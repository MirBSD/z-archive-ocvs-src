head	1.19;
access;
symbols
	tg-mergetmp-mirosx-1:1.19
	tg-mergefixes-1-branch:1.19.0.4
	tg-mergefixes-1-base:1.19
	MIROS_X:1.19.0.2
	MIROS_X_BASE:1.19
	tg-mergetmp-3:1.19
	MIRBSD_XP_MIRPPC:1.18.0.4
	MIRBSD_XP_SPARC_BASE:1.18
	MIRBSD_XP_SPARC:1.18.0.2
	MIRBSD_7quater:1.13
	cvs-200405160640:1.1.1.17
	cvs-200401271800:1.1.1.16
	cvs-200401261630:1.1.1.16
	cvs-200401021645:1.1.1.15
	MIRBSD_7_ALPHA:1.13.0.6
	MIRBSD_7:1.13.0.4
	cvs-200312222040:1.1.1.14
	MIRBSD_7ter:1.13
	MIRBSD_7_DEV:1.13.0.2
	cvs-200310020700:1.1.1.13
	cvs-200309271030:1.1.1.13
	cvs-200309251530:1.1.1.13
	cvs-200308302005:1.1.1.12
	cvs-200308221505:1.1.1.11
	cvs-200308171200:1.1.1.10
	ctm-3496:1.1.1.10
	ctm-3449:1.1.1.10
	ctm-3437:1.1.1.10
	cvs-200307191805:1.1.1.10
	ctm-3425:1.1.1.10
	cvs-200307091500:1.1.1.10
	cvs-200307072125:1.1.1.10
	ctm-3389:1.1.1.9
	cvs-200306291430:1.1.1.8
	ctm-3341:1.1.1.8
	MIRBSD_5:1.8
	cvs-200306082100:1.1.1.7
	ctm-3316:1.1.1.6
	ctm-3272:1.1.1.5
	ctm-3264:1.1.1.4
	cvs-200305071630:1.1.1.4
	MIRBSD_4:1.4
	ctm-3203:1.1.1.3
	cvs-20030410-1130:1.1.1.3
	ctm-3155:1.1.1.2
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@.\" @;


1.19
date	2004.12.07.22.17.24;	author tg;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.23.15.57.33;	author tg;	state Stab;
branches;
next	1.17;

1.17
date	2004.01.27.17.42.15;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.04.19.53.51;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.03.02.27.39;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.27.00.30.59;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.25.20.59.56;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.31.20.54.45;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.07.21.50.42;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.06.20.22.21;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.19.16.44.24;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.09.01.07.13;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.06.18.28.41;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.22.14.08.19;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.07.20.54.20;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.10.20.12.06;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.29.21.33.33;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.52.10;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.49.05;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.49.05;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.03.29.19.43.00;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.04.10.14.45.40;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.07.17.44.59;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.21.19.03.59;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.06.05.17.32.46;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.06.08.23.01.28;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.06.19.12.43.55;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.07.06.15.41.14;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.07.07.21.28.52;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2003.08.22.15.31.04;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2003.08.30.23.05.54;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2003.09.25.16.33.34;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2003.12.22.21.12.07;	author tg;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2004.01.02.18.02.53;	author tg;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2004.01.26.18.35.06;	author tg;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2004.05.16.08.28.57;	author tg;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove pf features which are broken:
 ($interface) -> did never work correctly
 antispoof -> dangerous, false sense of security, side impacts, only for lazies

remove kernel stuff accordingly, but don't change ABI

update documentation
remove orphaned documentation nobody maintains
@
text
@.\"	$MirBSD: src/share/man/man5/pf.conf.5,v 1.18 2004/05/23 15:57:33 tg Stab $
.\"	$OpenBSD: pf.conf.5,v 1.297 2004/05/09 10:51:55 dhartmei Exp $
.\"
.\" Copyright (c) 2002, Daniel Hartmeier
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"    - Redistributions of source code must retain the above copyright
.\"      notice, this list of conditions and the following disclaimer.
.\"    - Redistributions in binary form must reproduce the above
.\"      copyright notice, this list of conditions and the following
.\"      disclaimer in the documentation and/or other materials provided
.\"      with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
.\" FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
.\" COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
.\" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
.\" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
.\" CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
.\" ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd November 19, 2002
.Dt PF.CONF 5
.Os
.Sh NAME
.Nm pf.conf
.Nd packet filter configuration file
.Sh DESCRIPTION
The
.Xr pf 4
packet filter modifies, drops or passes packets according to rules or
definitions specified in
.Nm pf.conf .
.Sh STATEMENT ORDER
There are seven types of statements in
.Nm pf.conf :
.Bl -tag -width xxxx
.It Cm Macros
User-defined variables may be defined and used later, simplifying
the configuration file.
Macros must be defined before they are referenced in
.Nm pf.conf .
.It Cm Tables
Tables provide a mechanism for increasing the performance and flexibility of
rules with large numbers of source or destination addresses.
.It Cm Options
Options tune the behaviour of the packet filtering engine.
.It Cm Traffic Normalization Li (e.g. Em scrub )
Traffic normalization protects internal machines against inconsistencies
in Internet protocols and implementations.
.It Cm Queueing
Queueing provides rule-based bandwidth control.
.It Cm Translation Li (various forms of NAT)
Translation rules specify how addresses are to be mapped or redirected to
other addresses.
.It Cm Packet Filtering
Stateful and stateless packet filtering provides rule-based blocking or
passing of packets.
.El
.Pp
With the exception of
.Cm macros
and
.Cm tables ,
the types of statements should be grouped and appear in
.Nm pf.conf
in the order shown above, as this matches the operation of the underlying
packet filtering engine.
By default
.Xr pfctl 8
enforces this order (see
.Ar set require-order
below).
.Sh MACROS
Much like
.Xr cpp 1
or
.Xr m4 1 ,
macros can be defined that will later be expanded in context.
Macro names must start with a letter, and may contain letters, digits
and underscores.
Macro names may not be reserved words (for example
.Ar pass ,
.Ar in ,
.Ar out ) .
Macros are not expanded inside quotes.
.Pp
For example,
.Bd -literal -offset indent
ext_if = \&"kue0\&"
all_ifs = \&"{\&" $ext_if lo0 \&"}\&"
pass out on $ext_if from any to any keep state
pass in  on $ext_if proto tcp from any to any port 25 keep state
.Ed
.Sh TABLES
Tables are named structures which can hold a collection of addresses and
networks.
Lookups against tables in
.Xr pf 4
are relatively fast, making a single rule with tables much more efficient,
in terms of
processor usage and memory consumption, than a large number of rules which
differ only in IP address (either created explicitly or automatically by rule
expansion).
.Pp
Tables can be used as the source or destination of filter rules,
.Ar scrub
rules
or
translation rules such as
.Ar nat
or
.Ar rdr
(see below for details on the various rule types).
Tables can also be used for the redirect address of
.Ar nat
and
.Ar rdr
rules and in the routing options of filter rules, but only for
.Ar round-robin
pools.
.Pp
Tables can be defined with any of the following
.Xr pfctl 8
mechanisms.
As with macros, reserved words may not be used as table names.
.Bl -tag -width "manually"
.It Ar manually
Persistent tables can be manually created with the
.Ar add
or
.Ar replace
option of
.Xr pfctl 8 ,
before or after the ruleset has been loaded.
.It Pa pf.conf
Table definitions can be placed directly in this file, and loaded at the
same time as other rules are loaded, atomically.
Table definitions inside
.Nm pf.conf
use the
.Ar table
statement, and are especially useful to define non-persistent tables.
The contents of a pre-existing table defined without a list of addresses
to initialize it is not altered when
.Nm pf.conf
is loaded.
A table initialized with the empty list,
.Li { } ,
will be cleared on load.
.El
.Pp
Tables may be defined with the following two attributes:
.Bl -tag -width persist
.It Ar persist
The
.Ar persist
flag forces the kernel to keep the table even when no rules refer to it.
If the flag is not set, the kernel will automatically remove the table
when the last rule referring to it is flushed.
.It Ar const
The
.Ar const
flag prevents the user from altering the contents of the table once it
has been created.
Without that flag,
.Xr pfctl 8
can be used to add or remove addresses from the table at any time, even
when running with
.Xr securelevel 7
= 2.
.El
.Pp
For example,
.Bd -literal -offset indent
table <private> const { 10/8, 172.16/12, 192.168/16 }
table <badhosts> persist
block on fxp0 from { <private>, <badhosts> } to any
.Ed
.Pp
creates a table called private, to hold RFC 1918 private network
blocks, and a table called badhosts, which is initially empty.
A filter rule is set up to block all traffic coming from addresses listed in
either table.
The private table cannot have its contents changed and the badhosts table
will exist even when no active filter rules reference it.
Addresses may later be added to the badhosts table, so that traffic from
these hosts can be blocked by using
.Bd -literal -offset indent
# pfctl -t badhosts -Tadd 204.92.77.111
.Ed
.Pp
A table can also be initialized with an address list specified in one or more
external files, using the following syntax:
.Bd -literal -offset indent
table <spam> persist file \&"/etc/spammers\&" file \&"/etc/openrelays\&"
block on fxp0 from <spam> to any
.Ed
.Pp
The files
.Pa /etc/spammers
and
.Pa /etc/openrelays
list IP addresses, one per line.
Any lines beginning with a # are treated as comments and ignored.
In addition to being specified by IP address, hosts may also be
specified by their hostname.
When the resolver is called to add a hostname to a table,
.Em all
resulting IPv4 and IPv6 addresses are placed into the table.
IP addresses can also be entered in a table by specifying a valid interface
name or the
.Em self
keyword, in which case all addresses assigned to the interface(s) will be
added to the table.
.Sh OPTIONS
.Xr pf 4
may be tuned for various situations using the
.Ar set
command.
.Bl -tag -width xxxx
.It Ar set timeout
.Pp
.Bl -tag -width interval -compact
.It Ar interval
Interval between purging expired states and fragments.
.It Ar frag
Seconds before an unassembled fragment is expired.
.It Ar src.track
Length of time to retain a source tracking entry after the last state
expires.
.El
.Pp
When a packet matches a stateful connection, the seconds to live for the
connection will be updated to that of the
.Ar proto.modifier
which corresponds to the connection state.
Each packet which matches this state will reset the TTL.
Tuning these values may improve the performance of the
firewall at the risk of dropping valid idle connections.
.Pp
.Bl -tag -width xxxx -compact
.It Ar tcp.first
The state after the first packet.
.It Ar tcp.opening
The state before the destination host ever sends a packet.
.It Ar tcp.established
The fully established state.
.It Ar tcp.closing
The state after the first FIN has been sent.
.It Ar tcp.finwait
The state after both FINs have been exchanged and the connection is closed.
Some hosts (notably web servers on Solaris) send TCP packets even after closing
the connection.
Increasing
.Ar tcp.finwait
(and possibly
.Ar tcp.closing )
can prevent blocking of such packets.
.It Ar tcp.closed
The state after one endpoint sends an RST.
.El
.Pp
ICMP and UDP are handled in a fashion similar to TCP, but with a much more
limited set of states:
.Pp
.Bl -tag -width xxxx -compact
.It Ar udp.first
The state after the first packet.
.It Ar udp.single
The state if the source host sends more than one packet but the destination
host has never sent one back.
.It Ar udp.multiple
The state if both hosts have sent packets.
.It Ar icmp.first
The state after the first packet.
.It Ar icmp.error
The state after an ICMP error came back in response to an ICMP packet.
.El
.Pp
Other protocols are handled similarly to UDP:
.Pp
.Bl -tag -width xxxx -compact
.It Ar other.first
.It Ar other.single
.It Ar other.multiple
.El
.Pp
Timeout values can be reduced adaptively as the number of state table
entries grows.
.Pp
.Bl -tag -width xxxx -compact
.It Ar adaptive.start
When the number of state entries exceeds this value, adaptive scaling
begins.
All timeout values are scaled linearly with factor
(adaptive.end \- number of states) / (adaptive.end \- adaptive.start).
.It Ar adaptive.end
When reaching this number of state entries, all timeout values become
zero, effectively purging all state entries immediately.
This value is used to define the scale factor, it should not actually
be reached (set a lower state limit, see below).
.El
.Pp
These values can be defined both globally and for each rule.
When used on a per-rule basis, the values relate to the number of
states created by the rule, otherwise to the total number of
states.
.Pp
For example:
.Bd -literal -offset indent
set timeout tcp.first 120
set timeout tcp.established 86400
set timeout { adaptive.start 6000, adaptive.end 12000 }
set limit states 10000
.Ed
.Pp
With 9000 state table entries, the timeout values are scaled to 50%
(tcp.first 60, tcp.established 43200).
.Pp
.It Ar set loginterface
Enable collection of packet and byte count statistics for the given interface.
These statistics can be viewed using
.Bd -literal -offset indent
# pfctl -s info
.Ed
.Pp
In this example
.Xr pf 4
collects statistics on the interface named dc0:
.Bd -literal -offset indent
set loginterface dc0
.Ed
.Pp
One can disable the loginterface using:
.Bd -literal -offset indent
set loginterface none
.Ed
.Pp
.It Ar set limit
Sets hard limits on the memory pools used by the packet filter.
See
.Xr pool 9
for an explanation of memory pools.
.Pp
For example,
.Bd -literal -offset indent
set limit states 20000
.Ed
.Pp
sets the maximum number of entries in the memory pool used by state table
entries (generated by
.Ar keep state
rules) to 20000.
Using
.Bd -literal -offset indent
set limit frags 20000
.Ed
.Pp
sets the maximum number of entries in the memory pool used for fragment
reassembly (generated by
.Ar scrub
rules) to 20000.
Finally,
.Bd -literal -offset indent
set limit src-nodes 2000
.Ed
.Pp
sets the maximum number of entries in the memory pool used for tracking
source IP addresses (generated by the
.Ar sticky-address
and
.Ar source-track
options) to 2000.
.Pp
These can be combined:
.Bd -literal -offset indent
set limit { states 20000, frags 20000, src-nodes 2000 }
.Ed
.Pp
.It Ar set optimization
Optimize the engine for one of the following network environments:
.Pp
.Bl -tag -width xxxx -compact
.It Ar normal
A normal network environment.
Suitable for almost all networks.
.It Ar high-latency
A high-latency environment (such as a satellite connection).
.It Ar satellite
Alias for
.Ar high-latency .
.It Ar aggressive
Aggressively expire connections.
This can greatly reduce the memory usage of the firewall at the cost of
dropping idle connections early.
.It Ar conservative
Extremely conservative settings.
Avoid dropping legitimate connections at the
expense of greater memory utilization (possibly much greater on a busy
network) and slightly increased processor utilization.
.El
.Pp
For example:
.Bd -literal -offset indent
set optimization aggressive
.Ed
.Pp
.It Ar set block-policy
The
.Ar block-policy
option sets the default behaviour for the packet
.Ar block
action:
.Pp
.Bl -tag -width xxxxxxxx -compact
.It Ar drop
Packet is silently dropped.
.It Ar return
A TCP RST is returned for blocked TCP packets,
an ICMP UNREACHABLE is returned for blocked UDP packets,
and all other packets are silently dropped.
.El
.Pp
For example:
.Bd -literal -offset indent
set block-policy return
.Ed
.It Ar set state-policy
The
.Ar state-policy
option sets the default behaviour for states:
.Pp
.Bl -tag -width group-bound -compact
.It Ar if-bound
States are bound to interface.
.It Ar group-bound
States are bound to interface group (i.e. ppp)
.It Ar floating
States can match packets on any interfaces (the default).
.El
.Pp
For example:
.Bd -literal -offset indent
set state-policy if-bound
.Ed
.It Ar set require-order
By default
.Xr pfctl 8
enforces an ordering of the statement types in the ruleset to:
.Em options ,
.Em normalization ,
.Em queueing ,
.Em translation ,
.Em filtering .
Setting this option to
.Ar no
disables this enforcement.
There may be non-trivial and non-obvious implications to an out of
order ruleset.
Consider carefully before disabling the order enforcement.
.It Ar set fingerprints
Load fingerprints of known operating systems from the given filename.
By default fingerprints of known operating systems are automatically
loaded from
.Xr pf.os 5
in
.Pa /etc
but can be overridden via this option.
Setting this option may leave a small period of time where the fingerprints
referenced by the currently active ruleset are inconsistent until the new
ruleset finishes loading.
.Pp
For example:
.Pp
.Dl set fingerprints \&"/etc/pf.os.devel\&"
.Pp
.It Ar set debug
Set the debug
.Ar level
to one of the following:
.Pp
.Bl -tag -width xxxxxxxxxxxx -compact
.It Ar none
Don't generate debug messages.
.It Ar urgent
Generate debug messages only for serious errors.
.It Ar misc
Generate debug messages for various errors.
.It Ar loud
Generate debug messages for common conditions.
.El
.El
.Sh TRAFFIC NORMALIZATION
Traffic normalization is used to sanitize packet content in such
a way that there are no ambiguities in packet interpretation on
the receiving side.
The normalizer does IP fragment reassembly to prevent attacks
that confuse intrusion detection systems by sending overlapping
IP fragments.
Packet normalization is invoked with the
.Ar scrub
directive.
.Pp
.Ar scrub
has the following options:
.Bl -tag -width xxxx
.It Ar no-df
Clears the
.Ar dont-fragment
bit from a matching IP packet.
Some operating systems are known to generate fragmented packets with the
.Ar dont-fragment
bit set.
This is particularly true with NFS.
.Ar Scrub
will drop such fragmented
.Ar dont-fragment
packets unless
.Ar no-df
is specified.
.Pp
Unfortunately some operating systems also generate their
.Ar dont-fragment
packets with a zero IP identification field.
Clearing the
.Ar dont-fragment
bit on packets with a zero IP ID may cause deleterious results if an
upstream router later fragments the packet.
Using the
.Ar random-id
modifier (see below) is recommended in combination with the
.Ar no-df
modifier to ensure unique IP identifiers.
.It Ar min-ttl <number>
Enforces a minimum TTL for matching IP packets.
.It Ar max-mss <number>
Enforces a maximum MSS for matching TCP packets.
.It Ar random-id
Replaces the IP identification field with random values to compensate
for predictable values generated by many hosts.
This option only applies to outgoing packets that are not fragmented
after the optional fragment reassembly.
.It Ar fragment reassemble
Using
.Ar scrub
rules, fragments can be reassembled by normalization.
In this case, fragments are buffered until they form a complete
packet, and only the completed packet is passed on to the filter.
The advantage is that filter rules have to deal only with complete
packets, and can ignore fragments.
The drawback of caching fragments is the additional memory cost.
But the full reassembly method is the only method that currently works
with NAT.
This is the default behavior of a
.Ar scrub
rule if no fragmentation modifier is supplied.
.It Ar fragment crop
The default fragment reassembly method is expensive, hence the option
to crop is provided.
In this case,
.Xr pf 4
will track the fragments and cache a small range descriptor.
Duplicate fragments are dropped and overlaps are cropped.
Thus data will only occur once on the wire with ambiguities resolving to
the first occurrence.
Unlike the
.Ar fragment reassemble
modifier, fragments are not buffered, they are passed as soon as they
are received.
The
.Ar fragment crop
reassembly mechanism does not yet work with NAT.
.Pp
.It Ar fragment drop-ovl
This option is similar to the
.Ar fragment crop
modifier except that all overlapping or duplicate fragments will be
dropped, and all further corresponding fragments will be
dropped as well.
.It Ar reassemble tcp
Statefully normalizes TCP connections.
.Ar scrub reassemble tcp
rules may not have the direction (in/out) specified.
.Ar reassemble tcp
performs the following normalizations:
.Pp
.Bl -tag -width timeout -compact
.It ttl
Neither side of the connection is allowed to reduce their IP TTL.
An attacker may send a packet such that it reaches the firewall, affects
the firewall state, and expires before reaching the destination host.
.Ar reassemble tcp
will raise the TTL of all packets back up to the highest value seen on
the connection.
.It timeout modulation
Modern TCP stacks will send a timestamp on every TCP packet and echo
the other endpoint's timestamp back to them.
Many operating systems will merely start the timestamp at zero when
first booted, and increment it several times a second.
The uptime of the host can be deduced by reading the timestamp and multiplying
by a constant.
Also observing several different timestamps can be used to count hosts
behind a NAT device.
And spoofing TCP packets into a connection requires knowing or guessing
valid timestamps.
Timestamps merely need to be monotonically increasing and not derived off a
guessable base time.
.Ar reassemble tcp
will cause
.Ar scrub
to modulate the TCP timestamps with a random number.
.It extended PAWS checks
There is a problem with TCP on long fat pipes, in that a packet might get
delayed for longer than it takes the connection to wrap its 32-bit sequence
space.
In such an occurance, the old packet would be indistinguishable from a
new packet and would be accepted as such.
The solution to this is called PAWS: Protection Against Wrapped Sequence
numbers.
It protects against it by making sure the timestamp on each packet does
not go backwards.
.Ar reassemble tcp
also makes sure the timestamp on the packet does not go forward more
than the RFC allows.
By doing this,
.Xr pf 4
artificially extends the security of TCP sequence numbers by 10 to 18
bits when the host uses appropriately randomized timestamps, since a
blind attacker would have to guess the timestamp as well.
.El
.El
.Pp
For example,
.Bd -literal -offset indent
scrub in on $ext_if all fragment reassemble
.Ed
.Sh QUEUEING
Packets can be assigned to queues for the purpose of bandwidth
control.
At least two declarations are required to configure queues, and later
any packet filtering rule can reference the defined queues by name.
During the filtering component of
.Nm pf.conf ,
the last referenced
.Ar queue
name is where any packets from
.Ar pass
rules will be queued, while for
.Ar block
rules it specifies where any resulting ICMP or TCP RST
packets should be queued.
The
.Ar scheduler
defines the algorithm used to decide which packets get delayed, dropped, or
sent out immediately.
There are three
.Ar schedulers
currently supported.
.Bl -tag -width xxxx
.It Ar cbq
Class Based Queueing.
.Ar Queues
attached to an interface build a tree, thus each
.Ar queue
can have further child
.Ar queues .
Each queue can have a
.Ar priority
and a
.Ar bandwidth
assigned.
.Ar Priority
mainly controls the time packets take to get sent out, while
.Ar bandwidth
has primarily effects on throughput.
.It Ar priq
Priority Queueing.
.Ar Queues
are flat attached to the interface, thus,
.Ar queues
cannot have further child
.Ar queues .
Each
.Ar queue
has a unique
.Ar priority
assigned, ranging from 0 to 15.
Packets in the
.Ar queue
with the highest
.Ar priority
are processed first.
.It Ar hfsc
Hierarchical Fair Service Curve.
.Ar Queues
attached to an interface build a tree, thus each
.Ar queue
can have further child
.Ar queues .
Each queue can have a
.Ar priority
and a
.Ar bandwidth
assigned.
.Ar Priority
mainly controls the time packets take to get sent out, while
.Ar bandwidth
has primarily effects on throughput.
.El
.Pp
The interfaces on which queueing should be activated are declared using
the
.Ar altq on
declaration.
.Ar altq on
has the following keywords:
.Bl -tag -width xxxx
.It Ar <interface>
Queueing is enabled on the named interface.
.It Ar <scheduler>
Specifies which queueing scheduler to use.
Currently supported values
are
.Ar cbq
for Class Based Queueing,
.Ar priq
for Priority Queueing and
.Ar hfsc
for the Hierarchical Fair Service Curve scheduler.
.It Ar bandwidth <bw>
The maximum bitrate for all queues on an
interface may be specified using the
.Ar bandwidth
keyword.
The value can be specified as an absolute value or as a
percentage of the interface bandwidth.
When using an absolute value, the suffixes
.Ar b ,
.Ar Kib ,
.Ar Mib ,
and
.Ar Gib
are used to represent bits, kibibits, mebibits, and
gibibits per second, respectively.
The value must not exceed the interface bandwidth.
If
.Ar bandwidth
is not specified, the interface bandwidth is used.
.It Ar qlimit <limit>
The maximum number of packets held in the queue.
The default is 50.
.It Ar tbrsize <size>
Adjusts the size, in bytes, of the token bucket regulator.
If not specified, heuristics based on the
interface bandwidth are used to determine the size.
.It Ar queue <list>
Defines a list of subqueues to create on an interface.
.El
.Pp
In the following example, the interface dc0
should queue up to 5 Mbit/s in four second-level queues using
Class Based Queueing.
Those four queues will be shown in a later example.
.Bd -literal -offset indent
altq on dc0 cbq bandwidth 5000000b queue { std, http, mail, ssh }
.Ed
.Pp
Once interfaces are activated for queueing using the
.Ar altq
directive, a sequence of
.Ar queue
directives may be defined.
The name associated with a
.Ar queue
must match a queue defined in the
.Ar altq
directive (e.g. mail), or, except for the
.Ar priq
.Ar scheduler ,
in a parent
.Ar queue
declaration.
The following keywords can be used:
.Bl -tag -width xxxx
.It Ar on <interface>
Specifies the interface the queue operates on.
If not given, it operates on all matching interfaces.
.It Ar bandwidth <bw>
Specifies the maximum bitrate to be processed by the queue.
This value must not exceed the value of the parent
.Ar queue
and can be specified as an absolute value or a percentage of the parent
queue's bandwidth.
The
.Ar priq
scheduler does not support bandwidth specification.
.It Ar priority <level>
Between queues a priority level can be set.
For
.Ar cbq
and
.Ar hfsc ,
the range is 0 to 7 and for
.Ar priq ,
the range is 0 to 15.
The default for all is 1.
.Ar Priq
queues with a higher priority are always served first.
.Ar Cbq
and
.Ar Hfsc
queues with a higher priority are preferred in the case of overload.
.It Ar qlimit <limit>
The maximum number of packets held in the queue.
The default is 50.
.El
.Pp
The
.Ar scheduler
can get additional parameters with
.Ar <scheduler> Ns Li \&( Ar <parameters> No \&) .
Parameters are as follows:
.Bl -tag -width Fl
.It Ar default
Packets not matched by another queue are assigned to this one.
Exactly one default queue is required.
.It Ar red
Enable RED (Random Early Detection) on this queue.
RED drops packets with a probability proportional to the average
queue length.
.It Ar rio
Enables RIO on this queue.
RIO is RED with IN/OUT, thus running
RED two times more than RIO would achieve the same effect.
RIO is currently not supported in the GENERIC kernel.
.It Ar ecn
Enables ECN (Explicit Congestion Notification) on this queue.
ECN implies RED.
.El
.Pp
The
.Ar cbq
.Ar scheduler
supports an additional option:
.Bl -tag -width Fl
.It Ar borrow
The queue can borrow bandwidth from the parent.
.El
.Pp
The
.Ar hfsc
.Ar scheduler
supports some additional options:
.Bl -tag -width Fl
.It Ar realtime <sc>
The minimum required bandwidth for the queue.
.It Ar upperlimit <sc>
The maximum allowed bandwidth for the queue.
.It Ar linkshare <sc>
The bandwidth share of a backlogged queue.
.El
.Pp
<sc> is an acronym for
.Ar service curve .
.Pp
The format for service curve specifications is
.Ar ( m1 , d , m2 ) .
.Ar m2
controls the bandwidth assigned to the queue.
.Ar m1
and
.Ar d
are optional and can be used to control the initial bandwidth assignment.
For the first
.Ar d
milliseconds the queue gets the bandwidth given as
.Ar m1 ,
afterwards the value given in
.Ar m2 .
.Pp
Furthermore, with
.Ar cbq
and
.Ar hfsc ,
child queues can be specified as in an
.Ar altq
declaration, thus building a tree of queues using a part of
their parent's bandwidth.
.Pp
Packets can be assigned to queues based on filter rules by using the
.Ar queue
keyword.
Normally only one
.Ar queue
is specified; when a second one is specified it will instead be used for
packets which have a
.Em TOS
of
.Em lowdelay
and for TCP ACKs with no data payload.
.Pp
To continue the previous example, the examples below would specify the
four referenced
queues, plus a few child queues.
Interactive
.Xr ssh 1
sessions get priority over bulk transfers like
.Xr scp 1
and
.Xr sftp 1 .
The queues may then be referenced by filtering rules (see
.Sx PACKET FILTERING
below).
.Bd -literal
queue std bandwidth 10% cbq(default)
queue http bandwidth 60% priority 2 cbq(borrow red) \e
      { employees, developers }
queue  developers bandwidth 75% cbq(borrow)
queue  employees bandwidth 15%
queue mail bandwidth 10% priority 0 cbq(borrow ecn)
queue ssh bandwidth 20% cbq(borrow) { ssh_interactive, ssh_bulk }
queue  ssh_interactive priority 7
queue  ssh_bulk priority 0

block return out on dc0 inet all queue std
pass out on dc0 inet proto tcp from $developerhosts to any port 80 \e
      keep state queue developers
pass out on dc0 inet proto tcp from $employeehosts to any port 80 \e
      keep state queue employees
pass out on dc0 inet proto tcp from any to any port 22 \e
      keep state queue(ssh_bulk, ssh_interactive)
pass out on dc0 inet proto tcp from any to any port 25 \e
      keep state queue mail
.Ed
.Sh TRANSLATION
Translation rules modify either the source or destination address of the
packets associated with a stateful connection.
A stateful connection is automatically created to track packets matching
such a rule as long as they are not blocked by the filtering section of
.Nm pf.conf .
The translation engine modifies the specified address and/or port in the
packet, recalculates IP, TCP and UDP checksums as necessary, and passes it to
the packet filter for evaluation.
.Pp
Since translation occurs before filtering the filter
engine will see packets as they look after any
addresses and ports have been translated.
Filter rules will therefore have to filter based on the translated
address and port number.
Packets that match a translation rule are only automatically passed if
the
.Ar pass
modifier is given, otherwise they are
still subject to
.Ar block
and
.Ar pass
rules.
.Pp
The state entry created permits
.Xr pf 4
to keep track of the original address for traffic associated with that state
and correctly direct return traffic for that connection.
.Pp
Various types of translation are possible with pf:
.Bl -tag -width xxxx
.It Ar binat
A
.Ar binat
rule specifies a bidirectional mapping between an external IP netblock
and an internal IP netblock.
.It Ar nat
A
.Ar nat
rule specifies that IP addresses are to be changed as the packet
traverses the given interface.
This technique allows one or more IP addresses
on the translating host to support network traffic for a larger range of
machines on an "inside" network.
Although in theory any IP address can be used on the inside, it is strongly
recommended that one of the address ranges defined by RFC 1918 be used.
These netblocks are:
.Bd -literal
10.0.0.0 - 10.255.255.255 (all of net 10, i.e., 10/8)
172.16.0.0 - 172.31.255.255 (i.e., 172.16/12)
192.168.0.0 - 192.168.255.255 (i.e., 192.168/16)
.Ed
.It Pa rdr
The packet is redirected to another destination and possibly a
different port.
.Ar rdr
rules can optionally specify port ranges instead of single ports.
rdr ... port 2000:2999 -> ... port 4000
redirects ports 2000 to 2999 (inclusive) to port 4000.
rdr ... port 2000:2999 -> ... port 4000:*
redirects port 2000 to 4000, 2001 to 4001, ..., 2999 to 4999.
.El
.Pp
In addition to modifying the address, some translation rules may modify
source or destination ports for
.Xr tcp 4
or
.Xr udp 4
connections; implicitly in the case of
.Ar nat
rules and explicitly in the case of
.Ar rdr
rules.
Port numbers are never translated with a
.Ar binat
rule.
.Pp
For each packet processed by the translator, the translation rules are
evaluated in sequential order, from first to last.
The first matching rule decides what action is taken.
.Pp
The
.Ar no
option prefixed to a translation rule causes packets to remain untranslated,
much in the same way as
.Ar drop quick
works in the packet filter (see below).
If no rule matches the packet it is passed to the filter engine unmodified.
.Pp
Translation rules apply only to packets that pass through
the specified interface, and if no interface is specified,
translation is applied to packets on all interfaces.
For instance, redirecting port 80 on an external interface to an internal
web server will only work for connections originating from the outside.
Connections to the address of the external interface from local hosts will
not be redirected, since such packets do not actually pass through the
external interface.
Redirections cannot reflect packets back through the interface they arrive
on, they can only be redirected to hosts connected to different interfaces
or to the firewall itself.
.Pp
Note that redirecting external incoming connections to the loopback
address, as in
.Bd -literal -offset indent
rdr on ne3 inet proto tcp to port 8025 -> 127.0.0.1 port 25
.Ed
.Pp
will effectively allow an external host to connect to daemons
bound solely to the loopback address, circumventing the traditional
blocking of such connections on a real interface.
Unless this effect is desired, any of the local non-loopback addresses
should be used as redirection target instead, which allows external
connections only to daemons bound to this address or not bound to
any address.
.Pp
See
.Sx TRANSLATION EXAMPLES
below.
.Sh PACKET FILTERING
.Xr pf 4
has the ability to
.Ar block
and
.Ar pass
packets based on attributes of their layer 3 (see
.Xr ip 4
and
.Xr ip6 4 )
and layer 4 (see
.Xr icmp 4 ,
.Xr icmp6 4 ,
.Xr tcp 4 ,
.Xr udp 4 )
headers.
In addition, packets may also be
assigned to queues for the purpose of bandwidth control.
.Pp
For each packet processed by the packet filter, the filter rules are
evaluated in sequential order, from first to last.
The last matching rule decides what action is taken.
.Pp
The following actions can be used in the filter:
.Bl -tag -width xxxx
.It Ar block
The packet is blocked.
There are a number of ways in which a
.Ar block
rule can behave when blocking a packet.
The default behaviour is to
.Ar drop
packets silently, however this can be overridden or made
explicit either globally, by setting the
.Ar block-policy
option, or on a per-rule basis with one of the following options:
.Pp
.Bl -tag -width xxxx -compact
.It Ar drop
The packet is silently dropped.
.It Ar return-rst
This applies only to
.Xr tcp 4
packets, and issues a TCP RST which closes the
connection.
.It Ar return-icmp
.It Ar return-icmp6
This causes ICMP messages to be returned for packets which match the rule.
By default this is an ICMP UNREACHABLE message, however this
can be overridden by specifying a message as a code or number.
.It Ar return
This causes a TCP RST to be returned for
.Xr tcp 4
packets and an ICMP UNREACHABLE for UDP and other packets.
.El
.Pp
Options returning packets have no effect if
.Xr pf 4
operates on a
.Xr bridge 4 .
.It Ar pass
The packet is passed.
.El
.Pp
If no rule matches the packet, the default action is
.Ar pass .
.Pp
To block everything by default and only pass packets
that match explicit rules, one uses
.Bd -literal -offset indent
block all
.Ed
.Pp
as the first filter rule.
.Pp
See
.Sx FILTER EXAMPLES
below.
.Sh PARAMETERS
The rule parameters specify the packets to which a rule applies.
A packet always comes in on, or goes out through, one interface.
Most parameters are optional.
If a parameter is specified, the rule only applies to packets with
matching attributes.
Certain parameters can be expressed as lists, in which case
.Xr pfctl 8
generates all needed rule combinations.
.Bl -tag -width xxxx
.It Ar in No or Ar out
This rule applies to incoming or outgoing packets.
If neither
.Ar in
nor
.Ar out
are specified, the rule will match packets in both directions.
.It Ar log
In addition to the action specified, a log message is generated.
All packets for that connection are logged, unless the
.Ar keep state ,
.Ar modulate state
or
.Ar synproxy state
options are specified, in which case only the
packet that establishes the state is logged.
(See
.Ar keep state ,
.Ar modulate state
and
.Ar synproxy state
below).
The logged packets are sent to the
.Xr pflog 4
interface.
This interface is monitored by the
.Xr pflogd 8
logging daemon, which dumps the logged packets to the file
.Pa /var/log/pflog
in
.Xr pcap 3
binary format.
.It Ar log-all
Used with
.Ar keep state ,
.Ar modulate state
or
.Ar synproxy state
rules to force logging of all packets for a connection.
As with
.Ar log ,
packets are logged to
.Xr pflog 4 .
.It Ar quick
If a packet matches a rule which has the
.Ar quick
option set, this rule
is considered the last matching rule, and evaluation of subsequent rules
is skipped.
.It Ar on <interface>
This rule applies only to packets coming in on, or going out through, this
particular interface.
It is also possible to simply give the interface driver name, like ppp or fxp,
to make the rule match packets flowing through a group of interfaces.
.It Ar <af>
This rule applies only to packets of this address family.
Supported values are
.Ar inet
and
.Ar inet6 .
.It Ar proto <protocol>
This rule applies only to packets of this protocol.
Common protocols are
.Xr icmp 4 ,
.Xr icmp6 4 ,
.Xr tcp 4 ,
and
.Xr udp 4 .
For a list of all the protocol name to number mappings used by
.Xr pfctl 8 ,
see the file
.Em /etc/protocols .
.It Xo
.Ar from <source> port <source> os <source>
.Ar to <dest> port <dest>
.Xc
This rule applies only to packets with the specified source and destination
addresses and ports.
.Pp
Addresses can be specified in CIDR notation (matching netblocks), as
symbolic host names or interface names, or as any of the following keywords:
.Pp
.Bl -tag -width xxxxxxxxxxxx -compact
.It Ar any
Any address.
.It Ar no-route
Any address which is not currently routable.
.It Ar <table>
Any address that matches the given table.
.El
.Pp
Interface names can have modifiers appended:
.Pp
.Bl -tag -width xxxxxxxxxxxx -compact
.It Ar :network
Translates to the network(s) attached to the interface.
.It Ar :broadcast
Translates to the interface's broadcast address(es).
.It Ar :peer
Translates to the point to point interface's peer address(es).
.It Ar :0
Do not include interface aliases.
.El
.Pp
Host names may also have the
.Ar :0
option appended to restrict the name resolution to the first of each
v4 and v6 address found.
.Pp
Host name resolution and interface to address translation are done at
ruleset load-time.
When the address of an interface (or host name) changes (under DHCP or PPP,
for instance), the ruleset must be reloaded for the change to be reflected
in the kernel.
.Pp
Ports can be specified either by number or by name.
For example, port 80 can be specified as
.Em www .
For a list of all port name to number mappings used by
.Xr pfctl 8 ,
see the file
.Pa /etc/services .
.Pp
Ports and ranges of ports are specified by using these operators:
.Bd -literal -offset indent
=	(equal)
!=	(unequal)
<	(less than)
<=	(less than or equal)
>	(greater than)
>=	(greater than or equal)
:	(range including boundaries)
><	(range excluding boundaries)
<>	(except range)
.Ed
.Pp
><, <> and :
are binary operators (they take two arguments).
For instance:
.Bl -tag -width Fl
.It Ar port 2000:2004
means
.Sq all ports >= 2000 and <= 2004 ,
hence ports 2000, 2001, 2002, 2003 and 2004.
.It Ar port 2000 >< 2004
means
.Sq all ports > 2000 and < 2004 ,
hence ports 2001, 2002 and 2003.
.It Ar port 2000 <> 2004
means
.Sq all ports < 2000 or > 2004 ,
hence ports 1-1999 and 2005-65535.
.El
.Pp
The operating system of the source host can be specified in the case of TCP
rules with the
.Ar OS
modifier.
See the
.Sx OPERATING SYSTEM FINGERPRINTING
section for more information.
.Pp
The host, port and OS specifications are optional, as in the following examples:
.Bd -literal -offset indent
pass in all
pass in from any to any
pass in proto tcp from any port <= 1024 to any
pass in proto tcp from any to any port 25
pass in proto tcp from 10.0.0.0/8 port > 1024 \e
      to ! 10.1.2.3 port != ssh
pass in proto tcp from any os "OpenBSD" flags S/SA
.Ed
.It Ar all
This is equivalent to "from any to any".
.It Ar group <group>
Similar to
.Ar user ,
this rule only applies to packets of sockets owned by the specified group.
.It Ar user <user>
This rule only applies to packets of sockets owned by the specified user.
For outgoing connections initiated from the firewall, this is the user
that opened the connection.
For incoming connections to the firewall itself, this is the user that
listens on the destination port.
For forwarded connections, where the firewall is not a connection endpoint,
the user and group are
.Em unknown .
.Pp
All packets, both outgoing and incoming, of one connection are associated
with the same user and group.
Only TCP and UDP packets can be associated with users; for other protocols
these parameters are ignored.
.Pp
User and group refer to the effective (as opposed to the real) IDs, in
case the socket is created by a setuid/setgid process.
User and group IDs are stored when a socket is created;
when a process creates a listening socket as root (for instance, by
binding to a privileged port) and subsequently changes to another
user ID (to drop privileges), the credentials will remain root.
.Pp
User and group IDs can be specified as either numbers or names.
The syntax is similar to the one for ports.
The value
.Em unknown
matches packets of forwarded connections.
.Em unknown
can only be used with the operators
.Cm =
and
.Cm != .
Other constructs like
.Cm user >= unknown
are invalid.
Forwarded packets with unknown user and group ID match only rules
that explicitly compare against
.Em unknown
with the operators
.Cm =
or
.Cm != .
For instance
.Cm user >= 0
does not match forwarded packets.
The following example allows only selected users to open outgoing
connections:
.Bd -literal -offset indent
block out proto { tcp, udp } all
pass  out proto { tcp, udp } all \e
      user { < 1000, dhartmei } keep state
.Ed
.It Ar flags <a>/<b> | /<b>
This rule only applies to TCP packets that have the flags
.Ar <a>
set out of set
.Ar <b> .
Flags not specified in
.Ar <b>
are ignored.
The flags are: (F)IN, (S)YN, (R)ST, (P)USH, (A)CK, (U)RG, (E)CE, and C(W)R.
.Bl -tag -width Fl
.It Ar flags S/S
Flag SYN is set.
The other flags are ignored.
.It Ar flags S/SA
Out of SYN and ACK, exactly SYN may be set.
SYN, SYN+PSH and SYN+RST match, but SYN+ACK, ACK and ACK+RST do not.
This is more restrictive than the previous example.
.It Ar flags /SFRA
If the first set is not specified, it defaults to none.
All of SYN, FIN, RST and ACK must be unset.
.El
.It Ar icmp-type <type> code <code>
.It Ar icmp6-type <type> code <code>
This rule only applies to ICMP or ICMPv6 packets with the specified type
and code.
This parameter is only valid for rules that cover protocols ICMP or
ICMP6.
The protocol and the ICMP type indicator (icmp-type or icmp6-type)
must match.
.It Ar allow-opts
By default, packets which contain IP options are blocked.
When
.Ar allow-opts
is specified for a
.Ar pass
rule, packets that pass the filter based on that rule (last matching)
do so even if they contain IP options.
For packets that match state, the rule that initially created the
state is used.
The implicit
.Ar pass
rule that is used when a packet does not match any rules does not
allow IP options.
.It Ar label <string>
Adds a label (name) to the rule, which can be used to identify the rule.
For instance,
pfctl -s labels
shows per-rule statistics for rules that have labels.
.Pp
The following macros can be used in labels:
.Pp
.Bl -tag -width $srcaddr -compact -offset indent
.It Ar $if
The interface.
.It Ar $srcaddr
The source IP address.
.It Ar $dstaddr
The destination IP address.
.It Ar $srcport
The source port specification.
.It Ar $dstport
The destination port specification.
.It Ar $proto
The protocol name.
.It Ar $nr
The rule number.
.El
.Pp
For example:
.Bd -literal -offset indent
ips = \&"{ 1.2.3.4, 1.2.3.5 }\&"
pass in proto tcp from any to $ips \e
      port > 1023 label \&"$dstaddr:$dstport\&"
.Ed
.Pp
expands to
.Bd -literal -offset indent
pass in inet proto tcp from any to 1.2.3.4 \e
      port > 1023 label \&"1.2.3.4:>1023\&"
pass in inet proto tcp from any to 1.2.3.5 \e
      port > 1023 label \&"1.2.3.5:>1023\&"
.Ed
.Pp
The macro expansion for the
.Ar label
directive occurs only at configuration file parse time, not during runtime.
.It Ar queue <queue> | ( <queue> , <queue> )
Packets matching this rule will be assigned to the specified queue.
If two queues are given, packets which have a
.Em tos
of
.Em lowdelay
and TCP ACKs with no data payload will be assigned to the second one.
See
.Sx QUEUEING
for setup details.
.Pp
For example:
.Bd -literal -offset indent
pass in proto tcp to port 25 queue mail
pass in proto tcp to port 22 queue(ssh_bulk, ssh_prio)
.Ed
.It Ar tag <string>
Packets matching this rule will be tagged with the
specified string.
The tag acts as an internal marker that can be used to
identify these packets later on.
This can be used, for example, to provide trust between
interfaces and to determine if packets have been
processed by translation rules.
Tags are
.Qq sticky ,
meaning that the packet will be tagged even if the rule
is not the last matching rule.
Further matching rules can replace the tag with a
new one but will not remove a previously applied tag.
A packet is only ever assigned one tag at a time.
.Ar pass
rules that use the
.Ar tag
keyword must also use
.Ar keep state ,
.Ar modulate state
or
.Ar synproxy state .
Packet tagging can be done during
.Ar nat ,
.Ar rdr ,
or
.Ar binat
rules in addition to filter rules.
Tags take the same macros as labels (see above).
.It Ar tagged <string>
Used with filter rules to specify that packets must already
be tagged with the given tag in order to match the rule.
Inverse tag matching can also be done
by specifying the
.Cm \&!
operator before the
.Ar tagged
keyword.
.It Ar probability <number>
A probability attribute can be attached to a rule, with a value set between
0 and 1, bounds not included.
In that case, the rule will be honoured using the given probability value
only.
For example, the following rule will drop 20% of incoming ICMP packets:
.Bd -literal -offset indent
block in proto icmp probability 20%
.Ed
.El
.Sh ROUTING
If a packet matches a rule with a route option set, the packet filter will
route the packet according to the type of route option.
When such a rule creates state, the route option is also applied to all
packets matching the same connection.
.Bl -tag -width xxxx
.It Ar fastroute
The
.Ar fastroute
option does a normal route lookup to find the next hop for the packet.
.It Ar route-to
The
.Ar route-to
option routes the packet to the specified interface with an optional address
for the next hop.
When a
.Ar route-to
rule creates state, only packets that pass in the same direction as the
filter rule specifies will be routed in this way.
Packets passing in the opposite direction (replies) are not affected
and are routed normally.
.It Ar reply-to
The
.Ar reply-to
option is similar to
.Ar route-to ,
but routes packets that pass in the opposite direction (replies) to the
specified interface.
Opposite direction is only defined in the context of a state entry, and
.Ar reply-to
is useful only in rules that create state.
It can be used on systems with multiple external connections to
route all outgoing packets of a connection through the interface
the incoming connection arrived through (symmetric routing enforcement).
.It Ar dup-to
The
.Ar dup-to
option creates a duplicate of the packet and routes it like
.Ar route-to .
The original packet gets routed as it normally would.
.El
.Sh POOL OPTIONS
For
.Ar nat
and
.Ar rdr
rules, (as well as for the
.Ar route-to ,
.Ar reply-to
and
.Ar dup-to
rule options) for which there is a single redirection address which has a
subnet mask smaller than 32 for IPv4 or 128 for IPv6 (more than one IP
address), a variety of different methods for assigning this address can be
used:
.Bl -tag -width xxxx
.It Ar bitmask
The
.Ar bitmask
option applies the network portion of the redirection address to the address
to be modified (source with
.Ar nat ,
destination with
.Ar rdr ) .
.It Ar random
The
.Ar random
option selects an address at random within the defined block of addresses.
.It Ar source-hash
The
.Ar source-hash
option uses a hash of the source address to determine the redirection address,
ensuring that the redirection address is always the same for a given source.
An optional key can be specified after this keyword either in hex or as a
string; by default
.Xr pfctl 8
randomly generates a key for source-hash every time the
ruleset is reloaded.
.It Ar round-robin
The
.Ar round-robin
option loops through the redirection address(es).
.Pp
When more than one redirection address is specified,
.Ar round-robin
is the only permitted pool type.
.It Ar static-port
With
.Ar nat
rules, the
.Ar static-port
option prevents
.Xr pf 4
from modifying the source port on TCP and UDP packets.
.El
.Pp
Additionally, the
.Ar sticky-address
option can be specified to help ensure that multiple connections from the
same source are mapped to the same redirection address.
This option can be used with the
.Ar random
and
.Ar round-robin
pool options.
Note that by default these associations are destroyed as soon as there are
no longer states which refer to them; in order to make the mappings last
beyond the lifetime of the states, increase the global options with
.Ar set timeout source-track
See
.Sx STATEFUL TRACKING OPTIONS
for more ways to control the source tracking.
.Sh STATEFUL INSPECTION
.Xr pf 4
is a stateful packet filter, which means it can track the state of
a connection.
Instead of passing all traffic to port 25, for instance, it is possible
to pass only the initial packet, and then begin to keep state.
Subsequent traffic will flow because the filter is aware of the connection.
.Pp
If a packet matches a
.Ar pass ... keep state
rule, the filter creates a state for this connection and automatically
lets pass all subsequent packets of that connection.
.Pp
Before any rules are evaluated, the filter checks whether the packet
matches any state.
If it does, the packet is passed without evaluation of any rules.
.Pp
States are removed after the connection is closed or has timed out.
.Pp
This has several advantages.
Comparing a packet to a state involves checking its sequence numbers.
If the sequence numbers are outside the narrow windows of expected
values, the packet is dropped.
This prevents spoofing attacks, such as when an attacker sends packets with
a fake source address/port but does not know the connection's sequence
numbers.
.Pp
Also, looking up states is usually faster than evaluating rules.
If there are 50 rules, all of them are evaluated sequentially in O(n).
Even with 50000 states, only 16 comparisons are needed to match a
state, since states are stored in a binary search tree that allows
searches in O(log2 n).
.Pp
For instance:
.Bd -literal -offset indent
block all
pass out proto tcp from any to any flags S/SA keep state
pass in  proto tcp from any to any port 25 flags S/SA keep state
.Ed
.Pp
This ruleset blocks everything by default.
Only outgoing connections and incoming connections to port 25 are allowed.
The initial packet of each connection has the SYN
flag set, will be passed and creates state.
All further packets of these connections are passed if they match a state.
.Pp
By default, packets coming in and out of any interface can match a state,
but it is also possible to change that behaviour by assigning states to a
single interface or a group of interfaces.
.Pp
The default policy is specified by the
.Ar state-policy
global option, but this can be adjusted on a per-rule basis by adding one
of the
.Ar if-bound ,
.Ar group-bound
or
.Ar floating
keywords to the
.Ar keep state
option.
For example, if a rule is defined as:
.Bd -literal -offset indent
pass out on ppp from any to 10.12/16 keep state (group-bound)
.Ed
.Pp
A state created on ppp0 would match packets an all PPP interfaces,
but not packets flowing through fxp0 or any other interface.
.Pp
Keeping rules
.Ar floating
is the more flexible option when the firewall is in a dynamic routing
environment.
However, this has some security implications since a state created by one
trusted network could allow potentially hostile packets coming in from other
interfaces.
.Pp
Specifying
.Ar flags S/SA
restricts state creation to the initial SYN
packet of the TCP handshake.
One can also be less restrictive, and allow state creation from
intermediate
.Pq non-SYN
packets.
This will cause
.Xr pf 4
to synchronize to existing connections, for instance
if one flushes the state table.
.Pp
For UDP, which is stateless by nature,
.Ar keep state
will create state as well.
UDP packets are matched to states using only host addresses and ports.
.Pp
ICMP messages fall into two categories: ICMP error messages, which always
refer to a TCP or UDP packet, are matched against the referred to connection.
If one keeps state on a TCP connection, and an ICMP source quench message
referring to this TCP connection arrives, it will be matched to the right
state and get passed.
.Pp
For ICMP queries,
.Ar keep state
creates an ICMP state, and
.Xr pf 4
knows how to match ICMP replies to states.
For example,
.Bd -literal -offset indent
pass out inet proto icmp all icmp-type echoreq keep state
.Ed
.Pp
allows echo requests (such as those created by
.Xr ping 8 )
out, creates state, and matches incoming echo replies correctly to states.
.Pp
Note:
.Ar nat , binat No and Ar rdr
rules implicitly create state for connections.
.Sh STATE MODULATION
Much of the security derived from TCP is attributable to how well the
initial sequence numbers (ISNs) are chosen.
Some popular stack implementations choose
.Em very
poor ISNs and thus are normally susceptible to ISN prediction exploits.
By applying a
.Ar modulate state
rule to a TCP connection,
.Xr pf 4
will create a high quality random sequence number for each connection
endpoint.
.Pp
The
.Ar modulate state
directive implicitly keeps state on the rule and is
only applicable to TCP connections.
.Pp
For instance:
.Bd -literal -offset indent
block all
pass out proto tcp from any to any modulate state
pass in  proto tcp from any to any port 25 flags S/SA modulate state
.Ed
.Pp
There are two caveats associated with state modulation:
A
.Ar modulate state
rule can not be applied to a pre-existing but unmodulated connection.
Such an application would desynchronize TCP's strict
sequencing between the two endpoints.
Instead,
.Xr pf 4
will treat the
.Ar modulate state
modifier as a
.Ar keep state
modifier and the pre-existing connection will be inferred without
the protection conferred by modulation.
.Pp
The other caveat affects currently modulated states when the state table
is lost (firewall reboot, flushing the state table, etc...).
.Xr pf 4
will not be able to infer a connection again after the state table flushes
the connection's modulator.
When the state is lost, the connection may be left dangling until the
respective endpoints time out the connection.
It is possible on a fast local network for the endpoints to start an ACK
storm while trying to resynchronize after the loss of the modulator.
Using a
.Ar flags S/SA
modifier on
.Ar modulate state
rules between fast networks is suggested to prevent ACK storms.
.Sh SYN PROXY
By default,
.Xr pf 4
passes packets that are part of a
.Xr tcp 4
handshake between the endpoints.
The
.Ar synproxy state
option can be used to cause
.Xr pf 4
itself to complete the handshake with the active endpoint, perform a handshake
with the passive endpoint, and then forward packets between the endpoints.
.Pp
No packets are sent to the passive endpoint before the active endpoint has
completed the handshake, hence so-called SYN floods with spoofed source
addresses will not reach the passive endpoint, as the sender can't complete the
handshake.
.Pp
The proxy is transparent to both endpoints, they each see a single
connection from/to the other endpoint.
.Xr pf 4
chooses random initial sequence numbers for both handshakes.
Once the handshakes are completed, the sequence number modulators
(see previous section) are used to translate further packets of the
connection.
Hence,
.Ar synproxy state
includes
.Ar modulate state
and
.Ar keep state .
.Pp
Rules with
.Ar synproxy
will not work if
.Xr pf 4
operates on a
.Xr bridge 4 .
.Pp
Example:
.Bd -literal -offset indent
pass in proto tcp from any to any port www flags S/SA synproxy state
.Ed
.Sh STATEFUL TRACKING OPTIONS
All three of
.Ar keep state ,
.Ar modulate state
and
.Ar synproxy state
support the following options:
.Pp
.Bl -tag -width xxxx -compact
.It Ar max <number>
Limits the number of concurrent states the rule may create.
When this limit is reached, further packets matching the rule that would
create state are dropped, until existing states time out.
.It Ar no-sync
Prevent state changes for states created by this rule from appearing on the
.Xr pfsync 4
interface.
.It Ar <timeout> <seconds>
Changes the timeout values used for states created by this rule.
.El
.Pp
When the
.Ar source-track
keyword is specified, the number of states per source IP is tracked.
The following limits can be set:
.Pp
.Bl -tag -width xxxx -compact
.It Ar max-src-nodes
Limits the maximum number of source addresses which can simultaneously
have state table entries.
.It Ar max-src-states
Limits the maximum number of simultaneous state entries that a single
source address can create with this rule.
.El
.Pp
For a list of all valid timeout names, see
.Sx OPTIONS
above.
.Pp
Multiple options can be specified, separated by commas:
.Bd -literal
pass in proto tcp from any to any \e
      port www flags S/SA keep state \e
      (max 100, source-track rule, max-src-nodes 75, \e
      max-src-states 3, tcp.established 60, tcp.closing 5)
.Ed
.Sh OPERATING SYSTEM FINGERPRINTING
Passive OS Fingerprinting is a mechanism to inspect nuances of a TCP
connection's initial SYN packet and guess at the host's operating system.
Unfortunately these nuances are easily spoofed by an attacker so the
fingerprint is not useful in making security decisions.
But the fingerprint is typically accurate enough to make policy decisions
upon.
.Pp
The fingerprints may be specified by operating system class, by
version, or by subtype/patchlevel.
The class of an operating system is typically the vendor or genre
and would be OpenBSD for the
.Xr pf 4
firewall itself.
The version of the oldest available OpenBSD release on the main ftp site
would be 2.6 and the fingerprint would be written
.Pp
.Dl \&"OpenBSD 2.6\&"
.Pp
The subtype of an operating system is typically used to describe the
patchlevel if that patch led to changes in the TCP stack behavior.
In the case of OpenBSD, the only subtype is for a fingerprint that was
normalized by the
.Ar no-df
scrub option and would be specified as
.Pp
.Dl \&"OpenBSD 3.3 no-df\&"
.Pp
Fingerprints for most popular operating systems are provided by
.Xr pf.os 5 .
Once
.Xr pf 4
is running, a complete list of known operating system fingerprints may
be listed by running:
.Pp
.Dl # pfctl -so
.Pp
Filter rules can enforce policy at any level of operating system specification
assuming a fingerprint is present.
Policy could limit traffic to approved operating systems or even ban traffic
from hosts that aren't at the latest service pack.
.Pp
The
.Ar unknown
class can also be used as the fingerprint which will match packets for
which no operating system fingerprint is known.
.Pp
Examples:
.Bd -literal -offset indent
pass  out proto tcp from any os OpenBSD keep state
block out proto tcp from any os Doors
block out proto tcp from any os "Doors PT"
block out proto tcp from any os "Doors PT SP3"
block out from any os "unknown"
pass on lo0 proto tcp from any os "OpenBSD 3.3 lo0" keep state
.Ed
.Pp
Operating system fingerprinting is limited only to the TCP SYN packet.
This means that it will not work on other protocols and will not match
a currently established connection.
.Pp
Caveat: operating system fingerprints are occasionally wrong.
There are three problems: an attacker can trivially craft his packets to
appear as any operating system he chooses;
an operating system patch could change the stack behavior and no fingerprints
will match it until the database is updated;
and multiple operating systems may have the same fingerprint.
.Sh FRAGMENT HANDLING
The size of IP datagrams (packets) can be significantly larger than the
maximum transmission unit (MTU) of the network.
In cases when it is necessary or more efficient to send such large packets,
the large packet will be fragmented into many smaller packets that will each
fit onto the wire.
Unfortunately for a firewalling device, only the first logical fragment will
contain the necessary header information for the subprotocol that allows
.Xr pf 4
to filter on things such as TCP ports or to perform NAT.
.Pp
Besides the use of
.Ar scrub
rules as described in
.Sx TRAFFIC NORMALIZATION
above, there are three options for handling fragments in the packet filter.
.Pp
One alternative is to filter individual fragments with filter rules.
If no
.Ar scrub
rule applies to a fragment, it is passed to the filter.
Filter rules with matching IP header parameters decide whether the
fragment is passed or blocked, in the same way as complete packets
are filtered.
Without reassembly, fragments can only be filtered based on IP header
fields (source/destination address, protocol), since subprotocol header
fields are not available (TCP/UDP port numbers, ICMP code/type).
The
.Ar fragment
option can be used to restrict filter rules to apply only to
fragments, but not complete packets.
Filter rules without the
.Ar fragment
option still apply to fragments, if they only specify IP header fields.
For instance, the rule
.Bd -literal -offset indent
pass in proto tcp from any to any port 80
.Ed
.Pp
never applies to a fragment, even if the fragment is part of a TCP
packet with destination port 80, because without reassembly this information
is not available for each fragment.
This also means that fragments cannot create new or match existing
state table entries, which makes stateful filtering and address
translation (NAT, redirection) for fragments impossible.
.Pp
It's also possible to reassemble only certain fragments by specifying
source or destination addresses or protocols as parameters in
.Ar scrub
rules.
.Pp
In most cases, the benefits of reassembly outweigh the additional
memory cost, and it's recommended to use
.Ar scrub
rules to reassemble
all fragments via the
.Ar fragment reassemble
modifier.
.Pp
The memory allocated for fragment caching can be limited using
.Xr pfctl 8 .
Once this limit is reached, fragments that would have to be cached
are dropped until other entries time out.
The timeout value can also be adjusted.
.Pp
Currently, only IPv4 fragments are supported and IPv6 fragments
are blocked unconditionally.
.Sh ANCHORS AND NAMED RULESETS
Besides the main ruleset,
.Xr pfctl 8
can load named rulesets into
.Ar anchor
attachment points.
An
.Ar anchor
contains a list of named rulesets.
An
.Ar anchor
has a name which specifies where
.Xr pfctl 8
can be used to attach sub-rulesets.
A named ruleset contains filter and translation rules, like the
main ruleset.
The main ruleset can reference
.Ar anchor
attachment points
using the following kinds
of rules:
.Bl -tag -width xxxx
.It Ar nat-anchor <name>
Evaluates the
.Ar nat
rules of all named rulesets in the specified
.Ar anchor .
.It Ar rdr-anchor <name>
Evaluates the
.Ar rdr
rules of all named rulesets in the specified
.Ar anchor .
.It Ar binat-anchor <name>
Evaluates the
.Ar binat
rules of all named rulesets in the specified
.Ar anchor .
.It Ar anchor <name>
Evaluates the filter rules of all named rulesets in the specified
.Ar anchor .
.It Ar load anchor <name>:<ruleset> from <file>
Loads the rules from the specified file into the named
ruleset
.Ar <ruleset>
attached to the anchor
.Ar <name> .
.El
.Pp
When evaluation of the main ruleset reaches an
.Ar anchor
rule,
.Xr pf 4
will proceed to evaluate all rules specified in the
named rulesets attached to that
.Ar anchor .
.Pp
Matching filter rules in named rulesets with the
.Ar quick
option and matching translation rules are final and abort the
evaluation of both the rules in the
.Ar anchor
and the main ruleset.
.Pp
Only the main ruleset can contain
.Ar anchor
rules.
.Pp
When an
.Ar anchor
contains more than one named ruleset, they are evaluated
in the alphabetical order of their names.
.Pp
Rules may contain
.Ar anchor
attachment points which do not contain any rules when the main ruleset
is loaded, and later such named rulesets can be manipulated through
.Xr pfctl 8
without reloading the main ruleset.
For example,
.Bd -literal -offset indent
ext_if = \&"kue0\&"
block on $ext_if all
anchor spam
pass out on $ext_if all keep state
pass in on $ext_if proto tcp from any \e
      to $ext_if port smtp keep state
.Ed
.Pp
blocks all packets on the external interface by default, then evaluates
all rulesets in the
.Ar anchor
named "spam", and finally passes all outgoing connections and
incoming connections to port 25.
.Bd -literal -offset indent
# echo \&"block in quick from 1.2.3.4 to any\&" \&| \e
      pfctl -a spam:manual -f -
.Ed
.Pp
loads a single ruleset containing a single rule into the
.Ar anchor ,
which blocks all packets from a specific address.
.Pp
The named ruleset can also be populated by adding a
.Ar load anchor
rule after the
.Ar anchor
rule:
.Bd -literal -offset indent
anchor spam
load anchor spam:manual from "/etc/pf-spam.conf"
.Ed
.Pp
When
.Xr pfctl 8
loads
.Nm pf.conf ,
it will also load all the rules from the file
.Pa /etc/pf-spam.conf
into the named ruleset.
.Pp
Optionally,
.Ar anchor
rules can specify the parameter's
direction, interface, address family, protocol and source/destination
address/port
using the same syntax as filter rules.
When parameters are used, the
.Ar anchor
rule is only evaluated for matching packets.
This allows conditional evaluation of named rulesets, like:
.Bd -literal -offset indent
block on $ext_if all
anchor spam proto tcp from any to any port smtp
pass out on $ext_if all keep state
pass in on $ext_if proto tcp from any to $ext_if port smtp keep state
.Ed
.Pp
The rules inside
.Ar anchor
spam are only evaluated for
.Ar tcp
packets with destination port 25.
Hence,
.Bd -literal -offset indent
# echo \&"block in quick from 1.2.3.4 to any" \&| \e
      pfctl -a spam:manual -f -
.Ed
.Pp
will only block connections from 1.2.3.4 to port 25.
.Sh TRANSLATION EXAMPLES
This example maps incoming requests on port 80 to port 8080, on
which a daemon is running (because, for example, it is not run as root,
and therefore lacks permission to bind to port 80).
.Bd -literal
# use a macro for the interface name, so it can be changed easily
ext_if = \&"ne3\&"

# map daemon on 8080 to appear to be on 80
rdr on $ext_if proto tcp from any to any port 80 -> 127.0.0.1 port 8080
.Ed
.Pp
If the
.Ar pass
modifier is given, packets matching the translation rule are passed without
inspecting the filter rules:
.Bd -literal
rdr pass on $ext_if proto tcp from any to any port 80 -> 127.0.0.1 \e
      port 8080
.Ed
.Pp
In the example below, vlan12 is configured as 192.168.168.1;
the machine translates all packets coming from 192.168.168.0/24 to 204.92.77.111
when they are going out any interface except vlan12.
This has the net effect of making traffic from the 192.168.168.0/24
network appear as though it is the Internet routable address
204.92.77.111 to nodes behind any interface on the router except
for the nodes on vlan12.
(Thus, 192.168.168.1 can talk to the 192.168.168.0/24 nodes.)
.Bd -literal
nat on ! vlan12 from 192.168.168.0/24 to any -> 204.92.77.111
.Ed
.Pp
In the example below, the machine sits between a fake internal 144.19.74.*
network, and a routable external IP of 204.92.77.100.
The
.Ar no nat
rule excludes protocol AH from being translated.
.Bd -literal
# NO NAT
no nat on $ext_if proto ah from 144.19.74.0/24 to any
nat on $ext_if from 144.19.74.0/24 to any -> 204.92.77.100
.Ed
.Pp
In the example below, packets bound for one specific server, as well as those
generated by the sysadmins are not proxied; all other connections are.
.Bd -literal
# NO RDR
no rdr on $int_if proto { tcp, udp } from any to $server port 80
no rdr on $int_if proto { tcp, udp } from $sysadmins to any port 80
rdr on $int_if proto { tcp, udp } from any to any port 80 -> 127.0.0.1 \e
      port 80
.Ed
.Pp
This longer example uses both a NAT and a redirection.
The external interface has the address 157.161.48.183.
On the internal interface, we are running
.Xr ftp-proxy 8 ,
listening for outbound ftp sessions captured to port 8021.
.Bd -literal
# NAT
# Translate outgoing packets' source addresses (any protocol).
# In this case, any address but the gateway's external address is mapped.
nat on $ext_if inet from ! ($ext_if) \-> $ext_if

# NAT PROXYING
# Map outgoing packets' source port to an assigned proxy port instead of
# an arbitrary port.
# In this case, proxy outgoing isakmp with port 500 on the gateway.
nat on $ext_if inet proto udp from any port = isakmp -> $ext_if \e
      port 500

# BINAT
# Translate outgoing packets' source address (any protocol).
# Translate incoming packets' destination address to an internal machine
# (bidirectional).
binat on $ext_if from 10.1.2.150 to any -> $ext_if

# RDR
# Translate incoming packets' destination addresses.
# As an example, redirect a TCP and UDP port to an internal machine.
rdr on $ext_if inet proto tcp from any to $ext_if port 8080 \e
      -> 10.1.2.151 port 22
rdr on $ext_if inet proto udp from any to $ext_if port 8080 \e
      -> 10.1.2.151 port 53

# RDR
# Translate outgoing ftp control connections to send them to localhost
# for proxying with ftp-proxy(8) running on port 8021.
rdr on $int_if proto tcp from any to any port 21 -> 127.0.0.1 port 8021
.Ed
.Pp
In this example, a NAT gateway is set up to translate internal addresses
using a pool of public addresses (192.0.2.16/28) and to redirect
incoming web server connections to a group of web servers on the internal
network.
.Bd -literal
# NAT LOAD BALANCE
# Translate outgoing packets' source addresses using an address pool.
# A given source address is always translated to the same pool address by
# using the source-hash keyword.
nat on $ext_if inet from any to any -> 192.0.2.16/28 source-hash

# RDR ROUND ROBIN
# Translate incoming web server connections to a group of web servers on
# the internal network.
rdr on $ext_if proto tcp from any to any port 80 \e
      -> { 10.1.2.155, 10.1.2.160, 10.1.2.161 } round-robin
.Ed
.Sh FILTER EXAMPLES
.Bd -literal
# The external interface is kue0
# (157.161.48.183, the only routable address)
# and the private network is 10.0.0.0/8, for which we are doing NAT.

# use a macro for the interface name, so it can be changed easily
ext_if = \&"kue0\&"

# normalize all incoming traffic
scrub in on $ext_if all fragment reassemble

# block and log everything by default
block return log on $ext_if all

# block anything coming from source we have no back routes for
block in from no-route to any

# block and log outgoing packets that do not have our address as source,
# they are either spoofed or something is misconfigured (NAT disabled,
# for instance), we want to be nice and do not send out garbage.
block out log quick on $ext_if from ! 157.161.48.183 to any

# silently drop broadcasts (cable modem noise)
block in quick on $ext_if from any to 255.255.255.255

# block and log incoming packets from reserved address space and invalid
# addresses, they are either spoofed or misconfigured, we cannot reply to
# them anyway (hence, no return-rst).
block in log quick on $ext_if from { 10.0.0.0/8, 172.16.0.0/12, \e
      192.168.0.0/16, 255.255.255.255/32 } to any

# ICMP

# pass out/in certain ICMP queries and keep state (ping)
# state matching is done on host addresses and ICMP id (not type/code),
# so replies (like 0/0 for 8/0) will match queries
# ICMP error messages (which always refer to a TCP/UDP packet) are
# handled by the TCP/UDP states
pass on $ext_if inet proto icmp all icmp-type 8 code 0 keep state

# UDP

# pass out all UDP connections and keep state
pass out on $ext_if proto udp all keep state

# pass in certain UDP connections and keep state (DNS)
pass in on $ext_if proto udp from any to any port domain keep state

# TCP

# pass out all TCP connections and modulate state
pass out on $ext_if proto tcp all modulate state

# pass in certain TCP connections and keep state (SSH, SMTP, DNS, IDENT)
pass in on $ext_if proto tcp from any to any port { ssh, smtp, domain, \e
      auth } flags S/SA keep state

# pass in data mode connections for ftp-proxy running on this host.
# (see ftp-proxy(8) for details)
pass in on $ext_if proto tcp from any to 157.161.48.183 port >= 49152 \e
      flags S/SA keep state

# Do not allow Windows 9x SMTP connections since they are typically
# a viral worm. Alternately we could limit these OSes to 1 connection each.
block in on $ext_if proto tcp from any os {"Windows 95", "Windows 98"} \e
      to any port smtp

# Packet Tagging

# three interfaces: $int_if, $ext_if, and $wifi_if (wireless). NAT is
# being done on $ext_if for all outgoing packets. tag packets in on
# $int_if and pass those tagged packets out on $ext_if.  all other
# outgoing packets (i.e., packets from the wireless network) are only
# permitted to access port 80.

pass in on $int_if from any to any tag INTNET keep state
pass in on $wifi_if from any to any keep state

block out on $ext_if from any to any
pass out quick on $ext_if tagged INTNET keep state
pass out on $ext_if from any to any port 80 keep state

# tag incoming packets as they are redirected to spamd(8). use the tag
# to pass those packets through the packet filter.

rdr on $ext_if inet proto tcp from <spammers> to port smtp \e
	tag SPAMD -> 127.0.0.1 port spamd

block in on $ext_if
pass in on $ext_if inet proto tcp tagged SPAMD keep state
.Ed
.Sh GRAMMAR
Syntax for
.Nm
in BNF:
.Bd -literal
line           = ( option | pf-rule | nat-rule | binat-rule | rdr-rule |
                 altq-rule | queue-rule | anchor-rule |
                 trans-anchors | load-anchors | table-rule )

option         = "set" ( [ "timeout" ( timeout | "{" timeout-list "}" ) ] |
                 [ "optimization" [ "default" | "normal" |
                 "high-latency" | "satellite" |
                 "aggressive" | "conservative" ] ]
                 [ "limit" ( limit-item | "{" limit-list "}" ) ] |
                 [ "loginterface" ( interface-name | "none" ) ] |
                 [ "block-policy" ( "drop" | "return" ) ] |
		 [ "state-policy" ( "if-bound" | "group-bound" |
                 "floating" ) ]
                 [ "require-order" ( "yes" | "no" ) ]
                 [ "fingerprints" filename ] |
                 [ "debug" ( "none" | "urgent" | "misc" | "loud" ) ] )

pf-rule        = action [ ( "in" | "out" ) ]
                 [ "log" | "log-all" ] [ "quick" ]
                 [ "on" ifspec ] [ route ] [ af ] [ protospec ]
                 hosts [ filteropt-list ]

filteropt-list = filteropt-list filteropt | filteropt
filteropt      = user | group | flags | icmp-type | icmp6-type | tos |
                 ( "keep" | "modulate" | "synproxy" ) "state"
                 [ "(" state-opts ")" ] |
                 "fragment" | "no-df" | "min-ttl" number |
                 "max-mss" number | "random-id" | "reassemble tcp" |
                 fragmentation | "allow-opts" |
                 "label" string | "tag" string | [ ! ] "tagged" string
                 "queue" ( string | "(" string [ [ "," ] string ] ")" )

nat-rule       = [ "no" ] "nat" [ "pass" ] [ "on" ifspec ] [ af ]
                 [ protospec ] hosts [ "tag" string ]
                 [ "->" ( redirhost | "{" redirhost-list "}" )
                 [ portspec ] [ pooltype ] [ "static-port" ] ]

binat-rule     = [ "no" ] "binat" [ "pass" ] [ "on" interface-name ]
                 [ af ] [ "proto" ( proto-name | proto-number ) ]
                 "from" address [ "/" mask-bits ] "to" ipspec
                 [ "tag" string ]
                 [ "->" address [ "/" mask-bits ] ]

rdr-rule       = [ "no" ] "rdr" [ "pass" ] [ "on" ifspec ] [ af ]
                 [ protospec ] hosts [ "tag" string ]
                 [ "->" ( redirhost | "{" redirhost-list "}" )
                 [ portspec ] [ pooltype ] ]

table-rule     = "table" "<" string ">" [ tableopts-list ]
tableopts-list = tableopts-list tableopts | tableopts
tableopts      = "persist" | "const" | "file" string |
                 "{" [ tableaddr-list ] "}"
tableaddr-list = tableaddr-list [ "," ] tableaddr-spec | tableaddr-spec
tableaddr-spec = [ "!" ] tableaddr [ "/" mask-bits ]
tableaddr      = hostname | ipv4-dotted-quad | ipv6-coloned-hex |
                 interface-name | "self"

altq-rule      = "altq on" interface-name queueopts-list
                 "queue" subqueue
queue-rule     = "queue" string [ "on" interface-name ] queueopts-list
                 subqueue

anchor-rule    = "anchor" string [ ( "in" | "out" ) ] [ "on" ifspec ]
                 [ af ] [ "proto" ] [ protospec ] [ hosts ]

trans-anchors  = ( "nat-anchor" | "rdr-anchor" | "binat-anchor" ) string
                 [ "on" ifspec ] [ af ] [ "proto" ] [ protospec ] [ hosts ]

load-anchor    = "load anchor" anchorname:rulesetname "from" filename

queueopts-list = queueopts-list queueopts | queueopts
queueopts      = [ "bandwidth" bandwidth-spec ] |
                 [ "qlimit" number ] | [ "tbrsize" number ] |
                 [ "priority" number ] | [ schedulers ]
schedulers     = ( cbq-def | priq-def | hfsc-def )
bandwidth-spec = "number" ( "b" | "Kib" | "Mib" | "Gib" | "%" )

action         = "pass" | "block" [ return ] | "fuck-off" | "scrub"
return         = "drop" | "return" | "return-rst" [ "( ttl" number ")" ] |
                 "return-icmp" [ "(" icmpcode ["," icmp6code ] ")" ] |
                 "return-icmp6" [ "(" icmp6code ")" ]
icmpcode       = ( icmp-code-name | icmp-code-number )
icmp6code      = ( icmp6-code-name | icmp6-code-number )

ifspec         = ( [ "!" ] interface-name ) | "{" interface-list "}"
interface-list = [ "!" ] interface-name [ [ "," ] interface-list ]
route          = "fastroute" |
                 ( "route-to" | "reply-to" | "dup-to" )
                 ( routehost | "{" routehost-list "}" )
                 [ pooltype ]
af             = "inet" | "inet6"

protospec      = "proto" ( proto-name | proto-number |
                 "{" proto-list "}" )
proto-list     = ( proto-name | proto-number ) [ [ "," ] proto-list ]

hosts          = "all" |
                 "from" ( "any" | "no-route" | "self" | host |
                 "{" host-list "}" ) [ port ] [ os ]
                 "to"   ( "any" | "no-route" | "self" | host |
                 "{" host-list "}" ) [ port ]

ipspec         = "any" | host | "{" host-list "}"
host           = [ "!" ] ( address [ "/" mask-bits ] | "<" string ">" )
redirhost      = address [ "/" mask-bits ]
routehost      = ( interface-name [ address [ "/" mask-bits ] ] )
address        = ( interface-name | hostname |
                 ipv4-dotted-quad | ipv6-coloned-hex )
host-list      = host [ [ "," ] host-list ]
redirhost-list = redirhost [ [ "," ] redirhost-list ]
routehost-list = routehost [ [ "," ] routehost-list ]

port           = "port" ( unary-op | binary-op | "{" op-list "}" )
portspec       = "port" ( number | name ) [ ":" ( "*" | number | name ) ]
os             = "os"  ( os-name | "{" os-list "}" )
user           = "user" ( unary-op | binary-op | "{" op-list "}" )
group          = "group" ( unary-op | binary-op | "{" op-list "}" )

unary-op       = [ "=" | "!=" | "<" | "<=" | ">" | ">=" ]
                 ( name | number )
binary-op      = number ( "<>" | "><" | ":" ) number
op-list        = ( unary-op | binary-op ) [ [ "," ] op-list ]

os-name        = operating-system-name
os-list        = os-name [ [ "," ] os-list ]

flags          = "flags" [ flag-set ] "/" flag-set
flag-set       = [ "F" ] [ "S" ] [ "R" ] [ "P" ] [ "A" ] [ "U" ] [ "E" ]
                 [ "W" ]

icmp-type      = "icmp-type" ( icmp-type-code | "{" icmp-list "}" )
icmp6-type     = "icmp6-type" ( icmp-type-code | "{" icmp-list "}" )
icmp-type-code = ( icmp-type-name | icmp-type-number )
                 [ "code" ( icmp-code-name | icmp-code-number ) ]
icmp-list      = icmp-type-code [ [ "," ] icmp-list ]

tos            = "tos" ( "lowdelay" | "throughput" | "reliability" |
                 [ "0x" ] number )

state-opts     = state-opt [ [ "," ] state-opts ]
state-opt      = ( "max" number | "no-sync" | timeout |
                 "source-track" [ ( "rule" | "global" ) ] |
		 "max-src-nodes" number | "max-src-states" number |
                 "if-bound" | "group-bound" | "floating" )

fragmentation  = [ "fragment reassemble" | "fragment crop" |
                 "fragment drop-ovl" ]

timeout-list   = timeout [ [ "," ] timeout-list ]
timeout        = ( "tcp.first" | "tcp.opening" | "tcp.established" |
                 "tcp.closing" | "tcp.finwait" | "tcp.closed" |
                 "udp.first" | "udp.single" | "udp.multiple" |
                 "icmp.first" | "icmp.error" |
                 "other.first" | "other.single" | "other.multiple" |
                 "frag" | "interval" | "src.track" |
                 "adaptive.start" | "adaptive.end" ) number

limit-list     = limit-item [ [ "," ] limit-list ]
limit-item     = ( "states" | "frags" | "src-nodes" ) number

pooltype       = ( "bitmask" | "random" |
                 "source-hash" [ ( hex-key | string-key ) ] |
                 "round-robin" ) [ sticky-address ]

subqueue       = string | "{" queue-list "}"
queue-list     = string [ [ "," ] string ]
cbq-def        = "cbq" [ "(" cbq-opt [ [ "," ] cbq-opt ] ")" ]
priq-def       = "priq" [ "(" priq-opt [ [ "," ] priq-opt ] ")" ]
hfsc-def       = "hfsc" [ "(" hfsc-opt [ [ "," ] hfsc-opt ] ")" ]
cbq-opt        = ( "default" | "borrow" | "red" | "ecn" | "rio" )
priq-opt       = ( "default" | "red" | "ecn" | "rio" )
hfsc-opt       = ( "default" | "red" | "ecn" | "rio" |
                 linkshare-sc | realtime-sc | upperlimit-sc )
linkshare-sc   = "linkshare" sc-spec
realtime-sc    = "realtime" sc-spec
upperlimit-sc  = "upperlimit" sc-spec
sc-spec        = ( bandwidth-spec |
                 "(" bandwidth-spec number bandwidth-spec ")" )
.Ed
.Sh FILES
.Bl -tag -width "/etc/protocols" -compact
.It Pa /etc/hosts
Host name database.
.It Pa /etc/pf.conf
Default location of the ruleset file.
.It Pa /etc/pf.os
Default location of OS fingerprints.
.It Pa /etc/protocols
Protocol name database.
.It Pa /etc/services
Service name database.
.It Pa /usr/share/pf
Example rulesets.
.El
.Sh SEE ALSO
.Xr icmp 4 ,
.Xr icmp6 4 ,
.Xr ip 4 ,
.Xr ip6 4 ,
.Xr pf 4 ,
.Xr pfsync 4 ,
.Xr tcp 4 ,
.Xr udp 4 ,
.Xr hosts 5 ,
.Xr pf.os 5 ,
.Xr protocols 5 ,
.Xr services 5 ,
.Xr ftp-proxy 8 ,
.Xr pfctl 8 ,
.Xr pflogd 8
.Sh HISTORY
The
.Nm
file format first appeared in
.Ox 3.0 .
@


1.18
log
@* merge OpenBSD 3.5-current
* fix every single Makefile for papers/USD/PSD/SMM
* improve <bsd.doc.mk> - tbl(1) is called by default now
* move programme definitions from <bsd.doc.mk> into <bsd.own.mk>
* move a bunch of compiler selection stuff from /etc/mk.conf
  into <bsd.own.mk> and improve it largely
* overhaul gcc-local(1) and style(9), referencing our licence
  template in the latter
* overhaul (mostly shorten and clarify) the COPYRIGHT file;
  make clear where the other licences (Apache, Sendmail, GNU, ...)
  are listed, by pathname and www URI
* employ new mechanism to check for paper/doc Makefiles/SUBDIRs
* fix mdoc macros
* merge more acronymes from NetBSD

This merge took me more than three hours, just FYI
@
text
@d1 1
a1 1
.\"	$MirBSD: src/share/man/man5/pf.conf.5,v 1.17 2004/01/27 17:42:15 tg Exp $
d62 1
a62 1
.It Cm Translation Li (Various forms of NAT)
d306 1
a306 1
(adaptive.end - number of states) / (adaptive.end - adaptive.start).
a1265 7
Surrounding the interface name (and optional modifiers) in parentheses
changes this behaviour.
When the interface name is surrounded by parentheses, the rule is
automatically updated whenever the interface changes its address.
The ruleset does not need to be reloaded.
This is especially useful with
.Ar nat .
a1972 41
.Sh BLOCKING SPOOFED TRAFFIC
"Spoofing" is the faking of IP addresses, typically for malicious
purposes.
The
.Ar antispoof
directive expands to a set of filter rules which will block all
traffic with a source IP from the network(s) directly connected
to the specified interface(s) from entering the system through
any other interface.
.Pp
For example, the line
.Bd -literal -offset indent
antispoof for lo0
.Ed
.Pp
expands to
.Bd -literal -offset indent
block drop in on ! lo0 inet from 127.0.0.1/8 to any
block drop in on ! lo0 inet6 from ::1 to any
.Ed
.Pp
For non-loopback interfaces, there are additional rules to block incoming
packets with a source IP address identical to the interface's IP(s).
For example, assuming the interface wi0 had an IP address of 10.0.0.1 and a
netmask of 255.255.255.0,
the line
.Bd -literal -offset indent
antispoof for wi0 inet
.Ed
.Pp
expands to
.Bd -literal -offset indent
block drop in on ! wi0 inet from 10.0.0.0/24 to any
block drop in inet from 10.0.0.1 to any
.Ed
.Pp
Caveat: Rules created by the
.Ar antispoof
directive interfere with packets sent over loopback interfaces
to local addresses.
One should pass these explicitly.
d2252 1
a2252 1
nat on $ext_if inet from ! ($ext_if) to any -> ($ext_if)
d2258 1
a2258 1
nat on $ext_if inet proto udp from any port = isakmp to any -> ($ext_if) \e
d2265 1
a2265 1
binat on $ext_if from 10.1.2.150 to any -> ($ext_if)
d2270 1
a2270 1
rdr on $ext_if inet proto tcp from any to ($ext_if) port 8080 \e
d2272 1
a2272 1
rdr on $ext_if inet proto udp from any to ($ext_if) port 8080 \e
d2396 1
a2396 1
                 antispoof-rule | altq-rule | queue-rule | anchor-rule |
a2442 4
antispoof-rule = "antispoof" [ "log" ] [ "quick" ]
                 "for" ( interface-name | "{" interface-list "}" )
                 [ af ] [ "label" string ]

d2501 1
a2501 1
address        = ( interface-name | "(" interface-name ")" | hostname |
@


1.17
log
@first part of mergeing OpenBSD and fixing whitespace and RCS IDs
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.16 2004/01/04 19:53:51 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.289 2004/01/06 09:28:00 cedric Exp $
d239 1
a239 1
Length of time to retain a source-tracking entry after the last state
d373 11
d387 1
a387 1
set limit { states 20000, frags 20000 }
d622 18
d957 2
a958 2
addresses and ports have been translated. Filter rules
will therefore have to filter based on the translated
d1530 9
d1569 1
a1569 1
.Ar route-to
d1886 1
d1889 1
a1889 1
.Ar source-tracking
d1893 1
a1893 1
.Bl  -tag -width xxxx -compact
d1901 1
a1912 1
.El
d1923 1
a1923 1
The class of an operating system is typically the vender or genre
d2605 1
a2605 1
limit-item     = ( "states" | "frags" ) number
@


1.16
log
@this should fix the manpages
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.15 2004/01/03 02:27:39 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.288 2003/12/31 14:09:57 jmc Exp $
d1677 1
a1677 1
pass out on ppp from any to 10.12/16 keep state (group-locked)
@


1.15
log
@Merge OpenBSD
@
text
@d1 1
a1 1
.\"	$MirBSD: pf.conf.5,v 1.14 2003/12/27 00:30:59 tg Exp $
d802 1
a802 1
.Ar <scheduler> Ns Li (\& Ar <parameters> No ) .
d1497 1
a1497 1
.Cm !\&
@


1.14
log
@finish merging and sync a bit; bump version etc.
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.13 2003/09/25 20:59:56 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.286 2003/12/15 05:17:20 jmc Exp $
d427 18
d1175 2
d1221 4
d1227 5
d1237 2
a1238 1
Surrounding the interface name in parentheses changes this behaviour.
d1660 31
d2415 2
d2550 2
a2551 1
		 "max-src-nodes" number | "max-src-states" number)
@


1.13
log
@Merge OpenBSD-current
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.12 2003/08/31 20:54:45 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.271 2003/09/02 18:37:08 jmc Exp $
d238 3
d457 16
d1115 2
a1116 1
.Ar keep state
d1118 1
a1118 1
.Ar modulate state
d1122 2
a1123 1
.Ar keep state
d1125 1
a1125 1
.Ar modulate state
d1139 2
a1140 1
.Ar keep state
d1142 1
a1142 1
.Ar modulate state
d1231 2
a1232 1
><	(range)
d1236 2
a1237 3
>< and <>
are binary operators (they take two arguments), and the range
does not include the limits.
d1240 4
d1451 4
a1454 1
.Ar keep state .
d1461 1
d1567 17
d1746 1
a1746 1
choses random initial sequence numbers for both handshakes.
d1781 4
d1787 14
d1809 2
a1810 1
      (max 100, tcp.established 60, tcp.closing 5)
d1923 1
a1923 1
the maximum transmission unit (MTU) of the network.
d2097 1
a2097 1
load anchor spam:manual from /etc/pf-spam.conf
d2142 3
d2146 1
a2146 1
rdr on ne3 proto tcp from any to any port 80 -> 127.0.0.1 port 8080
d2154 2
a2155 1
rdr pass on ne3 proto tcp from any to any port 80 -> 127.0.0.1 port 8080
d2170 2
a2171 2
In the example below, fxp1 is the outside interface; the machine sits between a
fake internal 144.19.74.* network, and a routable external IP of 204.92.77.100.
d2177 2
a2178 2
no nat on fxp1 proto ah from 144.19.74.0/24 to any
nat on fxp1 from 144.19.74.0/24 to any -> 204.92.77.100
d2181 2
a2182 4
In the example below, fxp0 is the internal interface.
Packets bound
for one specific server, as well as those generated by the sysadmins
are not proxied; all other connections are.
d2185 4
a2188 3
no rdr on fxp0 proto { tcp, udp } from any to $server port 80
no rdr on fxp0 proto { tcp, udp } from $sysadmins to any port 80
rdr on fxp0 proto { tcp, udp } from any to any port 80 -> 127.0.0.1 port 80
d2192 2
a2193 3
Interface kue0 is the outside interface, and its external address is
157.161.48.183.
Interface fxp0 is the inside interface, and we are running
d2200 1
a2200 1
nat on kue0 inet from ! (kue0) to any -> (kue0)
d2206 1
a2206 1
nat on kue0 inet proto udp from any port = isakmp to any -> (kue0) \e
d2213 1
a2213 1
binat on kue0 from 10.1.2.150 to any -> (kue0)
d2218 4
a2221 4
rdr on kue0 inet proto tcp from any to (kue0) port 8080 -> 10.1.2.151 \e
      port 22
rdr on kue0 inet proto udp from any to (kue0) port 8080 -> 10.1.2.151 \e
      port 53
d2226 1
a2226 1
rdr on fxp0 proto tcp from any to any port 21 -> 127.0.0.1 port 8021
a2232 1
Interface fxp0 is the external interface.
d2238 1
a2238 1
nat on fxp0 inet from any to any -> 192.0.2.16/28 source-hash
d2243 1
a2243 1
rdr on fxp0 proto tcp from any to any port 80 \e
d2355 2
a2356 1
                 [ "fingerprints" filename ] )
d2371 1
a2371 1
                 "queue" "(" string | ( string [ [ "," ] string ] ) ")"
d2413 1
a2413 1
load-anchor    = "load" anchorname:rulesetname "from" filename
d2422 1
a2422 1
action         = "pass" | "block" [ "return" ] | "fuck-off" | "scrub"
d2485 3
a2487 1
state-opt      = ( "max" number ) | ( timeout )
d2498 1
a2498 1
                 "frag" | "interval" |
d2506 1
a2506 1
                 "round-robin" )
d2544 1
@


1.12
log
@Merge import of OpenBSD source, ports and XF4 tree.

While here,
o clean up differences where possible
o whitespace cleanup
o ifdef ./. if defined()
o '...' ./. "..."
o echo foo > bar ./. echo foo >bar
o `...` ./. $(...) ./. $$(...)
o `...' ./. '...'
o modernize "our" tree, e.g. WWW in ports
o fix some typos and brainos introduced when renaming OpenBSD to MirBSD
o use hardware 80387 by default
o migrate Apache 1.3.28 OpenBSD ./. MirBSD ./. KAME
o work around as many CVS bugs as possible (add back/delete files, ...)

Synchronize stuff, ready for ongoing changes.
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.11 2003/07/07 21:50:42 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.270 2003/08/28 09:41:22 jmc Exp $
d1437 1
a1437 1
.Cm !
@


1.11
log
@merge
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.10 2003/07/06 20:22:21 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.263 2003/07/07 09:15:54 jmc Exp $
d124 7
a130 3
Tables cannot be used for things like the redirect address of
translation rules, nor can they be used in the routing options of
filter rules.
d439 15
d570 1
a570 1
.Ar reassemple tcp
a766 1
.Pp
a1021 1
.Pp
a1051 6
An equivalent for
.Ar block return
is
.Ar fuck-off .
It can probably be imagined fairly well by Theo de Raadt jumping into
your computer and shouting at the network connection.
d1153 4
a1156 1
.It Ar from <source> port <source> to <dest> port <dest>
d1228 9
a1236 1
The host and port specifications are optional, as in the following examples:
d1244 1
d1722 3
a1724 2
Both
.Ar keep state
d1726 1
a1726 1
.Ar modulate state
d1747 67
d2242 5
d2287 2
a2288 1
                 [ "require-order" ( "yes" | "no" ) ] )
d2297 2
a2298 1
                 ( "keep" | "modulate" ) "state" [ "(" state-opts ")" ] |
d2375 1
a2375 1
                 "{" host-list "}" ) [ port ]
d2391 1
d2400 3
d2459 2
d2477 1
@


1.10
log
@mop up
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.9 2003/06/19 16:44:24 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.260 2003/07/04 10:42:52 henning Exp $
d653 1
a653 1
.Ar. hfsc
d875 3
a877 3
address and port number. In addition, packets that
match a translation rule are not automatically passed
through the packet filter unless the
d879 1
a879 1
modifier is given; translated packets are
d1988 1
d2039 2
a2040 2
# translate outgoing packets' source addresses (any protocol)
# in this case, any address but the gateway's external address is mapped
d2044 3
a2046 3
# map outgoing packets' source port to an assigned proxy port instead of
# an arbitrary port
# in this case, proxy outgoing isakmp with port 500 on the gateway
d2051 3
a2053 3
# translate outgoing packets' source address (any protocol)
# translate incoming packets' destination address to an internal machine
# (bidirectional)
d2057 2
a2058 2
# translate incoming packets' destination addresses
# as an example, redirect a TCP and UDP port to an internal machine
d2065 2
a2066 2
# translate outgoing ftp control connections to send them to localhost
# for proxying with ftp-proxy(8) running on port 8021
d2068 2
a2069 1

d2075 1
a2075 1

d2077 2
a2078 2
# translate outgoing packets' source addresses using an address pool.  A
# given source address is always translated to the same pool address by
d2083 2
a2084 2
# translate incoming web server connections to a group of web servers on
# the internal network
@


1.9
log
@merge cvs import - OpenBSD tree as of Thu Jun 19 16:13:15 UTC 2003
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.8 2003/06/09 01:07:13 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.259 2003/06/17 21:48:11 david Exp $
d877 3
a879 1
through the packet filter; translated packets are
d1988 7
d2205 2
a2206 2
nat-rule       = [ "no" ] "nat" [ "on" ifspec ] [ af ] [ protospec ]
                 hosts [ "tag" string ]
d2210 2
a2211 2
binat-rule     = [ "no" ] "binat" [ "on" interface-name ] [ af ]
                 [ "proto" ( proto-name | proto-number ) ]
d2216 2
a2217 2
rdr-rule       = [ "no" ] "rdr" [ "on" ifspec ] [ af ] [ protospec ]
                 hosts [ "tag" string ]
@


1.8
log
@merge import
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.7 2003/06/06 18:28:41 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.254 2003/06/07 20:31:13 henning Exp $
d1040 5
d1685 7
d2171 1
a2171 1
                 trans-anchors | load-anchors )
d2226 1
a2226 1
                 "queue" queue-list
d2228 1
a2228 1
                 queue-list
d2241 1
a2241 2
                 [ "priority" number ] | [ schedulers ] |
                 [ "qlimit" number ]
d2304 1
a2304 1
state-opt      = ( "max" number ) | ( timeout seconds )
d2314 3
a2316 3
                 "other.first" | "other.single" | "other.multiple" )
                 seconds
seconds        = number
@


1.7
log
@Merge OpenBSD-current
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.6 2003/05/22 14:08:19 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.250 2003/06/03 12:18:02 henning Exp $
d1377 32
a1408 2
A tag will be assigned to packets matching this rule.
Subsequent rules can match on that tag using the
d1410 1
a1410 6
keyword, even on another interface.
The tag is set on every matching rule, not just the last one.
There is one tag per packet, subsequent matches replace it.
.It Ar tagged <string>
This rule applies only to packets that have been tagged with the given
tag.
d1857 6
d1919 18
d2127 24
d2181 1
a2181 1
                 "label" string | "tag" string | "tagged" string
d2185 2
a2186 1
                 hosts [ "->" ( redirhost | "{" redirhost-list "}" )
d2192 1
d2196 2
a2197 1
                 hosts [ "->" ( redirhost | "{" redirhost-list "}" )
@


1.6
log
@merge CVS import stuff
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.5 2003/05/07 20:54:20 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.246 2003/05/17 07:50:46 henning Exp $
d280 1
a280 1
The state after an icmp error came back in response to an icmp packet.
d453 1
a453 1
bit from a matching ip packet.
d478 1
a478 1
Enforces a minimum ttl for matching ip packets.
d480 1
a480 1
Enforces a maximum mss for matching tcp packets.
d870 13
a882 1
Translation occurs before filtering.
d947 1
a947 5
.Pp
If no rule matches the packet, the packet is passed to the filter unmodified.
Translation occurs before the filter rules are applied;
therefore rules for redirected packets should specify the address and port
after translation.
d1368 1
a1368 1
.Sx QUEUE RULES
d1480 1
a1480 1
from modifying the source port on tcp and udp packets.
d2084 168
a2251 165
line           = ( OPTION | PF-RULE | NAT-RULE | BINAT-RULE | RDR-RULE
                 | ANTISPOOF-RULE | ALTQ-RULE | QUEUE-RULE | ANCHOR-RULE
                 | TRANS-ANCHORS | LOAD-ANCHORS )

option         = set ( [ TIMEOUT ( TIMEOUT | '{' TIMEOUT-LIST '}' ) ] |
                 [ optimization [ default | normal
                 | high-latency | satellite
                 | aggressive | conservative ] ]
                 [ limit LIMIT-LIST ] |
                 [ loginterface ( INTERFACE-NAME | none ) ] |
                 [ block-policy ( drop | return ) ] |
                 [ require-order ( yes | no ) ] )

pf-rule        = ACTION [ ( in | out ) ]
                 [ log | log-all ] [ quick ]
                 [ on IFSPEC ] [ ROUTE ] [ AF ] [ PROTOSPEC ]
                 HOSTS [ FILTEROPT-LIST ]

filteropt-list = FILTEROPT-LIST FILTEROPT | FILTEROPT
filteropt      = USER | GROUP | FLAGS | ICMP-TYPE | ICMP6-TYPE | TOS |
                 ( keep | modulate ) state [ '(' STATE-OPTS ')' ] |
                 fragment | no-df | min-ttl NUMBER | max-mss NUMBER |
                 random-id | reassemble tcp | FRAGMENTATION | allow-opts |
                 label STRING | tag STRING | tagged STRING
		 queue '(' STRING | ( STRING [ [ ',' ] STRING ] ) ')'

nat-rule       = [ no ] nat [ on IFSPEC ] [ AF ] [ PROTOSPEC ]
                 HOSTS [ '->' ( REDIRHOST | '{' REDIRHOST-LIST '}' )
                 [ PORTSPEC ] [ POOLTYPE ] [ static-port ] ]

binat-rule     = [ no ] binat [ on INTERFACE-NAME ] [ AF ]
                 [ proto ( PROTO-NAME | PROTO-NUMBER ) ]
                 from ADDRESS [ '/' MASK-BITS ] to IPSPEC
                 [ '->' ADDRESS [ '/' MASK-BITS ] ]

rdr-rule       = [ no ] rdr [ on IFSPEC ] [ AF ] [ PROTOSPEC ]
                 HOSTS [ '->' ( REDIRHOST | '{' REDIRHOST-LIST '}' )
                 [ PORTSPEC ] [ POOLTYPE ] ]

antispoof-rule = antispoof [ log ] [ quick ]
                 for ( INTERFACE-NAME | '{' INTERFACE-LIST '}' )
                 [ AF ] [ label STRING ]

table-rule     = table '<' STRING '>' [ TABLEOPTS-LIST ]
tableopts-list = TABLEOPTS-LIST TABLEOPTS | TABLEOPTS
tableopts      = persist | const | file STRING | '{' [ TABLEADDR-LIST ] '}'
tableaddr-list = TABLEADDR-LIST [ ',' ] TABLEADDR-SPEC | TABLEADDR-SPEC
tableaddr-spec = [ '!' ] TABLEADDR [ '/' MASK-BITS ]
tableaddr      = HOSTNAME | IPV4-DOTTED-QUAD | IPV6-COLONED-HEX |
                 INTERFACE-NAME | self

altq-rule      = altq on INTERFACE-NAME QUEUEOPTS-LIST
                 queue QUEUE-LIST
queue-rule     = queue STRING [ on INTERFACE-NAME ] QUEUEOPTS-LIST
                 QUEUE-LIST

anchor-rule    = anchor STRING [ ( in | out ) ] [ on IFSPEC ] [ AF ]
                 [ proto ] [ PROTOSPEC ] [ HOSTS ]

trans-anchors  = ( nat-anchor | rdr-anchor | binat-anchor ) STRING
                 [ on IFSPEC ] [ AF ] [ proto ] [ PROTOSPEC ] [ HOSTS ]

load-anchor    = load anchorname:rulesetname from filename

queueopts-list = QUEUEOPTS-LIST QUEUEOPTS | QUEUEOPTS
queueopts      = [ bandwidth BANDWIDTH-SPEC ] |
                 [ qlimit NUMBER ] | [ tbrsize NUMBER ] |
                 [ priority NUMBER ] | [ SCHEDULERS ] |
                 [ qlimit NUMBER ]
schedulers     = ( CBQ-DEF | PRIQ-DEF | HFSC-DEF )
bandwidth-spec = number ( b | Kib | Mib | Gib | '%' )

action         = pass | block [ return ] | fuck-off | scrub
return         = drop | return | return-rst [ '(' ttl NUMBER ')' ]
                 | return-icmp [ '(' ICMPCODE [',' ICMP6CODE ] ')' ]
                 | return-icmp6 [ '(' ICMP6CODE ')' ]
icmpcode       = ( ICMP-CODE-NAME | ICMP-CODE-NUMBER )
icmp6code      = ( ICMP6-CODE-NAME | ICMP6-CODE-NUMBER )

ifspec         = ( [ '!' ] INTERFACE-NAME ) | '{' INTERFACE-LIST '}'
interface-list = [ '!' ] INTERFACE-NAME [ [ ',' ] INTERFACE-LIST ]
route          = fastroute |
                 ( route-to | reply-to | dup-to )
                 ( ROUTEHOST | '{' ROUTEHOST-LIST '}' )
                 [ POOLTYPE ]
af             = inet | inet6

protospec      = proto ( PROTO-NAME | PROTO-NUMBER |
                 '{' PROTO-LIST '}' )
proto-list     = ( PROTO-NAME | PROTO-NUMBER ) [ [ ',' ] PROTO-LIST ]

hosts          = all |
                 from ( any | no-route | self | HOST |
                 '{' HOST-LIST '}' ) [ PORT ]
                 to   ( any | no-route | self | HOST |
                 '{' HOST-LIST '}' ) [ PORT ]

ipspec         = any | HOST | '{' HOST-LIST '}'
host           = [ '!' ] ( ADDRESS [ '/' MASK-BITS ] | '<' STRING '>' )
redirhost      = ADDRESS [ '/' MASK-BITS ]
routehost      = ( INTERFACE-NAME [ ADDRESS [ '/' MASK-BITS ] ] )
address        = ( INTERFACE-NAME | '(' INTERFACE-NAME ')' | HOSTNAME
                 | IPV4-DOTTED-QUAD | IPV6-COLONED-HEX )
host-list      = HOST [ [ ',' ] HOST-LIST ]
redirhost-list = REDIRHOST [ [ ',' ] REDIRHOST-LIST ]
routehost-list = ROUTEHOST [ [ ',' ] ROUTEHOST-LIST ]

port           = port ( UNARY-OP | BINARY-OP | '{' OP-LIST '}' )
portspec       = port ( NUMBER | NAME ) [ ':' ( '*' | NUMBER | NAME ) ]
user           = user ( UNARY-OP | BINARY-OP | '{' OP-LIST '}' )
group          = group ( UNARY-OP | BINARY-OP | '{' OP-LIST '}' )

unary-op       = [ '=' | '!=' | '<' | '<=' | '>' | '>=' ]
                 ( NAME | NUMBER )
binary-op      = NUMBER ( '<>' | '><' | ':' ) NUMBER
op-list        = ( UNARY-OP | BINARY-OP ) [ [ ',' ] OP-LIST ]

flags          = flags [ FLAG-SET ] '/' FLAG-SET
flag-set       = [ F ] [ S ] [ R ] [ P ] [ A ] [ U ] [ E ] [ W ]

icmp-type      = icmp-type ( ICMP-TYPE-CODE | '{' ICMP-LIST '}' )
icmp6-type     = icmp6-type ( ICMP-TYPE-CODE | '{' ICMP-LIST '}')
icmp-type-code = ( ICMP-TYPE-NAME | ICMP-TYPE-NUMBER )
                 [ code ( ICMP-CODE-NAME | ICMP-CODE-NUMBER ) ]
icmp-list      = ICMP-TYPE-CODE [ [ ',' ] ICMP-LIST ]

tos            = tos ( lowdelay | throughput | reliability |
                 [ 0x ] NUMBER )

state-opts     = STATE-OPT [ [ ',' ] STATE-OPTS ]
state-opt      = ( max NUMBER ) | ( timeout SECONDS )

fragmentation  = [ fragment reassemble | fragment crop
                 | fragment drop-ovl ]

timeout-list   = TIMEOUT [ [ ',' ] TIMEOUT-LIST ]
timeout        = ( tcp.first | tcp.opening | tcp.established
                 | tcp.closing | tcp.finwait | tcp.closed
                 | udp.first | udp.single | udp.multiple
                 | icmp.first | icmp.error
                 | other.first | other.single | other.multiple )
                 SECONDS
seconds        = NUMBER

limit-list     = LIMIT-ITEM [ [ ',' ] LIMIT-LIST ]
limit-item     = ( states | frags ) NUMBER

pooltype       = ( bitmask | random
                 | source-hash [ ( hex-key | string-key ) ]
                 | round-robin )

subqueue       = STRING | '{' QUEUE-LIST '}'
queue-list     = STRING [ [ ',' ] STRING ]
cbq-def        = cbq [ '(' CBQ-OPT [ [ ',' ] CBQ-OPT ] ')' ]
priq-def       = priq [ '(' PRIQ-OPT [ [ ',' ] PRIQ-OPT ] ')' ]
hfsc-def       = hfsc [ '(' HFSC-OPT [ [ ',' ] HFSC-OPT ] ')' ]
cbq-opt        = ( default | borrow | red | ecn | rio )
priq-opt       = ( default | red | ecn | rio )
hfsc-opt       = ( default | red | ecn | rio
                 | LINKSHARE-SC | REALTIME-SC | UPPERLIMIT-SC )
linkshare-sc   = linkshare SC-SPEC
realtime-sc    = realtime SC-SPEC
upperlimit-sc  = upperlimit SC-SPEC
sc-spec        = ( BANDWIDTH-SPEC
                 | '(' BANDWIDTH-SPEC NUMBER BANDWIDTH-SPEC ')' )
@


1.5
log
@merge conflicts; fix what(1) stdin
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.4 2003/04/10 20:12:06 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.229 2003/05/06 15:52:27 henning Exp $
a42 1
.Pp
d57 1
a57 1
.It Cm Traffic Normalization Li (e.g. Em scrub Ns )
a82 1
.Pp
d94 1
a94 1
.Ar out Ns ).
a103 1
.Pp
d291 21
d314 4
a317 2
set timeout tcp.established 3600
set timeout { tcp.opening 30, tcp.closing 900 }
d320 3
a435 1
.Pp
d523 33
a775 1
.Pp
d793 1
a793 1
.Ar ( m1 , d , m2 ) . 
d836 1
a836 1
.Xr sftp 1 Ns .
a860 1
.Pp
a969 1
.Pp
d979 1
a979 1
.Xr ip6 4 Ns )
d984 1
a984 1
.Xr udp 4 Ns )
d1024 1
a1024 2
packets, an ICMP UNREACHABLE for UDP packets,
and silently drops all other packets.
d1212 1
a1212 1
.Ar user Ns ,
d1368 10
d1417 1
a1417 1
.Ar route-to.
a1419 1
.Pp
a1473 1
.Pp
d1615 36
a1716 1
.Pp
d2076 3
a2078 3
line           = ( option | pf-rule | nat-rule | binat-rule | rdr-rule
                 | antispoof-rule | altq-rule | queue-rule | anchor-rule
                 | trans-anchors )
d2080 1
a2080 1
option         = set ( [ timeout ( timeout | { timeout-list } ) ] |
d2084 2
a2085 2
                 [ limit limit-list ] |
                 [ loginterface ( interface-name | none ) ] |
d2089 1
a2089 1
pf-rule        = action [ ( in | out ) ]
d2091 2
a2092 2
                 [ on ifspec ] [ route ] [ af ] [ protospec ]
                 hosts [ filteropt-list ]
d2094 20
a2113 19
filteropt-list = filteropt-list filteropt | filteropt
filteropt      = user | group | flags | icmp-type | icmp6-type | tos |
                 ( keep | modulate ) state [ ( state-opts ) ] |
                 fragment | no-df | min-ttl number | max-mss number |
                 random-id | fragmentation | allow-opts | label string |
                 queue ( string | ( string [ [ , ] string ] ) )

nat-rule       = [ no ] nat [ on ifspec ] [ af ] [ protospec ]
                 hosts [ -> ( redirhost | { redirhost-list } )
                 [ portspec ] ] [ pooltype ] [ static-port ]

binat-rule     = [ no ] binat [ on interface-name ] [ af ]
                 [ proto ( proto-name | proto-number ) ]
                 from address [ / mask-bits ] to ipspec
                 [ -> address [ / mask-bits ] ]

rdr-rule       = [ no ] rdr [ on ifspec ] [ af ] [ protospec ]
                 hosts [ -> ( redirhost | { redirhost-list } )
                 [ portspec ] ] [ pooltype ]
d2116 2
a2117 2
                 for ( interface-name | { interface-list } )
                 [ af ] [ label ]
d2119 28
a2146 26
table-rule     = table < tablename > [ tableopts-list ]
tableopts-list = tableopts-list tableopts | tableopts
tableopts      = persist | const | file "filename" | { [ tableaddr-list ] }
tableaddr-list = tableaddr-list [ , ] tableaddr-spec | tableaddr-spec
tableaddr-spec = [ ! ] tableaddr [ / mask-bits ]
tableaddr      = hostname | ipv4-dotted-quad | ipv6-coloned-hex |
                 interface-name | self

altq-rule      = altq on interface-name queueopts-list
                 queue queue-list
queue-rule     = queue string [ on interface-name ] queueopts-list
                 queue-list

anchor-rule    = anchor string [ ( in | out ) ] [ on ifspec ] [ af ]
                 [ proto ] [ protospec ] [ hosts ]

trans-anchors  = ( nat-anchor | rdr-anchor | binat-anchor ) string
                 [ on ifspec ] [ af ] [ proto ] [ protospec ] [ hosts ]

queueopts-list = queueopts-list queueopts | queueopts
queueopts      = [ bandwidth bandwidth-spec ] |
                 [ qlimit number ] | [ tbrsize number ] |
                 [ priority number ] | [ schedulers ] |
                 [ qlimit number ]
schedulers     = ( cbq-def | priq-def | hfsc-def )
bandwidth-spec = number ( b | Kib | Mib | Gib | % )
d2149 5
a2153 5
return         = drop | return | return-rst [ ( ttl number ) ]
                 | return-icmp [ ( icmpcode [, icmp6code ] ) ]
                 | return-icmp6 [ ( icmp6code ) ]
icmpcode       = ( icmp-code-name | icmp-code-number )
icmp6code      = ( icmp6-code-name | icmp6-code-number )
d2155 2
a2156 2
ifspec         = ( [ ! ] interface-name ) | { interface-list }
interface-list = [ ! ] interface-name [ [ , ] interface-list ]
d2159 2
a2160 2
                 ( routehost | { routehost-list } )
                 [ pooltype ]
d2163 3
a2165 3
protospec      = proto ( proto-name | proto-number |
                 { proto-list } )
proto-list     = ( proto-name | proto-number ) [ [ , ] proto-list ]
d2168 24
a2191 24
                 from ( any | no-route | self | host |
                 { host-list } ) [ port ]
                 to   ( any | no-route | self | host |
                 { host-list } ) [ port ]

ipspec         = any | host | { host-list }
host           = [ ! ] ( address [ / mask-bits ] | < table > )
redirhost      = address [ / mask-bits ]
routehost      = ( interface-name [ address [ / mask-bits ] ] )
address        = ( interface-name | ( interface-name ) | host-name
                 | ipv4-dotted-quad | ipv6-coloned-hex )
host-list      = host [ [ , ] host-list ]
redirhost-list = redirhost [ [,] redirhost-list ]
routehost-list = routehost [ [,] routehost-list ]

port           = port ( unary-op | binary-op | { op-list } )
portspec       = port ( number | name ) [ : ( * | number | name ) ]
user           = user ( unary-op | binary-op | { op-list } )
group          = group ( unary-op | binary-op | { op-list } )

unary-op       = [ = | != | < | <= | > | >= ]
                 ( name | number )
binary-op      = number ( <> | >< | : ) number
op-list        = ( unary-op | binary-op ) [ [ , ] op-list ]
d2193 1
a2193 1
flags          = flags [ flag-set ] / flag-set
d2196 5
a2200 5
icmp-type      = icmp-type ( icmp-type-code | { icmp-list } )
icmp6-type     = icmp6-type ( icmp-type-code | { icmp-list } )
icmp-type-code = ( icmp-type-name | icmp-type-number )
                 [ code ( icmp-code-name | icmp-code-number ) ]
icmp-list      = icmp-type-code [ [ , ] icmp-list ]
d2203 1
a2203 1
                 [ 0x ] number )
d2205 2
a2206 2
state-opts     = state-opt [ [ , ] state-opts ]
state-opt      = ( max number ) | ( timeout seconds )
d2211 1
a2211 1
timeout-list   = timeout [ [ , ] timeout-list ]
d2217 2
a2218 2
                 seconds
seconds        = number
d2220 2
a2221 2
limit-list     = limit-item [ [ , ] limit-list ]
limit-item     = ( states | frags ) number
d2227 5
a2231 5
subqueue       = string | { queue-list }
queue-list     = string [ [ , ] string ]
cbq-def        = cbq [ ( cbq-opt [ [ , ] cbq-opt ] ) ]
priq-def       = priq [ ( priq-opt [ [ , ] priq-opt ] ) ]
hfsc-def       = hfsc [ ( hfsc-opt [ [ , ] hfsc-opt ] ) ]
d2235 6
a2240 6
                 | linkshare-sc | realtime-sc | upperlimit-sc )
linkshare-sc   = linkshare sc-spec
realtime-sc    = realtime sc-spec
upperlimit-sc  = upperlimit sc-spec
sc-spec        = ( bandwidth-spec
                 | ( bandwidth-spec number bandwidth-spec ) )
@


1.4
log
@clean up the cvs import mess

nb, this doesnt mean the tree builds.
its bed time
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.3 2003/03/29 21:33:33 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.222 2003/04/05 21:46:50 henning Exp $
d526 1
a526 1
There are two
d563 16
d595 1
a595 1
for Class Based Queueing and
d597 3
a599 1
for Priority Queueing.
d647 2
a648 2
directive (e.g. mail), or, for the
.Ar cbq
d670 3
a672 1
.Ar cbq ,
d676 1
a676 1
The default for both is 1.
d680 2
d721 32
d754 3
a756 1
.Ar cbq ,
d1317 1
a1317 1
.Pp
d1580 1
d1863 1
a1863 1
listening for outbound ftp sessions captured to port 8081.
d1893 2
a1894 2
# for proxying with ftp-proxy(8) running on port 8081
rdr on fxp0 proto tcp from any to any port 21 -> 127.0.0.1 port 8081
d2004 2
a2005 2
                 random-id | fragmentation | allow-opts |
                 label string | queue ( string | ( string [ [ , ] string ] ) )
d2021 2
a2022 1
                 for ( interface-name | { interface-list } ) [ af ]
d2034 2
a2035 1
queue-rule     = queue string [ on interface-name ] queueopts-list queue-list
d2037 2
a2038 2
anchor-rule    = anchor string [ ( in | out ) ] [ on ifspec ] [ af ] [ proto ]
                 [ protospec ] [ hosts ]
d2044 1
a2044 1
queueopts      = [ bandwidth number ( b | Kib | Mib | Gib | % ) ] |
d2048 2
a2049 1
schedulers     = ( cbq-def | priq-def )
d2134 1
d2137 7
@


1.3
log
@merge OpenBSD cvs import conflicts
enable /etc/isdn directory and MAKEDEV.i4b
@
text
@d1 2
a2 2
.\"	$MirBSD: pf.conf.5,v 1.2 2003/03/23 21:52:10 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.219 2003/03/22 00:10:17 david Exp $
d637 3
d1926 2
a1927 1
                 | antispoof-rule | altq-rule | queue-rule )
d1976 7
a1982 1
queue-rule     = queue string queueopts-list queue-list
d1985 1
a1985 1
queueopts      = [ bandwidth number ( b | Kib | Mib | Gib | %) ] |
d2036 1
a2036 1
flags          = flags ( flag-set / flag-set | / flag-set )
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 2
a2 2
.\"	$MirBSD: obsd.tygs,v 1.44 2003/03/22 22:33:30 tg Exp $
.\"	$OpenBSD: pf.conf.5,v 1.218 2003/03/20 01:27:17 david Exp $
d104 1
a104 1
pass in \ on $ext_if proto tcp from any to any port 25 keep state
d731 2
a732 2
queue \ developers bandwidth 75% cbq(borrow)
queue \ employees bandwidth 15%
d735 2
a736 2
queue \ ssh_interactive priority 7
queue \ ssh_bulk priority 0
d1095 1
a1095 1
pass in proto tcp from 10.0.0.0/8 port >1024 \e
d1153 2
a1154 2
pass \ out proto { tcp, udp } all \e
   user { < 1000, dhartmei } keep state
d1228 1
a1228 2
      port >1023
label \&"$dstaddr:$dstport\&"
d1233 4
a1236 4
pass in proto tcp from any to 1.2.3.4 \e
      port >1023 label \&"1.2.3.4:>1023\&"
pass in proto tcp from any to 1.2.3.5 \e
      port >1023 label \&"1.2.3.5:>1023\&"
d1393 1
a1393 1
pass  in proto tcp from any to any port 25 flags S/SA keep state
d1441 1
a1441 1
.Ar nat, binat No and Ar rdr
d1463 3
a1465 2
block all pass out proto tcp from any to any modulate state
pass in proto tcp from any to any port 25 flags S/SA modulate state
d1538 2
a1539 2
block in on ! lo0 inet from 127.0.0.1/8 to any
block in on ! lo0 inet6 from ::1 to any
d1553 2
a1554 2
block in on ! wi0 inet from 10.0.0.1/24 to any
block in inet from 10.0.0.1 to any
d1718 1
a1718 1
# echo \&"block in quick from 1.2.3.4 to any\&" \&|
d1750 1
a1750 1
# echo \&"block in quick from 1.2.3.4 to any" \&|
d1793 3
a1795 3
no rdr on fxp0 from any to $server port 80
no rdr on fxp0 from $sysadmins to any port 80
rdr on fxp0 from any to any port 80 -> 127.0.0.1 port 80
d1975 1
a1975 1
queueopts      = [ bandwidth number ( b | Kib | Mib | Gib |  %) ] |
@


1.1
log
@Initial revision
@
text
@d1 1
d591 2
a592 2
.Ar Kb ,
.Ar Mb ,
d594 3
a596 3
.Ar Gb
are used to represent bits, kilobits, megabits, and
gigabits per second, respectively.
d617 1
a617 1
altq on dc0 cbq bandwidth 5Mb queue { std, http, mail, ssh }
d915 6
d1975 1
a1975 1
queueopts      = [ bandwidth number ( b | Kb | Mb | Gb |  %) ] |
d1981 1
a1981 1
action         = pass | block [ return ] | scrub
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD repository of CTM 3155 (roughly today at noon).
Mostly in order to go 3.3-current and ease further merges of
both OpenBSD and ELFdiffs after the MirBSD has been enabled
to build again.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.219 2003/03/22 00:10:17 david Exp $
d103 1
a103 1
pass in  on $ext_if proto tcp from any to any port 25 keep state
d730 2
a731 2
queue  developers bandwidth 75% cbq(borrow)
queue  employees bandwidth 15%
d734 2
a735 2
queue  ssh_interactive priority 7
queue  ssh_bulk priority 0
d1088 1
a1088 1
pass in proto tcp from 10.0.0.0/8 port > 1024 \e
d1146 2
a1147 2
pass  out proto { tcp, udp } all \e
      user { < 1000, dhartmei } keep state
d1221 2
a1222 1
      port > 1023 label \&"$dstaddr:$dstport\&"
d1227 4
a1230 4
pass in inet proto tcp from any to 1.2.3.4 \e
      port > 1023 label \&"1.2.3.4:>1023\&"
pass in inet proto tcp from any to 1.2.3.5 \e
      port > 1023 label \&"1.2.3.5:>1023\&"
d1387 1
a1387 1
pass in  proto tcp from any to any port 25 flags S/SA keep state
d1435 1
a1435 1
.Ar nat , binat No and Ar rdr
d1457 2
a1458 3
block all
pass out proto tcp from any to any modulate state
pass in  proto tcp from any to any port 25 flags S/SA modulate state
d1531 2
a1532 2
block drop in on ! lo0 inet from 127.0.0.1/8 to any
block drop in on ! lo0 inet6 from ::1 to any
d1546 2
a1547 2
block drop in on ! wi0 inet from 10.0.0.0/24 to any
block drop in inet from 10.0.0.1 to any
d1711 1
a1711 1
# echo \&"block in quick from 1.2.3.4 to any\&" \&| \e
d1743 1
a1743 1
# echo \&"block in quick from 1.2.3.4 to any" \&| \e
d1786 3
a1788 3
no rdr on fxp0 proto { tcp, udp } from any to $server port 80
no rdr on fxp0 proto { tcp, udp } from $sysadmins to any port 80
rdr on fxp0 proto { tcp, udp } from any to any port 80 -> 127.0.0.1 port 80
d1968 1
a1968 1
queueopts      = [ bandwidth number ( b | Kb | Mb | Gb | %) ] |
@


1.1.1.3
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.222 2003/04/05 21:46:50 henning Exp $
a635 3
.It Ar on <interface>
Specifies the interface the queue operates on.
If not given, it operates on all matching interfaces.
d1916 1
a1916 2
                 | antispoof-rule | altq-rule | queue-rule | anchor-rule
                 | trans-anchors )
d1965 1
a1965 7
queue-rule     = queue string [ on interface-name ] queueopts-list queue-list

anchor-rule    = anchor string [ ( in | out ) ] [ on ifspec ] [ af ] [ proto ]
                 [ protospec ] [ hosts ]

trans-anchors  = ( nat-anchor | rdr-anchor | binat-anchor ) string
                 [ on ifspec ] [ af ] [ proto ] [ protospec ] [ hosts ]
d1968 1
a1968 1
queueopts      = [ bandwidth number ( b | Kb | Mb | Gb | % ) ] |
d2019 1
a2019 1
flags          = flags [ flag-set ] / flag-set
@


1.1.1.4
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.229 2003/05/06 15:52:27 henning Exp $
d525 1
a525 1
There are three
a561 16
.It Ar hfsc
Hierarchical Fair Service Curve.
.Ar Queues
attached to an interface build a tree, thus each
.Ar queue
can have further child
.Ar queues .
Each queue can have a
.Ar priority
and a
.Ar bandwidth
assigned.
.Ar Priority
mainly controls the time packets take to get sent out, while
.Ar bandwidth
has primarily effects on throughput.
d578 1
a578 1
for Class Based Queueing,
d580 1
a580 3
for Priority Queueing and
.Ar. hfsc
for the Hierarchical Fair Service Curve scheduler.
d628 2
a629 2
directive (e.g. mail), or, except for the
.Ar priq
d651 1
a651 3
.Ar cbq
and
.Ar hfsc ,
d655 1
a655 1
The default for all is 1.
a658 2
and
.Ar Hfsc
a697 32
.Pp
The
.Ar hfsc
.Ar scheduler
supports some additional options:
.Bl -tag -width Fl
.It Ar realtime <sc>
The minimum required bandwidth for the queue.
.It Ar upperlimit <sc>
The maximum allowed bandwidth for the queue.
.It Ar linkshare <sc>
The bandwidth share of a backlogged queue.
.El
.Pp
<sc> is an acronym for
.Ar service curve .
.Pp
The format for service curve specifications is
.Ar ( m1 , d , m2 ) . 
.Ar m2
controls the bandwidth assigned to the queue.
.Ar m1
and
.Ar d
are optional and can be used to control the initial bandwidth assignment.
For the first
.Ar d
milliseconds the queue gets the bandwidth given as
.Ar m1 ,
afterwards the value given in
.Ar m2 .
.Pp
d699 1
a699 3
.Ar cbq
and
.Ar hfsc ,
d1254 1
a1254 1
.El
a1516 1
.El
d1799 1
a1799 1
listening for outbound ftp sessions captured to port 8021.
d1829 2
a1830 2
# for proxying with ftp-proxy(8) running on port 8021
rdr on fxp0 proto tcp from any to any port 21 -> 127.0.0.1 port 8021
d1940 2
a1941 2
                 random-id | fragmentation | allow-opts | label string |
                 queue ( string | ( string [ [ , ] string ] ) )
d1957 1
a1957 2
                 for ( interface-name | { interface-list } )
                 [ af ] [ label ]
d1969 1
a1969 2
queue-rule     = queue string [ on interface-name ] queueopts-list
                 queue-list
d1971 2
a1972 2
anchor-rule    = anchor string [ ( in | out ) ] [ on ifspec ] [ af ]
                 [ proto ] [ protospec ] [ hosts ]
d1978 1
a1978 1
queueopts      = [ bandwidth bandwidth-spec ] |
d1982 1
a1982 2
schedulers     = ( cbq-def | priq-def | hfsc-def )
bandwidth-spec = number ( b | Kb | Mb | Gb | % )
a2066 1
hfsc-def       = hfsc [ ( hfsc-opt [ [ , ] hfsc-opt ] ) ]
a2068 7
hfsc-opt       = ( default | red | ecn | rio
                 | linkshare-sc | realtime-sc | upperlimit-sc )
linkshare-sc   = linkshare sc-spec
realtime-sc    = realtime sc-spec
upperlimit-sc  = upperlimit sc-spec
sc-spec        = ( bandwidth-spec
                 | ( bandwidth-spec number bandwidth-spec ) )
@


1.1.1.5
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.246 2003/05/17 07:50:46 henning Exp $
d42 1
d57 1
a57 1
.It Cm Traffic Normalization Li (e.g. Em scrub )
d83 1
d95 1
a95 1
.Ar out ) .
d105 1
a292 21
Timeout values can be reduced adaptively as the number of state table
entries grows.
.Pp
.Bl -tag -width xxxx -compact
.It Ar adaptive.start
When the number of state entries exceeds this value, adaptive scaling
begins.
All timeout values are scaled linearly with factor
(adaptive.end - number of states) / (adaptive.end - adaptive.start).
.It Ar adaptive.end
When reaching this number of state entries, all timeout values become
zero, effectively purging all state entries immediately.
This value is used to define the scale factor, it should not actually
be reached (set a lower state limit, see below).
.El
.Pp
These values can be defined both globally and for each rule.
When used on a per-rule basis, the values relate to the number of
states created by the rule, otherwise to the total number of
states.
.Pp
d295 2
a296 4
set timeout tcp.first 120
set timeout tcp.established 86400
set timeout { adaptive.start 6000, adaptive.end 12000 }
set limit states 10000
a298 3
With 9000 state table entries, the timeout values are scaled to 50%
(tcp.first 60, tcp.established 43200).
.Pp
d412 1
a499 33
.It Ar reassemble tcp
Statefully normalizes TCP connections.
.Ar scrub reassemble tcp
rules may not have the direction (in/out) specified.
.Ar reassemble tcp
performs the following normalizations:
.Pp
.Bl -tag -width timeout -compact
.It ttl
Neither side of the connection is allowed to reduce their IP TTL.
An attacker may send a packet such that it reaches the firewall, affects
the firewall state, and expires before reaching the destination host.
.Ar reassemble tcp
will raise the TTL of all packets back up to the highest value seen on
the connection.
.It timeout modulation
Modern TCP stacks will send a timestamp on every TCP packet and echo
the other endpoint's timestamp back to them.
Many operating systems will merely start the timestamp at zero when
first booted, and increment it several times a second.
The uptime of the host can be deduced by reading the timestamp and multiplying
by a constant.
Also observing several different timestamps can be used to count hosts
behind a NAT device.
And spoofing TCP packets into a connection requires knowing or guessing
valid timestamps.
Timestamps merely need to be monotonically increasing and not derived off a
guessable base time.
.Ar reassemple tcp
will cause
.Ar scrub
to modulate the TCP timestamps with a random number.
.El
d720 1
d738 1
a738 1
.Ar ( m1 , d , m2 ) .
d781 1
a781 1
.Xr sftp 1 .
d806 1
d916 1
d926 1
a926 1
.Xr ip6 4 )
d931 1
a931 1
.Xr udp 4 )
d971 2
a972 1
packets and an ICMP UNREACHABLE for UDP and other packets.
d1154 1
a1154 1
.Ar user ,
a1309 10
.It Ar tag <string>
A tag will be assigned to packets matching this rule.
Subsequent rules can match on that tag using the
.Ar tagged
keyword, even on another interface.
The tag is set on every matching rule, not just the last one.
There is one tag per packet, subsequent matches replace it.
.It Ar tagged <string>
This rule applies only to packets that have been tagged with the given
tag.
d1349 1
a1349 1
.Ar route-to .
d1352 1
d1407 1
a1548 36
.Sh SYN PROXY
By default,
.Xr pf 4
passes packets that are part of a
.Xr tcp 4
handshake between the endpoints.
The
.Ar synproxy state
option can be used to cause
.Xr pf 4
itself to complete the handshake with the active endpoint, perform a handshake
with the passive endpoint, and then forward packets between the endpoints.
.Pp
No packets are sent to the passive endpoint before the active endpoint has
completed the handshake, hence so-called SYN floods with spoofed source
addresses will not reach the passive endpoint, as the sender can't complete the
handshake.
.Pp
The proxy is transparent to both endpoints, they each see a single
connection from/to the other endpoint.
.Xr pf 4
choses random initial sequence numbers for both handshakes.
Once the handshakes are completed, the sequence number modulators
(see previous section) are used to translate further packets of the
connection.
Hence,
.Ar synproxy state
includes
.Ar modulate state
and
.Ar keep state .
.Pp
Example:
.Bd -literal -offset indent
pass in proto tcp from any to any port www flags S/SA synproxy state
.Ed
d1615 1
d1975 3
a1977 3
line           = ( OPTION | PF-RULE | NAT-RULE | BINAT-RULE | RDR-RULE
                 | ANTISPOOF-RULE | ALTQ-RULE | QUEUE-RULE | ANCHOR-RULE
                 | TRANS-ANCHORS | LOAD-ANCHORS )
d1979 1
a1979 1
option         = set ( [ TIMEOUT ( TIMEOUT | '{' TIMEOUT-LIST '}' ) ] |
d1983 2
a1984 2
                 [ limit LIMIT-LIST ] |
                 [ loginterface ( INTERFACE-NAME | none ) ] |
d1988 1
a1988 1
pf-rule        = ACTION [ ( in | out ) ]
d1990 2
a1991 2
                 [ on IFSPEC ] [ ROUTE ] [ AF ] [ PROTOSPEC ]
                 HOSTS [ FILTEROPT-LIST ]
d1993 19
a2011 20
filteropt-list = FILTEROPT-LIST FILTEROPT | FILTEROPT
filteropt      = USER | GROUP | FLAGS | ICMP-TYPE | ICMP6-TYPE | TOS |
                 ( keep | modulate ) state [ '(' STATE-OPTS ')' ] |
                 fragment | no-df | min-ttl NUMBER | max-mss NUMBER |
                 random-id | reassemble tcp | FRAGMENTATION | allow-opts |
                 label STRING | tag STRING | tagged STRING
		 queue '(' STRING | ( STRING [ [ ',' ] STRING ] ) ')'

nat-rule       = [ no ] nat [ on IFSPEC ] [ AF ] [ PROTOSPEC ]
                 HOSTS [ '->' ( REDIRHOST | '{' REDIRHOST-LIST '}' )
                 [ PORTSPEC ] [ POOLTYPE ] [ static-port ] ]

binat-rule     = [ no ] binat [ on INTERFACE-NAME ] [ AF ]
                 [ proto ( PROTO-NAME | PROTO-NUMBER ) ]
                 from ADDRESS [ '/' MASK-BITS ] to IPSPEC
                 [ '->' ADDRESS [ '/' MASK-BITS ] ]

rdr-rule       = [ no ] rdr [ on IFSPEC ] [ AF ] [ PROTOSPEC ]
                 HOSTS [ '->' ( REDIRHOST | '{' REDIRHOST-LIST '}' )
                 [ PORTSPEC ] [ POOLTYPE ] ]
d2014 2
a2015 2
                 for ( INTERFACE-NAME | '{' INTERFACE-LIST '}' )
                 [ AF ] [ label STRING ]
d2017 26
a2042 28
table-rule     = table '<' STRING '>' [ TABLEOPTS-LIST ]
tableopts-list = TABLEOPTS-LIST TABLEOPTS | TABLEOPTS
tableopts      = persist | const | file STRING | '{' [ TABLEADDR-LIST ] '}'
tableaddr-list = TABLEADDR-LIST [ ',' ] TABLEADDR-SPEC | TABLEADDR-SPEC
tableaddr-spec = [ '!' ] TABLEADDR [ '/' MASK-BITS ]
tableaddr      = HOSTNAME | IPV4-DOTTED-QUAD | IPV6-COLONED-HEX |
                 INTERFACE-NAME | self

altq-rule      = altq on INTERFACE-NAME QUEUEOPTS-LIST
                 queue QUEUE-LIST
queue-rule     = queue STRING [ on INTERFACE-NAME ] QUEUEOPTS-LIST
                 QUEUE-LIST

anchor-rule    = anchor STRING [ ( in | out ) ] [ on IFSPEC ] [ AF ]
                 [ proto ] [ PROTOSPEC ] [ HOSTS ]

trans-anchors  = ( nat-anchor | rdr-anchor | binat-anchor ) STRING
                 [ on IFSPEC ] [ AF ] [ proto ] [ PROTOSPEC ] [ HOSTS ]

load-anchor    = load anchorname:rulesetname from filename

queueopts-list = QUEUEOPTS-LIST QUEUEOPTS | QUEUEOPTS
queueopts      = [ bandwidth BANDWIDTH-SPEC ] |
                 [ qlimit NUMBER ] | [ tbrsize NUMBER ] |
                 [ priority NUMBER ] | [ SCHEDULERS ] |
                 [ qlimit NUMBER ]
schedulers     = ( CBQ-DEF | PRIQ-DEF | HFSC-DEF )
bandwidth-spec = number ( b | Kb | Mb | Gb | '%' )
d2045 5
a2049 5
return         = drop | return | return-rst [ '(' ttl NUMBER ')' ]
                 | return-icmp [ '(' ICMPCODE [',' ICMP6CODE ] ')' ]
                 | return-icmp6 [ '(' ICMP6CODE ')' ]
icmpcode       = ( ICMP-CODE-NAME | ICMP-CODE-NUMBER )
icmp6code      = ( ICMP6-CODE-NAME | ICMP6-CODE-NUMBER )
d2051 2
a2052 2
ifspec         = ( [ '!' ] INTERFACE-NAME ) | '{' INTERFACE-LIST '}'
interface-list = [ '!' ] INTERFACE-NAME [ [ ',' ] INTERFACE-LIST ]
d2055 2
a2056 2
                 ( ROUTEHOST | '{' ROUTEHOST-LIST '}' )
                 [ POOLTYPE ]
d2059 3
a2061 3
protospec      = proto ( PROTO-NAME | PROTO-NUMBER |
                 '{' PROTO-LIST '}' )
proto-list     = ( PROTO-NAME | PROTO-NUMBER ) [ [ ',' ] PROTO-LIST ]
d2064 24
a2087 24
                 from ( any | no-route | self | HOST |
                 '{' HOST-LIST '}' ) [ PORT ]
                 to   ( any | no-route | self | HOST |
                 '{' HOST-LIST '}' ) [ PORT ]

ipspec         = any | HOST | '{' HOST-LIST '}'
host           = [ '!' ] ( ADDRESS [ '/' MASK-BITS ] | '<' STRING '>' )
redirhost      = ADDRESS [ '/' MASK-BITS ]
routehost      = ( INTERFACE-NAME [ ADDRESS [ '/' MASK-BITS ] ] )
address        = ( INTERFACE-NAME | '(' INTERFACE-NAME ')' | HOSTNAME
                 | IPV4-DOTTED-QUAD | IPV6-COLONED-HEX )
host-list      = HOST [ [ ',' ] HOST-LIST ]
redirhost-list = REDIRHOST [ [ ',' ] REDIRHOST-LIST ]
routehost-list = ROUTEHOST [ [ ',' ] ROUTEHOST-LIST ]

port           = port ( UNARY-OP | BINARY-OP | '{' OP-LIST '}' )
portspec       = port ( NUMBER | NAME ) [ ':' ( '*' | NUMBER | NAME ) ]
user           = user ( UNARY-OP | BINARY-OP | '{' OP-LIST '}' )
group          = group ( UNARY-OP | BINARY-OP | '{' OP-LIST '}' )

unary-op       = [ '=' | '!=' | '<' | '<=' | '>' | '>=' ]
                 ( NAME | NUMBER )
binary-op      = NUMBER ( '<>' | '><' | ':' ) NUMBER
op-list        = ( UNARY-OP | BINARY-OP ) [ [ ',' ] OP-LIST ]
d2089 1
a2089 1
flags          = flags [ FLAG-SET ] '/' FLAG-SET
d2092 5
a2096 5
icmp-type      = icmp-type ( ICMP-TYPE-CODE | '{' ICMP-LIST '}' )
icmp6-type     = icmp6-type ( ICMP-TYPE-CODE | '{' ICMP-LIST '}')
icmp-type-code = ( ICMP-TYPE-NAME | ICMP-TYPE-NUMBER )
                 [ code ( ICMP-CODE-NAME | ICMP-CODE-NUMBER ) ]
icmp-list      = ICMP-TYPE-CODE [ [ ',' ] ICMP-LIST ]
d2099 1
a2099 1
                 [ 0x ] NUMBER )
d2101 2
a2102 2
state-opts     = STATE-OPT [ [ ',' ] STATE-OPTS ]
state-opt      = ( max NUMBER ) | ( timeout SECONDS )
d2107 1
a2107 1
timeout-list   = TIMEOUT [ [ ',' ] TIMEOUT-LIST ]
d2113 2
a2114 2
                 SECONDS
seconds        = NUMBER
d2116 2
a2117 2
limit-list     = LIMIT-ITEM [ [ ',' ] LIMIT-LIST ]
limit-item     = ( states | frags ) NUMBER
d2123 5
a2127 5
subqueue       = STRING | '{' QUEUE-LIST '}'
queue-list     = STRING [ [ ',' ] STRING ]
cbq-def        = cbq [ '(' CBQ-OPT [ [ ',' ] CBQ-OPT ] ')' ]
priq-def       = priq [ '(' PRIQ-OPT [ [ ',' ] PRIQ-OPT ] ')' ]
hfsc-def       = hfsc [ '(' HFSC-OPT [ [ ',' ] HFSC-OPT ] ')' ]
d2131 6
a2136 6
                 | LINKSHARE-SC | REALTIME-SC | UPPERLIMIT-SC )
linkshare-sc   = linkshare SC-SPEC
realtime-sc    = realtime SC-SPEC
upperlimit-sc  = upperlimit SC-SPEC
sc-spec        = ( BANDWIDTH-SPEC
                 | '(' BANDWIDTH-SPEC NUMBER BANDWIDTH-SPEC ')' )
@


1.1.1.6
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.250 2003/06/03 12:18:02 henning Exp $
d279 1
a279 1
The state after an ICMP error came back in response to an ICMP packet.
d452 1
a452 1
bit from a matching IP packet.
d477 1
a477 1
Enforces a minimum TTL for matching IP packets.
d479 1
a479 1
Enforces a maximum MSS for matching TCP packets.
d869 1
a869 13
.Pp
Since translation occurs before filtering the filter
engine will see packets as they look after any
addresses and ports have been translated. Filter rules
will therefore have to filter based on the translated
address and port number. In addition, packets that
match a translation rule are not automatically passed
through the packet filter; translated packets are
still subject to
.Ar block
and
.Ar pass
rules.
d934 5
a938 1
If no rule matches the packet it is passed to the filter engine unmodified.
d1353 1
a1353 1
.Sx QUEUEING
d1465 1
a1465 1
from modifying the source port on TCP and UDP packets.
d2069 165
a2233 168
line           = ( option | pf-rule | nat-rule | binat-rule | rdr-rule |
                 antispoof-rule | altq-rule | queue-rule | anchor-rule |
                 trans-anchors | load-anchors )

option         = "set" ( [ "timeout" ( timeout | "{" timeout-list "}" ) ] |
                 [ "optimization" [ "default" | "normal" |
                 "high-latency" | "satellite" |
                 "aggressive" | "conservative" ] ]
                 [ "limit" ( limit-item | "{" limit-list "}" ) ] |
                 [ "loginterface" ( interface-name | "none" ) ] |
                 [ "block-policy" ( "drop" | "return" ) ] |
                 [ "require-order" ( "yes" | "no" ) ] )

pf-rule        = action [ ( "in" | "out" ) ]
                 [ "log" | "log-all" ] [ "quick" ]
                 [ "on" ifspec ] [ route ] [ af ] [ protospec ]
                 hosts [ filteropt-list ]

filteropt-list = filteropt-list filteropt | filteropt
filteropt      = user | group | flags | icmp-type | icmp6-type | tos |
                 ( "keep" | "modulate" ) "state" [ "(" state-opts ")" ] |
                 "fragment" | "no-df" | "min-ttl" number |
                 "max-mss" number | "random-id" | "reassemble tcp" |
                 fragmentation | "allow-opts" |
                 "label" string | "tag" string | "tagged" string
                 "queue" "(" string | ( string [ [ "," ] string ] ) ")"

nat-rule       = [ "no" ] "nat" [ "on" ifspec ] [ af ] [ protospec ]
                 hosts [ "->" ( redirhost | "{" redirhost-list "}" )
                 [ portspec ] [ pooltype ] [ "static-port" ] ]

binat-rule     = [ "no" ] "binat" [ "on" interface-name ] [ af ]
                 [ "proto" ( proto-name | proto-number ) ]
                 "from" address [ "/" mask-bits ] "to" ipspec
                 [ "->" address [ "/" mask-bits ] ]

rdr-rule       = [ "no" ] "rdr" [ "on" ifspec ] [ af ] [ protospec ]
                 hosts [ "->" ( redirhost | "{" redirhost-list "}" )
                 [ portspec ] [ pooltype ] ]

antispoof-rule = "antispoof" [ "log" ] [ "quick" ]
                 "for" ( interface-name | "{" interface-list "}" )
                 [ af ] [ "label" string ]

table-rule     = "table" "<" string ">" [ tableopts-list ]
tableopts-list = tableopts-list tableopts | tableopts
tableopts      = "persist" | "const" | "file" string |
                 "{" [ tableaddr-list ] "}"
tableaddr-list = tableaddr-list [ "," ] tableaddr-spec | tableaddr-spec
tableaddr-spec = [ "!" ] tableaddr [ "/" mask-bits ]
tableaddr      = hostname | ipv4-dotted-quad | ipv6-coloned-hex |
                 interface-name | "self"

altq-rule      = "altq on" interface-name queueopts-list
                 "queue" queue-list
queue-rule     = "queue" string [ "on" interface-name ] queueopts-list
                 queue-list

anchor-rule    = "anchor" string [ ( "in" | "out" ) ] [ "on" ifspec ]
                 [ af ] [ "proto" ] [ protospec ] [ hosts ]

trans-anchors  = ( "nat-anchor" | "rdr-anchor" | "binat-anchor" ) string
                 [ "on" ifspec ] [ af ] [ "proto" ] [ protospec ] [ hosts ]

load-anchor    = "load" anchorname:rulesetname "from" filename

queueopts-list = queueopts-list queueopts | queueopts
queueopts      = [ "bandwidth" bandwidth-spec ] |
                 [ "qlimit" number ] | [ "tbrsize" number ] |
                 [ "priority" number ] | [ schedulers ] |
                 [ "qlimit" number ]
schedulers     = ( cbq-def | priq-def | hfsc-def )
bandwidth-spec = "number" ( "b" | "Kb" | "Mb" | "Gb" | "%" )

action         = "pass" | "block" [ "return" ] | "scrub"
return         = "drop" | "return" | "return-rst" [ "( ttl" number ")" ] |
                 "return-icmp" [ "(" icmpcode ["," icmp6code ] ")" ] |
                 "return-icmp6" [ "(" icmp6code ")" ]
icmpcode       = ( icmp-code-name | icmp-code-number )
icmp6code      = ( icmp6-code-name | icmp6-code-number )

ifspec         = ( [ "!" ] interface-name ) | "{" interface-list "}"
interface-list = [ "!" ] interface-name [ [ "," ] interface-list ]
route          = "fastroute" |
                 ( "route-to" | "reply-to" | "dup-to" )
                 ( routehost | "{" routehost-list "}" )
                 [ pooltype ]
af             = "inet" | "inet6"

protospec      = "proto" ( proto-name | proto-number |
                 "{" proto-list "}" )
proto-list     = ( proto-name | proto-number ) [ [ "," ] proto-list ]

hosts          = "all" |
                 "from" ( "any" | "no-route" | "self" | host |
                 "{" host-list "}" ) [ port ]
                 "to"   ( "any" | "no-route" | "self" | host |
                 "{" host-list "}" ) [ port ]

ipspec         = "any" | host | "{" host-list "}"
host           = [ "!" ] ( address [ "/" mask-bits ] | "<" string ">" )
redirhost      = address [ "/" mask-bits ]
routehost      = ( interface-name [ address [ "/" mask-bits ] ] )
address        = ( interface-name | "(" interface-name ")" | hostname |
                 ipv4-dotted-quad | ipv6-coloned-hex )
host-list      = host [ [ "," ] host-list ]
redirhost-list = redirhost [ [ "," ] redirhost-list ]
routehost-list = routehost [ [ "," ] routehost-list ]

port           = "port" ( unary-op | binary-op | "{" op-list "}" )
portspec       = "port" ( number | name ) [ ":" ( "*" | number | name ) ]
user           = "user" ( unary-op | binary-op | "{" op-list "}" )
group          = "group" ( unary-op | binary-op | "{" op-list "}" )

unary-op       = [ "=" | "!=" | "<" | "<=" | ">" | ">=" ]
                 ( name | number )
binary-op      = number ( "<>" | "><" | ":" ) number
op-list        = ( unary-op | binary-op ) [ [ "," ] op-list ]

flags          = "flags" [ flag-set ] "/" flag-set
flag-set       = [ "F" ] [ "S" ] [ "R" ] [ "P" ] [ "A" ] [ "U" ] [ "E" ]
                 [ "W" ]

icmp-type      = "icmp-type" ( icmp-type-code | "{" icmp-list "}" )
icmp6-type     = "icmp6-type" ( icmp-type-code | "{" icmp-list "}" )
icmp-type-code = ( icmp-type-name | icmp-type-number )
                 [ "code" ( icmp-code-name | icmp-code-number ) ]
icmp-list      = icmp-type-code [ [ "," ] icmp-list ]

tos            = "tos" ( "lowdelay" | "throughput" | "reliability" |
                 [ "0x" ] number )

state-opts     = state-opt [ [ "," ] state-opts ]
state-opt      = ( "max" number ) | ( timeout seconds )

fragmentation  = [ "fragment reassemble" | "fragment crop" |
                 "fragment drop-ovl" ]

timeout-list   = timeout [ [ "," ] timeout-list ]
timeout        = ( "tcp.first" | "tcp.opening" | "tcp.established" |
                 "tcp.closing" | "tcp.finwait" | "tcp.closed" |
                 "udp.first" | "udp.single" | "udp.multiple" |
                 "icmp.first" | "icmp.error" |
                 "other.first" | "other.single" | "other.multiple" )
                 seconds
seconds        = number

limit-list     = limit-item [ [ "," ] limit-list ]
limit-item     = ( "states" | "frags" ) number

pooltype       = ( "bitmask" | "random" |
                 "source-hash" [ ( hex-key | string-key ) ] |
                 "round-robin" )

subqueue       = string | "{" queue-list "}"
queue-list     = string [ [ "," ] string ]
cbq-def        = "cbq" [ "(" cbq-opt [ [ "," ] cbq-opt ] ")" ]
priq-def       = "priq" [ "(" priq-opt [ [ "," ] priq-opt ] ")" ]
hfsc-def       = "hfsc" [ "(" hfsc-opt [ [ "," ] hfsc-opt ] ")" ]
cbq-opt        = ( "default" | "borrow" | "red" | "ecn" | "rio" )
priq-opt       = ( "default" | "red" | "ecn" | "rio" )
hfsc-opt       = ( "default" | "red" | "ecn" | "rio" |
                 linkshare-sc | realtime-sc | upperlimit-sc )
linkshare-sc   = "linkshare" sc-spec
realtime-sc    = "realtime" sc-spec
upperlimit-sc  = "upperlimit" sc-spec
sc-spec        = ( bandwidth-spec |
                 "(" bandwidth-spec number bandwidth-spec ")" )
@


1.1.1.7
log
@Import OpenBSD CVS of roughly 2000-2200 UTC. Last import before release.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.254 2003/06/07 20:31:13 henning Exp $
d1370 6
a1375 25
Packets matching this rule will be tagged with the
specified string.
The tag acts as an internal marker that can be used to
identify these packets later on.
This can be used, for example, to provide trust between
interfaces and to determine if packets have been
processed by translation rules.
Tags are
.Qq sticky ,
meaning that the packet will be tagged even if the rule
is not the last matching rule.
Further matching rules can replace the tag with a
new one but will not remove a previously applied tag.
A packet is only ever assigned one tag at a time.
.Ar pass
rules that use the
.Ar tag
keyword must also use
.Ar keep state .
Packet tagging can be done during
.Ar nat ,
.Ar rdr ,
or
.Ar binat
rules in addition to filter rules.
d1377 2
a1378 8
Used with filter rules to specify that packets must already
be tagged with the given tag in order to match the rule.
Inverse tag matching can also be done
by specifying the
.Cm !
operator before the
.Ar tagged
keyword.
a1824 6
.It Ar load anchor <name>:<ruleset> from <file>
Loads the rules from the specified file into the named
ruleset
.Ar <ruleset>
attached to the anchor
.Ar <name> .
a1880 18
The named ruleset can also be populated by adding a
.Ar load anchor
rule after the
.Ar anchor
rule:
.Bd -literal -offset indent
anchor spam
load anchor spam:manual from /etc/pf-spam.conf
.Ed
.Pp
When
.Xr pfctl 8
loads
.Nm pf.conf ,
it will also load all the rules from the file
.Pa /etc/pf-spam.conf
into the named ruleset.
.Pp
a2070 24

# Packet Tagging

# three interfaces: $int_if, $ext_if, and $wifi_if (wireless). NAT is
# being done on $ext_if for all outgoing packets. tag packets in on
# $int_if and pass those tagged packets out on $ext_if.  all other
# outgoing packets (i.e., packets from the wireless network) are only
# permitted to access port 80.

pass in on $int_if from any to any tag INTNET keep state
pass in on $wifi_if from any to any keep state

block out on $ext_if from any to any
pass out quick on $ext_if tagged INTNET keep state
pass out on $ext_if from any to any port 80 keep state

# tag incoming packets as they are redirected to spamd(8). use the tag
# to pass those packets through the packet filter.

rdr on $ext_if inet proto tcp from <spammers> to port smtp \e
	tag SPAMD -> 127.0.0.1 port spamd

block in on $ext_if
pass in on $ext_if inet proto tcp tagged SPAMD keep state
d2101 1
a2101 1
                 "label" string | "tag" string | [ ! ] "tagged" string
d2105 1
a2105 2
                 hosts [ "tag" string ]
                 [ "->" ( redirhost | "{" redirhost-list "}" )
a2110 1
                 [ "tag" string ]
d2114 1
a2114 2
                 hosts [ "tag" string ]
                 [ "->" ( redirhost | "{" redirhost-list "}" )
@


1.1.1.8
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.259 2003/06/17 21:48:11 david Exp $
a1032 5
.Pp
Options returning packets have no effect if
.Xr pf 4
operates on a
.Xr bridge 4 .
a1672 7
Rules with
.Ar synproxy
will not work if
.Xr pf 4
operates on a
.Xr bridge 4 .
.Pp
d2152 1
a2152 1
                 trans-anchors | load-anchors | table-rule )
d2207 1
a2207 1
                 "queue" subqueue
d2209 1
a2209 1
                 subqueue
d2222 2
a2223 1
                 [ "priority" number ] | [ schedulers ]
d2286 1
a2286 1
state-opt      = ( "max" number ) | ( timeout )
d2296 3
a2298 3
                 "other.first" | "other.single" | "other.multiple" |
                 "frag" | "interval" |
                 "adaptive.start" | "adaptive.end" ) number
@


1.1.1.9
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.260 2003/07/04 10:42:52 henning Exp $
d876 1
a876 3
through the packet filter unless the
.Ar pass
modifier is given; translated packets are
a1978 7
If the
.Ar pass
modifier is given, packets matching the translation rule are passed without
inspecting the filter rules:
.Bd -literal
rdr pass on ne3 proto tcp from any to any port 80 -> 127.0.0.1 port 8080
.Ed
d2189 2
a2190 2
nat-rule       = [ "no" ] "nat" [ "pass" ] [ "on" ifspec ] [ af ]
                 [ protospec ] hosts [ "tag" string ]
d2194 2
a2195 2
binat-rule     = [ "no" ] "binat" [ "pass" ] [ "on" interface-name ]
                 [ af ] [ "proto" ( proto-name | proto-number ) ]
d2200 2
a2201 2
rdr-rule       = [ "no" ] "rdr" [ "pass" ] [ "on" ifspec ] [ af ]
                 [ protospec ] hosts [ "tag" string ]
@


1.1.1.10
log
@Sync some stuff with OpenBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.263 2003/07/07 09:15:54 jmc Exp $
d652 1
a652 1
.Ar hfsc
d874 3
a876 3
address and port number.
Packets that match a translation rule are only automatically passed if
the
d878 1
a878 1
modifier is given, otherwise they are
a1980 1
.Pp
d2031 2
a2032 2
# Translate outgoing packets' source addresses (any protocol).
# In this case, any address but the gateway's external address is mapped.
d2036 3
a2038 3
# Map outgoing packets' source port to an assigned proxy port instead of
# an arbitrary port.
# In this case, proxy outgoing isakmp with port 500 on the gateway.
d2043 3
a2045 3
# Translate outgoing packets' source address (any protocol).
# Translate incoming packets' destination address to an internal machine
# (bidirectional).
d2049 2
a2050 2
# Translate incoming packets' destination addresses.
# As an example, redirect a TCP and UDP port to an internal machine.
d2057 2
a2058 2
# Translate outgoing ftp control connections to send them to localhost
# for proxying with ftp-proxy(8) running on port 8021.
d2060 1
a2060 2
.Ed
.Pp
d2066 1
a2066 1
.Bd -literal
d2068 2
a2069 2
# Translate outgoing packets' source addresses using an address pool.
# A given source address is always translated to the same pool address by
d2074 2
a2075 2
# Translate incoming web server connections to a group of web servers on
# the internal network.
@


1.1.1.11
log
@Pull in a bit of current OpenBSD, to the least
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.265 2003/08/22 04:54:13 david Exp $
a433 15
.It Ar set fingerprints
Load fingerprints of known operating systems from the given filename.
By default fingerprints of known operating systems are automatically
loaded from
.Xr pf.os 5
in /etc but can be overridden via this option.
Setting this option may leave a small period of time where the fingerprints
referenced by the currently active ruleset are inconsistent until the new
ruleset finishes loading.
.Pp
For example:
.Bd -literal -offset indent
set fingerprints "/etc/pf.os.devel"
.Ed
.Pp
d1135 1
a1135 1
.It Ar from <source> port <source> os <source> to <dest> port <dest>
d1207 1
a1207 9
The operating system of the source host can be specified in the case of TCP
rules with the
.Ar OS
modifier.
See the
.Sx OPERATING SYSTEM FINGERPRINTING
section for more information.
.Pp
The host, port and OS specifications are optional, as in the following examples:
a1214 1
pass in proto tcp from any os "OpenBSD" flags S/SA
a1715 69
.Sh OPERATING SYSTEM FINGERPRINTING
Passive OS Fingerprinting is a mechanism to inspect nuances of a TCP
connection's initial SYN packet and guess at the host's operating system.
Unfortunately these nuances are easily spoofed by an attacker so the
fingerprint is not useful in making security decisions.
But the fingerprint is typically accurate enough to make policy decisions
upon.
.Pp
The fingerprints may be specified by operating system class, by
version, or by subtype/patchlevel.
The class of an operating system is typically the vender or genre
and would be OpenBSD for the
.Xr pf 4
firewall itself.
The version of the oldest available OpenBSD release on the main ftp site
would be 2.6 and the fingerprint would be written
.Bd -literal indent
	"OpenBSD 2.6"
.Ed
.Pp
The subtype of an operating system is typically used to describe the
patchlevel if that patch led to changes in the TCP stack behavior.
In the case of OpenBSD, the only subtype is for a fingerprint on the
loopback interface lo0 since it utilizes a different TCP maximum segment
size and would be specified like
.Bd -literal indent
	"OpenBSD 3.3 lo0"
.Ed
.Pp
Fingerprints for most popular operating systems are provided by
.Xr pf.os 5 .
Once
.Xr pf 4
is running, a complete list of known operating system fingerprints may
be listed by running:
.Bd -literal -offset indent
# pfctl -so
.Ed
.Pp
Filter rules can enforce policy at any level of operating system specification
assuming a fingerprint is present.
Policy could limit traffic to approved operating systems or even ban traffic
from hosts that aren't at the latest service pack.
.Pp
The
.Ar unknown
class can also be used as the fingerprint which will match packets for
which no operating system fingerprint is known.
.Pp
Examples:
.Bd -literal -offset indent
pass  out proto tcp from any os OpenBSD keep state
block out proto tcp from any os Doors
block out proto tcp from any os "Doors PT"
block out proto tcp from any os "Doors PT SP3"
block out from any os "unknown"
pass on lo0 proto tcp from any os "OpenBSD 3.3 lo0" keep state
.Ed
.Pp
Operating system fingerprinting is limited only to the TCP SYN packet.
This means that it will not work on other protocols and will not match
a currently established connection.
.Pp
Caveat: operating system fingerprints are occasionally wrong.
There are three problems: an attacker can trivially craft his packets to
appear as any operating system he chooses;
an operating system patch could change the stack behavior and no fingerprints
will match it until the database is updated;
and multiple operating systems may have the same fingerprint.
a2143 5
# Do not allow Windows 9x SMTP connections since they are typically
# a viral worm.  Alternately we could limit these OSes to 1 connection each.
block in on $ext_if proto tcp from any os {"Windows 95", "Windows 98"} \e
      to any port smtp

d2184 1
a2184 2
                 [ "require-order" ( "yes" | "no" ) ]
                 [ "fingerprints" filename ] )
d2270 1
a2270 1
                 "{" host-list "}" ) [ port ] [ os ]
a2285 1
os             = "os"  ( os-name | "{" os-list "}" )
a2292 3

os-name        = operating-system-name
os-list        = os-name [ [ "," ] os-list ]
@


1.1.1.12
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.270 2003/08/28 09:41:22 jmc Exp $
d123 3
a125 7
Tables can also be used for the redirect address of
.Ar nat
and
.Ar rdr
rules and in the routing options of filter rules, but only for
.Ar round-robin
pools.
d439 1
a439 3
in
.Pa /etc
but can be overridden via this option.
d445 3
a448 1
.Dl set fingerprints \&"/etc/pf.os.devel\&"
d565 1
a565 1
.Ar reassemble tcp
d762 1
d1018 1
d1150 1
a1150 4
.It Xo
.Ar from <source> port <source> os <source>
.Ar to <dest> port <dest>
.Xc
d1716 3
a1718 2
All three of
.Ar keep state ,
a1719 2
and
.Ar synproxy state
d1756 3
a1758 2
.Pp
.Dl \&"OpenBSD 2.6\&"
d1762 6
a1767 6
In the case of OpenBSD, the only subtype is for a fingerprint that was
normalized by the
.Ar no-df
scrub option and would be specified as
.Pp
.Dl \&"OpenBSD 3.3 no-df\&"
d1775 3
a1777 2
.Pp
.Dl # pfctl -so
d2238 1
a2238 1
# a viral worm. Alternately we could limit these OSes to 1 connection each.
d2292 1
a2292 2
                 ( "keep" | "modulate" | "synproxy" ) "state"
                 [ "(" state-opts ")" ] |
a2452 2
.It Pa /etc/pf.os
Default location of OS fingerprints.
a2468 1
.Xr pf.os 5 ,
@


1.1.1.13
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.271 2003/09/02 18:37:08 jmc Exp $
d1436 1
a1436 1
.Cm !\&
@


1.1.1.14
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.286 2003/12/15 05:17:20 jmc Exp $
a236 3
.It Ar src.track
Length of time to retain a source-tracking entry after the last state
expires.
a452 16
.Pp
.It Ar set debug
Set the debug
.Ar level
to one of the following:
.Pp
.Bl -tag -width xxxxxxxxxxxx -compact
.It Ar none
Don't generate debug messages.
.It Ar urgent
Generate debug messages only for serious errors.
.It Ar misc
Generate debug messages for various errors.
.It Ar loud
Generate debug messages for common conditions.
.El
d1095 2
a1096 1
.Ar keep state ,
a1097 2
or
.Ar synproxy state
d1101 2
a1102 1
.Ar keep state ,
a1103 2
and
.Ar synproxy state
d1117 2
a1118 1
.Ar keep state ,
a1119 2
or
.Ar synproxy state
d1208 1
a1208 2
:	(range including boundaries)
><	(range excluding boundaries)
d1212 3
a1214 2
><, <> and :
are binary operators (they take two arguments).
a1216 4
.It Ar port 2000:2004
means
.Sq all ports >= 2000 and <= 2004 ,
hence ports 2000, 2001, 2002, 2003 and 2004.
d1424 1
a1424 4
.Ar keep state ,
.Ar modulate state
or
.Ar synproxy state .
a1430 1
Tags take the same macros as labels (see above).
a1535 17
.Pp
Additionally, the
.Ar sticky-address
option can be specified to help ensure that multiple connections from the
same source are mapped to the same redirection address.
This option can be used with the
.Ar random
and
.Ar round-robin
pool options.
Note that by default these associations are destroyed as soon as there are
no longer states which refer to them; in order to make the mappings last
beyond the lifetime of the states, increase the global options with
.Ar set timeout source-track
See
.Sx STATEFUL TRACKING OPTIONS
for more ways to control the source tracking.
d1698 1
a1698 1
chooses random initial sequence numbers for both handshakes.
a1732 4
.It Ar no-sync
Prevent state changes for states created by this rule from appearing on the
.Xr pfsync 4
interface.
a1734 14
.Pp
When the
.Ar source-tracking
keyword is specified, the number of states per source IP is tracked.
The following limits can be set:
.Pp
.Bl  -tag -width xxxx -compact
.It Ar max-src-nodes
Limits the maximum number of source addresses which can simultaneously
have state table entries.
.It Ar max-src-states
Limits the maximum number of simultaneous state entries that a single
source address can create with this rule.
.El
d1743 1
a1743 2
      (max 100, source-track rule, max-src-nodes 75, \e
      max-src-states 3, tcp.established 60, tcp.closing 5)
d1856 1
a1856 1
maximum transmission unit (MTU) of the network.
d2030 1
a2030 1
load anchor spam:manual from "/etc/pf-spam.conf"
a2074 3
# use a macro for the interface name, so it can be changed easily
ext_if = \&"ne3\&"

d2076 1
a2076 1
rdr on $ext_if proto tcp from any to any port 80 -> 127.0.0.1 port 8080
d2084 1
a2084 2
rdr pass on $ext_if proto tcp from any to any port 80 -> 127.0.0.1 \e
      port 8080
d2099 2
a2100 2
In the example below, the machine sits between a fake internal 144.19.74.*
network, and a routable external IP of 204.92.77.100.
d2106 2
a2107 2
no nat on $ext_if proto ah from 144.19.74.0/24 to any
nat on $ext_if from 144.19.74.0/24 to any -> 204.92.77.100
d2110 4
a2113 2
In the example below, packets bound for one specific server, as well as those
generated by the sysadmins are not proxied; all other connections are.
d2116 3
a2118 4
no rdr on $int_if proto { tcp, udp } from any to $server port 80
no rdr on $int_if proto { tcp, udp } from $sysadmins to any port 80
rdr on $int_if proto { tcp, udp } from any to any port 80 -> 127.0.0.1 \e
      port 80
d2122 3
a2124 2
The external interface has the address 157.161.48.183.
On the internal interface, we are running
d2131 1
a2131 1
nat on $ext_if inet from ! ($ext_if) to any -> ($ext_if)
d2137 1
a2137 1
nat on $ext_if inet proto udp from any port = isakmp to any -> ($ext_if) \e
d2144 1
a2144 1
binat on $ext_if from 10.1.2.150 to any -> ($ext_if)
d2149 4
a2152 4
rdr on $ext_if inet proto tcp from any to ($ext_if) port 8080 \e
      -> 10.1.2.151 port 22
rdr on $ext_if inet proto udp from any to ($ext_if) port 8080 \e
      -> 10.1.2.151 port 53
d2157 1
a2157 1
rdr on $int_if proto tcp from any to any port 21 -> 127.0.0.1 port 8021
d2164 1
d2170 1
a2170 1
nat on $ext_if inet from any to any -> 192.0.2.16/28 source-hash
d2175 1
a2175 1
rdr on $ext_if proto tcp from any to any port 80 \e
d2287 1
a2287 2
                 [ "fingerprints" filename ] |
                 [ "debug" ( "none" | "urgent" | "misc" | "loud" ) ] )
d2302 1
a2302 1
                 "queue" ( string | "(" string [ [ "," ] string ] ")" )
d2344 1
a2344 1
load-anchor    = "load anchor" anchorname:rulesetname "from" filename
d2353 1
a2353 1
action         = "pass" | "block" [ return ] | "scrub"
d2416 1
a2416 3
state-opt      = ( "max" number | "no-sync" | timeout |
                 "source-track" [ ( "rule" | "global" ) ] |
		 "max-src-nodes" number | "max-src-states" number)
d2427 1
a2427 1
                 "frag" | "interval" | "src.track" |
d2435 1
a2435 1
                 "round-robin" ) [ sticky-address ]
a2472 1
.Xr pfsync 4 ,
@


1.1.1.15
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.288 2003/12/31 14:09:57 jmc Exp $
a425 18
.It Ar set state-policy
The
.Ar state-policy
option sets the default behaviour for states:
.Pp
.Bl -tag -width group-bound -compact
.It Ar if-bound
States are bound to interface.
.It Ar group-bound
States are bound to interface group (i.e. ppp)
.It Ar floating
States can match packets on any interfaces (the default).
.El
.Pp
For example:
.Bd -literal -offset indent
set state-policy if-bound
.Ed
a1155 2
It is also possible to simply give the interface driver name, like ppp or fxp,
to make the rule match packets flowing through a group of interfaces.
a1199 4
.It Ar :peer
Translates to the point to point interface's peer address(es).
.It Ar :0
Do not include interface aliases.
a1201 5
Host names may also have the
.Ar :0
option appended to restrict the name resolution to the first of each
v4 and v6 address found.
.Pp
d1207 1
a1207 2
Surrounding the interface name (and optional modifiers) in parentheses
changes this behaviour.
a1628 31
By default, packets coming in and out of any interface can match a state,
but it is also possible to change that behaviour by assigning states to a
single interface or a group of interfaces.
.Pp
The default policy is specified by the
.Ar state-policy
global option, but this can be adjusted on a per-rule basis by adding one
of the
.Ar if-bound ,
.Ar group-bound
or
.Ar floating
keywords to the
.Ar keep state
option.
For example, if a rule is defined as:
.Bd -literal -offset indent
pass out on ppp from any to 10.12/16 keep state (group-locked)
.Ed
.Pp
A state created on ppp0 would match packets an all PPP interfaces,
but not packets flowing through fxp0 or any other interface.
.Pp
Keeping rules
.Ar floating
is the more flexible option when the firewall is in a dynamic routing
environment.
However, this has some security implications since a state created by one
trusted network could allow potentially hostile packets coming in from other
interfaces.
.Pp
a2352 2
		 [ "state-policy" ( "if-bound" | "group-bound" |
                 "floating" ) ]
d2486 1
a2486 2
		 "max-src-nodes" number | "max-src-states" number |
                 "if-bound" | "group-bound" | "floating" )
@


1.1.1.16
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.289 2004/01/06 09:28:00 cedric Exp $
d1676 1
a1676 1
pass out on ppp from any to 10.12/16 keep state (group-bound)
@


1.1.1.17
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.conf.5,v 1.297 2004/05/09 10:51:55 dhartmei Exp $
d238 1
a238 1
Length of time to retain a source tracking entry after the last state
a371 11
Finally,
.Bd -literal -offset indent
set limit src-nodes 2000
.Ed
.Pp
sets the maximum number of entries in the memory pool used for tracking
source IP addresses (generated by the
.Ar sticky-address
and
.Ar source-track
options) to 2000.
d375 1
a375 1
set limit { states 20000, frags 20000, src-nodes 2000 }
a609 18
.It extended PAWS checks
There is a problem with TCP on long fat pipes, in that a packet might get
delayed for longer than it takes the connection to wrap its 32-bit sequence
space.
In such an occurance, the old packet would be indistinguishable from a
new packet and would be accepted as such.
The solution to this is called PAWS: Protection Against Wrapped Sequence
numbers.
It protects against it by making sure the timestamp on each packet does
not go backwards.
.Ar reassemble tcp
also makes sure the timestamp on the packet does not go forward more
than the RFC allows.
By doing this,
.Xr pf 4
artificially extends the security of TCP sequence numbers by 10 to 18
bits when the host uses appropriately randomized timestamps, since a
blind attacker would have to guess the timestamp as well.
d927 2
a928 2
addresses and ports have been translated.
Filter rules will therefore have to filter based on the translated
a1499 9
.It Ar probability <number>
A probability attribute can be attached to a rule, with a value set between
0 and 1, bounds not included.
In that case, the rule will be honoured using the given probability value
only.
For example, the following rule will drop 20% of incoming ICMP packets:
.Bd -literal -offset indent
block in proto icmp probability 20%
.Ed
d1530 1
a1530 1
.Ar reply-to
a1846 1
.El
d1849 1
a1849 1
.Ar source-track
d1853 1
a1853 1
.Bl -tag -width xxxx -compact
a1860 1
.Pp
d1872 1
d1883 1
a1883 1
The class of an operating system is typically the vendor or genre
d2565 1
a2565 1
limit-item     = ( "states" | "frags" | "src-nodes" ) number
@


