head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.13
	tg-mergefixes-1-branch:1.1.1.13.0.8
	tg-mergefixes-1-base:1.1.1.13
	MIROS_X:1.1.1.13.0.6
	MIROS_X_BASE:1.1.1.13
	tg-mergetmp-3:1.1.1.13
	MIRBSD_XP_MIRPPC:1.1.1.13.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.13
	MIRBSD_XP_SPARC:1.1.1.13.0.2
	MIRBSD_7quater:1.1.1.9
	cvs-200405160640:1.1.1.13
	cvs-200401271800:1.1.1.12
	cvs-200401261630:1.1.1.12
	cvs-200401021645:1.1.1.11
	MIRBSD_7_ALPHA:1.1.1.9.0.6
	MIRBSD_7:1.1.1.9.0.4
	cvs-200312222040:1.1.1.10
	MIRBSD_7ter:1.1.1.9
	MIRBSD_7_DEV:1.1.1.9.0.2
	cvs-200310020700:1.1.1.9
	cvs-200309271030:1.1.1.8
	cvs-200309251530:1.1.1.8
	cvs-200308302005:1.1.1.8
	cvs-200308221505:1.1.1.7
	cvs-200308171200:1.1.1.6
	ctm-3496:1.1.1.5
	ctm-3449:1.1.1.4
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	cvs-200307072125:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.4
	cvs-200306082100:1.1.1.4
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@.\" @;


1.1
date	2003.03.22.17.48.58;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.48.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.15.17.37.57;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.32.18;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.08.23.00.10;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.08.11.18.31.42;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.08.17.14.24.01;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.08.22.15.30.45;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.08.30.23.04.44;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.10.02.07.48.51;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.12.22.21.11.53;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.01.02.18.02.37;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2004.01.26.18.33.32;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2004.05.16.08.29.56;	author tg;	state Stab;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@.\"	$OpenBSD: pf.4,v 1.29 2003/02/14 09:41:42 henning Exp $
.\"
.\" Copyright (C) 2001, Kjell Wooding.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the project nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.Dd June 24, 2001
.Dt PF 4
.Os
.Sh NAME
.Nm pf
.Nd packet filter
.Sh SYNOPSIS
.Cd "pseudo-device pf 1"
.Sh DESCRIPTION
Packet filtering takes place in the kernel.
A pseudo-device,
.Pa /dev/pf ,
allows userland processes to control the
behavior of the packet filter through an
.Xr ioctl 2
interface.
There are commands to enable and disable the filter, load rulesets,
add and remove individual rules or retrieve state table entries and
statistics.
The most commonly used functions are covered by
.Xr pfctl 8 .
.Pp
Manipulations like loading a ruleset that involve more than a single
ioctl call require a so-called ticket, which prevents the occurrence of
multiple concurrent manipulations.
.Pp
Fields of ioctl parameter structures that refer to packet data (like
addresses and ports) are generally expected in network byte-order.
.Sh FILES
.Bl -tag -width /dev/pf -compact
.It Pa /dev/pf
packet filtering device.
.El
.Sh IOCTL INTERFACE
pf supports the following
.Xr ioctl 2
commands:
.Bl -tag -width xxxxxx
.It Dv DIOCSTART
Starts the packet filter.
.It Dv DIOCSTOP
Stops the packet filter.
.It Dv DIOCSTARTALTQ
Starts the ALTQ bandwidth control system.
.It Dv DIOCSTOPALTQ
Stops the ALTQ bandwidth control system.
.It Dv DIOCBEGINADDRS  Fa "u_int32_t"
Clears the buffer address pool
and returns a ticket for subsequent DIOCADDADDR, DIOCADDRULE and
DIOCCHANGERULE calls.
.It Dv DIOCADDADDR     Fa "struct pfioc_pooladdr"
.Bd -literal
struct pfioc_pooladdr {
	u_int32_t		action;
	u_int32_t		ticket;
	u_int32_t		nr;
	u_int32_t		r_num;
	u_int8_t		r_action;
	u_int8_t		r_last;
	u_int8_t		af;
	char			anchor[PF_ANCHOR_NAME_SIZE];
	char			ruleset[PF_RULESET_NAME_SIZE];
	struct pf_pooladdr	addr;
};
.Ed
.Pp
Adds pool address
.Va addr
to the buffer address pool to be used in the following
DIOCADDRULE or DIOCCHANGERULE call.
All other members of the structure are ignored.
.It Dv DIOCBEGINRULES  Fa "u_int32_t"
Clears the inactive ruleset for the type of rule indicated by
.Va rule.action
and returns a ticket for subsequent
DIOCADDRULE and DIOCCOMMITRULES calls.
.It Dv DIOCADDRULE     Fa "struct pfioc_rule"
.Bd -literal
struct pfioc_rule {
	u_int32_t	action;
	u_int32_t	ticket;
	u_int32_t	pool_ticket;
	u_int32_t	nr;
	char		anchor[PF_ANCHOR_NAME_SIZE];
	char		ruleset[PF_RULESET_NAME_SIZE];
	struct pf_rule	rule;
};
.Ed
.Pp
Adds
.Va rule
at the end of the inactive ruleset.
Requires
.Va ticket
obtained through preceding DIOCBEGINRULES call, and
.Va pool_ticket
obtained through DIOCBEGINADDRS call.
DIOCADDADDR must also be called if any pool addresses are required.
The optional
.Va anchor
and
.Va ruleset
names indicate the anchor and ruleset in which to append the rule.
.Va nr
and
.Va action
are ignored.
.It Dv DIOCCOMMITRULES Fa "u_int32_t"
Switch inactive to active filter ruleset.
Requires
.Va ticket .
.It Dv DIOCBEGINALTQS  Fa "u_int32_t"
Clears the inactive list of queues and returns a ticket for subsequent
DIOCADDALTQ and DIOCCOMMITALTQS calls.
.It Dv DIOCADDALTQ     Fa "struct pfioc_altq"
Adds
.Bd -literal
struct pfioc_altq {
	u_int32_t	ticket;
	u_int32_t	nr;
	struct pf_altq   altq;
};
.Ed
.It Dv DIOCCOMMITALTQS Fa "u_int32_t"
Switch inactive to active list of queues.
Requires
.Va ticket .
.It Dv DIOCGETRULES    Fa "struct pfioc_rule"
Returns
.Va ticket
for subsequent DIOCGETRULE calls and
.Va nr
of rules in the active ruleset.
.It Dv DIOCGETRULE     Fa "struct pfioc_rule"
Returns
.Va rule
number
.Va nr
using
.Va ticket
obtained through a preceding DIOCGETRULES call.
.It Dv DIOCGETADDRS    Fa "struct pfioc_pooladdr"
Returns
.Va ticket
for subsequent DIOCGETADDR calls and
.Va nr
of pool addresses in the rule specified with
.Va r_action ,
.Va r_num ,
.Va anchor
and
.Va ruleset .
.It Dv DIOCGETADDR     Fa "struct pfioc_pooladdr"
Returns pool address
.Va addr
number
.Va nr
from the rule specified with
.Va r_action ,
.Va r_num ,
.Va anchor
and
.Va ruleset
using
.Va ticket
obtained through a preceding DIOCGETADDRS call.
.It Dv DIOCGETALTQS    Fa "struct pfioc_altq"
Returns
.Va ticket
for subsequent DIOCGETALTQ calls and
.Va nr
of queues in the active list.
.It Dv DIOCGETALTQ     Fa "struct pfioc_altq"
Returns
.Va altq
number
.Va nr
using
.Va ticket
obtained through a preceding DIOCGETALTQS call.
.It Dv DIOCGETQSTATS   Fa "struct pfioc_qstats"
Returns statistics on a queue.
.Bd -literal
struct pfioc_qstats {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	void		*buf;
	int		 nbytes;
	u_int8_t	 scheduler;
};
.Ed
.Pp
A pointer to a buffer of statistics
.Va buf
of length
.Va nbytes
for the queue specified by
.Va nr .
.It Dv DIOCCLRSTATES
Clears the state table.
.It Dv DIOCADDSTATE    Fa "struct pfioc_state"
Adds a state entry.
.It Dv DIOCGETSTATE    Fa "struct pfioc_state"
.Bd -literal
struct pfioc_state {
	u_int32_t	 nr;
	struct pf_state	 state;
};
.Ed
.Pp
Extracts the entry with the specified number from the state table.
.It Dv DIOCKILLSTATES  Fa "struct pfioc_state_kill"
Removes matching entries from the state table.
Returns the number of killed states in psk_af.
.Bd -literal
struct pfioc_state_kill {
	int			psk_af;
	int			psk_proto;
	struct pf_rule_addr	psk_src;
	struct pf_rule_addr	psk_dst;
};
.Ed
.It Dv DIOCSETSTATUSIF Fa "struct pfioc_if"
.Bd -literal
struct pfioc_if {
	char		 ifname[IFNAMSIZ];
};
.Ed
.Pp
Specifies the interface for which statistics are accumulated.
.It Dv DIOCGETSTATUS   Fa "struct pf_status"
.Bd -literal
struct pf_status {
	u_int64_t	 counters[PFRES_MAX];
	u_int64_t	 fcounters[FCNT_MAX];
	u_int64_t	 pcounters[2][2][3];
	u_int64_t	 bcounters[2][2];
	u_int32_t	 running;
	u_int32_t	 states;
	u_int32_t	 since;
	u_int32_t	 debug;
};
.Ed
.Pp
Gets the internal packet filter statistics.
.It Dv DIOCCLRSTATUS
Clears the internal packet filter statistics.
.It Dv DIOCNATLOOK     Fa "struct pfioc_natlook"
Looks up a state table entry by source and destination addresses and ports.
.Bd -literal
struct pfioc_natlook {
	struct pf_addr	 saddr;
	struct pf_addr	 daddr;
	struct pf_addr	 rsaddr;
	struct pf_addr	 rdaddr;
	u_int16_t	 sport;
	u_int16_t	 dport;
	u_int16_t	 rsport;
	u_int16_t	 rdport;
	u_int8_t	 af;
	u_int8_t	 proto;
	u_int8_t	 direction;
};
.Ed
.It Dv DIOCSETDEBUG    Fa "u_int32_t"
Sets the debug level.
.Bd -literal
enum	{ PF_DEBUG_NONE=0, PF_DEBUG_URGENT=1, PF_DEBUG_MISC=2 };
.Ed
.It Dv DIOCGETSTATES   Fa "struct pfioc_states"
.Bd -literal
struct pfioc_states {
	int	ps_len;
	union {
		caddr_t psu_buf;
		struct pf_state *psu_states;
	} ps_u;
#define ps_buf		ps_u.psu_buf
#define ps_states	ps_u.psu_states
};
.Ed
.It Dv DIOCCHANGERULE  Fa "struct pfioc_rule"
Adds or removes the
.Va rule
in the ruleset specified by
.Va rule.action .
.Bd -literal
enum	{ PF_CHANGE_ADD_HEAD=1, PF_CHANGE_ADD_TAIL=2,
	  PF_CHANGE_ADD_BEFORE=3, PF_CHANGE_ADD_AFTER=4,
	  PF_CHANGE_REMOVE=5, PF_CHANGE_GET_TICKET=6 };
.Ed
.Pp
The type of operation to be performed is indicated by
.Va action .
.Pp
.Va ticket
must be set to the value obtained with PF_CHANGE_GET_TICKET
for all actions except PF_CHANGE_GET_TICKET.
.Va pool_ticket
must be set to the value obtained with the DIOCBEGINADDRS call
for all actions except PF_CHANGE_REMOVE and PF_CHANGE_GET_TICKET.
.Pp
.Va anchor
and
.Va ruleset
indicate which anchor and ruleset the operation applies to.
.Va nr
indicates the rule number against which PF_CHANGE_ADD_BEFORE,
PF_CHANGE_ADD_AFTER or PF_CHANGE_REMOVE actions are applied.
.It Dv DIOCCHANGEADDR  Fa "struct pfioc_addr"
Adds or removes a pool address
.Va addr
from a rule specified with
.Va r_action ,
.Va r_num ,
.Va anchor
and
.Va ruleset .
.It Dv DIOCSETTIMEOUT  Fa "struct pfioc_tm"
.Bd -literal
struct pfioc_tm {
	int		 timeout;
	int		 seconds;
};
.Ed
.It Dv DIOCGETTIMEOUT  Fa "struct pfioc_tm"
.It Dv DIOCCLRRULECTRS
Clear per-rule statistics.
.It Dv DIOCSETLIMIT   Fa "struct pfioc_limit"
Sets hard limits on the memory pools used by the packet filter.
.Bd -literal
struct pfioc_limit {
	int		index;
	unsigned	limit;
};
.Ed
.It Dv DIOCGETLIMIT   Fa "struct pfioc_limit"
.It Dv DIOCRCLRTABLES Fa "struct pfioc_table"
Clear all tables.
All the IOCTLs that manipulate radix tables
use the same structure described below.
For
.Dv DIOCRCLRTABLES, pfrio_ndel contains on exit the number
of tables deleted.
.Bd -literal
struct pfioc_table {
        struct pfr_table         pfrio_table;
        void                    *pfrio_buffer;
        int                      pfrio_size;
        int                      pfrio_size2;
        int                      pfrio_nadd;
        int                      pfrio_ndel;
        int                      pfrio_nchange;
        int                      pfrio_flags;
        int                      pfrio_ticket;
};
#define pfrio_exists    pfrio_nadd
#define pfrio_nzero     pfrio_nadd
#define pfrio_nmatch    pfrio_nadd
#define pfrio_naddr     pfrio_size2
#define pfrio_setflag   pfrio_size2
#define pfrio_clrflag   pfrio_nadd
.Ed
.It Dv DIOCRADDTABLES Fa "struct pfioc_table"
Creates one or more tables.
On entry, pfrio_buffer[pfrio_size] contains a table of pfr_table structures.
On exit, pfrio_nadd contains the number of tables effectively created.
.Bd -literal
struct pfr_table {
        char                     pfrt_name[PF_TABLE_NAME_SIZE];
        u_int32_t                pfrt_flags;
};
.Ed
.It Dv DIOCRDELTABLES Fa "struct pfioc_table"
Deletes one or more tables.
On entry, pfrio_buffer[pfrio_size] contains a table of pfr_table structures.
On exit, pfrio_nadd contains the number of tables effectively deleted.
.It Dv DIOCRGETTABLES Fa "struct pfioc_table"
Get the list of all tables.
On entry, pfrio_buffer[pfrio_size] contains a valid writeable buffer for
pfr_table structures.
On exit, pfrio_size contains the number of tables written into the buffer.
If the buffer is too small, the kernel does not store anything but just
returns the required buffer size, without error.
.It Dv DIOCRGETTSTATS Fa "struct pfioc_table"
Like
.Dv DIOCRGETTABLES, but returns an array of pfr_tstats structures.
.Bd -literal
struct pfr_tstats {
        struct pfr_table pfrts_t;
        u_int64_t        pfrts_packets
                             [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
        u_int64_t        pfrts_bytes
                             [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
        u_int64_t        pfrts_match;
        u_int64_t        pfrts_nomatch;
        long             pfrts_tzero;
        int              pfrts_cnt;
        int              pfrts_refcnt;
};
#define pfrts_name      pfrts_t.pfrt_name
#define pfrts_flags     pfrts_t.pfrt_flags
.Ed
.It Dv DIOCRCLRTSTATS Fa "struct pfioc_table"
Clears the statistics of one or more tables.
On entry, pfrio_buffer[pfrio_size] contains a table of pfr_table structures.
On exit, pfrio_nzero contains the number of tables effectively cleared.
.It Dv DIOCRCLRADDRS Fa "struct pfioc_table"
Clear all addresses in a table.
On entry, pfrio_table contains the table to clear.
On exit, pfrio_ndel contains the number of addresses removed.
.It Dv DIOCRADDADDRS Fa "struct pfioc_table"
Add one or more addresses to a table.
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains the list of pfr_addr structures to add.
On exit, pfrio_nadd contains the number of addresses effectively added.
.Bd -literal
struct pfr_addr {
        union {
                struct in_addr   _pfra_ip4addr;
                struct in6_addr  _pfra_ip6addr;
        }                pfra_u;
        u_int8_t         pfra_af;
        u_int8_t         pfra_net;
        u_int8_t         pfra_not;
        u_int8_t         pfra_fback;
};
#define pfra_ip4addr    pfra_u._pfra_ip4addr
#define pfra_ip6addr    pfra_u._pfra_ip6addr
.Ed
.It Dv DIOCRDELADDRS Fa "struct pfioc_table"
Delete one or more addresses from a table.
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains the list of pfr_addr structures to delete.
On exit, pfrio_ndel contains the number of addresses effectively deleted.
.It Dv DIOCRSETADDRS Fa "struct pfioc_table"
Replace the content of a table by a new address list.
This is the most complicated command, which uses all the structure members.
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains the new list of pfr_addr structures.
In addition to that, if size2 is nonzero, pfrio_buffer[pfrio_size..pfrio_size2]
must be a writeable buffer, into which the kernel can copy the addresses that
have been deleted during the replace operation.
On exit, pfrio_ndel, pfrio_nadd and pfrio_nchange contain the number of
addresses deleted, added and changed by the kernel.
If pfrio_size2 was set on
entry, pfrio_size2 will point to the size of the buffer used, exactly like
.Dv DIOCRGETADDRS.
.It Dv DIOCRGETADDRS Fa "struct pfioc_table"
Get all the addresses of a table.
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains a valid writeable buffer for pfr_addr structures.
On exit, pfrio_size contains the number of addresses written into the buffer.
If the buffer was too small, the kernel does not store anything but just
return the required buffer size, without returning an error.
.It Dv DIOCRGETASTATS Fa "struct pfioc_table"
Like
.Dv DIOCRGETADDRS, but returns an array of pfr_astats structures.
.Bd -literal
struct pfr_astats {
        struct pfr_addr  pfras_a;
        u_int64_t        pfras_packets
                             [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
        u_int64_t        pfras_bytes
                             [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
        long             pfras_tzero;
};
.Ed
.It Dv DIOCRCLRASTATS Fa "struct pfioc_table"
Clears the statistics of one or more addresses.
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains a table of pfr_addr structures to clear.
On exit, pfrio_nzero contains the number of addresses effectively cleared.
.It Dv DIOCRTSTADDRS Fa "struct pfioc_table"
Test if the given addresses match a table.
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains a table of pfr_addr structures to test.
On exit, the kernel updates the pfr_addr table by setting the pfra_fback
member appropriately.
.It Dv DIOCRSETTFLAGS Fa "struct pfioc_table"
Change the
.Va const
or
.Va persist
flag of a table.
On entry, pfrio_buffer[pfrio_size] contains a table of pfr_table structures,
and pfrio_setflag contains the flags to add, while pfrio_clrflag contains the
flags to remove.
On exit, pfrio_nchange and pfrio_ndel contain the number of tables altered
or deleted by the kernel.
Yes, tables can be deleted if one removes the
.Va persist
flag of an unreferenced table.
.It Dv DIOCRINABEGIN Fa "struct pfioc_table"
Starts a transaction with the inactive set of tables.
Cleans up any leftover from a previously aborted transaction, and returns
a new ticket.
On exit, pfrio_ndel contains the number of leftover table deleted, and
pfrio_ticket contains a valid ticket to use for the following two IOCTLs.
.It Dv DIOCRINACOMMIT Fa "struct pfioc_table"
Commit the inactive set of tables into the active set.
While copying the addresses, do a best effort to keep statistics for
addresses present before and after the commit.
On entry, io->pfrio_ticket takes a valid ticket.
On exit, io->pfrio_nadd and io->pfrio_nchange contain the number of tables
added and altered by the commit operation.
.It Dv DIOCRINADEFINE Fa "struct pfioc_table"
Defines a table in the inactive set.
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains the list of pfr_addr structures to put in the table.
A valid ticket must also be supplied to pfrio_ticket.
On exit, pfrio_nadd contains 0 if the table was already defined in the
inactive list, or 1 if a new table has been created.
pfrio_naddr contains the number of addresses effectively put in the table.
.El
.Sh EXAMPLES
The following example demonstrates how to use the DIOCNATLOOK command
to find the internal host/port of a NATed connection.
.Bd -literal
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <net/if.h>
#include <netinet/in.h>
#include <net/pfvar.h>
#include <stdio.h>

u_int32_t
read_address(const char *s)
{
	int a, b, c, d;

	sscanf(s, "%i.%i.%i.%i", &a, &b, &c, &d);
	return htonl(a << 24 | b << 16 | c << 8 | d);
}

void
print_address(u_int32_t a)
{
	a = ntohl(a);
	printf("%d.%d.%d.%d", a >> 24 & 255, a >> 16 & 255,
	    a >> 8 & 255, a & 255);
}

int
main(int argc, char *argv[])
{
	struct pfioc_natlook nl;
	int dev;

	if (argc != 5) {
		printf("%s <gwy addr> <gwy port> <ext addr> <ext port>\\n",
		    argv[0]);
		return 1;
	}

	dev = open("/dev/pf", O_RDWR);
	if (dev == -1)
		err(1, "open(\\"/dev/pf\\") failed");

	memset(&nl, 0, sizeof(struct pfioc_natlook));
	nl.saddr.v4.s_addr	= read_address(argv[1]);
	nl.sport		= htons(atoi(argv[2]));
	nl.daddr.v4.s_addr	= read_address(argv[3]);
	nl.dport		= htons(atoi(argv[4]));
	nl.af			= AF_INET;
	nl.proto		= IPPROTO_TCP;
	nl.direction		= PF_IN;

	if (ioctl(dev, DIOCNATLOOK, &nl))
		err(1, "DIOCNATLOOK");

	printf("internal host ");
	print_address(nl.rsaddr.v4.s_addr);
	printf(":%u\\n", ntohs(nl.rsport));
	return 0;
}
.Ed
.Sh SEE ALSO
.Xr ioctl 2 ,
.Xr bridge 4 ,
.Xr pflog 4 ,
.Xr pfsync 4 ,
.Xr pfctl 8
.Sh HISTORY
The
.Nm
packet filtering mechanism first appeared in
.Ox 3.0 .
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source with the "new" command line as well,
in order to be able to provide a MirBSD release which bases
upon a fairly current OpenBSD base source code tree deemed
stable enough.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.30 2003/04/11 16:52:48 tedu Exp $
d46 2
a47 2
add and remove individual rules or state table entries,
and retrieve statistics.
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.31 2003/05/24 14:29:29 cedric Exp $
a376 1
        int                      pfrio_esize;
a397 2
        char                     pfrt_anchor[PF_ANCHOR_NAME_SIZE];
        char                     pfrt_ruleset[PF_RULESET_NAME_SIZE];
a399 1
        u_int8_t                 pfrt_fback;
d427 1
a427 1
        int              pfrts_refcnt[PFR_REFCNT_MAX];
@


1.1.1.4
log
@Import OpenBSD CVS of roughly 2000-2200 UTC. Last import before release.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.32 2003/06/06 10:29:41 jmc Exp $
d419 1
a419 2
.Dv DIOCRGETTABLES ,
but returns an array of pfr_tstats structures.
d480 1
a480 1
.Dv DIOCRGETADDRS .
d490 1
a490 2
.Dv DIOCRGETADDRS ,
but returns an array of pfr_astats structures.
@


1.1.1.5
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.33 2003/08/09 13:36:25 dhartmei Exp $
a560 1
#include <err.h>
a561 1
#include <stdlib.h>
@


1.1.1.6
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.34 2003/08/11 20:39:38 dhartmei Exp $
d338 1
a338 1
.It Dv DIOCCHANGEADDR  Fa "struct pfioc_pooladdr"
@


1.1.1.7
log
@Pull in a bit of current OpenBSD, to the least
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.35 2003/08/21 19:12:59 frantzen Exp $
a548 77
.It Dv DIOCFPFLUSH
Flush the passive OS fingerprint table.
.It Dv DIOCFPADD Fa "struct pf_osfp_ioctl"
.Bd -literal
struct pf_osfp_ioctl {
	struct pf_osfp_entry {
		SLIST_ENTRY(pf_osfp_entry) fp_entry;
		pf_osfp_t		fp_os;
		char			fp_class_nm[PF_OSFP_LEN];
		char			fp_version_nm[PF_OSFP_LEN];
		char			fp_subtype_nm[PF_OSFP_LEN];
	} 			fp_os;
	u_int16_t		fp_mss;
	u_int16_t		fp_wsize;
	u_int16_t		fp_psize;
	u_int8_t		fp_ttl;
	u_int8_t		fp_wscale;
	u_int8_t		fp_flags;
	int			fp_getnum;
};
.Ed
.Pp
Add a passive OS fingerprint to the table.
Set
.Va fp_os.fp_os
to the packed fingerprint,
.Va fp_os.fp_class_nm
to the name of the class (Linux, Windows, etc),
.Va fp_os.fp_version_nm
to the name of the version (NT, 95, 98), and
.Va fp_os.fp_subtype_nm
to the name of the subtype or patchlevel.
The members
.Va fp_mss
.Va fp_wsize
.Va fp_psize
.Va fp_ttl
and
.Va fp_wscale
are set to the TCP MSS, the TCP window size, the IP length and the IP TTL of
the TCP SYN packet respectively.
The
.Va fp_flags
member is filled according to the net/pfvar.h include file PF_OSFP_* defines.
The
.Va fp_getnum
is not used with this ioctl.
.Pp
The structure's slack space must be zeroed for correct operation; memset
the whole structure to zero before filling and sending to the kernel.
.It Dv DIOCFPGET Fa "struct pf_osfp_ioctl"
.Bd -literal
struct pf_osfp_ioctl {
	struct pf_osfp_entry {
		SLIST_ENTRY(pf_osfp_entry) fp_entry;
		pf_osfp_t		fp_os;
		char			fp_class_nm[PF_OSFP_LEN];
		char			fp_version_nm[PF_OSFP_LEN];
		char			fp_subtype_nm[PF_OSFP_LEN];
	} 			fp_os;
	u_int16_t		fp_mss;
	u_int16_t		fp_wsize;
	u_int16_t		fp_psize;
	u_int8_t		fp_ttl;
	u_int8_t		fp_wscale;
	u_int8_t		fp_flags;
	int			fp_getnum;
};
.Ed
.Pp
Get the passive OS fingerprint number
.Va fp_getnum
from the kernels fingerprint list.
The rest of the structure members will come back filled.
Get the whole list by repeatadly incrementing the
.Va fp_getnum
number until the ioctl returns EBUSY.
@


1.1.1.8
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.37 2003/08/28 09:41:22 jmc Exp $
d582 4
a585 4
.Va fp_mss ,
.Va fp_wsize ,
.Va fp_psize ,
.Va fp_ttl ,
d621 1
a621 1
from the kernel's fingerprint list.
d623 1
a623 1
Get the whole list by repeatedly incrementing the
@


1.1.1.9
log
@Import OpenBSD source tree again, with critical bug fixes
(OpenSSL, bc, dc, sensorsd, pf, ...)
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.39 2003/10/02 00:25:42 mcbride Exp $
d100 5
d123 1
a123 1
obtained through preceding DIOCXBEGIN call, and
d136 7
a146 1
	u_int32_t	action;
d152 4
a269 1
	char		 ifname[IFNAMSIZ];
d288 1
a288 1
	sa_family_t	 af;
d528 13
a548 40
.It Dv DIOCXBEGIN Fa "struct pfioc_trans"
.Bd -literal
#define PF_RULESET_ALTQ         (PF_RULESET_MAX)
#define PF_RULESET_TABLE        (PF_RULESET_MAX+1)
struct pfioc_trans {
        int              size;  /* number of elements */
        int              esize; /* size of each element in bytes */
        struct pfioc_trans_e {
                int             rs_num;
                char            anchor[PF_ANCHOR_NAME_SIZE];
                char            ruleset[PF_RULESET_NAME_SIZE];
                u_int32_t       ticket;
        }               *array;
};
.Ed
.Pp
Clears all the inactive rulesets specified in the
.Fa "struct pfioc_trans_e"
array.
For each ruleset, a ticket is returned for subsequent "add rule" IOCTLs,
as well as for the
.Dv DIOCXCOMMIT
and
.Dv DIOCXROLLBACK
calls.
.It Dv DIOCXCOMMIT Fa "struct pfioc_trans"
Atomically switch a vector of inactive rulesets to the active rulesets.
Implemented as a standard 2-phase commit, which will either fail for all
rulesets or completely succeed.
All tickets need to be valid.
Returns
.Dv EBUSY
if a concurrent process is trying to update some of the same rulesets
concurrently.
.It Dv DIOCXROLLBACK Fa "struct pfioc_trans"
Clean up the kernel by undoing all changes that have taken place on the
inactive rulesets since the last
.Dv DIOCXBEGIN .
.Dv DIOCXROLLBACK
will silently ignore rulesets for which the ticket is invalid.
@


1.1.1.10
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.42 2003/12/15 05:18:40 jmc Exp $
d75 5
a79 1
.It Dv DIOCBEGINADDRS  Fa "pfioc_pool_addr"
a94 6
Clears the buffer address pool
and returns a
.Va ticket
for subsequent DIOCADDADDR, DIOCADDRULE and DIOCCHANGERULE calls.
.It Dv DIOCADDADDR     Fa "struct pfioc_pooladdr"
.Pp
d247 9
a255 11
	u_int64_t	counters[PFRES_MAX];
	u_int64_t	fcounters[FCNT_MAX];
	u_int64_t	scounters[SCNT_MAX];
	u_int64_t	pcounters[2][2][3];
	u_int64_t	bcounters[2][2];
	u_int32_t	running;
	u_int32_t	states;
	u_int32_t	src_nodes;
	u_int32_t	since;
	u_int32_t	debug;
	char		ifname[IFNAMSIZ];
a638 36
.It Dv DIOCGETSRCNODES Fa "struct pfioc_src_nodes"
.Bd -literal
struct pfioc_src_nodes {
        int     psn_len;
        union {
                caddr_t          psu_buf;
                struct pf_src_node      *psu_src_nodes;
        } psn_u;
#define psn_buf         psn_u.psu_buf
#define psn_src_nodes   psn_u.psu_src_nodes
};
.Ed
.Pp
Get the list of source nodes kept by the
.Ar sticky-address
and
.Ar source-track
options.
The ioctl must be called once with
.Va psn_len
set to 0.
If the ioctl returns without error,
.Va psn_len
will be set to the size of the buffer required to hold all the
.Va pf_src_node
structures held in the table.
A buffer of this size should then be allocated, and a pointer to this buffer
placed in
.Va psn_buf .
The ioctl must then be called again to fill this buffer with the actual
source node data.
After the ioctl call
.Va psn_len
will be set to the length of the buffer actually used.
.It Dv DIOCCLRSRCNODES Fa "struct pfioc_table"
Clear the tree of source tracking nodes.
@


1.1.1.11
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.44 2003/12/31 14:03:01 jmc Exp $
a678 73
.It Dv DIOCIGETIFACES Fa "struct pfioc_iface"
Gets the list of interfaces and interface drivers known to
.Nm .
All the IOCTLs that manipulate interfaces
use the same structure described below:
.Bd -literal
struct pfioc_iface {
        char                     pfiio_name[IFNAMSIZ];
        void                    *pfiio_buffer;
        int                      pfiio_esize;
        int                      pfiio_size;
        int                      pfiio_nzero;
        int                      pfiio_flags;
};

#define PFI_FLAG_GROUP     0x0001  /* gets groups of interfaces */
#define PFI_FLAG_INSTANCE  0x0002  /* gets single interfaces */
#define PFI_FLAG_ALLMASK   0x0003
.Ed
.Pp
If not empty,
.Va pfiio_name
can be used to restrict the search to a specific interface or driver.
.Va pfiio_buffer[pfiio_size]
is the user-supplied buffer for returning the data.
On entry,
.Va pfiio_size
represents the number of
.Va pfi_if
entries that can fit into the buffer.
The kernel will replace this value by the real number of entries it wants
to return.
.Va pfiio_esize
should be set to sizeof(struct pfi_if).
.Va pfiio_flags
should be set to
.Dv PFI_FLAG_GROUP , PFI_FLAG_INSTANCE ,
or both to tell the kernel to return a group of interfaces
(drivers, like "fxp"), real interface instances (like "fxp1") or both.
The data is returned in the
.Va pfi_if
structure described below:
.Bd -literal
struct pfi_if {
        char                             pfif_name[IFNAMSIZ];
        u_int64_t                        pfif_packets[2][2][2];
        u_int64_t                        pfif_bytes[2][2][2];
        u_int64_t                        pfif_addcnt;
        u_int64_t                        pfif_delcnt;
        long                             pfif_tzero;
        int                              pfif_states;
        int                              pfif_rules;
        int                              pfif_flags;
};

#define PFI_IFLAG_GROUP         0x0001  /* group of interfaces */
#define PFI_IFLAG_INSTANCE      0x0002  /* single instance */
#define PFI_IFLAG_CLONABLE      0x0010  /* clonable group */
#define PFI_IFLAG_DYNAMIC       0x0020  /* dynamic group */
#define PFI_IFLAG_ATTACHED      0x0040  /* interface attached */
#define PFI_IFLAG_REFERENCED    0x0080  /* referenced by rules */
.Ed
.It Dv DIOCICLRISTATS Fa "struct pfioc_iface"
Clear the statistics counters of one or more interfaces.
.Va pfiio_name
and
.Va pfrio_flags
can be used to select which interfaces need to be cleared.
The filtering process is the same as for
.Dv DIOCIGETIFACES .
.Va pfiio_nzero
will be set by the kernel to the number of interfaces and drivers
that have been cleared.
@


1.1.1.12
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.45 2004/01/24 18:54:40 deraadt Exp $
d75 1
a75 1
.It Dv DIOCBEGINADDRS  Fa "struct pfioc_pooladdr"
@


1.1.1.13
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.49 2004/03/31 08:20:57 jmc Exp $
d36 1
a36 1
.Cd "pseudo-device pf"
d57 5
d63 1
a63 2
.Nm
supports the following
d65 1
a65 2
commands, available through
.Aq Pa net/pfvar.h :
d68 1
a68 1
Start the packet filter.
d70 1
a70 1
Stop the packet filter.
d72 1
a72 2
Start the ALTQ bandwidth control system (see
.Xr altq 9 ) .
d74 2
a75 2
Stop the ALTQ bandwidth control system.
.It Dv DIOCBEGINADDRS Fa "struct pfioc_pooladdr"
d91 2
a92 1
Clear the buffer address pool and get a
d94 2
a95 7
for subsequent
.Dv DIOCADDADDR ,
.Dv DIOCADDRULE ,
and
.Dv DIOCCHANGERULE
calls.
.It Dv DIOCADDADDR Fa "struct pfioc_pooladdr"
d97 1
a97 1
Add the pool address
d100 1
a100 4
.Dv DIOCADDRULE
or
.Dv DIOCCHANGERULE
call.
d102 1
a102 1
.It Dv DIOCADDRULE Fa "struct pfioc_rule"
d115 1
a115 1
Add
d118 1
a118 1
This call requires a
d120 1
a120 3
obtained through a preceding
.Dv DIOCXBEGIN
call and a
d122 2
a123 5
obtained through a
.Dv DIOCBEGINADDRS
call.
.Dv DIOCADDADDR
must also be called if any pool addresses are required.
d133 2
a134 2
.It Dv DIOCADDALTQ Fa "struct pfioc_altq"
Add an ALTQ discipline or queue.
d140 1
a140 1
	struct pf_altq  altq;
d143 2
a144 2
.It Dv DIOCGETRULES Fa "struct pfioc_rule"
Get a
d146 1
a146 3
for subsequent
.Dv DIOCGETRULE
calls and the number
d149 2
a150 2
.It Dv DIOCGETRULE Fa "struct pfioc_rule"
Get a
d152 1
a152 1
by its number
d154 1
a154 1
using the
d156 3
a158 5
obtained through a preceding
.Dv DIOCGETRULES
call.
.It Dv DIOCGETADDRS Fa "struct pfioc_pooladdr"
Get a
d160 1
a160 3
for subsequent
.Dv DIOCGETADDR
calls and the number
d165 1
a165 1
.Va anchor ,
d168 2
a169 2
.It Dv DIOCGETADDR Fa "struct pfioc_pooladdr"
Get the pool address
d171 1
a171 1
by its number
d176 1
a176 1
.Va anchor ,
d179 1
a179 1
using the
d181 3
a183 5
obtained through a preceding
.Dv DIOCGETADDRS
call.
.It Dv DIOCGETALTQS Fa "struct pfioc_altq"
Get a
d185 1
a185 3
for subsequent
.Dv DIOCGETALTQ
calls and the number
d188 2
a189 2
.It Dv DIOCGETALTQ Fa "struct pfioc_altq"
Get the queueing discipline
d191 1
a191 1
by its number
d193 1
a193 1
using a
d195 3
a197 5
obtained through a preceding
.Dv DIOCGETALTQS
call.
.It Dv DIOCGETQSTATS Fa "struct pfioc_qstats"
Get the statistics on a queue.
d208 2
a209 2
This call fills in a pointer to the buffer of statistics
.Va buf ,
d211 1
a211 1
.Va nbytes ,
d214 5
a218 2
.It Dv DIOCADDSTATE Fa "struct pfioc_state"
Add a state entry.
d225 5
a229 8
.It Dv DIOCGETSTATE Fa "struct pfioc_state"
Extract the entry with the specified number
.Va nr
from the state table.
.It Dv DIOCKILLSTATES Fa "struct pfioc_state_kill"
Remove matching entries from the state table.
This call returns the number of killed states in
.Va psk_af .
d232 1
a232 1
	sa_family_t		psk_af;
a235 1
	char			psk_ifname[IFNAMSIZ];
a237 13
.It Dv DIOCCLRSTATES Fa "struct pfioc_state_kill"
Clear all states.
It works like
.Dv DIOCKILLSTATES ,
but ignores the
.Va psk_af ,
.Va psk_proto ,
.Va psk_src ,
and
.Va psk_dst
fields of the
.Va pfioc_state_kill
structure.
a238 1
Specify the interface for which statistics are accumulated.
d244 3
a246 2
.It Dv DIOCGETSTATUS Fa "struct pf_status"
Get the internal packet filter statistics.
a253 1
	u_int64_t	stateid;
a258 1
	u_int32_t	hostid;
d262 2
d265 3
a267 3
Clear the internal packet filter statistics.
.It Dv DIOCNATLOOK Fa "struct pfioc_natlook"
Look up a state table entry by source and destination addresses and ports.
d283 2
a284 2
.It Dv DIOCSETDEBUG Fa "u_int32_t"
Set the debug level.
d286 1
a286 2
enum	{ PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC,
	  PF_DEBUG_NOISY };
d288 1
a288 2
.It Dv DIOCGETSTATES Fa "struct pfioc_states"
Get state table entries.
d300 2
a301 18
.Pp
If
.Va ps_len
is zero, all states will be gathered into
.Va pf_states
and
.Va ps_len
will be set to the size they take in memory (i.e.,
.Li sizeof(struct pf_state) * nr ) .
If
.Va ps_len
is non-zero, as many states that can fit into
.Va ps_len
as possible will be gathered, and
.Va ps_len
will be updated to the size those rules take in memory.
.It Dv DIOCCHANGERULE Fa "struct pfioc_rule"
Add or remove the
d305 5
d312 1
a312 7
.Va action ,
which can be any of the following:
.Bd -literal
enum	{ PF_CHANGE_NONE, PF_CHANGE_ADD_HEAD, PF_CHANGE_ADD_TAIL,
	  PF_CHANGE_ADD_BEFORE, PF_CHANGE_ADD_AFTER,
	  PF_CHANGE_REMOVE, PF_CHANGE_GET_TICKET };
.Ed
d315 2
a316 4
must be set to the value obtained with
.Dv PF_CHANGE_GET_TICKET
for all actions except
.Dv PF_CHANGE_GET_TICKET .
d318 2
a319 6
must be set to the value obtained with the
.Dv DIOCBEGINADDRS
call for all actions except
.Dv PF_CHANGE_REMOVE
and
.Dv PF_CHANGE_GET_TICKET .
d324 1
a324 1
indicate to which anchor and ruleset the operation applies.
d326 4
a329 8
indicates the rule number against which
.Dv PF_CHANGE_ADD_BEFORE ,
.Dv PF_CHANGE_ADD_AFTER ,
or
.Dv PF_CHANGE_REMOVE
actions are applied.
.It Dv DIOCCHANGEADDR Fa "struct pfioc_pooladdr"
Add or remove the pool address
d331 1
a331 1
from the rule specified by
d334 1
a334 1
.Va anchor ,
d337 1
a337 1
.It Dv DIOCSETTIMEOUT Fa "struct pfioc_tm"
d344 1
a344 19
.Pp
Set the state timeout of
.Va timeout
to
.Va seconds .
The old value will be placed into
.Va seconds .
For possible values of
.Va timeout ,
consult the
.Dv PFTM_*
values in
.Aq Pa net/pfvar.h .
.It Dv DIOCGETTIMEOUT Fa "struct pfioc_tm"
Get the state timeout of
.Va timeout .
The value will be placed into the
.Va seconds
field.
d347 2
a348 2
.It Dv DIOCSETLIMIT Fa "struct pfioc_limit"
Set the hard limits on the memory pools used by the packet filter.
a353 2

enum { PF_LIMIT_STATES, PF_LIMIT_SRC_NODES, PF_LIMIT_FRAGS };
d355 1
a355 5
.It Dv DIOCGETLIMIT Fa "struct pfioc_limit"
Get the hard
.Va limit
for the memory pool indicated by
.Va index .
d358 1
a358 1
All the ioctls that manipulate radix tables
d361 2
a362 3
.Dv DIOCRCLRTABLES ,
.Va pfrio_ndel
contains on exit the number of tables deleted.
d365 10
a374 10
	struct pfr_table	 pfrio_table;
	void			*pfrio_buffer;
	int			 pfrio_esize;
	int			 pfrio_size;
	int			 pfrio_size2;
	int			 pfrio_nadd;
	int			 pfrio_ndel;
	int			 pfrio_nchange;
	int			 pfrio_flags;
	u_int32_t		 pfrio_ticket;
d384 3
a386 9
Create one or more tables.
On entry,
.Va pfrio_buffer[pfrio_size]
contains a table of
.Va pfr_table
structures.
On exit,
.Va pfrio_nadd
contains the number of tables effectively created.
d389 5
a393 5
	char		pfrt_anchor[PF_ANCHOR_NAME_SIZE];
	char		pfrt_ruleset[PF_RULESET_NAME_SIZE];
	char		pfrt_name[PF_TABLE_NAME_SIZE];
	u_int32_t	pfrt_flags;
	u_int8_t	pfrt_fback;
d397 3
a399 9
Delete one or more tables.
On entry,
.Va pfrio_buffer[pfrio_size]
contains a table of
.Va pfr_table
structures.
On exit,
.Va pfrio_nadd
contains the number of tables effectively deleted.
d402 3
a404 8
On entry,
.Va pfrio_buffer[pfrio_size]
contains a valid writeable buffer for
.Va pfr_table
structures.
On exit,
.Va pfrio_size
contains the number of tables written into the buffer.
d408 3
a410 5
This call is like
.Dv DIOCRGETTABLES
but is used to get an array of
.Va pfr_tstats
structures.
d413 10
a422 10
	struct pfr_table pfrts_t;
	u_int64_t	 pfrts_packets
			     [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_bytes
			     [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_match;
	u_int64_t	 pfrts_nomatch;
	long		 pfrts_tzero;
	int		 pfrts_cnt;
	int		 pfrts_refcnt[PFR_REFCNT_MAX];
d424 2
a425 2
#define pfrts_name	 pfrts_t.pfrt_name
#define pfrts_flags	 pfrts_t.pfrt_flags
d428 3
a430 9
Clear the statistics of one or more tables.
On entry,
.Va pfrio_buffer[pfrio_size]
contains a table of
.Va pfr_table
structures.
On exit,
.Va pfrio_nzero
contains the number of tables effectively cleared.
d433 2
a434 6
On entry,
.Va pfrio_table
contains the table to clear.
On exit,
.Va pfrio_ndel
contains the number of addresses removed.
d437 3
a439 10
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer[pfrio_size]
contains the list of
.Va pfr_addr
structures to add.
On exit,
.Va pfrio_nadd
contains the number of addresses effectively added.
d442 8
a449 8
	union {
		struct in_addr	 _pfra_ip4addr;
		struct in6_addr	 _pfra_ip6addr;
	}		 pfra_u;
	u_int8_t	 pfra_af;
	u_int8_t	 pfra_net;
	u_int8_t	 pfra_not;
	u_int8_t	 pfra_fback;
d456 3
a458 10
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer[pfrio_size]
contains the list of
.Va pfr_addr
structures to delete.
On exit,
.Va pfrio_ndel
contains the number of addresses effectively deleted.
d462 9
a470 26
.Pp
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer[pfrio_size]
contains the new list of
.Va pfr_addr
structures.
Additionally, if
.Va pfrio_size2
is non-zero,
.Va pfrio_buffer[pfrio_size..pfrio_size2]
must be a writeable buffer, into which the kernel can copy the
addresses that have been deleted during the replace operation.
On exit,
.Va pfrio_ndel ,
.Va pfrio_nadd ,
and
.Va pfrio_nchange
contain the number of addresses deleted, added, and changed by the
kernel.
If
.Va pfrio_size2
was set on entry,
.Va pfrio_size2
will point to the size of the buffer used, exactly like
d474 3
a476 10
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer[pfrio_size]
contains a valid writeable buffer for
.Va pfr_addr
structures.
On exit,
.Va pfrio_size
contains the number of addresses written into the buffer.
d478 1
a478 1
returns the required buffer size, without returning an error.
d480 3
a482 5
This call is like
.Dv DIOCRGETADDRS
but is used to get an array of
.Va pfr_astats
structures.
d485 6
a490 6
	struct pfr_addr	 pfras_a;
	u_int64_t	 pfras_packets
			     [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t	 pfras_bytes
			     [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	long		 pfras_tzero;
d494 4
a497 11
Clear the statistics of one or more addresses.
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer[pfrio_size]
contains a table of
.Va pfr_addr
structures to clear.
On exit,
.Va pfrio_nzero
contains the number of addresses effectively cleared.
d500 3
a502 11
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer[pfrio_size]
contains a table of
.Va pfr_addr
structures to test.
On exit, the kernel updates the
.Va pfr_addr
table by setting the
.Va pfra_fback
d506 1
a506 1
.Dv PFR_TFLAG_CONST
d508 7
a514 16
.Dv PFR_TFLAG_PERSIST
flags of a table.
On entry,
.Va pfrio_buffer[pfrio_size]
contains a table of
.Va pfr_table
structures, and
.Va pfrio_setflag
contains the flags to add, while
.Va pfrio_clrflag
contains the flags to remove.
On exit,
.Va pfrio_nchange
and
.Va pfrio_ndel
contain the number of tables altered or deleted by the kernel.
d516 1
a516 1
.Dv PFR_TFLAG_PERSIST
d520 6
a525 15
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer[pfrio_size]
contains the list of
.Va pfr_addr
structures to put in the table.
A valid ticket must also be supplied to
.Va pfrio_ticket .
On exit,
.Va pfrio_nadd
contains 0 if the table was already defined in the inactive list,
or 1 if a new table has been created.
.Va pfrio_naddr
contains the number of addresses effectively put in the table.
d531 8
a538 8
	int		 size;	/* number of elements */
	int		 esize;	/* size of each element in bytes */
	struct pfioc_trans_e {
		int		rs_num;
		char		anchor[PF_ANCHOR_NAME_SIZE];
		char		ruleset[PF_RULESET_NAME_SIZE];
		u_int32_t	ticket;
	}		*array;
d542 2
a543 2
Clear all the inactive rulesets specified in the
.Va pfioc_trans_e
d545 1
a545 1
For each ruleset, a ticket is returned for subsequent "add rule" ioctls,
d553 2
a554 2
This call is implemented as a standard two-phase commit, which will either
fail for all rulesets or completely succeed.
d557 1
a557 1
.Er EBUSY
d566 1
a566 1
.It Dv DIOCOSFPFLUSH
d568 1
a568 1
.It Dv DIOCOSFPADD Fa "struct pf_osfp_ioctl"
d578 1
a578 1
	pf_tcpopts_t		fp_tcpopts;
d581 1
a581 3
	u_int16_t		fp_mss;
	u_int16_t		fp_flags;
	u_int8_t		fp_optcnt;
d583 1
a583 1
	u_int8_t		fp_ttl;
a602 1
.Va fp_optcnt ,
d605 2
a606 4
are set to the TCP MSS, the TCP window size, the IP length, the IP TTL,
the number of TCP options, and the TCP window scaling constant of the
TCP SYN packet, respectively.
.Pp
d609 1
a609 19
member is filled according to the
.Aq Pa net/pfvar.h
include file
.Dv PF_OSFP_*
defines.
The
.Va fp_tcpopts
member contains packed TCP options.
Each option uses
.Dv PF_OSFP_TCPOPT_BITS
bits in the packed value.
Options include any of
.Dv PF_OSFP_TCPOPT_NOP ,
.Dv PF_OSFP_TCPOPT_SACK ,
.Dv PF_OSFP_TCPOPT_WSCALE ,
.Dv PF_OSFP_TCPOPT_MSS ,
or
.Dv PF_OSFP_TCPOPT_TS .
.Pp
d612 1
a612 1
member is not used with this ioctl.
d614 1
a614 2
The structure's slack space must be zeroed for correct operation;
.Xr memset 3
d616 20
a635 1
.It Dv DIOCOSFPGET Fa "struct pf_osfp_ioctl"
d642 1
a642 2
number until the ioctl returns
.Er EBUSY .
d646 7
a652 7
	int	psn_len;
	union {
		caddr_t		psu_buf;
		struct pf_src_node	*psu_src_nodes;
	} psn_u;
#define psn_buf		psn_u.psu_buf
#define psn_src_nodes	psn_u.psu_src_nodes
d656 5
a660 2
Get the list of source nodes kept by sticky addresses and source
tracking.
d674 1
a674 1
After that call,
d677 1
a677 1
.It Dv DIOCCLRSRCNODES
d680 1
a680 1
Get the list of interfaces and interface drivers known to
d682 1
a682 1
All the ioctls that manipulate interfaces
d686 6
a691 6
	char			 pfiio_name[IFNAMSIZ];
	void			*pfiio_buffer;
	int			 pfiio_esize;
	int			 pfiio_size;
	int			 pfiio_nzero;
	int			 pfiio_flags;
d712 1
a712 2
should be set to
.Li sizeof(struct pfi_if) .
d715 2
a716 3
.Dv PFI_FLAG_GROUP ,
.Dv PFI_FLAG_INSTANCE ,
or both, to tell the kernel to return a group of interfaces
d723 17
a739 16
	char				 pfif_name[IFNAMSIZ];
	u_int64_t			 pfif_packets[2][2][2];
	u_int64_t			 pfif_bytes[2][2][2];
	u_int64_t			 pfif_addcnt;
	u_int64_t			 pfif_delcnt;
	long				 pfif_tzero;
	int				 pfif_states;
	int				 pfif_rules;
	int				 pfif_flags;
};

#define PFI_IFLAG_GROUP		0x0001	/* group of interfaces */
#define PFI_IFLAG_INSTANCE	0x0002	/* single instance */
#define PFI_IFLAG_CLONABLE	0x0010	/* clonable group */
#define PFI_IFLAG_DYNAMIC	0x0020	/* dynamic group */
#define PFI_IFLAG_ATTACHED	0x0040	/* interface attached */
d745 1
a745 1
.Va pfiio_flags
a752 5
.Sh FILES
.Bl -tag -width /dev/pf -compact
.It Pa /dev/pf
packet filtering device.
.El
d754 2
a755 3
The following example demonstrates how to use the
.Dv DIOCNATLOOK
command to find the internal host/port of a NATed connection:
d824 1
a824 2
.Xr pfctl 8 ,
.Xr altq 9
@


