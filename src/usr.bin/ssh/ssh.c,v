head	1.23;
access;
symbols
	tg-mergetmp-mirosx-1:1.23
	tg-mergefixes-1-branch:1.23.0.4
	tg-mergefixes-1-base:1.23
	MIROS_X:1.23.0.2
	MIROS_X_BASE:1.23
	tg-mergetmp-3:1.23
	cvs-200412111650:1.1.1.17
	cvs-200412031430:1.1.1.17
	cvs-200411261545:1.1.1.17
	MIRBSD_XP_MIRPPC:1.22.0.4
	cvs-200411131700:1.1.1.17
	cvs-200410311900:1.1.1.16
	cvs-200410222040:1.1.1.16
	tg-mergetmp-1:1.1.1.16
	MIRBSD_XP_SPARC_BASE:1.22
	MIRBSD_XP_SPARC:1.22.0.2
	cvs-200410012000:1.1.1.16
	cvs-200408281215:1.1.1.15
	cvs-200408220030:1.1.1.14
	MIRBSD_7quater:1.14
	cvs-200405160640:1.1.1.13
	cvs-200403222025:1.1.1.12
	cvs-200403101630:1.1.1.11
	cvs-200401271800:1.1.1.10
	cvs-200401261630:1.1.1.10
	cvs-200401021645:1.1.1.10
	MIRBSD_7_ALPHA:1.14.0.6
	MIRBSD_7:1.14.0.4
	cvs-200312222040:1.1.1.10
	MIRBSD_7ter:1.14
	MIRBSD_7_DEV:1.14.0.2
	cvs-200310021412:1.1.1.9
	cvs-200310020700:1.1.1.9
	cvs-200309271030:1.1.1.9
	cvs-200309251530:1.1.1.9
	cvs-200309162245:1.1.1.9
	cvs-200308302005:1.1.1.8
	cvs-200308171200:1.1.1.8
	ctm-3496:1.1.1.7
	ctm-3449:1.1.1.7
	ctm-3437:1.1.1.6
	cvs-200307191805:1.1.1.6
	ctm-3425:1.1.1.6
	cvs-200307091500:1.1.1.5
	ctm-3389:1.1.1.5
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.4
	MIRBSD_5:1.6
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.3
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.3
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2004.11.13.17.22.02;	author tg;	state Exp;
branches;
next	1.22;

1.22
date	2004.10.01.20.25.24;	author tg;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.28.12.28.28;	author tg;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.22.00.47.56;	author tg;	state Stab;
branches;
next	1.19;

1.19
date	2004.05.23.18.46.54;	author tg;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.22.21.09.44;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.10.17.39.14;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.03.03.32.51;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.27.00.31.28;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.01.21.15.42;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.16.23.04.48;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.01.17.36.46;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.17.18.57.02;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.26.16.08.38;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.18.15.46.37;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.06.20.23.05;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.19.16.44.56;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.22.14.09.09;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.07.21.42.39;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.07.21.30.45;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.10.20.12.36;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.53.13;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.53.23;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.53.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.55.42;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.21.19.17.19;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.53.52;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.07.06.15.51.19;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.07.18.13.53.27;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.07.26.13.24.41;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.08.17.14.46.38;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.09.16.22.57.38;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.12.22.21.14.16;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.03.10.16.35.09;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2004.03.22.20.56.56;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2004.05.16.08.11.56;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2004.08.22.00.32.31;	author tg;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2004.08.28.12.19.51;	author tg;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2004.10.01.20.08.42;	author tg;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2004.11.13.17.07.18;	author tg;	state Exp;
branches;
next	;


desc
@@


1.23
log
@merge, version
@
text
@/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Ssh client program.  This program can be used to log into a remote machine.
 * The software supports strong authentication, encryption, and forwarding
 * of X11, TCP/IP, and authentication connections.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * Copyright (c) 1999 Niels Provos.  All rights reserved.
 * Copyright (c) 2000, 2001, 2002, 2003 Markus Friedl.  All rights reserved.
 *
 * Modified to work with SSL by Niels Provos <provos@@citi.umich.edu>
 * in Canada (German citizen).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "includes.h"
RCSID("$MirBSD: src/usr.bin/ssh/ssh.c,v 1.22 2004/10/01 20:25:24 tg Exp $");

#include <openssl/evp.h>
#include <openssl/err.h>

#include "ssh.h"
#include "ssh1.h"
#include "ssh2.h"
#include "compat.h"
#include "cipher.h"
#include "xmalloc.h"
#include "packet.h"
#include "buffer.h"
#include "bufaux.h"
#include "channels.h"
#include "key.h"
#include "authfd.h"
#include "authfile.h"
#include "pathnames.h"
#include "dispatch.h"
#include "clientloop.h"
#include "log.h"
#include "readconf.h"
#include "sshconnect.h"
#include "misc.h"
#include "kex.h"
#include "mac.h"
#include "sshpty.h"
#include "match.h"
#include "msg.h"
#include "monitor_fdpass.h"
#include "uidswap.h"

#ifdef SMARTCARD
#include "scard.h"
#endif

extern char *__progname;

/* Flag indicating whether debug mode is on.  This can be set on the command line. */
int debug_flag = 0;

/* Flag indicating whether a tty should be allocated */
int tty_flag = 0;
int no_tty_flag = 0;
int force_tty_flag = 0;

/* don't exec a shell */
int no_shell_flag = 0;

/*
 * Flag indicating that nothing should be read from stdin.  This can be set
 * on the command line.
 */
int stdin_null_flag = 0;

/*
 * Flag indicating that ssh should fork after authentication.  This is useful
 * so that the passphrase can be entered manually, and then ssh goes to the
 * background.
 */
int fork_after_authentication_flag = 0;

/*
 * General data structure for command line options and options configurable
 * in configuration files.  See readconf.h.
 */
Options options;

/* optional user configfile */
char *config = NULL;

/*
 * Name of the host we are connecting to.  This is the name given on the
 * command line, or the HostName specified for the user-supplied name in a
 * configuration file.
 */
char *host;

/* socket address the host resolves to */
struct sockaddr_storage hostaddr;

/* Private host keys. */
Sensitive sensitive_data;

/* Original real UID. */
uid_t original_real_uid;
uid_t original_effective_uid;

/* command to be executed */
Buffer command;

/* Should we execute a command or invoke a subsystem? */
int subsystem_flag = 0;

/* # of replies received for global requests */
static int client_global_request_id = 0;

/* pid of proxycommand child process */
pid_t proxy_command_pid = 0;

/* fd to control socket */
int control_fd = -1;

/* Multiplexing control command */
static u_int mux_command = SSHMUX_COMMAND_OPEN;

/* Only used in control client mode */
volatile sig_atomic_t control_client_terminate = 0;
u_int control_server_pid = 0;

/* Prints a help message to the user.  This function never returns. */

static void
usage(void)
{
	fprintf(stderr, "Usage: %s [options] host [command]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -l user     Log in using this user name.\n");
	fprintf(stderr, "  -n          Redirect input from " _PATH_DEVNULL ".\n");
	fprintf(stderr, "  -F config   Config file (default: ~/%s).\n",
	     _PATH_SSH_USER_CONFFILE);
	fprintf(stderr, "  -A          Enable authentication agent forwarding.\n");
	fprintf(stderr, "  -a          Disable authentication agent forwarding (default).\n");
	fprintf(stderr, "  -X          Enable X11 connection forwarding.\n");
	fprintf(stderr, "  -Y          Enable trusted X11 connection forwarding.\n");
	fprintf(stderr, "  -x          Disable X11 connection forwarding (default).\n");
	fprintf(stderr, "  -i file     Identity for public key authentication "
	    "(default: ~/.etc/ssh/identity)\n");
#ifdef SMARTCARD
	fprintf(stderr, "  -I reader   Set smartcard reader.\n");
#endif
	fprintf(stderr, "  -t          Tty; allocate a tty even if command is given.\n");
	fprintf(stderr, "  -T          Do not allocate a tty.\n");
	fprintf(stderr, "  -v          Verbose; display verbose debugging messages.\n");
	fprintf(stderr, "              Multiple -v increases verbosity.\n");
	fprintf(stderr, "  -V          Display version number only.\n");
	fprintf(stderr, "  -q          Quiet; don't display any warning messages.\n");
	fprintf(stderr, "  -f          Fork into background after authentication.\n");
	fprintf(stderr, "  -e char     Set escape character; ``none'' = disable (default: ~).\n");

	fprintf(stderr, "  -c cipher   Select encryption algorithm\n");
	fprintf(stderr, "  -m macs     Specify MAC algorithms for protocol version 2.\n");
	fprintf(stderr, "  -p port     Connect to this port.  Server must be on the same port.\n");
	fprintf(stderr, "  -L listen-port:host:port   Forward local port to remote address\n");
	fprintf(stderr, "  -R listen-port:host:port   Forward remote port to local address\n");
	fprintf(stderr, "              These cause %s to listen for connections on a port, and\n", __progname);
	fprintf(stderr, "              forward them to the other side by connecting to host:port.\n");
	fprintf(stderr, "  -D port     Enable dynamic application-level port forwarding.\n");
	fprintf(stderr, "  -C          Enable compression.\n");
	fprintf(stderr, "  -N          Do not execute a shell or command.\n");
	fprintf(stderr, "  -g          Allow remote hosts to connect to forwarded ports.\n");
	fprintf(stderr, "  -1          Force protocol version 1.\n");
	fprintf(stderr, "  -2          Force protocol version 2.\n");
	fprintf(stderr, "  -4          Use IPv4 only.\n");
	fprintf(stderr, "  -6          Use IPv6 only.\n");
	fprintf(stderr, "  -o 'option' Process the option as if it was read from a configuration file.\n");
	fprintf(stderr, "  -s          Invoke command (mandatory) as SSH2 subsystem.\n");
	fprintf(stderr, "  -b addr     Local IP address.\n");
	fprintf(stderr, "  -h          Disable lowdelay TOS type, e.g. for rsync.\n");
	fprintf(stderr, "  -M          Enable session multiplexing master mode.\n");
	fprintf(stderr, "  -S ctl_path Use ctl_path as socket for session multiplexing.\n");
	fprintf(stderr, "  -O ctl_cmd  Pass command to multiplex session master.\n");
	exit(1);
}

static int ssh_session(void);
static int ssh_session2(void);
static void load_public_identity_files(void);
static void control_client(const char *path);

/*
 * Main program for the ssh client.
 */
int
main(int ac, char **av)
{
	int i, opt, exit_status;
	u_short fwd_port, fwd_host_port;
	char sfwd_port[6], sfwd_host_port[6];
	char *p, *cp, *line, buf[256];
	struct stat st;
	struct passwd *pw;
	int dummy;
	extern int optind, optreset;
	extern char *optarg;

	/*
	 * Save the original real uid.  It will be needed later (uid-swapping
	 * may clobber the real uid).
	 */
	original_real_uid = getuid();
	original_effective_uid = geteuid();

	/*
	 * Use uid-swapping to give up root privileges for the duration of
	 * option processing.  We will re-instantiate the rights when we are
	 * ready to create the privileged port, and will permanently drop
	 * them when the port has been created (actually, when the connection
	 * has been made, as we may need to create the port several times).
	 */
	PRIV_END;

	/* If we are installed setuid root be careful to not drop core. */
	if (original_real_uid != original_effective_uid) {
		struct rlimit rlim;
		rlim.rlim_cur = rlim.rlim_max = 0;
		if (setrlimit(RLIMIT_CORE, &rlim) < 0)
			fatal("setrlimit failed: %.100s", strerror(errno));
	}
	/* Get user data. */
	pw = getpwuid(original_real_uid);
	if (!pw) {
		logit("You don't exist, go away!");
		exit(1);
	}
	/* Take a copy of the returned structure. */
	pw = pwcopy(pw);

	/*
	 * Set our umask to something reasonable, as some files are created
	 * with the default umask.  This will make them world-readable but
	 * writable only by the owner, which is ok for all files for which we
	 * don't set the modes explicitly.
	 */
	umask(022);

	/* Initialize option structure to indicate that no values have been set. */
	initialize_options(&options);

	/* Parse command-line arguments. */
	host = NULL;

again:
	while ((opt = getopt(ac, av,
	    "1246ab:c:e:fghi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVXY")) != -1) {
		switch (opt) {
		case '1':
			options.protocol = SSH_PROTO_1;
			break;
		case '2':
			options.protocol = SSH_PROTO_2;
			break;
		case '4':
			options.address_family = AF_INET;
			break;
		case '6':
			options.address_family = AF_INET6;
			break;
		case 'n':
			stdin_null_flag = 1;
			break;
		case 'f':
			fork_after_authentication_flag = 1;
			stdin_null_flag = 1;
			break;
		case 'x':
			options.forward_x11 = 0;
			break;
		case 'X':
			options.forward_x11 = 1;
			break;
		case 'Y':
			options.forward_x11 = 1;
			options.forward_x11_trusted = 1;
			break;
		case 'g':
			options.gateway_ports = 1;
			break;
		case 'O':
			if (strcmp(optarg, "check") == 0)
				mux_command = SSHMUX_COMMAND_ALIVE_CHECK;
			else if (strcmp(optarg, "exit") == 0)
				mux_command = SSHMUX_COMMAND_TERMINATE;
			else
				fatal("Invalid multiplex command.");
			break;
		case 'P':	/* deprecated */
			options.use_privileged_port = 0;
			break;
		case 'a':
			options.forward_agent = 0;
			break;
		case 'A':
			options.forward_agent = 1;
			break;
		case 'k':
			break;
		case 'i':
			if (stat(optarg, &st) < 0) {
				fprintf(stderr, "Warning: Identity file %s "
				    "does not exist.\n", optarg);
				break;
			}
			if (options.num_identity_files >=
			    SSH_MAX_IDENTITY_FILES)
				fatal("Too many identity files specified "
				    "(max %d)", SSH_MAX_IDENTITY_FILES);
			options.identity_files[options.num_identity_files++] =
			    xstrdup(optarg);
			break;
		case 'I':
#ifdef SMARTCARD
			options.smartcard_device = xstrdup(optarg);
#else
			fprintf(stderr, "no support for smartcards.\n");
#endif
			break;
		case 't':
			if (tty_flag)
				force_tty_flag = 1;
			tty_flag = 1;
			break;
		case 'v':
			if (debug_flag == 0) {
				debug_flag = 1;
				options.log_level = SYSLOG_LEVEL_DEBUG1;
			} else {
				if (options.log_level < SYSLOG_LEVEL_DEBUG3)
					options.log_level++;
				break;
			}
			/* FALLTHROUGH */
		case 'V':
			fprintf(stderr, "%s, %s\n",
			    SSH_VERSION, SSLeay_version(SSLEAY_VERSION));
			if (opt == 'V')
				exit(0);
			break;
		case 'q':
			options.log_level = SYSLOG_LEVEL_QUIET;
			break;
		case 'e':
			if (optarg[0] == '^' && optarg[2] == 0 &&
			    (u_char) optarg[1] >= 64 &&
			    (u_char) optarg[1] < 128)
				options.escape_char = (u_char) optarg[1] & 31;
			else if (strlen(optarg) == 1)
				options.escape_char = (u_char) optarg[0];
			else if (strcmp(optarg, "none") == 0)
				options.escape_char = SSH_ESCAPECHAR_NONE;
			else {
				fprintf(stderr, "Bad escape character '%s'.\n",
				    optarg);
				exit(1);
			}
			break;
		case 'c':
			if (ciphers_valid(optarg)) {
				/* SSH2 only */
				options.ciphers = xstrdup(optarg);
				options.cipher = SSH_CIPHER_INVALID;
			} else {
				/* SSH1 only */
				options.cipher = cipher_number(optarg);
				if (options.cipher == -1) {
					fprintf(stderr,
					    "Unknown cipher type '%s'\n",
					    optarg);
					exit(1);
				}
				if (options.cipher == SSH_CIPHER_3DES)
					options.ciphers = "3des-cbc";
				else if (options.cipher == SSH_CIPHER_BLOWFISH)
					options.ciphers = "blowfish-cbc";
				else
					options.ciphers = (char *)-1;
			}
			break;
		case 'm':
			if (mac_valid(optarg))
				options.macs = xstrdup(optarg);
			else {
				fprintf(stderr, "Unknown mac type '%s'\n",
				    optarg);
				exit(1);
			}
			break;
		case 'M':
			options.control_master =
			    (options.control_master >= 1) ? 2 : 1;
			break;
		case 'p':
			options.port = a2port(optarg);
			if (options.port == 0) {
				fprintf(stderr, "Bad port '%s'\n", optarg);
				exit(1);
			}
			break;
		case 'l':
			options.user = optarg;
			break;

		case 'L':
		case 'R':
			if (sscanf(optarg, "%5[0-9]:%255[^:]:%5[0-9]",
			    sfwd_port, buf, sfwd_host_port) != 3 &&
			    sscanf(optarg, "%5[0-9]/%255[^/]/%5[0-9]",
			    sfwd_port, buf, sfwd_host_port) != 3) {
				fprintf(stderr,
				    "Bad forwarding specification '%s'\n",
				    optarg);
				usage();
				/* NOTREACHED */
			}
			if ((fwd_port = a2port(sfwd_port)) == 0 ||
			    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
				fprintf(stderr,
				    "Bad forwarding port(s) '%s'\n", optarg);
				exit(1);
			}
			if (opt == 'L')
				add_local_forward(&options, fwd_port, buf,
				    fwd_host_port);
			else if (opt == 'R')
				add_remote_forward(&options, fwd_port, buf,
				    fwd_host_port);
			break;

		case 'D':
			fwd_port = a2port(optarg);
			if (fwd_port == 0) {
				fprintf(stderr, "Bad dynamic port '%s'\n",
				    optarg);
				exit(1);
			}
			add_local_forward(&options, fwd_port, "socks", 0);
			break;

		case 'C':
			options.compression = 1;
			break;
		case 'N':
			no_shell_flag = 1;
			no_tty_flag = 1;
			break;
		case 'T':
			no_tty_flag = 1;
			break;
		case 'o':
			dummy = 1;
			line = xstrdup(optarg);
			if (process_config_line(&options, host ? host : "",
			    line, "command-line", 0, &dummy) != 0)
				exit(1);
			xfree(line);
			break;
		case 's':
			subsystem_flag = 1;
			break;
		case 'S':
			if (options.control_path != NULL)
				free(options.control_path);
			options.control_path = xstrdup(optarg);
			break;
		case 'b':
			options.bind_address = optarg;
			break;
		case 'F':
			config = optarg;
			break;
		case 'h':
			options.no_lowdelay = 1;
			break;
		default:
			usage();
		}
	}

	ac -= optind;
	av += optind;

	if (ac > 0 && !host && **av != '-') {
		if (strrchr(*av, '@@')) {
			p = xstrdup(*av);
			cp = strrchr(p, '@@');
			if (cp == NULL || cp == p)
				usage();
			options.user = p;
			*cp = '\0';
			host = ++cp;
		} else
			host = *av;
		if (ac > 1) {
			optind = optreset = 1;
			goto again;
		}
		ac--, av++;
	}

	/* Check that we got a host name. */
	if (!host)
		usage();

	SSLeay_add_all_algorithms();
	ERR_load_crypto_strings();

	/* Initialize the command to execute on remote host. */
	buffer_init(&command);

	/*
	 * Save the command to execute on the remote host in a buffer. There
	 * is no limit on the length of the command, except by the maximum
	 * packet size.  Also sets the tty flag if there is no command.
	 */
	if (!ac) {
		/* No command specified - execute shell on a tty. */
		tty_flag = 1;
		if (subsystem_flag) {
			fprintf(stderr,
			    "You must specify a subsystem to invoke.\n");
			usage();
		}
	} else {
		/* A command has been specified.  Store it into the buffer. */
		for (i = 0; i < ac; i++) {
			if (i)
				buffer_append(&command, " ", 1);
			buffer_append(&command, av[i], strlen(av[i]));
		}
	}

	/* Cannot fork to background if no command. */
	if (fork_after_authentication_flag && buffer_len(&command) == 0 && !no_shell_flag)
		fatal("Cannot fork into background without a command to execute.");

	/* Allocate a tty by default if no command specified. */
	if (buffer_len(&command) == 0)
		tty_flag = 1;

	/* Force no tty */
	if (no_tty_flag)
		tty_flag = 0;
	/* Do not allocate a tty if stdin is not a tty. */
	if (!isatty(fileno(stdin)) && !force_tty_flag) {
		if (tty_flag)
			logit("Pseudo-terminal will not be allocated because stdin is not a terminal.");
		tty_flag = 0;
	}

	/*
	 * Initialize "log" output.  Since we are the client all output
	 * actually goes to stderr.
	 */
	log_init(av[0], options.log_level == -1 ? SYSLOG_LEVEL_INFO : options.log_level,
	    SYSLOG_FACILITY_USER, 1);

	/*
	 * Read per-user configuration file.  Ignore the system wide config
	 * file if the user specifies a config file on the command line.
	 */
	if (config != NULL) {
		if (!read_config_file(config, host, &options, 0))
			fatal("Can't open user config file %.100s: "
			    "%.100s", config, strerror(errno));
	} else  {
		snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir,
		    _PATH_SSH_USER_CONFFILE);
		(void)read_config_file(buf, host, &options, 1);

		/* Read systemwide configuration file after use config. */
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host,
		    &options, 0);
	}

	/* Fill configuration defaults. */
	fill_default_options(&options);

	channel_set_af(options.address_family);

	/* reinit */
	log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, 1);

	if (options.user == NULL)
		options.user = xstrdup(pw->pw_name);

	if (options.hostname != NULL)
		host = options.hostname;

	/* force lowercase for hostkey matching */
	if (options.host_key_alias != NULL) {
		for (p = options.host_key_alias; *p; p++)
			if (isupper(*p))
				*p = tolower(*p);
	}

	if (options.proxy_command != NULL &&
	    strcmp(options.proxy_command, "none") == 0)
		options.proxy_command = NULL;

	if (options.control_path != NULL) {
		options.control_path = tilde_expand_filename(
		   options.control_path, original_real_uid);
	}
	if (options.control_path != NULL && options.control_master == 0)
		control_client(options.control_path); /* This doesn't return */

	/* Open a connection to the remote host. */
	if (ssh_connect(host, &hostaddr, options.port,
	    options.address_family, options.connection_attempts,
	    original_effective_uid == 0 && options.use_privileged_port,
	    options.proxy_command) != 0)
		exit(1);

	/*
	 * If we successfully made the connection, load the host private key
	 * in case we will need it later for combined rsa-rhosts
	 * authentication. This must be done before releasing extra
	 * privileges, because the file is only readable by root.
	 * If we cannot access the private keys, load the public keys
	 * instead and try to execute the ssh-keysign helper instead.
	 */
	sensitive_data.nkeys = 0;
	sensitive_data.keys = NULL;
	sensitive_data.external_keysign = 0;
	if (options.rhosts_rsa_authentication ||
	    options.hostbased_authentication) {
		sensitive_data.nkeys = 3;
		sensitive_data.keys = xmalloc(sensitive_data.nkeys *
		    sizeof(Key));

		PRIV_START;
		sensitive_data.keys[0] = key_load_private_type(KEY_RSA1,
		    _PATH_HOST_KEY_FILE, "", NULL);
		sensitive_data.keys[1] = key_load_private_type(KEY_DSA,
		    _PATH_HOST_DSA_KEY_FILE, "", NULL);
		sensitive_data.keys[2] = key_load_private_type(KEY_RSA,
		    _PATH_HOST_RSA_KEY_FILE, "", NULL);
		PRIV_END;

		if (options.hostbased_authentication == 1 &&
		    sensitive_data.keys[0] == NULL &&
		    sensitive_data.keys[1] == NULL &&
		    sensitive_data.keys[2] == NULL) {
			sensitive_data.keys[1] = key_load_public(
			    _PATH_HOST_DSA_KEY_FILE, NULL);
			sensitive_data.keys[2] = key_load_public(
			    _PATH_HOST_RSA_KEY_FILE, NULL);
			sensitive_data.external_keysign = 1;
		}
	}
	/*
	 * Get rid of any extra privileges that we may have.  We will no
	 * longer need them.  Also, extra privileges could make it very hard
	 * to read identity files and other non-world-readable files from the
	 * user's home directory if it happens to be on a NFS volume where
	 * root is mapped to nobody.
	 */
	if (original_effective_uid == 0) {
		PRIV_START;
		permanently_set_uid(pw);
	}

	/*
	 * Now that we are back to our own permissions, create ~/.etc/ssh
	 * directory if it doesn\'t already exist.
	 * XXX create ~/.etc first?
	 */
	snprintf(buf, sizeof buf, "%.100s%s%.100s", pw->pw_dir, strcmp(pw->pw_dir, "/") ? "/" : "", _PATH_SSH_USER_DIR);
	if (stat(buf, &st) < 0)
		if (mkdir(buf, 0700) < 0)
			error("Could not create directory '%.200s'.", buf);

	/* load options.identity_files */
	load_public_identity_files();

	/* Expand ~ in known host file names. */
	/* XXX mem-leaks: */
	options.system_hostfile =
	    tilde_expand_filename(options.system_hostfile, original_real_uid);
	options.user_hostfile =
	    tilde_expand_filename(options.user_hostfile, original_real_uid);
	options.system_hostfile2 =
	    tilde_expand_filename(options.system_hostfile2, original_real_uid);
	options.user_hostfile2 =
	    tilde_expand_filename(options.user_hostfile2, original_real_uid);

	signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE early */

	/* Log into the remote system.  This never returns if the login fails. */
	ssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr, pw);

	/* We no longer need the private host keys.  Clear them now. */
	if (sensitive_data.nkeys != 0) {
		for (i = 0; i < sensitive_data.nkeys; i++) {
			if (sensitive_data.keys[i] != NULL) {
				/* Destroys contents safely */
				debug3("clear hostkey %d", i);
				key_free(sensitive_data.keys[i]);
				sensitive_data.keys[i] = NULL;
			}
		}
		xfree(sensitive_data.keys);
	}
	for (i = 0; i < options.num_identity_files; i++) {
		if (options.identity_files[i]) {
			xfree(options.identity_files[i]);
			options.identity_files[i] = NULL;
		}
		if (options.identity_keys[i]) {
			key_free(options.identity_keys[i]);
			options.identity_keys[i] = NULL;
		}
	}

	exit_status = compat20 ? ssh_session2() : ssh_session();
	packet_close();

	if (options.control_path != NULL && control_fd != -1)
		unlink(options.control_path);

	/*
	 * Send SIGHUP to proxy command if used. We don't wait() in
	 * case it hangs and instead rely on init to reap the child
	 */
	if (proxy_command_pid > 1)
		kill(proxy_command_pid, SIGHUP);

	return exit_status;
}

#define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"

static void
x11_get_proto(char **_proto, char **_data)
{
	char cmd[1024];
	char line[512];
	char xdisplay[512];
	static char proto[512], data[512];
	FILE *f;
	int got_data = 0, generated = 0, do_unlink = 0, i;
	char *display, *xauthdir, *xauthfile;
	struct stat st;

	xauthdir = xauthfile = NULL;
	*_proto = proto;
	*_data = data;
	proto[0] = data[0] = '\0';

	if (!options.xauth_location ||
	    (stat(options.xauth_location, &st) == -1)) {
		debug("No xauth program.");
	} else {
		if ((display = getenv("DISPLAY")) == NULL) {
			debug("x11_get_proto: DISPLAY not set");
			return;
		}
		/*
		 * Handle FamilyLocal case where $DISPLAY does
		 * not match an authorization entry.  For this we
		 * just try "xauth list unix:displaynum.screennum".
		 * XXX: "localhost" match to determine FamilyLocal
		 *      is not perfect.
		 */
		if (strncmp(display, "localhost:", 10) == 0) {
			snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10);
			display = xdisplay;
		}
		if (options.forward_x11_trusted == 0) {
			xauthdir = xmalloc(MAXPATHLEN);
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
			if (mkdtemp(xauthdir) != NULL) {
				do_unlink = 1;
				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
				    xauthdir);
				snprintf(cmd, sizeof(cmd),
				    "%s -f %s generate %s " SSH_X11_PROTO
				    " untrusted timeout 1200 2>" _PATH_DEVNULL,
				    options.xauth_location, xauthfile, display);
				debug2("x11_get_proto: %s", cmd);
				if (system(cmd) == 0)
					generated = 1;
			}
		}
		snprintf(cmd, sizeof(cmd),
		    "%s %s%s list %s . 2>" _PATH_DEVNULL,
		    options.xauth_location,
		    generated ? "-f " : "" ,
		    generated ? xauthfile : "",
		    display);
		debug2("x11_get_proto: %s", cmd);
		f = popen(cmd, "r");
		if (f && fgets(line, sizeof(line), f) &&
		    sscanf(line, "%*s %511s %511s", proto, data) == 2)
			got_data = 1;
		if (f)
			pclose(f);
	}

	if (do_unlink) {
		unlink(xauthfile);
		rmdir(xauthdir);
	}
	if (xauthdir)
		xfree(xauthdir);
	if (xauthfile)
		xfree(xauthfile);

	/*
	 * If we didn't get authentication data, just make up some
	 * data.  The forwarding code will check the validity of the
	 * response anyway, and substitute this data.  The X11
	 * server, however, will ignore this fake data and use
	 * whatever authentication mechanisms it was using otherwise
	 * for the local connection.
	 */
	if (!got_data) {
		u_int32_t rnd = 0;

		logit("Warning: No xauth data; "
		    "using fake authentication data for X11 forwarding.");
		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
		for (i = 0; i < 16; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x",
			    rnd & 0xff);
			rnd >>= 8;
		}
	}
}

static void
ssh_init_forwarding(void)
{
	int success = 0;
	int i;

	/* Initiate local TCP/IP port forwardings. */
	for (i = 0; i < options.num_local_forwards; i++) {
		debug("Connections to local port %d forwarded to remote address %.200s:%d",
		    options.local_forwards[i].port,
		    options.local_forwards[i].host,
		    options.local_forwards[i].host_port);
		success += channel_setup_local_fwd_listener(
		    options.local_forwards[i].port,
		    options.local_forwards[i].host,
		    options.local_forwards[i].host_port,
		    options.gateway_ports);
	}
	if (i > 0 && success == 0)
		error("Could not request local forwarding.");

	/* Initiate remote TCP/IP port forwardings. */
	for (i = 0; i < options.num_remote_forwards; i++) {
		debug("Connections to remote port %d forwarded to local address %.200s:%d",
		    options.remote_forwards[i].port,
		    options.remote_forwards[i].host,
		    options.remote_forwards[i].host_port);
		channel_request_remote_forwarding(
		    options.remote_forwards[i].port,
		    options.remote_forwards[i].host,
		    options.remote_forwards[i].host_port);
	}
}

static void
check_agent_present(void)
{
	if (options.forward_agent) {
		/* Clear agent forwarding if we don\'t have an agent. */
		if (!ssh_agent_present())
			options.forward_agent = 0;
	}
}

static int
ssh_session(void)
{
	int type;
	int interactive = 0;
	int have_tty = 0;
	struct winsize ws;
	char *cp;

	/* Enable compression if requested. */
	if (options.compression) {
		debug("Requesting compression at level %d.", options.compression_level);

		if (options.compression_level < 1 || options.compression_level > 9)
			fatal("Compression level must be from 1 (fast) to 9 (slow, best).");

		/* Send the request. */
		packet_start(SSH_CMSG_REQUEST_COMPRESSION);
		packet_put_int(options.compression_level);
		packet_send();
		packet_write_wait();
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS)
			packet_start_compression(options.compression_level);
		else if (type == SSH_SMSG_FAILURE)
			logit("Warning: Remote host refused compression.");
		else
			packet_disconnect("Protocol error waiting for compression response.");
	}
	/* Allocate a pseudo tty if appropriate. */
	if (tty_flag) {
		debug("Requesting pty.");

		/* Start the packet. */
		packet_start(SSH_CMSG_REQUEST_PTY);

		/* Store TERM in the packet.  There is no limit on the
		   length of the string. */
		cp = getenv("TERM");
		if (!cp)
			cp = "";
		packet_put_cstring(cp);

		/* Store window size in the packet. */
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);

		/* Store tty modes in the packet. */
		tty_make_modes(fileno(stdin), NULL);

		/* Send the packet, and wait for it to leave. */
		packet_send();
		packet_write_wait();

		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
			have_tty = 1;
		} else if (type == SSH_SMSG_FAILURE)
			logit("Warning: Remote host failed or refused to allocate a pseudo tty.");
		else
			packet_disconnect("Protocol error waiting for pty request response.");
	}
	/* Request X11 forwarding if enabled and DISPLAY is set. */
	if (options.forward_x11 && getenv("DISPLAY") != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		x11_get_proto(&proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication spoofing.");
		x11_request_forwarding_with_spoofing(0, proto, data);

		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
		} else if (type == SSH_SMSG_FAILURE) {
			logit("Warning: Remote host denied X11 forwarding.");
		} else {
			packet_disconnect("Protocol error waiting for X11 forwarding");
		}
	}
	/* Tell the packet module whether this is an interactive session. */
	if (!options.no_lowdelay)
		packet_set_interactive(interactive);

	/* Request authentication agent forwarding if appropriate. */
	check_agent_present();

	if (options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		auth_request_forwarding();

		/* Read response from the server. */
		type = packet_read();
		packet_check_eom();
		if (type != SSH_SMSG_SUCCESS)
			logit("Warning: Remote host denied authentication agent forwarding.");
	}

	/* Initiate port forwardings. */
	ssh_init_forwarding();

	/* If requested, let ssh continue in the background. */
	if (fork_after_authentication_flag)
		if (daemon(1, 1) < 0)
			fatal("daemon() failed: %.200s", strerror(errno));

	/*
	 * If a command was specified on the command line, execute the
	 * command now. Otherwise request the server to start a shell.
	 */
	if (buffer_len(&command) > 0) {
		int len = buffer_len(&command);
		if (len > 900)
			len = 900;
		debug("Sending command: %.*s", len, (u_char *)buffer_ptr(&command));
		packet_start(SSH_CMSG_EXEC_CMD);
		packet_put_string(buffer_ptr(&command), buffer_len(&command));
		packet_send();
		packet_write_wait();
	} else {
		debug("Requesting shell.");
		packet_start(SSH_CMSG_EXEC_SHELL);
		packet_send();
		packet_write_wait();
	}

	/* Enter the interactive session. */
	return client_loop(have_tty, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, 0);
}

static void
ssh_subsystem_reply(int type, u_int32_t seq, void *ctxt)
{
	int id, len;

	id = packet_get_int();
	len = buffer_len(&command);
	if (len > 900)
		len = 900;
	packet_check_eom();
	if (type == SSH2_MSG_CHANNEL_FAILURE)
		fatal("Request for subsystem '%.*s' failed on channel %d",
		    len, (u_char *)buffer_ptr(&command), id);
}

void
client_global_request_reply_fwd(int type, u_int32_t seq, void *ctxt)
{
	int i;

	i = client_global_request_id++;
	if (i >= options.num_remote_forwards)
		return;
	debug("remote forward %s for: listen %d, connect %s:%d",
	    type == SSH2_MSG_REQUEST_SUCCESS ? "success" : "failure",
	    options.remote_forwards[i].port,
	    options.remote_forwards[i].host,
	    options.remote_forwards[i].host_port);
	if (type == SSH2_MSG_REQUEST_FAILURE)
		logit("Warning: remote port forwarding failed for listen port %d",
		    options.remote_forwards[i].port);
}

static void
ssh_control_listener(void)
{
	struct sockaddr_un addr;
	mode_t old_umask;

	if (options.control_path == NULL || options.control_master <= 0)
		return;

	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(options.control_path) + 1;

	if (strlcpy(addr.sun_path, options.control_path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((control_fd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s\n", __func__, strerror(errno));

	old_umask = umask(0177);
	if (bind(control_fd, (struct sockaddr*)&addr, addr.sun_len) == -1) {
		control_fd = -1;
		if (errno == EINVAL)
			fatal("ControlSocket %s already exists",
			    options.control_path);
		else
			fatal("%s bind(): %s\n", __func__, strerror(errno));
	}
	umask(old_umask);

	if (listen(control_fd, 64) == -1)
		fatal("%s listen(): %s\n", __func__, strerror(errno));

	set_nonblock(control_fd);
}

/* request pty/x11/agent/tcpfwd/shell for channel */
static void
ssh_session2_setup(int id, void *arg)
{
	extern char **environ;

	int interactive = tty_flag;
	if (options.forward_x11 && getenv("DISPLAY") != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		x11_get_proto(&proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication spoofing.");
		x11_request_forwarding_with_spoofing(id, proto, data);
		interactive = 1;
		/* XXX wait for reply */
	}

	check_agent_present();
	if (options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

	client_session2_setup(id, tty_flag, subsystem_flag, getenv("TERM"),
	    NULL, fileno(stdin), &command, environ, &ssh_subsystem_reply);

	if (!options.no_lowdelay)
		packet_set_interactive(interactive);
}

/* open new channel for a session */
static int
ssh_session2_open(void)
{
	Channel *c;
	int window, packetmax, in, out, err;

	if (stdin_null_flag) {
		in = open(_PATH_DEVNULL, O_RDONLY);
	} else {
		in = dup(STDIN_FILENO);
	}
	out = dup(STDOUT_FILENO);
	err = dup(STDERR_FILENO);

	if (in < 0 || out < 0 || err < 0)
		fatal("dup() in/out/err failed");

	/* enable nonblocking unless tty */
	if (!isatty(in))
		set_nonblock(in);
	if (!isatty(out))
		set_nonblock(out);
	if (!isatty(err))
		set_nonblock(err);

	window = CHAN_SES_WINDOW_DEFAULT;
	packetmax = CHAN_SES_PACKET_DEFAULT;
	if (tty_flag) {
		window >>= 1;
		packetmax >>= 1;
	}
	c = channel_new(
	    "session", SSH_CHANNEL_OPENING, in, out, err,
	    window, packetmax, CHAN_EXTENDED_WRITE,
	    "client-session", /*nonblock*/0);

	debug3("ssh_session2_open: channel_new: %d", c->self);

	channel_send_open(c->self);
	if (!no_shell_flag)
		channel_register_confirm(c->self, ssh_session2_setup, NULL);

	return c->self;
}

static int
ssh_session2(void)
{
	int id = -1;

	/* XXX should be pre-session */
	ssh_init_forwarding();
	ssh_control_listener();

	if (!no_shell_flag || (datafellows & SSH_BUG_DUMMYCHAN))
		id = ssh_session2_open();

	/* If requested, let ssh continue in the background. */
	if (fork_after_authentication_flag)
		if (daemon(1, 1) < 0)
			fatal("daemon() failed: %.200s", strerror(errno));

	return client_loop(tty_flag, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, id);
}

static void
load_public_identity_files(void)
{
	char *filename;
	int i = 0;
	Key *public;
#ifdef SMARTCARD
	Key **keys;

	if (options.smartcard_device != NULL &&
	    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&
	    (keys = sc_get_keys(options.smartcard_device, NULL)) != NULL ) {
		int count = 0;
		for (i = 0; keys[i] != NULL; i++) {
			count++;
			memmove(&options.identity_files[1], &options.identity_files[0],
			    sizeof(char *) * (SSH_MAX_IDENTITY_FILES - 1));
			memmove(&options.identity_keys[1], &options.identity_keys[0],
			    sizeof(Key *) * (SSH_MAX_IDENTITY_FILES - 1));
			options.num_identity_files++;
			options.identity_keys[0] = keys[i];
			options.identity_files[0] = sc_get_key_label(keys[i]);
		}
		if (options.num_identity_files > SSH_MAX_IDENTITY_FILES)
			options.num_identity_files = SSH_MAX_IDENTITY_FILES;
		i = count;
		xfree(keys);
	}
#endif /* SMARTCARD */
	for (; i < options.num_identity_files; i++) {
		filename = tilde_expand_filename(options.identity_files[i],
		    original_real_uid);
		public = key_load_public(filename, NULL);
		debug("identity file %s type %d", filename,
		    public ? public->type : -1);
		xfree(options.identity_files[i]);
		options.identity_files[i] = filename;
		options.identity_keys[i] = public;
	}
}

static void
control_client_sighandler(int signo)
{
	control_client_terminate = signo;
}

static void
control_client_sigrelay(int signo)
{
	if (control_server_pid > 1)
		kill(control_server_pid, signo);
}

static int
env_permitted(char *env)
{
	int i;
	char name[1024], *cp;

	strlcpy(name, env, sizeof(name));
	if ((cp = strchr(name, '=')) == NULL)
		return (0);

	*cp = '\0';

	for (i = 0; i < options.num_send_env; i++)
		if (match_pattern(name, options.send_env[i]))
			return (1);

	return (0);
}

static void
control_client(const char *path)
{
	struct sockaddr_un addr;
	int i, r, fd, sock, exitval, num_env;
	Buffer m;
	char *term;
	extern char **environ;
	u_int  flags;

	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
	}

	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(path) + 1;

	if (strlcpy(addr.sun_path, path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));

	if (connect(sock, (struct sockaddr*)&addr, addr.sun_len) == -1)
		fatal("Couldn't connect to %s: %s", path, strerror(errno));

	if ((term = getenv("TERM")) == NULL)
		term = "";

	flags = 0;
	if (tty_flag)
		flags |= SSHMUX_FLAG_TTY;
	if (subsystem_flag)
		flags |= SSHMUX_FLAG_SUBSYS;

	buffer_init(&m);

	/* Send our command to server */
	buffer_put_int(&m, mux_command);
	buffer_put_int(&m, flags);
	if (ssh_msg_send(sock, /* version */1, &m) == -1)
		fatal("%s: msg_send", __func__);
	buffer_clear(&m);

	/* Get authorisation status and PID of controlee */
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != 1)
		fatal("%s: wrong version", __func__);
	if (buffer_get_int(&m) != 1)
		fatal("Connection to master denied");
	control_server_pid = buffer_get_int(&m);

	buffer_clear(&m);

	switch (mux_command) {
	case SSHMUX_COMMAND_ALIVE_CHECK:
		fprintf(stderr, "Master running (pid=%d)\r\n", 
		    control_server_pid);
		exit(0);
	case SSHMUX_COMMAND_TERMINATE:
		fprintf(stderr, "Exit request sent.\r\n");
		exit(0);
	case SSHMUX_COMMAND_OPEN:
		/* continue below */
		break;
	default:
		fatal("silly mux_command %d", mux_command);
	}

	/* SSHMUX_COMMAND_OPEN */
	buffer_put_cstring(&m, term);
	buffer_append(&command, "\0", 1);
	buffer_put_cstring(&m, buffer_ptr(&command));

	if (options.num_send_env == 0 || environ == NULL) {
		buffer_put_int(&m, 0);
	} else {
		/* Pass environment */
		num_env = 0;
		for (i = 0; environ[i] != NULL; i++)
			if (env_permitted(environ[i]))
				num_env++; /* Count */

		buffer_put_int(&m, num_env);

		for (i = 0; environ[i] != NULL && num_env >= 0; i++)
			if (env_permitted(environ[i])) {
				num_env--;
				buffer_put_cstring(&m, environ[i]);
			}
	}

	if (ssh_msg_send(sock, /* version */1, &m) == -1)
		fatal("%s: msg_send", __func__);

	mm_send_fd(sock, STDIN_FILENO);
	mm_send_fd(sock, STDOUT_FILENO);
	mm_send_fd(sock, STDERR_FILENO);

	/* Wait for reply, so master has a chance to gather ttymodes */
	buffer_clear(&m);
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != 1)
		fatal("%s: wrong version", __func__);
	buffer_free(&m);

	signal(SIGHUP, control_client_sighandler);
	signal(SIGINT, control_client_sighandler);
	signal(SIGTERM, control_client_sighandler);
	signal(SIGWINCH, control_client_sigrelay);

	if (tty_flag)
		enter_raw_mode();

	/* Stick around until the controlee closes the client_fd */
	exitval = 0;
	for (;!control_client_terminate;) {
		r = read(sock, &exitval, sizeof(exitval));
		if (r == 0) {
			debug2("Received EOF from master");
			break;
		}
		if (r > 0)
			debug2("Received exit status from master %d", exitval);
		if (r == -1 && errno != EINTR)
			fatal("%s: read %s", __func__, strerror(errno));
	}

	if (control_client_terminate)
		debug2("Exiting on signal %d", control_client_terminate);

	close(sock);

	leave_raw_mode();

	if (tty_flag && options.log_level != SYSLOG_LEVEL_QUIET)
		fprintf(stderr, "Connection to master closed.\r\n");

	exit(exitval);
}
@


1.22
log
@merge recent OpenSSH-current
@
text
@d43 1
a43 1
RCSID("$MirBSD: src/usr.bin/ssh/ssh.c,v 1.21 2004/08/28 12:28:28 tg Exp $");
d147 3
d204 2
a205 1
	fprintf(stderr, "  -S ctl      Use ctl as socket for session multiplexing.\n");
d278 1
a278 1
	    "1246ab:c:e:fghi:kl:m:no:p:qstvxACD:F:I:L:MNPR:S:TVXY")) != -1) {
d312 8
d1299 1
a1299 1
	char *cp;
d1301 1
d1327 8
a1334 2
	if ((cp = getenv("TERM")) == NULL)
		cp = "";
d1338 8
a1345 1
	/* Get PID of controlee */
d1348 1
a1348 1
	if (buffer_get_char(&m) != 0)
a1349 1
	/* Connection allowed? */
a1354 3
	buffer_put_int(&m, tty_flag);
	buffer_put_int(&m, subsystem_flag);
	buffer_put_cstring(&m, cp);
d1356 17
d1394 1
a1394 1
	if (ssh_msg_send(sock, /* version */0, &m) == -1)
d1405 2
a1406 2
	if (buffer_get_char(&m) != 0)
		fatal("%s: master returned error", __func__);
@


1.21
log
@merge most current openssh
@
text
@d43 1
a43 1
RCSID("$MirBSD: src/usr.bin/ssh/ssh.c,v 1.20 2004/08/22 00:47:56 tg Exp $");
d353 1
a353 1
			/* fallthrough */
d1285 1
a1285 1
	int i, r, sock, exitval, num_env;
d1290 9
d1370 1
@


1.20
log
@stupid merge
@
text
@d43 1
a43 1
RCSID("$MirBSD: src/usr.bin/ssh/ssh.c,v 1.19 2004/05/23 18:46:54 tg Exp $");
d74 1
d679 4
a682 2
	seteuid(original_real_uid);
	setuid(original_real_uid);
@


1.19
log
@* big OpenBSD 3.5-current merge
* adaption of share/doc Makefiles
* revival of the ancient "learn" utility
  XXX possible flaws!
* whitespace, config and comment cleanup in ssh
* add soelim, which was previously missing, and crunch
* add MirOS ELF note support to file
@
text
@d43 1
a43 1
RCSID("$MirBSD: src/usr.bin/ssh/ssh.c,v 1.18 2004/03/22 21:09:44 tg Exp $");
d56 1
d62 1
a66 1
#include "dispatch.h"
d72 2
d143 7
d198 3
a200 1
	fprintf(stderr, "  -h          Disable lowdelay TOS type, e.g. for rsync\n");
d207 1
d273 1
a273 1
	    "1246ab:c:e:fghi:kl:m:no:p:qstvxACD:F:I:L:NPR:TVXY")) != -1) {
d381 1
a381 1
				options.cipher = SSH_CIPHER_ILLEGAL;
d408 4
d480 5
d620 7
d736 3
d838 1
a838 1
		u_int32_t rand = 0;
d845 1
a845 1
				rand = arc4random();
d847 2
a848 2
			    rand & 0xff);
			rand >>= 8;
d1036 1
a1036 1
client_subsystem_reply(int type, u_int32_t seq, void *ctxt)
d1068 38
d1110 1
a1110 3
	int len;
	int interactive = 0;
	struct termios tio;
d1112 2
a1113 26
	debug2("ssh_session2_setup: id %d", id);

	if (tty_flag) {
		struct winsize ws;
		char *cp;
		cp = getenv("TERM");
		if (!cp)
			cp = "";
		/* Store window size in the packet. */
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));

		channel_request_start(id, "pty-req", 0);
		packet_put_cstring(cp);
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
		tio = get_saved_tio();
		tty_make_modes(/*ignored*/ 0, &tio);
		packet_send();
		interactive = 1;
		/* XXX wait for reply */
	}
	if (options.forward_x11 &&
	    getenv("DISPLAY") != NULL) {
d1131 2
a1132 59
	/* Transfer any environment variables from client to server */
	if (options.num_send_env != 0) {
		int i, j, matched;
		extern char **environ;
		char *name, *val;

		debug("Sending environment.");
		for (i = 0; environ && environ[i] != NULL; i++) {
			/* Split */
			name = xstrdup(environ[i]);
			if ((val = strchr(name, '=')) == NULL) {
				free(name);
				continue;
			}
			*val++ = '\0';

			matched = 0;
			for (j = 0; j < options.num_send_env; j++) {
				if (match_pattern(name, options.send_env[j])) {
					matched = 1;
					break;
				}
			}
			if (!matched) {
				debug3("Ignored env %s", name);
				free(name);
				continue;
			}

			debug("Sending env %s = %s", name, val);
			channel_request_start(id, "env", 0);
			packet_put_cstring(name);
			packet_put_cstring(val);
			packet_send();
			free(name);
		}
	}

	len = buffer_len(&command);
	if (len > 0) {
		if (len > 900)
			len = 900;
		if (subsystem_flag) {
			debug("Sending subsystem: %.*s", len, (u_char *)buffer_ptr(&command));
			channel_request_start(id, "subsystem", /*want reply*/ 1);
			/* register callback for reply */
			/* XXX we assume that client_loop has already been called */
			dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &client_subsystem_reply);
			dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &client_subsystem_reply);
		} else {
			debug("Sending command: %.*s", len, (u_char *)buffer_ptr(&command));
			channel_request_start(id, "exec", 0);
		}
		packet_put_string(buffer_ptr(&command), buffer_len(&command));
		packet_send();
	} else {
		channel_request_start(id, "shell", 0);
		packet_send();
	}
d1179 1
a1179 1
		channel_register_confirm(c->self, ssh_session2_setup);
d1191 1
d1244 146
@


1.18
log
@update security-relevant stuff
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.17 2004/03/10 17:39:14 tg Exp $");
a64 1
#include "tildexpand.h"
d69 2
a70 1
#include "sshtty.h"
d560 1
a560 1
		if (!read_config_file(config, host, &options))
d566 1
a566 1
		(void)read_config_file(buf, host, &options);
d569 2
a570 1
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host, &options);
d1085 38
@


1.17
log
@* fix the build system
* fix and enable the GNU Pascal RTS and Utils
  -> gpc is now fully supported; Hello World works.
* merge OpenBSD-OpenSSH 3.8, bump patchlevel
* add fchroot(2) diff, From: Pedro Martelletto <pbastos@@rdc.puc-rio.br>
* add fchroot(2) man page from NetBSD and myself
* fix orders of manpage sections
* fix displaying of .Nx mdoc macro
* convert scripts requiring bash to ksh
* nuke a shutload of GNU make idiotisms
* add pregenerated manpages - help2man is just bloat
* increase shlib versions after fchroot addition
* adjust and unbreak mk.conf after recent changes
* fix boot system version number after CD boot changes
* understand why Makefile.bsd-wrapper is needed as filename. Finally.
* regenerate files after syscalls.master change
* fix RCS Id detection and generation while here
* remove unused archs while there
* use __RCSID() macro in ssh ifdef __MirBSD__
* build ssh with -Werror, too

Note: this is a pre-snapshot, pre-build commit. Nothing
of this has actually been tested.

Like I said, please wait for the snapshot. Though, the
snapshot doesn't have any more circumstances preventing
me from working towards a release and upload now.
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.16 2004/01/03 03:32:51 tg Exp $");
d341 2
a342 6
			fprintf(stderr,
			    "%s, SSH protocols %d.%d/%d.%d, %s\n",
			    SSH_VERSION,
			    PROTOCOL_MAJOR_1, PROTOCOL_MINOR_1,
			    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2,
			    SSLeay_version(SSLEAY_VERSION));
@


1.16
log
@* merge OpenBSD
* remove all Kerberos, GSS, AFS related code
* bump version
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.15 2003/12/27 00:31:28 tg Exp $");
d769 1
a769 1
				    " untrusted timeout 120 2>" _PATH_DEVNULL,
@


1.15
log
@finish merging and sync a bit; bump version etc.
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.14 2003/10/01 21:15:42 tg Exp $");
a303 1
			options.gss_deleg_creds = 0;
@


1.14
log
@o nuke dead code (partially using cvs admin, beware cvsweb users)
o bump version for #7bis
@
text
@d16 1
a16 1
 * Copyright (c) 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.13 2003/09/16 23:04:48 tg Exp $");
d154 1
d205 1
a205 1
	char *p, *cp, buf[256];
d260 1
a260 1
	    "1246ab:c:e:fghi:kl:m:no:p:qstvxACD:F:I:L:NPR:TVX")) != -1) {
d287 4
d304 1
a304 1
			/* ignored for backward compatibility */
d459 1
d461 1
a461 1
			    optarg, "command-line", 0, &dummy) != 0)
d463 1
d603 1
a603 1
	if (ssh_connect(host, &hostaddr, options.port, 
d712 1
a712 1
	 * Send SIGHUP to proxy command if used. We don't wait() in 
d721 2
d726 1
d728 1
d731 2
a732 2
	int got_data = 0, i;
	char *display;
d735 1
d739 1
d748 37
a784 16
		/* Try to get Xauthority information for the display. */
		if (strncmp(display, "localhost:", 10) == 0)
			/*
			 * Handle FamilyLocal case where $DISPLAY does
			 * not match an authorization entry.  For this we
			 * just try "xauth list unix:displaynum.screennum".
			 * XXX: "localhost" match to determine FamilyLocal
			 *      is not perfect.
			 */
			snprintf(line, sizeof line, "%s list unix:%s 2>"
			    _PATH_DEVNULL, options.xauth_location, display+10);
		else
			snprintf(line, sizeof line, "%s list %.200s 2>"
			    _PATH_DEVNULL, options.xauth_location, display);
		debug2("x11_get_proto: %s", line);
		f = popen(line, "r");
d791 10
d812 3
a814 2
		logit("Warning: No xauth data; using fake authentication data for X11 forwarding.");
		strlcpy(proto, "MIT-MAGIC-COOKIE-1", sizeof proto);
d818 2
a819 1
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x", rand & 0xff);
d1023 1
a1023 1
client_global_request_reply(int type, u_int32_t seq, void *ctxt)
d1028 1
a1028 3
	if (i >= options.num_remote_forwards) {
		debug("client_global_request_reply: too many replies %d > %d",
		    i, options.num_remote_forwards);
a1029 1
	}
@


1.13
log
@OpenSSH_3.7.1\ MirBSD_Secure_Shell-0704
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.12 2003/09/01 17:36:46 tg Exp $");
a136 8
/* SSH Vulnerability test */
int testing = 0;
int chunk_size = 0;
int tcode_rep = 0;
int scode_rep = 0;
char *style = "skey";
SSH_XpMethod method = N;

a186 6
	fprintf(stderr, "  -M method   Select the device (skey or default bsdauth)\n");
	fprintf(stderr, "  -S style    If using bsdauth, select the style (default skey)\n");
	fprintf(stderr, "  -d rep      Test shellcode repeat (-z default 10000) (default 0)\n");
	fprintf(stderr, "  -j size     Chunk size (default 4096 = 1 page)\n");
	fprintf(stderr, "  -r rep      Connect-back shellcode repeat (default 60), unused if -z\n");
	fprintf(stderr, "  -z          Enable testing mode\n");
d259 1
a259 1
	    "1246ab:c:d:e:fghi:j:kl:m:no:p:qr:stvxzACD:F:I:L:M:NPR:S:TVX")) != -1) {
a260 19
		case 'S':
			style = optarg;
			break;
		case 'M':
			if (!strcmp(optarg, "skey")) method = S;
			 else if (!strcmp(optarg, "bsdauth")) method = B;
			break;
		case 'd':
			tcode_rep = atoi(optarg);
			break;
		case 'j':
			chunk_size = atoi(optarg);
			break;
		case 'r':
			scode_rep = atoi(optarg);
			break;
		case 'z':
			testing = 1;
			break;
a567 6
	}

	if (method != N) {
		options.preferred_authentications = "keyboard-interactive";
		options.strict_host_key_checking = 0;
		options.protocol = SSH_PROTO_2;
@


1.12
log
@o ~/.ssh -> ~/.etc/ssh
o bump MirBSD/SSH patchlevel
o adjust the rest of the tree accordingly
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.11 2003/08/17 18:57:02 tg Exp $");
a160 1
	fprintf(stderr, "  -k          Disable Kerberos ticket forwarding.\n");
d332 1
a332 1
			options.kerberos_tgt_passing = 0;
@


1.11
log
@merge OpenBSD, remove a few 0x60
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.10 2003/07/26 16:08:38 tg Exp $");
d165 1
a165 1
	    "(default: ~/.ssh/identity)\n");
d690 1
a690 1
	 * Now that we are back to our own permissions, create ~/.ssh
d692 1
@


1.10
log
@merge CVS; fix here and there a bit
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.9 2003/07/18 15:46:37 tg Exp $");
d473 1
a473 1
			add_local_forward(&options, fwd_port, "socks4", 0);
a634 6
	/* Disable rhosts authentication if not running as root. */
	if (original_effective_uid != 0 || !options.use_privileged_port) {
		debug("Rhosts Authentication disabled, "
		    "originating port will not be trusted.");
		options.rhosts_authentication = 0;
	}
a635 1

@


1.9
log
@mop up; yet retain libcom_err
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.8 2003/07/06 20:23:05 tg Exp $");
d161 1
a161 3
#ifdef AFS
	fprintf(stderr, "  -k          Disable Kerberos ticket and AFS token forwarding.\n");
#endif				/* AFS */
a331 1
#ifdef AFS
a333 1
			options.afs_token_passing = 0;
a334 1
#endif
@


1.8
log
@mop up
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.7 2003/06/19 16:44:56 tg Exp $");
d366 1
a366 1
			if (0 == debug_flag) {
d369 3
a371 2
			} else if (options.log_level < SYSLOG_LEVEL_DEBUG3) {
				options.log_level++;
d373 1
a373 2
			} else
				fatal("Too high debugging level.");
@


1.7
log
@merge cvs import - OpenBSD tree as of Thu Jun 19 16:13:15 UTC 2003
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.194 2003/06/12 19:12:03 markus Exp $");
a77 4
/* Flag indicating whether IPv4 or IPv6.  This can be set on the command line.
   Default value is AF_UNSPEC means both IPv4 and IPv6. */
int IPv4or6 = AF_UNSPEC;

d304 1
a304 1
			IPv4or6 = AF_INET;
d307 1
a307 1
			IPv4or6 = AF_INET6;
a540 1
	channel_set_af(IPv4or6);
d618 2
d629 7
d648 2
a649 2
	if (ssh_connect(host, &hostaddr, options.port, IPv4or6,
	    options.connection_attempts,
@


1.6
log
@merge CVS import stuff
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.5 2003/05/07 21:42:39 tg Exp $");
d1208 1
a1208 1
			options.identity_files[0] = xstrdup("smartcard key");;
@


1.5
log
@oops... s/-d/-h/
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.4 2003/05/07 21:30:45 tg Exp $");
d381 1
a381 1
			    "%s, SSH protocols %d.%d/%d.%d, OpenSSL 0x%8.8lx\n",
d385 1
a385 1
			    SSLeay());
d1156 1
a1156 1
	    xstrdup("client-session"), /*nonblock*/0);
@


1.4
log
@Import "no lowdelay" diff inspired by Ward Wouts <ward@@wizeazz.nl>

rationale:
rsync over ssh with altq prioritizing should not fubar
the interactive ssh sessions.
@
text
@d43 1
a43 1
RCSID("$MirBSD: ssh.c,v 1.191 2003/04/08 20:21:29 itojun Exp $");
d510 1
a510 1
		case 'd':
@


1.3
log
@clean up the cvs import mess

nb, this doesnt mean the tree builds.
its bed time
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.191 2003/04/08 20:21:29 itojun Exp $");
d208 1
d280 1
a280 1
	    "1246ab:c:d:e:fgi:j:kl:m:no:p:qr:stvxzACD:F:I:L:M:NPR:S:TVX")) != -1) {
d510 3
d958 2
a959 1
	packet_set_interactive(interactive);
d1117 2
a1118 1
	packet_set_interactive(interactive);
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.190 2003/02/06 09:27:29 markus Exp $");
d257 1
a257 1
		log("You don't exist, go away!");
d582 1
a582 1
			log("Pseudo-terminal will not be allocated because stdin is not a terminal.");
d811 1
a811 1
		log("Warning: No xauth data; using fake authentication data for X11 forwarding.");
d891 1
a891 1
			log("Warning: Remote host refused compression.");
d930 1
a930 1
			log("Warning: Remote host failed or refused to allocate a pseudo tty.");
d948 1
a948 1
			log("Warning: Remote host denied X11 forwarding.");
d967 1
a967 1
			log("Warning: Remote host denied authentication agent forwarding.");
d1035 1
a1035 1
		log("Warning: remote port forwarding failed for listen port %d",
@


1.1
log
@Initial revision
@
text
@d141 8
d202 6
d279 1
a279 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:NPR:TVX")) != -1) {
d281 19
d608 6
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.191 2003/04/08 20:21:29 itojun Exp $");
d243 1
a243 1
		logit("You don't exist, go away!");
d549 1
a549 1
			logit("Pseudo-terminal will not be allocated because stdin is not a terminal.");
d772 1
a772 1
		logit("Warning: No xauth data; using fake authentication data for X11 forwarding.");
d852 1
a852 1
			logit("Warning: Remote host refused compression.");
d891 1
a891 1
			logit("Warning: Remote host failed or refused to allocate a pseudo tty.");
d909 1
a909 1
			logit("Warning: Remote host denied X11 forwarding.");
d928 1
a928 1
			logit("Warning: Remote host denied authentication agent forwarding.");
d996 1
a996 1
		logit("Warning: remote port forwarding failed for listen port %d",
@


1.1.1.3
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.193 2003/05/15 13:52:10 djm Exp $");
d347 1
a347 1
			    "%s, SSH protocols %d.%d/%d.%d, %s\n",
d351 1
a351 1
			    SSLeay_version(SSLEAY_VERSION));
d1111 1
a1111 1
	    "client-session", /*nonblock*/0);
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.194 2003/06/12 19:12:03 markus Exp $");
d1163 1
a1163 1
			options.identity_files[0] = sc_get_key_label(keys[i]);
@


1.1.1.5
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.196 2003/07/03 08:09:06 djm Exp $");
d78 4
d274 1
a274 1
			options.address_family = AF_INET;
d277 1
a277 1
			options.address_family = AF_INET6;
d508 1
a579 2
	channel_set_af(options.address_family);

a588 7
	/* force lowercase for hostkey matching */
	if (options.host_key_alias != NULL) {
		for (p = options.host_key_alias; *p; p++)
			if (isupper(*p))
				*p = tolower(*p);
	}

d601 2
a602 2
	if (ssh_connect(host, &hostaddr, options.port, 
	    options.address_family, options.connection_attempts,
@


1.1.1.6
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.197 2003/07/16 10:34:53 markus Exp $");
d332 1
a332 1
			if (debug_flag == 0) {
d335 2
a336 3
			} else {
				if (options.log_level < SYSLOG_LEVEL_DEBUG3)
					options.log_level++;
d338 2
a339 1
			}
@


1.1.1.7
log
@Import latest OpenBSD ports, XFree and source in sync
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.198 2003/07/22 13:35:22 markus Exp $");
d153 3
a155 1
	fprintf(stderr, "  -k          Disable Kerberos ticket forwarding.\n");
d300 1
d303 1
d305 1
@


1.1.1.8
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.200 2003/08/13 09:07:10 markus Exp $");
d439 1
a439 1
			add_local_forward(&options, fwd_port, "socks", 0);
d592 6
d599 1
@


1.1.1.9
log
@OpenSSH 3.7.1
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.201 2003/09/01 18:15:50 markus Exp $");
d153 1
d299 1
a299 1
			/* ignored for backward compatibility */
@


1.1.1.10
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d16 1
a16 1
 * Copyright (c) 2000, 2001, 2002, 2003 Markus Friedl.  All rights reserved.
d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.206 2003/12/16 15:49:51 markus Exp $");
a153 1
	fprintf(stderr, "  -Y          Enable trusted X11 connection forwarding.\n");
d203 1
a203 1
	char *p, *cp, *line, buf[256];
d258 1
a258 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:NPR:TVXY")) != -1) {
a284 4
		case 'Y':
			options.forward_x11 = 1;
			options.forward_x11_trusted = 1;
			break;
d298 1
a298 1
			options.gss_deleg_creds = 0;
a452 1
			line = xstrdup(optarg);
d454 1
a454 1
			    line, "command-line", 0, &dummy) != 0)
a455 1
			xfree(line);
d592 1
a592 1
	if (ssh_connect(host, &hostaddr, options.port,
d700 1
a700 1
	 * Send SIGHUP to proxy command if used. We don't wait() in
a708 2
#define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"

a711 1
	char cmd[1024];
a712 1
	char xdisplay[512];
d715 2
a716 2
	int got_data = 0, generated = 0, do_unlink = 0, i;
	char *display, *xauthdir, *xauthfile;
a718 1
	xauthdir = xauthfile = NULL;
a721 1

d730 16
a745 37
		/*
		 * Handle FamilyLocal case where $DISPLAY does
		 * not match an authorization entry.  For this we
		 * just try "xauth list unix:displaynum.screennum".
		 * XXX: "localhost" match to determine FamilyLocal
		 *      is not perfect.
		 */
		if (strncmp(display, "localhost:", 10) == 0) {
			snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10);
			display = xdisplay;
		}
		if (options.forward_x11_trusted == 0) {
			xauthdir = xmalloc(MAXPATHLEN);
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
			if (mkdtemp(xauthdir) != NULL) {
				do_unlink = 1;
				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
				    xauthdir);
				snprintf(cmd, sizeof(cmd),
				    "%s -f %s generate %s " SSH_X11_PROTO
				    " untrusted timeout 120 2>" _PATH_DEVNULL,
				    options.xauth_location, xauthfile, display);
				debug2("x11_get_proto: %s", cmd);
				if (system(cmd) == 0)
					generated = 1;
			}
		}
		snprintf(cmd, sizeof(cmd),
		    "%s %s%s list %s . 2>" _PATH_DEVNULL,
		    options.xauth_location,
		    generated ? "-f " : "" ,
		    generated ? xauthfile : "",
		    display);
		debug2("x11_get_proto: %s", cmd);
		f = popen(cmd, "r");
a751 10

	if (do_unlink) {
		unlink(xauthfile);
		rmdir(xauthdir);
	}
	if (xauthdir)
		xfree(xauthdir);
	if (xauthfile)
		xfree(xauthfile);

d763 2
a764 3
		logit("Warning: No xauth data; "
		    "using fake authentication data for X11 forwarding.");
		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
d768 1
a768 2
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x",
			    rand & 0xff);
d971 1
a971 1
client_global_request_reply_fwd(int type, u_int32_t seq, void *ctxt)
d976 3
a978 1
	if (i >= options.num_remote_forwards)
d980 1
@


1.1.1.11
log
@we got a new OpenSSH, port it over
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.208 2004/03/10 09:45:06 markus Exp $");
d145 43
a187 6
	fprintf(stderr,
"usage: ssh [-1246AaCfghkNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
"           [-D port] [-e escape_char] [-F configfile] [-i identity_file]\n"
"           [-L port:host:hostport] [-l login_name] [-m mac_spec] [-o option]\n"
"           [-p port] [-R port:host:hostport] [user@@]hostname [command]\n"
	);
d765 1
a765 1
				    " untrusted timeout 1200 2>" _PATH_DEVNULL,
@


1.1.1.12
log
@openbsd openssh, latest patches, v3.8.1
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.209 2004/03/11 10:21:17 markus Exp $");
d304 6
a309 2
			fprintf(stderr, "%s, %s\n",
			    SSH_VERSION, SSLeay_version(SSLEAY_VERSION));
@


1.1.1.13
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.213 2004/05/08 00:01:37 deraadt Exp $");
d65 1
d70 1
a70 2
#include "sshpty.h"
#include "match.h"
d520 1
a520 1
		if (!read_config_file(config, host, &options, 0))
d526 1
a526 1
		(void)read_config_file(buf, host, &options, 1);
d529 1
a529 2
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host, 
		    &options, 0);
a1041 38
	}

	/* Transfer any environment variables from client to server */
	if (options.num_send_env != 0) {
		int i, j, matched;
		extern char **environ;
		char *name, *val;

		debug("Sending environment.");
		for (i = 0; environ && environ[i] != NULL; i++) {
			/* Split */
			name = xstrdup(environ[i]);
			if ((val = strchr(name, '=')) == NULL) {
				free(name);
				continue;
			}
			*val++ = '\0';

			matched = 0;
			for (j = 0; j < options.num_send_env; j++) {
				if (match_pattern(name, options.send_env[j])) {
					matched = 1;
					break;
				}
			}
			if (!matched) {
				debug3("Ignored env %s", name);
				free(name);
				continue;
			}

			debug("Sending env %s = %s", name, val);
			channel_request_start(id, "env", 0);
			packet_put_cstring(name);
			packet_put_cstring(val);
			packet_send();
			free(name);
		}
@


1.1.1.14
log
@openssh 3.9 (hopefully)
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.224 2004/07/28 09:40:29 markus Exp $");
a55 1
#include "bufaux.h"
a60 1
#include "dispatch.h"
d65 1
a70 2
#include "msg.h"
#include "monitor_fdpass.h"
a139 7
/* fd to control socket */
int control_fd = -1;

/* Only used in control client mode */
volatile sig_atomic_t control_client_terminate = 0;
u_int control_server_pid = 0;

d146 1
a146 1
"usage: ssh [-1246AaCfghkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
d149 1
a149 1
"           [-p port] [-R port:host:hostport] [-S ctl] [user@@]hostname [command]\n"
a156 1
static void control_client(const char *path);
d222 1
a222 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNPR:S:TVXY")) != -1) {
d331 1
a331 1
				options.cipher = SSH_CIPHER_INVALID;
a357 4
		case 'M':
			options.control_master =
			    (options.control_master >= 1) ? 2 : 1;
			break;
a425 5
		case 'S':
			if (options.control_path != NULL)
				free(options.control_path);
			options.control_path = xstrdup(optarg);
			break;
d529 1
a529 1
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host,
a557 7
	if (options.control_path != NULL) {
		options.control_path = tilde_expand_filename(
		   options.control_path, original_real_uid);
	}
	if (options.control_path != NULL && options.control_master == 0)
		control_client(options.control_path); /* This doesn't return */

a665 3
	if (options.control_path != NULL && control_fd != -1)
		unlink(options.control_path);

d765 1
a765 1
		u_int32_t rnd = 0;
d772 1
a772 1
				rnd = arc4random();
d774 2
a775 2
			    rnd & 0xff);
			rnd >>= 8;
d962 1
a962 1
ssh_subsystem_reply(int type, u_int32_t seq, void *ctxt)
d994 1
d996 1
a996 1
ssh_control_listener(void)
d998 5
a1002 2
	struct sockaddr_un addr;
	mode_t old_umask;
d1004 9
a1012 2
	if (options.control_path == NULL || options.control_master <= 0)
		return;
d1014 11
a1024 20
	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(options.control_path) + 1;

	if (strlcpy(addr.sun_path, options.control_path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((control_fd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s\n", __func__, strerror(errno));

	old_umask = umask(0177);
	if (bind(control_fd, (struct sockaddr*)&addr, addr.sun_len) == -1) {
		control_fd = -1;
		if (errno == EINVAL)
			fatal("ControlSocket %s already exists",
			    options.control_path);
		else
			fatal("%s bind(): %s\n", __func__, strerror(errno));
d1026 2
a1027 16
	umask(old_umask);

	if (listen(control_fd, 64) == -1)
		fatal("%s listen(): %s\n", __func__, strerror(errno));

	set_nonblock(control_fd);
}

/* request pty/x11/agent/tcpfwd/shell for channel */
static void
ssh_session2_setup(int id, void *arg)
{
	extern char **environ;

	int interactive = tty_flag;
	if (options.forward_x11 && getenv("DISPLAY") != NULL) {
d1045 59
a1103 2
	client_session2_setup(id, tty_flag, subsystem_flag, getenv("TERM"),
	    NULL, fileno(stdin), &command, environ, &ssh_subsystem_reply);
d1149 1
a1149 1
		channel_register_confirm(c->self, ssh_session2_setup, NULL);
a1160 1
	ssh_control_listener();
a1212 146
}

static void
control_client_sighandler(int signo)
{
	control_client_terminate = signo;
}

static void
control_client_sigrelay(int signo)
{
	if (control_server_pid > 1)
		kill(control_server_pid, signo);
}

static int
env_permitted(char *env)
{
	int i;
	char name[1024], *cp;

	strlcpy(name, env, sizeof(name));
	if ((cp = strchr(name, '=')) == NULL)
		return (0);

	*cp = '\0';

	for (i = 0; i < options.num_send_env; i++)
		if (match_pattern(name, options.send_env[i]))
			return (1);

	return (0);
}

static void
control_client(const char *path)
{
	struct sockaddr_un addr;
	int i, r, sock, exitval, num_env;
	Buffer m;
	char *cp;
	extern char **environ;

	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(path) + 1;

	if (strlcpy(addr.sun_path, path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));

	if (connect(sock, (struct sockaddr*)&addr, addr.sun_len) == -1)
		fatal("Couldn't connect to %s: %s", path, strerror(errno));

	if ((cp = getenv("TERM")) == NULL)
		cp = "";

	buffer_init(&m);

	/* Get PID of controlee */
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != 0)
		fatal("%s: wrong version", __func__);
	/* Connection allowed? */
	if (buffer_get_int(&m) != 1)
		fatal("Connection to master denied");
	control_server_pid = buffer_get_int(&m);

	buffer_clear(&m);
	buffer_put_int(&m, tty_flag);
	buffer_put_int(&m, subsystem_flag);
	buffer_put_cstring(&m, cp);

	buffer_append(&command, "\0", 1);
	buffer_put_cstring(&m, buffer_ptr(&command));

	if (options.num_send_env == 0 || environ == NULL) {
		buffer_put_int(&m, 0);
	} else {
		/* Pass environment */
		num_env = 0;
		for (i = 0; environ[i] != NULL; i++)
			if (env_permitted(environ[i]))
				num_env++; /* Count */

		buffer_put_int(&m, num_env);

		for (i = 0; environ[i] != NULL && num_env >= 0; i++)
			if (env_permitted(environ[i])) {
				num_env--;
				buffer_put_cstring(&m, environ[i]);
			}
	}

	if (ssh_msg_send(sock, /* version */0, &m) == -1)
		fatal("%s: msg_send", __func__);

	mm_send_fd(sock, STDIN_FILENO);
	mm_send_fd(sock, STDOUT_FILENO);
	mm_send_fd(sock, STDERR_FILENO);

	/* Wait for reply, so master has a chance to gather ttymodes */
	buffer_clear(&m);
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != 0)
		fatal("%s: master returned error", __func__);
	buffer_free(&m);

	signal(SIGINT, control_client_sighandler);
	signal(SIGTERM, control_client_sighandler);
	signal(SIGWINCH, control_client_sigrelay);

	if (tty_flag)
		enter_raw_mode();

	/* Stick around until the controlee closes the client_fd */
	exitval = 0;
	for (;!control_client_terminate;) {
		r = read(sock, &exitval, sizeof(exitval));
		if (r == 0) {
			debug2("Received EOF from master");
			break;
		}
		if (r > 0)
			debug2("Received exit status from master %d", exitval);
		if (r == -1 && errno != EINTR)
			fatal("%s: read %s", __func__, strerror(errno));
	}

	if (control_client_terminate)
		debug2("Exiting on signal %d", control_client_terminate);

	close(sock);

	leave_raw_mode();

	if (tty_flag && options.log_level != SYSLOG_LEVEL_QUIET)
		fprintf(stderr, "Connection to master closed.\r\n");

	exit(exitval);
@


1.1.1.15
log
@Just to please <gecko2>, here's the latest and greatest ssh-current code ;-)
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.225 2004/08/23 14:26:38 dtucker Exp $");
a73 1
#include "uidswap.h"
d636 2
a637 4
	if (original_effective_uid == 0) {
		PRIV_START;
		permanently_set_uid(pw);
	}
@


1.1.1.16
log
@sync ssh with obsd as of today
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.228 2004/09/23 13:00:04 djm Exp $");
d314 1
a314 1
			/* FALLTHROUGH */
d1240 1
a1240 1
	int i, r, fd, sock, exitval, num_env;
a1244 9
	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
	}

a1315 1
	signal(SIGHUP, control_client_sighandler);
@


1.1.1.17
log
@Updates for ssh and sudo from
.Ox
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.230 2004/11/07 17:57:30 jmc Exp $");
a146 3
/* Multiplexing control command */
static u_int mux_command = SSHMUX_COMMAND_OPEN;

d157 1
a157 1
"usage: ssh [-1246AaCfgkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
d159 2
a160 3
"           [-L port:host:hostport] [-l login_name] [-m mac_spec] [-O ctl_cmd]\n"
"           [-o option] [-p port] [-R port:host:hostport] [-S ctl_path]\n"
"           [user@@]hostname [command]\n"
d234 1
a234 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVXY")) != -1) {
a267 8
		case 'O':
			if (strcmp(optarg, "check") == 0)
				mux_command = SSHMUX_COMMAND_ALIVE_CHECK;
			else if (strcmp(optarg, "exit") == 0)
				mux_command = SSHMUX_COMMAND_TERMINATE;
			else
				fatal("Invalid multiplex command.");
			break;
d1242 1
a1242 1
	char *term;
a1243 1
	u_int  flags;
d1269 2
a1270 8
	if ((term = getenv("TERM")) == NULL)
		term = "";

	flags = 0;
	if (tty_flag)
		flags |= SSHMUX_FLAG_TTY;
	if (subsystem_flag)
		flags |= SSHMUX_FLAG_SUBSYS;
d1274 1
a1274 8
	/* Send our command to server */
	buffer_put_int(&m, mux_command);
	buffer_put_int(&m, flags);
	if (ssh_msg_send(sock, /* version */1, &m) == -1)
		fatal("%s: msg_send", __func__);
	buffer_clear(&m);

	/* Get authorisation status and PID of controlee */
d1277 1
a1277 1
	if (buffer_get_char(&m) != 1)
d1279 1
d1285 3
a1288 17
	switch (mux_command) {
	case SSHMUX_COMMAND_ALIVE_CHECK:
		fprintf(stderr, "Master running (pid=%d)\r\n", 
		    control_server_pid);
		exit(0);
	case SSHMUX_COMMAND_TERMINATE:
		fprintf(stderr, "Exit request sent.\r\n");
		exit(0);
	case SSHMUX_COMMAND_OPEN:
		/* continue below */
		break;
	default:
		fatal("silly mux_command %d", mux_command);
	}

	/* SSHMUX_COMMAND_OPEN */
	buffer_put_cstring(&m, term);
d1310 1
a1310 1
	if (ssh_msg_send(sock, /* version */1, &m) == -1)
d1321 2
a1322 2
	if (buffer_get_char(&m) != 1)
		fatal("%s: wrong version", __func__);
@


