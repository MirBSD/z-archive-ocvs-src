head	1.3;
access;
symbols
	tg-mergetmp-mirosx-1:1.3
	tg-mergefixes-1-branch:1.3.0.8
	tg-mergefixes-1-base:1.3
	MIROS_X:1.3.0.6
	MIROS_X_BASE:1.3
	tg-mergetmp-3:1.3
	MIRBSD_XP_MIRPPC:1.3.0.4
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	MIRBSD_7quater:1.1.1.2.2.6
	cvs-200405160640:1.1.1.4
	cvs-200401271800:1.1.1.3
	cvs-200401261630:1.1.1.3
	cvs-200401021645:1.1.1.3
	MIRBSD_7_ALPHA:1.1.1.2.2.6.0.4
	MIRBSD_7:1.1.1.2.2.6.0.2
	cvs-200312222040:1.1.1.3
	MIRBSD_7ter:1.1.1.2.2.6
	cvs-200311091712:1.1.5.1
	netbsd:1.1.5
	MIRBSD_7_DEV:1.1.1.2.0.2
	cvs-200310020700:1.1.1.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2003.12.27.00.31.13;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2003.12.17.19.00.26;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.52.39;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.5.1;
next	;

1.1.1.1
date	2003.03.22.17.52.39;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.06.19.12.52.19;	author tg;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	2003.12.22.21.12.53;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.16.08.07.00;	author tg;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	2003.11.09.17.43.00;	author tg;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	2003.11.09.17.48.47;	author tg;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	2003.11.09.17.51.46;	author tg;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	2003.11.09.18.16.36;	author tg;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	2003.11.09.18.23.41;	author tg;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	2003.11.19.16.15.28;	author tg;	state Exp;
branches;
next	;

1.1.5.1
date	2003.11.09.17.14.34;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@finish merging and sync a bit; bump version etc.
@
text
@/* $MirBSD: elf2aout.c,v 1.2 2003/12/17 19:00:26 tg Exp $ */
/* $NetBSD: elf2aout.c,v 1.10 2000/03/13 23:22:50 soren Exp $ */

/*
 * Copyright (c) 1995
 *	Ted Lemon (hereinafter referred to as the author)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* elf2aout.c

   This program converts an elf executable to a NetBSD a.out executable.
   The minimal symbol table is copied, but the debugging symbols and
   other informational sections are not. */

#include <sys/types.h>
#include <sys/exec_aout.h>
#include <sys/exec_elf.h>

#include <a.out.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>


struct sect {
	unsigned long vaddr;
	unsigned long len;
};

void	combine(struct sect *, struct sect *, int);
int	phcmp(const void *, const void *);
char   *saveRead(int, off_t, off_t, char *);
void	copy(int, int, off_t, off_t);
void	translate_syms(int, int, off_t, off_t, off_t, off_t);

int    *symTypeTable;

int
main(int argc, char **argv)
{
	Elf32_Ehdr ex;
	Elf32_Phdr *ph;
	Elf32_Shdr *sh;
	char   *shstrtab;
	int     strtabix, symtabix;
	int     i, newmid;
	struct sect text, data, bss;
	struct exec aex;
	int     infile, outfile;
	unsigned long cur_vma = ULONG_MAX;
	int     symflag = 0;
	int	bootflag = 0;

	strtabix = symtabix = 0;
	text.len = data.len = bss.len = 0;
	text.vaddr = data.vaddr = bss.vaddr = 0;

	/* Check args... */
	if (argc < 3 || argc > 4) {
usage:
		fprintf(stderr,
		    "usage: elf2aout <elf executable> <a.out executable> [-sb]\n");
		exit(1);
	}
	if (argc == 4) {
		if (!strcmp(argv[3], "-s"))
			symflag = 1;
		else if (!strcmp(argv[3], "-b"))
			bootflag = 1;
		else if (!strcmp(argv[3], "-sb")) {
			symflag = 1;
			bootflag = 1;
		} else if (!strcmp(argv[3], "-bs")) {
			symflag = 1;
			bootflag = 1;
		} else	goto usage;
	}
	/* Try the input file... */
	if ((infile = open(argv[1], O_RDONLY)) < 0) {
		fprintf(stderr, "Can't open %s for read: %s\n",
		    argv[1], strerror(errno));
		exit(1);
	}
	/* Read the header, which is at the beginning of the file... */
	i = read(infile, &ex, sizeof ex);
	if (i != sizeof ex) {
		fprintf(stderr, "ex: %s: %s.\n",
		    argv[1], i ? strerror(errno) : "End of file reached");
		exit(1);
	}
	/* Read the program headers... */
	ph = (Elf32_Phdr *) saveRead(infile, ex.e_phoff,
	    ex.e_phnum * sizeof(Elf32_Phdr), "ph");
	/* Read the section headers... */
	sh = (Elf32_Shdr *) saveRead(infile, ex.e_shoff,
	    ex.e_shnum * sizeof(Elf32_Shdr), "sh");
	/* Read in the section string table. */
	shstrtab = saveRead(infile, sh[ex.e_shstrndx].sh_offset,
	    sh[ex.e_shstrndx].sh_size, "shstrtab");

	/* Find space for a table matching ELF section indices to a.out symbol
	 * types. */
	symTypeTable = (int *) malloc(ex.e_shnum * sizeof(int));
	if (!symTypeTable) {
		fprintf(stderr, "symTypeTable: can't allocate.\n");
		exit(1);
	}
	memset(symTypeTable, 0, ex.e_shnum * sizeof(int));

	/* Look for the symbol table and string table... Also map section
	 * indices to symbol types for a.out */
	for (i = 0; i < ex.e_shnum; i++) {
		char   *name = shstrtab + sh[i].sh_name;
		if (!strcmp(name, ".symtab"))
			symtabix = i;
		else
			if (!strcmp(name, ".strtab"))
				strtabix = i;
			else
				if (!strcmp(name, ".text") || !strcmp(name, ".rodata"))
					symTypeTable[i] = N_TEXT;
				else
					if (!strcmp(name, ".data") || !strcmp(name, ".sdata") ||
					    !strcmp(name, ".lit4") || !strcmp(name, ".lit8"))
						symTypeTable[i] = N_DATA;
					else
						if (!strcmp(name, ".bss") || !strcmp(name, ".sbss"))
							symTypeTable[i] = N_BSS;
	}

	/* Figure out if we can cram the program header into an a.out
	 * header... Basically, we can't handle anything but loadable
	 * segments, but we can ignore some kinds of segments.   We can't
	 * handle holes in the address space, and we handle start addresses
	 * other than 0x1000 by hoping that the loader will know where to load
	 * - a.out doesn't have an explicit load address.   Segments may be
	 * out of order, so we sort them first. */
	qsort(ph, ex.e_phnum, sizeof(Elf32_Phdr), phcmp);
	for (i = 0; i < ex.e_phnum; i++) {
		/* Section types we can ignore... */
		if (ph[i].p_type == PT_NULL || ph[i].p_type == PT_NOTE ||
		    ph[i].p_type == PT_PHDR)
			continue;
		/* Section types we can't handle... */
		else if (ph[i].p_type != PT_LOAD) {
			fprintf(stderr,
			    "Program header %d type %d can't be converted.\n",
			    i, ph[i].p_type);
			exit(1);
		}
		/* Writable (data) segment? */
		if (ph[i].p_flags & PF_W) {
			struct sect ndata, nbss;

			ndata.vaddr = ph[i].p_vaddr;
			ndata.len = ph[i].p_filesz;
			nbss.vaddr = ph[i].p_vaddr + ph[i].p_filesz;
			nbss.len = ph[i].p_memsz - ph[i].p_filesz;

			combine(&data, &ndata, 0);
			combine(&bss, &nbss, 1);
		} else {
			struct sect ntxt;

			ntxt.vaddr = ph[i].p_vaddr;
			ntxt.len = ph[i].p_filesz;

			combine(&text, &ntxt, 0);
		}
		/* Remember the lowest segment start address. */
		if (ph[i].p_vaddr < cur_vma)
			cur_vma = ph[i].p_vaddr;
	}

	/* Sections must be in order to be converted... */
	if (text.vaddr > data.vaddr || data.vaddr > bss.vaddr ||
	    text.vaddr + text.len > data.vaddr || data.vaddr + data.len > bss.vaddr) {
		fprintf(stderr, "Sections ordering prevents a.out conversion.\n");
		exit(1);
	}
	/* If there's a data section but no text section, then the loader
	 * combined everything into one section.   That needs to be the text
	 * section, so just make the data section zero length following text. */
	if (data.len && !text.len) {
		text = data;
		data.vaddr = text.vaddr + text.len;
		data.len = 0;
	}
	/* If there is a gap between text and data, we'll fill it when we copy
	 * the data, so update the length of the text segment as represented
	 * in a.out to reflect that, since a.out doesn't allow gaps in the
	 * program address space. */
	if (text.vaddr + text.len < data.vaddr)
		text.len = data.vaddr - text.vaddr;

	/* We now have enough information to cons up an a.out header... */
	newmid = MID_ZERO;
	switch (ex.e_machine) {
		case EM_ALPHA:
		case EM_ALPHA_EXP:
			newmid = MID_ALPHA;
			break;
		case EM_386:
		case EM_486:
			newmid = MID_I386;
			break;
		case EM_68K:
			newmid = MID_M68K;
			break;
		case EM_88K:
			newmid = MID_M88K;
			break;
		case EM_MIPS:
			newmid = (bootflag ? MID_PMAX : MID_MIPS);
			break;
		case EM_PPC:
			newmid = MID_POWERPC;
			break;
		case EM_SPARC:
			newmid = (bootflag ? 0x0103 : MID_SPARC);
			break;
		case EM_SPARC64:
		case EM_SPARCV9:
			newmid = (bootflag ? 0x0103 : MID_SPARC64);
			break;
		case EM_VAX:
			newmid = MID_VAX;
			break;
		case EM_NONE:
			break;
		default:
			fprintf(stderr,
			    "Warning: Machine %04X unknown, using MID_ZERO\n",
			    ex.e_machine);
			break;
	}
	aex.a_midmag = htonl((symflag << 26) | (newmid << 16) | OMAGIC);
	aex.a_text = text.len;
	aex.a_data = data.len;
	aex.a_bss = bss.len;
	aex.a_entry = ex.e_entry;
	aex.a_syms = (sizeof(struct nlist) *
	    (symtabix != -1
		? sh[symtabix].sh_size / sizeof(Elf32_Sym) : 0));
	aex.a_trsize = 0;
	aex.a_drsize = 0;

	/* Make the output file... */
	if ((outfile = open(argv[2], O_WRONLY | O_CREAT, 0777)) < 0) {
		fprintf(stderr, "Unable to create %s: %s\n", argv[2], strerror(errno));
		exit(1);
	}
	/* Truncate file... */
	if (ftruncate(outfile, 0)) {
		warn("ftruncate %s", argv[2]);
	}
	/* Write the header... */
	i = write(outfile, &aex, sizeof aex);
	if (i != sizeof aex) {
		perror("aex: write");
		exit(1);
	}
	/* Copy the loadable sections.   Zero-fill any gaps less than 64k;
	 * complain about any zero-filling, and die if we're asked to
	 * zero-fill more than 64k. */
	for (i = 0; i < ex.e_phnum; i++) {
		/* Unprocessable sections were handled above, so just verify
		 * that the section can be loaded before copying. */
		if (ph[i].p_type == PT_LOAD && ph[i].p_filesz) {
			if (cur_vma != ph[i].p_vaddr) {
				unsigned long gap = ph[i].p_vaddr - cur_vma;
				char    obuf[1024];
				if (gap > 65536)
					errx(1,
			"Intersegment gap (%ld bytes) too large.", (long) gap);
#ifdef DEBUG
				warnx("Warning: %ld byte intersegment gap.",
				    (long)gap);
#endif
				memset(obuf, 0, sizeof obuf);
				while (gap) {
					int     count = write(outfile, obuf, (gap > sizeof obuf
						? sizeof obuf : gap));
					if (count < 0) {
						fprintf(stderr, "Error writing gap: %s\n",
						    strerror(errno));
						exit(1);
					}
					gap -= count;
				}
			}
			copy(outfile, infile, ph[i].p_offset, ph[i].p_filesz);
			cur_vma = ph[i].p_vaddr + ph[i].p_filesz;
		}
	}

	/* Copy and translate the symbol table... */
	translate_syms(outfile, infile,
	    sh[symtabix].sh_offset, sh[symtabix].sh_size,
	    sh[strtabix].sh_offset, sh[strtabix].sh_size);

	/* Looks like we won... */
	exit(0);
}

/* translate_syms (out, in, offset, size)

   Read the ELF symbol table from in at offset; translate it into a.out
   nlist format and write it to out. */
void
translate_syms(int out, int in, off_t symoff, off_t symsize,
    off_t stroff, off_t strsize)
{
#define SYMS_PER_PASS	64
	Elf32_Sym inbuf[64];
	struct nlist outbuf[64];
	int     i, remaining, cur;
	char   *oldstrings;
	char   *newstrings, *nsp;
	int     newstringsize;

	/* Zero the unused fields in the output buffer.. */
	memset(outbuf, 0, sizeof outbuf);

	/* Find number of symbols to process... */
	remaining = symsize / sizeof(Elf32_Sym);

	/* Suck in the old string table... */
	oldstrings = saveRead(in, stroff, strsize, "string table");

	/* Allocate space for the new one.   XXX We make the wild assumption
	 * that no two symbol table entries will point at the same place in
	 * the string table - if that assumption is bad, this could easily
	 * blow up. */
	newstringsize = strsize + remaining;
	newstrings = (char *) malloc(newstringsize);
	if (!newstrings) {
		fprintf(stderr, "No memory for new string table!\n");
		exit(1);
	}
	/* Initialize the table pointer... */
	nsp = newstrings;

	/* Go to the start of the ELF symbol table... */
	if (lseek(in, symoff, SEEK_SET) < 0) {
		perror("translate_syms: lseek");
		exit(1);
	}
	/* Translate and copy symbols... */
	while (remaining) {
		cur = remaining;
		if (cur > SYMS_PER_PASS)
			cur = SYMS_PER_PASS;
		remaining -= cur;
		if ((i = read(in, inbuf, cur * sizeof(Elf32_Sym)))
		    != cur * sizeof(Elf32_Sym)) {
			if (i < 0)
				perror("translate_syms");
			else
				fprintf(stderr, "translate_syms: premature end of file.\n");
			exit(1);
		}
		/* Do the translation... */
		for (i = 0; i < cur; i++) {
			int     binding, type;

			/* Copy the symbol into the new table, but prepend an
			 * underscore. */
			*nsp = '_';
			strlcpy(nsp + 1, oldstrings + inbuf[i].st_name,
			    newstringsize - 1);
			outbuf[i].n_un.n_strx = nsp - newstrings + 4;
			nsp += strlen(nsp) + 1;

			type = ELF32_ST_TYPE(inbuf[i].st_info);
			binding = ELF32_ST_BIND(inbuf[i].st_info);

			/* Convert ELF symbol type/section/etc info into a.out
			 * type info. */
			if (type == STT_FILE)
				outbuf[i].n_type = N_FN;
			else
				if (inbuf[i].st_shndx == SHN_UNDEF)
					outbuf[i].n_type = N_UNDF;
				else
					if (inbuf[i].st_shndx == SHN_ABS)
						outbuf[i].n_type = N_ABS;
					else
						if (inbuf[i].st_shndx == SHN_COMMON)
							outbuf[i].n_type = N_COMM;
						else
							outbuf[i].n_type = symTypeTable[inbuf[i].st_shndx];
			if (binding == STB_GLOBAL)
				outbuf[i].n_type |= N_EXT;
			/* Symbol values in executables should be compatible. */
			outbuf[i].n_value = inbuf[i].st_value;
		}
		/* Write out the symbols... */
		if ((i = write(out, outbuf, cur * sizeof(struct nlist)))
		    != cur * sizeof(struct nlist)) {
			fprintf(stderr, "translate_syms: write: %s\n", strerror(errno));
			exit(1);
		}
	}
	/* Write out the string table length... */
	if (write(out, &newstringsize, sizeof newstringsize)
	    != sizeof newstringsize) {
		fprintf(stderr,
		    "translate_syms: newstringsize: %s\n", strerror(errno));
		exit(1);
	}
	/* Write out the string table... */
	if (write(out, newstrings, newstringsize) != newstringsize) {
		fprintf(stderr, "translate_syms: newstrings: %s\n", strerror(errno));
		exit(1);
	}
}

void
copy(int out, int in, off_t offset, off_t size)
{
	char    ibuf[4096];
	int     remaining, cur, count;

	/* Go to the start of the ELF symbol table... */
	if (lseek(in, offset, SEEK_SET) < 0) {
		perror("copy: lseek");
		exit(1);
	}
	remaining = size;
	while (remaining) {
		cur = remaining;
		if (cur > sizeof ibuf)
			cur = sizeof ibuf;
		remaining -= cur;
		if ((count = read(in, ibuf, cur)) != cur) {
			fprintf(stderr, "copy: read: %s\n",
			    count ? strerror(errno) : "premature end of file");
			exit(1);
		}
		if ((count = write(out, ibuf, cur)) != cur) {
			perror("copy: write");
			exit(1);
		}
	}
}

/* Combine two segments, which must be contiguous.   If pad is true, it's
   okay for there to be padding between. */
void
combine(struct sect *base, struct sect *new, int pad)
{
	if (!base->len)
		*base = *new;
	else
		if (new->len) {
			if (base->vaddr + base->len != new->vaddr) {
				if (pad)
					base->len = new->vaddr - base->vaddr;
				else {
					fprintf(stderr,
					    "Non-contiguous data can't be converted.\n");
					exit(1);
				}
			}
			base->len += new->len;
		}
}

int
phcmp(const void *vh1, const void *vh2)
{
	Elf32_Phdr *h1, *h2;
	h1 = (Elf32_Phdr *) vh1;
	h2 = (Elf32_Phdr *) vh2;

	if (h1->p_vaddr > h2->p_vaddr)
		return 1;
	else
		if (h1->p_vaddr < h2->p_vaddr)
			return -1;
		else
			return 0;
}

char *
saveRead(int file, off_t offset, off_t len, char *name)
{
	char   *tmp;
	int     count;
	off_t   off;
	if ((off = lseek(file, offset, SEEK_SET)) < 0) {
		fprintf(stderr, "%s: fseek: %s\n", name, strerror(errno));
		exit(1);
	}
	if (!(tmp = (char *) malloc(len)))
		errx(1, "%s: Can't allocate %ld bytes.", name, (long)len);
	count = read(file, tmp, len);
	if (count != len) {
		fprintf(stderr, "%s: read: %s.\n",
		    name, count ? strerror(errno) : "End of file reached");
		exit(1);
	}
	return tmp;
}
@


1.2
log
@second (piecewise) attempt to merge MirBSD #7ter into HEAD
@
text
@d1 1
a1 1
/* $MirBSD: elf2aout.c,v 1.1.1.2.2.6 2003/11/19 16:15:28 tg Exp $ */
d173 6
a178 3
		else
			if (ph[i].p_type != PT_LOAD)
				errx(1, "Program header %d type %d can't be converted.", i, ph[i].p_type);
d372 1
a372 1
	/* Go the start of the ELF symbol table... */
d453 1
a453 1
	/* Go the the start of the ELF symbol table... */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: elf2aout.c,v 1.2 2001/01/29 01:57:56 niklas Exp $	*/
d19 1
a19 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND
d32 6
d39 6
d46 1
a46 3
#include <unistd.h>
#include <elf_abi.h>
#include <machine/elf_abi.h>
d48 1
a48 2
#include <a.out.h>
#include <sys/errno.h>
d50 1
a50 3
#include <limits.h>

#define SHN_MIPS_ACOMMON 0xfff0
a51 1
extern char *__progname;
d54 2
a55 19
  unsigned long vaddr;
  unsigned long len;
};
int phcmp ();
char *saveRead (int file, off_t offset, off_t len, char *name);
int copy (int, int, off_t, off_t);
int translate_syms (int, int, off_t, off_t, off_t, off_t);
extern int errno;
int *symTypeTable;

/* Symbol table entry... */
struct sym {
  unsigned long name;           /* Index into strtab of symbol name. */
  unsigned long value;          /* Section offset, virt addr or common align. */
  unsigned long size;           /* Size of object referenced. */
  unsigned type    : 4;         /* Symbol type (e.g., function, data)... */
  unsigned binding : 4;         /* Symbol binding (e.g., global, local)... */
  unsigned char other;          /* Unused. */
  unsigned short shndx;         /* Section containing symbol. */
d58 7
a64 10
struct phdr {
  unsigned long type;           /* Segment type... */
  unsigned long offset;         /* File offset... */
  unsigned long vaddr;          /* Virtual address... */
  unsigned long paddr;          /* Physical address... */
  unsigned long filesz;         /* Size of segment in file... */
  unsigned long memsz;          /* Size of segment in memory... */
  unsigned long flags;          /* Segment flags... */
  unsigned long align;          /* Alighment, file and memory... */
};
d66 2
a67 1
main (int argc, char **argv, char **envp)
d69 125
a193 197
  Elf32_Ehdr ex;
  Elf32_Phdr *ph;
  Elf32_Shdr *sh;
  struct sym *symtab;
  char *shstrtab;
  int strtabix, symtabix;
  int i;
  struct sect text, data, bss;
  struct exec aex;
  int infile, outfile;
  unsigned long cur_vma = ULONG_MAX;
  int symflag = 0;

  text.len = data.len = bss.len = 0;
  text.vaddr = data.vaddr = bss.vaddr = 0;

  /* Check args... */
  if (argc < 3 || argc > 4)
    {
    usage:
      fprintf (stderr,
	       "usage: %s <elf executable> <a.out executable>\n", __progname);
      exit (1);
    }

  /* Try the input file... */
  if ((infile = open (argv [1], O_RDONLY)) < 0)
    {
      fprintf (stderr, "Can't open %s for read: %s\n",
	       argv [1], strerror (errno));
      exit (1);
    }

  /* Read the header, which is at the beginning of the file... */
  i = read (infile, &ex, sizeof ex);
  if (i != sizeof ex)
    {
      fprintf (stderr, "ex: %s: %s.\n",
	       argv [1], i ? strerror (errno) : "End of file reached");
      exit (1);
    }

  /* Read the program headers... */
  ph = (Elf32_Phdr *)saveRead (infile, ex.e_phoff,
				ex.e_phnum * sizeof (Elf32_Phdr), "ph");
  /* Read the section headers... */
  sh = (Elf32_Shdr *)saveRead (infile, ex.e_shoff,
				ex.e_shnum * sizeof (Elf32_Shdr), "sh");
  /* Read in the section string table. */
  shstrtab = saveRead (infile, sh [ex.e_shstrndx].sh_offset,
		       sh [ex.e_shstrndx].sh_size, "shstrtab");

  /* Find space for a table matching ELF section indices to a.out symbol
     types. */
  symTypeTable = (int *)malloc (ex.e_shnum * sizeof (int));
  if (!symTypeTable)
    {
      fprintf (stderr, "symTypeTable: can't allocate.\n");
      exit (1);
    }
  memset (symTypeTable, 0, ex.e_shnum * sizeof (int));

  /* Look for the symbol table and string table...
     Also map section indices to symbol types for a.out */
  for (i = 0; i < ex.e_shnum; i++)
    {
      char *name = shstrtab + sh [i].sh_name;
      if (!strcmp (name, ".symtab"))
	symtabix = i;
      else if (!strcmp (name, ".strtab"))
	strtabix = i;
      else if (!strcmp (name, ".text") || !strcmp (name, ".rodata"))
	symTypeTable [i] = N_TEXT;
      else if (!strcmp (name, ".data") || !strcmp (name, ".sdata") ||
	       !strcmp (name, ".lit4") || !strcmp (name, ".lit8"))
	symTypeTable [i] = N_DATA;
      else if (!strcmp (name, ".bss") || !strcmp (name, ".sbss"))
	symTypeTable [i] = N_BSS;
    }

  /* Figure out if we can cram the program header into an a.out header...
     Basically, we can't handle anything but loadable segments, but we
     can ignore some kinds of segments.   We can't handle holes in the
     address space, and we handle start addresses other than 0x1000 by
     hoping that the loader will know where to load - a.out doesn't have
     an explicit load address.   Segments may be out of order, so we
     sort them first. */
  qsort (ph, ex.e_phnum, sizeof (Elf32_Phdr), phcmp);
  for (i = 0; i < ex.e_phnum; i++)
    {
      /* Section types we can ignore... */
      if (ph [i].p_type == PT_NULL || ph [i].p_type == PT_NOTE ||
	  ph [i].p_type == PT_PHDR || ph [i].p_type == PT_MIPS_REGINFO)
	continue;
      /* Section types we can't handle... */
      else if (ph [i].p_type != PT_LOAD)
        {
	  fprintf (stderr, "Program header %d type %d can't be converted.\n");
	  exit (1);
	}
      /* Writable (data) segment? */
      if (ph [i].p_flags & PF_W)
	{
	  struct sect ndata, nbss;

	  ndata.vaddr = ph [i].p_vaddr;
	  ndata.len = ph [i].p_filesz;
	  nbss.vaddr = ph [i].p_vaddr + ph [i].p_filesz;
	  nbss.len = ph [i].p_memsz - ph [i].p_filesz;

	  combine (&data, &ndata, 0);
	  combine (&bss, &nbss, 1);
	}
      else
	{
	  struct sect ntxt;

	  ntxt.vaddr = ph [i].p_vaddr;
	  ntxt.len = ph [i].p_filesz;

	  combine (&text, &ntxt);
	}
      /* Remember the lowest segment start address. */
      if (ph [i].p_vaddr < cur_vma)
	cur_vma = ph [i].p_vaddr;
    }

  /* Sections must be in order to be converted... */
  if (text.vaddr > data.vaddr || data.vaddr > bss.vaddr ||
      text.vaddr + text.len > data.vaddr || data.vaddr + data.len > bss.vaddr)
    {
      fprintf (stderr, "Sections ordering prevents a.out conversion.\n");
      exit (1);
    }

  /* If there's a data section but no text section, then the loader
     combined everything into one section.   That needs to be the
     text section, so just make the data section zero length following
     text. */
  if (data.len && !text.len)
    {
      text = data;
      data.vaddr = text.vaddr + text.len;
      data.len = 0;
    }

  /* If there is a gap between text and data, we'll fill it when we copy
     the data, so update the length of the text segment as represented in
     a.out to reflect that, since a.out doesn't allow gaps in the program
     address space. */
  if (text.vaddr + text.len < data.vaddr)
    text.len = data.vaddr - text.vaddr;

  /* We now have enough information to cons up an a.out header... */
  aex.a_midmag = htonl ((symflag << 26) | (MID_PMAX << 16) | OMAGIC);
  aex.a_text = text.len;
  aex.a_data = data.len;
  aex.a_bss = bss.len;
  aex.a_entry = ex.e_entry;
  aex.a_syms = (sizeof (struct nlist) *
		(symtabix != -1
		 ? sh [symtabix].sh_size / sizeof (struct sym) : 0));
  aex.a_trsize = 0;
  aex.a_drsize = 0;

  /* Make the output file... */
  if ((outfile = open (argv [2], O_WRONLY | O_CREAT, 0777)) < 0)
    {
      fprintf (stderr, "Unable to create %s: %s\n", argv [2], strerror (errno));
      exit (1);
    }
  /* Write the header... */
  i = write (outfile, &aex, sizeof aex);
  if (i != sizeof aex)
    {
      perror ("aex: write");
      exit (1);
    }

  /* Copy the loadable sections.   Zero-fill any gaps less than 64k;
     complain about any zero-filling, and die if we're asked to zero-fill
     more than 64k. */
  for (i = 0; i < ex.e_phnum; i++)
    {
      /* Unprocessable sections were handled above, so just verify that
	 the section can be loaded before copying. */
      if (ph [i].p_type == PT_LOAD && ph [i].p_filesz)
	{
	  if (cur_vma != ph [i].p_vaddr)
	    {
	      unsigned long gap = ph [i].p_vaddr - cur_vma;
	      char obuf [1024];
	      if (gap > 65536)
		{
		  fprintf (stderr, "Intersegment gap (%d bytes) too large.\n",
			   gap);
		  exit (1);
d195 124
a318 13
	      fprintf (stderr, "Warning: %d byte intersegment gap.\n", gap);
	      memset (obuf, 0, sizeof obuf);
	      while (gap)
		{
		  int count = write (outfile, obuf, (gap > sizeof obuf
						     ? sizeof obuf : gap));
		  if (count < 0)
		    {
		      fprintf (stderr, "Error writing gap: %s\n",
			       strerror (errno));
		      exit (1);
		    }
		  gap -= count;
d320 6
a325 10
	    }
	  copy (outfile, infile, ph [i].p_offset, ph [i].p_filesz);
	  cur_vma = ph [i].p_vaddr + ph [i].p_filesz;
	}
    }

  /* Copy and translate the symbol table... */
  translate_syms (outfile, infile, sh [symtabix].sh_offset,
                  sh [symtabix].sh_size,
		  sh [strtabix].sh_offset, sh [strtabix].sh_size);
d327 2
a328 2
  /* Looks like we won... */
  exit (0);
d335 33
d369 73
a441 107
translate_syms (out, in, symoff, symsize, stroff, strsize)
     int out, in;
     off_t symoff, symsize;
     off_t stroff, strsize;
{
# define SYMS_PER_PASS	64
  struct sym inbuf [64];
  struct nlist outbuf [64];
  int i, remaining, cur;
  char *oldstrings;
  char *newstrings, *nsp;
  int newstringsize;

  /* Zero the unused fields in the output buffer.. */
  memset (outbuf, 0, sizeof outbuf);

  /* Find number of symbols to process... */
  remaining = symsize / sizeof (struct sym);

  /* Suck in the old string table... */
  oldstrings = saveRead (in, stroff, strsize, "string table");

  /* Allocate space for the new one.   XXX We make the wild assumption that
     no two symbol table entries will point at the same place in the
     string table - if that assumption is bad, this could easily blow up. */
  newstringsize = strsize + remaining;
  newstrings = (char *)malloc (newstringsize);
  if (!newstrings)
    {
      fprintf (stderr, "No memory for new string table!\n");
      exit (1);
    }
  /* Initialize the table pointer... */
  nsp = newstrings;

  /* Go the the start of the ELF symbol table... */
  if (lseek (in, symoff, SEEK_SET) < 0)
    {
      perror ("translate_syms: lseek");
      exit (1);
    }

  /* Translate and copy symbols... */
  while (remaining)
    {
      cur = remaining;
      if (cur > SYMS_PER_PASS)
	cur = SYMS_PER_PASS;
      remaining -= cur;
      if ((i = read (in, inbuf, cur * sizeof (struct sym)))
	  != cur * sizeof (struct sym))
	{
	  if (i < 0)
	    perror ("translate_syms");
	  else
	    fprintf (stderr, "translate_syms: premature end of file.\n");
	  exit (1);
	}

      /* Do the translation... */
      for (i = 0; i < cur; i++)
	{
	  /* Copy the symbol into the new table, but prepend an underscore. */
	  *nsp = '_';
	  strcpy (nsp + 1, oldstrings + inbuf [i].name);
	  outbuf [i].n_un.n_strx = nsp - newstrings + 4;
	  nsp += strlen (nsp) + 1;

	  /* Convert ELF symbol type/section/etc info into a.out type info. */
	  if (inbuf [i].type == STT_FILE)
	    outbuf [i].n_type = N_FN;
	  else if (inbuf [i].shndx == SHN_UNDEF)
	    outbuf [i].n_type = N_UNDF;
	  else if (inbuf [i].shndx == SHN_ABS)
	    outbuf [i].n_type = N_ABS;
	  else if (inbuf [i].shndx == SHN_COMMON ||
		 inbuf [i].shndx == SHN_MIPS_ACOMMON)
	    outbuf [i].n_type = N_COMM;
	  else
	    outbuf [i].n_type = symTypeTable [inbuf [i].shndx];
	  if (inbuf [i].binding == STB_GLOBAL)
	    outbuf [i].n_type |= N_EXT;
	  /* Symbol values in executables should be compatible. */
	  outbuf [i].n_value = inbuf [i].value;
	}
      /* Write out the symbols... */
      if ((i = write (out, outbuf, cur * sizeof (struct nlist)))
	  != cur * sizeof (struct nlist))
	{
	  fprintf (stderr, "translate_syms: write: %s\n", strerror (errno));
	  exit (1);
	}
    }
  /* Write out the string table length... */
  if (write (out, &newstringsize, sizeof newstringsize)
      != sizeof newstringsize)
    {
      fprintf (stderr,
	       "translate_syms: newstringsize: %s\n", strerror (errno));
      exit (1);
    }
  /* Write out the string table... */
  if (write (out, newstrings, newstringsize) != newstringsize)
    {
      fprintf (stderr, "translate_syms: newstrings: %s\n", strerror (errno));
      exit (1);
    }
d443 3
a445 4
      
copy (out, in, offset, size)
     int out, in;
     off_t offset, size;
d447 2
a448 2
  char ibuf [4096];
  int remaining, cur, count;
d450 20
a469 24
  /* Go the the start of the ELF symbol table... */
  if (lseek (in, offset, SEEK_SET) < 0)
    {
      perror ("copy: lseek");
      exit (1);
    }

  remaining = size;
  while (remaining)
    {
      cur = remaining;
      if (cur > sizeof ibuf)
	cur = sizeof ibuf;
      remaining -= cur;
      if ((count = read (in, ibuf, cur)) != cur)
	{
	  fprintf (stderr, "copy: read: %s\n",
		   count ? strerror (errno) : "premature end of file");
	  exit (1);
	}
      if ((count = write (out, ibuf, cur)) != cur)
	{
	  perror ("copy: write");
	  exit (1);
a470 1
    }
d475 2
a476 3
combine (base, new, pad)
     struct sect *base, *new;
     int pad;
d478 15
a492 17
  if (!base -> len)
    *base = *new;
  else if (new -> len)
    {
      if (base -> vaddr + base -> len != new -> vaddr)
	{
	  if (pad)
	    base -> len = new -> vaddr - base -> vaddr;
	  else
	    {
	      fprintf (stderr,
		       "Non-contiguous data can't be converted.\n");
	      exit (1);
	    }
	}
      base -> len += new -> len;
    }
d495 2
a496 2
phcmp (h1, h2)
     struct phdr *h1, *h2;
d498 11
a508 6
  if (h1 -> vaddr > h2 -> vaddr)
    return 1;
  else if (h1 -> vaddr < h2 -> vaddr)
    return -1;
  else
    return 0;
d511 2
a512 1
char *saveRead (int file, off_t offset, off_t len, char *name)
d514 16
a529 21
  char *tmp;
  int count;
  off_t off;
  if ((off = lseek (file, offset, SEEK_SET)) < 0)
    {
      fprintf (stderr, "%s: fseek: %s\n", name, strerror (errno));
      exit (1);
    }
  if (!(tmp = (char *)malloc (len)))
    {
      fprintf (stderr, "%s: Can't allocate %d bytes.\n", name, len);
      exit (1);
    }
  count = read (file, tmp, len);
  if (count != len)
    {
      fprintf (stderr, "%s: read: %s.\n",
	       name, count ? strerror (errno) : "End of file reached");
      exit (1);
    }
  return tmp;
@


1.1.5.1
log
@Import NetBSD elf2aout, to be used to provide a TFTP-bootable
bsd.rd kernel for SPARC
@
text
@d1 1
a1 1
/*	$NetBSD: elf2aout.c,v 1.10 2000/03/13 23:22:50 soren Exp $	*/
a30 6
/* elf2aout.c

   This program converts an elf executable to a NetBSD a.out executable.
   The minimal symbol table is copied, but the debugging symbols and
   other informational sections are not. */

a31 6
#include <sys/exec_aout.h>
#include <sys/exec_elf.h>

#include <a.out.h>
#include <err.h>
#include <errno.h>
d33 3
a35 1
#include <limits.h>
d37 2
a38 1
#include <stdlib.h>
d40 3
a42 1
#include <unistd.h>
d44 1
d47 19
a65 2
	unsigned long vaddr;
	unsigned long len;
d68 10
a77 7
void	combine __P((struct sect *, struct sect *, int));
int	phcmp __P((const void *, const void *));
char   *saveRead __P((int file, off_t offset, off_t len, char *name));
void	copy __P((int, int, off_t, off_t));
void	translate_syms __P((int, int, off_t, off_t, off_t, off_t));

int    *symTypeTable;
d79 1
a79 2
int
main(int argc, char **argv)
d81 197
a277 116
	Elf32_Ehdr ex;
	Elf32_Phdr *ph;
	Elf32_Shdr *sh;
	char   *shstrtab;
	int     strtabix, symtabix;
	int     i;
	struct sect text, data, bss;
	struct exec aex;
	int     infile, outfile;
	unsigned long cur_vma = ULONG_MAX;
	int     symflag = 0;

	strtabix = symtabix = 0;
	text.len = data.len = bss.len = 0;
	text.vaddr = data.vaddr = bss.vaddr = 0;

	/* Check args... */
	if (argc < 3 || argc > 4) {
usage:
		fprintf(stderr,
		    "usage: elf2aout <elf executable> <a.out executable> [-s]\n");
		exit(1);
	}
	if (argc == 4) {
		if (strcmp(argv[3], "-s"))
			goto usage;
		symflag = 1;
	}
	/* Try the input file... */
	if ((infile = open(argv[1], O_RDONLY)) < 0) {
		fprintf(stderr, "Can't open %s for read: %s\n",
		    argv[1], strerror(errno));
		exit(1);
	}
	/* Read the header, which is at the beginning of the file... */
	i = read(infile, &ex, sizeof ex);
	if (i != sizeof ex) {
		fprintf(stderr, "ex: %s: %s.\n",
		    argv[1], i ? strerror(errno) : "End of file reached");
		exit(1);
	}
	/* Read the program headers... */
	ph = (Elf32_Phdr *) saveRead(infile, ex.e_phoff,
	    ex.e_phnum * sizeof(Elf32_Phdr), "ph");
	/* Read the section headers... */
	sh = (Elf32_Shdr *) saveRead(infile, ex.e_shoff,
	    ex.e_shnum * sizeof(Elf32_Shdr), "sh");
	/* Read in the section string table. */
	shstrtab = saveRead(infile, sh[ex.e_shstrndx].sh_offset,
	    sh[ex.e_shstrndx].sh_size, "shstrtab");

	/* Find space for a table matching ELF section indices to a.out symbol
	 * types. */
	symTypeTable = (int *) malloc(ex.e_shnum * sizeof(int));
	if (!symTypeTable) {
		fprintf(stderr, "symTypeTable: can't allocate.\n");
		exit(1);
	}
	memset(symTypeTable, 0, ex.e_shnum * sizeof(int));

	/* Look for the symbol table and string table... Also map section
	 * indices to symbol types for a.out */
	for (i = 0; i < ex.e_shnum; i++) {
		char   *name = shstrtab + sh[i].sh_name;
		if (!strcmp(name, ".symtab"))
			symtabix = i;
		else
			if (!strcmp(name, ".strtab"))
				strtabix = i;
			else
				if (!strcmp(name, ".text") || !strcmp(name, ".rodata"))
					symTypeTable[i] = N_TEXT;
				else
					if (!strcmp(name, ".data") || !strcmp(name, ".sdata") ||
					    !strcmp(name, ".lit4") || !strcmp(name, ".lit8"))
						symTypeTable[i] = N_DATA;
					else
						if (!strcmp(name, ".bss") || !strcmp(name, ".sbss"))
							symTypeTable[i] = N_BSS;
	}

	/* Figure out if we can cram the program header into an a.out
	 * header... Basically, we can't handle anything but loadable
	 * segments, but we can ignore some kinds of segments.   We can't
	 * handle holes in the address space, and we handle start addresses
	 * other than 0x1000 by hoping that the loader will know where to load
	 * - a.out doesn't have an explicit load address.   Segments may be
	 * out of order, so we sort them first. */
	qsort(ph, ex.e_phnum, sizeof(Elf32_Phdr), phcmp);
	for (i = 0; i < ex.e_phnum; i++) {
		/* Section types we can ignore... */
		if (ph[i].p_type == PT_NULL || ph[i].p_type == PT_NOTE ||
		    ph[i].p_type == PT_PHDR || ph[i].p_type == PT_MIPS_REGINFO)
			continue;
		/* Section types we can't handle... */
		else
			if (ph[i].p_type != PT_LOAD)
				errx(1, "Program header %d type %d can't be converted.", i, ph[i].p_type);
		/* Writable (data) segment? */
		if (ph[i].p_flags & PF_W) {
			struct sect ndata, nbss;

			ndata.vaddr = ph[i].p_vaddr;
			ndata.len = ph[i].p_filesz;
			nbss.vaddr = ph[i].p_vaddr + ph[i].p_filesz;
			nbss.len = ph[i].p_memsz - ph[i].p_filesz;

			combine(&data, &ndata, 0);
			combine(&bss, &nbss, 1);
		} else {
			struct sect ntxt;

			ntxt.vaddr = ph[i].p_vaddr;
			ntxt.len = ph[i].p_filesz;

			combine(&text, &ntxt, 0);
d279 13
a291 88
		/* Remember the lowest segment start address. */
		if (ph[i].p_vaddr < cur_vma)
			cur_vma = ph[i].p_vaddr;
	}

	/* Sections must be in order to be converted... */
	if (text.vaddr > data.vaddr || data.vaddr > bss.vaddr ||
	    text.vaddr + text.len > data.vaddr || data.vaddr + data.len > bss.vaddr) {
		fprintf(stderr, "Sections ordering prevents a.out conversion.\n");
		exit(1);
	}
	/* If there's a data section but no text section, then the loader
	 * combined everything into one section.   That needs to be the text
	 * section, so just make the data section zero length following text. */
	if (data.len && !text.len) {
		text = data;
		data.vaddr = text.vaddr + text.len;
		data.len = 0;
	}
	/* If there is a gap between text and data, we'll fill it when we copy
	 * the data, so update the length of the text segment as represented
	 * in a.out to reflect that, since a.out doesn't allow gaps in the
	 * program address space. */
	if (text.vaddr + text.len < data.vaddr)
		text.len = data.vaddr - text.vaddr;

	/* We now have enough information to cons up an a.out header... */
	aex.a_midmag = htonl((symflag << 26) | (MID_PMAX << 16) | OMAGIC);
	if (ex.e_machine == EM_PPC)
		aex.a_midmag = htonl((symflag << 26) | (MID_POWERPC << 16)
			| OMAGIC);
		
	aex.a_text = text.len;
	aex.a_data = data.len;
	aex.a_bss = bss.len;
	aex.a_entry = ex.e_entry;
	aex.a_syms = (sizeof(struct nlist) *
	    (symtabix != -1
		? sh[symtabix].sh_size / sizeof(Elf32_Sym) : 0));
	aex.a_trsize = 0;
	aex.a_drsize = 0;

	/* Make the output file... */
	if ((outfile = open(argv[2], O_WRONLY | O_CREAT, 0777)) < 0) {
		fprintf(stderr, "Unable to create %s: %s\n", argv[2], strerror(errno));
		exit(1);
	}
	/* Truncate file... */
	if (ftruncate(outfile, 0)) {
		warn("ftruncate %s", argv[2]);
	}
	/* Write the header... */
	i = write(outfile, &aex, sizeof aex);
	if (i != sizeof aex) {
		perror("aex: write");
		exit(1);
	}
	/* Copy the loadable sections.   Zero-fill any gaps less than 64k;
	 * complain about any zero-filling, and die if we're asked to
	 * zero-fill more than 64k. */
	for (i = 0; i < ex.e_phnum; i++) {
		/* Unprocessable sections were handled above, so just verify
		 * that the section can be loaded before copying. */
		if (ph[i].p_type == PT_LOAD && ph[i].p_filesz) {
			if (cur_vma != ph[i].p_vaddr) {
				unsigned long gap = ph[i].p_vaddr - cur_vma;
				char    obuf[1024];
				if (gap > 65536)
					errx(1,
			"Intersegment gap (%ld bytes) too large.", (long) gap);
#ifdef DEBUG
				warnx("Warning: %ld byte intersegment gap.",
				    (long)gap);
#endif
				memset(obuf, 0, sizeof obuf);
				while (gap) {
					int     count = write(outfile, obuf, (gap > sizeof obuf
						? sizeof obuf : gap));
					if (count < 0) {
						fprintf(stderr, "Error writing gap: %s\n",
						    strerror(errno));
						exit(1);
					}
					gap -= count;
				}
			}
			copy(outfile, infile, ph[i].p_offset, ph[i].p_filesz);
			cur_vma = ph[i].p_vaddr + ph[i].p_filesz;
d293 10
a302 1
	}
d304 3
a306 4
	/* Copy and translate the symbol table... */
	translate_syms(outfile, infile,
	    sh[symtabix].sh_offset, sh[symtabix].sh_size,
	    sh[strtabix].sh_offset, sh[strtabix].sh_size);
a307 3
	/* Looks like we won... */
	exit(0);
}
d313 4
a316 5
void
translate_syms(out, in, symoff, symsize, stroff, strsize)
	int     out, in;
	off_t   symoff, symsize;
	off_t   stroff, strsize;
d318 102
a419 103
#define SYMS_PER_PASS	64
	Elf32_Sym inbuf[64];
	struct nlist outbuf[64];
	int     i, remaining, cur;
	char   *oldstrings;
	char   *newstrings, *nsp;
	int     newstringsize;

	/* Zero the unused fields in the output buffer.. */
	memset(outbuf, 0, sizeof outbuf);

	/* Find number of symbols to process... */
	remaining = symsize / sizeof(Elf32_Sym);

	/* Suck in the old string table... */
	oldstrings = saveRead(in, stroff, strsize, "string table");

	/* Allocate space for the new one.   XXX We make the wild assumption
	 * that no two symbol table entries will point at the same place in
	 * the string table - if that assumption is bad, this could easily
	 * blow up. */
	newstringsize = strsize + remaining;
	newstrings = (char *) malloc(newstringsize);
	if (!newstrings) {
		fprintf(stderr, "No memory for new string table!\n");
		exit(1);
	}
	/* Initialize the table pointer... */
	nsp = newstrings;

	/* Go the start of the ELF symbol table... */
	if (lseek(in, symoff, SEEK_SET) < 0) {
		perror("translate_syms: lseek");
		exit(1);
	}
	/* Translate and copy symbols... */
	while (remaining) {
		cur = remaining;
		if (cur > SYMS_PER_PASS)
			cur = SYMS_PER_PASS;
		remaining -= cur;
		if ((i = read(in, inbuf, cur * sizeof(Elf32_Sym)))
		    != cur * sizeof(Elf32_Sym)) {
			if (i < 0)
				perror("translate_syms");
			else
				fprintf(stderr, "translate_syms: premature end of file.\n");
			exit(1);
		}
		/* Do the translation... */
		for (i = 0; i < cur; i++) {
			int     binding, type;

			/* Copy the symbol into the new table, but prepend an
			 * underscore. */
			*nsp = '_';
			strcpy(nsp + 1, oldstrings + inbuf[i].st_name);
			outbuf[i].n_un.n_strx = nsp - newstrings + 4;
			nsp += strlen(nsp) + 1;

			type = ELF32_ST_TYPE(inbuf[i].st_info);
			binding = ELF32_ST_BIND(inbuf[i].st_info);

			/* Convert ELF symbol type/section/etc info into a.out
			 * type info. */
			if (type == STT_FILE)
				outbuf[i].n_type = N_FN;
			else
				if (inbuf[i].st_shndx == SHN_UNDEF)
					outbuf[i].n_type = N_UNDF;
				else
					if (inbuf[i].st_shndx == SHN_ABS)
						outbuf[i].n_type = N_ABS;
					else
						if (inbuf[i].st_shndx == SHN_COMMON ||
						    inbuf[i].st_shndx == SHN_MIPS_ACOMMON)
							outbuf[i].n_type = N_COMM;
						else
							outbuf[i].n_type = symTypeTable[inbuf[i].st_shndx];
			if (binding == STB_GLOBAL)
				outbuf[i].n_type |= N_EXT;
			/* Symbol values in executables should be compatible. */
			outbuf[i].n_value = inbuf[i].st_value;
		}
		/* Write out the symbols... */
		if ((i = write(out, outbuf, cur * sizeof(struct nlist)))
		    != cur * sizeof(struct nlist)) {
			fprintf(stderr, "translate_syms: write: %s\n", strerror(errno));
			exit(1);
		}
	}
	/* Write out the string table length... */
	if (write(out, &newstringsize, sizeof newstringsize)
	    != sizeof newstringsize) {
		fprintf(stderr,
		    "translate_syms: newstringsize: %s\n", strerror(errno));
		exit(1);
	}
	/* Write out the string table... */
	if (write(out, newstrings, newstringsize) != newstringsize) {
		fprintf(stderr, "translate_syms: newstrings: %s\n", strerror(errno));
		exit(1);
	}
d421 4
a424 5

void
copy(out, in, offset, size)
	int     out, in;
	off_t   offset, size;
d426 2
a427 2
	char    ibuf[4096];
	int     remaining, cur, count;
d429 24
a452 20
	/* Go the the start of the ELF symbol table... */
	if (lseek(in, offset, SEEK_SET) < 0) {
		perror("copy: lseek");
		exit(1);
	}
	remaining = size;
	while (remaining) {
		cur = remaining;
		if (cur > sizeof ibuf)
			cur = sizeof ibuf;
		remaining -= cur;
		if ((count = read(in, ibuf, cur)) != cur) {
			fprintf(stderr, "copy: read: %s\n",
			    count ? strerror(errno) : "premature end of file");
			exit(1);
		}
		if ((count = write(out, ibuf, cur)) != cur) {
			perror("copy: write");
			exit(1);
		}
d454 1
d456 1
d459 3
a461 4
void
combine(base, new, pad)
	struct sect *base, *new;
	int     pad;
d463 17
a479 15
	if (!base->len)
		*base = *new;
	else
		if (new->len) {
			if (base->vaddr + base->len != new->vaddr) {
				if (pad)
					base->len = new->vaddr - base->vaddr;
				else {
					fprintf(stderr,
					    "Non-contiguous data can't be converted.\n");
					exit(1);
				}
			}
			base->len += new->len;
		}
d482 2
a483 3
int
phcmp(vh1, vh2)
	const void *vh1, *vh2;
d485 6
a490 11
	Elf32_Phdr *h1, *h2;
	h1 = (Elf32_Phdr *) vh1;
	h2 = (Elf32_Phdr *) vh2;

	if (h1->p_vaddr > h2->p_vaddr)
		return 1;
	else
		if (h1->p_vaddr < h2->p_vaddr)
			return -1;
		else
			return 0;
d493 1
a493 2
char   *
saveRead(int file, off_t offset, off_t len, char *name)
d495 21
a515 16
	char   *tmp;
	int     count;
	off_t   off;
	if ((off = lseek(file, offset, SEEK_SET)) < 0) {
		fprintf(stderr, "%s: fseek: %s\n", name, strerror(errno));
		exit(1);
	}
	if (!(tmp = (char *) malloc(len)))
		errx(1, "%s: Can't allocate %ld bytes.", name, (long)len);
	count = read(file, tmp, len);
	if (count != len) {
		fprintf(stderr, "%s: read: %s.\n",
		    name, count ? strerror(errno) : "End of file reached");
		exit(1);
	}
	return tmp;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/* $OpenBSD: elf2aout.c,v 1.3 2003/06/10 22:20:46 deraadt Exp $	 */
d44 1
a44 1
extern char    *__progname;
d47 2
a48 2
	unsigned long   vaddr;
	unsigned long   len;
d50 6
a55 6
int             phcmp();
char           *saveRead(int file, off_t offset, off_t len, char *name);
int             copy(int, int, off_t, off_t);
int             translate_syms(int, int, off_t, off_t, off_t, off_t);
extern int      errno;
int            *symTypeTable;
d59 7
a65 8
	unsigned long   name;	/* Index into strtab of symbol name. */
	unsigned long   value;	/* Section offset, virt addr or common align. */
	unsigned long   size;	/* Size of object referenced. */
	unsigned        type:4;	/* Symbol type (e.g., function, data)... */
	unsigned        binding:4;	/* Symbol binding (e.g., global,
					 * local)... */
	unsigned char   other;	/* Unused. */
	unsigned short  shndx;	/* Section containing symbol. */
d69 8
a76 8
	unsigned long   type;	/* Segment type... */
	unsigned long   offset;	/* File offset... */
	unsigned long   vaddr;	/* Virtual address... */
	unsigned long   paddr;	/* Physical address... */
	unsigned long   filesz;	/* Size of segment in file... */
	unsigned long   memsz;	/* Size of segment in memory... */
	unsigned long   flags;	/* Segment flags... */
	unsigned long   align;	/* Alighment, file and memory... */
d79 1
a79 2
int
main(int argc, char *argv[])
d81 197
a277 115
	Elf32_Ehdr      ex;
	Elf32_Phdr     *ph;
	Elf32_Shdr     *sh;
	struct sym     *symtab;
	char           *shstrtab;
	int             strtabix, symtabix;
	int             i;
	struct sect     text, data, bss;
	struct exec     aex;
	int             infile, outfile;
	unsigned long   cur_vma = ULONG_MAX;
	int             symflag = 0;

	text.len = data.len = bss.len = 0;
	text.vaddr = data.vaddr = bss.vaddr = 0;

	/* Check args... */
	if (argc < 3 || argc > 4) {
usage:
		fprintf(stderr,
		    "usage: %s elf a.out\n", __progname);
		exit(1);
	}
	/* Try the input file... */
	if ((infile = open(argv[1], O_RDONLY)) < 0) {
		fprintf(stderr, "Can't open %s for read: %s\n",
			argv[1], strerror(errno));
		exit(1);
	}
	/* Read the header, which is at the beginning of the file... */
	i = read(infile, &ex, sizeof ex);
	if (i != sizeof ex) {
		fprintf(stderr, "ex: %s: %s.\n",
		    argv[1], i ? strerror(errno) : "End of file reached");
		exit(1);
	}
	/* Read the program headers... */
	ph = (Elf32_Phdr *) saveRead(infile, ex.e_phoff,
				     ex.e_phnum * sizeof(Elf32_Phdr), "ph");
	/* Read the section headers... */
	sh = (Elf32_Shdr *) saveRead(infile, ex.e_shoff,
				     ex.e_shnum * sizeof(Elf32_Shdr), "sh");
	/* Read in the section string table. */
	shstrtab = saveRead(infile, sh[ex.e_shstrndx].sh_offset,
			    sh[ex.e_shstrndx].sh_size, "shstrtab");

	/*
	 * Find space for a table matching ELF section indices to a.out
	 * symbol types.
	 */
	symTypeTable = (int *) malloc(ex.e_shnum * sizeof(int));
	if (!symTypeTable) {
		fprintf(stderr, "symTypeTable: can't allocate.\n");
		exit(1);
	}
	memset(symTypeTable, 0, ex.e_shnum * sizeof(int));

	/*
	 * Look for the symbol table and string table... Also map section
	 * indices to symbol types for a.out
	 */
	for (i = 0; i < ex.e_shnum; i++) {
		char           *name = shstrtab + sh[i].sh_name;
		if (!strcmp(name, ".symtab"))
			symtabix = i;
		else if (!strcmp(name, ".strtab"))
			strtabix = i;
		else if (!strcmp(name, ".text") || !strcmp(name, ".rodata"))
			symTypeTable[i] = N_TEXT;
		else if (!strcmp(name, ".data") || !strcmp(name, ".sdata") ||
			 !strcmp(name, ".lit4") || !strcmp(name, ".lit8"))
			symTypeTable[i] = N_DATA;
		else if (!strcmp(name, ".bss") || !strcmp(name, ".sbss"))
			symTypeTable[i] = N_BSS;
	}

	/*
	 * Figure out if we can cram the program header into an a.out
	 * header... Basically, we can't handle anything but loadable
	 * segments, but we can ignore some kinds of segments.   We can't
	 * handle holes in the address space, and we handle start addresses
	 * other than 0x1000 by hoping that the loader will know where to
	 * load - a.out doesn't have an explicit load address.   Segments may
	 * be out of order, so we sort them first.
	 */
	qsort(ph, ex.e_phnum, sizeof(Elf32_Phdr), phcmp);
	for (i = 0; i < ex.e_phnum; i++) {
		/* Section types we can ignore... */
		if (ph[i].p_type == PT_NULL || ph[i].p_type == PT_NOTE ||
		 ph[i].p_type == PT_PHDR || ph[i].p_type == PT_MIPS_REGINFO)
			continue;
		/* Section types we can't handle... */
		else if (ph[i].p_type != PT_LOAD) {
			fprintf(stderr,
			    "Program header %d type %d can't be converted.\n");
			exit(1);
		}
		/* Writable (data) segment? */
		if (ph[i].p_flags & PF_W) {
			struct sect     ndata, nbss;

			ndata.vaddr = ph[i].p_vaddr;
			ndata.len = ph[i].p_filesz;
			nbss.vaddr = ph[i].p_vaddr + ph[i].p_filesz;
			nbss.len = ph[i].p_memsz - ph[i].p_filesz;

			combine(&data, &ndata, 0);
			combine(&bss, &nbss, 1);
		} else {
			struct sect     ntxt;

			ntxt.vaddr = ph[i].p_vaddr;
			ntxt.len = ph[i].p_filesz;

			combine(&text, &ntxt);
d279 13
a291 91
		/* Remember the lowest segment start address. */
		if (ph[i].p_vaddr < cur_vma)
			cur_vma = ph[i].p_vaddr;
	}

	/* Sections must be in order to be converted... */
	if (text.vaddr > data.vaddr || data.vaddr > bss.vaddr ||
	    text.vaddr + text.len > data.vaddr || data.vaddr + data.len > bss.vaddr) {
		fprintf(stderr, "Sections ordering prevents a.out conversion.\n");
		exit(1);
	}
	/*
	 * If there's a data section but no text section, then the loader
	 * combined everything into one section.   That needs to be the text
	 * section, so just make the data section zero length following text.
	 */
	if (data.len && !text.len) {
		text = data;
		data.vaddr = text.vaddr + text.len;
		data.len = 0;
	}
	/*
	 * If there is a gap between text and data, we'll fill it when we
	 * copy the data, so update the length of the text segment as
	 * represented in a.out to reflect that, since a.out doesn't allow
	 * gaps in the program address space.
	 */
	if (text.vaddr + text.len < data.vaddr)
		text.len = data.vaddr - text.vaddr;

	/* We now have enough information to cons up an a.out header... */
	aex.a_midmag = htonl((symflag << 26) | (MID_PMAX << 16) | OMAGIC);
	aex.a_text = text.len;
	aex.a_data = data.len;
	aex.a_bss = bss.len;
	aex.a_entry = ex.e_entry;
	aex.a_syms = (sizeof(struct nlist) *
		      (symtabix != -1
		       ? sh[symtabix].sh_size / sizeof(struct sym) : 0));
	aex.a_trsize = 0;
	aex.a_drsize = 0;

	/* Make the output file... */
	if ((outfile = open(argv[2], O_WRONLY | O_CREAT, 0777)) < 0) {
		fprintf(stderr, "Unable to create %s: %s\n", argv[2], strerror(errno));
		exit(1);
	}
	/* Write the header... */
	i = write(outfile, &aex, sizeof aex);
	if (i != sizeof aex) {
		perror("aex: write");
		exit(1);
	}
	/*
	 * Copy the loadable sections.   Zero-fill any gaps less than 64k;
	 * complain about any zero-filling, and die if we're asked to
	 * zero-fill more than 64k.
	 */
	for (i = 0; i < ex.e_phnum; i++) {
		/*
		 * Unprocessable sections were handled above, so just verify
		 * that the section can be loaded before copying.
		 */
		if (ph[i].p_type == PT_LOAD && ph[i].p_filesz) {
			if (cur_vma != ph[i].p_vaddr) {
				unsigned long   gap = ph[i].p_vaddr - cur_vma;
				char obuf[1024];

				if (gap > 65536) {
					fprintf(stderr,
					    "Intersegment gap (%d bytes) too large.\n",
					    gap);
					exit(1);
				}
				fprintf(stderr,
				    "Warning: %d byte intersegment gap.\n", gap);
				memset(obuf, 0, sizeof obuf);
				while (gap) {
					int count = write(outfile, obuf,
					    (gap > sizeof obuf ? sizeof obuf : gap));
					if (count < 0) {
						fprintf(stderr,
						    "Error writing gap: %s\n",
						    strerror(errno));
						exit(1);
					}
					gap -= count;
				}
			}
			copy(outfile, infile, ph[i].p_offset, ph[i].p_filesz);
			cur_vma = ph[i].p_vaddr + ph[i].p_filesz;
d293 10
a302 1
	}
d304 3
a306 4
	/* Copy and translate the symbol table... */
	translate_syms(outfile, infile, sh[symtabix].sh_offset,
		       sh[symtabix].sh_size,
		       sh[strtabix].sh_offset, sh[strtabix].sh_size);
d308 1
a308 3
	/* Looks like we won... */
	exit(0);
}
d310 2
a311 6
/*
 * translate_syms (out, in, offset, size)
 * 
 * Read the ELF symbol table from in at offset; translate it into a.out nlist
 * format and write it to out.
 */
d313 4
a316 2
translate_syms(int out, int in, off_t symoff, off_t symsize, off_t stroff,
    off_t strsize)
d318 102
a419 102
#define SYMS_PER_PASS	64
	struct sym      inbuf[64];
	struct nlist    outbuf[64];
	int             i, remaining, cur;
	char           *oldstrings;
	char           *newstrings, *nsp;
	int             newstringsize;

	/* Zero the unused fields in the output buffer.. */
	memset(outbuf, 0, sizeof outbuf);

	/* Find number of symbols to process... */
	remaining = symsize / sizeof(struct sym);

	/* Suck in the old string table... */
	oldstrings = saveRead(in, stroff, strsize, "string table");

	/*
	 * Allocate space for the new one.   XXX We make the wild assumption
	 * that no two symbol table entries will point at the same place in
	 * the string table - if that assumption is bad, this could easily
	 * blow up.
	 */
	newstringsize = strsize + remaining;
	newstrings = (char *) malloc(newstringsize);
	if (!newstrings) {
		fprintf(stderr, "No memory for new string table!\n");
		exit(1);
	}
	/* Initialize the table pointer... */
	nsp = newstrings;

	/* Go the the start of the ELF symbol table... */
	if (lseek(in, symoff, SEEK_SET) < 0) {
		perror("translate_syms: lseek");
		exit(1);
	}
	/* Translate and copy symbols... */
	while (remaining) {
		cur = remaining;
		if (cur > SYMS_PER_PASS)
			cur = SYMS_PER_PASS;
		remaining -= cur;
		if ((i = read(in, inbuf, cur * sizeof(struct sym)))
		    != cur * sizeof(struct sym)) {
			if (i < 0)
				perror("translate_syms");
			else
				fprintf(stderr,
				    "translate_syms: premature end of file.\n");
			exit(1);
		}
		/* Do the translation... */
		for (i = 0; i < cur; i++) {
			/*
			 * Copy the symbol into the new table, but prepend an
			 * underscore.
			 */
			*nsp = '_';
			strcpy(nsp + 1, oldstrings + inbuf[i].name);
			outbuf[i].n_un.n_strx = nsp - newstrings + 4;
			nsp += strlen(nsp) + 1;

			/*
			 * Convert ELF symbol type/section/etc info into
			 * a.out type info.
			 */
			if (inbuf[i].type == STT_FILE)
				outbuf[i].n_type = N_FN;
			else if (inbuf[i].shndx == SHN_UNDEF)
				outbuf[i].n_type = N_UNDF;
			else if (inbuf[i].shndx == SHN_ABS)
				outbuf[i].n_type = N_ABS;
			else if (inbuf[i].shndx == SHN_COMMON ||
				 inbuf[i].shndx == SHN_MIPS_ACOMMON)
				outbuf[i].n_type = N_COMM;
			else
				outbuf[i].n_type = symTypeTable[inbuf[i].shndx];
			if (inbuf[i].binding == STB_GLOBAL)
				outbuf[i].n_type |= N_EXT;
			/* Symbol values in executables should be compatible. */
			outbuf[i].n_value = inbuf[i].value;
		}
		/* Write out the symbols... */
		if ((i = write(out, outbuf, cur * sizeof(struct nlist)))
		    != cur * sizeof(struct nlist)) {
			fprintf(stderr, "translate_syms: write: %s\n", strerror(errno));
			exit(1);
		}
	}
	/* Write out the string table length... */
	if (write(out, &newstringsize, sizeof newstringsize)
	    != sizeof newstringsize) {
		fprintf(stderr,
		    "translate_syms: newstringsize: %s\n", strerror(errno));
		exit(1);
	}
	/* Write out the string table... */
	if (write(out, newstrings, newstringsize) != newstringsize) {
		fprintf(stderr, "translate_syms: newstrings: %s\n", strerror(errno));
		exit(1);
	}
d421 4
a424 2

copy(int out, int in, off_t offset, off_t size)
d426 2
a427 2
	char ibuf[4096];
	int  remaining, cur, count;
d429 24
a452 20
	/* Go the the start of the ELF symbol table... */
	if (lseek(in, offset, SEEK_SET) < 0) {
		perror("copy: lseek");
		exit(1);
	}
	remaining = size;
	while (remaining) {
		cur = remaining;
		if (cur > sizeof ibuf)
			cur = sizeof ibuf;
		remaining -= cur;
		if ((count = read(in, ibuf, cur)) != cur) {
			fprintf(stderr, "copy: read: %s\n",
			 count ? strerror(errno) : "premature end of file");
			exit(1);
		}
		if ((count = write(out, ibuf, cur)) != cur) {
			perror("copy: write");
			exit(1);
		}
d454 1
d457 5
a461 5
/*
 * Combine two segments, which must be contiguous.   If pad is true, it's
 * okay for there to be padding between.
 */
combine(struct sect * base, struct sect * new, int pad)
d463 14
a476 13
	if (!base->len)
		*base = *new;
	else if (new->len) {
		if (base->vaddr + base->len != new->vaddr) {
			if (pad)
				base->len = new->vaddr - base->vaddr;
			else {
				fprintf(stderr,
				"Non-contiguous data can't be converted.\n");
				exit(1);
			}
		}
		base->len += new->len;
d478 2
d482 2
a483 1
phcmp(struct phdr * h1, struct phdr * h2)
d485 6
a490 6
	if (h1->vaddr > h2->vaddr)
		return 1;
	else if (h1->vaddr < h2->vaddr)
		return -1;
	else
		return 0;
d493 1
a493 2
char           *
saveRead(int file, off_t offset, off_t len, char *name)
d495 21
a515 19
	char           *tmp;
	int             count;
	off_t           off;

	if ((off = lseek(file, offset, SEEK_SET)) < 0) {
		fprintf(stderr, "%s: fseek: %s\n", name, strerror(errno));
		exit(1);
	}
	if (!(tmp = (char *) malloc(len))) {
		fprintf(stderr, "%s: Can't allocate %d bytes.\n", name, len);
		exit(1);
	}
	count = read(file, tmp, len);
	if (count != len) {
		fprintf(stderr, "%s: read: %s.\n",
		     name, count ? strerror(errno) : "End of file reached");
		exit(1);
	}
	return tmp;
@


1.1.1.3
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/* $OpenBSD: elf2aout.c,v 1.4 2003/11/27 10:31:52 henning Exp $	 */
d177 1
a177 2
			    "Program header %d type %d can't be converted.\n",
			    i, ph[i].p_type);
d344 1
a344 1
	/* Go to the start of the ELF symbol table... */
d421 1
a421 1
	/* Go to the start of the ELF symbol table... */
@


1.1.1.4
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/* $OpenBSD: elf2aout.c,v 1.5 2004/03/16 01:11:09 tedu Exp $	 */
d38 1
a38 1
#include <errno.h>
d54 1
@


1.1.1.2.2.1
log
@OpenBSD "elf2aout" and "elf2ecoff" bite the dust. They cannot
really be used anyways.

NetBSD "elf2aout" will be used for making TFTP bootable SPARC ramdisks.
@
text
@d1 1
a1 1
/*	$NetBSD: elf2aout.c,v 1.10 2000/03/13 23:22:50 soren Exp $	*/
a30 6
/* elf2aout.c

   This program converts an elf executable to a NetBSD a.out executable.
   The minimal symbol table is copied, but the debugging symbols and
   other informational sections are not. */

a31 6
#include <sys/exec_aout.h>
#include <sys/exec_elf.h>

#include <a.out.h>
#include <err.h>
#include <errno.h>
d33 3
a35 1
#include <limits.h>
d37 2
a38 1
#include <stdlib.h>
d40 3
a42 1
#include <unistd.h>
d44 1
d47 20
a66 2
	unsigned long vaddr;
	unsigned long len;
d69 10
a78 7
void	combine __P((struct sect *, struct sect *, int));
int	phcmp __P((const void *, const void *));
char   *saveRead __P((int file, off_t offset, off_t len, char *name));
void	copy __P((int, int, off_t, off_t));
void	translate_syms __P((int, int, off_t, off_t, off_t, off_t));

int    *symTypeTable;
d81 1
a81 1
main(int argc, char **argv)
d83 12
a94 11
	Elf32_Ehdr ex;
	Elf32_Phdr *ph;
	Elf32_Shdr *sh;
	char   *shstrtab;
	int     strtabix, symtabix;
	int     i;
	struct sect text, data, bss;
	struct exec aex;
	int     infile, outfile;
	unsigned long cur_vma = ULONG_MAX;
	int     symflag = 0;
a95 1
	strtabix = symtabix = 0;
d103 1
a103 1
		    "usage: elf2aout <elf executable> <a.out executable> [-s]\n");
a105 5
	if (argc == 4) {
		if (strcmp(argv[3], "-s"))
			goto usage;
		symflag = 1;
	}
d109 1
a109 1
		    argv[1], strerror(errno));
d121 1
a121 1
	    ex.e_phnum * sizeof(Elf32_Phdr), "ph");
d124 1
a124 1
	    ex.e_shnum * sizeof(Elf32_Shdr), "sh");
d127 1
a127 1
	    sh[ex.e_shstrndx].sh_size, "shstrtab");
d129 4
a132 2
	/* Find space for a table matching ELF section indices to a.out symbol
	 * types. */
d140 4
a143 2
	/* Look for the symbol table and string table... Also map section
	 * indices to symbol types for a.out */
d145 1
a145 1
		char   *name = shstrtab + sh[i].sh_name;
d148 9
a156 13
		else
			if (!strcmp(name, ".strtab"))
				strtabix = i;
			else
				if (!strcmp(name, ".text") || !strcmp(name, ".rodata"))
					symTypeTable[i] = N_TEXT;
				else
					if (!strcmp(name, ".data") || !strcmp(name, ".sdata") ||
					    !strcmp(name, ".lit4") || !strcmp(name, ".lit8"))
						symTypeTable[i] = N_DATA;
					else
						if (!strcmp(name, ".bss") || !strcmp(name, ".sbss"))
							symTypeTable[i] = N_BSS;
d159 2
a160 1
	/* Figure out if we can cram the program header into an a.out
d164 4
a167 3
	 * other than 0x1000 by hoping that the loader will know where to load
	 * - a.out doesn't have an explicit load address.   Segments may be
	 * out of order, so we sort them first. */
d172 1
a172 1
		    ph[i].p_type == PT_PHDR || ph[i].p_type == PT_MIPS_REGINFO)
d175 5
a179 3
		else
			if (ph[i].p_type != PT_LOAD)
				errx(1, "Program header %d type %d can't be converted.", i, ph[i].p_type);
d182 1
a182 1
			struct sect ndata, nbss;
d192 1
a192 1
			struct sect ntxt;
d197 1
a197 1
			combine(&text, &ntxt, 0);
d210 2
a211 1
	/* If there's a data section but no text section, then the loader
d213 2
a214 1
	 * section, so just make the data section zero length following text. */
d220 6
a225 4
	/* If there is a gap between text and data, we'll fill it when we copy
	 * the data, so update the length of the text segment as represented
	 * in a.out to reflect that, since a.out doesn't allow gaps in the
	 * program address space. */
a230 4
	if (ex.e_machine == EM_PPC)
		aex.a_midmag = htonl((symflag << 26) | (MID_POWERPC << 16)
			| OMAGIC);
		
d236 2
a237 2
	    (symtabix != -1
		? sh[symtabix].sh_size / sizeof(Elf32_Sym) : 0));
a245 4
	/* Truncate file... */
	if (ftruncate(outfile, 0)) {
		warn("ftruncate %s", argv[2]);
	}
d252 2
a253 1
	/* Copy the loadable sections.   Zero-fill any gaps less than 64k;
d255 2
a256 1
	 * zero-fill more than 64k. */
d258 4
a261 2
		/* Unprocessable sections were handled above, so just verify
		 * that the section can be loaded before copying. */
d264 11
a274 9
				unsigned long gap = ph[i].p_vaddr - cur_vma;
				char    obuf[1024];
				if (gap > 65536)
					errx(1,
			"Intersegment gap (%ld bytes) too large.", (long) gap);
#ifdef DEBUG
				warnx("Warning: %ld byte intersegment gap.",
				    (long)gap);
#endif
d277 2
a278 2
					int     count = write(outfile, obuf, (gap > sizeof obuf
						? sizeof obuf : gap));
d280 2
a281 1
						fprintf(stderr, "Error writing gap: %s\n",
d294 3
a296 3
	translate_syms(outfile, infile,
	    sh[symtabix].sh_offset, sh[symtabix].sh_size,
	    sh[strtabix].sh_offset, sh[strtabix].sh_size);
a300 1
/* translate_syms (out, in, offset, size)
d302 6
a307 2
   Read the ELF symbol table from in at offset; translate it into a.out
   nlist format and write it to out. */
d309 2
a310 5
void
translate_syms(out, in, symoff, symsize, stroff, strsize)
	int     out, in;
	off_t   symoff, symsize;
	off_t   stroff, strsize;
d313 6
a318 6
	Elf32_Sym inbuf[64];
	struct nlist outbuf[64];
	int     i, remaining, cur;
	char   *oldstrings;
	char   *newstrings, *nsp;
	int     newstringsize;
d324 1
a324 1
	remaining = symsize / sizeof(Elf32_Sym);
d329 2
a330 1
	/* Allocate space for the new one.   XXX We make the wild assumption
d333 2
a334 1
	 * blow up. */
d344 1
a344 1
	/* Go the start of the ELF symbol table... */
d355 2
a356 2
		if ((i = read(in, inbuf, cur * sizeof(Elf32_Sym)))
		    != cur * sizeof(Elf32_Sym)) {
d360 2
a361 1
				fprintf(stderr, "translate_syms: premature end of file.\n");
d366 4
a369 4
			int     binding, type;

			/* Copy the symbol into the new table, but prepend an
			 * underscore. */
d371 1
a371 1
			strcpy(nsp + 1, oldstrings + inbuf[i].st_name);
d375 5
a379 6
			type = ELF32_ST_TYPE(inbuf[i].st_info);
			binding = ELF32_ST_BIND(inbuf[i].st_info);

			/* Convert ELF symbol type/section/etc info into a.out
			 * type info. */
			if (type == STT_FILE)
d381 7
d389 2
a390 12
				if (inbuf[i].st_shndx == SHN_UNDEF)
					outbuf[i].n_type = N_UNDF;
				else
					if (inbuf[i].st_shndx == SHN_ABS)
						outbuf[i].n_type = N_ABS;
					else
						if (inbuf[i].st_shndx == SHN_COMMON ||
						    inbuf[i].st_shndx == SHN_MIPS_ACOMMON)
							outbuf[i].n_type = N_COMM;
						else
							outbuf[i].n_type = symTypeTable[inbuf[i].st_shndx];
			if (binding == STB_GLOBAL)
d393 1
a393 1
			outbuf[i].n_value = inbuf[i].st_value;
d416 1
a416 4
void
copy(out, in, offset, size)
	int     out, in;
	off_t   offset, size;
d418 2
a419 2
	char    ibuf[4096];
	int     remaining, cur, count;
d434 1
a434 1
			    count ? strerror(errno) : "premature end of file");
d443 6
a448 6
/* Combine two segments, which must be contiguous.   If pad is true, it's
   okay for there to be padding between. */
void
combine(base, new, pad)
	struct sect *base, *new;
	int     pad;
d452 8
a459 10
	else
		if (new->len) {
			if (base->vaddr + base->len != new->vaddr) {
				if (pad)
					base->len = new->vaddr - base->vaddr;
				else {
					fprintf(stderr,
					    "Non-contiguous data can't be converted.\n");
					exit(1);
				}
a460 1
			base->len += new->len;
d462 2
d466 1
a466 3
int
phcmp(vh1, vh2)
	const void *vh1, *vh2;
d468 1
a468 5
	Elf32_Phdr *h1, *h2;
	h1 = (Elf32_Phdr *) vh1;
	h2 = (Elf32_Phdr *) vh2;

	if (h1->p_vaddr > h2->p_vaddr)
d470 2
d473 1
a473 4
		if (h1->p_vaddr < h2->p_vaddr)
			return -1;
		else
			return 0;
d476 1
a476 1
char   *
d479 4
a482 3
	char   *tmp;
	int     count;
	off_t   off;
d487 4
a490 2
	if (!(tmp = (char *) malloc(len)))
		errx(1, "%s: Can't allocate %ld bytes.", name, (long)len);
d494 1
a494 1
		    name, count ? strerror(errno) : "End of file reached");
@


1.1.1.2.2.2
log
@MirOSify
@
text
@a0 1
/*	$MirBSD$	*/
d18 1
a18 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND
d216 1
a216 1

@


1.1.1.2.2.3
log
@KNF
@
text
@d1 1
a1 1
/*	$MirBSD: elf2aout.c,v 1.1.1.2.2.2 2003/11/09 17:48:47 tg Exp $	*/
d58 5
a62 5
void	combine(struct sect *, struct sect *, int);
int	phcmp(const void *, const void *);
char   *saveRead(int, off_t, off_t, char *);
void	copy(int, int, off_t, off_t);
void	translate_syms(int, int, off_t, off_t, off_t, off_t);
a284 1

d289 1
d291 4
a294 2
translate_syms(int out, int in, off_t symoff, off_t symsize,
    off_t stroff, off_t strsize)
d402 3
a404 1
copy(int out, int in, off_t offset, off_t size)
a430 1

d434 3
a436 1
combine(struct sect *base, struct sect *new, int pad)
d456 2
a457 1
phcmp(const void *vh1, const void *vh2)
d472 1
a472 1
char *
@


1.1.1.2.2.4
log
@extend, to allow for multi-machine conversions and
more than one target MID per source EM.

adjust man page appropiately, and document the -s option while here.
@
text
@d1 1
a1 1
/*	$MirBSD: elf2aout.c,v 1.1.1.2.2.3 2003/11/09 17:51:46 tg Exp $	*/
d74 1
a74 1
	int     i, newmid;
a79 1
	int	bootflag = 0;
d89 1
a89 1
		    "usage: elf2aout <elf executable> <a.out executable> [-sb]\n");
d93 3
a95 11
		if (!strcmp(argv[3], "-s"))
			symflag = 1;
		else if (!strcmp(argv[3], "-b"))
			bootflag = 1;
		else if (!strcmp(argv[3], "-sb")) {
			symflag = 1;
			bootflag = 1;
		} else if (!strcmp(argv[3], "-bs")) {
			symflag = 1;
			bootflag = 1;
		} else	goto usage;
d213 5
a217 41
	newmid = MID_ZERO;
	switch (ex.e_machine) {
		case EM_ALPHA:
		case EM_ALPHA_EXP:
			newmid = MID_ALPHA;
			break;
		case EM_386:
		case EM_486:
			newmid = MID_I386;
			break;
		case EM_68K:
			newmid = MID_M68K;
			break;
		case EM_88K:
			newmid = MID_M88K;
			break;
		case EM_MIPS:
			newmid = (bootflag ? MID_PMAX : MID_MIPS);
			break;
		case EM_PPC:
			newmid = MID_PPC;
			break;
		case EM_SPARC:
			newmid = (bootflag ? 0x0103 : MID_SPARC);
			break;
		case EM_SPARC64:
		case EM_SPARCV9:
			newmid = (bootflag ? 0x0103 : MID_SPARC64);
			break;
		case EM_VAX:
			newmid = MID_VAX;
			break;
		case EM_NONE:
			break;
		default:
			fprintf(stderr,
			    "Warning: Machine %04X unknown, using MID_ZERO\n",
			    ex.e_machine);
			break;
	}
	aex.a_midmag = htonl((symflag << 26) | (newmid << 16) | OMAGIC);
@


1.1.1.2.2.5
log
@make compile
@
text
@d1 1
a1 1
/*	$MirBSD: elf2aout.c,v 1.1.1.2.2.4 2003/11/09 18:16:36 tg Exp $	*/
d170 1
a170 1
		    ph[i].p_type == PT_PHDR)
d242 1
a242 1
			newmid = MID_POWERPC;
d413 2
a414 1
						if (inbuf[i].st_shndx == SHN_COMMON)
@


1.1.1.2.2.6
log
@fix strcpy()
@
text
@d1 1
a1 1
/*	$MirBSD: elf2aout.c,v 1.1.1.2.2.5 2003/11/09 18:23:41 tg Exp $	*/
d395 1
a395 2
			strlcpy(nsp + 1, oldstrings + inbuf[i].st_name,
			    newstringsize - 1);
@


