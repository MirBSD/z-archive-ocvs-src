head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.9
	tg-mergefixes-1-branch:1.1.1.9.0.4
	tg-mergefixes-1-base:1.1.1.9
	MIROS_X:1.1.1.9.0.2
	MIROS_X_BASE:1.1.1.9
	tg-mergetmp-3:1.1.1.9
	cvs-200412031430:1.1.1.9
	MIRBSD_XP_MIRPPC:1.1.1.7.0.4
	cvs-200410222040:1.1.1.8
	tg-mergetmp-1:1.1.1.7
	MIRBSD_XP_SPARC_BASE:1.1.1.7
	MIRBSD_XP_SPARC:1.1.1.7.0.2
	MIRBSD_7quater:1.1.1.2.2.1
	cvs-200405160640:1.1.1.7
	cvs-200401271800:1.1.1.6
	cvs-200401261630:1.1.1.6
	cvs-200401021645:1.1.1.5
	MIRBSD_7_ALPHA:1.1.1.2.2.1.0.4
	MIRBSD_7:1.1.1.2.2.1.0.2
	cvs-200312222040:1.1.1.5
	cvs-200312031730:1.1.1.4
	MIRBSD_7ter:1.1.1.2.2.1
	cvs-200310232020:1.1.1.3
	MIRBSD_7_DEV:1.1.1.2.0.2
	cvs-200310081755:1.1.1.2
	cvs-200310020700:1.1.1.2
	cvs-200309271030:1.1.1.1
	cvs-200309261610:1.1.1.1
	cvs-200309251530:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.09.25.16.40.42;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.09.25.16.40.42;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.10.02.07.49.35;	author tg;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	2003.10.23.20.23.37;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.17.46.02;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.22.21.12.53;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.01.26.18.57.14;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.16.08.06.56;	author tg;	state Stab;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.10.22.20.49.20;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.12.03.14.35.06;	author tg;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	2003.10.23.20.49.13;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: bcode.c,v 1.5 2003/09/22 14:49:16 otto Exp $	*/

/*
 * Copyright (c) 2003, Otto Moerbeek <otto@@drijf.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef lint
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.5 2003/09/22 14:49:16 otto Exp $";
#endif /* not lint */

#include <ssl/ssl.h>
#include <err.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "extern.h"

BIGNUM		zero;
static bool	trace = false;

#define MAX_ARRAY_INDEX		2048
#define MAX_RECURSION		100

struct bmachine {
	struct stack		stack;
	u_int			scale;
	u_int			obase;
	u_int			ibase;
	int			readsp;
	struct stack		reg[UCHAR_MAX];
	struct source		readstack[MAX_RECURSION];
};

static struct bmachine	bmachine;

static __inline int	readch(void);
static __inline int	unreadch(void);
static __inline char	*readline(void);
static __inline void	src_free(void);

static __inline u_int	max(u_int, u_int);
static u_long		get_ulong(struct number *);

static __inline void	push_number(struct number *);
static __inline void	push_string(char *);
static __inline void	push(struct value *);
static __inline struct value *tos(void);
static __inline struct number	*pop_number(void);
static __inline char	*pop_string(void);
static __inline void	clear_stack(void);
static __inline void	print_tos(void);
static __inline void	pop_print(void);
static __inline void	print_stack();
static __inline void	dup(void);

static void		get_scale(void);
static void		set_scale(void);
static void		get_obase(void);
static void		set_obase(void);
static void		get_ibase(void);
static void		set_ibase(void);
static void		stackdepth(void);
static void		push_scale(void);
static u_int		count_digits(const struct number *);
static void		num_digits(void);

static void		push_line(void);
static void		bexec(char *);
static void		badd(void);
static void		bsub(void);
static void		bmul(void);
static void		bdiv(void);
static void		bmod(void);
static void		bexp(void);
static bool		bsqrt_stop(const BIGNUM *, const BIGNUM *);
static void		bsqrt(void);
static void		equal(void);
static void		not_equal(void);
static void		less(void);
static void		not_less(void);
static void		greater(void);
static void		not_greater(void);
static void		not_compare(void);
static void		compare(enum bcode_compare);
static void		load(void);
static void		store(void);
static void		load_stack(void);
static void		store_stack(void);
static void		load_array(void);
static void		store_array(void);
static void		nop(void);
static void		quit(void);
static void		quitN(void);
static void		parse_number(void);
static void		unknown(void);
static void		eval_string(char *);
static void		eval_line(void);
static void		eval_tos(void);


typedef void		(*opcode_function)(void);

struct jump_entry {
	u_char		ch;
	opcode_function	f;
};

static opcode_function jump_table[UCHAR_MAX];

static const struct jump_entry jump_table_data[] = {
	{ '0',	parse_number	},
	{ '1',	parse_number	},
	{ '2',	parse_number	},
	{ '3',	parse_number	},
	{ '4',	parse_number	},
	{ '5',	parse_number	},
	{ '6',	parse_number	},
	{ '7',	parse_number	},
	{ '8',	parse_number	},
	{ '9',	parse_number	},
	{ 'A',	parse_number	},
	{ 'B',	parse_number	},
	{ 'C',	parse_number	},
	{ 'D',	parse_number	},
	{ 'E',	parse_number	},
	{ 'F',	parse_number	},
	{ '_',	parse_number	},
	{ '.',	parse_number	},
	{ '+',	badd		},
	{ '-',	bsub		},
	{ '*',	bmul		},
	{ '/',	bdiv		},
	{ '%',	bmod		},
	{ '^',	bexp		},
	{ 's',	store		},
	{ 'S',	store_stack	},
	{ 'l',	load		},
	{ 'L',	load_stack	},
	{ 'd',	dup		},
	{ 'p',	print_tos	},
	{ 'P',	pop_print	},
	{ 'f',	print_stack	},
	{ 'x',	eval_tos	},
	{ 'X',	push_scale	},
	{ '[',	push_line	},
	{ 'q',	quit		},
	{ 'Q',	quitN		},
	{ '<',	less		},
	{ '>',	greater		},
	{ '=',	equal		},
	{ '!',	not_compare	},
	{ 'v',	bsqrt		},
	{ 'c',	clear_stack	},
	{ 'i',	set_ibase	},
	{ 'I',	get_ibase	},
	{ 'o',	set_obase	},
	{ 'O',	get_obase	},
	{ 'k',	set_scale	},
	{ 'K',	get_scale	},
	{ 'z',	stackdepth	},
	{ 'Z',	num_digits	},
	{ '?',	eval_line	},
	{ ';',	load_array	},
	{ ':',	store_array	},
	{ ' ',	nop		},
	{ '\t',	nop		},
	{ '\n',	nop		},
	{ '\f',	nop		},
	{ '\r',	nop		}
};

#define JUMP_TABLE_DATA_SIZE \
	(sizeof(jump_table_data)/sizeof(jump_table_data[0]))

void
init_bmachine(void)
{
	int i;

	for (i = 0; i < UCHAR_MAX; i++)
		jump_table[i] = unknown;
	for (i = 0; i < JUMP_TABLE_DATA_SIZE; i++)
		jump_table[jump_table_data[i].ch] = jump_table_data[i].f;

	stack_init(&bmachine.stack);

	for (i = 0; i < UCHAR_MAX; i++)
		stack_init(&bmachine.reg[i]);

	bmachine.obase = bmachine.ibase = 10;
	BN_init(&zero);
	bn_check(BN_zero(&zero));
}

/* Reset the things needed before processing a (new) file */
void
reset_bmachine(struct source *src)
{
	bmachine.readsp = 0;
	bmachine.readstack[0] = *src;
}

static __inline int
readch(void)
{
	struct source *src = &bmachine.readstack[bmachine.readsp];

	return src->vtable->readchar(src);
}

static __inline int
unreadch(void)
{
	struct source *src = &bmachine.readstack[bmachine.readsp];

	return src->vtable->unreadchar(src);
}

static __inline char *
readline(void)
{
	struct source *src = &bmachine.readstack[bmachine.readsp];

	return src->vtable->readline(src);
}

static __inline void
src_free(void)
{
	struct source *src = &bmachine.readstack[bmachine.readsp];

	src->vtable->free(src);
}

#if 1
void
pn(const char * str, const struct number *n)
{
	char *p = BN_bn2dec(n->number);
	if (p == NULL)
		err(1, "BN_bn2dec failed");
	fputs(str, stderr);
	fprintf(stderr, " %s (%u)\n" , p, n->scale);
	OPENSSL_free(p);
}

void
pbn(const char * str, const BIGNUM *n)
{
	char *p = BN_bn2dec(n);
	if (p == NULL)
		err(1, "BN_bn2dec failed");
	fputs(str, stderr);
	fprintf(stderr, " %s\n", p);
	OPENSSL_free(p);
}

#endif

static __inline u_int
max(u_int a, u_int b)
{
	return a > b ? a : b;
}

static unsigned long factors[] = {
	0, 10, 100, 1000, 10000, 100000, 1000000, 10000000,
	100000000, 1000000000
};

void
scale_number(BIGNUM *n, int s)
{
	int abs_scale;

	if (s == 0)
		return;

	abs_scale = s > 0 ? s : -s;

	if (abs_scale < sizeof(factors)/sizeof(factors[0])) {
		if (s > 0)
			bn_check(BN_mul_word(n, factors[abs_scale]));
		else
			BN_div_word(n, factors[abs_scale]);
	} else {
		BIGNUM *a, *p;
		BN_CTX *ctx;

		a = BN_new();
		bn_checkp(a);
		p = BN_new();
		bn_checkp(p);
		ctx = BN_CTX_new();
		bn_checkp(ctx);

		bn_check(BN_set_word(a, 10));
		bn_check(BN_set_word(p, abs_scale));
		bn_check(BN_exp(a, a, p, ctx));
		if (s > 0)
			bn_check(BN_mul(n, n, a, ctx));
		else
			bn_check(BN_div(n, NULL, n, a, ctx));
		BN_CTX_free(ctx);
		BN_free(a);
		BN_free(p);
	}
}

void
split_number(const struct number *n, BIGNUM *i, BIGNUM *f)
{
	u_long rem;

	bn_checkp(BN_copy(i, n->number));

	if (n->scale == 0 && f != NULL)
		BN_zero(f);
	else if (n->scale < sizeof(factors)/sizeof(factors[0])) {
		rem = BN_div_word(i, factors[n->scale]);
		if (f != NULL)
			BN_set_word(f, rem);
	} else {
		BIGNUM *a, *p;
		BN_CTX *ctx;

		a = BN_new();
		bn_checkp(a);
		p = BN_new();
		bn_checkp(p);
		ctx = BN_CTX_new();
		bn_checkp(ctx);

		bn_check(BN_set_word(a, 10));
		bn_check(BN_set_word(p, n->scale));
		bn_check(BN_exp(a, a, p, ctx));
		bn_check(BN_div(i, f, n->number, a, ctx));
		BN_CTX_free(ctx);
		BN_free(a);
		BN_free(p);
	}
}

__inline void
normalize(struct number *n, u_int s)
{
	scale_number(n->number, s - n->scale);
	n->scale = s;
}

static u_long
get_ulong(struct number *n)
{
	normalize(n, 0);
	return BN_get_word(n->number);
}

void
negate(struct number *n)
{
	bn_check(BN_sub(n->number, &zero, n->number));
}

static __inline void
push_number(struct number *n)
{
	stack_pushnumber(&bmachine.stack, n);
}

static __inline void
push_string(char *string)
{
	stack_pushstring(&bmachine.stack, string);
}

static __inline void
push(struct value *v)
{
	stack_push(&bmachine.stack, v);
}

static __inline struct value *
tos(void)
{
	return stack_tos(&bmachine.stack);
}

static __inline struct value *
pop(void)
{
	return stack_pop(&bmachine.stack);
}

static __inline struct number *
pop_number(void)
{
	return stack_popnumber(&bmachine.stack);
}

static __inline char *
pop_string(void)
{
	return stack_popstring(&bmachine.stack);
}

static __inline void
clear_stack(void)
{
	stack_clear(&bmachine.stack);
}

static __inline void
print_stack(void)
{
	stack_print(stdout, &bmachine.stack, "", bmachine.obase);
}

static __inline void
print_tos(void)
{
	struct value *value = tos();
	if (value != NULL) {
		print_value(stdout, value, "", bmachine.obase);
		putchar('\n');
	}
	else
		warnx("stack empty");
}

static __inline void
pop_print(void)
{
	struct value *value = pop();
	if (value != NULL) {
		switch (value->type) {
		case BCODE_NONE:
			break;
		case BCODE_NUMBER:
			normalize(value->u.num, 0);
			print_ascii(stdout, value->u.num);
			break;
		case BCODE_STRING:
			printf("%s", value->u.string);
			break;
		}
		stack_free_value(value);
	}
}

static __inline void
dup(void)
{
	stack_dup(&bmachine.stack);
}

static void
get_scale(void)
{
	struct number	*n;

	n = new_number();
	bn_check(BN_set_word(n->number, bmachine.scale));
	push_number(n);
}

static void
set_scale(void)
{
	struct number	*n;
	u_long		scale;

	n = pop_number();
	if (n != NULL) {
		if (BN_cmp(n->number, &zero) < 0)
			warnx("scale must be a nonnegative number");
		else {
			scale = get_ulong(n);
			if (scale != BN_MASK2)
				bmachine.scale = scale;
			else
				warnx("scale too large");
			}
		free_number(n);
	}
}

static void
get_obase(void)
{
	struct number	*n;

	n = new_number();
	bn_check(BN_set_word(n->number, bmachine.obase));
	push_number(n);
}

static void
set_obase(void)
{
	struct number	*n;
	u_long		base;

	n = pop_number();
	if (n != NULL) {
		base = get_ulong(n);
		if (base != BN_MASK2 && base > 1)
			bmachine.obase = base;
		else
			warnx("output base must be a number greater than 1");
		free_number(n);
	}
}

static void
get_ibase(void)
{
	struct number *n;

	n = new_number();
	bn_check(BN_set_word(n->number, bmachine.ibase));
	push_number(n);
}

static void
set_ibase(void)
{
	struct number	*n;
	u_long		base;

	n = pop_number();
	if (n != NULL) {
		base = get_ulong(n);
		if (base != BN_MASK2 && 2 <= base && base <= 16)
			bmachine.ibase = base;
		else
			warnx("input base must be a number between 2 and 16 "
			    "(inclusive)");
		free_number(n);
	}
}

static void
stackdepth(void)
{
	u_int i;
	struct number *n;

	i = stack_size(&bmachine.stack);
	n = new_number();
	bn_check(BN_set_word(n->number, i));
	push_number(n);
}

static void
push_scale(void)
{
	struct value	*value;
	u_int		scale = 0;
	struct number	*n;


	value = pop();
	if (value != NULL) {
		switch (value->type) {
		case BCODE_NONE:
			return;
		case BCODE_NUMBER:
			scale = value->u.num->scale;
			break;
		case BCODE_STRING:
			break;
		}
		stack_free_value(value);
		n = new_number();
		bn_check(BN_set_word(n->number, scale));
		push_number(n);
	}
}

static u_int
count_digits(const struct number *n)
{
	struct number	*int_part, *fract_part;
	u_int		i;

	if (BN_is_zero(n->number))
		return 1;

	int_part = new_number();
	fract_part = new_number();
	fract_part->scale = n->scale;
	split_number(n, int_part->number, fract_part->number);

	i = 0;
	while (!BN_is_zero(int_part->number)) {
		BN_div_word(int_part->number, 10);
		i++;
	}
	free_number(int_part);
	free_number(fract_part);
	return i + n->scale;
}

static void
num_digits(void)
{
	struct value	*value;
	u_int		digits;
	struct number	*n;

	value = pop();
	if (value != NULL) {
		switch (value->type) {
		case BCODE_NONE:
			break;
		case BCODE_NUMBER:
			digits = count_digits(value->u.num);
			n = new_number();
			bn_check(BN_set_word(n->number, digits));
			/* free first, then reassign */
			BN_free(value->u.num->number);
			push_number(n);
			break;
		case BCODE_STRING:
			digits = strlen(value->u.string);
			n = new_number();
			bn_check(BN_set_word(n->number, digits));
			/* free first, then reassign */
			free(value->u.string);
			push_number(n);
			break;
		}
	}
}

static void
load(void)
{
	int		index;
	struct value	*v, copy;
	struct number	*n;

	index = readch();
	if (0 <= index && index < UCHAR_MAX) {
		v = stack_tos(&bmachine.reg[index]);
		if (v == NULL) {
			n = new_number();
			bn_check(BN_zero(n->number));
			push_number(n);
		} else
			push(stack_dup_value(v, &copy));
	} else
		warnx("internal error: reg num = %d", index);
}

static void
store(void)
{
	int		index;
	struct value	*val;

	index = readch();
	if (0 <= index && index < UCHAR_MAX) {
		val = pop();
		if (val == NULL) {
			return;
		}
		stack_set_tos(&bmachine.reg[index], val);
	} else
		warnx("internal error: reg num = %d", index);
}

static void
load_stack(void)
{
	int		index;
	struct stack	*stack;
	struct value	*value, copy;

	index = readch();
	if (0 <= index && index < UCHAR_MAX) {
		stack = &bmachine.reg[index];
		value = NULL;
		if (stack_size(stack) > 0) {
			value = stack_pop(stack);
		}
		if (value != NULL)
			push(stack_dup_value(value, &copy));
		else
			warnx("stack register '%c' (0%o) is empty",
			    index, index);
	} else
		warnx("internal error: reg num = %d", index);
}

static void
store_stack(void)
{
	int		index;
	struct value	*value;

	index = readch();
	if (0 <= index && index < UCHAR_MAX) {
		value = pop();
		if (value == NULL)
			return;
		stack_push(&bmachine.reg[index], value);
	} else
		warnx("internal error: reg num = %d", index);
}

static void
load_array(void)
{
	int			reg;
	struct number		*inumber, *n;
	u_long			index;
	struct stack		*stack;
	struct value		*v, copy;

	reg = readch();
	if (0 <= reg && reg < UCHAR_MAX) {
		inumber = pop_number();
		if (inumber == NULL)
			return;
		index = get_ulong(inumber);
		if (BN_cmp(inumber->number, &zero) < 0)
			warnx("negative index");
		else if (index == BN_MASK2 || index > MAX_ARRAY_INDEX)
			warnx("index too big");
		else {
			stack = &bmachine.reg[reg];
			v = frame_retrieve(stack, index);
			if (v == NULL) {
				n = new_number();
				bn_check(BN_zero(n->number));
				push_number(n);
			}
			else
				push(stack_dup_value(v, &copy));
		}
		free_number(inumber);
	} else
		warnx("internal error: reg num = %d", reg);
}

static void
store_array(void)
{
	int			reg;
	struct number		*inumber;
	u_long			index;
	struct value		*value;
	struct stack		*stack;

	reg = readch();
	if (0 <= reg && reg < UCHAR_MAX) {
		inumber = pop_number();
		value = pop();
		if (inumber == NULL) {
			if (value != NULL)
				stack_free_value(value);
			return;
		}
		index = get_ulong(inumber);
		if (BN_cmp(inumber->number, &zero) < 0) {
			warnx("negative index");
			stack_free_value(value);
		} else if (index == BN_MASK2 || index > MAX_ARRAY_INDEX) {
			warnx("index too big");
			stack_free_value(value);
		} else {
			stack = &bmachine.reg[reg];
			frame_assign(stack, index, value);
		}
		free_number(inumber);
	} else
		warnx("internal error: reg num = %d", reg);
}

static void
push_line(void)
{
	push_string(read_string(&bmachine.readstack[bmachine.readsp]));
}

static void
bexec(char *line)
{
	system(line);
	free(line);
}

static void
badd(void)
{
	struct number	*a, *b;
	struct number	*r;

	a = pop_number();
	if (a == NULL) {
		return;
	}
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	r = new_number();
	r->scale = max(a->scale, b->scale);
	if (r->scale > a->scale)
		normalize(a, r->scale);
	else if (r->scale > b->scale)
		normalize(b, r->scale);
	bn_check(BN_add(r->number, a->number, b->number));
	push_number(r);
	free_number(a);
	free_number(b);
}

static void
bsub(void)
{
	struct number	*a, *b;
	struct number	*r;

	a = pop_number();
	if (a == NULL) {
		return;
	}
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	r = new_number();

	r->scale = max(a->scale, b->scale);
	if (r->scale > a->scale)
		normalize(a, r->scale);
	else if (r->scale > b->scale)
		normalize(b, r->scale);
	bn_check(BN_sub(r->number, b->number, a->number));
	push_number(r);
	free_number(a);
	free_number(b);
}

void
bmul_number(struct number *r, struct number *a, struct number *b)
{
	BN_CTX		*ctx;

	/* Create copies of the scales, since r might be equal to a or b */
	u_int ascale = a->scale;
	u_int bscale = b->scale;
	u_int rscale = ascale + bscale;

	ctx = BN_CTX_new();
	bn_checkp(ctx);
	bn_check(BN_mul(r->number, a->number, b->number, ctx));
	BN_CTX_free(ctx);

	if (rscale > bmachine.scale && rscale > ascale && rscale > bscale) {
		r->scale = rscale;
		normalize(r, max(bmachine.scale, max(ascale, bscale)));
	} else
		r->scale = rscale;
}

static void
bmul(void)
{
	struct number	*a, *b;
	struct number	*r;

	a = pop_number();
	if (a == NULL) {
		return;
	}
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	r = new_number();
	bmul_number(r, a, b);

	push_number(r);
	free_number(a);
	free_number(b);
}

static void
bdiv(void)
{
	struct number	*a, *b;
	struct number	*r;
	u_int		scale;
	BN_CTX		*ctx;

	a = pop_number();
	if (a == NULL) {
		return;
	}
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	r = new_number();
	r->scale = bmachine.scale;
	scale = max(a->scale, b->scale);

	if (BN_is_zero(a->number))
		warnx("divide by zero");
	else {
		normalize(a, scale);
		normalize(b, scale + r->scale);

		ctx = BN_CTX_new();
		bn_checkp(ctx);
		bn_check(BN_div(r->number, NULL, b->number, a->number, ctx));
		BN_CTX_free(ctx);
	}
	push_number(r);
	free_number(a);
	free_number(b);
}

static void
bmod(void)
{
	struct number	*a, *b;
	struct number	*r;
	u_int		scale;
	BN_CTX		*ctx;

	a = pop_number();
	if (a == NULL) {
		return;
	}
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	r = new_number();
	scale = max(a->scale, b->scale);
	r->scale = max(b->scale, a->scale + bmachine.scale);

	if (BN_is_zero(a->number))
		warnx("remainder by zero");
	else {
		normalize(a, scale);
		normalize(b, scale + bmachine.scale);

		ctx = BN_CTX_new();
		bn_checkp(ctx);
		bn_check(BN_mod(r->number, b->number, a->number, ctx));
		BN_CTX_free(ctx);
	}
	push_number(r);
	free_number(a);
	free_number(b);
}

static void
bexp(void)
{
	struct number	*a, *p;
	struct number	*r;
	bool		neg;
	u_int		scale;

	p = pop_number();
	if (p == NULL) {
		return;
	}
	a = pop_number();
	if (a == NULL) {
		push_number(p);
		return;
	}

	if (p->scale != 0)
		warnx("Runtime warning: non-zero scale in exponent");
	normalize(p, 0);

	neg = false;
	if (BN_cmp(p->number, &zero) < 0) {
		neg = true;
		negate(p);
		scale = bmachine.scale;
	} else {
		/* Posix bc says min(a.scale * b, max(a.scale, scale) */
		u_long	b;
		u_int	m;

		b = BN_get_word(p->number);
		m = max(a->scale, bmachine.scale);
		scale = a->scale * b;
		if (scale > m || b == BN_MASK2)
			scale = m;
	}

	if (BN_is_zero(p->number)) {
		r = new_number();
		bn_check(BN_one(r->number));
		normalize(r, scale);
	} else {
		while (!BN_is_bit_set(p->number, 0)) {
			bmul_number(a, a, a);
			bn_check(BN_rshift1(p->number, p->number));
		}

		r = dup_number(a);
		normalize(r, scale);
		bn_check(BN_rshift1(p->number, p->number));

		while (!BN_is_zero(p->number)) {
			bmul_number(a, a, a);
			if (BN_is_bit_set(p->number, 0))
				bmul_number(r, r, a);
			bn_check(BN_rshift1(p->number, p->number));
		}

		if (neg) {
			BN_CTX	*ctx;
			BIGNUM	*one;

			one = BN_new();
			bn_checkp(one);
			BN_one(one);
			ctx = BN_CTX_new();
			bn_checkp(ctx);
			r->scale = scale;
			scale_number(one, r->scale);
			bn_check(BN_div(r->number, NULL, one, r->number, ctx));
			BN_free(one);
			BN_CTX_free(ctx);
		}
	}
	push_number(r);
	free_number(a);
	free_number(p);
}

static bool
bsqrt_stop(const BIGNUM *x, const BIGNUM *y)
{
	BIGNUM *r;
	bool ret;

	r = BN_new();
	bn_checkp(r);
	bn_check(BN_sub(r, x, y));
	ret = BN_is_one(r) || BN_is_zero(r);
	BN_free(r);
	return ret;
}

static void
bsqrt(void)
{
	struct number	*n;
	struct number	*r;
	BIGNUM		*x, *y;
	u_int		scale;
	BN_CTX		*ctx;

	n = pop_number();
	if (n == NULL) {
		return;
	}
	if (BN_is_zero(n->number)) {
		r = new_number();
		push_number(r);
	} else if (BN_cmp(n->number, &zero) < 0)
		warnx("square root of negative number");
	else {
		scale = max(bmachine.scale, n->scale);
		normalize(n, 2*scale);
		x = BN_dup(n->number);
		bn_checkp(x);
		bn_check(BN_rshift(x, x, BN_num_bits(x)/2));
		y = BN_new();
		bn_checkp(y);
		ctx = BN_CTX_new();
		bn_checkp(ctx);
		for (;;) {
			bn_checkp(BN_copy(y, x));
			bn_check(BN_div(x, NULL, n->number, x, ctx));
			bn_check(BN_add(x, x, y));
			bn_check(BN_rshift1(x, x));
			if (bsqrt_stop(x, y))
				break;
		}
		r = bmalloc(sizeof(*r));
		r->scale = scale;
		r->number = y;
		BN_free(x);
		BN_CTX_free(ctx);
		push_number(r);
	}

	free_number(n);
}

static void
equal(void)
{
	compare(BCODE_EQUAL);
}

static void
not_equal(void)
{
	compare(BCODE_NOT_EQUAL);
}

static void
less(void)
{
	compare(BCODE_LESS);
}

static void
not_compare(void)
{
	switch (readch()) {
	case '<':
		not_less();
		break;
	case '>':
		not_greater();
		break;
	case '=':
		not_equal();
		break;
	default:
		unreadch();
		bexec(readline());
		break;
	}
}

static void
not_less(void)
{
	compare(BCODE_NOT_LESS);
}

static void
greater(void)
{
	compare(BCODE_GREATER);
}

static void
not_greater(void)
{
	compare(BCODE_NOT_GREATER);
}

static void
compare(enum bcode_compare type)
{
	int		index;
	struct number	*a, *b;
	u_int		scale;
	int		cmp;
	bool		ok;
	struct value	*v;

	index = readch();

	a = pop_number();
	if (a == NULL) {
		return;
	}
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	scale = max(a->scale, b->scale);
	if (scale > a->scale)
		normalize(a, scale);
	else if (scale > scale)
		normalize(b, scale);

	cmp = BN_cmp(a->number, b->number);

	free_number(a);
	free_number(b);

	ok = false;
	switch (type) {
	case BCODE_EQUAL:
		ok = cmp == 0;
		break;
	case BCODE_NOT_EQUAL:
		ok = cmp != 0;
		break;
	case BCODE_LESS:
		ok = cmp < 0;
		break;
	case BCODE_NOT_LESS:
		ok = cmp >= 0;
		break;
	case BCODE_GREATER:
		ok = cmp > 0;
		break;
	case BCODE_NOT_GREATER:
		ok = cmp <= 0;
		break;
	}

	if (ok) {
		v = stack_tos(&bmachine.reg[index]);
		if (v == NULL)
			warn("stack empty");
		else {
			switch(v->type) {
			case BCODE_NONE:
				warnx("register '%c' (0%o) is empty",
				    index, index);
				break;
			case BCODE_NUMBER:
				warn("eval called with non-string argument");
				break;
			case BCODE_STRING:
				eval_string(bstrdup(v->u.string));
				break;
			}
		}
	}
}


static void
nop(void)
{
}

static void
quit(void)
{
	if (bmachine.readsp < 2)
		exit(0);
	src_free();
	bmachine.readsp--;
	src_free();
	bmachine.readsp--;
}

static void
quitN(void)
{
	struct number	*n;
	u_long		i;

	n = pop_number();
	if (n == NULL)
		return;
	i = get_ulong(n);
	if (i == BN_MASK2 || i == 0)
		warnx("Q command requires a number >= 1");
	else if (bmachine.readsp < i)
		warnx("Q command argument exceeded string execution depth");
	else {
		while (i-- > 0) {
			src_free();
			bmachine.readsp--;
		}
	}
}

static void
parse_number(void)
{
	unreadch();
	push_number(readnumber(&bmachine.readstack[bmachine.readsp],
	    bmachine.ibase));
}

static void
unknown(void)
{
	int ch = bmachine.readstack[bmachine.readsp].lastchar;
	warnx("%c (0%o) is unimplemented", ch, ch);
}

static void
eval_string(char *p)
{
	int ch;

	if (bmachine.readsp > 0) {
		/* Check for tail call. Do not recurse in that case. */
		ch = readch();
		if (ch == EOF) {
			src_free();
			src_setstring(&bmachine.readstack[bmachine.readsp], p);
			return;
		} else
			unreadch();
	}
	if (bmachine.readsp == MAX_RECURSION)
		errx(1, "recursion too deep");
	src_setstring(&bmachine.readstack[++bmachine.readsp], p);
}

static void
eval_line(void)
{
	/* Always read from stdin */
	struct source	in;
	char		*p;

	src_setstream(&in, stdin);
	p = (*in.vtable->readline)(&in);
	eval_string(p);
}

static void
eval_tos(void)
{
	char *p;

	p = pop_string();
	if (p == NULL)
		return;
	eval_string(p);
}

void
eval(void)
{
	int	ch;

	for (;;) {
		ch = readch();
		if (ch == EOF) {
			if (bmachine.readsp == 0)
				exit(0);
			src_free();
			bmachine.readsp--;
			continue;
		}
		if (trace) {
			fprintf(stderr, "# %c\n", ch);
			stack_print(stderr, &bmachine.stack, "* ",
			    bmachine.obase);
			fprintf(stderr, "%d =>\n", bmachine.readsp);
		}

		if (0 <= ch && ch < UCHAR_MAX)
			(*jump_table[ch])();
		else
			warnx("internal error: opcode %d", ch);

		if (trace) {
			stack_print(stderr, &bmachine.stack, "* ",
			    bmachine.obase);
			fprintf(stderr, "%d ==\n", bmachine.readsp);
		}
	}
}
@


1.1.1.1
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree again, with critical bug fixes
(OpenSSL, bc, dc, sensorsd, pf, ...)
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.7 2003/09/30 18:27:01 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.7 2003/09/30 18:27:01 otto Exp $";
a454 1
			fflush(stdout);
d457 1
a457 2
			fputs(value->u.string, stdout);
			fflush(stdout);
a772 2
		if (inumber == NULL)
			return;
d774 3
a776 2
		if (value == NULL) {
			free_number(inumber);
@


1.1.1.2.2.1
log
@that bc/dc fix sync with OpenBSD (must-have fix :)
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.12 2003/10/22 14:58:32 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.12 2003/10/22 14:58:32 otto Exp $";
d33 1
a33 2

/* #define	DEBUGGING */
a37 2
#define NO_ELSE			-2	/* -1 is EOF */

a87 1
static void		bdivmod(void);
a107 2
static void		skipN(void);
static void		skip_until_mark(void);
a147 1
	{ '~',	bdivmod		},
a161 2
	{ 'J',	skipN		},
	{ 'M',	nop		},
d249 1
a249 1
#ifdef DEBUGGING
a990 42
bdivmod(void)
{
	struct number	*a, *b;
	struct number	*rdiv, *rmod;
	u_int		scale;
	BN_CTX		*ctx;

	a = pop_number();
	if (a == NULL) {
		return;
	}
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	rdiv = new_number();
	rmod = new_number();
	rdiv->scale = bmachine.scale;
	rmod->scale = max(b->scale, a->scale + bmachine.scale);
	scale = max(a->scale, b->scale);

	if (BN_is_zero(a->number))
		warnx("divide by zero");
	else {
		normalize(a, scale);
		normalize(b, scale + bmachine.scale);

		ctx = BN_CTX_new();
		bn_checkp(ctx);
		bn_check(BN_div(rdiv->number, rmod->number,
		    b->number, a->number, ctx));
		BN_CTX_free(ctx);
	}
	push_number(rdiv);
	push_number(rmod);
	free_number(a);
	free_number(b);
}

static void
d1191 1
a1191 1
	int		index, elseindex;
a1197 1
	elseindex = NO_ELSE;
a1198 4
	if (readch() == 'e')
		elseindex = readch();
	else
		unreadch();
d1201 1
a1201 1
	if (a == NULL)
d1203 1
d1243 1
a1243 6
	if (!ok && elseindex != NO_ELSE)
		index = elseindex;

	if (index < 0 || index > UCHAR_MAX)
		warnx("internal error: reg num = %d", index);
	else if (ok || (!ok && elseindex != NO_ELSE)) {
d1246 1
a1246 1
			warnx("register '%c' (0%o) is empty", index, index);
a1303 76
skipN(void)
{
	struct number	*n;
	u_long		i;

	n = pop_number();
	if (n == NULL)
		return;
	i = get_ulong(n);
	if (i == BN_MASK2)
		warnx("J command requires a number >= 0");
	else if (i > 0 && bmachine.readsp < i)
		warnx("J command argument exceeded string execution depth");
	else {
		while (i-- > 0) {
			src_free();
			bmachine.readsp--;
		}
		skip_until_mark();
	}
}

static void
skip_until_mark(void)
{
	int ch;

	for (;;) {
		ch = readch();
		switch (ch) {
		case 'M':
			return;
		case EOF:
			errx(1, "mark not found");
			return;
		case 'l':
		case 'L':
		case 's':
		case 'S':
		case ':':
		case ';':
		case '<':
		case '>':
		case '=':
			readch();
			if (readch() == 'e')
				readch();
			else
				unreadch();
			break;
		case '[':
			free(read_string(&bmachine.readstack[bmachine.readsp]));
			break;
		case '!':
			switch (ch = readch()) {
				case '<':
				case '>':
				case '=':
					readch();
					if (readch() == 'e')
						readch();
					else
						unreadch();
					break;
				default:
					free(readline());
					break;
			}
			break;
		default:
			break;
		}
	}
}

static void
d1375 6
a1380 6
#ifdef DEBUGGING
		fprintf(stderr, "# %c\n", ch);
		stack_print(stderr, &bmachine.stack, "* ",
		    bmachine.obase);
		fprintf(stderr, "%d =>\n", bmachine.readsp);
#endif
d1387 5
a1391 5
#ifdef DEBUGGING
		stack_print(stderr, &bmachine.stack, "* ",
		    bmachine.obase);
		fprintf(stderr, "%d ==\n", bmachine.readsp);
#endif
@


1.1.1.3
log
@Import fixed bc and dc from OpenBSD-current (a must-have :)
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.12 2003/10/22 14:58:32 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.12 2003/10/22 14:58:32 otto Exp $";
d33 1
a33 2

/* #define	DEBUGGING */
a37 2
#define NO_ELSE			-2	/* -1 is EOF */

a87 1
static void		bdivmod(void);
a107 2
static void		skipN(void);
static void		skip_until_mark(void);
a147 1
	{ '~',	bdivmod		},
a161 2
	{ 'J',	skipN		},
	{ 'M',	nop		},
d249 1
a249 1
#ifdef DEBUGGING
a990 42
bdivmod(void)
{
	struct number	*a, *b;
	struct number	*rdiv, *rmod;
	u_int		scale;
	BN_CTX		*ctx;

	a = pop_number();
	if (a == NULL) {
		return;
	}
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	rdiv = new_number();
	rmod = new_number();
	rdiv->scale = bmachine.scale;
	rmod->scale = max(b->scale, a->scale + bmachine.scale);
	scale = max(a->scale, b->scale);

	if (BN_is_zero(a->number))
		warnx("divide by zero");
	else {
		normalize(a, scale);
		normalize(b, scale + bmachine.scale);

		ctx = BN_CTX_new();
		bn_checkp(ctx);
		bn_check(BN_div(rdiv->number, rmod->number,
		    b->number, a->number, ctx));
		BN_CTX_free(ctx);
	}
	push_number(rdiv);
	push_number(rmod);
	free_number(a);
	free_number(b);
}

static void
d1191 1
a1191 1
	int		index, elseindex;
a1197 1
	elseindex = NO_ELSE;
a1198 4
	if (readch() == 'e')
		elseindex = readch();
	else
		unreadch();
d1201 1
a1201 1
	if (a == NULL)
d1203 1
d1243 1
a1243 6
	if (!ok && elseindex != NO_ELSE)
		index = elseindex;

	if (index < 0 || index > UCHAR_MAX)
		warnx("internal error: reg num = %d", index);
	else if (ok || (!ok && elseindex != NO_ELSE)) {
d1246 1
a1246 1
			warnx("register '%c' (0%o) is empty", index, index);
a1303 76
skipN(void)
{
	struct number	*n;
	u_long		i;

	n = pop_number();
	if (n == NULL)
		return;
	i = get_ulong(n);
	if (i == BN_MASK2)
		warnx("J command requires a number >= 0");
	else if (i > 0 && bmachine.readsp < i)
		warnx("J command argument exceeded string execution depth");
	else {
		while (i-- > 0) {
			src_free();
			bmachine.readsp--;
		}
		skip_until_mark();
	}
}

static void
skip_until_mark(void)
{
	int ch;

	for (;;) {
		ch = readch();
		switch (ch) {
		case 'M':
			return;
		case EOF:
			errx(1, "mark not found");
			return;
		case 'l':
		case 'L':
		case 's':
		case 'S':
		case ':':
		case ';':
		case '<':
		case '>':
		case '=':
			readch();
			if (readch() == 'e')
				readch();
			else
				unreadch();
			break;
		case '[':
			free(read_string(&bmachine.readstack[bmachine.readsp]));
			break;
		case '!':
			switch (ch = readch()) {
				case '<':
				case '>':
				case '=':
					readch();
					if (readch() == 'e')
						readch();
					else
						unreadch();
					break;
				default:
					free(readline());
					break;
			}
			break;
		default:
			break;
		}
	}
}

static void
d1375 6
a1380 6
#ifdef DEBUGGING
		fprintf(stderr, "# %c\n", ch);
		stack_print(stderr, &bmachine.stack, "* ",
		    bmachine.obase);
		fprintf(stderr, "%d =>\n", bmachine.readsp);
#endif
d1387 5
a1391 5
#ifdef DEBUGGING
		stack_print(stderr, &bmachine.stack, "* ",
		    bmachine.obase);
		fprintf(stderr, "%d ==\n", bmachine.readsp);
#endif
@


1.1.1.4
log
@Import selected parts of the OpenBSD base system:
 * vnd change - you'll have to re-run MAKEDEV after booting a new kernel
 * misc. changes in /etc, mostly user related
 * Perl 5.8.2 (diff to MirPorts will be committed RSN)
 * some changes to binutils
 * Updates in bc and dc
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.19 2003/12/02 13:43:02 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.19 2003/12/02 13:43:02 otto Exp $";
d37 1
a37 1
#define RECURSION_STACK_SIZE	100
a39 2
#define REG_ARRAY_SIZE_SMALL	(UCHAR_MAX + 1)
#define REG_ARRAY_SIZE_BIG	(UCHAR_MAX + 1 + USHRT_MAX + 1)
d47 2
a48 4
	bool			extended_regs;
	size_t			reg_array_size;
	struct stack		*reg;
	struct source		readstack[RECURSION_STACK_SIZE];
d69 2
a70 3
static void		pop_print(void);
static void		pop_printn(void);
static __inline void	print_stack(void);
a71 2
static void		swap(void);
static void		drop(void);
d83 1
a83 1
static void		to_ascii(void);
a84 1
static void		comment(void);
a94 4
static void		not(void);
static void		equal_numbers(void);
static void		less_numbers(void);
static void		lesseq_numbers(void);
a101 2
static bool		compare_numbers(enum bcode_compare, struct number *,
			    struct number *);
a102 1
static int		readreg(void);
a130 10
	{ ' ',	nop		},
	{ '!',	not_compare	},
	{ '#',	comment		},
	{ '%',	bmod		},
	{ '(',	less_numbers	},
	{ '*',	bmul		},
	{ '+',	badd		},
	{ '-',	bsub		},
	{ '.',	parse_number	},
	{ '/',	bdiv		},
a140 6
	{ ':',	store_array	},
	{ ';',	load_array	},
	{ '<',	less		},
	{ '=',	equal		},
	{ '>',	greater		},
	{ '?',	eval_line	},
d147 12
a158 4
	{ 'G',	equal_numbers	},
	{ 'I',	get_ibase	},
	{ 'J',	skipN		},
	{ 'K',	get_scale	},
d160 2
a161 3
	{ 'M',	nop		},
	{ 'N',	not		},
	{ 'O',	get_obase	},
d163 2
a164 3
	{ 'Q',	quitN		},
	{ 'R',	drop		},
	{ 'S',	store_stack	},
a165 1
	{ 'Z',	num_digits	},
d167 9
a175 7
	{ '\f',	nop		},
	{ '\n',	nop		},
	{ '\r',	nop		},
	{ '\t',	nop		},
	{ '^',	bexp		},
	{ '_',	parse_number	},
	{ 'a',	to_ascii	},
a176 2
	{ 'd',	dup		},
	{ 'f',	print_stack	},
d178 3
d182 1
a182 10
	{ 'l',	load		},
	{ 'n',	pop_printn	},
	{ 'o',	set_obase	},
	{ 'p',	print_tos	},
	{ 'p',	print_tos	},
	{ 'q',	quit		},
	{ 'r',	swap		},
	{ 's',	store		},
	{ 'v',	bsqrt		},
	{ 'x',	eval_tos	},
d184 9
a192 2
	{ '{',	lesseq_numbers	},
	{ '~',	bdivmod		}
d199 1
a199 1
init_bmachine(bool extended_registers)
a202 9
	bmachine.extended_regs = extended_registers;
	bmachine.reg_array_size = bmachine.extended_regs ?
	    REG_ARRAY_SIZE_BIG : REG_ARRAY_SIZE_SMALL;

	bmachine.reg = malloc(bmachine.reg_array_size *
	    sizeof(bmachine.reg[0]));
	if (bmachine.reg == NULL)
		err(1, NULL);

d210 1
a210 1
	for (i = 0; i < bmachine.reg_array_size; i++)
d453 1
a453 1
static void
a456 1

a474 12
static void
pop_printn(void)
{
	struct value *value = pop();

	if (value != NULL) {
		print_value(stdout, value, "", bmachine.obase);
		fflush(stdout);
		stack_free_value(value);
	}
}

a481 14
swap(void)
{
	stack_swap(&bmachine.stack);
}

static void
drop(void)
{
	struct value *v = pop();
	if (v != NULL)
		stack_free_value(v);
}

static void
d634 1
a634 1
	struct number	*n = NULL;
d640 1
a640 1
			return;
d645 3
d653 3
a657 2
		stack_free_value(value);
		push_number(n);
a661 51
to_ascii(void)
{
	char		str[2];
	struct value	*value;
	struct number	*n;

	value = pop();
	if (value != NULL) {
		str[1] = '\0';
		switch (value->type) {
		case BCODE_NONE:
			return;
		case BCODE_NUMBER:
			n = value->u.num;
			normalize(n, 0);
			if (BN_num_bits(n->number) > 8)
				bn_check(BN_mask_bits(n->number, 8));
			str[0] = BN_get_word(n->number);
			break;
		case BCODE_STRING:
			str[0] = value->u.string[0];
			break;
		}
		stack_free_value(value);
		push_string(bstrdup(str));
	}
}

static int
readreg(void)
{
	int index, ch1, ch2;

	index = readch();
	if (index == 0xff && bmachine.extended_regs) {
		ch1 = readch();
		ch2 = readch();
		if (ch1 == EOF || ch2 == EOF) {
			warnx("unexpected eof");
			index = -1;
		} else
			index = (ch1 << 8) + ch2 + UCHAR_MAX + 1;
	}
	if (index < 0 || index >= bmachine.reg_array_size) {
		warnx("internal error: reg num = %d", index);
		index = -1;
	}
	return index;
}

static void
d668 2
a669 2
	index = readreg();
	if (index >= 0) {
d677 2
a678 1
	}
d687 2
a688 2
	index = readreg();
	if (index >= 0) {
d694 2
a695 1
	}
d705 2
a706 2
	index = readreg();
	if (index >= 0) {
d717 2
a718 1
	}
d727 2
a728 2
	index = readreg();
	if (index >= 0) {
d733 2
a734 1
	}
d746 2
a747 2
	reg = readreg();
	if (reg >= 0) {
d768 2
a769 1
	}
d781 2
a782 2
	reg = readreg();
	if (reg >= 0) {
d803 2
a804 1
	}
a813 6
comment(void)
{
	free(readline());
}

static void
a1183 14
not(void)
{
	struct number	*a;

	a = pop_number();
	if (a == NULL) {
		return;
	}
	a->scale = 0;
	bn_check(BN_set_word(a->number, BN_get_word(a->number) ? 0 : 1));
	push_number(a);
}

static void
a1189 60
equal_numbers(void)
{
	struct number *a, *b, *r;

	a = pop_number();
	if (a == NULL) {
		return;
	}
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}
	r = new_number();
	bn_check(BN_set_word(r->number,
	    compare_numbers(BCODE_EQUAL, a, b) ? 1 : 0));
	push_number(r);
}

static void
less_numbers(void)
{
	struct number *a, *b, *r;

	a = pop_number();
	if (a == NULL) {
		return;
	}
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}
	r = new_number();
	bn_check(BN_set_word(r->number,
	    compare_numbers(BCODE_LESS, a, b) ? 1 : 0));
	push_number(r);
}

static void
lesseq_numbers(void)
{
	struct number *a, *b, *r;

	a = pop_number();
	if (a == NULL) {
		return;
	}
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}
	r = new_number();
	bn_check(BN_set_word(r->number,
	    compare_numbers(BCODE_NOT_GREATER, a, b) ? 1 : 0));
	push_number(r);
}

static void
a1238 35
static bool
compare_numbers(enum bcode_compare type, struct number *a, struct number *b)
{
	u_int	scale;
	int	cmp;

	scale = max(a->scale, b->scale);

	if (scale > a->scale)
		normalize(a, scale);
	else if (scale > scale)
		normalize(b, scale);

	cmp = BN_cmp(a->number, b->number);

	free_number(a);
	free_number(b);

	switch (type) {
	case BCODE_EQUAL:
		return cmp == 0;
	case BCODE_NOT_EQUAL:
		return cmp != 0;
	case BCODE_LESS:
		return cmp < 0;
	case BCODE_NOT_LESS:
		return cmp >= 0;
	case BCODE_GREATER:
		return cmp > 0;
	case BCODE_NOT_GREATER:
		return cmp <= 0;
	}
	return false;
}

d1244 2
d1250 1
a1250 1
	index = readreg();
d1252 1
a1252 1
		elseindex = readreg();
d1265 32
a1296 1
	ok = compare_numbers(type, a, b);
d1301 3
a1303 1
	if (index >= 0 && (ok || (!ok && elseindex != NO_ELSE))) {
d1408 1
a1408 1
			readreg();
d1410 1
a1410 1
				readreg();
d1422 1
a1422 1
					readreg();
d1424 1
a1424 1
						readreg();
d1469 1
a1469 1
	if (bmachine.readsp == RECURSION_STACK_SIZE-1)
@


1.1.1.5
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.20 2003/12/19 19:23:16 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.20 2003/12/19 19:23:16 otto Exp $";
a25 1
#include <signal.h>
a51 1
	bool			interrupted;
a55 1
static void sighandler(int);
a222 6
static void
sighandler(int ignored)
{
	bmachine.interrupted = true;
}

a249 1
	signal(SIGINT, sighandler);
a1691 9
		}
		if (bmachine.interrupted) {
			if (bmachine.readsp > 0) {
				src_free();
				bmachine.readsp--;
				continue;
			} else {
				bmachine.interrupted = false;
			}
@


1.1.1.6
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.21 2004/01/20 21:41:20 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.21 2004/01/20 21:41:20 deraadt Exp $";
d211 1
@


1.1.1.7
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.22 2004/02/11 20:44:31 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.22 2004/02/11 20:44:31 otto Exp $";
d53 1
a53 1
	volatile bool		interrupted;
d1707 1
a1707 1
			} else
d1709 1
@


1.1.1.8
log
@import some updates/fixes from openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.24 2004/10/18 07:49:00 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.24 2004/10/18 07:49:00 otto Exp $";
a224 1
/* ARGSUSED */
d1697 1
a1697 1
				return;
@


1.1.1.9
log
@your daily dose of bugfixes and security updates from obsd
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.26 2004/12/01 08:40:12 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.26 2004/12/01 08:40:12 otto Exp $";
d53 1
a53 1
	volatile sig_atomic_t	interrupted;
d104 1
a104 1
static bool		bsqrt_stop(const BIGNUM *, const BIGNUM *, u_int *);
d1241 1
a1241 1
bsqrt_stop(const BIGNUM *x, const BIGNUM *y, u_int *onecount)
d1249 1
a1249 3
	if (BN_is_one(r))
		(*onecount)++;
	ret = BN_is_zero(r);
d1251 1
a1251 1
	return ret || *onecount > 1;
d1260 1
a1260 1
	u_int		scale, onecount;
a1262 1
	onecount = 0;
d1287 1
a1287 1
			if (bsqrt_stop(x, y, &onecount))
@


