head	1.4;
access;
symbols
	tg-mergetmp-mirosx-1:1.4
	tg-mergefixes-1-branch:1.4.0.8
	tg-mergefixes-1-base:1.4
	MIROS_X:1.4.0.6
	MIROS_X_BASE:1.4
	tg-mergetmp-3:1.4
	MIRBSD_XP_MIRPPC:1.4.0.4
	MIRBSD_XP_SPARC_BASE:1.4
	MIRBSD_XP_SPARC:1.4.0.2
	MIRBSD_7quater:1.1.1.12.4.1
	cvs-200405160640:1.1.1.15
	cvs-200401271800:1.1.1.14
	cvs-200401261630:1.1.1.14
	cvs-200401021645:1.1.1.13
	MIRBSD_7_ALPHA:1.1.1.12.0.6
	MIRBSD_7:1.1.1.12.0.4
	cvs-200312222040:1.1.1.13
	MIRBSD_7ter:1.1.1.12
	MIRBSD_7_DEV:1.1.1.12.0.2
	cvs-200310020700:1.1.1.12
	cvs-200309271030:1.1.1.12
	cvs-200309251530:1.1.1.12
	cvs-200308302005:1.1.1.11
	cvs-200308171200:1.1.1.11
	ctm-3496:1.1.1.11
	ctm-3449:1.1.1.10
	ctm-3437:1.1.1.9
	cvs-200307191805:1.1.1.9
	ctm-3425:1.1.1.8
	cvs-200307091500:1.1.1.7
	cvs-200307081345:1.1.1.7
	ctm-3389:1.1.1.6
	cvs-200306301405:1.1.1.6
	cvs-200306291430:1.1.1.5
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.06.11.20.14.33;	author tg;	state Stab;
branches;
next	1.3;

1.3
date	2004.05.23.18.46.13;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.30.18.15.08;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.52.36;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.52.36;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.54.00;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.42.32;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.52.14;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.06.29.17.35.33;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.06.30.14.12.10;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.07.08.13.46.27;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.07.18.13.51.44;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.07.19.18.58.05;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.07.26.13.23.13;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2003.08.11.18.43.16;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2003.09.25.16.40.38;	author tg;	state Exp;
branches
	1.1.1.12.4.1;
next	1.1.1.13;

1.1.1.13
date	2003.12.22.21.12.50;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2004.01.26.18.57.09;	author tg;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2004.05.16.08.06.52;	author tg;	state Exp;
branches;
next	;

1.1.1.12.4.1
date	2004.05.08.23.22.15;	author bsiegert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@sanify RCS IDs
(these are stripped out via -R .comment ifdef SMALL anyways)
@
text
@/* $MirBSD: src/usr.bin/compress/main.c,v 1.3 2004/05/23 18:46:13 tg Exp $ */
/* $OpenBSD: main.c,v 1.54 2004/02/29 13:59:15 markus Exp $	*/

#ifndef SMALL
static const char copyright[] =
"@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n"
"Copyright (c) 1997-2002 Michael Shalayeff\n";
#endif

#ifndef SMALL
static const char license[] =
"\n"
" Redistribution and use in source and binary forms, with or without\n"
" modification, are permitted provided that the following conditions\n"
" are met:\n"
" 1. Redistributions of source code must retain the above copyright\n"
"    notice, this list of conditions and the following disclaimer.\n"
" 2. Redistributions in binary form must reproduce the above copyright\n"
"    notice, this list of conditions and the following disclaimer in the\n"
"    documentation and/or other materials provided with the distribution.\n"
" 3. Neither the name of the University nor the names of its contributors\n"
"    may be used to endorse or promote products derived from this software\n"
"    without specific prior written permission.\n"
"\n"
" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n"
" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n"
" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n"
" IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,\n"
" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n"
" (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n"
" SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n"
" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n"
" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n"
" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n"
" THE POSSIBILITY OF SUCH DAMAGE.\n";
#endif /* SMALL */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/stat.h>

#include <getopt.h>
#include <err.h>
#include <errno.h>
#include <fts.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <paths.h>
#include "compress.h"

__RCSID("$MirBSD: src/usr.bin/compress/main.c,v 1.3 2004/05/23 18:46:13 tg Exp $");

#define min(a,b) ((a) < (b)? (a) : (b))

int pipin, force, verbose, testmode, list, nosave;
int savename, recurse;
int cat, decomp;
extern char *__progname;

const struct compressor {
	char *name;
	char *suffix;
	u_char *magic;
	void *(*open)(int, const char *, char *, int, u_int32_t, int);
	int (*read)(void *, char *, int);
	int (*write)(void *, const char *, int);
	int (*close)(void *, struct z_info *);
} c_table[] = {
#define M_DEFLATE (&c_table[0])
  { "deflate", ".gz", "\037\213", gz_open, gz_read, gz_write, gz_close },
#define M_COMPRESS (&c_table[1])
#ifndef SMALL
  { "compress", ".Z", "\037\235", z_open,  zread,   zwrite,   z_close },
#endif /* SMALL */
#if 0
#define M_LZH (&c_table[2])
  { "lzh", ".lzh", "\037\240", lzh_open, lzh_read, lzh_write, lzh_close },
#define M_ZIP (&c_table[3])
  { "zip", ".zip", "PK", zip_open, zip_read, zip_write, zip_close },
#define M_PACK (&c_table[4])
  { "pack", ".pak", "\037\036", pak_open, pak_read, pak_write, pak_close },
#endif
  { NULL }
};

#ifndef SMALL
const struct compressor null_method =
{ "null", ".nul", "XX", null_open, null_read, null_write, null_close };
#endif /* SMALL */

int permission(const char *);
void setfile(const char *, struct stat *);
__dead void usage(int);
int docompress(const char *, char *, const struct compressor *,
    int, struct stat *);
int dodecompress(const char *, char *, const struct compressor *,
    int, struct stat *);
const struct compressor *check_method(int);
const char *check_suffix(const char *);
char *set_outfile(const char *, char *, size_t);
void list_stats(const char *, const struct compressor *, struct z_info *);
void verbose_info(const char *, off_t, off_t, u_int32_t);

#define	OPTSTRING	"123456789ab:cdfghlLnNOo:qrS:tvV"
const struct option longopts[] = {
#ifndef SMALL
	{ "ascii",	no_argument,		0, 'a' },
	{ "stdout",	no_argument,		0, 'c' },
	{ "to-stdout",	no_argument,		0, 'c' },
	{ "decompress",	no_argument,		0, 'd' },
	{ "uncompress",	no_argument,		0, 'd' },
	{ "force",	no_argument,		0, 'f' },
	{ "help",	no_argument,		0, 'h' },
	{ "list",	no_argument,		0, 'l' },
	{ "license",	no_argument,		0, 'L' },
	{ "no-name",	no_argument,		0, 'n' },
	{ "name",	no_argument,		0, 'N' },
	{ "quiet",	no_argument,		0, 'q' },
	{ "recursive",	no_argument,		0, 'r' },
	{ "suffix",	required_argument,	0, 'S' },
	{ "test",	no_argument,		0, 't' },
	{ "verbose",	no_argument,		0, 'v' },
	{ "version",	no_argument,		0, 'V' },
	{ "fast",	no_argument,		0, '1' },
	{ "best",	no_argument,		0, '9' },
#endif /* SMALL */
	{ NULL }
};

int
main(int argc, char *argv[])
{
	FTS *ftsp;
	FTSENT *entry;
	struct stat osb;
	const struct compressor *method;
	const char *s;
	char *p, *infile;
	char outfile[MAXPATHLEN], _infile[MAXPATHLEN], suffix[16];
	char *nargv[512];	/* some estimate based on ARG_MAX */
	int bits, exists, oreg, ch, error, i, rc, oflag;

	exists = 0;
	bits = oflag = 0;
	nosave = -1;
	p = __progname;
	if (p[0] == 'g') {
		method = M_DEFLATE;
		bits = 6;
		p++;
	} else
#ifdef SMALL
		method = M_DEFLATE;
#else
		method = M_COMPRESS;
#endif /* SMALL */

	decomp = 0;
	if (!strcmp(p, "zcat")) {
		decomp++;
		cat = 1;
	} else {
		if (p[0] == 'u' && p[1] == 'n') {
			p += 2;
			decomp++;
		}

		if (strcmp(p, "zip") &&
		    strcmp(p, "compress"))
			errx(1, "unknown program name");
	}

	strlcpy(suffix, method->suffix, sizeof(suffix));

	nargv[0] = NULL;
	if ((p = getenv("GZIP")) != NULL) {
		char *last;

		nargv[0] = *argv++;
		for (i = 1, (p = strtok_r(p, " ", &last)); p != NULL;
		    (p = strtok_r(NULL, " ", &last)), i++)
			if (i < sizeof(nargv)/sizeof(nargv[1]) - argc - 1)
				nargv[i] = p;
			else {
				errx(1, "GZIP is too long");
			}
		argc += i - 1;
		while ((nargv[i++] = *argv++))
			;
		argv = nargv;
	}

	while ((ch = getopt_long(argc, argv, OPTSTRING, longopts, NULL)) != -1)
		switch(ch) {
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			method = M_DEFLATE;
			strlcpy(suffix, method->suffix, sizeof(suffix));
			bits = ch - '0';
			break;
		case 'a':
			warnx("option -a is ignored on this system");
			break;
		case 'b':
			bits = strtol(optarg, &p, 10);
			/*
			 * POSIX 1002.3 says 9 <= bits <= 14 for portable
			 * apps, but says the implementation may allow
			 * greater.
			 */
			if (*p)
				errx(1, "illegal bit count -- %s", optarg);
			break;
		case 'c':
			cat = 1;
			break;
		case 'd':		/* Backward compatible. */
			decomp++;
			break;
		case 'f':
			force++;
			break;
		case 'g':
			method = M_DEFLATE;
			strlcpy(suffix, method->suffix, sizeof(suffix));
			bits = 6;
			break;
		case 'l':
			list++;
			testmode++;
			decomp++;
			break;
		case 'n':
			nosave = 1;
			break;
		case 'N':
			nosave = 0;
			break;
#ifndef SMALL
		case 'O':
			method = M_COMPRESS;
			strlcpy(suffix, method->suffix, sizeof(suffix));
			break;
#endif /* SMALL */
		case 'o':
			if (strlcpy(outfile, optarg,
			    sizeof(outfile)) >= sizeof(outfile))
				errx(1, "-o argument is too long");
			oflag = 1;
			break;
		case 'q':
			verbose = -1;
			break;
		case 'S':
			p = suffix;
			if (optarg[0] != '.')
				*p++ = '.';
			strlcpy(p, optarg, sizeof(suffix) - (p - suffix));
			p = optarg;
			break;
		case 't':
			testmode = 1;
			decomp++;
			break;
		case 'V':
			printf("MirOS compress\n");
			exit (0);
		case 'v':
			verbose++;
			break;
#ifndef SMALL
		case 'L':
			fputs(copyright, stderr);
			fputs(license, stderr);
#endif
			exit (0);
		case 'r':
			recurse++;
			break;

		case 'h':
			usage(0);
			break;
		default:
			usage(1);
		}
	argc -= optind;
	argv += optind;

	if (argc == 0) {
		if (nargv[0] == NULL)
			argv = nargv;
		/* XXX - make sure we don't oflow nargv in $GZIP case (millert) */
		argv[0] = "/dev/stdin";
		argv[1] = NULL;
		pipin++;
		if (!oflag)
			cat = 1;
	} else {
		for (i = 0; i < argc; i++) {
			if (argv[i][0] == '-' && argv[i][1] == '\0') {
				argv[i] = "/dev/stdin";
				pipin++;
				cat = 1;
			}
		}
	}
	if (oflag && (recurse || argc > 1))
		errx(1, "-o option may only be used with a single input file");

	if ((cat && argc) + testmode + oflag > 1)
		errx(1, "may not mix -o, -c, or -t options");
	if (nosave == -1)
		nosave = decomp;

	if ((ftsp = fts_open(argv, FTS_PHYSICAL|FTS_NOCHDIR, 0)) == NULL)
		err(1, NULL);
	for (rc = SUCCESS; (entry = fts_read(ftsp)) != NULL;) {
		infile = entry->fts_path;
		switch (entry->fts_info) {
		case FTS_D:
			if (!recurse) {
				warnx("%s is a directory: ignored",
				    infile);
				fts_set(ftsp, entry, FTS_SKIP);
			}
			continue;
		case FTS_DP:
			continue;
		case FTS_NS:
			/*
			 * If file does not exist and has no suffix,
			 * tack on the default suffix and try that.
			 */
			/* XXX - is overwriting fts_statp legal? (millert) */
			if (entry->fts_errno == ENOENT &&
			    strchr(entry->fts_accpath, '.') == NULL &&
			    snprintf(_infile, sizeof(_infile), "%s%s", infile,
			    suffix) < sizeof(_infile) &&
			    stat(_infile, entry->fts_statp) == 0 &&
			    S_ISREG(entry->fts_statp->st_mode)) {
				infile = _infile;
				break;
			}
		case FTS_ERR:
		case FTS_DNR:
			warnx("%s: %s", infile, strerror(entry->fts_errno));
			rc = rc ? rc : WARNING;
			continue;
		default:
			if (!S_ISREG(entry->fts_statp->st_mode) && !pipin &&
			    !(S_ISLNK(entry->fts_statp->st_mode) && cat)) {
				warnx("%s not a regular file%s",
				    infile, cat ? "" : ": unchanged");
				rc = rc ? rc : WARNING;
				continue;
			}
			break;
		}

		if (!decomp && !pipin && (s = check_suffix(infile)) != NULL) {
			warnx("%s already has %s suffix -- unchanged",
			    infile, s);
			rc = rc ? rc : WARNING;
			continue;
		}

		if (cat)
			strlcpy(outfile, "/dev/stdout", sizeof outfile);
		else if (!oflag) {
			if (decomp) {
				if (set_outfile(infile, outfile,
				    sizeof outfile) == NULL) {
					if (!recurse) {
						warnx("%s: unknown suffix: "
						    "ignored", infile);
						rc = rc ? rc : WARNING;
					}
					continue;
				}
			} else {
				if (snprintf(outfile, sizeof(outfile),
				    "%s%s", infile, suffix) >= sizeof(outfile)) {
					warnx("%s%s: name too long",
					    infile, suffix);
					rc = rc ? rc : WARNING;
					continue;
				}
			}
		}

		if (!testmode)
			exists = !stat(outfile, &osb);
		if (!force && exists && S_ISREG(osb.st_mode) &&
		    !permission(outfile)) {
			rc = rc ? rc : WARNING;
			continue;
		}

		oreg = !exists || S_ISREG(osb.st_mode);

		if (verbose > 0 && !pipin && !list)
			fprintf(stderr, "%s:\t", infile);

		error = (decomp ? dodecompress : docompress)
			(infile, outfile, method, bits, entry->fts_statp);

		switch (error) {
		case SUCCESS:
			if (!cat && !testmode) {
				setfile(outfile, entry->fts_statp);
				if (!pipin && unlink(infile) && verbose >= 0)
					warn("input: %s", infile);
			}
			break;
		case WARNING:
			rc = rc ? rc : WARNING;
			break;
		default:
			rc = FAILURE;
			if (oreg && unlink(outfile) && errno != ENOENT &&
			    verbose >= 0) {
				if (force)
					warn("output: %s", outfile);
				else
					err(1, "output: %s", outfile);
			}
			break;
		}
	}
	if (list)
		list_stats(NULL, NULL, NULL);

	exit(rc);
}

int
docompress(const char *in, char *out, const struct compressor *method,
    int bits, struct stat *sb)
{
	u_char buf[Z_BUFSIZE];
	char *name;
	int error, ifd, ofd, flags;
	void *cookie;
	ssize_t nr;
	u_int32_t mtime;
	struct z_info info;

	mtime = 0;
	flags = 0;
	error = SUCCESS;
	name = NULL;
	cookie  = NULL;

	if ((ifd = open(in, O_RDONLY)) < 0) {
		if (verbose >= 0)
			warn("%s", out);
		return (FAILURE);
	}

	if ((ofd = open(out, O_WRONLY|O_CREAT, S_IWUSR)) < 0) {
		if (verbose >= 0)
			warn("%s", out);
		(void) close(ifd);
		return (FAILURE);
	}

	if (method != M_COMPRESS && !force && isatty(ofd)) {
		if (verbose >= 0)
			warnx("%s: won't write compressed data to terminal",
			    out);
		(void) close(ofd);
		(void) close(ifd);
		return (FAILURE);
	}

	if (!pipin && !nosave) {
		name = basename(in);
		mtime = (u_int32_t)sb->st_mtime;
	}
	if ((cookie = (*method->open)(ofd, "w", name, bits, mtime, flags)) == NULL) {
		if (verbose >= 0)
			warn("%s", in);
		(void) close(ofd);
		(void) close(ifd);
		return (FAILURE);
	}

	while ((nr = read(ifd, buf, sizeof(buf))) > 0)
		if ((method->write)(cookie, buf, nr) != nr) {
			if (verbose >= 0)
				warn("%s", out);
			error = FAILURE;
			break;
		}

	if (!error && nr < 0) {
		if (verbose >= 0)
			warn("%s", in);
		error = FAILURE;
	}

	if ((method->close)(cookie, &info)) {
		if (!error && verbose >= 0)
			warn("%s", out);
		error = FAILURE;
	}

	if (close(ifd)) {
		if (!error && verbose >= 0)
			warn("%s", in);
		error = FAILURE;
	}

	if (!force && info.total_out >= info.total_in) {
		if (verbose > 0)
			fprintf(stderr, "file would grow; left unmodified\n");
		error = FAILURE;
	}

	if (!error && verbose > 0)
		verbose_info(out, info.total_out, info.total_in, info.hlen);

	return (error);
}

const struct compressor *
check_method(int fd)
{
	const struct compressor *method;
	u_char magic[2];

	if (read(fd, magic, sizeof(magic)) != 2)
		return (NULL);
	for (method = &c_table[0]; method->name != NULL; method++) {
		if (magic[0] == method->magic[0] &&
		    magic[1] == method->magic[1])
			return (method);
	}
#ifndef SMALL
	if (force && cat) {
		null_magic[0] = magic[0];
		null_magic[1] = magic[1];
		return (&null_method);
	}
#endif /* SMALL */
	return (NULL);
}

int
dodecompress(const char *in, char *out, const struct compressor *method,
    int bits, struct stat *sb)
{
	u_char buf[Z_BUFSIZE];
	int error, ifd, ofd;
	void *cookie;
	ssize_t nr;
	struct z_info info;

	error = SUCCESS;
	cookie = NULL;

	if ((ifd = open(in, O_RDONLY)) < 0) {
		if (verbose >= 0)
			warn("%s", in);
		return -1;
	}

	if (!force && isatty(ifd)) {
		if (verbose >= 0)
			warnx("%s: won't read compressed data from terminal",
			    in);
		close (ifd);
		return -1;
	}

	if ((method = check_method(ifd)) == NULL) {
		if (verbose >= 0)
			warnx("%s: unrecognized file format", in);
		close (ifd);
		return -1;
	}

	/* XXX - open constrains outfile to MAXPATHLEN so this is safe */
	if ((cookie = (*method->open)(ifd, "r", nosave ? NULL : out,
	    bits, 0, 1)) == NULL) {
		if (verbose >= 0)
			warn("%s", in);
		close (ifd);
		return (FAILURE);
	}

	if (testmode)
		ofd = -1;
	else if ((ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR)) < 0) {
		if (verbose >= 0)
			warn("%s", in);
		(method->close)(cookie, NULL);
		return (FAILURE);
	}

	while ((nr = (method->read)(cookie, buf, sizeof(buf))) > 0) {
		if (ofd != -1 && write(ofd, buf, nr) != nr) {
			if (verbose >= 0)
				warn("%s", out);
			error = FAILURE;
			break;
		}
	}

	if (!error && nr < 0) {
		if (verbose >= 0)
			warnx("%s: %s", in,
			    errno == EINVAL ? "crc error" : strerror(errno));
		error = errno == EINVAL ? WARNING : FAILURE;
	}

	if ((method->close)(cookie, &info)) {
		if (!error && verbose >= 0)
			warnx("%s", in);
		error = FAILURE;
	}

	if (!nosave) {
		if (info.mtime != 0) {
			sb->st_mtimespec.tv_sec =
			    sb->st_atimespec.tv_sec = info.mtime;
			sb->st_mtimespec.tv_nsec =
			    sb->st_atimespec.tv_nsec = 0;
		} else
			nosave = 1;		/* no timestamp to restore */

		if (cat && strcmp(out, "/dev/stdout") != 0)
			cat = 0;		/* have a real output name */
	}

	if (ofd != -1 && close(ofd)) {
		if (!error && verbose >= 0)
			warn("%s", out);
		error = FAILURE;
	}

	if (!error) {
		if (list) {
			if (info.mtime == 0)
				info.mtime = (u_int32_t)sb->st_mtime;
			list_stats(out, method, &info);
		} else if (verbose > 0) {
			verbose_info(out, info.total_in, info.total_out,
			    info.hlen);
		}
	}

	return (error);
}

void
setfile(const char *name, struct stat *fs)
{
	struct timeval tv[2];

	if (!pipin || !nosave) {
		TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
		TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
		if (utimes(name, tv))
			warn("utimes: %s", name);
	}

	/*
	 * If input was a pipe we don't have any info to restore but we
	 * must set the mode since the current mode on the file is 0200.
	 */
	if (pipin) {
		mode_t mask = umask(022);
		chmod(name, DEFFILEMODE & ~mask);
		umask(mask);
		return;
	}

	/*
	 * Changing the ownership probably won't succeed, unless we're root
	 * or POSIX_CHOWN_RESTRICTED is not set.  Set uid/gid before setting
	 * the mode; current BSD behavior is to remove all setuid bits on
	 * chown.  If chown fails, lose setuid/setgid bits.
	 */
	fs->st_mode &= S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO;
	if (chown(name, fs->st_uid, fs->st_gid)) {
		if (errno != EPERM)
			warn("chown: %s", name);
		fs->st_mode &= ~(S_ISUID|S_ISGID);
	}
	if (chmod(name, fs->st_mode))
		warn("chown: %s", name);

	if (fs->st_flags && chflags(name, fs->st_flags))
		warn("chflags: %s", name);
}

int
permission(const char *fname)
{
	int ch, first;

	if (!isatty(fileno(stderr)))
		return (0);
	(void)fprintf(stderr, "overwrite %s? ", fname);
	first = ch = getchar();
	while (ch != '\n' && ch != EOF)
		ch = getchar();
	return (first == 'y');
}

/*
 * Check infile for a known suffix and return the suffix portion or NULL.
 */
const char *
check_suffix(const char *infile)
{
	int i;
	char *suf, *sep, *separators = ".-_";
	static char *suffixes[] = { "Z", "gz", "z", "tgz", "taz", "cgz", "ngz", NULL };

	for (sep = separators; *sep != '\0'; sep++) {
		if ((suf = strrchr(infile, *sep)) == NULL)
			continue;
		suf++;

		for (i = 0; suffixes[i] != NULL; i++) {
			if (strcmp(suf, suffixes[i]) == 0)
				return (suf - 1);
		}
	}
	return (NULL);
}

/*
 * Set outfile based on the suffix.  In most cases we just strip
 * off the suffix but things like .tgz and .taz are special.
 */
char *
set_outfile(const char *infile, char *outfile, size_t osize)
{
	const char *s;
	char *cp;

	if ((s = check_suffix(infile)) == NULL)
		return (NULL);

	(void)strlcpy(outfile, infile, osize);
	cp = outfile + (s - infile) + 1;
	/*
	 * Convert tgz and taz -> tar, else drop the suffix.
	 */
	if (strcmp(cp, "tgz") == 0) {
		cp[1] = 'a';
		cp[2] = 'r';
	} else if (!strcmp(cp, "cgz") || !strcmp(cp, "ngz")) {
		*--cp = 0;
		strlcat(outfile, ".cpio", osize);
	} else if (strcmp(cp, "taz") == 0)
		cp[2] = 'r';
	else
		cp[-1] = '\0';
	return (outfile);
}

/*
 * Print output for the -l option.
 */
void
list_stats(const char *name, const struct compressor *method,
    struct z_info *info)
{
	static off_t compressed_total, uncompressed_total, header_total;
	static u_int nruns;
	char *timestr;

	if (nruns == 0) {
		if (verbose >= 0) {
			if (verbose > 0)
				fputs("method  crc      date   time  ", stdout);
			puts("compressed  uncompressed  ratio  uncompressed_name");
		}
	}
	nruns++;

	if (name != NULL) {
		if (strcmp(name, "/dev/stdout") == 0)
			name += 5;
		if (verbose > 0) {
			timestr = ctime(&info->mtime) + 4;
			timestr[12] = '\0';
			if (timestr[4] == ' ')
				timestr[4] = '0';
			printf("%-7.7s %08x %s ", method->name, info->crc,
				timestr);
		}
		printf("%10lld    %10lld  %4.1f%%  %s\n",
		    (long long)(info->total_in + info->hlen),
		    (long long)info->total_out,
		    (info->total_out - info->total_in) *
		    100.0 / info->total_out, name);
		compressed_total += info->total_in;
		uncompressed_total += info->total_out;
		header_total += info->hlen;
	} else if (verbose >= 0) {
		if (nruns < 3)		/* only do totals for > 1 files */
			return;
		if (verbose > 0)
			fputs("                              ", stdout);
		printf("%10lld    %10lld  %4.1f%%  (totals)\n",
		    (long long)(compressed_total + header_total),
		    (long long)uncompressed_total,
		    (uncompressed_total - compressed_total) *
		    100.0 / uncompressed_total);
	}
}

void
verbose_info(const char *file, off_t compressed, off_t uncompressed,
    u_int32_t hlen)
{
	if (testmode) {
		fputs("OK\n", stderr);
		return;
	}
	if (!pipin) {
		fprintf(stderr, "\t%4.1f%% -- replaced with %s\n",
		    (uncompressed - compressed) * 100.0 / uncompressed, file);
	}
	compressed += hlen;
	fprintf(stderr, "%lld bytes in, %lld bytes out\n",
	    (long long)(decomp ? compressed : uncompressed),
	    (long long)(decomp ? uncompressed : compressed));
}

__dead void
usage(int status)
{
	fprintf(stderr,
	    "usage: %s [-cdfghOqrtvV] [-b bits] [-S suffix] [-[1-9]] [file ...]\n",
	    __progname);
	exit(status);
}
@


1.3
log
@* big OpenBSD 3.5-current merge
* adaption of share/doc Makefiles
* revival of the ancient "learn" utility
  XXX possible flaws!
* whitespace, config and comment cleanup in ssh
* add soelim, which was previously missing, and crunch
* add MirOS ELF note support to file
@
text
@d1 1
a1 1
/* $MirBSD: src/usr.bin/compress/main.c,v 1.2 2004/04/30 18:15:08 tg Exp $ */
d56 1
a56 1
__RCSID("$MirBSD$");
a276 1
#ifndef SMALL
d278 1
a278 3
			printf("%s\n%s\n", main_rcsid, gz_rcsid);
			printf("%s\n%s\n", z_rcsid, null_rcsid);
#endif
@


1.2
log
@handle *.cgz and *.ngz on gunzip like *[-._]tgz -> convert to *.cpio
@
text
@d1 2
a2 2
/* $MirBSD$ */
/* $OpenBSD: main.c,v 1.53 2004/01/22 18:50:39 millert Exp $	*/
a38 4
#ifndef SMALL
static const char main_rcsid[] = "$MirBSD$";
#endif

d56 2
d148 1
d407 2
a408 1
		exists = !stat(outfile, &osb);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: main.c,v 1.21 2003/01/07 18:48:06 millert Exp $	*/
d4 1
d9 1
d11 1
d22 3
a24 4
" 3. All advertising materials mentioning features or use of this software\n"
"    must display the following acknowledgement:\n"
"      This product includes software developed by the University of\n"
"      California, Berkeley and its contributors.\n"
d37 1
d39 2
a40 5
#ifndef lint
#if 0
static char sccsid[] = "@@(#)compress.c	8.2 (Berkeley) 1/7/94";
#else
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.21 2003/01/07 18:48:06 millert Exp $";
a41 1
#endif /* not lint */
d51 1
d64 1
a64 1
int bits, cat, decomp;
d70 2
a71 2
	int (*check_header)(int, struct stat *, const char *);
	void *(*open)(int, const char *, int);
d74 1
a74 1
	int (*close)(void *);
d76 6
a81 4
#define M_COMPRESS (&c_table[0])
  { "compress", ".Z", z_check_header,  z_open,  zread,   zwrite,   zclose },
#define M_DEFLATE (&c_table[1])
  { "deflate", ".gz", gz_check_header, gz_open, gz_read, gz_write, gz_close },
d84 1
a84 1
  { "lzh", ".lzh", lzh_check_header, lzh_open, lzh_read, lzh_write, lzh_close },
d86 1
a86 1
  { "zip", ".zip", zip_check_header, zip_open, zip_read, zip_write, zip_close },
d88 1
a88 1
  { "pack", ".pak",pak_check_header, pak_open, pak_read, pak_write, pak_close },
d93 5
d100 10
a109 4
void usage(void);
int compress(const char *, const char *, const struct compressor *, int, struct stat *);
int decompress(const char *, const char *, const struct compressor *, int, struct stat *);
const struct compressor *check_method(int, struct stat *, const char *);
d113 1
d133 1
d138 1
a138 3
main(argc, argv)
	int argc;
	char *argv[];
d144 2
a145 1
	char *p, *s, *infile;
d148 1
a148 1
	int exists, oreg, ch, error, i, rc, oflag;
d150 2
a151 1
	bits = cat = oflag = decomp = 0;
d158 3
d162 1
d182 1
a182 1
	if ((s = getenv("GZIP")) != NULL) {
d186 1
a186 1
		for (i = 1, (p = strtok_r(s, " ", &last)); p;
d243 2
d247 1
a247 1
			nosave++;
d250 1
a250 1
			nosave = 0;	/* XXX not yet */
d252 1
d257 1
d276 1
d278 1
d280 3
a282 2
			printf("%s\n%s\n%s\n", main_rcsid,
			    z_rcsid, gz_rcsid);
d287 1
d291 1
d298 2
a299 1
		case '?':
d301 1
a301 1
			usage();
d313 10
a322 1
		cat = 1;
d327 1
a327 1
	if (cat + testmode + oflag > 1)
d329 2
d334 1
a334 2
	/* XXX - set rc in cases where we "continue" below? */
	for (rc = 0; (entry = fts_read(ftsp)) != NULL;) {
d364 1
a364 1
			error = 1;
d367 5
a371 3
			if (!S_ISREG(entry->fts_statp->st_mode) && !pipin) {
				warnx("%s not a regular file: unchanged",
				    infile);
d377 9
a385 4
		if (testmode)
			strcpy(outfile, _PATH_DEVNULL);
		else if (cat)
			strcpy(outfile, "/dev/stdout");
d388 3
a390 11
				const struct compressor *m = method;

				if ((s = strrchr(infile, '.')) != NULL &&
				    strcmp(s, suffix) != 0) {
					for (m = &c_table[0];
					    m->name && strcmp(s, m->suffix);
					    m++)
						;
				}
				if (s == NULL || m->name == NULL) {
					if (!recurse)
d393 2
a396 3
				method = m;
				strlcpy(outfile, infile,
				    min(sizeof(outfile), (s - infile) + 1));
d402 1
d410 2
a411 1
		    !permission(outfile))
d413 1
d417 1
a417 1
		if (verbose > 0)
d420 1
a420 1
		error = (decomp ? decompress : compress)
d423 3
a425 9
		if (!error && !cat && !testmode && stat(outfile, &osb) == 0) {
			if (!force && !decomp &&
			    osb.st_size >= entry->fts_statp->st_size) {
				if (verbose > 0)
					fprintf(stderr, "file would grow; "
						     "left unmodified\n");
				error = 1;
				rc = rc ? rc : 2;
			} else {
d427 1
a427 2

				if (unlink(infile) && verbose >= 0)
a428 12

				if (verbose > 0) {
					u_int ratio;
					ratio = (1000 * osb.st_size)
					    / entry->fts_statp->st_size;
					fprintf(stderr, "%u", ratio / 10);
					if (ratio % 10)
						fprintf(stderr, ".%u",
						        ratio % 10);
					fputc('%', stderr);
					fputc(' ', stderr);
				}
d430 14
a444 10

		if (error > 0 && oreg && unlink(outfile) && errno != ENOENT &&
		    verbose >= 0) {
			if (force) {
				warn("output: %s", outfile);
				rc = 1;
			} else
				err(1, "output: %s", outfile);
		} else if (!error && verbose > 0)
			fputs("OK\n", stderr);
d446 2
d453 2
a454 6
compress(in, out, method, bits, sb)
	const char *in;
	const char *out;
	const struct compressor *method;
	int bits;
	struct stat *sb;
d457 2
a458 1
	int error, ifd, ofd;
d461 2
d464 4
a467 1
	error = 0;
d473 1
a473 1
		return (-1);
d479 2
a480 1
		return (-1);
d486 4
a489 2
			      out);
		return (-1);
d492 11
a502 1
	if ((cookie = (*method->open)(ofd, "w", bits)) != NULL) {
d504 7
a510 8
		while ((nr = read(ifd, buf, sizeof(buf))) > 0)
			if ((method->write)(cookie, buf, nr) != nr) {
				if (verbose >= 0)
					warn("%s", out);
				error++;
				break;
			}
	}
d512 2
a513 2
	if (cookie == NULL || nr < 0) {
		if (!error && verbose >= 0)
d515 1
a515 1
		error++;
d518 1
a518 1
	if (cookie == NULL || (method->close)(cookie)) {
d521 1
a521 2
		error++;
		(void) close(ofd);
d526 8
a533 2
			warn("%s", out);
		error++;
d536 3
d543 1
a543 4
check_method(fd, sb, out)
	int fd;
	struct stat *sb;
	const char *out;
d546 1
d548 15
a562 9
	for (method = &c_table[0];
	     method->name != NULL && !(*method->check_header)(fd, sb, out);
	     method++)
		;

	if (method->name == NULL)
		method = NULL;

	return (method);
d566 2
a567 6
decompress(in, out, method, bits, sb)
	const char *in;
	const char *out;
	const struct compressor *method;
	int bits;
	struct stat *sb;
d573 1
d575 1
a575 1
	error = 0;
d587 1
a587 1
			      in);
d592 1
a592 1
	if (!pipin && (method = check_method(ifd, sb, out)) == NULL) {
d599 20
a618 2
	if ((cookie = (*method->open)(ifd, "r", bits)) != NULL) {
		if ((ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR)) < 0) {
d620 3
a622 3
				warn("%s", in);
			(method->close)(cookie);
			return -1;
d624 1
d626 5
a630 7
		while ((nr = (method->read)(cookie, buf, sizeof(buf))) > 0)
			if (write(ofd, buf, nr) != nr) {
				if (verbose >= 0)
					warn("%s", out);
				error++;
				break;
			}
d633 1
a633 1
	if (cookie == NULL || (method->close)(cookie) || nr < 0) {
d635 15
a649 3
			warn("%s", in);
		error++;
		close (ifd);
d652 1
a652 1
	if (close(ofd)) {
d655 12
a666 1
		error++;
d673 1
a673 3
setfile(name, fs)
	const char *name;
	struct stat *fs;
d677 6
a682 1
	fs->st_mode &= S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO;
d684 10
a693 4
	TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
	TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
	if (utimes(name, tv))
		warn("utimes: %s", name);
d701 1
d715 1
a715 2
permission(fname)
	const char *fname;
d728 106
d835 19
a853 1
usage()
d856 1
a856 1
	    "usage: %s [-cdfghlnLOqrStvV] [-b <bits>] [-[0-9]] [file ...]\n",
d858 1
a858 1
	exit(1);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2003/04/07 20:55:33 deraadt Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.22 2003/04/07 20:55:33 deraadt Exp $";
d336 1
a336 1
			strlcpy(outfile, _PATH_DEVNULL, sizeof outfile);
d338 1
a338 1
			strlcpy(outfile, "/dev/stdout", sizeof outfile);
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2003/06/04 04:55:58 deraadt Exp $	*/
d18 4
a21 3
" 3. Neither the name of the University nor the names of its contributors\n"
"    may be used to endorse or promote products derived from this software\n"
"    without specific prior written permission.\n"
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.23 2003/06/04 04:55:58 deraadt Exp $";
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2003/06/10 22:20:45 deraadt Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.24 2003/06/10 22:20:45 deraadt Exp $";
d121 3
a123 1
main(int argc, char *argv[])
d424 6
a429 2
compress(const char *in, const char *out, const struct compressor *method,
    int bits, struct stat *sb)
d492 4
a495 1
check_method(int fd, struct stat *sb, const char *out)
d511 6
a516 2
decompress(const char *in, const char *out, const struct compressor *method,
    int bits, struct stat *sb)
d581 3
a583 1
setfile(const char *name, struct stat *fs)
d613 2
a614 1
permission(const char *fname)
d628 1
a628 1
usage(void)
@


1.1.1.5
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2003/06/27 17:33:26 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.29 2003/06/27 17:33:26 millert Exp $";
d92 2
a93 4
int compress(const char *, const char *, const struct compressor *,
    int, struct stat *);
int decompress(const char *, const char *, const struct compressor *,
    int, struct stat *);
a248 1
			decomp++;
a280 8
	} else {
		for (i = 0; i < argc; i++) {
			if (argv[i][0] == '-' && argv[i][1] == '\0') {
				argv[i] = "/dev/stdin";
				pipin++;
				cat = 1;
			}
		}
d325 2
a326 2
				warnx("%s not a regular file%s",
				    infile, cat ? "" : ": unchanged");
d384 1
a384 1
					    "left unmodified\n");
d400 1
a400 1
						    ratio % 10);
d448 1
a448 1
			    out);
d491 2
a492 2
	    method->name != NULL && !(*method->check_header)(fd, sb, out);
	    method++)
d522 1
a522 1
			    in);
d615 1
a615 1
	    "usage: %s [-cdfgOqrtvV] [-b bits] [-S suffix] [-[1-9]] [file ...]\n",
@


1.1.1.6
log
@more fixes from -current
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2003/06/30 03:42:05 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.31 2003/06/30 03:42:05 millert Exp $";
d91 1
a91 1
__dead void usage(int);
d269 1
a269 2
			usage(0);
			break;
d271 1
a271 1
			usage(1);
d564 1
a564 2
			warnx("%s: %s", in,
			    errno == EINVAL ? "crc error" : strerror(errno));
d622 2
a623 2
__dead void
usage(int status)
d626 1
a626 1
	    "usage: %s [-cdfghOqrtvV] [-b bits] [-S suffix] [-[1-9]] [file ...]\n",
d628 1
a628 1
	exit(status);
@


1.1.1.7
log
@Most recent fixes from anoncvs.comstyle.com in:
ports/shells/ast-ksh src/usr.bin/compress src/usr.bin/diff src/sys/netinet6
 src/sys/netinet

From: Christian Weisgerber <naddy@@cvs.openbsd.org>
Log message:
Forced update to 2003-06-21 because older distfiles have been removed.

From: Michael Shalayeff <mickey@@cvs.openbsd.org>
Log message:
fix fd closing logicand close in gzopen(); found by wilfried@@ and millert@@ ok

From: Todd C. Miller <millert@@cvs.openbsd.org>
Log message:
o Avoid a temp file if using stdin and stdin is redirected from a regular file
o Fix a double free in the temmp file case

From: Jun-ichiro itojun Hagino <itojun@@cvs.openbsd.org>
Log message:
on interface removal, clear multicast forwarding stuff.  from kame

From: Markus Friedl <markus@@cvs.openbsd.org>
Log message:
make sure the packets contains a complete inner header
for ip{4,6}-in-ip{4,6} encapsulation; fixes panic
for truncated ip-in-ip over ipsec; ok angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2003/07/08 00:30:12 mickey Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.32 2003/07/08 00:30:12 mickey Exp $";
a453 1
		(void) close(ifd);
a460 2
		(void) close(ofd);
		(void) close(ifd);
d464 9
a472 6
	if ((cookie = (*method->open)(ofd, "w", bits)) == NULL) {
		if (verbose >= 0)
			warn("%s", in);
		(void) close(ofd);
		(void) close(ifd);
		return (-1);
d475 2
a476 10
	while ((nr = read(ifd, buf, sizeof(buf))) > 0)
		if ((method->write)(cookie, buf, nr) != nr) {
			if (verbose >= 0)
				warn("%s", out);
			error++;
			break;
		}

	if (!error && nr < 0) {
		if (verbose >= 0)
d481 1
a481 1
	if ((method->close)(cookie)) {
d485 1
d490 1
a490 1
			warn("%s", in);
d493 1
a493 1
	
d546 2
a547 17
	if ((cookie = (*method->open)(ifd, "r", bits)) == NULL) {
		if (verbose >= 0)
			warn("%s", in);
		error++;
		close (ifd);
		return -1;
	}

	if ((ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR)) < 0) {
		if (verbose >= 0)
			warn("%s", in);
		(method->close)(cookie);
		return -1;
	}

	while ((nr = (method->read)(cookie, buf, sizeof(buf))) > 0)
		if (write(ofd, buf, nr) != nr) {
d549 3
a551 3
				warn("%s", out);
			error++;
			break;
d554 7
a560 5
	if (!error && nr < 0) {
		if (verbose >= 0)
			warnx("%s: %s", in,
			    errno == EINVAL ? "crc error" : strerror(errno));
		error++;
d563 1
a563 1
	if ((method->close)(cookie)) {
d565 2
a566 1
			warnx("%s", in);
d568 1
@


1.1.1.8
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2003/07/17 20:06:01 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.37 2003/07/17 20:06:01 millert Exp $";
a49 1
#include <libgen.h>
d62 1
a62 1
int cat, decomp;
d68 2
a69 2
	u_char *magic;
	void *(*open)(int, const char *, char *, int, u_int32_t, int);
d72 1
a72 1
	int (*close)(void *, struct z_info *);
d75 1
a75 1
  { "compress", ".Z", "\037\235", z_open,  zread,   zwrite,   z_close },
d77 1
a77 1
  { "deflate", ".gz", "\037\213", gz_open, gz_read, gz_write, gz_close },
d80 1
a80 1
  { "lzh", ".lzh", "\037\240", lzh_open, lzh_read, lzh_write, lzh_close },
d82 1
a82 1
  { "zip", ".zip", "PK", zip_open, zip_read, zip_write, zip_close },
d84 1
a84 1
  { "pack", ".pak", "\037\036", pak_open, pak_read, pak_write, pak_close },
d92 1
a92 1
int compress(const char *, char *, const struct compressor *,
d94 1
a94 1
int decompress(const char *, char *, const struct compressor *,
d96 1
a96 5
const struct compressor *check_method(int);
const char *check_suffix(const char *);
char *set_outfile(const char *, char *, size_t);
void list_stats(const char *, const struct compressor *, struct z_info *);
void verbose_info(const char *, off_t, off_t, u_int32_t);
d129 1
a129 2
	const char *s;
	char *p, *infile;
d132 1
a132 1
	int bits, exists, oreg, ch, error, i, rc, oflag;
d161 1
a161 1
	if ((p = getenv("GZIP")) != NULL) {
d165 1
a165 1
		for (i = 1, (p = strtok_r(p, " ", &last)); p != NULL;
a221 2
			testmode++;
			decomp++;
d224 1
a224 1
			nosave = 1;
d227 1
a227 1
			nosave = -1;
d297 1
a297 1
	if ((cat && argc) + testmode + oflag > 1)
d302 2
a303 1
	for (rc = SUCCESS; (entry = fts_read(ftsp)) != NULL;) {
d333 1
a333 1
			rc = rc ? rc : WARNING;
a338 1
				rc = rc ? rc : WARNING;
d344 3
a346 8
		if (!decomp && !pipin && (s = check_suffix(infile)) != NULL) {
			warnx("%s already has %s suffix -- unchanged",
			    infile, s);
			rc = rc ? rc : WARNING;
			continue;
		}

		if (cat)
d350 10
a359 2
				if (set_outfile(infile, outfile,
				    sizeof outfile) == NULL) {
d365 3
d380 1
a380 2
		    !permission(outfile)) {
			rc = rc ? rc : WARNING;
a381 1
		}
d385 1
a385 1
		if (verbose > 0 && !pipin && !list)
d391 9
a399 3
		switch (error) {
		case SUCCESS:
			if (!cat && !testmode) {
d401 2
a402 1
				if (!pipin && unlink(infile) && verbose >= 0)
d404 12
a416 14
			break;
		case WARNING:
			rc = rc ? rc : WARNING;
			break;
		default:
			rc = FAILURE;
			if (oreg && unlink(outfile) && errno != ENOENT &&
			    verbose >= 0) {
				if (force)
					warn("output: %s", outfile);
				else
					err(1, "output: %s", outfile);
			}
			break;
d418 10
a428 2
	if (list)
		list_stats(NULL, NULL, NULL);
d434 1
a434 1
compress(const char *in, char *out, const struct compressor *method,
d438 1
a438 2
	char *name;
	int error, ifd, ofd, flags;
a440 2
	u_int32_t mtime;
	struct z_info info;
d442 1
a442 4
	mtime = 0;
	flags = 0;
	error = SUCCESS;
	name = NULL;
d448 1
a448 1
		return (FAILURE);
d455 1
a455 1
		return (FAILURE);
d464 1
a464 1
		return (FAILURE);
d467 1
a467 5
	if (!pipin && nosave <= 0) {
		name = basename(in);
		mtime = (u_int32_t)sb->st_mtime;
	}
	if ((cookie = (*method->open)(ofd, "w", name, bits, mtime, flags)) == NULL) {
d472 1
a472 1
		return (FAILURE);
d479 1
a479 1
			error = FAILURE;
d486 1
a486 1
		error = FAILURE;
d489 1
a489 1
	if ((method->close)(cookie, &info)) {
d492 1
a492 1
		error = FAILURE;
d498 1
a498 1
		error = FAILURE;
a499 9

	if (!force && info.total_out >= info.total_in) {
		if (verbose > 0)
			fprintf(stderr, "file would grow; left unmodified\n");
		error = WARNING;
	}

	if (!error && verbose > 0)
		verbose_info(out, info.total_out, info.total_in, info.hlen);
d505 1
a505 1
check_method(int fd)
a507 1
	u_char magic[2];
d509 9
a517 8
	if (read(fd, magic, sizeof(magic)) != 2)
		return (NULL);
	for (method = &c_table[0]; method->name != NULL; method++) {
		if (magic[0] == method->magic[0] &&
		    magic[1] == method->magic[1])
			return (method);
	}
	return (NULL);
d521 1
a521 1
decompress(const char *in, char *out, const struct compressor *method,
a527 1
	struct z_info info;
d529 1
a529 1
	error = SUCCESS;
d546 1
a546 1
	if ((method = check_method(ifd)) == NULL) {
d553 1
a553 3
	/* XXX - open constrains outfile to MAXPATHLEN so this is safe */
	if ((cookie = (*method->open)(ifd, "r", nosave < 0 ? out : NULL,
	    bits, 0, 1)) == NULL) {
d556 1
d558 1
a558 1
		return (FAILURE);
d561 1
a561 3
	if (testmode)
		ofd = -1;
	else if ((ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR)) < 0) {
d564 2
a565 2
		(method->close)(cookie, NULL);
		return (FAILURE);
d568 2
a569 2
	while ((nr = (method->read)(cookie, buf, sizeof(buf))) > 0) {
		if (ofd != -1 && write(ofd, buf, nr) != nr) {
d572 1
a572 1
			error = FAILURE;
a574 1
	}
d580 1
a580 1
		error = errno == EINVAL ? WARNING : FAILURE;
d583 1
a583 1
	if ((method->close)(cookie, &info)) {
d586 1
a586 6
		error = FAILURE;
	}

	if (nosave < 0) {
		sb->st_mtimespec.tv_sec = info.mtime;
		sb->st_mtimespec.tv_nsec = 0;
d589 1
a589 1
	if (ofd != -1 && close(ofd)) {
d592 1
a592 12
		error = FAILURE;
	}

	if (!error) {
		if (list) {
			if (info.mtime == 0)
				info.mtime = (u_int32_t)sb->st_mtime;
			list_stats(pipin ? "stdout" : out, method, &info);
		} else if (verbose > 0) {
			verbose_info(out, info.total_in, info.total_out,
			    info.hlen);
		}
a639 116
}

/*
 * Check infile for a known suffix and return the suffix portion or NULL.
 */
const char *
check_suffix(const char *infile)
{
	int i;
	char *suf, *sep, *separators = ".-_";
	static char *suffixes[] = { "Z", "gz", "z", "tgz", "taz", NULL };

	for (sep = separators; *sep != '\0'; sep++) {
		if ((suf = strrchr(infile, *sep)) == NULL)
			continue;
		suf++;

		for (i = 0; suffixes[i] != NULL; i++) {
			if (strcmp(suf, suffixes[i]) == 0)
				return (suf - 1);
		}
	}
	return (NULL);
}

/*
 * Set outfile based on the suffix.  In most cases we just strip
 * off the suffix but things like .tgz and .taz are special.
 */
char *
set_outfile(const char *infile, char *outfile, size_t osize)
{
	const char *s;
	char *cp;

	if ((s = check_suffix(infile)) == NULL)
		return (NULL);

	(void)strlcpy(outfile, infile, osize);
	cp = outfile + (s - infile) + 1;
	/*
	 * Convert tgz and taz -> tar, else drop the suffix.
	 */
	if (strcmp(cp, "tgz") == 0) {
		cp[1] = 'a';
		cp[2] = 'r';
	} else if (strcmp(cp, "taz") == 0)
		cp[2] = 'r';
	else
		cp[-1] = '\0';
	return (outfile);
}

/*
 * Print output for the -l option.
 */
void
list_stats(const char *name, const struct compressor *method,
    struct z_info *info)
{
	static off_t compressed_total, uncompressed_total, header_total;
	static u_int nruns;
	char *timestr;

	if (nruns == 0) {
		if (verbose >= 0) {
			if (verbose > 0)
				fputs("method  crc     date  time  ", stdout);
			puts("compressed  uncompr. ratio uncompressed_name");
		}
	}
	nruns++;

	if (name != NULL) {
		if (verbose > 0) {
			timestr = ctime(&info->mtime) + 4;
			timestr[12] = '\0';
			printf("%.5s %08x %s ", method->name, info->crc, timestr);
		}
		printf("%9lld %9lld  %4.1f%% %s\n",
		    (long long)(info->total_in + info->hlen),
		    (long long)info->total_out,
		    (info->total_out - info->total_in) *
		    100.0 / info->total_out, name);
		compressed_total += info->total_in;
		uncompressed_total += info->total_out;
		header_total += info->hlen;
	} else if (verbose >= 0) {
		if (nruns < 3)		/* only do totals for > 1 files */
			return;
		if (verbose > 0)
			fputs("                            ", stdout);
		printf("%9lld %9lld  %4.1f%% (totals)\n",
		    (long long)(compressed_total + header_total),
		    (long long)uncompressed_total,
		    (uncompressed_total - compressed_total) *
		    100.0 / uncompressed_total);
	}
}

void
verbose_info(const char *file, off_t compressed, off_t uncompressed,
    u_int32_t hlen)
{
	if (testmode) {
		fputs("OK\n", stderr);
		return;
	}
	if (!pipin) {
		fprintf(stderr, "\t%4.1f%% -- replaced with %s\n",
		    (uncompressed - compressed) * 100.0 / uncompressed, file);
	}
	compressed += hlen;
	fprintf(stderr, "%lld bytes in, %lld bytes out\n", 
	    (long long)(decomp ? compressed : uncompressed),
	    (long long)(decomp ? uncompressed : compressed));
@


1.1.1.9
log
@Another sync to OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2003/07/18 20:46:42 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.39 2003/07/18 20:46:42 millert Exp $";
a140 1
	nosave = -1;
d235 1
a235 1
			nosave = 0;
d292 1
a292 2
		if (!oflag)
			cat = 1;
a306 2
	if (nosave == -1)
		nosave = decomp;
d464 1
a464 1
	if (!pipin && !nosave) {
d565 1
a565 1
	if ((cookie = (*method->open)(ifd, "r", nosave ? NULL : out,
d604 1
a604 1
	if (!nosave) {
@


1.1.1.10
log
@Import latest OpenBSD ports, XFree and source in sync
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2003/07/25 20:10:53 millert Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.40 2003/07/25 20:10:53 millert Exp $";
d609 2
a610 10
		if (info.mtime != 0) {
			sb->st_mtimespec.tv_sec =
			    sb->st_atimespec.tv_sec = info.mtime;
			sb->st_mtimespec.tv_nsec =
			    sb->st_atimespec.tv_nsec = 0;
		} else
			nosave = 1;		/* no timestamp to restore */

		if (cat && strcmp(out, "/dev/stdout") != 0)
			cat = 0;		/* have a real output name */
d638 1
a638 6
	if (!pipin || !nosave) {
		TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
		TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
		if (utimes(name, tv))
			warn("utimes: %s", name);
	}
d640 4
a643 10
	/*
	 * If input was a pipe we don't have any info to restore but we
	 * must set the mode since the current mode on the file is 0200.
	 */
	if (pipin) {
		mode_t mask = umask(022);
		chmod(name, DEFFILEMODE & ~mask);
		umask(mask);
		return;
	}
a650 1
	fs->st_mode &= S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO;
@


1.1.1.11
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2003/08/05 18:22:17 deraadt Exp $	*/
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.44 2003/08/05 18:22:17 deraadt Exp $";
d509 1
a509 1
		error = FAILURE;
d514 1
a514 1

d631 1
a631 1
			list_stats(out, method, &info);
a758 3
	if (name != NULL && strcmp(name, "/dev/stdout") == 0)
		name += 5;

d808 1
a808 1
	fprintf(stderr, "%lld bytes in, %lld bytes out\n",
@


1.1.1.12
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2003/09/05 21:03:36 henning Exp $	*/
a7 1
#ifndef SMALL
a32 1
#endif /* SMALL */
d38 1
a38 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.47 2003/09/05 21:03:36 henning Exp $";
d75 3
a77 1
#define M_DEFLATE (&c_table[0])
a78 4
#define M_COMPRESS (&c_table[1])
#ifndef SMALL
  { "compress", ".Z", "\037\235", z_open,  zread,   zwrite,   z_close },
#endif /* SMALL */
a89 5
#ifndef SMALL
const struct compressor null_method =
{ "null", ".nul", "XX", null_open, null_read, null_write, null_close };
#endif /* SMALL */

a104 1
#ifndef SMALL
a123 1
#endif /* SMALL */
a147 3
#ifdef SMALL
		method = M_DEFLATE;
#else
a148 1
#endif /* SMALL */
a237 1
#ifndef SMALL
a241 1
#endif /* SMALL */
d264 1
a264 4
#ifndef SMALL
			    z_rcsid,
#endif
			    gz_rcsid);
a270 1
#ifndef SMALL
a271 1
#endif
d347 1
a347 2
			if (!S_ISREG(entry->fts_statp->st_mode) && !pipin &&
			    !(S_ISLNK(entry->fts_statp->st_mode) && cat)) {
a530 7
#ifndef SMALL
	if (force && cat) {
		null_magic[0] = magic[0];
		null_magic[1] = magic[1];
		return (&null_method);
	}
#endif /* SMALL */
@


1.1.1.12.4.1
log
@From 3.4-stable:

Make exit code for "unknown suffix" and "name too long" match GNU gzip.
Fixes an interaction with the perl CPAN module which checks the exit value.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47.2.1 2004/01/31 04:17:53 brad Exp $	*/
d40 1
a40 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.47.2.1 2004/01/31 04:17:53 brad Exp $";
d392 1
a392 1
					if (!recurse) {
a394 2
						rc = rc ? rc : WARNING;
					}
a401 1
					rc = rc ? rc : WARNING;
@


1.1.1.13
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2003/12/16 23:32:24 henning Exp $	*/
a2 1
#ifndef SMALL
a6 1
#endif
d36 5
a40 2
#ifndef SMALL
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.52 2003/12/16 23:32:24 henning Exp $";
d42 1
d102 1
a102 1
int docompress(const char *, char *, const struct compressor *,
d104 1
a104 1
int dodecompress(const char *, char *, const struct compressor *,
d151 1
a151 1
	bits = oflag = 0;
d279 2
d282 1
a282 3
		case 'V':
			printf("%s\n%s\n", main_rcsid, gz_rcsid);
			printf("%s\n%s\n", z_rcsid, null_rcsid);
d284 1
a288 1
#ifndef SMALL
d291 1
d419 1
a419 1
		error = (decomp ? dodecompress : docompress)
d452 1
a452 1
docompress(const char *in, char *out, const struct compressor *method,
d565 1
a565 1
dodecompress(const char *in, char *out, const struct compressor *method,
d789 3
d795 2
a796 2
				fputs("method  crc      date   time  ", stdout);
			puts("compressed  uncompressed  ratio  uncompressed_name");
a801 2
		if (strcmp(name, "/dev/stdout") == 0)
			name += 5;
d805 1
a805 4
			if (timestr[4] == ' ')
				timestr[4] = '0';
			printf("%-7.7s %08x %s ", method->name, info->crc,
				timestr);
d807 1
a807 1
		printf("%10lld    %10lld  %4.1f%%  %s\n",
d819 2
a820 2
			fputs("                              ", stdout);
		printf("%10lld    %10lld  %4.1f%%  (totals)\n",
@


1.1.1.14
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.53 2004/01/22 18:50:39 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.53 2004/01/22 18:50:39 millert Exp $";
d389 1
a389 1
					if (!recurse) {
a391 2
						rc = rc ? rc : WARNING;
					}
a398 1
					rc = rc ? rc : WARNING;
@


1.1.1.15
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.54 2004/02/29 13:59:15 markus Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.54 2004/02/29 13:59:15 markus Exp $";
a148 1
	exists = 0;
d407 1
a407 2
		if (!testmode)
			exists = !stat(outfile, &osb);
@


