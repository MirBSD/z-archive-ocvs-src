head	1.3;
access;
symbols
	tg-mergetmp-mirosx-1:1.3
	tg-mergefixes-1-branch:1.3.0.4
	tg-mergefixes-1-base:1.3
	MIROS_X:1.3.0.2
	MIROS_X_BASE:1.3
	tg-mergetmp-3:1.3
	MIRBSD_XP_MIRPPC:1.2.0.4
	cvs-200410222040:1.1.1.3
	tg-mergetmp-1:1.1.1.2
	MIRBSD_XP_SPARC_BASE:1.2
	MIRBSD_XP_SPARC:1.2.0.2
	MIRBSD_7quater:1.1.1.2
	cvs-200405160640:1.1.1.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.6
	MIRBSD_7:1.1.1.2.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.1.1.2
	MIRBSD_7_DEV:1.1.1.2.0.2
	cvs-200310020700:1.1.1.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.10.22.21.53.46;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.26.12.25.59;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.17.52.40;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.52.40;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.06.19.12.52.24;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.10.22.20.49.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@merge; fix; whitespace; bump libc level
XXX untested
@
text
@/**	$MirBSD$ */
/*	$OpenBSD: softmagic.c,v 1.11 2004/05/19 02:32:36 tedu Exp $ */
/*
 * Copyright (c) Ian F. Darwin 1986-1995.
 * Software written by Ian F. Darwin and others;
 * maintained 1995-present by Christos Zoulas and others.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * softmagic - interpret variable magic from MAGIC
 */

#include "file.h"
#include "magic.h"
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include <time.h>
#include <regex.h>

__RCSID("$MirBSD: src/usr.bin/file/softmagic.c,v 1.2 2004/07/26 12:25:59 tg Stab $");

private int match(struct magic_set *, struct magic *, uint32_t,
    const unsigned char *, size_t);
private int mget(struct magic_set *, union VALUETYPE *, const unsigned char *,
    struct magic *, size_t);
private int mcheck(struct magic_set *, union VALUETYPE *, struct magic *);
private int32_t mprint(struct magic_set *, union VALUETYPE *, struct magic *);
private void mdebug(uint32_t, const char *, size_t);
private int mconvert(struct magic_set *, union VALUETYPE *, struct magic *);
private int check_mem(struct magic_set *, unsigned int);

/*
 * softmagic - lookup one file in database
 * (already read from MAGIC by apprentice.c).
 * Passed the name and FILE * of one file to be typed.
 */
/*ARGSUSED1*/		/* nbytes passed for regularity, maybe need later */
protected int
file_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes)
{
	struct mlist *ml;
	for (ml = ms->mlist->next; ml != ms->mlist; ml = ml->next)
		if (match(ms, ml->magic, ml->nmagic, buf, nbytes))
			return 1;

	return 0;
}

/*
 * Go through the whole list, stopping if you find a match.  Process all
 * the continuations of that match before returning.
 *
 * We support multi-level continuations:
 *
 *	At any time when processing a successful top-level match, there is a
 *	current continuation level; it represents the level of the last
 *	successfully matched continuation.
 *
 *	Continuations above that level are skipped as, if we see one, it
 *	means that the continuation that controls them - i.e, the
 *	lower-level continuation preceding them - failed to match.
 *
 *	Continuations below that level are processed as, if we see one,
 *	it means we've finished processing or skipping higher-level
 *	continuations under the control of a successful or unsuccessful
 *	lower-level continuation, and are now seeing the next lower-level
 *	continuation and should process it.  The current continuation
 *	level reverts to the level of the one we're seeing.
 *
 *	Continuations at the current level are processed as, if we see
 *	one, there's no lower-level continuation that may have failed.
 *
 *	If a continuation matches, we bump the current continuation level
 *	so that higher-level continuations are processed.
 */
private int
match(struct magic_set *ms, struct magic *magic, uint32_t nmagic,
    const unsigned char *s, size_t nbytes)
{
	uint32_t magindex = 0;
	unsigned int cont_level = 0;
	int need_separator = 0;
	union VALUETYPE p;
	int32_t oldoff = 0;
	int returnval = 0; /* if a match is found it is set to 1*/
	int firstline = 1; /* a flag to print X\n  X\n- X */

	if (check_mem(ms, cont_level) == -1)
		return -1;

	for (magindex = 0; magindex < nmagic; magindex++) {
		/* if main entry matches, print it... */
		int flush = !mget(ms, &p, s, &magic[magindex], nbytes);
		switch (mcheck(ms, &p, &magic[magindex])) {
		case -1:
			return -1;
		case 0:
			flush++;
			break;
		default:
			break;
		}
		if (flush) {
			/*
			 * main entry didn't match,
			 * flush its continuations
			 */
			while (magindex < nmagic - 1 &&
			       magic[magindex + 1].cont_level != 0)
			       magindex++;
			continue;
		}

		if (!firstline) { /* we found another match */
			/* put a newline and '-' to do some simple formatting*/
			if (file_printf(ms, "\n- ") == -1)
				return -1;
		}

		if ((ms->c.off[cont_level] = mprint(ms, &p, &magic[magindex]))
		    == -1)
			return -1;
		/*
		 * If we printed something, we'll need to print
		 * a blank before we print something else.
		 */
		if (magic[magindex].desc[0])
			need_separator = 1;
		/* and any continuations that match */
		if (check_mem(ms, ++cont_level) == -1)
			return -1;

		while (magic[magindex+1].cont_level != 0 &&
		       ++magindex < nmagic) {
			if (cont_level < magic[magindex].cont_level)
				continue;
			if (cont_level > magic[magindex].cont_level) {
				/*
				 * We're at the end of the level
				 * "cont_level" continuations.
				 */
				cont_level = magic[magindex].cont_level;
			}
			if (magic[magindex].flag & OFFADD) {
				oldoff=magic[magindex].offset;
				magic[magindex].offset += ms->c.off[cont_level-1];
			}
			if (!mget(ms, &p, s, &magic[magindex], nbytes))
				goto done;

			switch (mcheck(ms, &p, &magic[magindex])) {
			case -1:
				return -1;
			case 0:
				break;
			default:
				/*
				 * This continuation matched.
				 * Print its message, with
				 * a blank before it if
				 * the previous item printed
				 * and this item isn't empty.
				 */
				/* space if previous printed */
				if (need_separator
				    && (magic[magindex].nospflag == 0)
				   && (magic[magindex].desc[0] != '\0')) {
					if (file_printf(ms, " ") == -1)
						return -1;
					need_separator = 0;
				}
				if ((ms->c.off[cont_level] = mprint(ms, &p,
				    &magic[magindex])) == -1)
					return -1;
				if (magic[magindex].desc[0])
					need_separator = 1;

				/*
				 * If we see any continuations
				 * at a higher level,
				 * process them.
				 */
				if (check_mem(ms, ++cont_level) == -1)
					return -1;
			}
done:
			if (magic[magindex].flag & OFFADD) {
				 magic[magindex].offset = oldoff;
			}
		}
		firstline = 0;
		returnval = 1;
		if ((ms->flags & MAGIC_CONTINUE) == 0) {
			return 1; /* don't keep searching */
		}
	}
	return returnval;  /* This is hit if -k is set or there is no match */
}

private int
check_mem(struct magic_set *ms, unsigned int level)
{
	size_t len;

	if (level < ms->c.len)
		return 0;

	len = (ms->c.len += 20) * sizeof(*ms->c.off);
	ms->c.off = (ms->c.off == NULL) ? malloc(len) : realloc(ms->c.off, len);
	if (ms->c.off != NULL)
		return 0;
	file_oomem(ms);
	return -1;
}

private int32_t
mprint(struct magic_set *ms, union VALUETYPE *p, struct magic *m)
{
	uint32_t v;
	int32_t t=0 ;
	time_t tv;


  	switch (m->type) {
  	case FILE_BYTE:
		v = file_signextend(ms, m, (size_t)p->b);
		if (file_printf(ms, m->desc, (unsigned char) v) == -1)
			return -1;
		t = m->offset + sizeof(char);
		break;

  	case FILE_SHORT:
  	case FILE_BESHORT:
  	case FILE_LESHORT:
		v = file_signextend(ms, m, (size_t)p->h);
		if (file_printf(ms, m->desc, (unsigned short) v) == -1)
			return -1;
		t = m->offset + sizeof(short);
		break;

  	case FILE_LONG:
  	case FILE_BELONG:
  	case FILE_LELONG:
		v = file_signextend(ms, m, p->l);
		if (file_printf(ms, m->desc, (uint32_t) v) == -1)
			return -1;
		t = m->offset + sizeof(int32_t);
  		break;

  	case FILE_STRING:
  	case FILE_PSTRING:
		if (m->reln == '=') {
			if (file_printf(ms, m->desc, m->value.s) == -1)
				return -1;
			t = m->offset + strlen(m->value.s);
		}
		else {
			if (*m->value.s == '\0') {
				char *cp = strchr(p->s,'\n');
				if (cp)
					*cp = '\0';
			}
			if (file_printf(ms, m->desc, p->s) == -1)
				return -1;
			t = m->offset + strlen(p->s);
		}
		break;

	case FILE_DATE:
	case FILE_BEDATE:
	case FILE_LEDATE:
		if (file_printf(ms, m->desc, file_fmttime(p->l, 1)) == -1)
			return -1;
		t = m->offset + sizeof(time_t);
		break;

	case FILE_LDATE:
	case FILE_BELDATE:
	case FILE_LELDATE:
		if (file_printf(ms, m->desc, file_fmttime(p->l, 0)) == -1)
			return -1;
		t = m->offset + sizeof(time_t);
		break;
	case FILE_REGEX:
	  	if (file_printf(ms, m->desc, p->s) == -1)
			return -1;
		t = m->offset + strlen(p->s);
		break;

	default:
		file_error(ms, 0, "invalid m->type (%d) in mprint()", m->type);
		return -1;
	}
	return(t);
}

/*
 * Convert the byte order of the data we are looking at
 * While we're here, let's apply the mask operation
 * (unless you have a better idea)
 */
private int
mconvert(struct magic_set *ms, union VALUETYPE *p, struct magic *m)
{
	switch (m->type) {
	case FILE_BYTE:
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->b &= m->mask;
				break;
			case FILE_OPOR:
				p->b |= m->mask;
				break;
			case FILE_OPXOR:
				p->b ^= m->mask;
				break;
			case FILE_OPADD:
				p->b += m->mask;
				break;
			case FILE_OPMINUS:
				p->b -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->b *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->b /= m->mask;
				break;
			case FILE_OPMODULO:
				p->b %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->b = ~p->b;
		return 1;
	case FILE_SHORT:
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->h &= m->mask;
				break;
			case FILE_OPOR:
				p->h |= m->mask;
				break;
			case FILE_OPXOR:
				p->h ^= m->mask;
				break;
			case FILE_OPADD:
				p->h += m->mask;
				break;
			case FILE_OPMINUS:
				p->h -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->h *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->h /= m->mask;
				break;
			case FILE_OPMODULO:
				p->h %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->h = ~p->h;
		return 1;
	case FILE_LONG:
	case FILE_DATE:
	case FILE_LDATE:
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->l &= m->mask;
				break;
			case FILE_OPOR:
				p->l |= m->mask;
				break;
			case FILE_OPXOR:
				p->l ^= m->mask;
				break;
			case FILE_OPADD:
				p->l += m->mask;
				break;
			case FILE_OPMINUS:
				p->l -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->l *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->l /= m->mask;
				break;
			case FILE_OPMODULO:
				p->l %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->l = ~p->l;
		return 1;
	case FILE_STRING:
		{
			int n;

			/* Null terminate and eat *trailing* return */
			p->s[sizeof(p->s) - 1] = '\0';
			n = strlen(p->s) - 1;
			if (p->s[n] == '\n')
				p->s[n] = '\0';
			return 1;
		}
	case FILE_PSTRING:
		{
			char *ptr1 = p->s, *ptr2 = ptr1 + 1;
			unsigned int n = *p->s;
			if (n >= sizeof(p->s))
				n = sizeof(p->s) - 1;
			while (n--)
				*ptr1++ = *ptr2++;
			*ptr1 = '\0';
			n = strlen(p->s) - 1;
			if (p->s[n] == '\n')
				p->s[n] = '\0';
			return 1;
		}
	case FILE_BESHORT:
		p->h = (short)((p->hs[0]<<8)|(p->hs[1]));
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->h &= m->mask;
				break;
			case FILE_OPOR:
				p->h |= m->mask;
				break;
			case FILE_OPXOR:
				p->h ^= m->mask;
				break;
			case FILE_OPADD:
				p->h += m->mask;
				break;
			case FILE_OPMINUS:
				p->h -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->h *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->h /= m->mask;
				break;
			case FILE_OPMODULO:
				p->h %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->h = ~p->h;
		return 1;
	case FILE_BELONG:
	case FILE_BEDATE:
	case FILE_BELDATE:
		p->l = (int32_t)
		    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->l &= m->mask;
				break;
			case FILE_OPOR:
				p->l |= m->mask;
				break;
			case FILE_OPXOR:
				p->l ^= m->mask;
				break;
			case FILE_OPADD:
				p->l += m->mask;
				break;
			case FILE_OPMINUS:
				p->l -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->l *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->l /= m->mask;
				break;
			case FILE_OPMODULO:
				p->l %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->l = ~p->l;
		return 1;
	case FILE_LESHORT:
		p->h = (short)((p->hs[1]<<8)|(p->hs[0]));
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->h &= m->mask;
				break;
			case FILE_OPOR:
				p->h |= m->mask;
				break;
			case FILE_OPXOR:
				p->h ^= m->mask;
				break;
			case FILE_OPADD:
				p->h += m->mask;
				break;
			case FILE_OPMINUS:
				p->h -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->h *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->h /= m->mask;
				break;
			case FILE_OPMODULO:
				p->h %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->h = ~p->h;
		return 1;
	case FILE_LELONG:
	case FILE_LEDATE:
	case FILE_LELDATE:
		p->l = (int32_t)
		    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->l &= m->mask;
				break;
			case FILE_OPOR:
				p->l |= m->mask;
				break;
			case FILE_OPXOR:
				p->l ^= m->mask;
				break;
			case FILE_OPADD:
				p->l += m->mask;
				break;
			case FILE_OPMINUS:
				p->l -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->l *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->l /= m->mask;
				break;
			case FILE_OPMODULO:
				p->l %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->l = ~p->l;
		return 1;
	case FILE_REGEX:
		return 1;
	default:
		file_error(ms, 0, "invalid type %d in mconvert()", m->type);
		return 0;
	}
}


private void
mdebug(uint32_t offset, const char *str, size_t len)
{
	(void) fprintf(stderr, "mget @@%d: ", offset);
	file_showstr(stderr, str, len);
	(void) fputc('\n', stderr);
	(void) fputc('\n', stderr);
}

private int
mget(struct magic_set *ms, union VALUETYPE *p, const unsigned char *s,
    struct magic *m, size_t nbytes)
{
	uint32_t offset = m->offset;

	if (m->type == FILE_REGEX) {
		/*
		 * offset is interpreted as last line to search,
		 * (starting at 1), not as bytes-from start-of-file
		 */
		unsigned char *b, *last = NULL;
		if ((p->buf = strdup((const char *)s)) == NULL) {
			file_oomem(ms);
			return -1;
		}
		for (b = (unsigned char *)p->buf; offset &&
		    (b = (unsigned char *)strchr((char *)b, '\n')) != NULL;
		    offset--, s++)
			last = b;
		if (last != NULL)
			*last = '\0';
	} else if (offset + sizeof(union VALUETYPE) <= nbytes)
		memcpy(p, s + offset, sizeof(union VALUETYPE));
	else {
		/*
		 * the usefulness of padding with zeroes eludes me, it
		 * might even cause problems
		 */
		memset(p, 0, sizeof(union VALUETYPE));
		if (offset < nbytes)
			memcpy(p, s + offset, nbytes - offset);
	}

	/* Verify we have enough data to match magic type */
	switch (m->type) {
		case FILE_BYTE:
			if (nbytes < (offset + 1)) /* should alway be true */
				return 0;
			break;

		case FILE_SHORT:
		case FILE_BESHORT:
		case FILE_LESHORT:
			if (nbytes < (offset + 2))
				return 0;
			break;

		case FILE_LONG:
		case FILE_BELONG:
		case FILE_LELONG:
		case FILE_DATE:
		case FILE_BEDATE:
		case FILE_LEDATE:
		case FILE_LDATE:
		case FILE_BELDATE:
		case FILE_LELDATE:
			if (nbytes < (offset + 4))
				return 0;
			break;

		case FILE_STRING:
		case FILE_PSTRING:
			if (nbytes < (offset + m->vallen))
				return 0;
			break;
	}

	if ((ms->flags & MAGIC_DEBUG) != 0) {
		mdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));
		file_mdump(m);
	}

	if (m->flag & INDIR) {
		switch (m->in_type) {
		case FILE_BYTE:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = p->b & m->in_offset;
					break;
				case FILE_OPOR:
					offset = p->b | m->in_offset;
					break;
				case FILE_OPXOR:
					offset = p->b ^ m->in_offset;
					break;
				case FILE_OPADD:
					offset = p->b + m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = p->b - m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = p->b * m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = p->b / m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = p->b % m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_BESHORT:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) &
						 m->in_offset;
					break;
				case FILE_OPOR:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) |
						 m->in_offset;
					break;
				case FILE_OPXOR:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) ^
						 m->in_offset;
					break;
				case FILE_OPADD:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) +
						 m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) -
						 m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) *
						 m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) /
						 m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) %
						 m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_LESHORT:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) &
						 m->in_offset;
					break;
				case FILE_OPOR:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) |
						 m->in_offset;
					break;
				case FILE_OPXOR:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) ^
						 m->in_offset;
					break;
				case FILE_OPADD:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) +
						 m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) -
						 m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) *
						 m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) /
						 m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) %
						 m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_SHORT:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = p->h & m->in_offset;
					break;
				case FILE_OPOR:
					offset = p->h | m->in_offset;
					break;
				case FILE_OPXOR:
					offset = p->h ^ m->in_offset;
					break;
				case FILE_OPADD:
					offset = p->h + m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = p->h - m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = p->h * m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = p->h / m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = p->h % m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_BELONG:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) &
						 m->in_offset;
					break;
				case FILE_OPOR:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) |
						 m->in_offset;
					break;
				case FILE_OPXOR:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) ^
						 m->in_offset;
					break;
				case FILE_OPADD:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) +
						 m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) -
						 m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) *
						 m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) /
						 m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) %
						 m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_LELONG:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) &
						 m->in_offset;
					break;
				case FILE_OPOR:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) |
						 m->in_offset;
					break;
				case FILE_OPXOR:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) ^
						 m->in_offset;
					break;
				case FILE_OPADD:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) +
						 m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) -
						 m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) *
						 m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) /
						 m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) %
						 m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_LONG:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = p->l & m->in_offset;
					break;
				case FILE_OPOR:
					offset = p->l | m->in_offset;
					break;
				case FILE_OPXOR:
					offset = p->l ^ m->in_offset;
					break;
				case FILE_OPADD:
					offset = p->l + m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = p->l - m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = p->l * m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = p->l / m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = p->l % m->in_offset;
					break;
			/*	case TOOMANYSWITCHBLOCKS:
			 *		ugh = p->eye % m->strain;
			 *		rub;
			 *	case BEER:
			 *		off = p->tab & m->in_gest;
			 *		sleep;
			 */
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		}

		if (nbytes < sizeof(union VALUETYPE) ||
		    nbytes - sizeof(union VALUETYPE) < offset)
			return 0;

		memcpy(p, s + offset, sizeof(union VALUETYPE));

		if ((ms->flags & MAGIC_DEBUG) != 0) {
			mdebug(offset, (char *)(void *)p,
			    sizeof(union VALUETYPE));
			file_mdump(m);
		}
	}
	if (!mconvert(ms, p, m))
	  return 0;
	return 1;
}

private int
mcheck(struct magic_set *ms, union VALUETYPE *p, struct magic *m)
{
	uint32_t l = m->value.l;
	uint32_t v;
	int matched;

	if ( (m->value.s[0] == 'x') && (m->value.s[1] == '\0') ) {
		return 1;
	}


	switch (m->type) {
	case FILE_BYTE:
		v = p->b;
		break;

	case FILE_SHORT:
	case FILE_BESHORT:
	case FILE_LESHORT:
		v = p->h;
		break;

	case FILE_LONG:
	case FILE_BELONG:
	case FILE_LELONG:
	case FILE_DATE:
	case FILE_BEDATE:
	case FILE_LEDATE:
	case FILE_LDATE:
	case FILE_BELDATE:
	case FILE_LELDATE:
		v = p->l;
		break;

	case FILE_STRING:
	case FILE_PSTRING:
	{
		/*
		 * What we want here is:
		 * v = strncmp(m->value.s, p->s, m->vallen);
		 * but ignoring any nulls.  bcmp doesn't give -/+/0
		 * and isn't universally available anyway.
		 */
		unsigned char *a = (unsigned char*)m->value.s;
		unsigned char *b = (unsigned char*)p->s;
		int len = m->vallen;
		l = 0;
		v = 0;
		if (0L == m->mask) { /* normal string: do it fast */
			while (--len >= 0)
				if ((v = *b++ - *a++) != '\0')
					break;
		} else { /* combine the others */
			while (--len >= 0) {
				if ((m->mask & STRING_IGNORE_LOWERCASE) &&
				    islower(*a)) {
					if ((v = tolower(*b++) - *a++) != '\0')
						break;
				} else if ((m->mask & STRING_COMPACT_BLANK) &&
				    isspace(*a)) {
					a++;
					if (isspace(*b++)) {
						while (isspace(*b))
							b++;
					} else {
						v = 1;
						break;
					}
				} else if (isspace(*a) &&
				    (m->mask & STRING_COMPACT_OPTIONAL_BLANK)) {
					a++;
					while (isspace(*b))
						b++;
				} else {
					if ((v = *b++ - *a++) != '\0')
						break;
				}
			}
		}
		break;
	}
	case FILE_REGEX:
	{
		int rc;
		regex_t rx;
		char errmsg[512];

		rc = regcomp(&rx, m->value.s, REG_EXTENDED|REG_NOSUB);
		if (rc) {
			free(p->buf);
			regerror(rc, &rx, errmsg, sizeof(errmsg));
			file_error(ms, 0, "regex error %d, (%s)", rc, errmsg);
			return -1;
		} else {
			rc = regexec(&rx, p->buf, 0, 0, 0);
			regfree(&rx);
			free(p->buf);
			return !rc;
		}
	}
	default:
		file_error(ms, 0, "invalid type %d in mcheck()", m->type);
		return -1;
	}

	if (m->type != FILE_STRING && m->type != FILE_PSTRING)
		v = file_signextend(ms, m, v);

	switch (m->reln) {
	case 'x':
		if ((ms->flags & MAGIC_DEBUG) != 0)
			(void) fprintf(stderr, "%u == *any* = 1\n", v);
		matched = 1;
		break;

	case '!':
		matched = v != l;
		if ((ms->flags & MAGIC_DEBUG) != 0)
			(void) fprintf(stderr, "%u != %u = %d\n",
				       v, l, matched);
		break;

	case '=':
		matched = v == l;
		if ((ms->flags & MAGIC_DEBUG) != 0)
			(void) fprintf(stderr, "%u == %u = %d\n",
				       v, l, matched);
		break;

	case '>':
		if (m->flag & UNSIGNED) {
			matched = v > l;
			if ((ms->flags & MAGIC_DEBUG) != 0)
				(void) fprintf(stderr, "%u > %u = %d\n",
					       v, l, matched);
		}
		else {
			matched = (int32_t) v > (int32_t) l;
			if ((ms->flags & MAGIC_DEBUG) != 0)
				(void) fprintf(stderr, "%d > %d = %d\n",
					       v, l, matched);
		}
		break;

	case '<':
		if (m->flag & UNSIGNED) {
			matched = v < l;
			if ((ms->flags & MAGIC_DEBUG) != 0)
				(void) fprintf(stderr, "%u < %u = %d\n",
					       v, l, matched);
		}
		else {
			matched = (int32_t) v < (int32_t) l;
			if ((ms->flags & MAGIC_DEBUG) != 0)
				(void) fprintf(stderr, "%d < %d = %d\n",
					       v, l, matched);
		}
		break;

	case '&':
		matched = (v & l) == l;
		if ((ms->flags & MAGIC_DEBUG) != 0)
			(void) fprintf(stderr, "((%x & %x) == %x) = %d\n",
				       v, l, l, matched);
		break;

	case '^':
		matched = (v & l) != l;
		if ((ms->flags & MAGIC_DEBUG) != 0)
			(void) fprintf(stderr, "((%x & %x) != %x) = %d\n",
				       v, l, l, matched);
		break;

	default:
		matched = 0;
		file_error(ms, 0, "cannot happen: invalid relation `%c'",
		    m->reln);
		return -1;
	}

	return matched;
}
@


1.2
log
@magic(5) says, date/bedate/ledate is a four-byte value,
so zero out the upper four bytes of a 64-bit time_t :-(
@
text
@d1 2
a2 3
/* $MirBSD$ */
/* $OpenBSD: softmagic.c,v 1.10 2003/06/13 18:31:14 deraadt Exp $	*/

a3 2
 * softmagic - interpret variable magic from /etc/magic
 *
d30 3
d34 2
a35 2
#include <sys/types.h>
#include <stdio.h>
d37 1
d40 1
a40 1
#include <err.h>
d42 1
a42 3
#include "file.h"

__RCSID("$MirBSD$");
d44 9
a52 6
static int match(unsigned char *, int);
static int mget(union VALUETYPE *, unsigned char *, struct magic *, int);
static int mcheck(union VALUETYPE *, struct magic *);
static int32_t mprint(union VALUETYPE *, struct magic *);
static void mdebug(int32_t, char *, int);
static int mconvert(union VALUETYPE *, struct magic *);
d56 1
a56 1
 * (already read from /etc/magic by apprentice.c).
d60 2
a61 4
int
softmagic(buf, nbytes)
unsigned char *buf;
int nbytes;
d63 4
a66 2
	if (match(buf, nbytes))
		return 1;
d98 3
a100 4
static int
match(s, nbytes)
unsigned char	*s;
int nbytes;
d102 2
a103 2
	int magindex = 0;
	int cont_level = 0;
a105 2
	static int32_t *tmpoff = NULL;
	static size_t tmplen = 0;
d107 2
d110 2
a111 3
	if (tmpoff == NULL)
		if ((tmpoff = (int32_t *) malloc(tmplen = 20)) == NULL)
			err(1, "malloc");
d115 25
a139 10
		if (!mget(&p, s, &magic[magindex], nbytes) ||
		    !mcheck(&p, &magic[magindex])) {
			    /*
			     * main entry didn't match,
			     * flush its continuations
			     */
			    while (magindex < nmagic &&
			    	   magic[magindex + 1].cont_level != 0)
			    	   magindex++;
			    continue;
d142 3
a144 1
		tmpoff[cont_level] = mprint(&p, &magic[magindex]);
d152 3
a154 4
		if (++cont_level >= tmplen)
			if ((tmpoff = (int32_t *) realloc(tmpoff,
						       tmplen += 20)) == NULL)
				err(1, "malloc");
d157 36
a192 46
			if (cont_level >= magic[magindex].cont_level) {
				if (cont_level > magic[magindex].cont_level) {
					/*
					 * We're at the end of the level
					 * "cont_level" continuations.
					 */
					cont_level = magic[magindex].cont_level;
				}
				if (magic[magindex].flag & ADD) {
					oldoff=magic[magindex].offset;
					magic[magindex].offset += tmpoff[cont_level-1];
				}
				if (mget(&p, s, &magic[magindex], nbytes) &&
				    mcheck(&p, &magic[magindex])) {
					/*
					 * This continuation matched.
					 * Print its message, with
					 * a blank before it if
					 * the previous item printed
					 * and this item isn't empty.
					 */
					/* space if previous printed */
					if (need_separator
					   && (magic[magindex].nospflag == 0)
					   && (magic[magindex].desc[0] != '\0')
					   ) {
						(void) putchar(' ');
						need_separator = 0;
					}
					tmpoff[cont_level] = mprint(&p, &magic[magindex]);
					if (magic[magindex].desc[0])
						need_separator = 1;

					/*
					 * If we see any continuations
					 * at a higher level,
					 * process them.
					 */
					if (++cont_level >= tmplen)
						if ((tmpoff =
						    (int32_t *) realloc(tmpoff,
						    tmplen += 20)) == NULL)
							err(1, "malloc");
				}
				if (magic[magindex].flag & ADD) {
					 magic[magindex].offset = oldoff;
d194 17
d213 5
a217 1
		return 1;		/* all through */
d219 17
a235 1
	return 0;			/* no match at all */
d238 2
a239 4
static int32_t
mprint(p, m)
union VALUETYPE *p;
struct magic *m;
a240 1
	char *pp, *rt;
d247 4
a250 4
  	case BYTE:
		v = p->b;
		v = signextend(m, v) & m->mask;
		(void) printf(m->desc, (unsigned char) v);
d254 6
a259 6
  	case SHORT:
  	case BESHORT:
  	case LESHORT:
		v = p->h;
		v = signextend(m, v) & m->mask;
		(void) printf(m->desc, (unsigned short) v);
d263 6
a268 6
  	case LONG:
  	case BELONG:
  	case LELONG:
		v = p->l;
		v = signextend(m, v) & m->mask;
		(void) printf(m->desc, (uint32_t) v);
d272 2
a273 1
  	case STRING:
d275 2
a276 1
			(void) printf(m->desc, m->value.s);
d285 2
a286 1
			(void) printf(m->desc, p->s);
d291 13
a303 8
	case DATE:
	case BEDATE:
	case LEDATE:
		tv = p->l;
		pp = ctime(&tv);
		if ((rt = strchr(pp, '\n')) != NULL)
			*rt = '\0';
		(void) printf(m->desc, pp);
d306 5
d313 2
a314 2
		errx(1, "invalid m->type (%d) in mprint().", m->type);
		/*NOTREACHED*/
d321 2
d324 2
a325 4
static int
mconvert(p, m)
union VALUETYPE *p;
struct magic *m;
d328 61
a388 4
	case BYTE:
	case SHORT:
	case LONG:
	case DATE:
d390 34
a423 1
	case STRING:
d425 1
a425 1
			char *ptr;
d427 1
a427 1
			/* Null terminate and eat the return */
d429 17
a445 2
			if ((ptr = strchr(p->s, '\n')) != NULL)
				*ptr = '\0';
d448 1
a448 1
	case BESHORT:
d450 29
d480 3
a482 2
	case BELONG:
	case BEDATE:
d485 29
d515 1
a515 1
	case LESHORT:
d517 29
d547 3
a549 2
	case LELONG:
	case LEDATE:
d552 31
d585 1
a585 1
		errx(1, "invalid type %d in mconvert().", m->type);
d591 2
a592 5
static void
mdebug(offset, str, len)
int32_t offset;
char *str;
int len;
d595 1
a595 1
	showstr(stderr, (char *) str, len);
d600 3
a602 6
static int
mget(p, s, m, nbytes)
union VALUETYPE* p;
unsigned char	*s;
struct magic *m;
int nbytes;
d604 1
a604 1
	int32_t offset = m->offset;
d606 17
a622 1
	if (offset + sizeof(union VALUETYPE) <= nbytes)
a628 1
		int32_t have = nbytes - offset;
d630 2
a631 2
		if (have > 0)
			memcpy(p, s + offset, have);
d634 6
d641 25
a665 3
	if (debug) {
		mdebug(offset, (char *) p, sizeof(union VALUETYPE));
		mdump(m);
d668 4
a671 2
	if (!mconvert(p, m))
		return 0;
d674 219
a892 4

		switch (m->in.type) {
		case BYTE:
			offset = p->b + m->in.offset;
d894 62
a955 2
		case SHORT:
			offset = p->h + m->in.offset;
d957 37
a993 2
		case LONG:
			offset = p->l + m->in.offset;
d997 2
a998 1
		if (offset + sizeof(union VALUETYPE) > nbytes)
d1003 4
a1006 3
		if (debug) {
			mdebug(offset, (char *) p, sizeof(union VALUETYPE));
			mdump(m);
a1007 3

		if (!mconvert(p, m))
			return 0;
d1009 2
d1014 2
a1015 4
static int
mcheck(p, m)
union VALUETYPE* p;
struct magic *m;
a1021 1
		fprintf(stderr, "BOINK");
d1027 1
a1027 1
	case BYTE:
d1031 3
a1033 3
	case SHORT:
	case BESHORT:
	case LESHORT:
d1037 9
a1045 6
	case LONG:
	case BELONG:
	case LELONG:
	case DATE:
	case BEDATE:
	case LEDATE:
d1049 5
a1053 3
	case STRING:
		l = 0;
		/* What we want here is:
d1058 4
d1063 1
a1063 5
		{
			unsigned char *a = (unsigned char*)m->value.s;
			unsigned char *b = (unsigned char*)p->s;
			int len = m->vallen;

d1067 26
d1095 20
d1116 2
a1117 2
		errx(1, "invalid type %d in mcheck().", m->type);
		return 0;/*NOTREACHED*/
d1120 2
a1121 1
	v = signextend(m, v) & m->mask;
d1125 1
a1125 1
		if (debug)
d1132 1
a1132 1
		if (debug)
d1139 1
a1139 1
		if (debug)
d1147 1
a1147 1
			if (debug)
d1153 1
a1153 1
			if (debug)
d1162 1
a1162 1
			if (debug)
d1168 1
a1168 1
			if (debug)
d1176 1
a1176 1
		if (debug)
d1183 1
a1183 1
		if (debug)
d1190 3
a1192 2
		errx(1, "mcheck: can't happen: invalid relation %d.", m->reln);
		break;/*NOTREACHED*/
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: softmagic.c,v 1.9 2003/03/11 21:26:26 ian Exp $	*/
d10 1
a10 1
 * 
d20 1
a20 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Ian F. Darwin and others.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *  
d43 1
a43 3
#ifndef	lint
static char *moduleid = "$OpenBSD: softmagic.c,v 1.9 2003/03/11 21:26:26 ian Exp $";
#endif	/* lint */
d53 1
a53 1
 * softmagic - lookup one file in database 
d117 1
a117 1
			    /* 
d139 1
a139 1
		while (magic[magindex+1].cont_level != 0 && 
d180 1
a180 1
						if ((tmpoff = 
d203 1
d251 2
a252 1
		pp = ctime((time_t*) &p->l);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.10 2003/06/13 18:31:14 deraadt Exp $	*/
d19 5
d48 1
a48 1
static char *moduleid = "$OpenBSD: softmagic.c,v 1.10 2003/06/13 18:31:14 deraadt Exp $";
@


1.1.1.3
log
@import some updates/fixes from openbsd
@
text
@d1 2
a2 1
/*	$OpenBSD: softmagic.c,v 1.11 2004/05/19 02:32:36 tedu Exp $ */
d4 2
a31 3
/*
 * softmagic - interpret variable magic from MAGIC
 */
d33 2
a34 2
#include "file.h"
#include "magic.h"
a35 1
#include <ctype.h>
d38 1
a38 1
#include <regex.h>
d40 1
d43 1
a43 1
FILE_RCSID("@@(#)$Id: softmagic.c,v 1.11 2004/05/19 02:32:36 tedu Exp $")
d46 6
a51 9
private int match(struct magic_set *, struct magic *, uint32_t,
    const unsigned char *, size_t);
private int mget(struct magic_set *, union VALUETYPE *, const unsigned char *,
    struct magic *, size_t);
private int mcheck(struct magic_set *, union VALUETYPE *, struct magic *);
private int32_t mprint(struct magic_set *, union VALUETYPE *, struct magic *);
private void mdebug(uint32_t, const char *, size_t);
private int mconvert(struct magic_set *, union VALUETYPE *, struct magic *);
private int check_mem(struct magic_set *, unsigned int);
d55 1
a55 1
 * (already read from MAGIC by apprentice.c).
d59 4
a62 2
protected int
file_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes)
d64 2
a65 4
	struct mlist *ml;
	for (ml = ms->mlist->next; ml != ms->mlist; ml = ml->next)
		if (match(ms, ml->magic, ml->nmagic, buf, nbytes))
			return 1;
d97 4
a100 3
private int
match(struct magic_set *ms, struct magic *magic, uint32_t nmagic,
    const unsigned char *s, size_t nbytes)
d102 2
a103 2
	uint32_t magindex = 0;
	unsigned int cont_level = 0;
d106 2
a108 2
	int returnval = 0; /* if a match is found it is set to 1*/
	int firstline = 1; /* a flag to print X\n  X\n- X */
d110 3
a112 2
	if (check_mem(ms, cont_level) == -1)
		return -1;
d116 10
a125 19
		int flush = !mget(ms, &p, s, &magic[magindex], nbytes);
		switch (mcheck(ms, &p, &magic[magindex])) {
		case -1:
			return -1;
		case 0:
			flush++;
			break;
		default:
			break;
		}
		if (flush) {
			/* 
			 * main entry didn't match,
			 * flush its continuations
			 */
			while (magindex < nmagic - 1 &&
			       magic[magindex + 1].cont_level != 0)
			       magindex++;
			continue;
d128 1
a128 9
		if (!firstline) { /* we found another match */
			/* put a newline and '-' to do some simple formatting*/
			if (file_printf(ms, "\n- ") == -1)
				return -1;
		}

		if ((ms->c.off[cont_level] = mprint(ms, &p, &magic[magindex]))
		    == -1)
			return -1;
d136 4
a139 3
		if (check_mem(ms, ++cont_level) == -1)
			return -1;

d142 46
a187 36
			if (cont_level < magic[magindex].cont_level)
				continue;
			if (cont_level > magic[magindex].cont_level) {
				/*
				 * We're at the end of the level
				 * "cont_level" continuations.
				 */
				cont_level = magic[magindex].cont_level;
			}
			if (magic[magindex].flag & OFFADD) {
				oldoff=magic[magindex].offset;
				magic[magindex].offset += ms->c.off[cont_level-1];
			}
			if (!mget(ms, &p, s, &magic[magindex], nbytes))
				goto done;
				
			switch (mcheck(ms, &p, &magic[magindex])) {
			case -1:
				return -1;
			case 0:
				break;
			default:
				/*
				 * This continuation matched.
				 * Print its message, with
				 * a blank before it if
				 * the previous item printed
				 * and this item isn't empty.
				 */
				/* space if previous printed */
				if (need_separator
				    && (magic[magindex].nospflag == 0)
				   && (magic[magindex].desc[0] != '\0')) {
					if (file_printf(ms, " ") == -1)
						return -1;
					need_separator = 0;
a188 17
				if ((ms->c.off[cont_level] = mprint(ms, &p,
				    &magic[magindex])) == -1)
					return -1;
				if (magic[magindex].desc[0])
					need_separator = 1;

				/*
				 * If we see any continuations
				 * at a higher level,
				 * process them.
				 */
				if (check_mem(ms, ++cont_level) == -1)
					return -1;
			}
done:
			if (magic[magindex].flag & OFFADD) {
				 magic[magindex].offset = oldoff;
d191 1
a191 5
		firstline = 0;
		returnval = 1;
		if ((ms->flags & MAGIC_CONTINUE) == 0) {
			return 1; /* don't keep searching */
		}			
d193 1
a193 17
	return returnval;  /* This is hit if -k is set or there is no match */
}

private int
check_mem(struct magic_set *ms, unsigned int level)
{
	size_t len;

	if (level < ms->c.len)
		return 0;

	len = (ms->c.len += 20) * sizeof(*ms->c.off);
	ms->c.off = (ms->c.off == NULL) ? malloc(len) : realloc(ms->c.off, len);
	if (ms->c.off != NULL)
		return 0;
	file_oomem(ms);
	return -1;
d196 4
a199 2
private int32_t
mprint(struct magic_set *ms, union VALUETYPE *p, struct magic *m)
d201 1
d207 4
a210 4
  	case FILE_BYTE:
		v = file_signextend(ms, m, (size_t)p->b);
		if (file_printf(ms, m->desc, (unsigned char) v) == -1)
			return -1;
d214 6
a219 6
  	case FILE_SHORT:
  	case FILE_BESHORT:
  	case FILE_LESHORT:
		v = file_signextend(ms, m, (size_t)p->h);
		if (file_printf(ms, m->desc, (unsigned short) v) == -1)
			return -1;
d223 6
a228 6
  	case FILE_LONG:
  	case FILE_BELONG:
  	case FILE_LELONG:
		v = file_signextend(ms, m, p->l);
		if (file_printf(ms, m->desc, (uint32_t) v) == -1)
			return -1;
d232 1
a232 2
  	case FILE_STRING:
  	case FILE_PSTRING:
d234 1
a234 2
			if (file_printf(ms, m->desc, m->value.s) == -1)
				return -1;
d243 1
a243 2
			if (file_printf(ms, m->desc, p->s) == -1)
				return -1;
d248 7
a254 5
	case FILE_DATE:
	case FILE_BEDATE:
	case FILE_LEDATE:
		if (file_printf(ms, m->desc, file_fmttime(p->l, 1)) == -1)
			return -1;
a257 13
	case FILE_LDATE:
	case FILE_BELDATE:
	case FILE_LELDATE:
		if (file_printf(ms, m->desc, file_fmttime(p->l, 0)) == -1)
			return -1;
		t = m->offset + sizeof(time_t);
		break;
	case FILE_REGEX:
	  	if (file_printf(ms, m->desc, p->s) == -1)
			return -1;
		t = m->offset + strlen(p->s);
		break;

d259 2
a260 2
		file_error(ms, 0, "invalid m->type (%d) in mprint()", m->type);
		return -1;
a266 2
 * While we're here, let's apply the mask operation
 * (unless you have a better idea)
d268 4
a271 2
private int
mconvert(struct magic_set *ms, union VALUETYPE *p, struct magic *m)
d274 4
a277 30
	case FILE_BYTE:
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->b &= m->mask;
				break;
			case FILE_OPOR:
				p->b |= m->mask;
				break;
			case FILE_OPXOR:
				p->b ^= m->mask;
				break;
			case FILE_OPADD:
				p->b += m->mask;
				break;
			case FILE_OPMINUS:
				p->b -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->b *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->b /= m->mask;
				break;
			case FILE_OPMODULO:
				p->b %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->b = ~p->b;
d279 1
a279 65
	case FILE_SHORT:
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->h &= m->mask;
				break;
			case FILE_OPOR:
				p->h |= m->mask;
				break;
			case FILE_OPXOR:
				p->h ^= m->mask;
				break;
			case FILE_OPADD:
				p->h += m->mask;
				break;
			case FILE_OPMINUS:
				p->h -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->h *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->h /= m->mask;
				break;
			case FILE_OPMODULO:
				p->h %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->h = ~p->h;
		return 1;
	case FILE_LONG:
	case FILE_DATE:
	case FILE_LDATE:
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->l &= m->mask;
				break;
			case FILE_OPOR:
				p->l |= m->mask;
				break;
			case FILE_OPXOR:
				p->l ^= m->mask;
				break;
			case FILE_OPADD:
				p->l += m->mask;
				break;
			case FILE_OPMINUS:
				p->l -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->l *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->l /= m->mask;
				break;
			case FILE_OPMODULO:
				p->l %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->l = ~p->l;
		return 1;
	case FILE_STRING:
d281 1
a281 1
			int n;
d283 1
a283 1
			/* Null terminate and eat *trailing* return */
d285 2
a286 3
			n = strlen(p->s) - 1;
			if (p->s[n] == '\n')
				p->s[n] = '\0';
d289 1
a289 15
	case FILE_PSTRING:
		{
			char *ptr1 = p->s, *ptr2 = ptr1 + 1;
			unsigned int n = *p->s;
			if (n >= sizeof(p->s))
				n = sizeof(p->s) - 1;
			while (n--)
				*ptr1++ = *ptr2++;
			*ptr1 = '\0';
			n = strlen(p->s) - 1;
			if (p->s[n] == '\n')
				p->s[n] = '\0';
			return 1;
		}
	case FILE_BESHORT:
a290 29
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->h &= m->mask;
				break;
			case FILE_OPOR:
				p->h |= m->mask;
				break;
			case FILE_OPXOR:
				p->h ^= m->mask;
				break;
			case FILE_OPADD:
				p->h += m->mask;
				break;
			case FILE_OPMINUS:
				p->h -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->h *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->h /= m->mask;
				break;
			case FILE_OPMODULO:
				p->h %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->h = ~p->h;
d292 2
a293 3
	case FILE_BELONG:
	case FILE_BEDATE:
	case FILE_BELDATE:
a295 29
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->l &= m->mask;
				break;
			case FILE_OPOR:
				p->l |= m->mask;
				break;
			case FILE_OPXOR:
				p->l ^= m->mask;
				break;
			case FILE_OPADD:
				p->l += m->mask;
				break;
			case FILE_OPMINUS:
				p->l -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->l *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->l /= m->mask;
				break;
			case FILE_OPMODULO:
				p->l %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->l = ~p->l;
d297 1
a297 1
	case FILE_LESHORT:
a298 29
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->h &= m->mask;
				break;
			case FILE_OPOR:
				p->h |= m->mask;
				break;
			case FILE_OPXOR:
				p->h ^= m->mask;
				break;
			case FILE_OPADD:
				p->h += m->mask;
				break;
			case FILE_OPMINUS:
				p->h -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->h *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->h /= m->mask;
				break;
			case FILE_OPMODULO:
				p->h %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->h = ~p->h;
d300 2
a301 3
	case FILE_LELONG:
	case FILE_LEDATE:
	case FILE_LELDATE:
a303 31
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->l &= m->mask;
				break;
			case FILE_OPOR:
				p->l |= m->mask;
				break;
			case FILE_OPXOR:
				p->l ^= m->mask;
				break;
			case FILE_OPADD:
				p->l += m->mask;
				break;
			case FILE_OPMINUS:
				p->l -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->l *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->l /= m->mask;
				break;
			case FILE_OPMODULO:
				p->l %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->l = ~p->l;
		return 1;
	case FILE_REGEX:
d306 1
a306 1
		file_error(ms, 0, "invalid type %d in mconvert()", m->type);
d312 5
a316 2
private void
mdebug(uint32_t offset, const char *str, size_t len)
d319 1
a319 1
	file_showstr(stderr, str, len);
d324 6
a329 3
private int
mget(struct magic_set *ms, union VALUETYPE *p, const unsigned char *s,
    struct magic *m, size_t nbytes)
d331 1
a331 1
	uint32_t offset = m->offset;
d333 1
a333 17
	if (m->type == FILE_REGEX) {
		/*
		 * offset is interpreted as last line to search,
		 * (starting at 1), not as bytes-from start-of-file
		 */
		unsigned char *b, *last = NULL;
		if ((p->buf = strdup((const char *)s)) == NULL) {
			file_oomem(ms);
			return -1;
		}
		for (b = (unsigned char *)p->buf; offset &&
		    (b = (unsigned char *)strchr((char *)b, '\n')) != NULL;
		    offset--, s++)
			last = b;
		if (last != NULL)
			*last = '\0';
	} else if (offset + sizeof(union VALUETYPE) <= nbytes)
d340 1
d342 2
a343 2
		if (offset < nbytes)
			memcpy(p, s + offset, nbytes - offset);
a345 6
	/* Verify we have enough data to match magic type */
	switch (m->type) {
		case FILE_BYTE:
			if (nbytes < (offset + 1)) /* should alway be true */
				return 0;
			break;
d347 3
a349 25
		case FILE_SHORT:
		case FILE_BESHORT:
		case FILE_LESHORT:
			if (nbytes < (offset + 2))
				return 0;
			break;

		case FILE_LONG:
		case FILE_BELONG:
		case FILE_LELONG:
		case FILE_DATE:
		case FILE_BEDATE:
		case FILE_LEDATE:
		case FILE_LDATE:
		case FILE_BELDATE:
		case FILE_LELDATE:
			if (nbytes < (offset + 4))
				return 0;
			break;

		case FILE_STRING:
		case FILE_PSTRING:
			if (nbytes < (offset + m->vallen))
				return 0;
			break;
d352 2
a353 4
	if ((ms->flags & MAGIC_DEBUG) != 0) {
		mdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));
		file_mdump(m);
	}
d356 4
a359 78
		switch (m->in_type) {
		case FILE_BYTE:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = p->b & m->in_offset;
					break;
				case FILE_OPOR:
					offset = p->b | m->in_offset;
					break;
				case FILE_OPXOR:
					offset = p->b ^ m->in_offset;
					break;
				case FILE_OPADD:
					offset = p->b + m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = p->b - m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = p->b * m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = p->b / m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = p->b % m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_BESHORT:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) &
						 m->in_offset;
					break;
				case FILE_OPOR:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) |
						 m->in_offset;
					break;
				case FILE_OPXOR:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) ^
						 m->in_offset;
					break;
				case FILE_OPADD:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) +
						 m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) -
						 m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) *
						 m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) /
						 m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) %
						 m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
d361 2
a362 46
		case FILE_LESHORT:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) &
						 m->in_offset;
					break;
				case FILE_OPOR:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) |
						 m->in_offset;
					break;
				case FILE_OPXOR:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) ^
						 m->in_offset;
					break;
				case FILE_OPADD:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) +
						 m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) -
						 m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) *
						 m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) /
						 m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) %
						 m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
d364 2
a365 194
		case FILE_SHORT:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = p->h & m->in_offset;
					break;
				case FILE_OPOR:
					offset = p->h | m->in_offset;
					break;
				case FILE_OPXOR:
					offset = p->h ^ m->in_offset;
					break;
				case FILE_OPADD:
					offset = p->h + m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = p->h - m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = p->h * m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = p->h / m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = p->h % m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_BELONG:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) &
						 m->in_offset;
					break;
				case FILE_OPOR:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) |
						 m->in_offset;
					break;
				case FILE_OPXOR:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) ^
						 m->in_offset;
					break;
				case FILE_OPADD:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) +
						 m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) -
						 m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) *
						 m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) /
						 m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) %
						 m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_LELONG:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) &
						 m->in_offset;
					break;
				case FILE_OPOR:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) |
						 m->in_offset;
					break;
				case FILE_OPXOR:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) ^
						 m->in_offset;
					break;
				case FILE_OPADD:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) +
						 m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) -
						 m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) *
						 m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) /
						 m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) %
						 m->in_offset;
					break;
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_LONG:
			if (m->in_offset)
				switch (m->in_op&0x7F) {
				case FILE_OPAND:
					offset = p->l & m->in_offset;
					break;
				case FILE_OPOR:
					offset = p->l | m->in_offset;
					break;
				case FILE_OPXOR:
					offset = p->l ^ m->in_offset;
					break;
				case FILE_OPADD:
					offset = p->l + m->in_offset;
					break;
				case FILE_OPMINUS:
					offset = p->l - m->in_offset;
					break;
				case FILE_OPMULTIPLY:
					offset = p->l * m->in_offset;
					break;
				case FILE_OPDIVIDE:
					offset = p->l / m->in_offset;
					break;
				case FILE_OPMODULO:
					offset = p->l % m->in_offset;
					break;
			/*	case TOOMANYSWITCHBLOCKS:
			 *		ugh = p->eye % m->strain;
			 *		rub;
			 *	case BEER:
			 *		off = p->tab & m->in_gest;
			 *		sleep;
			 */
				}
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
d369 1
a369 2
		if (nbytes < sizeof(union VALUETYPE) ||
		    nbytes - sizeof(union VALUETYPE) < offset)
d374 3
a376 4
		if ((ms->flags & MAGIC_DEBUG) != 0) {
			mdebug(offset, (char *)(void *)p,
			    sizeof(union VALUETYPE));
			file_mdump(m);
d378 3
a381 2
	if (!mconvert(ms, p, m))
	  return 0;
d385 4
a388 2
private int
mcheck(struct magic_set *ms, union VALUETYPE *p, struct magic *m)
d395 1
d401 1
a401 1
	case FILE_BYTE:
d405 3
a407 3
	case FILE_SHORT:
	case FILE_BESHORT:
	case FILE_LESHORT:
d411 6
a416 9
	case FILE_LONG:
	case FILE_BELONG:
	case FILE_LELONG:
	case FILE_DATE:
	case FILE_BEDATE:
	case FILE_LEDATE:
	case FILE_LDATE:
	case FILE_BELDATE:
	case FILE_LELDATE:
d420 3
a422 5
	case FILE_STRING:
	case FILE_PSTRING:
	{
		/*
		 * What we want here is:
a426 4
		unsigned char *a = (unsigned char*)m->value.s;
		unsigned char *b = (unsigned char*)p->s;
		int len = m->vallen;
		l = 0;
d428 5
a432 1
		if (0L == m->mask) { /* normal string: do it fast */
d435 1
a435 27
					break; 
		} else { /* combine the others */
			while (--len >= 0) {
				if ((m->mask & STRING_IGNORE_LOWERCASE) &&
				    islower(*a)) {
					if ((v = tolower(*b++) - *a++) != '\0')
						break;
				} else if ((m->mask & STRING_COMPACT_BLANK) && 
				    isspace(*a)) { 
					a++;
					if (isspace(*b++)) {
						while (isspace(*b))
							b++;
					} else {
						v = 1;
						break;
					}
				} else if (isspace(*a) &&
				    (m->mask & STRING_COMPACT_OPTIONAL_BLANK)) {
					a++;
					while (isspace(*b))
						b++;
				} else {
					if ((v = *b++ - *a++) != '\0')
						break;
				}
			}
a437 20
	}
	case FILE_REGEX:
	{
		int rc;
		regex_t rx;
		char errmsg[512];

		rc = regcomp(&rx, m->value.s, REG_EXTENDED|REG_NOSUB);
		if (rc) {
			free(p->buf);
			regerror(rc, &rx, errmsg, sizeof(errmsg));
			file_error(ms, 0, "regex error %d, (%s)", rc, errmsg);
			return -1;
		} else {
			rc = regexec(&rx, p->buf, 0, 0, 0);
			regfree(&rx);
			free(p->buf);
			return !rc;
		}
	}
d439 2
a440 2
		file_error(ms, 0, "invalid type %d in mcheck()", m->type);
		return -1;
d443 1
a443 2
	if (m->type != FILE_STRING && m->type != FILE_PSTRING)
		v = file_signextend(ms, m, v);
d447 1
a447 1
		if ((ms->flags & MAGIC_DEBUG) != 0)
d454 1
a454 1
		if ((ms->flags & MAGIC_DEBUG) != 0)
d461 1
a461 1
		if ((ms->flags & MAGIC_DEBUG) != 0)
d469 1
a469 1
			if ((ms->flags & MAGIC_DEBUG) != 0)
d475 1
a475 1
			if ((ms->flags & MAGIC_DEBUG) != 0)
d484 1
a484 1
			if ((ms->flags & MAGIC_DEBUG) != 0)
d490 1
a490 1
			if ((ms->flags & MAGIC_DEBUG) != 0)
d498 1
a498 1
		if ((ms->flags & MAGIC_DEBUG) != 0)
d505 1
a505 1
		if ((ms->flags & MAGIC_DEBUG) != 0)
d512 2
a513 3
		file_error(ms, 0, "cannot happen: invalid relation `%c'",
		    m->reln);
		return -1;
@


