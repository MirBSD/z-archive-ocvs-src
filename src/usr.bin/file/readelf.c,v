head	1.4;
access;
symbols
	tg-mergetmp-mirosx-1:1.4
	tg-mergefixes-1-branch:1.4.0.4
	tg-mergefixes-1-base:1.4
	MIROS_X:1.4.0.2
	MIROS_X_BASE:1.4
	tg-mergetmp-3:1.4
	MIRBSD_XP_MIRPPC:1.3.0.4
	cvs-200410222040:1.1.1.4
	tg-mergetmp-1:1.1.1.3
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	MIRBSD_7quater:1.1.1.2
	cvs-200405160640:1.1.1.3
	cvs-200401271800:1.1.1.3
	cvs-200401261630:1.1.1.3
	cvs-200401021645:1.1.1.3
	MIRBSD_7_ALPHA:1.1.1.2.0.6
	MIRBSD_7:1.1.1.2.0.4
	cvs-200312222040:1.1.1.3
	MIRBSD_7ter:1.1.1.2
	MIRBSD_7_DEV:1.1.1.2.0.2
	cvs-200310020700:1.1.1.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.10.22.21.53.45;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.28.15.22.21;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.05.23.18.46.15;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.52.40;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.52.40;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.06.19.12.52.24;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.22.21.12.56;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.10.22.20.49.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@merge; fix; whitespace; bump libc level
XXX untested
@
text
@/**	$MirBSD$ */
/*	$OpenBSD: readelf.c,v 1.8 2004/05/19 02:32:35 tedu Exp $ */
/*
 * Copyright (c) Christos Zoulas 2003.
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "file.h"

#ifdef BUILTIN_ELF
#include <sys/cdefs.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "readelf.h"

__RCSID("$MirBSD$");

#ifdef	ELFCORE
private int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t);
#endif
private int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t);
private int doshn(struct magic_set *, int, int, int, off_t, int, size_t);
private size_t donote(struct magic_set *, unsigned char *, size_t, size_t, int,
    int, size_t);

#define	ELF_ALIGN(a)	((((a) + align - 1) / align) * align)

private uint16_t getu16(int, uint16_t);
private uint32_t getu32(int, uint32_t);
private uint64_t getu64(int, uint64_t);

private uint16_t
getu16(int swap, uint16_t value)
{
	union {
		uint16_t ui;
		char c[2];
	} retval, tmpval;

	if (swap) {
		tmpval.ui = value;

		retval.c[0] = tmpval.c[1];
		retval.c[1] = tmpval.c[0];

		return retval.ui;
	} else
		return value;
}

private uint32_t
getu32(int swap, uint32_t value)
{
	union {
		uint32_t ui;
		char c[4];
	} retval, tmpval;

	if (swap) {
		tmpval.ui = value;

		retval.c[0] = tmpval.c[3];
		retval.c[1] = tmpval.c[2];
		retval.c[2] = tmpval.c[1];
		retval.c[3] = tmpval.c[0];

		return retval.ui;
	} else
		return value;
}

private uint64_t
getu64(int swap, uint64_t value)
{
	union {
		uint64_t ui;
		char c[8];
	} retval, tmpval;

	if (swap) {
		tmpval.ui = value;

		retval.c[0] = tmpval.c[7];
		retval.c[1] = tmpval.c[6];
		retval.c[2] = tmpval.c[5];
		retval.c[3] = tmpval.c[4];
		retval.c[4] = tmpval.c[3];
		retval.c[5] = tmpval.c[2];
		retval.c[6] = tmpval.c[1];
		retval.c[7] = tmpval.c[0];

		return retval.ui;
	} else
		return value;
}

#define sh_addr		(class == ELFCLASS32		\
			 ? (void *) &sh32		\
			 : (void *) &sh64)
#define sh_size		(class == ELFCLASS32		\
			 ? sizeof sh32			\
			 : sizeof sh64)
#define shs_type	(class == ELFCLASS32		\
			 ? getu32(swap, sh32.sh_type)	\
			 : getu32(swap, sh64.sh_type))
#define ph_addr		(class == ELFCLASS32		\
			 ? (void *) &ph32		\
			 : (void *) &ph64)
#define ph_size		(class == ELFCLASS32		\
			 ? sizeof ph32			\
			 : sizeof ph64)
#define ph_type		(class == ELFCLASS32		\
			 ? getu32(swap, ph32.p_type)	\
			 : getu32(swap, ph64.p_type))
#define ph_offset	(class == ELFCLASS32		\
			 ? getu32(swap, ph32.p_offset)	\
			 : getu64(swap, ph64.p_offset))
#define ph_align	(size_t)((class == ELFCLASS32	\
			 ? (off_t) (ph32.p_align ? 	\
			    getu32(swap, ph32.p_align) : 4) \
			 : (off_t) (ph64.p_align ?	\
			    getu64(swap, ph64.p_align) : 4)))
#define nh_size		(class == ELFCLASS32		\
			 ? sizeof nh32			\
			 : sizeof nh64)
#define nh_type		(class == ELFCLASS32		\
			 ? getu32(swap, nh32.n_type)	\
			 : getu32(swap, nh64.n_type))
#define nh_namesz	(class == ELFCLASS32		\
			 ? getu32(swap, nh32.n_namesz)	\
			 : getu32(swap, nh64.n_namesz))
#define nh_descsz	(class == ELFCLASS32		\
			 ? getu32(swap, nh32.n_descsz)	\
			 : getu32(swap, nh64.n_descsz))
#define prpsoffsets(i)	(class == ELFCLASS32		\
			 ? prpsoffsets32[i]		\
			 : prpsoffsets64[i])

#ifdef ELFCORE
size_t	prpsoffsets32[] = {
	8,		/* FreeBSD */
	28,		/* Linux 2.0.36 */
	32,		/* Linux (I forget which kernel version) */
	84,		/* SunOS 5.x */
};

size_t	prpsoffsets64[] = {
       120,		/* SunOS 5.x, 64-bit */
};

#define	NOFFSETS32	(sizeof prpsoffsets32 / sizeof prpsoffsets32[0])
#define NOFFSETS64	(sizeof prpsoffsets64 / sizeof prpsoffsets64[0])

#define NOFFSETS	(class == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)

/*
 * Look through the program headers of an executable image, searching
 * for a PT_NOTE section of type NT_PRPSINFO, with a name "CORE" or
 * "FreeBSD"; if one is found, try looking in various places in its
 * contents for a 16-character string containing only printable
 * characters - if found, that string should be the name of the program
 * that dropped core.  Note: right after that 16-character string is,
 * at least in SunOS 5.x (and possibly other SVR4-flavored systems) and
 * Linux, a longer string (80 characters, in 5.x, probably other
 * SVR4-flavored systems, and Linux) containing the start of the
 * command line for that program.
 *
 * The signal number probably appears in a section of type NT_PRSTATUS,
 * but that's also rather OS-dependent, in ways that are harder to
 * dissect with heuristics, so I'm not bothering with the signal number.
 * (I suppose the signal number could be of interest in situations where
 * you don't have the binary of the program that dropped core; if you
 * *do* have that binary, the debugger will probably tell you what
 * signal it was.)
 */

#define	OS_STYLE_SVR4		0
#define	OS_STYLE_FREEBSD	1
#define	OS_STYLE_NETBSD		2

private const char *os_style_names[] = {
	"SVR4",
	"FreeBSD",
	"NetBSD",
};

private int
dophn_core(struct magic_set *ms, int class, int swap, int fd, off_t off,
    int num, size_t size)
{
	Elf32_Phdr ph32;
	Elf64_Phdr ph64;
	size_t offset;
	unsigned char nbuf[BUFSIZ];
	ssize_t bufsize;

	if (size != ph_size) {
		if (file_printf(ms, ", corrupted program header size") == -1)
			return -1;
		return 0;
	}
	/*
	 * Loop through all the program headers.
	 */
	for ( ; num; num--) {
		if (lseek(fd, off, SEEK_SET) == (off_t)-1) {
			file_badseek(ms);
			return -1;
		}
		if (read(fd, ph_addr, ph_size) == -1) {
			file_badread(ms);
			return -1;
		}
		off += size;
		if (ph_type != PT_NOTE)
			continue;

		/*
		 * This is a PT_NOTE section; loop through all the notes
		 * in the section.
		 */
		if (lseek(fd, (off_t) ph_offset, SEEK_SET) == (off_t)-1) {
			file_badseek(ms);
			return -1;
		}
		bufsize = read(fd, nbuf, BUFSIZ);
		if (bufsize == -1) {
			file_badread(ms);
			return -1;
		}
		offset = 0;
		for (;;) {
			if (offset >= (size_t)bufsize)
				break;
			offset = donote(ms, nbuf, offset, (size_t)bufsize,
			    class, swap, 4);
			if (offset == 0)
				break;

		}
	}
	return 0;
}
#endif

private size_t
donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,
    int class, int swap, size_t align)
{
	Elf32_Nhdr nh32;
	Elf64_Nhdr nh64;
	size_t noff, doff;
#ifdef ELFCORE
	int os_style = -1;
#endif
	uint32_t namesz, descsz;

	if (class == ELFCLASS32)
		memcpy(&nh32, &nbuf[offset], sizeof(nh32));
	else
		memcpy(&nh64, &nbuf[offset], sizeof(nh64));
	offset += nh_size;

	namesz = nh_namesz;
	descsz = nh_descsz;
	if ((namesz == 0) && (descsz == 0)) {
		/*
		 * We're out of note headers.
		 */
		return offset;
	}

	if (namesz & 0x80000000) {
	    (void)file_printf(ms, ", bad note name size 0x%lx",
		(unsigned long)namesz);
	    return offset;
	}

	if (descsz & 0x80000000) {
	    (void)file_printf(ms, ", bad note description size 0x%lx",
		(unsigned long)descsz);
	    return offset;
	}


	noff = offset;
	doff = ELF_ALIGN(offset + namesz);

	if (offset + namesz >= size) {
		/*
		 * We're past the end of the buffer.
		 */
		return doff;
	}

	offset = ELF_ALIGN(doff + descsz);
	if (offset + descsz >= size) {
		return offset;
	}

	if (namesz == 4 && strcmp((char *)&nbuf[noff], "GNU") == 0 &&
	    nh_type == NT_GNU_VERSION && descsz == 16) {
		uint32_t desc[4];
		(void)memcpy(desc, &nbuf[doff], sizeof(desc));

		if (file_printf(ms, ", for GNU/") == -1)
			return size;
		switch (getu32(swap, desc[0])) {
		case GNU_OS_LINUX:
			if (file_printf(ms, "Linux") == -1)
				return size;
			break;
		case GNU_OS_HURD:
			if (file_printf(ms, "Hurd") == -1)
				return size;
			break;
		case GNU_OS_SOLARIS:
			if (file_printf(ms, "Solaris") == -1)
				return size;
			break;
		default:
			if (file_printf(ms, "<unknown>") == -1)
				return size;
		}
		if (file_printf(ms, " %d.%d.%d", getu32(swap, desc[1]),
		    getu32(swap, desc[2]), getu32(swap, desc[3])) == -1)
			return size;
		return size;
	}

	if (nh_type == NT_MIRBSD_VERSION &&
	    ((namesz == 7 && strcmp((char *)&nbuf[noff], "MirBSD") == 0) ||
	    (namesz > NT_MIROS_STRTLEN && strncmp((char *)&nbuf[noff],
	    NT_MIROS_STRTEST, NT_MIROS_STRTLEN) == 0))) {
		char *tmp = (char *)&nbuf[noff];
		uint32_t desc;

		if (strcmp((char *)&nbuf[noff], "MirBSD") == 0)
			tmp = "MirOS BSD";
		if (file_printf(ms, ", for %s", tmp) == -1)
			return size;

		/* look for version of note */
		(void)memcpy(&desc, &nbuf[doff], sizeof(desc));
		desc = getu32(swap, desc);
		if (!desc)
			return size;	/* first version */

		/* any newer version */
		if ((desc & 0xFF) == 0xFF) {
			if (file_printf(ms, ", wrong endianness") == -1)
				return size;
			desc = getu32(1, desc);
		}
		if (file_printf(ms, ", crti version %02X", desc & 0xFF) == -1)
			return size;	/* newer version */

		/* can't parse that yet, because it's unspecified */
		return size;
	}

	if (namesz == 7 && strcmp((char *)&nbuf[noff], "NetBSD") == 0 &&
	    nh_type == NT_NETBSD_VERSION && descsz == 4) {
		uint32_t desc;
		(void)memcpy(&desc, &nbuf[doff], sizeof(desc));
		desc = getu32(swap, desc);

		if (file_printf(ms, ", for NetBSD") == -1)
			return size;
		/*
		 * The version number used to be stuck as 199905, and was thus
		 * basically content-free.  Newer versions of NetBSD have fixed
		 * this and now use the encoding of __NetBSD_Version__:
		 *
		 *	MMmmrrpp00
		 *
		 * M = major version
		 * m = minor version
		 * r = release ["",A-Z,Z[A-Z] but numeric]
		 * p = patchlevel
		 */
		if (desc > 100000000U) {
			u_int ver_patch = (desc / 100) % 100;
			u_int ver_rel = (desc / 10000) % 100;
			u_int ver_min = (desc / 1000000) % 100;
			u_int ver_maj = desc / 100000000;

			if (file_printf(ms, " %u.%u", ver_maj, ver_min) == -1)
				return size;
			if (ver_rel == 0 && ver_patch != 0) {
				if (file_printf(ms, ".%u", ver_patch) == -1)
					return size;
			} else if (ver_rel != 0) {
				while (ver_rel > 26) {
					file_printf(ms, "Z");
					ver_rel -= 26;
				}
				file_printf(ms, "%c", 'A' + ver_rel - 1);
			}
		}
		return size;
	}

	if (namesz == 8 && strcmp((char *)&nbuf[noff], "FreeBSD") == 0 &&
	    nh_type == NT_FREEBSD_VERSION && descsz == 4) {
		uint32_t desc;
		(void)memcpy(&desc, &nbuf[doff], sizeof(desc));
		desc = getu32(swap, desc);
		if (file_printf(ms, ", for FreeBSD") == -1)
			return size;

		/*
		 * Contents is __FreeBSD_version, whose relation to OS
		 * versions is defined by a huge table in the Porters'
		 * Handbook. For up to 5.x, the first three digits are
		 * the version number.  For 5.x and higher, the scheme
		 * is: <major><two digit minor> <0 if release branch,
		 * otherwise 1>xx
		 */
		if (desc / 100000 < 5) {
			if (file_printf(ms, " %d.%d", desc / 100000,
			    desc / 10000 % 10) == -1)
				return size;
			if (desc / 1000 % 10 > 0)
				if (file_printf(ms, ".%d", desc / 1000 % 10)
				    == -1)
					return size;
		} else {
			if (file_printf(ms, " %d.%d", desc / 100000,
			    desc / 1000 % 100) == -1)
				return size;
			desc %= 1000;
			if (desc > 100) {
				if (file_printf(ms, "-CURRENT (rev %d)",
				    desc % 100) == -1)
					return size;
			} else if (desc != 0) {
				if (file_printf(ms, ".%d", desc / 10) == -1)
					return size;
			}
		}
		return size;
	}

	if (namesz == 8 && strcmp((char *)&nbuf[noff], "OpenBSD") == 0 &&
	    nh_type == NT_OPENBSD_VERSION && descsz == 4) {
		if (file_printf(ms, ", for OpenBSD") == -1)
			return size;
		/* Content of note is always 0 */
		return size;
	}

	/*
	 * Sigh.  The 2.0.36 kernel in Debian 2.1, at
	 * least, doesn't correctly implement name
	 * sections, in core dumps, as specified by
	 * the "Program Linking" section of "UNIX(R) System
	 * V Release 4 Programmer's Guide: ANSI C and
	 * Programming Support Tools", because my copy
	 * clearly says "The first 'namesz' bytes in 'name'
	 * contain a *null-terminated* [emphasis mine]
	 * character representation of the entry's owner
	 * or originator", but the 2.0.36 kernel code
	 * doesn't include the terminating null in the
	 * name....
	 */
	if ((namesz == 4 && strncmp((char *)&nbuf[noff], "CORE", 4) == 0) ||
	    (namesz == 5 && strcmp((char *)&nbuf[noff], "CORE") == 0)) {
		os_style = OS_STYLE_SVR4;
	}

	if ((namesz == 8 && strcmp((char *)&nbuf[noff], "FreeBSD") == 0)) {
		os_style = OS_STYLE_FREEBSD;
	}

	if ((namesz >= 11 && strncmp((char *)&nbuf[noff], "NetBSD-CORE", 11)
	    == 0)) {
		os_style = OS_STYLE_NETBSD;
	}

#ifdef ELFCORE
	if (os_style != -1)
		if (file_printf(ms, ", %s-style", os_style_names[os_style]) == -1)
			return size;

	if (os_style == OS_STYLE_NETBSD && nh_type == NT_NETBSD_CORE_PROCINFO) {
		uint32_t signo;
		/*
		 * Extract the program name.  It is at
		 * offset 0x7c, and is up to 32-bytes,
		 * including the terminating NUL.
		 */
		if (file_printf(ms, ", from '%.31s'", &nbuf[doff + 0x7c]) == -1)
			return size;

		/*
		 * Extract the signal number.  It is at
		 * offset 0x08.
		 */
		memcpy(&signo, &nbuf[doff + 0x08],
		    sizeof(signo));
		if (file_printf(ms, " (signal %u)", getu32(swap, signo)) == -1)
			return size;
		return size;
	} else if (os_style != OS_STYLE_NETBSD && nh_type == NT_PRPSINFO) {
		size_t i, j;
		unsigned char c;
		/*
		 * Extract the program name.  We assume
		 * it to be 16 characters (that's what it
		 * is in SunOS 5.x and Linux).
		 *
		 * Unfortunately, it's at a different offset
		 * in varous OSes, so try multiple offsets.
		 * If the characters aren't all printable,
		 * reject it.
		 */
		for (i = 0; i < NOFFSETS; i++) {
			size_t reloffset = prpsoffsets(i);
			size_t noffset = doff + reloffset;
			for (j = 0; j < 16; j++, noffset++, reloffset++) {
				/*
				 * Make sure we're not past
				 * the end of the buffer; if
				 * we are, just give up.
				 */
				if (noffset >= size)
					goto tryanother;

				/*
				 * Make sure we're not past
				 * the end of the contents;
				 * if we are, this obviously
				 * isn't the right offset.
				 */
				if (reloffset >= descsz)
					goto tryanother;

				c = nbuf[noffset];
				if (c == '\0') {
					/*
					 * A '\0' at the
					 * beginning is
					 * obviously wrong.
					 * Any other '\0'
					 * means we're done.
					 */
					if (j == 0)
						goto tryanother;
					else
						break;
				} else {
					/*
					 * A nonprintable
					 * character is also
					 * wrong.
					 */
#define isquote(c) (strchr("'\"`", (c)) != NULL)
					if (!isprint(c) || isquote(c))
						goto tryanother;
				}
			}

			/*
			 * Well, that worked.
			 */
			if (file_printf(ms, ", from '%.16s'",
			    &nbuf[doff + prpsoffsets(i)]) == -1)
				return size;
			return size;

		tryanother:
			;
		}
		return offset;
	}
#endif
	return offset;
}

private int
doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,
    size_t size)
{
	Elf32_Shdr sh32;
	Elf64_Shdr sh64;

	if (size != sh_size) {
		if (file_printf(ms, ", corrupted section header size") == -1)
			return -1;
		return 0;
	}

	if (lseek(fd, off, SEEK_SET) == (off_t)-1) {
		file_badseek(ms);
		return -1;
	}

	for ( ; num; num--) {
		if (read(fd, sh_addr, sh_size) == -1) {
			file_badread(ms);
			return -1;
		}
		if (shs_type == SHT_SYMTAB /* || shs_type == SHT_DYNSYM */) {
			if (file_printf(ms, ", not stripped") == -1)
				return -1;
			return 0;
		}
	}
	if (file_printf(ms, ", stripped") == -1)
		return -1;
	return 0;
}

/*
 * Look through the program headers of an executable image, searching
 * for a PT_INTERP section; if one is found, it's dynamically linked,
 * otherwise it's statically linked.
 */
private int
dophn_exec(struct magic_set *ms, int class, int swap, int fd, off_t off,
    int num, size_t size)
{
	Elf32_Phdr ph32;
	Elf64_Phdr ph64;
	const char *linking_style = "statically";
	const char *shared_libraries = "";
	unsigned char nbuf[BUFSIZ];
	int bufsize;
	size_t offset, align;
	off_t savedoffset;

	if (size != ph_size) {
		if (file_printf(ms, ", corrupted program header size") == -1)
		    return -1;
		return 0;
	}
	if (lseek(fd, off, SEEK_SET) == (off_t)-1) {
		file_badseek(ms);
		return -1;
	}

  	for ( ; num; num--) {
  		if (read(fd, ph_addr, ph_size) == -1) {
  			file_badread(ms);
			return -1;
		}
		if ((savedoffset = lseek(fd, (off_t)0, SEEK_CUR)) == (off_t)-1) {
  			file_badseek(ms);
			return -1;
		}

		switch (ph_type) {
		case PT_DYNAMIC:
			linking_style = "dynamically";
			break;
		case PT_INTERP:
			shared_libraries = " (uses shared libs)";
			break;
		case PT_NOTE:
			if ((align = ph_align) & 0x80000000) {
				if (file_printf(ms,
				    ", invalid note alignment 0x%lx",
				    (unsigned long)align) == -1)
					return -1;
				align = 4;
			}
			/*
			 * This is a PT_NOTE section; loop through all the notes
			 * in the section.
			 */
			if (lseek(fd, (off_t) ph_offset, SEEK_SET)
			    == (off_t)-1) {
				file_badseek(ms);
				return -1;
			}
			bufsize = read(fd, nbuf, sizeof(nbuf));
			if (bufsize == -1) {
				file_badread(ms);
				return -1;
			}
			offset = 0;
			for (;;) {
				if (offset >= (size_t)bufsize)
					break;
				offset = donote(ms, nbuf, offset,
				    (size_t)bufsize, class, swap, align);
				if (offset == 0)
					break;
			}
			if (lseek(fd, savedoffset + offset, SEEK_SET)
			    == (off_t)-1) {
				file_badseek(ms);
				return -1;
			}
			break;
		}
	}
	if (file_printf(ms, ", %s linked%s", linking_style, shared_libraries)
	    == -1)
	    return -1;
	return 0;
}


protected int
file_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,
    size_t nbytes)
{
	union {
		int32_t l;
		char c[sizeof (int32_t)];
	} u;
	int class;
	int swap;

	/*
	 * If we cannot seek, it must be a pipe, socket or fifo.
	 */
	if((lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) && (errno == ESPIPE))
		fd = file_pipe2file(ms, fd, buf, nbytes);

	/*
	 * ELF executables have multiple section headers in arbitrary
	 * file locations and thus file(1) cannot determine it from easily.
	 * Instead we traverse thru all section headers until a symbol table
	 * one is found or else the binary is stripped.
	 */
	if (buf[EI_MAG0] != ELFMAG0
	    || (buf[EI_MAG1] != ELFMAG1 && buf[EI_MAG1] != OLFMAG1)
	    || buf[EI_MAG2] != ELFMAG2 || buf[EI_MAG3] != ELFMAG3)
	    return 0;


	class = buf[4];

	if (class == ELFCLASS32) {
		Elf32_Ehdr elfhdr;
		if (nbytes <= sizeof (Elf32_Ehdr))
			return 0;


		u.l = 1;
		(void) memcpy(&elfhdr, buf, sizeof elfhdr);
		swap = (u.c[sizeof(int32_t) - 1] + 1) != elfhdr.e_ident[5];

		if (getu16(swap, elfhdr.e_type) == ET_CORE) {
#ifdef ELFCORE
			if (dophn_core(ms, class, swap, fd,
			    (off_t)getu32(swap, elfhdr.e_phoff),
			    getu16(swap, elfhdr.e_phnum),
			    (size_t)getu16(swap, elfhdr.e_phentsize)) == -1)
				return -1;
#else
			;
#endif
		} else {
			if (getu16(swap, elfhdr.e_type) == ET_EXEC) {
				if (dophn_exec(ms, class, swap,
				    fd, (off_t)getu32(swap, elfhdr.e_phoff),
				    getu16(swap, elfhdr.e_phnum),
				    (size_t)getu16(swap, elfhdr.e_phentsize))
				    == -1)
					return -1;
			}
			if (doshn(ms, class, swap, fd,
			    (off_t)getu32(swap, elfhdr.e_shoff),
			    getu16(swap, elfhdr.e_shnum),
			    (size_t)getu16(swap, elfhdr.e_shentsize)) == -1)
				return -1;
		}
		return 1;
	}

        if (class == ELFCLASS64) {
		Elf64_Ehdr elfhdr;
		if (nbytes <= sizeof (Elf64_Ehdr))
			return 0;


		u.l = 1;
		(void) memcpy(&elfhdr, buf, sizeof elfhdr);
		swap = (u.c[sizeof(int32_t) - 1] + 1) != elfhdr.e_ident[5];

		if (getu16(swap, elfhdr.e_type) == ET_CORE) {
#ifdef ELFCORE
			if (dophn_core(ms, class, swap, fd,
#ifdef USE_ARRAY_FOR_64BIT_TYPES
			    (off_t)getu32(swap, elfhdr.e_phoff[1]),
#else
			    (off_t)getu64(swap, elfhdr.e_phoff),
#endif
			    getu16(swap, elfhdr.e_phnum),
			    (size_t)getu16(swap, elfhdr.e_phentsize)) == -1)
				return -1;
#else
			;
#endif
		} else {
			if (getu16(swap, elfhdr.e_type) == ET_EXEC) {
				if (dophn_exec(ms, class, swap, fd,
#ifdef USE_ARRAY_FOR_64BIT_TYPES
				    (off_t)getu32(swap, elfhdr.e_phoff[1]),
#else
				    (off_t)getu64(swap, elfhdr.e_phoff),
#endif
				    getu16(swap, elfhdr.e_phnum),
				    (size_t)getu16(swap, elfhdr.e_phentsize))
				    == -1)
					return -1;
			}
			if (doshn(ms, class, swap, fd,
#ifdef USE_ARRAY_FOR_64BIT_TYPES
			    (off_t)getu32(swap, elfhdr.e_shoff[1]),
#else
			    (off_t)getu64(swap, elfhdr.e_shoff),
#endif
			    getu16(swap, elfhdr.e_shnum),
			    (size_t)getu16(swap, elfhdr.e_shentsize)) == -1)
				return -1;
		}
		return 1;
	}
	return 0;
}
#endif
@


1.3
log
@recognise MirOS BSD/Linux PT_NOTE sections
@
text
@d1 2
a2 1
/* $MirBSD: src/usr.bin/file/readelf.c,v 1.2 2004/05/23 18:46:15 tg Exp $ */
d4 2
a5 5
 * ELF routines for the file command.
 *
 * Copyright (c) Ian F. Darwin 1986-1995.
 * Software written by Ian F. Darwin and others;
 * maintained 1995-present by Christos Zoulas and others.
d16 2
a30 1

d34 1
d44 1
a44 3
#ifndef lint
static char *RCSID = "@@(#)$Id: readelf.c,v 1.2 2004/05/23 18:46:15 tg Exp $";
#endif
d47 1
a47 1
static void dophn_core(int, int, int, off_t, int, size_t);
d49 10
a58 6
static void dophn_exec(int, int, int, off_t, int, size_t);
static void doshn(int, int, int, off_t, int, size_t);

static uint16_t getu16(int, uint16_t);
static uint32_t getu32(int, uint32_t);
static uint64_t getu64(int, uint64_t);
d60 1
a60 1
static uint16_t
d79 1
a79 1
static uint32_t
d100 1
a100 1
static uint64_t
d146 5
a150 3
#define ph_align	(class == ELFCLASS32		\
			 ? (ph32.p_align ? getu32(swap, ph32.p_align) : 4) \
			 : (ph64.p_align ? getu64(swap, ph64.p_align) : 4))
d152 2
a153 2
			 ? sizeof *nh32			\
			 : sizeof *nh64)
d155 2
a156 2
			 ? getu32(swap, nh32->n_type)	\
			 : getu32(swap, nh64->n_type))
d158 2
a159 2
			 ? getu32(swap, nh32->n_namesz)	\
			 : getu32(swap, nh64->n_namesz))
d161 2
a162 2
			 ? getu32(swap, nh32->n_descsz)	\
			 : getu32(swap, nh64->n_descsz))
a166 193
static void
doshn(int class, int swap, int fd, off_t off, int num, size_t size)
{
	Elf32_Shdr sh32;
	Elf64_Shdr sh64;

	if (size != sh_size)
		error("corrupted section header size.\n");

	if (lseek(fd, off, SEEK_SET) == -1)
		error("lseek failed (%s).\n", strerror(errno));

	for ( ; num; num--) {
		if (read(fd, sh_addr, sh_size) == -1)
			error("read failed (%s).\n", strerror(errno));
		if (shs_type == SHT_SYMTAB /* || shs_type == SHT_DYNSYM */) {
			(void) printf (", not stripped");
			return;
		}
	}
	(void) printf (", stripped");
}

/*
 * Look through the program headers of an executable image, searching
 * for a PT_INTERP section; if one is found, it's dynamically linked,
 * otherwise it's statically linked.
 */
static void
dophn_exec(int class, int swap, int fd, off_t off, int num, size_t size)
{
	Elf32_Phdr ph32;
	Elf32_Nhdr *nh32 = NULL;
	Elf64_Phdr ph64;
	Elf64_Nhdr *nh64 = NULL;
	char *linking_style = "statically";
	char *shared_libraries = "";
	char nbuf[BUFSIZ];
	int bufsize;
	size_t offset, nameoffset;
	off_t savedoffset;

	if (size != ph_size)
		error("corrupted program header size.\n");
	if (lseek(fd, off, SEEK_SET) == -1)
		error("lseek failed (%s).\n", strerror(errno));

  	for ( ; num; num--) {
  		if (read(fd, ph_addr, ph_size) == -1)
  			error("read failed (%s).\n", strerror(errno));
		if ((savedoffset = lseek(fd, 0, SEEK_CUR)) == -1)
  			error("lseek failed (%s).\n", strerror(errno));

		switch (ph_type) {
		case PT_DYNAMIC:
			linking_style = "dynamically";
			break;
		case PT_INTERP:
			shared_libraries = " (uses shared libs)";
			break;
		case PT_NOTE:
			/*
			 * This is a PT_NOTE section; loop through all the notes
			 * in the section.
			 */
			if (lseek(fd, (off_t) ph_offset, SEEK_SET) == -1)
				error("lseek failed (%s).\n", strerror(errno));
			bufsize = read(fd, nbuf, sizeof(nbuf));
			if (bufsize == -1)
				error(": " "read failed (%s).\n",
				    strerror(errno));
			offset = 0;
			for (;;) {
				if (offset >= bufsize)
					break;
				if (class == ELFCLASS32)
					nh32 = (Elf32_Nhdr *)&nbuf[offset];
				else
					nh64 = (Elf64_Nhdr *)&nbuf[offset];
				offset += nh_size;

				if (offset + nh_namesz >= bufsize) {
					/*
					 * We're past the end of the buffer.
					 */
					break;
				}

				nameoffset = offset;
				offset += nh_namesz;
				offset = ((offset+ph_align-1)/ph_align)*ph_align;

				if ((nh_namesz == 0) && (nh_descsz == 0)) {
					/*
					 * We're out of note headers.
					 */
					break;
				}

				if (offset + nh_descsz >= bufsize)
					break;

				if (nh_namesz == 4 &&
				    strcmp(&nbuf[nameoffset], "GNU") == 0 &&
				    nh_type == NT_GNU_VERSION &&
				    nh_descsz == 16) {
					uint32_t *desc =
					    (uint32_t *)&nbuf[offset];

					printf(", for GNU/");
					switch (getu32(swap, desc[0])) {
					case GNU_OS_LINUX:
						printf("Linux");
						break;
					case GNU_OS_HURD:
						printf("Hurd");
						break;
					case GNU_OS_SOLARIS:
						printf("Solaris");
						break;
					default:
						printf("<unknown>");
					}
					printf(" %d.%d.%d",
					    getu32(swap, desc[1]),
					    getu32(swap, desc[2]),
					    getu32(swap, desc[3]));
				}

				if (nh_namesz == 7 &&
				    strcmp(&nbuf[nameoffset], "NetBSD") == 0 &&
				    nh_type == NT_NETBSD_VERSION &&
				    nh_descsz == 4) {
					printf(", for NetBSD");
					/*
					 * Version number is stuck at 199905,
					 * and hence is basically content-free.
					 */
				}

				if (nh_namesz == 7 &&
				    strcmp(&nbuf[nameoffset], "MirBSD") == 0 &&
				    nh_type == NT_MIRBSD_VERSION) {
					printf(", for MirOS BSD");
				}

				if (nh_namesz > NT_MIROS_STRTLEN &&
				    strncmp(&nbuf[nameoffset],
				    NT_MIROS_STRTEST, NT_MIROS_STRTLEN) == 0 &&
				    nh_type == NT_MIROS_VERSION) {
					printf(", for %s", &nbuf[nameoffset]);
				}

				if (nh_namesz == 8 &&
				    strcmp(&nbuf[nameoffset], "FreeBSD") == 0 &&
				    nh_type == NT_FREEBSD_VERSION &&
				    nh_descsz == 4) {
					uint32_t desc = getu32(swap,
					    *(uint32_t *)&nbuf[offset]);
					printf(", for FreeBSD");
					/*
					 * Contents is __FreeBSD_version,
					 * whose relation to OS versions is
					 * defined by a huge table in the
					 * Porters' Handbook.  Happily, the
					 * first three digits are the version
					 * number, at least in versions of
					 * FreeBSD that use this note.
					 */

					printf(" %d.%d", desc / 100000,
					    desc / 10000 % 10);
					if (desc / 1000 % 10 > 0)
						printf(".%d",
						    desc / 1000 % 10);
				}

				if (nh_namesz == 8 &&
				    strcmp(&nbuf[nameoffset], "OpenBSD") == 0 &&
				    nh_type == NT_OPENBSD_VERSION &&
				    nh_descsz == 4) {
					printf(", for OpenBSD");
					/* Content of note is always 0 */
				}
			}
			if ((lseek(fd, savedoffset + offset, SEEK_SET)) == -1)
				error("lseek failed (%s).\n", strerror(errno));
			break;
		}
	}
	printf(", %s linked%s", linking_style, shared_libraries);
}

d209 1
a209 1
static const char *os_style_names[] = {
d215 3
a217 2
static void
dophn_core(int class, int swap, int fd, off_t off, int num, size_t size)
a219 1
	Elf32_Nhdr *nh32 = NULL;
d221 9
a229 10
	Elf64_Nhdr *nh64 = NULL;
	size_t offset, nameoffset, noffset, reloffset;
	unsigned char c;
	int i, j;
	char nbuf[BUFSIZ];
	int bufsize;
	int os_style = -1;

	if (size != ph_size)
		error("corrupted program header size.\n");
d234 8
a241 4
		if (lseek(fd, off, SEEK_SET) == -1)
			error("lseek failed (%s).\n", strerror(errno));
		if (read(fd, ph_addr, ph_size) == -1)
			error("read failed (%s).\n", strerror(errno));
d250 4
a253 2
		if (lseek(fd, (off_t) ph_offset, SEEK_SET) == -1)
			error("lseek failed (%s).\n", strerror(errno));
d255 4
a258 2
		if (bufsize == -1)
			error(": " "read failed (%s).\n", strerror(errno));
d261 5
a265 1
			if (offset >= bufsize)
a266 5
			if (class == ELFCLASS32)
				nh32 = (Elf32_Nhdr *)&nbuf[offset];
			else
				nh64 = (Elf64_Nhdr *)&nbuf[offset];
			offset += nh_size;
d268 159
a426 9
			/*
			 * Check whether this note has the name "CORE" or
			 * "FreeBSD", or "NetBSD-CORE".
			 */
			if (offset + nh_namesz >= bufsize) {
				/*
				 * We're past the end of the buffer.
				 */
				break;
d428 3
d432 7
a438 3
			nameoffset = offset;
			offset += nh_namesz;
			offset = ((offset + 3)/4)*4;
d440 28
a467 35
			/*
			 * Sigh.  The 2.0.36 kernel in Debian 2.1, at
			 * least, doesn't correctly implement name
			 * sections, in core dumps, as specified by
			 * the "Program Linking" section of "UNIX(R) System
			 * V Release 4 Programmer's Guide: ANSI C and
			 * Programming Support Tools", because my copy
			 * clearly says "The first 'namesz' bytes in 'name'
			 * contain a *null-terminated* [emphasis mine]
			 * character representation of the entry's owner
			 * or originator", but the 2.0.36 kernel code
			 * doesn't include the terminating null in the
			 * name....
			 */
			if (os_style == -1) {
				if ((nh_namesz == 4 &&
				     strncmp(&nbuf[nameoffset],
					    "CORE", 4) == 0) ||
				    (nh_namesz == 5 &&
				     strcmp(&nbuf[nameoffset],
				     	    "CORE") == 0)) {
					os_style = OS_STYLE_SVR4;
				} else
				if ((nh_namesz == 8 &&
				     strcmp(&nbuf[nameoffset],
				     	    "FreeBSD") == 0)) {
					os_style = OS_STYLE_FREEBSD;
				} else
				if ((nh_namesz >= 11 &&
				     strncmp(&nbuf[nameoffset],
				     	     "NetBSD-CORE", 11) == 0)) {
					os_style = OS_STYLE_NETBSD;
				} else
					continue;
				printf(", %s-style", os_style_names[os_style]);
d469 3
d473 7
a479 3
			if (os_style == OS_STYLE_NETBSD &&
			    nh_type == NT_NETBSD_CORE_PROCINFO) {
				uint32_t signo;
d481 69
d551 3
a553 3
				 * Extract the program name.  It is at
				 * offset 0x7c, and is up to 32-bytes,
				 * including the terminating NUL.
d555 2
a556 1
				printf(", from '%.31s'", &nbuf[offset + 0x7c]);
d559 4
a562 2
				 * Extract the signal number.  It is at
				 * offset 0x08.
d564 2
a565 63
				memcpy(&signo, &nbuf[offset + 0x08],
				    sizeof(signo));
				printf(" (signal %u)", getu32(swap, signo));
			} else
			if (os_style != OS_STYLE_NETBSD &&
			    nh_type == NT_PRPSINFO) {
				/*
				 * Extract the program name.  We assume
				 * it to be 16 characters (that's what it
				 * is in SunOS 5.x and Linux).
				 *
				 * Unfortunately, it's at a different offset
				 * in various OSes, so try multiple offsets.
				 * If the characters aren't all printable,
				 * reject it.
				 */
				for (i = 0; i < NOFFSETS; i++) {
					reloffset = prpsoffsets(i);
					noffset = offset + reloffset;
					for (j = 0; j < 16;
					    j++, noffset++, reloffset++) {
						/*
						 * Make sure we're not past
						 * the end of the buffer; if
						 * we are, just give up.
						 */
						if (noffset >= bufsize)
							goto tryanother;

						/*
						 * Make sure we're not past
						 * the end of the contents;
						 * if we are, this obviously
						 * isn't the right offset.
						 */
						if (reloffset >= nh_descsz)
							goto tryanother;

						c = nbuf[noffset];
						if (c == '\0') {
							/*
							 * A '\0' at the
							 * beginning is
							 * obviously wrong.
							 * Any other '\0'
							 * means we're done.
							 */
							if (j == 0)
								goto tryanother;
							else
								break;
						} else {
							/*
							 * A nonprintable
							 * character is also
							 * wrong.
							 */
#define isquote(c) (strchr("'\"`", (c)) != NULL)
							if (!isprint(c) ||
							     isquote(c))
								goto tryanother;
						}
					}
d567 2
d570 5
a574 1
					 * Well, that worked.
d576 141
a716 2
					printf(", from '%.16s'",
					    &nbuf[offset + prpsoffsets(i)]);
a717 5

				tryanother:
					;
				}
				break;
d719 6
a724 2
			offset += nh_descsz;
			offset = ((offset + 3)/4)*4;
d727 4
a731 1
#endif
d733 4
a736 2
void
tryelf(int fd, unsigned char *buf, int nbytes)
d746 1
a746 1
	 * If we can't seek, it must be a pipe, socket or fifo.
d749 1
a749 1
		fd = pipe2file(fd, buf, nbytes);
d760 1
a760 1
	    return;
d768 1
a768 1
			return;
d775 1
a775 1
		if (getu16(swap, elfhdr.e_type) == ET_CORE)
d777 5
a781 5
			dophn_core(class, swap,
				   fd,
				   getu32(swap, elfhdr.e_phoff),
				   getu16(swap, elfhdr.e_phnum),
				   getu16(swap, elfhdr.e_phentsize));
d785 1
a785 1
		else {
d787 6
a792 5
				dophn_exec(class, swap,
					   fd,
					   getu32(swap, elfhdr.e_phoff),
					   getu16(swap, elfhdr.e_phnum),
					   getu16(swap, elfhdr.e_phentsize));
d794 5
a798 5
			doshn(class, swap,
			      fd,
			      getu32(swap, elfhdr.e_shoff),
			      getu16(swap, elfhdr.e_shnum),
			      getu16(swap, elfhdr.e_shentsize));
d800 1
a800 1
		return;
d806 1
a806 1
			return;
d813 1
a813 1
		if (getu16(swap, elfhdr.e_type) == ET_CORE)
d815 1
a815 2
			dophn_core(class, swap,
				   fd,
d817 1
a817 1
				   getu32(swap, elfhdr.e_phoff[1]),
d819 1
a819 1
				   getu64(swap, elfhdr.e_phoff),
d821 3
a823 2
				   getu16(swap, elfhdr.e_phnum),
				   getu16(swap, elfhdr.e_phentsize));
d827 1
a827 2
		else
		{
d829 1
a829 2
				dophn_exec(class, swap,
					   fd,
d831 1
a831 1
					   getu32(swap, elfhdr.e_phoff[1]),
d833 1
a833 1
					   getu64(swap, elfhdr.e_phoff),
d835 4
a838 2
					   getu16(swap, elfhdr.e_phnum),
					   getu16(swap, elfhdr.e_phentsize));
d840 1
a840 2
			doshn(class, swap,
			      fd,
d842 1
a842 1
			      getu32(swap, elfhdr.e_shoff[1]),
d844 1
a844 1
			      getu64(swap, elfhdr.e_shoff),
d846 3
a848 2
			      getu16(swap, elfhdr.e_shnum),
			      getu16(swap, elfhdr.e_shentsize));
d850 1
a850 1
		return;
d852 1
@


1.2
log
@* big OpenBSD 3.5-current merge
* adaption of share/doc Makefiles
* revival of the ancient "learn" utility
  XXX possible flaws!
* whitespace, config and comment cleanup in ssh
* add soelim, which was previously missing, and crunch
* add MirOS ELF note support to file
@
text
@d1 1
a1 1
/* $MirBSD$ */
d45 1
a45 1
static char *RCSID = "@@(#)$Id: readelf.c,v 1.1.1.3 2003/12/22 21:12:56 tg Exp $";
d305 1
a305 2
				    nh_type == NT_MIRBSD_VERSION &&
				    nh_descsz == 4) {
d307 7
@


1.1
log
@Initial revision
@
text
@d1 1
d8 1
a8 1
 * 
d18 1
a18 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Ian F. Darwin and others.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *  
d45 1
a45 1
static char *RCSID = "@@(#)$Id: readelf.c,v 1.5 2003/03/11 21:26:26 ian Exp $";
d71 1
a71 1
		
d92 1
a92 1
		
d117 1
a117 1
		
d243 1
a243 1
	
d303 7
d507 1
a507 1
				
d524 1
a524 1
				 * in varous OSes, so try multiple offsets.
d635 1
a635 1
		if (getu16(swap, elfhdr.e_type) == ET_CORE) 
d640 1
a640 1
				   getu16(swap, elfhdr.e_phnum), 
d650 1
a650 1
					   getu16(swap, elfhdr.e_phnum), 
d672 1
a672 1
		if (getu16(swap, elfhdr.e_type) == ET_CORE) 
d681 1
a681 1
				   getu16(swap, elfhdr.e_phnum), 
d696 1
a696 1
					   getu16(swap, elfhdr.e_phnum), 
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d17 5
d49 1
a49 1
static char *RCSID = "@@(#)$Id: readelf.c,v 1.6 2003/06/13 18:31:14 deraadt Exp $";
@


1.1.1.3
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d44 1
a44 1
static char *RCSID = "@@(#)$Id: readelf.c,v 1.7 2003/11/09 20:13:57 otto Exp $";
d516 1
a516 1
				 * in various OSes, so try multiple offsets.
@


1.1.1.4
log
@import some updates/fixes from openbsd
@
text
@a0 1
/*	$OpenBSD: readelf.c,v 1.8 2004/05/19 02:32:35 tedu Exp $ */
d2 5
a6 2
 * Copyright (c) Christos Zoulas 2003.
 * All Rights Reserved.
a16 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 1
d44 1
a44 1
FILE_RCSID("@@(#)$Id: readelf.c,v 1.8 2004/05/19 02:32:35 tedu Exp $")
d48 1
a48 1
private int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t);
d50 2
a51 10
private int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t);
private int doshn(struct magic_set *, int, int, int, off_t, int, size_t);
private size_t donote(struct magic_set *, unsigned char *, size_t, size_t, int,
    int, size_t);

#define	ELF_ALIGN(a)	((((a) + align - 1) / align) * align)

private uint16_t getu16(int, uint16_t);
private uint32_t getu32(int, uint32_t);
private uint64_t getu64(int, uint64_t);
d53 5
a57 1
private uint16_t
d76 1
a76 1
private uint32_t
d97 1
a97 1
private uint64_t
d143 3
a145 5
#define ph_align	(size_t)((class == ELFCLASS32	\
			 ? (off_t) (ph32.p_align ? 	\
			    getu32(swap, ph32.p_align) : 4) \
			 : (off_t) (ph64.p_align ?	\
			    getu64(swap, ph64.p_align) : 4)))
d147 2
a148 2
			 ? sizeof nh32			\
			 : sizeof nh64)
d150 2
a151 2
			 ? getu32(swap, nh32.n_type)	\
			 : getu32(swap, nh64.n_type))
d153 2
a154 2
			 ? getu32(swap, nh32.n_namesz)	\
			 : getu32(swap, nh64.n_namesz))
d156 2
a157 2
			 ? getu32(swap, nh32.n_descsz)	\
			 : getu32(swap, nh64.n_descsz))
d162 180
d384 1
a384 1
private const char *os_style_names[] = {
d390 2
a391 3
private int
dophn_core(struct magic_set *ms, int class, int swap, int fd, off_t off,
    int num, size_t size)
d394 1
d396 10
a405 9
	size_t offset;
	unsigned char nbuf[BUFSIZ];
	ssize_t bufsize;

	if (size != ph_size) {
		if (file_printf(ms, ", corrupted program header size") == -1)
			return -1;
		return 0;
	}
d410 4
a413 8
		if (lseek(fd, off, SEEK_SET) == (off_t)-1) {
			file_badseek(ms);
			return -1;
		}
		if (read(fd, ph_addr, ph_size) == -1) {
			file_badread(ms);
			return -1;
		}
d422 2
a423 4
		if (lseek(fd, (off_t) ph_offset, SEEK_SET) == (off_t)-1) {
			file_badseek(ms);
			return -1;
		}
d425 2
a426 4
		if (bufsize == -1) {
			file_badread(ms);
			return -1;
		}
d429 1
a429 1
			if (offset >= (size_t)bufsize)
d431 14
a444 3
			offset = donote(ms, nbuf, offset, (size_t)bufsize,
			    class, swap, 4);
			if (offset == 0)
a445 129

		}
	}
	return 0;
}
#endif

private size_t
donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,
    int class, int swap, size_t align)
{
	Elf32_Nhdr nh32;
	Elf64_Nhdr nh64;
	size_t noff, doff;
#ifdef ELFCORE
	int os_style = -1;
#endif
	uint32_t namesz, descsz;

	if (class == ELFCLASS32)
		memcpy(&nh32, &nbuf[offset], sizeof(nh32));
	else
		memcpy(&nh64, &nbuf[offset], sizeof(nh64));
	offset += nh_size;

	namesz = nh_namesz;
	descsz = nh_descsz;
	if ((namesz == 0) && (descsz == 0)) {
		/*
		 * We're out of note headers.
		 */
		return offset;
	}

	if (namesz & 0x80000000) {
	    (void)file_printf(ms, ", bad note name size 0x%lx",
		(unsigned long)namesz);
	    return offset;
	}

	if (descsz & 0x80000000) {
	    (void)file_printf(ms, ", bad note description size 0x%lx",
		(unsigned long)descsz);
	    return offset;
	}


	noff = offset;
	doff = ELF_ALIGN(offset + namesz);

	if (offset + namesz >= size) {
		/*
		 * We're past the end of the buffer.
		 */
		return doff;
	}

	offset = ELF_ALIGN(doff + descsz);
	if (offset + descsz >= size) {
		return offset;
	}

	if (namesz == 4 && strcmp((char *)&nbuf[noff], "GNU") == 0 &&
	    nh_type == NT_GNU_VERSION && descsz == 16) {
		uint32_t desc[4];
		(void)memcpy(desc, &nbuf[doff], sizeof(desc));

		if (file_printf(ms, ", for GNU/") == -1)
			return size;
		switch (getu32(swap, desc[0])) {
		case GNU_OS_LINUX:
			if (file_printf(ms, "Linux") == -1)
				return size;
			break;
		case GNU_OS_HURD:
			if (file_printf(ms, "Hurd") == -1)
				return size;
			break;
		case GNU_OS_SOLARIS:
			if (file_printf(ms, "Solaris") == -1)
				return size;
			break;
		default:
			if (file_printf(ms, "<unknown>") == -1)
				return size; 
		}
		if (file_printf(ms, " %d.%d.%d", getu32(swap, desc[1]),
		    getu32(swap, desc[2]), getu32(swap, desc[3])) == -1)
			return size;
		return size;
	}

	if (namesz == 7 && strcmp((char *)&nbuf[noff], "NetBSD") == 0 &&
	    nh_type == NT_NETBSD_VERSION && descsz == 4) {
		uint32_t desc;
		(void)memcpy(&desc, &nbuf[doff], sizeof(desc));
		desc = getu32(swap, desc);

		if (file_printf(ms, ", for NetBSD") == -1)
			return size;
		/*
		 * The version number used to be stuck as 199905, and was thus
		 * basically content-free.  Newer versions of NetBSD have fixed
		 * this and now use the encoding of __NetBSD_Version__:
		 *
		 *	MMmmrrpp00
		 *
		 * M = major version
		 * m = minor version
		 * r = release ["",A-Z,Z[A-Z] but numeric]
		 * p = patchlevel
		 */
		if (desc > 100000000U) {
			u_int ver_patch = (desc / 100) % 100;
			u_int ver_rel = (desc / 10000) % 100;
			u_int ver_min = (desc / 1000000) % 100;
			u_int ver_maj = desc / 100000000;

			if (file_printf(ms, " %u.%u", ver_maj, ver_min) == -1)
				return size;
			if (ver_rel == 0 && ver_patch != 0) {
				if (file_printf(ms, ".%u", ver_patch) == -1)
					return size;
			} else if (ver_rel != 0) {
				while (ver_rel > 26) {
					file_printf(ms, "Z");
					ver_rel -= 26;
				}
				file_printf(ms, "%c", 'A' + ver_rel - 1);
a446 3
		}
		return size;
	}
d448 3
a450 7
	if (namesz == 8 && strcmp((char *)&nbuf[noff], "FreeBSD") == 0 &&
	    nh_type == NT_FREEBSD_VERSION && descsz == 4) {
		uint32_t desc;
		(void)memcpy(&desc, &nbuf[doff], sizeof(desc));
		desc = getu32(swap, desc);
		if (file_printf(ms, ", for FreeBSD") == -1)
			return size;
d452 35
a486 28
		/*
		 * Contents is __FreeBSD_version, whose relation to OS
		 * versions is defined by a huge table in the Porters'
		 * Handbook. For up to 5.x, the first three digits are
		 * the version number.  For 5.x and higher, the scheme
		 * is: <major><two digit minor> <0 if release branch,
		 * otherwise 1>xx
		 */
		if (desc / 100000 < 5) {
			if (file_printf(ms, " %d.%d", desc / 100000,
			    desc / 10000 % 10) == -1)
				return size;
			if (desc / 1000 % 10 > 0)
				if (file_printf(ms, ".%d", desc / 1000 % 10)
				    == -1)
					return size;
		} else {
			if (file_printf(ms, " %d.%d", desc / 100000,
			    desc / 1000 % 100) == -1)
				return size;
			desc %= 1000;
			if (desc > 100) {
				if (file_printf(ms, "-CURRENT (rev %d)",
				    desc % 100) == -1)
					return size;
			} else if (desc != 0) {
				if (file_printf(ms, ".%d", desc / 10) == -1)
					return size;
a487 3
		}
		return size;
	}
d489 3
a491 7
	if (namesz == 8 && strcmp((char *)&nbuf[noff], "OpenBSD") == 0 &&
	    nh_type == NT_OPENBSD_VERSION && descsz == 4) {
		if (file_printf(ms, ", for OpenBSD") == -1)
			return size;
		/* Content of note is always 0 */
		return size;
	}
a492 69
	/*
	 * Sigh.  The 2.0.36 kernel in Debian 2.1, at
	 * least, doesn't correctly implement name
	 * sections, in core dumps, as specified by
	 * the "Program Linking" section of "UNIX(R) System
	 * V Release 4 Programmer's Guide: ANSI C and
	 * Programming Support Tools", because my copy
	 * clearly says "The first 'namesz' bytes in 'name'
	 * contain a *null-terminated* [emphasis mine]
	 * character representation of the entry's owner
	 * or originator", but the 2.0.36 kernel code
	 * doesn't include the terminating null in the
	 * name....
	 */
	if ((namesz == 4 && strncmp((char *)&nbuf[noff], "CORE", 4) == 0) ||
	    (namesz == 5 && strcmp((char *)&nbuf[noff], "CORE") == 0)) {
		os_style = OS_STYLE_SVR4;
	} 

	if ((namesz == 8 && strcmp((char *)&nbuf[noff], "FreeBSD") == 0)) {
		os_style = OS_STYLE_FREEBSD;
	}

	if ((namesz >= 11 && strncmp((char *)&nbuf[noff], "NetBSD-CORE", 11)
	    == 0)) {
		os_style = OS_STYLE_NETBSD;
	}

#ifdef ELFCORE
	if (os_style != -1)
		if (file_printf(ms, ", %s-style", os_style_names[os_style]) == -1)
			return size;

	if (os_style == OS_STYLE_NETBSD && nh_type == NT_NETBSD_CORE_PROCINFO) {
		uint32_t signo;
		/*
		 * Extract the program name.  It is at
		 * offset 0x7c, and is up to 32-bytes,
		 * including the terminating NUL.
		 */
		if (file_printf(ms, ", from '%.31s'", &nbuf[doff + 0x7c]) == -1)
			return size;
		
		/*
		 * Extract the signal number.  It is at
		 * offset 0x08.
		 */
		memcpy(&signo, &nbuf[doff + 0x08],
		    sizeof(signo));
		if (file_printf(ms, " (signal %u)", getu32(swap, signo)) == -1)
			return size;
		return size;
	} else if (os_style != OS_STYLE_NETBSD && nh_type == NT_PRPSINFO) {
		size_t i, j;
		unsigned char c;
		/*
		 * Extract the program name.  We assume
		 * it to be 16 characters (that's what it
		 * is in SunOS 5.x and Linux).
		 *
		 * Unfortunately, it's at a different offset
		 * in varous OSes, so try multiple offsets.
		 * If the characters aren't all printable,
		 * reject it.
		 */
		for (i = 0; i < NOFFSETS; i++) {
			size_t reloffset = prpsoffsets(i);
			size_t noffset = doff + reloffset;
			for (j = 0; j < 16; j++, noffset++, reloffset++) {
d494 9
a502 3
				 * Make sure we're not past
				 * the end of the buffer; if
				 * we are, just give up.
d504 6
a509 3
				if (noffset >= size)
					goto tryanother;

d511 8
a518 4
				 * Make sure we're not past
				 * the end of the contents;
				 * if we are, this obviously
				 * isn't the right offset.
d520 47
a566 2
				if (reloffset >= descsz)
					goto tryanother;
a567 2
				c = nbuf[noffset];
				if (c == '\0') {
d569 1
a569 5
					 * A '\0' at the
					 * beginning is
					 * obviously wrong.
					 * Any other '\0'
					 * means we're done.
d571 6
a576 13
					if (j == 0)
						goto tryanother;
					else
						break;
				} else {
					/*
					 * A nonprintable
					 * character is also
					 * wrong.
					 */
#define isquote(c) (strchr("'\"`", (c)) != NULL)
					if (!isprint(c) || isquote(c))
						goto tryanother;
d578 1
d580 2
a581 11

			/*
			 * Well, that worked.
			 */
			if (file_printf(ms, ", from '%.16s'",
			    &nbuf[doff + prpsoffsets(i)]) == -1)
				return size;
			return size;

		tryanother:
			;
a582 1
		return offset;
d584 1
a585 127
	return offset;
}

private int
doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,
    size_t size)
{
	Elf32_Shdr sh32;
	Elf64_Shdr sh64;

	if (size != sh_size) {
		if (file_printf(ms, ", corrupted section header size") == -1)
			return -1;
		return 0;
	}

	if (lseek(fd, off, SEEK_SET) == (off_t)-1) {
		file_badseek(ms);
		return -1;
	}

	for ( ; num; num--) {
		if (read(fd, sh_addr, sh_size) == -1) {
			file_badread(ms);
			return -1;
		}
		if (shs_type == SHT_SYMTAB /* || shs_type == SHT_DYNSYM */) {
			if (file_printf(ms, ", not stripped") == -1)
				return -1;
			return 0;
		}
	}
	if (file_printf(ms, ", stripped") == -1)
		return -1;
	return 0;
}

/*
 * Look through the program headers of an executable image, searching
 * for a PT_INTERP section; if one is found, it's dynamically linked,
 * otherwise it's statically linked.
 */
private int
dophn_exec(struct magic_set *ms, int class, int swap, int fd, off_t off,
    int num, size_t size)
{
	Elf32_Phdr ph32;
	Elf64_Phdr ph64;
	const char *linking_style = "statically";
	const char *shared_libraries = "";
	unsigned char nbuf[BUFSIZ];
	int bufsize;
	size_t offset, align;
	off_t savedoffset;

	if (size != ph_size) {
		if (file_printf(ms, ", corrupted program header size") == -1)
		    return -1;
		return 0;
	}
	if (lseek(fd, off, SEEK_SET) == (off_t)-1) {
		file_badseek(ms);
		return -1;
	}

  	for ( ; num; num--) {
  		if (read(fd, ph_addr, ph_size) == -1) {
  			file_badread(ms);
			return -1;
		}
		if ((savedoffset = lseek(fd, (off_t)0, SEEK_CUR)) == (off_t)-1) {
  			file_badseek(ms);
			return -1;
		}

		switch (ph_type) {
		case PT_DYNAMIC:
			linking_style = "dynamically";
			break;
		case PT_INTERP:
			shared_libraries = " (uses shared libs)";
			break;
		case PT_NOTE:
			if ((align = ph_align) & 0x80000000) {
				if (file_printf(ms, 
				    ", invalid note alignment 0x%lx",
				    (unsigned long)align) == -1)
					return -1;
				align = 4;
			}
			/*
			 * This is a PT_NOTE section; loop through all the notes
			 * in the section.
			 */
			if (lseek(fd, (off_t) ph_offset, SEEK_SET)
			    == (off_t)-1) {
				file_badseek(ms);
				return -1;
			}
			bufsize = read(fd, nbuf, sizeof(nbuf));
			if (bufsize == -1) {
				file_badread(ms);
				return -1;
			}
			offset = 0;
			for (;;) {
				if (offset >= (size_t)bufsize)
					break;
				offset = donote(ms, nbuf, offset,
				    (size_t)bufsize, class, swap, align);
				if (offset == 0)
					break;
			}
			if (lseek(fd, savedoffset + offset, SEEK_SET)
			    == (off_t)-1) {
				file_badseek(ms);
				return -1;
			}
			break;
		}
	}
	if (file_printf(ms, ", %s linked%s", linking_style, shared_libraries)
	    == -1)
	    return -1;
	return 0;
}

d587 2
a588 3
protected int
file_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,
    size_t nbytes)
d598 1
a598 1
	 * If we cannot seek, it must be a pipe, socket or fifo.
d601 1
a601 1
		fd = file_pipe2file(ms, fd, buf, nbytes);
d612 1
a612 1
	    return 0;
d620 1
a620 1
			return 0;
d627 1
a627 1
		if (getu16(swap, elfhdr.e_type) == ET_CORE) {
d629 5
a633 5
			if (dophn_core(ms, class, swap, fd,
			    (off_t)getu32(swap, elfhdr.e_phoff),
			    getu16(swap, elfhdr.e_phnum), 
			    (size_t)getu16(swap, elfhdr.e_phentsize)) == -1)
				return -1;
d637 1
a637 1
		} else {
d639 5
a643 6
				if (dophn_exec(ms, class, swap,
				    fd, (off_t)getu32(swap, elfhdr.e_phoff),
				    getu16(swap, elfhdr.e_phnum), 
				    (size_t)getu16(swap, elfhdr.e_phentsize))
				    == -1)
					return -1;
d645 5
a649 5
			if (doshn(ms, class, swap, fd,
			    (off_t)getu32(swap, elfhdr.e_shoff),
			    getu16(swap, elfhdr.e_shnum),
			    (size_t)getu16(swap, elfhdr.e_shentsize)) == -1)
				return -1;
d651 1
a651 1
		return 1;
d657 1
a657 1
			return 0;
d664 1
a664 1
		if (getu16(swap, elfhdr.e_type) == ET_CORE) {
d666 2
a667 1
			if (dophn_core(ms, class, swap, fd,
d669 1
a669 1
			    (off_t)getu32(swap, elfhdr.e_phoff[1]),
d671 1
a671 1
			    (off_t)getu64(swap, elfhdr.e_phoff),
d673 2
a674 3
			    getu16(swap, elfhdr.e_phnum), 
			    (size_t)getu16(swap, elfhdr.e_phentsize)) == -1)
				return -1;
d678 2
a679 1
		} else {
d681 2
a682 1
				if (dophn_exec(ms, class, swap, fd,
d684 1
a684 1
				    (off_t)getu32(swap, elfhdr.e_phoff[1]),
d686 1
a686 1
				    (off_t)getu64(swap, elfhdr.e_phoff),
d688 2
a689 4
				    getu16(swap, elfhdr.e_phnum), 
				    (size_t)getu16(swap, elfhdr.e_phentsize))
				    == -1)
					return -1;
d691 2
a692 1
			if (doshn(ms, class, swap, fd,
d694 1
a694 1
			    (off_t)getu32(swap, elfhdr.e_shoff[1]),
d696 1
a696 1
			    (off_t)getu64(swap, elfhdr.e_shoff),
d698 2
a699 3
			    getu16(swap, elfhdr.e_shnum),
			    (size_t)getu16(swap, elfhdr.e_shentsize)) == -1)
				return -1;
d701 1
a701 1
		return 1;
a702 1
	return 0;
@


