head	1.3;
access;
symbols
	MIRBSD_XP_MIRPPC:1.2.0.4
	MIRBSD_XP_SPARC_BASE:1.2
	MIRBSD_XP_SPARC:1.2.0.2
	MIRBSD_7quater:1.1.1.7
	cvs-200405160640:1.1.1.7
	cvs-200401271800:1.1.1.7
	cvs-200401261630:1.1.1.7
	cvs-200401021645:1.1.1.7
	MIRBSD_7_ALPHA:1.1.1.7.0.6
	MIRBSD_7:1.1.1.7.0.4
	cvs-200312222040:1.1.1.7
	MIRBSD_7ter:1.1.1.7
	MIRBSD_7_DEV:1.1.1.7.0.2
	cvs-200310020700:1.1.1.7
	cvs-200309271030:1.1.1.7
	cvs-200309251530:1.1.1.7
	cvs-200308302005:1.1.1.7
	cvs-200308171200:1.1.1.7
	ctm-3496:1.1.1.7
	ctm-3449:1.1.1.7
	ctm-3437:1.1.1.7
	cvs-200307191805:1.1.1.7
	ctm-3425:1.1.1.7
	cvs-200307091500:1.1.1.7
	ctm-3389:1.1.1.6
	cvs-200306291430:1.1.1.6
	ctm-3341:1.1.1.6
	MIRBSD_5:1.1.1.6
	cvs-200306082100:1.1.1.6
	ctm-3316:1.1.1.6
	ctm-3272:1.1.1.5
	ctm-3264:1.1.1.4
	cvs-200305071630:1.1.1.4
	MIRBSD_4:1.1.1.3
	ctm-3203:1.1.1.3
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.11.13.18.34.46;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2004.01.21.22.01.44;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.17.53.15;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.53.15;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.55.23;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.04.15.17.47.42;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.07.17.53.51;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.21.19.16.20;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.06.05.17.44.06;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.07.09.16.49.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@* gprof: I don't know; I think gprof is pointless (since I don't write
  hooks for profiling libraries into gcc3, nor do we build these since
  years), but let's keep it here - the BSD version, not the GNU versi-
  on, and with unused arches deleted
* oldrdist: u-uh, deserves to die
* rdist, rdistd, sup: I don't think anybody would use them willingly;
  if so, please tell me (and I hope you've got a very good reason to
  do so ;-)
* learn: it was nice as a document of UNIX(R) history, but I'm cleaning
  up base right now, so...
@
text
@/*	$MirBSD: src/usr.bin/rdistd/server.c,v 1.2 2004/01/21 22:01:44 tg Stab $	*/
/*	$OpenBSD: server.c,v 1.16 2003/07/07 14:39:26 mpech Exp $	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "defs.h"

#ifndef lint
#if 0
static char RCSid[] __attribute__((__unused__)) =
"$From: server.c,v 1.10 1999/08/04 15:57:33 christos Exp $";
#else
static char RCSid[] __attribute__((__unused__)) =
"$OpenBSD: server.c,v 1.16 2003/07/07 14:39:26 mpech Exp $";
#endif

static char sccsid[] __attribute__((__unused__)) =
"@@(#)server.c	5.3 (Berkeley) 6/7/86";

static char copyright[] __attribute__((__unused__)) =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

/*
 * Server routines
 */

char	tempname[sizeof _RDIST_TMP + 1]; /* Tmp file name */
int	tempfd;			/* Tmp file fd */
char	buf[BUFSIZ];		/* general purpose buffer */
char	target[MAXPATHLEN];	/* target/source directory name */
char	*ptarget;		/* pointer to end of target name */
int	catname = 0;		/* cat name to target name */
char	*sptarget[32];		/* stack of saved ptarget's for directories */
char   *fromhost = NULL;	/* Client hostname */
static long min_freespace = 0;	/* Minimium free space on a filesystem */
static long min_freefiles = 0;	/* Minimium free # files on a filesystem */
int	oumask;			/* Old umask */

static int cattarget(char *);
static int setownership(char *, int, UID_T, GID_T, int);
static int setfilemode(char *, int, int, int);
static int fchog(int, char *, char *, char *, int);
static int removefile(struct stat *, int);
static void doclean(char *);
static void clean(char *);
static void dospecial(char *);
static void docmdspecial(void);
static void query(char *);
static int chkparent(char *, opt_t);
static char *savetarget(char *, opt_t);
static void recvfile(char *, opt_t, int, char *, char *, time_t, time_t, off_t);
static void recvdir(opt_t, int, char *, char *);
static void recvlink(char *, opt_t, int, off_t);
static void hardlink(char *);
static void setconfig(char *);
static void recvit(char *, int);
static void dochmog(char *);
static void settarget(char *, int);

/*
 * Cat "string" onto the target buffer with error checking.
 */
static int
cattarget(char *string)
{
	if (strlen(string) + strlen(target) + 2 > sizeof(target)) {
		message(MT_INFO, "target buffer is not large enough.");
		return(-1);
	}
	if (!ptarget) {
		message(MT_INFO, "NULL target pointer set.");
		return(-10);
	}

	(void) snprintf(ptarget, sizeof(target) - (ptarget - target),
			"/%s", string);

	return(0);
}

/*
 * Set uid and gid ownership of a file.
 */
static int
setownership(char *file, int fd, UID_T uid, GID_T gid, int link)
{
	int status = -1;

	/*
	 * We assume only the Superuser can change uid ownership.
	 */
	if (getuid() != 0)
		uid = -1;

	/*
	 * If we are dealing with a symlink, only try to change it if
	 * we have lchown, if we don't leave it alone.
	 */
#if	defined(HAVE_LCHOWN)
	if (link)
		status = lchown(file, (CHOWN_UID_T) uid,
				(CHOWN_GID_T) gid);
#else
	if (link)
		return 0;
#endif

#if	defined(HAVE_FCHOWN)
	if (fd != -1 && !link)
		status = fchown(fd, (CHOWN_UID_T) uid,
				(CHOWN_GID_T) gid);
#endif
	if (status < 0 && !link)
		status = chown(file, (CHOWN_UID_T) uid,
			       (CHOWN_GID_T) gid);

	if (status < 0) {
		if (uid == (UID_T) -1)
			message(MT_NOTICE, "%s: chgrp %d failed: %s",
				target, gid, SYSERR);
		else
			message(MT_NOTICE, "%s: chown %d.%d failed: %s",
				target, uid, gid, SYSERR);
		return(-1);
	}

	return(0);
}

/*
 * Set mode of a file
 */
static int
setfilemode(char *file, int fd, int mode, int link)
{
	int status = -1;

	if (mode == -1)
		return(0);

	/*
	 * If we are dealing with a symlink, only try to change it if
	 * we have lchown, if we don't leave it alone.
	 */
#if	defined(HAVE_LCHMOD)
	if (link)
		status = lchmod(file, mode);
#else
	if (link)
		return 0;
#endif

#if	defined(HAVE_FCHMOD)
	if (fd != -1 && !link)
		status = fchmod(fd, mode);
#endif

	if (status < 0 && !link)
		status = chmod(file, mode);

	if (status < 0) {
		message(MT_NOTICE, "%s: chmod failed: %s", target, SYSERR);
		return(-1);
	}

	return(0);
}
/*
 * Change owner, group and mode of file.
 */
static int
fchog(int fd, char *file, char *owner, char *group, int mode)
{
	static struct group *gr = NULL;
	extern char *locuser;
	int i;
	struct stat st;
	UID_T uid;
	GID_T gid;
	GID_T primegid = (GID_T)-2;

	uid = userid;
	if (userid == 0) {	/* running as root; take anything */
		if (*owner == ':') {
			uid = (UID_T) atoi(owner + 1);
		} else if (pw == NULL || strcmp(owner, pw->pw_name) != 0) {
			if ((pw = getpwnam(owner)) == NULL) {
				if (mode != -1 && IS_ON(mode, S_ISUID)) {
					message(MT_NOTICE,
			      "%s: unknown login name \"%s\", clearing setuid",
						target, owner);
					mode &= ~S_ISUID;
					uid = 0;
				} else
					message(MT_NOTICE,
					"%s: unknown login name \"%s\"",
						target, owner);
			} else
				uid = pw->pw_uid;
		} else {
			uid = pw->pw_uid;
			primegid = pw->pw_gid;
		}
		if (*group == ':') {
			gid = (GID_T) atoi(group + 1);
			goto ok;
		}
	} else {	/* not root, setuid only if user==owner */
		struct passwd *lupw;

		if (mode != -1) {
			if (IS_ON(mode, S_ISUID) &&
			    strcmp(locuser, owner) != 0)
				mode &= ~S_ISUID;
			if (mode)
				mode &= ~S_ISVTX; /* and strip sticky too */
		}

		if ((lupw = getpwnam(locuser)) != NULL)
			primegid = lupw->pw_gid;
	}

	gid = (GID_T) -1;
	if (gr == NULL || strcmp(group, gr->gr_name) != 0) {
		if ((*group == ':' &&
		     (getgrgid(gid = atoi(group + 1)) == NULL))
		    || ((gr = (struct group *)getgrnam(group)) == NULL)) {
			if (mode != -1 && IS_ON(mode, S_ISGID)) {
				message(MT_NOTICE,
				"%s: unknown group \"%s\", clearing setgid",
					target, group);
				mode &= ~S_ISGID;
			} else
				message(MT_NOTICE,
					"%s: unknown group \"%s\"",
					target, group);
		} else
			gid = gr->gr_gid;
	} else
		gid = gr->gr_gid;

	if (userid && gid >= 0 && gid != primegid) {
		if (gr)
			for (i = 0; gr->gr_mem[i] != NULL; i++)
				if (strcmp(locuser, gr->gr_mem[i]) == 0)
					goto ok;
		if (mode != -1 && IS_ON(mode, S_ISGID)) {
			message(MT_NOTICE,
				"%s: user %s not in group %s, clearing setgid",
				target, locuser, group);
			mode &= ~S_ISGID;
		}
		gid = (GID_T) -1;
	}
ok:
	if (stat(file, &st) == -1) {
		error("%s: Stat failed %s", file, SYSERR);
		return -1;
	}
	/*
	 * Set uid and gid ownership.  If that fails, strip setuid and
	 * setgid bits from mode.  Once ownership is set, successful
	 * or otherwise, set the new file mode.
	 */
	if (setownership(file, fd, uid, gid, S_ISLNK(st.st_mode)) < 0) {
		if (mode != -1 && IS_ON(mode, S_ISUID)) {
			message(MT_NOTICE,
				"%s: chown failed, clearing setuid", target);
			mode &= ~S_ISUID;
		}
		if (mode != -1 && IS_ON(mode, S_ISGID)) {
			message(MT_NOTICE,
				"%s: chown failed, clearing setgid", target);
			mode &= ~S_ISGID;
		}
	}
	(void) setfilemode(file, fd, mode, S_ISLNK(st.st_mode));


	return(0);
}

/*
 * Remove a file or directory (recursively) and send back an acknowledge
 * or an error message.
 */
static int
removefile(struct stat *statb, int silent)
{
	DIR *d;
	static DIRENTRY *dp;
	char *cp;
	struct stat stb;
	char *optarget;
	int len, failures = 0;

	switch (statb->st_mode & S_IFMT) {
	case S_IFREG:
	case S_IFLNK:
	case S_IFCHR:
	case S_IFBLK:
#ifdef S_IFSOCK
	case S_IFSOCK:
#endif
#ifdef S_IFIFO
	case S_IFIFO:
#endif
		if (unlink(target) < 0) {
			if (errno == ETXTBSY) {
				if (!silent)
					message(MT_REMOTE|MT_NOTICE,
						"%s: unlink failed: %s",
						target, SYSERR);
				return(0);
			} else {
				error("%s: unlink failed: %s", target, SYSERR);
				return(-1);
			}
		}
		goto removed;

	case S_IFDIR:
		break;

	default:
		error("%s: not a plain file", target);
		return(-1);
	}

	errno = 0;
	if ((d = opendir(target)) == NULL) {
		error("%s: opendir failed: %s", target, SYSERR);
		return(-1);
	}

	optarget = ptarget;
	len = ptarget - target;
	while ((dp = readdir(d)) != NULL) {
		if ((D_NAMLEN(dp) == 1 && dp->d_name[0] == '.') ||
		    (D_NAMLEN(dp) == 2 && dp->d_name[0] == '.' &&
		     dp->d_name[1] == '.'))
			continue;

		if (len + 1 + (int)strlen(dp->d_name) >= MAXPATHLEN - 1) {
			if (!silent)
				message(MT_REMOTE|MT_WARNING,
					"%s/%s: Name too long",
					target, dp->d_name);
			continue;
		}
		ptarget = optarget;
		*ptarget++ = '/';
		cp = dp->d_name;;
		while ((*ptarget++ = *cp++) != '\0')
			continue;
		ptarget--;
		if (lstat(target, &stb) < 0) {
			if (!silent)
				message(MT_REMOTE|MT_WARNING,
					"%s: lstat failed: %s",
					target, SYSERR);
			continue;
		}
		if (removefile(&stb, 0) < 0)
			++failures;
	}
	(void) closedir(d);
	ptarget = optarget;
	*ptarget = CNULL;

	if (failures)
		return(-1);

	if (rmdir(target) < 0) {
		error("%s: rmdir failed: %s", target, SYSERR);
		return(-1);
	}
removed:
#if NEWWAY
	if (!silent)
		message(MT_CHANGE|MT_REMOTE, "%s: removed", target);
#else
	/*
	 * We use MT_NOTICE instead of MT_CHANGE because this function is
	 * sometimes called by other functions that are suppose to return a
	 * single ack() back to the client (rdist).  This is a kludge until
	 * the Rdist protocol is re-done.  Sigh.
	 */
	message(MT_NOTICE|MT_REMOTE, "%s: removed", target);
#endif
	return(0);
}

/*
 * Check the current directory (initialized by the 'T' command to server())
 * for extraneous files and remove them.
 */
static void
doclean(char *cp)
{
	DIR *d;
	DIRENTRY *dp;
	struct stat stb;
	char *optarget, *ep;
	int len;
	opt_t opts;
	char targ[MAXPATHLEN*4];

	opts = strtol(cp, &ep, 8);
	if (*ep != CNULL) {
		error("clean: options not delimited");
		return;
	}
	if ((d = opendir(target)) == NULL) {
		error("%s: opendir failed: %s", target, SYSERR);
		return;
	}
	ack();

	optarget = ptarget;
	len = ptarget - target;
	while ((dp = readdir(d)) != NULL) {
		if ((D_NAMLEN(dp) == 1 && dp->d_name[0] == '.') ||
		    (D_NAMLEN(dp) == 2 && dp->d_name[0] == '.' &&
		     dp->d_name[1] == '.'))
			continue;

		if (len + 1 + (int)strlen(dp->d_name) >= MAXPATHLEN - 1) {
			message(MT_REMOTE|MT_WARNING, "%s/%s: Name too long",
				target, dp->d_name);
			continue;
		}
		ptarget = optarget;
		*ptarget++ = '/';
		cp = dp->d_name;;
		while ((*ptarget++ = *cp++) != '\0')
			continue;
		ptarget--;
		if (lstat(target, &stb) < 0) {
			message(MT_REMOTE|MT_WARNING, "%s: lstat failed: %s",
				target, SYSERR);
			continue;
		}

		ENCODE(targ, dp->d_name);
		(void) sendcmd(CC_QUERY, "%s", targ);
		(void) remline(cp = buf, sizeof(buf), TRUE);

		if (*cp != CC_YES)
			continue;

		if (IS_ON(opts, DO_VERIFY))
			message(MT_REMOTE|MT_INFO, "%s: need to remove",
				target);
		else
			(void) removefile(&stb, 0);
	}
	(void) closedir(d);

	ptarget = optarget;
	*ptarget = CNULL;
}

/*
 * Frontend to doclean().
 */
static void
clean(char *cp)
{
	doclean(cp);
	(void) sendcmd(CC_END, NULL);
	(void) response();
}

/*
 * Execute a shell command to handle special cases.
 * We can't really set an alarm timeout here since we
 * have no idea how long the command should take.
 */
static void
dospecial(char *xcmd)
{
	char cmd[BUFSIZ];
	if (DECODE(cmd, xcmd) == -1) {
		error("dospecial: Cannot decode command.");
		return;
	}
	runcommand(cmd);
}

/*
 * Do a special cmd command.  This differs from normal special
 * commands in that it's done after an entire command has been updated.
 * The list of updated target files is sent one at a time with RC_FILE
 * commands.  Each one is added to an environment variable defined by
 * E_FILES.  When an RC_COMMAND is finally received, the E_FILES variable
 * is stuffed into our environment and a normal dospecial() command is run.
 */
static void
docmdspecial(void)
{
	char *cp;
	char *cmd, *env = NULL;
	int n;
	size_t len;

	/* We're ready */
	ack();

	for ( ; ; ) {
		n = remline(cp = buf, sizeof(buf), FALSE);
		if (n <= 0) {
			error("cmdspecial: premature end of input.");
			return;
		}

		switch (*cp++) {
		case RC_FILE:
			if (env == NULL) {
				len = (2 * sizeof(E_FILES)) + strlen(cp) + 10;
				env = (char *) xmalloc(len);
				(void) snprintf(env, len, "export %s;%s=%s",
					       E_FILES, E_FILES, cp);
			} else {
				len = strlen(env) + 1 + strlen(cp) + 1;
				env = (char *) xrealloc(env, len);
				(void) strlcat(env, ":", len);
				(void) strlcat(env, cp, len);
			}
			ack();
			break;

		case RC_COMMAND:
			if (env) {
				len = strlen(env) + 1 + strlen(cp) + 1;
				env = (char *) xrealloc(env, len);
				(void) strlcat(env, ";", len);
				(void) strlcat(env, cp, len);
				cmd = env;
			} else
				cmd = cp;

			dospecial(cmd);
			if (env)
				(void) free(env);
			return;

		default:
			error("Unknown cmdspecial command '%s'.", cp);
			return;
		}
	}
}

/*
 * Query. Check to see if file exists. Return one of the following:
 *
#ifdef NFS_CHECK
 *  QC_ONNFS		- resides on a NFS
#endif NFS_CHECK
#ifdef RO_CHECK
 *  QC_ONRO		- resides on a Read-Only filesystem
#endif RO_CHECK
 *  QC_NO		- doesn't exist
 *  QC_YESsize mtime 	- exists and its a regular file (size & mtime of file)
 *  QC_YES		- exists and its a directory or symbolic link
 *  QC_ERRMSGmessage 	- error message
 */
static void
query(char *xname)
{
	static struct stat stb;
	int s = -1, stbvalid = 0;
	char name[MAXPATHLEN];

	if (DECODE(name, xname) == -1) {
		error("query: Cannot decode filename");
		return;
	}

	if (catname && cattarget(name) < 0)
		return;

#if	defined(NFS_CHECK)
	if (IS_ON(options, DO_CHKNFS)) {
		s = is_nfs_mounted(target, &stb, &stbvalid);
		if (s > 0)
			(void) sendcmd(QC_ONNFS, NULL);

		/* Either the above check was true or an error occurred */
		/* and is_nfs_mounted sent the error message */
		if (s != 0) {
			*ptarget = CNULL;
			return;
		}
	}
#endif 	/* NFS_CHECK */

#if	defined(RO_CHECK)
	if (IS_ON(options, DO_CHKREADONLY)) {
		s = is_ro_mounted(target, &stb, &stbvalid);
		if (s > 0)
			(void) sendcmd(QC_ONRO, NULL);

		/* Either the above check was true or an error occurred */
		/* and is_ro_mounted sent the error message */
		if (s != 0) {
			*ptarget = CNULL;
			return;
		}
	}
#endif 	/* RO_CHECK */

	if (IS_ON(options, DO_CHKSYM)) {
		if (is_symlinked(target, &stb, &stbvalid) > 0) {
			(void) sendcmd(QC_SYM, NULL);
			return;
		}
	}

	/*
	 * If stbvalid is false, "stb" is not valid because:
	 *	a) RO_CHECK and NFS_CHECK were not defined
	 *	b) The stat by is_*_mounted() either failed or
	 *	   does not match "target".
	 */
	if (!stbvalid && lstat(target, &stb) < 0) {
		if (errno == ENOENT)
			(void) sendcmd(QC_NO, NULL);
		else
			error("%s: lstat failed: %s", target, SYSERR);
		*ptarget = CNULL;
		return;
	}

	switch (stb.st_mode & S_IFMT) {
	case S_IFLNK:
	case S_IFDIR:
	case S_IFREG:
#ifdef notyet
	case S_IFCHR:
	case S_IFBLK:
#ifdef S_IFSOCK
	case S_IFSOCK:
#endif
#ifdef S_IFIFO
	case S_IFIFO:
#endif
#endif
		(void) sendcmd(QC_YES, "%ld %ld %o %s %s",
			       (long) stb.st_size, stb.st_mtime,
			       stb.st_mode & 07777,
			       getusername(stb.st_uid, target, options),
			       getgroupname(stb.st_gid, target, options));
		break;

	default:
		error("%s: not a file or directory", target);
		break;
	}
	*ptarget = CNULL;
}

/*
 * Check to see if parent directory exists and create one if not.
 */
static int
chkparent(char *name, opt_t opts)
{
	char *cp;
	struct stat stb;
	int r = -1;

	debugmsg(DM_CALL, "chkparent(%s, %o) start\n", name, opts);

	cp = strrchr(name, '/');
	if (cp == NULL || cp == name)
		return(0);

	*cp = CNULL;

	if (lstat(name, &stb) < 0) {
		if (errno == ENOENT && chkparent(name, opts) >= 0) {
			if (mkdir(name, 0777 & ~oumask) == 0) {
				message(MT_NOTICE, "%s: mkdir", name);
				r = 0;
			} else
				debugmsg(DM_MISC,
					 "chkparent(%s, %o) mkdir fail: %s\n",
					 name, opts, SYSERR);
		}
	} else	/* It exists */
		r = 0;

	/* Put back what we took away */
	*cp = '/';

	return(r);
}

/*
 * Save a copy of 'file' by renaming it.
 */
static char *
savetarget(char *file, opt_t opts)
{
	static char savefile[MAXPATHLEN];

	if (strlen(file) + sizeof(SAVE_SUFFIX) + 1 > MAXPATHLEN) {
		error("%s: Cannot save: Save name too long", file);
		return(NULL);
	}

	if (IS_ON(opts, DO_HISTORY)) {
		int i;
		struct stat st;
		/*
		 * There is a race here, but the worst that can happen
		 * is to lose a version of the file
		 */
		for (i = 1; i < 1000; i++) {
			(void) snprintf(savefile, sizeof(savefile),
					"%s;%.3d", file, i);
			if (stat(savefile, &st) == -1 && errno == ENOENT)
				break;

		}
		if (i == 1000) {
			message(MT_NOTICE,
			    "%s: More than 1000 versions for %s; reusing 1\n",
				savefile, SYSERR);
			i = 1;
			(void) snprintf(savefile, sizeof(savefile),
					"%s;%.3d", file, i);
		}
	}
	else {
		(void) snprintf(savefile, sizeof(savefile), "%s%s",
				file, SAVE_SUFFIX);

		if (unlink(savefile) != 0 && errno != ENOENT) {
			message(MT_NOTICE, "%s: remove failed: %s",
				savefile, SYSERR);
			return(NULL);
		}
	}

	if (rename(file, savefile) != 0 && errno != ENOENT) {
		error("%s -> %s: rename failed: %s",
		      file, savefile, SYSERR);
		return(NULL);
	}

	return(savefile);
}

/*
 * Receive a file
 */
static void
recvfile(char *new, opt_t opts, int mode, char *owner, char *group,
	 time_t mtime, time_t atime, off_t size)
{
	int f, wrerr, olderrno;
	off_t i;
	char *cp;
	char *savefile = NULL;
	static struct stat statbuff;

	if ((f = tempfd) == -1)
		return;
	chmod(new, mode);

	/*
	 * Receive the file itself
	 */
	ack();
	wrerr = 0;
	olderrno = 0;
	for (i = 0; i < size; i += BUFSIZ) {
		int amt = BUFSIZ;

		cp = buf;
		if (i + amt > size)
			amt = size - i;
		do {
			int j;

			j = readrem(cp, amt);
			if (j <= 0) {
				(void) close(f);
				(void) unlink(new);
				fatalerr(
				   "Read error occurred while receiving file.");
				finish();
			}
			amt -= j;
			cp += j;
		} while (amt > 0);
		amt = BUFSIZ;
		if (i + amt > size)
			amt = size - i;
		if (wrerr == 0 && xwrite(f, buf, amt) != amt) {
			olderrno = errno;
			wrerr++;
		}
	}

	if (response() < 0) {
		(void) close(f);
		(void) unlink(new);
		return;
	}

	if (wrerr) {
		error("%s: Write error: %s", new, strerror(olderrno));
		(void) close(f);
		(void) unlink(new);
		return;
	}

	/*
	 * Do file comparison if enabled
	 */
	if (IS_ON(opts, DO_COMPARE)) {
		FILE *f1, *f2;
		int c;

		errno = 0;	/* fopen is not a syscall */
		if ((f1 = fopen(target, "r")) == NULL) {
			error("%s: open for read failed: %s", target, SYSERR);
			(void) close(f);
			(void) unlink(new);
			return;
		}
		errno = 0;
		if ((f2 = fopen(new, "r")) == NULL) {
			error("%s: open for read failed: %s", new, SYSERR);
			(void) fclose(f1);
			(void) close(f);
			(void) unlink(new);
			return;
		}
		while ((c = getc(f1)) == getc(f2))
			if (c == EOF) {
				debugmsg(DM_MISC,
					 "Files are the same '%s' '%s'.",
					 target, new);
				(void) fclose(f1);
				(void) fclose(f2);
				(void) close(f);
				(void) unlink(new);
				/*
				 * This isn't an error per-se, but we
				 * need to indicate to the master that
				 * the file was not updated.
				 */
				error("");
				return;
			}
		debugmsg(DM_MISC, "Files are different '%s' '%s'.",
			 target, new);
		(void) fclose(f1);
		(void) fclose(f2);
		if (IS_ON(opts, DO_VERIFY)) {
			message(MT_REMOTE|MT_INFO, "%s: need to update",
				target);
			(void) close(f);
			(void) unlink(new);
			return;
		}
	}

	/*
	 * Set owner, group, and file mode
	 */
	if (fchog(f, new, owner, group, mode) < 0) {
		(void) close(f);
		(void) unlink(new);
		return;
	}
	(void) close(f);

	/*
	 * Perform utimes() after file is closed to make
	 * certain OS's, such as NeXT 2.1, happy.
	 */
	if (setfiletime(new, time((time_t *) 0), mtime) < 0)
		message(MT_NOTICE, "%s: utimes failed: %s", new, SYSERR);

	/*
	 * Try to save target file from being over-written
	 */
	if (IS_ON(opts, DO_SAVETARGETS))
		if ((savefile = savetarget(target, opts)) == NULL) {
			(void) unlink(new);
			return;
		}

	/*
	 * If the target is a directory, we need to remove it first
	 * before we can rename the new file.
	 */
	if ((stat(target, &statbuff) == 0) && S_ISDIR(statbuff.st_mode)) {
		char *saveptr = ptarget;

		ptarget = &target[strlen(target)];
		removefile(&statbuff, 0);
		ptarget = saveptr;
	}

	/*
	 * Install new (temporary) file as the actual target
	 */
	if (rename(new, target) < 0) {
		static char fmt[] = "%s -> %s: rename failed: %s";
		struct stat stb;
		/*
		 * If the rename failed due to "Text file busy", then
		 * try to rename the target file and retry the rename.
		 */
		switch (errno) {
		case ETXTBSY:
			/* Save the target */
			if ((savefile = savetarget(target, opts)) != NULL) {
				/* Retry installing new file as target */
				if (rename(new, target) < 0) {
					error(fmt, new, target, SYSERR);
					/* Try to put back save file */
					if (rename(savefile, target) < 0)
						error(fmt,
						      savefile, target, SYSERR);
					(void) unlink(new);
				} else
					message(MT_NOTICE, "%s: renamed to %s",
						target, savefile);
				/*
				 * XXX: We should remove the savefile here.
				 *	But we are nice to nfs clients and
				 *	we keep it.
				 */
			}
			break;
		case EISDIR:
			/*
			 * See if target is a directory and remove it if it is
			 */
			if (lstat(target, &stb) == 0) {
				if (S_ISDIR(stb.st_mode)) {
					char *optarget = ptarget;
					for (ptarget = target; *ptarget;
						ptarget++);
					/* If we failed to remove, we'll catch
					   it later */
					(void) removefile(&stb, 1);
					ptarget = optarget;
				}
			}
			if (rename(new, target) >= 0)
				break;
			/*FALLTHROUGH*/

		default:
			error(fmt, new, target, SYSERR);
			(void) unlink(new);
			break;
		}
	}

	if (IS_ON(opts, DO_COMPARE))
		message(MT_REMOTE|MT_CHANGE, "%s: updated", target);
	else
		ack();
}

/*
 * Receive a directory
 */
static void
recvdir(opt_t opts, int mode, char *owner, char *group)
{
	static char lowner[100], lgroup[100];
	char *cp;
	struct stat stb;
	int s;

	s = lstat(target, &stb);
	if (s == 0) {
		/*
		 * If target is not a directory, remove it
		 */
		if (!S_ISDIR(stb.st_mode)) {
			if (IS_ON(opts, DO_VERIFY))
				message(MT_NOTICE, "%s: need to remove",
					target);
			else {
				if (unlink(target) < 0) {
					error("%s: remove failed: %s",
					      target, SYSERR);
					return;
				}
			}
			s = -1;
			errno = ENOENT;
		} else {
			if (!IS_ON(opts, DO_NOCHKMODE) &&
			    (stb.st_mode & 07777) != mode) {
				if (IS_ON(opts, DO_VERIFY))
					message(MT_NOTICE,
						"%s: need to chmod to %o",
						target, mode);
				else {
					if (chmod(target, mode) != 0)
						message(MT_NOTICE,
					  "%s: chmod from %o to %o failed: %s",
							target,
							stb.st_mode & 07777,
							mode,
							SYSERR);
					else
						message(MT_NOTICE,
						"%s: chmod from %o to %o",
							target,
							stb.st_mode & 07777,
							mode);
				}
			}

			/*
			 * Check ownership and set if necessary
			 */
			lowner[0] = CNULL;
			lgroup[0] = CNULL;

			if (!IS_ON(opts, DO_NOCHKOWNER) && owner) {
				int o;

				o = (owner[0] == ':') ? opts & DO_NUMCHKOWNER :
					opts;
				if ((cp = getusername(stb.st_uid, target, o))
				    != NULL)
					if (strcmp(owner, cp))
						(void) strlcpy(lowner, cp,
						    sizeof(lowner));
			}
			if (!IS_ON(opts, DO_NOCHKGROUP) && group) {
				int o;

				o = (group[0] == ':') ? opts & DO_NUMCHKGROUP :
					opts;
				if ((cp = getgroupname(stb.st_gid, target, o))
				    != NULL)
					if (strcmp(group, cp))
						(void) strlcpy(lgroup, cp,
						    sizeof(lgroup));
			}

			/*
			 * Need to set owner and/or group
			 */
#define PRN(n) ((n[0] == ':') ? n+1 : n)
			if (lowner[0] != CNULL || lgroup[0] != CNULL) {
				if (lowner[0] == CNULL &&
				    (cp = getusername(stb.st_uid,
						      target, opts)))
					(void) strlcpy(lowner, cp,
					    sizeof(lowner));
				if (lgroup[0] == CNULL &&
				    (cp = getgroupname(stb.st_gid,
						       target, opts)))
					(void) strlcpy(lgroup, cp,
					    sizeof(lgroup));

				if (IS_ON(opts, DO_VERIFY))
					message(MT_NOTICE,
				"%s: need to chown from %s:%s to %s:%s",
						target,
						PRN(lowner), PRN(lgroup),
						PRN(owner), PRN(group));
				else {
					if (fchog(-1, target, owner,
						  group, -1) == 0)
						message(MT_NOTICE,
					       "%s: chown from %s:%s to %s:%s",
							target,
							PRN(lowner),
							PRN(lgroup),
							PRN(owner),
							PRN(group));
				}
			}
#undef PRN
			ack();
			return;
		}
	}

	if (IS_ON(opts, DO_VERIFY)) {
		ack();
		return;
	}

	/*
	 * Create the directory
	 */
	if (s < 0) {
		if (errno == ENOENT) {
			if (mkdir(target, mode) == 0 ||
			    (chkparent(target, opts) == 0 &&
			    mkdir(target, mode) == 0)) {
				message(MT_NOTICE, "%s: mkdir", target);
				(void) fchog(-1, target, owner, group, mode);
				ack();
			} else {
				error("%s: mkdir failed: %s", target, SYSERR);
				ptarget = sptarget[--catname];
				*ptarget = CNULL;
			}
			return;
		}
	}
	error("%s: lstat failed: %s", target, SYSERR);
	ptarget = sptarget[--catname];
	*ptarget = CNULL;
}

/*
 * Receive a link
 */
static void
recvlink(char *new, opt_t opts, int mode, off_t size)
{
	char tbuf[MAXPATHLEN];
	struct stat stb;
	char *optarget;
	int uptodate;
	off_t i;

	/*
	 * Read basic link info
	 */
	ack();
	(void) remline(buf, sizeof(buf), TRUE);

	if (response() < 0) {
		err();
		return;
	}

	uptodate = 0;
	if ((i = readlink(target, tbuf, sizeof(tbuf)-1)) != -1) {
		tbuf[i] = '\0';
		if (i == size && strncmp(buf, tbuf, (int) size) == 0)
			uptodate = 1;
	}
	mode &= 0777;

	if (IS_ON(opts, DO_VERIFY) || uptodate) {
		if (uptodate)
			message(MT_REMOTE|MT_INFO, "");
		else
			message(MT_REMOTE|MT_INFO, "%s: need to update",
				target);
		if (IS_ON(opts, DO_COMPARE))
			return;
		(void) sendcmd(C_END, NULL);
		(void) response();
		return;
	}

	/*
	 * Make new symlink using a temporary name
	 */
	if (tempfd != -1) {
		close(tempfd);
		unlink(new);
	}
	if (symlink(buf, new) < 0) {
		if (errno != ENOENT || chkparent(new, opts) < 0 ||
		    symlink(buf, new) < 0) {
			error("%s -> %s: symlink failed: %s", new, buf,SYSERR);
			(void) unlink(new);
			return;
		}
	}

	/*
	 * See if target is a directory and remove it if it is
	 */
	if (lstat(target, &stb) == 0) {
		if (S_ISDIR(stb.st_mode)) {
			optarget = ptarget;
			for (ptarget = target; *ptarget; ptarget++);
			if (removefile(&stb, 0) < 0) {
				ptarget = optarget;
				(void) unlink(new);
				(void) sendcmd(C_END, NULL);
				(void) response();
				return;
			}
			ptarget = optarget;
		}
	}

	/*
	 * Install link as the target
	 */
	if (rename(new, target) < 0) {
		error("%s -> %s: symlink rename failed: %s",
		      new, target, SYSERR);
		(void) unlink(new);
		(void) sendcmd(C_END, NULL);
		(void) response();
		return;
	}

	message(MT_REMOTE|MT_CHANGE, "%s: updated", target);

	/*
	 * Indicate end of receive operation
	 */
	(void) sendcmd(C_END, NULL);
	(void) response();
}

/*
 * Creat a hard link to existing file.
 */
static void
hardlink(char *cmd)
{
	struct stat stb;
	int exists = 0;
	char *xoldname, *xnewname;
	char *cp = cmd;
	static char expbuf[BUFSIZ];
	char oldname[BUFSIZ], newname[BUFSIZ];

	/* Skip over opts */
	(void) strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("hardlink: options not delimited");
		return;
	}

	xoldname = strtok(cp, " ");
	if (xoldname == NULL) {
		error("hardlink: oldname name not delimited");
		return;
	}

	if (DECODE(oldname, xoldname) == -1) {
		error("hardlink: Cannot decode oldname");
		return;
	}

	xnewname = strtok(NULL, " ");
	if (xnewname == NULL) {
		error("hardlink: new name not specified");
		return;
	}

	if (DECODE(newname, xnewname) == -1) {
		error("hardlink: Cannot decode newname");
		return;
	}

	if (exptilde(expbuf, oldname, sizeof(expbuf)) == NULL) {
		error("hardlink: tilde expansion failed");
		return;
	}

	if (catname && cattarget(newname) < 0) {
		error("Cannot set newname target.");
		return;
	}

	if (lstat(target, &stb) == 0) {
		int mode = stb.st_mode & S_IFMT;

		if (mode != S_IFREG && mode != S_IFLNK) {
			error("%s: not a regular file", target);
			return;
		}
		exists = 1;
	}

	if (chkparent(target, options) < 0 ) {
		error("%s: no parent: %s ", target, SYSERR);
		return;
	}
	if (exists && (unlink(target) < 0)) {
		error("%s: unlink failed: %s", target, SYSERR);
		return;
	}
	if (link(expbuf, target) < 0) {
		error("%s: cannot link to %s: %s", target, oldname, SYSERR);
		return;
	}
	ack();
}

/*
 * Set configuration information.
 *
 * A key letter is followed immediately by the value
 * to set.  The keys are:
 *	SC_FREESPACE	- Set minimium free space of filesystem
 *	SC_FREEFILES	- Set minimium free number of files of filesystem
 */
static void
setconfig(char *cmd)
{
	char *cp = cmd;
	char *estr;

	switch (*cp++) {
	case SC_HOSTNAME:	/* Set hostname */
		/*
		 * Only use info if we don't know who this is.
		 */
		if (!fromhost) {
			fromhost = xstrdup(cp);
			message(MT_SYSLOG, "startup for %s", fromhost);
#if defined(SETARGS) || defined(HAVE_SETPROCTITLE)
			setproctitle("serving %s", cp);
#endif /* SETARGS || HAVE_SETPROCTITLE */
		}
		break;

	case SC_FREESPACE: 	/* Minimium free space */
		if (!isdigit((unsigned char)*cp)) {
			fatalerr("Expected digit, got '%s'.", cp);
			return;
		}
		min_freespace = (unsigned long) atoi(cp);
		break;

	case SC_FREEFILES: 	/* Minimium free files */
		if (!isdigit((unsigned char)*cp)) {
			fatalerr("Expected digit, got '%s'.", cp);
			return;
		}
		min_freefiles = (unsigned long) atoi(cp);
		break;

	case SC_LOGGING:	/* Logging options */
		if ((estr = msgparseopts(cp, TRUE)) != NULL) {
			fatalerr("Bad message option string (%s): %s",
				 cp, estr);
			return;
		}
		break;

	case SC_DEFOWNER:
		(void) strlcpy(defowner, cp, sizeof(defowner));
		break;

	case SC_DEFGROUP:
		(void) strlcpy(defgroup, cp, sizeof(defgroup));
		break;

	default:
		message(MT_NOTICE, "Unknown config command \"%s\".", cp-1);
		return;
	}
}

/*
 * Receive something
 */
static void
recvit(char *cmd, int type)
{
	int mode;
	opt_t opts;
	off_t size;
	time_t mtime, atime;
	char *owner, *group, *file;
	char new[MAXPATHLEN];
	char fileb[MAXPATHLEN];
	long freespace = -1, freefiles = -1;
	char *cp = cmd;

	/*
	 * Get rdist option flags
	 */
	opts = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("recvit: options not delimited");
		return;
	}

	/*
	 * Get file mode
	 */
	mode = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("recvit: mode not delimited");
		return;
	}

	/*
	 * Get file size
	 */
	size = strtol(cp, &cp, 10);
	if (*cp++ != ' ') {
		error("recvit: size not delimited");
		return;
	}

	/*
	 * Get modification time
	 */
	mtime = strtol(cp, &cp, 10);
	if (*cp++ != ' ') {
		error("recvit: mtime not delimited");
		return;
	}

	/*
	 * Get access time
	 */
	atime = strtol(cp, &cp, 10);
	if (*cp++ != ' ') {
		error("recvit: atime not delimited");
		return;
	}

	/*
	 * Get file owner name
	 */
	owner = strtok(cp, " ");
	if (owner == NULL) {
		error("recvit: owner name not delimited");
		return;
	}

	/*
	 * Get file group name
	 */
	group = strtok(NULL, " ");
	if (group == NULL) {
		error("recvit: group name not delimited");
		return;
	}

	/*
	 * Get file name. Can't use strtok() since there could
	 * be white space in the file name.
	 */
	if (DECODE(fileb, group + strlen(group) + 1) == -1) {
		error("recvit: Cannot decode file name");
		return;
	}

	if (fileb[0] == '\0') {
		error("recvit: no file name");
		return;
	}
	file = fileb;

	debugmsg(DM_MISC,
		 "recvit: opts = %04o mode = %04o size = %d mtime = %d",
		 opts, mode, size, mtime);
	debugmsg(DM_MISC,
       "recvit: owner = '%s' group = '%s' file = '%s' catname = %d isdir = %d",
		 owner, group, file, catname, (type == S_IFDIR) ? 1 : 0);

	if (type == S_IFDIR) {
		if ((size_t) catname >= sizeof(sptarget)) {
			error("%s: too many directory levels", target);
			return;
		}
		sptarget[catname] = ptarget;
		if (catname++) {
			*ptarget++ = '/';
			while ((*ptarget++ = *file++) != '\0')
			    continue;
			ptarget--;
		}
	} else {
		/*
		 * Create name of temporary file
		 */
		if (catname && cattarget(file) < 0) {
			error("Cannot set file name.");
			return;
		}
		file = strrchr(target, '/');
		if (file == NULL)
			(void) strlcpy(new, tempname, sizeof(new));
		else if (file == target)
			(void) snprintf(new, sizeof(new), "/%s", tempname);
		else {
			*file = CNULL;
			(void) snprintf(new, sizeof(new), "%s/%s", target,
					tempname);
			*file = '/';
		}
		if ((tempfd = mkstemp(new)) == -1)
			if (errno != ENOENT || chkparent(new, opts) < 0 ||
			    (tempfd = mkstemp(new)) < 0)
				if (tempfd != -1) {
					close(tempfd);
					unlink(new);
					tempfd = -1;
				}
	}

	/*
	 * Check to see if there is enough free space and inodes
	 * to install this file.
	 */
	if (min_freespace || min_freefiles) {
		/* Convert file size to kilobytes */
		long fsize = (long) (size / 1024);

		if (getfilesysinfo(target, &freespace, &freefiles) != 0)
			return;

		/*
		 * filesystem values < 0 indicate unsupported or unavailable
		 * information.
		 */
		if (min_freespace && (freespace >= 0) &&
		    (freespace - fsize < min_freespace)) {
			error(
		     "%s: Not enough free space on filesystem: min %d free %d",
			      target, min_freespace, freespace);
			return;
		}
		if (min_freefiles && (freefiles >= 0) &&
		    (freefiles - 1 < min_freefiles)) {
			error(
		     "%s: Not enough free files on filesystem: min %d free %d",
			      target, min_freefiles, freefiles);
			return;
		}
	}

	/*
	 * Call appropriate receive function to receive file
	 */
	switch (type) {
	case S_IFDIR:
		recvdir(opts, mode, owner, group);
		break;

	case S_IFLNK:
		recvlink(new, opts, mode, size);
		break;

	case S_IFREG:
		recvfile(new, opts, mode, owner, group, mtime, atime, size);
		break;

	default:
		error("%d: unknown file type", type);
		break;
	}
}

/*
 * Chmog something
 */
static void
dochmog(char *cmd)
{
	int mode;
	opt_t opts;
	char *owner, *group, *file;
	char *cp = cmd;
	char fileb[MAXPATHLEN];

	/*
	 * Get rdist option flags
	 */
	opts = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("dochmog: options not delimited");
		return;
	}

	/*
	 * Get file mode
	 */
	mode = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("dochmog: mode not delimited");
		return;
	}

	/*
	 * Get file owner name
	 */
	owner = strtok(cp, " ");
	if (owner == NULL) {
		error("dochmog: owner name not delimited");
		return;
	}

	/*
	 * Get file group name
	 */
	group = strtok(NULL, " ");
	if (group == NULL) {
		error("dochmog: group name not delimited");
		return;
	}

	/*
	 * Get file name. Can't use strtok() since there could
	 * be white space in the file name.
	 */
	if (DECODE(fileb, group + strlen(group) + 1) == -1) {
		error("dochmog: Cannot decode file name");
		return;
	}

	if (fileb[0] == '\0') {
		error("dochmog: no file name");
		return;
	}
	file = fileb;

	debugmsg(DM_MISC,
		 "dochmog: opts = %04o mode = %04o", opts, mode);
	debugmsg(DM_MISC,
	         "dochmog: owner = '%s' group = '%s' file = '%s' catname = %d",
		 owner, group, file, catname);

	if (catname && cattarget(file) < 0) {
		error("Cannot set newname target.");
		return;
	}

	(void) fchog(-1, target, owner, group, mode);

	ack();
}

/*
 * Set target information
 */
static void
settarget(char *cmd, int isdir)
{
	char *cp = cmd;
	opt_t opts;
	char file[BUFSIZ];

	catname = isdir;

	/*
	 * Parse options for this target
	 */
	opts = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("settarget: options not delimited");
		return;
	}
	options = opts;

	if (DECODE(file, cp) == -1) {
		error("settarget: Cannot decode target name");
		return;
	}

	/*
	 * Handle target
	 */
	if (exptilde(target, cp, sizeof(target)) == NULL)
		return;
	ptarget = target;
	while (*ptarget)
		ptarget++;

	ack();
}

/*
 * Cleanup in preparation for exiting.
 */
void
cleanup(int dummy)
{
	/* We don't need to do anything */
}

/*
 * Server routine to read requests and process them.
 */
void
server(void)
{
	static char cmdbuf[BUFSIZ];
	char *cp;
	int n;
	extern jmp_buf finish_jmpbuf;

	if (setjmp(finish_jmpbuf))
		return;
	(void) signal(SIGHUP, sighandler);
	(void) signal(SIGINT, sighandler);
	(void) signal(SIGQUIT, sighandler);
	(void) signal(SIGTERM, sighandler);
	(void) signal(SIGPIPE, sighandler);
	(void) umask(oumask = umask(0));
	(void) strlcpy(tempname, _RDIST_TMP, sizeof(tempname));
	if (fromhost) {
		message(MT_SYSLOG, "Startup for %s", fromhost);
#if 	defined(SETARGS)
		setproctitle("Serving %s", fromhost);
#endif	/* SETARGS */
	}

	/*
	 * Let client know we want it to send it's version number
	 */
	(void) sendcmd(S_VERSION, NULL);

	if (remline(cmdbuf, sizeof(cmdbuf), TRUE) < 0) {
		error("server: expected control record");
		return;
	}

	if (cmdbuf[0] != S_VERSION || !isdigit((unsigned char)cmdbuf[1])) {
		error("Expected version command, received: \"%s\".", cmdbuf);
		return;
	}

	proto_version = atoi(&cmdbuf[1]);
	if (proto_version != VERSION) {
		error("Protocol version %d is not supported.", proto_version);
		return;
	}

	/* Version number is okay */
	ack();

	/*
	 * Main command loop
	 */
	for ( ; ; ) {
		n = remline(cp = cmdbuf, sizeof(cmdbuf), TRUE);
		if (n == -1)		/* EOF */
			return;
		if (n == 0) {
			error("server: expected control record");
			continue;
		}

		switch (*cp++) {
		case C_SETCONFIG:  	/* Configuration info */
		        setconfig(cp);
			ack();
			continue;

		case C_DIRTARGET:  	/* init target file/directory name */
			settarget(cp, TRUE);
			continue;

		case C_TARGET:  	/* init target file/directory name */
			settarget(cp, FALSE);
			continue;

		case C_RECVREG:  	/* Transfer a regular file. */
			recvit(cp, S_IFREG);
			continue;

		case C_RECVDIR:  	/* Transfer a directory. */
			recvit(cp, S_IFDIR);
			continue;

		case C_RECVSYMLINK:  	/* Transfer symbolic link. */
			recvit(cp, S_IFLNK);
			continue;

		case C_RECVHARDLINK:  	/* Transfer hard link. */
			hardlink(cp);
			continue;

		case C_END:  		/* End of transfer */
			*ptarget = CNULL;
			if (catname <= 0) {
				error("server: too many '%c's", C_END);
				continue;
			}
			ptarget = sptarget[--catname];
			*ptarget = CNULL;
			ack();
			continue;

		case C_CLEAN:  		/* Clean. Cleanup a directory */
			clean(cp);
			continue;

		case C_QUERY:  		/* Query file/directory */
			query(cp);
			continue;

		case C_SPECIAL:  	/* Special. Execute commands */
			dospecial(cp);
			continue;

		case C_CMDSPECIAL:  	/* Cmd Special. Execute commands */
			docmdspecial();
			continue;

	        case C_CHMOG:  		/* Set owner, group, mode */
			dochmog(cp);
			continue;

		case C_ERRMSG:		/* Normal error message */
			if (cp && *cp)
				message(MT_NERROR|MT_NOREMOTE, "%s", cp);
			continue;

		case C_FERRMSG:		/* Fatal error message */
			if (cp && *cp)
				message(MT_FERROR|MT_NOREMOTE, "%s", cp);
			return;

		default:
			error("server: unknown command '%s'", cp - 1);
		case CNULL:
			continue;
		}
	}
}
@


1.2
log
@* remove all GNU Automake files, we don't need them
* disable stupid "if Makefile.am isn't there, I can't build
  Makefile.in so I can't build Makefile so... huh?" stuff
* basically synch lists (base, not x11) with what is gained;
  more review needed
  XXX adjust notes
* various improvements I don't remember
* add configs from the FSF
  (with MirBSD and ekkoBSD support added by myself)
* update some FSF material
* plug some strcpy, strcat, sprintf, mktemp holes
* fix and unify the way where and how the gcc version subdirs are included

XXX someone string-"fix" roff and the gnu part (isdnd will be taken care of later)
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: server.c,v 1.10 2001/11/19 19:02:15 mpech Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d32 2
d36 2
a37 2
static char RCSid[] = 
"$From: server.c,v 6.85 1996/03/12 22:55:38 mcooper Exp $";
d39 2
a40 2
static char RCSid[] = 
"$OpenBSD: server.c,v 1.10 2001/11/19 19:02:15 mpech Exp $";
d43 2
a44 1
static char sccsid[] = "@@(#)server.c	5.3 (Berkeley) 6/7/86";
d46 1
a46 1
static char copyright[] =
a54 2
#include "defs.h"

d56 1
d67 21
d91 2
a92 2
static int cattarget(string)
	char *string;
d103 2
a104 1
	(void) sprintf(ptarget, "/%s", string);
d108 1
a108 1
	
d112 2
a113 5
static int setownership(file, fd, uid, gid)
	char *file;
	int fd;
	UID_T uid;
	GID_T gid;
d120 14
a133 5
	if (getuid() == 0) {
#if	defined(HAVE_FCHOWN)
		if (fd != -1)
			status = fchown(fd, (CHOWN_UID_T) uid, 
					(CHOWN_GID_T) gid);
d135 1
a135 10
		if (status < 0)
			status = chown(file, (CHOWN_UID_T) uid, 
				       (CHOWN_GID_T) gid);

		if (status < 0) {
			message(MT_NOTICE, "%s: chown %d.%d failed: %s", 
				target, (UID_T) uid, (GID_T) gid, SYSERR);
			return(-1);
		}
	} else {
d137 3
a139 3
		if (fd != -1)
			status = fchown(fd, (CHOWN_UID_T) -1, 
					(CHOWN_GID_T) gid);
d141 3
a143 3
		if (status < 0)
			status = chown(file, (CHOWN_UID_T) -1, 
				       (CHOWN_GID_T) gid);
d145 2
a146 1
		if (status < 0) {
d148 5
a152 3
				target, (GID_T) gid, SYSERR);
			return(-1);
		}
d161 2
a162 4
static int setfilemode(file, fd, mode)
	char *file;
	int fd;
	int mode;
d169 12
d182 1
a182 1
	if (fd != -1)
d186 1
a186 1
	if (status < 0)
a195 19

/*
 * Get group entry.  This routine takes a string argument (name).
 * If name is of form ":N" a lookup for gid N is done.
 * Otherwise a lookup by name is done.
 */
static struct group *mygetgroup(name)
	char *name;
{
    	struct group *gr;

	if (*name == ':')
	    	gr = getgrgid(atoi(name + 1));
	else
	    	gr = getgrnam(name);

	return(gr);
}

d199 2
a200 4
static int fchog(fd, file, owner, group, mode)
	int fd;
	char *file, *owner, *group;
	int mode;
d202 1
a202 6
	struct group *gr = NULL;
	static char last_group[128];
	static char last_owner[128];
	static GID_T last_gid = (GID_T)-2;
	static UID_T last_uid = (UID_T)-2;
	static GID_T last_primegid;
d205 1
d214 1
a214 2
		} else if (last_uid == (UID_T)-2 ||
			   strcmp(owner, last_owner) != 0) {
d226 2
a227 5
			} else {
				uid	 = last_uid	 = pw->pw_uid;
				primegid = last_primegid = pw->pw_gid;
				strcpy(last_owner, owner);
			}
d229 2
a230 2
			uid = last_uid;
			primegid = last_primegid;
d240 1
a240 1
			if (IS_ON(mode, S_ISUID) && 
d252 4
a255 8
	if (last_gid < (GID_T)0 || strcmp(group, last_group) != 0) {
	        /*
		 * Invalid cached values so we need to do a new lookup.
		 */
		if ((gr = mygetgroup(group))) {
			last_gid = gid = gr->gr_gid;
			strcpy(last_group, gr->gr_name);
		} else {
d257 1
a257 1
				message(MT_NOTICE, 
d262 1
a262 1
				message(MT_NOTICE, 
d265 4
a268 7
		}
	} else {
	    	/*
		 * Use the cached values.
		 */
		gid = last_gid;
	}
a269 4
	/*
	 * We need to check non-root users to make sure they're a member
	 * of the group.  If they are not, we don't set that gid ownership.
	 */
a270 2
		if (!gr)
		    	gr = mygetgroup(group);
d273 1
a273 1
			    	if (strcmp(locuser, gr->gr_mem[i]) == 0)
d276 1
a276 1
			message(MT_NOTICE, 
d284 4
d293 1
a293 1
	if (setownership(file, fd, uid, gid) < 0) {
d295 1
a295 1
			message(MT_NOTICE, 
d300 1
a300 1
			message(MT_NOTICE, 
d305 1
a305 1
	(void) setfilemode(file, fd, mode);
d315 2
a316 2
static int removefile(statb)
	struct stat *statb;
d328 8
d338 4
a341 3
				message(MT_REMOTE|MT_NOTICE, 
					"%s: unlink failed: %s",
					target, SYSERR);
d366 1
a366 1
	while ((dp = readdir(d))) {
d373 4
a376 2
			message(MT_REMOTE|MT_WARNING, "%s/%s: Name too long", 
				target, dp->d_name);
d382 2
a383 2
		while ((*ptarget++ = *cp++))
			;
d386 4
a389 2
			message(MT_REMOTE|MT_WARNING, "%s: lstat failed: %s", 
				target, SYSERR);
d392 1
a392 1
		if (removefile(&stb) < 0)
d407 4
d418 1
d426 2
a427 2
static void doclean(cp)
	char *cp;
d435 1
d450 1
a450 1
	while ((dp = readdir(d))) {
d457 1
a457 1
			message(MT_REMOTE|MT_WARNING, "%s/%s: Name too long", 
d464 2
a465 2
		while ((*ptarget++ = *cp++))
			;
d468 1
a468 1
			message(MT_REMOTE|MT_WARNING, "%s: lstat failed: %s", 
d473 2
a474 1
		(void) sendcmd(CC_QUERY, "%s", dp->d_name);
d481 1
a481 1
			message(MT_REMOTE|MT_INFO, "%s: need to remove", 
d484 1
a484 1
			(void) removefile(&stb);
d495 2
a496 2
static void clean(cp)
	char *cp;
d508 2
a509 2
static void dospecial(cmd)
	char *cmd;
d511 5
d527 2
a528 1
static void docmdspecial()
d533 1
a533 1
	int len;
d550 1
a550 1
				(void) sprintf(env, "export %s;%s=%s", 
d553 4
a556 6
				len = strlen(env);
				env = (char *) xrealloc(env, 
							len + strlen(cp) + 2);
				env[len] = CNULL;
				(void) strcat(env, ":");
				(void) strcat(env, cp);
d563 4
a566 6
				len = strlen(env);
				env = (char *) xrealloc(env, 
							len + strlen(cp) + 2);
				env[len] = CNULL;
				(void) strcat(env, ";");
				(void) strcat(env, cp);
d597 2
a598 2
static void query(name)
	char *name;
d602 6
d668 10
d679 1
a679 2
			       (long) stb.st_size, 
			       stb.st_mtime, 
d681 1
a681 1
			       getusername(stb.st_uid, target, options), 
d695 2
a696 3
static int chkparent(name, opts)
	char *name;
	opt_t opts;
d715 2
a716 2
			} else 
				debugmsg(DM_MISC, 
d732 2
a733 2
static char *savetarget(file)
	char *file;
d742 32
a773 5
	(void) sprintf(savefile, "%s%s", file, SAVE_SUFFIX);

	if (unlink(savefile) != 0 && errno != ENOENT) {
		message(MT_NOTICE, "%s: remove failed: %s", savefile, SYSERR);
		return(NULL);
d777 1
a777 1
		error("%s -> %s: rename failed: %s", 
a785 18
 * See if buf is all zeros (sparse check)
 */
static int iszeros (buf, size)
	char *buf;
	off_t size;
{
    	while (size > 0) {
	    if (*buf != CNULL)
		return(0);
	    buf++;
	    size--;
	}

	return(1);
}

  
/*
d788 3
a790 9
static void recvfile(new, opts, mode, owner, group, mtime, atime, size)
	/*ARGSUSED*/
	char *new;
	opt_t opts;
	int mode;
	char *owner, *group;
	time_t mtime;
	time_t atime;
	off_t size;
d792 1
a792 1
	int f, wrerr, olderrno, lastwashole = 0, wassparse = 0;
d798 3
a800 11
	/*
	 * Create temporary file
	 */
	if ((f = open(new, O_CREAT|O_EXCL|O_WRONLY, mode)) < 0) {
		if (errno != ENOENT || chkparent(new, opts) < 0 ||
		    (f = open(new, O_CREAT|O_EXCL|O_WRONLY, mode)) < 0) {
			error("%s: create failed: %s", new, SYSERR);
			(void) unlink(new);
			return;
		}
	}
d831 1
a831 25
		if (IS_ON(opts, DO_SPARSE) && iszeros(buf, amt)) {
		    	if (lseek (f, amt, SEEK_CUR) < 0L) {
			    	olderrno = errno;
				wrerr++;
			}
			lastwashole = 1;
			wassparse++;
		} else {
		    	if (wrerr == 0 && xwrite(f, buf, amt) != amt) {
			    	olderrno = errno;
				wrerr++;
			}
			lastwashole = 0;
		}
	}

	if (lastwashole) {
#if	defined(HAVE_FTRUNCATE)
	    	if (write (f, "", 1) != 1 || ftruncate (f, size) < 0)
#else
		/* Seek backwards one character and write a null.  */
		if (lseek (f, (off_t) -1, SEEK_CUR) < 0L
		    || write (f, "", 1) != 1)
#endif
		{
d867 1
d874 1
a874 1
				debugmsg(DM_MISC, 
d894 1
a894 1
			message(MT_REMOTE|MT_INFO, "%s: need to update", 
d923 1
a923 1
		if ((savefile = savetarget(target)) == NULL) {
d936 1
a936 1
		removefile(&statbuff);
d944 2
d950 2
a951 1
		if (errno == ETXTBSY) {
d953 1
a953 1
			if ((savefile = savetarget(target)) != NULL) {
d956 1
a956 2
					error("%s -> %s: rename failed: %s",
					      new, target, SYSERR);
d959 3
a961 4
						error(
					         "%s -> %s: rename failed: %s",
						      savefile, target, 
						      SYSERR);
d965 21
d987 6
a992 3
		} else {
			error("%s -> %s: rename failed: %s", 
			      new, target, SYSERR);
d994 1
a997 3
	if (wassparse)
	    	message (MT_NOTICE, "%s: was sparse", target);

d1007 2
a1008 4
static void recvdir(opts, mode, owner, group)
	opt_t opts;
	int mode;
	char *owner, *group;
d1037 1
a1037 1
					message(MT_NOTICE, 
d1044 2
a1045 2
							target, 
							stb.st_mode & 07777, 
d1051 2
a1052 2
							target, 
							stb.st_mode & 07777, 
d1068 2
a1069 1
				if ((cp = getusername(stb.st_uid, target, o)))
d1071 2
a1072 1
						(void) strcpy(lowner, cp);
d1079 2
a1080 1
				if ((cp = getgroupname(stb.st_gid, target, o)))
d1082 2
a1083 1
						(void) strcpy(lgroup, cp);
d1091 2
a1092 2
				if (lowner[0] == CNULL && 
				    (cp = getusername(stb.st_uid, 
d1094 4
a1097 3
					(void) strcpy(lowner, cp);
				if (lgroup[0] == CNULL && 
				    (cp = getgroupname(stb.st_gid, 
d1099 2
a1100 1
					(void) strcpy(lgroup, cp);
d1104 2
a1105 2
				"%s: need to chown from %s.%s to %s.%s",
						target, 
d1109 1
a1109 1
					if (fchog(-1, target, owner, 
d1112 1
a1112 1
					       "%s: chown from %s.%s to %s.%s",
d1114 1
a1114 1
							PRN(lowner), 
d1116 1
a1116 1
							PRN(owner), 
d1137 1
a1137 1
			    (chkparent(target, opts) == 0 && 
d1158 2
a1159 5
static void recvlink(new, opts, mode, size)
	char *new;
	opt_t opts;
	int mode;
	off_t size;
d1161 1
d1164 1
d1178 21
d1202 4
a1215 24
	 * Do comparison of what link is pointing to if enabled
	 */
	mode &= 0777;
	if (IS_ON(opts, DO_COMPARE)) {
		char tbuf[MAXPATHLEN];
		
		if ((i = readlink(target, tbuf, sizeof(tbuf)-1)) != -1)
			tbuf[i] = '\0';
		if (i != -1 && i == size && strncmp(buf, tbuf, (size_t) size) == 0) {
			(void) unlink(new);
			ack();
			return;
		}
		if (IS_ON(opts, DO_VERIFY)) {
			(void) unlink(new);
			message(MT_REMOTE|MT_INFO, "%s: need to update",
				target);
			(void) sendcmd(C_END, NULL);
			(void) response();
			return;
		}
	}

	/*
d1222 1
a1222 1
			if (removefile(&stb) < 0) {
d1245 1
a1245 4
	if (IS_ON(opts, DO_COMPARE))
		message(MT_REMOTE|MT_CHANGE, "%s: updated", target);
	else
	        ack();
d1257 2
a1258 2
static void hardlink(cmd)
	char *cmd;
d1262 1
a1262 1
	char *oldname, *newname;
d1265 1
d1274 2
a1275 2
	oldname = strtok(cp, " ");
	if (oldname == NULL) {
d1280 7
a1286 2
	newname = strtok(NULL, " ");
	if (newname == NULL) {
d1291 6
a1296 1
	if (exptilde(expbuf, oldname) == NULL) {
a1299 1
	oldname = expbuf;
d1324 1
a1324 1
	if (link(oldname, target) < 0) {
d1339 2
a1340 2
static void setconfig(cmd)
	char *cmd;
d1352 1
a1352 1
			message(MT_SYSLOG, "startup for %s",  fromhost);
d1360 1
a1360 1
		if (!isdigit(*cp)) {
d1368 1
a1368 1
		if (!isdigit(*cp)) {
d1376 2
a1377 2
		if ((estr = msgparseopts(cp, TRUE))) {
			fatalerr("Bad message option string (%s): %s", 
d1383 8
d1400 2
a1401 3
static void recvit(cmd, type)
	char *cmd;
	int type;
d1409 1
d1477 1
a1477 1
	 * Get file name.  Can't use strtok() since there could
d1480 6
a1485 2
	file = group + strlen(group) + 1;
	if (file == NULL) {
d1489 1
d1499 1
a1499 1
		if (catname >= sizeof(sptarget)) {
d1506 2
a1507 2
			while ((*ptarget++ = *file++))
			    ;
d1520 1
a1520 1
			(void) strcpy(new, tempname);
d1522 1
a1522 1
			(void) sprintf(new, "/%s", tempname);
d1525 2
a1526 1
			(void) sprintf(new, "%s/%s", target, tempname);
d1529 8
a1536 1
		(void) mktemp(new);
d1554 1
a1554 1
		if (min_freespace && (freespace >= 0) && 
d1593 79
d1674 2
a1675 3
static void settarget(cmd, isdir)
	char *cmd;
	int isdir;
d1679 1
d1693 5
d1701 1
a1701 1
	if (exptilde(target, cp) == NULL)
d1713 2
a1714 1
extern void cleanup()
d1722 2
a1723 1
extern void server()
d1730 1
a1730 2
	if (setjmp(finish_jmpbuf)) {
		setjmp_ok = FALSE;
a1731 2
	}
        setjmp_ok = TRUE;
d1738 1
a1738 1
	(void) strcpy(tempname, _RDIST_TMP);
d1746 1
a1746 1
	/* 
a1751 1
		setjmp_ok = FALSE;
d1756 1
a1756 2
	if (cmdbuf[0] != S_VERSION || !isdigit(cmdbuf[1])) {
		setjmp_ok = FALSE;
a1762 1
		setjmp_ok = FALSE;
d1775 1
a1775 2
		if (n == -1) {		/* EOF */
			setjmp_ok = FALSE;
a1776 1
		}
d1839 2
a1840 3
#ifdef DOCHMOD
	        case C_CHMOD:  		/* Set mode */
			dochmod(cp);
a1841 1
#endif /* DOCHMOD */
a1850 1
			setjmp_ok = FALSE;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.11 2003/04/05 20:31:58 deraadt Exp $	*/
d41 1
a41 1
"$OpenBSD: server.c,v 1.11 2003/04/05 20:31:58 deraadt Exp $";
d224 1
a224 1
				strlcpy(last_owner, owner, sizeof last_owner);
d256 1
a256 1
			strlcpy(last_group, gr->gr_name, sizeof last_group);
d531 1
a531 1
				(void) snprintf(env, len, "export %s;%s=%s", 
d536 1
a536 1
				    len + strlen(cp) + 2);
d713 1
a713 1
	(void) snprintf(savefile, sizeof savefile, "%s%s", file, SAVE_SUFFIX);
d1048 1
a1048 2
						(void) strlcpy(lowner, cp,
						    sizeof lowner);
d1057 1
a1057 2
						(void) strlcpy(lgroup, cp,
						    sizeof lgroup);
d1068 1
a1068 2
					(void) strlcpy(lowner, cp,
					    sizeof lowner);
d1072 1
a1072 2
					(void) strlcpy(lgroup, cp,
					    sizeof lgroup);
d1472 1
a1472 1
			(void) strlcpy(new, tempname, sizeof new);
d1474 1
a1474 1
			(void) snprintf(new, sizeof new, "/%s", tempname);
d1477 1
a1477 1
			(void) snprintf(new, sizeof new, "%s/%s", target, tempname);
d1599 1
a1599 1
	(void) strlcpy(tempname, _RDIST_TMP, sizeof tempname);
@


1.1.1.3
log
@Import OpenBSD source with the "new" command line as well,
in order to be able to provide a MirBSD release which bases
upon a fairly current OpenBSD base source code tree deemed
stable enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.12 2003/04/10 22:42:29 millert Exp $	*/
d41 1
a41 1
"$OpenBSD: server.c,v 1.12 2003/04/10 22:42:29 millert Exp $";
d113 1
a113 1
			message(MT_NOTICE, "%s: chown %d:%d failed: %s", 
d1080 1
a1080 1
				"%s: need to chown from %s:%s to %s:%s",
d1088 1
a1088 1
					       "%s: chown from %s:%s to %s:%s",
@


1.1.1.4
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.13 2003/04/19 17:22:30 millert Exp $	*/
d41 1
a41 1
"$OpenBSD: server.c,v 1.13 2003/04/19 17:22:30 millert Exp $";
d83 1
a83 2
	(void) snprintf(ptarget, target + sizeof(target) - ptarget,
	    "/%s", string);
d514 1
a514 1
	size_t len;
d534 6
a539 4
				len = strlen(env) + 1 + strlen(cp) + 1;
				env = (char *) xrealloc(env, len);
				(void) strlcat(env, ":", len);
				(void) strlcat(env, cp, len);
d546 6
a551 4
				len = strlen(env) + 1 + strlen(cp) + 1;
				env = (char *) xrealloc(env, len);
				(void) strlcat(env, ";", len);
				(void) strlcat(env, cp, len);
d1264 1
a1264 1
	if (exptilde(expbuf, oldname, sizeof(expbuf)) == NULL) {
d1565 1
a1565 1
	if (exptilde(target, cp, sizeof(target)) == NULL)
@


1.1.1.5
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.14 2003/05/14 01:34:35 millert Exp $	*/
a34 2
#include "defs.h"

d37 2
a38 2
static char RCSid[] __attribute__((__unused__)) =
"$From: server.c,v 1.10 1999/08/04 15:57:33 christos Exp $";
d40 2
a41 2
static char RCSid[] __attribute__((__unused__)) =
"$OpenBSD: server.c,v 1.14 2003/05/14 01:34:35 millert Exp $";
d44 1
a44 2
static char sccsid[] __attribute__((__unused__)) =
"@@(#)server.c	5.3 (Berkeley) 6/7/86";
d46 1
a46 1
static char copyright[] __attribute__((__unused__)) =
d55 2
a67 21
static int cattarget(char *);
static int setownership(char *, int, UID_T, GID_T, int);
static int setfilemode(char *, int, int, int);
static int fchog(int, char *, char *, char *, int);
static int removefile(struct stat *, int);
static void doclean(char *);
static void clean(char *);
static void dospecial(char *);
static void docmdspecial(void);
static void query(char *);
static int chkparent(char *, opt_t);
static char *savetarget(char *, opt_t);
static void recvfile(char *, opt_t, int, char *, char *, time_t, time_t, off_t);
static void recvdir(opt_t, int, char *, char *);
static void recvlink(char *, opt_t, int, off_t);
static void hardlink(char *);
static void setconfig(char *);
static void recvit(char *, int);
static void dochmog(char *);
static void settarget(char *, int);

d71 2
a72 2
static int
cattarget(char *string)
d83 2
a84 2
	(void) snprintf(ptarget, sizeof(target) - (ptarget - target),
			"/%s", string);
d92 5
a96 2
static int
setownership(char *file, int fd, UID_T uid, GID_T gid, int link)
d103 5
a107 14
	if (getuid() != 0) 
		uid = -1;

	/*
	 * If we are dealing with a symlink, only try to change it if
	 * we have lchown, if we don't leave it alone.
	 */
#if	defined(HAVE_LCHOWN)
	if (link)
		status = lchown(file, (CHOWN_UID_T) uid, 
				(CHOWN_GID_T) gid);
#else
	if (link)
		return 0;
d109 10
a118 1

d120 3
a122 3
	if (fd != -1 && !link)
		status = fchown(fd, (CHOWN_UID_T) uid, 
				(CHOWN_GID_T) gid);
d124 3
a126 3
	if (status < 0 && !link)
		status = chown(file, (CHOWN_UID_T) uid, 
			       (CHOWN_GID_T) gid);
d128 1
a128 2
	if (status < 0) {
		if (uid == (UID_T) -1)
d130 3
a132 5
				target, gid, SYSERR);
		else
			message(MT_NOTICE, "%s: chown %d.%d failed: %s", 
				target, uid, gid, SYSERR);
		return(-1);
d141 4
a144 2
static int
setfilemode(char *file, int fd, int mode, int link)
a150 12
	/*
	 * If we are dealing with a symlink, only try to change it if
	 * we have lchown, if we don't leave it alone.
	 */
#if	defined(HAVE_LCHMOD)
	if (link)
		status = lchmod(file, mode);
#else
	if (link)
		return 0;
#endif

d152 1
a152 1
	if (fd != -1 && !link)
d156 1
a156 1
	if (status < 0 && !link)
d166 19
d188 4
a191 2
static int
fchog(int fd, char *file, char *owner, char *group, int mode)
d193 6
a198 1
	static struct group *gr = NULL;
a200 1
	struct stat st;
d209 2
a210 1
		} else if (pw == NULL || strcmp(owner, pw->pw_name) != 0) {
d222 5
a226 2
			} else
				uid = pw->pw_uid;
d228 2
a229 2
			uid = pw->pw_uid;
			primegid = pw->pw_gid;
d251 8
a258 4
	if (gr == NULL || strcmp(group, gr->gr_name) != 0) {
		if ((*group == ':' && 
		     (getgrgid(gid = atoi(group + 1)) == NULL))
		    || ((gr = (struct group *)getgrnam(group)) == NULL)) {
d268 7
a274 4
		} else
			gid = gr->gr_gid;
	} else
		gid = gr->gr_gid;
d276 4
d281 2
d285 1
a285 1
				if (strcmp(locuser, gr->gr_mem[i]) == 0)
a295 4
	if (stat(file, &st) == -1) {
		error("%s: Stat failed %s", file, SYSERR);
		return -1;
	}
d301 1
a301 1
	if (setownership(file, fd, uid, gid, S_ISLNK(st.st_mode)) < 0) {
d313 1
a313 1
	(void) setfilemode(file, fd, mode, S_ISLNK(st.st_mode));
d323 2
a324 2
static int
removefile(struct stat *statb, int silent)
a335 8
	case S_IFCHR:
	case S_IFBLK:
#ifdef S_IFSOCK
	case S_IFSOCK:
#endif
#ifdef S_IFIFO
	case S_IFIFO:
#endif
d338 3
a340 4
				if (!silent)
					message(MT_REMOTE|MT_NOTICE, 
						"%s: unlink failed: %s",
						target, SYSERR);
d365 1
a365 1
	while ((dp = readdir(d)) != NULL) {
d372 2
a373 4
			if (!silent)
				message(MT_REMOTE|MT_WARNING, 
					"%s/%s: Name too long", 
					target, dp->d_name);
d379 2
a380 2
		while ((*ptarget++ = *cp++) != '\0')
			continue;
d383 2
a384 4
			if (!silent)
				message(MT_REMOTE|MT_WARNING,
					"%s: lstat failed: %s", 
					target, SYSERR);
d387 1
a387 1
		if (removefile(&stb, 0) < 0)
a401 4
#if NEWWAY
	if (!silent)
		message(MT_CHANGE|MT_REMOTE, "%s: removed", target);
#else
a408 1
#endif
d416 2
a417 2
static void
doclean(char *cp)
a424 1
	char targ[MAXPATHLEN*4];
d439 1
a439 1
	while ((dp = readdir(d)) != NULL) {
d453 2
a454 2
		while ((*ptarget++ = *cp++) != '\0')
			continue;
d462 1
a462 2
		ENCODE(targ, dp->d_name);
		(void) sendcmd(CC_QUERY, "%s", targ);
d472 1
a472 1
			(void) removefile(&stb, 0);
d483 2
a484 2
static void
clean(char *cp)
d496 2
a497 2
static void
dospecial(char *xcmd)
a498 5
	char cmd[BUFSIZ];
	if (DECODE(cmd, xcmd) == -1) {
		error("dospecial: Cannot decode command.");
		return;
	}
d510 1
a510 2
static void
docmdspecial(void)
d579 2
a580 2
static void
query(char *xname)
a583 6
	char name[MAXPATHLEN];

	if (DECODE(name, xname) == -1) {
		error("query: Cannot decode filename");
		return;
	}
a643 10
#ifdef notyet
	case S_IFCHR:
	case S_IFBLK:
#ifdef S_IFSOCK
	case S_IFSOCK:
#endif
#ifdef S_IFIFO
	case S_IFIFO:
#endif
#endif
d645 2
a646 1
			       (long) stb.st_size, stb.st_mtime,
d662 3
a664 2
static int
chkparent(char *name, opt_t opts)
d700 2
a701 2
static char *
savetarget(char *file, opt_t opts)
d710 1
a710 12
	if (IS_ON(opts, DO_HISTORY)) {
		int i;
		struct stat st;
		/*
		 * There is a race here, but the worst that can happen
		 * is to lose a version of the file
		 */
		for (i = 1; i < 1000; i++) {
			(void) snprintf(savefile, sizeof(savefile),
					"%s;%.3d", file, i);
			if (stat(savefile, &st) == -1 && errno == ENOENT)
				break;
d712 3
a714 19
		}
		if (i == 1000) {
			message(MT_NOTICE, 
			    "%s: More than 1000 versions for %s; reusing 1\n",
				savefile, SYSERR);
			i = 1;
			(void) snprintf(savefile, sizeof(savefile),
					"%s;%.3d", file, i);
		}
	}
	else {
		(void) snprintf(savefile, sizeof(savefile), "%s%s",
				file, SAVE_SUFFIX);

		if (unlink(savefile) != 0 && errno != ENOENT) {
			message(MT_NOTICE, "%s: remove failed: %s",
				savefile, SYSERR);
			return(NULL);
		}
d727 18
d747 9
a755 3
static void
recvfile(char *new, opt_t opts, int mode, char *owner, char *group,
	 time_t mtime, time_t atime, off_t size)
d757 1
a757 1
	int f, wrerr, olderrno;
d804 25
a828 1
		if (wrerr == 0 && xwrite(f, buf, amt) != amt) {
a863 1
			(void) fclose(f1);
d919 1
a919 1
		if ((savefile = savetarget(target, opts)) == NULL) {
d932 1
a932 1
		removefile(&statbuff, 0);
a939 2
		static char fmt[] = "%s -> %s: rename failed: %s";
		struct stat stb;
d944 1
a944 2
		switch (errno) {
		case ETXTBSY:
d946 1
a946 1
			if ((savefile = savetarget(target, opts)) != NULL) {
d949 2
a950 1
					error(fmt, new, target, SYSERR);
d953 4
a956 3
						error(fmt,
						      savefile, target, SYSERR);
					(void) unlink(new);
a959 5
				/*
				 * XXX: We should remove the savefile here.
				 *	But we are nice to nfs clients and
				 *	we keep it.
				 */
d961 3
a963 22
			break;
		case EISDIR:
			/*
			 * See if target is a directory and remove it if it is
			 */
			if (lstat(target, &stb) == 0) {
				if (S_ISDIR(stb.st_mode)) {
					char *optarget = ptarget;
					for (ptarget = target; *ptarget;
						ptarget++);
					/* If we failed to remove, we'll catch
					   it later */
					(void) removefile(&stb, 1);
					ptarget = optarget;
				}
			}
			if (rename(new, target) >= 0)
				break;
			/*FALLTHROUGH*/

		default:
			error(fmt, new, target, SYSERR);
a964 1
			break;
d968 3
d980 4
a983 2
static void
recvdir(opt_t opts, int mode, char *owner, char *group)
d1043 1
a1043 2
				if ((cp = getusername(stb.st_uid, target, o))
				    != NULL)
d1046 1
a1046 1
						    sizeof(lowner));
d1053 1
a1053 2
				if ((cp = getgroupname(stb.st_gid, target, o))
				    != NULL)
d1056 1
a1056 1
						    sizeof(lgroup));
d1068 1
a1068 1
					    sizeof(lowner));
d1073 1
a1073 1
					    sizeof(lgroup));
d1131 5
a1135 2
static void
recvlink(char *new, opt_t opts, int mode, off_t size)
a1136 1
	char tbuf[MAXPATHLEN];
a1138 1
	int uptodate;
a1151 21
	uptodate = 0;
	if ((i = readlink(target, tbuf, sizeof(tbuf))) != -1) {
		tbuf[i] = '\0';
		if (i == size && strncmp(buf, tbuf, (int) size) == 0)
			uptodate = 1;
	}
	mode &= 0777;

	if (IS_ON(opts, DO_VERIFY) || uptodate) {
		if (uptodate)
			message(MT_REMOTE|MT_INFO, "");
		else
			message(MT_REMOTE|MT_INFO, "%s: need to update",
				target);
		if (IS_ON(opts, DO_COMPARE))
			return;
		(void) sendcmd(C_END, NULL);
		(void) response();
		return;
	}

d1165 24
d1195 1
a1195 1
			if (removefile(&stb, 0) < 0) {
d1218 4
a1221 1
	message(MT_REMOTE|MT_CHANGE, "%s: updated", target);
d1233 2
a1234 2
static void
hardlink(char *cmd)
d1238 1
a1238 1
	char *xoldname, *xnewname;
a1240 1
	char oldname[BUFSIZ], newname[BUFSIZ];
d1249 2
a1250 2
	xoldname = strtok(cp, " ");
	if (xoldname == NULL) {
d1255 2
a1256 7
	if (DECODE(oldname, xoldname) == -1) {
		error("hardlink: Cannot decode oldname");
		return;
	}

	xnewname = strtok(NULL, " ");
	if (xnewname == NULL) {
a1260 5
	if (DECODE(newname, xnewname) == -1) {
		error("hardlink: Cannot decode newname");
		return;
	}

d1265 1
d1290 1
a1290 1
	if (link(expbuf, target) < 0) {
d1305 2
a1306 2
static void
setconfig(char *cmd)
d1318 1
a1318 1
			message(MT_SYSLOG, "startup for %s", fromhost);
d1326 1
a1326 1
		if (!isdigit((unsigned char)*cp)) {
d1334 1
a1334 1
		if (!isdigit((unsigned char)*cp)) {
d1342 1
a1342 1
		if ((estr = msgparseopts(cp, TRUE)) != NULL) {
a1348 8
	case SC_DEFOWNER:
		(void) strlcpy(defowner, cp, sizeof(defowner));
		break;

	case SC_DEFGROUP:
		(void) strlcpy(defgroup, cp, sizeof(defgroup));
		break;

d1358 3
a1360 2
static void
recvit(char *cmd, int type)
a1367 1
	char fileb[MAXPATHLEN];
d1435 1
a1435 1
	 * Get file name. Can't use strtok() since there could
d1438 2
a1439 6
	if (DECODE(fileb, group + strlen(group) + 1) == -1) {
		error("recvit: Cannot decode file name");
		return;
	}

	if (fileb[0] == '\0') {
a1442 1
	file = fileb;
d1452 1
a1452 1
		if ((size_t) catname >= sizeof(sptarget)) {
d1459 2
a1460 2
			while ((*ptarget++ = *file++) != '\0')
			    continue;
d1473 1
a1473 1
			(void) strlcpy(new, tempname, sizeof(new));
d1475 1
a1475 1
			(void) snprintf(new, sizeof(new), "/%s", tempname);
d1478 1
a1478 2
			(void) snprintf(new, sizeof(new), "%s/%s", target,
					tempname);
a1537 79
 * Chmog something
 */
static void
dochmog(char *cmd)
{
	int mode;
	opt_t opts;
	char *owner, *group, *file;
	char *cp = cmd;
	char fileb[MAXPATHLEN];

	/*
	 * Get rdist option flags
	 */
	opts = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("dochmog: options not delimited");
		return;
	}

	/*
	 * Get file mode
	 */
	mode = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("dochmog: mode not delimited");
		return;
	}

	/*
	 * Get file owner name
	 */
	owner = strtok(cp, " ");
	if (owner == NULL) {
		error("dochmog: owner name not delimited");
		return;
	}

	/*
	 * Get file group name
	 */
	group = strtok(NULL, " ");
	if (group == NULL) {
		error("dochmog: group name not delimited");
		return;
	}

	/*
	 * Get file name. Can't use strtok() since there could
	 * be white space in the file name.
	 */
	if (DECODE(fileb, group + strlen(group) + 1) == -1) {
		error("dochmog: Cannot decode file name");
		return;
	}

	if (fileb[0] == '\0') {
		error("dochmog: no file name");
		return;
	}
	file = fileb;

	debugmsg(DM_MISC,
		 "dochmog: opts = %04o mode = %04o", opts, mode);
	debugmsg(DM_MISC,
	         "dochmog: owner = '%s' group = '%s' file = '%s' catname = %d",
		 owner, group, file, catname);

	if (catname && cattarget(file) < 0) {
		error("Cannot set newname target.");
		return;
	}

	(void) fchog(-1, target, owner, group, mode);

	ack();
}

/*
d1540 3
a1542 2
static void
settarget(char *cmd, int isdir)
a1545 1
	char file[BUFSIZ];
a1558 5
	if (DECODE(file, cp) == -1) {
		error("settarget: Cannot decode target name");
		return;
	}

d1574 1
a1574 2
void
cleanup(int dummy)
d1582 1
a1582 2
void
server(void)
d1589 2
a1590 1
	if (setjmp(finish_jmpbuf))
d1592 2
d1600 1
a1600 1
	(void) strlcpy(tempname, _RDIST_TMP, sizeof(tempname));
d1614 1
d1619 2
a1620 1
	if (cmdbuf[0] != S_VERSION || !isdigit((unsigned char)cmdbuf[1])) {
d1627 1
d1640 2
a1641 1
		if (n == -1)		/* EOF */
d1643 1
d1706 3
a1708 2
	        case C_CHMOG:  		/* Set owner, group, mode */
			dochmog(cp);
d1710 1
d1720 1
@


1.1.1.6
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.15 2003/06/03 02:56:15 millert Exp $	*/
d15 5
a19 1
 * 3. Neither the name of the University nor the names of its contributors
d43 1
a43 1
"$OpenBSD: server.c,v 1.15 2003/06/03 02:56:15 millert Exp $";
@


1.1.1.7
log
@Bring the entire base system and ports tree in sync with OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.16 2003/07/07 14:39:26 mpech Exp $	*/
d39 1
a39 1
"$OpenBSD: server.c,v 1.16 2003/07/07 14:39:26 mpech Exp $";
d1185 1
a1185 1
	if ((i = readlink(target, tbuf, sizeof(tbuf)-1)) != -1) {
@


