head	1.5;
access;
symbols
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	tg-mergetmp-3:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.4
	cvs-200401271800:1.1.1.3
	cvs-200401261630:1.1.1.3
	cvs-200401021645:1.1.1.3
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.3
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.3
	cvs-200309271030:1.1.1.3
	cvs-200309251530:1.1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.3
	ctm-3449:1.1.1.3
	ctm-3437:1.1.1.3
	cvs-200307191805:1.1.1.3
	ctm-3425:1.1.1.3
	cvs-200307091500:1.1.1.3
	ctm-3389:1.1.1.3
	cvs-200306291430:1.1.1.3
	ctm-3341:1.1.1.3
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.07.27.21.08.35;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.05.23.18.46.34;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.01.16.10.33;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.01.15.56.45;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.53.03;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.53.03;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.54.58;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.43.34;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.16.08.09.20;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@almost better infrastructure for building MirMake on
tg@@linuxsys:/services/homes/tg $ uname -a
Linux LinuxSys.de 2.6.4 #1 Sat Mar 20 01:04:34 CET 2004 i686 GNU/Linux

I think my .if/.else/.endif replacement is "good enough" to
even work on very old makes (seen at FSF makefiles for ancient
systems)
@
text
@/* $MirBSD: src/usr.bin/make/arch.c,v 1.4 2004/05/23 18:46:34 tg Exp $	*/
/* $OpenPackages$ */
/* $OpenBSD: arch.c,v 1.54 2004/04/07 13:11:35 espie Exp $ */
/* $NetBSD: arch.c,v 1.17 1996/11/06 17:58:59 christos Exp $	*/

/*
 * Copyright (c) 1999,2000 Marc Espie.
 *
 * Extensive code changes for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 *	Once again, cacheing/hashing comes into play in the manipulation
 * of archives. The first time an archive is referenced, all of its members'
 * headers are read and hashed and the archive closed again. All hashed
 * archives are kept in a hash (archives) which is searched each time
 * an archive member is referenced.
 *
 */

#include <sys/param.h>
#include <sys/types.h>
#include <ar.h>
#include <assert.h>
#include <ctype.h>
#include <fcntl.h>
#include <limits.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "ohash.h"
#include "config.h"
#include "defines.h"
#include "dir.h"
#include "arch.h"
#include "var.h"
#include "targ.h"
#include "memory.h"
#include "gnode.h"
#include "timestamp.h"
#include "lst.h"

#ifndef PATH_MAX
# ifdef MAXPATHLEN
#  define PATH_MAX (MAXPATHLEN+1)
# else
#  define PATH_MAX	1024
# endif
#endif

#ifdef TARGET_MACHINE
#undef MACHINE
#define MACHINE TARGET_MACHINE
#endif
#ifdef TARGET_MACHINE_ARCH
#undef MACHINE_ARCH
#define MACHINE_ARCH TARGET_MACHINE_ARCH
#endif

__RCSID("$MirBSD$");

static struct ohash	  archives;   /* Archives we've already examined.  */

typedef struct Arch_ {
    struct ohash   members;    /* All the members of this archive, as
			       * struct arch_member entries.  */
    char	  name[1];    /* Archive name.	*/
} Arch;

/* Used to get to ar's field sizes.  */
static struct ar_hdr *dummy;
#define AR_NAME_SIZE		(sizeof(dummy->ar_name))
#define AR_DATE_SIZE		(sizeof(dummy->ar_date))

/* Each archive member is tied to an arch_member structure,
 * suitable for hashing.  */
struct arch_member {
    TIMESTAMP	  mtime;	/* Member modification date.  */
    char	  date[AR_DATE_SIZE+1];
				/* Same, before conversion to numeric value.  */
    char	  name[1];	/* Member name.  */
};

static struct ohash_info members_info = {
    offsetof(struct arch_member, name), NULL,
    hash_alloc, hash_free, element_alloc
};

static struct ohash_info arch_info = {
    offsetof(Arch, name), NULL, hash_alloc, hash_free, element_alloc
};



static struct arch_member *new_arch_member(struct ar_hdr *, const char *);
static TIMESTAMP mtime_of_member(struct arch_member *);
static long field2long(const char *, size_t);
static Arch *read_archive(const char *, const char *);

#ifdef CLEANUP
static void ArchFree(Arch *);
#endif
static TIMESTAMP ArchMTimeMember(const char *, const char *, bool);
static FILE *ArchFindMember(const char *, const char *, struct ar_hdr *, const char *);
static void ArchTouch(const char *, const char *);
#if defined(__svr4__) || defined(__SVR4) || \
    (defined(__Linux__) && defined(__ELF__)) || \
    (defined(__OpenBSD__) && defined(__ELF__))
#define SVR4ARCHIVES
#endif

#ifdef SVR4ARCHIVES
struct SVR4namelist {
    char	  *fnametab;  /* Extended name table strings */
    size_t	  fnamesize;  /* Size of the string table */
};

static const char *svr4list = "Archive list";

static char *ArchSVR4Entry(struct SVR4namelist *, const char *, size_t, FILE *);
#endif

static struct arch_member *
new_arch_member(struct ar_hdr *hdr, const char *name)
{
    const char *end = NULL;
    struct arch_member *n;

    n = ohash_create_entry(&members_info, name, &end);
    /* XXX ar entries are NOT null terminated.	*/
    memcpy(n->date, &(hdr->ar_date), AR_DATE_SIZE);
    n->date[AR_DATE_SIZE] = '\0';
    /* Don't compute mtime before it is needed. */
    ts_set_out_of_date(n->mtime);
    return n;
}

static TIMESTAMP
mtime_of_member(struct arch_member *m)
{
    if (is_out_of_date(m->mtime))
	ts_set_from_time_t((time_t) strtol(m->date, NULL, 10), m->mtime);
    return m->mtime;
}

#ifdef CLEANUP
/*-
 *-----------------------------------------------------------------------
 * ArchFree --
 *	Free memory used by an archive
 *-----------------------------------------------------------------------
 */
static void
ArchFree(Arch *a)
{
    struct arch_member *mem;
    unsigned int i;

    /* Free memory from hash entries */
    for (mem = ohash_first(&a->members, &i); mem != NULL;
	mem = ohash_next(&a->members, &i))
	free(mem);

    ohash_delete(&a->members);
    free(a);
}
#endif



/* Side-effects: Some nodes may be created.  */
bool
Arch_ParseArchive(char **linePtr,   /* Pointer to start of specification */
    Lst nodeLst, 		    /* Lst on which to place the nodes */
    SymTable *ctxt)		    /* Context in which to expand variables */
{
    char	    *cp;	    /* Pointer into line */
    GNode	    *gn;	    /* New node */
    char	    *libName;	    /* Library-part of specification */
    char	    *memberName;    /* Member-part of specification */
    char	    nameBuf[MAKE_BSIZE]; /* temporary place for node name */
    char	    saveChar;	    /* Ending delimiter of member-name */
    bool	    subLibName;     /* true if libName should have/had
				     * variable substitution performed on it */

    libName = *linePtr;

    subLibName = false;

    for (cp = libName; *cp != '(' && *cp != '\0';) {
	if (*cp == '$') {
	    bool ok;

	    cp += Var_ParseSkip(cp, ctxt, &ok);
	    if (ok == false)
		return false;
	    subLibName = true;
	} else
	    cp++;
    }

    *cp++ = '\0';
    if (subLibName)
	libName = Var_Subst(libName, ctxt, true);

    for (;;) {
	/* First skip to the start of the member's name, mark that
	 * place and skip to the end of it (either white-space or
	 * a close paren).  */
	bool doSubst = false; /* true if need to substitute in memberName */

	while (*cp != '\0' && *cp != ')' && isspace(*cp))
	    cp++;
	memberName = cp;
	while (*cp != '\0' && *cp != ')' && !isspace(*cp)) {
	    if (*cp == '$') {
		bool ok;
		cp += Var_ParseSkip(cp, ctxt, &ok);
		if (ok == false)
		    return false;
		doSubst = true;
	    } else
		cp++;
	}

	/* If the specification ends without a closing parenthesis,
	 * chances are there's something wrong (like a missing backslash),
	 * so it's better to return failure than allow such things to
	 * happen.  */
	if (*cp == '\0') {
	    printf("No closing parenthesis in archive specification\n");
	    return false;
	}

	/* If we didn't move anywhere, we must be done.  */
	if (cp == memberName)
	    break;

	saveChar = *cp;
	*cp = '\0';

	/* XXX: This should be taken care of intelligently by
	 * SuffExpandChildren, both for the archive and the member portions.  */

	/* If member contains variables, try and substitute for them.
	 * This will slow down archive specs with dynamic sources, of course,
	 * since we'll be (non-)substituting them three times, but them's
	 * the breaks -- we need to do this since SuffExpandChildren calls
	 * us, otherwise we could assume the thing would be taken care of
	 * later.  */
	if (doSubst) {
	    char    *buf;
	    char    *sacrifice;
	    char    *oldMemberName = memberName;
	    size_t  length;

	    memberName = Var_Subst(memberName, ctxt, true);

	    /* Now form an archive spec and recurse to deal with nested
	     * variables and multi-word variable values.... The results
	     * are just placed at the end of the nodeLst we're returning.  */
	    length = strlen(memberName)+strlen(libName)+3;
	    buf = sacrifice = emalloc(length);

	    snprintf(buf, length, "%s(%s)", libName, memberName);

	    if (strchr(memberName, '$') &&
	    	strcmp(memberName, oldMemberName) == 0) {
		/* Must contain dynamic sources, so we can't deal with it now.
		 * Just create an ARCHV node for the thing and let
		 * SuffExpandChildren handle it...  */
		gn = Targ_FindNode(buf, TARG_CREATE);

		if (gn == NULL) {
		    free(buf);
		    return false;
		} else {
		    gn->type |= OP_ARCHV;
		    Lst_AtEnd(nodeLst, gn);
		}
	    } else if (!Arch_ParseArchive(&sacrifice, nodeLst, ctxt)) {
		/* Error in nested call -- free buffer and return false
		 * ourselves.  */
		free(buf);
		return false;
	    }
	    /* Free buffer and continue with our work.	*/
	    free(buf);
	} else if (Dir_HasWildcards(memberName)) {
	    LIST  members;
	    char  *member;

	    Lst_Init(&members);

	    Dir_Expand(memberName, dirSearchPath, &members);
	    while ((member = (char *)Lst_DeQueue(&members)) != NULL) {
		snprintf(nameBuf, MAKE_BSIZE, "%s(%s)", libName, member);
		free(member);
		gn = Targ_FindNode(nameBuf, TARG_CREATE);
		/* We've found the node, but have to make sure the rest of
		 * the world knows it's an archive member, without having
		 * to constantly check for parentheses, so we type the
		 * thing with the OP_ARCHV bit before we place it on the
		 * end of the provided list.  */
		gn->type |= OP_ARCHV;
		Lst_AtEnd(nodeLst, gn);
	    }
	} else {
	    snprintf(nameBuf, MAKE_BSIZE, "%s(%s)", libName, memberName);
	    gn = Targ_FindNode(nameBuf, TARG_CREATE);
	    /* We've found the node, but have to make sure the rest of the
	     * world knows it's an archive member, without having to
	     * constantly check for parentheses, so we type the thing with
	     * the OP_ARCHV bit before we place it on the end of the
	     * provided list.  */
	    gn->type |= OP_ARCHV;
	    Lst_AtEnd(nodeLst, gn);
	}
	if (doSubst)
	    free(memberName);

	*cp = saveChar;
    }

    /* If substituted libName, free it now, since we need it no longer.  */
    if (subLibName)
	free(libName);

    /* We promised the pointer would be set up at the next non-space, so
     * we must advance cp there before setting *linePtr... (note that on
     * entrance to the loop, cp is guaranteed to point at a ')') */
    do {
	cp++;
    } while (*cp != '\0' && isspace(*cp));

    *linePtr = cp;
    return true;
}

/* Helper function: ar fields are not null terminated.	*/
static long
field2long(const char *field, size_t length)
{
    static char enough[32];

    assert(length < sizeof(enough));
    memcpy(enough, field, length);
    enough[length] = '\0';
    return strtol(enough, NULL, 10);
}

static Arch *
read_archive(const char *archive, const char *earchive)
{
    FILE *	  arch;       /* Stream to archive */
    char	  magic[SARMAG];
    Arch	  *ar;
#ifdef SVR4ARCHIVES
    struct SVR4namelist list;

    list.fnametab = NULL;
#endif

    /* When we encounter an archive for the first time, we read its
     * whole contents, to place it in the cache.  */
    arch = fopen(archive, "r");
    if (arch == NULL)
	return NULL;

    /* Make sure this is an archive we can handle.  */
    if ((fread(magic, SARMAG, 1, arch) != 1) ||
	(strncmp(magic, ARMAG, SARMAG) != 0)) {
	    fclose(arch);
	    return NULL;
    }

    ar = ohash_create_entry(&arch_info, archive, &earchive);
    ohash_init(&ar->members, 8, &members_info);

    for (;;) {
	size_t		n;
	struct ar_hdr	arHeader;/* Archive-member header for reading archive */
	off_t		size;	/* Size of archive member */
	char		buffer[PATH_MAX];
	char		*memberName;
				/* Current member name while hashing. */
	char		*cp;	/* Useful character pointer */

	memberName = buffer;
	n = fread(&arHeader, 1, sizeof(struct ar_hdr), arch);

	/*  Whole archive read ok.  */
	if (n == 0 && feof(arch)) {
#ifdef SVR4ARCHIVES
	    efree(list.fnametab);
#endif
	    fclose(arch);
	    return ar;
	}
	if (n < sizeof(struct ar_hdr))
	    break;

	if (memcmp(arHeader.ar_fmag, ARFMAG, sizeof(arHeader.ar_fmag)) != 0) {
	    /* The header is bogus.  */
	    break;
	} else {
	    /* We need to advance the stream's pointer to the start of the
	     * next header.  Records are padded with newlines to an even-byte
	     * boundary, so we need to extract the size of the record and
	     * round it up during the seek.  */
	    size = (off_t) field2long(arHeader.ar_size,
	    	sizeof(arHeader.ar_size));

	    (void)memcpy(memberName, arHeader.ar_name, AR_NAME_SIZE);
	    /* Find real end of name (strip extranous ' ')  */
	    for (cp = memberName + AR_NAME_SIZE - 1; *cp == ' ';)
		cp--;
	    cp[1] = '\0';

#ifdef SVR4ARCHIVES
	    /* SVR4 names are slash terminated.  Also svr4 extended AR format.
	     */
	    if (memberName[0] == '/') {
		/* SVR4 magic mode.  */
		memberName = ArchSVR4Entry(&list, memberName, size, arch);
		if (memberName == NULL)		/* Invalid data */
		    break;
		else if (memberName == svr4list)/* List of files entry */
		    continue;
		/* Got the entry.  */
		/* XXX this assumes further processing, such as AR_EFMT1,
		 * also applies to SVR4ARCHIVES.  */
	    }
	    else {
		if (cp[0] == '/')
		    cp[0] = '\0';
	    }
#endif

#ifdef AR_EFMT1
	    /* BSD 4.4 extended AR format: #1/<namelen>, with name as the
	     * first <namelen> bytes of the file.  */
	    if (memcmp(memberName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
		isdigit(memberName[sizeof(AR_EFMT1) - 1])) {

		int elen = atoi(memberName + sizeof(AR_EFMT1)-1);

		if (elen <= 0 || elen >= PATH_MAX)
			break;
		memberName = buffer;
		if (fread(memberName, elen, 1, arch) != 1)
			break;
		memberName[elen] = '\0';
		if (fseek(arch, -elen, SEEK_CUR) != 0)
			break;
		if (DEBUG(ARCH) || DEBUG(MAKE))
		    printf("ArchStat: Extended format entry for %s\n",
		    	memberName);
	    }
#endif

	    ohash_insert(&ar->members,
		ohash_qlookup(&ar->members, memberName),
		    new_arch_member(&arHeader, memberName));
	}
	if (fseek(arch, (size + 1) & ~1, SEEK_CUR) != 0)
	    break;
    }

    fclose(arch);
    ohash_delete(&ar->members);
#ifdef SVR4ARCHIVES
    efree(list.fnametab);
#endif
    free(ar);
    return NULL;
}

/*-
 *-----------------------------------------------------------------------
 * ArchMTimeMember --
 *	Find the modification time of an archive's member, given the
 *	path to the archive and the path to the desired member.
 *
 * Results:
 *	The archive member's modification time, or OUT_OF_DATE if member
 *	was not found (convenient, so that missing members are always
 *	out of date).
 *
 * Side Effects:
 *	Cache the whole archive contents if hash is true.
 *-----------------------------------------------------------------------
 */
static TIMESTAMP
ArchMTimeMember(
    const char	  *archive,   /* Path to the archive */
    const char	  *member,    /* Name of member. If it is a path, only the
			       * last component is used. */
    bool	  hash)       /* true if archive should be hashed if not
			       * already so. */
{
    FILE *	  arch;       /* Stream to archive */
    Arch	  *ar;	      /* Archive descriptor */
    unsigned int  slot;       /* Place of archive in the archives hash */
    const char	  *end = NULL;
    const char	  *cp;
    TIMESTAMP	  result;

    ts_set_out_of_date(result);
    /* Because of space constraints and similar things, files are archived
     * using their final path components, not the entire thing, so we need
     * to point 'member' to the final component, if there is one, to make
     * the comparisons easier...  */
    cp = strrchr(member, '/');
    if (cp != NULL)
	member = cp + 1;

    /* Try to find archive in cache.  */
    slot = ohash_qlookupi(&archives, archive, &end);
    ar = ohash_find(&archives, slot);

    /* If not found, get it now.  */
    if (ar == NULL) {
	if (!hash) {
	    /* Quick path:  no need to hash the whole archive, just use
	     * ArchFindMember to get the member's header and close the stream
	     * again.  */
	    struct ar_hdr	arHeader;

	    arch = ArchFindMember(archive, member, &arHeader, "r");

	    if (arch != NULL) {
		fclose(arch);
		ts_set_from_time_t( (time_t)strtol(arHeader.ar_date, NULL, 10),
		    result);
	    }
	    return result;
	}
	ar = read_archive(archive, end);
	if (ar != NULL)
	    ohash_insert(&archives, slot, ar);
    }

    /* If archive was found, get entry we seek.  */
    if (ar != NULL) {
	struct arch_member *he;
	end = NULL;

	he = ohash_find(&ar->members, ohash_qlookupi(&ar->members, member, &end));
	if (he != NULL)
	    return mtime_of_member(he);
	else {
	    if ((size_t)(end - member) > AR_NAME_SIZE) {
		/* Try truncated name.	*/
		end = member + AR_NAME_SIZE;
		he = ohash_find(&ar->members,
		    ohash_qlookupi(&ar->members, member, &end));
		if (he != NULL)
		    return mtime_of_member(he);
	    }
	}
    }
    return result;
}

#ifdef SVR4ARCHIVES
/*-
 *-----------------------------------------------------------------------
 * ArchSVR4Entry --
 *	Parse an SVR4 style entry that begins with a slash.
 *	If it is "//", then load the table of filenames
 *	If it is "/<offset>", then try to substitute the long file name
 *	from offset of a table previously read.
 *
 * Results:
 *	svr4list: just read a list of names
 *	NULL:	  error occurred
 *	extended name
 *
 * Side-effect:
 *	For a list of names, store the list in l.
 *-----------------------------------------------------------------------
 */

static char *
ArchSVR4Entry(struct SVR4namelist *l, const char *name, size_t size, FILE *arch)
{
#define ARLONGNAMES1 "/"
#define ARLONGNAMES2 "ARFILENAMES"
    size_t entry;
    char *ptr, *eptr;

    assert(name[0] == '/');
    name++;
    /* First comes a table of archive names, to be used by subsequent calls.  */
    if (memcmp(name, ARLONGNAMES1, sizeof(ARLONGNAMES1) - 1) == 0 ||
	memcmp(name, ARLONGNAMES2, sizeof(ARLONGNAMES2) - 1) == 0) {

	if (l->fnametab != NULL) {
	    if (DEBUG(ARCH))
		printf("Attempted to redefine an SVR4 name table\n");
	    return NULL;
	}

	l->fnametab = emalloc(size);
	l->fnamesize = size;

	if (fread(l->fnametab, size, 1, arch) != 1) {
	    if (DEBUG(ARCH))
		printf("Reading an SVR4 name table failed\n");
	    return NULL;
	}

	eptr = l->fnametab + size;
	for (entry = 0, ptr = l->fnametab; ptr < eptr; ptr++)
	    switch (*ptr) {
	    case '/':
		entry++;
		*ptr = '\0';
		break;

	    case '\n':
		break;

	    default:
		break;
	    }
	if (DEBUG(ARCH))
	    printf("Found svr4 archive name table with %lu entries\n",
			(u_long)entry);
	return (char *)svr4list;
    }
    /* Then the names themselves are given as offsets in this table.  */
    if (*name == ' ' || *name == '\0')
	return NULL;

    entry = (size_t) strtol(name, &eptr, 0);
    if ((*eptr != ' ' && *eptr != '\0') || eptr == name) {
	if (DEBUG(ARCH))
	    printf("Could not parse SVR4 name /%s\n", name);
	return NULL;
    }
    if (entry >= l->fnamesize) {
	if (DEBUG(ARCH))
	    printf("SVR4 entry offset /%s is greater than %lu\n",
		   name, (u_long)l->fnamesize);
	return NULL;
    }

    if (DEBUG(ARCH))
	printf("Replaced /%s with %s\n", name, l->fnametab + entry);

    return l->fnametab + entry;
}
#endif


/*-
 *-----------------------------------------------------------------------
 * ArchFindMember --
 *	Locate a member of an archive, given the path of the archive and
 *	the path of the desired member. If the archive is to be modified,
 *	the mode should be "r+", if not, it should be "r".
 *
 * Results:
 *	A FILE *, opened for reading and writing, positioned right after
 *	the member's header, or NULL if the member was nonexistent.
 *
 * Side Effects:
 *	Fill the struct ar_hdr pointed by arHeaderPtr.
 *-----------------------------------------------------------------------
 */
static FILE *
ArchFindMember(
    const char	  *archive,   /* Path to the archive */
    const char	  *member,    /* Name of member. If it is a path, only the
			       * last component is used. */
    struct ar_hdr *arHeaderPtr,/* Pointer to header structure to be filled in */
    const char	  *mode)      /* mode for opening the stream */
{
    FILE *	  arch;       /* Stream to archive */
    char	  *cp;
    char	  magic[SARMAG];
    size_t	  length;
#ifdef SVR4ARCHIVES
    struct SVR4namelist list;

    list.fnametab = NULL;
#endif

    arch = fopen(archive, mode);
    if (arch == NULL)
	return NULL;

    /* Make sure this is an archive we can handle.  */
    if (fread(magic, SARMAG, 1, arch) != 1 ||
	strncmp(magic, ARMAG, SARMAG) != 0) {
	    fclose(arch);
	    return NULL;
    }

    /* Because of space constraints and similar things, files are archived
     * using their final path components, not the entire thing, so we need
     * to point 'member' to the final component, if there is one, to make
     * the comparisons easier...  */
    cp = strrchr(member, '/');
    if (cp != NULL)
	member = cp + 1;

    length = strlen(member);
    if (length >= AR_NAME_SIZE)
	length = AR_NAME_SIZE;

    /* Error handling is simpler than for read_archive, since we just
     * look for a given member.  */
    while (fread(arHeaderPtr, sizeof(struct ar_hdr), 1, arch) == 1) {
	off_t		  size;       /* Size of archive member */
	char		  *memberName;

	if (memcmp(arHeaderPtr->ar_fmag, ARFMAG, sizeof(arHeaderPtr->ar_fmag) )
	    != 0)
	     /* The header is bogus, so the archive is bad.  */
	     break;

	memberName = arHeaderPtr->ar_name;
	if (memcmp(member, memberName, length) == 0) {
	    /* If the member's name doesn't take up the entire 'name' field,
	     * we have to be careful of matching prefixes. Names are space-
	     * padded to the right, so if the character in 'name' at the end
	     * of the matched string is anything but a space, this isn't the
	     * member we sought.  */
#ifdef SVR4ARCHIVES
	    if (length < sizeof(arHeaderPtr->ar_name) &&
	    	memberName[length] == '/')
		length++;
#endif
	    if (length == sizeof(arHeaderPtr->ar_name) ||
		memberName[length] == ' ') {
#ifdef SVR4ARCHIVES
		efree(list.fnametab);
#endif
		return arch;
	    }
	}

	size = (off_t) field2long(arHeaderPtr->ar_size,
	    sizeof(arHeaderPtr->ar_size));

#ifdef SVR4ARCHIVES
	    /* svr4 names are slash terminated. Also svr4 extended AR format.
	     */
	    if (memberName[0] == '/') {
		/* svr4 magic mode.  */
		memberName = ArchSVR4Entry(&list, arHeaderPtr->ar_name, size,
		    arch);
		if (memberName == NULL)		/* Invalid data */
		    break;
		else if (memberName == svr4list)/* List of files entry */
		    continue;
		/* Got the entry.  */
		if (strcmp(memberName, member) == 0) {
		    efree(list.fnametab);
		    return arch;
		}
	    }
#endif

#ifdef AR_EFMT1
	/* BSD 4.4 extended AR format: #1/<namelen>, with name as the
	 * first <namelen> bytes of the file.  */
	if (memcmp(memberName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
	    isdigit(memberName[sizeof(AR_EFMT1) - 1])) {
	    char	  ename[PATH_MAX];

	    int elength = atoi(memberName + sizeof(AR_EFMT1)-1);

	    if (elength <= 0 || elength >= PATH_MAX)
		break;
	    if (fread(ename, elength, 1, arch) != 1)
		break;
	    if (fseek(arch, -elength, SEEK_CUR) != 0)
		break;
	    ename[elength] = '\0';
	    if (DEBUG(ARCH) || DEBUG(MAKE))
		printf("ArchFind: Extended format entry for %s\n", ename);
	    /* Found as extended name.	*/
	    if (strcmp(ename, member) == 0) {
#ifdef SVR4ARCHIVES
		efree(list.fnametab);
#endif
		return arch;
		}
	}
#endif
	/* This isn't the member we're after, so we need to advance the
	 * stream's pointer to the start of the next header.  */
	if (fseek(arch, (size + 1) & ~1, SEEK_CUR) != 0)
	    break;
    }

    /* We did not find the member, or we ran into an error while reading
     * the archive.  */
#ifdef SVRARCHIVES
    efree(list.fnametab);
#endif
    fclose(arch);
    return NULL;
}

static void
ArchTouch(const char *archive, const char *member)
{
    FILE *arch;
    struct ar_hdr arHeader;

    arch = ArchFindMember(archive, member, &arHeader, "r+");
    if (arch != NULL) {
	snprintf(arHeader.ar_date, sizeof(arHeader.ar_date), "%-12ld", (long)
	    timestamp2time_t(now));
	if (fseek(arch, -sizeof(struct ar_hdr), SEEK_CUR) == 0)
	    (void)fwrite(&arHeader, sizeof(struct ar_hdr), 1, arch);
	fclose(arch);
    }
}

/*
 * Side Effects:
 *	The modification time of the entire archive is also changed.
 *	For a library, this could necessitate the re-ranlib'ing of the
 *	whole thing.
 */
void
Arch_Touch(GNode *gn)
{
    ArchTouch(Varq_Value(ARCHIVE_INDEX, gn), Varq_Value(MEMBER_INDEX, gn));
}

/*ARGSUSED*/
void
Arch_TouchLib(GNode *gn UNUSED)
                     /* ^          Non RANLIBMAG does nothing with it */
{
#ifdef RANLIBMAG
    if (gn->path != NULL) {
	ArchTouch(gn->path, RANLIBMAG);
	set_times(gn->path);
    }
#endif
}

TIMESTAMP
Arch_MTime(GNode *gn)
{
    gn->mtime = ArchMTimeMember(Varq_Value(ARCHIVE_INDEX, gn),
	     Varq_Value(MEMBER_INDEX, gn),
	     true);

    return gn->mtime;
}

TIMESTAMP
Arch_MemMTime(GNode *gn)
{
    LstNode	  ln;

    for (ln = Lst_First(&gn->parents); ln != NULL; ln = Lst_Adv(ln)) {
	GNode	*pgn;
	char	*nameStart,
		*nameEnd;

	pgn = (GNode *)Lst_Datum(ln);

	if (pgn->type & OP_ARCHV) {
	    /* If the parent is an archive specification and is being made
	     * and its member's name matches the name of the node we were
	     * given, record the modification time of the parent in the
	     * child. We keep searching its parents in case some other
	     * parent requires this child to exist...  */
	    if ((nameStart = strchr(pgn->name, '(') ) != NULL) {
		nameStart++;
		nameEnd = strchr(nameStart, ')');
	    } else
		nameEnd = NULL;

	    if (pgn->make && nameEnd != NULL &&
		strncmp(nameStart, gn->name, nameEnd - nameStart) == 0 &&
		gn->name[nameEnd-nameStart] == '\0')
		    gn->mtime = Arch_MTime(pgn);
	} else if (pgn->make) {
	    /* Something which isn't a library depends on the existence of
	     * this target, so it needs to exist.  */
	    ts_set_out_of_date(gn->mtime);
	    break;
	}
    }
    return gn->mtime;
}

/* If the system can handle the -L flag when linking (or we cannot find
 * the library), we assume that the user has placed the .LIBRARIES variable
 * in the final linking command (or the linker will know where to find it)
 * and set the TARGET variable for this node to be the node's name. Otherwise,
 * we set the TARGET variable to be the full path of the library,
 * as returned by Dir_FindFile.
 */
void
Arch_FindLib(GNode *gn, Lst path)
{
    char	    *libName;	/* file name for archive */
    size_t	    length = strlen(gn->name) + 6 - 2;

    libName = emalloc(length);
    snprintf(libName, length, "lib%s.a", &gn->name[2]);

    gn->path = Dir_FindFile(libName, path);

    free(libName);

#ifdef LIBRARIES
    Varq_Set(TARGET_INDEX, gn->name, gn);
#else
    Varq_Set(TARGET_INDEX, gn->path == NULL ? gn->name : gn->path, gn);
#endif /* LIBRARIES */
}

/*-
 *-----------------------------------------------------------------------
 * Arch_LibOODate --
 *	Decide if a node with the OP_LIB attribute is out-of-date. Called
 *	from Make_OODate to make its life easier.
 *
 *	There are several ways for a library to be out-of-date that are
 *	not available to ordinary files. In addition, there are ways
 *	that are open to regular files that are not available to
 *	libraries. A library that is only used as a source is never
 *	considered out-of-date by itself. This does not preclude the
 *	library's modification time from making its parent be out-of-date.
 *	A library will be considered out-of-date for any of these reasons,
 *	given that it is a target on a dependency line somewhere:
 *	    Its modification time is less than that of one of its
 *		  sources (gn->mtime < gn->cmtime).
 *	    Its modification time is greater than the time at which the
 *		  make began (i.e. it's been modified in the course
 *		  of the make, probably by archiving).
 *	    The modification time of one of its sources is greater than
 *		  the one of its RANLIBMAG member (i.e. its table of contents
 *		  is out-of-date). We don't compare of the archive time
 *		  vs. TOC time because they can be too close. In my
 *		  opinion we should not bother with the TOC at all since
 *		  this is used by 'ar' rules that affect the data contents
 *		  of the archive, not by ranlib rules, which affect the
 *		  TOC.
 *
 * Results:
 *	true if the library is out-of-date. false otherwise.
 *
 * Side Effects:
 *	The library will be hashed if it hasn't been already.
 *-----------------------------------------------------------------------
 */
bool
Arch_LibOODate(GNode *gn)
{
#ifdef RANLIBMAG
    TIMESTAMP	  modTimeTOC;	/* mod time of __.SYMDEF */
#endif

    if (OP_NOP(gn->type) && Lst_IsEmpty(&gn->children))
	return false;
    if (is_strictly_before(now, gn->mtime) || is_strictly_before(gn->mtime, gn->cmtime) ||
	is_out_of_date(gn->mtime))
	return true;
#ifdef RANLIBMAG
    /* non existent libraries are always out-of-date.  */
    if (gn->path == NULL)
	return true;
    modTimeTOC = ArchMTimeMember(gn->path, RANLIBMAG, false);

    if (!is_out_of_date(modTimeTOC)) {
	if (DEBUG(ARCH) || DEBUG(MAKE))
	    printf("%s modified %s...", RANLIBMAG, Targ_FmtTime(modTimeTOC));
	return is_strictly_before(modTimeTOC, gn->cmtime);
    }
    /* A library w/o a table of contents is out-of-date.  */
    if (DEBUG(ARCH) || DEBUG(MAKE))
	printf("No t.o.c....");
    return true;
#else
    return false;
#endif
}

void
Arch_Init(void)
{
    ohash_init(&archives, 4, &arch_info);
}

#ifdef CLEANUP
void
Arch_End(void)
{
    Arch *e;
    unsigned int i;

    for (e = ohash_first(&archives, &i); e != NULL;
	e = ohash_next(&archives, &i))
	    ArchFree(e);
    ohash_delete(&archives);
}
#endif

bool
Arch_IsLib(GNode *gn)
{
    char buf[SARMAG];
    int fd;

    if (gn->path == NULL || (fd = open(gn->path, O_RDONLY)) == -1)
	return false;

    if (read(fd, buf, SARMAG) != SARMAG) {
	(void)close(fd);
	return false;
    }

    (void)close(fd);

    return memcmp(buf, ARMAG, SARMAG) == 0;
}
@


1.4
log
@* big OpenBSD 3.5-current merge
* adaption of share/doc Makefiles
* revival of the ancient "learn" utility
  XXX possible flaws!
* whitespace, config and comment cleanup in ssh
* add soelim, which was previously missing, and crunch
* add MirOS ELF note support to file
@
text
@d1 4
a4 4
/*	$MirBSD: src/usr.bin/make/arch.c,v 1.3 2003/09/01 16:10:33 tg Exp $	*/
/*	$OpenPackages$ */
/*	$OpenBSD: arch.c,v 1.54 2004/04/07 13:11:35 espie Exp $ */
/*	$NetBSD: arch.c,v 1.17 1996/11/06 17:58:59 christos Exp $	*/
d70 1
a70 1
 * archives are kept in a hash (archives) which is searched each time 
d116 2
d323 1
a323 1
	    if (strchr(memberName, '$') && 
d467 1
a467 1
	    size = (off_t) field2long(arHeader.ar_size, 
d513 1
a513 1
		    printf("ArchStat: Extended format entry for %s\n", 
d590 1
a590 1
		ts_set_from_time_t( (time_t)strtol(arHeader.ar_date, NULL, 10), 
d776 1
a776 1
	if (memcmp(arHeaderPtr->ar_fmag, ARFMAG, sizeof(arHeaderPtr->ar_fmag) ) 
d789 1
a789 1
	    if (length < sizeof(arHeaderPtr->ar_name) && 
d802 1
a802 1
	size = (off_t) field2long(arHeaderPtr->ar_size, 
d810 1
a810 1
		memberName = ArchSVR4Entry(&list, arHeaderPtr->ar_name, size, 
d955 3
a957 3
/* If the system can handle the -L flag when linking (or we cannot find 
 * the library), we assume that the user has placed the .LIBRARIES variable 
 * in the final linking command (or the linker will know where to find it) 
@


1.3
log
@employ MACHINE_OS as make(1) global variable
will be used soon

falls back to:
 -DTARGET_MACHINE_OS in Makefile.boot
 "BSD" #ifdef BSD
 "Linux" #ifdef __Linux__
 "unknown" else
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
d3 1
a3 1
/*	$OpenBSD: arch.c,v 1.53 2003/06/03 02:56:11 millert Exp $ */
d174 1
a174 1
static char *ArchSVR4Entry(struct SVR4namelist *, char *, size_t, FILE *);
d178 1
a178 3
new_arch_member(hdr, name)
    struct ar_hdr *hdr;
    const char *name;
d193 1
a193 2
mtime_of_member(m)
    struct arch_member *m;
d208 1
a208 2
ArchFree(a)
    Arch	  *a;
d227 3
a229 4
Arch_ParseArchive(linePtr, nodeLst, ctxt)
    char	    **linePtr;	    /* Pointer to start of specification */
    Lst 	    nodeLst;	    /* Lst on which to place the nodes */
    SymTable	    *ctxt;	    /* Context in which to expand variables */
d234 1
a234 1
    char	    *memName;	    /* Member-part of specification */
d264 1
a264 1
	bool doSubst = false; /* true if need to substitute in memName */
d268 1
a268 1
	memName = cp;
d290 1
a290 1
	if (cp == memName)
d308 2
a309 2
	    char    *oldMemName = memName;
	    size_t  len;
d311 1
a311 1
	    memName = Var_Subst(memName, ctxt, true);
d316 2
a317 2
	    len = strlen(memName)+strlen(libName)+3;
	    buf = sacrifice = emalloc(len);
d319 1
a319 1
	    snprintf(buf, len, "%s(%s)", libName, memName);
d321 2
a322 1
	    if (strchr(memName, '$') && strcmp(memName, oldMemName) == 0) {
d343 1
a343 1
	} else if (Dir_HasWildcards(memName)) {
d349 1
a349 1
	    Dir_Expand(memName, dirSearchPath, &members);
d363 1
a363 1
	    snprintf(nameBuf, MAKE_BSIZE, "%s(%s)", libName, memName);
d374 1
a374 1
	    free(memName);
d396 1
a396 3
field2long(field, len)
    const char *field;
    size_t len;
d400 3
a402 3
    assert(len < sizeof(enough));
    memcpy(enough, field, len);
    enough[len] = '\0';
d407 1
a407 3
read_archive(archive, end)
    const char *archive;
    const char *end;
d431 1
a431 1
    ar = ohash_create_entry(&arch_info, archive, &end);
d436 1
a436 1
	struct ar_hdr	arh;	/* Archive-member header for reading archive */
d439 1
a439 1
	char		*memName;
d443 2
a444 2
	memName = buffer;
	n = fread(&arh, 1, sizeof(struct ar_hdr), arch);
d457 1
a457 1
	if (memcmp(arh.ar_fmag, ARFMAG, sizeof(arh.ar_fmag)) != 0) {
d465 2
a466 1
	    size = (off_t) field2long(arh.ar_size, sizeof(arh.ar_size));
d468 1
a468 1
	    (void)memcpy(memName, arh.ar_name, AR_NAME_SIZE);
d470 1
a470 1
	    for (cp = memName + AR_NAME_SIZE - 1; *cp == ' ';)
d477 1
a477 1
	    if (memName[0] == '/') {
d479 2
a480 2
		memName = ArchSVR4Entry(&list, memName, size, arch);
		if (memName == NULL)		/* Invalid data */
d482 1
a482 1
		else if (memName == svr4list)	/* List of files entry */
d497 2
a498 2
	    if (memcmp(memName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
		isdigit(memName[sizeof(AR_EFMT1) - 1])) {
d500 1
a500 1
		int elen = atoi(memName + sizeof(AR_EFMT1)-1);
d504 2
a505 2
		memName = buffer;
		if (fread(memName, elen, 1, arch) != 1)
d507 1
a507 1
		memName[elen] = '\0';
d511 2
a512 1
		    printf("ArchStat: Extended format entry for %s\n", memName);
d517 2
a518 2
		ohash_qlookup(&ar->members, memName),
		    new_arch_member(&arh, memName));
d549 3
a551 3
ArchMTimeMember(archive, member, hash)
    const char	  *archive;   /* Path to the archive */
    const char	  *member;    /* Name of member. If it is a path, only the
d553 1
a553 1
    bool	  hash;       /* true if archive should be hashed if not
d582 1
a582 1
	    struct ar_hdr	sarh;
d584 1
a584 1
	    arch = ArchFindMember(archive, member, &sarh, "r");
d588 2
a589 1
		ts_set_from_time_t( (time_t)strtol(sarh.ar_date, NULL, 10), result);
d640 1
a640 5
ArchSVR4Entry(l, name, size, arch)
	struct SVR4namelist *l;
	char *name;
	size_t size;
	FILE *arch;
d724 1
a724 1
 *	Fill the struct ar_hdr pointed by arhPtr.
d728 3
a730 3
ArchFindMember(archive, member, arhPtr, mode)
    const char	  *archive;   /* Path to the archive */
    const char	  *member;    /* Name of member. If it is a path, only the
d732 2
a733 2
    struct ar_hdr *arhPtr;    /* Pointer to header structure to be filled in */
    const char	  *mode;      /* The mode for opening the stream */
d736 1
a736 1
    char	  *cp;	      /* Useful character pointer */
d738 1
a738 1
    size_t	  len;
d764 3
a766 3
    len = strlen(member);
    if (len >= AR_NAME_SIZE)
	len = AR_NAME_SIZE;
d770 1
a770 1
    while (fread(arhPtr, sizeof(struct ar_hdr), 1, arch) == 1) {
d772 1
a772 1
	char		  *memName;
d774 2
a775 1
	if (memcmp(arhPtr->ar_fmag, ARFMAG, sizeof(arhPtr->ar_fmag) ) != 0)
d779 2
a780 2
	memName = arhPtr->ar_name;
	if (memcmp(member, memName, len) == 0) {
d787 3
a789 2
	    if (len < sizeof(arhPtr->ar_name) && memName[len] == '/')
		len++;
d791 2
a792 2
	    if (len == sizeof(arhPtr->ar_name) ||
		memName[len] == ' ') {
d800 2
a801 1
	size = (off_t) field2long(arhPtr->ar_size, sizeof(arhPtr->ar_size));
d806 1
a806 1
	    if (memName[0] == '/') {
d808 3
a810 2
		memName = ArchSVR4Entry(&list, arhPtr->ar_name, size, arch);
		if (memName == NULL)		/* Invalid data */
d812 1
a812 1
		else if (memName == svr4list)	/* List of files entry */
d815 1
a815 1
		if (strcmp(memName, member) == 0) {
d825 2
a826 2
	if (memcmp(memName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
	    isdigit(memName[sizeof(AR_EFMT1) - 1])) {
d829 1
a829 1
	    int elen = atoi(memName + sizeof(AR_EFMT1)-1);
d831 1
a831 1
	    if (elen <= 0 || elen >= PATH_MAX)
d833 1
a833 1
	    if (fread(ename, elen, 1, arch) != 1)
d835 1
a835 1
	    if (fseek(arch, -elen, SEEK_CUR) != 0)
d837 1
a837 1
	    ename[elen] = '\0';
d865 1
a865 3
ArchTouch(archive, member)
    const char	  *archive;   /* Path to the archive */
    const char	  *member;    /* Name of member. */
d868 1
a868 1
    struct ar_hdr arh;
d870 1
a870 1
    arch = ArchFindMember(archive, member, &arh, "r+");
d872 1
a872 1
	snprintf(arh.ar_date, sizeof(arh.ar_date), "%-12ld", (long)
d875 1
a875 1
	    (void)fwrite(&arh, sizeof(struct ar_hdr), 1, arch);
d887 1
a887 2
Arch_Touch(gn)
    GNode	  *gn;	  /* Node of member to touch */
d894 1
a894 2
Arch_TouchLib(gn)
    GNode	    *gn UNUSED;	/* The node of the library to touch */
d906 1
a906 2
Arch_MTime(gn)
    GNode	  *gn;	      /* Node describing archive member */
d916 1
a916 2
Arch_MemMTime(gn)
    GNode	  *gn;
d961 1
a961 3
Arch_FindLib(gn, path)
    GNode	    *gn;	/* Node of library to find */
    Lst 	    path;	/* Search path */
d964 1
a964 1
    size_t	    len = strlen(gn->name) + 6 - 2;
d966 2
a967 2
    libName = emalloc(len);
    snprintf(libName, len, "lib%s.a", &gn->name[2]);
d1016 1
a1016 2
Arch_LibOODate(gn)
    GNode	  *gn;		/* The library's graph node */
d1048 1
a1048 1
Arch_Init()
d1055 1
a1055 1
Arch_End()
d1068 1
a1068 2
Arch_IsLib(gn)
    GNode *gn;
@


1.2
log
@I think Linux uses SVR4 ar(1) archives, too...
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.51 2002/01/30 18:40:26 matthieu Exp $ */
d48 1
a48 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d160 1
d313 1
d320 2
a321 1
	    buf = sacrifice = emalloc(strlen(memName)+strlen(libName)+3);
d323 1
a323 1
	    sprintf(buf, "%s(%s)", libName, memName);
d976 1
d978 2
a979 2
    libName = emalloc(strlen(gn->name) + 6 - 2);
    sprintf(libName, "lib%s.a", &gn->name[2]);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.52 2003/04/06 22:47:14 espie Exp $ */
a315 1
	    size_t  len;
d322 1
a322 2
	    len = strlen(memName)+strlen(libName)+3;
	    buf = sacrifice = emalloc(len);
d324 1
a324 1
	    snprintf(buf, len, "%s(%s)", libName, memName);
a976 1
    size_t	    len = strlen(gn->name) + 6 - 2;
d978 2
a979 2
    libName = emalloc(len);
    snprintf(libName, len, "lib%s.a", &gn->name[2]);
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.53 2003/06/03 02:56:11 millert Exp $ */
d48 5
a52 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.1.4
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.54 2004/04/07 13:11:35 espie Exp $ */
d172 1
a172 1
static char *ArchSVR4Entry(struct SVR4namelist *, const char *, size_t, FILE *);
d176 3
a178 1
new_arch_member(struct ar_hdr *hdr, const char *name)
d193 2
a194 1
mtime_of_member(struct arch_member *m)
d209 2
a210 1
ArchFree(Arch *a)
d229 4
a232 3
Arch_ParseArchive(char **linePtr,   /* Pointer to start of specification */
    Lst nodeLst, 		    /* Lst on which to place the nodes */
    SymTable *ctxt)		    /* Context in which to expand variables */
d237 1
a237 1
    char	    *memberName;    /* Member-part of specification */
d267 1
a267 1
	bool doSubst = false; /* true if need to substitute in memberName */
d271 1
a271 1
	memberName = cp;
d293 1
a293 1
	if (cp == memberName)
d311 2
a312 2
	    char    *oldMemberName = memberName;
	    size_t  length;
d314 1
a314 1
	    memberName = Var_Subst(memberName, ctxt, true);
d319 2
a320 2
	    length = strlen(memberName)+strlen(libName)+3;
	    buf = sacrifice = emalloc(length);
d322 1
a322 1
	    snprintf(buf, length, "%s(%s)", libName, memberName);
d324 1
a324 2
	    if (strchr(memberName, '$') && 
	    	strcmp(memberName, oldMemberName) == 0) {
d345 1
a345 1
	} else if (Dir_HasWildcards(memberName)) {
d351 1
a351 1
	    Dir_Expand(memberName, dirSearchPath, &members);
d365 1
a365 1
	    snprintf(nameBuf, MAKE_BSIZE, "%s(%s)", libName, memberName);
d376 1
a376 1
	    free(memberName);
d398 3
a400 1
field2long(const char *field, size_t length)
d404 3
a406 3
    assert(length < sizeof(enough));
    memcpy(enough, field, length);
    enough[length] = '\0';
d411 3
a413 1
read_archive(const char *archive, const char *earchive)
d437 1
a437 1
    ar = ohash_create_entry(&arch_info, archive, &earchive);
d442 1
a442 1
	struct ar_hdr	arHeader;/* Archive-member header for reading archive */
d445 1
a445 1
	char		*memberName;
d449 2
a450 2
	memberName = buffer;
	n = fread(&arHeader, 1, sizeof(struct ar_hdr), arch);
d463 1
a463 1
	if (memcmp(arHeader.ar_fmag, ARFMAG, sizeof(arHeader.ar_fmag)) != 0) {
d471 1
a471 2
	    size = (off_t) field2long(arHeader.ar_size, 
	    	sizeof(arHeader.ar_size));
d473 1
a473 1
	    (void)memcpy(memberName, arHeader.ar_name, AR_NAME_SIZE);
d475 1
a475 1
	    for (cp = memberName + AR_NAME_SIZE - 1; *cp == ' ';)
d482 1
a482 1
	    if (memberName[0] == '/') {
d484 2
a485 2
		memberName = ArchSVR4Entry(&list, memberName, size, arch);
		if (memberName == NULL)		/* Invalid data */
d487 1
a487 1
		else if (memberName == svr4list)/* List of files entry */
d502 2
a503 2
	    if (memcmp(memberName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
		isdigit(memberName[sizeof(AR_EFMT1) - 1])) {
d505 1
a505 1
		int elen = atoi(memberName + sizeof(AR_EFMT1)-1);
d509 2
a510 2
		memberName = buffer;
		if (fread(memberName, elen, 1, arch) != 1)
d512 1
a512 1
		memberName[elen] = '\0';
d516 1
a516 2
		    printf("ArchStat: Extended format entry for %s\n", 
		    	memberName);
d521 2
a522 2
		ohash_qlookup(&ar->members, memberName),
		    new_arch_member(&arHeader, memberName));
d553 3
a555 3
ArchMTimeMember(
    const char	  *archive,   /* Path to the archive */
    const char	  *member,    /* Name of member. If it is a path, only the
d557 1
a557 1
    bool	  hash)       /* true if archive should be hashed if not
d586 1
a586 1
	    struct ar_hdr	arHeader;
d588 1
a588 1
	    arch = ArchFindMember(archive, member, &arHeader, "r");
d592 1
a592 2
		ts_set_from_time_t( (time_t)strtol(arHeader.ar_date, NULL, 10), 
		    result);
d643 5
a647 1
ArchSVR4Entry(struct SVR4namelist *l, const char *name, size_t size, FILE *arch)
d731 1
a731 1
 *	Fill the struct ar_hdr pointed by arHeaderPtr.
d735 3
a737 3
ArchFindMember(
    const char	  *archive,   /* Path to the archive */
    const char	  *member,    /* Name of member. If it is a path, only the
d739 2
a740 2
    struct ar_hdr *arHeaderPtr,/* Pointer to header structure to be filled in */
    const char	  *mode)      /* mode for opening the stream */
d743 1
a743 1
    char	  *cp;
d745 1
a745 1
    size_t	  length;
d771 3
a773 3
    length = strlen(member);
    if (length >= AR_NAME_SIZE)
	length = AR_NAME_SIZE;
d777 1
a777 1
    while (fread(arHeaderPtr, sizeof(struct ar_hdr), 1, arch) == 1) {
d779 1
a779 1
	char		  *memberName;
d781 1
a781 2
	if (memcmp(arHeaderPtr->ar_fmag, ARFMAG, sizeof(arHeaderPtr->ar_fmag) ) 
	    != 0)
d785 2
a786 2
	memberName = arHeaderPtr->ar_name;
	if (memcmp(member, memberName, length) == 0) {
d793 2
a794 3
	    if (length < sizeof(arHeaderPtr->ar_name) && 
	    	memberName[length] == '/')
		length++;
d796 2
a797 2
	    if (length == sizeof(arHeaderPtr->ar_name) ||
		memberName[length] == ' ') {
d805 1
a805 2
	size = (off_t) field2long(arHeaderPtr->ar_size, 
	    sizeof(arHeaderPtr->ar_size));
d810 1
a810 1
	    if (memberName[0] == '/') {
d812 2
a813 3
		memberName = ArchSVR4Entry(&list, arHeaderPtr->ar_name, size, 
		    arch);
		if (memberName == NULL)		/* Invalid data */
d815 1
a815 1
		else if (memberName == svr4list)/* List of files entry */
d818 1
a818 1
		if (strcmp(memberName, member) == 0) {
d828 2
a829 2
	if (memcmp(memberName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
	    isdigit(memberName[sizeof(AR_EFMT1) - 1])) {
d832 1
a832 1
	    int elength = atoi(memberName + sizeof(AR_EFMT1)-1);
d834 1
a834 1
	    if (elength <= 0 || elength >= PATH_MAX)
d836 1
a836 1
	    if (fread(ename, elength, 1, arch) != 1)
d838 1
a838 1
	    if (fseek(arch, -elength, SEEK_CUR) != 0)
d840 1
a840 1
	    ename[elength] = '\0';
d868 3
a870 1
ArchTouch(const char *archive, const char *member)
d873 1
a873 1
    struct ar_hdr arHeader;
d875 1
a875 1
    arch = ArchFindMember(archive, member, &arHeader, "r+");
d877 1
a877 1
	snprintf(arHeader.ar_date, sizeof(arHeader.ar_date), "%-12ld", (long)
d880 1
a880 1
	    (void)fwrite(&arHeader, sizeof(struct ar_hdr), 1, arch);
d892 2
a893 1
Arch_Touch(GNode *gn)
d900 2
a901 1
Arch_TouchLib(GNode *gn UNUSED)
d913 2
a914 1
Arch_MTime(GNode *gn)
d924 2
a925 1
Arch_MemMTime(GNode *gn)
d970 3
a972 1
Arch_FindLib(GNode *gn, Lst path)
d975 1
a975 1
    size_t	    length = strlen(gn->name) + 6 - 2;
d977 2
a978 2
    libName = emalloc(length);
    snprintf(libName, length, "lib%s.a", &gn->name[2]);
d1027 2
a1028 1
Arch_LibOODate(GNode *gn)
d1060 1
a1060 1
Arch_Init(void)
d1067 1
a1067 1
Arch_End(void)
d1080 2
a1081 1
Arch_IsLib(GNode *gn)
@


