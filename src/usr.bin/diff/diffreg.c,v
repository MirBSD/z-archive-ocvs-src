head	1.6;
access;
symbols
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.4
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.2
	MIROS_X_BASE:1.6
	tg-mergetmp-3:1.6
	cvs-200412091955:1.1.1.18
	cvs-200412071730:1.1.1.17
	cvs-200411281330:1.1.1.17
	MIRBSD_XP_MIRPPC:1.2.0.4
	cvs-200410222040:1.1.1.16
	tg-mergetmp-1:1.1.1.15
	cvs-200410141645:1.1.1.15
	MIRBSD_XP_SPARC_BASE:1.2
	MIRBSD_XP_SPARC:1.2.0.2
	cvs-200407041700:1.1.1.14
	MIRBSD_7quater:1.1.1.11
	cvs-200405160640:1.1.1.13
	cvs-200401271800:1.1.1.13
	cvs-200401261630:1.1.1.13
	cvs-200401021645:1.1.1.12
	MIRBSD_7_ALPHA:1.1.1.11.0.6
	MIRBSD_7:1.1.1.11.0.4
	cvs-200312222040:1.1.1.12
	MIRBSD_7ter:1.1.1.11
	MIRBSD_7_DEV:1.1.1.11.0.2
	cvs-200310020700:1.1.1.11
	cvs-200309271030:1.1.1.11
	cvs-200309251530:1.1.1.11
	cvs-200308302005:1.1.1.10
	cvs-200308171200:1.1.1.10
	ctm-3496:1.1.1.9
	ctm-3449:1.1.1.8
	ctm-3437:1.1.1.7
	cvs-200307191805:1.1.1.6
	ctm-3425:1.1.1.6
	cvs-200307091500:1.1.1.5
	cvs-200307081345:1.1.1.4
	cvs-200307072125:1.1.1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.12.09.20.00.24;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.28.13.41.32;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.22.21.53.44;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.14.20.50.52;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.04.17.10.27;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.06.29.17.35.37;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.06.29.17.35.37;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.07.06.15.49.55;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.07.07.21.27.51;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.07.08.13.46.33;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.07.09.16.48.28;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.07.18.13.51.46;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.07.22.15.01.36;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.07.26.13.23.19;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.08.11.18.43.21;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.08.17.14.42.47;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2003.09.25.16.40.40;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2003.12.22.21.12.52;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2004.01.26.18.57.17;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2004.07.04.17.01.57;	author tg;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2004.10.14.17.17.17;	author tg;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2004.10.22.20.49.22;	author tg;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2004.11.28.13.40.45;	author tg;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2004.12.09.19.58.59;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@merge
@
text
@/**	$MirBSD: src/usr.bin/diff/diffreg.c,v 1.5 2004/11/28 13:41:32 tg Exp $ */
/*	$OpenBSD: diffreg.c,v 1.61 2004/12/09 18:56:10 millert Exp $	*/

/*
 * Copyright (C) Caldera International Inc.  2001-2002.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code and documentation must retain the above
 *    copyright notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed or owned by Caldera
 *	International, Inc.
 * 4. Neither the name of Caldera International, Inc. nor the names of other
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE FOR ANY DIRECT,
 * INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)diffreg.c   8.1 (Berkeley) 6/6/93
 */

#if 0
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.61 2004/12/09 18:56:10 millert Exp $";
#endif /* not lint */

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "diff.h"
#include "pathnames.h"

__RCSID("$MirBSD: src/usr.bin/diff/diffreg.c,v 1.5 2004/11/28 13:41:32 tg Exp $");

/*
 * diff - compare two files.
 */

/*
 *	Uses an algorithm due to Harold Stone, which finds
 *	a pair of longest identical subsequences in the two
 *	files.
 *
 *	The major goal is to generate the match vector J.
 *	J[i] is the index of the line in file1 corresponding
 *	to line i file0. J[i] = 0 if there is no
 *	such line in file1.
 *
 *	Lines are hashed so as to work in core. All potential
 *	matches are located by sorting the lines of each file
 *	on the hash (called ``value''). In particular, this
 *	collects the equivalence classes in file1 together.
 *	Subroutine equiv replaces the value of each line in
 *	file0 by the index of the first element of its
 *	matching equivalence in (the reordered) file1.
 *	To save space equiv squeezes file1 into a single
 *	array member in which the equivalence classes
 *	are simply concatenated, except that their first
 *	members are flagged by changing sign.
 *
 *	Next the indices that point into member are unsorted into
 *	array class according to the original order of file0.
 *
 *	The cleverness lies in routine stone. This marches
 *	through the lines of file0, developing a vector klist
 *	of "k-candidates". At step i a k-candidate is a matched
 *	pair of lines x,y (x in file0 y in file1) such that
 *	there is a common subsequence of length k
 *	between the first i lines of file0 and the first y
 *	lines of file1, but there is no such subsequence for
 *	any smaller y. x is the earliest possible mate to y
 *	that occurs in such a subsequence.
 *
 *	Whenever any of the members of the equivalence class of
 *	lines in file1 matable to a line in file0 has serial number
 *	less than the y of some k-candidate, that k-candidate
 *	with the smallest such y is replaced. The new
 *	k-candidate is chained (via pred) to the current
 *	k-1 candidate so that the actual subsequence can
 *	be recovered. When a member has serial number greater
 *	that the y of all k-candidates, the klist is extended.
 *	At the end, the longest subsequence is pulled out
 *	and placed in the array J by unravel
 *
 *	With J in hand, the matches there recorded are
 *	check'ed against reality to assure that no spurious
 *	matches have crept in due to hashing. If they have,
 *	they are broken, and "jackpot" is recorded--a harmless
 *	matter except that a true match for a spuriously
 *	mated line may now be unnecessarily reported as a change.
 *
 *	Much of the complexity of the program comes simply
 *	from trying to minimize core utilization and
 *	maximize the range of doable problems by dynamically
 *	allocating what is needed and reusing what is not.
 *	The core requirements for problems larger than somewhat
 *	are (in words) 2*length(file0) + length(file1) +
 *	3*(number of k-candidates installed),  typically about
 *	6n words for files of length n.
 */

struct cand {
	int x;
	int y;
	int pred;
};

struct line {
	int serial;
	int value;
} *file[2];

/*
 * The following struct is used to record change information when
 * doing a "context" or "unified" diff.  (see routine "change" to
 * understand the highly mnemonic field names)
 */
struct context_vec {
	int a;			/* start line in old file */
	int b;			/* end line in old file */
	int c;			/* start line in new file */
	int d;			/* end line in new file */
};

static int  *J;			/* will be overlaid on class */
static int  *class;		/* will be overlaid on file[0] */
static int  *klist;		/* will be overlaid on file[0] after class */
static int  *member;		/* will be overlaid on file[1] */
static int   clen;
static int   inifdef;		/* whether or not we are in a #ifdef block */
static int   len[2];
static int   pref, suff;	/* length of prefix and suffix */
static int   slen[2];
static int   anychange;
static long *ixnew;		/* will be overlaid on file[1] */
static long *ixold;		/* will be overlaid on klist */
static struct cand *clist;	/* merely a free storage pot for candidates */
static int   clistlen;		/* the length of clist */
static struct line *sfile[2];	/* shortened by pruning common prefix/suffix */
static u_char *chrtran;		/* translation table for case-folding */
static struct context_vec *context_vec_start;
static struct context_vec *context_vec_end;
static struct context_vec *context_vec_ptr;

#define FUNCTION_CONTEXT_SIZE	41
static char lastbuf[FUNCTION_CONTEXT_SIZE];
static int lastline;
static int lastmatchline;

static FILE *opentemp(const char *);
static void output(char *, FILE *, char *, FILE *);
static void check(char *, FILE *, char *, FILE *);
static void range(int, int, char *);
static void uni_range(int, int);
static void dump_context_vec(FILE *, FILE *);
static void dump_unified_vec(FILE *, FILE *);
static void prepare(int, FILE *, off_t);
static void prune(void);
static void equiv(struct line *, int, struct line *, int, int *);
static void unravel(int);
static void unsort(struct line *, int, int *);
static void change(char *, FILE *, char *, FILE *, int, int, int, int);
static void sort(struct line *, int);
static void print_header(const char *, const char *);
static int  ignoreline(char *);
static int  asciifile(FILE *);
static int  fetch(long *, int, int, FILE *, int, int);
static int  newcand(int, int, int);
static int  search(int *, int, int);
static int  skipline(FILE *);
static int  isqrt(int);
static int  stone(int *, int, int *, int *);
static int  readhash(FILE *);
static int  files_differ(FILE *, FILE *, int);
static __inline int min(int, int);
static __inline int max(int, int);
static char *match_function(const long *, int, FILE *);
static char *preadline(int, size_t, off_t);


/*
 * chrtran points to one of 2 translation tables: cup2low if folding upper to
 * lower case clow2low if not folding case
 */
u_char clow2low[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
	0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
	0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
	0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
	0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41,
	0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c,
	0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
	0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
	0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
	0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
	0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
	0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
	0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
	0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5,
	0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
	0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
	0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
	0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,
	0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc,
	0xfd, 0xfe, 0xff
};

u_char cup2low[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
	0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
	0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
	0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
	0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x60, 0x61,
	0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
	0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x60, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
	0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
	0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
	0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
	0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
	0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
	0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
	0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5,
	0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
	0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
	0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
	0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,
	0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc,
	0xfd, 0xfe, 0xff
};

int
diffreg(char *ofile1, char *ofile2, int flags)
{
	char *file1 = ofile1;
	char *file2 = ofile2;
	FILE *f1 = NULL;
	FILE *f2 = NULL;
	int rval = D_SAME;
	int i, ostdout = -1;
	pid_t pid = -1;

	anychange = 0;
	lastline = 0;
	lastmatchline = 0;
	context_vec_ptr = context_vec_start - 1;
	chrtran = (iflag ? cup2low : clow2low);
	if (S_ISDIR(stb1.st_mode) != S_ISDIR(stb2.st_mode))
		return (S_ISDIR(stb1.st_mode) ? D_MISMATCH1 : D_MISMATCH2);
	if (strcmp(file1, "-") == 0 && strcmp(file2, "-") == 0)
		goto closem;

	if (flags & D_EMPTY1)
		f1 = fopen(_PATH_DEVNULL, "r");
	else {
		if (!S_ISREG(stb1.st_mode)) {
			if ((f1 = opentemp(file1)) == NULL ||
			    fstat(fileno(f1), &stb1) < 0) {
				warn("%s", file1);
				status |= 2;
				goto closem;
			}
		} else if (strcmp(file1, "-") == 0)
			f1 = stdin;
		else
			f1 = fopen(file1, "r");
	}
	if (f1 == NULL) {
		warn("%s", file1);
		status |= 2;
		goto closem;
	}

	if (flags & D_EMPTY2)
		f2 = fopen(_PATH_DEVNULL, "r");
	else {
		if (!S_ISREG(stb2.st_mode)) {
			if ((f2 = opentemp(file2)) == NULL ||
			    fstat(fileno(f2), &stb2) < 0) {
				warn("%s", file2);
				status |= 2;
				goto closem;
			}
		} else if (strcmp(file2, "-") == 0)
			f2 = stdin;
		else
			f2 = fopen(file2, "r");
	}
	if (f2 == NULL) {
		warn("%s", file2);
		status |= 2;
		goto closem;
	}

	switch (files_differ(f1, f2, flags)) {
	case 0:
		goto closem;
	case 1:
		break;
	default:
		/* error */
		status |= 2;
		goto closem;
	}

	if (!asciifile(f1) || !asciifile(f2)) {
		rval = D_BINARY;
		status |= 1;
		goto closem;
	}
	if (lflag) {
		/* redirect stdout to pr */
		int pfd[2];
		char *header;
		char *prargv[] = { "pr", "-h", NULL, "-f", NULL };

		easprintf(&header, "%s %s %s", diffargs, file1, file2);
		prargv[2] = header;
		fflush(stdout);
		rewind(stdout);
		pipe(pfd);
		switch ((pid = fork())) {
		case -1:
			warnx("No more processes");
			status |= 2;
			free(header);
			return (D_ERROR);
		case 0:
			/* child */
			if (pfd[0] != STDIN_FILENO) {
				dup2(pfd[0], STDIN_FILENO);
				close(pfd[0]);
			}
			close(pfd[1]);
			execv(_PATH_PR, prargv);
			_exit(127);
		default:
			/* parent */
			if (pfd[1] != STDOUT_FILENO) {
				ostdout = dup(STDOUT_FILENO);
				dup2(pfd[1], STDOUT_FILENO);
				close(pfd[1]);
			}
			close(pfd[0]);
			rewind(stdout);
			free(header);
		}
	} else if (flags & D_HEADER)
		printf("%s %s %s\n", diffargs, file1, file2);
	prepare(0, f1, stb1.st_size);
	prepare(1, f2, stb2.st_size);
	prune();
	sort(sfile[0], slen[0]);
	sort(sfile[1], slen[1]);

	member = (int *)file[1];
	equiv(sfile[0], slen[0], sfile[1], slen[1], member);
	member = erealloc(member, (slen[1] + 2) * sizeof(int));

	class = (int *)file[0];
	unsort(sfile[0], slen[0], class);
	class = erealloc(class, (slen[0] + 2) * sizeof(int));

	klist = emalloc((slen[0] + 2) * sizeof(int));
	clen = 0;
	clistlen = 100;
	clist = emalloc(clistlen * sizeof(struct cand));
	i = stone(class, slen[0], member, klist);
	free(member);
	free(class);

	J = erealloc(J, (len[0] + 2) * sizeof(int));
	unravel(klist[i]);
	free(clist);
	free(klist);

	ixold = erealloc(ixold, (len[0] + 2) * sizeof(long));
	ixnew = erealloc(ixnew, (len[1] + 2) * sizeof(long));
	check(file1, f1, file2, f2);
	output(file1, f1, file2, f2);
	if (ostdout != -1) {
		int wstatus;

		/* close the pipe to pr and restore stdout */
		fflush(stdout);
		rewind(stdout);
		if (ostdout != STDOUT_FILENO) {
			close(STDOUT_FILENO);
			dup2(ostdout, STDOUT_FILENO);
			close(ostdout);
		}
		waitpid(pid, &wstatus, 0);
	}
closem:
	if (anychange) {
		status |= 1;
		if (rval == D_SAME)
			rval = D_DIFFER;
	}
	if (f1 != NULL)
		fclose(f1);
	if (f2 != NULL)
		fclose(f2);
	if (file1 != ofile1)
		free(file1);
	if (file2 != ofile2)
		free(file2);
	return (rval);
}

/*
 * Check to see if the given files differ.
 * Returns 0 if they are the same, 1 if different, and -1 on error.
 * XXX - could use code from cmp(1) [faster]
 */
static int
files_differ(FILE *f1, FILE *f2, int flags)
{
	char buf1[BUFSIZ], buf2[BUFSIZ];
	size_t i, j;

	if ((flags & (D_EMPTY1|D_EMPTY2)) || stb1.st_size != stb2.st_size ||
	    (stb1.st_mode & S_IFMT) != (stb2.st_mode & S_IFMT))
		return (1);
	for (;;) {
		i = fread(buf1, 1, sizeof(buf1), f1);
		j = fread(buf2, 1, sizeof(buf2), f2);
		if (i != j)
			return (1);
		if (i == 0 && j == 0) {
			if (ferror(f1) || ferror(f2))
				return (1);
			return (0);
		}
		if (memcmp(buf1, buf2, i) != 0)
			return (1);
	}
}

static FILE *
opentemp(const char *file)
{
	char buf[BUFSIZ], *tempdir, tempfile[MAXPATHLEN];
	ssize_t nread;
	int ifd, ofd;

	if (strcmp(file, "-") == 0)
		ifd = STDIN_FILENO;
	else if ((ifd = open(file, O_RDONLY, 0644)) < 0)
		return (NULL);

	if ((tempdir = getenv("TMPDIR")) == NULL)
		tempdir = _PATH_TMP;
	if (snprintf(tempfile, sizeof(tempfile), "%s/diff.XXXXXXXX",
	    tempdir) >= sizeof(tempfile)) {
		close(ifd);
		errno = ENAMETOOLONG;
		return (NULL);
	}

	if ((ofd = mkstemp(tempfile)) < 0)
		return (NULL);
	unlink(tempfile);
	while ((nread = read(ifd, buf, BUFSIZ)) > 0) {
		if (write(ofd, buf, nread) != nread) {
			close(ifd);
			close(ofd);
			return (NULL);
		}
	}
	close(ifd);
	lseek(ofd, (off_t)0, SEEK_SET);
	return (fdopen(ofd, "r"));
}

char *
splice(char *dir, char *file)
{
	char *tail, *buf;

	if ((tail = strrchr(file, '/')) == NULL)
		tail = file;
	else
		tail++;
	easprintf(&buf, "%s/%s", dir, tail);
	return (buf);
}

static void
prepare(int i, FILE *fd, off_t filesize)
{
	struct line *p;
	int j, h;
	size_t sz;

	rewind(fd);

	sz = (filesize <= SIZE_MAX ? filesize : SIZE_MAX) / 25;
	if (sz < 100)
		sz = 100;

	p = emalloc((sz + 3) * sizeof(struct line));
	for (j = 0; (h = readhash(fd));) {
		if (j == sz) {
			sz = sz * 3 / 2;
			p = erealloc(p, (sz + 3) * sizeof(struct line));
		}
		p[++j].value = h;
	}
	len[i] = j;
	file[i] = p;
}

static void
prune(void)
{
	int i, j;

	for (pref = 0; pref < len[0] && pref < len[1] &&
	    file[0][pref + 1].value == file[1][pref + 1].value;
	    pref++)
		;
	for (suff = 0; suff < len[0] - pref && suff < len[1] - pref &&
	    file[0][len[0] - suff].value == file[1][len[1] - suff].value;
	    suff++)
		;
	for (j = 0; j < 2; j++) {
		sfile[j] = file[j] + pref;
		slen[j] = len[j] - pref - suff;
		for (i = 0; i <= slen[j]; i++)
			sfile[j][i].serial = i;
	}
}

static void
equiv(struct line *a, int n, struct line *b, int m, int *c)
{
	int i, j;

	i = j = 1;
	while (i <= n && j <= m) {
		if (a[i].value < b[j].value)
			a[i++].value = 0;
		else if (a[i].value == b[j].value)
			a[i++].value = j;
		else
			j++;
	}
	while (i <= n)
		a[i++].value = 0;
	b[m + 1].value = 0;
	j = 0;
	while (++j <= m) {
		c[j] = -b[j].serial;
		while (b[j + 1].value == b[j].value) {
			j++;
			c[j] = b[j].serial;
		}
	}
	c[j] = -1;
}

/* Code taken from ping.c */
static int
isqrt(int n)
{
	int y, x = 1;

	if (n == 0)
		return(0);

	do { /* newton was a stinker */
		y = x;
		x = n / x;
		x += y;
		x /= 2;
	} while ((x - y) > 1 || (x - y) < -1);

	return (x);
}

static int
stone(int *a, int n, int *b, int *c)
{
	int i, k, y, j, l;
	int oldc, tc, oldl;
	u_int numtries;

	const u_int bound = dflag ? UINT_MAX : max(256, isqrt(n));

	k = 0;
	c[0] = newcand(0, 0, 0);
	for (i = 1; i <= n; i++) {
		j = a[i];
		if (j == 0)
			continue;
		y = -b[j];
		oldl = 0;
		oldc = c[0];
		numtries = 0;
		do {
			if (y <= clist[oldc].y)
				continue;
			l = search(c, k, y);
			if (l != oldl + 1)
				oldc = c[l - 1];
			if (l <= k) {
				if (clist[c[l]].y <= y)
					continue;
				tc = c[l];
				c[l] = newcand(i, y, oldc);
				oldc = tc;
				oldl = l;
				numtries++;
			} else {
				c[l] = newcand(i, y, oldc);
				k++;
				break;
			}
		} while ((y = b[++j]) > 0 && numtries < bound);
	}
	return (k);
}

static int
newcand(int x, int y, int pred)
{
	struct cand *q;

	if (clen == clistlen) {
		clistlen = clistlen * 11 / 10;
		clist = erealloc(clist, clistlen * sizeof(struct cand));
	}
	q = clist + clen;
	q->x = x;
	q->y = y;
	q->pred = pred;
	return (clen++);
}

static int
search(int *c, int k, int y)
{
	int i, j, l, t;

	if (clist[c[k]].y < y)	/* quick look for typical case */
		return (k + 1);
	i = 0;
	j = k + 1;
	while (1) {
		l = i + j;
		if ((l >>= 1) <= i)
			break;
		t = clist[c[l]].y;
		if (t > y)
			j = l;
		else if (t < y)
			i = l;
		else
			return (l);
	}
	return (l + 1);
}

static void
unravel(int p)
{
	struct cand *q;
	int i;

	for (i = 0; i <= len[0]; i++)
		J[i] = i <= pref ? i :
		    i > len[0] - suff ? i + len[1] - len[0] : 0;
	for (q = clist + p; q->y != 0; q = clist + q->pred)
		J[q->x + pref] = q->y + pref;
}

/*
 * Check does double duty:
 *  1.	ferret out any fortuitous correspondences due
 *	to confounding by hashing (which result in "jackpot")
 *  2.  collect random access indexes to the two files
 */
static void
check(char *file1, FILE *f1, char *file2, FILE *f2)
{
	int i, j, jackpot, c, d;
	long ctold, ctnew;

	rewind(f1);
	rewind(f2);
	j = 1;
	ixold[0] = ixnew[0] = 0;
	jackpot = 0;
	ctold = ctnew = 0;
	for (i = 1; i <= len[0]; i++) {
		if (J[i] == 0) {
			ixold[i] = ctold += skipline(f1);
			continue;
		}
		while (j < J[i]) {
			ixnew[j] = ctnew += skipline(f2);
			j++;
		}
		if (bflag || wflag || iflag) {
			for (;;) {
				c = getc(f1);
				d = getc(f2);
				/*
				 * GNU diff ignores a missing newline
				 * in one file if bflag || wflag.
				 */
				if ((bflag || wflag) &&
				    ((c == EOF && d == '\n') ||
				    (c == '\n' && d == EOF))) {
					break;
				}
				ctold++;
				ctnew++;
				if (bflag && isspace(c) && isspace(d)) {
					do {
						if (c == '\n')
							break;
						ctold++;
					} while (isspace(c = getc(f1)));
					do {
						if (d == '\n')
							break;
						ctnew++;
					} while (isspace(d = getc(f2)));
				} else if (wflag) {
					while (isspace(c) && c != '\n') {
						c = getc(f1);
						ctold++;
					}
					while (isspace(d) && d != '\n') {
						d = getc(f2);
						ctnew++;
					}
				}
				if (chrtran[c] != chrtran[d]) {
					jackpot++;
					J[i] = 0;
					if (c != '\n' && c != EOF)
						ctold += skipline(f1);
					if (d != '\n' && c != EOF)
						ctnew += skipline(f2);
					break;
				}
				if (c == '\n' || c == EOF)
					break;
			}
		} else {
			for (;;) {
				ctold++;
				ctnew++;
				if ((c = getc(f1)) != (d = getc(f2))) {
					/* jackpot++; */
					J[i] = 0;
					if (c != '\n' && c != EOF)
						ctold += skipline(f1);
					if (d != '\n' && c != EOF)
						ctnew += skipline(f2);
					break;
				}
				if (c == '\n' || c == EOF)
					break;
			}
		}
		ixold[i] = ctold;
		ixnew[j] = ctnew;
		j++;
	}
	for (; j <= len[1]; j++)
		ixnew[j] = ctnew += skipline(f2);
	/*
	 * if (jackpot)
	 *	fprintf(stderr, "jackpot\n");
	 */
}

/* shellsort CACM #201 */
static void
sort(struct line *a, int n)
{
	struct line *ai, *aim, w;
	int j, m = 0, k;

	if (n == 0)
		return;
	for (j = 1; j <= n; j *= 2)
		m = 2 * j - 1;
	for (m /= 2; m != 0; m /= 2) {
		k = n - m;
		for (j = 1; j <= k; j++) {
			for (ai = &a[j]; ai > a; ai -= m) {
				aim = &ai[m];
				if (aim < ai)
					break;	/* wraparound */
				if (aim->value > ai[0].value ||
				    (aim->value == ai[0].value &&
					aim->serial > ai[0].serial))
					break;
				w.value = ai[0].value;
				ai[0].value = aim->value;
				aim->value = w.value;
				w.serial = ai[0].serial;
				ai[0].serial = aim->serial;
				aim->serial = w.serial;
			}
		}
	}
}

static void
unsort(struct line *f, int l, int *b)
{
	int *a, i;

	a = emalloc((l + 1) * sizeof(int));
	for (i = 1; i <= l; i++)
		a[f[i].serial] = f[i].value;
	for (i = 1; i <= l; i++)
		b[i] = a[i];
	free(a);
}

static int
skipline(FILE *f)
{
	int i, c;

	for (i = 1; (c = getc(f)) != '\n' && c != EOF; i++)
		continue;
	return (i);
}

static void
output(char *file1, FILE *f1, char *file2, FILE *f2)
{
	int m, i0, i1, j0, j1;

	rewind(f1);
	rewind(f2);
	m = len[0];
	J[0] = 0;
	J[m + 1] = len[1] + 1;
	if (format != D_EDIT) {
		for (i0 = 1; i0 <= m; i0 = i1 + 1) {
			while (i0 <= m && J[i0] == J[i0 - 1] + 1)
				i0++;
			j0 = J[i0 - 1] + 1;
			i1 = i0 - 1;
			while (i1 < m && J[i1 + 1] == 0)
				i1++;
			j1 = J[i1 + 1] - 1;
			J[i1] = j1;
			change(file1, f1, file2, f2, i0, i1, j0, j1);
		}
	} else {
		for (i0 = m; i0 >= 1; i0 = i1 - 1) {
			while (i0 >= 1 && J[i0] == J[i0 + 1] - 1 && J[i0] != 0)
				i0--;
			j0 = J[i0 + 1] - 1;
			i1 = i0 + 1;
			while (i1 > 1 && J[i1 - 1] == 0)
				i1--;
			j1 = J[i1 - 1] + 1;
			J[i1] = j1;
			change(file1, f1, file2, f2, i1, i0, j1, j0);
		}
	}
	if (m == 0)
		change(file1, f1, file2, f2, 1, 0, 1, len[1]);
	if (format == D_IFDEF) {
		for (;;) {
#define	c i0
			if ((c = getc(f1)) == EOF)
				return;
			putchar(c);
		}
#undef c
	}
	if (anychange != 0) {
		if (format == D_CONTEXT)
			dump_context_vec(f1, f2);
		else if (format == D_UNIFIED)
			dump_unified_vec(f1, f2);
	}
}

static __inline void
range(int a, int b, char *separator)
{
	printf("%d", a > b ? b : a);
	if (a < b)
		printf("%s%d", separator, b);
}

static __inline void
uni_range(int a, int b)
{
	if (a < b)
		printf("%d,%d", a, b - a + 1);
	else if (a == b)
		printf("%d", b);
	else
		printf("%d,0", b);
}

static char *
preadline(int fd, size_t len, off_t off)
{
	char *line;
	ssize_t nr;

	line = emalloc(len + 1);
	if ((nr = pread(fd, line, len, off)) < 0)
		err(1, "preadline");
	line[nr] = '\0';
	return (line);
}

static int
ignoreline(char *line)
{
	int ret;

	ret = regexec(&ignore_re, line, 0, NULL, 0);
	free(line);
	return (ret == 0);	/* if it matched, it should be ignored. */
}

/*
 * Indicate that there is a difference between lines a and b of the from file
 * to get to lines c to d of the to file.  If a is greater then b then there
 * are no lines in the from file involved and this means that there were
 * lines appended (beginning at b).  If c is greater than d then there are
 * lines missing from the to file.
 */
static void
change(char *file1, FILE *f1, char *file2, FILE *f2, int a, int b, int c, int d)
{
	static size_t max_context = 64;
	int i;

restart:
	if (format != D_IFDEF && a > b && c > d)
		return;
	if (ignore_pats != NULL) {
		char *line;
		/*
		 * All lines in the change, insert, or delete must
		 * match an ignore pattern for the change to be
		 * ignored.
		 */
		if (a <= b) {		/* Changes and deletes. */
			for (i = a; i <= b; i++) {
				line = preadline(fileno(f1),
				    ixold[i] - ixold[i - 1], ixold[i - 1]);
				if (!ignoreline(line))
					goto proceed;
			}
		}
		if (a > b || c <= d) {	/* Changes and inserts. */
			for (i = c; i <= d; i++) {
				line = preadline(fileno(f2),
				    ixnew[i] - ixnew[i - 1], ixnew[i - 1]);
				if (!ignoreline(line))
					goto proceed;
			}
		}
		return;
	}
proceed:
	if (format == D_CONTEXT || format == D_UNIFIED) {
		/*
		 * Allocate change records as needed.
		 */
		if (context_vec_ptr == context_vec_end - 1) {
			ptrdiff_t offset = context_vec_ptr - context_vec_start;
			max_context <<= 1;
			context_vec_start = erealloc(context_vec_start,
			    max_context * sizeof(struct context_vec));
			context_vec_end = context_vec_start + max_context;
			context_vec_ptr = context_vec_start + offset;
		}
		if (anychange == 0) {
			/*
			 * Print the context/unidiff header first time through.
			 */
			print_header(file1, file2);
			anychange = 1;
		} else if (a > context_vec_ptr->b + (2 * context) + dflag &&
		    c > context_vec_ptr->d + (2 * context) + dflag) {
			/*
			 * If this change is more than 'context' lines from the
			 * previous change, dump the record and reset it.
			 */
			if (format == D_CONTEXT)
				dump_context_vec(f1, f2);
			else
				dump_unified_vec(f1, f2);
		}
		context_vec_ptr++;
		context_vec_ptr->a = a;
		context_vec_ptr->b = b;
		context_vec_ptr->c = c;
		context_vec_ptr->d = d;
		return;
	}
	if (anychange == 0)
		anychange = 1;
	switch (format) {

	case D_BRIEF:
		return;
	case D_NORMAL:
	case D_EDIT:
		range(a, b, ",");
		putchar(a > b ? 'a' : c > d ? 'd' : 'c');
		if (format == D_NORMAL)
			range(c, d, ",");
		putchar('\n');
		break;
	case D_REVERSE:
		putchar(a > b ? 'a' : c > d ? 'd' : 'c');
		range(a, b, " ");
		putchar('\n');
		break;
	case D_NREVERSE:
		if (a > b)
			printf("a%d %d\n", b, d - c + 1);
		else {
			printf("d%d %d\n", a, b - a + 1);
			if (!(c > d))
				/* add changed lines */
				printf("a%d %d\n", b, d - c + 1);
		}
		break;
	}
	if (format == D_NORMAL || format == D_IFDEF) {
		fetch(ixold, a, b, f1, '<', 1);
		if (a <= b && c <= d && format == D_NORMAL)
			puts("---");
	}
	i = fetch(ixnew, c, d, f2, format == D_NORMAL ? '>' : '\0', 0);
	if (i != 0 && format == D_EDIT) {
		/*
		 * A non-zero return value for D_EDIT indicates that the
		 * last line printed was a bare dot (".") that has been
		 * escaped as ".." to prevent ed(1) from misinterpreting
		 * it.  We have to add a substitute command to change this
		 * back and restart where we left off.
		 */
		puts(".");
		printf("%ds/^\\.\\././\n", a);
		a += i;
		c += i;
		goto restart;
	}
	if ((format == D_EDIT || format == D_REVERSE) && c <= d)
		puts(".");
	if (inifdef) {
		printf("#endif /* %s */\n", ifdefname);
		inifdef = 0;
	}
}

static int
fetch(long *f, int a, int b, FILE *lb, int ch, int oldfile)
{
	int i, j, c, lastc, col, nc;

	/*
	 * When doing #ifdef's, copy down to current line
	 * if this is the first file, so that stuff makes it to output.
	 */
	if (format == D_IFDEF && oldfile) {
		long curpos = ftell(lb);
		/* print through if append (a>b), else to (nb: 0 vs 1 orig) */
		nc = f[a > b ? b : a - 1] - curpos;
		for (i = 0; i < nc; i++)
			putchar(getc(lb));
	}
	if (a > b)
		return (0);
	if (format == D_IFDEF) {
		if (inifdef) {
			printf("#else /* %s%s */\n",
			    oldfile == 1 ? "!" : "", ifdefname);
		} else {
			if (oldfile)
				printf("#ifndef %s\n", ifdefname);
			else
				printf("#ifdef %s\n", ifdefname);
		}
		inifdef = 1 + oldfile;
	}
	for (i = a; i <= b; i++) {
		fseek(lb, f[i - 1], SEEK_SET);
		nc = f[i] - f[i - 1];
		if (format != D_IFDEF && ch != '\0') {
			putchar(ch);
			if (Tflag && (format == D_NORMAL || format == D_CONTEXT
			    || format == D_UNIFIED))
				putchar('\t');
			else if (format != D_UNIFIED)
				putchar(' ');
		}
		col = 0;
		for (j = 0, lastc = '\0'; j < nc; j++, lastc = c) {
			if ((c = getc(lb)) == EOF) {
				if (format == D_EDIT || format == D_REVERSE ||
				    format == D_NREVERSE)
					warnx("No newline at end of file");
				else
					puts("\n\\ No newline at end of file");
				return (0);
			}
			if (c == '\t' && tflag) {
				do {
					putchar(' ');
				} while (++col & 7);
			} else {
				if (format == D_EDIT && j == 1 && c == '\n'
				    && lastc == '.') {
					/*
					 * Don't print a bare "." line
					 * since that will confuse ed(1).
					 * Print ".." instead and return,
					 * giving the caller an offset
					 * from which to restart.
					 */
					puts(".");
					return (i - a + 1);
				}
				putchar(c);
				col++;
			}
		}
	}
	return (0);
}

/*
 * Hash function taken from Robert Sedgewick, Algorithms in C, 3d ed., p 578.
 */
static int
readhash(FILE *f)
{
	int i, t, space;
	int sum;

	sum = 1;
	space = 0;
	if (!bflag && !wflag) {
		if (iflag)
			for (i = 0; (t = getc(f)) != '\n'; i++) {
				if (t == EOF) {
					if (i == 0)
						return (0);
					break;
				}
				sum = sum * 127 + chrtran[t];
			}
		else
			for (i = 0; (t = getc(f)) != '\n'; i++) {
				if (t == EOF) {
					if (i == 0)
						return (0);
					break;
				}
				sum = sum * 127 + t;
			}
	} else {
		for (i = 0;;) {
			switch (t = getc(f)) {
			case '\t':
			case ' ':
				space++;
				continue;
			default:
				if (space && !wflag) {
					i++;
					space = 0;
				}
				sum = sum * 127 + chrtran[t];
				i++;
				continue;
			case EOF:
				if (i == 0)
					return (0);
				/* FALLTHROUGH */
			case '\n':
				break;
			}
			break;
		}
	}
	/*
	 * There is a remote possibility that we end up with a zero sum.
	 * Zero is used as an EOF marker, so return 1 instead.
	 */
	return (sum == 0 ? 1 : sum);
}

static int
asciifile(FILE *f)
{
	unsigned char buf[BUFSIZ];
	int i, cnt;

	if (aflag || f == NULL)
		return (1);

	rewind(f);
	cnt = fread(buf, 1, sizeof(buf), f);
	for (i = 0; i < cnt; i++)
		if (!isprint(buf[i]) && !isspace(buf[i]))
			return (0);
	return (1);
}

static __inline int min(int a, int b)
{
	return (a < b ? a : b);
}

static __inline int max(int a, int b)
{
	return (a > b ? a : b);
}

static char *
match_function(const long *f, int pos, FILE *file)
{
	unsigned char buf[FUNCTION_CONTEXT_SIZE];
	size_t nc;
	int last = lastline;
	char *p;

	lastline = pos;
	while (pos > last) {
		fseek(file, f[pos - 1], SEEK_SET);
		nc = f[pos] - f[pos - 1];
		if (nc >= sizeof(buf))
			nc = sizeof(buf) - 1;
		nc = fread(buf, 1, nc, file);
		if (nc > 0) {
			buf[nc] = '\0';
			p = strchr(buf, '\n');
			if (p != NULL)
				*p = '\0';
			if (isalpha(buf[0]) || buf[0] == '_' || buf[0] == '$') {
				strlcpy(lastbuf, buf, sizeof lastbuf);
				lastmatchline = pos;
				return lastbuf;
			}
		}
		pos--;
	}
	return lastmatchline > 0 ? lastbuf : NULL;
}

/* dump accumulated "context" diff changes */
static void
dump_context_vec(FILE *f1, FILE *f2)
{
	struct context_vec *cvp = context_vec_start;
	int lowa, upb, lowc, upd, do_output;
	int a, b, c, d;
	char ch, *f;

	if (context_vec_start > context_vec_ptr)
		return;

	b = d = 0;		/* gcc */
	lowa = max(1, cvp->a - context);
	upb = min(len[0], context_vec_ptr->b + context);
	lowc = max(1, cvp->c - context);
	upd = min(len[1], context_vec_ptr->d + context);

	printf("***************");
	if (pflag) {
		f = match_function(ixold, lowa-1, f1);
		if (f != NULL) {
			putchar(' ');
			fputs(f, stdout);
		}
	}
	printf("\n*** ");
	range(lowa, upb, ",");
	printf(" ****\n");

	/*
	 * Output changes to the "old" file.  The first loop suppresses
	 * output if there were no changes to the "old" file (we'll see
	 * the "old" lines as context in the "new" list).
	 */
	do_output = 0;
	for (; cvp <= context_vec_ptr; cvp++)
		if (cvp->a <= cvp->b) {
			cvp = context_vec_start;
			do_output++;
			break;
		}
	if (do_output) {
		while (cvp <= context_vec_ptr) {
			a = cvp->a;
			b = cvp->b;
			c = cvp->c;
			d = cvp->d;

			if (a <= b && c <= d)
				ch = 'c';
			else
				ch = (a <= b) ? 'd' : 'a';

			if (ch == 'a')
				fetch(ixold, lowa, b, f1, ' ', 0);
			else {
				fetch(ixold, lowa, a - 1, f1, ' ', 0);
				fetch(ixold, a, b, f1,
				    ch == 'c' ? '!' : '-', 0);
			}
			lowa = b + 1;
			cvp++;
		}
		fetch(ixold, b + 1, upb, f1, ' ', 0);
	}
	/* output changes to the "new" file */
	printf("--- ");
	range(lowc, upd, ",");
	printf(" ----\n");

	do_output = 0;
	for (cvp = context_vec_start; cvp <= context_vec_ptr; cvp++)
		if (cvp->c <= cvp->d) {
			cvp = context_vec_start;
			do_output++;
			break;
		}
	if (do_output) {
		while (cvp <= context_vec_ptr) {
			a = cvp->a;
			b = cvp->b;
			c = cvp->c;
			d = cvp->d;

			if (a <= b && c <= d)
				ch = 'c';
			else
				ch = (a <= b) ? 'd' : 'a';

			if (ch == 'd')
				fetch(ixnew, lowc, d, f2, ' ', 0);
			else {
				fetch(ixnew, lowc, c - 1, f2, ' ', 0);
				fetch(ixnew, c, d, f2,
				    ch == 'c' ? '!' : '+', 0);
			}
			lowc = d + 1;
			cvp++;
		}
		fetch(ixnew, d + 1, upd, f2, ' ', 0);
	}
	context_vec_ptr = context_vec_start - 1;
}

/* dump accumulated "unified" diff changes */
static void
dump_unified_vec(FILE *f1, FILE *f2)
{
	struct context_vec *cvp = context_vec_start;
	int lowa, upb, lowc, upd;
	int a, b, c, d;
	char ch, *f;

	if (context_vec_start > context_vec_ptr)
		return;

	b = d = 0;		/* gcc */
	lowa = max(1, cvp->a - context);
	upb = min(len[0], context_vec_ptr->b + context);
	lowc = max(1, cvp->c - context);
	upd = min(len[1], context_vec_ptr->d + context);

	fputs("@@@@ -", stdout);
	uni_range(lowa, upb);
	fputs(" +", stdout);
	uni_range(lowc, upd);
	fputs(" @@@@", stdout);
	if (pflag) {
		f = match_function(ixold, lowa-1, f1);
		if (f != NULL) {
			putchar(' ');
			fputs(f, stdout);
		}
	}
	putchar('\n');

	/*
	 * Output changes in "unified" diff format--the old and new lines
	 * are printed together.
	 */
	for (; cvp <= context_vec_ptr; cvp++) {
		a = cvp->a;
		b = cvp->b;
		c = cvp->c;
		d = cvp->d;

		/*
		 * c: both new and old changes
		 * d: only changes in the old file
		 * a: only changes in the new file
		 */
		if (a <= b && c <= d)
			ch = 'c';
		else
			ch = (a <= b) ? 'd' : 'a';

		switch (ch) {
		case 'c':
			fetch(ixold, lowa, a - 1, f1, ' ', 0);
			fetch(ixold, a, b, f1, '-', 0);
			fetch(ixnew, c, d, f2, '+', 0);
			break;
		case 'd':
			fetch(ixold, lowa, a - 1, f1, ' ', 0);
			fetch(ixold, a, b, f1, '-', 0);
			break;
		case 'a':
			fetch(ixnew, lowc, c - 1, f2, ' ', 0);
			fetch(ixnew, c, d, f2, '+', 0);
			break;
		}
		lowa = b + 1;
		lowc = d + 1;
	}
	fetch(ixnew, d + 1, upd, f2, ' ', 0);

	context_vec_ptr = context_vec_start - 1;
}

static void
print_header(const char *file1, const char *file2)
{
	if (label[0] != NULL)
		printf("%s %s\n", format == D_CONTEXT ? "***" : "---",
		    label[0]);
	else
		printf("%s %s\t%s", format == D_CONTEXT ? "***" : "---",
		    file1, ctime(&stb1.st_mtime));
	if (label[1] != NULL)
		printf("%s %s\n", format == D_CONTEXT ? "---" : "+++",
		    label[1]);
	else
		printf("%s %s\t%s", format == D_CONTEXT ? "---" : "+++",
		    file2, ctime(&stb2.st_mtime));
}
@


1.5
log
@merge
@
text
@d1 2
a2 2
/**	$MirBSD: src/usr.bin/diff/diffreg.c,v 1.4 2004/10/22 21:53:44 tg Exp $ */
/*	$OpenBSD: diffreg.c,v 1.60 2004/11/27 19:16:25 otto Exp $	*/
d70 1
a70 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.60 2004/11/27 19:16:25 otto Exp $";
d90 1
a90 1
__RCSID("$MirBSD: src/usr.bin/diff/diffreg.c,v 1.4 2004/10/22 21:53:44 tg Exp $");
d221 1
d1056 1
a1056 10
			if (label != NULL)
				printf("%s %s\n",
				    format == D_CONTEXT ? "***" : "---", label);
			else
				printf("%s %s\t%s",
				    format == D_CONTEXT ? "***" : "---", file1,
				    ctime(&stb1.st_mtime));
			printf("%s %s\t%s",
			    format == D_CONTEXT ? "---" : "+++", file2,
			    ctime(&stb2.st_mtime));
d1508 17
@


1.4
log
@merge; fix; whitespace; bump libc level
XXX untested
@
text
@d1 2
a2 2
/**	$MirBSD: src/usr.bin/diff/diffreg.c,v 1.3 2004/10/14 20:50:52 tg Exp $ */
/*	$OpenBSD: diffreg.c,v 1.59 2004/10/20 08:52:19 otto Exp $	*/
d69 4
d90 1
a90 1
__RCSID("$MirBSD: src/usr.bin/diff/diffreg.c,v 1.3 2004/10/14 20:50:52 tg Exp $");
d1283 1
a1283 1
	char buf[BUFSIZ];
d1310 1
a1310 1
	char buf[FUNCTION_CONTEXT_SIZE];
@


1.3
log
@merge openbsd; fix; enhance
@
text
@d1 2
a2 2
/**	$MirBSD$ */
/*	$OpenBSD: diffreg.c,v 1.58 2004/09/14 23:04:27 deraadt Exp $	*/
d86 1
a86 1
__RCSID("$MirBSD: src/usr.bin/diff/diffreg.c,v 1.2 2004/07/04 17:10:27 tg Stab $");
d1055 1
a1055 1
				printf("%s %s	%s",
d1058 1
a1058 1
			printf("%s %s	%s",
@


1.2
log
@only go more like gdiff if -du, not if -u
@
text
@d1 2
a2 2
/* $MirBSD$ */
/* $OpenBSD: diffreg.c,v 1.57 2004/06/20 18:47:45 otto Exp $	*/
d37 1
d86 1
a86 1
__RCSID("$MirBSD$");
d159 1
a159 1
} cand;
d426 1
a426 1
	clist = emalloc(clistlen * sizeof(cand));
d691 1
a691 1
		clist = erealloc(clist, clistlen * sizeof(cand));
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: diffreg.c,v 1.23 2003/06/27 20:28:13 tedu Exp $	*/
d37 30
d68 10
a77 2
#include <sys/types.h>

d79 1
a80 2
#include <fcntl.h>
#include <string.h>
d85 1
a85 3
#if 0
static char const sccsid[] = "@@(#)diffreg.c 4.21 4/6/90";
#endif
a153 4
#define	prints(s)	fputs(s,stdout)

FILE *input[2];

d165 40
a204 17
int len[2];
struct line *sfile[2];	/* shortened by pruning common prefix and suffix */
int slen[2];
int pref, suff;			/* length of prefix and suffix */
int *class;			/* will be overlaid on file[0] */
int *member;			/* will be overlaid on file[1] */
int *klist;			/* will be overlaid on file[0] after class */
struct cand *clist;		/* merely a free storage pot for candidates */
int clen = 0;
int *J;				/* will be overlaid on class */
long *ixold;			/* will be overlaid on klist */
long *ixnew;			/* will be overlaid on file[1] */
u_char *chrtran;		/* translation table for case-folding */

static void fetch(long *, int, int, FILE *, char *, int);
static void output(void);
static void check(void);
d206 4
a209 3
static void dump_context_vec(void);
static void dump_unified_vec(void);
static void prepare(int, FILE *);
d214 1
a214 1
static void change(int, int, int, int);
d216 15
a230 6
static int newcand(int, int, int);
static int search(int *, int, int);
static int skipline(int);
static int asciifile(FILE *);
static int stone(int *, int, int *, int *);
static int readhash(FILE *);
d290 2
a291 2
void
diffreg(void)
d293 17
a309 3
	char buf1[BUFSIZ], buf2[BUFSIZ];
	FILE *f1, *f2;
	int i, j;
d311 40
a350 4
	if (hflag) {
		diffargv[0] = "diffh";
		execv(diffh, diffargv);
		error("%s", diffh);
d352 10
a361 42
	chrtran = (iflag ? cup2low : clow2low);
	if (strcmp(file1, "-") == 0 && strcmp(file2, "-") == 0)
		errorx("can't specify - -");
	if (S_ISDIR(stb1.st_mode)) {
		file1 = splice(file1, file2);
		if (stat(file1, &stb1) < 0)
			error("%s", file1);
	} else if (!S_ISREG(stb1.st_mode) || strcmp(file1, "-") == 0) {
		file1 = copytemp(file1, 1);
		if (stat(file1, &stb1) < 0)
			error("%s", file1);
	}
	if (S_ISDIR(stb2.st_mode)) {
		file2 = splice(file2, file1);
		if (stat(file2, &stb2) < 0)
			error("%s", file2);
	} else if (!S_ISREG(stb2.st_mode) || strcmp(file2, "-") == 0) {
		file2 = copytemp(file2, 2);
		if (stat(file2, &stb2) < 0)
			error("%s", file2);
	}
	if ((f1 = fopen(file1, "r")) == NULL)
		error("%s", file1);
	if ((f2 = fopen(file2, "r")) == NULL)
		error("%s", file2);
	if (S_ISREG(stb1.st_mode) && S_ISREG(stb2.st_mode) &&
	    stb1.st_size != stb2.st_size)
		goto notsame;
	for (;;) {
		i = fread(buf1, 1, BUFSIZ, f1);
		j = fread(buf2, 1, BUFSIZ, f2);
		if (i < 0 || j < 0 || i != j)
			goto notsame;
		if (i == 0 && j == 0) {
			fclose(f1);
			fclose(f2);
			status = 0;	/* files don't differ */
			goto same;
		}
		for (j = 0; j < i; j++)
			if (buf1[j] != buf2[j])
				goto notsame;
d363 1
a363 5
notsame:
	/*
	 * Files certainly differ at this point; set status accordingly
	 */
	status = 1;
d365 45
a409 7
		printf("Binary files %s and %s differ\n", file1, file2);
		exit(status);
	}
	prepare(0, f1);
	prepare(1, f2);
	fclose(f1);
	fclose(f2);
d423 3
a425 1
	clist = emalloc(sizeof(cand));
d430 1
a430 1
	J = emalloc((len[0] + 2) * sizeof(int));
d435 32
a466 8
	ixold = emalloc((len[0] + 2) * sizeof(long));
	ixnew = emalloc((len[1] + 2) * sizeof(long));
	check();
	output();
	status = anychange;
same:
	if (anychange == 0 && (opt == D_CONTEXT || opt == D_UNIFIED))
		printf("No differences encountered\n");
d469 28
a496 1
char *tempfiles[2];
d498 2
a499 2
char *
copytemp(const char *file, int n)
d501 3
a503 5
	char buf[BUFSIZ], *tempdir, *tempfile;
	int i, ifd, ofd;

	if (n != 1 && n != 2)
		return (NULL);
d508 1
a508 1
		error("%s", file);
d512 16
a527 14
	if (asprintf(&tempfile, "%s/diff%d.XXXXXXXX", tempdir, n) == -1)
		error(NULL);
	tempfiles[n - 1] = tempfile;

	signal(SIGHUP, done);
	signal(SIGINT, done);
	signal(SIGPIPE, done);
	signal(SIGTERM, done);
	ofd = mkstemp(tempfile);
	if (ofd < 0)
		error("%s", tempfile);
	while ((i = read(ifd, buf, BUFSIZ)) > 0) {
		if (write(ofd, buf, i) != i)
			error("%s", tempfile);
d530 2
a531 2
	close(ofd);
	return (tempfile);
a537 1
	size_t len;
d539 1
a539 4
	if (!strcmp(file, "-"))
		errorx("can't specify - with other arg directory");
	tail = strrchr(file, '/');
	if (tail == NULL)
d543 1
a543 3
	len = strlen(dir) + 1 + strlen(tail) + 1;
	buf = emalloc(len);
	snprintf(buf, len, "%s/%s", dir, tail);
d548 1
a548 1
prepare(int i, FILE *fd)
d552 7
d560 1
a560 2
	fseek(fd, 0L, SEEK_SET);
	p = emalloc(3 * sizeof(struct line));
d562 5
a566 2
		p = erealloc(p, (++j + 3) * sizeof(struct line));
		p[j].value = h;
d621 19
d645 3
d658 1
d672 1
d678 1
a678 1
		} while ((y = b[++j]) > 0);
d688 5
a692 2
	clist = erealloc(clist, ++clen * sizeof(cand));
	q = clist + clen - 1;
d696 1
a696 1
	return (clen - 1);
d743 1
a743 1
check(void)
d748 2
a749 4
	if ((input[0] = fopen(file1, "r")) == NULL)
		error("%s", file1);
	if ((input[1] = fopen(file2, "r")) == NULL)
		error("%s", file2);
d756 1
a756 1
			ixold[i] = ctold += skipline(0);
d760 1
a760 1
			ixnew[j] = ctnew += skipline(1);
d765 11
a775 2
				c = getc(input[0]);
				d = getc(input[1]);
d783 1
a783 1
					} while (isspace(c = getc(input[0])));
d788 1
a788 1
					} while (isspace(d = getc(input[1])));
d791 1
a791 1
						c = getc(input[0]);
d795 1
a795 1
						d = getc(input[1]);
d802 4
a805 4
					if (c != '\n')
						ctold += skipline(0);
					if (d != '\n')
						ctnew += skipline(1);
d808 1
a808 1
				if (c == '\n')
d815 1
a815 1
				if ((c = getc(input[0])) != (d = getc(input[1]))) {
d818 4
a821 4
					if (c != '\n')
						ctold += skipline(0);
					if (d != '\n')
						ctnew += skipline(1);
d824 1
a824 1
				if (c == '\n')
d832 2
a833 5
	for (; j <= len[1]; j++) {
		ixnew[j] = ctnew += skipline(1);
	}
	fclose(input[0]);
	fclose(input[1]);
d887 1
a887 1
skipline(int f)
d891 2
a892 3
	for (i = 1; (c = getc(input[f])) != '\n'; i++)
		if (c < 0)
			return (i);
d897 1
a897 1
output(void)
d901 2
a902 2
	input[0] = fopen(file1, "r");
	input[1] = fopen(file2, "r");
d906 1
a906 1
	if (opt != D_EDIT) {
d916 1
a916 1
			change(i0, i1, j0, j1);
d928 1
a928 1
			change(i1, i0, j1, j0);
d932 2
a933 2
		change(1, 0, 1, len[1]);
	if (opt == D_IFDEF) {
d936 1
a936 2
			c = getc(input[0]);
			if (c < 0)
d943 4
a946 4
		if (opt == D_CONTEXT)
			dump_context_vec();
		else if (opt == D_UNIFIED)
			dump_unified_vec();
d950 31
a980 11
/*
 * The following struct is used to record change information when
 * doing a "context" diff.  (see routine "change" to understand the
 * highly mneumonic field names)
 */
struct context_vec {
	int a;			/* start line in old file */
	int b;			/* end line in old file */
	int c;			/* start line in new file */
	int d;			/* end line in new file */
};
d982 4
a985 1
struct context_vec *context_vec_start, *context_vec_end, *context_vec_ptr;
d987 4
a990 1
#define	MAX_CONTEXT	128
d993 2
a994 2
 * indicate that there is a difference between lines a and b of the from file
 * to get to lines c to d of the to file. If a is greater then b then there
d996 1
a996 1
 * lines appended (beginning at b). If c is greater than d then there are
d1000 1
a1000 1
change(int a, int b, int c, int d)
d1002 2
a1003 1
	struct stat stbuf;
d1005 2
a1006 1
	if (opt != D_IFDEF && a > b && c > d)
d1008 22
a1029 13
	if (anychange == 0) {
		anychange = 1;
		if (opt == D_CONTEXT || opt == D_UNIFIED) {
			stat(file1, &stbuf);
			printf("%s %s	%s", opt == D_CONTEXT ? "***" : "---",
			   file1, ctime(&stbuf.st_mtime));
			stat(file2, &stbuf);
			printf("%s %s	%s", opt == D_CONTEXT ? "---" : "+++",
			    file2, ctime(&stbuf.st_mtime));
			context_vec_start = emalloc(MAX_CONTEXT *
			    sizeof(struct context_vec));
			context_vec_end = context_vec_start + MAX_CONTEXT;
			context_vec_ptr = context_vec_start - 1;
d1031 1
d1033 2
a1034 1
	if (opt == D_CONTEXT || opt == D_UNIFIED) {
d1036 1
a1036 5
		 * If this new change is within 'context' lines of
		 * the previous change, just add it to the change
		 * record.  If the record is full or if this
		 * change is more than 'context' lines from the previous
		 * change, dump the record, reset it & add the new change.
d1038 31
a1068 6
		if (context_vec_ptr >= context_vec_end ||
		    (context_vec_ptr >= context_vec_start &&
		    a > (context_vec_ptr->b + 2 * context) &&
		    c > (context_vec_ptr->d + 2 * context))) {
			if (opt == D_CONTEXT)
				dump_context_vec();
d1070 1
a1070 1
				dump_unified_vec();
d1079 3
a1081 1
	switch (opt) {
d1083 2
d1089 1
a1089 1
		if (opt == D_NORMAL)
d1109 22
a1130 8
	if (opt == D_NORMAL || opt == D_IFDEF) {
		fetch(ixold, a, b, input[0], "< ", 1);
		if (a <= b && c <= d && opt == D_NORMAL)
			prints("---\n");
	}
	fetch(ixnew, c, d, input[1], opt == D_NORMAL ? "> " : "", 0);
	if ((opt == D_EDIT || opt == D_REVERSE) && c <= d)
		prints(".\n");
d1132 1
a1132 1
		fprintf(stdout, "#endif /* %s */\n", ifdefname);
d1137 2
a1138 10
static void
range(int a, int b, char *separator)
{
	printf("%d", a > b ? b : a);
	if (a < b)
		printf("%s%d", separator, b);
}

static void
fetch(long *f, int a, int b, FILE *lb, char *s, int oldfile)
d1140 1
a1140 1
	int i, j, c, col, nc;
d1146 1
a1146 1
	if (opt == D_IFDEF && oldfile) {
d1154 2
a1155 2
		return;
	if (opt == D_IFDEF) {
d1157 1
a1157 1
			fprintf(stdout, "#else /* %s%s */\n",
d1161 1
a1161 1
				fprintf(stdout, "#ifndef %s\n", ifdefname);
d1163 1
a1163 1
				fprintf(stdout, "#ifdef %s\n", ifdefname);
d1170 8
a1177 2
		if (opt != D_IFDEF)
			prints(s);
d1179 11
a1189 4
		for (j = 0; j < nc; j++) {
			c = getc(lb);
			if (c == '\t' && tflag)
				do
d1191 14
a1204 2
				while (++col & 7);
			else {
d1210 1
a1212 5
#define POW2			/* define only if HALFLONG is 2**n */
#define HALFLONG 16
#define low(x)	(x&((1L<<HALFLONG)-1))
#define high(x)	(x>>HALFLONG)

d1214 1
a1214 3
 * hashing has the effect of
 * arranging line in 7-bit bytes and then
 * summing 1-s complement in 16-bit hunks
d1219 2
a1220 3
	unsigned int shift;
	int t, space;
	long sum;
d1226 7
a1232 9
			for (shift = 0; (t = getc(f)) != '\n'; shift += 7) {
				if (t == -1)
					return (0);
				sum += (long)chrtran[t] << (shift
#ifdef POW2
				    &= HALFLONG - 1);
#else
				    %= HALFLONG);
#endif
d1235 7
a1241 9
			for (shift = 0; (t = getc(f)) != '\n'; shift += 7) {
				if (t == -1)
					return (0);
				sum += (long)t << (shift
#ifdef POW2
				    &= HALFLONG - 1);
#else
				    %= HALFLONG);
#endif
d1244 1
a1244 1
		for (shift = 0;;) {
a1245 2
			case -1:
				return (0);
d1252 1
a1252 1
					shift += 7;
d1255 2
a1256 7
				sum += (long)chrtran[t] << (shift
#ifdef POW2
				    &= HALFLONG - 1);
#else
				    %= HALFLONG);
#endif
				shift += 7;
d1258 4
d1268 5
a1272 2
	sum = low(sum) + high(sum);
	return ((short) low(sum) + (short) high(sum));
d1278 2
a1279 2
	char buf[BUFSIZ], *cp;
	int cnt;
d1281 1
a1281 1
	if (aflag)
d1284 4
a1287 5
	fseek(f, 0L, SEEK_SET);
	cnt = fread(buf, 1, BUFSIZ, f);
	cp = buf;
	while (--cnt >= 0)
		if (*cp++ & 0200)
d1292 41
d1335 1
a1335 1
dump_context_vec(void)
d1340 1
a1340 1
	char ch;
d1351 9
a1359 1
	printf("***************\n*** ");
d1364 1
a1364 1
	 * output changes to the "old" file.  The first loop suppresses
d1388 1
a1388 1
				fetch(ixold, lowa, b, input[0], "  ", 0);
d1390 3
a1392 3
				fetch(ixold, lowa, a - 1, input[0], "  ", 0);
				fetch(ixold, a, b, input[0],
				    ch == 'c' ? "! " : "- ", 0);
d1397 1
a1397 1
		fetch(ixold, b + 1, upb, input[0], "  ", 0);
d1424 1
a1424 1
				fetch(ixnew, lowc, d, input[1], "  ", 0);
d1426 3
a1428 3
				fetch(ixnew, lowc, c - 1, input[1], "  ", 0);
				fetch(ixnew, c, d, input[1],
				    ch == 'c' ? "! " : "+ ", 0);
d1433 1
a1433 1
		fetch(ixnew, d + 1, upd, input[1], "  ", 0);
d1440 1
a1440 1
dump_unified_vec(void)
d1445 1
a1445 1
	char ch;
d1456 13
a1468 2
	printf("@@@@ -%d,%d +%d,%d @@@@\n", lowa, upb - lowa + 1,
	    lowc, upd - lowc + 1);
d1492 3
a1494 3
			fetch(ixold, lowa, a - 1, input[0], " ", 0);
			fetch(ixold, a, b, input[0], "-", 0);
			fetch(ixnew, c, d, input[1], "+", 0);
d1497 2
a1498 2
			fetch(ixold, lowa, a - 1, input[0], " ", 0);
			fetch(ixold, a, b, input[0], "-", 0);
d1501 2
a1502 2
			fetch(ixnew, lowc, c - 1, input[1], " ", 0);
			fetch(ixnew, c, d, input[1], "+", 0);
d1508 1
a1508 1
	fetch(ixnew, d + 1, upd, input[1], " ", 0);
@


1.1.1.1
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@@


1.1.1.2
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.26 2003/07/04 17:37:07 millert Exp $	*/
a136 1
int inifdef;			/* whether or not we are in a #ifdef block */
d232 5
d244 1
a244 2
	} else if (strcmp(file1, "-") == 0 ||
	    (!S_ISREG(stb1.st_mode) && strcmp(file1, _PATH_DEVNULL) != 0)) {
d253 1
a253 2
	} else if (strcmp(file2, "-") == 0 ||
	    (!S_ISREG(stb2.st_mode) && strcmp(file2, _PATH_DEVNULL) != 0)) {
d262 1
a262 1
	if ((stb1.st_mode & S_IFMT) != (stb2.st_mode & S_IFMT) ||
@


1.1.1.3
log
@Sync some stuff with OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.28 2003/07/06 22:17:21 millert Exp $	*/
a35 34
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)diffreg.c   8.1 (Berkeley) 6/6/93
 */

#ifndef lint
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.28 2003/07/06 22:17:21 millert Exp $";
#endif /* not lint */
a37 1
#include <sys/stat.h>
d39 2
a40 2
#include <ctype.h>
#include <err.h>
a41 5
#include <libgen.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
a42 1
#include <unistd.h>
d45 5
d118 4
d133 14
a146 15
static int  *J;			/* will be overlaid on class */
static int  *class;		/* will be overlaid on file[0] */
static int  *klist;		/* will be overlaid on file[0] after class */
static int  *member;		/* will be overlaid on file[1] */
static int   clen;
static int   inifdef;		/* whether or not we are in a #ifdef block */
static int   len[2];
static int   pref, suff;	/* length of prefix and suffix */
static int   slen[2];
static int   anychange;
static long *ixnew;		/* will be overlaid on file[1] */
static long *ixold;		/* will be overlaid on klist */
static struct cand *clist;	/* merely a free storage pot for candidates */
static struct line *sfile[2];	/* shortened by pruning common prefix/suffix */
static u_char *chrtran;		/* translation table for case-folding */
d149 2
a150 2
static void output(char *, FILE *, char *, FILE *);
static void check(char *, FILE *, char *, FILE *);
d152 2
a153 2
static void dump_context_vec(FILE *, FILE *);
static void dump_unified_vec(FILE *, FILE *);
d159 1
a159 1
static void change(char *, FILE *, char *, FILE *, int, int, int, int);
d161 6
a166 7
static int  asciifile(FILE *);
static int  newcand(int, int, int);
static int  search(int *, int, int);
static int  skipline(FILE *);
static int  stone(int *, int, int *, int *);
static int  readhash(FILE *);
static int  files_differ(FILE *, FILE *, int);
d227 1
a227 1
diffreg(char *ofile1, char *ofile2, int flags)
d229 3
a231 5
	char *file1 = ofile1;
	char *file2 = ofile2;
	FILE *f1 = NULL;
	FILE *f2 = NULL;
	int i;
a232 1
	anychange = 0;
d235 27
d263 14
a276 52

	/* XXX - only make temp file for stdin if not seekable? (millert) */
	if (flags & D_EMPTY1)
		f1 = fopen(_PATH_DEVNULL, "r");
	else {
		if (S_ISDIR(stb1.st_mode)) {
			file1 = splice(file1, file2);
			if (stat(file1, &stb1) < 0) {
				warn("%s", file1);
				status |= 2;
				goto closem;
			}
		} else if (strcmp(file1, "-") == 0 || !S_ISREG(stb1.st_mode)) {
			file1 = copytemp(file1, 1);
			if (file1 == NULL || stat(file1, &stb1) < 0) {
				warn("%s", file1);
				status |= 2;
				goto closem;
			}
		}
		f1 = fopen(file1, "r");
	}
	if (f1 == NULL) {
		warn("%s", file1);
		status |= 2;
		goto closem;
	}

	if (flags & D_EMPTY2)
		f2 = fopen(_PATH_DEVNULL, "r");
	else {
		if (S_ISDIR(stb2.st_mode)) {
			file2 = splice(file2, file1);
			if (stat(file2, &stb2) < 0) {
				warn("%s", file2);
				status |= 2;
				goto closem;
			}
		} else if (strcmp(file2, "-") == 0 || !S_ISREG(stb2.st_mode)) {
			file2 = copytemp(file2, 2);
			if (file2 == NULL || stat(file2, &stb2) < 0) {
				warn("%s", file2);
				status |= 2;
				goto closem;
			}
		}
		f2 = fopen(file2, "r");
	}
	if (f2 == NULL) {
		warn("%s", file2);
		status |= 2;
		goto closem;
a277 12

	switch (files_differ(f1, f2, flags)) {
	case 0:
		goto same;
	case 1:
		break;
	default:
		/* error */
		status |= 2;
		goto closem;
	}

d282 1
a282 11
	status |= 1;
	if (format == D_BRIEF) {
		printf("Files %s and %s differ\n", file1, file2);
		goto closem;
	}
	if (flags & D_HEADER) {
		if (format == D_EDIT)
			printf("ed - %s << '-*-END-*-'\n", basename(file1));
		else
			printf("%s %s %s\n", diffargs, file1, file2);
	}
d285 1
a285 1
		goto closem;
d289 2
d309 1
a309 1
	J = erealloc(J, (len[0] + 2) * sizeof(int));
d314 5
a318 6
	ixold = erealloc(ixold, (len[0] + 2) * sizeof(long));
	ixnew = erealloc(ixnew, (len[1] + 2) * sizeof(long));
	check(file1, f1, file2, f2);
	output(file1, f1, file2, f2);
	if ((flags & D_HEADER) && format == D_EDIT)
		printf("w\nq\n-*-END-*-\n");
d320 2
a321 51
	if (anychange == 0 && sflag != 0)
		printf("Files %s and %s are identical\n", file1, file2);

closem:
	if (f1 != NULL)
		fclose(f1);
	if (f2 != NULL)
		fclose(f2);
	if (tempfiles[0] != NULL) {
		unlink(tempfiles[0]);
		free(tempfiles[0]);
		tempfiles[0] = NULL;
	}
	if (tempfiles[1] != NULL) {
		unlink(tempfiles[1]);
		free(tempfiles[1]);
		tempfiles[1] = NULL;
	}
	if (file1 != ofile1)
		free(file1);
	if (file2 != ofile2)
		free(file2);
}

/*
 * Check to see if the given files differ.
 * Returns 0 if they are the same, 1 if different, and -1 on error.
 * XXX - could use code from cmp(1) [faster]
 */
static int
files_differ(FILE *f1, FILE *f2, int flags)
{
	char buf1[BUFSIZ], buf2[BUFSIZ];
	size_t i, j;

	if ((flags & (D_EMPTY1|D_EMPTY2)) || stb1.st_size != stb2.st_size ||
	    (stb1.st_mode & S_IFMT) != (stb2.st_mode & S_IFMT))
		return (1);
	for (;;) {
		i = fread(buf1, 1, sizeof(buf1), f1);
		j = fread(buf2, 1, sizeof(buf2), f2);
		if (i != j)
			return (1);
		if (i == 0 && j == 0) {
			if (ferror(f1) || ferror(f2))
				return (1);
			return (0);
		}
		if (memcmp(buf1, buf2, i) != 0)
			return (1);
	}
a325 1
/* XXX - pass back a FILE * too (millert) */
d338 1
a338 1
		return (NULL);
d343 1
a343 1
		return (NULL);
d346 4
a349 4
	signal(SIGHUP, quit);
	signal(SIGINT, quit);
	signal(SIGPIPE, quit);
	signal(SIGTERM, quit);
d352 1
a352 1
		return (NULL);
d355 1
a355 1
			return (NULL);
d368 2
d387 1
a387 1
	rewind(fd);
d541 1
a541 1
check(char *file1, FILE *f1, char *file2, FILE *f2)
d546 4
a549 2
	rewind(f1);
	rewind(f2);
d556 1
a556 1
			ixold[i] = ctold += skipline(f1);
d560 1
a560 1
			ixnew[j] = ctnew += skipline(f2);
d565 2
a566 2
				c = getc(f1);
				d = getc(f2);
d574 1
a574 1
					} while (isspace(c = getc(f1)));
d579 1
a579 1
					} while (isspace(d = getc(f2)));
d582 1
a582 1
						c = getc(f1);
d586 1
a586 1
						d = getc(f2);
d594 1
a594 1
						ctold += skipline(f1);
d596 1
a596 1
						ctnew += skipline(f2);
d606 1
a606 1
				if ((c = getc(f1)) != (d = getc(f2))) {
d610 1
a610 1
						ctold += skipline(f1);
d612 1
a612 1
						ctnew += skipline(f2);
d623 5
a627 2
	for (; j <= len[1]; j++)
		ixnew[j] = ctnew += skipline(f2);
d681 1
a681 1
skipline(FILE *f)
d685 1
a685 1
	for (i = 1; (c = getc(f)) != '\n'; i++)
d692 1
a692 1
output(char *file1, FILE *f1, char *file2, FILE *f2)
d696 2
a697 2
	rewind(f1);
	rewind(f2);
d701 1
a701 1
	if (format != D_EDIT) {
d711 1
a711 1
			change(file1, f1, file2, f2, i0, i1, j0, j1);
d723 1
a723 1
			change(file1, f1, file2, f2, i1, i0, j1, j0);
d727 2
a728 2
		change(file1, f1, file2, f2, 1, 0, 1, len[1]);
	if (format == D_IFDEF) {
d731 1
a731 1
			c = getc(f1);
d739 4
a742 4
		if (format == D_CONTEXT)
			dump_context_vec(f1, f2);
		else if (format == D_UNIFIED)
			dump_unified_vec(f1, f2);
d748 2
a749 2
 * doing a "context" or "unified" diff.  (see routine "change" to
 * understand the highly mnemonic field names)
d763 2
a764 2
 * Indicate that there is a difference between lines a and b of the from file
 * to get to lines c to d of the to file.  If a is greater then b then there
d766 1
a766 1
 * lines appended (beginning at b).  If c is greater than d then there are
d770 1
a770 1
change(char *file1, FILE *f1, char *file2, FILE *f2, int a, int b, int c, int d)
d772 3
a774 1
	if (format != D_IFDEF && a > b && c > d)
d778 9
a786 8
		if (format == D_CONTEXT || format == D_UNIFIED) {
			printf("%s %s	%s", format == D_CONTEXT ? "***" : "---",
			   file1, ctime(&stb1.st_mtime));
			printf("%s %s	%s", format == D_CONTEXT ? "---" : "+++",
			    file2, ctime(&stb2.st_mtime));
			if (context_vec_start == NULL)
				context_vec_start = emalloc(MAX_CONTEXT *
				    sizeof(struct context_vec));
d791 1
a791 1
	if (format == D_CONTEXT || format == D_UNIFIED) {
d803 2
a804 2
			if (format == D_CONTEXT)
				dump_context_vec(f1, f2);
d806 1
a806 1
				dump_unified_vec(f1, f2);
d815 1
a815 1
	switch (format) {
d821 1
a821 1
		if (format == D_NORMAL)
d841 8
a848 8
	if (format == D_NORMAL || format == D_IFDEF) {
		fetch(ixold, a, b, f1, "< ", 1);
		if (a <= b && c <= d && format == D_NORMAL)
			puts("---");
	}
	fetch(ixnew, c, d, f2, format == D_NORMAL ? "> " : "", 0);
	if ((format == D_EDIT || format == D_REVERSE) && c <= d)
		puts(".");
d872 1
a872 1
	if (format == D_IFDEF && oldfile) {
d881 1
a881 1
	if (format == D_IFDEF) {
d896 2
a897 2
		if (format != D_IFDEF)
			fputs(s, stdout);
d987 1
a987 1
int
d993 1
a993 1
	if (aflag || f == NULL)
d996 2
a997 2
	rewind(f);
	cnt = fread(buf, 1, sizeof(buf), f);
a1004 10
static __inline int min(int a, int b)
{
	return (a < b ? a : b);
}

static __inline int max(int a, int b)
{
	return (a > b ? a : b);
}

d1007 1
a1007 1
dump_context_vec(FILE *f1, FILE *f2)
d1028 1
a1028 1
	 * Output changes to the "old" file.  The first loop suppresses
d1052 1
a1052 1
				fetch(ixold, lowa, b, f1, "  ", 0);
d1054 2
a1055 2
				fetch(ixold, lowa, a - 1, f1, "  ", 0);
				fetch(ixold, a, b, f1,
d1061 1
a1061 1
		fetch(ixold, b + 1, upb, f1, "  ", 0);
d1088 1
a1088 1
				fetch(ixnew, lowc, d, f2, "  ", 0);
d1090 2
a1091 2
				fetch(ixnew, lowc, c - 1, f2, "  ", 0);
				fetch(ixnew, c, d, f2,
d1097 1
a1097 1
		fetch(ixnew, d + 1, upd, f2, "  ", 0);
d1104 1
a1104 1
dump_unified_vec(FILE *f1, FILE *f2)
d1145 3
a1147 3
			fetch(ixold, lowa, a - 1, f1, " ", 0);
			fetch(ixold, a, b, f1, "-", 0);
			fetch(ixnew, c, d, f2, "+", 0);
d1150 2
a1151 2
			fetch(ixold, lowa, a - 1, f1, " ", 0);
			fetch(ixold, a, b, f1, "-", 0);
d1154 2
a1155 2
			fetch(ixnew, lowc, c - 1, f2, " ", 0);
			fetch(ixnew, c, d, f2, "+", 0);
d1161 1
a1161 1
	fetch(ixnew, d + 1, upd, f2, " ", 0);
@


1.1.1.4
log
@Most recent fixes from anoncvs.comstyle.com in:
ports/shells/ast-ksh src/usr.bin/compress src/usr.bin/diff src/sys/netinet6
 src/sys/netinet

From: Christian Weisgerber <naddy@@cvs.openbsd.org>
Log message:
Forced update to 2003-06-21 because older distfiles have been removed.

From: Michael Shalayeff <mickey@@cvs.openbsd.org>
Log message:
fix fd closing logicand close in gzopen(); found by wilfried@@ and millert@@ ok

From: Todd C. Miller <millert@@cvs.openbsd.org>
Log message:
o Avoid a temp file if using stdin and stdin is redirected from a regular file
o Fix a double free in the temmp file case

From: Jun-ichiro itojun Hagino <itojun@@cvs.openbsd.org>
Log message:
on interface removal, clear multicast forwarding stuff.  from kame

From: Markus Friedl <markus@@cvs.openbsd.org>
Log message:
make sure the packets contains a complete inner header
for ip{4,6}-in-ip{4,6} encapsulation; fixes panic
for truncated ip-in-ip over ipsec; ok angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.30 2003/07/08 04:51:30 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.30 2003/07/08 04:51:30 millert Exp $";
d285 1
a285 1
		} else if (!S_ISREG(stb1.st_mode)) {
d293 1
a293 4
		if (strcmp(file1, "-") == 0)
			f1 = stdin;
		else
			f1 = fopen(file1, "r");
d311 1
a311 1
		} else if (!S_ISREG(stb2.st_mode)) {
d319 1
a319 4
		if (strcmp(file2, "-") == 0)
			f2 = stdin;
		else
			f2 = fopen(file2, "r");
d401 1
a401 2
	} else if (file1 != ofile1)
		free(file1);
d406 4
a409 1
	} else if (file2 != ofile2)
@


1.1.1.5
log
@Bring the entire base system and ports tree in sync with OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.32 2003/07/09 00:39:26 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.32 2003/07/09 00:39:26 millert Exp $";
d71 1
a71 1
#include <sys/param.h>
a72 1
#include <sys/wait.h>
a75 1
#include <errno.h>
d78 2
a85 1
#include "pathnames.h"
a180 1
static FILE *opentemp(const char *);
d260 1
a260 1
int
d267 1
a267 3
	int rval = D_SAME;
	int i, ostdout = -1;
	pid_t pid = -1;
a270 2
	if (S_ISDIR(stb1.st_mode) != S_ISDIR(stb2.st_mode))
		return (D_MISMATCH);
d274 1
d278 10
a287 3
		if (!S_ISREG(stb1.st_mode)) {
			if ((f1 = opentemp(file1)) == NULL ||
			    fstat(fileno(f1), &stb1) < 0) {
d292 2
a293 1
		} else if (strcmp(file1, "-") == 0)
d307 10
a316 3
		if (!S_ISREG(stb2.st_mode)) {
			if ((f2 = opentemp(file2)) == NULL ||
			    fstat(fileno(f2), &stb2) < 0) {
d321 2
a322 1
		} else if (strcmp(file2, "-") == 0)
d335 1
a335 1
		goto closem;
d349 2
a350 3
	rval = D_DIFFER;
	if (!asciifile(f1) || !asciifile(f2)) {
		rval = D_BINARY;
d353 8
a360 1
	if (format == D_BRIEF)
a361 45
	if (lflag) {
		/* redirect stdout to pr */
		int pfd[2];
		char *header;
		char *prargv[] = { "pr", "-h", NULL, "-f", NULL };

		easprintf(&header, "%s %s %s", diffargs, file1, file2);
		prargv[2] = header;
		fflush(stdout);
		rewind(stdout);
		pipe(pfd);
		switch ((pid = fork())) {
		case -1:
			warnx("No more processes");
			status |= 2;
			free(header);
			return (D_ERROR);
		case 0:
			/* child */
			if (pfd[0] != STDIN_FILENO) {
				dup2(pfd[0], STDIN_FILENO);
				close(pfd[0]);
			}
			close(pfd[1]);
			execv(_PATH_PR, prargv);
			_exit(127);
		default:
			/* parent */
			if (pfd[1] != STDOUT_FILENO) {
				ostdout = dup(STDOUT_FILENO);
				dup2(pfd[1], STDOUT_FILENO);
				close(pfd[1]);
			}
			close(pfd[0]);
			rewind(stdout);
			free(header);
		}
	} else {
		if (flags & D_HEADER) {
			if (format == D_EDIT)
				printf("ed - %s << '-*-END-*-'\n",
				    basename(file1));
			else
				printf("%s %s %s\n", diffargs, file1, file2);
		}
d392 5
a396 2
	if (ostdout != -1) {
		int wstatus;
a397 11
		/* close the pipe to pr and restore stdout */
		fflush(stdout);
		rewind(stdout);
		if (ostdout != STDOUT_FILENO) {
			close(STDOUT_FILENO);
			dup2(ostdout, STDOUT_FILENO);
			close(ostdout);
		}
		waitpid(pid, &wstatus, 0);
	} else if ((flags & D_HEADER) && format == D_EDIT)
		printf("w\nq\n-*-END-*-\n");
d403 5
a407 1
	if (file1 != ofile1)
d409 5
a413 1
	if (file2 != ofile2)
a414 1
	return (rval);
d446 5
a450 2
static FILE *
opentemp(const char *file)
d452 5
a456 3
	char buf[BUFSIZ], *tempdir, tempfile[MAXPATHLEN];
	ssize_t nread;
	int ifd, ofd;
d465 1
a465 4
	if (snprintf(tempfile, sizeof(tempfile), "%s/diff.XXXXXXXX",
	    tempdir) >= sizeof(tempfile)) {
		close(ifd);
		errno = ENAMETOOLONG;
d467 1
a467 1
	}
d469 6
a474 1
	if ((ofd = mkstemp(tempfile)) < 0)
d476 2
a477 5
	unlink(tempfile);
	while ((nread = read(ifd, buf, BUFSIZ)) > 0) {
		if (write(ofd, buf, nread) != nread) {
			close(ifd);
			close(ofd);
a478 1
		}
d481 2
a482 1
	return (fdopen(ofd, "r"));
d489 1
d491 2
a492 1
	if ((tail = strrchr(file, '/')) == NULL)
d496 3
a498 1
	easprintf(&buf, "%s/%s", dir, tail);
d963 1
a963 1
		printf("#endif /* %s */\n", ifdefname);
d996 1
a996 1
			printf("#else /* %s%s */\n",
d1000 1
a1000 1
				printf("#ifndef %s\n", ifdefname);
d1002 1
a1002 1
				printf("#ifdef %s\n", ifdefname);
@


1.1.1.6
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.35 2003/07/17 21:54:28 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.35 2003/07/17 21:54:28 millert Exp $";
a186 1
static void uni_range(int, int);
a706 9
				/*
				 * GNU diff ignores a missing newline
				 * in one file if bflag || wflag.
				 */
				if ((bflag || wflag) &&
				    ((c == EOF && d == '\n') ||
				    (c == '\n' && d == EOF))) {
					break;
				}
d733 1
a733 1
					if (c != '\n' && c != EOF)
d735 1
a735 1
					if (d != '\n' && c != EOF)
d739 1
a739 1
				if (c == '\n' || c == EOF)
d749 1
a749 1
					if (c != '\n' && c != EOF)
d751 1
a751 1
					if (d != '\n' && c != EOF)
d755 1
a755 1
				if (c == '\n' || c == EOF)
d822 3
a824 2
	for (i = 1; (c = getc(f)) != '\n' && c != EOF; i++)
		continue;
d868 2
a869 1
			if ((c = getc(f1)) == EOF)
a882 19
static __inline void
range(int a, int b, char *separator)
{
	printf("%d", a > b ? b : a);
	if (a < b)
		printf("%s%d", separator, b);
}

static __inline void
uni_range(int a, int b)
{
	if (a < b)
		printf("%d,%d", a, b - a + 1);
	else if (a == b)
		printf("%d", b);
	else
		printf("%d,0", b);
}

d990 8
d1034 3
a1036 6
			if ((c = getc(lb)) == EOF) {
				puts("\n\\ No newline at end of file");
				return;
			}
			if (c == '\t' && tflag) {
				do {
d1038 2
a1039 2
				} while (++col & 7);
			} else {
d1047 4
a1050 1
#define HASHMASK (16 - 1)	/* for masking out 16 bytes */
d1069 8
a1076 6
				if (t == EOF) {
					if (shift == 0)
						return (0);
					break;
				}
				sum += (long)chrtran[t] << (shift &= HASHMASK);
d1080 8
a1087 6
				if (t == EOF) {
					if (shift == 0)
						return (0);
					break;
				}
				sum += (long)t << (shift &= HASHMASK);
d1092 2
d1103 6
a1108 1
				sum += (long)chrtran[t] << (shift &= HASHMASK);
a1110 4
			case EOF:
				if (shift == 0)
					return (0);
				/* FALLTHROUGH */
d1117 2
a1118 1
	return (sum);
d1264 2
a1265 5
	fputs("@@@@ -", stdout);
	uni_range(lowa, upb);
	fputs(" +", stdout);
	uni_range(lowc, upd);
	fputs(" @@@@\n", stdout);
@


1.1.1.7
log
@Sync to OpenBSD 3.3-current
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.41 2003/07/22 01:16:01 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.41 2003/07/22 01:16:01 millert Exp $";
d79 1
a79 1
#include <stddef.h>
a165 12
/*
 * The following struct is used to record change information when
 * doing a "context" or "unified" diff.  (see routine "change" to
 * understand the highly mnemonic field names)
 */
struct context_vec {
	int a;			/* start line in old file */
	int b;			/* end line in old file */
	int c;			/* start line in new file */
	int d;			/* end line in new file */
};

a180 3
static struct context_vec *context_vec_start;
static struct context_vec *context_vec_end;
static struct context_vec *context_vec_ptr;
d183 1
a197 1
static int  fetch(long *, int, int, FILE *, int, int);
a274 1
	context_vec_ptr = context_vec_start - 1;
d277 1
a277 1
		return (S_ISDIR(stb1.st_mode) ? D_MISMATCH1 : D_MISMATCH2);
d383 9
a391 2
	} else if (flags & D_HEADER)
		printf("%s %s %s\n", diffargs, file1, file2);
d433 2
a434 1
	}
d911 16
a935 4
	static size_t max_context = 64;
	int i;

restart:
d938 14
d954 5
a958 1
		 * Allocate change records as needed.
d960 4
a963 29
		if (context_vec_ptr == context_vec_end - 1) {
			ptrdiff_t offset = context_vec_ptr - context_vec_start;
			max_context <<= 1;
			context_vec_start = erealloc(context_vec_start,
			    max_context * sizeof(struct context_vec));
			context_vec_end = context_vec_start + max_context;
			context_vec_ptr = context_vec_start + offset;
		}
		if (anychange == 0) {
			/*
			 * Print the context/unidiff header first time through.
			 */
			if (label != NULL)
				printf("%s %s\n",
				    format == D_CONTEXT ? "***" : "---", label);
			else
				printf("%s %s	%s",
				    format == D_CONTEXT ? "***" : "---", file1,
				    ctime(&stb1.st_mtime));
			printf("%s %s	%s",
			    format == D_CONTEXT ? "---" : "+++", file2,
			    ctime(&stb2.st_mtime));
			anychange = 1;
		} else if (a > context_vec_ptr->b + (2 * context) &&
		    c > context_vec_ptr->d + (2 * context)) {
			/*
			 * If this change is more than 'context' lines from the
			 * previous change, dump the record and reset it.
			 */
a975 2
	if (anychange == 0)
		anychange = 1;
d1003 1
a1003 1
		fetch(ixold, a, b, f1, '<', 1);
d1007 1
a1007 15
	i = fetch(ixnew, c, d, f2, format == D_NORMAL ? '>' : '\0', 0);
	if (i != 0 && format == D_EDIT) {
		/*
		 * A non-zero return value for D_EDIT indicates that the
		 * last line printed was a bare dot (".") that has been
		 * escaped as ".." to prevent ed(1) from misinterpreting
		 * it.  We have to add a substitute command to change this
		 * back and restart where we left off.
		 */
		puts(".");
		printf("%ds/^\\.\\././\n", a);
		a += i;
		c += i;
		goto restart;
	}
d1016 2
a1017 2
static int
fetch(long *f, int a, int b, FILE *lb, int ch, int oldfile)
d1019 1
a1019 1
	int i, j, c, lastc, col, nc;
d1033 1
a1033 1
		return (0);
d1049 2
a1050 8
		if (format != D_IFDEF && ch != '\0') {
			putchar(ch);
			if (Tflag && (format == D_NORMAL || format == D_CONTEXT
			    || format == D_UNIFIED))
				putchar('\t');
			else if (format != D_UNIFIED)
				putchar(' ');
		}
d1052 1
a1052 1
		for (j = 0, lastc = '\0'; j < nc; j++, lastc = c) {
d1055 1
a1055 1
				return (0);;
a1061 12
				if (format == D_EDIT && j == 1 && c == '\n'
				    && lastc == '.') {
					/*
					 * Don't print a bare "." line
					 * since that will confuse ed(1).
					 * Print ".." instead and return,
					 * giving the caller an offset
					 * from which to restart.
					 */
					puts(".");
					return (i - a + 1);
				}
a1066 1
	return (0);
d1207 1
a1207 1
				fetch(ixold, lowa, b, f1, ' ', 0);
d1209 1
a1209 1
				fetch(ixold, lowa, a - 1, f1, ' ', 0);
d1211 1
a1211 1
				    ch == 'c' ? '!' : '-', 0);
d1216 1
a1216 1
		fetch(ixold, b + 1, upb, f1, ' ', 0);
d1243 1
a1243 1
				fetch(ixnew, lowc, d, f2, ' ', 0);
d1245 1
a1245 1
				fetch(ixnew, lowc, c - 1, f2, ' ', 0);
d1247 1
a1247 1
				    ch == 'c' ? '!' : '+', 0);
d1252 1
a1252 1
		fetch(ixnew, d + 1, upd, f2, ' ', 0);
d1303 3
a1305 3
			fetch(ixold, lowa, a - 1, f1, ' ', 0);
			fetch(ixold, a, b, f1, '-', 0);
			fetch(ixnew, c, d, f2, '+', 0);
d1308 2
a1309 2
			fetch(ixold, lowa, a - 1, f1, ' ', 0);
			fetch(ixold, a, b, f1, '-', 0);
d1312 2
a1313 2
			fetch(ixnew, lowc, c - 1, f2, ' ', 0);
			fetch(ixnew, c, d, f2, '+', 0);
d1319 1
a1319 1
	fetch(ixnew, d + 1, upd, f2, ' ', 0);
@


1.1.1.8
log
@Import latest OpenBSD ports, XFree and source in sync
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.42 2003/07/23 22:01:36 tedu Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.42 2003/07/23 22:01:36 tedu Exp $";
d1174 1
a1174 1
	int i, cnt;
d1182 2
a1183 2
	for (i = 0; i < cnt; i++)
		if (!isprint(*cp) && !isspace(*cp))
@


1.1.1.9
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.48 2003/08/08 16:09:26 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.48 2003/08/08 16:09:26 otto Exp $";
a190 1
static int   clistlen;		/* the length of clist */
d204 1
a204 1
static void prepare(int, FILE *, off_t);
a215 1
static int  isqrt(int);
a218 3
static __inline int min(int, int);
static __inline int max(int, int);

d295 1
a295 1
		goto closem;
d350 1
d401 2
a402 2
	prepare(0, f1, stb1.st_size);
	prepare(1, f2, stb2.st_size);
d416 1
a416 3
	clen = 0;
	clistlen = 100;
	clist = emalloc(clistlen * sizeof(cand));
a515 1
	lseek(ofd, (off_t)0, SEEK_SET);
d533 1
a533 1
prepare(int i, FILE *fd, off_t filesize)
a536 1
	size_t sz;
d539 1
a539 6

	sz = (filesize <= SIZE_MAX ? filesize : SIZE_MAX) / 25;
	if (sz < 100)
		sz = 100;

	p = emalloc((sz + 3) * sizeof(struct line));
d541 2
a542 5
		if (j == sz) {
			sz = sz * 3 / 2;
			p = erealloc(p, (sz + 3) * sizeof(struct line));
		}
		p[++j].value = h;
a596 19
/* Code taken from ping.c */
static int
isqrt(int n)
{
	int y, x = 1;

	if (n == 0)
		return(0);

	do { /* newton was a stinker */
		y = x;
		x = n / x;
		x += y;
		x /= 2;
	} while ((x - y) > 1 || (x - y) < -1);

	return (x);
}

a601 3
	u_int loopcount;

	const u_int bound = dflag ? UINT_MAX : max(256, isqrt(n));
a611 1
		loopcount = 0;
a612 1
			loopcount++;
d630 1
a630 1
		} while ((y = b[++j]) > 0 && loopcount < bound);
d640 2
a641 5
	if (clen == clistlen) {
		clistlen = clistlen * 11 / 10;
		clist = erealloc(clist, clistlen * sizeof(cand));
	}
	q = clist + clen;
d645 1
a645 1
	return (clen++);
d1107 2
d1110 3
a1112 1
 * Hash function taken from Robert Sedgewick, Algorithms in C, 3d ed., p 578.
d1117 3
a1119 2
	int i, t, space;
	int sum;
d1125 1
a1125 1
			for (i = 0; (t = getc(f)) != '\n'; i++) {
d1127 1
a1127 1
					if (i == 0)
d1131 1
a1131 1
				sum = sum * 127 + chrtran[t];
d1134 1
a1134 1
			for (i = 0; (t = getc(f)) != '\n'; i++) {
d1136 1
a1136 1
					if (i == 0)
d1140 1
a1140 1
				sum = sum * 127 + t;
d1143 1
a1143 1
		for (i = 0;;) {
d1151 1
a1151 1
					i++;
d1154 2
a1155 2
				sum = sum * 127 + chrtran[t];
				i++;
d1158 1
a1158 1
				if (i == 0)
d1167 1
a1167 5
	/*
	 * There is a remote possibility that we end up with a zero sum.
	 * Zero is used as an EOF marker, so return 1 instead.
	 */
	return (sum == 0 ? 1 : sum);
@


1.1.1.10
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.49 2003/08/13 20:44:15 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.49 2003/08/13 20:44:15 millert Exp $";
d637 1
a637 1
	u_int numtries;
d650 1
a650 1
		numtries = 0;
d652 1
a664 1
				numtries++;
d670 1
a670 1
		} while ((y = b[++j]) > 0 && numtries < bound);
@


1.1.1.11
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.50 2003/09/07 07:53:01 tedu Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.50 2003/09/07 07:53:01 tedu Exp $";
d1215 1
a1215 1
	char buf[BUFSIZ];
d1223 1
d1225 1
a1225 1
		if (!isprint(buf[i]) && !isspace(buf[i]))
@


1.1.1.12
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.54 2003/11/22 18:02:44 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.54 2003/11/22 18:02:44 millert Exp $";
d355 5
a361 1
		status |= 1;
d364 2
a449 5
	if (anychange) {
		status |= 1;
		if (rval == D_SAME)
			rval = D_DIFFER;
	}
a1025 2
	case D_BRIEF:
		return;
d1122 2
a1123 6
				if (format == D_EDIT || format == D_REVERSE ||
				    format == D_NREVERSE)
					warnx("No newline at end of file");
				else
					puts("\n\\ No newline at end of file");
				return (0);
d1212 1
a1212 1
static int
@


1.1.1.13
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.55 2004/01/07 17:18:32 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.55 2004/01/07 17:18:32 otto Exp $";
a197 5
#define FUNCTION_CONTEXT_SIZE	41
static char lastbuf[FUNCTION_CONTEXT_SIZE];
static int lastline;
static int lastmatchline;

a222 1
static char *match_function(const long *, int, FILE *);
a294 2
	lastline = 0;
	lastmatchline = 0;
a1243 31
static char *
match_function(const long *f, int pos, FILE *file)
{
	char buf[FUNCTION_CONTEXT_SIZE];
	size_t nc;
	int last = lastline;
	char *p;

	lastline = pos;
	while (pos > last) {
		fseek(file, f[pos - 1], SEEK_SET);
		nc = f[pos] - f[pos - 1];
		if (nc >= sizeof(buf))
			nc = sizeof(buf) - 1;
		nc = fread(buf, 1, nc, file);
		if (nc > 0) {
			buf[nc] = '\0';
			p = strchr(buf, '\n');
			if (p != NULL)
				*p = '\0';
			if (isalpha(buf[0]) || buf[0] == '_' || buf[0] == '$') {
				strlcpy(lastbuf, buf, sizeof lastbuf);
				lastmatchline = pos;
				return lastbuf;
			}
		}
		pos--;
	}
	return lastmatchline > 0 ? lastbuf : NULL;
}

d1251 1
a1251 1
	char ch, *f;
d1262 1
a1262 9
	printf("***************");
	if (pflag) {
		f = match_function(ixold, lowa-1, f1);
		if (f != NULL) {
			putchar(' ');
			fputs(f, stdout);
		}
	}
	printf("\n*** ");
d1348 1
a1348 1
	char ch, *f;
d1363 1
a1363 9
	fputs(" @@@@", stdout);
	if (pflag) {
		f = match_function(ixold, lowa-1, f1);
		if (f != NULL) {
			putchar(' ');
			fputs(f, stdout);
		}
	}
	putchar('\n');
@


1.1.1.14
log
@die GNU diff die!
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.57 2004/06/20 18:47:45 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.57 2004/06/20 18:47:45 otto Exp $";
a216 1
static int  ignoreline(char *);
a228 1
static char *preadline(int, size_t, off_t);
a967 23
static char *
preadline(int fd, size_t len, off_t off)
{
	char *line;
	ssize_t nr;

	line = emalloc(len + 1);
	if ((nr = pread(fd, line, len, off)) < 0)
		err(1, "preadline");
	line[nr] = '\0';
	return (line);
}

static int
ignoreline(char *line)
{
	int ret;

	ret = regexec(&ignore_re, line, 0, NULL, 0);
	free(line);
	return (ret == 0);	/* if it matched, it should be ignored. */
}

a983 26
	if (ignore_pats != NULL) {
		char *line;
		/*
		 * All lines in the change, insert, or delete must
		 * match an ignore pattern for the change to be
		 * ignored.
		 */
		if (a <= b) {		/* Changes and deletes. */
			for (i = a; i <= b; i++) {
				line = preadline(fileno(f1),
				    ixold[i] - ixold[i - 1], ixold[i - 1]);
				if (!ignoreline(line))
					goto proceed;
			}
		}
		if (a > b || c <= d) {	/* Changes and inserts. */
			for (i = c; i <= d; i++) {
				line = preadline(fileno(f2),
				    ixnew[i] - ixnew[i - 1], ixnew[i - 1]);
				if (!ignoreline(line))
					goto proceed;
			}
		}
		return;
	}
proceed:
d1011 2
a1012 2
		} else if (a > context_vec_ptr->b + (2 * context) + 1 &&
		    c > context_vec_ptr->d + (2 * context) + 1) {
@


1.1.1.15
log
@updates for diff
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.58 2004/09/14 23:04:27 deraadt Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.58 2004/09/14 23:04:27 deraadt Exp $";
d159 1
a159 1
};
d426 1
a426 1
	clist = emalloc(clistlen * sizeof(struct cand));
d691 1
a691 1
		clist = erealloc(clist, clistlen * sizeof(struct cand));
@


1.1.1.16
log
@import some updates/fixes from openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.59 2004/10/20 08:52:19 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.59 2004/10/20 08:52:19 otto Exp $";
d1055 1
a1055 1
				printf("%s %s\t%s",
d1058 1
a1058 1
			printf("%s %s\t%s",
@


1.1.1.17
log
@some more fixes from otto@@openbsd, good work
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.60 2004/11/27 19:16:25 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.60 2004/11/27 19:16:25 otto Exp $";
d1279 1
a1279 1
	unsigned char buf[BUFSIZ];
d1306 1
a1306 1
	unsigned char buf[FUNCTION_CONTEXT_SIZE];
@


1.1.1.18
log
@mas patches for diff, madam
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.61 2004/12/09 18:56:10 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.61 2004/12/09 18:56:10 millert Exp $";
a216 1
static void print_header(const char *, const char *);
d1051 10
a1060 1
			print_header(file1, file2);
a1511 17
}

static void
print_header(const char *file1, const char *file2)
{
	if (label[0] != NULL)
		printf("%s %s\n", format == D_CONTEXT ? "***" : "---",
		    label[0]);
	else
		printf("%s %s\t%s", format == D_CONTEXT ? "***" : "---",
		    file1, ctime(&stb1.st_mtime));
	if (label[1] != NULL)
		printf("%s %s\n", format == D_CONTEXT ? "---" : "+++",
		    label[1]);
	else
		printf("%s %s\t%s", format == D_CONTEXT ? "---" : "+++",
		    file2, ctime(&stb2.st_mtime));
@


