head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.11
	tg-mergefixes-1-branch:1.1.1.11.0.4
	tg-mergefixes-1-base:1.1.1.11
	MIROS_X:1.1.1.11.0.2
	MIROS_X_BASE:1.1.1.11
	tg-mergetmp-3:1.1.1.11
	cvs-200411210200:1.1.1.11
	MIRBSD_XP_MIRPPC:1.1.1.10.0.4
	cvs-200411031540:1.1.1.11
	MIRBSD_XP_SPARC_BASE:1.1.1.10
	MIRBSD_XP_SPARC:1.1.1.10.0.2
	MIRBSD_7quater:1.1.1.8
	cvs-200405160640:1.1.1.10
	cvs-200401271800:1.1.1.9
	cvs-200401261630:1.1.1.9
	cvs-200401021645:1.1.1.9
	MIRBSD_7_ALPHA:1.1.1.8.0.6
	MIRBSD_7:1.1.1.8.0.4
	cvs-200312222040:1.1.1.9
	MIRBSD_7ter:1.1.1.8
	MIRBSD_7_DEV:1.1.1.8.0.2
	cvs-200310020700:1.1.1.8
	cvs-200309271030:1.1.1.7
	cvs-200309251530:1.1.1.7
	cvs-200308302005:1.1.1.7
	cvs-200308171200:1.1.1.7
	ctm-3496:1.1.1.6
	ctm-3449:1.1.1.5
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.3
	ctm-3425:1.1.1.3
	cvs-200307091500:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.53.11;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.53.11;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.55.17;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.07.18.13.52.56;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.07.22.15.02.40;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.07.26.13.24.19;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.08.11.18.45.27;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.08.17.14.45.42;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.10.02.07.50.20;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.12.22.21.13.53;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.05.16.08.10.31;	author tg;	state Stab;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.11.03.15.45.18;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: pch.c,v 1.11 2000/12/14 00:02:19 beck Exp $	*/

#ifndef lint
static char rcsid[] = "$OpenBSD: pch.c,v 1.11 2000/12/14 00:02:19 beck Exp $";
#endif /* not lint */

#include "EXTERN.h"
#include "common.h"
#include "util.h"
#include "INTERN.h"
#include "pch.h"

extern bool check_only;
/* Patch (diff listing) abstract type. */

static long p_filesize;			/* size of the patch file */
static LINENUM p_first;			/* 1st line number */
static LINENUM p_newfirst;		/* 1st line number of replacement */
static LINENUM p_ptrn_lines;		/* # lines in pattern */
static LINENUM p_repl_lines;		/* # lines in replacement text */
static LINENUM p_end = -1;		/* last line in hunk */
static LINENUM p_max;			/* max allowed value of p_end */
static LINENUM p_context = 3;		/* # of context lines */
static LINENUM p_input_line = 0;	/* current line # from patch file */
static char **p_line = Null(char**);	/* the text of the hunk */
static short *p_len = Null(short*);	/* length of each line */
static char *p_char = Nullch;		/* +, -, and ! */
static int hunkmax = INITHUNKMAX;	/* size of above arrays to begin with */
static int p_indent;			/* indent to patch */
static LINENUM p_base;			/* where to intuit this time */
static LINENUM p_bline;			/* line # of p_base */
static LINENUM p_start;			/* where intuit found a patch */
static LINENUM p_sline;			/* and the line number for it */
static LINENUM p_hunk_beg;		/* line number of current hunk */
static LINENUM p_efake = -1;		/* end of faked up lines--don't free */
static LINENUM p_bfake = -1;		/* beg of faked up lines */

/* Prepare to look for the next patch in the patch file. */

void
re_patch()
{
    p_first = Nulline;
    p_newfirst = Nulline;
    p_ptrn_lines = Nulline;
    p_repl_lines = Nulline;
    p_end = (LINENUM)-1;
    p_max = Nulline;
    p_indent = 0;
}

/* Open the patch file at the beginning of time. */

void
open_patch_file(filename)
char *filename;
{
    if (filename == Nullch || !*filename || strEQ(filename, "-")) {
	pfp = fopen(TMPPATNAME, "w");
	if (pfp == Nullfp)
	    pfatal2("can't create %s", TMPPATNAME);
	while (fgets(buf, sizeof buf, stdin) != Nullch)
	    fputs(buf, pfp);
	Fclose(pfp);
	filename = TMPPATNAME;
    }
    pfp = fopen(filename, "r");
    if (pfp == Nullfp)
	pfatal2("patch file %s not found", filename);
    Fstat(fileno(pfp), &filestat);
    p_filesize = filestat.st_size;
    next_intuit_at(0L,1L);			/* start at the beginning */
    set_hunkmax();
}

/* Make sure our dynamically realloced tables are malloced to begin with. */

void
set_hunkmax()
{
#ifndef lint
    if (p_line == Null(char**))
	p_line = (char**) malloc((MEM)hunkmax * sizeof(char *));
    if (p_len == Null(short*))
	p_len  = (short*) malloc((MEM)hunkmax * sizeof(short));
#endif
    if (p_char == Nullch)
	p_char = (char*)  malloc((MEM)hunkmax * sizeof(char));
}

/* Enlarge the arrays containing the current hunk of patch. */

void
grow_hunkmax()
{
    hunkmax *= 2;
    /* 
     * Note that on most systems, only the p_line array ever gets fresh memory
     * since p_len can move into p_line's old space, and p_char can move into
     * p_len's old space.  Not on PDP-11's however.  But it doesn't matter.
     */
    assert(p_line != Null(char**) && p_len != Null(short*) && p_char != Nullch);
#ifndef lint
    p_line = (char**) realloc((char*)p_line, (MEM)hunkmax * sizeof(char *));
    p_len  = (short*) realloc((char*)p_len,  (MEM)hunkmax * sizeof(short));
    p_char = (char*)  realloc((char*)p_char, (MEM)hunkmax * sizeof(char));
#endif
    if (p_line != Null(char**) && p_len != Null(short*) && p_char != Nullch)
	return;
    if (!using_plan_a)
	fatal1("out of memory\n");
    out_of_mem = TRUE;		/* whatever is null will be allocated again */
				/* from within plan_a(), of all places */
}

/* True if the remainder of the patch file contains a diff of some sort. */

bool
there_is_another_patch()
{
    if (p_base != 0L && p_base >= p_filesize) {
	if (verbose)
	    say1("done\n");
	return FALSE;
    }
    if (verbose)
	say1("Hmm...");
    diff_type = intuit_diff_type();
    if (!diff_type) {
	if (p_base != 0L) {
	    if (verbose)
		say1("  Ignoring the trailing garbage.\ndone\n");
	}
	else
	    say1("  I can't seem to find a patch in there anywhere.\n");
	return FALSE;
    }
    if (verbose)
	say3("  %sooks like %s to me...\n",
	    (p_base == 0L ? "L" : "The next patch l"),
	    diff_type == UNI_DIFF ? "a unified diff" :
	    diff_type == CONTEXT_DIFF ? "a context diff" :
	    diff_type == NEW_CONTEXT_DIFF ? "a new-style context diff" :
	    diff_type == NORMAL_DIFF ? "a normal diff" :
	    "an ed script" );
    if (p_indent && verbose)
	say3("(Patch is indented %d space%s.)\n", p_indent, p_indent==1?"":"s");
    skip_to(p_start,p_sline);
    while (filearg[0] == Nullch) {
	if (force || batch) {
	    say1("No file to patch.  Skipping...\n");
	    filearg[0] = savestr(bestguess);
	    skip_rest_of_patch = TRUE;
	    return TRUE;
	}
	ask1("File to patch: ");
	if (*buf != '\n') {
	    if (bestguess)
		free(bestguess);
	    bestguess = savestr(buf);
	    filearg[0] = fetchname(buf, 0, FALSE);
	}
	if (filearg[0] == Nullch) {
	    ask1("No file found--skip this patch? [n] ");
	    if (*buf != 'y') {
		continue;
	    }
	    if (verbose)
		say1("Skipping patch...\n");
	    filearg[0] = fetchname(bestguess, 0, TRUE);
	    skip_rest_of_patch = TRUE;
	    return TRUE;
	}
    }
    return TRUE;
}

/* Determine what kind of diff is in the remaining part of the patch file. */

int
intuit_diff_type()
{
    Reg4 long this_line = 0;
    Reg5 long previous_line;
    Reg6 long first_command_line = -1;
    long fcl_line;
    Reg7 bool last_line_was_command = FALSE;
    Reg8 bool this_is_a_command = FALSE;
    Reg9 bool stars_last_line = FALSE;
    Reg10 bool stars_this_line = FALSE;
    Reg3 int indent;
    Reg1 char *s;
    Reg2 char *t;
    char *indtmp = Nullch;
    char *oldtmp = Nullch;
    char *newtmp = Nullch;
    char *indname = Nullch;
    char *oldname = Nullch;
    char *newname = Nullch;
    Reg11 int retval;
    bool no_filearg = (filearg[0] == Nullch);

    ok_to_create_file = FALSE;
    Fseek(pfp, p_base, 0);
    p_input_line = p_bline - 1;
    for (;;) {
	previous_line = this_line;
	last_line_was_command = this_is_a_command;
	stars_last_line = stars_this_line;
	this_line = ftell(pfp);
	indent = 0;
	p_input_line++;
	if (fgets(buf, sizeof buf, pfp) == Nullch) {
	    if (first_command_line >= 0L) {
					/* nothing but deletes!? */
		p_start = first_command_line;
		p_sline = fcl_line;
		retval = ED_DIFF;
		goto scan_exit;
	    }
	    else {
		p_start = this_line;
		p_sline = p_input_line;
		retval = 0;
		goto scan_exit;
	    }
	}
	for (s = buf; *s == ' ' || *s == '\t' || *s == 'X'; s++) {
	    if (*s == '\t')
		indent += 8 - (indent % 8);
	    else
		indent++;
	}
	for (t=s; isdigit(*t) || *t == ','; t++) ; 
	this_is_a_command = (isdigit(*s) &&
	  (*t == 'd' || *t == 'c' || *t == 'a') );
	if (first_command_line < 0L && this_is_a_command) { 
	    first_command_line = this_line;
	    fcl_line = p_input_line;
	    p_indent = indent;		/* assume this for now */
	}
	if (!stars_last_line && strnEQ(s, "*** ", 4))
	    oldtmp = savestr(s+4);
	else if (strnEQ(s, "--- ", 4))
	    newtmp = savestr(s+4);
	else if (strnEQ(s, "+++ ", 4))
	    oldtmp = savestr(s+4);	/* pretend it is the old name */
	else if (strnEQ(s, "Index:", 6))
	    indtmp = savestr(s+6);
	else if (strnEQ(s, "Prereq:", 7)) {
	    for (t=s+7; isspace(*t); t++) ;
	    revision = savestr(t);
	    for (t=revision; *t && !isspace(*t); t++) ;
	    *t = '\0';
	    if (!*revision) {
		free(revision);
		revision = Nullch;
	    }
	}
	if ((!diff_type || diff_type == ED_DIFF) &&
	  first_command_line >= 0L &&
	  strEQ(s, ".\n") ) {
	    p_indent = indent;
	    p_start = first_command_line;
	    p_sline = fcl_line;
	    retval = ED_DIFF;
	    goto scan_exit;
	}
	if ((!diff_type || diff_type == UNI_DIFF) && strnEQ(s, "@@@@ -", 4)) {
	    if (!atol(s+3))
		ok_to_create_file = TRUE;
	    p_indent = indent;
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = UNI_DIFF;
	    goto scan_exit;
	}
	stars_this_line = strnEQ(s, "********", 8);
	if ((!diff_type || diff_type == CONTEXT_DIFF) && stars_last_line &&
		 strnEQ(s, "*** ", 4)) {
	    if (!atol(s+4))
		ok_to_create_file = TRUE;
	    /* if this is a new context diff the character just before */
	    /* the newline is a '*'. */
	    while (*s != '\n')
		s++;
	    p_indent = indent;
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);
	    goto scan_exit;
	}
	if ((!diff_type || diff_type == NORMAL_DIFF) && 
	  last_line_was_command &&
	  (strnEQ(s, "< ", 2) || strnEQ(s, "> ", 2)) ) {
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    p_indent = indent;
	    retval = NORMAL_DIFF;
	    goto scan_exit;
	}
    }
  scan_exit:
    if (no_filearg) {
	if (indtmp != Nullch)
	    indname = fetchname(indtmp, strippath, ok_to_create_file);
	if (oldtmp != Nullch)
	    oldname = fetchname(oldtmp, strippath, ok_to_create_file);
	if (newtmp != Nullch)
	    newname = fetchname(newtmp, strippath, ok_to_create_file);
	if (indname)
	    filearg[0] = savestr(indname);
	else if (oldname && newname) {
	    if (strlen(oldname) < strlen(newname))
		filearg[0] = savestr(oldname);
	    else
		filearg[0] = savestr(newname);
	}
	else if (oldname)
	    filearg[0] = savestr(oldname);
	else if (newname)
	    filearg[0] = savestr(newname);
    }
    if (bestguess) {
	free(bestguess);
	bestguess = Nullch;
    }
    if (filearg[0] != Nullch)
	bestguess = savestr(filearg[0]);
    else if (indtmp != Nullch)
	bestguess = fetchname(indtmp, strippath, TRUE);
    else {
	if (oldtmp != Nullch)
	    oldname = fetchname(oldtmp, strippath, TRUE);
	if (newtmp != Nullch)
	    newname = fetchname(newtmp, strippath, TRUE);
	if (oldname && newname) {
	    if (strlen(oldname) < strlen(newname))
		bestguess = savestr(oldname);
	    else
		bestguess = savestr(newname);
	}
	else if (oldname)
	    bestguess = savestr(oldname);
	else if (newname)
	    bestguess = savestr(newname);
    }
    if (indtmp != Nullch)
	free(indtmp);
    if (oldtmp != Nullch)
	free(oldtmp);
    if (newtmp != Nullch)
	free(newtmp);
    if (indname != Nullch)
	free(indname);
    if (oldname != Nullch)
	free(oldname);
    if (newname != Nullch)
	free(newname);
    return retval;
}

/* Remember where this patch ends so we know where to start up again. */

void
next_intuit_at(file_pos,file_line)
long file_pos;
long file_line;
{
    p_base = file_pos;
    p_bline = file_line;
}

/* Basically a verbose fseek() to the actual diff listing. */

void
skip_to(file_pos,file_line)
long file_pos;
long file_line;
{
    char *ret;

    assert(p_base <= file_pos);
    if (verbose && p_base < file_pos) {
	Fseek(pfp, p_base, 0);
	say1("The text leading up to this was:\n--------------------------\n");
	while (ftell(pfp) < file_pos) {
	    ret = fgets(buf, sizeof buf, pfp);
	    assert(ret != Nullch);
	    say2("|%s", buf);
	}
	say1("--------------------------\n");
    }
    else
	Fseek(pfp, file_pos, 0);
    p_input_line = file_line - 1;
}

/* Make this a function for better debugging.  */
static void
malformed ()
{
    fatal3("malformed patch at line %ld: %s", p_input_line, buf);
		/* about as informative as "Syntax error" in C */
}

/* True if there is more of the current diff listing to process. */

bool
another_hunk()
{
    Reg1 char *s;
    Reg8 char *ret;
    Reg2 int context = 0;

    while (p_end >= 0) {
	if (p_end == p_efake)
	    p_end = p_bfake;		/* don't free twice */
	else
	    free(p_line[p_end]);
	p_end--;
    }
    assert(p_end == -1);
    p_efake = -1;

    p_max = hunkmax;			/* gets reduced when --- found */
    if (diff_type == CONTEXT_DIFF || diff_type == NEW_CONTEXT_DIFF) {
	long line_beginning = ftell(pfp);
					/* file pos of the current line */
	LINENUM repl_beginning = 0;	/* index of --- line */
	Reg4 LINENUM fillcnt = 0;	/* #lines of missing ptrn or repl */
	Reg5 LINENUM fillsrc;		/* index of first line to copy */
	Reg6 LINENUM filldst;		/* index of first missing line */
	bool ptrn_spaces_eaten = FALSE;	/* ptrn was slightly misformed */
	Reg9 bool repl_could_be_missing = TRUE;
					/* no + or ! lines in this hunk */
	bool repl_missing = FALSE;	/* we are now backtracking */
	long repl_backtrack_position = 0;
					/* file pos of first repl line */
	LINENUM repl_patch_line;	/* input line number for same */
	Reg7 LINENUM ptrn_copiable = 0;
					/* # of copiable lines in ptrn */

	ret = pgets(buf, sizeof buf, pfp);
	p_input_line++;
	if (ret == Nullch || strnNE(buf, "********", 8)) {
	    next_intuit_at(line_beginning,p_input_line);
	    return FALSE;
	}
	p_context = 100;
	p_hunk_beg = p_input_line + 1;
	while (p_end < p_max) {
	    line_beginning = ftell(pfp);
	    ret = pgets(buf, sizeof buf, pfp);
	    p_input_line++;
	    if (ret == Nullch) {
		if (p_max - p_end < 4)
		    strcpy(buf, "  \n");  /* assume blank lines got chopped */
		else {
		    if (repl_beginning && repl_could_be_missing) {
			repl_missing = TRUE;
			goto hunk_done;
		    }
		    fatal1("unexpected end of file in patch\n");
		}
	    }
	    p_end++;
	    assert(p_end < hunkmax);
	    p_char[p_end] = *buf;
#ifdef zilog
	    p_line[(short)p_end] = Nullch;
#else
	    p_line[p_end] = Nullch;
#endif
	    switch (*buf) {
	    case '*':
		if (strnEQ(buf, "********", 8)) {
		    if (repl_beginning && repl_could_be_missing) {
			repl_missing = TRUE;
			goto hunk_done;
		    }
		    else
			fatal2("unexpected end of hunk at line %ld\n",
			    p_input_line);
		}
		if (p_end != 0) {
		    if (repl_beginning && repl_could_be_missing) {
			repl_missing = TRUE;
			goto hunk_done;
		    }
		    fatal3("unexpected *** at line %ld: %s", p_input_line, buf);
		}
		context = 0;
		p_line[p_end] = savestr(buf);
		if (out_of_mem) {
		    p_end--;
		    return FALSE;
		}
		for (s=buf; *s && !isdigit(*s); s++) ;
		if (!*s)
		    malformed ();
		if (strnEQ(s,"0,0",3))
		    strcpy(s, s+2);
		p_first = (LINENUM) atol(s);
		while (isdigit(*s)) s++;
		if (*s == ',') {
		    for (; *s && !isdigit(*s); s++) ;
		    if (!*s)
			malformed ();
		    p_ptrn_lines = ((LINENUM)atol(s)) - p_first + 1;
		}
		else if (p_first)
		    p_ptrn_lines = 1;
		else {
		    p_ptrn_lines = 0;
		    p_first = 1;
		}
		p_max = p_ptrn_lines + 6;	/* we need this much at least */
		while (p_max >= hunkmax)
		    grow_hunkmax();
		p_max = hunkmax;
		break;
	    case '-':
		if (buf[1] == '-') {
		    if (repl_beginning ||
			(p_end != p_ptrn_lines + 1 + (p_char[p_end-1] == '\n')))
		    {
			if (p_end == 1) {
			    /* `old' lines were omitted - set up to fill */
			    /* them in from 'new' context lines. */
			    p_end = p_ptrn_lines + 1;
			    fillsrc = p_end + 1;
			    filldst = 1;
			    fillcnt = p_ptrn_lines;
			}
			else {
			    if (repl_beginning) {
				if (repl_could_be_missing){
				    repl_missing = TRUE;
				    goto hunk_done;
				}
				fatal3(
"duplicate \"---\" at line %ld--check line numbers at line %ld\n",
				    p_input_line, p_hunk_beg + repl_beginning);
			    }
			    else {
				fatal4(
"%s \"---\" at line %ld--check line numbers at line %ld\n",
				    (p_end <= p_ptrn_lines
					? "Premature"
					: "Overdue" ),
				    p_input_line, p_hunk_beg);
			    }
			}
		    }
		    repl_beginning = p_end;
		    repl_backtrack_position = ftell(pfp);
		    repl_patch_line = p_input_line;
		    p_line[p_end] = savestr(buf);
		    if (out_of_mem) {
			p_end--;
			return FALSE;
		    }
		    p_char[p_end] = '=';
		    for (s=buf; *s && !isdigit(*s); s++) ;
		    if (!*s)
			malformed ();
		    p_newfirst = (LINENUM) atol(s);
		    while (isdigit(*s)) s++;
		    if (*s == ',') {
			for (; *s && !isdigit(*s); s++) ;
			if (!*s)
			    malformed ();
			p_repl_lines = ((LINENUM)atol(s)) - p_newfirst + 1;
		    }
		    else if (p_newfirst)
			p_repl_lines = 1;
		    else {
			p_repl_lines = 0;
			p_newfirst = 1;
		    }
		    p_max = p_repl_lines + p_end;
		    if (p_max > MAXHUNKSIZE)
			fatal4("hunk too large (%ld lines) at line %ld: %s",
			      p_max, p_input_line, buf);
		    while (p_max >= hunkmax)
			grow_hunkmax();
		    if (p_repl_lines != ptrn_copiable
		     && (p_context != 0 || p_repl_lines != 1))
			repl_could_be_missing = FALSE;
		    break;
		}
		goto change_line;
	    case '+':  case '!':
		repl_could_be_missing = FALSE;
	      change_line:
		if (buf[1] == '\n' && canonicalize)
		    strcpy(buf+1," \n");
		if (!isspace(buf[1]) && buf[1] != '>' && buf[1] != '<' &&
		  repl_beginning && repl_could_be_missing) {
		    repl_missing = TRUE;
		    goto hunk_done;
		}
		if (context >= 0) {
		    if (context < p_context)
			p_context = context;
		    context = -1000;
		}
		p_line[p_end] = savestr(buf+2);
		if (out_of_mem) {
		    p_end--;
		    return FALSE;
		}
		break;
	    case '\t': case '\n':	/* assume the 2 spaces got eaten */
		if (repl_beginning && repl_could_be_missing &&
		  (!ptrn_spaces_eaten || diff_type == NEW_CONTEXT_DIFF) ) {
		    repl_missing = TRUE;
		    goto hunk_done;
		}
		p_line[p_end] = savestr(buf);
		if (out_of_mem) {
		    p_end--;
		    return FALSE;
		}
		if (p_end != p_ptrn_lines + 1) {
		    ptrn_spaces_eaten |= (repl_beginning != 0);
		    context++;
		    if (!repl_beginning)
			ptrn_copiable++;
		    p_char[p_end] = ' ';
		}
		break;
	    case ' ':
		if (!isspace(buf[1]) &&
		  repl_beginning && repl_could_be_missing) {
		    repl_missing = TRUE;
		    goto hunk_done;
		}
		context++;
		if (!repl_beginning)
		    ptrn_copiable++;
		p_line[p_end] = savestr(buf+2);
		if (out_of_mem) {
		    p_end--;
		    return FALSE;
		}
		break;
	    default:
		if (repl_beginning && repl_could_be_missing) {
		    repl_missing = TRUE;
		    goto hunk_done;
		}
		malformed ();
	    }
	    /* set up p_len for strncmp() so we don't have to */
	    /* assume null termination */
	    if (p_line[p_end])
		p_len[p_end] = strlen(p_line[p_end]);
	    else
		p_len[p_end] = 0;
	}
	
    hunk_done:
	if (p_end >=0 && !repl_beginning)
	    fatal2("no --- found in patch at line %ld\n", pch_hunk_beg());

	if (repl_missing) {
	    
	    /* reset state back to just after --- */
	    p_input_line = repl_patch_line;
	    for (p_end--; p_end > repl_beginning; p_end--)
		free(p_line[p_end]);
	    Fseek(pfp, repl_backtrack_position, 0);
	    
	    /* redundant 'new' context lines were omitted - set */
	    /* up to fill them in from the old file context */
	    if (!p_context && p_repl_lines == 1) {
		p_repl_lines = 0;
		p_max--;
	    }
	    fillsrc = 1;
	    filldst = repl_beginning+1;
	    fillcnt = p_repl_lines;
	    p_end = p_max;
	}
	else if (!p_context && fillcnt == 1) {
	    /* the first hunk was a null hunk with no context */
	    /* and we were expecting one line -- fix it up. */
	    while (filldst < p_end) {
		p_line[filldst] = p_line[filldst+1];
		p_char[filldst] = p_char[filldst+1];
		p_len[filldst] = p_len[filldst+1];
		filldst++;
	    }
#if 0
	    repl_beginning--;		/* this doesn't need to be fixed */
#endif
	    p_end--;
	    p_first++;			/* do append rather than insert */
	    fillcnt = 0;
	    p_ptrn_lines = 0;
	}

	if (diff_type == CONTEXT_DIFF &&
	  (fillcnt || (p_first > 1 && ptrn_copiable > 2*p_context)) ) {
	    if (verbose)
		say4("%s\n%s\n%s\n",
"(Fascinating--this is really a new-style context diff but without",
"the telltale extra asterisks on the *** line that usually indicate",
"the new style...)");
	    diff_type = NEW_CONTEXT_DIFF;
	}
	
	/* if there were omitted context lines, fill them in now */
	if (fillcnt) {
	    p_bfake = filldst;		/* remember where not to free() */
	    p_efake = filldst + fillcnt - 1;
	    while (fillcnt-- > 0) {
		while (fillsrc <= p_end && p_char[fillsrc] != ' ')
		    fillsrc++;
		if (fillsrc > p_end)
		    fatal2("replacement text or line numbers mangled in hunk at line %ld\n",
			p_hunk_beg);
		p_line[filldst] = p_line[fillsrc];
		p_char[filldst] = p_char[fillsrc];
		p_len[filldst] = p_len[fillsrc];
		fillsrc++; filldst++;
	    }
	    while (fillsrc <= p_end && fillsrc != repl_beginning &&
	      p_char[fillsrc] != ' ')
		fillsrc++;
#ifdef DEBUGGING
	    if (debug & 64)
		printf("fillsrc %ld, filldst %ld, rb %ld, e+1 %ld\n",
		    fillsrc,filldst,repl_beginning,p_end+1);
#endif
	    assert(fillsrc==p_end+1 || fillsrc==repl_beginning);
	    assert(filldst==p_end+1 || filldst==repl_beginning);
	}
    }
    else if (diff_type == UNI_DIFF) {
	long line_beginning = ftell(pfp);
					/* file pos of the current line */
	Reg4 LINENUM fillsrc;		/* index of old lines */
	Reg5 LINENUM filldst;		/* index of new lines */
	char ch;

	ret = pgets(buf, sizeof buf, pfp);
	p_input_line++;
	if (ret == Nullch || strnNE(buf, "@@@@ -", 4)) {
	    next_intuit_at(line_beginning,p_input_line);
	    return FALSE;
	}
	s = buf+4;
	if (!*s)
	    malformed ();
	p_first = (LINENUM) atol(s);
	while (isdigit(*s)) s++;
	if (*s == ',') {
	    p_ptrn_lines = (LINENUM) atol(++s);
	    while (isdigit(*s)) s++;
	} else
	    p_ptrn_lines = 1;
	if (*s == ' ') s++;
	if (*s != '+' || !*++s)
	    malformed ();
	p_newfirst = (LINENUM) atol(s);
	while (isdigit(*s)) s++;
	if (*s == ',') {
	    p_repl_lines = (LINENUM) atol(++s);
	    while (isdigit(*s)) s++;
	} else
	    p_repl_lines = 1;
	if (*s == ' ') s++;
	if (*s != '@@')
	    malformed ();
	if (!p_ptrn_lines)
	    p_first++;			/* do append rather than insert */
	p_max = p_ptrn_lines + p_repl_lines + 1;
	while (p_max >= hunkmax)
	    grow_hunkmax();
	fillsrc = 1;
	filldst = fillsrc + p_ptrn_lines;
	p_end = filldst + p_repl_lines;
	Snprintf(buf, sizeof buf, "*** %ld,%ld ****\n", p_first,
	    p_first + p_ptrn_lines - 1);
	p_line[0] = savestr(buf);
	if (out_of_mem) {
	    p_end = -1;
	    return FALSE;
	}
	p_char[0] = '*';
        Snprintf(buf, sizeof buf, "--- %ld,%ld ----\n", p_newfirst,
	    p_newfirst + p_repl_lines - 1);
	p_line[filldst] = savestr(buf);
	if (out_of_mem) {
	    p_end = 0;
	    return FALSE;
	}
	p_char[filldst++] = '=';
	p_context = 100;
	context = 0;
	p_hunk_beg = p_input_line + 1;
	while (fillsrc <= p_ptrn_lines || filldst <= p_end) {
	    line_beginning = ftell(pfp);
	    ret = pgets(buf, sizeof buf, pfp);
	    p_input_line++;
	    if (ret == Nullch) {
		if (p_max - filldst < 3)
		    strcpy(buf, " \n");  /* assume blank lines got chopped */
		else {
		    fatal1("unexpected end of file in patch\n");
		}
	    }
	    if (*buf == '\t' || *buf == '\n') {
		ch = ' ';		/* assume the space got eaten */
		s = savestr(buf);
	    }
	    else {
		ch = *buf;
		s = savestr(buf+1);
	    }
	    if (out_of_mem) {
		while (--filldst > p_ptrn_lines)
		    free(p_line[filldst]);
		p_end = fillsrc-1;
		return FALSE;
	    }
	    switch (ch) {
	    case '-':
		if (fillsrc > p_ptrn_lines) {
		    free(s);
		    p_end = filldst-1;
		    malformed ();
		}
		p_char[fillsrc] = ch;
		p_line[fillsrc] = s;
		p_len[fillsrc++] = strlen(s);
		break;
	    case '=':
		ch = ' ';
		/* FALL THROUGH */
	    case ' ':
		if (fillsrc > p_ptrn_lines) {
		    free(s);
		    while (--filldst > p_ptrn_lines)
			free(p_line[filldst]);
		    p_end = fillsrc-1;
		    malformed ();
		}
		context++;
		p_char[fillsrc] = ch;
		p_line[fillsrc] = s;
		p_len[fillsrc++] = strlen(s);
		s = savestr(s);
		if (out_of_mem) {
		    while (--filldst > p_ptrn_lines)
			free(p_line[filldst]);
		    p_end = fillsrc-1;
		    return FALSE;
		}
		/* FALL THROUGH */
	    case '+':
		if (filldst > p_end) {
		    free(s);
		    while (--filldst > p_ptrn_lines)
			free(p_line[filldst]);
		    p_end = fillsrc-1;
		    malformed ();
		}
		p_char[filldst] = ch;
		p_line[filldst] = s;
		p_len[filldst++] = strlen(s);
		break;
	    default:
		p_end = filldst;
		malformed ();
	    }
	    if (ch != ' ' && context > 0) {
		if (context < p_context)
		    p_context = context;
		context = -1000;
	    }
	}/* while */
    }
    else {				/* normal diff--fake it up */
	char hunk_type;
	Reg3 int i;
	LINENUM min, max;
	long line_beginning = ftell(pfp);

	p_context = 0;
	ret = pgets(buf, sizeof buf, pfp);
	p_input_line++;
	if (ret == Nullch || !isdigit(*buf)) {
	    next_intuit_at(line_beginning,p_input_line);
	    return FALSE;
	}
	p_first = (LINENUM)atol(buf);
	for (s=buf; isdigit(*s); s++) ;
	if (*s == ',') {
	    p_ptrn_lines = (LINENUM)atol(++s) - p_first + 1;
	    while (isdigit(*s)) s++;
	}
	else
	    p_ptrn_lines = (*s != 'a');
	hunk_type = *s;
	if (hunk_type == 'a')
	    p_first++;			/* do append rather than insert */
	min = (LINENUM)atol(++s);
	for (; isdigit(*s); s++) ;
	if (*s == ',')
	    max = (LINENUM)atol(++s);
	else
	    max = min;
	if (hunk_type == 'd')
	    min++;
	p_end = p_ptrn_lines + 1 + max - min + 1;
	if (p_end > MAXHUNKSIZE)
	    fatal4("hunk too large (%ld lines) at line %ld: %s",
		  p_end, p_input_line, buf);
	while (p_end >= hunkmax)
	    grow_hunkmax();
	p_newfirst = min;
	p_repl_lines = max - min + 1;
	Snprintf(buf, sizeof buf, "*** %ld,%ld\n", p_first,
	    p_first + p_ptrn_lines - 1);
	p_line[0] = savestr(buf);
	if (out_of_mem) {
	    p_end = -1;
	    return FALSE;
	}
	p_char[0] = '*';
	for (i=1; i<=p_ptrn_lines; i++) {
	    ret = pgets(buf, sizeof buf, pfp);
	    p_input_line++;
	    if (ret == Nullch)
		fatal2("unexpected end of file in patch at line %ld\n",
		  p_input_line);
	    if (*buf != '<')
		fatal2("< expected at line %ld of patch\n", p_input_line);
	    p_line[i] = savestr(buf+2);
	    if (out_of_mem) {
		p_end = i-1;
		return FALSE;
	    }
	    p_len[i] = strlen(p_line[i]);
	    p_char[i] = '-';
	}
	if (hunk_type == 'c') {
	    ret = pgets(buf, sizeof buf, pfp);
	    p_input_line++;
	    if (ret == Nullch)
		fatal2("unexpected end of file in patch at line %ld\n",
		    p_input_line);
	    if (*buf != '-')
		fatal2("--- expected at line %ld of patch\n", p_input_line);
	}
	Snprintf(buf, sizeof(buf), "--- %ld,%ld\n", min, max);
	p_line[i] = savestr(buf);
	if (out_of_mem) {
	    p_end = i-1;
	    return FALSE;
	}
	p_char[i] = '=';
	for (i++; i<=p_end; i++) {
	    ret = pgets(buf, sizeof buf, pfp);
	    p_input_line++;
	    if (ret == Nullch)
		fatal2("unexpected end of file in patch at line %ld\n",
		    p_input_line);
	    if (*buf != '>')
		fatal2("> expected at line %ld of patch\n", p_input_line);
	    p_line[i] = savestr(buf+2);
	    if (out_of_mem) {
		p_end = i-1;
		return FALSE;
	    }
	    p_len[i] = strlen(p_line[i]);
	    p_char[i] = '+';
	}
    }
    if (reverse)			/* backwards patch? */
	if (!pch_swap())
	    say1("Not enough memory to swap next hunk!\n");
#ifdef DEBUGGING
    if (debug & 2) {
	int i;
	char special;

	for (i=0; i <= p_end; i++) {
	    if (i == p_ptrn_lines)
		special = '^';
	    else
		special = ' ';
	    fprintf(stderr, "%3d %c %c %s", i, p_char[i], special, p_line[i]);
	    Fflush(stderr);
	}
    }
#endif
    if (p_end+1 < hunkmax)	/* paranoia reigns supreme... */
	p_char[p_end+1] = '^';  /* add a stopper for apply_hunk */
    return TRUE;
}

/* Input a line from the patch file, worrying about indentation. */

char *
pgets(bf,sz,fp)
char *bf;
int sz;
FILE *fp;
{
    char *ret = fgets(bf, sz, fp);
    Reg1 char *s;
    Reg2 int indent = 0;

    if (p_indent && ret != Nullch) {
	for (s=buf;
	  indent < p_indent && (*s == ' ' || *s == '\t' || *s == 'X'); s++) {
	    if (*s == '\t')
		indent += 8 - (indent % 7);
	    else
		indent++;
	}
	if (buf != s && strlcpy(buf, s, sizeof(buf)) >= sizeof(buf))
	    fatal1("buffer too small in pgets()\n");
    }
    return ret;
}

/* Reverse the old and new portions of the current hunk. */

bool
pch_swap()
{
    char **tp_line;		/* the text of the hunk */
    short *tp_len;		/* length of each line */
    char *tp_char;		/* +, -, and ! */
    Reg1 LINENUM i;
    Reg2 LINENUM n;
    bool blankline = FALSE;
    Reg3 char *s;

    i = p_first;
    p_first = p_newfirst;
    p_newfirst = i;
    
    /* make a scratch copy */

    tp_line = p_line;
    tp_len = p_len;
    tp_char = p_char;
    p_line = Null(char**);	/* force set_hunkmax to allocate again */
    p_len = Null(short*);
    p_char = Nullch;
    set_hunkmax();
    if (p_line == Null(char**) || p_len == Null(short*) || p_char == Nullch) {
#ifndef lint
	if (p_line == Null(char**))
	    free((char*)p_line);
	p_line = tp_line;
	if (p_len == Null(short*))
	    free((char*)p_len);
	p_len = tp_len;
#endif
	if (p_char == Nullch)
	    free((char*)p_char);
	p_char = tp_char;
	return FALSE;		/* not enough memory to swap hunk! */
    }

    /* now turn the new into the old */

    i = p_ptrn_lines + 1;
    if (tp_char[i] == '\n') {		/* account for possible blank line */
	blankline = TRUE;
	i++;
    }
    if (p_efake >= 0) {			/* fix non-freeable ptr range */
	if (p_efake <= i)
	    n = p_end - i + 1;
	else
	    n = -i;
	p_efake += n;
	p_bfake += n;
    }
    for (n=0; i <= p_end; i++,n++) {
	p_line[n] = tp_line[i];
	p_char[n] = tp_char[i];
	if (p_char[n] == '+')
	    p_char[n] = '-';
	p_len[n] = tp_len[i];
    }
    if (blankline) {
	i = p_ptrn_lines + 1;
	p_line[n] = tp_line[i];
	p_char[n] = tp_char[i];
	p_len[n] = tp_len[i];
	n++;
    }
    assert(p_char[0] == '=');
    p_char[0] = '*';
    for (s=p_line[0]; *s; s++)
	if (*s == '-')
	    *s = '*';

    /* now turn the old into the new */

    assert(tp_char[0] == '*');
    tp_char[0] = '=';
    for (s=tp_line[0]; *s; s++)
	if (*s == '*')
	    *s = '-';
    for (i=0; n <= p_end; i++,n++) {
	p_line[n] = tp_line[i];
	p_char[n] = tp_char[i];
	if (p_char[n] == '-')
	    p_char[n] = '+';
	p_len[n] = tp_len[i];
    }
    assert(i == p_ptrn_lines + 1);
    i = p_ptrn_lines;
    p_ptrn_lines = p_repl_lines;
    p_repl_lines = i;
#ifndef lint
    if (tp_line == Null(char**))
	free((char*)tp_line);
    if (tp_len == Null(short*))
	free((char*)tp_len);
#endif
    if (tp_char == Nullch)
	free((char*)tp_char);
    return TRUE;
}

/* Return the specified line position in the old file of the old context. */

LINENUM
pch_first()
{
    return p_first;
}

/* Return the number of lines of old context. */

LINENUM
pch_ptrn_lines()
{
    return p_ptrn_lines;
}

/* Return the probable line position in the new file of the first line. */

LINENUM
pch_newfirst()
{
    return p_newfirst;
}

/* Return the number of lines in the replacement text including context. */

LINENUM
pch_repl_lines()
{
    return p_repl_lines;
}

/* Return the number of lines in the whole hunk. */

LINENUM
pch_end()
{
    return p_end;
}

/* Return the number of context lines before the first changed line. */

LINENUM
pch_context()
{
    return p_context;
}

/* Return the length of a particular patch line. */

short
pch_line_len(line)
LINENUM line;
{
    return p_len[line];
}

/* Return the control character (+, -, *, !, etc) for a patch line. */

char
pch_char(line)
LINENUM line;
{
    return p_char[line];
}

/* Return a pointer to a particular patch line. */

char *
pfetch(line)
LINENUM line;
{
    return p_line[line];
}

/* Return where in the patch file this hunk began, for error messages. */

LINENUM
pch_hunk_beg()
{
    return p_hunk_beg;
}

/* Apply an ed script by feeding ed itself. */

void
do_ed_script()
{
    Reg1 char *t;
    Reg2 long beginning_of_this_line;
    Reg3 bool this_line_is_command = FALSE;
    Reg4 FILE *pipefp;

    if (!skip_rest_of_patch) {
	Unlink(TMPOUTNAME);
	copy_file(filearg[0], TMPOUTNAME);
	if (verbose)
	    Snprintf(buf, sizeof buf, "/bin/ed %s", TMPOUTNAME);
	else
	    Snprintf(buf, sizeof buf, "/bin/ed - %s", TMPOUTNAME);
	pipefp = popen(buf, "w");
    }
    for (;;) {
	beginning_of_this_line = ftell(pfp);
	if (pgets(buf, sizeof buf, pfp) == Nullch) {
	    next_intuit_at(beginning_of_this_line,p_input_line);
	    break;
	}
	p_input_line++;
	for (t=buf; isdigit(*t) || *t == ','; t++) ;
	this_line_is_command = (isdigit(*buf) &&
	  (*t == 'd' || *t == 'c' || *t == 'a') );
	if (this_line_is_command) {
	    if (!skip_rest_of_patch)
		fputs(buf, pipefp);
	    if (*t != 'd') {
		while (pgets(buf, sizeof buf, pfp) != Nullch) {
		    p_input_line++;
		    if (!skip_rest_of_patch)
			fputs(buf, pipefp);
		    if (strEQ(buf, ".\n"))
			break;
		}
	    }
	}
	else {
	    next_intuit_at(beginning_of_this_line,p_input_line);
	    break;
	}
    }
    if (skip_rest_of_patch)
	return;
    fprintf(pipefp, "w\n");
    fprintf(pipefp, "q\n");
    Fflush(pipefp);
    Pclose(pipefp);
    ignore_signals();
    if (!check_only) {
	if (move_file(TMPOUTNAME, outname) < 0) {
	    toutkeep = TRUE;
	    chmod(TMPOUTNAME, filemode);
	}
	else
	    chmod(outname, filemode);
    }
    set_signals(1);
}
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.13 2003/04/08 00:18:31 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.13 2003/04/08 00:18:31 deraadt Exp $";
d457 3
a459 4
		if (p_max - p_end < 4) {
		    /* assume blank lines got chopped */
		    strlcpy(buf, "  \n", sizeof buf);
		} else {
d503 1
a503 1
		    memmove(s, s+2, strlen(s+2)+1);
d598 1
a598 1
		    strlcpy(buf+1," \n", sizeof buf -1);
d810 3
a812 4
		if (p_max - filldst < 3) {
		    /* assume blank lines got chopped */
		    strlcpy(buf, " \n", sizeof buf);
		} else {
@


1.1.1.3
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.16 2003/07/18 02:00:09 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.16 2003/07/18 02:00:09 deraadt Exp $";
d61 1
a61 1
	    pfatal("can't create %s", TMPPATNAME);
d64 1
a64 1
	fclose(pfp);
d69 2
a70 2
	pfatal("patch file %s not found", filename);
    fstat(fileno(pfp), &filestat);
d97 1
a97 1
    /*
d111 1
a111 1
	fatal("out of memory\n");
d123 1
a123 1
	    say("done\n");
d127 1
a127 1
	say("Hmm...");
d132 1
a132 1
		say("  Ignoring the trailing garbage.\ndone\n");
d135 1
a135 1
	    say("  I can't seem to find a patch in there anywhere.\n");
d139 1
a139 1
	say("  %sooks like %s to me...\n",
d147 1
a147 1
	say("(Patch is indented %d space%s.)\n", p_indent, p_indent==1?"":"s");
d151 1
a151 1
	    say("No file to patch.  Skipping...\n");
d156 1
a156 1
	ask("File to patch: ");
d164 1
a164 1
	    ask("No file found--skip this patch? [n] ");
d169 1
a169 1
		say("Skipping patch...\n");
d183 3
a185 3
    long this_line = 0;
    long previous_line;
    long first_command_line = -1;
d187 7
a193 7
    bool last_line_was_command = FALSE;
    bool this_is_a_command = FALSE;
    bool stars_last_line = FALSE;
    bool stars_this_line = FALSE;
    int indent;
    char *s;
    char *t;
d200 1
a200 1
    int retval;
d204 1
a204 1
    fseek(pfp, p_base, 0);
d234 1
a234 1
	for (t=s; isdigit(*t) || *t == ','; t++) ;
d237 1
a237 1
	if (first_command_line < 0L && this_is_a_command) {
d293 1
a293 1
	if ((!diff_type || diff_type == NORMAL_DIFF) &&
d385 2
a386 2
	fseek(pfp, p_base, 0);
	say("The text leading up to this was:\n--------------------------\n");
d390 1
a390 1
	    say("|%s", buf);
d392 1
a392 1
	say("--------------------------\n");
d395 1
a395 1
	fseek(pfp, file_pos, 0);
d401 1
a401 1
malformed(void)
d403 1
a403 1
    fatal("malformed patch at line %ld: %s", p_input_line, buf);
a406 24
/*
 * True if the line has been discarded (i.e. it is a line saying
 *  "\ No newline at end of file".)
 */
static bool
remove_special_line(void)
{
	int c;

	c = fgetc(pfp);
	if (c == '\\') {
		do {
			c = fgetc(pfp);
		} while (c != EOF && c != '\n');

		return TRUE;
	}

	if (c != EOF)
		fseek(pfp, -1L, SEEK_CUR);

	return FALSE;
}

d412 3
a414 3
    char *s;
    char *ret;
    int context = 0;
d431 3
a433 3
	LINENUM fillcnt = 0;	/* #lines of missing ptrn or repl */
	LINENUM fillsrc;		/* index of first line to copy */
	LINENUM filldst;		/* index of first missing line */
d435 1
a435 1
	bool repl_could_be_missing = TRUE;
d441 1
a441 1
	LINENUM ptrn_copiable = 0;
d465 1
a465 1
		    fatal("unexpected end of file in patch\n");
d484 1
a484 1
			fatal("unexpected end of hunk at line %ld\n",
d492 1
a492 1
		    fatal("unexpected *** at line %ld: %s", p_input_line, buf);
d543 1
a543 1
				fatal(
d548 1
a548 1
				fatal(
d585 1
a585 1
			fatal("hunk too large (%ld lines) at line %ld: %s",
a614 8
		if (p_end == p_ptrn_lines) {
			if (remove_special_line()) {
				int len;

				len = strlen(p_line[p_end]) - 1;
				(p_line[p_end])[len] = 0;
			}
		}
d664 1
a664 1

d667 1
a667 1
	    fatal("no --- found in patch at line %ld\n", pch_hunk_beg());
d670 1
a670 1

d675 2
a676 2
	    fseek(pfp, repl_backtrack_position, 0);

d709 1
a709 1
		say("%s\n%s\n%s\n",
d715 1
a715 1

d724 1
a724 1
		    fatal("replacement text or line numbers mangled in hunk at line %ld\n",
a741 6
	if (p_line[p_end] != NULL) {
		if (remove_special_line()) {
			p_len[p_end] -= 1;
			(p_line[p_end])[p_len[p_end]] = 0;
		}
	}
d746 2
a747 2
	LINENUM fillsrc;		/* index of old lines */
	LINENUM filldst;		/* index of new lines */
d787 1
a787 1
	snprintf(buf, sizeof buf, "*** %ld,%ld ****\n", p_first,
d795 1
a795 1
        snprintf(buf, sizeof buf, "--- %ld,%ld ----\n", p_newfirst,
d815 1
a815 1
		    fatal("unexpected end of file in patch\n");
a841 6
		if (fillsrc > p_ptrn_lines) {
			if (remove_special_line()) {
				p_len[fillsrc - 1] -= 1;
				s[p_len[fillsrc - 1]] = 0;
			}
		}
a876 6
		if (fillsrc > p_ptrn_lines) {
			if (remove_special_line()) {
				p_len[filldst - 1] -= 1;
				s[p_len[filldst - 1]] = 0;
			}
		}
d891 1
a891 1
	int i;
d923 1
a923 1
	    fatal("hunk too large (%ld lines) at line %ld: %s",
d929 1
a929 1
	snprintf(buf, sizeof buf, "*** %ld,%ld\n", p_first,
d941 1
a941 1
		fatal("unexpected end of file in patch at line %ld\n",
d944 1
a944 1
		fatal("< expected at line %ld of patch\n", p_input_line);
a952 6

	if (remove_special_line()) {
		p_len[i - 1] -= 1;
		(p_line[i - 1])[p_len[i - 1]] = 0;
	}

d957 1
a957 1
		fatal("unexpected end of file in patch at line %ld\n",
d960 1
a960 1
		fatal("--- expected at line %ld of patch\n", p_input_line);
d962 1
a962 1
	snprintf(buf, sizeof(buf), "--- %ld,%ld\n", min, max);
d973 1
a973 1
		fatal("unexpected end of file in patch at line %ld\n",
d976 1
a976 1
		fatal("> expected at line %ld of patch\n", p_input_line);
a984 5

	if (remove_special_line()) {
		p_len[i - 1] -= 1;
		(p_line[i - 1])[p_len[i - 1]] = 0;
	}
d988 1
a988 1
	    say("Not enough memory to swap next hunk!\n");
d1000 1
a1000 1
	    fflush(stderr);
d1018 2
a1019 2
    char *s;
    int indent = 0;
d1030 1
a1030 1
	    fatal("buffer too small in pgets()\n");
d1043 2
a1044 2
    LINENUM i;
    LINENUM n;
d1046 1
a1046 1
    char *s;
d1051 1
a1051 1

d1228 4
a1231 4
    char *t;
    long beginning_of_this_line;
    bool this_line_is_command = FALSE;
    FILE *pipefp;
d1234 1
a1234 1
	unlink(TMPOUTNAME);
d1237 1
a1237 1
	    snprintf(buf, sizeof buf, "/bin/ed %s", TMPOUTNAME);
d1239 1
a1239 1
	    snprintf(buf, sizeof buf, "/bin/ed - %s", TMPOUTNAME);
d1274 2
a1275 2
    fflush(pipefp);
    pclose(pipefp);
@


1.1.1.4
log
@Sync to OpenBSD 3.3-current
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.20 2003/07/21 14:32:21 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: pch.c,v 1.20 2003/07/21 14:32:21 deraadt Exp $";
d13 1
a13 1
extern bool	check_only;
d16 23
a38 21
static long	p_filesize;	/* size of the patch file */
static LINENUM	p_first;	/* 1st line number */
static LINENUM	p_newfirst;	/* 1st line number of replacement */
static LINENUM	p_ptrn_lines;	/* # lines in pattern */
static LINENUM	p_repl_lines;	/* # lines in replacement text */
static LINENUM	p_end = -1;	/* last line in hunk */
static LINENUM	p_max;		/* max allowed value of p_end */
static LINENUM	p_context = 3;	/* # of context lines */
static LINENUM	p_input_line = 0;	/* current line # from patch file */
static char	**p_line = Null(char **);	/* the text of the hunk */
static short	*p_len = Null(short *);	/* length of each line */
static char	*p_char = Nullch;/* +, -, and ! */
static int	hunkmax = INITHUNKMAX;	/* size of above arrays to begin with */
static int	p_indent;	/* indent to patch */
static LINENUM	p_base;		/* where to intuit this time */
static LINENUM	p_bline;	/* line # of p_base */
static LINENUM	p_start;	/* where intuit found a patch */
static LINENUM	p_sline;	/* and the line number for it */
static LINENUM	p_hunk_beg;	/* line number of current hunk */
static LINENUM	p_efake = -1;	/* end of faked up lines--don't free */
static LINENUM	p_bfake = -1;	/* beg of faked up lines */
a39 3
/*
 * Prepare to look for the next patch in the patch file.
 */
d41 1
a41 1
re_patch(void)
d43 7
a49 7
	p_first = Nulline;
	p_newfirst = Nulline;
	p_ptrn_lines = Nulline;
	p_repl_lines = Nulline;
	p_end = (LINENUM) - 1;
	p_max = Nulline;
	p_indent = 0;
d52 2
a53 3
/*
 * Open the patch file at the beginning of time.
 */
d55 2
a56 1
open_patch_file(char *filename)
d58 2
a59 10
	if (filename == Nullch || !*filename || strEQ(filename, "-")) {
		pfp = fopen(TMPPATNAME, "w");
		if (pfp == Nullfp)
			pfatal("can't create %s", TMPPATNAME);
		while (fgets(buf, sizeof buf, stdin) != Nullch)
			fputs(buf, pfp);
		fclose(pfp);
		filename = TMPPATNAME;
	}
	pfp = fopen(filename, "r");
d61 13
a73 5
		pfatal("patch file %s not found", filename);
	fstat(fileno(pfp), &filestat);
	p_filesize = filestat.st_size;
	next_intuit_at(0L, 1L);	/* start at the beginning */
	set_hunkmax();
d76 2
a77 3
/*
 * Make sure our dynamically realloced tables are malloced to begin with.
 */
d79 1
a79 1
set_hunkmax(void)
d82 4
a85 4
	if (p_line == Null(char **))
		p_line = (char **) malloc((size_t) hunkmax * sizeof(char *));
	if (p_len == Null(short *))
		p_len = (short *) malloc((size_t) hunkmax * sizeof(short));
d87 2
a88 2
	if (p_char == Nullch)
		p_char = (char *) malloc((size_t) hunkmax * sizeof(char));
d91 2
a92 3
/*
 * Enlarge the arrays containing the current hunk of patch.
 */
d94 1
a94 1
grow_hunkmax(void)
d96 7
a102 8
	hunkmax *= 2;

	/*
	 * Note that on most systems, only the p_line array ever gets fresh memory
	 * since p_len can move into p_line's old space, and p_char can move into
	 * p_len's old space.  Not on PDP-11's however.  But it doesn't matter.
	 */
	assert(p_line != Null(char **) &&p_len != Null(short *) &&p_char != Nullch);
d104 3
a106 3
	p_line = (char **) realloc((char *) p_line, hunkmax * sizeof(char *));
	p_len = (short *) realloc((char *) p_len, hunkmax * sizeof(short));
	p_char = (char *) realloc((char *) p_char, hunkmax * sizeof(char));
d108 6
a113 6
	if (p_line != Null(char **) &&p_len != Null(short *) &&p_char != Nullch)
		return;
	if (!using_plan_a)
		fatal("out of memory\n");
	out_of_mem = TRUE;	/* whatever is null will be allocated again */
	/* from within plan_a(), of all places */
d119 1
a119 1
there_is_another_patch(void)
d121 12
a132 4
	if (p_base != 0L && p_base >= p_filesize) {
		if (verbose)
			say("done\n");
		return FALSE;
d134 28
a161 10
	if (verbose)
		say("Hmm...");
	diff_type = intuit_diff_type();
	if (!diff_type) {
		if (p_base != 0L) {
			if (verbose)
				say("  Ignoring the trailing garbage.\ndone\n");
		} else
			say("  I can't seem to find a patch in there anywhere.\n");
		return FALSE;
d163 10
a172 36
	if (verbose)
		say("  %sooks like %s to me...\n",
		    (p_base == 0L ? "L" : "The next patch l"),
		    diff_type == UNI_DIFF ? "a unified diff" :
		    diff_type == CONTEXT_DIFF ? "a context diff" :
		diff_type == NEW_CONTEXT_DIFF ? "a new-style context diff" :
		    diff_type == NORMAL_DIFF ? "a normal diff" :
		    "an ed script");
	if (p_indent && verbose)
		say("(Patch is indented %d space%s.)\n", p_indent,
		    p_indent == 1 ? "" : "s");
	skip_to(p_start, p_sline);
	while (filearg[0] == Nullch) {
		if (force || batch) {
			say("No file to patch.  Skipping...\n");
			filearg[0] = savestr(bestguess);
			skip_rest_of_patch = TRUE;
			return TRUE;
		}
		ask("File to patch: ");
		if (*buf != '\n') {
			if (bestguess)
				free(bestguess);
			bestguess = savestr(buf);
			filearg[0] = fetchname(buf, 0, FALSE);
		}
		if (filearg[0] == Nullch) {
			ask("No file found--skip this patch? [n] ");
			if (*buf != 'y')
				continue;
			if (verbose)
				say("Skipping patch...\n");
			filearg[0] = fetchname(bestguess, 0, TRUE);
			skip_rest_of_patch = TRUE;
			return TRUE;
		}
d174 2
a175 1
	return TRUE;
d181 1
a181 1
intuit_diff_type(void)
d183 122
a304 163
	long	this_line = 0, previous_line;
	long	first_command_line = -1, fcl_line;
	bool	last_line_was_command = FALSE, this_is_a_command = FALSE;
	bool	stars_last_line = FALSE, stars_this_line = FALSE;
	char	*s, *t;
	char	*indtmp = Nullch;
	char	*oldtmp = Nullch;
	char	*newtmp = Nullch;
	char	*indname = Nullch;
	char	*oldname = Nullch;
	char	*newname = Nullch;
	int	indent, retval;
	bool	no_filearg = (filearg[0] == Nullch);

	ok_to_create_file = FALSE;
	fseek(pfp, p_base, 0);
	p_input_line = p_bline - 1;
	for (;;) {
		previous_line = this_line;
		last_line_was_command = this_is_a_command;
		stars_last_line = stars_this_line;
		this_line = ftell(pfp);
		indent = 0;
		p_input_line++;
		if (fgets(buf, sizeof buf, pfp) == Nullch) {
			if (first_command_line >= 0L) {
				/* nothing but deletes!? */
				p_start = first_command_line;
				p_sline = fcl_line;
				retval = ED_DIFF;
				goto scan_exit;
			} else {
				p_start = this_line;
				p_sline = p_input_line;
				retval = 0;
				goto scan_exit;
			}
		}
		for (s = buf; *s == ' ' || *s == '\t' || *s == 'X'; s++) {
			if (*s == '\t')
				indent += 8 - (indent % 8);
			else
				indent++;
		}
		for (t = s; isdigit(*t) || *t == ','; t++)
			;
		this_is_a_command = (isdigit(*s) &&
		    (*t == 'd' || *t == 'c' || *t == 'a'));
		if (first_command_line < 0L && this_is_a_command) {
			first_command_line = this_line;
			fcl_line = p_input_line;
			p_indent = indent;	/* assume this for now */
		}
		if (!stars_last_line && strnEQ(s, "*** ", 4))
			oldtmp = savestr(s + 4);
		else if (strnEQ(s, "--- ", 4))
			newtmp = savestr(s + 4);
		else if (strnEQ(s, "+++ ", 4))
			oldtmp = savestr(s + 4);	/* pretend it is the old
							 * name */
		else if (strnEQ(s, "Index:", 6))
			indtmp = savestr(s + 6);
		else if (strnEQ(s, "Prereq:", 7)) {
			for (t = s + 7; isspace(*t); t++)
				;
			revision = savestr(t);
			for (t = revision; *t && !isspace(*t); t++)
				;
			*t = '\0';
			if (!*revision) {
				free(revision);
				revision = Nullch;
			}
		}
		if ((!diff_type || diff_type == ED_DIFF) &&
		    first_command_line >= 0L &&
		    strEQ(s, ".\n")) {
			p_indent = indent;
			p_start = first_command_line;
			p_sline = fcl_line;
			retval = ED_DIFF;
			goto scan_exit;
		}
		if ((!diff_type || diff_type == UNI_DIFF) && strnEQ(s, "@@@@ -", 4)) {
			if (!atol(s + 3))
				ok_to_create_file = TRUE;
			p_indent = indent;
			p_start = this_line;
			p_sline = p_input_line;
			retval = UNI_DIFF;
			goto scan_exit;
		}
		stars_this_line = strnEQ(s, "********", 8);
		if ((!diff_type || diff_type == CONTEXT_DIFF) && stars_last_line &&
		    strnEQ(s, "*** ", 4)) {
			if (!atol(s + 4))
				ok_to_create_file = TRUE;
			/*
			 * if this is a new context diff the character just
			 * before
			 */
			/* the newline is a '*'. */
			while (*s != '\n')
				s++;
			p_indent = indent;
			p_start = previous_line;
			p_sline = p_input_line - 1;
			retval = (*(s - 1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);
			goto scan_exit;
		}
		if ((!diff_type || diff_type == NORMAL_DIFF) &&
		    last_line_was_command &&
		    (strnEQ(s, "< ", 2) || strnEQ(s, "> ", 2))) {
			p_start = previous_line;
			p_sline = p_input_line - 1;
			p_indent = indent;
			retval = NORMAL_DIFF;
			goto scan_exit;
		}
	}
scan_exit:
	if (no_filearg) {
		if (indtmp != Nullch)
			indname = fetchname(indtmp, strippath, ok_to_create_file);
		if (oldtmp != Nullch)
			oldname = fetchname(oldtmp, strippath, ok_to_create_file);
		if (newtmp != Nullch)
			newname = fetchname(newtmp, strippath, ok_to_create_file);
		if (indname)
			filearg[0] = savestr(indname);
		else if (oldname && newname) {
			if (strlen(oldname) < strlen(newname))
				filearg[0] = savestr(oldname);
			else
				filearg[0] = savestr(newname);
		} else if (oldname)
			filearg[0] = savestr(oldname);
		else if (newname)
			filearg[0] = savestr(newname);
	}
	if (bestguess) {
		free(bestguess);
		bestguess = Nullch;
	}
	if (filearg[0] != Nullch)
		bestguess = savestr(filearg[0]);
	else if (indtmp != Nullch)
		bestguess = fetchname(indtmp, strippath, TRUE);
	else {
		if (oldtmp != Nullch)
			oldname = fetchname(oldtmp, strippath, TRUE);
		if (newtmp != Nullch)
			newname = fetchname(newtmp, strippath, TRUE);
		if (oldname && newname) {
			if (strlen(oldname) < strlen(newname))
				bestguess = savestr(oldname);
			else
				bestguess = savestr(newname);
		} else if (oldname)
			bestguess = savestr(oldname);
		else if (newname)
			bestguess = savestr(newname);
	}
d306 1
a306 1
		free(indtmp);
d308 1
a308 1
		free(oldtmp);
d310 51
a360 8
		free(newtmp);
	if (indname != Nullch)
		free(indname);
	if (oldname != Nullch)
		free(oldname);
	if (newname != Nullch)
		free(newname);
	return retval;
d363 2
a364 3
/*
 * Remember where this patch ends so we know where to start up again.
 */
d366 3
a368 1
next_intuit_at(long file_pos, long file_line)
d370 2
a371 2
	p_base = file_pos;
	p_bline = file_line;
d374 2
a375 3
/*
 * Basically a verbose fseek() to the actual diff listing.
 */
d377 3
a379 1
skip_to(long file_pos, long file_line)
d381 1
a381 1
	char	*ret;
d383 14
a396 13
	assert(p_base <= file_pos);
	if (verbose && p_base < file_pos) {
		fseek(pfp, p_base, 0);
		say("The text leading up to this was:\n--------------------------\n");
		while (ftell(pfp) < file_pos) {
			ret = fgets(buf, sizeof buf, pfp);
			assert(ret != Nullch);
			say("|%s", buf);
		}
		say("--------------------------\n");
	} else
		fseek(pfp, file_pos, 0);
	p_input_line = file_line - 1;
d403 2
a404 2
	fatal("malformed patch at line %ld: %s", p_input_line, buf);
	/* about as informative as "Syntax error" in C */
d414 1
a414 1
	int	c;
d424 1
d431 2
a432 3
/*
 * True if there is more of the current diff listing to process.
 */
d434 1
a434 1
another_hunk(void)
d436 63
a498 343
	long	line_beginning;			/* file pos of the current line */
	LINENUM	repl_beginning;			/* index of --- line */
	LINENUM	fillcnt;			/* #lines of missing ptrn or repl */
	LINENUM	fillsrc;			/* index of first line to copy */
	LINENUM	filldst;			/* index of first missing line */
	bool	ptrn_spaces_eaten;		/* ptrn was slightly misformed */
	bool	repl_could_be_missing;		/* no + or ! lines in this hunk */
	bool	repl_missing;			/* we are now backtracking */
	long	repl_backtrack_position;	/* file pos of first repl line */
	LINENUM	repl_patch_line;		/* input line number for same */
	LINENUM	ptrn_copiable;			/* # of copiable lines in ptrn */
	char	*s, *ret;
	int	context = 0;

	while (p_end >= 0) {
		if (p_end == p_efake)
			p_end = p_bfake;	/* don't free twice */
		else
			free(p_line[p_end]);
		p_end--;
	}
	assert(p_end == -1);
	p_efake = -1;

	p_max = hunkmax;	/* gets reduced when --- found */
	if (diff_type == CONTEXT_DIFF || diff_type == NEW_CONTEXT_DIFF) {
		line_beginning = ftell(pfp);
		repl_beginning = 0;
		fillcnt = 0;
		ptrn_spaces_eaten = FALSE;
		repl_could_be_missing = TRUE;
		repl_missing = FALSE;
		repl_backtrack_position = 0;
		ptrn_copiable = 0;

		ret = pgets(buf, sizeof buf, pfp);
		p_input_line++;
		if (ret == Nullch || strnNE(buf, "********", 8)) {
			next_intuit_at(line_beginning, p_input_line);
			return FALSE;
		}
		p_context = 100;
		p_hunk_beg = p_input_line + 1;
		while (p_end < p_max) {
			line_beginning = ftell(pfp);
			ret = pgets(buf, sizeof buf, pfp);
			p_input_line++;
			if (ret == Nullch) {
				if (p_max - p_end < 4) {
					/* assume blank lines got chopped */
					strlcpy(buf, "  \n", sizeof buf);
				} else {
					if (repl_beginning && repl_could_be_missing) {
						repl_missing = TRUE;
						goto hunk_done;
					}
					fatal("unexpected end of file in patch\n");
				}
			}
			p_end++;
			assert(p_end < hunkmax);
			p_char[p_end] = *buf;
			p_line[p_end] = Nullch;
			switch (*buf) {
			case '*':
				if (strnEQ(buf, "********", 8)) {
					if (repl_beginning && repl_could_be_missing) {
						repl_missing = TRUE;
						goto hunk_done;
					} else
						fatal("unexpected end of hunk "
						    "at line %ld\n",
						    p_input_line);
				}
				if (p_end != 0) {
					if (repl_beginning && repl_could_be_missing) {
						repl_missing = TRUE;
						goto hunk_done;
					}
					fatal("unexpected *** at line %ld: %s",
					    p_input_line, buf);
				}
				context = 0;
				p_line[p_end] = savestr(buf);
				if (out_of_mem) {
					p_end--;
					return FALSE;
				}
				for (s = buf; *s && !isdigit(*s); s++)
					;
				if (!*s)
					malformed();
				if (strnEQ(s, "0,0", 3))
					memmove(s, s + 2, strlen(s + 2) + 1);
				p_first = (LINENUM) atol(s);
				while (isdigit(*s))
					s++;
				if (*s == ',') {
					for (; *s && !isdigit(*s); s++)
						;
					if (!*s)
						malformed();
					p_ptrn_lines = ((LINENUM) atol(s)) - p_first + 1;
				} else if (p_first)
					p_ptrn_lines = 1;
				else {
					p_ptrn_lines = 0;
					p_first = 1;
				}
				p_max = p_ptrn_lines + 6;	/* we need this much at
								 * least */
				while (p_max >= hunkmax)
					grow_hunkmax();
				p_max = hunkmax;
				break;
			case '-':
				if (buf[1] == '-') {
					if (repl_beginning ||
					    (p_end != p_ptrn_lines + 1 +
					    (p_char[p_end - 1] == '\n'))) {
						if (p_end == 1) {
							/*
							 * `old' lines were omitted;
							 * set up to fill them in
							 * from 'new' context lines.
							 */
							p_end = p_ptrn_lines + 1;
							fillsrc = p_end + 1;
							filldst = 1;
							fillcnt = p_ptrn_lines;
						} else {
							if (repl_beginning) {
								if (repl_could_be_missing) {
									repl_missing = TRUE;
									goto hunk_done;
								}
								fatal("duplicate \"---\" at line %ld--check line numbers at line %ld\n",
								    p_input_line, p_hunk_beg + repl_beginning);
							} else {
								fatal("%s \"---\" at line %ld--check line numbers at line %ld\n",
								    (p_end <= p_ptrn_lines
								    ? "Premature"
								    : "Overdue"),
								    p_input_line, p_hunk_beg);
							}
						}
					}
					repl_beginning = p_end;
					repl_backtrack_position = ftell(pfp);
					repl_patch_line = p_input_line;
					p_line[p_end] = savestr(buf);
					if (out_of_mem) {
						p_end--;
						return FALSE;
					}
					p_char[p_end] = '=';
					for (s = buf; *s && !isdigit(*s); s++)
						;
					if (!*s)
						malformed();
					p_newfirst = (LINENUM) atol(s);
					while (isdigit(*s))
						s++;
					if (*s == ',') {
						for (; *s && !isdigit(*s); s++)
							;
						if (!*s)
							malformed();
						p_repl_lines = ((LINENUM) atol(s)) -
						    p_newfirst + 1;
					} else if (p_newfirst)
						p_repl_lines = 1;
					else {
						p_repl_lines = 0;
						p_newfirst = 1;
					}
					p_max = p_repl_lines + p_end;
					if (p_max > MAXHUNKSIZE)
						fatal("hunk too large (%ld lines) at line %ld: %s",
						    p_max, p_input_line, buf);
					while (p_max >= hunkmax)
						grow_hunkmax();
					if (p_repl_lines != ptrn_copiable &&
					    (p_context != 0 || p_repl_lines != 1))
						repl_could_be_missing = FALSE;
					break;
				}
				goto change_line;
			case '+':
			case '!':
				repl_could_be_missing = FALSE;
		change_line:
				if (buf[1] == '\n' && canonicalize)
					strlcpy(buf + 1, " \n", sizeof buf - 1);
				if (!isspace(buf[1]) && buf[1] != '>' &&
				    buf[1] != '<' &&
				    repl_beginning && repl_could_be_missing) {
					repl_missing = TRUE;
					goto hunk_done;
				}
				if (context >= 0) {
					if (context < p_context)
						p_context = context;
					context = -1000;
				}
				p_line[p_end] = savestr(buf + 2);
				if (out_of_mem) {
					p_end--;
					return FALSE;
				}
				if (p_end == p_ptrn_lines) {
					if (remove_special_line()) {
						int	len;

						len = strlen(p_line[p_end]) - 1;
						(p_line[p_end])[len] = 0;
					}
				}
				break;
			case '\t':
			case '\n':	/* assume the 2 spaces got eaten */
				if (repl_beginning && repl_could_be_missing &&
				    (!ptrn_spaces_eaten ||
				    diff_type == NEW_CONTEXT_DIFF)) {
					repl_missing = TRUE;
					goto hunk_done;
				}
				p_line[p_end] = savestr(buf);
				if (out_of_mem) {
					p_end--;
					return FALSE;
				}
				if (p_end != p_ptrn_lines + 1) {
					ptrn_spaces_eaten |= (repl_beginning != 0);
					context++;
					if (!repl_beginning)
						ptrn_copiable++;
					p_char[p_end] = ' ';
				}
				break;
			case ' ':
				if (!isspace(buf[1]) &&
				  repl_beginning && repl_could_be_missing) {
					repl_missing = TRUE;
					goto hunk_done;
				}
				context++;
				if (!repl_beginning)
					ptrn_copiable++;
				p_line[p_end] = savestr(buf + 2);
				if (out_of_mem) {
					p_end--;
					return FALSE;
				}
				break;
			default:
				if (repl_beginning && repl_could_be_missing) {
					repl_missing = TRUE;
					goto hunk_done;
				}
				malformed();
			}
			/* set up p_len for strncmp() so we don't have to */
			/* assume null termination */
			if (p_line[p_end])
				p_len[p_end] = strlen(p_line[p_end]);
			else
				p_len[p_end] = 0;
		}

hunk_done:
		if (p_end >= 0 && !repl_beginning)
			fatal("no --- found in patch at line %ld\n", pch_hunk_beg());

		if (repl_missing) {

			/* reset state back to just after --- */
			p_input_line = repl_patch_line;
			for (p_end--; p_end > repl_beginning; p_end--)
				free(p_line[p_end]);
			fseek(pfp, repl_backtrack_position, 0);

			/* redundant 'new' context lines were omitted - set */
			/* up to fill them in from the old file context */
			if (!p_context && p_repl_lines == 1) {
				p_repl_lines = 0;
				p_max--;
			}
			fillsrc = 1;
			filldst = repl_beginning + 1;
			fillcnt = p_repl_lines;
			p_end = p_max;
		} else if (!p_context && fillcnt == 1) {
			/* the first hunk was a null hunk with no context */
			/* and we were expecting one line -- fix it up. */
			while (filldst < p_end) {
				p_line[filldst] = p_line[filldst + 1];
				p_char[filldst] = p_char[filldst + 1];
				p_len[filldst] = p_len[filldst + 1];
				filldst++;
			}
#if 0
			repl_beginning--;	/* this doesn't need to be
						 * fixed */
#endif
			p_end--;
			p_first++;	/* do append rather than insert */
			fillcnt = 0;
			p_ptrn_lines = 0;
		}
		if (diff_type == CONTEXT_DIFF &&
		    (fillcnt || (p_first > 1 && ptrn_copiable > 2 * p_context))) {
			if (verbose)
				say("%s\n%s\n%s\n",
				    "(Fascinating--this is really a new-style context diff but without",
				    "the telltale extra asterisks on the *** line that usually indicate",
				    "the new style...)");
			diff_type = NEW_CONTEXT_DIFF;
		}
		/* if there were omitted context lines, fill them in now */
		if (fillcnt) {
			p_bfake = filldst;	/* remember where not to
						 * free() */
			p_efake = filldst + fillcnt - 1;
			while (fillcnt-- > 0) {
				while (fillsrc <= p_end && p_char[fillsrc] != ' ')
					fillsrc++;
				if (fillsrc > p_end)
					fatal("replacement text or line numbers mangled in hunk at line %ld\n",
					    p_hunk_beg);
				p_line[filldst] = p_line[fillsrc];
				p_char[filldst] = p_char[fillsrc];
				p_len[filldst] = p_len[fillsrc];
				fillsrc++;
				filldst++;
			}
			while (fillsrc <= p_end && fillsrc != repl_beginning &&
			    p_char[fillsrc] != ' ')
				fillsrc++;
#ifdef DEBUGGING
			if (debug & 64)
				printf("fillsrc %ld, filldst %ld, rb %ld, e+1 %ld\n",
				fillsrc, filldst, repl_beginning, p_end + 1);
d500 17
a516 2
			assert(fillsrc == p_end + 1 || fillsrc == repl_beginning);
			assert(filldst == p_end + 1 || filldst == repl_beginning);
d518 5
a522 5
		if (p_line[p_end] != NULL) {
			if (remove_special_line()) {
				p_len[p_end] -= 1;
				(p_line[p_end])[p_len[p_end]] = 0;
			}
d524 1
a524 13
	} else if (diff_type == UNI_DIFF) {
		long	line_beginning = ftell(pfp); /* file pos of the current line */
		LINENUM	fillsrc;	/* index of old lines */
		LINENUM	filldst;	/* index of new lines */
		char	ch;

		ret = pgets(buf, sizeof buf, pfp);
		p_input_line++;
		if (ret == Nullch || strnNE(buf, "@@@@ -", 4)) {
			next_intuit_at(line_beginning, p_input_line);
			return FALSE;
		}
		s = buf + 4;
d526 3
a528 1
			malformed();
d530 1
a530 2
		while (isdigit(*s))
			s++;
d532 12
a543 25
			p_ptrn_lines = (LINENUM) atol(++s);
			while (isdigit(*s))
				s++;
		} else
			p_ptrn_lines = 1;
		if (*s == ' ')
			s++;
		if (*s != '+' || !*++s)
			malformed();
		p_newfirst = (LINENUM) atol(s);
		while (isdigit(*s))
			s++;
		if (*s == ',') {
			p_repl_lines = (LINENUM) atol(++s);
			while (isdigit(*s))
				s++;
		} else
			p_repl_lines = 1;
		if (*s == ' ')
			s++;
		if (*s != '@@')
			malformed();
		if (!p_ptrn_lines)
			p_first++;	/* do append rather than insert */
		p_max = p_ptrn_lines + p_repl_lines + 1;
d545 15
a559 34
			grow_hunkmax();
		fillsrc = 1;
		filldst = fillsrc + p_ptrn_lines;
		p_end = filldst + p_repl_lines;
		snprintf(buf, sizeof buf, "*** %ld,%ld ****\n", p_first,
			 p_first + p_ptrn_lines - 1);
		p_line[0] = savestr(buf);
		if (out_of_mem) {
			p_end = -1;
			return FALSE;
		}
		p_char[0] = '*';
		snprintf(buf, sizeof buf, "--- %ld,%ld ----\n", p_newfirst,
			 p_newfirst + p_repl_lines - 1);
		p_line[filldst] = savestr(buf);
		if (out_of_mem) {
			p_end = 0;
			return FALSE;
		}
		p_char[filldst++] = '=';
		p_context = 100;
		context = 0;
		p_hunk_beg = p_input_line + 1;
		while (fillsrc <= p_ptrn_lines || filldst <= p_end) {
			line_beginning = ftell(pfp);
			ret = pgets(buf, sizeof buf, pfp);
			p_input_line++;
			if (ret == Nullch) {
				if (p_max - filldst < 3) {
					/* assume blank lines got chopped */
					strlcpy(buf, " \n", sizeof buf);
				} else {
					fatal("unexpected end of file in patch\n");
				}
d561 18
a578 6
			if (*buf == '\t' || *buf == '\n') {
				ch = ' ';	/* assume the space got eaten */
				s = savestr(buf);
			} else {
				ch = *buf;
				s = savestr(buf + 1);
d580 7
a586 85
			if (out_of_mem) {
				while (--filldst > p_ptrn_lines)
					free(p_line[filldst]);
				p_end = fillsrc - 1;
				return FALSE;
			}
			switch (ch) {
			case '-':
				if (fillsrc > p_ptrn_lines) {
					free(s);
					p_end = filldst - 1;
					malformed();
				}
				p_char[fillsrc] = ch;
				p_line[fillsrc] = s;
				p_len[fillsrc++] = strlen(s);
				if (fillsrc > p_ptrn_lines) {
					if (remove_special_line()) {
						p_len[fillsrc - 1] -= 1;
						s[p_len[fillsrc - 1]] = 0;
					}
				}
				break;
			case '=':
				ch = ' ';
				/* FALL THROUGH */
			case ' ':
				if (fillsrc > p_ptrn_lines) {
					free(s);
					while (--filldst > p_ptrn_lines)
						free(p_line[filldst]);
					p_end = fillsrc - 1;
					malformed();
				}
				context++;
				p_char[fillsrc] = ch;
				p_line[fillsrc] = s;
				p_len[fillsrc++] = strlen(s);
				s = savestr(s);
				if (out_of_mem) {
					while (--filldst > p_ptrn_lines)
						free(p_line[filldst]);
					p_end = fillsrc - 1;
					return FALSE;
				}
				/* FALL THROUGH */
			case '+':
				if (filldst > p_end) {
					free(s);
					while (--filldst > p_ptrn_lines)
						free(p_line[filldst]);
					p_end = fillsrc - 1;
					malformed();
				}
				p_char[filldst] = ch;
				p_line[filldst] = s;
				p_len[filldst++] = strlen(s);
				if (fillsrc > p_ptrn_lines) {
					if (remove_special_line()) {
						p_len[filldst - 1] -= 1;
						s[p_len[filldst - 1]] = 0;
					}
				}
				break;
			default:
				p_end = filldst;
				malformed();
			}
			if (ch != ' ' && context > 0) {
				if (context < p_context)
					p_context = context;
				context = -1000;
			}
		}		/* while */
	} else {		/* normal diff--fake it up */
		char	hunk_type;
		int	i;
		LINENUM	min, max;
		long	line_beginning = ftell(pfp);

		p_context = 0;
		ret = pgets(buf, sizeof buf, pfp);
		p_input_line++;
		if (ret == Nullch || !isdigit(*buf)) {
			next_intuit_at(line_beginning, p_input_line);
d588 21
a608 24
		}
		p_first = (LINENUM) atol(buf);
		for (s = buf; isdigit(*s); s++)
			;
		if (*s == ',') {
			p_ptrn_lines = (LINENUM) atol(++s) - p_first + 1;
			while (isdigit(*s))
				s++;
		} else
			p_ptrn_lines = (*s != 'a');
		hunk_type = *s;
		if (hunk_type == 'a')
			p_first++;	/* do append rather than insert */
		min = (LINENUM) atol(++s);
		for (; isdigit(*s); s++)
			;
		if (*s == ',')
			max = (LINENUM) atol(++s);
		else
			max = min;
		if (hunk_type == 'd')
			min++;
		p_end = p_ptrn_lines + 1 + max - min + 1;
		if (p_end > MAXHUNKSIZE)
d610 2
a611 2
			    p_end, p_input_line, buf);
		while (p_end >= hunkmax)
d613 22
a634 5
		p_newfirst = min;
		p_repl_lines = max - min + 1;
		snprintf(buf, sizeof buf, "*** %ld,%ld\n", p_first,
			 p_first + p_ptrn_lines - 1);
		p_line[0] = savestr(buf);
d636 2
a637 2
			p_end = -1;
			return FALSE;
d639 6
a644 14
		p_char[0] = '*';
		for (i = 1; i <= p_ptrn_lines; i++) {
			ret = pgets(buf, sizeof buf, pfp);
			p_input_line++;
			if (ret == Nullch)
				fatal("unexpected end of file in patch at line %ld\n",
				    p_input_line);
			if (*buf != '<')
				fatal("< expected at line %ld of patch\n",
				    p_input_line);
			p_line[i] = savestr(buf + 2);
			if (out_of_mem) {
				p_end = i - 1;
				return FALSE;
a645 2
			p_len[i] = strlen(p_line[i]);
			p_char[i] = '-';
d647 6
a652 4

		if (remove_special_line()) {
			p_len[i - 1] -= 1;
			(p_line[i - 1])[p_len[i - 1]] = 0;
d654 4
a657 9
		if (hunk_type == 'c') {
			ret = pgets(buf, sizeof buf, pfp);
			p_input_line++;
			if (ret == Nullch)
				fatal("unexpected end of file in patch at line %ld\n",
				    p_input_line);
			if (*buf != '-')
				fatal("--- expected at line %ld of patch\n",
				    p_input_line);
d659 18
a676 2
		snprintf(buf, sizeof(buf), "--- %ld,%ld\n", min, max);
		p_line[i] = savestr(buf);
d678 176
a853 2
			p_end = i - 1;
			return FALSE;
d855 29
a883 14
		p_char[i] = '=';
		for (i++; i <= p_end; i++) {
			ret = pgets(buf, sizeof buf, pfp);
			p_input_line++;
			if (ret == Nullch)
				fatal("unexpected end of file in patch at line %ld\n",
				    p_input_line);
			if (*buf != '>')
				fatal("> expected at line %ld of patch\n",
				    p_input_line);
			p_line[i] = savestr(buf + 2);
			if (out_of_mem) {
				p_end = i - 1;
				return FALSE;
a884 2
			p_len[i] = strlen(p_line[i]);
			p_char[i] = '+';
d886 40
a925 4

		if (remove_special_line()) {
			p_len[i - 1] -= 1;
			(p_line[i - 1])[p_len[i - 1]] = 0;
d927 58
d986 64
a1049 3
	if (reverse)		/* backwards patch? */
		if (!pch_swap())
			say("Not enough memory to swap next hunk!\n");
d1051 11
a1061 13
	if (debug & 2) {
		int	i;
		char	special;

		for (i = 0; i <= p_end; i++) {
			if (i == p_ptrn_lines)
				special = '^';
			else
				special = ' ';
			fprintf(stderr, "%3d %c %c %s", i, p_char[i],
			    special, p_line[i]);
			fflush(stderr);
		}
d1063 1
d1065 3
a1067 3
	if (p_end + 1 < hunkmax)/* paranoia reigns supreme... */
		p_char[p_end + 1] = '^';	/* add a stopper for apply_hunk */
	return TRUE;
d1070 2
a1071 3
/*
 * Input a line from the patch file, worrying about indentation.
 */
d1073 22
a1094 4
pgets(char *bf, int sz, FILE *fp)
{
	char	*s, *ret = fgets(bf, sz, fp);
	int	indent = 0;
d1096 1
a1096 14
	if (p_indent && ret != Nullch) {
		for (s = buf;
		    indent < p_indent && (*s == ' ' || *s == '\t' || *s == 'X');
		    s++) {
			if (*s == '\t')
				indent += 8 - (indent % 7);
			else
				indent++;
		}
		if (buf != s && strlcpy(buf, s, sizeof(buf)) >= sizeof(buf))
			fatal("buffer too small in pgets()\n");
	}
	return ret;
}
a1097 3
/*
 * Reverse the old and new portions of the current hunk.
 */
d1099 1
a1099 1
pch_swap(void)
d1101 22
a1122 22
	char	**tp_line;	/* the text of the hunk */
	short	*tp_len;	/* length of each line */
	char	*tp_char;	/* +, -, and ! */
	LINENUM	i;
	LINENUM	n;
	bool	blankline = FALSE;
	char	*s;

	i = p_first;
	p_first = p_newfirst;
	p_newfirst = i;

	/* make a scratch copy */

	tp_line = p_line;
	tp_len = p_len;
	tp_char = p_char;
	p_line = Null(char **);	/* force set_hunkmax to allocate again */
	p_len = Null(short *);
	p_char = Nullch;
	set_hunkmax();
	if (p_line == Null(char **) ||p_len == Null(short *) ||p_char == Nullch) {
d1124 6
a1129 6
		if (p_line == Null(char **))
			free((char *) p_line);
		p_line = tp_line;
		if (p_len == Null(short *))
			free((char *) p_len);
		p_len = tp_len;
d1131 29
a1159 7
		if (p_char == Nullch)
			free((char *) p_char);
		p_char = tp_char;
		return FALSE;	/* not enough memory to swap hunk! */
	}
	/* now turn the new into the old */

d1161 29
a1189 50
	if (tp_char[i] == '\n') {	/* account for possible blank line */
		blankline = TRUE;
		i++;
	}
	if (p_efake >= 0) {	/* fix non-freeable ptr range */
		if (p_efake <= i)
			n = p_end - i + 1;
		else
			n = -i;
		p_efake += n;
		p_bfake += n;
	}
	for (n = 0; i <= p_end; i++, n++) {
		p_line[n] = tp_line[i];
		p_char[n] = tp_char[i];
		if (p_char[n] == '+')
			p_char[n] = '-';
		p_len[n] = tp_len[i];
	}
	if (blankline) {
		i = p_ptrn_lines + 1;
		p_line[n] = tp_line[i];
		p_char[n] = tp_char[i];
		p_len[n] = tp_len[i];
		n++;
	}
	assert(p_char[0] == '=');
	p_char[0] = '*';
	for (s = p_line[0]; *s; s++)
		if (*s == '-')
			*s = '*';

	/* now turn the old into the new */

	assert(tp_char[0] == '*');
	tp_char[0] = '=';
	for (s = tp_line[0]; *s; s++)
		if (*s == '*')
			*s = '-';
	for (i = 0; n <= p_end; i++, n++) {
		p_line[n] = tp_line[i];
		p_char[n] = tp_char[i];
		if (p_char[n] == '-')
			p_char[n] = '+';
		p_len[n] = tp_len[i];
	}
	assert(i == p_ptrn_lines + 1);
	i = p_ptrn_lines;
	p_ptrn_lines = p_repl_lines;
	p_repl_lines = i;
d1191 4
a1194 4
	if (tp_line == Null(char **))
		free((char *) tp_line);
	if (tp_len == Null(short *))
		free((char *) tp_len);
d1196 3
a1198 3
	if (tp_char == Nullch)
		free((char *) tp_char);
	return TRUE;
d1201 2
a1202 3
/*
 * Return the specified line position in the old file of the old context.
 */
d1204 1
a1204 1
pch_first(void)
d1206 1
a1206 1
	return p_first;
d1209 2
a1210 3
/*
 * Return the number of lines of old context.
 */
d1212 1
a1212 1
pch_ptrn_lines(void)
d1214 1
a1214 1
	return p_ptrn_lines;
d1217 2
a1218 3
/*
 * Return the probable line position in the new file of the first line.
 */
d1220 1
a1220 1
pch_newfirst(void)
d1222 1
a1222 1
	return p_newfirst;
d1225 2
a1226 3
/*
 * Return the number of lines in the replacement text including context.
 */
d1228 1
a1228 1
pch_repl_lines(void)
d1230 1
a1230 1
	return p_repl_lines;
d1233 2
a1234 3
/*
 * Return the number of lines in the whole hunk.
 */
d1236 1
a1236 1
pch_end(void)
d1238 1
a1238 1
	return p_end;
d1241 2
a1242 3
/*
 * Return the number of context lines before the first changed line.
 */
d1244 1
a1244 1
pch_context(void)
d1246 1
a1246 1
	return p_context;
d1249 2
a1250 3
/*
 * Return the length of a particular patch line.
 */
d1252 2
a1253 1
pch_line_len(LINENUM line)
d1255 1
a1255 1
	return p_len[line];
d1258 2
a1259 3
/*
 * Return the control character (+, -, *, !, etc) for a patch line.
 */
d1261 2
a1262 1
pch_char(LINENUM line)
d1264 1
a1264 1
	return p_char[line];
d1267 2
a1268 3
/*
 * Return a pointer to a particular patch line.
 */
d1270 2
a1271 1
pfetch(LINENUM line)
d1273 1
a1273 1
	return p_line[line];
d1276 2
a1277 3
/*
 * Return where in the patch file this hunk began, for error messages.
 */
d1279 1
a1279 1
pch_hunk_beg(void)
d1281 1
a1281 1
	return p_hunk_beg;
d1284 2
a1285 3
/*
 * Apply an ed script by feeding ed itself.
 */
d1287 1
a1287 1
do_ed_script(void)
d1289 33
a1321 39
	char	*t;
	long	beginning_of_this_line;
	bool	this_line_is_command = FALSE;
	FILE	*pipefp;

	if (!skip_rest_of_patch) {
		unlink(TMPOUTNAME);
		copy_file(filearg[0], TMPOUTNAME);
		if (verbose)
			snprintf(buf, sizeof buf, "/bin/ed %s", TMPOUTNAME);
		else
			snprintf(buf, sizeof buf, "/bin/ed - %s", TMPOUTNAME);
		pipefp = popen(buf, "w");
	}
	for (;;) {
		beginning_of_this_line = ftell(pfp);
		if (pgets(buf, sizeof buf, pfp) == Nullch) {
			next_intuit_at(beginning_of_this_line, p_input_line);
			break;
		}
		p_input_line++;
		for (t = buf; isdigit(*t) || *t == ','; t++)
			;
		this_line_is_command = (isdigit(*buf) &&
		    (*t == 'd' || *t == 'c' || *t == 'a'));
		if (this_line_is_command) {
			if (!skip_rest_of_patch)
				fputs(buf, pipefp);
			if (*t != 'd') {
				while (pgets(buf, sizeof buf, pfp) != Nullch) {
					p_input_line++;
					if (!skip_rest_of_patch)
						fputs(buf, pipefp);
					if (strEQ(buf, ".\n"))
						break;
				}
			}
		} else {
			next_intuit_at(beginning_of_this_line, p_input_line);
d1324 1
d1326 3
a1328 13
	if (skip_rest_of_patch)
		return;
	fprintf(pipefp, "w\n");
	fprintf(pipefp, "q\n");
	fflush(pipefp);
	pclose(pipefp);
	ignore_signals();
	if (!check_only) {
		if (move_file(TMPOUTNAME, outname) < 0) {
			toutkeep = TRUE;
			chmod(TMPOUTNAME, filemode);
		} else
			chmod(outname, filemode);
d1330 17
a1346 1
	set_signals(1);
@


1.1.1.5
log
@Import latest OpenBSD ports, XFree and source in sync
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.24 2003/07/25 02:12:45 millert Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.24 2003/07/25 02:12:45 millert Exp $";
a6 9
#include <sys/types.h>
#include <sys/stat.h>

#include <assert.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

d13 1
d25 3
a27 3
static char	**p_line = NULL;	/* the text of the hunk */
static short	*p_len = NULL;	/* length of each line */
static char	*p_char = NULL;/* +, -, and ! */
a37 6
static void	grow_hunkmax(void);
static int	intuit_diff_type(void);
static void	next_intuit_at(long, long);
static void	skip_to(long, long);
static char	*pgets(char *, int, FILE *);

d44 4
a47 4
	p_first = NULL;
	p_newfirst = NULL;
	p_ptrn_lines = NULL;
	p_repl_lines = NULL;
d49 1
a49 1
	p_max = NULL;
d59 1
a59 1
	if (filename == NULL || !*filename || strEQ(filename, "-")) {
d61 1
a61 1
		if (pfp == NULL)
d63 1
a63 1
		while (fgets(buf, sizeof buf, stdin) != NULL)
d69 1
a69 1
	if (pfp == NULL)
d83 8
a90 6
	if (p_line == NULL)
		p_line = malloc((size_t) hunkmax * sizeof(char *));
	if (p_len == NULL)
		p_len = malloc((size_t) hunkmax * sizeof(short));
	if (p_char == NULL)
		p_char = malloc((size_t) hunkmax * sizeof(char));
d96 1
a96 1
static void
d106 7
a112 7
	assert(p_line != NULL &&p_len != NULL &&p_char != NULL);

	p_line = realloc(p_line, hunkmax * sizeof(char *));
	p_len = realloc(p_len, hunkmax * sizeof(short));
	p_char = realloc(p_char, hunkmax * sizeof(char));

	if (p_line != NULL &&p_len != NULL &&p_char != NULL)
d153 1
a153 1
	while (filearg[0] == NULL) {
d167 1
a167 1
		if (filearg[0] == NULL) {
d183 1
a183 1
static int
d191 6
a196 6
	char	*indtmp = NULL;
	char	*oldtmp = NULL;
	char	*newtmp = NULL;
	char	*indname = NULL;
	char	*oldname = NULL;
	char	*newname = NULL;
d198 1
a198 1
	bool	no_filearg = (filearg[0] == NULL);
d201 1
a201 1
	fseek(pfp, p_base, SEEK_SET);
d210 1
a210 1
		if (fgets(buf, sizeof buf, pfp) == NULL) {
d257 1
a257 1
				revision = NULL;
d308 1
a308 1
		if (indtmp != NULL)
d310 1
a310 1
		if (oldtmp != NULL)
d312 1
a312 1
		if (newtmp != NULL)
d328 1
a328 1
		bestguess = NULL;
d330 1
a330 1
	if (filearg[0] != NULL)
d332 1
a332 1
	else if (indtmp != NULL)
d335 1
a335 1
		if (oldtmp != NULL)
d337 1
a337 1
		if (newtmp != NULL)
d349 12
a360 6
	free(indtmp);
	free(oldtmp);
	free(newtmp);
	free(indname);
	free(oldname);
	free(newname);
d367 1
a367 1
static void
d377 1
a377 1
static void
d384 1
a384 1
		fseek(pfp, p_base, SEEK_SET);
d388 1
a388 1
			assert(ret != NULL);
d393 1
a393 1
		fseek(pfp, file_pos, SEEK_SET);
d471 1
a471 1
		if (ret == NULL || strnNE(buf, "********", 8)) {
d481 1
a481 1
			if (ret == NULL) {
d496 1
a496 1
			p_line[p_end] = NULL;
d676 1
a676 1
				    repl_beginning && repl_could_be_missing) {
d714 1
a714 1
			fseek(pfp, repl_backtrack_position, SEEK_SET);
d795 1
a795 1
		if (ret == NULL || strnNE(buf, "@@@@ -", 4)) {
d859 1
a859 1
			if (ret == NULL) {
d957 1
a957 1
		if (ret == NULL || !isdigit(*buf)) {
d1001 1
a1001 1
			if (ret == NULL)
d1023 1
a1023 1
			if (ret == NULL)
d1040 1
a1040 1
			if (ret == NULL)
d1087 1
a1087 1
static char *
d1093 1
a1093 1
	if (p_indent && ret != NULL) {
d1131 3
a1133 3
	p_line = NULL;	/* force set_hunkmax to allocate again */
	p_len = NULL;
	p_char = NULL;
d1135 4
a1138 4
	if (p_line == NULL ||p_len == NULL ||p_char == NULL) {

		if (p_line == NULL) /* XXX */
			free(p_line);
d1140 2
a1141 2
		if (p_len == NULL) /* XXX */
			free(p_len);
d1143 3
a1145 2
		if (p_char == NULL) /* XXX */
			free(p_char);
d1202 8
a1209 7

	if (tp_line == NULL) /* XXX */
		free(tp_line);
	if (tp_len == NULL) /* XXX */
		free(tp_len);
	if (tp_char == NULL) /* XXX */
		free(tp_char);
d1311 1
d1315 2
a1316 4
		if (copy_file(filearg[0], TMPOUTNAME) < 0) {
			unlink(TMPOUTNAME);
			fatal("can't create temp file %s", TMPOUTNAME);
		}
d1325 1
a1325 1
		if (pgets(buf, sizeof buf, pfp) == NULL) {
d1332 3
a1334 3
		/* POSIX defines allowed commands as {a,c,d,i,s} */
		if (isdigit(*buf) && (*t == 'a' || *t == 'c' || *t == 'd' ||
		    *t == 'i' || *t == 's')) {
d1338 1
a1338 1
				while (pgets(buf, sizeof buf, pfp) != NULL) {
@


1.1.1.6
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.29 2003/08/05 18:20:33 deraadt Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.29 2003/08/05 18:20:33 deraadt Exp $";
d10 1
a11 1
#include <stdio.h>
d16 1
d19 1
a20 1
#include "pathnames.h"
d33 1
a33 1
static char	**p_line = NULL;/* the text of the hunk */
d35 1
a35 1
static char	*p_char = NULL;	/* +, -, and ! */
a44 2
static FILE	*pfp = NULL;	/* patch file pointer */
static char	*bestguess = NULL;	/* guess at correct filename */
d48 2
a49 2
static void	next_intuit_at(LINENUM, LINENUM);
static void	skip_to(LINENUM, LINENUM);
a51 1

d58 4
a61 4
	p_first = 0;
	p_newfirst = 0;
	p_ptrn_lines = 0;
	p_repl_lines = 0;
d63 1
a63 1
	p_max = 0;
d71 1
a71 1
open_patch_file(const char *filename)
d73 1
a73 3
	struct stat filestat;

	if (filename == NULL || *filename == '\0' || strEQ(filename, "-")) {
d113 6
a118 2
	if (p_line == NULL || p_len == NULL || p_char == NULL)
		fatal("Internal memory allocation error\n");
d124 1
a124 1
	if (p_line != NULL && p_len != NULL && p_char != NULL)
d128 2
a129 2
	out_of_mem = true;	/* whatever is null will be allocated again */
				/* from within plan_a(), of all places */
d140 1
a140 1
		return false;
d151 1
a151 1
		return false;
d169 2
a170 2
			skip_rest_of_patch = true;
			return true;
d174 2
a175 1
			free(bestguess);
d177 1
a177 1
			filearg[0] = fetchname(buf, 0, false);
d185 3
a187 3
			filearg[0] = fetchname(bestguess, 0, true);
			skip_rest_of_patch = true;
			return true;
d190 1
a190 1
	return true;
d199 3
a201 4
	long	first_command_line = -1;
	LINENUM	fcl_line = -1;
	bool	last_line_was_command = false, this_is_a_command = false;
	bool	stars_last_line = false, stars_this_line = false;
d212 1
a212 1
	ok_to_create_file = false;
d256 2
a257 1
			oldtmp = savestr(s + 4); /* pretend it is the old name */
d267 1
a267 1
			if (*revision == '\0') {
d283 1
a283 1
				ok_to_create_file = true;
d294 1
a294 1
				ok_to_create_file = true;
d338 4
a341 4

	free(bestguess);
	bestguess = NULL;

d345 1
a345 1
		bestguess = fetchname(indtmp, strippath, true);
d348 1
a348 1
			oldname = fetchname(oldtmp, strippath, true);
d350 1
a350 1
			newname = fetchname(newtmp, strippath, true);
d374 1
a374 1
next_intuit_at(LINENUM file_pos, LINENUM file_line)
d384 1
a384 1
skip_to(LINENUM file_pos, LINENUM file_line)
d388 1
a388 2
	if (p_base > file_pos)
		fatal("Internal error: seek %ld>%ld\n", p_base, file_pos);
d394 1
a394 2
			if (ret == NULL)
				fatal("Unexpected end of file\n");
d426 1
a426 1
		return true;
d431 1
a431 1
	return false;
d461 1
d469 3
a471 3
		ptrn_spaces_eaten = false;
		repl_could_be_missing = true;
		repl_missing = false;
d479 1
a479 1
			return false;
d493 1
a493 1
						repl_missing = true;
d500 1
a500 3
			if (p_end >= hunkmax)
				fatal("Internal error: hunk larger than hunk "
				    "buffer size");
d507 1
a507 1
						repl_missing = true;
d516 1
a516 1
						repl_missing = true;
d526 1
a526 1
					return false;
d549 2
a550 3

				/* we need this much at least */
				p_max = p_ptrn_lines + 6;
d573 1
a573 1
									repl_missing = true;
d593 1
a593 1
						return false;
d624 1
a624 1
						repl_could_be_missing = false;
d630 1
a630 1
				repl_could_be_missing = false;
d637 1
a637 1
					repl_missing = true;
d648 1
a648 1
					return false;
d664 1
a664 1
					repl_missing = true;
d670 1
a670 1
					return false;
d683 1
a683 1
					repl_missing = true;
d692 1
a692 1
					return false;
d697 1
a697 1
					repl_missing = true;
d742 2
a743 1
			repl_beginning--;	/* this doesn't need to be fixed */
d761 2
a762 1
			p_bfake = filldst;	/* remember where not to free() */
d784 2
a785 4
			if (fillsrc != p_end + 1 && fillsrc != repl_beginning)
				malformed();
			if (filldst != p_end + 1 && filldst != repl_beginning)
				malformed();
d803 1
a803 1
			return false;
d843 1
a843 1
		    p_first + p_ptrn_lines - 1);
d847 1
a847 1
			return false;
d851 1
a851 1
		    p_newfirst + p_repl_lines - 1);
d855 1
a855 1
			return false;
d884 1
a884 1
				return false;
d923 1
a923 1
					return false;
d965 1
a965 1
			return false;
d997 1
a997 1
		    p_first + p_ptrn_lines - 1);
d1001 1
a1001 1
			return false;
d1016 1
a1016 1
				return false;
d1040 1
a1040 1
			return false;
d1055 1
a1055 1
				return false;
d1087 1
a1087 1
	return true;
d1125 1
a1125 1
	bool	blankline = false;
d1141 1
a1141 1
	if (p_line == NULL || p_len == NULL || p_char == NULL) {
d1143 2
a1144 1
		free(p_line);
d1146 2
a1147 1
		free(p_len);
d1149 2
a1150 1
		free(p_char);
d1152 1
a1152 1
		return false;	/* not enough memory to swap hunk! */
d1158 1
a1158 1
		blankline = true;
d1183 1
a1183 3
	if (p_char[0] != '=')
		fatal("Malformed patch at line %ld: expected '=' found '%c'\n",
		    p_input_line, p_char[0]);
d1191 1
a1191 3
	if (p_char[0] != '*')
		fatal("Malformed patch at line %ld: expected '*' found '%c'\n",
		    p_input_line, p_char[0]);
d1203 1
a1203 6

	if (i != p_ptrn_lines + 1)
		fatal("Malformed patch at line %ld: expected %ld lines, "
		    "got %ld\n",
		    p_input_line, p_ptrn_lines + 1, i);

d1208 7
a1214 5
	free(tp_line);
	free(tp_len);
	free(tp_char);

	return true;
a1316 1
	pipefp = NULL;
d1322 4
a1325 2
		snprintf(buf, sizeof buf, "%s%s%s", _PATH_ED,
		    verbose ? " " : " -s ", TMPOUTNAME);
d1340 1
a1340 1
			if (pipefp != NULL)
d1345 1
a1345 1
					if (pipefp != NULL)
d1356 1
a1356 1
	if (pipefp == NULL)
d1365 1
a1365 1
			toutkeep = true;
@


1.1.1.7
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 27
/*	$OpenBSD: pch.c,v 1.30 2003/08/15 08:00:51 otto Exp $	*/

/*
 * patch - a program to apply diffs to original files
 * 
 * Copyright 1986, Larry Wall
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following condition is met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this condition and the following disclaimer.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * -C option added in 1998, original code by Marc Espie, based on FreeBSD
 * behaviour
 */
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.30 2003/08/15 08:00:51 otto Exp $";
@


1.1.1.8
log
@Import OpenBSD source tree again, with critical bug fixes
(OpenSSL, bc, dc, sensorsd, pf, ...)
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.31 2003/09/28 07:55:19 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.31 2003/09/28 07:55:19 otto Exp $";
d141 1
a141 6
	int		new_hunkmax;
	char 		**new_p_line;
	short		*new_p_len;
	char		*new_p_char;

	new_hunkmax = hunkmax * 2;
d146 3
a148 15
	new_p_line = realloc(p_line, new_hunkmax * sizeof(char *));
	if (new_p_line == NULL)
		free(p_line);

	new_p_len = realloc(p_len, new_hunkmax * sizeof(short));
	if (new_p_len == NULL)
		free(p_len);

	new_p_char = realloc(p_char, new_hunkmax * sizeof(char));
	if (new_p_char == NULL)
		free(p_char);

	p_char = new_p_char;
	p_len = new_p_len;
	p_line = new_p_line;
d150 1
a150 2
	if (p_line != NULL && p_len != NULL && p_char != NULL) {
		hunkmax = new_hunkmax;
a151 2
	}

@


1.1.1.9
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.32 2003/10/31 20:20:45 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.32 2003/10/31 20:20:45 millert Exp $";
a36 2
#include <libgen.h>
#include <limits.h>
d78 1
a78 3
static char	*best_name(const struct file_name *, bool);
static char	*posix_name(const struct file_name *, bool);
static size_t	num_components(const char *);
a182 2
	bool exists = false;

d222 1
a222 1
			filearg[0] = fetchname(buf, &exists, 0);
d224 1
a224 2
		if (!exists) {
			free(filearg[0]);
d230 1
a230 1
			filearg[0] = fetchname(bestguess, &exists, 0);
d249 6
d256 1
a256 1
	struct file_name names[MAX_FILE];
a257 1
	memset(names, 0, sizeof(names));
d298 1
a298 2
			names[OLD_FILE].path = fetchname(s + 4,
			    &names[OLD_FILE].exists, strippath);
d300 1
a300 2
			names[NEW_FILE].path = fetchname(s + 4,
			    &names[NEW_FILE].exists, strippath);
d302 1
a302 3
			/* pretend it is the old name */
			names[OLD_FILE].path = fetchname(s + 4,
			    &names[OLD_FILE].exists, strippath);
d304 1
a304 2
			names[INDEX_FILE].path = fetchname(s + 6,
			    &names[INDEX_FILE].exists, strippath);
d327 1
a327 1
			if (strnEQ(s + 4, "0,0", 3))
d338 1
a338 1
			if (atol(s + 4) == 0)
d341 2
a342 2
			 * If this is a new context diff the character just
			 * before the newline is a '*'.
d344 1
d364 18
a381 18
	if (retval == UNI_DIFF) {
		/* unswap old and new */
		struct file_name tmp = names[OLD_FILE];
		names[OLD_FILE] = names[NEW_FILE];
		names[NEW_FILE] = tmp;
	}
	if (filearg[0] == NULL) {
		if (posix)
			filearg[0] = posix_name(names, ok_to_create_file);
		else {
			/* Ignore the Index: name for context diffs, like GNU */
			if (names[OLD_FILE].path != NULL ||
			    names[NEW_FILE].path != NULL) {
				free(names[INDEX_FILE].path);
				names[INDEX_FILE].path = NULL;
			}
			filearg[0] = best_name(names, ok_to_create_file);
		}
d386 1
d389 23
a411 14
	else if (!ok_to_create_file) {
		/*
		 * We don't want to create a new file but we need a
		 * filename to set bestguess.  Avoid setting filearg[0]
		 * so the file is not created automatically.
		 */
		if (posix)
			bestguess = posix_name(names, true);
		else
			bestguess = best_name(names, true);
	}
	free(names[OLD_FILE].path);
	free(names[NEW_FILE].path);
	free(names[INDEX_FILE].path);
a1422 124
}

/*
 * Choose the name of the file to be patched based on POSIX rules.
 * NOTE: the POSIX rules are amazingly stupid and we only follow them
 *       if the user specified --posix or set POSIXLY_CORRECT.
 */
static char *
posix_name(const struct file_name *names, bool assume_exists)
{
	char *path = NULL;
	int i;

	/*
	 * POSIX states that the filename will be chosen from one
	 * of the old, new and index names (in that order) if
	 * the file exists relative to CWD after -p stripping.
	 */
	for (i = 0; i < MAX_FILE; i++) {
		if (names[i].path != NULL && names[i].exists) {
			path = names[i].path;
			break;
		}
	}
	if (path == NULL && !assume_exists) {
		/*
		 * No files found, look for something we can checkout from
		 * RCS/SCCS dirs.  Same order as above.
		 */
		for (i = 0; i < MAX_FILE; i++) {
			if (names[i].path != NULL &&
			    (path = checked_in(names[i].path)) != NULL)
				break;
		}
		/*
		 * Still no match?  Check to see if the diff could be creating
		 * a new file.
		 */
		if (path == NULL && ok_to_create_file &&
		    names[NEW_FILE].path != NULL)
			path = names[NEW_FILE].path;
	}

	return path ? savestr(path) : NULL;
}

/*
 * Choose the name of the file to be patched based the "best" one
 * available.
 */
static char *
best_name(const struct file_name *names, bool assume_exists)
{
	size_t min_components, min_baselen, min_len, tmp;
	char *best = NULL;
	int i;

	/*
	 * The "best" name is the one with the fewest number of path
	 * components, the shortest basename length, and the shortest
	 * overall length (in that order).  We only use the Index: file
	 * if neither of the old or new files could be intuited from
	 * the diff header.
	 */
	min_components = min_baselen = min_len = SIZE_MAX;
	for (i = INDEX_FILE; i >= OLD_FILE; i--) {
		if (names[i].path == NULL ||
		    (!names[i].exists && !assume_exists))
			continue;
		if ((tmp = num_components(names[i].path)) > min_components)
			continue;
		min_components = tmp;
		if ((tmp = strlen(basename(names[i].path))) > min_baselen)
			continue;
		min_baselen = tmp;
		if ((tmp = strlen(names[i].path)) > min_len)
			continue;
		min_len = tmp;
		best = names[i].path;
	}
	if (best == NULL) {
		/*
		 * No files found, look for something we can checkout from
		 * RCS/SCCS dirs.  Logic is identical to that above...
		 */
		min_components = min_baselen = min_len = SIZE_MAX;
		for (i = INDEX_FILE; i >= OLD_FILE; i--) {
			if (names[i].path == NULL ||
			    checked_in(names[i].path) == NULL)
				continue;
			if ((tmp = num_components(names[i].path)) > min_components)
				continue;
			min_components = tmp;
			if ((tmp = strlen(basename(names[i].path))) > min_baselen)
				continue;
			min_baselen = tmp;
			if ((tmp = strlen(names[i].path)) > min_len)
				continue;
			min_len = tmp;
			best = names[i].path;
		}
		/*
		 * Still no match?  Check to see if the diff could be creating
		 * a new file.
		 */
		if (best == NULL && ok_to_create_file &&
		    names[NEW_FILE].path != NULL)
			best = names[NEW_FILE].path;
	}

	return best ? savestr(best) : NULL;
}

static size_t
num_components(const char *path)
{
	size_t n;
	const char *cp;

	for (n = 0, cp = path; (cp = strchr(cp, '/')) != NULL; n++, cp++) {
		while (*cp == '/')
			cp++;		/* skip consecutive slashes */
	}
	return n;
@


1.1.1.10
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.33 2004/01/28 08:31:07 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.33 2004/01/28 08:31:07 otto Exp $";
d231 1
a236 1
			free(filearg[0]);
@


1.1.1.11
log
@better patch(1) fixes from obsd
@
text
@d1 1
a1 1
/*	$OpenBSD: pch.c,v 1.35 2004/08/05 21:47:24 deraadt Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: pch.c,v 1.35 2004/08/05 21:47:24 deraadt Exp $";
d146 1
a146 1
	char		**new_p_line;
a968 6
				}
				if (fillsrc > p_ptrn_lines) {
					if (remove_special_line()) {
						p_len[fillsrc - 1] -= 1;
						s[p_len[fillsrc - 1]] = 0;
					}
@


