head	1.4;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.10
	tg-mergefixes-1-branch:1.1.1.10.0.4
	tg-mergefixes-1-base:1.1.1.10
	MIROS_X:1.1.1.10.0.2
	MIROS_X_BASE:1.1.1.10
	tg-mergetmp-3:1.1.1.10
	cvs-200411210200:1.1.1.10
	MIRBSD_XP_MIRPPC:1.1.1.8.0.4
	cvs-200411031540:1.1.1.9
	MIRBSD_XP_SPARC_BASE:1.1.1.8
	MIRBSD_XP_SPARC:1.1.1.8.0.2
	MIRBSD_7quater:1.1.1.7
	cvs-200405160640:1.1.1.8
	cvs-200401271800:1.1.1.8
	cvs-200401261630:1.1.1.8
	cvs-200401021645:1.1.1.8
	MIRBSD_7_ALPHA:1.1.1.7.0.6
	MIRBSD_7:1.1.1.7.0.4
	cvs-200312222040:1.1.1.8
	MIRBSD_7ter:1.1.1.7
	MIRBSD_7_DEV:1.1.1.7.0.2
	cvs-200310020700:1.1.1.7
	cvs-200309271030:1.1.1.7
	cvs-200309251530:1.1.1.7
	cvs-200308302005:1.1.1.7
	cvs-200308171200:1.1.1.7
	ctm-3496:1.1.1.6
	ctm-3449:1.1.1.5
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.3
	ctm-3425:1.1.1.3
	cvs-200307091500:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.11.21.02.08.00;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.03.15.46.16;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.19.18.11.04;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.53.11;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.53.11;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.55.17;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.07.18.13.52.57;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.07.22.15.02.41;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.07.26.13.24.19;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.08.11.18.45.27;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.08.17.14.45.42;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.12.22.21.13.53;	author tg;	state Stab;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.03.15.45.19;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.21.02.03.51;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@merge
@
text
@/**	$MirBSD: src/usr.bin/patch/util.c,v 1.3 2004/11/03 15:46:16 tg Exp $ */
/*	$OpenBSD: util.c,v 1.29 2004/11/19 20:00:57 otto Exp $	*/

/*
 * patch - a program to apply diffs to original files
 *
 * Copyright 1986, Larry Wall
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following condition is met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this condition and the following disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * -C option added in 1998, original code by Marc Espie, based on FreeBSD
 * behaviour
 */

#if 0
static const char rcsid[] = "$OpenBSD: util.c,v 1.29 2004/11/19 20:00:57 otto Exp $";
#endif /* not lint */

#include <sys/param.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <paths.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "common.h"
#include "util.h"
#include "backupfile.h"
#include "pathnames.h"

__RCSID("$MirBSD: src/usr.bin/patch/util.c,v 1.3 2004/11/03 15:46:16 tg Exp $");

/* Rename a file, copying it if necessary. */

int
move_file(const char *from, const char *to)
{
	int	fromfd;
	ssize_t	i;

	/* to stdout? */

	if (strEQ(to, "-")) {
#ifdef DEBUGGING
		if (debug & 4)
			say("Moving %s to stdout.\n", from);
#endif
		fromfd = open(from, O_RDONLY);
		if (fromfd < 0)
			pfatal("internal error, can't reopen %s", from);
		while ((i = read(fromfd, buf, sizeof buf)) > 0)
			if (write(STDOUT_FILENO, buf, i) != i)
				pfatal("write failed");
		close(fromfd);
		return 0;
	}
	if (backup_file(to) < 0) {
		say("Can't backup %s, output is in %s: %s\n", to, from,
		    strerror(errno));
		return -1;
	}
#ifdef DEBUGGING
	if (debug & 4)
		say("Moving %s to %s.\n", from, to);
#endif
	if (rename(from, to) < 0) {
		if (errno != EXDEV || copy_file(from, to) < 0) {
			say("Can't create %s, output is in %s: %s\n",
			    to, from, strerror(errno));
			return -1;
		}
	}
	return 0;
}

/* Backup the original file.  */

int
backup_file(const char *orig)
{
	struct stat	filestat;
	char		bakname[MAXPATHLEN], *s, *simplename;
	dev_t		orig_device;
	ino_t		orig_inode;

	if (backup_type == none || stat(orig, &filestat) != 0)
		return 0;			/* nothing to do */
	orig_device = filestat.st_dev;
	orig_inode = filestat.st_ino;

	if (origprae) {
		if (strlcpy(bakname, origprae, sizeof(bakname)) >= sizeof(bakname) ||
		    strlcat(bakname, orig, sizeof(bakname)) >= sizeof(bakname))
			fatal("filename %s too long for buffer\n", origprae);
	} else {
		if ((s = find_backup_file_name(orig)) == NULL)
			fatal("out of memory\n");
		if (strlcpy(bakname, s, sizeof(bakname)) >= sizeof(bakname))
			fatal("filename %s too long for buffer\n", s);
		free(s);
	}

	if ((simplename = strrchr(bakname, '/')) != NULL)
		simplename = simplename + 1;
	else
		simplename = bakname;

	/*
	 * Find a backup name that is not the same file. Change the
	 * first lowercase char into uppercase; if that isn't
	 * sufficient, chop off the first char and try again.
	 */
	while (stat(bakname, &filestat) == 0 &&
	    orig_device == filestat.st_dev && orig_inode == filestat.st_ino) {
		/* Skip initial non-lowercase chars.  */
		for (s = simplename; *s && !islower(*s); s++)
			;
		if (*s)
			*s = toupper(*s);
		else
			memmove(simplename, simplename + 1,
			    strlen(simplename + 1) + 1);
	}
#ifdef DEBUGGING
	if (debug & 4)
		say("Moving %s to %s.\n", orig, bakname);
#endif
	if (rename(orig, bakname) < 0) {
		if (errno != EXDEV || copy_file(orig, bakname) < 0)
			return -1;
	}
	return 0;
}

/*
 * Copy a file.
 */
int
copy_file(const char *from, const char *to)
{
	int	tofd, fromfd;
	ssize_t	i;

	tofd = open(to, O_CREAT|O_TRUNC|O_WRONLY, 0666);
	if (tofd < 0)
		return -1;
	fromfd = open(from, O_RDONLY, 0);
	if (fromfd < 0)
		pfatal("internal error, can't reopen %s", from);
	while ((i = read(fromfd, buf, sizeof buf)) > 0)
		if (write(tofd, buf, i) != i)
			pfatal("write to %s failed", to);
	close(fromfd);
	close(tofd);
	return 0;
}

/*
 * Allocate a unique area for a string.
 */
char *
savestr(const char *s)
{
	char	*rv;

	if (!s)
		s = "Oops";
	rv = strdup(s);
	if (rv == NULL) {
		if (using_plan_a)
			out_of_mem = true;
		else
			fatal("out of memory\n");
	}
	return rv;
}

/*
 * Vanilla terminal output (buffered).
 */
void
say(const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	fflush(stderr);
}

/*
 * Terminal output, pun intended.
 */
void
fatal(const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	fprintf(stderr, "patch: **** ");
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	my_exit(2);
}

/*
 * Say something from patch, something from the system, then silence . . .
 */
void
pfatal(const char *fmt, ...)
{
	va_list	ap;
	int	errnum = errno;

	fprintf(stderr, "patch: **** ");
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	fprintf(stderr, ": %s\n", strerror(errnum));
	my_exit(2);
}

/*
 * Get a response from the user via /dev/tty
 */
void
ask(const char *fmt, ...)
{
	va_list	ap;
	ssize_t	nr;
	static	int ttyfd = -1;

	va_start(ap, fmt);
	vfprintf(stdout, fmt, ap);
	va_end(ap);
	fflush(stdout);
	if (ttyfd < 0)
		ttyfd = open(_PATH_TTY, O_RDONLY);
	if (ttyfd >= 0) {
		if ((nr = read(ttyfd, buf, sizeof(buf))) > 0 &&
		    buf[nr - 1] == '\n')
			buf[nr - 1] = '\0';
	}
	if (ttyfd < 0 || nr <= 0) {
		/* no tty or error reading, pretend user entered 'return' */
		putchar('\n');
		buf[0] = '\0';
	}
}

/*
 * How to handle certain events when not in a critical region.
 */
void
set_signals(int reset)
{
	static sig_t	hupval, intval;

	if (!reset) {
		hupval = signal(SIGHUP, SIG_IGN);
		if (hupval != SIG_IGN)
			hupval = (sig_t) my_exit;
		intval = signal(SIGINT, SIG_IGN);
		if (intval != SIG_IGN)
			intval = (sig_t) my_exit;
	}
	signal(SIGHUP, hupval);
	signal(SIGINT, intval);
}

/*
 * How to handle certain events when in a critical region.
 */
void
ignore_signals(void)
{
	signal(SIGHUP, SIG_IGN);
	signal(SIGINT, SIG_IGN);
}

/*
 * Make sure we'll have the directories to create a file. If `striplast' is
 * true, ignore the last element of `filename'.
 */

void
makedirs(const char *filename, bool striplast)
{
	char	*tmpbuf;

	if ((tmpbuf = strdup(filename)) == NULL)
		fatal("out of memory\n");

	if (striplast) {
		char	*s = strrchr(tmpbuf, '/');
		if (s == NULL)
			return;	/* nothing to be done */
		*s = '\0';
	}
	if (snprintf(buf, sizeof(buf), "%s -p %s", _PATH_MKDIR, tmpbuf)
	    >= sizeof(buf))
		fatal("buffer too small to hold %.20s...\n", tmpbuf);

	if (system(buf))
		pfatal("%.40s failed", buf);
}

/*
 * Make filenames more reasonable.
 */
char *
fetchname(const char *at, bool *exists, int strip_leading)
{
	char		*fullname, *name, *t;
	int		sleading, tab;
	struct stat	filestat;

	if (at == NULL || *at == '\0')
		return NULL;
	while (isspace(*at))
		at++;
#ifdef DEBUGGING
	if (debug & 128)
		say("fetchname %s %d\n", at, strip_leading);
#endif
	/* So files can be created by diffing against /dev/null.  */
	if (strnEQ(at, _PATH_DEVNULL, sizeof(_PATH_DEVNULL) - 1))
		return NULL;
	name = fullname = t = savestr(at);

	tab = strchr(t, '\t') != NULL;
	/* Strip off up to `strip_leading' path components and NUL terminate. */
	for (sleading = strip_leading; *t != '\0' && ((tab && *t != '\t') ||
	    !isspace(*t)); t++) {
		if (t[0] == '/' && t[1] != '/' && t[1] != '\0')
			if (--sleading >= 0)
				name = t + 1;
	}
	*t = '\0';

	/*
	 * If no -p option was given (957 is the default value!), we were
	 * given a relative pathname, and the leading directories that we
	 * just stripped off all exist, put them back on.
	 */
	if (strip_leading == 957 && name != fullname && *fullname != '/') {
		name[-1] = '\0';
		if (stat(fullname, &filestat) == 0 && S_ISDIR(filestat.st_mode)) {
			name[-1] = '/';
			name = fullname;
		}
	}
	name = savestr(name);
	free(fullname);

	*exists = stat(name, &filestat) == 0;
	return name;
}

/*
 * Takes the name returned by fetchname and looks in RCS/SCCS directories
 * for a checked in version.
 */
char *
checked_in(char *file)
{
	char		*filebase, *filedir, tmpbuf[MAXPATHLEN];
	struct stat	filestat;

	filebase = basename(file);
	filedir = dirname(file);

#define try(f, a1, a2, a3) \
(snprintf(tmpbuf, sizeof tmpbuf, f, a1, a2, a3), stat(tmpbuf, &filestat) == 0)

	if (try("%s/RCS/%s%s", filedir, filebase, RCSSUFFIX) ||
	    try("%s/RCS/%s%s", filedir, filebase, "") ||
	    try("%s/%s%s", filedir, filebase, RCSSUFFIX) ||
	    try("%s/SCCS/%s%s", filedir, SCCSPREFIX, filebase) ||
	    try("%s/%s%s", filedir, SCCSPREFIX, filebase))
		return file;

	return NULL;
}

void
version(void)
{
	fprintf(stderr, "Patch version 2.0-12u8-MirBSD\n");
	my_exit(EXIT_SUCCESS);
}

/*
 * Exit with cleanup.
 */
void
my_exit(int status)
{
	unlink(TMPINNAME);
	if (!toutkeep)
		unlink(TMPOUTNAME);
	if (!trejkeep)
		unlink(TMPREJNAME);
	unlink(TMPPATNAME);
	exit(status);
}
@


1.3
log
@merge
@
text
@d1 2
a2 2
/**	$MirBSD$ */
/*	$OpenBSD: util.c,v 1.28 2004/08/05 21:47:24 deraadt Exp $	*/
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.28 2004/08/05 21:47:24 deraadt Exp $";
d53 1
a53 1
__RCSID("$MirBSD$");
d338 1
a338 1
	int		sleading;
d354 1
d356 2
a357 1
	for (sleading = strip_leading; *t != '\0' && !isspace(*t); t++) {
@


1.2
log
@make patch(1) space-safe
from kurt miller
@
text
@d2 1
a2 1
/*	$OpenBSD: util.c,v 1.27 2003/10/31 20:20:45 millert Exp $	*/
d30 4
d354 2
a355 15
	/* find filename by locating the last '/' if any */
	for (; *t != '\0'; t++) {
		if (t[0] == '/' && t[1] != '/' && t[1] != '\0')
			name = t + 1;
	}

	/* NULL terminate filename */
	for (t = name; *t != '\0' && !isspace(*t); t++)
		continue;
	*t = '\0';

	name = t = fullname;

	/* Strip off up to `strip_leading' path components. */
	for (sleading = strip_leading; *t != '\0'; t++) {
d360 1
d410 1
a410 1
	fprintf(stderr, "Patch version 2.0-12u8-OpenBSD\n");
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: util.c,v 1.9 1999/12/04 21:00:03 provos Exp $	*/
d4 39
a42 3
#ifndef lint
static char rcsid[] = "$OpenBSD: util.c,v 1.9 1999/12/04 21:00:03 provos Exp $";
#endif /* not lint */
a43 1
#include "EXTERN.h"
a44 1
#include "INTERN.h"
d47 1
d49 1
a49 5
#ifdef __GNUC__
void my_exit() __attribute__((noreturn));
#else
void my_exit();
#endif
d54 1
a54 2
move_file(from,to)
char *from, *to;
d56 2
a57 4
    char bakname[MAXPATHLEN];
    Reg1 char *s;
    Reg2 int i;
    Reg3 int fromfd;
d59 1
a59 1
    /* to stdout? */
d61 19
a79 1
    if (strEQ(to, "-")) {
d82 1
a82 1
	    say2("Moving %s to stdout.\n", from);
d84 7
a90 7
	fromfd = open(from, O_RDONLY);
	if (fromfd < 0)
	    pfatal2("internal error, can't reopen %s", from);
	while ((i=read(fromfd, buf, sizeof buf)) > 0)
	    if (write(1, buf, i) != 1)
		pfatal1("write failed");
	Close(fromfd);
d92 3
a94 1
    }
d96 35
a130 31
    if (origprae) {
	if (strlcpy(bakname, origprae, sizeof(bakname)) >= sizeof(bakname) ||
	    strlcat(bakname, to, sizeof(bakname)) >= sizeof(bakname))
	    fatal2("filename %s too long for buffer\n", origprae);
    } else {
#ifndef NODIR
	char *backupname = find_backup_file_name(to);
	if (backupname == (char *) 0)
	    fatal1("out of memory\n");
	if (strlcpy(bakname, backupname, sizeof(bakname)) >= sizeof(bakname))
	    fatal2("filename %s too long for buffer\n", backupname);
	free(backupname);
#else /* NODIR */
	if (strlcpy(bakname, to, sizeof(bakname)) >= sizeof(bakname) ||
	    strlcat(bakname, simple_backup_suffix, sizeof(bakname)) >= sizeof(bakname))
	    fatal2("filename %s too long for buffer\n", to);
#endif /* NODIR */
    }

    if (stat(to, &filestat) == 0) {	/* output file exists */
	dev_t to_device = filestat.st_dev;
	ino_t to_inode  = filestat.st_ino;
	char *simplename = bakname;
	
	for (s=bakname; *s; s++) {
	    if (*s == '/')
		simplename = s+1;
	}
	/* Find a backup name that is not the same file.
	   Change the first lowercase char into uppercase;
	   if that isn't sufficient, chop off the first char and try again.  */
d132 9
a140 7
		to_device == filestat.st_dev && to_inode == filestat.st_ino) {
	    /* Skip initial non-lowercase chars.  */
	    for (s=simplename; *s && !islower(*s); s++) ;
	    if (*s)
		*s = toupper(*s);
	    else
		strcpy(simplename, simplename+1);
a141 1
	while (unlink(bakname) >= 0) ;	/* while() is for benefit of Eunice */
d144 1
a144 1
	    say3("Moving %s to %s.\n", to, bakname);
d146 3
a148 21
	if (link(to, bakname) < 0) {
	    /* Maybe `to' is a symlink into a different file system.
	       Copying replaces the symlink with a file; using rename
	       would be better.  */
	    Reg4 int tofd;
	    Reg5 int bakfd;

	    bakfd = creat(bakname, 0666);
	    if (bakfd < 0) {
		say4("Can't backup %s, output is in %s: %s\n", to, from,
		     strerror(errno));
		return -1;
	    }
	    tofd = open(to, O_RDONLY);
	    if (tofd < 0)
		pfatal2("internal error, can't open %s", to);
	    while ((i=read(tofd, buf, sizeof buf)) > 0)
		if (write(bakfd, buf, i) != i)
		    pfatal1("write failed");
	    Close(tofd);
	    Close(bakfd);
d150 1
a150 26
	while (unlink(to) >= 0) ;
    }
#ifdef DEBUGGING
    if (debug & 4)
	say3("Moving %s to %s.\n", from, to);
#endif
    if (link(from, to) < 0) {		/* different file system? */
	Reg4 int tofd;
	
	tofd = creat(to, 0666);
	if (tofd < 0) {
	    say4("Can't create %s, output is in %s: %s\n",
	      to, from, strerror(errno));
	    return -1;
	}
	fromfd = open(from, O_RDONLY);
	if (fromfd < 0)
	    pfatal2("internal error, can't reopen %s", from);
	while ((i=read(fromfd, buf, sizeof buf)) > 0)
	    if (write(tofd, buf, i) != i)
		pfatal1("write failed");
	Close(fromfd);
	Close(tofd);
    }
    Unlink(from);
    return 0;
d153 8
a160 1
/* Copy a file. */
d162 12
a173 19
void
copy_file(from,to)
char *from, *to;
{
    Reg3 int tofd;
    Reg2 int fromfd;
    Reg1 int i;
    
    tofd = creat(to, 0666);
    if (tofd < 0)
	pfatal2("can't create %s", to);
    fromfd = open(from, O_RDONLY);
    if (fromfd < 0)
	pfatal2("internal error, can't reopen %s", from);
    while ((i=read(fromfd, buf, sizeof buf)) > 0)
	if (write(tofd, buf, i) != i)
	    pfatal2("write to %s failed", to);
    Close(fromfd);
    Close(tofd);
d176 3
a178 2
/* Allocate a unique area for a string. */

d180 1
a180 2
savestr(s)
Reg1 char *s;
d182 1
a182 2
    Reg3 char *rv;
    Reg2 char *t;
d184 11
a194 29
    if (!s)
	s = "Oops";
    t = s;
    while (*t++);
    rv = malloc((MEM) (t - s));
    if (rv == Nullch) {
	if (using_plan_a)
	    out_of_mem = TRUE;
	else
	    fatal1("out of memory\n");
    }
    else {
	t = rv;
	while ((*t++ = *s++))
	    ;
    }
    return rv;
}

#if defined(lint) && defined(CANVARARG)

/*VARARGS ARGSUSED*/
say(pat) char *pat; { ; }
/*VARARGS ARGSUSED*/
fatal(pat) char *pat; { ; }
/*VARARGS ARGSUSED*/
pfatal(pat) char *pat; { ; }
/*VARARGS ARGSUSED*/
ask(pat) char *pat; { ; }
d196 7
a202 1
#else
d204 5
a208 1
/* Vanilla terminal output (buffered). */
d210 3
d214 1
a214 3
say(pat,arg1,arg2,arg3)
char *pat;
long arg1,arg2,arg3;
d216 7
a222 2
    fprintf(stderr, pat, arg1, arg2, arg3);
    Fflush(stderr);
d225 16
a240 1
/* Terminal output, pun intended. */
d242 5
a246 4
void				/* very void */
fatal(pat,arg1,arg2,arg3)
char *pat;
long arg1,arg2,arg3;
d248 20
a267 3
    fprintf(stderr, "patch: **** ");
    fprintf(stderr, pat, arg1, arg2, arg3);
    my_exit(1);
d270 5
a274 6
/* Say something from patch, something from the system, then silence . . . */

void				/* very void */
pfatal(pat,arg1,arg2,arg3)
char *pat;
long arg1,arg2,arg3;
d276 1
a276 1
    int errnum = errno;
d278 10
a287 4
    fprintf(stderr, "patch: **** ");
    fprintf(stderr, pat, arg1, arg2, arg3);
    fprintf(stderr, ": %s\n", strerror(errnum));
    my_exit(1);
d290 3
a292 2
/* Get a response from the user, somehow or other. */

d294 4
a297 40
ask(pat,arg1,arg2,arg3)
char *pat;
long arg1,arg2,arg3;
{
    int ttyfd;
    int r;
    bool tty2 = isatty(2);

    Snprintf(buf, sizeof buf, pat, arg1, arg2, arg3);
    Fflush(stderr);
    write(2, buf, strlen(buf));
    if (tty2) {				/* might be redirected to a file */
	r = read(2, buf, sizeof buf);
    }
    else if (isatty(1)) {		/* this may be new file output */
	Fflush(stdout);
	write(1, buf, strlen(buf));
	r = read(1, buf, sizeof buf);
    }
    else if ((ttyfd = open(_PATH_TTY, O_RDWR)) >= 0 && isatty(ttyfd)) {
					/* might be deleted or unwriteable */
	write(ttyfd, buf, strlen(buf));
	r = read(ttyfd, buf, sizeof buf);
	Close(ttyfd);
    }
    else if (isatty(0)) {		/* this is probably patch input */
	Fflush(stdin);
	write(0, buf, strlen(buf));
	r = read(0, buf, sizeof buf);
    }
    else {				/* no terminal at all--default it */
	buf[0] = '\n';
	r = 1;
    }
    if (r <= 0)
	buf[0] = 0;
    else
	buf[r] = '\0';
    if (!tty2)
	say1(buf);
a298 1
#endif /* lint */
d300 4
a303 1
/* How to handle certain events when not in a critical region. */
d306 1
a306 2
set_signals(reset)
int reset;
d308 4
a311 2
#ifndef lint
    static sig_t hupval, intval;
d313 12
a324 11
    if (!reset) {
	hupval = signal(SIGHUP, SIG_IGN);
	if (hupval != SIG_IGN)
	    hupval = (sig_t)my_exit;
	intval = signal(SIGINT, SIG_IGN);
	if (intval != SIG_IGN)
	    intval = (sig_t)my_exit;
    }
    Signal(SIGHUP, hupval);
    Signal(SIGINT, intval);
#endif
d327 5
a331 4
/* How to handle certain events when in a critical region. */

void
ignore_signals()
d333 11
a343 3
#ifndef lint
    Signal(SIGHUP, SIG_IGN);
    Signal(SIGINT, SIG_IGN);
d345 42
d389 6
a394 7
/* Make sure we'll have the directories to create a file.
   If `striplast' is TRUE, ignore the last element of `filename'.  */

void
makedirs(filename,striplast)
Reg1 char *filename;
bool striplast;
d396 2
a397 1
    char *tmpbuf;
d399 2
a400 2
    if ((tmpbuf = strdup(filename)) == NULL)
        fatal1("out of memory\n");
d402 2
a403 6
    if (striplast) {
        char *s = strrchr(tmpbuf, '/');
	if (s == NULL)
	  return; /* nothing to be done */
	*s = '\0';
    }
d405 6
a410 3
    strcpy(buf, "/bin/mkdir -p ");
    if (strlcat(buf, tmpbuf, sizeof(buf)) >= sizeof(buf))
      fatal2("buffer too small to hold %.20s...\n", tmpbuf);
d412 1
a412 2
    if (system(buf))
      pfatal2("%.40s failed", buf);
d415 6
a420 1
/* Make filenames more reasonable. */
d422 13
a434 62
char *
fetchname(at,strip_leading,assume_exists)
char *at;
int strip_leading;
int assume_exists;
{
    char *fullname;
    char *name;
    Reg1 char *t;
    char tmpbuf[200];
    int sleading = strip_leading;

    if (!at || *at == '\0')
	return Nullch;
    while (isspace(*at))
	at++;
#ifdef DEBUGGING
    if (debug & 128)
	say4("fetchname %s %d %d\n",at,strip_leading,assume_exists);
#endif
    if (strnEQ(at, "/dev/null", 9))	/* so files can be created by diffing */
	return Nullch;			/*   against /dev/null. */
    name = fullname = t = savestr(at);

    /* Strip off up to `sleading' leading slashes and null terminate.  */
    for (; *t && !isspace(*t); t++)
	if (*t == '/')
	    if (--sleading >= 0)
		name = t+1;
    *t = '\0';

    /* If no -p option was given (957 is the default value!),
       we were given a relative pathname,
       and the leading directories that we just stripped off all exist,
       put them back on.  */
    if (strip_leading == 957 && name != fullname && *fullname != '/') {
	name[-1] = '\0';
	if (stat(fullname, &filestat) == 0 && S_ISDIR (filestat.st_mode)) {
	    name[-1] = '/';
	    name=fullname;
	}
    }

    name = savestr(name);
    free(fullname);

    if (stat(name, &filestat) && !assume_exists) {
	char *filebase = basename(name);
	char *filedir = dirname(name);

#define try(f, a1, a2, a3) (Snprintf(tmpbuf, sizeof tmpbuf, f, a1, a2, a3), stat(tmpbuf, &filestat) == 0)
	if (   try("%s/RCS/%s%s", filedir, filebase, RCSSUFFIX)
	    || try("%s/RCS/%s%s", filedir, filebase,        "")
	    || try(    "%s/%s%s", filedir, filebase, RCSSUFFIX)
	    || try("%s/SCCS/%s%s", filedir, SCCSPREFIX, filebase)
	    || try(     "%s/%s%s", filedir, SCCSPREFIX, filebase))
	  return name;
	free(name);
	name = Nullch;
    }

    return name;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 2003/04/08 00:18:31 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.11 2003/04/08 00:18:31 deraadt Exp $";
d85 1
a85 1
		memmove(simplename, simplename+1, strlen(simplename+1)+1);
d343 1
a343 1
    strlcpy(buf, "/bin/mkdir -p ", sizeof buf);
@


1.1.1.3
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2003/07/18 02:00:09 deraadt Exp $	*/
d4 1
a4 1
static char rcsid[] = "$OpenBSD: util.c,v 1.12 2003/07/18 02:00:09 deraadt Exp $";
d13 5
a17 1
void my_exit(int) __attribute__((noreturn));
d26 3
a28 3
    char *s;
    int i;
    int fromfd;
d35 1
a35 1
	    say("Moving %s to stdout.\n", from);
d39 1
a39 1
	    pfatal("internal error, can't reopen %s", from);
d42 2
a43 2
		pfatal("write failed");
	close(fromfd);
d50 1
a50 1
	    fatal("filename %s too long for buffer\n", origprae);
d55 1
a55 1
	    fatal("out of memory\n");
d57 1
a57 1
	    fatal("filename %s too long for buffer\n", backupname);
d62 1
a62 1
	    fatal("filename %s too long for buffer\n", to);
d70 1
a70 1

d90 1
a90 1
	    say("Moving %s to %s.\n", to, bakname);
d96 2
a97 2
	    int tofd;
	    int bakfd;
d101 1
a101 1
		say("Can't backup %s, output is in %s: %s\n", to, from,
d107 1
a107 1
		pfatal("internal error, can't open %s", to);
d110 3
a112 3
		    pfatal("write failed");
	    close(tofd);
	    close(bakfd);
d118 1
a118 1
	say("Moving %s to %s.\n", from, to);
d121 2
a122 2
	int tofd;

d125 1
a125 1
	    say("Can't create %s, output is in %s: %s\n",
d131 1
a131 1
	    pfatal("internal error, can't reopen %s", from);
d134 3
a136 3
		pfatal("write failed");
	close(fromfd);
	close(tofd);
d138 1
a138 1
    unlink(from);
d148 4
a151 4
    int tofd;
    int fromfd;
    int i;

d154 1
a154 1
	pfatal("can't create %s", to);
d157 1
a157 1
	pfatal("internal error, can't reopen %s", from);
d160 3
a162 3
	    pfatal("write to %s failed", to);
    close(fromfd);
    close(tofd);
d169 1
a169 1
char *s;
d171 2
a172 2
    char *rv;
    char *t;
d183 1
a183 1
	    fatal("out of memory\n");
d193 13
d209 3
a211 1
say(char *fmt, ...)
d213 2
a214 6
    va_list ap;

    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);
    fflush(stderr);
d219 4
a222 2
void
fatal(char *fmt, ...)
a223 3
    va_list ap;

    va_start(ap, fmt);
d225 1
a225 2
    vfprintf(stderr, fmt, ap);
    va_end(ap);
d231 4
a234 2
void
pfatal(char *fmt, ...)
a235 1
    va_list ap;
d239 1
a239 3
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);
d247 3
a249 1
ask(char *fmt, ...)
a250 1
    va_list ap;
d255 2
a256 4
    va_start(ap, fmt);
    vsnprintf(buf, sizeof buf, fmt, ap);
    va_end(ap);
    fflush(stderr);
d260 3
a262 2
    } else if (isatty(1)) {		/* this may be new file output */
	fflush(stdout);
d265 3
a267 2
    } else if ((ttyfd = open(_PATH_TTY, O_RDWR)) >= 0 && isatty(ttyfd)) {
	/* might be deleted or unwriteable */
d270 4
a273 3
	close(ttyfd);
    } else if (isatty(0)) {		/* this is probably patch input */
	fflush(stdin);
d276 2
a277 1
    } else {				/* no terminal at all--default it */
d286 1
a286 1
	say(buf);
d288 1
d307 2
a308 2
    signal(SIGHUP, hupval);
    signal(SIGINT, intval);
d318 2
a319 2
    signal(SIGHUP, SIG_IGN);
    signal(SIGINT, SIG_IGN);
d328 1
a328 1
char *filename;
d334 1
a334 1
        fatal("out of memory\n");
d345 1
a345 1
      fatal("buffer too small to hold %.20s...\n", tmpbuf);
d348 1
a348 1
      pfatal("%.40s failed", buf);
d361 1
a361 1
    char *t;
d371 1
a371 1
	say("fetchname %s %d %d\n",at,strip_leading,assume_exists);
d403 1
a403 1
#define try(f, a1, a2, a3) (snprintf(tmpbuf, sizeof tmpbuf, f, a1, a2, a3), stat(tmpbuf, &filestat) == 0)
a414 7
}

void
version()
{
    fprintf(stderr, "Patch version 2.0-12u8-OpenBSD\n");
    my_exit(0);
@


1.1.1.4
log
@Sync to OpenBSD 3.3-current
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2003/07/21 14:32:21 deraadt Exp $	*/
d4 2
a5 2
static char     rcsid[] = "$OpenBSD: util.c,v 1.15 2003/07/21 14:32:21 deraadt Exp $";
#endif				/* not lint */
d13 1
a13 1
void            my_exit(int) __attribute__((noreturn));
d18 2
a19 1
move_file(char *from, char *to)
d21 4
a24 2
	char	bakname[MAXPATHLEN], *s;
	int	i, fromfd;
d26 1
a26 1
	/* to stdout? */
d28 1
a28 1
	if (strEQ(to, "-")) {
d30 2
a31 2
		if (debug & 4)
			say("Moving %s to stdout.\n", from);
d33 37
a69 8
		fromfd = open(from, O_RDONLY);
		if (fromfd < 0)
			pfatal("internal error, can't reopen %s", from);
		while ((i = read(fromfd, buf, sizeof buf)) > 0)
			if (write(1, buf, i) != 1)
				pfatal("write failed");
		close(fromfd);
		return 0;
d71 11
a81 11
	if (origprae) {
		if (strlcpy(bakname, origprae, sizeof(bakname)) >= sizeof(bakname) ||
		    strlcat(bakname, to, sizeof(bakname)) >= sizeof(bakname))
			fatal("filename %s too long for buffer\n", origprae);
	} else {
		char	*backupname = find_backup_file_name(to);
		if (backupname == (char *) 0)
			fatal("out of memory\n");
		if (strlcpy(bakname, backupname, sizeof(bakname)) >= sizeof(bakname))
			fatal("filename %s too long for buffer\n", backupname);
		free(backupname);
d83 1
a83 29

	if (stat(to, &filestat) == 0) {	/* output file exists */
		dev_t	to_device = filestat.st_dev;
		ino_t	to_inode = filestat.st_ino;
		char	*simplename = bakname;

		for (s = bakname; *s; s++) {
			if (*s == '/')
				simplename = s + 1;
		}

		/*
		 * Find a backup name that is not the same file. Change the
		 * first lowercase char into uppercase; if that isn't
		 * sufficient, chop off the first char and try again.
		 */
		while (stat(bakname, &filestat) == 0 &&
		    to_device == filestat.st_dev && to_inode == filestat.st_ino) {
			/* Skip initial non-lowercase chars.  */
			for (s = simplename; *s && !islower(*s); s++)
				;
			if (*s)
				*s = toupper(*s);
			else
				memmove(simplename, simplename + 1,
				    strlen(simplename + 1) + 1);
		}
		unlink(bakname);

d85 2
a86 2
		if (debug & 4)
			say("Moving %s to %s.\n", to, bakname);
d88 21
a108 24
		if (link(to, bakname) < 0) {
			/*
			 * Maybe `to' is a symlink into a different file
			 * system. Copying replaces the symlink with a file;
			 * using rename would be better.
			 */
			int	tofd, bakfd;

			bakfd = creat(bakname, 0666);
			if (bakfd < 0) {
				say("Can't backup %s, output is in %s: %s\n",
				    to, from, strerror(errno));
				return -1;
			}
			tofd = open(to, O_RDONLY);
			if (tofd < 0)
				pfatal("internal error, can't open %s", to);
			while ((i = read(tofd, buf, sizeof buf)) > 0)
				if (write(bakfd, buf, i) != i)
					pfatal("write failed");
			close(tofd);
			close(bakfd);
		}
		unlink(to);
d110 2
d113 2
a114 2
	if (debug & 4)
		say("Moving %s to %s.\n", from, to);
d116 2
a117 2
	if (link(from, to) < 0) {	/* different file system? */
		int	tofd;
d119 5
a123 14
		tofd = creat(to, 0666);
		if (tofd < 0) {
			say("Can't create %s, output is in %s: %s\n",
			    to, from, strerror(errno));
			return -1;
		}
		fromfd = open(from, O_RDONLY);
		if (fromfd < 0)
			pfatal("internal error, can't reopen %s", from);
		while ((i = read(fromfd, buf, sizeof buf)) > 0)
			if (write(tofd, buf, i) != i)
				pfatal("write failed");
		close(fromfd);
		close(tofd);
d125 11
a135 2
	unlink(from);
	return 0;
d138 2
a139 3
/*
 * Copy a file.
 */
d141 2
a142 1
copy_file(char *from, char *to)
d144 16
a159 1
	int	tofd, fromfd, i;
d161 1
a161 12
	tofd = creat(to, 0666);
	if (tofd < 0)
		pfatal("can't create %s", to);
	fromfd = open(from, O_RDONLY);
	if (fromfd < 0)
		pfatal("internal error, can't reopen %s", from);
	while ((i = read(fromfd, buf, sizeof buf)) > 0)
		if (write(tofd, buf, i) != i)
			pfatal("write to %s failed", to);
	close(fromfd);
	close(tofd);
}
a162 3
/*
 * Allocate a unique area for a string.
 */
d164 2
a165 1
savestr(char *s)
d167 2
a168 1
	char	*rv, *t;
d170 17
a186 17
	if (!s)
		s = "Oops";
	t = s;
	while (*t++)
		;
	rv = malloc((size_t) (t - s));
	if (rv == Nullch) {
		if (using_plan_a)
			out_of_mem = TRUE;
		else
			fatal("out of memory\n");
	} else {
		t = rv;
		while ((*t++ = *s++))
			;
	}
	return rv;
d189 2
a190 3
/*
 * Vanilla terminal output (buffered).
 */
d194 1
a194 1
	va_list	ap;
d196 4
a199 4
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	fflush(stderr);
d202 2
a203 3
/*
 * Terminal output, pun intended.
 */
d207 1
a207 1
	va_list	ap;
d209 5
a213 5
	va_start(ap, fmt);
	fprintf(stderr, "patch: **** ");
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	my_exit(1);
d216 2
a217 3
/*
 * Say something from patch, something from the system, then silence . . .
 */
d221 2
a222 2
	va_list	ap;
	int	errnum = errno;
d224 6
a229 6
	fprintf(stderr, "patch: **** ");
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	fprintf(stderr, ": %s\n", strerror(errnum));
	my_exit(1);
d232 2
a233 3
/*
 * Get a response from the user, somehow or other.
 */
d237 35
a271 35
	va_list	ap;
	int	ttyfd, r;
	bool	tty2 = isatty(2);

	va_start(ap, fmt);
	vsnprintf(buf, sizeof buf, fmt, ap);
	va_end(ap);
	fflush(stderr);
	write(2, buf, strlen(buf));
	if (tty2) {
		/* might be redirected to a file */
		r = read(2, buf, sizeof buf);
	} else if (isatty(1)) {	/* this may be new file output */
		fflush(stdout);
		write(1, buf, strlen(buf));
		r = read(1, buf, sizeof buf);
	} else if ((ttyfd = open(_PATH_TTY, O_RDWR)) >= 0 && isatty(ttyfd)) {
		/* might be deleted or unwriteable */
		write(ttyfd, buf, strlen(buf));
		r = read(ttyfd, buf, sizeof buf);
		close(ttyfd);
	} else if (isatty(0)) {	/* this is probably patch input */
		fflush(stdin);
		write(0, buf, strlen(buf));
		r = read(0, buf, sizeof buf);
	} else {		/* no terminal at all--default it */
		buf[0] = '\n';
		r = 1;
	}
	if (r <= 0)
		buf[0] = 0;
	else
		buf[r] = '\0';
	if (!tty2)
		say(buf);
d274 2
a275 3
/*
 * How to handle certain events when not in a critical region.
 */
d277 2
a278 1
set_signals(int reset)
d281 1
a281 1
	static sig_t	hupval, intval;
d283 10
a292 10
	if (!reset) {
		hupval = signal(SIGHUP, SIG_IGN);
		if (hupval != SIG_IGN)
			hupval = (sig_t) my_exit;
		intval = signal(SIGINT, SIG_IGN);
		if (intval != SIG_IGN)
			intval = (sig_t) my_exit;
	}
	signal(SIGHUP, hupval);
	signal(SIGINT, intval);
d296 2
a297 3
/*
 * How to handle certain events when in a critical region.
 */
d299 1
a299 1
ignore_signals(void)
d302 2
a303 2
	signal(SIGHUP, SIG_IGN);
	signal(SIGINT, SIG_IGN);
d307 2
a308 4
/*
 * Make sure we'll have the directories to create a file. If `striplast' is
 * TRUE, ignore the last element of `filename'.
 */
d311 3
a313 1
makedirs(char *filename, bool striplast)
d315 4
a318 1
	char	*tmpbuf;
d320 6
a325 2
	if ((tmpbuf = strdup(filename)) == NULL)
		fatal("out of memory\n");
d327 3
a329 9
	if (striplast) {
		char	*s = strrchr(tmpbuf, '/');
		if (s == NULL)
			return;	/* nothing to be done */
		*s = '\0';
	}
	strlcpy(buf, "/bin/mkdir -p ", sizeof buf);
	if (strlcat(buf, tmpbuf, sizeof(buf)) >= sizeof(buf))
		fatal("buffer too small to hold %.20s...\n", tmpbuf);
d331 2
a332 2
	if (system(buf))
		pfatal("%.40s failed", buf);
d335 2
a336 3
/*
 * Make filenames more reasonable.
 */
d338 15
a352 9
fetchname(char *at, int strip_leading, int assume_exists)
{
	char	*fullname, *name, *t, tmpbuf[200];
	int	sleading = strip_leading;

	if (!at || *at == '\0')
		return Nullch;
	while (isspace(*at))
		at++;
d354 2
a355 2
	if (debug & 128)
		say("fetchname %s %d %d\n", at, strip_leading, assume_exists);
d357 20
a376 22
	if (strnEQ(at, "/dev/null", 9))	/* so files can be created by diffing */
		return Nullch;	/* against /dev/null. */
	name = fullname = t = savestr(at);

	/* Strip off up to `sleading' leading slashes and null terminate.  */
	for (; *t && !isspace(*t); t++)
		if (*t == '/')
			if (--sleading >= 0)
				name = t + 1;
	*t = '\0';

	/*
	 * If no -p option was given (957 is the default value!), we were
	 * given a relative pathname, and the leading directories that we
	 * just stripped off all exist, put them back on.
	 */
	if (strip_leading == 957 && name != fullname && *fullname != '/') {
		name[-1] = '\0';
		if (stat(fullname, &filestat) == 0 && S_ISDIR(filestat.st_mode)) {
			name[-1] = '/';
			name = fullname;
		}
d378 4
a381 2
	name = savestr(name);
	free(fullname);
d383 16
a398 17
	if (stat(name, &filestat) && !assume_exists) {
		char	*filebase = basename(name);
		char	*filedir = dirname(name);

#define try(f, a1, a2, a3) \
	(snprintf(tmpbuf, sizeof tmpbuf, f, a1, a2, a3), stat(tmpbuf, &filestat) == 0)

		if (try("%s/RCS/%s%s", filedir, filebase, RCSSUFFIX) ||
		    try("%s/RCS/%s%s", filedir, filebase, "") ||
		    try("%s/%s%s", filedir, filebase, RCSSUFFIX) ||
		    try("%s/SCCS/%s%s", filedir, SCCSPREFIX, filebase) ||
		    try("%s/%s%s", filedir, SCCSPREFIX, filebase))
			return name;
		free(name);
		name = Nullch;
	}
	return name;
d402 1
a402 1
version(void)
d404 2
a405 2
	fprintf(stderr, "Patch version 2.0-12u8-OpenBSD\n");
	my_exit(0);
@


1.1.1.5
log
@Import latest OpenBSD ports, XFree and source in sync
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2003/07/25 02:12:45 millert Exp $	*/
d4 2
a5 15
static const char     rcsid[] = "$OpenBSD: util.c,v 1.18 2003/07/25 02:12:45 millert Exp $";
#endif /* not lint */

#include <sys/param.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <paths.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
d13 1
d20 1
d34 1
a34 1
			if (write(STDOUT_FILENO, buf, i) != i)
a38 33
	if (backup_file(to) < 0) {
		say("Can't backup %s, output is in %s: %s\n", to, from,
		    strerror(errno));
		return -1;
	}
#ifdef DEBUGGING
	if (debug & 4)
		say("Moving %s to %s.\n", from, to);
#endif
	if (rename(from, to) < 0) {
		if (errno != EXDEV || copy_file(from, to) < 0) {
			say("Can't create %s, output is in %s: %s\n",
			    to, from, strerror(errno));
			return -1;
		}
	}
	return 0;
}

/* Backup the original file.  */

int
backup_file(char *orig)
{
	char	bakname[MAXPATHLEN], *s, *simplename;
	dev_t	orig_device;
	ino_t	orig_inode;

	if (backup_type == none || stat(orig, &filestat) != 0)
		return 0;			/* nothing to do */
	orig_device = filestat.st_dev;
	orig_inode = filestat.st_ino;

d41 1
a41 1
		    strlcat(bakname, orig, sizeof(bakname)) >= sizeof(bakname))
d44 2
a45 1
		if ((s = find_backup_file_name(orig)) == NULL)
d47 3
a49 3
		if (strlcpy(bakname, s, sizeof(bakname)) >= sizeof(bakname))
			fatal("filename %s too long for buffer\n", s);
		free(s);
d52 27
a78 4
	if ((simplename = strrchr(bakname, '/')) != NULL)
		simplename = simplename + 1;
	else
		simplename = bakname;
d80 28
a107 15
	/*
	 * Find a backup name that is not the same file. Change the
	 * first lowercase char into uppercase; if that isn't
	 * sufficient, chop off the first char and try again.
	 */
	while (stat(bakname, &filestat) == 0 &&
	    orig_device == filestat.st_dev && orig_inode == filestat.st_ino) {
		/* Skip initial non-lowercase chars.  */
		for (s = simplename; *s && !islower(*s); s++)
			;
		if (*s)
			*s = toupper(*s);
		else
			memmove(simplename, simplename + 1,
			    strlen(simplename + 1) + 1);
d111 1
a111 1
		say("Moving %s to %s.\n", orig, bakname);
d113 7
a119 2
	if (rename(orig, bakname) < 0) {
		if (errno != EXDEV || copy_file(orig, bakname) < 0)
d121 9
d131 1
d138 1
a138 1
int
d143 1
a143 1
	tofd = open(to, O_CREAT|O_TRUNC|O_WRONLY, 0666);
d145 2
a146 2
		return -1;
	fromfd = open(from, O_RDONLY, 0);
a153 1
	return 0;
d170 1
a170 1
	if (rv == NULL) {
d278 1
d291 1
d300 1
d303 1
d343 1
a343 1
		return NULL;
d351 1
a351 1
		return NULL;	/* against /dev/null. */
d390 1
a390 1
		name = NULL;
a399 15
}

/*
 * Exit with cleanup.
 */
void
my_exit(int status)
{
	unlink(TMPINNAME);
	if (!toutkeep)
		unlink(TMPOUTNAME);
	if (!trejkeep)
		unlink(TMPREJNAME);
	unlink(TMPPATNAME);
	exit(status);
@


1.1.1.6
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.25 2003/08/01 20:30:49 otto Exp $	*/
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.25 2003/08/01 20:30:49 otto Exp $";
a16 1
#include <stdio.h>
d20 1
d22 1
a24 1
#include "pathnames.h"
d30 1
a30 1
move_file(const char *from, const char *to)
d32 1
a32 2
	int	fromfd;
	ssize_t	i;
d72 1
a72 1
backup_file(const char *orig)
d74 3
a76 4
	struct stat	filestat;
	char		bakname[MAXPATHLEN], *s, *simplename;
	dev_t		orig_device;
	ino_t		orig_inode;
d131 1
a131 1
copy_file(const char *from, const char *to)
d133 1
a133 2
	int	tofd, fromfd;
	ssize_t	i;
d153 1
a153 1
savestr(const char *s)
d155 1
a155 1
	char	*rv;
d159 4
a162 1
	rv = strdup(s);
d165 1
a165 1
			out_of_mem = true;
d168 4
d180 1
a180 1
say(const char *fmt, ...)
d194 1
a194 1
fatal(const char *fmt, ...)
d202 1
a202 1
	my_exit(2);
d209 1
a209 1
pfatal(const char *fmt, ...)
d219 1
a219 1
	my_exit(2);
d223 1
a223 1
 * Get a response from the user via /dev/tty
d226 1
a226 1
ask(const char *fmt, ...)
d229 2
a230 2
	ssize_t	nr;
	static	int ttyfd = -1;
d233 1
a233 1
	vfprintf(stdout, fmt, ap);
d235 21
a255 12
	fflush(stdout);
	if (ttyfd < 0)
		ttyfd = open(_PATH_TTY, O_RDONLY);
	if (ttyfd >= 0) {
		if ((nr = read(ttyfd, buf, sizeof(buf))) > 0 &&
		    buf[nr - 1] == '\n')
			buf[nr - 1] = '\0';
	}
	if (ttyfd < 0 || nr <= 0) {
		/* no tty or error reading, pretend user entered 'return' */
		putchar('\n');
		buf[0] = '\0';
d257 6
d297 1
a297 1
 * true, ignore the last element of `filename'.
d301 1
a301 1
makedirs(const char *filename, bool striplast)
d314 2
a315 2
	if (snprintf(buf, sizeof(buf), "%s -p %s", _PATH_MKDIR, tmpbuf)
	    >= sizeof(buf))
d326 1
a326 1
fetchname(const char *at, int strip_leading, int assume_exists)
d328 2
a329 3
	char		*fullname, *name, *t, tmpbuf[200];
	int		sleading;
	struct stat	filestat;
d331 1
a331 1
	if (at == NULL || *at == '\0')
d339 2
a340 3
	/* So files can be created by diffing against /dev/null.  */
	if (strnEQ(at, _PATH_DEVNULL, sizeof(_PATH_DEVNULL) - 1))
		return NULL;
d343 3
a345 3
	/* Strip off up to `strip_leading' path components and NUL terminate. */
	for (sleading = strip_leading; *t != '\0' && !isspace(*t); t++) {
		if (t[0] == '/' && t[1] != '/' && t[1] != '\0')
a347 1
	}
d388 1
a388 1
	my_exit(EXIT_SUCCESS);
@


1.1.1.7
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 27
/*	$OpenBSD: util.c,v 1.26 2003/08/15 08:00:51 otto Exp $	*/

/*
 * patch - a program to apply diffs to original files
 * 
 * Copyright 1986, Larry Wall
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following condition is met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this condition and the following disclaimer.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * -C option added in 1998, original code by Marc Espie, based on FreeBSD
 * behaviour
 */
d4 1
a4 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.26 2003/08/15 08:00:51 otto Exp $";
@


1.1.1.8
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.27 2003/10/31 20:20:45 millert Exp $	*/
d30 1
a30 1
static const char     rcsid[] = "$OpenBSD: util.c,v 1.27 2003/10/31 20:20:45 millert Exp $";
d333 1
a333 1
fetchname(const char *at, bool *exists, int strip_leading)
d335 1
a335 1
	char		*fullname, *name, *t;
d345 1
a345 1
		say("fetchname %s %d\n", at, strip_leading);
d375 3
a377 16
	*exists = stat(name, &filestat) == 0;
	return name;
}

/*
 * Takes the name returned by fetchname and looks in RCS/SCCS directories
 * for a checked in version.
 */
char *
checked_in(char *file)
{
	char		*filebase, *filedir, tmpbuf[MAXPATHLEN];
	struct stat	filestat;

	filebase = basename(file);
	filedir = dirname(file);
d380 1
a380 1
(snprintf(tmpbuf, sizeof tmpbuf, f, a1, a2, a3), stat(tmpbuf, &filestat) == 0)
d382 10
a391 8
	if (try("%s/RCS/%s%s", filedir, filebase, RCSSUFFIX) ||
	    try("%s/RCS/%s%s", filedir, filebase, "") ||
	    try("%s/%s%s", filedir, filebase, RCSSUFFIX) ||
	    try("%s/SCCS/%s%s", filedir, SCCSPREFIX, filebase) ||
	    try("%s/%s%s", filedir, SCCSPREFIX, filebase))
		return file;

	return NULL;
@


1.1.1.9
log
@better patch(1) fixes from obsd
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.28 2004/08/05 21:47:24 deraadt Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.28 2004/08/05 21:47:24 deraadt Exp $";
@


1.1.1.10
log
@w00t! patch(1) writes rejected hunks in unified format! :)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.29 2004/11/19 20:00:57 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.29 2004/11/19 20:00:57 otto Exp $";
d336 1
a336 1
	int		sleading, tab;
a351 1
	tab = strchr(t, '\t') != NULL;
d353 1
a353 2
	for (sleading = strip_leading; *t != '\0' && ((tab && *t != '\t') ||
	    !isspace(*t)); t++) {
@


