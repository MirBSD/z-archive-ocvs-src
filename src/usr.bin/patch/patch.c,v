head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.10
	tg-mergefixes-1-branch:1.1.1.10.0.4
	tg-mergefixes-1-base:1.1.1.10
	MIROS_X:1.1.1.10.0.2
	MIROS_X_BASE:1.1.1.10
	tg-mergetmp-3:1.1.1.10
	cvs-200411210200:1.1.1.10
	MIRBSD_XP_MIRPPC:1.1.1.8.0.4
	cvs-200411031540:1.1.1.9
	MIRBSD_XP_SPARC_BASE:1.1.1.8
	MIRBSD_XP_SPARC:1.1.1.8.0.2
	MIRBSD_7quater:1.1.1.7
	cvs-200405160640:1.1.1.8
	cvs-200401271800:1.1.1.8
	cvs-200401261630:1.1.1.8
	cvs-200401021645:1.1.1.8
	MIRBSD_7_ALPHA:1.1.1.7.0.6
	MIRBSD_7:1.1.1.7.0.4
	cvs-200312222040:1.1.1.8
	MIRBSD_7ter:1.1.1.7
	MIRBSD_7_DEV:1.1.1.7.0.2
	cvs-200310020700:1.1.1.7
	cvs-200309271030:1.1.1.7
	cvs-200309251530:1.1.1.7
	cvs-200308302005:1.1.1.7
	cvs-200308171200:1.1.1.7
	ctm-3496:1.1.1.7
	ctm-3449:1.1.1.6
	ctm-3437:1.1.1.5
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.3
	ctm-3389:1.1.1.3
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.53.11;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.53.11;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.55.17;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.07.06.15.50.58;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.07.18.13.52.56;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.07.22.15.02.40;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.07.26.13.24.19;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.08.11.18.45.27;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.12.22.21.13.53;	author tg;	state Stab;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.03.15.45.18;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.21.02.03.50;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: patch.c,v 1.15 2002/07/04 04:22:48 deraadt Exp $	*/

/* patch - a program to apply diffs to original files
 *
 * Copyright 1986, Larry Wall
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following condition
 * is met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this condition and the following disclaimer.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * -C option added in 1998, original code by Marc Espie,
 * based on FreeBSD behaviour
 */

#ifndef lint
static char rcsid[] = "$OpenBSD: patch.c,v 1.15 2002/07/04 04:22:48 deraadt Exp $";
#endif /* not lint */

#include "INTERN.h"
#include "common.h"
#include "EXTERN.h"
#include "version.h"
#include "util.h"
#include "pch.h"
#include "inp.h"
#include "backupfile.h"

/* procedures */

void reinitialize_almost_everything();
void get_some_switches();
LINENUM locate_hunk();
void abort_hunk();
void apply_hunk();
void init_output();
void init_reject();
void copy_till();
void spew_output();
void dump_line();
bool patch_match();
bool similar();
void re_input();
#ifdef __GNUC__
void my_exit() __attribute__((noreturn));
#else
void my_exit();
#endif

/* TRUE if -E was specified on command line.  */
static int remove_empty_files = FALSE;

/* TRUE if -R was specified on command line.  */
static int reverse_flag_specified = FALSE;

/* TRUE if -C was specified on command line.  */
bool check_only = FALSE;

/* Apply a set of diffs as appropriate. */

int
main(argc,argv)
int argc;
char **argv;
{
    LINENUM where;
    LINENUM newwhere;
    LINENUM fuzz;
    LINENUM mymaxfuzz;
    int hunk = 0;
    int failed = 0;
    int failtotal = 0;
    int patch_seen = 0;
    int i;

    setbuf(stderr, serrbuf);
    for (i = 0; i<MAXFILEC; i++)
	filearg[i] = Nullch;

    myuid = getuid();

    /* Cons up the names of the temporary files.  */
    {
      /* Directory for temporary files.  */
      char *tmpdir;
      int tmpname_len;

      tmpdir = getenv ("TMPDIR");
      if (tmpdir == NULL) {
	tmpdir = "/tmp";
      }
      tmpname_len = strlen (tmpdir) + 20;

      TMPOUTNAME = (char *) malloc (tmpname_len);
      if (TMPOUTNAME == NULL)
	fatal1("cannot allocate memory");
      strcpy (TMPOUTNAME, tmpdir);
      strcat (TMPOUTNAME, "/patchoXXXXXX");
      if ((i = mkstemp(TMPOUTNAME)) < 0)
	pfatal2("can't create %s", TMPOUTNAME);
      Close(i);

      TMPINNAME = (char *) malloc (tmpname_len);
      if (TMPINNAME == NULL)
	fatal1("cannot allocate memory");
      strcpy (TMPINNAME, tmpdir);
      strcat (TMPINNAME, "/patchiXXXXXX");
      if ((i = mkstemp(TMPINNAME)) < 0)
	pfatal2("can't create %s", TMPINNAME);
      Close(i);

      TMPREJNAME = (char *) malloc (tmpname_len);
      if (TMPREJNAME == NULL)
	fatal1("cannot allocate memory");
      strcpy (TMPREJNAME, tmpdir);
      strcat (TMPREJNAME, "/patchrXXXXXX");
      if ((i = mkstemp(TMPREJNAME)) < 0)
	pfatal2("can't create %s", TMPREJNAME);
      Close(i);

      TMPPATNAME = (char *) malloc (tmpname_len);
      if (TMPPATNAME == NULL)
	fatal1("cannot allocate memory");
      strcpy (TMPPATNAME, tmpdir);
      strcat (TMPPATNAME, "/patchpXXXXXX");
      if ((i = mkstemp(TMPPATNAME)) < 0)
	pfatal2("can't create %s", TMPPATNAME);
      Close(i);
    }

    {
      char *v;

      v = getenv ("SIMPLE_BACKUP_SUFFIX");
      if (v)
	simple_backup_suffix = v;
      else
	simple_backup_suffix = ORIGEXT;
#ifndef NODIR
      v = getenv ("VERSION_CONTROL");
      backup_type = get_version (v); /* OK to pass NULL. */
#endif
    }

    /* parse switches */
    Argc = argc;
    Argv = argv;
    get_some_switches();
    
    /* make sure we clean up /tmp in case of disaster */
    set_signals(0);

    for (
	open_patch_file(filearg[1]);
	there_is_another_patch();
	reinitialize_almost_everything()
    ) {					/* for each patch in patch file */
	patch_seen = TRUE;

	if (outname == Nullch)
	    outname = savestr(filearg[0]);
    
	/* for ed script just up and do it and exit */
	if (diff_type == ED_DIFF) {
	    do_ed_script();
	    continue;
	}
    
	/* initialize the patched file */
	if (!skip_rest_of_patch)
	    init_output(TMPOUTNAME);
    
	/* initialize reject file */
	init_reject(TMPREJNAME);
    
	/* find out where all the lines are */
	if (!skip_rest_of_patch)
	    scan_input(filearg[0]);
    
	/* from here on, open no standard i/o files, because malloc */
	/* might misfire and we can't catch it easily */
    
	/* apply each hunk of patch */
	hunk = 0;
	failed = 0;
	out_of_mem = FALSE;
	while (another_hunk()) {
	    hunk++;
	    fuzz = Nulline;
	    mymaxfuzz = pch_context();
	    if (maxfuzz < mymaxfuzz)
		mymaxfuzz = maxfuzz;
	    if (!skip_rest_of_patch) {
		do {
		    where = locate_hunk(fuzz);
		    if (hunk == 1 && where == Nulline && !force) {
						/* dwim for reversed patch? */
			if (!pch_swap()) {
			    if (fuzz == Nulline)
				say1(
"Not enough memory to try swapped hunk!  Assuming unswapped.\n");
			    continue;
			}
			reverse = !reverse;
			where = locate_hunk(fuzz);  /* try again */
			if (where == Nulline) {	    /* didn't find it swapped */
			    if (!pch_swap())         /* put it back to normal */
				fatal1("lost hunk on alloc error!\n");
			    reverse = !reverse;
			}
			else if (noreverse) {
			    if (!pch_swap())         /* put it back to normal */
				fatal1("lost hunk on alloc error!\n");
			    reverse = !reverse;
			    say1(
"Ignoring previously applied (or reversed) patch.\n");
			    skip_rest_of_patch = TRUE;
			}
			else if (batch) {
			    if (verbose)
				say3(
"%seversed (or previously applied) patch detected!  %s -R.",
				reverse ? "R" : "Unr",
				reverse ? "Assuming" : "Ignoring");
			}
			else {
			    ask3(
"%seversed (or previously applied) patch detected!  %s -R? [y] ",
				reverse ? "R" : "Unr",
				reverse ? "Assume" : "Ignore");
			    if (*buf == 'n') {
				ask1("Apply anyway? [n] ");
				if (*buf != 'y')
				    skip_rest_of_patch = TRUE;
				where = Nulline;
				reverse = !reverse;
				if (!pch_swap())  /* put it back to normal */
				    fatal1("lost hunk on alloc error!\n");
			    }
			}
		    }
		} while (!skip_rest_of_patch && where == Nulline &&
		    ++fuzz <= mymaxfuzz);

		if (skip_rest_of_patch) {		/* just got decided */
		    Fclose(ofp);
		    ofp = Nullfp;
		}
	    }

	    newwhere = pch_newfirst() + last_offset;
	    if (skip_rest_of_patch) {
		abort_hunk();
		failed++;
		if (verbose)
		    say3("Hunk #%d ignored at %ld.\n", hunk, newwhere);
	    }
	    else if (where == Nulline) {
		abort_hunk();
		failed++;
		if (verbose)
		    say3("Hunk #%d failed at %ld.\n", hunk, newwhere);
	    }
	    else {
		apply_hunk(where);
		if (verbose) {
		    say3("Hunk #%d succeeded at %ld", hunk, newwhere);
		    if (fuzz)
			say2(" with fuzz %ld", fuzz);
		    if (last_offset)
			say3(" (offset %ld line%s)",
			    last_offset, last_offset==1L?"":"s");
		    say1(".\n");
		}
	    }
	}

	if (out_of_mem && using_plan_a) {
	    Argc = Argc_last;
	    Argv = Argv_last;
	    say1("\n\nRan out of memory using Plan A--trying again...\n\n");
	    if (ofp)
	        Fclose(ofp);
	    ofp = Nullfp;
	    if (rejfp)
	        Fclose(rejfp);
	    rejfp = Nullfp;
	    continue;
	}
    
	assert(hunk);
    
	/* finish spewing out the new file */
	if (!skip_rest_of_patch)
	    spew_output();
	
	/* and put the output where desired */
	ignore_signals();
	if (!skip_rest_of_patch) {
	    struct stat statbuf;
	    char *realout = outname;

	    if (!check_only) {	
		if (move_file(TMPOUTNAME, outname) < 0) {
		    toutkeep = TRUE;
		    realout = TMPOUTNAME;
		    chmod(TMPOUTNAME, filemode);
		}
		else
		    chmod(outname, filemode);

		if (remove_empty_files && stat(realout, &statbuf) == 0
		    && statbuf.st_size == 0) {
		    if (verbose)
			say2("Removing %s (empty after patching).\n", realout);
		    while (unlink(realout) >= 0) ; /* while is for Eunice.  */
		}
	    }
	}
	Fclose(rejfp);
	rejfp = Nullfp;
	if (failed) {
	    failtotal += failed;
	    if (!*rejname) {
		if (strlcpy(rejname, outname, sizeof(rejname)) >= sizeof(rejname))
		    fatal2("filename %s is too long\n", outname);
		    
#ifndef FLEXFILENAMES
		{
		    char *s = strrchr(rejname,'/');

		    if (!s)
			s = rejname;
		    if (strlen(s) > 13)
			if (s[12] == '.')	/* try to preserve difference */
			    s[12] = s[13];	/* between .h, .c, .y, etc. */
			s[13] = '\0';
		}
#endif
		if (strlcat(rejname, REJEXT, sizeof(rejname)) >= sizeof(rejname))
		    fatal2("filename %s is too long\n", outname);
	    }
	    if (skip_rest_of_patch) {
		say4("%d out of %d hunks ignored--saving rejects to %s\n",
		    failed, hunk, rejname);
	    }
	    else {
		say4("%d out of %d hunks failed--saving rejects to %s\n",
		    failed, hunk, rejname);
	    }
	    if (!check_only && move_file(TMPREJNAME, rejname) < 0)
		trejkeep = TRUE;
	}
	set_signals(1);
    }
    if (!patch_seen)
    	failtotal++;
    my_exit(failtotal);
    /* NOTREACHED */
}

/* Prepare to find the next patch to do in the patch file. */

void
reinitialize_almost_everything()
{
    re_patch();
    re_input();

    input_lines = 0;
    last_frozen_line = 0;

    filec = 0;
    if (filearg[0] != Nullch && !out_of_mem) {
	free(filearg[0]);
	filearg[0] = Nullch;
    }

    if (outname != Nullch) {
	free(outname);
	outname = Nullch;
    }

    last_offset = 0;

    diff_type = 0;

    if (revision != Nullch) {
	free(revision);
	revision = Nullch;
    }

    reverse = reverse_flag_specified;
    skip_rest_of_patch = FALSE;

    get_some_switches();

    if (filec >= 2)
	fatal1("you may not change to a different patch file\n");
}

static char *
nextarg()
{
    if (!--Argc)
	fatal2("missing argument after `%s'\n", *Argv);
    return *++Argv;
}

/* Module for handling of long options.  */

struct option {
    char *long_opt;
    char short_opt;
};

int
optcmp(a, b)
    struct option *a, *b;
{
    return strcmp (a->long_opt, b->long_opt);
}

/* Decode Long options beginning with "--" to their short equivalents.  */

char
decode_long_option(opt)
    char *opt;
{
    /* This table must be sorted on the first field.  We also decode
       unimplemented options as those will be handled later anyway.  */
    static struct option options[] = {
      { "batch",		't' },
      { "check",		'C' },
      { "context",		'c' },
      { "debug",		'x' },
      { "directory",		'd' },
      { "ed",			'e' },
      { "force",		'f' },
      { "forward",		'N' },
      { "fuzz",			'F' },
      { "ifdef",		'D' },
      { "ignore-whitespace",	'l' },
      { "normal",		'n' },
      { "output",		'o' },
      { "prefix",		'B' },
      { "quiet",		's' },
      { "reject-file",		'r' },
      { "remove-empty-files",	'E' },
      { "reverse",		'R' },
      { "silent",		's' },
      { "skip",			'S' },
      { "strip",		'p' },
      { "suffix",		'b' },
      { "unified",		'u' },
      { "version",		'v' },
      { "version-control",	'V' },
    };
    struct option key, *found;

    key.long_opt = opt;
    found = (struct option *)bsearch(&key, options,
				     sizeof(options) / sizeof(options[0]),
				     sizeof(options[0]), optcmp);
    return found ? found->short_opt : '\0';
}

/* Process switches and filenames up to next '+' or end of list. */

void
get_some_switches()
{
    Reg1 char *s;

    rejname[0] = '\0';
    Argc_last = Argc;
    Argv_last = Argv;
    if (!Argc)
	return;
    for (Argc--,Argv++; Argc; Argc--,Argv++) {
	s = Argv[0];
	if (strEQ(s, "+")) {
	    return;			/* + will be skipped by for loop */
	}
	if (*s != '-' || !s[1]) {
	    if (filec == MAXFILEC)
		fatal1("too many file arguments\n");
	    filearg[filec++] = savestr(s);
	}
	else {
	    char opt;

	    if (*(s + 1) == '-') {
	        opt = decode_long_option(s + 2);
		s += strlen(s) - 1;
	    }
	    else
	        opt = *++s;
	    switch (opt) {
	    case 'b':
		simple_backup_suffix = savestr(nextarg());
		break;
	    case 'B':
		origprae = savestr(nextarg());
		break;
	    case 'c':
		diff_type = CONTEXT_DIFF;
		break;
	    case 'C':
	    	check_only = TRUE;
		break;
	    case 'd':
		if (!*++s)
		    s = nextarg();
		if (chdir(s) < 0)
		    pfatal2("can't cd to %s", s);
		break;
	    case 'D':
	    	do_defines = TRUE;
		if (!*++s)
		    s = nextarg();
		if (!isalpha(*s) && '_' != *s)
		    fatal1("argument to -D is not an identifier\n");
		Snprintf(if_defined, sizeof if_defined, "#ifdef %s\n", s);
		Snprintf(not_defined, sizeof not_defined, "#ifndef %s\n", s);
		Snprintf(end_defined, sizeof end_defined, "#endif /* %s */\n", s);
		break;
	    case 'e':
		diff_type = ED_DIFF;
		break;
	    case 'E':
		remove_empty_files = TRUE;
		break;
	    case 'f':
		force = TRUE;
		break;
	    case 'F':
		if (!*++s)
		    s = nextarg();
		else if (*s == '=')
		    s++;
		maxfuzz = atoi(s);
		break;
	    case 'l':
		canonicalize = TRUE;
		break;
	    case 'n':
		diff_type = NORMAL_DIFF;
		break;
	    case 'N':
		noreverse = TRUE;
		break;
	    case 'o':
		outname = savestr(nextarg());
		break;
	    case 'p':
		if (!*++s)
		    s = nextarg();
		else if (*s == '=')
		    s++;
		strippath = atoi(s);
		break;
	    case 'r':
		if (strlcpy(rejname, nextarg(), sizeof(rejname)) >= sizeof(rejname))
		    fatal1("argument for -r is too long\n");
		break;
	    case 'R':
		reverse = TRUE;
		reverse_flag_specified = TRUE;
		break;
	    case 's':
		verbose = FALSE;
		break;
	    case 'S':
		skip_rest_of_patch = TRUE;
		break;
	    case 't':
		batch = TRUE;
		break;
	    case 'u':
		diff_type = UNI_DIFF;
		break;
	    case 'v':
		version();
		break;
	    case 'V':
#ifndef NODIR
		backup_type = get_version (nextarg ());
#endif
		break;
#ifdef DEBUGGING
	    case 'x':
		if (!*++s)
		    s = nextarg();
		debug = atoi(s);
		break;
#endif
	    default:
		fprintf(stderr, "patch: unrecognized option `%s'\n", Argv[0]);
		fprintf(stderr, "\
Usage: patch [options] [origfile [patchfile]] [+ [options] [origfile]]...\n\
Options:\n\
       [-cCeEflnNRsStuv] [-b backup-ext] [-B backup-prefix] [-d directory]\n\
       [-D symbol] [-Fmax-fuzz] [-o out-file] [-p[strip-count]]\n\
       [-r rej-name] [-V {numbered,existing,simple}]\n");
		my_exit(1);
	    }
	}
    }
}

/* Attempt to find the right place to apply this hunk of patch. */

LINENUM
locate_hunk(fuzz)
LINENUM fuzz;
{
    Reg1 LINENUM first_guess = pch_first() + last_offset;
    Reg2 LINENUM offset;
    LINENUM pat_lines = pch_ptrn_lines();
    Reg3 LINENUM max_pos_offset = input_lines - first_guess
				- pat_lines + 1; 
    Reg4 LINENUM max_neg_offset = first_guess - last_frozen_line - 1
				+ pch_context();

    if (!pat_lines)			/* null range matches always */
	return first_guess;
    if (max_neg_offset >= first_guess)	/* do not try lines < 0 */
	max_neg_offset = first_guess - 1;
    if (first_guess <= input_lines && patch_match(first_guess, Nulline, fuzz))
	return first_guess;
    for (offset = 1; ; offset++) {
	Reg5 bool check_after = (offset <= max_pos_offset);
	Reg6 bool check_before = (offset <= max_neg_offset);

	if (check_after && patch_match(first_guess, offset, fuzz)) {
#ifdef DEBUGGING
	    if (debug & 1)
		say3("Offset changing from %ld to %ld\n", last_offset, offset);
#endif
	    last_offset = offset;
	    return first_guess+offset;
	}
	else if (check_before && patch_match(first_guess, -offset, fuzz)) {
#ifdef DEBUGGING
	    if (debug & 1)
		say3("Offset changing from %ld to %ld\n", last_offset, -offset);
#endif
	    last_offset = -offset;
	    return first_guess-offset;
	}
	else if (!check_before && !check_after)
	    return Nulline;
    }
}

/* We did not find the pattern, dump out the hunk so they can handle it. */

void
abort_hunk()
{
    Reg1 LINENUM i;
    Reg2 LINENUM pat_end = pch_end();
    /* add in last_offset to guess the same as the previous successful hunk */
    LINENUM oldfirst = pch_first() + last_offset;
    LINENUM newfirst = pch_newfirst() + last_offset;
    LINENUM oldlast = oldfirst + pch_ptrn_lines() - 1;
    LINENUM newlast = newfirst + pch_repl_lines() - 1;
    char *stars = (diff_type >= NEW_CONTEXT_DIFF ? " ****" : "");
    char *minuses = (diff_type >= NEW_CONTEXT_DIFF ? " ----" : " -----");

    fprintf(rejfp, "***************\n");
    for (i=0; i<=pat_end; i++) {
	switch (pch_char(i)) {
	case '*':
	    if (oldlast < oldfirst)
		fprintf(rejfp, "*** 0%s\n", stars);
	    else if (oldlast == oldfirst)
		fprintf(rejfp, "*** %ld%s\n", oldfirst, stars);
	    else
		fprintf(rejfp, "*** %ld,%ld%s\n", oldfirst, oldlast, stars);
	    break;
	case '=':
	    if (newlast < newfirst)
		fprintf(rejfp, "--- 0%s\n", minuses);
	    else if (newlast == newfirst)
		fprintf(rejfp, "--- %ld%s\n", newfirst, minuses);
	    else
		fprintf(rejfp, "--- %ld,%ld%s\n", newfirst, newlast, minuses);
	    break;
	case '\n':
	    fprintf(rejfp, "%s", pfetch(i));
	    break;
	case ' ': case '-': case '+': case '!':
	    fprintf(rejfp, "%c %s", pch_char(i), pfetch(i));
	    break;
	default:
	    fatal1("fatal internal error in abort_hunk\n"); 
	}
    }
}

/* We found where to apply it (we hope), so do it. */

void
apply_hunk(where)
LINENUM where;
{
    Reg1 LINENUM old = 1;
    Reg2 LINENUM lastline = pch_ptrn_lines();
    Reg3 LINENUM new = lastline+1;
#define OUTSIDE 0
#define IN_IFNDEF 1
#define IN_IFDEF 2
#define IN_ELSE 3
    Reg4 int def_state = OUTSIDE;
    Reg5 bool R_do_defines = do_defines;
    Reg6 LINENUM pat_end = pch_end();

    where--;
    while (pch_char(new) == '=' || pch_char(new) == '\n')
	new++;
    
    while (old <= lastline) {
	if (pch_char(old) == '-') {
	    copy_till(where + old - 1);
	    if (R_do_defines) {
		if (def_state == OUTSIDE) {
		    fputs(not_defined, ofp);
		    def_state = IN_IFNDEF;
		}
		else if (def_state == IN_IFDEF) {
		    fputs(else_defined, ofp);
		    def_state = IN_ELSE;
		}
		fputs(pfetch(old), ofp);
	    }
	    last_frozen_line++;
	    old++;
	}
	else if (new > pat_end) {
	    break;
	}
	else if (pch_char(new) == '+') {
	    copy_till(where + old - 1);
	    if (R_do_defines) {
		if (def_state == IN_IFNDEF) {
		    fputs(else_defined, ofp);
		    def_state = IN_ELSE;
		}
		else if (def_state == OUTSIDE) {
		    fputs(if_defined, ofp);
		    def_state = IN_IFDEF;
		}
	    }
	    fputs(pfetch(new), ofp);
	    new++;
	}
	else if (pch_char(new) != pch_char(old)) {
	    say3("Out-of-sync patch, lines %ld,%ld--mangled text or line numbers, maybe?\n",
		pch_hunk_beg() + old,
		pch_hunk_beg() + new);
#ifdef DEBUGGING
	    say3("oldchar = '%c', newchar = '%c'\n",
		pch_char(old), pch_char(new));
#endif
	    my_exit(1);
	}
	else if (pch_char(new) == '!') {
	    copy_till(where + old - 1);
	    if (R_do_defines) {
	       fputs(not_defined, ofp);
	       def_state = IN_IFNDEF;
	    }
	    while (pch_char(old) == '!') {
		if (R_do_defines) {
		    fputs(pfetch(old), ofp);
		}
		last_frozen_line++;
		old++;
	    }
	    if (R_do_defines) {
		fputs(else_defined, ofp);
		def_state = IN_ELSE;
	    }
	    while (pch_char(new) == '!') {
		fputs(pfetch(new), ofp);
		new++;
	    }
	}
	else {
	    assert(pch_char(new) == ' ');
	    old++;
	    new++;
	    if (R_do_defines && def_state != OUTSIDE) {
		fputs(end_defined, ofp);
		def_state = OUTSIDE;
	    }
	}
    }
    if (new <= pat_end && pch_char(new) == '+') {
	copy_till(where + old - 1);
	if (R_do_defines) {
	    if (def_state == OUTSIDE) {
	    	fputs(if_defined, ofp);
		def_state = IN_IFDEF;
	    }
	    else if (def_state == IN_IFNDEF) {
		fputs(else_defined, ofp);
		def_state = IN_ELSE;
	    }
	}
	while (new <= pat_end && pch_char(new) == '+') {
	    fputs(pfetch(new), ofp);
	    new++;
	}
    }
    if (R_do_defines && def_state != OUTSIDE) {
	fputs(end_defined, ofp);
    }
}

/* Open the new file. */

void
init_output(name)
char *name;
{
    ofp = fopen(name, "w");
    if (ofp == Nullfp)
	pfatal2("can't create %s", name);
}

/* Open a file to put hunks we can't locate. */

void
init_reject(name)
char *name;
{
    rejfp = fopen(name, "w");
    if (rejfp == Nullfp)
	pfatal2("can't create %s", name);
}

/* Copy input file to output, up to wherever hunk is to be applied. */

void
copy_till(lastline)
Reg1 LINENUM lastline;
{
    Reg2 LINENUM R_last_frozen_line = last_frozen_line;

    if (R_last_frozen_line > lastline)
	fatal1("misordered hunks! output would be garbled\n");
    while (R_last_frozen_line < lastline) {
	dump_line(++R_last_frozen_line);
    }
    last_frozen_line = R_last_frozen_line;
}

/* Finish copying the input file to the output file. */

void
spew_output()
{
#ifdef DEBUGGING
    if (debug & 256)
	say3("il=%ld lfl=%ld\n",input_lines,last_frozen_line);
#endif
    if (input_lines)
	copy_till(input_lines);		/* dump remainder of file */
    Fclose(ofp);
    ofp = Nullfp;
}

/* Copy one line from input to output. */

void
dump_line(line)
LINENUM line;
{
    Reg1 char *s;
    Reg2 char R_newline = '\n';

    /* Note: string is not null terminated. */
    for (s=ifetch(line, 0); putc(*s, ofp) != R_newline; s++) ;
}

/* Does the patch pattern match at line base+offset? */

bool
patch_match(base, offset, fuzz)
LINENUM base;
LINENUM offset;
LINENUM fuzz;
{
    Reg1 LINENUM pline = 1 + fuzz;
    Reg2 LINENUM iline;
    Reg3 LINENUM pat_lines = pch_ptrn_lines() - fuzz;

    for (iline=base+offset+fuzz; pline <= pat_lines; pline++,iline++) {
	if (canonicalize) {
	    if (!similar(ifetch(iline, (offset >= 0)),
			 pfetch(pline),
			 pch_line_len(pline) ))
		return FALSE;
	}
	else if (strnNE(ifetch(iline, (offset >= 0)),
		   pfetch(pline),
		   pch_line_len(pline) ))
	    return FALSE;
    }
    return TRUE;
}

/* Do two lines match with canonicalized white space? */

bool
similar(a,b,len)
Reg1 char *a;
Reg2 char *b;
Reg3 int len;
{
    while (len) {
	if (isspace(*b)) {		/* whitespace (or \n) to match? */
	    if (!isspace(*a))		/* no corresponding whitespace? */
		return FALSE;
	    while (len && isspace(*b) && *b != '\n')
		b++,len--;		/* skip pattern whitespace */
	    while (isspace(*a) && *a != '\n')
		a++;			/* skip target whitespace */
	    if (*a == '\n' || *b == '\n')
		return (*a == *b);	/* should end in sync */
	}
	else if (*a++ != *b++)		/* match non-whitespace chars */
	    return FALSE;
	else
	    len--;			/* probably not necessary */
    }
    return TRUE;			/* actually, this is not reached */
					/* since there is always a \n */
}

/* Exit with cleanup. */

void
my_exit(status)
int status;
{
    Unlink(TMPINNAME);
    if (!toutkeep) {
	Unlink(TMPOUTNAME);
    }
    if (!trejkeep) {
	Unlink(TMPREJNAME);
    }
    Unlink(TMPPATNAME);
    exit(status);
}
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.16 2003/04/05 17:17:53 deraadt Exp $	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.16 2003/04/05 17:17:53 deraadt Exp $";
d99 1
d105 1
d107 2
a108 1
      if (asprintf(&TMPOUTNAME, "%s/patchoXXXXXX", tmpdir) == -1)
d110 2
d116 2
a117 1
      if (asprintf(&TMPINNAME, "%s/patchiXXXXXX", tmpdir) == -1)
d119 2
d125 2
a126 1
      if (asprintf(&TMPREJNAME, "%s/patchrXXXXXX", tmpdir) == -1)
d128 2
d134 2
a135 1
      if (asprintf(&TMPPATNAME, "%s/patchpXXXXXX", tmpdir) == -1)
d137 2
@


1.1.1.3
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.17 2003/07/02 00:21:16 avsm Exp $	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.17 2003/07/02 00:21:16 avsm Exp $";
d105 1
a105 1
      if (asprintf(&TMPOUTNAME, "%s/patchoXXXXXXXXXX", tmpdir) == -1)
d111 1
a111 1
      if (asprintf(&TMPINNAME, "%s/patchiXXXXXXXXXX", tmpdir) == -1)
d117 1
a117 1
      if (asprintf(&TMPREJNAME, "%s/patchrXXXXXXXXXX", tmpdir) == -1)
d123 1
a123 1
      if (asprintf(&TMPPATNAME, "%s/patchpXXXXXXXXXX", tmpdir) == -1)
@


1.1.1.4
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.19 2003/07/18 02:00:09 deraadt Exp $	*/
d12 1
a12 1
 *
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.19 2003/07/18 02:00:09 deraadt Exp $";
d36 1
d44 18
a61 16
void reinitialize_almost_everything(void);
void get_some_switches(void);
LINENUM locate_hunk(LINENUM);
void abort_hunk(void);
void apply_hunk(LINENUM);
void init_output(char *);
void init_reject(char *);
void copy_till(LINENUM);
void spew_output(void);
void dump_line(LINENUM);
bool patch_match(LINENUM, LINENUM, LINENUM);
bool similar(char *, char *, int);
void re_input(void);
void my_exit(int) __attribute__((noreturn));
int optcmp(const void *, const void *);
char decode_long_option(char *);
d75 3
a77 1
main(int argc, char *argv[])
d106 1
a106 1
	fatal("cannot allocate memory");
d108 2
a109 2
	pfatal("can't create %s", TMPOUTNAME);
      close(i);
d112 1
a112 1
	fatal("cannot allocate memory");
d114 2
a115 2
	pfatal("can't create %s", TMPINNAME);
      close(i);
d118 1
a118 1
	fatal("cannot allocate memory");
d120 2
a121 2
	pfatal("can't create %s", TMPREJNAME);
      close(i);
d124 1
a124 1
	fatal("cannot allocate memory");
d126 2
a127 2
	pfatal("can't create %s", TMPPATNAME);
      close(i);
d148 1
a148 1

d161 1
a161 1

d167 1
a167 1

d171 1
a171 1

d174 1
a174 1

d178 1
a178 1

d181 1
a181 1

d199 1
a199 1
				say(
d207 1
a207 1
				fatal("lost hunk on alloc error!\n");
d212 1
a212 1
				fatal("lost hunk on alloc error!\n");
d214 1
a214 1
			    say(
d220 1
a220 1
				say(
d226 1
a226 1
			    ask(
d231 1
a231 1
				ask("Apply anyway? [n] ");
d237 1
a237 1
				    fatal("lost hunk on alloc error!\n");
d245 1
a245 1
		    fclose(ofp);
d255 1
a255 1
		    say("Hunk #%d ignored at %ld.\n", hunk, newwhere);
d261 1
a261 1
		    say("Hunk #%d failed at %ld.\n", hunk, newwhere);
d266 1
a266 1
		    say("Hunk #%d succeeded at %ld", hunk, newwhere);
d268 1
a268 1
			say(" with fuzz %ld", fuzz);
d270 1
a270 1
			say(" (offset %ld line%s)",
d272 1
a272 1
		    say(".\n");
d280 1
a280 1
	    say("\n\nRan out of memory using Plan A--trying again...\n\n");
d282 1
a282 1
	        fclose(ofp);
d285 1
a285 1
	        fclose(rejfp);
d289 1
a289 1

d291 1
a291 1

d295 1
a295 1

d302 1
a302 1
	    if (!check_only) {
d314 1
a314 1
			say("Removing %s (empty after patching).\n", realout);
d319 1
a319 1
	fclose(rejfp);
d325 14
a338 1
		    fatal("filename %s is too long\n", outname);
d340 1
a340 1
		    fatal("filename %s is too long\n", outname);
d343 1
a343 1
		say("%d out of %d hunks ignored--saving rejects to %s\n",
d347 1
a347 1
		say("%d out of %d hunks failed--saving rejects to %s\n",
d356 1
a356 1
	failtotal++;
d398 1
a398 1
	fatal("you may not change to a different patch file\n");
d402 1
a402 1
nextarg(void)
d405 1
a405 1
	fatal("missing argument after `%s'\n", *Argv);
d417 2
a418 1
optcmp(const void *v1, const void *v2)
a419 2
    const struct option *a = v1, *b = v2;

d426 2
a427 1
decode_long_option(char *opt)
d472 1
a472 1
    char *s;
d486 1
a486 1
		fatal("too many file arguments\n");
d509 1
a509 1
		check_only = TRUE;
d515 1
a515 1
		    pfatal("can't cd to %s", s);
d518 1
a518 1
		do_defines = TRUE;
d522 4
a525 4
		    fatal("argument to -D is not an identifier\n");
		snprintf(if_defined, sizeof if_defined, "#ifdef %s\n", s);
		snprintf(not_defined, sizeof not_defined, "#ifndef %s\n", s);
		snprintf(end_defined, sizeof end_defined, "#endif /* %s */\n", s);
d564 1
a564 1
		    fatal("argument for -r is too long\n");
d617 2
a618 2
    LINENUM first_guess = pch_first() + last_offset;
    LINENUM offset;
d620 3
a622 3
    LINENUM max_pos_offset = input_lines - first_guess
				- pat_lines + 1;
    LINENUM max_neg_offset = first_guess - last_frozen_line - 1
d632 2
a633 2
	bool check_after = (offset <= max_pos_offset);
	bool check_before = (offset <= max_neg_offset);
d638 1
a638 1
		say("Offset changing from %ld to %ld\n", last_offset, offset);
d646 1
a646 1
		say("Offset changing from %ld to %ld\n", last_offset, -offset);
d661 2
a662 2
    LINENUM i;
    LINENUM pat_end = pch_end();
d697 1
a697 1
	    fatal("fatal internal error in abort_hunk\n");
d708 3
a710 3
    LINENUM old = 1;
    LINENUM lastline = pch_ptrn_lines();
    LINENUM new = lastline+1;
d715 3
a717 3
    int def_state = OUTSIDE;
    bool R_do_defines = do_defines;
    LINENUM pat_end = pch_end();
d722 1
a722 1

d759 1
a759 1
	    say("Out-of-sync patch, lines %ld,%ld--mangled text or line numbers, maybe?\n",
d763 1
a763 1
	    say("oldchar = '%c', newchar = '%c'\n",
d804 1
a804 1
		fputs(if_defined, ofp);
d830 1
a830 1
	pfatal("can't create %s", name);
d841 1
a841 1
	pfatal("can't create %s", name);
d848 1
a848 1
LINENUM lastline;
d850 1
a850 1
    LINENUM R_last_frozen_line = last_frozen_line;
d853 1
a853 1
	fatal("misordered hunks! output would be garbled\n");
d867 1
a867 1
	say("il=%ld lfl=%ld\n",input_lines,last_frozen_line);
d871 1
a871 1
    fclose(ofp);
d881 2
a882 2
    char *s;
    char R_newline = '\n';
a883 3
    s = ifetch(line, 0);
    if (s == NULL)
	return;
d885 1
a885 1
    for (; putc(*s, ofp) != R_newline; s++) ;
d896 3
a898 3
    LINENUM pline = 1 + fuzz;
    LINENUM iline;
    LINENUM pat_lines = pch_ptrn_lines() - fuzz;
d919 3
a921 3
char *a;
char *b;
int len;
a922 2
    if (a == NULL || b == NULL)
	return FALSE;
d949 1
a949 1
    unlink(TMPINNAME);
d951 1
a951 1
	unlink(TMPOUTNAME);
d954 1
a954 1
	unlink(TMPREJNAME);
d956 1
a956 1
    unlink(TMPPATNAME);
@


1.1.1.5
log
@Sync to OpenBSD 3.3-current
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.22 2003/07/21 21:01:45 otto Exp $	*/
d3 2
a4 3
/*
 * patch - a program to apply diffs to original files
 * 
d6 1
a6 1
 * 
d8 13
a20 12
 * modification, are permitted provided that the following condition is met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this condition and the following disclaimer.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
d24 3
a26 3
 * 
 * -C option added in 1998, original code by Marc Espie, based on FreeBSD
 * behaviour
d30 1
a30 1
static char rcsid[] = "$OpenBSD: patch.c,v 1.22 2003/07/21 21:01:45 otto Exp $";
d41 18
a58 16
void	reinitialize_almost_everything(void);
void	get_some_switches(void);
LINENUM	locate_hunk(LINENUM);
void	abort_hunk(void);
void	apply_hunk(LINENUM);
void	init_output(char *);
void	init_reject(char *);
void	copy_till(LINENUM);
void	spew_output(void);
void	dump_line(LINENUM);
bool	patch_match(LINENUM, LINENUM, LINENUM);
bool	similar(char *, char *, int);
void	re_input(void);
void	my_exit(int) __attribute__((noreturn));
int	optcmp(const void *, const void *);
char	decode_long_option(char *);
d61 1
a61 1
static int	remove_empty_files = FALSE;
d64 1
a64 1
static int	reverse_flag_specified = FALSE;
d67 1
a67 1
bool	check_only = FALSE;
d74 64
a137 64
	int	hunk = 0, failed = 0, failtotal = 0, patch_seen = 0, i;
	LINENUM	where, newwhere, fuzz, mymaxfuzz;
	char	*tmpdir, *v;

	setbuf(stderr, serrbuf);
	for (i = 0; i < MAXFILEC; i++)
		filearg[i] = Nullch;

	myuid = getuid();

	/* Cons up the names of the temporary files.  */
	tmpdir = getenv("TMPDIR");
	if (tmpdir == NULL) {
		tmpdir = "/tmp";
	}
	if (asprintf(&TMPOUTNAME, "%s/patchoXXXXXXXXXX", tmpdir) == -1)
		fatal("cannot allocate memory");
	if ((i = mkstemp(TMPOUTNAME)) < 0)
		pfatal("can't create %s", TMPOUTNAME);
	close(i);

	if (asprintf(&TMPINNAME, "%s/patchiXXXXXXXXXX", tmpdir) == -1)
		fatal("cannot allocate memory");
	if ((i = mkstemp(TMPINNAME)) < 0)
		pfatal("can't create %s", TMPINNAME);
	close(i);

	if (asprintf(&TMPREJNAME, "%s/patchrXXXXXXXXXX", tmpdir) == -1)
		fatal("cannot allocate memory");
	if ((i = mkstemp(TMPREJNAME)) < 0)
		pfatal("can't create %s", TMPREJNAME);
	close(i);

	if (asprintf(&TMPPATNAME, "%s/patchpXXXXXXXXXX", tmpdir) == -1)
		fatal("cannot allocate memory");
	if ((i = mkstemp(TMPPATNAME)) < 0)
		pfatal("can't create %s", TMPPATNAME);
	close(i);

	v = getenv("SIMPLE_BACKUP_SUFFIX");
	if (v)
		simple_backup_suffix = v;
	else
		simple_backup_suffix = ORIGEXT;

	v = getenv("VERSION_CONTROL");
	backup_type = get_version(v);	/* OK to pass NULL. */

	/* parse switches */
	Argc = argc;
	Argv = argv;
	get_some_switches();

	/* make sure we clean up /tmp in case of disaster */
	set_signals(0);

	for (open_patch_file(filearg[1]); there_is_another_patch();
	    reinitialize_almost_everything()) {
		/* for each patch in patch file */

		patch_seen = TRUE;

		if (outname == Nullch)
			outname = savestr(filearg[0]);
d139 52
a190 33
		/* for ed script just up and do it and exit */
		if (diff_type == ED_DIFF) {
			do_ed_script();
			continue;
		}
		/* initialize the patched file */
		if (!skip_rest_of_patch)
			init_output(TMPOUTNAME);

		/* initialize reject file */
		init_reject(TMPREJNAME);

		/* find out where all the lines are */
		if (!skip_rest_of_patch)
			scan_input(filearg[0]);

		/* from here on, open no standard i/o files, because malloc */
		/* might misfire and we can't catch it easily */

		/* apply each hunk of patch */
		hunk = 0;
		failed = 0;
		out_of_mem = FALSE;
		while (another_hunk()) {
			hunk++;
			fuzz = Nulline;
			mymaxfuzz = pch_context();
			if (maxfuzz < mymaxfuzz)
				mymaxfuzz = maxfuzz;
			if (!skip_rest_of_patch) {
				do {
					where = locate_hunk(fuzz);
					if (hunk == 1 && where == Nulline && !force) {
d192 110
a301 77
						if (!pch_swap()) {
							if (fuzz == Nulline)
								say("Not enough memory to try swapped hunk!  Assuming unswapped.\n");
							continue;
						}
						reverse = !reverse;
						/* try again */
						where = locate_hunk(fuzz);
						if (where == Nulline) {
							/* didn't find it swapped */
							if (!pch_swap())
								/* put it back to normal */
								fatal("lost hunk on alloc error!\n");
							reverse = !reverse;
						} else if (noreverse) {
							if (!pch_swap())
								/* put it back to normal */
								fatal("lost hunk on alloc error!\n");
							reverse = !reverse;
							say("Ignoring previously applied (or reversed) patch.\n");
							skip_rest_of_patch = TRUE;
						} else if (batch) {
							if (verbose)
								say("%seversed (or previously applied) patch detected!  %s -R.",
								    reverse ? "R" : "Unr",
								    reverse ? "Assuming" : "Ignoring");
						} else {
							ask("%seversed (or previously applied) patch detected!  %s -R? [y] ",
							    reverse ? "R" : "Unr",
							    reverse ? "Assume" : "Ignore");
							if (*buf == 'n') {
								ask("Apply anyway? [n] ");
								if (*buf != 'y')
									skip_rest_of_patch = TRUE;
								where = Nulline;
								reverse = !reverse;
								if (!pch_swap())
									/* put it back to normal */
									fatal("lost hunk on alloc error!\n");
							}
						}
					}
				} while (!skip_rest_of_patch && where == Nulline &&
					 ++fuzz <= mymaxfuzz);

				if (skip_rest_of_patch) {	/* just got decided */
					fclose(ofp);
					ofp = Nullfp;
				}
			}
			newwhere = pch_newfirst() + last_offset;
			if (skip_rest_of_patch) {
				abort_hunk();
				failed++;
				if (verbose)
					say("Hunk #%d ignored at %ld.\n",
					    hunk, newwhere);
			} else if (where == Nulline) {
				abort_hunk();
				failed++;
				if (verbose)
					say("Hunk #%d failed at %ld.\n",
					    hunk, newwhere);
			} else {
				apply_hunk(where);
				if (verbose) {
					say("Hunk #%d succeeded at %ld",
					    hunk, newwhere);
					if (fuzz)
						say(" with fuzz %ld", fuzz);
					if (last_offset)
						say(" (offset %ld line%s)",
						    last_offset,
						    last_offset == 1L ? "" : "s");
					say(".\n");
				}
			}
d303 2
d306 35
a340 70
		if (out_of_mem && using_plan_a) {
			Argc = Argc_last;
			Argv = Argv_last;
			say("\n\nRan out of memory using Plan A--trying again...\n\n");
			if (ofp)
				fclose(ofp);
			ofp = Nullfp;
			if (rejfp)
				fclose(rejfp);
			rejfp = Nullfp;
			continue;
		}
		assert(hunk);

		/* finish spewing out the new file */
		if (!skip_rest_of_patch)
			spew_output();

		/* and put the output where desired */
		ignore_signals();
		if (!skip_rest_of_patch) {
			struct stat	statbuf;
			char	*realout = outname;

			if (!check_only) {
				if (move_file(TMPOUTNAME, outname) < 0) {
					toutkeep = TRUE;
					realout = TMPOUTNAME;
					chmod(TMPOUTNAME, filemode);
				} else
					chmod(outname, filemode);

				if (remove_empty_files &&
				    stat(realout, &statbuf) == 0 &&
				    statbuf.st_size == 0) {
					if (verbose)
						say("Removing %s (empty after patching).\n",
						    realout);
					unlink(realout);
				}
			}
		}
		fclose(rejfp);
		rejfp = Nullfp;
		if (failed) {
			failtotal += failed;
			if (!*rejname) {
				if (strlcpy(rejname, outname,
				    sizeof(rejname)) >= sizeof(rejname))
					fatal("filename %s is too long\n", outname);
				if (strlcat(rejname, REJEXT,
				    sizeof(rejname)) >= sizeof(rejname))
					fatal("filename %s is too long\n", outname);
			}
			if (skip_rest_of_patch) {
				say("%d out of %d hunks ignored--saving rejects to %s\n",
				    failed, hunk, rejname);
			} else {
				say("%d out of %d hunks failed--saving rejects to %s\n",
				    failed, hunk, rejname);
			}
			if (!check_only && move_file(TMPREJNAME, rejname) < 0)
				trejkeep = TRUE;
		}
		set_signals(1);
	}
	if (!patch_seen)
		failtotal++;
	my_exit(failtotal);
	/* NOTREACHED */
d346 1
a346 1
reinitialize_almost_everything(void)
d348 11
a358 2
	re_patch();
	re_input();
d360 4
a363 2
	input_lines = 0;
	last_frozen_line = 0;
d365 3
a367 10
	filec = 0;
	if (filearg[0] != Nullch && !out_of_mem) {
		free(filearg[0]);
		filearg[0] = Nullch;
	}
	if (outname != Nullch) {
		free(outname);
		outname = Nullch;
	}
	last_offset = 0;
d369 4
a372 1
	diff_type = 0;
d374 2
a375 6
	if (revision != Nullch) {
		free(revision);
		revision = Nullch;
	}
	reverse = reverse_flag_specified;
	skip_rest_of_patch = FALSE;
d377 1
a377 1
	get_some_switches();
d379 2
a380 2
	if (filec >= 2)
		fatal("you may not change to a different patch file\n");
d386 3
a388 3
	if (!--Argc)
		fatal("missing argument after `%s'\n", *Argv);
	return *++Argv;
d394 2
a395 2
	char	*long_opt;
	char	short_opt;
d401 1
a401 1
	const struct option *a = v1, *b = v2;
d403 1
a403 1
	return strcmp(a->long_opt, b->long_opt);
d411 36
a446 38
	/*
	 * This table must be sorted on the first field.  We also decode
	 * unimplemented options as those will be handled later anyway.
	 */
	static struct option options[] = {
		{"batch", 't'},
		{"check", 'C'},
		{"context", 'c'},
		{"debug", 'x'},
		{"directory", 'd'},
		{"ed", 'e'},
		{"force", 'f'},
		{"forward", 'N'},
		{"fuzz", 'F'},
		{"ifdef", 'D'},
		{"ignore-whitespace", 'l'},
		{"normal", 'n'},
		{"output", 'o'},
		{"prefix", 'B'},
		{"quiet", 's'},
		{"reject-file", 'r'},
		{"remove-empty-files", 'E'},
		{"reverse", 'R'},
		{"silent", 's'},
		{"skip", 'S'},
		{"strip", 'p'},
		{"suffix", 'b'},
		{"unified", 'u'},
		{"version", 'v'},
		{"version-control", 'V'},
	};
	struct option   key, *found;

	key.long_opt = opt;
	found = (struct option *) bsearch(&key, options,
	    sizeof(options) / sizeof(options[0]),
	    sizeof(options[0]), optcmp);
	return found ? found->short_opt : '\0';
d452 1
a452 1
get_some_switches(void)
d454 1
a454 1
	char	*s;
d456 116
a571 116
	rejname[0] = '\0';
	Argc_last = Argc;
	Argv_last = Argv;
	if (!Argc)
		return;
	for (Argc--, Argv++; Argc; Argc--, Argv++) {
		s = Argv[0];
		if (strEQ(s, "+")) {
			return;	/* + will be skipped by for loop */
		}
		if (*s != '-' || !s[1]) {
			if (filec == MAXFILEC)
				fatal("too many file arguments\n");
			filearg[filec++] = savestr(s);
		} else {
			char	opt;

			if (*(s + 1) == '-') {
				opt = decode_long_option(s + 2);
				s += strlen(s) - 1;
			} else
				opt = *++s;
			switch (opt) {
			case 'b':
				simple_backup_suffix = savestr(nextarg());
				break;
			case 'B':
				origprae = savestr(nextarg());
				break;
			case 'c':
				diff_type = CONTEXT_DIFF;
				break;
			case 'C':
				check_only = TRUE;
				break;
			case 'd':
				if (!*++s)
					s = nextarg();
				if (chdir(s) < 0)
					pfatal("can't cd to %s", s);
				break;
			case 'D':
				do_defines = TRUE;
				if (!*++s)
					s = nextarg();
				if (!isalpha(*s) && '_' != *s)
					fatal("argument to -D is not an identifier\n");
				snprintf(if_defined, sizeof if_defined,
				    "#ifdef %s\n", s);
				snprintf(not_defined, sizeof not_defined,
				    "#ifndef %s\n", s);
				snprintf(end_defined, sizeof end_defined,
				    "#endif /* %s */\n", s);
				break;
			case 'e':
				diff_type = ED_DIFF;
				break;
			case 'E':
				remove_empty_files = TRUE;
				break;
			case 'f':
				force = TRUE;
				break;
			case 'F':
				if (!*++s)
					s = nextarg();
				else if (*s == '=')
					s++;
				maxfuzz = atoi(s);
				break;
			case 'l':
				canonicalize = TRUE;
				break;
			case 'n':
				diff_type = NORMAL_DIFF;
				break;
			case 'N':
				noreverse = TRUE;
				break;
			case 'o':
				outname = savestr(nextarg());
				break;
			case 'p':
				if (!*++s)
					s = nextarg();
				else if (*s == '=')
					s++;
				strippath = atoi(s);
				break;
			case 'r':
				if (strlcpy(rejname, nextarg(),
				    sizeof(rejname)) >= sizeof(rejname))
					fatal("argument for -r is too long\n");
				break;
			case 'R':
				reverse = TRUE;
				reverse_flag_specified = TRUE;
				break;
			case 's':
				verbose = FALSE;
				break;
			case 'S':
				skip_rest_of_patch = TRUE;
				break;
			case 't':
				batch = TRUE;
				break;
			case 'u':
				diff_type = UNI_DIFF;
				break;
			case 'v':
				version();
				break;
			case 'V':
				backup_type = get_version(nextarg());
				break;
d573 5
a577 5
			case 'x':
				if (!*++s)
					s = nextarg();
				debug = atoi(s);
				break;
d579 3
a581 4
			default:
				fprintf(stderr, "patch: unrecognized option `%s'\n",
				    Argv[0]);
				fprintf(stderr, "\
d587 2
a588 3
				my_exit(1);
			}
		}
d590 1
d593 2
a594 3
/*
 * Attempt to find the right place to apply this hunk of patch.
 */
d596 2
a597 1
locate_hunk(LINENUM fuzz)
d599 17
a615 15
	LINENUM	first_guess = pch_first() + last_offset;
	LINENUM	offset;
	LINENUM	pat_lines = pch_ptrn_lines();
	LINENUM	max_pos_offset = input_lines - first_guess - pat_lines + 1;
	LINENUM	max_neg_offset = first_guess - last_frozen_line - 1 + pch_context();

	if (!pat_lines)		/* null range matches always */
		return first_guess;
	if (max_neg_offset >= first_guess)	/* do not try lines < 0 */
		max_neg_offset = first_guess - 1;
	if (first_guess <= input_lines && patch_match(first_guess, Nulline, fuzz))
		return first_guess;
	for (offset = 1; ; offset++) {
		bool	check_after = (offset <= max_pos_offset);
		bool	check_before = (offset <= max_neg_offset);
d617 1
a617 1
		if (check_after && patch_match(first_guess, offset, fuzz)) {
d619 2
a620 3
			if (debug & 1)
				say("Offset changing from %ld to %ld\n",
				    last_offset, offset);
d622 4
a625 3
			last_offset = offset;
			return first_guess + offset;
		} else if (check_before && patch_match(first_guess, -offset, fuzz)) {
d627 2
a628 3
			if (debug & 1)
				say("Offset changing from %ld to %ld\n",
				    last_offset, -offset);
d630 2
a631 4
			last_offset = -offset;
			return first_guess - offset;
		} else if (!check_before && !check_after)
			return Nulline;
d633 3
d641 1
a641 1
abort_hunk(void)
d643 37
a679 46
	LINENUM	i;
	LINENUM	pat_end = pch_end();
	/*
	 * add in last_offset to guess the same as the previous successful
	 * hunk
	 */
	LINENUM	oldfirst = pch_first() + last_offset;
	LINENUM	newfirst = pch_newfirst() + last_offset;
	LINENUM	oldlast = oldfirst + pch_ptrn_lines() - 1;
	LINENUM	newlast = newfirst + pch_repl_lines() - 1;
	char	*stars = (diff_type >= NEW_CONTEXT_DIFF ? " ****" : "");
	char	*minuses = (diff_type >= NEW_CONTEXT_DIFF ? " ----" : " -----");

	fprintf(rejfp, "***************\n");
	for (i = 0; i <= pat_end; i++) {
		switch (pch_char(i)) {
		case '*':
			if (oldlast < oldfirst)
				fprintf(rejfp, "*** 0%s\n", stars);
			else if (oldlast == oldfirst)
				fprintf(rejfp, "*** %ld%s\n", oldfirst, stars);
			else
				fprintf(rejfp, "*** %ld,%ld%s\n", oldfirst,
				    oldlast, stars);
			break;
		case '=':
			if (newlast < newfirst)
				fprintf(rejfp, "--- 0%s\n", minuses);
			else if (newlast == newfirst)
				fprintf(rejfp, "--- %ld%s\n", newfirst, minuses);
			else
				fprintf(rejfp, "--- %ld,%ld%s\n", newfirst,
				    newlast, minuses);
			break;
		case '\n':
			fprintf(rejfp, "%s", pfetch(i));
			break;
		case ' ':
		case '-':
		case '+':
		case '!':
			fprintf(rejfp, "%c %s", pch_char(i), pfetch(i));
			break;
		default:
			fatal("fatal internal error in abort_hunk\n");
		}
d681 1
d687 2
a688 1
apply_hunk(LINENUM where)
d690 3
a692 3
	LINENUM	old = 1;
	LINENUM	lastline = pch_ptrn_lines();
	LINENUM	new = lastline + 1;
d697 47
a743 42
	int	def_state = OUTSIDE;
	bool	R_do_defines = do_defines;
	LINENUM	pat_end = pch_end();

	where--;
	while (pch_char(new) == '=' || pch_char(new) == '\n')
		new++;

	while (old <= lastline) {
		if (pch_char(old) == '-') {
			copy_till(where + old - 1);
			if (R_do_defines) {
				if (def_state == OUTSIDE) {
					fputs(not_defined, ofp);
					def_state = IN_IFNDEF;
				} else if (def_state == IN_IFDEF) {
					fputs(else_defined, ofp);
					def_state = IN_ELSE;
				}
				fputs(pfetch(old), ofp);
			}
			last_frozen_line++;
			old++;
		} else if (new > pat_end) {
			break;
		} else if (pch_char(new) == '+') {
			copy_till(where + old - 1);
			if (R_do_defines) {
				if (def_state == IN_IFNDEF) {
					fputs(else_defined, ofp);
					def_state = IN_ELSE;
				} else if (def_state == OUTSIDE) {
					fputs(if_defined, ofp);
					def_state = IN_IFDEF;
				}
			}
			fputs(pfetch(new), ofp);
			new++;
		} else if (pch_char(new) != pch_char(old)) {
			say("Out-of-sync patch, lines %ld,%ld--mangled text or line numbers, maybe?\n",
			    pch_hunk_beg() + old,
			    pch_hunk_beg() + new);
d745 2
a746 2
			say("oldchar = '%c', newchar = '%c'\n",
			    pch_char(old), pch_char(new));
d748 1
a748 31
			my_exit(1);
		} else if (pch_char(new) == '!') {
			copy_till(where + old - 1);
			if (R_do_defines) {
				fputs(not_defined, ofp);
				def_state = IN_IFNDEF;
			}
			while (pch_char(old) == '!') {
				if (R_do_defines) {
					fputs(pfetch(old), ofp);
				}
				last_frozen_line++;
				old++;
			}
			if (R_do_defines) {
				fputs(else_defined, ofp);
				def_state = IN_ELSE;
			}
			while (pch_char(new) == '!') {
				fputs(pfetch(new), ofp);
				new++;
			}
		} else {
			assert(pch_char(new) == ' ');
			old++;
			new++;
			if (R_do_defines && def_state != OUTSIDE) {
				fputs(end_defined, ofp);
				def_state = OUTSIDE;
			}
		}
d750 7
a756 2
	if (new <= pat_end && pch_char(new) == '+') {
		copy_till(where + old - 1);
d758 1
a758 11
			if (def_state == OUTSIDE) {
				fputs(if_defined, ofp);
				def_state = IN_IFDEF;
			} else if (def_state == IN_IFNDEF) {
				fputs(else_defined, ofp);
				def_state = IN_ELSE;
			}
		}
		while (new <= pat_end && pch_char(new) == '+') {
			fputs(pfetch(new), ofp);
			new++;
d760 11
d772 5
a776 1
	if (R_do_defines && def_state != OUTSIDE) {
d778 2
d781 21
d804 2
a805 3
/*
 * Open the new file.
 */
d807 2
a808 1
init_output(char *name)
d810 3
a812 3
	ofp = fopen(name, "w");
	if (ofp == Nullfp)
		pfatal("can't create %s", name);
d815 2
a816 3
/*
 * Open a file to put hunks we can't locate.
 */
d818 2
a819 1
init_reject(char *name)
d821 3
a823 3
	rejfp = fopen(name, "w");
	if (rejfp == Nullfp)
		pfatal("can't create %s", name);
d826 2
a827 3
/*
 * Copy input file to output, up to wherever hunk is to be applied.
 */
d829 2
a830 1
copy_till(LINENUM lastline)
d832 1
a832 1
	LINENUM	R_last_frozen_line = last_frozen_line;
d834 6
a839 5
	if (R_last_frozen_line > lastline)
		fatal("misordered hunks! output would be garbled\n");
	while (R_last_frozen_line < lastline)
		dump_line(++R_last_frozen_line);
	last_frozen_line = R_last_frozen_line;
d842 2
a843 3
/*
 * Finish copying the input file to the output file.
 */
d845 1
a845 1
spew_output(void)
d848 2
a849 2
	if (debug & 256)
		say("il=%ld lfl=%ld\n", input_lines, last_frozen_line);
d851 4
a854 4
	if (input_lines)
		copy_till(input_lines);	/* dump remainder of file */
	fclose(ofp);
	ofp = Nullfp;
d857 2
a858 3
/*
 * Copy one line from input to output.
 */
d860 2
a861 1
dump_line(LINENUM line)
d863 2
a864 1
	char	*s, R_newline = '\n';
d866 5
a870 3
	/* Note: string is not null terminated. */
	for (s=ifetch(line, 0); putc(*s, ofp) != R_newline; s++)
		;
d873 2
a874 3
/*
 * Does the patch pattern match at line base+offset?
 */
d876 22
a897 16
patch_match(LINENUM base, LINENUM offset, LINENUM fuzz)
{
	LINENUM	pline = 1 + fuzz;
	LINENUM	iline;
	LINENUM	pat_lines = pch_ptrn_lines() - fuzz;

	for (iline = base + offset + fuzz; pline <= pat_lines; pline++, iline++) {
		if (canonicalize) {
			if (!similar(ifetch(iline, (offset >= 0)),
			    pfetch(pline), pch_line_len(pline)))
				return FALSE;
		} else if (strnNE(ifetch(iline, (offset >= 0)),
		    pfetch(pline), pch_line_len(pline)))
			return FALSE;
	}
	return TRUE;
d900 2
a901 3
/*
 * Do two lines match with canonicalized white space?
 */
d903 17
a919 16
similar(char *a, char *b, int len)
{
	while (len) {
		if (isspace(*b)) {	/* whitespace (or \n) to match? */
			if (!isspace(*a))	/* no corresponding whitespace? */
				return FALSE;
			while (len && isspace(*b) && *b != '\n')
				b++, len--;	/* skip pattern whitespace */
			while (isspace(*a) && *a != '\n')
				a++;	/* skip target whitespace */
			if (*a == '\n' || *b == '\n')
				return (*a == *b);	/* should end in sync */
		} else if (*a++ != *b++)	/* match non-whitespace chars */
			return FALSE;
		else
			len--;	/* probably not necessary */
d921 7
a927 2
	return TRUE;		/* actually, this is not reached */
	/* since there is always a \n */
d930 2
a931 3
/*
 * Exit with cleanup.
 */
d933 2
a934 1
my_exit(int status)
d936 9
a944 7
	unlink(TMPINNAME);
	if (!toutkeep)
		unlink(TMPOUTNAME);
	if (!trejkeep)
		unlink(TMPREJNAME);
	unlink(TMPPATNAME);
	exit(status);
@


1.1.1.6
log
@Import latest OpenBSD ports, XFree and source in sync
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.27 2003/07/25 02:12:45 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.27 2003/07/25 02:12:45 millert Exp $";
a32 11
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include <assert.h>
#include <ctype.h>
#include <getopt.h>
#include <limits.h>
#include <string.h>
#include <stdlib.h>

d41 16
a56 14

static void	reinitialize_almost_everything(void);
static void	get_some_switches(void);
static LINENUM	locate_hunk(LINENUM);
static void	abort_hunk(void);
static void	apply_hunk(LINENUM);
static void	init_output(char *);
static void	init_reject(char *);
static void	copy_till(LINENUM);
static void	spew_output(void);
static void	dump_line(LINENUM);
static bool	patch_match(LINENUM, LINENUM, LINENUM);
static bool	similar(char *, char *, int);
static __dead void usage(void);
d64 2
a65 6
/* buffer holding the name of the rejected patch file. */
static char	rejname[NAME_MAX + 1];

/* buffer for stderr */
static char	serrbuf[BUFSIZ];

d78 1
a78 1
		filearg[i] = NULL;
d117 3
a124 8
	if (backup_type == none) {
		v = getenv("VERSION_CONTROL");
#ifdef notyet
		if (v != NULL)
#endif
			backup_type = get_version(v);	/* OK to pass NULL. */
	}

d134 1
a134 1
		if (outname == NULL)
d162 1
a162 1
			fuzz = NULL;
d169 1
a169 1
					if (hunk == 1 && where == NULL && !force) {
d172 1
a172 1
							if (fuzz == NULL)
d179 1
a179 1
						if (where == NULL) {
d205 1
a205 1
								where = NULL;
d213 1
a213 1
				} while (!skip_rest_of_patch && where == NULL &&
d218 1
a218 1
					ofp = NULL;
d228 1
a228 1
			} else if (where == NULL) {
d256 1
a256 1
			ofp = NULL;
d259 1
a259 1
			rejfp = NULL;
d293 1
a293 1
		rejfp = NULL;
d324 1
a324 1
static void
d334 1
a334 1
	if (filearg[0] != NULL && !out_of_mem) {
d336 1
a336 1
		filearg[0] = NULL;
d338 1
a338 1
	if (outname != NULL) {
d340 1
a340 1
		outname = NULL;
d346 1
a346 1
	if (revision != NULL) {
d348 1
a348 1
		revision = NULL;
d354 11
d367 52
a418 1
/* Process switches and filenames. */
d420 10
a429 1
static void
d432 1
a432 30
	const char *options = "b::B:cCd:D:eEfF:lnNo:p::r:RstuvV:x:z:";
	static struct option longopts[] = {
		{"backup",		no_argument,		0,	'b'},
		{"batch",		no_argument,		0,	't'},
		{"check",		no_argument,		0,	'C'},
		{"context",		no_argument,		0,	'c'},
		{"debug",		required_argument,	0,	'x'},
		{"directory",		required_argument,	0,	'd'},
		{"ed",			no_argument,		0,	'e'},
		{"force",		no_argument,		0,	'f'},
		{"forward",		no_argument,		0,	'N'},
		{"fuzz",		required_argument,	0,	'F'},
		{"ifdef",		required_argument,	0,	'D'},
		{"ignore-whitespace",	no_argument,		0,	'l'},
		{"normal",		no_argument,		0,	'n'},
		{"output",		required_argument,	0,	'o'},
		{"prefix",		required_argument,	0,	'B'},
		{"quiet",		no_argument,		0,	's'},
		{"reject-file",		required_argument,	0,	'r'},
		{"remove-empty-files",	no_argument,		0,	'E'},
		{"reverse",		no_argument,		0,	'R'},
		{"silent",		no_argument,		0,	's'},
		{"strip",		optional_argument,	0,	'p'},
		{"suffix",		required_argument,	0,	'z'},
		{"unified",		no_argument,		0,	'u'},
		{"version",		no_argument,		0,	'v'},
		{"version-control",	required_argument,	0,	'V'},
		{NULL,			0,			0,	0}
	};
	int ch;
d439 110
a548 9
	optreset = optind = 1;
	while ((ch = getopt_long(Argc, Argv, options, longopts, NULL)) != -1) {
		switch (ch) {
		case 'b':
#ifdef notyet
			if (backup_type == none)
				backup_type = numbered_existing;
#endif
			if (optarg == NULL)
a549 83
			if (verbose)
				say("Warning, the ``-b suffix'' option has been"
				    " obsoleted by the -z option.\n");
			/* FALLTHROUGH */
		case 'z':
			/* must directly follow 'b' case for backwards compat */
			simple_backup_suffix = savestr(optarg);
			break;
		case 'B':
			origprae = savestr(optarg);
			break;
		case 'c':
			diff_type = CONTEXT_DIFF;
			break;
		case 'C':
			check_only = TRUE;
			break;
		case 'd':
			if (chdir(optarg) < 0)
				pfatal("can't cd to %s", optarg);
			break;
		case 'D':
			do_defines = TRUE;
			if (!isalpha(*optarg) && *optarg != '_')
				fatal("argument to -D is not an identifier\n");
			snprintf(if_defined, sizeof if_defined,
			    "#ifdef %s\n", optarg);
			snprintf(not_defined, sizeof not_defined,
			    "#ifndef %s\n", optarg);
			snprintf(end_defined, sizeof end_defined,
			    "#endif /* %s */\n", optarg);
			break;
		case 'e':
			diff_type = ED_DIFF;
			break;
		case 'E':
			remove_empty_files = TRUE;
			break;
		case 'f':
			force = TRUE;
			break;
		case 'F':
			maxfuzz = atoi(optarg);
			break;
		case 'l':
			canonicalize = TRUE;
			break;
		case 'n':
			diff_type = NORMAL_DIFF;
			break;
		case 'N':
			noreverse = TRUE;
			break;
		case 'o':
			outname = savestr(optarg);
			break;
		case 'p':
			strippath = optarg ? atoi(optarg) : 0;
			break;
		case 'r':
			if (strlcpy(rejname, optarg,
			    sizeof(rejname)) >= sizeof(rejname))
				fatal("argument for -r is too long\n");
			break;
		case 'R':
			reverse = TRUE;
			reverse_flag_specified = TRUE;
			break;
		case 's':
			verbose = FALSE;
			break;
		case 't':
			batch = TRUE;
			break;
		case 'u':
			diff_type = UNI_DIFF;
			break;
		case 'v':
			version();
			break;
		case 'V':
			backup_type = get_version(optarg);
			break;
d551 5
a555 3
		case 'x':
			debug = atoi(optarg);
			break;
d557 11
a567 3
		default:
			usage();
			break;
a569 20
	Argc -= optind;
	Argv += optind;

	while (Argc > 0) {
		if (filec == MAXFILEC)
			fatal("too many file arguments\n");
		filearg[filec++] = savestr(*Argv++);
		Argc--;
	}
}

static __dead void
usage(void)
{
	fprintf(stderr,
"usage: patch [-bcCeEflnNRstuv] [-B backup-prefix] [-d directory] [-D symbol]\n"
"             [-Fmax-fuzz] [-o out-file] [-p[strip-count]] [-r rej-name]\n"
"             [-V {numbered,existing,simple}] [-z backup-ext]\n"
"             [origfile [patchfile]]\n");
	my_exit(1);
d575 1
a575 1
static LINENUM
d588 1
a588 1
	if (first_guess <= input_lines && patch_match(first_guess, NULL, fuzz))
d611 1
a611 1
			return NULL;
d617 1
a617 1
static void
d671 1
a671 1
static void
d783 1
a783 1
static void
d787 1
a787 1
	if (ofp == NULL)
d794 1
a794 1
static void
d798 1
a798 1
	if (rejfp == NULL)
d805 1
a805 1
static void
d820 1
a820 1
static void
d830 1
a830 1
	ofp = NULL;
d836 1
a836 1
static void
a840 3
	s = ifetch(line, 0);
	if (s == NULL)
		return;
d842 1
a842 1
	for (; putc(*s, ofp) != R_newline; s++)
d849 1
a849 1
static bool
a854 3
	char *ilineptr;
	char *plineptr;
	short plinelen;
a856 5
		ilineptr = ifetch(iline, offset >= 0);
		if (ilineptr == NULL)
			return FALSE;
		plineptr = pfetch(pline);
		plinelen = pch_line_len(pline);
d858 2
a859 1
			if (!similar(ilineptr, plineptr, plinelen))
d861 2
a862 1
		} else if (strnNE(ilineptr, plineptr, plinelen))
d871 1
a871 1
static bool
d891 15
@


1.1.1.7
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.37 2003/08/10 21:28:48 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.37 2003/08/10 21:28:48 otto Exp $";
d37 1
a40 1
#include <stdio.h>
d44 1
d46 1
a50 1
#include "pathnames.h"
a51 38
int		filemode = 0644;

char		buf[MAXLINELEN];	/* general purpose buffer */

bool		using_plan_a = true;	/* try to keep everything in memory */
bool		out_of_mem = false;	/* ran out of memory in plan a */

#define MAXFILEC 2

char		*filearg[MAXFILEC];
bool		ok_to_create_file = false;
char		*outname = NULL;
char		*origprae = NULL;
char		*TMPOUTNAME;
char		*TMPINNAME;
char		*TMPREJNAME;
char		*TMPPATNAME;
bool		toutkeep = false;
bool		trejkeep = false;
bool		warn_on_invalid_line;
bool		last_line_missing_eol;

#ifdef DEBUGGING
int		debug = 0;
#endif

bool		force = false;
bool		batch = false;
bool		verbose = true;
bool		reverse = false;
bool		noreverse = false;
bool		skip_rest_of_patch = false;
int		strippath = 957;
bool		canonicalize = false;
bool		check_only = false;
int		diff_type = 0;
char		*revision = NULL;	/* prerequisite revision, if any */
LINENUM		input_lines = 0;	/* how long is input file in lines */
d58 3
a60 3
static void	init_output(const char *);
static void	init_reject(const char *);
static void	copy_till(LINENUM, bool);
d62 1
a62 1
static void	dump_line(LINENUM, bool);
d64 1
a64 1
static bool	similar(const char *, const char *, int);
d67 2
a68 2
/* true if -E was specified on command line.  */
static bool	remove_empty_files = false;
d70 2
a71 2
/* true if -R was specified on command line.  */
static bool	reverse_flag_specified = false;
a78 26
/* how many input lines have been irretractibly output */
static LINENUM	last_frozen_line = 0;

static int	Argc;		/* guess */
static char	**Argv;
static int	Argc_last;	/* for restarting plan_b */
static char	**Argv_last;

static FILE	*ofp = NULL;	/* output file pointer */
static FILE	*rejfp = NULL;	/* reject file pointer */

static int	filec = 0;	/* how many file arguments? */
static LINENUM	last_offset = 0;
static LINENUM	maxfuzz = 2;

/* patch using ifdef, ifndef, etc. */
static bool		do_defines = false;
/* #ifdef xyzzy */
static char		if_defined[128];
/* #ifndef xyzzy */
static char		not_defined[128];
/* #else */
static const char	else_defined[] = "#else\n";
/* #endif xyzzy */
static char		end_defined[128];

d85 3
a87 4
	int	error = 0, hunk, failed, patch_seen = 0, i, fd;
	LINENUM	where = 0, newwhere, fuzz, mymaxfuzz;
	const	char *tmpdir;
	char	*v;
d93 2
d96 5
a100 6
	if ((tmpdir = getenv("TMPDIR")) == NULL || *tmpdir == '\0')
		tmpdir = _PATH_TMP;
	for (i = strlen(tmpdir) - 1; i > 0 && tmpdir[i] == '/'; i--)
		;
	i++;
	if (asprintf(&TMPOUTNAME, "%.*s/patchoXXXXXXXXXX", i, tmpdir) == -1)
d102 1
a102 1
	if ((fd = mkstemp(TMPOUTNAME)) < 0)
d104 1
a104 1
	close(fd);
d106 1
a106 1
	if (asprintf(&TMPINNAME, "%.*s/patchiXXXXXXXXXX", i, tmpdir) == -1)
d108 1
a108 1
	if ((fd = mkstemp(TMPINNAME)) < 0)
d110 1
a110 1
	close(fd);
d112 1
a112 1
	if (asprintf(&TMPREJNAME, "%.*s/patchrXXXXXXXXXX", i, tmpdir) == -1)
d114 1
a114 1
	if ((fd = mkstemp(TMPREJNAME)) < 0)
d116 1
a116 1
	close(fd);
d118 1
a118 1
	if (asprintf(&TMPPATNAME, "%.*s/patchpXXXXXXXXXX", i, tmpdir) == -1)
d120 1
a120 1
	if ((fd = mkstemp(TMPPATNAME)) < 0)
d122 1
a122 1
	close(fd);
d150 1
a150 2
		patch_seen = true;
		warn_on_invalid_line = true;
d177 1
a177 1
		out_of_mem = false;
d180 1
a180 1
			fuzz = 0;
d187 1
a187 1
					if (hunk == 1 && where == 0 && !force) {
d190 1
a190 1
							if (fuzz == 0)
d197 1
a197 1
						if (where == 0) {
d209 1
a209 1
							skip_rest_of_patch = true;
d222 2
a223 2
									skip_rest_of_patch = true;
								where = 0;
d231 2
a232 2
				} while (!skip_rest_of_patch && where == 0 &&
				    ++fuzz <= mymaxfuzz);
d246 1
a246 1
			} else if (where == 0) {
d257 1
a257 1
					if (fuzz != 0)
d280 1
a280 2
		if (hunk == 0)
			fatal("Internal error: hunk should not be 0\n");
d294 1
a294 1
					toutkeep = true;
d313 2
a314 2
			error = 1;
			if (*rejname == '\0') {
d330 1
a330 1
				trejkeep = true;
d334 3
a336 1
	my_exit(error);
d352 1
a352 1
	if (!out_of_mem) {
d356 5
a361 4
	free(outname);
	outname = NULL;

	last_offset = 0;
d364 4
a367 3
	free(revision);
	revision = NULL;

d369 1
a369 1
	skip_rest_of_patch = false;
d379 1
a379 1
	const char *options = "b::B:cCd:D:eEfF:i:lnNo:p:r:RstuvV:x:z:";
a391 1
		{"input",		required_argument,	0,	'i'},
d401 1
a401 1
		{"strip",		required_argument,	0,	'p'},
d440 1
a440 1
			check_only = true;
d447 1
a447 1
			do_defines = true;
d461 1
a461 1
			remove_empty_files = true;
d464 1
a464 1
			force = true;
a468 5
		case 'i':
			if (++filec == MAXFILEC)
				fatal("too many file arguments\n");
			filearg[filec] = savestr(optarg);
			break;
d470 1
a470 1
			canonicalize = true;
d476 1
a476 1
			noreverse = true;
d482 1
a482 1
			strippath = atoi(optarg);
d490 2
a491 2
			reverse = true;
			reverse_flag_specified = true;
d494 1
a494 1
			verbose = false;
d497 1
a497 1
			batch = true;
d521 4
a524 2
	if (Argc > 0) {
		filearg[0] = savestr(*Argv++);
a525 6
		while (Argc > 0) {
			if (++filec == MAXFILEC)
				fatal("too many file arguments\n");
			filearg[filec] = savestr(*Argv++);
			Argc--;
		}
d534 2
a535 2
"             [-F max-fuzz] [-i patchfile] [-o out-file] [-p strip-count]\n"
"             [-r rej-name] [-V {numbered,existing,simple}] [-z backup-ext]\n"
d537 1
a537 1
	my_exit(EXIT_SUCCESS);
d552 1
a552 7
	if (pat_lines == 0) {		/* null range matches always */
		if (verbose && (diff_type == CONTEXT_DIFF
		    || diff_type == NEW_CONTEXT_DIFF
		    || diff_type == UNI_DIFF)) {
			say("Empty context always matches.\n");
			say("Detection of previously applied patch not possible.\n");
		}
a553 1
	}
d556 1
a556 1
	if (first_guess <= input_lines && patch_match(first_guess, 0, fuzz))
d579 1
a579 1
			return 0;
d589 1
a589 1
	const LINENUM	pat_end = pch_end();
d594 6
a599 6
	const LINENUM	oldfirst = pch_first() + last_offset;
	const LINENUM	newfirst = pch_newfirst() + last_offset;
	const LINENUM	oldlast = oldfirst + pch_ptrn_lines() - 1;
	const LINENUM	newlast = newfirst + pch_repl_lines() - 1;
	const char	*stars = (diff_type >= NEW_CONTEXT_DIFF ? " ****" : "");
	const char	*minuses = (diff_type >= NEW_CONTEXT_DIFF ? " ----" : " -----");
d642 3
a644 3
	LINENUM		old = 1;
	const LINENUM	lastline = pch_ptrn_lines();
	LINENUM		new = lastline + 1;
d649 3
a651 2
	int		def_state = OUTSIDE;
	const LINENUM	pat_end = pch_end();
d659 2
a660 2
			copy_till(where + old - 1, false);
			if (do_defines) {
d675 2
a676 2
			copy_till(where + old - 1, false);
			if (do_defines) {
d695 1
a695 1
			my_exit(2);
d697 2
a698 2
			copy_till(where + old - 1, false);
			if (do_defines) {
d703 1
a703 1
				if (do_defines) {
d709 1
a709 1
			if (do_defines) {
d718 1
a718 2
			if (pch_char(new) != ' ')
				fatal("Internal error: expected ' '\n");
d721 1
a721 1
			if (do_defines && def_state != OUTSIDE) {
d728 2
a729 2
		copy_till(where + old - 1, false);
		if (do_defines) {
d743 1
a743 1
	if (do_defines && def_state != OUTSIDE) {
d752 1
a752 1
init_output(const char *name)
d763 1
a763 1
init_reject(const char *name)
a771 2
 * If endoffile is true, treat the last line specially since it may
 * lack a newline.
d774 1
a774 1
copy_till(LINENUM lastline, bool endoffile)
d776 3
a778 1
	if (last_frozen_line > lastline)
d780 3
a782 6
	while (last_frozen_line < lastline) {
		if (++last_frozen_line == lastline && endoffile)
			dump_line(last_frozen_line, !last_line_missing_eol);
		else
			dump_line(last_frozen_line, true);
	}
d796 1
a796 1
		copy_till(input_lines, true);	/* dump remainder of file */
d805 1
a805 1
dump_line(LINENUM line, bool write_newline)
d807 1
a807 1
	char	*s;
d812 3
a814 5
	/* Note: string is not NUL terminated. */
	for (; *s != '\n'; s++)
		putc(*s, ofp);
	if (write_newline)
		putc('\n', ofp);
d823 6
a828 6
	LINENUM		pline = 1 + fuzz;
	LINENUM		iline;
	LINENUM		pat_lines = pch_ptrn_lines() - fuzz;
	const char	*ilineptr;
	const char	*plineptr;
	short		plinelen;
d833 1
a833 1
			return false;
d838 1
a838 1
				return false;
d840 1
a840 1
			return false;
d842 1
a842 1
	return true;
d849 1
a849 1
similar(const char *a, const char *b, int len)
d854 1
a854 1
				return false;
d862 1
a862 1
			return false;
d866 1
a866 1
	return true;		/* actually, this is not reached */
@


1.1.1.8
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.38 2003/10/31 20:20:45 millert Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.38 2003/10/31 20:20:45 millert Exp $";
a88 1
int		posix = 0;		/* strict POSIX mode? */
d199 4
a202 3
		if ((v = getenv("PATCH_VERSION_CONTROL")) == NULL)
			v = getenv("VERSION_CONTROL");
		if (v != NULL || !posix)
a467 1
		{"posix",		no_argument,		&posix,	1},
d481 1
d484 1
d581 1
a581 2
			if (ch != '\0')
				usage();
a597 3

	if (getenv("POSIXLY_CORRECT") != NULL)
		posix = 1;
@


1.1.1.9
log
@better patch(1) fixes from obsd
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.42 2004/09/14 23:54:21 deraadt Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.42 2004/09/14 23:54:21 deraadt Exp $";
d149 1
a149 1
	int	error = 0, hunk, failed, i, fd;
d213 1
d627 1
a627 1
		if (verbose && fuzz == 0 && (diff_type == CONTEXT_DIFF
d631 1
d633 1
a633 7
		if (diff_type == CONTEXT_DIFF
		    || diff_type == NEW_CONTEXT_DIFF
		    || diff_type == UNI_DIFF) {
			if (fuzz == 0)
				return (input_lines == 0 ? first_guess : 0);
		} else
			return (first_guess);
a926 15
		if (iline == input_lines) {
			/*
			 * We are looking at the last line of the file.
			 * If the file has no eol, the patch line should
			 * not have one either and vice-versa. Note that
			 * plinelen > 0.
			 */
			if (last_line_missing_eol) {
				if (plineptr[plinelen - 1] == '\n')
					return false;
			} else {
				if (plineptr[plinelen - 1] != '\n')
					return false;
			}
		}
@


1.1.1.10
log
@w00t! patch(1) writes rejected hunks in unified format! :)
@
text
@d1 1
a1 1
/*	$OpenBSD: patch.c,v 1.43 2004/11/19 20:08:11 otto Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: patch.c,v 1.43 2004/11/19 20:08:11 otto Exp $";
a93 2
static void	abort_context_hunk(void);
static void	rej_line(int, LINENUM);
d671 1
a671 1
abort_context_hunk(void)
d717 1
a717 79
			fatal("fatal internal error in abort_context_hunk\n");
		}
	}
}

static void
rej_line(int ch, LINENUM i)
{
	size_t len;
	const char *line = pfetch(i);

	len = strlen(line);

	fprintf(rejfp, "%c%s", ch, line);
	if (len == 0 || line[len-1] != '\n')
		fprintf(rejfp, "\n\\ No newline at end of file\n");
}

static void
abort_hunk(void)
{
	LINENUM		i, j, split;
	int		ch1, ch2;
	const LINENUM	pat_end = pch_end();
	const LINENUM	oldfirst = pch_first() + last_offset;
	const LINENUM	newfirst = pch_newfirst() + last_offset;

	if (diff_type != UNI_DIFF) {
		abort_context_hunk();
		return;
	}
	split = -1;
	for (i = 0; i <= pat_end; i++) {
		if (pch_char(i) == '=') {
			split = i;
			break;
		}
	}
	if (split == -1) {
		fprintf(rejfp, "malformed hunk: no split found\n");
		return;
	}
	i = 0;
	j = split + 1;
	fprintf(rejfp, "@@@@ -%ld,%ld +%ld,%ld @@@@\n",
	    pch_ptrn_lines() ? oldfirst : 0,
	    pch_ptrn_lines(), newfirst, pch_repl_lines());
	while (i < split || j <= pat_end) {
		ch1 = i < split ? pch_char(i) : -1;
		ch2 = j <= pat_end ? pch_char(j) : -1;
		if (ch1 == '-') {
			rej_line('-', i);
			i++;
		} else if (ch1 == ' ' && ch2 == ' ') {
			rej_line(' ', i);
			i++;
			j++;
		} else if (ch1 == '!' && ch2 == '!') {
			while (i < split && ch1 == '!') {
				rej_line('-', i);
				i++;
				ch1 = i < split ? pch_char(i) : -1;
			}
			while (j <= pat_end && ch2 == '!') {
				rej_line('+', j);
				j++;
				ch2 = j <= pat_end ? pch_char(j) : -1;
			}
		} else if (ch1 == '*') {
			i++;
		} else if (ch2 == '+' || ch2 == ' ') {
			rej_line(ch2, j);
			j++;
		} else {
			fprintf(rejfp, "internal error on (%ld %ld %ld)\n",
			    i, split, j);
			rej_line(ch1, i);
			rej_line(ch2, j);
			return;
@


