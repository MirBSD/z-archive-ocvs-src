head	1.2;
access;
symbols
	MIRBSD_XP_MIRPPC:1.1.1.5.0.10
	MIRBSD_XP_SPARC_BASE:1.1.1.5
	MIRBSD_XP_SPARC:1.1.1.5.0.8
	MIRBSD_7quater:1.1.1.5
	cvs-200405160640:1.1.1.5
	cvs-200401271800:1.1.1.5
	cvs-200401261630:1.1.1.5
	cvs-200401021645:1.1.1.5
	MIRBSD_7_ALPHA:1.1.1.5.0.6
	MIRBSD_7:1.1.1.5.0.4
	cvs-200312222040:1.1.1.5
	MIRBSD_7ter:1.1.1.5
	MIRBSD_7_DEV:1.1.1.5.0.2
	cvs-200310020700:1.1.1.5
	cvs-200309271030:1.1.1.5
	cvs-200309251530:1.1.1.5
	cvs-200308302005:1.1.1.5
	cvs-200308171200:1.1.1.5
	ctm-3496:1.1.1.5
	ctm-3449:1.1.1.5
	ctm-3437:1.1.1.5
	cvs-200307191805:1.1.1.5
	ctm-3425:1.1.1.5
	cvs-200307091500:1.1.1.5
	ctm-3389:1.1.1.5
	cvs-200306291430:1.1.1.5
	ctm-3341:1.1.1.5
	MIRBSD_5:1.1.1.5
	cvs-200306082100:1.1.1.5
	ctm-3316:1.1.1.5
	ctm-3272:1.1.1.4
	ctm-3264:1.1.1.3
	cvs-200305071630:1.1.1.3
	MIRBSD_4:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.11.13.18.34.41;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.53.15;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.53.15;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.55.22;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.07.17.53.47;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.21.19.16.15;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.06.05.17.44.01;	author tg;	state Stab;
branches;
next	;


desc
@@


1.2
log
@* gprof: I don't know; I think gprof is pointless (since I don't write
  hooks for profiling libraries into gcc3, nor do we build these since
  years), but let's keep it here - the BSD version, not the GNU versi-
  on, and with unused arches deleted
* oldrdist: u-uh, deserves to die
* rdist, rdistd, sup: I don't think anybody would use them willingly;
  if so, please tell me (and I hope you've got a very good reason to
  do so ;-)
* learn: it was nice as a document of UNIX(R) history, but I'm cleaning
  up base right now, so...
@
text
@/*	$OpenBSD: client.c,v 1.13 2001/11/19 19:02:15 mpech Exp $	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
#if 0
static char RCSid[] = 
"$From: client.c,v 6.80 1996/02/28 20:34:27 mcooper Exp $";
#else
static char RCSid[] = 
"$OpenBSD: client.c,v 1.13 2001/11/19 19:02:15 mpech Exp $";
#endif

static char sccsid[] = "@@(#)client.c";

static char copyright[] =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

/*
 * Routines used in client mode to communicate with remove server.
 */

#include "defs.h"
#include "y.tab.h"

/*
 * Update status
 */
#define US_NOTHING 	0	/* No update needed */
#define US_NOENT	1	/* Entry does not exist */
#define US_OUTDATE	2	/* Entry is out of date */
#define US_DOCOMP	3	/* Do a binary comparison */
#define US_MODE		4	/* Modes of file differ */

struct	linkbuf *ihead = NULL;	/* list of files with more than one link */
char	buf[BUFSIZ];		/* general purpose buffer */
u_char	respbuff[BUFSIZ];	/* Response buffer */
char	target[BUFSIZ];		/* target/source directory name */
char	source[BUFSIZ];		/* source directory name */
char	*ptarget;		/* pointer to end of target name */
char	*Tdest;			/* pointer to last T dest*/
struct namelist	*updfilelist = NULL; /* List of updated files */

static int sendit();

/*
 * return remote file pathname (relative from target)
 */
char *remfilename(src, dest, path, rname, destdir)
	char *src, *dest, *path, *rname;
	int destdir;
{
	extern struct namelist *filelist;
	char *lname, *cp;
	static char buff[BUFSIZ];
	int srclen, pathlen;
	char *p;


	debugmsg(DM_MISC, 
		 "remfilename: src=%s dest=%s path=%s rname=%s destdir=%d\n",
		A(src), A(dest), A(path), A(rname), destdir);

	if (!dest) {
		debugmsg(DM_MISC, "remfilename: remote filename=%s\n", path);
		return(path);
	}

	if (!destdir) {
		debugmsg(DM_MISC, "remfilename: remote filename=%s\n", dest);
		return(dest);
	}

	buff[0] = CNULL;
	lname = buff;
	if (path && *path) {
		cp = strrchr(path, '/');
 		if (cp == NULL)
			(void) sprintf(buff, "%s/%s", dest, path);
		else {
			srclen = strlen(src);
			pathlen = strlen(path);
			if (srclen >= pathlen)
				cp++; /* xbasename(path) */
			else {
				if (filelist && filelist->n_next == NULL)
					/* path relative to src */
					cp = path + srclen;
				else {
					if ((p = strrchr(src, '/')))
						cp = path + srclen - strlen(p);
					else
						cp = path;
				}
			}
			if ((*cp != '/') && *cp)
				(void) sprintf(buff, "%s/%s", dest, cp);
			else
				(void) sprintf(buff, "%s%s", dest, cp);
		}
	} else
		strcpy(lname, dest);

	debugmsg(DM_MISC, "remfilename: remote filename=%s\n", lname);

	return(lname);
}

/*
 * Return true if name is in the list.
 */
int inlist(list, file)
	struct namelist *list;
	char *file;
{
	struct namelist *nl;

	for (nl = list; nl != NULL; nl = nl->n_next)
		if (strcmp(file, nl->n_name) == 0)
			return(1);
	return(0);
}

/*
 * Run any special commands for this file
 */
static void runspecial(starget, opts, rname, destdir)
	char *starget;
	opt_t opts;
	char *rname;
	int destdir;
{
	struct subcmd *sc;
	extern struct subcmd *subcmds;
	char *rfile;

 	rfile = remfilename(source, Tdest, target, rname, destdir);

	for (sc = subcmds; sc != NULL; sc = sc->sc_next) {
		if (sc->sc_type != SPECIAL)
			continue;
		if (sc->sc_args != NULL && !inlist(sc->sc_args, starget))
			continue;
		message(MT_CHANGE, "special \"%s\"", sc->sc_name);
		if (IS_ON(opts, DO_VERIFY))
			continue;
		(void) sendcmd(C_SPECIAL,
			"%s=%s;%s=%s;%s=%s;export %s %s %s;%s",
			E_LOCFILE, starget,
			E_REMFILE, rfile,
			E_BASEFILE, xbasename(rfile),
			E_LOCFILE, E_REMFILE, E_BASEFILE,
			sc->sc_name);
		while (response() > 0)
			;
	}
}

/*
 * If we're doing a target with a "cmdspecial" in it, then
 * save the name of the file being updated for use with "cmdspecial".
 */
static void addcmdspecialfile(starget, rname, destdir)
	char *starget;
	char *rname;
	int destdir;
{
	char *rfile;
	struct namelist *new;
	struct subcmd *sc;
	extern struct subcmd *subcmds;
	int isokay = 0;

 	rfile = remfilename(source, Tdest, target, rname, destdir);

	for (sc = subcmds; sc != NULL && !isokay; sc = sc->sc_next) {
		if (sc->sc_type != CMDSPECIAL)
			continue;
		if (sc->sc_args != NULL && !inlist(sc->sc_args, starget))
			continue;
		isokay = TRUE;
	}

	if (isokay) {
		new = (struct namelist *) xmalloc(sizeof(struct namelist));
		new->n_name = xstrdup(rfile);
		new->n_next = updfilelist;
		updfilelist = new;
	}
}

/*
 * Free the file list
 */
static void freecmdspecialfiles()
{
	struct namelist *ptr, *save;

	for (ptr = updfilelist; ptr; ) {
		if (ptr->n_name) (void) free(ptr->n_name);
		save = ptr->n_next;
		(void) free(ptr);
		if (save)
			ptr = save->n_next;
		else
			ptr = NULL;
	}
	updfilelist = NULL;
}

/*
 * Run commands for an entire cmd
 */
extern void runcmdspecial(cmd, filev, opts)
	struct cmd *cmd;
	char **filev;
	opt_t opts;
{
	struct subcmd *sc;
	struct namelist *f;
	int first = TRUE;

	for (sc = cmd->c_cmds; sc != NULL; sc = sc->sc_next) {
		if (sc->sc_type != CMDSPECIAL)
			continue;
		message(MT_CHANGE, "cmdspecial \"%s\"", sc->sc_name);
		if (IS_ON(opts, DO_VERIFY))
			continue;
		/* Send all the file names */
		for (f = updfilelist; f != NULL; f = f->n_next) {
			if (first) {
				(void) sendcmd(C_CMDSPECIAL, NULL);
				if (response() < 0)
					return;
				first = FALSE;
			}
			(void) sendcmd(RC_FILE, f->n_name);
			if (response() < 0)
				return;
		}
		if (first) {
			(void) sendcmd(C_CMDSPECIAL, NULL);
			if (response() < 0)
				return;
			first = FALSE;
		}
		/* Send command to run and wait for it to complete */
		(void) sendcmd(RC_COMMAND, sc->sc_name);
		while (response() > 0)
			;
		first = TRUE;	/* Reset in case there are more CMDSPECIAL's */
	}
	freecmdspecialfiles();
}

/*
 * For security, reject filenames that contains a newline
 */
int checkfilename(name)
	char *name;
{
	char *cp;

	if (strchr(name, '\n')) {
		for (cp = name; *cp; cp++)
			if (*cp == '\n')
				*cp = '?';
		message(MT_NERROR, 
			"Refuse to handle filename containing newline: %s",
			name);
		return(-1);
	}

	return(0);
}

void freelinkinfo(lp)
	struct linkbuf *lp;
{
	if (lp->pathname)
		free(lp->pathname);
	if (lp->src)
		free(lp->src);
	if (lp->target)
		free(lp->target);
	free(lp);
}

/*
 * Save and retrieve hard link info
 */
static struct linkbuf *linkinfo(statp)
	struct stat *statp;
{
	struct linkbuf *lp;

	/* XXX - linear search doesn't scale with many links */
	for (lp = ihead; lp != NULL; lp = lp->nextp)
		if (lp->inum == statp->st_ino && lp->devnum == statp->st_dev) {
			lp->count--;
			return(lp);
		}

	lp = (struct linkbuf *) xmalloc(sizeof(*lp));
	lp->nextp = ihead;
	ihead = lp;
	lp->inum = statp->st_ino;
	lp->devnum = statp->st_dev;
	lp->count = statp->st_nlink - 1;
	lp->pathname = xstrdup(target);
	lp->src = xstrdup(source);
	if (Tdest)
		lp->target = xstrdup(Tdest);
	else
		lp->target = NULL;

	return(NULL);
}

/*
 * Send a hardlink
 */
static int sendhardlink(opts, lp, rname, destdir)
	opt_t opts;
	struct linkbuf *lp;
	char *rname;
	int destdir;
{
	static char buff[MAXPATHLEN];
	char *lname;	/* name of file to link to */

	debugmsg(DM_MISC, 
	       "sendhardlink: rname='%s' pathname='%s' src='%s' target='%s'\n",
		 rname, lp->pathname ? lp->pathname : "(null)", lp->src
		 ? lp->src : "(null)", lp->target ? lp->target : "(null)");
		 
	if (lp->target == NULL)
		(void) sendcmd(C_RECVHARDLINK, "%o %s %s", 
			       opts, lp->pathname, rname);
	else {
		lname = buff;
		strcpy(lname, remfilename(lp->src, lp->target, 
					  lp->pathname, rname, 
					  destdir));
		debugmsg(DM_MISC, "sendhardlink: lname=%s\n", lname);
		(void) sendcmd(C_RECVHARDLINK, "%o %s %s", 
			       opts, lname, rname);
	}

	return(response());
}

/*
 * Send a file
 */
static int sendfile(rname, opts, stb, user, group, destdir)
	char *rname;
	opt_t opts;
	struct stat *stb;
	char *user, *group;
	int destdir;
{
	int goterr, f;
	off_t i;

	if (stb->st_nlink > 1) {
		struct linkbuf *lp;
		
		if ((lp = linkinfo(stb)) != NULL)
			return(sendhardlink(opts, lp, rname, destdir));
	}

	if ((f = open(target, O_RDONLY)) < 0) {
		error("%s: open for read failed: %s", target, SYSERR);
		return(-1);
	}

	/*
	 * Send file info
	 */
	(void) sendcmd(C_RECVREG, "%o %04o %ld %ld %ld %s %s %s", 
		       opts, stb->st_mode & 07777, 
		       (long) stb->st_size, 
		       stb->st_mtime, stb->st_atime,
		       user, group, rname);
	if (response() < 0) {
		(void) close(f);
		return(-1);
	}

	debugmsg(DM_MISC, "Send file '%s' %d bytes\n", 
		 rname, (long) stb->st_size);

	/*
	 * Set remote time out alarm handler.
	 */
	(void) signal(SIGALRM, sighandler);

	/*
	 * Actually transfer the file
	 */
	goterr = 0;
	for (i = 0; i < stb->st_size; i += BUFSIZ) {
		int amt = BUFSIZ;

		(void) alarm(rtimeout);
		if (i + amt > stb->st_size)
			amt = stb->st_size - i;
		if (read(f, buf, amt) != amt) {
			error("%s: File changed size", target);
			err();
			++goterr;
			/*
			 * XXX - We have to keep going because the
			 * server expects to receive a fixed number
			 * of bytes that we specified as the file size.
			 * We need Out Of Band communication to handle
			 * this situation gracefully.
			 */
		}
		if (xwrite(rem_w, buf, amt) < 0) {
		    	error("%s: Error writing to client: %s", 
			      target, SYSERR);
			err();
			++goterr;
			break;
		}
		(void) alarm(0);
	}

	(void) alarm(0);	/* Insure alarm is off */
	(void) close(f);

	debugmsg(DM_MISC, "Send file '%s' %s.\n", 
		 (goterr) ? "failed" : "complete", rname);

	/*
	 * Check for errors and end send
	 */
	if (goterr)
		return(-1);
	else {
		ack();
		f = response();
		if (f < 0)
			return(-1);
		else if (f == 0 && IS_ON(opts, DO_COMPARE))
			return(0);

		runspecial(target, opts, rname, destdir);
		addcmdspecialfile(target, rname, destdir);

		return(0);
	}
}

/*
 * Check for files on the machine being updated that are not on the master
 * machine and remove them.
 *
 * Return < 0 on error.
 * Return 0 if nothing happened.
 * Return > 0 if anything is updated.
 */
static int rmchk(opts)
	opt_t opts;
{
	u_char *s;
	struct stat stb;
	int didupdate = 0;
	int n;

	debugmsg(DM_CALL, "rmchk()\n");

	/*
	 * Tell the remote to clean the files from the last directory sent.
	 */
	(void) sendcmd(C_CLEAN, "%o", IS_ON(opts, DO_VERIFY));
	if (response() < 0)
		return(-1);

	for ( ; ; ) {
		n = remline(s = respbuff, sizeof(respbuff), TRUE);
		if (n <= 0) {
			error("rmchk: unexpected control record");
			return(didupdate);
		}

		switch (*s++) {
		case CC_QUERY: /* Query if file should be removed */
			/*
			 * Return the following codes to remove query.
			 * CC_NO -- file exists - DON'T remove.
			 * CC_YES -- file doesn't exist - REMOVE.
			 */
			(void) sprintf(ptarget, "%s%s", 
				       (ptarget[-1] == '/' ? "" : "/"), s);
			debugmsg(DM_MISC, "check %s\n", target);
			if (except(target))
				(void) sendcmd(CC_NO, NULL);
			else if (lstat(target, &stb) < 0) {
				if (sendcmd(CC_YES, NULL) == 0)
					didupdate = 1;
			} else
				(void) sendcmd(CC_NO, NULL);
			break;

		case CC_END:
			*ptarget = CNULL;
			ack();
			return(didupdate);

		case C_LOGMSG:
			if (n > 0)
				message(MT_INFO, "%s", s);
			break;

		case C_NOTEMSG:
			if (n > 0)
				message(MT_NOTICE, "%s", s);
			break;
			/* Goto top of loop */

		case C_ERRMSG:
			message(MT_NERROR, "%s", s);
			return(didupdate);

		case C_FERRMSG:
			message(MT_FERROR, "%s", s);
			finish();

		default:
			error("rmchk: unexpected response '%s'", respbuff);
			err();
		}
	}
	/*NOTREACHED*/
}

/*
 * Send a directory
 *
 * Return < 0 on error.
 * Return 0 if nothing happened.
 * Return > 0 if anything is updated.
 */
static int senddir(rname, opts, stb, user, group, destdir)
	char *rname;
	opt_t opts;
	struct stat *stb;
	char *user, *group;
	int destdir;
{
	DIRENTRY *dp;
	DIR *d;
	char *optarget, *cp;
	int len;
	int didupdate = 0;

	/*
	 * Don't descend into directory
	 */
	if (IS_ON(opts, DO_NODESCEND))
		return(0);

	if ((d = opendir(target)) == NULL) {
		error("%s: opendir failed: %s", target, SYSERR);
		return(-1);
	}

	/*
	 * Send recvdir command in recvit() format.
	 */
	(void) sendcmd(C_RECVDIR, "%o %04o 0 0 0 %s %s %s", 
		       opts, stb->st_mode & 07777, user, group, rname);
	if (response() < 0)
		return(-1);

	if (IS_ON(opts, DO_REMOVE))
		if (rmchk(opts) > 0)
			++didupdate;
	
	optarget = ptarget;
	len = ptarget - target;
	while ((dp = readdir(d))) {
		if (!strcmp(dp->d_name, ".") ||
		    !strcmp(dp->d_name, ".."))
			continue;
		if (len + 1 + (int) strlen(dp->d_name) >= MAXPATHLEN - 1) {
			error("%s/%s: Name too long", target,
			      dp->d_name);
			continue;
		}
		ptarget = optarget;
		if (ptarget[-1] != '/')
			*ptarget++ = '/';
		cp = dp->d_name;
		while ((*ptarget++ = *cp++))
			;
		ptarget--;
		if (sendit(dp->d_name, opts, destdir) > 0)
			didupdate = 1;
	}
	(void) closedir(d);

	(void) sendcmd(C_END, NULL);
	(void) response();

	ptarget = optarget;
	*ptarget = CNULL;

	return(didupdate);
}

/*
 * Send a link
 */
static int sendlink(rname, opts, stb, user, group, destdir)
	char *rname;
	opt_t opts;
	struct stat *stb;
	char *user;
	char *group;
	int destdir;
{
	int f, n;
	static char tbuf[BUFSIZ];
	char lbuf[MAXPATHLEN];
	u_char *s;

	debugmsg(DM_CALL, "sendlink(%s, %x, stb, %d)\n", rname, opts, destdir);

	if (stb->st_nlink > 1) {
		struct linkbuf *lp;
		
		if ((lp = linkinfo(stb)) != NULL)
			return(sendhardlink(opts, lp, rname, destdir));
	}

	/*
	 * Gather and send basic link info
	 */
	(void) sendcmd(C_RECVSYMLINK, "%o %04o %ld %ld %ld %s %s %s", 
		       opts, stb->st_mode & 07777, 
		       (long) stb->st_size, 
		       stb->st_mtime, stb->st_atime,
		       user, group, rname);
	if (response() < 0)
		return(-1);

	/*
	 * Gather and send additional link info
	 */
	if ((n = readlink(target, lbuf, sizeof(lbuf)-1)) != -1)
		lbuf[n] = '\0';
	else {
		error("%s: readlink failed", target);
		err();
	}
	(void) sprintf(tbuf, "%.*s", (int) stb->st_size, lbuf);
	(void) sendcmd(C_NONE, "%s\n", tbuf);

	if (n != stb->st_size) {
		error("%s: file changed size", target);
		err();
	} else
		ack();

	/*
	 * Check response
	 */
	f = response();
	if (f < 0)
		return(-1);
	else if (f == 0 && IS_ON(opts, DO_COMPARE))
		return(0);

	/*
	 * Read and process responses from server.
	 * The server may send multiple messages regarding
	 * file deletes if the remote target is a directory.
	 */
	for (;;) {
		n = remline(s = respbuff, sizeof(respbuff), TRUE);
		if (n == -1)	/* normal EOF */
			return(0);
		if (n == 0) {
			error("expected control record");
			continue;
		}
		
		switch (*s++) {
		case C_END:	/* End of send operation */
			*ptarget = CNULL;
			ack();
			runspecial(target, opts, rname, destdir);
			addcmdspecialfile(target, rname, destdir);
			return(0);
			
		case C_LOGMSG:
			if (n > 0)
				message(MT_INFO, "%s", s);
			break;

		case C_NOTEMSG:
			if (n > 0)
				message(MT_NOTICE, "%s", s);
			break;
			/* Goto top of loop */

		case C_ERRMSG:
			message(MT_NERROR, "%s", s);
			return(-1);

		case C_FERRMSG:
			message(MT_FERROR, "%s", s);
			finish();

		default:
			error("install link: unexpected response '%s'", 
			      respbuff);
			err();
		}
	}
	/*NOTREACHED*/
}

/*
 * Check to see if file needs to be updated on the remote machine.
 * Returns:
 * 	US_NOTHING	- no update
 *	US_NOENT	- remote doesn't exist
 *	US_OUTDATE	- out of date
 *	US_DOCOMP	- comparing binaries to determine if out of date
 *	US_MODE		- File modes do not match
 */
static int update(rname, opts, statp)
	char *rname;
	opt_t opts;
	struct stat *statp;
{
	off_t size;
	time_t mtime;
	unsigned short lmode;
	unsigned short rmode;
	char *owner = NULL, *group = NULL;
	int done, n;
	u_char *cp;

	debugmsg(DM_CALL, "update(%s, 0x%x, 0x%x)\n", rname, opts, statp);

	if (IS_ON(opts, DO_NOEXEC))
		if (isexec(target, statp)) {
			debugmsg(DM_MISC, "%s is an executable\n", target);
			return(US_NOTHING);
		}

	/*
	 * Check to see if the file exists on the remote machine.
	 */
	(void) sendcmd(C_QUERY, "%s", rname);

	for (done = 0; !done;) {
		n = remline(cp = respbuff, sizeof(respbuff), TRUE);
		if (n <= 0) {
			error("update: unexpected control record in response to query");
			return(US_NOTHING);
		}

		switch (*cp++) {
		case QC_ONNFS:  /* Resides on a NFS */
			debugmsg(DM_MISC,
				 "update: %s is on a NFS.  Skipping...\n", 
				 rname);
			return(US_NOTHING);

		case QC_SYM:  /* Is a symbolic link */
			debugmsg(DM_MISC,
				 "update: %s is a symlink.  Skipping...\n", 
				 rname);
			return(US_NOTHING);

		case QC_ONRO:  /* Resides on a Read-Only fs */
			debugmsg(DM_MISC,
				 "update: %s is on a RO fs.  Skipping...\n", 
				 rname);
			return(US_NOTHING);
			
		case QC_YES:
			done = 1;
			break;

		case QC_NO:  /* file doesn't exist so install it */
			return(US_NOENT);

		case C_ERRMSG:
			if (cp)
				message(MT_NERROR, "%s", cp);
			return(US_NOTHING);

		case C_FERRMSG:
			if (cp)
				message(MT_FERROR, "%s", cp);
			finish();

		case C_NOTEMSG:
			if (cp)
				message(MT_NOTICE, "%s", cp);
			break;
			/* Goto top of loop */

		default:
			error("update: unexpected response to query '%s'", cp);
			return(US_NOTHING);
		}
	}

	/*
	 * Target exists, but no other info passed
	 */
	if (n <= 1 || !S_ISREG(statp->st_mode))
		return(US_OUTDATE);

	if (IS_ON(opts, DO_COMPARE))
		return(US_DOCOMP);

	/*
	 * Parse size
	 */
	size = strtol(cp, (char **)&cp, 10);
	if (*cp++ != ' ') {
		error("update: size not delimited");
		return(US_NOTHING);
	}

	/*
	 * Parse mtime
	 */
	mtime = strtol(cp, (char **)&cp, 10);
	if (*cp++ != ' ') {
		error("update: mtime not delimited");
		return(US_NOTHING);
	}

	/*
	 * Parse remote file mode
	 */
	rmode = strtol(cp, (char **)&cp, 8);
	if (cp && *cp)
		++cp;

	/*
	 * Be backwards compatible
	 */
	if (cp && *cp != CNULL) {
		/*
		 * Parse remote file owner
		 */
		owner = strtok((char *)cp, " ");
		if (owner == NULL) {
			error("update: owner not delimited");
			return(US_NOTHING);
		}

		/*
		 * Parse remote file group
		 */
		group = strtok(NULL, " ");
		if (group == NULL) {
			error("update: group not delimited");
			return(US_NOTHING);
		}
	}

	/*
	 * File needs to be updated?
	 */
	lmode = statp->st_mode & 07777;

	debugmsg(DM_MISC, "update(%s,) local mode %04o remote mode %04o\n", 
		 rname, lmode, rmode);
	debugmsg(DM_MISC, "update(%s,) size %d mtime %d owner '%s' grp '%s'\n",
		 rname, (int) size, mtime, owner, group);

	if (statp->st_mtime != mtime) {
		if (statp->st_mtime < mtime && IS_ON(opts, DO_YOUNGER)) {
			message(MT_WARNING, 
				"%s: Warning: remote copy is newer",
				target);
			return(US_NOTHING);
		}
		return(US_OUTDATE);
	}

	/*
	 * If the mode of a file does not match the local mode, the
	 * whole file is updated.  This is done both to insure that
	 * a bogus version of the file has not been installed and to
	 * avoid having to handle weird cases of chmod'ing symlinks 
	 * and such.
	 */
	if (!IS_ON(opts, DO_NOCHKMODE) && lmode != rmode) {
		debugmsg(DM_MISC, "modes do not match (%04o != %04o).\n",
			 lmode, rmode);
		return(US_OUTDATE);
	}

	if (statp->st_size != size) {
		debugmsg(DM_MISC, "size does not match (%d != %d).\n",
			 (int) statp->st_size, size);
		return(US_OUTDATE);
	} 

	/*
	 * Check ownership
	 */
	if (!IS_ON(opts, DO_NOCHKOWNER) && owner) {
		if (!IS_ON(opts, DO_NUMCHKOWNER)) {
			/* Check by string compare */
			if (strcmp(owner, getusername(statp->st_uid, 
						      target, opts)) != 0) {
				debugmsg(DM_MISC, 
					 "owner does not match (%s != %s).\n",
					 getusername(statp->st_uid, 
						     target, opts), owner);
				return(US_OUTDATE);
			}
		} else {
			/* 
			 * Check numerically.
			 * Allow negative numbers.
			 */
			while (*owner && !isdigit(*owner) && (*owner != '-'))
				++owner;
			if (owner && atoi(owner) != statp->st_uid) {
				debugmsg(DM_MISC, 
					 "owner does not match (%d != %s).\n",
					 statp->st_uid, owner);
				return(US_OUTDATE);
			}
		}
	} 

	if (!IS_ON(opts, DO_NOCHKGROUP) && group) {
		if (!IS_ON(opts, DO_NUMCHKGROUP)) {
			/* Check by string compare */
			if (strcmp(group, getgroupname(statp->st_gid, 
						       target, opts)) != 0) {
				debugmsg(DM_MISC, 
					 "group does not match (%s != %s).\n",
					 getgroupname(statp->st_gid, 
						      target, opts), group);
				return(US_OUTDATE);
			}
		} else {	
			/* Check numerically */
			/* Allow negative gid */
			while (*group && !isdigit(*group) && (*group != '-'))
				++group;
			if (group && atoi(group) != statp->st_gid) {
				debugmsg(DM_MISC,
					 "group does not match (%d != %s).\n",
					 statp->st_gid, group);
				return(US_OUTDATE);
			}
		}
	}

	return(US_NOTHING);
}

/*
 * Stat a file
 */
static int dostat(file, statbuf, opts)
	char *file;
	struct stat *statbuf;
	opt_t opts;
{
	int s;

	if (IS_ON(opts, DO_FOLLOW))
		s = stat(file, statbuf);
	else
		s = lstat(file, statbuf);

	if (s < 0)
		error("%s: %s failed: %s", file,
		      IS_ON(opts, DO_FOLLOW) ? "stat" : "lstat", SYSERR);
	return(s);
}

/*
 * Transfer the file or directory in target[].
 * rname is the name of the file on the remote host.
 *
 * Return < 0 on error.
 * Return 0 if nothing happened.
 * Return > 0 if anything is updated.
 */
static int sendit(rname, opts, destdir)
	char *rname;
	opt_t opts;
	int destdir;
{
	static struct stat stb;
	extern struct subcmd *subcmds;
	char *user, *group;
	int u, len;
	int didupdate = 0;

	/*
	 * Remove possible accidental newline
	 */
	len = strlen(rname);
	if (len > 0 && rname[len-1] == '\n')
		rname[len-1] = CNULL;

	if (checkfilename(rname) != 0)
		return(-1);

	debugmsg(DM_CALL, "sendit(%s, 0x%x) called\n", rname, opts);

	if (except(target))
		return(0);

	if (dostat(target, &stb, opts) < 0)
		return(-1);

	/*
	 * Does rname need updating?
	 */
	u = update(rname, opts, &stb);
	debugmsg(DM_MISC, "sendit(%s, 0x%x): update status of %s is %d\n", 
		 rname, opts, target, u);

	/*
	 * Don't need to update the file, but we may need to save hardlink
	 * info.
	 */
	if (u == US_NOTHING) {
		if (S_ISREG(stb.st_mode) && stb.st_nlink > 1)
			(void) linkinfo(&stb);
		return(0);
	}

	/*
	 * File mode needs changing
	 */
	if (u == US_MODE) {
		if (IS_ON(opts, DO_VERIFY)) {
			message(MT_INFO, "%s: need to chmod to %04o",
				target, stb.st_mode & 07777);
			runspecial(target, opts, rname, destdir);
			return(1);
		}
		message(MT_CHANGE, "%s: chmod to %04o", 
			target, stb.st_mode & 07777);
		(void) sendcmd(C_CHMOD, "%o %04o %s",
			       opts, stb.st_mode & 07777, rname);
		(void) response();
		return(1);
	}

	user = getusername(stb.st_uid, target, opts);
	group = getgroupname(stb.st_gid, target, opts);

	/*
	 * No entry - need to install
	 */
	if (u == US_NOENT) {
		if (IS_ON(opts, DO_VERIFY)) {
			message(MT_INFO, "%s: need to install", target);
			runspecial(target, opts, rname, destdir);
			return(1);
		}
		if (!IS_ON(opts, DO_QUIET))
			message(MT_CHANGE, "%s: installing", target);
		FLAG_OFF(opts, (DO_COMPARE|DO_REMOVE));
	}

	/*
	 * Handle special file types, including directories and symlinks
	 */
	if (S_ISDIR(stb.st_mode)) {
		if (senddir(rname, opts, &stb, user, group, destdir) > 0)
			didupdate = 1;
	} else if (S_ISLNK(stb.st_mode)) {
		if (u != US_NOENT)
			FLAG_ON(opts, DO_COMPARE);
		/*
		 * Since we always send link info to the server
		 * so the server can determine if the remote link
		 * is correct, we never get any acknowledge meant
		 * from the server whether the link was really
		 * updated or not.
		 */
		(void) sendlink(rname, opts, &stb, user, group, destdir);
	} else if (S_ISREG(stb.st_mode)) {		
		if (u == US_OUTDATE) {
			if (IS_ON(opts, DO_VERIFY)) {
				message(MT_INFO, "%s: need to update", target);
				runspecial(target, opts, rname, destdir);
				return(1);
			}
			if (!IS_ON(opts, DO_QUIET))
				message(MT_CHANGE, "%s: updating", target);
		}
		if (sendfile(rname, opts, &stb, user, group, destdir) == 0)
			didupdate = 1;
	} else
		error("%s: unknown file type", target);

	return(didupdate);
}
	
/*
 * Remove temporary files and do any cleanup operations before exiting.
 */
extern void cleanup()
{
	char *file;
#ifdef USE_STATDB
	extern char statfile[];

	(void) unlink(statfile);
#endif

	if ((file = getnotifyfile()))
		(void) unlink(file);
}

/*
 * Update the file(s) if they are different.
 * destdir = 1 if destination should be a directory
 * (i.e., more than one source is being copied to the same destination).
 *
 * Return < 0 on error.
 * Return 0 if nothing updated.
 * Return > 0 if something was updated.
 */
extern int install(src, dest, ddir, destdir, opts)
	char *src, *dest;
 	int ddir, destdir;
	opt_t opts;
{
	static char destcopy[MAXPATHLEN];
	char *rname;
	int didupdate = 0;

	debugmsg(DM_CALL,
		"install(src=%s,dest=%s,ddir=%d,destdir=%d,opts=%d) start\n",
		(src?src:"NULL"), (dest?dest:"NULL"), ddir, destdir, opts);
	/*
	 * Save source name
	 */
	if (IS_ON(opts, DO_WHOLE))
		source[0] = CNULL;
	else
		(void) strcpy(source, src);

	if (dest == NULL) {
		FLAG_OFF(opts, DO_WHOLE); /* WHOLE only useful if renaming */
		dest = src;
	}

	if (checkfilename(dest) != 0)
		return(-1);

	if (nflag || debug) {
		static char buff[BUFSIZ];
		char *cp;

		cp = getondistoptlist(opts);
		(void) sprintf(buff, "%s%s%s %s %s", 
			       IS_ON(opts, DO_VERIFY) ? "verify" : "install",
			       (cp) ? " -o" : "", (cp) ? cp : "", 
			       src, dest);
		if (nflag) {
			printf("%s\n", buff);
			return(0);
		} else
			debugmsg(DM_MISC, "%s\n", buff);
	}

	rname = exptilde(target, src);
	if (rname == NULL)
		return(-1);
	ptarget = target;
	while (*ptarget)
		ptarget++;
	/*
	 * If we are renaming a directory and we want to preserve
	 * the directory heirarchy (-w), we must strip off the leading
	 * directory name and preserve the rest.
	 */
	if (IS_ON(opts, DO_WHOLE)) {
		while (*rname == '/')
			rname++;
		ddir = 1;
		destdir = 1;
	} else {
		rname = strrchr(target, '/');
		/* Check if no '/' or target ends in '/' */
		if (rname == NULL || 
		    rname+1 == NULL || 
		    *(rname+1) == CNULL)
			rname = target;
		else
			rname++;
	}

	debugmsg(DM_MISC, 
 	"install: target=%s src=%s rname=%s dest='%s' destdir=%d, ddir=%d\n", 
 		 target, source, rname, dest, destdir, ddir);

	/*
	 * Pass the destination file/directory name to remote.
	 */
 	if (ddir)
		(void) sendcmd(C_DIRTARGET, "%o %s", opts, dest);
	else
		(void) sendcmd(C_TARGET, "%o %s", opts, dest);
	if (response() < 0)
		return(-1);

	/*
	 * Save the name of the remote target destination if we are
	 * in WHOLE mode (destdir > 0) or if the source and destination
	 * are not the same.  This info will be used later for maintaining
	 * hardlink info.
	 */
	if (destdir || (src && dest && strcmp(src, dest))) {
		(void) strcpy(destcopy, dest);
		Tdest = destcopy;
	}

	didupdate = sendit(rname, opts, destdir);
	Tdest = 0;

	return(didupdate);
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.15 2003/04/07 21:13:52 deraadt Exp $	*/
d42 1
a42 1
"$OpenBSD: client.c,v 1.15 2003/04/07 21:13:52 deraadt Exp $";
d112 1
a112 1
			(void) snprintf(buff, sizeof buff, "%s/%s", dest, path);
d130 1
a130 2
				(void) snprintf(buff, sizeof buff,
				    "%s/%s", dest, cp);
d132 1
a132 2
				(void) snprintf(buff, sizeof buff,
				    "%s%s", dest, cp);
d135 1
a135 1
		strlcpy(lname, dest, buf + sizeof buff - lname);
d363 1
d374 5
a378 3
		strlcpy(buff, remfilename(lp->src, lp->target, 
		    lp->pathname, rname, destdir), sizeof buff);
		debugmsg(DM_MISC, "sendhardlink: lname=%s\n", buff);
d380 1
a380 1
			       opts, buff, rname);
d693 1
a693 1
	(void) snprintf(tbuf, sizeof tbuf, "%.*s", (int) stb->st_size, lbuf);
d1193 1
a1193 1
		(void) strlcpy(source, src, sizeof source);
d1208 1
a1208 1
		(void) snprintf(buff, sizeof buff, "%s%s%s %s %s", 
d1267 1
a1267 1
		(void) strlcpy(destcopy, dest, sizeof destcopy);
@


1.1.1.3
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.17 2003/05/06 22:10:11 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: client.c,v 1.17 2003/05/06 22:10:11 millert Exp $";
a221 1
		new->n_regex = NULL;
d528 2
a529 2
			snprintf(ptarget, target + sizeof(target) - ptarget,
			    "%s%s", (ptarget[-1] == '/' ? "" : "/"), s);
d1218 1
a1218 1
	rname = exptilde(target, src, sizeof(target));
@


1.1.1.4
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.18 2003/05/14 01:34:35 millert Exp $	*/
a35 3
#include "defs.h"
#include "y.tab.h"

d38 2
a39 2
static char RCSid[] __attribute__((__unused__)) = 
"$From: client.c,v 1.13 1999/11/01 00:22:14 christos Exp $";
d41 2
a42 2
static char RCSid[] __attribute__((__unused__)) = 
"$OpenBSD: client.c,v 1.18 2003/05/14 01:34:35 millert Exp $";
d45 1
a45 2
static char sccsid[] __attribute__((__unused__)) =
"@@(#)client.c";
d47 1
a47 1
static char copyright[] __attribute__((__unused__)) =
d56 2
d66 1
a66 1
#define US_CHMOG	4	/* Modes or ownership of file differ */
d77 1
a77 14
static void runspecial(char *, opt_t, char *, int);
static void addcmdspecialfile(char *, char *, int);
static void freecmdspecialfiles(void);
static struct linkbuf *linkinfo(struct stat *);
static int sendhardlink(opt_t, struct linkbuf *, char *, int);
static int sendfile(char *, opt_t, struct stat *, char *, char *, int);
static int rmchk(opt_t);
static int senddir(char *, opt_t, struct stat *, char *, char *, int);
static int sendlink(char *, opt_t, struct stat *, char *, char *, int);
static int update(char *, opt_t, struct stat *);
static int dostat(char *, struct stat *, opt_t);
static int statupdate(int, char *, opt_t, char *, int, struct stat *, char *, char *);
static int fullupdate(int, char *, opt_t, char *, int, struct stat *, char *, char *);
static int sendit(char *, opt_t, int);
d82 3
a84 2
char *
remfilename(char *src, char *dest, char *path, char *rname, int destdir)
d112 1
a112 1
			(void) snprintf(buff, sizeof(buff), "%s/%s", dest, path);
d130 2
a131 2
				(void) snprintf(buff, sizeof(buff), "%s/%s",
						dest, cp);
d133 2
a134 2
				(void) snprintf(buff, sizeof(buff), "%s%s",
						dest, cp);
d137 1
a137 1
		(void) strlcpy(lname, dest, buf + sizeof buff - lname);
d147 3
a149 2
int
inlist(struct namelist *list, char *file)
d162 5
a166 2
static void
runspecial(char *starget, opt_t opts, char *rname, int destdir)
d198 4
a201 2
static void
addcmdspecialfile(char *starget, char *rname, int destdir)
d231 1
a231 2
static void
freecmdspecialfiles(void)
d250 4
a253 2
void
runcmdspecial(struct cmd *cmd, opt_t opts)
d295 2
a296 2
int
checkfilename(char *name)
d313 2
a314 2
void
freelinkinfo(struct linkbuf *lp)
d328 2
a329 2
static struct linkbuf *
linkinfo(struct stat *statp)
d359 5
a363 2
static int
sendhardlink(opt_t opts, struct linkbuf *lp, char *rname, int destdir)
a365 2
	char *lname;	/* name of file to link to */
	char ername[MAXPATHLEN*4], elname[MAXPATHLEN*4];
d369 2
a370 2
		rname, lp->pathname ? lp->pathname : "",
		lp->src ? lp->src : "", lp->target ? lp->target : "");
d373 2
a374 1
		lname = lp->pathname;
d376 6
a381 10
		lname = buff;
		strlcpy(lname, remfilename(lp->src, lp->target, 
					  lp->pathname, rname, 
					  destdir), sizeof(buff));
		debugmsg(DM_MISC, "sendhardlink: lname=%s\n", lname);
	}
	ENCODE(elname, lname);
	ENCODE(ername, rname);
	(void) sendcmd(C_RECVHARDLINK, "%o %s %s", 
		       opts, elname, ername);
d389 6
a394 3
static int
sendfile(char *rname, opt_t opts, struct stat *stb, char *user,
	 char *group, int destdir)
a397 1
	char ername[MAXPATHLEN*4];
a413 2
	ENCODE(ername, rname);

d415 2
a416 1
		       opts, stb->st_mode & 07777, (long) stb->st_size, 
d418 1
a418 1
		       user, group, ername);
d424 2
a425 3

	debugmsg(DM_MISC, "Send file '%s' %ld bytes\n", rname,
		 (long) stb->st_size);
d437 1
a437 1
		off_t amt = BUFSIZ;
d442 1
a442 1
		if (read(f, buf, (size_t) amt) != (ssize_t) amt) {
d454 2
a455 2
		if (xwrite(rem_w, buf, (size_t) amt) < 0) {
			error("%s: Error writing to client: %s", 
d498 2
a499 2
static int
rmchk(opt_t opts)
a504 1
	char targ[MAXPATHLEN*4];
d529 2
a530 9
			if (DECODE(targ, (char *) s) == -1) {
				error("rmchk: cannot decode file");
				return(-1);
			}
			(void) snprintf(ptarget,
					sizeof(target) - (ptarget - target),
					"%s%s", 
				        (ptarget[-1] == '/' ? "" : "/"),
				        targ);
d580 6
a585 3
static int
senddir(char *rname, opt_t opts, struct stat *stb, char *user,
	char *group, int destdir)
d592 11
a602 1
	char ername[MAXPATHLEN*4];
a606 1
	ENCODE(ername, rname);
d608 1
a608 1
		       opts, stb->st_mode & 07777, user, group, ername);
a611 6
	/*
	 * Don't descend into directory
	 */
	if (IS_ON(opts, DO_NODESCEND))
		return(0);

a615 5
	if ((d = opendir(target)) == NULL) {
		error("%s: opendir failed: %s", target, SYSERR);
		return(-1);
	}

d618 1
a618 1
	while ((dp = readdir(d)) != NULL) {
d631 2
a632 2
		while ((*ptarget++ = *cp++) != '\0')
			continue;
d651 7
a657 3
static int
sendlink(char *rname, opt_t opts, struct stat *stb, char *user,
	 char *group, int destdir)
a662 1
	char ername[MAXPATHLEN*4];
a675 1
	ENCODE(ername, rname);
d677 2
a678 1
		       opts, stb->st_mode & 07777, (long) stb->st_size, 
d680 1
a680 1
		       user, group, ername);
d693 2
a694 3
	(void) snprintf(tbuf, sizeof(tbuf), "%.*s", (int) stb->st_size, lbuf);
	ENCODE(ername, tbuf);
	(void) sendcmd(C_NONE, "%s\n", ername);
d768 1
a768 1
 *	US_CHMOG	- File modes or ownership do not match
d770 4
a773 2
static int
update(char *rname, opt_t opts, struct stat *statp)
a781 1
	char ername[MAXPATHLEN*4];
d794 1
a794 2
	ENCODE(ername, rname);
	(void) sendcmd(C_QUERY, "%s", ername);
d846 1
a846 1
			error("update: unexpected response to query '%s'", respbuff);
d863 1
a863 1
	size = (off_t) strtol(cp, (char **)&cp, 10);
d915 2
a916 2
	debugmsg(DM_MISC, "update(%s,) size %ld mtime %d owner '%s' grp '%s'\n",
		 rname, (long) size, mtime, owner, group);
d928 7
a934 6
	if (statp->st_size != size) {
		debugmsg(DM_MISC, "size does not match (%ld != %ld).\n",
			 (long) statp->st_size, (long) size);
		return(US_OUTDATE);
	} 

d938 1
a938 1
		return(US_CHMOG);
d941 5
d959 1
a959 1
				return(US_CHMOG);
d966 1
a966 2
			while (*owner && !isdigit((unsigned char)*owner) &&
			    (*owner != '-'))
d968 1
a968 1
			if (owner && (UID_T) atoi(owner) != statp->st_uid) {
d972 1
a972 1
				return(US_CHMOG);
d986 1
a986 1
				return(US_CHMOG);
d991 1
a991 2
			while (*group && !isdigit((unsigned char) *group) &&
			    (*group != '-'))
d993 1
a993 1
			if (group && (UID_T) atoi(group) != statp->st_gid) {
d997 1
a997 1
				return(US_CHMOG);
d1008 4
a1011 2
static int
dostat(char *file, struct stat *statbuf, opt_t opts)
a1026 90
 * We need to just change file info.
 */
static int
statupdate(int u, char *target, opt_t opts, char *rname, int destdir,
	   struct stat *st, char *user, char *group)
{
	int rv = 0;
	char ername[MAXPATHLEN*4];
	int lmode = st->st_mode & 07777;

	if (u == US_CHMOG) {
		if (IS_ON(opts, DO_VERIFY)) {
			message(MT_INFO,
				"%s: need to change to perm %04o, owner %s, group %s",
				target, lmode, user, group);
			runspecial(target, opts, rname, destdir);
		}
		else {
			message(MT_CHANGE, "%s: change to perm %04o, owner %s, group %s", 
				target, lmode, user, group);
			ENCODE(ername, rname);
			(void) sendcmd(C_CHMOG, "%o %04o %s %s %s",
				       opts, lmode, user, group, ername);
			(void) response();
		}
		rv = 1;
	}
	return(rv);
}


/*
 * We need to install/update:
 */
static int
fullupdate(int u, char *target, opt_t opts, char *rname, int destdir,
	   struct stat *st, char *user, char *group)
{
	/*
	 * No entry - need to install
	 */
	if (u == US_NOENT) {
		if (IS_ON(opts, DO_VERIFY)) {
			message(MT_INFO, "%s: need to install", target);
			runspecial(target, opts, rname, destdir);
			return(1);
		}
		if (!IS_ON(opts, DO_QUIET))
			message(MT_CHANGE, "%s: installing", target);
		FLAG_OFF(opts, (DO_COMPARE|DO_REMOVE));
	}

	/*
	 * Handle special file types, including directories and symlinks
	 */
	if (S_ISDIR(st->st_mode)) {
		if (senddir(rname, opts, st, user, group, destdir) > 0)
			return(1);
		return(0);
	} else if (S_ISLNK(st->st_mode)) {
		if (u == US_NOENT)
			FLAG_ON(opts, DO_COMPARE);
		/*
		 * Since we always send link info to the server
		 * so the server can determine if the remote link
		 * is correct, we never get any acknowledge meant
		 * from the server whether the link was really
		 * updated or not.
		 */
		(void) sendlink(rname, opts, st, user, group, destdir);
		return(0);
	} else if (S_ISREG(st->st_mode)) {		
		if (u == US_OUTDATE) {
			if (IS_ON(opts, DO_VERIFY)) {
				message(MT_INFO, "%s: need to update", target);
				runspecial(target, opts, rname, destdir);
				return(1);
			}
			if (!IS_ON(opts, DO_QUIET))
				message(MT_CHANGE, "%s: updating", target);
		}
		return (sendfile(rname, opts, st, user, group, destdir) == 0);
	} else {
		message(MT_INFO, "%s: unknown file type 0%o", target,
			st->st_mode);
		return(0);
	}
}

/*
d1034 4
a1037 2
static int
sendit(char *rname, opt_t opts, int destdir)
d1040 1
d1043 1
d1080 18
d1101 13
a1113 2
	if (u == US_CHMOG && IS_OFF(opts, DO_UPDATEPERM))
		u = US_OUTDATE;
d1115 31
a1145 7
	if (u == US_NOENT || u == US_OUTDATE || u == US_DOCOMP)
		return(fullupdate(u, target, opts, rname, destdir, &stb,
				  user, group));

	if (u == US_CHMOG)
		return(statupdate(u, target, opts, rname, destdir, &stb,
				  user, group));
d1147 1
a1147 1
	return(0);
d1153 1
a1153 2
void
cleanup(int dummy)
d1162 1
a1162 1
	if ((file = getnotifyfile()) != NULL)
d1175 4
a1178 2
int
install(char *src, char *dest, int ddir, int destdir, opt_t opts)
a1182 1
	char ername[MAXPATHLEN*4];
d1193 1
a1193 1
		(void) strlcpy(source, src, sizeof(source));
d1208 1
a1208 1
		(void) snprintf(buff, sizeof(buff), "%s%s%s %s %s", 
a1252 1
	ENCODE(ername, dest);
d1254 1
a1254 1
		(void) sendcmd(C_DIRTARGET, "%o %s", opts, ername);
d1256 1
a1256 1
		(void) sendcmd(C_TARGET, "%o %s", opts, ername);
d1267 1
a1267 1
		(void) strlcpy(destcopy, dest, sizeof(destcopy));
@


1.1.1.5
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.19 2003/06/03 02:56:14 millert Exp $	*/
d15 5
a19 1
 * 3. Neither the name of the University nor the names of its contributors
d45 1
a45 1
"$OpenBSD: client.c,v 1.19 2003/06/03 02:56:14 millert Exp $";
@


