head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.5
	tg-mergefixes-1-branch:1.1.1.5.0.14
	tg-mergefixes-1-base:1.1.1.5
	MIROS_X:1.1.1.5.0.12
	MIROS_X_BASE:1.1.1.5
	tg-mergetmp-3:1.1.1.5
	MIRBSD_XP_MIRPPC:1.1.1.5.0.10
	MIRBSD_XP_SPARC_BASE:1.1.1.5
	MIRBSD_XP_SPARC:1.1.1.5.0.8
	MIRBSD_7quater:1.1.1.5
	cvs-200405160640:1.1.1.5
	cvs-200401271800:1.1.1.5
	cvs-200401261630:1.1.1.5
	cvs-200401021645:1.1.1.5
	MIRBSD_7_ALPHA:1.1.1.5.0.6
	MIRBSD_7:1.1.1.5.0.4
	cvs-200312222040:1.1.1.5
	MIRBSD_7ter:1.1.1.5
	MIRBSD_7_DEV:1.1.1.5.0.2
	cvs-200310020700:1.1.1.5
	cvs-200309271030:1.1.1.5
	cvs-200309261655:1.1.1.5
	cvs-200309251530:1.1.1.4
	cvs-200308302005:1.1.1.4
	cvs-200308171200:1.1.1.4
	ctm-3496:1.1.1.4
	ctm-3449:1.1.1.3
	ctm-3437:1.1.1.3
	cvs-200307191805:1.1.1.3
	ctm-3425:1.1.1.3
	cvs-200307091500:1.1.1.3
	ctm-3389:1.1.1.3
	cvs-200306291430:1.1.1.3
	ctm-3341:1.1.1.3
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.3
	ctm-3264:1.1.1.3
	cvs-200305071630:1.1.1.3
	MIRBSD_4:1.1.1.3
	ctm-3203:1.1.1.3
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.52.58;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.52.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.54.48;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.04.15.17.47.05;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.11.18.44.39;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.09.26.17.13.36;	author tg;	state Stab;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: screen.c,v 1.8 2001/11/19 19:02:14 mpech Exp $	*/

/*
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * Routines which deal with the characteristics of the terminal.
 * Uses termcap to be as terminal-independent as possible.
 *
 * {{ Maybe someday this should be rewritten to use curses or terminfo. }}
 */

#include "less.h"
#include "cmd.h"

#if HAVE_TERMIOS_H && HAVE_TERMIOS_FUNCS
#include <termios.h>
#if HAVE_SYS_IOCTL_H && !defined(TIOCGWINSZ)
#include <sys/ioctl.h>
#endif
#else
#if HAVE_TERMIO_H
#include <termio.h>
#else
#include <sgtty.h>
#if HAVE_SYS_IOCTL_H && (defined(TIOCGWINSZ) || defined(TCGETA) || defined(TIOCGETP) || defined(WIOCGETD))
#include <sys/ioctl.h>
#endif
#endif
#endif
#if HAVE_TERMCAP_H
#include <termcap.h>
#endif

#ifndef TIOCGWINSZ
/*
 * For the Unix PC (ATT 7300 & 3B1):
 * Since WIOCGETD is defined in sys/window.h, we can't use that to decide
 * whether to include sys/window.h.  Use SIGPHONE from sys/signal.h instead.
 */
#include <sys/signal.h>
#ifdef SIGPHONE
#include <sys/window.h>
#endif
#endif

#if HAVE_SYS_STREAM_H
#include <sys/stream.h>
#endif
#if HAVE_SYS_PTEM_H
#include <sys/ptem.h>
#endif

#if OS2
#define	DEFAULT_TERM		"ansi"
#else
#define	DEFAULT_TERM		"unknown"
#endif

/*
 * Strings passed to tputs() to do various terminal functions.
 */
static char
	*sc_pad,		/* Pad string */
	*sc_home,		/* Cursor home */
	*sc_addline,		/* Add line, scroll down following lines */
	*sc_lower_left,		/* Cursor to last line, first column */
	*sc_move,		/* General cursor positioning */
	*sc_clear,		/* Clear screen */
	*sc_eol_clear,		/* Clear to end of line */
	*sc_eos_clear,		/* Clear to end of screen */
	*sc_s_in,		/* Enter standout (highlighted) mode */
	*sc_s_out,		/* Exit standout mode */
	*sc_u_in,		/* Enter underline mode */
	*sc_u_out,		/* Exit underline mode */
	*sc_b_in,		/* Enter bold mode */
	*sc_b_out,		/* Exit bold mode */
	*sc_bl_in,		/* Enter blink mode */
	*sc_bl_out,		/* Exit blink mode */
	*sc_visual_bell,	/* Visual bell (flash screen) sequence */
	*sc_backspace,		/* Backspace cursor */
	*sc_s_keypad,		/* Start keypad mode */
	*sc_e_keypad,		/* End keypad mode */
	*sc_init,		/* Startup terminal initialization */
	*sc_deinit;		/* Exit terminal de-initialization */

static int init_done = 0;
static int tty_fd = -1;

public int auto_wrap;		/* Terminal does \r\n when write past margin */
public int ignaw;		/* Terminal ignores \n immediately after wrap */
public int erase_char, kill_char; /* The user's erase and line-kill chars */
public int werase_char;		/* The user's word-erase char */
public int sc_width, sc_height;	/* Height & width of screen */
public int bo_s_width, bo_e_width;	/* Printing width of boldface seq */
public int ul_s_width, ul_e_width;	/* Printing width of underline seq */
public int so_s_width, so_e_width;	/* Printing width of standout seq */
public int bl_s_width, bl_e_width;	/* Printing width of blink seq */
public int above_mem, below_mem;	/* Memory retained above/below screen */
public int can_goto_line;		/* Can move cursor to any line */

static char *cheaper();

/*
 * These two variables are sometimes defined in,
 * and needed by, the termcap library.
 */
#if MUST_DEFINE_OSPEED
extern short ospeed;	/* Terminal output baud rate */
extern char PC;		/* Pad character */
#endif

extern int quiet;		/* If VERY_QUIET, use visual bell for bell */
extern int know_dumb;		/* Don't complain about a dumb terminal */
extern int back_scroll;
extern int swindow;
extern int no_init;
extern int quit_at_eof;
extern int more_mode;
#if HILITE_SEARCH
extern int hilite_search;
#endif

extern char *tgetstr();
extern char *tgoto();


/*
 * Change terminal to "raw mode", or restore to "normal" mode.
 * "Raw mode" means 
 *	1. An outstanding read will complete on receipt of a single keystroke.
 *	2. Input is not echoed.  
 *	3. On output, \n is mapped to \r\n.
 *	4. \t is NOT expanded into spaces.
 *	5. Signal-causing characters such as ctrl-C (interrupt),
 *	   etc. are NOT disabled.
 * It doesn't matter whether an input \n is mapped to \r, or vice versa.
 */
	public void
raw_mode(on)
	int on;
{
	static int curr_on = 0;

	if (on == curr_on)
		return;

	if (tty_fd == -1 && (tty_fd = open("/dev/tty", O_RDWR)) < 0)
		tty_fd = 2;

#if OS2
	signal(SIGINT, SIG_IGN);
	erase_char = '\b';
	kill_char = '\033';
#else
#if HAVE_TERMIOS_H && HAVE_TERMIOS_FUNCS
    {
	struct termios s;
	static struct termios save_term;

	if (on) 
	{
		/*
		 * Get terminal modes.
		 */
		if (tcgetattr(tty_fd, &s) == -1)
			return;

		/*
		 * Save modes and set certain variables dependent on modes.
		 */
		save_term = s;
#if HAVE_OSPEED
		switch (cfgetospeed(&s))
		{
#ifdef B0
		case B0: ospeed = 0; break;
#endif
#ifdef B50
		case B50: ospeed = 1; break;
#endif
#ifdef B75
		case B75: ospeed = 2; break;
#endif
#ifdef B110
		case B110: ospeed = 3; break;
#endif
#ifdef B134
		case B134: ospeed = 4; break;
#endif
#ifdef B150
		case B150: ospeed = 5; break;
#endif
#ifdef B200
		case B200: ospeed = 6; break;
#endif
#ifdef B300
		case B300: ospeed = 7; break;
#endif
#ifdef B600
		case B600: ospeed = 8; break;
#endif
#ifdef B1200
		case B1200: ospeed = 9; break;
#endif
#ifdef B1800
		case B1800: ospeed = 10; break;
#endif
#ifdef B2400
		case B2400: ospeed = 11; break;
#endif
#ifdef B4800
		case B4800: ospeed = 12; break;
#endif
#ifdef B9600
		case B9600: ospeed = 13; break;
#endif
#ifdef EXTA
		case EXTA: ospeed = 14; break;
#endif
#ifdef EXTB
		case EXTB: ospeed = 15; break;
#endif
#ifdef B57600
		case B57600: ospeed = 16; break;
#endif
#ifdef B115200
		case B115200: ospeed = 17; break;
#endif
		default: ;
		}
#endif
		erase_char = s.c_cc[VERASE];
		kill_char = s.c_cc[VKILL];
#ifdef VWERASE
		werase_char = s.c_cc[VWERASE];
#else
		werase_char = 0;
#endif

		/*
		 * Set the modes to the way we want them.
		 */
		s.c_lflag &= ~(0
#ifdef ICANON
			| ICANON
#endif
#ifdef ECHO
			| ECHO
#endif
#ifdef ECHOE
			| ECHOE
#endif
#ifdef ECHOK
			| ECHOK
#endif
#if ECHONL
			| ECHONL
#endif
		);

		s.c_oflag |= (0
#ifdef XTABS
			| XTABS
#else
#ifdef TAB3
			| TAB3
#else
#ifdef OXTABS
			| OXTABS
#endif
#endif
#endif
#ifdef OPOST
			| OPOST
#endif
#ifdef ONLCR
			| ONLCR
#endif
		);

		s.c_oflag &= ~(0
#ifdef ONOEOT
			| ONOEOT
#endif
#ifdef OCRNL
			| OCRNL
#endif
#ifdef ONOCR
			| ONOCR
#endif
#ifdef ONLRET
			| ONLRET
#endif
		);
		s.c_cc[VMIN] = 1;
		s.c_cc[VTIME] = 0;
	} else
	{
		/*
		 * Restore saved modes.
		 */
		s = save_term;
	}
	if (tcsetattr(tty_fd, TCSANOW, &s) == -1)
		return;
    }
#else
#ifdef TCGETA
    {
	struct termio s;
	static struct termio save_term;

	if (on)
	{
		/*
		 * Get terminal modes.
		 */
		ioctl(tty_fd, TCGETA, &s);

		/*
		 * Save modes and set certain variables dependent on modes.
		 */
		save_term = s;
#if HAVE_OSPEED
		ospeed = s.c_cflag & CBAUD;
#endif
		erase_char = s.c_cc[VERASE];
		kill_char = s.c_cc[VKILL];
#ifdef VWERASE
		werase_char = s.c_cc[VWERASE];
#else
		werase_char = 0;
#endif

		/*
		 * Set the modes to the way we want them.
		 */
		s.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL);
		s.c_oflag |=  (OPOST|ONLCR|TAB3);
		s.c_oflag &= ~(OCRNL|ONOCR|ONLRET);
		s.c_cc[VMIN] = 1;
		s.c_cc[VTIME] = 0;
	} else
	{
		/*
		 * Restore saved modes.
		 */
		s = save_term;
	}
	ioctl(tty_fd, TCSETAW, &s);
    }
#else
    {
	struct sgttyb s;
	static struct sgttyb save_term;

	if (on)
	{
		/*
		 * Get terminal modes.
		 */
		ioctl(tty_fd, TIOCGETP, &s);

		/*
		 * Save modes and set certain variables dependent on modes.
		 */
		save_term = s;
#if HAVE_OSPEED
		ospeed = s.sg_ospeed;
#endif
		erase_char = s.sg_erase;
		kill_char = s.sg_kill;
		werase_char = 0;

		/*
		 * Set the modes to the way we want them.
		 */
		s.sg_flags |= CBREAK;
		s.sg_flags &= ~(ECHO|XTABS);
	} else
	{
		/*
		 * Restore saved modes.
		 */
		s = save_term;
	}
	ioctl(tty_fd, TIOCSETN, &s);
    }
#endif
#endif
#endif
	curr_on = on;
}

	static void
cannot(s)
	char *s;
{
	PARG parg;

	if (know_dumb || more_mode)
		/* 
		 * User knows this is a dumb terminal, so don't tell him.
		 * more doesn't complain about these, either.
		 */
		return;

	parg.p_string = s;
	error("WARNING: terminal cannot %s", &parg);
}

/*
 * Get size of the output screen.
 */
#if OS2
	public void
scrsize()
{
	int s[2];

	_scrsize(s);
	sc_width = s[0];
	sc_height = s[1];
}

#else

	public void
scrsize()
{
	char *s;
#ifdef TIOCGWINSZ
	struct winsize w;
#else
#ifdef WIOCGETD
	struct uwdata w;
#endif
#endif

	if (tty_fd == -1 && (tty_fd = open("/dev/tty", O_RDWR)) < 0)
		tty_fd = 2;

#ifdef TIOCGWINSZ
	if (ioctl(tty_fd, TIOCGWINSZ, &w) == 0 && w.ws_row > 0)
		sc_height = w.ws_row;
	else
#else
#ifdef WIOCGETD
	if (ioctl(tty_fd, WIOCGETD, &w) == 0 && w.uw_height > 0)
		sc_height = w.uw_height/w.uw_vs;
	else
#endif
#endif
	if ((s = getenv("LINES")) != NULL)
		sc_height = atoi(s);
	else
 		sc_height = tgetnum("li");

	if (sc_height <= 0)
		sc_height = 24;

#ifdef TIOCGWINSZ
 	if (ioctl(tty_fd, TIOCGWINSZ, &w) == 0 && w.ws_col > 0)
		sc_width = w.ws_col;
	else
#ifdef WIOCGETD
	if (ioctl(tty_fd, WIOCGETD, &w) == 0 && w.uw_width > 0)
		sc_width = w.uw_width/w.uw_hs;
	else
#endif
#endif
	if ((s = getenv("COLUMNS")) != NULL)
		sc_width = atoi(s);
	else
 		sc_width = tgetnum("co");

 	if (sc_width <= 0)
  		sc_width = 80;
}
#endif /* OS2 */

/*
 * Take care of the "variable" keys.
 * Certain keys send escape sequences which differ on different terminals
 * (such as the arrow keys, INSERT, DELETE, etc.)
 * Construct the commands based on these keys.
 */
	public void
get_editkeys()
{
	char *sp;
	char *s;
	char tbuf[40];

	static char kfcmdtable[400];
	int sz_kfcmdtable = 0;
	static char kecmdtable[400];
	int sz_kecmdtable = 0;

#define	put_cmd(str,action,tbl,sz) { \
	strcpy(tbl+sz, str);	\
	sz += strlen(str) + 1;	\
	tbl[sz++] = action; }
#define	put_esc_cmd(str,action,tbl,sz) { \
	tbl[sz++] = ESC; \
	put_cmd(str,action,tbl,sz); }

#define	put_fcmd(str,action)	put_cmd(str,action,kfcmdtable,sz_kfcmdtable)
#define	put_ecmd(str,action)	put_cmd(str,action,kecmdtable,sz_kecmdtable)
#define	put_esc_fcmd(str,action) put_esc_cmd(str,action,kfcmdtable,sz_kfcmdtable)
#define	put_esc_ecmd(str,action) put_esc_cmd(str,action,kecmdtable,sz_kecmdtable)

	/*
	 * Look at some interesting keys and see what strings they send.
	 * Create commands (both command keys and line-edit keys).
	 */

	/* RIGHT ARROW */
	sp = tbuf;
	if ((s = tgetstr("kr", &sp)) != NULL)
	{
		put_ecmd(s, EC_RIGHT);
		put_esc_ecmd(s, EC_W_RIGHT);
	}
	
	/* LEFT ARROW */
	sp = tbuf;
	if ((s = tgetstr("kl", &sp)) != NULL)
	{
		put_ecmd(s, EC_LEFT);
		put_esc_ecmd(s, EC_W_LEFT);
	}
	
	/* UP ARROW */
	sp = tbuf;
	if ((s = tgetstr("ku", &sp)) != NULL) 
	{
		put_ecmd(s, EC_UP);
		put_fcmd(s, A_B_LINE);
	}
		
	/* DOWN ARROW */
	sp = tbuf;
	if ((s = tgetstr("kd", &sp)) != NULL) 
	{
		put_ecmd(s, EC_DOWN);
		put_fcmd(s, A_F_LINE);
	}

	/* PAGE UP */
	sp = tbuf;
	if ((s = tgetstr("kP", &sp)) != NULL) 
	{
		put_fcmd(s, A_B_SCREEN);
	}

	/* PAGE DOWN */
	sp = tbuf;
	if ((s = tgetstr("kN", &sp)) != NULL) 
	{
		put_fcmd(s, A_F_SCREEN);
	}
	
	/* HOME */
	sp = tbuf;
	if ((s = tgetstr("kh", &sp)) != NULL) 
	{
		put_ecmd(s, EC_HOME);
	}

	/* END */
	sp = tbuf;
	if ((s = tgetstr("@@7", &sp)) != NULL) 
	{
		put_ecmd(s, EC_END);
	}

	/* DELETE */
	sp = tbuf;
	if ((s = tgetstr("kD", &sp)) == NULL) 
	{
		/* Use DEL (\177) if no "kD" termcap. */
		tbuf[1] = '\177';
		tbuf[2] = '\0';
		s = tbuf+1;
	}
	put_ecmd(s, EC_DELETE);
	put_esc_ecmd(s, EC_W_DELETE);
		
	/* BACKSPACE */
	tbuf[0] = ESC;
	tbuf[1] = erase_char;
	tbuf[2] = '\0';
	put_ecmd(tbuf, EC_W_BACKSPACE);

	if (werase_char != 0)
	{
		tbuf[0] = werase_char;
		tbuf[1] = '\0';
		put_ecmd(tbuf, EC_W_BACKSPACE);
	}

	/*
	 * Register the two tables.
	 */
	add_fcmd_table(kfcmdtable, sz_kfcmdtable);
	add_ecmd_table(kecmdtable, sz_kecmdtable);
}

#if DEBUG
	static void
get_debug_term()
{
	auto_wrap = 1;
	ignaw = 1;
	so_s_width = so_e_width = 0;
	bo_s_width = bo_e_width = 0;
	ul_s_width = ul_e_width = 0;
	bl_s_width = bl_e_width = 0;
	sc_s_keypad =	"(InitKey)";
	sc_e_keypad =	"(DeinitKey)";
	sc_init =	"(InitTerm)";
	sc_deinit =	"(DeinitTerm)";
	sc_eol_clear =	"(ClearEOL)";
	sc_eos_clear =	"(ClearEOS)";
	sc_clear =	"(ClearScreen)";
	sc_move =	"(Move<%d,%d>)";
	sc_s_in =	"(SO+)";
	sc_s_out =	"(SO-)";
	sc_u_in =	"(UL+)";
	sc_u_out =	"(UL-)";
	sc_b_in =	"(BO+)";
	sc_b_out =	"(BO-)";
	sc_bl_in =	"(BL+)";
	sc_bl_out =	"(BL-)";
	sc_visual_bell ="(VBell)";
	sc_backspace =	"(BS)";
	sc_home =	"(Home)";
	sc_lower_left =	"(LL)";
	sc_addline =	"(AddLine)";
}
#endif

/*
 * Get terminal capabilities via termcap.
 */
	public void
get_term()
{
	char *sp;
	char *t1, *t2;
	int hard;
	char *term;
	char termbuf[2048];

	static char sbuf[1024];

#ifdef OS2
	/*
	 * Make sure the termcap database is available.
	 */
	sp = getenv("TERMCAP");
	if (sp == NULL || *sp == '\0')
	{
		char *termcap;
		if ((sp = homefile("termcap.dat")) != NULL)
		{
			termcap = (char *) ecalloc(strlen(sp)+9, sizeof(char));
			sprintf(termcap, "TERMCAP=%s", sp);
			free(sp);
			putenv(termcap);
		}
	}
#endif
	/*
	 * Find out what kind of terminal this is.
	 */
 	if ((term = getenv("TERM")) == NULL)
 		term = DEFAULT_TERM;
 	if (tgetent(termbuf, term) <= 0)
 		strcpy(termbuf, "dumb:hc:");

 	hard = tgetflag("hc");

	/*
	 * Get size of the screen.
	 */
	scrsize();
	pos_init();

#if DEBUG
	if (strncmp(term,"LESSDEBUG",9) == 0)
	{
		get_debug_term();
		return;
	}
#endif /* DEBUG */

	auto_wrap = tgetflag("am");
	ignaw = tgetflag("xn");
	above_mem = tgetflag("da");
	below_mem = tgetflag("db");

	/*
	 * Assumes termcap variable "sg" is the printing width of:
	 * the standout sequence, the end standout sequence,
	 * the underline sequence, the end underline sequence,
	 * the boldface sequence, and the end boldface sequence.
	 */
	if ((so_s_width = tgetnum("sg")) < 0)
		so_s_width = 0;
	so_e_width = so_s_width;

	bo_s_width = bo_e_width = so_s_width;
	ul_s_width = ul_e_width = so_s_width;
	bl_s_width = bl_e_width = so_s_width;

#if HILITE_SEARCH
	if (so_s_width > 0 || so_e_width > 0)
		/*
		 * Disable highlighting by default on magic cookie terminals.
		 * Turning on highlighting might change the displayed width
		 * of a line, causing the display to get messed up.
		 * The user can turn it back on with -g, 
		 * but she won't like the results.
		 */
		hilite_search = 0;
#endif

	/*
	 * Get various string-valued capabilities.
	 */
	sp = sbuf;

#if HAVE_OSPEED
	sc_pad = tgetstr("pc", &sp);
	if (sc_pad != NULL)
		PC = *sc_pad;
#endif

	sc_s_keypad = tgetstr("ks", &sp);
	if (sc_s_keypad == NULL)
		sc_s_keypad = "";
	sc_e_keypad = tgetstr("ke", &sp);
	if (sc_e_keypad == NULL)
		sc_e_keypad = "";
		
	/*
	 * This loses for terminals with termcap entries with ti/te strings
	 * that switch to/from an alternate screen, and we're in quit_at_eof
	 * (eg, more(1)).
	 */
	if (!quit_at_eof && !more_mode) {
		sc_init = tgetstr("ti", &sp);
		sc_deinit = tgetstr("te", &sp);
	}
	if (sc_init == NULL)
		sc_init = "";
	if (sc_deinit == NULL)
		sc_deinit = "";

	sc_eol_clear = tgetstr("ce", &sp);
	if (hard || sc_eol_clear == NULL || *sc_eol_clear == '\0')
	{
		cannot("clear to end of line");
		sc_eol_clear = "";
	}

	sc_eos_clear = tgetstr("cd", &sp);
	if (below_mem && 
		(hard || sc_eos_clear == NULL || *sc_eos_clear == '\0'))
	{
		cannot("clear to end of screen");
		sc_eol_clear = "";
	}

	sc_clear = tgetstr("cl", &sp);
	if (hard || sc_clear == NULL || *sc_clear == '\0')
	{
		cannot("clear screen");
		sc_clear = "\n\n";
	}

	sc_move = tgetstr("cm", &sp);
	if (hard || sc_move == NULL || *sc_move == '\0')
	{
		/*
		 * This is not an error here, because we don't 
		 * always need sc_move.
		 * We need it only if we don't have home or lower-left.
		 */
		sc_move = "";
		can_goto_line = 0;
	} else
		can_goto_line = 1;

	sc_s_in = tgetstr("so", &sp);
	if (hard || sc_s_in == NULL)
		sc_s_in = "";

	sc_s_out = tgetstr("se", &sp);
	if (hard || sc_s_out == NULL)
		sc_s_out = "";

	sc_u_in = tgetstr("us", &sp);
	if (hard || sc_u_in == NULL)
		sc_u_in = sc_s_in;

	sc_u_out = tgetstr("ue", &sp);
	if (hard || sc_u_out == NULL)
		sc_u_out = sc_s_out;

	sc_b_in = tgetstr("md", &sp);
	if (hard || sc_b_in == NULL)
	{
		sc_b_in = sc_s_in;
		sc_b_out = sc_s_out;
	} else
	{
		sc_b_out = tgetstr("me", &sp);
		if (hard || sc_b_out == NULL)
			sc_b_out = "";
	}

	sc_bl_in = tgetstr("mb", &sp);
	if (hard || sc_bl_in == NULL)
	{
		sc_bl_in = sc_s_in;
		sc_bl_out = sc_s_out;
	} else
	{
		sc_bl_out = tgetstr("me", &sp);
		if (hard || sc_bl_out == NULL)
			sc_bl_out = "";
	}

	sc_visual_bell = tgetstr("vb", &sp);
	if (hard || sc_visual_bell == NULL)
		sc_visual_bell = "";

	if (tgetflag("bs"))
		sc_backspace = "\b";
	else
	{
		sc_backspace = tgetstr("bc", &sp);
		if (sc_backspace == NULL || *sc_backspace == '\0')
			sc_backspace = "\b";
	}

	/*
	 * Choose between using "ho" and "cm" ("home" and "cursor move")
	 * to move the cursor to the upper left corner of the screen.
	 */
	t1 = tgetstr("ho", &sp);
	if (hard || t1 == NULL)
		t1 = "";
	if (*sc_move == '\0')
		t2 = "";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, 0));
		t2 = sp;
		sp += strlen(sp) + 1;
	}
	sc_home = cheaper(t1, t2, "home cursor", "|\b^");

	/*
	 * Choose between using "ll" and "cm"  ("lower left" and "cursor move")
	 * to move the cursor to the lower left corner of the screen.
	 */
	t1 = tgetstr("ll", &sp);
	if (hard || t1 == NULL)
		t1 = "";
	if (*sc_move == '\0')
		t2 = "";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, sc_height-1));
		t2 = sp;
		sp += strlen(sp) + 1;
	}
	sc_lower_left = cheaper(t1, t2,
		"move cursor to lower left of screen", "\r");

	/*
	 * Choose between using "al" or "sr" ("add line" or "scroll reverse")
	 * to add a line at the top of the screen.
	 */
	t1 = tgetstr("al", &sp);
	if (hard || t1 == NULL)
		t1 = "";
	t2 = tgetstr("sr", &sp);
	if (hard || t2 == NULL)
		t2 = "";
#if OS2
	if (*t1 == '\0' && *t2 == '\0')
		sc_addline = "";
	else
#endif
	if (above_mem)
		sc_addline = t1;
	else
		sc_addline = cheaper(t1, t2, "scroll backwards", "");
	if (*sc_addline == '\0')
	{
		/*
		 * Force repaint on any backward movement.
		 */
		back_scroll = 0;
	}
}

/*
 * Return the cost of displaying a termcap string.
 * We use the trick of calling tputs, but as a char printing function
 * we give it inc_costcount, which just increments "costcount".
 * This tells us how many chars would be printed by using this string.
 * {{ Couldn't we just use strlen? }}
 */
static int costcount;

/*ARGSUSED*/
	static int
inc_costcount(c)
	int c;
{
	costcount++;
	return (c);
}

	static int
cost(t)
	char *t;
{
	costcount = 0;
	tputs(t, sc_height, inc_costcount);
	return (costcount);
}

/*
 * Return the "best" of the two given termcap strings.
 * The best, if both exist, is the one with the lower 
 * cost (see cost() function).
 */
	static char *
cheaper(t1, t2, doit, def)
	char *t1, *t2;
	char *doit;
	char *def;
{
	if (*t1 == '\0' && *t2 == '\0')
	{
		cannot(doit);
		return (def);
	}
	if (*t1 == '\0')
		return (t2);
	if (*t2 == '\0')
		return (t1);
	if (cost(t1) < cost(t2))
		return (t1);
	return (t2);
}


/*
 * Below are the functions which perform all the 
 * terminal-specific screen manipulation.
 */


/*
 * Initialize terminal
 */
	public void
init()
{
	if (no_init)
		return;
	tputs(sc_init, sc_height, putchr);
	tputs(sc_s_keypad, sc_height, putchr);
	init_done = 1;
}

/*
 * Deinitialize terminal
 */
	public void
deinit()
{
	if (no_init)
		return;
	if (!init_done)
		return;
	tputs(sc_e_keypad, sc_height, putchr);
	tputs(sc_deinit, sc_height, putchr);
	init_done = 0;
}

/*
 * Home cursor (move to upper left corner of screen).
 */
	public void
home()
{
	tputs(sc_home, 1, putchr);
}

/*
 * Add a blank line (called with cursor at home).
 * Should scroll the display down.
 */
	public void
add_line()
{
	tputs(sc_addline, sc_height, putchr);
}

/*
 * Move cursor to lower left corner of screen.
 */
	public void
lower_left()
{
	tputs(sc_lower_left, 1, putchr);
}

/*
 * Goto a specific line on the screen.
 */
	public void
goto_line(slinenum)
	int slinenum;
{
	char *sc_goto;

	sc_goto = tgoto(sc_move, 0, slinenum);
	tputs(sc_goto, 1, putchr);
}

/*
 * Ring the terminal bell.
 */
	public void
bell()
{
	if (quiet == VERY_QUIET)
		vbell();
	else
		putchr('\7');
}

/*
 * Output the "visual bell", if there is one.
 */
	public void
vbell()
{
	if (*sc_visual_bell == '\0')
		return;
	tputs(sc_visual_bell, sc_height, putchr);
}

/*
 * Clear the screen.
 */
	public void
clear()
{
	tputs(sc_clear, sc_height, putchr);
}

/*
 * Clear from the cursor to the end of the cursor's line.
 * {{ This must not move the cursor. }}
 */
	public void
clear_eol()
{
	tputs(sc_eol_clear, 1, putchr);
}

/*
 * Clear the bottom line of the display.
 * Leave the cursor at the beginning of the bottom line.
 */
	public void
clear_bot()
{
	lower_left();
	if (below_mem)
		tputs(sc_eos_clear, 1, putchr);
	else
		tputs(sc_eol_clear, 1, putchr);
}

/*
 * Begin "standout" (bold, underline, or whatever).
 */
	public void
so_enter()
{
	tputs(sc_s_in, 1, putchr);
}

/*
 * End "standout".
 */
	public void
so_exit()
{
	tputs(sc_s_out, 1, putchr);
}

/*
 * Begin "underline" (hopefully real underlining, 
 * otherwise whatever the terminal provides).
 */
	public void
ul_enter()
{
	tputs(sc_u_in, 1, putchr);
}

/*
 * End "underline".
 */
	public void
ul_exit()
{
	tputs(sc_u_out, 1, putchr);
}

/*
 * Begin "bold"
 */
	public void
bo_enter()
{
	tputs(sc_b_in, 1, putchr);
}

/*
 * End "bold".
 */
	public void
bo_exit()
{
	tputs(sc_b_out, 1, putchr);
}

/*
 * Begin "blink"
 */
	public void
bl_enter()
{
	tputs(sc_bl_in, 1, putchr);
}

/*
 * End "blink".
 */
	public void
bl_exit()
{
	tputs(sc_bl_out, 1, putchr);
}

/*
 * Erase the character to the left of the cursor 
 * and move the cursor left.
 */
	public void
backspace()
{
	/* 
	 * Try to erase the previous character by overstriking with a space.
	 */
	tputs(sc_backspace, 1, putchr);
	putchr(' ');
	tputs(sc_backspace, 1, putchr);
}

/*
 * Output a plain backspace, without erasing the previous char.
 */
	public void
putbs()
{
	tputs(sc_backspace, 1, putchr);
}
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.c,v 1.10 2003/04/06 23:38:07 deraadt Exp $	*/
d693 2
a694 3
			size_t l = strlen(sp)+9;
			termcap = (char *) ecalloc(l, sizeof(char));
			snprintf(termcap, l, "TERMCAP=%s", sp);
d706 1
a706 1
 		strlcpy(termbuf, "dumb:hc:", sizeof termbuf);
d886 1
a886 1
		strlcpy(sp, tgoto(sc_move, 0, 0), sbuf + sizeof sbuf - sp);
d903 1
a903 1
		strlcpy(sp, tgoto(sc_move, 0, sc_height-1), sbuf + sizeof sbuf - sp);
@


1.1.1.3
log
@Import OpenBSD source with the "new" command line as well,
in order to be able to provide a MirBSD release which bases
upon a fairly current OpenBSD base source code tree deemed
stable enough.
@
text
@d1 2
d4 2
a5 1
 * Copyright (C) 1984-2002  Mark Nudelman
d7 8
a14 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d16 11
a26 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d33 2
a39 21
#if MSDOS_COMPILER
#include "pckeys.h"
#if MSDOS_COMPILER==MSOFTC
#include <graph.h>
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
#include <conio.h>
#if MSDOS_COMPILER==DJGPPC
#include <pc.h>
extern int fd0;
#endif
#else
#if MSDOS_COMPILER==WIN32C
#include <windows.h>
#endif
#endif
#endif
#include <time.h>

#else

a48 3
#if HAVE_SGSTAT_H
#include <sgstat.h>
#else
a49 1
#endif
a54 1

d58 10
a67 2
#ifdef _OSK
#include <signal.h>
a68 3
#if OS2
#include <sys/signal.h>
#include "pckeys.h"
d70 1
a77 12
#endif /* MSDOS_COMPILER */

/*
 * Check for broken termios package that forces you to manually
 * set the line discipline.
 */
#ifdef __ultrix__
#define MUST_SET_LINE_DISCIPLINE 1
#else
#define MUST_SET_LINE_DISCIPLINE 0
#endif

a79 1
static char *windowid;
a83 63
#if MSDOS_COMPILER==MSOFTC
static int videopages;
static long msec_loops;
static int flash_created = 0;
#define	SETCOLORS(fg,bg)	{ _settextcolor(fg); _setbkcolor(bg); }
#endif

#if MSDOS_COMPILER==BORLANDC
static unsigned short *whitescreen;
static int flash_created = 0;
#endif
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
#define _settextposition(y,x)   gotoxy(x,y)
#define _clearscreen(m)         clrscr()
#define _outtext(s)             cputs(s)
#define	SETCOLORS(fg,bg)	{ textcolor(fg); textbackground(bg); }
extern int sc_height;
#endif

#if MSDOS_COMPILER==WIN32C
struct keyRecord
{
	int ascii;
	int scan;
} currentKey;

static int keyCount = 0;
static WORD curr_attr;
static int pending_scancode = 0;
static WORD *whitescreen;

static HANDLE con_out_save = INVALID_HANDLE_VALUE; /* previous console */
static HANDLE con_out_ours = INVALID_HANDLE_VALUE; /* our own */
HANDLE con_out = INVALID_HANDLE_VALUE;             /* current console */

extern int quitting;
static void win32_init_term();
static void win32_deinit_term();

#define FG_COLORS       (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY)
#define BG_COLORS       (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE | BACKGROUND_INTENSITY)
#define	MAKEATTR(fg,bg)		((WORD)((fg)|((bg)<<4)))
#define	SETCOLORS(fg,bg)	{ curr_attr = MAKEATTR(fg,bg); \
				if (SetConsoleTextAttribute(con_out, curr_attr) == 0) \
				error("SETCOLORS failed"); }
#endif

#if MSDOS_COMPILER
public int nm_fg_color;		/* Color of normal text */
public int nm_bg_color;
public int bo_fg_color;		/* Color of bold text */
public int bo_bg_color;
public int ul_fg_color;		/* Color of underlined text */
public int ul_bg_color;
public int so_fg_color;		/* Color of standout text */
public int so_bg_color;
public int bl_fg_color;		/* Color of blinking text */
public int bl_bg_color;
static int sy_fg_color;		/* Color of system text (before less) */
static int sy_bg_color;

#else

a109 1
#endif
d112 1
a124 4
public int clear_bg;		/* Clear fills with background color */
public int missing_cap = 0;	/* Some capability is missing */

static int attrmode = AT_NORMAL;
a125 1
#if !MSDOS_COMPILER
a126 2
static void tmodes();
#endif
a135 4
#ifdef _OSK
short ospeed;
char PC_, *UP, *BC;
#endif
d138 2
a139 1
extern int no_back_scroll;
a141 5
extern int no_keypad;
extern int sigs;
extern int wscroll;
extern int screen_trashed;
extern int tty;
d143 1
a143 1
extern int ismore;
d171 9
a183 1
	static int saved_term = 0;
d190 2
a191 1
		tcgetattr(tty, &s);
d196 1
a196 5
		if (!saved_term)
		{
			save_term = s;
			saved_term = 1;
		}
d262 1
a262 1
		werase_char = CONTROL('W');
d287 2
a288 2
#ifdef OXTABS
			| OXTABS
d293 2
a294 2
#ifdef XTABS
			| XTABS
a321 13
#ifdef VLNEXT
		s.c_cc[VLNEXT] = 0;
#endif
#ifdef VDSUSP
		s.c_cc[VDSUSP] = 0;
#endif
#if MUST_SET_LINE_DISCIPLINE
		/*
		 * System's termios is broken; need to explicitly 
		 * request TERMIODISC line discipline.
		 */
		s.c_line = TERMIODISC;
#endif
d329 2
a330 16
#if HAVE_FSYNC
	fsync(tty);
#endif
	tcsetattr(tty, TCSADRAIN, &s);
#if MUST_SET_LINE_DISCIPLINE
	if (!on)
	{
		/*
		 * Broken termios *ignores* any line discipline
		 * except TERMIODISC.  A different old line discipline
		 * is therefore not restored, yet.  Restore the old
		 * line discipline by hand.
		 */
		ioctl(tty, TIOCSETD, &save_term.c_line);
	}
#endif
a336 1
	static int saved_term = 0;
d343 1
a343 1
		ioctl(tty, TCGETA, &s);
d348 1
a348 5
		if (!saved_term)
		{
			save_term = s;
			saved_term = 1;
		}
d357 1
a357 1
		werase_char = CONTROL('W');
d375 1
a375 1
	ioctl(tty, TCSETAW, &s);
a377 1
#ifdef TIOCGETP
a380 1
	static int saved_term = 0;
d387 1
a387 1
		ioctl(tty, TIOCGETP, &s);
d392 1
a392 5
		if (!saved_term)
		{
			save_term = s;
			saved_term = 1;
		}
d398 1
a398 1
		werase_char = CONTROL('W');
d412 1
a412 1
	ioctl(tty, TIOCSETN, &s);
d414 5
a418 6
#else
#ifdef _OSK
    {
	struct sgbuf s;
	static struct sgbuf save_term;
	static int saved_term = 0;
d420 5
a424 6
	if (on)
	{
		/*
		 * Get terminal modes.
		 */
		_gs_opt(tty, &s);
d426 4
a429 2
		/*
		 * Save modes and set certain variables dependent on modes.
d431 1
a431 8
		if (!saved_term)
		{
			save_term = s;
			saved_term = 1;
		}
		erase_char = s.sg_bspch;
		kill_char = s.sg_dlnch;
		werase_char = CONTROL('W');
d433 2
a434 43
		/*
		 * Set the modes to the way we want them.
		 */
		s.sg_echo = 0;
		s.sg_eofch = 0;
		s.sg_pause = 0;
		s.sg_psch = 0;
	} else
	{
		/*
		 * Restore saved modes.
		 */
		s = save_term;
	}
	_ss_opt(tty, &s);
    }
#else
	/* MS-DOS, Windows, or OS2 */
#if OS2
	/* OS2 */
	LSIGNAL(SIGINT, SIG_IGN);
#endif
	erase_char = '\b';
#if MSDOS_COMPILER==DJGPPC
	kill_char = CONTROL('U');
	/*
	 * So that when we shell out or run another program, its
	 * stdin is in cooked mode.  We do not switch stdin to binary 
	 * mode if fd0 is zero, since that means we were called before
	 * tty was reopened in open_getchr, in which case we would be
	 * changing the original stdin device outside less.
	 */
	if (fd0 != 0)
		setmode(0, on ? O_BINARY : O_TEXT);
#else
	kill_char = ESC;
#endif
	werase_char = CONTROL('W');
#endif
#endif
#endif
#endif
	curr_on = on;
a436 1
#if !MSDOS_COMPILER
d438 1
a438 1
 * Some glue to prevent calling termcap functions if tgetent() failed.
d440 3
a442 5
static int hardcopy;

	static char *
ltget_env(capname)
	char *capname;
d444 1
a444 1
	char name[16];
d446 3
a448 3
	strlcpy(name, "LESS_TERMCAP_", sizeof(name));
	strlcat(name, capname, sizeof(name));
	return (lgetenv(name));
d451 4
a454 3
	static int
ltgetflag(capname)
	char *capname;
d457 7
d465 2
a466 6
	if ((s = ltget_env(capname)) != NULL)
		return (*s != '\0' && *s != '0');
	if (hardcopy)
		return (0);
	return (tgetflag(capname));
}
d468 15
a482 5
	static int
ltgetnum(capname)
	char *capname;
{
	char *s;
d484 2
a485 6
	if ((s = ltget_env(capname)) != NULL)
		return (atoi(s));
	if (hardcopy)
		return (-1);
	return (tgetnum(capname));
}
d487 14
a500 6
	static char *
ltgetstr(capname, pp)
	char *capname;
	char **pp;
{
	char *s;
d502 2
a503 5
	if ((s = ltget_env(capname)) != NULL)
		return (s);
	if (hardcopy)
		return (NULL);
	return (tgetstr(capname, pp));
d505 1
a505 1
#endif /* MSDOS_COMPILER */
d508 4
a511 1
 * Get size of the output screen.
d514 1
a514 1
scrsize()
d516 8
a523 6
	register char *s;
	int sys_height;
	int sys_width;
#if !MSDOS_COMPILER
	int n;
#endif
d525 7
a531 6
#define	DEF_SC_WIDTH	80
#if MSDOS_COMPILER
#define	DEF_SC_HEIGHT	25
#else
#define	DEF_SC_HEIGHT	24
#endif
d533 4
d538 4
a541 1
	sys_width = sys_height = 0;
d543 3
a545 1
#if MSDOS_COMPILER==MSOFTC
d547 2
a548 4
		struct videoconfig w;
		_getvideoconfig(&w);
		sys_height = w.numtextrows;
		sys_width = w.numtextcols;
d550 28
a577 2
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
d579 1
a579 4
		struct text_info w;
		gettextinfo(&w);
		sys_height = w.screenheight;
		sys_width = w.screenwidth;
d581 4
a584 2
#else
#if MSDOS_COMPILER==WIN32C
d586 1
a586 4
		CONSOLE_SCREEN_BUFFER_INFO scr;
		GetConsoleScreenBufferInfo(con_out, &scr);
		sys_height = scr.srWindow.Bottom - scr.srWindow.Top + 1;
		sys_width = scr.srWindow.Right - scr.srWindow.Left + 1;
d588 4
a591 2
#else
#if OS2
d593 1
a593 25
		int s[2];
		_scrsize(s);
		sys_width = s[0];
		sys_height = s[1];
		/*
		 * When using terminal emulators for XFree86/OS2, the
		 * _scrsize function does not work well.
		 * Call the scrsize.exe program to get the window size.
		 */
		windowid = getenv("WINDOWID");
		if (windowid != NULL)
		{
			FILE *fd = popen("scrsize", "rt");
			if (fd != NULL)
			{
				int w, h;
				fscanf(fd, "%i %i", &w, &h);
				if (w > 0 && h > 0)
				{
					sys_width = w;
					sys_height = h;
				}
				pclose(fd);
			}
		}
d595 4
a598 2
#else
#ifdef TIOCGWINSZ
d600 1
a600 8
		struct winsize w;
		if (ioctl(2, TIOCGWINSZ, &w) == 0)
		{
			if (w.ws_row > 0)
				sys_height = w.ws_row;
			if (w.ws_col > 0)
				sys_width = w.ws_col;
		}
d602 4
a605 2
#else
#ifdef WIOCGETD
d607 4
a610 8
		struct uwdata w;
		if (ioctl(2, WIOCGETD, &w) == 0)
		{
			if (w.uw_height > 0)
				sys_height = w.uw_height / w.uw_vs;
			if (w.uw_width > 0)
				sys_width = w.uw_width / w.uw_hs;
		}
d612 8
a619 6
#endif
#endif
#endif
#endif
#endif
#endif
d621 6
a626 10
	if (sys_height > 0)
		sc_height = sys_height;
	else if ((s = lgetenv("LINES")) != NULL)
		sc_height = atoi(s);
#if !MSDOS_COMPILER
	else if ((n = ltgetnum("li")) > 0)
 		sc_height = n;
#endif
	else
		sc_height = DEF_SC_HEIGHT;
d628 5
a632 10
	if (sys_width > 0)
		sc_width = sys_width;
	else if ((s = lgetenv("COLUMNS")) != NULL)
		sc_width = atoi(s);
#if !MSDOS_COMPILER
	else if ((n = ltgetnum("co")) > 0)
 		sc_width = n;
#endif
	else
		sc_width = DEF_SC_WIDTH;
d635 1
a635 4
#if MSDOS_COMPILER==MSOFTC
/*
 * Figure out how many empty loops it takes to delay a millisecond.
 */
d637 1
a637 1
get_clock()
d639 27
a665 20
	clock_t start;
	
	/*
	 * Get synchronized at the start of a tick.
	 */
	start = clock();
	while (clock() == start)
		;
	/*
	 * Now count loops till the next tick.
	 */
	start = clock();
	msec_loops = 0;
	while (clock() == start)
		msec_loops++;
	/*
	 * Convert from (loops per clock) to (loops per millisecond).
	 */
	msec_loops *= CLOCKS_PER_SEC;
	msec_loops /= 1000;
d667 1
d670 1
a670 1
 * Delay for a specified number of milliseconds.
d672 2
a673 2
	static void
dummy_func()
d675 7
a681 3
	static long delay_dummy = 0;
	delay_dummy++;
}
d683 6
a688 7
	static void
delay(msec)
	int msec;
{
	long i;
	
	while (msec-- > 0)
d690 2
a691 1
		for (i = 0;  i < msec_loops;  i++)
d693 5
a697 5
			/*
			 * Make it look like we're doing something here,
			 * so the optimizer doesn't remove the whole loop.
			 */
			dummy_func();
a699 1
}
d701 7
d709 1
a709 30
/*
 * Return the characters actually input by a "special" key.
 */
	public char *
special_key_str(key)
	int key;
{
	static char tbuf[40];
	char *s;
#if MSDOS_COMPILER || OS2
	static char k_right[]		= { '\340', PCK_RIGHT, 0 };
	static char k_left[]		= { '\340', PCK_LEFT, 0  };
	static char k_ctl_right[]	= { '\340', PCK_CTL_RIGHT, 0  };
	static char k_ctl_left[]	= { '\340', PCK_CTL_LEFT, 0  };
	static char k_insert[]		= { '\340', PCK_INSERT, 0  };
	static char k_delete[]		= { '\340', PCK_DELETE, 0  };
	static char k_ctl_delete[]	= { '\340', PCK_CTL_DELETE, 0  };
	static char k_ctl_backspace[]	= { '\177', 0 };
	static char k_home[]		= { '\340', PCK_HOME, 0 };
	static char k_end[]		= { '\340', PCK_END, 0 };
	static char k_up[]		= { '\340', PCK_UP, 0 };
	static char k_down[]		= { '\340', PCK_DOWN, 0 };
	static char k_backtab[]		= { '\340', PCK_SHIFT_TAB, 0 };
	static char k_pagedown[]	= { '\340', PCK_PAGEDOWN, 0 };
	static char k_pageup[]		= { '\340', PCK_PAGEUP, 0 };
	static char k_f1[]		= { '\340', PCK_F1, 0 };
#endif
#if !MSDOS_COMPILER
	char *sp = tbuf;
#endif
a710 3
	switch (key)
	{
#if OS2
d712 1
a712 2
	 * If windowid is not NULL, assume less is executed in 
	 * the XFree86 environment.
d714 2
a715 199
	case SK_RIGHT_ARROW:
		s = windowid ? ltgetstr("kr", &sp) : k_right;
		break;
	case SK_LEFT_ARROW:
		s = windowid ? ltgetstr("kl", &sp) : k_left;
		break;
	case SK_UP_ARROW:
		s = windowid ? ltgetstr("ku", &sp) : k_up;
		break;
	case SK_DOWN_ARROW:
		s = windowid ? ltgetstr("kd", &sp) : k_down;
		break;
	case SK_PAGE_UP:
		s = windowid ? ltgetstr("kP", &sp) : k_pageup;
		break;
	case SK_PAGE_DOWN:
		s = windowid ? ltgetstr("kN", &sp) : k_pagedown;
		break;
	case SK_HOME:
		s = windowid ? ltgetstr("kh", &sp) : k_home;
		break;
	case SK_END:
		s = windowid ? ltgetstr("@@7", &sp) : k_end;
		break;
	case SK_DELETE:
		if (windowid)
		{
			s = ltgetstr("kD", &sp);
			if (s == NULL)
			{
				tbuf[0] = '\177';
				tbuf[1] = '\0';
				s = tbuf;
			}
		} else
			s = k_delete;
		break;
#endif
#if MSDOS_COMPILER
	case SK_RIGHT_ARROW:
		s = k_right;
		break;
	case SK_LEFT_ARROW:
		s = k_left;
		break;
	case SK_UP_ARROW:
		s = k_up;
		break;
	case SK_DOWN_ARROW:
		s = k_down;
		break;
	case SK_PAGE_UP:
		s = k_pageup;
		break;
	case SK_PAGE_DOWN:
		s = k_pagedown;
		break;
	case SK_HOME:
		s = k_home;
		break;
	case SK_END:
		s = k_end;
		break;
	case SK_DELETE:
		s = k_delete;
		break;
#endif
#if MSDOS_COMPILER || OS2
	case SK_INSERT:
		s = k_insert;
		break;
	case SK_CTL_LEFT_ARROW:
		s = k_ctl_left;
		break;
	case SK_CTL_RIGHT_ARROW:
		s = k_ctl_right;
		break;
	case SK_CTL_BACKSPACE:
		s = k_ctl_backspace;
		break;
	case SK_CTL_DELETE:
		s = k_ctl_delete;
		break;
	case SK_F1:
		s = k_f1;
		break;
	case SK_BACKTAB:
		s = k_backtab;
		break;
#else
	case SK_RIGHT_ARROW:
		s = ltgetstr("kr", &sp);
		break;
	case SK_LEFT_ARROW:
		s = ltgetstr("kl", &sp);
		break;
	case SK_UP_ARROW:
		s = ltgetstr("ku", &sp);
		break;
	case SK_DOWN_ARROW:
		s = ltgetstr("kd", &sp);
		break;
	case SK_PAGE_UP:
		s = ltgetstr("kP", &sp);
		break;
	case SK_PAGE_DOWN:
		s = ltgetstr("kN", &sp);
		break;
	case SK_HOME:
		s = ltgetstr("kh", &sp);
		break;
	case SK_END:
		s = ltgetstr("@@7", &sp);
		break;
	case SK_DELETE:
		s = ltgetstr("kD", &sp);
		if (s == NULL)
		{
			tbuf[0] = '\177';
			tbuf[1] = '\0';
			s = tbuf;
		}
		break;
#endif
	case SK_CONTROL_K:
		tbuf[0] = CONTROL('K');
		tbuf[1] = '\0';
		s = tbuf;
		break;
	default:
		return (NULL);
	}
	return (s);
}

/*
 * Get terminal capabilities via termcap.
 */
	public void
get_term()
{
#if MSDOS_COMPILER
	auto_wrap = 1;
	ignaw = 0;
	can_goto_line = 1;
	clear_bg = 1;
	/*
	 * Set up default colors.
	 * The xx_s_width and xx_e_width vars are already initialized to 0.
	 */
#if MSDOS_COMPILER==MSOFTC
	sy_bg_color = _getbkcolor();
	sy_fg_color = _gettextcolor();
	get_clock();
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
    {
	struct text_info w;
	gettextinfo(&w);
	sy_bg_color = (w.attribute >> 4) & 0x0F;
	sy_fg_color = (w.attribute >> 0) & 0x0F;
    }
#else
#if MSDOS_COMPILER==WIN32C
    {
	DWORD nread;
	CONSOLE_SCREEN_BUFFER_INFO scr;

	con_out_save = con_out = GetStdHandle(STD_OUTPUT_HANDLE);
	/*
	 * Always open stdin in binary. Note this *must* be done
	 * before any file operations have been done on fd0.
	 */
	SET_BINARY(0);
	GetConsoleScreenBufferInfo(con_out, &scr);
	ReadConsoleOutputAttribute(con_out, &curr_attr, 
					1, scr.dwCursorPosition, &nread);
	sy_bg_color = (curr_attr & BG_COLORS) >> 4; /* normalize */
	sy_fg_color = curr_attr & FG_COLORS;
    }
#endif
#endif
#endif
	nm_fg_color = sy_fg_color;
	nm_bg_color = sy_bg_color;
	bo_fg_color = 11;
	bo_bg_color = 0;
	ul_fg_color = 9;
	ul_bg_color = 0;
	so_fg_color = 15;
	so_bg_color = 9;
	bl_fg_color = 15;
	bl_bg_color = 0;

	/*
	 * Get size of the screen.
	 */
	scrsize();
	pos_init();
d717 2
a718 16

#else /* !MSDOS_COMPILER */

	char *sp;
	register char *t1, *t2;
	char *term;
	char termbuf[TERMBUF_SIZE];

	static char sbuf[TERMSBUF_SIZE];

#if OS2
	/*
	 * Make sure the termcap database is available.
	 */
	sp = lgetenv("TERMCAP");
	if (sp == NULL || *sp == '\0')
d720 2
a721 9
		char *termcap;
		if ((sp = homefile("termcap.dat")) != NULL)
		{
			size_t len = strlen(sp) + 9;
			termcap = (char *) ecalloc(len, sizeof(char));
			snprintf(termcap, len, "TERMCAP=%s", sp);
			free(sp);
			putenv(termcap);
		}
d723 1
a723 11
#endif
	/*
	 * Find out what kind of terminal this is.
	 */
 	if ((term = lgetenv("TERM")) == NULL)
 		term = DEFAULT_TERM;
	hardcopy = 0;
 	if (tgetent(termbuf, term) <= 0)
 		hardcopy = 1;
 	if (ltgetflag("hc"))
		hardcopy = 1;
d725 4
a728 11
	/*
	 * Get size of the screen.
	 */
	scrsize();
	pos_init();

	auto_wrap = ltgetflag("am");
	ignaw = ltgetflag("xn");
	above_mem = ltgetflag("da");
	below_mem = ltgetflag("db");
	clear_bg = ltgetflag("ut");
d736 1
a736 1
	if ((so_s_width = ltgetnum("sg")) < 0)
d762 1
a762 1
	sc_pad = ltgetstr("pc", &sp);
d767 1
a767 1
	sc_s_keypad = ltgetstr("ks", &sp);
d770 1
a770 1
	sc_e_keypad = ltgetstr("ke", &sp);
d779 3
a781 3
	if (!quit_at_eof && !ismore) {
		sc_init = ltgetstr("ti", &sp);
		sc_deinit= ltgetstr("te", &sp);
a784 1

d788 2
a789 2
	sc_eol_clear = ltgetstr("ce", &sp);
	if (sc_eol_clear == NULL || *sc_eol_clear == '\0')
d791 1
a791 1
		missing_cap = 1;
d795 3
a797 2
	sc_eos_clear = ltgetstr("cd", &sp);
	if (below_mem && (sc_eos_clear == NULL || *sc_eos_clear == '\0'))
d799 1
a799 1
		missing_cap = 1;
d803 2
a804 2
	sc_clear = ltgetstr("cl", &sp);
	if (sc_clear == NULL || *sc_clear == '\0')
d806 1
a806 1
		missing_cap = 1;
d810 2
a811 2
	sc_move = ltgetstr("cm", &sp);
	if (sc_move == NULL || *sc_move == '\0')
d823 27
a849 4
	tmodes("so", "se", &sc_s_in, &sc_s_out, "", "", &sp);
	tmodes("us", "ue", &sc_u_in, &sc_u_out, sc_s_in, sc_s_out, &sp);
	tmodes("md", "me", &sc_b_in, &sc_b_out, sc_s_in, sc_s_out, &sp);
	tmodes("mb", "me", &sc_bl_in, &sc_bl_out, sc_s_in, sc_s_out, &sp);
d851 14
a864 2
	sc_visual_bell = ltgetstr("vb", &sp);
	if (sc_visual_bell == NULL)
d867 1
a867 1
	if (ltgetflag("bs"))
d871 1
a871 1
		sc_backspace = ltgetstr("bc", &sp);
d880 2
a881 2
	t1 = ltgetstr("ho", &sp);
	if (t1 == NULL)
d887 1
a887 1
		strlcpy(sp, tgoto(sc_move, 0, 0), sbuf + sizeof(sbuf) - sp);
d891 1
a891 1
	sc_home = cheaper(t1, t2, "|\b^");
d897 2
a898 2
	t1 = ltgetstr("ll", &sp);
	if (t1 == NULL)
d904 1
a904 2
		strlcpy(sp, tgoto(sc_move, 0, sc_height-1),
		    sbuf + sizeof(sbuf) - sp);
d908 2
a909 1
	sc_lower_left = cheaper(t1, t2, "\r");
d915 2
a916 2
	t1 = ltgetstr("al", &sp);
	if (t1 == NULL)
d918 2
a919 2
	t2 = ltgetstr("sr", &sp);
	if (t2 == NULL)
d929 1
a929 1
		sc_addline = cheaper(t1, t2, "");
d935 1
a935 1
		no_back_scroll = 1;
a936 1
#endif /* MSDOS_COMPILER */
a938 1
#if !MSDOS_COMPILER
d972 1
a972 1
cheaper(t1, t2, def)
d974 1
d979 1
a979 1
		missing_cap = 1;
a990 30
	static void
tmodes(incap, outcap, instr, outstr, def_instr, def_outstr, spp)
	char *incap;
	char *outcap;
	char **instr;
	char **outstr;
	char *def_instr;
	char *def_outstr;
	char **spp;
{
	*instr = ltgetstr(incap, spp);
	if (*instr == NULL)
	{
		/* Use defaults. */
		*instr = def_instr;
		*outstr = def_outstr;
		return;
	}

	*outstr = ltgetstr(outcap, spp);
	if (*outstr == NULL)
		/* No specific out capability; use "me". */
		*outstr = ltgetstr("me", spp);
	if (*outstr == NULL)
		/* Don't even have "me"; use a null string. */
		*outstr = "";
}

#endif /* MSDOS_COMPILER */

a997 100
#if MSDOS_COMPILER

#if MSDOS_COMPILER==WIN32C
	static void
_settextposition(int row, int col)
{
	COORD cpos;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	GetConsoleScreenBufferInfo(con_out, &csbi);
	cpos.X = csbi.srWindow.Left + (col - 1);
	cpos.Y = csbi.srWindow.Top + (row - 1);
	SetConsoleCursorPosition(con_out, cpos);
}
#endif

/*
 * Initialize the screen to the correct color at startup.
 */
	static void
initcolor()
{
	SETCOLORS(nm_fg_color, nm_bg_color);
#if 0
	/*
	 * This clears the screen at startup.  This is different from
	 * the behavior of other versions of less.  Disable it for now.
	 */
	char *blanks;
	int row;
	int col;
	
	/*
	 * Create a complete, blank screen using "normal" colors.
	 */
	SETCOLORS(nm_fg_color, nm_bg_color);
	blanks = (char *) ecalloc(width+1, sizeof(char));
	for (col = 0;  col < sc_width;  col++)
		blanks[col] = ' ';
	blanks[sc_width] = '\0';
	for (row = 0;  row < sc_height;  row++)
		_outtext(blanks);
	free(blanks);
#endif
}
#endif

#if MSDOS_COMPILER==WIN32C

/*
 * Termcap-like init with a private win32 console.
 */
	static void
win32_init_term()
{
	CONSOLE_SCREEN_BUFFER_INFO scr;
	COORD size;

	if (con_out_save == INVALID_HANDLE_VALUE)
		return;

	GetConsoleScreenBufferInfo(con_out_save, &scr);

	if (con_out_ours == INVALID_HANDLE_VALUE)
	{
		/*
		 * Create our own screen buffer, so that we
		 * may restore the original when done.
		 */
		con_out_ours = CreateConsoleScreenBuffer(
			GENERIC_WRITE | GENERIC_READ,
			FILE_SHARE_WRITE | FILE_SHARE_READ,
			(LPSECURITY_ATTRIBUTES) NULL,
			CONSOLE_TEXTMODE_BUFFER,
			(LPVOID) NULL);
	}

	size.X = scr.srWindow.Right - scr.srWindow.Left + 1;
	size.Y = scr.srWindow.Bottom - scr.srWindow.Top + 1;
	SetConsoleScreenBufferSize(con_out_ours, size);
	SetConsoleActiveScreenBuffer(con_out_ours);
	con_out = con_out_ours;
}

/*
 * Restore the startup console.
 */
static void
win32_deinit_term()
{
	if (con_out_save == INVALID_HANDLE_VALUE)
		return;
	if (quitting)
		(void) CloseHandle(con_out_ours);
	SetConsoleActiveScreenBuffer(con_out_save);
	con_out = con_out_save;
}

#endif

d1004 4
a1007 13
#if !MSDOS_COMPILER
	if (!no_init)
		tputs(sc_init, sc_height, putchr);
	if (!no_keypad)
		tputs(sc_s_keypad, sc_height, putchr);
#else
#if MSDOS_COMPILER==WIN32C
	if (!no_init)
		win32_init_term();
#endif
	initcolor();
	flush();
#endif
d1017 2
d1021 2
a1022 16
#if !MSDOS_COMPILER
	if (!no_keypad)
		tputs(sc_e_keypad, sc_height, putchr);
	if (!no_init)
		tputs(sc_deinit, sc_height, putchr);
#else
	/* Restore system colors. */
	SETCOLORS(sy_fg_color, sy_bg_color);
#if MSDOS_COMPILER==WIN32C
	if (!no_init)
		win32_deinit_term();
#else
	/* Need clreol to make SETCOLORS take effect. */
	clreol();
#endif
#endif
a1031 1
#if !MSDOS_COMPILER
a1032 4
#else
	flush();
	_settextposition(1,1);
#endif
a1041 1
#if !MSDOS_COMPILER
a1042 198
#else
	flush();
#if MSDOS_COMPILER==MSOFTC
	_scrolltextwindow(_GSCROLLDOWN);
	_settextposition(1,1);
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	movetext(1,1, sc_width,sc_height-1, 1,2);
	gotoxy(1,1);
	clreol();
#else
#if MSDOS_COMPILER==WIN32C
    {
	CHAR_INFO fillchar;
	SMALL_RECT rcSrc, rcClip;
	COORD new_org;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	GetConsoleScreenBufferInfo(con_out,&csbi);

	/* The clip rectangle is the entire visible screen. */
	rcClip.Left = csbi.srWindow.Left;
	rcClip.Top = csbi.srWindow.Top;
	rcClip.Right = csbi.srWindow.Right;
	rcClip.Bottom = csbi.srWindow.Bottom;

	/* The source rectangle is the visible screen minus the last line. */
	rcSrc = rcClip;
	rcSrc.Bottom--;

	/* Move the top left corner of the source window down one row. */
	new_org.X = rcSrc.Left;
	new_org.Y = rcSrc.Top + 1;

	/* Fill the right character and attributes. */
	fillchar.Char.AsciiChar = ' ';
	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	fillchar.Attributes = curr_attr;
	ScrollConsoleScreenBuffer(con_out, &rcSrc, &rcClip, new_org, &fillchar);
	_settextposition(1,1);
    }
#endif
#endif
#endif
#endif
}

#if 0
/*
 * Remove the n topmost lines and scroll everything below it in the 
 * window upward.  This is needed to stop leaking the topmost line 
 * into the scrollback buffer when we go down-one-line (in WIN32).
 */
	public void
remove_top(n)
	int n;
{
#if MSDOS_COMPILER==WIN32C
	SMALL_RECT rcSrc, rcClip;
	CHAR_INFO fillchar;
	COORD new_org;
	CONSOLE_SCREEN_BUFFER_INFO csbi; /* to get buffer info */

	if (n >= sc_height - 1)
	{
		clear();
		home();
		return;
	}

	flush();

	GetConsoleScreenBufferInfo(con_out, &csbi);

	/* Get the extent of all-visible-rows-but-the-last. */
	rcSrc.Left    = csbi.srWindow.Left;
	rcSrc.Top     = csbi.srWindow.Top + n;
	rcSrc.Right   = csbi.srWindow.Right;
	rcSrc.Bottom  = csbi.srWindow.Bottom;

	/* Get the clip rectangle. */
	rcClip.Left   = rcSrc.Left;
	rcClip.Top    = csbi.srWindow.Top;
	rcClip.Right  = rcSrc.Right;
	rcClip.Bottom = rcSrc.Bottom ;

	/* Move the source window up n rows. */
	new_org.X = rcSrc.Left;
	new_org.Y = rcSrc.Top - n;

	/* Fill the right character and attributes. */
	fillchar.Char.AsciiChar = ' ';
	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	fillchar.Attributes = curr_attr;

	ScrollConsoleScreenBuffer(con_out, &rcSrc, &rcClip, new_org, &fillchar);

	/* Position cursor on first blank line. */
	goto_line(sc_height - n - 1);
#endif
}
#endif

#if MSDOS_COMPILER==WIN32C
/*
 * Clear the screen.
 */
	static void
win32_clear()
{
	/*
	 * This will clear only the currently visible rows of the NT
	 * console buffer, which means none of the precious scrollback
	 * rows are touched making for faster scrolling.  Note that, if
	 * the window has fewer columns than the console buffer (i.e.
	 * there is a horizontal scrollbar as well), the entire width
	 * of the visible rows will be cleared.
	 */
	COORD topleft;
	DWORD nchars;
	DWORD winsz;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	/* get the number of cells in the current buffer */
	GetConsoleScreenBufferInfo(con_out, &csbi);
	winsz = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);
	topleft.X = 0;
	topleft.Y = csbi.srWindow.Top;

	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	FillConsoleOutputCharacter(con_out, ' ', winsz, topleft, &nchars);
	FillConsoleOutputAttribute(con_out, curr_attr, winsz, topleft, &nchars);
}

/*
 * Remove the n topmost lines and scroll everything below it in the 
 * window upward.
 */
	public void
win32_scroll_up(n)
	int n;
{
	SMALL_RECT rcSrc, rcClip;
	CHAR_INFO fillchar;
	COORD topleft;
	COORD new_org;
	DWORD nchars;
	DWORD size;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	if (n <= 0)
		return;

	if (n >= sc_height - 1)
	{
		win32_clear();
		_settextposition(1,1);
		return;
	}

	/* Get the extent of what will remain visible after scrolling. */
	GetConsoleScreenBufferInfo(con_out, &csbi);
	rcSrc.Left    = csbi.srWindow.Left;
	rcSrc.Top     = csbi.srWindow.Top + n;
	rcSrc.Right   = csbi.srWindow.Right;
	rcSrc.Bottom  = csbi.srWindow.Bottom;

	/* Get the clip rectangle. */
	rcClip.Left   = rcSrc.Left;
	rcClip.Top    = csbi.srWindow.Top;
	rcClip.Right  = rcSrc.Right;
	rcClip.Bottom = rcSrc.Bottom ;

	/* Move the source text to the top of the screen. */
	new_org.X = rcSrc.Left;
	new_org.Y = 0;

	/* Fill the right character and attributes. */
	fillchar.Char.AsciiChar = ' ';
	fillchar.Attributes = MAKEATTR(nm_fg_color, nm_bg_color);

	/* Scroll the window. */
	SetConsoleTextAttribute(con_out, fillchar.Attributes);
	ScrollConsoleScreenBuffer(con_out, &rcSrc, &rcClip, new_org, &fillchar);

	/* Clear remaining lines at bottom. */
	topleft.X = csbi.dwCursorPosition.X;
	topleft.Y = rcSrc.Bottom - n;
	size = (n * csbi.dwSize.X) + (rcSrc.Right - topleft.X);
	FillConsoleOutputCharacter(con_out, ' ', size, topleft,
		&nchars);
	FillConsoleOutputAttribute(con_out, fillchar.Attributes, size, topleft,
		&nchars);
	SetConsoleTextAttribute(con_out, curr_attr);

	/* Move cursor n lines up from where it was. */
	csbi.dwCursorPosition.Y -= n;
	SetConsoleCursorPosition(con_out, csbi.dwCursorPosition);
a1043 1
#endif
a1050 1
#if !MSDOS_COMPILER
a1051 35
#else
	flush();
	_settextposition(sc_height, 1);
#endif
}

/*
 * Check if the console size has changed and reset internals 
 * (in lieu of SIGWINCH for WIN32).
 */
	public void
check_winch()
{
#if MSDOS_COMPILER==WIN32C
	CONSOLE_SCREEN_BUFFER_INFO scr;
	COORD size;

	if (con_out == INVALID_HANDLE_VALUE)
		return;
 
	flush();
	GetConsoleScreenBufferInfo(con_out, &scr);
	size.Y = scr.srWindow.Bottom - scr.srWindow.Top + 1;
	size.X = scr.srWindow.Right - scr.srWindow.Left + 1;
	if (size.Y != sc_height || size.X != sc_width)
	{
		sc_height = size.Y;
		sc_width = size.X;
		if (!no_init && con_out_ours == con_out)
			SetConsoleScreenBufferSize(con_out, size);
		pos_init();
		wscroll = (sc_height + 1) / 2;
		screen_trashed = 1;
	}
#endif
d1061 4
a1064 6
#if !MSDOS_COMPILER
	tputs(tgoto(sc_move, 0, slinenum), 1, putchr);
#else
	flush();
	_settextposition(slinenum+1, 1);
#endif
a1066 1
#if MSDOS_COMPILER==MSOFTC || MSDOS_COMPILER==BORLANDC
d1068 1
a1068 4
 * Create an alternate screen which is all white.
 * This screen is used to create a "flash" effect, by displaying it
 * briefly and then switching back to the normal screen.
 * {{ Yuck!  There must be a better way to get a visual bell. }}
d1070 2
a1071 2
	static void
create_flash()
d1073 4
a1076 50
#if MSDOS_COMPILER==MSOFTC
	struct videoconfig w;
	char *blanks;
	int row, col;
	
	_getvideoconfig(&w);
	videopages = w.numvideopages;
	if (videopages < 2)
	{
		so_enter();
		so_exit();
	} else
	{
		_setactivepage(1);
		so_enter();
		blanks = (char *) ecalloc(w.numtextcols, sizeof(char));
		for (col = 0;  col < w.numtextcols;  col++)
			blanks[col] = ' ';
		for (row = w.numtextrows;  row > 0;  row--)
			_outmem(blanks, w.numtextcols);
		_setactivepage(0);
		_setvisualpage(0);
		free(blanks);
		so_exit();
	}
#else
#if MSDOS_COMPILER==BORLANDC
	register int n;

	whitescreen = (unsigned short *) 
		malloc(sc_width * sc_height * sizeof(short));
	if (whitescreen == NULL)
		return;
	for (n = 0;  n < sc_width * sc_height;  n++)
		whitescreen[n] = 0x7020;
#else
#if MSDOS_COMPILER==WIN32C
	register int n;

	whitescreen = (WORD *)
		malloc(sc_height * sc_width * sizeof(WORD));
	if (whitescreen == NULL)
		return;
	/* Invert the standard colors. */
	for (n = 0;  n < sc_width * sc_height;  n++)
		whitescreen[n] = (WORD)((nm_fg_color << 4) | nm_bg_color);
#endif
#endif
#endif
	flash_created = 1;
a1077 1
#endif /* MSDOS_COMPILER */
a1084 1
#if !MSDOS_COMPILER
a1087 81
#else
#if MSDOS_COMPILER==DJGPPC
	ScreenVisualBell();
#else
#if MSDOS_COMPILER==MSOFTC
	/*
	 * Create a flash screen on the second video page.
	 * Switch to that page, then switch back.
	 */
	if (!flash_created)
		create_flash();
	if (videopages < 2)
		return;
	_setvisualpage(1);
	delay(100);
	_setvisualpage(0);
#else
#if MSDOS_COMPILER==BORLANDC
	unsigned short *currscreen;

	/*
	 * Get a copy of the current screen.
	 * Display the flash screen.
	 * Then restore the old screen.
	 */
	if (!flash_created)
		create_flash();
	if (whitescreen == NULL)
		return;
	currscreen = (unsigned short *) 
		malloc(sc_width * sc_height * sizeof(short));
	if (currscreen == NULL) return;
	gettext(1, 1, sc_width, sc_height, currscreen);
	puttext(1, 1, sc_width, sc_height, whitescreen);
	delay(100);
	puttext(1, 1, sc_width, sc_height, currscreen);
	free(currscreen);
#else
#if MSDOS_COMPILER==WIN32C
	/* paint screen with an inverse color */
	clear();

	/* leave it displayed for 100 msec. */
	Sleep(100);

	/* restore with a redraw */
	repaint();
#endif
#endif
#endif
#endif
#endif
}

/*
 * Make a noise.
 */
	static void
beep()
{
#if !MSDOS_COMPILER
	putchr(CONTROL('G'));
#else
#if MSDOS_COMPILER==WIN32C
	MessageBeep(0);
#else
	write(1, "\7", 1);
#endif
#endif
}

/*
 * Ring the terminal bell.
 */
	public void
bell()
{
	if (quiet == VERY_QUIET)
		vbell();
	else
		beep();
a1095 1
#if !MSDOS_COMPILER
a1096 8
#else
	flush();
#if MSDOS_COMPILER==WIN32C
	win32_clear();
#else
	_clearscreen(_GCLEARSCREEN);
#endif
#endif
a1105 1
#if !MSDOS_COMPILER
a1106 65
#else
#if MSDOS_COMPILER==MSOFTC
	short top, left;
	short bot, right;
	struct rccoord tpos;
	
	flush();
	/*
	 * Save current state.
	 */
	tpos = _gettextposition();
	_gettextwindow(&top, &left, &bot, &right);
	/*
	 * Set a temporary window to the current line,
	 * from the cursor's position to the right edge of the screen.
	 * Then clear that window.
	 */
	_settextwindow(tpos.row, tpos.col, tpos.row, sc_width);
	_clearscreen(_GWINDOW);
	/*
	 * Restore state.
	 */
	_settextwindow(top, left, bot, right);
	_settextposition(tpos.row, tpos.col);
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	flush();
	clreol();
#else
#if MSDOS_COMPILER==WIN32C
	DWORD           nchars;
	COORD           cpos;
	CONSOLE_SCREEN_BUFFER_INFO scr;

	flush();
	memset(&scr, 0, sizeof(scr));
	GetConsoleScreenBufferInfo(con_out, &scr);
	cpos.X = scr.dwCursorPosition.X;
	cpos.Y = scr.dwCursorPosition.Y;
	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	FillConsoleOutputAttribute(con_out, curr_attr,
		scr.dwSize.X - cpos.X, cpos, &nchars);
	FillConsoleOutputCharacter(con_out, ' ',
		scr.dwSize.X - cpos.X, cpos, &nchars);
#endif
#endif
#endif
#endif
}

/*
 * Clear the current line.
 * Clear the screen if there's off-screen memory below the display.
 */
	static void
clear_eol_bot()
{
#if MSDOS_COMPILER
	clear_eol();
#else
	if (below_mem)
		tputs(sc_eos_clear, 1, putchr);
	else
		tputs(sc_eol_clear, 1, putchr);
#endif
a1115 5
	/*
	 * If we're in a non-normal attribute mode, temporarily exit
	 * the mode while we do the clear.  Some terminals fill the
	 * cleared area with the current attribute.
	 */
d1117 4
a1120 26
	switch (attrmode)
	{
	case AT_STANDOUT:
		so_exit();
		clear_eol_bot();
		so_enter();
		break;
	case AT_UNDERLINE:
		ul_exit();
		clear_eol_bot();
		ul_enter();
		break;
	case AT_BOLD:
		bo_exit();
		clear_eol_bot();
		bo_enter();
		break;
	case AT_BLINK:
		bl_exit();
		clear_eol_bot();
		bl_enter();
		break;
	default:
		clear_eol_bot();
		break;
	}
a1128 1
#if !MSDOS_COMPILER
a1129 5
#else
	flush();
	SETCOLORS(so_fg_color, so_bg_color);
#endif
	attrmode = AT_STANDOUT;
a1137 1
#if !MSDOS_COMPILER
a1138 5
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
	attrmode = AT_NORMAL;
a1147 1
#if !MSDOS_COMPILER
a1148 5
#else
	flush();
	SETCOLORS(ul_fg_color, ul_bg_color);
#endif
	attrmode = AT_UNDERLINE;
a1156 1
#if !MSDOS_COMPILER
a1157 5
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
	attrmode = AT_NORMAL;
a1165 1
#if !MSDOS_COMPILER
a1166 5
#else
	flush();
	SETCOLORS(bo_fg_color, bo_bg_color);
#endif
	attrmode = AT_BOLD;
a1174 1
#if !MSDOS_COMPILER
a1175 5
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
	attrmode = AT_NORMAL;
a1183 1
#if !MSDOS_COMPILER
a1184 5
#else
	flush();
	SETCOLORS(bl_fg_color, bl_bg_color);
#endif
	attrmode = AT_BLINK;
a1192 1
#if !MSDOS_COMPILER
a1193 5
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
	attrmode = AT_NORMAL;
a1195 1
#if 0 /* No longer used */
a1202 1
#if !MSDOS_COMPILER
d1204 1
a1204 1
	 * Erase the previous character by overstriking with a space.
a1208 33
#else
#if MSDOS_COMPILER==MSOFTC
	struct rccoord tpos;
	
	flush();
	tpos = _gettextposition();
	if (tpos.col <= 1)
		return;
	_settextposition(tpos.row, tpos.col-1);
	_outtext(" ");
	_settextposition(tpos.row, tpos.col-1);
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	cputs("\b");
#else
#if MSDOS_COMPILER==WIN32C
	COORD cpos;
	DWORD cChars;
	CONSOLE_SCREEN_BUFFER_INFO scr;

	flush();
	GetConsoleScreenBufferInfo(con_out, &scr);
	cpos = scr.dwCursorPosition;
	if (cpos.X <= 0)
		return;
	cpos.X--;
	SetConsoleCursorPosition(con_out, cpos);
	FillConsoleOutputCharacter(con_out, (TCHAR)' ', 1, cpos, &cChars);
	SetConsoleCursorPosition(con_out, cpos);
#endif
#endif
#endif
#endif
a1209 1
#endif /* 0 */
a1216 1
#if !MSDOS_COMPILER
a1217 28
#else
	int row, col;

	flush();
	{
#if MSDOS_COMPILER==MSOFTC
		struct rccoord tpos;
		tpos = _gettextposition();
		row = tpos.row;
		col = tpos.col;
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
		row = wherey();
		col = wherex();
#else
#if MSDOS_COMPILER==WIN32C
		CONSOLE_SCREEN_BUFFER_INFO scr;
		GetConsoleScreenBufferInfo(con_out, &scr);
		row = scr.dwCursorPosition.Y - scr.srWindow.Top + 1;
		col = scr.dwCursorPosition.X - scr.srWindow.Left + 1;
#endif
#endif
#endif
	}
	if (col <= 1)
		return;
	_settextposition(row, col-1);
#endif /* MSDOS_COMPILER */
a1218 100

#if MSDOS_COMPILER==WIN32C
/*
 * Determine whether an input character is waiting to be read.
 */
	static int
win32_kbhit(tty)
	HANDLE tty;
{
	INPUT_RECORD ip;
	DWORD read;

	if (keyCount > 0)
		return (TRUE);

	currentKey.ascii = 0;
	currentKey.scan = 0;

	/*
	 * Wait for a real key-down event, but
	 * ignore SHIFT and CONTROL key events.
	 */
	do
	{
		PeekConsoleInput(tty, &ip, 1, &read);
		if (read == 0)
			return (FALSE);
		ReadConsoleInput(tty, &ip, 1, &read);
	} while (ip.EventType != KEY_EVENT ||
		ip.Event.KeyEvent.bKeyDown != TRUE ||
		ip.Event.KeyEvent.wVirtualScanCode == 0 ||
		ip.Event.KeyEvent.wVirtualKeyCode == VK_SHIFT ||
		ip.Event.KeyEvent.wVirtualKeyCode == VK_CONTROL ||
		ip.Event.KeyEvent.wVirtualKeyCode == VK_MENU);
		
	currentKey.ascii = ip.Event.KeyEvent.uChar.AsciiChar;
	currentKey.scan = ip.Event.KeyEvent.wVirtualScanCode;
	keyCount = ip.Event.KeyEvent.wRepeatCount;

	if (ip.Event.KeyEvent.dwControlKeyState & 
		(LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))
	{
		switch (currentKey.scan)
		{
		case PCK_ALT_E:     /* letter 'E' */
			currentKey.ascii = 0;
			break;
		}
	} else if (ip.Event.KeyEvent.dwControlKeyState & 
		(LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED))
	{
		switch (currentKey.scan)
		{
		case PCK_RIGHT: /* right arrow */
			currentKey.scan = PCK_CTL_RIGHT;
			break;
		case PCK_LEFT: /* left arrow */
			currentKey.scan = PCK_CTL_LEFT;
			break;
		case PCK_DELETE: /* delete */
			currentKey.scan = PCK_CTL_DELETE;
			break;
		}
	}
	return (TRUE);
}

/*
 * Read a character from the keyboard.
 */
	public char
WIN32getch(tty)
	int tty;
{
	int ascii;

	if (pending_scancode)
	{
		pending_scancode = 0;
		return ((char)(currentKey.scan & 0x00FF));
	}

	while (win32_kbhit((HANDLE)tty) == FALSE)
	{
		Sleep(20);
		if (ABORT_SIGS())
			return ('\003');
		continue;
	}
	keyCount --;
	ascii = currentKey.ascii;
	/*
	 * On PC's, the extended keys return a 2 byte sequence beginning 
	 * with '00', so if the ascii code is 00, the next byte will be 
	 * the lsb of the scan code.
	 */
	pending_scancode = (ascii == 0x00);
	return ((char)ascii);
}
#endif
@


1.1.1.4
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d43 1
a43 1
#if HAVE_SYS_IOCTL_H
@


1.1.1.5
log
@Import some pieces of OpenBSD changes I unbedingtly wanted to have
@
text
@a427 1
	tcsetattr(tty, TCSASOFT | TCSADRAIN, &s);
d431 1
@


