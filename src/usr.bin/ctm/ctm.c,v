head	1.2;
access;
symbols
	tg-mergetmp-mirosx-1:1.2
	tg-mergefixes-1-branch:1.2.0.8
	tg-mergefixes-1-base:1.2
	MIROS_X:1.2.0.6
	MIROS_X_BASE:1.2
	MIRBSD_XP_MIRPPC:1.2.0.4
	MIRBSD_XP_SPARC_BASE:1.2
	MIRBSD_XP_SPARC:1.2.0.2
	MIRBSD_7quater:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	MIRBSD_5:1.1.1.1
	MIRBSD_4:1.1.1.1
	cvs-2003-04-05:1.1.1.1
	freebsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.01.21.22.01.34;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.04.05.20.02.46;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.04.05.20.02.46;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@* remove all GNU Automake files, we don't need them
* disable stupid "if Makefile.am isn't there, I can't build
  Makefile.in so I can't build Makefile so... huh?" stuff
* basically synch lists (base, not x11) with what is gained;
  more review needed
  XXX adjust notes
* various improvements I don't remember
* add configs from the FSF
  (with MirBSD and ekkoBSD support added by myself)
* update some FSF material
* plug some strcpy, strcat, sprintf, mktemp holes
* fix and unify the way where and how the gcc version subdirs are included

XXX someone string-"fix" roff and the gnu part (isdnd will be taken care of later)
@
text
@/* $MirBSD$ */
/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revision 42):
 * <phk@@FreeBSD.org> wrote this file.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp
 * ----------------------------------------------------------------------------
 *
 * $FreeBSD: src/usr.sbin/ctm/ctm/ctm.c,v 1.21 2002/03/25 13:53:29 phk Exp $
 *
 * This is the client program of 'CTM'.  It will apply a CTM-patch to a
 * collection of files.
 *
 * Options we'd like to see:
 *
 * -a 			Attempt best effort.
 * -d <int>		Debug TBD.
 * -m <mail-addr>	Email me instead.
 * -r <name>		Reconstruct file.
 * -R <file>		Read list of files to reconstruct.
 *
 * Options we have:
 * -b <dir>		Base-dir
 * -B <file>		Backup to tar-file.
 * -t 			Tar command (default as in TARCMD).
 * -c			Check it out, don't do anything.
 * -F      		Force
 * -q 			Tell us less.
 * -T <tmpdir>.		Temporary files.
 * -u			Set all file modification times to the timestamp
 * -v 			Tell us more.
 * -V <level>		Tell us more level = number of -v
 * -k			Keep files and directories that would have been removed.
 * -l			List actions.
 *
 * Options we don't actually use:
 * -p			Less paranoid.
 * -P			Paranoid.
 */

#define EXTERN /* */
#include <paths.h>
#include "ctm.h"

#define CTM_STATUS ".ctm_status"

extern int Proc(char *, unsigned applied);

int
main(int argc, char **argv)
{
    int stat=0, err=0;
    int c;
    unsigned applied = 0;
    FILE *statfile;
    struct CTM_Filter *nfilter = NULL;	/* new filter */
    u_char * basedir;

    basedir = NULL;
    Verbose = 1;
    Paranoid = 1;
    SetTime = 0;
    KeepIt = 0;
    ListIt = 0;
    BackupFile = NULL;
    TarCmd = TARCMD;
    LastFilter = FilterList = NULL;
    TmpDir = getenv("TMPDIR");
    if (TmpDir == NULL)
	TmpDir = strdup(_PATH_TMP);
    setbuf(stderr,0);
    setbuf(stdout,0);

    while((c=getopt(argc,argv,"ab:B:cd:e:Fklm:pPqr:R:t:T:uV:vx:")) != -1) {
	switch (c) {
	    case 'b': basedir = optarg;	break; /* Base Directory */
	    case 'B': BackupFile = optarg;	break;
	    case 'c': CheckIt++;	break; /* Only check it */
	    case 'F': Force = 1;	break;
	    case 'k': KeepIt++;		break; /* Don't do removes */
	    case 'l': ListIt++;		break; /* Only list actions and files */
	    case 'p': Paranoid--;	break; /* Less Paranoid */
	    case 'P': Paranoid++;	break; /* More Paranoid */
	    case 'q': Verbose--;	break; /* Quiet */
	    case 't': TarCmd = optarg;	break; /* archiver command */
	    case 'T': TmpDir = optarg;	break; /* set temporary directory */
	    case 'u': SetTime++;	break; /* Set timestamp on files */
	    case 'v': Verbose++;	break; /* Verbose */
	    case 'V': sscanf(optarg,"%d", &c); /* Verbose */
		      Verbose += c;
		      break;
	    case 'e':				/* filter expressions */
	    case 'x':
		if (NULL == (nfilter =  Malloc(sizeof(struct CTM_Filter)))) {
			warnx("out of memory for expressions: \"%s\"", optarg);
			stat++;
			break;
		}

		(void) memset(nfilter, 0, sizeof(struct CTM_Filter));

		if (0 != (err =
			regcomp(&nfilter->CompiledRegex, optarg, REG_NOSUB))) {

			char errmsg[128];

			regerror(err, &nfilter->CompiledRegex, errmsg,
				sizeof(errmsg));
			warnx("regular expression: \"%s\"", errmsg);
			stat++;
			break;
		}

		/* note whether the filter enables or disables on match */
		nfilter->Action =
			(('e' == c) ? CTM_FILTER_ENABLE : CTM_FILTER_DISABLE);

		/* link in the expression into the list */
	        nfilter->Next = NULL;
		if (NULL == FilterList) {
		  LastFilter = FilterList = nfilter; /* init head and tail */
		} else {    /* place at tail */
		  LastFilter->Next = nfilter;
		  LastFilter = nfilter;
		}
		break;
	    case ':':
		warnx("option '%c' requires an argument",optopt);
		stat++;
		break;
	    case '?':
		warnx("option '%c' not supported",optopt);
		stat++;
		break;
	    default:
		warnx("option '%c' not yet implemented",optopt);
		break;
	}
    }

    if(stat) {
	warnx("%d errors during option processing",stat);
	return Exit_Pilot;
    }
    stat = Exit_Done;
    argc -= optind;
    argv += optind;

    if (basedir == NULL) {
	CatPtrLen = BUFSIZ + strlen(SUBSUFF) + 1;
	Buffer = (u_char *)Malloc(CatPtrLen);
	CatPtr = Buffer;
	*Buffer  = '\0';
    } else {
	CatPtrLen = strlen(basedir) + BUFSIZ + strlen(SUBSUFF) + 1;
	Buffer = (u_char *)Malloc(CatPtrLen);
	strlcpy(Buffer, basedir, CatPtrLen);
	CatPtr = Buffer + strlen(basedir);
	CatPtrLen -= strlen(basedir);
	if (CatPtr[-1] != '/') {
		strlcat(Buffer, "/", CatPtrLen);
		CatPtr++;
		CatPtrLen--;
	}
    }
    strlcat(Buffer, CTM_STATUS, BUFSIZ);

    if(ListIt)
	applied = 0;
    else
	if((statfile = fopen(Buffer, "r")) == NULL) {
	    if (Verbose > 0)
	    	warnx("warning: %s not found", Buffer);
	} else {
	    fscanf(statfile, "%*s %u", &applied);
	    fclose(statfile);
	}

    if(!argc)
	stat |= Proc("-", applied);

    while(argc-- && stat == Exit_Done) {
	stat |= Proc(*argv++, applied);
	stat &= ~(Exit_Version | Exit_NoMatch);
    }

    if(stat == Exit_Done)
	stat = Exit_OK;

    if(Verbose > 0)
	warnx("exit(%d)",stat);

    if (FilterList)
	for (nfilter = FilterList; nfilter; ) {
	    struct CTM_Filter *tmp = nfilter->Next;
	    Free(nfilter);
	    nfilter = tmp;
	}
    return stat;
}

int
Proc(char *filename, unsigned applied)
{
    FILE *f;
    int i;
    char *p = strrchr(filename,'.');

    if(!strcmp(filename,"-")) {
	p = 0;
	f = stdin;
    } else if(p && (!strcmp(p,".gz") || !strcmp(p,".Z"))) {
	p = alloca(20 + strlen(filename));
	strlcpy(p,"gunzip < ", 20 + strlen(filename));
	strlcat(p,filename, 20 + strlen(filename));
	f = popen(p,"r");
	if(!f) { warn("%s", p); return Exit_Garbage; }
    } else {
	p = 0;
	f = fopen(filename,"r");
    }
    if(!f) {
	warn("%s", filename);
	return Exit_Garbage;
    }

    if(Verbose > 1)
	fprintf(stderr,"Working on <%s>\n",filename);

    Delete(FileName);
    FileName = String(filename);

    /* If we cannot seek, we're doomed, so copy to a tmp-file in that case */
    if(!p &&  -1 == fseek(f,0,SEEK_END)) {
	char *fn;
	FILE *f2;
	int fd;

	if (asprintf(&fn, "%s/CTMclient.XXXXXXXXXX", TmpDir) == -1) {
	    fprintf(stderr, "Cannot allocate memory\n");
	    fclose(f);
	    return Exit_Broke;
	}
	if ((fd = mkstemp(fn)) == -1 || (f2 = fdopen(fd, "w+")) == NULL) {
 	    warn("%s", fn);
	    free(fn);
	    if (fd != -1)
		close(fd);
 	    fclose(f);
 	    return Exit_Broke;
 	}
	unlink(fn);
	if (Verbose > 0)
	    fprintf(stderr,"Writing tmp-file \"%s\"\n",fn);
	free(fn);
	while(EOF != (i=getc(f)))
	    if(EOF == putc(i,f2)) {
		fclose(f2);
		return Exit_Broke;
	    }
	fclose(f);
	f = f2;
    }

    if(!p)
	rewind(f);

    if((i=Pass1(f, applied)))
	goto exit_and_close;

    if(ListIt) {
	i = Exit_Done;
	goto exit_and_close;
    }

    if(!p) {
        rewind(f);
    } else {
	pclose(f);
	f = popen(p,"r");
	if(!f) { warn("%s", p); return Exit_Broke; }
    }

    i=Pass2(f);

    if(!p) {
        rewind(f);
    } else {
	pclose(f);
	f = popen(p,"r");
	if(!f) { warn("%s", p); return Exit_Broke; }
    }

    if(i) {
	if((!Force) || (i & ~Exit_Forcible))
	    goto exit_and_close;
    }

    if(CheckIt) {
	if (Verbose > 0)
	    fprintf(stderr,"All checks out ok.\n");
	i = Exit_Done;
	goto exit_and_close;
    }

    /* backup files if requested */
    if(BackupFile) {

	i = PassB(f);

	if(!p) {
	    rewind(f);
	} else {
	    pclose(f);
	    f = popen(p,"r");
	    if(!f) { warn("%s", p); return Exit_Broke; }
	}
    }

    i=Pass3(f);

exit_and_close:
    if(!p)
        fclose(f);
    else
	pclose(f);

    if(i)
	return i;

    if (Verbose > 0)
	fprintf(stderr,"All done ok\n");

    return Exit_Done;
}
@


1.1
log
@Initial revision
@
text
@d1 1
d80 1
a80 1
	    case 'F': Force = 1;	break; 
d103 1
a103 1
		if (0 != (err = 
d108 1
a108 1
			regerror(err, &nfilter->CompiledRegex, errmsg, 
d116 1
a116 1
		nfilter->Action = 
d125 1
a125 1
		  LastFilter = nfilter;	
d151 2
a152 1
	Buffer = (u_char *)Malloc(BUFSIZ + strlen(SUBSUFF) +1);
d156 3
a158 2
	Buffer = (u_char *)Malloc(strlen(basedir)+ BUFSIZ + strlen(SUBSUFF) +1);
	strcpy(Buffer, basedir);
d160 1
d162 1
a162 1
		strcat(Buffer, "/");
d164 1
d167 1
a167 1
    strcat(Buffer, CTM_STATUS);
d169 1
a169 1
    if(ListIt) 
d215 2
a216 2
	strcpy(p,"gunzip < ");
	strcat(p,filename);
d301 1
a301 1
	if (Verbose > 0) 
d306 1
a306 1
   
@


1.1.1.1
log
@Import CTM from FreeBSD-current
@
text
@@
