head	1.3;
access;
symbols
	MIRBSD_7quater:1.1.1.4
	cvs-200405160640:1.1.1.6
	cvs-200401271800:1.1.1.5
	cvs-200401261630:1.1.1.5
	cvs-200401021645:1.1.1.4
	MIRBSD_7_ALPHA:1.1.1.4.0.6
	MIRBSD_7:1.1.1.4.0.4
	cvs-200312222040:1.1.1.4
	MIRBSD_7ter:1.1.1.4
	MIRBSD_7_DEV:1.1.1.4.0.2
	cvs-200310020700:1.1.1.4
	cvs-200309271030:1.1.1.4
	cvs-200309251530:1.1.1.4
	cvs-200308302005:1.1.1.4
	cvs-200308171200:1.1.1.4
	ctm-3496:1.1.1.4
	ctm-3449:1.1.1.4
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.21.45.53;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.04.15.20.12.18;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.53.11;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.53.11;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.55.15;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.43.57;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.53.28;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.01.26.19.00.00;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.16.08.10.19;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@there you go, BSD-licenced nm(1) and size(1)
in favour of a BFD-based multi-platform one

after discussion on miros-discuss@@
@
text
@/*	$OpenBSD: nm.c,v 1.16 2002/02/16 21:27:50 millert Exp $	*/
/*	$NetBSD: nm.c,v 1.7 1996/01/14 23:04:03 pk Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Hans Huebner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)nm.c	8.1 (Berkeley) 6/6/93";
#endif
static char rcsid[] = "$OpenBSD: nm.c,v 1.16 2002/02/16 21:27:50 millert Exp $";
#endif /* not lint */

#include <sys/param.h>
#include <sys/types.h>
#include <a.out.h>
#include <stab.h>
#include <ar.h>
#include <ranlib.h>
#include <unistd.h>
#include <err.h>
#include <ctype.h>
#include <link.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/* XXX get shared code to handle byte-order swaps */
#include "byte.c"


int demangle = 0;
int ignore_bad_archive_entries = 1;
int print_only_external_symbols;
int print_only_undefined_symbols;
int print_all_symbols;
int print_file_each_line;
int show_extensions = 0;
int fcount;

int rev;
int fname(const void *, const void *);
int rname(const void *, const void *);
int value(const void *, const void *);
int (*sfunc)(const void *, const void *) = fname;
char *otherstring(struct nlist *);
char *typestring(unsigned int);
char typeletter(unsigned int);


/* some macros for symbol type (nlist.n_type) handling */
#define	IS_DEBUGGER_SYMBOL(x)	((x) & N_STAB)
#define	IS_EXTERNAL(x)		((x) & N_EXT)
#define	SYMBOL_TYPE(x)		((x) & (N_TYPE | N_STAB))

void	*emalloc(size_t);
void	 pipe2cppfilt(void);
void	 usage(void);
char	*symname(struct nlist *);
void 	print_symbol(const char *, struct nlist *);

/*
 * main()
 *	parse command line, execute process_file() for each file
 *	specified on the command line.
 */
main(argc, argv)
	int argc;
	char **argv;
{
	extern int optind;
	int ch, errors;

	while ((ch = getopt(argc, argv, "aBCegnopruw")) != -1) {
		switch (ch) {
		case 'a':
			print_all_symbols = 1;
			break;
		case 'B':
			/* no-op, compat with gnu-nm */
			break;
		case 'C':
			demangle = 1;
			break;
		case 'e':
			show_extensions = 1;
			break;
		case 'g':
			print_only_external_symbols = 1;
			break;
		case 'n':
			sfunc = value;
			break;
		case 'o':
			print_file_each_line = 1;
			break;
		case 'p':
			sfunc = NULL;
			break;
		case 'r':
			rev = 1;
			break;
		case 'u':
			print_only_undefined_symbols = 1;
			break;
		case 'w':
			ignore_bad_archive_entries = 0;
			break;
		case '?':
		default:
			usage();
		}
	}

	if (demangle)
		pipe2cppfilt();
	fcount = argc - optind;
	argv += optind;

	if (rev && sfunc == fname)
		sfunc = rname;

	if (!fcount)
		errors = process_file("a.out");
	else {
		errors = 0;
		do {
			errors |= process_file(*argv);
		} while (*++argv);
	}
	exit(errors);
}

/*
 * process_file()
 *	show symbols in the file given as an argument.  Accepts archive and
 *	object files as input.
 */
process_file(fname)
	char *fname;
{
	struct exec exec_head;
	FILE *fp;
	int retval;
	char magic[SARMAG];
    
	if (!(fp = fopen(fname, "r"))) {
		warn("cannot read %s", fname);
		return(1);
	}

	if (fcount > 1)
		(void)printf("\n%s:\n", fname);
    
	/*
	 * first check whether this is an object file - read a object
	 * header, and skip back to the beginning
	 */
	if (fread((char *)&exec_head, sizeof(exec_head), (size_t)1, fp) != 1) {
		warnx("%s: bad format", fname);
		(void)fclose(fp);
		return(1);
	}
	rewind(fp);

	if (BAD_OBJECT(exec_head)) {
	/* this could be an archive */
		if (fread(magic, sizeof(magic), (size_t)1, fp) != 1 ||
		    strncmp(magic, ARMAG, SARMAG)) {
			warnx("%s: not object file or archive", fname);
			(void)fclose(fp);
			return(1);
		}
		retval = show_archive(fname, fp);
	} else
		retval = show_objfile(fname, fp);
	(void)fclose(fp);
	return(retval);
}

/*
 * show_archive()
 *	show symbols in the given archive file
 */
show_archive(fname, fp)
	char *fname;
	FILE *fp;
{
	struct ar_hdr ar_head;
	struct exec exec_head;
	int i, rval;
	long last_ar_off;
	char *p, *name;
	int baselen, namelen;

	baselen = strlen(fname) + 3;
	namelen = sizeof(ar_head.ar_name);
	name = emalloc(baselen + namelen);

	rval = 0;

	/* while there are more entries in the archive */
	while (fread((char *)&ar_head, sizeof(ar_head), (size_t)1, fp) == 1) {
		/* bad archive entry - stop processing this archive */
		if (strncmp(ar_head.ar_fmag, ARFMAG, sizeof(ar_head.ar_fmag))) {
			warnx("%s: bad format archive header", fname);
			(void)free(name);
			return(1);
		}

		/* remember start position of current archive object */
		last_ar_off = ftell(fp);

		/* skip ranlib entries */
		if (!strncmp(ar_head.ar_name, RANLIBMAG, sizeof(RANLIBMAG) - 1))
			goto skip;

		/*
		 * construct a name of the form "archive.a:obj.o:" for the
		 * current archive entry if the object name is to be printed
		 * on each output line
		 */
		p = name;
		if (print_file_each_line)
			p += sprintf(p, "%s:", fname);
#ifdef AR_EFMT1
		/*
		 * BSD 4.4 extended AR format: #1/<namelen>, with name as the
		 * first <namelen> bytes of the file
		 */
		if (		(ar_head.ar_name[0] == '#') &&
				(ar_head.ar_name[1] == '1') &&
				(ar_head.ar_name[2] == '/') && 
				(isdigit(ar_head.ar_name[3]))) {

			int len = atoi(&ar_head.ar_name[3]);
			if (len > namelen) {
				p -= (long)name;
				if ((name = realloc(name, baselen+len)) == NULL)
					err(1, NULL);
				namelen = len;
				p += (long)name;
			}
			if (fread(p, len, 1, fp) != 1) {
				warnx("%s: premature EOF", name);
				(void)free(name);
				return 1;
			}
			p += len;
		} else
#endif
		for (i = 0; i < sizeof(ar_head.ar_name); ++i)
			if (ar_head.ar_name[i] && ar_head.ar_name[i] != ' ')
				*p++ = ar_head.ar_name[i];
		*p++ = '\0';

		/* get and check current object's header */
		if (fread((char *)&exec_head, sizeof(exec_head),
		    (size_t)1, fp) != 1) {
			warnx("%s: premature EOF", name);
			(void)free(name);
			return(1);
		}

		if (BAD_OBJECT(exec_head)) {
			if (!ignore_bad_archive_entries) {
				 warnx("%s: bad format", name);
				rval = 1;
			}
		} else {
			(void)fseek(fp, (long)-sizeof(exec_head), SEEK_CUR);
			if (!print_file_each_line)
				(void)printf("\n%s:\n", name);
			rval |= show_objfile(name, fp);
		}

		/*
		 * skip to next archive object - it starts at the next
	 	 * even byte boundary
		 */
#define even(x) (((x) + 1) & ~1)
skip:		if (fseek(fp, last_ar_off + even(atol(ar_head.ar_size)),
		    SEEK_SET)) {
			warn("%s", fname);
			(void)free(name);
			return(1);
		}
	}
	(void)free(name);
	return(rval);
}

/*
 * show_objfile()
 *	show symbols from the object file pointed to by fp.  The current
 *	file pointer for fp is expected to be at the beginning of an a.out
 *	header.
 */
show_objfile(objname, fp)
	char *objname;
	FILE *fp;
{
	struct nlist *names, *np;
	struct nlist **snames;
	int i, nnames, nrawnames;
	struct exec head;
	long stabsize;
	char *stab;

	/* read a.out header */
	if (fread((char *)&head, sizeof(head), (size_t)1, fp) != 1) {
		warnx("%s: cannot read header", objname);
		return(1);
	}

	/*
	 * skip back to the header - the N_-macros return values relative
	 * to the beginning of the a.out header
	 */
	if (fseek(fp, (long)-sizeof(head), SEEK_CUR)) {
		warn("%s", objname);
		return(1);
	}

	/* stop if this is no valid object file, or a format we don't dare
	 * playing with
	 */
	if (BAD_OBJECT(head)) {
		warnx("%s: bad format", objname);
		return(1);
	}

	fix_header_order(&head);

	/* stop if the object file contains no symbol table */
	if (!head.a_syms) {
		warnx("%s: no name list", objname);
		return(1);
	}

	if (fseek(fp, (long)N_SYMOFF(head), SEEK_CUR)) {
		warn("%s", objname);
		return(1);
	}

	/* get memory for the symbol table */
	names = emalloc((size_t)head.a_syms);
	nrawnames = head.a_syms / sizeof(*names);
	snames = emalloc(nrawnames*sizeof(struct nlist *));
	if (fread((char *)names, (size_t)head.a_syms, (size_t)1, fp) != 1) {
		warnx("%s: cannot read symbol table", objname);
		(void)free((char *)names);
		return(1);
	}
	fix_nlists_order(names, nrawnames, N_GETMID(head));

	/*
	 * Following the symbol table comes the string table.  The first
	 * 4-byte-integer gives the total size of the string table
	 * _including_ the size specification itself.
	 */
	if (fread((char *)&stabsize, sizeof(stabsize), (size_t)1, fp) != 1) {
		warnx("%s: cannot read stab size", objname);
		(void)free((char *)names);
		return(1);
	}
	stabsize = fix_long_order(stabsize, N_GETMID(head));
	stab = emalloc((size_t)stabsize);

	/*
	 * read the string table offset by 4 - all indices into the string
	 * table include the size specification.
	 */
	stabsize -= 4;		/* we already have the size */
	if (fread(stab + 4, (size_t)stabsize, (size_t)1, fp) != 1) {
		warnx("%s: stab truncated..", objname);
		(void)free((char *)names);
		(void)free(stab);
		return(1);
	}

	/*
	 * fix up the symbol table and filter out unwanted entries
	 *
	 * common symbols are characterized by a n_type of N_UNDF and a
	 * non-zero n_value -- change n_type to N_COMM for all such
	 * symbols to make life easier later.
	 *
	 * filter out all entries which we don't want to print anyway
	 */
	for (np = names, i = nnames = 0; i < nrawnames; np++, i++) {
		/*
		 * make n_un.n_name a character pointer by adding the string
		 * table's base to n_un.n_strx
		 *
		 * don't mess with zero offsets
		 */
		if (np->n_un.n_strx)
			np->n_un.n_name = stab + np->n_un.n_strx;
		else
			np->n_un.n_name = "";
		if (SYMBOL_TYPE(np->n_type) == N_UNDF && np->n_value)
			np->n_type = N_COMM | (np->n_type & N_EXT);
		if (!print_all_symbols && IS_DEBUGGER_SYMBOL(np->n_type))
			continue;
		if (print_only_external_symbols && !IS_EXTERNAL(np->n_type))
			continue;
		if (print_only_undefined_symbols &&
		    SYMBOL_TYPE(np->n_type) != N_UNDF)
			continue;

		snames[nnames++] = np;
	}

	/* sort the symbol table if applicable */
	if (sfunc)
		qsort(snames, (size_t)nnames, sizeof(*snames), sfunc);

	/* print out symbols */
	for (i = 0; i < nnames; i++) {
		if (show_extensions && snames[i] != names &&
		    SYMBOL_TYPE((snames[i] -1)->n_type) == N_INDR)
			continue;
		print_symbol(objname, snames[i]);
	}

	(void)free(snames);
	(void)free(names);
	(void)free(stab);
	return(0);
}

char *
symname(sym)
	struct nlist *sym;
{
	if (demangle && sym->n_un.n_name[0] == '_') 
		return sym->n_un.n_name + 1;
	else
		return sym->n_un.n_name;
}

/*
 * print_symbol()
 *	show one symbol
 */
void
print_symbol(objname, sym)
	const char *objname;
	struct nlist *sym;
{
	if (print_file_each_line)
		(void)printf("%s:", objname);

	/*
	 * handle undefined-only format especially (no space is
	 * left for symbol values, no type field is printed)
	 */
	if (!print_only_undefined_symbols) {
		/* print symbol's value */
		if (SYMBOL_TYPE(sym->n_type) == N_UNDF || 
		    (show_extensions && SYMBOL_TYPE(sym->n_type) == N_INDR && 
		     sym->n_value == 0))
			(void)printf("        ");
		else
			(void)printf("%08lx", sym->n_value);

		/* print type information */
		if (IS_DEBUGGER_SYMBOL(sym->n_type))
			(void)printf(" - %02x %04x %5s ", sym->n_other,
			    sym->n_desc&0xffff, typestring(sym->n_type));
		else if (show_extensions)
			(void)printf(" %c%2s ", typeletter(sym->n_type),
			    otherstring(sym));
		else
			(void)printf(" %c ", typeletter(sym->n_type));
	}

	if (SYMBOL_TYPE(sym->n_type) == N_INDR && show_extensions) {
		printf("%s -> %s\n", symname(sym), symname(sym+1));
	}
	else
		(void)puts(symname(sym));
}

char *
otherstring(sym)
	struct nlist *sym;
{
	static char buf[3];
	char *result;

	result = buf;

	if (N_BIND(sym) == BIND_WEAK)
		*result++ = 'w';
	if (N_AUX(sym) == AUX_OBJECT)
		*result++ = 'o';
	else if (N_AUX(sym) == AUX_FUNC)
		*result++ = 'f';
	*result++ = 0;
	return buf;
}

/*
 * typestring()
 *	return the a description string for an STAB entry
 */
char *
typestring(type)
	unsigned int type;
{
	switch(type) {
	case N_BCOMM:
		return("BCOMM");
	case N_ECOML:
		return("ECOML");
	case N_ECOMM:
		return("ECOMM");
	case N_ENTRY:
		return("ENTRY");
	case N_FNAME:
		return("FNAME");
	case N_FUN:
		return("FUN");
	case N_GSYM:
		return("GSYM");
	case N_LBRAC:
		return("LBRAC");
	case N_LCSYM:
		return("LCSYM");
	case N_LENG:
		return("LENG");
	case N_LSYM:
		return("LSYM");
	case N_PC:
		return("PC");
	case N_PSYM:
		return("PSYM");
	case N_RBRAC:
		return("RBRAC");
	case N_RSYM:
		return("RSYM");
	case N_SLINE:
		return("SLINE");
	case N_SO:
		return("SO");
	case N_SOL:
		return("SOL");
	case N_SSYM:
		return("SSYM");
	case N_STSYM:
		return("STSYM");
	}
	return("???");
}

/*
 * typeletter()
 *	return a description letter for the given basic type code of an
 *	symbol table entry.  The return value will be upper case for
 *	external, lower case for internal symbols.
 */
char
typeletter(type)
	unsigned int type;
{
	switch(SYMBOL_TYPE(type)) {
	case N_ABS:
		return(IS_EXTERNAL(type) ? 'A' : 'a');
	case N_BSS:
		return(IS_EXTERNAL(type) ? 'B' : 'b');
	case N_COMM:
		return(IS_EXTERNAL(type) ? 'C' : 'c');
	case N_DATA:
		return(IS_EXTERNAL(type) ? 'D' : 'd');
	case N_FN:
		/* NOTE: N_FN == N_WARNING,
		 * in this case, the N_EXT bit is to considered as
		 * part of the symbol's type itself.
		 */
		return(IS_EXTERNAL(type) ? 'F' : 'W');
	case N_TEXT:
		return(IS_EXTERNAL(type) ? 'T' : 't');
	case N_INDR:
		return(IS_EXTERNAL(type) ? 'I' : 'i');
	case N_SIZE:
		return(IS_EXTERNAL(type) ? 'S' : 's');
	case N_UNDF:
		return(IS_EXTERNAL(type) ? 'U' : 'u');
	}
	return('?');
}

int
fname(a0, b0)
	const void *a0, *b0;
{
	struct nlist * const *a = a0, * const *b = b0;

	return(strcmp((*a)->n_un.n_name, (*b)->n_un.n_name));
}

int
rname(a0, b0)
	const void *a0, *b0;
{
	struct nlist * const *a = a0, * const *b = b0;

	return(strcmp((*b)->n_un.n_name, (*a)->n_un.n_name));
}

int
value(a0, b0)
	const void *a0, *b0;
{
	struct nlist * const *a = a0, * const *b = b0;

	if (SYMBOL_TYPE((*a)->n_type) == N_UNDF)
		if (SYMBOL_TYPE((*b)->n_type) == N_UNDF)
			return(0);
		else
			return(-1);
	else if (SYMBOL_TYPE((*b)->n_type) == N_UNDF)
		return(1);
	if (rev) {
		if ((*a)->n_value == (*b)->n_value)
			return(rname(a0, b0));
		return((*b)->n_value > (*a)->n_value ? 1 : -1);
	} else {
		if ((*a)->n_value == (*b)->n_value)
			return(fname(a0, b0));
		return((*a)->n_value > (*b)->n_value ? 1 : -1);
	}
}

void *
emalloc(size)
	size_t size;
{
	char *p;

	/* NOSTRICT */
	if (p = malloc(size))
		return(p);
	err(1, NULL);
}

#define CPPFILT	"/usr/bin/c++filt"

void
pipe2cppfilt()
{
	int pip[2];
	char *argv[2];

	argv[0] = "c++filt";
	argv[1] = NULL;

	if (pipe(pip) == -1)
		err(1, "pipe");
	switch(fork()) {
	case -1:
		err(1, "fork");
	default:
		dup2(pip[0], 0);
		close(pip[0]);
		close(pip[1]);
		execve(CPPFILT, argv, NULL);
		err(1, "execve");
	case 0:
		dup2(pip[1], 1);
		close(pip[1]);
		close(pip[0]);
	}
}

void
usage()
{
	(void)fprintf(stderr, "usage: nm [-aCgnopruw] [file ...]\n");
	exit(1);
}
@


1.2
log
@clean up after cvs
fix some stuff

in the hope to fully have removed sys_mhint... they implemented
it in the name of sys_mquery *d'oh*
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.17 2003/04/05 17:15:06 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.17 2003/04/05 17:15:06 deraadt Exp $";
d262 2
a263 4
		if (print_file_each_line) {
			snprintf(p, baselen, "%s:", fname);
			p += strlen(p);
		}
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.18 2003/06/03 02:56:14 millert Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.18 2003/06/03 02:56:14 millert Exp $";
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.19 2003/06/10 22:20:49 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.19 2003/06/10 22:20:49 deraadt Exp $";
d101 3
a103 1
main(int argc, char *argv[])
d173 2
a174 1
process_file(char *fname)
d219 3
a221 1
show_archive(char *fname, FILE *fp)
d335 3
a337 1
show_objfile(char *objname, FILE *fp)
d470 2
a471 1
symname(struct nlist *sym)
d484 3
a486 1
print_symbol(const char *objname, struct nlist *sym)
d523 2
a524 1
otherstring(struct nlist *sym)
d546 2
a547 1
typestring(unsigned int type)
d601 2
a602 1
typeletter(unsigned int type)
d632 2
a633 1
fname(const void *a0, const void *b0)
d641 2
a642 1
rname(const void *a0, const void *b0)
d650 2
a651 1
value(const void *a0, const void *b0)
d674 2
a675 1
emalloc(size_t size)
d688 1
a688 1
pipe2cppfilt(void)
d715 1
a715 1
usage(void)
@


1.1.1.5
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.23 2004/01/14 04:23:26 millert Exp $	*/
d37 1
a37 1
static const char copyright[] =
d42 1
d44 1
a44 1
static const char sccsid[] = "@@(#)nm.c	8.1 (Berkeley) 6/6/93";
d46 2
a47 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.23 2004/01/14 04:23:26 millert Exp $";
d50 1
a50 1
#include <sys/mman.h>
a51 1
#include <elf_abi.h>
a56 1
#include <errno.h>
a58 3
#ifdef __ELF__
#include <link_aout.h>
#endif
a61 1
#include <getopt.h>
a63 1
#include "elf.c"
a64 4
#ifdef MID_MACHINE_OVERRIDE
#undef MID_MACHINE
#define	MID_MACHINE	MID_MACHINE_OVERRIDE
#endif
d66 2
a67 11
#define	SYMTABMAG	"/ "
#define	STRTABMAG	"//"

union hdr {
	struct exec aout;
	Elf_Ehdr elf;
};

int armap;
int demangle;
int non_object_warning;
d72 2
a73 7
int show_extensions;
int issize;
int usemmap = 1;

/* size vars */
unsigned long total_text, total_data, total_bss, total_total;
int non_object_warning, print_totals;
d82 2
a83 1
char typeletter(struct nlist *, int);
d90 1
d94 1
a94 24
int	process_file(int, const char *);
int	show_archive(int, const char *, FILE *);
int	show_file(int, int, const char *, FILE *fp, off_t, union hdr *);
void 	print_symbol(const char *, struct nlist *, int);
int	elf_symload(const char *, FILE *, off_t, Elf_Ehdr *, Elf_Shdr *);

#define	OPTSTRING_NM	"aABCegnoprsuvVw"
const struct option longopts_nm[] = {
	{ "debug-syms",		no_argument,		0,	'a' },
	{ "demangle",		no_argument,		0,	'C' },
/*	{ "dynamic",		no_argument,		0,	'D' }, */
	{ "extern-only",	no_argument,		0,	'g' },
/*	{ "line-numbers",	no_argument,		0,	'l' }, */
	{ "no-sort",		no_argument,		0,	'p' },
	{ "numeric-sort",	no_argument,		0,	'n' },
	{ "print-armap",	no_argument,		0,	's' },
	{ "print-file-name",	no_argument,		0,	'o' },
	{ "reverse-sort",	no_argument,		0,	'r' },
/*	{ "size-sort",		no_argument,		&szval,	1 }, */
	{ "undefined-only",	no_argument,		0,	'u' },
	{ "version",		no_argument,		0,	'V' },
	{ "help",		no_argument,		0,	'?' },
	{ NULL }
};
a100 1
int
a102 1
	extern char *__progname;
d104 1
a104 11
	const char *optstr;
	const struct option *lopts;
	int ch, eval;

	optstr = OPTSTRING_NM;
	lopts = longopts_nm;
	if (!strcmp(__progname, "size")) {
		issize++;
		optstr = "tw";
		lopts = NULL;
	}
d106 1
a106 1
	while ((ch = getopt_long(argc, argv, optstr, lopts, NULL)) != -1) {
a123 1
		case 'v':
a125 1
		case 'A':
a134 3
		case 's':
			armap = 1;
			break;
a137 3
		case 'V':
			fprintf(stderr, "%s\n", rcsid);
			exit(0);
d139 1
a139 1
			non_object_warning = 1;
a140 5
		case 't':
			if (issize) {
				print_totals = 1;
				break;
			}
d149 1
a150 1
	argc -= optind;
d155 4
a158 2
	eval = 0;
	if (*argv)
d160 1
a160 1
			eval |= process_file(argc, *argv);
d162 2
a163 8
	else
		eval |= process_file(1, "a.out");

	if (issize && print_totals)
		printf("\n%lu\t%lu\t%lu\t%lu\t%lx\tTOTAL\n",
		    total_text, total_data, total_bss,
		    total_total, total_total);
	exit(eval);
d171 1
a171 2
int
process_file(int count, const char *fname)
d173 1
a173 1
	union hdr exec_head;
d183 1
a183 1
	if (!issize && count > 1)
d197 1
a198 1
	if (!IS_ELF(exec_head.elf) && N_BADMAG(exec_head.aout)) {
d205 1
a205 1
		retval = show_archive(count, fname, fp);
d207 1
a207 1
		retval = show_file(count, 1, fname, fp, 0, &exec_head);
a211 201
char *nametab;

/*
 *
 *	given the archive member header -- produce member name
 */
int
mmbr_name(struct ar_hdr *arh, char **name, int baselen, int *namelen, FILE *fp)
{
	char *p = *name + strlen(*name);
	long i;

	if (nametab && arh->ar_name[0] == '/') {
		int len;

		i = atol(&arh->ar_name[1]);
		len = strlen(&nametab[i]);
		if (len > *namelen) {
			p -= (long)*name;
			if ((*name = realloc(*name, baselen+len)) == NULL)
				err(1, NULL);
			*namelen = len;
			p += (long)*name;
		}
		strlcpy(p, &nametab[i], len);
		p += len;
	} else
#ifdef AR_EFMT1
	/*
	 * BSD 4.4 extended AR format: #1/<namelen>, with name as the
	 * first <namelen> bytes of the file
	 */
	if ((arh->ar_name[0] == '#') &&
	    (arh->ar_name[1] == '1') &&
	    (arh->ar_name[2] == '/') && 
	    (isdigit(arh->ar_name[3]))) {
		int len = atoi(&arh->ar_name[3]);

		if (len > *namelen) {
			p -= (long)*name;
			if ((*name = realloc(*name, baselen+len)) == NULL)
				err(1, NULL);
			*namelen = len;
			p += (long)*name;
		}
		if (fread(p, len, 1, fp) != 1) {
			warnx("%s: premature EOF", *name);
			free(*name);
			return(1);
		}
		p += len;
	} else
#endif
	for (i = 0; i < sizeof(arh->ar_name); ++i)
		if (arh->ar_name[i] && arh->ar_name[i] != ' ')
			*p++ = arh->ar_name[i];
	*p = '\0';
	if (p[-1] == '/')
		*--p = '\0';

	return (0);
}

#define	MMAP(ptr, len, prot, flags, fd, off)	do {		\
	if ((ptr = mmap(NULL, len, prot, flags, fd, off)) == MAP_FAILED) { \
		usemmap = 0;						\
		if (errno != EINVAL)					\
			warn("mmap");					\
		else if ((ptr = malloc(len)) == NULL) {			\
			ptr = MAP_FAILED;				\
			warn("malloc");					\
		} else if (pread(fd, ptr, len, off) != len) {		\
			free(ptr);					\
			ptr = MAP_FAILED;				\
			warn("pread");					\
		}							\
	}								\
} while (0)

#define MUNMAP(addr, len)	do {					\
	if (usemmap)							\
		munmap(addr, len);					\
	else								\
		free(addr);						\
} while (0)

/*
 * show_symtab()
 *	show archive ranlib index (fs5)
 */
int
show_symtab(off_t off, u_long len, const char *name, FILE *fp)
{
	struct ar_hdr ar_head;
	int *symtab, *ps;
	char *strtab, *p;
	int num, rval = 0;
	int namelen;

	MMAP(symtab, len, PROT_READ, MAP_PRIVATE|MAP_FILE, fileno(fp), off);
	if (symtab == MAP_FAILED)
		return (1);

	namelen = sizeof(ar_head.ar_name);
	if ((p = malloc(sizeof(ar_head.ar_name))) == NULL) {
		warn("%s: malloc", name);
		MUNMAP(symtab, len);
	}

	printf("\nArchive index:\n");
	num = betoh32(*symtab);
	strtab = (char *)(symtab + num + 1);
	for (ps = symtab + 1; num--; ps++, strtab += strlen(strtab) + 1) {
		if (fseeko(fp, betoh32(*ps), SEEK_SET)) {
			warn("%s: fseeko", name);
			rval = 1;
			break;
		}

		if (fread(&ar_head, sizeof(ar_head), 1, fp) != 1 ||
		    memcmp(ar_head.ar_fmag, ARFMAG, sizeof(ar_head.ar_fmag))) {
			warnx("%s: member fseeko", name);
			rval = 1;
			break;
		}

		*p = '\0';
		if (mmbr_name(&ar_head, &p, 0, &namelen, fp)) {
			rval = 1;
			break;
		}

		printf("%s in %s\n", strtab, p);
	}

	free(p);
	MUNMAP(symtab, len);
	return (rval);
}

/*
 * show_symdef()
 *	show archive ranlib index (gob)
 */
int
show_symdef(off_t off, u_long len, const char *name, FILE *fp)
{
	struct ranlib *prn, *eprn;
	struct ar_hdr ar_head;
	void *symdef;
	char *strtab, *p;
	u_long size;
	int namelen, rval = 0;

	MMAP(symdef, len, PROT_READ, MAP_PRIVATE|MAP_FILE, fileno(fp), off);
	if (symdef == MAP_FAILED)
		return (1);
	if (usemmap)
		(void)madvise(symdef, len, MADV_SEQUENTIAL);

	namelen = sizeof(ar_head.ar_name);
	if ((p = malloc(sizeof(ar_head.ar_name))) == NULL) {
		warn("%s: malloc", name);
		MUNMAP(symdef, len);
		return (1);
	}

	size = *(u_long *)symdef;
	prn = symdef + sizeof(u_long);
	eprn = prn + size / sizeof(*prn);
	strtab = symdef + sizeof(u_long) + size + sizeof(u_long);

	printf("\nArchive index:\n");
	for (; prn < eprn; prn++) {
		if (fseeko(fp, prn->ran_off, SEEK_SET)) {
			warn("%s: fseeko", name);
			rval = 1;
			break;
		}

		if (fread(&ar_head, sizeof(ar_head), 1, fp) != 1 ||
		    memcmp(ar_head.ar_fmag, ARFMAG, sizeof(ar_head.ar_fmag))) {
			warnx("%s: member fseeko", name);
			rval = 1;
			break;
		}

		*p = '\0';
		if (mmbr_name(&ar_head, &p, 0, &namelen, fp)) {
			rval = 1;
			break;
		}

		printf("%s in %s\n", strtab + prn->ran_un.ran_strx, p);
	}

	free(p);
	MUNMAP(symdef, len);
	return (rval);
}

d216 1
a216 2
int
show_archive(int count, const char *fname, FILE *fp)
d219 1
a219 1
	union hdr exec_head;
d221 2
a222 2
	off_t last_ar_off, foff, symtaboff;
	char *name;
a223 1
	u_long mmbrlen, symtablen;
d227 1
a227 2
	if ((name = malloc(baselen + namelen)) == NULL)
		err(1, NULL);
a229 3
	nametab = NULL;
	symtaboff = 0;
	symtablen = 0;
d232 1
a232 1
	while (fread(&ar_head, sizeof(ar_head), 1, fp) == 1) {
d234 1
a234 1
		if (memcmp(ar_head.ar_fmag, ARFMAG, sizeof(ar_head.ar_fmag))) {
d236 2
a237 2
			rval = 1;
			break;
d241 1
a241 2
		last_ar_off = ftello(fp);
		mmbrlen = atol(ar_head.ar_size);
d243 2
a244 7
		if (strncmp(ar_head.ar_name, RANLIBMAG,
		    sizeof(RANLIBMAG) - 1) == 0) {
			if (!issize && armap &&
			    show_symdef(last_ar_off, mmbrlen, fname, fp)) {
				rval = 1;
				break;
			}
a245 44
		} else if (strncmp(ar_head.ar_name, SYMTABMAG,
		    sizeof(SYMTABMAG) - 1) == 0) {
			/* if nametab hasn't been seen yet -- doit later */
			if (!nametab) {
				symtablen = mmbrlen;
				symtaboff = last_ar_off;
				goto skip;
			}

			/* load the Sys5 long names table */
		} else if (strncmp(ar_head.ar_name, STRTABMAG,
		    sizeof(STRTABMAG) - 1) == 0) {
			char *p;

			if ((nametab = malloc(mmbrlen)) == NULL) {
				warn("%s: nametab", fname);
				rval = 1;
				break;
			}

			if (fread(nametab, mmbrlen, (size_t)1, fp) != 1) {
				warnx("%s: premature EOF", fname);
				rval = 1;
				break;
			}

			for (p = nametab, i = mmbrlen; i--; p++)
				if (*p == '\n')
					*p = '\0';

			if (issize || !armap || !symtablen || !symtaboff)
				goto skip;
		}

		if (!issize && armap && symtablen && symtaboff) {
			if (show_symtab(symtaboff, symtablen, fname, fp)) {
				rval = 1;
				break;
			} else {
				symtaboff = 0;
				symtablen = 0;
				goto skip;
			}
		}
d252 4
a255 7
		*name = '\0';
		if (count > 1)
			snprintf(name, baselen - 1, "%s:", fname);

		if (mmbr_name(&ar_head, &name, baselen, &namelen, fp)) {
			rval = 1;
			break;
d257 30
a286 2

		foff = ftello(fp);
d291 15
a305 3
			warnx("%s: premature EOF", fname);
			rval = 1;
			break;
a307 1
		rval |= show_file(2, non_object_warning, name, fp, foff, &exec_head);
d313 2
a314 1
skip:		if (fseeko(fp, last_ar_off + even(mmbrlen), SEEK_SET)) {
d316 2
a317 2
			rval = 1;
			break;
d320 1
a320 5
	if (nametab) {
		free(nametab);
		nametab = NULL;
	}
	free(name);
a323 5
struct nlist *names;
struct nlist **snames;
char *stab;
int nnames, nrawnames, stabsize;

d325 1
a325 1
 * show_file()
d330 1
a330 2
int
show_file(int count, int warn_fmt, const char *name, FILE *fp, off_t foff, union hdr *head)
d332 12
a343 18
	u_long text, data, bss, total;
	struct nlist *np;
	Elf_Shdr *shdr;
	off_t staboff;
	int i, aout;

	aout = 0;
	if (IS_ELF(head->elf) &&
	    head->elf.e_ident[EI_CLASS] == ELF_TARG_CLASS &&
	    head->elf.e_ident[EI_VERSION] == ELF_TARG_VER) {

		elf_fix_header(&head->elf);

		if ((shdr = malloc(head->elf.e_shentsize *
		    head->elf.e_shnum)) == NULL) {
			warn("%s: malloc shdr", name);
			return (1);
		}
d345 8
a352 5
		if (fseeko(fp, foff + head->elf.e_shoff, SEEK_SET)) {
			warn("%s: fseeko", name);
			free(shdr);
			return (1);
		}
d354 7
a360 6
		if (fread(shdr, head->elf.e_shentsize, head->elf.e_shnum,
		    fp) != head->elf.e_shnum) {
			warnx("%s: premature EOF", name);
			free(shdr);
			return(1);
		}
d362 1
a362 1
		elf_fix_shdrs(&head->elf, shdr);
d364 5
a368 20
		if (issize) {
			text = data = bss = 0;
			for (i = 0; i < head->elf.e_shnum; i++) {
				if (!(shdr[i].sh_flags & SHF_ALLOC))
					;
				else if (shdr[i].sh_flags & SHF_EXECINSTR ||
				    !(shdr[i].sh_flags & SHF_WRITE))
					text += shdr[i].sh_size;
				else if (shdr[i].sh_type == SHT_NOBITS)
					bss += shdr[i].sh_size;
				else
					data += shdr[i].sh_size;
			}
			free(shdr);
		} else {
			i = elf_symload(name, fp, foff, &head->elf, shdr);
			free(shdr);
			if (i)
				return (i);
		}
d370 4
a373 15
	} else if (BAD_OBJECT(head->aout)) {
		if (warn_fmt)
			warnx("%s: bad format", name);
		return (1);
	} else do {
		aout++;

		fix_header_order(&head->aout);

		if (issize) {
			text = head->aout.a_text;
			data = head->aout.a_data;
			bss = head->aout.a_bss;
			break;
		}
d375 10
a384 5
		/* stop if the object file contains no symbol table */
		if (!head->aout.a_syms) {
			warnx("%s: no name list", name);
			return(1);
		}
d386 9
a394 69
		if (fseeko(fp, foff + N_SYMOFF(head->aout), SEEK_SET)) {
			warn("%s", name);
			return(1);
		}

		/* get memory for the symbol table */
		if ((names = malloc(head->aout.a_syms)) == NULL) {
			warn("%s: malloc names", name);
			return (1);
		}
		nrawnames = head->aout.a_syms / sizeof(*names);
		if ((snames = malloc(nrawnames * sizeof(struct nlist *))) == NULL) {
			warn("%s: malloc snames", name);
			free(names);
			return (1);
		}

		if (fread(names, head->aout.a_syms, 1, fp) != 1) {
			warnx("%s: cannot read symbol table", name);
			free(snames);
			free(names);
			return(1);
		}
		fix_nlists_order(names, nrawnames, N_GETMID(head->aout));

		staboff = ftello(fp);
		/*
		 * Following the symbol table comes the string table.
		 * The first 4-byte-integer gives the total size of the
		 * string table _including_ the size specification itself.
		 */
		if (fread(&stabsize, sizeof(stabsize), (size_t)1, fp) != 1) {
			warnx("%s: cannot read stab size", name);
			free(snames);
			free(names);
			return(1);
		}
		MMAP(stab, stabsize, PROT_READ, MAP_PRIVATE|MAP_FILE,
		    fileno(fp), staboff);
		if (stab == MAP_FAILED) {
			free(snames);
			free(names);
			return (1);
		}

		stabsize -= 4;		/* we already have the size */
	} while (0);

	if (issize) {
		static int first = 1;

		if (first) {
			first = 0;
			printf("text\tdata\tbss\tdec\thex\n");
		}

		total = text + data + bss;
		printf("%lu\t%lu\t%lu\t%lu\t%lx",
		    text, data, bss, total, total);
		if (count > 1)
			(void)printf("\t%s", name);

		total_text += text;
		total_data += data;
		total_bss += bss;
		total_total += total;

		printf("\n");
		return (0);
d396 2
a397 1
	/* else we are nm */
d400 2
a401 2
	 * it seems that string table is sequential
	 * relative to the symbol table order
d403 7
a409 2
	if (sfunc == NULL && usemmap)
		(void)madvise(stab, stabsize, MADV_SEQUENTIAL);
d431 1
a431 1
		if (aout && SYMBOL_TYPE(np->n_type) == N_UNDF && np->n_value)
a447 3
	if (count > 1)
		(void)printf("\n%s:\n", name);

d453 1
a453 1
		print_symbol(name, snames[i], aout);
d456 3
a458 3
	free(snames);
	free(names);
	MUNMAP(stab, stabsize);
a461 115
int
elf_symload(const char *name, FILE *fp, off_t foff, Elf_Ehdr *eh, Elf_Shdr *shdr)
{
	long symsize, shstrsize;
	struct nlist *np;
	Elf_Sym sbuf;
	char *shstr;
	int i;

	shstrsize = shdr[eh->e_shstrndx].sh_size;
	if ((shstr = malloc(shstrsize)) == NULL) {
		warn("%s: malloc shsrt", name);
		return (1);
	}

	if (fseeko(fp, foff + shdr[eh->e_shstrndx].sh_offset, SEEK_SET)) {
		warn("%s: fseeko", name);
		free(shstr);
		return (1);
	}

	if (fread(shstr, 1, shstrsize, fp) != shstrsize) {
		warnx("%s: premature EOF", name);
		free(shstr);
		return(1);
	}

	stab = NULL;
	names = NULL; snames = NULL;
	for (i = 0; i < eh->e_shnum; i++) {
		if (!strcmp(shstr + shdr[i].sh_name, ELF_STRTAB)) {
			stabsize = shdr[i].sh_size;
			if (stabsize > SIZE_T_MAX) {
				warnx("%s: corrupt file", name);
				free(shstr);
				return (1);
			}

			MMAP(stab, stabsize, PROT_READ, MAP_PRIVATE|MAP_FILE,
			    fileno(fp), foff + shdr[i].sh_offset);
			if (stab == MAP_FAILED) {
				free(shstr);
				return (1);
			}
		}
	}
	for (i = 0; i < eh->e_shnum; i++) {
		if (!strcmp(shstr + shdr[i].sh_name, ELF_SYMTAB)) {
			symsize = shdr[i].sh_size;
			if (fseeko(fp, foff + shdr[i].sh_offset, SEEK_SET)) {
				warn("%s: fseeko", name);
				if (stab)
					MUNMAP(stab, stabsize);
				free(shstr);
				return (1);
			}

			nrawnames = symsize / sizeof(sbuf);
			if ((names = calloc(nrawnames, sizeof(*np))) == NULL) {
				warn("%s: malloc names", name);
				if (stab)
					MUNMAP(stab, stabsize);
				free(names);
				free(shstr);
				return (1);
			}
			if ((snames = malloc(nrawnames * sizeof(np))) == NULL) {
				warn("%s: malloc snames", name);
				if (stab)
					MUNMAP(stab, stabsize);
				free(shstr);
				free(names);
				free(snames);
				return (1);
			}

			for (np = names; symsize > 0; symsize -= sizeof(sbuf)) {
				if (fread(&sbuf, 1, sizeof(sbuf),
				    fp) != sizeof(sbuf)) {
					warn("%s: read symbol", name);
					if (stab)
						MUNMAP(stab, stabsize);
					free(shstr);
					free(names);
					free(snames);
					return (1);
				}

				elf_fix_sym(eh, &sbuf);

				if (!sbuf.st_name)
					continue;

				elf2nlist(&sbuf, eh, shdr, shstr, np);
				np->n_value = sbuf.st_value;
				np->n_un.n_strx = sbuf.st_name;
				np++;
			}
			nrawnames = np - names;
		}
	}

	free(shstr);
	if (stab == NULL) {
		warnx("%s: no name list", name);
		if (names)
			free(names);
		if (snames)
			free(snames);
		return (1);
	}
		
	return (0);
}

d476 1
a476 1
print_symbol(const char *name, struct nlist *sym, int aout)
d479 1
a479 1
		(void)printf("%s:", name);
d499 1
a499 1
			(void)printf(" %c%2s ", typeletter(sym, aout),
d502 1
a502 1
			(void)printf(" %c ", typeletter(sym, aout));
d589 1
a589 1
typeletter(struct nlist *np, int aout)
d591 1
a591 6
	int ext = IS_EXTERNAL(np->n_type);

	if (!aout && !IS_DEBUGGER_SYMBOL(np->n_type) && np->n_other)
		return np->n_other;

	switch(SYMBOL_TYPE(np->n_type)) {
d593 1
a593 1
		return(ext? 'A' : 'a');
d595 1
a595 1
		return(ext? 'B' : 'b');
d597 1
a597 1
		return(ext? 'C' : 'c');
d599 1
a599 1
		return(ext? 'D' : 'd');
d605 1
a605 1
		return(ext? 'F' : 'W');
d607 1
a607 1
		return(ext? 'T' : 't');
d609 1
a609 1
		return(ext? 'I' : 'i');
d611 1
a611 1
		return(ext? 'S' : 's');
d613 1
a613 1
		return(ext? 'U' : 'u');
d657 11
d700 1
a700 7
	extern char *__progname;

	if (issize)
		fprintf(stderr, "usage: %s [-tw] [file ...]\n", __progname);
	else
		fprintf(stderr, "usage: %s [-aABCegnoprsuvVw] [file ...]\n",
		    __progname);
@


1.1.1.6
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.25 2004/05/04 23:09:07 deraadt Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.25 2004/05/04 23:09:07 deraadt Exp $";
d118 1
a118 1
void	print_symbol(const char *, struct nlist *, int);
a249 1
	size_t bytes;
d251 1
a251 1

d259 1
a259 1

d264 4
a267 8
	bzero(&exec_head, sizeof(exec_head));
	bytes = fread((char *)&exec_head, 1, sizeof(exec_head), fp);
	if (bytes < sizeof(exec_head)) {
		if (bytes < sizeof(exec_head.aout) || IS_ELF(exec_head.elf)) {
			warnx("%s: bad format", fname);
			(void)fclose(fp);
			return(1);
		}
d320 1
a320 1
	    (arh->ar_name[2] == '/') &&
d605 1
a605 1
		 * even byte boundary
d957 1
a957 1

d964 1
a964 1
	if (demangle && sym->n_un.n_name[0] == '_')
d986 3
a988 3
		if (SYMBOL_TYPE(sym->n_type) == N_UNDF ||
		    (show_extensions && SYMBOL_TYPE(sym->n_type) == N_INDR &&
		    sym->n_value == 0))
@


