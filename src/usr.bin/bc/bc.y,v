head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.10
	tg-mergefixes-1-branch:1.1.1.10.0.4
	tg-mergefixes-1-base:1.1.1.10
	MIROS_X:1.1.1.10.0.2
	MIROS_X_BASE:1.1.1.10
	tg-mergetmp-3:1.1.1.10
	cvs-200412031430:1.1.1.10
	MIRBSD_XP_MIRPPC:1.1.1.9.0.4
	cvs-200410222040:1.1.1.10
	tg-mergetmp-1:1.1.1.9
	MIRBSD_XP_SPARC_BASE:1.1.1.9
	MIRBSD_XP_SPARC:1.1.1.9.0.2
	MIRBSD_7quater:1.1.1.4.2.1
	cvs-200405160640:1.1.1.9
	cvs-200401271800:1.1.1.8
	cvs-200401261630:1.1.1.8
	cvs-200401021645:1.1.1.7
	MIRBSD_7_ALPHA:1.1.1.4.2.1.0.4
	MIRBSD_7:1.1.1.4.2.1.0.2
	cvs-200312222040:1.1.1.7
	cvs-200312031730:1.1.1.6
	MIRBSD_7ter:1.1.1.4.2.1
	cvs-200310232020:1.1.1.5
	MIRBSD_7_DEV:1.1.1.4.0.2
	cvs-200310081755:1.1.1.4
	cvs-200310020700:1.1.1.4
	cvs-200309281115:1.1.1.3
	cvs-200309271030:1.1.1.2
	cvs-200309261610:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.09.26.16.12.42;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.09.26.16.12.42;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.09.27.11.19.03;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.09.28.11.21.10;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.10.02.07.49.29;	author tg;	state Exp;
branches
	1.1.1.4.2.1;
next	1.1.1.5;

1.1.1.5
date	2003.10.23.20.23.37;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.17.46.01;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.12.22.21.12.47;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.01.26.18.56.46;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.16.08.06.36;	author tg;	state Stab;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.10.22.20.49.18;	author tg;	state Exp;
branches;
next	;

1.1.1.4.2.1
date	2003.10.23.20.49.09;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@%{
/*	$OpenBSD: bc.y,v 1.2 2003/09/26 07:23:06 otto Exp $	*/

/*
 * Copyright (c) 2003, Otto Moerbeek <otto@@drijf.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This implementation of bc(1) uses concepts from the original 4.4
 * BSD bc(1). The code itself is a complete rewrite, based on the
 * Posix defined bc(1) grammar. Other differences include type safe
 * usage of pointers to build the tree of emitted code, typed yacc
 * rule values, dynamic allocation of all data structures and a
 * completely rewritten lexical analyzer using lex(1).
 *
 * Some effort has been made to make sure that the generated code is
 * the same as the code generated by the older version, to provide
 * easy regression testing.
 */

#ifndef lint
static const char rcsid[] = "$OpenBSD: bc.y,v 1.2 2003/09/26 07:23:06 otto Exp $";
#endif /* not lint */

#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>

#include "extern.h"
#include "pathnames.h"

#define END_NODE	((ssize_t) -1)
#define CONST_STRING	((ssize_t) -2)
#define ALLOC_STRING	((ssize_t) -3)

struct tree {
	ssize_t			index;
	union {
		char		*astr;
		const char	*cstr;
	} u;
};

int			yyparse(void);
int			yywrap(void);
void			yyerror(char *);

static void		grow(void);
static ssize_t		cs(const char *);
static ssize_t		as(const char *);
static ssize_t		node(ssize_t, ...);
static void		emit(ssize_t);
static void		emit_macro(int, ssize_t);
static void		free_tree(void);
static ssize_t		numnode(int);
static void		add_par(ssize_t);
static void		add_local(ssize_t);
static void		fatal(const char *);
static void		warning(const char *);
static void		init(void);
static __dead void	usage(void);

static size_t		instr_sz = 0;
static struct tree	*instructions = NULL;
static size_t		current = 0;
static int		macro_char = '0';
static int		reset_macro_char = '0';
static int		nesting = 0;
static int		breakstack[16];
static int		breaksp = 0;
static ssize_t		prologue;
static ssize_t		epilogue;
static char		str_table[UCHAR_MAX][2];
static int		sargc;
static char		**sargv;
static char		*filename;
static bool		do_fork = true;

extern char *__progname;

#define BREAKSTACK_SZ	(sizeof(breakstack)/sizeof(breakstack[0]))

/* These values are 4.4BSD dc compatible */
#define FUNC_CHAR	0x01
#define ARRAY_CHAR	0xa1

#define LETTER_NODE(str)	(cs(str_table[(int)str[0]]))
#define ARRAY_NODE(str)		(cs(str_table[(int)str[0] - 'a' + ARRAY_CHAR]))
#define FUNCTION_NODE(str)	(cs(str_table[(int)str[0] - 'a' + FUNC_CHAR]))

%}

%start program

%union {
	ssize_t		node;
	struct lvalue	lvalue;
	const char	*str;
}

%token COMMA SEMICOLON LPAR RPAR LBRACE RBRACE LBRACKET RBRACKET
%token ENDOFFILE NEWLINE
%token <str> LETTER NUMBER STRING
%token DEFINE BREAK QUIT LENGTH
%token RETURN FOR IF WHILE SQRT
%token SCALE IBASE OBASE AUTO

%nonassoc EQUALS LESS_EQ GREATER_EQ UNEQUALS LESS GREATER
%right <str> ASSIGN_OP
%left PLUS MINUS
%left MULTIPLY DIVIDE REMAINDER
%left EXPONENT
%nonassoc UMINUS
%nonassoc INCR DECR

%type <lvalue>	named_expression
%type <node>	argument_list
%type <node>	alloc_macro
%type <node>	expression
%type <node>	function
%type <node>	function_header
%type <node>	input_item
%type <node>	opt_argument_list
%type <node>	opt_statement
%type <node>	relational_expression
%type <node>	return_expression
%type <node>	semicolon_list
%type <node>	statement
%type <node>	statement_list

%%

program		: /* empty */
			{
				putchar('q');
				fflush(stdout);
				exit(0);
			}
		| input_item program
		;

input_item	: semicolon_list NEWLINE
			{
				emit($1);
				macro_char = reset_macro_char;
				putchar('\n');
				free_tree();
			}
		| function
			{
				putchar('\n');
				free_tree();
			}
		| error
			{
			}
		;

semicolon_list	: /* empty */
			{
				$$ = cs("");
			}
		| statement
		| semicolon_list SEMICOLON statement
			{
				$$ = node($1, $3, END_NODE);
			}
		| semicolon_list SEMICOLON
		;

statement_list	: /* empty */
			{
				$$ = cs("");
			}
		| statement
		| statement_list NEWLINE
		| statement_list NEWLINE statement
			{
				$$ = node($1, $3, END_NODE);
			}
		| statement_list SEMICOLON
		| statement_list SEMICOLON statement
			{
				$$ = node($1, $3, END_NODE);
			}
		;


opt_statement	: /* empty */
			{
				$$ = cs("");
			}
		| statement
		;

statement	: expression
			{
				$$ = node($1, cs("ps."), END_NODE);
			}
		| named_expression ASSIGN_OP expression
			{
				$$ = node($3, cs($2), $1.store, END_NODE);
			}
		| STRING
			{
				$$ = node(cs("["), as($1),
				    cs("]P"), END_NODE);
			}
		| BREAK
			{
				if (breaksp == 0) {
					warning("break not in for or while");
					YYERROR;
				} else {
					$$ = node(
					    numnode(nesting -
						breakstack[breaksp-1]),
					    cs("Q"), END_NODE);
				}
			}
		| QUIT
			{
				putchar('q');
				fflush(stdout);
				exit(0);
			}
		| RETURN
			{
				if (nesting == 0) {
					warnx("return must be in a function");
					YYERROR;
				}
				$$ = node(cs("0"), epilogue,
				    numnode(nesting), cs("Q"), END_NODE);
			}
		| RETURN LPAR return_expression RPAR
			{
				if (nesting == 0) {
					warnx("return must be in a function");
					YYERROR;
				}
				$$ = $3;
			}
		| FOR LPAR alloc_macro expression SEMICOLON
		     relational_expression SEMICOLON
		     expression RPAR opt_statement pop_nesting
			{
				int n = node($10, $8, cs("s."), $6, $3,
				    END_NODE);
				emit_macro($3, n);
				$$ = node($4, cs("s."), $6, $3, cs(" "),
				    END_NODE);
			}
		| IF LPAR alloc_macro pop_nesting relational_expression RPAR
		      opt_statement
			{
				emit_macro($3, $7);
				$$ = node($5, $3, cs(" "), END_NODE);
			}
		| WHILE LPAR alloc_macro relational_expression RPAR
		      opt_statement pop_nesting
			{
				int n = node($6, $4, $3, END_NODE);
				emit_macro($3, n);
				$$ = node($4, $3, cs(" "), END_NODE);
			}
		| LBRACE statement_list RBRACE
			{
				$$ = $2;
			}
		;

alloc_macro	: /* empty */
			{
				$$ = cs(str_table[macro_char]);
				macro_char++;
				/* Do not use [, \ and ] */
				if (macro_char == '[')
					macro_char += 3;
				/* skip letters */
				else if (macro_char == 'a')
					macro_char = '{';
				else if (macro_char == ARRAY_CHAR)
					macro_char += 26;
				else if (macro_char == 256)
					fatal("program too big");
				if (breaksp == BREAKSTACK_SZ)
					fatal("nesting too deep");
				breakstack[breaksp++] = nesting++;
			}
pop_nesting	: /* empty */
			{
				breaksp--;
			}

function	: function_header opt_parameter_list RPAR
		  LBRACE NEWLINE opt_auto_define_list
		  statement_list RBRACE
			{
				int n = node(prologue, $7, epilogue,
				    cs("0"), numnode(nesting),
				    cs("Q"), END_NODE);
				emit_macro($1, n);
				reset_macro_char = macro_char;
				nesting = 0;
				breaksp = 0;
			}
		;

function_header : DEFINE LETTER LPAR
			{
				$$ = FUNCTION_NODE($2);
				prologue = cs("");
				epilogue = cs("");
				nesting = 1;
				breaksp = 0;
				breakstack[breaksp] = 0;
			}

opt_parameter_list
		: /* empty */
		| parameter_list
		;


parameter_list	: LETTER
			{
				add_par(LETTER_NODE($1));
			}
		| LETTER LBRACKET RBRACKET
			{
				add_par(ARRAY_NODE($1));
			}
		| parameter_list COMMA LETTER
			{
				add_par(LETTER_NODE($3));
			}
		| parameter_list COMMA LETTER LBRACKET RBRACKET
			{
				add_par(ARRAY_NODE($3));
			}
		;



opt_auto_define_list
		: /* empty */
		| AUTO define_list NEWLINE
		| AUTO define_list SEMICOLON
		;


define_list	: LETTER
			{
				add_local(LETTER_NODE($1));
			}
		| LETTER LBRACKET RBRACKET
			{
				add_local(ARRAY_NODE($1));
			}
		| define_list COMMA LETTER
			{
				add_local(LETTER_NODE($3));
			}
		| define_list COMMA LETTER LBRACKET RBRACKET
			{
				add_local(ARRAY_NODE($3));
			}
		;


opt_argument_list
		: /* empty */
			{
				$$ = cs("");
			}
		| argument_list
		;


argument_list	: expression
		| argument_list COMMA expression
			{
				$$ = node($1, $3, END_NODE);
			}
		| argument_list COMMA LETTER LBRACKET RBRACKET
			{
				$$ = node($1, cs("l"), ARRAY_NODE($3),
					  END_NODE);
			}
		;


relational_expression
		: expression
			{
				$$ = node($1, cs(" 0!="), END_NODE);
			}
		| expression EQUALS expression
			{
				$$ = node($1, $3, cs("="), END_NODE);
			}
		| expression UNEQUALS expression
			{
				$$ = node($1, $3, cs("!="), END_NODE);
			}
		| expression LESS expression
			{
				$$ = node($1, $3, cs(">"), END_NODE);
			}
		| expression LESS_EQ expression
			{
				$$ = node($1, $3, cs("!<"), END_NODE);
			}
		| expression GREATER expression
			{
				$$ = node($1, $3, cs("<"), END_NODE);
			}
		| expression GREATER_EQ expression
			{
				$$ = node($1, $3, cs("!>"), END_NODE);
			}
		;


return_expression
		: /* empty */
			{
				$$ = node(cs("0"), epilogue,
				    numnode(nesting), cs("Q"), END_NODE);
			}
		| expression
			{
				$$ = node($1, epilogue,
				    numnode(nesting), cs("Q"), END_NODE);
			}
		;


expression	: named_expression
			{
				$$ = node($1.load, END_NODE);
			}
		| NUMBER
			{
				$$ = node(cs(" "), as($1), END_NODE);
			}
		| LPAR expression RPAR
			{
				$$ = $2;
			}
		| LETTER LPAR opt_argument_list RPAR
			{
				$$ = node($3, cs("l"),
				    FUNCTION_NODE($1), cs("x"),
				    END_NODE);
			}
		| MINUS expression %prec UMINUS
			{
				$$ = node(cs(" 0"), $2, cs("-"),
				    END_NODE);
			}
		| expression PLUS expression
			{
				$$ = node($1, $3, cs("+"), END_NODE);
			}
		| expression MINUS expression
			{
				$$ = node($1, $3, cs("-"), END_NODE);
			}
		| expression MULTIPLY expression
			{
				$$ = node($1, $3, cs("*"), END_NODE);
			}
		| expression DIVIDE expression
			{
				$$ = node($1, $3, cs("/"), END_NODE);
			}
		| expression REMAINDER expression
			{
				$$ = node($1, $3, cs("%"), END_NODE);
			}
		| expression EXPONENT expression
			{
				$$ = node($1, $3, cs("^"), END_NODE);
			}
		| INCR named_expression
			{
				$$ = node($2.load, cs("1+d"), $2.store,
				    END_NODE);
			}
		| DECR named_expression
			{
				$$ = node($2.load, cs("1-d"),
				    $2.store, END_NODE);
			}
		| named_expression INCR
			{
				$$ = node($1.load, cs("d1+"),
				    $1.store, END_NODE);
			}
		| named_expression DECR
			{
				$$ = node($1.load, cs("d1-"),
				    $1.store, END_NODE);
			}
		| named_expression ASSIGN_OP expression
			{
				$$ = node($3, cs($2), cs("d"),
				    $1.store, END_NODE);
			}
		| LENGTH LPAR expression RPAR
			{
				$$ = node($3, cs("Z"), END_NODE);
			}
		| SQRT LPAR expression RPAR
			{
				$$ = node($3, cs("v"), END_NODE);
			}
		| SCALE LPAR expression RPAR
			{
				$$ = node($3, cs("X"), END_NODE);
			}
		;

named_expression
		: LETTER
			{
				$$.load = node(cs("l"), LETTER_NODE($1),
				    END_NODE);
				$$.store = node(cs("s"), LETTER_NODE($1),
				    END_NODE);
			}
		| LETTER LBRACKET expression RBRACKET
			{
				$$.load = node($3, cs(";"),
				    ARRAY_NODE($1), END_NODE);
				$$.store = node($3, cs(":"),
				    ARRAY_NODE($1), END_NODE);
			}
		| SCALE
			{
				$$.load = cs("K");
				$$.store = cs("k");
			}
		| IBASE
			{
				$$.load = cs("I");
				$$.store = cs("i");
			}
		| OBASE
			{
				$$.load = cs("O");
				$$.store = cs("o");
			}
		;
%%


static void
grow(void)
{
	struct tree	*p;
	int		newsize;

	if (current == instr_sz) {
		newsize = instr_sz * 2 + 1;
		p = realloc(instructions, newsize * sizeof(*p));
		if (p == NULL) {
			free(instructions);
			err(1, "cannot realloc instruction buffer");
		}
		instructions = p;
		instr_sz = newsize;
	}
}

static int
cs(const char *str)
{
	grow();
	instructions[current].index = CONST_STRING;
	instructions[current].u.cstr = str;
	return current++;
}

static int
as(const char *str)
{
	grow();
	instructions[current].index = ALLOC_STRING;
	instructions[current].u.astr = strdup(str);
	if (instructions[current].u.astr == NULL)
		err(1, "cannot allocate string");
	return current++;
}

static ssize_t
node(ssize_t arg, ...)
{
	va_list		ap;
	ssize_t		ret;

	va_start(ap, arg);

	ret = current;
	grow();
	instructions[current++].index = arg;

	do {
		arg = va_arg(ap, ssize_t);
		grow();
		instructions[current++].index = arg;
	} while (arg != END_NODE);

	va_end(ap);
	return ret;
}

static void
emit(ssize_t i)
{
	if (instructions[i].index >= 0)
		while (instructions[i].index != END_NODE)
			emit(instructions[i++].index);
	else
		fputs(instructions[i].u.cstr, stdout);
}

static void
emit_macro(int node, ssize_t code)
{
	putchar('[');
	emit(code);
	printf("]s%s\n", instructions[node].u.cstr);
	nesting--;
}

static void
free_tree(void)
{
	size_t i;

	for (i = 0; i < current; i++)
		if (instructions[i].index == ALLOC_STRING)
			free(instructions[i].u.astr);
	current = 0;
}

static ssize_t
numnode(int num)
{
	const char *p;

	if (num < 10)
		p = str_table['0' + num];
	else if (num < 16)
		p = str_table['A' - 10 + num];
	else
		err(1, "internal error: break num > 15");
	return node(cs(" "), cs(p), END_NODE);
}

static void
add_par(ssize_t n)
{
	prologue = node(cs("S"), n, prologue, END_NODE);
	epilogue = node(epilogue, cs("L"), n, cs("s."), END_NODE);
}

static void
add_local(ssize_t n)
{
	prologue = node(cs("0S"), n, prologue, END_NODE);
	epilogue = node(epilogue, cs("L"), n, cs("s."), END_NODE);
}

int
yywrap(void)
{
	lineno = 1;
	if (optind < sargc) {
		filename = sargv[optind++];
		yyin = fopen(filename, "r");
		if (yyin == NULL)
			err(1, "cannot open %s", filename);
		return 0;
	}
	else if (optind == sargc) {
		optind++;
		yyin = stdin;
		filename = "stdin";
		return 0;
	}
	return 1;
}

void
yyerror(char *s)
{
	if (isspace(*yytext) || !isprint(*yytext))
		printf("c[%s:%d: %s: ascii char 0x%x unexpected]pc\n",
		    filename, lineno, s, *yytext);
	else
		printf("c[%s:%d: %s: %s unexpected]pc\n",
		    filename, lineno, s, yytext);
}

static void
fatal(const char *s)
{
	errx(1, "%s:%d: %s", filename, lineno, s);
}

static void
warning(const char *s)
{
	warnx("%s:%d: %s", filename, lineno, s);
}

static void
init(void)
{
	int i;

	for (i = 0; i < UCHAR_MAX; i++) {
		str_table[i][0] = i;
		str_table[i][1] = '\0';
	}
}


static __dead void
usage(void)
{
	fprintf(stderr, "%s: usage: [-c] [-l] [file ...]\n", __progname);
	exit(1);
}


int
main(int argc, char *argv[])
{
	int	ch, ret;
	int	p[2];

	init();
	setlinebuf(stdout);

	/* The d debug option is 4.4 BSD dc(1) compatible */
	while ((ch = getopt(argc, argv, "cdl")) != -1) {
		switch (ch) {
		case 'c':
		case 'd':
			do_fork = false;
			break;
		case 'l':
			argv[1] = _PATH_LIBB;
			optind = 1;
			break;
		default:
		usage();
		}
	}

	sargc = argc;
	sargv = argv;

	if (do_fork) {
		if (pipe(p) == -1)
			err(1, "cannot create pipe");
		ret = fork();
		if (ret == -1)
			err(1, "cannot fork");
		else if (ret == 0) {
			close(STDOUT_FILENO);
			dup(p[1]);
			close(p[0]);
			close(p[1]);
		}
		else {
			signal(SIGINT, SIG_IGN);
			close(STDIN_FILENO);
			dup(p[0]);
			close(p[0]);
			close(p[1]);
			execl(_PATH_DC, "dc", "-", (char *)NULL);
			err(1, "cannot find dc");
		}
	}
	signal(SIGINT, abort_line);
	yywrap();
	return yyparse();
}
@


1.1.1.1
log
@Import Unix bc and dc from OpenBSD-current sources
@
text
@@


1.1.1.2
log
@cvs is playing games with me.

@@@@@@ CONSIDER THE TREE LOCKED NOW @@@@@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.6 2003/09/26 19:26:16 deraadt Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.6 2003/09/26 19:26:16 deraadt Exp $";
d406 1
a406 1
				    END_NODE);
d705 2
a706 1
	} else if (optind == sargc) {
d753 1
a753 1
	fprintf(stderr, "%s: usage: [-cl] [file ...]\n", __progname);
d779 1
a779 1
			usage();
d797 2
a798 1
		} else {
@


1.1.1.3
log
@Bug fixes from OpenBSD
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.8 2003/09/28 07:57:57 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.8 2003/09/28 07:57:57 otto Exp $";
d63 1
d75 1
d82 1
a82 1
static ssize_t		current = 0;
d171 1
a171 1
		| error NEWLINE
a172 1
				yyerrok;
d247 1
a247 1
					warning("return must be in a function");
d256 1
a256 1
					warning("return must be in a function");
d595 1
a595 1
static ssize_t
d604 1
a604 1
static ssize_t
d698 1
a701 1
		lineno = 1;
a707 1
		lineno = 1;
d718 2
a719 2
		printf("c[%s: %s:%d: %s: ascii char 0x%x unexpected]pc\n",
		    __progname, filename, lineno, s, *yytext);
d721 2
a722 2
		printf("c[%s: %s:%d: %s: %s unexpected]pc\n",
		    __progname, filename, lineno, s, yytext);
d725 1
a725 1
void
@


1.1.1.4
log
@Import OpenBSD source tree again, with critical bug fixes
(OpenSSL, bc, dc, sensorsd, pf, ...)
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.10 2003/09/30 18:46:11 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.10 2003/09/30 18:46:11 otto Exp $";
d116 2
a117 2
%token COMMA SEMICOLON LPAR RPAR LBRACE RBRACE LBRACKET RBRACKET DOT
%token NEWLINE
a459 3
		| DOT	{
				$$ = node(cs("l."), END_NODE);
			}
d717 3
a719 5
	char	*str, *p;

	if (isspace(yytext[0]) || !isprint(yytext[0]))
		asprintf(&str, "%s: %s:%d: %s: ascii char 0x%x unexpected",
		    __progname, filename, lineno, s, yytext[0]);
d721 1
a721 1
		asprintf(&str, "%s: %s:%d: %s: %s unexpected",
a722 11
	if (str == NULL)
		err(1, "cannot allocate string");

	fputs("c[", stdout);
	for (p = str; *p != '\0'; p++) {
		if (*p == '[' || *p == ']' || *p =='\\')
			putchar('\\');
		putchar(*p);
	}
	fputs("]pc\n", stdout);
	free(str);
@


1.1.1.4.2.1
log
@that bc/dc fix sync with OpenBSD (must-have fix :)
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.14 2003/10/22 12:24:41 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.14 2003/10/22 12:24:41 otto Exp $";
a87 1
static bool		st_has_continue;
a121 1
%token CONTINUE ELSE
a138 2
%type <node>	opt_expression
%type <node>	opt_relational_expression
a162 1
				st_has_continue = false;
a167 1
				st_has_continue = false;
d218 1
a218 6
				if ($2[0] == '\0')
					$$ = node($3, cs($2), $1.store,
					    END_NODE);
				else
					$$ = node($1.load, $3, cs($2), $1.store,
					    END_NODE);
a236 12
		| CONTINUE
			{
				if (breaksp == 0) {
					warning("continue not in for or while");
					YYERROR;
				} else {
					st_has_continue = true;
					$$ = node(numnode(nesting -
					    breakstack[breaksp-1] - 1),
					    cs("J"), END_NODE);
				}
			}
d260 6
a265 13
		| FOR LPAR alloc_macro opt_expression SEMICOLON
		     opt_relational_expression SEMICOLON
		     opt_expression RPAR opt_statement pop_nesting
			{
				ssize_t n;

				if (st_has_continue)
					n = node($10, cs("M"), $8, cs("s."),
					    $6, $3, END_NODE);
				else
					n = node($10, $8, cs("s."), $6, $3,
					    END_NODE);

a275 8
		| IF LPAR alloc_macro pop_nesting relational_expression RPAR
		      opt_statement ELSE alloc_macro pop_nesting opt_statement
			{
				emit_macro($3, $7);
				emit_macro($9, $11);
				$$ = node($5, $3, cs("e"), $9, cs(" "),
				    END_NODE);
			}
d279 1
a279 6
				ssize_t n;

				if (st_has_continue)
					n = node($6, cs("M"), $4, $3, END_NODE);
				else
					n = node($6, $4, $3, END_NODE);
a306 2
		;

a310 1
		;
a334 1
		;
a408 7
opt_relational_expression
		: /* empty */
			{
				$$ = cs(" 0 0=");
			}
		| relational_expression
		;
a455 7
opt_expression : /* empty */
			{
				$$ = cs(" 0");
			}
		| expression
		;

d528 2
a529 6
				if ($2[0] == '\0')
					$$ = node($3, cs($2), cs("d"), $1.store,
					    END_NODE);
				else
					$$ = node($1.load, $3, cs($2), cs("d"),
					    $1.store, END_NODE);
d590 1
a590 1
			err(1, NULL);
d613 1
a613 1
		err(1, NULL);
d729 1
a729 1
		err(1, NULL);
@


1.1.1.5
log
@Import fixed bc and dc from OpenBSD-current (a must-have :)
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.14 2003/10/22 12:24:41 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.14 2003/10/22 12:24:41 otto Exp $";
a87 1
static bool		st_has_continue;
a121 1
%token CONTINUE ELSE
a138 2
%type <node>	opt_expression
%type <node>	opt_relational_expression
a162 1
				st_has_continue = false;
a167 1
				st_has_continue = false;
d218 1
a218 6
				if ($2[0] == '\0')
					$$ = node($3, cs($2), $1.store,
					    END_NODE);
				else
					$$ = node($1.load, $3, cs($2), $1.store,
					    END_NODE);
a236 12
		| CONTINUE
			{
				if (breaksp == 0) {
					warning("continue not in for or while");
					YYERROR;
				} else {
					st_has_continue = true;
					$$ = node(numnode(nesting -
					    breakstack[breaksp-1] - 1),
					    cs("J"), END_NODE);
				}
			}
d260 6
a265 13
		| FOR LPAR alloc_macro opt_expression SEMICOLON
		     opt_relational_expression SEMICOLON
		     opt_expression RPAR opt_statement pop_nesting
			{
				ssize_t n;

				if (st_has_continue)
					n = node($10, cs("M"), $8, cs("s."),
					    $6, $3, END_NODE);
				else
					n = node($10, $8, cs("s."), $6, $3,
					    END_NODE);

a275 8
		| IF LPAR alloc_macro pop_nesting relational_expression RPAR
		      opt_statement ELSE alloc_macro pop_nesting opt_statement
			{
				emit_macro($3, $7);
				emit_macro($9, $11);
				$$ = node($5, $3, cs("e"), $9, cs(" "),
				    END_NODE);
			}
d279 1
a279 6
				ssize_t n;

				if (st_has_continue)
					n = node($6, cs("M"), $4, $3, END_NODE);
				else
					n = node($6, $4, $3, END_NODE);
a306 2
		;

a310 1
		;
a334 1
		;
a408 7
opt_relational_expression
		: /* empty */
			{
				$$ = cs(" 0 0=");
			}
		| relational_expression
		;
a455 7
opt_expression : /* empty */
			{
				$$ = cs(" 0");
			}
		| expression
		;

d528 2
a529 6
				if ($2[0] == '\0')
					$$ = node($3, cs($2), cs("d"), $1.store,
					    END_NODE);
				else
					$$ = node($1.load, $3, cs($2), cs("d"),
					    $1.store, END_NODE);
d590 1
a590 1
			err(1, NULL);
d613 1
a613 1
		err(1, NULL);
d729 1
a729 1
		err(1, NULL);
@


1.1.1.6
log
@Import selected parts of the OpenBSD base system:
 * vnd change - you'll have to re-run MAKEDEV after booting a new kernel
 * misc. changes in /etc, mostly user related
 * Perl 5.8.2 (diff to MirPorts will be committed RSN)
 * some changes to binutils
 * Updates in bc and dc
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.20 2003/12/02 09:00:07 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.20 2003/12/02 09:00:07 otto Exp $";
a39 1
#include <search.h>
a71 5
static ssize_t		lookup(char *, size_t, char);
static ssize_t		letter_node(char *);
static ssize_t		array_node(char *);
static ssize_t		function_node(char *);

a76 1
static char		*escape(const char *);
a93 1
static u_short		var_count;
d99 1
a99 1
/* These values are 4.4BSD bc compatible */
d103 3
a105 4
/* Skip '\0', [, \ and ] */
#define ENCODE(c)	((c) < '[' ? (c) : (c) + 3);
#define VAR_BASE	(256-4)
#define MAX_VARIABLES	(VAR_BASE * VAR_BASE)
a114 1
	char		*astr;
d119 1
a119 2
%token <astr> LETTER
%token <str> NUMBER STRING
d123 1
a123 1
%token CONTINUE ELSE PRINT
a124 3
%left BOOL_OR
%left BOOL_AND
%nonassoc BOOL_NOT
d129 1
a129 1
%right EXPONENT
a143 2
%type <node>	print_expression
%type <node>	print_expression_list
d153 6
a158 1
		| program input_item
d266 10
a275 1
		| RETURN return_expression
d281 1
a281 1
				$$ = $2;
a329 4
		| PRINT print_expression_list
			{
				$$ = $2;
			}
d344 1
a344 1
				else if (macro_char == 255)
d358 1
a358 1
function	: function_header opt_parameter_list RPAR opt_newline
d362 1
a362 1
				int n = node(prologue, $8, epilogue,
d374 1
a374 2
				$$ = function_node($2);
				free($2);
a382 4
opt_newline	: /* empty */
		| NEWLINE
		;

d391 1
a391 2
				add_par(letter_node($1));
				free($1);
d395 1
a395 2
				add_par(array_node($1));
				free($1);
d399 1
a399 2
				add_par(letter_node($3));
				free($3);
d403 1
a403 2
				add_par(array_node($3));
				free($3);
d418 1
a418 2
				add_local(letter_node($1));
				free($1);
d422 1
a422 2
				add_local(array_node($1));
				free($1);
d426 1
a426 2
				add_local(letter_node($3));
				free($3);
d430 1
a430 2
				add_local(array_node($3));
				free($3);
d451 1
a451 1
				$$ = node($1, cs("l"), array_node($3),
a452 1
				free($3);
d465 5
a469 1
		: expression EQUALS expression
a492 4
		| expression
			{
				$$ = node($1, cs(" 0!="), END_NODE);
			}
a506 5
		| LPAR RPAR
			{
				$$ = node(cs("0"), epilogue,
				    numnode(nesting), cs("Q"), END_NODE);
			}
d535 1
a535 1
				    function_node($1), cs("x"),
a536 1
				free($1);
a607 40
		| BOOL_NOT expression
			{
				$$ = node($2, cs("N"), END_NODE);
			}
		| expression BOOL_AND alloc_macro pop_nesting expression
			{
				ssize_t n = node(cs("R"), $5, END_NODE);
				emit_macro($3, n);
				$$ = node($1, cs("d0!="), $3, END_NODE);
			}
		| expression BOOL_OR alloc_macro pop_nesting expression
			{
				ssize_t n = node(cs("R"), $5, END_NODE);
				emit_macro($3, n);
				$$ = node($1, cs("d0="), $3, END_NODE);
			}
		| expression EQUALS expression
			{
				$$ = node($1, $3, cs("G"), END_NODE);
			}
		| expression UNEQUALS expression
			{
				$$ = node($1, $3, cs("GN"), END_NODE);
			}
		| expression LESS expression
			{
				$$ = node($3, $1, cs("("), END_NODE);
			}
		| expression LESS_EQ expression
			{
				$$ = node($3, $1, cs("{"), END_NODE);
			}
		| expression GREATER expression
			{
				$$ = node($1, $3, cs("("), END_NODE);
			}
		| expression GREATER_EQ expression
			{
				$$ = node($1, $3, cs("{"), END_NODE);
			}
d613 1
a613 1
				$$.load = node(cs("l"), letter_node($1),
d615 1
a615 1
				$$.store = node(cs("s"), letter_node($1),
a616 1
				free($1);
d621 1
a621 1
				    array_node($1), END_NODE);
d623 1
a623 2
				    array_node($1), END_NODE);
				free($1);
a640 19

print_expression_list
		: print_expression
		| print_expression_list COMMA print_expression
			{
				$$ = node($1, $3, END_NODE);
			}

print_expression
		: expression
			{
				$$ = node($1, cs("ds.n"), END_NODE);
			}
		| STRING
			{
				char *p = escape($1);
				$$ = node(cs("["), as(p), cs("]n"), END_NODE);
				free(p);
			}
d744 1
a744 1
		errx(1, "internal error: break num > 15");
a747 74

static ssize_t
lookup(char * str, size_t len, char type)
{
	ENTRY	entry, *found;
	u_short	num;
	u_char	*p;

	/* The scanner allocated an extra byte already */
	if (str[len-1] != type) {
		str[len] = type;
		str[len+1] = '\0';
	}
	entry.key = str;
	found = hsearch(entry, FIND);
	if (found == NULL) {
		if (var_count == MAX_VARIABLES)
			errx(1, "too many variables");
		p = malloc(4);
		if (p == NULL)
			err(1, NULL);
		num = var_count++;
		p[0] = 255;
		p[1] = ENCODE(num / VAR_BASE + 1);
		p[2] = ENCODE(num % VAR_BASE + 1);
		p[3] = '\0';

		entry.data = p;
		entry.key = strdup(str);
		if (entry.key == NULL)
			err(1, NULL);
		found = hsearch(entry, ENTER);
		if (found == NULL)
			err(1, NULL);
	}
	return cs(found->data);
}

static ssize_t
letter_node(char *str)
{
	size_t len;

	len = strlen(str);
	if (len == 1 && str[0] != '_')
		return cs(str_table[(int)str[0]]);
	else
		return lookup(str, len, 'L');
}

static ssize_t
array_node(char *str)
{
	size_t len;

	len = strlen(str);
	if (len == 1 && str[0] != '_')
		return cs(str_table[(int)str[0] - 'a' + ARRAY_CHAR]);
	else
		return lookup(str, len, 'A');
}

static ssize_t
function_node(char *str)
{
	size_t len;

	len = strlen(str);
	if (len == 1 && str[0] != '_')
		return cs(str_table[(int)str[0] - 'a' + FUNC_CHAR]);
	else
		return lookup(str, len, 'F');
}

a826 2
	if (hcreate(1 << 16) == 0)
		err(1, NULL);
a836 54
static char *
escape(const char *str)
{
	char *ret, *p;

	ret = malloc(strlen(str) + 1);
	if (ret == NULL)
		err(1, NULL);

	p = ret;
	while (*str != '\0') {
		/*
		 * We get _escaped_ strings here. Single backslashes are
		 * already converted to double backslashes
		 */
		if (*str == '\\') {
			if (*++str == '\\') {
				switch (*++str) {
				case 'a':
					*p++ = '\a';
					break;
				case 'b':
					*p++ = '\b';
					break;
				case 'f':
					*p++ = '\f';
					break;
				case 'n':
					*p++ = '\n';
					break;
				case 'q':
					*p++ = '"';
					break;
				case 'r':
					*p++ = '\r';
					break;
				case 't':
					*p++ = '\t';
					break;
				case '\\':
					*p++ = '\\';
					break;
				}
				str++;
			} else {
				*p++ = '\\';
				*p++ = *str++;
			}
		} else
			*p++ = *str++;
	}
	*p = '\0';
	return ret;
}
d883 1
a883 1
			execl(_PATH_DC, "dc", "-x", (char *)NULL);
@


1.1.1.7
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.21 2003/12/19 19:24:22 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.21 2003/12/19 19:24:22 otto Exp $";
d1095 1
@


1.1.1.8
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.22 2004/01/13 08:43:23 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.22 2004/01/13 08:43:23 otto Exp $";
d862 1
a862 1
		entry.data = (char *)p;
@


1.1.1.9
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.23 2004/02/18 07:43:58 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.23 2004/02/18 07:43:58 otto Exp $";
a96 1
static int		fileindex;
d926 2
a927 2
	if (fileindex < sargc) {
		filename = sargv[fileindex++];
d933 2
a934 2
	} else if (fileindex == sargc) {
		fileindex++;
d1058 1
a1058 1
	int	i, ch, ret;
a1063 4
	sargv = malloc(argc * sizeof(char *));
	if (sargv == NULL)
		err(1, NULL);

d1072 2
a1073 1
			sargv[sargc++] = _PATH_LIBB;
d1080 2
a1081 5
	argc -= optind;
	argv += optind;

	for (i = 0; i < argc; i++)
		sargv[sargc++] = argv[i];
@


1.1.1.10
log
@import some updates/fixes from openbsd
@
text
@d2 1
a2 1
/*	$OpenBSD: bc.y,v 1.24 2004/10/19 07:36:51 otto Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: bc.y,v 1.24 2004/10/19 07:36:51 otto Exp $";
a64 6
int			fileindex;
int			sargc;
char			**sargv;
char			*filename;
char			*cmdexpr;

d97 4
d924 20
d997 1
a997 2
	fprintf(stderr, "%s: usage: [-cl] [-e expression] [file ...]\n",
	    __progname);
a1060 1
	char	*q;
d1069 2
a1070 4
	if ((cmdexpr = strdup("")) == NULL)
		err(1, NULL);
	/* The d debug option is 4.4 BSD bc(1) compatible */
	while ((ch = getopt(argc, argv, "cde:l")) != -1) {
a1074 6
			break;
		case 'e':
			q = cmdexpr;
			if (asprintf(&cmdexpr, "%s%s\n", cmdexpr, optarg) == -1)
				err(1, NULL);
			free(q);
@


