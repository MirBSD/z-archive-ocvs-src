head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.8
	tg-mergefixes-1-branch:1.1.1.8.0.8
	tg-mergefixes-1-base:1.1.1.8
	MIROS_X:1.1.1.8.0.6
	MIROS_X_BASE:1.1.1.8
	tg-mergetmp-3:1.1.1.8
	MIRBSD_XP_MIRPPC:1.1.1.8.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.8
	MIRBSD_XP_SPARC:1.1.1.8.0.2
	MIRBSD_7quater:1.1.1.6
	cvs-200405160640:1.1.1.8
	cvs-200401271800:1.1.1.7
	cvs-200401261630:1.1.1.7
	cvs-200401021645:1.1.1.7
	MIRBSD_7_ALPHA:1.1.1.6.0.6
	MIRBSD_7:1.1.1.6.0.4
	cvs-200312222040:1.1.1.7
	MIRBSD_7ter:1.1.1.6
	MIRBSD_7_DEV:1.1.1.6.0.2
	cvs-200310020700:1.1.1.6
	cvs-200309271030:1.1.1.6
	cvs-200309251530:1.1.1.6
	cvs-200308302005:1.1.1.5
	cvs-200308171200:1.1.1.4
	ctm-3496:1.1.1.4
	ctm-3449:1.1.1.4
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	ctm-3389:1.1.1.3
	cvs-200306291430:1.1.1.3
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.53.35;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.53.35;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.06.19.12.54.17;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.29.17.37.36;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.07.09.16.50.26;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.08.30.23.40.13;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.09.25.16.42.14;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.12.22.21.14.42;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.16.08.13.14;	author tg;	state Stab;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: top.c,v 1.18 2002/07/15 17:20:36 deraadt Exp $	*/

const char copyright[] = "Copyright (c) 1984 through 1996, William LeFebvre";

/*
 *  Top users/processes display for Unix
 *  Version 3
 *
 * Copyright (c) 1984, 1989, William LeFebvre, Rice University
 * Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS EMPLOYER BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *  See the file "Changes" for information on version-to-version changes.
 */

/*
 *  This file contains "main" and other high-level routines.
 */

/*
 * The following preprocessor variables, when defined, are used to
 * distinguish between different Unix implementations:
 *
 *	FD_SET   - macros FD_SET and FD_ZERO are used when defined
 */

#include <sys/types.h>
#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <setjmp.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/time.h>

/* includes specific to top */
#include "display.h"		/* interface to display package */
#include "screen.h"		/* interface to screen package */
#include "top.h"
#include "top.local.h"
#include "boolean.h"
#include "machine.h"
#include "utils.h"

/* Size of the stdio buffer given to stdout */
#define Buffersize	2048

/* The buffer that stdio will use */
char stdoutbuf[Buffersize];

/* imported from screen.c */
extern int overstrike;

/* signal handling routines */
static void leave(int);
static void onalrm(int);
static void tstop(int);
#ifdef SIGWINCH
static void winch(int);
#endif

volatile sig_atomic_t leaveflag;
volatile sig_atomic_t tstopflag;
volatile sig_atomic_t winchflag;

static void reset_display(void);

/* values which need to be accessed by signal handlers */
static int max_topn;		/* maximum displayable processes */

/* miscellaneous things */
char *myname = "top";
jmp_buf jmp_int;

/* routines that don't return int */

#ifdef ORDER
extern int (*proc_compares[])();
#else
extern int proc_compare();
#endif
time_t time();

caddr_t get_process_info();

/* pointers to display routines */
void (*d_loadave)() = i_loadave;
void (*d_procstates)() = i_procstates;
void (*d_cpustates)() = i_cpustates;
void (*d_memory)() = i_memory;
void (*d_message)() = i_message;
void (*d_header)() = i_header;
void (*d_process)() = i_process;


int main(argc, argv)

int  argc;
char *argv[];

{
    int i;
    int active_procs;
    int change;

    struct system_info system_info;
    struct statics statics;
    caddr_t processes;

    static char tempbuf1[50];
    static char tempbuf2[50];
    sigset_t mask, oldmask;
    int topn = Default_TOPN;
    double delay = Default_DELAY;
    int displays = 0;		/* indicates unspecified */
    time_t curr_time;
    char *(*get_userid)() = username;
    char *uname_field = "USERNAME";
    char *header_text;
    char *env_top;
    char **preset_argv;
    int  preset_argc = 0;
    char **av;
    int  ac;
    char dostates = No;
    char do_unames = Yes;
    char interactive = Maybe;
    char warnings = 0;
#if Default_TOPN == Infinity
    char topn_specified = No;
#endif
    char ch;
    char *iptr;
    char no_command = 1;
    struct timeval timeout;
    struct process_select ps;
#ifdef ORDER
    char *order_name = NULL;
    int order_index = 0;
#endif
#ifndef FD_SET
    /* FD_SET and friends are not present:  fake it */
    typedef int fd_set;
#define FD_ZERO(x)     (*(x) = 0)
#define FD_SET(f, x)   (*(x) = f)
#endif
    fd_set readfds;

#ifdef ORDER
    static char command_chars[] = "\f qh?en#sdkriIuSo";
#else
    static char command_chars[] = "\f qh?en#sdkriIuS";
#endif
/* these defines enumerate the "strchr"s of the commands in command_chars */
#define CMD_redraw	0
#define CMD_update	1
#define CMD_quit	2
#define CMD_help1	3
#define CMD_help2	4
#define CMD_OSLIMIT	4    /* terminals with OS can only handle commands */
#define CMD_errors	5    /* less than or equal to CMD_OSLIMIT	   */
#define CMD_number1	6
#define CMD_number2	7
#define CMD_delay	8
#define CMD_displays	9
#define CMD_kill	10
#define CMD_renice	11
#define CMD_idletog     12
#define CMD_idletog2    13
#define CMD_user	14
#define CMD_system	15
#ifdef ORDER
#define CMD_order       16
#endif

    /* set the buffer for stdout */
#ifdef DEBUG
    setbuffer(stdout, NULL, 0);
#else
    setbuffer(stdout, stdoutbuf, Buffersize);
#endif

    /* get our name */
    if (argc > 0)
    {
	if ((myname = strrchr(argv[0], '/')) == 0)
	{
	    myname = argv[0];
	}
	else
	{
	    myname++;
	}
    }

    /* initialize some selection options */
    ps.idle    = Yes;
    ps.system  = No;
    ps.uid     = -1;
    ps.command = NULL;

    /* get preset options from the environment */
    if ((env_top = getenv("TOP")) != NULL)
    {
	av = preset_argv = argparse(env_top, &preset_argc);
	ac = preset_argc;

	/* set the dummy argument to an explanatory message, in case
	   getopt encounters a bad argument */
	preset_argv[0] = "while processing environment";
    }

    /* process options */
    do {
	/* if we're done doing the presets, then process the real arguments */
	if (preset_argc == 0)
	{
	    ac = argc;
	    av = argv;

	    /* this should keep getopt happy... */
	    optind = 1;
	}

	while ((i = getopt(ac, av, "SIbinqus:d:U:o:")) != -1)
	{
	    switch(i)
	    {
	      case 'u':			/* toggle uid/username display */
		do_unames = !do_unames;
		break;

	      case 'U':			/* display only username's processes */
		if ((ps.uid = userid(optarg)) == -1)
		{
		    fprintf(stderr, "%s: unknown user\n", optarg);
		    exit(1);
		}
		break;

	      case 'S':			/* show system processes */
		ps.system = !ps.system;
		break;

	      case 'I':                   /* show idle processes */
		ps.idle = !ps.idle;
		break;

	      case 'i':			/* go interactive regardless */
		interactive = Yes;
		break;

	      case 'n':			/* batch, or non-interactive */
	      case 'b':
		interactive = No;
		break;

	      case 'd':			/* number of displays to show */
		if ((i = atoiwi(optarg)) == Invalid || i == 0)
		{
		    fprintf(stderr,
			"%s: warning: display count should be positive -- option ignored\n",
			myname);
		    warnings++;
		}
		else
		{
		    displays = i;
		}
		break;

	      case 's':
		{
		  char *endp;

		  delay = strtod(optarg, &endp);

		  if (delay < 0 || delay >= 1000000 || *endp != '\0')
		  {
		    fprintf(stderr,
			"%s: warning: delay should be a non-negative number -- using default\n",
			myname);
		    delay = Default_DELAY;
		    warnings++;
		  }
		}
		break;

	      case 'q':		/* be quick about it */
		/* only allow this if user is really root */
		if (getuid() == 0)
		{
		    /* be very un-nice! */
		    (void) nice(-20);
		}
		else
		{
		    fprintf(stderr,
			"%s: warning: `-q' option can only be used by root\n",
			myname);
		    warnings++;
		}
		break;

	      case 'o':		/* select sort order */
#ifdef ORDER
		order_name = optarg;
#else
		fprintf(stderr,
			"%s: this platform does not support arbitrary ordering.  Sorry.\n",
			myname);
		warnings++;
#endif
		break;

	      default:
		fprintf(stderr, "\
Top version %s\n\
Usage: %s [-ISbinqu] [-d x] [-s x] [-o field] [-U username] [number]\n",
			version_string(), myname);
		exit(1);
	    }
	}

	/* get count of top processes to display (if any) */
	if (optind < ac)
	{
	    if ((topn = atoiwi(av[optind])) == Invalid)
	    {
		fprintf(stderr,
			"%s: warning: process display count should be non-negative -- using default\n",
			myname);
		warnings++;
	    }
#if Default_TOPN == Infinity
            else
	    {
		topn_specified = Yes;
	    }
#endif
	}

	/* tricky:  remember old value of preset_argc & set preset_argc = 0 */
	i = preset_argc;
	preset_argc = 0;

    /* repeat only if we really did the preset arguments */
    } while (i != 0);

    /* set constants for username/uid display correctly */
    if (!do_unames)
    {
	uname_field = "   UID  ";
	get_userid = itoa7;
    }

    /* initialize the kernel memory interface */
    if (machine_init(&statics) == -1)
    {
	exit(1);
    }

#ifdef ORDER
    /* determine sorting order index, if necessary */
    if (order_name != NULL)
    {
	if ((order_index = string_index(order_name, statics.order_names)) == -1)
	{
	    char **pp;

	    fprintf(stderr, "%s: '%s' is not a recognized sorting order.\n",
		    myname, order_name);
	    fprintf(stderr, "\tTry one of these:");
	    pp = statics.order_names;
	    while (*pp != NULL)
	    {
		fprintf(stderr, " %s", *pp++);
	    }
	    fputc('\n', stderr);
	    exit(1);
	}
    }
#endif

#ifdef no_initialization_needed
    /* initialize the hashing stuff */
    if (do_unames)
    {
	init_hash();
    }
#endif

    /* initialize termcap */
    init_termcap(interactive);

    /* get the string to use for the process area header */
    header_text = format_header(uname_field);

    /* initialize display interface */
    if ((max_topn = display_init(&statics)) == -1)
    {
	fprintf(stderr, "%s: can't allocate sufficient memory\n", myname);
	exit(4);
    }
    
    /* print warning if user requested more processes than we can display */
    if (topn > max_topn)
    {
	fprintf(stderr,
		"%s: warning: this terminal can only display %d processes.\n",
		myname, max_topn);
	warnings++;
    }

    /* adjust for topn == Infinity */
    if (topn == Infinity)
    {
	/*
	 *  For smart terminals, infinity really means everything that can
	 *  be displayed, or Largest.
	 *  On dumb terminals, infinity means every process in the system!
	 *  We only really want to do that if it was explicitly specified.
	 *  This is always the case when "Default_TOPN != Infinity".  But if
	 *  topn wasn't explicitly specified and we are on a dumb terminal
	 *  and the default is Infinity, then (and only then) we use
	 *  "Nominal_TOPN" instead.
	 */
#if Default_TOPN == Infinity
	topn = smart_terminal ? Largest :
		    (topn_specified ? Largest : Nominal_TOPN);
#else
	topn = Largest;
#endif
    }

    /* set header display accordingly */
    display_header(topn > 0);

    /* determine interactive state */
    if (interactive == Maybe)
    {
	interactive = smart_terminal;
    }

    /* if # of displays not specified, fill it in */
    if (displays == 0)
    {
	displays = smart_terminal ? Infinity : 1;
    }

    /* block interrupt signals while setting up the screen and the handlers */
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    sigaddset(&mask, SIGQUIT);
    sigaddset(&mask, SIGTSTP);
    sigprocmask(SIG_BLOCK, &mask, &oldmask);
    init_screen();
    (void) signal(SIGINT, leave);
    (void) signal(SIGQUIT, leave);
    (void) signal(SIGTSTP, tstop);
#ifdef SIGWINCH
    (void) signal(SIGWINCH, winch);
#endif
    sigprocmask(SIG_SETMASK, &oldmask, NULL);
    if (warnings)
    {
	fputs("....", stderr);
	fflush(stderr);			/* why must I do this? */
	sleep((unsigned)(3 * warnings));
	fputc('\n', stderr);
    }

restart:

    /*
     *  main loop -- repeat while display count is positive or while it
     *		indicates infinity (by being -1)
     */

    while ((displays == -1) || (displays-- > 0))
    {
	/* get the current stats */
	get_system_info(&system_info);

	/* get the current set of processes */
	processes =
		get_process_info(&system_info,
				 &ps,
#ifdef ORDER
				 proc_compares[order_index]);
#else
				 proc_compare);
#endif

	/* display the load averages */
	(*d_loadave)(system_info.last_pid,
		     system_info.load_avg);

	/* display the current time */
	/* this method of getting the time SHOULD be fairly portable */
	time(&curr_time);
	i_timeofday(&curr_time);

	/* display process state breakdown */
	(*d_procstates)(system_info.p_total,
			system_info.procstates);

	/* display the cpu state percentage breakdown */
	if (dostates)	/* but not the first time */
	{
	    (*d_cpustates)(system_info.cpustates);
	}
	else
	{
	    /* we'll do it next time */
	    if (smart_terminal)
	    {
		z_cpustates();
	    }
	    else
	    {
		if (putchar('\n') == EOF)
		    exit(1);
	    }
	    dostates = Yes;
	}

	/* display memory stats */
	(*d_memory)(system_info.memory);

	/* handle message area */
	(*d_message)();

	/* update the header area */
	(*d_header)(header_text);
    
	if (topn > 0)
	{
	    /* determine number of processes to actually display */
	    /* this number will be the smallest of:  active processes,
	       number user requested, number current screen accommodates */
	    active_procs = system_info.p_active;
	    if (active_procs > topn)
	    {
		active_procs = topn;
	    }
	    if (active_procs > max_topn)
	    {
		active_procs = max_topn;
	    }

	    /* now show the top "n" processes. */
	    for (i = 0; i < active_procs; i++)
	    {
		(*d_process)(i, format_next_process(processes, get_userid));
	    }
	}
	else
	{
	    i = 0;
	}

	/* do end-screen processing */
	u_endscreen(i);

	/* now, flush the output buffer */
	fflush(stdout);

	/* only do the rest if we have more displays to show */
	if (displays)
	{
	    /* switch out for new display on smart terminals */
	    if (smart_terminal)
	    {
		if (overstrike)
		{
		    reset_display();
		}
		else
		{
		    d_loadave = u_loadave;
		    d_procstates = u_procstates;
		    d_cpustates = u_cpustates;
		    d_memory = u_memory;
		    d_message = u_message;
		    d_header = u_header;
		    d_process = u_process;
		}
	    }
    
	    no_command = Yes;
	    if (!interactive)
	    {
		/* set up alarm */
		(void) signal(SIGALRM, onalrm);
		(void) alarm((unsigned)delay);
    
		/* wait for the rest of it .... */
		pause();
	    }
	    else while (no_command)
	    {
		/* assume valid command unless told otherwise */
		no_command = No;

		/* set up arguments for select with timeout */
		FD_ZERO(&readfds);
		FD_SET(STDIN_FILENO, &readfds);	/* for standard input */
		timeout.tv_sec  = (long)delay;
		timeout.tv_usec = (long)((delay - timeout.tv_sec) * 1000000);

		if (leaveflag) {
		    end_screen();
		    exit(0);
		}

		if (tstopflag) {
		    /* move to the lower left */
		    end_screen();
		    fflush(stdout);

		    /* default the signal handler action */
		    (void) signal(SIGTSTP, SIG_DFL);

		    /* unblock the signal and send ourselves one */
		    sigemptyset(&mask);
		    sigaddset(&mask, SIGTSTP);
		    sigprocmask(SIG_UNBLOCK, &mask, NULL);
		    (void) kill(0, SIGTSTP);

		    /* reset the signal handler */
		    (void) signal(SIGTSTP, tstop);

		    /* reinit screen */
		    reinit_screen();
		    reset_display();
		    tstopflag = 0;
		    goto restart;
		}

		if (winchflag) {
		    /* reascertain the screen dimensions */
		    get_screensize();

		    /* tell display to resize */
		    max_topn = display_resize();

		    /* reset the signal handler */
		    (void) signal(SIGWINCH, winch);

		    reset_display();
		    winchflag = 0;
		    goto restart;
		}

		/* wait for either input or the end of the delay period */
		if (select(STDIN_FILENO + 1, &readfds, (fd_set *)NULL,
		  (fd_set *)NULL, &timeout) > 0)
		{
		    int newval;
		    char *errmsg;
    
		    /* something to read -- clear the message area first */
		    clear_message();

		    /* now read it and convert to command strchr */
		    /* (use "change" as a temporary to hold strchr) */
		    (void) read(0, &ch, 1);
		    if ((iptr = strchr(command_chars, ch)) == NULL)
		    {
			/* illegal command */
			new_message(MT_standout, " Command not understood");
			if (putchar('\r') == EOF)
			    exit(1);
			no_command = Yes;
		    }
		    else
		    {
			change = iptr - command_chars;
			if (overstrike && change > CMD_OSLIMIT)
			{
			    /* error */
			    new_message(MT_standout,
			    " Command cannot be handled by this terminal");
			    if (putchar('\r') == EOF)
			        exit(1);
			    no_command = Yes;
			}
			else switch(change)
			{
			    case CMD_redraw:	/* redraw screen */
				reset_display();
				break;
    
			    case CMD_update:	/* merely update display */
				/* is the load average high? */
				if (system_info.load_avg[0] > LoadMax)
				{
				    /* yes, go home for visual feedback */
				    go_home();
				    fflush(stdout);
				}
				break;
	    
			    case CMD_quit:	/* quit */
				quit(0);
				/*NOTREACHED*/
				break;
	    
			    case CMD_help1:	/* help */
			    case CMD_help2:
				reset_display();
				clear();
				show_help();
				standout("Hit any key to continue: ");
				fflush(stdout);
				(void) read(0, &ch, 1);
				break;
	
			    case CMD_errors:	/* show errors */
				if (error_count() == 0)
				{
				    new_message(MT_standout,
					" Currently no errors to report.");
				    if (putchar('\r') == EOF)
				        exit(1);
				    no_command = Yes;
				}
				else
				{
				    reset_display();
				    clear();
				    show_errors();
				    standout("Hit any key to continue: ");
				    fflush(stdout);
				    (void) read(0, &ch, 1);
				}
				break;
	
			    case CMD_number1:	/* new number */
			    case CMD_number2:
				new_message(MT_standout,
				    "Number of processes to show: ");
				newval = readline(tempbuf1, 8, Yes);
				if (newval > -1)
				{
				    if (newval > max_topn)
				    {
					new_message(MT_standout | MT_delayed,
					  " This terminal can only display %d processes.",
					  max_topn);
					if (putchar('\r') == EOF)
					    exit(1);
				    }

				    if (newval == 0)
				    {
					/* inhibit the header */
					display_header(No);
				    }
				    else if (newval > topn && topn == 0)
				    {
					/* redraw the header */
					display_header(Yes);
					d_header = i_header;
				    }
				    topn = newval;
				}
				break;
	    
			    case CMD_delay:	/* new seconds delay */
				new_message(MT_standout, "Seconds to delay: ");
				if (readline(tempbuf2, sizeof(tempbuf2), No) > 0)
				{
				    char *endp;
				    double newdelay = strtod(tempbuf2, &endp);
				    if (newdelay >= 0 && newdelay < 1000000 && *endp == '\0')
				    {
					delay = newdelay;
				    }
				}
				clear_message();
				break;
	
			    case CMD_displays:	/* change display count */
				new_message(MT_standout,
					"Displays to show (currently %s): ",
					displays == -1 ? "infinite" :
							 itoa(displays));
				if ((i = readline(tempbuf1, 10, Yes)) > 0)
				{
				    displays = i;
				}
				else if (i == 0)
				{
				    quit(0);
				}
				clear_message();
				break;
    
			    case CMD_kill:	/* kill program */
				new_message(0, "kill ");
				if (readline(tempbuf2, sizeof(tempbuf2), No) > 0)
				{
				    if ((errmsg = kill_procs(tempbuf2)) != NULL)
				    {
					new_message(MT_standout, "%s", errmsg);
					if (putchar('\r') == EOF)
					    exit(1);
					no_command = Yes;
				    }
				}
				else
				{
				    clear_message();
				}
				break;
	    
			    case CMD_renice:	/* renice program */
				new_message(0, "renice ");
				if (readline(tempbuf2, sizeof(tempbuf2), No) > 0)
				{
				    if ((errmsg = renice_procs(tempbuf2)) != NULL)
				    {
					new_message(MT_standout, "%s", errmsg);
					if (putchar('\r') == EOF)
					    exit(1);
					no_command = Yes;
				    }
				}
				else
				{
				    clear_message();
				}
				break;

			    case CMD_idletog:
			    case CMD_idletog2:
				ps.idle = !ps.idle;
				new_message(MT_standout | MT_delayed,
				    " %sisplaying idle processes.",
				    ps.idle ? "D" : "Not d");
				if (putchar('\r') == EOF)
				    exit(1);
				break;

			    case CMD_user:
				new_message(MT_standout,
				    "Username to show: ");
				if (readline(tempbuf2, sizeof(tempbuf2), No) > 0)
				{
				    if (tempbuf2[0] == '+' &&
					tempbuf2[1] == '\0')
				    {
					ps.uid = -1;
				    }
				    else if ((i = userid(tempbuf2)) == -1)
				    {
					new_message(MT_standout,
					    " %s: unknown user", tempbuf2);
					no_command = Yes;
				    }
				    else
				    {
					ps.uid = i;
				    }
				    if (putchar('\r') == EOF)
				        exit(1);
				}
				else
				{
				    clear_message();
				}
				break;

			    case CMD_system:
				ps.system = !ps.system;
				new_message(MT_standout | MT_delayed,
				    " %sisplaying system processes.",
				    ps.system ? "D" : "Not d");
				break;

#ifdef ORDER
			    case CMD_order:
				new_message(MT_standout,
				    "Order to sort: ");
				if (readline(tempbuf2, sizeof(tempbuf2), No) > 0)
				{
				  if ((i = string_index(tempbuf2, statics.order_names)) == -1)
					{
					  new_message(MT_standout,
					      " %s: unrecognized sorting order", tempbuf2);
					  no_command = Yes;
				    }
				    else
				    {
					order_index = i;
				    }
				    if (putchar('\r') == EOF)
				        exit(1);
				}
				else
				{
				    clear_message();
				}
				break;
#endif
	    
			    default:
				new_message(MT_standout, " BAD CASE IN SWITCH!");
				if (putchar('\r') == EOF)
				    exit(1);
			}
		    }

		    /* flush out stuff that may have been written */
		    fflush(stdout);
		}
	    }
	}
    }

    quit(0);
    /*NOTREACHED*/
    return(0);
}

/*
 *  reset_display() - reset all the display routine pointers so that entire
 *	screen will get redrawn.
 */

static void reset_display()

{
    d_loadave    = i_loadave;
    d_procstates = i_procstates;
    d_cpustates  = i_cpustates;
    d_memory     = i_memory;
    d_message	 = i_message;
    d_header	 = i_header;
    d_process	 = i_process;
}

/*
 *  signal handlers
 */

void leave(unused)	/* exit under normal conditions -- INT handler */

int unused;

{
    leaveflag = 1;
}

void tstop(i)	/* SIGTSTP handler */

int i;

{
    tstopflag = 1;
}

#ifdef SIGWINCH
void winch(i)		/* SIGWINCH handler */

int i;

{
    winchflag = 1;
}
#endif

void quit(status)		/* exit under duress */

int status;

{
    end_screen();
    exit(status);
    /*NOTREACHED*/
}

void onalrm(unused)	/* SIGALRM handler */

int unused;

{
    /* this is only used in batch mode to break out of the pause() */
    /* return; */
}

@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 3
a3 1
/*	$OpenBSD: top.c,v 1.25 2003/06/18 08:42:17 deraadt Exp $	*/
d33 14
a46 1
const char      copyright[] = "Copyright (c) 1984 through 1996, William LeFebvre";
a48 3
#include <sys/time.h>
#include <err.h>
#include <errno.h>
d52 1
d56 2
d69 1
a69 1
#define BUFFERSIZE	2048
d72 1
a72 1
char            stdoutbuf[BUFFERSIZE];
d74 2
a75 1
extern int      overstrike;
d78 10
a87 4
static void     leave(int);
static void     onalrm(int);
static void     tstop(int);
static void     winch(int);
d89 1
a89 1
volatile sig_atomic_t leaveflag, tstopflag, winchflag;
d91 2
a92 2
static void     reset_display(void);
int		rundisplay(void);
d94 12
a105 1
static int      max_topn;	/* maximum displayable processes */
d107 1
a107 2
extern int      (*proc_compares[])(const void *, const void *);
int order_index;
d110 10
a119 18
void            (*d_loadave) () = i_loadave;
void            (*d_procstates) () = i_procstates;
void            (*d_cpustates) () = i_cpustates;
void            (*d_memory) () = i_memory;
void            (*d_message) () = i_message;
void            (*d_header) () = i_header;
void            (*d_process) () = i_process;

int displays = 0;	/* indicates unspecified */
char do_unames = Yes;
struct process_select ps;
char dostates = No;
char interactive = Maybe;
char warnings = 0;
double delay = Default_DELAY;
char *order_name = NULL;
int topn = Default_TOPN;
int no_command = Yes;
d121 31
d153 10
a162 1
char topn_specified = No;
d164 7
d172 6
a177 4
/*
 * these defines enumerate the "strchr"s of the commands in
 * command_chars
 */
d183 2
a184 2
#define CMD_OSLIMIT	4	/* terminals with OS can only handle commands */
#define CMD_errors	5	/* less than or equal to CMD_OSLIMIT	   */
d195 1
d197 1
d199 6
a204 4
void
usage(void)
{
	extern char *__progname;
d206 57
a262 4
	fprintf(stderr,
	    "usage: %s [-ISbinqu] [-d x] [-s x] [-o field] [-U username] [number]\n",
	    __progname);
}
d264 30
a293 5
void
parseargs(int ac, char **av)
{
	char *endp;
	int i;
d295 16
a310 12
	while ((i = getopt(ac, av, "SIbinqus:d:U:o:")) != -1) {
		switch (i) {
		case 'u':	/* toggle uid/username display */
			do_unames = !do_unames;
			break;

		case 'U':	/* display only username's processes */
			if ((ps.uid = userid(optarg)) == (uid_t)-1) {
				fprintf(stderr, "%s: unknown user\n", optarg);
				exit(1);
			}
			break;
d312 13
a324 57
		case 'S':	/* show system processes */
			ps.system = !ps.system;
			break;

		case 'I':	/* show idle processes */
			ps.idle = !ps.idle;
			break;

		case 'i':	/* go interactive regardless */
			interactive = Yes;
			break;

		case 'n':	/* batch, or non-interactive */
		case 'b':
			interactive = No;
			break;

		case 'd':	/* number of displays to show */
			if ((i = atoiwi(optarg)) != Invalid && i != 0) {
				displays = i;
				break;
			}				
			warnx("warning: display count should be positive "
			    "-- option ignored");
			warnings++;
			break;

		case 's':
			delay = strtod(optarg, &endp);

			if (delay > 0 && delay <= 1000000 && *endp == '\0')
				break;

			warnx("warning: delay should be a non-negative number"
			    " -- using default");
			delay = Default_DELAY;
			warnings++;
			break;

		case 'q':	/* be quick about it */
			/* only allow this if user is really root */
			if (getuid() == 0) {
				/* be very un-nice! */
				(void) nice(-20);
				break;
			}
			warnx("warning: `-q' option can only be used by root");
			warnings++;
			break;

		case 'o':	/* select sort order */
			order_name = optarg;
			break;

		default:
			usage();
			exit(1);
d326 20
d349 9
a357 6
	if (optind < ac) {
		if ((topn = atoiwi(av[optind])) == Invalid) {
			warnx("warning: process display count should "
			    "be non-negative -- using default");
			warnings++;
		}
d359 4
a362 2
		else
			topn_specified = Yes;
a364 1
}
d366 41
a406 2
struct system_info system_info;
struct statics  statics;
d408 6
a413 15
int
main(int argc, char *argv[])
{
	char *uname_field = "USERNAME", *header_text, *env_top;
	char *(*get_userid)() = username, **preset_argv, **av;
	int preset_argc = 0, ac, active_procs, i;
	sigset_t mask, oldmask;
	time_t curr_time;
	caddr_t processes;

	/* set the buffer for stdout */
#ifdef DEBUG
	setbuffer(stdout, NULL, 0);
#else
	setbuffer(stdout, stdoutbuf, sizeof stdoutbuf);
d416 2
a417 41
	/* initialize some selection options */
	ps.idle = Yes;
	ps.system = No;
	ps.uid = (uid_t)-1;
	ps.command = NULL;

	/* get preset options from the environment */
	if ((env_top = getenv("TOP")) != NULL) {
		av = preset_argv = argparse(env_top, &preset_argc);
		ac = preset_argc;

		/*
		 * set the dummy argument to an explanatory message, in case
		 * getopt encounters a bad argument
		 */
		preset_argv[0] = "while processing environment";
	}
	/* process options */
	do {
		/*
		 * if we're done doing the presets, then process the real
		 * arguments
		 */
		if (preset_argc == 0) {
			ac = argc;
			av = argv;
			optind = 1;
		}
		parseargs(ac, av);
		i = preset_argc;
		preset_argc = 0;
	} while (i != 0);

	/* set constants for username/uid display correctly */
	if (!do_unames) {
		uname_field = "   UID  ";
		get_userid = itoa7;
	}
	/* initialize the kernel memory interface */
	if (machine_init(&statics) == -1)
		exit(1);
d419 2
a420 16
	/* determine sorting order index, if necessary */
	if (order_name != NULL) {
		if ((order_index = string_index(order_name,
		    statics.order_names)) == -1) {
			char **pp;

			warnx("'%s' is not a recognized sorting order",
			    order_name);
			fprintf(stderr, "\tTry one of these:");
			pp = statics.order_names;
			while (*pp != NULL)
				fprintf(stderr, " %s", *pp++);
			fputc('\n', stderr);
			exit(1);
		}
	}
d422 29
a450 29
	/* initialize termcap */
	init_termcap(interactive);

	/* get the string to use for the process area header */
	header_text = format_header(uname_field);

	/* initialize display interface */
	if ((max_topn = display_init(&statics)) == -1) {
		warnx("can't allocate sufficient memory");
		exit(4);
	}
	/* print warning if user requested more processes than we can display */
	if (topn > max_topn) {
		warnx("warning: this terminal can only display %d processes",
		    max_topn);
		warnings++;
	}
	/* adjust for topn == Infinity */
	if (topn == Infinity) {
		/*
		 *  For smart terminals, infinity really means everything that can
		 *  be displayed, or Largest.
		 *  On dumb terminals, infinity means every process in the system!
		 *  We only really want to do that if it was explicitly specified.
		 *  This is always the case when "Default_TOPN != Infinity".  But if
		 *  topn wasn't explicitly specified and we are on a dumb terminal
		 *  and the default is Infinity, then (and only then) we use
		 *  "Nominal_TOPN" instead.
		 */
d452 1
a452 1
		topn = smart_terminal ? Largest :
d455 1
a455 1
		topn = Largest;
d457 1
a457 3
	}
	/* set header display accordingly */
	display_header(topn > 0);
d459 2
a460 3
	/* determine interactive state */
	if (interactive == Maybe)
		interactive = smart_terminal;
d462 33
a494 3
	/* if # of displays not specified, fill it in */
	if (displays == 0)
		displays = smart_terminal ? Infinity : 1;
a495 21
	/*
	 * block interrupt signals while setting up the screen and the
	 * handlers
	 */
	sigemptyset(&mask);
	sigaddset(&mask, SIGINT);
	sigaddset(&mask, SIGQUIT);
	sigaddset(&mask, SIGTSTP);
	sigprocmask(SIG_BLOCK, &mask, &oldmask);
	init_screen();
	(void) signal(SIGINT, leave);
	(void) signal(SIGQUIT, leave);
	(void) signal(SIGTSTP, tstop);
	(void) signal(SIGWINCH, winch);
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
	if (warnings) {
		fputs("....", stderr);
		fflush(stderr);	/* why must I do this? */
		sleep((unsigned) (3 * warnings));
		fputc('\n', stderr);
	}
d498 87
a584 36
	/*
	 *  main loop -- repeat while display count is positive or while it
	 *		indicates infinity (by being -1)
	 */
	while ((displays == -1) || (displays-- > 0)) {
		/* get the current stats */
		get_system_info(&system_info);

		/* get the current set of processes */
		processes = get_process_info(&system_info, &ps,
		    proc_compares[order_index]);

		/* display the load averages */
		(*d_loadave)(system_info.last_pid, system_info.load_avg);

		/* display the current time */
		/* this method of getting the time SHOULD be fairly portable */
		time(&curr_time);
		i_timeofday(&curr_time);

		/* display process state breakdown */
		(*d_procstates)(system_info.p_total, system_info.procstates);

		/* display the cpu state percentage breakdown */
		if (dostates) {	/* but not the first time */
			(*d_cpustates) (system_info.cpustates);
		} else {
			/* we'll do it next time */
			if (smart_terminal)
				z_cpustates();
			else {
				if (putchar('\n') == EOF)
					exit(1);
			}
			dostates = Yes;
		}
d586 2
a587 2
		/* display memory stats */
		(*d_memory) (system_info.memory);
d589 2
a590 2
		/* handle message area */
		(*d_message) ();
d592 46
a637 57
		/* update the header area */
		(*d_header) (header_text);

		if (topn > 0) {
			/* determine number of processes to actually display */
			/*
			 * this number will be the smallest of:  active
			 * processes, number user requested, number current
			 * screen accommodates
			 */
			active_procs = system_info.p_active;
			if (active_procs > topn)
				active_procs = topn;
			if (active_procs > max_topn)
				active_procs = max_topn;
			/* now show the top "n" processes. */
			for (i = 0; i < active_procs; i++)
				(*d_process)(i, format_next_process(processes,
				    get_userid));
		} else
			i = 0;

		/* do end-screen processing */
		u_endscreen(i);

		/* now, flush the output buffer */
		fflush(stdout);

		/* only do the rest if we have more displays to show */
		if (displays) {
			/* switch out for new display on smart terminals */
			if (smart_terminal) {
				if (overstrike) {
					reset_display();
				} else {
					d_loadave = u_loadave;
					d_procstates = u_procstates;
					d_cpustates = u_cpustates;
					d_memory = u_memory;
					d_message = u_message;
					d_header = u_header;
					d_process = u_process;
				}
			}
			no_command = Yes;
			if (!interactive) {
				/* set up alarm */
				(void) signal(SIGALRM, onalrm);
				(void) alarm((unsigned) delay);

				/* wait for the rest of it .... */
				pause();
			} else {
				while (no_command)
					if (rundisplay())
						goto restart;
			}
a638 1
	}
d640 23
a662 4
	quit(0);
	/* NOTREACHED */
	return (0);
}
d664 14
a677 11
int
rundisplay(void)
{
	static char tempbuf1[50], tempbuf2[50];
	struct timeval timeout;
	fd_set readfds;
	sigset_t mask;
	char ch, *iptr;
	int change, i;
	uid_t uid;
	static char command_chars[] = "\f qh?en#sdkriIuSo";
d679 15
a693 82
	/*
	 * assume valid command unless told
	 * otherwise
	 */
	no_command = No;

	/*
	 * set up arguments for select with
	 * timeout
	 */
	FD_ZERO(&readfds);
	FD_SET(STDIN_FILENO, &readfds);
	timeout.tv_sec = (long) delay;
	timeout.tv_usec = (long) ((delay - timeout.tv_sec) * 1000000);

	if (leaveflag) {
		end_screen();
		exit(0);
	}
	if (tstopflag) {
		/* move to the lower left */
		end_screen();
		fflush(stdout);

		/*
		 * default the signal handler
		 * action
		 */
		(void) signal(SIGTSTP, SIG_DFL);

		/*
		 * unblock the signal and
		 * send ourselves one
		 */
		sigemptyset(&mask);
		sigaddset(&mask, SIGTSTP);
		sigprocmask(SIG_UNBLOCK, &mask, NULL);
		(void) kill(0, SIGTSTP);

		/* reset the signal handler */
		(void) signal(SIGTSTP, tstop);

		/* reinit screen */
		reinit_screen();
		reset_display();
		tstopflag = 0;
		return 1;
	}
	if (winchflag) {
		/*
		 * reascertain the screen
		 * dimensions
		 */
		get_screensize();

		/* tell display to resize */
		max_topn = display_resize();

		/* reset the signal handler */
		(void) signal(SIGWINCH, winch);

		reset_display();
		winchflag = 0;
		return 1;
	}
	/*
	 * wait for either input or the end
	 * of the delay period
	 */
	if (select(STDIN_FILENO + 1, &readfds, (fd_set *) NULL,
	    (fd_set *) NULL, &timeout) > 0) {
		char *errmsg;
		int newval;

		clear_message();

		/*
		 * now read it and convert to
		 * command strchr
		 */
		(void) read(0, &ch, 1);
		if ((iptr = strchr(command_chars, ch)) == NULL) {
d697 1
a697 1
				exit(1);
d699 8
a706 8
			fflush(stdout);
			return (0);
		}

		change = iptr - command_chars;
		if (overstrike && change > CMD_OSLIMIT) {
			/* error */
			new_message(MT_standout,
d708 3
a710 20
			if (putchar('\r') == EOF)
				exit(1);
			no_command = Yes;
			fflush(stdout);
			return (0);
		}

		switch (change) {
		case CMD_redraw:	/* redraw screen */
			reset_display();
			break;

		case CMD_update:	/* merely update display */
			/*
			 * is the load average high?
			 */
			if (system_info.load_avg[0] > LoadMax) {
				/* yes, go home for visual feedback */
				go_home();
				fflush(stdout);
d712 23
a734 24
			break;

		case CMD_quit:	/* quit */
			quit(0);
			break;

		case CMD_help1:	/* help */
		case CMD_help2:
			reset_display();
			clear();
			show_help();
			standout("Hit any key to continue: ");
			fflush(stdout);
			(void) read(0, &ch, 1);
			break;

		case CMD_errors:	/* show errors */
			if (error_count() == 0) {
				new_message(MT_standout,
				    " Currently no errors to report.");
				if (putchar('\r') == EOF)
					exit(1);
				no_command = Yes;
			} else {
d737 1
a737 1
				show_errors();
d741 31
a771 10
			}
			break;

		case CMD_number1:	/* new number */
		case CMD_number2:
			new_message(MT_standout,
			    "Number of processes to show: ");
			newval = readline(tempbuf1, 8, Yes);
			if (newval > -1) {
				if (newval > max_topn) {
d773 2
a774 3
					    " This terminal can only "
					    "display %d processes.",
					    max_topn);
d776 6
a781 3
						exit(1);
				}
				if (newval == 0)
d783 3
a785 1
				else if (newval > topn && topn == 0) {
d789 2
d792 10
a801 12
				topn = newval;
			}
			break;

		case CMD_delay:	/* new seconds delay */
			new_message(MT_standout, "Seconds to delay: ");
			if (readline(tempbuf2, sizeof(tempbuf2), No) > 0) {
				char *endp;
				double newdelay = strtod(tempbuf2, &endp);

				if (newdelay >= 0 && newdelay < 1000000 &&
				    *endp == '\0')
d803 27
a829 21
			}
			clear_message();
			break;

		case CMD_displays:	/* change display count */
			new_message(MT_standout,
			    "Displays to show (currently %s): ",
			    displays == -1 ? "infinite" :
			    itoa(displays));
			if ((i = readline(tempbuf1, 10, Yes)) > 0)
				displays = i;
			else if (i == 0)
				quit(0);

			clear_message();
			break;

		case CMD_kill:	/* kill program */
			new_message(0, "kill ");
			if (readline(tempbuf2, sizeof(tempbuf2), No) > 0) {
				if ((errmsg = kill_procs(tempbuf2)) != NULL) {
d832 1
a832 1
						exit(1);
d834 1
d836 12
a847 8
			} else
				clear_message();
			break;

		case CMD_renice:	/* renice program */
			new_message(0, "renice ");
			if (readline(tempbuf2, sizeof(tempbuf2), No) > 0) {
				if ((errmsg = renice_procs(tempbuf2)) != NULL) {
d850 1
a850 1
						exit(1);
d852 5
d858 1
a858 3
			} else
				clear_message();
			break;
d860 9
a868 9
		case CMD_idletog:
		case CMD_idletog2:
			ps.idle = !ps.idle;
			new_message(MT_standout | MT_delayed,
			    " %sisplaying idle processes.",
			    ps.idle ? "D" : "Not d");
			if (putchar('\r') == EOF)
				exit(1);
			break;
d870 12
a881 8
		case CMD_user:
			new_message(MT_standout,
			    "Username to show: ");
			if (readline(tempbuf2, sizeof(tempbuf2), No) > 0) {
				if (tempbuf2[0] == '+' &&
				    tempbuf2[1] == '\0') {
					ps.uid = (uid_t)-1;
				} else if ((uid = userid(tempbuf2)) == (uid_t)-1) {
d885 20
a904 7
				} else
					ps.uid = uid;
				if (putchar('\r') == EOF)
					exit(1);
			} else
				clear_message();
			break;
d906 14
a919 19
		case CMD_system:
			ps.system = !ps.system;
			new_message(MT_standout | MT_delayed,
			    " %sisplaying system processes.",
			    ps.system ? "D" : "Not d");
			break;

		case CMD_order:
			new_message(MT_standout,
			    "Order to sort: ");
			if (readline(tempbuf2,
			    sizeof(tempbuf2), No) > 0) {
				if ((i = string_index(tempbuf2,
				    statics.order_names)) == -1) {
					new_message(MT_standout,
					    " %s: unrecognized sorting order",
					    tempbuf2);
					no_command = Yes;
				} else
d921 13
d935 3
a937 4
					exit(1);
			} else
				clear_message();
			break;
d939 2
a940 4
		default:
			new_message(MT_standout, " BAD CASE IN SWITCH!");
			if (putchar('\r') == EOF)
				exit(1);
d942 1
d944 1
d946 3
a948 3
	/* flush out stuff that may have been written */
	fflush(stdout);
	return 0;
a950 1

d955 3
a957 2
static void
reset_display(void)
d959 7
a965 7
	d_loadave = i_loadave;
	d_procstates = i_procstates;
	d_cpustates = i_cpustates;
	d_memory = i_memory;
	d_message = i_message;
	d_header = i_header;
	d_process = i_process;
d968 8
a975 2
void
leave(int signo)
d977 1
a977 1
	leaveflag = 1;
d980 4
a983 2
void
tstop(int signo)
d985 1
a985 1
	tstopflag = 1;
d988 5
a992 2
void
winch(int signo)
d994 1
a994 1
	winchflag = 1;
d996 5
a1001 2
void
onalrm(int signo)
d1003 3
d1008 4
a1011 2
void
quit(int ret)
d1013 2
a1014 2
	end_screen();
	exit(ret);
d1016 1
@


1.1.1.3
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.26 2003/06/19 22:40:45 millert Exp $	*/
d283 1
a283 1
		get_userid = format_uid;
@


1.1.1.4
log
@Bring the entire base system and ports tree in sync with OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.27 2003/07/07 21:36:52 deraadt Exp $	*/
d78 7
a84 7
void            (*d_loadave) (int, double *) = i_loadave;
void            (*d_procstates) (int, int *) = i_procstates;
void            (*d_cpustates) (int *) = i_cpustates;
void            (*d_memory) (int *) = i_memory;
void            (*d_message) (void) = i_message;
void            (*d_header) (char *) = i_header;
void            (*d_process) (int, char *) = i_process;
d124 1
a124 1
static void
d134 1
a134 1
static void
d234 1
a234 1
	char *(*get_userid)(uid_t) = username, **preset_argv, **av;
@


1.1.1.5
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.28 2003/08/21 08:14:50 deraadt Exp $	*/
a40 1
#include <poll.h>
d488 2
a492 1
	struct pollfd pfd[1];
d506 4
a509 2
	pfd[0].fd = STDIN_FILENO;
	pfd[0].events = POLLIN;
d565 2
a566 1
	if (poll(pfd, 1, delay * 1000) > 0) {
@


1.1.1.6
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.29 2003/09/19 10:32:24 jmc Exp $	*/
d131 1
a131 1
	    "usage: %s [-biInqSu] [-d count] [-o field] [-s time] [-U username] [number]\n",
@


1.1.1.7
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.30 2003/11/01 20:20:57 deraadt Exp $	*/
a364 1
	siginterrupt(SIGINT, 1);
a564 1
		ssize_t len;
d573 1
a573 8
		while (1) {
			len = read(0, &ch, 1);
			if (len == -1 && errno == EINTR)
				continue;
			if (len == 0)
				exit(1);
			break;
		}
d623 1
a623 8
			while (1) {
				len = read(0, &ch, 1);
				if (len == -1 && errno == EINTR)
					continue;
				if (len == 0)
					exit(1);
				break;
			}
d639 1
a639 8
				while (1) {
					len = read(0, &ch, 1);
					if (len == -1 && errno == EINTR)
						continue;
					if (len == 0)
						exit(1);
					break;
				}
@


1.1.1.8
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.33 2004/05/09 22:16:26 deraadt Exp $	*/
d31 1
a31 1
const char	copyright[] = "Copyright (c) 1984 through 1996, William LeFebvre";
d58 1
a58 1
char		stdoutbuf[BUFFERSIZE];
d60 1
a60 1
extern int	overstrike;
d63 4
a66 4
static void	leave(int);
static void	onalrm(int);
static void	tstop(int);
static void	winch(int);
d70 1
a70 1
static void	reset_display(void);
d73 1
a73 1
static int	max_topn;	/* maximum displayable processes */
d75 1
a75 1
extern int	(*proc_compares[])(const void *, const void *);
d79 7
a85 7
void		(*d_loadave)(int, double *) = i_loadave;
void		(*d_procstates)(int, int *) = i_procstates;
void		(*d_cpustates)(int *) = i_cpustates;
void		(*d_memory)(int *) = i_memory;
void		(*d_message)(void) = i_message;
void		(*d_header)(char *) = i_header;
void		(*d_process)(int, char *) = i_process;
d119 2
a120 2
#define CMD_idletog	12
#define CMD_idletog2	13
d123 1
a123 1
#define CMD_order	16
d175 1
a175 1
			}
d373 1
a373 1
		sleep((unsigned)(3 * warnings));
d403 1
a403 1
			(*d_cpustates)(system_info.cpustates);
d416 1
a416 1
		(*d_memory)(system_info.memory);
d419 1
a419 1
		(*d_message)();
d422 1
a422 1
		(*d_header)(header_text);
d564 1
a564 2
	if (poll(pfd, 1, (int)(delay * 1000)) > 0 &&
	    !(pfd[0].revents & (POLLERR|POLLHUP|POLLNVAL))) {
@


