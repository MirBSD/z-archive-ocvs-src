head	1.50;
access;
symbols
	tg-mergetmp-mirosx-1:1.50
	tg-mergefixes-1-branch:1.50.0.4
	tg-mergefixes-1-base:1.50
	MIROS_X:1.50.0.2
	MIROS_X_BASE:1.50
	tg-mergetmp-3:1.50
	MIRBSD_XP_MIRPPC:1.45.0.4
	MIRBSD_XP_SPARC_BASE:1.45
	MIRBSD_XP_SPARC:1.45.0.2
	MIRBSD_7quater:1.27.4.1
	cvs-200405160640:1.1.1.16
	cvs-200401271800:1.1.1.15
	cvs-200401261630:1.1.1.15
	cvs-200401021645:1.1.1.14
	MIRBSD_7_ALPHA:1.27.0.6
	MIRBSD_7:1.27.0.4
	cvs-200312222040:1.1.1.14
	MIRBSD_7ter:1.27
	MIRBSD_7_DEV:1.27.0.2
	cvs-200310020700:1.1.1.13
	cvs-200309271030:1.1.1.13
	cvs-200309251530:1.1.1.13
	cvs-200309071830:1.1.1.12
	cvs-200308302005:1.1.1.12
	cvs-200308171200:1.1.1.11
	ctm-3496:1.1.1.10
	ctm-3449:1.1.1.9
	ctm-3437:1.1.1.9
	cvs-200307191805:1.1.1.9
	ctm-3425:1.1.1.9
	cvs-200307091500:1.1.1.8
	cvs-200307072125:1.1.1.8
	ctm-3389:1.1.1.8
	cvs-200307030815:1.1.1.7
	cvs-200307021520:1.1.1.6
	cvs-200306301805:1.1.1.6
	cvs-200306291430:1.1.1.5
	ctm-3341:1.1.1.4
	MIRBSD_5:1.11
	cvs-200306082100:1.1.1.4
	ctm-3316:1.1.1.4
	ctm-3272:1.1.1.3
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.5
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.50
date	2004.11.21.15.31.07;	author tg;	state Exp;
branches;
next	1.49;

1.49
date	2004.11.20.19.14.11;	author tg;	state Exp;
branches;
next	1.48;

1.48
date	2004.11.13.20.21.48;	author tg;	state Exp;
branches;
next	1.47;

1.47
date	2004.11.02.21.21.46;	author tg;	state Exp;
branches;
next	1.46;

1.46
date	2004.10.25.20.12.20;	author tg;	state Exp;
branches;
next	1.45;

1.45
date	2004.09.26.11.24.03;	author tg;	state Exp;
branches;
next	1.44;

1.44
date	2004.08.15.16.20.13;	author tg;	state Stab;
branches;
next	1.43;

1.43
date	2004.08.15.16.19.17;	author tg;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.11.15.57.25;	author tg;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.21.21.10.47;	author tg;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.02.20.07.24;	author tg;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.09.21.10.38;	author tg;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.01.16.33.37;	author tg;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.31.02.17.31;	author tg;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.28.15.14.06;	author tg;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.27.17.41.32;	author tg;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.23.22.31.41;	author tg;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.23.22.16.59;	author tg;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.04.19.08.45;	author tg;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.04.03.18.20;	author tg;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.23.13.41.59;	author tg;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.28.22.37.50;	author tg;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.20.12.36.05;	author tg;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.02.23.43.55;	author tg;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2003.10.01.18.51.28;	author tg;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.25.20.59.40;	author tg;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.03.23.55.09;	author tg;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.31.20.54.08;	author tg;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.17.18.55.48;	author tg;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.16.15.19.52;	author tg;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.20.11.49.55;	author tg;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.20.11.35.43;	author tg;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.18.15.44.11;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.06.20.20.59;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.05.17.09.20;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.03.08.26.53;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.30.18.26.05;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.30.18.22.10;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.29.19.45.43;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.06.20.26.05;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.06.18.26.41;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.22.14.06.11;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.21.17.03.14;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.19.15.35.19;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.07.20.53.05;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.13.10.19.53;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.12.23.43.41;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.12.16.19.01;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.12.14.48.48;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.35.11;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.35.11;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.15.42;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.21.18.36.15;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.05.16.58.33;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.06.29.14.52.19;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.06.30.18.14.29;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.07.03.08.19.34;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.07.06.14.48.08;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.07.18.13.10.27;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.08.11.17.46.43;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2003.08.17.12.53.28;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2003.08.30.21.07.51;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2003.09.25.16.08.08;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2003.12.22.20.23.14;	author tg;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2004.01.26.16.55.55;	author tg;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2004.05.16.07.26.09;	author tg;	state Exp;
branches;
next	;

1.27.4.1
date	2004.04.12.17.48.53;	author tg;	state Exp;
branches;
next	;


desc
@@


1.50
log
@reorder
@
text
@# $MirBSD: src/distrib/miniroot/install.sub,v 1.49 2004/11/20 19:14:11 tg Exp $
# $OpenBSD: install.sub,v 1.338 2004/04/12 22:55:11 krw Exp $
# $NetBSD: install.sub,v 1.5.2.8 1996/09/02 23:25:02 pk Exp $
#
# Copyright (c) 2003, 2004
#	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
# Copyright (c) 1997-2004 Todd Miller, Theo de Raadt, Ken Westerback
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Copyright (c) 1996 The NetBSD Foundation, Inc.
# All rights reserved.
#
# This code is derived from software contributed to The NetBSD Foundation
# by Jason R. Thorpe.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#        This product includes software developed by the NetBSD
#        Foundation, Inc. and its contributors.
# 4. Neither the name of The NetBSD Foundation nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

# MirBSD install/upgrade script common subroutines and initialization code

# Include machine-dependent functions and definitions.
#
# The following functions must be provided:
#	md_congrats()		  - display friendly message
#	md_installboot()	  - install boot-blocks on disk
#	md_prep_disklabel()	  - put an OpenBSD disklabel on the disk
#	md_set_term()		  - set up terminal
#
# The following variables can be provided if required:
#	MDSETS	    - list of files to add to THESETS
#	MDTERM      - 'vt220' assumed if not provided
#	MDFSTYPE    - nothing assumed if not provided
#	MDFSOPTS    - nothing assumed if not provided
#	MDDISKDEVS  - '/^[sw]d[0-9][0-9]* /s/ .*//p' assumed if not provided
#	MDCDDEVS    - '/^cd[0-9][0-9]* /s/ .*//p'    assumed if not provided
#	MDXAPERTURE - if not empty, set machdep.allowaperture=value in sysctl.conf
. install.md

set_term() {
	[[ -n $TERM ]] && return
	ask "Terminal type?" ${MDTERM:-vt220}
	TERM=$resp
	export TERM

	md_set_term
}

welcome() {
	local _q

	cat <<__EOT

Welcome to the ${OBSD} $MODE program.

This program will help you $MODE MirOS. At any prompt except password prompts
you can run a shell command by typing '!foo', or escape to a shell by typing
'!'. Default answers are shown in []'s and are selected by just RETURN, but
sometimes there is no default. At any time you can exit this programme by
pressing Control-C and then RETURN, but quitting during an $MODE can leave
your system in an inconsistent state.

__EOT

	# Configure the terminal.
	set_term

	cat <<__EOT

IS YOUR DATA BACKED UP? As with anything that modifies disk contents, this
program can cause SIGNIFICANT data loss.

__EOT

	case $MODE in
	upgrade)
		cat <<__EOT
NOTE: before your system has been upgraded, you must manually merge any changes
to files in the 'etc' and 'xetc' set into the files already on your system.

__EOT
		_q="Proceed with upgrade?"
		;;

	install)
		cat <<__EOT
It is often helpful to have the installation notes handy. For complex disk
configurations, relevant disk hardware manuals and a calculator are useful.

__EOT

		if [ -f /etc/fstab ]; then
			cat <<__EOT
You seem to be trying to restart an interrupted installation! You can skip
the disk preparation steps and continue, or you can reboot and start over.

__EOT
			_q="Skip disk initialization?"
		else
			_q="Proceed with install?"
		fi
		;;
	esac

	ask_yn "$_q"
	if [[ $resp == n ]]; then
		cat <<__EOT

Enter 'halt -p' or 'reboot' at the prompt to gracefully exit MirBSD.
You can then power cycle the machine and boot BSD or your other OSes.
__EOT
		exit
	fi

	echo "Cool!  Let's get to it..."
}

get_dkdevs() {
	bsort $(sed -ne "${MDDISKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}" -e '/^raid[0-9][0-9]* /s/ .*//p' -e '/^ccd[0-9][0-9]* /s/ .*//p' /var/run/dmesg.boot)
}

get_cddevs() {
	bsort $(sed -ne "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}" /var/run/dmesg.boot)
}

get_ifdevs() {
	ifconfig -a \
	    | egrep -v '^[[:space:]]|(bridge|enc|gif|gre|lo|pflog|pfsync|ppp|sl|tun|vlan)[[:digit:]]+:' \
	    | sed -ne 's/^\(.*\):.*/\1/p'
}

# Ask for a password, saving the input in $resp.
#    Display $1 as the prompt.
#    *Don't* allow the '!' options that ask does.
#    *Don't* echo input.
askpass() {
	set -o noglob
	stty -echo
	read resp?"$1 "
	stty echo
	set +o noglob
	echo
}

# Ask for user input.
#
#    $1    = the question to ask the user
#    $2    = the default answer
#
# Save the user input (or the default) in $resp.
#
# Allow the user to escape to shells ('!') or execute commands
# ('!foo') before entering the input.
ask() {
	local _question=$1 _default=$2

	set -o noglob
	while : ; do
		echo -n "$_question "
		[[ -z $_default ]] || echo -n "[$_default] "
		read resp
		case $resp in
		!)	echo "Type 'exit' to return to install."
			sh
			;;
		!*)	eval ${resp#?}
			;;
		*)	: ${resp:=$_default}
			break
			;;
		esac
	done
	set +o noglob
}

# Ask for user input until a non-empty reply is entered.
#
#    $1    = the question to ask the user
#    $2    = the default answer
#
# Save the user input (or the default) in $resp.
ask_until() {
	resp=
	while [[ -z $resp ]]; do
		ask "$1" "$2"
	done
}

# Ask the user for a y or n, and insist on 'y', 'yes', 'n' or 'no'.
#
#    $1    = the question to ask the user
#    $2    = the default answer (assumed to be 'n' if empty).
#
# Return 'y' or 'n' in $resp.
ask_yn() {
	local _q=$1 _a=${2:-no} _resp
	typeset -l _resp

	while : ; do
		ask "$_q" "$_a"
		_resp=$resp
		case $_resp in
		y|yes)	resp=y; return ;;
		n|no)	resp=n; return ;;
		esac
	done
 }

# Ask for the user to select a device from a list generated by scanning
# /var/run/dmesg.boot, and make the device if it doesn't exist.
#
# $1 = device name (disk, cd, etc.)
# $2 = question to ask
# $3 = list of devices from /var/run/dmesg.boot scan
# $4 = default device. If it is not specified, use the first device in $3
# $5 = error message if no devices in $3, defaults to 'No $1s found.'
#
# $resp holds device selected at exit, or 'done'
ask_which() {
	local _name=$1 _query=$2 _devs=$3 _defdev=$4 _err=$5

	set -- $_devs
	if [[ $# -lt 1 ]]; then
		echo "${_err:=No ${_name}s found}."
		resp=done
		return
	fi
	: ${_defdev:=$1}

	# Eliminate extraneous (especially trailing) whitespace in _devs.
	_devs="$*"

	while : ; do
		# Put both lines in ask prompt, rather than use a
		# separate 'echo' to ensure the entire question is
		# re-ask'ed after a '!' or '!foo' shell escape.
		ask "Available ${_name}s are: ${_devs}.\nWhich one ${_query}? (or 'done')" "$_defdev"
		[[ $resp == done ]] && break

		# Quote $resp to prevent user from confusing isin() by
		# entering something like 'a a'.
		if isin "$resp" $_devs; then
			makedev $resp && break
		else
			echo "'$resp' is not a valid choice."
		fi
	done
}

# test the first argument against the remaining ones, return success on a match
isin() {
	local	_a=$1 _b

	shift
	for _b; do
		[ "$_a" = "$_b" ] && return 0
	done
	return 1
}

# add first argument to list formed by the remaining arguments
# adds to the tail if the element does not already exist
addel() {
	local	_a=$1 _b _seen=false

	shift

	echo -n "$*"
	isin "$_a" $* || echo -n " $_a"
}

# remove all occurrences of first argument from list formed by
# the remaining arguments
rmel() {
	local	_a=$1 _b

	shift
	for _b; do
		[ "$_a" != "$_b" ] && echo -n "$_b "
	done
}

bsort() {
	local _l _a=$1 _b

	[[ $# -gt 0 ]] || return

	shift
	for _b; do
		if [[ $_a != $_b ]]; then
			if [[ $_a >$_b ]]; then
				_l="$_a $_l"; _a=$_b
			else
				_l="$_b $_l"
			fi
		fi
	done

	# Output the smallest value found.
	echo "$_a "

	# Sort remaining values.
	bsort $_l
}

# Add interesting/useful comments from mnt/etc/$1 to /tmp/$1.
#
# $1 == file in /tmp and /mnt/etc directories
save_comments() {
	local _file=$1

	if [[ -f /mnt/etc/$_file ]]; then
		grep "^#" /mnt/etc/$_file >/tmp/$_file.new
		[[ -f /tmp/$_file ]] && cat /tmp/$_file >>/tmp/$_file.new
		mv /tmp/$_file.new /tmp/$_file
	fi
}

# Offer to edit a file in /tmp and execute ${EDITOR} to do so if the user
# accepts the offer.
#
# $1 == file in /tmp to edit
edit_tmp_file() {
	local _file=$1

	ask_yn "Edit $_file with $EDITOR?"
	[[ $resp == y ]] && $EDITOR /tmp/$_file
}

# Offer to shell out for manual network configuration, and do so if
# the user accepts the offer.
manual_net_cfg() {
	ask_yn "Do you want to do any manual network configuration?"

	[[ $resp == y ]] && { echo "Type 'exit' to return to $MODE."; sh; }
}

# log in via ftp to host $1 as user $2 with password $3
# and return a list of all files in the directory $4 on stdout
ftp_list_files() {
	ftp ${_ftp_active} -V -n "$1" <<__EOT
user "$2" "$3"
cd "$4"
ls
quit
__EOT
}

# Check for the existence of the device nodes for the
# supplied device name. If they are missing (as indicated
# by r${1}c not being found) then create them. In either
# case, return true if the nodes exist and false if not.
#
# $1 = name of the device that is about to be used.
makedev() {
	local _dev=$1 _node=/dev/r${1}c

	# Don't need to make network interface devices nodes. If the device
	# nodes exist, don't need to create them.
	if isin $_dev $IFDEVS || [[ -c $_node ]]; then
		return 0
	fi

	if [[ ! -r /dev/MAKEDEV ]]; then
		echo "No /dev/MAKEDEV. Can't create device nodes for ${_dev}."
		return 1
	fi

	(cd /dev; sh MAKEDEV $_dev)

	# If the device nodes still do not exist, assume MAKEDEV issued a useful
	# error message and return false.
	[[ -c $_node ]] || return 1

	DEVSMADE=$(addel $_dev $DEVSMADE)
}

# Create an entry in the hosts file. If an entry with the
# same symbolic name already exists, delete it.
# $1 - IP address
# $2 - symbolic name
addhostent() {
	sed "/ $2\$/d" /tmp/hosts >/tmp/hosts.new
	mv /tmp/hosts.new /tmp/hosts

	echo "$1 $2" >>/tmp/hosts
}

# Show list of available sets and let the user select which sets to install.
#
# $1 = available sets
# $2 = already selected sets
#
# Set $resp to list of selected sets.
select_sets() {
	local _avail=$1 _selected=$2 _next _f _action

	while : ; do
		_action=
		cat <<__EOT

The following sets are available. Enter a filename, 'all' to select
all the sets, or 'done'. You may de-select a set by prepending a '-'
to its name.

__EOT
		_next=
		for _f in $_avail; do
			if isin $_f $_selected; then
				echo "	[X] $_f"
			else
				echo "	[ ] $_f"
				: ${_next:=$_f}
			fi
		done
		: ${_next:=done}

		ask "\nFile name? (or 'done')" "$_next"
		case $resp in
		done)	break ;;
		-*)	_action=rmel ;;
		esac

		: ${_action:=addel}
		resp=${resp#+|-}

		case $resp in
		"")	continue ;;
		all)	resp=* ;;
		esac

		# Use @@($resp) rather than just $resp to protect
		# against silly user input that might cause syntax
		# errors.
		for _f in $_avail; do
			eval "case $_f in
			@@($resp)) _selected=\`$_action $_f \$_selected\` ;;
			esac"
		done
	done

	resp=$_selected
}

configure_ifs() {
	local _IFDEVS=$IFDEVS _ifs _name _media _hn

	while : ; do
		ask_which "interface" "do you wish to initialize" "$_IFDEVS" \
			"" "No more interfaces to initialize"
		[[ $resp == done ]] && break

		_ifs=$resp
		_hn=/tmp/hostname.$_ifs

		# Get symbolic name - will be used in DHCP requests.
		ask "Symbolic (host) name for $_ifs?" "$(hostname -s)"
		_name=$resp

		# Get and apply media options.
		_media=$(ifconfig -m $_ifs | grep "media ")
		if [[ -n $_media ]]; then
			cat << __EOT
The media options for $_ifs are currently
$(ifconfig -m $_ifs | sed -n '/supported/D;/media:/p')
__EOT
			ask_yn "Do you want to change the media options?"
			case $resp in
			y)	cat << __EOT
Supported media options for $_ifs are:
$_media
__EOT
				ask "Media options for $_ifs?"
				_media=$resp
				ifconfig $_ifs $_media || return 1
				;;
			n)	_media=
				;;
			esac
		fi

		rm -f $_hn
		v4_config "$_ifs" "$_media" "$_name" "$_hn"

		[[ -f $_hn ]] && _IFDEVS=$(rmel "$_ifs" $_IFDEVS)
	done
}

# Output '<UP | DOWN> [<addr> <netmask> <rest of inet line>]'.
#
# $1 == interface
v4_info() {
	ifconfig $1 inet | sed -n '
		1s/.*<UP,.*/UP/p
		1s/.*<.*/DOWN/p
		/inet/s/netmask//
		/inet/s///p'
}

# Construct etc/dhclient.conf and issue DHCP request. Return FALSE if
# no IP address or 0.0.0.0 assigned to $1.
#
# $1 == interface
# $2 == hostname (optional).
dhcp_request() {
	local _ifs=$1 _hostname=$2

	echo "initial-interval 1;" >/etc/dhclient.conf

	if [[ -n $_hostname ]]; then
		echo "send host-name \"$_hostname\";" >>/etc/dhclient.conf
		echo "Issuing hostname-associated DHCP request for $_ifs."
	else
		echo "Issuing free-roaming DHCP request for $_ifs."
	fi

	cat >>/etc/dhclient.conf <<__EOT
request subnet-mask,
	broadcast-address,
	routers,
	domain-name,
	domain-name-servers,
	host-name;
__EOT

	cat >>/etc/resolv.conf.tail <<__EOT
lookup file bind
__EOT

	dhclient $_ifs

	set -- $(v4_info $_ifs)

	if [[ $1 == UP && $2 == "0.0.0.0" ]]; then
		ifconfig $_ifs delete down
		rm /etc/dhclient.conf /etc/resolv.conf.tail
		return 1
	fi

	# Move configuration files to where they will be copied to the
	# installed system. Overwrites configuration information from last
	# successful dhcp attempt.
	mv /etc/dhclient.conf /tmp/dhclient.conf
	mv /etc/resolv.conf.tail /tmp/resolv.conf.tail

	return 0
}

v4_config() {
	local _ifs=$1 _media=$2 _name=$3 _hn=$4 _prompt

	set -- $(v4_info $_ifs)
	if [[ -n $2 ]]; then
		ifconfig $_ifs inet $2 delete
		[[ $2 != "0.0.0.0" ]] && { _addr=$2; _mask=$3; }
	fi

	[[ -x /sbin/dhclient ]] && _prompt=" or 'dhcp'"
	_prompt="IPv4 address for $_ifs? (or 'none'$_prompt)"

	ask_until "$_prompt" "$_addr"
	case $resp in
	none)	;;
	dhcp)	if [[ ! -x /sbin/dhclient ]]; then
			echo "DHCP not possible - no /sbin/dhclient."
		elif dhcp_request $_ifs "$_name" || dhcp_request $_ifs ; then
			addhostent "127.0.0.1" "$_name"
			echo "dhcp NONE NONE NONE $_media" > $_hn
		fi
		;;
	*)	_addr=$resp
		ask_until "Netmask?" "${_mask:=255.255.255.0}"
		if ifconfig $_ifs inet $_addr netmask $resp up ; then
			addhostent "$_addr" "$_name"
			echo "inet $_addr $resp NONE $_media" > $_hn
		fi
		;;
	esac
}

v4_defroute() {
	local _dr _prompt=" or 'none'"

	[[ -x /sbin/dhclient ]] && _prompt=", 'dhcp'$_prompt"
	_prompt="Default IPv4 route? (IPv4 address$_prompt)"

	_dr=$(route -n show -inet | sed -ne '/^default */{s///; s/ .*//; p;}')
	[[ -f /tmp/dhclient.conf ]] && _dr=dhcp

	while : ; do
		ask_until "$_prompt" "$_dr"
		case $resp in
		none|dhcp) break ;;
		esac
		route delete -inet default > /dev/null 2>&1
		route -n add -inet -host default "$resp" && {
			echo "route -n add -inet -host default $resp" \
			    >/tmp/hostname.local
			break
		}
		# Put the old default route back. The new one did not work.
		route -n add -inet -host default $_dr >/dev/null 2>&1
	done
}

# Returns true if $1 contains only alphanumerics
isalphanumeric() {
	local _n=$1
	while [[ ${#_n} -ne 0 ]]; do
		case $_n in
		[A-Za-z0-9]*)	;;
		*)		return 1;;
		esac
		_n=${_n#?}
	done
	return 0
}

# Much of this is gratuitously stolen from /etc/netstart.
enable_network() {
	local _netfile

	# Copy any required or optional files found
	for _netfile in hosts dhclient.conf resolv.conf resolv.conf.tail protocols services; do
		if [ -f /mnt/etc/${_netfile} ]; then
			cp /mnt/etc/${_netfile} /etc/${_netfile}
		fi
	done

	DIDNET=y

	# Set the address for the loopback interface. Bringing the
	# interface up, automatically invokes the IPv6 address ::1.
	ifconfig lo0 inet 127.0.0.1

	# configure all of the non-loopback interfaces which we know about.
	# refer to hostname.if(5)
	for hn in /mnt/etc/hostname.*; do
		# Strip off /mnt/etc/hostname. prefix
		if=${hn#/mnt/etc/hostname.}

		# Interface names must be alphanumeric only. We check to avoid
		# configuring backup or temp files, and to catch the "*" case.
		isalphanumeric "$if" || continue
		[[ $if = local ]] && continue
		ifconfig $if >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			continue
		fi

		# Now parse the hostname.* file
		while :; do
			if [ "$cmd2" ]; then
				# we are carrying over from the 'read dt dtaddr' last time
				set -- $cmd2
				af=$1 name=$2 mask=$3 bcaddr=$4 ext1=$5 cmd2=
				# make sure and get any remaining args in ext2, like the read below
				i=1; while [ i -lt 6 -a -n "$1" ]; do shift; let i=i+1; done
				ext2="$@@"
			else
				# read the next line or exit the while loop
				read af name mask bcaddr ext1 ext2 || break
			fi
			# $af can be "dhcp", "up", "rtsol", an address family, commands, or
			# a comment.
			case $af in
			"route"|"!route")
				routep="-n $name"
				[ x"$name" = x"+n" ] && routep=
				cmd="/sbin/route ${routep} ${mask} ${bcaddr} ${ext1} ${ext2}"
				;;
			"#"*|"!"*|"bridge"|""|"rtsol")
				# skip comments, user commands, bridges,
				# IPv6 rtsol and empty lines
				continue
				;;
			"dhcp")	[ "$name" = "NONE" ] && name=
				[ "$mask" = "NONE" ] && mask=
				[ "$bcaddr" = "NONE" ] && bcaddr=
				ifconfig $if $name $mask $bcaddr $ext1 $ext2 down
				cmd="dhclient $if"
				;;
			"up")
				# The only one of these guaranteed to be set is $if
				# the remaining ones exist so that media controls work
				cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 up"
				;;
			*)	read dt dtaddr
				if [ "$name" = "alias" ]; then
					# perform a 'shift' of sorts
					alias=$name
					name=$mask
					mask=$bcaddr
					bcaddr=$ext1
					ext1=$ext2
					ext2=
				else
					alias=
				fi
				cmd="ifconfig $if $af $alias $name "
				case $dt in
				dest)	cmd="$cmd $dtaddr"
					;;
				[a-z!]*)
					cmd2="$dt $dtaddr"
					;;
				esac
				if [ ! -n "$name" ]; then
					echo "/mnt/etc/hostname.$if: invalid network configuration file"
					return
				fi
				case $af in
				inet)	[ "$mask" ] && cmd="$cmd netmask $mask"
					if [ "$bcaddr" -a "$bcaddr" != "NONE" ]; then
						cmd="$cmd broadcast $bcaddr"
					fi
					[ "$alias" ] && rtcmd="; route -qn add -host $name 127.0.0.1"
					;;
				inet6)
					# Ignore IPv6 setup
					continue
					;;
				*)	cmd="$cmd $mask $bcaddr"
				esac
				cmd="$cmd $ext1 $ext2$rtcmd" rtcmd=
				;;
			esac
			eval "$cmd"
		done </mnt/etc/hostname.$if
	done

	# Use loopback, not the wire.
	route -qn add -host $(hostname) 127.0.0.1 >/dev/null
	route -qn add -net 127 127.0.0.1 -reject >/dev/null

	# Grab default route, if existent
	if [ -s /mnt/etc/hostname.local ]; then
		cmd="$(grep ^route /mnt/etc/hostname.local | grep default)"
		[[ -n $cmd ]] && eval "$cmd"
	fi

	# Display results...
	echo "Network interface configuration:"
	ifconfig -am

	# enable the resolver if resolv.conf is available
	route -n show
	if [ -f /etc/resolv.conf ]; then
		echo "\nResolver enabled."
	else
		echo "\nResolver not enabled."
	fi
}

# Install a user-selected subset of the files in $2 from the source
# named in $1. Display an error message for failed installs so the
# user will know to try again.
install_files() {
	local _src=$1 _files=$2 _f _sets _get_sets

	# Initialize _sets to the list of sets found in _src, and initialize
	# _get_sets to the intersection of _sets and DEFAULTSETS.
	#
	# Sets will be installed in the order given in THESETS to ensure proper
	# installation. So, to minimize user confusion display the sets in the
	# order in which they will be installed.
	for _f in $THESETS; do
		isin $_f $_files || continue;
		_sets=$(addel $_f $_sets)
		isin $_f $DEFAULTSETS && _get_sets=$(addel $_f $_get_sets)
	done

	if [[ -z $_sets ]]; then
		# Show $_src, but delete any ftp password.
		cat <<__EOT
No $OBSD sets were found at

	$(echo $_src | sed -e 's/\(^ftp:\/\/[^/]*\)\(:[^/]*\)\(@@.*\)/\1\3/')

Set names are: $THESETS
__EOT
		return
	fi

	select_sets "$_sets" "$_get_sets"

	[[ -n $resp ]] || return
	_get_sets=$resp

	ask_yn "Ready to $MODE sets?" yes
	[[ $resp = n ]] && return

	for _f in $THESETS; do
		isin $_f $_get_sets || continue
		echo "Getting $_f ..."
		case $_f in
		*.ngz)	ftp $_ftp_active -o - -V -m "$_src/$_f" | tar zxphf - -C /mnt
			;;
		*)	ftp $_ftp_active -o "/mnt/$_f" -V -m "$_src/$_f"
			;;
		esac
		if [ $? -ne 0 ]; then
			echo "'$_f' did not install correctly."
		else
			DEFAULTSETS=$(rmel $_f $DEFAULTSETS)
		fi
	done
}

# Encode $1 as specified for usercodes and passwords in RFC 1738
# section 3.1 and section 5.
#
# Escape everything between 0x20 and 0x7e to avoid both illegal url
# characters and characters causing problems during script processing.
#
# *NOTE*
#	1) quotes around $1 are required to preserve trailing or
#	   embeddded blanks in usercodes and passwords.
#	2) substitute '%' FIRST so it doesn't eliminate '%' chars we insert.
encode_for_url() {
	echo "$1" | sed -e "
s/%/%25/g
s/ /%20/g
s/!/%21/g
s/\"/%22/g
s/#/%23/g
s/\\\$/%24/g
s/&/%26/g
s/'/%27/g
s/(/%28/g
s/)/%29/g
s/\*/%2a/g
s/+/%2b/g
s/,/%2c/g
s/-/%2d/g
s/\./%2e/g
s/\//%2f/g
s/:/%3a/g
s/;/%3b/g
s/</%3c/g
s/=/%3d/g
s/>/%3e/g
s/?/%3f/g
s/@@/%40/g
s/\[/%5b/g
s/\\\\/%5c/g
s/]/%5d/g
s/\^/%5e/g
s/_/%5f/g
s/\`/%60/g
s/{/%7b/g
s/|/%7c/g
s/}/%7d/g
s/~/%7e/g
"
}

# Check for the presence of an error message in the output of the ftp commands
# used to get the list of files in a directory.
#
# $1 = error message to look for
# $2 = ftp command output
ftp_error() {
	if [[ -n $(echo "$2" | grep "$1") ]]; then
		echo $1
		return 0
	fi
	return 1
}

# Get several parameters from the user, and xfer
# files from the server.
# $1 = url type (ftp or http)
# Note:	_ftp_server_ip, _ftp_server_dir, _ftp_server_login,
#	and _ftp_active must be global.
install_url() {
	local _url_type=$1 _file_list _url_base _oifs _prompt _passwd

	donetconfig

	ask "HTTP/FTP proxy URL? (e.g. 'http://proxy:8080', or 'none')" \
	    "${ftp_proxy:-none}"
	unset ftp_proxy http_proxy
	[[ $resp == none ]] || export ftp_proxy=$resp http_proxy=$resp

	rm -f $SERVERLIST
#	ask_yn "Display the list of known $_url_type servers?" "${_get_server_list:-yes}"
#	_get_server_list=$resp
	_get_server_list=n
#	if [[ $_get_server_list == y ]]; then
#		# ftp.openbsd.org == 129.128.5.191 and will remain at
#		# that address for the forseeable future.
#		echo -n "Getting the list from 129.128.5.191 (ftp.openbsd.org)..."
#		ftp $_ftp_active -V -a -o - \
#			ftp://129.128.5.191/$FTPDIR/ftplist 2>/tmp/ftplisterr \
#			| sed -ne "/^${_url_type}:\/\//s///p" >$SERVERLIST
#		if [[ -s $SERVERLIST ]]; then
#			echo "done."
#			_prompt="Server? (IP address, hostname, list#, 'done' or '?')"
#			cat -n $SERVERLIST | less -XE
#		else
#			echo "FAILED."
#			cat /tmp/ftplisterr
#		fi
#	fi

	# Get server IP address or hostname
	: ${_prompt:="Server? (IP address, hostname or 'done')"}
	while : ; do
		eval resp=\$_${_url_type}_server_ip
		ask_until "$_prompt" "$resp"
		case $resp in
		done)	return ;;
		"?")	[[ -s $SERVERLIST ]] || continue
			cat -n $SERVERLIST | less -XE
			;;
		+([0-9]))
			# A numeric hostname is ignored. A number is only used
			# as a line number in $SERVERLIST.
			[[ -s $SERVERLIST ]] || continue
			set -- $(sed -ne "${resp}p" $SERVERLIST)
			[[ $# -lt 1 ]] && { echo "There is no line $resp."; continue; }
			echo "Using	$*"
			eval _${_url_type}_server_ip=${1%%/*}
			eval _${_url_type}_server_dir=${1#*/}/$SETDIR
			# Repeat loop to get user to confirm server address.
			;;
		*)	eval _${_url_type}_server_ip=$resp
			break
			;;
		esac
	done

	# Some older servers lie about their support for passive mode ftp, so
	# ask the user if it worth trying passive mode to the chosen server.
	# Irrelevant if using a proxy.
	if [[ $_url_type == ftp && -z $ftp_proxy ]]; then
		case $_ftp_active in
		-A)	resp=no ;;
		*)	resp=yes ;;
		esac

		unset _ftp_active
		ask_yn "Does the server support passive mode ftp?" $resp
		[[ $resp == n ]] && _ftp_active=-A
	fi

	# Get server directory
	eval resp=\$_${_url_type}_server_dir
	ask_until "Server directory?" "${resp:-mbsd7}"
	eval _${_url_type}_server_dir=$resp

	if [[ $_url_type == ftp ]]; then
		# Get login name, setting IFS to nothing so trailing or
		# embedded blanks are preserved!
		_oifs=$IFS
		IFS=
		ask_until "Login?" "${_ftp_server_login:=anonymous}"
		_ftp_server_login=$resp

		# Get password unless anonymous
		_passwd=root@@$(hostname)
		if [[ $_ftp_server_login != anonymous ]]; then
			resp=
			while [[ -z $resp ]]; do
				askpass "Password? (will not echo)"
			done
			_passwd=$resp
		fi
		IFS=$_oifs
	fi

	# Build up the base url since it is so nasty...
	_url_base=$_url_type://
	if [[ $_url_type == ftp && $_ftp_server_login != anonymous ]]; then
		_url_base=$_url_base$(encode_for_url "$_ftp_server_login"):$(encode_for_url "$_passwd")@@
	fi
	eval _url_base=$_url_base\$_${_url_type}_server_ip/\$_${_url_type}_server_dir

	# Get list of files from the server.
	if [[ $_url_type == ftp && -z $ftp_proxy ]]; then
		_file_list=$(ftp_list_files "$_ftp_server_ip" "$_ftp_server_login" "$_passwd" "$_ftp_server_dir")
		ftp_error "Login failed." "$_file_list" && return
		ftp_error "No such file or directory." "$_file_list" && return
	else
		# Assumes index file is "index.txt" for http (or proxy)
		# We can't use index.html since the format is server-dependent
		_file_list=$(ftp -o - -V "$_url_base/index.txt" | sed 's///')
	fi

	install_files "$_url_base" "$_file_list"
}

# $1 - mount point directory is relative to
# $2 - default directory
install_mounted_fs() {
	local _mp=$1 _dir=$2

	while : ; do
		ask_until "Pathname to the sets? (or 'done')" "$_dir"
		case $resp in
		done)	return
			;;
		*)
			# Accept a valid $_mp relative path.
			[[ -d $_mp/$resp ]] && { _dir=$_mp/$resp; break; }
			# Accept a valid absolute path.
			[[ -d /$resp ]] && { _dir=/$resp; break; }
			# Otherwise ask again, with original default dir.
			echo "The directory '$resp' does not exist."
			;;
		esac
	done

	install_files "file://$_dir" "$(ls -l $_dir)"
}

install_cdrom() {
	local _drive _part _fstype _directory _n

	ask_which "CD-ROM" "contains the ${MODE} media" "$CDDEVS"
	[[ $resp == done ]] && return

	_drive=$resp

	# If it is an ISO9660 CD-ROM, we don't need to ask any other questions
	_n=0
	until disklabel $_drive >/tmp/label.$_drive 2>&1; do
		# Try up to 6 times to access the CD
		if egrep -q '(Input/output error)|(sector size 0)' /tmp/label.$_drive; then
			_n=$(( $_n + 1 ))
			if [ _n -le 5 ]; then
				echo "I/O error accessing $_drive; retrying"
				sleep 10
			else
				echo "Cannot access $_drive."
				return
			fi
		else
			break
		fi
	done

	echo
	if grep -q '^ *c: .*ISO9660' /tmp/label.$_drive; then
		_fstype=cd9660
		_part=c
	else
		# Get partition from user
		resp=
		while [ -z "$resp" ]; do
			ask "CD-ROM partition to mount? (normally 'c')" c
			case $resp in
			[a-p])
				_part=$resp
				;;
			*)	echo "Invalid response: $resp"
				# force loop to repeat
				resp=
				;;
			esac
		done

		# Ask for filesystem type
		cat <<__EOT

Two CD-ROM filesystem types are currently supported by this program:
cd9660		ISO-9660
ffs		Berkeley Fast Filesystem

__EOT
		resp=
		while [ -z "$resp" ]; do
			ask "Which filesystem type?" cd9660
			case $resp in
			cd9660|ffs)
				_fstype=$resp
				;;
			*)	echo "Invalid response: '$resp'"
				# force loop to repeat
				resp=
				;;
			esac
		done
	fi

	rm -f /tmp/label.$_drive

	# Mount the CD-ROM
	if ! mount -t ${_fstype} -o ro /dev/${_drive}${_part} /mnt2; then
		echo "Cannot mount CD-ROM drive."
		return
	fi

	install_mounted_fs /mnt2 "$SETDIR"
	umount -f /mnt2 >/dev/null 2>&1
}

# Mount a disk on /mnt2. The set of disk devices to choose from
# is $DKDEVS.
# returns 0 on success, 1 on failure
mount_a_disk() {
	local _drive _def_partition _partition_range _partition
	local _fstype _fsopts

	ask_which "disk" "contains the ${MODE} sets" "$DKDEVS"
	[[ $resp == done ]] && return 1

	_drive=$resp

	# Get partition
	cat <<__EOT

The following partitions have been found on $_drive:

__EOT
	disklabel $_drive 2>/dev/null | grep '^  .:'
	echo
	_likely_partition_range=$(disklabel $_drive 2>/dev/null | \
		sed -n	-e '/swap/s/.*//' -e '/unused/s/.*//' \
			-e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
			-e '${g;s/\n//g;s/^/[/;s/$/]/p;}')
	_partition_range=$(disklabel $_drive 2>/dev/null | \
		sed -n	-e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
			-e '${g;s/\n//g;s/^/[/;s/$/]/p;}')
	_def_partition=$(echo $_likely_partition_range | \
		sed -n 's/^\[\(.\).*\]/\1/p')
	if [ -z "$_def_partition" ]; then
		_def_partition=$(echo $_partition_range | \
			sed -n 's/^\[\(.\).*\]/\1/p')
		if [ -z "$_def_partition" ]; then
			echo "There are no usable partitions on that disk"
			return 1
		fi
	fi

	resp=
	while [ -z "$resp" ]; do
		ask "Partition?" "$_def_partition"
		case $resp in
		$_partition_range)
			_partition=$resp
			;;
		*)	echo "Invalid response: $resp"
			# force loop to repeat
			resp=
			;;
		esac
	done

	# Ask for filesystem type
	cat <<__EOT

The following filesystem types are supported:
default		(deduced from the disklabel)
ffs
msdos
$MDFSTYPE
__EOT

	resp=
	while [ -z "$resp" ]; do
		ask "Which filesystem type?" default
		case $resp in
		default)
			;;
		ffs)	_fstype="-t ffs"
			_fsopts=softdep
			;;
		msdos)	_fstype="-t msdos"
			_fsopts="-l"
			;;
		$MDFSTYPE)
			_fstype="-t $resp"
			_fsopts=$MDFSOPTS
			;;
		*)	echo "Invalid response: $resp"
			# force loop to repeat
			resp=
			;;
		esac
	done

	# Mount the disk read-only
	if ! mount $_fstype -o ro,$_fsopts /dev/${_drive}${_partition} /mnt2; then
		echo "Cannot mount disk."
		return 1
	fi

	return 0
}

install_disk() {
	if mount_a_disk; then
		install_mounted_fs /mnt2
		umount -f /mnt2 >/dev/null 2>&1
	fi
}

install_nfs() {
	# Can we actually mount NFS filesystems?
	if [ ! -f /sbin/mount_nfs ]; then
		echo "/sbin/mount_nfs not found. Cannot mount NFS filesystems."
		return
	fi

	donetconfig

	# Get the IP address of the server
	ask_until "Server IP address or hostname?" "$_nfs_server_ip"
	_nfs_server_ip=$resp

	# Get server path to mount
	ask_until "Filesystem on server to mount?" "$_nfs_server_path"
	_nfs_server_path=$resp

	# Determine use of TCP
	_nfs_tcp=
	ask_yn "Use TCP transport? (only works with capable NFS server)" yes
	[[ $resp == n ]] || _nfs_tcp=-T

	# Mount the server
	if ! mount_nfs $_nfs_tcp -o ro ${_nfs_server_ip}:${_nfs_server_path} /mnt2; then
		echo "Cannot mount NFS server."
		return
	fi

	install_mounted_fs /mnt2
	umount -f /mnt2 >/dev/null 2>&1
}

install_tape() {
	local _xcmd

	# Get the name of the tape from the user.
	cat <<__EOT

The installation program needs to know which tape device to use. Make
sure you use a "no rewind on close" device.

__EOT
	ask_until "Name of tape device?" "${TAPE##*/}"
	TAPE=/dev/${resp##*/}
	if [ ! -c $TAPE ]; then
		echo "$TAPE does not exist or is not a character special file."
		return
	fi
	export TAPE

	# Rewind the tape device
	echo -n "Rewinding ${TAPE} (mt rewind)..."
	if ! mt rewind; then
		echo "FAILED."
		return
	fi
	echo "done."

	# Get the file number
	resp=
	while [ -z "$resp" ]; do
		ask "File number?"
		case $resp in
		[1-9]*)	_nskip=$(( $resp - 1 ))
			;;
		*)	echo "Invalid file number ${resp}."
			# force loop to repeat
			resp=
			;;
		esac
	done

	# Skip to correct file.
	if [ $_nskip -ne 0 ]; then
		echo -n "Skipping to source file (mt fsf ${_nskip})..."
		if ! mt fsf $_nskip; then
			echo "FAILED. Could not skip $_nskip files."
			return
		fi
		echo "done."
	fi

cat <<__EOT

There are 2 different ways the file can be stored on tape:

1) an image of a gzipped tar file
2) a standard tar image

__EOT

	resp=
	while [ -z "$resp" ]; do
		ask "Which way is it?" 1
		case $resp in
		1)	_xcmd="tar zxvphf -"
			;;
		2)	_xcmd="tar xvphf -"
			;;
		*)	echo "Invalid response: $resp."
			# force loop to repeat
			resp=
			;;
		esac
		( cd /mnt; dd if=$TAPE | $_xcmd )
	done
	echo "Extraction complete."
}

set_timezone() {
	local _zoneroot=/mnt/usr/share/zoneinfo/right/ _zonepath

	# If the timezone directory structure is not
	# available, return immediately.

	[[ ! -d $_zoneroot ]] && return

	if [[ -L /mnt/etc/localtime ]]; then
		TZ=$(ls -l /mnt/etc/localtime 2>/dev/null)
		TZ=${TZ#*${_zoneroot#/mnt}}
	fi

	: ${TZ:=GMT}

	while : ; do
		_zonepath=$_zoneroot

		ask "What timezone are you in? ('?' for list)" "$TZ"

		if [[ $resp == ? ]]; then
			ls -F ${_zonepath}
			continue;
		fi

		_zonepath=${_zonepath}${resp}

		while [[ -d $_zonepath ]]; do
			ask "What sub-timezone of '${_zonepath#$_zoneroot}' are you in? ('?' for list)"
			if [[ $resp == ? ]]; then
				ls -F $_zonepath
			else
				_zonepath=$_zonepath/$resp
			fi
		done

		if [[ -f $_zonepath ]]; then
			TZ=${_zonepath#$_zoneroot}
			echo -n "Setting local timezone to '$TZ'..."
			ln -sf /usr/share/zoneinfo/right/$TZ /mnt/etc/localtime
			echo "done."
			return
		fi

		echo -n "'${_zonepath#$_zoneroot}'"
		echo " is not a valid timezone on this system."
	done
}

# Check that required sets were successfully installed by checking
# for the presence of a 'random' selection of their contents.
#
# Required sets are:
#	1) bsd
#	2) baseXX
#	3) etcXX
#
# If a 'problem' set is found, add it back to DEFAULTSETS.
sane_install() {
	local _insane

	# Check if bsd is installed and >0 bytes in size.
	if [[ ! -s /mnt/bsd ]]; then
		_insane=y
		DEFAULTSETS=$(addel bsd $DEFAULTSETS)
		cat << __EOT
+*** 'bsd' must be (re)installed: no kernel found.
__EOT
	fi

	# Check if baseXX is installed.
	if [[ ! -d /mnt/sbin || ! -d /mnt/dev ]]; then
		_insane=y
		DEFAULTSETS=$(addel base${VERSION}.ngz $DEFAULTSETS)
		cat << __EOT
+*** 'base${VERSION}.tgz' must be (re)installed: /sbin or /dev is missing.
__EOT
	fi

	# Check if etcXX is installed.
	if [[ ! -s /mnt/etc/rc ]]; then
		_insane=y
		DEFAULTSETS=$(addel etc${VERSION}.ngz $DEFAULTSETS)
		cat << __EOT
+*** 'etc${VERSION}.tgz' must be (re)installed: /etc/rc is missing.
__EOT
	fi

	[[ -n $_insane ]] && return 1

	return 0
}

# Ask the user for locations of sets, and then install whatever sets the
# user selects from that location. Repeat as many times as the user
# needs to get all desired sets.
install_sets() {
	cat <<__EOT

You will now specify the location and names of the ${MODE} sets you want to
load. You will be able to repeat this step until all of your sets have been
successfully loaded. If you are not sure what sets to ${MODE}, refer to the
installation notes for details on the contents of each.
__EOT

	while : ; do
		cat <<__EOT

Sets can be located on a (m)ounted filesystem; a (c)drom, (d)isk or (t)ape
device; or a (f)tp, (n)fs or (h)ttp server.
__EOT
		ask "Where are the ${MODE} sets? (or 'done')"

		case $resp in
		done)	sane_install && return ;;
		c*|C*)	install_cdrom ;;
		d*|D*)	install_disk ;;
		f*|F*)	install_url ftp ;;
		h*|H*)	install_url http ;;
		m*|M*)	install_mounted_fs /mnt ;;
		n*|N*)	install_nfs ;;
		t*|T*)	install_tape ;;
		*)	;;
		esac
	done
}

# Create a skeletal but useful /etc/fstab from /tmp/fstab by stripping all
# comment lines and dropping all filesystems which
#
#       1) can't be mounted (no mount_* command is found),
#	2) have 'xx' in the option field (usually /altroot),
#	3) have 'noauto' in the option field,
#	4) are nfs (since name resolution may not be present),
#	5) are mfs (breaks install usually).
#
# In addition,
#
#	2) mount non-ffs filesystems read only,
#	3) prepend '/mnt' to all mount points,
#	4) delete any trailing '/' from the mount point (e.g. root),
#	5) leave out fs_freq and fs_passno fields.
#
# If no /etc/fstab is created, do not proceed with install/upgrade.
munge_fstab() {
	local _dev _mp _fstype _opt _rest

	while read _dev _mp _fstype _opt _rest; do
		# Drop irrelevant lines and filesystems.
		[[ $_dev == \#* || \
		    $_fstype == nfs || \
		    $_fstype == mfs || \
		    ! -f /sbin/mount_$_fstype || \
		    $_opt == *noauto* || \
		    $_opt == *xx* ]] && continue

		# Mount non-ffs filesystems read only.
		[[ $_fstype == ffs ]] || _opt=$(echo $_opt | sed -e 's/rw/ro/')

		# Write fs entry in fstab.
		# 1) prepend '/mnt' to the mount point.
		# 2) remove a trailing '/' from the mount point (e.g. root).
		# 3) leave out fs_freq and fs_passno fields (i.e. $_rest).
		echo $_dev /mnt${_mp%/} $_fstype $_opt

	done </tmp/fstab >/etc/fstab

	# If no /etc/fstab was created, we have nowhere to ${MODE} to.
	if [ ! -s /etc/fstab ]; then
		echo "Unable to create valid /etc/fstab."
		exit
	fi
}

# Must mount filesystems manually, one at a time, so we can make
# sure the mount points exist.
mount_fs() {
	local _async=$1 _dev _mp _fstype _opt _rest

	while read _dev _mp _fstype _opt _rest; do
		# If not the root filesystem, make sure the mount
		# point is present.
		[ "$_mp" = "/mnt" ] || mkdir -p $_mp

		# Mount the filesystem. If the mount fails, exit.
		if ! mount -v -t $_fstype $_async -o $_opt $_dev $_mp; then
		# If it failed, try without async (important for raid) first
			if ! mount -v -t $_fstype -o $_opt $_dev $_mp; then
			# In addition to the error message displayed by mount ...
			cat <<__EOT

FATAL ERROR:	Cannot mount filesystems. Double-check your configuration
		and restart the ${MODE}.

__EOT
			exit
		fi; fi
	done </etc/fstab
}

# Preen all filesystems in /etc/fstab that have a /sbin/fsck_XXX,
# showing individual results, but skipping $ROOTDEV. This was already
# fsck'ed successfully.
#
# Exit if any fsck's fail (but do them all before exiting!).
check_fs() {
	local _dev _mp _fstype _rest _fail

	echo "Checking non-root filesystems..."

	while read _dev _mp _fstype _rest; do
		[ "$_dev" != /dev/"$ROOTDEV" ] || continue
		[ -f "/sbin/fsck_$_fstype" ] || continue
		# Make sure device exists before fsck'ing it.
		_rest=${_dev#/dev/}
		makedev ${_rest%[a-p]} || continue
		echo -n "fsck -p ${_dev}..."
		if ! fsck -fp ${_dev} >/dev/null 2>&1; then
			echo "FAILED. You must fsck $_dev manually."
			_fail=y
		else
			echo "OK."
		fi
	done </etc/fstab

	echo "...done."

	[ "$_fail" ] && exit
}

# Extract fully qualified domain name from current hostname. If none is
# currently set, use 'my.domain'.
get_fqdn() {
	local _dn

	_dn=$(hostname)
	_dn=${_dn#$(hostname -s)}
	_dn=${_dn#.}

	echo "${_dn:=my.domain}"
}

donetconfig() {
	local _dn _ns

	[[ -n $DIDNET ]] && return

	DIDNET=y

	configure_ifs

	# As dhclient will populate /etc/resolv.conf, a symbolic link to
	# /tmp/resolv.conf.shadow, mv any such file to /tmp/resolv.conf
	# so it will eventually be copied to /mnt/etc/resolv.conf and will
	# not in the meantime remove the user's ability to choose to use it
	# or not, during the rest of the install.
	if [ -f /tmp/resolv.conf.shadow ]; then
		mv /tmp/resolv.conf.shadow /tmp/resolv.conf
		# Get nameserver address(es).
		_ns=$(sed -ne '/^nameserver /s///p' /tmp/resolv.conf)
		# Get default fully qualified domain name from *first* domain
		# given on *last* search or domain statement.
		_dn=$(sed -n \
			-e '/^domain[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
			-e '/^search[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
			-e '${g;p;}' /tmp/resolv.conf)
	fi

	# Get & apply fully qualified domain name to hostname.
	ask "DNS domain name? (e.g. 'bar.com')" "${_dn:=$(get_fqdn)}"
	hostname "$(hostname -s).$resp"

	# Get/Confirm nameservers, and construct appropriate resolv.conf.
	ask "DNS nameserver? (IP address or 'none')" "${_ns:=none}"
	if [[ $resp != none ]]; then
		echo "lookup file bind" >/tmp/resolv.conf
		for _ns in $resp; do
			echo "nameserver $_ns" >>/tmp/resolv.conf
		done
		ask_yn "Use the nameserver now?" yes
		[[ $resp == y ]] && cp /tmp/resolv.conf /tmp/resolv.conf.shadow
	fi

	# Get/Confirm an IPv4 default route if an IPv4 address was configured.
	[[ -n $(ifconfig -a | sed -ne '/[ 	]inet .* broadcast /p') ]] && v4_defroute

	edit_tmp_file hosts
	manual_net_cfg
}

populateusrlocal() {
	if [ -f /mnt/etc/mtree/BSD.local.dist ]; then
		/mnt/usr/sbin/chroot /mnt /usr/sbin/mtree -Uedqn -p /usr/local -f /etc/mtree/BSD.local.dist >/dev/null
	fi
}

questions() {
	ask_yn "Do you wish sshd(8) to be started by default?" yes
	if [[ $resp == n ]]; then
		echo "sshd_flags=NO		# disabled during install" \
		    >/mnt/etc/rc.conf.local
	fi

	[[ -n $MDXAPERTURE ]] || return

	ask_yn "Do you expect to run the X Window System?" yes
	if [[ $resp == y ]]; then
		sed -e "/^#\(machdep\.allowaperture=${MDXAPERTURE}\)/s//\1	/" \
		    /mnt/etc/sysctl.conf >/tmp/sysctl.conf
	fi
}

finish_up() {
	local _dev _mp _fstype _rest

	# Mount all known swap partitions.  This gives systems with little
	# memory a better chance at running 'MAKEDEV all'.
	if [[ -x /mnt/sbin/swapctl ]]; then
		/mnt/sbin/swapctl -a /dev/$SWAPDEV >/dev/null 2>&1
		# Can't do chmod && swapctl -A because devices are not yet
		# created on install'ed systems. On upgrade'ed system there
		# is a small chance the device does not exist on the ramdisk
		# and will thus not get mounted.
		while read _dev _mp _fstype _rest; do
			[[ $_fstype == swap ]] && \
			    /mnt/sbin/swapctl -a $_dev >/dev/null 2>&1
		done </mnt/etc/fstab
	fi

	echo -n "Making all device nodes..."
	cd /mnt/dev
	sh MAKEDEV all
	# Make sure any devices we added as a result of makedev() calls
	# are recreated in installed system.
	for _dev in $DEVSMADE; do
		sh MAKEDEV $_dev
	done
	echo "done."
	cd /

	md_installboot $ROOTDISK

	populateusrlocal

	[ -x /mnt/${MODE}.site ] && /mnt/usr/sbin/chroot /mnt /${MODE}.site

	# Pat on the back.
	cat <<__EOT

CONGRATULATIONS! Your MirBSD ${MODE} has been successfully completed!
To boot the new system, enter halt at the command prompt. Once the
system has halted, reset the machine and boot from the disk.

Hello there! We from the MirOS project would like to hear from you!
If you installed or updated your existing MirOS installation, which
architecture, maybe your country, a dmesg and a few words about how
you like MirOS. If you don't mind being counted to help us estimate
our userbase, mail to <miros-dev@@66h.42h.de> - thanks in advance!
__EOT

	md_congrats
}

# #######################################################################
#
# Initial actions common to both installs and upgrades.
#
# Some may require machine dependent routines, which may
# call functions defined above, so it's safest to put this
# code here rather than at the top of the file.
#
# #######################################################################

ROOTDISK=
ROOTDEV=

VERSION=8

VNAME="$(( $VERSION / 10 )).$(( $VERSION % 10 ))"
SETDIR="$VNAME/$ARCH"
OBSD="MirOS/BSD/$ARCH $VNAME"
SERVERLIST=/tmp/serverlist

# Do not limit ourselves during installs or upgrades.
for _opt in d f l m n p s; do
	ulimit -$_opt unlimited
done

# Extract and save one boot's worth of dmesg
dmesg | sed -ne '/^MirBSD /h;/^MirBSD /!H;${g;p;}' >/var/run/dmesg.boot

# Scan /var/run/dmesg.boot for disks and cds
DKDEVS=$(get_dkdevs)
CDDEVS=$(get_cddevs)
IFDEVS=$(get_ifdevs)

# Devices created with makedev().
DEVSMADE=

# Selected sets will be installed in the order they are listed in $THESETS.
# Ensure that siteXX.ngz is the *last* set listed so its contents overwrite
# the contents of the other sets, not the other way around.
THESETS="bsd bsd.rd $MDSETS"
DEFAULTSETS="bsd"
for _set in base etc gnu gcc xbase xetc ports pkgutl source xfree site; do
	[[ $MODE == upgrade && $_set == ?(x)etc ]] && continue
	THESETS="$THESETS ${_set}${VERSION}.ngz"
	isin $_set xbase xetc ports pkgutl source xfree site && continue
	DEFAULTSETS="$DEFAULTSETS ${_set}${VERSION}.ngz"
done

# decide upon an editor
if [ -z "$EDITOR" ]; then
	EDITOR=ed
	[ -x /usr/bin/vi ] && EDITOR=vi
	export EDITOR
	# for ksh line-editing (bsiegert@@, leave this in, thanks)
	set -o emacs
fi

# umount all filesystems, just in case we are re-running install or upgrade.
[[ -f /etc/fstab ]] && umount -av 1>/dev/null 2>&1
umount -v /mnt 1>/dev/null 2>&1

# Introduce ourselves.
welcome

# Get ROOTDISK, ROOTDEV and SWAPDEV.
if [[ $MODE == install && ! -f /etc/fstab ]]; then
	cat <<__EOT

You will now initialize the disk(s) that MirBSD will use. To enable all
available security features you should configure the disk(s) to allow the
creation of separate filesystems for /, /tmp, /var, /usr, and /home.

__EOT
fi

set -- $DKDEVS
[[ $# -gt 1 ]] && _defdsk=done

ask_which "disk" "is the root disk" "$DKDEVS" "$_defdsk"
[[ $resp == done ]] && exit

ROOTDISK=$resp
ROOTDEV=${ROOTDISK}a
SWAPDEV=${ROOTDISK}b
@


1.49
log
@* rename xfree set to xbase, to better match base/etc
* add xfree set, containing source code of X-Window
* fix list of default sets in install.sub too
* fix/optimise .profile for ramdisk
@
text
@d1 1
a1 1
# $MirBSD: src/distrib/miniroot/install.sub,v 1.48 2004/11/13 20:21:48 tg Exp $
d1758 1
a1758 1
for _set in base etc gnu gcc xbase xetc pkgutl source ports xfree site; do
d1761 1
a1761 1
	isin $_set xbase xetc pkgutl source ports xfree site && continue
@


1.48
log
@new sets:
 base	-> as usual; required, totally free
 etc	-> as usual; required
 gnu	-> src/gnu/*; "required"
 gcc	-> contrib/gcc/*; required for compiling
 pkgutl	-> pkg_*(8) and their manpages
 site	-> as usual
 source	-> as usual (but without X-Window)
 ports	-> as usual
 xetc	-> /etc for X
 xfree	-> rest of X

discussing this with bsiegert@@ in IRC right now
@
text
@d1 1
a1 1
# $MirBSD: src/distrib/miniroot/install.sub,v 1.47 2004/11/02 21:21:46 tg Exp $
d1758 1
a1758 1
for _set in base etc gnu gcc xetc xfree pkgutl source ports site; do
d1761 1
a1761 1
	isin $_set xetc xfree source ports site && continue
@


1.47
log
@a bunch of fixes:
* tn3270 is too old and uses... scary Makefile techniques
* some compile fixes
* more acronymes
* german acronymes
* tai2timet and vice versa as macro
* sync lists after partial make build
@
text
@d1 1
a1 1
# $MirBSD: src/distrib/miniroot/install.sub,v 1.46 2004/10/25 20:12:20 tg Exp $
d1758 1
a1758 1
for _set in base etc xetc xfree source ports site; do
@


1.46
log
@*ARGH* we're already at #8
why isn't this generated compile-time?
@
text
@d1 1
a1 1
# $MirBSD: src/distrib/miniroot/install.sub,v 1.45 2004/09/26 11:24:03 tg Exp $
d1709 3
a1711 3
architecture, maybe which country,a dmesg and a few words about how
you like MirOS. If you don't mind being counted for a userbase esti-
mate, drop an email to <miros-dev@@66h.42h.de> - thanks in advance!
@


1.45
log
@kludge install script into throwing default route into installed base,
and TRY to get it on upgrades
untested
@
text
@d1 1
a1 1
# $MirBSD: src/distrib/miniroot/install.sub,v 1.44 2004/08/15 16:20:13 tg Stab $
d1730 1
a1730 1
VERSION=7
@


1.44
log
@more cleanup
@
text
@d1 1
a1 1
# $MirBSD: src/distrib/miniroot/install.sub,v 1.43 2004/08/15 16:19:17 tg Exp $
d641 5
a645 1
		route -n add -inet -host default "$resp" && break
a648 1
	echo "Attention: the default route is _not_ preserved after install."
d689 2
a690 3
		if ! isalphanumeric "$if"; then
			continue
		fi
d780 6
@


1.43
log
@* set name changes
* xetc is a no-upgrade set, too
* misc. cleanup
@
text
@d1 1
a1 1
# $MirBSD: src/distrib/miniroot/install.sub,v 1.42 2004/06/11 15:57:25 tg Exp $
d6 1
a6 1
#	Thorsten Glaser <x86@@ePost.de> for the MirOS Project
d101 1
a101 1
This program will help you $MODE MirBSD. At any prompt except password prompts
@


1.42
log
@unbreak make release - the only thing that's broken is
IPv4 default routes which are not entered via hostname.if(5)
@
text
@d1 1
a1 1
# $MirBSD: src/distrib/miniroot/install.sub,v 1.41 2004/05/21 21:10:47 tg Exp $
d124 1
a124 5
to files in the 'etc' set into the files already on your system.

IMPORTANT NOTE: the 'xbase', 'xserv' and 'xshare' upgrade sets contain files
that live within /etc/ and will overwrite them if the sets are installed.
Consider backing up /etc/X11 before upgrading.
d1750 2
a1751 3
for _set in base etc man perl comp egcs misc game \
    xbase xfont xserv source ports site; do
	[[ $MODE == upgrade && $_set == etc ]] && continue
d1753 1
a1753 1
	isin $_set xbase xfont xserv source ports site && continue
d1762 2
@


1.41
log
@not-so-easy merge
note: the release process is currently marked as broken, because
the install.sub file needs some major fixes.
they are so major I'll eventually rewrite the stuff now. let's see.
@
text
@d1 1
a1 1
# $MirBSD: src/distrib/miniroot/install.sub,v 1.40 2004/05/02 20:07:24 tg Exp $
d645 1
a645 1
		route -n add -inet -host default "$resp" && { echo "$resp" >/tmp/mygate ; break ; }
d649 1
@


1.40
log
@friendly note about feedback to the developers
idea from Christian Louis
@
text
@d1 3
a3 3
#	$MirBSD: src/distrib/miniroot/install.sub,v 1.39 2004/03/09 21:10:38 tg Exp $
#	$OpenBSD: install.sub,v 1.325 2004/01/11 18:57:02 krw Exp $
#	$NetBSD: install.sub,v 1.5.2.8 1996/09/02 23:25:02 pk Exp $
a4 1
# Copyright (c) 1997-2003 Todd Miller, Theo de Raadt, Ken Westerback
d7 1
d255 1
a255 1
	done		
d494 2
a495 2
configure_all_interfaces() {
	local _IFDEVS=$IFDEVS _ifs
d498 2
a499 4
		_IFDEVS=$(rmel "$_ifs" $_IFDEVS)

		ask_which "interface" "do you wish to initialize" "$_IFDEVS" "" \
		    "No more interfaces to initialize"
d503 32
a534 1
		configure_ifs $_ifs || _ifs=
d538 1
a538 2
# Obtain and output the inet information related to the given
# interface. Should output '<up/down> <addr> <netmask> <broadcast>'.
d541 1
a541 1
inet_info() {
d543 2
a544 5
		1s/.*<UP,.*$/UP/p
		1s/.*<.*>*$/DOWN/p
		/media:/s/^.*$//
		/status:/s/^.*$//
		/inet/s/--> [0-9.][0-9.]*//
d546 1
a546 2
		/inet/s/broadcast//
		/inet/s/inet// p'
d581 1
a581 1
	set -- $(inet_info $_ifs)
d598 2
a599 2
configure_ifs() {
	local _ifs=$1 _addr _mask _name _prompt _media _config
d601 4
a604 37
	set -- $(inet_info $_ifs)
	[[ $1 == UP ]] && ifconfig $_ifs delete down
	[[ -n $2 && $2 != "0.0.0.0" ]] && { _addr=$2; _mask=$3; }

	# Get symbolic name - will be used in DHCP requests.
	ask "Symbolic (host) name for $_ifs?" "$(hostname -s)"
	_name=$resp

	# Get and apply media options.
	_media=$(ifconfig -m $_ifs | grep "media ")
	if [[ -n $_media ]]; then
		cat <<__EOT
The default media for $_ifs is
$(ifconfig -m $_ifs | sed -n '/supported/D;/media:/p')
__EOT
		ask_yn "Do you want to change the default media?"
		case $resp in
		y)	cat <<__EOT
Supported media options for $_ifs are:
$_media
__EOT
			ask "Media options for $_ifs?"
			_media=$resp
			ifconfig $_ifs $_media down || return 1
			;;
		n)	_media=
			;;
		esac
	fi

	# Enable IPv6, if possible
	resp=n
	[[ -x /usr/sbin/sysctl && -x /sbin/rtsol ]] && \
	    ask_yn "Do you want to enable stateless IPv6 autoconfiguration?"
	if [[ $resp == y ]]; then
		/usr/sbin/sysctl -w net.inet6.ip6.accept_rtadv=1
		/sbin/rtsol $_ifs
d607 2
a608 3
	# Get address and mask.
	_prompt="IP address for ${_ifs}?"
	[[ -x /sbin/dhclient ]] && _prompt="$_prompt (or 'dhcp')"
d612 1
d614 4
a617 2
			echo "DHCP not supported - no /sbin/dhclient found."
			return 1
a618 4
		dhcp_request $_ifs "$_name" || dhcp_request $_ifs || return 1
		_config="dhcp NONE NONE"
		# Fake address for the hosts file.
		_addr=127.0.0.1
d622 4
a625 3
		_mask=$resp
		ifconfig $_ifs inet $_addr netmask $_mask $_media up || return 1
		_config="inet $_addr $_mask"
d628 10
a638 7
	# Save configuration information.
	echo "$_config NONE $_media" >/tmp/hostname.$_ifs
	addhostent $_addr $_name

	# Check for default route
	_dr=$(route -n show | sed -ne '/^default */{s///; s/ .*//; p;}')
	[ -f /tmp/dhclient.conf ] && _dr=dhcp
d640 1
a640 1
		ask_until "Configure a default route on this interface? (IP address, 'dhcp' or 'no')" "$_dr"
d642 1
a642 1
		  no|dhcp)	echo -n >/tmp/mygate; break ;;
d644 4
a647 4
		route -n delete -inet default >/dev/null 2>&1
		route -n add -inet -host default "$resp" && \
		    { echo "$_ifs $resp" >/tmp/mygate; break; }
		route -n add -inet -host default "$_dr" >/dev/null 2>&1
d649 1
a649 2
	return 0
 }
d653 1
a653 2
	local _n
	_n=$1
d677 3
a679 6
	# set the address for the loopback interface
	ifconfig lo0 inet localhost

	# use loopback, not the wire
	route -n add -host $(hostname) localhost >/dev/null
	route -n add -net 127 127.0.0.1 -reject >/dev/null
d763 1
a763 1
					[ "$alias" ] && rtcmd="; route -n add -host $name 127.0.0.1"
d778 4
d851 1
a851 1
# section 3.1, and now supported by our in-tree ftp:
d853 2
a854 3
#    ':' -> '%3a'
#    '@@' -> '%40'
#    '/' -> '%2f'
d856 4
a859 2
# *NOTE* quotes around $1 are required to preserve trailing or
# embeddded blanks in usercodes and passwords!
d861 35
a895 1
	echo "$1" | sed -e 's/:/%3a/g' -e 's/@@/%40/g' -e 's/\//%2f/g'
d917 1
a917 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _home _passwd
a1015 1
		[[ $_ftp_server_dir == /* || $_ftp_server_dir == ~* ]] || _home="~/"
d1018 1
a1018 1
	eval _url_base=$_url_base\$_${_url_type}_server_ip/$_home\$_${_url_type}_server_dir
d1414 2
a1415 4
		cat <<__EOT

*** /bsd is not present in the installed system, or is 0 bytes long. MirBSD
    cannot boot without a valid kernel! 'bsd' must be (re)installed.
d1420 1
a1420 1
	if [[ ! -x /mnt/bin/cat || ! -x /mnt/dev/MAKEDEV ]]; then
d1423 2
a1424 5
		cat <<__EOT

*** One or both of the executable files /bin/cat and /dev/MAKEDEV are not
    present in the installed system. This indicates that executable files
    MirBSD requires are missing. 'base${VERSION}' must be (re)installed.
d1429 1
a1429 1
	if [[ ! -d /mnt/etc || ! -d /mnt/usr/share/zoneinfo/right || ! -d /mnt/dev ]]; then
d1432 2
a1433 5
		cat <<__EOT

*** One or more of the directories /etc, /usr/share/zoneinfo and /dev are not
    present in the installed system. This indicates that directories MirBSD
    requires are missing. 'etc${VERSION}' must be (re)installed.
d1592 1
a1592 1
	local _dn _ns _dr
d1598 1
a1598 1
	configure_all_interfaces
d1628 1
a1628 1
		ask_yn "Use the nameserver now?" y
d1632 3
a1662 2

	set_timezone
@


1.39
log
@* nuke obsolete files and parts of files
* enable pascal frontend
* enable CPIO naming convention:
  sv4cpio = .cpio
  sv4crc  = .cpio
  sv4cpio gzipped = .ngz (newc/gz)
  svrcrc  gzipped = .cgz (crc/gz)
* all packages are .cgz, all sets are .ngz
* add hooks for gjc frontend
* add stubbed out gpc and gjc rts hooks in src/gnu/gcc/Makefile
* enable java frontend (with almost no changes; this is what I
  call a _really_ nice langspec-subdir... amazing)
* bump patchlevel for these changes
* better document some changes
* matthieu@@openbsd.org assured me we need no X piclibs any more
* improve comments
* export whole libz to XFree86 .a modules
* correct usage of languages when bootstrapping gcc
* fix MKC_PGCC when USE_GCC3=no (since USE_GCC3 is a post-#7
  thing, and ports/lang/egcs is not available for -current)
* install man- and texinfopages for gpc

most of this stuff is tested. however, I *strongly* recommend
to not update, but rather wait for the next snapshot.

Now missing:
* pascal RTS
* a port for libgjc (I won't like it in base, due to the
  _heavy_ overhead (jar, ffi, boehm-gc*cough*, ...), but
  since the compiler is there, it should be easy)
* test pascal (c, cp, f, objc, and ada are fine already)
* test gcov? (proto is fine, all right)
* documentation improvements
* quality tests and improvements
* more ~/.etc
* get the damn cvs conflict script right ;)

Next projects:
* update binutils
* sync with openbsd
* rewrite large parts of build system
* write boot loader
* rewrite install system
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.38 2004/03/01 16:33:37 tg Exp $
d1682 6
@


1.38
log
@support installing ports7.tgz and source7.tgz as sets
proposal from Ed White <ed.white@@libero.it> as RFC#18 to tech@@openbsd

these sets won't be automagically generated though.
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.37 2004/01/31 02:17:31 tg Exp $
d845 1
a845 1
		*.tgz)	ftp $_ftp_active -o - -V -m "$_src/$_f" | tar zxphf - -C /mnt
d1398 1
a1398 1
		DEFAULTSETS=$(addel base${VERSION}.tgz $DEFAULTSETS)
d1410 1
a1410 1
		DEFAULTSETS=$(addel etc${VERSION}.tgz $DEFAULTSETS)
d1724 1
a1724 1
# Ensure that siteXX.tgz is the *last* set listed so its contents overwrite
d1729 1
a1729 1
    xbase xfont xserv site source ports; do
d1731 3
a1733 3
	THESETS="$THESETS ${_set}${VERSION}.tgz"
	isin $_set xbase xfont xserv site source ports && continue
	DEFAULTSETS="$DEFAULTSETS ${_set}${VERSION}.tgz"
@


1.37
log
@* this time, make b-r for real
* including X-Window
* merge evilwm import
* install all .cf etc. files, especially the MirBSD.cf one
* cope in X for MirOS changes
* refine anoncvssh: all defines in Makefile, etc.
* cope for XFree86 1.1 licence
* merge nlist.c import
* nuke unused files
* remove warnings
* fix really bogus bug in rcdb again
* offer bsd.slim for installation
* fix the default route bug
* sync distrib stuff
(...)

thanks for alpha-testing to
 * Jannis "Kabelaffe" Konrad
 * Jos Antnio "T0ni" "jesus_" Matias de Jesus
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.36 2004/01/28 15:14:06 tg Exp $
d1728 2
a1729 1
for _set in base etc man perl comp egcs misc game xbase xfont xserv site; do
d1732 1
a1732 1
	isin $_set xbase xshare xfont xserv site && continue
@


1.36
log
@second round
 - more merges
 - (hopefully) fix routing issue
 - also ask for a per-interface default route,
   not for a global one
 - use ELF sections for cdefs.h
   (XXX miros is now a.out incompatible. maybe even since longer.)
 - seed random on upgrade scenario
 - regenerate files
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.35 2004/01/27 17:41:32 tg Exp $
a1612 18

	# Get/Confirm the default route.
	_dr=$(route -n show | sed -ne '/^default */{s///; s/ .*//; p;}')
	[[ -f /tmp/dhclient.conf ]] && _dr=dhcp
	while : ; do
		ask_until "Default route? (IP address, 'dhcp' or 'none')" "$_dr"
		case $resp in
		none|dhcp) break ;;
		esac
		route -n delete default >/dev/null 2>&1
		route -n add -host default "$resp" && \
		    { echo

		route delete default >/dev/null 2>&1
		route -n add -host default "$resp"
		# Put the old default route back. The new one did not work.
		[ $? -ne 0 ] && route -n add -host default $_dr >/dev/null 2>&2
	done
@


1.35
log
@first part of mergeing OpenBSD and fixing whitespace and RCS IDs
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.34 2004/01/23 22:31:41 tg Exp $
d642 14
d725 4
a728 4
			"!route")
				# user defined route command
				route "$name" "$mask" "$bcaddr" "$ext1" "$ext2"
				continue
d1622 4
@


1.34
log
@* xshare gets merged into xbase
* shuffle install order around
* move tinyirc back to base (even if it's GPLd),
  so I have no stomach aches installing miscOSREV.tgz late

ok'd cnuke@@
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.33 2004/01/23 22:16:59 tg Exp $
#	$OpenBSD: install.sub,v 1.324 2003/12/21 21:45:41 krw Exp $
d555 1
a555 2
	kill_dhclient
	dhclient -1 $_ifs
a724 1
				kill_dhclient
a1514 8
}

# Try to kill a running dhclient.
kill_dhclient() {
	if [[ -f /var/run/dhclient.pid ]]; then
		kill -HUP $(sed -ne "1p" /var/run/dhclient.pid) >/dev/null 2>&1
		rm -f /var/run/dhclient.pid
	fi
@


1.33
log
@apparently, we got egcsOSREV.tgz and perlOSREV.tgz
 - let them install
 - add stub with descriptions
 - adjust compressed set sizes temporarily
   (why is there that much difference? checkflist didn't change...)
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.32 2004/01/04 19:08:45 tg Exp $
d1738 1
a1738 1
for _set in base etc perl misc comp egcs man game xbase xshare xfont xserv site; do
@


1.32
log
@add sysctl and ask for IPv6 autoconfiguration
to be tested by wbx@@
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.31 2004/01/04 03:18:20 tg Exp $
d233 1
a233 1
	while [[ -z $resp ]] ; do
d252 2
a253 2
		y|yes)	resp=y ; return ;;
		n|no)	resp=n ; return ;;
d339 2
a340 2
		if [[ $_a != $_b ]] ; then
			if [[ $_a >$_b ]] ; then
d384 1
a384 1
	[[ $resp == y ]] && { echo "Type 'exit' to return to $MODE." ; sh ; }
d409 1
a409 1
	if isin $_dev $IFDEVS || [[ -c $_node ]] ; then
d413 1
a413 1
	if [[ ! -r /dev/MAKEDEV ]] ; then
d829 1
a829 1
	for _f in $THESETS ; do
d923 1
a923 1
			[[ $# -lt 1 ]] && { echo "There is no line $resp." ; continue ; }
d966 1
a966 1
			while [[ -z $resp ]] ; do
d983 1
a983 1
	if [[ $_url_type == ftp && -z $ftp_proxy ]] ; then
d1008 1
a1008 1
			[[ -d $_mp/$resp ]] && { _dir=$_mp/$resp ; break ; }
d1010 1
a1010 1
			[[ -d /$resp ]] && { _dir=/$resp ; break ; }
d1053 1
a1053 1
		while [ -z "$resp" ] ; do
d1075 1
a1075 1
		while [ -z "$resp" ] ; do
d1092 1
a1092 1
	if ! mount -t ${_fstype} -o ro /dev/${_drive}${_part} /mnt2 ; then
d1225 1
a1225 1
	if ! mount_nfs $_nfs_tcp -o ro ${_nfs_server_ip}:${_nfs_server_path} /mnt2 ; then
d1254 1
a1254 1
	if ! mt rewind ; then
d1277 1
a1277 1
		if ! mt fsf $_nskip ; then
d1504 1
a1504 1
		if ! mount -v -t $_fstype $_async -o $_opt $_dev $_mp ; then
d1506 1
a1506 1
			if ! mount -v -t $_fstype -o $_opt $_dev $_mp ; then
d1738 1
a1738 1
for _set in base etc misc comp man game xbase xshare xfont xserv site ; do
d1746 1
a1746 1
if [ -z "$EDITOR" ] ; then
@


1.31
log
@fix IPv6 and version number
XXX no rtsold here, but apparently there's a soluting coming from obsd
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.30 2003/12/23 13:41:59 tg Exp $
d6 2
d606 9
@


1.30
log
@* merge in OpenBSD
* rename cd34.iso to cdrom8.iso

XXX gzip/compress on ramdisk in MirOS should still
XXX	be able to compress and not only decompress
XXX	files. must be revisited
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.29 2003/11/28 22:37:50 tg Exp $
d1699 1
a1699 1
VERSION=34
@


1.29
log
@remove /etc/mygate altogether; it's prone to errors.
users on
.Mx
are to use
.Xr hostname.if 5
instead, for example:

# cat >>/etc/hostname.vr0 <<EOF
!route -n add -inet default 192.168.0.1 -mtu 1454
EOF

for an ADSL home router.
--
Idea from Angelo Laub.
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.28 2003/11/20 12:36:05 tg Exp $
#	$OpenBSD: install.sub,v 1.321 2003/09/22 01:31:39 krw Exp $
d201 1
a201 1
ask () {
d229 1
a229 1
ask_until () {
d242 1
a242 1
ask_yn () {
d266 1
a266 1
ask_which () {
d356 1
a356 1
save_comments () {
d370 1
a370 1
edit_tmp_file () {
d379 1
a379 1
manual_net_cfg () {
d511 1
a511 1
inet_info () {
d528 1
a528 1
dhcp_request () {
d783 1
a783 1
install_files () {
d853 1
a853 1
ftp_error () {
d1509 1
a1509 1
kill_dhclient () {
d1595 1
a1595 1
		ask_yn "Use the nameserver now?"
d1623 7
a1629 1
set_machdep_apertureallowed() {
d1635 1
a1635 1
			/mnt/etc/sysctl.conf >/tmp/sysctl.conf
@


1.28
log
@have procfs with -o linux being automatically
mounted on /proc and kernfs (BSD) resp. sysfs (Linux)
on /kern after an installation.

remove space after I/O redirectors while here
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.27 2003/10/02 23:43:55 tg Exp $
d701 5
a766 7
	# /mnt/etc/mygate, if it exists, contains the name of my gateway host
	# that name must be in /etc/hosts.
	if [ -f /mnt/etc/mygate ]; then
		route delete default >/dev/null 2>&1
		route -n add -host default $(cat /mnt/etc/mygate)
	fi

d1608 1
a1608 1
		route -n add -host default "$resp" && { echo "$resp" >/tmp/mygate ; break ; }
d1610 1
a1610 1
		route -n add -host default $_dr >/dev/null 2>&2
@


1.27
log
@regression (again): sets could not be added
no such disaster as with MirBSD #6 again, please.

ksh hates me, just like cvs does
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.26 2003/10/01 18:51:28 tg Exp $
d95 1
a95 1
	cat << __EOT
d111 1
a111 1
	cat << __EOT
d120 1
a120 1
		cat << __EOT
d133 1
a133 1
		cat << __EOT
d140 1
a140 1
			cat << __EOT
d154 1
a154 1
		cat << __EOT
d338 1
a338 1
			if [[ $_a > $_b ]] ; then
d360 2
a361 2
		grep "^#" /mnt/etc/$_file > /tmp/$_file.new
		[[ -f /tmp/$_file ]] && cat /tmp/$_file >> /tmp/$_file.new
d388 1
a388 1
	ftp ${_ftp_active} -V -n "$1" << __EOT
d430 1
a430 1
	sed "/ $2\$/d" /tmp/hosts > /tmp/hosts.new
d433 1
a433 1
	echo "$1 $2" >> /tmp/hosts
d447 1
a447 1
		cat << __EOT
d531 1
a531 1
	echo "initial-interval 1;" > /etc/dhclient.conf
d534 1
a534 1
		echo "send host-name \"$_hostname\";" >> /etc/dhclient.conf
d540 1
a540 1
	cat >> /etc/dhclient.conf << __EOT
d549 1
a549 1
	cat >> /etc/resolv.conf.tail << __EOT
d587 1
a587 1
		cat << __EOT
d593 1
a593 1
		y)	cat << __EOT
d630 1
a630 1
	echo "$_config NONE $_media" > /tmp/hostname.$_ifs
d666 2
a667 2
	route -n add -host $(hostname) localhost > /dev/null
	route -n add -net 127 127.0.0.1 -reject > /dev/null
d680 1
a680 1
		ifconfig $if > /dev/null 2>&1
d759 1
a759 1
		done < /mnt/etc/hostname.$if
d765 1
a765 1
		route delete default > /dev/null 2>&1
d802 1
a802 1
		cat << __EOT
d1058 1
a1058 1
		cat << __EOT
d1089 1
a1089 1
	umount -f /mnt2 > /dev/null 2>&1
d1105 1
a1105 1
	cat << __EOT
d1145 1
a1145 1
	cat << __EOT
d1189 1
a1189 1
		umount -f /mnt2 > /dev/null 2>&1
d1222 1
a1222 1
	umount -f /mnt2 > /dev/null 2>&1
d1229 1
a1229 1
	cat << __EOT
d1275 1
a1275 1
cat << __EOT
d1367 1
a1367 1
		cat << __EOT
d1378 1
a1378 1
		cat << __EOT
d1390 1
a1390 1
		cat << __EOT
d1407 1
a1407 1
	cat << __EOT
d1416 1
a1416 1
		cat << __EOT
d1443 2
a1444 1
#	4) are nfs (since name resolution may not be present).
d1461 1
d1475 1
a1475 1
	done < /tmp/fstab > /etc/fstab
d1499 1
a1499 1
			cat << __EOT
d1507 1
a1507 1
	done < /etc/fstab
d1513 1
a1513 1
		kill -HUP $(sed -ne "1p" /var/run/dhclient.pid) > /dev/null 2>&1
d1535 1
a1535 1
		if ! fsck -fp ${_dev} > /dev/null 2>&1; then
d1541 1
a1541 1
	done < /etc/fstab
d1593 1
a1593 1
		echo "lookup file bind" > /tmp/resolv.conf
d1595 1
a1595 1
			echo "nameserver $_ns" >> /tmp/resolv.conf
d1609 2
a1610 2
		route delete default > /dev/null 2>&1
		route -n add -host default "$resp" && { echo "$resp" > /tmp/mygate ; break ; }
d1612 1
a1612 1
		route -n add -host default $_dr > /dev/null 2>&2
d1631 1
a1631 1
			/mnt/etc/sysctl.conf > /tmp/sysctl.conf
d1672 1
a1672 1
	cat << __EOT
d1708 1
a1708 1
dmesg | sed -ne '/^MirBSD /h;/^MirBSD /!H;${g;p;}' > /var/run/dmesg.boot
d1746 1
a1746 1
	cat << __EOT
@


1.27.4.1
log
@MFC: allow ports34.tgz to be installed
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.27 2003/10/02 23:43:55 tg Exp $
d1721 1
a1721 1
for _set in base etc misc comp man game ports xbase xshare xfont xserv site ; do
@


1.26
log
@fix a "buglet" that has been buggin me since LinuxTag 2003.

| from \`foo\` don't make \$(foo\) but \$\(foo\)

can please PLEASE somebody confirm this (and that this works)?
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.25 2003/09/25 20:59:40 tg Exp $
d484 1
a484 1
			@@($resp)) _selected=\$\($_action $_f \$_selected\) ;;
@


1.25
log
@Merge OpenBSD-current
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.24 2003/09/03 23:55:09 tg Exp $
d484 1
a484 1
			@@($resp)) _selected=\`$_action $_f \$_selected\` ;;
@


1.24
log
@upgrade trap: x*34.tgz contain files that match ^\./etc.*$
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.23 2003/08/31 20:54:08 tg Exp $
#	$OpenBSD: install.sub,v 1.320 2003/08/23 22:22:02 krw Exp $
d70 1
a70 1
#	md_prep_disklabel()	  - label the root disk
d84 1
a84 1
	[ "$TERM" ] && return
d93 2
d129 1
a129 1
		ask "Proceed with upgrade?" n
d145 1
a145 1
			ask "Skip disk initialization?" n
d147 1
a147 1
			ask "Proceed with install?" n
d152 3
a154 4
	case $resp in
	y*|Y*)	echo "Cool! Let's get to it..."
		;;
	*)	cat << __EOT
d160 3
a162 2
		;;
	esac
d201 1
a201 1
ask() {
d236 20
d373 2
a374 5
	ask "Edit $_file with ${EDITOR}?" n
	case $resp in
	y*|Y*)	${EDITOR} /tmp/$_file
		;;
	esac
d380 1
a380 1
	ask "Do you want to do any manual network configuration?" n
d382 1
a382 5
	case $resp in
	y*|Y*)	echo "Type 'exit' to return to ${MODE}."
		sh
		;;
	esac
d591 1
a591 1
		ask "Do you want to change the default media?" n
d593 1
a593 1
		y*|Y*)	cat << __EOT
d601 1
a601 1
		*)	_media=
d817 2
a818 4
	ask "Ready to $MODE sets?" y
	case $resp in
	n*|N*)	return ;;
	esac
d879 2
a880 2
	# ask "Display the list of known $_url_type servers?" "${_get_server_list:-y}"
	# case $resp in
d882 16
a897 20
	# n*|N*)	_get_server_list=n
	#	;;
	# *)
	#	_get_server_list=y
	#	# ftp.openbsd.org == 129.128.5.191 and will remain at
	#	# that address for the forseeable future.
	#	echo -n "Getting the list from 129.128.5.191 (ftp.openbsd.org)..."
	#	ftp $_ftp_active -V -a -o - \
	#		ftp://129.128.5.191/$FTPDIR/ftplist 2>/tmp/ftplisterr \
	#		| sed -ne "/^${_url_type}:\/\//s///p" >$SERVERLIST
	#	if [[ -s $SERVERLIST ]]; then
	#		echo "done."
	#		_prompt="Server? (IP address, hostname, list#, 'done' or '?')"
	#		cat -n $SERVERLIST | less -XE
	#	else
	#		echo "FAILED."
	#		cat /tmp/ftplisterr
	#	fi
	#	;;
	# esac
d931 2
a932 2
		-A)	resp=n ;;
		*)	resp=y ;;
d935 3
a937 5
		ask "Does the server support passive mode ftp?" "$resp"
		case $resp in
		n*|N*)	_ftp_active=-A ;;
		*)	unset _ftp_active ;;
		esac
d1211 3
a1213 7
	ask "Use TCP transport? (only works with capable NFS server)" y
	case $resp in
	n*|N*)	_nfs_tcp=
		;;
	*)	_nfs_tcp=-T
		;;
	esac
d1595 2
a1596 5
		ask "Use the nameserver now?" y
		case $resp in
		y*|Y*)	cp /tmp/resolv.conf /tmp/resolv.conf.shadow
			;;
		esac
d1624 1
a1624 1
	[ "$MDXAPERTURE" ] || return
d1626 2
a1627 3
	ask "Do you expect to run the X Window System?" y
	case $resp in
	y*|Y*)
d1630 1
a1630 2
		;;
	esac
@


1.23
log
@Merge import of OpenBSD source, ports and XF4 tree.

While here,
o clean up differences where possible
o whitespace cleanup
o ifdef ./. if defined()
o '...' ./. "..."
o echo foo > bar ./. echo foo >bar
o `...` ./. $(...) ./. $$(...)
o `...' ./. '...'
o modernize "our" tree, e.g. WWW in ports
o fix some typos and brainos introduced when renaming OpenBSD to MirBSD
o use hardware 80387 by default
o migrate Apache 1.3.28 OpenBSD ./. MirBSD ./. KAME
o work around as many CVS bugs as possible (add back/delete files, ...)

Synchronize stuff, ready for ongoing changes.
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.22 2003/08/17 18:55:48 tg Exp $
d122 4
d1699 1
a1699 1
OBSD="OpenBSD-mirabile/$ARCH $VNAME"
@


1.22
log
@merge OpenBSD, remove a few 0x60
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.21 2003/08/16 15:19:52 tg Exp $
#	$OpenBSD: install.sub,v 1.317 2003/08/16 20:37:24 krw Exp $
d236 2
a237 1
# $4 = default device. If it is not specified, use the first device in $3.
d241 1
a241 1
	local _name=$1 _query=$2 _devs=$3 _defdev=$4
d245 1
a245 1
		echo "Done - no available ${_name}s found."
d258 1
a258 1
		ask "Available ${_name}s are: ${_devs}.\nWhich one $_query (or 'done')" "$_defdev"
a405 28
get_rootdisk() {
	local _defdsk

	if [[ $MODE == install && ! -f /etc/fstab ]]; then
		cat << __EOT

You will now initialize the disk(s) that MirBSD will use. To enable all
available security features you should configure the disk(s) to allow the
creation of separate filesystems for /, /tmp, /var, /usr, and /home.

__EOT
fi

	ROOTDISK=
	ROOTDEV=
	SWAPDEV=

	set -- $DKDEVS
	[[ $# -gt 1 ]] && _defdsk=done

	ask_which "disk" "is the root disk?" "$DKDEVS" "$_defdsk"
	[[ $resp == done ]] && exit

	ROOTDISK=$resp
	ROOTDEV=${ROOTDISK}a
	SWAPDEV=${ROOTDISK}b
}

d479 2
a480 1
		ask_which "interface" "do you wish to initialize?" "$_IFDEVS"
d850 1
a850 1
#	_ftp_server_password, and _ftp_active must be global.
d852 1
a852 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _home
d943 1
a943 1
		_ftp_server_password=root@@$(hostname)
d949 1
a949 1
			_ftp_server_password=$resp
d958 1
a958 1
		_url_base=$_url_base$(encode_for_url "$_ftp_server_login"):$(encode_for_url "$_ftp_server_password")@@
d964 1
a964 1
		_file_list=$(ftp_list_files "$_ftp_server_ip" "$_ftp_server_login" "$_ftp_server_password" "$_ftp_server_dir")
d1003 1
a1003 1
	ask_which "CD-ROM" "contains the ${MODE} media?" "$CDDEVS"
d1088 1
a1088 1
	ask_which "disk" "contains the ${MODE} sets?" "$DKDEVS"
d1597 1
d1704 1
a1704 1
dmesg | sed -ne '/^OpenBSD /h;/^OpenBSD /!H;${g;p;}' > /var/run/dmesg.boot
d1740 20
a1759 2
# Get ROOTDISK and default ROOTDEV
get_rootdisk
@


1.21
log
@Merge OpenBSD
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.20 2003/07/20 11:49:55 tg Exp $
#	$OpenBSD: install.sub,v 1.315 2003/08/07 19:13:00 deraadt Exp $
d1560 1
a1560 1
	echo "...Done."
d1716 1
a1716 1
VERSION=33
@


1.20
log
@place TAB or SPACE after HASHMARK -> comment gets stripped
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.19 2003/07/20 11:35:43 tg Exp $
#	$OpenBSD: install.sub,v 1.314 2003/07/10 15:03:19 krw Exp $
d241 1
a241 1
	
d932 1
a932 1
 			;;
@


1.19
log
@fix da annoying bug, caused by a 0x60 translation...
someone know how to fix _that_?
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.18 2003/07/18 15:44:11 tg Exp $
d888 2
a889 2
	#ask "Display the list of known $_url_type servers?" "${_get_server_list:-y}"
	#case $resp in
d891 1
a891 1
	#n*|N*)	_get_server_list=n
d893 1
a893 1
	#*)
d910 1
a910 1
	#esac
@


1.18
log
@mop up; yet retain libcom_err
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.17 2003/07/06 20:20:59 tg Exp $
d492 1
a492 1
			@@($resp)) _selected=\$($_action $_f \$_selected\) ;;
@


1.17
log
@mop up
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.16 2003/07/05 17:09:20 tg Exp $
#	$OpenBSD: install.sub,v 1.312 2003/07/03 15:19:01 krw Exp $
d878 1
a878 1
	local _url_type=$1 _file_list _url_base _oifs _prompt
d983 1
d986 1
a986 1
	eval _url_base=$_url_base\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
d1722 5
@


1.16
log
@Bump to MirBSD #6 (minor 01=n)
remove dangling $FTPDIR
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.15 2003/07/03 08:26:53 tg Exp $
#	$OpenBSD: install.sub,v 1.310 2003/07/02 16:42:19 krw Exp $
d243 1
a243 1
	if [[ $# < 1 ]]; then
a286 4
	for _b; do
		echo -n "$_b "
		[ "$_a" = "$_b" ] && _seen=true
	done
d288 2
a289 1
	$_seen || echo -n "$_a"
d306 1
a306 4
	case $# in
	0) return;;
	1) echo $1; return;;
	esac
d310 2
a311 2
		if [[ "$_a" != "$_b" ]] ; then
			if [[ "$_a" > "$_b" ]] ; then
d319 2
a320 1
	echo -n $_a
d322 2
a323 8
	# Prevent a trailing blank on the output, and thus a bad value
	# for cutword, by outputting blanks only when $_l
	# has values to sort.

	if [[ -n "$_l" ]] ; then
		echo -n " "
		bsort $_l
	fi
d423 1
a423 1
	[[ $# > 1 ]] && _defdsk=done
d646 1
a646 1
	while [ ${#_n} != 0 ]; do
d927 1
a927 1
			[[ $# < 1 ]] && { echo "There is no line $resp." ; continue ; }
@


1.15
log
@Merge OpenBSD, gives us better mmap2, etc.pp
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.14 2003/06/30 18:26:05 tg Exp $
d968 1
a968 1
	ask_until "Server directory?" "${resp:-mbsd6}"
a1729 1
FTPDIR="mbsd4"
@


1.14
log
@wording
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.13 2003/06/30 18:22:10 tg Exp $
#	$OpenBSD: install.sub,v 1.309 2003/06/30 17:49:14 krw Exp $
d168 3
a170 1
	ifconfig -a | egrep -v '^([[:space:]]|(lo|enc|gre|ppp|sl|tun|bridge|pflog|vlan|gif)[[:digit:]])' | cutword -t: 1
a305 18
# read lines on stdin, return Nth element of each line, like cut(1)
cutword () {
	local _a _n _oifs=$IFS

	# optional field separator
	case $1 in
	-t?*) IFS=${1#-t}; shift;;
	esac

	_n=$1
	while read _a; do
		set -- $_a
		[ "$1" ] || break
		eval echo \$$_n
	done
	IFS=$_oifs
}

d889 1
a889 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _line
d937 5
a941 6
			_line=$(sed -ne "${resp}p" $SERVERLIST)
			[[ -n $_line ]] || { echo "There is no line $resp." ; continue ; }
			echo "Using	$_line"
			_line=$(echo $_line | cutword -t' ' 1)
			eval _${_url_type}_server_ip=${_line%%/*}
			eval _${_url_type}_server_dir=${_line#*/}/$SETDIR
@


1.13
log
@merge fixes by krw
remove 0x60 uncharacter
some more MirBSD
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.12 2003/06/29 19:45:43 tg Exp $
d97 4
a100 4
This program will help you $MODE MirBSD in a simple and rational way. At
any prompt except password prompts you can run a shell command by typing
'!foo', or escape to a shell by typing '!'. Default answers are shown in []'s
and are selected by pressing RETURN. At any time you can exit this program by
d152 1
a152 1
You can then power cycle the machine and boot BSD or your original OS.
@


1.12
log
@merge the import
amd (automount dmon) bites the dust
rewrite fake-NLS emulation, copyright to me
foobar! fnord!
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.11 2003/06/06 20:26:05 tg Exp $
#	$OpenBSD: install.sub,v 1.307 2003/06/27 22:40:40 krw Exp $
d160 1
a160 1
	bsort `sed -ne "${MDDISKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}" -e '/^raid[0-9][0-9]* /s/ .*//p' -e '/^ccd[0-9][0-9]* /s/ .*//p' /var/run/dmesg.boot`
d164 1
a164 1
	bsort `sed -ne "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}" /var/run/dmesg.boot`
d234 1
a234 1
# $4 = default device
d239 3
a241 10

	# If not default device is supplied, assume 'done'.
	: ${_defdev:=done}

	# A trailing space may be present if _devs list
	# was manipulated by rmel().
	_devs=${_devs% }

	resp=
	if [[ -z $_devs ]]; then
d244 1
d246 4
d251 1
a251 1
	while [ -z "$resp" ]; do
d253 2
a254 2
		# separate 'echo', to ensure entire question is
		# re-ask'ed after a '!' '!foo' shell escape.
d256 1
d260 3
a262 3
		if isin "$resp" $_devs ; then
			makedev $resp || resp=
		elif [ "$resp" != "done" ]; then
a263 1
			resp=
a321 9
# read a line of data, return last element. Equiv. of awk '{print $NF}'.
cutlast () {
	local _a

	read _a; set -- $_a
	[ $# -gt 0 ] || return
	eval echo \$\{$#\}
}

d344 1
a344 1
	# for cutlast or cutword, by outputting blanks only when $_l
d429 1
a429 1
	DEVSMADE=`addel $_dev $DEVSMADE`
d435 1
a435 4
	_defdsk=`echo $DKDEVS | cutlast`
	[ "$_defdsk" = "$DKDEVS" ] || _defdsk=

	if [ "$MODE" = "install" -a ! -f /etc/fstab ]; then
d449 3
d453 1
a453 1
	[ "$resp" = "done" ] && exit
d519 1
a519 1
			@@($resp)) _selected=\`$_action $_f \$_selected\` ;;
d531 1
a531 3
		_IFDEVS=`rmel "$_ifs" $_IFDEVS`

		ask_which "interface" "do you wish to initialize?" "$_IFDEVS" "`echo $_IFDEVS | cutword 1`"
d533 2
a534 1
		[ "$resp" = "done" ] && break
d700 1
a700 1
	route -n add -host `hostname` localhost > /dev/null
d800 1
a800 1
		route -n add -host default `cat /mnt/etc/mygate`
d985 1
a985 1
	ask_until "Server directory?" "${resp:-pub/OpenBSD/$SETDIR}"
d997 1
a997 1
		_ftp_server_password=root@@`hostname`
d1050 1
a1050 1
	install_files "file://$_dir" "`ls -l $_dir`"
d1056 2
a1057 2
	ask_which "CD-ROM" "contains the ${MODE} media?" "$CDDEVS" "`echo $CDDEVS | cutword 1`"
	[ "$resp" = "done" ] && return
d1141 2
a1142 2
	ask_which "disk" "contains the ${MODE} sets?" "$DKDEVS" "`echo $DKDEVS | cutword 1`"
	[ "$resp" = "done" ] && return 1
d1154 1
a1154 1
	_likely_partition_range=`disklabel $_drive 2>/dev/null | \
d1157 2
a1158 2
			-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
	_partition_range=`disklabel $_drive 2>/dev/null | \
d1160 3
a1162 3
			-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
	_def_partition=`echo $_likely_partition_range | \
		sed -n 's/^\[\(.\).*\]/\1/p'`
d1164 2
a1165 2
		_def_partition=`echo $_partition_range | \
			sed -n 's/^\[\(.\).*\]/\1/p'`
d1354 1
a1354 1
	[ ! -d $_zoneroot ] && return
d1356 3
a1358 3
	if [ -L /mnt/etc/localtime ]; then
		TZ=`ls -l /mnt/etc/localtime 2>/dev/null | cutlast`
		TZ=${TZ#${_zoneroot#/mnt}}
d1368 1
a1368 1
		if [ "$resp" = "?" ]; then
d1375 1
a1375 1
		while [ -d "$_zonepath" ]; do
d1377 2
a1378 2
			if [ "$resp" = "?" ]; then
				ls -F ${_zonepath}
d1380 1
a1380 1
				_zonepath=${_zonepath}/${resp}
d1384 1
a1384 1
		if [ -f "$_zonepath" ]; then
d1755 3
a1757 3
DKDEVS=`get_dkdevs`
CDDEVS=`get_cddevs`
IFDEVS=`get_ifdevs`
@


1.11
log
@fix RAID install
support NTFS and msdosfs alongside
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.10 2003/06/06 18:26:41 tg Exp $
#	$OpenBSD: install.sub,v 1.304 2003/06/02 15:46:09 deraadt Exp $
d461 1
d468 1
d492 1
a511 1

d513 2
a514 8
		""|+|-) continue
			;;
		done)	break
			;;
		-*)	_action=rmel
			;;
		*)	_action=addel
			;;
d517 1
a518 1
		[[ $resp == all ]] && resp=*
d520 8
d530 1
a530 3
			$resp)
				_selected=\`$_action $_f \$_selected\`
				;;
a532 1

a698 6
	# Check for required hosts file.
	if [ ! -f /mnt/etc/hosts ]; then
		echo "ERROR: no /mnt/etc/hosts!"
		return 1
	fi

a825 2

	return 0
d1696 1
a1696 1
	local _dev
d1699 14
@


1.10
log
@Merge OpenBSD-current
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.9 2003/05/22 14:06:11 tg Exp $
d95 1
a95 1
Welcome to the ${OBSD}-mirabile $MODE program.
d147 1
a147 1
	y*|Y*)	echo "Cool!  Let's get to it..."
d160 1
a160 1
	bsort `sed -ne "${MDDISKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}" /var/run/dmesg.boot`
d845 1
a845 1
	# installation.  So, to minimize user confusion display the sets in the
d1211 1
d1222 4
a1225 1
			_fsopts=async
d1559 2
d1569 1
a1569 1
		fi
@


1.9
log
@merge CVS import stuff
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.8 2003/05/21 17:03:14 tg Exp $
#	$OpenBSD: install.sub,v 1.303 2003/05/12 19:01:58 krw Exp $
a15 6
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#	This product includes software developed by Todd Miller and
#	Theo de Raadt
# 4. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
@


1.8
log
@bump to MirBSD #5-prerelease
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.7 2003/05/19 15:35:19 tg Exp $
#	$OpenBSD: install.sub,v 1.298 2003/05/07 00:43:06 krw Exp $
d229 1
a229 1
	while [ -z "$resp" ] ; do
d930 1
a930 1
	local _file_list _url_type=$1 _url_base _url_login _url_pass _oifs
d934 4
a937 11
	# Proxy the connections?
	: ${_proxy_host:=none}

	ask "HTTP/FTP proxy URL? (e.g. 'http://proxy:8080', or 'none')" "$_proxy_host"
	if [[ $resp == none ]]; then
		unset _proxy_host ftp_proxy http_proxy
	else
		_proxy_host=$resp
		export ftp_proxy=$_proxy_host
		export http_proxy=$_proxy_host
	fi
d939 2
a940 5
	# Provide a list of possible servers
	#XXX not for MirBSD tho
	#: ${_ftp_getlist:=y}

	#ask "Do you want to see a list of potential $_url_type servers?" "$_ftp_getlist"
d942 2
a943 2
	#n*|N*)	_ftp_getlist=n
	_ftp_getlist=n
d946 1
a946 1
	#	_ftp_getlist=y
d949 12
a960 2
	#	ftp ${_ftp_active} -V -a -o /tmp/ftplist ftp://129.128.5.191/$FTPDIR/ftplist > /dev/null
	#	grep "^${_url_type}:" /tmp/ftplist | cat -n | less -XE
a963 2
	: ${_ftp_server_dir:=mbsd5

d965 4
a968 9
	resp=
	while [[ -z $resp ]] ; do
		if [ ! -f /tmp/ftplist ]; then
			eval ask \"Server IP address, or hostname?\" \"\$_${_url_type}_server_ip\"
			continue;
		fi

		eval ask \"Server IP address, hostname, or list#?\" \"\$_${_url_type}_server_ip\"

d970 3
a972 3
		"?")
			grep "^${_url_type}:" /tmp/ftplist | cat -n | less -XE
			resp=
d975 13
a987 18
			maxlines=$(grep "^${_url_type}:" /tmp/ftplist | sed -ne )$='`

			if [ $maxlines -lt $resp -o $resp -lt 1 ]; then
				echo "There is no ${resp}th line in the list."
			else
				tline=`grep "^${_url_type}:" /tmp/ftplist | sed -ne "${resp}p"`
				echo "Using	$tline"
				url=`echo $tline | sed -e "s/^${_url_type}:\/\///" |
					cutword -t' ' 1 | cutword -t' ' 1`
				host=`echo $url | cutword -t/ 1`
				eval _${_url_type}_server_ip=$host
				eval _${_url_type}_server_dir=$(echo $url | sed -e "s/^${host}\///")/$SETDIR
			fi

			# Always do it again, just to double check
			resp=
			;;
		*)
a991 2
	eval _${_url_type}_server_ip=$resp

d1009 2
a1010 1
	eval ask_until \"Server directory?\" \"\$_${_url_type}_server_dir\"
d1034 1
d1036 1
a1036 5
		_url_login=`encode_for_url "$_ftp_server_login"`
		_url_pass=`encode_for_url "$_ftp_server_password"`
		_url_base=ftp://${_url_login}:${_url_pass}@@${_ftp_server_ip}/${_ftp_server_dir}
	else
		eval _url_base=${_url_type}://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
d1038 1
d1042 1
a1042 1
		_file_list=`ftp_list_files "$_ftp_server_ip" "$_ftp_server_login" "$_ftp_server_password" "$_ftp_server_dir"`
d1048 1
a1048 1
		_file_list=$(ftp -o - -V "${_url_base}/index.txt" | sed )s///'`
d1060 1
a1060 1
		ask "Pathname to the sets? (or 'done')" "$_dir"
d1064 7
a1070 7
		"")	;;
		*)	if [[ -d $_mp/$resp ]]; then
				_dir=$_mp/$resp
				break
			else
				echo "The directory '$resp' does not exist."
			fi
d1754 1
@


1.7
log
@softdep on ramdisk
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.6 2003/05/07 20:53:05 tg Exp $
d23 1
a23 1
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
d57 1
a57 1
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
d69 1
a69 1
# OpenBSD install/upgrade script common subroutines and initialization code
d458 1
a458 1
You will now initialize the disk(s) that OpenBSD will use. To enable all
d947 2
a948 1
	: ${_ftp_getlist:=y}
d950 13
a962 12
	ask "Do you want to see a list of potential $_url_type servers?" "$_ftp_getlist"
	case $resp in
	n*|N*)	_ftp_getlist=n
		;;
	*)
		_ftp_getlist=y
		# ftp.openbsd.org == 129.128.5.191 and will remain at
		# that address for the forseeable future.
		ftp ${_ftp_active} -V -a -o /tmp/ftplist ftp://129.128.5.191/$FTPDIR/ftplist > /dev/null
		grep "^${_url_type}:" /tmp/ftplist | cat -n | less -XE
		;;
	esac
d964 1
a964 1
	: ${_ftp_server_dir:=pub/OpenBSD/$SETDIR}
d982 1
a982 1
			maxlines=`grep "^${_url_type}:" /tmp/ftplist | sed -ne '$='`
d1063 1
a1063 1
		_file_list=`ftp -o - -V "${_url_base}/index.txt" | sed 's///'`
d1451 1
a1451 1
*** /bsd is not present in the installed system, or is 0 bytes long. OpenBSD
d1464 1
a1464 1
    OpenBSD requires are missing. 'base${VERSION}' must be (re)installed.
d1475 1
a1475 1
    present in the installed system. This indicates that directories OpenBSD
a1528 1
#	#XXX 1) delete 'softdep' options (no soft updates in ramdisk kernels),
a1545 4
		# Remove any softdep options, as soft updates are not
		# available in the ramdisk kernels.
		#XXX _opt=$(echo $_opt | sed -e 's/softdep//')

d1742 1
a1742 1
CONGRATULATIONS! Your OpenBSD ${MODE} has been successfully completed!
d1767 2
a1768 2
FTPDIR="pub/OpenBSD/$VNAME"
OBSD="OpenBSD/$ARCH $VNAME"
@


1.6
log
@merge conflicts; fix what(1) stdin
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.5 2003/04/13 10:19:53 tg Exp $
d1383 1
a1383 1
	local _zoneroot=/mnt/usr/share/zoneinfo/ _zonepath
d1421 1
a1421 1
			ln -sf /usr/share/zoneinfo/$TZ /mnt/etc/localtime
d1467 1
a1467 1
	if [[ ! -d /mnt/etc || ! -d /mnt/usr/share/zoneinfo || ! -d /mnt/dev ]]; then
d1527 1
a1527 1
#	1) delete 'softdep' options (no soft updates in ramdisk kernels),
d1547 1
a1547 1
		_opt=$(echo $_opt | sed -e 's/softdep//')
@


1.5
log
@remove unneeded files (no miniroot for i386)
back out some changes that were intended to shrink
the ramdisc size, since they didnt do it, and it's
more readible this way
@
text
@d1 2
a2 2
#	$MirBSD: install.sub,v 1.4 2003/04/12 23:43:41 tg Exp $
#	$OpenBSD: install.sub,v 1.293 2003/03/06 04:19:45 david Exp $
d613 1
a613 1
 	fi
d638 1
a638 1
 		cat << __EOT
d643 2
a644 2
 		case $resp in
 		y*|Y*)	cat << __EOT
d653 3
a655 3
 			;;
 		esac
 	fi
d666 1
a666 1
 		fi
d831 1
a832 1
		route show
a834 1
		route -n show
d848 1
a848 1
	# _get_sets to the intersection of _sets and DEFAULTSETS. 
d885 1
a885 1
		*.tgz)	ftp $_ftp_active -o - -V -m "$_src/$_f" | tar zxpf - -C /mnt
d1088 1
a1088 1
	install_files "file://$_dir" "`ls -l $_dir`" 
d1368 1
a1368 1
		1)	_xcmd="tar -zxvpf -"
d1370 1
a1370 1
		2)	_xcmd="tar -xvpf -"
d1517 15
a1531 5
# Create a /etc/fstab from /tmp/fstab. Ensure /etc/fstab
#	1) contains only ffs filesystems
#	2) contains only filesystems without the 'noauto' option
#	3) contains no 'softdep' options
#	4) mounts all filesystems relative to /mnt
d1538 6
a1543 18
		# Skip comment lines.
		case $_dev in
		\#*)	continue ;;
		esac

		# Skip noauto filesystems.
		case $_opt in
		*noauto*) continue ;;
		esac

		# Skip filesystems we can't mount.
		[ -f "/sbin/mount_${_fstype}" ] || continue

		# Skip nfs filesystems because all name
		# resolutions (e.g. yp) are not available
		# and success is not guaranteed. The user
		# will have to mount nfs filesystems manually.
		[ "$_fstype" != "nfs" ] || continue
d1547 1
a1547 7
		_opt="$(echo ${_opt} | \
			sed -e 's/^softdep$//; s/^softdep,//; s/,softdep,/,/; s/,softdep$//;')"

		# Mount non-ffs filesystems read-only
		[ "$_fstype" = "ffs" ] || \
			_opt="$(echo ${_opt} | \
				sed -e 's/^rw$/ro/; s/^rw,/ro,/; s/,rw,/,ro,/; s/,rw$/,ro/')"
d1549 2
a1550 2
		# Avoid '/mnt/' in root fs entry in munged fstab
		[ "$_mp" = "/" ] && _mp=
d1553 4
a1556 1
		echo $_dev /mnt$_mp $_fstype $_opt $_rest
d1632 1
a1632 1
 	local _dn
d1771 1
a1771 1
OBSD="OpenBSD/$ARCH $VNAME" 
@


1.4
log
@reorganize, so the ramdiscs will all build (verified)
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.3 2003/04/12 16:19:01 tg Exp $
d157 2
a158 1
Enter 'halt' or 'reboot' at the prompt to gracefully exit MirBSD.
d457 4
a460 1
Disc initialization stage.
d498 3
a500 2
Enter a filename, 'all' to select all the sets, or 'done'.
You may de-select a set by prepending a '-' to its name.
d1141 1
a1141 1
Two CD-ROM filesystem types are currently supported:
d1450 2
a1451 1
*** /bsd is not installed correctly! You cannot boot this system!
d1462 2
a1463 1
    present in the installed system. 'base${VERSION}' must be (re)installed.
d1474 2
a1475 1
    present in the installed system. 'etc${VERSION}' must be (re)installed.
d1492 2
a1493 1
successfully loaded.
@


1.3
log
@Implement (hopefully enough) NFS install capability on RAMDISK_CD
@
text
@d1 1
a1 1
#	$MirBSD: install.sub,v 1.2 2003/04/12 14:48:48 tg Exp $
d456 1
a456 4

You will now initialize the disk(s) that OpenBSD will use. To enable all
available security features you should configure the disk(s) to allow the
creation of separate filesystems for /, /tmp, /var, /usr, and /home.
d494 2
a495 3
The following sets are available. Enter a filename, 'all' to select
all the sets, or 'done'. You may de-select a set by prepending a '-'
to its name.
d1136 1
a1136 1
Two CD-ROM filesystem types are currently supported by this program:
d1445 1
a1445 2
*** /bsd is not present in the installed system, or is 0 bytes long. OpenBSD
    cannot boot without a valid kernel! 'bsd' must be (re)installed.
d1456 1
a1456 2
    present in the installed system. This indicates that executable files
    OpenBSD requires are missing. 'base${VERSION}' must be (re)installed.
d1467 1
a1467 2
    present in the installed system. This indicates that directories OpenBSD
    requires are missing. 'etc${VERSION}' must be (re)installed.
d1484 1
a1484 2
successfully loaded. If you are not sure what sets to ${MODE}, refer to the
installation notes for details on the contents of each.
@


1.2
log
@some more OpenBSD -> OpenBSD-mirabile / MirBSD
@
text
@d1 1
a1 1
#	$MirBSD$
d1287 1
a1287 1
	ask "Use TCP transport? (only works with capable NFS server)" n
d1289 1
a1289 1
	y*|Y*)	_nfs_tcp=-T
d1291 1
a1291 1
	*)	_nfs_tcp=
@


1.1
log
@Initial revision
@
text
@d1 1
d101 1
a101 1
Welcome to the $OBSD $MODE program.
d103 1
a103 1
This program will help you $MODE OpenBSD in a simple and rational way. At
d125 1
a125 1
NOTE: once your system has been upgraded, you must manually merge any changes
d157 1
a157 2
Enter 'halt' at the prompt to gracefully exit OpenBSD. You can then
power cycle the machine and boot your original OS.
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.298 2003/05/07 00:43:06 krw Exp $
d612 1
a612 1
	fi
d637 1
a637 1
		cat << __EOT
d642 2
a643 2
		case $resp in
		y*|Y*)	cat << __EOT
d652 3
a654 3
			;;
		esac
	fi
d665 1
a665 1
		fi
a829 1
	route -n show
d831 1
d834 1
d848 1
a848 1
	# _get_sets to the intersection of _sets and DEFAULTSETS.
d885 1
a885 1
		*.tgz)	ftp $_ftp_active -o - -V -m "$_src/$_f" | tar zxphf - -C /mnt
d1088 1
a1088 1
	install_files "file://$_dir" "`ls -l $_dir`"
d1368 1
a1368 1
		1)	_xcmd="tar zxvphf -"
d1370 1
a1370 1
		2)	_xcmd="tar xvphf -"
d1517 5
a1521 15
# Create a skeletal but useful /etc/fstab from /tmp/fstab by stripping all
# comment lines and dropping all filesystems which
#
#       1) can't be mounted (no mount_* command is found),
#	2) have 'xx' in the option field (usually /altroot),
#	3) have 'noauto' in the option field,
#	4) are nfs (since name resolution may not be present).
#
# In addition,
#
#	1) delete 'softdep' options (no soft updates in ramdisk kernels),
#	2) mount non-ffs filesystems read only,
#	3) prepend '/mnt' to all mount points,
#	4) delete any trailing '/' from the mount point (e.g. root),
#	5) leave out fs_freq and fs_passno fields.
d1528 18
a1545 6
		# Drop irrelevant lines and filesystems.
		[[ $_dev == \#* || \
		    $_fstype == nfs || \
		    ! -f /sbin/mount_$_fstype || \
		    $_opt == *noauto* || \
		    $_opt == *xx* ]] && continue
d1549 7
a1555 1
		_opt=$(echo $_opt | sed -e 's/softdep//')
d1557 2
a1558 2
		# Mount non-ffs filesystems read only.
		[[ $_fstype == ffs ]] || _opt=$(echo $_opt | sed -e 's/rw/ro/')
d1561 1
a1561 4
		# 1) prepend '/mnt' to the mount point.
		# 2) remove a trailing '/' from the mount point (e.g. root).
		# 3) leave out fs_freq and fs_passno fields (i.e. $_rest).
		echo $_dev /mnt${_mp%/} $_fstype $_opt
d1637 1
a1637 1
	local _dn
d1776 1
a1776 1
OBSD="OpenBSD/$ARCH $VNAME"
@


1.1.1.3
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.303 2003/05/12 19:01:58 krw Exp $
d228 1
a228 1
	while [[ -z $resp ]] ; do
d929 1
a929 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _line
d933 14
a946 4
	ask "HTTP/FTP proxy URL? (e.g. 'http://proxy:8080', or 'none')" \
	    "${ftp_proxy:-none}"
	unset ftp_proxy http_proxy
	[[ $resp == none ]] || export ftp_proxy=$resp http_proxy=$resp
d948 1
a948 2
	rm -f $SERVERLIST
	ask "Display the list of known $_url_type servers?" "${_get_server_list:-y}"
d950 1
a950 1
	n*|N*)	_get_server_list=n
d953 1
a953 1
		_get_server_list=y
d956 2
a957 12
		echo -n "Getting the list from 129.128.5.191 (ftp.openbsd.org)..."
		ftp $_ftp_active -V -a -o - \
			ftp://129.128.5.191/$FTPDIR/ftplist 2>/tmp/ftplisterr \
			| sed -ne "/^${_url_type}:\/\//s///p" >$SERVERLIST
		if [[ -s $SERVERLIST ]]; then
			echo "done."
			_prompt="Server? (IP address, hostname, list#, 'done' or '?')"
			cat -n $SERVERLIST | less -XE
		else
			echo "FAILED."
			cat /tmp/ftplisterr
		fi
d961 2
d964 9
a972 4
	: ${_prompt:="Server? (IP address, hostname or 'done')"}
	while : ; do
		eval resp=\$_${_url_type}_server_ip
		ask_until "$_prompt" "$resp"
d974 3
a976 3
		done)	return ;;
		"?")	[[ -s $SERVERLIST ]] || continue
			cat -n $SERVERLIST | less -XE
d979 18
a996 13
			# A numeric hostname is ignored. A number is only used
			# as a line number in $SERVERLIST.
			[[ -s $SERVERLIST ]] || continue
			_line=$(sed -ne "${resp}p" $SERVERLIST)
			[[ -n $_line ]] || { echo "There is no line $resp." ; continue ; }
			echo "Using	$_line"
			_line=$(echo $_line | cutword -t' ' 1)
			eval _${_url_type}_server_ip=${_line%%/*}
			eval _${_url_type}_server_dir=${_line#*/}/$SETDIR
			# Repeat loop to get user to confirm server address.
 			;;
		*)	eval _${_url_type}_server_ip=$resp
			break
d1001 2
d1020 1
a1020 2
	eval resp=\$_${_url_type}_server_dir
	ask_until "Server directory?" "${resp:-pub/OpenBSD/$SETDIR}"
a1043 1
	_url_base=$_url_type://
d1045 5
a1049 1
		_url_base=$_url_base$(encode_for_url "$_ftp_server_login"):$(encode_for_url "$_ftp_server_password")@@
a1050 1
	eval _url_base=$_url_base\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
d1054 1
a1054 1
		_file_list=$(ftp_list_files "$_ftp_server_ip" "$_ftp_server_login" "$_ftp_server_password" "$_ftp_server_dir")
d1060 1
a1060 1
		_file_list=$(ftp -o - -V "$_url_base/index.txt" | sed 's///')
d1072 1
a1072 1
		ask_until "Pathname to the sets? (or 'done')" "$_dir"
d1076 7
a1082 7
		*)
			# Accept a valid $_mp relative path.
			[[ -d $_mp/$resp ]] && { _dir=$_mp/$resp ; break ; }
			# Accept a valid absolute path.
			[[ -d /$resp ]] && { _dir=/$resp ; break ; }
			# Otherwise ask again, with original default dir.
			echo "The directory '$resp' does not exist."
a1770 1
SERVERLIST=/tmp/serverlist
@


1.1.1.4
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.304 2003/06/02 15:46:09 deraadt Exp $
d15 6
@


1.1.1.5
log
@Sync OpenBSD source tree from -current CVS.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.307 2003/06/27 22:40:40 krw Exp $
a459 1
	SWAPDEV=
a465 1
	SWAPDEV=${ROOTDISK}b
a488 1
		_action=
d508 1
d510 8
a517 2
		done)	break ;;
		-*)	_action=rmel ;;
a519 1
		: ${_action:=addel}
d521 1
a522 8
		case $resp in
		"")	continue ;;
		all)	resp=* ;;
		esac

		# Use @@($resp) rather than just $resp to protect
		# against silly user input that might cause syntax
		# errors.
d525 3
a527 1
			@@($resp)) _selected=\`$_action $_f \$_selected\` ;;
d530 1
d697 6
d830 2
d1700 1
a1700 1
	local _dev _mp _fstype _rest
a1702 14

	# Mount all known swap partitions.  This gives systems with little
	# memory a better chance at running 'MAKEDEV all'.
	if [[ -x /mnt/sbin/swapctl ]]; then
		/mnt/sbin/swapctl -a /dev/$SWAPDEV >/dev/null 2>&1
		# Can't do chmod && swapctl -A because devices are not yet
		# created on install'ed systems. On upgrade'ed system there
		# is a small chance the device does not exist on the ramdisk
		# and will thus not get mounted.
		while read _dev _mp _fstype _rest; do
			[[ $_fstype == swap ]] && \
			    /mnt/sbin/swapctl -a $_dev >/dev/null 2>&1
		done </mnt/etc/fstab
	fi
@


1.1.1.6
log
@some more fixes for the OpenBSD installation scripts, from krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.309 2003/06/30 17:49:14 krw Exp $
d233 1
a233 1
# $4 = default device. If it is not specified, use the first device in $3.
d238 10
a247 3
	
	set -- $_devs
	if [[ $# < 1 ]]; then
a249 1
		return
a250 1
	: ${_defdev:=$1}
d252 1
a252 4
	# Eliminate extraneous (especially trailing) whitespace in _devs.
	_devs="$*"

	while : ; do
d254 2
a255 2
		# separate 'echo' to ensure the entire question is
		# re-ask'ed after a '!' or '!foo' shell escape.
a256 1
		[[ $resp == done ]] && break
d260 3
a262 3
		if isin "$resp" $_devs; then
			makedev $resp && break
		else
d264 1
d323 9
d354 1
a354 1
	# for cutword, by outputting blanks only when $_l
d445 4
a448 1
	if [[ $MODE == install && ! -f /etc/fstab ]]; then
a461 3
	set -- $DKDEVS
	[[ $# > 1 ]] && _defdsk=done

d463 1
a463 1
	[[ $resp == done ]] && exit
d543 3
a545 2
		ask_which "interface" "do you wish to initialize?" "$_IFDEVS"
		[[ $resp == done ]] && break
d1066 2
a1067 2
	ask_which "CD-ROM" "contains the ${MODE} media?" "$CDDEVS"
	[[ $resp == done ]] && return
d1151 2
a1152 2
	ask_which "disk" "contains the ${MODE} sets?" "$DKDEVS"
	[[ $resp == done ]] && return 1
d1360 1
a1360 1
	[[ ! -d $_zoneroot ]] && return
d1362 3
a1364 3
	if [[ -L /mnt/etc/localtime ]]; then
		TZ=$(ls -l /mnt/etc/localtime 2>/dev/null)
		TZ=${TZ#*${_zoneroot#/mnt}}
d1374 1
a1374 1
		if [[ $resp == ? ]]; then
d1381 1
a1381 1
		while [[ -d $_zonepath ]]; do
d1383 2
a1384 2
			if [[ $resp == ? ]]; then
				ls -F $_zonepath
d1386 1
a1386 1
				_zonepath=$_zonepath/$resp
d1390 1
a1390 1
		if [[ -f $_zonepath ]]; then
@


1.1.1.7
log
@A few more selected fixes from -current
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.310 2003/07/02 16:42:19 krw Exp $
d167 1
a167 3
	ifconfig -a \
	    | egrep -v '^[[:space:]]|(bridge|enc|gif|gre|lo|pflog|pfsync|ppp|sl|tun|vlan)[[:digit:]]+:' \
	    | sed -ne 's/^\(.*\):.*/\1/p'
d303 18
d904 1
a904 1
	local _url_type=$1 _file_list _url_base _oifs _prompt
d951 6
a956 5
			set -- $(sed -ne "${resp}p" $SERVERLIST)
			[[ $# < 1 ]] && { echo "There is no line $resp." ; continue ; }
			echo "Using	$*"
			eval _${_url_type}_server_ip=${1%%/*}
			eval _${_url_type}_server_dir=${1#*/}/$SETDIR
@


1.1.1.8
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.312 2003/07/03 15:19:01 krw Exp $
d242 1
a242 1
	if [[ $# -lt 1 ]]; then
d286 4
d291 1
a291 2
	echo -n "$*"
	isin "$_a" $* || echo -n " $_a"
d308 4
a311 1
	[[ $# -gt 0 ]] || return
d315 2
a316 2
		if [[ $_a != $_b ]] ; then
			if [[ $_a > $_b ]] ; then
d324 1
a324 2
	# Output the smallest value found.
	echo "$_a "
d326 8
a333 2
	# Sort remaining values.
	bsort $_l
d433 1
a433 1
	[[ $# -gt 1 ]] && _defdsk=done
d656 1
a656 1
	while [[ ${#_n} -ne 0 ]]; do
d936 1
a936 1
			[[ $# -lt 1 ]] && { echo "There is no line $resp." ; continue ; }
@


1.1.1.9
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.314 2003/07/10 15:03:19 krw Exp $
d877 1
a877 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _home
a980 1
		[[ $_ftp_server_dir == /* || $_ftp_server_dir == ~* ]] || _home="~/"
d983 1
a983 1
	eval _url_base=$_url_base\$_${_url_type}_server_ip/$_home\$_${_url_type}_server_dir
a1718 5

# Do not limit ourselves during installs or upgrades.
for _opt in d f l m n p s; do
	ulimit -$_opt unlimited
done
@


1.1.1.10
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.315 2003/08/07 19:13:00 deraadt Exp $
d240 1
a240 1

d930 1
a930 1
			;;
@


1.1.1.11
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.317 2003/08/16 20:37:24 krw Exp $
d1557 1
a1557 1
	echo "...done."
d1713 1
a1713 1
VERSION=34
@


1.1.1.12
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.320 2003/08/23 22:22:02 krw Exp $
d235 1
a235 2
# $4 = default device. If it is not specified, use the first device in $3
# $5 = error message if no devices in $3, defaults to 'No $1s found.'
d239 1
a239 1
	local _name=$1 _query=$2 _devs=$3 _defdev=$4 _err=$5
d243 1
a243 1
		echo "${_err:=No ${_name}s found}."
d256 1
a256 1
		ask "Available ${_name}s are: ${_devs}.\nWhich one ${_query}? (or 'done')" "$_defdev"
d404 28
d505 1
a505 2
		ask_which "interface" "do you wish to initialize" "$_IFDEVS" "" \
		    "No more interfaces to initialize"
d875 1
a875 1
#	and _ftp_active must be global.
d877 1
a877 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _home _passwd
d967 1
a967 1
		_passwd=root@@`hostname`
d973 1
a973 1
			_passwd=$resp
d982 1
a982 1
		_url_base=$_url_base$(encode_for_url "$_ftp_server_login"):$(encode_for_url "$_passwd")@@
d988 1
a988 1
		_file_list=$(ftp_list_files "$_ftp_server_ip" "$_ftp_server_login" "$_passwd" "$_ftp_server_dir")
d1027 1
a1027 1
	ask_which "CD-ROM" "contains the ${MODE} media" "$CDDEVS"
d1112 1
a1112 1
	ask_which "disk" "contains the ${MODE} sets" "$DKDEVS"
a1619 1
	[[ -f /tmp/dhclient.conf ]] && _dr=dhcp
d1763 2
a1764 20
# Get ROOTDISK, ROOTDEV and SWAPDEV.
if [[ $MODE == install && ! -f /etc/fstab ]]; then
	cat << __EOT

You will now initialize the disk(s) that OpenBSD will use. To enable all
available security features you should configure the disk(s) to allow the
creation of separate filesystems for /, /tmp, /var, /usr, and /home.

__EOT
fi

set -- $DKDEVS
[[ $# -gt 1 ]] && _defdsk=done

ask_which "disk" "is the root disk" "$DKDEVS" "$_defdsk"
[[ $resp == done ]] && exit

ROOTDISK=$resp
ROOTDEV=${ROOTDISK}a
SWAPDEV=${ROOTDISK}b
@


1.1.1.13
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.321 2003/09/22 01:31:39 krw Exp $
d69 1
a69 1
#	md_prep_disklabel()	  - put an OpenBSD disklabel on the disk
d83 1
a83 1
	[[ -n $TERM ]] && return
a91 2
	local _q

d122 1
a122 1
		_q="Proceed with upgrade?"
d138 1
a138 1
			_q="Skip disk initialization?"
d140 1
a140 1
			_q="Proceed with install?"
d145 4
a148 3
	ask_yn "$_q"
	if [[ $resp == n ]]; then
		cat << __EOT
d154 2
a155 3
	fi

	echo "Cool!  Let's get to it..."
d194 1
a194 1
ask () {
a228 20
# Ask the user for a y or n, and insist on 'y', 'yes', 'n' or 'no'.
#
#    $1    = the question to ask the user
#    $2    = the default answer (assumed to be 'n' if empty).
#
# Return 'y' or 'n' in $resp.
ask_yn () {
	local _q=$1 _a=${2:-no} _resp
	typeset -l _resp

	while : ; do
		ask "$_q" "$_a"
		_resp=$resp
		case $_resp in
		y|yes)	resp=y ; return ;;
		n|no)	resp=n ; return ;;
		esac
	done		
 }

d346 5
a350 2
	ask_yn "Edit $_file with $EDITOR?"
	[[ $resp == y ]] && $EDITOR /tmp/$_file
d356 1
a356 1
	ask_yn "Do you want to do any manual network configuration?"
d358 5
a362 1
	[[ $resp == y ]] && { echo "Type 'exit' to return to $MODE." ; sh ; }
d571 1
a571 1
		ask_yn "Do you want to change the default media?"
d573 1
a573 1
		y)	cat << __EOT
d581 1
a581 1
		n)	_media=
d797 4
a800 2
	ask_yn "Ready to $MODE sets?" yes
	[[ $resp = n ]] && return
d861 6
a866 3
	ask_yn "Display the list of known $_url_type servers?" "${_get_server_list:-yes}"
	_get_server_list=$resp
	if [[ $_get_server_list == y ]]; then
d881 2
a882 1
	fi
d916 2
a917 2
		-A)	resp=no ;;
		*)	resp=yes ;;
d920 5
a924 3
		unset _ftp_active
		ask_yn "Does the server support passive mode ftp?" $resp
		[[ $resp == n ]] && _ftp_active=-A
d1194 7
a1200 3
	_nfs_tcp=
	ask_yn "Use TCP transport? (only works with capable NFS server)"
	[[ $resp == y ]] && _nfs_tcp=-T
d1585 5
a1589 2
		ask_yn "Use the nameserver now?"
		[[ $resp == y ]] && cp /tmp/resolv.conf /tmp/resolv.conf.shadow
d1617 1
a1617 1
	[[ -n $MDXAPERTURE ]] || return
d1619 3
a1621 2
	ask_yn "Do you expect to run the X Window System?" yes
	if [[ $resp == y ]]; then
d1624 2
a1625 1
	fi
@


1.1.1.14
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.324 2003/12/21 21:45:41 krw Exp $
d196 1
a196 1
ask() {
d224 1
a224 1
ask_until() {
d237 1
a237 1
ask_yn() {
d261 1
a261 1
ask_which() {
d351 1
a351 1
save_comments() {
d365 1
a365 1
edit_tmp_file() {
d374 1
a374 1
manual_net_cfg() {
d506 1
a506 1
inet_info() {
d523 1
a523 1
dhcp_request() {
d780 1
a780 1
install_files() {
d850 1
a850 1
ftp_error() {
d1502 1
a1502 1
kill_dhclient() {
d1588 1
a1588 1
		ask_yn "Use the nameserver now?" y
d1616 1
a1616 7
questions() {
	ask_yn "Do you wish sshd(8) to be started by default?" yes
	if [[ $resp == n ]]; then
		echo "sshd_flags=NO		# disabled during install" \
		    > /mnt/etc/rc.conf.local
	fi

d1622 1
a1622 1
		    /mnt/etc/sysctl.conf > /tmp/sysctl.conf
@


1.1.1.15
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.325 2004/01/11 18:57:02 krw Exp $
d548 2
a549 1
	dhclient $_ifs
d705 1
d1499 8
@


1.1.1.16
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.338 2004/04/12 22:55:11 krw Exp $
d4 1
a4 1
# Copyright (c) 1997-2004 Todd Miller, Theo de Raadt, Ken Westerback
d248 1
a248 1
	done
d487 2
a488 2
configure_ifs() {
	local _IFDEVS=$IFDEVS _ifs _name _media _hn
d491 4
a494 2
		ask_which "interface" "do you wish to initialize" "$_IFDEVS" \
			"" "No more interfaces to initialize"
d498 1
a498 32
		_hn=/tmp/hostname.$_ifs 

		# Get symbolic name - will be used in DHCP requests.
		ask "Symbolic (host) name for $_ifs?" "$(hostname -s)"
		_name=$resp

		# Get and apply media options.
		_media=$(ifconfig -m $_ifs | grep "media ")
		if [[ -n $_media ]]; then
			cat << __EOT
The media options for $_ifs are currently
$(ifconfig -m $_ifs | sed -n '/supported/D;/media:/p')
__EOT
			ask_yn "Do you want to change the media options?"
			case $resp in
			y)	cat << __EOT
Supported media options for $_ifs are:
$_media
__EOT
				ask "Media options for $_ifs?"
				_media=$resp
				ifconfig $_ifs $_media || return 1
				;;
			n)	_media=
				;;
			esac
		fi

		rm -f $_hn
		v4_config "$_ifs" "$_media" "$_name" "$_hn"

		[[ -f $_hn ]] && _IFDEVS=$(rmel "$_ifs" $_IFDEVS)
d502 2
a503 1
# Output '<UP | DOWN> [<addr> <netmask> <rest of inet line>]'.
d506 1
a506 1
v4_info() {
d508 5
a512 2
		1s/.*<UP,.*/UP/p
		1s/.*<.*/DOWN/p
d514 2
a515 1
		/inet/s///p'
d550 1
a550 1
	set -- $(v4_info $_ifs)
d567 36
a602 2
v4_config() {
	local _ifs=$1 _media=$2 _name=$3 _hn=$4 _prompt
a603 9
	set -- $(v4_info $_ifs)
	if [[ -n $2 ]]; then
		ifconfig $_ifs inet $2 delete
		[[ $2 != "0.0.0.0" ]] && { _addr=$2; _mask=$3; }
	fi	

	[[ -x /sbin/dhclient ]] && _prompt=" or 'dhcp'"
	_prompt="IPv4 address for $_ifs? (or 'none'$_prompt)"
	
a605 1
	none)	;;
d607 2
a608 4
			echo "DHCP not possible - no /sbin/dhclient."
		elif dhcp_request $_ifs "$_name" || dhcp_request $_ifs ; then
			addhostent "127.0.0.1" "$_name"
			echo "dhcp NONE NONE NONE $_media" > $_hn
d610 4
d617 3
a619 4
		if ifconfig $_ifs inet $_addr netmask $resp up ; then
			addhostent "$_addr" "$_name"
			echo "inet $_addr $resp NONE $_media" > $_hn
		fi
a621 1
}
d623 5
a627 20
v4_defroute() {
	local _dr _prompt=" or 'none'"

	[[ -x /sbin/dhclient ]] && _prompt=", 'dhcp'$_prompt"
	_prompt="Default IPv4 route? (IPv4 address$_prompt)"

	_dr=$(route -n show -inet | sed -ne '/^default */{s///; s/ .*//; p;}')
	[[ -f /tmp/dhclient.conf ]] && _dr=dhcp

	while : ; do
		ask_until "$_prompt" "$_dr"
		case $resp in
		none|dhcp) break ;;
		esac
		route delete -inet default > /dev/null 2>&1
		route -n add -inet -host default "$resp" && { echo "$resp" >/tmp/mygate ; break ; }
		# Put the old default route back. The new one did not work.
		route -n add -inet -host default $_dr >/dev/null 2>&1
	done
}
d631 2
a632 1
	local _n=$1
d656 6
a661 3
	# Set the address for the loopback interface. Bringing the
	# interface up, automatically invokes the IPv6 address ::1.
	ifconfig lo0 inet 127.0.0.1
d740 1
a740 1
					[ "$alias" ] && rtcmd="; route -qn add -host $name 127.0.0.1"
d752 1
a752 1
		done </mnt/etc/hostname.$if
d758 2
a759 2
		route delete default >/dev/null 2>&1
		route -qn add -host default $(< /mnt/etc/mygate)
a761 4
	# Use loopback, not the wire.
	route -qn add -host `hostname` 127.0.0.1 >/dev/null
	route -qn add -net 127 127.0.0.1 -reject >/dev/null

d831 1
a831 1
# section 3.1 and section 5.
d833 3
a835 2
# Escape everything between 0x20 and 0x7e to avoid both illegal url
# characters and characters causing problems during script processing.
d837 2
a838 4
# *NOTE*
#	1) quotes around $1 are required to preserve trailing or
#	   embeddded blanks in usercodes and passwords.
#	2) substitute '%' FIRST so it doesn't eliminate '%' chars we insert.
d840 1
a840 35
	echo "$1" | sed -e "
s/%/%25/g
s/ /%20/g
s/!/%21/g
s/\"/%22/g
s/#/%23/g
s/\\\$/%24/g
s/&/%26/g
s/'/%27/g
s/(/%28/g
s/)/%29/g
s/\*/%2a/g
s/+/%2b/g
s/,/%2c/g
s/-/%2d/g
s/\./%2e/g
s/\//%2f/g
s/:/%3a/g
s/;/%3b/g
s/</%3c/g
s/=/%3d/g
s/>/%3e/g
s/?/%3f/g
s/@@/%40/g
s/\[/%5b/g
s/\\\\/%5c/g
s/]/%5d/g
s/\^/%5e/g
s/_/%5f/g
s/\`/%60/g
s/{/%7b/g
s/|/%7c/g
s/}/%7d/g
s/~/%7e/g
"
d862 1
a862 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _passwd
d960 1
d963 1
a963 1
	eval _url_base=$_url_base\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
d1356 3
a1358 1
+*** 'bsd' must be (re)installed: no kernel found.
d1363 1
a1363 1
	if [[ ! -d /mnt/sbin || ! -d /mnt/dev ]]; then
d1367 4
a1370 1
+*** 'base${VERSION}.tgz' must be (re)installed: /sbin or /dev is missing.
d1375 1
a1375 1
	if [[ ! -s /mnt/etc/rc ]]; then
d1379 4
a1382 1
+*** 'etc${VERSION}.tgz' must be (re)installed: /etc/rc is missing.
d1542 1
a1542 1
	local _dn _ns
d1548 1
a1548 1
	configure_ifs
d1578 1
a1578 1
		ask_yn "Use the nameserver now?" yes
d1582 13
a1594 2
	# Get/Confirm an IPv4 default route if an IPv4 address was configured.
	[[ -n $(ifconfig -a | sed -ne '/[ 	]inet .* broadcast /p') ]] && v4_defroute
d1625 2
d1682 1
a1682 1
VERSION=35
@


