head	1.5;
access;
symbols
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.14
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.12
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.10
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.8
	MIRBSD_7quater:1.5
	MIRBSD_7_ALPHA:1.5.0.6
	MIRBSD_7:1.5.0.4
	MIRBSD_7ter:1.5
	MIRBSD_7_DEV:1.5.0.2
	MIRBSD_5:1.3
	MIRBSD_4:1.2;
locks; strict;
comment	@ * @;


1.5
date	2003.10.03.19.10.53;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2003.10.03.14.58.41;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.15.16.19.44;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.06.14.13.27;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.25.21.53.20;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@finish release engineering
you should be able to build the release now
@
text
@/*	$MirBSD: rc_config.c,v 1.4 2003/10/03 14:58:41 tg Exp $	*/
/*
 * Copyright (c) 1997, 2000 Hellmuth Michaelis. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *---------------------------------------------------------------------------
 *
 *	i4b daemon - config file processing
 *	-----------------------------------
 *
 *	_Id: rc_config.c,v 1.16 2003/01/06 12:46:14 wiz Exp $ 
 *
 * $FreeBSD$
 *
 *      last edit-date: [Sat Jan  6 12:57:36 2001]
 *
 *---------------------------------------------------------------------------*/

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <sys/timeout.h>
#include <sys/ioctl.h>
#include <ifaddrs.h>

#include "isdnd.h"
#include "rc_parse.h"

#include "monitor.h"

extern int lineno;
extern char *yytext;

extern FILE *yyin;
extern int yyparse(void);

static void set_config_defaults(void);
static void check_config(void);
static void print_config(void);
static void parse_valid(char *dt);
static int lookup_l4_driver(const char *name);
void init_currrent_cfg_state(void);
//static void set_isppp_auth(struct cfg_entry*);
static void set_autoupdown(struct cfg_entry*);
void flush_config(void);

static int nregexpr = 0;
static int nregprog = 0;
static struct cfg_entry * current_cfe = NULL;
struct isdn_ctrl_state * cur_ctrl = NULL;

/*---------------------------------------------------------------------------*
 *	called from main to read and process config file
 *---------------------------------------------------------------------------*/
void
configure(char *filename, int reread)
{
	extern void reset_scanner(FILE *inputfile);
	
	set_config_defaults();

	yyin = fopen(filename, "r");

	if(reread)
	{
		reset_scanner(yyin);
		current_cfe = NULL;
	}

	if (yyin == NULL)
	{
		logit(LL_ERR, "cannot fopen file [%s]", filename);
		exit(1);
	}

	yyparse();
	
	monitor_fixup_rights();

	check_config();		/* validation and consistency check */

	fclose(yyin);

	if(do_print)
	{
		if(config_error_flag)
		{
			logit(LL_ERR, "there were %d error(s) in the configuration file, terminating!", config_error_flag);
			exit(1);
		}
		print_config();
		do_exit(0);
	}
}

/*---------------------------------------------------------------------------*
 *	yacc error routine
 *---------------------------------------------------------------------------*/
void
yyerror(const char *msg)
{
	logit(LL_ERR, "configuration error: %s at line %d, token \"%s\"", msg, lineno+1, yytext);
	config_error_flag++;
}

/*
 * Prepare a new default entry
 */
void
init_currrent_cfg_state()
{
	if (current_cfe != NULL) {
		add_cfg_entry(current_cfe);
	}
	current_cfe = malloc(sizeof(struct cfg_entry));
	memset(current_cfe, 0, sizeof(struct cfg_entry));

	current_cfe->isdncontroller = INVALID;
	current_cfe->isdnchannel = CHAN_ANY;
	current_cfe->usrdevice = INVALID;
	current_cfe->usrdeviceunit = INVALID;
	current_cfe->remote_numbers_handling = RNH_LAST;
	current_cfe->dialin_reaction = REACT_IGNORE;
	current_cfe->b1protocol = BPROT_NONE;
	current_cfe->unitlength = UNITLENGTH_DEFAULT;
	current_cfe->earlyhangup = EARLYHANGUP_DEFAULT;
	current_cfe->ratetype = INVALID_RATE;
	current_cfe->unitlengthsrc = ULSRC_NONE;
	current_cfe->answerprog = ANSWERPROG_DEF;	 	
	current_cfe->callbackwait = CALLBACKWAIT_MIN;
	current_cfe->calledbackwait = CALLEDBACKWAIT_MIN;		
	current_cfe->dialretries = DIALRETRIES_DEF;
	current_cfe->recoverytime = RECOVERYTIME_MIN;
	current_cfe->dialouttype = DIALOUT_NORMAL;
	current_cfe->inout = DIR_INOUT;
	current_cfe->ppp_expect_auth = AUTH_UNDEF;
	current_cfe->ppp_send_auth = AUTH_UNDEF;
	current_cfe->ppp_auth_flags = AUTH_RECHALLENGE | AUTH_REQUIRED;
	current_cfe->cdid = CDID_UNUSED;
	current_cfe->state = ST_IDLE;
	current_cfe->aoc_valid = AOC_INVALID;
	current_cfe->autoupdown = AUTOUPDOWN_YES;
}

/*---------------------------------------------------------------------------*
 *	fill all config entries with default values
 *---------------------------------------------------------------------------*/
static void
set_config_defaults(void)
{
	int i;

	/* system section cleanup */
        
	nregprog = nregexpr = 0;

	rt_prio = RTPRIO_NOTUSED;

	mailer[0] = '\0';
	mailto[0] = '\0';       
        
	/* clean regular expression table */
        
	for(i=0; i < MAX_RE; i++)
	{
		if(rarr[i].re_expr)
			free(rarr[i].re_expr);
		rarr[i].re_expr = NULL;
	        
		if(rarr[i].re_prog)
			free(rarr[i].re_prog);
		rarr[i].re_prog = NULL;

		rarr[i].re_flg = 0;
	}

	strcpy(rotatesuffix, "");
}

static void
set_autoupdown(struct cfg_entry *cep)
{
        struct ifaddrs *res = NULL, *p;
	struct ifreq ifr;
	int r, s, cnt, in6;

	s = socket(AF_INET, SOCK_DGRAM, 0);
	memset(&ifr, 0, sizeof ifr);
	snprintf(ifr.ifr_name, sizeof ifr.ifr_name, "%s%d", cep->usrdevicename, cep->usrdeviceunit);
	r = ioctl(s, SIOCGIFFLAGS, &ifr);

	/*
	 * See if this interface has got any valid addresses - if not,
	 * leave it alone.
	 */
	if (r >= 0 && !(ifr.ifr_flags & IFF_UP)) {
		cnt = in6 = 0;
		if (getifaddrs(&res) == 0) {
			for (p = res; p; p = p->ifa_next) {
				if (p->ifa_addr == NULL)
					continue;
				if (p->ifa_addr->sa_family == AF_LINK)
					continue;
				if (strcmp(p->ifa_name, ifr.ifr_name) != 0)
					continue;
				if (p->ifa_addr->sa_family == AF_INET6)
					in6 = 1;
				cnt++;
			}
			freeifaddrs(res);
		}

		if (in6)
			cnt--;	/* XXX - heuristic to adjust for INET6 local scope */

		/* Ok, we have some addres - so UP the interface */
		if (cnt > 0) {
			ifr.ifr_flags |= IFF_UP;
			r = ioctl(s, SIOCSIFFLAGS, &ifr);
			if (r >= 0)
				cep->autoupdown |= AUTOUPDOWN_DONE;
		}
	}

	close(s);
}

/*static void
set_isppp_auth(struct cfg_entry *cep)
{
	struct spppauthcfg spcfg;
	int s;
	int doioctl = 0;

	if(cep->ppp_expect_auth == AUTH_UNDEF 
	   && cep->ppp_send_auth == AUTH_UNDEF)
		return;

	if(cep->ppp_expect_auth == AUTH_NONE 
	   || cep->ppp_send_auth == AUTH_NONE)
		doioctl = 1;

	if ((cep->ppp_expect_auth == AUTH_CHAP 
	     || cep->ppp_expect_auth == AUTH_PAP)
	    && cep->ppp_expect_name != NULL
	    && cep->ppp_expect_password != NULL)
		doioctl = 1;

	if ((cep->ppp_send_auth == AUTH_CHAP || cep->ppp_send_auth == AUTH_PAP)
			&& cep->ppp_send_name != NULL
			&& cep->ppp_send_password != NULL)
		doioctl = 1;

	if(!doioctl)
		return;

	memset(&spcfg, 0, sizeof spcfg);
	snprintf(spcfg.ifname, sizeof(spcfg.ifname), "%s%d",
		cep->usrdevicename, cep->usrdeviceunit);

	/* use a random AF to create the socket **
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		logit(LL_ERR, "ERROR opening control socket at line %d!", lineno);
		config_error_flag++;
		return;
	}

	if (ioctl(s, SPPPGETAUTHCFG, &spcfg) == -1) {
		logit(LL_ERR, "ERROR fetching active PPP authentication info for %s at line %d!", spcfg.ifname, lineno);
		close(s);
		config_error_flag++;
		return;
	}
	if (cep->ppp_expect_auth != AUTH_UNDEF)
	{
		if(cep->ppp_expect_auth == AUTH_NONE)
		{
			spcfg.hisauth = SPPP_AUTHPROTO_NONE;
		}
		else if ((cep->ppp_expect_auth == AUTH_CHAP 
			  || cep->ppp_expect_auth == AUTH_PAP)
			 && cep->ppp_expect_name != NULL
			 && cep->ppp_expect_password != NULL)
		{
			spcfg.hisauth = cep->ppp_expect_auth == AUTH_PAP ? SPPP_AUTHPROTO_PAP : SPPP_AUTHPROTO_CHAP;
			spcfg.hisname = cep->ppp_expect_name;
			spcfg.hisname_length = strlen(cep->ppp_expect_name)+1;
			spcfg.hissecret = cep->ppp_expect_password;
			spcfg.hissecret_length = strlen(cep->ppp_expect_password)+1;
		}
	}
	if (cep->ppp_send_auth != AUTH_UNDEF)
	{
		if(cep->ppp_send_auth == AUTH_NONE)
		{
			spcfg.myauth = SPPP_AUTHPROTO_NONE;
		}
		else if ((cep->ppp_send_auth == AUTH_CHAP 
			  || cep->ppp_send_auth == AUTH_PAP)
			 && cep->ppp_send_name != NULL
			 && cep->ppp_send_password != NULL)
		{
			spcfg.myauth = cep->ppp_send_auth == AUTH_PAP ? SPPP_AUTHPROTO_PAP : SPPP_AUTHPROTO_CHAP;
			spcfg.myname = cep->ppp_send_name;
			spcfg.myname_length = strlen(cep->ppp_send_name)+1;
			spcfg.mysecret = cep->ppp_send_password;
			spcfg.mysecret_length = strlen(cep->ppp_send_password)+1;

			if(cep->ppp_auth_flags & AUTH_REQUIRED)
				spcfg.hisauthflags &= ~SPPP_AUTHFLAG_NOCALLOUT;
			else
				spcfg.hisauthflags |= SPPP_AUTHFLAG_NOCALLOUT;

			if(cep->ppp_auth_flags & AUTH_RECHALLENGE)
				spcfg.hisauthflags &= ~SPPP_AUTHFLAG_NORECHALLENGE;
			else
				spcfg.hisauthflags |= SPPP_AUTHFLAG_NORECHALLENGE;
		}
	}

	if (ioctl(s, SPPPSETAUTHCFG, &spcfg) == -1) {
		logit(LL_ERR, "ERROR setting new PPP authentication parameters for %s at line %d!", spcfg.ifname, lineno);
		config_error_flag++;
	}
	close(s);
}

/*---------------------------------------------------------------------------*
 *	extract values from config and fill table
 *---------------------------------------------------------------------------*/
void
cfg_setval(int keyword)
{
	int i;
	
	switch(keyword)
	{
		case ACCTALL:
			acct_all = yylval.booln;
			DBGL(DL_RCCF, (logit(LL_DBG, "system: acctall = %d", yylval.booln)));
			break;
			
		case ACCTFILE:
			strcpy(acctfile, yylval.str);
			DBGL(DL_RCCF, (logit(LL_DBG, "system: acctfile = %s", yylval.str)));
			break;

		case ALERT:
			if(yylval.num < MINALERT)
			{
				yylval.num = MINALERT;
				DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: alert < %d, min = %d", current_cfe->name, MINALERT, yylval.num)));
			}
			else if(yylval.num > MAXALERT)
			{
				yylval.num = MAXALERT;
				DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: alert > %d, min = %d", current_cfe->name, MAXALERT, yylval.num)));
			}
				
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: alert = %d", current_cfe->name, yylval.num)));
			current_cfe->alert = yylval.num;
			break;

		case ALIASING:
			DBGL(DL_RCCF, (logit(LL_DBG, "system: aliasing = %d", yylval.booln)));
			aliasing = yylval.booln;
			break;

		case ALIASFNAME:
			strcpy(aliasfile, yylval.str);
			DBGL(DL_RCCF, (logit(LL_DBG, "system: aliasfile = %s", yylval.str)));
			break;

		case ANSWERPROG:
			if((current_cfe->answerprog = malloc(strlen(yylval.str)+1)) == NULL)
			{
				logit(LL_ERR, "entry %s: answerstring, malloc failed!", current_cfe->name);
				do_exit(1);
			}
			strcpy(current_cfe->answerprog, yylval.str);
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: answerprog = %s", current_cfe->name, yylval.str)));
			break;
			
		case B1PROTOCOL:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: b1protocol = %s", current_cfe->name, yylval.str)));
			if(!(strcmp(yylval.str, "raw")))
				current_cfe->b1protocol = BPROT_NONE;
			else if(!(strcmp(yylval.str, "hdlc")))
				current_cfe->b1protocol = BPROT_RHDLC;
			else
			{
				logit(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"b1protocol\" at line %d!", lineno);
				config_error_flag++;
			}
			break;

		case BEEPCONNECT:
			do_bell = yylval.booln;
			DBGL(DL_RCCF, (logit(LL_DBG, "system: beepconnect = %d", yylval.booln)));
			break;

		case BUDGETCALLBACKPERIOD:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: budget-callbackperiod = %d", current_cfe->name, yylval.num)));
			current_cfe->budget_callbackperiod = yylval.num;
			break;

		case BUDGETCALLBACKNCALLS:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: budget-callbackncalls = %d", current_cfe->name, yylval.num)));
			current_cfe->budget_callbackncalls = yylval.num;
			break;
			
		case BUDGETCALLOUTPERIOD:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: budget-calloutperiod = %d", current_cfe->name, yylval.num)));
			current_cfe->budget_calloutperiod = yylval.num;
			break;

		case BUDGETCALLOUTNCALLS:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: budget-calloutncalls = %d", current_cfe->name, yylval.num)));
			current_cfe->budget_calloutncalls = yylval.num;
			break;

		case AUTOUPDOWN:
			current_cfe->autoupdown = yylval.booln;
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: autoupdown = %d", current_cfe->name, yylval.booln)));
			break;

		case BUDGETCALLBACKSFILEROTATE:
			current_cfe->budget_callbacksfile_rotate = yylval.booln;
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: budget-callbacksfile-rotate = %d", current_cfe->name, yylval.booln)));
			break;
			
		case BUDGETCALLBACKSFILE:
			{
				FILE *fp;
				int s, l;
				int n;
				DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: budget-callbacksfile = %s", yylval.str)));
				fp = fopen(yylval.str, "r");
				if(fp != NULL)
				{
					if((fscanf(fp, "%d %d %d", (int *)&s, (int *)&l, &n)) != 3)
					{
						DBGL(DL_RCCF, (logit(LL_DBG, "entry %d: initializing budget-callbacksfile %s", current_cfe->name, yylval.str)));
						fclose(fp);
						fp = fopen(yylval.str, "w");
						if(fp != NULL)
							fprintf(fp, "%d %d %d", (int)time(NULL), (int)time(NULL), 0);
						fclose(fp);
					}
				}
				else
				{
					DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: creating budget-callbacksfile %s", current_cfe->name, yylval.str)));
					fp = fopen(yylval.str, "w");
					if(fp != NULL)
						fprintf(fp, "%d %d %d", (int)time(NULL), (int)time(NULL), 0);
					fclose(fp);
				}

				fp = fopen(yylval.str, "r");
				if(fp != NULL)
				{
					if((fscanf(fp, "%d %d %d", (int *)&s, (int *)&l, &n)) == 3)
					{
						if((current_cfe->budget_callbacks_file = malloc(strlen(yylval.str)+1)) == NULL)
						{
							logit(LL_ERR, "entry %s: budget-callbacksfile, malloc failed!", current_cfe->name);
							do_exit(1);
						}
						strcpy(current_cfe->budget_callbacks_file, yylval.str);
						DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: using callbacksfile %s", current_cfe->name, yylval.str)));
					}
					fclose(fp);
				}
			}
			break;

		case BUDGETCALLOUTSFILEROTATE:
			current_cfe->budget_calloutsfile_rotate = yylval.booln;
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: budget-calloutsfile-rotate = %d", current_cfe->name, yylval.booln)));
			break;

		case BUDGETCALLOUTSFILE:
			{
				FILE *fp;
				int s, l;
				int n;
				DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: budget-calloutsfile = %s", current_cfe->name, yylval.str)));
				fp = fopen(yylval.str, "r");
				if(fp != NULL)
				{
					if((fscanf(fp, "%d %d %d", (int *)&s, (int *)&l, &n)) != 3)
					{
						DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: initializing budget-calloutsfile %s", current_cfe->name, yylval.str)));
						fclose(fp);
						fp = fopen(yylval.str, "w");
						if(fp != NULL)
							fprintf(fp, "%d %d %d", (int)time(NULL), (int)time(NULL), 0);
						fclose(fp);
					}
				}
				else
				{
					DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: creating budget-calloutsfile %s", current_cfe->name, yylval.str)));
					fp = fopen(yylval.str, "w");
					if(fp != NULL)
						fprintf(fp, "%d %d %d", (int)time(NULL), (int)time(NULL), 0);
					fclose(fp);
				}

				fp = fopen(yylval.str, "r");
				if(fp != NULL)
				{
					if((fscanf(fp, "%d %d %d", (int *)&s, (int *)&l, &n)) == 3)
					{
						if((current_cfe->budget_callouts_file = malloc(strlen(yylval.str)+1)) == NULL)
						{
							logit(LL_ERR, "entry %s: budget-calloutsfile, malloc failed!", current_cfe->name);
							do_exit(1);
						}
						strcpy(current_cfe->budget_callouts_file, yylval.str);
						DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: using calloutsfile %s", current_cfe->name, yylval.str)));
					}
					fclose(fp);
				}
			}
			break;
		
		case CALLBACKWAIT:
			if(yylval.num < CALLBACKWAIT_MIN)
			{
				yylval.num = CALLBACKWAIT_MIN;
				DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: callbackwait < %d, min = %d", current_cfe->name, CALLBACKWAIT_MIN, yylval.num)));
			}

			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: callbackwait = %d", current_cfe->name, yylval.num)));
			current_cfe->callbackwait = yylval.num;
			break;
			
		case CALLEDBACKWAIT:
			if(yylval.num < CALLEDBACKWAIT_MIN)
			{
				yylval.num = CALLEDBACKWAIT_MIN;
				DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: calledbackwait < %d, min = %d", current_cfe->name, CALLEDBACKWAIT_MIN, yylval.num)));
			}

			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: calledbackwait = %d", current_cfe->name, yylval.num)));
			current_cfe->calledbackwait = yylval.num;
			break;

		case CONNECTPROG:
			if((current_cfe->connectprog = malloc(strlen(yylval.str)+1)) == NULL)
			{
				logit(LL_ERR, "entry %s: connectprog, malloc failed!", current_cfe->name);
				do_exit(1);
			}
			strcpy(current_cfe->connectprog, yylval.str);
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: connectprog = %s", current_cfe->name, yylval.str)));
			break;
			
		case DIALOUTTYPE:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: dialouttype = %s", current_cfe->name, yylval.str)));
			if(!(strcmp(yylval.str, "normal")))
				current_cfe->dialouttype = DIALOUT_NORMAL;
			else if(!(strcmp(yylval.str, "calledback")))
				current_cfe->dialouttype = DIALOUT_CALLEDBACK;
			else
			{
				logit(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"dialout-type\" at line %d!", lineno);
				config_error_flag++;
			}
			break;

		case DIALRETRIES:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: dialretries = %d", current_cfe->name, yylval.num)));
			current_cfe->dialretries = yylval.num;
			break;

		case DIALRANDINCR:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: dialrandincr = %d", current_cfe->name, yylval.booln)));
			current_cfe->dialrandincr = yylval.booln;
			break;

		case DIRECTION:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: direction = %s", current_cfe->name, yylval.str)));

			if(!(strcmp(yylval.str, "inout")))
				current_cfe->inout = DIR_INOUT;
			else if(!(strcmp(yylval.str, "in")))
				current_cfe->inout = DIR_INONLY;
			else if(!(strcmp(yylval.str, "out")))
				current_cfe->inout = DIR_OUTONLY;
			else
			{
				logit(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"direction\" at line %d!", lineno);
				config_error_flag++;
			}
			break;

		case DISCONNECTPROG:
			if((current_cfe->disconnectprog = malloc(strlen(yylval.str)+1)) == NULL)
			{
				logit(LL_ERR, "entry %s: disconnectprog, malloc failed!", current_cfe->name);
				do_exit(1);
			}
			strcpy(current_cfe->disconnectprog, yylval.str);
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: disconnectprog = %s", current_cfe->name, yylval.str)));
			break;

		case DOWNTRIES:
			if(yylval.num > DOWN_TRIES_MAX)
				yylval.num = DOWN_TRIES_MAX;
			else if(yylval.num < DOWN_TRIES_MIN)
				yylval.num = DOWN_TRIES_MIN;
		
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: downtries = %d", current_cfe->name, yylval.num)));
			current_cfe->downtries = yylval.num;
			break;

		case DOWNTIME:
			if(yylval.num > DOWN_TIME_MAX)
				yylval.num = DOWN_TIME_MAX;
			else if(yylval.num < DOWN_TIME_MIN)
				yylval.num = DOWN_TIME_MIN;
		
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: downtime = %d", current_cfe->name, yylval.num)));
			current_cfe->downtime = yylval.num;
			break;

		case EARLYHANGUP:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: earlyhangup = %d", current_cfe->name, yylval.num)));
			current_cfe->earlyhangup = yylval.num;
			break;

		case EXTCALLATTR:
			DBGL(DL_RCCF, (logit(LL_DBG, "system: extcallattr = %d", yylval.booln)));
			extcallattr = yylval.booln;
			break;

		case FIRMWARE:
			DBGL(DL_RCCF, (logit(LL_DBG, "controller %d: firmware = %s", cur_ctrl->isdnif, yylval.str)));
			cur_ctrl->firmware = strdup(yylval.str);
			break;

		case HOLIDAYFILE:
			strcpy(holidayfile, yylval.str);
			DBGL(DL_RCCF, (logit(LL_DBG, "system: holidayfile = %s", yylval.str)));
			break;

		case IDLE_ALG_OUT:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: idle-algorithm-outgoing = %s", current_cfe->name, yylval.str)));

			if(!(strcmp(yylval.str, "fix-unit-size")))
			{
				current_cfe->shorthold_algorithm = SHA_FIXU;
			}
			else if(!(strcmp(yylval.str, "var-unit-size")))
			{
				current_cfe->shorthold_algorithm = SHA_VARU;
			}
			else
			{
				logit(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"idle-algorithm-outgoing\" at line %d!", lineno);
				config_error_flag++;
			}
			break;

		case IDLETIME_IN:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: idle_time_in = %d", current_cfe->name, yylval.num)));
			current_cfe->idle_time_in = yylval.num;
			break;
			
		case IDLETIME_OUT:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: idle_time_out = %d", current_cfe->name, yylval.num)));
			current_cfe->idle_time_out = yylval.num;
			break;

		case ISDNCONTROLLER:
			current_cfe->isdncontroller = yylval.num;
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: isdncontroller = %d", current_cfe->name, yylval.num)));
			break;

		case ISDNCHANNEL:
			switch(yylval.num)
			{
				case 0:
				case -1:
					current_cfe->isdnchannel = CHAN_ANY;
					DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: isdnchannel = any", current_cfe->name)));
					break;
				case 1:
					current_cfe->isdnchannel = CHAN_B1;
					DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: isdnchannel = one", current_cfe->name)));
					break;
				case 2:
					current_cfe->isdnchannel = CHAN_B2;
					DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: isdnchannel = two", current_cfe->name)));
					break;
				default:
					logit(LL_DBG, "entry %s: isdnchannel value out of range", current_cfe->name);
					config_error_flag++;
					break;
			}
			break;

		case ISDNTIME:
			DBGL(DL_RCCF, (logit(LL_DBG, "system: isdntime = %d", yylval.booln)));
			isdntime = yylval.booln;
			break;

		case ISDNTXDELIN:
			current_cfe->isdntxdelin = yylval.num;
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: isdntxdel-incoming = %d", current_cfe->name, yylval.num)));
			break;

		case ISDNTXDELOUT:
			current_cfe->isdntxdelout = yylval.num;
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: isdntxdel-outgoing = %d", current_cfe->name, yylval.num)));
			break;

		case LOCAL_PHONE_DIALOUT:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: local_phone_dialout = %s", current_cfe->name, yylval.str)));
			strcpy(current_cfe->local_phone_dialout, yylval.str);
			break;

		case LOCAL_PHONE_INCOMING:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: local_phone_incoming = %s", current_cfe->name, yylval.str)));
			strcpy(current_cfe->local_phone_incoming, yylval.str);
			break;

		case MAILER:
			strcpy(mailer, yylval.str);
			DBGL(DL_RCCF, (logit(LL_DBG, "system: mailer = %s", yylval.str)));
			break;

		case MAILTO:
			strcpy(mailto, yylval.str);
			DBGL(DL_RCCF, (logit(LL_DBG, "system: mailto = %s", yylval.str)));
			break;

		case MONITORPORT:
			monitorport = yylval.num;
			DBGL(DL_RCCF, (logit(LL_DBG, "system: monitorport = %d", yylval.num)));
			break;

		case MONITORSW:
			if (yylval.booln && inhibit_monitor)
			{
				do_monitor = 0;
				DBGL(DL_RCCF, (logit(LL_DBG, "system: monitor-enable overriden by command line flag")));
			}
			else
			{
				do_monitor = yylval.booln;
				DBGL(DL_RCCF, (logit(LL_DBG, "system: monitor-enable = %d", yylval.booln)));
			}
			break;

		case NAME:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: name = %s", current_cfe->name, yylval.str)));
			strcpy(current_cfe->name, yylval.str);
			break;

		case PPP_AUTH_RECHALLENGE:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: ppp-auth-rechallenge = %d", current_cfe->name, yylval.booln)));
			if(yylval.booln)
				current_cfe->ppp_auth_flags |= AUTH_RECHALLENGE;
			else
				current_cfe->ppp_auth_flags &= ~AUTH_RECHALLENGE;
			break;

		case PPP_AUTH_PARANOID:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: ppp-auth-paranoid = %d", current_cfe->name, yylval.booln)));
			if(yylval.booln)
				current_cfe->ppp_auth_flags |= AUTH_REQUIRED;
			else
				current_cfe->ppp_auth_flags &= ~AUTH_REQUIRED;
			break;

		case PPP_EXPECT_AUTH:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: ppp-expect-auth = %s", current_cfe->name, yylval.str)));
			if(!(strcmp(yylval.str, "none")))
				current_cfe->ppp_expect_auth = AUTH_NONE;
			else if(!(strcmp(yylval.str, "pap")))
				current_cfe->ppp_expect_auth = AUTH_PAP;
			else if(!(strcmp(yylval.str, "chap")))
				current_cfe->ppp_expect_auth = AUTH_CHAP;
			else
			{
				logit(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"ppp-expect-auth\" at line %d!", lineno);
				config_error_flag++;
				break;
			}
			break;

		case PPP_EXPECT_NAME:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: ppp-expect-name = %s", current_cfe->name, yylval.str)));
			if (current_cfe->ppp_expect_name)
			    free(current_cfe->ppp_expect_name);
			current_cfe->ppp_expect_name = strdup(yylval.str);
			break;

		case PPP_EXPECT_PASSWORD:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: ppp-expect-password = %s", current_cfe->name, yylval.str)));
			if (current_cfe->ppp_expect_password)
			    free(current_cfe->ppp_expect_password);
			current_cfe->ppp_expect_password = strdup(yylval.str);
			break;

		case PPP_SEND_AUTH:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: ppp-send-auth = %s", current_cfe->name, yylval.str)));
			if(!(strcmp(yylval.str, "none")))
				current_cfe->ppp_send_auth = AUTH_NONE;
			else if(!(strcmp(yylval.str, "pap")))
				current_cfe->ppp_send_auth = AUTH_PAP;
			else if(!(strcmp(yylval.str, "chap")))
				current_cfe->ppp_send_auth = AUTH_CHAP;
			else
			{
				logit(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"ppp-send-auth\" at line %d!", lineno);
				config_error_flag++;
				break;
			}
			break;

		case PPP_SEND_NAME:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: ppp-send-name = %s", current_cfe->name, yylval.str)));
			if (current_cfe->ppp_send_name)
			    free(current_cfe->ppp_send_name);
			current_cfe->ppp_send_name = strdup(yylval.str);
			break;

		case PPP_SEND_PASSWORD:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: ppp-send-password = %s", current_cfe->name, yylval.str)));
			if (current_cfe->ppp_send_password)
			    free(current_cfe->ppp_send_password);
			current_cfe->ppp_send_password = strdup(yylval.str);
			break;

		case PROTOCOL:
			DBGL(DL_RCCF, (logit(LL_DBG, "controller %d: protocol = %s", cur_ctrl->isdnif, yylval.str)));
			if(!(strcmp(yylval.str, "dss1")))
				cur_ctrl->protocol = PROTOCOL_DSS1;
			else if(!(strcmp(yylval.str, "d64s")))
				cur_ctrl->protocol = PROTOCOL_D64S;
			else
			{
				logit(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"protocol\" at line %d!", lineno);
				config_error_flag++;
			}
			break;

		case REACTION:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: dialin_reaction = %s", current_cfe->name, yylval.str)));
			if(!(strcmp(yylval.str, "accept")))
				current_cfe->dialin_reaction = REACT_ACCEPT;
			else if(!(strcmp(yylval.str, "reject")))
				current_cfe->dialin_reaction = REACT_REJECT;
			else if(!(strcmp(yylval.str, "ignore")))
				current_cfe->dialin_reaction = REACT_IGNORE;
			else if(!(strcmp(yylval.str, "answer")))
				current_cfe->dialin_reaction = REACT_ANSWER;
			else if(!(strcmp(yylval.str, "callback")))
				current_cfe->dialin_reaction = REACT_CALLBACK;
			else
			{
				logit(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"dialin_reaction\" at line %d!", lineno);
				config_error_flag++;
			}
			break;

		case REMOTE_PHONE_DIALOUT:
			if(current_cfe->remote_numbers_count >= MAXRNUMBERS)
			{
				logit(LL_ERR, "ERROR parsing config file: too many remote numbers at line %d!", lineno);
				config_error_flag++;
				break;
			}				
			
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: remote_phone_dialout #%d = %s",
				current_cfe->name, current_cfe->remote_numbers_count, yylval.str)));

			strcpy(current_cfe->remote_numbers[current_cfe->remote_numbers_count].number, yylval.str);
			current_cfe->remote_numbers[current_cfe->remote_numbers_count].flag = 0;

			current_cfe->remote_numbers_count++;
			
			break;

		case REMOTE_NUMBERS_HANDLING:			
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: remdial_handling = %s", current_cfe->name, yylval.str)));
			if(!(strcmp(yylval.str, "next")))
				current_cfe->remote_numbers_handling = RNH_NEXT;
			else if(!(strcmp(yylval.str, "last")))
				current_cfe->remote_numbers_handling = RNH_LAST;
			else if(!(strcmp(yylval.str, "first")))
				current_cfe->remote_numbers_handling = RNH_FIRST;
			else
			{
				logit(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"remdial_handling\" at line %d!", lineno);
				config_error_flag++;
			}
			break;

		case REMOTE_PHONE_INCOMING:
			{
				int n;
				n = current_cfe->incoming_numbers_count;
				if (n >= MAX_INCOMING)
				{
					logit(LL_ERR, "ERROR parsing config file: too many \"remote_phone_incoming\" entries at line %d!", lineno);
					config_error_flag++;
					break;
				}
				DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: remote_phone_incoming #%d = %s", current_cfe->name, n, yylval.str)));
				strcpy(current_cfe->remote_phone_incoming[n].number, yylval.str);
				current_cfe->incoming_numbers_count++;
			}
			break;

		case RATESFILE:
			strcpy(ratesfile, yylval.str);
			DBGL(DL_RCCF, (logit(LL_DBG, "system: ratesfile = %s", yylval.str)));
			break;

		case RATETYPE:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: ratetype = %d", current_cfe->name, yylval.num)));
			current_cfe->ratetype = yylval.num;
			break;
		
		case RECOVERYTIME:
			if(yylval.num < RECOVERYTIME_MIN)
			{
				yylval.num = RECOVERYTIME_MIN;
				DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: recoverytime < %d, min = %d", current_cfe->name, RECOVERYTIME_MIN, yylval.num)));
			}

			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: recoverytime = %d", current_cfe->name, yylval.num)));
			current_cfe->recoverytime = yylval.num;
			break;
		
		case REGEXPR:
			if(nregexpr >= MAX_RE)
			{
				logit(LL_ERR, "system: regexpr #%d >= MAX_RE", nregexpr);
				config_error_flag++;
				break;
			}

			if((i = regcomp(&(rarr[nregexpr].re), yylval.str, REG_EXTENDED|REG_NOSUB)) != 0)
		        {
                		char buf[256];
                		regerror(i, &(rarr[nregexpr].re), buf, sizeof(buf));
				logit(LL_ERR, "system: regcomp error for %s: [%s]", yylval.str, buf);
				config_error_flag++;
                		break;
			}
			else
			{
				if((rarr[nregexpr].re_expr = malloc(strlen(yylval.str)+1)) == NULL)
				{
					logit(LL_ERR, "system: regexpr malloc error error for %s", yylval.str);
					config_error_flag++;
					break;
				}
				strcpy(rarr[nregexpr].re_expr, yylval.str);

				DBGL(DL_RCCF, (logit(LL_DBG, "system: regexpr %s stored into slot %d", yylval.str, nregexpr)));
				
				if(rarr[nregexpr].re_prog != NULL)
					rarr[nregexpr].re_flg = 1;
				
				nregexpr++;
				
			}
			break;

		case REGPROG:
			if(nregprog >= MAX_RE)
			{
				logit(LL_ERR, "system: regprog #%d >= MAX_RE", nregprog);
				config_error_flag++;
				break;
			}
			if((rarr[nregprog].re_prog = malloc(strlen(yylval.str)+1)) == NULL)
			{
				logit(LL_ERR, "system: regprog malloc error error for %s", yylval.str);
				config_error_flag++;
				break;
			}
			strcpy(rarr[nregprog].re_prog, yylval.str);

			DBGL(DL_RCCF, (logit(LL_DBG, "system: regprog %s stored into slot %d", yylval.str, nregprog)));
			
			if(rarr[nregprog].re_expr != NULL)
				rarr[nregprog].re_flg = 1;

			nregprog++;
			break;

		case ROTATESUFFIX:
			strcpy(rotatesuffix, yylval.str);
			DBGL(DL_RCCF, (logit(LL_DBG, "system: rotatesuffix = %s", yylval.str)));
			break;

		case RTPRIO:
#ifdef USE_RTPRIO
			rt_prio = yylval.num;
			if(rt_prio < RTP_PRIO_MIN || rt_prio > RTP_PRIO_MAX)
			{
				config_error_flag++;
				logit(LL_ERR, "system: error, rtprio (%d) out of range!", yylval.num);
			}
			else
			{
				DBGL(DL_RCCF, (logit(LL_DBG, "system: rtprio = %d", yylval.num)));
			}
#else
			rt_prio = RTPRIO_NOTUSED;
#endif
			break;

		case TINAINITPROG:
			strcpy(tinainitprog, yylval.str);
			DBGL(DL_RCCF, (logit(LL_DBG, "system: tinainitprog = %s", yylval.str)));
			break;

		case UNITLENGTH:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: unitlength = %d", current_cfe->name, yylval.num)));
			current_cfe->unitlength = yylval.num;
			break;

		case UNITLENGTHSRC:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: unitlengthsrc = %s", current_cfe->name, yylval.str)));
			if(!(strcmp(yylval.str, "none")))
				current_cfe->unitlengthsrc = ULSRC_NONE;
			else if(!(strcmp(yylval.str, "cmdl")))
				current_cfe->unitlengthsrc = ULSRC_CMDL;
			else if(!(strcmp(yylval.str, "conf")))
				current_cfe->unitlengthsrc = ULSRC_CONF;
			else if(!(strcmp(yylval.str, "rate")))
				current_cfe->unitlengthsrc = ULSRC_RATE;
			else if(!(strcmp(yylval.str, "aocd")))
				current_cfe->unitlengthsrc = ULSRC_DYN;
			else
			{
				logit(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"unitlengthsrc\" at line %d!", lineno);
				config_error_flag++;
			}
			break;

		case USRDEVICENAME:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: usrdevicename = %s", current_cfe->name, yylval.str)));
			strncpy(current_cfe->usrdevicename, yylval.str, sizeof(current_cfe->usrdevicename));
			current_cfe->usrdevice = lookup_l4_driver(yylval.str);
			if (current_cfe->usrdevice < 0)
			{
				logit(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"usrdevicename\" at line %d!", lineno);
				config_error_flag++;
			}
			break;

		case USRDEVICEUNIT:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: usrdeviceunit = %d", current_cfe->name, yylval.num)));
			current_cfe->usrdeviceunit = yylval.num;
			break;

		case USEACCTFILE:
			useacctfile = yylval.booln;
			DBGL(DL_RCCF, (logit(LL_DBG, "system: useacctfile = %d", yylval.booln)));
			break;

		case USEDOWN:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: usedown = %d", current_cfe->name, yylval.booln)));
			current_cfe->usedown = yylval.booln;
			break;

		case VALID:
			DBGL(DL_RCCF, (logit(LL_DBG, "entry %s: valid = %s", current_cfe->name, yylval.str)));
			parse_valid(yylval.str);
			break;

		default:
			logit(LL_ERR, "ERROR parsing config file: unknown keyword at line %d!", lineno);
			config_error_flag++;
			break;			
	}
}

/*---------------------------------------------------------------------------*
 *	parse a date/time range
 *---------------------------------------------------------------------------*/
static void
parse_valid(char *dt)
{
	/* a valid string consists of some days of week separated by
	 * commas, where 0=sunday, 1=monday .. 6=saturday and a special
	 * value of 7 which is a holiday from the holiday file.
	 * after the days comes an optional (!) time range in the form
	 * aa:bb-cc:dd, this format is fixed to be parsable by sscanf.
	 * Valid specifications looks like this:
	 * 1,2,3,4,5,09:00-18:00	Monday-Friday 9-18h
	 * 1,2,3,4,5,18:00-09:00	Monday-Friday 18-9h
	 * 6				Saturday (whole day)
	 * 0,7				Sunday and Holidays
	 */

	int day = 0;
	int fromhr = 0;
	int frommin = 0;
	int tohr = 0;
	int tomin = 0;
	int ret;
	
	for(;;)
	{
		if( ( ((*dt >= '0') && (*dt <= '9')) && (*(dt+1) == ':') ) ||
		    ( ((*dt >= '0') && (*dt <= '2')) && ((*(dt+1) >= '0') && (*(dt+1) <= '9')) && (*(dt+2) == ':') ) )
		{
			/* dt points to time spec */
			ret = sscanf(dt, "%d:%d-%d:%d", &fromhr, &frommin, &tohr, &tomin);
			if(ret !=4)
			{
				logit(LL_ERR, "ERROR parsing config file: timespec [%s] error at line %d!", *dt, lineno);
				config_error_flag++;
				return;
			}

			if(fromhr < 0 || fromhr > 24 || tohr < 0 || tohr > 24 ||
			   frommin < 0 || frommin > 59 || tomin < 0 || tomin > 59)
			{
				logit(LL_ERR, "ERROR parsing config file: invalid time [%s] at line %d!", *dt, lineno);
				config_error_flag++;
				return;
			}
			break;
		}
		else if ((*dt >= '0') && (*dt <= '7'))
		{
			/* dt points to day spec */
			day |= 1 << (*dt - '0');
			dt++;
			continue;
		}
		else if (*dt == ',')
		{
			/* dt points to delimiter */
			dt++;
			continue;
		}
		else if (*dt == '\0')
		{
			/* dt points to end of string */
			break;
		}
		else
		{
			/* dt points to illegal character */
			logit(LL_ERR, "ERROR parsing config file: illegal character [%c=0x%x] in date/time spec at line %d!", *dt, *dt, lineno);
			config_error_flag++;
			return;
		}
	}
	current_cfe->day = day;
	current_cfe->fromhr = fromhr;
	current_cfe->frommin = frommin;
	current_cfe->tohr = tohr;
	current_cfe->tomin = tomin;
}

void
flush_config()
{
	if (current_cfe != NULL) {
		add_cfg_entry(current_cfe);
	}
}

/*---------------------------------------------------------------------------*
 *	configuration validation and consistency check
 *---------------------------------------------------------------------------*/
static void
check_config(void)
{
	struct cfg_entry *cep = NULL;
	int i;
	int error = 0;

	/* regular expression table */
	
	for(i=0; i < MAX_RE; i++)
	{
		if((rarr[i].re_expr != NULL) && (rarr[i].re_prog == NULL))
		{
			logit(LL_ERR, "check_config: regular expression %d without program!", i);
			error++;
		}
		if((rarr[i].re_prog != NULL) && (rarr[i].re_expr == NULL))
		{
			logit(LL_ERR, "check_config: regular expression program %d without expression!", i);
			error++;
		}
	}

	/* entry sections */
	
	for (cep = get_first_cfg_entry(); cep; cep = NEXT_CFE(cep)) {

		/* numbers used for dialout */
		
		if((cep->inout != DIR_INONLY) && (cep->dialin_reaction != REACT_ANSWER))
		{
			if(cep->remote_numbers_count == 0)
			{
				logit(LL_ERR, "check_config: remote-phone-dialout not set in entry %d!", i);
				error++;
			}
			if(strlen(cep->local_phone_dialout) == 0)
			{
				logit(LL_ERR, "check_config: local-phone-dialout not set in entry %d!", i);
				error++;
			}
		}

		/* numbers used for incoming calls */
		
		if(cep->inout != DIR_OUTONLY)
		{
			if(strlen(cep->local_phone_incoming) == 0)
			{
				logit(LL_ERR, "check_config: local-phone-incoming not set in entry %d!", i);
				error++;
			}
			if(cep->incoming_numbers_count == 0)
			{
				logit(LL_ERR, "check_config: remote-phone-incoming not set in entry %d!", i);
				error++;
			}
		}

		if((cep->dialin_reaction == REACT_ANSWER) && (cep->b1protocol != BPROT_NONE))
		{
			logit(LL_ERR, "check_config: b1protocol not raw for telephony in entry %d!", i);
			error++;
		}

		if((cep->ppp_send_auth == AUTH_PAP) || (cep->ppp_send_auth == AUTH_CHAP))
		{
			if(cep->ppp_send_name == NULL)
			{
				logit(LL_ERR, "check_config: no remote authentification name in entry %d!", i);
				error++;
			}
			if(cep->ppp_send_password == NULL)
			{
				logit(LL_ERR, "check_config: no remote authentification password in entry %d!", i);
				error++;
			}
		}
		if((cep->ppp_expect_auth == AUTH_PAP) || (cep->ppp_expect_auth == AUTH_CHAP))
		{
			if(cep->ppp_expect_name == NULL)
			{
				logit(LL_ERR, "check_config: no local authentification name in entry %d!", i);
				error++;
			}
			if(cep->ppp_expect_password == NULL)
			{
				logit(LL_ERR, "check_config: no local authentification secret in entry %d!", i);
				error++;
			}
		}

//		if(cep->ppp_expect_auth != AUTH_UNDEF 
//		   || cep->ppp_send_auth != AUTH_UNDEF)
//			set_isppp_auth(cep);

		/*
		 * Only if AUTOUPDOWN_YES is the only bit set, otherwise
		 * we already have handled this interface.
		 */
		if (cep->autoupdown == AUTOUPDOWN_YES)
			set_autoupdown(cep);
	}
	if (error) {
		logit(LL_ERR, "check_config: %d error(s) in configuration file, exit!", error);
		do_exit(1);
	}
}

/*---------------------------------------------------------------------------*
 *	print the configuration
 *---------------------------------------------------------------------------*/
static void
print_config(void)
{
#define PFILE stdout

#ifdef I4B_EXTERNAL_MONITOR
	extern struct monitor_rights * monitor_next_rights(const struct monitor_rights *r);
	struct monitor_rights *m_rights;
#endif
	struct cfg_entry *cep = NULL;
	int i, j;
	time_t clock;
	char mytime[64];

	time(&clock);
	strcpy(mytime, ctime(&clock));
	mytime[strlen(mytime)-1] = '\0';

	fprintf(PFILE, "#---------------------------------------------------------------------------\n");
	fprintf(PFILE, "# system section (generated %s)\n", mytime);
	fprintf(PFILE, "#---------------------------------------------------------------------------\n");
	fprintf(PFILE, "system\n");
	fprintf(PFILE, "useacctfile     = %s\n", useacctfile ? "on\t\t\t\t# update accounting information file" : "off\t\t\t\t# don't update accounting information file");
	fprintf(PFILE, "acctall         = %s\n", acct_all ? "on\t\t\t\t# put all events into accounting file" : "off\t\t\t\t# put only charged events into accounting file");
	fprintf(PFILE, "acctfile        = %s\t\t# accounting information file\n", acctfile);
	fprintf(PFILE, "ratesfile       = %s\t\t# charging rates database file\n", ratesfile);

#ifdef USE_RTPRIO
	if(rt_prio == RTPRIO_NOTUSED)
		fprintf(PFILE, "# rtprio is unused\n");
	else
		fprintf(PFILE, "rtprio          = %d\t\t\t\t# isdnd runs at realtime priority\n", rt_prio);
#endif

	/* regular expression table */
	
	for(i=0; i < MAX_RE; i++)
	{
		if(rarr[i].re_expr != NULL)
		{
			fprintf(PFILE, "regexpr         = \"%s\"\t\t# scan logfile for this expression\n", rarr[i].re_expr);
		}
		if(rarr[i].re_prog != NULL)
		{
			fprintf(PFILE, "regprog         = %s\t\t# program to run when expression is matched\n", rarr[i].re_prog);
		}
	}

#ifdef I4B_EXTERNAL_MONITOR

	fprintf(PFILE, "monitor-allowed = %s\n", do_monitor ? "on\t\t\t\t# remote isdnd monitoring allowed" : "off\t\t\t\t# remote isdnd monitoring disabled");
	fprintf(PFILE, "monitor-port    = %d\t\t\t\t# TCP/IP port number used for remote monitoring\n", monitorport);

	m_rights = monitor_next_rights(NULL);
	if(m_rights != NULL)
	{
		char *s = "error\n";
		char b[512];

		for ( ; m_rights != NULL; m_rights = monitor_next_rights(m_rights))
		{
			if(m_rights->local)
			{
				fprintf(PFILE, "monitor         = \"%s\"\t\t# local socket name for monitoring\n", m_rights->name);
			}
			else
			{
				struct in_addr ia;
				ia.s_addr = ntohl(m_rights->net);

				switch(m_rights->mask)
				{
					case 0xffffffff:
						s = "32";
						break;
					case 0xfffffffe:
						s = "31";
						break;
					case 0xfffffffc:
						s = "30";
						break;
					case 0xfffffff8:
						s = "29";
						break;
					case 0xfffffff0:
						s = "28";
						break;
					case 0xffffffe0:
						s = "27";
						break;
					case 0xffffffc0:
						s = "26";
						break;
					case 0xffffff80:
						s = "25";
						break;
					case 0xffffff00:
						s = "24";
						break;
					case 0xfffffe00:
						s = "23";
						break;
					case 0xfffffc00:
						s = "22";
						break;
					case 0xfffff800:
						s = "21";
						break;
					case 0xfffff000:
						s = "20";
						break;
					case 0xffffe000:
						s = "19";
						break;
					case 0xffffc000:
						s = "18";
						break;
					case 0xffff8000:
						s = "17";
						break;
					case 0xffff0000:
						s = "16";
						break;
					case 0xfffe0000:
						s = "15";
						break;
					case 0xfffc0000:
						s = "14";
						break;
					case 0xfff80000:
						s = "13";
						break;
					case 0xfff00000:
						s = "12";
						break;
					case 0xffe00000:
						s = "11";
						break;
					case 0xffc00000:
						s = "10";
						break;
					case 0xff800000:
						s = "9";
						break;
					case 0xff000000:
						s = "8";
						break;
					case 0xfe000000:
						s = "7";
						break;
					case 0xfc000000:
						s = "6";
						break;
					case 0xf8000000:
						s = "5";
						break;
					case 0xf0000000:
						s = "4";
						break;
					case 0xe0000000:
						s = "3";
						break;
					case 0xc0000000:
						s = "2";
						break;
					case 0x80000000:
						s = "1";
						break;
					case 0x00000000:
						s = "0";
						break;
				}
				fprintf(PFILE, "monitor         = \"%s/%s\"\t\t# host (net/mask) allowed to connect for monitoring\n", inet_ntoa(ia), s);
			}
			b[0] = '\0';
			
			if((m_rights->rights) & I4B_CA_COMMAND_FULL)
				strcat(b, "fullcmd,");
			if((m_rights->rights) & I4B_CA_COMMAND_RESTRICTED)
				strcat(b, "restrictedcmd,");
			if((m_rights->rights) & I4B_CA_EVNT_CHANSTATE)
				strcat(b, "channelstate,");
			if((m_rights->rights) & I4B_CA_EVNT_CALLIN)
				strcat(b, "callin,");
			if((m_rights->rights) & I4B_CA_EVNT_CALLOUT)
				strcat(b, "callout,");
			if((m_rights->rights) & I4B_CA_EVNT_I4B)
				strcat(b, "logevents,");

			if(b[strlen(b)-1] == ',')
				b[strlen(b)-1] = '\0';
				
			fprintf(PFILE, "monitor-access  = %s\t\t# monitor access rights\n", b);
		}
	}
	
#endif
	/* entry sections */
	
	for (cep = get_first_cfg_entry(); cep; cep = NEXT_CFE(cep)) {
		fprintf(PFILE, "\n");
		fprintf(PFILE, "#---------------------------------------------------------------------------\n");
		fprintf(PFILE, "# entry section %d\n", i);
		fprintf(PFILE, "#---------------------------------------------------------------------------\n");
		fprintf(PFILE, "entry\n");

		fprintf(PFILE, "name                  = %s\t\t# name for this entry section\n", cep->name);

		fprintf(PFILE, "isdncontroller        = %d\t\t# ISDN card number used for this entry\n", cep->isdncontroller);
		fprintf(PFILE, "isdnchannel           = ");
		switch(cep->isdnchannel)
		{
				case CHAN_ANY:
					fprintf(PFILE, "-1\t\t# any ISDN B-channel may be used\n");
					break;
				case CHAN_B1:
					fprintf(PFILE, "1\t\t# only ISDN B-channel 1 may be used\n");
					break;
				case CHAN_B2:
					fprintf(PFILE, "2\t\t# only ISDN B-channel 2 ay be used\n");
					break;
		}

		fprintf(PFILE, "usrdevicename         = %s\t\t# name of userland ISDN B-channel device\n", cep->usrdevicename);
		fprintf(PFILE, "usrdeviceunit         = %d\t\t# unit number of userland ISDN B-channel device\n", cep->usrdeviceunit);

		fprintf(PFILE, "b1protocol            = %s\n", cep->b1protocol ? "hdlc\t\t# B-channel layer 1 protocol is HDLC" : "raw\t\t# No B-channel layer 1 protocol used");

		fprintf(PFILE, "direction             = ");
		switch(cep->inout)
		{
			case DIR_INONLY:
				fprintf(PFILE, "in\t\t# only incoming connections allowed\n");
				break;
			case DIR_OUTONLY:
				fprintf(PFILE, "out\t\t# only outgoing connections allowed\n");
				break;
			case DIR_INOUT:
				fprintf(PFILE, "inout\t\t# incoming and outgoing connections allowed\n");
				break;
		}
		
		if(cep->remote_numbers_count > 1)
		{
			for(j=0; j<cep->remote_numbers_count; j++)
				fprintf(PFILE, "remote-phone-dialout  = %s\t\t# telephone number %d for dialing out to remote\n", cep->remote_numbers[j].number, j+1);

				fprintf(PFILE, "remdial-handling      = ");
	
				switch(cep->remote_numbers_handling)
				{
					case RNH_NEXT:
						fprintf(PFILE, "next\t\t# use next number after last successful for new dial\n");
						break;
					case RNH_LAST:
						fprintf(PFILE, "last\t\t# use last successful number for new dial\n");
						break;
					case RNH_FIRST:
						fprintf(PFILE, "first\t\t# always start with first number for new dial\n");
						break;
				}
			}

			fprintf(PFILE, "local-phone-dialout   = %s\t\t# show this number to remote when dialling out\n", cep->local_phone_dialout);
			fprintf(PFILE, "dialout-type          = %s\n", cep->dialouttype ? "calledback\t\t# i am called back by remote" : "normal\t\t# i am not called back by remote");
		}

		if(!(cep->inout == DIR_OUTONLY))
		{
			int n;
			
			fprintf(PFILE, "local-phone-incoming  = %s\t\t# incoming calls must match this (mine) telephone number\n", cep->local_phone_incoming);
			for (n = 0; n < cep->incoming_numbers_count; n++)
				fprintf(PFILE, "remote-phone-incoming = %s\t\t# this is a valid remote number to call me\n",
					cep->remote_phone_incoming[n].number);

			fprintf(PFILE, "dialin-reaction       = ");
			switch(cep->dialin_reaction)
			{
				case REACT_ACCEPT:
					fprintf(PFILE, "accept\t\t# i accept a call from remote and connect\n");
					break;
				case REACT_REJECT:
					fprintf(PFILE, "reject\t\t# i reject the call from remote\n");
					break;
				case REACT_IGNORE:
					fprintf(PFILE, "ignore\t\t# i ignore the call from remote\n");
					break;
				case REACT_ANSWER:
					fprintf(PFILE, "answer\t\t# i will start telephone answering when remote calls in\n");
					break;
				case REACT_CALLBACK:
					fprintf(PFILE, "callback\t\t# when remote calls in, i will hangup and call back\n");
					break;
			}
		}

		{
			char *s;
			switch(cep->ppp_expect_auth)
			{
				case AUTH_NONE:
					s = "none";
					break;
				case AUTH_PAP:
					s = "pap";
					break;
				case AUTH_CHAP:
					s = "chap";
					break;
				default:
					s = NULL;
					break;
			}
			if(s != NULL)
			{
				fprintf(PFILE, "ppp-expect-auth       = %s\t\t# the auth protocol we expect to receive on dial-in (none,pap,chap)\n", s);
				if(cep->ppp_expect_auth != AUTH_NONE)
				{
					fprintf(PFILE, "ppp-expect-name       = %s\t\t# the user name allowed in\n", cep->ppp_expect_name);
					fprintf(PFILE, "ppp-expect-password   = %s\t\t# the key expected from the other side\n", cep->ppp_expect_password);
					fprintf(PFILE, "ppp-auth-paranoid     = %s\t\t# do we require remote to authenticate even if we dial out\n", cep->ppp_auth_flags & AUTH_REQUIRED ? "yes" : "no");
				}
			}
			switch(cep->ppp_send_auth)
			{
				case AUTH_NONE:
					s = "none";
					break;
				case AUTH_PAP:
					s = "pap";
					break;
				case AUTH_CHAP:
					s = "chap";
					break;
				default:
					s = NULL;
					break;
			}
			if(s != NULL)
			{
				fprintf(PFILE, "ppp-send-auth         = %s\t\t# the auth protocol we use when dialing out (none,pap,chap)\n", s);
				if(cep->ppp_send_auth != AUTH_NONE)
				{
					fprintf(PFILE, "ppp-send-name         = %s\t\t# our PPP account used for dial-out\n", cep->ppp_send_name);
					fprintf(PFILE, "ppp-send-password     = %s\t\t# the key sent to the other side\n", cep->ppp_send_password);
				}
			}
			if(cep->ppp_send_auth == AUTH_CHAP ||
			   cep->ppp_expect_auth == AUTH_CHAP) {
				fprintf(PFILE, "ppp-auth-rechallenge   = %s\t\t# rechallenge CHAP connections once in a while\n", cep->ppp_auth_flags & AUTH_RECHALLENGE ? "yes" : "no");
			}
		}

		if (cep->autoupdown == AUTOUPDOWN_NO)
			fprintf(PFILE, "autoupdown = no\n");

		{
			char *s;
			fprintf(PFILE, "idletime-outgoing     = %d\t\t# outgoing call idle timeout\n", cep->idle_time_out);

			switch( cep->shorthold_algorithm )
			{
				case SHA_FIXU:
					s = "fix-unit-size";
					break;
				case SHA_VARU:
					s = "var-unit-size";
					break;
				default:
					s = "error!!!";
					break;
			}

			fprintf(PFILE, "idle-algorithm-outgoing     = %s\t\t# outgoing call idle algorithm\n", s);
		}

		if(!(cep->inout == DIR_OUTONLY))
			fprintf(PFILE, "idletime-incoming     = %d\t\t# incoming call idle timeout\n", cep->idle_time_in);

		{		
	 		fprintf(PFILE, "unitlengthsrc         = ");
			switch(cep->unitlengthsrc)
			{
				case ULSRC_NONE:
					fprintf(PFILE, "none\t\t# no unit length specified, using default\n");
					break;
				case ULSRC_CMDL:
					fprintf(PFILE, "cmdl\t\t# using unit length specified on commandline\n");
					break;
				case ULSRC_CONF:
					fprintf(PFILE, "conf\t\t# using unitlength specified by unitlength-keyword\n");
					fprintf(PFILE, "unitlength            = %d\t\t# fixed unitlength\n", cep->unitlength);
					break;
				case ULSRC_RATE:
					fprintf(PFILE, "rate\t\t# using unitlength specified in rate database\n");
					fprintf(PFILE, "ratetype              = %d\t\t# type of rate from rate database\n", cep->ratetype);
					break;
				case ULSRC_DYN:
					fprintf(PFILE, "aocd\t\t# using dynamically calculated unitlength based on AOCD subscription\n");
					fprintf(PFILE, "ratetype              = %d\t\t# type of rate from rate database\n", cep->ratetype);
					break;
			}

			fprintf(PFILE, "earlyhangup           = %d\t\t# early hangup safety time\n", cep->earlyhangup);

		}
		
		{
			fprintf(PFILE, "answerprog            = %s\t\t# program used to answer incoming telephone calls\n", cep->answerprog);
			fprintf(PFILE, "alert                 = %d\t\t# number of seconds to wait before accepting a call\n", cep->alert);
		}

		{		
			if(cep->dialin_reaction == REACT_CALLBACK)
				fprintf(PFILE, "callbackwait          = %d\t\t# i am waiting this time before calling back remote\n", cep->callbackwait);
	
			if(cep->dialouttype == DIALOUT_CALLEDBACK)
				fprintf(PFILE, "calledbackwait        = %d\t\t# i am waiting this time for a call back from remote\n", cep->calledbackwait);
	
			if(!(cep->inout == DIR_INONLY))
			{
				fprintf(PFILE, "dialretries           = %d\t\t# number of dialing retries\n", cep->dialretries);
				fprintf(PFILE, "recoverytime          = %d\t\t# time to wait between dialling retries\n", cep->recoverytime);
				fprintf(PFILE, "dialrandincr          = %s\t\t# use random dialing time addon\n", cep->dialrandincr ? "on" : "off");

				fprintf(PFILE, "usedown               = %s\n", cep->usedown ? "on\t\t# ISDN device switched off on excessive dial failures" : "off\t\t# no device switchoff on excessive dial failures");
				if(cep->usedown)
				{
					fprintf(PFILE, "downtries             = %d\t\t# number of dialretries failures before switching off\n", cep->downtries);
					fprintf(PFILE, "downtime              = %d\t\t# time device is switched off\n", cep->downtime);
				}
			}
	}
	fprintf(PFILE, "\n");	
}

static int
lookup_l4_driver(const char *name)
{
	msg_l4driver_lookup_t query;
	int e;

	memset(&query, 0, sizeof query);
	strncpy(query.name, name, sizeof query.name);
	e = ioctl(isdnfd, I4B_L4DRIVER_LOOKUP, &query);
	if (e != 0) return -1;
	return query.driver_id;
}

@


1.4
log
@- Sync isdnd with NetBSD (adds load firmware capability)
- Make ppp portable (ifdefing) again
@
text
@d1 1
a1 1
/*	$MirBSD: rc_config.c,v 1.3 2003/05/15 16:19:44 tg Exp $	*/
d663 1
a663 1
			DBGL(DL_RCCF, (logit(LL_DBG, "controller %d: firmware = %s", cur_ctrl->bri, yylval.str)));
d863 1
a863 1
			DBGL(DL_RCCF, (logit(LL_DBG, "controller %d: protocol = %s", cur_ctrl->bri, yylval.str)));
@


1.3
log
@callout -> timeout
add RCS Id
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
d660 5
@


1.2
log
@pull in the remaining ISDN man pages and the daemon from NetBSD,
replacing the postcard-ware ones

I still think it's okay to send Hellmuth a postcard, though.
@
text
@d1 1
d44 1
a44 1
#include <sys/callout.h>
@


1.1
log
@Import ISDN (i4b) into MirBSD
Done:
 - kernel support
 - (commented out) entries in GENERIC
 - MAKEDEV file with licence issues
 - isdnd

Not done:
 - testing
 - configuration files

Not planned:
 - more stuff from i4b (voicemail, fax, etc)
@
text
@d1 2
a2 2
/* $MirBSD$
 * Copyright (c) 1997, 1999 Hellmuth Michaelis. All rights reserved.
d30 1
a30 1
 *	_Id: rc_config.c,v 1.48 1999/12/07 10:56:05 hm Exp $ 
d32 3
a34 1
 *      last edit-date: [Tue Dec  7 11:36:05 1999]
d43 4
d48 1
a48 1
#include "y.tab.h"
a51 2
extern int entrycount;
extern int controllercount;
d56 1
a56 1
extern int yyparse();
d61 6
d70 2
d88 1
d90 1
a90 1
	
d93 1
a93 1
		log(LL_ERR, "cannot fopen file [%s]", filename);
d109 1
a109 1
			log(LL_ERR, "there were %d error(s) in the configuration file, terminating!", config_error_flag);
d123 1
a123 1
	log(LL_ERR, "configuration error: %s at line %d, token \"%s\"", msg, lineno+1, yytext);
d127 39
a171 1
	cfg_entry_t *cep = &cfg_entry_tab[0];	/* ptr to config entry */
d175 1
a175 1
	
d181 2
a182 2
	mailto[0] = '\0';	
	
d184 1
a184 1
	
d190 1
a190 1
		
d199 14
a212 1
	
d214 2
a215 2
	 * controller table cleanup, beware: has already
	 * been setup in main, init_controller() !
d217 16
a232 5
	
	for(i=0; i < ncontroller; i++)
	{
		isdn_ctrl_tab[i].protocol = PROTOCOL_DSS1;
	}
d234 2
a235 5
	/* entry section cleanup */
	
	for(i=0; i < CFG_ENTRY_MAX; i++, cep++)
	{
		bzero(cep, sizeof(cfg_entry_t));
d237 8
a244 1
		/* ====== filled in at startup configuration, then static */
d246 2
a247 1
		sprintf(cep->name, "ENTRY%d", i);	
d249 39
a287 2
		cep->isdncontroller = INVALID;
		cep->isdnchannel = CHAN_ANY;
d289 40
a328 4
		cep->usrdevicename = INVALID;
		cep->usrdeviceunit = INVALID;
		
		cep->remote_numbers_handling = RNH_LAST;
d330 4
a333 1
		cep->dialin_reaction = REACT_IGNORE;
d335 6
a340 1
		cep->b1protocol = BPROT_NONE;
d342 5
a346 41
		cep->unitlength = UNITLENGTH_DEFAULT;

		cep->earlyhangup = EARLYHANGUP_DEFAULT;
		
		cep->ratetype = INVALID_RATE;
		
	 	cep->unitlengthsrc = ULSRC_NONE;

		cep->answerprog = ANSWERPROG_DEF;	 	

		cep->callbackwait = CALLBACKWAIT_MIN;

		cep->calledbackwait = CALLEDBACKWAIT_MIN;		

		cep->dialretries = DIALRETRIES_DEF;

		cep->recoverytime = RECOVERYTIME_MIN;
	
		cep->dialouttype = DIALOUT_NORMAL;
		
		cep->inout = DIR_INOUT;
		
		/* ======== filled in after start, then dynamic */

		cep->cdid = CDID_UNUSED;

		cep->state = ST_IDLE;

		cep->aoc_valid = AOC_INVALID;
 	}
}

/*---------------------------------------------------------------------------*
 *	internaly set values for ommitted controler sectin
 *---------------------------------------------------------------------------*/
void
cfg_set_controller_default()
{
	controllercount = 0;
	DBGL(DL_RCCF, (log(LL_DBG, "[defaults, no controller section] controller %d: protocol = dss1", controllercount)));
	isdn_ctrl_tab[controllercount].protocol = PROTOCOL_DSS1;
d361 1
a361 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: acctall = %d", yylval.booln)));
d366 1
a366 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: acctfile = %s", yylval.str)));
d373 1
a373 1
				DBGL(DL_RCCF, (log(LL_DBG, "entry %d: alert < %d, min = %d", entrycount, MINALERT, yylval.num)));
d378 1
a378 1
				DBGL(DL_RCCF, (log(LL_DBG, "entry %d: alert > %d, min = %d", entrycount, MAXALERT, yylval.num)));
d381 2
a382 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: alert = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].alert = yylval.num;
d386 1
a386 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: aliasing = %d", yylval.booln)));
d392 1
a392 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: aliasfile = %s", yylval.str)));
d396 1
a396 1
			if((cfg_entry_tab[entrycount].answerprog = malloc(strlen(yylval.str)+1)) == NULL)
d398 1
a398 1
				log(LL_ERR, "entry %d: answerstring, malloc failed!", entrycount);
d401 2
a402 2
			strcpy(cfg_entry_tab[entrycount].answerprog, yylval.str);
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: answerprog = %s", entrycount, yylval.str)));
d406 1
a406 1
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: b1protocol = %s", entrycount, yylval.str)));
d408 1
a408 1
				cfg_entry_tab[entrycount].b1protocol = BPROT_NONE;
d410 1
a410 1
				cfg_entry_tab[entrycount].b1protocol = BPROT_RHDLC;
d413 1
a413 1
				log(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"b1protocol\" at line %d!", lineno);
d420 82
a501 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: beepconnect = %d", yylval.booln)));
d504 46
d554 1
a554 1
				DBGL(DL_RCCF, (log(LL_DBG, "entry %d: callbackwait < %d, min = %d", entrycount, CALLBACKWAIT_MIN, yylval.num)));
d557 2
a558 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: callbackwait = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].callbackwait = yylval.num;
d565 1
a565 1
				DBGL(DL_RCCF, (log(LL_DBG, "entry %d: calledbackwait < %d, min = %d", entrycount, CALLEDBACKWAIT_MIN, yylval.num)));
d568 2
a569 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: calledbackwait = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].calledbackwait = yylval.num;
d573 1
a573 1
			if((cfg_entry_tab[entrycount].connectprog = malloc(strlen(yylval.str)+1)) == NULL)
d575 1
a575 1
				log(LL_ERR, "entry %d: connectprog, malloc failed!", entrycount);
d578 2
a579 2
			strcpy(cfg_entry_tab[entrycount].connectprog, yylval.str);
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: connectprog = %s", entrycount, yylval.str)));
d583 1
a583 1
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: dialouttype = %s", entrycount, yylval.str)));
d585 1
a585 1
				cfg_entry_tab[entrycount].dialouttype = DIALOUT_NORMAL;
d587 1
a587 1
				cfg_entry_tab[entrycount].dialouttype = DIALOUT_CALLEDBACK;
d590 1
a590 1
				log(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"dialout-type\" at line %d!", lineno);
d596 2
a597 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: dialretries = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].dialretries = yylval.num;
d601 2
a602 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: dialrandincr = %d", entrycount, yylval.booln)));
			cfg_entry_tab[entrycount].dialrandincr = yylval.booln;
d606 1
a606 1
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: direction = %s", entrycount, yylval.str)));
d609 1
a609 1
				cfg_entry_tab[entrycount].inout = DIR_INOUT;
d611 1
a611 1
				cfg_entry_tab[entrycount].inout = DIR_INONLY;
d613 1
a613 1
				cfg_entry_tab[entrycount].inout = DIR_OUTONLY;
d616 1
a616 1
				log(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"direction\" at line %d!", lineno);
d622 1
a622 1
			if((cfg_entry_tab[entrycount].disconnectprog = malloc(strlen(yylval.str)+1)) == NULL)
d624 1
a624 1
				log(LL_ERR, "entry %d: disconnectprog, malloc failed!", entrycount);
d627 2
a628 2
			strcpy(cfg_entry_tab[entrycount].disconnectprog, yylval.str);
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: disconnectprog = %s", entrycount, yylval.str)));
d637 2
a638 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: downtries = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].downtries = yylval.num;
d647 2
a648 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: downtime = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].downtime = yylval.num;
d652 12
a663 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: earlyhangup = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].earlyhangup = yylval.num;
d667 1
a667 1
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: idle-algorithm-outgoing = %s", entrycount, yylval.str)));
d671 1
a671 1
				cfg_entry_tab[entrycount].shorthold_algorithm = SHA_FIXU;
d675 1
a675 1
				cfg_entry_tab[entrycount].shorthold_algorithm = SHA_VARU;
d679 1
a679 1
				log(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"idle-algorithm-outgoing\" at line %d!", lineno);
d685 2
a686 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: idle_time_in = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].idle_time_in = yylval.num;
d690 2
a691 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: idle_time_out = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].idle_time_out = yylval.num;
d695 2
a696 2
			cfg_entry_tab[entrycount].isdncontroller = yylval.num;
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: isdncontroller = %d", entrycount, yylval.num)));
d704 2
a705 2
					cfg_entry_tab[entrycount].isdnchannel = CHAN_ANY;
					DBGL(DL_RCCF, (log(LL_DBG, "entry %d: isdnchannel = any", entrycount)));
d708 2
a709 2
					cfg_entry_tab[entrycount].isdnchannel = CHAN_B1;
					DBGL(DL_RCCF, (log(LL_DBG, "entry %d: isdnchannel = one", entrycount)));
d712 2
a713 2
					cfg_entry_tab[entrycount].isdnchannel = CHAN_B2;
					DBGL(DL_RCCF, (log(LL_DBG, "entry %d: isdnchannel = two", entrycount)));
d716 1
a716 1
					log(LL_DBG, "entry %d: isdnchannel value out of range", entrycount);
d723 1
a723 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: isdntime = %d", yylval.booln)));
d728 2
a729 2
			cfg_entry_tab[entrycount].isdntxdelin = yylval.num;
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: isdntxdel-incoming = %d", entrycount, yylval.num)));
d733 2
a734 2
			cfg_entry_tab[entrycount].isdntxdelout = yylval.num;
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: isdntxdel-outgoing = %d", entrycount, yylval.num)));
d738 2
a739 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: local_phone_dialout = %s", entrycount, yylval.str)));
			strcpy(cfg_entry_tab[entrycount].local_phone_dialout, yylval.str);
d743 2
a744 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: local_phone_incoming = %s", entrycount, yylval.str)));
			strcpy(cfg_entry_tab[entrycount].local_phone_incoming, yylval.str);
d749 1
a749 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: mailer = %s", yylval.str)));
d754 1
a754 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: mailto = %s", yylval.str)));
d759 1
a759 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: monitorport = %d", yylval.num)));
d766 1
a766 1
				DBGL(DL_RCCF, (log(LL_DBG, "system: monitor-enable overriden by command line flag")));
d771 1
a771 1
				DBGL(DL_RCCF, (log(LL_DBG, "system: monitor-enable = %d", yylval.booln)));
d776 78
a853 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: name = %s", entrycount, yylval.str)));
			strcpy(cfg_entry_tab[entrycount].name, yylval.str);
d857 1
a857 1
			DBGL(DL_RCCF, (log(LL_DBG, "controller %d: protocol = %s", controllercount, yylval.str)));
d859 1
a859 1
				isdn_ctrl_tab[controllercount].protocol = PROTOCOL_DSS1;
d861 1
a861 1
				isdn_ctrl_tab[controllercount].protocol = PROTOCOL_D64S;
d864 1
a864 1
				log(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"protocol\" at line %d!", lineno);
d870 1
a870 1
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: dialin_reaction = %s", entrycount, yylval.str)));
d872 1
a872 1
				cfg_entry_tab[entrycount].dialin_reaction = REACT_ACCEPT;
d874 1
a874 1
				cfg_entry_tab[entrycount].dialin_reaction = REACT_REJECT;
d876 1
a876 1
				cfg_entry_tab[entrycount].dialin_reaction = REACT_IGNORE;
d878 1
a878 1
				cfg_entry_tab[entrycount].dialin_reaction = REACT_ANSWER;
d880 1
a880 1
				cfg_entry_tab[entrycount].dialin_reaction = REACT_CALLBACK;
d883 1
a883 1
				log(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"dialin_reaction\" at line %d!", lineno);
d889 1
a889 1
			if(cfg_entry_tab[entrycount].remote_numbers_count >= MAXRNUMBERS)
d891 1
a891 1
				log(LL_ERR, "ERROR parsing config file: too many remote numbers at line %d!", lineno);
d896 2
a897 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: remote_phone_dialout #%d = %s",
				entrycount, cfg_entry_tab[entrycount].remote_numbers_count, yylval.str)));
d899 2
a900 2
			strcpy(cfg_entry_tab[entrycount].remote_numbers[cfg_entry_tab[entrycount].remote_numbers_count].number, yylval.str);
			cfg_entry_tab[entrycount].remote_numbers[cfg_entry_tab[entrycount].remote_numbers_count].flag = 0;
d902 1
a902 1
			cfg_entry_tab[entrycount].remote_numbers_count++;
d907 1
a907 1
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: remdial_handling = %s", entrycount, yylval.str)));
d909 1
a909 1
				cfg_entry_tab[entrycount].remote_numbers_handling = RNH_NEXT;
d911 1
a911 1
				cfg_entry_tab[entrycount].remote_numbers_handling = RNH_LAST;
d913 1
a913 1
				cfg_entry_tab[entrycount].remote_numbers_handling = RNH_FIRST;
d916 1
a916 1
				log(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"remdial_handling\" at line %d!", lineno);
d924 1
a924 1
				n = cfg_entry_tab[entrycount].incoming_numbers_count;
d927 1
a927 1
					log(LL_ERR, "ERROR parsing config file: too many \"remote_phone_incoming\" entries at line %d!", lineno);
d931 3
a933 3
				DBGL(DL_RCCF, (log(LL_DBG, "entry %d: remote_phone_incoming #%d = %s", entrycount, n, yylval.str)));
				strcpy(cfg_entry_tab[entrycount].remote_phone_incoming[n].number, yylval.str);
				cfg_entry_tab[entrycount].incoming_numbers_count++;
d939 1
a939 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: ratesfile = %s", yylval.str)));
d943 2
a944 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: ratetype = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].ratetype = yylval.num;
d951 1
a951 1
				DBGL(DL_RCCF, (log(LL_DBG, "entry %d: recoverytime < %d, min = %d", entrycount, RECOVERYTIME_MIN, yylval.num)));
d954 2
a955 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: recoverytime = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].recoverytime = yylval.num;
d961 1
a961 1
				log(LL_ERR, "system: regexpr #%d >= MAX_RE", nregexpr);
d970 1
a970 1
				log(LL_ERR, "system: regcomp error for %s: [%s]", yylval.str, buf);
d978 1
a978 1
					log(LL_ERR, "system: regexpr malloc error error for %s", yylval.str);
d984 1
a984 1
				DBGL(DL_RCCF, (log(LL_DBG, "system: regexpr %s stored into slot %d", yylval.str, nregexpr)));
d997 1
a997 1
				log(LL_ERR, "system: regprog #%d >= MAX_RE", nregprog);
d1003 1
a1003 1
				log(LL_ERR, "system: regprog malloc error error for %s", yylval.str);
d1009 1
a1009 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: regprog %s stored into slot %d", yylval.str, nregprog)));
d1019 1
a1019 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: rotatesuffix = %s", yylval.str)));
d1028 1
a1028 1
				log(LL_ERR, "system: error, rtprio (%d) out of range!", yylval.num);
d1032 1
a1032 1
				DBGL(DL_RCCF, (log(LL_DBG, "system: rtprio = %d", yylval.num)));
d1041 1
a1041 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: tinainitprog = %s", yylval.str)));
d1045 2
a1046 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: unitlength = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].unitlength = yylval.num;
d1050 1
a1050 1
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: unitlengthsrc = %s", entrycount, yylval.str)));
d1052 1
a1052 1
				cfg_entry_tab[entrycount].unitlengthsrc = ULSRC_NONE;
d1054 1
a1054 1
				cfg_entry_tab[entrycount].unitlengthsrc = ULSRC_CMDL;
d1056 1
a1056 1
				cfg_entry_tab[entrycount].unitlengthsrc = ULSRC_CONF;
d1058 1
a1058 1
				cfg_entry_tab[entrycount].unitlengthsrc = ULSRC_RATE;
d1060 1
a1060 1
				cfg_entry_tab[entrycount].unitlengthsrc = ULSRC_DYN;
d1063 1
a1063 1
				log(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"unitlengthsrc\" at line %d!", lineno);
d1069 4
a1072 14
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: usrdevicename = %s", entrycount, yylval.str)));
			if(!strcmp(yylval.str, "rbch"))
				cfg_entry_tab[entrycount].usrdevicename = BDRV_RBCH;
			else if(!strcmp(yylval.str, "tel"))
				cfg_entry_tab[entrycount].usrdevicename = BDRV_TEL;
			else if(!strcmp(yylval.str, "ipr"))
				cfg_entry_tab[entrycount].usrdevicename = BDRV_IPR;
			else if(!strcmp(yylval.str, "isp"))
				cfg_entry_tab[entrycount].usrdevicename = BDRV_ISPPP;
#ifdef __bsdi__
			else if(!strcmp(yylval.str, "ibc"))
				cfg_entry_tab[entrycount].usrdevicename = BDRV_IBC;
#endif
			else
d1074 1
a1074 1
				log(LL_ERR, "ERROR parsing config file: unknown parameter for keyword \"usrdevicename\" at line %d!", lineno);
d1080 2
a1081 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: usrdeviceunit = %d", entrycount, yylval.num)));
			cfg_entry_tab[entrycount].usrdeviceunit = yylval.num;
d1086 1
a1086 1
			DBGL(DL_RCCF, (log(LL_DBG, "system: useacctfile = %d", yylval.booln)));
d1090 7
a1096 2
			DBGL(DL_RCCF, (log(LL_DBG, "entry %d: usedown = %d", entrycount, yylval.booln)));
			cfg_entry_tab[entrycount].usedown = yylval.booln;
d1100 1
a1100 1
			log(LL_ERR, "ERROR parsing config file: unknown keyword at line %d!", lineno);
d1107 89
d1201 1
a1201 1
	cfg_entry_t *cep = &cfg_entry_tab[0];	/* ptr to config entry */
d1211 1
a1211 1
			log(LL_ERR, "check_config: regular expression %d without program!", i);
d1216 1
a1216 1
			log(LL_ERR, "check_config: regular expression program %d without expression!", i);
d1223 1
a1223 9
	for(i=0; i <= entrycount; i++, cep++)
	{
		/* isdn controller number */

		if((cep->isdncontroller < 0) || (cep->isdncontroller > (ncontroller-1)))
		{
			log(LL_ERR, "check_config: isdncontroller out of range in entry %d!", i);
			error++;
		}
d1231 1
a1231 1
				log(LL_ERR, "check_config: remote-phone-dialout not set in entry %d!", i);
d1236 1
a1236 1
				log(LL_ERR, "check_config: local-phone-dialout not set in entry %d!", i);
d1247 1
a1247 1
				log(LL_ERR, "check_config: local-phone-incoming not set in entry %d!", i);
d1252 1
a1252 1
				log(LL_ERR, "check_config: remote-phone-incoming not set in entry %d!", i);
d1259 1
a1259 1
			log(LL_ERR, "check_config: b1protocol not raw for telephony in entry %d!", i);
d1262 38
d1301 2
a1302 3
	if(error)
	{
		log(LL_ERR, "check_config: %d error(s) in configuration file, exit!", error);
d1319 1
a1319 1
	cfg_entry_t *cep = &cfg_entry_tab[0];	/* ptr to config entry */
d1509 1
a1509 2
	for(i=0; i <= entrycount; i++, cep++)
	{
d1533 1
a1533 1
		fprintf(PFILE, "usrdevicename         = %s\t\t# name of userland ISDN B-channel device\n", bdrivername(cep->usrdevicename));
d1538 2
a1539 1
		if(!(cep->usrdevicename == BDRV_TEL))
d1541 9
a1549 13
			fprintf(PFILE, "direction             = ");
			switch(cep->inout)
			{
				case DIR_INONLY:
					fprintf(PFILE, "in\t\t# only incoming connections allowed\n");
					break;
				case DIR_OUTONLY:
					fprintf(PFILE, "out\t\t# only outgoing connections allowed\n");
					break;
				case DIR_INOUT:
					fprintf(PFILE, "inout\t\t# incoming and outgoing connections allowed\n");
					break;
			}
d1552 1
a1552 1
		if(!((cep->usrdevicename == BDRV_TEL) || (cep->inout == DIR_INONLY)))
d1554 2
a1555 4
			if(cep->remote_numbers_count > 1)
			{
				for(j=0; j<cep->remote_numbers_count; j++)
					fprintf(PFILE, "remote-phone-dialout  = %s\t\t# telephone number %d for dialing out to remote\n", cep->remote_numbers[j].number, j+1);
d1558 1
a1558 1
		
d1562 1
a1562 1
						fprintf(PFILE, "next\t\t# use next number after last successfull for new dial\n");
d1565 1
a1565 1
						fprintf(PFILE, "last\t\t# use last successfull number for new dial\n");
a1571 4
			else
			{
				fprintf(PFILE, "remote-phone-dialout  = %s\t\t# telephone number for dialing out to remote\n", cep->remote_numbers[0].number);
			}
d1607 60
a1666 1
		if(!((cep->inout == DIR_INONLY) || (cep->usrdevicename == BDRV_TEL)))
a1689 1
		if(!(cep->usrdevicename == BDRV_TEL))
a1717 1
		if(cep->usrdevicename == BDRV_TEL)
a1722 1
		if(!(cep->usrdevicename == BDRV_TEL))
a1742 1
		}		
d1747 13
a1759 1
/* EOF */
@

