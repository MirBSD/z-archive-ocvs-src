head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.11
	tg-mergefixes-1-branch:1.1.1.11.0.8
	tg-mergefixes-1-base:1.1.1.11
	MIROS_X:1.1.1.11.0.6
	MIROS_X_BASE:1.1.1.11
	tg-mergetmp-3:1.1.1.11
	MIRBSD_XP_MIRPPC:1.1.1.11.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.11
	MIRBSD_XP_SPARC:1.1.1.11.0.2
	MIRBSD_7quater:1.1.1.8
	cvs-200405160640:1.1.1.11
	cvs-200401271800:1.1.1.10
	cvs-200401261630:1.1.1.10
	cvs-200401021645:1.1.1.9
	MIRBSD_7_ALPHA:1.1.1.8.0.6
	MIRBSD_7:1.1.1.8.0.4
	cvs-200312222040:1.1.1.8
	MIRBSD_7ter:1.1.1.8
	MIRBSD_7_DEV:1.1.1.8.0.2
	cvs-200310020700:1.1.1.8
	cvs-200309271030:1.1.1.8
	cvs-200309251530:1.1.1.8
	cvs-200308302005:1.1.1.7
	cvs-200308171200:1.1.1.6
	ctm-3496:1.1.1.6
	ctm-3449:1.1.1.5
	ctm-3437:1.1.1.5
	cvs-200307191805:1.1.1.5
	ctm-3425:1.1.1.5
	cvs-200307091500:1.1.1.5
	ctm-3389:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.4
	cvs-200306082100:1.1.1.4
	ctm-3316:1.1.1.4
	ctm-3272:1.1.1.3
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.2
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.56.01;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.56.01;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.03.29.19.53.41;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.21.19.27.46;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.05.17.49.27;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.07.09.16.55.32;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.08.11.18.56.15;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.08.30.23.59.50;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.09.25.16.46.20;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.01.02.18.12.09;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.01.26.19.13.52;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.05.16.07.24.54;	author tg;	state Stab;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: syslogd.c,v 1.59 2002/12/22 17:19:42 mickey Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1983, 1988, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)syslogd.c	8.3 (Berkeley) 4/4/94";
#else
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.59 2002/12/22 17:19:42 mickey Exp $";
#endif
#endif /* not lint */

/*
 *  syslogd -- log system messages
 *
 * This program implements a system log. It takes a series of lines.
 * Each line may have a priority, signified as "<n>" as
 * the first characters of the line.  If this is
 * not present, a default priority is used.
 *
 * To kill syslogd, send a signal 15 (terminate).  A signal 1 (hup) will
 * cause it to reread its configuration file.
 *
 * Defined Constants:
 *
 * MAXLINE -- the maximum line length that can be handled.
 * DEFUPRI -- the default priority for user messages
 * DEFSPRI -- the default priority for kernel messages
 *
 * Author: Eric Allman
 * extensive changes by Ralph Campbell
 * more extensive changes by Eric Allman (again)
 */

#define	MAXLINE		1024		/* maximum line length */
#define	MAXSVLINE	120		/* maximum saved line length */
#define DEFUPRI		(LOG_USER|LOG_NOTICE)
#define DEFSPRI		(LOG_KERN|LOG_CRIT)
#define TIMERINTVL	30		/* interval for checking flush, mark */
#define TTYMSGTIME	1		/* timeout passed to ttymsg */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/msgbuf.h>
#include <sys/uio.h>
#include <sys/sysctl.h>
#include <sys/un.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <errno.h>
#include <err.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <utmp.h>
#include <vis.h>

#define SYSLOG_NAMES
#include <sys/syslog.h>

char	*ConfFile = _PATH_LOGCONF;
char	*PidFile = _PATH_LOGPID;
char	ctty[] = _PATH_CONSOLE;

#define	dprintf		if (Debug) printf

#define MAXUNAMES	20	/* maximum number of user names */

/*
 * Flags to logmsg().
 */

#define IGN_CONS	0x001	/* don't print on console */
#define SYNC_FILE	0x002	/* do fsync on file after printing */
#define ADDDATE		0x004	/* add a date to the message */
#define MARK		0x008	/* this message is a mark */

/*
 * This structure represents the files that will have log
 * copies printed.
 */

struct filed {
	struct	filed *f_next;		/* next in linked list */
	short	f_type;			/* entry type, see below */
	short	f_file;			/* file descriptor */
	time_t	f_time;			/* time this was last written */
	u_char	f_pmask[LOG_NFACILITIES+1];	/* priority mask */
	char	*f_program;		/* program this applies to */
	union {
		char	f_uname[MAXUNAMES][UT_NAMESIZE+1];
		struct {
			char	f_hname[MAXHOSTNAMELEN];
			struct sockaddr_in	f_addr;
		} f_forw;		/* forwarding address */
		char	f_fname[MAXPATHLEN];
	} f_un;
	char	f_prevline[MAXSVLINE];		/* last message logged */
	char	f_lasttime[16];			/* time of last occurrence */
	char	f_prevhost[MAXHOSTNAMELEN];	/* host from which recd. */
	int	f_prevpri;			/* pri of f_prevline */
	int	f_prevlen;			/* length of f_prevline */
	int	f_prevcount;			/* repetition cnt of prevline */
	int	f_repeatcount;			/* number of "repeated" msgs */
};

/*
 * Intervals at which we flush out "message repeated" messages,
 * in seconds after previous message is logged.  After each flush,
 * we move to the next interval until we reach the largest.
 */
int	repeatinterval[] = { 30, 120, 600 };	/* # of secs before flush */
#define	MAXREPEAT ((sizeof(repeatinterval) / sizeof(repeatinterval[0])) - 1)
#define	REPEATTIME(f)	((f)->f_time + repeatinterval[(f)->f_repeatcount])
#define	BACKOFF(f)	{ if (++(f)->f_repeatcount > MAXREPEAT) \
				 (f)->f_repeatcount = MAXREPEAT; \
			}

/* values for f_type */
#define F_UNUSED	0		/* unused entry */
#define F_FILE		1		/* regular file */
#define F_TTY		2		/* terminal */
#define F_CONSOLE	3		/* console terminal */
#define F_FORW		4		/* remote machine */
#define F_USERS		5		/* list of users */
#define F_WALL		6		/* everyone logged on */

char	*TypeNames[7] = {
	"UNUSED",	"FILE",		"TTY",		"CONSOLE",
	"FORW",		"USERS",	"WALL"
};

struct	filed *Files;
struct	filed consfile;

int	Debug;			/* debug flag */
char	LocalHostName[MAXHOSTNAMELEN];	/* our hostname */
char	*LocalDomain;		/* our local domain name */
int	InetInuse = 0;		/* non-zero if INET sockets are being used */
int	finet;			/* Internet datagram socket */
int	LogPort;		/* port number for INET connections */
int	Initialized = 0;	/* set when we have initialized ourselves */

int	MarkInterval = 20 * 60;	/* interval between marks in seconds */
int	MarkSeq = 0;		/* mark sequence number */
int	SecureMode = 1;		/* when true, speak only unix domain socks */
int	NoDNS = 0;		/* when true, will refrain from doing DNS lookups */

volatile sig_atomic_t MarkSet;
volatile sig_atomic_t WantDie;
volatile sig_atomic_t DoInit;

void	cfline(char *, struct filed *, char *);
char   *cvthname(struct sockaddr_in *);
int	decode(const char *, CODE *);
void	dodie(int);
void	doinit(int);
void	die(int);
void	domark(int);
void	markit(void);
void	fprintlog(struct filed *, int, char *);
void	init(void);
void	logerror(char *);
void	logmsg(int, char *, char *, int);
void	printline(char *, char *);
void	printsys(char *);
void	reapchild(int);
char   *ttymsg(struct iovec *, int, char *, int);
void	usage(void);
void	wallmsg(struct filed *, struct iovec *);
int	getmsgbufsize(void);

#define MAXFUNIX	21

int nfunix = 1;
char *funixn[MAXFUNIX] = { _PATH_LOG };
int funix[MAXFUNIX];

int
main(int argc, char *argv[])
{
	int ch, i, fklog, linesize, fdsrmax = 0;
	struct sockaddr_un sunx, fromunix;
	struct sockaddr_in sin, frominet;
	socklen_t slen, len;
	fd_set *fdsr = NULL;
	char *p, *line;
	FILE *fp;

	while ((ch = getopt(argc, argv, "dnuf:m:p:a:")) != -1)
		switch (ch) {
		case 'd':		/* debug */
			Debug++;
			break;
		case 'f':		/* configuration file */
			ConfFile = optarg;
			break;
		case 'm':		/* mark interval */
			MarkInterval = atoi(optarg) * 60;
			break;
		case 'n':		/* don't do DNS lookups */
			NoDNS = 1;
			break;
		case 'p':		/* path */
			funixn[0] = optarg;
			break;
		case 'u':		/* allow udp input port */
			SecureMode = 0;
			break;
		case 'a':
			if (nfunix >= MAXFUNIX)
				fprintf(stderr,
				    "syslogd: out of descriptors, ignoring %s\n",
				    optarg);
			else if (strlen(optarg) >= sizeof(sunx.sun_path))
				fprintf(stderr,
				    "syslogd: path too long, ignoring %s\n",
				    optarg);
			else
				funixn[nfunix++] = optarg;
			break;
		case '?':
		default:
			usage();
		}
	if ((argc -= optind) != 0)
		usage();

	if (!Debug)
		(void)daemon(0, 0);
	else
		setlinebuf(stdout);

	consfile.f_type = F_CONSOLE;
	(void)strlcpy(consfile.f_un.f_fname, ctty,
	    sizeof(consfile.f_un.f_fname));
	(void)gethostname(LocalHostName, sizeof(LocalHostName));
	if ((p = strchr(LocalHostName, '.')) != NULL) {
		*p++ = '\0';
		LocalDomain = p;
	} else
		LocalDomain = "";

	linesize = getmsgbufsize();
	if (linesize < MAXLINE)
		linesize = MAXLINE;
	linesize++;
	line = malloc(linesize);

	(void)signal(SIGHUP, doinit);
	(void)signal(SIGTERM, dodie);
	(void)signal(SIGINT, Debug ? dodie : SIG_IGN);
	(void)signal(SIGQUIT, Debug ? dodie : SIG_IGN);
	(void)signal(SIGCHLD, reapchild);
	(void)signal(SIGALRM, domark);
	(void)alarm(TIMERINTVL);

#ifndef SUN_LEN
#define SUN_LEN(unp) (strlen((unp)->sun_path) + 2)
#endif
	for (i = 0; i < nfunix; i++) {
		(void)unlink(funixn[i]);

		memset(&sunx, 0, sizeof(sunx));
		sunx.sun_family = AF_UNIX;
		(void)strlcpy(sunx.sun_path, funixn[i], sizeof(sunx.sun_path));
		funix[i] = socket(AF_UNIX, SOCK_DGRAM, 0);
		if (funix[i] < 0 ||
		    bind(funix[i], (struct sockaddr *)&sunx,
		    SUN_LEN(&sunx)) < 0 ||
		    chmod(funixn[i], 0666) < 0) {
			(void)snprintf(line, linesize, "cannot create %s",
			    funixn[i]);
			logerror(line);
			dprintf("cannot create %s (%d)\n", funixn[i], errno);
			if (i == 0)
				die(0);
		}
		/* double socket receive buffer size */
		if (getsockopt(funix[i], SOL_SOCKET, SO_RCVBUF, &len,
		    &slen) == 0) {
			len *= 2;
			(void)setsockopt(funix[i], SOL_SOCKET, SO_RCVBUF, &len,
			    slen);
		}
	}
	finet = socket(AF_INET, SOCK_DGRAM, 0);
	if (finet >= 0) {
		struct servent *sp;

		sp = getservbyname("syslog", "udp");
		if (sp == NULL) {
			errno = 0;
			logerror("syslog/udp: unknown service");
			die(0);
		}
		memset(&sin, 0, sizeof(sin));
		sin.sin_len = sizeof(sin);
		sin.sin_family = AF_INET;
		sin.sin_port = LogPort = sp->s_port;
		if (bind(finet, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
			logerror("bind");
			if (!Debug)
				die(0);
		} else {
			InetInuse = 1;
			/* double socket receive buffer size */
			if (getsockopt(finet, SOL_SOCKET, SO_RCVBUF, &len,
			    &slen) == 0) {
				len *= 2;
				(void)setsockopt(finet, SOL_SOCKET,
				    SO_RCVBUF, &len, slen);
			}
		}
	}
	if ((fklog = open(_PATH_KLOG, O_RDONLY, 0)) < 0)
		dprintf("can't open %s (%d)\n", _PATH_KLOG, errno);

	/* tuck my process id away */
	if (!Debug) {
		fp = fopen(PidFile, "w");
		if (fp != NULL) {
			fprintf(fp, "%ld\n", (long)getpid());
			(void) fclose(fp);
		}
	}

	dprintf("off & running....\n");

	init();

	if (fklog != -1 && fklog > fdsrmax)
		fdsrmax = fklog;
	if (finet != -1 && finet > fdsrmax)
		fdsrmax = finet;
	for (i = 0; i < nfunix; i++) {
		if (funix[i] != -1 && funix[i] > fdsrmax)
			fdsrmax = funix[i];
	}

	fdsr = (fd_set *)calloc(howmany(fdsrmax+1, NFDBITS),
	    sizeof(fd_mask));
	if (fdsr == NULL)
		errx(1, "calloc fd_set");

	for (;;) {
		if (MarkSet)
			markit();
		if (WantDie)
			die(WantDie);

		if (DoInit) {
			init();
			DoInit = 0;
		}

		bzero(fdsr, howmany(fdsrmax+1, NFDBITS) *
		    sizeof(fd_mask));

		if (fklog != -1)
			FD_SET(fklog, fdsr);
		if (finet != -1)
			FD_SET(finet, fdsr);
		for (i = 0; i < nfunix; i++) {
			if (funix[i] != -1)
				FD_SET(funix[i], fdsr);
		}

		switch (select(fdsrmax+1, fdsr, NULL, NULL, NULL)) {
		case 0:
			continue;
		case -1:
			if (errno != EINTR)
				logerror("select");
			continue;
		}

		if (fklog != -1 && FD_ISSET(fklog, fdsr)) {
			i = read(fklog, line, linesize - 1);
			if (i > 0) {
				line[i] = '\0';
				printsys(line);
			} else if (i < 0 && errno != EINTR) {
				logerror("klog");
				fklog = -1;
			}
		}
		if (finet != -1 && FD_ISSET(finet, fdsr)) {
			len = sizeof(frominet);
			i = recvfrom(finet, line, MAXLINE, 0,
			    (struct sockaddr *)&frominet, &len);
			if (SecureMode) {
				/* silently drop it */
			} else {
				if (i > 0) {
					line[i] = '\0';
					printline(cvthname(&frominet), line);
				} else if (i < 0 && errno != EINTR)
					logerror("recvfrom inet");
			}
		}

		for (i = 0; i < nfunix; i++) {
			if (funix[i] != -1 && FD_ISSET(funix[i], fdsr)) {
				len = sizeof(fromunix);
				len = recvfrom(funix[i], line, MAXLINE, 0,
				    (struct sockaddr *)&fromunix, &len);
				if (len > 0) {
					line[len] = '\0';
					printline(LocalHostName, line);
				} else if (len < 0 && errno != EINTR)
					logerror("recvfrom unix");
			}
		}
	}
	if (fdsr)
		free(fdsr);
}

void
usage(void)
{

	(void)fprintf(stderr,
	    "usage: syslogd [-dnu] [-f config_file] [-m mark_interval] "
	    "[-a path] [-p log_socket]\n");
	exit(1);
}

/*
 * Take a raw input line, decode the message, and print the message
 * on the appropriate log files.
 */
void
printline(char *hname, char *msg)
{
	int pri;
	char *p, *q, line[MAXLINE + 1];

	/* test for special codes */
	pri = DEFUPRI;
	p = msg;
	if (*p == '<') {
		pri = 0;
		while (isdigit(*++p))
			pri = 10 * pri + (*p - '0');
		if (*p == '>')
			++p;
	}
	if (pri &~ (LOG_FACMASK|LOG_PRIMASK))
		pri = DEFUPRI;

	/* don't allow users to log kernel messages */
	if (LOG_FAC(pri) == LOG_KERN)
		pri = LOG_MAKEPRI(LOG_USER, LOG_PRI(pri));

	for (q = line; *p && q < &line[sizeof(line) - 4]; p++) {
		if (*p == '\n')
			*q++ = ' ';
		else
			q = vis(q, *p, 0, 0);
	}
	*q = '\0';

	logmsg(pri, line, hname, 0);
}

/*
 * Take a raw input line from /dev/klog, split and format similar to syslog().
 */
void
printsys(char *msg)
{
	int c, pri, flags;
	char *lp, *p, *q, line[MAXLINE + 1];

	(void)snprintf(line, sizeof line, "%s: ", _PATH_UNIX);
	lp = line + strlen(line);
	for (p = msg; *p != '\0'; ) {
		flags = SYNC_FILE | ADDDATE;	/* fsync file after write */
		pri = DEFSPRI;
		if (*p == '<') {
			pri = 0;
			while (isdigit(*++p))
				pri = 10 * pri + (*p - '0');
			if (*p == '>')
				++p;
		} else {
			/* kernel printf's come out on console */
			flags |= IGN_CONS;
		}
		if (pri &~ (LOG_FACMASK|LOG_PRIMASK))
			pri = DEFSPRI;

		q = lp;
		while (*p && (c = *p++) != '\n' && q < &line[sizeof(line) - 4])
			q = vis(q, c, 0, 0);

		logmsg(pri, line, LocalHostName, flags);
	}
}

time_t	now;

/*
 * Log a message to the appropriate log files, users, etc. based on
 * the priority.
 */
void
logmsg(int pri, char *msg, char *from, int flags)
{
	struct filed *f;
	int fac, msglen, prilev, i;
	sigset_t mask, omask;
	char *timestamp;
	char prog[NAME_MAX+1];

	dprintf("logmsg: pri 0%o, flags 0x%x, from %s, msg %s\n",
	    pri, flags, from, msg);

	sigemptyset(&mask);
	sigaddset(&mask, SIGALRM);
	sigaddset(&mask, SIGHUP);
	sigprocmask(SIG_BLOCK, &mask, &omask);

	/*
	 * Check to see if msg looks non-standard.
	 */
	msglen = strlen(msg);
	if (msglen < 16 || msg[3] != ' ' || msg[6] != ' ' ||
	    msg[9] != ':' || msg[12] != ':' || msg[15] != ' ')
		flags |= ADDDATE;

	(void)time(&now);
	if (flags & ADDDATE)
		timestamp = ctime(&now) + 4;
	else {
		timestamp = msg;
		msg += 16;
		msglen -= 16;
	}

	/* extract facility and priority level */
	if (flags & MARK)
		fac = LOG_NFACILITIES;
	else
		fac = LOG_FAC(pri);
	prilev = LOG_PRI(pri);

	/* extract program name */
	for(i = 0; i < NAME_MAX; i++) {
		if (!isalnum(msg[i]))
			break;
		prog[i] = msg[i];
	}
	prog[i] = 0;

	/* log the message to the particular outputs */
	if (!Initialized) {
		f = &consfile;
		f->f_file = open(ctty, O_WRONLY|O_NONBLOCK, 0);

		if (f->f_file >= 0) {
			fprintlog(f, flags, msg);
			(void)close(f->f_file);
			f->f_file = -1;
		}
		(void)sigprocmask(SIG_SETMASK, &omask, NULL);
		return;
	}
	for (f = Files; f; f = f->f_next) {
		/* skip messages that are incorrect priority */
		if (f->f_pmask[fac] < prilev ||
		    f->f_pmask[fac] == INTERNAL_NOPRI)
			continue;

		/* skip messages with the incorrect program name */
		if (f->f_program)
			if (strcmp(prog, f->f_program) != 0)
				continue;

		if (f->f_type == F_CONSOLE && (flags & IGN_CONS))
			continue;

		/* don't output marks to recently written files */
		if ((flags & MARK) && (now - f->f_time) < MarkInterval / 2)
			continue;

		/*
		 * suppress duplicate lines to this file
		 */
		if ((flags & MARK) == 0 && msglen == f->f_prevlen &&
		    !strcmp(msg, f->f_prevline) &&
		    !strcmp(from, f->f_prevhost)) {
			strlcpy(f->f_lasttime, timestamp, 16);
			f->f_prevcount++;
			dprintf("msg repeated %d times, %ld sec of %d\n",
			    f->f_prevcount, (long)(now - f->f_time),
			    repeatinterval[f->f_repeatcount]);
			/*
			 * If domark would have logged this by now,
			 * flush it now (so we don't hold isolated messages),
			 * but back off so we'll flush less often
			 * in the future.
			 */
			if (now > REPEATTIME(f)) {
				fprintlog(f, flags, (char *)NULL);
				BACKOFF(f);
			}
		} else {
			/* new line, save it */
			if (f->f_prevcount)
				fprintlog(f, 0, (char *)NULL);
			f->f_repeatcount = 0;
			f->f_prevpri = pri;
			strlcpy(f->f_lasttime, timestamp, 16);
			strlcpy(f->f_prevhost, from,
			    sizeof(f->f_prevhost));
			if (msglen < MAXSVLINE) {
				f->f_prevlen = msglen;
				strlcpy(f->f_prevline, msg, sizeof(f->f_prevline));
				fprintlog(f, flags, (char *)NULL);
			} else {
				f->f_prevline[0] = 0;
				f->f_prevlen = 0;
				fprintlog(f, flags, msg);
			}
		}
	}
	(void)sigprocmask(SIG_SETMASK, &omask, NULL);
}

void
fprintlog(struct filed *f, int flags, char *msg)
{
	struct iovec iov[6];
	struct iovec *v;
	int l;
	char line[MAXLINE + 1], repbuf[80], greetings[500];

	v = iov;
	if (f->f_type == F_WALL) {
		if ((l = snprintf(greetings, sizeof(greetings),
		    "\r\n\7Message from syslogd@@%s at %.24s ...\r\n",
		    f->f_prevhost, ctime(&now))) >= sizeof(greetings) ||
		    l == -1)
			l = strlen(greetings);
		v->iov_base = greetings;
		v->iov_len = l;
		v++;
		v->iov_base = "";
		v->iov_len = 0;
		v++;
	} else {
		v->iov_base = f->f_lasttime;
		v->iov_len = 15;
		v++;
		v->iov_base = " ";
		v->iov_len = 1;
		v++;
	}
	v->iov_base = f->f_prevhost;
	v->iov_len = strlen(v->iov_base);
	v++;
	v->iov_base = " ";
	v->iov_len = 1;
	v++;

	if (msg) {
		v->iov_base = msg;
		v->iov_len = strlen(msg);
	} else if (f->f_prevcount > 1) {
		if ((l = snprintf(repbuf, sizeof(repbuf),
		    "last message repeated %d times", f->f_prevcount)) >=
		    sizeof(repbuf) || l == -1)
			l = strlen(repbuf);
		v->iov_base = repbuf;
		v->iov_len = l;
	} else {
		v->iov_base = f->f_prevline;
		v->iov_len = f->f_prevlen;
	}
	v++;

	dprintf("Logging to %s", TypeNames[f->f_type]);
	f->f_time = now;

	switch (f->f_type) {
	case F_UNUSED:
		dprintf("\n");
		break;

	case F_FORW:
		dprintf(" %s\n", f->f_un.f_forw.f_hname);
		if ((l = snprintf(line, sizeof(line), "<%d>%.15s %s",
		    f->f_prevpri, (char *)iov[0].iov_base,
		    (char *)iov[4].iov_base)) >= sizeof(line) || l == -1)
			l = strlen(line);
		if (sendto(finet, line, l, 0,
		    (struct sockaddr *)&f->f_un.f_forw.f_addr,
		    sizeof(f->f_un.f_forw.f_addr)) != l) {
			f->f_type = F_UNUSED;
			logerror("sendto");
		}
		break;

	case F_CONSOLE:
		if (flags & IGN_CONS) {
			dprintf(" (ignored)\n");
			break;
		}
		/* FALLTHROUGH */

	case F_TTY:
	case F_FILE:
		dprintf(" %s\n", f->f_un.f_fname);
		if (f->f_type != F_FILE) {
			v->iov_base = "\r\n";
			v->iov_len = 2;
		} else {
			v->iov_base = "\n";
			v->iov_len = 1;
		}
	again:
		if (writev(f->f_file, iov, 6) < 0) {
			int e = errno;
			(void)close(f->f_file);
			/*
			 * Check for errors on TTY's due to loss of tty
			 */
			if (e == EAGAIN) {
				/*
				 * Silently drop messages on blocked write.
				 * This can happen when logging to a locked tty.
				 */
				break;
			} else if ((e == EIO || e == EBADF) &&
			    f->f_type != F_FILE) {
				f->f_file = open(f->f_un.f_fname,
				    O_WRONLY|O_APPEND|O_NONBLOCK, 0);
				if (f->f_file < 0) {
					f->f_type = F_UNUSED;
					logerror(f->f_un.f_fname);
				} else
					goto again;
			} else {
				f->f_type = F_UNUSED;
				f->f_file = -1;
				errno = e;
				logerror(f->f_un.f_fname);
			}
		} else if (flags & SYNC_FILE)
			(void)fsync(f->f_file);
		break;

	case F_USERS:
	case F_WALL:
		dprintf("\n");
		v->iov_base = "\r\n";
		v->iov_len = 2;
		wallmsg(f, iov);
		break;
	}
	f->f_prevcount = 0;
}

/*
 *  WALLMSG -- Write a message to the world at large
 *
 *	Write the specified message to either the entire
 *	world, or a list of approved users.
 */
void
wallmsg(struct filed *f, struct iovec *iov)
{
	struct utmp ut;
	char line[sizeof(ut.ut_line) + 1], *p;
	static int reenter;			/* avoid calling ourselves */
	FILE *uf;
	int i;

	if (reenter++)
		return;
	if ((uf = fopen(_PATH_UTMP, "r")) == NULL) {
		logerror(_PATH_UTMP);
		reenter = 0;
		return;
	}
	/* NOSTRICT */
	while (fread((char *)&ut, sizeof(ut), 1, uf) == 1) {
		if (ut.ut_name[0] == '\0')
			continue;
		strlcpy(line, ut.ut_line, sizeof(line));
		if (f->f_type == F_WALL) {
			if ((p = ttymsg(iov, 6, line, TTYMSGTIME)) != NULL) {
				errno = 0;	/* already in msg */
				logerror(p);
			}
			continue;
		}
		/* should we send the message to this user? */
		for (i = 0; i < MAXUNAMES; i++) {
			if (!f->f_un.f_uname[i][0])
				break;
			if (!strncmp(f->f_un.f_uname[i], ut.ut_name,
			    UT_NAMESIZE)) {
				if ((p = ttymsg(iov, 6, line, TTYMSGTIME))
								!= NULL) {
					errno = 0;	/* already in msg */
					logerror(p);
				}
				break;
			}
		}
	}
	(void)fclose(uf);
	reenter = 0;
}

void
reapchild(int signo)
{
	int save_errno = errno;
	int status;

	while (waitpid(-1, &status, WNOHANG) > 0)
		;
	errno = save_errno;
}

/*
 * Return a printable representation of a host address.
 */
char *
cvthname(struct sockaddr_in *f)
{
	struct hostent *hp;
	sigset_t omask, nmask;
	char *p;
	char *ip;

	if (f->sin_family != AF_INET) {
		dprintf("Malformed from address\n");
		return ("???");
	}

	ip = inet_ntoa(f->sin_addr);
	dprintf("cvthname(%s)\n", ip);
	if (NoDNS)
		return (ip);

	sigemptyset(&nmask);
	sigaddset(&nmask, SIGHUP);
	sigprocmask(SIG_BLOCK, &nmask, &omask);
	hp = gethostbyaddr((char *)&f->sin_addr,
	    sizeof(struct in_addr), f->sin_family);
	sigprocmask(SIG_SETMASK, &omask, NULL);
	if (hp == 0) {
		dprintf("Host name for your address (%s) unknown\n", ip);
		return (ip);
	}
	if ((p = strchr(hp->h_name, '.')) && strcmp(p + 1, LocalDomain) == 0)
		*p = '\0';
	return (hp->h_name);
}

void
dodie(int signo)
{
	WantDie = signo;
}

void
domark(int signo)
{
	MarkSet = 1;
}

void
doinit(int signo)
{
	DoInit = 1;
}

/*
 * Print syslogd errors some place.
 */
void
logerror(char *type)
{
	char buf[100];

	if (errno)
		(void)snprintf(buf, sizeof(buf), "syslogd: %s: %s",
		    type, strerror(errno));
	else
		(void)snprintf(buf, sizeof(buf), "syslogd: %s", type);
	errno = 0;
	dprintf("%s\n", buf);
	logmsg(LOG_SYSLOG|LOG_ERR, buf, LocalHostName, ADDDATE);
}

void
die(int signo)
{
	struct filed *f;
	int was_initialized = Initialized;
	char buf[100];
	int i;

	Initialized = 0;		/* Don't log SIGCHLDs */
	alarm(0);
	for (f = Files; f != NULL; f = f->f_next) {
		/* flush any pending output */
		if (f->f_prevcount)
			fprintlog(f, 0, (char *)NULL);
	}
	Initialized = was_initialized;
	if (signo) {
		dprintf("syslogd: exiting on signal %d\n", signo);
		(void)snprintf(buf, sizeof buf, "exiting on signal %d", signo);
		errno = 0;
		logerror(buf);
	}
	for (i = 0; i < nfunix; i++)
		if (funixn[i] && funix[i] != -1)
			(void)unlink(funixn[i]);
	exit(0);
}

/*
 *  INIT -- Initialize syslogd from configuration table
 */
void
init(void)
{
	char cline[LINE_MAX], prog[NAME_MAX+1], *p;
	struct filed *f, *next, **nextp;
	FILE *cf;
	int i;

	dprintf("init\n");

	/*
	 *  Close all open log files.
	 */
	Initialized = 0;
	for (f = Files; f != NULL; f = next) {
		/* flush any pending output */
		if (f->f_prevcount)
			fprintlog(f, 0, (char *)NULL);

		switch (f->f_type) {
		case F_FILE:
		case F_TTY:
		case F_CONSOLE:
			(void)close(f->f_file);
			break;
		case F_FORW:
			break;
		}
		next = f->f_next;
		if (f->f_program)
			free(f->f_program);
		free((char *)f);
	}
	Files = NULL;
	nextp = &Files;

	/* open the configuration file */
	if ((cf = fopen(ConfFile, "r")) == NULL) {
		dprintf("cannot open %s\n", ConfFile);
		*nextp = (struct filed *)calloc(1, sizeof(*f));
		cfline("*.ERR\t/dev/console", *nextp, "*");
		(*nextp)->f_next = (struct filed *)calloc(1, sizeof(*f));
		cfline("*.PANIC\t*", (*nextp)->f_next, "*");
		Initialized = 1;
		return;
	}

	/*
	 *  Foreach line in the conf table, open that file.
	 */
	f = NULL;
	strlcpy(prog, "*", sizeof(prog));
	while (fgets(cline, sizeof(cline), cf) != NULL) {
		/*
		 * check for end-of-section, comments, strip off trailing
		 * spaces and newline character. !prog is treated
		 * specially: the following lines apply only to that program.
		 */
		for (p = cline; isspace(*p); ++p)
			continue;
		if (*p == '\0' || *p == '#')
			continue;
		if (*p == '!') {
			p++;
			while (isspace(*p))
				p++;
			if (!*p) {
				strlcpy(prog, "*", sizeof(prog));
				continue;
			}
			for (i = 0; i < NAME_MAX; i++) {
				if (!isalnum(p[i]))
					break;
				prog[i] = p[i];
			}
			prog[i] = 0;
			continue;
		}
		p = cline + strlen(cline);
		while (p > cline)
			if (!isspace(*--p)) {
				p++;
				break;
			}
		*p = '\0';
		f = (struct filed *)calloc(1, sizeof(*f));
		*nextp = f;
		nextp = &f->f_next;
		cfline(cline, f, prog);
	}

	/* close the configuration file */
	(void)fclose(cf);

	Initialized = 1;

	if (Debug) {
		for (f = Files; f; f = f->f_next) {
			for (i = 0; i <= LOG_NFACILITIES; i++)
				if (f->f_pmask[i] == INTERNAL_NOPRI)
					printf("X ");
				else
					printf("%d ", f->f_pmask[i]);
			printf("%s: ", TypeNames[f->f_type]);
			switch (f->f_type) {
			case F_FILE:
			case F_TTY:
			case F_CONSOLE:
				printf("%s", f->f_un.f_fname);
				break;

			case F_FORW:
				printf("%s", f->f_un.f_forw.f_hname);
				break;

			case F_USERS:
				for (i = 0; i < MAXUNAMES && *f->f_un.f_uname[i]; i++)
					printf("%s, ", f->f_un.f_uname[i]);
				break;
			}
			if (f->f_program)
				printf(" (%s)", f->f_program);
			printf("\n");
		}
	}

	logmsg(LOG_SYSLOG|LOG_INFO, "syslogd: restart", LocalHostName,
	    ADDDATE);
	dprintf("syslogd: restarted\n");
}

/*
 * Crack a configuration file line
 */
void
cfline(char *line, struct filed *f, char *prog)
{
	struct hostent *hp;
	int i, pri;
	char *bp, *p, *q;
	char buf[MAXLINE], ebuf[100];

	dprintf("cfline(\"%s\", f, \"%s\")\n", line, prog);

	errno = 0;	/* keep strerror() stuff out of logerror messages */

	/* clear out file entry */
	memset(f, 0, sizeof(*f));
	for (i = 0; i <= LOG_NFACILITIES; i++)
		f->f_pmask[i] = INTERNAL_NOPRI;

	/* save program name if any */
	if (!strcmp(prog, "*"))
		prog = NULL;
	else {
		f->f_program = calloc(1, strlen(prog)+1);
		if (f->f_program)
			strlcpy(f->f_program, prog, strlen(prog)+1);
	}

	/* scan through the list of selectors */
	for (p = line; *p && *p != '\t';) {

		/* find the end of this facility name list */
		for (q = p; *q && *q != '\t' && *q++ != '.'; )
			continue;

		/* collect priority name */
		for (bp = buf; *q && !strchr("\t,;", *q); )
			*bp++ = *q++;
		*bp = '\0';

		/* skip cruft */
		while (strchr(", ;", *q))
			q++;

		/* decode priority name */
		if (*buf == '*')
			pri = LOG_PRIMASK + 1;
		else {
			/* ignore trailing spaces */
			int i;
			for (i=strlen(buf)-1; i >= 0 && buf[i] == ' '; i--) {
				buf[i]='\0';
			}

			pri = decode(buf, prioritynames);
			if (pri < 0) {
				(void)snprintf(ebuf, sizeof ebuf,
				    "unknown priority name \"%s\"", buf);
				logerror(ebuf);
				return;
			}
		}

		/* scan facilities */
		while (*p && !strchr("\t.;", *p)) {
			for (bp = buf; *p && !strchr("\t,;.", *p); )
				*bp++ = *p++;
			*bp = '\0';
			if (*buf == '*')
				for (i = 0; i < LOG_NFACILITIES; i++)
					f->f_pmask[i] = pri;
			else {
				i = decode(buf, facilitynames);
				if (i < 0) {
					(void)snprintf(ebuf, sizeof(ebuf),
					    "unknown facility name \"%s\"",
					    buf);
					logerror(ebuf);
					return;
				}
				f->f_pmask[i >> 3] = pri;
			}
			while (*p == ',' || *p == ' ')
				p++;
		}

		p = q;
	}

	/* skip to action part */
	while (*p == '\t')
		p++;

	switch (*p) {
	case '@@':
		if (!InetInuse)
			break;
		(void)strlcpy(f->f_un.f_forw.f_hname, ++p,
		    sizeof(f->f_un.f_forw.f_hname));
		hp = gethostbyname(f->f_un.f_forw.f_hname);
		if (hp == NULL) {
			extern int h_errno;

			logerror((char *)hstrerror(h_errno));
			break;
		}
		memset(&f->f_un.f_forw.f_addr, 0,
		    sizeof(f->f_un.f_forw.f_addr));
		f->f_un.f_forw.f_addr.sin_len = sizeof(f->f_un.f_forw.f_addr);
		f->f_un.f_forw.f_addr.sin_family = AF_INET;
		f->f_un.f_forw.f_addr.sin_port = LogPort;
		memmove(&f->f_un.f_forw.f_addr.sin_addr, hp->h_addr,
		    hp->h_length);
		f->f_type = F_FORW;
		break;

	case '/':
		(void)strlcpy(f->f_un.f_fname, p, sizeof(f->f_un.f_fname));
		f->f_file = open(p, O_WRONLY|O_APPEND|O_NONBLOCK, 0);
		if (f->f_file < 0) {
			f->f_type = F_UNUSED;
			logerror(p);
			break;
		}
		if (isatty(f->f_file)) {
			if (strcmp(p, ctty) == 0)
				f->f_type = F_CONSOLE;
			else
				f->f_type = F_TTY;
		} else {
			f->f_type = F_FILE;
			/* Clear O_NONBLOCK flag on f->f_file */
			if ((i = fcntl(f->f_file, F_GETFL, 0)) != -1) {
				i &= ~O_NONBLOCK;
				fcntl(f->f_file, F_SETFL, i);
			}
		}
		break;

	case '*':
		f->f_type = F_WALL;
		break;

	default:
		for (i = 0; i < MAXUNAMES && *p; i++) {
			for (q = p; *q && *q != ','; )
				q++;
			(void)strncpy(f->f_un.f_uname[i], p, UT_NAMESIZE);
			if ((q - p) > UT_NAMESIZE)
				f->f_un.f_uname[i][UT_NAMESIZE] = '\0';
			else
				f->f_un.f_uname[i][q - p] = '\0';
			while (*q == ',' || *q == ' ')
				q++;
			p = q;
		}
		f->f_type = F_USERS;
		break;
	}
}


/*
 * Retrieve the size of the kernel message buffer, via sysctl.
 */
int
getmsgbufsize(void)
{
	int msgbufsize, mib[2];
	size_t size;

	mib[0] = CTL_KERN;
	mib[1] = KERN_MSGBUFSIZE;
	size = sizeof msgbufsize;
	if (sysctl(mib, 2, &msgbufsize, &size, NULL, 0) == -1) {
		dprintf("couldn't get kern.msgbufsize\n");
		return (0);
	}
	return (msgbufsize);
}

/*
 *  Decode a symbolic name to a numeric value
 */
int
decode(const char *name, CODE *codetab)
{
	CODE *c;
	char *p, buf[40];

	if (isdigit(*name))
		return (atoi(name));

	for (p = buf; *name && p < &buf[sizeof(buf) - 1]; p++, name++) {
		if (isupper(*name))
			*p = tolower(*name);
		else
			*p = *name;
	}
	*p = '\0';
	for (c = codetab; c->c_name; c++)
		if (!strcmp(buf, c->c_name))
			return (c->c_val);

	return (-1);
}

void
markit(void)
{
	struct filed *f;

	now = time((time_t *)NULL);
	MarkSeq += TIMERINTVL;
	if (MarkSeq >= MarkInterval) {
		logmsg(LOG_INFO, "-- MARK --",
		    LocalHostName, ADDDATE|MARK);
		MarkSeq = 0;
	}

	for (f = Files; f; f = f->f_next) {
		if (f->f_prevcount && now >= REPEATTIME(f)) {
			dprintf("flush %s: repeated %d times, %d sec.\n",
			    TypeNames[f->f_type], f->f_prevcount,
			    repeatinterval[f->f_repeatcount]);
			fprintlog(f, 0, (char *)NULL);
			BACKOFF(f);
		}
	}
	MarkSet = 0;
	(void)alarm(TIMERINTVL);
}
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD repository of CTM 3155 (roughly today at noon).
Mostly in order to go 3.3-current and ease further merges of
both OpenBSD and ELFdiffs after the MirBSD has been enabled
to build again.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.60 2003/03/21 19:28:58 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.60 2003/03/21 19:28:58 millert Exp $";
d503 1
a503 5
	/*
	 * Don't allow users to log kernel messages.
	 * NOTE: since LOG_KERN == 0 this will also match
	 *       messages with no facility specified.
	 */
d505 1
a505 1
		pri = LOG_USER | LOG_PRI(pri);
@


1.1.1.3
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.62 2003/05/17 19:44:06 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.62 2003/05/17 19:44:06 millert Exp $";
d847 1
a847 3
		/* must use strncpy since ut_* may not be NUL terminated */
		strncpy(line, ut.ut_line, sizeof(line) - 1);
		line[sizeof(line) - 1] = '\0';
@


1.1.1.4
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.63 2003/06/02 23:36:54 millert Exp $	*/
d15 5
a19 1
 * 3. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.63 2003/06/02 23:36:54 millert Exp $";
@


1.1.1.5
log
@Bring the entire base system and ports tree in sync with OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.64 2003/07/08 01:28:11 avsm Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: syslogd.c,v 1.64 2003/07/08 01:28:11 avsm Exp $";
d251 1
a251 6
			if (strlen(optarg) >= sizeof(sunx.sun_path)) {
				fprintf(stderr,
				    "syslogd: socket path too long, exiting\n");
				exit(1);
			} else
				funixn[0] = optarg;
@


1.1.1.6
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.65 2003/07/31 18:20:07 avsm Exp $	*/
d33 1
a33 1
static const char copyright[] =
d40 1
a40 1
static const char sccsid[] = "@@(#)syslogd.c	8.3 (Berkeley) 4/4/94";
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.65 2003/07/31 18:20:07 avsm Exp $";
d107 3
a109 1
#include "syslogd.h"
d111 1
a111 2
char *ConfFile = _PATH_LOGCONF;
const char ctty[] = _PATH_CONSOLE;
a114 1

d162 1
a162 1
				(f)->f_repeatcount = MAXREPEAT; \
a182 1
int	Startup = 1;		/* startup flag */
d186 1
a186 2
int	finet = -1;		/* Internet datagram socket */
int	fklog = -1;		/* Kernel log device socket */
d200 2
a201 2
void    cvthname(struct sockaddr_in *, char *, size_t);
int	decode(const char *, const CODE *);
d228 1
a228 1
	int ch, i, linesize, fdsrmax = 0;
a233 2
	char resolve[MAXHOSTNAMELEN];
	int lockpipe[2], nullfd = -1;
d280 3
a282 1
	if (Debug)
d301 8
a369 24
	dprintf("off & running....\n");

	chdir("/");

	if (!Debug) {
		char c;

		pipe(lockpipe);

		switch(fork()) {
		case -1:
			exit(1);
		case 0:
			setsid();
			nullfd = open(_PATH_DEVNULL, O_RDWR);
			close(lockpipe[0]);
			break;
		default:
			close(lockpipe[1]);
			read(lockpipe[0], &c, 1);
			_exit(0);
		}
	}

d372 1
a372 1
		fp = fopen(_PATH_LOGPID, "w");
d379 1
a379 3
	/* Privilege separation begins here */
	if (priv_init(ConfFile, NoDNS, lockpipe[1], nullfd, argv) < 0)
		errx(1, "unable to privsep");
a380 1
	/* Process is now unprivileged and inside a chroot */
a382 25
	Startup = 0;

	if (!Debug) {
		dup2(nullfd, STDIN_FILENO);
		dup2(nullfd, STDOUT_FILENO);
		dup2(nullfd, STDERR_FILENO);
		if (nullfd > 2)
			close(nullfd);
		close(lockpipe[1]);
	}

	/*
	 * Signal to the priv process that the initial config parsing is done
	 * so that it will reject any future attempts to open more files
	 */
	priv_config_parse_done();

	(void)signal(SIGHUP, doinit);
	(void)signal(SIGTERM, dodie);
	(void)signal(SIGINT, Debug ? dodie : SIG_IGN);
	(void)signal(SIGQUIT, Debug ? dodie : SIG_IGN);
	(void)signal(SIGCHLD, reapchild);
	(void)signal(SIGALRM, domark);
	(void)alarm(TIMERINTVL);

d448 1
a448 3
					cvthname(&frominet, resolve, sizeof resolve);
					dprintf("cvthname res: %s\n", resolve);
					printline(resolve, line);
d507 1
a507 1
	 * messages with no facility specified.
d616 1
a616 1
		f->f_file = priv_open_tty(ctty);
d794 2
a795 1
				f->f_file = priv_open_tty(f->f_un.f_fname);
d839 1
a839 1
	if ((uf = priv_open_utmp()) == NULL) {
d891 2
a892 2
void
cvthname(struct sockaddr_in *f, char *result, size_t res_len)
d894 1
d896 2
a897 2
	char *p, *ip;
	int ret_len;
d901 1
a901 2
		strlcpy(result, "???", res_len);
		return;
d906 2
a907 4
	if (NoDNS) {
		strlcpy(result, ip, res_len);
		return;
	}
d912 2
a913 4

	ret_len = priv_gethostbyaddr((char *)&f->sin_addr,
		sizeof(struct in_addr), f->sin_family, result, res_len);

d915 1
a915 1
	if (ret_len == 0) {
d917 3
a919 2
		strlcpy(result, ip, res_len);
	} else if ((p = strchr(result, '.')) && strcmp(p + 1, LocalDomain) == 0)
d921 1
d957 1
a957 4
	if (Startup)
		fprintf(stderr, "%s\n", buf);
	else
		logmsg(LOG_SYSLOG|LOG_ERR, buf, LocalHostName, ADDDATE);
d966 1
d982 3
a984 1
	dprintf("[unpriv] syslogd child about to exit\n");
a1000 6
	/* If config file has been modified, then just die to restart */
	if (priv_config_modified()) {
		dprintf("config file changed: dying\n");
		die(0);
	}

d1028 1
a1028 1
	if ((cf = priv_open_config()) == NULL) {
d1128 2
a1129 1
	int i, pri, addr_len;
a1131 1
	char addr[MAXHOSTNAMELEN];
d1222 4
a1225 3
		addr_len = priv_gethostbyname(f->f_un.f_forw.f_hname,
		    addr, sizeof addr);
		if (addr_len < 1) {
d1234 2
a1235 1
		memmove(&f->f_un.f_forw.f_addr.sin_addr, addr, addr_len);
d1241 1
a1241 4
		if (strcmp(p, ctty) == 0)
			f->f_file = priv_open_tty(p);
		else
			f->f_file = priv_open_log(p);
d1308 1
a1308 1
decode(const char *name, const CODE *codetab)
d1310 1
a1310 1
	const CODE *c;
@


1.1.1.7
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.66 2003/08/18 16:56:31 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.66 2003/08/18 16:56:31 millert Exp $";
a366 2

	tzset();
@


1.1.1.8
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.67 2003/09/19 08:15:55 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.67 2003/09/19 08:15:55 deraadt Exp $";
d277 1
@


1.1.1.9
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.69 2003/12/29 22:08:44 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.69 2003/12/29 22:08:44 deraadt Exp $";
a95 1
#include <poll.h>
a181 2
int	nfunix = 1;		/* Number of Unix domain sockets requested */
char	*funixn[MAXFUNIX] = { _PATH_LOG }; /* Paths to Unix domain sockets */
d187 2
a196 2
struct pollfd pfd[N_PFD];

d221 6
d230 1
a230 1
	int ch, i, linesize, fd;
d234 1
d267 2
a268 2
				fprintf(stderr, "syslogd: "
				    "out of descriptors, ignoring %s\n",
a301 6
	/* Clear poll array, set all fds to ignore */
	for (i = 0; i < N_PFD; i++) {
		pfd[i].fd = -1;
		pfd[i].events = 0;
	}

d307 1
d311 4
a314 2
		if ((fd = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1 ||
		    bind(fd, (struct sockaddr *)&sunx, SUN_LEN(&sunx)) == -1 ||
d322 7
a328 9
		} else {
			/* double socket receive buffer size */
			if (getsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len,
			    &slen) == 0) {
				len *= 2;
				(void)setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len, slen);
			}
			pfd[PFD_UNIX_0 + i].fd = fd;
			pfd[PFD_UNIX_0 + i].events = POLLIN;
d331 2
a332 2

	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) != -1) {
a334 1
		/* XXX use getaddrinfo */
d345 1
a345 1
		if (bind(fd, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
d352 1
a352 1
			if (getsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len,
d355 1
a355 1
				(void)setsockopt(fd, SOL_SOCKET,
a357 2
			pfd[PFD_INET].fd = fd;
			pfd[PFD_INET].events = POLLIN;
d360 1
a360 1
	if ((fd = open(_PATH_KLOG, O_RDONLY, 0)) == -1) {
a361 4
	} else {
		pfd[PFD_KLOG].fd = fd;
		pfd[PFD_KLOG].events = POLLIN;
	}
d430 14
d455 13
a467 1
		switch (poll(pfd, PFD_UNIX_0 + nfunix, -1)) {
d472 1
a472 1
				logerror("poll");
d475 3
a477 2
		if ((pfd[PFD_KLOG].revents & POLLIN) != 0) {
			i = read(pfd[PFD_KLOG].fd, line, linesize - 1);
d483 1
a483 2
				pfd[PFD_KLOG].fd = -1;
				pfd[PFD_KLOG].events = 0;
d486 1
a486 1
		if ((pfd[PFD_INET].revents & POLLIN) != 0) {
d488 1
a488 1
			i = recvfrom(pfd[PFD_INET].fd, line, MAXLINE, 0,
d495 1
a495 2
					cvthname(&frominet, resolve,
					    sizeof resolve);
d504 1
a504 1
			if ((pfd[PFD_UNIX_0 + i].revents & POLLIN) != 0) {
d506 2
a507 3
				len = recvfrom(pfd[PFD_UNIX_0 + i].fd, line,
				    MAXLINE, 0, (struct sockaddr *)&fromunix,
				    &len);
d516 2
a517 3
	/* NOTREACHED */
	free(pfd);
	return (0);
d803 1
a803 1
		if (sendto(pfd[PFD_INET].fd, line, l, 0,
a1411 1

@


1.1.1.10
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.74 2004/01/19 16:06:05 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.74 2004/01/19 16:06:05 millert Exp $";
a65 1
 * memory buffer logging by Damien Miller
a68 3
#define MIN_MEMBUF	(MAXLINE * 4)	/* Minimum memory buffer size */
#define MAX_MEMBUF	(256 * 1024)	/* Maximum memory buffer size */
#define MAX_MEMBUF_NAME	64		/* Max length of membuf log name */
a143 4
		struct {
			char	f_mname[MAX_MEMBUF_NAME];
			struct ringbuf *f_rb;
		} f_mb;		/* Memory buffer */
a173 1
#define F_MEMBUF	7		/* memory buffer */
d175 1
a175 1
char	*TypeNames[8] = {
d177 1
a177 1
	"FORW",		"USERS",	"WALL",		"MEMBUF"
a197 20
char	*ctlsock_path = NULL;	/* Path to control socket */

#define CTL_READING_CMD		1
#define CTL_WRITING_REPLY	2
int	ctl_state = 0;		/* What the control socket is up to */

size_t	ctl_cmd_bytes = 0;	/* number of bytes of ctl_cmd read */
struct	{
#define CMD_READ	1	/* Read out log */
#define CMD_READ_CLEAR	2	/* Read and clear log */
#define CMD_CLEAR	3	/* Clear log */
#define CMD_LIST	4	/* List available logs */
	int	cmd;
	char	logname[MAX_MEMBUF_NAME];
}	ctl_cmd;

char	*ctl_reply = NULL;	/* Buffer for control connection reply */
size_t	ctl_reply_size = 0;	/* Number of bytes used in reply */
size_t	ctl_reply_offset = 0;	/* Number of bytes of reply written so far */

a222 5
int	unix_socket(char *, int, mode_t);
void	double_rbuf(int);
void	ctlsock_accept_handler(void);
void	ctlconn_read_handler(void);
void	ctlconn_write_handler(void);
d228 1
a228 1
	struct sockaddr_un fromunix;
d230 1
a230 1
	socklen_t len;
d236 1
a236 1
	while ((ch = getopt(argc, argv, "dnuf:m:p:a:s:")) != -1)
d251 6
a256 1
			funixn[0] = optarg;
d266 4
a272 3
		case 's':
			ctlsock_path = optarg;
			break;
d296 1
a296 4
	if ((line = malloc(linesize)) == NULL) {
		logerror("Couldn't allocate line buffer");
		die(0);
	}
d308 11
a318 1
		if ((fd = unix_socket(funixn[i], SOCK_DGRAM, 0666)) == -1) {
d321 9
a329 1
			continue;
a330 3
		double_rbuf(fd);
		pfd[PFD_UNIX_0 + i].fd = fd;
		pfd[PFD_UNIX_0 + i].events = POLLIN;
d353 7
a359 1
			double_rbuf(fd);
a363 12

	if (ctlsock_path != NULL) {
		if ((fd = unix_socket(ctlsock_path, SOCK_STREAM, 0600)) == -1)
			die(0);
		if (listen(fd, 16) == -1) {
			logerror("ctlsock listen");
			die(0);
		}
		pfd[PFD_CTLSOCK].fd = fd;
		pfd[PFD_CTLSOCK].events = POLLIN;
	}

a414 7
	/* Allocate ctl socket reply buffer if we have a ctl socket */
	if (pfd[PFD_CTLSOCK].fd != -1 &&
	    (ctl_reply = malloc(MAX_MEMBUF)) == NULL) {
		logerror("Couldn't allocate ctlsock reply buffer");
		die(0);
	}

a435 1
	(void)signal(SIGPIPE, SIG_IGN);
a456 1

a484 6
		if ((pfd[PFD_CTLSOCK].revents & POLLIN) != 0)
			ctlsock_accept_handler();
		if ((pfd[PFD_CTLCONN].revents & POLLIN) != 0)
			ctlconn_read_handler();
		if ((pfd[PFD_CTLCONN].revents & POLLOUT) != 0)
			ctlconn_write_handler();
d510 2
a511 2
	    "usage: syslogd [-dnu] [-a path] [-f config_file] [-m mark_interval]\n"
	    "               [-p log_socket] [-s reporting_socket]\n");
a850 7

	case F_MEMBUF:
		dprintf("\n");
		snprintf(line, sizeof(line), "%.15s %s",
		    (char *)iov[0].iov_base, (char *)iov[4].iov_base);
		ringbuf_append_line(f->f_un.f_mb.f_rb, line);
		break;
a1150 5

			case F_MEMBUF:
				printf("%s", f->f_un.f_mb.f_mname);
				break;

a1169 1
	size_t rb_len;
a1172 1
	struct filed *xf;
a1307 46
	case ':':
		f->f_type = F_MEMBUF;

		/* Parse buffer size (in kb) */
		errno = 0;
		rb_len = strtoul(++p, &q, 0);
		if (*p == '\0' || (errno == ERANGE && rb_len == ULONG_MAX) ||
		    *q != ':' || rb_len == 0) {
			f->f_type = F_UNUSED;
			logerror(p);
			break;
		}
		q++;
		rb_len *= 1024;

		/* Copy buffer name */
		for(i = 0; i < sizeof(f->f_un.f_mb.f_mname) - 1; i++) {
			if (!isalnum(q[i]))
				break;
			f->f_un.f_mb.f_mname[i] = q[i];
		}

		/* Make sure buffer name is unique */
		for (xf = Files; i != 0 && xf != f; xf = xf->f_next) {
			if (xf->f_type == F_MEMBUF &&
			    strcmp(xf->f_un.f_mb.f_mname,
			    f->f_un.f_mb.f_mname) == 0)
				break;
		}

		/* Error on missing or non-unique name, or bad buffer length */
		if (i == 0 || rb_len > MAX_MEMBUF || xf != f) {
			f->f_type = F_UNUSED;
			logerror(p);
			break;
		}

		/* Allocate buffer */
		rb_len = MAX(rb_len, MIN_MEMBUF);
		if ((f->f_un.f_mb.f_rb = ringbuf_init(rb_len)) == NULL) {
			f->f_type = F_UNUSED;
			logerror(p);
			break;
		}
		break;

a1397 246
int
unix_socket(char *path, int type, mode_t mode)
{
	struct sockaddr_un s_un;
	char errbuf[512];
	int fd;
	mode_t old_umask;

	memset(&s_un, 0, sizeof(s_un));
	s_un.sun_family = AF_UNIX;
	if (strlcpy(s_un.sun_path, path, sizeof(s_un.sun_path)) >
	    sizeof(s_un.sun_path)) {
		snprintf(errbuf, sizeof(errbuf), "socket path too long: %s",
		    path);
		logerror(errbuf);
		die(0);
	}

	if ((fd = socket(AF_UNIX, type, 0)) == -1) {
		logerror("socket");
		return (-1);
	}

	old_umask = umask(0177);

	unlink(path);
	if (bind(fd, (struct sockaddr *)&s_un, SUN_LEN(&s_un)) == -1) {
		snprintf(errbuf, sizeof(errbuf), "cannot bind %s", path);
		logerror(errbuf);
		umask(old_umask);
		close(fd);
		return (-1);
	}

	umask(old_umask);

	if (chmod(path, mode) == -1) {
		snprintf(errbuf, sizeof(errbuf), "cannot chmod %s", path);
		logerror(errbuf);
		close(fd);
		unlink(path);
		return (-1);
	}

	return (fd);
}

void
double_rbuf(int fd)
{
	socklen_t slen, len;

	if (getsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len, &slen) == 0) {
		len *= 2;
		setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len, slen);
	}
}

static void
ctlconn_cleanup(void)
{
	if (pfd[PFD_CTLCONN].fd != -1)
		close(pfd[PFD_CTLCONN].fd);

	pfd[PFD_CTLCONN].fd = -1;
	pfd[PFD_CTLCONN].events = pfd[PFD_CTLCONN].revents = 0;

	pfd[PFD_CTLSOCK].events = POLLIN;

	ctl_state = ctl_cmd_bytes = ctl_reply_offset = ctl_reply_size = 0;
}

void
ctlsock_accept_handler(void)
{
	int fd, flags;

	dprintf("Accepting control connection\n");
	fd = accept(pfd[PFD_CTLSOCK].fd, NULL, NULL);
	if (fd == -1) {
		if (errno != EINTR && errno != ECONNABORTED)
			logerror("accept ctlsock");
		return;
	}

	ctlconn_cleanup();

	/* Only one connection at a time */
	pfd[PFD_CTLSOCK].events = pfd[PFD_CTLSOCK].revents = 0;

	if ((flags = fcntl(fd, F_GETFL)) == -1 ||
	    fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
		logerror("fcntl ctlconn");
		close(fd);
		return;
	}

	pfd[PFD_CTLCONN].fd = fd;
	pfd[PFD_CTLCONN].events = POLLIN;
	ctl_state = CTL_READING_CMD;
	ctl_cmd_bytes = 0;
}

static struct filed
*find_membuf_log(const char *name)
{
	struct filed *f;

	for (f = Files; f != NULL; f = f->f_next) {
		if (f->f_type == F_MEMBUF &&
		    strcmp(f->f_un.f_mb.f_mname, name) == 0)
			break;
	}
	return (f);
}

void
ctlconn_read_handler(void)
{
	ssize_t n;
	struct filed *f;

	if (ctl_state != CTL_READING_CMD) {
		/* Shouldn't be here! */
		logerror("ctlconn_read with bad ctl_state");
		ctlconn_cleanup();
		return;
	}
 retry:
	n = read(pfd[PFD_CTLCONN].fd, (char*)&ctl_cmd + ctl_cmd_bytes,
	    sizeof(ctl_cmd) - ctl_cmd_bytes);
	switch (n) {
	case -1:
		if (errno == EINTR)
			goto retry;
		logerror("ctlconn read");
		/* FALLTHROUGH */
	case 0:
		ctlconn_cleanup();
		return;
	default:
		ctl_cmd_bytes += n;
	}

	if (ctl_cmd_bytes < sizeof(ctl_cmd))
		return;

	/* Ensure that logname is \0 terminated */
	if (memchr(ctl_cmd.logname, '\0', sizeof(ctl_cmd.logname)) == NULL) {
		logerror("Corrupt ctlsock command");
		ctlconn_cleanup();
		return;
	}

	ctl_reply_size = ctl_reply_offset = 0;
	*ctl_reply = '\0';

	dprintf("ctlcmd %x logname \"%s\"\n", ctl_cmd.cmd, ctl_cmd.logname);

	switch (ctl_cmd.cmd) {
	case CMD_READ:
	case CMD_READ_CLEAR:
		f = find_membuf_log(ctl_cmd.logname);
		if (f == NULL) {
			strlcpy(ctl_reply, "No such log\n", MAX_MEMBUF);
		} else {
			ringbuf_to_string(ctl_reply, MAX_MEMBUF,
			    f->f_un.f_mb.f_rb);
		}
		ctl_reply_size = strlen(ctl_reply);

		if (ctl_cmd.cmd == CMD_READ_CLEAR)
			ringbuf_clear(f->f_un.f_mb.f_rb);
		break;
	case CMD_CLEAR:
		f = find_membuf_log(ctl_cmd.logname);
		if (f == NULL) {
			strlcpy(ctl_reply, "No such log\n", MAX_MEMBUF);
		} else {
			ringbuf_clear(f->f_un.f_mb.f_rb);
			strlcpy(ctl_reply, "Log cleared\n", MAX_MEMBUF);
		}
		ctl_reply_size = strlen(ctl_reply);
		break;
	case CMD_LIST:
		for (f = Files; f != NULL; f = f->f_next) {
			if (f->f_type == F_MEMBUF) {
				strlcat(ctl_reply, f->f_un.f_mb.f_mname,
				    MAX_MEMBUF);
				strlcat(ctl_reply, " ", MAX_MEMBUF);
			}
		}
		strlcat(ctl_reply, "\n", MAX_MEMBUF);
		ctl_reply_size = strlen(ctl_reply);
		break;
	default:
		logerror("Unsupported ctlsock command");
		ctlconn_cleanup();
		return;
	}

	dprintf("ctlcmd reply length %d\n", ctl_reply_size);

	/* If there is no reply, close the connection now */
	if (ctl_reply_size == 0) {
		ctlconn_cleanup();
		return;
	}

	/* Otherwise, set up to write out reply */
	ctl_state = CTL_WRITING_REPLY;
	pfd[PFD_CTLCONN].events = POLLOUT;
	pfd[PFD_CTLCONN].revents = 0;
}

void
ctlconn_write_handler(void)
{
	ssize_t n;

	if (ctl_state != CTL_WRITING_REPLY) {
		/* Shouldn't be here! */
		logerror("ctlconn_write with bad ctl_state");
		ctlconn_cleanup();
		return;
	}
 retry:
	n = write(pfd[PFD_CTLCONN].fd, ctl_reply + ctl_reply_offset,
	    ctl_reply_size - ctl_reply_offset);
	switch (n) {
	case -1:
		if (errno == EINTR)
			goto retry;
		if (errno != EPIPE)
			logerror("ctlconn write");
		/* FALLTHROUGH */
	case 0:
		ctlconn_cleanup();
		return;
	default:
		ctl_reply_offset += n;
	}

	if (ctl_reply_offset >= ctl_reply_size)
		ctlconn_cleanup();
}
@


1.1.1.11
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslogd.c,v 1.76 2004/04/15 18:13:07 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: syslogd.c,v 1.76 2004/04/15 18:13:07 millert Exp $";
d335 14
a374 14
#ifndef SUN_LEN
#define SUN_LEN(unp) (strlen((unp)->sun_path) + 2)
#endif
	for (i = 0; i < nfunix; i++) {
		if ((fd = unix_socket(funixn[i], SOCK_DGRAM, 0666)) == -1) {
			if (i == 0 && !Debug)
				die(0);
			continue;
		}
		double_rbuf(fd);
		pfd[PFD_UNIX_0 + i].fd = fd;
		pfd[PFD_UNIX_0 + i].events = POLLIN;
	}

d376 4
a379 9
		fd = unix_socket(ctlsock_path, SOCK_STREAM, 0600);
		if (fd != -1) {
			if (listen(fd, 16) == -1) {
				logerror("ctlsock listen");
				die(0);
			}
			pfd[PFD_CTLSOCK].fd = fd;
			pfd[PFD_CTLSOCK].events = POLLIN;
		} else if (!Debug)
d381 3
a1517 10
	if (Debug) {
		if (connect(fd, (struct sockaddr *)&s_un, sizeof(s_un)) == 0 ||
		    errno == EPROTOTYPE) {
			close(fd);
			errno = EISCONN;
			logerror("connect");
			return (-1);
		}
	}

a1662 2
			if (ctl_cmd.cmd == CMD_READ_CLEAR)
				ringbuf_clear(f->f_un.f_mb.f_rb);
d1665 3
@


