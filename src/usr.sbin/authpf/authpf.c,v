head	1.9;
access;
symbols
	tg-mergetmp-mirosx-1:1.9
	tg-mergefixes-1-branch:1.9.0.8
	tg-mergefixes-1-base:1.9
	MIROS_X:1.9.0.6
	MIROS_X_BASE:1.9
	tg-mergetmp-3:1.9
	MIRBSD_XP_MIRPPC:1.9.0.4
	MIRBSD_XP_SPARC_BASE:1.9
	MIRBSD_XP_SPARC:1.9.0.2
	MIRBSD_7quater:1.1.1.12
	cvs-200405160640:1.1.1.15
	cvs-200401271800:1.1.1.14
	cvs-200401261630:1.1.1.14
	cvs-200401021645:1.1.1.13
	MIRBSD_7_ALPHA:1.1.1.12.0.6
	MIRBSD_7:1.1.1.12.0.4
	cvs-200312222040:1.1.1.13
	MIRBSD_7ter:1.1.1.12
	MIRBSD_7_DEV:1.1.1.12.0.2
	cvs-200310020700:1.1.1.12
	cvs-200309271030:1.1.1.12
	cvs-200309261655:1.1.1.11
	cvs-200309251530:1.1.1.10
	cvs-200308302005:1.1.1.10
	cvs-200308171200:1.1.1.9
	ctm-3496:1.1.1.9
	ctm-3449:1.1.1.8
	ctm-3437:1.1.1.8
	cvs-200307191805:1.1.1.8
	ctm-3425:1.1.1.8
	cvs-200307091500:1.1.1.7
	ctm-3389:1.1.1.6
	cvs-200306291430:1.1.1.5
	ctm-3341:1.1.1.4
	MIRBSD_5:1.5
	cvs-200306082100:1.1.1.4
	ctm-3316:1.1.1.4
	ctm-3272:1.1.1.3
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.2
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2004.06.11.21.40.22;	author tg;	state Stab;
branches;
next	1.8;

1.8
date	2004.01.27.17.42.57;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.27.00.31.36;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.30.05.56.19;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.06.18.30.32;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.22.14.09.17;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.07.20.54.55;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.53.57;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.54.17;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.54.17;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.55.48;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.21.19.22.45;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.05.17.46.41;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.06.29.17.39.06;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.07.06.15.53.32;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.07.09.16.52.02;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.07.18.13.55.49;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.08.11.18.50.02;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.08.30.23.46.25;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2003.09.26.17.04.53;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2003.09.27.11.23.32;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2003.12.22.21.17.59;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2004.01.26.19.05.42;	author tg;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2004.05.16.07.19.17;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@long int != time_t
@
text
@/*	$OpenBSD: authpf.c,v 1.81 2004/05/13 17:14:55 henning Exp $	*/

/*
 * Copyright (C) 1998 - 2002 Bob Beck (beck@@openbsd.org).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <net/if.h>
#include <net/pfvar.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <login_cap.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "pathnames.h"

extern int	symset(const char *, const char *, int);

static int	read_config(FILE *);
static void	print_message(char *);
static int	allowed_luser(char *);
static int	check_luser(char *, char *);
static int	remove_stale_rulesets(void);
static int	change_filter(int, const char *, const char *);
static int	change_table(int, const char *, const char *);
static void	authpf_kill_states(void);

int	dev;			/* pf device */
char	anchorname[PF_ANCHOR_NAME_SIZE] = "authpf";
char	tablename[PF_TABLE_NAME_SIZE] = "authpf_users";
char	rulesetname[PF_RULESET_NAME_SIZE];

FILE	*pidfp;
char	*infile;		/* file name printed by yyerror() in parse.y */
char	 luser[MAXLOGNAME];	/* username */
char	 ipsrc[256];		/* ip as a string */
char	 pidfile[MAXPATHLEN];	/* we save pid in this file. */

struct timeval	Tstart, Tend;	/* start and end times of session */

volatile sig_atomic_t	want_death;
static void		need_death(int signo);
static __dead void	do_death(int);

/*
 * User shell for authenticating gateways. Sole purpose is to allow
 * a user to ssh to a gateway, and have the gateway modify packet
 * filters to allow access, then remove access when the user finishes
 * up. Meant to be used only from ssh(1) connections.
 */
int
main(int argc, char *argv[])
{
	int		 lockcnt = 0, n, pidfd;
	FILE		*config;
	struct in6_addr	 ina;
	struct passwd	*pw;
	char		*cp;
	uid_t		 uid;
	char		*shell;
	login_cap_t	*lc;

	config = fopen(PATH_CONFFILE, "r");

	if ((cp = getenv("SSH_TTY")) == NULL) {
		syslog(LOG_ERR, "non-interactive session connection for authpf");
		exit(1);
	}

	if ((cp = getenv("SSH_CLIENT")) == NULL) {
		syslog(LOG_ERR, "cannot determine connection source");
		exit(1);
	}

	if (strlcpy(ipsrc, cp, sizeof(ipsrc)) >= sizeof(ipsrc)) {
		syslog(LOG_ERR, "SSH_CLIENT variable too long");
		exit(1);
	}
	cp = strchr(ipsrc, ' ');
	if (!cp) {
		syslog(LOG_ERR, "corrupt SSH_CLIENT variable %s", ipsrc);
		exit(1);
	}
	*cp = '\0';
	if (inet_pton(AF_INET, ipsrc, &ina) != 1 &&
	    inet_pton(AF_INET6, ipsrc, &ina) != 1) {
		syslog(LOG_ERR,
		    "cannot determine IP from SSH_CLIENT %s", ipsrc);
		exit(1);
	}
	/* open the pf device */
	dev = open(PATH_DEVFILE, O_RDWR);
	if (dev == -1) {
		syslog(LOG_ERR, "cannot open packet filter device (%m)");
		goto die;
	}

	uid = getuid();
	pw = getpwuid(uid);
	endpwent();
	if (pw == NULL) {
		syslog(LOG_ERR, "cannot find user for uid %u", uid);
		goto die;
	}

	if ((lc = login_getclass(pw->pw_class)) != NULL)
		shell = login_getcapstr(lc, "shell", pw->pw_shell,
		    pw->pw_shell);
	else
		shell = pw->pw_shell;

	login_close(lc);
	
	if (strcmp(shell, PATH_AUTHPF_SHELL)) {
		syslog(LOG_ERR, "wrong shell for user %s, uid %u",
		    pw->pw_name, pw->pw_uid);
		if (shell != pw->pw_shell)
			free(shell);
		goto die;
	}

	if (shell != pw->pw_shell)
		free(shell);

	/*
	 * Paranoia, but this data _does_ come from outside authpf, and
	 * truncation would be bad.
	 */
	if (strlcpy(luser, pw->pw_name, sizeof(luser)) >= sizeof(luser)) {
		syslog(LOG_ERR, "username too long: %s", pw->pw_name);
		goto die;
	}

	if ((n = snprintf(rulesetname, sizeof(rulesetname), "%s(%ld)",
	    luser, (long)getpid())) < 0 || n >= sizeof(rulesetname)) {
		syslog(LOG_INFO, "%s(%ld) too large, ruleset name will be %ld",
		    luser, (long)getpid(), (long)getpid());
		if ((n = snprintf(rulesetname, sizeof(rulesetname), "%ld",
		    (long)getpid())) < 0 || n >= sizeof(rulesetname)) {
			syslog(LOG_ERR, "pid too large for ruleset name");
			goto die;
		}
	}


	/* Make our entry in /var/authpf as /var/authpf/ipaddr */
	n = snprintf(pidfile, sizeof(pidfile), "%s/%s", PATH_PIDFILE, ipsrc);
	if (n < 0 || (u_int)n >= sizeof(pidfile)) {
		syslog(LOG_ERR, "path to pidfile too long");
		goto die;
	}

	/*
	 * If someone else is already using this ip, then this person
	 * wants to switch users - so kill the old process and exit
	 * as well.
	 *
	 * Note, we could print a message and tell them to log out, but the
	 * usual case of this is that someone has left themselves logged in,
	 * with the authenticated connection iconized and someone else walks
	 * up to use and automatically logs in before using. If this just
	 * gets rid of the old one silently, the new user never knows they
	 * could have used someone else's old authentication. If we
	 * tell them to log out before switching users it is an invitation
	 * for abuse.
	 */

	do {
		int	save_errno, otherpid = -1;
		char	otherluser[MAXLOGNAME];

		if ((pidfd = open(pidfile, O_RDWR|O_CREAT, 0644)) == -1 ||
		    (pidfp = fdopen(pidfd, "r+")) == NULL) {
			if (pidfd != -1)
				close(pidfd);
			syslog(LOG_ERR, "cannot open or create %s: %s", pidfile,
			    strerror(errno));
			goto die;
		}

		if (flock(fileno(pidfp), LOCK_EX|LOCK_NB) == 0)
			break;
		save_errno = errno;

		/* Mark our pid, and username to our file. */

		rewind(pidfp);
		/* 31 == MAXLOGNAME - 1 */
		if (fscanf(pidfp, "%d\n%31s\n", &otherpid, otherluser) != 2)
			otherpid = -1;
		syslog(LOG_DEBUG, "tried to lock %s, in use by pid %d: %s",
		    pidfile, otherpid, strerror(save_errno));

		if (otherpid > 0) {
			syslog(LOG_INFO,
			    "killing prior auth (pid %d) of %s by user %s",
			    otherpid, ipsrc, otherluser);
			if (kill((pid_t) otherpid, SIGTERM) == -1) {
				syslog(LOG_INFO,
				    "could not kill process %d: (%m)",
				    otherpid);
			}
		}

		/*
		 * we try to kill the previous process and acquire the lock
		 * for 10 seconds, trying once a second. if we can't after
		 * 10 attempts we log an error and give up
		 */
		if (++lockcnt > 10) {
			syslog(LOG_ERR, "cannot kill previous authpf (pid %d)",
			    otherpid);
			goto dogdeath;
		}
		sleep(1);

		/* re-open, and try again. The previous authpf process
		 * we killed above should unlink the file and release
		 * it's lock, giving us a chance to get it now
		 */
		fclose(pidfp);
	} while (1);

	/* revoke privs */
	seteuid(getuid());
	setuid(getuid());

	openlog("authpf", LOG_PID | LOG_NDELAY, LOG_DAEMON);

	if (!check_luser(PATH_BAN_DIR, luser) || !allowed_luser(luser)) {
		syslog(LOG_INFO, "user %s prohibited", luser);
		do_death(0);
	}

	if (config == NULL || read_config(config)) {
		syslog(LOG_INFO, "bad or nonexistent %s", PATH_CONFFILE);
		do_death(0);
	}

	if (remove_stale_rulesets()) {
		syslog(LOG_INFO, "error removing stale rulesets");
		do_death(0);
	}

	/* We appear to be making headway, so actually mark our pid */
	rewind(pidfp);
	fprintf(pidfp, "%ld\n%s\n", (long)getpid(), luser);
	fflush(pidfp);
	(void) ftruncate(fileno(pidfp), ftell(pidfp));

	if (change_filter(1, luser, ipsrc) == -1) {
		printf("Unable to modify filters\r\n");
		do_death(0);
	}
	if (change_table(1, luser, ipsrc) == -1) {
		printf("Unable to modify table\r\n");
		change_filter(0, luser, ipsrc);
		do_death(0);
	}

	signal(SIGTERM, need_death);
	signal(SIGINT, need_death);
	signal(SIGALRM, need_death);
	signal(SIGPIPE, need_death);
	signal(SIGHUP, need_death);
	signal(SIGSTOP, need_death);
	signal(SIGTSTP, need_death);
	while (1) {
		printf("\r\nHello %s, ", luser);
		printf("You are authenticated from host \"%s\"\r\n", ipsrc);
		setproctitle("%s@@%s", luser, ipsrc);
		print_message(PATH_MESSAGE);
		while (1) {
			sleep(10);
			if (want_death)
				do_death(1);
		}
	}

	/* NOTREACHED */
dogdeath:
	printf("\r\n\r\nSorry, this service is currently unavailable due to ");
	printf("technical difficulties\r\n\r\n");
	print_message(PATH_PROBLEM);
	printf("\r\nYour authentication process (pid %ld) was unable to run\n",
	    (long)getpid());
	sleep(180); /* them lusers read reaaaaal slow */
die:
	do_death(0);
}

/*
 * reads config file in PATH_CONFFILE to set optional behaviours up
 */
static int
read_config(FILE *f)
{
	char	buf[1024];
	int	i = 0;

	do {
		char	**ap;
		char	 *pair[4], *cp, *tp;
		int	  len;

		if (fgets(buf, sizeof(buf), f) == NULL) {
			fclose(f);
			return (0);
		}
		i++;
		len = strlen(buf);
		if (buf[len - 1] != '\n' && !feof(f)) {
			syslog(LOG_ERR, "line %d too long in %s", i,
			    PATH_CONFFILE);
			return (1);
		}
		buf[len - 1] = '\0';

		for (cp = buf; *cp == ' ' || *cp == '\t'; cp++)
			; /* nothing */

		if (!*cp || *cp == '#' || *cp == '\n')
			continue;

		for (ap = pair; ap < &pair[3] &&
		    (*ap = strsep(&cp, "=")) != NULL; ) {
			if (**ap != '\0')
				ap++;
		}
		if (ap != &pair[2])
			goto parse_error;

		tp = pair[1] + strlen(pair[1]);
		while ((*tp == ' ' || *tp == '\t') && tp >= pair[1])
			*tp-- = '\0';

		if (strcasecmp(pair[0], "anchor") == 0) {
			if (!pair[1][0] || strlcpy(anchorname, pair[1],
			    sizeof(anchorname)) >= sizeof(anchorname))
				goto parse_error;
		}
		if (strcasecmp(pair[0], "table") == 0) {
			if (!pair[1][0] || strlcpy(tablename, pair[1],
			    sizeof(tablename)) >= sizeof(tablename))
				goto parse_error;
		}
	} while (!feof(f) && !ferror(f));
	fclose(f);
	return (0);

parse_error:
	fclose(f);
	syslog(LOG_ERR, "parse error, line %d of %s", i, PATH_CONFFILE);
	return (1);
}


/*
 * splatter a file to stdout - max line length of 1024,
 * used for spitting message files at users to tell them
 * they've been bad or we're unavailable.
 */
static void
print_message(char *filename)
{
	char	 buf[1024];
	FILE	*f;

	if ((f = fopen(filename, "r")) == NULL)
		return; /* fail silently, we don't care if it isn't there */

	do {
		if (fgets(buf, sizeof(buf), f) == NULL) {
			fflush(stdout);
			fclose(f);
			return;
		}
	} while (fputs(buf, stdout) != EOF && !feof(f));
	fflush(stdout);
	fclose(f);
}

/*
 * allowed_luser checks to see if user "luser" is allowed to
 * use this gateway by virtue of being listed in an allowed
 * users file, namely /etc/authpf/authpf.allow .
 *
 * If /etc/authpf/authpf.allow does not exist, then we assume that
 * all users who are allowed in by sshd(8) are permitted to
 * use this gateway. If /etc/authpf/authpf.allow does exist, then a
 * user must be listed if the connection is to continue, else
 * the session terminates in the same manner as being banned.
 */
static int
allowed_luser(char *luser)
{
	char	*buf, *lbuf;
	int	 matched;
	size_t	 len;
	FILE	*f;

	if ((f = fopen(PATH_ALLOWFILE, "r")) == NULL) {
		if (errno == ENOENT) {
			/*
			 * allowfile doesn't exist, thus this gateway
			 * isn't restricted to certain users...
			 */
			return (1);
		}

		/*
		 * luser may in fact be allowed, but we can't open
		 * the file even though it's there. probably a config
		 * problem.
		 */
		syslog(LOG_ERR, "cannot open allowed users file %s (%s)",
		    PATH_ALLOWFILE, strerror(errno));
		return (0);
	} else {
		/*
		 * /etc/authpf/authpf.allow exists, thus we do a linear
		 * search to see if they are allowed.
		 * also, if username "*" exists, then this is a
		 * "public" gateway, such as it is, so let
		 * everyone use it.
		 */
		lbuf = NULL;
		while ((buf = fgetln(f, &len))) {
			if (buf[len - 1] == '\n')
				buf[len - 1] = '\0';
			else {
				if ((lbuf = (char *)malloc(len + 1)) == NULL)
					err(1, NULL);
				memcpy(lbuf, buf, len);
				lbuf[len] = '\0';
				buf = lbuf;
			}

			matched = strcmp(luser, buf) == 0 || strcmp("*", buf) == 0;

			if (lbuf != NULL) {
				free(lbuf);
				lbuf = NULL;
			}

			if (matched)
				return (1); /* matched an allowed username */
		}
		syslog(LOG_INFO, "denied access to %s: not listed in %s",
		    luser, PATH_ALLOWFILE);

		/* reuse buf */
		buf = "\n\nSorry, you are not allowed to use this facility!\n";
		fputs(buf, stdout);
	}
	fflush(stdout);
	return (0);
}

/*
 * check_luser checks to see if user "luser" has been banned
 * from using us by virtue of having an file of the same name
 * in the "luserdir" directory.
 *
 * If the user has been banned, we copy the contents of the file
 * to the user's screen. (useful for telling the user what to
 * do to get un-banned, or just to tell them they aren't
 * going to be un-banned.)
 */
static int
check_luser(char *luserdir, char *luser)
{
	FILE	*f;
	int	 n;
	char	 tmp[MAXPATHLEN];

	n = snprintf(tmp, sizeof(tmp), "%s/%s", luserdir, luser);
	if (n < 0 || (u_int)n >= sizeof(tmp)) {
		syslog(LOG_ERR, "provided banned directory line too long (%s)",
		    luserdir);
		return (0);
	}
	if ((f = fopen(tmp, "r")) == NULL) {
		if (errno == ENOENT) {
			/*
			 * file or dir doesn't exist, so therefore
			 * this luser isn't banned..  all is well
			 */
			return (1);
		} else {
			/*
			 * luser may in fact be banned, but we can't open the
			 * file even though it's there. probably a config
			 * problem.
			 */
			syslog(LOG_ERR, "cannot open banned file %s (%s)",
			    tmp, strerror(errno));
			return (0);
		}
	} else {
		/*
		 * luser is banned - spit the file at them to
		 * tell what they can do and where they can go.
		 */
		syslog(LOG_INFO, "denied access to %s: %s exists",
		    luser, tmp);

		/* reuse tmp */
		strlcpy(tmp, "\n\n-**- Sorry, you have been banned! -**-\n\n",
		    sizeof(tmp));
		while (fputs(tmp, stdout) != EOF && !feof(f)) {
			if (fgets(tmp, sizeof(tmp), f) == NULL) {
				fflush(stdout);
				return (0);
			}
		}
	}
	fflush(stdout);
	return (0);
}

/*
 * Search for rulesets left by other authpf processes (either because they
 * died ungracefully or were terminated) and remove them.
 */
static int
remove_stale_rulesets(void)
{
	struct pfioc_ruleset	 prs;
	const int		 action[PF_RULESET_MAX] = { PF_SCRUB,
				    PF_PASS, PF_NAT, PF_BINAT, PF_RDR };
	u_int32_t		 nr, mnr;

	memset(&prs, 0, sizeof(prs));
	strlcpy(prs.anchor, anchorname, sizeof(prs.anchor));
	if (ioctl(dev, DIOCGETRULESETS, &prs)) {
		if (errno == EINVAL)
			return (0);
		else
			return (1);
	}

	mnr = prs.nr;
	nr = 0;
	while (nr < mnr) {
		char	*s, *t;
		pid_t	 pid;

		prs.nr = nr;
		if (ioctl(dev, DIOCGETRULESET, &prs))
			return (1);
		errno = 0;
		if ((t = strchr(prs.name, '(')) == NULL)
			t = prs.name;
		else
			t++;
		pid = strtoul(t, &s, 10);
		if (!prs.name[0] || errno ||
		    (*s && (t == prs.name || *s != ')')))
			return (1);
		if (kill(pid, 0) && errno != EPERM) {
			int i;

			for (i = 0; i < PF_RULESET_MAX; ++i) {
				struct pfioc_rule pr;

				memset(&pr, 0, sizeof(pr));
				memcpy(pr.anchor, prs.anchor, sizeof(pr.anchor));
				memcpy(pr.ruleset, prs.name, sizeof(pr.ruleset));
				pr.rule.action = action[i];
				if ((ioctl(dev, DIOCBEGINRULES, &pr) ||
				    ioctl(dev, DIOCCOMMITRULES, &pr)) &&
				    errno != EINVAL)
					return (1);
			}
			mnr--;
		} else
			nr++;
	}
	return (0);
}

/*
 * Add/remove filter entries for user "luser" from ip "ipsrc"
 */
static int
change_filter(int add, const char *luser, const char *ipsrc)
{
	char	*pargv[13] = {
		"pfctl", "-p", "/dev/pf", "-q", "-a", "anchor:ruleset",
		"-D", "user_ip=X", "-D", "user_id=X", "-f",
		"file", NULL
	};
	char	*fdpath = NULL, *userstr = NULL, *ipstr = NULL;
	char	*rsn = NULL, *fn = NULL;
	pid_t	pid;
	int	s;

	if (luser == NULL || !luser[0] || ipsrc == NULL || !ipsrc[0]) {
		syslog(LOG_ERR, "invalid luser/ipsrc");
		goto error;
	}

	if (asprintf(&rsn, "%s:%s", anchorname, rulesetname) == -1)
		goto no_mem;
	if (asprintf(&fdpath, "/dev/fd/%d", dev) == -1)
		goto no_mem;
	if (asprintf(&ipstr, "user_ip=%s", ipsrc) == -1)
		goto no_mem;
	if (asprintf(&userstr, "user_id=%s", luser) == -1)
		goto no_mem;

	if (add) {
		struct stat sb;

		if (asprintf(&fn, "%s/%s/authpf.rules", PATH_USER_DIR, luser)
		    == -1)
			goto no_mem;
		if (stat(fn, &sb) == -1) {
			free(fn);
			if ((fn = strdup(PATH_PFRULES)) == NULL)
				goto no_mem;
		}
	}
	pargv[2] = fdpath;
	pargv[5] = rsn;
	pargv[7] = userstr;
	pargv[9] = ipstr;
	if (!add)
		pargv[11] = "/dev/null";
	else
		pargv[11] = fn;

	switch (pid = fork()) {
	case -1:
		err(1, "fork failed");
	case 0:
		execvp(PATH_PFCTL, pargv);
		err(1, "exec of %s failed", PATH_PFCTL);
	}

	/* parent */
	waitpid(pid, &s, 0);
	if (s != 0) {
		if (WIFEXITED(s)) {
			syslog(LOG_ERR, "pfctl exited abnormally");
			goto error;
		}
	}

	if (add) {
		gettimeofday(&Tstart, NULL);
		syslog(LOG_INFO, "allowing %s, user %s", ipsrc, luser);
	} else {
		gettimeofday(&Tend, NULL);
		syslog(LOG_INFO, "removed %s, user %s - duration %ld seconds",
		    ipsrc, luser, (long)(Tend.tv_sec - Tstart.tv_sec));
	}
	return (0);
no_mem:
	syslog(LOG_ERR, "malloc failed");
error:
	free(fdpath);
	fdpath = NULL;
	free(rsn);
	rsn = NULL;
	free(userstr);
	userstr = NULL;
	free(ipstr);
	ipstr = NULL;
	free(fn);
	fn = NULL;
	infile = NULL;
	return (-1);
}

/*
 * Add/remove this IP from the "authpf_users" table.
 */
static int
change_table(int add, const char *luser, const char *ipsrc)
{
	struct pfioc_table	io;
	struct pfr_addr		addr;

	bzero(&io, sizeof(io));
	strlcpy(io.pfrio_table.pfrt_name, tablename, sizeof(io.pfrio_table));
	io.pfrio_buffer = &addr;
	io.pfrio_esize = sizeof(addr);
	io.pfrio_size = 1;

	bzero(&addr, sizeof(addr));
	if (ipsrc == NULL || !ipsrc[0])
		return (-1);
	if (inet_pton(AF_INET, ipsrc, &addr.pfra_ip4addr) == 1) {
		addr.pfra_af = AF_INET;
		addr.pfra_net = 32;
	} else if (inet_pton(AF_INET6, ipsrc, &addr.pfra_ip6addr) == 1) {
		addr.pfra_af = AF_INET6;
		addr.pfra_net = 128;
	} else {
		syslog(LOG_ERR, "invalid ipsrc");
		return (-1);
	}

	if (ioctl(dev, add ? DIOCRADDADDRS : DIOCRDELADDRS, &io) &&
	    errno != ESRCH) {
		syslog(LOG_ERR, "cannot %s %s from table %s: %s",
		    add ? "add" : "remove", ipsrc, tablename,
		    strerror(errno));
		return (-1);
	}
	return (0);
}

/*
 * This is to kill off states that would otherwise be left behind stateful
 * rules. This means we don't need to allow in more traffic than we really
 * want to, since we don't have to worry about any luser sessions lasting
 * longer than their ssh session. This function is based on
 * pfctl_kill_states from pfctl.
 */
static void
authpf_kill_states(void)
{
	struct pfioc_state_kill	psk;
	struct pf_addr target;

	memset(&psk, 0, sizeof(psk));
	memset(&target, 0, sizeof(target));

	if (inet_pton(AF_INET, ipsrc, &target.v4) == 1)
		psk.psk_af = AF_INET;
	else if (inet_pton(AF_INET6, ipsrc, &target.v6) == 1)
		psk.psk_af = AF_INET6;
	else {
		syslog(LOG_ERR, "inet_pton(%s) failed", ipsrc);
		return;
	}

	/* Kill all states from ipsrc */
	memcpy(&psk.psk_src.addr.v.a.addr, &target,
	    sizeof(psk.psk_src.addr.v.a.addr));
	memset(&psk.psk_src.addr.v.a.mask, 0xff,
	    sizeof(psk.psk_src.addr.v.a.mask));
	if (ioctl(dev, DIOCKILLSTATES, &psk))
		syslog(LOG_ERR, "DIOCKILLSTATES failed (%m)");

	/* Kill all states to ipsrc */
	memset(&psk.psk_src, 0, sizeof(psk.psk_src));
	memcpy(&psk.psk_dst.addr.v.a.addr, &target,
	    sizeof(psk.psk_dst.addr.v.a.addr));
	memset(&psk.psk_dst.addr.v.a.mask, 0xff,
	    sizeof(psk.psk_dst.addr.v.a.mask));
	if (ioctl(dev, DIOCKILLSTATES, &psk))
		syslog(LOG_ERR, "DIOCKILLSTATES failed (%m)");
}

/* signal handler that makes us go away properly */
static void
need_death(int signo)
{
	want_death = 1;
}

/*
 * function that removes our stuff when we go away.
 */
static __dead void
do_death(int active)
{
	int	ret = 0;

	if (active) {
		change_filter(0, luser, ipsrc);
		change_table(0, luser, ipsrc);
		authpf_kill_states();
		remove_stale_rulesets();
	}
	if (pidfp)
		ftruncate(fileno(pidfp), 0);
	if (pidfile[0])
		if (unlink(pidfile) == -1)
			syslog(LOG_ERR, "cannot unlink %s (%m)", pidfile);
	exit(ret);
}
@


1.8
log
@first part of mergeing OpenBSD and fixing whitespace and RCS IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.74 2004/01/13 17:31:15 dhartmei Exp $	*/
d32 1
d34 1
d42 1
a50 3
#include <pfctl_parser.h>
#include <pfctl.h>

d61 1
d66 1
d92 1
a92 1
	struct in_addr	 ina;
d96 2
d121 2
a122 1
	if (inet_pton(AF_INET, ipsrc, &ina) != 1) {
d136 1
d141 10
a150 1
	if (strcmp(pw->pw_shell, PATH_AUTHPF_SHELL)) {
d153 2
d158 3
d291 5
d378 5
d469 1
a469 1
					err(1, "malloc");
d625 9
a633 5
	char			 fn[MAXPATHLEN];
	FILE			*f = NULL;
	struct pfctl		 pf;
	struct pfr_buffer	 t;
	int			 i;
d640 8
a647 40
	if (add) {
		if ((i = snprintf(fn, sizeof(fn), "%s/%s/authpf.rules",
		    PATH_USER_DIR, luser)) < 0 || i >= sizeof(fn)) {
			syslog(LOG_ERR, "user rule path too long");
			goto error;
		}
		if ((f = fopen(fn, "r")) == NULL && errno != ENOENT) {
			syslog(LOG_ERR, "cannot open %s (%m)", fn);
			goto error;
		}
		if (f == NULL) {
			if (strlcpy(fn, PATH_PFRULES, sizeof(fn)) >=
			    sizeof(fn)) {
				syslog(LOG_ERR, "rule path too long");
				goto error;
			}
			if ((f = fopen(fn, "r")) == NULL) {
				syslog(LOG_ERR, "cannot open %s (%m)", fn);
				goto error;
			}
		}
	}

	if (pfctl_load_fingerprints(dev, 0)) {
		syslog(LOG_ERR, "unable to load kernel's OS fingerprints");
		goto error;
	}
	bzero(&t, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	memset(&pf, 0, sizeof(pf));
	for (i = 0; i < PF_RULESET_MAX; ++i) {
		if (pfctl_add_trans(&t, i, anchorname, rulesetname)) {
			syslog(LOG_ERR, "pfctl_add_trans %m");
			goto error;
		}
	}
	if (pfctl_trans(dev, &t, DIOCXBEGIN, 0)) {
		syslog(LOG_ERR, "DIOCXBEGIN (%s) %m", add?"add":"remove");
		goto error;
	}
d650 1
a650 5
		if (symset("user_ip", ipsrc, 0) ||
		    symset("user_id", luser, 0)) {
			syslog(LOG_ERR, "symset");
			goto error;
		}
d652 31
a682 9
		pf.dev = dev;
		pf.trans = &t;
		pf.anchor = anchorname;
		pf.ruleset = rulesetname;

		infile = fn;
		if (parse_rules(f, &pf) < 0) {
			syslog(LOG_ERR, "syntax error in rule file: "
			    "authpf rules not loaded");
a684 9

		infile = NULL;
		fclose(f);
		f = NULL;
	}

	if (pfctl_trans(dev, &t, DIOCXCOMMIT, 0)) {
		syslog(LOG_ERR, "DIOCXCOMMIT (%s) %m", add?"add":"remove");
		goto error;
d693 1
a693 1
		    ipsrc, luser, Tend.tv_sec - Tstart.tv_sec);
d696 2
a697 1

d699 10
a708 5
	if (f != NULL)
		fclose(f);
	if (pfctl_trans(dev, &t, DIOCXROLLBACK, 0))
		syslog(LOG_ERR, "DIOCXROLLBACK (%s) %m", add?"add":"remove");

d714 39
d763 1
a763 1
	struct in_addr		target;
d766 1
a766 1
	psk.psk_af = AF_INET;
d768 8
a775 1
	inet_pton(AF_INET, ipsrc, &target);
d778 2
a779 1
	psk.psk_src.addr.v.a.addr.v4 = target;
a785 1
	psk.psk_af = AF_INET;
d787 2
a788 1
	psk.psk_dst.addr.v.a.addr.v4 = target;
d812 1
a822 150

/*
 * callbacks for parse_rules(void)
 */

int
pfctl_add_rule(struct pfctl *pf, struct pf_rule *r)
{
	u_int8_t		rs_num;
	struct pfioc_rule	pr;

	switch (r->action) {
	case PF_PASS:
	case PF_DROP:
		rs_num = PF_RULESET_FILTER;
		break;
	case PF_SCRUB:
		rs_num = PF_RULESET_SCRUB;
		break;
	case PF_NAT:
	case PF_NONAT:
		rs_num = PF_RULESET_NAT;
		break;
	case PF_RDR:
	case PF_NORDR:
		rs_num = PF_RULESET_RDR;
		break;
	case PF_BINAT:
	case PF_NOBINAT:
		rs_num = PF_RULESET_BINAT;
		break;
	default:
		syslog(LOG_ERR, "invalid rule action %d", r->action);
		return (1);
	}

	bzero(&pr, sizeof(pr));
	strlcpy(pr.anchor, pf->anchor, sizeof(pr.anchor));
	strlcpy(pr.ruleset, pf->ruleset, sizeof(pr.ruleset));
	if (pfctl_add_pool(pf, &r->rpool, r->af))
		return (1);
	pr.ticket = pfctl_get_ticket(pf->trans, rs_num, pf->anchor,
	    pf->ruleset);
	pr.pool_ticket = pf->paddr.ticket;
	memcpy(&pr.rule, r, sizeof(pr.rule));
	if (ioctl(pf->dev, DIOCADDRULE, &pr)) {
		syslog(LOG_ERR, "DIOCADDRULE %m");
		return (1);
	}
	pfctl_clear_pool(&r->rpool);
	return (0);
}

int
pfctl_add_pool(struct pfctl *pf, struct pf_pool *p, sa_family_t af)
{
	struct pf_pooladdr	*pa;

	if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr)) {
		syslog(LOG_ERR, "DIOCBEGINADDRS %m");
		return (1);
	}
	pf->paddr.af = af;
	TAILQ_FOREACH(pa, &p->list, entries) {
		memcpy(&pf->paddr.addr, pa, sizeof(struct pf_pooladdr));
		if (ioctl(pf->dev, DIOCADDADDR, &pf->paddr)) {
			syslog(LOG_ERR, "DIOCADDADDR %m");
			return (1);
		}
	}
	return (0);
}

void
pfctl_clear_pool(struct pf_pool *pool)
{
	struct pf_pooladdr	*pa;

	while ((pa = TAILQ_FIRST(&pool->list)) != NULL) {
		TAILQ_REMOVE(&pool->list, pa, entries);
		free(pa);
	}
}

int
pfctl_add_altq(struct pfctl *pf, struct pf_altq *a)
{
	fprintf(stderr, "altq rules not supported in authpf\n");
	return (1);
}

int
pfctl_set_optimization(struct pfctl *pf, const char *opt)
{
	fprintf(stderr, "set optimization not supported in authpf\n");
	return (1);
}

int
pfctl_set_logif(struct pfctl *pf, char *ifname)
{
	fprintf(stderr, "set loginterface not supported in authpf\n");
	return (1);
}

int
pfctl_set_hostid(struct pfctl *pf, u_int32_t hostid)
{
	fprintf(stderr, "set hostid not supported in authpf\n");
	return (1);
}

int
pfctl_set_timeout(struct pfctl *pf, const char *opt, int seconds, int quiet)
{
	fprintf(stderr, "set timeout not supported in authpf\n");
	return (1);
}

int
pfctl_set_limit(struct pfctl *pf, const char *opt, unsigned int limit)
{
	fprintf(stderr, "set limit not supported in authpf\n");
	return (1);
}

int
pfctl_set_debug(struct pfctl *pf, char *d)
{
	fprintf(stderr, "set debug not supported in authpf\n");
	return (1);
}

int
pfctl_define_table(char *name, int flags, int addrs, const char *anchor,
    const char *ruleset, struct pfr_buffer *ab, u_int32_t ticket)
{
	fprintf(stderr, "table definitions not yet supported in authpf\n");
	return (1);
}

int
pfctl_rules(int dev, char *filename, int opts, char *anchorname,
    char *rulesetname, struct pfr_buffer *t)
{
	/* never called, no anchors inside anchors, but we need the stub */
	fprintf(stderr, "load anchor not supported from authpf\n");
	return (1);
}

@


1.7
log
@finish merging and sync a bit; bump version etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.73 2003/12/15 07:11:31 mcbride Exp $	*/
d552 1
a552 1
		char	*s;
d559 7
a565 2
		pid = strtoul(prs.name, &s, 10);
		if (!prs.name[0] || errno || *s)
@


1.6
log
@the system (kernel, userland) is fully gcc3-compileable now.
increment version number for that.

TODO:
 * wait for my X11 compile to finish
   (gcc3 is sooooooooooooooooooo slow)
 * c++, libstdc++, fortran+libs, objective-c+libs, ada
   XXX ada needs gnat installed, openbsd dont provide gnat
 * bump to gcc 3.3.2+
 * X11 enable C++ again (libGLU, yay)
 * X11 fix DRM (3D acceleration .ko""s)

TODO IMPORTANT:
 * propolice support MUST go in and be enabled before
   this thingie becomes system compiler
   (enable it in toplev.c and make bootstrap. watch it die.)
 * support for other stuff from gcc-local(1) would be nice:
   > -O2 no -fstrict-aliasing
   > err(3) checking for non-nonNULL
   > anil's bounds checker
   > -fno-ident default
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.70 2003/09/26 21:44:09 cedric Exp $	*/
a94 6
	if ((n = snprintf(rulesetname, sizeof(rulesetname), "%ld",
	    (long)getpid())) < 0 || n >= sizeof(rulesetname)) {
		syslog(LOG_ERR, "pid too large for ruleset name");
		exit(1);
	}

a121 1

d150 12
d244 4
a247 1
	if (!check_luser(PATH_BAN_DIR, luser) || !allowed_luser(luser))
d249 1
d251 2
a252 2
	openlog("authpf", LOG_PID | LOG_NDELAY, LOG_DAEMON);
	if (config == NULL || read_config(config))
d254 1
d256 2
a257 1
	if (remove_stale_rulesets())
d259 1
d859 7
d876 7
@


1.5
log
@Merge OpenBSD-current
@
text
@d1 1
a1 2
/*	$MirBSD: authpf.c,v 1.4 2003/05/22 14:09:17 tg Exp $	*/
/*	$OpenBSD: authpf.c,v 1.58 2003/06/03 20:38:59 beck Exp $	*/
d49 1
d257 1
a257 1
		do_death(1);
d284 2
a285 2
	printf("\r\nYour authentication process (pid %d) was unable to run\n",
	    getpid());
d380 1
a380 1
 * users file, namely /etc/authpf.allow .
d382 1
a382 1
 * If /etc/authpf.allow does not exist, then we assume that
d384 1
a384 1
 * use this gateway. If /etc/authpf.allow does exist, then a
d415 1
a415 1
		 * /etc/authpf.allow exists, thus we do a linear
d505 1
a505 1
		while ((fputs(tmp, stdout) != EOF) && !feof(f)) {
d521 1
a521 1
remove_stale_rulesets()
d550 1
a550 1
		if (kill(pid, 0)) {
a579 2
	const int		 action[PF_RULESET_MAX] = { PF_SCRUB,
				    PF_PASS, PF_NAT, PF_BINAT, PF_RDR };
d581 1
a581 1
	struct pfioc_rule	 pr[PF_RULESET_MAX];
d584 1
a584 2
	if (luser == NULL || !luser[0] || strlen(luser) >=
	    PF_RULESET_NAME_SIZE || ipsrc == NULL || !ipsrc[0]) {
d612 6
d620 2
a621 6
		memset(&pr[i], 0, sizeof(pr[i]));
		pr[i].rule.action = action[i];
		strlcpy(pr[i].anchor, anchorname, sizeof(pr[i].anchor));
		strlcpy(pr[i].ruleset, rulesetname, sizeof(pr[i].ruleset));
		if (ioctl(dev, DIOCBEGINRULES, &pr[i])) {
			syslog(LOG_ERR, "DIOCBEGINRULES %m");
d624 4
a627 1
		pf.prule[i] = &pr[i];
d638 4
d654 4
a657 10
	for (i = 0; i < PF_RULESET_MAX; ++i)
		/*
		 * ignore EINVAL on removal, it means the anchor was
		 * already automatically removed by the kernel.
		 */
		if (ioctl(dev, DIOCCOMMITRULES, &pr[i]) &&
		    (add || errno != EINVAL)) {
			syslog(LOG_ERR, "DIOCCOMMITRULES %m");
			goto error;
		}
d672 2
d687 1
a687 1
authpf_kill_states()
d705 1
d743 1
a743 1
 * callbacks for parse_rules()
d749 2
a750 1
	struct pfioc_rule	*pr;
d755 1
a755 1
		pr = pf->prule[PF_RULESET_FILTER];
d758 1
a758 1
		pr = pf->prule[PF_RULESET_SCRUB];
d762 1
a762 1
		pr = pf->prule[PF_RULESET_NAT];
d766 1
a766 1
		pr = pf->prule[PF_RULESET_RDR];
d770 1
a770 1
		pr = pf->prule[PF_RULESET_BINAT];
d776 4
d782 5
a786 3
	pr->pool_ticket = pf->paddr.ticket;
	memcpy(&pr->rule, r, sizeof(pr->rule));
	if (ioctl(pf->dev, DIOCADDRULE, pr)) {
d860 3
a862 15
void
pfctl_append_addr(char *addr, int net, int neg)
{
	/* appropriate message will be printed by following function */
}

void
pfctl_append_file(char *file)
{
	/* appropriate message will be printed by following function */
}

void
pfctl_define_table(char *name, int flags, int addrs, int noaction,
    const char *anchor, const char *ruleset)
d865 1
d870 1
a870 1
    char *rulesetname)
d876 1
@


1.4
log
@merge CVS import stuff
@
text
@d1 2
a2 2
/*	$MirBSD: authpf.c,v 1.3 2003/05/07 20:54:55 tg Exp $	*/
/*	$OpenBSD: authpf.c,v 1.57 2003/05/10 06:14:29 cloder Exp $	*/
a14 3
 * 3. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.3
log
@merge conflicts; fix what(1) stdin
@
text
@d1 2
a2 2
/*	$MirBSD: authpf.c,v 1.2 2003/03/23 21:53:57 tg Exp $	*/
/*	$OpenBSD: authpf.c,v 1.55 2003/04/30 12:30:27 cedric Exp $	*/
d646 1
d675 2
d870 9
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 2
a2 2
/*	$MirBSD: obsd.misc,v 1.25 2003/03/22 22:33:26 tg Exp $	*/
/*	$OpenBSD: authpf.c,v 1.53 2003/02/19 00:03:22 deraadt Exp $	*/
d246 1
a246 1
	if (config != NULL && read_config(config))
d863 2
a864 1
pfctl_define_table(char *name, int flags, int addrs, int noaction)
@


1.1
log
@Initial revision
@
text
@d1 1
d430 1
a430 1
					err(1, NULL);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.55 2003/04/30 12:30:27 cedric Exp $	*/
d245 1
a245 1
	if (config == NULL || read_config(config))
d862 1
a862 2
pfctl_define_table(char *name, int flags, int addrs, int noaction,
    const char *anchor, const char *ruleset)
@


1.1.1.3
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.57 2003/05/10 06:14:29 cloder Exp $	*/
a644 1
		infile = NULL;
a672 2

	infile = NULL;
a866 9

int
pfctl_rules(int dev, char *filename, int opts, char *anchorname,
    char *rulesetname)
{
	/* never called, no anchors inside anchors, but we need the stub */
	fprintf(stderr, "load anchor not supported from authpf\n");
	return (1);
}@


1.1.1.4
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.58 2003/06/03 20:38:59 beck Exp $	*/
d14 3
d878 1
a878 1
}
@


1.1.1.5
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.62 2003/06/28 20:37:29 deraadt Exp $	*/
d283 2
a284 2
	printf("\r\nYour authentication process (pid %ld) was unable to run\n",
	    (long)getpid());
d379 1
a379 1
 * users file, namely /etc/authpf/authpf.allow .
d381 1
a381 1
 * If /etc/authpf/authpf.allow does not exist, then we assume that
d383 1
a383 1
 * use this gateway. If /etc/authpf/authpf.allow does exist, then a
d414 1
a414 1
		 * /etc/authpf/authpf.allow exists, thus we do a linear
d504 1
a504 1
		while (fputs(tmp, stdout) != EOF && !feof(f)) {
d520 1
a520 1
remove_stale_rulesets(void)
d684 1
a684 1
authpf_kill_states(void)
d739 1
a739 1
 * callbacks for parse_rules(void)
@


1.1.1.6
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.64 2003/07/03 21:09:13 cedric Exp $	*/
d849 13
a861 1
int
d863 1
a863 2
    const char *anchor, const char *ruleset, struct pfr_buffer *ab,
    int ticket)
a865 1
	return (1);
@


1.1.1.7
log
@Bring the entire base system and ports tree in sync with OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.65 2003/07/08 11:31:27 dhartmei Exp $	*/
d549 1
a549 1
		if (kill(pid, 0) && errno != EPERM) {
a701 1
	psk.psk_af = AF_INET;
@


1.1.1.8
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.66 2003/07/11 08:29:34 cedric Exp $	*/
d851 3
a853 2
pfctl_define_table(char *name, int flags, int addrs, const char *anchor,
    const char *ruleset, struct pfr_buffer *ab, int ticket)
@


1.1.1.9
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.67 2003/08/01 05:29:36 millert Exp $	*/
d852 1
a852 1
    const char *ruleset, struct pfr_buffer *ab, u_int32_t ticket)
@


1.1.1.10
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.68 2003/08/21 19:13:23 frantzen Exp $	*/
a613 5
	if (pfctl_load_fingerprints(dev, 0)) {
		syslog(LOG_ERR, "unable to load kernel's OS fingerprints");
		goto error;
	}

a865 1

@


1.1.1.11
log
@Import some pieces of OpenBSD changes I unbedingtly wanted to have
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.69 2003/09/26 07:24:10 henning Exp $	*/
d585 2
a586 1
	if (luser == NULL || !luser[0] || ipsrc == NULL || !ipsrc[0]) {
@


1.1.1.12
log
@cvs is playing games with me.

@@@@@@ CONSIDER THE TREE LOCKED NOW @@@@@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.70 2003/09/26 21:44:09 cedric Exp $	*/
a48 1
#include <pfctl.h>
d256 1
a256 1
		do_death(0);
d579 2
d582 1
a582 1
	struct pfr_buffer	 t;
d617 1
a617 2
	bzero(&t, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
d620 6
a625 2
		if (pfctl_add_trans(&t, i, anchorname, rulesetname)) {
			syslog(LOG_ERR, "pfctl_add_trans %m");
d628 1
a628 4
	}
	if (pfctl_trans(dev, &t, DIOCXBEGIN, 0)) {
		syslog(LOG_ERR, "DIOCXBEGIN (%s) %m", add?"add":"remove");
		goto error;
a638 4
		pf.trans = &t;
		pf.anchor = anchorname;
		pf.ruleset = rulesetname;

d651 10
a660 4
	if (pfctl_trans(dev, &t, DIOCXCOMMIT, 0)) {
		syslog(LOG_ERR, "DIOCXCOMMIT (%s) %m", add?"add":"remove");
		goto error;
	}
a674 2
	if (pfctl_trans(dev, &t, DIOCXROLLBACK, 0))
		syslog(LOG_ERR, "DIOCXROLLBACK (%s) %m", add?"add":"remove");
d750 1
a750 2
	u_int8_t		rs_num;
	struct pfioc_rule	pr;
d755 1
a755 1
		rs_num = PF_RULESET_FILTER;
d758 1
a758 1
		rs_num = PF_RULESET_SCRUB;
d762 1
a762 1
		rs_num = PF_RULESET_NAT;
d766 1
a766 1
		rs_num = PF_RULESET_RDR;
d770 1
a770 1
		rs_num = PF_RULESET_BINAT;
a775 4

	bzero(&pr, sizeof(pr));
	strlcpy(pr.anchor, pf->anchor, sizeof(pr.anchor));
	strlcpy(pr.ruleset, pf->ruleset, sizeof(pr.ruleset));
d778 3
a780 5
	pr.ticket = pfctl_get_ticket(pf->trans, rs_num, pf->anchor,
	    pf->ruleset);
	pr.pool_ticket = pf->paddr.ticket;
	memcpy(&pr.rule, r, sizeof(pr.rule));
	if (ioctl(pf->dev, DIOCADDRULE, &pr)) {
d864 1
a864 1
    char *rulesetname, struct pfr_buffer *t)
@


1.1.1.13
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.73 2003/12/15 07:11:31 mcbride Exp $	*/
d95 6
d128 1
a156 12
	if ((n = snprintf(rulesetname, sizeof(rulesetname), "%s(%ld)",
	    luser, (long)getpid())) < 0 || n >= sizeof(rulesetname)) {
		syslog(LOG_INFO, "%s(%ld) too large, ruleset name will be %ld",
		    luser, (long)getpid(), (long)getpid());
		if ((n = snprintf(rulesetname, sizeof(rulesetname), "%ld",
		    (long)getpid())) < 0 || n >= sizeof(rulesetname)) {
			syslog(LOG_ERR, "pid too large for ruleset name");
			goto die;
		}
	}


d239 1
a239 4
	openlog("authpf", LOG_PID | LOG_NDELAY, LOG_DAEMON);

	if (!check_luser(PATH_BAN_DIR, luser) || !allowed_luser(luser)) {
		syslog(LOG_INFO, "user %s prohibited", luser);
a240 1
	}
d242 2
a243 2
	if (config == NULL || read_config(config)) {
		syslog(LOG_INFO, "bad or nonexistent %s", PATH_CONFFILE);
a244 1
	}
d246 1
a246 2
	if (remove_stale_rulesets()) {
		syslog(LOG_INFO, "error removing stale rulesets");
a247 1
	}
a846 7
pfctl_set_hostid(struct pfctl *pf, u_int32_t hostid)
{
	fprintf(stderr, "set hostid not supported in authpf\n");
	return (1);
}

int
a856 7
	return (1);
}

int
pfctl_set_debug(struct pfctl *pf, char *d)
{
	fprintf(stderr, "set debug not supported in authpf\n");
@


1.1.1.14
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.74 2004/01/13 17:31:15 dhartmei Exp $	*/
d552 1
a552 1
		char	*s, *t;
d559 2
a560 7
		if ((t = strchr(prs.name, '(')) == NULL)
			t = prs.name;
		else
			t++;
		pid = strtoul(t, &s, 10);
		if (!prs.name[0] || errno ||
		    (*s && (t == prs.name || *s != ')')))
@


1.1.1.15
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: authpf.c,v 1.81 2004/05/13 17:14:55 henning Exp $	*/
a31 1
#include <sys/stat.h>
a32 1
#include <sys/wait.h>
a39 1
#include <login_cap.h>
d48 3
a60 1
static int	change_table(int, const char *, const char *);
a64 1
char	tablename[PF_TABLE_NAME_SIZE] = "authpf_users";
d90 1
a90 1
	struct in6_addr	 ina;
a93 2
	char		*shell;
	login_cap_t	*lc;
d117 1
a117 2
	if (inet_pton(AF_INET, ipsrc, &ina) != 1 &&
	    inet_pton(AF_INET6, ipsrc, &ina) != 1) {
a130 1
	endpwent();
d135 1
a135 10

	if ((lc = login_getclass(pw->pw_class)) != NULL)
		shell = login_getcapstr(lc, "shell", pw->pw_shell,
		    pw->pw_shell);
	else
		shell = pw->pw_shell;

	login_close(lc);
	
	if (strcmp(shell, PATH_AUTHPF_SHELL)) {
a137 2
		if (shell != pw->pw_shell)
			free(shell);
a140 3
	if (shell != pw->pw_shell)
		free(shell);

a270 5
	if (change_table(1, luser, ipsrc) == -1) {
		printf("Unable to modify table\r\n");
		change_filter(0, luser, ipsrc);
		do_death(0);
	}
a352 5
		if (strcasecmp(pair[0], "table") == 0) {
			if (!pair[1][0] || strlcpy(tablename, pair[1],
			    sizeof(tablename)) >= sizeof(tablename))
				goto parse_error;
		}
d595 5
a599 9
	char	*pargv[13] = {
		"pfctl", "-p", "/dev/pf", "-q", "-a", "anchor:ruleset",
		"-D", "user_ip=X", "-D", "user_id=X", "-f",
		"file", NULL
	};
	char	*fdpath = NULL, *userstr = NULL, *ipstr = NULL;
	char	*rsn = NULL, *fn = NULL;
	pid_t	pid;
	int	s;
d606 40
a645 8
	if (asprintf(&rsn, "%s:%s", anchorname, rulesetname) == -1)
		goto no_mem;
	if (asprintf(&fdpath, "/dev/fd/%d", dev) == -1)
		goto no_mem;
	if (asprintf(&ipstr, "user_ip=%s", ipsrc) == -1)
		goto no_mem;
	if (asprintf(&userstr, "user_id=%s", luser) == -1)
		goto no_mem;
d648 5
a652 1
		struct stat sb;
d654 9
a662 31
		if (asprintf(&fn, "%s/%s/authpf.rules", PATH_USER_DIR, luser)
		    == -1)
			goto no_mem;
		if (stat(fn, &sb) == -1) {
			free(fn);
			if ((fn = strdup(PATH_PFRULES)) == NULL)
				goto no_mem;
		}
	}
	pargv[2] = fdpath;
	pargv[5] = rsn;
	pargv[7] = userstr;
	pargv[9] = ipstr;
	if (!add)
		pargv[11] = "/dev/null";
	else
		pargv[11] = fn;

	switch (pid = fork()) {
	case -1:
		err(1, "fork failed");
	case 0:
		execvp(PATH_PFCTL, pargv);
		err(1, "exec of %s failed", PATH_PFCTL);
	}

	/* parent */
	waitpid(pid, &s, 0);
	if (s != 0) {
		if (WIFEXITED(s)) {
			syslog(LOG_ERR, "pfctl exited abnormally");
d665 9
d685 1
a685 2
no_mem:
	syslog(LOG_ERR, "malloc failed");
d687 5
a691 10
	free(fdpath);
	fdpath = NULL;
	free(rsn);
	rsn = NULL;
	free(userstr);
	userstr = NULL;
	free(ipstr);
	ipstr = NULL;
	free(fn);
	fn = NULL;
a696 39
 * Add/remove this IP from the "authpf_users" table.
 */
static int
change_table(int add, const char *luser, const char *ipsrc)
{
	struct pfioc_table	io;
	struct pfr_addr		addr;

	bzero(&io, sizeof(io));
	strlcpy(io.pfrio_table.pfrt_name, tablename, sizeof(io.pfrio_table));
	io.pfrio_buffer = &addr;
	io.pfrio_esize = sizeof(addr);
	io.pfrio_size = 1;

	bzero(&addr, sizeof(addr));
	if (ipsrc == NULL || !ipsrc[0])
		return (-1);
	if (inet_pton(AF_INET, ipsrc, &addr.pfra_ip4addr) == 1) {
		addr.pfra_af = AF_INET;
		addr.pfra_net = 32;
	} else if (inet_pton(AF_INET6, ipsrc, &addr.pfra_ip6addr) == 1) {
		addr.pfra_af = AF_INET6;
		addr.pfra_net = 128;
	} else {
		syslog(LOG_ERR, "invalid ipsrc");
		return (-1);
	}

	if (ioctl(dev, add ? DIOCRADDADDRS : DIOCRDELADDRS, &io) &&
	    errno != ESRCH) {
		syslog(LOG_ERR, "cannot %s %s from table %s: %s",
		    add ? "add" : "remove", ipsrc, tablename,
		    strerror(errno));
		return (-1);
	}
	return (0);
}

/*
d707 1
a707 1
	struct pf_addr target;
d710 1
a710 1
	memset(&target, 0, sizeof(target));
d712 1
a712 8
	if (inet_pton(AF_INET, ipsrc, &target.v4) == 1)
		psk.psk_af = AF_INET;
	else if (inet_pton(AF_INET6, ipsrc, &target.v6) == 1)
		psk.psk_af = AF_INET6;
	else {
		syslog(LOG_ERR, "inet_pton(%s) failed", ipsrc);
		return;
	}
d715 1
a715 2
	memcpy(&psk.psk_src.addr.v.a.addr, &target,
	    sizeof(psk.psk_src.addr.v.a.addr));
d722 1
d724 1
a724 2
	memcpy(&psk.psk_dst.addr.v.a.addr, &target,
	    sizeof(psk.psk_dst.addr.v.a.addr));
a747 1
		change_table(0, luser, ipsrc);
d758 150
@


