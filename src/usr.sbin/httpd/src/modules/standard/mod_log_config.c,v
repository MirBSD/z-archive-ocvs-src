head	1.10;
access;
symbols
	tg-mergetmp-mirosx-1:1.10
	tg-mergefixes-1-branch:1.10.0.4
	tg-mergefixes-1-base:1.10
	MIROS_X:1.10.0.2
	MIROS_X_BASE:1.10
	tg-mergetmp-3:1.10
	cvs-200412121715:1.1.1.5
	cvs-200412040100:1.1.1.5
	MIRBSD_XP_MIRPPC:1.8.0.4
	aphttpd-1_3_33:1.1.8.2
	cvs-200410222040:1.1.1.4
	tg-mergetmp-1:1.1.1.4
	MIRBSD_XP_SPARC_BASE:1.8
	MIRBSD_XP_SPARC:1.8.0.2
	cvs-200408220000:1.1.1.4
	aphttpd-1_3_31:1.1.8.2
	ASF:1.1.8
	MIRBSD_7quater:1.4
	cvs-200405160640:1.1.1.4
	cvs-200401271800:1.1.1.4
	cvs-200401261630:1.1.1.4
	cvs-200401021645:1.1.1.3
	MIRBSD_7_ALPHA:1.4.0.6
	MIRBSD_7:1.4.0.4
	cvs-200312222040:1.1.1.3
	MIRBSD_7ter:1.4
	apache-1_3_29:1.1.8.1
	apache-1_3_28:1.1.8.1
	apache:1.1.8
	MIRBSD_7_DEV:1.4.0.2
	cvs-200310020700:1.1.1.3
	cvs-200309271030:1.1.1.3
	cvs-200309261655:1.1.1.3
	cvs-200309251530:1.1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2004.12.12.18.03.21;	author tg;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2004.11.28.02.02.05;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.21.23.31.05;	author tg;	state Stab;
branches;
next	1.7;

1.7
date	2004.08.21.22.57.59;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.19.11.17;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.27.17.43.04;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.31.20.55.34;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.19.20.24.47;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.19.16.11.43;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.55.37;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.8.1;
next	;

1.1.1.1
date	2003.03.22.17.55.37;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.07.19.19.04.10;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.30.23.55.58;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.01.26.19.11.47;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.12.12.15.24.17;	author tg;	state Exp;
branches;
next	;

1.1.8.1
date	2003.10.29.14.08.03;	author tg;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2004.07.15.17.05.17;	author tg;	state Exp;
branches;
next	;

1.10.4.1
date	2004.12.28.22.14.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@go back from base-upon-ASF-httpd-1.3.33 to 1.3.29 then up via OpenBSD;
unmerge stuff not needed; shuffle stuff around, etc.
add some RCS IDs

builds, serves default pages on odem successfully
@
text
@/**	$MirBSD$ */
/*	$OpenBSD: mod_log_config.c,v 1.16 2004/12/02 19:42:48 henning Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
 * Modified by djm@@va.pubnix.com:
 * If no TransferLog is given explicitly, decline to log.
 *
 * This is module implements the TransferLog directive (same as the
 * common log module), and additional directives, LogFormat and CustomLog.
 *
 *
 * Syntax:
 *
 *    TransferLog fn      Logs transfers to fn in standard log format, unless
 *                        a custom format is set with LogFormat
 *    LogFormat format    Set a log format from TransferLog files
 *    CustomLog fn format
 *                        Log to file fn with format given by the format
 *                        argument
 *
 *    CookieLog fn        For backwards compatability with old Cookie
 *                        logging module - now deprecated.
 *
 * There can be any number of TransferLog and CustomLog
 * commands. Each request will be logged to _ALL_ the
 * named files, in the appropriate format.
 *
 * If no TransferLog or CustomLog directive appears in a VirtualHost,
 * the request will be logged to the log file(s) defined outside
 * the virtual host section. If a TransferLog or CustomLog directive
 * appears in the VirtualHost section, the log files defined outside
 * the VirtualHost will _not_ be used. This makes this module compatable
 * with the CLF and config log modules, where the use of TransferLog
 * inside the VirtualHost section overrides its use outside.
 *
 * Examples:
 *
 *    TransferLog    logs/access_log
 *    <VirtualHost>
 *    LogFormat      "... custom format ..."
 *    TransferLog    log/virtual_only
 *    CustomLog      log/virtual_useragents "%t %{user-agent}i"
 *    </VirtualHost>
 *
 * This will log using CLF to access_log any requests handled by the
 * main server, while any requests to the virtual host will be logged
 * with the "... custom format..." to virtual_only _AND_ using
 * the custom user-agent log to virtual_useragents.
 *
 * Note that the NCSA referer and user-agent logs are easily added with
 * CustomLog:
 *   CustomLog   logs/referer  "%{referer}i -> %U"
 *   CustomLog   logs/agent    "%{user-agent}i"
 *
 * RefererIgnore functionality can be obtained with conditional
 * logging (SetEnvIf and CustomLog ... env=!VAR).
 *
 * But using this method allows much easier modification of the
 * log format, e.g. to log hosts along with UA:
 *   CustomLog   logs/referer "%{referer}i %U %h"
 *
 * The argument to LogFormat and CustomLog is a string, which can include
 * literal characters copied into the log files, and '%' directives as
 * follows:
 *
 * %...B:  bytes sent, excluding HTTP headers.
 * %...b:  bytes sent, excluding HTTP headers in CLF format, i.e. a '-'
 *         when no bytes where sent (rather than a '0'.
 * %...c:  Status of the connection.
 *         'X' = connection aborted before the response completed.
 *         '+' = connection may be kept alive after the response is sent.
 *         '-' = connection will be closed after the response is sent.
 * %...{FOOBAR}e:  The contents of the environment variable FOOBAR
 * %...f:  filename
 * %...h:  remote host
 * %...a:  remote IP-address
 * %...A:  local IP-address
 * %...{Foobar}i:  The contents of Foobar: header line(s) in the request
 *                 sent to the client.
 * %...l:  remote logname (from identd, if supplied)
 * %...{Foobar}n:  The contents of note "Foobar" from another module.
 * %...{Foobar}o:  The contents of Foobar: header line(s) in the reply.
 * %...p:  the port the request was served to
 * %...P:  the process ID of the child that serviced the request.
 * %...r:  first line of request
 * %...s:  status.  For requests that got internally redirected, this
 *         is status of the *original* request --- %...>s for the last.
 * %...t:  time, in common log format time format
 * %...{format}t:  The time, in the form given by format, which should
 *                 be in strftime(3) format.
 * %...T:  the time taken to serve the request, in seconds.
 * %...u:  remote user (from auth; may be bogus if return status (%s) is 401)
 * %...U:  the URL path requested.
 * %...v:  the configured name of the server (i.e. which virtual host?)
 * %...V:  the server name according to the UseCanonicalName setting
 * %...m:  the request method
 * %...H:  the request protocol
 * %...q:  the query string prepended by "?", or empty if no query string
 *
 * The '...' can be nothing at all (e.g. "%h %u %r %s %b"), or it can
 * indicate conditions for inclusion of the item (which will cause it
 * to be replaced with '-' if the condition is not met).  Note that
 * there is no escaping performed on the strings from %r, %...i and
 * %...o; some with long memories may remember that I thought this was
 * a bad idea, once upon a time, and I'm still not comfortable with
 * it, but it is difficult to see how to "do the right thing" with all
 * of '%..i', unless we URL-escape everything and break with CLF.
 *
 * The forms of condition are a list of HTTP status codes, which may
 * or may not be preceded by '!'.  Thus, '%400,501{User-agent}i' logs
 * User-agent: on 400 errors and 501 errors (Bad Request, Not
 * Implemented) only; '%!200,304,302{Referer}i' logs Referer: on all
 * requests which did *not* return some sort of normal status.
 *
 * The default LogFormat reproduces CLF; see below.
 *
 * The way this is supposed to work with virtual hosts is as follows:
 * a virtual host can have its own LogFormat, or its own TransferLog.
 * If it doesn't have its own LogFormat, it inherits from the main
 * server.  If it doesn't have its own TransferLog, it writes to the
 * same descriptor (meaning the same process for "| ...").
 *
 * --- rst */

#define DEFAULT_LOG_FORMAT "%h %l %u %t \"%r\" %>s %b"

#include "httpd.h"
#include "http_config.h"
#include "http_core.h"          /* For REMOTE_NAME */
#include "http_log.h"
#include "http_main.h"
#include "fdcache.h"
#include <limits.h>

__RCSID("$MirBSD: src/usr.sbin/httpd/src/modules/standard/mod_log_config.c,v 1.9 2004/11/28 02:02:05 tg Exp $");

module MODULE_VAR_EXPORT config_log_module;

static int xfer_flags = (O_WRONLY | O_APPEND | O_CREAT);
static mode_t xfer_mode = (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);

/* POSIX.1 defines PIPE_BUF as the maximum number of bytes that is
 * guaranteed to be atomic when writing a pipe.  And PIPE_BUF >= 512
 * is guaranteed.  So we'll just guess 512 in the event the system
 * doesn't have this.  Now, for file writes there is actually no limit,
 * the entire write is atomic.  Whether all systems implement this
 * correctly is another question entirely ... so we'll just use PIPE_BUF
 * because it's probably a good guess as to what is implemented correctly
 * everywhere.
 */
#ifdef PIPE_BUF
#define LOG_BUFSIZE     PIPE_BUF
#else
#define LOG_BUFSIZE     (512)
#endif

/*
 * multi_log_state is our per-(virtual)-server configuration. We store
 * an array of the logs we are going to use, each of type config_log_state.
 * If a default log format is given by LogFormat, store in default_format
 * (backward compat. with mod_log_config).  We also store for each virtual
 * server a pointer to the logs specified for the main server, so that if this
 * vhost has no logs defined, we can use the main server's logs instead.
 *
 * So, for the main server, config_logs contains a list of the log files
 * and server_config_logs in empty. For a vhost, server_config_logs
 * points to the same array as config_logs in the main server, and
 * config_logs points to the array of logs defined inside this vhost,
 * which might be empty.
 */

typedef struct {
    char *default_format_string;
    array_header *default_format;
    array_header *config_logs;
    array_header *server_config_logs;
    table *formats;
} multi_log_state;

/*
 * config_log_state holds the status of a single log file. fname might
 * be NULL, which means this module does no logging for this
 * request. format might be NULL, in which case the default_format
 * from the multi_log_state should be used, or if that is NULL as
 * well, use the CLF. log_fd is -1 before the log file is opened and
 * set to a valid fd after it is opened.
 */

typedef struct {
    char *fname;
    char *format_string;
    array_header *format;
    int log_fd;
    char *condition_var;
#ifdef BUFFERED_LOGS
    int outcnt;
    char outbuf[LOG_BUFSIZE];
#endif
} config_log_state;

/*
 * Format items...
 * Note that many of these could have ap_sprintfs replaced with static buffers.
 */

typedef const char *(*item_key_func) (request_rec *, char *);

typedef struct {
#ifdef EAPI
    char ch;
#endif
    item_key_func func;
    char *arg;
    int condition_sense;
    int want_orig;
    array_header *conditions;
} log_format_item;

static char *format_integer(pool *p, int i)
{
    return ap_psprintf(p, "%d", i);
}

static char *pfmt(pool *p, int i)
{
    if (i <= 0) {
        return "-";
    }
    else {
        return format_integer(p, i);
    }
}

static const char *constant_item(request_rec *dummy, char *stuff)
{
    return stuff;
}

static const char *log_remote_host(request_rec *r, char *a)
{
    return ap_escape_logitem(r->pool, ap_get_remote_host(r->connection, r->per_dir_config,
                                    REMOTE_NAME));
}

static const char *log_remote_address(request_rec *r, char *a)
{
    return r->connection->remote_ip;
}

static const char *log_local_address(request_rec *r, char *a)
{
    return r->connection->local_ip;
}

static const char *log_remote_logname(request_rec *r, char *a)
{
    return ap_escape_logitem(r->pool, ap_get_remote_logname(r));
}

static const char *log_remote_user(request_rec *r, char *a)
{
    char *rvalue = r->connection->user;

    if (rvalue == NULL) {
        rvalue = "-";
    }
    else if (strlen(rvalue) == 0) {
        rvalue = "\"\"";
    }
    else
        rvalue = ap_escape_logitem(r->pool, rvalue);
    return rvalue;
}

static const char *log_request_line(request_rec *r, char *a)
{
	    /* NOTE: If the original request contained a password, we
	     * re-write the request line here to contain XXXXXX instead:
	     * (note the truncation before the protocol string for HTTP/0.9 requests)
	     * (note also that r->the_request contains the unmodified request)
	     */
    return ap_escape_logitem(r->pool,
			     (r->parsed_uri.password) ? ap_pstrcat(r->pool, r->method, " ",
					 ap_unparse_uri_components(r->pool, &r->parsed_uri, 0),
					 r->assbackwards ? NULL : " ", r->protocol, NULL)
					: r->the_request
			     );
}

static const char *log_request_file(request_rec *r, char *a)
{
    return r->filename;
}
static const char *log_request_uri(request_rec *r, char *a)
{
    return ap_escape_logitem(r->pool, r->uri);
}
static const char *log_request_method(request_rec *r, char *a)
{
    return ap_escape_logitem(r->pool, r->method);
}
static const char *log_request_protocol(request_rec *r, char *a)
{
    return ap_escape_logitem(r->pool, r->protocol);
}
static const char *log_request_query(request_rec *r, char *a)
{
    return (r->args != NULL) ? ap_pstrcat(r->pool, "?",
					  ap_escape_logitem(r->pool, r->args), NULL)
                             : "";
}
static const char *log_status(request_rec *r, char *a)
{
    return pfmt(r->pool, r->status);
}

static const char *clf_log_bytes_sent(request_rec *r, char *a)
{
    if (!r->sent_bodyct) {
        return "-";
    }
    else {
        long int bs;
        ap_bgetopt(r->connection->client, BO_BYTECT, &bs);
	return ap_psprintf(r->pool, "%ld", bs);
    }
}

static const char *log_bytes_sent(request_rec *r, char *a)
{
    if (!r->sent_bodyct) {
        return "0";
    }
    else {
        long int bs;
        ap_bgetopt(r->connection->client, BO_BYTECT, &bs);
	return ap_psprintf(r->pool, "%ld", bs);
    }
}


static const char *log_header_in(request_rec *r, char *a)
{
    return ap_escape_logitem(r->pool, ap_table_get(r->headers_in, a));
}

static const char *log_header_out(request_rec *r, char *a)
{
    const char *cp = ap_table_get(r->headers_out, a);
    if (!strcasecmp(a, "Content-type") && r->content_type) {
        cp = ap_field_noparam(r->pool, r->content_type);
    }
    if (cp) {
        return cp;
    }
    return ap_table_get(r->err_headers_out, a);
}

static const char *log_note(request_rec *r, char *a)
{
    return ap_table_get(r->notes, a);
}
static const char *log_env_var(request_rec *r, char *a)
{
    return ap_table_get(r->subprocess_env, a);
}

static const char *log_request_time(request_rec *r, char *a)
{
    int timz;
    struct tm *t;
    char tstr[MAX_STRING_LEN];

    t = ap_get_gmtoff(&timz);

    if (a && *a) {              /* Custom format */
        strftime(tstr, MAX_STRING_LEN, a, t);
    }
    else {                      /* CLF format */
        char sign = (timz < 0 ? '-' : '+');

        if (timz < 0) {
            timz = -timz;
        }
        ap_snprintf(tstr, sizeof(tstr), "[%02d/%s/%lld:%02d:%02d:%02d %c%.2d%.2d]",
                t->tm_mday, ap_month_snames[t->tm_mon], (int64_t)t->tm_year+1900,
                t->tm_hour, t->tm_min, t->tm_sec,
                sign, timz / 60, timz % 60);
    }

    return ap_pstrdup(r->pool, tstr);
}

static const char *log_request_duration(request_rec *r, char *a)
{
    return ap_psprintf(r->pool, "%ld", (long)(time(NULL) - r->request_time));
}

/* These next two routines use the canonical name:port so that log
 * parsers don't need to duplicate all the vhost parsing crud.
 */
static const char *log_virtual_host(request_rec *r, char *a)
{
    return r->server->server_hostname;
}

static const char *log_server_port(request_rec *r, char *a)
{
    return ap_psprintf(r->pool, "%u",
	r->server->port ? r->server->port : ap_default_port(r));
}

/* This respects the setting of UseCanonicalName so that
 * the dynamic mass virtual hosting trick works better.
 */
static const char *log_server_name(request_rec *r, char *a)
{
    return ap_get_server_name(r);
}

static const char *log_child_pid(request_rec *r, char *a)
{
    return ap_psprintf(r->pool, "%ld", (long) getpid());
}

static const char *log_connection_status(request_rec *r, char *a)
{
    if (r->connection->aborted)
        return "X";

    if ((r->connection->keepalive) &&
        ((r->server->keep_alive_max - r->connection->keepalives) > 0)) {
        return "+";
    }

    return "-";
}

/*****************************************************************
 *
 * Parsing the log format string
 */

static struct log_item_list {
    char ch;
    item_key_func func;
    int want_orig_default;
} log_item_keys[] = {

    {
        'h', log_remote_host, 0
    },
    {
        'a', log_remote_address, 0
    },
    {
        'A', log_local_address, 0
    },
    {
        'l', log_remote_logname, 0
    },
    {
        'u', log_remote_user, 0
    },
    {
        't', log_request_time, 0
    },
    {
        'T', log_request_duration, 1
    },
    {
        'r', log_request_line, 1
    },
    {
        'f', log_request_file, 0
    },
    {
        'U', log_request_uri, 1
    },
    {
        's', log_status, 1
    },
    {
        'b', clf_log_bytes_sent, 0
    },
    {
        'B', log_bytes_sent, 0
    },
    {
        'i', log_header_in, 0
    },
    {
        'o', log_header_out, 0
    },
    {
        'n', log_note, 0
    },
    {
        'e', log_env_var, 0
    },
    {
        'V', log_server_name, 0
    },
    {
        'v', log_virtual_host, 0
    },
    {
        'p', log_server_port, 0
    },
    {
        'P', log_child_pid, 0
    },
    {
        'H', log_request_protocol, 0
    },
    {
        'm', log_request_method, 0
    },
    {
        'q', log_request_query, 0
    },
    {
        'c', log_connection_status, 0
    },
    {
        '\0'
    }
};

#ifdef EAPI
static struct log_item_list *find_log_func(pool *p, char k)
#else /* EAPI */
static struct log_item_list *find_log_func(char k)
#endif /* EAPI */
{
    int i;
#ifdef EAPI
    struct log_item_list *lil;
#endif /* EAPI */

    for (i = 0; log_item_keys[i].ch; ++i)
        if (k == log_item_keys[i].ch) {
            return &log_item_keys[i];
        }

#ifdef EAPI
    if (ap_hook_status(ap_psprintf(p, "ap::mod_log_config::log_%c", k))
        != AP_HOOK_STATE_NOTEXISTANT) {
        lil = (struct log_item_list *)
              ap_pcalloc(p, sizeof(struct log_item_list));
        if (lil == NULL)
            return NULL;
        lil->ch = k;
        lil->func = NULL;
        lil->want_orig_default = 0;
        return lil;
    }
#endif /* EAPI */

    return NULL;
}

static char *parse_log_misc_string(pool *p, log_format_item *it,
                                   const char **sa)
{
    const char *s;
    char *d;

    it->func = constant_item;
    it->conditions = NULL;

    s = *sa;
    while (*s && *s != '%') {
	s++;
    }
    /*
     * This might allocate a few chars extra if there's a backslash
     * escape in the format string.
     */
    it->arg = ap_palloc(p, s - *sa + 1);

    d = it->arg;
    s = *sa;
    while (*s && *s != '%') {
	if (*s != '\\') {
	    *d++ = *s++;
	}
	else {
	    s++;
	    switch (*s) {
	    case '\\':
		*d++ = '\\';
		s++;
		break;
	    case 'n':
		*d++ = '\n';
		s++;
		break;
	    case 't':
		*d++ = '\t';
		s++;
		break;
	    default:
		/* copy verbatim */
		*d++ = '\\';
		/*
		 * Allow the loop to deal with this *s in the normal
		 * fashion so that it handles end of string etc.
		 * properly.
		 */
		break;
	    }
	}
    }
    *d = '\0';

    *sa = s;
    return NULL;
}

static char *parse_log_item(pool *p, log_format_item *it, const char **sa)
{
    const char *s = *sa;

    if (*s != '%') {
        return parse_log_misc_string(p, it, sa);
    }

    ++s;
    it->condition_sense = 0;
    it->conditions = NULL;
    it->want_orig = -1;
    it->arg = "";               /* For safety's sake... */

    while (*s) {
        int i;
        struct log_item_list *l;

        switch (*s) {
        case '!':
            ++s;
            it->condition_sense = !it->condition_sense;
            break;

        case '<':
            ++s;
            it->want_orig = 1;
            break;

        case '>':
            ++s;
            it->want_orig = 0;
            break;

        case ',':
            ++s;
            break;

        case '{':
            ++s;
            it->arg = ap_getword(p, &s, '}');
            break;

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            i = *s - '0';
            while (ap_isdigit(*++s)) {
                i = i * 10 + (*s) - '0';
            }
            if (!it->conditions) {
                it->conditions = ap_make_array(p, 4, sizeof(int));
            }
            *(int *) ap_push_array(it->conditions) = i;
            break;

        default:
#ifdef EAPI
            l = find_log_func(p, *s++);
#else /* EAPI */
            l = find_log_func(*s++);
#endif /* EAPI */
            if (!l) {
                char dummy[2];

                dummy[0] = s[-1];
                dummy[1] = '\0';
                return ap_pstrcat(p, "Unrecognized LogFormat directive %",
                               dummy, NULL);
            }
#ifdef EAPI
            it->ch = s[-1];
#endif
            it->func = l->func;
            if (it->want_orig == -1) {
                it->want_orig = l->want_orig_default;
            }
            *sa = s;
            return NULL;
        }
    }

    return "Ran off end of LogFormat parsing args to some directive";
}

static array_header *parse_log_string(pool *p, const char *s, const char **err)
{
    array_header *a = ap_make_array(p, 30, sizeof(log_format_item));
    char *res;

    while (*s) {
        if ((res = parse_log_item(p, (log_format_item *) ap_push_array(a), &s))) {
            *err = res;
            return NULL;
        }
    }

    s = "\n";
    parse_log_item(p, (log_format_item *) ap_push_array(a), &s);
    return a;
}

/*****************************************************************
 *
 * Actually logging.
 */

static const char *process_item(request_rec *r, request_rec *orig,
                          log_format_item *item)
{
    const char *cp;

    /* First, see if we need to process this thing at all... */

    if (item->conditions && item->conditions->nelts != 0) {
        int i;
        int *conds = (int *) item->conditions->elts;
        int in_list = 0;

        for (i = 0; i < item->conditions->nelts; ++i) {
            if (r->status == conds[i]) {
                in_list = 1;
                break;
            }
        }

        if ((item->condition_sense && in_list)
            || (!item->condition_sense && !in_list)) {
            return "-";
        }
    }

    /* We do.  Do it... */

#ifdef EAPI
    if (item->func == NULL) {
        cp = NULL;
        ap_hook_use(ap_psprintf(r->pool, "ap::mod_log_config::log_%c", item->ch),
                    AP_HOOK_SIG3(ptr,ptr,ptr), AP_HOOK_DECLINE(NULL),
                    &cp, r, item->arg);
    }
    else
#endif
    cp = (*item->func) (item->want_orig ? orig : r, item->arg);
    return cp ? cp : "-";
}

#ifdef BUFFERED_LOGS
static void flush_log(config_log_state *cls)
{
    if (cls->outcnt && cls->log_fd != -1) {
        write(cls->log_fd, cls->outbuf, cls->outcnt);
        cls->outcnt = 0;
    }
}
#endif

static int config_log_transaction(request_rec *r, config_log_state *cls,
                                  array_header *default_format)
{
    log_format_item *items;
    char *str, *s;
    const char **strs;
    int *strl;
    request_rec *orig;
    int i;
    int len = 0;
    array_header *format;
    char *envar;

    if (cls->fname == NULL) {
        return DECLINED;
    }

    /*
     * See if we've got any conditional envariable-controlled logging decisions
     * to make.
     */
    if (cls->condition_var != NULL) {
	envar = cls->condition_var;
	if (*envar != '!') {
	    if (ap_table_get(r->subprocess_env, envar) == NULL) {
		return DECLINED;
	    }
	}
	else {
	    if (ap_table_get(r->subprocess_env, &envar[1]) != NULL) {
		return DECLINED;
	    }
	}
    }

    format = cls->format ? cls->format : default_format;

    strs = ap_palloc(r->pool, sizeof(char *) * (format->nelts));
    strl = ap_palloc(r->pool, sizeof(int) * (format->nelts));
    items = (log_format_item *) format->elts;

    orig = r;
    while (orig->prev) {
        orig = orig->prev;
    }
    while (r->next) {
        r = r->next;
    }

    for (i = 0; i < format->nelts; ++i) {
        strs[i] = process_item(r, orig, &items[i]);
    }

    for (i = 0; i < format->nelts; ++i) {
        len += strl[i] = strlen(strs[i]);
    }

#ifdef BUFFERED_LOGS
    if (len + cls->outcnt > LOG_BUFSIZE) {
        flush_log(cls);
    }
    if (len >= LOG_BUFSIZE) {
        str = ap_palloc(r->pool, len + 1);
        for (i = 0, s = str; i < format->nelts; ++i) {
            memcpy(s, strs[i], strl[i]);
            s += strl[i];
        }
        write(cls->log_fd, str, len);
    }
    else {
        for (i = 0, s = &cls->outbuf[cls->outcnt]; i < format->nelts; ++i) {
            memcpy(s, strs[i], strl[i]);
            s += strl[i];
        }
        cls->outcnt += len;
    }
#else
    str = ap_palloc(r->pool, len + 1);

    for (i = 0, s = str; i < format->nelts; ++i) {
        memcpy(s, strs[i], strl[i]);
        s += strl[i];
    }

    write(cls->log_fd, str, len);
#endif

    return OK;
}

static int multi_log_transaction(request_rec *r)
{
    multi_log_state *mls = ap_get_module_config(r->server->module_config,
						&config_log_module);
    config_log_state *clsarray;
    int i;

    /*
     * Log this transaction..
     */
    if (mls->config_logs->nelts) {
        clsarray = (config_log_state *) mls->config_logs->elts;
        for (i = 0; i < mls->config_logs->nelts; ++i) {
            config_log_state *cls = &clsarray[i];

            config_log_transaction(r, cls, mls->default_format);
        }
    }
    else if (mls->server_config_logs) {
        clsarray = (config_log_state *) mls->server_config_logs->elts;
        for (i = 0; i < mls->server_config_logs->nelts; ++i) {
            config_log_state *cls = &clsarray[i];

            config_log_transaction(r, cls, mls->default_format);
        }
    }

    return OK;
}

/*****************************************************************
 *
 * Module glue...
 */

static void *make_config_log_state(pool *p, server_rec *s)
{
    multi_log_state *mls;

    mls = (multi_log_state *) ap_palloc(p, sizeof(multi_log_state));
    mls->config_logs = ap_make_array(p, 1, sizeof(config_log_state));
    mls->default_format_string = NULL;
    mls->default_format = NULL;
    mls->server_config_logs = NULL;
    mls->formats = ap_make_table(p, 4);
    ap_table_setn(mls->formats, "CLF", DEFAULT_LOG_FORMAT);

    return mls;
}

/*
 * Use the merger to simply add a pointer from the vhost log state
 * to the log of logs specified for the non-vhost configuration.  Make sure
 * vhosts inherit any globally-defined format names.
 */

static void *merge_config_log_state(pool *p, void *basev, void *addv)
{
    multi_log_state *base = (multi_log_state *) basev;
    multi_log_state *add = (multi_log_state *) addv;

    add->server_config_logs = base->config_logs;
    if (!add->default_format) {
        add->default_format_string = base->default_format_string;
        add->default_format = base->default_format;
    }
    add->formats = ap_overlay_tables(p, base->formats, add->formats);

    return add;
}

/*
 * Set the default logfile format, or define a nickname for a format string.
 */
static const char *log_format(cmd_parms *cmd, void *dummy, char *fmt,
                              char *name)
{
    const char *err_string = NULL;
    multi_log_state *mls = ap_get_module_config(cmd->server->module_config,
						&config_log_module);

    /*
     * If we were given two arguments, the second is a name to be given to the
     * format.  This syntax just defines the nickname - it doesn't actually
     * make the format the default.
     */
    if (name != NULL) {
        parse_log_string(cmd->pool, fmt, &err_string);
        if (err_string == NULL) {
            ap_table_setn(mls->formats, name, fmt);
        }
    }
    else {
        mls->default_format_string = fmt;
        mls->default_format = parse_log_string(cmd->pool, fmt, &err_string);
    }
    return err_string;
}


static const char *add_custom_log(cmd_parms *cmd, void *dummy, char *fn,
                                  char *fmt, char *envclause)
{
    const char *err_string = NULL;
    multi_log_state *mls = ap_get_module_config(cmd->server->module_config,
						&config_log_module);
    config_log_state *cls;

    cls = (config_log_state *) ap_push_array(mls->config_logs);
    cls->condition_var = NULL;
    if (envclause != NULL) {
	if (strncasecmp(envclause, "env=", 4) != 0) {
	    return "error in condition clause";
	}
	if ((envclause[4] == '\0')
	    || ((envclause[4] == '!') && (envclause[5] == '\0'))) {
	    return "missing environment variable name";
	}
	cls->condition_var = ap_pstrdup(cmd->pool, &envclause[4]);
    }

    cls->fname = fn;
    cls->format_string = fmt;
    if (fmt == NULL) {
        cls->format = NULL;
    }
    else {
        cls->format = parse_log_string(cmd->pool, fmt, &err_string);
    }
    cls->log_fd = -1;

    return err_string;
}

static const char *set_transfer_log(cmd_parms *cmd, void *dummy, char *fn)
{
    return add_custom_log(cmd, dummy, fn, NULL, NULL);
}

static const char *set_cookie_log(cmd_parms *cmd, void *dummy, char *fn)
{
    return add_custom_log(cmd, dummy, fn, "%{Cookie}n \"%r\" %t", NULL);
}

static const command_rec config_log_cmds[] =
{
    {"CustomLog", add_custom_log, NULL, RSRC_CONF, TAKE23,
     "a file name, a custom log format string or format name, "
     "and an optional \"env=\" clause (see docs)"},
    {"TransferLog", set_transfer_log, NULL, RSRC_CONF, TAKE1,
     "the filename of the access log"},
    {"LogFormat", log_format, NULL, RSRC_CONF, TAKE12,
     "a log format string (see docs) and an optional format name"},
    {"CookieLog", set_cookie_log, NULL, RSRC_CONF, TAKE1,
     "the filename of the cookie log"},
    {NULL}
};

static config_log_state *open_config_log(server_rec *s, pool *p,
                                         config_log_state *cls,
                                         array_header *default_format)
{
    if (cls->log_fd > 0) {
        return cls;             /* virtual config shared w/main server */
    }

    if (cls->fname == NULL) {
        return cls;             /* Leave it NULL to decline.  */
    }

    if (*cls->fname == '|') {
        piped_log *pl;

        pl = ap_open_piped_log(p, cls->fname + 1);
        if (pl == NULL) {
            exit(1);
        }
        cls->log_fd = ap_piped_log_write_fd(pl);
    }
    else {
        char *fname = ap_server_root_relative(p, cls->fname);
	if (ap_server_chroot_desired())
	    cls->log_fd = fdcache_open(fname, xfer_flags, xfer_mode);
	else
	    cls->log_fd = ap_popenf_ex(p, fname, xfer_flags, xfer_mode, 1);

        if (cls->log_fd < 0) {
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
                         "could not open transfer log file %s.", fname);
            exit(1);
        }
    }
#ifdef BUFFERED_LOGS
    cls->outcnt = 0;
#endif

    return cls;
}

static config_log_state *open_multi_logs(server_rec *s, pool *p)
{
    int i;
    multi_log_state *mls = ap_get_module_config(s->module_config,
                                             &config_log_module);
    config_log_state *clsarray;
    const char *dummy;
    const char *format;

    if (mls->default_format_string) {
	format = ap_table_get(mls->formats, mls->default_format_string);
	if (format) {
	    mls->default_format = parse_log_string(p, format, &dummy);
	}
    }

    if (!mls->default_format) {
        mls->default_format = parse_log_string(p, DEFAULT_LOG_FORMAT, &dummy);
    }

    if (mls->config_logs->nelts) {
        clsarray = (config_log_state *) mls->config_logs->elts;
        for (i = 0; i < mls->config_logs->nelts; ++i) {
            config_log_state *cls = &clsarray[i];

	    if (cls->format_string) {
		format = ap_table_get(mls->formats, cls->format_string);
		if (format) {
		    cls->format = parse_log_string(p, format, &dummy);
		}
	    }

            cls = open_config_log(s, p, cls, mls->default_format);
        }
    }
    else if (mls->server_config_logs) {
        clsarray = (config_log_state *) mls->server_config_logs->elts;
        for (i = 0; i < mls->server_config_logs->nelts; ++i) {
            config_log_state *cls = &clsarray[i];

	    if (cls->format_string) {
		format = ap_table_get(mls->formats, cls->format_string);
		if (format) {
		    cls->format = parse_log_string(p, format, &dummy);
		}
	    }

            cls = open_config_log(s, p, cls, mls->default_format);
        }
    }

    return NULL;
}

static void init_config_log(server_rec *s, pool *p)
{
    /* First, do "physical" server, which gets default log fd and format
     * for the virtual servers, if they don't override...
     */

    open_multi_logs(s, p);

    /* Then, virtual servers */

    for (s = s->next; s; s = s->next) {
        open_multi_logs(s, p);
    }
}

#ifdef BUFFERED_LOGS
static void flush_all_logs(server_rec *s, pool *p)
{
    multi_log_state *mls;
    array_header *log_list;
    config_log_state *clsarray;
    int i;

    for (; s; s = s->next) {
        mls = ap_get_module_config(s->module_config, &config_log_module);
        log_list = NULL;
        if (mls->config_logs->nelts) {
            log_list = mls->config_logs;
        }
        else if (mls->server_config_logs) {
            log_list = mls->server_config_logs;
        }
        if (log_list) {
            clsarray = (config_log_state *) log_list->elts;
            for (i = 0; i < log_list->nelts; ++i) {
                flush_log(&clsarray[i]);
            }
        }
    }
}
#endif

module MODULE_VAR_EXPORT config_log_module =
{
    STANDARD_MODULE_STUFF,
    init_config_log,            /* initializer */
    NULL,                       /* create per-dir config */
    NULL,                       /* merge per-dir config */
    make_config_log_state,      /* server config */
    merge_config_log_state,     /* merge server config */
    config_log_cmds,            /* command table */
    NULL,                       /* handlers */
    NULL,                       /* filename translation */
    NULL,                       /* check_user_id */
    NULL,                       /* check auth */
    NULL,                       /* check access */
    NULL,                       /* type_checker */
    NULL,                       /* fixups */
    multi_log_transaction,      /* logger */
    NULL,                       /* header parser */
    NULL,                       /* child_init */
#ifdef BUFFERED_LOGS
    flush_all_logs,             /* child_exit */
#else
    NULL,
#endif
    NULL                        /* post read-request */
};
@


1.10.4.1
log
@fix log format
@
text
@d1 1
a1 1
/**	$MirBSD: src/usr.sbin/httpd/src/modules/standard/mod_log_config.c,v 1.10 2004/12/12 18:03:21 tg Exp $ */
d193 1
a193 1
__RCSID("$MirBSD: src/usr.sbin/httpd/src/modules/standard/mod_log_config.c,v 1.10 2004/12/12 18:03:21 tg Exp $");
d443 1
a443 1
	snprintf(tstr, sizeof(tstr), "[%02d/%s/%lld:%02d:%02d:%02d %c%.2d%.2d]",
@


1.9
log
@* fix a few cases where DESTDIR wasn't honoured
* fix a few cases where CFLAGS (specifically the
  new global -Werror) wasn't honoured
* fix a bunch of warnings and errors
  (for takers: there are quite a few left, I fixed
  the most important ones. Don't care about gcc3.2
  though, it'll die RSN. Perl or Lynx are probably
  good targets.)
* fix parameter passing to HTML manpage generation
  (noticed outside the chroot and with a known bad
  config only... jarejare... we should build stuff
  with a ports-like systrace (I have worn the idea
  for weeks).
* sync lists

I'm not too sure about this code being release-quality
yet, but OTOH it works without too much failures.
@
text
@d1 2
a2 2
/* $MirBSD: src/usr.sbin/httpd/src/modules/standard/mod_log_config.c,v 1.8 2004/08/21 23:31:05 tg Stab $ */
/* $OpenBSD: mod_log_config.c,v 1.15 2004/01/15 12:17:18 otto Exp $ */
d4 2
a5 1
/* Copyright 1999-2004 The Apache Software Foundation
d7 53
a59 11
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
d124 1
a124 2
 * %...a:  remote IP-address
 * %...A:  local IP-address
a126 1
 * %...B:  bytes sent, excluding HTTP headers.
d134 2
a135 1
 * %...H:  the request protocol
a138 1
 * %...m:  the request method
a142 1
 * %...q:  the query string prepended by "?", or empty if no query string
d154 3
a156 1
 * %...X:  An alias for %..c (Status of the connection).
d193 1
a193 1
__RCSID("$MirBSD$");
a197 4
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
/* OS/2 dosen't support users and groups */
static mode_t xfer_mode = (S_IREAD | S_IWRITE);
#else
a198 1
#endif
d509 3
d518 1
a518 1
        'b', clf_log_bytes_sent, 0
d521 1
a521 1
        'B', log_bytes_sent, 0
d524 1
a524 1
        'c', log_connection_status, 0
d527 1
a527 1
        'e', log_env_var, 0
d530 1
a530 1
        'f', log_request_file, 0
d533 1
a533 1
        'h', log_remote_host, 0
d536 1
a536 1
        'H', log_request_protocol, 0
d539 1
a539 1
        'i', log_header_in, 0
d542 1
a542 1
        'l', log_remote_logname, 0
d545 1
a545 1
        'm', log_request_method, 0
d548 1
a548 1
        'n', log_note, 0
d554 1
a554 1
        'p', log_server_port, 0
d557 1
a557 1
        'P', log_child_pid, 0
d560 1
a560 1
        'q', log_request_query, 0
d563 1
a563 1
        'r', log_request_line, 1
d566 1
a566 1
        's', log_status, 1
d569 1
a569 1
        't', log_request_time, 0
d572 1
a572 1
        'T', log_request_duration, 1
d575 1
a575 1
        'u', log_remote_user, 0
d578 1
a578 1
        'U', log_request_uri, 1
d581 1
a581 7
        'v', log_virtual_host, 0
    },
    {
        'V', log_server_name, 0
    },
    {
        'X', log_connection_status, 0
@


1.8
log
@even more sync with old work
@
text
@d1 1
a1 1
/* $MirBSD: src/usr.sbin/httpd/src/modules/standard/mod_log_config.c,v 1.6 2004/07/15 19:11:17 tg Exp $ */
d151 2
d406 2
a407 2
        ap_snprintf(tstr, sizeof(tstr), "[%02d/%s/%d:%02d:%02d:%02d %c%.2d%.2d]",
                t->tm_mday, ap_month_snames[t->tm_mon], t->tm_year+1900,
@


1.7
log
@update to an older version of my httpd work
@
text
@@


1.6
log
@merge... attempt I (I hate ASF httpd)
@
text
@d1 1
a1 1
/* $MirBSD$ */
d50 1
a50 1
 * 
d405 1
a405 1
                t->tm_mday, ap_month_snames[t->tm_mon], t->tm_year+1900, 
d469 2
a470 2
    {   
        'a', log_remote_address, 0 
d472 2
a473 2
    {   
        'A', log_local_address, 0 
d569 1
a569 1
    if (ap_hook_status(ap_psprintf(p, "ap::mod_log_config::log_%c", k)) 
d621 1
a621 1
	    case 't':	
d1110 1
a1110 1
    }    
@


1.5
log
@first part of mergeing OpenBSD and fixing whitespace and RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: mod_log_config.c,v 1.15 2004/01/15 12:17:18 otto Exp $ */
d4 1
a4 2
/* ====================================================================
 * The Apache Software License, Version 1.1
d6 11
a16 53
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d81 2
a82 1
 * %...B:  bytes sent, excluding HTTP headers.
d85 1
d93 1
a93 2
 * %...a:  remote IP-address
 * %...A:  local IP-address
d97 1
d102 1
d114 1
a114 3
 * %...m:  the request method
 * %...H:  the request protocol
 * %...q:  the query string prepended by "?", or empty if no query string
a468 3
    {
        'h', log_remote_host, 0
    },
d476 1
a476 1
        'l', log_remote_logname, 0
d479 1
a479 1
        'u', log_remote_user, 0
d482 1
a482 1
        't', log_request_time, 0
d485 1
a485 1
        'T', log_request_duration, 1
d488 1
a488 1
        'r', log_request_line, 1
d491 1
a491 1
        'f', log_request_file, 0
d494 1
a494 1
        'U', log_request_uri, 1
d497 1
a497 1
        's', log_status, 1
d500 1
a500 1
        'b', clf_log_bytes_sent, 0
d503 1
a503 1
        'B', log_bytes_sent, 0
d506 1
a506 1
        'i', log_header_in, 0
d512 7
a518 1
        'n', log_note, 0
d521 1
a521 1
        'e', log_env_var, 0
d524 1
a524 1
        'V', log_server_name, 0
d527 1
a527 1
        'v', log_virtual_host, 0
d530 1
a530 1
        'p', log_server_port, 0
d533 1
a533 1
        'P', log_child_pid, 0
d536 1
a536 1
        'H', log_request_protocol, 0
d539 1
a539 1
        'm', log_request_method, 0
d542 1
a542 1
        'q', log_request_query, 0
d545 1
a545 1
        'c', log_connection_status, 0
@


1.4
log
@Merge import of OpenBSD source, ports and XF4 tree.

While here,
o clean up differences where possible
o whitespace cleanup
o ifdef ./. if defined()
o '...' ./. "..."
o echo foo > bar ./. echo foo >bar
o `...` ./. $(...) ./. $$(...)
o `...' ./. '...'
o modernize "our" tree, e.g. WWW in ports
o fix some typos and brainos introduced when renaming OpenBSD to MirBSD
o use hardware 80387 by default
o migrate Apache 1.3.28 OpenBSD ./. MirBSD ./. KAME
o work around as many CVS bugs as possible (add back/delete files, ...)

Synchronize stuff, ready for ongoing changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.14 2003/08/21 13:11:36 henning Exp $ */
d456 1
a456 1
    return ap_psprintf(r->pool, "%ld", time(NULL) - r->request_time);
@


1.3
log
@merge OpenBSD tree; bump MirBSD minor
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.13 2003/07/18 21:16:37 david Exp $ */
d1120 1
@


1.2
log
@o Update to Apache 1.3.28
o Retain OpenBSD changes
o Retain IPv6 changes
o Retain local (MirBSD) changes
o Remove some unused files
  o SSL stuff is in src/etc/ssl.certs.shar
  o SSL demonstration stuff is not needed
  o Windows®, Novell® Netware®, OS/2®, Cygwin, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.12 2002/07/19 21:31:16 henning Exp $ */
d188 1
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d1118 1
a1118 1
	    cls->log_fd = ap_popenf(p, fname, xfer_flags, xfer_mode);
@


1.1.8.1
log
@Import Apache HTTPD 1.3.28 into vendor branch to ease update
@
text
@d1 2
d6 1
a6 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d188 1
d268 3
d589 3
d593 1
d596 3
d605 14
d744 3
d748 1
d757 3
d821 9
d1115 5
a1119 2
        if ((cls->log_fd = ap_popenf_ex(p, fname, xfer_flags, xfer_mode, 1))
             < 0) {
@


1.1.8.2
log
@The Apache(TM) Webserver, version 1.3.31
@
text
@d1 2
a2 1
/* Copyright 1999-2004 The Apache Software Foundation
d4 53
a56 11
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
d121 1
a121 2
 * %...a:  remote IP-address
 * %...A:  local IP-address
a123 1
 * %...B:  bytes sent, excluding HTTP headers.
d131 2
a132 1
 * %...H:  the request protocol
a135 1
 * %...m:  the request method
a139 1
 * %...q:  the query string prepended by "?", or empty if no query string
d151 3
a153 1
 * %...X:  An alias for %..c (Status of the connection).
d503 3
d513 1
a513 1
        'b', clf_log_bytes_sent, 0
d516 1
a516 1
        'B', log_bytes_sent, 0
d519 1
a519 1
        'c', log_connection_status, 0
d522 1
a522 1
        'e', log_env_var, 0
d525 1
a525 1
        'f', log_request_file, 0
d528 1
a528 1
        'h', log_remote_host, 0
d531 1
a531 1
        'H', log_request_protocol, 0
d534 1
a534 1
        'i', log_header_in, 0
d537 1
a537 1
        'l', log_remote_logname, 0
d540 1
a540 1
        'm', log_request_method, 0
d543 1
a543 1
        'n', log_note, 0
d549 1
a549 1
        'p', log_server_port, 0
d552 1
a552 1
        'P', log_child_pid, 0
d555 1
a555 1
        'q', log_request_query, 0
d558 1
a558 1
        'r', log_request_line, 1
d561 1
a561 1
        's', log_status, 1
d564 1
a564 1
        't', log_request_time, 0
d567 1
a567 1
        'T', log_request_duration, 1
d570 1
a570 1
        'u', log_remote_user, 0
d573 1
a573 1
        'U', log_request_uri, 1
d576 1
a576 7
        'v', log_virtual_host, 0
    },
    {
        'V', log_server_name, 0
    },
    {
        'X', log_connection_status, 0
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Another sync to OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.13 2003/07/18 21:16:37 david Exp $ */
a187 1
#include "http_main.h"
@


1.1.1.3
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.14 2003/08/21 13:11:36 henning Exp $ */
d6 1
a6 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d1119 1
a1119 2
	    cls->log_fd = ap_popenf_ex(p, fname, xfer_flags, xfer_mode, 1);

@


1.1.1.4
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.15 2004/01/15 12:17:18 otto Exp $ */
d456 1
a456 1
    return ap_psprintf(r->pool, "%ld", (long)(time(NULL) - r->request_time));
@


1.1.1.5
log
@Import first part of OpenBSD httpd cleanup work (OpenHTTPD? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.16 2004/12/02 19:42:48 henning Exp $ */
d195 4
d200 1
@


