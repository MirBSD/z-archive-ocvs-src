head	1.13;
access;
symbols
	tg-mergetmp-mirosx-1:1.13
	tg-mergefixes-1-branch:1.13.0.4
	tg-mergefixes-1-base:1.13
	MIROS_X:1.13.0.2
	MIROS_X_BASE:1.13
	tg-mergetmp-3:1.13
	cvs-200412121715:1.1.1.5
	cvs-200412040100:1.1.1.5
	MIRBSD_XP_MIRPPC:1.11.0.4
	aphttpd-1_3_33:1.1.8.4
	cvs-200410222040:1.1.1.4
	tg-mergetmp-1:1.1.1.4
	MIRBSD_XP_SPARC_BASE:1.11
	MIRBSD_XP_SPARC:1.11.0.2
	cvs-200408220000:1.1.1.4
	aphttpd-1_3_31:1.1.8.3
	ASF:1.1.8
	MIRBSD_7quater:1.5
	cvs-200405160640:1.1.1.3
	cvs-200401271800:1.1.1.3
	cvs-200401261630:1.1.1.3
	cvs-200401021645:1.1.1.3
	MIRBSD_7_ALPHA:1.5.0.6
	MIRBSD_7:1.5.0.4
	cvs-200312222040:1.1.1.3
	MIRBSD_7ter:1.5
	apache-1_3_29:1.1.8.2
	apache-1_3_28:1.1.8.1
	apache:1.1.8
	MIRBSD_7_DEV:1.5.0.2
	cvs-200310020700:1.1.1.2
	cvs-200309271030:1.1.1.2
	cvs-200309261655:1.1.1.2
	cvs-200309251530:1.1.1.2
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.2
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.2
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2004.12.12.18.03.05;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.29.08.21.35;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.22.00.30.14;	author tg;	state Stab;
branches;
next	1.10;

1.10
date	2004.08.21.23.30.54;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.21.22.57.45;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.15.19.11.02;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.27.00.31.47;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.29.15.29.28;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.31.20.55.28;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.19.16.11.37;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.20.11.26.18;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.19.57.36;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.55.28;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.8.1;
next	;

1.1.1.1
date	2003.03.22.17.55.28;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.30.23.55.27;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.22.21.17.12;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.22.00.07.53;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.12.12.15.23.57;	author tg;	state Exp;
branches;
next	;

1.1.8.1
date	2003.10.29.14.06.45;	author tg;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2003.10.29.14.29.50;	author tg;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2004.07.15.17.04.48;	author tg;	state Exp;
branches;
next	1.1.8.4;

1.1.8.4
date	2004.10.29.07.53.33;	author tg;	state Exp;
branches;
next	;


desc
@@


1.13
log
@go back from base-upon-ASF-httpd-1.3.33 to 1.3.29 then up via OpenBSD;
unmerge stuff not needed; shuffle stuff around, etc.
add some RCS IDs

builds, serves default pages on odem successfully
@
text
@/* $MirBSD$ */
/* $OpenBSD: http_core.c,v 1.19 2004/12/02 19:42:47 henning Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

#define CORE_PRIVATE
#define ADD_EBCDICCONVERT_DEBUG_HEADER 0
#include "httpd.h"
#include "http_config.h"
#include "http_core.h"
#include "http_protocol.h"	/* For index_of_response().  Grump. */
#include "http_request.h"
#include "http_conf_globals.h"
#include "http_vhost.h"
#include "http_main.h"		/* For the default_handler below... */
#include "http_log.h"
#include "rfc1413.h"
#include "util_md5.h"
#include "scoreboard.h"
#include "fnmatch.h"
#include "sa_len.h"

#ifdef USE_MMAP_FILES
#include <sys/mman.h>

/* mmap support for static files based on ideas from John Heidemann's
 * patch against 1.0.5.  See
 * <http://www.isi.edu/~johnh/SOFTWARE/APACHE/index.html>.
 */

/* Files have to be at least this big before they're mmap()d.  This is to deal
 * with systems where the expense of doing an mmap() and an munmap() outweighs
 * the benefit for small files.  It shouldn't be set lower than 1.
 */
#ifndef MMAP_THRESHOLD
#define MMAP_THRESHOLD		1
#endif
#endif
#ifndef MMAP_LIMIT
#define MMAP_LIMIT              (4*1024*1024)
#endif

/* Server core module... This module provides support for really basic
 * server operations, including options and commands which control the
 * operation of other modules.  Consider this the bureaucracy module.
 *
 * The core module also defines handlers, etc., do handle just enough
 * to allow a server with the core module ONLY to actually serve documents
 * (though it slaps DefaultType on all of 'em); this was useful in testing,
 * but may not be worth preserving.
 *
 * This file could almost be mod_core.c, except for the stuff which affects
 * the http_conf_globals.
 */

static void *create_core_dir_config(pool *a, char *dir)
{
    core_dir_config *conf;

    conf = (core_dir_config *)ap_pcalloc(a, sizeof(core_dir_config));
    if (!dir || dir[strlen(dir) - 1] == '/') {
        conf->d = dir;
    }
    else if (strncmp(dir, "proxy:", 6) == 0) {
        conf->d = ap_pstrdup(a, dir);
    }
    else {
        conf->d = ap_pstrcat(a, dir, "/", NULL);
    }
    conf->d_is_fnmatch = conf->d ? (ap_is_fnmatch(conf->d) != 0) : 0;
    conf->d_components = conf->d ? ap_count_dirs(conf->d) : 0;

    conf->opts = dir ? OPT_UNSET : OPT_UNSET|OPT_ALL;
    conf->opts_add = conf->opts_remove = OPT_NONE;
    conf->override = dir ? OR_UNSET : OR_UNSET|OR_ALL;

    conf->content_md5 = 2;

    conf->use_canonical_name = USE_CANONICAL_NAME_UNSET;

    conf->hostname_lookups = HOSTNAME_LOOKUP_UNSET;
    conf->do_rfc1413 = DEFAULT_RFC1413 | 2; /* set bit 1 to indicate default */
    conf->satisfy = SATISFY_NOSPEC;

#ifdef RLIMIT_CPU
    conf->limit_cpu = NULL;
#endif
#ifdef RLIMIT_TIME
    conf->limit_time = NULL;
#endif
#if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
    conf->limit_mem = NULL;
#endif
#ifdef RLIMIT_NPROC
    conf->limit_nproc = NULL;
#endif

    conf->limit_req_body = 0;
    conf->sec = ap_make_array(a, 2, sizeof(void *));

    conf->server_signature = srv_sig_unset;

    conf->add_default_charset = ADD_DEFAULT_CHARSET_UNSET;
    conf->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;

    /*
     * Flag for use of inodes in ETags.
     */
    conf->etag_bits = ETAG_UNSET;
    conf->etag_add = ETAG_UNSET;
    conf->etag_remove = ETAG_UNSET;

    return (void *)conf;
}

static void *merge_core_dir_configs(pool *a, void *basev, void *newv)
{
    core_dir_config *base = (core_dir_config *)basev;
    core_dir_config *new = (core_dir_config *)newv;
    core_dir_config *conf;
    int i;

    conf = (core_dir_config *)ap_palloc(a, sizeof(core_dir_config));
    memcpy((char *)conf, (const char *)base, sizeof(core_dir_config));
    if (base->response_code_strings) {
	conf->response_code_strings =
	    ap_palloc(a, sizeof(*conf->response_code_strings)
		      * RESPONSE_CODES);
	memcpy(conf->response_code_strings, base->response_code_strings,
	       sizeof(*conf->response_code_strings) * RESPONSE_CODES);
    }

    conf->d = new->d;
    conf->d_is_fnmatch = new->d_is_fnmatch;
    conf->d_components = new->d_components;
    conf->r = new->r;

    if (new->opts & OPT_UNSET) {
	/* there was no explicit setting of new->opts, so we merge
	 * preserve the invariant (opts_add & opts_remove) == 0
	 */
	conf->opts_add = (conf->opts_add & ~new->opts_remove) | new->opts_add;
	conf->opts_remove = (conf->opts_remove & ~new->opts_add)
	                    | new->opts_remove;
	conf->opts = (conf->opts & ~conf->opts_remove) | conf->opts_add;
        if ((base->opts & OPT_INCNOEXEC) && (new->opts & OPT_INCLUDES)) {
            conf->opts = (conf->opts & ~OPT_INCNOEXEC) | OPT_INCLUDES;
	}
    }
    else {
	/* otherwise we just copy, because an explicit opts setting
	 * overrides all earlier +/- modifiers
	 */
	conf->opts = new->opts;
	conf->opts_add = new->opts_add;
	conf->opts_remove = new->opts_remove;
    }

    if (!(new->override & OR_UNSET)) {
        conf->override = new->override;
    }
    if (new->ap_default_type) {
        conf->ap_default_type = new->ap_default_type;
    }

    if (new->ap_auth_type) {
        conf->ap_auth_type = new->ap_auth_type;
    }
    if (new->ap_auth_name) {
        conf->ap_auth_name = new->ap_auth_name;
    }
    if (new->ap_auth_nonce) {
        conf->ap_auth_nonce = new->ap_auth_nonce;
    }
    if (new->ap_requires) {
        conf->ap_requires = new->ap_requires;
    }

    if (new->response_code_strings) {
	if (conf->response_code_strings == NULL) {
	    conf->response_code_strings = ap_palloc(a,
		sizeof(*conf->response_code_strings) * RESPONSE_CODES);
	    memcpy(conf->response_code_strings, new->response_code_strings,
		   sizeof(*conf->response_code_strings) * RESPONSE_CODES);
	}
	else {
	    for (i = 0; i < RESPONSE_CODES; ++i) {
	        if (new->response_code_strings[i] != NULL) {
		    conf->response_code_strings[i]
		        = new->response_code_strings[i];
		}
	    }
	}
    }
    if (new->hostname_lookups != HOSTNAME_LOOKUP_UNSET) {
	conf->hostname_lookups = new->hostname_lookups;
    }
    if ((new->do_rfc1413 & 2) == 0) {
        conf->do_rfc1413 = new->do_rfc1413;
    }
    if ((new->content_md5 & 2) == 0) {
        conf->content_md5 = new->content_md5;
    }
    if (new->use_canonical_name != USE_CANONICAL_NAME_UNSET) {
	conf->use_canonical_name = new->use_canonical_name;
    }

#ifdef RLIMIT_CPU
    if (new->limit_cpu) {
        conf->limit_cpu = new->limit_cpu;
    }
#endif
#ifdef RLIMIT_TIME
    if (new->limit_time) {
        conf->limit_time = new->limit_time;
    }
#endif
#if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
    if (new->limit_mem) {
        conf->limit_mem = new->limit_mem;
    }
#endif
#ifdef RLIMIT_NPROC
    if (new->limit_nproc) {
        conf->limit_nproc = new->limit_nproc;
    }
#endif

    if (new->limit_req_body) {
        conf->limit_req_body = new->limit_req_body;
    }
    conf->sec = ap_append_arrays(a, base->sec, new->sec);

    if (new->satisfy != SATISFY_NOSPEC) {
        conf->satisfy = new->satisfy;
    }


    if (new->server_signature != srv_sig_unset) {
	conf->server_signature = new->server_signature;
    }

    if (new->add_default_charset != ADD_DEFAULT_CHARSET_UNSET) {
	conf->add_default_charset = new->add_default_charset;
	if (new->add_default_charset_name) {
	    conf->add_default_charset_name = new->add_default_charset_name;
	}
    }

    /*
     * Now merge the setting of the FileETag directive.
     */
    if (new->etag_bits == ETAG_UNSET) {
        conf->etag_add =
            (conf->etag_add & (~ new->etag_remove)) | new->etag_add;
        conf->etag_remove =
            (conf->opts_remove & (~ new->etag_add)) | new->etag_remove;
        conf->etag_bits =
            (conf->etag_bits & (~ conf->etag_remove)) | conf->etag_add;
    }
    else {
        conf->etag_bits = new->etag_bits;
        conf->etag_add = new->etag_add;
        conf->etag_remove = new->etag_remove;
    }
    if (conf->etag_bits != ETAG_NONE) {
        conf->etag_bits &= (~ ETAG_NONE);
    }

    if (new->cgi_command_args != AP_FLAG_UNSET) {
        conf->cgi_command_args = new->cgi_command_args;
    }
    ap_server_strip_chroot(conf->d, 0);

    return (void*)conf;
}

static void *create_core_server_config(pool *a, server_rec *s)
{
    core_server_config *conf;
    int is_virtual = s->is_virtual;

    conf = (core_server_config *)ap_pcalloc(a, sizeof(core_server_config));
#ifdef GPROF
    conf->gprof_dir = NULL;
#endif
    conf->access_name = is_virtual ? NULL : DEFAULT_ACCESS_FNAME;
    conf->ap_document_root = is_virtual ? NULL : DOCUMENT_LOCATION;
    conf->sec = ap_make_array(a, 40, sizeof(void *));
    conf->sec_url = ap_make_array(a, 40, sizeof(void *));

    /* recursion stopper */
    conf->redirect_limit = 0;
    conf->subreq_limit = 0;
    conf->recursion_limit_set = 0;

    return (void *)conf;
}

static void *merge_core_server_configs(pool *p, void *basev, void *virtv)
{
    core_server_config *base = (core_server_config *)basev;
    core_server_config *virt = (core_server_config *)virtv;
    core_server_config *conf;

    conf = (core_server_config *)ap_pcalloc(p, sizeof(core_server_config));
    *conf = *virt;
    if (!conf->access_name) {
        conf->access_name = base->access_name;
    }
    if (!conf->ap_document_root) {
        conf->ap_document_root = base->ap_document_root;
    }
    conf->sec = ap_append_arrays(p, base->sec, virt->sec);
    conf->sec_url = ap_append_arrays(p, base->sec_url, virt->sec_url);

    conf->redirect_limit = virt->recursion_limit_set
                           ? virt->redirect_limit
                           : base->redirect_limit;

    conf->subreq_limit = virt->recursion_limit_set
                         ? virt->subreq_limit
                         : base->subreq_limit;

    return conf;
}

/* Add per-directory configuration entry (for <directory> section);
 * these are part of the core server config.
 */

CORE_EXPORT(void) ap_add_per_dir_conf(server_rec *s, void *dir_config)
{
    core_server_config *sconf = ap_get_module_config(s->module_config,
						     &core_module);
    void **new_space = (void **)ap_push_array(sconf->sec);

    *new_space = dir_config;
}

CORE_EXPORT(void) ap_add_per_url_conf(server_rec *s, void *url_config)
{
    core_server_config *sconf = ap_get_module_config(s->module_config,
						     &core_module);
    void **new_space = (void **)ap_push_array(sconf->sec_url);

    *new_space = url_config;
}

CORE_EXPORT(void) ap_add_file_conf(core_dir_config *conf, void *url_config)
{
    void **new_space = (void **)ap_push_array(conf->sec);

    *new_space = url_config;
}

/* core_reorder_directories reorders the directory sections such that the
 * 1-component sections come first, then the 2-component, and so on, finally
 * followed by the "special" sections.  A section is "special" if it's a regex,
 * or if it doesn't start with / -- consider proxy: matching.  All movements
 * are in-order to preserve the ordering of the sections from the config files.
 * See directory_walk().
 */

#if defined(HAVE_DRIVE_LETTERS)
#define IS_SPECIAL(entry_core)	\
    ((entry_core)->r != NULL \
	|| ((entry_core)->d[0] != '/' && (entry_core)->d[1] != ':'))
#elif defined(NETWARE)
/* XXX: Fairly certain this is correct... '/' must prefix the path
 *      or else in the case xyz:/ or abc/xyz:/, '/' must follow the ':'.
 *      If there is no leading '/' or embedded ':/', then we are special.
 */
#define IS_SPECIAL(entry_core)	\
    ((entry_core)->r != NULL \
	|| ((entry_core)->d[0] != '/' \
            && strchr((entry_core)->d, ':') \
            && *(strchr((entry_core)->d, ':') + 1) != '/'))
#else
#define IS_SPECIAL(entry_core)	\
    ((entry_core)->r != NULL || (entry_core)->d[0] != '/')
#endif

/* We need to do a stable sort, qsort isn't stable.  So to make it stable
 * we'll be maintaining the original index into the list, and using it
 * as the minor key during sorting.  The major key is the number of
 * components (where a "special" section has infinite components).
 */
struct reorder_sort_rec {
    void *elt;
    int orig_index;
};

static int reorder_sorter(const void *va, const void *vb)
{
    const struct reorder_sort_rec *a = va;
    const struct reorder_sort_rec *b = vb;
    core_dir_config *core_a;
    core_dir_config *core_b;

    core_a = (core_dir_config *)ap_get_module_config(a->elt, &core_module);
    core_b = (core_dir_config *)ap_get_module_config(b->elt, &core_module);
    if (IS_SPECIAL(core_a)) {
	if (!IS_SPECIAL(core_b)) {
	    return 1;
	}
    }
    else if (IS_SPECIAL(core_b)) {
	return -1;
    }
    else {
	/* we know they're both not special */
	if (core_a->d_components < core_b->d_components) {
	    return -1;
	}
	else if (core_a->d_components > core_b->d_components) {
	    return 1;
	}
    }
    /* Either they're both special, or they're both not special and have the
     * same number of components.  In any event, we now have to compare
     * the minor key. */
    return a->orig_index - b->orig_index;
}

CORE_EXPORT(void) ap_core_reorder_directories(pool *p, server_rec *s)
{
    core_server_config *sconf;
    array_header *sec;
    struct reorder_sort_rec *sortbin;
    int nelts;
    void **elts;
    int i;
    pool *tmp;

    sconf = ap_get_module_config(s->module_config, &core_module);
    sec = sconf->sec;
    nelts = sec->nelts;
    elts = (void **)sec->elts;

    /* we have to allocate tmp space to do a stable sort */
    tmp = ap_make_sub_pool(p);
    sortbin = ap_palloc(tmp, sec->nelts * sizeof(*sortbin));
    for (i = 0; i < nelts; ++i) {
	sortbin[i].orig_index = i;
	sortbin[i].elt = elts[i];
    }

    qsort(sortbin, nelts, sizeof(*sortbin), reorder_sorter);

    /* and now copy back to the original array */
    for (i = 0; i < nelts; ++i) {
      elts[i] = sortbin[i].elt;
    }

    ap_destroy_pool(tmp);
}

/*****************************************************************
 *
 * There are some elements of the core config structures in which
 * other modules have a legitimate interest (this is ugly, but necessary
 * to preserve NCSA back-compatibility).  So, we have a bunch of accessors
 * here...
 */

API_EXPORT(int) ap_allow_options(request_rec *r)
{
    core_dir_config *conf =
      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);

    return conf->opts;
}

API_EXPORT(int) ap_allow_overrides(request_rec *r)
{
    core_dir_config *conf;
    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						   &core_module);

    return conf->override;
}

API_EXPORT(const char *) ap_auth_type(request_rec *r)
{
    core_dir_config *conf;

    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						   &core_module);
    return conf->ap_auth_type;
}

API_EXPORT(const char *) ap_auth_name(request_rec *r)
{
    core_dir_config *conf;

    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						   &core_module);
    return conf->ap_auth_name;
}

API_EXPORT(const char *) ap_auth_nonce(request_rec *r)
{
    core_dir_config *conf;
    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
                                                   &core_module);
    if (conf->ap_auth_nonce)
       return conf->ap_auth_nonce;

    /* Ideally we'd want to mix in some per-directory style
     * information; as we are likely to want to detect replay
     * across those boundaries and some randomness. But that
     * is harder due to the adhoc nature of .htaccess memory
     * structures, restarts and forks.
     *
     * But then again - you should use AuthDigestRealmSeed in your config
     * file if you care. So the adhoc value should do.
     */
    return ap_psprintf(r->pool,"%pp%pp%pp%pp%pp",
	   (void *)&(((struct sockaddr_in *)&r->connection->local_addr)->sin_addr ),
           (void *)ap_user_name,
           (void *)ap_listeners,
           (void *)ap_server_argv0,
           (void *)ap_pid_fname);
}

API_EXPORT(const char *) ap_default_type(request_rec *r)
{
    core_dir_config *conf;

    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						   &core_module);
    return conf->ap_default_type
               ? conf->ap_default_type
               : DEFAULT_CONTENT_TYPE;
}

API_EXPORT(const char *) ap_document_root(request_rec *r) /* Don't use this! */
{
    core_server_config *conf;

    conf = (core_server_config *)ap_get_module_config(r->server->module_config,
						      &core_module);
    return conf->ap_document_root;
}

API_EXPORT(const array_header *) ap_requires(request_rec *r)
{
    core_dir_config *conf;

    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						   &core_module);
    return conf->ap_requires;
}

API_EXPORT(int) ap_satisfies(request_rec *r)
{
    core_dir_config *conf;

    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						   &core_module);

    return conf->satisfy;
}

/* Should probably just get rid of this... the only code that cares is
 * part of the core anyway (and in fact, it isn't publicised to other
 * modules).
 */

API_EXPORT(char *) ap_response_code_string(request_rec *r, int error_index)
{
    core_dir_config *conf;

    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						   &core_module);

    if (conf->response_code_strings == NULL) {
	return NULL;
    }
    return conf->response_code_strings[error_index];
}


/* Code from Harald Hanche-Olsen <hanche@@imf.unit.no> */
/* Note: the function returns its result in conn->double_reverse:
 *       +1: forward lookup of the previously reverse-looked-up
 *           hostname in conn->remote_host succeeded, and at
 *           least one of its IP addresses matches the client.
 *       -1: forward lookup of conn->remote_host failed, or
 *           none of the addresses found matches the client connection
 *           (possible DNS spoof in the reverse zone!)
 *       If do_double_reverse() returns -1, then it also invalidates
 *       conn->remote_host to prevent an invalid name from appearing
 *       in the log files. Conn->remote_host is set to "", because
 *       a setting of NULL would allow another reverse lookup,
 *       depending on the flags given to ap_get_remote_host().
 */
static ap_inline void do_double_reverse (conn_rec *conn)
{
    struct addrinfo hints, *res, *res0;
    char hostbuf1[128], hostbuf2[128]; /* INET6_ADDRSTRLEN(=46) is enough */
    int ok = 0;

    if (conn->double_reverse) {
	/* already done */
	return;
    }
    if (conn->remote_host == NULL || conn->remote_host[0] == '\0') {
	/* single reverse failed, so don't bother */
	conn->double_reverse = -1;
        conn->remote_host = ""; /* prevent another lookup */
	return;
    }
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    if (getaddrinfo(conn->remote_host, NULL, &hints, &res0)) {
	conn->double_reverse = -1;
	return;
    }
    for (res = res0; res; res = res->ai_next) {
	if (res->ai_addr->sa_family != conn->remote_addr.ss_family ||
	    !(res->ai_family == AF_INET
#ifdef INET6
	      || res->ai_family == AF_INET6
#endif
	      )
	    )
	    continue;
#ifndef HAVE_SOCKADDR_LEN
	if (res->ai_addrlen != SA_LEN((struct sockaddr *)&conn->remote_addr))
#else
	if (res->ai_addr->sa_len != conn->remote_addr.ss_len)
#endif
	    continue;
	if (getnameinfo(res->ai_addr, res->ai_addrlen,
            hostbuf1, sizeof(hostbuf1), NULL, 0,
            NI_NUMERICHOST))
	    continue;
	if (getnameinfo(((struct sockaddr *)&conn->remote_addr), res->ai_addrlen,
            hostbuf2, sizeof(hostbuf2), NULL, 0,
            NI_NUMERICHOST))
	    continue;
	if (strcmp(hostbuf1, hostbuf2) == 0){
	    ok = 1;
	    break;
	}
    }
    conn->double_reverse = ok ? 1 : -1;
    freeaddrinfo(res0);
}

API_EXPORT(const char *) ap_get_remote_host(conn_rec *conn, void *dir_config,
					    int type)
{
    int hostname_lookups;
    int old_stat = SERVER_DEAD;	/* we shouldn't ever be in this state */
    char hostnamebuf[MAXHOSTNAMELEN];

    /* If we haven't checked the host name, and we want to */
    if (dir_config) {
	hostname_lookups =
	    ((core_dir_config *)ap_get_module_config(dir_config, &core_module))
		->hostname_lookups;
	if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {
	    hostname_lookups = HOSTNAME_LOOKUP_OFF;
	}
    }
    else {
	/* the default */
	hostname_lookups = HOSTNAME_LOOKUP_OFF;
    }

    if (type != REMOTE_NOLOOKUP
	&& conn->remote_host == NULL
	&& (type == REMOTE_DOUBLE_REV
	    || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {
	old_stat = ap_update_child_status(conn->child_num, SERVER_BUSY_DNS,
					  (request_rec*)NULL);
	if (!getnameinfo((struct sockaddr *)&conn->remote_addr,
#ifndef SIN6_LEN
		SA_LEN((struct sockaddr *)&conn->remote_addr),
#else
		conn->remote_addr.ss_len,
#endif
		hostnamebuf, sizeof(hostnamebuf), NULL, 0, 0)) {
	    conn->remote_host = ap_pstrdup(conn->pool, (void *)hostnamebuf);
	    ap_str_tolower(conn->remote_host);

	    if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {
		do_double_reverse(conn);
	    }
	}
	/* if failed, set it to the NULL string to indicate error */
	if (conn->remote_host == NULL) {
	    conn->remote_host = "";
	}
    }
    if (type == REMOTE_DOUBLE_REV) {
	do_double_reverse(conn);
	if (conn->double_reverse == -1) {
	    return NULL;
	}
    }
    if (old_stat != SERVER_DEAD) {
	(void)ap_update_child_status(conn->child_num, old_stat,
				     (request_rec*)NULL);
    }

/*
 * Return the desired information; either the remote DNS name, if found,
 * or either NULL (if the hostname was requested) or the IP address
 * (if any identifier was requested).
 */
    if (conn->remote_host != NULL && conn->remote_host[0] != '\0') {
	return conn->remote_host;
    }
    else {
	if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {
	    return NULL;
	}
	else {
	    return conn->remote_ip;
	}
    }
}

API_EXPORT(const char *) ap_get_remote_logname(request_rec *r)
{
    core_dir_config *dir_conf;

    if (r->connection->remote_logname != NULL) {
	return r->connection->remote_logname;
    }

/* If we haven't checked the identity, and we want to */
    dir_conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						       &core_module);

    if (dir_conf->do_rfc1413 & 1) {
	return ap_rfc1413(r->connection, r->server);
    }
    else {
	return NULL;
    }
}

/* There are two options regarding what the "name" of a server is.  The
 * "canonical" name as defined by ServerName and Port, or the "client's
 * name" as supplied by a possible Host: header or full URI.  We never
 * trust the port passed in the client's headers, we always use the
 * port of the actual socket.
 *
 * The DNS option to UseCanonicalName causes this routine to do a
 * reverse lookup on the local IP address of the connectiona and use
 * that for the ServerName. This makes its value more reliable while
 * at the same time allowing Demon's magic virtual hosting to work.
 * The assumption is that DNS lookups are sufficiently quick...
 * -- fanf 1998-10-03
 */
API_EXPORT(const char *) ap_get_server_name(request_rec *r)
{
    conn_rec *conn = r->connection;
    core_dir_config *d;
    char hbuf[MAXHOSTNAMELEN];

    d = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						&core_module);

    if (d->use_canonical_name == USE_CANONICAL_NAME_OFF) {
        return r->hostname ? r->hostname : r->server->server_hostname;
    }
    if (d->use_canonical_name == USE_CANONICAL_NAME_DNS) {
        if (conn->local_host == NULL) {
            int old_stat;
	    old_stat = ap_update_child_status(conn->child_num,
					      SERVER_BUSY_DNS, r);
	    if (getnameinfo((struct sockaddr *)&conn->local_addr,
#ifndef SIN6_LEN
		    SA_LEN((struct sockaddr *)&conn->local_addr),
#else
		    conn->local_addr.ss_len,
#endif
		    hbuf, sizeof(hbuf), NULL, 0, 0) == 0) {
		conn->local_host = ap_pstrdup(conn->pool, hbuf);
	    } else {
		conn->local_host = ap_pstrdup(conn->pool,
		    r->server->server_hostname);
	    }
	    ap_str_tolower(conn->local_host);
	    (void) ap_update_child_status(conn->child_num, old_stat, r);
	}
	return conn->local_host;
    }
    /* default */
    return r->server->server_hostname;
}

API_EXPORT(unsigned) ap_get_server_port(const request_rec *r)
{
    unsigned port;
    unsigned cport = ntohs(((struct sockaddr_in *)&r->connection->local_addr)->sin_port);
    core_dir_config *d =
      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);

    if (d->use_canonical_name == USE_CANONICAL_NAME_OFF
        || d->use_canonical_name == USE_CANONICAL_NAME_DNS) {

        /* With UseCanonicalName Off Apache will form self-referential
         * URLs using the hostname and port supplied by the client if
         * any are supplied (otherwise it will use the canonical name).
         */
        port = r->parsed_uri.port_str ? r->parsed_uri.port :
          cport ? cport :
            r->server->port ? r->server->port :
              ap_default_port(r);
    } else { /* d->use_canonical_name == USE_CANONICAL_NAME_ON */
        port = r->server->port ? r->server->port :
          cport ? cport :
            ap_default_port(r);
    }

    /* default */
    return port;
}

API_EXPORT(char *) ap_construct_url(pool *p, const char *uri,
				    request_rec *r)
{
    unsigned port = ap_get_server_port(r);
    const char *host = ap_get_server_name(r);

    if (ap_is_default_port(port, r)) {
	return ap_pstrcat(p, ap_http_method(r), "://", host, uri, NULL);
    }
    return ap_psprintf(p, "%s://%s:%u%s", ap_http_method(r), host, port, uri);
}

API_EXPORT(unsigned long) ap_get_limit_req_body(const request_rec *r)
{
    core_dir_config *d =
      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);

    return d->limit_req_body;
}


/*****************************************************************
 *
 * Commands... this module handles almost all of the NCSA httpd.conf
 * commands, but most of the old srm.conf is in the the modules.
 */

static const char end_directory_section[] = "</Directory>";
static const char end_directorymatch_section[] = "</DirectoryMatch>";
static const char end_location_section[] = "</Location>";
static const char end_locationmatch_section[] = "</LocationMatch>";
static const char end_files_section[] = "</Files>";
static const char end_filesmatch_section[] = "</FilesMatch>";
static const char end_virtualhost_section[] = "</VirtualHost>";
static const char end_ifmodule_section[] = "</IfModule>";
static const char end_ifdefine_section[] = "</IfDefine>";


API_EXPORT(const char *) ap_check_cmd_context(cmd_parms *cmd,
					      unsigned forbidden)
{
    const char *gt = (cmd->cmd->name[0] == '<'
		      && cmd->cmd->name[strlen(cmd->cmd->name)-1] != '>')
                         ? ">" : "";

    if ((forbidden & NOT_IN_VIRTUALHOST) && cmd->server->is_virtual) {
	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
			  " cannot occur within <VirtualHost> section", NULL);
    }

    if ((forbidden & NOT_IN_LIMIT) && cmd->limited != -1) {
	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
			  " cannot occur within <Limit> section", NULL);
    }

    if ((forbidden & NOT_IN_DIR_LOC_FILE) == NOT_IN_DIR_LOC_FILE
	&& cmd->path != NULL) {
	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
			  " cannot occur within <Directory/Location/Files> "
			  "section", NULL);
    }

    if (((forbidden & NOT_IN_DIRECTORY)
	 && (cmd->end_token == end_directory_section
	     || cmd->end_token == end_directorymatch_section))
	|| ((forbidden & NOT_IN_LOCATION)
	    && (cmd->end_token == end_location_section
		|| cmd->end_token == end_locationmatch_section))
	|| ((forbidden & NOT_IN_FILES)
	    && (cmd->end_token == end_files_section
		|| cmd->end_token == end_filesmatch_section))) {
	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
			  " cannot occur within <", cmd->end_token+2,
			  " section", NULL);
    }

    return NULL;
}

static const char *set_access_name(cmd_parms *cmd, void *dummy, char *arg)
{
    void *sconf = cmd->server->module_config;
    core_server_config *conf = ap_get_module_config(sconf, &core_module);

    const char *err = ap_check_cmd_context(cmd,
					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    conf->access_name = ap_pstrdup(cmd->pool, arg);
    return NULL;
}

#ifdef GPROF
static const char *set_gprof_dir(cmd_parms *cmd, void *dummy, char *arg)
{
    void *sconf = cmd->server->module_config;
    core_server_config *conf = ap_get_module_config(sconf, &core_module);

    const char *err = ap_check_cmd_context(cmd,
					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    conf->gprof_dir = ap_pstrdup(cmd->pool, arg);
    return NULL;
}
#endif /*GPROF*/

static const char *set_add_default_charset(cmd_parms *cmd,
	core_dir_config *d, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }
    if (!strcasecmp(arg, "Off")) {
       d->add_default_charset = ADD_DEFAULT_CHARSET_OFF;
    }
    else if (!strcasecmp(arg, "On")) {
       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;
       d->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;
    }
    else {
       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;
       d->add_default_charset_name = arg;
    }
    return NULL;
}
static const char *set_accept_mutex(cmd_parms *cmd, void *dummy, char *arg)
{
	return ap_init_mutex_method(arg);
}

static const char *set_document_root(cmd_parms *cmd, void *dummy, char *arg)
{
    void *sconf = cmd->server->module_config;
    core_server_config *conf = ap_get_module_config(sconf, &core_module);

    const char *err = ap_check_cmd_context(cmd,
					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    arg = ap_os_canonical_filename(cmd->pool, arg);
    if (ap_configtestonly && ap_docrootcheck && !ap_is_directory(arg)) {
	if (cmd->server->is_virtual) {
	    fprintf(stderr, "Warning: DocumentRoot [%s] does not exist\n",
		    arg);
	}
	else {
	    return "DocumentRoot must be a directory";
	}
    }
    ap_server_strip_chroot(arg, 1);
    conf->ap_document_root = arg;
    return NULL;
}

API_EXPORT(void) ap_custom_response(request_rec *r, int status, char *string)
{
    core_dir_config *conf =
	ap_get_module_config(r->per_dir_config, &core_module);
    int idx;

    ap_server_strip_chroot(conf->d, 0);
    if(conf->response_code_strings == NULL) {
        conf->response_code_strings =
	    ap_pcalloc(r->pool,
		    sizeof(*conf->response_code_strings) *
                       RESPONSE_CODES);
    }

    idx = ap_index_of_response(status);

    conf->response_code_strings[idx] =
       ((ap_is_url(string) || (*string == '/')) && (*string != '"')) ?
       ap_pstrdup(r->pool, string) : ap_pstrcat(r->pool, "\"", string, NULL);
}

static const char *set_error_document(cmd_parms *cmd, core_dir_config *conf,
				      char *line)
{
    int error_number, index_number, idx500;
    char *w;

    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    /* 1st parameter should be a 3 digit number, which we recognize;
     * convert it into an array index
     */

    w = ap_getword_conf_nc(cmd->pool, &line);
    error_number = atoi(w);

    idx500 = ap_index_of_response(HTTP_INTERNAL_SERVER_ERROR);

    if (error_number == HTTP_INTERNAL_SERVER_ERROR) {
        index_number = idx500;
    }
    else if ((index_number = ap_index_of_response(error_number)) == idx500) {
        return ap_pstrcat(cmd->pool, "Unsupported HTTP response code ",
			  w, NULL);
    }

    /* The entry should be ignored if it is a full URL for a 401 error */

    if (error_number == 401 &&
	line[0] != '/' && line[0] != '"') { /* Ignore it... */
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, cmd->server,
		     "cannot use a full URL in a 401 ErrorDocument "
		     "directive --- ignoring!");
    }
    else { /* Store it... */
    	if (conf->response_code_strings == NULL) {
	    conf->response_code_strings =
		ap_pcalloc(cmd->pool,
			   sizeof(*conf->response_code_strings) * RESPONSE_CODES);
        }
        conf->response_code_strings[index_number] = ap_pstrdup(cmd->pool, line);
    }

    return NULL;
}

/* access.conf commands...
 *
 * The *only* thing that can appear in access.conf at top level is a
 * <Directory> section.  NB we need to have a way to cut the srm_command_loop
 * invoked by dirsection (i.e., <Directory>) short when </Directory> is seen.
 * We do that by returning an error, which dirsection itself recognizes and
 * discards as harmless.  Cheesy, but it works.
 */

static const char *set_override(cmd_parms *cmd, core_dir_config *d,
				const char *l)
{
    char *w;

    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    d->override = OR_NONE;
    while (l[0]) {
        w = ap_getword_conf(cmd->pool, &l);
	if (!strcasecmp(w, "Limit")) {
	    d->override |= OR_LIMIT;
	}
	else if (!strcasecmp(w, "Options")) {
	    d->override |= OR_OPTIONS;
	}
	else if (!strcasecmp(w, "FileInfo")) {
            d->override |= OR_FILEINFO;
	}
	else if (!strcasecmp(w, "AuthConfig")) {
	    d->override |= OR_AUTHCFG;
	}
	else if (!strcasecmp(w, "Indexes")) {
            d->override |= OR_INDEXES;
	}
	else if (!strcasecmp(w, "None")) {
	    d->override = OR_NONE;
	}
	else if (!strcasecmp(w, "All")) {
	    d->override = OR_ALL;
	}
	else {
	    return ap_pstrcat(cmd->pool, "Illegal override option ", w, NULL);
	}
	d->override &= ~OR_UNSET;
    }

    return NULL;
}

static const char *set_options(cmd_parms *cmd, core_dir_config *d,
			       const char *l)
{
    allow_options_t opt;
    int first = 1;
    char action;

    while (l[0]) {
        char *w = ap_getword_conf(cmd->pool, &l);
	action = '\0';

	if (*w == '+' || *w == '-') {
	    action = *(w++);
	}
	else if (first) {
  	    d->opts = OPT_NONE;
            first = 0;
        }

	if (!strcasecmp(w, "Indexes")) {
	    opt = OPT_INDEXES;
	}
	else if (!strcasecmp(w, "Includes")) {
	    opt = OPT_INCLUDES;
	}
	else if (!strcasecmp(w, "IncludesNOEXEC")) {
	    opt = (OPT_INCLUDES | OPT_INCNOEXEC);
	}
	else if (!strcasecmp(w, "FollowSymLinks")) {
	    opt = OPT_SYM_LINKS;
	}
	else if (!strcasecmp(w, "SymLinksIfOwnerMatch")) {
	    opt = OPT_SYM_OWNER;
	}
	else if (!strcasecmp(w, "execCGI")) {
	    opt = OPT_EXECCGI;
	}
	else if (!strcasecmp(w, "MultiViews")) {
	    opt = OPT_MULTI;
	}
	else if (!strcasecmp(w, "RunScripts")) { /* AI backcompat. Yuck */
	    opt = OPT_MULTI|OPT_EXECCGI;
	}
	else if (!strcasecmp(w, "None")) {
	    opt = OPT_NONE;
	}
	else if (!strcasecmp(w, "All")) {
	    opt = OPT_ALL;
	}
	else {
	    return ap_pstrcat(cmd->pool, "Illegal option ", w, NULL);
	}

	/* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
	if (action == '-') {
	    d->opts_remove |= opt;
	    d->opts_add &= ~opt;
	    d->opts &= ~opt;
	}
	else if (action == '+') {
	    d->opts_add |= opt;
	    d->opts_remove &= ~opt;
	    d->opts |= opt;
	}
	else {
	    d->opts |= opt;
	}
    }

    return NULL;
}

static const char *satisfy(cmd_parms *cmd, core_dir_config *c, char *arg)
{
    if (!strcasecmp(arg, "all")) {
        c->satisfy = SATISFY_ALL;
    }
    else if (!strcasecmp(arg, "any")) {
        c->satisfy = SATISFY_ANY;
    }
    else {
        return "Satisfy either 'any' or 'all'.";
    }
    return NULL;
}

static const char *require(cmd_parms *cmd, core_dir_config *c, char *arg)
{
    require_line *r;

    if (!c->ap_requires) {
        c->ap_requires = ap_make_array(cmd->pool, 2, sizeof(require_line));
    }
    r = (require_line *)ap_push_array(c->ap_requires);
    r->requirement = ap_pstrdup(cmd->pool, arg);
    r->method_mask = cmd->limited;
    return NULL;
}

CORE_EXPORT_NONSTD(const char *) ap_limit_section(cmd_parms *cmd, void *dummy,
						  const char *arg)
{
    const char *limited_methods = ap_getword(cmd->pool, &arg, '>');
    void *tog = cmd->cmd->cmd_data;
    int limited = 0;

    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    /* XXX: NB: Currently, we have no way of checking
     * whether <Limit> or <LimitExcept> sections are closed properly.
     * (If we would add a srm_command_loop() here we might...)
     */

    while (limited_methods[0]) {
        char *method = ap_getword_conf(cmd->pool, &limited_methods);
        int  methnum = ap_method_number_of(method);

        if (methnum == M_TRACE && !tog) {
            return "TRACE cannot be controlled by <Limit>";
        }
        else if (methnum == M_INVALID) {
            return ap_pstrcat(cmd->pool, "unknown method \"", method,
                              "\" in <Limit", tog ? "Except>" : ">", NULL);
        }
        else {
            limited |= (1 << methnum);
        }
    }

    /* Killing two features with one function,
     * if (tog == NULL) <Limit>, else <LimitExcept>
     */
    cmd->limited = tog ? ~limited : limited;
    return NULL;
}

static const char *endlimit_section(cmd_parms *cmd, void *dummy, void *dummy2)
{
    void *tog = cmd->cmd->cmd_data;

    if (cmd->limited == -1) {
        return tog ? "</LimitExcept> unexpected" : "</Limit> unexpected";
    }

    cmd->limited = -1;
    return NULL;
}

/*
 * When a section is not closed properly when end-of-file is reached,
 * then an error message should be printed:
 */
static const char *missing_endsection(cmd_parms *cmd, int nest)
{
    if (nest < 2) {
	return ap_psprintf(cmd->pool, "Missing %s directive at end-of-file",
			   cmd->end_token);
    }
    return ap_psprintf(cmd->pool, "%d missing %s directives at end-of-file",
		       nest, cmd->end_token);
}

/* We use this in <DirectoryMatch> and <FilesMatch>, to ensure that
 * people don't get bitten by wrong-cased regex matches
 */

#define USE_ICASE 0

static const char *end_nested_section(cmd_parms *cmd, void *dummy)
{
    if (cmd->end_token == NULL) {
        return ap_pstrcat(cmd->pool, cmd->cmd->name,
			  " without matching <", cmd->cmd->name + 2,
			  " section", NULL);
    }
    /*
     * This '!=' may look weird on a string comparison, but it's correct --
     * it's been set up so that checking for two pointers to the same datum
     * is valid here.  And faster.
     */
    if (cmd->cmd->name != cmd->end_token) {
	return ap_pstrcat(cmd->pool, "Expected ", cmd->end_token, " but saw ",
			  cmd->cmd->name, NULL);
    }
    return cmd->end_token;
}

/*
 * Report a missing-'>' syntax error.
 */
static char *unclosed_directive(cmd_parms *cmd)
{
    return ap_pstrcat(cmd->pool, cmd->cmd->name,
		      "> directive missing closing '>'", NULL);
}

static const char *dirsection(cmd_parms *cmd, void *dummy, const char *arg)
{
    const char *errmsg;
    char *endp = strrchr(arg, '>');
    int old_overrides = cmd->override;
    char *old_path = cmd->path;
    core_dir_config *conf;
    void *new_dir_conf = ap_create_per_dir_config(cmd->pool);
    regex_t *r = NULL;
    const char *old_end_token;
    const command_rec *thiscmd = cmd->cmd;

    const char *err = ap_check_cmd_context(cmd,
					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    if (endp == NULL) {
	return unclosed_directive(cmd);
    }

    *endp = '\0';

    cmd->path = ap_getword_conf(cmd->pool, &arg);
    ap_server_strip_chroot(cmd->path, 1);
    cmd->override = OR_ALL|ACCESS_CONF;

    if (thiscmd->cmd_data) { /* <DirectoryMatch> */
	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
    }
    else if (!strcmp(cmd->path, "~")) {
	cmd->path = ap_getword_conf(cmd->pool, &arg);
	ap_server_strip_chroot(cmd->path, 1);
	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
    }
#if defined(HAVE_DRIVE_LETTERS) || defined(NETWARE)
    else if (strcmp(cmd->path, "/") == 0) {
        /* Treat 'default' path / as an inalienable root */
        cmd->path = ap_pstrdup(cmd->pool, cmd->path);
    }
#endif
#if defined(HAVE_UNC_PATHS)
    else if (strcmp(cmd->path, "//") == 0) {
        /* Treat UNC path // as an inalienable root */
        cmd->path = ap_pstrdup(cmd->pool, cmd->path);
    }
#endif
    else {
	/* Ensure that the pathname is canonical */
	cmd->path = ap_os_canonical_filename(cmd->pool, cmd->path);
    }

    old_end_token = cmd->end_token;
    cmd->end_token = thiscmd->cmd_data ? end_directorymatch_section : end_directory_section;
    errmsg = ap_srm_command_loop(cmd, new_dir_conf);
    if (errmsg == NULL) {
	errmsg = missing_endsection(cmd, 1);
    }
    cmd->end_token = old_end_token;
    if (errmsg != (thiscmd->cmd_data
		       ? end_directorymatch_section
		   : end_directory_section)) {
	return errmsg;
    }

    conf = (core_dir_config *)ap_get_module_config(new_dir_conf, &core_module);
    conf->r = r;

    ap_add_per_dir_conf(cmd->server, new_dir_conf);

    if (*arg != '\0') {
	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
			  "> arguments not (yet) supported.", NULL);
    }

    cmd->path = old_path;
    cmd->override = old_overrides;

    return NULL;
}

static const char *urlsection(cmd_parms *cmd, void *dummy, const char *arg)
{
    const char *errmsg;
    char *endp = strrchr(arg, '>');
    int old_overrides = cmd->override;
    char *old_path = cmd->path;
    core_dir_config *conf;
    regex_t *r = NULL;
    const char *old_end_token;
    const command_rec *thiscmd = cmd->cmd;

    void *new_url_conf = ap_create_per_dir_config(cmd->pool);

    const char *err = ap_check_cmd_context(cmd,
					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    if (endp == NULL) {
	return unclosed_directive(cmd);
    }

    *endp = '\0';

    cmd->path = ap_getword_conf(cmd->pool, &arg);
    ap_server_strip_chroot(cmd->path, 0);
    cmd->override = OR_ALL|ACCESS_CONF;

    if (thiscmd->cmd_data) { /* <LocationMatch> */
	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED);
    }
    else if (!strcmp(cmd->path, "~")) {
	cmd->path = ap_getword_conf(cmd->pool, &arg);
	ap_server_strip_chroot(cmd->path, 0);
	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED);
    }

    old_end_token = cmd->end_token;
    cmd->end_token = thiscmd->cmd_data ? end_locationmatch_section
                                       : end_location_section;
    errmsg = ap_srm_command_loop(cmd, new_url_conf);
    if (errmsg == NULL) {
	errmsg = missing_endsection(cmd, 1);
    }
    cmd->end_token = old_end_token;
    if (errmsg != (thiscmd->cmd_data
		       ? end_locationmatch_section
		       : end_location_section)) {
	return errmsg;
    }

    conf = (core_dir_config *)ap_get_module_config(new_url_conf, &core_module);
    conf->d = ap_pstrdup(cmd->pool, cmd->path);	/* No mangling, please */
    conf->d_is_fnmatch = ap_is_fnmatch(conf->d) != 0;
    conf->r = r;

    ap_add_per_url_conf(cmd->server, new_url_conf);

    if (*arg != '\0') {
	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
			  "> arguments not (yet) supported.", NULL);
    }

    cmd->path = old_path;
    cmd->override = old_overrides;

    return NULL;
}

static const char *filesection(cmd_parms *cmd, core_dir_config *c,
			       const char *arg)
{
    const char *errmsg;
    char *endp = strrchr(arg, '>');
    int old_overrides = cmd->override;
    char *old_path = cmd->path;
    core_dir_config *conf;
    regex_t *r = NULL;
    const char *old_end_token;
    const command_rec *thiscmd = cmd->cmd;

    void *new_file_conf = ap_create_per_dir_config(cmd->pool);

    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT|NOT_IN_LOCATION);
    if (err != NULL) {
        return err;
    }

    if (endp == NULL) {
	return unclosed_directive(cmd);
    }

    *endp = '\0';

    cmd->path = ap_getword_conf(cmd->pool, &arg);
    ap_server_strip_chroot(cmd->path, 1);
    /* Only if not an .htaccess file */
    if (!old_path) {
	cmd->override = OR_ALL|ACCESS_CONF;
    }

    if (thiscmd->cmd_data) { /* <FilesMatch> */
        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
    }
    else if (!strcmp(cmd->path, "~")) {
	cmd->path = ap_getword_conf(cmd->pool, &arg);
	ap_server_strip_chroot(cmd->path, 1);
	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
    }
    else {
	/* Ensure that the pathname is canonical */
	cmd->path = ap_os_canonical_filename(cmd->pool, cmd->path);
    }

    old_end_token = cmd->end_token;
    cmd->end_token = thiscmd->cmd_data ? end_filesmatch_section : end_files_section;
    errmsg = ap_srm_command_loop(cmd, new_file_conf);
    if (errmsg == NULL) {
	errmsg = missing_endsection(cmd, 1);
    }
    cmd->end_token = old_end_token;
    if (errmsg != (thiscmd->cmd_data
		       ? end_filesmatch_section
		   : end_files_section)) {
	return errmsg;
    }

    conf = (core_dir_config *)ap_get_module_config(new_file_conf,
						   &core_module);
    conf->d = cmd->path;
    conf->d_is_fnmatch = ap_is_fnmatch(conf->d) != 0;
    conf->r = r;

    ap_add_file_conf(c, new_file_conf);

    if (*arg != '\0') {
	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
			  "> arguments not (yet) supported.", NULL);
    }

    cmd->path = old_path;
    cmd->override = old_overrides;

    return NULL;
}

/* XXX: NB: Currently, we have no way of checking
 * whether <IfModule> sections are closed properly.
 * Extra (redundant, unpaired) </IfModule> directives are
 * simply silently ignored.
 */
static const char *end_ifmod(cmd_parms *cmd, void *dummy)
{
    return NULL;
}

static const char *start_ifmod(cmd_parms *cmd, void *dummy, char *arg)
{
    char *endp = strrchr(arg, '>');
    char l[MAX_STRING_LEN];
    int not = (arg[0] == '!');
    module *found;
    int nest = 1;

    if (endp == NULL) {
	return unclosed_directive(cmd);
    }

    *endp = '\0';

    if (not) {
        arg++;
    }

    found = ap_find_linked_module(arg);

    if ((!not && found) || (not && !found)) {
        return NULL;
    }

    while (nest && !(ap_cfg_getline(l, MAX_STRING_LEN, cmd->config_file))) {
        if (!strncasecmp(l, "<IfModule", 9)) {
	    nest++;
	}
	if (!strcasecmp(l, "</IfModule>")) {
	  nest--;
	}
    }

    if (nest) {
	cmd->end_token = end_ifmodule_section;
	return missing_endsection(cmd, nest);
    }
    return NULL;
}

API_EXPORT(int) ap_exists_config_define(char *name)
{
    char **defines;
    int i;

    defines = (char **)ap_server_config_defines->elts;
    for (i = 0; i < ap_server_config_defines->nelts; i++) {
        if (strcmp(defines[i], name) == 0) {
            return 1;
	}
    }
    return 0;
}

static const char *end_ifdefine(cmd_parms *cmd, void *dummy)
{
    return NULL;
}

static const char *start_ifdefine(cmd_parms *cmd, void *dummy, char *arg)
{
    char *endp;
    char l[MAX_STRING_LEN];
    int defined;
    int not = 0;
    int nest = 1;

    endp = strrchr(arg, '>');
    if (endp == NULL) {
	return unclosed_directive(cmd);
    }

    *endp = '\0';

    if (arg[0] == '!') {
        not = 1;
	arg++;
    }

    defined = ap_exists_config_define(arg);

    if ((!not && defined) || (not && !defined)) {
	return NULL;
    }

    while (nest && !(ap_cfg_getline(l, MAX_STRING_LEN, cmd->config_file))) {
        if (!strncasecmp(l, "<IfDefine", 9)) {
	    nest++;
	}
	if (!strcasecmp(l, "</IfDefine>")) {
	    nest--;
	}
    }
    if (nest) {
	cmd->end_token = end_ifdefine_section;
	return missing_endsection(cmd, nest);
    }
    return NULL;
}

/* httpd.conf commands... beginning with the <VirtualHost> business */

static const char *virtualhost_section(cmd_parms *cmd, void *dummy, char *arg)
{
    server_rec *main_server = cmd->server, *s;
    const char *errmsg;
    char *endp = strrchr(arg, '>');
    pool *p = cmd->pool, *ptemp = cmd->temp_pool;
    const char *old_end_token;

    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    if (endp == NULL) {
	return unclosed_directive(cmd);
    }

    *endp = '\0';

    /* FIXME: There's another feature waiting to happen here -- since you
	can now put multiple addresses/names on a single <VirtualHost>
	you might want to use it to group common definitions and then
	define other "subhosts" with their individual differences.  But
	personally I'd rather just do it with a macro preprocessor. -djg */
    if (main_server->is_virtual) {
	return "<VirtualHost> doesn't nest!";
    }

    errmsg = ap_init_virtual_host(p, arg, main_server, &s);
    if (errmsg) {
	return errmsg;
    }

    s->next = main_server->next;
    main_server->next = s;

    s->defn_name = cmd->config_file->name;
    s->defn_line_number = cmd->config_file->line_number;

    old_end_token = cmd->end_token;
    cmd->end_token = end_virtualhost_section;
    cmd->server = s;
    errmsg = ap_srm_command_loop(cmd, s->lookup_defaults);
    cmd->server = main_server;
    if (errmsg == NULL) {
	errmsg = missing_endsection(cmd, 1);
    }
    cmd->end_token = old_end_token;

    if (s->srm_confname) {
	ap_process_resource_config(s, s->srm_confname, p, ptemp);
    }

    if (s->access_confname) {
	ap_process_resource_config(s, s->access_confname, p, ptemp);
    }

    if (errmsg == end_virtualhost_section) {
	return NULL;
    }
    return errmsg;
}

static const char *set_server_alias(cmd_parms *cmd, void *dummy,
				    const char *arg)
{
    if (!cmd->server->names) {
	return "ServerAlias only used in <VirtualHost>";
    }
    while (*arg) {
	char **item, *name = ap_getword_conf(cmd->pool, &arg);
	if (ap_is_matchexp(name)) {
	    item = (char **)ap_push_array(cmd->server->wild_names);
	}
	else {
	    item = (char **)ap_push_array(cmd->server->names);
	}
	*item = name;
    }
    return NULL;
}

static const char *add_module_command(cmd_parms *cmd, void *dummy, char *arg)
{
    module *modp;
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    for (modp = top_module; modp; modp = modp->next) {
        if (modp->name != NULL && strcmp(modp->name, arg) == 0) {
            ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
                          "module %s is already added, skipping", arg);
            return NULL;
        }
    }

    if (!ap_add_named_module(arg)) {
	return ap_pstrcat(cmd->pool, "Cannot add module via name '", arg,
			  "': not in list of loaded modules", NULL);
    }
    return NULL;
}

static const char *clear_module_list_command(cmd_parms *cmd, void *dummy)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_clear_module_list();
    return NULL;
}

static const char *set_server_string_slot(cmd_parms *cmd, void *dummy,
					  char *arg)
{
    /* This one's pretty generic... */

    int offset = (int)(long)cmd->info;
    char *struct_ptr = (char *)cmd->server;

    const char *err = ap_check_cmd_context(cmd,
					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    *(char **)(struct_ptr + offset) = arg;
    return NULL;
}

static const char *server_type(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    if (!strcasecmp(arg, "inetd")) {
        ap_standalone = 0;
    }
    else if (!strcasecmp(arg, "standalone")) {
        ap_standalone = 1;
    }
    else {
        return "ServerType must be either 'inetd' or 'standalone'";
    }

    return NULL;
}

static const char *server_port(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    int port;

    if (err != NULL) {
	return err;
    }
    port = atoi(arg);
    if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */
	return ap_pstrcat(cmd->temp_pool, "The port number \"", arg,
			  "\" is outside the appropriate range "
			  "(i.e., 1..65535).", NULL);
    }
    cmd->server->port = port;
    return NULL;
}

static const char *set_signature_flag(cmd_parms *cmd, core_dir_config *d,
				      char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    if (strcasecmp(arg, "On") == 0) {
	d->server_signature = srv_sig_on;
    }
    else if (strcasecmp(arg, "Off") == 0) {
        d->server_signature = srv_sig_off;
    }
    else if (strcasecmp(arg, "EMail") == 0) {
	d->server_signature = srv_sig_withmail;
    }
    else {
	return "ServerSignature: use one of: off | on | email";
    }
    return NULL;
}

static const char *set_send_buffer_size(cmd_parms *cmd, void *dummy, char *arg)
{
    int s = atoi(arg);
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    if (s < 512 && s != 0) {
        return "SendBufferSize must be >= 512 bytes, or 0 for system default.";
    }
    cmd->server->send_buffer_size = s;
    return NULL;
}

static const char *set_user(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    /*
     * This is, again, tricky. on restarts, we cannot use uname2id.
     * keep the old settings for the main server.
     * barf out on user directives in <VirtualHost> sections.
     */

    if (!cmd->server->is_virtual) {
	if (!ap_server_is_chrooted()) {
	    ap_user_name = arg;
	    ap_user_id = ap_uname2id(arg);
	}
	cmd->server->server_uid = ap_user_id;
    }
    else {
        if (ap_suexec_enabled) {
	    if (ap_server_is_chrooted()) {
		fprintf(stderr, "cannot look up uids once chrooted. Thus, User "
		    "directives inside <VirtualHost> and restarts aren't "
		    "possible together. Please stop httpd and start a new "
		    "one\n");
		exit(1);
	    } else
		cmd->server->server_uid = ap_uname2id(arg);
	}
	else {
	    cmd->server->server_uid = ap_user_id;
	    fprintf(stderr,
		    "Warning: User directive in <VirtualHost> "
		    "requires SUEXEC wrapper.\n");
	}
    }
#if !defined (BIG_SECURITY_HOLE) && !defined (OS2)
    if (cmd->server->server_uid == 0) {
	fprintf(stderr,
		"Error:\tApache has not been designed to serve pages while\n"
		"\trunning as root.  There are known race conditions that\n"
		"\twill allow any local user to read any file on the system.\n"
		"\tIf you still desire to serve pages as root then\n"
		"\tadd -DBIG_SECURITY_HOLE to the EXTRA_CFLAGS line in your\n"
		"\tsrc/Configuration file and rebuild the server.  It is\n"
		"\tstrongly suggested that you instead modify the User\n"
		"\tdirective in your httpd.conf file to list a non-root\n"
		"\tuser.\n");
	exit (1);
    }
#endif

    return NULL;
}

static const char *set_group(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    if (!cmd->server->is_virtual) {
	if (!ap_server_is_chrooted()) {
	    ap_group_id = ap_gname2id(arg);
	}
	cmd->server->server_gid = ap_group_id;
    }
    else {
        if (ap_suexec_enabled) {
	    if (ap_server_is_chrooted()) {
		fprintf(stderr, "cannot look up gids once chrooted. Thus, Group"
		    " directives inside <VirtualHost> and restarts aren't "
		    "possible together. Please stop httpd and start a new "
		    "one\n");
		exit(1);
	    } else
		cmd->server->server_gid = ap_gname2id(arg);
	}
	else {
	    cmd->server->server_gid = ap_group_id;
	    fprintf(stderr,
		    "Warning: Group directive in <VirtualHost> requires "
		    "SUEXEC wrapper.\n");
	}
    }

    return NULL;
}

static const char *set_server_root(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);

    if (err != NULL) {
        return err;
    }

    arg = ap_os_canonical_filename(cmd->pool, arg);

    /*
     * This is a bit tricky. On startup we are not chrooted here.
     * On restarts (graceful or not) we are (unless we're in unsecure mode).
     * if we would strip off the chroot prefix, nothing (not even "/")
     * would last.
     * it's pointless to test wether ServerRoot is a directory if we are
     * already chrooted into that.
     * Of course it's impossible to change ServerRoot without a full restart.
     * should we abort with an error if ap_server_root != arg?
     */

    if (!ap_server_is_chrooted()) {
	if (!ap_is_directory(arg)) {
	    return "ServerRoot must be a valid directory";
	}
	/* ServerRoot is never '/' terminated */
	while (strlen(ap_server_root) > 1 && ap_server_root[strlen(ap_server_root)-1] == '/')
	    ap_server_root[strlen(ap_server_root)-1] = '\0';
	ap_cpystrn(ap_server_root, arg, sizeof(ap_server_root));
    }
    return NULL;
}

static const char *set_timeout(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    cmd->server->timeout = atoi(arg);
    return NULL;
}

static const char *set_keep_alive_timeout(cmd_parms *cmd, void *dummy,
					  char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    cmd->server->keep_alive_timeout = atoi(arg);
    return NULL;
}

static const char *set_keep_alive(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    /* We've changed it to On/Off, but used to use numbers
     * so we accept anything but "Off" or "0" as "On"
     */
    if (!strcasecmp(arg, "off") || !strcmp(arg, "0")) {
	cmd->server->keep_alive = 0;
    }
    else {
	cmd->server->keep_alive = 1;
    }
    return NULL;
}

static const char *set_keep_alive_max(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    cmd->server->keep_alive_max = atoi(arg);
    return NULL;
}

static const char *set_pidfile(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    if (cmd->server->is_virtual) {
	return "PidFile directive not allowed in <VirtualHost>";
    }
    ap_pid_fname = arg;
    return NULL;
}

static const char *set_scoreboard(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_scoreboard_fname = arg;
    return NULL;
}

static const char *set_lockfile(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_lock_fname = arg;
    return NULL;
}

static const char *set_idcheck(cmd_parms *cmd, core_dir_config *d, int arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    d->do_rfc1413 = arg != 0;
    return NULL;
}

static const char *set_hostname_lookups(cmd_parms *cmd, core_dir_config *d,
					char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    if (!strcasecmp(arg, "on")) {
	d->hostname_lookups = HOSTNAME_LOOKUP_ON;
    }
    else if (!strcasecmp(arg, "off")) {
	d->hostname_lookups = HOSTNAME_LOOKUP_OFF;
    }
    else if (!strcasecmp(arg, "double")) {
	d->hostname_lookups = HOSTNAME_LOOKUP_DOUBLE;
    }
    else {
	return "parameter must be 'on', 'off', or 'double'";
    }
    return NULL;
}

static const char *set_serverpath(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    cmd->server->path = arg;
    cmd->server->pathlen = strlen(arg);
    return NULL;
}

static const char *set_content_md5(cmd_parms *cmd, core_dir_config *d, int arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    d->content_md5 = arg != 0;
    return NULL;
}

static const char *set_use_canonical_name(cmd_parms *cmd, core_dir_config *d,
					  char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
    if (err != NULL) {
	return err;
    }

    if (strcasecmp(arg, "on") == 0) {
        d->use_canonical_name = USE_CANONICAL_NAME_ON;
    }
    else if (strcasecmp(arg, "off") == 0) {
        d->use_canonical_name = USE_CANONICAL_NAME_OFF;
    }
    else if (strcasecmp(arg, "dns") == 0) {
        d->use_canonical_name = USE_CANONICAL_NAME_DNS;
    }
    else {
        return "parameter must be 'on', 'off', or 'dns'";
    }
    return NULL;
}

static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_daemons_to_start = atoi(arg);
    return NULL;
}

static const char *set_min_free_servers(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_daemons_min_free = atoi(arg);
    if (ap_daemons_min_free <= 0) {
       fprintf(stderr, "WARNING: detected MinSpareServers set to non-positive.\n");
       fprintf(stderr, "Resetting to 1 to avoid almost certain Apache failure.\n");
       fprintf(stderr, "Please read the documentation.\n");
       ap_daemons_min_free = 1;
    }

    return NULL;
}

static const char *set_max_free_servers(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_daemons_max_free = atoi(arg);
    return NULL;
}

static const char *set_server_limit (cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_daemons_limit = atoi(arg);
    if (ap_daemons_limit > HARD_SERVER_LIMIT) {
       fprintf(stderr, "WARNING: MaxClients of %d exceeds compile time limit "
           "of %d servers,\n", ap_daemons_limit, HARD_SERVER_LIMIT);
       fprintf(stderr, " lowering MaxClients to %d.  To increase, please "
           "see the\n", HARD_SERVER_LIMIT);
       fprintf(stderr, " HARD_SERVER_LIMIT define in src/include/httpd.h.\n");
       ap_daemons_limit = HARD_SERVER_LIMIT;
    }
    else if (ap_daemons_limit < 1) {
	fprintf(stderr, "WARNING: Require MaxClients > 0, setting to 1\n");
	ap_daemons_limit = 1;
    }
    return NULL;
}

static const char *set_max_requests(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_max_requests_per_child = atoi(arg);
    return NULL;
}

static const char *set_threads(cmd_parms *cmd, void *dummy, char *arg) {
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_threads_per_child = atoi(arg);
    if (ap_threads_per_child > HARD_SERVER_LIMIT) {
        fprintf(stderr, "WARNING: ThreadsPerChild of %d exceeds compile time limit "
                "of %d threads,\n", ap_threads_per_child, HARD_SERVER_LIMIT);
        fprintf(stderr, " lowering ThreadsPerChild to %d.  To increase, please "
                "see the\n", HARD_SERVER_LIMIT);
        fprintf(stderr, " HARD_SERVER_LIMIT define in src/include/httpd.h.\n");
        ap_threads_per_child = HARD_SERVER_LIMIT;
    }
    else if (ap_threads_per_child < 1) {
	fprintf(stderr, "WARNING: Require ThreadsPerChild > 0, setting to 1\n");
	ap_threads_per_child = 1;
    }

    return NULL;
}

static const char *set_excess_requests(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_excess_requests_per_child = atoi(arg);
    return NULL;
}


#if defined(RLIMIT_CPU) || defined(RLIMIT_TIME) || defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_NPROC) || defined(RLIMIT_AS)
static void set_rlimit(cmd_parms *cmd, struct rlimit **plimit, const char *arg,
                       const char * arg2, int type)
{
    char *str;
    struct rlimit *limit;
    /* If your platform doesn't define rlim_t then typedef it in ap_config.h */
    rlim_t cur = 0;
    rlim_t max = 0;

    *plimit = (struct rlimit *)ap_pcalloc(cmd->pool, sizeof(**plimit));
    limit = *plimit;
    if ((getrlimit(type, limit)) != 0)	{
	*plimit = NULL;
	ap_log_error(APLOG_MARK, APLOG_ERR, cmd->server,
		     "%s: getrlimit failed", cmd->cmd->name);
	return;
    }

    if ((str = ap_getword_conf(cmd->pool, &arg))) {
	if (!strcasecmp(str, "max")) {
	    cur = limit->rlim_max;
	}
	else {
	    cur = atol(str);
	}
    }
    else {
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, cmd->server,
		     "Invalid parameters for %s", cmd->cmd->name);
	return;
    }

    if (arg2 && (str = ap_getword_conf(cmd->pool, &arg2))) {
	max = atol(str);
    }

    /* if we aren't running as root, cannot increase max */
    if (geteuid()) {
	limit->rlim_cur = cur;
	if (max) {
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, cmd->server,
			 "Must be uid 0 to raise maximum %s", cmd->cmd->name);
	}
    }
    else {
        if (cur) {
	    limit->rlim_cur = cur;
	}
        if (max) {
	    limit->rlim_max = max;
	}
    }
}
#endif

#if !defined (RLIMIT_CPU) || !defined (RLIMIT_TIME) || !( defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS) ) || !defined (RLIMIT_NPROC)
static const char *no_set_limit(cmd_parms *cmd, core_dir_config *conf,
				char *arg, char *arg2)
{
    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, cmd->server,
		"%s not supported on this platform", cmd->cmd->name);
    return NULL;
}
#endif

#ifdef RLIMIT_CPU
static const char *set_limit_cpu(cmd_parms *cmd, core_dir_config *conf,
				 char *arg, char *arg2)
{
    set_rlimit(cmd, &conf->limit_cpu, arg, arg2, RLIMIT_CPU);
    return NULL;
}
#endif

#ifdef RLIMIT_TIME
static const char *set_limit_time(cmd_parms *cmd, core_dir_config *conf,
				 char *arg, char *arg2)
{
    set_rlimit(cmd, &conf->limit_time, arg, arg2, RLIMIT_TIME);
    return NULL;
}
#endif

#if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)
static const char *set_limit_mem(cmd_parms *cmd, core_dir_config *conf,
				 char *arg, char * arg2)
{
#if defined(RLIMIT_AS)
    set_rlimit(cmd, &conf->limit_mem, arg, arg2 ,RLIMIT_AS);
#elif defined(RLIMIT_DATA)
    set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_DATA);
#elif defined(RLIMIT_VMEM)
    set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_VMEM);
#endif
    return NULL;
}
#endif

#ifdef RLIMIT_NPROC
static const char *set_limit_nproc(cmd_parms *cmd, core_dir_config *conf,
				   char *arg, char * arg2)
{
    set_rlimit(cmd, &conf->limit_nproc, arg, arg2, RLIMIT_NPROC);
    return NULL;
}
#endif

static const char *set_bind_address(cmd_parms *cmd, void *dummy, char *arg)
{
    struct sockaddr *sa;
    size_t sa_len;
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    if (strcmp(arg, "*") == 0)
      arg = NULL;

    sa = ap_get_virthost_addr(arg, NULL);
#ifdef HAVE_SOCKADDR_LEN
    sa_len = sa->sa_len;
#else
    sa_len = SA_LEN(sa);
#endif
    memcpy(&ap_bind_address, &sa, sa_len);
    return NULL;
}

/* Though the AcceptFilter functionality is not available across
 * all platforms - we still allow the config directive to appear
 * on all platforms and do intentionally not tie it to the compile
 * time flag SO_ACCEPTFILTER. This makes configuration files significantly
 * more portable; especially as an <IfModule http_core.c> or some
 * other construct is not possible.
 */
static const char *set_acceptfilter(cmd_parms *cmd, void *dummy, int flag)
{
#ifdef SO_ACCEPTFILTER
    ap_acceptfilter = flag;
#endif
    return NULL;
}

static const char *set_listener(cmd_parms *cmd, void *dummy, char *h, char *p)
{
    listen_rec *new;
    char *host, *port;
    struct addrinfo hints, *res;
    int error;

    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    host = port = NULL;
    if (!p) {
	port = strrchr(h, ':');
	if (port != NULL) {
	    if (port == h) {
		return "Missing IP address";
	    }
	    else if (port[1] == '\0') {
		return "Address must end in :<port-number>";
	    }
	    *(port++) = '\0';
	    if (*h)
		host = h;
	} else {
	    host = NULL;
	    port = h;
	}
    } else {
	host = h;
	port = p;
    }

    if (host && strcmp(host, "*") == 0)
	host = NULL;

    new = ap_pcalloc(cmd->pool, sizeof(listen_rec));

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = host ? PF_UNSPEC : ap_default_family;
    hints.ai_flags = AI_PASSIVE;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, port, &hints, &res);
    if (error || !res) {
	fprintf(stderr, "could not resolve ");
	if (host)
	    fprintf(stderr, "host \"%s\" ", host);
	if (port)
	    fprintf(stderr, "port \"%s\" ", port);
	fprintf(stderr, "--- %s\n", gai_strerror(error));
	exit(1);
    }
    if (res->ai_next) {
        if (host)
	    fprintf(stderr, "host \"%s\" ", host);
	if (port)
	    fprintf(stderr, "port \"%s\" ", port);
	fprintf(stderr, "resolved to multiple addresses, ambiguous.\n");
	exit(1);
    }

    memcpy(&new->local_addr, res->ai_addr, res->ai_addrlen);

    new->fd = -1;
    new->used = 0;
    new->next = ap_listeners;
    ap_listeners = new;
    return NULL;
}

static const char *set_listenbacklog(cmd_parms *cmd, void *dummy, char *arg)
{
    int b;

    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    b = atoi(arg);
    if (b < 1) {
        return "ListenBacklog must be > 0";
    }
    ap_listenbacklog = b;
    return NULL;
}

static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, char *arg)
{
    struct stat finfo;
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    arg = ap_server_root_relative(cmd->pool, arg);
    if ((stat(arg, &finfo) == -1) || !S_ISDIR(finfo.st_mode)) {
	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", arg,
			  " does not exist or is not a directory", NULL);
    }
    ap_cpystrn(ap_coredump_dir, arg, sizeof(ap_coredump_dir));
    return NULL;
}

static const char *include_config (cmd_parms *cmd, void *dummy, char *name)
{
    name = ap_server_root_relative(cmd->pool, name);

    ap_process_resource_config(cmd->server, name, cmd->pool, cmd->temp_pool);

    return NULL;
}

static const char *set_loglevel(cmd_parms *cmd, void *dummy, const char *arg)
{
    char *str;

    const char *err = ap_check_cmd_context(cmd,
					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    if ((str = ap_getword_conf(cmd->pool, &arg))) {
        if (!strcasecmp(str, "emerg")) {
	    cmd->server->loglevel = APLOG_EMERG;
	}
	else if (!strcasecmp(str, "alert")) {
	    cmd->server->loglevel = APLOG_ALERT;
	}
	else if (!strcasecmp(str, "crit")) {
	    cmd->server->loglevel = APLOG_CRIT;
	}
	else if (!strcasecmp(str, "error")) {
	    cmd->server->loglevel = APLOG_ERR;
	}
	else if (!strcasecmp(str, "warn")) {
	    cmd->server->loglevel = APLOG_WARNING;
	}
	else if (!strcasecmp(str, "notice")) {
	    cmd->server->loglevel = APLOG_NOTICE;
	}
	else if (!strcasecmp(str, "info")) {
	    cmd->server->loglevel = APLOG_INFO;
	}
	else if (!strcasecmp(str, "debug")) {
	    cmd->server->loglevel = APLOG_DEBUG;
	}
	else {
            return "LogLevel requires level keyword: one of "
	           "emerg/alert/crit/error/warn/notice/info/debug";
	}
    }
    else {
        return "LogLevel requires level keyword";
    }

    return NULL;
}

API_EXPORT(const char *) ap_psignature(const char *prefix, request_rec *r)
{
    char sport[20];
    core_dir_config *conf;

    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						   &core_module);
    if ((conf->server_signature == srv_sig_off)
	    || (conf->server_signature == srv_sig_unset)) {
	return "";
    }

    ap_snprintf(sport, sizeof sport, "%u", (unsigned) ap_get_server_port(r));

    if (conf->server_signature == srv_sig_withmail) {
	return ap_pstrcat(r->pool, prefix, "<address>" SERVER_BASEVERSION
			  " Server at <a href=\"mailto:",
			  r->server->server_admin, "\">",
			  ap_escape_html(r->pool, ap_get_server_name(r)),
                          "</a> Port ", sport,
			  "</address>\n", NULL);
    }
    return ap_pstrcat(r->pool, prefix, "<address>" SERVER_BASEVERSION
		      " Server at ",
                      ap_escape_html(r->pool, ap_get_server_name(r)),
                      " Port ", sport,
		      "</address>\n", NULL);
}

/*
 * Load an authorisation realm into our location configuration, applying the
 * usual rules that apply to realms.
 */
static const char *set_authname(cmd_parms *cmd, void *mconfig, char *word1)
{
    core_dir_config *aconfig = (core_dir_config *)mconfig;

    aconfig->ap_auth_name = ap_escape_quotes(cmd->pool, word1);
    return NULL;
}

/*
 * Load an authorisation nonce into our location configuration, and
 * force it to be in the 0-9/A-Z realm.
 */
static const char *set_authnonce (cmd_parms *cmd, void *mconfig, char *word1)
{
    core_dir_config *aconfig = (core_dir_config *)mconfig;
    size_t i;

    aconfig->ap_auth_nonce = ap_escape_quotes(cmd->pool, word1);

    if (strlen(aconfig->ap_auth_nonce) > 510)
       return "AuthDigestRealmSeed length limited to 510 chars for browser compatibility";

    for(i=0;i<strlen(aconfig->ap_auth_nonce );i++)
       if (!ap_isalnum(aconfig->ap_auth_nonce [i]))
         return "AuthDigestRealmSeed limited to 0-9 and A-Z range for browser compatibility";

    return NULL;
}


static const char *set_protocol_req_check(cmd_parms *cmd,
                                              core_dir_config *d, int arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_protocol_req_check = arg != 0;
    return NULL;
}

static const char *set_change_shmem_uid(cmd_parms *cmd,
                                              core_dir_config *d, int arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_change_shmem_uid = arg != 0;
    return NULL;
}

/*
 * Handle a request to include the server's OS platform in the Server
 * response header field (the ServerTokens directive).  Unfortunately
 * this requires a new global in order to communicate the setting back to
 * http_main so it can insert the information in the right place in the
 * string.
 */
static const char *set_serv_tokens(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    if (!strcasecmp(arg, "OS")) {
        ap_server_tokens = SrvTk_OS;
    }
    else if (!strcasecmp(arg, "Min") || !strcasecmp(arg, "Minimal")) {
        ap_server_tokens = SrvTk_MIN;
    }
    else if (!strcasecmp(arg, "Full")) {
        ap_server_tokens = SrvTk_FULL;
    }
    else if (!strcasecmp(arg, "Prod") || !strcasecmp(arg, "ProductOnly")) {
        ap_server_tokens = SrvTk_PRODUCT_ONLY;
    }
    else {
	return ap_pstrcat(cmd->pool, "Unrecognised ServerTokens keyword: ",
			  arg, NULL);
    }
    return NULL;
}

static const char *set_limit_req_line(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd,
                                           NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    int lim;

    if (err != NULL) {
        return err;
    }
    lim = atoi(arg);
    if (lim < 0) {
        return ap_pstrcat(cmd->temp_pool, "LimitRequestLine \"", arg,
                          "\" must be a non-negative integer", NULL);
    }
    if (lim > DEFAULT_LIMIT_REQUEST_LINE) {
        return ap_psprintf(cmd->temp_pool, "LimitRequestLine \"%s\" "
                           "must not exceed the precompiled maximum of %d",
                           arg, DEFAULT_LIMIT_REQUEST_LINE);
    }
    cmd->server->limit_req_line = lim;
    return NULL;
}

static const char *set_limit_req_fieldsize(cmd_parms *cmd, void *dummy,
                                           char *arg)
{
    const char *err = ap_check_cmd_context(cmd,
                                           NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    int lim;

    if (err != NULL) {
        return err;
    }
    lim = atoi(arg);
    if (lim < 0) {
        return ap_pstrcat(cmd->temp_pool, "LimitRequestFieldsize \"", arg,
                          "\" must be a non-negative integer (0 = no limit)",
                          NULL);
    }
    if (lim > DEFAULT_LIMIT_REQUEST_FIELDSIZE) {
        return ap_psprintf(cmd->temp_pool, "LimitRequestFieldsize \"%s\" "
                          "must not exceed the precompiled maximum of %d",
                           arg, DEFAULT_LIMIT_REQUEST_FIELDSIZE);
    }
    cmd->server->limit_req_fieldsize = lim;
    return NULL;
}

static const char *set_limit_req_fields(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd,
                                           NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    int lim;

    if (err != NULL) {
        return err;
    }
    lim = atoi(arg);
    if (lim < 0) {
        return ap_pstrcat(cmd->temp_pool, "LimitRequestFields \"", arg,
                          "\" must be a non-negative integer (0 = no limit)",
                          NULL);
    }
    cmd->server->limit_req_fields = lim;
    return NULL;
}

static const char *set_limit_req_body(cmd_parms *cmd, core_dir_config *conf,
                                      char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
    if (err != NULL) {
        return err;
    }

    /* WTF: If strtoul is not portable, then write a replacement.
     *      Instead we have an idiotic define in httpd.h that prevents
     *      it from being used even when it is available. Sheesh.
     */
    conf->limit_req_body = (unsigned long)ap_strtol(arg, (char **)NULL, 10);
    return NULL;
}

static const char *set_cgi_command_args(cmd_parms *cmd,
                                              void *mconfig,
                                              int arg)
{
    core_dir_config *cfg = (core_dir_config *)mconfig;
    cfg->cgi_command_args = arg ? AP_FLAG_ON : AP_FLAG_OFF;
    return NULL;
}

/*
 * Note what data should be used when forming file ETag values.
 * It would be nicer to do this as an ITERATE, but then we couldn't
 * remember the +/- state properly.
 */
static const char *set_etag_bits(cmd_parms *cmd, void *mconfig,
                                 const char *args_p)
{
    core_dir_config *cfg;
    etag_components_t bit;
    char action;
    char *token;
    const char *args;
    int valid;
    int first;
    int explicit;

    cfg = (core_dir_config *) mconfig;

    args = args_p;
    first = 1;
    explicit = 0;
    while (args[0] != '\0') {
        action = '*';
        bit = ETAG_UNSET;
        valid = 1;
        token = ap_getword_conf(cmd->pool, &args);
        if ((*token == '+') || (*token == '-')) {
            action = *token;
            token++;
        }
        else {
            /*
             * The occurrence of an absolute setting wipes
             * out any previous relative ones.  The first such
             * occurrence forgets any inherited ones, too.
             */
            if (first) {
                cfg->etag_bits = ETAG_UNSET;
                cfg->etag_add = ETAG_UNSET;
                cfg->etag_remove = ETAG_UNSET;
                first = 0;
            }
        }

        if (strcasecmp(token, "None") == 0) {
            if (action != '*') {
                valid = 0;
            }
            else {
                cfg->etag_bits = bit = ETAG_NONE;
                explicit = 1;
            }
        }
        else if (strcasecmp(token, "All") == 0) {
            if (action != '*') {
                valid = 0;
            }
            else {
                explicit = 1;
                cfg->etag_bits = bit = ETAG_ALL;
            }
        }
        else if (strcasecmp(token, "Size") == 0) {
            bit = ETAG_SIZE;
        }
        else if ((strcasecmp(token, "LMTime") == 0)
                 || (strcasecmp(token, "MTime") == 0)
                 || (strcasecmp(token, "LastModified") == 0)) {
            bit = ETAG_MTIME;
        }
        else if (strcasecmp(token, "INode") == 0) {
            bit = ETAG_INODE;
        }
        else {
            return ap_pstrcat(cmd->pool, "Unknown keyword '",
                              token, "' for ", cmd->cmd->name,
                              " directive", NULL);
        }

        if (! valid) {
            return ap_pstrcat(cmd->pool, cmd->cmd->name, " keyword '",
                              token, "' cannot be used with '+' or '-'",
                              NULL);
        }

        if (action == '+') {
            /*
             * Make sure it's in the 'add' list and absent from the
             * 'subtract' list.
             */
            cfg->etag_add |= bit;
            cfg->etag_remove &= (~ bit);
        }
        else if (action == '-') {
            cfg->etag_remove |= bit;
            cfg->etag_add &= (~ bit);
        }
        else {
            /*
             * Non-relative values wipe out any + or - values
             * accumulated so far.
             */
            cfg->etag_bits |= bit;
            cfg->etag_add = ETAG_UNSET;
            cfg->etag_remove = ETAG_UNSET;
            explicit = 1;
        }
    }

    /*
     * Any setting at all will clear the 'None' and 'Unset' bits.
     */

    if (cfg->etag_add != ETAG_UNSET) {
        cfg->etag_add &= (~ ETAG_UNSET);
    }
    if (cfg->etag_remove != ETAG_UNSET) {
        cfg->etag_remove &= (~ ETAG_UNSET);
    }
    if (explicit) {
        cfg->etag_bits &= (~ ETAG_UNSET);
        if ((cfg->etag_bits & ETAG_NONE) != ETAG_NONE) {
            cfg->etag_bits &= (~ ETAG_NONE);
        }
    }
    return NULL;
}

static const char *set_recursion_limit(cmd_parms *cmd, void *dummy,
                                       const char *arg1, const char *arg2)
{
    core_server_config *conf = ap_get_module_config(cmd->server->module_config,
                                                    &core_module);
    int limit = atoi(arg1);

    if (limit < 0) {
        return "The redirect recursion limit cannot be less than zero.";
    }
    if (limit && limit < 4) {
        ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
                     "Limiting internal redirects to very low numbers may "
                     "cause normal requests to fail.");
    }

    conf->redirect_limit = limit;

    if (arg2) {
        limit = atoi(arg2);

        if (limit < 0) {
            return "The subrequest recursion limit cannot be less than zero.";
        }
        if (limit && limit < 4) {
            ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
                         "Limiting the subrequest depth to a very low level may"
                         " cause normal requests to fail.");
        }
    }

    conf->subreq_limit = limit;
    conf->recursion_limit_set = 1;

    return NULL;
}

static void log_backtrace(const request_rec *r)
{
    const request_rec *top = r;

    ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                  "r->uri = %s", r->uri ? r->uri : "(unexpectedly NULL)");

    while (top && (top->prev || top->main)) {
        if (top->prev) {
            top = top->prev;
            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                          "redirected from r->uri = %s",
                          top->uri ? top->uri : "(unexpectedly NULL)");
        }

        if (!top->prev && top->main) {
            top = top->main;
            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                          "subrequested from r->uri = %s",
                          top->uri ? top->uri : "(unexpectedly NULL)");
        }
    }
}

/*
 * check whether redirect limit is reached
 */
API_EXPORT(int) ap_is_recursion_limit_exceeded(const request_rec *r)
{
    core_server_config *conf = ap_get_module_config(r->server->module_config,
                                                    &core_module);
    const request_rec *top = r;
    int redirects = 0, subreqs = 0;
    int rlimit = conf->recursion_limit_set
                 ? conf->redirect_limit
                 : AP_DEFAULT_MAX_INTERNAL_REDIRECTS;
    int slimit = conf->recursion_limit_set
                 ? conf->subreq_limit
                 : AP_DEFAULT_MAX_SUBREQ_DEPTH;

    /* fast exit (unlimited) */
    if (!rlimit && !slimit) {
        return 0;
    }

    while (top->prev || top->main) {
        if (top->prev) {
            if (rlimit && ++redirects >= rlimit) {
                /* uuh, too much. */
                ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
                              "Request exceeded the limit of %d internal "
                              "redirects due to probable configuration error. "
                              "Use 'LimitInternalRecursion' to increase the "
                              "limit if necessary. Use 'LogLevel debug' to get "
                              "a backtrace.", rlimit);

                /* post backtrace */
                log_backtrace(r);

                /* return failure */
                return 1;
            }

            top = top->prev;
        }

        if (!top->prev && top->main) {
            if (slimit && ++subreqs >= slimit) {
                /* uuh, too much. */
                ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
                              "Request exceeded the limit of %d subrequest "
                              "nesting levels due to probable confguration "
                              "error. Use 'LimitInternalRecursion' to increase "
                              "the limit if necessary. Use 'LogLevel debug' to "
                              "get a backtrace.", slimit);

                /* post backtrace */
                log_backtrace(r);

                /* return failure */
                return 1;
            }

            top = top->main;
        }
    }

    /* recursion state: ok */
    return 0;
}

/* Note --- ErrorDocument will now work from .htaccess files.
 * The AllowOverride of Fileinfo allows webmasters to turn it off
 */

static const command_rec core_cmds[] = {

/* Old access config file commands */

{ "<Directory", dirsection, NULL, RSRC_CONF, RAW_ARGS,
  "Container for directives affecting resources located in the specified "
  "directories" },
{ end_directory_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
  "Marks end of <Directory>" },
{ "<Location", urlsection, NULL, RSRC_CONF, RAW_ARGS,
  "Container for directives affecting resources accessed through the "
  "specified URL paths" },
{ end_location_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
  "Marks end of <Location>" },
{ "<VirtualHost", virtualhost_section, NULL, RSRC_CONF, RAW_ARGS,
  "Container to map directives to a particular virtual host, takes one or "
  "more host addresses" },
{ end_virtualhost_section, end_nested_section, NULL, RSRC_CONF, NO_ARGS,
  "Marks end of <VirtualHost>" },
{ "<Files", filesection, NULL, OR_ALL, RAW_ARGS, "Container for directives "
  "affecting files matching specified patterns" },
{ end_files_section, end_nested_section, NULL, OR_ALL, NO_ARGS,
  "Marks end of <Files>" },
{ "<Limit", ap_limit_section, NULL, OR_ALL, RAW_ARGS, "Container for "
  "authentication directives when accessed using specified HTTP methods" },
{ "</Limit>", endlimit_section, NULL, OR_ALL, NO_ARGS,
  "Marks end of <Limit>" },
{ "<LimitExcept", ap_limit_section, (void*)1, OR_ALL, RAW_ARGS,
  "Container for authentication directives to be applied when any HTTP "
  "method other than those specified is used to access the resource" },
{ "</LimitExcept>", endlimit_section, (void*)1, OR_ALL, NO_ARGS,
  "Marks end of <LimitExcept>" },
{ "<IfModule", start_ifmod, NULL, OR_ALL, TAKE1,
  "Container for directives based on existance of specified modules" },
{ end_ifmodule_section, end_ifmod, NULL, OR_ALL, NO_ARGS,
  "Marks end of <IfModule>" },
{ "<IfDefine", start_ifdefine, NULL, OR_ALL, TAKE1,
  "Container for directives based on existance of command line defines" },
{ end_ifdefine_section, end_ifdefine, NULL, OR_ALL, NO_ARGS,
  "Marks end of <IfDefine>" },
{ "<DirectoryMatch", dirsection, (void*)1, RSRC_CONF, RAW_ARGS,
  "Container for directives affecting resources located in the "
  "specified directories" },
{ end_directorymatch_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
  "Marks end of <DirectoryMatch>" },
{ "<LocationMatch", urlsection, (void*)1, RSRC_CONF, RAW_ARGS,
  "Container for directives affecting resources accessed through the "
  "specified URL paths" },
{ end_locationmatch_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
  "Marks end of <LocationMatch>" },
{ "<FilesMatch", filesection, (void*)1, OR_ALL, RAW_ARGS,
  "Container for directives affecting files matching specified patterns" },
{ end_filesmatch_section, end_nested_section, NULL, OR_ALL, NO_ARGS,
  "Marks end of <FilesMatch>" },
{ "AuthType", ap_set_string_slot,
  (void*)XtOffsetOf(core_dir_config, ap_auth_type), OR_AUTHCFG, TAKE1,
  "An HTTP authorization type (e.g., \"Basic\")" },
{ "AuthName", set_authname, NULL, OR_AUTHCFG, TAKE1,
  "The authentication realm (e.g. \"Members Only\")" },
{ "AuthDigestRealmSeed", set_authnonce, NULL, OR_AUTHCFG, TAKE1,
  "An authentication token which should be different for each logical realm. "\
  "A random value or the servers IP may be a good choise.\n" },
{ "Require", require, NULL, OR_AUTHCFG, RAW_ARGS,
  "Selects which authenticated users or groups may access a protected space" },
{ "Satisfy", satisfy, NULL, OR_AUTHCFG, TAKE1,
  "access policy if both allow and require used ('all' or 'any')" },
#ifdef GPROF
{ "GprofDir", set_gprof_dir, NULL, RSRC_CONF, TAKE1,
  "Directory to plop gmon.out files" },
#endif
{ "AddDefaultCharset", set_add_default_charset, NULL, OR_FILEINFO,
  TAKE1, "The name of the default charset to add to any Content-Type without one or 'Off' to disable" },

/* Old resource config file commands */

{ "AccessFileName", set_access_name, NULL, RSRC_CONF, RAW_ARGS,
  "Name(s) of per-directory config files (default: .htaccess)" },
{ "DocumentRoot", set_document_root, NULL, RSRC_CONF, TAKE1,
  "Root directory of the document tree"  },
{ "ErrorDocument", set_error_document, NULL, OR_FILEINFO, RAW_ARGS,
  "Change responses for HTTP errors" },
{ "AllowOverride", set_override, NULL, ACCESS_CONF, RAW_ARGS,
  "Controls what groups of directives can be configured by per-directory "
  "config files" },
{ "Options", set_options, NULL, OR_OPTIONS, RAW_ARGS,
  "Set a number of attributes for a given directory" },
{ "DefaultType", ap_set_string_slot,
  (void*)XtOffsetOf (core_dir_config, ap_default_type),
  OR_FILEINFO, TAKE1, "the default MIME type for untypable files" },

/* Old server config file commands */

{ "ServerType", server_type, NULL, RSRC_CONF, TAKE1,
  "'inetd' or 'standalone'"},
{ "Port", server_port, NULL, RSRC_CONF, TAKE1, "A TCP port number"},
{ "HostnameLookups", set_hostname_lookups, NULL, ACCESS_CONF|RSRC_CONF, TAKE1,
  "\"on\" to enable, \"off\" to disable reverse DNS lookups, or \"double\" to "
  "enable double-reverse DNS lookups" },
{ "User", set_user, NULL, RSRC_CONF, TAKE1,
  "Effective user id for this server"},
{ "Group", set_group, NULL, RSRC_CONF, TAKE1,
  "Effective group id for this server"},
{ "ServerAdmin", set_server_string_slot,
  (void *)XtOffsetOf (server_rec, server_admin), RSRC_CONF, TAKE1,
  "The email address of the server administrator" },
{ "ServerName", set_server_string_slot,
  (void *)XtOffsetOf (server_rec, server_hostname), RSRC_CONF, TAKE1,
  "The hostname of the server" },
{ "ServerSignature", set_signature_flag, NULL, OR_ALL, TAKE1,
  "En-/disable server signature (on|off|email)" },
{ "ServerRoot", set_server_root, NULL, RSRC_CONF, TAKE1,
  "Common directory of server-related files (logs, confs, etc.)" },
{ "ErrorLog", set_server_string_slot,
  (void *)XtOffsetOf (server_rec, error_fname), RSRC_CONF, TAKE1,
  "The filename of the error log" },
{ "PidFile", set_pidfile, NULL, RSRC_CONF, TAKE1,
    "A file for logging the server process ID"},
{ "ScoreBoardFile", set_scoreboard, NULL, RSRC_CONF, TAKE1,
    "A file for Apache to maintain runtime process management information"},
{ "LockFile", set_lockfile, NULL, RSRC_CONF, TAKE1,
    "The lockfile used when Apache needs to lock the accept() call"},
{ "AccessConfig", set_server_string_slot,
  (void *)XtOffsetOf (server_rec, access_confname), RSRC_CONF, TAKE1,
  "The filename of the access config file" },
{ "ResourceConfig", set_server_string_slot,
  (void *)XtOffsetOf (server_rec, srm_confname), RSRC_CONF, TAKE1,
  "The filename of the resource config file" },
{ "ServerAlias", set_server_alias, NULL, RSRC_CONF, RAW_ARGS,
  "A name or names alternately used to access the server" },
{ "ServerPath", set_serverpath, NULL, RSRC_CONF, TAKE1,
  "The pathname the server can be reached at" },
{ "Timeout", set_timeout, NULL, RSRC_CONF, TAKE1, "Timeout duration (sec)" },
{ "KeepAliveTimeout", set_keep_alive_timeout, NULL, RSRC_CONF, TAKE1,
  "Keep-Alive timeout duration (sec)"},
{ "MaxKeepAliveRequests", set_keep_alive_max, NULL, RSRC_CONF, TAKE1,
  "Maximum number of Keep-Alive requests per connection, or 0 for infinite" },
{ "KeepAlive", set_keep_alive, NULL, RSRC_CONF, TAKE1,
  "Whether persistent connections should be On or Off" },
{ "IdentityCheck", set_idcheck, NULL, RSRC_CONF|ACCESS_CONF, FLAG,
  "Enable identd (RFC 1413) user lookups - SLOW" },
{ "ContentDigest", set_content_md5, NULL, OR_OPTIONS,
  FLAG, "whether or not to send a Content-MD5 header with each request" },
{ "UseCanonicalName", set_use_canonical_name, NULL,
  RSRC_CONF|ACCESS_CONF, TAKE1,
  "How to work out the ServerName : Port when constructing URLs" },
{ "StartServers", set_daemons_to_start, NULL, RSRC_CONF, TAKE1,
  "Number of child processes launched at server startup" },
{ "MinSpareServers", set_min_free_servers, NULL, RSRC_CONF, TAKE1,
  "Minimum number of idle children, to handle request spikes" },
{ "MaxSpareServers", set_max_free_servers, NULL, RSRC_CONF, TAKE1,
  "Maximum number of idle children" },
{ "MaxServers", set_max_free_servers, NULL, RSRC_CONF, TAKE1,
  "Deprecated equivalent to MaxSpareServers" },
{ "ServersSafetyLimit", set_server_limit, NULL, RSRC_CONF, TAKE1,
  "Deprecated equivalent to MaxClients" },
{ "MaxClients", set_server_limit, NULL, RSRC_CONF, TAKE1,
  "Maximum number of children alive at the same time" },
{ "MaxRequestsPerChild", set_max_requests, NULL, RSRC_CONF, TAKE1,
  "Maximum number of requests a particular child serves before dying." },
{ "RLimitCPU",
#ifdef RLIMIT_CPU
  set_limit_cpu, (void*)XtOffsetOf(core_dir_config, limit_cpu),
#else
  no_set_limit, NULL,
#endif
  OR_ALL, TAKE12, "Soft/hard limits for max CPU usage in seconds" },
{ "RLimitTime",
#ifdef RLIMIT_TIME
  set_limit_time, (void*)XtOffsetOf(core_dir_config, limit_time),
#else
  no_set_limit, NULL,
#endif
  OR_ALL, TAKE12, "Soft/hard limits for max human time in seconds" },
{ "RLimitMEM",
#if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined (RLIMIT_AS)
  set_limit_mem, (void*)XtOffsetOf(core_dir_config, limit_mem),
#else
  no_set_limit, NULL,
#endif
  OR_ALL, TAKE12, "Soft/hard limits for max memory usage per process" },
{ "RLimitNPROC",
#ifdef RLIMIT_NPROC
  set_limit_nproc, (void*)XtOffsetOf(core_dir_config, limit_nproc),
#else
  no_set_limit, NULL,
#endif
   OR_ALL, TAKE12, "soft/hard limits for max number of processes per uid" },
{ "BindAddress", set_bind_address, NULL, RSRC_CONF, TAKE1,
  "'*', a numeric IP address, or the name of a host with a unique IP address"},
{ "Listen", set_listener, NULL, RSRC_CONF, TAKE12,
  "A port number or a numeric IP address and a port number"},
{ "SendBufferSize", set_send_buffer_size, NULL, RSRC_CONF, TAKE1,
  "Send buffer size in bytes"},
{ "AddModule", add_module_command, NULL, RSRC_CONF, ITERATE,
  "The name of a module" },
{ "ClearModuleList", clear_module_list_command, NULL, RSRC_CONF, NO_ARGS,
  NULL },
{ "ThreadsPerChild", set_threads, NULL, RSRC_CONF, TAKE1,
  "Number of threads a child creates" },
{ "ExcessRequestsPerChild", set_excess_requests, NULL, RSRC_CONF, TAKE1,
  "Maximum number of requests a particular child serves after it is ready "
  "to die." },
{ "ListenBacklog", set_listenbacklog, NULL, RSRC_CONF, TAKE1,
  "Maximum length of the queue of pending connections, as used by listen(2)" },
{ "AcceptFilter", set_acceptfilter, NULL, RSRC_CONF, FLAG,
  "Switch AcceptFiltering on/off (default is "
#ifdef AP_ACCEPTFILTER_OFF
	"off"
#else
	"on"
#endif
	")."
#ifndef SO_ACCEPTFILTER
	"This feature is currently not compiled in; so this directive "
	"is ignored."
#endif
   },
{ "CoreDumpDirectory", set_coredumpdir, NULL, RSRC_CONF, TAKE1,
  "The location of the directory Apache changes to before dumping core" },
{ "Include", include_config, NULL, (RSRC_CONF | ACCESS_CONF), TAKE1,
  "Name of the config file to be included" },
{ "LogLevel", set_loglevel, NULL, RSRC_CONF, TAKE1,
  "Level of verbosity in error logging" },
{ "NameVirtualHost", ap_set_name_virtual_host, NULL, RSRC_CONF, TAKE12,
  "A numeric IP address:port, or the name of a host" },
{ "CGICommandArgs", set_cgi_command_args, NULL, OR_OPTIONS, FLAG,
  "Allow or Disallow CGI requests to pass args on the command line" },
{ "ServerTokens", set_serv_tokens, NULL, RSRC_CONF, TAKE1,
  "Tokens displayed in the Server: header - Min[imal], OS, Prod[uctOnly], Full" },
{ "LimitRequestLine", set_limit_req_line, NULL, RSRC_CONF, TAKE1,
  "Limit on maximum size of an HTTP request line"},
{ "LimitRequestFieldsize", set_limit_req_fieldsize, NULL, RSRC_CONF, TAKE1,
  "Limit on maximum size of an HTTP request header field"},
{ "LimitRequestFields", set_limit_req_fields, NULL, RSRC_CONF, TAKE1,
  "Limit (0 = unlimited) on max number of header fields in a request message"},
{ "LimitRequestBody", set_limit_req_body,
  (void*)XtOffsetOf(core_dir_config, limit_req_body),
  OR_ALL, TAKE1,
  "Limit (in bytes) on maximum size of request message body" },
{ "ProtocolReqCheck", set_protocol_req_check, NULL, RSRC_CONF, FLAG,
  "Enable strict checking of Protocol type in requests" },
{ "ShmemUIDisUser", set_change_shmem_uid, NULL, RSRC_CONF, FLAG,
  "Enable the setting of SysV shared memory scoreboard uid/gid to User/Group" },
{ "AcceptMutex", set_accept_mutex, NULL, RSRC_CONF, TAKE1,
  "Serialized Accept Mutex; the methods "
#ifdef HAVE_USLOCK_SERIALIZED_ACCEPT
    "'uslock' "
#endif
#ifdef HAVE_PTHREAD_SERIALIZED_ACCEPT
    "'pthread' "
#endif
#ifdef HAVE_SYSVSEM_SERIALIZED_ACCEPT
    "'sysvsem' "
#endif
#ifdef HAVE_FCNTL_SERIALIZED_ACCEPT
    "'fcntl' "
#endif
#ifdef HAVE_FLOCK_SERIALIZED_ACCEPT
    "'flock' "
#endif
#ifdef HAVE_NONE_SERIALIZED_ACCEPT
    "'none' "
#endif
    "are compiled in"
},

{ "FileETag", set_etag_bits, NULL, OR_FILEINFO, RAW_ARGS,
  "Specify components used to construct a file's ETag"},

{ "LimitInternalRecursion", set_recursion_limit, NULL, RSRC_CONF, TAKE12,
  "maximum recursion depth of internal redirects and subrequests"},

{ NULL }
};

/*****************************************************************
 *
 * Core handlers for various phases of server operation...
 */

static int core_translate(request_rec *r)
{
    void *sconf = r->server->module_config;
    core_server_config *conf = ap_get_module_config(sconf, &core_module);

    if (r->proxyreq != NOT_PROXY) {
        return HTTP_FORBIDDEN;
    }
    if ((r->uri[0] != '/') && strcmp(r->uri, "*")) {
	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
		     "Invalid URI in request %s", r->the_request);
	return BAD_REQUEST;
    }

    if (r->server->path
	&& !strncmp(r->uri, r->server->path, r->server->pathlen)
	&& (r->server->path[r->server->pathlen - 1] == '/'
	    || r->uri[r->server->pathlen] == '/'
	    || r->uri[r->server->pathlen] == '\0')) {
        r->filename = ap_pstrcat(r->pool, conf->ap_document_root,
				 (r->uri + r->server->pathlen), NULL);
    }
    else {
	/*
         * Make sure that we do not mess up the translation by adding two
         * /'s in a row.  This happens under windows when the document
         * root ends with a /
         */
        if ((conf->ap_document_root[strlen(conf->ap_document_root)-1] == '/')
	    && (*(r->uri) == '/')) {
	    r->filename = ap_pstrcat(r->pool, conf->ap_document_root, r->uri+1,
				     NULL);
	}
	else {
	    r->filename = ap_pstrcat(r->pool, conf->ap_document_root, r->uri,
				     NULL);
	}
    }

    return OK;
}

static int do_nothing(request_rec *r) { return OK; }

#ifdef USE_MMAP_FILES
struct mmap_rec {
    void *mm;
    size_t length;
};

static void mmap_cleanup(void *mmv)
{
    struct mmap_rec *mmd = mmv;

    if (munmap(mmd->mm, mmd->length) == -1) {
        ap_log_error(APLOG_MARK, APLOG_ERR, NULL,
                     "Failed to munmap memory of length %ld at 0x%lx",
                     (long) mmd->length, (long) mmd->mm);
    }
}
#endif

/*
 * Default handler for MIME types without other handlers.  Only GET
 * and OPTIONS at this point... anyone who wants to write a generic
 * handler for PUT or POST is free to do so, but it seems unwise to provide
 * any defaults yet... So, for now, we assume that this will always be
 * the last handler called and return 405 or 501.
 */

static int default_handler(request_rec *r)
{
    core_dir_config *d =
      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
    int rangestatus, errstatus;
    FILE *f;
#ifdef USE_MMAP_FILES
    caddr_t mm;
#endif

    /* This handler has no use for a request body (yet), but we still
     * need to read and discard it if the client sent one.
     */
    if ((errstatus = ap_discard_request_body(r)) != OK) {
        return errstatus;
    }

    r->allowed |= (1 << M_GET) | (1 << M_OPTIONS);

    if (r->method_number == M_INVALID) {
	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
		    "Invalid method in request %s",
		    ap_escape_logitem(r->pool, r->the_request));
	return NOT_IMPLEMENTED;
    }
    if (r->method_number == M_OPTIONS) {
        return ap_send_http_options(r);
    }
    if (r->method_number == M_PUT) {
        return METHOD_NOT_ALLOWED;
    }

    if (r->finfo.st_mode == 0 || (r->path_info && *r->path_info)) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
		      "File does not exist: %s",r->path_info ?
		      ap_pstrcat(r->pool, r->filename, r->path_info, NULL)
		      : r->filename);
	return HTTP_NOT_FOUND;
    }
    if (r->method_number != M_GET) {
        return METHOD_NOT_ALLOWED;
    }

    f = ap_pfopen(r->pool, r->filename, "r");

    if (f == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "file permissions deny server access: %s", r->filename);
        return FORBIDDEN;
    }

    ap_update_mtime(r, r->finfo.st_mtime);
    ap_set_last_modified(r);
    ap_set_etag(r);
    ap_table_setn(r->headers_out, "Accept-Ranges", "bytes");
    if (((errstatus = ap_meets_conditions(r)) != OK)
	|| (errstatus = ap_set_content_length(r, r->finfo.st_size))) {
        return errstatus;
    }

#ifdef USE_MMAP_FILES
    ap_block_alarms();
    if ((r->finfo.st_size >= MMAP_THRESHOLD)
	&& (r->finfo.st_size < MMAP_LIMIT)
	&& (!r->header_only || (d->content_md5 & 1))) {
	/* we need to protect ourselves in case we die while we've got the
 	 * file mmapped */
	mm = mmap(NULL, r->finfo.st_size, PROT_READ, MAP_PRIVATE,
		  fileno(f), 0);
	if (mm == (caddr_t)-1) {
	    ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
			 "default_handler: mmap failed: %s", r->filename);
	}
    }
    else {
	mm = (caddr_t)-1;
    }

    if (mm == (caddr_t)-1) {
	ap_unblock_alarms();
#endif

	if (d->content_md5 & 1) {
	    ap_table_setn(r->headers_out, "Content-MD5",
			  ap_md5digest(r->pool, f));
	}

	rangestatus = ap_set_byterange(r);

	ap_send_http_header(r);

	if (!r->header_only) {
	    if (!rangestatus) {
		ap_send_fd(f, r);
	    }
	    else {
		long offset, length;
		while (ap_each_byterange(r, &offset, &length)) {
		    /*
		     * Non zero returns are more portable than checking
		     * for a return of -1.
		     */
		    if (fseek(f, offset, SEEK_SET)) {
			ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			      "Failed to fseek for byterange (%ld, %ld): %s",
			      offset, length, r->filename);
		    }
		    else {
			ap_send_fd_length(f, r, length);
		    }
		}
	    }
	}

#ifdef USE_MMAP_FILES
    }
    else {
	struct mmap_rec *mmd;

	mmd = ap_palloc(r->pool, sizeof(*mmd));
	mmd->mm = mm;
	mmd->length = r->finfo.st_size;
	ap_register_cleanup(r->pool, (void *)mmd, mmap_cleanup, mmap_cleanup);
	ap_unblock_alarms();

	if (d->content_md5 & 1) {
	    AP_MD5_CTX context;

	    ap_MD5Init(&context);
	    ap_MD5Update(&context, (void *)mm, (unsigned int)r->finfo.st_size);
	    ap_table_setn(r->headers_out, "Content-MD5",
			  ap_md5contextTo64(r->pool, &context));
	}

	rangestatus = ap_set_byterange(r);
	ap_send_http_header(r);

	if (!r->header_only) {
	    if (!rangestatus) {
		ap_send_mmap(mm, r, 0, r->finfo.st_size);
	    }
	    else {
		long offset, length;
		while (ap_each_byterange(r, &offset, &length)) {
		    ap_send_mmap(mm, r, offset, length);
		}
	    }
	}
    }
#endif

    ap_pfclose(r->pool, f);
    return OK;
}

static const handler_rec core_handlers[] = {
{ "*/*", default_handler },
{ "default-handler", default_handler },
{ NULL, NULL }
};

API_VAR_EXPORT module core_module = {
    STANDARD_MODULE_STUFF,
    NULL,			/* initializer */
    create_core_dir_config,	/* create per-directory config structure */
    merge_core_dir_configs,	/* merge per-directory config structures */
    create_core_server_config,	/* create per-server config structure */
    merge_core_server_configs,	/* merge per-server config structures */
    core_cmds,			/* command table */
    core_handlers,		/* handlers */
    core_translate,		/* translate_handler */
    NULL,			/* check_user_id */
    NULL,			/* check auth */
    do_nothing,			/* check access */
    do_nothing,			/* type_checker */
    NULL,			/* pre-run fixups */
    NULL,			/* logger */
    NULL,			/* header parser */
    NULL,			/* child_init */
    NULL,			/* child_exit */
    NULL			/* post_read_request */
};
@


1.12
log
@carefully merge changes into MirOS httpd
@
text
@d1 2
a2 2
/* $MirBSD: src/usr.sbin/httpd/src/main/http_core.c,v 1.11 2004/08/22 00:30:14 tg Stab $ */
/* $OpenBSD: http_core.c,v 1.18 2004/07/31 20:01:55 brad Exp $ */
d4 2
a5 1
/* Copyright 1999-2004 The Apache Software Foundation
d7 2
a8 3
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
d10 3
a12 1
 *     http://www.apache.org/licenses/LICENSE-2.0
d14 46
a59 5
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
a91 3
#ifdef SUNOS4
#define MMAP_THRESHOLD		(8*1024)
#else
a94 1
#endif
a98 9
typedef struct {
    /* Custom response strings registered via ap_custom_response(),
     * or NULL; check per-dir config if nothing found here
     */
    char **response_code_strings; /* from ap_custom_response(), not from
				   * ErrorDocument
				   */
} core_request_config;

d118 1
a118 1
	conf->d = dir;
d121 1
a121 1
	conf->d = ap_pstrdup(a, dir);
d124 1
a124 1
	conf->d = ap_pstrcat(a, dir, "/", NULL);
a155 3
#ifdef WIN32
    conf->script_interpreter_source = INTERPRETER_SOURCE_UNSET;
#endif
a161 11
#ifdef CHARSET_EBCDIC
    conf->ebcdicconversion_by_ext_in = ap_make_table(a, 4);
    conf->ebcdicconversion_by_ext_out = ap_make_table(a, 4);
    conf->ebcdicconversion_by_type_in = ap_make_table(a, 4);
    conf->ebcdicconversion_by_type_out = ap_make_table(a, 4);
    conf->x_ascii_magic_kludge = 0;
#if ADD_EBCDICCONVERT_DEBUG_HEADER
    conf->ebcdicconversion_debug_header = 0;
#endif
#endif /* CHARSET_EBCDIC */

d200 1
a200 1
			    | new->opts_remove;
d202 2
a203 2
	if ((base->opts & OPT_INCNOEXEC) && (new->opts & OPT_INCLUDES)) {
	    conf->opts = (conf->opts & ~OPT_INCNOEXEC) | OPT_INCLUDES;
d216 1
a216 1
	conf->override = new->override;
d219 1
a219 1
	conf->ap_default_type = new->ap_default_type;
d223 1
a223 1
	conf->ap_auth_type = new->ap_auth_type;
d226 1
a226 1
	conf->ap_auth_name = new->ap_auth_name;
d229 1
a229 1
	conf->ap_auth_nonce = new->ap_auth_nonce;
d232 1
a232 1
	conf->ap_requires = new->ap_requires;
d244 1
a244 1
		if (new->response_code_strings[i] != NULL) {
d246 1
a246 1
			= new->response_code_strings[i];
d255 1
a255 1
	conf->do_rfc1413 = new->do_rfc1413;
d258 1
a258 1
	conf->content_md5 = new->content_md5;
d266 1
a266 1
	conf->limit_cpu = new->limit_cpu;
d271 1
a271 1
	conf->limit_time = new->limit_time;
d276 1
a276 1
	conf->limit_mem = new->limit_mem;
d281 1
a281 1
	conf->limit_nproc = new->limit_nproc;
d286 1
a286 1
	conf->limit_req_body = new->limit_req_body;
d291 1
a291 1
	conf->satisfy = new->satisfy;
a293 5
#ifdef WIN32
    if (new->script_interpreter_source != INTERPRETER_SOURCE_UNSET) {
	conf->script_interpreter_source = new->script_interpreter_source;
    }
#endif
a305 15
#ifdef CHARSET_EBCDIC
    conf->ebcdicconversion_by_ext_in = ap_overlay_tables(a, new->ebcdicconversion_by_ext_in,
					       base->ebcdicconversion_by_ext_in);
    conf->ebcdicconversion_by_ext_out = ap_overlay_tables(a, new->ebcdicconversion_by_ext_out,
					       base->ebcdicconversion_by_ext_out);
    conf->ebcdicconversion_by_type_in = ap_overlay_tables(a, new->ebcdicconversion_by_type_in,
						base->ebcdicconversion_by_type_in);
    conf->ebcdicconversion_by_type_out = ap_overlay_tables(a, new->ebcdicconversion_by_type_out,
						base->ebcdicconversion_by_type_out);
    conf->x_ascii_magic_kludge = new->x_ascii_magic_kludge ? new->x_ascii_magic_kludge : base->x_ascii_magic_kludge;
#if ADD_EBCDICCONVERT_DEBUG_HEADER
    conf->ebcdicconversion_debug_header = new->ebcdicconversion_debug_header ? new->ebcdicconversion_debug_header : base->ebcdicconversion_debug_header;
#endif
#endif /* CHARSET_EBCDIC */

d310 6
a315 6
	conf->etag_add =
	    (conf->etag_add & (~ new->etag_remove)) | new->etag_add;
	conf->etag_remove =
	    (conf->opts_remove & (~ new->etag_add)) | new->etag_remove;
	conf->etag_bits =
	    (conf->etag_bits & (~ conf->etag_remove)) | conf->etag_add;
d318 3
a320 3
	conf->etag_bits = new->etag_bits;
	conf->etag_add = new->etag_add;
	conf->etag_remove = new->etag_remove;
d323 1
a323 1
	conf->etag_bits &= (~ ETAG_NONE);
d327 1
a327 1
	conf->cgi_command_args = new->cgi_command_args;
d365 1
a365 1
	conf->access_name = base->access_name;
d368 1
a368 1
	conf->ap_document_root = base->ap_document_root;
d374 2
a375 2
			   ? virt->redirect_limit
			   : base->redirect_limit;
d378 2
a379 2
			 ? virt->subreq_limit
			 : base->subreq_limit;
d433 2
a434 2
	    && strchr((entry_core)->d, ':') \
	    && *(strchr((entry_core)->d, ':') + 1) != '/'))
d562 1
a562 1
						   &core_module);
d575 6
a580 6
    return ap_psprintf(r->pool,"%pI%pp%pp%pp%pp",
	   (void *)&(((struct sockaddr_in *)&r->connection->local_addr)->sin_addr),
	   (void *)ap_user_name,
	   (void *)ap_listeners,
	   (void *)ap_server_argv0,
	   (void *)ap_pid_fname);
d590 2
a591 2
	       ? conf->ap_default_type
	       : DEFAULT_CONTENT_TYPE;
d629 1
a629 2
    core_request_config *reqconf;
    core_dir_config *dirconf;
d631 2
a632 15
    /* prefer per-request settings, which are created by calls to
     * ap_custom_response()
     */
    reqconf = (core_request_config *)ap_get_module_config(r->request_config,
							  &core_module);

    if (reqconf != NULL &&
	reqconf->response_code_strings != NULL &&
	reqconf->response_code_strings[error_index] != NULL) {
	return reqconf->response_code_strings[error_index];
    }

    /* check for string specified via ErrorDocument */
    dirconf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						      &core_module);
d634 1
a634 1
    if (dirconf->response_code_strings == NULL) {
d637 1
a637 2

    return dirconf->response_code_strings[error_index];
d668 1
a668 1
	conn->remote_host = ""; /* prevent another lookup */
d694 2
a695 2
	    hostbuf1, sizeof(hostbuf1), NULL, 0,
	    NI_NUMERICHOST))
d698 2
a699 2
	    hostbuf2, sizeof(hostbuf2), NULL, 0,
	    NI_NUMERICHOST))
d828 1
a828 1
	return r->hostname ? r->hostname : r->server->server_hostname;
d831 2
a832 2
	if (conn->local_host == NULL) {
	    int old_stat;
d864 1
a864 1
	|| d->use_canonical_name == USE_CANONICAL_NAME_DNS) {
d866 8
a873 10
	/* With UseCanonicalName Off Apache will form self-referential
	 * URLs using the hostname and port supplied by the client if
	 * any are supplied (otherwise it will use the canonical name).
	 */
	port = r->parsed_uri.port_str ? r->parsed_uri.port :
#ifdef UCN_OFF_HONOR_PHYSICAL_PORT
	  cport ? cport :
#endif
	    r->server->port ? r->server->port :
	      ap_default_port(r);
d875 3
a877 3
	port = r->server->port ? r->server->port :
	  cport ? cport :
	    ap_default_port(r);
a903 221
#ifdef WIN32
static char* get_interpreter_from_win32_registry(pool *p, const char* ext)
{
    char extension_path[] = "SOFTWARE\\Classes\\";
    char executable_path[] = "\\SHELL\\OPEN\\COMMAND";

    HKEY hkeyOpen;
    DWORD type;
    int size;
    int result;
    char *keyName;
    char *buffer;
    char *s;

    if (!ext)
	return NULL;
    /*
     * Future optimization:
     * When the registry is successfully searched, store the interpreter
     * string in a table to make subsequent look-ups faster
     */

    /* Open the key associated with the script extension */
    keyName = ap_pstrcat(p, extension_path, ext, NULL);

    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, keyName, 0, KEY_QUERY_VALUE,
			  &hkeyOpen);

    if (result != ERROR_SUCCESS)
	return NULL;

    /* Read to NULL buffer to find value size */
    size = 0;
    result = RegQueryValueEx(hkeyOpen, "", NULL, &type, NULL, &size);

    if (result == ERROR_SUCCESS) {
	buffer = ap_palloc(p, size);
	result = RegQueryValueEx(hkeyOpen, "", NULL, &type, buffer, &size);
    }

    RegCloseKey(hkeyOpen);

    if (result != ERROR_SUCCESS)
	return NULL;

    /* Open the key associated with the interpreter path */
    keyName = ap_pstrcat(p, extension_path, buffer, executable_path, NULL);

    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, keyName, 0, KEY_QUERY_VALUE,
			  &hkeyOpen);

    if (result != ERROR_SUCCESS)
	return NULL;

    /* Read to NULL buffer to find value size */
    size = 0;
    result = RegQueryValueEx(hkeyOpen, "", 0, &type, NULL, &size);

    if (result == ERROR_SUCCESS) {
	buffer = ap_palloc(p, size);
	result = RegQueryValueEx(hkeyOpen, "", 0, &type, buffer, &size);
    }

    RegCloseKey(hkeyOpen);

    if (result != ERROR_SUCCESS)
	return NULL;

    /*
     * The command entry may contain embedded %envvar% entries,
     * e.g. %winsysdir%\somecommand.exe %1
     *
     * Resolve them here
     */
    size = ExpandEnvironmentStrings(buffer, NULL, 0);
    if (size) {
	s = ap_palloc(p, size);
	if (ExpandEnvironmentStrings(buffer, s, size))
	    buffer = s;
    }

    /*
     * The canonical way shell command entries are entered in the Win32
     * registry is as follows:
     *   shell [options] "%1" [options] [%*]
     * where
     *   shell - full path name to interpreter or shell to run.
     *           E.g., c:\usr\local\ntreskit\perl\bin\perl.exe
     *   options - optional switches
     *              E.g., /C or -w
     *   "%1" - Place holder for file to run the shell against.
     *          Quoted for if long path names are accepted.
     *          Not quoted if only short paths are acceptd
     *
     *   %* - additional arguments
     *
     * Effective in v. 1.3.15, the responsibility is the consumer's
     * to make these substitutions.
     */

    return buffer;
}

API_EXPORT (file_type_e) ap_get_win32_interpreter(const  request_rec *r,
						  char** interpreter )
{
    HANDLE hFile;
    DWORD nBytesRead;
    BOOLEAN bResult;
    char buffer[1024];
    core_dir_config *d;
    int i;
    file_type_e fileType = eFileTypeUNKNOWN;
    char *ext = NULL;
    char *exename = NULL;

    d = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						&core_module);

    /* Find the file extension */
    exename = strrchr(r->filename, '/');
    if (!exename) {
	exename = strrchr(r->filename, '\\');
    }
    if (!exename) {
	exename = r->filename;
    }
    else {
	exename++;
    }
    ext = strrchr(exename, '.');

    if (ext && (!strcasecmp(ext,".bat") || !strcasecmp(ext,".cmd")))
    {
	char *p, *shellcmd = getenv("COMSPEC");
	if (!shellcmd)
	    return eFileTypeUNKNOWN;
	p = strchr(shellcmd, '\0');
	if ((p - shellcmd >= 11) && !strcasecmp(p - 11, "command.com"))
	{
	    /* Command.com doesn't like long paths, doesn't do .cmd
	     */
	    if (!strcasecmp(ext,".cmd"))
		return eFileTypeUNKNOWN;
	    *interpreter = ap_pstrcat(r->pool, "\"", shellcmd, "\" /C %1", NULL);
	    return eCommandShell16;
	}
	else {
	    /* Assume any other likes long paths, and knows .cmd,
	     * but the entire /c arg should be double quoted, e.g.
	     * "c:\path\cmd.exe" /c ""prog" "arg" "arg""
	     */
	    *interpreter = ap_pstrcat(r->pool, "\"", shellcmd, "\" /C \"\"%1\" %*\"", NULL);
	    return eCommandShell32;
	}
    }

    /* If the file has an extension and it is not .com and not .exe and
     * we've been instructed to search the registry, then do it!
     */
    if (ext && strcasecmp(ext,".exe") && strcasecmp(ext,".com") &&
	d->script_interpreter_source == INTERPRETER_SOURCE_REGISTRY) {
	 /* Check the registry */
	*interpreter = get_interpreter_from_win32_registry(r->pool, ext);
	if (*interpreter)
	    return eFileTypeSCRIPT;
	else {
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, r->server,
	     "ScriptInterpreterSource config directive set to \"registry\".\n\t"
	     "Registry was searched but interpreter not found. Trying the shebang line.");
	}
    }

    /* Need to peek into the file figure out what it really is... */
    hFile = CreateFile(r->filename, GENERIC_READ, FILE_SHARE_READ, NULL,
		       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
	return eFileTypeUNKNOWN;
    }
    bResult = ReadFile(hFile, (void*) &buffer, sizeof(buffer) - 1,
		       &nBytesRead, NULL);
    if (!bResult || (nBytesRead == 0)) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		      "ReadFile(%s) failed", r->filename);
	CloseHandle(hFile);
	return eFileTypeUNKNOWN;
    }
    CloseHandle(hFile);
    buffer[nBytesRead] = '\0';

    /* Script or executable, that is the question... */
    if ((buffer[0] == '#') && (buffer[1] == '!')) {
	/* Assuming file is a script since it starts with a shebang */
	fileType = eFileTypeSCRIPT;
	for (i = 2; i < (sizeof(buffer) - 1); i++) {
	    if ((buffer[i] == '\r')
		|| (buffer[i] == '\n')) {
		break;
	    }
	}
	buffer[i] = '\0';
	for (i = 2; buffer[i] == ' ' ; ++i)
	    ;
	*interpreter = ap_pstrdup(r->pool, buffer + i );
    }
    else {
	/* Not a script, is it an executable? */
	IMAGE_DOS_HEADER *hdr = (IMAGE_DOS_HEADER*)buffer;
	if ((nBytesRead >= sizeof(IMAGE_DOS_HEADER)) && (hdr->e_magic == IMAGE_DOS_SIGNATURE)) {
	    if (hdr->e_lfarlc < 0x40)
		fileType = eFileTypeEXE16;
	    else
		fileType = eFileTypeEXE32;
	}
	else
	    fileType = eFileTypeUNKNOWN;
    }

    return fileType;
}
#endif
d927 1
a927 1
			 ? ">" : "";
d971 1
a971 1
	return err;
d987 1
a987 1
	return err;
d1000 1
a1000 1
	return err;
d1028 1
a1028 1
	return err;
d1048 2
a1049 2
    core_request_config *reqconf =
	ap_get_module_config(r->request_config, &core_module);
d1052 3
a1054 8
    if (reqconf == NULL) {
	reqconf = (core_request_config *)ap_pcalloc(r->pool,
						    sizeof(core_request_config));
	ap_set_module_config(r->request_config, &core_module, reqconf);
    }

    if (reqconf->response_code_strings == NULL) {
	reqconf->response_code_strings =
d1056 2
a1057 2
		       sizeof(reqconf->response_code_strings) *
		       RESPONSE_CODES);
d1062 1
a1062 1
    reqconf->response_code_strings[idx] =
d1075 1
a1075 1
	return err;
d1088 1
a1088 1
	index_number = idx500;
d1091 1
a1091 1
	return ap_pstrcat(cmd->pool, "Unsupported HTTP response code ",
d1104 1
a1104 1
	if (conf->response_code_strings == NULL) {
d1108 2
a1109 2
	}
	conf->response_code_strings[index_number] = ap_pstrdup(cmd->pool, line);
d1131 1
a1131 1
	return err;
d1136 1
a1136 1
	w = ap_getword_conf(cmd->pool, &l);
d1144 1
a1144 1
	    d->override |= OR_FILEINFO;
d1150 1
a1150 1
	    d->override |= OR_INDEXES;
d1175 1
a1175 1
	char *w = ap_getword_conf(cmd->pool, &l);
d1182 3
a1184 3
	    d->opts = OPT_NONE;
	    first = 0;
	}
d1242 1
a1242 1
	c->satisfy = SATISFY_ALL;
d1245 1
a1245 1
	c->satisfy = SATISFY_ANY;
d1248 1
a1248 1
	return "Satisfy either 'any' or 'all'.";
d1258 1
a1258 1
	c->ap_requires = ap_make_array(cmd->pool, 2, sizeof(require_line));
d1275 1
a1275 1
	return err;
d1284 2
a1285 2
	char *method = ap_getword_conf(cmd->pool, &limited_methods);
	int  methnum = ap_method_number_of(method);
d1287 10
a1296 10
	if (methnum == M_TRACE && !tog) {
	    return "TRACE cannot be controlled by <Limit>";
	}
	else if (methnum == M_INVALID) {
	    return ap_pstrcat(cmd->pool, "unknown method \"", method,
			      "\" in <Limit", tog ? "Except>" : ">", NULL);
	}
	else {
	    limited |= (1 << methnum);
	}
d1311 1
a1311 1
	return tog ? "</LimitExcept> unexpected" : "</Limit> unexpected";
a1335 3
#ifdef WIN32
#define USE_ICASE REG_ICASE
#else
a1336 1
#endif
d1341 1
a1341 1
	return ap_pstrcat(cmd->pool, cmd->cmd->name,
d1381 1
a1381 1
	return err;
a1395 3
	if (!r) {
	    return "Regex could not be compiled";
	}
a1400 3
	if (!r) {
	    return "Regex could not be compiled";
	}
d1404 2
a1405 2
	/* Treat 'default' path / as an inalienable root */
	cmd->path = ap_pstrdup(cmd->pool, cmd->path);
d1410 2
a1411 2
	/* Treat UNC path // as an inalienable root */
	cmd->path = ap_pstrdup(cmd->pool, cmd->path);
d1464 1
a1464 1
	return err;
a1478 3
	if (!r) {
	    return "Regex could not be compiled";
	}
a1483 3
	if (!r) {
	    return "Regex could not be compiled";
	}
d1488 1
a1488 1
				       : end_location_section;
d1534 1
a1534 1
	return err;
d1551 1
a1551 4
	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
	if (!r) {
	    return "Regex could not be compiled";
	}
a1556 3
	if (!r) {
	    return "Regex could not be compiled";
	}
d1620 1
a1620 1
	arg++;
d1626 1
a1626 1
	return NULL;
d1630 1
a1630 1
	if (!strncasecmp(l, "<IfModule", 9)) {
d1652 2
a1653 2
	if (strcmp(defines[i], name) == 0) {
	    return 1;
d1680 1
a1680 1
	not = 1;
d1691 1
a1691 1
	if (!strncasecmp(l, "<IfDefine", 9)) {
d1717 1
a1717 1
	return err;
d1794 1
a1794 1
	return err;
d1798 5
a1802 5
	if (modp->name != NULL && strcmp(modp->name, arg) == 0) {
	    ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
			  "module %s is already added, skipping", arg);
	    return NULL;
	}
d1816 1
a1816 1
	return err;
d1834 1
a1834 1
	return err;
d1845 1
a1845 1
	return err;
d1849 1
a1849 1
	ap_standalone = 0;
d1852 1
a1852 1
	ap_standalone = 1;
d1855 1
a1855 1
	return "ServerType must be either 'inetd' or 'standalone'";
d1884 1
a1884 1
	return err;
d1891 1
a1891 1
	d->server_signature = srv_sig_off;
d1907 1
a1907 1
	return err;
d1911 1
a1911 1
	return "SendBufferSize must be >= 512 bytes, or 0 for system default.";
a1918 5
#ifdef WIN32
    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, cmd->server,
		 "User directive has no affect on Win32");
    cmd->server->server_uid = ap_user_id = 1;
#else
d1921 1
a1921 1
	return err;
d1938 1
a1938 1
	if (ap_suexec_enabled) {
a1969 1
#endif /* WIN32 */
d1978 1
a1978 1
	return err;
d1988 1
a1988 1
	if (ap_suexec_enabled) {
d2014 1
a2014 1
	return err;
d2046 1
a2046 1
	return err;
d2058 1
a2058 1
	return err;
d2069 1
a2069 1
	return err;
d2088 1
a2088 1
	return err;
a2094 26
#ifdef AP_ENABLE_EXCEPTION_HOOK
static const char *set_exception_hook(cmd_parms *cmd, void *dummy, char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
	return err;
    }

    if (cmd->server->is_virtual) {
	return "EnableExceptionHook directive not allowed in <VirtualHost>";
    }

    if (strcasecmp(arg, "on") == 0) {
	ap_exception_hook_enabled = 1;
    }
    else if (strcasecmp(arg, "off") == 0) {
	ap_exception_hook_enabled = 0;
    }
    else {
	return "parameter must be 'on' or 'off'";
    }

    return NULL;
}
#endif /* AP_ENABLE_EXCEPTION_HOOK */

d2099 1
a2099 1
	return err;
d2113 1
a2113 1
	return err;
d2124 1
a2124 1
	return err;
d2135 1
a2135 1
	return err;
d2147 1
a2147 1
	return err;
d2169 1
a2169 1
	return err;
d2181 1
a2181 1
	return err;
d2197 1
a2197 1
	d->use_canonical_name = USE_CANONICAL_NAME_ON;
d2200 1
a2200 1
	d->use_canonical_name = USE_CANONICAL_NAME_OFF;
d2203 1
a2203 1
	d->use_canonical_name = USE_CANONICAL_NAME_DNS;
d2206 1
a2206 1
	return "parameter must be 'on', 'off', or 'dns'";
a2212 5
#ifdef WIN32
    fprintf(stderr, "WARNING: StartServers has no effect on Win32\n");
#elif defined(NETWARE)
    fprintf(stderr, "WARNING: StartServers has no effect on NetWare\n");
#else
d2215 1
a2215 1
	return err;
a2218 1
#endif
d2226 1
a2226 1
	return err;
d2244 1
a2244 1
	return err;
d2255 1
a2255 1
	return err;
d2261 1
a2261 1
	   "of %d servers,\n", ap_daemons_limit, HARD_SERVER_LIMIT);
d2263 1
a2263 1
	   "see the\n", HARD_SERVER_LIMIT);
d2278 1
a2278 1
	return err;
d2288 1
a2288 1
	return err;
d2293 6
a2298 6
	fprintf(stderr, "WARNING: ThreadsPerChild of %d exceeds compile time limit "
		"of %d threads,\n", ap_threads_per_child, HARD_SERVER_LIMIT);
	fprintf(stderr, " lowering ThreadsPerChild to %d.  To increase, please "
		"see the\n", HARD_SERVER_LIMIT);
	fprintf(stderr, " HARD_SERVER_LIMIT define in src/include/httpd.h.\n");
	ap_threads_per_child = HARD_SERVER_LIMIT;
d2312 1
a2312 1
	return err;
d2322 1
a2322 1
		       const char * arg2, int type)
d2366 1
a2366 1
	if (cur) {
d2369 1
a2369 1
	if (max) {
d2434 1
a2434 1
	return err;
a2449 13
#ifdef NETWARE
static const char *set_threadstacksize(cmd_parms *cmd, void *dummy, char *stacksize)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
	return err;
    }

    ap_thread_stack_size = atoi(stacksize);
    return NULL;
}
#endif

d2474 1
a2474 1
	return err;
d2519 1
a2519 1
	if (host)
d2542 1
a2542 1
	return err;
d2547 1
a2547 1
	return "ListenBacklog must be > 0";
d2558 1
a2558 1
	return err;
a2566 1
    ap_coredump_dir_configured = 1;
d2586 1
a2586 1
	return err;
d2590 1
a2590 1
	if (!strcasecmp(str, "emerg")) {
d2615 2
a2616 2
	    return "LogLevel requires level keyword: one of "
		   "emerg/alert/crit/error/warn/notice/info/debug";
d2620 1
a2620 1
	return "LogLevel requires level keyword";
d2645 1
a2645 1
			  "</a> Port ", sport,
d2650 2
a2651 2
		      ap_escape_html(r->pool, ap_get_server_name(r)),
		      " Port ", sport,
d2683 1
a2683 1
	 return "AuthDigestRealmSeed limited to 0-9 and A-Z range for browser compatibility";
a2688 12
#ifdef _OSD_POSIX /* BS2000 Logon Passwd file */
static const char *set_bs2000_account(cmd_parms *cmd, void *dummy, char *name)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
	return err;
    }

    return os_set_account(cmd->pool, name);
}
#endif /*_OSD_POSIX*/

d2690 1
a2690 1
					      core_dir_config *d, int arg)
d2694 1
a2694 1
	return err;
d2702 1
a2702 1
					      core_dir_config *d, int arg)
d2706 1
a2706 1
	return err;
d2724 1
a2724 1
	return err;
d2728 1
a2728 1
	ap_server_tokens = SrvTk_OS;
d2731 1
a2731 1
	ap_server_tokens = SrvTk_MIN;
d2734 1
a2734 1
	ap_server_tokens = SrvTk_FULL;
d2737 1
a2737 1
	ap_server_tokens = SrvTk_PRODUCT_ONLY;
d2749 1
a2749 1
					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
d2753 1
a2753 1
	return err;
d2757 2
a2758 2
	return ap_pstrcat(cmd->temp_pool, "LimitRequestLine \"", arg,
			  "\" must be a non-negative integer", NULL);
d2761 3
a2763 3
	return ap_psprintf(cmd->temp_pool, "LimitRequestLine \"%s\" "
			   "must not exceed the precompiled maximum of %d",
			   arg, DEFAULT_LIMIT_REQUEST_LINE);
d2770 1
a2770 1
					   char *arg)
d2773 1
a2773 1
					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
d2777 1
a2777 1
	return err;
d2781 3
a2783 3
	return ap_pstrcat(cmd->temp_pool, "LimitRequestFieldsize \"", arg,
			  "\" must be a non-negative integer (0 = no limit)",
			  NULL);
d2786 3
a2788 3
	return ap_psprintf(cmd->temp_pool, "LimitRequestFieldsize \"%s\" "
			  "must not exceed the precompiled maximum of %d",
			   arg, DEFAULT_LIMIT_REQUEST_FIELDSIZE);
d2797 1
a2797 1
					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
d2801 1
a2801 1
	return err;
d2805 3
a2807 3
	return ap_pstrcat(cmd->temp_pool, "LimitRequestFields \"", arg,
			  "\" must be a non-negative integer (0 = no limit)",
			  NULL);
d2814 1
a2814 1
				      char *arg)
d2818 1
a2818 1
	return err;
a2828 17
#ifdef WIN32
static const char *set_interpreter_source(cmd_parms *cmd, core_dir_config *d,
						char *arg)
{
    if (!strcasecmp(arg, "registry")) {
	d->script_interpreter_source = INTERPRETER_SOURCE_REGISTRY;
    } else if (!strcasecmp(arg, "script")) {
	d->script_interpreter_source = INTERPRETER_SOURCE_SHEBANG;
    } else {
	return ap_pstrcat(cmd->temp_pool, "ScriptInterpreterSource \"", arg,
			  "\" must be \"registry\" or \"script\"",
			  NULL);
    }
    return NULL;
}
#endif

d2830 2
a2831 2
					      void *mconfig,
					      int arg)
a2837 116
#ifdef CHARSET_EBCDIC

typedef struct {
  char conv_out[2];
  char conv_in[2];
} parsed_conf_t;

/* Check for conversion syntax:  { On | Off } [ = { In | Out | InOut } ] */
static parsed_conf_t *
parse_on_off_in_out(pool *p, char *arg)
{
    static parsed_conf_t ret = { { conv_Unset, '\0' }, { conv_Unset, '\0' } };
    char *onoff = ap_getword_nc(p, &arg, '=');
    int in = 0, out = 0, inout = 0;
    char conv_val;

    /* Check for valid syntax:  { On | Off } [ = { In | Out | InOut } ] */
    if (strcasecmp(onoff, "On") == 0)
	conv_val = conv_On;
    else if (strcasecmp(onoff, "Off") == 0)
	conv_val = conv_Off;
    else
	return NULL;

    /* Check the syntax, and at the same time assign the test results */
    if (!(inout = (*arg == '\0')) &&
	!(in = (strcasecmp(arg, "In") == 0)) &&
	!(out = (strcasecmp(arg, "Out") == 0)) &&
	!(inout = (strcasecmp(arg, "InOut") == 0))) {
	/* Invalid string, not conforming to syntax! */
	return NULL;
    }

    ret.conv_in[0]  = (in || inout)  ? conv_val : conv_Unset;
    ret.conv_out[0] = (out || inout) ? conv_val : conv_Unset;

    return &ret;
}


/* Handle the EBCDICConvert directive:
 *   EBCDICConvert {On|Off}[={In|Out|InOut}] ext ...
 */
static const char *
add_conversion_by_ext(cmd_parms *cmd, core_dir_config *m,
		      char *onoff, char *ext)
{
    parsed_conf_t *onoff_code = parse_on_off_in_out(cmd->pool, onoff);

    if (onoff_code == NULL)
	return "Invalid syntax: use EBCDICConvert {On|Off}[={In|Out|InOut}] ext [...]";

    if (*ext == '.')
	++ext;

    if (*onoff_code->conv_in != conv_Unset)
	ap_table_addn(m->ebcdicconversion_by_ext_in, ext,
		      ap_pstrndup(cmd->pool, onoff_code->conv_in, 1));
    if (*onoff_code->conv_out != conv_Unset)
	ap_table_addn(m->ebcdicconversion_by_ext_out, ext,
		      ap_pstrndup(cmd->pool, onoff_code->conv_out, 1));

    return NULL;
}


/* Handle the EBCDICConvertByType directive:
 *   EBCDICConvertByType {On|Off}[={In|Out|InOut}] mimetype ...
 */
static const char *
add_conversion_by_type(cmd_parms *cmd, core_dir_config *m,
		       char *onoff, char *type)
{
    parsed_conf_t *onoff_code = parse_on_off_in_out(cmd->pool, onoff);

    if (onoff_code == NULL)
	return "Invalid syntax: use EBCDICConvertByType {On|Off}[={In|Out|InOut}] mimetype [...]";

    if (*onoff_code->conv_in != conv_Unset)
	ap_table_addn(m->ebcdicconversion_by_type_in, type,
		      ap_pstrndup(cmd->pool, onoff_code->conv_in, 1));
    if (*onoff_code->conv_out != conv_Unset)
	ap_table_addn(m->ebcdicconversion_by_type_out, type,
		      ap_pstrndup(cmd->pool, onoff_code->conv_out, 1));

    return NULL;
}


/* Handle the EBCDICKludge directive:
 *   EBCDICKludge {On|Off}
 */
#ifdef LEGACY_KLUDGE
static const char *
set_x_ascii_kludge(cmd_parms *cmd, core_dir_config *m, int arg)
{
    m->x_ascii_magic_kludge = arg;

    return NULL;
}
#endif

#if ADD_EBCDICCONVERT_DEBUG_HEADER
/* Handle the EBCDICDebugHeader directive:
 *   EBCDICDebugHeader {On|Off}
 */
static const char *
set_debug_header(cmd_parms *cmd, core_dir_config *m, int arg)
{
    m->ebcdicconversion_debug_header = arg;

    return NULL;
}
#endif
#endif /* CHARSET_EBCDIC */

d2844 1
a2844 1
				 const char *args_p)
d2861 85
a2945 85
	action = '*';
	bit = ETAG_UNSET;
	valid = 1;
	token = ap_getword_conf(cmd->pool, &args);
	if ((*token == '+') || (*token == '-')) {
	    action = *token;
	    token++;
	}
	else {
	    /*
	     * The occurrence of an absolute setting wipes
	     * out any previous relative ones.  The first such
	     * occurrence forgets any inherited ones, too.
	     */
	    if (first) {
		cfg->etag_bits = ETAG_UNSET;
		cfg->etag_add = ETAG_UNSET;
		cfg->etag_remove = ETAG_UNSET;
		first = 0;
	    }
	}

	if (strcasecmp(token, "None") == 0) {
	    if (action != '*') {
		valid = 0;
	    }
	    else {
		cfg->etag_bits = bit = ETAG_NONE;
		explicit = 1;
	    }
	}
	else if (strcasecmp(token, "All") == 0) {
	    if (action != '*') {
		valid = 0;
	    }
	    else {
		explicit = 1;
		cfg->etag_bits = bit = ETAG_ALL;
	    }
	}
	else if (strcasecmp(token, "Size") == 0) {
	    bit = ETAG_SIZE;
	}
	else if ((strcasecmp(token, "LMTime") == 0)
		 || (strcasecmp(token, "MTime") == 0)
		 || (strcasecmp(token, "LastModified") == 0)) {
	    bit = ETAG_MTIME;
	}
	else if (strcasecmp(token, "INode") == 0) {
	    bit = ETAG_INODE;
	}
	else {
	    return ap_pstrcat(cmd->pool, "Unknown keyword '",
			      token, "' for ", cmd->cmd->name,
			      " directive", NULL);
	}

	if (! valid) {
	    return ap_pstrcat(cmd->pool, cmd->cmd->name, " keyword '",
			      token, "' cannot be used with '+' or '-'",
			      NULL);
	}

	if (action == '+') {
	    /*
	     * Make sure it's in the 'add' list and absent from the
	     * 'subtract' list.
	     */
	    cfg->etag_add |= bit;
	    cfg->etag_remove &= (~ bit);
	}
	else if (action == '-') {
	    cfg->etag_remove |= bit;
	    cfg->etag_add &= (~ bit);
	}
	else {
	    /*
	     * Non-relative values wipe out any + or - values
	     * accumulated so far.
	     */
	    cfg->etag_bits |= bit;
	    cfg->etag_add = ETAG_UNSET;
	    cfg->etag_remove = ETAG_UNSET;
	    explicit = 1;
	}
d2953 1
a2953 1
	cfg->etag_add &= (~ ETAG_UNSET);
d2956 1
a2956 1
	cfg->etag_remove &= (~ ETAG_UNSET);
d2959 4
a2962 4
	cfg->etag_bits &= (~ ETAG_UNSET);
	if ((cfg->etag_bits & ETAG_NONE) != ETAG_NONE) {
	    cfg->etag_bits &= (~ ETAG_NONE);
	}
d2968 1
a2968 1
				       const char *arg1, const char *arg2)
d2971 1
a2971 1
						    &core_module);
d2975 1
a2975 1
	return "The redirect recursion limit cannot be less than zero.";
d2978 3
a2980 3
	ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
		     "Limiting internal redirects to very low numbers may "
		     "cause normal requests to fail.");
d2986 1
a2986 1
	limit = atoi(arg2);
d2988 8
a2995 8
	if (limit < 0) {
	    return "The subrequest recursion limit cannot be less than zero.";
	}
	if (limit && limit < 4) {
	    ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
			 "Limiting the subrequest depth to a very low level may"
			 " cause normal requests to fail.");
	}
d3009 1
a3009 1
		  "r->uri = %s", r->uri ? r->uri : "(unexpectedly NULL)");
d3012 13
a3024 13
	if (top->prev) {
	    top = top->prev;
	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
			  "redirected from r->uri = %s",
			  top->uri ? top->uri : "(unexpectedly NULL)");
	}

	if (!top->prev && top->main) {
	    top = top->main;
	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
			  "subrequested from r->uri = %s",
			  top->uri ? top->uri : "(unexpectedly NULL)");
	}
d3034 1
a3034 1
						    &core_module);
d3038 2
a3039 2
		 ? conf->redirect_limit
		 : AP_DEFAULT_MAX_INTERNAL_REDIRECTS;
d3041 2
a3042 2
		 ? conf->subreq_limit
		 : AP_DEFAULT_MAX_SUBREQ_DEPTH;
d3046 1
a3046 1
	return 0;
d3050 36
a3085 12
	if (top->prev) {
	    if (rlimit && ++redirects >= rlimit) {
		/* uuh, too much. */
		ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
			      "Request exceeded the limit of %d internal "
			      "redirects due to probable configuration error. "
			      "Use 'LimitInternalRecursion' to increase the "
			      "limit if necessary. Use 'LogLevel debug' to get "
			      "a backtrace.", rlimit);

		/* post backtrace */
		log_backtrace(r);
d3087 2
a3088 26
		/* return failure */
		return 1;
	    }

	    top = top->prev;
	}

	if (!top->prev && top->main) {
	    if (slimit && ++subreqs >= slimit) {
		/* uuh, too much. */
		ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
			      "Request exceeded the limit of %d subrequest "
			      "nesting levels due to probable confguration "
			      "error. Use 'LimitInternalRecursion' to increase "
			      "the limit if necessary. Use 'LogLevel debug' to "
			      "get a backtrace.", slimit);

		/* post backtrace */
		log_backtrace(r);

		/* return failure */
		return 1;
	    }

	    top = top->main;
	}
a3287 4
#ifdef NETWARE
{ "ThreadStackSize", set_threadstacksize, NULL, RSRC_CONF, TAKE1,
  "Stack size each created thread will use."},
#endif
a3323 8
#ifdef _OSD_POSIX
{ "BS2000Account", set_bs2000_account, NULL, RSRC_CONF, TAKE1,
  "Name of server User's bs2000 logon account name" },
#endif
#ifdef WIN32
{ "ScriptInterpreterSource", set_interpreter_source, NULL, OR_FILEINFO, TAKE1,
  "Where to find interpreter to run Win32 scripts - Registry or Script (shebang line)" },
#endif
a3358 9
#ifdef HAVE_OS2SEM_SERIALIZED_ACCEPT
    "'os2sem' "
#endif
#ifdef HAVE_TPF_CORE_SERIALIZED_ACCEPT
    "'tpfcore' "
#endif
#ifdef HAVE_BEOS_SERIALIZED_ACCEPT
    "'beos_sem' "
#endif
a3363 20
#ifdef AP_ENABLE_EXCEPTION_HOOK
{ "EnableExceptionHook", set_exception_hook, NULL, RSRC_CONF, TAKE1,
  "Controls whether exception hook may be called after a crash" },
#endif

/* EBCDIC Conversion directives: */
#ifdef CHARSET_EBCDIC
{ "EBCDICConvert", add_conversion_by_ext, NULL, OR_FILEINFO, ITERATE2,
    "{On|Off}[={In|Out|InOut}] followed by one or more file extensions" },
{ "EBCDICConvertByType", add_conversion_by_type, NULL, OR_FILEINFO, ITERATE2,
    "{On|Off}[={In|Out|InOut}] followed by one or more MIME types" },
#ifdef LEGACY_KLUDGE
{ "EBCDICKludge", set_x_ascii_kludge, NULL, OR_FILEINFO, FLAG,
    "'On': enable or default='Off': disable the old text/x-ascii-mimetype kludge" },
#endif
#if ADD_EBCDICCONVERT_DEBUG_HEADER
{ "EBCDICDebugHeader", set_debug_header, NULL, OR_FILEINFO, FLAG,
    "'On': enable or default='Off': disable the EBCDIC Debugging MIME Header" },
#endif
#endif /* CHARSET_EBCDIC */
d3385 1
a3385 1
	return HTTP_FORBIDDEN;
d3398 1
a3398 1
	r->filename = ap_pstrcat(r->pool, conf->ap_document_root,
d3403 5
a3407 5
	 * Make sure that we do not mess up the translation by adding two
	 * /'s in a row.  This happens under windows when the document
	 * root ends with a /
	 */
	if ((conf->ap_document_root[strlen(conf->ap_document_root)-1] == '/')
a3422 253
#ifdef CHARSET_EBCDIC
struct do_mime_match_parms {
    request_rec *request;     /* [In] current request_rec */
    int direction;            /* [In] determine conversion for: dir_In|dir_Out */
    const char *content_type; /* [In] Content-Type (dir_In: from MIME Header, else r->content_type) */
    int match_found;          /* [Out] nonzero if a match was found */
    int conv;                 /* [Out] conversion setting if match was found */
};


/* This routine is called for each mime type configured by the
 * EBCDICConvertByType directive.
 */
static int
do_mime_match(void *rec, const char *key, const char *val)
{
    int conv = (val[0] == conv_On);
    const char *content_type;
#if ADD_EBCDICCONVERT_DEBUG_HEADER
    request_rec *r = ((struct do_mime_match_parms *) rec)->request;
#endif

    ((struct do_mime_match_parms *) rec)->match_found = 0;
    ((struct do_mime_match_parms *) rec)->conv = conv_Unset;

    content_type = ((struct do_mime_match_parms *) rec)->content_type;

    /* If no type set: no need to continue */
    if (content_type == NULL)
	return 0;

    /* If the MIME type matches, set the conversion flag appropriately */
    if ((ap_is_matchexp(key) && ap_strcasecmp_match(content_type, key) == 0)
	|| (strcasecmp(key, content_type) == 0)) {

	((struct do_mime_match_parms *) rec)->match_found = 1;
	((struct do_mime_match_parms *) rec)->conv = conv;

#if ADD_EBCDICCONVERT_DEBUG_HEADER
	ap_table_setn(r->headers_out,
	       ((((struct do_mime_match_parms *) rec)->direction) == dir_In)
		      ? "X-EBCDIC-Debug-In" : "X-EBCDIC-Debug-Out",
		       ap_psprintf(r->pool, "EBCDICConversionByType %s %s",
				   conv ? "On" : "Off",
				   key));
#endif

	/* the mime type scan stops at the first  match. */
	return 0;
    }

    return 1;
}

static void
ap_checkconv_dir(request_rec *r, const char **pType, int dir)
{
    core_dir_config *conf =
    (core_dir_config *) ap_get_module_config(r->per_dir_config, &core_module);
    table *conv_by_ext, *conv_by_type;
    const char *type, *conversion;
    char *ext;
    int conv_valid = 0, conv;

    conv_by_ext  = (dir == dir_In) ? conf->ebcdicconversion_by_ext_in  : conf->ebcdicconversion_by_ext_out;
    conv_by_type = (dir == dir_In) ? conf->ebcdicconversion_by_type_in : conf->ebcdicconversion_by_type_out;

    type = (*pType == NULL) ? ap_default_type(r) : *pType;

    /* Pseudo "loop" which is executed once only, with break's at individual steps */
    do {
	/* Step 0: directories result in redirections or in directory listings.
	 * Both are EBCDIC text documents.
	 * @@@@@@ Should we check for the handler instead?
	 */
	if (S_ISDIR(r->finfo.st_mode) && dir == dir_Out) {
	    conv = conv_valid = 1;
	    break;
	}

	/* 1st step: check the binding on file extension. This allows us to
	 * override the conversion default based on a specific name.
	 * For instance, the following would allow some HTML files
	 * to be converted (.html) and others passed unconverted (.ahtml):
	 *     AddType text/html .html .ahtml
	 *     EBCDICConvert Off .ahtml
	 * For uploads, this assumes that the destination file name
	 * has the correct extension. That may not be true for, e.g.,
	 * Netscape Communicator roaming profile uploads!
	 */
	if (r->filename && !ap_is_empty_table(conv_by_ext)) {
	    const char *fn = strrchr(r->filename, '/');

	    if (fn == NULL)
		fn = r->filename;

	    /* Parse filename extension */
	    if ((ext = strrchr(fn, '.')) != NULL) {
		++ext;

		/* Check for Content-Type */
		if ((conversion = ap_table_get(conv_by_ext, ext)) != NULL) {

#if ADD_EBCDICCONVERT_DEBUG_HEADER
		    if (conf->ebcdicconversion_debug_header)
			ap_table_setn(r->headers_out,
				      (dir == dir_In) ? "X-EBCDIC-Debug-In" : "X-EBCDIC-Debug-Out",
				      ap_psprintf(r->pool, "EBCDICConversion %s .%s",
						  (conversion[0] == conv_On) ? "On" : "Off",
						  ext));
#endif

		    conv = (conversion[0] == conv_On);
		    conv_valid = 1;
		    break;
		}
	    }
	}


	/* 2nd step: test for the old "legacy kludge", that is, a default
	 * conversion=on for text/?* message/?* multipart/?* and the possibility
	 * to override the text/?* conversion with a definition like
	 *    AddType text/x-ascii-plain .atxt
	 *    AddType text/x-ascii-html  .ahtml
	 * where the "x-ascii-" would be removed and the conversion switched
	 * off.
	 * This step must be performed prior to testing wildcard MIME types
	 * like text/?* by the EBCDICConvertByType directive.
	 */
#ifdef LEGACY_KLUDGE
	/* This fallback is only used when enabled (default=off) */
	if (conf->x_ascii_magic_kludge) {
	    char *magic;

	    /* If the mime type of a document is set to
	     * "text/x-ascii-anything", it gets changed to
	     * "text/anything" here and the conversion is forced to off
	     * ("binary" or ASCII documents).
	     */
	    if (*pType != NULL
		&& (magic = strstr(*pType, "/x-ascii-")) != NULL) {

#if ADD_EBCDICCONVERT_DEBUG_HEADER
		if (conf->ebcdicconversion_debug_header)
		    ap_table_setn(r->headers_out,
				  (dir == dir_In) ? "X-EBCDIC-Debug-In" : "X-EBCDIC-Debug-Out",
				  ap_psprintf(r->pool, "EBCDICKludge On (and type is: %s, thus no conversion)",
					      *pType));
#endif

		/* the mime type scan stops at the first  match. */
		magic[1] = '\0';        /* overwrite 'x' */

		/* Fix MIME type: strip out the magic "x-ascii-" substring */
		*pType = ap_pstrcat(r->pool, *pType, &magic[9], NULL);

		magic[1] = 'x'; /* restore 'x' in old string (just in case) */

		/* Switch conversion to BINARY */
		conv = 0;       /* do NOT convert this document */
		conv_valid = 1;
		break;
	    }
	}
#endif /*LEGACY_KLUDGE */


	/* 3rd step: check whether a generic conversion was defined for a MIME type,
	 * like in
	 *    EBCDICConvertByType  On  model/vrml application/postscript text/?*
	 */
	if (!ap_is_empty_table(conv_by_type)) {
	    struct do_mime_match_parms do_par;

	    do_par.request = r;
	    do_par.direction = dir;
	    do_par.content_type = type;

	    ap_table_do(do_mime_match, (void *) &do_par, conv_by_type, NULL);

	    if ((conv_valid = do_par.match_found) != 0) {
		conv = do_par.conv;
		break;
	    }
	}
	else /* If no conversion by type was configured, use the default: */
	{
	    /*
	     * As a final step, mime types starting with "text/", "message/" or
	     * "multipart/" imply a conversion, while all the rest is
	     * delivered unconverted (i.e., binary, e.g. application/octet-stream).
	     */

	    /* If no content type is set then treat it as text (conversion=on) */
	    conv =
		(type == NULL) ||
		(strncasecmp(type, "text/", 5) == 0) ||
		(strncasecmp(type, "message/", 8) == 0) ||
		(strncasecmp(type, "multipart/", 10) == 0) ||
		(strcasecmp(type, "application/x-www-form-urlencoded") == 0);

#if ADD_EBCDICCONVERT_DEBUG_HEADER
		if (conf->ebcdicconversion_debug_header)
		    ap_table_setn(r->headers_out,
				  (dir == dir_In) ? "X-EBCDIC-Debug-In" : "X-EBCDIC-Debug-Out",
				  ap_psprintf(r->pool,
					      "No EBCDICConversion configured (and type is: %s, "
					      "=> guessed conversion = %s)",
					      type, conv ? "On" : "Off"));
#endif
	    conv_valid = 1;
	    break;
	}
    } while (0);

    if (conv_valid) {
	if (dir == dir_In)
	    r->ebcdic.conv_in = conv;
	else
	    r->ebcdic.conv_out = conv;
    }
}

/* This function determines the conversion for uploads (PUT/POST): */
API_EXPORT(int)
ap_checkconv_in(request_rec *r)
{
    const char *typep;

    /* If nothing is being sent as input anyway, we don't bother about conversion */
    /* (see ap_should_client_block())*/
    if (r->read_length || (!r->read_chunked && (r->remaining <= 0)))
	return r->ebcdic.conv_in;

    typep = ap_table_get(r->headers_in, "Content-Type");
    ap_checkconv_dir(r, &typep, dir_In);

    return r->ebcdic.conv_in;
}


/* Backward compatibility function */
API_EXPORT(int)
ap_checkconv(request_rec *r)
{
    ap_checkconv_dir(r, &r->content_type, dir_Out);
    return r->ebcdic.conv_out;
}

#endif /* CHARSET_EBCDIC */


d3434 3
a3436 3
	ap_log_error(APLOG_MARK, APLOG_ERR, NULL,
		     "Failed to munmap memory of length %ld at 0x%lx",
		     (long) mmd->length, (long) mmd->mm);
d3463 1
a3463 1
	return errstatus;
d3475 1
a3475 1
	return ap_send_http_options(r);
d3478 1
a3478 1
	return METHOD_NOT_ALLOWED;
d3489 1
a3489 1
	return METHOD_NOT_ALLOWED;
a3491 4
#if defined(OS2) || defined(WIN32) || defined(NETWARE) || defined(CYGWIN)
    /* Need binary mode for OS/2 */
    f = ap_pfopen(r->pool, r->filename, "rb");
#else
a3492 1
#endif
d3495 1
a3495 1
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
d3497 1
a3497 1
	return FORBIDDEN;
d3506 1
a3506 1
	return errstatus;
d3515 1
a3515 1
	 * file mmapped */
a3530 6
#ifdef CHARSET_EBCDIC
	if (d->content_md5 & 1) {
	    ap_table_setn(r->headers_out, "Content-MD5",
			  ap_md5digest(r->pool, f, r->ebcdic.conv_out));
	}
#else
a3534 1
#endif /* CHARSET_EBCDIC */
@


1.11
log
@merge openbsd security (our way) and bring MirOS httpd back to life
(well... it compiles.)
@
text
@d1 1
a1 1
/* $MirBSD: src/usr.sbin/httpd/src/main/http_core.c,v 1.10 2004/08/21 23:30:54 tg Exp $ */
d65 2
a66 2
                                   * ErrorDocument
                                   */
d88 1
a88 1
        conf->d = dir;
d91 1
a91 1
        conf->d = ap_pstrdup(a, dir);
d94 1
a94 1
        conf->d = ap_pstrcat(a, dir, "/", NULL);
d184 1
a184 1
	                    | new->opts_remove;
d186 2
a187 2
        if ((base->opts & OPT_INCNOEXEC) && (new->opts & OPT_INCLUDES)) {
            conf->opts = (conf->opts & ~OPT_INCNOEXEC) | OPT_INCLUDES;
d200 1
a200 1
        conf->override = new->override;
d203 1
a203 1
        conf->ap_default_type = new->ap_default_type;
d207 1
a207 1
        conf->ap_auth_type = new->ap_auth_type;
d210 1
a210 1
        conf->ap_auth_name = new->ap_auth_name;
d213 1
a213 1
        conf->ap_auth_nonce = new->ap_auth_nonce;
d216 1
a216 1
        conf->ap_requires = new->ap_requires;
d228 1
a228 1
	        if (new->response_code_strings[i] != NULL) {
d230 1
a230 1
		        = new->response_code_strings[i];
d239 1
a239 1
        conf->do_rfc1413 = new->do_rfc1413;
d242 1
a242 1
        conf->content_md5 = new->content_md5;
d250 1
a250 1
        conf->limit_cpu = new->limit_cpu;
d255 1
a255 1
        conf->limit_time = new->limit_time;
d260 1
a260 1
        conf->limit_mem = new->limit_mem;
d265 1
a265 1
        conf->limit_nproc = new->limit_nproc;
d270 1
a270 1
        conf->limit_req_body = new->limit_req_body;
d275 1
a275 1
        conf->satisfy = new->satisfy;
d280 1
a280 1
        conf->script_interpreter_source = new->script_interpreter_source;
d297 1
a297 1
                                               base->ebcdicconversion_by_ext_in);
d299 1
a299 1
                                               base->ebcdicconversion_by_ext_out);
d301 1
a301 1
                                                base->ebcdicconversion_by_type_in);
d303 1
a303 1
                                                base->ebcdicconversion_by_type_out);
d314 6
a319 6
        conf->etag_add =
            (conf->etag_add & (~ new->etag_remove)) | new->etag_add;
        conf->etag_remove =
            (conf->opts_remove & (~ new->etag_add)) | new->etag_remove;
        conf->etag_bits =
            (conf->etag_bits & (~ conf->etag_remove)) | conf->etag_add;
d322 3
a324 3
        conf->etag_bits = new->etag_bits;
        conf->etag_add = new->etag_add;
        conf->etag_remove = new->etag_remove;
d327 1
a327 1
        conf->etag_bits &= (~ ETAG_NONE);
d331 1
a331 1
        conf->cgi_command_args = new->cgi_command_args;
d369 1
a369 1
        conf->access_name = base->access_name;
d372 1
a372 1
        conf->ap_document_root = base->ap_document_root;
d378 2
a379 2
                           ? virt->redirect_limit
                           : base->redirect_limit;
d382 2
a383 2
                         ? virt->subreq_limit
                         : base->subreq_limit;
d437 2
a438 2
            && strchr((entry_core)->d, ':') \
            && *(strchr((entry_core)->d, ':') + 1) != '/'))
d566 1
a566 1
                                                   &core_module);
d579 2
a580 2
    return ap_psprintf(r->pool,"%pp%pp%pp%pp%pp",
           (void *)&(((struct sockaddr_in *)&r->connection->local_addr)->sin_addr),
d582 3
a584 3
           (void *)ap_listeners,
           (void *)ap_server_argv0,
           (void *)ap_pid_fname);
d594 2
a595 2
               ? conf->ap_default_type
               : DEFAULT_CONTENT_TYPE;
d640 1
a640 1
                                                          &core_module);
d643 3
a645 3
        reqconf->response_code_strings != NULL &&
        reqconf->response_code_strings[error_index] != NULL) {
        return reqconf->response_code_strings[error_index];
d650 1
a650 1
                                                      &core_module);
d687 1
a687 1
        conn->remote_host = ""; /* prevent another lookup */
d713 2
a714 2
            hostbuf1, sizeof(hostbuf1), NULL, 0,
            NI_NUMERICHOST))
d717 2
a718 2
            hostbuf2, sizeof(hostbuf2), NULL, 0,
            NI_NUMERICHOST))
d847 1
a847 1
        return r->hostname ? r->hostname : r->server->server_hostname;
d850 2
a851 2
        if (conn->local_host == NULL) {
            int old_stat;
d883 1
a883 1
        || d->use_canonical_name == USE_CANONICAL_NAME_DNS) {
d885 10
a894 8
        /* With UseCanonicalName Off Apache will form self-referential
         * URLs using the hostname and port supplied by the client if
         * any are supplied (otherwise it will use the canonical name).
         */
        port = r->parsed_uri.port_str ? r->parsed_uri.port :
          cport ? cport :
            r->server->port ? r->server->port :
              ap_default_port(r);
d896 3
a898 3
        port = r->server->port ? r->server->port :
          cport ? cport :
            ap_default_port(r);
d940 1
a940 1
        return NULL;
d951 1
a951 1
                          &hkeyOpen);
d954 1
a954 1
        return NULL;
d961 2
a962 2
        buffer = ap_palloc(p, size);
        result = RegQueryValueEx(hkeyOpen, "", NULL, &type, buffer, &size);
d968 1
a968 1
        return NULL;
d974 1
a974 1
                          &hkeyOpen);
d977 1
a977 1
        return NULL;
d984 2
a985 2
        buffer = ap_palloc(p, size);
        result = RegQueryValueEx(hkeyOpen, "", 0, &type, buffer, &size);
d991 1
a991 1
        return NULL;
d1001 3
a1003 3
        s = ap_palloc(p, size);
        if (ExpandEnvironmentStrings(buffer, s, size))
            buffer = s;
d1029 1
a1029 1
                                                  char** interpreter )
d1042 1
a1042 1
                                                &core_module);
d1047 1
a1047 1
        exename = strrchr(r->filename, '\\');
d1050 1
a1050 1
        exename = r->filename;
d1053 1
a1053 1
        exename++;
d1059 21
a1079 21
        char *p, *shellcmd = getenv("COMSPEC");
        if (!shellcmd)
            return eFileTypeUNKNOWN;
        p = strchr(shellcmd, '\0');
        if ((p - shellcmd >= 11) && !strcasecmp(p - 11, "command.com"))
        {
            /* Command.com doesn't like long paths, doesn't do .cmd
             */
            if (!strcasecmp(ext,".cmd"))
                return eFileTypeUNKNOWN;
            *interpreter = ap_pstrcat(r->pool, "\"", shellcmd, "\" /C %1", NULL);
            return eCommandShell16;
        }
        else {
            /* Assume any other likes long paths, and knows .cmd,
             * but the entire /c arg should be double quoted, e.g.
             * "c:\path\cmd.exe" /c ""prog" "arg" "arg""
             */
            *interpreter = ap_pstrcat(r->pool, "\"", shellcmd, "\" /C \"\"%1\" %*\"", NULL);
            return eCommandShell32;
        }
d1086 10
a1095 10
        d->script_interpreter_source == INTERPRETER_SOURCE_REGISTRY) {
         /* Check the registry */
        *interpreter = get_interpreter_from_win32_registry(r->pool, ext);
        if (*interpreter)
            return eFileTypeSCRIPT;
        else {
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, r->server,
             "ScriptInterpreterSource config directive set to \"registry\".\n\t"
             "Registry was searched but interpreter not found. Trying the shebang line.");
        }
d1100 1
a1100 1
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
d1102 1
a1102 1
        return eFileTypeUNKNOWN;
d1105 1
a1105 1
                       &nBytesRead, NULL);
d1107 4
a1110 4
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                      "ReadFile(%s) failed", r->filename);
        CloseHandle(hFile);
        return eFileTypeUNKNOWN;
d1117 12
a1128 12
        /* Assuming file is a script since it starts with a shebang */
        fileType = eFileTypeSCRIPT;
        for (i = 2; i < (sizeof(buffer) - 1); i++) {
            if ((buffer[i] == '\r')
                || (buffer[i] == '\n')) {
                break;
            }
        }
        buffer[i] = '\0';
        for (i = 2; buffer[i] == ' ' ; ++i)
            ;
        *interpreter = ap_pstrdup(r->pool, buffer + i );
d1131 10
a1140 10
        /* Not a script, is it an executable? */
        IMAGE_DOS_HEADER *hdr = (IMAGE_DOS_HEADER*)buffer;
        if ((nBytesRead >= sizeof(IMAGE_DOS_HEADER)) && (hdr->e_magic == IMAGE_DOS_SIGNATURE)) {
            if (hdr->e_lfarlc < 0x40)
                fileType = eFileTypeEXE16;
            else
                fileType = eFileTypeEXE32;
        }
        else
            fileType = eFileTypeUNKNOWN;
d1169 1
a1169 1
                         ? ">" : "";
d1213 1
a1213 1
        return err;
d1229 1
a1229 1
        return err;
d1242 1
a1242 1
        return err;
d1270 1
a1270 1
        return err;
d1295 3
a1297 3
        reqconf = (core_request_config *)ap_pcalloc(r->pool,
                                                    sizeof(core_request_config));
        ap_set_module_config(r->request_config, &core_module, reqconf);
d1301 1
a1301 1
        reqconf->response_code_strings =
d1303 2
a1304 2
                       sizeof(reqconf->response_code_strings) *
                       RESPONSE_CODES);
d1322 1
a1322 1
        return err;
d1335 1
a1335 1
        index_number = idx500;
d1338 1
a1338 1
        return ap_pstrcat(cmd->pool, "Unsupported HTTP response code ",
d1351 1
a1351 1
    	if (conf->response_code_strings == NULL) {
d1355 2
a1356 2
        }
        conf->response_code_strings[index_number] = ap_pstrdup(cmd->pool, line);
d1378 1
a1378 1
        return err;
d1383 1
a1383 1
        w = ap_getword_conf(cmd->pool, &l);
d1391 1
a1391 1
            d->override |= OR_FILEINFO;
d1397 1
a1397 1
            d->override |= OR_INDEXES;
d1422 1
a1422 1
        char *w = ap_getword_conf(cmd->pool, &l);
d1429 3
a1431 3
  	    d->opts = OPT_NONE;
            first = 0;
        }
d1489 1
a1489 1
        c->satisfy = SATISFY_ALL;
d1492 1
a1492 1
        c->satisfy = SATISFY_ANY;
d1495 1
a1495 1
        return "Satisfy either 'any' or 'all'.";
d1505 1
a1505 1
        c->ap_requires = ap_make_array(cmd->pool, 2, sizeof(require_line));
d1522 1
a1522 1
        return err;
d1531 2
a1532 2
        char *method = ap_getword_conf(cmd->pool, &limited_methods);
        int  methnum = ap_method_number_of(method);
d1534 10
a1543 10
        if (methnum == M_TRACE && !tog) {
            return "TRACE cannot be controlled by <Limit>";
        }
        else if (methnum == M_INVALID) {
            return ap_pstrcat(cmd->pool, "unknown method \"", method,
                              "\" in <Limit", tog ? "Except>" : ">", NULL);
        }
        else {
            limited |= (1 << methnum);
        }
d1558 1
a1558 1
        return tog ? "</LimitExcept> unexpected" : "</Limit> unexpected";
d1592 1
a1592 1
        return ap_pstrcat(cmd->pool, cmd->cmd->name,
d1632 1
a1632 1
        return err;
d1647 3
d1655 3
d1661 2
a1662 2
        /* Treat 'default' path / as an inalienable root */
        cmd->path = ap_pstrdup(cmd->pool, cmd->path);
d1667 2
a1668 2
        /* Treat UNC path // as an inalienable root */
        cmd->path = ap_pstrdup(cmd->pool, cmd->path);
d1721 1
a1721 1
        return err;
d1736 3
d1744 3
d1751 1
a1751 1
                                       : end_location_section;
d1797 1
a1797 1
        return err;
d1814 4
a1817 1
        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
d1823 3
d1889 1
a1889 1
        arg++;
d1895 1
a1895 1
        return NULL;
d1899 1
a1899 1
        if (!strncasecmp(l, "<IfModule", 9)) {
d1921 2
a1922 2
        if (strcmp(defines[i], name) == 0) {
            return 1;
d1949 1
a1949 1
        not = 1;
d1960 1
a1960 1
        if (!strncasecmp(l, "<IfDefine", 9)) {
d1986 1
a1986 1
        return err;
d2063 1
a2063 1
        return err;
d2067 5
a2071 5
        if (modp->name != NULL && strcmp(modp->name, arg) == 0) {
            ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
                          "module %s is already added, skipping", arg);
            return NULL;
        }
d2085 1
a2085 1
        return err;
d2103 1
a2103 1
        return err;
d2114 1
a2114 1
        return err;
d2118 1
a2118 1
        ap_standalone = 0;
d2121 1
a2121 1
        ap_standalone = 1;
d2124 1
a2124 1
        return "ServerType must be either 'inetd' or 'standalone'";
d2153 1
a2153 1
        return err;
d2160 1
a2160 1
        d->server_signature = srv_sig_off;
d2176 1
a2176 1
        return err;
d2180 1
a2180 1
        return "SendBufferSize must be >= 512 bytes, or 0 for system default.";
d2195 1
a2195 1
        return err;
d2212 1
a2212 1
        if (ap_suexec_enabled) {
d2253 1
a2253 1
        return err;
d2263 1
a2263 1
        if (ap_suexec_enabled) {
d2289 1
a2289 1
        return err;
d2321 1
a2321 1
        return err;
d2333 1
a2333 1
        return err;
d2344 1
a2344 1
        return err;
d2363 1
a2363 1
        return err;
d2375 1
a2375 1
        return err;
d2383 1
a2383 1
        ap_exception_hook_enabled = 1;
d2386 1
a2386 1
        ap_exception_hook_enabled = 0;
d2389 1
a2389 1
        return "parameter must be 'on' or 'off'";
d2400 1
a2400 1
        return err;
d2414 1
a2414 1
        return err;
d2425 1
a2425 1
        return err;
d2436 1
a2436 1
        return err;
d2448 1
a2448 1
        return err;
d2470 1
a2470 1
        return err;
d2482 1
a2482 1
        return err;
d2498 1
a2498 1
        d->use_canonical_name = USE_CANONICAL_NAME_ON;
d2501 1
a2501 1
        d->use_canonical_name = USE_CANONICAL_NAME_OFF;
d2504 1
a2504 1
        d->use_canonical_name = USE_CANONICAL_NAME_DNS;
d2507 1
a2507 1
        return "parameter must be 'on', 'off', or 'dns'";
d2521 1
a2521 1
        return err;
d2533 1
a2533 1
        return err;
d2551 1
a2551 1
        return err;
d2562 1
a2562 1
        return err;
d2568 1
a2568 1
           "of %d servers,\n", ap_daemons_limit, HARD_SERVER_LIMIT);
d2570 1
a2570 1
           "see the\n", HARD_SERVER_LIMIT);
d2585 1
a2585 1
        return err;
d2595 1
a2595 1
        return err;
d2600 6
a2605 6
        fprintf(stderr, "WARNING: ThreadsPerChild of %d exceeds compile time limit "
                "of %d threads,\n", ap_threads_per_child, HARD_SERVER_LIMIT);
        fprintf(stderr, " lowering ThreadsPerChild to %d.  To increase, please "
                "see the\n", HARD_SERVER_LIMIT);
        fprintf(stderr, " HARD_SERVER_LIMIT define in src/include/httpd.h.\n");
        ap_threads_per_child = HARD_SERVER_LIMIT;
d2619 1
a2619 1
        return err;
d2629 1
a2629 1
                       const char * arg2, int type)
d2673 1
a2673 1
        if (cur) {
d2676 1
a2676 1
        if (max) {
d2741 1
a2741 1
        return err;
d2762 1
a2762 1
        return err;
d2794 1
a2794 1
        return err;
d2839 1
a2839 1
        if (host)
d2862 1
a2862 1
        return err;
d2867 1
a2867 1
        return "ListenBacklog must be > 0";
d2878 1
a2878 1
        return err;
d2907 1
a2907 1
        return err;
d2911 1
a2911 1
        if (!strcasecmp(str, "emerg")) {
d2936 2
a2937 2
            return "LogLevel requires level keyword: one of "
	           "emerg/alert/crit/error/warn/notice/info/debug";
d2941 1
a2941 1
        return "LogLevel requires level keyword";
d2966 1
a2966 1
                          "</a> Port ", sport,
d2971 2
a2972 2
                      ap_escape_html(r->pool, ap_get_server_name(r)),
                      " Port ", sport,
d3004 1
a3004 1
         return "AuthDigestRealmSeed limited to 0-9 and A-Z range for browser compatibility";
d3015 1
a3015 1
        return err;
d3023 1
a3023 1
                                              core_dir_config *d, int arg)
d3027 1
a3027 1
        return err;
d3035 1
a3035 1
                                              core_dir_config *d, int arg)
d3039 1
a3039 1
        return err;
d3057 1
a3057 1
        return err;
d3061 1
a3061 1
        ap_server_tokens = SrvTk_OS;
d3064 1
a3064 1
        ap_server_tokens = SrvTk_MIN;
d3067 1
a3067 1
        ap_server_tokens = SrvTk_FULL;
d3070 1
a3070 1
        ap_server_tokens = SrvTk_PRODUCT_ONLY;
d3082 1
a3082 1
                                           NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
d3086 1
a3086 1
        return err;
d3090 2
a3091 2
        return ap_pstrcat(cmd->temp_pool, "LimitRequestLine \"", arg,
                          "\" must be a non-negative integer", NULL);
d3094 3
a3096 3
        return ap_psprintf(cmd->temp_pool, "LimitRequestLine \"%s\" "
                           "must not exceed the precompiled maximum of %d",
                           arg, DEFAULT_LIMIT_REQUEST_LINE);
d3103 1
a3103 1
                                           char *arg)
d3106 1
a3106 1
                                           NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
d3110 1
a3110 1
        return err;
d3114 3
a3116 3
        return ap_pstrcat(cmd->temp_pool, "LimitRequestFieldsize \"", arg,
                          "\" must be a non-negative integer (0 = no limit)",
                          NULL);
d3119 3
a3121 3
        return ap_psprintf(cmd->temp_pool, "LimitRequestFieldsize \"%s\" "
                          "must not exceed the precompiled maximum of %d",
                           arg, DEFAULT_LIMIT_REQUEST_FIELDSIZE);
d3130 1
a3130 1
                                           NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
d3134 1
a3134 1
        return err;
d3138 3
a3140 3
        return ap_pstrcat(cmd->temp_pool, "LimitRequestFields \"", arg,
                          "\" must be a non-negative integer (0 = no limit)",
                          NULL);
d3147 1
a3147 1
                                      char *arg)
d3151 1
a3151 1
        return err;
d3164 1
a3164 1
                                                char *arg)
d3167 1
a3167 1
        d->script_interpreter_source = INTERPRETER_SOURCE_REGISTRY;
d3169 1
a3169 1
        d->script_interpreter_source = INTERPRETER_SOURCE_SHEBANG;
d3171 3
a3173 3
        return ap_pstrcat(cmd->temp_pool, "ScriptInterpreterSource \"", arg,
                          "\" must be \"registry\" or \"script\"",
                          NULL);
d3180 2
a3181 2
                                              void *mconfig,
                                              int arg)
d3206 1
a3206 1
        conv_val = conv_On;
d3208 1
a3208 1
        conv_val = conv_Off;
d3210 1
a3210 1
        return NULL;
d3214 5
a3218 5
        !(in = (strcasecmp(arg, "In") == 0)) &&
        !(out = (strcasecmp(arg, "Out") == 0)) &&
        !(inout = (strcasecmp(arg, "InOut") == 0))) {
        /* Invalid string, not conforming to syntax! */
        return NULL;
d3238 1
a3238 1
        return "Invalid syntax: use EBCDICConvert {On|Off}[={In|Out|InOut}] ext [...]";
d3241 1
a3241 1
        ++ext;
d3264 1
a3264 1
        return "Invalid syntax: use EBCDICConvertByType {On|Off}[={In|Out|InOut}] mimetype [...]";
d3310 1
a3310 1
                                 const char *args_p)
d3327 85
a3411 85
        action = '*';
        bit = ETAG_UNSET;
        valid = 1;
        token = ap_getword_conf(cmd->pool, &args);
        if ((*token == '+') || (*token == '-')) {
            action = *token;
            token++;
        }
        else {
            /*
             * The occurrence of an absolute setting wipes
             * out any previous relative ones.  The first such
             * occurrence forgets any inherited ones, too.
             */
            if (first) {
                cfg->etag_bits = ETAG_UNSET;
                cfg->etag_add = ETAG_UNSET;
                cfg->etag_remove = ETAG_UNSET;
                first = 0;
            }
        }

        if (strcasecmp(token, "None") == 0) {
            if (action != '*') {
                valid = 0;
            }
            else {
                cfg->etag_bits = bit = ETAG_NONE;
                explicit = 1;
            }
        }
        else if (strcasecmp(token, "All") == 0) {
            if (action != '*') {
                valid = 0;
            }
            else {
                explicit = 1;
                cfg->etag_bits = bit = ETAG_ALL;
            }
        }
        else if (strcasecmp(token, "Size") == 0) {
            bit = ETAG_SIZE;
        }
        else if ((strcasecmp(token, "LMTime") == 0)
                 || (strcasecmp(token, "MTime") == 0)
                 || (strcasecmp(token, "LastModified") == 0)) {
            bit = ETAG_MTIME;
        }
        else if (strcasecmp(token, "INode") == 0) {
            bit = ETAG_INODE;
        }
        else {
            return ap_pstrcat(cmd->pool, "Unknown keyword '",
                              token, "' for ", cmd->cmd->name,
                              " directive", NULL);
        }

        if (! valid) {
            return ap_pstrcat(cmd->pool, cmd->cmd->name, " keyword '",
                              token, "' cannot be used with '+' or '-'",
                              NULL);
        }

        if (action == '+') {
            /*
             * Make sure it's in the 'add' list and absent from the
             * 'subtract' list.
             */
            cfg->etag_add |= bit;
            cfg->etag_remove &= (~ bit);
        }
        else if (action == '-') {
            cfg->etag_remove |= bit;
            cfg->etag_add &= (~ bit);
        }
        else {
            /*
             * Non-relative values wipe out any + or - values
             * accumulated so far.
             */
            cfg->etag_bits |= bit;
            cfg->etag_add = ETAG_UNSET;
            cfg->etag_remove = ETAG_UNSET;
            explicit = 1;
        }
d3419 1
a3419 1
        cfg->etag_add &= (~ ETAG_UNSET);
d3422 1
a3422 1
        cfg->etag_remove &= (~ ETAG_UNSET);
d3425 4
a3428 4
        cfg->etag_bits &= (~ ETAG_UNSET);
        if ((cfg->etag_bits & ETAG_NONE) != ETAG_NONE) {
            cfg->etag_bits &= (~ ETAG_NONE);
        }
d3434 1
a3434 1
                                       const char *arg1, const char *arg2)
d3437 1
a3437 1
                                                    &core_module);
d3441 1
a3441 1
        return "The redirect recursion limit cannot be less than zero.";
d3444 3
a3446 3
        ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
                     "Limiting internal redirects to very low numbers may "
                     "cause normal requests to fail.");
d3452 1
a3452 1
        limit = atoi(arg2);
d3454 8
a3461 8
        if (limit < 0) {
            return "The subrequest recursion limit cannot be less than zero.";
        }
        if (limit && limit < 4) {
            ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
                         "Limiting the subrequest depth to a very low level may"
                         " cause normal requests to fail.");
        }
d3475 1
a3475 1
                  "r->uri = %s", r->uri ? r->uri : "(unexpectedly NULL)");
d3478 13
a3490 13
        if (top->prev) {
            top = top->prev;
            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                          "redirected from r->uri = %s",
                          top->uri ? top->uri : "(unexpectedly NULL)");
        }

        if (!top->prev && top->main) {
            top = top->main;
            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                          "subrequested from r->uri = %s",
                          top->uri ? top->uri : "(unexpectedly NULL)");
        }
d3500 1
a3500 1
                                                    &core_module);
d3504 2
a3505 2
                 ? conf->redirect_limit
                 : AP_DEFAULT_MAX_INTERNAL_REDIRECTS;
d3507 2
a3508 2
                 ? conf->subreq_limit
                 : AP_DEFAULT_MAX_SUBREQ_DEPTH;
d3512 1
a3512 1
        return 0;
d3516 9
a3524 36
        if (top->prev) {
            if (rlimit && ++redirects >= rlimit) {
                /* uuh, too much. */
                ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
                              "Request exceeded the limit of %d internal "
                              "redirects due to probable configuration error. "
                              "Use 'LimitInternalRecursion' to increase the "
                              "limit if necessary. Use 'LogLevel debug' to get "
                              "a backtrace.", rlimit);

                /* post backtrace */
                log_backtrace(r);

                /* return failure */
                return 1;
            }

            top = top->prev;
        }

        if (!top->prev && top->main) {
            if (slimit && ++subreqs >= slimit) {
                /* uuh, too much. */
                ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
                              "Request exceeded the limit of %d subrequest "
                              "nesting levels due to probable confguration "
                              "error. Use 'LimitInternalRecursion' to increase "
                              "the limit if necessary. Use 'LogLevel debug' to "
                              "get a backtrace.", slimit);

                /* post backtrace */
                log_backtrace(r);

                /* return failure */
                return 1;
            }
d3526 29
a3554 2
            top = top->main;
        }
d3892 1
a3892 1
        return HTTP_FORBIDDEN;
d3905 1
a3905 1
        r->filename = ap_pstrcat(r->pool, conf->ap_document_root,
d3910 5
a3914 5
         * Make sure that we do not mess up the translation by adding two
         * /'s in a row.  This happens under windows when the document
         * root ends with a /
         */
        if ((conf->ap_document_root[strlen(conf->ap_document_root)-1] == '/')
d3959 1
a3959 1
        return 0;
d3963 1
a3963 1
        || (strcasecmp(key, content_type) == 0)) {
d3965 2
a3966 2
        ((struct do_mime_match_parms *) rec)->match_found = 1;
        ((struct do_mime_match_parms *) rec)->conv = conv;
d3970 1
a3970 1
               ((((struct do_mime_match_parms *) rec)->direction) == dir_In)
d3972 3
a3974 3
                       ap_psprintf(r->pool, "EBCDICConversionByType %s %s",
                                   conv ? "On" : "Off",
                                   key));
d3977 2
a3978 2
        /* the mime type scan stops at the first  match. */
        return 0;
d4001 1
a4001 1
        /* Step 0: directories result in redirections or in directory listings.
d4005 12
a4016 12
        if (S_ISDIR(r->finfo.st_mode) && dir == dir_Out) {
            conv = conv_valid = 1;
            break;
        }

        /* 1st step: check the binding on file extension. This allows us to
         * override the conversion default based on a specific name.
         * For instance, the following would allow some HTML files
         * to be converted (.html) and others passed unconverted (.ahtml):
         *     AddType text/html .html .ahtml
         *     EBCDICConvert Off .ahtml
         * For uploads, this assumes that the destination file name
d4019 6
a4024 10
         */
        if (r->filename && !ap_is_empty_table(conv_by_ext)) {
            const char *fn = strrchr(r->filename, '/');

            if (fn == NULL)
                fn = r->filename;

            /* Parse filename extension */
            if ((ext = strrchr(fn, '.')) != NULL) {
                ++ext;
d4026 6
a4031 2
                /* Check for Content-Type */
                if ((conversion = ap_table_get(conv_by_ext, ext)) != NULL) {
d4035 1
a4035 1
		        ap_table_setn(r->headers_out,
d4042 18
a4059 18
                    conv = (conversion[0] == conv_On);
                    conv_valid = 1;
                    break;
                }
            }
        }


        /* 2nd step: test for the old "legacy kludge", that is, a default
         * conversion=on for text/?* message/?* multipart/?* and the possibility
         * to override the text/?* conversion with a definition like
         *    AddType text/x-ascii-plain .atxt
         *    AddType text/x-ascii-html  .ahtml
         * where the "x-ascii-" would be removed and the conversion switched
         * off.
         * This step must be performed prior to testing wildcard MIME types
         * like text/?* by the EBCDICConvertByType directive.
         */
d4061 11
a4071 11
        /* This fallback is only used when enabled (default=off) */
        if (conf->x_ascii_magic_kludge) {
            char *magic;

            /* If the mime type of a document is set to
             * "text/x-ascii-anything", it gets changed to
             * "text/anything" here and the conversion is forced to off
             * ("binary" or ASCII documents).
             */
            if (*pType != NULL
                && (magic = strstr(*pType, "/x-ascii-")) != NULL) {
d4081 2
a4082 2
                /* the mime type scan stops at the first  match. */
                magic[1] = '\0';        /* overwrite 'x' */
d4084 2
a4085 2
                /* Fix MIME type: strip out the magic "x-ascii-" substring */
                *pType = ap_pstrcat(r->pool, *pType, &magic[9], NULL);
d4087 1
a4087 1
                magic[1] = 'x'; /* restore 'x' in old string (just in case) */
d4089 6
a4094 6
                /* Switch conversion to BINARY */
                conv = 0;       /* do NOT convert this document */
                conv_valid = 1;
                break;
            }
        }
d4098 6
a4103 6
        /* 3rd step: check whether a generic conversion was defined for a MIME type,
         * like in
         *    EBCDICConvertByType  On  model/vrml application/postscript text/?*
         */
        if (!ap_is_empty_table(conv_by_type)) {
            struct do_mime_match_parms do_par;
d4105 2
a4106 2
            do_par.request = r;
            do_par.direction = dir;
d4109 1
a4109 1
            ap_table_do(do_mime_match, (void *) &do_par, conv_by_type, NULL);
d4111 20
a4130 20
            if ((conv_valid = do_par.match_found) != 0) {
                conv = do_par.conv;
                break;
            }
        }
        else /* If no conversion by type was configured, use the default: */
        {
            /*
             * As a final step, mime types starting with "text/", "message/" or
             * "multipart/" imply a conversion, while all the rest is
             * delivered unconverted (i.e., binary, e.g. application/octet-stream).
             */

            /* If no content type is set then treat it as text (conversion=on) */
            conv =
                (type == NULL) ||
                (strncasecmp(type, "text/", 5) == 0) ||
                (strncasecmp(type, "message/", 8) == 0) ||
                (strncasecmp(type, "multipart/", 10) == 0) ||
                (strcasecmp(type, "application/x-www-form-urlencoded") == 0);
d4141 3
a4143 3
            conv_valid = 1;
            break;
        }
d4147 4
a4150 4
        if (dir == dir_In)
            r->ebcdic.conv_in = conv;
        else
            r->ebcdic.conv_out = conv;
d4163 1
a4163 1
        return r->ebcdic.conv_in;
d4194 3
a4196 3
        ap_log_error(APLOG_MARK, APLOG_ERR, NULL,
                     "Failed to munmap memory of length %ld at 0x%lx",
                     (long) mmd->length, (long) mmd->mm);
d4223 1
a4223 1
        return errstatus;
d4235 1
a4235 1
        return ap_send_http_options(r);
d4238 1
a4238 1
        return METHOD_NOT_ALLOWED;
d4249 1
a4249 1
        return METHOD_NOT_ALLOWED;
d4260 1
a4260 1
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
d4262 1
a4262 1
        return FORBIDDEN;
d4271 1
a4271 1
        return errstatus;
d4280 1
a4280 1
 	 * file mmapped */
@


1.10
log
@even more sync with old work
@
text
@d1 2
a2 2
/* $MirBSD: src/usr.sbin/httpd/src/main/http_core.c,v 1.8 2004/07/15 19:11:02 tg Exp $ */
/* $OpenBSD: http_core.c,v 1.16 2003/11/17 18:57:05 henning Exp $ */
@


1.9
log
@update to an older version of my httpd work
@
text
@@


1.8
log
@merge... attempt I (I hate ASF httpd)
@
text
@d1 1
a1 1
/* $MirBSD: src/usr.sbin/httpd/src/main/http_core.c,v 1.7 2003/12/27 00:31:47 tg Exp $ */
d162 1
a162 1
  
d172 1
a172 1
    
d205 1
a205 1
    
d263 1
a263 1
#ifdef RLIMIT_NPROC    
d342 1
a342 1
  
d397 1
a397 1
    
d406 1
a406 1
    
d413 1
a413 1
    
d529 2
a530 2
    core_dir_config *conf = 
      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module); 
d532 2
a533 2
    return conf->opts; 
} 
d535 2
a536 2
API_EXPORT(int) ap_allow_overrides(request_rec *r) 
{ 
d539 1
a539 1
						   &core_module); 
d541 2
a542 2
    return conf->override; 
} 
d549 1
a549 1
						   &core_module); 
d558 1
a558 1
						   &core_module); 
d580 2
a581 2
           (void *)&((r->connection->local_addr).sin_addr ),
           (void *)ap_user_name,
d592 3
a594 3
						   &core_module); 
    return conf->ap_default_type 
               ? conf->ap_default_type 
d603 1
a603 1
						      &core_module); 
d612 1
a612 1
						   &core_module); 
d640 1
a640 1
                                                          &core_module); 
d765 1
a765 1
	   
d878 1
a878 1
    unsigned cport = ntohs(r->connection->local_addr.sin_port);
d881 1
a881 1
    
d884 1
a884 1
        
d889 1
a889 1
        port = r->parsed_uri.port_str ? r->parsed_uri.port : 
d894 1
a894 1
        port = r->server->port ? r->server->port : 
d919 1
a919 1
    
d924 1
a924 1
static char* get_interpreter_from_win32_registry(pool *p, const char* ext) 
d939 1
a939 1
    /* 
d948 1
a948 1
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, keyName, 0, KEY_QUERY_VALUE, 
d951 1
a951 1
    if (result != ERROR_SUCCESS) 
d971 1
a971 1
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, keyName, 0, KEY_QUERY_VALUE, 
d1005 1
a1005 1
     * The canonical way shell command entries are entered in the Win32 
d1013 1
a1013 1
     *   "%1" - Place holder for file to run the shell against. 
d1026 1
a1026 1
API_EXPORT (file_type_e) ap_get_win32_interpreter(const  request_rec *r, 
d1039 1
a1039 1
    d = (core_dir_config *)ap_get_module_config(r->per_dir_config, 
d1055 1
a1055 1
    if (ext && (!strcasecmp(ext,".bat") || !strcasecmp(ext,".cmd"))) 
d1061 1
a1061 1
        if ((p - shellcmd >= 11) && !strcasecmp(p - 11, "command.com")) 
d1094 1
a1094 1
    }        
d1102 1
a1102 1
    bResult = ReadFile(hFile, (void*) &buffer, sizeof(buffer) - 1, 
d1126 1
a1126 1
        *interpreter = ap_pstrdup(r->pool, buffer + i ); 
d1130 1
a1130 1
        IMAGE_DOS_HEADER *hdr = (IMAGE_DOS_HEADER*)buffer;    
d1185 1
a1185 1
    
d1188 1
a1188 1
	     || cmd->end_token == end_directorymatch_section)) 
d1191 1
a1191 1
		|| cmd->end_token == end_locationmatch_section)) 
d1235 1
a1235 1
static const char *set_add_default_charset(cmd_parms *cmd, 
d1264 1
a1264 1
  
a1291 1
    ap_server_strip_chroot(reqconf->d, 0);
d1297 1
a1297 1
    
d1299 1
a1299 1
        reqconf->response_code_strings = 
d1301 1
a1301 1
                       sizeof(reqconf->response_code_strings) * 
d1307 2
a1308 2
    reqconf->response_code_strings[idx] = 
       ((ap_is_url(string) || (*string == '/')) && (*string != '"')) ? 
d1317 1
a1317 1
                
d1326 1
a1326 1
  
d1355 1
a1355 1
    }   
d1373 1
a1373 1
  
d1430 1
a1430 1
	    
d1501 1
a1501 1
  
d1517 1
a1517 1
  
d1527 1
a1527 1
    
d1558 1
a1558 1
    
d1577 1
a1577 1
/* We use this in <DirectoryMatch> and <FilesMatch>, to ensure that 
d1591 1
a1591 1
			  " without matching <", cmd->cmd->name + 2, 
d1675 2
a1676 2
    if (errmsg != (thiscmd->cmd_data 
		       ? end_directorymatch_section 
d1743 2
a1744 2
    if (errmsg != (thiscmd->cmd_data 
		       ? end_locationmatch_section 
d1755 1
a1755 1
    
d1819 2
a1820 2
    if (errmsg != (thiscmd->cmd_data 
		       ? end_filesmatch_section 
d1908 1
a1908 1
static const char *end_ifdefine(cmd_parms *cmd, void *dummy) 
d1974 1
a1974 1
    
d1983 1
a1983 1
    
d2012 1
a2012 1
    
d2055 1
a2055 1
	return ap_pstrcat(cmd->pool, "Cannot add module via name '", arg, 
d2076 1
a2076 1
  
d2079 2
a2080 2
    
    const char *err = ap_check_cmd_context(cmd, 
d2120 1
a2120 1
	return ap_pstrcat(cmd->temp_pool, "The port number \"", arg, 
d2128 1
a2128 1
static const char *set_signature_flag(cmd_parms *cmd, core_dir_config *d, 
d2182 1
a2182 1
     */ 
d2264 1
a2264 1
static const char *set_server_root(cmd_parms *cmd, void *dummy, char *arg) 
d2280 1
a2280 1
     * already chrooted into that. 
d2320 1
a2320 1
static const char *set_keep_alive(cmd_parms *cmd, void *dummy, char *arg) 
d2339 1
a2339 1
static const char *set_keep_alive_max(cmd_parms *cmd, void *dummy, char *arg) 
d2351 1
a2351 1
static const char *set_exception_hook(cmd_parms *cmd, void *dummy, char *arg) 
d2376 1
a2376 1
static const char *set_pidfile(cmd_parms *cmd, void *dummy, char *arg) 
d2390 1
a2390 1
static const char *set_scoreboard(cmd_parms *cmd, void *dummy, char *arg) 
d2401 1
a2401 1
static const char *set_lockfile(cmd_parms *cmd, void *dummy, char *arg) 
d2412 1
a2412 1
static const char *set_idcheck(cmd_parms *cmd, core_dir_config *d, int arg) 
d2446 1
a2446 1
static const char *set_serverpath(cmd_parms *cmd, void *dummy, char *arg) 
d2469 1
a2469 1
static const char *set_use_canonical_name(cmd_parms *cmd, core_dir_config *d, 
d2492 1
a2492 1
static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy, char *arg) 
d2523 1
a2523 1
       
d2538 1
a2538 1
static const char *set_server_limit (cmd_parms *cmd, void *dummy, char *arg) 
d2553 1
a2553 1
    } 
d2561 1
a2561 1
static const char *set_max_requests(cmd_parms *cmd, void *dummy, char *arg) 
d2586 1
a2586 1
    } 
d2595 1
a2595 1
static const char *set_excess_requests(cmd_parms *cmd, void *dummy, char *arg) 
d2639 1
a2639 1
    
d2663 1
a2663 1
#if !defined (RLIMIT_CPU) || defined (RLIMIT_TIME) || !(defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)) || !defined (RLIMIT_NPROC)
d2674 1
a2674 1
static const char *set_limit_cpu(cmd_parms *cmd, core_dir_config *conf, 
d2692 1
a2692 1
static const char *set_limit_mem(cmd_parms *cmd, core_dir_config *conf, 
d2707 1
a2707 1
static const char *set_limit_nproc(cmd_parms *cmd, core_dir_config *conf,  
d2715 1
a2715 1
static const char *set_bind_address(cmd_parms *cmd, void *dummy, char *arg) 
a2716 1
    struct addrinfo hints, *res;
a2718 1
    int error;
d2744 2
a2745 2
    
    ap_thread_stack_size = atoi(stacksize);    
d2771 1
a2771 1
    
d2836 1
a2836 1
static const char *set_listenbacklog(cmd_parms *cmd, void *dummy, char *arg) 
d2853 1
a2853 1
static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, char *arg) 
d2863 1
a2863 1
	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", arg, 
d2874 1
a2874 1
    
d2880 1
a2880 1
static const char *set_loglevel(cmd_parms *cmd, void *dummy, const char *arg) 
d2883 1
a2883 1
    
d3003 1
a3003 1
                                              core_dir_config *d, int arg) 
d3015 1
a3015 1
                                              core_dir_config *d, int arg) 
d3033 1
a3033 1
static const char *set_serv_tokens(cmd_parms *cmd, void *dummy, char *arg) 
d3070 1
a3070 1
        return ap_pstrcat(cmd->temp_pool, "LimitRequestLine \"", arg, 
d3094 1
a3094 1
        return ap_pstrcat(cmd->temp_pool, "LimitRequestFieldsize \"", arg, 
d3118 1
a3118 1
        return ap_pstrcat(cmd->temp_pool, "LimitRequestFields \"", arg, 
d3127 1
a3127 1
                                      char *arg) 
d3151 1
a3151 1
        return ap_pstrcat(cmd->temp_pool, "ScriptInterpreterSource \"", arg, 
d3541 1
a3541 1
/* Note --- ErrorDocument will now work from .htaccess files.  
d3610 1
a3610 1
  "access policy if both allow and require used ('all' or 'any')" },    
d3615 1
a3615 1
{ "AddDefaultCharset", set_add_default_charset, NULL, OR_FILEINFO, 
d3619 1
a3619 1
  
d3744 1
a3744 1
{ "ClearModuleList", clear_module_list_command, NULL, RSRC_CONF, NO_ARGS, 
d3801 1
a3801 1
  "Serialized Accept Mutex; the methods " 
d3803 1
a3803 1
    "'uslock' "                           
d3870 1
a3870 1
  
d3879 2
a3880 2
    
    if (r->server->path 
d4231 1
a4231 1
	
d4244 1
a4244 1
	
d4291 1
a4291 1
	
d4328 1
a4328 1
	    
d4337 1
a4337 1
	
@


1.7
log
@finish merging and sync a bit; bump version etc.
@
text
@d1 1
a1 1
/* $MirBSD: http_core.c,v 1.6 2003/10/29 15:29:28 tg Exp $ */
d4 1
a4 2
/* ====================================================================
 * The Apache Software License, Version 1.1
d6 3
a8 2
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
d10 1
a10 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d12 5
a16 46
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d60 9
d212 3
d562 25
d633 14
a646 1
    core_dir_config *conf;
d648 3
a650 2
    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
						   &core_module); 
d652 1
a652 1
    if (conf->response_code_strings == NULL) {
d655 2
a656 1
    return conf->response_code_strings[error_index];
d878 1
d882 16
a897 1
    port = r->server->port ? r->server->port : ap_default_port(r);
d899 2
a900 9
    if (d->use_canonical_name == USE_CANONICAL_NAME_OFF
	|| d->use_canonical_name == USE_CANONICAL_NAME_DNS) {
        return r->hostname
	    ?  ntohs(((struct sockaddr_in *)&r->connection->local_addr)->sin_port)
	    : port;
    }
    return r->hostname
	? ntohs(((struct sockaddr_in *)&r->connection->local_addr)->sin_port)
	: port;
d1288 2
a1289 2
    core_dir_config *conf = 
	ap_get_module_config(r->per_dir_config, &core_module);
d1292 9
a1300 3
    ap_server_strip_chroot(conf->d, 0);
    if(conf->response_code_strings == NULL) {
        conf->response_code_strings = 
d1302 2
a1303 2
		    sizeof(*conf->response_code_strings) * 
		    RESPONSE_CODES);
d1308 1
a1308 1
    conf->response_code_strings[idx] = 
d2351 26
d2870 1
d2971 22
d3607 3
d3834 4
@


1.6
log
@* merge Apache HTTPD 1.3.29
* the usual
  - nuke whitespace at end of line
  - nuke whitespace at end of file
  - nuke character 0x60
  in areas being revisited
* convert	/*<tab>$MirBSD...<tab>*/
  to		/*<space>$MirBSD...<space>*/
  in areas being revisited
* sort list of files in Makefile.bsd-wrapper
* nuke unused files
@
text
@d1 2
a2 2
/* $MirBSD: http_core.c,v 1.5 2003/08/31 20:55:28 tg Exp $ */
/* $OpenBSD: http_core.c,v 1.15 2003/08/21 13:11:35 henning Exp $ */
@


1.5
log
@Merge import of OpenBSD source, ports and XF4 tree.

While here,
o clean up differences where possible
o whitespace cleanup
o ifdef ./. if defined()
o '...' ./. "..."
o echo foo > bar ./. echo foo >bar
o `...` ./. $(...) ./. $$(...)
o `...' ./. '...'
o modernize "our" tree, e.g. WWW in ports
o fix some typos and brainos introduced when renaming OpenBSD to MirBSD
o use hardware 80387 by default
o migrate Apache 1.3.28 OpenBSD ./. MirBSD ./. KAME
o work around as many CVS bugs as possible (add back/delete files, ...)

Synchronize stuff, ready for ongoing changes.
@
text
@d1 1
a1 1
/* $MirBSD: http_core.c,v 1.4 2003/07/19 16:11:37 tg Exp $ */
d1322 1
a1322 1
		     "cannot use a full or relative URL in a 401 ErrorDocument "
@


1.4
log
@o Update to Apache 1.3.28
o Retain OpenBSD changes
o Retain IPv6 changes
o Retain local (MirBSD) changes
o Remove some unused files
  o SSL stuff is in src/etc/ssl.certs.shar
  o SSL demonstration stuff is not needed
  o Windows, Novell Netware, OS/2, Cygwin, etc.
@
text
@d1 2
a2 2
/* $MirBSD: http_core.c,v 1.3 2003/06/20 11:26:18 tg Exp $ */
/* $OpenBSD: http_core.c,v 1.14 2002/10/07 20:23:06 henning Exp $ */
@


1.3
log
@improve [X]HTML standards compliance of the server signature:
lowercase HTML tags
@
text
@d1 1
a1 1
/* $MirBSD: http_core.c,v 1.2 2003/03/23 19:57:36 tg Exp $ */
d7 1
a7 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d382 6
a387 1
    
d408 8
d1322 1
a1322 1
		     "cannot use a full URL in a 401 ErrorDocument "
d3343 128
d3777 4
@


1.2
log
@merge obsd.httpd
@
text
@d1 1
a1 1
/*	$MirBSD: obsd.httpd,v 1.27 2003/03/22 22:33:25 tg Exp $	*/
d2881 2
a2882 2
	return ap_pstrcat(r->pool, prefix, "<ADDRESS>" SERVER_BASEVERSION
			  " Server at <A HREF=\"mailto:",
d2885 2
a2886 2
                          "</A> Port ", sport,
			  "</ADDRESS>\n", NULL);
d2888 1
a2888 1
    return ap_pstrcat(r->pool, prefix, "<ADDRESS>" SERVER_BASEVERSION
d2892 1
a2892 1
		      "</ADDRESS>\n", NULL);
@


1.1
log
@Initial revision
@
text
@d1 1
d77 1
d148 3
d284 5
d654 3
a656 1
    struct hostent *hptr;
d668 33
a700 10
    hptr = gethostbyname(conn->remote_host);
    if (hptr) {
	char **haddr;

	for (haddr = hptr->h_addr_list; *haddr; haddr++) {
	    if (((struct in_addr *)(*haddr))->s_addr
		== conn->remote_addr.sin_addr.s_addr) {
		conn->double_reverse = 1;
		return;
	    }
d703 2
a704 3
    conn->double_reverse = -1;
    /* invalidate possible reverse-resolved hostname if forward lookup fails */
    conn->remote_host = "";
a709 2
    struct in_addr *iaddr;
    struct hostent *hptr;
d712 1
d734 8
a741 4
	iaddr = &(conn->remote_addr.sin_addr);
	hptr = gethostbyaddr((char *)iaddr, sizeof(struct in_addr), AF_INET);
	if (hptr != NULL) {
	    conn->remote_host = ap_pstrdup(conn->pool, (void *)hptr->h_name);
d819 1
a828 2
	    struct in_addr *iaddr;
	    struct hostent *hptr;
d832 11
a842 11
	    iaddr = &(conn->local_addr.sin_addr);
	    hptr = gethostbyaddr((char *)iaddr, sizeof(struct in_addr),
				 AF_INET);
	    if (hptr != NULL) {
	        conn->local_host = ap_pstrdup(conn->pool,
					      (void *)hptr->h_name);
		ap_str_tolower(conn->local_host);
	    }
	    else {
	        conn->local_host = ap_pstrdup(conn->pool,
					      r->server->server_hostname);
d844 1
d863 7
a869 5
        return r->hostname ? ntohs(r->connection->local_addr.sin_port)
			   : port;
    }
    /* default */
    return port;
d2545 1
a2545 1
#if defined(RLIMIT_CPU) || defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_NPROC) || defined(RLIMIT_AS)
d2601 1
a2601 1
#if !defined (RLIMIT_CPU) || !(defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)) || !defined (RLIMIT_NPROC)
d2620 9
d2655 4
d2664 10
a2673 1
    ap_bind_address.s_addr = ap_get_virthost_addr(arg, NULL);
d2705 1
a2705 1
static const char *set_listener(cmd_parms *cmd, void *dummy, char *ips)
d2708 3
a2710 2
    char *ports;
    unsigned short port;
d2717 16
a2732 4
    ports = strchr(ips, ':');
    if (ports != NULL) {
	if (ports == ips) {
	    return "Missing IP address";
d2734 3
a2736 4
	else if (ports[1] == '\0') {
	    return "Address must end in :<port-number>";
	}
	*(ports++) = '\0';
d2738 27
a2764 2
    else {
	ports = ips;
d2767 2
a2768 13
    new=ap_pcalloc(cmd->pool, sizeof(listen_rec));
    new->local_addr.sin_family = AF_INET;
    if (ports == ips) { /* no address */
	new->local_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    }
    else {
	new->local_addr.sin_addr.s_addr = ap_get_virthost_addr(ips, NULL);
    }
    port = atoi(ports);
    if (!port) {
	return "Port must be numeric";
    }
    new->local_addr.sin_port = htons(port);
d3497 7
d3524 1
a3524 1
{ "Listen", set_listener, NULL, RSRC_CONF, TAKE1,
d3558 1
a3558 1
{ "NameVirtualHost", ap_set_name_virtual_host, NULL, RSRC_CONF, TAKE1,
@


1.1.8.1
log
@Import Apache HTTPD 1.3.28 into vendor branch to ease update
@
text
@d1 2
d6 1
a6 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d354 1
d372 1
a372 6

    /* recursion stopper */
    conf->redirect_limit = 0;
    conf->subreq_limit = 0;
    conf->recursion_limit_set = 0;

a392 8
    conf->redirect_limit = virt->recursion_limit_set
                           ? virt->redirect_limit
                           : base->redirect_limit;

    conf->subreq_limit = virt->recursion_limit_set
                         ? virt->subreq_limit
                         : base->subreq_limit;

d1211 1
a1211 1
    
d1222 1
d1270 1
a1270 1
		     "cannot use a full or relative URL in a 401 ErrorDocument "
d1565 1
d1573 1
d1648 1
d1656 1
d1718 1
d1729 1
d2103 6
d2110 5
a2114 2
	ap_user_name = arg;
	cmd->server->server_uid = ap_user_id = ap_uname2id(arg);
d2118 8
a2125 1
	    cmd->server->server_uid = ap_uname2id(arg);
d2162 4
a2165 1
	cmd->server->server_gid = ap_group_id = ap_gname2id(arg);
d2169 8
a2176 1
	    cmd->server->server_gid = ap_gname2id(arg);
d2199 19
a2217 2
    if (!ap_is_directory(arg)) {
        return "ServerRoot must be a valid directory";
a2218 5
    /* ServerRoot is never '/' terminated */
    while (strlen(ap_server_root) > 1 && ap_server_root[strlen(ap_server_root)-1] == '/')
        ap_server_root[strlen(ap_server_root)-1] = '\0';
    ap_cpystrn(ap_server_root, arg,
	       sizeof(ap_server_root));
d2647 2
a2648 2
    char *ports, *endptr;
    long port;
d2677 3
a2679 7
    errno = 0; /* clear errno before calling strtol */
    port = ap_strtol(ports, &endptr, 10);
    if (errno /* some sort of error */
       || (endptr && *endptr) /* make sure no trailing characters */
       || port < 1 || port > 65535) /* underflow/overflow */
    {
	return "Missing, invalid, or non-numeric port";
d2681 1
a2681 1
    new->local_addr.sin_port = htons((unsigned short)port);
d2797 2
a2798 2
			  ap_escape_html(r->pool, ap_get_server_name(r)), 
			  "</A> Port ", sport,
d2802 3
a2804 3
		      " Server at ", 
		      ap_escape_html(r->pool, ap_get_server_name(r)), 
		      " Port ", sport,
a3242 128
static const char *set_recursion_limit(cmd_parms *cmd, void *dummy,
                                       const char *arg1, const char *arg2)
{
    core_server_config *conf = ap_get_module_config(cmd->server->module_config,
                                                    &core_module);
    int limit = atoi(arg1);

    if (limit < 0) {
        return "The redirect recursion limit cannot be less than zero.";
    }
    if (limit && limit < 4) {
        ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
                     "Limiting internal redirects to very low numbers may "
                     "cause normal requests to fail.");
    }

    conf->redirect_limit = limit;

    if (arg2) {
        limit = atoi(arg2);

        if (limit < 0) {
            return "The subrequest recursion limit cannot be less than zero.";
        }
        if (limit && limit < 4) {
            ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
                         "Limiting the subrequest depth to a very low level may"
                         " cause normal requests to fail.");
        }
    }

    conf->subreq_limit = limit;
    conf->recursion_limit_set = 1;

    return NULL;
}

static void log_backtrace(const request_rec *r)
{
    const request_rec *top = r;

    ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                  "r->uri = %s", r->uri ? r->uri : "(unexpectedly NULL)");

    while (top && (top->prev || top->main)) {
        if (top->prev) {
            top = top->prev;
            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                          "redirected from r->uri = %s",
                          top->uri ? top->uri : "(unexpectedly NULL)");
        }

        if (!top->prev && top->main) {
            top = top->main;
            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                          "subrequested from r->uri = %s",
                          top->uri ? top->uri : "(unexpectedly NULL)");
        }
    }
}

/*
 * check whether redirect limit is reached
 */
API_EXPORT(int) ap_is_recursion_limit_exceeded(const request_rec *r)
{
    core_server_config *conf = ap_get_module_config(r->server->module_config,
                                                    &core_module);
    const request_rec *top = r;
    int redirects = 0, subreqs = 0;
    int rlimit = conf->recursion_limit_set
                 ? conf->redirect_limit
                 : AP_DEFAULT_MAX_INTERNAL_REDIRECTS;
    int slimit = conf->recursion_limit_set
                 ? conf->subreq_limit
                 : AP_DEFAULT_MAX_SUBREQ_DEPTH;

    /* fast exit (unlimited) */
    if (!rlimit && !slimit) {
        return 0;
    }

    while (top->prev || top->main) {
        if (top->prev) {
            if (rlimit && ++redirects >= rlimit) {
                /* uuh, too much. */
                ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
                              "Request exceeded the limit of %d internal "
                              "redirects due to probable configuration error. "
                              "Use 'LimitInternalRecursion' to increase the "
                              "limit if necessary. Use 'LogLevel debug' to get "
                              "a backtrace.", rlimit);

                /* post backtrace */
                log_backtrace(r);

                /* return failure */
                return 1;
            }

            top = top->prev;
        }

        if (!top->prev && top->main) {
            if (slimit && ++subreqs >= slimit) {
                /* uuh, too much. */
                ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
                              "Request exceeded the limit of %d subrequest "
                              "nesting levels due to probable confguration "
                              "error. Use 'LimitInternalRecursion' to increase "
                              "the limit if necessary. Use 'LogLevel debug' to "
                              "get a backtrace.", slimit);

                /* post backtrace */
                log_backtrace(r);

                /* return failure */
                return 1;
            }

            top = top->main;
        }
    }

    /* recursion state: ok */
    return 0;
}

a3541 4

{ "LimitInternalRecursion", set_recursion_limit, NULL, RSRC_CONF, TAKE12,
  "maximum recursion depth of internal redirects and subrequests"},

@


1.1.8.2
log
@Import the new Apache HTTPD 1.3.29 as seen on slashdot
@
text
@d1279 1
a1279 1
		     "cannot use a full URL in a 401 ErrorDocument "
@


1.1.8.3
log
@The Apache(TM) Webserver, version 1.3.31
@
text
@d1 2
a2 1
/* Copyright 1999-2004 The Apache Software Foundation
d4 2
a5 3
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
d7 3
a9 1
 *     http://www.apache.org/licenses/LICENSE-2.0
d11 46
a56 5
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
a98 9
typedef struct {
    /* Custom response strings registered via ap_custom_response(),
     * or NULL; check per-dir config if nothing found here
     */
    char **response_code_strings; /* from ap_custom_response(), not from
                                   * ErrorDocument
                                   */
} core_request_config;

a238 3
    if (new->ap_auth_nonce) {
        conf->ap_auth_nonce = new->ap_auth_nonce;
    }
a579 25
API_EXPORT(const char *) ap_auth_nonce(request_rec *r)
{
    core_dir_config *conf;
    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
                                                   &core_module);
    if (conf->ap_auth_nonce)
       return conf->ap_auth_nonce;

    /* Ideally we'd want to mix in some per-directory style
     * information; as we are likely to want to detect replay
     * across those boundaries and some randomness. But that
     * is harder due to the adhoc nature of .htaccess memory
     * structures, restarts and forks.
     *
     * But then again - you should use AuthDigestRealmSeed in your config
     * file if you care. So the adhoc value should do.
     */
    return ap_psprintf(r->pool,"%pp%pp%pp%pp%pp",
           (void *)&((r->connection->local_addr).sin_addr ),
           (void *)ap_user_name,
           (void *)ap_listeners,
           (void *)ap_server_argv0,
           (void *)ap_pid_fname);
}

d626 1
a626 2
    core_request_config *reqconf;
    core_dir_config *dirconf;
d628 2
a629 11
    /* prefer per-request settings, which are created by calls to
     * ap_custom_response()
     */
    reqconf = (core_request_config *)ap_get_module_config(r->request_config,
                                                          &core_module); 

    if (reqconf != NULL &&
        reqconf->response_code_strings != NULL &&
        reqconf->response_code_strings[error_index] != NULL) {
        return reqconf->response_code_strings[error_index];
    }
d631 1
a631 5
    /* check for string specified via ErrorDocument */
    dirconf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
                                                      &core_module);

    if (dirconf->response_code_strings == NULL) {
d634 1
a634 2

    return dirconf->response_code_strings[error_index];
a828 1
    unsigned cport = ntohs(r->connection->local_addr.sin_port);
d832 2
d835 3
a837 14
        || d->use_canonical_name == USE_CANONICAL_NAME_DNS) {
        
        /* With UseCanonicalName Off Apache will form self-referential
         * URLs using the hostname and port supplied by the client if
         * any are supplied (otherwise it will use the canonical name).
         */
        port = r->parsed_uri.port_str ? r->parsed_uri.port : 
          cport ? cport :
            r->server->port ? r->server->port :
              ap_default_port(r);
    } else { /* d->use_canonical_name == USE_CANONICAL_NAME_ON */
        port = r->server->port ? r->server->port : 
          cport ? cport :
            ap_default_port(r);
a838 1

d1228 2
a1229 2
    core_request_config *reqconf =
	ap_get_module_config(r->request_config, &core_module);
d1232 2
a1233 8
    if (reqconf == NULL) {
        reqconf = (core_request_config *)ap_pcalloc(r->pool,
                                                    sizeof(core_request_config));
        ap_set_module_config(r->request_config, &core_module, reqconf);
    }
    
    if (reqconf->response_code_strings == NULL) {
        reqconf->response_code_strings = 
d1235 2
a1236 2
                       sizeof(reqconf->response_code_strings) * 
                       RESPONSE_CODES);
d1241 1
a1241 1
    reqconf->response_code_strings[idx] = 
a2239 26
#ifdef AP_ENABLE_EXCEPTION_HOOK
static const char *set_exception_hook(cmd_parms *cmd, void *dummy, char *arg) 
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    if (cmd->server->is_virtual) {
	return "EnableExceptionHook directive not allowed in <VirtualHost>";
    }

    if (strcasecmp(arg, "on") == 0) {
        ap_exception_hook_enabled = 1;
    }
    else if (strcasecmp(arg, "off") == 0) {
        ap_exception_hook_enabled = 0;
    }
    else {
        return "parameter must be 'on' or 'off'";
    }

    return NULL;
}
#endif /* AP_ENABLE_EXCEPTION_HOOK */

a2688 1
    ap_coredump_dir_configured = 1;
a2788 22
/*
 * Load an authorisation nonce into our location configuration, and
 * force it to be in the 0-9/A-Z realm.
 */
static const char *set_authnonce (cmd_parms *cmd, void *mconfig, char *word1)
{
    core_dir_config *aconfig = (core_dir_config *)mconfig;
    size_t i;

    aconfig->ap_auth_nonce = ap_escape_quotes(cmd->pool, word1);

    if (strlen(aconfig->ap_auth_nonce) > 510)
       return "AuthDigestRealmSeed length limited to 510 chars for browser compatibility";

    for(i=0;i<strlen(aconfig->ap_auth_nonce );i++)
       if (!ap_isalnum(aconfig->ap_auth_nonce [i]))
         return "AuthDigestRealmSeed limited to 0-9 and A-Z range for browser compatibility";

    return NULL;
}


a3402 3
{ "AuthDigestRealmSeed", set_authnonce, NULL, OR_AUTHCFG, TAKE1,
  "An authentication token which should be different for each logical realm. "\
  "A random value or the servers IP may be a good choise.\n" },
a3619 4
#ifdef AP_ENABLE_EXCEPTION_HOOK
{ "EnableExceptionHook", set_exception_hook, NULL, RSRC_CONF, TAKE1,
  "Controls whether exception hook may be called after a crash" },
#endif
@


1.1.8.4
log
@Apache(TM) 1.3.33 (no, not 1.3.37 yet)
@
text
@d566 2
a567 2
    return ap_psprintf(r->pool,"%pI%pp%pp%pp%pp",
           &r->connection->local_addr.sin_addr,
a849 1
#ifdef UCN_OFF_HONOR_PHYSICAL_PORT
a850 1
#endif
d1603 1
a1603 4
        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
        if (!r) {
            return "Regex could not be compiled";
        }
d1606 2
a1607 5
        cmd->path = ap_getword_conf(cmd->pool, &arg);
        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
        if (!r) {
            return "Regex could not be compiled";
        }
d1684 1
a1684 4
        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED);
        if (!r) {
            return "Regex could not be compiled";
        }
d1687 2
a1688 5
        cmd->path = ap_getword_conf(cmd->pool, &arg);
        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED);
        if (!r) {
            return "Regex could not be compiled";
        }
a1755 3
        if (!r) {
            return "Regex could not be compiled";
        }
d1758 2
a1759 5
        cmd->path = ap_getword_conf(cmd->pool, &arg);
        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
        if (!r) {
            return "Regex could not be compiled";
        }
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/* $OpenBSD: http_core.c,v 1.15 2003/08/21 13:11:35 henning Exp $ */
d6 1
a6 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d372 1
a372 6

    /* recursion stopper */
    conf->redirect_limit = 0;
    conf->subreq_limit = 0;
    conf->recursion_limit_set = 0;

a392 8
    conf->redirect_limit = virt->recursion_limit_set
                           ? virt->redirect_limit
                           : base->redirect_limit;

    conf->subreq_limit = virt->recursion_limit_set
                         ? virt->subreq_limit
                         : base->subreq_limit;

d1270 1
a1270 1
		     "cannot use a full or relative URL in a 401 ErrorDocument "
d2647 2
a2648 2
    char *ports, *endptr;
    long port;
d2677 3
a2679 7
    errno = 0; /* clear errno before calling strtol */
    port = ap_strtol(ports, &endptr, 10);
    if (errno /* some sort of error */
       || (endptr && *endptr) /* make sure no trailing characters */
       || port < 1 || port > 65535) /* underflow/overflow */
    {
	return "Missing, invalid, or non-numeric port";
d2681 1
a2681 1
    new->local_addr.sin_port = htons((unsigned short)port);
a3242 128
static const char *set_recursion_limit(cmd_parms *cmd, void *dummy,
                                       const char *arg1, const char *arg2)
{
    core_server_config *conf = ap_get_module_config(cmd->server->module_config,
                                                    &core_module);
    int limit = atoi(arg1);

    if (limit < 0) {
        return "The redirect recursion limit cannot be less than zero.";
    }
    if (limit && limit < 4) {
        ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
                     "Limiting internal redirects to very low numbers may "
                     "cause normal requests to fail.");
    }

    conf->redirect_limit = limit;

    if (arg2) {
        limit = atoi(arg2);

        if (limit < 0) {
            return "The subrequest recursion limit cannot be less than zero.";
        }
        if (limit && limit < 4) {
            ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
                         "Limiting the subrequest depth to a very low level may"
                         " cause normal requests to fail.");
        }
    }

    conf->subreq_limit = limit;
    conf->recursion_limit_set = 1;

    return NULL;
}

static void log_backtrace(const request_rec *r)
{
    const request_rec *top = r;

    ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                  "r->uri = %s", r->uri ? r->uri : "(unexpectedly NULL)");

    while (top && (top->prev || top->main)) {
        if (top->prev) {
            top = top->prev;
            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                          "redirected from r->uri = %s",
                          top->uri ? top->uri : "(unexpectedly NULL)");
        }

        if (!top->prev && top->main) {
            top = top->main;
            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                          "subrequested from r->uri = %s",
                          top->uri ? top->uri : "(unexpectedly NULL)");
        }
    }
}

/*
 * check whether redirect limit is reached
 */
API_EXPORT(int) ap_is_recursion_limit_exceeded(const request_rec *r)
{
    core_server_config *conf = ap_get_module_config(r->server->module_config,
                                                    &core_module);
    const request_rec *top = r;
    int redirects = 0, subreqs = 0;
    int rlimit = conf->recursion_limit_set
                 ? conf->redirect_limit
                 : AP_DEFAULT_MAX_INTERNAL_REDIRECTS;
    int slimit = conf->recursion_limit_set
                 ? conf->subreq_limit
                 : AP_DEFAULT_MAX_SUBREQ_DEPTH;

    /* fast exit (unlimited) */
    if (!rlimit && !slimit) {
        return 0;
    }

    while (top->prev || top->main) {
        if (top->prev) {
            if (rlimit && ++redirects >= rlimit) {
                /* uuh, too much. */
                ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
                              "Request exceeded the limit of %d internal "
                              "redirects due to probable configuration error. "
                              "Use 'LimitInternalRecursion' to increase the "
                              "limit if necessary. Use 'LogLevel debug' to get "
                              "a backtrace.", rlimit);

                /* post backtrace */
                log_backtrace(r);

                /* return failure */
                return 1;
            }

            top = top->prev;
        }

        if (!top->prev && top->main) {
            if (slimit && ++subreqs >= slimit) {
                /* uuh, too much. */
                ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
                              "Request exceeded the limit of %d subrequest "
                              "nesting levels due to probable confguration "
                              "error. Use 'LimitInternalRecursion' to increase "
                              "the limit if necessary. Use 'LogLevel debug' to "
                              "get a backtrace.", slimit);

                /* post backtrace */
                log_backtrace(r);

                /* return failure */
                return 1;
            }

            top = top->main;
        }
    }

    /* recursion state: ok */
    return 0;
}

a3541 4

{ "LimitInternalRecursion", set_recursion_limit, NULL, RSRC_CONF, TAKE12,
  "maximum recursion depth of internal redirects and subrequests"},

@


1.1.1.3
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/* $OpenBSD: http_core.c,v 1.16 2003/11/17 18:57:05 henning Exp $ */
d1283 1
a1283 1
		     "cannot use a full URL in a 401 ErrorDocument "
@


1.1.1.4
log
@OpenBSD has got some security fixes for httpd
@
text
@d1 1
a1 1
/* $OpenBSD: http_core.c,v 1.18 2004/07/31 20:01:55 brad Exp $ */
a240 3
    if (new->ap_auth_nonce) {
        conf->ap_auth_nonce = new->ap_auth_nonce;
    }
a582 25
API_EXPORT(const char *) ap_auth_nonce(request_rec *r)
{
    core_dir_config *conf;
    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
                                                   &core_module);
    if (conf->ap_auth_nonce)
       return conf->ap_auth_nonce;

    /* Ideally we'd want to mix in some per-directory style
     * information; as we are likely to want to detect replay
     * across those boundaries and some randomness. But that
     * is harder due to the adhoc nature of .htaccess memory
     * structures, restarts and forks.
     *
     * But then again - you should use AuthDigestRealmSeed in your config
     * file if you care. So the adhoc value should do.
     */
    return ap_psprintf(r->pool,"%pp%pp%pp%pp%pp",
           (void *)&((r->connection->local_addr).sin_addr ),
           (void *)ap_user_name,
           (void *)ap_listeners,
           (void *)ap_server_argv0,
           (void *)ap_pid_fname);
}

a831 1
    unsigned cport = ntohs(r->connection->local_addr.sin_port);
d835 2
d838 3
a840 14
        || d->use_canonical_name == USE_CANONICAL_NAME_DNS) {
        
        /* With UseCanonicalName Off Apache will form self-referential
         * URLs using the hostname and port supplied by the client if
         * any are supplied (otherwise it will use the canonical name).
         */
        port = r->parsed_uri.port_str ? r->parsed_uri.port : 
          cport ? cport :
            r->server->port ? r->server->port :
              ap_default_port(r);
    } else { /* d->use_canonical_name == USE_CANONICAL_NAME_ON */
        port = r->server->port ? r->server->port : 
          cport ? cport :
            ap_default_port(r);
a841 1

a2836 22
/*
 * Load an authorisation nonce into our location configuration, and
 * force it to be in the 0-9/A-Z realm.
 */
static const char *set_authnonce (cmd_parms *cmd, void *mconfig, char *word1)
{
    core_dir_config *aconfig = (core_dir_config *)mconfig;
    size_t i;

    aconfig->ap_auth_nonce = ap_escape_quotes(cmd->pool, word1);

    if (strlen(aconfig->ap_auth_nonce) > 510)
       return "AuthDigestRealmSeed length limited to 510 chars for browser compatibility";

    for(i=0;i<strlen(aconfig->ap_auth_nonce );i++)
       if (!ap_isalnum(aconfig->ap_auth_nonce [i]))
         return "AuthDigestRealmSeed limited to 0-9 and A-Z range for browser compatibility";

    return NULL;
}


a3450 3
{ "AuthDigestRealmSeed", set_authnonce, NULL, OR_AUTHCFG, TAKE1,
  "An authentication token which should be different for each logical realm. "\
  "A random value or the servers IP may be a good choise.\n" },
@


1.1.1.5
log
@Import first part of OpenBSD httpd cleanup work (OpenHTTPD? ;)
@
text
@d1 1
a1 1
/* $OpenBSD: http_core.c,v 1.19 2004/12/02 19:42:47 henning Exp $ */
d90 3
d96 1
d155 3
d164 11
d302 5
d319 15
d905 221
d1558 3
d1562 1
d2145 5
d2201 1
d2445 5
d2456 1
d2668 12
d2898 12
d3050 16
d3076 116
d3635 4
d3675 8
d3718 9
d3733 16
d3807 253
d4129 4
d4134 1
d4173 6
d4183 1
@


