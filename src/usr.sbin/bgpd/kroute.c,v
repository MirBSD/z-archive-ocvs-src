head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.4
	tg-mergefixes-1-branch:1.1.1.4.0.8
	tg-mergefixes-1-base:1.1.1.4
	MIROS_X:1.1.1.4.0.6
	MIROS_X_BASE:1.1.1.4
	tg-mergetmp-3:1.1.1.4
	MIRBSD_XP_MIRPPC:1.1.1.4.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.4
	MIRBSD_XP_SPARC:1.1.1.4.0.2
	cvs-200405160640:1.1.1.4
	cvs-200401271800:1.1.1.3
	cvs-200401261630:1.1.1.3
	cvs-200401021645:1.1.1.2
	cvs-200312222040:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.12.22.21.20.11;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.22.21.20.11;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.01.02.18.12.25;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.01.26.19.05.50;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.16.07.19.22;	author tg;	state Stab;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: kroute.c,v 1.1 2003/12/22 15:22:13 henning Exp $ */

/*
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/route.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "bgpd.h"

int	kroute_msg(int, int, struct kroute *);

u_int32_t	rtseq = 1;

int
kroute_init(void)
{
	int	s, opt;

	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) < 0)
		fatal("route socket", errno);

	if (fcntl(s, F_SETFL, O_NONBLOCK) == -1)
		fatal(NULL, errno);

	/* not intrested in my own messages */
	if (setsockopt(s, SOL_SOCKET, SO_USELOOPBACK, &opt, sizeof(opt)) == -1)
		fatal("route setsockopt", errno);

	return (s);
}

int
kroute_msg(int fd, int action, struct kroute *kroute)
{
	struct {
		struct rt_msghdr	hdr;
		struct sockaddr_in	prefix;
		struct sockaddr_in	nexthop;
		struct sockaddr_in	mask;
	} r;
	ssize_t	n;

	r.hdr.rtm_msglen = sizeof(r);
	r.hdr.rtm_version = RTM_VERSION;
	r.hdr.rtm_type = action;
	r.hdr.rtm_flags = RTF_GATEWAY|RTF_MASK; /* XXX */
	r.hdr.rtm_seq = rtseq++;	/* overflow doesn't matter */
	r.hdr.rtm_addrs = RTA_DST|RTA_GATEWAY|RTA_NETMASK;
	r.prefix.sin_family = AF_INET;
	r.prefix.sin_addr.s_addr = kroute->prefix;
	r.nexthop.sin_family = AF_INET;
	r.nexthop.sin_addr.s_addr = kroute->nexthop;
	r.mask.sin_family = AF_INET;
	r.mask.sin_addr.s_addr = htonl(0xffffffff << (32 - kroute->prefixlen));

retry:
	if ((n = write(fd, &r, sizeof(r))) == -1) {
		if (errno == ESRCH) {
			if (r.hdr.rtm_type == RTM_CHANGE) {
				r.hdr.rtm_type = RTM_ADD;
				goto retry;
			} else if (r.hdr.rtm_type == RTM_DELETE) {
				logit(LOG_INFO, "route vanished before delete");
				return (0);
			}
		} else {
			logit(LOG_INFO, "kroute_msg", strerror(errno));
			return (-1);
		}
	}
	if (n == sizeof(r))
		return (0);

	/* XXX we could not write everything... bad bad bad. cope. */
	return (n);
}

int
kroute_add(int fd, struct kroute *kroute)
{
	return (kroute_msg(fd, RTM_ADD, kroute));
}

int
kroute_change(int fd, struct kroute *kroute)
{
	return (kroute_msg(fd, RTM_CHANGE, kroute));
}

int
kroute_delete(int fd, struct kroute *kroute)
{
	return (kroute_msg(fd, RTM_DELETE, kroute));
}
@


1.1.1.1
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@@


1.1.1.2
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.45 2004/01/02 01:46:20 deraadt Exp $ */
a18 1
#include <sys/param.h>
a20 2
#include <sys/sysctl.h>
#include <sys/tree.h>
d34 3
a36 47
struct {
	u_int32_t		rtseq;
	pid_t			pid;
	int			fib_sync;
	int			fd;
} kr_state;

struct kroute_node {
	RB_ENTRY(kroute_node)	 entry;
	struct kroute		 r;
	int			 flags;
};

struct knexthop_node {
	RB_ENTRY(knexthop_node)	 entry;
	in_addr_t		 nexthop;
	struct kroute_node	*kroute;
};

int		kroute_protect_lo(void);
int		kroute_msg(int, int, struct kroute *);
int		kroute_insert(struct kroute_node *);
int		kroute_compare(struct kroute_node *, struct kroute_node *);
void		get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
u_int8_t	prefixlen_classful(in_addr_t);
u_int8_t	mask2prefixlen(in_addr_t);
int		kroute_fetchtable(void);
int		kroute_remove(struct kroute_node *);
int		kroute_nexthop_insert(in_addr_t, struct kroute_nexthop *);
int		kroute_nexthop_checkmatch(in_addr_t, struct knexthop_node *);
int		knexthop_compare(struct knexthop_node *,
		    struct knexthop_node *);

struct kroute_node	*kroute_match(in_addr_t);

RB_HEAD(kroute_tree, kroute_node)	kroute_tree, krt;
RB_PROTOTYPE(kroute_tree, kroute_node, entry, kroute_compare);
RB_GENERATE(kroute_tree, kroute_node, entry, kroute_compare);

RB_HEAD(knexthop_tree, knexthop_node)	knexthop_tree, knt;
RB_PROTOTYPE(knexthop_tree, knexthop_node, entry, knexthop_compare);
RB_GENERATE(knexthop_tree, knexthop_node, entry, knexthop_compare);

#define	F_BGPD_INSERTED		0x0001
#define	F_KERNEL		0x0002
#define	F_CONNECTED		0x0004
#define	F_NEXTHOP		0x0008
d39 1
a39 1
kroute_init(int fs)
d41 1
a41 28
	int opt;

	kr_state.fib_sync = fs;

	if ((kr_state.fd = socket(AF_ROUTE, SOCK_RAW, 0)) == -1) {
		log_err("kroute_init: socket");
		return (-1);
	}

	/* not interested in my own messages */
	if (setsockopt(kr_state.fd, SOL_SOCKET, SO_USELOOPBACK,
	    &opt, sizeof(opt)) == -1)
		log_err("kroute_init: setsockopt");	/* not fatal */

	kr_state.pid = getpid();
	kr_state.rtseq = 1;

	RB_INIT(&krt);
	RB_INIT(&knt);

	if (kroute_fetchtable() == -1)
		return (-1);

	if (kroute_protect_lo() == -1)
		return (-1);

	return (kr_state.fd);
}
d43 2
a44 4
int
kroute_protect_lo(void)
{
	struct kroute_node	*kr;
d46 2
a47 9
	/* special protection for 127/8 */
	if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
		log_err("kroute_protect_lo");
		return (-1);
	}
	kr->r.prefix = inet_addr("127.0.0.1");
	kr->r.prefixlen = 8;
	kr->r.nexthop = 0;
	kr->flags = F_KERNEL|F_CONNECTED;
d49 3
a51 2
	if (RB_INSERT(kroute_tree, &krt, kr) != NULL)
		free(kr);	/* kernel route already there, no problem */
d53 1
a53 1
	return (0);
a66 4
	if (kr_state.fib_sync == 0)
		return (0);

	bzero(&r, sizeof(r));
d70 2
a71 2
	r.hdr.rtm_flags = RTF_GATEWAY|RTF_PROTO1;
	r.hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
a72 1
	r.prefix.sin_len = sizeof(r.prefix);
a74 1
	r.nexthop.sin_len = sizeof(r.nexthop);
a76 1
	r.mask.sin_len = sizeof(r.mask);
d82 1
a82 2
		switch (errno) {
		case ESRCH:
d87 1
a87 10
				logit(LOG_INFO,
				    "route %s/%u vanished before delete",
				    log_ntoa(kroute->prefix),
				    kroute->prefixlen);
				return (0);
			} else {
				logit(LOG_CRIT,
				    "kroute_msg: action %u, prefix %s/%u: %s",
				    r.hdr.rtm_type, log_ntoa(kroute->prefix),
				    kroute->prefixlen, strerror(errno));
d90 2
a91 35
			break;
		default:
			logit(LOG_CRIT,
			    "kroute_msg: action %u, prefix %s/%u: %s",
			    r.hdr.rtm_type, log_ntoa(kroute->prefix),
			    kroute->prefixlen, strerror(errno));
			return (0);
		}
	}

	return (0);
}

int
kroute_change(struct kroute *kroute)
{
	struct kroute_node	*kr, s;
	int			 action = RTM_ADD;

	s.r.prefix = kroute->prefix;
	s.r.prefixlen = kroute->prefixlen;

	if ((kr = RB_FIND(kroute_tree, &krt, &s)) != NULL) {
		if (kr->flags & F_BGPD_INSERTED)
			action = RTM_CHANGE;
		else	/* a non-bgp route already exists. not a problem */
			return (0);
	}

	if (kroute_msg(kr_state.fd, action, kroute) == -1)
		return (-1);

	if (action == RTM_ADD) {
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_err("kroute_change");
a93 24
		kr->r.prefix = kroute->prefix;
		kr->r.prefixlen = kroute->prefixlen;
		kr->r.nexthop = kroute->nexthop;
		kr->flags = F_BGPD_INSERTED;

		if (kroute_insert(kr) == -1)
			free(kr);
	} else
		kr->r.nexthop = kroute->nexthop;

	return (0);
}

int
kroute_insert(struct kroute_node *kr)
{
	struct knexthop_node	*h;
	struct kroute_nexthop	 nh;
	in_addr_t		 mask, ina;

	if (RB_INSERT(kroute_tree, &krt, kr) != NULL) {
		logit(LOG_CRIT, "kroute_tree insert failed for %s/%u",
		    log_ntoa(kr->r.prefix), kr->r.prefixlen);
		return (-1);
d95 1
a95 31

	if (kr->flags & F_KERNEL) {
		mask = 0xffffffff << (32 - kr->r.prefixlen);
		ina = ntohl(kr->r.prefix);
		RB_FOREACH(h, knexthop_tree, &knt) {
			if ((ntohl(h->nexthop) & mask) == ina) {
				if (h->kroute != NULL)
					continue;	/* XXX */
				h->kroute = kr;
				kr->flags |= F_NEXTHOP;
				bzero(&nh, sizeof(nh));
				nh.nexthop = h->nexthop;
				nh.valid = 1;
				nh.connected = kr->flags & F_CONNECTED;
				nh.gateway = kr->r.nexthop;
				send_nexthop_update(&nh);
			}
		}
	}
	return (0);
}

int
kroute_delete(struct kroute *kroute)
{
	struct kroute_node	*kr, s;

	s.r.prefix = kroute->prefix;
	s.r.prefixlen = kroute->prefixlen;

	if ((kr = RB_FIND(kroute_tree, &krt, &s)) == NULL)
d98 2
a99 10
	if (!(kr->flags & F_BGPD_INSERTED))
		return (0);

	if (kroute_msg(kr_state.fd, RTM_DELETE, kroute) == -1)
		return (-1);

	RB_REMOVE(kroute_tree, &krt, kr);
	free(kr);

	return (0);
d103 1
a103 21
kroute_compare(struct kroute_node *a, struct kroute_node *b)
{
	if (a->r.prefix < b->r.prefix)
		return (-1);
	if (a->r.prefix > b->r.prefix)
		return (1);
	if (a->r.prefixlen < b->r.prefixlen)
		return (-1);
	if (a->r.prefixlen > b->r.prefixlen)
		return (1);
	return (0);
}

void
kroute_shutdown(void)
{
	kroute_fib_decouple();
}

void
kroute_fib_couple(void)
d105 1
a105 63
	struct kroute_node	*kr;

	kr_state.fib_sync = 1;

	RB_FOREACH(kr, kroute_tree, &krt)
		if ((kr->flags & F_BGPD_INSERTED))
			kroute_msg(kr_state.fd, RTM_ADD, &kr->r);
}

void
kroute_fib_decouple(void)
{
	struct kroute_node	*kr;

	RB_FOREACH(kr, kroute_tree, &krt)
		if ((kr->flags & F_BGPD_INSERTED))
			kroute_msg(kr_state.fd, RTM_DELETE, &kr->r);

	kr_state.fib_sync = 0;
}

#define	ROUNDUP(a, size)	\
    (((a) & ((size) - 1)) ? (1 + ((a) | ((size) - 1))) : (a))

void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int	i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len, sizeof(long)));
		} else
			rti_info[i] = NULL;
	}
}

u_int8_t
prefixlen_classful(in_addr_t ina)
{
	/* it hurt to write this. */

	if (ina >= 0xf0000000U)		/* class E */
		return (32);
	else if (ina >= 0xe0000000U)	/* class D */
		return (4);
	else if (ina >= 0xc0000000U)	/* class C */
		return (24);
	else if (ina >= 0x80000000U)	/* class B */
		return (16);
	else				/* class A */
		return (8);
}

u_int8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
d109 1
a109 1
kroute_fetchtable(void)
d111 1
a111 69
	size_t			 len;
	int			 mib[6];
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in	*sa_in;
	struct kroute_node	*kr;

	mib[0] = CTL_NET;
	mib[1] = AF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;

	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
		log_err("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_err("kroute_fetchtable");
		return (-1);
	}
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
		log_err("sysctl");
		return (-1);
	}

	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		sa = (struct sockaddr *)(rtm + 1);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_DST]) == NULL)
			continue;

		if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
			continue;

		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_err("kroute_fetchtable");
			return (-1);
		}

		kr->flags = F_KERNEL;
		kr->r.prefix = sa_in->sin_addr.s_addr;
		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK]) !=
		    NULL) {
			kr->r.prefixlen =
			    mask2prefixlen(sa_in->sin_addr.s_addr);
		} else if (rtm->rtm_flags & RTF_HOST)
			kr->r.prefixlen = 32;
		else
			kr->r.prefixlen = prefixlen_classful(kr->r.prefix);

		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_GATEWAY]) !=
		    NULL) {
			if (sa_in->sin_family == AF_INET)
				kr->r.nexthop = sa_in->sin_addr.s_addr;
			else if (sa_in->sin_family == AF_LINK)
				kr->flags |= F_CONNECTED;
		}

		if (kroute_insert(kr) == -1)
			free(kr);
	}
	free(buf);
	return (0);
d115 1
a115 1
kroute_dispatch_msg(void)
d117 1
a117 141
	char			 buf[RT_BUF_SIZE];
	ssize_t			 n;
	char			*next, *lim;
	struct rt_msghdr	*rtm;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in	*sa_in;
	struct kroute_node	*kr, s;
	in_addr_t		 nexthop;
	int			 flags;

	if ((n = read(kr_state.fd, &buf, sizeof(buf))) == -1) {
		log_err("kroute_dispatch_msg: read error");
		return (-1);
	}

	if (n == 0) {
		logit(LOG_CRIT, "routing socket closed");
		return (-1);
	}

	lim = buf + n;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		sa = (struct sockaddr *)(rtm + 1);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
		flags = F_KERNEL;
		nexthop = 0;

		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_DST]) == NULL)
			continue;

		if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
			continue;

		if (rtm->rtm_pid == kr_state.pid)	/* cause by us */
			continue;

		if (rtm->rtm_errno)			/* failed attempts... */
			continue;

		s.r.prefix = sa_in->sin_addr.s_addr;
		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK]) !=
		    NULL) {
			s.r.prefixlen =
			    mask2prefixlen(sa_in->sin_addr.s_addr);
		} else if (rtm->rtm_flags & RTF_HOST)
			s.r.prefixlen = 32;
		else
			s.r.prefixlen = prefixlen_classful(s.r.prefix);

		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_GATEWAY]) !=
		    NULL) {
			if (sa_in->sin_family == AF_INET)
				nexthop = sa_in->sin_addr.s_addr;
			else if (sa_in->sin_family == AF_LINK)
				flags |= F_CONNECTED;
		}

		switch (rtm->rtm_type) {
		case RTM_ADD:
		case RTM_CHANGE:
			if (nexthop == 0) {
				logit(LOG_CRIT,
				    "kroute_dispatch_msg: no nexthop for %s/%u",
				    log_ntoa(s.r.prefix), s.r.prefixlen);
				continue;
			}

			if ((kr = RB_FIND(kroute_tree, &krt, &s)) != NULL) {
				if (kr->flags & F_KERNEL) {
					kr->r.nexthop = nexthop;
					if (kr->flags & F_NEXTHOP) /* XXX */
						flags |= F_NEXTHOP;
					kr->flags = flags;
				}
			} else {
				if ((kr = calloc(1,
				    sizeof(struct kroute_node))) == NULL) {
					log_err("kroute_dispatch_msg");
					return (-1);
				}
				kr->r.prefix = s.r.prefix;
				kr->r.prefixlen = s.r.prefixlen;
				kr->r.nexthop = nexthop;
				kr->flags = flags;

				if (kroute_insert(kr) == -1)
					free(kr);
			}
			break;
		case RTM_DELETE:
			if ((kr = RB_FIND(kroute_tree, &krt, &s)) == NULL)
				continue;
			if (!(kr->flags & F_KERNEL))
				continue;
			if (kroute_remove(kr) == -1)
				return (-1);
			break;
		default:
			/* ignore for now */
			break;
		}
	}
	return (0);
}

int
kroute_remove(struct kroute_node *kr)
{
	struct knexthop_node	*s;
	struct kroute_nexthop	 h;

	/*
	 * the foreach is suboptimal, but:
	 * -routes disappering that have nexthops attached should not
	 *  happen often; except for some ibgp and multihop that should
	 *  be connected routes anyway
	 * -maintaining an SLIST per kroute_node is probably worse
	 * -it is easy to change if needed ;-)
	 */

	RB_REMOVE(kroute_tree, &krt, kr);

	if ((kr->flags & F_KERNEL) && (kr->flags & F_NEXTHOP))
		RB_FOREACH(s, knexthop_tree, &knt)
			if (s->kroute == kr) {
				/*
				 * XXX check again wether there's another
				 * non-bgp route. if not, notify RDE
				 * that this nexthop is now invalid
				 */
				if (!kroute_nexthop_checkmatch(s->nexthop,
				    s)) {
					s->kroute = NULL;
					bzero(&h, sizeof(h));
					h.nexthop = s->nexthop;
					send_nexthop_update(&h);
				}
			}
	free(kr);
	return (0);
a118 125

struct kroute_node *
kroute_match(in_addr_t key)
{
	int			i;
	struct kroute_node	s, *kr;
	in_addr_t		ina;

	ina = ntohl(key);

	/* we will never match the default route */
	for (i = 32; i > 0; i--) {
		s.r.prefix = htonl(ina & (0xffffffff << (32 - i)));
		s.r.prefixlen = i;
		if ((kr = RB_FIND(kroute_tree, &krt, &s)) != NULL)
			return (kr);
	}

	/* if we don't have a match yet, try to find a default route */
	s.r.prefix = 0;
	s.r.prefixlen = 0;
	if ((kr = RB_FIND(kroute_tree, &krt, &s)) != NULL)
		return (kr);

	return (NULL);
}

int
kroute_nexthop_add(in_addr_t key)
{
	struct kroute_nexthop	 nh;
	struct knexthop_node	*h, s;

	s.nexthop = key;

	bzero(&nh, sizeof(nh));
	nh.nexthop = key;

	if ((h = RB_FIND(knexthop_tree, &knt, &s)) != NULL) {
		if (h->kroute != NULL) {
			nh.valid = 1;
			nh.connected = h->kroute->flags & F_CONNECTED;
			nh.gateway = h->kroute->r.nexthop;
		}
	} else
		if (kroute_nexthop_insert(key, &nh) == -1)
			return (-1);

	send_nexthop_update(&nh);

	return (0);
}

void
kroute_nexthop_delete(in_addr_t key)
{
	struct knexthop_node	*a, *b, s;

	s.nexthop = key;

	if ((a = RB_FIND(knexthop_tree, &knt, &s)) == NULL)
		return;

	/*
	 * check wether there's another nexthop depending on this kroute
	 * if not remove the flag
	 */

	for (b = RB_MIN(knexthop_tree, &knt); b != NULL &&
	    b->kroute != a->kroute; b = RB_NEXT(knexthop_tree, &knt, b))
		;	/* nothing */

	if (b == NULL)
		a->kroute->flags &= ~F_NEXTHOP;

	RB_REMOVE(knexthop_tree, &knt, a);
}

int
kroute_nexthop_insert(in_addr_t key, struct kroute_nexthop *nh)
{
	struct knexthop_node	*h;

	if ((h = calloc(1, sizeof(struct knexthop_node))) == NULL) {
		log_err("kroute_nexthop_insert");
		return (-1);
	}

	h->nexthop = nh->nexthop = key;

	if (kroute_nexthop_checkmatch(key, h) == 1) {
		nh->valid = 1;
		nh->connected = h->kroute->flags & F_CONNECTED;
		nh->gateway = h->kroute->r.nexthop;
	}

	if (RB_INSERT(knexthop_tree, &knt, h) != NULL) {
		logit(LOG_CRIT, "knexthop_tree insert failed for %s",
			    log_ntoa(h->nexthop));
		free(h);
	}
	return (0);
}

int
kroute_nexthop_checkmatch(in_addr_t key, struct knexthop_node *h)
{
	struct kroute_node	*kr;

	if ((kr = kroute_match(key)) != NULL)
		if (kr->flags & F_KERNEL) {	/* must be non-bgp! */
			h->kroute = kr;
			kr->flags |= F_NEXTHOP;
			return (1);
		}

	return (0);
}

int
knexthop_compare(struct knexthop_node *a, struct knexthop_node *b)
{
	return (b->nexthop - a->nexthop);
}

@


1.1.1.3
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.78 2004/01/23 21:18:12 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
a25 2
#include <net/if.h>
#include <net/if_dl.h>
d47 1
d52 1
a52 1
	struct bgpd_addr	 nexthop;
d56 5
a60 39
struct kif_kr {
	LIST_ENTRY(kif_kr)	 entry;
	struct kroute_node	*kr;
};

LIST_HEAD(kif_kr_head, kif_kr);

struct kif_node {
	RB_ENTRY(kif_node)	 entry;
	struct kif		 k;
	struct kif_kr_head	 kroute_l;
};

int	kroute_compare(struct kroute_node *, struct kroute_node *);
int	knexthop_compare(struct knexthop_node *, struct knexthop_node *);
int	kif_compare(struct kif_node *, struct kif_node *);

struct kroute_node	*kroute_find(in_addr_t, u_int8_t);
int			 kroute_insert(struct kroute_node *);
int			 kroute_remove(struct kroute_node *);

struct knexthop_node	*knexthop_find(struct bgpd_addr *);
int			 knexthop_insert(struct knexthop_node *);
int			 knexthop_remove(struct knexthop_node *);

struct kif_node		*kif_find(int);
int			 kif_insert(struct kif_node *);
int			 kif_remove(struct kif_node *);

int			 kif_kr_insert(struct kroute_node *);
int			 kif_kr_remove(struct kroute_node *);

void			 knexthop_validate(struct knexthop_node *);
struct kroute_node	*kroute_match(in_addr_t);
void			 kroute_attach_nexthop(struct knexthop_node *,
			    struct kroute_node *);
void			 kroute_detach_nexthop(struct knexthop_node *);

int		protect_lo(void);
d63 6
a68 3
void		get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
void		if_change(u_short, int, struct if_data *);
void		if_announce(void *);
d70 1
a70 4
int		send_rtmsg(int, int, struct kroute *);
int		dispatch_rtmsg(void);
int		fetchtable(void);
int		fetchifs(int);
d80 4
a83 7
RB_HEAD(kif_tree, kif_node)		kif_tree, kit;
RB_PROTOTYPE(kif_tree, kif_node, entry, kif_compare);
RB_GENERATE(kif_tree, kif_node, entry, kif_compare);

/*
 * exported functions
 */
d86 1
a86 1
kr_init(int fs)
d93 1
a93 1
		log_warn("kr_init: socket");
d100 1
a100 1
		log_warn("kr_init: setsockopt");	/* not fatal */
a106 4
	RB_INIT(&kit);

	if (fetchifs(0) == -1)
		return (-1);
d108 1
a108 1
	if (fetchtable() == -1)
d111 1
a111 1
	if (protect_lo() == -1)
d118 1
a118 1
kr_change(struct kroute *kroute)
a120 1
	int			 action = RTM_ADD;
d122 4
a125 6
	if ((kr = kroute_find(kroute->prefix, kroute->prefixlen)) !=
	    NULL) {
		if (kr->r.flags & F_BGPD_INSERTED)
			action = RTM_CHANGE;
		else	/* a non-bgp route already exists. not a problem */
			return (0);
d127 4
d132 2
a133 17
	if (send_rtmsg(kr_state.fd, action, kroute) == -1)
		return (-1);

	if (action == RTM_ADD) {
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("kr_change");
			return (-1);
		}
		kr->r.prefix = kroute->prefix;
		kr->r.prefixlen = kroute->prefixlen;
		kr->r.nexthop = kroute->nexthop;
		kr->r.flags = F_BGPD_INSERTED;

		if (kroute_insert(kr) == -1)
			free(kr);
	} else
		kr->r.nexthop = kroute->nexthop;
d139 1
a139 1
kr_delete(struct kroute *kroute)
d141 7
a147 1
	struct kroute_node	*kr;
d149 1
a149 1
	if ((kr = kroute_find(kroute->prefix, kroute->prefixlen)) == NULL)
d152 16
a167 2
	if (!(kr->r.flags & F_BGPD_INSERTED))
		return (0);
d169 19
a187 72
	if (send_rtmsg(kr_state.fd, RTM_DELETE, kroute) == -1)
		return (-1);

	if (kroute_remove(kr) == -1)
		return (-1);

	return (0);
}

void
kr_shutdown(void)
{
	kr_fib_decouple();
}

void
kr_fib_couple(void)
{
	struct kroute_node	*kr;

	if (kr_state.fib_sync == 1)	/* already coupled */
		return;

	kr_state.fib_sync = 1;

	RB_FOREACH(kr, kroute_tree, &krt)
		if ((kr->r.flags & F_BGPD_INSERTED))
			send_rtmsg(kr_state.fd, RTM_ADD, &kr->r);

	log_info("kernel routing table coupled");
}

void
kr_fib_decouple(void)
{
	struct kroute_node	*kr;

	if (kr_state.fib_sync == 0)	/* already decoupled */
		return;

	RB_FOREACH(kr, kroute_tree, &krt)
		if ((kr->r.flags & F_BGPD_INSERTED))
			send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r);

	kr_state.fib_sync = 0;

	log_info("kernel routing table decoupled");
}

int
kr_dispatch_msg(void)
{
	return (dispatch_rtmsg());
}

int
kr_nexthop_add(struct bgpd_addr *addr)
{
	struct knexthop_node	*h;

	if ((h = knexthop_find(addr)) != NULL) {
		/* should not happen... this is really an error path */
		struct kroute_nexthop	 nh;

		bzero(&nh, sizeof(nh));
		memcpy(&nh.nexthop, addr, sizeof(nh.nexthop));
		if (h->kroute != NULL) {
			nh.valid = 1;
			nh.connected = h->kroute->r.flags & F_CONNECTED;
			if (h->kroute->r.nexthop != 0) {
				nh.gateway.af = AF_INET;
				nh.gateway.v4.s_addr = h->kroute->r.nexthop;
d189 7
a195 1
			memcpy(&nh.kr, &h->kroute->r, sizeof(nh.kr));
a196 10
		send_nexthop_update(&nh);
	} else {
		if ((h = calloc(1, sizeof(struct knexthop_node))) == NULL) {
			log_warn("kr_nexthop_add");
			return (-1);
		}
		memcpy(&h->nexthop, addr, sizeof(h->nexthop));

		if (knexthop_insert(h) == -1)
			return (-1);
d202 2
a203 2
void
kr_nexthop_delete(struct bgpd_addr *addr)
d205 2
a206 1
	struct knexthop_node	*kn;
d208 2
a209 2
	if ((kn = knexthop_find(addr)) == NULL)
		return;
d211 5
a215 57
	knexthop_remove(kn);
}

void
kr_show_route(struct imsg *imsg)
{
	struct kroute_node	*kr;
	struct bgpd_addr	*addr;
	int			 flags;
	struct ctl_show_nexthop	 snh;
	struct knexthop_node	*h;
	struct kif_node		*kif;

	switch (imsg->hdr.type) {
	case IMSG_CTL_KROUTE:
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(flags)) {
			log_warnx("kr_show_route: wrong imsg len");
			return;
		}
		memcpy(&flags, imsg->data, sizeof(flags));
		RB_FOREACH(kr, kroute_tree, &krt)
			if (!flags || kr->r.flags & flags)
				send_imsg_session(IMSG_CTL_KROUTE,
				    imsg->hdr.pid, &kr->r, sizeof(kr->r));
		break;
	case IMSG_CTL_KROUTE_ADDR:
		if (imsg->hdr.len != IMSG_HEADER_SIZE +
		    sizeof(struct bgpd_addr)) {
			log_warnx("kr_show_route: wrong imsg len");
			return;
		}
		addr = imsg->data;
		kr = NULL;
		if (addr->af == AF_INET)
			kr = kroute_match(addr->v4.s_addr);
		if (kr != NULL)
			send_imsg_session(IMSG_CTL_KROUTE, imsg->hdr.pid,
			    &kr->r, sizeof(kr->r));
		break;
	case IMSG_CTL_SHOW_NEXTHOP:
		RB_FOREACH(h, knexthop_tree, &knt) {
			bzero(&snh, sizeof(snh));
			memcpy(&snh.addr, &h->nexthop, sizeof(snh.addr));
			if (h->kroute != NULL)
				if (!(h->kroute->r.flags & F_DOWN))
					snh.valid = 1;
			send_imsg_session(IMSG_CTL_SHOW_NEXTHOP, imsg->hdr.pid,
			    &snh, sizeof(snh));
		}
		break;
	case IMSG_CTL_SHOW_INTERFACE:
		RB_FOREACH(kif, kif_tree, &kit)
			send_imsg_session(IMSG_CTL_SHOW_INTERFACE,
			    imsg->hdr.pid, &kif->k, sizeof(kif->k));
		break;
	default:	/* nada */
		break;
d218 1
a218 15
	send_imsg_session(IMSG_CTL_END, imsg->hdr.pid, NULL, 0);
}

/*
 * RB-tree compare functions
 */

int
kroute_compare(struct kroute_node *a, struct kroute_node *b)
{
	if (a->r.prefix < b->r.prefix)
		return (-1);
	if (a->r.prefix > b->r.prefix)
		return (1);
	if (a->r.prefixlen < b->r.prefixlen)
a219 4
	if (a->r.prefixlen > b->r.prefixlen)
		return (1);
	return (0);
}
d221 9
a229 4
int
knexthop_compare(struct knexthop_node *a, struct knexthop_node *b)
{
	u_int32_t	r;
d231 4
a234 19
	if (a->nexthop.af != b->nexthop.af)
		return (b->nexthop.af - a->nexthop.af);

	switch (a->nexthop.af) {
	case AF_INET:
		if ((r = b->nexthop.addr32[0] - a->nexthop.addr32[0]) != 0)
			return (r);
		break;
	case AF_INET6:
		if ((r = b->nexthop.addr32[3] - a->nexthop.addr32[3]) != 0)
			return (r);
		if ((r = b->nexthop.addr32[2] - a->nexthop.addr32[2]) != 0)
			return (r);
		if ((r = b->nexthop.addr32[1] - a->nexthop.addr32[1]) != 0)
			return (r);
		if ((r = b->nexthop.addr32[0] - a->nexthop.addr32[0]) != 0)
			return (r);
		break;
	}
a239 22
kif_compare(struct kif_node *a, struct kif_node *b)
{
	return (b->k.ifindex - a->k.ifindex);
}


/*
 * tree management functions
 */

struct kroute_node *
kroute_find(in_addr_t prefix, u_int8_t prefixlen)
{
	struct kroute_node	s;

	s.r.prefix = prefix;
	s.r.prefixlen = prefixlen;

	return (RB_FIND(kroute_tree, &krt, &s));
}

int
d243 1
d247 1
a247 1
		log_warnx("kroute_tree insert failed for %s/%u",
a248 1
		free(kr);
d252 1
a252 4
	if (kr->r.flags & F_KERNEL) {
		if (!(kr->r.flags & F_CONNECTED))
			kr->r.flags |= F_STATIC;

d255 13
a267 33
		RB_FOREACH(h, knexthop_tree, &knt)
			if (h->nexthop.af == AF_INET &&
			    (ntohl(h->nexthop.v4.s_addr) & mask) == ina)
				knexthop_validate(h);

		if (kr->r.flags & F_CONNECTED)
			if (kif_kr_insert(kr) == -1)
				return (-1);
	}
	return (0);
}

int
kroute_remove(struct kroute_node *kr)
{
	struct knexthop_node	*s;

	if (RB_REMOVE(kroute_tree, &krt, kr) == NULL) {
		log_warnx("kroute_remove failed for %s/%u",
		    log_ntoa(kr->r.prefix), kr->r.prefixlen);
		return (-1);
	}

	/* check wether a nexthop depends on this kroute */
	if ((kr->r.flags & F_KERNEL) && (kr->r.flags & F_NEXTHOP))
		RB_FOREACH(s, knexthop_tree, &knt)
			if (s->kroute == kr)
				knexthop_validate(s);

	if (kr->r.flags & F_CONNECTED)
		if (kif_kr_remove(kr) == -1) {
			free(kr);
			return (-1);
a268 23

	free(kr);
	return (0);
}

struct knexthop_node *
knexthop_find(struct bgpd_addr *addr)
{
	struct knexthop_node	s;

	memcpy(&s.nexthop, addr, sizeof(s.nexthop));

	return (RB_FIND(knexthop_tree, &knt, &s));
}

int
knexthop_insert(struct knexthop_node *kn)
{
	if (RB_INSERT(knexthop_tree, &knt, kn) != NULL) {
		log_warnx("knexthop_tree insert failed for %s",
			    log_addr(&kn->nexthop));
		free(kn);
		return (-1);
a269 3

	knexthop_validate(kn);

d274 1
a274 16
knexthop_remove(struct knexthop_node *kn)
{
	kroute_detach_nexthop(kn);

	if (RB_REMOVE(knexthop_tree, &knt, kn) == NULL) {
		log_warnx("knexthop_remove failed for %s",
		    log_addr(&kn->nexthop));
		return (-1);
	}

	free(kn);
	return (0);
}

struct kif_node *
kif_find(int ifindex)
d276 1
a276 1
	struct kif_node	*kif, s;
d278 2
a279 2
	bzero(&s, sizeof(s));
	s.k.ifindex = ifindex;
d281 2
a282 2
	if ((kif = RB_FIND(kif_tree, &kit, &s)) != NULL)
		return (kif);
d284 2
a285 9
	/* check wether the interface showed up now */
	fetchifs(ifindex);
	return (RB_FIND(kif_tree, &kit, &s));
}

int
kif_insert(struct kif_node *kif)
{
	LIST_INIT(&kif->kroute_l);
d287 1
a287 3
	if (RB_INSERT(kif_tree, &kit, kif) != NULL) {
		log_warnx("RB_INSERT(kif_tree, &kit, kif)");
		free(kif);
a288 1
	}
d290 2
a291 19
	return (0);
}

int
kif_remove(struct kif_node *kif)
{
	struct kif_kr	*kkr;

	if (RB_REMOVE(kif_tree, &kit, kif) == NULL) {
		log_warnx("RB_REMOVE(kif_tree, &kit, kif)");
		return (-1);
	}

	while ((kkr = LIST_FIRST(&kif->kroute_l)) != NULL) {
		LIST_REMOVE(kkr, entry);
		kkr->kr->r.flags &= ~F_NEXTHOP;
		kroute_remove(kkr->kr);
		free(kkr);
	}
a292 1
	free(kif);
d297 1
a297 1
kif_kr_insert(struct kroute_node *kr)
d299 1
a299 11
	struct kif_node	*kif;
	struct kif_kr	*kkr;

	if ((kif = kif_find(kr->r.ifindex)) == NULL) {
		log_warnx("interface with index %u not found",
		    kr->r.ifindex);
		return (0);
	}

	if ((kkr = calloc(1, sizeof(struct kif_kr))) == NULL) {
		log_warn("kif_kr_insert");
d301 3
a303 28
	}

	kkr->kr = kr;

	LIST_INSERT_HEAD(&kif->kroute_l, kkr, entry);

	return (0);
}

int
kif_kr_remove(struct kroute_node *kr)
{
	struct kif_node	*kif;
	struct kif_kr	*kkr;

	if ((kif = kif_find(kr->r.ifindex)) == NULL) {
		log_warnx("interface with index %u not found",
		    kr->r.ifindex);
		return (0);
	}

	for (kkr = LIST_FIRST(&kif->kroute_l); kkr != NULL && kkr->kr != kr;
	    kkr = LIST_NEXT(kkr, entry))
		;	/* nothing */

	if (kkr == NULL) {
		log_warnx("can't remove connected route from interface "
		    "with index %u: not found", kr->r.ifindex);
d305 2
a306 5
	}

	LIST_REMOVE(kkr, entry);
	free(kkr);

a309 4
/*
 * nexthop validation
 */

d311 1
a311 1
knexthop_validate(struct knexthop_node *kn)
d313 1
a313 35
	struct kroute_node	*kr;
	struct kroute_nexthop	 n;
	int			 was_valid = 0;

	if (kn->kroute != NULL && (!(kn->kroute->r.flags & F_DOWN)))
		was_valid = 1;

	bzero(&n, sizeof(n));
	memcpy(&n.nexthop, &kn->nexthop, sizeof(n.nexthop));
	kroute_detach_nexthop(kn);

	switch (kn->nexthop.af) {
	case AF_INET:
		if ((kr = kroute_match(kn->nexthop.v4.s_addr)) == NULL) {
			if (was_valid)
				send_nexthop_update(&n);
		} else {					/* match */
			if (kr->r.flags & F_DOWN) {		/* is down */
				if (was_valid)
					send_nexthop_update(&n);
			} else {				/* valid */
				if (!was_valid) {
					n.valid = 1;
					n.connected = kr->r.flags & F_CONNECTED;
					if ((n.gateway.v4.s_addr =
					    kr->r.nexthop) != 0)
						n.gateway.af = AF_INET;
					memcpy(&n.kr, &kr->r, sizeof(n.kr));
					send_nexthop_update(&n);
				}
			}
			kroute_attach_nexthop(kn, kr);
		}
		break;
	}
d316 2
a317 2
struct kroute_node *
kroute_match(in_addr_t key)
a318 1
	int			 i;
a319 1
	in_addr_t		 ina;
d321 1
a321 1
	ina = ntohl(key);
d323 3
a325 11
	/* we will never match the default route */
	for (i = 32; i > 0; i--)
		if ((kr = kroute_find(
		    htonl(ina & (0xffffffff << (32 - i))), i)) != NULL)
			return (kr);

	/* if we don't have a match yet, try to find a default route */
	if ((kr = kroute_find(0, 0)) != NULL)
			return (kr);

	return (NULL);
d329 1
a329 36
kroute_attach_nexthop(struct knexthop_node *kn, struct kroute_node *kr)
{
	kn->kroute = kr;
	kr->r.flags |= F_NEXTHOP;
}

void
kroute_detach_nexthop(struct knexthop_node *kn)
{
	struct knexthop_node	*s;

	/*
	 * check wether there's another nexthop depending on this kroute
	 * if not remove the flag
	 */

	if (kn->kroute == NULL)
		return;

	for (s = RB_MIN(knexthop_tree, &knt); s != NULL &&
	    s->kroute != kn->kroute; s = RB_NEXT(knexthop_tree, &knt, s))
		;	/* nothing */

	if (s == NULL)
		kn->kroute->r.flags &= ~F_NEXTHOP;

	kn->kroute = NULL;
}


/*
 * misc helpers
 */

int
protect_lo(void)
d333 3
a335 32
	/* special protection for 127/8 */
	if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
		log_warn("protect_lo");
		return (-1);
	}
	kr->r.prefix = inet_addr("127.0.0.1");
	kr->r.prefixlen = 8;
	kr->r.nexthop = 0;
	kr->r.flags = F_KERNEL|F_CONNECTED;

	if (RB_INSERT(kroute_tree, &krt, kr) != NULL)
		free(kr);	/* kernel route already there, no problem */

	return (0);
}

u_int8_t
prefixlen_classful(in_addr_t ina)
{
	/* it hurt to write this. */

	if (ina >= 0xf0000000U)		/* class E */
		return (32);
	else if (ina >= 0xe0000000U)	/* class D */
		return (4);
	else if (ina >= 0xc0000000U)	/* class C */
		return (24);
	else if (ina >= 0x80000000U)	/* class B */
		return (16);
	else				/* class A */
		return (8);
}
d337 1
a337 7
u_int8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
d358 2
a359 2
void
if_change(u_short ifindex, int flags, struct if_data *ifd)
d361 1
a361 5
	struct kif_node		*kif;
	struct kif_kr		*kkr;
	struct kroute_nexthop	 nh;
	struct knexthop_node	*n;
	u_int8_t		 reachable;
d363 10
a372 44
	if ((kif = kif_find(ifindex)) == NULL) {
		log_warnx("interface with index %u not found",
		    ifindex);
		return;
	}

	kif->k.flags = flags;
	kif->k.link_state = ifd->ifi_link_state;
	kif->k.media_type = ifd->ifi_type;
	kif->k.baudrate = ifd->ifi_baudrate;

	if ((reachable = (flags & IFF_UP) &&
	    (ifd->ifi_link_state != LINK_STATE_DOWN)) == kif->k.nh_reachable)
		return;		/* nothing changed wrt nexthop validity */

	kif->k.nh_reachable = reachable;

	LIST_FOREACH(kkr, &kif->kroute_l, entry) {
		/*
		 * we treat link_state == LINK_STATE_UNKNOWN as valid
		 * not all interfaces have a conecpt of "link state" and/or
		 * do not report up
		 */
		if (reachable)
			kkr->kr->r.flags &= ~F_DOWN;
		else
			kkr->kr->r.flags |= F_DOWN;

		RB_FOREACH(n, knexthop_tree, &knt)
			if (n->kroute == kkr->kr) {
				bzero(&nh, sizeof(nh));
				memcpy(&nh.nexthop, &n->nexthop,
				    sizeof(nh.nexthop));
				if (!(kkr->kr->r.flags & F_DOWN)) {
					nh.valid = 1;
					nh.connected = 1;
					if ((nh.gateway.v4.s_addr =
					    kkr->kr->r.nexthop) != 0)
						nh.gateway.af = AF_INET;
				}
				memcpy(&nh.kr, &kkr->kr->r, sizeof(nh.kr));
				send_nexthop_update(&nh);
			}
	}
d375 2
a376 2
void
if_announce(void *msg)
d378 1
a378 39
	struct if_announcemsghdr	*ifan;
	struct kif_node			*kif;

	ifan = msg;

	switch (ifan->ifan_what) {
	case IFAN_ARRIVAL:
		if ((kif = calloc(1, sizeof(struct kif_node))) == NULL) {
			log_warn("if_announce");
			return;
		}

		kif->k.ifindex = ifan->ifan_index;
		strlcpy(kif->k.ifname, ifan->ifan_name, sizeof(kif->k.ifname));
		kif_insert(kif);
		break;
	case IFAN_DEPARTURE:
		kif = kif_find(ifan->ifan_index);
		kif_remove(kif);
		break;
	}
}

/*
 * rtsock related functions
 */

int
send_rtmsg(int fd, int action, struct kroute *kroute)
{
	struct {
		struct rt_msghdr	hdr;
		struct sockaddr_in	prefix;
		struct sockaddr_in	nexthop;
		struct sockaddr_in	mask;
	} r;
	ssize_t	n;

	if (kr_state.fib_sync == 0)
d380 2
a381 47

	bzero(&r, sizeof(r));
	r.hdr.rtm_msglen = sizeof(r);
	r.hdr.rtm_version = RTM_VERSION;
	r.hdr.rtm_type = action;
	r.hdr.rtm_flags = RTF_GATEWAY|RTF_PROTO1;
	r.hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	r.hdr.rtm_addrs = RTA_DST|RTA_GATEWAY|RTA_NETMASK;
	r.prefix.sin_len = sizeof(r.prefix);
	r.prefix.sin_family = AF_INET;
	r.prefix.sin_addr.s_addr = kroute->prefix;
	r.nexthop.sin_len = sizeof(r.nexthop);
	r.nexthop.sin_family = AF_INET;
	r.nexthop.sin_addr.s_addr = kroute->nexthop;
	r.mask.sin_len = sizeof(r.mask);
	r.mask.sin_family = AF_INET;
	r.mask.sin_addr.s_addr = htonl(0xffffffff << (32 - kroute->prefixlen));

retry:
	if ((n = write(fd, &r, sizeof(r))) == -1) {
		switch (errno) {
		case ESRCH:
			if (r.hdr.rtm_type == RTM_CHANGE) {
				r.hdr.rtm_type = RTM_ADD;
				goto retry;
			} else if (r.hdr.rtm_type == RTM_DELETE) {
				log_info("route %s/%u vanished before delete",
				    log_ntoa(kroute->prefix),
				    kroute->prefixlen);
				return (0);
			} else {
				log_warnx("send_rtmsg: action %u, "
				    "prefix %s/%u: %s", r.hdr.rtm_type,
				    log_ntoa(kroute->prefix), kroute->prefixlen,
				    strerror(errno));
				return (0);
			}
			break;
		default:
			log_warnx("send_rtmsg: action %u, prefix %s/%u: %s",
			    r.hdr.rtm_type, log_ntoa(kroute->prefix),
			    kroute->prefixlen, strerror(errno));
			return (0);
		}
	}

	return (0);
d385 1
a385 1
fetchtable(void)
d403 1
a403 1
		log_warn("sysctl");
d407 1
a407 1
		log_warn("fetchtable");
d411 1
a411 1
		log_warn("sysctl");
d421 1
a421 1
		if ((sa = rti_info[RTAX_DST]) == NULL)
d428 1
a428 1
			log_warn("fetchtable");
d432 10
a441 1
		kr->r.flags = F_KERNEL;
d443 6
a448 19
		switch (sa->sa_family) {
		case AF_INET:
			kr->r.prefix =
			    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
			sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
			if (kr->r.prefix == 0)	/* default route */
				kr->r.prefixlen = 0;
			else if (sa_in != NULL)
				kr->r.prefixlen =
				    mask2prefixlen(sa_in->sin_addr.s_addr);
			else if (rtm->rtm_flags & RTF_HOST)
				kr->r.prefixlen = 32;
			else
				kr->r.prefixlen =
				    prefixlen_classful(kr->r.prefix);
			break;
		default:
			continue;
			/* not reached */
d451 2
a452 14
		if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
			switch (sa->sa_family) {
			case AF_INET:
				kr->r.nexthop =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				break;
			case AF_LINK:
				kr->r.flags |= F_CONNECTED;
				kr->r.ifindex = rtm->rtm_index;
				break;
			}

		kroute_insert(kr);

d459 1
a459 67
fetchifs(int ifindex)
{
	size_t			 len;
	int			 mib[6];
	char			*buf, *next, *lim;
	struct if_msghdr	*ifm;
	struct kif_node		*kif;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_dl	*sdl;

	mib[0] = CTL_NET;
	mib[1] = AF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_IFLIST;
	mib[5] = ifindex;

	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn("fetchif");
		return (-1);
	}
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}

	lim = buf + len;
	for (next = buf; next < lim; next += ifm->ifm_msglen) {
		ifm = (struct if_msghdr *)next;
		sa = (struct sockaddr *)(ifm + 1);
		get_rtaddrs(ifm->ifm_addrs, sa, rti_info);

		if (ifm->ifm_type != RTM_IFINFO)
			continue;

		if ((kif = calloc(1, sizeof(struct kif_node))) == NULL) {
			log_warn("fetchifs");
			return (-1);
		}

		kif->k.ifindex = ifm->ifm_index;
		kif->k.flags = ifm->ifm_flags;
		kif->k.link_state = ifm->ifm_data.ifi_link_state;
		kif->k.media_type = ifm->ifm_data.ifi_type;
		kif->k.baudrate = ifm->ifm_data.ifi_baudrate;
		kif->k.nh_reachable = (kif->k.flags & IFF_UP) &&
		    (ifm->ifm_data.ifi_link_state != LINK_STATE_DOWN);

		if ((sa = rti_info[RTAX_IFP]) != NULL)
			if (sa->sa_family == AF_LINK) {
				sdl = (struct sockaddr_dl *)sa;
				if (sdl->sdl_nlen > 0)
					strlcpy(kif->k.ifname, sdl->sdl_data,
					    sizeof(kif->k.ifname));
			}

		kif_insert(kif);
	}
	return (0);
}

int
dispatch_rtmsg(void)
a464 1
	struct if_msghdr	*ifm;
d467 2
a468 3
	struct kroute_node	*kr;
	in_addr_t		 prefix, nexthop;
	u_int8_t		 prefixlen;
a469 1
	u_short			 ifindex;
d472 1
a472 1
		log_warn("dispatch_rtmsg: read error");
d477 1
a477 1
		log_warnx("routing socket closed");
a485 3

		prefix = 0;
		prefixlen = 0;
d488 6
a493 1
		ifindex = 0;
d501 9
a509 25
		if (rtm->rtm_type == RTM_ADD || rtm->rtm_type == RTM_CHANGE ||
		    rtm->rtm_type == RTM_DELETE) {
			if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
				continue;
			switch (sa->sa_family) {
			case AF_INET:
				prefix =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				sa_in = (struct sockaddr_in *)
				    rti_info[RTAX_NETMASK];
				if (sa_in != NULL) {
					if (sa_in->sin_family != AF_INET)
						continue;
					prefixlen = mask2prefixlen(
					    sa_in->sin_addr.s_addr);
				} else if (rtm->rtm_flags & RTF_HOST)
					prefixlen = 32;
				else
					prefixlen = prefixlen_classful(prefix);
				break;
			default:
				continue;
				/* not reached */
			}
		}
d511 5
a515 7
		if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
			switch (sa->sa_family) {
			case AF_INET:
				nexthop =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				break;
			case AF_LINK:
d517 1
a517 3
				ifindex = rtm->rtm_index;
				break;
			}
d522 4
a525 3
			if (nexthop == 0 && !(flags & F_CONNECTED)) {
				log_warnx("dispatch_rtmsg no nexthop for %s/%u",
				    log_ntoa(prefix), prefixlen);
d529 2
a530 3
			if ((kr = kroute_find(prefix, prefixlen)) !=
			    NULL) {
				if (kr->r.flags & F_KERNEL) {
d532 1
a532 1
					if (kr->r.flags & F_NEXTHOP)
d534 1
a534 7
					if ((kr->r.flags & F_CONNECTED) &&
					    !(flags & F_CONNECTED))
						kif_kr_remove(kr);
					if ((flags & F_CONNECTED) &&
					    !(kr->r.flags & F_CONNECTED))
						kif_kr_insert(kr);
					kr->r.flags = flags;
d539 1
a539 1
					log_warn("dispatch_rtmsg");
d542 2
a543 2
				kr->r.prefix = prefix;
				kr->r.prefixlen = prefixlen;
d545 1
a545 1
				kr->r.flags = flags;
d547 2
a548 1
				kroute_insert(kr);
d552 1
a552 1
			if ((kr = kroute_find(prefix, prefixlen)) == NULL)
d554 1
a554 1
			if (!(kr->r.flags & F_KERNEL))
a558 8
		case RTM_IFINFO:
			ifm = (struct if_msghdr *)next;
			if_change(ifm->ifm_index, ifm->ifm_flags,
			    &ifm->ifm_data);
			break;
		case RTM_IFANNOUNCE:
			if_announce(next);
			break;
d566 162
@


1.1.1.4
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.95 2004/05/08 06:04:57 henning Exp $ */
a76 1
void			 kroute_clear(void);
a80 1
void			 knexthop_clear(void);
a84 1
void			 kif_clear(void);
a97 1
in_addr_t	prefixlen2mask(u_int8_t);
d108 2
a109 2
RB_PROTOTYPE(kroute_tree, kroute_node, entry, kroute_compare)
RB_GENERATE(kroute_tree, kroute_node, entry, kroute_compare)
d112 2
a113 2
RB_PROTOTYPE(knexthop_tree, knexthop_node, entry, knexthop_compare)
RB_GENERATE(knexthop_tree, knexthop_node, entry, knexthop_compare)
d116 2
a117 2
RB_PROTOTYPE(kif_tree, kif_node, entry, kif_compare)
RB_GENERATE(kif_tree, kif_node, entry, kif_compare)
d165 1
a165 1
	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen)) !=
d181 1
a181 1
		kr->r.prefix.s_addr = kroute->prefix.s_addr;
d183 1
a183 1
		kr->r.nexthop.s_addr = kroute->nexthop.s_addr;
d189 1
a189 1
		kr->r.nexthop.s_addr = kroute->nexthop.s_addr;
d199 1
a199 2
	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen)) ==
	    NULL)
a217 3
	knexthop_clear();
	kroute_clear();
	kif_clear();
d274 1
a274 1
			if (h->kroute->r.nexthop.s_addr != 0) {
d276 1
a276 2
				nh.gateway.v4.s_addr =
				    h->kroute->r.nexthop.s_addr;
d372 1
a372 1
	if (ntohl(a->r.prefix.s_addr) < ntohl(b->r.prefix.s_addr))
d374 1
a374 1
	if (ntohl(a->r.prefix.s_addr) > ntohl(b->r.prefix.s_addr))
d427 1
a427 1
	s.r.prefix.s_addr = prefix;
d441 1
a441 1
		    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
d450 2
a451 2
		mask = prefixlen2mask(kr->r.prefixlen);
		ina = ntohl(kr->r.prefix.s_addr);
d471 1
a471 1
		    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
a490 9
void
kroute_clear(void)
{
	struct kroute_node	*kr;

	while ((kr = RB_MIN(kroute_tree, &krt)) != NULL)
		kroute_remove(kr);
}

a530 9
void
knexthop_clear(void)
{
	struct knexthop_node	*kn;

	while ((kn = RB_MIN(knexthop_tree, &knt)) != NULL)
		knexthop_remove(kn);
}

d534 1
a534 1
	struct kif_node	s;
d539 5
a581 9
void
kif_clear(void)
{
	struct kif_node	*kif;

	while ((kif = RB_MIN(kif_tree, &kit)) != NULL)
		kif_remove(kif);
}

d589 2
a590 3
		if (kr->r.ifindex)
			log_warnx("interface with index %u not found",
			    kr->r.ifindex);
d613 2
a614 3
		if (kr->r.ifindex)
			log_warnx("interface with index %u not found",
			    kr->r.ifindex);
d666 1
a666 1
					    kr->r.nexthop.s_addr) != 0)
d689 2
a690 2
		if ((kr =
		    kroute_find(htonl(ina & prefixlen2mask(i)), i)) != NULL)
d745 1
a745 1
	kr->r.prefix.s_addr = inet_addr("127.0.0.1");
d747 1
a781 6
in_addr_t
prefixlen2mask(u_int8_t prefixlen)
{
	return (0xffffffff << (32 - prefixlen));
}

d846 1
a846 1
					    kkr->kr->r.nexthop.s_addr) != 0)
d894 1
d908 1
a908 1
	r.prefix.sin_addr.s_addr = kroute->prefix.s_addr;
d911 1
a911 1
	r.nexthop.sin_addr.s_addr = kroute->nexthop.s_addr;
d914 1
a914 1
	r.mask.sin_addr.s_addr = htonl(prefixlen2mask(kroute->prefixlen));
d917 1
a917 1
	if (write(fd, &r, sizeof(r)) == -1) {
d925 1
a925 1
				    inet_ntoa(kroute->prefix),
d931 2
a932 2
				    inet_ntoa(kroute->prefix),
				    kroute->prefixlen, strerror(errno));
d938 1
a938 1
			    r.hdr.rtm_type, inet_ntoa(kroute->prefix),
a974 1
		free(buf);
a991 1
			free(buf);
d999 1
a999 1
			kr->r.prefix.s_addr =
d1002 3
a1004 3
			if (sa_in != NULL) {
				if (sa_in->sin_len == 0)
					break;
d1007 1
a1007 1
			} else if (rtm->rtm_flags & RTF_HOST)
d1011 1
a1011 1
				    prefixlen_classful(kr->r.prefix.s_addr);
a1013 1
			free(kr);
d1021 1
a1021 1
				kr->r.nexthop.s_addr =
d1043 1
a1043 1
	struct if_msghdr	 ifm;
a1064 1
		free(buf);
d1069 4
a1072 4
	for (next = buf; next < lim; next += ifm.ifm_msglen) {
		memcpy(&ifm, next, sizeof(ifm));
		sa = (struct sockaddr *)(next + sizeof(ifm));
		get_rtaddrs(ifm.ifm_addrs, sa, rti_info);
d1074 1
a1074 1
		if (ifm.ifm_type != RTM_IFINFO)
a1078 1
			free(buf);
d1082 5
a1086 5
		kif->k.ifindex = ifm.ifm_index;
		kif->k.flags = ifm.ifm_flags;
		kif->k.link_state = ifm.ifm_data.ifi_link_state;
		kif->k.media_type = ifm.ifm_data.ifi_type;
		kif->k.baudrate = ifm.ifm_data.ifi_baudrate;
d1088 1
a1088 1
		    (ifm.ifm_data.ifi_link_state != LINK_STATE_DOWN);
a1099 1
	free(buf);
d1110 1
a1110 1
	struct if_msghdr	 ifm;
d1114 1
a1114 1
	struct in_addr		 prefix, nexthop;
d1135 1
a1135 1
		prefix.s_addr = 0;
d1138 1
a1138 1
		nexthop.s_addr = 0;
d1153 1
a1153 1
				prefix.s_addr =
d1158 4
a1161 3
					if (sa_in->sin_len != 0)
						prefixlen = mask2prefixlen(
						    sa_in->sin_addr.s_addr);
d1165 1
a1165 2
					prefixlen =
					    prefixlen_classful(prefix.s_addr);
d1176 1
a1176 1
				nexthop.s_addr =
d1188 1
a1188 1
			if (nexthop.s_addr == 0 && !(flags & F_CONNECTED)) {
d1190 1
a1190 1
				    inet_ntoa(prefix), prefixlen);
d1194 1
a1194 1
			if ((kr = kroute_find(prefix.s_addr, prefixlen)) !=
d1197 1
a1197 1
					kr->r.nexthop.s_addr = nexthop.s_addr;
a1207 5
			} else if (rtm->rtm_type == RTM_CHANGE) {
				log_warnx("change req for %s/%u: not "
				    "in table", inet_ntoa(prefix),
				    prefixlen);
				continue;
d1214 1
a1214 1
				kr->r.prefix.s_addr = prefix.s_addr;
d1216 1
a1216 1
				kr->r.nexthop.s_addr = nexthop.s_addr;
a1217 1
				kr->r.ifindex = ifindex;
d1223 1
a1223 2
			if ((kr = kroute_find(prefix.s_addr, prefixlen)) ==
			    NULL)
d1231 3
a1233 3
			memcpy(&ifm, next, sizeof(ifm));
			if_change(ifm.ifm_index, ifm.ifm_flags,
			    &ifm.ifm_data);
@


