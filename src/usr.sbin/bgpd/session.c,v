head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.5
	tg-mergefixes-1-branch:1.1.1.5.0.8
	tg-mergefixes-1-base:1.1.1.5
	MIROS_X:1.1.1.5.0.6
	MIROS_X_BASE:1.1.1.5
	tg-mergetmp-3:1.1.1.5
	MIRBSD_XP_MIRPPC:1.1.1.5.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.5
	MIRBSD_XP_SPARC:1.1.1.5.0.2
	cvs-200405160640:1.1.1.5
	cvs-200401271800:1.1.1.4
	cvs-200401261630:1.1.1.3
	cvs-200401021645:1.1.1.2
	cvs-200312222040:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.12.22.21.20.12;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.22.21.20.12;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.01.02.18.12.25;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.01.26.19.05.56;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.01.27.19.20.52;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.16.07.19.26;	author tg;	state Stab;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: session.c,v 1.27 2003/12/21 23:28:39 henning Exp $ */

/*
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


#include <sys/param.h>
#include <sys/types.h>

#include <sys/mman.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "bgpd.h"
#include "session.h"

#define	PFD_LISTEN	0
#define PFD_PIPE_MAIN	1
#define PFD_PIPE_ROUTE	2
#define PFD_PEERS_START	3

void	session_sighdlr(int);
int	setup_listener(void);
void	init_conf(struct bgpd_config *);
void	init_peers(void);
void	bgp_fsm(struct peer *, enum session_events);
int	timer_due(time_t);
void	start_timer_holdtime(struct peer *);
void	start_timer_keepalive(struct peer *);
void	session_close_connection(struct peer *);
void	session_terminate(void);
void	change_state(struct peer *, enum session_state, enum session_events);
int	session_setup_socket(struct peer *);
void	session_accept(int);
int	session_connect(struct peer *);
void	session_open(struct peer *);
void	session_keepalive(struct peer *);
void	session_update(struct peer *);
void	session_notification(struct peer *, u_int8_t, u_int8_t, void *,
	    ssize_t);
int	session_dispatch_msg(struct pollfd *, struct peer *);
int	parse_header(struct peer *, u_char *, u_int16_t *, u_int8_t *);
int	parse_open(struct peer *);
int	parse_update(struct peer *);
int	parse_notification(struct peer *);
int	parse_keepalive(struct peer *);
void	session_dispatch_imsg(struct imsgbuf *, int);
void	session_up(struct peer *);
void	session_down(struct peer *);

struct peer	*getpeerbyip(in_addr_t);

struct bgpd_config	*conf = NULL, *nconf = NULL;
volatile sig_atomic_t	 session_quit = 0;
int			 pending_reconf = 0;
struct imsgbuf		 ibuf_rde;
struct imsgbuf		 ibuf_main;

void
session_sighdlr(int sig)
{
	switch (sig) {
	case SIGTERM:
		session_quit = 1;
		break;
	}
}

int
setup_listener(void)
{
	int			fd, opt;
	struct sockaddr_in	addr;

	if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
		return (fd);

	opt = 1;
	setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));

	bzero(&addr, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
	addr.sin_port = htons(BGP_PORT);

	if (bind(fd, (struct sockaddr *)&addr, sizeof(addr))) {
		close(fd);
		return (-1);
	}
	if (listen(fd, MAX_BACKLOG)) {
		close(fd);
		return (-1);
	}
	if (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {
		close(fd);
		return (-1);
	}

	return (fd);
}


int
session_main(struct bgpd_config *config, int pipe_m2s[2], int pipe_s2r[2])
{
	int		 sock, nfds, i, j, timeout;
	pid_t		 pid;
	time_t		 nextaction;
	struct passwd	*pw;
	struct peer	*p, *peers[OPEN_MAX], *last, *next;
	struct pollfd	 pfd[OPEN_MAX];

	conf = config;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork", errno);
	case 0:
		break;
	default:
		return (pid);
	}

	if ((pw = getpwnam(BGPD_USER)) == NULL)
		fatal(NULL, errno);

	if (chroot(pw->pw_dir) < 0)
		fatal("chroot failed", errno);
	chdir("/");

	setproctitle("session engine");
	bgpd_process = PROC_SE;

	if ((sock = setup_listener()) < 0)
		fatal("listener setup failed", 0);

	if (setgroups(1, &pw->pw_gid) ||
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid))
		fatal("can't drop privileges", errno);

	endpwent();

	signal(SIGTERM, session_sighdlr);
	logit(LOG_INFO, "session engine ready");
	close(pipe_m2s[0]);
	close(pipe_s2r[1]);
	init_conf(conf);
	imsg_init(&ibuf_rde, pipe_s2r[0]);
	imsg_init(&ibuf_main, pipe_m2s[1]);
	init_peers();

	while (session_quit == 0) {
		bzero(&pfd, sizeof(pfd));
		pfd[PFD_LISTEN].fd = sock;
		pfd[PFD_LISTEN].events = POLLIN;
		pfd[PFD_PIPE_MAIN].fd = ibuf_main.sock;
		pfd[PFD_PIPE_MAIN].events = POLLIN;
		pfd[PFD_PIPE_ROUTE].fd = ibuf_rde.sock;
		pfd[PFD_PIPE_ROUTE].events = POLLIN;
		if (ibuf_rde.w.queued > 0)
			pfd[PFD_PIPE_ROUTE].events |= POLLOUT;

		nextaction = time(NULL) + 240;	/* loop every 240s at least */
		i = PFD_PEERS_START;

		last = NULL;
		for (p = conf->peers; p != NULL; p = next) {
			next = p->next;
			if (!pending_reconf) {
				/* needs init? */
				if (p->state == STATE_NONE)
					change_state(p, STATE_IDLE, EVNT_NONE);

				/* reinit due? */
				if (p->conf.reconf_action == RECONF_REINIT) {
					bgp_fsm(p, EVNT_STOP);
					p->StartTimer = time(NULL);
				}

				/* deletion due? */
				if (p->conf.reconf_action == RECONF_DELETE) {
					bgp_fsm(p, EVNT_STOP);
					log_errx(p, "removed");
					if (last != NULL)
						last->next = next;
					else
						conf->peers = next;
					free(p);
					continue;
				}
				p->conf.reconf_action = RECONF_NONE;
			}
			last = p;

			/* check timers */
			if (timer_due(p->HoldTimer))
				bgp_fsm(p, EVNT_TIMER_HOLDTIME);
			if (timer_due(p->ConnectRetryTimer))
				bgp_fsm(p, EVNT_TIMER_CONNRETRY);
			if (timer_due(p->KeepaliveTimer))
				bgp_fsm(p, EVNT_TIMER_KEEPALIVE);
			if (timer_due(p->StartTimer))
				bgp_fsm(p, EVNT_START);

			/* set nextaction to the first expiring timer */
			if (p->ConnectRetryTimer &&
			    p->ConnectRetryTimer < nextaction)
				nextaction = p->ConnectRetryTimer;
			if (p->HoldTimer && p->HoldTimer < nextaction)
				nextaction = p->HoldTimer;
			if (p->KeepaliveTimer && p->KeepaliveTimer < nextaction)
				nextaction = p->KeepaliveTimer;
			if (p->StartTimer && p->StartTimer < nextaction)
				nextaction = p->StartTimer;

			/* are we waiting for a write? */
			if (p->wbuf.queued > 0)
				p->events |= POLLOUT;

			/* poll events */
			if (p->sock != -1 && p->events != 0) {
				pfd[i].fd = p->sock;
				pfd[i].events = p->events;
				peers[i] = p;
				i++;
			}
		}

		timeout = nextaction - time(NULL);
		if (timeout < 0)
			timeout = 0;
		nfds = poll(pfd, i, timeout * 1000);
		/*
		 * what do we do on poll error?
		 */
		if (nfds > 0 && pfd[PFD_LISTEN].revents & POLLIN) {
			nfds--;
			session_accept(sock);
		}

		if (nfds > 0 && pfd[PFD_PIPE_MAIN].revents & POLLIN) {
			nfds--;
			session_dispatch_imsg(&ibuf_main, PFD_PIPE_MAIN);
		}

		if (nfds > 0 && pfd[PFD_PIPE_ROUTE].revents & POLLOUT)
			if (msgbuf_write(&ibuf_rde.w) == -1)
				fatal("pipe write error", 0);

		if (nfds > 0 && pfd[PFD_PIPE_ROUTE].revents & POLLIN) {
			nfds--;
			session_dispatch_imsg(&ibuf_rde, PFD_PIPE_ROUTE);
		}

		for (j = PFD_PEERS_START; nfds > 0 && j < i; j++) {
			nfds -= session_dispatch_msg(&pfd[j], peers[j]);
		}
	}

	session_terminate();
	shutdown(sock, SHUT_RDWR);
	close(sock);
	logit(LOG_INFO, "session engine exiting");
	_exit(0);
}

void
init_conf(struct bgpd_config *c)
{
	if (!c->holdtime)
		c->holdtime = INTERVAL_HOLD;
}

void
init_peers(void)
{
	struct peer	*p;

	for (p = conf->peers; p != NULL; p = p->next) {
		if (p->state == STATE_NONE) {
			change_state(p, STATE_IDLE, EVNT_NONE);
			p->StartTimer = time(NULL);	/* start ASAP */
		}
	}
}

void
bgp_fsm(struct peer *peer, enum session_events event)
{
	switch (peer->state) {
	case STATE_NONE:
		/* nothing */
		break;
	case STATE_IDLE:
		switch (event) {
		case EVNT_START:
			peer->HoldTimer = 0;
			peer->KeepaliveTimer = 0;
			peer->events = 0;
			peer->StartTimer = 0;
			peer->ConnectRetryTimer =
			    time(NULL) + INTERVAL_CONNECTRETRY;

			/* allocate read buffer */
			peer->rbuf = calloc(1, sizeof(struct peer_buf_read));
			if (peer->rbuf == NULL)
				fatal(NULL, errno);
			peer->rbuf->wptr = peer->rbuf->buf;
			peer->rbuf->pkt_len = MSGSIZE_HEADER;

			/* init write buffer */
			msgbuf_init(&peer->wbuf);

			change_state(peer, STATE_CONNECT, event);
			session_connect(peer);
			break;
		default:
			/* ignore */
		}
		break;
	case STATE_CONNECT:
		switch (event) {
		case EVNT_START:
			/* ignore */
			break;
		case EVNT_CON_OPEN:
			session_open(peer);
			peer->ConnectRetryTimer = 0;
			change_state(peer, STATE_OPENSENT, event);
			break;
		case EVNT_CON_OPENFAIL:
			peer->ConnectRetryTimer =
			    time(NULL) + INTERVAL_CONNECTRETRY;
			session_close_connection(peer);
			change_state(peer, STATE_ACTIVE, event);
			break;
		case EVNT_TIMER_CONNRETRY:
			peer->ConnectRetryTimer =
			    time(NULL) + INTERVAL_CONNECTRETRY;
			session_connect(peer);
		break;
		default:
			change_state(peer, STATE_IDLE, event);
			break;
		}
		break;
	case STATE_ACTIVE:
		switch (event) {
		case EVNT_START:
			/* ignore */
			break;
		case EVNT_CON_OPEN:
			session_open(peer);
			peer->ConnectRetryTimer = 0;
			peer->holdtime = INTERVAL_HOLD_INITIAL;
			start_timer_holdtime(peer);
			change_state(peer, STATE_OPENSENT, event);
			break;
		case EVNT_CON_OPENFAIL:
			peer->ConnectRetryTimer =
			    time(NULL) + INTERVAL_CONNECTRETRY;
			session_close_connection(peer);
			change_state(peer, STATE_ACTIVE, event);
			break;
		case EVNT_TIMER_CONNRETRY:
			peer->ConnectRetryTimer =
			    time(NULL) + peer->holdtime;
			session_connect(peer);
			change_state(peer, STATE_CONNECT, event);
			break;
		default:
			change_state(peer, STATE_IDLE, event);
			break;
		}
		break;
	case STATE_OPENSENT:
		switch (event) {
		case EVNT_START:
			/* ignore */
			break;
		case EVNT_STOP:
			session_notification(peer, ERR_CEASE, 0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_CON_CLOSED:
			session_close_connection(peer);
			peer->ConnectRetryTimer =
			    time(NULL) + INTERVAL_CONNECTRETRY;
			change_state(peer, STATE_ACTIVE, event);
			break;
		case EVNT_CON_FATAL:
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_TIMER_HOLDTIME:
			session_notification(peer, ERR_HOLDTIMEREXPIRED,
			    0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_RCVD_OPEN:
			if (parse_open(peer))
				change_state(peer, STATE_IDLE, event);
			else {
				session_keepalive(peer);
				change_state(peer, STATE_OPENCONFIRM, event);
			}
			break;
		case EVNT_RCVD_NOTIFICATION:
			parse_notification(peer);
			change_state(peer, STATE_IDLE, event);
			break;
		default:
			session_notification(peer, ERR_FSM, 0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		}
		break;
	case STATE_OPENCONFIRM:
		switch (event) {
		case EVNT_START:
			/* ignore */
			break;
		case EVNT_STOP:
			session_notification(peer, ERR_CEASE, 0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_CON_CLOSED:
		case EVNT_CON_FATAL:
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_TIMER_HOLDTIME:
			session_notification(peer, ERR_HOLDTIMEREXPIRED,
			    0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_TIMER_KEEPALIVE:
			session_keepalive(peer);
			break;
		case EVNT_RCVD_KEEPALIVE:
			start_timer_holdtime(peer);
			change_state(peer, STATE_ESTABLISHED, event);
			break;
		case EVNT_RCVD_NOTIFICATION:
			parse_notification(peer);
			change_state(peer, STATE_IDLE, event);
			break;
		default:
			session_notification(peer, ERR_FSM, 0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		}
		break;
	case STATE_ESTABLISHED:
		switch (event) {
		case EVNT_START:
			/* ignore */
			break;
		case EVNT_STOP:
			session_notification(peer, ERR_CEASE, 0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_CON_CLOSED:
		case EVNT_CON_FATAL:
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_TIMER_HOLDTIME:
			session_notification(peer, ERR_HOLDTIMEREXPIRED,
			    0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_TIMER_KEEPALIVE:
			session_keepalive(peer);
			break;
		case EVNT_RCVD_KEEPALIVE:
			start_timer_holdtime(peer);
			break;
		case EVNT_RCVD_UPDATE:
			start_timer_holdtime(peer);
			if (parse_update(peer))
				change_state(peer, STATE_IDLE, event);
			else
				start_timer_holdtime(peer);
			break;
		case EVNT_RCVD_NOTIFICATION:
			parse_notification(peer);
			change_state(peer, STATE_IDLE, event);
			break;
		default:
			session_notification(peer, ERR_FSM, 0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		}
		break;
	}
}

int
timer_due(time_t timer)
{
	if (timer > 0 && timer <= time(NULL))
		return (1);
	return (0);
}

void
start_timer_holdtime(struct peer *peer)
{
	if (peer->holdtime > 0)
		peer->HoldTimer = time(NULL) + peer->holdtime;
	else
		peer->HoldTimer = 0;
}

void
start_timer_keepalive(struct peer *peer)
{
	if (peer->holdtime > 0)
		peer->KeepaliveTimer = time(NULL) + peer->holdtime / 3;
	else
		peer->KeepaliveTimer = 0;
}

void
session_close_connection(struct peer *peer)
{
	if (peer->sock != -1) {
		shutdown(peer->sock, SHUT_RDWR);
		close(peer->sock);
		peer->sock = -1;
		peer->wbuf.sock = -1;
	}
}

void
session_terminate(void)
{
	struct peer	*p;

	for (p = conf->peers; p != NULL; p = p->next)
		bgp_fsm(p, EVNT_STOP);
}

void
change_state(struct peer *peer, enum session_state state,
    enum session_events event)
{
	switch (state) {
	case STATE_IDLE:
		/*
		 * we must start the timer for the next EVNT_START
		 * if we are coming here due to an error and the
		 * session was not established successfull before, the
		 * starttimerinterval needs to be exponentially increased
		 */
		peer->events = 0;
		if (peer->StartTimerInterval == 0)
			peer->StartTimerInterval = INTERVAL_START;
		peer->holdtime = INTERVAL_HOLD_INITIAL;
		peer->ConnectRetryTimer = 0;
		peer->KeepaliveTimer = 0;
		peer->HoldTimer = 0;
		session_close_connection(peer);
		msgbuf_clear(&peer->wbuf);
		free(peer->rbuf);
		peer->rbuf = NULL;
		if (peer->state == STATE_ESTABLISHED)
			session_down(peer);
		if (event != EVNT_STOP) {
			peer->StartTimer = time(NULL) +
			    peer->StartTimerInterval;
			if (peer->StartTimerInterval < UINT_MAX / 2)
				peer->StartTimerInterval *= 2;
		}
		break;
	case STATE_CONNECT:
		peer->events = (POLLIN|POLLOUT);
		break;
	case STATE_ACTIVE:
		peer->events = (POLLIN|POLLOUT);
		break;
	case STATE_OPENSENT:
		peer->events = POLLIN;
		break;
	case STATE_OPENCONFIRM:
		peer->events = POLLIN;
		break;
	case STATE_ESTABLISHED:
		peer->events = POLLIN;
		peer->StartTimerInterval = INTERVAL_START;
		session_up(peer);
		break;
	default:		/* something seriously fucked */
	}

	log_statechange(peer, state, event);
	peer->state = state;
}

void
session_accept(int listenfd)
{
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_in	 cliaddr;
	struct peer		*p = NULL;

	/* collision detection, 6.8, missing */

	len = sizeof(cliaddr);
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&cliaddr, &len)) == -1) {
		if (errno == EWOULDBLOCK || errno == EINTR)
			/* EINTR check needed? stevens says yes */
			return;
		else
			/* what do we do here? log & ignore? */
			;
	}

	p = getpeerbyip(cliaddr.sin_addr.s_addr);

	if (p != NULL &&
	    (p->state == STATE_CONNECT || p->state == STATE_ACTIVE)) {
		p->sock = connfd;
		p->wbuf.sock = connfd;
		if (session_setup_socket(p)) {
			shutdown(connfd, SHUT_RDWR);
			close(connfd);
			return;
		}
		bgp_fsm(p, EVNT_CON_OPEN);
	} else {
		log_conn_attempt(p, cliaddr.sin_addr);
		shutdown(connfd, SHUT_RDWR);
		close(connfd);
	}
}

int
session_connect(struct peer *peer)
{
	int		n;

	/* collision detection, 6.8, missing */

	if (peer->sock != -1)	/* what do we do here? */
		return (-1);

	if ((peer->sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
		log_err(peer, "session_connect socket");
		bgp_fsm(peer, EVNT_CON_OPENFAIL);
		return (-1);
	}

	peer->wbuf.sock = peer->sock;

	/* if update source is set we need to bind() */
	if (peer->conf.local_addr.sin_addr.s_addr)
		if (bind(peer->sock, (struct sockaddr *)&peer->conf.local_addr,
		    sizeof(peer->conf.local_addr))) {
			log_err(peer, "session_connect bind");
			bgp_fsm(peer, EVNT_CON_OPENFAIL);
			return (-1);
		}

	if (fcntl(peer->sock, F_SETFL, O_NONBLOCK) == -1) {
		log_err(peer, "session_connect fcntl");
		bgp_fsm(peer, EVNT_CON_OPENFAIL);
		return (-1);
	}

	if (session_setup_socket(peer)) {
		bgp_fsm(peer, EVNT_CON_OPENFAIL);
		return (-1);
	}

	if ((n = connect(peer->sock, (struct sockaddr *)&peer->conf.remote_addr,
	    sizeof(peer->conf.remote_addr))) < 0)
		if (errno != EINPROGRESS) {
			log_err(peer, "connect");
			bgp_fsm(peer, EVNT_CON_OPENFAIL);
			return (-1);
		}

	if (n == 0)
		bgp_fsm(peer, EVNT_CON_OPEN);

	return (0);
}

int
session_setup_socket(struct peer *p)
{
	int	ttl = p->conf.distance;
	int	pre = IPTOS_PREC_INTERNETCONTROL;
	int	nodelay = 1;

	if (p->conf.ebgp)
		/* set TTL to foreign router's distance - 1=direct n=multihop */
		if (setsockopt(p->sock, IPPROTO_IP, IP_TTL, &ttl,
		    sizeof(ttl)) == -1) {
			log_err(p, "session_setup_socket setsockopt TTL");
			return (-1);
		}

	/* set TCP_NODELAY */
	if (setsockopt(p->sock, IPPROTO_TCP, TCP_NODELAY, &nodelay,
	    sizeof(nodelay)) == -1) {
		log_err(p, "session_setup_socket setsockopt TCP_NODELAY");
		return (-1);
	}

	/* set precedence, see rfc1771 appendix 5 */
	if (setsockopt(p->sock, IPPROTO_IP, IP_TOS, &pre, sizeof(pre)) == -1) {
		log_err(p, "session_setup_socket setsockopt TOS");
		return (-1);
	}

	return (0);
}

void
session_open(struct peer *peer)
{
	struct msg_open	 msg;
	struct buf	*buf;
	u_int16_t	 len;
	int		 errs = 0;

	len = MSGSIZE_OPEN_MIN;

	memset(&msg.header.marker, 0xff, sizeof(msg.header.marker));
	msg.header.len = htons(len);
	msg.header.type = OPEN;
	msg.version = 4;
	msg.myas = htons(conf->as);
	msg.holdtime = htons(conf->holdtime);
	msg.bgpid = conf->bgpid;	/* is already in network byte order */
	msg.optparamlen = 0;

	if ((buf = buf_open(len)) == NULL)
		bgp_fsm(peer, EVNT_CON_FATAL);
	errs += buf_add(buf, &msg.header.marker, sizeof(msg.header.marker));
	errs += buf_add(buf, &msg.header.len, sizeof(msg.header.len));
	errs += buf_add(buf, &msg.header.type, sizeof(msg.header.type));
	errs += buf_add(buf, &msg.version, sizeof(msg.version));
	errs += buf_add(buf, &msg.myas, sizeof(msg.myas));
	errs += buf_add(buf, &msg.holdtime, sizeof(msg.holdtime));
	errs += buf_add(buf, &msg.bgpid, sizeof(msg.bgpid));
	errs += buf_add(buf, &msg.optparamlen, sizeof(msg.optparamlen));

	if (errs == 0) {
		if (buf_close(&peer->wbuf, buf) == -1) {
			buf_free(buf);
			bgp_fsm(peer, EVNT_CON_FATAL);
		}
	} else {
		buf_free(buf);
		bgp_fsm(peer, EVNT_CON_FATAL);
	}
}

void
session_keepalive(struct peer *peer)
{
	struct msg_header	 msg;
	struct buf		*buf;
	ssize_t			 len;
	int			 errs = 0;

	len = MSGSIZE_KEEPALIVE;

	memset(&msg.marker, 0xff, sizeof(msg.marker));
	msg.len = htons(len);
	msg.type = KEEPALIVE;

	if ((buf = buf_open(len)) == NULL)
		bgp_fsm(peer, EVNT_CON_FATAL);
	errs += buf_add(buf, &msg.marker, sizeof(msg.marker));
	errs += buf_add(buf, &msg.len, sizeof(msg.len));
	errs += buf_add(buf, &msg.type, sizeof(msg.type));

	if (errs > 0) {
		buf_free(buf);
		bgp_fsm(peer, EVNT_CON_FATAL);
		return;
	}

	if (buf_close(&peer->wbuf, buf) == -1) {
		buf_free(buf);
		bgp_fsm(peer, EVNT_CON_FATAL);
		return;
	}
	start_timer_keepalive(peer);
}

void
session_update(struct peer *peer)
{
	start_timer_keepalive(peer);
}

void
session_notification(struct peer *peer, u_int8_t errcode, u_int8_t subcode,
    void *data, ssize_t datalen)
{
	struct msg_header	 msg;
	struct buf		*buf;
	ssize_t			 len;
	int			 errs = 0;

	len = MSGSIZE_NOTIFICATION_MIN + datalen;

	memset(&msg.marker, 0xff, sizeof(msg.marker));
	msg.len = htons(len);
	msg.type = NOTIFICATION;

	if ((buf = buf_open(len)) == NULL)
		bgp_fsm(peer, EVNT_CON_FATAL);
	errs += buf_add(buf, &msg.marker, sizeof(msg.marker));
	errs += buf_add(buf, &msg.len, sizeof(msg.len));
	errs += buf_add(buf, &msg.type, sizeof(msg.type));
	errs += buf_add(buf, &errcode, sizeof(errcode));
	errs += buf_add(buf, &subcode, sizeof(subcode));

	if (datalen > 0)
		errs += buf_add(buf, data, datalen);

	if (errs > 0) {
		buf_free(buf);
		bgp_fsm(peer, EVNT_CON_FATAL);
		return;
	}

	if (buf_close(&peer->wbuf, buf) == -1) {
		buf_free(buf);
		bgp_fsm(peer, EVNT_CON_FATAL);
	}
}

int
session_dispatch_msg(struct pollfd *pfd, struct peer *peer)
{
	ssize_t		n, read_total;
	socklen_t	len;
	int		error;

	if (peer->state == STATE_CONNECT) {
		if (pfd->revents & POLLOUT) {
			if (pfd->revents & POLLIN) {
				/* error occured */
				len = sizeof(error);
				if (getsockopt(pfd->fd, SOL_SOCKET, SO_ERROR,
				    &error, &len) == -1)
					logit(LOG_CRIT, "unknown socket error");
				else {
					errno = error;
					log_err(peer, "socket error");
				}
				bgp_fsm(peer, EVNT_CON_OPENFAIL);
			} else
				bgp_fsm(peer, EVNT_CON_OPEN);
			return (1);
		}
		if (pfd->revents & POLLHUP) {
			bgp_fsm(peer, EVNT_CON_OPENFAIL);
			return (1);
		}
		if (pfd->revents & (POLLERR|POLLNVAL)) {
			bgp_fsm(peer, EVNT_CON_FATAL);
			return (1);
		}
		return (0);
	}

	if (pfd->revents & POLLHUP) {
		bgp_fsm(peer, EVNT_CON_CLOSED);
		return (1);
	}
	if (pfd->revents & (POLLERR|POLLNVAL)) {
		bgp_fsm(peer, EVNT_CON_FATAL);
		return (1);
	}

	if (pfd->revents & POLLOUT && peer->wbuf.queued) {
		if (msgbuf_write(&peer->wbuf))
			bgp_fsm(peer, EVNT_CON_FATAL);
		if (!(pfd->revents & POLLIN))
			return (1);
	}

	if (pfd->revents & POLLIN) {
		read_total = 0;
		do {
			if ((n = read(peer->sock, peer->rbuf->wptr,
			    peer->rbuf->pkt_len - peer->rbuf->read_len)) ==
			    -1) {
				if (errno != EAGAIN && errno != EINTR) {
					log_err(peer, "read error");
					bgp_fsm(peer, EVNT_CON_FATAL);
				}
				return (1);
			}
			read_total += n;
			peer->rbuf->wptr += n;
			peer->rbuf->read_len += n;
			if (peer->rbuf->read_len == peer->rbuf->pkt_len) {
				if (!peer->rbuf->seen_hdr) {	/* got header */
					if (parse_header(peer,
					    peer->rbuf->buf,
					    &peer->rbuf->pkt_len,
					    &peer->rbuf->type) == 1) {
						bgp_fsm(peer, EVNT_CON_FATAL);
						return (1);
					}
					peer->rbuf->seen_hdr = 1;
				} else {	/* we got the full packet */
					switch (peer->rbuf->type) {
					case OPEN:
						bgp_fsm(peer, EVNT_RCVD_OPEN);
						break;
					case UPDATE:
						bgp_fsm(peer, EVNT_RCVD_UPDATE);
						break;
					case NOTIFICATION:
						bgp_fsm(peer,
						    EVNT_RCVD_NOTIFICATION);
						break;
					case KEEPALIVE:
						bgp_fsm(peer,
						    EVNT_RCVD_KEEPALIVE);
						break;
					default:	/* cannot happen */
						session_notification(peer,
						    ERR_HEADER, ERR_HDR_TYPE,
						    &peer->rbuf->type, 1);
						logit(LOG_CRIT,
						    "received message with "
						    "unknown type %u",
						    peer->rbuf->type);
					}
					n = 0;	/* give others a chance... */
					if (peer->rbuf != NULL) {
						bzero(peer->rbuf,
						    sizeof(struct peer_buf_read));
						peer->rbuf->wptr =
						    peer->rbuf->buf;
						peer->rbuf->pkt_len =
						    MSGSIZE_HEADER;
					}
				}
			}
		} while (n > 0);
		if (read_total == 0) /* connection closed */
			bgp_fsm(peer, EVNT_CON_CLOSED);
		return (1);
	}

	return (0);
}

int
parse_header(struct peer *peer, u_char *data, u_int16_t *len, u_int8_t *type)
{
	u_char		*p;
	u_char		 one = 0xff;
	int		 i;
	u_int16_t	 olen;

	/* caller MUST make sure we are getting 19 bytes! */
	p = data;
	for (i = 0; i < 16; i++) {
		if (memcmp(p, &one, 1)) {
			log_errx(peer, "received message: sync error");
			session_notification(peer, ERR_HEADER, ERR_HDR_SYNC,
			    NULL, 0);
			bgp_fsm(peer, EVNT_CON_FATAL);
			return (-1);
		}
		p++;
	}
	memcpy(&olen, p, 2);
	*len = ntohs(olen);
	p += 2;
	memcpy(type, p, 1);

	if (*len < MSGSIZE_HEADER || *len > MAX_PKTSIZE) {
		log_errx(peer, "received message: illegal length: %u byte",
		    *len);
		session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
		    &olen, sizeof(olen));
		return (-1);
	}

	switch (*type) {
	case OPEN:
		if (*len < MSGSIZE_OPEN_MIN) {
			log_errx(peer,
			    "received OPEN: illegal len: %u byte", *len);
			session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
			    &olen, sizeof(olen));
			return (-1);
		}
		break;
	case NOTIFICATION:
		if (*len < MSGSIZE_NOTIFICATION_MIN) {
			log_errx(peer,
			    "received NOTIFICATION: illegal len: %u byte",
			    *len);
			session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
			    &olen, sizeof(olen));
			return (-1);
		}
		break;
	case UPDATE:
		if (*len < MSGSIZE_UPDATE_MIN) {
			log_errx(peer,
			    "received UPDATE: illegal len: %u byte", *len);
			session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
			    &olen, sizeof(olen));
			return (-1);
		}
		break;
	case KEEPALIVE:
		if (*len != MSGSIZE_KEEPALIVE) {
			log_errx(peer,
			    "received KEEPALIVE: illegal len: %u byte", *len);
			session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
			    &olen, sizeof(olen));
			return (-1);
		}
		break;
	default:
		log_errx(peer, "received msg with unknown type %u", *type);
		session_notification(peer, ERR_HEADER, ERR_HDR_TYPE,
		    type, 1);
		return (-1);
	}
	return (0);
}

int
parse_open(struct peer *peer)
{
	u_char		*p;
	u_int8_t	 version;
	u_int16_t	 as;
	u_int16_t	 holdtime, oholdtime;
	u_int32_t	 bgpid;
	u_int8_t	 optparamlen;

	p = peer->rbuf->buf;
	p += MSGSIZE_HEADER;	/* header is already checked */

	memcpy(&version, p, sizeof(version));
	p += sizeof(version);

	if (version != BGP_VERSION) {
		if (version > BGP_VERSION)
			log_errx(peer, "peer wants unrecognized version %u",
			    version);
			session_notification(peer, ERR_OPEN,
			    ERR_OPEN_VERSION, &version, sizeof(version));
		return (-1);
	}

	memcpy(&as, p, sizeof(as));
	p += sizeof(as);

	if (peer->conf.remote_as != ntohs(as)) {
		log_errx(peer, "peer AS %u unacceptable", ntohs(as));
		session_notification(peer, ERR_OPEN, ERR_OPEN_AS, NULL, 0);
		return (-1);
	}

	memcpy(&oholdtime, p, sizeof(oholdtime));
	p += sizeof(oholdtime);

	holdtime = ntohs(oholdtime);
	if (holdtime && holdtime < conf->min_holdtime) {
		log_errx(peer, "peer requests unacceptable holdtime %u",
		    holdtime);
		session_notification(peer, ERR_OPEN, ERR_OPEN_HOLDTIME,
		    NULL, 0);
		return (-1);
	}
	if (holdtime < conf->holdtime)
		peer->holdtime = holdtime;
	else
		peer->holdtime = conf->holdtime;

	memcpy(&bgpid, p, sizeof(bgpid));
	p += sizeof(bgpid);

	/* check bgpid for validity, must be a valid ip address - HOW? */
	/* if ( bgpid invalid ) {
		log_errx(peer, "peer BGPID %lu unacceptable", ntohl(bgpid));
		session_notification(peer, ERR_OPEN, ERR_OPEN_BGPID,
		    NULL, 0);
		return (-1);
	} */
	peer->remote_bgpid = ntohl(bgpid);

	memcpy(&optparamlen, p, sizeof(optparamlen));
	p += sizeof(optparamlen);

	/* handle opt params... */

	return (0);
}

int
parse_update(struct peer *peer)
{
	u_char		*p;
	u_int16_t	 datalen;

	/*
	 * we pass the message verbatim to the rde.
	 * in case of errors the whole session is reset with a
	 * notification anyway, we only need to know the peer
	 */
	p = peer->rbuf->buf;
	p += MSGSIZE_HEADER_MARKER;
	memcpy(&datalen, p, sizeof(datalen));
	datalen = ntohs(datalen);

	p = peer->rbuf->buf;
	p += MSGSIZE_HEADER;	/* header is already checked */
	datalen -= MSGSIZE_HEADER;

	imsg_compose(&ibuf_rde, IMSG_UPDATE, peer->conf.id, p, datalen);

	return (0);
}

int
parse_notification(struct peer *peer)
{
	u_char		*p;
	u_int8_t	 errcode;
	u_int8_t	 subcode;
	u_int16_t	 datalen;

	/* just log */
	p = peer->rbuf->buf;
	p += MSGSIZE_HEADER_MARKER;
	memcpy(&datalen, p, sizeof(datalen));
	datalen = ntohs(datalen);

	p = peer->rbuf->buf;
	p += MSGSIZE_HEADER;	/* header is already checked */
	datalen -= MSGSIZE_HEADER;

	memcpy(&errcode, p, sizeof(errcode));
	p += sizeof(errcode);
	datalen -= sizeof(errcode);

	memcpy(&subcode, p, sizeof(subcode));
	p += sizeof(subcode);
	datalen -= sizeof(subcode);

	/* read & parse data section if needed */

	/* log */
	log_notification(peer, errcode, subcode, p, datalen);

	return (0);
}

void
session_dispatch_imsg(struct imsgbuf *ibuf, int idx)
{
	struct imsg		 imsg;
	struct peer_config	*pconf;
	struct peer		*p, *next;
	enum reconf_action	 reconf;

	if (imsg_get(ibuf, &imsg) > 0) {
		switch (imsg.hdr.type) {
		case IMSG_RECONF_CONF:
			if (idx != PFD_PIPE_MAIN)
				fatal("reconf request not from parent", 0);
			if ((nconf = malloc(sizeof(struct bgpd_config))) ==
			    NULL)
				fatal(NULL, errno);
			memcpy(nconf, imsg.data, sizeof(struct bgpd_config));
			nconf->peers = NULL;
			init_conf(nconf);
			pending_reconf = 1;
			break;
		case IMSG_RECONF_PEER:
			if (idx != PFD_PIPE_MAIN)
				fatal("reconf request not from parent", 0);
			pconf = imsg.data;
			p = getpeerbyip(pconf->remote_addr.sin_addr.s_addr);
			if (p == NULL) {
				if ((p = calloc(1, sizeof(struct peer))) ==
				    NULL)
					fatal("new_peer", errno);
				p->state = STATE_NONE;
				p->sock = -1;
				p->next = nconf->peers;
				nconf->peers = p;
				reconf = RECONF_REINIT;
			} else
				reconf = RECONF_KEEP;

			if (bcmp(&p->conf.remote_addr, &pconf->remote_addr,
			    sizeof(struct sockaddr_in)))
				reconf = RECONF_REINIT;
			if (bcmp(&p->conf.local_addr, &pconf->local_addr,
			    sizeof(struct sockaddr_in)))
				reconf = RECONF_REINIT;
			if (p->conf.remote_as != pconf->remote_as)
				reconf = RECONF_REINIT;
			if (p->conf.distance != pconf->distance)
				reconf = RECONF_REINIT;

			memcpy(&p->conf, pconf, sizeof(struct peer_config));
			p->conf.reconf_action = reconf;
			if (pconf->reconf_action > reconf)
				p->conf.reconf_action = pconf->reconf_action;

			if (p->state >= STATE_OPENSENT) {
				if (p->holdtime == conf->holdtime &&
				    nconf->holdtime > conf->holdtime)
					p->conf.reconf_action = RECONF_REINIT;
				if (p->holdtime > nconf->holdtime)
					p->conf.reconf_action = RECONF_REINIT;
				if (p->holdtime < nconf->min_holdtime)
					p->conf.reconf_action = RECONF_REINIT;
			}
			break;
		case IMSG_RECONF_DONE:
			if (idx != PFD_PIPE_MAIN)
				fatal("reconf request not from parent", 0);
			if (nconf == NULL)
				fatal("got IMSG_RECONF_DONE but no config", 0);
			conf->as = nconf->as;
			conf->holdtime = nconf->holdtime;
			conf->bgpid = nconf->bgpid;
			conf->min_holdtime = nconf->min_holdtime;
			/* add new peers */
			for (p = nconf->peers; p != NULL; p = next) {
				next = p->next;
				p->next = conf->peers;
				conf->peers = p;
			}
			/* find peers to be deleted */
			for (p = conf->peers; p != NULL; p = p->next)
				if (p->conf.reconf_action == RECONF_NONE)
					p->conf.reconf_action = RECONF_DELETE;
			free(nconf);
			nconf = NULL;
			pending_reconf = 0;
			logit(LOG_INFO, "SE reconfigured");
			break;
		default:
		}
		imsg_free(&imsg);
	}
}

struct peer *
getpeerbyip(in_addr_t ip)
{
	struct peer *p;

	/* we might want a more effective way to find peers by IP */
	for (p = conf->peers; p != NULL &&
	    p->conf.remote_addr.sin_addr.s_addr != ip; p = p->next)
		;	/* nothing */

	return (p);
}

void
session_down(struct peer *peer)
{
	if (!session_quit)
		imsg_compose(&ibuf_rde, IMSG_SESSION_DOWN, peer->conf.id,
		    NULL, 0);
}

void
session_up(struct peer *peer)
{
	imsg_compose(&ibuf_rde, IMSG_SESSION_UP, peer->conf.id,
	    &peer->remote_bgpid, sizeof(peer->remote_bgpid));
}
@


1.1.1.1
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@@


1.1.1.2
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.54 2004/01/01 23:46:47 henning Exp $ */
a24 1
#include <sys/un.h>
d48 1
a48 2
#define	PFD_SOCK_CTL	3
#define PFD_PEERS_START	4
d81 1
a81 1
struct bgpd_config	*nconf = NULL;
a83 2
int			 sock = -1;
int			 csock = -1;
d100 2
a101 1
	int			 fd, opt;
d103 1
a103 1
	if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
d109 6
a114 2
	if (bind(fd, (struct sockaddr *)&conf->listen_addr,
	    sizeof(conf->listen_addr))) {
a117 3

	session_socket_blockmode(fd, BM_NONBLOCK);

d122 4
d134 1
a134 1
	int		 nfds, i, j, timeout, npeers;
a139 1
	struct ctl_conn	*ctl_conn;
d145 1
a145 1
		fatal("cannot fork");
d153 1
a153 1
		fatal(NULL);
d155 2
a156 2
	if (chroot(pw->pw_dir) == -1)
		fatal("chroot failed");
d162 2
a163 2
	if ((sock = setup_listener()) == -1)
		fatalx("listener setup failed");
d168 1
a168 1
		fatal("can't drop privileges");
a178 2
	TAILQ_INIT(&ctl_conns);
	csock = control_listen();
a190 2
		pfd[PFD_SOCK_CTL].fd = csock;
		pfd[PFD_SOCK_CTL].events = POLLIN;
d212 1
a212 1
					log_peer_errx(p, "removed");
a257 10
		npeers = i;

		TAILQ_FOREACH(ctl_conn, &ctl_conns, entries) {
			pfd[i].fd = ctl_conn->ibuf.sock;
			pfd[i].events = POLLIN;
			if (ctl_conn->ibuf.w.queued > 0)
				pfd[i].events |= POLLOUT;
			i++;
		}

d276 2
a277 2
			if (msgbuf_write(&ibuf_rde.w) < 0)
				fatal("pipe write error");
d284 2
a285 3
		if (nfds > 0 && pfd[PFD_SOCK_CTL].revents & POLLIN) {
			nfds--;
			control_accept(csock);
a286 6

		for (j = PFD_PEERS_START; nfds > 0 && j < npeers; j++)
			nfds -= session_dispatch_msg(&pfd[j], peers[j]);

		for (; nfds > 0 && j < i; j++)
			nfds -= control_dispatch_msg(&pfd[j], j);
d289 3
a291 1
	control_shutdown();
d330 2
d334 1
a334 1
			peer->rbuf = calloc(1, sizeof(struct buf_read));
d336 3
a338 2
				fatal(NULL);
			peer->rbuf->wpos = 0;
d343 2
a344 9
			if (peer->conf.passive) {
				change_state(peer, STATE_ACTIVE, event);
				peer->ConnectRetryTimer = 0;
			} else {
				change_state(peer, STATE_CONNECT, event);
				session_connect(peer);
				peer->ConnectRetryTimer =
				    time(NULL) + INTERVAL_CONNECTRETRY;
			}
a347 1
			break;
d397 1
a398 1
			session_connect(peer);
a568 4

	shutdown(sock, SHUT_RDWR);
	close(sock);
	sock = -1;
d580 1
a580 1
		 * session was not established successfully before, the
a620 1
		break;
d677 2
a678 2
	if ((peer->sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
		log_peer_err(peer, "session_connect socket");
d689 1
a689 1
			log_peer_err(peer, "session_connect bind");
d694 6
a704 2
	session_socket_blockmode(peer->sock, BM_NONBLOCK);

d706 1
a706 1
	    sizeof(peer->conf.remote_addr))) == -1)
d708 1
a708 1
			log_peer_err(peer, "connect");
d730 1
a730 1
			log_peer_err(p, "session_setup_socket setsockopt TTL");
d737 1
a737 1
		log_peer_err(p, "session_setup_socket setsockopt TCP_NODELAY");
d743 1
a743 1
		log_peer_err(p, "session_setup_socket setsockopt TOS");
a750 17
session_socket_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fnctl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fnctl F_SETFL");
}

void
d756 1
a756 3
	int		 errs = 0, n;

	session_socket_blockmode(peer->sock, BM_NORMAL);
d769 1
a769 1
	if ((buf = buf_open(len)) == NULL) {
a770 2
		return;
	}
d781 1
a781 5
		if ((n = buf_close(&peer->wbuf, buf)) < 0) {
			if (n == -2)
				log_peer_errx(peer, "Connection closed");
			else
				log_peer_err(peer, "Write error");
d797 1
a797 1
	int			 errs = 0, n;
d805 1
a805 1
	if ((buf = buf_open(len)) == NULL) {
a806 2
		return;
	}
d817 1
a817 5
	if ((n = buf_close(&peer->wbuf, buf)) < 0) {
		if (n == -2)
			log_peer_errx(peer, "Connection closed");
		else
			log_peer_err(peer, "Write error");
a821 1

d838 1
a838 1
	int			 errs = 0, n;
d846 1
a846 1
	if ((buf = buf_open(len)) == NULL) {
a847 2
		return;
	}
d863 1
a863 5
	if ((n = buf_close(&peer->wbuf, buf)) < 0) {
		if (n == -2)
			log_peer_errx(peer, "Connection closed");
		else
			log_peer_err(peer, "Write error");
d872 1
a872 1
	ssize_t		n, rpos, av, left;
a874 2
	u_int16_t	msglen;
	u_int8_t	msgtype;
d879 1
a879 1
				/* error occurred */
d886 1
a886 1
					log_peer_err(peer, "socket error");
d914 1
a914 5
		if ((error = msgbuf_write(&peer->wbuf)) < 0) {
			if (error == -2)
				log_peer_errx(peer, "Connection closed");
			else
				log_peer_err(peer, "Write error");
a915 1
		}
d921 4
a924 2
		if ((n = read(peer->sock, peer->rbuf->buf + peer->rbuf->wpos,
			    sizeof(peer->rbuf->buf) - peer->rbuf->wpos)) ==
d926 2
a927 2
				if (errno != EINTR) {
					log_peer_err(peer, "read error");
d932 47
a978 37
			if (n == 0) {	/* connection closed */
				bgp_fsm(peer, EVNT_CON_CLOSED);
				return (1);
			}

			rpos = 0;
			av = peer->rbuf->wpos + n;

			for (;;) {
				if (rpos + MSGSIZE_HEADER > av)
					break;
				if (parse_header(peer, peer->rbuf->buf + rpos,
				    &msglen, &msgtype) == -1)
					return (0);
				if (rpos + msglen > av)
					break;
				peer->rbuf->rptr = peer->rbuf->buf + rpos;

				switch (msgtype) {
				case OPEN:
					bgp_fsm(peer, EVNT_RCVD_OPEN);
					break;
				case UPDATE:
					bgp_fsm(peer, EVNT_RCVD_UPDATE);
					break;
				case NOTIFICATION:
					bgp_fsm(peer, EVNT_RCVD_NOTIFICATION);
					break;
				case KEEPALIVE:
					bgp_fsm(peer, EVNT_RCVD_KEEPALIVE);
					break;
				default:	/* cannot happen */
					session_notification(peer, ERR_HEADER,
					    ERR_HDR_TYPE, &msgtype, 1);
					logit(LOG_CRIT,
					    "received message with unknown type"
					    " %u", msgtype);
a979 1
				rpos += msglen;
d981 3
a983 8
			if (rpos < av) {
				left = av - rpos;
				memcpy(&peer->rbuf->buf, peer->rbuf->buf + rpos,
				    left);
				peer->rbuf->wpos = left;
			} else
				peer->rbuf->wpos = 0;

d986 1
d1002 1
a1002 1
			log_peer_errx(peer, "received message: sync error");
d1016 1
a1016 1
		log_peer_errx(peer, "received message: illegal length: %u byte",
d1026 1
a1026 1
			log_peer_errx(peer,
d1035 1
a1035 1
			log_peer_errx(peer,
d1045 1
a1045 1
			log_peer_errx(peer,
d1054 1
a1054 1
			log_peer_errx(peer,
d1062 1
a1062 1
		log_peer_errx(peer, "received msg with unknown type %u", *type);
d1080 1
a1080 1
	p = peer->rbuf->rptr;
d1088 2
a1089 2
			log_peer_errx(peer,
			    "peer wants unrecognized version %u", version);
d1099 1
a1099 1
		log_peer_errx(peer, "peer AS %u unacceptable", ntohs(as));
d1109 1
a1109 1
		log_peer_errx(peer, "peer requests unacceptable holdtime %u",
d1125 1
a1125 2
		log_peer_errx(peer, "peer BGPID %lu unacceptable",
		    ntohl(bgpid));
d1151 1
a1151 1
	p = peer->rbuf->rptr;
d1156 1
a1156 1
	p = peer->rbuf->rptr;
d1160 1
a1160 3
	if (imsg_compose(&ibuf_rde, IMSG_UPDATE, peer->conf.id, p,
	    datalen) == -1)
		return (-1);
d1174 1
a1174 1
	p = peer->rbuf->rptr;
d1179 1
a1179 1
	p = peer->rbuf->rptr;
a1205 11
	int			 n;

	if (imsg_read(ibuf) == -1)
		fatal("session_dispatch_imsg: imsg_read error");

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("session_dispatch_imsg: imsg_get error");

		if (n == 0)
			break;
d1207 1
d1211 1
a1211 1
				fatalx("reconf request not from parent");
d1214 1
a1214 1
				fatal(NULL);
d1222 1
a1222 1
				fatalx("reconf request not from parent");
d1228 1
a1228 1
					fatal("new_peer");
a1247 4
			if (p->state <= STATE_ACTIVE &&
			    p->conf.passive && !pconf->passive)
				reconf = RECONF_REINIT;

d1265 1
a1265 1
				fatalx("reconf request not from parent");
d1267 1
a1267 1
				fatalx("got IMSG_RECONF_DONE but no config");
a1287 1
			break;
d1309 3
a1311 3
	if (imsg_compose(&ibuf_rde, IMSG_SESSION_DOWN, peer->conf.id,
	    NULL, 0) == -1)
		fatalx("imsg_compose error");
d1317 2
a1318 3
	if (imsg_compose(&ibuf_rde, IMSG_SESSION_UP, peer->conf.id,
	    &peer->remote_bgpid, sizeof(peer->remote_bgpid)) == -1)
		fatalx("imsg_compose error");
@


1.1.1.3
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.94 2004/01/23 18:06:01 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
a43 1
#include "mrt.h"
d55 2
a56 1
void	init_peer(struct peer *);
a65 1
void	session_tcp_established(struct peer *);
d68 1
a68 1
void	session_update(u_int32_t, void *, size_t);
d81 1
a81 1
struct peer	*getpeerbyid(u_int32_t);
d83 1
a83 2
struct bgpd_config	*conf, *nconf = NULL;
struct peer		*npeers;
a90 3
int			 mrt_flagall = 0;
struct mrt_config	 mrt_allin;

d130 1
a130 2
session_main(struct bgpd_config *config, struct peer *cpeers, int pipe_m2s[2],
    int pipe_s2r[2])
d132 1
a132 1
	int		 nfds, i, j, timeout, idx_peers;
d136 1
a136 1
	struct peer	*p, *peer_l[OPEN_MAX], *last, *next;
a138 1
	short		 events;
a140 1
	peers = cpeers;
d172 1
a172 2
	signal(SIGPIPE, SIG_IGN);
	log_info("session engine ready");
d180 1
a187 2
		if (ibuf_main.w.queued > 0)
			pfd[PFD_PIPE_MAIN].events |= POLLOUT;
d199 1
a199 1
		for (p = peers; p != NULL; p = next) {
d204 1
a204 1
					init_peer(p);
d209 1
a209 1
					p->IdleHoldTimer = time(NULL);
d215 1
a215 1
					log_peer_warnx(&p->conf, "removed");
d219 1
a219 1
						peers = next;
d234 1
a234 1
			if (timer_due(p->IdleHoldTimer))
a235 11
			if (timer_due(p->IdleHoldResetTimer)) {
				p->IdleHoldTime /= 2;
				if (p->IdleHoldTime <=
				    INTERVAL_IDLE_HOLD_INITIAL) {
					p->IdleHoldTime =
					    INTERVAL_IDLE_HOLD_INITIAL;
					p->IdleHoldResetTimer = 0;
				} else
					p->IdleHoldResetTimer =
					    time(NULL) + p->IdleHoldTime;
			}
d245 2
a246 5
			if (p->IdleHoldTimer && p->IdleHoldTimer < nextaction)
				nextaction = p->IdleHoldTimer;
			if (p->IdleHoldResetTimer &&
			    p->IdleHoldResetTimer < nextaction)
				nextaction = p->IdleHoldResetTimer;
d249 2
a250 3
			events = POLLIN;
			if (p->wbuf.queued > 0 || p->state == STATE_CONNECT)
				events |= POLLOUT;
d253 1
a253 1
			if (p->sock != -1 && events != 0) {
d255 2
a256 2
				pfd[i].events = events;
				peer_l[i] = p;
d261 1
a261 1
		idx_peers = i;
d274 4
a277 4
		if ((nfds = poll(pfd, i, timeout * 1000)) == -1)
			if (errno != EINTR)
				fatal("poll error");

a282 4
		if (nfds > 0 && pfd[PFD_PIPE_MAIN].revents & POLLOUT)
			if (msgbuf_write(&ibuf_main.w) < 0)
				fatal("pipe write error");

d302 2
a303 2
		for (j = PFD_PEERS_START; nfds > 0 && j < idx_peers; j++)
			nfds -= session_dispatch_msg(&pfd[j], peer_l[j]);
d310 1
a310 1
	log_info("session engine exiting");
d322 1
a322 1
init_peer(struct peer *p)
d324 1
a324 1
	p->sock = -1;
d326 6
a331 2
	change_state(p, STATE_IDLE, EVNT_NONE);
	p->IdleHoldTimer = time(NULL);	/* start ASAP */
d346 2
a347 1
			peer->IdleHoldTimer = 0;
a378 1
			session_tcp_established(peer);
a404 1
			session_tcp_established(peer);
d590 1
a590 1
	for (p = peers; p != NULL; p = p->next)
d610 3
a612 2
		if (peer->IdleHoldTime == 0)
			peer->IdleHoldTime = INTERVAL_IDLE_HOLD_INITIAL;
a616 1
		peer->IdleHoldResetTimer = 0;
d624 4
a627 4
			peer->IdleHoldTimer = time(NULL) + peer->IdleHoldTime;
			if (event != EVNT_NONE &&
			    peer->IdleHoldTime < MAX_IDLE_HOLD/2)
				peer->IdleHoldTime *= 2;
d631 1
d634 1
d637 1
d640 1
d643 2
a644 3
		if (peer->IdleHoldTime > INTERVAL_IDLE_HOLD_INITIAL)
			peer->IdleHoldResetTimer =
			    time(NULL) + peer->IdleHoldTime;
a651 4
	if (mrt_flagall == 1)
		mrt_dump_state(&mrt_allin, peer->state, state,
		    &peer->conf, conf);
	/* XXX mrt dump per peer */
d663 2
d669 1
d672 2
a673 1
			log_warn("accept");
d680 2
a681 6
		if (p->sock != -1) {
			shutdown(connfd, SHUT_RDWR);
			close(connfd);
			return;
		}
		p->sock = p->wbuf.sock = connfd;
d700 3
a702 6
	/*
	 * we do not need the overcomplicated collision detection rfc1771
	 * decribes; we simply make sure there is only ever one concurrent
	 * tcp connection per peer.
	 */
	if (peer->sock != -1)
d706 1
a706 1
		log_peer_warn(&peer->conf, "session_connect socket");
d717 1
a717 1
			log_peer_warn(&peer->conf, "session_connect bind");
d732 1
a732 1
			log_peer_warn(&peer->conf, "connect");
d754 1
a754 2
			log_peer_warn(&p->conf,
			    "session_setup_socket setsockopt TTL");
d761 1
a761 2
		log_peer_warn(&p->conf,
		    "session_setup_socket setsockopt TCP_NODELAY");
d767 1
a767 2
		log_peer_warn(&p->conf,
		    "session_setup_socket setsockopt TOS");
d792 1
a792 15
session_tcp_established(struct peer *peer)
{
	socklen_t	len;

	session_socket_blockmode(peer->sock, BM_NORMAL);
	if (getsockname(peer->sock, (struct sockaddr *)&peer->sa_local,
	    &len) == -1)
		log_warn("getsockname");
	if (getpeername(peer->sock, (struct sockaddr *)&peer->sa_remote,
	    &len) == -1)
		log_warn("getpeername");
}

void
session_open(struct peer *p)
d799 2
d808 1
a808 4
	if (p->conf.holdtime)
		msg.holdtime = htons(p->conf.holdtime);
	else
		msg.holdtime = htons(conf->holdtime);
d813 1
a813 1
		bgp_fsm(p, EVNT_CON_FATAL);
d826 1
a826 1
		if ((n = buf_close(&p->wbuf, buf)) < 0) {
d828 1
a828 1
				log_peer_warnx(&p->conf, "Connection closed");
d830 1
a830 1
				log_peer_warn(&p->conf, "Write error");
d832 1
a832 1
			bgp_fsm(p, EVNT_CON_FATAL);
d836 1
a836 1
		bgp_fsm(p, EVNT_CON_FATAL);
a837 2

	p->stats.msg_sent_open++;
d870 1
a870 1
			log_peer_warnx(&peer->conf, "Connection closed");
d872 1
a872 1
			log_peer_warn(&peer->conf, "Write error");
a878 1
	peer->stats.msg_sent_keepalive++;
d882 1
a882 1
session_update(u_int32_t peerid, void *data, size_t datalen)
d884 1
a884 43
	struct peer		*p;
	struct msg_header	 msg;
	struct buf		*buf;
	ssize_t			 len;
	int			 errs = 0, n;

	if ((p = getpeerbyid(peerid)) == NULL) {
		log_warnx("no such peer: id=%u", peerid);
		return;
	}

	len = MSGSIZE_HEADER + datalen;

	memset(&msg.marker, 0xff, sizeof(msg.marker));
	msg.len = htons(len);
	msg.type = UPDATE;

	if ((buf = buf_open(len)) == NULL) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}
	errs += buf_add(buf, &msg.marker, sizeof(msg.marker));
	errs += buf_add(buf, &msg.len, sizeof(msg.len));
	errs += buf_add(buf, &msg.type, sizeof(msg.type));
	errs += buf_add(buf, data, datalen);

	if (errs > 0) {
		buf_free(buf);
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	if ((n = buf_close(&p->wbuf, buf)) < 0) {
		if (n == -2)
			log_peer_warnx(&p->conf, "Connection closed");
		else
			log_peer_warn(&p->conf, "Write error");
		buf_free(buf);
		bgp_fsm(p, EVNT_CON_FATAL);
	}

	start_timer_keepalive(p);
	p->stats.msg_sent_update++;
d923 1
a923 1
			log_peer_warnx(&peer->conf, "Connection closed");
d925 1
a925 1
			log_peer_warn(&peer->conf, "Write error");
a928 1
	peer->stats.msg_sent_notification++;
d932 1
a932 1
session_dispatch_msg(struct pollfd *pfd, struct peer *p)
d940 1
a940 1
	if (p->state == STATE_CONNECT) {
d947 1
a947 1
					log_warnx("unknown socket error");
d950 1
a950 1
					log_peer_warn(&p->conf, "socket error");
d952 1
a952 1
				bgp_fsm(p, EVNT_CON_OPENFAIL);
d954 1
a954 1
				bgp_fsm(p, EVNT_CON_OPEN);
d958 1
a958 1
			bgp_fsm(p, EVNT_CON_OPENFAIL);
d962 1
a962 1
			bgp_fsm(p, EVNT_CON_FATAL);
d969 1
a969 1
		bgp_fsm(p, EVNT_CON_CLOSED);
d973 1
a973 1
		bgp_fsm(p, EVNT_CON_FATAL);
d977 2
a978 2
	if (pfd->revents & POLLOUT && p->wbuf.queued) {
		if ((error = msgbuf_write(&p->wbuf)) < 0) {
d980 1
a980 1
				log_peer_warnx(&p->conf, "Connection closed");
d982 2
a983 2
				log_peer_warn(&p->conf, "Write error");
			bgp_fsm(p, EVNT_CON_FATAL);
d990 2
a991 2
		if ((n = read(p->sock, p->rbuf->buf + p->rbuf->wpos,
			    sizeof(p->rbuf->buf) - p->rbuf->wpos)) ==
d994 2
a995 2
					log_peer_warn(&p->conf, "read error");
					bgp_fsm(p, EVNT_CON_FATAL);
d1000 1
a1000 1
				bgp_fsm(p, EVNT_CON_CLOSED);
d1005 1
a1005 2
			av = p->rbuf->wpos + n;
			p->stats.last_read = time(NULL);
a1006 4
			/*
			 * session might drop to IDLE -> buffers deallocated
			 * we MUST check rbuf != NULL before use
			 */
d1010 1
a1010 3
				if (p->rbuf == NULL)
					break;
				if (parse_header(p, p->rbuf->buf + rpos,
d1015 1
a1015 1
				p->rbuf->rptr = p->rbuf->buf + rpos;
d1019 1
a1019 2
					bgp_fsm(p, EVNT_RCVD_OPEN);
					p->stats.msg_rcvd_open++;
d1022 1
a1022 2
					bgp_fsm(p, EVNT_RCVD_UPDATE);
					p->stats.msg_rcvd_update++;
d1025 1
a1025 2
					bgp_fsm(p, EVNT_RCVD_NOTIFICATION);
					p->stats.msg_rcvd_notification++;
d1028 1
a1028 2
					bgp_fsm(p, EVNT_RCVD_KEEPALIVE);
					p->stats.msg_rcvd_keepalive++;
d1031 1
a1031 1
					session_notification(p, ERR_HEADER,
d1033 3
a1035 2
					log_warnx("received message with "
					    "unknown type %u", msgtype);
a1038 3
			if (p->rbuf == NULL)
				return (1);

d1041 1
a1041 1
				memcpy(&p->rbuf->buf, p->rbuf->buf + rpos,
d1043 1
a1043 1
				p->rbuf->wpos = left;
d1045 1
a1045 1
				p->rbuf->wpos = 0;
d1064 1
a1064 1
			log_peer_warnx(&peer->conf, "sync error");
d1078 2
a1079 2
		log_peer_warnx(&peer->conf,
		    "received message: illegal length: %u byte", *len);
d1088 1
a1088 1
			log_peer_warnx(&peer->conf,
d1097 1
a1097 1
			log_peer_warnx(&peer->conf,
d1107 1
a1107 1
			log_peer_warnx(&peer->conf,
d1116 1
a1116 1
			log_peer_warnx(&peer->conf,
d1124 1
a1124 2
		log_peer_warnx(&peer->conf,
		    "received msg with unknown type %u", *type);
a1128 3
	if (mrt_flagall == 1)
		mrt_dump_bgp_msg(&mrt_allin, data, *len, 0, &peer->conf, conf);
	/* XXX mrt dump per peer */
d1138 1
a1138 1
	u_int16_t	 holdtime, oholdtime, myholdtime;
d1150 1
a1150 1
			log_peer_warnx(&peer->conf,
d1161 1
a1161 1
		log_peer_warnx(&peer->conf, "peer sent wrong AS %u", ntohs(as));
d1170 3
a1172 3
	if (holdtime && holdtime < peer->conf.min_holdtime) {
		log_peer_warnx(&peer->conf,
		    "peer requests unacceptable holdtime %u", holdtime);
d1177 1
a1177 5

	myholdtime = peer->conf.holdtime;
	if (!myholdtime)
		myholdtime = conf->holdtime;
	if (holdtime < myholdtime)
d1180 1
a1180 1
		peer->holdtime = myholdtime;
d1187 1
a1187 1
		log_peer_warnx(&peer->conf, "peer BGPID %lu unacceptable",
d1193 1
a1193 1
	peer->remote_bgpid = bgpid;
a1267 1
	struct mrt_config	 mrt;
a1271 1
	u_int8_t		 suberr;
d1273 1
a1273 1
	if ((n = imsg_read(ibuf)) == -1)
a1275 3
	if (n == 0)	/* connection closed */
		fatal("session_dispatch_imsg: pipe closed");

d1291 1
a1291 1
			npeers = NULL;
d1305 3
a1307 2
				p->next = npeers;
				npeers = p;
d1312 15
d1329 12
d1352 1
a1352 1
			for (p = npeers; p != NULL; p = next) {
d1354 2
a1355 2
				p->next = peers;
				peers = p;
d1358 1
a1358 1
			for (p = peers; p != NULL; p = p->next)
d1364 1
a1364 53
			log_info("SE reconfigured");
			break;
		case IMSG_MRT_REQ:
			memcpy(&mrt, imsg.data, sizeof(mrt));
			mrt.msgbuf = &ibuf_main.w;
			if (mrt.type == MRT_ALL_IN) {
				mrt_flagall = 1;
				memcpy(&mrt_allin, &mrt, sizeof(mrt_allin));
			}
			break;
		case IMSG_MRT_END:
			memcpy(&mrt, imsg.data, sizeof(mrt));
			if (mrt.type == MRT_ALL_IN) {
				mrt_flagall = 0;
				bzero(&mrt_allin, sizeof(mrt_allin));
			}
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
		case IMSG_CTL_SHOW_NEXTHOP:
		case IMSG_CTL_SHOW_INTERFACE:
		case IMSG_CTL_END:
			if (idx != PFD_PIPE_MAIN)
				fatalx("ctl kroute request not from parent");
			control_imsg_relay(&imsg);
			break;
		case IMSG_UPDATE:
			if (idx != PFD_PIPE_ROUTE)
				fatalx("update request not from RDE");
			if (imsg.hdr.len > IMSG_HEADER_SIZE +
			    MAX_PKTSIZE - MSGSIZE_HEADER ||
			    imsg.hdr.len < IMSG_HEADER_SIZE +
			    MSGSIZE_UPDATE_MIN - MSGSIZE_HEADER)
				log_warnx("RDE sent invalid update");
			else
				session_update(imsg.hdr.peerid, imsg.data,
				    imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_UPDATE_ERR:
			if (idx != PFD_PIPE_ROUTE)
				fatalx("update request not from RDE");
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(suberr)) {
				log_warnx("RDE sent invalid notification");
				break;
			}
			if ((p = getpeerbyid(imsg.hdr.peerid)) == NULL)
				log_warnx("no such peer: id=%u",
				    imsg.hdr.peerid);
			else {
				memcpy(&suberr, imsg.data, sizeof(suberr));
				session_notification(p, ERR_UPDATE, suberr,
				    NULL, 0);
			}
d1379 1
a1379 1
	for (p = peers; p != NULL &&
a1385 13
struct peer *
getpeerbyid(u_int32_t peerid)
{
	struct peer *p;

	/* we might want a more effective way to find peers by IP */
	for (p = peers; p != NULL &&
	    p->conf.id != peerid; p = p->next)
		;	/* nothing */

	return (p);
}

a1388 1
	peer->stats.last_updown = time(NULL);
a1396 18
	struct session_up	sup;

	sup.remote_bgpid = peer->remote_bgpid;

	switch (peer->sa_local.ss_family) {
	case AF_INET:
		sup.local_addr.af = AF_INET;
		sup.local_addr.v4 =
		    ((struct sockaddr_in *)&peer->sa_local)->sin_addr;
		sup.remote_addr.af = AF_INET;
		sup.remote_addr.v4 =
		    ((struct sockaddr_in *)&peer->sa_remote)->sin_addr;
		break;
	default:
		fatalx("session_up: only AF_INET supported");
	}

	peer->stats.last_updown = time(NULL);
d1398 1
a1398 1
	    &sup, sizeof(sup)) == -1)
a1399 6
}

int
imsg_compose_parent(int type, pid_t pid, void *data, u_int16_t datalen)
{
	return (imsg_compose_pid(&ibuf_main, type, pid, data, datalen));
@


1.1.1.4
log
@using: ========= cvsim-base-obsd _MirBSD: cvsim-src-openbsd,v 1.3 2004/01/27 17:17:54 tg Exp $ =========

In contrast to what people might believe now,
I am not "specially" attracted by CVS Imports
(neither am I a version number hunter).
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.95 2004/01/27 16:49:53 henning Exp $ */
d82 1
a82 3
struct peer		*getpeerbyaddr(struct bgpd_addr *);
struct peer		*getpeerbyid(u_int32_t);
static struct sockaddr	*addr2sa(struct bgpd_addr *, u_int16_t);
d725 1
a725 2
	int			 n;
	struct sockaddr		*sa;
d735 1
a735 2
	if ((peer->sock = socket(peer->conf.remote_addr.af, SOCK_STREAM,
	    IPPROTO_TCP)) == -1) {
d744 2
a745 2
	if (peer->conf.local_addr.af)
		if (bind(peer->sock, addr2sa(&peer->conf.local_addr, 0),
d759 2
a760 2
	sa = addr2sa(&peer->conf.remote_addr, BGP_PORT);
	if ((n = connect(peer->sock, sa, sa->sa_len)) == -1)
d1419 1
a1419 1
			p = getpeerbyaddr(&pconf->remote_addr);
a1517 14
getpeerbyaddr(struct bgpd_addr *addr)
{
	struct peer *p;

	/* we might want a more effective way to find peers by IP */
	for (p = peers; p != NULL &&
	    memcmp(&p->conf.remote_addr, addr, sizeof(p->conf.remote_addr));
	    p = p->next)
		;	/* nothing */

	return (p);
}

struct peer *
d1524 1
a1524 1
	    p->conf.remote_addr.v4.s_addr != ip; p = p->next)
a1581 27
}

static struct sockaddr *
addr2sa(struct bgpd_addr *addr, u_int16_t port)
{
	static struct sockaddr_storage	 ss;
	struct sockaddr_in		*sa_in = (struct sockaddr_in *)&ss;
	struct sockaddr_in6		*sa_in6 = (struct sockaddr_in6 *)&ss;

	bzero(&ss, sizeof(ss));
	switch (addr->af) {
	case AF_INET:
		sa_in->sin_family = AF_INET;
		sa_in->sin_len = sizeof(struct sockaddr_in);
		sa_in->sin_addr.s_addr = addr->v4.s_addr;
		sa_in->sin_port = htons(port);
		break;
	case AF_INET6:
		sa_in6->sin6_family = AF_INET6;
		sa_in6->sin6_len = sizeof(struct sockaddr_in6);
		memcpy(&sa_in6->sin6_addr, &addr->v6,
		    sizeof(sa_in6->sin6_addr));
		sa_in6->sin6_port = htons(port);
		break;
	}

	return ((struct sockaddr *)&ss);
@


1.1.1.5
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.169 2004/05/08 11:22:43 henning Exp $ */
d48 4
a51 5
#define	PFD_LISTEN6	1
#define PFD_PIPE_MAIN	2
#define PFD_PIPE_ROUTE	3
#define	PFD_SOCK_CTL	4
#define PFD_PEERS_START	5
d54 1
a54 1
int	setup_listener(struct sockaddr *);
d61 1
a75 1
int	parse_refresh(struct peer *);
a77 1
int	parse_capabilities(struct peer *, u_char *, u_int16_t);
d82 1
a82 2
struct peer		*getpeerbyip(struct sockaddr *);
int			 session_match_mask(struct peer *, struct sockaddr *);
a90 1
int			 sock6 = -1;
d95 2
a96 1
struct mrt_config_head	 mrt_l;
a101 1
	case SIGINT:
d109 1
a109 1
setup_listener(struct sockaddr *sa)
d111 1
a111 1
	int	fd, opt;
d113 1
a113 6
	if (sa->sa_family != AF_INET && sa->sa_family != AF_INET6)
		fatal("king bula sez: unknown address family");

	if ((fd = socket(sa->sa_family, SOCK_STREAM, IPPROTO_TCP)) == -1) {
		log_warn("error setting up %s listener",
		    sa->sa_family == AF_INET ? "IPv4" : "IPv6");
a114 1
	}
d117 1
a117 4
	if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt)) == -1)
		fatal("setsockopt SO_REUSEPORT");
	if (setsockopt(fd, IPPROTO_TCP, TCP_MD5SIG, &opt, sizeof(opt)) == -1)
		fatal("setsockopt TCP_MD5SIG");
d119 2
a120 1
	if (bind(fd, sa, sa->sa_len)) {
d122 1
a122 1
		fatal("bind");
d129 1
a129 1
		fatal("listen");
d135 1
d137 11
a147 16
session_main(struct bgpd_config *config, struct peer *cpeers,
    struct network_head *net_l, struct filter_head *rules,
    struct mrt_head *m_l, int pipe_m2s[2], int pipe_s2r[2])
{
	int			 nfds, i, j, timeout, idx_peers;
	pid_t			 pid;
	time_t			 nextaction;
	struct passwd		*pw;
	struct peer		*p, *peer_l[OPEN_MAX], *last, *next;
	struct network		*net;
	struct mrt		*m;
	struct mrt_config	*mrt;
	struct filter_rule	*r;
	struct pollfd		 pfd[OPEN_MAX];
	struct ctl_conn		*ctl_conn;
	short			 events;
a160 4
	/* control socket is outside chroot */
	if ((csock = control_init()) == -1)
		fatalx("control socket setup failed");

d165 2
a166 3
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");
d171 2
a172 5
	sock = setup_listener((struct sockaddr *)&conf->listen_addr);
	sock6 = setup_listener((struct sockaddr *)&conf->listen6_addr);

	if (pfkey_init() == -1)
		fatalx("pfkey setup failed");
a181 1
	signal(SIGINT, session_sighdlr);
a190 20
	LIST_INIT(&mrt_l);

	/* filter rules are not used in the SE */
	while ((r = TAILQ_FIRST(rules)) != NULL) {
		TAILQ_REMOVE(rules, r, entries);
		free(r);
	}
	free(rules);

	/* network list is not used in the SE */
	while ((net = TAILQ_FIRST(net_l)) != NULL) {
		TAILQ_REMOVE(net_l, net, network_l);
		free(net);
	}

	/* main mrt list is not used in the SE */
	while ((m = LIST_FIRST(m_l)) != NULL) {
		LIST_REMOVE(m, list);
		free(m);
	}
d196 1
a196 3
		pfd[PFD_LISTEN6].fd = sock6;
		pfd[PFD_LISTEN6].events = POLLIN;
		pfd[PFD_PIPE_MAIN].fd = ibuf_main.fd;
d200 1
a200 1
		pfd[PFD_PIPE_ROUTE].fd = ibuf_rde.fd;
d280 2
a281 2
			if (p->fd != -1 && events != 0) {
				pfd[i].fd = p->fd;
d291 1
a291 1
			pfd[i].fd = ctl_conn->ibuf.fd;
a309 5
		if (nfds > 0 && pfd[PFD_LISTEN6].revents & POLLIN) {
			nfds--;
			session_accept(sock6);
		}

d337 1
a337 13
			nfds -= control_dispatch_msg(&pfd[j]);
	}

	while ((p = peers) != NULL) {
		peers = p->next;
		bgp_fsm(p, EVNT_STOP);
		pfkey_remove(p);
		free(p);
	}

	while ((mrt = LIST_FIRST(&mrt_l)) != NULL) {
		LIST_REMOVE(mrt, list);
		free(mrt);
a339 5
	msgbuf_write(&ibuf_rde.w);
	msgbuf_clear(&ibuf_rde.w);
	msgbuf_write(&ibuf_main.w);
	msgbuf_clear(&ibuf_main.w);

d355 1
a355 4
	p->fd = p->wbuf.fd = -1;
	p->capa.announce = p->conf.capabilities;
	p->capa.ann_mp = 1;
	p->capa.ann_refresh = 1;
d384 1
a384 9
			/* init pfkey - remove old if any, load new ones */
			pfkey_remove(peer);
			if (pfkey_establish(peer) == -1) {
				log_peer_warnx(&peer->conf,
				    "pfkey setup failed");
				return;
			}

			if (peer->conf.passive || peer->conf.template) {
a479 1
			/* parse_open calls change_state itself on failure */
d481 5
a485 3
				break;
			session_keepalive(peer);
			change_state(peer, STATE_OPENCONFIRM, event);
d488 2
a489 7
			if (parse_notification(peer)) {
				change_state(peer, STATE_IDLE, event);
				/* don't punish, capa negotiation */
				peer->IdleHoldTimer = time(NULL);
				peer->IdleHoldTime /= 2;
			} else
				change_state(peer, STATE_IDLE, event);
d605 5
a609 3
	if (peer->fd != -1) {
		shutdown(peer->fd, SHUT_RDWR);
		close(peer->fd);
d611 13
a623 1
	peer->fd = peer->wbuf.fd = -1;
a629 2
	struct mrt_config	*mrt;

a632 7
		 * try to write out what's buffered (maybe a notification),
		 * don't bother if it fails
		 */
		if (peer->state >= STATE_OPENSENT && peer->wbuf.queued)
			msgbuf_write(&peer->wbuf);

		/*
d651 1
a651 1
		if (event != EVNT_STOP && !peer->conf.cloned) {
a656 2
		if (peer->state != STATE_NONE && peer->conf.cloned)
			peer->conf.reconf_action = RECONF_DELETE;
d677 4
a680 9
	LIST_FOREACH(mrt, &mrt_l, list) {
		if (mrt->type != MRT_ALL_IN && mrt->type != MRT_ALL_OUT)
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == peer->conf.id ||
		    mrt->group_id == peer->conf.groupid)
			mrt_dump_state(mrt, peer->state, state,
			    &peer->conf, conf);
	}
a687 1
	int			 opt;
d689 1
a689 1
	struct sockaddr_storage	 cliaddr;
d701 1
a701 1
	p = getpeerbyip((struct sockaddr *)&cliaddr);
d705 4
a708 8
		if (p->fd != -1) {
			if (p->state == STATE_CONNECT)
				session_close_connection(p);
			else {
				shutdown(connfd, SHUT_RDWR);
				close(connfd);
				return;
			}
d710 1
a710 14
		if (p->conf.auth.method == AUTH_MD5SIG) {
			len = sizeof(opt);
			if (getsockopt(connfd, IPPROTO_TCP, TCP_MD5SIG,
			    &opt, &len) == -1)
				fatal("getsockopt TCP_MD5SIG");
			if (!opt) {	/* non-md5'd connection! */
				log_peer_warnx(&p->conf,
				    "connection attempt without md5 signature");
				shutdown(connfd, SHUT_RDWR);
				close(connfd);
				return;
			}
		}
		p->fd = p->wbuf.fd = connfd;
a715 1
		session_socket_blockmode(connfd, BM_NONBLOCK);
d718 1
a718 1
		log_conn_attempt(p, (struct sockaddr *)&cliaddr);
d727 1
a727 1
	int			 opt = 1;
d732 1
a732 1
	 * describes; we simply make sure there is only ever one concurrent
d735 1
a735 1
	if (peer->fd != -1)
d738 1
a738 1
	if ((peer->fd = socket(peer->conf.remote_addr.af, SOCK_STREAM,
d745 1
a745 9
	if (peer->conf.auth.method == AUTH_MD5SIG)
		if (setsockopt(peer->fd, IPPROTO_TCP, TCP_MD5SIG,
		    &opt, sizeof(opt)) == -1) {
			log_peer_warn(&peer->conf, "setsockopt md5sig");
			bgp_fsm(peer, EVNT_CON_OPENFAIL);
			return (-1);
		}

	peer->wbuf.fd = peer->fd;
d748 3
a750 3
	if (peer->conf.local_addr.af) {
		sa = addr2sa(&peer->conf.local_addr, 0);
		if (bind(peer->fd, sa, sa->sa_len) == -1) {
a754 1
	}
d761 1
a761 1
	session_socket_blockmode(peer->fd, BM_NONBLOCK);
d764 1
a764 1
	if (connect(peer->fd, sa, sa->sa_len) == -1) {
d770 2
a771 1
	} else
a782 1
	int	bsize;
d784 1
a784 1
	if (p->conf.ebgp && p->sa_remote.ss_family == AF_INET)
d786 1
a786 1
		if (setsockopt(p->fd, IPPROTO_IP, IP_TTL, &ttl,
a792 9
	if (p->conf.ebgp && p->sa_remote.ss_family == AF_INET6)
		/* set hoplimit to foreign router's distance */
		if (setsockopt(p->fd, IPPROTO_IPV6, IPV6_HOPLIMIT, &ttl,
		    sizeof(ttl)) == -1) {
			log_peer_warn(&p->conf,
			    "session_setup_socket setsockopt hoplimit");
			return (-1);
		}

d794 1
a794 1
	if (setsockopt(p->fd, IPPROTO_TCP, TCP_NODELAY, &nodelay,
d802 1
a802 2
	if (p->sa_remote.ss_family == AF_INET &&
	    setsockopt(p->fd, IPPROTO_IP, IP_TOS, &pre, sizeof(pre)) == -1) {
a807 13
	/* only increase bufsize (and thus window) if md5 or ipsec is in use */
	if (p->conf.auth.method != AUTH_NONE) {
		/* try to increase bufsize. no biggie if it fails */
		bsize = 65535;
		while (setsockopt(p->fd, SOL_SOCKET, SO_RCVBUF, &bsize,
		    sizeof(bsize)) == -1)
			bsize /= 2;
		bsize = 65535;
		while (setsockopt(p->fd, SOL_SOCKET, SO_SNDBUF, &bsize,
		    sizeof(bsize)) == -1)
			bsize /= 2;
	}

d833 2
a834 2
	len = sizeof(peer->sa_local);
	if (getsockname(peer->fd, (struct sockaddr *)&peer->sa_local,
d837 1
a837 2
	len = sizeof(peer->sa_remote);
	if (getpeername(peer->fd, (struct sockaddr *)&peer->sa_remote,
d845 4
a848 21
	struct msg_open		 msg;
	struct buf		*buf;
	struct mrt_config	*mrt;
	u_int16_t		 len;
	int			 errs = 0;
	u_int8_t		 op_type, op_len = 0, optparamlen = 0;
	u_int8_t		 capa_code, capa_len;
	struct capa_mp		 capa_mp_v4;

	if (p->capa.announce) {
		if (p->capa.ann_mp) {
			/* multiprotocol extensions, RFC 2858 */
			bzero(&capa_mp_v4, sizeof(capa_mp_v4));
			capa_mp_v4.afi = htons(AFI_IPv4);
			capa_mp_v4.safi = SAFI_UNICAST;
			op_len += 6;	/* 1 code + 1 len + 4 data */
		}
		if (p->capa.ann_refresh) {
			/* route refresh, RFC 2918 */
			op_len += 2;	/* 1 code + 1 len, no data */
		}
d850 1
a850 5
		if (op_len > 0)
			optparamlen = sizeof(op_type) + sizeof(op_len) + op_len;
	}

	len = MSGSIZE_OPEN_MIN + optparamlen;
d862 1
a862 1
	msg.optparamlen = optparamlen;
a876 28
	if (p->capa.announce && optparamlen) {
		op_type = OPT_PARAM_CAPABILITIES;
		errs += buf_add(buf, &op_type, sizeof(op_type));
		errs += buf_add(buf, &op_len, sizeof(op_len));

		if (p->capa.ann_mp) {
			/* multiprotocol extensions, RFC 2858 */
			capa_code = CAPA_MP;
			capa_len = 4;
			errs += buf_add(buf, &capa_code, sizeof(capa_code));
			errs += buf_add(buf, &capa_len, sizeof(capa_len));
			errs += buf_add(buf, &capa_mp_v4.afi,
			    sizeof(capa_mp_v4.afi));
			errs += buf_add(buf, &capa_mp_v4.pad,
			    sizeof(capa_mp_v4.pad));
			errs += buf_add(buf, &capa_mp_v4.safi,
			    sizeof(capa_mp_v4.safi));
		}

		if (p->capa.ann_refresh) {
			/* route refresh, RFC 2918 */
			capa_code = CAPA_REFRESH;
			capa_len = 0;
			errs += buf_add(buf, &capa_code, sizeof(capa_code));
			errs += buf_add(buf, &capa_len, sizeof(capa_len));
		}
	}

d878 5
a882 12
		LIST_FOREACH(mrt, &mrt_l, list) {
			if (mrt->type != MRT_ALL_OUT)
				continue;
			if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
			    mrt->peer_id == p->conf.id ||
			    mrt->group_id == p->conf.groupid)
				mrt_dump_bgp_msg(mrt, buf->buf, len,
				    &p->conf, conf);
		}

		if (buf_close(&p->wbuf, buf) == -1) {
			log_peer_warn(&p->conf, "session_open buf_close");
a884 1
			return;
a888 1
		return;
a898 1
	struct mrt_config	*mrt;
d900 1
a900 1
	int			 errs = 0;
d922 5
a926 11
	LIST_FOREACH(mrt, &mrt_l, list) {
		if (mrt->type != MRT_ALL_OUT)
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == peer->conf.id ||
		    mrt->group_id == peer->conf.groupid)
			mrt_dump_bgp_msg(mrt, buf->buf, len, &peer->conf, conf);
	}

	if (buf_close(&peer->wbuf, buf) == -1) {
		log_peer_warn(&peer->conf, "session_keepalive buf_close");
a941 1
	struct mrt_config	*mrt;
d943 1
a943 1
	int			 errs = 0;
a949 3
	if (p->state != STATE_ESTABLISHED)
		return;

d971 5
a975 11
	LIST_FOREACH(mrt, &mrt_l, list) {
		if (mrt->type != MRT_ALL_OUT && mrt->type != MRT_UPDATE_OUT)
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == p->conf.id ||
		    mrt->group_id == p->conf.groupid)
			mrt_dump_bgp_msg(mrt, buf->buf, len, &p->conf, conf);
	}

	if (buf_close(&p->wbuf, buf) == -1) {
		log_peer_warn(&p->conf, "session_update: buf_close");
a977 1
		return;
a989 1
	struct mrt_config	*mrt;
d991 1
a991 1
	int			 errs = 0;
d1018 5
a1022 11
	LIST_FOREACH(mrt, &mrt_l, list) {
		if (mrt->type != MRT_ALL_OUT)
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == peer->conf.id ||
		    mrt->group_id == peer->conf.groupid)
			mrt_dump_bgp_msg(mrt, buf->buf, len, &peer->conf, conf);
	}

	if (buf_close(&peer->wbuf, buf) == -1) {
		log_peer_warn(&peer->conf, "session_notification: buf_close");
a1024 1
		return;
d1044 4
a1047 3
				    &error, &len) == -1 || error) {
					if (error)
						errno = error;
a1048 2
					bgp_fsm(p, EVNT_CON_OPENFAIL);
					return (1);
d1050 3
a1052 2
			}
			bgp_fsm(p, EVNT_CON_OPEN);
d1080 1
a1080 1
				log_peer_warn(&p->conf, "write error");
a1081 1
			return (1);
d1088 4
a1091 3
		if ((n = read(p->fd, p->rbuf->buf + p->rbuf->wpos,
		    sizeof(p->rbuf->buf) - p->rbuf->wpos)) == -1) {
				if (errno != EINTR && errno != EAGAIN) {
a1138 4
				case RREFRESH:
					parse_refresh(p);
					p->stats.msg_rcvd_rrefresh++;
					break;
d1166 4
a1169 5
	struct mrt_config	*mrt;
	u_char			*p;
	u_char			 one = 0xff;
	int			 i;
	u_int16_t		 olen;
a1233 9
	case RREFRESH:
		if (*len != MSGSIZE_RREFRESH) {
			log_peer_warnx(&peer->conf,
			    "received RREFRESH: illegal len: %u byte", *len);
			session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
			    &olen, sizeof(olen));
			return (-1);
		}
		break;
d1241 3
a1243 9
	LIST_FOREACH(mrt, &mrt_l, list) {
		if (mrt->type != MRT_ALL_IN && (mrt->type != MRT_UPDATE_IN ||
		    *type != UPDATE))
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == peer->conf.id ||
		    mrt->group_id == peer->conf.groupid)
			mrt_dump_bgp_msg(mrt, data, *len, &peer->conf, conf);
	}
d1250 3
a1252 3
	u_char		*p, *op_val;
	u_int8_t	 version, rversion;
	u_int16_t	 as, msglen;
d1255 1
a1255 7
	u_int8_t	 optparamlen, plen;
	u_int8_t	 op_type, op_len;

	p = peer->rbuf->rptr;
	p += MSGSIZE_HEADER_MARKER;
	memcpy(&msglen, p, sizeof(msglen));
	msglen = ntohs(msglen);
a1263 2
		log_peer_warnx(&peer->conf,
		    "peer wants unrecognized version %u", version);
d1265 4
a1268 6
			rversion = version - BGP_VERSION;
		else
			rversion = BGP_VERSION;
		session_notification(peer, ERR_OPEN, ERR_OPEN_VERSION,
		    &rversion, sizeof(rversion));
		change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
a1274 4
	/* if remote-as is zero and it's a cloned neighbor, accept any */
	if (peer->conf.cloned && !peer->conf.remote_as)
		peer->conf.remote_as = ntohs(as);

a1277 1
		change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
a1289 1
		change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
a1309 1
		change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
d1317 1
a1317 68
	if (optparamlen > msglen - MSGSIZE_OPEN_MIN) {
			log_peer_warnx(&peer->conf,
			    "corrupt OPEN message received: length mismatch");
			session_notification(peer, ERR_OPEN, 0, NULL, 0);
			change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
			return (-1);
	}

	plen = optparamlen;
	while (plen > 0) {
		if (plen < 2) {
			log_peer_warnx(&peer->conf,
			    "corrupt OPEN message received, len wrong");
			session_notification(peer, ERR_OPEN, 0, NULL, 0);
			change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
			return (-1);
		}
		memcpy(&op_type, p, sizeof(op_type));
		p += sizeof(op_type);
		plen -= sizeof(op_type);
		memcpy(&op_len, p, sizeof(op_len));
		p += sizeof(op_len);
		plen -= sizeof(op_len);
		if (op_len > 0) {
			if (plen < op_len) {
				log_peer_warnx(&peer->conf,
				    "corrupt OPEN message received, len wrong");
				session_notification(peer, ERR_OPEN, 0,
				    NULL, 0);
				change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
				return (-1);
			}
			op_val = p;
			p += op_len;
			plen -= op_len;
		} else
			op_val = NULL;

		switch (op_type) {
		case OPT_PARAM_CAPABILITIES:		/* RFC 3392 */
			if (parse_capabilities(peer, op_val, op_len) == -1) {
				session_notification(peer, ERR_OPEN, 0,
				    NULL, 0);
				change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
				return (-1);
			}
			break;
		case OPT_PARAM_AUTH:			/* deprecated */
		default:
			/*
			 * unsupported type
			 * the RFCs tell us to leave the data section empty
			 * and notify the peer with ERR_OPEN, ERR_OPEN_OPT.
			 * How the peer should know _which_ optional parameter
			 * we don't support is beyond me.
			 */
			log_peer_warnx(&peer->conf,
			    "received OPEN message with unsupported optional "
			    "parameter: type %u", op_type);
			session_notification(peer, ERR_OPEN, ERR_OPEN_OPT,
				NULL, 0);
			change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
			peer->IdleHoldTimer = time(NULL);	/* no punish */
			peer->IdleHoldTime /= 2;
			return (-1);
			/* not reached */
		}
	}
a1349 27
parse_refresh(struct peer *peer)
{
	u_char		*p;
	struct rrefresh	 r;

	p = peer->rbuf->rptr;
	p += MSGSIZE_HEADER;	/* header is already checked */

	/* afi, 2 byte */
	memcpy(&r.afi, p, sizeof(r.afi));
	r.afi = ntohs(r.afi);
	p += 2;
	/* reserved, 1 byte */
	p += 1;
	/* safi, 1 byte */
	memcpy(&r.safi, p, sizeof(r.safi));

	/* afi/safi unchecked -	unrecognized values will be ignored anyway */

	if (imsg_compose(&ibuf_rde, IMSG_REFRESH, peer->conf.id, &r,
	    sizeof(r)) == -1)
		return (-1);

	return (0);
}

int
a1355 2
	u_int8_t	 capa_code;
	u_int8_t	 capa_len;
d1375 3
a1379 141
	if (errcode == ERR_OPEN && subcode == ERR_OPEN_CAPA) {
		if (datalen == 0) {	/* zebra likes to send those.. humbug */
			log_peer_warnx(&peer->conf, "received \"unsupported "
			    "capability\" notification without data part, "
			    "disabling capability announcements alltogether");
			peer->capa.announce = 0;
		}

		while (datalen > 0) {
			if (datalen < 2) {
				log_peer_warnx(&peer->conf,
				    "parse_notification: "
				    "expect len >= 2, len is %u", datalen);
				return (-1);
			}
			memcpy(&capa_code, p, sizeof(capa_code));
			p += sizeof(capa_code);
			datalen -= sizeof(capa_code);
			memcpy(&capa_len, p, sizeof(capa_len));
			p += sizeof(capa_len);
			datalen -= sizeof(capa_len);
			if (datalen < capa_len) {
				log_peer_warnx(&peer->conf,
				    "parse_notification: capa_len %u exceeds"
				    "remaining msg length", capa_len);
				return (-1);
			}
			p += capa_len;
			datalen -= capa_len;
			switch (capa_code) {
			case CAPA_MP:
				peer->capa.ann_mp = 0;
				log_peer_warnx(&peer->conf,
				    "disabling multiprotocol capability");
				break;
			case CAPA_REFRESH:
				peer->capa.ann_refresh = 0;
				log_peer_warnx(&peer->conf,
				    "disabling route refresh capability");
				break;
			default:	/* should not happen... */
				log_peer_warnx(&peer->conf, "received "
				    "\"unsupported capability\" notification "
				    "for unknown capability %u, disabling "
				    "capability announcements alltogether",
				    capa_code);
				peer->capa.announce = 0;
				break;
			}
		}

		return (1);
	}

	if (errcode == ERR_OPEN && subcode == ERR_OPEN_OPT) {
		peer->capa.announce = 0;
		return (1);
	}

	return (0);
}

int
parse_capabilities(struct peer *peer, u_char *d, u_int16_t dlen)
{
	u_int16_t	 len;
	u_int8_t	 capa_code;
	u_int8_t	 capa_len;
	u_char		*capa_val;
	u_int16_t	 mp_afi;
	u_int8_t	 mp_safi;

	len = dlen;
	while (len > 0) {
		if (len < 2) {
			log_peer_warnx(&peer->conf, "parse_capabilities: "
			    "expect len >= 2, len is %u", len);
			return (-1);
		}
		memcpy(&capa_code, d, sizeof(capa_code));
		d += sizeof(capa_code);
		len -= sizeof(capa_code);
		memcpy(&capa_len, d, sizeof(capa_len));
		d += sizeof(capa_len);
		len -= sizeof(capa_len);
		if (capa_len > 0) {
			if (len < capa_len) {
				log_peer_warnx(&peer->conf,
				    "parse_capabilities: "
				    "len %u smaller than capa_len %u",
				    len, capa_len);
				return (-1);
			}
			capa_val = d;
			d += capa_len;
			len -= capa_len;
		} else
			capa_val = NULL;

		switch (capa_code) {
		case CAPA_MP:			/* RFC 2858 */
			if (capa_len != 4) {
				log_peer_warnx(&peer->conf,
				    "parse_capabilities: "
				    "expect len 4, len is %u", capa_len);
				return (-1);
			}
			memcpy(&mp_afi, capa_val, sizeof(mp_afi));
			mp_afi = ntohs(mp_afi);
			memcpy(&mp_safi, capa_val + 3, sizeof(mp_safi));
			switch (mp_afi) {
			case AFI_IPv4:
				if (mp_safi < 1 || mp_safi > 3) {
					log_peer_warnx(&peer->conf,
					    "parse_capabilities: AFI IPv4, "
					    "mp_safi %u illegal", mp_safi);
					return (-1);
				}
				peer->capa.mp_v4 = mp_safi;
				break;
			case AFI_IPv6:
				if (mp_safi < 1 || mp_safi > 3) {
					log_peer_warnx(&peer->conf,
					    "parse_capabilities: AFI IPv6, "
					    "mp_safi %u illegal", mp_safi);
					return (-1);
				}
				peer->capa.mp_v6 = mp_safi;
				break;
			default:			/* ignore */
				break;
			}
			break;
		case CAPA_REFRESH:
			peer->capa.refresh = 1;
			break;
		default:
			break;
		}
	}

d1387 1
a1387 2
	struct mrt_config	 xmrt;
	struct mrt_config	*mrt;
a1389 1
	u_char			*data;
d1392 1
a1392 1
	u_int8_t		 errcode, subcode;
d1455 1
a1455 2
				if (p->conf.reconf_action == RECONF_NONE &&
				    !p->conf.cloned)
d1463 6
a1468 6
			if ((mrt = calloc(1, sizeof(struct mrt_config))) ==
			    NULL)
				fatal("session_dispatch_imsg");
			memcpy(mrt, imsg.data, sizeof(struct mrt_config));
			mrt->ibuf = &ibuf_main;
			LIST_INSERT_HEAD(&mrt_l, mrt, list);
d1471 4
a1474 10
			memcpy(&xmrt, imsg.data, sizeof(struct mrt_config));
			LIST_FOREACH(mrt, &mrt_l, list) {
				if (mrt->type != xmrt.type)
					continue;
				if (mrt->peer_id == xmrt.peer_id &&
				    mrt->group_id == xmrt.group_id) {
					LIST_REMOVE(mrt, list);
					free(mrt);
					break;
				}
d1481 1
a1485 9
		case IMSG_CTL_SHOW_RIB:
		case IMSG_CTL_SHOW_RIB_PREFIX:
			if (idx != PFD_PIPE_ROUTE)
				fatalx("ctl rib request not from RDE");
			control_imsg_relay(&imsg);
			break;
		case IMSG_CTL_END:
			control_imsg_relay(&imsg);
			break;
d1501 1
a1501 1
			if (imsg.hdr.len < IMSG_HEADER_SIZE + 2) {
d1505 1
a1505 1
			if ((p = getpeerbyid(imsg.hdr.peerid)) == NULL) {
d1508 4
a1511 1
				break;
a1512 9
			data = imsg.data;
			errcode = *data++;
			subcode = *data++;

			if (imsg.hdr.len == IMSG_HEADER_SIZE + 2)
				data = NULL;

			session_notification(p, errcode, subcode,
			    data, imsg.hdr.len - IMSG_HEADER_SIZE - 2);
d1536 1
a1536 1
getpeerbyip(struct sockaddr *ip)
d1538 1
a1538 2
	struct peer	*p, *newpeer, *loose = NULL;
	u_int32_t	 id;
d1541 3
a1543 13
	for (p = peers; p != NULL; p = p->next)
		if (!p->conf.template &&
		    p->conf.remote_addr.af == ip->sa_family) {
			if (p->conf.remote_addr.af == AF_INET &&
			    p->conf.remote_addr.v4.s_addr ==
			    ((struct sockaddr_in *)ip)->sin_addr.s_addr)
				return (p);
			if (p->conf.remote_addr.af == AF_INET6 &&
			    !bcmp(&p->conf.remote_addr.v6,
			    &((struct sockaddr_in6 *)ip)->sin6_addr,
			    sizeof(p->conf.remote_addr.v6)))
				return (p);
		}
d1545 1
a1545 83
	/* try template matching */
	for (p = peers; p != NULL; p = p->next)
		if (p->conf.template &&
		    p->conf.remote_addr.af == ip->sa_family &&
		    session_match_mask(p, ip))
			if (loose == NULL || loose->conf.remote_masklen <
			    p->conf.remote_masklen)
				loose = p;

	if (loose != NULL) {
		/* clone */
		if ((newpeer = malloc(sizeof(struct peer))) == NULL)
			fatal(NULL);
		memcpy(newpeer, loose, sizeof(struct peer));
		for (id = UINT_MAX; id > UINT_MAX / 2; id--) {
			for (p = peers; p != NULL && p->conf.id != id;
			    p = p->next)
				;	/* nothing */
			if (p == NULL) {	/* we found a free id */
				newpeer->conf.id = id;
				break;
			}
		}
		if (newpeer->conf.remote_addr.af == AF_INET) {
			newpeer->conf.remote_addr.v4.s_addr =
			    ((struct sockaddr_in *)ip)->sin_addr.s_addr;
			newpeer->conf.remote_masklen = 32;
		}
		if (newpeer->conf.remote_addr.af == AF_INET6) {
			memcpy(&p->conf.remote_addr.v6,
			    &((struct sockaddr_in6 *)ip)->sin6_addr,
			    sizeof(newpeer->conf.remote_addr.v6));
			newpeer->conf.remote_masklen = 128;
		}
		newpeer->conf.template = 0;
		newpeer->conf.cloned = 1;
		newpeer->state = STATE_NONE;
		newpeer->rbuf = NULL;
		init_peer(newpeer);
		bgp_fsm(newpeer, EVNT_START);
		newpeer->next = peers;
		peers = newpeer;
		return (newpeer);
	}

	return (NULL);
}

int
session_match_mask(struct peer *p, struct sockaddr *ip)
{
	int		 i;
	in_addr_t	 v4mask;
	struct in6_addr	*in;
	struct in6_addr	 mask;

	if (p->conf.remote_addr.af == AF_INET) {
		v4mask = htonl(0xffffffff << (32 - p->conf.remote_masklen));
		if (p->conf.remote_addr.v4.s_addr ==
		    ((((struct sockaddr_in *)ip)->sin_addr.s_addr) & v4mask))
			return (1);
		else
			return (0);
	}

	if (p->conf.remote_addr.af == AF_INET6) {
		for (i = 0; i < p->conf.remote_masklen / 8; i++)
			mask.s6_addr[i] = 0xff;
		i = p->conf.remote_masklen % 8;
		if (i)
			mask.s6_addr[p->conf.remote_masklen / 8] = 0xff00 >> i;

		in = &((struct sockaddr_in6 *)ip)->sin6_addr;

		for (i = 0; i < 16; i++)
			if ((in->s6_addr[i] & mask.s6_addr[i]) !=
			    p->conf.remote_addr.addr8[i])
				return (0);

		return (1);
	}

	return (0);
d1580 2
a1581 3
		memcpy(&sup.local_addr.v4,
		    &((struct sockaddr_in *)&peer->sa_local)->sin_addr,
		    sizeof(sup.local_addr.v4));
d1583 2
a1584 13
		memcpy(&sup.remote_addr.v4,
		    &((struct sockaddr_in *)&peer->sa_remote)->sin_addr,
		    sizeof(sup.remote_addr.v4));
		break;
	case AF_INET6:
		sup.local_addr.af = AF_INET6;
		memcpy(&sup.local_addr.v6,
		    &((struct sockaddr_in6 *)&peer->sa_local)->sin6_addr,
		    sizeof(sup.local_addr.v6));
		sup.remote_addr.af = AF_INET6;
		memcpy(&sup.remote_addr.v6,
		    &((struct sockaddr_in6 *)&peer->sa_remote)->sin6_addr,
		    sizeof(sup.remote_addr.v6));
d1587 1
a1587 1
		fatalx("session_up: unsupported address family");
a1589 1
	memcpy(&sup.conf, &peer->conf, sizeof(sup.conf));
a1599 6
}

int
imsg_compose_rde(int type, pid_t pid, void *data, u_int16_t datalen)
{
	return (imsg_compose_pid(&ibuf_rde, type, pid, data, datalen));
@


