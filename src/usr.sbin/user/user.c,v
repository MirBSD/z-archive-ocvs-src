head	1.7;
access;
symbols
	tg-mergetmp-mirosx-1:1.7
	tg-mergefixes-1-branch:1.7.0.8
	tg-mergefixes-1-base:1.7
	MIROS_X:1.7.0.6
	MIROS_X_BASE:1.7
	tg-mergetmp-3:1.7
	MIRBSD_XP_MIRPPC:1.7.0.4
	MIRBSD_XP_SPARC_BASE:1.7
	MIRBSD_XP_SPARC:1.7.0.2
	MIRBSD_7quater:1.1.1.6
	cvs-200405160640:1.1.1.9
	cvs-200401271800:1.1.1.8
	cvs-200401261630:1.1.1.8
	cvs-200401021645:1.1.1.7
	MIRBSD_7_ALPHA:1.1.1.6.0.6
	MIRBSD_7:1.1.1.6.0.4
	cvs-200312222040:1.1.1.6
	MIRBSD_7ter:1.1.1.6
	MIRBSD_7_DEV:1.1.1.6.0.2
	cvs-200310020700:1.1.1.6
	cvs-200309271030:1.1.1.6
	cvs-200309251530:1.1.1.6
	cvs-200308302005:1.1.1.6
	cvs-200308171200:1.1.1.6
	ctm-3496:1.1.1.6
	ctm-3449:1.1.1.6
	ctm-3437:1.1.1.6
	cvs-200307191805:1.1.1.6
	ctm-3425:1.1.1.6
	cvs-200307091500:1.1.1.6
	ctm-3389:1.1.1.6
	cvs-200306291430:1.1.1.6
	ctm-3341:1.1.1.6
	MIRBSD_5:1.5
	cvs-200306090050:1.1.1.5
	cvs-200306082100:1.1.1.4
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.3
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.3
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.05.21.20.09.00;	author tg;	state Stab;
branches;
next	1.6;

1.6
date	2004.01.29.21.34.31;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.09.01.15.34;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.22.14.09.26;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.10.20.12.52;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.54.14;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.56.09;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.56.09;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.15.01.48;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.21.19.28.10;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.08.23.47.09;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.06.09.00.53.23;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.06.19.12.58.07;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.01.02.18.12.21;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.01.26.19.14.28;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.16.07.25.30;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@* merge OpenBSD 3.5-current
* re-sort entries in Makefile
  => not a bunch of adds any more; all alphabetic
  => remove obsolete SUBDIRS_ONLY_BSD for now
     (MirLinux won't come that soon due to a certain lawsuit,
      licence issues with unwillingly GNU fanatics, and my
      chronic unwillingness to do masochistic work)
* spacing, RCS IDs, etc.
* pkg gets folded into pkg_install, so we only have one dir
  to worry about
* pkg_add leaves the tree - nobody cared about this kind
  of package tools anyways, and they're not part of MirBSD
  (although still supported by MirPorts)
* mopd leaves - we don't have VAX support anyways
@
text
@/* $MirBSD: src/usr.sbin/user/user.c,v 1.6 2004/01/29 21:34:31 tg Exp $ */
/* $OpenBSD: user.c,v 1.59 2004/05/10 18:41:11 otto Exp $ */
/* $NetBSD: user.c,v 1.69 2003/04/14 17:40:07 agc Exp $ */

/*
 * Copyright (c) 1999 Alistair G. Crooks.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Alistair G. Crooks.
 * 4. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/stat.h>

#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <fcntl.h>
#include <grp.h>
#ifdef EXTENSIONS
#include <login_cap.h>
#endif
#include <paths.h>
#include <pwd.h>
#include <regex.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <util.h>

#include "defs.h"
#include "usermgmt.h"


/* this struct describes a uid range */
typedef struct range_t {
	uid_t	r_from;		/* low uid */
	uid_t	r_to;		/* high uid */
} range_t;

/* this struct encapsulates the user information */
typedef struct user_t {
	int		u_flags;		/* see below */
	uid_t		u_uid;			/* uid of user */
	char	       *u_password;		/* encrypted password */
	char	       *u_comment;		/* comment field */
	char	       *u_home;		/* home directory */
	char	       *u_primgrp;		/* primary group */
	int		u_groupc;		/* # of secondary groups */
	const char     *u_groupv[NGROUPS_MAX];	/* secondary groups */
	char	       *u_shell;		/* user's shell */
	char	       *u_basedir;		/* base directory for home */
	char	       *u_expire;		/* when password will expire */
	char	       *u_inactive;		/* when account will expire */
	char	       *u_skeldir;		/* directory for startup files */
	char	       *u_class;		/* login class */
	unsigned int	u_rsize;		/* size of range array */
	unsigned int	u_rc;			/* # of ranges */
	range_t	       *u_rv;			/* the ranges */
	unsigned int	u_defrc;		/* # of ranges in defaults */
	int		u_preserve;		/* preserve uids on deletion */
} user_t;

/* flags for which fields of the user_t replace the passwd entry */
enum {
	F_COMMENT	= 0x0001,
	F_DUPUID	= 0x0002,
	F_EXPIRE	= 0x0004,
	F_GROUP		= 0x0008,
	F_HOMEDIR	= 0x0010,
	F_MKDIR		= 0x0020,
	F_INACTIVE	= 0x0040,
	F_PASSWORD	= 0x0080,
	F_SECGROUP	= 0x0100,
	F_SHELL		= 0x0200,
	F_UID		= 0x0400,
	F_USERNAME	= 0x0800,
	F_CLASS		= 0x1000
};

#define CONFFILE	"/etc/usermgmt.conf"

#ifndef DEF_GROUP
#define DEF_GROUP	"users"
#endif

#ifndef DEF_BASEDIR
#define DEF_BASEDIR	"/home"
#endif

#ifndef DEF_SKELDIR
#define DEF_SKELDIR	"/etc/skel"
#endif

#ifndef DEF_SHELL
#define DEF_SHELL	_PATH_CSHELL
#endif

#ifndef DEF_COMMENT
#define DEF_COMMENT	""
#endif

#ifndef DEF_LOWUID
#define DEF_LOWUID	1000
#endif

#ifndef DEF_HIGHUID
#define DEF_HIGHUID	60000
#endif

#ifndef DEF_INACTIVE
#define DEF_INACTIVE	0
#endif

#ifndef DEF_EXPIRE
#define DEF_EXPIRE	NULL
#endif

#ifndef DEF_CLASS
#define DEF_CLASS	""
#endif

#ifndef WAITSECS
#define WAITSECS	10
#endif

#ifndef NOBODY_UID
#define NOBODY_UID	32767
#endif

/* some useful constants */
enum {
	MaxShellNameLen = 256,
	MaxFileNameLen = MAXPATHLEN,
	MaxUserNameLen = _PW_NAME_LEN,
	MaxCommandLen = 2048,
	PasswordLength = _PASSWORD_LEN,

	DES_Len = 13,

	LowGid = DEF_LOWUID,
	HighGid = DEF_HIGHUID
};

/* Full paths of programs used here */
#define CHMOD		"/bin/chmod"
#define CHOWN		"/sbin/chown"
#define MKDIR		"/bin/mkdir"
#define MV		"/bin/mv"
#define NOLOGIN		"/sbin/nologin"
#define PAX		"/bin/pax"
#define RM		"/bin/rm"

#define UNSET_INACTIVE	"Null (unset)"
#define UNSET_EXPIRY	"Null (unset)"

static int asystem(const char *fmt, ...)
	__attribute__((__format__(__printf__, 1, 2)));

static int	verbose;

/* if *cpp is non-null, free it, then assign `n' chars of `s' to it */
static void
memsave(char **cpp, const char *s, size_t n)
{
	if (*cpp != NULL) {
		FREE(*cpp);
	}
	NEWARRAY(char, *cpp, n + 1, exit(1));
	(void) memcpy(*cpp, s, n);
	(*cpp)[n] = '\0';
}

/* a replacement for system(3) */
static int
asystem(const char *fmt, ...)
{
	va_list	vp;
	char	buf[MaxCommandLen];
	int	ret;

	va_start(vp, fmt);
	(void) vsnprintf(buf, sizeof(buf), fmt, vp);
	va_end(vp);
	if (verbose) {
		(void) printf("Command: %s\n", buf);
	}
	if ((ret = system(buf)) != 0) {
		warnx("[Warning] can't system `%s'", buf);
	}
	return ret;
}

/* remove a users home directory, returning 1 for success (ie, no problems encountered) */
static int
removehomedir(const char *user, uid_t uid, const char *dir)
{
	struct stat st;

	/* userid not root? */
	if (uid == 0) {
		warnx("Not deleting home directory `%s'; userid is 0", dir);
		return 0;
	}

	/* directory exists (and is a directory!) */
	if (stat(dir, &st) < 0) {
		warnx("Home directory `%s' doesn't exist", dir);
		return 0;
	}
	if (!S_ISDIR(st.st_mode)) {
		warnx("Home directory `%s' is not a directory", dir);
		return 0;
	}

	/* userid matches directory owner? */
	if (st.st_uid != uid) {
		warnx("User `%s' doesn't own directory `%s', not removed",
		    user, dir);
		return 0;
	}

	(void) seteuid(uid);
	/* we add the "|| true" to keep asystem() quiet if there is a non-zero exit status. */
	(void) asystem("%s -rf %s > /dev/null 2>&1 || true", RM, dir);
	(void) seteuid(0);
	if (rmdir(dir) < 0) {
		warnx("Unable to remove all files in `%s'", dir);
		return 0;
	}
	return 1;
}

/* return 1 if all of `s' is numeric */
static int
is_number(char *s)
{
	for ( ; *s ; s++) {
		if (!isdigit((unsigned char) *s)) {
			return 0;
		}
	}
	return 1;
}

/*
 * check that the effective uid is 0 - called from funcs which will
 * modify data and config files.
 */
static void
checkeuid(void)
{
	if (geteuid() != 0) {
		errx(EXIT_FAILURE, "Program must be run as root");
	}
}

/* copy any dot files into the user's home directory */
static int
copydotfiles(char *skeldir, uid_t uid, gid_t gid, char *dir)
{
	struct dirent	*dp;
	DIR		*dirp;
	int		n;

	if ((dirp = opendir(skeldir)) == NULL) {
		warn("can't open source . files dir `%s'", skeldir);
		return 0;
	}
	for (n = 0; (dp = readdir(dirp)) != NULL && n == 0 ; ) {
		if (strcmp(dp->d_name, ".") == 0 ||
		    strcmp(dp->d_name, "..") == 0) {
			continue;
		}
		n = 1;
	}
	(void) closedir(dirp);
	if (n == 0) {
		warnx("No \"dot\" initialisation files found");
	} else {
		(void) asystem("cd %s && %s -rw -pe %s . %s",
				skeldir, PAX, (verbose) ? "-v" : "", dir);
	}
	(void) asystem("%s -R -P %u:%u %s", CHOWN, uid, gid, dir);
	(void) asystem("%s -R u+w %s", CHMOD, dir);
	return n;
}

/* create a group entry with gid `gid' */
static int
creategid(char *group, gid_t gid, const char *name)
{
	struct stat	st;
	FILE		*from;
	FILE		*to;
	char		*buf;
	char		f[MaxFileNameLen];
	int		fd, ret;
	int		wroteit = 0;
	size_t		len;

	if (getgrnam(group) != NULL) {
		warnx("group `%s' already exists", group);
		return 0;
	}
	if ((from = fopen(_PATH_GROUP, "r")) == NULL) {
		warn("can't create gid for `%s': can't open `%s'", group,
		    _PATH_GROUP);
		return 0;
	}
	if (flock(fileno(from), LOCK_EX | LOCK_NB) < 0) {
		warn("can't lock `%s'", _PATH_GROUP);
	}
	(void) fstat(fileno(from), &st);
	(void) snprintf(f, sizeof(f), "%s.XXXXXXXX", _PATH_GROUP);
	if ((fd = mkstemp(f)) < 0) {
		(void) fclose(from);
		warn("can't create gid: mkstemp failed");
		return 0;
	}
	if ((to = fdopen(fd, "w")) == NULL) {
		(void) fclose(from);
		(void) close(fd);
		(void) unlink(f);
		warn("can't create gid: fdopen `%s' failed", f);
		return 0;
	}
	while ((buf = fgetln(from, &len)) != NULL && len > 0) {
		ret = 0;
		if (buf[0] == '+' && wroteit == 0) {
			ret = fprintf(to, "%s:*:%u:%s\n", group, gid, name);
			wroteit = 1;
		}
		if (ret == -1 ||
		    fprintf(to, "%*.*s", (int)len, (int)len, buf) != len) {
			(void) fclose(from);
			(void) fclose(to);
			(void) unlink(f);
			warn("can't create gid: short write to `%s'", f);
			return 0;
		}
	}
	ret = 0;
	if (wroteit == 0)
		ret = fprintf(to, "%s:*:%u:%s\n", group, gid, name);
	(void) fclose(from);
	if (fclose(to) == EOF || ret == -1) {
		(void) unlink(f);
		warn("can't create gid: short write to `%s'", f);
		return 0;
	}
	if (rename(f, _PATH_GROUP) < 0) {
		(void) unlink(f);
		warn("can't create gid: can't rename `%s' to `%s'", f,
		    _PATH_GROUP);
		return 0;
	}
	(void) chmod(_PATH_GROUP, st.st_mode & 07777);
	syslog(LOG_INFO, "new group added: name=%s, gid=%d", group, gid);
	return 1;
}

/* modify the group entry with name `group' to be newent */
static int
modify_gid(char *group, char *newent)
{
	struct stat	st;
	FILE		*from;
	FILE		*to;
	char		buf[LINE_MAX];
	char		f[MaxFileNameLen];
	char		*colon;
	int		groupc;
	int		entc;
	int		fd;
	int		cc;

	if ((from = fopen(_PATH_GROUP, "r")) == NULL) {
		warn("can't modify gid for `%s': can't open `%s'", group,
		    _PATH_GROUP);
		return 0;
	}
	if (flock(fileno(from), LOCK_EX | LOCK_NB) < 0) {
		warn("can't lock `%s'", _PATH_GROUP);
	}
	(void) fstat(fileno(from), &st);
	(void) snprintf(f, sizeof(f), "%s.XXXXXXXX", _PATH_GROUP);
	if ((fd = mkstemp(f)) < 0) {
		(void) fclose(from);
		warn("can't modify gid: mkstemp failed");
		return 0;
	}
	if ((to = fdopen(fd, "w")) == NULL) {
		(void) fclose(from);
		(void) close(fd);
		(void) unlink(f);
		warn("can't modify gid: fdopen `%s' failed", f);
		return 0;
	}
	groupc = strlen(group);
	while (fgets(buf, sizeof(buf), from) != NULL) {
		cc = strlen(buf);
		if (buf[cc - 1] != '\n' && !feof(from)) {
			while (fgetc(from) != '\n' && !feof(from))
				cc++;
			warn("%s: line `%s' too long (%d bytes), skipping",
			    _PATH_GROUP, buf, cc);
			continue;
		}
		if ((colon = strchr(buf, ':')) == NULL) {
			warn("badly formed entry `%s'", buf);
			continue;
		}
		entc = (int)(colon - buf);
		if (entc == groupc && strncmp(group, buf, entc) == 0) {
			if (newent == NULL) {
				continue;
			} else {
				cc = strlen(newent);
				(void) strlcpy(buf, newent, sizeof(buf));
			}
		}
		if (fwrite(buf, cc, 1, to) != 1) {
			(void) fclose(from);
			(void) fclose(to);
			(void) unlink(f);
			warn("can't modify gid: short write to `%s'", f);
			return 0;
		}
	}
	(void) fclose(from);
	if (fclose(to) == EOF) {
		(void) unlink(f);
		warn("can't modify gid: short write to `%s'", f);
		return 0;
	}
	if (rename(f, _PATH_GROUP) < 0) {
		(void) unlink(f);
		warn("can't modify gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
		return 0;
	}
	(void) chmod(_PATH_GROUP, st.st_mode & 07777);
	if (newent == NULL) {
		syslog(LOG_INFO, "group deleted: name=%s", group);
	} else {
		syslog(LOG_INFO, "group information modified: name=%s", group);
	}
	return 1;
}

/* modify the group entries for all `groups', by adding `user' */
static int
append_group(char *user, int ngroups, const char **groups)
{
	struct group	*grp;
	struct stat	st;
	FILE		*from;
	FILE		*to;
	char		buf[LINE_MAX];
	char		f[MaxFileNameLen];
	char		*colon;
	int		fd;
	int		cc;
	int		i;
	int		j;

	for (i = 0 ; i < ngroups ; i++) {
		if ((grp = getgrnam(groups[i])) == NULL) {
			warnx("can't append group `%s' for user `%s'",
			    groups[i], user);
		} else {
			for (j = 0 ; grp->gr_mem[j] ; j++) {
				if (strcmp(user, grp->gr_mem[j]) == 0) {
					/* already in it */
					groups[i] = "";
				}
			}
		}
	}
	if ((from = fopen(_PATH_GROUP, "r")) == NULL) {
		warn("can't append group for `%s': can't open `%s'", user,
		    _PATH_GROUP);
		return 0;
	}
	if (flock(fileno(from), LOCK_EX | LOCK_NB) < 0) {
		warn("can't lock `%s'", _PATH_GROUP);
	}
	(void) fstat(fileno(from), &st);
	(void) snprintf(f, sizeof(f), "%s.XXXXXXXX", _PATH_GROUP);
	if ((fd = mkstemp(f)) < 0) {
		(void) fclose(from);
		warn("can't append group: mkstemp failed");
		return 0;
	}
	if ((to = fdopen(fd, "w")) == NULL) {
		(void) fclose(from);
		(void) close(fd);
		(void) unlink(f);
		warn("can't append group: fdopen `%s' failed", f);
		return 0;
	}
	while (fgets(buf, sizeof(buf), from) != NULL) {
		cc = strlen(buf);
		if (buf[cc - 1] != '\n' && !feof(from)) {
			while (fgetc(from) != '\n' && !feof(from))
				cc++;
			warn("%s: line `%s' too long (%d bytes), skipping",
			    _PATH_GROUP, buf, cc);
			continue;
		}
		if ((colon = strchr(buf, ':')) == NULL) {
			warnx("badly formed entry `%s'", buf);
			continue;
		}
		for (i = 0 ; i < ngroups ; i++) {
			if (strncmp(groups[i], buf, colon - buf) == 0) {
				while (isspace(buf[cc - 1]))
					cc--;
				buf[(j = cc)] = '\0';
				if (buf[strlen(buf) - 1] != ':')
					strlcat(buf, ",", sizeof(buf));
				cc = strlcat(buf, user, sizeof(buf)) + 1;
				if (cc >= sizeof(buf)) {
					warnx("Warning: group `%s' would "
					    "become too long, not modifying",
					    groups[i]);
					cc = j + 1;
				}
				buf[cc - 1] = '\n';
				buf[cc] = '\0';
			}
		}
		if (fwrite(buf, cc, 1, to) != 1) {
			(void) fclose(from);
			(void) fclose(to);
			(void) unlink(f);
			warn("can't append group: short write to `%s'", f);
			return 0;
		}
	}
	(void) fclose(from);
	if (fclose(to) == EOF) {
		(void) unlink(f);
		warn("can't append group: short write to `%s'", f);
		return 0;
	}
	if (rename(f, _PATH_GROUP) < 0) {
		(void) unlink(f);
		warn("can't append group: can't rename `%s' to `%s'", f, _PATH_GROUP);
		return 0;
	}
	(void) chmod(_PATH_GROUP, st.st_mode & 07777);
	return 1;
}

/* return 1 if `login' is a valid login name */
static int
valid_login(char *login_name)
{
	unsigned char	*cp;

	/* The first character cannot be a hyphen */
	if (*login_name == '-')
		return 0;

	for (cp = login_name ; *cp ; cp++) {
		/* We allow '$' as the last character for samba */
		if (!isalnum(*cp) && *cp != '.' && *cp != '_' && *cp != '-' &&
		    !(*cp == '$' && *(cp + 1) == '\0')) {
			return 0;
		}
	}
	if ((char *)cp - login_name > MaxUserNameLen)
		return 0;
	return 1;
}

/* return 1 if `group' is a valid group name */
static int
valid_group(char *group)
{
	unsigned char	*cp;

	for (cp = group ; *cp ; cp++) {
		if (!isalnum(*cp) && *cp != '.' && *cp != '_' && *cp != '-') {
			return 0;
		}
	}
	if ((char *)cp - group > MaxUserNameLen)
		return 0;
	return 1;
}

#ifdef EXTENSIONS
/* return 1 if `class' exists */
static int
valid_class(char *class)
{
	login_cap_t *lc;

	if ((lc = login_getclass(class)) != NULL)
		login_close(lc);
	return lc != NULL;
}
#endif

/* find the next gid in the range lo .. hi */
static int
getnextgid(uid_t *gidp, uid_t lo, uid_t hi)
{
	for (*gidp = lo ; *gidp < hi ; *gidp += 1) {
		if (getgrgid((gid_t)*gidp) == NULL) {
			return 1;
		}
	}
	return 0;
}

#ifdef EXTENSIONS
/* save a range of uids */
static int
save_range(user_t *up, char *cp)
{
	int	from;
	int	to;
	int	i;

	if (up->u_rsize == 0) {
		up->u_rsize = 32;
		NEWARRAY(range_t, up->u_rv, up->u_rsize, return(0));
	} else if (up->u_rc == up->u_rsize) {
		up->u_rsize *= 2;
		RENEW(range_t, up->u_rv, up->u_rsize, return(0));
	}
	if (up->u_rv && sscanf(cp, "%d..%d", &from, &to) == 2) {
		for (i = up->u_defrc ; i < up->u_rc ; i++) {
			if (up->u_rv[i].r_from == from && up->u_rv[i].r_to == to) {
				break;
			}
		}
		if (i == up->u_rc) {
			up->u_rv[up->u_rc].r_from = from;
			up->u_rv[up->u_rc].r_to = to;
			up->u_rc += 1;
		}
	} else {
		warnx("Bad range `%s'", cp);
		return 0;
	}
	return 1;
}
#endif

/* set the defaults in the defaults file */
static int
setdefaults(user_t *up)
{
	char	template[MaxFileNameLen];
	FILE	*fp;
	int	ret;
	int	fd;
#ifdef EXTENSIONS
	int	i;
#endif

	(void) snprintf(template, sizeof(template), "%s.XXXXXXXX", CONFFILE);
	if ((fd = mkstemp(template)) < 0) {
		warnx("can't mkstemp `%s' for writing", CONFFILE);
		return 0;
	}
	if ((fp = fdopen(fd, "w")) == NULL) {
		warn("can't fdopen `%s' for writing", CONFFILE);
		return 0;
	}
	ret = 1;
	if (fprintf(fp, "group\t\t%s\n", up->u_primgrp) <= 0 ||
	    fprintf(fp, "base_dir\t%s\n", up->u_basedir) <= 0 ||
	    fprintf(fp, "skel_dir\t%s\n", up->u_skeldir) <= 0 ||
	    fprintf(fp, "shell\t\t%s\n", up->u_shell) <= 0 ||
#ifdef EXTENSIONS
	    fprintf(fp, "class\t\t%s\n", up->u_class) <= 0 ||
#endif
	    fprintf(fp, "inactive\t%s\n", (up->u_inactive == NULL) ? UNSET_INACTIVE : up->u_inactive) <= 0 ||
	    fprintf(fp, "expire\t\t%s\n", (up->u_expire == NULL) ? UNSET_EXPIRY : up->u_expire) <= 0 ||
	    fprintf(fp, "preserve\t%s\n", (up->u_preserve == 0) ? "false" : "true") <= 0) {
		warn("can't write to `%s'", CONFFILE);
		ret = 0;
	}
#ifdef EXTENSIONS
	for (i = (up->u_defrc != up->u_rc) ? up->u_defrc : 0 ; i < up->u_rc ; i++) {
		if (fprintf(fp, "range\t\t%d..%d\n", up->u_rv[i].r_from, up->u_rv[i].r_to) <= 0) {
			warn("can't write to `%s'", CONFFILE);
			ret = 0;
		}
	}
#endif
	if (fclose(fp) == EOF) {
		warn("can't write to `%s'", CONFFILE);
		ret = 0;
	}
	if (ret) {
		ret = ((rename(template, CONFFILE) == 0) && (chmod(CONFFILE, 0644) == 0));
	}
	return ret;
}

/* read the defaults file */
static void
read_defaults(user_t *up)
{
	struct stat	st;
	size_t		lineno;
	size_t		len;
	FILE		*fp;
	unsigned char	*cp;
	unsigned char	*s;

	memsave(&up->u_primgrp, DEF_GROUP, strlen(DEF_GROUP));
	memsave(&up->u_basedir, DEF_BASEDIR, strlen(DEF_BASEDIR));
	memsave(&up->u_skeldir, DEF_SKELDIR, strlen(DEF_SKELDIR));
	memsave(&up->u_shell, DEF_SHELL, strlen(DEF_SHELL));
	memsave(&up->u_comment, DEF_COMMENT, strlen(DEF_COMMENT));
#ifdef EXTENSIONS
	memsave(&up->u_class, DEF_CLASS, strlen(DEF_CLASS));
#endif
	up->u_rsize = 16;
	up->u_defrc = 0;
	NEWARRAY(range_t, up->u_rv, up->u_rsize, exit(1));
	up->u_inactive = DEF_INACTIVE;
	up->u_expire = DEF_EXPIRE;
	if ((fp = fopen(CONFFILE, "r")) == NULL) {
		if (stat(CONFFILE, &st) < 0 && !setdefaults(up)) {
			warn("can't create `%s' defaults file", CONFFILE);
		}
		fp = fopen(CONFFILE, "r");
	}
	if (fp != NULL) {
		while ((s = fparseln(fp, &len, &lineno, NULL, 0)) != NULL) {
			if (strncmp(s, "group", 5) == 0) {
				for (cp = s + 5 ; *cp && isspace(*cp) ; cp++) {
				}
				memsave(&up->u_primgrp, cp, strlen(cp));
			} else if (strncmp(s, "base_dir", 8) == 0) {
				for (cp = s + 8 ; *cp && isspace(*cp) ; cp++) {
				}
				memsave(&up->u_basedir, cp, strlen(cp));
			} else if (strncmp(s, "skel_dir", 8) == 0) {
				for (cp = s + 8 ; *cp && isspace(*cp) ; cp++) {
				}
				memsave(&up->u_skeldir, cp, strlen(cp));
			} else if (strncmp(s, "shell", 5) == 0) {
				for (cp = s + 5 ; *cp && isspace(*cp) ; cp++) {
				}
				memsave(&up->u_shell, cp, strlen(cp));
			} else if (strncmp(s, "password", 8) == 0) {
				for (cp = s + 8 ; *cp && isspace(*cp) ; cp++) {
				}
				memsave(&up->u_password, cp, strlen(cp));
#ifdef EXTENSIONS
			} else if (strncmp(s, "class", 5) == 0) {
				for (cp = s + 5 ; *cp && isspace(*cp) ; cp++) {
				}
				memsave(&up->u_class, cp, strlen(cp));
#endif
			} else if (strncmp(s, "inactive", 8) == 0) {
				for (cp = s + 8 ; *cp && isspace(*cp) ; cp++) {
				}
				if (strcmp(cp, UNSET_INACTIVE) == 0) {
					if (up->u_inactive) {
						FREE(up->u_inactive);
					}
					up->u_inactive = NULL;
				} else {
					memsave(&up->u_inactive, cp, strlen(cp));
				}
#ifdef EXTENSIONS
			} else if (strncmp(s, "range", 5) == 0) {
				for (cp = s + 5 ; *cp && isspace(*cp) ; cp++) {
				}
				(void) save_range(up, cp);
#endif
#ifdef EXTENSIONS
			} else if (strncmp(s, "preserve", 8) == 0) {
				for (cp = s + 8 ; *cp && isspace(*cp) ; cp++) {
				}
				up->u_preserve = (strncmp(cp, "true", 4) == 0) ? 1 :
						  (strncmp(cp, "yes", 3) == 0) ? 1 :
						   atoi(cp);
#endif
			} else if (strncmp(s, "expire", 6) == 0) {
				for (cp = s + 6 ; *cp && isspace(*cp) ; cp++) {
				}
				if (strcmp(cp, UNSET_EXPIRY) == 0) {
					if (up->u_expire) {
						FREE(up->u_expire);
					}
					up->u_expire = NULL;
				} else {
					memsave(&up->u_expire, cp, strlen(cp));
				}
			}
			(void) free(s);
		}
		(void) fclose(fp);
	}
	if (up->u_rc == 0) {
		up->u_rv[up->u_rc].r_from = DEF_LOWUID;
		up->u_rv[up->u_rc].r_to = DEF_HIGHUID;
		up->u_rc += 1;
	}
	up->u_defrc = up->u_rc;
}

/* return the next valid unused uid */
static int
getnextuid(int sync_uid_gid, uid_t *uid, uid_t low_uid, uid_t high_uid)
{
	for (*uid = low_uid ; *uid <= high_uid ; (*uid)++) {
		if (getpwuid((uid_t)(*uid)) == NULL && *uid != NOBODY_UID) {
			if (sync_uid_gid) {
				if (getgrgid((gid_t)(*uid)) == NULL) {
					return 1;
				}
			} else {
				return 1;
			}
		}
	}
	return 0;
}

/* structure which defines a password type */
typedef struct passwd_type_t {
	const char     *type;		/* optional type descriptor */
	int		desc_length;	/* length of type descriptor */
	int		length;		/* length of password */
	const char     *regex;		/* regexp to output the password */
	int		re_sub;		/* subscript of regexp to use */
} passwd_type_t;

static passwd_type_t	passwd_types[] = {
	{ "$2a",	3,	54,	"\\$[^$]+\\$[^$]+\\$(.*)",	1 },	/* Blowfish */
	{ "$1",		2,	34,	NULL,				0 },	/* MD5 */
	{ "",		0,	DES_Len,NULL,				0 },	/* standard DES */
	{ NULL,		-1,	-1,	NULL,				0 }	/* none - terminate search */
};

/* return non-zero if it's a valid password - check length for cipher type */
static int
valid_password_length(char *newpasswd)
{
	passwd_type_t  *pwtp;
	regmatch_t	matchv[10];
	regex_t		r;

	for (pwtp = passwd_types ; pwtp->desc_length >= 0 ; pwtp++) {
		if (strncmp(newpasswd, pwtp->type, pwtp->desc_length) == 0) {
			if (pwtp->regex == NULL) {
				return strlen(newpasswd) == pwtp->length;
			}
			(void) regcomp(&r, pwtp->regex, REG_EXTENDED);
			if (regexec(&r, newpasswd, 10, matchv, 0) == 0) {
				regfree(&r);
				return (int)(matchv[pwtp->re_sub].rm_eo - matchv[pwtp->re_sub].rm_so + 1) == pwtp->length;
			}
			regfree(&r);
		}
	}
	return 0;
}

/* look for a valid time, return 0 if it was specified but bad */
static int
scantime(time_t *tp, char *s)
{
	struct tm	tm;

	*tp = 0;
	if (s != NULL) {
		(void) memset(&tm, 0, sizeof(tm));
		if (strptime(s, "%c", &tm) != NULL) {
			*tp = mktime(&tm);
		} else if (strptime(s, "%B %d %Y", &tm) != NULL) {
			*tp = mktime(&tm);
		} else if (!isdigit((unsigned char) s[0])) {
			*tp = atoi(s);
		} else {
			return 0;
		}
	}
	return 1;
}

/* compute the extra length '&' expansion consumes */
static size_t
expand_len(const char *p, const char *username)
{
	size_t alen;
	size_t ulen;

	ulen = strlen(username);
	for (alen = 0; *p != '\0'; p++)
		if (*p == '&')
			alen += ulen - 1;
	return alen;
}

/* add a user */
static int
adduser(char *login_name, user_t *up)
{
	struct group	*grp;
	struct stat	st;
	time_t		expire;
	time_t		inactive;
	char		password[PasswordLength + 1];
	char		home[MaxFileNameLen];
	char		buf[LINE_MAX];
	int		sync_uid_gid;
	int		masterfd;
	int		ptmpfd;
	gid_t		gid;
	int		cc;
	int		i;

	if (!valid_login(login_name)) {
		errx(EXIT_FAILURE, "`%s' is not a valid login name", login_name);
	}
#ifdef EXTENSIONS
	if (!valid_class(up->u_class)) {
		errx(EXIT_FAILURE, "No such login class `%s'", up->u_class);
	}
#endif
	if ((masterfd = open(_PATH_MASTERPASSWD, O_RDONLY)) < 0) {
		err(EXIT_FAILURE, "can't open `%s'", _PATH_MASTERPASSWD);
	}
	if (flock(masterfd, LOCK_EX | LOCK_NB) < 0) {
		err(EXIT_FAILURE, "can't lock `%s'", _PATH_MASTERPASSWD);
	}
	pw_init();
	if ((ptmpfd = pw_lock(WAITSECS)) < 0) {
		(void) close(masterfd);
		err(EXIT_FAILURE, "can't obtain pw_lock");
	}
	while ((cc = read(masterfd, buf, sizeof(buf))) > 0) {
		if (write(ptmpfd, buf, (size_t)(cc)) != cc) {
			(void) close(masterfd);
			(void) close(ptmpfd);
			pw_abort();
			err(EXIT_FAILURE, "short write to /etc/ptmp (not %d chars)", cc);
		}
	}
	/* if no uid was specified, get next one in [low_uid..high_uid] range */
	sync_uid_gid = (strcmp(up->u_primgrp, "=uid") == 0);
	if (up->u_uid == UID_MAX) {
		int got_id = 0;

		/*
		 * Look for a free UID in the command line ranges (if any).
		 * These start after the ranges specified in the config file.
		 */
		for (i = up->u_defrc; got_id == 0 && i < up->u_rc ; i++) {
			got_id = getnextuid(sync_uid_gid, &up->u_uid,
			    up->u_rv[i].r_from, up->u_rv[i].r_to);
	 	}
		/*
		 * If there were no free UIDs in the command line ranges,
		 * try the ranges from the config file (there will always
		 * be at least one default).
		 */
		if (got_id == 0) {
			for (i = 0; got_id == 0 && i < up->u_defrc; i++) {
				got_id = getnextuid(sync_uid_gid, &up->u_uid,
				    up->u_rv[i].r_from, up->u_rv[i].r_to);
			}
		}
		if (got_id == 0) {
			(void) close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "can't get next uid for %u", up->u_uid);
		}
	}
	/* check uid isn't already allocated */
	if (!(up->u_flags & F_DUPUID) && getpwuid((uid_t)(up->u_uid)) != NULL) {
		(void) close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "uid %u is already in use", up->u_uid);
	}
	/* if -g=uid was specified, check gid is unused */
	if (sync_uid_gid) {
		if (getgrgid((gid_t)(up->u_uid)) != NULL) {
			(void) close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "gid %u is already in use", up->u_uid);
		}
		gid = up->u_uid;
	} else if ((grp = getgrnam(up->u_primgrp)) != NULL) {
		gid = grp->gr_gid;
	} else if (is_number(up->u_primgrp) &&
		   (grp = getgrgid((gid_t)atoi(up->u_primgrp))) != NULL) {
		gid = grp->gr_gid;
	} else {
		(void) close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "group %s not found", up->u_primgrp);
	}
	/* check name isn't already in use */
	if (!(up->u_flags & F_DUPUID) && getpwnam(login_name) != NULL) {
		(void) close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "already a `%s' user", login_name);
	}
	if (up->u_flags & F_HOMEDIR) {
		(void) strlcpy(home, up->u_home, sizeof(home));
	} else {
		/* if home directory hasn't been given, make it up */
		(void) snprintf(home, sizeof(home), "%s/%s", up->u_basedir,
		    login_name);
	}
	if (!scantime(&inactive, up->u_inactive)) {
		warnx("Warning: inactive time `%s' invalid, account expiry off",
				up->u_inactive);
	}
	if (!scantime(&expire, up->u_expire)) {
		warnx("Warning: expire time `%s' invalid, password expiry off",
				up->u_expire);
	}
	if (lstat(home, &st) < 0 && !(up->u_flags & F_MKDIR) &&
	    strcmp(home, _PATH_NONEXISTENT) != 0) {
		warnx("Warning: home directory `%s' doesn't exist, and -m was"
		    " not specified", home);
	}
	if (up->u_password != NULL && valid_password_length(up->u_password)) {
		(void) strlcpy(password, up->u_password, sizeof(password));
	} else {
		(void) memset(password, '*', DES_Len);
		password[DES_Len] = 0;
		if (up->u_password != NULL) {
			warnx("Password `%s' is invalid: setting it to `%s'",
				up->u_password, password);
		}
	}
	cc = snprintf(buf, sizeof(buf), "%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n",
	    login_name,
	    password,
	    up->u_uid,
	    gid,
#ifdef EXTENSIONS
	    up->u_class,
#else
	    "",
#endif
	    (long) inactive,
	    (long) expire,
	    up->u_comment,
	    home,
	    up->u_shell);
	if (cc >= sizeof(buf) || cc < 0 ||
	    cc + expand_len(up->u_comment, login_name) >= 1023) {
		(void) close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "can't add `%s', line too long", buf);
	}
	if (write(ptmpfd, buf, (size_t) cc) != cc) {
		(void) close(ptmpfd);
		pw_abort();
		err(EXIT_FAILURE, "can't add `%s'", buf);
	}
	if (up->u_flags & F_MKDIR) {
		if (lstat(home, &st) == 0) {
			(void) close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "home directory `%s' already exists",
			    home);
		} else {
			if (asystem("%s -p %s", MKDIR, home) != 0) {
				(void) close(ptmpfd);
				pw_abort();
				err(EXIT_FAILURE, "can't mkdir `%s'", home);
			}
			(void) copydotfiles(up->u_skeldir, up->u_uid, gid, home);
		}
	}
	if (strcmp(up->u_primgrp, "=uid") == 0 &&
	    getgrnam(login_name) == NULL &&
	    !creategid(login_name, gid, login_name)) {
		(void) close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "can't create gid %d for login name %s",
		    gid, login_name);
	}
	if (up->u_groupc > 0 && !append_group(login_name, up->u_groupc, up->u_groupv)) {
		(void) close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "can't append `%s' to new groups", login_name);
	}
	(void) close(ptmpfd);
	if (pw_mkdb(login_name, 0) < 0) {
		pw_abort();
		err(EXIT_FAILURE, "pw_mkdb failed");
	}
	syslog(LOG_INFO, "new user added: name=%s, uid=%d, gid=%d, home=%s, shell=%s",
		login_name, up->u_uid, gid, home, up->u_shell);
	return 1;
}

/* remove a user from the groups file */
static int
rm_user_from_groups(char *login_name)
{
	struct stat	st;
	size_t		login_len;
	FILE		*from;
	FILE		*to;
	char		buf[LINE_MAX];
	char		f[MaxFileNameLen];
	char		*cp, *ep;
	int		fd;
	int		cc;

	login_len = strlen(login_name);
	if ((from = fopen(_PATH_GROUP, "r")) == NULL) {
		warn("can't remove gid for `%s': can't open `%s'",
		    login_name, _PATH_GROUP);
		return 0;
	}
	if (flock(fileno(from), LOCK_EX | LOCK_NB) < 0) {
		warn("can't lock `%s'", _PATH_GROUP);
	}
	(void) fstat(fileno(from), &st);
	(void) snprintf(f, sizeof(f), "%s.XXXXXXXX", _PATH_GROUP);
	if ((fd = mkstemp(f)) < 0) {
		(void) fclose(from);
		warn("can't remove gid for `%s': mkstemp failed", login_name);
		return 0;
	}
	if ((to = fdopen(fd, "w")) == NULL) {
		(void) fclose(from);
		(void) close(fd);
		(void) unlink(f);
		warn("can't remove gid for `%s': fdopen `%s' failed",
		    login_name, f);
		return 0;
	}
	while (fgets(buf, sizeof(buf), from) > 0) {
		cc = strlen(buf);
		if (buf[cc - 1] != '\n' && !feof(from)) {
			while (fgetc(from) != '\n' && !feof(from))
				cc++;
			warn("%s: line `%s' too long (%d bytes), skipping",
			    _PATH_GROUP, buf, cc);
			continue;
		}

		/* Break out the group list. */
		for (cp = buf, cc = 0; *cp != '\0' && cc < 3; cp++) {
			if (*cp == ':')
				cc++;
		}
		if (cc != 3) {
			warnx("Malformed entry `%.*s'. Skipping",
			    (int)strlen(buf) - 1, buf);
			continue;
		}
		while ((cp = strstr(cp, login_name)) != NULL) {
			if ((cp[-1] == ':' || cp[-1] == ',') &&
			    (cp[login_len] == ',' || cp[login_len] == '\n')) {
				ep = cp + login_len;
				if (cp[login_len] == ',')
					ep++;
				else if (cp[-1] == ',')
					cp--;
				memmove(cp, ep, strlen(ep) + 1);
			} else {
				if ((cp = strchr(cp, ',')) == NULL)
					break;
				cp++;
			}
		}
		if (fwrite(buf, strlen(buf), 1, to) != 1) {
			(void) fclose(from);
			(void) fclose(to);
			(void) unlink(f);
			warn("can't remove gid for `%s': short write to `%s'",
			    login_name, f);
			return 0;
		}
	}
	(void) fchmod(fileno(to), st.st_mode & 07777);
	(void) fclose(from);
	if (fclose(to) == EOF) {
		(void) unlink(f);
		warn("can't remove gid for `%s': short write to `%s'",
		    login_name, f);
		return 0;
	}
	if (rename(f, _PATH_GROUP) < 0) {
		(void) unlink(f);
		warn("can't remove gid for `%s': can't rename `%s' to `%s'",
		    login_name, f, _PATH_GROUP);
		return 0;
	}
	return 1;
}

/* check that the user or group is local, not from YP/NIS */
static int
is_local(char *name, const char *file)
{
	regmatch_t	matchv[10];
	regex_t		r;
	FILE	       *fp;
	char		buf[LINE_MAX];
	char		re[LINE_MAX];
	int		ret;
	int		cc;

	(void) snprintf(re, sizeof(re), "^%s:", name);
	if (regcomp(&r, re, REG_EXTENDED) != 0) {
		errx(EXIT_FAILURE, "can't compile regular expression `%s'", re);
	}
	if ((fp = fopen(file, "r")) == NULL) {
		err(EXIT_FAILURE, "can't open `%s'", file);
	}
	for (ret = 0 ; fgets(buf, sizeof(buf), fp) != NULL ; ) {
		cc = strlen(buf);
		if (buf[cc - 1] != '\n' && !feof(fp)) {
			while (fgetc(fp) != '\n' && !feof(fp))
				cc++;
			warn("%s: line `%s' too long (%d bytes), skipping",
			    file, buf, cc);
			continue;
		}
		if (regexec(&r, buf, 10, matchv, 0) == 0) {
			ret = 1;
			break;
		}
	}
	(void) fclose(fp);
	return ret;
}

/* modify a user */
static int
moduser(char *login_name, char *newlogin, user_t *up)
{
	struct passwd	*pwp;
	struct group	*grp;
	const char	*homedir;
	char		buf[LINE_MAX];
	size_t		colonc, loginc;
	size_t		cc;
	FILE		*master;
	char		newdir[MaxFileNameLen];
	char		*colon;
	int		len;
	int		masterfd;
	int		ptmpfd;
	int		rval;

	if (!valid_login(newlogin)) {
		errx(EXIT_FAILURE, "`%s' is not a valid login name", login_name);
	}
	if ((pwp = getpwnam(login_name)) == NULL) {
		errx(EXIT_FAILURE, "No such user `%s'", login_name);
	}
	if (!is_local(login_name, _PATH_MASTERPASSWD)) {
		errx(EXIT_FAILURE, "User `%s' must be a local user", login_name);
	}
	/* keep dir name in case we need it for '-m' */
	homedir = pwp->pw_dir;

	if ((masterfd = open(_PATH_MASTERPASSWD, O_RDONLY)) < 0) {
		err(EXIT_FAILURE, "can't open `%s'", _PATH_MASTERPASSWD);
	}
	if (flock(masterfd, LOCK_EX | LOCK_NB) < 0) {
		err(EXIT_FAILURE, "can't lock `%s'", _PATH_MASTERPASSWD);
	}
	pw_init();
	if ((ptmpfd = pw_lock(WAITSECS)) < 0) {
		(void) close(masterfd);
		err(EXIT_FAILURE, "can't obtain pw_lock");
	}
	if ((master = fdopen(masterfd, "r")) == NULL) {
		(void) close(masterfd);
		(void) close(ptmpfd);
		pw_abort();
		err(EXIT_FAILURE, "can't fdopen fd for %s", _PATH_MASTERPASSWD);
	}
	if (up != NULL) {
		if (up->u_flags & F_USERNAME) {
			/* if changing name, check new name isn't already in use */
			if (strcmp(login_name, newlogin) != 0 && getpwnam(newlogin) != NULL) {
				(void) close(ptmpfd);
				pw_abort();
				errx(EXIT_FAILURE, "already a `%s' user", newlogin);
			}
			pwp->pw_name = newlogin;

			/*
			 * Provide a new directory name in case the
			 * home directory is to be moved.
			 */
			if (up->u_flags & F_MKDIR) {
				(void) snprintf(newdir, sizeof(newdir),
				    "%s/%s", up->u_basedir, newlogin);
				pwp->pw_dir = newdir;
			}
		}
		if (up->u_flags & F_PASSWORD) {
			if (up->u_password != NULL) {
				if (!valid_password_length(up->u_password)) {
					(void) close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "Invalid password: `%s'",
						up->u_password);
				}
				pwp->pw_passwd = up->u_password;
			}
		}
		if (up->u_flags & F_UID) {
			/* check uid isn't already allocated */
			if (!(up->u_flags & F_DUPUID) && getpwuid((uid_t)(up->u_uid)) != NULL) {
				(void) close(ptmpfd);
				pw_abort();
				errx(EXIT_FAILURE, "uid %u is already in use", up->u_uid);
			}
			pwp->pw_uid = up->u_uid;
		}
		if (up->u_flags & F_GROUP) {
			/* if -g=uid was specified, check gid is unused */
			if (strcmp(up->u_primgrp, "=uid") == 0) {
				if (getgrgid((gid_t)(up->u_uid)) != NULL) {
					(void) close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "gid %u is already in use", up->u_uid);
				}
				pwp->pw_gid = up->u_uid;
			} else if ((grp = getgrnam(up->u_primgrp)) != NULL) {
				pwp->pw_gid = grp->gr_gid;
			} else if (is_number(up->u_primgrp) &&
				   (grp = getgrgid((gid_t)atoi(up->u_primgrp))) != NULL) {
				pwp->pw_gid = grp->gr_gid;
			} else {
				(void) close(ptmpfd);
				pw_abort();
				errx(EXIT_FAILURE, "group %s not found", up->u_primgrp);
			}
		}
		if (up->u_flags & F_INACTIVE) {
			if (!scantime(&pwp->pw_change, up->u_inactive)) {
				warnx("Warning: inactive time `%s' invalid, password expiry off",
					up->u_inactive);
			}
		}
		if (up->u_flags & F_EXPIRE) {
			if (!scantime(&pwp->pw_expire, up->u_expire)) {
				warnx("Warning: expire time `%s' invalid, password expiry off",
					up->u_expire);
			}
		}
		if (up->u_flags & F_COMMENT)
			pwp->pw_gecos = up->u_comment;
		if (up->u_flags & F_HOMEDIR)
			pwp->pw_dir = up->u_home;
		if (up->u_flags & F_SHELL)
			pwp->pw_shell = up->u_shell;
#ifdef EXTENSIONS
		if (up->u_flags & F_CLASS) {
			if (!valid_class(up->u_class)) {
				(void) close(ptmpfd);
				pw_abort();
				errx(EXIT_FAILURE,
				    "No such login class `%s'", up->u_class);
			}
			pwp->pw_class = up->u_class;
		}
#endif
	}
	loginc = strlen(login_name);
	while (fgets(buf, sizeof(buf), master) != NULL) {
		if ((colon = strchr(buf, ':')) == NULL) {
			warnx("Malformed entry `%s'. Skipping", buf);
			continue;
		}
		colonc = (size_t)(colon - buf);
		if (strncmp(login_name, buf, loginc) == 0 && loginc == colonc) {
			if (up != NULL) {
				if ((len = snprintf(buf, sizeof(buf),
				    "%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n",
				    newlogin,
				    pwp->pw_passwd,
				    pwp->pw_uid,
				    pwp->pw_gid,
#ifdef EXTENSIONS
				    pwp->pw_class,
#else
				    "",
#endif
				    (long)pwp->pw_change,
				    (long)pwp->pw_expire,
				    pwp->pw_gecos,
				    pwp->pw_dir,
				    pwp->pw_shell)) >= sizeof(buf) || len < 0 ||
				    len + expand_len(pwp->pw_gecos, newlogin)
				    >= 1023) {
					(void) close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "can't add `%s', "
					    "line too long (%d bytes)", buf,
					    len + expand_len(pwp->pw_gecos,
					    newlogin));
				}
				if (write(ptmpfd, buf, len) != len) {
					(void) close(ptmpfd);
					pw_abort();
					err(EXIT_FAILURE, "can't add `%s'", buf);
				}
			}
		} else {
			len = strlen(buf);
			if ((cc = write(ptmpfd, buf, len)) != len) {
				(void) close(masterfd);
				(void) close(ptmpfd);
				pw_abort();
				err(EXIT_FAILURE, "short write to /etc/ptmp (%lld not %lld chars)",
				    (long long)cc, (long long)len);
			}
		}
	}
	if (up != NULL) {
		if ((up->u_flags & F_MKDIR) &&
		    asystem("%s %s %s", MV, homedir, pwp->pw_dir) != 0) {
			(void) close(ptmpfd);
			pw_abort();
			err(EXIT_FAILURE, "can't move `%s' to `%s'",
			    homedir, pwp->pw_dir);
		}
		if (up->u_groupc > 0 &&
		    !append_group(newlogin, up->u_groupc, up->u_groupv)) {
			(void) close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "can't append `%s' to new groups",
			    newlogin);
		}
	}
	(void) close(ptmpfd);
	if (up != NULL && strcmp(login_name, newlogin) == 0)
		rval = pw_mkdb(login_name, 0);
	else
		rval = pw_mkdb(NULL, 0);
	if (rval == -1) {
		pw_abort();
		err(EXIT_FAILURE, "pw_mkdb failed");
	}
	if (up == NULL) {
		syslog(LOG_INFO, "user removed: name=%s", login_name);
	} else if (strcmp(login_name, newlogin) == 0) {
		syslog(LOG_INFO, "user information modified: name=%s, uid=%d, gid=%d, home=%s, shell=%s",
			login_name, pwp->pw_uid, pwp->pw_gid, pwp->pw_dir, pwp->pw_shell);
	} else {
		syslog(LOG_INFO, "user information modified: name=%s, new name=%s, uid=%d, gid=%d, home=%s, shell=%s",
			login_name, newlogin, pwp->pw_uid, pwp->pw_gid, pwp->pw_dir, pwp->pw_shell);
	}
	return 1;
}


#ifdef EXTENSIONS
/* see if we can find out the user struct */
static struct passwd *
find_user_info(char *name)
{
	struct passwd	*pwp;

	if ((pwp = getpwnam(name)) != NULL) {
		return pwp;
	}
	if (is_number(name) && (pwp = getpwuid((uid_t)atoi(name))) != NULL) {
		return pwp;
	}
	return NULL;
}
#endif

#ifdef EXTENSIONS
/* see if we can find out the group struct */
static struct group *
find_group_info(char *name)
{
	struct group	*grp;

	if ((grp = getgrnam(name)) != NULL) {
		return grp;
	}
	if (is_number(name) && (grp = getgrgid((gid_t)atoi(name))) != NULL) {
		return grp;
	}
	return NULL;
}
#endif

/* print out usage message, and then exit */
void
usermgmt_usage(const char *prog)
{
	if (strcmp(prog, "useradd") == 0) {
		(void) fprintf(stderr, "usage: %s -D [-b basedir] [-e expiry] "
		    "[-f changetime] [-g group]\n\t\t[-k skeletondir] "
		    "[-r low..high] [-s shell] [-L class]\n", prog);
		(void) fprintf(stderr, "usage: %s [-mov] [-G group[,group,...]]"
		    " [-b basedir] [-c comment]\n\t\t"
		    "[-d homedir] [-e expiry] [-f changetime] [-g group]\n\t\t"
		    "[-k skeletondir] [-p password] "
		    "[-r lowuid..highuid]\n\t\t[-s shell] [-u uid] [-L class] "
		    "user\n", prog);
	} else if (strcmp(prog, "usermod") == 0) {
		(void) fprintf(stderr, "usage: %s [-mov] [-G group[,group,...]]"
		    " [-c comment] [-d homedir]\n\t\t"
		    "[-e expire] [-f changetime] [-g group] [-l newname]\n\t\t"
		    "[-p password] [-s shell] [-u uid] [-L class] user\n",
		    prog);
	} else if (strcmp(prog, "userdel") == 0) {
		(void) fprintf(stderr, "usage: %s -D [-p preserve]\n", prog);
		(void) fprintf(stderr, "usage: %s [-prv] user\n", prog);
#ifdef EXTENSIONS
	} else if (strcmp(prog, "userinfo") == 0) {
		(void) fprintf(stderr, "usage: %s [-ev] user\n", prog);
#endif
	} else if (strcmp(prog, "groupadd") == 0) {
		(void) fprintf(stderr, "usage: %s [-ov] [-g gid] group\n",
		    prog);
	} else if (strcmp(prog, "groupdel") == 0) {
		(void) fprintf(stderr, "usage: %s [-v] group\n", prog);
	} else if (strcmp(prog, "groupmod") == 0) {
		(void) fprintf(stderr, "usage: %s [-ov] [-g gid] [-n newname] "
		    "group\n", prog);
	} else if (strcmp(prog, "user") == 0 || strcmp(prog, "group") == 0) {
		(void) fprintf(stderr, "usage: %s [ add | del | mod "
#ifdef EXTENSIONS
		"| info "
#endif
		"] ...\n",
		    prog);
#ifdef EXTENSIONS
	} else if (strcmp(prog, "groupinfo") == 0) {
		(void) fprintf(stderr, "usage: %s [-ev] group\n", prog);
#endif
	} else {
		(void) fprintf(stderr, "This program must be called as {user,group}{add,del,mod,info},\n%s is not an understood name.\n", prog);
	}
	exit(EXIT_FAILURE);
	/* NOTREACHED */
}

#ifdef EXTENSIONS
#define ADD_OPT_EXTENSIONS	"p:r:vL:"
#else
#define ADD_OPT_EXTENSIONS
#endif

int
useradd(int argc, char **argv)
{
	user_t	u;
	int	defaultfield;
	int	bigD;
	int	c;
#ifdef EXTENSIONS
	int	i;
#endif

	(void) memset(&u, 0, sizeof(u));
	read_defaults(&u);
	u.u_uid = UID_MAX;
	defaultfield = bigD = 0;
	while ((c = getopt(argc, argv, "DG:b:c:d:e:f:g:k:mou:s:" ADD_OPT_EXTENSIONS)) != -1) {
		switch(c) {
		case 'D':
			bigD = 1;
			break;
		case 'G':
			while ((u.u_groupv[u.u_groupc] = strsep(&optarg, ",")) != NULL &&
			    u.u_groupc < NGROUPS_MAX - 2) {
				if (u.u_groupv[u.u_groupc][0] != 0) {
					u.u_groupc++;
				}
			}
			if (optarg != NULL) {
				warnx("Truncated list of secondary groups to %d entries", NGROUPS_MAX - 2);
			}
			break;
		case 'b':
			defaultfield = 1;
			memsave(&u.u_basedir, optarg, strlen(optarg));
			break;
		case 'c':
			memsave(&u.u_comment, optarg, strlen(optarg));
			break;
		case 'd':
			memsave(&u.u_home, optarg, strlen(optarg));
			u.u_flags |= F_HOMEDIR;
			break;
		case 'e':
			defaultfield = 1;
			memsave(&u.u_expire, optarg, strlen(optarg));
			break;
		case 'f':
			defaultfield = 1;
			memsave(&u.u_inactive, optarg, strlen(optarg));
			break;
		case 'g':
			defaultfield = 1;
			memsave(&u.u_primgrp, optarg, strlen(optarg));
			break;
		case 'k':
			defaultfield = 1;
			memsave(&u.u_skeldir, optarg, strlen(optarg));
			break;
#ifdef EXTENSIONS
		case 'L':
			defaultfield = 1;
			memsave(&u.u_class, optarg, strlen(optarg));
			break;
#endif
		case 'm':
			u.u_flags |= F_MKDIR;
			break;
		case 'o':
			u.u_flags |= F_DUPUID;
			break;
#ifdef EXTENSIONS
		case 'p':
			memsave(&u.u_password, optarg, strlen(optarg));
			break;
#endif
#ifdef EXTENSIONS
		case 'r':
			defaultfield = 1;
			(void) save_range(&u, optarg);
			break;
#endif
		case 's':
			defaultfield = 1;
			memsave(&u.u_shell, optarg, strlen(optarg));
			break;
		case 'u':
			if (!is_number(optarg)) {
				errx(EXIT_FAILURE, "When using [-u uid], the uid must be numeric");
			}
			u.u_uid = atoi(optarg);
			break;
#ifdef EXTENSIONS
		case 'v':
			verbose = 1;
			break;
#endif
		default:
			usermgmt_usage("useradd");
			/* NOTREACHED */
		}
	}
	if (bigD) {
		if (defaultfield) {
			checkeuid();
			return setdefaults(&u) ? EXIT_SUCCESS : EXIT_FAILURE;
		}
		(void) printf("group\t\t%s\n", u.u_primgrp);
		(void) printf("base_dir\t%s\n", u.u_basedir);
		(void) printf("skel_dir\t%s\n", u.u_skeldir);
		(void) printf("shell\t\t%s\n", u.u_shell);
#ifdef EXTENSIONS
		(void) printf("class\t\t%s\n", u.u_class);
#endif
		(void) printf("inactive\t%s\n", (u.u_inactive == NULL) ? UNSET_INACTIVE : u.u_inactive);
		(void) printf("expire\t\t%s\n", (u.u_expire == NULL) ? UNSET_EXPIRY : u.u_expire);
#ifdef EXTENSIONS
		for (i = 0 ; i < u.u_rc ; i++) {
			(void) printf("range\t\t%d..%d\n", u.u_rv[i].r_from, u.u_rv[i].r_to);
		}
#endif
		return EXIT_SUCCESS;
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("useradd");
	}
	checkeuid();
	openlog("useradd", LOG_PID, LOG_USER);
	return adduser(*argv, &u) ? EXIT_SUCCESS : EXIT_FAILURE;
}

#ifdef EXTENSIONS
#define MOD_OPT_EXTENSIONS	"p:vL:"
#else
#define MOD_OPT_EXTENSIONS
#endif

int
usermod(int argc, char **argv)
{
	user_t	u;
	char	newuser[MaxUserNameLen + 1];
	int	c, have_new_user;

	(void) memset(&u, 0, sizeof(u));
	(void) memset(newuser, 0, sizeof(newuser));
	read_defaults(&u);
	free(u.u_primgrp);
	u.u_primgrp = NULL;
	have_new_user = 0;
	while ((c = getopt(argc, argv, "G:c:d:e:f:g:l:mos:u:" MOD_OPT_EXTENSIONS)) != -1) {
		switch(c) {
		case 'G':
			while ((u.u_groupv[u.u_groupc] = strsep(&optarg, ",")) != NULL &&
			    u.u_groupc < NGROUPS_MAX - 2) {
				if (u.u_groupv[u.u_groupc][0] != 0) {
					u.u_groupc++;
				}
			}
			if (optarg != NULL) {
			  	warnx("Truncated list of secondary groups to %d entries", NGROUPS_MAX - 2);
			}
			u.u_flags |= F_SECGROUP;
			break;
		case 'c':
			memsave(&u.u_comment, optarg, strlen(optarg));
			u.u_flags |= F_COMMENT;
			break;
		case 'd':
			memsave(&u.u_home, optarg, strlen(optarg));
			u.u_flags |= F_HOMEDIR;
			break;
		case 'e':
			memsave(&u.u_expire, optarg, strlen(optarg));
			u.u_flags |= F_EXPIRE;
			break;
		case 'f':
			memsave(&u.u_inactive, optarg, strlen(optarg));
			u.u_flags |= F_INACTIVE;
			break;
		case 'g':
			memsave(&u.u_primgrp, optarg, strlen(optarg));
			u.u_flags |= F_GROUP;
			break;
		case 'l':
			(void) strlcpy(newuser, optarg, sizeof(newuser));
			have_new_user = 1;
			u.u_flags |= F_USERNAME;
			break;
#ifdef EXTENSIONS
		case 'L':
			memsave(&u.u_class, optarg, strlen(optarg));
			u.u_flags |= F_CLASS;
			break;
#endif
		case 'm':
			u.u_flags |= F_MKDIR;
			break;
		case 'o':
			u.u_flags |= F_DUPUID;
			break;
#ifdef EXTENSIONS
		case 'p':
			memsave(&u.u_password, optarg, strlen(optarg));
			u.u_flags |= F_PASSWORD;
			break;
#endif
		case 's':
			memsave(&u.u_shell, optarg, strlen(optarg));
			u.u_flags |= F_SHELL;
			break;
		case 'u':
			if (!is_number(optarg)) {
				errx(EXIT_FAILURE, "When using [-u uid], the uid must be numeric");
			}
			u.u_uid = atoi(optarg);
			u.u_flags |= F_UID;
			break;
#ifdef EXTENSIONS
		case 'v':
			verbose = 1;
			break;
#endif
		default:
			usermgmt_usage("usermod");
			/* NOTREACHED */
		}
	}
	if ((u.u_flags & F_MKDIR) && !(u.u_flags & F_HOMEDIR) &&
	    !(u.u_flags & F_USERNAME)) {
		warnx("option 'm' useless without 'd' or 'l' -- ignored");
		u.u_flags &= ~F_MKDIR;
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("usermod");
	}
	checkeuid();
	openlog("usermod", LOG_PID, LOG_USER);
	return moduser(*argv, (have_new_user) ? newuser : *argv, &u) ?
	    EXIT_SUCCESS : EXIT_FAILURE;
}

#ifdef EXTENSIONS
#define DEL_OPT_EXTENSIONS	"Dp:v"
#else
#define DEL_OPT_EXTENSIONS
#endif

int
userdel(int argc, char **argv)
{
	struct passwd	*pwp;
	user_t		u;
	char		password[PasswordLength + 1];
	int		defaultfield;
	int		rmhome;
	int		bigD;
	int		c;

	(void) memset(&u, 0, sizeof(u));
	read_defaults(&u);
	defaultfield = bigD = rmhome = 0;
	while ((c = getopt(argc, argv, "r" DEL_OPT_EXTENSIONS)) != -1) {
		switch(c) {
#ifdef EXTENSIONS
		case 'D':
			bigD = 1;
			break;
#endif
#ifdef EXTENSIONS
		case 'p':
			defaultfield = 1;
			u.u_preserve = (strcmp(optarg, "true") == 0) ? 1 :
					(strcmp(optarg, "yes") == 0) ? 1 :
					 atoi(optarg);
			break;
#endif
		case 'r':
			rmhome = 1;
			break;
#ifdef EXTENSIONS
		case 'v':
			verbose = 1;
			break;
#endif
		default:
			usermgmt_usage("userdel");
			/* NOTREACHED */
		}
	}
#ifdef EXTENSIONS
	if (bigD) {
		if (defaultfield) {
			checkeuid();
			return setdefaults(&u) ? EXIT_SUCCESS : EXIT_FAILURE;
		}
		(void) printf("preserve\t%s\n", (u.u_preserve) ? "true" : "false");
		return EXIT_SUCCESS;
	}
#endif
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("userdel");
	}
	checkeuid();
	if ((pwp = getpwnam(*argv)) == NULL) {
		warnx("No such user `%s'", *argv);
		return EXIT_FAILURE;
	}
	if (rmhome)
		(void)removehomedir(pwp->pw_name, pwp->pw_uid, pwp->pw_dir);
	if (u.u_preserve) {
		u.u_flags |= F_SHELL;
		memsave(&u.u_shell, NOLOGIN, strlen(NOLOGIN));
		(void) memset(password, '*', DES_Len);
		password[DES_Len] = 0;
		memsave(&u.u_password, password, strlen(password));
		u.u_flags |= F_PASSWORD;
		openlog("userdel", LOG_PID, LOG_USER);
		return moduser(*argv, *argv, &u) ? EXIT_SUCCESS : EXIT_FAILURE;
	}
	if (!rm_user_from_groups(*argv)) {
		return 0;
	}
	openlog("userdel", LOG_PID, LOG_USER);
	return moduser(*argv, *argv, NULL) ? EXIT_SUCCESS : EXIT_FAILURE;
}

#ifdef EXTENSIONS
#define GROUP_ADD_OPT_EXTENSIONS	"v"
#else
#define GROUP_ADD_OPT_EXTENSIONS
#endif

/* add a group */
int
groupadd(int argc, char **argv)
{
	int	dupgid;
	int	gid;
	int	c;

	gid = GID_MAX;
	dupgid = 0;
	while ((c = getopt(argc, argv, "g:o" GROUP_ADD_OPT_EXTENSIONS)) != -1) {
		switch(c) {
		case 'g':
			if (!is_number(optarg)) {
				errx(EXIT_FAILURE, "When using [-g gid], the gid must be numeric");
			}
			gid = atoi(optarg);
			break;
		case 'o':
			dupgid = 1;
			break;
#ifdef EXTENSIONS
		case 'v':
			verbose = 1;
			break;
#endif
		default:
			usermgmt_usage("groupadd");
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("groupadd");
	}
	checkeuid();
	if (!valid_group(*argv)) {
		errx(EXIT_FAILURE, "invalid group name `%s'", *argv);
	}
	if (gid < 0 && !getnextgid(&gid, LowGid, HighGid)) {
		errx(EXIT_FAILURE, "can't add group: can't get next gid");
	}
	if (!dupgid && getgrgid((gid_t) gid) != NULL) {
		errx(EXIT_FAILURE, "can't add group: gid %d is a duplicate", gid);
	}
	openlog("groupadd", LOG_PID, LOG_USER);
	if (!creategid(*argv, gid, "")) {
		errx(EXIT_FAILURE, "can't add group: problems with %s file",
		    _PATH_GROUP);
	}
	return EXIT_SUCCESS;
}

#ifdef EXTENSIONS
#define GROUP_DEL_OPT_EXTENSIONS	"v"
#else
#define GROUP_DEL_OPT_EXTENSIONS
#endif

/* remove a group */
int
groupdel(int argc, char **argv)
{
	int	c;

	while ((c = getopt(argc, argv, "" GROUP_DEL_OPT_EXTENSIONS)) != -1) {
		switch(c) {
#ifdef EXTENSIONS
		case 'v':
			verbose = 1;
			break;
#endif
		default:
			usermgmt_usage("groupdel");
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("groupdel");
	}
	checkeuid();
	openlog("groupdel", LOG_PID, LOG_USER);
	if (getgrnam(*argv) == NULL) {
		warnx("No such group: `%s'", *argv);
		return EXIT_FAILURE;
	}
	if (!modify_gid(*argv, NULL)) {
		err(EXIT_FAILURE, "can't change %s file", _PATH_GROUP);
	}
	return EXIT_SUCCESS;
}

#ifdef EXTENSIONS
#define GROUP_MOD_OPT_EXTENSIONS	"v"
#else
#define GROUP_MOD_OPT_EXTENSIONS
#endif

/* modify a group */
int
groupmod(int argc, char **argv)
{
	struct group	*grp;
	char		buf[LINE_MAX];
	char		*newname;
	char		**cpp;
	int		dupgid;
	int		gid;
	int		cc;
	int		c;

	gid = GID_MAX;
	dupgid = 0;
	newname = NULL;
	while ((c = getopt(argc, argv, "g:on:" GROUP_MOD_OPT_EXTENSIONS)) != -1) {
		switch(c) {
		case 'g':
			if (!is_number(optarg)) {
				errx(EXIT_FAILURE, "When using [-g gid], the gid must be numeric");
			}
			gid = atoi(optarg);
			break;
		case 'o':
			dupgid = 1;
			break;
		case 'n':
			memsave(&newname, optarg, strlen(optarg));
			break;
#ifdef EXTENSIONS
		case 'v':
			verbose = 1;
			break;
#endif
		default:
			usermgmt_usage("groupmod");
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("groupmod");
	}
	checkeuid();
	if (gid < 0 && newname == NULL) {
		errx(EXIT_FAILURE, "Nothing to change");
	}
	if (dupgid && gid < 0) {
		errx(EXIT_FAILURE, "Duplicate which gid?");
	}
	if (!is_local(*argv, _PATH_GROUP)) {
		errx(EXIT_FAILURE, "Group `%s' must be a local group", *argv);
	}
	if ((grp = getgrnam(*argv)) == NULL) {
		errx(EXIT_FAILURE, "can't find group `%s' to modify", *argv);
	}
	if (newname != NULL && !valid_group(newname)) {
		errx(EXIT_FAILURE, "invalid group name `%s'", newname);
	}
	if ((cc = snprintf(buf, sizeof(buf), "%s:%s:%u:",
	    (newname) ? newname : grp->gr_name, grp->gr_passwd,
	    (gid < 0) ? grp->gr_gid : gid)) >= sizeof(buf) || cc < 0)
		errx(EXIT_FAILURE, "group `%s' entry too long", grp->gr_name);

	for (cpp = grp->gr_mem ; *cpp ; cpp++) {
		cc = strlcat(buf, *cpp, sizeof(buf)) + 1;
		if (cc >= sizeof(buf))
			errx(EXIT_FAILURE, "group `%s' entry too long",
			    grp->gr_name);
		if (cpp[1] != NULL) {
			buf[cc - 1] = ',';
			buf[cc] = '\0';
		}
	}
	cc = strlcat(buf, "\n", sizeof(buf));
	if (cc >= sizeof(buf))
		errx(EXIT_FAILURE, "group `%s' entry too long", grp->gr_name);

	openlog("groupmod", LOG_PID, LOG_USER);
	if (!modify_gid(*argv, buf))
		err(EXIT_FAILURE, "can't change %s file", _PATH_GROUP);
	return EXIT_SUCCESS;
}

#ifdef EXTENSIONS
/* display user information */
int
userinfo(int argc, char **argv)
{
	struct passwd	*pwp;
	struct group	*grp;
	char		**cpp;
	int		exists;
	int		i;

	exists = 0;
	while ((i = getopt(argc, argv, "ev")) != -1) {
		switch(i) {
		case 'e':
			exists = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usermgmt_usage("userinfo");
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("userinfo");
	}
	pwp = find_user_info(*argv);
	if (exists) {
		exit((pwp) ? EXIT_SUCCESS : EXIT_FAILURE);
	}
	if (pwp == NULL) {
		errx(EXIT_FAILURE, "can't find user `%s'", *argv);
	}
	(void) printf("login\t%s\n", pwp->pw_name);
	(void) printf("passwd\t%s\n", pwp->pw_passwd);
	(void) printf("uid\t%u\n", pwp->pw_uid);
	if ((grp = getgrgid(pwp->pw_gid)) == NULL)
		(void) printf("groups\t%u", pwp->pw_gid);
	else
		(void) printf("groups\t%s", grp->gr_name);
	while ((grp = getgrent()) != NULL) {
		for (cpp = grp->gr_mem ; *cpp ; cpp++) {
			if (strcmp(*cpp, *argv) == 0 && grp->gr_gid != pwp->pw_gid)
				(void) printf(" %s", grp->gr_name);
		}
	}
	(void) fputc('\n', stdout);
	(void) printf("change\t%s", pwp->pw_change ? ctime(&pwp->pw_change) : "NEVER\n");
#ifdef EXTENSIONS
	(void) printf("class\t%s\n", pwp->pw_class);
#endif
	(void) printf("gecos\t%s\n", pwp->pw_gecos);
	(void) printf("dir\t%s\n", pwp->pw_dir);
	(void) printf("shell\t%s\n", pwp->pw_shell);
	(void) printf("expire\t%s", pwp->pw_expire ? ctime(&pwp->pw_expire) : "NEVER\n");
	return EXIT_SUCCESS;
}
#endif

#ifdef EXTENSIONS
/* display user information */
int
groupinfo(int argc, char **argv)
{
	struct group	*grp;
	char		**cpp;
	int		exists;
	int		i;

	exists = 0;
	while ((i = getopt(argc, argv, "ev")) != -1) {
		switch(i) {
		case 'e':
			exists = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usermgmt_usage("groupinfo");
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("groupinfo");
	}
	grp = find_group_info(*argv);
	if (exists) {
		exit((grp) ? EXIT_SUCCESS : EXIT_FAILURE);
	}
	if (grp == NULL) {
		errx(EXIT_FAILURE, "can't find group `%s'", *argv);
	}
	(void) printf("name\t%s\n", grp->gr_name);
	(void) printf("passwd\t%s\n", grp->gr_passwd);
	(void) printf("gid\t%u\n", grp->gr_gid);
	(void) printf("members\t");
	for (cpp = grp->gr_mem ; *cpp ; cpp++) {
		(void) printf("%s ", *cpp);
	}
	(void) fputc('\n', stdout);
	return EXIT_SUCCESS;
}
#endif
@


1.6
log
@the first part of making a release (non-X)
* sync sets (for now)
* mention set sizes in INSTALL.i386
* install all files, but not more than wanted
* fix build time warnings
  (the mktemp in lpd is said to be safe)
* update docs a bit
* the eqn -> neqn move
* improved man page generation
* anoncvsbin removes tmp before making new symlink
* sendmail generated files are now in sendmail, and
  SKIPDIRS is checked before (asked for by Waldemar Brodkorb)
* more SKIPDIR checks, mostly for GNU stuff
@
text
@d1 2
a2 2
/* $MirBSD$ */
/* $OpenBSD: user.c,v 1.55 2004/01/03 18:30:39 millert Exp $ */
d324 1
a324 1
	char		buf[LINE_MAX];
d326 3
a328 2
	int		fd;
	int		cc;
d356 8
a363 2
	while ((cc = fread(buf, sizeof(char), sizeof(buf), from)) > 0) {
		if (fwrite(buf, cc, 1, to) != 1) {
d371 3
a373 1
	(void) fprintf(to, "%s:*:%u:%s\n", group, gid, name);
d375 5
a379 1
	(void) fclose(to);
d460 5
a464 1
	(void) fclose(to);
d570 5
a574 1
	(void) fclose(to);
d725 4
a728 1
	(void) fclose(fp);
d1056 2
a1057 1
	if (lstat(home, &st) < 0 && !(up->u_flags & F_MKDIR)) {
d1140 1
a1140 2
	regmatch_t	matchv[10];
	regex_t		r;
a1142 1
	char		line[LINE_MAX];
d1145 1
a1147 1
	int		sc;
d1149 1
a1149 5
	(void) snprintf(line, sizeof(line), "(:|,)(%s)(,|$)", login_name);
	if (regcomp(&r, line, REG_EXTENDED|REG_NEWLINE) != 0) {
		warn("can't compile regular expression `%s'", line);
		return 0;
	}
d1151 2
a1152 1
		warn("can't remove gid for `%s': can't open `%s'", login_name, _PATH_GROUP);
d1162 1
a1162 1
		warn("can't create gid: mkstemp failed");
d1169 2
a1170 1
		warn("can't create gid: fdopen `%s' failed", f);
d1182 24
a1205 14
		if (regexec(&r, buf, 10, matchv, 0) == 0) {
			if (buf[(int)matchv[1].rm_so] == ',')
				matchv[2].rm_so = matchv[1].rm_so;
			else if (matchv[2].rm_eo != matchv[3].rm_eo)
				matchv[2].rm_eo = matchv[3].rm_eo;
			cc -= (int) matchv[2].rm_eo;
			sc = (int) matchv[2].rm_so;
			if (fwrite(buf, sc, 1, to) != 1 ||
			    fwrite(&buf[(int)matchv[2].rm_eo], cc, 1, to) != 1) {
				(void) fclose(from);
				(void) close(fd);
				(void) unlink(f);
				warn("can't create gid: short write to `%s'", f);
				return 0;
d1207 2
a1208 1
		} else if (fwrite(buf, cc, 1, to) != 1) {
d1210 1
a1210 1
			(void) close(fd);
d1212 2
a1213 1
			warn("can't create gid: short write to `%s'", f);
d1217 1
d1219 6
a1224 1
	(void) fclose(to);
d1227 2
a1228 1
		warn("can't create gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
a1230 1
	(void) chmod(_PATH_GROUP, st.st_mode & 07777);
@


1.5
log
@merge import
@
text
@d1 3
a3 2
/* $OpenBSD: user.c,v 1.44 2003/06/08 20:50:51 millert Exp $ */
/* $NetBSD: user.c,v 1.45 2001/08/17 08:29:00 joda Exp $ */
d23 1
a23 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS
d44 3
d49 1
d54 1
d73 4
a76 4
	char		*u_password;		/* encrypted password */
	char		*u_comment;		/* comment field */
	char		*u_home;		/* home directory */
	char		*u_primgrp;		/* primary group */
d78 7
a84 7
	char		*u_groupv[NGROUPS_MAX];	/* secondary groups */
	char		*u_shell;		/* user's shell */
	char		*u_basedir;		/* base directory for home */
	char		*u_expire;		/* when password will expire */
	int		u_inactive;		/* inactive */
	char		*u_skeldir;		/* directory for startup files */
	char		*u_class;		/* login class */
d87 1
a87 1
	range_t		*u_rv;			/* the ranges */
d167 2
d182 1
d190 1
a190 1
/* if *cpp is non-null, free it, then assign 'n' chars of 's' to it */
d192 1
a192 1
memsave(char **cpp, char *s, size_t n)
d217 1
a217 1
		warnx("[Warning] can't system '%s'", buf);
d230 1
a230 1
		warnx("Not deleting home directory '%s'; userid is 0", dir);
d236 1
a236 1
		warnx("Home directory '%s' doesn't exist", dir);
d240 1
a240 1
		warnx("Home directory '%s' is not a directory", dir);
d246 1
a246 1
		warnx("User '%s' doesn't own directory '%s', not removed",
d256 1
a256 1
		warnx("Unable to remove all files in '%s'", dir);
d262 1
a262 1
/* return 1 if all of 's' is numeric */
d267 1
a267 1
		if (!isdigit(*s)) {
d295 1
a295 1
		warn("can't open source . files dir '%s'", skeldir);
d309 1
a309 1
		(void) asystem("cd %s && %s -rw -pe %s . %s", 
d317 1
a317 1
/* create a group entry with gid 'gid' */
d319 1
a319 1
creategid(char *group, gid_t gid, char *name)
d330 1
a330 1
		warnx("group '%s' already exists", group);
d334 1
a334 1
		warn("can't create gid for %s: can't open %s", group,
d339 1
a339 1
		warn("can't lock '%s'", _PATH_GROUP);
d352 1
a352 1
		warn("can't create gid: fdopen '%s' failed", f);
d356 1
a356 1
		if (fwrite(buf, cc, 1, to) <= 0) {
d360 1
a360 1
			warn("can't create gid: short write to '%s'", f);
d369 1
a369 1
		warn("can't create gid: can't rename '%s' to '%s'", f,
d374 1
d378 1
a378 1
/* modify the group entry with name 'group' to be newent */
d394 1
a394 1
		warn("can't create gid for %s: can't open %s", group,
d399 1
a399 1
		warn("can't lock '%s'", _PATH_GROUP);
d405 1
a405 1
		warn("can't create gid: mkstemp failed");
d412 1
a412 1
		warn("can't create gid: fdopen '%s' failed", f);
d418 2
a419 2
		if (buf[cc - 1] != '\n') {
			while (!feof(from) && fgetc(from) != '\n')
d421 2
a422 2
			warn("line '%s' too long (%d bytes), skipping", buf,
			    cc);
d426 1
a426 1
			warn("badly formed entry '%s'", buf);
d438 1
a438 1
		if (fwrite(buf, cc, 1, to) <= 0) {
d442 1
a442 1
			warn("can't create gid: short write to '%s'", f);
d450 1
a450 1
		warn("can't create gid: can't rename '%s' to '%s'", f, _PATH_GROUP);
d454 5
d462 1
a462 1
/* modify the group entries for all 'groups', by adding 'user' */
d464 1
a464 1
append_group(char *user, int ngroups, char **groups)
d480 1
a480 1
			warnx("can't append group '%s' for user '%s'",
d492 1
a492 1
		warn("can't append group for %s: can't open %s", user,
d497 1
a497 1
		warn("can't lock '%s'", _PATH_GROUP);
d503 1
a503 1
		warn("can't create gid: mkstemp failed");
d510 1
a510 1
		warn("can't create gid: fdopen '%s' failed", f);
d515 2
a516 2
		if (buf[cc - 1] != '\n') {
			while (!feof(from) && fgetc(from) != '\n')
d518 2
a519 2
			warn("line '%s' too long (%d bytes), skipping", buf,
			    cc);
d523 1
a523 1
			warnx("badly formed entry '%s'", buf);
d535 1
a535 1
					warnx("Warning: group '%s' would "
d544 1
a544 1
		if (fwrite(buf, cc, 1, to) <= 0) {
d548 1
a548 1
			warn("can't create gid: short write to '%s'", f);
d556 1
a556 1
		warn("can't create gid: can't rename '%s' to '%s'", f, _PATH_GROUP);
d563 1
a563 1
/* return 1 if 'login' is a valid login name */
d565 1
a565 1
valid_login(char *login)
d567 1
a567 1
	char	*cp;
d570 1
a570 1
	if (*login == '-')
d573 1
a573 1
	for (cp = login ; *cp ; cp++) {
d580 1
a580 1
	if (cp - login > MaxUserNameLen)
d585 1
a585 1
/* return 1 if 'group' is a valid group name */
d589 1
a589 1
	char	*cp;
d596 1
a596 1
	if (cp - group > MaxUserNameLen)
d601 13
d654 1
a654 1
		warnx("Bad range '%s'", cp);
d675 1
a675 1
		warnx("can't mkstemp '%s' for writing", CONFFILE);
d679 1
a679 1
		warn("can't fdopen '%s' for writing", CONFFILE);
d690 1
a690 1
	    fprintf(fp, "inactive\t%d\n", up->u_inactive) <= 0 ||
d693 1
a693 1
		warn("can't write to '%s'", CONFFILE);
d699 1
a699 1
			warn("can't write to '%s'", CONFFILE);
d719 2
a720 2
	char		*cp;
	char		*s;
d737 1
a737 1
			warn("can't create '%s' defaults file", CONFFILE);
d772 8
a779 1
				up->u_inactive = atoi(cp);
d836 76
d914 1
a914 1
adduser(char *login, user_t *up)
a917 1
	struct tm	tm;
d919 1
d930 2
a931 2
	if (!valid_login(login)) {
		errx(EXIT_FAILURE, "'%s' is not a valid login name", login);
d933 5
d939 1
a939 1
		err(EXIT_FAILURE, "can't open '%s'", _PATH_MASTERPASSWD);
d942 1
a942 1
		err(EXIT_FAILURE, "can't lock '%s'", _PATH_MASTERPASSWD);
d966 1
a966 1
		for (i = up->u_defrc; got_id == 0 && i < up->u_rc ; i++) { 
d976 1
a976 1
			for (i = 0; got_id == 0 && i < up->u_defrc; i++) { 
d1012 1
a1012 1
	if (!(up->u_flags & F_DUPUID) && getpwnam(login) != NULL) {
d1015 1
a1015 1
		errx(EXIT_FAILURE, "already a '%s' user", login);
d1021 2
a1022 1
		(void) snprintf(home, sizeof(home), "%s/%s", up->u_basedir, login);
d1024 7
a1030 8
	expire = 0;
	if (up->u_expire != NULL) {
		(void) memset(&tm, 0, sizeof(tm));
		if (strptime(up->u_expire, "%c", &tm) == NULL) {
			warnx("invalid time format '%s'", optarg);
		} else {
			expire = mktime(&tm);
		}
d1033 1
a1033 1
		warnx("Warning: home directory '%s' doesn't exist, and -m was"
d1036 1
a1036 2
	if (up->u_password != NULL &&
	    strlen(up->u_password) <= PasswordLength) {
d1039 2
a1040 1
		(void) strlcpy(password, "*", sizeof(password));
d1042 1
a1042 1
			warnx("Password '%s' is invalid: setting it to '%s'",
d1046 2
a1047 3

	if ((cc = snprintf(buf, sizeof(buf), "%s:%s:%u:%u:%s:%d:%ld:%s:%s:%s\n",
	    login,
d1056 1
a1056 1
	    up->u_inactive,
d1060 3
a1062 3
	    up->u_shell)) >= sizeof(buf) || cc < 0 ||
	    (strchr(up->u_comment, '&') != NULL &&
	    cc + strlen(login) >= sizeof(buf))) {
d1065 1
a1065 1
		errx(EXIT_FAILURE, "can't add '%s', line too long", buf);
d1070 1
a1070 1
		err(EXIT_FAILURE, "can't add '%s'", buf);
d1076 1
a1076 1
			errx(EXIT_FAILURE, "home directory '%s' already exists",
d1082 1
a1082 1
				err(EXIT_FAILURE, "can't mkdir '%s'", home);
d1087 3
a1089 2
	if (strcmp(up->u_primgrp, "=uid") == 0 && getgrnam(login) == NULL &&
	    !creategid(login, gid, login)) {
d1093 1
a1093 1
		    gid, login);
d1095 1
a1095 1
	if (up->u_groupc > 0 && !append_group(login, up->u_groupc, up->u_groupv)) {
d1098 1
a1098 1
		errx(EXIT_FAILURE, "can't append '%s' to new groups", login);
d1101 1
a1101 1
	if (pw_mkdb(login, 0) < 0) {
d1105 2
d1110 122
d1234 1
a1234 1
moduser(char *login, char *newlogin, user_t *up)
a1237 1
	struct tm	tm;
d1240 1
a1240 1
	size_t		colonc, len, loginc;
d1244 2
a1245 1
	char		*colon, *line;
d1251 4
a1254 1
		errx(EXIT_FAILURE, "'%s' is not a valid login name", login);
d1256 2
a1257 2
	if ((pwp = getpwnam(login)) == NULL) {
		errx(EXIT_FAILURE, "No such user '%s'", login);
d1263 1
a1263 1
		err(EXIT_FAILURE, "can't open '%s'", _PATH_MASTERPASSWD);
d1266 1
a1266 1
		err(EXIT_FAILURE, "can't lock '%s'", _PATH_MASTERPASSWD);
d1282 1
a1282 1
			if (strcmp(login, newlogin) != 0 && getpwnam(newlogin) != NULL) {
d1285 1
a1285 1
				errx(EXIT_FAILURE, "already a '%s' user", newlogin);
d1300 7
a1306 1
			if (up->u_password != NULL && strlen(up->u_password) <= PasswordLength)
d1308 1
d1339 6
a1344 2
		if (up->u_flags |= F_INACTIVE)
			pwp->pw_change = up->u_inactive;
d1346 4
a1349 5
			(void) memset(&tm, 0, sizeof(tm));
			if (strptime(up->u_expire, "%c", &tm) == NULL)
				warnx("invalid time format '%s'", optarg);
			else
				pwp->pw_expire = mktime(&tm);
d1358 7
a1364 1
		if (up->u_flags & F_CLASS)
d1366 1
d1369 4
a1372 4
	loginc = strlen(login);
	while ((line = fgetln(master, &len)) != NULL) {
		if ((colon = strchr(line, ':')) == NULL) {
			warnx("Malformed entry '%s'. Skipping", line);
d1375 2
a1376 2
		colonc = (size_t)(colon - line);
		if (strncmp(login, line, loginc) == 0 && loginc == colonc) {
d1394 2
a1395 2
				    (strchr(up->u_comment, '&') != NULL &&
				    len + strlen(newlogin) >= sizeof(buf))) {
d1398 4
a1401 3
					errx(EXIT_FAILURE, "can't add '%s',"
					    " line too long (%d bytes)", buf,
					    len + strlen(newlogin));
d1406 1
a1406 1
					err(EXIT_FAILURE, "can't add '%s'", buf);
d1409 9
a1417 6
		} else if ((cc = write(ptmpfd, line, len)) != len) {
			(void) close(masterfd);
			(void) close(ptmpfd);
			pw_abort();
			err(EXIT_FAILURE, "short write to /etc/ptmp (%lld not %lld chars)",
			    (long long)cc, (long long)len);
d1425 1
a1425 1
			err(EXIT_FAILURE, "can't move '%s' to '%s'",
d1432 1
a1432 1
			errx(EXIT_FAILURE, "can't append '%s' to new groups",
d1437 2
a1438 2
	if (up != NULL && strcmp(login, newlogin) == 0)
		rval = pw_mkdb(login, 0);
d1445 9
a1453 1

d1548 1
a1548 1
#define ADD_OPT_EXTENSIONS	
d1599 1
a1599 1
			u.u_inactive = atoi(optarg);
d1647 3
d1664 1
a1664 1
		(void) printf("inactive\t%d\n", u.u_inactive);
d1679 1
d1686 1
a1686 1
#define MOD_OPT_EXTENSIONS	
d1729 1
a1729 1
			u.u_inactive = atoi(optarg);
d1775 3
d1791 1
d1799 1
a1799 1
#define DEL_OPT_EXTENSIONS	
d1839 3
d1861 1
a1861 1
		warnx("No such user '%s'", *argv);
d1869 3
a1871 2
		(void) strlcpy(password, "*", sizeof(password));
		memsave(&u.u_password, password, PasswordLength);
d1873 1
d1876 4
d1886 1
a1886 1
#define GROUP_ADD_OPT_EXTENSIONS	
d1915 3
d1935 1
d1946 1
a1946 1
#define GROUP_DEL_OPT_EXTENSIONS	
d1962 3
d1973 1
d1975 1
a1975 1
		warnx("No such group: '%s'", *argv);
d1987 1
a1987 1
#define GROUP_MOD_OPT_EXTENSIONS	
d2025 3
d2042 3
d2046 1
a2046 1
		errx(EXIT_FAILURE, "can't find group '%s' to modify", *argv);
d2054 1
a2054 1
		errx(EXIT_FAILURE, "group '%s' entry too long", grp->gr_name);
d2059 1
a2059 1
			errx(EXIT_FAILURE, "group '%s' entry too long",
d2068 1
a2068 1
		errx(EXIT_FAILURE, "group '%s' entry too long", grp->gr_name);
d2070 1
d2096 3
d2111 1
a2111 1
		errx(EXIT_FAILURE, "can't find user '%s'", *argv);
d2158 3
d2173 1
a2173 1
		errx(EXIT_FAILURE, "can't find group '%s'", *argv);
@


1.4
log
@merge CVS import stuff
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.42 2003/05/13 01:12:31 millert Exp $ */
d157 1
a157 1
	MaxUserNameLen = MAXLOGNAME,
d581 2
d1634 3
a1642 3
	if (!valid_group(*argv)) {
		warnx("warning - invalid group name '%s'", *argv);
	}
d1746 1
a1746 1
		warnx("warning - invalid group name '%s'", newname);
@


1.3
log
@clean up the cvs import mess

nb, this doesnt mean the tree builds.
its bed time
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.41 2003/04/03 16:03:06 millert Exp $ */
d553 4
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 1
a1 2
/*	$MirBSD: obsd.diff,v 1.32 2003/03/22 22:33:24 tg Exp $	*/
/* $OpenBSD: user.c,v 1.40 2002/12/10 20:49:28 millert Exp $ */
d22 1
a22 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
d181 1
a181 1
/* if *cpp is non-null, free it, then assign `n' chars of `s' to it */
d208 1
a208 1
		warnx("[Warning] can't system `%s'", buf);
d221 1
a221 1
		warnx("Not deleting home directory `%s'; userid is 0", dir);
d227 1
a227 1
		warnx("Home directory `%s' doesn't exist", dir);
d231 1
a231 1
		warnx("Home directory `%s' is not a directory", dir);
d237 1
a237 1
		warnx("User `%s' doesn't own directory `%s', not removed",
d247 1
a247 1
		warnx("Unable to remove all files in `%s'", dir);
d253 1
a253 1
/* return 1 if all of `s' is numeric */
d286 1
a286 1
		warn("can't open source . files dir `%s'", skeldir);
d308 1
a308 1
/* create a group entry with gid `gid' */
d321 1
a321 1
		warnx("group `%s' already exists", group);
d330 1
a330 1
		warn("can't lock `%s'", _PATH_GROUP);
d343 1
a343 1
		warn("can't create gid: fdopen `%s' failed", f);
d351 1
a351 1
			warn("can't create gid: short write to `%s'", f);
d360 1
a360 1
		warn("can't create gid: can't rename `%s' to `%s'", f,
d368 1
a368 1
/* modify the group entry with name `group' to be newent */
d389 1
a389 1
		warn("can't lock `%s'", _PATH_GROUP);
d402 1
a402 1
		warn("can't create gid: fdopen `%s' failed", f);
d411 1
a411 1
			warn("line `%s' too long (%d bytes), skipping", buf,
d416 1
a416 1
			warn("badly formed entry `%s'", buf);
d432 1
a432 1
			warn("can't create gid: short write to `%s'", f);
d440 1
a440 1
		warn("can't create gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
d447 1
a447 1
/* modify the group entries for all `groups', by adding `user' */
d465 1
a465 1
			warnx("can't append group `%s' for user `%s'",
d482 1
a482 1
		warn("can't lock `%s'", _PATH_GROUP);
d495 1
a495 1
		warn("can't create gid: fdopen `%s' failed", f);
d503 1
a503 1
			warn("line `%s' too long (%d bytes), skipping", buf,
d508 1
a508 1
			warnx("badly formed entry `%s'", buf);
d516 1
a516 1
				if (*(colon + 1) != '\0')
d520 1
a520 1
					warnx("Warning: group `%s' would "
d533 1
a533 1
			warn("can't create gid: short write to `%s'", f);
d541 1
a541 1
		warn("can't create gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
d548 1
a548 1
/* return 1 if `login' is a valid login name */
d566 1
a566 1
/* return 1 if `group' is a valid group name */
d620 1
a620 1
		warnx("Bad range `%s'", cp);
d641 1
a641 1
		warnx("can't mkstemp `%s' for writing", CONFFILE);
d645 1
a645 1
		warn("can't fdopen `%s' for writing", CONFFILE);
d659 1
a659 1
		warn("can't write to `%s'", CONFFILE);
d665 1
a665 1
			warn("can't write to `%s'", CONFFILE);
d703 1
a703 1
			warn("can't create `%s' defaults file", CONFFILE);
d814 1
a814 1
		errx(EXIT_FAILURE, "`%s' is not a valid login name", login);
d817 1
a817 1
		err(EXIT_FAILURE, "can't open `%s'", _PATH_MASTERPASSWD);
d820 1
a820 1
		err(EXIT_FAILURE, "can't lock `%s'", _PATH_MASTERPASSWD);
d893 1
a893 1
		errx(EXIT_FAILURE, "already a `%s' user", login);
d905 1
a905 1
			warnx("invalid time format `%s'", optarg);
d911 1
a911 1
		warnx("Warning: home directory `%s' doesn't exist, and -m was"
d920 1
a920 1
			warnx("Password `%s' is invalid: setting it to `%s'",
d944 1
a944 1
		errx(EXIT_FAILURE, "can't add `%s', line too long", buf);
d949 1
a949 1
		err(EXIT_FAILURE, "can't add `%s'", buf);
d955 1
a955 1
			errx(EXIT_FAILURE, "home directory `%s' already exists",
d961 1
a961 1
				err(EXIT_FAILURE, "can't mkdir `%s'", home);
d976 1
a976 1
		errx(EXIT_FAILURE, "can't append `%s' to new groups", login);
d1005 1
a1005 1
		errx(EXIT_FAILURE, "`%s' is not a valid login name", login);
d1008 1
a1008 1
		errx(EXIT_FAILURE, "No such user `%s'", login);
d1014 1
a1014 1
		err(EXIT_FAILURE, "can't open `%s'", _PATH_MASTERPASSWD);
d1017 1
a1017 1
		err(EXIT_FAILURE, "can't lock `%s'", _PATH_MASTERPASSWD);
d1036 1
a1036 1
				errx(EXIT_FAILURE, "already a `%s' user", newlogin);
d1088 1
a1088 1
				warnx("invalid time format `%s'", optarg);
d1106 1
a1106 1
			warnx("Malformed entry `%s'. Skipping", line);
d1132 2
a1133 2
					errx(EXIT_FAILURE, "can't add `%s', "
					    "line too long (%d bytes)", buf,
d1139 1
a1139 1
					err(EXIT_FAILURE, "can't add `%s'", buf);
d1155 1
a1155 1
			err(EXIT_FAILURE, "can't move `%s' to `%s'",
d1162 1
a1162 1
			errx(EXIT_FAILURE, "can't append `%s' to new groups",
d1572 1
a1572 1
		warnx("No such user `%s'", *argv);
d1635 1
a1635 1
		warnx("warning - invalid group name `%s'", *argv);
d1672 1
a1672 1
		warnx("No such group: `%s'", *argv);
d1737 1
a1737 1
		errx(EXIT_FAILURE, "can't find group `%s' to modify", *argv);
d1740 1
a1740 1
		warnx("warning - invalid group name `%s'", newname);
d1745 1
a1745 1
		errx(EXIT_FAILURE, "group `%s' entry too long", grp->gr_name);
d1750 1
a1750 1
			errx(EXIT_FAILURE, "group `%s' entry too long",
d1759 1
a1759 1
		errx(EXIT_FAILURE, "group `%s' entry too long", grp->gr_name);
d1798 1
a1798 1
		errx(EXIT_FAILURE, "can't find user `%s'", *argv);
d1857 1
a1857 1
		errx(EXIT_FAILURE, "can't find group `%s'", *argv);
@


1.1
log
@Initial revision
@
text
@d1 1
d1133 2
a1134 2
					errx(EXIT_FAILURE, "can't add `%s',
					    line too long (%d bytes)", buf,
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.41 2003/04/03 16:03:06 millert Exp $ */
d516 1
a516 1
				if (buf[strlen(buf) - 1] != ':')
@


1.1.1.3
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.42 2003/05/13 01:12:31 millert Exp $ */
a552 4

	/* The first character cannot be a hyphen */
	if (*login == '-')
		return 0;
@


1.1.1.4
log
@Import OpenBSD CVS of roughly 2000-2200 UTC. Last import before release.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.44 2003/06/08 20:50:51 millert Exp $ */
d157 1
a157 1
	MaxUserNameLen = _PW_NAME_LEN,
a580 2
	if (cp - group > MaxUserNameLen)
		return 0;
a1631 3
	if (!valid_group(*argv)) {
		errx(EXIT_FAILURE, "invalid group name `%s'", *argv);
	}
d1638 3
d1744 1
a1744 1
		errx(EXIT_FAILURE, "invalid group name `%s'", newname);
@


1.1.1.5
log
@-current: work in progress...
@
text
@d1 2
a2 2
/* $OpenBSD: user.c,v 1.45 2003/06/08 23:04:36 millert Exp $ */
/* $NetBSD: user.c,v 1.52 2002/06/01 06:28:06 grant Exp $ */
d76 1
a76 1
	char		*u_inactive;		/* when account will expire */
a173 1
#define UNSET_INACTIVE	"Null (unset)"
d325 1
a325 1
		warn("can't create gid for `%s': can't open `%s'", group,
d384 1
a384 1
		warn("can't create gid for `%s': can't open `%s'", group,
d477 1
a477 1
		warn("can't append group for `%s': can't open `%s'", user,
d662 1
a662 1
	    fprintf(fp, "inactive\t%s\n", (up->u_inactive == NULL) ? UNSET_INACTIVE : up->u_inactive) <= 0 ||
d744 1
a744 8
				if (strcmp(cp, UNSET_INACTIVE) == 0) {
					if (up->u_inactive) {
						FREE(up->u_inactive);
					}
					up->u_inactive = NULL;
				} else {
					memsave(&up->u_inactive, cp, strlen(cp));
				}
a808 1
	time_t		inactive;
a906 14
	inactive = 0;
	if (up->u_inactive != NULL) {
		(void) memset(&tm, 0, sizeof(tm));
		if (strptime(up->u_inactive, "%c", &tm) != NULL) {
			inactive = mktime(&tm);
		} else if (strptime(up->u_inactive, "%B %d %Y", &tm) != NULL) {
			inactive = mktime(&tm);
		} else if (isdigit(up->u_inactive[0]) != NULL) {
			inactive = atoi(up->u_inactive);
		} else {
			warnx("Warning: inactive time `%s' invalid, account expiry off",
				up->u_inactive);
		}
	}
d910 3
a912 3
		if (strptime(up->u_expire, "%c", &tm) != NULL) {
			expire = mktime(&tm);
		} else if (strptime(up->u_expire, "%B %d %Y", &tm) != NULL) {
a913 5
		} else if (isdigit(up->u_expire[0]) != NULL) {
			expire = atoi(up->u_expire);
		} else {
			warnx("Warning: expire time `%s' invalid, password expiry off",
				up->u_expire);
d931 1
a931 1
	cc = snprintf(buf, sizeof(buf), "%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n",
d941 1
a941 1
	    (long) inactive,
d945 3
a947 4
	    up->u_shell);
	if (strchr(up->u_comment, '&') != NULL)
		cc += strlen(login);
	if (cc >= sizeof(buf)) {
d1089 2
a1090 13
		if (up->u_flags & F_INACTIVE) {
			(void) memset(&tm, 0, sizeof(tm));
			if (strptime(up->u_inactive, "%c", &tm) != NULL) {
				pwp->pw_change = mktime(&tm);
			} else if (strptime(up->u_inactive, "%B %d %Y", &tm) != NULL) { 
				pwp->pw_change = mktime(&tm);
			} else if (isdigit(up->u_inactive[0]) != NULL) {
				pwp->pw_change = atoi(up->u_inactive);
			} else {
				warnx("Warning: inactive time `%s' invalid, password expiry off",
					up->u_inactive);
			}
		}
d1093 3
a1095 3
			if (strptime(up->u_expire, "%c", &tm) != NULL) {
				pwp->pw_expire = mktime(&tm);
			} else if (strptime(up->u_expire, "%B %d %Y", &tm) != NULL) { 
a1096 6
			} else if (isdigit(up->u_expire[0]) != NULL) {
				pwp->pw_expire = atoi(up->u_expire);
			} else {
				warnx("Warning: expire time `%s' invalid, password expiry off",
					up->u_expire);
			}
d1327 1
a1327 1
			memsave(&u.u_inactive, optarg, strlen(optarg));
d1389 1
a1389 1
		(void) printf("inactive\t%s\n", (u.u_inactive == NULL) ? UNSET_INACTIVE : u.u_inactive);
d1453 1
a1453 1
			memsave(&u.u_inactive, optarg, strlen(optarg));
@


1.1.1.6
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 2
a2 2
/* $OpenBSD: user.c,v 1.52 2003/06/14 22:12:53 millert Exp $ */
/* $NetBSD: user.c,v 1.69 2003/04/14 17:40:07 agc Exp $ */
a42 3
#ifdef EXTENSIONS
#include <login_cap.h>
#endif
a44 1
#include <regex.h>
a48 1
#include <syslog.h>
d67 4
a70 4
	char	       *u_password;		/* encrypted password */
	char	       *u_comment;		/* comment field */
	char	       *u_home;		/* home directory */
	char	       *u_primgrp;		/* primary group */
d72 7
a78 7
	const char     *u_groupv[NGROUPS_MAX];	/* secondary groups */
	char	       *u_shell;		/* user's shell */
	char	       *u_basedir;		/* base directory for home */
	char	       *u_expire;		/* when password will expire */
	char	       *u_inactive;		/* when account will expire */
	char	       *u_skeldir;		/* directory for startup files */
	char	       *u_class;		/* login class */
d81 1
a81 1
	range_t	       *u_rv;			/* the ranges */
a160 2
	DES_Len = 13,

d184 1
a184 1
memsave(char **cpp, const char *s, size_t n)
d259 1
a259 1
		if (!isdigit((unsigned char) *s)) {
d311 1
a311 1
creategid(char *group, gid_t gid, const char *name)
d348 1
a348 1
		if (fwrite(buf, cc, 1, to) != 1) {
a365 1
	syslog(LOG_INFO, "new group added: name=%s, gid=%d", group, gid);
d385 1
a385 1
		warn("can't modify gid for `%s': can't open `%s'", group,
d396 1
a396 1
		warn("can't modify gid: mkstemp failed");
d403 1
a403 1
		warn("can't modify gid: fdopen `%s' failed", f);
d409 2
a410 2
		if (buf[cc - 1] != '\n' && !feof(from)) {
			while (fgetc(from) != '\n' && !feof(from))
d412 2
a413 2
			warn("%s: line `%s' too long (%d bytes), skipping",
			    _PATH_GROUP, buf, cc);
d429 1
a429 1
		if (fwrite(buf, cc, 1, to) != 1) {
d433 1
a433 1
			warn("can't modify gid: short write to `%s'", f);
d441 1
a441 1
		warn("can't modify gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
a444 5
	if (newent == NULL) {
		syslog(LOG_INFO, "group deleted: name=%s", group);
	} else {
		syslog(LOG_INFO, "group information modified: name=%s", group);
	}
d450 1
a450 1
append_group(char *user, int ngroups, const char **groups)
d489 1
a489 1
		warn("can't append group: mkstemp failed");
d496 1
a496 1
		warn("can't append group: fdopen `%s' failed", f);
d501 2
a502 2
		if (buf[cc - 1] != '\n' && !feof(from)) {
			while (fgetc(from) != '\n' && !feof(from))
d504 2
a505 2
			warn("%s: line `%s' too long (%d bytes), skipping",
			    _PATH_GROUP, buf, cc);
d530 1
a530 1
		if (fwrite(buf, cc, 1, to) != 1) {
d534 1
a534 1
			warn("can't append group: short write to `%s'", f);
d542 1
a542 1
		warn("can't append group: can't rename `%s' to `%s'", f, _PATH_GROUP);
d551 1
a551 1
valid_login(char *login_name)
d553 1
a553 1
	unsigned char	*cp;
d556 1
a556 1
	if (*login_name == '-')
d559 1
a559 1
	for (cp = login_name ; *cp ; cp++) {
d566 1
a566 1
	if ((char *)cp - login_name > MaxUserNameLen)
d575 1
a575 1
	unsigned char	*cp;
d582 1
a582 1
	if ((char *)cp - group > MaxUserNameLen)
a586 13
#ifdef EXTENSIONS
/* return 1 if `class' exists */
static int
valid_class(char *class)
{
	login_cap_t *lc;

	if ((lc = login_getclass(class)) != NULL)
		login_close(lc);
	return lc != NULL;
}
#endif

d692 2
a693 2
	unsigned char	*cp;
	unsigned char	*s;
a808 62
/* structure which defines a password type */
typedef struct passwd_type_t {
	const char     *type;		/* optional type descriptor */
	int		desc_length;	/* length of type descriptor */
	int		length;		/* length of password */
	const char     *regex;		/* regexp to output the password */
	int		re_sub;		/* subscript of regexp to use */
} passwd_type_t;

static passwd_type_t	passwd_types[] = {
	{ "$2a",	3,	54,	"\\$[^$]+\\$[^$]+\\$(.*)",	1 },	/* Blowfish */
	{ "$1",		2,	34,	NULL,				0 },	/* MD5 */
	{ "",		0,	DES_Len,NULL,				0 },	/* standard DES */
	{ NULL,		-1,	-1,	NULL,				0 }	/* none - terminate search */
};

/* return non-zero if it's a valid password - check length for cipher type */
static int
valid_password_length(char *newpasswd)
{
	passwd_type_t  *pwtp;
	regmatch_t	matchv[10];
	regex_t		r;

	for (pwtp = passwd_types ; pwtp->desc_length >= 0 ; pwtp++) {
		if (strncmp(newpasswd, pwtp->type, pwtp->desc_length) == 0) {
			if (pwtp->regex == NULL) {
				return strlen(newpasswd) == pwtp->length;
			}
			(void) regcomp(&r, pwtp->regex, REG_EXTENDED);
			if (regexec(&r, newpasswd, 10, matchv, 0) == 0) {
				regfree(&r);
				return (int)(matchv[pwtp->re_sub].rm_eo - matchv[pwtp->re_sub].rm_so + 1) == pwtp->length;
			}
			regfree(&r);
		}
	}
	return 0;
}

/* look for a valid time, return 0 if it was specified but bad */
static int
scantime(time_t *tp, char *s)
{
	struct tm	tm;

	*tp = 0;
	if (s != NULL) {
		(void) memset(&tm, 0, sizeof(tm));
		if (strptime(s, "%c", &tm) != NULL) {
			*tp = mktime(&tm);
		} else if (strptime(s, "%B %d %Y", &tm) != NULL) {
			*tp = mktime(&tm);
		} else if (isdigit((unsigned char) s[0]) != NULL) {
			*tp = atoi(s);
		} else {
			return 0;
		}
	}
	return 1;
}

d811 1
a811 1
adduser(char *login_name, user_t *up)
d815 1
d828 2
a829 6
	if (!valid_login(login_name)) {
		errx(EXIT_FAILURE, "`%s' is not a valid login name", login_name);
	}
#ifdef EXTENSIONS
	if (!valid_class(up->u_class)) {
		errx(EXIT_FAILURE, "No such login class `%s'", up->u_class);
a830 1
#endif
d905 1
a905 1
	if (!(up->u_flags & F_DUPUID) && getpwnam(login_name) != NULL) {
d908 1
a908 1
		errx(EXIT_FAILURE, "already a `%s' user", login_name);
d914 1
a914 2
		(void) snprintf(home, sizeof(home), "%s/%s", up->u_basedir,
		    login_name);
d916 11
a926 2
	if (!scantime(&inactive, up->u_inactive)) {
		warnx("Warning: inactive time `%s' invalid, account expiry off",
d928 1
d930 11
a940 2
	if (!scantime(&expire, up->u_expire)) {
		warnx("Warning: expire time `%s' invalid, password expiry off",
d942 1
d948 2
a949 1
	if (up->u_password != NULL && valid_password_length(up->u_password)) {
d952 1
a952 2
		(void) memset(password, '*', DES_Len);
		password[DES_Len] = 0;
d958 1
d960 1
a960 1
	    login_name,
d975 1
a975 1
		cc += strlen(login_name);
d1001 2
a1002 3
	if (strcmp(up->u_primgrp, "=uid") == 0 &&
	    getgrnam(login_name) == NULL &&
	    !creategid(login_name, gid, login_name)) {
d1006 1
a1006 1
		    gid, login_name);
d1008 1
a1008 1
	if (up->u_groupc > 0 && !append_group(login_name, up->u_groupc, up->u_groupv)) {
d1011 1
a1011 1
		errx(EXIT_FAILURE, "can't append `%s' to new groups", login_name);
d1014 1
a1014 1
	if (pw_mkdb(login_name, 0) < 0) {
a1017 87
	syslog(LOG_INFO, "new user added: name=%s, uid=%d, gid=%d, home=%s, shell=%s",
		login_name, up->u_uid, gid, home, up->u_shell);
	return 1;
}

/* remove a user from the groups file */
static int
rm_user_from_groups(char *login_name)
{
	struct stat	st;
	regmatch_t	matchv[10];
	regex_t		r;
	FILE		*from;
	FILE		*to;
	char		line[LINE_MAX];
	char		buf[LINE_MAX];
	char		f[MaxFileNameLen];
	int		fd;
	int		cc;
	int		sc;

	(void) snprintf(line, sizeof(line), "(:|,)(%s)(,|$)", login_name);
	if (regcomp(&r, line, REG_EXTENDED|REG_NEWLINE) != 0) {
		warn("can't compile regular expression `%s'", line);
		return 0;
	}
	if ((from = fopen(_PATH_GROUP, "r")) == NULL) {
		warn("can't remove gid for `%s': can't open `%s'", login_name, _PATH_GROUP);
		return 0;
	}
	if (flock(fileno(from), LOCK_EX | LOCK_NB) < 0) {
		warn("can't lock `%s'", _PATH_GROUP);
	}
	(void) fstat(fileno(from), &st);
	(void) snprintf(f, sizeof(f), "%s.XXXXXXXX", _PATH_GROUP);
	if ((fd = mkstemp(f)) < 0) {
		(void) fclose(from);
		warn("can't create gid: mkstemp failed");
		return 0;
	}
	if ((to = fdopen(fd, "w")) == NULL) {
		(void) fclose(from);
		(void) close(fd);
		(void) unlink(f);
		warn("can't create gid: fdopen `%s' failed", f);
		return 0;
	}
	while (fgets(buf, sizeof(buf), from) > 0) {
		cc = strlen(buf);
		if (buf[cc - 1] != '\n' && !feof(from)) {
			while (fgetc(from) != '\n' && !feof(from))
				cc++;
			warn("%s: line `%s' too long (%d bytes), skipping",
			    _PATH_GROUP, buf, cc);
			continue;
		}
		if (regexec(&r, buf, 10, matchv, 0) == 0) {
			if (buf[(int)matchv[1].rm_so] == ',')
				matchv[2].rm_so = matchv[1].rm_so;
			else if (matchv[2].rm_eo != matchv[3].rm_eo)
				matchv[2].rm_eo = matchv[3].rm_eo;
			cc -= (int) matchv[2].rm_eo;
			sc = (int) matchv[2].rm_so;
			if (fwrite(buf, sc, 1, to) != 1 ||
			    fwrite(&buf[(int)matchv[2].rm_eo], cc, 1, to) != 1) {
				(void) fclose(from);
				(void) close(fd);
				(void) unlink(f);
				warn("can't create gid: short write to `%s'", f);
				return 0;
			}
		} else if (fwrite(buf, cc, 1, to) != 1) {
			(void) fclose(from);
			(void) close(fd);
			(void) unlink(f);
			warn("can't create gid: short write to `%s'", f);
			return 0;
		}
	}
	(void) fclose(from);
	(void) fclose(to);
	if (rename(f, _PATH_GROUP) < 0) {
		(void) unlink(f);
		warn("can't create gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
		return 0;
	}
	(void) chmod(_PATH_GROUP, st.st_mode & 07777);
a1020 37
/* check that the user or group is local, not from YP/NIS */
static int
is_local(char *name, const char *file)
{
	regmatch_t	matchv[10];
	regex_t		r;
	FILE	       *fp;
	char		buf[LINE_MAX];
	char		re[LINE_MAX];
	int		ret;
	int		cc;

	(void) snprintf(re, sizeof(re), "^%s:", name);
	if (regcomp(&r, re, REG_EXTENDED) != 0) {
		errx(EXIT_FAILURE, "can't compile regular expression `%s'", re);
	}
	if ((fp = fopen(file, "r")) == NULL) {
		err(EXIT_FAILURE, "can't open `%s'", file);
	}
	for (ret = 0 ; fgets(buf, sizeof(buf), fp) != NULL ; ) {
		cc = strlen(buf);
		if (buf[cc - 1] != '\n' && !feof(fp)) {
			while (fgetc(fp) != '\n' && !feof(fp))
				cc++;
			warn("%s: line `%s' too long (%d bytes), skipping",
			    file, buf, cc);
			continue;
		}
		if (regexec(&r, buf, 10, matchv, 0) == 0) {
			ret = 1;
			break;
		}
	}
	(void) fclose(fp);
	return ret;
}

d1023 1
a1023 1
moduser(char *login_name, char *newlogin, user_t *up)
d1027 1
d1040 1
a1040 4
		errx(EXIT_FAILURE, "`%s' is not a valid login name", login_name);
	}
	if ((pwp = getpwnam(login_name)) == NULL) {
		errx(EXIT_FAILURE, "No such user `%s'", login_name);
d1042 2
a1043 2
	if (!is_local(login_name, _PATH_MASTERPASSWD)) {
		errx(EXIT_FAILURE, "User `%s' must be a local user", login_name);
d1068 1
a1068 1
			if (strcmp(login_name, newlogin) != 0 && getpwnam(newlogin) != NULL) {
d1086 1
a1086 7
			if (up->u_password != NULL) {
				if (!valid_password_length(up->u_password)) {
					(void) close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "Invalid password: `%s'",
						up->u_password);
				}
a1087 1
			}
d1119 8
a1126 1
			if (!scantime(&pwp->pw_change, up->u_inactive)) {
d1132 8
a1139 1
			if (!scantime(&pwp->pw_expire, up->u_expire)) {
d1151 1
a1151 7
		if (up->u_flags & F_CLASS) {
			if (!valid_class(up->u_class)) {
				(void) close(ptmpfd);
				pw_abort();
				errx(EXIT_FAILURE,
				    "No such login class `%s'", up->u_class);
			}
a1152 1
		}
d1155 1
a1155 1
	loginc = strlen(login_name);
d1162 1
a1162 1
		if (strncmp(login_name, line, loginc) == 0 && loginc == colonc) {
d1219 2
a1220 2
	if (up != NULL && strcmp(login_name, newlogin) == 0)
		rval = pw_mkdb(login_name, 0);
d1227 1
a1227 9
	if (up == NULL) {
		syslog(LOG_INFO, "user removed: name=%s", login_name);
	} else if (strcmp(login_name, newlogin) == 0) {
		syslog(LOG_INFO, "user information modified: name=%s, uid=%d, gid=%d, home=%s, shell=%s", 
			login_name, pwp->pw_uid, pwp->pw_gid, pwp->pw_dir, pwp->pw_shell);
	} else {
		syslog(LOG_INFO, "user information modified: name=%s, new name=%s, uid=%d, gid=%d, home=%s, shell=%s", 
			login_name, newlogin, pwp->pw_uid, pwp->pw_gid, pwp->pw_dir, pwp->pw_shell);
	}
a1420 3
		default:
			usermgmt_usage("useradd");
			/* NOTREACHED */
a1449 1
	openlog("useradd", LOG_PID, LOG_USER);
a1544 3
		default:
			usermgmt_usage("usermod");
			/* NOTREACHED */
a1557 1
	openlog("usermod", LOG_PID, LOG_USER);
a1604 3
		default:
			usermgmt_usage("userdel");
			/* NOTREACHED */
d1632 2
a1633 3
		(void) memset(password, '*', DES_Len);
		password[DES_Len] = 0;
		memsave(&u.u_password, password, strlen(password));
a1634 1
		openlog("userdel", LOG_PID, LOG_USER);
a1636 4
	if (!rm_user_from_groups(*argv)) {
		return 0;
	}
	openlog("userdel", LOG_PID, LOG_USER);
a1671 3
		default:
			usermgmt_usage("groupadd");
			/* NOTREACHED */
a1688 1
	openlog("groupadd", LOG_PID, LOG_USER);
a1714 3
		default:
			usermgmt_usage("groupdel");
			/* NOTREACHED */
a1722 1
	openlog("groupdel", LOG_PID, LOG_USER);
a1773 3
		default:
			usermgmt_usage("groupmod");
			/* NOTREACHED */
a1787 3
	if (!is_local(*argv, _PATH_GROUP)) {
		errx(EXIT_FAILURE, "Group `%s' must be a local group", *argv);
	}
a1812 1
	openlog("groupmod", LOG_PID, LOG_USER);
a1837 3
		default:
			usermgmt_usage("userinfo");
			/* NOTREACHED */
a1896 3
		default:
			usermgmt_usage("groupinfo");
			/* NOTREACHED */
@


1.1.1.7
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.54 2003/12/25 10:23:57 grange Exp $ */
a896 14
/* compute the extra length '&' expansion consumes */
static size_t
expand_len(const char *p, const char *username)
{
	size_t alen;
	size_t ulen;

	ulen = strlen(username);
	for (alen = 0; *p != '\0'; p++)
		if (*p == '&')
			alen += ulen - 1;
	return alen;
}

d1046 3
a1048 2
	if (cc >= sizeof(buf) || cc < 0 ||
	    cc + expand_len(up->u_comment, login_name) >= 1023) {
d1226 1
a1226 1
	size_t		colonc, loginc;
a1230 1
	int		len;
d1379 2
a1380 2
				    len + expand_len(pwp->pw_gecos, newlogin)
				    >= 1023) {
d1383 3
a1385 4
					errx(EXIT_FAILURE, "can't add `%s', "
					    "line too long (%d bytes)", buf,
					    len + expand_len(pwp->pw_gecos,
					    newlogin));
@


1.1.1.8
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.55 2004/01/03 18:30:39 millert Exp $ */
d1243 1
a1243 1
	char		*colon;
d1369 3
a1371 3
	while (fgets(buf, sizeof(buf), master) != NULL) {
		if ((colon = strchr(buf, ':')) == NULL) {
			warnx("Malformed entry `%s'. Skipping", buf);
d1374 2
a1375 2
		colonc = (size_t)(colon - buf);
		if (strncmp(login_name, buf, loginc) == 0 && loginc == colonc) {
d1408 6
a1413 9
		} else {
			len = strlen(buf);
			if ((cc = write(ptmpfd, buf, len)) != len) {
				(void) close(masterfd);
				(void) close(ptmpfd);
				pw_abort();
				err(EXIT_FAILURE, "short write to /etc/ptmp (%lld not %lld chars)",
				    (long long)cc, (long long)len);
			}
@


1.1.1.9
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.59 2004/05/10 18:41:11 otto Exp $ */
d323 1
a323 1
	char		*buf;
d325 2
a326 3
	int		fd, ret;
	int		wroteit = 0;
	size_t		len;
d354 2
a355 8
	while ((buf = fgetln(from, &len)) != NULL && len > 0) {
		ret = 0;
		if (buf[0] == '+' && wroteit == 0) {
			ret = fprintf(to, "%s:*:%u:%s\n", group, gid, name);
			wroteit = 1;
		}
		if (ret == -1 ||
		    fprintf(to, "%*.*s", (int)len, (int)len, buf) != len) {
d363 1
a363 3
	ret = 0;
	if (wroteit == 0)
		ret = fprintf(to, "%s:*:%u:%s\n", group, gid, name);
d365 1
a365 5
	if (fclose(to) == EOF || ret == -1) {
		(void) unlink(f);
		warn("can't create gid: short write to `%s'", f);
		return 0;
	}
d446 1
a446 5
	if (fclose(to) == EOF) {
		(void) unlink(f);
		warn("can't modify gid: short write to `%s'", f);
		return 0;
	}
d552 1
a552 5
	if (fclose(to) == EOF) {
		(void) unlink(f);
		warn("can't append group: short write to `%s'", f);
		return 0;
	}
d703 1
a703 4
	if (fclose(fp) == EOF) {
		warn("can't write to `%s'", CONFFILE);
		ret = 0;
	}
d1031 1
a1031 2
	if (lstat(home, &st) < 0 && !(up->u_flags & F_MKDIR) &&
	    strcmp(home, _PATH_NONEXISTENT) != 0) {
d1114 2
a1115 1
	size_t		login_len;
d1118 1
a1120 1
	char		*cp, *ep;
d1123 1
d1125 5
a1129 1
	login_len = strlen(login_name);
d1131 1
a1131 2
		warn("can't remove gid for `%s': can't open `%s'",
		    login_name, _PATH_GROUP);
d1141 1
a1141 1
		warn("can't remove gid for `%s': mkstemp failed", login_name);
d1148 1
a1148 2
		warn("can't remove gid for `%s': fdopen `%s' failed",
		    login_name, f);
d1160 14
a1173 24

		/* Break out the group list. */
		for (cp = buf, cc = 0; *cp != '\0' && cc < 3; cp++) {
			if (*cp == ':')
				cc++;
		}
		if (cc != 3) {
			warnx("Malformed entry `%.*s'. Skipping",
			    (int)strlen(buf) - 1, buf);
			continue;
		}
		while ((cp = strstr(cp, login_name)) != NULL) {
			if ((cp[-1] == ':' || cp[-1] == ',') &&
			    (cp[login_len] == ',' || cp[login_len] == '\n')) {
				ep = cp + login_len;
				if (cp[login_len] == ',')
					ep++;
				else if (cp[-1] == ',')
					cp--;
				memmove(cp, ep, strlen(ep) + 1);
			} else {
				if ((cp = strchr(cp, ',')) == NULL)
					break;
				cp++;
d1175 1
a1175 2
		}
		if (fwrite(buf, strlen(buf), 1, to) != 1) {
d1177 1
a1177 1
			(void) fclose(to);
d1179 1
a1179 2
			warn("can't remove gid for `%s': short write to `%s'",
			    login_name, f);
a1182 1
	(void) fchmod(fileno(to), st.st_mode & 07777);
d1184 1
a1184 6
	if (fclose(to) == EOF) {
		(void) unlink(f);
		warn("can't remove gid for `%s': short write to `%s'",
		    login_name, f);
		return 0;
	}
d1187 1
a1187 2
		warn("can't remove gid for `%s': can't rename `%s' to `%s'",
		    login_name, f, _PATH_GROUP);
d1190 1
@


