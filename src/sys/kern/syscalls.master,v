head	1.28;
access;
symbols
	tg-mergetmp-mirosx-1:1.28
	tg-mergefixes-1-branch:1.28.0.4
	tg-mergefixes-1-base:1.28
	MIROS_X:1.28.0.2
	MIROS_X_BASE:1.28
	tg-mergetmp-3:1.28
	MIRBSD_XP_MIRPPC:1.9.0.4
	MIRBSD_XP_SPARC_BASE:1.9
	MIRBSD_XP_SPARC:1.9.0.2
	MIRBSD_7quater:1.1.1.7
	cvs-200405160640:1.1.1.11
	cvs-200401271800:1.1.1.10
	cvs-200401261630:1.1.1.10
	cvs-200401021645:1.1.1.9
	MIRBSD_7_ALPHA:1.1.1.7.0.6
	MIRBSD_7:1.1.1.7.0.4
	cvs-200312222040:1.1.1.8
	MIRBSD_7ter:1.1.1.7
	MIRBSD_7_DEV:1.1.1.7.0.2
	cvs-200310020700:1.1.1.7
	cvs-200309271030:1.1.1.7
	cvs-200309261655:1.1.1.7
	cvs-200309251530:1.1.1.7
	cvs-200308302005:1.1.1.6
	cvs-200308171200:1.1.1.6
	ctm-3496:1.1.1.6
	ctm-3449:1.1.1.6
	ctm-3437:1.1.1.6
	cvs-200307191805:1.1.1.6
	ctm-3425:1.1.1.6
	cvs-200307091500:1.1.1.6
	cvs-200307072125:1.1.1.6
	ctm-3389:1.1.1.6
	cvs-200307021520:1.1.1.6
	cvs-200306291430:1.1.1.5
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.4
	cvs-200306082100:1.1.1.4
	ctm-3316:1.1.1.4
	ctm-3272:1.1.1.4
	ctm-3264:1.1.1.3
	cvs-200305071630:1.1.1.3
	ctm-3255:1.1.1.3
	ctm-3229:1.1.1.2
	MIRBSD_4:1.3
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.28
date	2004.12.03.09.38.18;	author tg;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.14.13.32.38;	author tg;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.14.13.28.59;	author tg;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.14.12.51.29;	author tg;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.14.01.06.46;	author tg;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.14.00.58.20;	author tg;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.13.23.49.44;	author tg;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.13.23.28.47;	author tg;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.13.22.32.17;	author tg;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.13.22.17.32;	author tg;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.31.16.25.03;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.31.15.52.51;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.31.15.51.43;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.31.15.49.39;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.31.15.25.31;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.31.15.24.34;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.31.15.23.47;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.28.22.07.25;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.28.21.30.15;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.19.01.36.13;	author tg;	state Stab;
branches;
next	1.8;

1.8
date	2004.06.13.19.12.13;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.27.19.10.49;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.23.20.16.29;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.14.18.23.27;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.10.16.43.07;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.15.20.11.58;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.29.19.54.33;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.51.51;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.51.51;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.15.17.44.46;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.05.18.57.05;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.21.19.10.30;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.06.29.17.34.07;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.07.02.15.36.22;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.09.25.16.39.20;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.12.22.21.04.12;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.01.02.17.54.27;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.01.26.18.52.50;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.05.16.09.06.42;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2004.11.13.22.10.08;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2004.11.13.22.24.45;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2004.11.13.23.00.52;	author tg;	state Exp;
branches;
next	;


desc
@@


1.28
log
@there might be some adaptions needed here
@
text
@;	$MirBSD: src/sys/kern/syscalls.master,v 1.27 2004/11/14 13:32:38 tg Exp $
;	$OpenBSD: syscalls.master,v 1.76 2004/07/15 14:35:34 deraadt Exp $
;	$NetBSD: syscalls.master,v 1.32 1996/04/23 10:24:21 mycroft Exp $
;	@@(#)syscalls.master	8.2 (Berkeley) 1/13/94

; MirOS BSD system call name/number "master" file.
; (See syscalls.conf to see what it is processed into.)
;
; Fields: number type [type-dependent ...]
;	number	system call number, must be in order
;	type	one of STD, OBSOL, UNIMPL, NODEF, NOARGS, EMUL, INDIR or
;		one of the compatibility options defined in syscalls.conf.
;
; types:
;	STD	always included
;	OBSOL	obsolete, not included in system
;	UNIMPL	unimplemented, not included in system
;	NODEF	included, but don't define the syscall number
;	NOARGS	included, but don't define the syscall args structure
;	INDIR	included, but don't define the syscall args structure,
;		and allow it to be "really" varargs.
;	EMUL	not included, but define the syscall args structure
;
; The compat options are defined in the syscalls.conf file, and the
; compat option name is prefixed to the syscall name.  Other than
; that, they're like NODEF (for 'compat' options), or STD (for
; 'libcompat' options).
;
; The type-dependent arguments are as follows:
; For STD, NODEF, EMUL, NOARGS, and compat syscalls:
;	{ pseudo-proto } [alias]
; For other syscalls:
;	[comment]
;
; #ifdef's, etc. may be included, and are copied to the output files.
; #include's are copied to the syscall switch definition file only.

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signal.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <sys/poll.h>
#include <sys/event.h>

; Reserved/unimplemented system calls in the range 0-150 inclusive
; are reserved for use in future Berkeley releases.
; Additional system calls implemented in vendor and other
; redistributions should be placed in the reserved range at the end
; of the current calls.

0	INDIR		{ int sys_syscall(int number, ...); }
1	STD		{ void sys_exit(int rval); }
2	STD		{ int sys_fork(void); }
3	STD		{ ssize_t sys_read(int fd, void *buf, size_t nbyte); }
4	STD		{ ssize_t sys_write(int fd, const void *buf, \
			    size_t nbyte); }
5	STD		{ int sys_open(const char *path, \
			    int flags, ... mode_t mode); }
6	STD		{ int sys_close(int fd); }
7	STD		{ pid_t sys_wait4(pid_t pid, int *status, \
			    int options, struct rusage *rusage); }
8	EMUL		{ int compat_43_sys_creat(const char *path, \
			    mode_t mode); } ocreat
9	STD		{ int sys_link(const char *path, const char *link); }
10	STD		{ int sys_unlink(const char *path); }
11	OBSOL		execv
12	STD		{ int sys_chdir(const char *path); }
13	STD		{ int sys_fchdir(int fd); }
14	STD		{ int sys_mknod(const char *path, mode_t mode, \
			    dev_t dev); }
15	STD		{ int sys_chmod(const char *path, mode_t mode); }
16	STD		{ int sys_chown(const char *path, uid_t uid, \
			    gid_t gid); }
17	STD		{ int sys_obreak(char *nsize); } break
18	EMUL		{ int compat_25_sys_getfsstat(struct statfs *buf, \
			    long bufsize, int flags); } ogetfsstat
19	EMUL		{ long compat_43_sys_lseek(int fd, long offset, \
			    int whence); } olseek
20	STD		{ pid_t sys_getpid(void); }
21	STD		{ int sys_mount(const char *type, const char *path, \
			    int flags, void *data); }
22	STD		{ int sys_unmount(const char *path, int flags); }
23	STD		{ int sys_setuid(uid_t uid); }
24	STD		{ uid_t sys_getuid(void); }
25	STD		{ uid_t sys_geteuid(void); }
#ifdef PTRACE
26	STD		{ int sys_ptrace(int req, pid_t pid, caddr_t addr, \
			    int data); }
#else
26	UNIMPL		ptrace
#endif
27	STD		{ ssize_t sys_recvmsg(int s, struct msghdr *msg, \
			    int flags); }
28	STD		{ ssize_t sys_sendmsg(int s, \
			    const struct msghdr *msg, int flags); }
29	STD		{ ssize_t sys_recvfrom(int s, void *buf, size_t len, \
			    int flags, struct sockaddr *from, \
			    socklen_t *fromlenaddr); }
30	STD		{ int sys_accept(int s, struct sockaddr *name, \
			    socklen_t *anamelen); }
31	STD		{ int sys_getpeername(int fdes, struct sockaddr *asa, \
			    socklen_t *alen); }
32	STD		{ int sys_getsockname(int fdes, struct sockaddr *asa, \
			    socklen_t *alen); }
33	STD		{ int sys_access(const char *path, int flags); }
34	STD		{ int sys_chflags(const char *path, u_int flags); }
35	STD		{ int sys_fchflags(int fd, u_int flags); }
36	STD		{ void sys_sync(void); }
37	STD		{ int sys_kill(int pid, int signum); }
38	EMUL		{ int compat_43_openbsd_sys_stat(char *path, \
			    struct stat43 *ub); } stat43
39	STD		{ pid_t sys_getppid(void); }
40	EMUL		{ int compat_43_sys_lstat(char *path, \
			    struct stat43 *ub); } lstat43
41	STD		{ int sys_dup(int fd); }
42	EMUL		{ int sys_opipe(void); }
43	STD		{ gid_t sys_getegid(void); }
44	STD		{ int sys_profil(caddr_t samples, size_t size, \
			    u_long offset, u_int scale); }
#ifdef KTRACE
45	STD		{ int sys_ktrace(const char *fname, int ops, \
			    int facs, pid_t pid); }
#else
45	UNIMPL		ktrace
#endif
46	STD		{ int sys_sigaction(int signum, \
			    const struct sigaction *nsa, \
			    struct sigaction *osa); }
47	STD		{ gid_t sys_getgid(void); }
48	STD		{ int sys_sigprocmask(int how, sigset_t mask); }
49	STD		{ int sys_getlogin(char *namebuf, u_int namelen); }
50	STD		{ int sys_setlogin(const char *namebuf); }
#ifdef ACCOUNTING
51	STD		{ int sys_acct(const char *path); }
#else
51	UNIMPL		acct
#endif
52	STD		{ int sys_sigpending(void); }
53	EMUL		{ int compat_35_sys_osigaltstack( \
			    const struct osigaltstack *nss, \
			    struct osigaltstack *oss); }
54	STD		{ int sys_ioctl(int fd, \
			    u_long com, ... void *data); }
55	STD		{ int sys_reboot(int opt); }
56	STD		{ int sys_revoke(const char *path); }
57	STD		{ int sys_symlink(const char *path, \
			    const char *link); }
58	STD		{ int sys_readlink(const char *path, char *buf, \
			    size_t count); }
59	STD		{ int sys_execve(const char *path, \
			    char * const *argp, char * const *envp); }
60	STD		{ mode_t sys_umask(mode_t newmask); }
61	STD		{ int sys_chroot(const char *path); }
62	EMUL		{ int compat_43_sys_fstat(int fd, \
			    struct stat43 *sb); } fstat43
63	EMUL		{ int compat_43_sys_getkerninfo(int op, char *where, \
			    int *size, int arg); } ogetkerninfo
64	EMUL		{ int compat_43_sys_getpagesize(void); } ogetpagesize
65	EMUL		{ int compat_25_sys_omsync(caddr_t addr, size_t len); }
66	STD		{ int sys_vfork(void); }
67	OBSOL		vread
68	OBSOL		vwrite
69	STD		{ int sys_sbrk(int incr); }
70	UNIMPL		sstk
71	EMUL		{ int compat_43_sys_mmap(caddr_t addr, size_t len, \
			    int prot, int flags, int fd, long pos); } ommap
72	STD		{ int sys_ovadvise(int anom); } vadvise
73	STD		{ int sys_munmap(void *addr, size_t len); }
74	STD		{ int sys_mprotect(void *addr, size_t len, \
			    int prot); }
75	STD		{ int sys_madvise(void *addr, size_t len, \
			    int behav); }
76	OBSOL		vhangup
77	OBSOL		vlimit
78	STD		{ int sys_mincore(void *addr, size_t len, \
			    char *vec); }
79	STD		{ int sys_getgroups(int gidsetsize, \
			    gid_t *gidset); }
80	STD		{ int sys_setgroups(int gidsetsize, \
			    const gid_t *gidset); }
81	STD		{ int sys_getpgrp(void); }
82	STD		{ int sys_setpgid(pid_t pid, int pgid); }
83	STD		{ int sys_setitimer(int which, \
			    const struct itimerval *itv, \
			    struct itimerval *oitv); }
84	EMUL		{ int compat_43_sys_wait(void); } owait
85	EMUL		{ int compat_25_sys_swapon(const char *name); }
86	STD		{ int sys_getitimer(int which, \
			    struct itimerval *itv); }
87	EMUL		{ int compat_43_sys_gethostname(char *hostname, \
			    u_int len); } ogethostname
88	EMUL		{ int compat_43_sys_sethostname(char *hostname, \
			    u_int len); } osethostname
89	EMUL		{ int compat_43_sys_getdtablesize(void); } \
			    ogetdtablesize
90	STD		{ int sys_dup2(int from, int to); }
91	UNIMPL		getdopt
92	STD		{ int sys_fcntl(int fd, int cmd, ... void *arg); }
93	STD		{ int sys_select(int nd, fd_set *in, fd_set *ou, \
			    fd_set *ex, struct timeval *tv); }
94	UNIMPL		setdopt
95	STD		{ int sys_fsync(int fd); }
96	STD		{ int sys_setpriority(int which, id_t who, int prio); }
97	STD		{ int sys_socket(int domain, int type, int protocol); }
98	STD		{ int sys_connect(int s, const struct sockaddr *name, \
			    socklen_t namelen); }
99	EMUL		{ int compat_43_sys_accept(int s, caddr_t name, \
			    int *anamelen); } oaccept
100	STD		{ int sys_getpriority(int which, id_t who); }
101	EMUL		{ int compat_43_sys_send(int s, caddr_t buf, int len, \
			    int flags); } osend
102	EMUL		{ int compat_43_sys_recv(int s, caddr_t buf, int len, \
			    int flags); } orecv
103	STD		{ int sys_sigreturn(struct sigcontext *sigcntxp); }
104	STD		{ int sys_bind(int s, const struct sockaddr *name, \
			    socklen_t namelen); }
105	STD		{ int sys_setsockopt(int s, int level, int name, \
			    const void *val, socklen_t valsize); }
106	STD		{ int sys_listen(int s, int backlog); }
107	OBSOL		vtimes
108	EMUL		{ int compat_43_sys_sigvec(int signum, \
			    struct sigvec *nsv, struct sigvec *osv); } osigvec
109	EMUL		{ int compat_43_sys_sigblock(int mask); } osigblock
110	EMUL		{ int compat_43_sys_sigsetmask(int mask); } \
			    osigsetmask
111	STD		{ int sys_sigsuspend(int mask); }
112	EMUL		{ int compat_43_sys_sigstack(struct sigstack *nss, \
			    struct sigstack *oss); } osigstack
113	EMUL		{ int compat_43_sys_recvmsg(int s, \
			    struct omsghdr *msg, int flags); } orecvmsg
114	EMUL		{ int compat_43_sys_sendmsg(int s, caddr_t msg, \
			    int flags); } osendmsg
115	OBSOL		vtrace
116	STD		{ int sys_gettimeofday(struct timeval *tp, \
			    struct timezone *tzp); }
117	STD		{ int sys_getrusage(int who, struct rusage *rusage); }
118	STD		{ int sys_getsockopt(int s, int level, int name, \
			    void *val, socklen_t *avalsize); }
119	OBSOL		resuba
120	STD		{ ssize_t sys_readv(int fd, \
			    const struct iovec *iovp, int iovcnt); }
121	STD		{ ssize_t sys_writev(int fd, \
			    const struct iovec *iovp, int iovcnt); }
122	STD		{ int sys_settimeofday(const struct timeval *tv, \
			    const struct timezone *tzp); }
123	STD		{ int sys_fchown(int fd, uid_t uid, gid_t gid); }
124	STD		{ int sys_fchmod(int fd, mode_t mode); }
125	EMUL		{ int compat_43_sys_recvfrom(int s, caddr_t buf, \
			    size_t len, int flags, caddr_t from, \
			    int *fromlenaddr); } orecvfrom
126	STD		{ int sys_setreuid(uid_t ruid, uid_t euid); }
127	STD		{ int sys_setregid(gid_t rgid, gid_t egid); }
128	STD		{ int sys_rename(const char *from, const char *to); }
129	EMUL		{ int compat_43_sys_truncate(const char *path, \
			    long length); } otruncate
130	EMUL		{ int compat_43_sys_ftruncate(int fd, \
			    long length); } oftruncate
131	STD		{ int sys_flock(int fd, int how); }
132	STD		{ int sys_mkfifo(const char *path, mode_t mode); }
133	STD		{ ssize_t sys_sendto(int s, const void *buf, \
			    size_t len, int flags, const struct sockaddr *to, \
			    socklen_t tolen); }
134	STD		{ int sys_shutdown(int s, int how); }
135	STD		{ int sys_socketpair(int domain, int type, \
			    int protocol, int *rsv); }
136	STD		{ int sys_mkdir(const char *path, mode_t mode); }
137	STD		{ int sys_rmdir(const char *path); }
138	STD		{ int sys_utimes(const char *path, \
			    const struct timeval *tptr); }
139	OBSOL		4.2 sigreturn
140	STD		{ int sys_adjtime(const struct timeval *delta, \
			    struct timeval *olddelta); }
141	EMUL		{ int compat_43_sys_getpeername(int fdes, \
			    caddr_t asa, socklen_t *alen); } ogetpeername
142	EMUL		{ int32_t compat_43_sys_gethostid(void); } ogethostid
143	EMUL		{ int compat_43_sys_sethostid(int32_t hostid); } \
			    osethostid
144	EMUL		{ int compat_43_sys_getrlimit(int which, \
			    struct ogetrlimit *rlp); } ogetrlimit
145	EMUL		{ int compat_43_sys_setrlimit(int which, \
			    struct ogetrlimit *rlp); } osetrlimit
146	EMUL		{ int compat_43_sys_killpg(int pgid, int signum); } \
			    okillpg
147	STD		{ int sys_setsid(void); }
148	STD		{ int sys_quotactl(const char *path, int cmd, \
			    int uid, char *arg); }
149	EMUL		{ int compat_43_sys_quota(void); } oquota
150	EMUL		{ int compat_43_sys_getsockname(int fdec, \
			    caddr_t asa, int *alen); } ogetsockname

; Syscalls 151-180 inclusive are reserved for vendor-specific
; system calls.  (This includes various calls added for compatibity
; with other Unix variants.)
; Some of these calls are now supported by BSD...
151	UNIMPL
152	UNIMPL
153	UNIMPL
154	UNIMPL
#if defined(NFSCLIENT) || defined(NFSSERVER)
155	STD		{ int sys_nfssvc(int flag, void *argp); }
#else
155	UNIMPL		nfssvc
#endif
156	EMUL		{ int compat_43_sys_getdirentries(int fd, char *buf, \
			    int count, long *basep); } ogetdirentries
157	EMUL		{ int compat_25_openbsd_sys_statfs(char *path, \
			    struct ostatfs *buf); } ostatfs
158	EMUL		{ int compat_25_sys_fstatfs(int fd, \
			    struct ostatfs *buf); } ostatfs
159	UNIMPL
160	UNIMPL
161	STD		{ int sys_getfh(const char *fname, fhandle_t *fhp); }
162	EMUL		{ int compat_09_sys_getdomainname(char *domainname, \
			    int len); } ogetdomainname
163	EMUL		{ int compat_09_sys_setdomainname(char *domainname, \
			    int len); } osetdomainname
164	EMUL		{ int compat_09_sys_uname(struct outsname *name); } \
			    ouname
165	STD		{ int sys_sysarch(int op, void *parms); }
166	UNIMPL
167	UNIMPL
168	UNIMPL
#if defined(SYSVSEM) && !defined(__LP64__)
169	EMUL		{ int compat_10_sys_semsys(int which, int a2, \
			    int a3, int a4, int a5); } osemsys
#else
169	UNIMPL		1.0 semsys
#endif
#if defined(SYSVMSG) && !defined(__LP64__)
170	EMUL		{ int compat_10_sys_msgsys(int which, int a2, \
			    int a3, int a4, int a5, int a6); } omsgsys
#else
170	UNIMPL		1.0 msgsys
#endif
#if defined(SYSVSHM) && !defined(__LP64__)
171	EMUL		{ int compat_10_sys_shmsys(int which, int a2, \
			    int a3, int a4); } oshmsys
#else
171	UNIMPL		1.0 shmsys
#endif
172	UNIMPL
173	STD		{ ssize_t sys_pread(int fd, void *buf, \
			  size_t nbyte, int pad, off_t offset); }
174	STD		{ ssize_t sys_pwrite(int fd, const void *buf, \
			  size_t nbyte, int pad, off_t offset); }
175	UNIMPL		ntp_gettime
176	UNIMPL		ntp_adjtime
177	UNIMPL
178	UNIMPL
179	UNIMPL
180	UNIMPL

; Syscalls 181-199 are used by/reserved for BSD
181	STD		{ int sys_setgid(gid_t gid); }
182	STD		{ int sys_setegid(gid_t egid); }
183	STD		{ int sys_seteuid(uid_t euid); }
#ifdef LFS
184	STD		{ int lfs_bmapv(fsid_t *fsidp, \
			    struct block_info *blkiov, int blkcnt); }
185	STD		{ int lfs_markv(fsid_t *fsidp, \
			    struct block_info *blkiov, int blkcnt); }
186	STD		{ int lfs_segclean(fsid_t *fsidp, u_long segment); }
187	STD		{ int lfs_segwait(fsid_t *fsidp, \
			    struct timeval *tv); }
#else
184	UNIMPL		lfs_bmapv
185	UNIMPL		lfs_markv
186	UNIMPL		lfs_segclean
187	UNIMPL		lfs_segwait
#endif
188	COMPAT_78	{ int sys_stat(const char *path, \
			    struct stat78 *ub); } stat78
189	COMPAT_78	{ int sys_fstat(int fd, \
			    struct stat78 *sb); } fstat78
190	COMPAT_78	{ int sys_lstat(const char *path, \
			    struct stat78 *ub); } lstat78
191	STD		{ long sys_pathconf(const char *path, int name); }
192	STD		{ long sys_fpathconf(int fd, int name); }
193	STD		{ int sys_swapctl(int cmd, const void *arg, \
			    int misc); }
194	STD		{ int sys_getrlimit(int which, \
			    struct rlimit *rlp); }
195	STD		{ int sys_setrlimit(int which, \
			    const struct rlimit *rlp); }
196	STD		{ int sys_getdirentries(int fd, char *buf, \
			    int count, long *basep); }
197	STD		{ void *sys_mmap(void *addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
198	INDIR		{ quad_t sys___syscall(quad_t num, ...); }
199	STD		{ off_t sys_lseek(int fd, int pad, off_t offset, \
			    int whence); }
200	STD		{ int sys_truncate(const char *path, int pad, \
			    off_t length); }
201	STD		{ int sys_ftruncate(int fd, int pad, off_t length); }
202	STD		{ int sys___sysctl(int *name, u_int namelen, \
			    void *old, size_t *oldlenp, void *new, \
			    size_t newlen); }
203	STD		{ int sys_mlock(const void *addr, size_t len); }
204	STD		{ int sys_munlock(const void *addr, size_t len); }
205	STD		{ int sys_undelete(const char *path); }
206	STD		{ int sys_futimes(int fd, \
			    const struct timeval *tptr); }
207	STD		{ pid_t sys_getpgid(pid_t pid); }
208	UNIMPL
209	UNIMPL
;
; Syscalls 210-219 are reserved for dynamically loaded syscalls
;
#ifdef LKM
210	NODEF		{ int sys_lkmnosys(void); }
211	NODEF		{ int sys_lkmnosys(void); }
212	NODEF		{ int sys_lkmnosys(void); }
213	NODEF		{ int sys_lkmnosys(void); }
214	NODEF		{ int sys_lkmnosys(void); }
215	NODEF		{ int sys_lkmnosys(void); }
216	NODEF		{ int sys_lkmnosys(void); }
217	NODEF		{ int sys_lkmnosys(void); }
218	NODEF		{ int sys_lkmnosys(void); }
219	NODEF		{ int sys_lkmnosys(void); }
#else	/* !LKM */
210	UNIMPL
211	UNIMPL
212	UNIMPL
213	UNIMPL
214	UNIMPL
215	UNIMPL
216	UNIMPL
217	UNIMPL
218	UNIMPL
219	UNIMPL
#endif	/* !LKM */
; System calls 220-240 are reserved for use by OpenBSD
#ifdef SYSVSEM
220	EMUL		{ int compat_23_sys___semctl(int semid, int semnum, \
			    int cmd, union semun *arg); } semctl23
221	STD		{ int sys_semget(key_t key, int nsems, int semflg); }
222	EMUL		{ int compat_35_sys_semop(int semid, \
			    struct sembuf *sops, u_int nsops); }
223	OBSOL		sys_semconfig
#else
220	UNIMPL		semctl
221	UNIMPL		semget
222	UNIMPL		semop
223	UNIMPL		semconfig
#endif
#ifdef SYSVMSG
224	EMUL		{ int compat_23_sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds23 *buf); } msgctl23
225	STD		{ int sys_msgget(key_t key, int msgflg); }
226	STD		{ int sys_msgsnd(int msqid, const void *msgp, \
			    size_t msgsz, int msgflg); }
227	STD		{ int sys_msgrcv(int msqid, void *msgp, size_t msgsz, \
			    long msgtyp, int msgflg); }
#else
224	UNIMPL		msgctl23
225	UNIMPL		msgget
226	UNIMPL		msgsnd
227	UNIMPL		msgrcv
#endif
#ifdef SYSVSHM
228	STD		{ void *sys_shmat(int shmid, const void *shmaddr, \
			    int shmflg); }
229	EMUL		{ int compat_23_sys_shmctl(int shmid, int cmd, \
			    struct shmid_ds23 *buf); } shmctl23
230	STD		{ int sys_shmdt(const void *shmaddr); }
231	EMUL		{ int compat_35_sys_shmget(key_t key, int size, \
			    int shmflg); }
#else
228	UNIMPL		shmat
229	UNIMPL		shmctl23
230	UNIMPL		shmdt
231	UNIMPL		shmget35
#endif
232	STD		{ int sys_clock_gettime(clockid_t clock_id, \
			    struct timespec *tp); }
233	STD		{ int sys_clock_settime(clockid_t clock_id, \
			    const struct timespec *tp); }
234	STD		{ int sys_clock_getres(clockid_t clock_id, \
			    struct timespec *tp); }
235	UNIMPL		timer_create
236	UNIMPL		timer_delete
237	UNIMPL		timer_settime
238	UNIMPL		timer_gettime
239	UNIMPL		timer_getoverrun
;
; System calls 240-249 are reserved for other IEEE Std1003.1b syscalls
;
240	STD		{ int sys_nanosleep(const struct timespec *rqtp, \
			    struct timespec *rmtp); }
241	UNIMPL
242	UNIMPL
243	UNIMPL
244	UNIMPL
245	UNIMPL
246	UNIMPL
247	UNIMPL
248	UNIMPL
249	UNIMPL
250	STD		{ int sys_minherit(void *addr, size_t len, \
			    int inherit); }
251	STD		{ int sys_rfork(int flags); }
252	STD		{ int sys_poll(struct pollfd *fds, \
			    u_int nfds, int timeout); }
253	STD		{ int sys_issetugid(void); }
254	STD		{ int sys_lchown(const char *path, uid_t uid, \
			    gid_t gid); }
255	STD		{ pid_t sys_getsid(pid_t pid); }
256	STD		{ int sys_msync(void *addr, size_t len, int flags); }
#if defined(SYSVSEM) && defined(COMPAT_78)
257	STD		{ int compat_35_sys___semctl(int semid, int semnum, \
			    int cmd, union semun *arg); } semctl35
#else
257	UNIMPL		semctl35
#endif
#if defined(SYSVSHM) && defined(COMPAT_78)
258	STD		{ int compat_35_sys_shmctl(int shmid, int cmd, \
			    struct shmid_ds35 *buf); } shmctl35
#else
258	UNIMPL		shmctl35
#endif
#if defined(SYSVMSG) && defined(COMPAT_78)
259	STD		{ int compat_35_sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds35 *buf); } msgctl35
#else
259	UNIMPL		msgctl35
#endif
260	STD		{ int sys_getfsstat(struct statfs *buf, \
			    size_t bufsize, int flags); }
261	STD		{ int sys_statfs(const char *path, \
			    struct statfs *buf); }
262	STD		{ int sys_fstatfs(int fd, struct statfs *buf); }
263	STD		{ int sys_pipe(int *fdp); }
264	STD		{ int sys_fhopen(const fhandle_t *fhp, int flags); }
265	COMPAT_78	{ int sys_fhstat(const fhandle_t *fhp, \
			    struct stat78 *sb); } fhstat78
266	STD		{ int sys_fhstatfs(const fhandle_t *fhp, \
			    struct statfs *buf); }
267	STD		{ ssize_t sys_preadv(int fd, \
			  const struct iovec *iovp, int iovcnt, \
			  int pad, off_t offset); }
268	STD		{ ssize_t sys_pwritev(int fd, \
			  const struct iovec *iovp, int iovcnt, \
			  int pad, off_t offset); }
269	STD		{ int sys_kqueue(void); }
270	STD		{ int sys_kevent(int fd, \
			    const struct kevent *changelist, int nchanges, \
			    struct kevent *eventlist, int nevents, \
			    const struct timespec *timeout); }
271	STD		{ int sys_mlockall(int flags); }
272	STD		{ int sys_munlockall(void); }
273	STD		{ int sys_getpeereid(int fdes, uid_t *euid, \
			    gid_t *egid); }
#ifdef UFS_EXTATTR
274	STD		{ int sys_extattrctl(const char *path, int cmd, \
			    const char *filename, int attrnamespace, \
			    const char *attrname); }
275	STD		{ int sys_extattr_set_file(const char *path, \
			    int attrnamespace, const char *attrname, \
			    const void *data, size_t nbytes); }
276	STD		{ ssize_t sys_extattr_get_file(const char *path, \
			    int attrnamespace, const char *attrname, \
			    void *data, size_t nbytes); }
277	STD		{ int sys_extattr_delete_file(const char *path, \
			    int attrnamespace, const char *attrname); }
278	STD		{ int sys_extattr_set_fd(int fd, int attrnamespace, \
			    const char *attrname, const void *data, \
			    size_t nbytes); }
279	STD		{ ssize_t sys_extattr_get_fd(int fd, \
			    int attrnamespace, const char *attrname, \
			    void *data, size_t nbytes); }
280	STD		{ int sys_extattr_delete_fd(int fd, \
			    int attrnamespace, const char *attrname); }
#else
274	UNIMPL		sys_extattrctl
275	UNIMPL		sys_extattr_set_file
276	UNIMPL		sys_extattr_get_file
277	UNIMPL		sys_extattr_delete_file
278	UNIMPL		sys_extattr_set_fd
279	UNIMPL		sys_extattr_get_fd
280	UNIMPL		sys_extattr_delete_fd
#endif
281	STD		{ int sys_getresuid(uid_t *ruid, uid_t *euid, \
			    uid_t *suid); }
282	STD		{ int sys_setresuid(uid_t ruid, uid_t euid, \
			    uid_t suid); }
283	STD		{ int sys_getresgid(gid_t *rgid, gid_t *egid, \
			    gid_t *sgid); }
284	STD		{ int sys_setresgid(gid_t rgid, gid_t egid, \
			    gid_t sgid); }
285	OBSOL		sys_omquery
286	STD		{ void *sys_mquery(void *addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
287	STD		{ int sys_closefrom(int fd); }
288	STD		{ int sys_sigaltstack(const struct sigaltstack *nss, \
			    struct sigaltstack *oss); }
289	STD		{ int sys_fchroot(int fd); }
#ifdef SYSVSHM
290	STD		{ int sys_shmget(key_t key, size_t size, int shmflg); }
#else
290	UNIMPL		shmget
#endif
#ifdef SYSVSEM
291	STD		{ int sys_semop(int semid, struct sembuf *sops, \
			    size_t nsops); }
#else
291	UNIMPL		semop
#endif
292	STD		{ int sys_stat(const char *path, struct stat *ub); }
293	STD		{ int sys_fstat(int fd, struct stat *sb); }
294	STD		{ int sys_lstat(const char *path, struct stat *ub); }
295	STD		{ int sys_fhstat(const fhandle_t *fhp, \
			    struct stat *sb); }
#ifdef SYSVSEM
296	STD		{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); }
#else
296	UNIMPL		semctl
#endif
#ifdef SYSVSHM
297	STD		{ int sys_shmctl(int shmid, int cmd, \
			    struct shmid_ds *buf); }
#else
297	UNIMPL		shmctl
#endif
#ifdef SYSVMSG
298	STD		{ int sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds *buf); }
#else
298	UNIMPL		msgctl
#endif
@


1.27
log
@sync
@
text
@d1 1
a1 1
;	$MirBSD: src/sys/kern/syscalls.master,v 1.26 2004/11/14 13:28:59 tg Exp $
d111 1
a111 1
38	EMUL		{ int compat_43_sys_stat(const char *path, \
d307 1
a307 1
157	EMUL		{ int compat_25_sys_statfs(const char *path, \
@


1.26
log
@compat_35 sys_msgctl, not compat_78
that's what the #ifdef is good for...

also, fill in a few blanks after UNIMPL
@
text
@d1 1
a1 1
;	$MirBSD: src/sys/kern/syscalls.master,v 1.25 2004/11/14 12:51:29 tg Exp $
d456 1
a456 1
224	UNIMPL		msgctl
d471 1
a471 1
229	UNIMPL		shmctl
d473 1
a473 1
231	UNIMPL		shmget
@


1.25
log
@some omsqid_ds -> msqid_ds23 either OpenBSD missed, or
I missed to ci to -ropenbsd yesterday
@
text
@d1 1
a1 1
;	$MirBSD: src/sys/kern/syscalls.master,v 1.24 2004/11/14 01:06:46 tg Exp $
d303 1
a303 1
155	UNIMPL
d367 4
a370 4
184	UNIMPL
185	UNIMPL
186	UNIMPL
187	UNIMPL
d514 1
a514 1
257	UNIMPL
d520 1
a520 1
258	UNIMPL
d523 1
a523 1
259	STD		{ int compat_78_sys_msgctl(int msqid, int cmd, \
d526 1
a526 1
259	UNIMPL
d618 1
a618 1
296	UNIMPL
d624 1
a624 1
297	UNIMPL
d630 1
a630 1
298	UNIMPL
@


1.24
log
@remove COMPAT_35 as an option
do all the magic with COMPAT_78
@
text
@d1 1
a1 1
;	$MirBSD: src/sys/kern/syscalls.master,v 1.23 2004/11/14 00:58:20 tg Exp $
d449 1
a449 1
			    struct omsqid_ds *buf); } msgctl23
d465 1
a465 1
			    struct oshmid_ds *buf); } shmctl23
@


1.23
log
@next round of shuffling:
* add COMPAT_78 (and COMPAT_35) as options to the kernel,
  specifying compatibility to pre-stat-change, post-time_t
  systems (#7-current, early #8-beta)
* for COMPAT_OPENBSD, there's always all functions there
* stat35_n -> stat78 (conditionalised)
* stat35_o -> stat35 (conditionalised)
@
text
@d1 1
a1 1
;	$MirBSD: src/sys/kern/syscalls.master,v 1.22 2004/11/13 23:49:44 tg Exp $
d510 2
a511 2
#ifdef SYSVSEM
257	COMPAT_35	{ int sys___semctl(int semid, int semnum, \
d516 2
a517 2
#ifdef SYSVSHM
258	COMPAT_35	{ int sys_shmctl(int shmid, int cmd, \
d522 2
a523 2
#ifdef SYSVMSG
259	COMPAT_35	{ int sys_msgctl(int msqid, int cmd, \
@


1.22
log
@split stat35 into stat35_o and stat35_n,
and compat_35 into compat_35n (compat_35o to follow)
@
text
@d1 1
a1 1
;	$MirBSD: src/sys/kern/syscalls.master,v 1.21 2004/11/13 23:28:47 tg Exp $
d372 6
a377 6
188	STD		{ int compat_35n_sys_stat(const char *path, \
			    struct stat35_n *ub); } stat35
189	STD		{ int compat_35n_sys_fstat(int fd, \
			    struct stat35_n *sb); } fstat35
190	STD		{ int compat_35n_sys_lstat(const char *path, \
			    struct stat35_n *ub); } lstat35
d511 1
a511 1
257	EMUL		{ int compat_35_sys___semctl(int semid, int semnum, \
d517 1
a517 1
258	EMUL		{ int compat_35_sys_shmctl(int shmid, int cmd, \
d523 1
a523 1
259	EMUL		{ int compat_35_sys_msgctl(int msqid, int cmd, \
d535 2
a536 2
265	STD		{ int compat_35n_sys_fhstat(const fhandle_t *fhp, \
			    struct stat35_n *sb); }
@


1.21
log
@merge stat and *_t changes
@
text
@d1 1
a1 1
;	$MirBSD: src/sys/kern/syscalls.master,v 1.20 2004/11/13 22:32:17 tg Exp $
d372 6
a377 6
188	EMUL		{ int compat_35_sys_stat(const char *path, \
			    struct stat35 *ub); } stat35
189	EMUL		{ int compat_35_sys_fstat(int fd, \
			    struct stat35 *sb); } fstat35
190	EMUL		{ int compat_35_sys_lstat(const char *path, \
			    struct stat35 *ub); } lstat35
d535 2
a536 2
265	EMUL		{ int compat_35_sys_fhstat(const fhandle_t *fhp, \
			    struct stat35 *sb); }
@


1.20
log
@merge openbsd ostat->stat43 changes
also, in vfs_syscalls_43, ensure time_t wraps correctly
@
text
@d1 2
a2 2
;	$MirBSD: src/sys/kern/syscalls.master,v 1.19 2004/11/13 22:17:32 tg Exp $
;	$OpenBSD: syscalls.master,v 1.71 2004/07/09 23:52:02 millert Exp $
d59 1
a59 1
			    int flags, ... int mode); }
d64 1
a64 1
			    int mode); } ocreat
d70 1
a70 1
14	STD		{ int sys_mknod(const char *path, int mode, \
d72 1
a72 1
15	STD		{ int sys_chmod(const char *path, int mode); }
d103 1
a103 1
			    int *alen); }
d153 1
a153 1
60	STD		{ int sys_umask(int newmask); }
d248 1
a248 1
124	STD		{ int sys_fchmod(int fd, int mode); }
d260 1
a260 1
132	STD		{ int sys_mkfifo(const char *path, int mode); }
d267 1
a267 1
136	STD		{ int sys_mkdir(const char *path, int mode); }
d372 6
a377 3
188	STD		{ int sys_stat(const char *path, struct stat *ub); }
189	STD		{ int sys_fstat(int fd, struct stat *sb); }
190	STD		{ int sys_lstat(const char *path, struct stat *ub); }
d436 1
a436 1
			    int cmd, union semun *arg); } __osemctl
d449 1
a449 1
			    struct omsqid_ds *buf); } omsgctl
d465 1
a465 1
			    struct oshmid_ds *buf); } oshmctl
d511 2
a512 2
257	STD		{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); }
d517 2
a518 2
258	STD		{ int sys_shmctl(int shmid, int cmd, \
			    struct shmid_ds *buf); }
d523 2
a524 2
259	STD		{ int sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds *buf); }
d535 2
a536 2
265	STD		{ int sys_fhstat(const fhandle_t *fhp, \
			    struct stat *sb); }
d560 1
a560 1
			    void *data, size_t nbytes); }
d567 1
a567 1
			    const char *attrname, void *data, \
d608 23
@


1.19
log
@merge accounting changes
@
text
@d1 2
a2 2
;	$MirBSD: src/sys/kern/syscalls.master,v 1.18 2004/10/31 16:25:03 tg Exp $
;	$OpenBSD: syscalls.master,v 1.70 2004/05/27 20:48:46 tedu Exp $
d112 1
a112 1
			    struct ostat *ub); } ostat
d115 1
a115 1
			    struct ostat *ub); } olstat
d156 1
a156 1
			    struct ostat *sb); } ofstat
@


1.18
log
@change two more NODEF to EMUL
@
text
@d1 2
a2 2
	$MirBSD: src/sys/kern/syscalls.master,v 1.17 2004/10/31 15:52:51 tg Exp $
;	$OpenBSD: syscalls.master,v 1.69 2004/05/03 17:38:48 millert Exp $
d134 1
d136 3
@


1.17
log
@nothing calls opipe(2) directly, but pipe(2) and the emuls do
@
text
@d1 1
a1 1
	$MirBSD: src/sys/kern/syscalls.master,v 1.16 2004/10/31 15:51:43 tg Exp $
d111 1
a111 1
38	NODEF		{ int compat_43_sys_stat(const char *path, \
d114 1
a114 1
40	NODEF		{ int compat_43_sys_lstat(char *path, \
@


1.16
log
@osigaltstack is not used by libc, only by openbsd compat
@
text
@d1 1
a1 1
	$MirBSD: src/sys/kern/syscalls.master,v 1.15 2004/10/31 15:49:39 tg Exp $
d117 1
a117 1
42	STD		{ int sys_opipe(void); }
@


1.15
log
@sstk(2) is ENOSYS
@
text
@d1 1
a1 1
	$MirBSD: src/sys/kern/syscalls.master,v 1.14 2004/10/31 15:25:31 tg Exp $
d136 1
a136 1
53	STD		{ int sys_osigaltstack( \
@


1.14
log
@add EMUL to more descriptions
@
text
@d1 1
a1 1
	$MirBSD: src/sys/kern/syscalls.master,v 1.13 2004/10/31 15:24:34 tg Exp $
d161 1
a161 1
70	STD		{ int sys_sstk(int incr); }
@


1.13
log
@describe EMUL type
@
text
@d1 1
a1 1
	$MirBSD: src/sys/kern/syscalls.master,v 1.12 2004/10/31 15:23:47 tg Exp $
d11 2
a12 2
;	type	one of STD, OBSOL, UNIMPL, NODEF, NOARGS, or one of
;		the compatibility options defined in syscalls.conf.
d30 1
a30 1
; For STD, NODEF, NOARGS, and compat syscalls:
@


1.12
log
@restrict to 80c
flesh out all these syscalls native programmes don't need to new EMUL type
@
text
@d1 1
a1 1
	$MirBSD: src/sys/kern/syscalls.master,v 1.11 2004/10/28 22:07:25 tg Exp $
d22 1
@


1.11
log
@NODEF for the compat options, not OBSOL
XXX revisit this ;)
@
text
@d1 1
a1 1
	$MirBSD: src/sys/kern/syscalls.master,v 1.10 2004/10/28 21:30:15 tg Exp $
d60 4
a63 3
7	STD		{ pid_t sys_wait4(pid_t pid, int *status, int options, \
			    struct rusage *rusage); }
8	COMPAT_43	{ int sys_creat(const char *path, int mode); } ocreat
d75 4
a78 4
18	COMPAT_25	{ int sys_getfsstat(struct statfs *buf, long bufsize, \
			    int flags); } ogetfsstat
19	COMPAT_43	{ long sys_lseek(int fd, long offset, int whence); } \
			    olseek
d135 2
a136 1
53	STD		{ int sys_osigaltstack(const struct osigaltstack *nss, \
d150 6
a155 6
62	NODEF		{ int compat_43_sys_fstat(int fd, struct ostat *sb); } \
			    ofstat
63	COMPAT_43	{ int sys_getkerninfo(int op, char *where, int *size, \
			    int arg); } ogetkerninfo
64	COMPAT_43	{ int sys_getpagesize(void); } ogetpagesize
65	COMPAT_25	{ int sys_omsync(caddr_t addr, size_t len); }
d161 2
a162 2
71	COMPAT_43	{ int sys_mmap(caddr_t addr, size_t len, int prot, \
			    int flags, int fd, long pos); } ommap
d182 2
a183 2
84	COMPAT_43	{ int sys_wait(void); } owait
85	COMPAT_25	{ int sys_swapon(const char *name); }
d186 6
a191 5
87	COMPAT_43	{ int sys_gethostname(char *hostname, u_int len); } \
			    ogethostname
88	COMPAT_43	{ int sys_sethostname(char *hostname, u_int len); } \
			    osethostname
89	COMPAT_43	{ int sys_getdtablesize(void); } ogetdtablesize
d203 1
a203 1
99	COMPAT_43	{ int sys_accept(int s, caddr_t name, \
d206 1
a206 1
101	COMPAT_43	{ int sys_send(int s, caddr_t buf, int len, \
d208 1
a208 1
102	COMPAT_43	{ int sys_recv(int s, caddr_t buf, int len, \
d217 5
a221 4
108	COMPAT_43	{ int sys_sigvec(int signum, struct sigvec *nsv, \
			    struct sigvec *osv); } osigvec
109	COMPAT_43	{ int sys_sigblock(int mask); } osigblock
110	COMPAT_43	{ int sys_sigsetmask(int mask); } osigsetmask
d223 1
a223 1
112	COMPAT_43	{ int sys_sigstack(struct sigstack *nss, \
d225 4
a228 4
113	COMPAT_43	{ int sys_recvmsg(int s, struct omsghdr *msg, \
			    int flags); } orecvmsg
114	COMPAT_43	{ int sys_sendmsg(int s, caddr_t msg, int flags); } \
			    osendmsg
d244 3
a246 3
125	COMPAT_43	{ int sys_recvfrom(int s, caddr_t buf, size_t len, \
			    int flags, caddr_t from, int *fromlenaddr); } \
			    orecvfrom
d250 4
a253 3
129	COMPAT_43	{ int sys_truncate(const char *path, long length); } \
			    otruncate
130	COMPAT_43	{ int sys_ftruncate(int fd, long length); } oftruncate
d269 6
a274 5
141	COMPAT_43	{ int sys_getpeername(int fdes, caddr_t asa, \
			    socklen_t *alen); } ogetpeername
142	COMPAT_43	{ int32_t sys_gethostid(void); } ogethostid
143	COMPAT_43	{ int sys_sethostid(int32_t hostid); } osethostid
144	COMPAT_43	{ int sys_getrlimit(int which, \
d276 1
a276 1
145	COMPAT_43	{ int sys_setrlimit(int which, \
d278 2
a279 1
146	COMPAT_43	{ int sys_killpg(int pgid, int signum); } okillpg
d283 3
a285 3
149	COMPAT_43	{ int sys_quota(void); } oquota
150	COMPAT_43	{ int sys_getsockname(int fdec, caddr_t asa, \
			    int *alen); } ogetsockname
d300 1
a300 1
156	COMPAT_43	{ int sys_getdirentries(int fd, char *buf, \
d302 3
a304 1
157	COMPAT_25	{ int sys_statfs(const char *path, \
a305 2
158	COMPAT_25	{ int sys_fstatfs(int fd, struct ostatfs *buf); } \
			    ostatfs
d309 6
a314 5
162	COMPAT_09	{ int sys_getdomainname(char *domainname, int len); } \
			    ogetdomainname
163	COMPAT_09	{ int sys_setdomainname(char *domainname, int len); } \
			    osetdomainname
164	COMPAT_09	{ int sys_uname(struct outsname *name); } ouname
d320 2
a321 2
169	COMPAT_10	{ int sys_semsys(int which, int a2, int a3, int a4, \
			    int a5); } osemsys
d326 2
a327 2
170	COMPAT_10	{ int sys_msgsys(int which, int a2, int a3, int a4, \
			    int a5, int a6); } omsgsys
d332 2
a333 2
171	COMPAT_10	{ int sys_shmsys(int which, int a2, int a3, int a4); } \
			    oshmsys
d359 2
a360 1
187	STD		{ int lfs_segwait(fsid_t *fsidp, struct timeval *tv); }
d372 2
a373 1
193	STD		{ int sys_swapctl(int cmd, const void *arg, int misc); }
d427 2
a428 2
220	COMPAT_23	{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); } __osemctl
d430 2
a431 2
222	COMPAT_35	{ int sys_semop(int semid, struct sembuf *sops, \
			    u_int nsops); }
d440 1
a440 1
224	COMPAT_23	{ int sys_msgctl(int msqid, int cmd, \
d443 2
a444 2
226	STD		{ int sys_msgsnd(int msqid, const void *msgp, size_t msgsz, \
			    int msgflg); }
d456 1
a456 1
229	COMPAT_23	{ int sys_shmctl(int shmid, int cmd, \
d459 2
a460 1
231	COMPAT_35	{ int sys_shmget(key_t key, int size, int shmflg); }
d498 2
a499 1
254	STD		{ int sys_lchown(const char *path, uid_t uid, gid_t gid); }
d520 2
a521 2
260	STD		{ int sys_getfsstat(struct statfs *buf, size_t bufsize, \
			    int flags); }
d544 2
a545 1
273	STD		{ int sys_getpeereid(int fdes, uid_t *euid, gid_t *egid); }
d564 2
a565 2
280	STD		{ int sys_extattr_delete_fd(int fd, int attrnamespace, \
			    const char *attrname); }
@


1.10
log
@mark some 4.3BSD syscalls OBSOL because they require time_t32
@
text
@d1 1
a1 1
	$MirBSD: src/sys/kern/syscalls.master,v 1.9 2004/06/19 01:36:13 tg Stab $
d109 2
a110 1
38	OBSOL		ostat
d112 2
a113 1
40	OBSOL		olstat
d148 2
a149 1
62	OBSOL		ofstat
@


1.9
log
@reverting just enough and fixing here and there so to make
the linuxulator back work
@
text
@d1 1
a1 1
	$MirBSD: src/sys/kern/syscalls.master,v 1.8 2004/06/13 19:12:13 tg Exp $
d109 1
a109 2
38	COMPAT_43	{ int sys_stat(const char *path, struct ostat *ub); } \
			    ostat
d111 1
a111 2
40	COMPAT_43	{ int sys_lstat(char *path, \
			    struct ostat *ub); } olstat
d146 1
a146 1
62	COMPAT_43	{ int sys_fstat(int fd, struct ostat *sb); } ofstat
@


1.8
log
@remove transiently added temporary syscalls
@
text
@d1 1
a1 1
	$MirBSD: src/sys/kern/syscalls.master,v 1.7 2004/05/27 19:10:49 tg Exp $
a61 1
#if defined(COMPAT_FREEBSD) || defined(COMPAT_BSDOS)
a62 3
#else
8	OBSOL		ocreat
#endif
d74 4
a77 2
18	OBSOL		ogetfsstat
19	OBSOL		olseek
a108 1
#if defined(COMPAT_FREEBSD) || defined(COMPAT_BSDOS)
a110 3
#else
38	OBSOL		ostat
#endif
a111 1
#if defined(COMPAT_FREEBSD) || defined(COMPAT_BSDOS) || defined(COMPAT_LINUX)
a113 3
#else
40	OBSOL		olstat
#endif
d148 5
a152 4
62	OBSOL		ofstat
63	OBSOL		ogetkerninfo
64	OBSOL		ogetpagesize
65	OBSOL		omsync
d158 2
a159 1
71	OBSOL		ommap
d179 2
a180 2
84	OBSOL		owait
85	OBSOL		oswapon
d183 5
a187 3
87	OBSOL		ogethostname
88	OBSOL		osethostname
89	OBSOL		ogetdtablesize
a198 1
#if defined(COMPAT_LINUX) || defined(COMPAT_BSDOS) || defined(COMPAT_FREEBSD)
a200 3
#else
99	OBSOL		oaccept
#endif
a201 1
#if defined(COMPAT_LINUX) || defined(COMPAT_BSDOS) || defined(COMPAT_FREEBSD)
a205 4
#else
101	OBSOL		osend
102	OBSOL		orecv
#endif
d213 4
a216 3
108	OBSOL		osigvec
109	OBSOL		osigblock
110	OBSOL		osigsetmask
d218 6
a223 3
112	OBSOL		osigstack
113	OBSOL		orecvmsg
114	OBSOL		osendmsg
d239 3
a241 1
125	OBSOL		orecvfrom
a244 1
#if defined(COMPAT_LINUX) || defined(COMPAT_BSDOS)
d247 1
a247 4
#else
129	OBSOL		otruncate
#endif
130	OBSOL		oftruncate
d263 6
a268 5
141	OBSOL		ogetpeername
142	OBSOL		ogethostid
143	OBSOL		osethostid
144	OBSOL		ogetrlimit
#if defined(COMPAT_LINUX) || defined(COMPAT_BSDOS) || defined(COMPAT_FREEBSD)
d271 1
a271 4
#else
145	OBSOL		osetrlimit
#endif
146	OBSOL		okillpg
d275 3
a277 2
149	OBSOL		oquota
150	OBSOL		ogetsockname
d292 6
a297 3
156	OBSOL		ogetdirentries
157	OBSOL		ostatfs
158	OBSOL		ostatfs
d301 5
a305 3
162	OBSOL		ogetdomainname
163	OBSOL		osetdomainname
164	OBSOL		ouname
d310 18
a327 3
169	OBSOL		osemsys
170	OBSOL		omsgsys
171	OBSOL		oshmsys
d416 2
a417 1
220	OBSOL		__osemctl
d419 3
a421 2
222	OBSOL		osemop
223	OBSOL		osemconfig
d425 2
a426 2
222	UNIMPL		osemop
223	UNIMPL		osemconfig
d429 2
a430 1
224	OBSOL		omsgctl
d445 2
a446 1
229	OBSOL		oshmctl
d448 1
a448 1
231	OBSOL		oshmget
d451 1
a451 1
229	UNIMPL		oshmctl
d453 1
a453 1
231	UNIMPL		oshmget
d569 1
a569 1
285	OBSOL		omquery
@


1.7
log
@* make kernel (GENERIC i386) build
* nuke more NS parts
* nuke more SVR4 compat
* fix compats
* more MirOS RCS IDs
* better randomness usage/distribution
* better paranoia checks in random stuff
* use \$SHELL instead of sh
etc.pp
@
text
@d1 1
a1 1
	$MirBSD: syscalls.master,v 1.6 2004/05/23 20:16:29 tg Exp $
a3 1

d412 1
a412 2
222	COMPAT_35	{ int sys_semop(int semid, struct sembuf *sops, \
			    u_int nsops); }
d417 2
a418 2
222	UNIMPL		semop
223	UNIMPL		semconfig
d438 1
a438 1
231	COMPAT_35	{ int sys_shmget(key_t key, int size, int shmflg); }
d441 1
a441 1
229	UNIMPL		shmctl
d443 1
a443 1
231	UNIMPL		shmget
@


1.6
log
@* first futile attempt to merge OpenBSD 3.5-current
* damn! they got pxeboot! -> disable for now
  (there's still ports/sysutils/pxegrub; we'll have pxeboot later)
* I don't know if that ... bootloader still works
* nuke netbsd emul (was unused anyways)
* nuke a plethora of syscalls not being used, and mark
  the other two (COMPAT_35) for deletion RSN
* merge new MI-GENERIC into i386 GENERIC
* resolve numeric conflicts for
  - syscalls
  - sysctls
  - device majors
  - pcidevs
* (c) cleanup - no need to add a bsd-like licence when
  there's already one; just add my name
* and much more
@
text
@d1 1
a1 1
;	$MirBSD: src/sys/kern/syscalls.master,v 1.5 2004/03/14 18:23:27 tg Exp $
d7 1
a7 1
; OpenBSD system call name/number "master" file.
d63 3
d67 1
d112 4
d117 1
d119 4
d124 1
d206 4
d211 1
d213 6
d221 1
d255 4
d260 1
d281 4
d286 1
@


1.5
log
@nuke xfs (not sgixfs!), the generic kernel-userland interface

does anyone use
 - netatalk
 - netccitt (I tried to build it; it's broken nearly beyond repair,
		and the NetBSD thing isn't better)
 - netiso
 - netns
or may someone nuke them sometime?
@
text
@d1 2
a2 2
;	$MirBSD: syscalls.master,v 1.4 2004/03/10 16:43:07 tg Exp $
;	$OpenBSD: syscalls.master,v 1.67 2004/01/14 05:23:25 tedu Exp $
d63 1
a63 1
8	COMPAT_43	{ int sys_creat(const char *path, int mode); } ocreat
d75 2
a76 4
18	COMPAT_25	{ int sys_getfsstat(struct statfs *buf, long bufsize, \
			    int flags); } ogetfsstat
19	COMPAT_43	{ long sys_lseek(int fd, long offset, int whence); } \
			    olseek
d108 1
a108 2
38	COMPAT_43	{ int sys_stat(const char *path, struct ostat *ub); } \
			    ostat
d110 1
a110 2
40	COMPAT_43	{ int sys_lstat(char *path, \
			    struct ostat *ub); } olstat
d145 4
a148 5
62	COMPAT_43	{ int sys_fstat(int fd, struct ostat *sb); } ofstat
63	COMPAT_43	{ int sys_getkerninfo(int op, char *where, int *size, \
			    int arg); } ogetkerninfo
64	COMPAT_43	{ int sys_getpagesize(void); } ogetpagesize
65	COMPAT_25	{ int sys_omsync(caddr_t addr, size_t len); }
d154 1
a154 2
71	COMPAT_43	{ int sys_mmap(caddr_t addr, size_t len, int prot, \
			    int flags, int fd, long pos); } ommap
d174 2
a175 2
84	COMPAT_43	{ int sys_wait(void); } owait
85	COMPAT_25	{ int sys_swapon(const char *name); }
d178 3
a180 5
87	COMPAT_43	{ int sys_gethostname(char *hostname, u_int len); } \
			    ogethostname
88	COMPAT_43	{ int sys_sethostname(char *hostname, u_int len); } \
			    osethostname
89	COMPAT_43	{ int sys_getdtablesize(void); } ogetdtablesize
d192 1
a192 2
99	COMPAT_43	{ int sys_accept(int s, caddr_t name, \
			    int *anamelen); } oaccept
d194 2
a195 4
101	COMPAT_43	{ int sys_send(int s, caddr_t buf, int len, \
			    int flags); } osend
102	COMPAT_43	{ int sys_recv(int s, caddr_t buf, int len, \
			    int flags); } orecv
d203 3
a205 4
108	COMPAT_43	{ int sys_sigvec(int signum, struct sigvec *nsv, \
			    struct sigvec *osv); } osigvec
109	COMPAT_43	{ int sys_sigblock(int mask); } osigblock
110	COMPAT_43	{ int sys_sigsetmask(int mask); } osigsetmask
d207 3
a209 6
112	COMPAT_43	{ int sys_sigstack(struct sigstack *nss, \
			    struct sigstack *oss); } osigstack
113	COMPAT_43	{ int sys_recvmsg(int s, struct omsghdr *msg, \
			    int flags); } orecvmsg
114	COMPAT_43	{ int sys_sendmsg(int s, caddr_t msg, int flags); } \
			    osendmsg
d225 1
a225 3
125	COMPAT_43	{ int sys_recvfrom(int s, caddr_t buf, size_t len, \
			    int flags, caddr_t from, int *fromlenaddr); } \
			    orecvfrom
d229 2
a230 3
129	COMPAT_43	{ int sys_truncate(const char *path, long length); } \
			    otruncate
130	COMPAT_43	{ int sys_ftruncate(int fd, long length); } oftruncate
d246 6
a251 9
141	COMPAT_43	{ int sys_getpeername(int fdes, caddr_t asa, \
			    socklen_t *alen); } ogetpeername
142	COMPAT_43	{ int32_t sys_gethostid(void); } ogethostid
143	COMPAT_43	{ int sys_sethostid(int32_t hostid); } osethostid
144	COMPAT_43	{ int sys_getrlimit(int which, \
			    struct ogetrlimit *rlp); } ogetrlimit
145	COMPAT_43	{ int sys_setrlimit(int which, \
			    struct ogetrlimit *rlp); } osetrlimit
146	COMPAT_43	{ int sys_killpg(int pgid, int signum); } okillpg
d255 2
a256 3
149	COMPAT_43	{ int sys_quota(void); } oquota
150	COMPAT_43	{ int sys_getsockname(int fdec, caddr_t asa, \
			    int *alen); } ogetsockname
d271 3
a273 6
156	COMPAT_43	{ int sys_getdirentries(int fd, char *buf, \
			    int count, long *basep); } ogetdirentries
157	COMPAT_25	{ int sys_statfs(const char *path, \
			    struct ostatfs *buf); } ostatfs
158	COMPAT_25	{ int sys_fstatfs(int fd, struct ostatfs *buf); } \
			    ostatfs
d277 3
a279 5
162	COMPAT_09	{ int sys_getdomainname(char *domainname, int len); } \
			    ogetdomainname
163	COMPAT_09	{ int sys_setdomainname(char *domainname, int len); } \
			    osetdomainname
164	COMPAT_09	{ int sys_uname(struct outsname *name); } ouname
d284 3
a286 21
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
#if defined(SYSVSEM) && !defined(alpha) && !defined(__sparc64__)
169	COMPAT_10	{ int sys_semsys(int which, int a2, int a3, int a4, \
			    int a5); } osemsys
#else
169	UNIMPL		1.0 semsys
#endif
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
#if defined(SYSVMSG) && !defined(alpha) && !defined(__sparc64__)
170	COMPAT_10	{ int sys_msgsys(int which, int a2, int a3, int a4, \
			    int a5, int a6); } omsgsys
#else
170	UNIMPL		1.0 msgsys
#endif
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
#if defined(SYSVSHM) && !defined(alpha) && !defined(__sparc64__)
171	COMPAT_10	{ int sys_shmsys(int which, int a2, int a3, int a4); } \
			    oshmsys
#else
171	UNIMPL		1.0 shmsys
#endif
d375 1
a375 2
220	COMPAT_23	{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); } __osemctl
d377 1
a377 1
222	STD		{ int sys_semop(int semid, struct sembuf *sops, \
d379 1
a379 1
223	OBSOL		sys_semconfig
d387 1
a387 2
224	COMPAT_23	{ int sys_msgctl(int msqid, int cmd, \
			    struct omsqid_ds *buf); } omsgctl
d402 1
a402 2
229	COMPAT_23	{ int sys_shmctl(int shmid, int cmd, \
			    struct oshmid_ds *buf); } oshmctl
d404 1
a404 1
231	STD		{ int sys_shmget(key_t key, int size, int shmflg); }
d525 1
a525 1
285	OBSOL		sys_omquery
d532 11
@


1.4
log
@add fchroot(2)
@
text
@d1 1
a1 1
;	$MirBSD: syscalls.master,v 1.67 2004/01/14 05:23:25 tedu Exp $
a44 1
#include <xfs/xfs_pioctl.h>
d390 1
a390 3
208	STD		{ int sys_xfspioctl(int operation, char *a_pathP, \
			    int a_opcode, struct ViceIoctl *a_paramsP, \
			    int a_followSymlinks); }
@


1.3
log
@clean up after cvs
fix some stuff

in the hope to fully have removed sys_mhint... they implemented
it in the name of sys_mquery *d'oh*
@
text
@d1 2
a2 2
;	$MirBSD: syscalls.master,v 1.2 2003/03/29 19:54:33 tg Exp $
;	$OpenBSD: syscalls.master,v 1.53 2003/04/14 04:53:50 art Exp $
d44 2
d62 1
a62 1
7	STD		{ int sys_wait4(int pid, int *status, int options, \
d136 2
a137 2
53	STD		{ int sys_sigaltstack(const struct sigaltstack *nss, \
			    struct sigaltstack *oss); }
d154 1
a154 1
65	STD		{ int sys_omsync(caddr_t addr, size_t len); }
d182 1
a182 1
85	STD		{ int sys_swapon(const char *name); }
d197 1
a197 1
96	STD		{ int sys_setpriority(int which, int who, int prio); }
d203 1
a203 1
100	STD		{ int sys_getpriority(int which, int who); }
d313 1
a313 1
#if defined(SYSVSEM) && !defined(alpha)
d320 1
a320 1
#if defined(SYSVMSG) && !defined(alpha)
d327 1
a327 1
#if defined(SYSVSHM) && !defined(alpha)
d491 1
a491 1
			    unsigned long nfds, int timeout); }
d530 1
a530 1
			  int pad, off_t offset); }                    
d576 7
a582 2
285	STD		{ int sys_mquery(int flags, void **addr, size_t size, \
			    int fd, off_t off); }
@


1.2
log
@merge elfdiffs.030314
@
text
@d1 2
a2 2
;	$MirBSD$
;	$OpenBSD: syscalls.master,v 1.52 2003/01/30 03:29:49 millert Exp $
d574 1
a574 1
285	STD		{ int sys_mhint(int flags, void **addr, size_t size, \
@


1.1
log
@Initial revision
@
text
@d1 1
d574 2
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source with the "new" command line as well,
in order to be able to provide a MirBSD release which bases
upon a fairly current OpenBSD base source code tree deemed
stable enough.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.53 2003/04/14 04:53:50 art Exp $
a572 2
285	STD		{ int sys_mquery(int flags, void **addr, size_t size, \
			    int fd, off_t off); }
@


1.1.1.3
log
@Import OpenBSD cvs as of now, CTM delta 3255, just before the i386 flag day
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.57 2003/04/29 19:52:32 miod Exp $
d151 1
a151 1
65	COMPAT_25	{ int sys_omsync(caddr_t addr, size_t len); }
d573 2
a574 4
285	STD		{ int sys_omquery(int flags, void **addr, \
			    size_t size, int fd, off_t off); }
286	STD		{ void *sys_mquery(void *addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
@


1.1.1.4
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.58 2003/05/10 17:53:58 miod Exp $
d179 1
a179 1
85	COMPAT_25	{ int sys_swapon(const char *name); }
@


1.1.1.5
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.60 2003/06/23 04:26:53 deraadt Exp $
a42 2
#include <sys/event.h>
#include <xfs/xfs_pioctl.h>
d488 1
a488 1
			    int nfds, int timeout); }
@


1.1.1.6
log
@most important fixes from -current
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.61 2003/07/01 22:18:09 tedu Exp $
d575 2
a576 1
285	OBSOL		sys_omquery
@


1.1.1.7
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.62 2003/09/07 21:00:27 miod Exp $
d312 1
a312 1
#if defined(SYSVSEM) && !defined(alpha) && !defined(__sparc64__)
d319 1
a319 1
#if defined(SYSVMSG) && !defined(alpha) && !defined(__sparc64__)
d326 1
a326 1
#if defined(SYSVSHM) && !defined(alpha) && !defined(__sparc64__)
@


1.1.1.8
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.64 2003/12/11 23:02:30 millert Exp $
d196 1
a196 1
96	STD		{ int sys_setpriority(int which, id_t who, int prio); }
d202 1
a202 1
100	STD		{ int sys_getpriority(int which, id_t who); }
d490 1
a490 1
			    u_int nfds, int timeout); }
@


1.1.1.9
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.65 2003/12/31 00:13:24 millert Exp $
d61 1
a61 1
7	STD		{ pid_t sys_wait4(pid_t pid, int *status, int options, \
@


1.1.1.10
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.67 2004/01/14 05:23:25 tedu Exp $
d135 2
a136 2
53	STD		{ int sys_osigaltstack(const struct osigaltstack *nss, \
			    struct osigaltstack *oss); }
a577 3
287	STD		{ int sys_closefrom(int fd); }			    
288	STD		{ int sys_sigaltstack(const struct sigaltstack *nss, \
			    struct sigaltstack *oss); }
@


1.1.1.11
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.69 2004/05/03 17:38:48 millert Exp $
d311 2
a312 1
#if defined(SYSVSEM) && !defined(__LP64__)
d318 2
a319 1
#if defined(SYSVMSG) && !defined(__LP64__)
d325 2
a326 1
#if defined(SYSVSHM) && !defined(__LP64__)
d425 1
a425 1
222	COMPAT_35	{ int sys_semop(int semid, struct sembuf *sops, \
d454 1
a454 1
231	COMPAT_35	{ int sys_shmget(key_t key, int size, int shmflg); }
a580 11
#ifdef SYSVSHM
289	STD		{ int sys_shmget(key_t key, size_t size, int shmflg); }
#else
289	UNIMPL		shmget
#endif
#ifdef SYSVSEM
290	STD		{ int sys_semop(int semid, struct sembuf *sops, \
			    size_t nsops); }
#else
290    UNIMPL          semop
#endif
@


1.1.1.12
log
@tedu@@cvs.openbsd.org    2004/05/27 14:48:46
make acct(2) optional with ACCOUNTING
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.70 2004/05/27 20:48:46 tedu Exp $
a132 1
#ifdef ACCOUNTING
a133 3
#else
51	UNIMPL		acct
#endif
@


1.1.1.13
log
@millert@@cvs.openbsd.org 2004/07/09 17:52:02
Rename ostat -> stat43 to disambiguate from upcoming struct stat changes.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.71 2004/07/09 23:52:02 millert Exp $
d110 2
a111 2
38	COMPAT_43	{ int sys_stat(const char *path, struct stat43 *ub); } \
			    stat43
d114 1
a114 1
			    struct stat43 *ub); } lstat43
d153 1
a153 1
62	COMPAT_43	{ int sys_fstat(int fd, struct stat43 *sb); } fstat43
@


1.1.1.14
log
@remaining merges:
	millert@@cvs.openbsd.org 2004/07/13 15:04:30
Change mode_t and nlink_t from 16bit to 32bit.

	millert@@cvs.openbsd.org 2004/07/14 12:00:48
fhstat(2) uses struct stat too and so needs replacing as well.

	millert@@cvs.openbsd.org 2004/07/14 17:45:11
Because mode_t is used in struct ipc_perm we need new versions of
the msgctl, semctl, and shmctl system calls.  This moves the old
versions to COMPAT_35 and adds new ones.

	millert@@cvs.openbsd.org 2004/07/15 05:24:46
Rename structs oipc_perm, omsqid_ds, osemid_ds, oshmid_ds to ipc_perm23,
etc to avoid confusion and for consistency with the *35 ones.
Remove *n2o functions that don't belong outside of compat.

	deraadt@@cvs.openbsd.org 2004/07/15 08:35:34
3 functions had inexact types; millert ok
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.76 2004/07/15 14:35:34 deraadt Exp $
d59 1
a59 1
			    int flags, ... mode_t mode); }
d63 1
a63 1
8	COMPAT_43	{ int sys_creat(const char *path, mode_t mode); } ocreat
d69 1
a69 1
14	STD		{ int sys_mknod(const char *path, mode_t mode, \
d71 1
a71 1
15	STD		{ int sys_chmod(const char *path, mode_t mode); }
d102 1
a102 1
			    socklen_t *alen); }
d151 1
a151 1
60	STD		{ mode_t sys_umask(mode_t newmask); }
d243 1
a243 1
124	STD		{ int sys_fchmod(int fd, mode_t mode); }
d254 1
a254 1
132	STD		{ int sys_mkfifo(const char *path, mode_t mode); }
d261 1
a261 1
136	STD		{ int sys_mkdir(const char *path, mode_t mode); }
d362 3
a364 6
188	COMPAT_35	{ int sys_stat(const char *path, struct stat35 *ub); } \
			    stat35
189	COMPAT_35	{ int sys_fstat(int fd, struct stat35 *sb); } \
			    fstat35
190	COMPAT_35	{ int sys_lstat(const char *path, \
			    struct stat35 *ub); } lstat35
d424 1
a424 1
			    union semun *arg); } semctl23
d437 1
a437 1
			    struct omsqid_ds *buf); } msgctl23
d453 1
a453 1
			    struct oshmid_ds *buf); } shmctl23
d497 2
a498 2
257	COMPAT_35	{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); } semctl35
d503 2
a504 2
258	COMPAT_35	{ int sys_shmctl(int shmid, int cmd, \
			    struct shmid_ds35 *buf); } shmctl35
d509 2
a510 2
259	COMPAT_35	{ int sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds35 *buf); } msgctl35
d521 2
a522 2
265	COMPAT_35	{ int sys_fhstat(const fhandle_t *fhp, \
			    struct stat35 *sb); }
d545 1
a545 1
			    const void *data, size_t nbytes); }
d552 1
a552 1
			    const char *attrname, const void *data, \
a591 23
#endif
291	STD		{ int sys_stat(const char *path, struct stat *ub); }
292	STD		{ int sys_fstat(int fd, struct stat *sb); }
293	STD		{ int sys_lstat(const char *path, struct stat *ub); }
294	STD		{ int sys_fhstat(const fhandle_t *fhp, \
			    struct stat *sb); }
#ifdef SYSVSEM
295	STD		{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); }
#else
295	UNIMPL
#endif
#ifdef SYSVSHM
296	STD		{ int sys_shmctl(int shmid, int cmd, \
			    struct shmid_ds *buf); }
#else
296	UNIMPL
#endif
#ifdef SYSVMSG
297	STD		{ int sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds *buf); }
#else
297	UNIMPL
@


