head	1.12;
access;
symbols
	tg-mergetmp-mirosx-1:1.12
	tg-mergefixes-1-branch:1.12.0.4
	tg-mergefixes-1-base:1.12
	MIROS_X:1.12.0.2
	MIROS_X_BASE:1.12
	tg-mergetmp-3:1.12
	MIRBSD_XP_MIRPPC:1.9.0.4
	MIRBSD_XP_SPARC_BASE:1.9
	MIRBSD_XP_SPARC:1.9.0.2
	MIRBSD_7quater:1.1.1.9.2.1
	cvs-200405160640:1.1.1.11
	cvs-200401271800:1.1.1.10
	cvs-200401261630:1.1.1.10
	cvs-200401021645:1.1.1.9
	MIRBSD_7_ALPHA:1.1.1.9.2.1.0.4
	MIRBSD_7:1.1.1.9.2.1.0.2
	cvs-200312222040:1.1.1.9
	MIRBSD_7ter:1.1.1.9.2.1
	MIRBSD_7_DEV:1.1.1.9.0.2
	cvs-200310020700:1.1.1.9
	cvs-200309271030:1.1.1.9
	cvs-200309261655:1.1.1.9
	cvs-200309251530:1.1.1.9
	cvs-200308302005:1.1.1.8
	cvs-200308171200:1.1.1.8
	ctm-3496:1.1.1.7
	ctm-3449:1.1.1.7
	ctm-3437:1.1.1.7
	cvs-200307191805:1.1.1.7
	ctm-3425:1.1.1.6
	cvs-200307091500:1.1.1.6
	cvs-200307072125:1.1.1.6
	ctm-3389:1.1.1.6
	cvs-200307021520:1.1.1.6
	cvs-200306291430:1.1.1.6
	ctm-3341:1.1.1.6
	MIRBSD_5:1.1.1.6
	cvs-200306082100:1.1.1.6
	ctm-3316:1.1.1.6
	ctm-3272:1.1.1.5
	ctm-3264:1.1.1.5
	cvs-200305071630:1.1.1.5
	ctm-3255:1.1.1.4
	ctm-3229:1.1.1.3
	MIRBSD_4:1.4
	ctm-3203:1.1.1.3
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2004.11.14.01.30.14;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.13.23.28.48;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.28.21.22.27;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.23.20.16.29;	author tg;	state Stab;
branches;
next	1.8;

1.8
date	2004.03.10.17.38.52;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.27.17.42.34;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.28.02.58.04;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.05.19.20.47;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.15.20.11.58;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.10.20.12.18;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.52.46;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.51.54;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.51.54;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.52.33;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.04.15.17.44.47;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.05.18.57.09;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.07.17.51.15;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.06.05.17.40.34;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.07.19.18.56.08;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.08.17.14.39.30;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.09.25.16.39.23;	author tg;	state Exp;
branches
	1.1.1.9.2.1;
next	1.1.1.10;

1.1.1.10
date	2004.01.26.18.52.56;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.05.16.09.07.05;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2004.11.13.22.58.00;	author tg;	state Exp;
branches;
next	;

1.1.1.9.2.1
date	2003.10.28.02.56.40;	author tg;	state Exp;
branches;
next	1.1.1.9.2.2;

1.1.1.9.2.2
date	2003.11.30.22.42.56;	author wbx;	state Exp;
branches;
next	;


desc
@@


1.12
log
@kludge: deraadt@@ fixed the proto and const-ified that, but
apparently didn't test build a kernel with UFS_EXTATTR enabled
@
text
@/**	$MirBSD: src/sys/kern/vfs_syscalls.c,v 1.11 2004/11/13 23:28:48 tg Exp $ */
/*	$OpenBSD: vfs_syscalls.c,v 1.114 2004/07/13 21:04:29 millert Exp $	*/
/*	$NetBSD: vfs_syscalls.c,v 1.71 1996/04/23 10:29:02 mycroft Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vfs_syscalls.c	8.28 (Berkeley) 12/10/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/filedesc.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/dirent.h>
#include <sys/extattr.h>

#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>

extern int suid_clear;
int	usermount = 0;		/* sysctl: by default, users may not mount */

static int change_dir(struct nameidata *, struct proc *);

void checkdirs(struct vnode *);

/*
 * Redirection info so we don't have to include the union fs routines in
 * the kernel directly.  This way, we can build unionfs as an LKM.  The
 * pointer gets filled in later, when we modload the LKM, or when the
 * compiled-in unionfs code gets initialized.  For now, we just set
 * it to a stub routine.
 */

int (*union_check_p)(struct proc *, struct vnode **,
    struct file *, struct uio, int *) = NULL;

/*
 * Virtual File System System Calls
 */

/*
 * Mount a file system.
 */
/* ARGSUSED */
int
sys_mount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_mount_args /* {
		syscallarg(const char *) type;
		syscallarg(const char *) path;
		syscallarg(int) flags;
		syscallarg(void *) data;
	} */ *uap = v;
	struct vnode *vp;
	struct mount *mp;
	int error, flag = 0;
#ifdef COMPAT_43
	u_long fstypenum = 0;
#endif
	char fstypename[MFSNAMELEN];
	char fspath[MNAMELEN];
	struct vattr va;
	struct nameidata nd;
	struct vfsconf *vfsp;
	struct timeval tv;

	if (usermount == 0 && (error = suser(p, 0)))
		return (error);

	/*
	 * Mount points must fit in MNAMELEN, not MAXPATHLEN.
	 */
	error = copyinstr(SCARG(uap, path), fspath, MNAMELEN, NULL);
	if (error)
		return(error);

	/*
	 * Get vnode to be covered
	 */
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_SYSSPACE, fspath, p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (SCARG(uap, flags) & MNT_UPDATE) {
		if ((vp->v_flag & VROOT) == 0) {
			vput(vp);
			return (EINVAL);
		}
		mp = vp->v_mount;
		flag = mp->mnt_flag;
		/*
		 * We only allow the filesystem to be reloaded if it
		 * is currently mounted read-only.
		 */
		if ((SCARG(uap, flags) & MNT_RELOAD) &&
		    ((mp->mnt_flag & MNT_RDONLY) == 0)) {
			vput(vp);
			return (EOPNOTSUPP);	/* Needs translation */
		}
		mp->mnt_flag |=
		    SCARG(uap, flags) & (MNT_RELOAD | MNT_UPDATE);
		/*
		 * Only root, or the user that did the original mount is
		 * permitted to update it.
		 */
		if (mp->mnt_stat.f_owner != p->p_ucred->cr_uid &&
		    (error = suser(p, 0))) {
			vput(vp);
			return (error);
		}
		/*
		 * Do not allow NFS export by non-root users. Silently
		 * enforce MNT_NOSUID and MNT_NODEV for non-root users, and
		 * inherit MNT_NOEXEC from the mount point.
		 */
		if (p->p_ucred->cr_uid != 0) {
			if (SCARG(uap, flags) & MNT_EXPORTED) {
				vput(vp);
				return (EPERM);
			}
			SCARG(uap, flags) |= MNT_NOSUID | MNT_NODEV;
			if (flag & MNT_NOEXEC)
				SCARG(uap, flags) |= MNT_NOEXEC;
		}
		if ((error = vfs_busy(mp, LK_NOWAIT, 0, p)) != 0) {
			vput(vp);
			return (error);
		}
		VOP_UNLOCK(vp, 0, p);
		goto update;
	}
	/*
	 * If the user is not root, ensure that they own the directory
	 * onto which we are attempting to mount.
	 */
	if ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) ||
	    (va.va_uid != p->p_ucred->cr_uid &&
	    (error = suser(p, 0)))) {
		vput(vp);
		return (error);
	}
	/*
	 * Do not allow NFS export by non-root users. Silently
	 * enforce MNT_NOSUID and MNT_NODEV for non-root users, and inherit
	 * MNT_NOEXEC from the mount point.
	 */
	if (p->p_ucred->cr_uid != 0) {
		if (SCARG(uap, flags) & MNT_EXPORTED) {
			vput(vp);
			return (EPERM);
		}
		SCARG(uap, flags) |= MNT_NOSUID | MNT_NODEV;
		if (vp->v_mount->mnt_flag & MNT_NOEXEC)
			SCARG(uap, flags) |= MNT_NOEXEC;
	}
	if ((error = vinvalbuf(vp, V_SAVE, p->p_ucred, p, 0, 0)) != 0)
		return (error);
	if (vp->v_type != VDIR) {
		vput(vp);
		return (ENOTDIR);
	}
	error = copyinstr(SCARG(uap, type), fstypename, MFSNAMELEN, NULL);
	if (error) {
#ifdef COMPAT_43
		/*
		 * Historically filesystem types were identified by number.
		 * If we get an integer for the filesystem type instead of a
		 * string, we check to see if it matches one of the historic
		 * filesystem types.
		 */
		fstypenum = (u_long)SCARG(uap, type);

		for (vfsp = vfsconf; vfsp; vfsp = vfsp->vfc_next)
			if (vfsp->vfc_typenum == fstypenum)
				break;
		if (vfsp == NULL) {
			vput(vp);
			return (ENODEV);
		}
		strncpy(fstypename, vfsp->vfc_name, MFSNAMELEN);

#else
		vput(vp);
		return (error);
#endif
	}
	for (vfsp = vfsconf; vfsp; vfsp = vfsp->vfc_next) {
		if (!strcmp(vfsp->vfc_name, fstypename))
			break;
	}

	if (vfsp == NULL) {
		vput(vp);
		return (EOPNOTSUPP);
	}

	if (vp->v_mountedhere != NULL) {
		vput(vp);
		return (EBUSY);
	}

	/*
	 * Allocate and initialize the file system.
	 */
	mp = (struct mount *)malloc((u_long)sizeof(struct mount),
		M_MOUNT, M_WAITOK);
	bzero((char *)mp, (u_long)sizeof(struct mount));
	lockinit(&mp->mnt_lock, PVFS, "vfslock", 0, 0);
	/* This error never happens, but it makes auditing easier */
	if ((error = vfs_busy(mp, LK_NOWAIT, 0, p)))
		return (error);
	mp->mnt_op = vfsp->vfc_vfsops;
	mp->mnt_vfc = vfsp;
	mp->mnt_flag |= (vfsp->vfc_flags & MNT_VISFLAGMASK);
	strncpy(mp->mnt_stat.f_fstypename, vfsp->vfc_name, MFSNAMELEN);
	mp->mnt_vnodecovered = vp;
	mp->mnt_stat.f_owner = p->p_ucred->cr_uid;
update:
	/*
	 * Set the mount level flags.
	 */
	if (SCARG(uap, flags) & MNT_RDONLY)
		mp->mnt_flag |= MNT_RDONLY;
	else if (mp->mnt_flag & MNT_RDONLY)
		mp->mnt_flag |= MNT_WANTRDWR;
	mp->mnt_flag &=~ (MNT_NOSUID | MNT_NOEXEC | MNT_NODEV |
	    MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC | MNT_SOFTDEP |
	    MNT_NOATIME | MNT_FORCE);
	mp->mnt_flag |= SCARG(uap, flags) & (MNT_NOSUID | MNT_NOEXEC |
	    MNT_NODEV | MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC |
	    MNT_SOFTDEP | MNT_NOATIME | MNT_FORCE);
	/*
	 * Mount the filesystem.
	 */
	error = VFS_MOUNT(mp, SCARG(uap, path), SCARG(uap, data), &nd, p);
	if (!error) {
		microtime(&tv);
		mp->mnt_stat.f_ctime = tv.tv_sec;
	}
	if (mp->mnt_flag & MNT_UPDATE) {
		vrele(vp);
		if (mp->mnt_flag & MNT_WANTRDWR)
			mp->mnt_flag &= ~MNT_RDONLY;
		mp->mnt_flag &=~
		    (MNT_UPDATE | MNT_RELOAD | MNT_FORCE | MNT_WANTRDWR);
		if (error)
			mp->mnt_flag = flag;

		if ((mp->mnt_flag & MNT_RDONLY) == 0) {
			if (mp->mnt_syncer == NULL)
				error = vfs_allocate_syncvnode(mp);
		} else {
			if (mp->mnt_syncer != NULL)
				vgone(mp->mnt_syncer);
			mp->mnt_syncer = NULL;
		}

		vfs_unbusy(mp, p);
		return (error);
	}

	vp->v_mountedhere = mp;

	/*
	 * Put the new filesystem on the mount list after root.
	 */
	cache_purge(vp);
	if (!error) {
		vfsp->vfc_refcount++;
		simple_lock(&mountlist_slock);
		CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
		simple_unlock(&mountlist_slock);
		checkdirs(vp);
		VOP_UNLOCK(vp, 0, p);
		if ((mp->mnt_flag & MNT_RDONLY) == 0)
			error = vfs_allocate_syncvnode(mp);
		vfs_unbusy(mp, p);
		(void) VFS_STATFS(mp, &mp->mnt_stat, p);
		if ((error = VFS_START(mp, 0, p)) != 0)
			vrele(vp);
	} else {
		mp->mnt_vnodecovered->v_mountedhere = (struct mount *)0;
		vfs_unbusy(mp, p);
		free(mp, M_MOUNT);
		vput(vp);
	}
	return (error);
}

/*
 * Scan all active processes to see if any of them have a current
 * or root directory onto which the new filesystem has just been
 * mounted. If so, replace them with the new mount point.
 */
void
checkdirs(olddp)
	struct vnode *olddp;
{
	struct filedesc *fdp;
	struct vnode *newdp;
	struct proc *p;

	if (olddp->v_usecount == 1)
		return;
	if (VFS_ROOT(olddp->v_mountedhere, &newdp))
		panic("mount: lost mount");
	for (p = LIST_FIRST(&allproc); p != 0; p = LIST_NEXT(p, p_list)) {
		fdp = p->p_fd;
		if (fdp->fd_cdir == olddp) {
			vrele(fdp->fd_cdir);
			VREF(newdp);
			fdp->fd_cdir = newdp;
		}
		if (fdp->fd_rdir == olddp) {
			vrele(fdp->fd_rdir);
			VREF(newdp);
			fdp->fd_rdir = newdp;
		}
	}
	if (rootvnode == olddp) {
		vrele(rootvnode);
		VREF(newdp);
		rootvnode = newdp;
	}
	vput(newdp);
}

/*
 * Unmount a file system.
 *
 * Note: unmount takes a path to the vnode mounted on as argument,
 * not special file (as before).
 */
/* ARGSUSED */
int
sys_unmount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_unmount_args /* {
		syscallarg(const char *) path;
		syscallarg(int) flags;
	} */ *uap = v;
	struct vnode *vp;
	struct mount *mp;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	mp = vp->v_mount;

	/*
	 * Only root, or the user that did the original mount is
	 * permitted to unmount this filesystem.
	 */
	if ((mp->mnt_stat.f_owner != p->p_ucred->cr_uid) &&
	    (error = suser(p, 0))) {
		vput(vp);
		return (error);
	}

	/*
	 * Don't allow unmounting the root file system.
	 */
	if (mp->mnt_flag & MNT_ROOTFS) {
		vput(vp);
		return (EINVAL);
	}

	/*
	 * Must be the root of the filesystem
	 */
	if ((vp->v_flag & VROOT) == 0) {
		vput(vp);
		return (EINVAL);
	}
	vput(vp);

	if (vfs_busy(mp, LK_EXCLUSIVE, NULL, p))
		return (EBUSY);

	return (dounmount(mp, SCARG(uap, flags), p, vp));
}

/*
 * Do the actual file system unmount.
 */
int
dounmount(struct mount *mp, int flags, struct proc *p, struct vnode *olddp)
{
	struct vnode *coveredvp;
	struct proc *p2;
	int error;
	int hadsyncer = 0;

	mp->mnt_flag &=~ MNT_ASYNC;
	cache_purgevfs(mp);	/* remove cache entries for this file sys */
	if (mp->mnt_syncer != NULL) {
		hadsyncer = 1;
		vgone(mp->mnt_syncer);
		mp->mnt_syncer = NULL;
	}
	if (((mp->mnt_flag & MNT_RDONLY) ||
	    (error = VFS_SYNC(mp, MNT_WAIT, p->p_ucred, p)) == 0) ||
	    (flags & MNT_FORCE))
		error = VFS_UNMOUNT(mp, flags, p);
	simple_lock(&mountlist_slock);
	if (error) {
		if ((mp->mnt_flag & MNT_RDONLY) == 0 && hadsyncer)
			(void) vfs_allocate_syncvnode(mp);
		lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK,
		    &mountlist_slock, p);
		return (error);
	}
	CIRCLEQ_REMOVE(&mountlist, mp, mnt_list);
	if ((coveredvp = mp->mnt_vnodecovered) != NULLVP) {
		if (olddp) {
			/*
			 * Try to put processes back in a real directory
			 * after a forced unmount.
			 * XXX We're not holding a ref on olddp, which may
			 * change, so compare id numbers.
			 */
			LIST_FOREACH(p2, &allproc, p_list) {
				struct filedesc *fdp = p2->p_fd;
				if (fdp->fd_cdir &&
				    fdp->fd_cdir->v_id == olddp->v_id) {
					vrele(fdp->fd_cdir);
					vref(coveredvp);
					fdp->fd_cdir = coveredvp;
				}
				if (fdp->fd_rdir &&
				    fdp->fd_rdir->v_id == olddp->v_id) {
					vrele(fdp->fd_rdir);
					vref(coveredvp);
					fdp->fd_rdir = coveredvp;
				}
			}
		}
		coveredvp->v_mountedhere = NULL;
		vrele(coveredvp);
	}
	mp->mnt_vfc->vfc_refcount--;
	if (mp->mnt_vnodelist.lh_first != NULL)
		panic("unmount: dangling vnode");
	lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK, &mountlist_slock, p);
	free(mp, M_MOUNT);
	return (0);
}

/*
 * Sync each mounted filesystem.
 */
#ifdef DEBUG
int syncprt = 0;
struct ctldebug debug0 = { "syncprt", &syncprt };
#endif

/* ARGSUSED */
int
sys_sync(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct mount *mp, *nmp;
	int asyncflag;

	simple_lock(&mountlist_slock);
	for (mp = CIRCLEQ_LAST(&mountlist); mp != CIRCLEQ_END(&mountlist);
	    mp = nmp) {
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock, p)) {
			nmp = CIRCLEQ_PREV(mp, mnt_list);
			continue;
		}
		if ((mp->mnt_flag & MNT_RDONLY) == 0) {
			asyncflag = mp->mnt_flag & MNT_ASYNC;
			mp->mnt_flag &= ~MNT_ASYNC;
			uvm_vnp_sync(mp);
			VFS_SYNC(mp, MNT_NOWAIT, p->p_ucred, p);
			if (asyncflag)
				mp->mnt_flag |= MNT_ASYNC;
		}
		simple_lock(&mountlist_slock);
		nmp = CIRCLEQ_PREV(mp, mnt_list);
		vfs_unbusy(mp, p);
	}
	simple_unlock(&mountlist_slock);

#ifdef DEBUG
	if (syncprt)
		vfs_bufstats();
#endif /* DEBUG */
	return (0);
}

/*
 * Change filesystem quotas.
 */
/* ARGSUSED */
int
sys_quotactl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_quotactl_args /* {
		syscallarg(const char *) path;
		syscallarg(int) cmd;
		syscallarg(int) uid;
		syscallarg(char *) arg;
	} */ *uap = v;
	struct mount *mp;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	mp = nd.ni_vp->v_mount;
	vrele(nd.ni_vp);
	return (VFS_QUOTACTL(mp, SCARG(uap, cmd), SCARG(uap, uid),
	    SCARG(uap, arg), p));
}

/*
 * Get filesystem statistics.
 */
/* ARGSUSED */
int
sys_statfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_statfs_args /* {
		syscallarg(const char *) path;
		syscallarg(struct statfs *) buf;
	} */ *uap = v;
	struct mount *mp;
	struct statfs *sp;
	int error;
	struct nameidata nd;
	struct statfs sb;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	mp = nd.ni_vp->v_mount;
	sp = &mp->mnt_stat;
	vrele(nd.ni_vp);
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
#if notyet
	if (mp->mnt_flag & MNT_SOFTDEP)
		sp->f_eflags = STATFS_SOFTUPD;
#endif
	/* Don't let non-root see filesystem id (for NFS security) */
	if (suser(p, 0)) {
		bcopy(sp, &sb, sizeof(sb));
		sb.f_fsid.val[0] = sb.f_fsid.val[1] = 0;
		sp = &sb;
	}
	return (copyout(sp, SCARG(uap, buf), sizeof(*sp)));
}

/*
 * Get filesystem statistics.
 */
/* ARGSUSED */
int
sys_fstatfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_fstatfs_args /* {
		syscallarg(int) fd;
		syscallarg(struct statfs *) buf;
	} */ *uap = v;
	struct file *fp;
	struct mount *mp;
	struct statfs *sp;
	int error;
	struct statfs sb;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	mp = ((struct vnode *)fp->f_data)->v_mount;
	if (!mp) {
		FRELE(fp);
		return (ENOENT);
	}
	sp = &mp->mnt_stat;
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
#if notyet
	if (mp->mnt_flag & MNT_SOFTDEP)
		sp->f_eflags = STATFS_SOFTUPD;
#endif
	/* Don't let non-root see filesystem id (for NFS security) */
	if (suser(p, 0)) {
		bcopy(sp, &sb, sizeof(sb));
		sb.f_fsid.val[0] = sb.f_fsid.val[1] = 0;
		sp = &sb;
	}
	return (copyout(sp, SCARG(uap, buf), sizeof(*sp)));
}

/*
 * Get statistics on all filesystems.
 */
int
sys_getfsstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_getfsstat_args /* {
		syscallarg(struct statfs *) buf;
		syscallarg(size_t) bufsize;
		syscallarg(int) flags;
	} */ *uap = v;
	struct mount *mp, *nmp;
	struct statfs *sp;
	struct statfs sb;
	struct statfs *sfsp;
	size_t count, maxcount;
	int error, flags = SCARG(uap, flags);

	maxcount = SCARG(uap, bufsize) / sizeof(struct statfs);
	sfsp = SCARG(uap, buf);
	count = 0;
	simple_lock(&mountlist_slock);
	for (mp = CIRCLEQ_FIRST(&mountlist); mp != CIRCLEQ_END(&mountlist);
	    mp = nmp) {
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock, p)) {
			nmp = CIRCLEQ_NEXT(mp, mnt_list);
			continue;
		}
		if (sfsp && count < maxcount) {
			sp = &mp->mnt_stat;

			/* Refresh stats unless MNT_NOWAIT is specified */
			if (flags != MNT_NOWAIT &&
			    flags != MNT_LAZY &&
			    (flags == MNT_WAIT ||
			    flags == 0) &&
			    (error = VFS_STATFS(mp, sp, p))) {
				simple_lock(&mountlist_slock);
				nmp = CIRCLEQ_NEXT(mp, mnt_list);
				vfs_unbusy(mp, p);
				continue;
			}

			sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
#if notyet
			if (mp->mnt_flag & MNT_SOFTDEP)
				sp->f_eflags = STATFS_SOFTUPD;
#endif
			if (suser(p, 0)) {
				bcopy(sp, &sb, sizeof(sb));
				sb.f_fsid.val[0] = sb.f_fsid.val[1] = 0;
				sp = &sb;
			}
			error = copyout(sp, sfsp, sizeof(*sp));
			if (error) {
				vfs_unbusy(mp, p);
				return (error);
			}
			sfsp++;
		}
		count++;
		simple_lock(&mountlist_slock);
		nmp = CIRCLEQ_NEXT(mp, mnt_list);
		vfs_unbusy(mp, p);
	}
	simple_unlock(&mountlist_slock);
	if (sfsp && count > maxcount)
		*retval = maxcount;
	else
		*retval = count;
	return (0);
}

/*
 * Change current working directory to a given file descriptor.
 */
/* ARGSUSED */
int
sys_fchdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_fchdir_args /* {
		syscallarg(int) fd;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct vnode *vp, *tdp;
	struct mount *mp;
	struct file *fp;
	int error;

	if ((error = getvnode(fdp, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = (struct vnode *)fp->f_data;
	VREF(vp);
	FRELE(fp);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_type != VDIR)
		error = ENOTDIR;
	else
		error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p);

	while (!error && (mp = vp->v_mountedhere) != NULL) {
		if (vfs_busy(mp, 0, 0, p))
			continue;
		error = VFS_ROOT(mp, &tdp);
		vfs_unbusy(mp, p);
		if (error)
			break;
		vput(vp);
		vp = tdp;
	}
	if (error) {
		vput(vp);
		return (error);
	}
	VOP_UNLOCK(vp, 0, p);
	vrele(fdp->fd_cdir);
	fdp->fd_cdir = vp;
	return (0);
}

/*
 * Change current working directory (".").
 */
/* ARGSUSED */
int
sys_chdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_chdir_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = change_dir(&nd, p)) != 0)
		return (error);
	vrele(fdp->fd_cdir);
	fdp->fd_cdir = nd.ni_vp;
	return (0);
}

/*
 * Change notion of root ("/") directory.
 */
/* ARGSUSED */
int
sys_chroot(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_chroot_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	int error;
	struct nameidata nd;

	if ((error = suser(p, 0)) != 0)
		return (error);
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = change_dir(&nd, p)) != 0)
		return (error);
	if (fdp->fd_rdir != NULL) {
		/*
		 * A chroot() done inside a changed root environment does
		 * an automatic chdir to avoid the out-of-tree experience.
		 */
		vrele(fdp->fd_rdir);
		vrele(fdp->fd_cdir);
		VREF(nd.ni_vp);
		fdp->fd_cdir = nd.ni_vp;
	}
	fdp->fd_rdir = nd.ni_vp;
	return (0);
}

/*
 * Change notion of root (``/'') directory to a file descriptor.
 */
int
sys_fchroot(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_fchroot_args *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct vnode *vp;
	struct file *fp;
	int error;

	if ((error = suser(p, 0)) != 0)
		return (error);
	if ((error = getvnode(fdp, SCARG(uap, fd), &fp)) != 0)
		return (error);

	vp = (struct vnode *)fp->f_data;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	if (vp->v_type != VDIR)
		error = ENOTDIR;
	else
		error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p);

	VOP_UNLOCK(vp, 0, p);

	if (error)
		return (error);

	VREF(vp);

	if (fdp->fd_rdir != NULL) {
		/*
		 * A chroot() done inside a changed root environment does
		 * an automatic chdir to avoid the out-of-tree experience.
		 */
		vrele(fdp->fd_rdir);
		vrele(fdp->fd_cdir);
		VREF(vp);
		fdp->fd_cdir = vp;
	}

	fdp->fd_rdir = vp;
	return (0);
}

/*
 * Common routine for chroot and chdir.
 */
static int
change_dir(ndp, p)
	struct nameidata *ndp;
	struct proc *p;
{
	struct vnode *vp;
	int error;

	if ((error = namei(ndp)) != 0)
		return (error);
	vp = ndp->ni_vp;
	if (vp->v_type != VDIR)
		error = ENOTDIR;
	else
		error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p);
	if (error)
		vput(vp);
	else
		VOP_UNLOCK(vp, 0, p);
	return (error);
}

/*
 * Check permissions, allocate an open file structure,
 * and call the device open routine if any.
 */
int
sys_open(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_open_args /* {
		syscallarg(const char *) path;
		syscallarg(int) flags;
		syscallarg(mode_t) mode;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	struct vattr vattr;
	int flags, cmode;
	int type, indx, error, localtrunc = 0;
	struct flock lf;
	struct nameidata nd;

	fdplock(fdp, p);

	if ((error = falloc(p, &fp, &indx)) != 0)
		goto out;

	flags = FFLAGS(SCARG(uap, flags));
	cmode = ((SCARG(uap, mode) &~ fdp->fd_cmask) & ALLPERMS) &~ S_ISTXT;
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	p->p_dupfd = -indx - 1;			/* XXX check for fdopen */
	if ((flags & O_TRUNC) && (flags & (O_EXLOCK | O_SHLOCK))) {
		localtrunc = 1;
		flags &= ~O_TRUNC;	/* Must do truncate ourselves */
	}
	if ((error = vn_open(&nd, flags, cmode)) != 0) {
		if ((error == ENODEV || error == ENXIO) &&
		    p->p_dupfd >= 0 &&			/* XXX from fdopen */
		    (error =
			dupfdopen(fdp, indx, p->p_dupfd, flags, error)) == 0) {
			closef(fp, p);
			*retval = indx;
			goto out;
		}
		if (error == ERESTART)
			error = EINTR;
		fdremove(fdp, indx);
		closef(fp, p);
		goto out;
	}
	p->p_dupfd = 0;
	vp = nd.ni_vp;
	fp->f_flag = flags & FMASK;
	fp->f_type = DTYPE_VNODE;
	fp->f_ops = &vnops;
	fp->f_data = vp;
	if (flags & (O_EXLOCK | O_SHLOCK)) {
		lf.l_whence = SEEK_SET;
		lf.l_start = 0;
		lf.l_len = 0;
		if (flags & O_EXLOCK)
			lf.l_type = F_WRLCK;
		else
			lf.l_type = F_RDLCK;
		type = F_FLOCK;
		if ((flags & FNONBLOCK) == 0)
			type |= F_WAIT;
		VOP_UNLOCK(vp, 0, p);
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, type);
		if (error) {
			/* closef will vn_close the file for us. */
			fdremove(fdp, indx);
			closef(fp, p);
			goto out;
		}
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
		fp->f_flag |= FHASLOCK;
	}
	if (localtrunc) {
		VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
		if ((fp->f_flag & FWRITE) == 0)
			error = EACCES;
		else if (vp->v_mount->mnt_flag & MNT_RDONLY)
			error = EROFS;
		else if (vp->v_type == VDIR)
			error = EISDIR;
		else if ((error = vn_writechk(vp)) == 0) {
			VATTR_NULL(&vattr);
			vattr.va_size = 0;
			error = VOP_SETATTR(vp, &vattr, fp->f_cred, p);
		}
		if (error) {
			VOP_UNLOCK(vp, 0, p);
			/* closef will close the file for us. */
			fdremove(fdp, indx);
			closef(fp, p);
			goto out;
		}
	}
	VOP_UNLOCK(vp, 0, p);
	*retval = indx;
	FILE_SET_MATURE(fp);
out:
	fdpunlock(fdp);
	return (error);
}

/*
 * Get file handle system call
 */
int
sys_getfh(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_getfh_args /* {
		syscallarg(const char *) fname;
		syscallarg(fhandle_t *) fhp;
	} */ *uap = v;
	struct vnode *vp;
	fhandle_t fh;
	int error;
	struct nameidata nd;

	/*
	 * Must be super user
	 */
	error = suser(p, 0);
	if (error)
		return (error);
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, fname), p);
	error = namei(&nd);
	if (error)
		return (error);
	vp = nd.ni_vp;
	bzero(&fh, sizeof(fh));
	fh.fh_fsid = vp->v_mount->mnt_stat.f_fsid;
	error = VFS_VPTOFH(vp, &fh.fh_fid);
	vput(vp);
	if (error)
		return (error);
	error = copyout(&fh, SCARG(uap, fhp), sizeof(fh));
	return (error);
}

/*
 * Open a file given a file handle.
 *
 * Check permissions, allocate an open file structure,
 * and call the device open routine if any.
 */
int
sys_fhopen(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_fhopen_args /* {
		syscallarg(const fhandle_t *) fhp;
		syscallarg(int) flags;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp = NULL;
	struct mount *mp;
	struct ucred *cred = p->p_ucred;
	int flags;
	int type, indx, error=0;
	struct flock lf;
	struct vattr va;
	fhandle_t fh;

	/*
	 * Must be super user
	 */
	if ((error = suser(p, 0)))
		return (error);

	flags = FFLAGS(SCARG(uap, flags));
	if ((flags & (FREAD | FWRITE)) == 0)
		return (EINVAL);
	if ((flags & O_CREAT))
		return (EINVAL);

	fdplock(fdp, p);
	if ((error = falloc(p, &fp, &indx)) != 0) {
		fp = NULL;
		goto bad;
	}

	if ((error = copyin(SCARG(uap, fhp), &fh, sizeof(fhandle_t))) != 0)
		goto bad;

	if ((mp = vfs_getvfs(&fh.fh_fsid)) == NULL) {
		error = ESTALE;
		goto bad;
	}

	if ((error = VFS_FHTOVP(mp, &fh.fh_fid, &vp)) != 0) {
		vp = NULL;	/* most likely unnecessary sanity for bad: */
		goto bad;
	}

	/* Now do an effective vn_open */

	if (vp->v_type == VSOCK) {
		error = EOPNOTSUPP;
		goto bad;
	}
	if (flags & FREAD) {
		if ((error = VOP_ACCESS(vp, VREAD, cred, p)) != 0)
			goto bad;
	}
	if (flags & (FWRITE | O_TRUNC)) {
		if (vp->v_type == VDIR) {
			error = EISDIR;
			goto bad;
		}
		if ((error = vn_writechk(vp)) != 0 ||
		    (error = VOP_ACCESS(vp, VWRITE, cred, p)) != 0)
			goto bad;
	}
	if (flags & O_TRUNC) {
		VOP_UNLOCK(vp, 0, p);				/* XXX */
		VOP_LEASE(vp, p, cred, LEASE_WRITE);
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);	/* XXX */
		VATTR_NULL(&va);
		va.va_size = 0;
		if ((error = VOP_SETATTR(vp, &va, cred, p)) != 0)
			goto bad;
	}
	if ((error = VOP_OPEN(vp, flags, cred, p)) != 0)
		goto bad;
	if (flags & FWRITE)
		vp->v_writecount++;

	/* done with modified vn_open, now finish what sys_open does. */

	fp->f_flag = flags & FMASK;
	fp->f_type = DTYPE_VNODE;
	fp->f_ops = &vnops;
	fp->f_data = vp;
	if (flags & (O_EXLOCK | O_SHLOCK)) {
		lf.l_whence = SEEK_SET;
		lf.l_start = 0;
		lf.l_len = 0;
		if (flags & O_EXLOCK)
			lf.l_type = F_WRLCK;
		else
			lf.l_type = F_RDLCK;
		type = F_FLOCK;
		if ((flags & FNONBLOCK) == 0)
			type |= F_WAIT;
		VOP_UNLOCK(vp, 0, p);
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, type);
		if (error) {
			/* closef will vn_close the file for us. */
			fdremove(fdp, indx);
			closef(fp, p);
			return (error);
		}
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
		fp->f_flag |= FHASLOCK;
	}
	VOP_UNLOCK(vp, 0, p);
	*retval = indx;
	FILE_SET_MATURE(fp);

	fdpunlock(fdp);
	return (0);

bad:
	if (fp) {
		fdremove(fdp, indx);
		closef(fp, p);
		if (vp != NULL)
			vput(vp);
	}
	fdpunlock(fdp);
	return (error);
}

/* ARGSUSED */
int
sys_fhstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_fhstat_args /* {
		syscallarg(const fhandle_t *) fhp;
		syscallarg(struct stat *) sb;
	} */ *uap = v;
	struct stat sb;
	int error;
	fhandle_t fh;
	struct mount *mp;
	struct vnode *vp;

	/*
	 * Must be super user
	 */
	if ((error = suser(p, 0)))
		return (error);

	if ((error = copyin(SCARG(uap, fhp), &fh, sizeof(fhandle_t))) != 0)
		return (error);

	if ((mp = vfs_getvfs(&fh.fh_fsid)) == NULL)
		return (ESTALE);
	if ((error = VFS_FHTOVP(mp, &fh.fh_fid, &vp)))
		return (error);
	error = vn_stat(vp, &sb, p);
	vput(vp);
	if (error)
		return (error);
	error = copyout(&sb, SCARG(uap, sb), sizeof(sb));
	return (error);
}

/* ARGSUSED */
int
sys_fhstatfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_fhstatfs_args /*
		syscallarg(const fhandle_t *) fhp;
		syscallarg(struct statfs *) buf;
	} */ *uap = v;
	struct statfs sp;
	fhandle_t fh;
	struct mount *mp;
	struct vnode *vp;
	int error;

	/*
	 * Must be super user
	 */
	if ((error = suser(p, 0)))
		return (error);

	if ((error = copyin(SCARG(uap, fhp), &fh, sizeof(fhandle_t))) != 0)
		return (error);

	if ((mp = vfs_getvfs(&fh.fh_fsid)) == NULL)
		return (ESTALE);
	if ((error = VFS_FHTOVP(mp, &fh.fh_fid, &vp)))
		return (error);
	mp = vp->v_mount;
	vput(vp);
	if ((error = VFS_STATFS(mp, &sp, p)) != 0)
		return (error);
	sp.f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	return (copyout(&sp, SCARG(uap, buf), sizeof(sp)));
}

/*
 * Create a special file.
 */
/* ARGSUSED */
int
sys_mknod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_mknod_args /* {
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
		syscallarg(int) dev;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	int whiteout = 0;
	struct nameidata nd;

	if ((error = suser(p, 0)) != 0)
		return (error);
#ifdef	HARD_CHROOT
	if (p->p_fd->fd_rdir)
		return (EINVAL);
#endif
	NDINIT(&nd, CREATE, LOCKPARENT, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (vp != NULL)
		error = EEXIST;
	else {
		VATTR_NULL(&vattr);
		vattr.va_mode = (SCARG(uap, mode) & ALLPERMS) &~ p->p_fd->fd_cmask;
		vattr.va_rdev = SCARG(uap, dev);
		whiteout = 0;

		switch (SCARG(uap, mode) & S_IFMT) {
		case S_IFMT:	/* used by badsect to flag bad sectors */
			vattr.va_type = VBAD;
			break;
		case S_IFCHR:
			vattr.va_type = VCHR;
			break;
		case S_IFBLK:
			vattr.va_type = VBLK;
			break;
		case S_IFWHT:
			whiteout = 1;
			break;
		default:
			error = EINVAL;
			break;
		}
	}
	if (!error) {
		VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
		if (whiteout) {
			error = VOP_WHITEOUT(nd.ni_dvp, &nd.ni_cnd, CREATE);
			if (error)
				VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
			vput(nd.ni_dvp);
		} else {
			error = VOP_MKNOD(nd.ni_dvp, &nd.ni_vp,
						&nd.ni_cnd, &vattr);
		}
	} else {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		if (vp)
			vrele(vp);
	}
	return (error);
}

/*
 * Create a named pipe.
 */
/* ARGSUSED */
int
sys_mkfifo(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#ifndef FIFO
	return (EOPNOTSUPP);
#else
	struct sys_mkfifo_args /* {
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
	} */ *uap = v;
	struct vattr vattr;
	int error;
	struct nameidata nd;

	NDINIT(&nd, CREATE, LOCKPARENT, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	if (nd.ni_vp != NULL) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vrele(nd.ni_vp);
		return (EEXIST);
	}
	VATTR_NULL(&vattr);
	vattr.va_type = VFIFO;
	vattr.va_mode = (SCARG(uap, mode) & ALLPERMS) &~ p->p_fd->fd_cmask;
	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
	return (VOP_MKNOD(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &vattr));
#endif /* FIFO */
}

/*
 * Make a hard file link.
 */
/* ARGSUSED */
int
sys_link(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_link_args /* {
		syscallarg(const char *) path;
		syscallarg(const char *) link;
	} */ *uap = v;
	struct vnode *vp;
	struct nameidata nd;
	int error;
	int flags;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;

	flags = LOCKPARENT;
	if (vp->v_type == VDIR) {
		flags |= STRIPSLASHES;
	}

	NDINIT(&nd, CREATE, flags, UIO_USERSPACE, SCARG(uap, link), p);
	if ((error = namei(&nd)) != 0)
		goto out;
	if (nd.ni_vp) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vrele(nd.ni_vp);
		error = EEXIST;
		goto out;
	}
	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	error = VOP_LINK(nd.ni_dvp, vp, &nd.ni_cnd);
out:
	vrele(vp);
	return (error);
}

/*
 * Make a symbolic link.
 */
/* ARGSUSED */
int
sys_symlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_symlink_args /* {
		syscallarg(const char *) path;
		syscallarg(const char *) link;
	} */ *uap = v;
	struct vattr vattr;
	char *path;
	int error;
	struct nameidata nd;

	path = pool_get(&namei_pool, PR_WAITOK);
	error = copyinstr(SCARG(uap, path), path, MAXPATHLEN, NULL);
	if (error)
		goto out;
	NDINIT(&nd, CREATE, LOCKPARENT, UIO_USERSPACE, SCARG(uap, link), p);
	if ((error = namei(&nd)) != 0)
		goto out;
	if (nd.ni_vp) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vrele(nd.ni_vp);
		error = EEXIST;
		goto out;
	}
	VATTR_NULL(&vattr);
	vattr.va_mode = ACCESSPERMS &~ p->p_fd->fd_cmask;
	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
	error = VOP_SYMLINK(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &vattr, path);
out:
	pool_put(&namei_pool, path);
	return (error);
}

/*
 * Delete a whiteout from the filesystem.
 */
/* ARGSUSED */
int
sys_undelete(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_undelete_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;
	int error;
	struct nameidata nd;

	NDINIT(&nd, DELETE, LOCKPARENT|DOWHITEOUT, UIO_USERSPACE,
	    SCARG(uap, path), p);
	error = namei(&nd);
	if (error)
		return (error);

	if (nd.ni_vp != NULLVP || !(nd.ni_cnd.cn_flags & ISWHITEOUT)) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		if (nd.ni_vp)
			vrele(nd.ni_vp);
		return (EEXIST);
	}

	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
	if ((error = VOP_WHITEOUT(nd.ni_dvp, &nd.ni_cnd, DELETE)) != 0)
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
	vput(nd.ni_dvp);
	return (error);
}

/*
 * Delete a name from the filesystem.
 */
/* ARGSUSED */
int
sys_unlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_unlink_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;
	struct vnode *vp;
	int error;
	struct nameidata nd;

	NDINIT(&nd, DELETE, LOCKPARENT | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;

	/*
	 * The root of a mounted filesystem cannot be deleted.
	 */
	if (vp->v_flag & VROOT) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vput(vp);
		error = EBUSY;
		goto out;
	}

	(void)uvm_vnp_uncache(vp);

	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	error = VOP_REMOVE(nd.ni_dvp, nd.ni_vp, &nd.ni_cnd);
out:
	return (error);
}

/*
 * Reposition read/write file offset.
 */
int
sys_lseek(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_lseek_args /* {
		syscallarg(int) fd;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
		syscallarg(int) whence;
	} */ *uap = v;
	struct ucred *cred = p->p_ucred;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vattr vattr;
	struct vnode *vp;
	int error, special;

	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);
	if (fp->f_type != DTYPE_VNODE)
		return (ESPIPE);
	vp = (struct vnode *)fp->f_data;
	if (vp->v_type == VFIFO)
		return (ESPIPE);
	if (vp->v_type == VCHR)
		special = 1;
	else
		special = 0;
	switch (SCARG(uap, whence)) {
	case SEEK_CUR:
		if (!special && fp->f_offset + SCARG(uap, offset) < 0)
			return (EINVAL);
		fp->f_offset += SCARG(uap, offset);
		break;
	case SEEK_END:
		error = VOP_GETATTR((struct vnode *)fp->f_data, &vattr,
				    cred, p);
		if (error)
			return (error);
		if (!special && (off_t)vattr.va_size + SCARG(uap, offset) < 0)
			return (EINVAL);
		fp->f_offset = SCARG(uap, offset) + vattr.va_size;
		break;
	case SEEK_SET:
		if (!special && SCARG(uap, offset) < 0)
			return (EINVAL);
		fp->f_offset = SCARG(uap, offset);
		break;
	default:
		return (EINVAL);
	}
	*(off_t *)retval = fp->f_offset;
	return (0);
}

/*
 * Check access permissions.
 */
int
sys_access(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_access_args /* {
		syscallarg(const char *) path;
		syscallarg(int) flags;
	} */ *uap = v;
	struct ucred *cred = p->p_ucred;
	struct vnode *vp;
	int error, flags, t_gid, t_uid;
	struct nameidata nd;

	if (SCARG(uap, flags) & ~(R_OK | W_OK | X_OK))
		return (EINVAL);
	t_uid = cred->cr_uid;
	t_gid = cred->cr_gid;
	cred->cr_uid = p->p_cred->p_ruid;
	cred->cr_gid = p->p_cred->p_rgid;
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		goto out1;
	vp = nd.ni_vp;

	/* Flags == 0 means only check for existence. */
	if (SCARG(uap, flags)) {
		flags = 0;
		if (SCARG(uap, flags) & R_OK)
			flags |= VREAD;
		if (SCARG(uap, flags) & W_OK)
			flags |= VWRITE;
		if (SCARG(uap, flags) & X_OK)
			flags |= VEXEC;
		if ((flags & VWRITE) == 0 || (error = vn_writechk(vp)) == 0)
			error = VOP_ACCESS(vp, flags, cred, p);
	}
	vput(vp);
out1:
	cred->cr_uid = t_uid;
	cred->cr_gid = t_gid;
	return (error);
}

/*
 * Get file status; this version follows links.
 */
/* ARGSUSED */
int
sys_stat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_stat_args /* {
		syscallarg(const char *) path;
		syscallarg(struct stat *) ub;
	} */ *uap = v;
	struct stat sb;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	error = vn_stat(nd.ni_vp, &sb, p);
	vput(nd.ni_vp);
	if (error)
		return (error);
	/* Don't let non-root see generation numbers (for NFS security) */
	if (suser(p, 0))
		sb.st_gen = 0;
	error = copyout(&sb, SCARG(uap, ub), sizeof(sb));
	return (error);
}

/*
 * Get file status; this version does not follow links.
 */
/* ARGSUSED */
int
sys_lstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_lstat_args /* {
		syscallarg(const char *) path;
		syscallarg(struct stat *) ub;
	} */ *uap = v;
	struct stat sb;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, NOFOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	error = vn_stat(nd.ni_vp, &sb, p);
	vput(nd.ni_vp);
	if (error)
		return (error);
	/* Don't let non-root see generation numbers (for NFS security) */
	if (suser(p, 0))
		sb.st_gen = 0;
	error = copyout(&sb, SCARG(uap, ub), sizeof(sb));
	return (error);
}

/*
 * Get configurable pathname variables.
 */
/* ARGSUSED */
int
sys_pathconf(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_pathconf_args /* {
		syscallarg(const char *) path;
		syscallarg(int) name;
	} */ *uap = v;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	error = VOP_PATHCONF(nd.ni_vp, SCARG(uap, name), retval);
	vput(nd.ni_vp);
	return (error);
}

/*
 * Return target name of a symbolic link.
 */
/* ARGSUSED */
int
sys_readlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_readlink_args /* {
		syscallarg(const char *) path;
		syscallarg(char *) buf;
		syscallarg(size_t) count;
	} */ *uap = v;
	struct vnode *vp;
	struct iovec aiov;
	struct uio auio;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, NOFOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (vp->v_type != VLNK)
		error = EINVAL;
	else {
		aiov.iov_base = SCARG(uap, buf);
		aiov.iov_len = SCARG(uap, count);
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_offset = 0;
		auio.uio_rw = UIO_READ;
		auio.uio_segflg = UIO_USERSPACE;
		auio.uio_procp = p;
		auio.uio_resid = SCARG(uap, count);
		error = VOP_READLINK(vp, &auio, p->p_ucred);
	}
	vput(vp);
	*retval = SCARG(uap, count) - auio.uio_resid;
	return (error);
}

/*
 * Change flags of a file given a path name.
 */
/* ARGSUSED */
int
sys_chflags(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_chflags_args /* {
		syscallarg(const char *) path;
		syscallarg(u_int) flags;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else if (SCARG(uap, flags) == VNOVAL)
		error = EINVAL;
	else {
		if (suser(p, 0)) {
			if ((error = VOP_GETATTR(vp, &vattr, p->p_ucred, p)) != 0)
				goto out;
			if (vattr.va_type == VCHR || vattr.va_type == VBLK) {
				error = EINVAL;
				goto out;
			}
		}
		VATTR_NULL(&vattr);
		vattr.va_flags = SCARG(uap, flags);
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
out:
	vput(vp);
	return (error);
}

/*
 * Change flags of a file given a file descriptor.
 */
/* ARGSUSED */
int
sys_fchflags(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_fchflags_args /* {
		syscallarg(int) fd;
		syscallarg(u_int) flags;
	} */ *uap = v;
	struct vattr vattr;
	struct vnode *vp;
	struct file *fp;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = (struct vnode *)fp->f_data;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else if (SCARG(uap, flags) == VNOVAL)
		error = EINVAL;
	else {
		if (suser(p, 0)) {
			if ((error = VOP_GETATTR(vp, &vattr, p->p_ucred, p))
			    != 0)
				goto out;
			if (vattr.va_type == VCHR || vattr.va_type == VBLK) {
				error = EINVAL;
				goto out;
			}
		}
		VATTR_NULL(&vattr);
		vattr.va_flags = SCARG(uap, flags);
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
out:
	VOP_UNLOCK(vp, 0, p);
	FRELE(fp);
	return (error);
}

/*
 * Change mode of a file given path name.
 */
/* ARGSUSED */
int
sys_chmod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_chmod_args /* {
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;

	if (SCARG(uap, mode) & ~(S_IFMT | ALLPERMS))
		return (EINVAL);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		VATTR_NULL(&vattr);
		vattr.va_mode = SCARG(uap, mode) & ALLPERMS;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
	vput(vp);
	return (error);
}

/*
 * Change mode of a file given a file descriptor.
 */
/* ARGSUSED */
int
sys_fchmod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_fchmod_args /* {
		syscallarg(int) fd;
		syscallarg(mode_t) mode;
	} */ *uap = v;
	struct vattr vattr;
	struct vnode *vp;
	struct file *fp;
	int error;

	if (SCARG(uap, mode) & ~(S_IFMT | ALLPERMS))
		return (EINVAL);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = (struct vnode *)fp->f_data;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		VATTR_NULL(&vattr);
		vattr.va_mode = SCARG(uap, mode) & ALLPERMS;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
	VOP_UNLOCK(vp, 0, p);
	FRELE(fp);
	return (error);
}

/*
 * Set ownership given a path name.
 */
/* ARGSUSED */
int
sys_chown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_chown_args /* {
		syscallarg(const char *) path;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;
	mode_t mode;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		if ((SCARG(uap, uid) != -1 || SCARG(uap, gid) != -1) &&
		    (suser(p, 0) || suid_clear)) {
			error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
			if (error)
				goto out;
			mode = vattr.va_mode & ~(VSUID | VSGID);
			if (mode == vattr.va_mode)
				mode = VNOVAL;
		}
		else
			mode = VNOVAL;
		VATTR_NULL(&vattr);
		vattr.va_uid = SCARG(uap, uid);
		vattr.va_gid = SCARG(uap, gid);
		vattr.va_mode = mode;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
out:
	vput(vp);
	return (error);
}

/*
 * Set ownership given a path name, without following links.
 */
/* ARGSUSED */
int
sys_lchown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_lchown_args /* {
		syscallarg(const char *) path;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;
	mode_t mode;

	NDINIT(&nd, LOOKUP, NOFOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		if ((SCARG(uap, uid) != -1 || SCARG(uap, gid) != -1) &&
		    (suser(p, 0) || suid_clear)) {
			error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
			if (error)
				goto out;
			mode = vattr.va_mode & ~(VSUID | VSGID);
			if (mode == vattr.va_mode)
				mode = VNOVAL;
		}
		else
			mode = VNOVAL;
		VATTR_NULL(&vattr);
		vattr.va_uid = SCARG(uap, uid);
		vattr.va_gid = SCARG(uap, gid);
		vattr.va_mode = mode;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
out:
	vput(vp);
	return (error);
}

/*
 * Set ownership given a file descriptor.
 */
/* ARGSUSED */
int
sys_fchown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_fchown_args /* {
		syscallarg(int) fd;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct file *fp;
	mode_t mode;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = (struct vnode *)fp->f_data;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		if ((SCARG(uap, uid) != -1 || SCARG(uap, gid) != -1) &&
		    (suser(p, 0) || suid_clear)) {
			error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
			if (error)
				goto out;
			mode = vattr.va_mode & ~(VSUID | VSGID);
			if (mode == vattr.va_mode)
				mode = VNOVAL;
		} else
			mode = VNOVAL;
		VATTR_NULL(&vattr);
		vattr.va_uid = SCARG(uap, uid);
		vattr.va_gid = SCARG(uap, gid);
		vattr.va_mode = mode;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
out:
	VOP_UNLOCK(vp, 0, p);
	FRELE(fp);
	return (error);
}

/*
 * Set the access and modification times given a path name.
 */
/* ARGSUSED */
int
sys_utimes(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_utimes_args /* {
		syscallarg(const char *) path;
		syscallarg(const struct timeval *) tptr;
	} */ *uap = v;
	struct vnode *vp;
	struct timeval tv[2];
	struct vattr vattr;
	int error;
	struct nameidata nd;

	VATTR_NULL(&vattr);
	if (SCARG(uap, tptr) == NULL) {
		microtime(&tv[0]);
		tv[1] = tv[0];
		vattr.va_vaflags |= VA_UTIMES_NULL;
	} else {
		error = copyin(SCARG(uap, tptr), tv,
		    sizeof(tv));
		if (error)
			return (error);
		/* XXX workaround timeval matching the VFS constant VNOVAL */
		if (tv[0].tv_sec == VNOVAL)
			tv[0].tv_sec = VNOVAL - 1;
		if (tv[1].tv_sec == VNOVAL)
			tv[1].tv_sec = VNOVAL - 1;
	}
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		vattr.va_atime.tv_sec = tv[0].tv_sec;
		vattr.va_atime.tv_nsec = tv[0].tv_usec * 1000;
		vattr.va_mtime.tv_sec = tv[1].tv_sec;
		vattr.va_mtime.tv_nsec = tv[1].tv_usec * 1000;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
	vput(vp);
	return (error);
}


/*
 * Set the access and modification times given a file descriptor.
 */
/* ARGSUSED */
int
sys_futimes(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_futimes_args /* {
		syscallarg(int) fd;
		syscallarg(const struct timeval *) tptr;
	} */ *uap = v;
	struct vnode *vp;
	struct timeval tv[2];
	struct vattr vattr;
	int error;
	struct file *fp;

	VATTR_NULL(&vattr);
	if (SCARG(uap, tptr) == NULL) {
		microtime(&tv[0]);
		tv[1] = tv[0];
		vattr.va_vaflags |= VA_UTIMES_NULL;
	} else {
		error = copyin(SCARG(uap, tptr), tv,
		    sizeof(tv));
		if (error)
			return (error);
		/* XXX workaround timeval matching the VFS constant VNOVAL */
		if (tv[0].tv_sec == VNOVAL)
			tv[0].tv_sec = VNOVAL - 1;
		if (tv[1].tv_sec == VNOVAL)
			tv[1].tv_sec = VNOVAL - 1;
	}
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = (struct vnode *)fp->f_data;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		vattr.va_atime.tv_sec = tv[0].tv_sec;
		vattr.va_atime.tv_nsec = tv[0].tv_usec * 1000;
		vattr.va_mtime.tv_sec = tv[1].tv_sec;
		vattr.va_mtime.tv_nsec = tv[1].tv_usec * 1000;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
	VOP_UNLOCK(vp, 0, p);
	FRELE(fp);
	return (error);
}

/*
 * Truncate a file given its path name.
 */
/* ARGSUSED */
int
sys_truncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_truncate_args /* {
		syscallarg(const char *) path;
		syscallarg(int) pad;
		syscallarg(off_t) length;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_type == VDIR)
		error = EISDIR;
	else if ((error = vn_writechk(vp)) == 0 &&
	    (error = VOP_ACCESS(vp, VWRITE, p->p_ucred, p)) == 0) {
		VATTR_NULL(&vattr);
		vattr.va_size = SCARG(uap, length);
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
	vput(vp);
	return (error);
}

/*
 * Truncate a file given a file descriptor.
 */
/* ARGSUSED */
int
sys_ftruncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_ftruncate_args /* {
		syscallarg(int) fd;
		syscallarg(int) pad;
		syscallarg(off_t) length;
	} */ *uap = v;
	struct vattr vattr;
	struct vnode *vp;
	struct file *fp;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	if ((fp->f_flag & FWRITE) == 0) {
		error = EINVAL;
		goto bad;
	}
	vp = (struct vnode *)fp->f_data;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_type == VDIR)
		error = EISDIR;
	else if ((error = vn_writechk(vp)) == 0) {
		VATTR_NULL(&vattr);
		vattr.va_size = SCARG(uap, length);
		error = VOP_SETATTR(vp, &vattr, fp->f_cred, p);
	}
	VOP_UNLOCK(vp, 0, p);
bad:
	FRELE(fp);
	return (error);
}

/*
 * Sync an open file.
 */
/* ARGSUSED */
int
sys_fsync(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_fsync_args /* {
		syscallarg(int) fd;
	} */ *uap = v;
	struct vnode *vp;
	struct file *fp;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = (struct vnode *)fp->f_data;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	error = VOP_FSYNC(vp, fp->f_cred, MNT_WAIT, p);
#ifdef FFS_SOFTUPDATES
	if (error == 0 && vp->v_mount && (vp->v_mount->mnt_flag & MNT_SOFTDEP))
		error = softdep_fsync(vp);
#endif

	VOP_UNLOCK(vp, 0, p);
	FRELE(fp);
	return (error);
}

/*
 * Rename files.  Source and destination must either both be directories,
 * or both not be directories.  If target is a directory, it must be empty.
 */
/* ARGSUSED */
int
sys_rename(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_rename_args /* {
		syscallarg(const char *) from;
		syscallarg(const char *) to;
	} */ *uap = v;
	struct vnode *tvp, *fvp, *tdvp;
	struct nameidata fromnd, tond;
	int error;
	int flags;

	NDINIT(&fromnd, DELETE, WANTPARENT | SAVESTART, UIO_USERSPACE,
	    SCARG(uap, from), p);
	if ((error = namei(&fromnd)) != 0)
		return (error);
	fvp = fromnd.ni_vp;

	flags = LOCKPARENT | LOCKLEAF | NOCACHE | SAVESTART;
	/*
	 * rename("foo/", "bar/");  is  OK
	 */
	if (fvp->v_type == VDIR)
		flags |= STRIPSLASHES;

	NDINIT(&tond, RENAME, flags,
	    UIO_USERSPACE, SCARG(uap, to), p);
	if ((error = namei(&tond)) != 0) {
		VOP_ABORTOP(fromnd.ni_dvp, &fromnd.ni_cnd);
		vrele(fromnd.ni_dvp);
		vrele(fvp);
		goto out1;
	}
	tdvp = tond.ni_dvp;
	tvp = tond.ni_vp;
	if (tvp != NULL) {
		if (fvp->v_type == VDIR && tvp->v_type != VDIR) {
			error = ENOTDIR;
			goto out;
		} else if (fvp->v_type != VDIR && tvp->v_type == VDIR) {
			error = EISDIR;
			goto out;
		}
	}
	if (fvp == tdvp)
		error = EINVAL;
	/*
	 * If source is the same as the destination (that is the
	 * same inode number)
	 */
	if (fvp == tvp)
		error = -1;
out:
	if (!error) {
		VOP_LEASE(tdvp, p, p->p_ucred, LEASE_WRITE);
		if (fromnd.ni_dvp != tdvp)
			VOP_LEASE(fromnd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
		if (tvp) {
			(void)uvm_vnp_uncache(tvp);
			VOP_LEASE(tvp, p, p->p_ucred, LEASE_WRITE);
		}
		error = VOP_RENAME(fromnd.ni_dvp, fromnd.ni_vp, &fromnd.ni_cnd,
				   tond.ni_dvp, tond.ni_vp, &tond.ni_cnd);
	} else {
		VOP_ABORTOP(tond.ni_dvp, &tond.ni_cnd);
		if (tdvp == tvp)
			vrele(tdvp);
		else
			vput(tdvp);
		if (tvp)
			vput(tvp);
		VOP_ABORTOP(fromnd.ni_dvp, &fromnd.ni_cnd);
		vrele(fromnd.ni_dvp);
		vrele(fvp);
	}
	vrele(tond.ni_startdir);
	pool_put(&namei_pool, tond.ni_cnd.cn_pnbuf);
out1:
	if (fromnd.ni_startdir)
		vrele(fromnd.ni_startdir);
	pool_put(&namei_pool, fromnd.ni_cnd.cn_pnbuf);
	if (error == -1)
		return (0);
	return (error);
}

/*
 * Make a directory file.
 */
/* ARGSUSED */
int
sys_mkdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_mkdir_args /* {
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;

	NDINIT(&nd, CREATE, LOCKPARENT | STRIPSLASHES,
	    UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (vp != NULL) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vrele(vp);
		return (EEXIST);
	}
	VATTR_NULL(&vattr);
	vattr.va_type = VDIR;
	vattr.va_mode = (SCARG(uap, mode) & ACCESSPERMS) &~ p->p_fd->fd_cmask;
	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
	error = VOP_MKDIR(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &vattr);
	if (!error)
		vput(nd.ni_vp);
	return (error);
}

/*
 * Remove a directory file.
 */
/* ARGSUSED */
int
sys_rmdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_rmdir_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;
	struct vnode *vp;
	int error;
	struct nameidata nd;

	NDINIT(&nd, DELETE, LOCKPARENT | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (vp->v_type != VDIR) {
		error = ENOTDIR;
		goto out;
	}
	/*
	 * No rmdir "." please.
	 */
	if (nd.ni_dvp == vp) {
		error = EBUSY;
		goto out;
	}
	/*
	 * The root of a mounted filesystem cannot be deleted.
	 */
	if (vp->v_flag & VROOT)
		error = EBUSY;
out:
	if (!error) {
		VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
		VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
		error = VOP_RMDIR(nd.ni_dvp, nd.ni_vp, &nd.ni_cnd);
	} else {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vput(vp);
	}
	return (error);
}

/*
 * Read a block of directory entries in a file system independent format.
 */
int
sys_getdirentries(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_getdirentries_args /* {
		syscallarg(int) fd;
		syscallarg(char *) buf;
		syscallarg(int) count;
		syscallarg(long *) basep;
	} */ *uap = v;
	struct vnode *vp;
	struct file *fp;
	struct uio auio;
	struct iovec aiov;
	long loff;
	int error, eofflag;

	if (SCARG(uap, count) < 0)
		return EINVAL;
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	if ((fp->f_flag & FREAD) == 0) {
		error = EBADF;
		goto bad;
	}
	vp = (struct vnode *)fp->f_data;
unionread:
	if (vp->v_type != VDIR) {
		error = EINVAL;
		goto bad;
	}
	aiov.iov_base = SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, count);
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;
	auio.uio_resid = SCARG(uap, count);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	loff = auio.uio_offset = fp->f_offset;
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, 0, 0);
	fp->f_offset = auio.uio_offset;
	VOP_UNLOCK(vp, 0, p);
	if (error)
		goto bad;
	if ((SCARG(uap, count) == auio.uio_resid) &&
	    union_check_p &&
	    (union_check_p(p, &vp, fp, auio, &error) != 0))
		goto unionread;
	if (error)
		goto bad;

	if ((SCARG(uap, count) == auio.uio_resid) &&
	    (vp->v_flag & VROOT) &&
	    (vp->v_mount->mnt_flag & MNT_UNION)) {
		struct vnode *tvp = vp;
		vp = vp->v_mount->mnt_vnodecovered;
		VREF(vp);
		fp->f_data = vp;
		fp->f_offset = 0;
		vrele(tvp);
		goto unionread;
	}
	error = copyout(&loff, SCARG(uap, basep),
	    sizeof(long));
	*retval = SCARG(uap, count) - auio.uio_resid;
bad:
	FRELE(fp);
	return (error);
}

/*
 * Set the mode mask for creation of filesystem nodes.
 */
int
sys_umask(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_umask_args /* {
		syscallarg(mode_t) newmask;
	} */ *uap = v;
	struct filedesc *fdp;

	fdp = p->p_fd;
	*retval = fdp->fd_cmask;
	fdp->fd_cmask = SCARG(uap, newmask) & ACCESSPERMS;
	return (0);
}

/*
 * Void all references to file by ripping underlying filesystem
 * away from vnode.
 */
/* ARGSUSED */
int
sys_revoke(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_revoke_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if ((error = VOP_GETATTR(vp, &vattr, p->p_ucred, p)) != 0)
		goto out;
	if (p->p_ucred->cr_uid != vattr.va_uid &&
	    (error = suser(p, 0)))
		goto out;
	if (vp->v_usecount > 1 || (vp->v_flag & (VALIASED | VLAYER)))
		VOP_REVOKE(vp, REVOKEALL);
out:
	vrele(vp);
	return (error);
}

/*
 * Convert a user file descriptor to a kernel file entry.
 *
 * On return *fpp is FREF:ed.
 */
int
getvnode(fdp, fd, fpp)
	struct filedesc *fdp;
	struct file **fpp;
	int fd;
{
	struct file *fp;

	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if (fp->f_type != DTYPE_VNODE)
		return (EINVAL);
	FREF(fp);
	*fpp = fp;

	return (0);
}

/*
 * Positional read system call.
 */
int
sys_pread(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_pread_args /* {
		syscallarg(int) fd;
		syscallarg(void *) buf;
		syscallarg(size_t) nbyte;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	off_t offset;
	int fd = SCARG(uap, fd);

	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FREAD) == 0)
		return (EBADF);

	vp = (struct vnode *)fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
		return (ESPIPE);
	}

	offset = SCARG(uap, offset);

	FREF(fp);

	/* dofileread() will FRELE the descriptor for us */
	return (dofileread(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &offset, retval));
}

/*
 * Positional scatter read system call.
 */
int
sys_preadv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_preadv_args /* {
		syscallarg(int) fd;
		syscallarg(const struct iovec *) iovp;
		syscallarg(int) iovcnt;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	off_t offset;
	int fd = SCARG(uap, fd);

	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FREAD) == 0)
		return (EBADF);

	vp = (struct vnode *)fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
		return (ESPIPE);
	}

	FREF(fp);

	offset = SCARG(uap, offset);

	/* dofilereadv() will FRELE the descriptor for us */
	return (dofilereadv(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
	    &offset, retval));
}

/*
 * Positional write system call.
 */
int
sys_pwrite(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_pwrite_args /* {
		syscallarg(int) fd;
		syscallarg(const void *) buf;
		syscallarg(size_t) nbyte;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	off_t offset;
	int fd = SCARG(uap, fd);

	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FWRITE) == 0)
		return (EBADF);

	vp = (struct vnode *)fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
		return (ESPIPE);
	}

	FREF(fp);

	offset = SCARG(uap, offset);

	/* dofilewrite() will FRELE the descriptor for us */
	return (dofilewrite(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &offset, retval));
}


/*
 * Positional gather write system call.
 */
int
sys_pwritev(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_pwritev_args /* {
		syscallarg(int) fd;
		syscallarg(const struct iovec *) iovp;
		syscallarg(int) iovcnt;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	off_t offset;
	int fd = SCARG(uap, fd);

	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FWRITE) == 0)
		return (EBADF);

	vp = (struct vnode *)fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
		return (ESPIPE);
	}

	FREF(fp);

	offset = SCARG(uap, offset);

	/* dofilewritev() will FRELE the descriptor for us */
	return (dofilewritev(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
	    &offset, retval));
}

#ifdef UFS_EXTATTR
/*
 * Syscall to push extended attribute configuration information into the
 * VFS.  Accepts a path, which it converts to a mountpoint, as well as
 * a command (int cmd), and attribute name and misc data.  For now, the
 * attribute name is left in userspace for consumption by the VFS_op.
 * It will probably be changed to be copied into sysspace by the
 * syscall in the future, once issues with various consumers of the
 * attribute code have raised their hands.
 *
 * Currently this is used only by UFS Extended Attributes.
 */
int
sys_extattrctl(struct proc *p, void *v, register_t *reval)
{
	struct sys_extattrctl_args /* {
		syscallarg(const char *) path;
		syscallarg(int) cmd;
		syscallarg(const char *) filename;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v;
	struct vnode *filename_vp;
	struct nameidata nd;
	struct mount *mp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	/*
	 * SCARG(uap, attrname) not always defined.  We check again later
	 * when we invoke the VFS call so as to pass in NULL there if needed.
	 */
	if (SCARG(uap, attrname) != NULL) {
		error = copyinstr(SCARG(uap, attrname), attrname,
		    EXTATTR_MAXNAMELEN, NULL);
		if (error)
			return (error);
	}

	/*
	 * SCARG(uap, filename) not always defined.  If it is, grab
	 * a vnode lock, which VFS_EXTATTRCTL() will later release.
	 */
	filename_vp = NULL;
	if (SCARG(uap, filename) != NULL) {
		NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
		    SCARG(uap, filename), p);
		if ((error = namei(&nd)) != 0)
			return (error);
		filename_vp = nd.ni_vp;
	}

	/* SCARG(uap, path) always defined. */
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0) {
		if (filename_vp != NULL)
			vput(filename_vp);
		return (error);
	}

	mp = nd.ni_vp->v_mount;
	if (error) {
		if (filename_vp != NULL)
			vput(filename_vp);
		return (error);
	}

	if (SCARG(uap, attrname) != NULL) {
		error = VFS_EXTATTRCTL(mp, SCARG(uap, cmd), filename_vp,
		    SCARG(uap, attrnamespace), attrname, p);
	} else {
		error = VFS_EXTATTRCTL(mp, SCARG(uap, cmd), filename_vp,
		    SCARG(uap, attrnamespace), NULL, p);
	}

	/*
	 * VFS_EXTATTRCTL will have unlocked, but not de-ref'd,
	 * filename_vp, so vrele it if it is defined.
	 */
	if (filename_vp != NULL)
		vrele(filename_vp);

	return (error);
}

/*-
 * Set a named extended attribute on a file or directory
 *
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", userspace buffer
 *            pointer "data", buffer length "nbytes", thread "td".
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_set_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    void *data, size_t nbytes, struct proc *p, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	ssize_t cnt;
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	aiov.iov_base = data;
	aiov.iov_len = nbytes;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_offset = 0;
	if (nbytes > INT_MAX) {
		error = EINVAL;
		goto done;
	}
	auio.uio_resid = nbytes;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;
	cnt = nbytes;

	error = VOP_SETEXTATTR(vp, attrnamespace, attrname, &auio,
	    p->p_ucred, p);
	cnt -= auio.uio_resid;
	retval[0] = cnt;

done:
	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_set_file(struct proc *p, void *v, register_t *retval)
{
	struct sys_extattr_set_file_args /* {
		syscallarg(const char *) path;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);

	error = extattr_set_vp(nd.ni_vp, SCARG(uap, attrnamespace), attrname,
	    (void *)SCARG(uap, data), SCARG(uap, nbytes), p, retval);

	vrele(nd.ni_vp);
	return (error);
}

int
sys_extattr_set_fd(struct proc *p, void *v, register_t *retval)
{
	struct sys_extattr_set_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	error = extattr_set_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, (void *)SCARG(uap, data),
	    SCARG(uap, nbytes), p, retval);
	FRELE(fp);

	return (error);
}

/*-
 * Get a named extended attribute on a file or directory
 *
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", userspace buffer
 *            pointer "data", buffer length "nbytes", thread "td".
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_get_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    void *data, size_t nbytes, struct proc *p, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	ssize_t cnt;
	size_t size;
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_READ);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	/*
	 * Slightly unusual semantics: if the user provides a NULL data
	 * pointer, they don't want to receive the data, just the
	 * maximum read length.
	 */
	if (data != NULL) {
		aiov.iov_base = data;
		aiov.iov_len = nbytes;
		auio.uio_iov = &aiov;
		auio.uio_offset = 0;
		if (nbytes > INT_MAX) {
			error = EINVAL;
			goto done;
		}
		auio.uio_resid = nbytes;
		auio.uio_rw = UIO_READ;
		auio.uio_segflg = UIO_USERSPACE;
		auio.uio_procp = p;
		cnt = nbytes;
		error = VOP_GETEXTATTR(vp, attrnamespace, attrname, &auio,
		    NULL, p->p_ucred, p);
		cnt -= auio.uio_resid;
		retval[0] = cnt;
	} else {
		error = VOP_GETEXTATTR(vp, attrnamespace, attrname, NULL,
		    &size, p->p_ucred, p);
		retval[0] = size;
	}
done:
	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_get_file(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_get_file_args /* {
		syscallarg(const char *) path;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);

	error = extattr_get_vp(nd.ni_vp, SCARG(uap, attrnamespace), attrname,
	    SCARG(uap, data), SCARG(uap, nbytes), p, retval);

	vrele(nd.ni_vp);
	return (error);
}

int
sys_extattr_get_fd(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_get_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	error = extattr_get_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, SCARG(uap, data),
	    SCARG(uap, nbytes), p, retval);
	FRELE(fp);

	return (error);
}

/*
 * extattr_delete_vp(): Delete a named extended attribute on a file or
 *                      directory
 *
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", proc "p"
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_delete_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    struct proc *p)
{
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	error = VOP_SETEXTATTR(vp, attrnamespace, attrname, NULL,
	    p->p_ucred, p);

	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_delete_file(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_delete_file_args /* {
		syscallarg(const char *) path;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return(error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return(error);

	error = extattr_delete_vp(nd.ni_vp, SCARG(uap, attrnamespace),
	    attrname, p);

	vrele(nd.ni_vp);
	return(error);
}

int
sys_extattr_delete_fd(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_delete_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v;
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	error = extattr_delete_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, p);
	FRELE(fp);

	return (error);
}
#endif
@


1.11
log
@merge stat and *_t changes
@
text
@d1 1
a1 1
/**	$MirBSD: src/sys/kern/vfs_syscalls.c,v 1.10 2004/10/28 21:22:27 tg Exp $ */
d3057 1
a3057 1
	    SCARG(uap, data), SCARG(uap, nbytes), p, retval);
d3086 1
a3086 1
	    SCARG(uap, attrnamespace), attrname, SCARG(uap, data),
@


1.10
log
@fhstat(2), security, compile fixes, kill register
@
text
@d1 2
a2 2
/**	$MirBSD$ */
/*	$OpenBSD: vfs_syscalls.c,v 1.111 2004/05/14 04:00:33 tedu Exp $	*/
d942 1
a942 1
		syscallarg(int) mode;
d1303 1
a1303 1
		syscallarg(int) mode;
d1386 1
a1386 1
		syscallarg(int) mode;
d1946 1
a1946 1
		syscallarg(int) mode;
d1985 1
a1985 1
		syscallarg(int) mode;
d2031 1
a2031 1
	u_short mode;
d2083 1
a2083 1
	u_short mode;
d2135 1
a2135 1
	u_short mode;
d2496 1
a2496 1
		syscallarg(int) mode;
d2668 1
a2668 1
		syscallarg(int) newmask;
@


1.9
log
@* first futile attempt to merge OpenBSD 3.5-current
* damn! they got pxeboot! -> disable for now
  (there's still ports/sysutils/pxegrub; we'll have pxeboot later)
* I don't know if that ... bootloader still works
* nuke netbsd emul (was unused anyways)
* nuke a plethora of syscalls not being used, and mark
  the other two (COMPAT_35) for deletion RSN
* merge new MI-GENERIC into i386 GENERIC
* resolve numeric conflicts for
  - syscalls
  - sysctls
  - device majors
  - pcidevs
* (c) cleanup - no need to add a bsd-like licence when
  there's already one; just add my name
* and much more
@
text
@d1 1
a1 1
/*	$MirBSD: src/sys/kern/vfs_syscalls.c,v 1.8 2004/03/10 17:38:52 tg Exp $	*/
d26 1
a26 1
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS" AND
d94 1
a94 1
	register struct sys_mount_args /* {
d100 2
a101 2
	register struct vnode *vp;
	register struct mount *mp;
d387 1
a387 1
	register struct sys_unmount_args /* {
d391 1
a391 1
	register struct vnode *vp;
d517 1
a517 1
	register struct mount *mp, *nmp;
d558 1
a558 1
	register struct sys_quotactl_args /* {
d564 1
a564 1
	register struct mount *mp;
d587 1
a587 1
	register struct sys_statfs_args /* {
d591 2
a592 2
	register struct mount *mp;
	register struct statfs *sp;
d674 1
a674 1
	register struct sys_getfsstat_args /* {
d679 2
a680 2
	register struct mount *mp, *nmp;
	register struct statfs *sp;
d804 1
a804 1
	register struct filedesc *fdp = p->p_fd;
d830 1
a830 1
	register struct filedesc *fdp = p->p_fd;
d871 2
a872 2
	 if ((error = getvnode(fdp, SCARG(uap, fd), &fp)) != 0)
		 return (error);
d874 2
a875 2
	 vp = (struct vnode *)fp->f_data;
	 vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d877 4
a880 4
	 if (vp->v_type != VDIR)
		 error = ENOTDIR;
	 else
		 error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p);
d882 1
a882 1
	 VOP_UNLOCK(vp, 0, p);
d884 1
a884 1
	 if (error)
d887 1
a887 1
	 VREF(vp);
d898 1
a898 1
	 }
d900 2
a901 2
	 fdp->fd_rdir = vp;
	 return (0);
d909 1
a909 1
	register struct nameidata *ndp;
d1044 1
a1044 1
	register void *v;
d1047 1
a1047 1
	register struct sys_getfh_args /* {
d1051 1
a1051 1
	register struct vnode *vp;
d1090 1
a1090 1
	register struct sys_fhopen_args /* {
d1222 1
a1222 1
	register struct sys_fhstat_args /* {
d1260 1
a1260 1
	register struct sys_fhstatfs_args /*
d1301 1
a1301 1
	register struct sys_mknod_args /* {
d1306 1
a1306 1
	register struct vnode *vp;
d1384 1
a1384 1
	register struct sys_mkfifo_args /* {
d1422 1
a1422 1
	register struct sys_link_args /* {
d1426 1
a1426 1
	register struct vnode *vp;
d1472 1
a1472 1
	register struct sys_symlink_args /* {
d1517 1
a1517 1
	register struct sys_undelete_args /* {
d1560 1
a1560 1
	register struct vnode *vp;
d1602 1
a1602 1
	register struct sys_lseek_args /* {
d1609 2
a1610 2
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
d1662 1
a1662 1
	register struct sys_access_args /* {
d1666 2
a1667 2
	register struct ucred *cred = p->p_ucred;
	register struct vnode *vp;
d1712 1
a1712 1
	register struct sys_stat_args /* {
d1745 1
a1745 1
	register struct sys_lstat_args /* {
d1778 1
a1778 1
	register struct sys_pathconf_args /* {
d1804 1
a1804 1
	register struct sys_readlink_args /* {
d1809 1
a1809 1
	register struct vnode *vp;
d1849 1
a1849 1
	register struct sys_chflags_args /* {
d1853 1
a1853 1
	register struct vnode *vp;
d1944 1
a1944 1
	register struct sys_chmod_args /* {
d1948 1
a1948 1
	register struct vnode *vp;
d2022 1
a2022 1
	register struct sys_chown_args /* {
d2027 1
a2027 1
	register struct vnode *vp;
d2074 1
a2074 1
	register struct sys_lchown_args /* {
d2079 1
a2079 1
	register struct vnode *vp;
d2177 1
a2177 1
	register struct sys_utimes_args /* {
d2181 1
a2181 1
	register struct vnode *vp;
d2233 1
a2233 1
	register struct sys_futimes_args /* {
d2288 1
a2288 1
	register struct sys_truncate_args /* {
d2293 1
a2293 1
	register struct vnode *vp;
d2401 1
a2401 1
	register struct sys_rename_args /* {
d2405 1
a2405 1
	register struct vnode *tvp, *fvp, *tdvp;
d2494 1
a2494 1
	register struct sys_mkdir_args /* {
d2498 1
a2498 1
	register struct vnode *vp;
d2540 1
a2540 1
	register struct vnode *vp;
d2670 1
a2670 1
	register struct filedesc *fdp;
d2689 1
a2689 1
	register struct sys_revoke_args /* {
d2692 1
a2692 1
	register struct vnode *vp;
@


1.8
log
@* fix the build system
* fix and enable the GNU Pascal RTS and Utils
  -> gpc is now fully supported; Hello World works.
* merge OpenBSD-OpenSSH 3.8, bump patchlevel
* add fchroot(2) diff, From: Pedro Martelletto <pbastos@@rdc.puc-rio.br>
* add fchroot(2) man page from NetBSD and myself
* fix orders of manpage sections
* fix displaying of .Nx mdoc macro
* convert scripts requiring bash to ksh
* nuke a shutload of GNU make idiotisms
* add pregenerated manpages - help2man is just bloat
* increase shlib versions after fchroot addition
* adjust and unbreak mk.conf after recent changes
* fix boot system version number after CD boot changes
* understand why Makefile.bsd-wrapper is needed as filename. Finally.
* regenerate files after syscalls.master change
* fix RCS Id detection and generation while here
* remove unused archs while there
* use __RCSID() macro in ssh ifdef __MirBSD__
* build ssh with -Werror, too

Note: this is a pre-snapshot, pre-build commit. Nothing
of this has actually been tested.

Like I said, please wait for the snapshot. Though, the
snapshot doesn't have any more circumstances preventing
me from working towards a release and upload now.
@
text
@d1 2
a2 2
/*	$MirBSD: vfs_syscalls.c,v 1.7 2004/01/27 17:42:34 tg Exp $	*/
/*	$OpenBSD: vfs_syscalls.c,v 1.108 2004/01/06 04:18:18 tedu Exp $	*/
d53 1
d159 2
a160 1
		 * enforce MNT_NOSUID and MNT_NODEV for non-root users.
d168 2
d190 2
a191 1
	 * enforce MNT_NOSUID and MNT_NODEV for non-root users.
d199 2
d330 1
a330 1
		free((caddr_t)mp, M_MOUNT);
d498 1
a498 1
	free((caddr_t)mp, M_MOUNT);
d612 1
a612 1
		bcopy((caddr_t)sp, (caddr_t)&sb, sizeof(sb));
d616 1
a616 1
	return (copyout((caddr_t)sp, (caddr_t)SCARG(uap, buf), sizeof(*sp)));
d658 1
a658 1
		bcopy((caddr_t)sp, (caddr_t)&sb, sizeof(sb));
d662 1
a662 1
	return (copyout((caddr_t)sp, (caddr_t)SCARG(uap, buf), sizeof(*sp)));
d682 1
a682 1
	caddr_t sfsp;
d687 1
a687 1
	sfsp = (caddr_t)SCARG(uap, buf);
d717 1
a717 1
				bcopy((caddr_t)sp, (caddr_t)&sb, sizeof(sb));
d721 1
a721 1
			error = copyout((caddr_t)sp, sfsp, sizeof(*sp));
d726 1
a726 1
			sfsp += sizeof(*sp);
d986 1
a986 1
	fp->f_data = (caddr_t)vp;
d1068 1
a1068 1
	bzero((caddr_t)&fh, sizeof(fh));
d1074 1
a1074 1
	error = copyout((caddr_t)&fh, (caddr_t)SCARG(uap, fhp), sizeof (fh));
d1174 1
a1174 1
	fp->f_data = (caddr_t)vp;
d1481 1
a1481 1
	MALLOC(path, char *, MAXPATHLEN, M_NAMEI, M_WAITOK);
d1503 1
a1503 1
	FREE(path, M_NAMEI);
d1731 1
a1731 1
	error = copyout((caddr_t)&sb, (caddr_t)SCARG(uap, ub), sizeof (sb));
d1764 1
a1764 1
	error = copyout((caddr_t)&sb, (caddr_t)SCARG(uap, ub), sizeof (sb));
d2193 2
a2194 2
		error = copyin((caddr_t)SCARG(uap, tptr), (caddr_t)tv,
		    sizeof (tv));
d2249 2
a2250 2
		error = copyin((caddr_t)SCARG(uap, tptr), (caddr_t)tv,
		    sizeof (tv));
d2474 1
a2474 1
	FREE(tond.ni_cnd.cn_pnbuf, M_NAMEI);
d2478 1
a2478 1
	FREE(fromnd.ni_cnd.cn_pnbuf, M_NAMEI);
d2645 1
a2645 1
		fp->f_data = (caddr_t) vp;
d2650 1
a2650 1
	error = copyout((caddr_t)&loff, (caddr_t)SCARG(uap, basep),
@


1.7
log
@first part of mergeing OpenBSD and fixing whitespace and RCS IDs
@
text
@d1 1
a1 1
/*	$MirBSD: vfs_syscalls.c,v 1.6 2003/10/28 02:58:04 tg Exp $	*/
d288 8
a295 8
 		if ((mp->mnt_flag & MNT_RDONLY) == 0) {
 			if (mp->mnt_syncer == NULL)
 				error = vfs_allocate_syncvnode(mp);
 		} else {
 			if (mp->mnt_syncer != NULL)
 				vgone(mp->mnt_syncer);
 			mp->mnt_syncer = NULL;
 		}
d314 2
a315 2
 		if ((mp->mnt_flag & MNT_RDONLY) == 0)
 			error = vfs_allocate_syncvnode(mp);
d440 3
a442 3
 	mp->mnt_flag &=~ MNT_ASYNC;
 	cache_purgevfs(mp);	/* remove cache entries for this file sys */
 	if (mp->mnt_syncer != NULL) {
d444 1
a444 1
 		vgone(mp->mnt_syncer);
d449 2
a450 2
 	    (flags & MNT_FORCE))
 		error = VFS_UNMOUNT(mp, flags, p);
d452 3
a454 3
 	if (error) {
 		if ((mp->mnt_flag & MNT_RDONLY) == 0 && hadsyncer)
 			(void) vfs_allocate_syncvnode(mp);
d485 2
a486 2
 		vrele(coveredvp);
 	}
d701 1
a701 1
 				continue;
d848 50
d3250 1
a3250 1
	     NULL);
@


1.6
log
@pull mknod-in-chroot change
@
text
@d1 2
a2 2
/*	$MirBSD$	*/
/*	$OpenBSD: vfs_syscalls.c,v 1.107 2003/09/01 18:06:03 henning Exp $	*/
d896 2
d899 1
a899 1
		return (error);
d916 1
a916 1
			return (0);
d922 1
a922 1
		return (error);
d947 1
a947 1
			return (error);
d970 1
a970 1
			return (error);
d976 3
a978 1
	return (0);
d1060 5
a1064 2
	if ((error = falloc(p, &fp, &indx)) != 0)
		return (error);
d1143 2
d1148 7
a1154 4
	fdremove(fdp, indx);
	closef(fp, p);
	if (vp != NULL)
		vput(vp);
@


1.5
log
@merge last cvs import conflicts

TODO:
 - sync the various files
 - make a kernel that can build the new W^X
   (i.e. temporarily disable the old W^X)
 - build new kernel, binutils, ld.so, userland
 - import new flag day change
 - build new binutils, ld.so, userland, kernel

includes:
CVSROOT:        /cvs
Module name:    src
Changes by:     drahn@@cvs.openbsd.org   2003/04/28 15:32:08

Modified files:
        lib/libc/sys   : mquery.c
        libexec/ld.so  : library_mquery.c
        libexec/ld.so/i386: archdep.h
        sys/kern       : syscalls.master
        sys/sys        : mman.h
        sys/uvm        : uvm_mmap.c

Log message:
Change mquery() function call signature to be the same a mmap(). It
needs the prot/flags info and passing the addresses via arg/return allows
it to be traced via ktrace better than an in/out paramter.
This adds a new mquery syscall and renames the old one to omquery.
New kernel _MUST_ be built, booted, and 'make includes' before building
ld.so with this change.
@
text
@d1 2
a2 1
/*	$OpenBSD: vfs_syscalls.c,v 1.102 2003/05/05 00:21:52 tedu Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d26 1
a26 1
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
d94 2
a95 2
		syscallarg(char *) type;
		syscallarg(char *) path;
d109 1
a109 1
	struct vfsconf *vfsp = NULL;
d112 1
a112 1
	if (usermount == 0 && (error = suser(p->p_ucred, &p->p_acflag)))
d152 1
a152 1
		    (error = suser(p->p_ucred, &p->p_acflag))) {
d180 1
a180 1
	    (error = suser(p->p_ucred, &p->p_acflag)))) {
d381 1
a381 1
		syscallarg(char *) path;
d401 1
a401 1
	    (error = suser(p->p_ucred, &p->p_acflag))) {
d426 1
a426 1
	return (dounmount(mp, SCARG(uap, flags), p));
d433 1
a433 1
dounmount(struct mount *mp, int flags, struct proc *p)
d436 1
d461 24
a484 1
		coveredvp->v_mountedhere = (struct mount *)0;
d552 1
a552 1
		syscallarg(char *) path;
d555 1
a555 1
		syscallarg(caddr_t) arg;
d581 1
a581 1
		syscallarg(char *) path;
d604 1
a604 1
	if (suser(p->p_ucred, &p->p_acflag)) {
d635 4
d650 1
a650 1
	if (suser(p->p_ucred, &p->p_acflag)) {
d709 1
a709 1
			if (suser(p->p_ucred, &p->p_acflag)) {
d785 1
a785 1
 * Change current working directory (``.'').
d795 1
a795 1
		syscallarg(char *) path;
d811 1
a811 1
 * Change notion of root (``/'') directory.
d821 1
a821 1
		syscallarg(char *) path;
d827 1
a827 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d883 1
a883 1
		syscallarg(char *) path;
d987 1
a987 1
		syscallarg(char *) fname;
d998 1
a998 1
	error = suser(p->p_ucred, &p->p_acflag);
d1047 1
a1047 1
	if ((error = suser(p->p_ucred, &p->p_acflag)))
d1166 1
a1166 1
	if ((error = suser(p->p_ucred, &p->p_acflag)))
d1204 1
a1204 1
	if ((error = suser(p->p_ucred, &p->p_acflag)))
d1233 1
a1233 1
		syscallarg(char *) path;
d1243 1
a1243 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d1245 1
d1248 1
d1316 1
a1316 1
		syscallarg(char *) path;
d1354 2
a1355 2
		syscallarg(char *) path;
		syscallarg(char *) link;
d1404 2
a1405 2
		syscallarg(char *) path;
		syscallarg(char *) link;
d1449 1
a1449 1
		syscallarg(char *) path;
d1489 1
a1489 1
		syscallarg(char *) path;
d1594 1
a1594 1
		syscallarg(char *) path;
d1644 1
a1644 1
		syscallarg(char *) path;
d1660 1
a1660 1
	if (suser(p->p_ucred, &p->p_acflag))
d1677 1
a1677 1
		syscallarg(char *) path;
d1693 1
a1693 1
	if (suser(p->p_ucred, &p->p_acflag))
d1710 1
a1710 1
		syscallarg(char *) path;
d1736 1
a1736 1
		syscallarg(char *) path;
d1781 2
a1782 2
		syscallarg(char *) path;
		syscallarg(unsigned int) flags;
d1800 1
a1800 1
		if (suser(p->p_ucred, &p->p_acflag)) {
d1829 1
a1829 1
		syscallarg(unsigned int) flags;
d1841 1
a1841 1
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
d1846 1
a1846 1
		if (suser(p->p_ucred, &p->p_acflag)) {
d1876 1
a1876 1
		syscallarg(char *) path;
d1931 1
a1931 1
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
d1954 3
a1956 3
		syscallarg(char *) path;
		syscallarg(int) uid;
		syscallarg(int) gid;
d1974 1
a1974 1
		    (suser(p->p_ucred, &p->p_acflag) || suid_clear)) {
d2006 3
a2008 3
		syscallarg(char *) path;
		syscallarg(int) uid;
		syscallarg(int) gid;
d2026 1
a2026 1
		    (suser(p->p_ucred, &p->p_acflag) || suid_clear)) {
d2059 2
a2060 2
		syscallarg(int) uid;
		syscallarg(int) gid;
d2077 1
a2077 1
		    (suser(p->p_ucred, &p->p_acflag) || suid_clear)) {
d2109 2
a2110 2
		syscallarg(char *) path;
		syscallarg(struct timeval *) tptr;
d2166 1
a2166 1
		syscallarg(struct timeval *) tptr;
d2195 1
a2195 1
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
d2220 1
a2220 1
		syscallarg(char *) path;
d2333 2
a2334 2
		syscallarg(char *) from;
		syscallarg(char *) to;
d2426 1
a2426 1
		syscallarg(char *) path;
d2469 1
a2469 1
		syscallarg(char *) path;
d2621 1
a2621 1
		syscallarg(char *) path;
d2635 1
a2635 1
	    (error = suser(p->p_ucred, &p->p_acflag)))
d2919 1
a2919 1
 * 
d3001 2
a3002 2
		syscallarg(struct iovec *) iovp;
		syscallarg(int) iovcnt;
d3026 1
a3026 1
 * 
d3149 1
a3149 1
 * 
d3179 1
a3179 1
		syscallarg(int) fd;
d3213 1
a3213 1
	} */ *uap = v; 
d3232 1
a3232 1
#endif 
@


1.4
log
@clean up after cvs
fix some stuff

in the hope to fully have removed sys_mhint... they implemented
it in the name of sys_mquery *d'oh*
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.100 2003/04/11 01:48:41 tedu Exp $	*/
d440 1
d444 2
a445 1
 	if (mp->mnt_syncer != NULL)
d447 2
d455 1
a455 1
 		if ((mp->mnt_flag & MNT_RDONLY) == 0 && mp->mnt_syncer == NULL)
d2610 1
a2610 1
	if (vp->v_usecount > 1 || (vp->v_flag & VALIASED))
@


1.3
log
@clean up the cvs import mess

nb, this doesnt mean the tree builds.
its bed time
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.99 2003/04/10 02:06:00 tedu Exp $	*/
a349 2
		if (P_ZOMBIE(p))
			continue;
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.98 2002/10/02 21:56:30 nordin Exp $	*/
d350 2
a351 4
		/*
		 * XXX - we have a race with fork here. We should probably
		 *       check if the process is SIDL before we fiddle with it.
		 */
@


1.1
log
@Initial revision
@
text
@d112 1
a112 1
	struct vfsconf *vfsp;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.99 2003/04/10 02:06:00 tedu Exp $	*/
d350 4
a353 2
		if (P_ZOMBIE(p))
			continue;
@


1.1.1.3
log
@Import OpenBSD source with the "new" command line as well,
in order to be able to provide a MirBSD release which bases
upon a fairly current OpenBSD base source code tree deemed
stable enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.100 2003/04/11 01:48:41 tedu Exp $	*/
d350 2
@


1.1.1.4
log
@Import OpenBSD cvs as of now, CTM delta 3255, just before the i386 flag day
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.102 2003/05/05 00:21:52 tedu Exp $	*/
a439 1
	int hadsyncer = 0;
d443 1
a443 2
 	if (mp->mnt_syncer != NULL) {
		hadsyncer = 1;
a444 2
		mp->mnt_syncer = NULL;
	}
d451 1
a451 1
 		if ((mp->mnt_flag & MNT_RDONLY) == 0 && hadsyncer)
d2606 1
a2606 1
	if (vp->v_usecount > 1 || (vp->v_flag & (VALIASED | VLAYER)))
@


1.1.1.5
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.103 2003/05/06 20:52:14 tedu Exp $	*/
d429 1
a429 1
	return (dounmount(mp, SCARG(uap, flags), p, vp));
d436 1
a436 1
dounmount(struct mount *mp, int flags, struct proc *p, struct vnode *olddp)
a438 1
	struct proc *p2;
d463 1
a463 24
		if (olddp) {
			/* 
			 * Try to put processes back in a real directory
			 * after a forced unmount.
			 * XXX We're not holding a ref on olddp, which may
			 * change, so compare id numbers.
			 */
			LIST_FOREACH(p2, &allproc, p_list) {
				struct filedesc *fdp = p2->p_fd;
				if (fdp->fd_cdir &&
				    fdp->fd_cdir->v_id == olddp->v_id) {
					vrele(fdp->fd_cdir);
					vref(coveredvp);
					fdp->fd_cdir = coveredvp;
				}
				if (fdp->fd_rdir &&
				    fdp->fd_rdir->v_id == olddp->v_id) {
					vrele(fdp->fd_rdir);
					vref(coveredvp);
					fdp->fd_rdir = coveredvp;
				}
			}
		}
		coveredvp->v_mountedhere = NULL;
@


1.1.1.6
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.104 2003/06/02 23:28:07 millert Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.1.7
log
@Another sync to OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.105 2003/07/18 16:43:32 tedu Exp $	*/
a633 4
	if (!mp) {
		FRELE(fp);
		return (ENOENT);
	}
d1834 1
a1834 1
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
d1924 1
a1924 1
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
d2188 1
a2188 1
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
@


1.1.1.8
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.106 2003/08/15 20:32:18 tedu Exp $	*/
d111 1
a111 1
	if (usermount == 0 && (error = suser(p, 0)))
d151 1
a151 1
		    (error = suser(p, 0))) {
d179 1
a179 1
	    (error = suser(p, 0)))) {
d400 1
a400 1
	    (error = suser(p, 0))) {
d603 1
a603 1
	if (suser(p, 0)) {
d649 1
a649 1
	if (suser(p, 0)) {
d708 1
a708 1
			if (suser(p, 0)) {
d826 1
a826 1
	if ((error = suser(p, 0)) != 0)
d997 1
a997 1
	error = suser(p, 0);
d1046 1
a1046 1
	if ((error = suser(p, 0)))
d1165 1
a1165 1
	if ((error = suser(p, 0)))
d1203 1
a1203 1
	if ((error = suser(p, 0)))
d1242 1
a1242 1
	if ((error = suser(p, 0)) != 0)
d1657 1
a1657 1
	if (suser(p, 0))
d1690 1
a1690 1
	if (suser(p, 0))
d1797 1
a1797 1
		if (suser(p, 0)) {
d1843 1
a1843 1
		if (suser(p, 0)) {
d1971 1
a1971 1
		    (suser(p, 0) || suid_clear)) {
d2023 1
a2023 1
		    (suser(p, 0) || suid_clear)) {
d2074 1
a2074 1
		    (suser(p, 0) || suid_clear)) {
d2632 1
a2632 1
	    (error = suser(p, 0)))
@


1.1.1.9
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.107 2003/09/01 18:06:03 henning Exp $	*/
d93 2
a94 2
		syscallarg(const char *) type;
		syscallarg(const char *) path;
d380 1
a380 1
		syscallarg(const char *) path;
d551 1
a551 1
		syscallarg(const char *) path;
d554 1
a554 1
		syscallarg(char *) arg;
d580 1
a580 1
		syscallarg(const char *) path;
d794 1
a794 1
		syscallarg(const char *) path;
d820 1
a820 1
		syscallarg(const char *) path;
d882 1
a882 1
		syscallarg(const char *) path;
d986 1
a986 1
		syscallarg(const char *) fname;
d1232 1
a1232 1
		syscallarg(const char *) path;
d1313 1
a1313 1
		syscallarg(const char *) path;
d1351 2
a1352 2
		syscallarg(const char *) path;
		syscallarg(const char *) link;
d1401 2
a1402 2
		syscallarg(const char *) path;
		syscallarg(const char *) link;
d1446 1
a1446 1
		syscallarg(const char *) path;
d1486 1
a1486 1
		syscallarg(const char *) path;
d1591 1
a1591 1
		syscallarg(const char *) path;
d1641 1
a1641 1
		syscallarg(const char *) path;
d1674 1
a1674 1
		syscallarg(const char *) path;
d1707 1
a1707 1
		syscallarg(const char *) path;
d1733 1
a1733 1
		syscallarg(const char *) path;
d1778 2
a1779 2
		syscallarg(const char *) path;
		syscallarg(u_int) flags;
d1826 1
a1826 1
		syscallarg(u_int) flags;
d1873 1
a1873 1
		syscallarg(const char *) path;
d1951 3
a1953 3
		syscallarg(const char *) path;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
d2003 3
a2005 3
		syscallarg(const char *) path;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
d2056 2
a2057 2
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
d2106 2
a2107 2
		syscallarg(const char *) path;
		syscallarg(const struct timeval *) tptr;
d2163 1
a2163 1
		syscallarg(const struct timeval *) tptr;
d2217 1
a2217 1
		syscallarg(const char *) path;
d2330 2
a2331 2
		syscallarg(const char *) from;
		syscallarg(const char *) to;
d2423 1
a2423 1
		syscallarg(const char *) path;
d2466 1
a2466 1
		syscallarg(const char *) path;
d2618 1
a2618 1
		syscallarg(const char *) path;
d2998 2
a2999 2
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
d3176 1
a3176 1
		syscallarg(const char *) path;
@


1.1.1.10
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.108 2004/01/06 04:18:18 tedu Exp $	*/
a894 2
	fdplock(fdp, p);

d896 1
a896 1
		goto out;
d913 1
a913 1
			goto out;
d919 1
a919 1
		goto out;
d944 1
a944 1
			goto out;
d967 1
a967 1
			goto out;
d973 1
a973 3
out:
	fdpunlock(fdp);
	return (error);
d1055 2
a1056 5
	fdplock(fdp, p);
	if ((error = falloc(p, &fp, &indx)) != 0) {
		fp = NULL;
		goto bad;
	}
a1134 2

	fdpunlock(fdp);
d1138 4
a1141 7
	if (fp) {
		fdremove(fdp, indx);
		closef(fp, p);
		if (vp != NULL)
			vput(vp);
	}
	fdpunlock(fdp);
@


1.1.1.11
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.111 2004/05/14 04:00:33 tedu Exp $	*/
a51 1
#include <sys/pool.h>
d157 1
a157 2
		 * enforce MNT_NOSUID and MNT_NODEV for non-root users, and
		 * inherit MNT_NOEXEC from the mount point.
a164 2
			if (flag & MNT_NOEXEC)
				SCARG(uap, flags) |= MNT_NOEXEC;
d185 1
a185 2
	 * enforce MNT_NOSUID and MNT_NODEV for non-root users, and inherit
	 * MNT_NOEXEC from the mount point.
a192 2
		if (vp->v_mount->mnt_flag & MNT_NOEXEC)
			SCARG(uap, flags) |= MNT_NOEXEC;
d322 1
a322 1
		free(mp, M_MOUNT);
d490 1
a490 1
	free(mp, M_MOUNT);
d604 1
a604 1
		bcopy(sp, &sb, sizeof(sb));
d608 1
a608 1
	return (copyout(sp, SCARG(uap, buf), sizeof(*sp)));
d650 1
a650 1
		bcopy(sp, &sb, sizeof(sb));
d654 1
a654 1
	return (copyout(sp, SCARG(uap, buf), sizeof(*sp)));
d674 1
a674 1
	struct statfs *sfsp;
d679 1
a679 1
	sfsp = SCARG(uap, buf);
d709 1
a709 1
				bcopy(sp, &sb, sizeof(sb));
d713 1
a713 1
			error = copyout(sp, sfsp, sizeof(*sp));
d718 1
a718 1
			sfsp++;
d928 1
a928 1
	fp->f_data = vp;
d1010 1
a1010 1
	bzero(&fh, sizeof(fh));
d1016 1
a1016 1
	error = copyout(&fh, SCARG(uap, fhp), sizeof(fh));
d1116 1
a1116 1
	fp->f_data = vp;
d1421 1
a1421 1
	path = pool_get(&namei_pool, PR_WAITOK);
d1443 1
a1443 1
	pool_put(&namei_pool, path);
d1671 1
a1671 1
	error = copyout(&sb, SCARG(uap, ub), sizeof(sb));
d1704 1
a1704 1
	error = copyout(&sb, SCARG(uap, ub), sizeof(sb));
d2133 2
a2134 2
		error = copyin(SCARG(uap, tptr), tv,
		    sizeof(tv));
d2189 2
a2190 2
		error = copyin(SCARG(uap, tptr), tv,
		    sizeof(tv));
d2414 1
a2414 1
	pool_put(&namei_pool, tond.ni_cnd.cn_pnbuf);
d2418 1
a2418 1
	pool_put(&namei_pool, fromnd.ni_cnd.cn_pnbuf);
d2585 1
a2585 1
		fp->f_data = vp;
d2590 1
a2590 1
	error = copyout(&loff, SCARG(uap, basep),
@


1.1.1.12
log
@partial merge:	millert@@cvs.openbsd.org 2004/07/13 15:04:30
Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.114 2004/07/13 21:04:29 millert Exp $	*/
d891 1
a891 1
		syscallarg(mode_t) mode;
d1252 1
a1252 1
		syscallarg(mode_t) mode;
d1333 1
a1333 1
		syscallarg(mode_t) mode;
d1893 1
a1893 1
		syscallarg(mode_t) mode;
d1932 1
a1932 1
		syscallarg(mode_t) mode;
d1978 1
a1978 1
	mode_t mode;
d2030 1
a2030 1
	mode_t mode;
d2082 1
a2082 1
	mode_t mode;
d2443 1
a2443 1
		syscallarg(mode_t) mode;
d2615 1
a2615 1
		syscallarg(mode_t) newmask;
@


1.1.1.9.2.1
log
@allow mknod(2) within a chroot(2) jail by default
(one can revert to the OpenBSD-specific behaviour
 by compiling a custom kernel)

this should enable us to build a system fully within chroot.

while here, the usual whitespace & friends clean-up
@
text
@a0 1
/*	$MirBSD$	*/
d25 1
a25 1
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS" AND
d461 1
a461 1
			/*
d784 1
a784 1
 * Change current working directory (".").
d810 1
a810 1
 * Change notion of root ("/") directory.
a1243 1
#ifdef	HARD_CHROOT
a1245 1
#endif
d2916 1
a2916 1
 *
d3023 1
a3023 1
 *
d3146 1
a3146 1
 *
d3210 1
a3210 1
	} */ *uap = v;
d3229 1
a3229 1
#endif
@


1.1.1.9.2.2
log
@verified exec ported from NetBSD 1.6.1 / Stephanie patches for OpenBSD 3.4:
 - prevent execution of trojaned applications (f.e. netstat,ps,..)
 - activated in GENERIC, but must be enabled with sysctl -w kern.vexec.op=1
 - you have to generate the fingerprint database with fpgen.sh from sbin/vexecctl/

TODO:
- fix a problem with hardlinked applications (f.e. /bin/chown and /bin/chgrp)
  error: "vexec_inodeadd: Received invalid fingerprint for an existing entry! Entry not modified."
- patch MAKEDEV.mi to create devicenode /dev/vexec
- create sample database when doing make release (/etc/vexec.conf.release)
- more testing, test it on sparc
- do performance tests
@
text
@d1 1
a1 1
/*	$MirBSD: vfs_syscalls.c,v 1.1.1.9.2.1 2003/10/28 02:56:40 tg Exp $	*/
a60 2
#include <sys/vexec.h>

a1493 3
	struct vexec_inode_list *vi;
	struct vattr va;
	char got_dev;
a1514 121
	/*
	 * Vexec remove policy:
	 *   If the file is in our lists, and the securelevel is high,
	 *   don't allow removing it. Otherwise, remove it from our lists
	 *   aswell.
	 *
	 * XXX: This really needs a speed-up.
	 */
	error = VOP_GETATTR(vp, &va, p->p_ucred, p);
	if (error)
		return (error);

	switch (vp->v_fpstatus) {
	case FP_VALID:
	case FP_INDIRECT:
	case FP_NOMATCH:
		/*
		 * These could be set only for files we have entry for.
		 * If the securelevel allows it, remove them.
		 */
		if (securelevel >= VEXEC_SECURELEVEL) {
			/*
			 * No way.
			 */
			printf("sys_unlink: Denying unlink request from "
			    "uid=%u: File in lists, system highly-secure."
			    " (inode=%u, dev=%d)\n", p->p_ucred->cr_uid,
			    va.va_fileid, va.va_fsid);

			error = EPERM;
			goto out;
		} else {
			/*
			 * First try normal file list, then executables.
			 * XXX: Add a flag indicating what list to use?
			 * XXX: Special care in case of a Union file-system,
			 *      to prevent "rm -W" abuse?
			 */
			vi = vexec_inodeget(&vexec_file_dev_head,
			    va.va_fsid, va.va_fileid, &got_dev);
			if (!vi) {
				vi = vexec_inodeget(&vexec_exec_dev_head,
				    va.va_fsid, va.va_fileid, &got_dev);
				if (!vi) {
					/*
					 * XXX: Should this be DIAGNOSTIC &&
					 * VEXEC_DEBUG?
					 */
#ifdef DIAGNOSTIC
					panic("sys_unlink: vexec list "
					    "inconsistency detected.");
#else
					printf("sys_unlink: vexec list "
					    "inconsistency detected.");

					goto skip_vexec_remove;
#endif
				}
			}

			if (security_vexec_verbose) {
				printf("sys_unlink: Removing "
				    "entry from Vexec list. "
				    "(dev=%d, inode=%u)\n",
				    va.va_fsid, va.va_fileid);
			}

			LIST_REMOVE(vi, vxi_entries);
			free(vi, M_TEMP);
		}
		
		break;

	case FP_NOENTRY:
	case FP_NODEV:
		/*
		 * These can be set only for files we don't have entries
		 * for. Just continue.
		 */
		break;

	case FP_INVALID:
		/*
		 * Here we have to check if we have an entry or not,
		 * because the status might've not been evaluated yet,
		 * and the vnode could've been freed and reallocated at
		 * securelevel 2.
		 */
		vi = vexec_inodeget(&vexec_file_dev_head,
		    va.va_fsid, va.va_fileid, &got_dev);
		if (!vi) {
			vi = vexec_inodeget(&vexec_exec_dev_head,
			    va.va_fsid, va.va_fileid, &got_dev);
			if (!vi) {
				/*
				 * Looks like we don't have an entry.
				 */
				goto skip_vexec_remove;
			}
		}

		/*
		 * We've got an entry, check securelevel...
		 */
		if (securelevel >= VEXEC_SECURELEVEL) {
			printf("sys_unlink: Denying unlink request from "
			    "uid=%u: File in lists, system highly-secure."
			    " (inode=%u, dev=%d)\n", p->p_ucred->cr_uid,
			    va.va_fileid, va.va_fsid);

			error = EPERM;
			goto out;
		}

		LIST_REMOVE(vi, vxi_entries);
		free(vi, M_TEMP);

		break;		
	}

skip_vexec_remove:
@


