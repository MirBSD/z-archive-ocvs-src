head	1.21;
access;
symbols
	tg-mergetmp-mirosx-1:1.21
	tg-mergefixes-1-branch:1.21.0.4
	tg-mergefixes-1-base:1.21
	MIROS_X:1.21.0.2
	MIROS_X_BASE:1.21
	tg-mergetmp-3:1.21
	MIRBSD_XP_MIRPPC:1.19.0.4
	MIRBSD_XP_SPARC_BASE:1.19
	MIRBSD_XP_SPARC:1.19.0.2
	MIRBSD_7quater:1.11
	cvs-200405160640:1.1.1.10
	cvs-200401271800:1.1.1.9
	cvs-200401261630:1.1.1.9
	cvs-200401021645:1.1.1.8
	MIRBSD_7_ALPHA:1.11.0.6
	MIRBSD_7:1.11.0.4
	cvs-200312222040:1.1.1.8
	MIRBSD_7ter:1.11
	MIRBSD_7_DEV:1.11.0.2
	cvs-200310020700:1.1.1.7
	cvs-200309271030:1.1.1.7
	cvs-200309261655:1.1.1.7
	cvs-200309251530:1.1.1.7
	cvs-200308302005:1.1.1.7
	cvs-200308171200:1.1.1.6
	ctm-3496:1.1.1.5
	ctm-3449:1.1.1.4
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	cvs-200307072125:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200307021520:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.4
	MIRBSD_5:1.6
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	ctm-3255:1.1.1.2
	ctm-3229:1.1.1.1
	MIRBSD_4:1.2
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2004.12.11.16.50.14;	author tg;	state Exp;
branches;
next	1.20;

1.20
date	2004.10.14.22.36.25;	author tg;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.16.21.24.55;	author tg;	state Stab;
branches;
next	1.18;

1.18
date	2004.06.16.21.06.37;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.23.20.16.28;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.29.18.36.17;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.26.20.54.13;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.28.20.42.51;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.27.17.42.34;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.25.21.25.32;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.03.13.47.23;	author tg;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2003.08.31.20.54.58;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.17.18.56.36;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.16.15.25.47;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.19.16.44.36;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.06.18.29.15;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.05.19.20.45;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.03.22.22.41;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.03.21.58.22;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.52.45;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.51.51;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.51.51;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.05.18.57.03;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.40.27;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.50.37;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.08.11.18.40.51;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.08.17.14.39.21;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.08.30.23.25.05;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.12.22.21.04.09;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.01.26.18.52.45;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.05.16.09.06.30;	author tg;	state Exp;
branches;
next	;

1.11.2.1
date	2003.11.30.22.42.54;	author wbx;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Another round of mega-commit-death:
* compile fixes (pre-removal)
* distrib list sync (pre-removal)
* throw out more orphaned profiling stuff
* sync with reality (post-removal)
  -> e.g. don't call comsatd in inetd.conf
* general clean-up phase for touched files,
  or stuff "while here"
* partial distrib list sync (post-removal)
* replace echo with print in /etc/profile

kernel builds; will do a make b-r in two jiffies
@
text
@/**	$MirBSD: src/sys/kern/kern_sysctl.c,v 1.19 2004/06/16 21:24:55 tg Stab $ */
/*	$NetBSD: kern_sysctl.c,v 1.146 2003/09/28 13:24:48 dsl Exp $	*/
/*	$OpenBSD: kern_sysctl.c,v 1.121 2004/10/14 17:10:17 mickey Exp $	*/
/*	$NetBSD: kern_sysctl.c,v 1.17 1996/05/20 17:49:05 mrg Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Mike Karels at Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_sysctl.c	8.4 (Berkeley) 4/14/94
 */

/*
 * sysctl system call.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/file.h>
#include <sys/vnode.h>
#include <sys/unistd.h>
#include <sys/buf.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>
#include <sys/msgbuf.h>
#include <sys/dkstat.h>
#include <sys/vmmeter.h>
#include <sys/namei.h>
#include <sys/exec.h>
#include <sys/mbuf.h>
#include <sys/sensors.h>
#include <sys/conf.h>
#ifdef __HAVE_TIMECOUNTER
#include <sys/timetc.h>
#endif
#ifdef __HAVE_EVCOUNT
#include <sys/evcount.h>
#endif

#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <dev/rndvar.h>

#ifdef DDB
#include <ddb/db_var.h>
#endif

#ifdef SYSVMSG
#include <sys/msg.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif

#define	PTRTOINT64(_x)	((u_int64_t)(u_long)(_x))

extern struct forkstat forkstat;
extern struct nchstats nchstats;
extern int nselcoll, fscale;
extern struct disklist_head disklist;
extern fixpt_t ccpu;
extern  long numvnodes;

extern void nmbclust_update(void);

int sysctl_diskinit(int, struct proc *);
int sysctl_proc_args(int *, u_int, void *, size_t *, struct proc *);
int sysctl_intrcnt(int *, u_int, void *, size_t *);
int sysctl_sensors(int *, u_int, void *, size_t *, void *, size_t);
int sysctl_emul(int *, u_int, void *, size_t *, void *, size_t);

int (*cpu_cpuspeed)(int *);
int (*cpu_setperf)(int);
int perflevel = 100;

extern char root_devname[];

/*
 * Lock to avoid too many processes vslocking a large amount of memory
 * at the same time.
 */
struct lock sysctl_lock, sysctl_disklock;

#if defined(KMEMSTATS) || defined(DIAGNOSTIC) || defined(FFS_SOFTUPDATES)
struct lock sysctl_kmemlock;
#endif

void sysctl_init_values(void);

void
sysctl_init()
{
	sysctl_init_values();

	lockinit(&sysctl_lock, PLOCK|PCATCH, "sysctl", 0, 0);
	lockinit(&sysctl_disklock, PLOCK|PCATCH, "sysctl_disklock", 0, 0);

#if defined(KMEMSTATS) || defined(DIAGNOSTIC) || defined(FFS_SOFTUPDATES)
	lockinit(&sysctl_kmemlock, PLOCK|PCATCH, "sysctl_kmemlock", 0, 0);
#endif
}

int
sys___sysctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys___sysctl_args /* {
		syscallarg(int *) name;
		syscallarg(u_int) namelen;
		syscallarg(void *) old;
		syscallarg(size_t *) oldlenp;
		syscallarg(void *) new;
		syscallarg(size_t) newlen;
	} */ *uap = v;
	int error, dolock = 1;
	size_t savelen = 0, oldlen = 0;
	sysctlfn *fn;
	int name[CTL_MAXNAME];

	if (SCARG(uap, new) != NULL &&
	    (error = suser(p, 0)))
		return (error);
	/*
	 * all top-level sysctl names are non-terminal
	 */
	if (SCARG(uap, namelen) > CTL_MAXNAME || SCARG(uap, namelen) < 2)
		return (EINVAL);
	error = copyin(SCARG(uap, name), name,
		       SCARG(uap, namelen) * sizeof(int));
	if (error)
		return (error);

	switch (name[0]) {
	case CTL_KERN:
		fn = kern_sysctl;
		if (name[1] == KERN_VNODE)	/* XXX */
			dolock = 0;
		break;
	case CTL_HW:
		fn = hw_sysctl;
		break;
	case CTL_VM:
		fn = uvm_sysctl;
		break;
	case CTL_NET:
		fn = net_sysctl;
		break;
	case CTL_FS:
		fn = fs_sysctl;
		break;
	case CTL_VFS:
		fn = vfs_sysctl;
		break;
	case CTL_MACHDEP:
		fn = cpu_sysctl;
		break;
#ifdef DEBUG
	case CTL_DEBUG:
		fn = debug_sysctl;
		break;
#endif
#ifdef DDB
	case CTL_DDB:
		fn = ddb_sysctl;
		break;
#endif
	default:
		return (EOPNOTSUPP);
	}

	if (SCARG(uap, oldlenp) &&
	    (error = copyin(SCARG(uap, oldlenp), &oldlen, sizeof(oldlen))))
		return (error);
	if (SCARG(uap, old) != NULL) {
		if ((error = lockmgr(&sysctl_lock, LK_EXCLUSIVE, NULL, p)) != 0)
			return (error);
		if (dolock) {
			error = uvm_vslock(p, SCARG(uap, old), oldlen,
			    VM_PROT_READ|VM_PROT_WRITE);
			if (error) {
				lockmgr(&sysctl_lock, LK_RELEASE, NULL, p);
				return (error);
			}
		}
		savelen = oldlen;
	}
	error = (*fn)(&name[1], SCARG(uap, namelen) - 1, SCARG(uap, old),
	    &oldlen, SCARG(uap, new), SCARG(uap, newlen), p);
	if (SCARG(uap, old) != NULL) {
		if (dolock)
			uvm_vsunlock(p, SCARG(uap, old), savelen);
		lockmgr(&sysctl_lock, LK_RELEASE, NULL, p);
	}
	if (error)
		return (error);
	if (SCARG(uap, oldlenp))
		error = copyout(&oldlen, SCARG(uap, oldlenp), sizeof(oldlen));
	return (error);
}

/*
 * Attributes stored in the kernel.
 */
char hostname[MAXHOSTNAMELEN];
int hostnamelen;
char domainname[1] = "";
int domainnamelen;
long hostid;
char *disknames = NULL;
struct diskstats *diskstats = NULL;
#ifdef INSECURE
int securelevel = -1;
#else
int securelevel;
#endif
int allowpsa = 1, allowpse = 1;
#define	MAXEMULUNAMELEN 65
char emul_uname[MAXEMULUNAMELEN];

/*
 * kernel related system variables.
 */
int
kern_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	int error, level, inthostid, stackgap;
	extern int somaxconn, sominconn;
	extern int usermount, nosuidcoredump;
	extern long cp_time[CPUSTATES];
	extern int stackgap_random;
#ifdef CRYPTO
	extern int usercrypto;
	extern int userasymcrypto;
	extern int cryptodevallowsoft;
#endif

	/* all sysctl names at this level are terminal except a ton of them */
	if (namelen != 1) {
		switch (name[0]) {
		case KERN_PROC:
		case KERN_PROC2:
		case KERN_PROF:
		case KERN_MALLOCSTATS:
		case KERN_TTY:
		case KERN_POOL:
		case KERN_PROC_ARGS:
		case KERN_SYSVIPC_INFO:
		case KERN_SEMINFO:
		case KERN_SHMINFO:
		case KERN_INTRCNT:
		case KERN_WATCHDOG:
		case KERN_EMUL:
#ifdef __HAVE_EVCOUNT
		case KERN_EVCOUNT:
#endif
#ifdef __HAVE_TIMECOUNTER
		case KERN_TIMECOUNTER:
#endif
			break;
		default:
			return (ENOTDIR);	/* overloaded */
		}
	}

	switch (name[0]) {
	case KERN_OSTYPE:
		return (sysctl_rdstring(oldp, oldlenp, newp, ostype));
	case KERN_OSRELEASE:
		return (sysctl_rdstring(oldp, oldlenp, newp, osrelease));
	case KERN_OSPATCHLEVEL:
		return (sysctl_rdstring(oldp, oldlenp, newp, ospatchlevel));
	case KERN_OSREV:
		return (sysctl_rdint(oldp, oldlenp, newp, MirBSD));
	case KERN_OSVERSION:
		return (sysctl_rdstring(oldp, oldlenp, newp, osversion));
	case KERN_VERSION:
		return (sysctl_rdstring(oldp, oldlenp, newp, version));
	case KERN_MAXVNODES:
		return(sysctl_int(oldp, oldlenp, newp, newlen, &desiredvnodes));
	case KERN_MAXPROC:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &maxproc));
	case KERN_MAXFILES:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &maxfiles));
	case KERN_NFILES:
		return (sysctl_rdint(oldp, oldlenp, newp, nfiles));
	case KERN_TTYCOUNT:
		return (sysctl_rdint(oldp, oldlenp, newp, tty_count));
	case KERN_NUMVNODES:
		return (sysctl_rdint(oldp, oldlenp, newp, numvnodes));
	case KERN_ARGMAX:
		return (sysctl_rdint(oldp, oldlenp, newp, ARG_MAX));
	case KERN_NSELCOLL:
		return (sysctl_rdint(oldp, oldlenp, newp, nselcoll));
	case KERN_SECURELVL:
		level = securelevel;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &level)) ||
		    newp == NULL)
			return (error);
		if ((securelevel > 0 || level < -1) &&
		    level < securelevel && p->p_pid != 1)
			return (EPERM);
		securelevel = level;
		return (0);
	case KERN_HOSTNAME:
		error = sysctl_tstring(oldp, oldlenp, newp, newlen,
		    hostname, sizeof(hostname));
		if (newp && !error)
			hostnamelen = newlen;
		return (error);
	case KERN_DOMAINNAME:
		error = sysctl_rdstring(oldp, oldlenp, newp, domainname);
		return (error);
	case KERN_HOSTID:
		inthostid = hostid;  /* XXX assumes sizeof long <= sizeof int */
		error =  sysctl_int(oldp, oldlenp, newp, newlen, &inthostid);
		hostid = inthostid;
		return (error);
	case KERN_CLOCKRATE:
		return (sysctl_clockrate(oldp, oldlenp));
	case KERN_BOOTTIME:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &boottime,
		    sizeof(struct timeval)));
	case KERN_VNODE:
		return (sysctl_vnode(oldp, oldlenp, p));
	case KERN_PROC:
	case KERN_PROC2:
		return (sysctl_doproc(name, namelen, oldp, oldlenp));
	case KERN_PROC_ARGS:
		return (sysctl_proc_args(name + 1, namelen - 1, oldp, oldlenp,
		     p));
	case KERN_FILE:
		return (sysctl_file(oldp, oldlenp));
	case KERN_MBSTAT:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &mbstat,
		    sizeof(mbstat)));
	case KERN_POSIX1:
		return (sysctl_rdint(oldp, oldlenp, newp, _POSIX_VERSION));
	case KERN_NGROUPS:
		return (sysctl_rdint(oldp, oldlenp, newp, NGROUPS_MAX));
	case KERN_JOB_CONTROL:
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
	case KERN_SAVED_IDS:
#ifdef _POSIX_SAVED_IDS
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case KERN_MAXPARTITIONS:
		return (sysctl_rdint(oldp, oldlenp, newp, MAXPARTITIONS));
	case KERN_RAWPARTITION:
		return (sysctl_rdint(oldp, oldlenp, newp, RAW_PART));
	case KERN_SOMAXCONN:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &somaxconn));
	case KERN_SOMINCONN:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &sominconn));
	case KERN_USERMOUNT:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &usermount));
	case KERN_RND:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &rndstats,
		    sizeof(rndstats)));
	case KERN_ARND:
		if (newp && newlen == sizeof(int)) {
			int rv, x = arc4random();
			rv = sysctl_int(oldp, oldlenp, newp, newlen, &x);
			rnd_addpool_add(x);
			return rv;
		}
		return (sysctl_rdint(oldp, oldlenp, newp, arc4random()));
	case KERN_NOSUIDCOREDUMP:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &nosuidcoredump));
	case KERN_FSYNC:
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
	case KERN_SYSVMSG:
#ifdef SYSVMSG
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case KERN_SYSVSEM:
#ifdef SYSVSEM
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case KERN_SYSVSHM:
#ifdef SYSVSHM
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case KERN_MSGBUFSIZE:
		/*
		 * deal with cases where the message buffer has
		 * become corrupted.
		 */
		if (!msgbufp || msgbufp->msg_magic != MSG_MAGIC)
			return (ENXIO);
		return (sysctl_rdint(oldp, oldlenp, newp, msgbufp->msg_bufs));
	case KERN_MSGBUF:
		/* see note above */
		if (!msgbufp || msgbufp->msg_magic != MSG_MAGIC)
			return (ENXIO);
		return (sysctl_rdstruct(oldp, oldlenp, newp, msgbufp,
		    msgbufp->msg_bufs + offsetof(struct msgbuf, msg_bufc)));
	case KERN_MALLOCSTATS:
		return (sysctl_malloc(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen, p));
	case KERN_CPTIME:
#ifdef __HAVE_CPUINFO
	{
		CPU_INFO_ITERATOR cii;
		struct cpu_info *ci;
		int i;

		bzero(cp_time, sizeof(cp_time));

		for (CPU_INFO_FOREACH(cii, ci)) {
			for (i = 0; i < CPUSTATES; i++)
				cp_time[i] += ci->ci_schedstate.spc_cp_time[i];
		}
	}
#endif
		return (sysctl_rdstruct(oldp, oldlenp, newp, &cp_time,
		    sizeof(cp_time)));
	case KERN_NCHSTATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &nchstats,
		    sizeof(struct nchstats)));
	case KERN_FORKSTAT:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &forkstat,
		    sizeof(struct forkstat)));
	case KERN_TTY:
		return (sysctl_tty(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
	case KERN_FSCALE:
		return (sysctl_rdint(oldp, oldlenp, newp, fscale));
	case KERN_CCPU:
		return (sysctl_rdint(oldp, oldlenp, newp, ccpu));
	case KERN_NPROCS:
		return (sysctl_rdint(oldp, oldlenp, newp, nprocs));
	case KERN_POOL:
		return (sysctl_dopool(name + 1, namelen - 1, oldp, oldlenp));
	case KERN_STACKGAPRANDOM:
		stackgap = stackgap_random;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &stackgap);
		if (error)
			return (error);
		/*
		 * Safety harness.
		 */
		if ((stackgap < ALIGNBYTES && stackgap != 0) ||
		    !powerof2(stackgap) || stackgap >= MAXSSIZ)
			return (EINVAL);
		stackgap_random = stackgap;
		return (0);
#if defined(SYSVMSG) || defined(SYSVSEM) || defined(SYSVSHM)  
	case KERN_SYSVIPC_INFO:
		return (sysctl_sysvipc(name + 1, namelen - 1, oldp, oldlenp));
#endif
#ifdef CRYPTO
	case KERN_USERCRYPTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &usercrypto));
	case KERN_USERASYMCRYPTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &userasymcrypto));
	case KERN_CRYPTODEVALLOWSOFT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &cryptodevallowsoft));
#endif
	case KERN_SPLASSERT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &splassert_ctl));
#ifdef SYSVSEM
	case KERN_SEMINFO:
		return (sysctl_sysvsem(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
#ifdef SYSVSHM
	case KERN_SHMINFO:
		return (sysctl_sysvshm(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
	case KERN_INTRCNT:
		return (sysctl_intrcnt(name + 1, namelen - 1, oldp, oldlenp));
#ifndef SMALL_KERNEL
	case KERN_WATCHDOG:
		return (sysctl_wdog(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
	case KERN_ALLOWPSA:
		return sysctl_int(oldp, oldlenp, newp, newlen,
		    &allowpsa);
	case KERN_ALLOWPSE:
		return sysctl_int(oldp, oldlenp, newp, newlen,
		    &allowpse);
	case KERN_EMUL:
		return (sysctl_emul(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
 	case KERN_ROOT_DEVICE:
		return sysctl_rdstring(oldp, oldlenp, newp,
		    root_devname);
	case KERN_ROOT_PARTITION:
		return sysctl_rdint(oldp, oldlenp, newp, DISKPART(rootdev));
	case KERN_PUSHRAND:
		return sysctl_int(oldp, oldlenp, newp, newlen,
		    &rnd_addpool_allow);
	case KERN_MAXCLUSTERS:
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nmbclust);
		if (!error)
			nmbclust_update();
		return (error);
	case KERN_EMULUNAME:
		error = sysctl_tstring(oldp, oldlenp, newp, newlen,
		    emul_uname, MAXEMULUNAMELEN);
		return (error);
#ifdef __HAVE_EVCOUNT
	case KERN_EVCOUNT:
		return (evcount_sysctl(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
#ifdef __HAVE_TIMECOUNTER
	case KERN_TIMECOUNTER:
		return (sysctl_tc(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * hardware related system variables.
 */
int
hw_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	extern char machine[], cpu_model[];
	int err;
	int cpuspeed;

	/* all sysctl names at this level except sensors are terminal */
	if (name[0] != HW_SENSORS && namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case HW_MACHINE:
		return (sysctl_rdstring(oldp, oldlenp, newp, machine));
	case HW_MODEL:
		return (sysctl_rdstring(oldp, oldlenp, newp, cpu_model));
	case HW_NCPU:
		return (sysctl_rdint(oldp, oldlenp, newp, 1));	/* XXX */
	case HW_BYTEORDER:
		return (sysctl_rdint(oldp, oldlenp, newp, BYTE_ORDER));
	case HW_PHYSMEM:
		return (sysctl_rdint(oldp, oldlenp, newp, ctob(physmem)));
	case HW_USERMEM:
		return (sysctl_rdint(oldp, oldlenp, newp,
		    ctob(physmem - uvmexp.wired)));
	case HW_PAGESIZE:
		return (sysctl_rdint(oldp, oldlenp, newp, PAGE_SIZE));
	case HW_DISKNAMES:
		err = sysctl_diskinit(0, p);
		if (err)
			return err;
		if (disknames)
			return (sysctl_rdstring(oldp, oldlenp, newp,
			    disknames));
		else
			return (sysctl_rdstring(oldp, oldlenp, newp, ""));
	case HW_DISKSTATS:
		err = sysctl_diskinit(1, p);
		if (err)
			return err;
		return (sysctl_rdstruct(oldp, oldlenp, newp, diskstats,
		    disk_count * sizeof(struct diskstats)));
	case HW_DISKCOUNT:
		return (sysctl_rdint(oldp, oldlenp, newp, disk_count));
	case HW_SENSORS:
		return (sysctl_sensors(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
	case HW_CPUSPEED:
		if (!cpu_cpuspeed)
			return (EOPNOTSUPP);
		err = cpu_cpuspeed(&cpuspeed);
		if (err)
			return err;
		return (sysctl_rdint(oldp, oldlenp, newp, cpuspeed));
	case HW_SETPERF:
		if (!cpu_setperf)
			return (EOPNOTSUPP);
		err = sysctl_int(oldp, oldlenp, newp, newlen, &perflevel);
		if (err)
			return err;
		if (perflevel > 100)
			perflevel = 100;
		if (perflevel < 0)
			perflevel = 0;
		if (newp)
			return (cpu_setperf(perflevel));
		else
			return (0);
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

#ifdef DEBUG
/*
 * Debugging related system variables.
 */
extern struct ctldebug debug0, debug1;
struct ctldebug debug2, debug3, debug4;
struct ctldebug debug5, debug6, debug7, debug8, debug9;
struct ctldebug debug10, debug11, debug12, debug13, debug14;
struct ctldebug debug15, debug16, debug17, debug18, debug19;
static struct ctldebug *debugvars[CTL_DEBUG_MAXID] = {
	&debug0, &debug1, &debug2, &debug3, &debug4,
	&debug5, &debug6, &debug7, &debug8, &debug9,
	&debug10, &debug11, &debug12, &debug13, &debug14,
	&debug15, &debug16, &debug17, &debug18, &debug19,
};
int
debug_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	struct ctldebug *cdp;

	/* all sysctl names at this level are name and field */
	if (namelen != 2)
		return (ENOTDIR);		/* overloaded */
	cdp = debugvars[name[0]];
	if (cdp->debugname == 0)
		return (EOPNOTSUPP);
	switch (name[1]) {
	case CTL_DEBUG_NAME:
		return (sysctl_rdstring(oldp, oldlenp, newp, cdp->debugname));
	case CTL_DEBUG_VALUE:
		return (sysctl_int(oldp, oldlenp, newp, newlen, cdp->debugvar));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}
#endif /* DEBUG */

/*
 * Validate parameters and get old / set new parameters
 * for an integer-valued sysctl function.
 */
int
sysctl_int(oldp, oldlenp, newp, newlen, valp)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	int *valp;
{
	int error = 0;

	if (oldp && *oldlenp < sizeof(int))
		return (ENOMEM);
	if (newp && newlen != sizeof(int))
		return (EINVAL);
	*oldlenp = sizeof(int);
	if (oldp)
		error = copyout(valp, oldp, sizeof(int));
	if (error == 0 && newp)
		error = copyin(newp, valp, sizeof(int));
	return (error);
}

/*
 * As above, but read-only.
 */
int
sysctl_rdint(oldp, oldlenp, newp, val)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	int val;
{
	int error = 0;

	if (oldp && *oldlenp < sizeof(int))
		return (ENOMEM);
	if (newp)
		return (EPERM);
	*oldlenp = sizeof(int);
	if (oldp)
		error = copyout((caddr_t)&val, oldp, sizeof(int));
	return (error);
}

/*
 * Array of integer values.
 */
int
sysctl_int_arr(valpp, name, namelen, oldp, oldlenp, newp, newlen)
	int **valpp;
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	if (namelen > 1)
		return (ENOTDIR);
	if (name[0] < 0 || valpp[name[0]] == NULL)
		return (EOPNOTSUPP);
	return (sysctl_int(oldp, oldlenp, newp, newlen, valpp[name[0]]));
}

/*
 * Validate parameters and get old / set new parameters
 * for an integer-valued sysctl function.
 */
int
sysctl_quad(oldp, oldlenp, newp, newlen, valp)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	int64_t *valp;
{
	int error = 0;

	if (oldp && *oldlenp < sizeof(int64_t))
		return (ENOMEM);
	if (newp && newlen != sizeof(int64_t))
		return (EINVAL);
	*oldlenp = sizeof(int64_t);
	if (oldp)
		error = copyout(valp, oldp, sizeof(int64_t));
	if (error == 0 && newp)
		error = copyin(newp, valp, sizeof(int64_t));
	return (error);
}

/*
 * As above, but read-only.
 */
int
sysctl_rdquad(oldp, oldlenp, newp, val)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	int64_t val;
{
	int error = 0;

	if (oldp && *oldlenp < sizeof(int64_t))
		return (ENOMEM);
	if (newp)
		return (EPERM);
	*oldlenp = sizeof(int64_t);
	if (oldp)
		error = copyout((caddr_t)&val, oldp, sizeof(int64_t));
	return (error);
}

/*
 * Validate parameters and get old / set new parameters
 * for a string-valued sysctl function.
 */
int
sysctl_string(oldp, oldlenp, newp, newlen, str, maxlen)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	char *str;
	int maxlen;
{
	return sysctl__string(oldp, oldlenp, newp, newlen, str, maxlen, 0);
}

int
sysctl_tstring(oldp, oldlenp, newp, newlen, str, maxlen)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	char *str;
	int maxlen;
{
	return sysctl__string(oldp, oldlenp, newp, newlen, str, maxlen, 1);
}

int
sysctl__string(oldp, oldlenp, newp, newlen, str, maxlen, trunc)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	char *str;
	int maxlen;
	int trunc;
{
	int len, error = 0;
	char c;

	len = strlen(str) + 1;
	if (oldp && *oldlenp < len) {
		if (trunc == 0 || *oldlenp == 0)
			return (ENOMEM);
	}
	if (newp && newlen >= maxlen)
		return (EINVAL);
	if (oldp) {
		if (trunc && *oldlenp < len) {
			/* save & zap NUL terminator while copying */
			c = str[*oldlenp-1];
			str[*oldlenp-1] = '\0';
			error = copyout(str, oldp, *oldlenp);
			str[*oldlenp-1] = c;
		} else {
			*oldlenp = len;
			error = copyout(str, oldp, len);
		}
	}
	if (error == 0 && newp) {
		error = copyin(newp, str, newlen);
		str[newlen] = 0;
	}
	return (error);
}

/*
 * As above, but read-only.
 */
int
sysctl_rdstring(oldp, oldlenp, newp, str)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	const char *str;
{
	int len, error = 0;

	len = strlen(str) + 1;
	if (oldp && *oldlenp < len)
		return (ENOMEM);
	if (newp)
		return (EPERM);
	*oldlenp = len;
	if (oldp)
		error = copyout(str, oldp, len);
	return (error);
}

/*
 * Validate parameters and get old / set new parameters
 * for a structure oriented sysctl function.
 */
int
sysctl_struct(oldp, oldlenp, newp, newlen, sp, len)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	void *sp;
	int len;
{
	int error = 0;

	if (oldp && *oldlenp < len)
		return (ENOMEM);
	if (newp && newlen > len)
		return (EINVAL);
	if (oldp) {
		*oldlenp = len;
		error = copyout(sp, oldp, len);
	}
	if (error == 0 && newp)
		error = copyin(newp, sp, len);
	return (error);
}

/*
 * Validate parameters and get old parameters
 * for a structure oriented sysctl function.
 */
int
sysctl_rdstruct(oldp, oldlenp, newp, sp, len)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	const void *sp;
	int len;
{
	int error = 0;

	if (oldp && *oldlenp < len)
		return (ENOMEM);
	if (newp)
		return (EPERM);
	*oldlenp = len;
	if (oldp)
		error = copyout(sp, oldp, len);
	return (error);
}

/*
 * Get file structures.
 */
int
sysctl_file(where, sizep)
	char *where;
	size_t *sizep;
{
	int buflen, error;
	struct file *fp;
	char *start = where;

	buflen = *sizep;
	if (where == NULL) {
		/*
		 * overestimate by 10 files
		 */
		*sizep = sizeof(filehead) + (nfiles + 10) * sizeof(struct file);
		return (0);
	}

	/*
	 * first copyout filehead
	 */
	if (buflen < sizeof(filehead)) {
		*sizep = 0;
		return (0);
	}
	error = copyout((caddr_t)&filehead, where, sizeof(filehead));
	if (error)
		return (error);
	buflen -= sizeof(filehead);
	where += sizeof(filehead);

	/*
	 * followed by an array of file structures
	 */
	LIST_FOREACH(fp, &filehead, f_list) {
		if (buflen < sizeof(struct file)) {
			*sizep = where - start;
			return (ENOMEM);
		}
		error = copyout((caddr_t)fp, where, sizeof (struct file));
		if (error)
			return (error);
		buflen -= sizeof(struct file);
		where += sizeof(struct file);
	}
	*sizep = where - start;
	return (0);
}

/*
 * try over estimating by 5 procs
 */
#define KERN_PROCSLOP	(5 * sizeof (struct kinfo_proc))

int
sysctl_doproc(name, namelen, where, sizep)
	int *name;
	u_int namelen;
	char *where;
	size_t *sizep;
{
	struct kinfo_proc2 kproc2;
	struct eproc eproc;
	struct proc *p;
	char *dp;
	int arg, buflen, doingzomb, elem_size, elem_count;
	int error, needed, type, op;

	dp = where;
	buflen = where != NULL ? *sizep : 0;
	needed = error = 0;
	type = name[0];

	if (type == KERN_PROC) {
		if (namelen != 3 && !(namelen == 2 &&
		    (name[1] == KERN_PROC_ALL || name[1] == KERN_PROC_KTHREAD)))
			return (EINVAL);
		op = name[1];
		arg = op == KERN_PROC_ALL ? 0 : name[2];
		elem_size = elem_count = 0;
	} else /* if (type == KERN_PROC2) */ {
		if (namelen != 5 || name[3] < 0 || name[4] < 0)
			return (EINVAL);
		op = name[1];
		arg = name[2];
		elem_size = name[3];
		elem_count = name[4];
	}
	p = LIST_FIRST(&allproc);
	doingzomb = 0;
again:
	for (; p != 0; p = LIST_NEXT(p, p_list)) {
		/*
		 * Skip embryonic processes.
		 */
		if (p->p_stat == SIDL)
			continue;
		/*
		 * Skip processes with different real uid
		 */
		if ((!allowpsa) &&
		    (curproc->p_cred->p_ruid != p->p_cred->p_ruid) &&
		    (curproc->p_cred->p_rgid))
			continue;

		/*
		 * TODO - make more efficient (see notes below).
		 */
		switch (op) {

		case KERN_PROC_PID:
			/* could do this with just a lookup */
			if (p->p_pid != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_PGRP:
			/* could do this by traversing pgrp */
			if (p->p_pgrp->pg_id != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_SESSION:
			if (p->p_session->s_leader == NULL ||
			    p->p_session->s_leader->p_pid != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_TTY:
			if ((p->p_flag & P_CONTROLT) == 0 ||
			    p->p_session->s_ttyp == NULL ||
			    p->p_session->s_ttyp->t_dev != (dev_t)arg)
				continue;
			break;

		case KERN_PROC_UID:
			if (p->p_ucred->cr_uid != (uid_t)arg)
				continue;
			break;

		case KERN_PROC_RUID:
			if (p->p_cred->p_ruid != (uid_t)arg)
				continue;
			break;

		case KERN_PROC_ALL:
			if (p->p_flag & P_SYSTEM)
				continue;
			break;
		case KERN_PROC_KTHREAD:
			/* no filtering */
			break;
		default:
			return (EINVAL);
		}
		if (type == KERN_PROC) {
			if (buflen >= sizeof(struct kinfo_proc)) {
				fill_eproc(p, &eproc);
				error = copyout((caddr_t)p,
				    &((struct kinfo_proc *)dp)->kp_proc,
				    sizeof(struct proc));
				if (error)
					return (error);
				error = copyout((caddr_t)&eproc,
				    &((struct kinfo_proc *)dp)->kp_eproc,
				    sizeof(eproc));
				if (error)
					return (error);
				dp += sizeof(struct kinfo_proc);
				buflen -= sizeof(struct kinfo_proc);
			}
			needed += sizeof(struct kinfo_proc);
		} else /* if (type == KERN_PROC2) */ {
			if (buflen >= elem_size && elem_count > 0) {
				fill_kproc2(p, &kproc2);
				/*
				 * Copy out elem_size, but not larger than
				 * the size of a struct kinfo_proc2.
				 */
				error = copyout(&kproc2, dp,
				    min(sizeof(kproc2), elem_size));
				if (error)
					return (error);
				dp += elem_size;
				buflen -= elem_size;
				elem_count--;
			}
			needed += elem_size;
		}
	}
	if (doingzomb == 0) {
		p = LIST_FIRST(&zombproc);
		doingzomb++;
		goto again;
	}
	if (where != NULL) {
		*sizep = dp - where;
		if (needed > *sizep)
			return (ENOMEM);
	} else {
		needed += KERN_PROCSLOP;
		*sizep = needed;
	}
	return (0);
}

/*
 * Fill in an eproc structure for the specified process.
 */
void
fill_eproc(struct proc *p, struct eproc *ep)
{
	struct tty *tp;

	ep->e_paddr = p;
	ep->e_sess = p->p_pgrp->pg_session;
	ep->e_pcred = *p->p_cred;
	ep->e_ucred = *p->p_ucred;
	if (p->p_stat == SIDL || P_ZOMBIE(p)) {
		ep->e_vm.vm_rssize = 0;
		ep->e_vm.vm_tsize = 0;
		ep->e_vm.vm_dsize = 0;
		ep->e_vm.vm_ssize = 0;
		bzero(&ep->e_pstats, sizeof(ep->e_pstats));
		ep->e_pstats_valid = 0;
	} else {
		struct vmspace *vm = p->p_vmspace;

		PHOLD(p);	/* need for pstats */
		ep->e_vm.vm_rssize = vm_resident_count(vm);
		ep->e_vm.vm_tsize = vm->vm_tsize;
		ep->e_vm.vm_dsize = vm->vm_dsize;
		ep->e_vm.vm_ssize = vm->vm_ssize;
		ep->e_pstats = *p->p_stats;
		ep->e_pstats_valid = 1;
		PRELE(p);
	}
	if (p->p_pptr)
		ep->e_ppid = p->p_pptr->p_pid;
	else
		ep->e_ppid = 0;
	ep->e_pgid = p->p_pgrp->pg_id;
	ep->e_jobc = p->p_pgrp->pg_jobc;
	if ((p->p_flag & P_CONTROLT) &&
	     (tp = ep->e_sess->s_ttyp)) {
		ep->e_tdev = tp->t_dev;
		ep->e_tpgid = tp->t_pgrp ? tp->t_pgrp->pg_id : NO_PID;
		ep->e_tsess = tp->t_session;
	} else
		ep->e_tdev = NODEV;
	ep->e_flag = ep->e_sess->s_ttyvp ? EPROC_CTTY : 0;
	if (SESS_LEADER(p))
		ep->e_flag |= EPROC_SLEADER;
	strncpy(ep->e_wmesg, p->p_wmesg ? p->p_wmesg : "", WMESGLEN);
	ep->e_wmesg[WMESGLEN] = '\0';
	ep->e_xsize = ep->e_xrssize = 0;
	ep->e_xccount = ep->e_xswrss = 0;
	strncpy(ep->e_login, ep->e_sess->s_login, MAXLOGNAME-1);
	ep->e_login[MAXLOGNAME-1] = '\0';
	strncpy(ep->e_emul, p->p_emul->e_name, EMULNAMELEN);
	ep->e_emul[EMULNAMELEN] = '\0';
	ep->e_maxrss = p->p_rlimit ? p->p_rlimit[RLIMIT_RSS].rlim_cur : 0;
}

/*
 * Fill in a kproc2 structure for the specified process.
 */
void
fill_kproc2(struct proc *p, struct kinfo_proc2 *ki)
{
	struct tty *tp;
	struct timeval ut, st;

	bzero(ki, sizeof(*ki));

	ki->p_paddr = PTRTOINT64(p);
	ki->p_fd = PTRTOINT64(p->p_fd);
	ki->p_stats = PTRTOINT64(p->p_stats);
	ki->p_limit = PTRTOINT64(p->p_limit);
	ki->p_vmspace = PTRTOINT64(p->p_vmspace);
	ki->p_sigacts = PTRTOINT64(p->p_sigacts);
	ki->p_sess = PTRTOINT64(p->p_session);
	ki->p_tsess = 0;	/* may be changed if controlling tty below */
	ki->p_ru = PTRTOINT64(p->p_ru);

	ki->p_eflag = 0;
	ki->p_exitsig = p->p_exitsig;
	ki->p_flag = p->p_flag;

	ki->p_pid = p->p_pid;
	if (p->p_pptr)
		ki->p_ppid = p->p_pptr->p_pid;
	else
		ki->p_ppid = 0;
	if (p->p_session->s_leader)
		ki->p_sid = p->p_session->s_leader->p_pid;
	else
		ki->p_sid = 0;
	ki->p__pgid = p->p_pgrp->pg_id;

	ki->p_tpgid = -1;	/* may be changed if controlling tty below */

	ki->p_uid = p->p_ucred->cr_uid;
	ki->p_ruid = p->p_cred->p_ruid;
	ki->p_gid = p->p_ucred->cr_gid;
	ki->p_rgid = p->p_cred->p_rgid;
	ki->p_svuid = p->p_cred->p_svuid;
	ki->p_svgid = p->p_cred->p_svgid;

	memcpy(ki->p_groups, p->p_cred->pc_ucred->cr_groups,
	    min(sizeof(ki->p_groups), sizeof(p->p_cred->pc_ucred->cr_groups)));
	ki->p_ngroups = p->p_cred->pc_ucred->cr_ngroups;

	ki->p_jobc = p->p_pgrp->pg_jobc;
	if ((p->p_flag & P_CONTROLT) && (tp = p->p_session->s_ttyp)) {
		ki->p_tdev = tp->t_dev;
		ki->p_tpgid = tp->t_pgrp ? tp->t_pgrp->pg_id : -1;
		ki->p_tsess = PTRTOINT64(tp->t_session);
	} else {
		ki->p_tdev = NODEV;
	}

	ki->p_estcpu = p->p_estcpu;
	ki->p_rtime_sec = p->p_rtime.tv_sec;
	ki->p_rtime_usec = p->p_rtime.tv_usec;
	ki->p_cpticks = p->p_cpticks;
	ki->p_pctcpu = p->p_pctcpu;

	ki->p_uticks = p->p_uticks;
	ki->p_sticks = p->p_sticks;
	ki->p_iticks = p->p_iticks;

	ki->p_tracep = PTRTOINT64(p->p_tracep);
	ki->p_traceflag = p->p_traceflag;

	ki->p_siglist = p->p_siglist;
	ki->p_sigmask = p->p_sigmask;
	ki->p_sigignore = p->p_sigignore;
	ki->p_sigcatch = p->p_sigcatch;

	ki->p_stat = p->p_stat;
	ki->p_nice = p->p_nice;

	ki->p_xstat = p->p_xstat;
	ki->p_acflag = p->p_acflag;

	strlcpy(ki->p_emul, p->p_emul->e_name, sizeof(ki->p_emul));
	strlcpy(ki->p_comm, p->p_comm, sizeof(ki->p_comm));
	strncpy(ki->p_login, p->p_session->s_login,
	    min(sizeof(ki->p_login) - 1, sizeof(p->p_session->s_login)));

	if (p->p_stat == SIDL || P_ZOMBIE(p)) {
		ki->p_vm_rssize = 0;
		ki->p_vm_tsize = 0;
		ki->p_vm_dsize = 0;
		ki->p_vm_ssize = 0;
	} else {
		struct vmspace *vm = p->p_vmspace;

		ki->p_vm_rssize = vm_resident_count(vm);
		ki->p_vm_tsize = vm->vm_tsize;
		ki->p_vm_dsize = vm->vm_dsize;
		ki->p_vm_ssize = vm->vm_ssize;

		ki->p_forw = PTRTOINT64(p->p_forw);
		ki->p_back = PTRTOINT64(p->p_back);
		ki->p_addr = PTRTOINT64(p->p_addr);
		ki->p_stat = p->p_stat;
		ki->p_swtime = p->p_swtime;
		ki->p_slptime = p->p_slptime;
#ifdef __HAVE_CPUINFO
		ki->p_schedflags = 0;
#else
		ki->p_schedflags = p->p_schedflags;
#endif
		ki->p_holdcnt = p->p_holdcnt;
		ki->p_priority = p->p_priority;
		ki->p_usrpri = p->p_usrpri;
		if (p->p_wmesg)
			strlcpy(ki->p_wmesg, p->p_wmesg, sizeof(ki->p_wmesg));
		ki->p_wchan = PTRTOINT64(p->p_wchan);

	}

	if (p->p_session->s_ttyvp)
		ki->p_eflag |= EPROC_CTTY;
	if (SESS_LEADER(p))
		ki->p_eflag |= EPROC_SLEADER;
	if (p->p_rlimit)
		ki->p_rlim_rss_cur = p->p_rlimit[RLIMIT_RSS].rlim_cur;

	/* XXX Is this double check necessary? */
	if (P_ZOMBIE(p)) {
		ki->p_uvalid = 0;
	} else {
		ki->p_uvalid = 1;

		PHOLD(p);	/* need for pstats */
		ki->p_ustart_sec = p->p_stats->p_start.tv_sec;
		ki->p_ustart_usec = p->p_stats->p_start.tv_usec;

		calcru(p, &ut, &st, 0);
		ki->p_uutime_sec = ut.tv_sec;
		ki->p_uutime_usec = ut.tv_usec;
		ki->p_ustime_sec = st.tv_sec;
		ki->p_ustime_usec = st.tv_usec;

		ki->p_uru_maxrss = p->p_stats->p_ru.ru_maxrss;
		ki->p_uru_ixrss = p->p_stats->p_ru.ru_ixrss;
		ki->p_uru_idrss = p->p_stats->p_ru.ru_idrss;
		ki->p_uru_isrss = p->p_stats->p_ru.ru_isrss;
		ki->p_uru_minflt = p->p_stats->p_ru.ru_minflt;
		ki->p_uru_majflt = p->p_stats->p_ru.ru_majflt;
		ki->p_uru_nswap = p->p_stats->p_ru.ru_nswap;
		ki->p_uru_inblock = p->p_stats->p_ru.ru_inblock;
		ki->p_uru_oublock = p->p_stats->p_ru.ru_oublock;
		ki->p_uru_msgsnd = p->p_stats->p_ru.ru_msgsnd;
		ki->p_uru_msgrcv = p->p_stats->p_ru.ru_msgrcv;
		ki->p_uru_nsignals = p->p_stats->p_ru.ru_nsignals;
		ki->p_uru_nvcsw = p->p_stats->p_ru.ru_nvcsw;
		ki->p_uru_nivcsw = p->p_stats->p_ru.ru_nivcsw;

		timeradd(&p->p_stats->p_cru.ru_utime,
			 &p->p_stats->p_cru.ru_stime, &ut);
		ki->p_uctime_sec = ut.tv_sec;
		ki->p_uctime_usec = ut.tv_usec;
		PRELE(p);
	}
}

int
sysctl_proc_args(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    struct proc *cp)
{
	struct proc *vp, *cur = curproc;
	pid_t pid;
	int op;
	struct ps_strings pss;
	struct iovec iov;
	struct uio uio;
	int error;
	size_t limit;
	int cnt;
	char **rargv, **vargv;		/* reader vs. victim */
	char *rarg, *varg;
	char *buf;

	if (namelen > 2)
		return (ENOTDIR);
	if (namelen < 2)
		return (EINVAL);

	pid = name[0];
	op = name[1];

	switch (op) {
	case KERN_PROC_ARGV:
	case KERN_PROC_NARGV:
	case KERN_PROC_ENV:
	case KERN_PROC_NENV:
		break;
	default:
		return (EOPNOTSUPP);
	}

	if ((vp = pfind(pid)) == NULL)
		return (ESRCH);

	if ((!allowpse) &&
	    (cur->p_cred->p_ruid != vp->p_cred->p_ruid) &&
	    (cur->p_cred->p_rgid))
		return (EPERM);

	if (oldp == NULL) {
		if (op == KERN_PROC_NARGV || op == KERN_PROC_NENV)
			*oldlenp = sizeof(int);
		else
			*oldlenp = ARG_MAX;	/* XXX XXX XXX */
		return (0);
	}

	if (P_ZOMBIE(vp) || (vp->p_flag & P_SYSTEM))
		return (EINVAL);

	/* Exiting - don't bother, it will be gone soon anyway */
	if ((vp->p_flag & P_WEXIT))
		return (ESRCH);

	/* Execing - danger. */
	if ((vp->p_flag & P_INEXEC))
		return (EBUSY);

	vp->p_vmspace->vm_refcnt++;	/* XXX */
	buf = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);

	iov.iov_base = &pss;
	iov.iov_len = sizeof(pss);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;	
	uio.uio_offset = (off_t)PS_STRINGS;
	uio.uio_resid = sizeof(pss);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = cp;

	if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
		goto out;

	if (op == KERN_PROC_NARGV) {
		error = sysctl_rdint(oldp, oldlenp, NULL, pss.ps_nargvstr);
		goto out;
	}
	if (op == KERN_PROC_NENV) {
		error = sysctl_rdint(oldp, oldlenp, NULL, pss.ps_nenvstr);
		goto out;
	}

	if (op == KERN_PROC_ARGV) {
		cnt = pss.ps_nargvstr;
		vargv = pss.ps_argvstr;
	} else {
		cnt = pss.ps_nenvstr;
		vargv = pss.ps_envstr;
	}

	/* -1 to have space for a terminating NUL */
	limit = *oldlenp - 1;
	*oldlenp = 0;

	rargv = oldp;

	/*
	 * *oldlenp - number of bytes copied out into readers buffer.
	 * limit - maximal number of bytes allowed into readers buffer.
	 * rarg - pointer into readers buffer where next arg will be stored.
	 * rargv - pointer into readers buffer where the next rarg pointer
	 *  will be stored.
	 * vargv - pointer into victim address space where the next argument
	 *  will be read.
	 */

	/* space for cnt pointers and a NULL */
	rarg = (char *)(rargv + cnt + 1);
	*oldlenp += (cnt + 1) * sizeof(char **);

	while (cnt > 0 && *oldlenp < limit) {
		size_t len, vstrlen;

		/* Write to readers argv */
		if ((error = copyout(&rarg, rargv, sizeof(rarg))) != 0)
			goto out;

		/* read the victim argv */
		iov.iov_base = &varg;
		iov.iov_len = sizeof(varg);
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(vaddr_t)vargv;
		uio.uio_resid = sizeof(varg);
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = cp;
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
			goto out;

		if (varg == NULL)
			break;

		/*
		 * read the victim arg. We must jump through hoops to avoid
		 * crossing a page boundary too much and returning an error.
		 */
more:
		len = PAGE_SIZE - (((vaddr_t)varg) & PAGE_MASK);
		/* leave space for the terminating NUL */
		iov.iov_base = buf;
		iov.iov_len = len;
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(vaddr_t)varg;
		uio.uio_resid = len;
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = cp;
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
			goto out;

		for (vstrlen = 0; vstrlen < len; vstrlen++) {
			if (buf[vstrlen] == '\0')
				break;
		}

		/* Don't overflow readers buffer. */
		if (*oldlenp + vstrlen + 1 >= limit) {
			error = ENOMEM;
			goto out;
		}

		if ((error = copyout(buf, rarg, vstrlen)) != 0)
			goto out;

		*oldlenp += vstrlen;
		rarg += vstrlen;

		/* The string didn't end in this page? */
		if (vstrlen == len) {
			varg += vstrlen;
			goto more;
		}

		/* End of string. Terminate it with a NUL */
		buf[0] = '\0';
		if ((error = copyout(buf, rarg, 1)) != 0)
			goto out;
		*oldlenp += 1;
		rarg += 1;

		vargv++;
		rargv++;
		cnt--;
	}

	if (*oldlenp >= limit) {
		error = ENOMEM;
		goto out;
	}

	/* Write the terminating null */
	rarg = NULL;
	error = copyout(&rarg, rargv, sizeof(rarg));

out:
	uvmspace_free(vp->p_vmspace);
	free(buf, M_TEMP);
	return (error);
}

/*
 * Initialize disknames/diskstats for export by sysctl. If update is set,
 * then we simply update the disk statistics information.
 */
int
sysctl_diskinit(update, p)
	int update;
	struct proc *p;
{
	struct diskstats *sdk;
	struct disk *dk;
	int i, tlen, l;

	if ((i = lockmgr(&sysctl_disklock, LK_EXCLUSIVE, NULL, p)) != 0)
		return i;

	if (disk_change) {
		for (dk = TAILQ_FIRST(&disklist), tlen = 0; dk;
		    dk = TAILQ_NEXT(dk, dk_link))
			tlen += strlen(dk->dk_name) + 1;
		tlen++;

		if (disknames)
			free(disknames, M_SYSCTL);
		if (diskstats)
			free(diskstats, M_SYSCTL);
		diskstats = NULL;
		disknames = NULL;
		diskstats = malloc(disk_count * sizeof(struct diskstats),
		    M_SYSCTL, M_WAITOK);
		disknames = malloc(tlen, M_SYSCTL, M_WAITOK);
		disknames[0] = '\0';

		for (dk = TAILQ_FIRST(&disklist), i = 0, l = 0; dk;
		    dk = TAILQ_NEXT(dk, dk_link), i++) {
			snprintf(disknames + l, tlen - l, "%s,",
			    dk->dk_name ? dk->dk_name : "");
			l += strlen(disknames + l);
			sdk = diskstats + i;
			strlcpy(sdk->ds_name, dk->dk_name,
			    sizeof(sdk->ds_name));
			sdk->ds_busy = dk->dk_busy;
			sdk->ds_rxfer = dk->dk_rxfer;
			sdk->ds_wxfer = dk->dk_wxfer;
			sdk->ds_seek = dk->dk_seek;
			sdk->ds_rbytes = dk->dk_rbytes;
			sdk->ds_wbytes = dk->dk_wbytes;
			sdk->ds_attachtime = dk->dk_attachtime;
			sdk->ds_timestamp = dk->dk_timestamp;
			sdk->ds_time = dk->dk_time;
		}

		/* Eliminate trailing comma */
		if (l != 0)
			disknames[l - 1] = '\0';
		disk_change = 0;
	} else if (update) {
		/* Just update, number of drives hasn't changed */
		for (dk = TAILQ_FIRST(&disklist), i = 0; dk;
		    dk = TAILQ_NEXT(dk, dk_link), i++) {
			sdk = diskstats + i;
			strlcpy(sdk->ds_name, dk->dk_name,
			    sizeof(sdk->ds_name));
			sdk->ds_busy = dk->dk_busy;
			sdk->ds_rxfer = dk->dk_rxfer;
			sdk->ds_wxfer = dk->dk_wxfer;
			sdk->ds_seek = dk->dk_seek;
			sdk->ds_rbytes = dk->dk_rbytes;
			sdk->ds_wbytes = dk->dk_wbytes;
			sdk->ds_attachtime = dk->dk_attachtime;
			sdk->ds_timestamp = dk->dk_timestamp;
			sdk->ds_time = dk->dk_time;
		}
	}
	lockmgr(&sysctl_disklock, LK_RELEASE, NULL, p);
	return 0;
}

#if defined(SYSVMSG) || defined(SYSVSEM) || defined(SYSVSHM)
int
sysctl_sysvipc(name, namelen, where, sizep)
	int *name;
	u_int namelen;
	void *where;
	size_t *sizep;
{
#ifdef SYSVMSG
	struct msg_sysctl_info *msgsi = NULL;
#endif
#ifdef SYSVSEM
	struct sem_sysctl_info *semsi = NULL;
#endif
#ifdef SYSVSHM
	struct shm_sysctl_info *shmsi = NULL;
#endif
	size_t infosize, dssize, tsize, buflen;
	int i, nds, error, ret;
	void *buf;

	if (namelen != 1)
		return (EINVAL);

	buflen = *sizep;

	switch (*name) {
	case KERN_SYSVIPC_MSG_INFO:
#ifdef SYSVMSG
		infosize = sizeof(msgsi->msginfo);
		nds = msginfo.msgmni;
		dssize = sizeof(msgsi->msgids[0]);
		break;
#else
		return (EOPNOTSUPP);
#endif
	case KERN_SYSVIPC_SEM_INFO:
#ifdef SYSVSEM
		infosize = sizeof(semsi->seminfo);
		nds = seminfo.semmni;
		dssize = sizeof(semsi->semids[0]);
		break;
#else
		return (EOPNOTSUPP);
#endif
	case KERN_SYSVIPC_SHM_INFO:
#ifdef SYSVSHM
		infosize = sizeof(shmsi->shminfo);
		nds = shminfo.shmmni;
		dssize = sizeof(shmsi->shmids[0]);
		break;
#else
		return (EOPNOTSUPP);
#endif
	default:
		return (EINVAL);
	}
	tsize = infosize + (nds * dssize);

	/* Return just the total size required. */
	if (where == NULL) {
		*sizep = tsize;
		return (0);
	}

	/* Not enough room for even the info struct. */
	if (buflen < infosize) {
		*sizep = 0;
		return (ENOMEM);
	}
	buf = malloc(min(tsize, buflen), M_TEMP, M_WAITOK);
	bzero(buf, min(tsize, buflen));

	switch (*name) { 
#ifdef SYSVMSG
	case KERN_SYSVIPC_MSG_INFO:
		msgsi = (struct msg_sysctl_info *)buf;
		msgsi->msginfo = msginfo;
		break;
#endif
#ifdef SYSVSEM
	case KERN_SYSVIPC_SEM_INFO:
		semsi = (struct sem_sysctl_info *)buf;
		semsi->seminfo = seminfo;
		break;
#endif
#ifdef SYSVSHM
	case KERN_SYSVIPC_SHM_INFO:
		shmsi = (struct shm_sysctl_info *)buf;
		shmsi->shminfo = shminfo;
		break;
#endif
	}
	buflen -= infosize;

	ret = 0;
	if (buflen > 0) {
		/* Fill in the IPC data structures.  */
		for (i = 0; i < nds; i++) {
			if (buflen < dssize) {
				ret = ENOMEM;
				break;
			}
			switch (*name) { 
#ifdef SYSVMSG
			case KERN_SYSVIPC_MSG_INFO:
				bcopy(&msqids[i], &msgsi->msgids[i], dssize);
				break;
#endif
#ifdef SYSVSEM
			case KERN_SYSVIPC_SEM_INFO:
				if (sema[i] != NULL)
					bcopy(sema[i], &semsi->semids[i],
					    dssize);
				else
					bzero(&semsi->semids[i], dssize);
				break;
#endif
#ifdef SYSVSHM
			case KERN_SYSVIPC_SHM_INFO:
				if (shmsegs[i] != NULL)
					bcopy(shmsegs[i], &shmsi->shmids[i],
					    dssize);
				else
					bzero(&shmsi->shmids[i], dssize);
				break;
#endif
			}
			buflen -= dssize;
		}
	}
	*sizep -= buflen;
	error = copyout(buf, where, *sizep);
	free(buf, M_TEMP);
	/* If copyout succeeded, use return code set earlier. */
	return (error ? error : ret);
}
#endif /* SYSVMSG || SYSVSEM || SYSVSHM */

int
sysctl_intrcnt(int *name, u_int namelen, void *oldp, size_t *oldlenp)
{
#ifdef __HAVE_EVCOUNT
	return (evcount_sysctl(name, namelen, oldp, oldlenp, NULL, 0));
#else
	extern int intrcnt[], eintrcnt[];
	extern char intrnames[], eintrnames[];
	char *intrname;
	int nintr, i;

	nintr = (off_t)(eintrcnt - intrcnt);

	if (name[0] != KERN_INTRCNT_NUM) {
		if (namelen != 2)
			return (ENOTDIR);
		if (name[1] < 0 || name[1] >= nintr)
			return (EINVAL);
		i = name[1];
	}

	switch (name[0]) {
	case KERN_INTRCNT_NUM:
		return (sysctl_rdint(oldp, oldlenp, NULL, nintr));
		break;
	case KERN_INTRCNT_CNT:
		return (sysctl_rdquad(oldp, oldlenp, NULL, intrcnt[i]));
	case KERN_INTRCNT_NAME:
		intrname = intrnames;
		while (i > 0) {
			intrname += strlen(intrname) + 1;
			i--;
			if (intrname > eintrnames)
				return (EINVAL);
		}
		return (sysctl_rdstring(oldp, oldlenp, NULL, intrname));
	default:
		return (EOPNOTSUPP);
	}
#endif
}

int nsensors = 0;
struct sensors_head sensors = SLIST_HEAD_INITIALIZER(&sensors);

int
sysctl_sensors(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	struct sensor *s = NULL;
	int num;

	if (namelen != 1)
		return (ENOTDIR);

	num = name[0];
	if (num < 0 || num >= nsensors)
		return (ENXIO);

	SLIST_FOREACH(s, &sensors, list)
		if (s->num == num)
			break;

	return (sysctl_rdstruct(oldp, oldlenp, newp, s, sizeof(struct sensor)));
}

int
sysctl_emul(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	int enabled, error;
	struct emul *e;

	if (name[0] == KERN_EMUL_NUM) {
		if (namelen != 1)
			return (ENOTDIR);
		return (sysctl_rdint(oldp, oldlenp, newp, nexecs));
	}

	if (namelen != 2)
		return (ENOTDIR);
	if (name[0] > nexecs || name[0] < 0)
		return (EINVAL);
	e = execsw[name[0] - 1].es_emul;
	if (e == NULL)
		return (EINVAL);

	switch (name[1]) {
	case KERN_EMUL_NAME:
		return (sysctl_rdstring(oldp, oldlenp, newp, e->e_name));
	case KERN_EMUL_ENABLED:
		enabled = (e->e_flags & EMUL_ENABLED);
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		    &enabled);
		e->e_flags = (enabled & EMUL_ENABLED);
		return (error);
	default:
		return (EINVAL);
	}
}

/* should be last because of declarations */
void
sysctl_init_values(void)
{
	strlcpy(emul_uname, ostype, MAXEMULUNAMELEN);
}
@


1.20
log
@more sync to openbsd
@
text
@a382 5
#ifdef GPROF
	case KERN_PROF:
		return (sysctl_doprof(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
@


1.19
log
@since we don't support YP, it's pretty pointless to support setting
the domain name in the kernel, and it's been already removed from the
userland anyways.
@
text
@d1 1
a1 1
/*	$MirBSD: src/sys/kern/kern_sysctl.c,v 1.18 2004/06/16 21:06:37 tg Exp $	*/
d3 1
a3 1
/*	$OpenBSD: kern_sysctl.c,v 1.106 2004/04/19 22:52:33 tedu Exp $	*/
d68 6
d112 1
d300 6
d461 14
d503 1
a503 1
		    !powerof2(stackgap) || stackgap >= 256 * 1024 * 1024)
d567 10
a598 2
	static int perflevel = 100;
	int operflevel;
a649 1
		operflevel = perflevel;
a652 2
		if (perflevel == operflevel)
			return (0);
d657 4
a660 1
		return (cpu_setperf(perflevel));
d1343 3
d1347 1
d1446 8
a1501 6
	if (limit > 8 * PAGE_SIZE) {
		/* Don't allow a denial of service. */
		error = E2BIG;
		goto out;
	}

d1830 3
d1853 1
a1853 1
		return (sysctl_rdint(oldp, oldlenp, NULL, intrcnt[i]));
d1866 1
d1883 1
a1883 1
	if (num >= nsensors)
@


1.18
log
@MirSolutions presents: user-settable "uname -s" for the Linuxulator.
@
text
@d1 1
a1 1
/*	$MirBSD: src/sys/kern/kern_sysctl.c,v 1.17 2004/05/23 20:16:28 tg Exp $	*/
d239 1
a239 1
char domainname[MAXHOSTNAMELEN];
d345 1
a345 4
		error = sysctl_tstring(oldp, oldlenp, newp, newlen,
		    domainname, sizeof(domainname));
		if (newp && !error)
			domainnamelen = newlen;
@


1.17
log
@* first futile attempt to merge OpenBSD 3.5-current
* damn! they got pxeboot! -> disable for now
  (there's still ports/sysutils/pxegrub; we'll have pxeboot later)
* I don't know if that ... bootloader still works
* nuke netbsd emul (was unused anyways)
* nuke a plethora of syscalls not being used, and mark
  the other two (COMPAT_35) for deletion RSN
* merge new MI-GENERIC into i386 GENERIC
* resolve numeric conflicts for
  - syscalls
  - sysctls
  - device majors
  - pcidevs
* (c) cleanup - no need to add a bsd-like licence when
  there's already one; just add my name
* and much more
@
text
@d1 1
a1 1
/*	$MirBSD: src/sys/kern/kern_sysctl.c,v 1.16 2004/04/29 18:36:17 tg Exp $	*/
d119 2
d124 2
d250 2
d539 4
d1884 7
@


1.16
log
@* use rnd_addpool_add() not add_true_randomness() in FFS
* add sysctl to block rnd_addpool_add() calls
@
text
@d1 1
a1 1
/*	$MirBSD: src/sys/kern/kern_sysctl.c,v 1.15 2004/04/26 20:54:13 tg Exp $	*/
d3 1
a3 1
/*	$OpenBSD: kern_sysctl.c,v 1.98 2004/01/07 21:51:30 millert Exp $	*/
d96 2
d104 2
a105 2
int (*cpu_cpuspeed)(void *, size_t *, void *, size_t);
int (*cpu_setperf)(void *, size_t *, void *, size_t);
d528 5
d554 3
d601 4
a604 1
		return (cpu_cpuspeed(oldp, oldlenp, newp, newlen));
d608 11
a618 1
		return (cpu_setperf(oldp, oldlenp, newp, newlen));
d719 20
d1601 2
d1604 2
a1605 1
			sdk->ds_xfer = dk->dk_xfer;
d1607 2
a1608 1
			sdk->ds_bytes = dk->dk_bytes;
d1623 2
d1626 2
a1627 1
			sdk->ds_xfer = dk->dk_xfer;
d1629 2
a1630 1
			sdk->ds_bytes = dk->dk_bytes;
d1851 1
a1851 1
		return (sysctl_rdint(oldp, oldlenp, newp, nemuls));
d1856 4
a1859 1
	if (name[0] > nemuls || name[0] < 0)
a1860 1
	e = emulsw[name[0] - 1];
@


1.15
log
@make KERN_ARND writable, adding the argument via the rnd_addpool_add
API just introduced so to not have users flood the kernel
@
text
@d1 1
a1 1
/*	$MirBSD: src/sys/kern/kern_sysctl.c,v 1.14 2004/01/28 20:42:51 tg Exp $	*/
d510 2
a511 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &allowpsa));
d513 2
a514 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &allowpse));
d519 2
a520 2
		return (sysctl_rdstring(oldp, oldlenp, newp,
		    root_devname));
d522 4
a525 1
		return (sysctl_rdint(oldp, oldlenp, newp, DISKPART(rootdev)));
@


1.14
log
@* use dkcsum data to increase randomness :)
* it seems to just have been a problem with libgcc.so,
  so un-do last commit wrt the comma in toplev.c
* use -nostdlib when linking libgcc.so
* compile fixes in kernel land
* nuke wt, it doesn't compile (poll changes, at least)
@
text
@d1 1
a1 1
/*	$MirBSD: kern_sysctl.c,v 1.13 2004/01/27 17:42:34 tg Exp $	*/
d396 6
@


1.13
log
@first part of mergeing OpenBSD and fixing whitespace and RCS IDs
@
text
@d1 1
a1 1
/*	$MirBSD: kern_sysctl.c,v 1.12 2003/12/25 21:25:32 tg Exp $	*/
d980 2
a981 2
		    (cur->p_cred->p_ruid != p->p_cred->p_ruid) &&
		    (cur->p_cred->p_rgid))
@


1.12
log
@* complete merging OpenBSD import for src/sys
* in addition to that, cope for some miros specialties
new:
+ the "OpenBSD" and "OpenBSDx_y" (x=3 y=4) preprocessor syms
	aren't defined any more
+ the "MirOS" symbol is defined to the same as MACHINE_OS
	(ie, BSD or Linux without string operator) iff
	the system is running MirBSD or MirLinux
bump patchlevel
@
text
@d1 1
a1 1
/*	$MirBSD: kern_sysctl.c,v 1.11 2003/10/03 13:47:23 tg Exp $	*/
d3 1
a3 1
/*	$OpenBSD: kern_sysctl.c,v 1.93 2003/12/18 23:46:20 tedu Exp $	*/
d87 2
d273 1
d355 2
a356 1
		return (sysctl_doproc(name + 1, namelen - 1, oldp, oldlenp));
d498 1
d502 1
d940 1
a940 5
	struct proc *p, *cur = curproc;
	struct kinfo_proc *dp = (struct kinfo_proc *)where;
	int needed = 0;
	int buflen = where != NULL ? *sizep : 0;
	int doingzomb;
d942 25
a966 5
	int error = 0;

	if (namelen != 2 && !(namelen == 1 &&
	    (name[0] == KERN_PROC_ALL || name[0] == KERN_PROC_KTHREAD)))
		return (EINVAL);
a985 1
		 * do by session.
d987 1
a987 1
		switch (name[0]) {
d991 1
a991 1
			if (p->p_pid != (pid_t)name[1])
d997 7
a1003 1
			if (p->p_pgrp->pg_id != (pid_t)name[1])
d1010 1
a1010 1
			    p->p_session->s_ttyp->t_dev != (dev_t)name[1])
d1015 1
a1015 1
			if (p->p_ucred->cr_uid != (uid_t)name[1])
d1020 1
a1020 1
			if (p->p_cred->p_ruid != (uid_t)name[1])
d1028 5
d1034 33
a1066 12
		if (buflen >= sizeof(struct kinfo_proc)) {
			fill_eproc(p, &eproc);
			error = copyout((caddr_t)p, &dp->kp_proc,
					sizeof(struct proc));
			if (error)
				return (error);
			error = copyout((caddr_t)&eproc, &dp->kp_eproc,
					sizeof(eproc));
			if (error)
				return (error);
			dp++;
			buflen -= sizeof(struct kinfo_proc);
a1067 1
		needed += sizeof(struct kinfo_proc);
d1075 1
a1075 1
		*sizep = (caddr_t)dp - where;
d1141 162
@


1.11
log
@finish the broken last commit (new sysctls from nbsd)
@
text
@d1 1
a1 2
/*	$MirBSD: kern_sysctl.c,v 1.10 2003/08/31 20:54:58 tg Exp $	*/
/*	$OpenBSD: kern_sysctl.c,v 1.89 2003/08/23 20:02:59 tedu Exp $	*/
d3 2
d100 3
d161 1
a161 1
		if (name[2] == KERN_VNODE)	/* XXX */
d256 1
a256 1
	int error, level, inthostid, oldsgap;
d296 1
a296 1
		return (sysctl_rdint(oldp, oldlenp, newp, OpenBSD));
d453 4
a456 3
		oldsgap = stackgap_random;

		error = sysctl_int(oldp, oldlenp, newp, newlen, &stackgap_random);
d460 2
a461 4
		if ((stackgap_random < ALIGNBYTES && stackgap_random != 0) ||
		    !powerof2(stackgap_random) ||
		    stackgap_random > PAGE_SIZE * 2) {
			stackgap_random = oldsgap;
d463 2
a464 2
		}
		return (error);
d573 8
@


1.11.2.1
log
@verified exec ported from NetBSD 1.6.1 / Stephanie patches for OpenBSD 3.4:
 - prevent execution of trojaned applications (f.e. netstat,ps,..)
 - activated in GENERIC, but must be enabled with sysctl -w kern.vexec.op=1
 - you have to generate the fingerprint database with fpgen.sh from sbin/vexecctl/

TODO:
- fix a problem with hardlinked applications (f.e. /bin/chown and /bin/chgrp)
  error: "vexec_inodeadd: Received invalid fingerprint for an existing entry! Entry not modified."
- patch MAKEDEV.mi to create devicenode /dev/vexec
- create sample database when doing make release (/etc/vexec.conf.release)
- more testing, test it on sparc
- do performance tests
@
text
@d1 1
a1 1
/*	$MirBSD: kern_sysctl.c,v 1.11 2003/10/03 13:47:23 tg Exp $	*/
a66 1
#include <sys/vexec.h>
a97 1
int sysctl_vexec(int *, u_int, void *, size_t *, void *, size_t);
a277 1
		case KERN_VEXEC:
a502 3
	case KERN_VEXEC:
		return (sysctl_vexec(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
a942 1

a1587 46

/*
 * Handle kernel vexec sysctls.
 */
int
sysctl_vexec(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{	

	switch (name[0]) {
	case KERN_VEXEC_OP:
		/*
		 * In multi-user mode(s), if Vexec is already
		 * enabled just return because it's boolean and we
		 * don't want to lower it.
		 */
		if ((securelevel > 0) && security_vexec && newp)
			return (EPERM);

		return (sysctl_int(oldp, oldlenp, newp, newlen, 
		    &security_vexec));

	case KERN_VEXEC_VERBOSE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &security_vexec_verbose));

	case KERN_VEXEC_STRICT:
		/* Raise only in multi-user. */
		if ((securelevel > 0) && security_vexec_strict && newp)
			return (EPERM);

		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &security_vexec_strict));

	default:
		return (EOPNOTSUPP);
	}

	/* NOTREACHED */
}

@


1.10
log
@Merge import of OpenBSD source, ports and XF4 tree.

While here,
o clean up differences where possible
o whitespace cleanup
o ifdef ./. if defined()
o '...' ./. "..."
o echo foo > bar ./. echo foo >bar
o `...` ./. $(...) ./. $$(...)
o `...' ./. '...'
o modernize "our" tree, e.g. WWW in ports
o fix some typos and brainos introduced when renaming OpenBSD to MirBSD
o use hardware 80387 by default
o migrate Apache 1.3.28 OpenBSD ./. MirBSD ./. KAME
o work around as many CVS bugs as possible (add back/delete files, ...)

Synchronize stuff, ready for ongoing changes.
@
text
@d1 1
a1 1
/*	$MirBSD: kern_sysctl.c,v 1.9 2003/08/17 18:56:36 tg Exp $	*/
d3 1
a3 1
/*	$NetBSD: kern_sysctl.c,v 1.17 1996/05/20 17:49:05 mrg Exp $	*/
d66 1
d99 2
d503 5
@


1.9
log
@merge OpenBSD, remove a few 0x60
@
text
@d1 2
a2 2
/*	$MirBSD: kern_sysctl.c,v 1.8 2003/08/16 15:25:47 tg Exp $	*/
/*	$OpenBSD: kern_sysctl.c,v 1.85 2003/08/15 20:32:18 tedu Exp $	*/
d96 1
d274 1
d315 2
a316 2
		if ((securelevel > 0 || level < -1)
		    && level < securelevel && p->p_pid != 1)
d497 3
d1546 33
@


1.8
log
@Merge OpenBSD
@
text
@d1 2
a2 2
/*	$MirBSD: kern_sysctl.c,v 1.7 2003/06/19 16:44:36 tg Exp $	*/
/*	$OpenBSD: kern_sysctl.c,v 1.84 2003/08/06 21:08:07 millert Exp $	*/
d138 1
a138 1
	    (error = suser(p->p_ucred, &p->p_acflag)))
@


1.7
log
@merge cvs import - OpenBSD tree as of Thu Jun 19 16:13:15 UTC 2003
@
text
@d1 2
a2 2
/*	$MirBSD: kern_sysctl.c,v 1.6 2003/06/06 18:29:15 tg Exp $	*/
/*	$OpenBSD: kern_sysctl.c,v 1.83 2003/06/10 21:50:26 mickey Exp $	*/
d1249 1
a1249 1
		*oldlenp += 1;;
@


1.6
log
@Merge OpenBSD-current
@
text
@d1 2
a2 2
/*	$MirBSD: kern_sysctl.c,v 1.5 2003/05/05 19:20:45 tg Exp $	*/
/*	$OpenBSD: kern_sysctl.c,v 1.82 2003/06/02 23:28:06 millert Exp $	*/
d567 2
a568 1
struct ctldebug debug0, debug1, debug2, debug3, debug4;
@


1.5
log
@merge last cvs import conflicts

TODO:
 - sync the various files
 - make a kernel that can build the new W^X
   (i.e. temporarily disable the old W^X)
 - build new kernel, binutils, ld.so, userland
 - import new flag day change
 - build new binutils, ld.so, userland, kernel

includes:
CVSROOT:        /cvs
Module name:    src
Changes by:     drahn@@cvs.openbsd.org   2003/04/28 15:32:08

Modified files:
        lib/libc/sys   : mquery.c
        libexec/ld.so  : library_mquery.c
        libexec/ld.so/i386: archdep.h
        sys/kern       : syscalls.master
        sys/sys        : mman.h
        sys/uvm        : uvm_mmap.c

Log message:
Change mquery() function call signature to be the same a mmap(). It
needs the prot/flags info and passing the addresses via arg/return allows
it to be traced via ktrace better than an in/out paramter.
This adds a new mquery syscall and renames the old one to omquery.
New kernel _MUST_ be built, booted, and 'make includes' before building
ld.so with this change.
@
text
@d1 2
a2 2
/*	$MirBSD: kern_sysctl.c,v 1.4 2003/05/03 22:22:41 tg Exp $	*/
/*	$OpenBSD: kern_sysctl.c,v 1.81 2003/05/03 21:14:59 deraadt Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@tedu@@ teaches: can't fail
@
text
@d1 2
a2 2
/*	$MirBSD: kern_sysctl.c,v 1.3 2003/05/03 21:58:22 tg Exp $	*/
/*	$OpenBSD: kern_sysctl.c,v 1.79 2003/01/21 16:59:23 markus Exp $	*/
d69 1
d99 1
d521 2
a522 2
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
d558 3
d1310 1
a1310 1
			l += sprintf(disknames + l, "%s,",
d1312 1
d1520 24
@


1.3
log
@when preparing the allowpsX diff, clean up after Jedi/Sector One,
and add RCS Id
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
d1409 1
a1409 3
	if ((buf = malloc(min(tsize, buflen), M_TEMP, M_WAITOK)) == NULL)
		return (ENOMEM);

@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 1
d1409 3
a1411 3
	if ((buf = malloc(min(tsize, buflen), M_TEMP, M_WAITOK)) == NULL) {
	return (ENOMEM);
    }
@


1.1
log
@Initial revision
@
text
@d234 1
d285 2
d490 6
d907 3
a909 3
	register struct proc *p;
	register struct kinfo_proc *dp = (struct kinfo_proc *)where;
	register int needed = 0;
d928 8
d1068 1
a1068 1
	struct proc *vp;
d1102 5
d1347 1
a1347 1
	struct msg_sysctl_info *msgsi;
d1350 1
a1350 1
	struct sem_sysctl_info *semsi;
d1353 1
a1353 1
	struct shm_sysctl_info *shmsi;
d1408 3
a1410 1
	buf = malloc(min(tsize, buflen), M_TEMP, M_WAITOK);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of now, CTM delta 3255, just before the i386 flag day
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.81 2003/05/03 21:14:59 deraadt Exp $	*/
a67 1
#include <sys/sensors.h>
a96 1
int sysctl_sensors(int *, u_int, void *, size_t *, void *, size_t);
d509 2
a510 2
	/* all sysctl names at this level except sensors are terminal */
	if (name[0] != HW_SENSORS && namelen != 1)
a545 3
	case HW_SENSORS:
		return (sysctl_sensors(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
d1282 1
a1282 1
			snprintf(disknames + l, tlen - l, "%s,",
a1283 1
			l += strlen(disknames + l);
a1490 24
}

int nsensors = 0;
struct sensors_head sensors = SLIST_HEAD_INITIALIZER(&sensors);

int
sysctl_sensors(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	struct sensor *s = NULL;
	int num;

	if (namelen != 1)
		return (ENOTDIR);

	num = name[0];
	if (num >= nsensors)
		return (ENXIO);

	SLIST_FOREACH(s, &sensors, list)
		if (s->num == num)
			break;

	return (sysctl_rdstruct(oldp, oldlenp, newp, s, sizeof(struct sensor)));
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.82 2003/06/02 23:28:06 millert Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.83 2003/06/10 21:50:26 mickey Exp $	*/
d557 1
a557 2
extern struct ctldebug debug0, debug1;
struct ctldebug debug2, debug3, debug4;
@


1.1.1.5
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.84 2003/08/06 21:08:07 millert Exp $	*/
d1226 1
a1226 1
		*oldlenp += 1;
@


1.1.1.6
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.85 2003/08/15 20:32:18 tedu Exp $	*/
d137 1
a137 1
	    (error = suser(p, 0)))
@


1.1.1.7
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.89 2003/08/23 20:02:59 tedu Exp $	*/
a94 1
int sysctl_emul(int *, u_int, void *, size_t *, void *, size_t);
a270 1
		case KERN_EMUL:
d309 2
a310 2
		if ((securelevel > 0 || level < -1) &&
		    level < securelevel && p->p_pid != 1)
a484 3
	case KERN_EMUL:
		return (sysctl_emul(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
a1517 33
}

int
sysctl_emul(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	int enabled, error;
	struct emul *e;

	if (name[0] == KERN_EMUL_NUM) {
		if (namelen != 1)
			return (ENOTDIR);
		return (sysctl_rdint(oldp, oldlenp, newp, nemuls));
	}

	if (namelen != 2)
		return (ENOTDIR);
	if (name[0] > nemuls || name[0] < 0)
		return (EINVAL);
	e = emulsw[name[0] - 1];

	switch (name[1]) {
	case KERN_EMUL_NAME:
		return (sysctl_rdstring(oldp, oldlenp, newp, e->e_name));
	case KERN_EMUL_ENABLED:
		enabled = (e->e_flags & EMUL_ENABLED);
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		    &enabled);
		e->e_flags = (enabled & EMUL_ENABLED);
		return (error);
	default:
		return (EINVAL);
	}
@


1.1.1.8
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.93 2003/12/18 23:46:20 tedu Exp $	*/
a96 3
int (*cpu_cpuspeed)(void *, size_t *, void *, size_t);
int (*cpu_setperf)(void *, size_t *, void *, size_t);

d153 1
a153 1
		if (name[1] == KERN_VNODE)	/* XXX */
d247 1
a247 1
	int error, level, inthostid, stackgap;
d442 3
a444 4
		stackgap = stackgap_random;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &stackgap);
		if (error)
			return (error);
d448 4
a451 2
		if ((stackgap < ALIGNBYTES && stackgap != 0) ||
		    !powerof2(stackgap) || stackgap >= 256 * 1024 * 1024)
d453 2
a454 2
		stackgap_random = stackgap;
		return (0);
a551 8
	case HW_CPUSPEED:
		if (!cpu_cpuspeed)
			return (EOPNOTSUPP);
		return (cpu_cpuspeed(oldp, oldlenp, newp, newlen));
	case HW_SETPERF:
		if (!cpu_setperf)
			return (EOPNOTSUPP);
		return (cpu_setperf(oldp, oldlenp, newp, newlen));
@


1.1.1.9
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.98 2004/01/07 21:51:30 millert Exp $	*/
a83 2
#define	PTRTOINT64(_x)	((u_int64_t)(u_long)(_x))

a264 1
		case KERN_PROC2:
d344 1
a344 2
	case KERN_PROC2:
		return (sysctl_doproc(name, namelen, oldp, oldlenp));
a485 1
#ifndef SMALL_KERNEL
a488 1
#endif
d915 5
a919 1
	struct kinfo_proc2 kproc2;
d921 5
a925 25
	struct proc *p;
	char *dp;
	int arg, buflen, doingzomb, elem_size, elem_count;
	int error, needed, type, op;

	dp = where;
	buflen = where != NULL ? *sizep : 0;
	needed = error = 0;
	type = name[0];

	if (type == KERN_PROC) {
		if (namelen != 3 && !(namelen == 2 &&
		    (name[1] == KERN_PROC_ALL || name[1] == KERN_PROC_KTHREAD)))
			return (EINVAL);
		op = name[1];
		arg = op == KERN_PROC_ALL ? 0 : name[2];
		elem_size = elem_count = 0;
	} else /* if (type == KERN_PROC2) */ {
		if (namelen != 5 || name[3] < 0 || name[4] < 0)
			return (EINVAL);
		op = name[1];
		arg = name[2];
		elem_size = name[3];
		elem_count = name[4];
	}
d937 1
d939 1
a939 1
		switch (op) {
d943 1
a943 1
			if (p->p_pid != (pid_t)arg)
d949 1
a949 7
			if (p->p_pgrp->pg_id != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_SESSION:
			if (p->p_session->s_leader == NULL ||
			    p->p_session->s_leader->p_pid != (pid_t)arg)
d956 1
a956 1
			    p->p_session->s_ttyp->t_dev != (dev_t)arg)
d961 1
a961 1
			if (p->p_ucred->cr_uid != (uid_t)arg)
d966 1
a966 1
			if (p->p_cred->p_ruid != (uid_t)arg)
a973 5
		case KERN_PROC_KTHREAD:
			/* no filtering */
			break;
		default:
			return (EINVAL);
d975 12
a986 33
		if (type == KERN_PROC) {
			if (buflen >= sizeof(struct kinfo_proc)) {
				fill_eproc(p, &eproc);
				error = copyout((caddr_t)p,
				    &((struct kinfo_proc *)dp)->kp_proc,
				    sizeof(struct proc));
				if (error)
					return (error);
				error = copyout((caddr_t)&eproc,
				    &((struct kinfo_proc *)dp)->kp_eproc,
				    sizeof(eproc));
				if (error)
					return (error);
				dp += sizeof(struct kinfo_proc);
				buflen -= sizeof(struct kinfo_proc);
			}
			needed += sizeof(struct kinfo_proc);
		} else /* if (type == KERN_PROC2) */ {
			if (buflen >= elem_size && elem_count > 0) {
				fill_kproc2(p, &kproc2);
				/*
				 * Copy out elem_size, but not larger than
				 * the size of a struct kinfo_proc2.
				 */
				error = copyout(&kproc2, dp,
				    min(sizeof(kproc2), elem_size));
				if (error)
					return (error);
				dp += elem_size;
				buflen -= elem_size;
				elem_count--;
			}
			needed += elem_size;
d988 1
d996 1
a996 1
		*sizep = dp - where;
a1061 162
}

/*
 * Fill in a kproc2 structure for the specified process.
 */
void
fill_kproc2(struct proc *p, struct kinfo_proc2 *ki)
{
	struct tty *tp;
	struct timeval ut, st;

	bzero(ki, sizeof(*ki));

	ki->p_paddr = PTRTOINT64(p);
	ki->p_fd = PTRTOINT64(p->p_fd);
	ki->p_stats = PTRTOINT64(p->p_stats);
	ki->p_limit = PTRTOINT64(p->p_limit);
	ki->p_vmspace = PTRTOINT64(p->p_vmspace);
	ki->p_sigacts = PTRTOINT64(p->p_sigacts);
	ki->p_sess = PTRTOINT64(p->p_session);
	ki->p_tsess = 0;	/* may be changed if controlling tty below */
	ki->p_ru = PTRTOINT64(p->p_ru);

	ki->p_eflag = 0;
	ki->p_exitsig = p->p_exitsig;
	ki->p_flag = p->p_flag;

	ki->p_pid = p->p_pid;
	if (p->p_pptr)
		ki->p_ppid = p->p_pptr->p_pid;
	else
		ki->p_ppid = 0;
	if (p->p_session->s_leader)
		ki->p_sid = p->p_session->s_leader->p_pid;
	else
		ki->p_sid = 0;
	ki->p__pgid = p->p_pgrp->pg_id;

	ki->p_tpgid = -1;	/* may be changed if controlling tty below */

	ki->p_uid = p->p_ucred->cr_uid;
	ki->p_ruid = p->p_cred->p_ruid;
	ki->p_gid = p->p_ucred->cr_gid;
	ki->p_rgid = p->p_cred->p_rgid;
	ki->p_svuid = p->p_cred->p_svuid;
	ki->p_svgid = p->p_cred->p_svgid;

	memcpy(ki->p_groups, p->p_cred->pc_ucred->cr_groups,
	    min(sizeof(ki->p_groups), sizeof(p->p_cred->pc_ucred->cr_groups)));
	ki->p_ngroups = p->p_cred->pc_ucred->cr_ngroups;

	ki->p_jobc = p->p_pgrp->pg_jobc;
	if ((p->p_flag & P_CONTROLT) && (tp = p->p_session->s_ttyp)) {
		ki->p_tdev = tp->t_dev;
		ki->p_tpgid = tp->t_pgrp ? tp->t_pgrp->pg_id : -1;
		ki->p_tsess = PTRTOINT64(tp->t_session);
	} else {
		ki->p_tdev = NODEV;
	}

	ki->p_estcpu = p->p_estcpu;
	ki->p_rtime_sec = p->p_rtime.tv_sec;
	ki->p_rtime_usec = p->p_rtime.tv_usec;
	ki->p_cpticks = p->p_cpticks;
	ki->p_pctcpu = p->p_pctcpu;

	ki->p_uticks = p->p_uticks;
	ki->p_sticks = p->p_sticks;
	ki->p_iticks = p->p_iticks;

	ki->p_tracep = PTRTOINT64(p->p_tracep);
	ki->p_traceflag = p->p_traceflag;

	ki->p_siglist = p->p_siglist;
	ki->p_sigmask = p->p_sigmask;
	ki->p_sigignore = p->p_sigignore;
	ki->p_sigcatch = p->p_sigcatch;

	ki->p_stat = p->p_stat;
	ki->p_nice = p->p_nice;

	ki->p_xstat = p->p_xstat;
	ki->p_acflag = p->p_acflag;

	strlcpy(ki->p_emul, p->p_emul->e_name, sizeof(ki->p_emul));
	strlcpy(ki->p_comm, p->p_comm, sizeof(ki->p_comm));
	strncpy(ki->p_login, p->p_session->s_login,
	    min(sizeof(ki->p_login) - 1, sizeof(p->p_session->s_login)));

	if (p->p_stat == SIDL || P_ZOMBIE(p)) {
		ki->p_vm_rssize = 0;
		ki->p_vm_tsize = 0;
		ki->p_vm_dsize = 0;
		ki->p_vm_ssize = 0;
	} else {
		struct vmspace *vm = p->p_vmspace;

		ki->p_vm_rssize = vm_resident_count(vm);
		ki->p_vm_tsize = vm->vm_tsize;
		ki->p_vm_dsize = vm->vm_dsize;
		ki->p_vm_ssize = vm->vm_ssize;

		ki->p_forw = PTRTOINT64(p->p_forw);
		ki->p_back = PTRTOINT64(p->p_back);
		ki->p_addr = PTRTOINT64(p->p_addr);
		ki->p_stat = p->p_stat;
		ki->p_swtime = p->p_swtime;
		ki->p_slptime = p->p_slptime;
		ki->p_schedflags = p->p_schedflags;
		ki->p_holdcnt = p->p_holdcnt;
		ki->p_priority = p->p_priority;
		ki->p_usrpri = p->p_usrpri;
		if (p->p_wmesg)
			strlcpy(ki->p_wmesg, p->p_wmesg, sizeof(ki->p_wmesg));
		ki->p_wchan = PTRTOINT64(p->p_wchan);

	}

	if (p->p_session->s_ttyvp)
		ki->p_eflag |= EPROC_CTTY;
	if (SESS_LEADER(p))
		ki->p_eflag |= EPROC_SLEADER;
	if (p->p_rlimit)
		ki->p_rlim_rss_cur = p->p_rlimit[RLIMIT_RSS].rlim_cur;

	/* XXX Is this double check necessary? */
	if (P_ZOMBIE(p)) {
		ki->p_uvalid = 0;
	} else {
		ki->p_uvalid = 1;

		PHOLD(p);	/* need for pstats */
		ki->p_ustart_sec = p->p_stats->p_start.tv_sec;
		ki->p_ustart_usec = p->p_stats->p_start.tv_usec;

		calcru(p, &ut, &st, 0);
		ki->p_uutime_sec = ut.tv_sec;
		ki->p_uutime_usec = ut.tv_usec;
		ki->p_ustime_sec = st.tv_sec;
		ki->p_ustime_usec = st.tv_usec;

		ki->p_uru_maxrss = p->p_stats->p_ru.ru_maxrss;
		ki->p_uru_ixrss = p->p_stats->p_ru.ru_ixrss;
		ki->p_uru_idrss = p->p_stats->p_ru.ru_idrss;
		ki->p_uru_isrss = p->p_stats->p_ru.ru_isrss;
		ki->p_uru_minflt = p->p_stats->p_ru.ru_minflt;
		ki->p_uru_majflt = p->p_stats->p_ru.ru_majflt;
		ki->p_uru_nswap = p->p_stats->p_ru.ru_nswap;
		ki->p_uru_inblock = p->p_stats->p_ru.ru_inblock;
		ki->p_uru_oublock = p->p_stats->p_ru.ru_oublock;
		ki->p_uru_msgsnd = p->p_stats->p_ru.ru_msgsnd;
		ki->p_uru_msgrcv = p->p_stats->p_ru.ru_msgrcv;
		ki->p_uru_nsignals = p->p_stats->p_ru.ru_nsignals;
		ki->p_uru_nvcsw = p->p_stats->p_ru.ru_nvcsw;
		ki->p_uru_nivcsw = p->p_stats->p_ru.ru_nivcsw;

		timeradd(&p->p_stats->p_cru.ru_utime,
			 &p->p_stats->p_cru.ru_stime, &ut);
		ki->p_uctime_sec = ut.tv_sec;
		ki->p_uctime_usec = ut.tv_usec;
		PRELE(p);
	}
@


1.1.1.10
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.106 2004/04/19 22:52:33 tedu Exp $	*/
a92 2
extern void nmbclust_update(void);

d99 2
a100 2
int (*cpu_cpuspeed)(int *);
int (*cpu_setperf)(int);
a497 5
	case KERN_MAXCLUSTERS:
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nmbclust);
		if (!error)
			nmbclust_update();
		return (error);
a518 3
	int cpuspeed;
	static int perflevel = 100;
	int operflevel;
d563 1
a563 4
		err = cpu_cpuspeed(&cpuspeed);
		if (err)
			return err;
		return (sysctl_rdint(oldp, oldlenp, newp, cpuspeed));
d567 1
a567 11
		operflevel = perflevel;
		err = sysctl_int(oldp, oldlenp, newp, newlen, &perflevel);
		if (err)
			return err;
		if (perflevel == operflevel)
			return (0);
		if (perflevel > 100)
			perflevel = 100;
		if (perflevel < 0)
			perflevel = 0;
		return (cpu_setperf(perflevel));
a667 20
 * Array of integer values.
 */
int
sysctl_int_arr(valpp, name, namelen, oldp, oldlenp, newp, newlen)
	int **valpp;
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	if (namelen > 1)
		return (ENOTDIR);
	if (name[0] < 0 || valpp[name[0]] == NULL)
		return (EOPNOTSUPP);
	return (sysctl_int(oldp, oldlenp, newp, newlen, valpp[name[0]]));
}

/*
a1516 2
			strlcpy(sdk->ds_name, dk->dk_name,
			    sizeof(sdk->ds_name));
d1518 1
a1518 2
			sdk->ds_rxfer = dk->dk_rxfer;
			sdk->ds_wxfer = dk->dk_wxfer;
d1520 1
a1520 2
			sdk->ds_rbytes = dk->dk_rbytes;
			sdk->ds_wbytes = dk->dk_wbytes;
a1534 2
			strlcpy(sdk->ds_name, dk->dk_name,
			    sizeof(sdk->ds_name));
d1536 1
a1536 2
			sdk->ds_rxfer = dk->dk_rxfer;
			sdk->ds_wxfer = dk->dk_wxfer;
d1538 1
a1538 2
			sdk->ds_rbytes = dk->dk_rbytes;
			sdk->ds_wbytes = dk->dk_wbytes;
d1759 1
a1759 1
		return (sysctl_rdint(oldp, oldlenp, newp, nexecs));
d1764 1
a1764 4
	if (name[0] > nexecs || name[0] < 0)
		return (EINVAL);
	e = execsw[name[0] - 1].es_emul;
	if (e == NULL)
d1766 1
@


