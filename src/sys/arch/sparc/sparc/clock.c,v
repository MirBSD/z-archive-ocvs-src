head	1.8;
access;
symbols
	tg-mergetmp-mirosx-1:1.8
	tg-mergefixes-1-branch:1.8.0.4
	tg-mergefixes-1-base:1.8
	MIROS_X:1.8.0.2
	MIROS_X_BASE:1.8
	tg-mergetmp-3:1.8
	MIRBSD_XP_SPARC:1.3.0.2
	MIRBSD_7quater:1.2.2.1
	cvs-200405160640:1.1.1.2
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.2.1.0.4
	MIRBSD_7:1.2.2.1.0.2
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.2.2.1
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309261655:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	cvs-200307072125:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200307021520:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.12.11.16.50.12;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.13.02.25.44;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.19.32.02;	author tg;	state dead;
branches;
next	1.5;

1.5
date	2004.07.02.17.24.06;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.02.16.52.32;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.17.18.31.51;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.06.04.30.05;	author tg;	state dead;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.03.22.17.50.18;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.50.18;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.05.16.08.48.49;	author tg;	state Exp;
branches;
next	;

1.2.2.1
date	2003.10.23.21.33.21;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Another round of mega-commit-death:
* compile fixes (pre-removal)
* distrib list sync (pre-removal)
* throw out more orphaned profiling stuff
* sync with reality (post-removal)
  -> e.g. don't call comsatd in inetd.conf
* general clean-up phase for touched files,
  or stuff "while here"
* partial distrib list sync (post-removal)
* replace echo with print in /etc/profile

kernel builds; will do a make b-r in two jiffies
@
text
@/*	$OpenBSD: clock.c,v 1.18 2002/08/12 10:44:04 miod Exp $	*/
/*	$NetBSD: clock.c,v 1.52 1997/05/24 20:16:05 pk Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 * Copyright (c) 1996 Paul Kranenburg
 * Copyright (c) 1996
 * 	The President and Fellows of Harvard College. All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by Harvard University.
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed by Paul Kranenburg.
 *	This product includes software developed by Harvard University.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)clock.c	8.1 (Berkeley) 6/11/93
 *
 */

/*
 * Clock driver.  This is the id prom and eeprom driver as well
 * and includes the timer register functions too.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/eeprom.h>
#include <machine/cpu.h>

#include <sparc/sparc/vaddrs.h>
#include <sparc/sparc/cpuvar.h>
#include <sparc/sparc/clockreg.h>
#include <sparc/sparc/intreg.h>
#include <sparc/sparc/timerreg.h>

/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 1024 would
 * give us offsets in [0..1023].  Instead, we take offsets in [1..1023].
 * This is symmetric about the point 512, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
/* XXX fix comment to match value */
int statvar = 8192;
int statmin;			/* statclock interval - 1/2*variance */
int timerok;

#include <dev/ic/intersil7170.h>

extern struct idprom idprom;

#define intersil_command(run, interrupt) \
    (run | interrupt | INTERSIL_CMD_FREQ_32K | INTERSIL_CMD_24HR_MODE | \
     INTERSIL_CMD_NORMAL_MODE)

#define intersil_disable(CLOCK) \
    CLOCK->clk_cmd_reg = \
    intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IDISABLE)

#define intersil_enable(CLOCK) \
    CLOCK->clk_cmd_reg = \
    intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE)

#define intersil_clear(CLOCK) CLOCK->clk_intr_reg

#if defined(SUN4)
/*
 * OCLOCK support: 4/100's and 4/200's have the old clock.
 */
static int oldclk = 0;
struct intersil7170 *i7;

long	oclk_get_secs(void);
void	oclk_get_dt(struct intersil_dt *);
void	dt_to_gmt(struct intersil_dt *, long *);
void	oclk_set_dt(struct intersil_dt *);
void	oclk_set_secs(long);
void	gmt_to_dt(long *, struct intersil_dt *);
#endif

int	oclockmatch(struct device *, void *, void *);
void	oclockattach(struct device *, struct device *, void *);

struct cfattach oclock_ca = {
	sizeof(struct device), oclockmatch, oclockattach
};

struct cfdriver oclock_cd = {
	NULL, "oclock", DV_DULL
};

/*
 * Sun 4 machines use the old-style (a'la Sun 3) EEPROM.  On the
 * 4/100's and 4/200's, this is at a separate obio space.  On the
 * 4/300's and 4/400's, however, it is the cl_nvram[] chunk of the
 * Mostek chip.  Therefore, eeprom_match will only return true on
 * the 100/200 models, and the eeprom will be attached separately.
 * On the 300/400 models, the eeprom will be dealt with when the clock is
 * attached.
 */
char		*eeprom_va = NULL;
#if defined(SUN4)
static int	eeprom_busy = 0;
static int	eeprom_wanted = 0;
static int	eeprom_nvram = 0;	/* non-zero if eeprom is on Mostek */
int	eeprom_take(void);
void	eeprom_give(void);
int	eeprom_update(char *, int, int);
#endif

int	eeprom_match(struct device *, void *, void *);
void	eeprom_attach(struct device *, struct device *, void *);

struct cfattach eeprom_ca = {
	sizeof(struct device), eeprom_match, eeprom_attach
};

struct	cfdriver eeprom_cd = {
	NULL, "eeprom", DV_DULL
};

int	clockmatch(struct device *, void *, void *);
void	clockattach(struct device *, struct device *, void *);

struct cfattach clock_ca = {
	sizeof(struct device), clockmatch, clockattach
};

struct cfdriver clock_cd = {
	NULL, "clock", DV_DULL
};

int	timermatch(struct device *, void *, void *);
void	timerattach(struct device *, struct device *, void *);

struct timer_4m	*timerreg_4m;	/* XXX - need more cleanup */
struct counter_4m	*counterreg_4m;
#define	timerreg4		((struct timerreg_4 *)TIMERREG_VA)

struct cfattach timer_ca = {
	sizeof(struct device), timermatch, timerattach
};

struct cfdriver timer_cd = {
	NULL, "timer", DV_DULL
};

struct chiptime;
void clk_wenable(int);
void myetheraddr(u_char *);
int chiptotime(int, int, int, int, int, int);
void timetochip(struct chiptime *);

int timerblurb = 10; /* Guess a value; used before clock is attached */

/*
 * old clock match routine
 */
int
oclockmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct confargs *ca = aux;

	/* Only these sun4s have oclock */
	if (!CPU_ISSUN4 ||
	    (cpuinfo.cpu_type != CPUTYP_4_100 &&
	     cpuinfo.cpu_type != CPUTYP_4_200))
		return (0);

	/* Check configuration name */
	if (strcmp(oclock_cd.cd_name, ca->ca_ra.ra_name) != 0)
		return (0);

	/* Make sure there is something there */
	if (probeget(ca->ca_ra.ra_vaddr, 1) == -1)
		return (0);

	return (1);
}

/* ARGSUSED */
void
oclockattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
#if defined(SUN4)
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	struct idprom *idp;
	int h;

	oldclk = 1;  /* we've got an oldie! */

	i7 = (struct intersil7170 *) mapiodev(ra->ra_reg, 0, sizeof(*i7));

	idp = &idprom;
	h = idp->id_machine << 24;
	h |= idp->id_hostid[0] << 16;
	h |= idp->id_hostid[1] << 8;
	h |= idp->id_hostid[2];
	hostid = h;

	/* 
	 * calibrate delay() 
	 */
	ienab_bic(IE_L14 | IE_L10);	/* disable all clock intrs */
	for (timerblurb = 1; ; timerblurb++) {
		volatile register char *ireg = &i7->clk_intr_reg;
		int ival;
		*ireg = INTERSIL_INTER_CSECONDS; /* 1/100 sec */
		intersil_enable(i7);		 /* enable clock */
		while ((*ireg & INTERSIL_INTER_PENDING) == 0)
			/* sync with interrupt */;
		while ((*ireg & INTERSIL_INTER_PENDING) == 0)
			/* XXX: do it again, seems to need it */;
		delay(10000);			/* Probe 1/100 sec delay */
		ival = *ireg;			/* clear, save value */
		intersil_disable(i7);		/* disable clock */
		if (ival & INTERSIL_INTER_PENDING) {
			printf(" delay constant %d%s\n", timerblurb,
				(timerblurb == 1) ? " [TOO SMALL?]" : "");
			break;
		}
		if (timerblurb > 10) {
			printf("\noclock: calibration failing; clamped at %d\n",
			       timerblurb);
			break;
		}
	}
#endif /* SUN4 */
}

/*
 * Sun 4/100, 4/200 EEPROM match routine.
 */
int
eeprom_match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;

	if (!CPU_ISSUN4)
		return (0);

	if (cf->cf_unit != 0)
		return (0);

	if (cpuinfo.cpu_type != CPUTYP_4_100 &&
	    cpuinfo.cpu_type != CPUTYP_4_200)
		return (0);

	if (strcmp(eeprom_cd.cd_name, ca->ca_ra.ra_name) != 0)
		return (0);

	/*
	 * Make sure there's something there...
	 * This is especially important if we want to
	 * use the same kernel on a 4/100 as a 4/200.
	 */
	if (probeget(ca->ca_ra.ra_vaddr, 1) == -1)
		return (0);

	/* Passed all tests */
	return (1);
}

void
eeprom_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
#if defined(SUN4)
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	printf("\n");

	eeprom_va = (char *)mapiodev(ra->ra_reg, 0, EEPROM_SIZE);

	eeprom_nvram = 0;
#endif /* SUN4 */
}

/*
 * The OPENPROM calls the clock the "eeprom", so we have to have our
 * own special match function to call it the "clock".
 */
int
clockmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct confargs *ca = aux;

	if (CPU_ISSUN4) {
		/* Only these sun4s have "clock" (others have "oclock") */
		if (cpuinfo.cpu_type != CPUTYP_4_300 &&
		    cpuinfo.cpu_type != CPUTYP_4_400)
			return (0);

		if (strcmp(clock_cd.cd_name, ca->ca_ra.ra_name) != 0)
			return (0);

		/* Make sure there is something there */
		if (probeget(ca->ca_ra.ra_vaddr, 1) == -1)
			return (0);

		return (1);
	}

	return (strcmp("eeprom", ca->ca_ra.ra_name) == 0);
}

/* ARGSUSED */
void
clockattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	int h;
	struct clockreg *cl;
	struct idprom *idp;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	char *prop = NULL;

	if (CPU_ISSUN4)
		prop = "mk48t02";

	if (CPU_ISSUN4COR4M)
		prop = getpropstring(ra->ra_node, "model");

#ifdef DIAGNOSTIC
	if (prop == NULL)
		panic("no prop");
#endif
	printf(": %s (eeprom)\n", prop);

	/*
	 * We ignore any existing virtual address as we need to map
	 * this read-only and make it read-write only temporarily,
	 * whenever we read or write the clock chip.  The clock also
	 * contains the ID ``PROM'', and I have already had the pleasure
	 * of reloading the cpu type, Ethernet address, etc, by hand from
	 * the console FORTH interpreter.  I intend not to enjoy it again.
	 */
	if (strcmp(prop, "mk48t08") == 0) {
		/*
		 * the MK48T08 is 8K
		 */
		cl = (struct clockreg *)mapiodev(ra->ra_reg, 0, 8192);
		pmap_changeprot(pmap_kernel(), (vaddr_t)cl, VM_PROT_READ, 1);
		pmap_changeprot(pmap_kernel(), (vaddr_t)cl + 4096,
				VM_PROT_READ, 1);
		cl = (struct clockreg *)((int)cl + CLK_MK48T08_OFF);
	} else {
		/*
		 * the MK48T02 is 2K
		 */
		cl = (struct clockreg *)mapiodev(ra->ra_reg, 0,
						 sizeof *clockreg);
		pmap_changeprot(pmap_kernel(), (vaddr_t)cl, VM_PROT_READ, 1);
	}
	idp = &cl->cl_idprom;

#if defined(SUN4)
	if (CPU_ISSUN4) {
		idp = &idprom;

		if (cpuinfo.cpu_type == CPUTYP_4_300 ||
		    cpuinfo.cpu_type == CPUTYP_4_400) {
			eeprom_va = (char *)cl->cl_nvram;
			eeprom_nvram = 1;
		}
	}
#endif

	h = idp->id_machine << 24;
	h |= idp->id_hostid[0] << 16;
	h |= idp->id_hostid[1] << 8;
	h |= idp->id_hostid[2];
	hostid = h;
	clockreg = cl;
}

/*
 * The OPENPROM calls the timer the "counter-timer".
 */
int
timermatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct confargs *ca = aux;

	if (CPU_ISSUN4) {
		if (cpuinfo.cpu_type != CPUTYP_4_300 &&
		    cpuinfo.cpu_type != CPUTYP_4_400)
			return (0);

		if (strcmp("timer", ca->ca_ra.ra_name) != 0)
			return (0);

		/* Make sure there is something there */
		if (probeget(ca->ca_ra.ra_vaddr, 4) == -1)
			return (0);

		return (1);
	}

	if (CPU_ISSUN4C) {
		return (strcmp("counter-timer", ca->ca_ra.ra_name) == 0);
	}

	if (CPU_ISSUN4M) {
		return (strcmp("counter", ca->ca_ra.ra_name) == 0);
	}

	return (0);
}

/* ARGSUSED */
void
timerattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	volatile int *cnt = NULL, *lim = NULL;
		/* XXX: must init to NULL to avoid stupid gcc -Wall warning */

	if (CPU_ISSUN4M) {
		(void)mapdev(&ra->ra_reg[ra->ra_nreg-1], TIMERREG_VA, 0,
			     sizeof(struct timer_4m));
		(void)mapdev(&ra->ra_reg[0], COUNTERREG_VA, 0,
			     sizeof(struct counter_4m));
		timerreg_4m = (struct timer_4m *)TIMERREG_VA;
		counterreg_4m = (struct counter_4m *)COUNTERREG_VA;

		/* Put processor counter in "timer" mode */
		timerreg_4m->t_cfg = 0;

		cnt = &counterreg_4m->t_counter;
		lim = &counterreg_4m->t_limit;
	}

	if (CPU_ISSUN4OR4C) {
		/*
		 * This time, we ignore any existing virtual address because
		 * we have a fixed virtual address for the timer, to make
		 * microtime() faster (in SUN4/SUN4C kernel only).
		 */
		(void)mapdev(ra->ra_reg, TIMERREG_VA, 0,
			     sizeof(struct timerreg_4));

		cnt = &timerreg4->t_c14.t_counter;
		lim = &timerreg4->t_c14.t_limit;
	}

	timerok = 1;

	/*
	 * Calibrate delay() by tweaking the magic constant
	 * until a delay(100) actually reads (at least) 100 us on the clock.
	 * Note: sun4m clocks tick with 500ns periods.
	 */

	for (timerblurb = 1; ; timerblurb++) {
		volatile int discard;
		int t0, t1;

		/* Reset counter register by writing some large limit value */
		discard = *lim;
		*lim = tmr_ustolim(TMR_MASK-1);

		t0 = *cnt;
		delay(100);
		t1 = *cnt;

		if (t1 & TMR_LIMIT)
			panic("delay calibration");

		t0 = (t0 >> TMR_SHIFT) & TMR_MASK;
		t1 = (t1 >> TMR_SHIFT) & TMR_MASK;

		if (t1 >= t0 + 100)
			break;

	}

	printf(" delay constant %d\n", timerblurb);

	/* should link interrupt handlers here, rather than compiled-in? */
}

/*
 * Write en/dis-able clock registers.  We coordinate so that several
 * writers can run simultaneously.
 */
void
clk_wenable(onoff)
	int onoff;
{
	int s;
	vm_prot_t prot;/* nonzero => change prot */
	static int writers;

	s = splhigh();
	if (onoff)
		prot = writers++ == 0 ? VM_PROT_READ|VM_PROT_WRITE : 0;
	else
		prot = --writers == 0 ? VM_PROT_READ : 0;
	splx(s);
	if (prot)
		pmap_changeprot(pmap_kernel(), (vaddr_t)clockreg & ~(NBPG-1),
				prot, 1);
}

/*
 * XXX this belongs elsewhere
 */
void
myetheraddr(cp)
	u_char *cp;
{
	struct clockreg *cl = clockreg;
	struct idprom *idp = &cl->cl_idprom;

#if defined(SUN4)
	if (CPU_ISSUN4)
		idp = &idprom;
#endif

	cp[0] = idp->id_ether[0];
	cp[1] = idp->id_ether[1];
	cp[2] = idp->id_ether[2];
	cp[3] = idp->id_ether[3];
	cp[4] = idp->id_ether[4];
	cp[5] = idp->id_ether[5];
}

/*
 * Set up the real-time and statistics clocks.  Leave stathz 0 only if
 * no alternative timer is available.
 *
 * The frequencies of these clocks must be an even number of microseconds.
 */
void
cpu_initclocks()
{
	int statint, minint;

#if defined(SUN4)
	if (oldclk) {
		int dummy;

		if (hz != 100) {
			printf("oclock0: cannot get %d Hz clock; using 100 Hz\n", hz);
		}

		profhz = hz = 100;
		tick = 1000000 / hz;

		i7->clk_intr_reg = INTERSIL_INTER_CSECONDS; /* 1/100 sec */

		ienab_bic(IE_L14 | IE_L10);	/* disable all clock intrs */
		intersil_disable(i7);		/* disable clock */
		dummy = intersil_clear(i7);	/* clear interrupts */
		ienab_bis(IE_L10);		/* enable l10 interrupt */
		intersil_enable(i7);		/* enable clock */

		return;
	}
#endif /* SUN4 */

	if (1000000 % hz) {
		printf("clock0: cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
		tick = 1000000 / hz;
	}
	if (stathz == 0)
		stathz = hz;
	if (1000000 % stathz) {
		printf("clock0: cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	if (CPU_ISSUN4M) {
		timerreg_4m->t_limit = tmr_ustolim4m(tick);
		counterreg_4m->t_limit = tmr_ustolim4m(statint);
	}

	if (CPU_ISSUN4OR4C) {
		timerreg4->t_c10.t_limit = tmr_ustolim(tick);
		timerreg4->t_c14.t_limit = tmr_ustolim(statint);
	}

	statmin = statint - (statvar >> 1);

#if defined(SUN4M)
	if (CPU_ISSUN4M)
		ienab_bic(SINTR_T);
#endif

	if (CPU_ISSUN4OR4C)
		ienab_bis(IE_L14 | IE_L10);

}

/*
 * Dummy setstatclockrate(), since we know profhz==hz.
 */
/* ARGSUSED */
void
setstatclockrate(newhz)
	int newhz;
{
	/* nothing */
}

/*
 * Level 10 (clock) interrupts.  If we are using the FORTH PROM for
 * console input, we need to check for that here as well, and generate
 * a software interrupt to read it.
 */
int
clockintr(cap)
	void *cap;
{
	volatile int discard;
	int s;

	/*
	 * Protect the clearing of the clock interrupt.  If we don't
	 * do this, and we're interrupted (by the zs, for example),
	 * the clock stops!
	 * XXX WHY DOES THIS HAPPEN?
	 */
	s = splhigh();

#if defined(SUN4)
	if (oldclk) {
		discard = intersil_clear(i7);
		ienab_bic(IE_L10);  /* clear interrupt */
		ienab_bis(IE_L10);  /* enable interrupt */
		goto forward;
	}
#endif
#if defined(SUN4M)
	/* read the limit register to clear the interrupt */
	if (CPU_ISSUN4M) {
		discard = timerreg_4m->t_limit;
	}
#endif
#if defined(SUN4) || defined(SUN4C)
	if (CPU_ISSUN4OR4C) {
		discard = timerreg4->t_c10.t_limit;
	}
#endif
#if defined(SUN4)
forward:
#endif
	splx(s);

	hardclock((struct clockframe *)cap);

	return (1);
}

/*
 * Level 14 (stat clock) interrupt handler.
 */
int
statintr(cap)
	void *cap;
{
	volatile int discard;
	u_long newint, r, var;

#if defined(SUN4)
	if (oldclk) {
		panic("oldclk statintr");
		return (1);
	}
#endif

	/* read the limit register to clear the interrupt */
	if (CPU_ISSUN4M) {
		discard = counterreg_4m->t_limit;
		if (timerok == 0) {
			/* Stop the clock */
			counterreg_4m->t_limit = 0;
			counterreg_4m->t_ss = 0;
			timerreg_4m->t_cfg = TMR_CFG_USER;
			return 1;
		}
	}

	if (CPU_ISSUN4OR4C) {
		discard = timerreg4->t_c14.t_limit;
	}
	statclock((struct clockframe *)cap);

	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	if (CPU_ISSUN4M) {
		counterreg_4m->t_limit = tmr_ustolim4m(newint);
	}

	if (CPU_ISSUN4OR4C) {
		timerreg4->t_c14.t_limit = tmr_ustolim(newint);
	}
	return (1);
}

/*
 * BCD to decimal and decimal to BCD.
 */
#define	FROMBCD(x)	(((x) >> 4) * 10 + ((x) & 0xf))
#define	TOBCD(x)	(((x) / 10 * 16) + ((x) % 10))

#define	SECDAY		(24 * 60 * 60)
#define	SECYR		(SECDAY * 365)
/*
 * should use something like
 * #define LEAPYEAR(y) ((((y) % 4) == 0 && ((y) % 100) != 0) || ((y) % 400) == 0)
 * but it's unlikely that we'll still be around in 2100.
 */
#define	LEAPYEAR(y)	(((y) & 3) == 0)

/*
 * This code is defunct after 2068.
 * Will Unix still be here then??
 */
const short dayyr[12] =
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };

int
chiptotime(sec, min, hour, day, mon, year)
	int sec, min, hour, day, mon, year;
{
	int days, yr;

	sec = FROMBCD(sec);
	min = FROMBCD(min);
	hour = FROMBCD(hour);
	day = FROMBCD(day);
	mon = FROMBCD(mon);
	year = FROMBCD(year) + YEAR0;

	/* simple sanity checks */
	if (year < 70 || mon < 1 || mon > 12 || day < 1 || day > 31)
		return (0);
	days = 0;
	for (yr = 70; yr < year; yr++)
		days += LEAPYEAR(yr) ? 366 : 365;
	days += dayyr[mon - 1] + day - 1;
	if (LEAPYEAR(yr) && mon > 2)
		days++;
	/* now have days since Jan 1, 1970; the rest is easy... */
	return (days * SECDAY + hour * 3600 + min * 60 + sec);
}

struct chiptime {
	int	sec;
	int	min;
	int	hour;
	int	wday;
	int	day;
	int	mon;
	int	year;
};

void
timetochip(c)
	struct chiptime *c;
{
	int t, t2, t3, now = time.tv_sec;

	/* compute the year */
	t2 = now / SECDAY;
	t3 = (t2 + 2) % 7;	/* day of week */
	c->wday = TOBCD(t3 + 1);

	t = 69;
	while (t2 >= 0) {	/* whittle off years */
		t3 = t2;
		t++;
		t2 -= LEAPYEAR(t) ? 366 : 365;
	}
	c->year = t;

	/* t3 = month + day; separate */
	t = LEAPYEAR(t);
	for (t2 = 1; t2 < 12; t2++)
		if (t3 < dayyr[t2] + (t && t2 > 1))
			break;

	/* t2 is month */
	c->mon = t2;
	c->day = t3 - dayyr[t2 - 1] + 1;
	if (t && t2 > 2)
		c->day--;

	/* the rest is easy */
	t = now % SECDAY;
	c->hour = t / 3600;
	t %= 3600;
	c->min = t / 60;
	c->sec = t % 60;

	c->sec = TOBCD(c->sec);
	c->min = TOBCD(c->min);
	c->hour = TOBCD(c->hour);
	c->day = TOBCD(c->day);
	c->mon = TOBCD(c->mon);
	c->year = TOBCD(c->year - YEAR0);
}

/*
 * Set up the system's time, given a `reasonable' time value.
 */
void
inittodr(base)
	time_t base;
{
	struct clockreg *cl = clockreg;
	int sec, min, hour, day, mon, year;
	int badbase = 0, waszero = base == 0;

	if (base < 5 * SECYR) {
		/*
		 * If base is 0, assume filesystem time is just unknown
		 * in stead of preposterous. Don't bark.
		 */
		if (base != 0)
			printf("WARNING: preposterous time in file system\n");
		/* not going to use it anyway, if the chip is readable */
		base = 21*SECYR + 186*SECDAY + SECDAY/2;
		badbase = 1;
	}
#if defined(SUN4)
	if (oldclk) {
		time.tv_sec = oclk_get_secs();
		goto forward;
	}
#endif
	clk_wenable(1);
	cl->cl_csr |= CLK_READ;		/* enable read (stop time) */
	sec = cl->cl_sec;
	min = cl->cl_min;
	hour = cl->cl_hour;
	day = cl->cl_mday;
	mon = cl->cl_month;
	year = cl->cl_year;
	cl->cl_csr &= ~CLK_READ;	/* time wears on */
	clk_wenable(0);
	time.tv_sec = chiptotime(sec, min, hour, day, mon, year);

#if defined(SUN4)
forward:
#endif
	if (time.tv_sec == 0) {
		printf("WARNING: bad date in battery clock");
		/*
		 * Believe the time in the file system for lack of
		 * anything better, resetting the clock.
		 */
		time.tv_sec = base;
		if (!badbase)
			resettodr();
	} else {
		int deltat = time.tv_sec - base;

		if (deltat < 0)
			deltat = -deltat;
		if (waszero || deltat < 2 * SECDAY)
			return;
		printf("WARNING: clock %s %d days",
		    time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
	}
	printf(" -- CHECK AND RESET THE DATE!\n");
}

/*
 * Reset the clock based on the current time.
 * Used when the current clock is preposterous, when the time is changed,
 * and when rebooting.  Do nothing if the time is not yet known, e.g.,
 * when crashing during autoconfig.
 */
void
resettodr()
{
	struct clockreg *cl;
	struct chiptime c;

#if defined(SUN4)
	if (oldclk) {
		if (!time.tv_sec || i7 == NULL)
			return;
		oclk_set_secs(time.tv_sec);
		return;
	}
#endif

	if (!time.tv_sec || (cl = clockreg) == NULL)
		return;
	timetochip(&c);
	clk_wenable(1);
	cl->cl_csr |= CLK_WRITE;	/* enable write */
	cl->cl_sec = c.sec;
	cl->cl_min = c.min;
	cl->cl_hour = c.hour;
	cl->cl_wday = c.wday;
	cl->cl_mday = c.day;
	cl->cl_month = c.mon;
	cl->cl_year = c.year;
	cl->cl_csr &= ~CLK_WRITE;	/* load them up */
	clk_wenable(0);
}

#if defined(SUN4)
/*
 * Now routines to get and set clock as POSIX time.
 */
long
oclk_get_secs()
{
        struct intersil_dt dt;
        long gmt;

        oclk_get_dt(&dt);
        dt_to_gmt(&dt, &gmt);
        return (gmt);
}

void
oclk_set_secs(secs)
	long secs;
{
        struct intersil_dt dt;
        long gmt;

        gmt = secs;
        gmt_to_dt(&gmt, &dt);
        oclk_set_dt(&dt);
}

/*
 * Routine to copy state into and out of the clock.
 * The clock registers have to be read or written
 * in sequential order (or so it appears). -gwr
 */
void
oclk_get_dt(dt)
	struct intersil_dt *dt;
{
        int s;
        register volatile char *src, *dst;

        src = (char *) &i7->counters;

        s = splhigh();
        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);

        dst = (char *) dt;
        dt++;   /* end marker */
        do {
                *dst++ = *src++;
        } while (dst < (char *)dt);

        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
        splx(s);
}

void
oclk_set_dt(dt)
	struct intersil_dt *dt;
{
        int s;
        register volatile char *src, *dst;

        dst = (char *) &i7->counters;

        s = splhigh();
        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);

        src = (char *) dt;
        dt++;   /* end marker */
        do {
                *dst++ = *src++;
        } while (src < (char *)dt);

        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
        splx(s);
}


/*
 * Machine dependent base year:
 * Note: must be < 1970
 */
#define CLOCK_BASE_YEAR 1968

/* Traditional UNIX base year */
#define POSIX_BASE_YEAR 1970
#define FEBRUARY        2

#define leapyear(year)          ((year) % 4 == 0)
#define days_in_year(a)         (leapyear(a) ? 366 : 365)
#define days_in_month(a)        (month_days[(a) - 1])

static int month_days[12] = {
        31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

void
gmt_to_dt(tp, dt)
	long *tp;
	struct intersil_dt *dt;
{
        int i;
        long days, secs;

        days = *tp / SECDAY;
        secs = *tp % SECDAY;

        /* Hours, minutes, seconds are easy */
        dt->dt_hour = secs / 3600;
        secs = secs % 3600;
        dt->dt_min  = secs / 60;
        secs = secs % 60;
        dt->dt_sec  = secs;

        /* Day of week (Note: 1/1/1970 was a Thursday) */
        dt->dt_dow = (days + 4) % 7;

        /* Number of years in days */
        i = POSIX_BASE_YEAR;
        while (days >= days_in_year(i)) {
                days -= days_in_year(i);
                i++;
        }
        dt->dt_year = i - CLOCK_BASE_YEAR;

        /* Number of months in days left */
        if (leapyear(i))
                days_in_month(FEBRUARY) = 29;
        for (i = 1; days >= days_in_month(i); i++)
                days -= days_in_month(i);
        days_in_month(FEBRUARY) = 28;
        dt->dt_month = i;

        /* Days are what is left over (+1) from all that. */
        dt->dt_day = days + 1;
}


void
dt_to_gmt(dt, tp)
	struct intersil_dt *dt;
	long *tp;
{
        int i;
        long tmp;
        int year;

        /*
         * Hours are different for some reason. Makes no sense really.
         */

        tmp = 0;

        if (dt->dt_hour >= 24) goto out;
        if (dt->dt_day  >  31) goto out;
        if (dt->dt_month > 12) goto out;

        year = dt->dt_year + CLOCK_BASE_YEAR;


        /*
         * Compute days since start of time
         * First from years, then from months.
         */
        for (i = POSIX_BASE_YEAR; i < year; i++)
                tmp += days_in_year(i);
        if (leapyear(year) && dt->dt_month > FEBRUARY)
                tmp++;

        /* Months */
        for (i = 1; i < dt->dt_month; i++)
                tmp += days_in_month(i);
        tmp += (dt->dt_day - 1);

        /* Now do hours */
        tmp = tmp * 24 + dt->dt_hour;

        /* Now do minutes */
        tmp = tmp * 60 + dt->dt_min;

        /* Now do seconds */
        tmp = tmp * 60 + dt->dt_sec;

out:
        *tp = tmp;
}
#endif /* SUN4 */

#if defined(SUN4)
/*
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  We do this by returning the current time
 * plus the amount of time since the last clock interrupt.
 *
 * Check that this time is no less than any previously-reported time,
 * which could happen around the time of a clock adjustment.  Just for
 * fun, we guarantee that the time will be greater than the value
 * obtained by a previous call.
 */
void
microtime(tvp)
	struct timeval *tvp;
{
	int s;
	static struct timeval lasttime;
	static struct timeval oneusec = {0, 1};

	if (!oldclk) {
		lo_microtime(tvp);
		return;
	}

	s = splhigh();
	*tvp = time;
	splx(s);

	if (timercmp(tvp, &lasttime, <=))
		timeradd(&lasttime, &oneusec, tvp);

	lasttime = *tvp;
}
#endif /* SUN4 */

/*
 * XXX: these may actually belong somewhere else, but since the
 * EEPROM is so closely tied to the clock on some models, perhaps
 * it needs to stay here...
 */
int
eeprom_uio(uio)
	struct uio *uio;
{
#if defined(SUN4)
	int error;
	int off;	/* NOT off_t */
	u_int cnt, bcnt;
	caddr_t buf = NULL;

	if (!CPU_ISSUN4)
		return (ENODEV);

	off = uio->uio_offset;
	if (off > EEPROM_SIZE)
		return (EFAULT);

	cnt = uio->uio_resid;
	if (cnt > (EEPROM_SIZE - off))
		cnt = (EEPROM_SIZE - off);

	if ((error = eeprom_take()) != 0)
		return (error);

	if (eeprom_va == NULL) {
		error = ENXIO;
		goto out;
	}

	/*
	 * The EEPROM can only be accessed one byte at a time, yet
	 * uiomove() will attempt long-word access.  To circumvent
	 * this, we byte-by-byte copy the eeprom contents into a
	 * temporary buffer.
	 */
	buf = malloc(EEPROM_SIZE, M_DEVBUF, M_WAITOK);

	if (uio->uio_rw == UIO_READ)
		for (bcnt = 0; bcnt < EEPROM_SIZE; ++bcnt)
			*(char *)(buf + bcnt) = *(char *)(eeprom_va + bcnt);

	if ((error = uiomove(buf + off, (int)cnt, uio)) != 0)
		goto out;

	if (uio->uio_rw != UIO_READ)
		error = eeprom_update(buf, off, cnt);

 out:
	if (buf)
		free(buf, M_DEVBUF);
	eeprom_give();
	return (error);
#else /* ! SUN4 */
	return (ENODEV);
#endif /* SUN4 */
}

#if defined(SUN4)
/*
 * Update the EEPROM from the passed buf.
 */
int
eeprom_update(buf, off, cnt)
	char *buf;
	int off, cnt;
{
	int error = 0;
	volatile char *ep;
	char *bp;

	if (eeprom_va == NULL)
		return (ENXIO);

	ep = eeprom_va + off;
	bp = buf + off;

	if (eeprom_nvram)
		clk_wenable(1);

	while (cnt > 0) {
		/*
		 * DO NOT WRITE IT UNLESS WE HAVE TO because the
		 * EEPROM has a limited number of write cycles.
		 * After some number of writes it just fails!
		 */
		if (*ep != *bp) {
			*ep = *bp;
			/*
			 * We have written the EEPROM, so now we must
			 * sleep for at least 10 milliseconds while
			 * holding the lock to prevent all access to
			 * the EEPROM while it recovers.
			 */
			(void)tsleep(eeprom_va, PZERO - 1, "eeprom", hz/50);
		}
		/* Make sure the write worked. */
		if (*ep != *bp) {
			error = EIO;
			goto out;
		}
		++ep;
		++bp;
		--cnt;
	}
 out:
	if (eeprom_nvram)
		clk_wenable(0);

	return (error);
}

/* Take a lock on the eeprom. */
int
eeprom_take()
{
	int error = 0;

	while (eeprom_busy) {
		eeprom_wanted = 1;
		error = tsleep(&eeprom_busy, PZERO | PCATCH, "eeprom", 0);
		eeprom_wanted = 0;
		if (error)	/* interrupted */
			goto out;
	}
	eeprom_busy = 1;
 out:
	return (error);
}

/* Give a lock on the eeprom away. */
void
eeprom_give()
{

	eeprom_busy = 0;
	if (eeprom_wanted) {
		eeprom_wanted = 0;
		wakeup(&eeprom_busy);
	}
}
#endif /* SUN4 */
@


1.7
log
@welcome back, sparc
(usr.bin/pmdb was never deleted)
@
text
@a69 3
#ifdef GPROF
#include <sys/gmon.h>
#endif
@


1.6
log
@sparc has to die :(

it was nice while it lasted, but I couldn't even live up to
my promise to provide XFree86 4.4.0 on sparc due to lack of
time (and money and health).

also, compat_freebsd dies, without prejudice.

<mirabile> benz: sparc darf sterben?
<mirabile> compat_freebsd darf sterben?
<benz> na gut

in addition, some set shuffling (it was a good idea originally
to pull out gcc3 specifics to the egcs set, but with gcc3 being
the only compiler that isn't it any more)
@
text
@d1 2
a2 3
/* $MirBSD: src/sys/arch/sparc/sparc/clock.c,v 1.5 2004/07/02 17:24:06 tg Exp $ */
/* $OpenBSD: clock.c,v 1.19 2004/04/08 01:11:21 deraadt Exp $	*/
/* $NetBSD: clock.c,v 1.52 1997/05/24 20:16:05 pk Exp $ */
a4 2
 * Copyright (c) 2004
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
d124 1
a124 1
time_t	oclk_get_secs(void);
d126 1
a126 1
void	dt_to_gmt(struct intersil_dt *, time_t *);
d128 2
a129 2
void	oclk_set_secs(time_t);
void	gmt_to_dt(time_t *, struct intersil_dt *);
d202 1
a202 1
time_t chiptotime(int, int, int, int, int, int);
d257 2
a258 2
	/*
	 * calibrate delay()
d280 1
a280 1
			    timerblurb);
d491 1
a491 1
		    sizeof(struct timer_4m));
d493 1
a493 1
		    sizeof(struct counter_4m));
d511 1
a511 1
		    sizeof(struct timerreg_4));
d794 8
d803 10
a812 2
time_t
chiptotime(int sec, int min, int hour, int day, int mon, int year)
d814 1
a814 1
	struct tm tm;
d816 3
d820 1
a820 1
	mon = FROMBCD(mon) - 1;
d826 8
a833 9

	tm.tm_sec = FROMBCD(sec);
	tm.tm_min = FROMBCD(min);
	tm.tm_hour = FROMBCD(hour);
	tm.tm_mday = day;
	tm.tm_mon = mon;
	tm.tm_year = year;

	return tai2timet(mjd2tai(tm2mjd(tm)));
d847 2
a848 1
timetochip(struct chiptime *c)
d850 1
a850 1
	struct tm tm;
d852 18
a869 1
	tm = mjd2tm(tai2mjd(timet2tai(time.tv_sec)));
d871 19
a889 6
	c->sec = TOBCD(tm.tm_sec);
	c->min = TOBCD(tm.tm_min);
	c->hour = TOBCD(tm.tm_hour);
	c->day = TOBCD(tm.tm_mday);
	c->mon = TOBCD(tm.tm_mon + 1);
	c->year = TOBCD(tm.tm_year - YEAR0);
d896 2
a897 1
inittodr(time_t base)
a901 1
	char *bad = NULL;
d936 1
a940 1
		bad = "WARNING: bad date in battery clock";
d945 1
a945 1
		time_t deltat = time.tv_sec - base;
a950 2

#ifndef SMALL_KERNEL
a952 5
		bad = "";
#endif
	}
	if (bad) {
		printf("%s -- CHECK AND RESET THE DATE!\n", bad);
d954 1
d964 1
a964 1
resettodr(void)
d998 2
a999 2
time_t
oclk_get_secs(void)
d1001 2
a1002 2
	struct intersil_dt dt;
	time_t gmt;
d1004 3
a1006 3
	oclk_get_dt(&dt);
	dt_to_gmt(&dt, &gmt);
	return (gmt);
d1010 2
a1011 1
oclk_set_secs(time_t secs)
d1013 2
a1014 2
	struct intersil_dt dt;
	time_t gmt;
d1016 3
a1018 3
	gmt = secs;
	gmt_to_dt(&gmt, &dt);
	oclk_set_dt(&dt);
d1027 2
a1028 1
oclk_get_dt(struct intersil_dt *dt)
d1030 2
a1031 4
	int s;
	register volatile char *src, *dst;

	src = (char *) &i7->counters;
d1033 1
a1033 3
	s = splhigh();
	i7->clk_cmd_reg =
	    intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);
d1035 13
a1047 9
	dst = (char *) dt;
	dt++;   /* end marker */
	do {
		*dst++ = *src++;
	} while (dst < (char *)dt);

	i7->clk_cmd_reg =
	    intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
	splx(s);
d1051 2
a1052 1
oclk_set_dt(struct intersil_dt *dt)
d1054 2
a1055 2
	int s;
	register volatile char *src, *dst;
d1057 1
a1057 1
	dst = (char *) &i7->counters;
d1059 13
a1071 13
	s = splhigh();
	i7->clk_cmd_reg =
	    intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);

	src = (char *) dt;
	dt++;   /* end marker */
	do {
		*dst++ = *src++;
	} while (src < (char *)dt);

	i7->clk_cmd_reg =
	    intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
	splx(s);
d1079 55
a1133 1
#define CLOCK_BASE_YEAR	1968
d1136 3
a1138 1
gmt_to_dt(time_t *tp, struct intersil_dt *dt)
d1140 3
a1142 1
	struct tm tm;
d1144 3
a1146 1
	tm = mjd2tm(tai2mjd(timet2tai(tp)));
d1148 1
a1148 3
	dt->dt_hour = tm.tm_hour;
	dt->dt_min  = tm.tm_min;
	dt->dt_sec  = tm.tm_sec;
d1150 3
a1152 2
	/* Day of week (Note: 1/1/1970 was a Thursday) */
	dt->dt_dow = tm.tm_wday;
d1154 16
a1169 4
	dt->dt_year = tm.tm_year + 1900 - CLOCK_BASE_YEAR;
	dt->dt_month = tm.tm_mon + 1;
	dt->dt_day = tm.tm_mday;
}
d1171 2
d1174 2
a1175 4
void
dt_to_gmt(struct intersil_dt *dt, time_t *tp)
{
	struct tm tm;
d1177 2
a1178 6
	tm.tm_hour = dt->dt_hour;
	tm.tm_min = dt->dt_min;
	tm.tm_sec = dt->dt_sec;
	tm.tm_mday = dt->dt_day;
	tm.tm_mon = dt->dt_month - 1;
	tm.tm_year = dt->dt_year - 1900 + CLOCK_BASE_YEAR;
d1180 2
a1181 1
	*tp = tai2time2(mjd2tai(tm2mjd(tm)));
a1365 30

struct timeval_old {
	long	tv_sec;
	long	tv_usec;
} time_old;

#if defined(SUN4)
void lo_microtime_old(struct timeval_old *);
#else
void microtime_old(struct timeval_old *);
#define lo_microtime_old microtime_old
#endif

void
#if defined(SUN4)
lo_microtime(struct timeval *tvp)
#else
microtime(struct timeval *tvp)
#endif
{
	struct timeval_old tvo;

	time_old.tv_sec = (long)time.tv_sec;
	time_old.tv_usec = time.tv_usec;

	lo_microtime_old(&tvo);

	tvp->tv_sec = tvo.tv_sec;
	tvp->tv_usec = tvo.tv_usec;
}
@


1.5
log
@wrapper around microtime(9) function using 32 bit second counter.
idea from miod@@openbsd, thanks
@
text
@d1 1
a1 1
/* $MirBSD: src/sys/arch/sparc/sparc/clock.c,v 1.4 2004/07/02 16:52:32 tg Exp $ */
@


1.4
log
@actually use the leap second and TAI conversion routines in the kernel
XXX sparc untested
XXX I hope I don't have off-by-ones or off-by-1900s or off-by-1970s left
@
text
@d1 1
a1 1
/* $MirBSD$ */
d1255 30
@


1.3
log
@second (piecewise) attempt to merge MirBSD #7ter into HEAD
@
text
@d1 3
a3 2
/*	$OpenBSD: clock.c,v 1.18 2002/08/12 10:44:04 miod Exp $	*/
/*	$NetBSD: clock.c,v 1.52 1997/05/24 20:16:05 pk Exp $ */
d6 2
d127 1
a127 1
long	oclk_get_secs(void);
d129 1
a129 1
void	dt_to_gmt(struct intersil_dt *, long *);
d131 2
a132 2
void	oclk_set_secs(long);
void	gmt_to_dt(long *, struct intersil_dt *);
d205 1
a205 1
int chiptotime(int, int, int, int, int, int);
d260 2
a261 2
	/* 
	 * calibrate delay() 
d283 1
a283 1
			       timerblurb);
d494 1
a494 1
			     sizeof(struct timer_4m));
d496 1
a496 1
			     sizeof(struct counter_4m));
d514 1
a514 1
			     sizeof(struct timerreg_4));
a796 15
#define	SECDAY		(24 * 60 * 60)
#define	SECYR		(SECDAY * 365)
/*
 * should use something like
 * #define LEAPYEAR(y) ((((y) % 4) == 0 && ((y) % 100) != 0) || ((y) % 400) == 0)
 * but it's unlikely that we'll still be around in 2100.
 */
#define	LEAPYEAR(y)	(((y) & 3) == 0)

/*
 * This code is defunct after 2068.
 * Will Unix still be here then??
 */
const short dayyr[12] =
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
d798 2
a799 3
int
chiptotime(sec, min, hour, day, mon, year)
	int sec, min, hour, day, mon, year;
d801 1
a801 1
	int days, yr;
a802 3
	sec = FROMBCD(sec);
	min = FROMBCD(min);
	hour = FROMBCD(hour);
d804 1
a804 1
	mon = FROMBCD(mon);
d810 9
a818 8
	days = 0;
	for (yr = 70; yr < year; yr++)
		days += LEAPYEAR(yr) ? 366 : 365;
	days += dayyr[mon - 1] + day - 1;
	if (LEAPYEAR(yr) && mon > 2)
		days++;
	/* now have days since Jan 1, 1970; the rest is easy... */
	return (days * SECDAY + hour * 3600 + min * 60 + sec);
d832 1
a832 2
timetochip(c)
	struct chiptime *c;
d834 1
a834 1
	int t, t2, t3, now = time.tv_sec;
d836 1
a836 18
	/* compute the year */
	t2 = now / SECDAY;
	t3 = (t2 + 2) % 7;	/* day of week */
	c->wday = TOBCD(t3 + 1);

	t = 69;
	while (t2 >= 0) {	/* whittle off years */
		t3 = t2;
		t++;
		t2 -= LEAPYEAR(t) ? 366 : 365;
	}
	c->year = t;

	/* t3 = month + day; separate */
	t = LEAPYEAR(t);
	for (t2 = 1; t2 < 12; t2++)
		if (t3 < dayyr[t2] + (t && t2 > 1))
			break;
d838 6
a843 19
	/* t2 is month */
	c->mon = t2;
	c->day = t3 - dayyr[t2 - 1] + 1;
	if (t && t2 > 2)
		c->day--;

	/* the rest is easy */
	t = now % SECDAY;
	c->hour = t / 3600;
	t %= 3600;
	c->min = t / 60;
	c->sec = t % 60;

	c->sec = TOBCD(c->sec);
	c->min = TOBCD(c->min);
	c->hour = TOBCD(c->hour);
	c->day = TOBCD(c->day);
	c->mon = TOBCD(c->mon);
	c->year = TOBCD(c->year - YEAR0);
d850 1
a850 2
inittodr(base)
	time_t base;
d855 1
a889 1
		printf("WARNING: bad date in battery clock");
d894 1
d899 1
a899 1
		int deltat = time.tv_sec - base;
d905 2
d909 5
a914 1
	printf(" -- CHECK AND RESET THE DATE!\n");
d924 1
a924 1
resettodr()
d958 2
a959 2
long
oclk_get_secs()
d961 2
a962 2
        struct intersil_dt dt;
        long gmt;
d964 3
a966 3
        oclk_get_dt(&dt);
        dt_to_gmt(&dt, &gmt);
        return (gmt);
d970 1
a970 2
oclk_set_secs(secs)
	long secs;
d972 2
a973 2
        struct intersil_dt dt;
        long gmt;
d975 3
a977 3
        gmt = secs;
        gmt_to_dt(&gmt, &dt);
        oclk_set_dt(&dt);
d986 1
a986 2
oclk_get_dt(dt)
	struct intersil_dt *dt;
d988 2
a989 2
        int s;
        register volatile char *src, *dst;
d991 1
a991 1
        src = (char *) &i7->counters;
d993 13
a1005 13
        s = splhigh();
        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);

        dst = (char *) dt;
        dt++;   /* end marker */
        do {
                *dst++ = *src++;
        } while (dst < (char *)dt);

        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
        splx(s);
d1009 1
a1009 2
oclk_set_dt(dt)
	struct intersil_dt *dt;
d1011 4
a1014 2
        int s;
        register volatile char *src, *dst;
d1016 9
a1024 1
        dst = (char *) &i7->counters;
d1026 3
a1028 13
        s = splhigh();
        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);

        src = (char *) dt;
        dt++;   /* end marker */
        do {
                *dst++ = *src++;
        } while (src < (char *)dt);

        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
        splx(s);
d1036 1
a1036 1
#define CLOCK_BASE_YEAR 1968
d1038 4
a1041 7
/* Traditional UNIX base year */
#define POSIX_BASE_YEAR 1970
#define FEBRUARY        2

#define leapyear(year)          ((year) % 4 == 0)
#define days_in_year(a)         (leapyear(a) ? 366 : 365)
#define days_in_month(a)        (month_days[(a) - 1])
d1043 5
a1047 3
static int month_days[12] = {
        31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
d1049 2
a1050 36
void
gmt_to_dt(tp, dt)
	long *tp;
	struct intersil_dt *dt;
{
        int i;
        long days, secs;

        days = *tp / SECDAY;
        secs = *tp % SECDAY;

        /* Hours, minutes, seconds are easy */
        dt->dt_hour = secs / 3600;
        secs = secs % 3600;
        dt->dt_min  = secs / 60;
        secs = secs % 60;
        dt->dt_sec  = secs;

        /* Day of week (Note: 1/1/1970 was a Thursday) */
        dt->dt_dow = (days + 4) % 7;

        /* Number of years in days */
        i = POSIX_BASE_YEAR;
        while (days >= days_in_year(i)) {
                days -= days_in_year(i);
                i++;
        }
        dt->dt_year = i - CLOCK_BASE_YEAR;

        /* Number of months in days left */
        if (leapyear(i))
                days_in_month(FEBRUARY) = 29;
        for (i = 1; days >= days_in_month(i); i++)
                days -= days_in_month(i);
        days_in_month(FEBRUARY) = 28;
        dt->dt_month = i;
d1052 3
a1054 2
        /* Days are what is left over (+1) from all that. */
        dt->dt_day = days + 1;
d1059 1
a1059 3
dt_to_gmt(dt, tp)
	struct intersil_dt *dt;
	long *tp;
d1061 1
a1061 36
        int i;
        long tmp;
        int year;

        /*
         * Hours are different for some reason. Makes no sense really.
         */

        tmp = 0;

        if (dt->dt_hour >= 24) goto out;
        if (dt->dt_day  >  31) goto out;
        if (dt->dt_month > 12) goto out;

        year = dt->dt_year + CLOCK_BASE_YEAR;


        /*
         * Compute days since start of time
         * First from years, then from months.
         */
        for (i = POSIX_BASE_YEAR; i < year; i++)
                tmp += days_in_year(i);
        if (leapyear(year) && dt->dt_month > FEBRUARY)
                tmp++;

        /* Months */
        for (i = 1; i < dt->dt_month; i++)
                tmp += days_in_month(i);
        tmp += (dt->dt_day - 1);

        /* Now do hours */
        tmp = tmp * 24 + dt->dt_hour;

        /* Now do minutes */
        tmp = tmp * 60 + dt->dt_min;
d1063 6
a1068 2
        /* Now do seconds */
        tmp = tmp * 60 + dt->dt_sec;
d1070 1
a1070 2
out:
        *tp = tmp;
@


1.2
log
@Remove "some dead architectures".

These are all but i386 and x86-64 (which is not in the tree yet),
because I have no machines to work with.

Re-adding support should be fairly easy, just cvs adding a partial
OpenBSD checkout and pulling in stuff like kernel signal patch, humantime,
etc. which got added to i386 as well.

You will need gcc support as well.
@
text
@@


1.2.2.1
log
@o move machine-dependent ATM and PLIP options out of mi space
  in i386 GENERIC kernel
o bring back in all of the sparc32 stuff I could find

maintained by: wbx@@
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.19 2004/04/08 01:11:21 deraadt Exp $	*/
a901 1
	char *bad = NULL;
d936 1
a940 1
		bad = "WARNING: bad date in battery clock";
a950 2
		
#ifndef SMALL_KERNEL
a952 6
		bad = "";
#endif
	}
	if (bad) {
		printf("%s", bad);
		printf(" -- CHECK AND RESET THE DATE!\n");
d954 1
@

