head	1.3;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.4
	tg-mergefixes-1-branch:1.1.1.4.0.6
	tg-mergefixes-1-base:1.1.1.4
	MIROS_X:1.1.1.4.0.4
	MIROS_X_BASE:1.1.1.4
	tg-mergetmp-3:1.1.1.4
	MIRBSD_XP_MIRPPC:1.1.1.4.0.2
	cvs-200405160640:1.1.1.4
	cvs-200401271800:1.1.1.4
	cvs-200401261630:1.1.1.4
	cvs-200401021645:1.1.1.4
	cvs-200312222040:1.1.1.4
	cvs-200310020700:1.1.1.3
	cvs-200309271030:1.1.1.3
	cvs-200309261655:1.1.1.3
	cvs-200309251530:1.1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.3
	ctm-3449:1.1.1.3
	ctm-3437:1.1.1.3
	cvs-200307191805:1.1.1.3
	ctm-3425:1.1.1.3
	cvs-200307091500:1.1.1.3
	cvs-200307072125:1.1.1.3
	ctm-3389:1.1.1.3
	cvs-200307021520:1.1.1.3
	cvs-200306291430:1.1.1.3
	ctm-3341:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.3
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	ctm-3255:1.1.1.2
	ctm-3229:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.2
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.11.13.21.06.36;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.06.04.29.47;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.50.10;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.50.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.03.29.19.44.52;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.21.19.06.24;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.22.21.00.07;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@shave some off my work for the first MirHackathon and let
the zombies walk around for bsiegert@@'s voodoo
@
text
@/*	$OpenBSD: db_disasm.c,v 1.14 2003/12/21 15:17:29 miod Exp $	*/
/*
 * Copyright (c) 1996, 2001, 2003 Dale Rahn. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>

#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_variables.h>
#include <ddb/db_interface.h>
#include <ddb/db_output.h>

enum opf {
	Opf_INVALID,
	Opf_A,
	Opf_A0,
	Opf_B,
	Opf_BI,
	Opf_BI1,
	Opf_BO,
	Opf_CRM,
	Opf_D,
	Opf_S,
	Opf_FM,
	Opf_LK,
	Opf_RC,
	Opf_AA,
	Opf_LI,
	Opf_OE,
	Opf_SR,
	Opf_TO,
	Opf_SIMM,
	Opf_UIMM,
	Opf_d,
	Opf_crbA,
	Opf_crbB,
	Opf_crbD,
	Opf_crfD,
	Opf_crfS,
	Opf_spr,
	Opf_tbr,

	Opf_BD,
	Opf_C,

	Opf_NB,

	Opf_sh,
	Opf_SH,
	Opf_mb,
	Opf_MB,
	Opf_ME,
};


struct db_field {
	char *name;
	enum opf opf;
} db_fields[] = {
	{ "A",		Opf_A },
	{ "A0",		Opf_A0 },
	{ "B",		Opf_B },
	{ "D",		Opf_D },
	{ "S",		Opf_S },
	{ "AA",		Opf_AA },
	{ "LI",		Opf_LI },
	{ "BD",		Opf_BD },
	{ "BI",		Opf_BI },
	{ "BI1",	Opf_BI1 },
	{ "BO",		Opf_BO },
	{ "CRM",	Opf_CRM },
	{ "FM",		Opf_FM },
	{ "LK",		Opf_LK },
	{ "MB",		Opf_MB },
	{ "ME",		Opf_ME },
	{ "NB",		Opf_NB },
	{ "OE",		Opf_OE },
	{ "RC",		Opf_RC },
	{ "SH",		Opf_SH },
	{ "SR",		Opf_SR },
	{ "TO",		Opf_TO },
	{ "SIMM",	Opf_SIMM },
	{ "UIMM",	Opf_UIMM },
	{ "crbA",	Opf_crbA },
	{ "crbB",	Opf_crbB },
	{ "crbD",	Opf_crbD },
	{ "crfD",	Opf_crfD },
	{ "crfS",	Opf_crfS },
	{ "d",		Opf_d },
	{ "mb",		Opf_mb },
	{ "sh",		Opf_sh },
	{ "spr",	Opf_spr },
	{ "tbr",	Opf_tbr },
	{ NULL,		0 }
};

struct opcode {
	char *name;
	u_int32_t mask;
	u_int32_t code;
	char *decode_str;
};

typedef u_int32_t instr_t;
typedef void (op_class_func) (u_int32_t addr, instr_t instr);

u_int32_t extract_field(u_int32_t value, u_int32_t base, u_int32_t width);
void disasm_fields(u_int32_t addr, const struct opcode *popcode, instr_t instr,
    char *disasm_str, size_t bufsize);
void disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt,
    char *ppoutput, size_t bufsize);
void dis_ppc(u_int32_t addr, const struct opcode *opcodeset, instr_t instr);


op_class_func op_ill, op_base;
op_class_func op_cl_x13, op_cl_x1e, op_cl_x1f;
op_class_func op_cl_x3a, op_cl_x3b;
op_class_func op_cl_x3e, op_cl_x3f;

op_class_func *opcodes_base[] = {
/*x00*/	op_ill,		op_ill,		op_base,	op_ill,
/*x04*/	op_ill,		op_ill,		op_ill,		op_base,
/*x08*/	op_base,	op_base,	op_base,	op_base,
/*x0C*/	op_base,	op_base,	op_base/*XXX*/,	op_base/*XXX*/,
/*x10*/	op_base,	op_base,	op_base,	op_cl_x13,
/*x14*/	op_base,	op_base,	op_ill,		op_base,
/*x18*/	op_base,	op_base,	op_base,	op_base,
/*x1C*/	op_base,	op_base,	op_cl_x1e,	op_cl_x1f,
/*x20*/	op_base,	op_base,	op_base,	op_base,
/*x24*/	op_base,	op_base,	op_base,	op_base,
/*x28*/	op_base,	op_base,	op_base,	op_base,
/*x2C*/	op_base,	op_base,	op_base,	op_base,
/*x30*/	op_base,	op_base,	op_base,	op_base,
/*x34*/	op_base,	op_base,	op_base,	op_base,
/*x38*/	op_ill,		op_ill,		op_cl_x3a,	op_cl_x3b,
/*x3C*/	op_ill,		op_ill,		op_cl_x3e,	op_cl_x3f
};


/* This table could be modified to make significant the "reserved" fields
 * of the opcodes, But I didn't feel like it when typing in the table,
 * I would recommend that this table be looked over for errors,
 * This was derived from the table in Appendix A.2 of (Mot part # MPCFPE/AD)
 * PowerPC Microprocessor Family: The Programming Environments
 */
	
const struct opcode opcodes[] = {
	{ "tdi",	0xfc000000, 0x08000000, " %{TO},%{A},%{SIMM}" },
	{ "twi",	0xfc000000, 0x0c000000, " %{TO},%{A},%{SIMM}" },

	{ "mulli",	0xfc000000, 0x1c000000, " %{D},%{A},%{SIMM}" },
	{ "subfic",	0xfc000000, 0x20000000, " %{D},%{A},%{SIMM}" },
	{ "cmpli",	0xff800000, 0x28000000, " %{A},%{UIMM}" },
	{ "cmpli",	0xfc400000, 0x28000000, " %{crfD}%{A}, %{UIMM}" },
	{ "cmpi",	0xff800000, 0x2c000000, " %{A},%{SIMM}"},
	{ "cmpi",	0xfc400000, 0x2c000000, " %{crfD}%{A},%{SIMM}" },
	{ "addic",	0xfc000000, 0x30000000, " %{D},%{A},%{SIMM}" },
	{ "addic.",	0xfc000000, 0x34000000, " %{D},%{A},%{SIMM}" },
	{ "addi",	0xfc000000, 0x38000000, " %{D},%{A0}%{SIMM}" },
	{ "addis",	0xfc000000, 0x3c000000, " %{D},%{A0}%{SIMM}" },
	{ "sc",		0xffffffff, 0x44000002, "" },
	{ "b",		0xfc000000, 0x40000000, "%{BO}%{LK}%{AA} %{BI}%{BD}" },
	{ "b",		0xfc000000, 0x48000000, "%{LK}%{AA} %{LI}" },

	{ "rlwimi",	0xfc000000, 0x50000000, "%{RC} %{A},%{S},%{SH},%{MB},%{ME}" },
	{ "rlwinm",	0xfc000000, 0x54000000, "%{RC} %{A},%{S},%{SH},%{MB},%{ME}" },
	{ "rlwnm",	0xfc000000, 0x5c000000, "%{RC} %{A},%{S},%{SH},%{MB},%{ME}" },

	{ "ori",	0xfc000000, 0x60000000, " %{A},%{S},%{UIMM}" },
	{ "oris",	0xfc000000, 0x64000000, " %{A},%{S},%{UIMM}" },
	{ "xori",	0xfc000000, 0x68000000, " %{A},%{S},%{UIMM}" },
	{ "xoris",	0xfc000000, 0x6c000000, " %{A},%{S},%{UIMM}" },

	{ "andi.",	0xfc000000, 0x70000000, " %{A},%{S},%{UIMM}" },
	{ "andis.",	0xfc000000, 0x74000000, " %{A},%{S},%{UIMM}" },

	{ "lwz",	0xfc000000, 0x80000000, " %{D},%{d}(%{A})" },
	{ "lwzu",	0xfc000000, 0x84000000, " %{D},%{d}(%{A})" },
	{ "lbz",	0xfc000000, 0x88000000, " %{D},%{d}(%{A})" },
	{ "lbzu",	0xfc000000, 0x8c000000, " %{D},%{d}(%{A})" },
	{ "stw",	0xfc000000, 0x90000000, " %{S},%{d}(%{A})" },
	{ "stwu",	0xfc000000, 0x94000000, " %{S},%{d}(%{A})" },
	{ "stb",	0xfc000000, 0x98000000, " %{S},%{d}(%{A})" },
	{ "stbu",	0xfc000000, 0x9c000000, " %{S},%{d}(%{A})" },

	{ "lhz",	0xfc000000, 0xa0000000, " %{D},%{d}(%{A})" },
	{ "lhzu",	0xfc000000, 0xa4000000, " %{D},%{d}(%{A})" },
	{ "lha",	0xfc000000, 0xa8000000, " %{D},%{d}(%{A})" },
	{ "lhau",	0xfc000000, 0xac000000, " %{D},%{d}(%{A})" },
	{ "sth",	0xfc000000, 0xb0000000, " %{S},%{d}(%{A})" },
	{ "sthu",	0xfc000000, 0xb4000000, " %{S},%{d}(%{A})" },
	{ "lmw",	0xfc000000, 0xb8000000, " %{D},%{d}(%{A})" },
	{ "stmw",	0xfc000000, 0xbc000000, " %{S},%{d}(%{A})" },

	{ "lfs",	0xfc000000, 0xc0000000, " %{D},%{d}(%{A})" },
	{ "lfsu",	0xfc000000, 0xc4000000, " %{D},%{d}(%{A})" },
	{ "lfd",	0xfc000000, 0xc8000000, " %{D},%{d}(%{A})" },
	{ "lfdu",	0xfc000000, 0xcc000000, " %{D},%{d}(%{A})" },

	{ "stfs",	0xfc000000, 0xd0000000, " %{S},%{d}(%{A})" },
	{ "stfsu",	0xfc000000, 0xd4000000, " %{S},%{d}(%{A})" },
	{ "stfd",	0xfc000000, 0xd8000000, " %{S},%{d}(%{A})" },
	{ "stfdu",	0xfc000000, 0xdc000000, " %{S},%{d}(%{A})" },
	{ "",		0x0,		0x0, "" }

};

/* 13 * 4 = 4c */
const struct opcode opcodes_13[] = {
/* 0x13 << 2 */
	{ "mcrf",	0xfc0007fe, 0x4c000000, " %{crfD},%{crfS}" },
	{ "b",/*bclr*/	0xfc0007fe, 0x4c000020, "%{BO}lr%{LK} %{BI1}" },
	{ "crnor",	0xfc0007fe, 0x4c000042, " %{crbD},%{crbA},%{crbB}" },
	{ "rfi",	0xfc0007fe, 0x4c000064, "" },
	{ "crandc",	0xfc0007fe, 0x4c000102, " %{crbD},%{crbA},%{crbB}" },
	{ "isync",	0xfc0007fe, 0x4c00012c, "" },
	{ "crxor",	0xfc0007fe, 0x4c000182, " %{crbD},%{crbA},%{crbB}" },
	{ "crnand",	0xfc0007fe, 0x4c0001c2, " %{crbD},%{crbA},%{crbB}" },
	{ "crand",	0xfc0007fe, 0x4c000202, " %{crbD},%{crbA},%{crbB}" },
	{ "creqv",	0xfc0007fe, 0x4c000242, " %{crbD},%{crbA},%{crbB}" },
	{ "crorc",	0xfc0007fe, 0x4c000342, " %{crbD},%{crbA},%{crbB}" },
	{ "cror",	0xfc0007fe, 0x4c000382, " %{crbD},%{crbA},%{crbB}" },
	{ "b"/*bcctr*/,	0xfc0007fe, 0x4c000420, "%{BO}ctr%{LK} %{BI1}" },
	{ "",		0x0,		0x0, "" }
};

/* 1e * 4 = 78 */
const struct opcode opcodes_1e[] = {
	{ "rldicl",	0xfc00001c, 0x78000000, " %{A},%{S},%{sh},%{mb}" },
	{ "rldicr",	0xfc00001c, 0x78000004, " %{A},%{S},%{sh},%{mb}" },
	{ "rldic",	0xfc00001c, 0x78000008, " %{A},%{S},%{sh},%{mb}" },
	{ "rldimi",	0xfc00001c, 0x7800000c, " %{A},%{S},%{sh},%{mb}" },
	{ "rldcl",	0xfc00003e, 0x78000010, " %{A},%{S},%{B},%{mb}" },
	{ "rldcr",	0xfc00003e, 0x78000012, " %{A},%{S},%{B},%{mb}" },
	{ "",		0x0,		0x0, "" }
};

/* 1f * 4 = 7c */
const struct opcode opcodes_1f[] = {
/* 1f << 2 */
	{ "cmpd",	0xfc2007fe, 0x7c200000, " %{crfD}%{A},%{B}" },
	{ "cmpw",	0xfc2007fe, 0x7c000000, " %{crfD}%{A},%{B}" },
	{ "tw",		0xfc0007fe, 0x7c000008, " %{TO},%{A},%{B}" },
	{ "subfc",	0xfc0003fe, 0x7c000010, "%{OE}%{RC} %{D},%{A},%{B}" },
	{ "mulhdu",	0xfc0007fe, 0x7c000012, "%{RC} %{D},%{A},%{B}" },
	{ "addc",	0xfc0003fe, 0x7c000014, "%{OE}%{RC} %{D},%{A},%{B}" },
	{ "mulhwu",	0xfc0007fe, 0x7c000016, "%{RC} %{D},%{A},%{B}" },

	{ "mfcr",	0xfc0007fe, 0x7c000026, " %{D}" },
	{ "lwarx",	0xfc0007fe, 0x7c000028, " %{D},%{A0}%{B}" },
	{ "ldx",	0xfc0007fe, 0x7c00002a, " %{D},%{A0}%{B}" },
	{ "lwzx",	0xfc0007fe, 0x7c00002e, " %{D},%{A0}%{B}" },
	{ "slw",	0xfc0007fe, 0x7c000030, "%{RC} %{A},%{S},%{B}" },
	{ "cntlzw",	0xfc0007fe, 0x7c000034, "%{RC} %{A},%{S}" },
	{ "sld",	0xfc0007fe, 0x7c000036, "%{RC} %{A},%{S},%{B}" },
	{ "and",	0xfc0007fe, 0x7c000038, "%{RC} %{A},%{S},%{B}" },
	{ "cmpld",	0xfc2007fe, 0x7c200040, " %{crfD}%{A},%{B}" },
	{ "cmplw",	0xfc2007fe, 0x7c000040, " %{crfD}%{A},%{B}" },
	{ "subf",	0xfc0003fe, 0x7c000050, "%{OE}%{RC} %{D},%{A},%{B}" },
	{ "ldux",	0xfc0007fe, 0x7c00006a, " %{D},%{A},%{B}" },
	{ "dcbst",	0xfc0007fe, 0x7c00006c, " %{A0}%{B}" },
	{ "lwzux",	0xfc0007fe, 0x7c00006e, " %{D},%{A},%{B}" },
	{ "cntlzd",	0xfc0007fe, 0x7c000074, "%{RC} %{A},%{S}" },
	{ "andc",	0xfc0007fe, 0x7c000078, "%{RC} %{A},%{S},%{B}" },
	{ "td",		0xfc0007fe, 0x7c000088, " %{TO},%{A},%{B}" },
	{ "mulhd",	0xfc0007fe, 0x7c000092, "%{RC} %{D},%{A},%{B}" },
	{ "mulhw",	0xfc0007fe, 0x7c000096, "%{RC} %{D},%{A},%{B}" },
	{ "mfmsr",	0xfc0007fe, 0x7c0000a6, " %{D}" },
	{ "ldarx",	0xfc0007fe, 0x7c0000a8, " %{D},%{A0}%{B}" },
	{ "dcbf",	0xfc0007fe, 0x7c0000ac, " %{A0}%{B}" },
	{ "lbzx",	0xfc0007fe, 0x7c0000ae, " %{D},%{A0}%{B}" },
	{ "neg",	0xfc0003fe, 0x7c0000d0, "%{OE}%{RC} %{D},%{A}" },
	{ "lbzux",	0xfc0007fe, 0x7c0000ee, " %{D},%{A},%{B}" },
	{ "nor",	0xfc0007fe, 0x7c0000f8, "%{RC} %{A},%{S}" },
	{ "subfe",	0xfc0003fe, 0x7c000110, "%{OE}%{RC} %{D},%{A}" },
	{ "adde",	0xfc0003fe, 0x7c000114, "%{OE}%{RC} %{D},%{A}" },
	{ "mtcrf",	0xfc0007fe, 0x7c000120, " %{S},%{CRM}" },
	{ "mtmsr",	0xfc0007fe, 0x7c000124, " %{S}" },
	{ "stdx",	0xfc0007fe, 0x7c00012a, " %{S},%{A0}%{B}" },
	{ "stwcx.",	0xfc0007ff, 0x7c00012d, " %{S},%{A},%{B}" },
	{ "stwx",	0xfc0007fe, 0x7c00012e, " %{S},%{A},%{B}" },
	{ "stdux",	0xfc0007fe, 0x7c00016a, " %{S},%{A},%{B}" },
	{ "stwux",	0xfc0007fe, 0x7c00016e, " %{S},%{A},%{B}" },
	{ "subfze",	0xfc0003fe, 0x7c000190, "%{OE}%{RC} %{D},%{A}" },
	{ "addze",	0xfc0003fe, 0x7c000194, "%{OE}%{RC} %{D},%{A}" },
	{ "mtsr",	0xfc0007fe, 0x7c0001a4, " %{SR},%{S}" },
	{ "stdcx.",	0xfc0007ff, 0x7c0001ad, " %{S},%{A0}%{B}" },
	{ "stbx",	0xfc0007fe, 0x7c0001ae, " %{S},%{A0}%{B}" },
	{ "subfme",	0xfc0003fe, 0x7c0001d0, "%{OE}%{RC} %{D},%{A}" },
	{ "mulld",	0xfc0003fe, 0x7c0001d2, "%{OE}%{RC} %{D},%{A},%{B}" },
	{ "addme",	0xfc0003fe, 0x7c0001d4, "%{OE}%{RC} %{D},%{A}" },
	{ "mullw",	0xfc0003fe, 0x7c0001d6, "%{OE}%{RC} %{D},%{A},%{B}" },
	{ "mtsrin",	0xfc0007fe, 0x7c0001e4, " %{S},%{B}" },
	{ "dcbtst",	0xfc0007fe, 0x7c0001ec, " %{A0}%{B}" },
	{ "stbux",	0xfc0007fe, 0x7c0001ee, " %{S},%{A},%{B}" },
	{ "add",	0xfc0003fe, 0x7c000214, "" },
	{ "dcbt",	0xfc0007fe, 0x7c00022c, " %{A0}%{B}" },
	{ "lhzx",	0xfc0007ff, 0x7c00022e, " %{D},%{A0}%{B}" },
	{ "eqv",	0xfc0007fe, 0x7c000238, "%{RC} %{A},%{S},%{B}" },
	{ "tlbie",	0xfc0007fe, 0x7c000264, " %{B}" },
	{ "eciwx",	0xfc0007fe, 0x7c00026c, " %{D},%{A0}%{B}" },
	{ "lhzux",	0xfc0007fe, 0x7c00026e, " %{D},%{A},%{B}" },
	{ "xor",	0xfc0007fe, 0x7c000278, "%{RC} %{A},%{S},%{B}" },
	{ "mfspr",	0xfc0007fe, 0x7c0002a6, " %{D},%{spr}" },
	{ "lwax",	0xfc0007fe, 0x7c0002aa, " %{D},%{A0}%{B}" },
	{ "lhax",	0xfc0007fe, 0x7c0002ae, " %{D},%{A},%{B}" },
	{ "tlbia",	0xfc0007fe, 0x7c0002e4, "" },
	{ "mftb",	0xfc0007fe, 0x7c0002e6, " %{D},%{tbr}" },
	{ "lwaux",	0xfc0007fe, 0x7c0002ea, " %{D},%{A},%{B}" },
	{ "lhaux",	0xfc0007fe, 0x7c0002ee, " %{D},%{A},%{B}" },
	{ "sthx",	0xfc0007fe, 0x7c00032e, " %{S},%{A0}%{B}" },
	{ "orc",	0xfc0007fe, 0x7c000338, "%{RC} %{A},%{S},%{B}" },
	{ "ecowx",	0xfc0007fe, 0x7c00036c, "%{RC} %{S},%{A0}%{B}" },
	{ "slbie",	0xfc0007fc, 0x7c000364, " %{B}" },
	{ "sthux",	0xfc0007fe, 0x7c00036e, " %{S},%{A0}%{B}" },
	{ "or",		0xfc0007fe, 0x7c000378, "%{RC} %{A},%{S},%{B}" },
	{ "divdu",	0xfc0003fe, 0x7c000392, "%{OE}%{RC} %{S},%{A},%{B}" },
	{ "divwu",	0xfc0003fe, 0x7c000396, "%{OE}%{RC} %{S},%{A},%{B}" },
	{ "mtspr",	0xfc0007fe, 0x7c0003a6, " %{spr},%{S}" },
	{ "dcbi",	0xfc0007fe, 0x7c0003ac, " %{A0}%{B}" },
	{ "nand",	0xfc0007fe, 0x7c0003b8, "%{RC} %{A},%{S},%{B}" },
	{ "divd",	0xfc0003fe, 0x7c0003d2, "%{OE}%{RC} %{S},%{A},%{B}" },
	{ "divw",	0xfc0003fe, 0x7c0003d6, "%{OE}%{RC} %{S},%{A},%{B}" },
	{ "slbia",	0xfc0003fe, 0x7c0003e4, "%{OE}%{RC} %{S},%{A},%{B}" },
	{ "mcrxr",	0xfc0007fe, 0x7c000400, "crfD1" },
	{ "lswx",	0xfc0007fe, 0x7c00042a, " %{D},%{A0}%{B}" },
	{ "lwbrx",	0xfc0007fe, 0x7c00042c, " %{D},%{A0}%{B}" },
	{ "lfsx",	0xfc0007fe, 0x7c00042e, " %{D},%{A},%{B}" },
	{ "srw",	0xfc0007fe, 0x7c000430, "%{RC} %{A},%{S},%{B}" },
	{ "srd",	0xfc0007fe, 0x7c000436, "%{RC} %{A},%{S},%{B}" },
	{ "tlbsync",	0xffffffff, 0x7c00046c, "" },
	{ "lfsux",	0xfc0007fe, 0x7c00046e, " %{D},%{A},%{B}" },
	{ "mfsr",	0xfc0007fe, 0x7c0004a6, " %{D},%{SR}" },
	{ "lswi",	0xfc0007fe, 0x7c0004aa, " %{D},%{A},%{NB}" },
	{ "sync",	0xfc0007fe, 0x7c0004ac, "" },
	{ "lfdx",	0xfc0007fe, 0x7c0004ae, " %{D},%{A},%{B}" },
	{ "lfdux",	0xfc0007fe, 0x7c0004ee, " %{D},%{A},%{B}" },
	{ "mfsrin",	0xfc0007fe, 0x7c000526, "" },
	{ "stswx",	0xfc0007fe, 0x7c00052a, " %{S},%{A0}%{B}" },
	{ "stwbrx",	0xfc0007fe, 0x7c00052c, " %{S},%{A0}%{B}" },
	{ "stfsx",	0xfc0007fe, 0x7c00052e, " %{S},%{A0}%{B}" },
	{ "stfsux",	0xfc0007fe, 0x7c00056e, " %{S},%{A},%{B}" },
	{ "stswi",	0xfc0007fe, 0x7c0005aa, "%{S},%{A0}%{NB}" },
	{ "stfdx",	0xfc0007fe, 0x7c0005ae, " %{S},%{A0}%{B}" },
	{ "stfdux",	0xfc0007fe, 0x7c0005ee, " %{S},%{A},%{B}" },
	{ "lhbrx",	0xfc0007fe, 0x7c00062c, " %{D},%{A0}%{B}" },
	{ "sraw",	0xfc0007fe, 0x7c000630, " %{A},%{S},%{B}" },
	{ "srad",	0xfc0007fe, 0x7c000634, "%{RC} %{A},%{S},%{B}" },
	{ "srawi",	0xfc0007fe, 0x7c000670, "%{RC} %{A},%{SH}" },
	{ "sradi",	0xfc0007fc, 0x7c000674, " %{A},%{S},%{sh}" },
	{ "eieio",	0xfc0007fe, 0x7c0006ac, "" }, /* MASK? */
	{ "sthbrx",	0xfc0007fe, 0x7c00072c, " %{S},%{A0}%{B}" },
	{ "extsh",	0xfc0007fe, 0x7c000734, "%{RC} %{A},%{S}" },
	{ "extsb",	0xfc0007fe, 0x7c000774, "%{RC} %{A},%{S}" },
	{ "icbi",	0xfc0007fe, 0x7c0007ac, " %{A0}%{B}" },

	{ "stfiwx",	0xfc0007fe, 0x7c0007ae, " %{S},%{A0}%{B}" },
	{ "extsw",	0xfc0007fe, 0x7c0007b4, "%{RC} %{A},%{S}" },
	{ "dcbz",	0xfc0007fe, 0x7c0007ec, " %{A0}%{B}" },
	{ "",		0x0,		0x0, 0, }
};

/* 3a * 4 = e8 */
const struct opcode opcodes_3a[] = {
	{ "ld",		0xfc000003, 0xe8000000, " %{D},${ds}${A}" },
	{ "ldu",	0xfc000003, 0xe8000001, " %{D},${ds}${A}" },
	{ "lwa",	0xfc000003, 0xe8000002, " %{D},${ds}${A}" },
	{ "",		0x0,		0x0, "" }
};

/* 3b * 4 = ec */
const struct opcode opcodes_3b[] = {
	{ "fdivs",	0xfc00003e, 0xec000024, "%{RC} f%{D},f%{A},f%{B}" },
	{ "fsubs",	0xfc00003e, 0xec000028, "%{RC} f%{D},f%{A},f%{B}" },

	{ "fadds",	0xfc00003e, 0xec00002a, "%{RC} f%{D},f%{A},f%{B}" },
	{ "fsqrts",	0xfc00003e, 0xec00002c, "" },
	{ "fres",	0xfc00003e, 0xec000030, "" },
	{ "fmuls",	0xfc00003e, 0xec000032, "%{RC} f%{D},f%{A},f%{C}" },
	{ "fmsubs",	0xfc00003e, 0xec000038, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fmadds",	0xfc00003e, 0xec00003a, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fnmsubs",	0xfc00003e, 0xec00003c, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fnmadds",	0xfc00003e, 0xec00003e, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "",		0x0,		0x0, "" }
};

/* 3e * 4 = f8 */
const struct opcode opcodes_3e[] = {
	{ "std",	0xfc000003, 0xf8000000, " %{D},${ds}${A}" },
	{ "stdu",	0xfc000003, 0xf8000001, " %{D},${ds}${A}" },
	{ "",		0x0,		0x0, "" }
};

/* 3f * 4 = fc */
const struct opcode opcodes_3f[] = {
	{ "fcmpu",	0xfc0007fe, 0xfc000000, " %{crfD},f%{A},f%{B}" },
	{ "frsp",	0xfc0007fe, 0xfc000018, "%{RC} f%{D},f%{B}" },
	{ "fctiw",	0xfc0007fe, 0xfc00001c, "%{RC} f%{D},f%{B}" },
	{ "fctiwz",	0xfc0007fe, 0xfc00001e, "%{RC} f%{D},f%{B}" },

	{ "fdiv",	0xfc00003e, 0xfc000024, "%{RC} f%{D},f%{A},f%{B}" },
	{ "fsub",	0xfc00003e, 0xfc000028, "%{RC} f%{D},f%{A},f%{B}" },
	{ "fadd",	0xfc00003e, 0xfc00002a, "%{RC} f%{D},f%{A},f%{B}" },
	{ "fsqrt",	0xfc00003e, 0xfc00002c, "%{RC} f%{D},f%{B}" },
	{ "fsel",	0xfc00003e, 0xfc00002e, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fmul",	0xfc00003e, 0xfc000032, "%{RC} f%{D},f%{A},f%{C}" },
	{ "frsqrte",	0xfc00003e, 0xfc000034, "%{RC} f%{D},f%{B}" },
	{ "fmsub",	0xfc00003e, 0xfc000038, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fmadd",	0xfc00003e, 0xfc00003a, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fnmsub",	0xfc00003e, 0xfc00003c, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fnmadd",	0xfc00003e, 0xfc00003e, "%{RC} f%{D},f%{A},f%{C},f%{B}" },

	{ "fcmpo",	0xfc0007fe, 0xfc000040, "%{RC} f%{D},f%{A},f%{C}" },
	{ "mtfsb1",	0xfc0007fe, 0xfc00004c, "%{RC} f%{D},f%{A},f%{C}" },
	{ "fneg",	0xfc0007fe, 0xfc000050, "%{RC} f%{D},f%{A},f%{C}" },
	{ "mcrfs",	0xfc0007fe, 0xfc000080, "%{RC} f%{D},f%{A},f%{C}" },
	{ "mtfsb0",	0xfc0007fe, 0xfc00008c, "%{RC} %{crfD},f%{C}" },
	{ "fmr",	0xfc0007fe, 0xfc000090, "%{RC} f%{D},f%{B}" },
	{ "mtfsfi",	0xfc0007fe, 0xfc00010c, "%{RC} %{crfD},f%{C},%{IMM}" },

	{ "fnabs",	0xfc0007fe, 0xfc000110, "%{RC} f%{D},f%{B}" },
	{ "fabs",	0xfc0007fe, 0xfc000210, "%{RC} f%{D},f%{B}" },
	{ "mffs",	0xfc0007fe, 0xfc00048e, "%{RC} f%{D},f%{B}" },
	{ "mtfsf",	0xfc0007fe, 0xfc00058e, "%{RC} %{FM},f%{B}" },
	{ "fctid",	0xfc0007fe, 0xfc00065c, "%{RC} f%{D},f%{B}" },
	{ "fctidz",	0xfc0007fe, 0xfc00065e, "%{RC} f%{D},f%{B}" },
	{ "fcfid",	0xfc0007fe, 0xfc00069c, "%{RC} f%{D},f%{B}" },
	{ "",		0x0,		0x0, "" }
};

void
op_ill(u_int32_t addr, instr_t instr)
{
	db_printf("illegal instruction %x\n", instr);
}

/*
 * Extracts bits out of an instruction opcode, base indicates the lsb
 * to keep.
 * Note that this uses the PowerPC bit number for base, MSb == 0
 * because all of the documentation is written that way.
 */
u_int32_t
extract_field(u_int32_t value, u_int32_t base, u_int32_t width)
{
	u_int32_t mask = (1 << width) - 1;
	return ((value >> (31 - base)) & mask);
}

const struct opcode * search_op(const struct opcode *);

char *db_BOBI_cond[] = {
	"ge",
	"le",
	"ne",
	"ns",
	"lt",
	"gt",
	"eq",
	"so"
};
/* what about prediction directions? */
char *db_BO_op[] = {
	"dnzf",
	"dnzf-",
	"dzf",
	"dzf-",
	"",
	"",
	"",
	"",
	"dnzt",
	"dnzt-",
	"dzt",
	"dzt-",
	"",
	"",
	"",
	"",
	"dnz",
	"dnz",
	"dz",
	"dz",
	"",
	"",
	"",
	"",
	"dnz",
	"dnz",
	"dz",
	"dz",
	"",
	"",
	"",
	""
};

char *BItbl[] = {
	"", "gt", "eq", "so"
};

char BO_uses_tbl[32] = {
	/* 0 */ 1,
	/* 1 */ 1,
	/* 2 */ 1,
	/* 3 */ 1,
	/* 4 */ 0,
	/* 5 */ 0,
	/* 6 */ 0, /* invalid */
	/* 7 */ 0, /* invalid */
	/* 8 */ 1,
	/* 9 */ 1,
	/* a */ 1,
	/* b */ 1,
	/* c */ 0,
	/* d */ 0,
	/* e */ 0, /* invalid */
	/* f */ 1,
	/* 10 */        1,
	/* 11 */        1,
	/* 12 */        1,
	/* 13 */        1,
	/* 14 */        1,
	/* 15 */        0, /* invalid */
	/* 16 */        0, /* invalid */
	/* 17 */        0, /* invalid */
	/* 18 */        0, /* invalid */
	/* 19 */        0, /* invalid */
	/* 1a */        0, /* invalid */
	/* 1b */        0, /* invalid */
	/* 1c */        0, /* invalid */
	/* 1d */        0, /* invalid */
	/* 1e */        0, /* invalid */
	/* 1f */        0, /* invalid */
};

void
disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt,
    char *disasm_buf, size_t bufsize)
{
	char field [8];
	char lbuf[50];
	int i;
	char *pfmt = *ppfmt;
	enum opf opf;
	char *name;
	db_expr_t offset;

	/* find field */
	if (pfmt[0] != '%' || pfmt[1] != '{') {
		printf("error in disasm fmt [%s]\n", pfmt);
	}
	pfmt = &pfmt[2];
	for (i = 0;
	    pfmt[i] != '\0' && pfmt[i] != '}' && i < sizeof(field);
	    i++) {
		field[i] = pfmt[i];
	}
	if (i == sizeof(field)) {
		printf("error in disasm fmt [%s]\n", pfmt);
		return;
	}
	field[i] = 0;
	if (pfmt[i] == '\0') {
		/* match following close paren { */
		printf("disasm_process_field: missing } in [%s]\n", pfmt);
	}
	*ppfmt = &pfmt[i+1];
	opf = Opf_INVALID;
	for (i = 0; db_fields[i].name != NULL; i++) {
		if (strcmp(db_fields[i].name, field) == 0) {
			opf = db_fields[i].opf;
			break;
		}
	}
	switch (opf) {
	case Opf_INVALID:
		{
			printf("unable to find variable [%s]\n", field);
		}
	case Opf_A:
		{
			u_int A;
			A = extract_field(instr, 15, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", A);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_A0:
		{
			u_int A;
			A = extract_field(instr, 15, 5);
			if (A != 0) {
				snprintf(lbuf, sizeof (lbuf), "r%d,", A);
				strlcat (disasm_buf, lbuf, bufsize);
			}
		}
		break;
	case Opf_AA:
		if (instr & 0x2) {
			strlcat (disasm_buf, "a", bufsize);
		}
		break;
	case Opf_LI:
		{
			u_int LI;
			LI = extract_field(instr, 29, 24);
			LI = LI << 2;
			if (LI & 0x02000000) {
				LI |= ~0x03ffffff;
			}
			if ((instr & (1 << 1)) == 0) {
				/* CHECK AA bit */
				LI = addr + LI;
			}
			db_find_sym_and_offset(LI, &name, &offset);
			if (name) {
				if (offset == 0) {
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s)", LI, name);
					strlcat (disasm_buf, lbuf, bufsize);
				} else {
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s+0x%lx)", LI, name,
					    offset);
					strlcat (disasm_buf, lbuf, bufsize);
				}
			} else {
				snprintf(lbuf, sizeof (lbuf), "0x%x", LI);
				strlcat (disasm_buf, lbuf, bufsize);
			}
		}
		break;
	case Opf_B:
		{
			u_int B;
			B = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", B);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_BD:
		{
			u_int BD;
			BD = extract_field(instr, 29, 14);
			BD = BD << 2;
			if (BD & 0x00008000) {
				BD &= ~0x00007fff;
			}
			if ((instr & (1 << 1)) == 0) {
				/* CHECK AA bit */
				BD = addr + BD;
			}
			db_find_sym_and_offset(BD, &name, &offset);
			if (name) {
				if (offset == 0) {
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s)", BD, name);
					strlcat (disasm_buf, lbuf, bufsize);
				} else {
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s+0x%lx)", BD, name, offset);
					strlcat (disasm_buf, lbuf, bufsize);
				}
			} else {
				snprintf(lbuf, sizeof (lbuf), "0x%x", BD);
				strlcat (disasm_buf, lbuf, bufsize);
			}
		}
		break;
	case Opf_BI1:
	case Opf_BI:
		{
			int BO, BI, cr, printcomma = 0;
			BO = extract_field(instr, 10, 5);
			BI = extract_field(instr, 15, 5);
			cr =  (BI >> 2) & 7;
			if (cr != 0) {
				snprintf(lbuf, sizeof (lbuf), "cr%d", cr);
				strlcat (disasm_buf, lbuf, bufsize);
				printcomma = 1;
			}
			if (BO_uses_tbl[BO]) {
				if ((cr != 0) && ((BI & 3) != 0) &&
				    BO_uses_tbl[BO] != 0)
					strlcat (disasm_buf, "+", bufsize);

				snprintf(lbuf, sizeof (lbuf), "%s",
				    BItbl[BI & 3]);
				strlcat (disasm_buf, lbuf, bufsize);
				printcomma = 1;
			}
			if ((opf == Opf_BI) && printcomma)
				strlcat (disasm_buf, ",", bufsize);
		}
		break;
	case Opf_BO:
		{
			int BO, BI;
			BO = extract_field(instr, 10, 5);
			strlcat (disasm_buf, db_BO_op[BO], bufsize);
			if ((BO & 4) != 0) {
				BI = extract_field(instr, 15, 5);
				strlcat (disasm_buf,
				    db_BOBI_cond[(BI & 0x3)| (((BO & 8) >> 1))],
				    bufsize);

				if (BO & 1)
					strlcat (disasm_buf, "-", bufsize);
			}
		}
		break;
	case Opf_C:
		{
			u_int C;
			C = extract_field(instr, 25, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d, ", C);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_CRM:
		{
			u_int CRM;
			CRM = extract_field(instr, 19, 8);
			snprintf(lbuf, sizeof (lbuf), "0x%x", CRM);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_FM:
		{
			u_int FM;
			FM = extract_field(instr, 10, 8);
			snprintf(lbuf, sizeof (lbuf), "%d", FM);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_LK:
		if (instr & 0x1) {
			strlcat (disasm_buf, "l", bufsize);
		}
		break;
	case Opf_MB:
		{
			u_int MB;
			MB = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", MB);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_ME:
		{
			u_int ME;
			ME = extract_field(instr, 25, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", ME);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_NB:
		{
			u_int NB;
			NB = extract_field(instr, 20, 5);
			if (NB == 0 ) {
				NB=32;
			}
			snprintf(lbuf, sizeof (lbuf), "%d", NB);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_OE:
		if (instr & (1 << (31-21))) {
			strlcat (disasm_buf, "o", bufsize);
		}
		break;
	case Opf_RC:
		if (instr & 0x1) {
			strlcat (disasm_buf, ".", bufsize);
		}
		break;
	case Opf_S:
	case Opf_D:
		{
			u_int D;
			/* S and D are the same */
			D = extract_field(instr, 10, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", D);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_SH:
		{
			u_int SH;
			SH = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", SH);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_SIMM:
	case Opf_d:
		{
			int32_t IMM;
			IMM = extract_field(instr, 31, 16);
			if (IMM & 0x8000)
				IMM |= ~0x7fff;
			snprintf(lbuf, sizeof (lbuf), "%d", IMM);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_UIMM:
		{
			u_int32_t IMM;
			IMM = extract_field(instr, 31, 16);
			snprintf(lbuf, sizeof (lbuf), "0x%x", IMM);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_SR:
		{
			u_int SR;
			SR = extract_field(instr, 15, 3);
			snprintf(lbuf, sizeof (lbuf), "sr%d", SR);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_TO:
		{
			u_int TO;
			TO = extract_field(instr, 10, 1);
			snprintf(lbuf, sizeof (lbuf), "%d", TO);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_crbA:
		{
			u_int crbA;
			crbA = extract_field(instr, 15, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", crbA);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_crbB:
		{
			u_int crbB;
			crbB = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", crbB);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_crbD:
		{
			u_int crfD;
			crfD = extract_field(instr, 8, 3);
			snprintf(lbuf, sizeof (lbuf), "crf%d", crfD);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_crfD:
		{
			u_int crfD;
			crfD = extract_field(instr, 8, 3);
			snprintf(lbuf, sizeof (lbuf), "crf%d", crfD);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_crfS:
		{
			u_int crfS;
			crfS = extract_field(instr, 13, 3);
			snprintf(lbuf, sizeof (lbuf), "%d", crfS);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
		break;
	case Opf_mb:
		{
			u_int mb, mbl, mbh;
			mbl = extract_field(instr, 25, 4);
			mbh = extract_field(instr, 26, 1);
			mb = mbh << 4 | mbl;
			snprintf(lbuf, sizeof (lbuf), ", %d", mb);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_sh:
		{
			u_int sh, shl, shh;
			shl = extract_field(instr, 19, 4);
			shh = extract_field(instr, 20, 1);
			sh = shh << 4 | shl;
			snprintf(lbuf, sizeof (lbuf), ", %d", sh);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_spr:
		{
			u_int spr;
			u_int sprl;
			u_int sprh;
			char *reg;
			sprl = extract_field(instr, 15, 5);
			sprh = extract_field(instr, 20, 5);
			spr = sprh << 5 | sprl;

			/* this table could be written better */
			switch (spr) {
			case	1:
				reg = "xer";
				break;
			case	8:
				reg = "lr";
				break;
			case	9:
				reg = "ctr";
				break;
			case	18:
				reg = "dsisr";
				break;
			case	19:
				reg = "dar";
				break;
			case	22:
				reg = "dec";
				break;
			case	25:
				reg = "sdr1";
				break;
			case	26:
				reg = "srr0";
				break;
			case	27:
				reg = "srr1";
				break;
			case	272:
				reg = "SPRG0";
				break;
			case	273:
				reg = "SPRG1";
				break;
			case	274:
				reg = "SPRG3";
				break;
			case	275:
				reg = "SPRG3";
				break;
			case	280:
				reg = "asr";
				break;
			case	282:
				reg = "aer";
				break;
			case	287:
				reg = "pvr";
				break;
			case	528:
				reg = "ibat0u";
				break;
			case	529:
				reg = "ibat0l";
				break;
			case	530:
				reg = "ibat1u";
				break;
			case	531:
				reg = "ibat1l";
				break;
			case	532:
				reg = "ibat2u";
				break;
			case	533:
				reg = "ibat2l";
				break;
			case	534:
				reg = "ibat3u";
				break;
			case	535:
				reg = "ibat3l";
				break;
			case	536:
				reg = "dbat0u";
				break;
			case	537:
				reg = "dbat0l";
				break;
			case	538:
				reg = "dbat1u";
				break;
			case	539:
				reg = "dbat1l";
				break;
			case	540:
				reg = "dbat2u";
				break;
			case	541:
				reg = "dbat2l";
				break;
			case	542:
				reg = "dbat3u";
				break;
			case	543:
				reg = "dbat3l";
				break;
			case	1013:
				reg = "dabr";
				break;
			default:
				reg = 0;
			}
			if (reg == 0) {
				snprintf(lbuf, sizeof (lbuf), "spr%d", spr);
				strlcat (disasm_buf, lbuf, bufsize);
			} else {
				snprintf(lbuf, sizeof (lbuf), "%s", reg);
				strlcat (disasm_buf, lbuf, bufsize);
			}
		}
		break;
	case Opf_tbr:
		{
			u_int tbr;
			u_int tbrl;
			u_int tbrh;
			char *reg = NULL;
			tbrl = extract_field(instr, 15, 5);
			tbrh = extract_field(instr, 20, 5);
			tbr = tbrh << 5 | tbrl;

			switch (tbr) {
			case 268:
				reg = "tbl";
				break;
			case 269:
				reg = "tbu";
				break;
			default:
				reg = 0;
			}
			if (reg == NULL) {
				snprintf(lbuf, sizeof (lbuf), "tbr%d", tbr);
				strlcat (disasm_buf, lbuf, bufsize);
			} else {
				snprintf(lbuf, sizeof (lbuf), "%s", reg);
				strlcat (disasm_buf, lbuf, bufsize);
			}
		}
		break;
	}
}

void
disasm_fields(u_int32_t addr, const struct opcode *popcode, instr_t instr,
    char *disasm_str, size_t bufsize)
{
	char *pfmt;
	char cbuf[2];
	if (popcode->decode_str == NULL || popcode->decode_str[0] == '0') {
		return;
	}
	pfmt = popcode->decode_str;

	while (*pfmt != '\0')  {
		if (*pfmt == '%') {
			disasm_process_field(addr, instr, &pfmt, disasm_str,
			    bufsize);
		} else {
			cbuf[0] = *pfmt;
			cbuf[1] = '\0';
			strlcat(disasm_str, cbuf, bufsize);
			pfmt++;
		}
	}
}

void
op_base(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes, instr);
}

void
op_cl_x13(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_13, instr);
}

void
op_cl_x1e(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_1e, instr);
}

void
op_cl_x1f(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_1f, instr);
}

void
op_cl_x3a(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_3a, instr);
}

void
op_cl_x3b(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_3b, instr);
}

void
op_cl_x3e(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_3e, instr);
}

void
op_cl_x3f(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_3f, instr);
}

void
dis_ppc(u_int32_t addr, const struct opcode *opcodeset, instr_t instr)
{
	const struct opcode *op;
	int i;
	char disasm_str[80];

	for (i=0; opcodeset[i].mask != 0; i++) {
		op = &opcodeset[i];
		if ((instr & op->mask) == op->code) {
			disasm_fields(addr, op, instr, disasm_str,
			    sizeof disasm_str);
			db_printf("%s%s\n", op->name, disasm_str);
			return;
		}
	}
	op_ill(addr, instr);
}

db_addr_t
db_disasm(db_addr_t loc, boolean_t extended)
{
	int class;
	instr_t opcode;
	opcode = *(instr_t *)(loc);
	class = opcode >> 26;
	(opcodes_base[class])(loc, opcode);

	return loc + 4;
}
@


1.2
log
@Remove "some dead architectures".

These are all but i386 and x86-64 (which is not in the tree yet),
because I have no machines to work with.

Re-adding support should be fairly easy, just cvs adding a partial
OpenBSD checkout and pulling in stuff like kernel signal patch, humantime,
etc. which got added to i386 as well.

You will need gcc support as well.
@
text
@d1 1
a1 2
/*	$NetBSD: db_disasm.c,v 1.8 2001/06/12 05:31:44 simonb Exp $	*/
/*	$OpenBSD: db_disasm.c,v 1.5 2003/02/20 16:48:25 drahn Exp $	*/
d3 1
a3 1
 * Copyright (c) 1996 Dale Rahn. All rights reserved.
a4 1
 *   
a12 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d24 1
a24 1
 */  
d119 1
a119 1
	{ NULL,	 	0 }
d134 3
a136 1
    char *disasm_str);
d139 1
d148 3
a150 3
/*x08*/	op_base,	op_base,	op_base,	op_base,	
/*x0C*/ op_base,	op_base,	op_base/*XXX*/,	op_base/*XXX*/,
/*x10*/ op_base,	op_base,	op_base,	op_cl_x13,
d153 1
a153 1
/*x1C*/ op_base,	op_base,	op_cl_x1e,	op_cl_x1f,
d160 1
a160 1
/*x38*/ op_ill,		op_ill,		op_cl_x3a,	op_cl_x3b,
d167 1
a167 1
 * I would recommend that this table be looked over for errors, 
d187 2
a188 2
	{ "b",		0xfc000000, 0x40000000, "%{BO}%{AA}%{LK} %{BI}%{BD}" },
	{ "b",		0xfc000000, 0x48000000, "%{AA}%{LK} %{LI}" },
d232 1
d395 1
d411 1
d462 6
d472 1
a472 1
	return ((value >> base) & mask);
d489 4
a492 4
	"dnz",
	"dnz",
	"dz",
	"dz",
d497 4
a500 4
	"dnz",
	"dnz",
	"dz",
	"dz",
d523 39
a561 1
void disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt, char **ppoutput);
d563 2
a564 1
disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt, char **ppoutput)
d567 1
a569 1
	char *pstr;
d576 1
a576 1
		printf("error in disasm fmt [%s]\n",pfmt);
d579 3
a581 1
	for (i = 0; pfmt[i] != '\0' && pfmt[i] != '}';  i++) {
d584 4
d590 1
a600 1
	pstr = *ppoutput;
d604 1
a604 1
			printf("unable to find variable [%s]\n",field);
d609 3
a611 2
			A = extract_field(instr, 31 - 15, 5);
			pstr += sprintf (pstr, "r%d", A);
d617 1
a617 1
			A = extract_field(instr, 31 - 15, 5);
d619 2
a620 1
				pstr += sprintf (pstr, "r%d,", A);
d626 1
a626 1
			pstr += sprintf (pstr,"a");
d632 1
a632 1
			LI = extract_field(instr, 31 - 29, 24);
d644 3
a646 2
				pstr += sprintf (pstr, "0x%x (%s)", LI,
					name);
d648 4
a651 2
				pstr += sprintf (pstr, "0x%x (%s+0x%x)", LI,
					name, offset);
d654 2
a655 1
				pstr += sprintf (pstr, "0x%x", LI);
d662 3
a664 2
			B = extract_field(instr, 31 - 20, 5);
			pstr += sprintf (pstr, "r%d", B);
d670 1
a670 1
			BD = extract_field(instr, 31 - 29, 14);
d682 3
a684 2
				pstr += sprintf (pstr, "0x%x (%s)", BD,
					name);
d686 3
a688 2
				pstr += sprintf (pstr, "0x%x (%s+0x%x)", BD,
					name, offset);
d691 2
a692 1
				pstr += sprintf (pstr, "0x%x", BD);
d696 1
d699 8
a706 4
			u_int BI;
			BI = extract_field(instr, 31 - 10, 5);
			if (BI != 0) {
			pstr += sprintf (pstr, "%d,", BI);
d708 9
a716 8
		}
		break;
	case Opf_BI1:
		{
			u_int BI;
			BI = extract_field(instr, 31 - 10, 5);
			if (BI != 0) {
			pstr += sprintf (pstr, "%d", BI);
d718 2
d724 8
a731 7
			int BO,BI;
			BO = extract_field(instr, 31 - 10, 5);
			pstr += sprintf (pstr ,"%s", db_BO_op[BO]);
			if (BO < 8) {
				BI = extract_field(instr, 31 - 10, 5);
				pstr += sprintf (pstr ,"%s",
				    db_BOBI_cond[(BI & 0x3)|((BO & 1) << 2)]);
d733 2
d741 3
a743 2
			C = extract_field(instr, 31 - 25, 5);
			pstr += sprintf (pstr, "r%d, ", C);
d749 3
a751 2
			CRM = extract_field(instr, 31 - 19, 8);
			pstr += sprintf (pstr, "0x%x", CRM);
d757 3
a759 2
			FM = extract_field(instr, 31 - 10, 8);
			pstr += sprintf (pstr, "%d", FM);
d764 1
a764 1
			pstr += sprintf (pstr,"l");
d770 3
a772 2
			MB = extract_field(instr, 31 - 20, 5);
			pstr += sprintf (pstr, "%d", MB);
d778 3
a780 2
			ME = extract_field(instr, 31 - 25, 5);
			pstr += sprintf (pstr, "%d", ME);
d786 1
a786 1
			NB = extract_field(instr, 31 - 20, 5);
d790 2
a791 1
			pstr += sprintf (pstr, "%d", NB);
d796 1
a796 1
			*pstr++ = 'o';
d801 1
a801 1
			*pstr++  = '.';
d809 3
a811 2
			D = extract_field(instr, 31 - 10, 5);
			pstr += sprintf (pstr, "r%d", D);
d817 3
a819 2
			SH = extract_field(instr, 31 - 20, 5);
			pstr += sprintf (pstr, "%d", SH);
d826 2
a827 2
			IMM = extract_field(instr, 31 - 31, 16);
			if (IMM & 0x8000) {
d829 2
a830 2
			}
			pstr += sprintf (pstr, "%d", IMM);
d836 3
a838 2
			IMM = extract_field(instr, 31 - 31, 16);
			pstr += sprintf (pstr, "0x%x", IMM);
d844 3
a846 2
			SR = extract_field(instr, 31 - 15, 3);
			pstr += sprintf (pstr, "sr%d", SR);
d852 3
a854 2
			TO = extract_field(instr, 31 - 10, 1);
			pstr += sprintf (pstr, "%d", TO);
d860 3
a862 2
			crbA = extract_field(instr, 31 - 15, 5);
			pstr += sprintf (pstr, "%d", crbA);
d868 3
a870 2
			crbB = extract_field(instr, 31 - 20, 5);
			pstr += sprintf (pstr, "%d", crbB);
d876 3
a878 2
			crfD = extract_field(instr, 31 - 8, 3);
			pstr += sprintf (pstr, "crf%d", crfD);
d884 3
a886 2
			crfD = extract_field(instr, 31 - 8, 3);
			pstr += sprintf (pstr, "crf%d", crfD);
d892 3
a894 2
			crfS = extract_field(instr, 31 - 13, 3);
			pstr += sprintf (pstr, "%d", crfS);
d901 2
a902 2
			mbl = extract_field(instr, 31 - 25, 4);
			mbh = extract_field(instr, 31 - 26, 1);
d904 2
a905 1
			pstr += sprintf (pstr, ", %d", mb);
d911 2
a912 2
			shl = extract_field(instr, 31 - 19, 4);
			shh = extract_field(instr, 31 - 20, 1);
d914 2
a915 1
			pstr += sprintf (pstr, ", %d", sh);
d924 2
a925 2
			sprl = extract_field(instr, 31 - 15, 5);
			sprh = extract_field(instr, 31 - 20, 5);
d930 1
a930 1
			case 	1:
d933 1
a933 1
			case 	8:
d936 1
a936 1
			case 	9:
d939 1
a939 1
			case 	18:
d942 1
a942 1
			case 	19:
d945 1
a945 1
			case 	22:
d948 1
a948 1
			case 	25:
d951 1
a951 1
			case 	26:
d954 1
a954 1
			case 	27:
d957 1
a957 1
			case 	272:
d960 1
a960 1
			case 	273:
d963 1
a963 1
			case 	274:
d966 1
a966 1
			case 	275:
d969 1
a969 1
			case 	280:
d972 1
a972 1
			case 	282:
d975 1
a975 1
			case 	287:
d978 1
a978 1
			case 	528:
d981 1
a981 1
			case 	529:
d984 1
a984 1
			case 	530:
d987 1
a987 1
			case 	531:
d990 1
a990 1
			case 	532:
d993 1
a993 1
			case 	533:
d996 1
a996 1
			case 	534:
d999 1
a999 1
			case 	535:
d1002 1
a1002 1
			case 	536:
d1005 1
a1005 1
			case 	537:
d1008 1
a1008 1
			case 	538:
d1011 1
a1011 1
			case 	539:
d1014 1
a1014 1
			case 	540:
d1017 1
a1017 1
			case 	541:
d1020 1
a1020 1
			case 	542:
d1023 1
a1023 1
			case 	543:
d1026 1
a1026 1
			case 	1013:
d1033 2
a1034 1
				pstr += sprintf (pstr, "spr%d", spr);
d1036 2
a1037 1
				pstr += sprintf (pstr, "%s", reg);
d1046 3
a1048 3
			char *reg;
			tbrl = extract_field(instr, 31 - 15, 5);
			tbrh = extract_field(instr, 31 - 20, 5);
d1061 3
a1063 2
			if (reg == 0) {
				pstr += sprintf (pstr, "tbr%d", tbr);
d1065 2
a1066 1
				pstr += sprintf (pstr, "%s", reg);
a1070 2
	*ppoutput = pstr;

d1074 2
a1075 1
disasm_fields(u_int32_t addr, const struct opcode *popcode, instr_t instr, char *disasm_str)
d1078 1
a1078 2
	char *poutput;
	disasm_str[0] = '\0';
a1082 1
	poutput = disasm_str;
d1086 2
a1087 1
			disasm_process_field(addr, instr, &pfmt, &poutput);
d1089 3
a1091 2
			*poutput = *pfmt;
			poutput++;
a1094 1
	*poutput = '\0';
d1100 1
a1100 1
	dis_ppc (addr, opcodes,instr);
d1106 1
a1106 1
	dis_ppc (addr, opcodes_13,instr);
d1112 1
a1112 1
	dis_ppc (addr, opcodes_1e,instr);
d1118 1
a1118 1
	dis_ppc (addr, opcodes_1f,instr);
d1124 1
a1124 1
	dis_ppc (addr, opcodes_3a,instr);
d1130 1
a1130 1
	dis_ppc (addr, opcodes_3b,instr);
d1136 1
a1136 1
	dis_ppc (addr, opcodes_3e,instr);
d1142 1
a1142 1
	dis_ppc (addr, opcodes_3f,instr);
a1148 1
	int found = 0;
d1150 1
a1150 1
	char disasm_str[30];
d1152 2
a1153 3
	for (i=0, op = &opcodeset[0];
	    found == 0 && op->mask != 0;
	    i++, op= &opcodeset[i] ) {
d1155 3
a1157 3
			found = 1;
			disasm_fields(addr, op, instr, disasm_str);
			db_printf("%s%s",op->name, disasm_str);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD repository of CTM 3155 (roughly today at noon).
Mostly in order to go 3.3-current and ease further merges of
both OpenBSD and ELFdiffs after the MirBSD has been enabled
to build again.
@
text
@d2 1
a2 1
/*	$OpenBSD: db_disasm.c,v 1.6 2003/03/27 17:40:19 drahn Exp $	*/
d484 4
a487 4
	"dnzf",
	"dnzf-",
	"dzf",
	"dzf-",
d492 4
a495 4
	"dnzt",
	"dnzt-",
	"dzt",
	"dzt-",
a517 40
char *BItbl[] = {
	"", "gt", "eq", "so"
};

char BO_uses_tbl[32] = {
	/* 0 */ 1,
	/* 1 */ 1,
	/* 2 */ 1,
	/* 3 */ 1,
	/* 4 */ 0,
	/* 5 */ 0,
	/* 6 */ 0, /* invalid */
	/* 7 */ 0, /* invalid */
	/* 8 */ 1,
	/* 9 */ 1,
	/* a */ 1,
	/* b */ 1,
	/* c */ 0,
	/* d */ 0,
	/* e */ 0, /* invalid */
	/* f */ 1,
	/* 10 */        1,
	/* 11 */        1,
	/* 12 */        1,
	/* 13 */        1,
	/* 14 */        1,
	/* 15 */        0, /* invalid */
	/* 16 */        0, /* invalid */
	/* 17 */        0, /* invalid */
	/* 18 */        0, /* invalid */
	/* 19 */        0, /* invalid */
	/* 1a */        0, /* invalid */
	/* 1b */        0, /* invalid */
	/* 1c */        0, /* invalid */
	/* 1d */        0, /* invalid */
	/* 1e */        0, /* invalid */
	/* 1f */        0, /* invalid */
};


a635 1
	case Opf_BI1:
d638 4
a641 7
			int BO, BI, cr, printcomma = 0;
			BO = extract_field(instr, 31 - 10, 5);
			BI = extract_field(instr, 31 - 15, 5);
			cr =  (BI >> 2) & 7;
			if (cr != 0) {
				pstr += sprintf (pstr, "cr%d", cr);
				printcomma = 1;
d643 8
a650 6
			if (BO_uses_tbl[BO]) {
				if ((cr != 0) && ((BI & 3) != 0))
					if (BO_uses_tbl[BO])
						pstr += sprintf (pstr, "+");
				pstr += sprintf (pstr, "%s", BItbl[BI & 3]);
				printcomma = 1;
a651 2
			if ((opf == Opf_BI) && printcomma)
				pstr += sprintf (pstr, ",");
d659 2
a660 2
			if ((BO & 4) != 0) {
				BI = extract_field(instr, 31 - 15, 5);
d662 1
a662 2
				    db_BOBI_cond[(BI & 0x3)|
				    (((BO & 8) >> 1))] );
a663 2
				if (BO & 1)
					pstr += sprintf (pstr ,"-");
@


1.1.1.3
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 2
a2 1
/*	$OpenBSD: db_disasm.c,v 1.12 2003/05/09 21:36:05 drahn Exp $	*/
d4 1
a4 1
 * Copyright (c) 1996, 2001, 2003 Dale Rahn. All rights reserved.
d6 1
d15 5
d31 1
a31 1
 */
d126 1
a126 1
	{ NULL,		0 }
d141 1
a141 3
    char *disasm_str, size_t bufsize);
void disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt,
    char *ppoutput, size_t bufsize);
a143 1

d152 3
a154 3
/*x08*/	op_base,	op_base,	op_base,	op_base,
/*x0C*/	op_base,	op_base,	op_base/*XXX*/,	op_base/*XXX*/,
/*x10*/	op_base,	op_base,	op_base,	op_cl_x13,
d157 1
a157 1
/*x1C*/	op_base,	op_base,	op_cl_x1e,	op_cl_x1f,
d164 1
a164 1
/*x38*/	op_ill,		op_ill,		op_cl_x3a,	op_cl_x3b,
d171 1
a171 1
 * I would recommend that this table be looked over for errors,
d191 2
a192 2
	{ "b",		0xfc000000, 0x40000000, "%{BO}%{LK}%{AA} %{BI}%{BD}" },
	{ "b",		0xfc000000, 0x48000000, "%{LK}%{AA} %{LI}" },
a462 6
/*
 * Extracts bits out of an instruction opcode, base indicates the lsb
 * to keep.
 * Note that this uses the PowerPC bit number for base, MSb == 0
 * because all of the documentation is written that way.
 */
d467 1
a467 1
	return ((value >> (31 - base)) & mask);
d557 2
d560 1
a560 2
disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt,
    char *disasm_buf, size_t bufsize)
a562 1
	char lbuf[50];
d565 1
d572 1
a572 1
		printf("error in disasm fmt [%s]\n", pfmt);
d575 1
a575 3
	for (i = 0;
	    pfmt[i] != '\0' && pfmt[i] != '}' && i < sizeof(field);
	    i++) {
a577 4
	if (i == sizeof(field)) {
		printf("error in disasm fmt [%s]\n", pfmt);
		return;
	}
a579 1
		/* match following close paren { */
d590 1
d594 1
a594 1
			printf("unable to find variable [%s]\n", field);
d599 2
a600 3
			A = extract_field(instr, 15, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", A);
			strlcat (disasm_buf, lbuf, bufsize);
d606 1
a606 1
			A = extract_field(instr, 15, 5);
d608 1
a608 2
				snprintf(lbuf, sizeof (lbuf), "r%d,", A);
				strlcat (disasm_buf, lbuf, bufsize);
d614 1
a614 1
			strlcat (disasm_buf, "a", bufsize);
d620 1
a620 1
			LI = extract_field(instr, 29, 24);
d632 2
a633 3
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s)", LI, name);
					strlcat (disasm_buf, lbuf, bufsize);
d635 2
a636 4
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s+0x%x)", LI, name,
					    offset);
					strlcat (disasm_buf, lbuf, bufsize);
d639 1
a639 2
				snprintf(lbuf, sizeof (lbuf), "0x%x", LI);
				strlcat (disasm_buf, lbuf, bufsize);
d646 2
a647 3
			B = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", B);
			strlcat (disasm_buf, lbuf, bufsize);
d653 1
a653 1
			BD = extract_field(instr, 29, 14);
d665 2
a666 3
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s)", BD, name);
					strlcat (disasm_buf, lbuf, bufsize);
d668 2
a669 3
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s+0x%x)", BD, name, offset);
					strlcat (disasm_buf, lbuf, bufsize);
d672 1
a672 2
				snprintf(lbuf, sizeof (lbuf), "0x%x", BD);
				strlcat (disasm_buf, lbuf, bufsize);
d680 2
a681 2
			BO = extract_field(instr, 10, 5);
			BI = extract_field(instr, 15, 5);
d684 1
a684 2
				snprintf(lbuf, sizeof (lbuf), "cr%d", cr);
				strlcat (disasm_buf, lbuf, bufsize);
d688 4
a691 7
				if ((cr != 0) && ((BI & 3) != 0) &&
				    BO_uses_tbl[BO] != 0)
					strlcat (disasm_buf, "+", bufsize);

				snprintf(lbuf, sizeof (lbuf), "%s",
				    BItbl[BI & 3]);
				strlcat (disasm_buf, lbuf, bufsize);
d695 1
a695 1
				strlcat (disasm_buf, ",", bufsize);
d700 3
a702 3
			int BO, BI;
			BO = extract_field(instr, 10, 5);
			strlcat (disasm_buf, db_BO_op[BO], bufsize);
d704 4
a707 4
				BI = extract_field(instr, 15, 5);
				strlcat (disasm_buf,
				    db_BOBI_cond[(BI & 0x3)| (((BO & 8) >> 1))],
				    bufsize);
d710 1
a710 1
					strlcat (disasm_buf, "-", bufsize);
d717 2
a718 3
			C = extract_field(instr, 25, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d, ", C);
			strlcat (disasm_buf, lbuf, bufsize);
d724 2
a725 3
			CRM = extract_field(instr, 19, 8);
			snprintf(lbuf, sizeof (lbuf), "0x%x", CRM);
			strlcat (disasm_buf, lbuf, bufsize);
d731 2
a732 3
			FM = extract_field(instr, 10, 8);
			snprintf(lbuf, sizeof (lbuf), "%d", FM);
			strlcat (disasm_buf, lbuf, bufsize);
d737 1
a737 1
			strlcat (disasm_buf, "l", bufsize);
d743 2
a744 3
			MB = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", MB);
			strlcat (disasm_buf, lbuf, bufsize);
d750 2
a751 3
			ME = extract_field(instr, 25, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", ME);
			strlcat (disasm_buf, lbuf, bufsize);
d757 1
a757 1
			NB = extract_field(instr, 20, 5);
d761 1
a761 2
			snprintf(lbuf, sizeof (lbuf), "%d", NB);
			strlcat (disasm_buf, lbuf, bufsize);
d766 1
a766 1
			strlcat (disasm_buf, "o", bufsize);
d771 1
a771 1
			strlcat (disasm_buf, ".", bufsize);
d779 2
a780 3
			D = extract_field(instr, 10, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", D);
			strlcat (disasm_buf, lbuf, bufsize);
d786 2
a787 3
			SH = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", SH);
			strlcat (disasm_buf, lbuf, bufsize);
d794 2
a795 2
			IMM = extract_field(instr, 31, 16);
			if (IMM & 0x8000)
d797 2
a798 2
			snprintf(lbuf, sizeof (lbuf), "%d", IMM);
			strlcat (disasm_buf, lbuf, bufsize);
d804 2
a805 3
			IMM = extract_field(instr, 31, 16);
			snprintf(lbuf, sizeof (lbuf), "0x%x", IMM);
			strlcat (disasm_buf, lbuf, bufsize);
d811 2
a812 3
			SR = extract_field(instr, 15, 3);
			snprintf(lbuf, sizeof (lbuf), "sr%d", SR);
			strlcat (disasm_buf, lbuf, bufsize);
d818 2
a819 3
			TO = extract_field(instr, 10, 1);
			snprintf(lbuf, sizeof (lbuf), "%d", TO);
			strlcat (disasm_buf, lbuf, bufsize);
d825 2
a826 3
			crbA = extract_field(instr, 15, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", crbA);
			strlcat (disasm_buf, lbuf, bufsize);
d832 2
a833 3
			crbB = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", crbB);
			strlcat (disasm_buf, lbuf, bufsize);
d839 2
a840 3
			crfD = extract_field(instr, 8, 3);
			snprintf(lbuf, sizeof (lbuf), "crf%d", crfD);
			strlcat (disasm_buf, lbuf, bufsize);
d846 2
a847 3
			crfD = extract_field(instr, 8, 3);
			snprintf(lbuf, sizeof (lbuf), "crf%d", crfD);
			strlcat (disasm_buf, lbuf, bufsize);
d853 2
a854 3
			crfS = extract_field(instr, 13, 3);
			snprintf(lbuf, sizeof (lbuf), "%d", crfS);
			strlcat (disasm_buf, lbuf, bufsize);
d861 2
a862 2
			mbl = extract_field(instr, 25, 4);
			mbh = extract_field(instr, 26, 1);
d864 1
a864 2
			snprintf(lbuf, sizeof (lbuf), ", %d", mb);
			strlcat (disasm_buf, lbuf, bufsize);
d870 2
a871 2
			shl = extract_field(instr, 19, 4);
			shh = extract_field(instr, 20, 1);
d873 1
a873 2
			snprintf(lbuf, sizeof (lbuf), ", %d", sh);
			strlcat (disasm_buf, lbuf, bufsize);
d882 2
a883 2
			sprl = extract_field(instr, 15, 5);
			sprh = extract_field(instr, 20, 5);
d888 1
a888 1
			case	1:
d891 1
a891 1
			case	8:
d894 1
a894 1
			case	9:
d897 1
a897 1
			case	18:
d900 1
a900 1
			case	19:
d903 1
a903 1
			case	22:
d906 1
a906 1
			case	25:
d909 1
a909 1
			case	26:
d912 1
a912 1
			case	27:
d915 1
a915 1
			case	272:
d918 1
a918 1
			case	273:
d921 1
a921 1
			case	274:
d924 1
a924 1
			case	275:
d927 1
a927 1
			case	280:
d930 1
a930 1
			case	282:
d933 1
a933 1
			case	287:
d936 1
a936 1
			case	528:
d939 1
a939 1
			case	529:
d942 1
a942 1
			case	530:
d945 1
a945 1
			case	531:
d948 1
a948 1
			case	532:
d951 1
a951 1
			case	533:
d954 1
a954 1
			case	534:
d957 1
a957 1
			case	535:
d960 1
a960 1
			case	536:
d963 1
a963 1
			case	537:
d966 1
a966 1
			case	538:
d969 1
a969 1
			case	539:
d972 1
a972 1
			case	540:
d975 1
a975 1
			case	541:
d978 1
a978 1
			case	542:
d981 1
a981 1
			case	543:
d984 1
a984 1
			case	1013:
d991 1
a991 2
				snprintf(lbuf, sizeof (lbuf), "spr%d", spr);
				strlcat (disasm_buf, lbuf, bufsize);
d993 1
a993 2
				snprintf(lbuf, sizeof (lbuf), "%s", reg);
				strlcat (disasm_buf, lbuf, bufsize);
d1002 3
a1004 3
			char *reg = NULL;
			tbrl = extract_field(instr, 15, 5);
			tbrh = extract_field(instr, 20, 5);
d1017 2
a1018 3
			if (reg == NULL) {
				snprintf(lbuf, sizeof (lbuf), "tbr%d", tbr);
				strlcat (disasm_buf, lbuf, bufsize);
d1020 1
a1020 2
				snprintf(lbuf, sizeof (lbuf), "%s", reg);
				strlcat (disasm_buf, lbuf, bufsize);
d1025 2
d1030 1
a1030 2
disasm_fields(u_int32_t addr, const struct opcode *popcode, instr_t instr,
    char *disasm_str, size_t bufsize)
d1033 2
a1034 1
	char cbuf[2];
d1039 1
d1043 1
a1043 2
			disasm_process_field(addr, instr, &pfmt, disasm_str,
			    bufsize);
d1045 2
a1046 3
			cbuf[0] = *pfmt;
			cbuf[1] = '\0';
			strlcat(disasm_str, cbuf, bufsize);
d1050 1
d1056 1
a1056 1
	dis_ppc(addr, opcodes, instr);
d1062 1
a1062 1
	dis_ppc(addr, opcodes_13, instr);
d1068 1
a1068 1
	dis_ppc(addr, opcodes_1e, instr);
d1074 1
a1074 1
	dis_ppc(addr, opcodes_1f, instr);
d1080 1
a1080 1
	dis_ppc(addr, opcodes_3a, instr);
d1086 1
a1086 1
	dis_ppc(addr, opcodes_3b, instr);
d1092 1
a1092 1
	dis_ppc(addr, opcodes_3e, instr);
d1098 1
a1098 1
	dis_ppc(addr, opcodes_3f, instr);
d1105 1
d1107 1
a1107 1
	char disasm_str[80];
d1109 3
a1111 2
	for (i=0; opcodeset[i].mask != 0; i++) {
		op = &opcodeset[i];
d1113 3
a1115 3
			disasm_fields(addr, op, instr, disasm_str,
			    sizeof disasm_str);
			db_printf("%s%s\n", op->name, disasm_str);
@


1.1.1.4
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.14 2003/12/21 15:17:29 miod Exp $	*/
a231 1

a393 1

a408 1

d646 1
a646 1
					    "0x%x (%s+0x%lx)", LI, name,
d684 1
a684 1
					    "0x%x (%s+0x%lx)", BD, name, offset);
@


