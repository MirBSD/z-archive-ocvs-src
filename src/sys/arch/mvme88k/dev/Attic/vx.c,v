head	1.2;
access;
symbols
	cvs-200405160640:1.1.1.6
	cvs-200401271800:1.1.1.5
	cvs-200401261630:1.1.1.5
	cvs-200401021645:1.1.1.5
	cvs-200312222040:1.1.1.4
	cvs-200310020700:1.1.1.3
	cvs-200309271030:1.1.1.3
	cvs-200309261655:1.1.1.3
	cvs-200309251530:1.1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	cvs-200307072125:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200307021520:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.04.06.04.29.29;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.50.01;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.50.01;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.06.05.17.35.37;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.17.14.31.17;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.22.20.59.55;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.01.02.17.49.41;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.16.08.38.38;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove "some dead architectures".

These are all but i386 and x86-64 (which is not in the tree yet),
because I have no machines to work with.

Re-adding support should be fairly easy, just cvs adding a partial
OpenBSD checkout and pulling in stuff like kernel signal patch, humantime,
etc. which got added to i386 as well.

You will need gcc support as well.
@
text
@/*	$OpenBSD: vx.c,v 1.20 2002/04/28 15:17:09 miod Exp $ */
/*
 * Copyright (c) 1999 Steve Murphree, Jr. 
 * All rights reserved.
 *
 *   
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */  

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/uio.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/device.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/psl.h>

#include <dev/cons.h>

#include <mvme88k/dev/vme.h>
#include <mvme88k/dev/vxreg.h>

#include "pcctwo.h"
#if NPCCTWO > 0
#include <mvme88k/dev/pcctworeg.h>
#endif

#ifdef	DDB
#include <ddb/db_var.h>
#endif

#define splvx()	spltty()

#ifdef DEBUG
#undef DEBUG
#endif

struct vx_info {
	struct   tty *tty;
	u_char   vx_swflags;
	int      vx_linestatus;
	int      open;
	int      waiting;
	u_char   vx_consio;
	u_char   vx_speed;
	u_char   read_pending;
	struct   wring  *wringp;
	struct   rring  *rringp;
};

struct vxsoftc {
	struct device     sc_dev;
	struct evcnt      sc_intrcnt;
	struct evcnt      sc_sintrcnt;
	struct vx_info  sc_info[9];
	struct vxreg    *vx_reg;
	unsigned int      board_addr;
	struct channel    *channel;
	char              channel_number;
	struct packet     sc_bppwait_pkt;
	void              *sc_bppwait_pktp;
	struct intrhand   sc_ih_c;
	struct intrhand   sc_ih_s;
#if defined(MVME187) || defined(MVME197)
	struct vme2reg    *sc_vme2;
#endif
	int               sc_ipl;
	int               sc_vec;
	int               sc_flags;
	struct envelope   *elist_head, *elist_tail;
	struct packet     *plist_head, *plist_tail;
};

/* prototypes */

void *get_next_envelope(struct envelope *thisenv);
struct envelope *get_status_head(struct vxsoftc *sc);
void set_status_head(struct vxsoftc *sc, void *envp);
struct packet *get_packet(struct vxsoftc *sc, struct envelope *thisenv);
struct envelope *find_status_packet(struct vxsoftc *sc, struct packet * pktp);

void read_wakeup(struct vxsoftc *sc, int port);
int  bpp_send(struct vxsoftc *sc, void *pkt, int wait_flag);

int  create_channels(struct vxsoftc *sc);
int  env_isvalid(struct envelope *thisenv);
void memcpy2(void *dest, const void *src, size_t size);
void *get_free_envelope(struct vxsoftc *sc);
void put_free_envelope(struct vxsoftc *sc, void *envp);
void *get_free_packet(struct vxsoftc *sc);
void put_free_packet(struct vxsoftc *sc, void *pktp);

int  vx_init(struct vxsoftc *sc);
int  vx_event(struct vxsoftc *sc, struct packet *evntp);

void vx_unblock(struct tty *tp);
int  vx_ccparam(struct vxsoftc *sc, struct termios *par, int port);

int  vx_param(struct tty *tp, struct termios *t);
int  vx_intr(void * arg);
int  vx_sintr(struct vxsoftc *sc);
int  vx_poll(struct vxsoftc *sc, struct packet *wpktp);
void vx_overflow(struct vxsoftc *sc, int port, long *ptime, u_char *msg);
void vx_frame(struct vxsoftc *sc, int port);
void vx_break( struct vxsoftc *sc, int port);
int  vx_mctl(dev_t dev, int bits, int how);

int  vxmatch(struct device *parent, void *self, void *aux);
void vxattach(struct device *parent, struct device *self, void *aux);

void vxstart(struct tty *tp);

void   vxputc(struct vxsoftc *sc, int port, u_char c);

struct tty * vxtty(dev_t);
short dtr_ctl(struct vxsoftc *, int, int);
short rts_ctl(struct vxsoftc *, int, int);
short flush_ctl(struct vxsoftc *, int, int);
u_short vxtspeed(int);
void read_chars(struct vxsoftc *, int);
void ccode(struct vxsoftc *, int, char);
void wzero(void *, size_t);
int create_free_queue(struct vxsoftc *);
void print_dump(struct vxsoftc *);
struct envelope *get_cmd_tail(struct vxsoftc *);

struct cfattach vx_ca = {       
	sizeof(struct vxsoftc), vxmatch, vxattach
};      

struct cfdriver vx_cd = {
	NULL, "vx", DV_TTY, 0
}; 
      
#define VX_UNIT(x) (int)(minor(x) / 9)
#define VX_PORT(x) (int)(minor(x) % 9)

struct envelope *bpp_wait;
unsigned int board_addr;

struct tty * vxtty(dev)
	dev_t dev;
{
	int unit, port;
	struct vxsoftc *sc;
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (NULL);
	}
	port = VX_PORT(dev);
	return sc->sc_info[port].tty;
}

int   
vxmatch(parent, self, aux)
	struct device *parent;
	void *self;
	void *aux;
{
	struct vxreg *vx_reg;
	struct confargs *ca = aux;
   
#ifdef OLD_MAPPINGS
	ca->ca_vaddr = ca->ca_paddr;
#endif
	ca->ca_len = 0x10000; /* we know this. */
	ca->ca_ipl = 3;	/* we need interrupts for this board to work */

	vx_reg = (struct vxreg *)ca->ca_vaddr;
	board_addr = (unsigned int)ca->ca_vaddr;
	if (badvaddr((unsigned)&vx_reg->ipc_cr, 1))
			return (0);
		return (1);
}

void
vxattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct vxsoftc *sc = (struct vxsoftc *)self;
	struct confargs *ca = aux;
	
	/* set up dual port memory and registers and init*/
	sc->vx_reg = (struct vxreg *)ca->ca_vaddr;
	sc->channel = (struct channel *)(ca->ca_vaddr + 0x0100);
#if defined(MVME187) || defined(MVME197)
	sc->sc_vme2 = ca->ca_master;
#endif 
	sc->sc_ipl = ca->ca_ipl; 
	sc->sc_vec = ca->ca_vec; 
	sc->board_addr = (unsigned int)ca->ca_vaddr;

	printf("\n");

	if (create_channels(sc)) {
		printf("%s: failed to create channel %d\n", sc->sc_dev.dv_xname, 
		       sc->channel->channel_number);
		return;
	}
	if (vx_init(sc)) {
		printf("%s: failed to initialize\n", sc->sc_dev.dv_xname);
		return;
	}

	/* enable interrupts */
	sc->sc_ih_c.ih_fn = vx_intr;
	sc->sc_ih_c.ih_arg = sc;
	sc->sc_ih_c.ih_wantframe = 0;
	sc->sc_ih_c.ih_ipl = ca->ca_ipl;

	vmeintr_establish(ca->ca_vec, &sc->sc_ih_c);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
}

int vxtdefaultrate = TTYDEF_SPEED;

short
dtr_ctl(sc, port, on)
	struct vxsoftc *sc;
	int port;
	int on;
{
	struct packet pkt;
	bzero(&pkt, sizeof(struct packet));
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCXONC;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	if (on) {
		pkt.ioctl_arg_l = 6;  /* assert DTR */
	} else {
		pkt.ioctl_arg_l = 7;  /* negate DTR */
	}
	bpp_send(sc, &pkt, NOWAIT);
	return (pkt.error_l);
}

short
rts_ctl(sc, port, on)
	struct vxsoftc *sc;
	int port;
	int on;
{
	struct packet pkt;
	bzero(&pkt, sizeof(struct packet));
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCXONC;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	if (on) {
		pkt.ioctl_arg_l = 4;  /* assert RTS */
	} else {
		pkt.ioctl_arg_l = 5;  /* negate RTS */
	}
	bpp_send(sc, &pkt, NOWAIT);
	return (pkt.error_l);
}

short
flush_ctl(sc, port, which)
	struct vxsoftc *sc;
	int port;
	int which;
{
	struct packet pkt;
	bzero(&pkt, sizeof(struct packet));
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCFLSH;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	pkt.ioctl_arg_l = which; /* 0=input, 1=output, 2=both */
	bpp_send(sc, &pkt, NOWAIT);
	return (pkt.error_l);
}

int vx_mctl (dev, bits, how)
	dev_t dev;
	int bits;
	int how;
{
	int s, unit, port;
	struct vxsoftc *sc;
	struct vx_info *vxt;
	u_char msvr;

	unit = VX_UNIT(dev);
	port = VX_PORT(dev);
	sc = (struct vxsoftc *) vx_cd.cd_devs[unit];
	vxt = &sc->sc_info[port];

	s = splvx();
	switch (how) {
	case DMSET:
		if( bits & TIOCM_RTS) {
			rts_ctl(sc, port, 1);
			vxt->vx_linestatus |= TIOCM_RTS;
		} else {
			rts_ctl(sc, port, 0);

			vxt->vx_linestatus &= ~TIOCM_RTS;
		}
		if ( bits & TIOCM_DTR) {
			dtr_ctl(sc, port, 1);
			vxt->vx_linestatus |= TIOCM_DTR;
		} else {
			dtr_ctl(sc, port, 0);
			vxt->vx_linestatus &= ~TIOCM_DTR;
		}
		break;
	case DMBIC:
		if ( bits & TIOCM_RTS) {
			rts_ctl(sc, port, 0);
			vxt->vx_linestatus &= ~TIOCM_RTS;
		}
		if ( bits & TIOCM_DTR) {
			dtr_ctl(sc, port, 0);
			vxt->vx_linestatus &= ~TIOCM_DTR;
		}
		break;

	case DMBIS:
		if ( bits & TIOCM_RTS) {
			rts_ctl(sc, port, 1);
			vxt->vx_linestatus |= TIOCM_RTS;
		}
		if ( bits & TIOCM_DTR) {
			dtr_ctl(sc, port, 1);
			vxt->vx_linestatus |= TIOCM_DTR;
		}
		break;

	case DMGET:
		bits = 0;
		msvr = vxt->vx_linestatus;
		if ( msvr & TIOCM_DSR) {
			bits |= TIOCM_DSR;
		}
		if ( msvr & TIOCM_CD) {
			bits |= TIOCM_CD;
		}
		if ( msvr & TIOCM_CTS) {
			bits |= TIOCM_CTS;
		}
		if ( msvr & TIOCM_DTR) {
			bits |= TIOCM_DTR;
		}
		if ( msvr & TIOCM_RTS) {
			bits |= TIOCM_RTS;
		}
		break;
	}

	splx(s);
	bits = 0;
	bits |= TIOCM_DTR;
	bits |= TIOCM_RTS;
	bits |= TIOCM_CTS;
	bits |= TIOCM_CD;
	bits |= TIOCM_DSR;
	return (bits);
}

int vxopen (dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int s, unit, port;
	struct vx_info *vxt;
	struct vxsoftc *sc;
	struct tty *tp;
	struct open_packet opkt;
	u_short code;

	unit = VX_UNIT(dev);
	port = VX_PORT(dev);

	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}

	/*flush_ctl(sc, port, 2);*/

	bzero(&opkt, sizeof(struct packet));
	opkt.eye_catcher[0] = 0x33;
	opkt.eye_catcher[1] = 0x33;
	opkt.eye_catcher[2] = 0x33;
	opkt.eye_catcher[3] = 0x33;
	opkt.command_pipe_number = sc->channel_number;
	opkt.status_pipe_number = sc->channel_number;
	opkt.command = CMD_OPEN;
	opkt.device_number = port;

	bpp_send(sc, &opkt, WAIT_POLL);

	if (opkt.error_l) {
#ifdef DEBUG_VXT
		printf("unit %d, port %d, ", unit, port);
		printf("error = %d\n", opkt.error_l);
#endif 
		return (ENODEV);
	}

	code = opkt.event_code;
	s = splvx();

	vxt = &sc->sc_info[port];
	if (vxt->tty) {
		tp = vxt->tty;
	} else {
		tp = vxt->tty = ttymalloc();  
	}

	/* set line status */
	tp->t_state |= TS_CARR_ON;
	if (code & E_DCD) {
		tp->t_state |= TS_CARR_ON;
		vxt->vx_linestatus |= TIOCM_CD;
	}
	if (code & E_DSR) {
		vxt->vx_linestatus |= TIOCM_DSR;
	}
	if (code & E_CTS) {
		vxt->vx_linestatus |= TIOCM_CTS;
	}

	tp->t_oproc = vxstart;
	tp->t_param = vx_param;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			/*
			 * only when cleared do we reset to defaults.
			 */
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = vxtdefaultrate;
			tp->t_cflag = TTYDEF_CFLAG;
		}
		/*
		 * do these all the time
		 */
		if (vxt->vx_swflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (vxt->vx_swflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (vxt->vx_swflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;
		vx_param(tp, &tp->t_termios);
		ttsetwater(tp);

		(void)vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);

		tp->t_state |= TS_CARR_ON;
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
		splx(s);
		return (EBUSY);
	}

	/*
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
	 */
	tp->t_dev = dev;
	sc->sc_info[port].open = 1;
	read_wakeup(sc, port);
	splx(s);
	return ((*linesw[tp->t_line].l_open)(dev, tp));
}

int 
vx_param(tp, t)
	struct tty *tp;
	struct termios *t;
{
	int unit, port;
	struct vxsoftc *sc;
	dev_t dev;

	dev = tp->t_dev;
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	vx_ccparam(sc, t, port);
	vx_unblock(tp);
	return 0;
}

int 
vxclose (dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int unit, port;
	struct tty *tp;
	struct vx_info *vxt;
	struct vxsoftc *sc;
	int s;
	struct close_packet cpkt;
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
/*   flush_ctl(sc, port, 2);   flush both input and output */

	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	(*linesw[tp->t_line].l_close)(tp, flag);

	if ((tp->t_cflag & HUPCL) != 0) {
		rts_ctl(sc, port, 0);
		dtr_ctl(sc, port, 0);
	}

	s = splvx();

	bzero(&cpkt, sizeof(struct packet));
	cpkt.eye_catcher[0] = 0x55;
	cpkt.eye_catcher[1] = 0x55;
	cpkt.eye_catcher[2] = 0x55;
	cpkt.eye_catcher[3] = 0x55;
	cpkt.command_pipe_number = sc->channel_number;
	cpkt.status_pipe_number = sc->channel_number;
	cpkt.command = CMD_CLOSE;
	cpkt.device_number = port;

	bpp_send(sc, &cpkt, NOWAIT);
	splx(s);
	ttyclose(tp);
	sc->sc_info[port].open = 0;
	return (0);
}

void 
read_wakeup(sc, port)
	struct vxsoftc *sc;
	int port;
{
	struct read_wakeup_packet rwp;
	struct vx_info *volatile vxt;
	vxt = &sc->sc_info[port];
	/* 
	 * If we already have a read_wakeup paket 
	 * for this port, do nothing.
	 */
	if (vxt->read_pending) {
		return;
	} else {
		vxt->read_pending = 1;
	}

	bzero(&rwp, sizeof(struct packet));
	rwp.eye_catcher[0] = 0x11;
	rwp.eye_catcher[1] = 0x11;
	rwp.eye_catcher[2] = 0x11;
	rwp.eye_catcher[3] = 0x11;
	rwp.command_pipe_number = sc->channel_number;
	rwp.status_pipe_number = sc->channel_number;
	rwp.command = CMD_READW;
	rwp.device_number = port;

	/*
	 * Do not wait.  Characters will be transferred
	 * to (*linesw[tp->t_line].l_rint)(c,tp); by 
	 * vx_intr()  (IPC will notify via interrupt)
	 */
	bpp_send(sc, &rwp, NOWAIT);
}

int 
vxread (dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, port;
	struct tty *tp;
	struct vx_info *volatile vxt;
	struct vxsoftc *volatile sc;

	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	if (!tp) return ENXIO;
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int 
vxwrite (dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, port;
	struct tty *tp;
	struct vx_info *vxt;
	struct vxsoftc *sc;
	struct wring *wp;
	struct write_wakeup_packet wwp;
	u_short get, put;

	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}

	port = VX_PORT(dev);
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	if (!tp) return ENXIO;

	wp = sc->sc_info[port].wringp;
	get = wp->get;
	put = wp->put;

	if ((put + 1) == get) {
		bzero(&wwp, sizeof(struct packet));
		wwp.eye_catcher[0] = 0x22;
		wwp.eye_catcher[1] = 0x22;
		wwp.eye_catcher[2] = 0x22;
		wwp.eye_catcher[3] = 0x22;
		wwp.command_pipe_number = sc->channel_number;
		wwp.status_pipe_number = sc->channel_number;
		wwp.command = CMD_WRITEW;
		wwp.device_number = port;

		port = VX_PORT(dev);
		vxt = &sc->sc_info[port];
		tp = vxt->tty;
		if (!tp) return ENXIO;

		wp = sc->sc_info[port].wringp;
		get = wp->get;
		put = wp->put;

		if ((put + 1) == get) {
			bzero(&wwp, sizeof(struct packet));
			wwp.eye_catcher[0] = 0x22;
			wwp.eye_catcher[1] = 0x22;
			wwp.eye_catcher[2] = 0x22;
			wwp.eye_catcher[3] = 0x22;
			wwp.command_pipe_number = sc->channel_number;
			wwp.status_pipe_number = sc->channel_number;
			wwp.command = CMD_WRITEW;
			wwp.device_number = port;

			bpp_send(sc, &wwp, WAIT_POLL);

			if (wwp.error_l) {
				return (ENXIO);
			}
		}
	}
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}  

int
vxioctl (dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int error;
	int unit, port;
	struct tty *tp;
	struct vx_info *vxt;
	struct vxsoftc *sc;
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	if (!tp)
		return ENXIO;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {
	case TIOCSBRK:
		/* */
		break;

	case TIOCCBRK:
		/* */
		break;

	case TIOCSDTR:
		(void) vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) vx_mctl(dev, *(int *) data, DMSET);
		break;

	case TIOCMBIS:
		(void) vx_mctl(dev, *(int *) data, DMBIS);
		break;

	case TIOCMBIC:
		(void) vx_mctl(dev, *(int *) data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = vx_mctl(dev, 0, DMGET);
		break;

	case TIOCGFLAGS:
		*(int *)data = vxt->vx_swflags;
		break;

	case TIOCSFLAGS:
		error = suser(p->p_ucred, &p->p_acflag); 
		if (error != 0)
			return (EPERM);

		vxt->vx_swflags = *(int *)data;
		vxt->vx_swflags &= /* only allow valid flags */
				   (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
		break;

	default:
		return (ENOTTY);
	}
	return 0;
}

int
vxstop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = splvx();
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return 0;
}

void
vxputc(sc, port, c)
	struct vxsoftc *sc;
	int port;
	u_char c;
{
	struct wring *wp;

	wp = sc->sc_info[port].wringp;
	wp->data[wp->put++ & (WRING_BUF_SIZE-1)] = c;
	wp->put &= (WRING_BUF_SIZE-1);
	return;
}

u_short
vxtspeed(speed)
	int speed;
{
	switch (speed) {
	case B0:
		return VB0;
		break;
	case B50:
		return VB50;
		break;
	case B75:
		return VB75;
		break;
	case B110:
		return VB110;
		break;
	case B134:
		return VB134;
		break;
	case B150:
		return VB150;
		break;
	case B200:
		return VB200;
		break;
	case B300:
		return VB300;
		break;
	case B600:
		return VB600;
		break;
	case B1200:
		return VB1200;
		break;
	case B1800:
		return VB1800;
		break;
	case B2400:
		return VB2400;
		break;
	case B4800:
		return VB4800;
		break;
	case B9600:
		return VB9600;
		break;
	case B19200:
		return VB19200;
		break;
	case B38400:
		return VB38400;
		break;
	default:
		return VB9600;
		break;
	}
}

int
vx_ccparam(sc, par, port)
	struct vxsoftc *sc;
	struct termios *par;
	int port;
{
	int imask=0, s;
	int cflag /*, iflag, oflag, lflag*/;
	struct ioctl_a_packet pkt;
	bzero(&pkt, sizeof(struct packet));

	if (par->c_ospeed == 0) {
		s = splvx();
		/* dont kill the console */
		if (sc->sc_info[port].vx_consio == 0) {
			/* disconnect, drop RTS DTR stop receiver */
			rts_ctl(sc, port, 0);
			dtr_ctl(sc, port, 0);
		}
		splx(s);
		return (0xff);
	}

	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCGETA;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	bpp_send(sc, &pkt, WAIT_POLL);

	cflag = pkt.c_cflag;
	cflag |= vxtspeed(par->c_ospeed);

	switch (par->c_cflag & CSIZE) {
	case CS5:
		cflag |= VCS5;
		imask = 0x1F;
		break;
	case CS6:
		cflag |= VCS6;
		imask = 0x3F;
		break;
	case CS7:
		cflag |= VCS7;
		imask = 0x7F;
		break;
	default:
		cflag |= VCS8;
		imask = 0xFF;
	}

	if (par->c_cflag & PARENB) cflag |= VPARENB;
	else cflag &= ~VPARENB;
	if (par->c_cflag & PARODD) cflag |= VPARODD;
	else cflag &= ~VPARODD;
	if (par->c_cflag & CREAD) cflag |= VCREAD;
	else cflag &= ~VCREAD;
	if (par->c_cflag & CLOCAL) cflag |= VCLOCAL;
	else cflag &= ~VCLOCAL;
	if (par->c_cflag & HUPCL) cflag |= VHUPCL;
	else cflag &= ~VHUPCL;
#if 0
	if (par->c_iflag & BRKINT) iflag |= VBRKINT;
	else iflag &= ~VBRKINT;
	if (par->c_iflag & ISTRIP) iflag |= VISTRIP;
	else iflag &= ~VISTRIP;
	if (par->c_iflag & ICRNL) iflag |= VICRNL;
	else iflag &= ~VICRNL;
	if (par->c_iflag & IXON) iflag |= VIXON;
	else iflag &= ~VIXON;
	if (par->c_iflag & IXANY) iflag |= VIXANY;
	else iflag &= ~VIXANY;
	if (par->c_oflag & OPOST) oflag |= VOPOST;
	else oflag &= ~VOPOST;
	if (par->c_oflag & ONLCR) oflag |= VONLCR;
	else oflag &= ~VONLCR;
	if (par->c_oflag & OXTABS) oflag |= VOXTABS;
	else oflag &= ~VOXTABS;
	if (par->c_lflag & ECHO) lflag |= VECHO;
	else lflag &= ~VECHO;
	if (par->c_lflag & ECHOE) lflag |= VECHOE;
	else lflag &= ~VECHOE;
	if (par->c_lflag & ICANON) lflag |= VICANON;
	else lflag &= ~VICANON;
	if (par->c_lflag & ISIG) lflag |= VISIG;
	else lflag &= ~VISIG;
#endif 
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCSETA;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	pkt.c_cflag = cflag;
#if 0
	pkt.c_iflag = iflag;
	pkt.c_oflag = oflag;
	pkt.c_lflag = lflag;
#endif

	bpp_send(sc, &pkt, WAIT_POLL);
	return imask;
}

void
vx_unblock(tp)
	struct tty *tp;
{
	tp->t_state &= ~TS_FLUSH;
	if (tp->t_outq.c_cc != 0)
		vxstart(tp);
}

void
vxstart(tp)
	struct tty *tp;
{
	dev_t dev;
	struct vxsoftc *sc;
	struct wring *wp;
	int cc, port, unit, s, cnt, i;
	u_short get, put;
	char buffer[WRING_BUF_SIZE];

	dev = tp->t_dev;
	port = VX_PORT(dev);
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return;
	}

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = splvx();
	if ((tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP | TS_FLUSH)) == 0) {
		tp->t_state |= TS_BUSY;
		wp = sc->sc_info[port].wringp;
		get = wp->get;
		put = wp->put;
		cc = tp->t_outq.c_cc;
		while (cc > 0) {
			cnt = min(WRING_BUF_SIZE, cc);
			cnt = q_to_b(&tp->t_outq, buffer, cnt);
			buffer[cnt] = 0;
			for (i=0; i<cnt; i++) {
				vxputc(sc, port, buffer[i]);
			}
			cc -= cnt;
		}
		tp->t_state &= ~TS_BUSY;
	}
	splx(s);
	return;
}

void 
read_chars(sc, port)
	struct vxsoftc *sc;
	int port;
{
	/* 
	 * This routine is called by vx_intr() when there are
	 * characters in the read ring.  It will process one 
	 * cooked line, put the chars in the line disipline ring,
	 * and then return.  The characters may then 
	 * be read by vxread.
	 */
	struct vx_info *vxt;
	struct rring *rp;
	struct tty *tp;
	u_short get, put;
	int frame_count, i, open;
	char c;

	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	rp = vxt->rringp;
	open = vxt->open;
	get = rp->get;
	put = rp->put;
#ifdef DEBUG_VXT
	printf("read_chars() get=%d, put=%d ", get, put);
	printf("open = %d ring at 0x%x\n", open, rp);
#endif 
	while (get != put) {
		frame_count = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
		rp->get &= (RRING_BUF_SIZE - 1);
		for (i=0; i<frame_count; i++) {
			c = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
			rp->get &= (RRING_BUF_SIZE - 1);
			if (open)
				(*linesw[tp->t_line].l_rint)(c,tp);
		}
		c = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
		rp->get &= (RRING_BUF_SIZE - 1);
		if (!(c & DELIMITER)) {
			vx_frame (sc, port);
			break;
		} else {
			break;
		}
		get = rp->get;
		put = rp->put;
	}
	vxt->read_pending = 0;
	read_wakeup(sc, port);
	return;
}

void
ccode(sc, port, c)
	struct vxsoftc *sc;
	int port;
	char c;
{
	struct vx_info *vxt;
	struct tty *tp;
	tp = vxt->tty;
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	(*linesw[tp->t_line].l_rint)(c,tp);
}

int
vx_intr(arg)
	void *arg;
{
	struct vxsoftc *sc = arg;
	struct envelope *envp, *next_envp;
	struct packet *pktp, pkt;
	int valid;
	short  cmd;
	u_char  port;

#if defined(MVME187) || defined(MVME197)
	struct vme2reg *vme2 = (struct vme2reg *)sc->sc_vme2;

	if (vme2->vme2_vbr & VME2_SYSFAIL) {
		/* do something... print_dump(sc); */
		
	}
#endif /* defined(MVME187) || defined(MVME197) */
	if (!cold) sc->sc_intrcnt.ev_count++;

	while (env_isvalid(get_status_head(sc))) {
		pktp = get_packet(sc, get_status_head(sc));
		valid = env_isvalid(get_status_head(sc));
		cmd = pktp->command;
		port = pktp->device_number;
		/* if we are waiting on this packet, strore the info so bpp_send 
		   can process the packet  */
		if (sc->sc_bppwait_pktp == pktp)
			memcpy2(&sc->sc_bppwait_pkt, pktp, sizeof(struct packet));

		memcpy2(&pkt, pktp, sizeof(struct packet));
		next_envp = get_next_envelope(get_status_head(sc));
		envp = get_status_head(sc);
		/* return envelope and packet to the free queues */
		put_free_envelope(sc, envp);
		put_free_packet(sc, pktp);
		/* mark new status pipe head pointer */
		set_status_head(sc, next_envp);
		/* if it was valid, process packet */
		switch (cmd) {
		case CMD_READW:
#ifdef DEBUG_VXT
			printf("READW Packet\n");  
#endif 
			read_chars(sc, port);          
			return 1;
			break;
		case CMD_WRITEW:
#ifdef DEBUG_VXT
			printf("WRITEW Packet\n");  /* Still don't know XXXsmurph */
#endif 
			return 1;
			break;
		case CMD_EVENT:
#ifdef DEBUG_VXT
			printf("EVENT Packet\n");  
#endif 
			vx_event(sc, &pkt);
			return 1;
			break;
		case CMD_PROCCESED:
#ifdef DEBUG_VXT
			printf("CMD_PROCCESED Packet\n");
#endif 
			return 1;
			break;
		default:
#ifdef DEBUG_VXT
			printf("Other packet 0x%x\n", cmd);  
#endif 
			return 1;
			break;
		}
	}
	return 1;
}

int 
vx_event(sc, evntp)
	struct vxsoftc *sc;
	struct packet *evntp;
{
	u_short code = evntp->event_code;
	struct event_packet evnt;
	struct vx_info *vxt;

	vxt = &sc->sc_info[evntp->device_number];

	if (code & E_INTR) {
		ccode(sc, evntp->device_number, CINTR);
	}
	if (code & E_QUIT) {
		ccode(sc, evntp->device_number, CQUIT);
	}
	if (code & E_HUP) {
		rts_ctl(sc, evntp->device_number, 0);
		dtr_ctl(sc, evntp->device_number, 0);
	}
	if (code & E_DCD) {
		vxt->vx_linestatus |= TIOCM_CD;
	}
	if (code & E_DSR) {
		vxt->vx_linestatus |= TIOCM_DSR;
	}
	if (code & E_CTS) {
		vxt->vx_linestatus |= TIOCM_CTS;
	}
	if (code & E_LOST_DCD) {
		vxt->vx_linestatus &= ~TIOCM_CD;
	}
	if (code & E_LOST_DSR) {
		vxt->vx_linestatus &= ~TIOCM_DSR;
	}
	if (code & E_LOST_CTS) {
		vxt->vx_linestatus &= ~TIOCM_CTS;
	}
	if (code & E_PR_FAULT) {
		/* do something... */
		
	}
	if (code & E_PR_POUT) {
		/* do something... */
		
	}
	if (code & E_PR_SELECT) {
		/* do something... */
		
	}
	if (code & E_SWITCH) {
		/* do something... */
		
	}
	if (code & E_BREAK) {
		vx_break (sc, evntp->device_number);
	}

	/* send and event packet backe to the device */
	bzero(&evnt, sizeof(struct event_packet));
	evnt.command = CMD_EVENT;
	evnt.device_number = evntp->device_number;
	evnt.command_pipe_number = sc->channel_number;
	/* return status on same channel */
	evnt.status_pipe_number = sc->channel_number;
	/* send packet to the firmware */
	bpp_send(sc, &evnt, NOWAIT);
	return 1;
}

void
vx_overflow (sc, port, ptime, msg)
	struct vxsoftc *sc;
	int port;
	long *ptime;
	u_char *msg;
{
	log(LOG_WARNING, "%s port %d: overrun\n", sc->sc_dev.dv_xname, port);
	return;
}

void
vx_frame (sc, port)
	struct vxsoftc *sc;
	int port;
{
	log(LOG_WARNING, "%s port %d: frame error\n", sc->sc_dev.dv_xname, port);
	return;
}

void
vx_break (sc, port)
	struct vxsoftc *sc;
	int port;
{
#ifdef DDB
	if (db_console != 0)
		Debugger();
#else
	log(LOG_WARNING, "%s port %d: break detected\n", sc->sc_dev.dv_xname, port);
#endif
	return;
}

/*
 *	Initialization and Buffered Pipe Protocol (BPP) code
 */

/* special function for 16 bit data transfer */
/* Not needed now that I figured out VME bus */
/* mappings and address modifiers, but I don't */
/* want to change them :) */
void
memcpy2(void *dest, const void *src, size_t size)
{
	int i;
	short *d, *s;
	d = (short *) dest;
	s = (short *) src;
	for (i=0; i<(size/2); i++) {
		*d = *s;
		d++;
		s++;
	}
}

void
wzero(void *addr, size_t size)
{
	int i;
	short *d;
	d = (short *) addr;
	for (i=0; i<(size/2); i++) {
		*d = 0;
		d++;
	}
}

int
create_free_queue(sc)
	struct vxsoftc *sc;
{
	int i;
	struct envelope *envp;
	struct packet   *pktp;

	envp = (struct envelope *)ENVELOPE_AREA;
	sc->elist_head = envp;
	for (i=0; i < NENVELOPES; i++) {
		bzero(envp, sizeof(struct envelope));
		if (i==(NENVELOPES - 1)) {
			envp->link = NULL;
		} else {
			envp->link = (u_long)envp + sizeof(struct envelope);
		}
		envp->packet_ptr = NULL;
		envp->valid_flag = 0;
		envp++;
	}
	sc->elist_tail = --envp;

	pktp = (struct packet *)PACKET_AREA;
	sc->plist_head = pktp;
	for (i=0; i < NPACKETS; i++) {
		bzero(pktp, sizeof(struct packet));
		if (i==(NPACKETS - 1)) {
			pktp->link = NULL;
		} else {
			pktp->link = (u_long)pktp + sizeof(struct packet);
		}
		pktp++;
	}
	sc->plist_tail = --pktp;
	return 0; /* no error */
}

void *
get_free_envelope(sc) 
	struct vxsoftc *sc;
{
	void *envp;

	envp = sc->elist_head;
	sc->elist_head = (struct envelope *)sc->elist_head->link;
	bzero(envp, sizeof(struct envelope));
	return envp;
}

void 
put_free_envelope(sc, ep)
	struct vxsoftc *sc;
	void * ep;
{
	struct envelope *envp = (struct envelope *)ep;
	bzero(envp, sizeof(struct envelope));
	sc->elist_tail->link = (ulong)envp;
	envp->link = NULL;
	sc->elist_tail = envp;
}

void * 
get_free_packet(sc)
	struct vxsoftc *sc;
{
	struct packet *pktp;

	pktp = sc->plist_head;
	sc->plist_head = (struct packet *)sc->plist_head->link;
	bzero(pktp, sizeof(struct packet));
	return pktp;
}

void 
put_free_packet(sc, pp)
	struct vxsoftc *sc;
	void *pp;
{
	struct packet *pktp = (struct packet *)pp;
	/*bzero(pktp, sizeof(struct packet));*/
	pktp->command = CMD_PROCCESED;
	sc->plist_tail->link = (u_long)pktp;
	pktp->link = NULL;
	sc->plist_tail = pktp;
}

/* 
 * This is the nitty gritty.  All the rest if this code
 * was hell to come by.  Getting this right from the 
 * Moto manual took *time*!  
 */
int 
create_channels(sc)
	struct vxsoftc *sc;
{
	struct envelope *envp;
	u_short status;
	u_short tas;
	struct vxreg *ipc_csr;

	ipc_csr = sc->vx_reg;
	/* wait for busy bit to clear */
	while ((ipc_csr->ipc_cr & IPC_CR_BUSY));
	create_free_queue(sc);
	/* set up channel header.  we only want one */
	tas = ipc_csr->ipc_tas;
	while (!(tas & IPC_TAS_VALID_STATUS)) {
		envp = get_free_envelope(sc);
		sc->channel->command_pipe_head_ptr_h = HI(envp);
		sc->channel->command_pipe_head_ptr_l = LO(envp);
		sc->channel->command_pipe_tail_ptr_h = sc->channel->command_pipe_head_ptr_h;
		sc->channel->command_pipe_tail_ptr_l = sc->channel->command_pipe_head_ptr_l;
		envp = get_free_envelope(sc);
		sc->channel->status_pipe_head_ptr_h = HI(envp);
		sc->channel->status_pipe_head_ptr_l = LO(envp);
		sc->channel->status_pipe_tail_ptr_h = sc->channel->status_pipe_head_ptr_h;
		sc->channel->status_pipe_tail_ptr_l = sc->channel->status_pipe_head_ptr_l;
		sc->channel->interrupt_level =  sc->sc_ipl;
		sc->channel->interrupt_vec = sc->sc_vec;
		sc->channel->channel_priority = 0;
		sc->channel->channel_number = 0;
		sc->channel->valid = 1;
		sc->channel->address_modifier = 0x8D; /* A32/D16 supervisor data access */
		sc->channel->datasize = 0; /* 32 bit data mode */

		/* loop until TAS bit is zero */
		while ((ipc_csr->ipc_tas & IPC_TAS_TAS)); 
		ipc_csr->ipc_tas |= IPC_TAS_TAS;
		/* load address of channel header */
		ipc_csr->ipc_addrh = HI(sc->channel);
		ipc_csr->ipc_addrl = LO(sc->channel);
		/* load address modifier reg (supervisor data access) */
		ipc_csr->ipc_amr = 0x8D;
		/* load tas with create channel command */
		ipc_csr->ipc_tas |= IPC_CSR_CREATE;
		/* set vaild command bit */
		ipc_csr->ipc_tas |= IPC_TAS_VALID_CMD;
		/* notify IPC of the CSR command */
		ipc_csr->ipc_cr |= IPC_CR_ATTEN;
		/* loop until IPC sets vaild status bit */
		delay(5000);
		tas = ipc_csr->ipc_tas;
	}

	/* save the status */
	status = ipc_csr->ipc_sr;
	/* set COMMAND COMPLETE bit */
	ipc_csr->ipc_tas |= IPC_TAS_COMPLETE;
	/* notify IPC that we are through */
	ipc_csr->ipc_cr |= IPC_CR_ATTEN;
	/* check and see if the channel was created */
	if (!status && sc->channel->valid) {
		sc->channel_number = sc->channel->channel_number;
		printf("%s: created channel %d\n", sc->sc_dev.dv_xname, 
		       sc->channel->channel_number);
		return 0;
	} else {
		switch (status) {
		case 0x0000:
			printf("%s: channel not valid\n", 
			       sc->sc_dev.dv_xname);
			break;
		case 0xFFFF:
			printf("%s: invalid CSR command\n", 
			       sc->sc_dev.dv_xname);
			break;
		case 0xC000:
			printf("%s: could not read channel structure\n", 
			       sc->sc_dev.dv_xname);
			break;
		case 0x8000:
			printf("%s: could not write channel structure\n", 
			       sc->sc_dev.dv_xname);
			break;
		default:
			printf("%s: unknown IPC CSR command error 0x%x\n", 
			       sc->sc_dev.dv_xname, status);
			break;
		}
		return status; /* error */
	}
}

void
print_dump(sc)
	struct vxsoftc *sc;
{
	char *dump_area;
	char dump[209];
	bzero(&dump, 209);

	dump_area = (char *)0xff780030;
	memcpy2(&dump, dump_area, 208);

	printf("%s", dump);
}

void *
get_next_envelope(thisenv)
	struct envelope *thisenv;
{
	return ((void *)thisenv->link);
}

int 
env_isvalid(thisenv)
	struct envelope *thisenv;
{
	return thisenv->valid_flag;
}

struct envelope *
get_cmd_tail(sc)
	struct vxsoftc *sc; 
{
	unsigned long retaddr;
	retaddr = (unsigned long)sc->vx_reg;
	retaddr += sc->channel->command_pipe_tail_ptr_l;
	return ((struct envelope *)retaddr);
}

struct envelope *
get_status_head(sc)
	struct vxsoftc *sc;
{
	unsigned long retaddr;
	retaddr = (unsigned long)sc->vx_reg;
	retaddr += sc->channel->status_pipe_head_ptr_l;
	return ((struct envelope *)retaddr);
}

void
set_status_head(sc, envp)
	struct vxsoftc *sc;
	void *envp;
{
	sc->channel->status_pipe_head_ptr_h = HI(envp);
	sc->channel->status_pipe_head_ptr_l = LO(envp);
	return;   
}

struct packet *
get_packet(sc, thisenv)
	struct vxsoftc *sc;
	struct envelope *thisenv;
{
	unsigned long baseaddr; 

	if (thisenv == NULL) return NULL;
	baseaddr = (unsigned long)sc->vx_reg;
	/* 
	 * packet ptr returned on status pipe is only last two bytes
	 * so we must supply the full address based on the board address.
	 * This also works for all envelopes because every address is an
	 * offset to the board address 
	 */
	baseaddr |= thisenv->packet_ptr;
	return ((void *)baseaddr);
}

/*
 *	Send a command via BPP
 */
int 
bpp_send(struct vxsoftc *sc, void *pkt, int wait_flag)
{
	struct envelope *envp;
	struct packet *pktp;
	unsigned long newenv;


	/* load up packet in dual port mem */
	pktp = get_free_packet(sc);
	memcpy2(pktp, pkt, sizeof(struct packet));

	envp = get_cmd_tail(sc);
	newenv = (unsigned long)get_free_envelope(sc); /* put a NULL env on the tail */
	envp->link = newenv;
	sc->channel->command_pipe_tail_ptr_h = HI(newenv);
	sc->channel->command_pipe_tail_ptr_l = LO(newenv);
	envp->packet_ptr = (u_long)pktp;   /* add the command packet */
	envp->valid_flag = 1;		   /* set valid command flag */

	sc->vx_reg->ipc_cr |= IPC_CR_ATTEN;
	if (wait_flag) {		    /* wait for a packet to return */
		while (pktp->command != CMD_PROCCESED) {
#ifdef DEBUG_VXT
			printf("Polling for packet 0x%x in envelope 0x%x...\n", pktp, envp);
#endif 
			vx_intr(sc);
			delay(5000);
		}
		memcpy2(pkt, pktp, sizeof(struct packet));
		return 0;
	}
	return 0; /* no error */
}

/*
 *	BPP commands
 */

int 
vx_init(sc)
	struct vxsoftc *sc;
{
	int i;
	struct init_info *infp, inf;
	struct wring *wringp;
	struct rring *rringp;
	struct termio def_termio;
	struct init_packet init;
	struct event_packet evnt;

	bzero(&def_termio, sizeof(struct termio));
	/* init wait queue */
	bzero(&sc->sc_bppwait_pkt, sizeof(struct packet));
	sc->sc_bppwait_pktp = NULL;
	/* set up init_info array */
	wringp = (struct wring *)WRING_AREA;
	rringp = (struct rring *)RRING_AREA;
	infp = (struct init_info *)INIT_INFO_AREA;
	for (i=0; i<9; i++) {
		bzero(&inf, sizeof(struct init_info));
		infp->write_ring_ptr_h = HI(wringp);
		infp->write_ring_ptr_l = LO(wringp);
		sc->sc_info[i].wringp = wringp;
		infp->read_ring_ptr_h = HI(rringp);
		infp->read_ring_ptr_l = LO(rringp);
		sc->sc_info[i].rringp = rringp;
#ifdef DEBUG_VXT
		printf("write at 0x%8x, read at 0x%8x\n", wringp, rringp);
#endif 
		infp->write_ring_size = WRING_DATA_SIZE;
		infp->read_ring_size = RRING_DATA_SIZE;
		infp->def_termio.c_iflag = VBRKINT;
		infp->def_termio.c_oflag = 0;
		infp->def_termio.c_cflag = (VB9600 | VCS8);

		infp->def_termio.c_lflag = VISIG; /* enable signal processing */
		infp->def_termio.c_line = 1; /* raw line disipline, we want to control it! */
		infp->def_termio.c_cc[0] = CINTR;
		infp->def_termio.c_cc[1] = CQUIT;
		infp->def_termio.c_cc[2] = CERASE;
		infp->def_termio.c_cc[3] = CKILL;
		infp->def_termio.c_cc[4] = 20;
		infp->def_termio.c_cc[5] = 2;
		infp->reserved1 = 0;  /* Must be Zero */
		infp->reserved2 = 0;
		infp->reserved3 = 0;
		infp->reserved4 = 0;
		wringp++; rringp++; infp++;
	}
	/* set up init_packet */
	bzero(&init, sizeof(struct init_packet));
	init.eye_catcher[0] = 0x12;
	init.eye_catcher[1] = 0x34;
	init.eye_catcher[2] = 0x56;
	init.eye_catcher[3] = 0x78;
	init.command = CMD_INIT;
	init.command_pipe_number = sc->channel_number;
	/* return status on the same channel */
	init.status_pipe_number = sc->channel_number;
	init.interrupt_level = sc->sc_ipl;
	init.interrupt_vec = sc->sc_vec;
	init.init_info_ptr_h = HI(INIT_INFO_AREA);
	init.init_info_ptr_l = LO(INIT_INFO_AREA);

	/* send packet to the firmware and wait for completion */
	bpp_send(sc, &init, WAIT_POLL);

	/* check for error */
	if (init.error_l !=0) {
		return init.error_l;
	} else {
		/* send one event packet to each device; */
		for (i=0; i<9; i++) {
			bzero(&evnt, sizeof(struct event_packet));
			evnt.command = CMD_EVENT;
			evnt.device_number = i;
			evnt.command_pipe_number = sc->channel_number;
			/* return status on same channel */
			evnt.status_pipe_number = sc->channel_number;
			/* send packet to the firmware */
			bpp_send(sc, &evnt, NOWAIT);
		}
		return 0;
	}
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.21 2003/06/03 21:09:01 deraadt Exp $ */
d6 1
d15 4
a18 1
 * 3. The name of the author may not be used to endorse or promote products
@


1.1.1.3
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.22 2003/08/15 20:32:14 tedu Exp $ */
d781 1
a781 1
		error = suser(p, 0); 
@


1.1.1.4
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.25 2003/12/22 11:54:48 miod Exp $ */
d3 1
a3 1
 * Copyright (c) 1999 Steve Murphree, Jr.
d27 1
a27 1
 */
d153 1
a153 1
struct cfattach vx_ca = {
d155 1
a155 1
};
d159 2
a160 2
};

d164 3
d173 1
a173 1
	if (unit >= vx_cd.cd_ndevs ||
d181 1
a181 1
int
d189 5
a193 1

a194 1
	ca->ca_len = 0x10000;	/* we know this */
d197 1
d200 1
a200 2

	return (1);
d211 1
a211 1

d217 3
a219 3
#endif
	sc->sc_ipl = ca->ca_ipl;
	sc->sc_vec = ca->ca_vec;
d225 1
a225 1
		printf("%s: failed to create channel %d\n", sc->sc_dev.dv_xname,
d411 1
a411 1
	if (unit >= vx_cd.cd_ndevs ||
d434 1
a434 1
#endif
d445 1
a445 1
		tp = vxt->tty = ttymalloc();
d509 1
a509 1
int
d520 1
a520 1
	if (unit >= vx_cd.cd_ndevs ||
d533 1
a533 1
int
d547 1
a547 1
	if (unit >= vx_cd.cd_ndevs ||
d582 1
a582 1
void
d590 2
a591 2
	/*
	 * If we already have a read_wakeup paket
d612 1
a612 1
	 * to (*linesw[tp->t_line].l_rint)(c,tp); by
d618 1
a618 1
int
d630 1
a630 1
	if (unit >= vx_cd.cd_ndevs ||
d641 1
a641 1
int
d656 1
a656 1
	if (unit >= vx_cd.cd_ndevs ||
d709 1
a709 1
}
d725 1
a725 1
	if (unit >= vx_cd.cd_ndevs ||
d781 1
a781 1
		error = suser(p, 0);
d971 1
a971 1
#endif
d1011 1
a1011 1
	if (unit >= vx_cd.cd_ndevs ||
d1041 1
a1041 1
void
d1046 1
a1046 1
	/*
d1048 1
a1048 1
	 * characters in the read ring.  It will process one
d1050 1
a1050 1
	 * and then return.  The characters may then
d1069 1
a1069 1
#endif
d1125 1
d1135 1
a1135 1
		/* if we are waiting on this packet, strore the info so bpp_send
d1152 3
a1154 3
			printf("READW Packet\n");
#endif
			read_chars(sc, port);
d1160 1
a1160 1
#endif
d1165 2
a1166 2
			printf("EVENT Packet\n");
#endif
d1170 1
a1170 1
		case CMD_PROCESSED:
d1172 2
a1173 2
			printf("CMD_PROCESSED Packet\n");
#endif
d1178 2
a1179 2
			printf("Other packet 0x%x\n", cmd);
#endif
d1187 1
a1187 1
int
d1228 1
d1232 1
d1236 1
d1240 1
d1303 9
a1311 8
	size_t i;
	u_int16_t *d, *s;

	d = (u_int16_t *)dest;
	s = (u_int16_t *)src;
	size /= 2;
	for (i = 0; i < size; i++)
		*d++ = *s++;
d1317 7
a1323 6
	u_int16_t *d;

	d = (u_int16_t *)addr;
	size /= 2;
	while (size-- != 0)
		*d++ = 0;
d1365 1
a1365 1
get_free_envelope(sc)
d1376 1
a1376 1
void
d1388 1
a1388 1
void *
d1400 1
a1400 1
void
d1407 1
a1407 1
	pktp->command = CMD_PROCESSED;
d1413 1
a1413 1
/*
d1415 2
a1416 2
 * was hell to come by.  Getting this right from the
 * Moto manual took *time*!
d1418 1
a1418 1
int
d1453 1
a1453 1
		while ((ipc_csr->ipc_tas & IPC_TAS_TAS));
d1480 1
a1480 1
		printf("%s: created channel %d\n", sc->sc_dev.dv_xname,
d1486 1
a1486 1
			printf("%s: channel not valid\n",
d1490 1
a1490 1
			printf("%s: invalid CSR command\n",
d1494 1
a1494 1
			printf("%s: could not read channel structure\n",
d1498 1
a1498 1
			printf("%s: could not write channel structure\n",
d1502 1
a1502 1
			printf("%s: unknown IPC CSR command error 0x%x\n",
d1531 1
a1531 1
int
d1540 1
a1540 1
	struct vxsoftc *sc;
d1565 1
d1573 1
a1573 1
	unsigned long baseaddr;
d1577 1
a1577 1
	/*
d1581 1
a1581 1
	 * offset to the board address
d1590 1
a1590 1
int
d1612 1
a1612 1
		while (pktp->command != CMD_PROCESSED) {
d1615 1
a1615 1
#endif
d1629 1
a1629 1
int
d1659 1
a1659 1
#endif
@


1.1.1.5
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.27 2003/12/27 21:58:20 miod Exp $ */
d49 9
d60 4
d70 1
d80 2
a81 1
	struct vx_info  sc_info[NVXPORTS];
d90 3
d100 52
a151 2
int  vxmatch(struct device *, void *, void *);
void vxattach(struct device *, struct device *, void *);
d158 1
a158 1
	NULL, "vx", DV_TTY
d161 2
a162 42
void	bpp_send(struct vxsoftc *, void *, int);
void	ccode(struct vxsoftc *, int, char);
int	create_channels(struct vxsoftc *);
void	create_free_queue(struct vxsoftc *);
short	dtr_ctl(struct vxsoftc *, int, int);
int	env_isvalid(struct envelope *);
struct envelope *find_status_packet(struct vxsoftc *, struct packet *);
short	flush_ctl(struct vxsoftc *, int, int);
struct envelope *get_cmd_tail(struct vxsoftc *);
void	*get_free_envelope(struct vxsoftc *);
void	*get_free_packet(struct vxsoftc *);
struct envelope *get_next_envelope(struct envelope *);
struct packet *get_packet(struct vxsoftc *, struct envelope *);
struct envelope *get_status_head(struct vxsoftc *);
void	put_free_envelope(struct vxsoftc *, void *);
void	put_free_packet(struct vxsoftc *, void *);
void	read_chars(struct vxsoftc *, int);
void	read_wakeup(struct vxsoftc *, int);
short	rts_ctl(struct vxsoftc *, int, int);
void	set_status_head(struct vxsoftc *, void *);
void	vx_break(struct vxsoftc *, int);
int	vx_ccparam(struct vxsoftc *, struct termios *, int);
int	vx_event(struct vxsoftc *, struct packet *);
void	vx_frame(struct vxsoftc *, int);
int	vx_init(struct vxsoftc *);
int	vx_intr(void *);
int	vx_mctl(dev_t, int, int);
void	vx_overflow(struct vxsoftc *, int, long *, u_char *);
int	vx_param(struct tty *, struct termios *);
int	vx_poll(struct vxsoftc *, struct packet *);
void	vxputc(struct vxsoftc *, int, u_char);
int	vx_sintr(struct vxsoftc *);
void	vxstart(struct tty *tp);
u_short	vxtspeed(int);
void	vx_unblock(struct tty *);

/* flags for bpp_send() */
#define	NOWAIT 0
#define	WAIT 1

#define VX_UNIT(x) (minor(x) / NVXPORTS)
#define VX_PORT(x) (minor(x) % NVXPORTS)
d164 2
a165 2
struct tty *
vxtty(dev_t dev)
a168 1

d171 1
a171 1
	    (sc = (struct vxsoftc *)vx_cd.cd_devs[unit]) == NULL) {
d179 4
a182 1
vxmatch(struct device *parent, void *self, void *aux)
d187 1
a187 1
	ca->ca_ipl = IPL_TTY;
d191 2
d194 1
a194 1
	return (!badvaddr((vaddr_t)&vx_reg->ipc_cr, 1));
d198 4
a201 1
vxattach(struct device *parent, struct device *self, void *aux)
d206 1
a206 1
	/* set up dual port memory and registers and init */
d209 3
d218 3
a220 3
	if (create_channels(sc) != 0) {
		printf("%s: failed to create channel %d\n",
		    sc->sc_dev.dv_xname, sc->channel->channel_number);
d223 1
a223 1
	if (vx_init(sc) != 0) {
d238 2
d241 4
a244 1
dtr_ctl(struct vxsoftc *sc, int port, int on)
a246 1

a258 1

d263 4
a266 1
rts_ctl(struct vxsoftc *sc, int port, int on)
a268 1

a280 1

a283 1
#if 0
d285 4
a288 1
flush_ctl(struct vxsoftc *sc, int port, int which)
a290 1

a298 1

a300 1
#endif
d302 4
a305 2
int
vx_mctl(dev_t dev, int bits, int how)
d314 1
a314 1
	sc = (struct vxsoftc *)vx_cd.cd_devs[unit];
d320 1
a320 1
		if (bits & TIOCM_RTS) {
d325 1
d328 1
a328 1
		if (bits & TIOCM_DTR) {
d337 1
a337 1
		if (bits & TIOCM_RTS) {
d341 1
a341 1
		if (bits & TIOCM_DTR) {
d348 1
a348 1
		if (bits & TIOCM_RTS) {
d352 1
a352 1
		if (bits & TIOCM_DTR) {
d361 1
a361 1
		if (msvr & TIOCM_DSR) {
d364 1
a364 1
		if (msvr & TIOCM_CD) {
d367 1
a367 1
		if (msvr & TIOCM_CTS) {
d370 1
a370 1
		if (msvr & TIOCM_DTR) {
d373 1
a373 1
		if (msvr & TIOCM_RTS) {
a379 2

#if 0
a385 1
#endif
d389 5
a393 2
int
vxopen(dev_t dev, int flag, int mode, struct proc *p)
d399 1
a399 1
	struct packet opkt;
d404 1
a408 1
	vxt = &sc->sc_info[port];
d410 1
a410 3
#if 0
	flush_ctl(sc, port, 2);
#endif
d413 4
a416 1
	opkt.link = 0x33333333;	/* eye catcher */
d422 1
a422 1
	bpp_send(sc, &opkt, WAIT);
d429 1
a429 1
		return (ENXIO);
d433 1
d435 1
a435 1
	s = splvx();
d469 1
a469 1
			tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
d497 2
a498 1
	vxt->open = 1;
d500 1
a500 1
	return (*linesw[tp->t_line].l_open)(dev, tp);
d504 3
a506 1
vx_param(struct tty *tp, struct termios *t)
d528 5
a532 1
vxclose(dev_t dev, int flag, int mode, struct proc *p)
d539 1
a539 2
	struct packet cpkt;

d546 2
a548 4
#if 0
	flush_ctl(sc, port, 2);	/* flush both input and output */
#endif

a551 2
	s = splvx();

d557 2
d560 4
a563 1
	cpkt.link = 0x55555555;	/* eye catcher */
d568 1
a569 2

	vxt->open = 0;
d572 1
a572 1

d577 3
a579 1
read_wakeup(struct vxsoftc *sc, int port)
d581 1
a581 1
	struct packet rwp;
a582 1

d588 1
a588 1
	if (vxt->read_pending != 0)
d590 1
a590 1
	else
d592 1
d595 4
a598 1
	rwp.link = 0x11111111;	/* eye catcher */
d606 1
a606 1
	 * to (*linesw[tp->t_line].l_rint)(c, tp); by
d613 4
a616 1
vxread(dev_t dev, struct uio *uio, int flag)
d631 1
a631 2
	if (!tp)
		return ENXIO;
d636 4
a639 1
vxwrite(dev_t dev, struct uio *uio, int flag)
d646 1
a646 1
	struct packet wwp;
d654 1
d658 1
a658 2
	if (!tp)
		return ENXIO;
d663 1
d666 4
a669 1
		wwp.link = 0x22222222;	/* eye catcher */
a673 1
		bpp_send(sc, &wwp, WAIT);
d675 26
a700 2
		if (wwp.error_l != 0)
			return (ENXIO);
a701 1

d706 6
a711 1
vxioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
a717 1

d747 1
a747 1
		vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
d751 1
a751 1
		vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
d755 1
a755 1
		vx_mctl(dev, *(int *)data, DMSET);
d759 1
a759 1
		vx_mctl(dev, *(int *)data, DMBIS);
d763 1
a763 1
		vx_mctl(dev, *(int *)data, DMBIC);
d781 1
a781 1
		    (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
a786 1

d791 3
a793 1
vxstop(struct tty *tp, int flag)
d807 4
a810 1
vxputc(struct vxsoftc *sc, int port, u_char c)
d815 3
a817 2
	wp->data[wp->put++ & (WRING_BUF_SIZE - 1)] = c;
	wp->put &= (WRING_BUF_SIZE - 1);
d821 2
a822 1
vxtspeed(int speed)
d827 1
d830 1
d833 1
d836 1
d839 1
d842 1
d845 1
d848 1
d851 1
d854 1
d857 1
d860 1
d863 1
d866 1
d869 1
d872 1
d875 1
d880 4
a883 1
vx_ccparam(struct vxsoftc *sc, struct termios *par, int port)
d885 4
a888 3
	int imask = 0, s;
	int cflag;
	struct packet pkt;
d892 6
a897 3
		/* disconnect, drop RTS DTR stop receiver */
		rts_ctl(sc, port, 0);
		dtr_ctl(sc, port, 0);
a901 1
	bzero(&pkt, sizeof(struct packet));
d907 1
a907 1
	bpp_send(sc, &pkt, WAIT);
d909 1
a909 1
	cflag = pkt.pb.tio.c_cflag;
d940 26
a965 1

d971 6
a976 2
	pkt.pb.tio.c_cflag = cflag;
	bpp_send(sc, &pkt, WAIT);
d978 1
d983 2
a984 1
vx_unblock(struct tty *tp)
d992 2
a993 1
vxstart(struct tty *tp)
d1024 1
a1024 1
			for (i = 0; i < cnt; i++) {
d1032 1
d1036 3
a1038 1
read_chars(struct vxsoftc *sc, int port)
d1067 1
a1067 1
		for (i = 0; i < frame_count; i++) {
d1071 1
a1071 1
				(*linesw[tp->t_line].l_rint)(c, tp);
d1076 1
a1076 1
			vx_frame(sc, port);
d1086 1
d1090 4
a1093 1
ccode(struct vxsoftc *sc, int port, char c)
a1096 1

d1098 3
a1100 1
	(*linesw[tp->t_line].l_rint)(c, tp);
d1104 2
a1105 1
vx_intr(void *arg)
d1111 5
a1115 2
	short cmd;
	u_char port;
d1117 5
a1121 1
	sc->sc_intrcnt.ev_count++;
d1128 2
a1129 4
		/*
		 * If we are waiting on this packet, store the info
		 * so bpp_send can process the packet
		 */
d1131 1
a1131 1
			d16_bcopy(pktp, &sc->sc_bppwait_pkt, sizeof(struct packet));
d1133 1
a1133 1
		d16_bcopy(pktp, &pkt, sizeof(struct packet));
d1148 1
d1154 1
d1161 1
d1167 1
d1173 1
d1181 3
a1183 1
vx_event(struct vxsoftc *sc, struct packet *evntp)
d1186 1
a1186 1
	struct packet evnt;
d1232 1
a1232 1
		vx_break(sc, evntp->device_number);
d1235 2
a1236 2
	/* send an event packet back to the device */
	bzero(&evnt, sizeof(struct packet));
a1243 1

d1248 5
a1252 1
vx_overflow(struct vxsoftc *sc, int port, long *ptime, u_char *msg)
d1254 2
a1255 2
	log(LOG_WARNING, "%s port %d: overrun\n",
	    sc->sc_dev.dv_xname, port);
d1259 3
a1261 1
vx_frame(struct vxsoftc *sc, int port)
d1263 2
a1264 2
	log(LOG_WARNING, "%s port %d: frame error\n",
	    sc->sc_dev.dv_xname, port);
d1268 3
a1270 1
vx_break(struct vxsoftc *sc, int port)
d1272 7
a1278 6
	/*
	 * No need to check for a ddb break, as the console can never be on
	 * this hardware.
	 */
	log(LOG_WARNING, "%s port %d: break detected\n",
	    sc->sc_dev.dv_xname, port);
d1285 4
d1290 26
a1315 1
create_free_queue(struct vxsoftc *sc)
d1318 2
a1319 2
	struct envelope *envp, env;
	struct packet *pktp, pkt;
d1323 9
a1331 9
	for (i = 0; i < NENVELOPES; i++) {
		bzero(&env, sizeof(struct envelope));
		if (i == NENVELOPES - 1)
			env.link = NULL;
		else
			env.link = (u_long)envp + sizeof(struct envelope);
		env.packet_ptr = NULL;
		env.valid_flag = 0;
		d16_bcopy(&env, envp, sizeof(struct envelope));
d1338 7
a1344 7
	for (i = 0; i < NPACKETS; i++) {
		bzero(&pkt, sizeof(struct packet));
		if (i == NPACKETS - 1)
			pkt.link = NULL;
		else
			pkt.link = (u_long)pktp + sizeof(struct packet);
		d16_bcopy(&pkt, pktp, sizeof(struct packet));
d1348 1
d1352 2
a1353 1
get_free_envelope(struct vxsoftc *sc)
a1355 1
	u_long link;
d1358 2
a1359 5
	/* pick envelope next pointer from the envelope itself */
	d16_bcopy((const void *)&sc->elist_head->link, &link, sizeof link);
	sc->elist_head = (struct envelope *)link;
	d16_bzero(envp, sizeof(struct envelope));

d1364 3
a1366 1
put_free_envelope(struct vxsoftc *sc, void *ep)
d1369 3
a1371 10
	u_long link;

#if 0
	d16_bzero(envp, sizeof(struct envelope));
#endif
	/* put envelope next pointer in the envelope itself */
	link = (u_long)envp;
	d16_bcopy(&link, (void *)&sc->elist_tail->link, sizeof link);
	d16_bzero((void *)&envp->link, sizeof envp->link);

d1376 2
a1377 1
get_free_packet(struct vxsoftc *sc)
a1379 1
	u_long link;
d1382 2
a1383 5
	/* pick packet next pointer from the packet itself */
	d16_bcopy((const void *)&sc->plist_head->link, &link, sizeof link);
	sc->plist_head = (struct packet *)link;
	d16_bzero(pktp, sizeof(struct packet));

d1388 3
a1390 1
put_free_packet(struct vxsoftc *sc, void *pp)
d1393 1
a1393 5
	u_long link;

#if 0
	d16_bzero(pktp, sizeof(struct packet));
#endif
d1395 2
a1396 5
	/* put packet next pointer in the packet itself */
	link = (u_long)pktp;
	d16_bcopy(&link, (void *)&sc->plist_tail->link, sizeof link);
	d16_bzero((void *)&pktp->link, sizeof pktp->link);

d1406 2
a1407 1
create_channels(struct vxsoftc *sc)
d1416 1
a1416 2
	while ((ipc_csr->ipc_cr & IPC_CR_BUSY)) ;

d1418 1
a1418 1
	/* set up channel header. we only want one */
d1424 2
a1425 4
		sc->channel->command_pipe_tail_ptr_h =
		    sc->channel->command_pipe_head_ptr_h;
		sc->channel->command_pipe_tail_ptr_l =
		    sc->channel->command_pipe_head_ptr_l;
d1429 3
a1431 5
		sc->channel->status_pipe_tail_ptr_h =
		    sc->channel->status_pipe_head_ptr_h;
		sc->channel->status_pipe_tail_ptr_l =
		    sc->channel->status_pipe_head_ptr_l;
		sc->channel->interrupt_level = sc->sc_ipl;
d1436 1
a1436 1
		sc->channel->address_modifier = 0x8d; /* A32/D16 supervisor data access */
d1440 1
a1440 1
		while ((ipc_csr->ipc_tas & IPC_TAS_TAS)) ;
d1446 1
a1446 1
		ipc_csr->ipc_amr = 0x8d;
d1453 1
a1453 2

		/* loop until IPC sets valid status bit */
d1493 1
a1493 1
		return 1;
d1497 3
a1499 2
struct envelope *
get_next_envelope(struct envelope *thisenv)
d1501 3
a1503 1
	u_long ptr;
d1505 2
a1506 1
	d16_bcopy((const void*)&thisenv->link, &ptr, sizeof ptr);
d1508 8
a1515 1
	return ((struct envelope *)ptr);
d1519 2
a1520 1
env_isvalid(struct envelope *thisenv)
d1522 1
a1522 1
	return (int)thisenv->valid_flag;
d1526 2
a1527 1
get_cmd_tail(struct vxsoftc *sc)
a1529 1

d1536 2
a1537 1
get_status_head(struct vxsoftc *sc)
a1539 1

d1546 3
a1548 1
set_status_head(struct vxsoftc *sc, void *envp)
d1555 3
a1557 1
get_packet(struct vxsoftc *sc, struct envelope *thisenv)
d1559 1
a1559 4
	u_long baseaddr;

	if (thisenv == NULL)
		return NULL;
d1561 2
d1567 1
a1567 1
	 * offset to the board address.
d1569 2
a1570 4
	d16_bcopy((const void *)&thisenv->packet_ptr, &baseaddr, sizeof baseaddr);
	baseaddr |= (u_long)sc->vx_reg;

	return ((struct packet *)baseaddr);
d1576 1
a1576 1
void
d1581 2
a1582 1
	u_long ptr;
d1586 1
a1586 1
	d16_bcopy(pkt, pktp, sizeof(struct packet));
d1589 6
a1594 7
	ptr = (unsigned long)get_free_envelope(sc); /* put a NULL env on the tail */
	d16_bcopy(&ptr, (void *)&envp->link, sizeof envp->link);
	sc->channel->command_pipe_tail_ptr_h = HI(ptr);
	sc->channel->command_pipe_tail_ptr_l = LO(ptr);
	ptr = (u_long)pktp;
	d16_bcopy(&ptr, (void *)&envp->packet_ptr, sizeof envp->packet_ptr);
	envp->valid_flag = 1;
d1597 1
a1597 3

	/* wait for a packet to return */
	if (wait_flag != NOWAIT) {
d1605 2
a1606 1
		d16_bcopy(pktp, pkt, sizeof(struct packet));
d1608 1
d1616 2
a1617 1
vx_init(struct vxsoftc *sc)
d1624 2
a1625 2
	struct packet init;
	struct packet evnt;
d1629 1
a1629 1
	d16_bzero(&sc->sc_bppwait_pkt, sizeof(struct packet));
d1635 1
a1635 1
	for (i = 0; i < NVXPORTS; i++) {
d1637 2
a1638 2
		inf.write_ring_ptr_h = HI(wringp);
		inf.write_ring_ptr_l = LO(wringp);
d1640 2
a1641 2
		inf.read_ring_ptr_h = HI(rringp);
		inf.read_ring_ptr_l = LO(rringp);
d1646 18
a1663 19
		inf.write_ring_size = WRING_DATA_SIZE;
		inf.read_ring_size = RRING_DATA_SIZE;
		inf.def_termio.c_iflag = VBRKINT;
		inf.def_termio.c_oflag = 0;
		inf.def_termio.c_cflag = (VB9600 | VCS8);

		inf.def_termio.c_lflag = VISIG; /* enable signal processing */
		inf.def_termio.c_line = 1; /* raw line discipline */
		inf.def_termio.c_cc[0] = CINTR;
		inf.def_termio.c_cc[1] = CQUIT;
		inf.def_termio.c_cc[2] = CERASE;
		inf.def_termio.c_cc[3] = CKILL;
		inf.def_termio.c_cc[4] = 20;
		inf.def_termio.c_cc[5] = 2;
		inf.reserved1 = 0;  /* Must Be Zero */
		inf.reserved2 = 0;
		inf.reserved3 = 0;
		inf.reserved4 = 0;
		d16_bcopy(&inf, infp, sizeof(struct init_info));
d1667 5
a1671 2
	bzero(&init, sizeof(struct packet));
	init.link = 0x12345678;	/* eye catcher */
d1682 4
a1685 2
	bpp_send(sc, &init, WAIT);
	if (init.error_l != 0)
d1687 13
a1699 11

	/* send one event packet to each device */
	for (i = 0; i < NVXPORTS; i++) {
		bzero(&evnt, sizeof(struct packet));
		evnt.command = CMD_EVENT;
		evnt.device_number = i;
		evnt.command_pipe_number = sc->channel_number;
		/* return status on same channel */
		evnt.status_pipe_number = sc->channel_number;
		/* send packet to the firmware */
		bpp_send(sc, &evnt, NOWAIT);
a1700 1
	return 0;
@


1.1.1.6
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.29 2004/04/24 19:51:48 miod Exp $ */
a28 3
/* This card lives in D16 space */
#define	__BUS_SPACE_RESTRICT_D16__

d68 1
a68 1
	vaddr_t		board_addr;
d75 1
d77 1
a155 3
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh;
	int rc;
d157 4
a160 5
	if (bus_space_map(iot, ca->ca_paddr, 0x10000, 0, &ioh) != 0)
		return 0;
	vx_reg = (struct vxreg *)bus_space_vaddr(iot, ioh);
	rc = badvaddr((vaddr_t)&vx_reg->ipc_cr, 1);
	bus_space_unmap(iot, ioh, 0x10000);
d162 1
a162 1
	return rc == 0;
a169 14
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh;

	if (ca->ca_vec < 0) {
		printf(": no more interrupts!\n");
		return;
	}
	if (ca->ca_ipl < 0)
		ca->ca_ipl = IPL_TTY;

	if (bus_space_map(iot, ca->ca_paddr, 0x10000, 0, &ioh) != 0) {
		printf(": can't map registers!\n");
		return;
	}
d172 3
a174 3
	sc->board_addr = (vaddr_t)bus_space_vaddr(iot, ioh);
	sc->vx_reg = (struct vxreg *)sc->board_addr;
	sc->channel = (struct channel *)(sc->board_addr + 0x0100);
d176 1
d194 1
a194 1
	sc->sc_ih_c.ih_ipl = IPL_TTY;
d1239 1
a1239 1
		sc->channel->interrupt_level = IPL_TTY;
d1469 1
a1469 1
	init.interrupt_level = IPL_TTY;
@


