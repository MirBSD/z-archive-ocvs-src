head	1.2;
access;
symbols
	cvs-200405160640:1.1.1.8
	cvs-200401271800:1.1.1.7
	cvs-200401261630:1.1.1.7
	cvs-200401021645:1.1.1.6
	cvs-200312222040:1.1.1.5
	cvs-200310020700:1.1.1.4
	cvs-200309271030:1.1.1.3
	cvs-200309261655:1.1.1.3
	cvs-200309251530:1.1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	cvs-200307072125:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200307021520:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.04.06.04.29.25;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.50.01;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.50.01;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.06.05.17.35.32;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.17.14.31.08;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.10.02.07.39.34;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.22.20.59.53;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.01.02.17.49.37;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.01.26.18.42.15;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.16.08.38.22;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove "some dead architectures".

These are all but i386 and x86-64 (which is not in the tree yet),
because I have no machines to work with.

Re-adding support should be fairly easy, just cvs adding a partial
OpenBSD checkout and pulling in stuff like kernel signal patch, humantime,
etc. which got added to i386 as well.

You will need gcc support as well.
@
text
@/*	$OpenBSD: cl.c,v 1.27 2003/01/13 20:09:19 miod Exp $ */

/*
 * Copyright (c) 1995 Dale Rahn. All rights reserved.
 *
 *   
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */  

/* DMA mode still does not work!!! */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/uio.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/device.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/psl.h>

#include <dev/cons.h>

#include <mvme88k/dev/clreg.h>

#include "cl.h"
#include "pcctwo.h"
#include <mvme88k/dev/pcctworeg.h>

#ifdef	DDB
#include <ddb/db_var.h>
#endif

#define splcl()	spltty()

/* min timeout 0xa, what is a good value */
#define CL_TIMEOUT	0x10
#define CL_FIFO_MAX	0x10
#define CL_FIFO_CNT	0xc
#define	CL_RX_TIMEOUT	0x10

#define CL_RXDMAINT	0x82
#define CL_TXDMAINT	0x42
#define CL_TXMASK	0x47
#define CL_RXMASK	0x87 
#define CL_TXINTR	0x02
#define CL_RXINTR	0x02

#define	CLCD_DO_POLLED_INPUT

#ifdef DEBUG
#undef DEBUG
#endif
struct cl_cons {
	void	*cl_paddr;
	struct clreg *volatile cl_vaddr;
	struct pcctworeg *volatile pcctwoaddr;
	u_char	channel;
} cl_cons;

struct cl_info {
	struct tty *tty;
	u_char	cl_swflags;
	u_char	cl_softchar;
	u_char	cl_consio;
	u_char	cl_speed;
	u_char	cl_parstop;	/* parity, stop bits. */
	u_char	cl_rxmode;
	u_char	cl_txmode;
	u_char	cl_clen;
	u_char	cl_parity;
	u_char  transmitting;
	u_long  txcnt;
	u_long  rxcnt;

	void *rx[2];
	void *rxp[2];
	void *tx[2];
	void *txp[2];
};
#define CLCD_PORTS_PER_CHIP 4
#define CL_BUFSIZE 256

#ifndef DO_MALLOC
/* four (4) buffers per port */
char cl_dmabuf [CLCD_PORTS_PER_CHIP * CL_BUFSIZE * 4];
#endif

struct clsoftc {
	struct device	sc_dev;
	struct evcnt sc_txintrcnt;
	struct evcnt sc_rxintrcnt;
	struct evcnt sc_mxintrcnt;
	time_t	sc_rotime;	/* time of last ring overrun */
	time_t	sc_fotime;	/* time of last fifo overrun */
	u_char *pbase;
	struct clreg *cl_reg;
	struct cl_info		sc_cl[CLCD_PORTS_PER_CHIP];
	struct intrhand		sc_ih_e;
	struct intrhand		sc_ih_m;
	struct intrhand		sc_ih_t;
	struct intrhand		sc_ih_r;
	struct pcctworeg		*sc_pcctwo;
	int			sc_flags;
};
struct {
	u_int speed;
	u_char divisor;
	u_char clock;
	u_char rx_timeout;
} cl_clocks[] = {
	{ 64000, 0x26, 0, 0x01},
	{ 56000, 0x2c, 0, 0x01},
	{ 38400, 0x40, 0, 0x01},
	{ 19200, 0x81, 0, 0x02},
	{  9600, 0x40, 1, 0x04},
	{  7200, 0x56, 1, 0x04},
	{  4800, 0x81, 1, 0x08},
	{  3600, 0xad, 1, 0x08},
	{  2400, 0x40, 2, 0x10},
	{  1200, 0x81, 2, 0x20},
	{   600, 0x40, 3, 0x40},
	{   300, 0x81, 3, 0x80},
	{   150, 0x40, 3, 0x80},
	{   110, 0x58, 4, 0xff},
	{    50, 0xC2, 4, 0xff},
	{     0, 0x00, 0, 0},
};

/* prototypes */
int clcnprobe(struct consdev *cp);
int clcninit(struct consdev *cp);
int cl_instat(struct clsoftc *sc);
int clcngetc(dev_t dev);
void clcnputc(dev_t dev, u_char c);
void clcnpollc(dev_t, int);
u_char cl_clkdiv(int speed);
u_char cl_clknum(int speed);
u_char cl_clkrxtimeout(int speed);
void clstart(struct tty *tp);
void cl_unblock(struct tty *tp);
int clccparam(struct clsoftc *sc, struct termios *par, int channel);

int clparam(struct tty *tp, struct termios *t);
int cl_mintr(void *);
int cl_txintr(void *);
int cl_rxintr(void *);
void cl_overflow(struct clsoftc *sc, int channel, long *ptime, u_char *msg);
void cl_parity(struct clsoftc *sc, int channel);
void cl_frame(struct clsoftc *sc, int channel);
void cl_break( struct clsoftc *sc, int channel);
int clmctl(dev_t dev, int bits, int how);
#ifdef DEBUG
void cl_dumpport(int channel);
#endif

int	clprobe(struct device *parent, void *self, void *aux);
void	clattach(struct device *parent, struct device *self, void *aux);

void cl_initchannel(struct clsoftc *sc, int channel);
void clputc(struct clsoftc *sc, int unit, u_char c);
u_char clgetc(struct clsoftc *sc, int *channel);
#if 0
void cloutput(struct tty *tp);
#endif
#ifdef	CLCD_DO_POLLED_INPUT
void cl_chkinput(void);
#endif

struct cfattach cl_ca = {       
	sizeof(struct clsoftc), clprobe, clattach
};      
  
struct cfdriver cl_cd = {
	NULL, "cl", DV_TTY, 0
}; 

#define CLCDBUF 80

int dopoll = 1;

#define CL_UNIT(x) (minor(x) >> 2)
#define CL_CHANNEL(x) (minor(x) & 3)
#define CL_TTY(x) (minor(x))

struct tty *cltty(dev_t dev);

struct tty *cltty(dev)
	dev_t dev;
{
	int unit, channel;
	struct clsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (NULL);
	}
	channel = CL_CHANNEL(dev);
	return sc->sc_cl[channel].tty;
}

int	
clprobe(parent, self, aux)
	struct device *parent;
	void *self;
	void *aux;
{
	/* probing onboard 166/167/187 CL-cd2400
	 * should be previously configured, 
	 * we can check the value before resetting the chip
	 */
	struct clreg *cl_reg;
	struct confargs *ca = aux;
	
	if (brdtyp == BRD_188)
		return 0;

	ca->ca_ipl = IPL_TTY;
	ca->ca_vaddr = ca->ca_paddr = (void *)CD2400_BASE_ADDR;
	cl_reg = (struct clreg *)ca->ca_vaddr;

	if (badvaddr((vm_offset_t)&cl_reg->cl_gfrcr,1))
		return 0;
	return 1;
}

void
clattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct clsoftc *sc = (struct clsoftc *)self;
	struct confargs *ca = aux;
	int i;

	sc->cl_reg = (struct clreg *)ca->ca_vaddr;
	sc->sc_pcctwo = ca->ca_master;

	if ((u_char *)ca->ca_paddr == (u_char *)cl_cons.cl_paddr) {
		/* if this device is configured as console,
		 * line cl_cons.channel is the console */
		sc->sc_cl[0].cl_consio = 1;
		printf(" console ");
	} else {
		/* reset chip only if we are not console device */
		/* wait for GFRCR */
	}
        /* allow chip to settle before continuing */
        delay(800);

	/* set up global registers */
	sc->cl_reg->cl_tpr = CL_TIMEOUT;
	sc->cl_reg->cl_rpilr = 0x03;
	sc->cl_reg->cl_tpilr = 0x02;
	sc->cl_reg->cl_mpilr = 0x01;

#ifdef DO_MALLOC
	sc->sc_cl[0].rx[0] = (void *)(dvma_malloc(16 * CL_BUFSIZE));
#else
	sc->sc_cl[0].rx[0] = (void *) (&cl_dmabuf);
#endif
	sc->sc_cl[0].rx[1] = (void *)(((int)sc->sc_cl[0].rx[0]) + CL_BUFSIZE);
	sc->sc_cl[1].rx[0] = (void *)(((int)sc->sc_cl[0].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[1].rx[1] = (void *)(((int)sc->sc_cl[1].rx[0]) + CL_BUFSIZE);

	sc->sc_cl[2].rx[0] = (void *)(((int)sc->sc_cl[1].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[2].rx[1] = (void *)(((int)sc->sc_cl[2].rx[0]) + CL_BUFSIZE);
	sc->sc_cl[3].rx[0] = (void *)(((int)sc->sc_cl[2].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[3].rx[1] = (void *)(((int)sc->sc_cl[3].rx[0]) + CL_BUFSIZE);

	sc->sc_cl[0].tx[0] = (void *)(((int)sc->sc_cl[3].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[0].tx[1] = (void *)(((int)sc->sc_cl[0].tx[0]) + CL_BUFSIZE);
	sc->sc_cl[1].tx[0] = (void *)(((int)sc->sc_cl[0].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[1].tx[1] = (void *)(((int)sc->sc_cl[1].tx[0]) + CL_BUFSIZE);

	sc->sc_cl[2].tx[0] = (void *)(((int)sc->sc_cl[1].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[2].tx[1] = (void *)(((int)sc->sc_cl[2].tx[0]) + CL_BUFSIZE);
	sc->sc_cl[3].tx[0] = (void *)(((int)sc->sc_cl[2].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[3].tx[1] = (void *)(((int)sc->sc_cl[3].tx[0]) + CL_BUFSIZE);
	for (i = 0; i < CLCD_PORTS_PER_CHIP; i++) {
#if 0
		int j;

		for (j = 0; j < 2 ; j++) {
			sc->sc_cl[i].rxp[j] = (void *)kvtop(sc->sc_cl[i].rx[j]);
			printf("cl[%d].rxbuf[%d] %x p %x\n",
			    i, j, sc->sc_cl[i].rx[j], sc->sc_cl[i].rxp[j]);
			sc->sc_cl[i].txp[j] = (void *)kvtop(sc->sc_cl[i].tx[j]);
			printf("cl[%d].txbuf[%d] %x p %x\n",
			    i, j, sc->sc_cl[i].tx[j], sc->sc_cl[i].txp[j]);
		}
#endif
#if 0
		sc->sc_cl[i].cl_rxmode =
			!(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x01));
		sc->sc_cl[i].cl_txmode =
			!(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x02));
		sc->sc_cl[i].cl_softchar =
			!(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x04));
#endif
		cl_initchannel(sc, i);
	}
	/* enable interrupts */
	sc->sc_ih_e.ih_fn = cl_rxintr;
	sc->sc_ih_e.ih_arg = sc;
	sc->sc_ih_e.ih_wantframe = 0;
	sc->sc_ih_e.ih_ipl = ca->ca_ipl;

	sc->sc_ih_m.ih_fn = cl_mintr;
	sc->sc_ih_m.ih_arg = sc;
	sc->sc_ih_e.ih_wantframe = 0;
	sc->sc_ih_m.ih_ipl = ca->ca_ipl;

	sc->sc_ih_t.ih_fn = cl_txintr;
	sc->sc_ih_t.ih_arg = sc;
	sc->sc_ih_e.ih_wantframe = 0;
	sc->sc_ih_t.ih_ipl = ca->ca_ipl;

	sc->sc_ih_r.ih_fn = cl_rxintr;
	sc->sc_ih_r.ih_arg = sc;
	sc->sc_ih_e.ih_wantframe = 0;
	sc->sc_ih_r.ih_ipl = ca->ca_ipl;
	dopoll = 0;
	intr_establish(PCC2_VECT + SRXEIRQ, &sc->sc_ih_e);
	intr_establish(PCC2_VECT + SMOIRQ, &sc->sc_ih_m);
	intr_establish(PCC2_VECT + STxIRQ, &sc->sc_ih_t);
	intr_establish(PCC2_VECT + SRxIRQ, &sc->sc_ih_r);
	sc->sc_pcctwo = ca->ca_master;
	sc->sc_pcctwo->pcc2_sccerr = 0x01; /* clear errors */

	/* enable all interrupts at ca_ipl */
	sc->sc_pcctwo->pcc2_sccirq = 0x10 | (ca->ca_ipl & 0x7);
	sc->sc_pcctwo->pcc2_scctx  = 0x10 | (ca->ca_ipl & 0x7);
	sc->sc_pcctwo->pcc2_sccrx  = 0x10 | (ca->ca_ipl & 0x7);

	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_txintrcnt);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_rxintrcnt);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_mxintrcnt);
	printf("\n");
}

void
cl_initchannel(sc, channel)
	struct clsoftc *sc;
	int channel;
{
	int s;
	struct clreg *cl_reg = sc->cl_reg;
	/* set up option registers */
	sc->sc_cl[channel].tty = NULL;
	s = splhigh();
	cl_reg->cl_car	= (u_char) channel;
	cl_reg->cl_livr	= PCC2_VECT + 0xc;/* set vector base at 5C */
	cl_reg->cl_ier	= 0x00;
	/* if the port is not the console, should be init for all ports??*/
	if (sc->sc_cl[channel].cl_consio != 1) {
		cl_reg->cl_cmr	= 0x02; 
		cl_reg->cl_cor1	= 0x17;
		cl_reg->cl_cor2	= 0x00;
		cl_reg->cl_cor3	= 0x02;
		cl_reg->cl_cor4	= 0xec;
		cl_reg->cl_cor5	= 0xec;
		cl_reg->cl_cor6	= 0x00;
		cl_reg->cl_cor7	= 0x00;
		cl_reg->cl_schr1	= 0x00;
		cl_reg->cl_schr2	= 0x00;
		cl_reg->cl_schr3	= 0x00;
		cl_reg->cl_schr4	= 0x00;
		cl_reg->cl_scrl	= 0x00;
		cl_reg->cl_scrh	= 0x00;
		cl_reg->cl_lnxt	= 0x00;
		cl_reg->cl_rbpr	= 0x40; /* 9600 */
		cl_reg->cl_rcor	= 0x01;
		cl_reg->cl_tbpr	= 0x40; /* 9600 */
		cl_reg->cl_tcor	= 0x01 << 5;
		/* console port should be 0x88 already */
		cl_reg->cl_msvr_rts	= 0x00;
		cl_reg->cl_msvr_dtr	= 0x00;
		cl_reg->cl_rtprl	= CL_RX_TIMEOUT;
		cl_reg->cl_rtprh	= 0x00;
	}
	sc->cl_reg->cl_ccr = 0x20;
	while (sc->cl_reg->cl_ccr != 0) {
	}

	splx(s);
}


int cldefaultrate = TTYDEF_SPEED;

int
clmctl(dev, bits, how)
	dev_t dev;
	int bits;
	int how;
{
	int s;
	struct clsoftc *sc;
	/* should only be called with valid device */
	sc = (struct clsoftc *) cl_cd.cd_devs[CL_UNIT(dev)];
	/*
	printf("mctl: dev %x, bits %x, how %x,\n",dev, bits, how);
	*/
	/* settings are currently ignored */
	s = splcl();
	switch (how) {
	case DMSET:
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x01;
		} else {
			sc->cl_reg->cl_msvr_rts = 0x00;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x02;
		} else {
			sc->cl_reg->cl_msvr_dtr = 0x00;
		}
		break;

	case DMBIC:
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x00;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x00;
		}
		break;

	case DMBIS:
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x01;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x02;
		}
		break;

	case DMGET:
		bits = 0;

		{
			u_char msvr;
			msvr = sc->cl_reg->cl_msvr_rts;
			if( msvr & 0x80) {
				bits |= TIOCM_DSR;
			}
			if( msvr & 0x40) {
				bits |= TIOCM_CD;
			}
			if( msvr & 0x20) {
				bits |= TIOCM_CTS;
			}
			if( msvr & 0x10) {
				bits |= TIOCM_DTR;
			}
			if( msvr & 0x02) {
				bits |= TIOCM_DTR;
			}
			if( msvr & 0x01) {
				bits |= TIOCM_RTS;
			}
			
		}
		break;
	}
	splx(s);
#if 0
	bits = 0;
	/* proper defaults? */
	bits |= TIOCM_DTR;
	bits |= TIOCM_RTS;
	bits |= TIOCM_CTS;
	bits |= TIOCM_CD;
	/*	bits |= TIOCM_RI; */
	bits |= TIOCM_DSR;
#endif

	/*
	printf("retbits %x\n", bits);
	*/
	return(bits);
}

int
clopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int s, unit, channel;
	struct cl_info *cl;
	struct clsoftc *sc;
	struct tty *tp;
	
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	s = splcl();
	if (cl->tty) {
		tp = cl->tty;
	} else {
		tp = cl->tty = ttymalloc();
/*		tty_attach(tp);*/  
	}
	tp->t_oproc = clstart;
	tp->t_param = clparam;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			/*
			 * only when cleared do we reset to defaults.
			 */
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = cldefaultrate;

			if(sc->sc_cl[channel].cl_consio == 1) {
				/* console is 8N1 */
				tp->t_cflag = (CREAD | CS8 | HUPCL);
			} else {
				tp->t_cflag = TTYDEF_CFLAG;
			}
		}
		/*
		 * do these all the time
		 */
		if (cl->cl_swflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (cl->cl_swflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (cl->cl_swflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;
		clparam(tp, &tp->t_termios);
		ttsetwater(tp);

		(void)clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
#ifdef XXX
		if ((cl->cl_swflags & TIOCFLAG_SOFTCAR) ||
			(clmctl(dev, 0, DMGET) & TIOCM_CD)) {
			tp->t_state |= TS_CARR_ON;
		} else {
			tp->t_state &= ~TS_CARR_ON;
		}
#endif
		tp->t_state |= TS_CARR_ON;
		{
			u_char save = sc->cl_reg->cl_car;
			sc->cl_reg->cl_car = channel;
			sc->cl_reg->cl_ier	= 0x88;
#ifdef CL_DMA_WORKS
			{
			sc->cl_reg->cl_cmr	=
				/* CL_TXDMAINT | */ CL_RXDMAINT; 
			sc->cl_reg->cl_ier	= 0xa8;
			sc->cl_reg->cl_licr	= 0x00;
			}
			sc->cl_reg->cl_arbadrl	=
				((u_long)sc->sc_cl[channel].rxp[0]) & 0xffff;
			sc->cl_reg->cl_arbadru	=
				((u_long)sc->sc_cl[channel].rxp[0]) >> 16;
			sc->cl_reg->cl_brbadrl	=
				((u_long)sc->sc_cl[channel].rxp[1]) & 0xffff;
			sc->cl_reg->cl_brbadru	=
				((u_long)sc->sc_cl[channel].rxp[1]) >> 16;
			sc->cl_reg->cl_atbadrl	=
				((u_long)sc->sc_cl[channel].txp[0]) & 0xffff;
			sc->cl_reg->cl_atbadru	=
				((u_long)sc->sc_cl[channel].txp[0]) >> 16;
			sc->cl_reg->cl_btbadrl	=
				((u_long)sc->sc_cl[channel].txp[1]) & 0xffff;
			sc->cl_reg->cl_btbadru	=
				((u_long)sc->sc_cl[channel].txp[1]) >> 16;
			sc->cl_reg->cl_arbcnt	= CL_BUFSIZE;
			sc->cl_reg->cl_brbcnt	= CL_BUFSIZE;
			sc->cl_reg->cl_arbsts	= 0x01;
			sc->cl_reg->cl_brbsts	= 0x01;
if (channel == 2) { /* test one channel now */
			/* shift for tx DMA */
			/* no shift for rx DMA */
#if 0
			/* tx only */
			sc->cl_reg->cl_licr	= (CL_DMAMODE << 4);
			sc->cl_reg->cl_cmr	= 0x42; 
#endif
		/* rx only */
			sc->cl_reg->cl_licr	= 0x00;
			sc->cl_reg->cl_cmr	= 0x82; 
}
			sc->cl_reg->cl_ccr = 0x20;
			while (sc->cl_reg->cl_ccr != 0) {
			}
#endif /* CL_DMA_WORKS */
			sc->cl_reg->cl_car = save;
		}
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
		splx(s);
		return(EBUSY);
	}
#ifdef XXX
	/*
	 * if NONBLOCK requested, ignore carrier
	 */
	if (flag & O_NONBLOCK)
	goto done;
#endif

	splx(s);
	/*
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
	 */
	tp->t_dev = dev;
#ifdef DEBUG
	cl_dumpport(channel);
#endif
	return((*linesw[tp->t_line].l_open)(dev, tp));
}

int
clparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	int unit, channel;
	struct clsoftc *sc;
	int s;
	dev_t dev;

	dev = tp->t_dev;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	clccparam(sc, t, channel);
	s = splcl();
	cl_unblock(tp);
	splx(s);
	return 0;
}

#if 0
void
cloutput(tp)
	struct tty *tp;
{
	int cc, s, unit, cnt;
	u_char *tptr;
	int channel;
	struct clsoftc *sc;
	dev_t dev;
	u_char cl_obuffer[CLCDBUF+1];

	dev = tp->t_dev;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return;
	}
	channel = CL_CHANNEL(dev);

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = splcl();
	cc = tp->t_outq.c_cc;
	while (cc > 0) {
/*XXX*/
		cnt = min (CLCDBUF,cc);
		cnt = q_to_b(&tp->t_outq, cl_obuffer, cnt);
		if (cnt == 0) {
			break;
		}
		for (tptr = cl_obuffer; tptr < &cl_obuffer[cnt]; tptr++) {
			clputc(sc, channel, *tptr);
		}
		cc -= cnt;
	}
	splx(s);
}
#endif

int
clclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	int s;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	(*linesw[tp->t_line].l_close)(tp, flag);

	s = splcl();
	
	sc->cl_reg->cl_car = channel;
	if(cl->cl_consio == 0 && (tp->t_cflag & HUPCL) != 0) {
		sc->cl_reg->cl_msvr_rts = 0x00;
		sc->cl_reg->cl_msvr_dtr = 0x00;
		sc->cl_reg->cl_ccr = 0x05;
	}

	splx(s);
	ttyclose(tp);

#if 0
	cl->tty = NULL;
#endif
#ifdef DEBUG
	cl_dumpport(channel);
#endif

	return 0;
}

int
clread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (!tp)
		return ENXIO;
	return((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
clwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (!tp)
		return ENXIO;
	return((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

int
clioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int error;
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (!tp)
		return ENXIO;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return(error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return(error);

	switch (cmd) {
	case TIOCSBRK:
		/* */
		break;

	case TIOCCBRK:
		/* */
		break;

	case TIOCSDTR:
		(void) clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) clmctl(dev, *(int *) data, DMSET);
		break;

	case TIOCMBIS:
		(void) clmctl(dev, *(int *) data, DMBIS);
		break;

	case TIOCMBIC:
		(void) clmctl(dev, *(int *) data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = clmctl(dev, 0, DMGET);
		break;
	case TIOCGFLAGS:
		*(int *)data = cl->cl_swflags;
		break;
	case TIOCSFLAGS:
		error = suser(p->p_ucred, &p->p_acflag); 
		if (error != 0)
			return(EPERM); 

		cl->cl_swflags = *(int *)data;
		cl->cl_swflags &= /* only allow valid flags */
			(TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
		break;
	default:
		return(ENOTTY);
	}

	return 0;
}

int
clstop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = splcl();
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return 0;
}

/*
 * clcn* stuff happens before configure() runs kicking off
 * autoconfig. Use a virtual mapping set up in locore till
 * the device is actually configured. Need mappings for
 * pcc2 space and Cirrus chip area.
 */

int
clcnprobe(cp)
	struct consdev *cp;
{
	/* always there ? */
	/* serial major */
	int maj;

	/* bomb if it'a a MVME188 */
	if (brdtyp == BRD_188) {
		cp->cn_pri = CN_DEAD;
		return 0;
	}
	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == clopen)
			break;
	cp->cn_dev = makedev (maj, 0);
	cp->cn_pri = CN_NORMAL;

	return 1;
}

int
clcninit(cp)
	struct consdev *cp;
{
	struct clreg *volatile cl_reg;
	
	cl_cons.cl_paddr = (void *)CD2400_BASE_ADDR;
	cl_cons.cl_vaddr   = (struct clreg *)IIOV(cl_cons.cl_paddr);
	cl_cons.pcctwoaddr = (void *)IIOV(0xfff42000);
	cl_reg = cl_cons.cl_vaddr;
	/* reset the chip? */
#ifdef CLCD_DO_RESET
#endif
	/* set up globals */
#ifdef NOT_ALREADY_SETUP
	cl_reg->cl_tftc  = 0x10;
	cl_reg->cl_tpr   = CL_TIMEOUT; /* is this correct?? */
	cl_reg->cl_rpilr = 0x03;
	cl_reg->cl_tpilr = 0x02;
	cl_reg->cl_mpilr = 0x01;

	/* set up the tty00 to be 9600 8N1 */
	cl_reg->cl_car   = 0x00;
	cl_reg->cl_cor1  = 0x17;	/* No parity, ignore parity, 8 bit char */
	cl_reg->cl_cor2  = 0x00;
	cl_reg->cl_cor3  = 0x02;	/* 1 stop bit */
	cl_reg->cl_cor4  = 0x00;
	cl_reg->cl_cor5  = 0x00;
	cl_reg->cl_cor6  = 0x00;
	cl_reg->cl_cor7  = 0x00;
	cl_reg->cl_schr1 = 0x00;
	cl_reg->cl_schr2 = 0x00;
	cl_reg->cl_schr3 = 0x00;
	cl_reg->cl_schr4 = 0x00;
	cl_reg->cl_scrl  = 0x00;
	cl_reg->cl_scrh  = 0x00;
	cl_reg->cl_lnxt  = 0x00;
	cl_reg->cl_cpsr  = 0x00;
#endif
	return 0;
}

int
cl_instat(sc)
	struct clsoftc *sc;
{
	struct clreg *volatile cl_reg;
	if ( NULL == sc) {
		cl_reg = cl_cons.cl_vaddr;
	} else {
		cl_reg = sc->cl_reg;
	}
	return (cl_reg->cl_rir & 0x40);
}

int
clcngetc(dev)
	dev_t dev;
{
	u_char val, reoir, licr, isrl, data = 0, fifo_cnt;
#if 0
	u_char status;
#endif
	int got_char = 0;
	u_char ier_old = 0xff;
	struct clreg *volatile cl_reg = cl_cons.cl_vaddr;
	struct pcctworeg *volatile pcc2_base = cl_cons.pcctwoaddr;
	cl_reg->cl_car = 0;
	if (!(cl_reg->cl_ier & 0x08)) {
		ier_old = cl_reg->cl_ier;
		cl_reg->cl_ier	= 0x08;
	}

	while (got_char == 0) {
		val = cl_reg->cl_rir;
		/* if no receive interrupt pending wait */
		if (!(val & 0x80)) {
			continue;
		}
		/* XXX do we need to suck the entire FIFO contents? */
		reoir = pcc2_base->pcc2_sccrxiack; /* receive PIACK */
		licr = cl_reg->cl_licr;
		if (((licr >> 2) & 0x3) == 0) {
			/* is the interrupt for us (port 0) */
			/* the character is for us yea. */
			isrl = cl_reg->cl_risrl;
#if 0
			if (isrl & 0x01) {
				status = BREAK;
			}
			if (isrl & 0x02) {
				status = FRAME;
			}
			if (isrl & 0x04) {
				status = PARITY;
			}
			if (isrl & 0x08) {
				status = OVERFLOW;
			}
			/* we do not have special characters ;-) */
#endif
			fifo_cnt = cl_reg->cl_rfoc;
			data = cl_reg->cl_rdr;
			if (ier_old != 0xff) {
				cl_reg->cl_ier  = ier_old;
			}
			got_char = 1;
			cl_reg->cl_teoir = 0x00;
		} else {
			data = cl_reg->cl_rdr;
			cl_reg->cl_teoir = 0x00;
		}
	}
	
	return data;
}

void
clcnputc(dev, c)
	dev_t dev;
	u_char c;
{
	clputc(0, 0, c);
}

void
clcnpollc(dev, on)
	dev_t dev;
	int on;
{
	if (1 == on) {
		/* enable polling */
	} else {
		/* disable polling */
	}
	return;
}

void
clputc(sc, unit, c)
	struct clsoftc *sc;
	int unit;
	u_char c;
{
	int s;
	u_char schar;
	u_char oldchannel;
	struct clreg *volatile cl_reg;
	if (0 == sc) {
		/* output on console */
		cl_reg = cl_cons.cl_vaddr;
	} else {
		cl_reg = sc->cl_reg;
	}
#ifdef NEW_CLCD_STRUCT
	/* should we disable, flush and all that goo? */
	cl->car = unit;
	schar = cl->schr3;
	cl->schr3 = c;
	cl->stcr = 0x08 | 0x03; /* send special char, char 3 */
	while (0 != cl->stcr) {
		/* wait until cl notices the command
		 * otherwise it may not notice the character
		 * if we send characters too fast.
		 */
	}
	cl->schr3 = schar;
#else
	if (unit == 0) {
		s = splhigh();
		oldchannel = cl_reg->cl_car;
		cl_reg->cl_car = unit;
		schar = cl_reg->cl_schr3;
		cl_reg->cl_schr3 = c;
		cl_reg->cl_stcr = 0x08 | 0x03; /* send special char, char 3 */
		while (0 != cl_reg->cl_stcr) {
			/* wait until cl notices the command
			 * otherwise it may not notice the character
			 * if we send characters too fast.
			 */
		}
		DELAY(5);
		cl_reg->cl_schr3 = schar;
		cl_reg->cl_car = oldchannel;
		splx(s);
	} else {
		s = splhigh();
		oldchannel = cl_reg->cl_car;
		cl_reg->cl_car = unit;
		if (cl_reg->cl_tftc > 0) {
			cl_reg->cl_tdr = c;
		}
		cl_reg->cl_car = oldchannel;
		splx(s);
	}
#endif
	return;
}

#ifdef CLCD_DO_POLLED_INPUT
void
cl_chkinput()
{
	struct tty *tp;
	int unit;
	struct clsoftc *sc;
	int channel;

	if (dopoll == 0)
		return;
	for (unit = 0; unit < cl_cd.cd_ndevs; unit++) {
		if (unit >= cl_cd.cd_ndevs || 
			(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
			continue;
		}
		if (cl_instat(sc)) {
			while (cl_instat(sc)){
				int ch;
				u_char c;
				/*
				*(pinchar++) = clcngetc();
				*/
				ch = clgetc(sc,&channel) & 0xff;
				c = ch;

				tp = sc->sc_cl[channel].tty;
				if (NULL != tp) {
					(*linesw[tp->t_line].l_rint)(c,tp);
				}
			}
			/*
			wakeup(tp);
			*/
		}
	}
}
#endif

u_char 
clgetc(sc, channel)
	struct clsoftc *sc;
	int *channel;
{
	struct clreg *volatile cl_reg;
	struct pcctworeg *volatile pcc2_base;
	u_char val, reoir, licr, isrl, fifo_cnt, data;
	if (0 == sc) {
		cl_reg = cl_cons.cl_vaddr;
		pcc2_base = cl_cons.pcctwoaddr;
	} else {
		cl_reg = sc->cl_reg;
		pcc2_base = sc->sc_pcctwo;
	}
	val = cl_reg->cl_rir;
	/* if no receive interrupt pending wait */
	if (!(val & 0x80)) {
		return 0;
	}
	/* XXX do we need to suck the entire FIFO contents? */
	reoir = pcc2_base->pcc2_sccrxiack; /* receive PIACK */
	licr = cl_reg->cl_licr;
	*channel = (licr >> 2) & 0x3;
	/* is the interrupt for us (port 0) */
	/* the character is for us yea. */
	isrl = cl_reg->cl_risrl;
#if 0
	if (isrl & 0x01) {
		status = BREAK;
	}
	if (isrl & 0x02) {
		status = FRAME;
	}
	if (isrl & 0x04) {
		status = PARITY;
	}
	if (isrl & 0x08) {
		status = OVERFLOW;
	}
	/* we do not have special characters ;-) */
#endif
	fifo_cnt = cl_reg->cl_rfoc;
	if (fifo_cnt > 0) {
		data = cl_reg->cl_rdr;
		cl_reg->cl_teoir = 0x00;
	} else {
		data = 0;
		cl_reg->cl_teoir = 0x08;
	}
	return data;
}

int
clccparam(sc, par, channel)
	struct clsoftc *sc;
	struct termios *par;
	int channel;
{
	u_int divisor, clk, clen;
	int s, imask, ints;

	s = splcl();
	sc->cl_reg->cl_car = channel;
	if (par->c_ospeed == 0) { 
		/* dont kill the console */
		if(sc->sc_cl[channel].cl_consio == 0) {
			/* disconnect, drop RTS DTR stop receiver */
			sc->cl_reg->cl_msvr_rts = 0x00;
			sc->cl_reg->cl_msvr_dtr = 0x00;
			sc->cl_reg->cl_ccr = 0x05;
		}
		splx(s);
		return (0xff);
	}

	sc->cl_reg->cl_msvr_rts = 0x03;
	sc->cl_reg->cl_msvr_dtr = 0x03;

	divisor = cl_clkdiv(par->c_ospeed);
	clk	= cl_clknum(par->c_ospeed);
	sc->cl_reg->cl_tbpr = divisor;
	sc->cl_reg->cl_tcor = clk << 5;
	divisor = cl_clkdiv(par->c_ispeed);
	clk	= cl_clknum(par->c_ispeed);
	sc->cl_reg->cl_rbpr = divisor;
	sc->cl_reg->cl_rcor = clk;
	sc->cl_reg->cl_rtprl = cl_clkrxtimeout(par->c_ispeed);
	sc->cl_reg->cl_rtprh = 0x00;

	switch (par->c_cflag & CSIZE) {
	case CS5:
		clen = 4; /* this is the mask for the chip. */
		imask = 0x1F;
		break;
	case CS6:
		clen = 5;
		imask = 0x3F;
		break;
	case CS7:
		clen = 6;
		imask = 0x7F;
		break;
	default:
		clen = 7;
		imask = 0xFF;
	}
	sc->cl_reg->cl_cor3 = par->c_cflag & PARENB ? 4 : 2;

	{
		u_char cor1;
		if (par->c_cflag & PARENB) {
			if (par->c_cflag & PARODD) {
				cor1 = 0xE0 | clen ; /* odd */
			} else {
				cor1 = 0x40 | clen ; /* even */
			}
		} else {
			cor1 = 0x10 | clen; /* ignore parity */
		}
		if (sc->cl_reg->cl_cor1 != cor1) { 
			sc->cl_reg->cl_cor1 = cor1;
			sc->cl_reg->cl_ccr = 0x20;
			while (sc->cl_reg->cl_ccr != 0) {
			}
		}
	}

	if (sc->sc_cl[channel].cl_consio == 0
		&& (par->c_cflag & CREAD) == 0 )
	{
		sc->cl_reg->cl_ccr = 0x08;
	} else {
		sc->cl_reg->cl_ccr = 0x0a;
	}
	while (sc->cl_reg->cl_ccr != 0) {
	}
	ints = 0;
#define SCC_DSR 0x80
#define SCC_DCD 0x40
#define SCC_CTS 0x20
	if ((par->c_cflag & CLOCAL) == 0) {
		ints |= SCC_DCD;
	}
	if ((par->c_cflag & CCTS_OFLOW) != 0) {
		ints |= SCC_CTS;
	}
	if ((par->c_cflag & CRTSCTS) != 0) {
		ints |= SCC_CTS;
	}
#ifdef DONT_LET_HARDWARE
	if ((par->c_cflag & CCTS_IFLOW) != 0) {
		ints |= SCC_DSR;
	}
#endif
	sc->cl_reg->cl_cor4 = ints | CL_FIFO_CNT;
	sc->cl_reg->cl_cor5 = ints | CL_FIFO_CNT;

	splx(s);
	return imask;
}

static int clknum = 0;

u_char 
cl_clkdiv(speed)
	int speed;
{
	int i = 0;
	if (cl_clocks[clknum].speed == speed) {
		return cl_clocks[clknum].divisor;
	}
	for  (i = 0; cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[i].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].divisor;
		}
	}
	/* return some sane value if unknown speed */
	return cl_clocks[4].divisor;
}

u_char 
cl_clknum(speed)
	int speed;
{
	int found = 0;
	int i = 0;
	if (cl_clocks[clknum].speed == speed) {
		return cl_clocks[clknum].clock;
	}
	for  (i = 0; found != 0 && cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[clknum].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].clock;
		}
	}
	/* return some sane value if unknown speed */
	return cl_clocks[4].clock;
}

u_char 
cl_clkrxtimeout(speed)
	int speed;
{
	int i = 0;
	if (cl_clocks[clknum].speed == speed) {
		return cl_clocks[clknum].rx_timeout;
	}
	for  (i = 0; cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[i].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].rx_timeout;
		}
	}
	/* return some sane value if unknown speed */
	return cl_clocks[4].rx_timeout;
}

void
cl_unblock(tp)
	struct tty *tp;
{
	tp->t_state &= ~TS_FLUSH;
	if (tp->t_outq.c_cc != 0)
		clstart(tp);
}

void
clstart(tp)
	struct tty *tp;
{
	dev_t dev;
	struct clsoftc *sc;
	int channel, unit, s;
#if 0
	int cnt;
	u_char cbuf;
#endif

	dev = tp->t_dev;
	channel = CL_CHANNEL(dev);
/* hack to test output on non console only */
#if 0
	if (channel == 0) {
		cloutput(tp);
		return;
	}
#endif
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return;
	}

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = splcl();
#if 0
	if (sc->sc_cl[channel].transmitting == 1) {
		/* i'm busy, go away, I will get to it later. */
		splx(s);
		return;
	}
	cnt = q_to_b(&tp->t_outq, &cbuf, 1);
	if ( cnt != 0 ) {
		sc->sc_cl[channel].transmitting = 1;
		sc->cl_reg->cl_car = channel;
		sc->cl_reg->cl_tdr = cbuf;
	} else {
		sc->sc_cl[channel].transmitting = 0;
	}
#else
	if ((tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP | TS_FLUSH)) == 0)
	{
		tp->t_state |= TS_BUSY;
		sc->cl_reg->cl_car = channel;
		sc->cl_reg->cl_ier = sc->cl_reg->cl_ier | 0x3;
	}
#endif
	splx(s);
	return;
}

int
cl_mintr(arg)
	void *arg;
{
	struct clsoftc *sc = arg;

	u_char mir, misr, msvr;
	int channel;

	if(((mir = sc->cl_reg->cl_mir) & 0x40) == 0x0) {
		/* only if intr is not shared? */
		log(LOG_WARNING, "cl_mintr extra intr\n");
		return 0;
	}
	sc->sc_mxintrcnt.ev_count++;

	channel = mir & 0x03;
	misr = sc->cl_reg->cl_misr;
	msvr = sc->cl_reg->cl_msvr_rts;
	if (misr & 0x01) {
		/* timers are not currently used?? */
		log(LOG_WARNING, "cl_mintr: channel %x timer 1 unexpected\n",channel);
	}
	if (misr & 0x02) {
		/* timers are not currently used?? */
		log(LOG_WARNING, "cl_mintr: channel %x timer 2 unexpected\n",channel);
	}
	if (misr & 0x20) {
		log(LOG_WARNING, "cl_mintr: channel %x cts %x\n",channel, 
		((msvr & 0x20) != 0x0)
		);
	}
	if (misr & 0x40) {
		struct tty *tp = sc->sc_cl[channel].tty;
		log(LOG_WARNING, "cl_mintr: channel %x cd %x\n",channel,
		((msvr & 0x40) != 0x0)
		);
		ttymodem(tp, ((msvr & 0x40) != 0x0) );
	}
	if (misr & 0x80) {
		log(LOG_WARNING, "cl_mintr: channel %x dsr %x\n",channel,
		((msvr & 0x80) != 0x0)
		);
	}
	sc->cl_reg->cl_meoir = 0x00;
	return 1;
}

int
cl_txintr(arg)
	void *arg;
{
	struct clsoftc *sc = arg;

	static int empty = 0;
	u_char tir, cmr, teoir;
	u_char max;
	int channel;
	struct tty *tp;
	int cnt;
	u_char buffer[CL_FIFO_MAX +1];
	u_char *tptr;
	if (((tir = sc->cl_reg->cl_tir) & 0x40) == 0x0) {
		/* only if intr is not shared ??? */
		log(LOG_WARNING, "cl_txintr extra intr\n");
		return 0;
	}
	sc->sc_txintrcnt.ev_count++;

	channel = tir & 0x03;
	cmr     = sc->cl_reg->cl_cmr;

	sc->sc_cl[channel].txcnt ++;

	tp = sc->sc_cl[channel].tty;
	if (tp == NULL || (tp->t_state & TS_ISOPEN) == 0) {
		sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
		sc->cl_reg->cl_teoir = 0x08;
		return 1;
	}
	switch (cmr & CL_TXMASK) {
	case CL_TXDMAINT:
		{
			u_char dmabsts;
			int nbuf, busy, resid;
			void *pbuffer;
			dmabsts = sc->cl_reg->cl_dmabsts;
			log(LOG_WARNING, "cl_txintr: DMAMODE channel %x dmabsts %x\n",
			    channel, dmabsts);
			nbuf = ((dmabsts & 0x8) >> 3) & 0x1;
			busy = ((dmabsts & 0x4) >> 2) & 0x1;

			do {
				pbuffer = sc->sc_cl[channel].tx[nbuf];
				resid = tp->t_outq.c_cc;
				cnt = min (CL_BUFSIZE,resid);
				log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %x\n",
				    resid, cnt, pbuffer);
				if (cnt != 0) {
					cnt = q_to_b(&tp->t_outq, pbuffer, cnt);
					resid -= cnt;
					if (nbuf == 0) {
						sc->cl_reg->cl_atbadru =
						((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
						sc->cl_reg->cl_atbadrl =
						((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
						sc->cl_reg->cl_atbcnt = cnt;
						sc->cl_reg->cl_atbsts = 0x43;
					} else {
						sc->cl_reg->cl_btbadru =
						((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
						sc->cl_reg->cl_btbadrl =
						((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
						sc->cl_reg->cl_btbcnt = cnt;
						sc->cl_reg->cl_btbsts = 0x43;
					}
					teoir = 0x08;
				} else {
					teoir = 0x08;
					if (tp->t_state & TS_BUSY) {
						tp->t_state &= ~(TS_BUSY | TS_FLUSH);
						if (tp->t_state & TS_ASLEEP) {
							tp->t_state &= ~TS_ASLEEP;
							wakeup((caddr_t) &tp->t_outq);
						}
						selwakeup(&tp->t_wsel);
					}
					sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
				}
				nbuf = ~nbuf & 0x1;
				busy--;
			} while (resid != 0 && busy != -1);/* if not busy do other buffer */
			log(LOG_WARNING, "cl_txintr: done\n");
		}
		break;
	case CL_TXINTR:
		max = sc->cl_reg->cl_tftc;
		cnt = min ((int)max,tp->t_outq.c_cc);
		if (cnt != 0) {
			cnt = q_to_b(&tp->t_outq, buffer, cnt);
			empty = 0;
			for (tptr = buffer; tptr < &buffer[cnt]; tptr++) {
				sc->cl_reg->cl_tdr = *tptr;
			}
			teoir = 0x00;
		} else {
			if (empty > 5 && ((empty % 20000 )== 0)) {
				log(LOG_WARNING, "cl_txintr to many empty intr %d channel %d\n",
				    empty, channel);
			}
			empty++;
			teoir = 0x08;
			if (tp->t_state & TS_BUSY) {
				tp->t_state &= ~(TS_BUSY | TS_FLUSH);
				if (tp->t_state & TS_ASLEEP) {
					tp->t_state &= ~TS_ASLEEP;
					wakeup((caddr_t) &tp->t_outq);
				}
				selwakeup(&tp->t_wsel);
			}
			sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
		}
		break;
	default:
		log(LOG_WARNING, "cl_txintr unknown mode %x\n", cmr);
		/* we probably will go to hell quickly now */
		teoir = 0x08;
	}
	sc->cl_reg->cl_teoir = teoir;
	return 1;
}

int
cl_rxintr(arg)
	void *arg;
{
	struct clsoftc *sc = arg;

	u_char rir, channel, cmr, risrl;
	u_char fifocnt;
	struct tty *tp;
	int i;
	u_char reoir;
	u_char buffer[CL_FIFO_MAX +1];
	
	rir = sc->cl_reg->cl_rir;
	if((rir & 0x40) == 0x0) {
		/* only if intr is not shared ??? */
		log(LOG_WARNING, "cl_rxintr extra intr\n");
		return 0;
	}
	sc->sc_rxintrcnt.ev_count++;
	channel = rir & 0x3;
	cmr = sc->cl_reg->cl_cmr;
	reoir = 0x08;

	sc->sc_cl[channel].rxcnt ++;
	risrl = sc->cl_reg->cl_risrl;
	if (risrl & 0x80) {
		/* timeout, no characters */
		reoir = 0x08;
	} else
	/* We don't need no sinkin special characters */
	if (risrl & 0x08) {
		cl_overflow (sc, channel, (long *)&sc->sc_fotime, "fifo");
		reoir = 0x08;
	} else
	if (risrl & 0x04) {
		cl_parity(sc, channel);
		reoir = 0x08;
	} else
	if (risrl & 0x02) {
		cl_frame(sc, channel);
		reoir = 0x08;
	} else
	if (risrl & 0x01) {
		cl_break(sc, channel);
		reoir = 0x08;
	}

	switch (cmr & CL_RXMASK) {
	case CL_RXDMAINT:
		{
			int nbuf;
			u_short cnt;
			int bufcomplete;
			u_char status, dmabsts;
			u_char risrh = sc->cl_reg->cl_risrh;
			dmabsts = sc->cl_reg->cl_dmabsts;
#ifdef DMA_DEBUG
log(LOG_WARNING, "cl_txintr: DMAMODE channel %x dmabsts %x risrl %x risrh %x\n",
	channel, dmabsts, risrl, risrh);
#endif
			nbuf = (risrh & 0x08) ? 1 : 0;
			bufcomplete = (risrh & 0x20) ? 1 : 0;
			if (nbuf == 0) {
				cnt  = sc->cl_reg->cl_arbcnt;
				status =  sc->cl_reg->cl_arbsts;
			} else {
				cnt  = sc->cl_reg->cl_brbcnt;
				status =  sc->cl_reg->cl_brbsts;
			}
#ifdef DMA_DEBUG
			log(LOG_WARNING, "cl_rxintr: 1channel %x buf %x cnt %x status %x\n",
			    channel, nbuf, cnt, status);
#endif
#if USE_BUFFER
			cl_appendbufn(sc, channel, sc->rx[nbuf], cnt);
#else 
			{
				int i;
				u_char *pbuf;
				tp = sc->sc_cl[channel].tty;
				pbuf = sc->sc_cl[channel].rx[nbuf];
				/* this should be done at off level */
				{
					u_short rcbadru, rcbadrl;
					u_char arbsts, brbsts;
					u_char *pbufs, *pbufe;
					rcbadru = sc->cl_reg->cl_rcbadru;
					rcbadrl = sc->cl_reg->cl_rcbadrl;
					arbsts =  sc->cl_reg->cl_arbsts;
					brbsts =  sc->cl_reg->cl_brbsts;
					pbufs = sc->sc_cl[channel].rxp[nbuf];
					pbufe = (u_char *)(((u_long)rcbadru << 16) | (u_long)rcbadrl);
					cnt = pbufe - pbufs;
#ifdef DMA_DEBUG
					log(LOG_WARNING, "cl_rxintr: rcbadru %x rcbadrl %x arbsts %x brbsts %x cnt %x\n",
					    rcbadru, rcbadrl, arbsts, brbsts, cnt);
#endif
#ifdef DMA_DEBUG1
					log(LOG_WARNING, "cl_rxintr: buf %x cnt %x\n",
					    nbuf, cnt);
#endif
				}
				reoir = 0x0 | (bufcomplete) ? 0 : 0xd0;
				sc->cl_reg->cl_reoir = reoir;
#ifdef DMA_DEBUG
				log(LOG_WARNING, "cl_rxintr: reoir %x\n", reoir);
#endif
				delay(10); /* give the chip a moment */
#ifdef DMA_DEBUG
				log(LOG_WARNING, "cl_rxintr: 2channel %x buf %x cnt %x status %x\n",
				    channel, nbuf, cnt, status);
#endif
				for (i = 0; i < cnt; i++) {
					u_char c;
					c = pbuf[i];
					(*linesw[tp->t_line].l_rint)(c,tp);
				}
			/* this should be done at off level */
				if (nbuf == 0) {
					sc->cl_reg->cl_arbcnt = CL_BUFSIZE;
					sc->cl_reg->cl_arbsts = 0x01;
				} else {
					sc->cl_reg->cl_brbcnt = CL_BUFSIZE;
					sc->cl_reg->cl_brbsts = 0x01;
				}
			}
#endif
		}
		sc->cl_reg->cl_reoir = reoir;
		break;
	case CL_RXINTR:
		fifocnt = sc->cl_reg->cl_rfoc;
		tp = sc->sc_cl[channel].tty;
		for (i = 0; i < fifocnt; i++) {
			buffer[i] = sc->cl_reg->cl_rdr;
		}
		if (NULL == tp) {
			/* if the channel is not configured,
			 * dont send characters upstream.
			 * also fix problem with NULL dereference
			 */
			reoir = 0x00;
			break;
		}

		sc->cl_reg->cl_reoir = reoir;
		for (i = 0; i < fifocnt; i++) {
			u_char c;
			c = buffer[i];
#if USE_BUFFER
			cl_appendbuf(sc, channel, c);
#else
			/* does any restricitions exist on spl
			 * for this call
			 */
			(*linesw[tp->t_line].l_rint)(c,tp);
			reoir = 0x00;
#endif
		}
		break;
	default:
		log(LOG_WARNING, "cl_rxintr unknown mode %x\n", cmr);
		/* we probably will go to hell quickly now */
		reoir = 0x08;
		sc->cl_reg->cl_reoir = reoir;
	}
	return 1;
}

void
cl_overflow (sc, channel, ptime, msg)
	struct clsoftc *sc;
	int channel;
	long *ptime;
	u_char *msg;
{
/*
	if (*ptime != time.tv_sec) {
*/
	{
/*
		*ptime = time.tv_sec;
*/
		log(LOG_WARNING, "%s%d[%d]: %s overrun\n", cl_cd.cd_name,
			0 /* fix */, channel, msg);
	}
	return;
}

void
cl_parity (sc, channel)
	struct clsoftc *sc;
	int channel;
{
	log(LOG_WARNING, "%s%d[%d]: parity error\n", cl_cd.cd_name, 0, channel);
	return;
}

void
cl_frame (sc, channel)
	struct clsoftc *sc;
	int channel;
{
	log(LOG_WARNING, "%s%d[%d]: frame error\n", cl_cd.cd_name, 0, channel);
	return;
}
void
cl_break (sc, channel)
	struct clsoftc *sc;
	int channel;
{
#ifdef DDB
	if (sc->sc_cl[channel].cl_consio && db_console != 0)
		Debugger();
#else
	log(LOG_WARNING, "%s%d[%d]: break detected\n", cl_cd.cd_name, 0, channel);
#endif
	return;
}

#ifdef DEBUG
void
cl_dumpport(channel)
	int channel;
{
	u_char	livr, cmr, cor1, cor2, cor3, cor4, cor5, cor6, cor7,
		schr1, schr2, schr3, schr4, scrl, scrh, lnxt,
		rbpr, rcor, tbpr, tcor, rpilr, rir, tpr, ier, ccr,
		dmabsts, arbsts, brbsts, atbsts, btbsts,
		csr, rts, dtr, rtprl, rtprh;
	void *volatile parbadru, *volatile parbadrl,
	     *volatile parbsts, *volatile parbcnt;
	u_short rcbadru, rcbadrl, arbadru, arbadrl, arbcnt,
		brbadru, brbadrl, brbcnt;
	u_short tcbadru, tcbadrl, atbadru, atbadrl, atbcnt,
		btbadru, btbadrl, btbcnt;
	struct clsoftc *sc;

	struct clreg *volatile cl_reg;
	int s;

	cl_reg = cl_cons.cl_vaddr;

	sc = (struct clsoftc *) cl_cd.cd_devs[0];

	s = splcl();
	cl_reg->cl_car	= (u_char) channel;
	livr = cl_reg->cl_livr;
	cmr = cl_reg->cl_cmr;
	cor1 = cl_reg->cl_cor1;
	cor2 = cl_reg->cl_cor2;
	cor3 = cl_reg->cl_cor3;
	cor4 = cl_reg->cl_cor4;
	cor5 = cl_reg->cl_cor5;
	cor6 = cl_reg->cl_cor6;
	cor7 = cl_reg->cl_cor7;
	schr1 = cl_reg->cl_schr1;
	schr2 = cl_reg->cl_schr2;
	schr3 = cl_reg->cl_schr3;
	schr4 = cl_reg->cl_schr4;
	scrl = cl_reg->cl_scrl;
	scrh = cl_reg->cl_scrh;
	lnxt = cl_reg->cl_lnxt;
	rbpr = cl_reg->cl_rbpr;
	rcor = cl_reg->cl_rcor;
	tbpr = cl_reg->cl_tbpr;
	rpilr = cl_reg->cl_rpilr;
	rir = cl_reg->cl_rir;
	ier = cl_reg->cl_ier;
	ccr = cl_reg->cl_ccr;
	tcor = cl_reg->cl_tcor;
	csr = cl_reg->cl_csr;
	tpr = cl_reg->cl_tpr;
	rts = cl_reg->cl_msvr_rts;
	dtr = cl_reg->cl_msvr_dtr;
	rtprl = cl_reg->cl_rtprl;
	rtprh = cl_reg->cl_rtprh;
	dmabsts = cl_reg->cl_dmabsts;
	tcbadru = cl_reg->cl_tcbadru;
	tcbadrl = cl_reg->cl_tcbadrl;
	rcbadru = cl_reg->cl_rcbadru;
	rcbadrl = cl_reg->cl_rcbadrl;

	parbadru = &(cl_reg->cl_arbadru);
	parbadrl = &(cl_reg->cl_arbadrl);
	parbcnt  = &(cl_reg->cl_arbcnt);
	parbsts  = &(cl_reg->cl_arbsts);

	arbadru = cl_reg->cl_arbadru;
	arbadrl = cl_reg->cl_arbadrl;
	arbcnt  = cl_reg->cl_arbcnt;
	arbsts  = cl_reg->cl_arbsts;

	brbadru = cl_reg->cl_brbadru;
	brbadrl = cl_reg->cl_brbadrl;
	brbcnt  = cl_reg->cl_brbcnt;
	brbsts  = cl_reg->cl_brbsts;

	atbadru = cl_reg->cl_atbadru;
	atbadrl = cl_reg->cl_atbadrl;
	atbcnt  = cl_reg->cl_atbcnt;
	atbsts  = cl_reg->cl_atbsts;

	btbadru = cl_reg->cl_btbadru;
	btbadrl = cl_reg->cl_btbadrl;
	btbcnt  = cl_reg->cl_btbcnt;
	btbsts  = cl_reg->cl_btbsts;

	splx(s);

	printf("{ port %x livr %x cmr %x\n",
		  channel,livr,   cmr);
	printf("cor1 %x cor2 %x cor3 %x cor4 %x cor5 %x cor6 %x cor7 %x\n",
		cor1,   cor2,   cor3,   cor4,   cor5,   cor6,   cor7);
	printf("schr1 %x schr2 %x schr3 %x schr4 %x\n",
		schr1,   schr2,   schr3,   schr4);
	printf("scrl %x scrh %x lnxt %x\n",
		scrl,   scrh,   lnxt);
	printf("rbpr %x rcor %x tbpr %x tcor %x\n",
		rbpr,   rcor,   tbpr,   tcor);
	printf("rpilr %x rir %x ier %x ccr %x\n",
		rpilr,   rir,   ier,   ccr);
	printf("tpr %x csr %x rts %x dtr %x\n",
		tpr,   csr,   rts,   dtr);
	printf("rtprl %x rtprh %x\n",
		rtprl,   rtprh);
	printf("rxcnt %x txcnt %x\n",
		sc->sc_cl[channel].rxcnt, sc->sc_cl[channel].txcnt);
	printf("dmabsts %x, tcbadru %x, tcbadrl %x, rcbadru %x, rcbadrl %x,\n",
		dmabsts,    tcbadru,    tcbadrl,    rcbadru,    rcbadrl );
	printf("parbadru %x, parbadrl %x, parbcnt %x, parbsts %x\n",
		parbadru,    parbadrl,    parbcnt,    parbsts);
	printf("arbadru %x, arbadrl %x, arbcnt %x, arbsts %x\n",
		arbadru,    arbadrl,    arbcnt,    arbsts);
	printf("brbadru %x, brbadrl %x, brbcnt %x, brbsts %x\n",
		brbadru,    brbadrl,    brbcnt,    brbsts);
	printf("atbadru %x, atbadrl %x, atbcnt %x, atbsts %x\n",
		atbadru,    atbadrl,    atbcnt,    atbsts);
	printf("btbadru %x, btbadrl %x, btbcnt %x, btbsts %x\n",
		btbadru,    btbadrl,    btbcnt,    btbsts);
	printf("}\n");
	return;
}
#endif
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.28 2003/06/03 21:09:01 deraadt Exp $ */
d5 1
d15 5
@


1.1.1.3
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.29 2003/08/15 20:32:14 tedu Exp $ */
d878 1
a878 1
		error = suser(p, 0); 
@


1.1.1.4
log
@Import OpenBSD source tree again, with critical bug fixes
(OpenSSL, bc, dc, sensorsd, pf, ...)
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.30 2003/09/28 14:26:25 miod Exp $ */
d532 1
a532 1
		tty_attach(tp);
@


1.1.1.5
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.33 2003/12/19 22:30:18 miod Exp $ */
d5 1
a5 1
 *
d25 1
a25 1
 */
d67 1
a67 1
#define CL_RXMASK	0x87
d192 1
a192 1
struct cfattach cl_ca = {
d194 2
a195 2
};

d198 1
a198 1
};
d216 1
a216 1
	if (unit >= cl_cd.cd_ndevs ||
d224 1
a224 1
int
d231 1
a231 1
	 * should be previously configured,
d236 1
a236 1

d244 1
a244 1
	if (badvaddr((vaddr_t)&cl_reg->cl_gfrcr,1))
d380 1
a380 1
		cl_reg->cl_cmr	= 0x02;
d486 1
d519 1
a519 1

d521 1
a521 1
	if (unit >= cl_cd.cd_ndevs ||
d532 1
d586 1
a586 1
				/* CL_TXDMAINT | */ CL_RXDMAINT;
d616 1
a616 1
			sc->cl_reg->cl_cmr	= 0x42;
d620 1
a620 1
			sc->cl_reg->cl_cmr	= 0x82;
d664 1
a664 1
	if (unit >= cl_cd.cd_ndevs ||
d693 1
a693 1
	if (unit >= cl_cd.cd_ndevs ||
d733 1
a733 1
	if (unit >= cl_cd.cd_ndevs ||
d743 1
a743 1

d775 1
a775 1
	if (unit >= cl_cd.cd_ndevs ||
d798 1
a798 1
	if (unit >= cl_cd.cd_ndevs ||
d824 1
a824 1
	if (unit >= cl_cd.cd_ndevs ||
d878 1
a878 1
		error = suser(p, 0);
d880 1
a880 1
			return(EPERM);
d944 1
a944 1

d1052 1
a1052 1

d1150 1
a1150 1
		if (unit >= cl_cd.cd_ndevs ||
d1177 1
a1177 1
u_char
d1241 1
a1241 1
	if (par->c_ospeed == 0) {
d1297 1
a1297 1
		if (sc->cl_reg->cl_cor1 != cor1) {
d1341 1
a1341 1
u_char
d1359 1
a1359 1
u_char
d1378 1
a1378 1
u_char
d1427 1
a1427 1
	if (unit >= cl_cd.cd_ndevs ||
d1490 1
a1490 1
		log(LOG_WARNING, "cl_mintr: channel %x cts %x\n",channel,
d1558 1
a1558 1
				log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %p\n",
d1646 1
a1646 1

d1710 1
a1710 1
#else
@


1.1.1.6
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.34 2003/12/29 07:04:14 deraadt Exp $ */
d266 1
a266 1
		printf(": console ");
@


1.1.1.7
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.37 2004/01/14 20:50:48 miod Exp $ */
d47 3
d73 3
d108 1
a108 2
char cl_dmabuf[CLCD_PORTS_PER_CHIP * CL_BUFSIZE * 4];
char cl_dmabuf1[CLCD_PORTS_PER_CHIP * CL_BUFSIZE * 4];
d197 1
a197 1
	NULL, "cl", DV_TTY
a201 1
#ifdef	CLCD_DO_POLLED_INPUT
a202 1
#endif
d206 1
d208 3
a210 2
struct tty *
cltty(dev)
a214 1

d217 1
a217 1
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
d230 4
d238 1
a238 1
		return (0);
d240 7
a246 13
	/*
	 * We do not accept empty locators here...
	 */
	if ((vaddr_t)ca->ca_paddr == CD2400_BASE_ADDR ||
	    ((vaddr_t)ca->ca_paddr == CD2400_SECONDARY_ADDR &&
	     brdtyp == BRD_8120)) {
		ca->ca_ipl = IPL_TTY;
		ca->ca_vaddr = ca->ca_paddr;

		cl_reg = (struct clreg *)ca->ca_vaddr;
		return (!badvaddr((vaddr_t)&cl_reg->cl_gfrcr, 1));
	} else
		return (0);
d283 1
a283 5
	/* XXX */
	if ((vaddr_t)ca->ca_paddr == CD2400_BASE_ADDR)
		sc->sc_cl[0].rx[0] = (void *)(&cl_dmabuf);
	else
		sc->sc_cl[0].rx[0] = (void *)(&cl_dmabuf1);
a345 1
#ifdef CLCD_DO_POLLED_INPUT
a346 1
#endif
@


1.1.1.8
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.45 2004/04/29 16:20:02 miod Exp $ */
a41 1
#include <machine/locore.h>
a47 1
#include <mvme88k/dev/pcctwovar.h>
d68 2
d71 4
a74 4
	bus_space_tag_t		cl_iot;
	bus_space_handle_t	cl_ioh;
	volatile u_int8_t	*cl_rxiack;
	u_int8_t		channel;
a87 1
#if 0
a88 1
#endif
d107 8
a114 7
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	struct evcnt		sc_txintrcnt;
	struct evcnt		sc_rxintrcnt;
	struct evcnt		sc_mxintrcnt;
	time_t			sc_fotime;	/* time of last fifo overrun */
d120 2
a121 1
	struct pcctwosoftc	*sc_pcctwo;
d123 1
a123 2

const struct {
a146 2
#define	CL_SAFE_CLOCK	4	/* 9600 entry */

d148 2
a149 1
cons_decl(cl);
d151 6
a156 3
u_int8_t cl_clkdiv(int speed);
u_int8_t cl_clknum(int speed);
u_int8_t cl_clkrxtimeout(int speed);
d165 1
a165 1
void cl_overflow(struct clsoftc *sc, int channel, long *ptime, char *msg);
d171 1
a171 1
void cl_dumpport(struct clsoftc *, int);
d177 9
a185 2
void	cl_initchannel(struct clsoftc *sc, int channel);
void	clputc(struct clsoftc *sc, int unit, u_char c);
a194 1
#if 0
d196 3
a198 1
void cloutput(struct tty *tp);
d214 1
a214 1
		return NULL;
d226 1
a227 2
	bus_space_handle_t ioh;
	int rc;
d230 1
a230 1
		return 0;
d235 5
a239 9
	if (ca->ca_paddr == CD2400_BASE_ADDR ||
	    (ca->ca_paddr == CD2400_SECONDARY_ADDR && brdtyp == BRD_8120)) {
		if (bus_space_map(ca->ca_iot, ca->ca_paddr, CD2400_SIZE,
		    0, &ioh) != 0)
			return 0;
		rc = badvaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 1);
		bus_space_unmap(ca->ca_iot, ca->ca_paddr, CD2400_SIZE);
		return rc == 0;
	}
d241 4
a244 1
	return 0;
a254 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d257 2
a258 2
	if (ca->ca_ipl < 0)
		ca->ca_ipl = IPL_TTY;
d260 3
a262 14
	iot = sc->sc_iot = ca->ca_iot;
	if (bus_space_map(iot, ca->ca_paddr, CD2400_SIZE, 0, &ioh) != 0) {
		printf(": can't map registers!\n");
		return;
	}
	sc->sc_ioh = ioh;
	sc->sc_pcctwo = (struct pcctwosoftc *)parent;

	if (ca->ca_paddr == CD2400_BASE_ADDR) {
		/*
		 * Although we are still running using the BUG routines,
		 * this device will be elected as the console after
		 * autoconf. Mark it as such.
		 */
d264 1
a264 1
		printf(": console");
d269 2
a270 2
	/* allow chip to settle before continuing */
	delay(800);
d273 4
a276 4
	bus_space_write_1(iot, ioh, CL_TPR, CL_TIMEOUT);
	bus_space_write_1(iot, ioh, CL_RPILR, 0x03);
	bus_space_write_1(iot, ioh, CL_TPILR, 0x02);
	bus_space_write_1(iot, ioh, CL_MPILR, 0x01);
a327 5

	/* clear errors */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCERR, 0x01);

d348 14
a361 12

	pcctwointr_establish(PCC2V_SCC_RXE, &sc->sc_ih_e);
	pcctwointr_establish(PCC2V_SCC_M, &sc->sc_ih_m);
	pcctwointr_establish(PCC2V_SCC_TX, &sc->sc_ih_t);
	pcctwointr_establish(PCC2V_SCC_RX, &sc->sc_ih_r);

	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCICR, PCC2_IRQ_IEN | (ca->ca_ipl & PCC2_IRQ_IPL));
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCTX, PCC2_IRQ_IEN | (ca->ca_ipl & PCC2_IRQ_IPL));
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCRX, PCC2_IRQ_IEN | (ca->ca_ipl & PCC2_IRQ_IPL));
a365 1

d375 1
a375 6
	bus_space_tag_t iot;
	bus_space_handle_t ioh;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

d379 24
a402 25

	bus_space_write_1(iot, ioh, CL_CAR, channel);
	bus_space_write_1(iot, ioh, CL_LIVR, PCC2_VECT + PCC2V_SCC_RXE);
	bus_space_write_1(iot, ioh, CL_IER, 0);

	if (sc->sc_cl[channel].cl_consio == 0) {
		bus_space_write_1(iot, ioh, CL_CMR, 0x02);
		bus_space_write_1(iot, ioh, CL_COR1, 0x17);
		bus_space_write_1(iot, ioh, CL_COR2, 0x00);
		bus_space_write_1(iot, ioh, CL_COR3, 0x02);
		bus_space_write_1(iot, ioh, CL_COR4, 0xec);
		bus_space_write_1(iot, ioh, CL_COR5, 0xec);
		bus_space_write_1(iot, ioh, CL_COR6, 0x00);
		bus_space_write_1(iot, ioh, CL_COR7, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR1, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR2, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR3, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR4, 0x00);
		bus_space_write_1(iot, ioh, CL_SCRL, 0x00);
		bus_space_write_1(iot, ioh, CL_SCRH, 0x00);
		bus_space_write_1(iot, ioh, CL_LNXT, 0x00);
		bus_space_write_1(iot, ioh, CL_RBPR, 0x40);	/* 9600 */
		bus_space_write_1(iot, ioh, CL_RCOR, 0x01);
		bus_space_write_1(iot, ioh, CL_TBPR, 0x40);	/* 9600 */
		bus_space_write_1(iot, ioh, CL_TCOR, 0x01 << 5);
d404 8
a411 8
		bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
		bus_space_write_1(iot, ioh, CL_RTPRL, CL_RX_TIMEOUT);
		bus_space_write_1(iot, ioh, CL_RTPRH, 0x00);
	}
	bus_space_write_1(iot, ioh, CL_CCR, 0x20);
	while (bus_space_read_1(iot, ioh, CL_CCR) != 0)
		;
d425 1
a426 4
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int s;

d428 4
a431 4
	sc = (struct clsoftc *)cl_cd.cd_devs[CL_UNIT(dev)];
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

d436 10
a445 8
		if (bits & TIOCM_RTS)
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x01);
		else
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		if (bits & TIOCM_DTR)
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x02);
		else
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
d449 6
a454 4
		if (bits & TIOCM_RTS)
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		if (bits & TIOCM_DTR)
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
d458 6
a463 4
		if (bits & TIOCM_RTS)
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x01);
		if (bits & TIOCM_DTR)
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x02);
d470 3
a472 4
			u_int8_t msvr;

			msvr = bus_space_read_1(iot, ioh, CL_MSVR_RTS);
			if (msvr & 0x80)
d474 2
a475 1
			if (msvr & 0x40)
d477 2
a478 1
			if (msvr & 0x20)
d480 2
a481 1
			if (msvr & 0x10)
d483 2
a484 1
			if (msvr & 0x02)
d486 2
a487 1
			if (msvr & 0x01)
d489 1
d505 4
a508 1
	return bits;
d525 2
a526 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
a527 1

a529 1

d552 1
a552 1
			if (sc->sc_cl[channel].cl_consio != 0) {
d582 47
a628 8
			u_int8_t save;

			save = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CL_CAR);
			bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR,
			    channel);
			bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_IER, 0x88);
			bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR,
			    save);
d632 1
a632 1
		return EBUSY;
d634 8
a642 1

d649 1
a649 1
	cl_dumpport(sc, channel);
d651 1
a651 1
	return (*linesw[tp->t_line].l_open)(dev, tp);
d667 2
a668 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
d696 1
a696 1
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
a732 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
a733 1

d736 2
a737 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
a740 2
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
d745 6
a750 5
	bus_space_write_1(iot, ioh, CL_CAR, channel);
	if (cl->cl_consio == 0 && (tp->t_cflag & HUPCL) != 0) {
		bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
		bus_space_write_1(iot, ioh, CL_CCR, 0x05);
a752 1

d760 1
a760 1
	cl_dumpport(sc, channel);
d778 2
a779 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
d784 1
a784 1
	if (tp == NULL)
d786 1
a786 1
	return (*linesw[tp->t_line].l_read)(tp, uio, flag);
d801 2
a802 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
d807 1
a807 1
	if (tp == NULL)
d809 1
a809 1
	return (*linesw[tp->t_line].l_write)(tp, uio, flag);
d827 2
a828 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
d833 1
a833 1
	if (tp == NULL)
d838 1
a838 1
		return error;
d842 1
a842 1
		return error;
d882 1
a882 1
			return EPERM;
d889 1
a889 1
		return ENOTTY;
d911 8
a918 1
void
d922 2
a925 2
	cp->cn_pri = CN_DEAD;

d927 4
a930 7
	if (brdtyp == BRD_188 || badaddr(CD2400_BASE_ADDR, 1) != 0)
		return;

	/* do not attach as console if cl has been disabled */
	if (cl_cd.cd_ndevs == 0 || cl_cd.cd_devs[0] == NULL)
		return;

d935 2
a936 2
	if (maj == nchrdev)
		return;
d938 1
a938 2
	cp->cn_dev = makedev(maj, 0);
	cp->cn_pri = CN_NORMAL;
d941 1
a941 1
void
d945 1
a945 1
	struct clsoftc *sc;
d947 34
a980 4
	sc = (struct clsoftc *)cl_cd.cd_devs[0];
	cl_cons.cl_iot = sc->sc_iot;
	cl_cons.cl_ioh = sc->sc_ioh;
	cl_cons.cl_rxiack = (void *)(sc->sc_pcctwo->sc_base + PCCTWO_SCCRXIACK);
d987 7
a993 8
	u_int8_t rir;

	if (sc == NULL)
		rir = bus_space_read_1(cl_cons.cl_iot, cl_cons.cl_ioh, CL_RIR);
	else
		rir = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CL_RIR);

	return (rir & 0x40);
d1000 4
a1003 1
	u_int8_t val, reoir, licr, data;
d1005 8
a1012 13
	u_int8_t ier_old;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;

	iot = cl_cons.cl_iot;
	ioh = cl_cons.cl_ioh;

	bus_space_write_1(iot, ioh, CL_CAR, 0);
	ier_old = bus_space_read_1(iot, ioh, CL_IER);
	if ((ier_old & 0x08) == 0) {
		bus_space_write_1(iot, ioh, CL_IER, 0x08);
	} else
		ier_old = 0xff;
d1015 1
a1015 1
		val = bus_space_read_1(iot, ioh, CL_RIR);
d1017 1
a1017 1
		if ((val & 0x80) == 0)
d1019 1
a1019 1

d1021 2
a1022 3
		reoir = *cl_cons.cl_rxiack; /* receive PIACK */
		licr = bus_space_read_1(iot, ioh, CL_LICR);
		/* is the interrupt for us? (port 0) */
d1024 23
a1046 5
			(void)bus_space_read_1(iot, ioh, CL_RISRL);
			(void)bus_space_read_1(iot, ioh, CL_RFOC);
			data = bus_space_read_1(iot, ioh, CL_RDR);
			if (ier_old != 0xff)
				bus_space_write_1(iot, ioh, CL_IER, ier_old);
d1048 1
d1050 2
a1051 2
			/* read and discard the character */
			data = bus_space_read_1(iot, ioh, CL_RDR);
a1052 1
		bus_space_write_1(iot, ioh, CL_TEOIR, 0x00);
d1071 1
a1071 1
	if (on != 0) {
d1076 1
a1084 4
	u_int8_t schar;
	u_int8_t oldchannel;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d1086 4
a1089 2

	if (sc == NULL) {
d1091 1
a1091 2
		iot = cl_cons.cl_iot;
		ioh = cl_cons.cl_ioh;
d1093 13
a1105 2
		iot = sc->sc_iot;
		ioh = sc->sc_ioh;
d1107 2
a1108 4

	s = splhigh();
	oldchannel = bus_space_read_1(iot, ioh, CL_CAR);
	bus_space_write_1(iot, ioh, CL_CAR, unit);
d1110 7
a1116 5
		schar = bus_space_read_1(iot, ioh, CL_SCHR3);
		/* send special char, number 3 */
		bus_space_write_1(iot, ioh, CL_SCHR3, c);
		bus_space_write_1(iot, ioh, CL_STCR, 0x08 | 3);
		while (bus_space_read_1(iot, ioh, CL_STCR) != 0) {
d1123 102
a1224 1
		bus_space_write_1(iot, ioh, CL_SCHR3, schar);
d1226 2
a1227 2
		if (bus_space_read_1(iot, ioh, CL_TFTC) != 0)
			bus_space_write_1(iot, ioh, CL_TDR, c);
d1229 1
a1229 2
	bus_space_write_1(iot, ioh, CL_CAR, oldchannel);
	splx(s);
a1237 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
a1240 3
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

d1242 1
a1242 1
	bus_space_write_1(iot, ioh, CL_CAR, channel);
d1245 1
a1245 1
		if (sc->sc_cl[channel].cl_consio == 0) {
d1247 3
a1249 3
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
			bus_space_write_1(iot, ioh, CL_CCR, 0x05);
d1252 1
a1252 1
		return 0xff;
d1255 2
a1256 2
	bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x03);
	bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x03);
d1260 2
a1261 2
	bus_space_write_1(iot, ioh, CL_TBPR, divisor);
	bus_space_write_1(iot, ioh, CL_TCOR, clk << 5);
d1264 4
a1267 4
	bus_space_write_1(iot, ioh, CL_RBPR, divisor);
	bus_space_write_1(iot, ioh, CL_RCOR, clk);
	bus_space_write_1(iot, ioh, CL_RTPRL, cl_clkrxtimeout(par->c_ispeed));
	bus_space_write_1(iot, ioh, CL_RTPRH, 0x00);
d1286 1
a1286 2

	bus_space_write_1(iot, ioh, CL_COR3, par->c_cflag & PARENB ? 4 : 2);
d1289 1
a1289 1
		u_int8_t cor1;
d1299 5
a1303 6

		if (bus_space_read_1(iot, ioh, CL_COR1) != cor1) {
			bus_space_write_1(iot, ioh, CL_COR1, cor1);
			bus_space_write_1(iot, ioh, CL_CCR, 0x20);
			while (bus_space_read_1(iot, ioh, CL_CCR) != 0)
				;
d1307 9
a1315 8
	if (sc->sc_cl[channel].cl_consio == 0 && (par->c_cflag & CREAD) == 0)
		bus_space_write_1(iot, ioh, CL_CCR, 0x08);
	else
		bus_space_write_1(iot, ioh, CL_CCR, 0x0a);

	while (bus_space_read_1(iot, ioh, CL_CCR) != 0)
		;

d1334 2
a1335 2
	bus_space_write_1(iot, ioh, CL_COR4, ints | CL_FIFO_CNT);
	bus_space_write_1(iot, ioh, CL_COR5, ints | CL_FIFO_CNT);
a1337 1

d1343 1
a1343 1
u_int8_t
d1347 2
a1348 3
	int i;

	if (cl_clocks[clknum].speed == speed)
d1350 1
a1350 1

a1356 1

d1358 1
a1358 1
	return cl_clocks[CL_SAFE_CLOCK].divisor;
d1361 1
a1361 1
u_int8_t
d1365 3
a1367 3
	int i;

	if (cl_clocks[clknum].speed == speed)
d1369 2
a1370 2

	for (i = 0; cl_clocks[i].speed != 0; i++) {
a1375 1

d1377 1
a1377 1
	return cl_clocks[CL_SAFE_CLOCK].clock;
d1380 1
a1380 1
u_int8_t
d1384 2
a1385 3
	int i;

	if (cl_clocks[clknum].speed == speed)
d1387 1
a1387 1

a1393 1

d1395 1
a1395 1
	return cl_clocks[CL_SAFE_CLOCK].rx_timeout;
d1416 1
a1416 1
	u_int8_t cbuf;
d1430 1
a1430 1
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
d1447 2
a1448 2
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR, channel);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_TDR, cbuf);
d1456 2
a1457 3
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR, channel);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_IER,
		    bus_space_read_1(sc->sc_iot, sc->sc_ioh, CL_IER) | 0x03);
d1461 1
d1469 2
a1470 3
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t mir, misr, msvr;
d1473 1
a1473 5
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	mir = bus_space_read_1(iot, ioh, CL_MIR);
	if ((mir & 0x40) == 0) {
d1481 2
a1482 2
	misr = bus_space_read_1(iot, ioh, CL_MISR);
	msvr = bus_space_read_1(iot, ioh, CL_MSVR_RTS);
a1491 1
#ifdef DEBUG
d1493 1
a1493 1
		    ((msvr & 0x20) != 0x0)
a1494 1
#endif
a1497 1
#ifdef DEBUG
d1499 1
a1499 1
		    ((msvr & 0x40) != 0x0)
a1500 1
#endif
a1503 1
#ifdef DEBUG
a1506 1
#endif
d1508 1
a1508 1
	bus_space_write_1(iot, ioh, CL_MEOIR, 0);
a1515 1
	static int empty;
d1517 4
a1520 4
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t tir, cmr, teoir;
	u_int8_t max;
d1525 2
a1526 5

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	tir = bus_space_read_1(iot, ioh, CL_TIR);
	if ((tir & 0x40) == 0) {
d1534 2
a1537 2
	cmr = bus_space_read_1(iot, ioh, CL_CMR);

d1540 2
a1541 3
		bus_space_write_1(iot, ioh, CL_IER,
		    bus_space_read_1(iot, ioh, CL_IER) & ~0x03);
		bus_space_write_1(iot, ioh, CL_TEOIR, 0x08);
a1543 1

d1546 35
a1580 27
	{
		u_int8_t dmabsts;
		int nbuf, busy, resid;
		void *pbuffer;

		dmabsts = bus_space_read_1(iot, ioh, CL_DMABSTS);
		nbuf = ((dmabsts & 0x8) >> 3) & 0x1;
		busy = ((dmabsts & 0x4) >> 2) & 0x1;

		do {
			pbuffer = sc->sc_cl[channel].tx[nbuf];
			resid = tp->t_outq.c_cc;
			cnt = min (CL_BUFSIZE,resid);
			log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %p\n",
			    resid, cnt, pbuffer);
			if (cnt != 0) {
				cnt = q_to_b(&tp->t_outq, pbuffer, cnt);
				resid -= cnt;
				if (nbuf == 0) {
					bus_space_write_2(iot, ioh, CL_ATBADRU,
					    ((u_long)sc->sc_cl[channel].txp[nbuf]) >> 16);
					bus_space_write_2(iot, ioh, CL_ATBADRL,
					    ((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff);
					bus_space_write_2(iot, ioh, CL_ATBCNT,
					    cnt);
					bus_space_write_1(iot, ioh, CL_ATBSTS,
					    0x43);
d1582 8
a1589 17
					bus_space_write_2(iot, ioh, CL_BTBADRU,
					    ((u_long)sc->sc_cl[channel].txp[nbuf]) >> 16);
					bus_space_write_2(iot, ioh, CL_BTBADRL,
					    ((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff);
					bus_space_write_2(iot, ioh, CL_BTBCNT,
					    cnt);
					bus_space_write_1(iot, ioh, CL_BTBSTS,
					    0x43);
				}
				teoir = 0x08;
			} else {
				teoir = 0x08;
				if (tp->t_state & TS_BUSY) {
					tp->t_state &= ~(TS_BUSY | TS_FLUSH);
					if (tp->t_state & TS_ASLEEP) {
						tp->t_state &= ~TS_ASLEEP;
						wakeup((caddr_t) &tp->t_outq);
d1591 1
a1591 1
					selwakeup(&tp->t_wsel);
d1593 5
a1597 7
				bus_space_write_1(iot, ioh, CL_IER,
				    bus_space_read_1(iot, ioh, CL_IER) & ~0x03);
			}
			nbuf = ~nbuf & 0x1;
			busy--;
		} while (resid != 0 && busy != -1);/* if not busy do other buffer */
	}
d1600 2
a1601 2
		max = bus_space_read_1(iot, ioh, CL_TFTC);
		cnt = min((int)max,tp->t_outq.c_cc);
d1605 3
a1607 1
			bus_space_write_multi_1(iot, ioh, CL_TDR, buffer, cnt);
d1624 1
a1624 2
			bus_space_write_1(iot, ioh, CL_IER,
			    bus_space_read_1(iot, ioh, CL_IER) & ~0x03);
d1632 1
a1632 1
	bus_space_write_1(iot, ioh, CL_TEOIR, teoir);
d1641 3
a1643 4
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t rir, channel, cmr, risrl;
	u_int8_t fifocnt;
d1646 1
a1646 1
	u_int8_t reoir;
a1647 3
#ifdef DDB
	int wantddb = 0;
#endif
d1649 2
a1650 5
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	rir = bus_space_read_1(iot, ioh, CL_RIR);
	if ((rir & 0x40) == 0x0) {
d1657 2
a1658 1
	cmr = bus_space_read_1(iot, ioh, CL_CMR);
d1661 1
a1661 1
	risrl = bus_space_read_1(iot, ioh, CL_RISRL);
d1664 1
d1666 1
a1666 1
	/* We don't need no stinkin special characters */
d1668 2
a1669 1
		cl_overflow(sc, channel, (long *)&sc->sc_fotime, "fifo");
d1673 1
d1677 1
a1679 4
#ifdef DDB
		if (sc->sc_cl[channel].cl_consio)
			wantddb = db_console;
#endif
d1681 1
a1682 1
	reoir = 0x08;
d1686 24
a1709 18
	{
		int nbuf;
		u_int16_t cnt;
		int bufcomplete;
		u_int8_t status, dmabsts;
		u_int8_t risrh;

		risrh = bus_space_read_1(iot, ioh, CL_RISRH);
		dmabsts = bus_space_read_1(iot, ioh, CL_DMABSTS);
		nbuf = (risrh & 0x08) ? 1 : 0;
		bufcomplete = (risrh & 0x20) ? 1 : 0;
		if (nbuf == 0) {
			cnt = bus_space_read_2(iot, ioh, CL_ARBCNT);
			status = bus_space_read_1(iot, ioh, CL_ARBSTS);
		} else {
			cnt = bus_space_read_2(iot, ioh, CL_BRBCNT);
			status = bus_space_read_1(iot, ioh, CL_BRBSTS);
		}
d1711 1
a1711 1
		cl_appendbufn(sc, channel, sc->rx[nbuf], cnt);
a1712 7
		{
			int i;
			u_char *pbuf;

			tp = sc->sc_cl[channel].tty;
			pbuf = sc->sc_cl[channel].rx[nbuf];
			/* this should be done at off level */
d1714 40
a1753 24
				u_int16_t rcbadru, rcbadrl;
				u_int8_t arbsts, brbsts;
				u_char *pbufs, *pbufe;

				rcbadru = bus_space_read_2(iot, ioh,
				    CL_RCBADRU);
				rcbadrl = bus_space_read_2(iot, ioh,
				    CL_RCBADRL);
				arbsts = bus_space_read_1(iot, ioh, CL_ARBSTS);
				brbsts = bus_space_read_1(iot, ioh, CL_BRBSTS);
				pbufs = sc->sc_cl[channel].rxp[nbuf];
				pbufe = (u_char *)(((u_long)rcbadru << 16) | (u_long)rcbadrl);
				cnt = pbufe - pbufs;
			}
			reoir = 0x0 | (bufcomplete) ? 0 : 0xd0;
			bus_space_write_1(iot, ioh, CL_REOIR, reoir);

			DELAY(10); /* give the chip a moment */

			for (i = 0; i < cnt; i++) {
				u_char c;
				c = pbuf[i];
				(*linesw[tp->t_line].l_rint)(c,tp);
			}
d1755 7
a1761 8
			if (nbuf == 0) {
				bus_space_write_2(iot, ioh, CL_ARBCNT,
				    CL_BUFSIZE);
				bus_space_write_2(iot, ioh, CL_ARBSTS, 0x01);
			} else {
				bus_space_write_2(iot, ioh, CL_BRBCNT,
				    CL_BUFSIZE);
				bus_space_write_2(iot, ioh, CL_BRBSTS, 0x01);
d1763 1
d1765 1
a1765 3
#endif
	}
		bus_space_write_1(iot, ioh, CL_REOIR, reoir);
d1768 1
a1768 1
		fifocnt = bus_space_read_1(iot, ioh, CL_RFOC);
d1770 4
a1773 2
		bus_space_read_multi_1(iot, ioh, CL_RDR, buffer, fifocnt);
		if (tp == NULL) {
d1782 1
a1782 1
		bus_space_write_1(iot, ioh, CL_REOIR, reoir);
d1793 1
d1800 2
a1801 1
		bus_space_write_1(iot, ioh, CL_REOIR, 0x08);
a1802 4
#ifdef DDB
	if (wantddb != 0)
		Debugger();
#endif
d1807 1
a1807 1
cl_overflow(sc, channel, ptime, msg)
d1811 1
a1811 1
	char *msg;
d1813 11
a1823 2
	log(LOG_WARNING, "%s[%d]: %s overrun\n", sc->sc_dev.dv_xname,
	    channel, msg);
d1827 1
a1827 1
cl_parity(sc, channel)
d1831 2
a1832 2
	log(LOG_WARNING, "%s[%d]: parity error\n", sc->sc_dev.dv_xname,
	    channel);
d1836 1
a1836 1
cl_frame(sc, channel)
d1840 2
a1841 2
	log(LOG_WARNING, "%s[%d]: frame error\n", sc->sc_dev.dv_xname,
	    channel);
a1842 1

d1844 1
a1844 1
cl_break(sc, channel)
d1848 5
a1852 3
#ifdef DEBUG
	log(LOG_WARNING, "%s[%d]: break detected\n", sc->sc_dev.dv_xname,
	    channel);
d1854 1
d1859 2
a1860 1
cl_dumpport(struct clsoftc *sc, int channel)
d1862 14
a1875 11
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t livr, cmr, cor1, cor2, cor3, cor4, cor5, cor6, cor7,
	    schr1, schr2, schr3, schr4, scrl, scrh, lnxt,
	    rbpr, rcor, tbpr, tcor, rpilr, rir, tpr, ier, ccr,
	    dmabsts, arbsts, brbsts, atbsts, btbsts,
	    csr, rts, dtr, rtprl, rtprh;
	u_int16_t rcbadru, rcbadrl, arbadru, arbadrl, arbcnt,
	    brbadru, brbadrl, brbcnt;
	u_int16_t tcbadru, tcbadrl, atbadru, atbadrl, atbcnt,
	    btbadru, btbadrl, btbcnt;
d1878 3
a1880 2
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
d1883 62
a1944 52
	bus_space_write_1(iot, ioh, CL_CAR, channel);
	livr = bus_space_read_1(iot, ioh, CL_LIVR);
	cmr = bus_space_read_1(iot, ioh, CL_CMR);
	cor1 = bus_space_read_1(iot, ioh, CL_COR1);
	cor2 = bus_space_read_1(iot, ioh, CL_COR2);
	cor3 = bus_space_read_1(iot, ioh, CL_COR3);
	cor4 = bus_space_read_1(iot, ioh, CL_COR4);
	cor5 = bus_space_read_1(iot, ioh, CL_COR5);
	cor6 = bus_space_read_1(iot, ioh, CL_COR6);
	cor7 = bus_space_read_1(iot, ioh, CL_COR7);
	schr1 = bus_space_read_1(iot, ioh, CL_SCHR1);
	schr2 = bus_space_read_1(iot, ioh, CL_SCHR2);
	schr3 = bus_space_read_1(iot, ioh, CL_SCHR3);
	schr4 = bus_space_read_1(iot, ioh, CL_SCHR4);
	scrl = bus_space_read_1(iot, ioh, CL_SCRL);
	scrh = bus_space_read_1(iot, ioh, CL_SCRH);
	lnxt = bus_space_read_1(iot, ioh, CL_LNXT);
	rbpr = bus_space_read_1(iot, ioh, CL_RBPR);
	rcor = bus_space_read_1(iot, ioh, CL_RCOR);
	tbpr = bus_space_read_1(iot, ioh, CL_TBPR);
	rpilr = bus_space_read_1(iot, ioh, CL_RPILR);
	rir = bus_space_read_1(iot, ioh, CL_RIR);
	ier = bus_space_read_1(iot, ioh, CL_IER);
	ccr = bus_space_read_1(iot, ioh, CL_CCR);
	tcor = bus_space_read_1(iot, ioh, CL_TCOR);
	csr = bus_space_read_1(iot, ioh, CL_CSR);
	tpr = bus_space_read_1(iot, ioh, CL_TPR);
	rts = bus_space_read_1(iot, ioh, CL_MSVR_RTS);
	dtr = bus_space_read_1(iot, ioh, CL_MSVR_DTR);
	rtprl = bus_space_read_1(iot, ioh, CL_RTPRL);
	rtprh = bus_space_read_1(iot, ioh, CL_RTPRH);
	dmabsts = bus_space_read_1(iot, ioh, CL_DMABSTS);
	tcbadru = bus_space_read_2(iot, ioh, CL_TCBADRU);
	tcbadrl = bus_space_read_2(iot, ioh, CL_TCBADRL);
	rcbadru = bus_space_read_2(iot, ioh, CL_RCBADRU);
	rcbadrl = bus_space_read_2(iot, ioh, CL_RCBADRL);
	arbadru = bus_space_read_2(iot, ioh, CL_ARBADRU);
	arbadrl = bus_space_read_2(iot, ioh, CL_ARBADRL);
	arbcnt  = bus_space_read_2(iot, ioh, CL_ARBCNT);
	arbsts  = bus_space_read_1(iot, ioh, CL_ARBSTS);
	brbadru = bus_space_read_2(iot, ioh, CL_BRBADRU);
	brbadrl = bus_space_read_2(iot, ioh, CL_BRBADRL);
	brbcnt  = bus_space_read_2(iot, ioh, CL_BRBCNT);
	brbsts  = bus_space_read_1(iot, ioh, CL_BRBSTS);
	atbadru = bus_space_read_2(iot, ioh, CL_ATBADRU);
	atbadrl = bus_space_read_2(iot, ioh, CL_ATBADRL);
	atbcnt  = bus_space_read_2(iot, ioh, CL_ATBCNT);
	atbsts  = bus_space_read_1(iot, ioh, CL_ATBSTS);
	btbadru = bus_space_read_2(iot, ioh, CL_BTBADRU);
	btbadrl = bus_space_read_2(iot, ioh, CL_BTBADRL);
	btbcnt  = bus_space_read_2(iot, ioh, CL_BTBCNT);
	btbsts  = bus_space_read_1(iot, ioh, CL_BTBSTS);
d1967 2
d1978 1
@


