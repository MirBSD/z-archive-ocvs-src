head	1.2;
access;
symbols
	cvs-200405160640:1.1.1.5
	cvs-200401271800:1.1.1.4
	cvs-200401261630:1.1.1.4
	cvs-200401021645:1.1.1.4
	cvs-200312222040:1.1.1.3
	cvs-200310020700:1.1.1.2
	cvs-200309271030:1.1.1.2
	cvs-200309261655:1.1.1.2
	cvs-200309251530:1.1.1.2
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	cvs-200307072125:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200307021520:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.04.06.04.29.29;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.50.01;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.50.01;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.06.05.17.35.36;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.22.20.59.55;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.01.02.17.49.40;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.16.08.38.36;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove "some dead architectures".

These are all but i386 and x86-64 (which is not in the tree yet),
because I have no machines to work with.

Re-adding support should be fairly easy, just cvs adding a partial
OpenBSD checkout and pulling in stuff like kernel signal patch, humantime,
etc. which got added to i386 as well.

You will need gcc support as well.
@
text
@/*	$OpenBSD: vme.h,v 1.8 2002/03/14 01:26:39 millert Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Theo de Raadt
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef __MVEME88K_DEV_VME_H__
#define __MVEME88K_DEV_VME_H__

struct vmesoftc {
	struct device	sc_dev;
	void *		sc_vaddr;
	struct intrhand sc_abih;       /* `abort' switch */
};

struct vmessoftc {
	struct device		sc_dev;
	struct vmesoftc		*sc_vme;
};

struct vmelsoftc {
	struct device		sc_dev;
	struct vmesoftc		*sc_vme;
};

/*
 * MVME147 vme configuration registers.
*/
struct vme1reg {
/*01*/	volatile u_short		vme1_scon;
#define VME1_SCON_SWITCH	0x01		/* SCON jumper is set */
#define VME1_SCON_SRESET	0x02		/* assert SRESET on bus */
#define VME1_SCON_SYSFAIL	0x04		/* assert SYSFAIL on bus */
#define VME1_SCON_ROBIN		0x08		/* round robin bus requests */
/*03*/	volatile u_short		vme1_reqconf;
#define VME1_REQ_IPLMASK	0x03		/* interrupt level for requester */
#define VME1_REQ_RNEVER		0x08
#define VME1_REQ_RWD		0x10
#define VME1_REQ_DHB		0x40
#define VME1_REQ_DWB		0x80
/*05*/	volatile u_short		vme1_masconf;
#define VME1_MAS_D16		0x01		/* force d8/16 accesses only */
#define VME1_MAS_MASA24		0x02		/* send address mod for A24 access */
#define VME1_MAS_MASA16		0x04		/* send address mod for A16 access */
#define VME1_MAS_MASUAT		0x08		/* handle unaligned VME cycles */
#define VME1_MAS_CFILL		0x10		/* DO NOT USE */
#define VME1_MAS_MASWP		0x20		/* VME fast mode (DO NOT USE) */
/*07*/	volatile u_short		vme1_slconf;
#define VME1_SLAVE_SLVD16	0x01		/* DO NOT USE */
#define VME1_SLAVE_SLVWP	0x20		/* DO NOT USE */
#define VME1_SLAVE_SLVEN	0x80		/* allow access to onboard DRAM */
/*09*/	volatile u_short		vme1_timerconf;
#define VME1_TIMER_LOCAL_MASK	0x03
#define VME1_TIMER_LOCAL_T0	0x00		/* local timeout 102 microsec */
#define VME1_TIMER_LOCAL_T1	0x01		/* local timeout 205 microsec */
#define VME1_TIMER_LOCAL_T2	0x02		/* local timeout 410 microsec */
#define VME1_TIMER_LOCAL_T3	0x03		/* local timeout disabled */
#define VME1_TIMER_VMEACC_MASK	0x0c
#define VME1_TIMER_VMEACC_T0	0x00		/* VME access timeout 102 microsec */
#define VME1_TIMER_VMEACC_T1	0x04		/* VME access timeout 1.6 millisec */
#define VME1_TIMER_VMEACC_T2	0x08		/* VME access timeout 51 millisec */
#define VME1_TIMER_VMEACC_T3	0x0c		/* VME access timeout disabled */
#define VME1_TIMER_VMEGLO_MASK	0x30
#define VME1_TIMER_VMEGLO_T0	0x00		/* VME glob timeout 102 microsec */
#define VME1_TIMER_VMEGLO_T1	0x10		/* VME glob timeout 205 microsec */
#define VME1_TIMER_VMEGLO_T2	0x20		/* VME glob timeout 410 microsec */
#define VME1_TIMER_VMEGLO_T3	0x30		/* VME glob timeout disabled */
#define VME1_TIMER_ARBTO	0x40		/* enable VME arbitration timer */
/*0b*/	volatile u_short		vme1_sladdrmod;
#define VME1_SLMOD_DATA		0x01
#define VME1_SLMOD_PRGRM	0x02
#define VME1_SLMOD_BLOCK	0x04
#define VME1_SLMOD_SHORT	0x08
#define VME1_SLMOD_STND		0x10
#define VME1_SLMOD_EXTED	0x20
#define VME1_SLMOD_USER		0x40
#define VME1_SLMOD_SUPER	0x80
/*0d*/	volatile u_short		vme1_msaddrmod;
#define VME1_MSMOD_AM_MASK	0x3f
#define VME1_MSMOD_AMSEL	0x80
/*0f*/	volatile u_short		vme1_irqen;
#define VME1_IRQ_VME(x)		(1 << (x))
/*11*/	volatile u_short		vme1_uirqen;
/*13*/	volatile u_short		vme1_uirq;
/*15*/	volatile u_short		vme1_irq;
/*17*/	volatile u_short		vme1_vmeid;
/*19*/	volatile u_short		vme1_buserr;
/*1b*/	volatile u_short		vme1_gcsr;
#define VME1_GCSR_OFF		0x0f
/*1d*/	u_short			:16;
/*1f*/	u_short			:16;
/*21*/	volatile u_short		vme1_gcsr_gr0;
/*23*/	volatile u_short		vme1_gcsr_gr1;
/*25*/	volatile u_short		vme1_gcsr_boardid;
/*27*/	volatile u_short		vme1_gcsr_gpr0;
/*29*/	volatile u_short		vme1_gcsr_gpr1;
/*2b*/	volatile u_short		vme1_gcsr_gpr2;
/*2d*/	volatile u_short		vme1_gcsr_gpr3;
/*2f*/	volatile u_short		vme1_gcsr_gpr4;
};

/*
 * Basic VME memory layout for the MVME147 follows:
 *    - A32D32 accesses occur at memsize-0xefffffff. This makes it
 *	impossible to do A32D32 accesses before the end of your onboard
 *	memory. If you want to do low address A24D32 accesses, and you
 *	have 16M or more onboard memory you'll find you cannot.
 *    - A32D16 accesses can occur at 0xf0000000-0xff7fffff.
 *    - A16D16 accesses can occur at 0xffff0000-0xffffffff.
 */
#define VME1_A32D32BASE	0x00000000UL
#define VME1_A32D32LEN	0xf0000000UL
#define VME1_A32D16BASE	0xf0000000UL
#define VME1_A32D16LEN	0x0f800000UL
#define VME1_A16D16BASE	0xffff0000UL
#define VME1_A16D16LEN	0x00010000UL
#define VME1_A16BASE	0xffff0000UL

/*
 * XXX: this chip has some rather inane access rules!
 */
struct vme2reg {
/*00*/	volatile u_long		vme2_slaveaddr1;
/*04*/	volatile u_long		vme2_slaveaddr2;
#define VME2_SADDR_END		0xffff0000		/* VME address END & START */
#define VME2_SADDR_START	0x0000ffff
/*08*/	volatile u_long		vme2_slavelmod1;
/*0c*/	volatile u_long		vme2_slavelmod2;
#define VME2_SADDR_LADDR	0xffff0000		/* local base address */
#define VME2_SADDR_SIZE(mem)	(0x1000 - (mem) >> 16)	/* encoding of size */
/*10*/	volatile u_long		vme2_slavectl;
#define VME2_SLAVE_CHOOSE(bits, num) ((bits) << (16*((num)-1)))
#define VME2_SLAVECTL_WP	0x00000100		/* write posting */
#define VME2_SLAVECTL_SNP_NO	0x00000000		/* no snooping */
#define VME2_SLAVECTL_SNP_SINK	0x00000200		/* sink data */
#define VME2_SLAVECTL_SNP_INVAL	0x00000400		/* invalidate */
#define VME2_SLAVECTL_ADDER	0x00000800		/* use adder */
#define VME2_SLAVECTL_SUP	0x00000080		/* modifier bit */
#define VME2_SLAVECTL_USR	0x00000040		/* modifier bit */
#define VME2_SLAVECTL_A32	0x00000020		/* modifier bit */
#define VME2_SLAVECTL_A24	0x00000010		/* modifier bit */
#define VME2_SLAVECTL_D64	0x00000008		/* modifier bit */
#define VME2_SLAVECTL_BLK	0x00000004		/* modifier bit */
#define VME2_SLAVECTL_PGM	0x00000002		/* modifier bit */
#define VME2_SLAVECTL_DAT	0x00000001		/* modifier bit */
/*14*/	volatile u_long		vme2_master1;
/*18*/	volatile u_long		vme2_master2;
/*1c*/	volatile u_long		vme2_master3;
/*20*/	volatile u_long		vme2_master4;
/*24*/	volatile u_long		vme2_master4mod;
/*28*/	volatile u_long		vme2_masterctl;
#define VME2_MASTERCTL_4SHIFT	24
#define VME2_MASTERCTL_3SHIFT	16
#define VME2_MASTERCTL_2SHIFT	8
#define VME2_MASTERCTL_1SHIFT	0
#define VME2_MASTERCTL_D16	0x80
#define VME2_MASTERCTL_WP	0x40
#define VME2_MASTERCTL_AM	0x3f
#define	VME2_MASTERCTL_AM24SB	0x3f	/* A24 Supervisory Block Transfer */
#define	VME2_MASTERCTL_AM24SP	0x3e	/* A24 Supervisory Program Access */
#define	VME2_MASTERCTL_AM24SD	0x3d	/* A24 Supervisory Data Access */
#define	VME2_MASTERCTL_AM24UB	0x3b	/* A24 Non-priv. Block Transfer */
#define	VME2_MASTERCTL_AM24UP	0x3a	/* A24 Non-priv. Program Access */
#define	VME2_MASTERCTL_AM24UD	0x39	/* A24 Non-priv. Data Access */
#define	VME2_MASTERCTL_AM16S		0x2d	/* A16 Supervisory Access */
#define	VME2_MASTERCTL_AM16U		0x29	/* A16 Non-priv. Access */
#define	VME2_MASTERCTL_AM32SB	0x0f	/* A32 Supervisory Block Transfer */
#define	VME2_MASTERCTL_AM32SP	0x0e	/* A32 Supervisory Program Access */
#define	VME2_MASTERCTL_AM32SD	0x0d	/* A32 Supervisory Data Access */
#define	VME2_MASTERCTL_AM32UB	0x0b	/* A32 Non-priv. Block Transfer */
#define	VME2_MASTERCTL_AM32UP	0x0a	/* A32 Non-priv. Program Access */
#define	VME2_MASTERCTL_AM32UD	0x09	/* A32 Non-priv Data Access */

#define VME2_MASTERCTL_ALL	0xff
/*2c*/	volatile u_long		vme2_gcsrctl;
#define VME2_GCSRCTL_OFF	0xf0000000
#define VME2_GCSRCTL_MDEN4	0x00080000
#define VME2_GCSRCTL_MDEN3	0x00040000
#define VME2_GCSRCTL_MDEN2	0x00020000
#define VME2_GCSRCTL_MDEN1	0x00010000
#define VME2_GCSRCTL_I2EN	0x00008000	/* F decode (A24D16/A32D16) on */
#define VME2_GCSRCTL_I2WP	0x00004000	/* F decode write post */
#define VME2_GCSRCTL_I2SU	0x00002000	/* F decode is supervisor */
#define VME2_GCSRCTL_I2PD	0x00001000	/* F decode is program */
#define VME2_GCSRCTL_I1EN	0x00000800	/* short decode (A16Dx) on */
#define VME2_GCSRCTL_I1D16	0x00000400	/* short decode is D16 */
#define VME2_GCSRCTL_I1WP	0x00000200	/* short decode write post */
#define VME2_GCSRCTL_I1SU	0x00000100	/* short decode is supervisor */
#define VME2_GCSRCTL_ROMSIZE	0x000000c0	/* size of ROM */
#define VME2_GCSRCTL_ROMBSPD	0x00000038	/* speed of ROM */
#define VME2_GCSRCTL_ROMASPD	0x00000007	/* speed of ROM */
/*30*/	volatile u_long		vme2_dmactl;
/*34*/	volatile u_long		vme2_dmamode;
/*38*/	volatile u_long		vme2_dmaladdr;
/*3c*/	volatile u_long		vme2_dmavmeaddr;
/*40*/	volatile u_long		vme2_dmacount;
/*44*/	volatile u_long		vme2_dmatable;
/*48*/	volatile u_long		vme2_dmastat;
/*4c*/	volatile u_long		vme2_tcr;
#define VME2_TCR_1MS		(1 << 8)       	/* Watchdog 1 ms */
#define VME2_TCR_2MS		(2 << 8)       	/* Watchdog 2 ms */
#define VME2_TCR_4MS		(3 << 8)       	/* Watchdog 4 ms */
#define VME2_TCR_8MS		(4 << 8)       	/* Watchdog 8 ms */
#define VME2_TCR_16MS		(5 << 8)       	/* Watchdog 16 ms */
#define VME2_TCR_32MS		(6 << 8)       	/* Watchdog 32 ms */
#define VME2_TCR_64MS		(7 << 8)       	/* Watchdog 64 ms */
#define VME2_TCR_128MS		(8 << 8)       	/* Watchdog 128 ms */
#define VME2_TCR_256MS		(9 << 8)       	/* Watchdog 256 ms */
#define VME2_TCR_512MS		(10 << 8)	/* Watchdog 512 ms */
#define VME2_TCR_1S		(11 << 8)	/* Watchdog 1 s */
#define VME2_TCR_4S		(12 << 8)	/* Watchdog 4 s */
#define VME2_TCR_16S		(13 << 8)	/* Watchdog 16 s */
#define VME2_TCR_32S		(14 << 8)	/* Watchdog 32 s */
#define VME2_TCR_64S		(15 << 8)	/* Watchdog 64 s */
/*50*/	volatile u_long		vme2_t1cmp;
/*54*/	volatile u_long		vme2_t1count;
/*58*/	volatile u_long		vme2_t2cmp;
/*5c*/	volatile u_long		vme2_t2count;
/*60*/	volatile u_long		vme2_tctl;
#define VME2_TCTL1_CEN		0x01
#define VME2_TCTL1_COC		0x02
#define VME2_TCTL1_COVF		0x04
#define VME2_TCTL1_OVF		0xf0
#define VME2_TCTL2_CEN		(0x01 << 8)
#define VME2_TCTL2_COC		(0x02 << 8)
#define VME2_TCTL2_COVF		(0x04 << 8)
#define VME2_TCTL2_OVF		(0xf0 << 8)
#define VME2_TCTL_WDEN		0x00010000	/* Watchdog Enable */
#define VME2_TCTL_WDRSE		0x00020000	/* Watchdog Reset Enable */
#define VME2_TCTL_WDSL		0x00040000	/* local or system reset */
#define VME2_TCTL_WDBFE		0x00080000	/* Watchdog Board Fail Enable */
#define VME2_TCTL_WDTO		0x00100000	/* Watchdog Timeout Status */
#define VME2_TCTL_WDCC		0x00200000	/* Watchdog Clear Counter */
#define VME2_TCTL_WDCS		0x00400000	/* Watchdog Clear Timeout */
#define VME2_TCTL_SRST		0x00800000	/* system reset */
#define VME2_TCTL_RSWE		0x01000000	/* Reset Switch Enable */
#define VME2_TCTL_BDFLO		0x02000000	/* Assert Board Fail */
#define VME2_TCTL_CPURS		0x04000000	/* Clear Power-up Reset bit */
#define VME2_TCTL_PURS		0x08000000	/* Power-up Reset bit */
#define VME2_TCTL_BDFLI		0x10000000	/* Board Fail Status*/
#define VME2_TCTL_SYSFAIL	0x20000000	/* light SYSFAIL led */
#define VME2_TCTL_SCON		0x40000000	/* we are SCON */
/*64*/	volatile u_long		vme2_prescale;
/*68*/	volatile u_long		vme2_irqstat;
/*6c*/	volatile u_long		vme2_irqen;
/*70*/	volatile u_long		vme2_setsoftirq;	/* VME2_IRQ_SWx only */
/*74*/	volatile u_long		vme2_irqclr;		/* except VME2_IRQ_VMEx */
#define VME2_IRQ_ACF		0x80000000
#define VME2_IRQ_AB		0x40000000
#define VME2_IRQ_SYSF		0x20000000
#define VME2_IRQ_MWP		0x10000000
#define VME2_IRQ_PE		0x08000000
#define VME2_IRQ_V1IE		0x04000000
#define VME2_IRQ_TIC2		0x02000000
#define VME2_IRQ_TIC1		0x01000000
#define VME2_IRQ_VIA		0x00800000
#define VME2_IRQ_DMA		0x00400000
#define VME2_IRQ_SIG3		0x00200000
#define VME2_IRQ_SIG2		0x00100000
#define VME2_IRQ_SIG1		0x00080000
#define VME2_IRQ_SIG0		0x00040000
#define VME2_IRQ_LM1		0x00020000
#define VME2_IRQ_LM0		0x00010000
#define VME2_IRQ_SW7		0x00008000
#define VME2_IRQ_SW6		0x00004000
#define VME2_IRQ_SW5		0x00002000
#define VME2_IRQ_SW4		0x00001000
#define VME2_IRQ_SW3		0x00000800
#define VME2_IRQ_SW2		0x00000400
#define VME2_IRQ_SW1		0x00000200
#define VME2_IRQ_SW0		0x00000100
#define VME2_IRQ_SW(x)		((1 << (x))) << 8)
#define VME2_IRQ_SPARE		0x00000080
#define VME2_IRQ_VME7		0x00000040
#define VME2_IRQ_VME6		0x00000020
#define VME2_IRQ_VME5		0x00000010
#define VME2_IRQ_VME4		0x00000008
#define VME2_IRQ_VME3		0x00000004
#define VME2_IRQ_VME2		0x00000002
#define VME2_IRQ_VME1		0x00000001
#define VME2_IRQ_VME(x)		(1 << ((x) - 1))
/*78*/	volatile u_long		vme2_irql1;
#define VME2_IRQL1_ACFSHIFT	28
#define VME2_IRQL1_ABSHIFT	24
#define VME2_IRQL1_SYSFSHIFT	20
#define VME2_IRQL1_WPESHIFT	16
#define VME2_IRQL1_PESHIFT	12
#define VME2_IRQL1_V1IESHIFT	8
#define VME2_IRQL1_TIC2SHIFT	4
#define VME2_IRQL1_TIC1SHIFT	0
/*7c*/	volatile u_long		vme2_irql2;
#define VME2_IRQL2_VIASHIFT	28
#define VME2_IRQL2_DMASHIFT	24
#define VME2_IRQL2_SIG3SHIFT	20
#define VME2_IRQL2_SIG2SHIFT	16
#define VME2_IRQL2_SIG1SHIFT	12
#define VME2_IRQL2_SIG0SHIFT	8
#define VME2_IRQL2_LM1SHIFT	4
#define VME2_IRQL2_LM0SHIFT	0
/*80*/	volatile u_long		vme2_irql3;
#define VME2_IRQL3_SW7SHIFT	28
#define VME2_IRQL3_SW6SHIFT	24
#define VME2_IRQL3_SW5SHIFT	20
#define VME2_IRQL3_SW4SHIFT	16
#define VME2_IRQL3_SW3SHIFT	12
#define VME2_IRQL3_SW2SHIFT	8
#define VME2_IRQL3_SW1SHIFT	4
#define VME2_IRQL3_SW0SHIFT	0
/*84*/	volatile u_long		vme2_irql4;
#define VME2_IRQL4_SPARESHIFT	28
#define VME2_IRQL4_VME7SHIFT	24
#define VME2_IRQL4_VME6SHIFT	20
#define VME2_IRQL4_VME5SHIFT	16
#define VME2_IRQL4_VME4SHIFT	12
#define VME2_IRQL4_VME3SHIFT	8
#define VME2_IRQL4_VME2SHIFT	4
#define VME2_IRQL4_VME1SHIFT	0
/*88*/	volatile u_long		vme2_vbr;
#define VME2_SYSFAIL       (1 << 22)
#define VME2_IOCTL1_MIEN       	(1 << 23)
#define VME2_VBR_0SHIFT		28
#define VME2_VBR_1SHIFT		24
#define VME2_SET_VBR0(x)	((x) << VME2_VBR_0SHIFT)
#define VME2_SET_VBR1(x)	((x) << VME2_VBR_1SHIFT)
#define VME2_GET_VBR0(x)	((((x)->vme2_vbr >> 28) & 0xf) << 4)
#define VME2_GET_VBR1(x)	((((x)->vme2_vbr >> 24) & 0xf) << 4)
#define VME2_VBR_GPOXXXX	0x00ffffff
/*8c*/	volatile u_long		vme2_misc;
#define VME2_MISC_MPIRQEN	0x00000080	/* do not set */	
#define VME2_MISC_REVEROM	0x00000040	/* 167: dis eprom. 166: en flash */
#define VME2_MISC_DISSRAM	0x00000020	/* do not set */
#define VME2_MISC_DISMST	0x00000010	
#define VME2_MISC_NOELBBSY	0x00000008	/* do not set */
#define VME2_MISC_DISBSYT	0x00000004	/* do not set */
#define VME2_MISC_ENINT		0x00000002	/* do not set */
#define VME2_MISC_DISBGN	0x00000001	/* do not set */
};

#define VME2_A16D32BASE	0xffff0000UL
#define VME2_A16D32LEN	0x00010000UL
#define VME2_A32D16BASE	0xf1000000UL
#define VME2_A32D16LEN	0x01000000UL
#define VME2_A16D16BASE	0xffff0000UL
#define VME2_A16D16LEN	0x00010000UL
#define VME2_A24D16BASE	0xf0000000UL
#define VME2_A24D16LEN	0x01000000UL
#define VME2_A16BASE	0xffff0000UL
#define VME2_A24BASE	0xff000000UL

void * vmepmap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
void * vmemap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
int vmerw(struct vmesoftc *sc, struct uio *uio, int flags, int bus);
int vmeintr_establish(int vec, struct intrhand *ih);
int vme_findvec(void);
int vmescan(struct device *, void *, void *, int);

#endif /* __MVEME88K_DEV_VME_H__ */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.9 2003/06/04 04:11:37 deraadt Exp $ */
d15 5
@


1.1.1.3
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.11 2003/12/22 11:54:48 miod Exp $ */
d350 1
a350 1
#define VME2_MISC_MPIRQEN	0x00000080	/* do not set */
d353 1
a353 1
#define VME2_MISC_DISMST	0x00000010
d371 2
a372 1
void *vmepmap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
@


1.1.1.4
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.13 2003/12/28 19:44:26 miod Exp $ */
d37 103
d371 2
a372 2
void *vmepmap(struct device *sc, off_t vmeaddr, int len, int bustype);
int vmerw(struct device *sc, struct uio *uio, int flags, int bus);
a375 4

/* D16 access functions */
void d16_bcopy(const void *, void *, size_t);
void d16_bzero(void *, size_t);
@


1.1.1.5
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.15 2004/04/24 19:51:48 miod Exp $ */
d29 1
a29 1
#define	__MVEME88K_DEV_VME_H__
d32 3
a34 4
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	struct intrhand 	sc_abih;       /* `abort' switch */
d38 1
a38 1
 * XXX: this chip has some rather insane access rules!
d40 37
a76 67

#define	VME2_BASE		0xfff40000

#define	VME2_SADDR1		0x0000
#define	VME2_SADDR2		0x0004
#define	VME2_SLAVELMOD1		0x0008
#define	VME2_SLAVELMOD2		0x000c
#define	VME2_SLAVECTL		0x0010
#define	VME2_MASTER1		0x0014
#define	VME2_MASTER2		0x0018
#define	VME2_MASTER3		0x001c
#define	VME2_MASTER4		0x0020
#define	VME2_MASTER4MOD		0x0024
#define	VME2_MASTERCTL		0x0028
#define	VME2_GCSRCTL		0x002c
#define	VME2_DMACTL		0x0030
#define	VME2_DMAMODE		0x0034
#define	VME2_DMALADDR		0x0038
#define	VME2_DMAVMEADDR		0x003c
#define	VME2_DMACOUNT		0x0040
#define	VME2_DMATABLE		0x0044
#define	VME2_DMASTAT		0x0048
#define	VME2_TCR		0x004c
#define	VME2_T1CMP		0x0050
#define	VME2_T1COUNT		0x0054
#define	VME2_T2CMP		0x0058
#define	VME2_T2COUNT		0x005c
#define	VME2_TCTL		0x0060
#define	VME2_PRESCALE		0x0064
#define	VME2_IRQSTAT		0x0068
#define	VME2_IRQEN		0x006c
#define	VME2_SETSOFTIRQ		0x0070
#define	VME2_IRQCLR		0x0074
#define	VME2_IRQL1		0x0078
#define	VME2_IRQL2		0x007c
#define	VME2_IRQL3		0x0080
#define	VME2_IRQL4		0x0084
#define	VME2_VBR		0x0088
#define	VME2_MISC		0x008c

#define	VME2_SADDR_END		0xffff0000	/* VME address END & START */
#define	VME2_SADDR_START	0x0000ffff
#define	VME2_SADDR_LADDR	0xffff0000		/* local base address */
#define	VME2_SADDR_SIZE(mem)	(0x1000 - (mem) >> 16)	/* encoding of size */

#define	VME2_SLAVE_CHOOSE(bits, num) ((bits) << (16*((num)-1)))
#define	VME2_SLAVECTL_WP	0x00000100		/* write posting */
#define	VME2_SLAVECTL_SNP_NO	0x00000000		/* no snooping */
#define	VME2_SLAVECTL_SNP_SINK	0x00000200		/* sink data */
#define	VME2_SLAVECTL_SNP_INVAL	0x00000400		/* invalidate */
#define	VME2_SLAVECTL_ADDER	0x00000800		/* use adder */
#define	VME2_SLAVECTL_SUP	0x00000080		/* modifier bit */
#define	VME2_SLAVECTL_USR	0x00000040		/* modifier bit */
#define	VME2_SLAVECTL_A32	0x00000020		/* modifier bit */
#define	VME2_SLAVECTL_A24	0x00000010		/* modifier bit */
#define	VME2_SLAVECTL_D64	0x00000008		/* modifier bit */
#define	VME2_SLAVECTL_BLK	0x00000004		/* modifier bit */
#define	VME2_SLAVECTL_PGM	0x00000002		/* modifier bit */
#define	VME2_SLAVECTL_DAT	0x00000001		/* modifier bit */

#define	VME2_MASTERCTL_4SHIFT	24
#define	VME2_MASTERCTL_3SHIFT	16
#define	VME2_MASTERCTL_2SHIFT	8
#define	VME2_MASTERCTL_1SHIFT	0
#define	VME2_MASTERCTL_D16	0x80
#define	VME2_MASTERCTL_WP	0x40
#define	VME2_MASTERCTL_AM	0x3f
d92 164
a255 58
#define	VME2_MASTERCTL_ALL	0xff

#define	VME2_GCSRCTL_OFF	0xf0000000
#define	VME2_GCSRCTL_MDEN4	0x00080000
#define	VME2_GCSRCTL_MDEN3	0x00040000
#define	VME2_GCSRCTL_MDEN2	0x00020000
#define	VME2_GCSRCTL_MDEN1	0x00010000
#define	VME2_GCSRCTL_I2EN	0x00008000	/* F decode (A24D16/A32D16) on */
#define	VME2_GCSRCTL_I2WP	0x00004000	/* F decode write post */
#define	VME2_GCSRCTL_I2SU	0x00002000	/* F decode is supervisor */
#define	VME2_GCSRCTL_I2PD	0x00001000	/* F decode is program */
#define	VME2_GCSRCTL_I1EN	0x00000800	/* short decode (A16Dx) on */
#define	VME2_GCSRCTL_I1D16	0x00000400	/* short decode is D16 */
#define	VME2_GCSRCTL_I1WP	0x00000200	/* short decode write post */
#define	VME2_GCSRCTL_I1SU	0x00000100	/* short decode is supervisor */
#define	VME2_GCSRCTL_ROMSIZE	0x000000c0	/* size of ROM */
#define	VME2_GCSRCTL_ROMBSPD	0x00000038	/* speed of ROM */
#define	VME2_GCSRCTL_ROMASPD	0x00000007	/* speed of ROM */

#define	VME2_TCR_1MS		(1 << 8)       	/* Watchdog 1 ms */
#define	VME2_TCR_2MS		(2 << 8)       	/* Watchdog 2 ms */
#define	VME2_TCR_4MS		(3 << 8)       	/* Watchdog 4 ms */
#define	VME2_TCR_8MS		(4 << 8)       	/* Watchdog 8 ms */
#define	VME2_TCR_16MS		(5 << 8)       	/* Watchdog 16 ms */
#define	VME2_TCR_32MS		(6 << 8)       	/* Watchdog 32 ms */
#define	VME2_TCR_64MS		(7 << 8)       	/* Watchdog 64 ms */
#define	VME2_TCR_128MS		(8 << 8)       	/* Watchdog 128 ms */
#define	VME2_TCR_256MS		(9 << 8)       	/* Watchdog 256 ms */
#define	VME2_TCR_512MS		(10 << 8)	/* Watchdog 512 ms */
#define	VME2_TCR_1S		(11 << 8)	/* Watchdog 1 s */
#define	VME2_TCR_4S		(12 << 8)	/* Watchdog 4 s */
#define	VME2_TCR_16S		(13 << 8)	/* Watchdog 16 s */
#define	VME2_TCR_32S		(14 << 8)	/* Watchdog 32 s */
#define	VME2_TCR_64S		(15 << 8)	/* Watchdog 64 s */

#define	VME2_TCTL1_CEN		0x01
#define	VME2_TCTL1_COC		0x02
#define	VME2_TCTL1_COVF		0x04
#define	VME2_TCTL1_OVF		0xf0
#define	VME2_TCTL2_CEN		(0x01 << 8)
#define	VME2_TCTL2_COC		(0x02 << 8)
#define	VME2_TCTL2_COVF		(0x04 << 8)
#define	VME2_TCTL2_OVF		(0xf0 << 8)
#define	VME2_TCTL_WDEN		0x00010000	/* Watchdog Enable */
#define	VME2_TCTL_WDRSE		0x00020000	/* Watchdog Reset Enable */
#define	VME2_TCTL_WDSL		0x00040000	/* local or system reset */
#define	VME2_TCTL_WDBFE		0x00080000	/* Watchdog Board Fail Enable */
#define	VME2_TCTL_WDTO		0x00100000	/* Watchdog Timeout Status */
#define	VME2_TCTL_WDCC		0x00200000	/* Watchdog Clear Counter */
#define	VME2_TCTL_WDCS		0x00400000	/* Watchdog Clear Timeout */
#define	VME2_TCTL_SRST		0x00800000	/* system reset */
#define	VME2_TCTL_RSWE		0x01000000	/* Reset Switch Enable */
#define	VME2_TCTL_BDFLO		0x02000000	/* Assert Board Fail */
#define	VME2_TCTL_CPURS		0x04000000	/* Clear Power-up Reset bit */
#define	VME2_TCTL_PURS		0x08000000	/* Power-up Reset bit */
#define	VME2_TCTL_BDFLI		0x10000000	/* Board Fail Status*/
#define	VME2_TCTL_SYSFAIL	0x20000000	/* light SYSFAIL led */
#define	VME2_TCTL_SCON		0x40000000	/* we are SCON */
d257 10
a266 34
#define	VME2_IRQ_ACF		0x80000000
#define	VME2_IRQ_AB		0x40000000
#define	VME2_IRQ_SYSF		0x20000000
#define	VME2_IRQ_MWP		0x10000000
#define	VME2_IRQ_PE		0x08000000
#define	VME2_IRQ_V1IE		0x04000000
#define	VME2_IRQ_TIC2		0x02000000
#define	VME2_IRQ_TIC1		0x01000000
#define	VME2_IRQ_VIA		0x00800000
#define	VME2_IRQ_DMA		0x00400000
#define	VME2_IRQ_SIG3		0x00200000
#define	VME2_IRQ_SIG2		0x00100000
#define	VME2_IRQ_SIG1		0x00080000
#define	VME2_IRQ_SIG0		0x00040000
#define	VME2_IRQ_LM1		0x00020000
#define	VME2_IRQ_LM0		0x00010000
#define	VME2_IRQ_SW7		0x00008000
#define	VME2_IRQ_SW6		0x00004000
#define	VME2_IRQ_SW5		0x00002000
#define	VME2_IRQ_SW4		0x00001000
#define	VME2_IRQ_SW3		0x00000800
#define	VME2_IRQ_SW2		0x00000400
#define	VME2_IRQ_SW1		0x00000200
#define	VME2_IRQ_SW0		0x00000100
#define	VME2_IRQ_SW(x)		((1 << (x))) << 8)
#define	VME2_IRQ_SPARE		0x00000080
#define	VME2_IRQ_VME7		0x00000040
#define	VME2_IRQ_VME6		0x00000020
#define	VME2_IRQ_VME5		0x00000010
#define	VME2_IRQ_VME4		0x00000008
#define	VME2_IRQ_VME3		0x00000004
#define	VME2_IRQ_VME2		0x00000002
#define	VME2_IRQ_VME1		0x00000001
#define	VME2_IRQ_VME(x)		(1 << ((x) - 1))
d268 1
a268 67
#define	VME2_IRQL1_ACFSHIFT	28
#define	VME2_IRQL1_ABSHIFT	24
#define	VME2_IRQL1_SYSFSHIFT	20
#define	VME2_IRQL1_WPESHIFT	16
#define	VME2_IRQL1_PESHIFT	12
#define	VME2_IRQL1_V1IESHIFT	8
#define	VME2_IRQL1_TIC2SHIFT	4
#define	VME2_IRQL1_TIC1SHIFT	0

#define	VME2_IRQL2_VIASHIFT	28
#define	VME2_IRQL2_DMASHIFT	24
#define	VME2_IRQL2_SIG3SHIFT	20
#define	VME2_IRQL2_SIG2SHIFT	16
#define	VME2_IRQL2_SIG1SHIFT	12
#define	VME2_IRQL2_SIG0SHIFT	8
#define	VME2_IRQL2_LM1SHIFT	4
#define	VME2_IRQL2_LM0SHIFT	0

#define	VME2_IRQL3_SW7SHIFT	28
#define	VME2_IRQL3_SW6SHIFT	24
#define	VME2_IRQL3_SW5SHIFT	20
#define	VME2_IRQL3_SW4SHIFT	16
#define	VME2_IRQL3_SW3SHIFT	12
#define	VME2_IRQL3_SW2SHIFT	8
#define	VME2_IRQL3_SW1SHIFT	4
#define	VME2_IRQL3_SW0SHIFT	0

#define	VME2_IRQL4_SPARESHIFT	28
#define	VME2_IRQL4_VME7SHIFT	24
#define	VME2_IRQL4_VME6SHIFT	20
#define	VME2_IRQL4_VME5SHIFT	16
#define	VME2_IRQL4_VME4SHIFT	12
#define	VME2_IRQL4_VME3SHIFT	8
#define	VME2_IRQL4_VME2SHIFT	4
#define	VME2_IRQL4_VME1SHIFT	0

#define	VME2_SYSFAIL		(1 << 22)
#define	VME2_IOCTL1_MIEN	(1 << 23)
#define	VME2_VBR_0SHIFT		28
#define	VME2_VBR_1SHIFT		24
#define	VME2_SET_VBR0(x)	((x) << VME2_VBR_0SHIFT)
#define	VME2_SET_VBR1(x)	((x) << VME2_VBR_1SHIFT)
#define	VME2_GET_VBR0(x)	((((x) >> 28) & 0xf) << 4)
#define	VME2_GET_VBR1(x)	((((x) >> 24) & 0xf) << 4)
#define	VME2_VBR_GPOXXXX	0x00ffffff

#define	VME2_MISC_MPIRQEN	0x00000080	/* do not set */
#define	VME2_MISC_REVEROM	0x00000040	/* 167: dis eprom. 166: en flash */
#define	VME2_MISC_DISSRAM	0x00000020	/* do not set */
#define	VME2_MISC_DISMST	0x00000010
#define	VME2_MISC_NOELBBSY	0x00000008	/* do not set */
#define	VME2_MISC_DISBSYT	0x00000004	/* do not set */
#define	VME2_MISC_ENINT		0x00000002	/* do not set */
#define	VME2_MISC_DISBGN	0x00000001	/* do not set */

#define	VME2_A16D32BASE	0xffff0000UL
#define	VME2_A16D32LEN	0x00010000UL
#define	VME2_A32D16BASE	0xf1000000UL
#define	VME2_A32D16LEN	0x01000000UL
#define	VME2_A16D16BASE	0xffff0000UL
#define	VME2_A16D16LEN	0x00010000UL
#define	VME2_A24D16BASE	0xf0000000UL
#define	VME2_A24D16LEN	0x01000000UL
#define	VME2_A16BASE	0xffff0000UL
#define	VME2_A24BASE	0xff000000UL

void *vmepmap(struct device *sc, off_t vmeaddr, int bustype);
d271 1
a271 1
int vme_findvec(int);
d273 4
@


