head	1.2;
access;
symbols
	cvs-200405160640:1.1.1.8
	cvs-200401271800:1.1.1.7
	cvs-200401261630:1.1.1.7
	cvs-200401021645:1.1.1.6
	cvs-200312222040:1.1.1.6
	cvs-200310020700:1.1.1.5
	cvs-200309271030:1.1.1.5
	cvs-200309261655:1.1.1.5
	cvs-200309251530:1.1.1.5
	cvs-200308302005:1.1.1.4
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	cvs-200307072125:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200307021520:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2003.04.06.04.29.30;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.50.05;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.50.05;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.11.18.35.45;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.17.14.31.25;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.30.23.13.28;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.09.25.16.35.56;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.22.20.59.58;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.01.26.18.42.30;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.16.08.37.29;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove "some dead architectures".

These are all but i386 and x86-64 (which is not in the tree yet),
because I have no machines to work with.

Re-adding support should be fairly easy, just cvs adding a partial
OpenBSD checkout and pulling in stuff like kernel signal patch, humantime,
etc. which got added to i386 as well.

You will need gcc support as well.
@
text
@/*   $OpenBSD: eh.S,v 1.29 2003/01/14 03:20:16 miod Exp $   */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1998 Steve Murphree, Jr.
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * HISTORY
 * 1. Should get rid of SR0 reference for thread stuff.
 * 2. Make up my mind what is _kstack. I think it
 *       should be p->p_addr+UPAGES. (p_addr
 *         is pointing to user struct and swapin is
 *         making sure it is updated)
 *   Whatever is _kstack, its usage in this file should be
 *   revisited.
 */
 
 /*
 **************************************************************RCS******
 *
 *  -------------------------------------------------------------------
 * ;  In the following discussion, references are made to:             ;
 * ;          MC88100 - RISC MICROPROCESSOR USER'S MANUAL              ;
 * ;  (second edition). Reference in []s refer to section numbers.     ;
 * ;                                                                   ;
 * ;  This discussion assumes that you are at least vaguely familiar   ;
 * ;  with 88100 exception handling (chapter 6), the MACH kernel, and  ;
 * ;  that you have a brain (and use it while reading this).           ;
 * ;                                                                   ;
 * ;  I also assume (and hope) that you're not offended by             ;
 * ;  frequent misspellings.                                           ;
 * ;                                                                   ;
 * ;                       Jeffrey Friedl                              ;
 * ;            jfriedl@@rna.ncl.omron.co.jp             ;
 * ;                       December, 1989                              ;
 *  -------------------------------------------------------------------
 *
 * EXCEPTIONS, INTERRUPTS, and TRAPS
 * ---------------------------------
 * This is the machine exception handler.
 * In the MC88100, various "conditions" cause an exception, where
 * processing momentarily jumps here to "service" the exception,
 * and then continues where it left off.
 *
 * There are a number of different types of exceptions.
 * For example, exception #6 is the privilege violation exception which
 * is raised when the user tries to execute a supervisor-only instruction.
 *
 * Exception #1 is the interrupt exception, and is raised when an
 * outside device raises the INT line on the CPU.  This happens,
 * for example, when the clock signals that it is time for a context
 * switch, or perhaps the disk drive signaling that some operation
 * is complete.
 *
 * Traps are also exceptions.  Traps are ways for user programs to request
 * kernel operations.  For example, "tcnd eq0, r0, 128" will raise
 * exception 128, the system call exception.
 *
 *
 * SERVICING AN EXCEPTION
 * -----------------------
 * When an exception occurs, each control register is saved in its
 * respective shadow register and execution continues from the
 * appropriate exception handler.  The exception handler must
 *      - save the context from the time of the exception
 *      - service the exception
 *      - restore the context (registers, etc)
 *      - pick up from where the exception occurred.
 *
 * The context is saved on a stack. Actually, in the user_state area
 * in the PCB if the exception happens in user mode.
 *
 * Servicing the exception is usually straightforward and in fact not dealt
 * with very much here.  Usually a C routine is called to handle it.
 * For example, when a privilege exception is raised, the routine that sends
 * an "illegal instruction" signal to the offending process is called.
 *
 * When the exception has been serviced, the context is restored from the
 * stack and execution resumes from where it left off.
 *
 * In more detail:
 *
 * Saving the exception-time context.
 * ---------------------------------
 *     In saving the exception-time context, we copy the shadow and general
 * purpose registers to memory.  Since one exception may occur while
 * servicing another, the memory used to save the exception-time context may
 * not be static (i.e. the same every time).  Thus, memory on a stack is set
 * aside for the exception frame (area where the exception-time context is
 * saved). The same stack is also used when C routines are called (to
 * service the exception).
 *
 *    Each process has a stack in kernel space (called the "kernel stack",
 * short for "process's kernel stack) as well as the user space stack.  When
 * entering the kernel from user space, the kernel stack is unused.  On this
 * stack we save the exception state and (most likely call a C routine to)
 * service the exception.
 *
 * Before servicing an exception, several issues must be addressed.
 *
 * 1) When an interrupt is recognized by the hardware, the data pipeline is
 *    allowed to clear.  However, if one of these data accesses faults (bad
 *    reference, or a reference to a page which needs to be swapped in), that
 *    reference, as well as any others in the pipeline at the time (at most
 *    three total) are left there, to be taken care of by the exception
 *    handler [6.4.1].  This involves swapping in the proper page and
 *    manually doing the appropriate load or store.
 *
 *    The other (at most, two other) data accesses that might have been in
 *    the pipeline must also be manually completed (even though they may not
 *    be at fault [yes, that's a bad pun, thank you]).
 *
 * 2) If any of the (at most three) uncompleted data access in the pipeline
 *    are loads (from memory to a register), then the bit for the destination
 *    register is set in the SSBR.  Since the hardware will never complete
 *    that load (since we do it manually), the hardware will never clear that
 *    SSBR bit.  Thus, we must clear it manually.  If this isn't done, the
 *    system will hang waiting for a bit to clear that will never.
 *
 * 3) If the exception is the privilege violation exception, the bounds
 *    violation exception, or the misaligned access exception, the
 *    destination register bit in the SSBR may need to be cleared.
 *
 * 4) If the exception is one of the floating exceptions, then the
 *    destination register for that floating process won't be written,
 *    and the SSBR must be cleared explicitly.
 *
 * 5) The FPU must be enabled (as it is disabled by the exception processing
 *    hardware) and allowed to complete actions in progress. This is so
 *    so that it may be used in the servicing of any instruction.
 *    When the FPU is being restarted, operations attempting to complete
 *    may themselves fault (raising another exception).
 *
 * More on Restarting the FPU
 * --------------------------
 *   The manual [section 6.4.3.4] gives only minor mention to this
 * rather complex task.  Before the FPU is restarted all SSBR bits are
 * cleared for actions that the exception handler completes (as mentioned
 * above) so that the SSBR is clear unless there are FPU operations that
 * have not actually been completed (and hence not written to the registers).
 * Also, all control registers (at least all those that we care about) are
 * saved to the stack exception frame before the FPU is restarted (this
 * is important... the reason comes later).
 *
 * The FPU is restarted by doing an rte to a trap-not-taken (the rte
 * actually enables the fpu because we ensure that the EPSR has the
 * FPU-enable bit on; the trap-not-taken ensures anything in the FPU
 * completes by waiting until scoreboard register is clear).
 *
 * At the time the FPU is restarted (the rte to the trap-not-taken) the FPU
 * can write to ANY of the general registers.  Thus, we must make sure that
 * all general registers (r1..r31) are in their pre-exception state so that
 * when saved to the exception frame after the FPU is enabled, they properly
 * reflect any changes made by the FPU in being restarted.
 *
 * Because we can't save the pointer to the exception frame in a general
 * register during the FPU restart (it could get overwritten by the FPU!),
 * we save it in a control register, SR3, during the restart.
 *
 *
 * HOWEVER .....
 *
 * Because other uncompleted actions in the FPU may fault when the FPU is
 * restarted, a new exception may be raised during the restart. This may
 * happen recursively a number of times. Thus, during a restart, ANY register
 * whatsoever may be modified, including control registers.  Because of this
 * we must make sure that the exception handler preserves SR3 throughout
 * servicing an exception so that, if the exception had been raised during
 * an FPU restart, it is returned unmolested when control returns to the FPU
 * restart.
 *
 * Thus: if an exception is from kernel space, we MUST preserve SR3.
 * (if it from user space, no FPU-enable can be in progress and SR3 is
 *  unimportant).
 *
 * Now is a good time to recap SR0..SR3 usage:
 *   SR0 - Used for subroutine returns.  XXX smurph XXX2 not any more...
 *   SR1 - CPU flags (exception handler flags)
 *   SR2 - generally free
 *   SR3 - free only if the exception is from user mode
 *
 * Once the FPU has been restarted, the general registers are saved to the
 * exception frame.  If the exception is not the interrupt exception,
 * interrupts are enabled and any faulted data accesses (see above) are
 * serviced.  In either case, the exception is then serviced (usually by
 * calling a C routine).  After servicing, any faulted data accesses are
 * serviced (if it had been the interrupt exception).  The context is then
 * restored and control returns to where the exception occurred.
 *
 */

#include "assym.h"
#include <machine/asm.h>
#include <machine/board.h>
#include <machine/param.h>          /* CPU_ and BRD_ defines */
#include <machine/trap.h>           /* for T_ defines */
#include <machine/board.h>

/*
 * The exception frame as defined in "machine/pcb.h" (among other places) is
 * a bit outdated and needs to be changed. Until then, we'll define some
 * pseudo-fields there for our needs.
 *
 * EF_SR3    A place to save the exception-time SR3 from just after the
 *         time when an exception is raised until just after the FPU
 *         has been restarted.  This does not necessarly conflict with
 *        the general registers (though it can if you're not careful)
 *         and so we can use a spot later used to save a general register.
 *
 * EF_FLAGS  This is just the old EF_MODE. "EF_MODE" isn't a very good name.
 */
#define EF_SR3         (EF_R0 + 5)
#define EF_FLAGS      EF_MODE

#define INTSTACK	0   /* To make interupts use their own stack */
	data
	align 4
sbadcpupanic:
	string  "eh.S: bad cpu number in FLAGS"
	
	text
	align 8

Lbadcpupanic:
	or.u r2, r0, hi16(sbadcpupanic)
	or   r2, r2, lo16(sbadcpupanic)
	bsr  _C_LABEL(panic)

	align 8

#define OFF_VEC		0
#define OFF_EPSR	4
#define OFF_EXIP	8
#define OFF_ENIP	12
#define OFF_DSR		16
#define OFF_DLAR	20
#define OFF_DPAR	24
#define OFF_ISR		28
#define OFF_ILAR	32
#define OFF_IPAR	36
#define OFF_TMP		40


#define SAVE_CTX				; \
	stcr	r31, SRX			; \
	or.u	r31, r0,  hi16(_save_frame)	; \
	or	r31, r31, lo16(_save_frame)	; \
	/* save old R31 and other R registers */; \
	st.d	r0 , r31, GENREG_OFF(0)		; \
	st.d	r2 , r31, GENREG_OFF(2)		; \
	st.d	r4 , r31, GENREG_OFF(4)		; \
	st.d	r6 , r31, GENREG_OFF(6)		; \
	st.d	r8 , r31, GENREG_OFF(8)		; \
	st.d	r10, r31, GENREG_OFF(10)	; \
	st.d	r12, r31, GENREG_OFF(12)	; \
	st.d	r14, r31, GENREG_OFF(14)	; \
	st.d	r16, r31, GENREG_OFF(16)	; \
	st.d	r18, r31, GENREG_OFF(18)	; \
	st.d	r20, r31, GENREG_OFF(20)	; \
	st.d	r22, r31, GENREG_OFF(22)	; \
	st.d	r24, r31, GENREG_OFF(24)	; \
	st.d	r26, r31, GENREG_OFF(26)	; \
	st.d	r28, r31, GENREG_OFF(28)	; \
	st	r30, r31, GENREG_OFF(30)	; \
	ldcr	r1,  SRX			; \
	st	r1,  r31, GENREG_OFF(31)	; \
	ldcr	r1,  EPSR			; \
	ldcr	r2,  EXIP			; \
	ldcr	r3,  ENIP			; \
	st	r1,  r31, REG_OFF(EF_EPSR)	; \
	st	r2,  r31, REG_OFF(EF_EXIP)	; \
	st	r3,  r31, REG_OFF(EF_ENIP)	; \
	ldcr	r1,  DSR			; \
	ldcr	r2,  DLAR			; \
	ldcr	r3,  DPAR			; \
	st	r1,  r31, REG_OFF(EF_DSR)	; \
	st	r2,  r31, REG_OFF(EF_DLAR)	; \
	st	r3,  r31, REG_OFF(EF_DPAR)	; \
	ldcr	r1,  ISR			; \
	ldcr	r2,  ILAR			; \
	ldcr	r3,  IPAR			; \
	st	r1,  r31, REG_OFF(EF_ISR)	; \
	st	r2,  r31, REG_OFF(EF_ILAR)	; \
	st	r3,  r31, REG_OFF(EF_IPAR)	; \
	ldcr	r1, DSAP			; \
	ldcr	r2, DUAP			; \
	st	r1,  r31, REG_OFF(EF_DSAP)	; \
	st	r2,  r31, REG_OFF(EF_DUAP)	; \
	ldcr	r1, ISAP			; \
	ldcr	r2, IUAP			; \
	st	r1,  r31, REG_OFF(EF_ISAP)	; \
	st	r2,  r31, REG_OFF(EF_IUAP)	; \
	/* Restore r1, r2, r3, and r31	*/	; \
	ld	r1 , r31, GENREG_OFF(1)		; \
	ld.d	r2 , r31, GENREG_OFF(2)		; \
	ld	r31, r31, GENREG_OFF(31)

/***************************************************************************
 ***************************************************************************
 **
 ** #define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_CHECK)
 **
 ** This is the "exception processing preparaton" common to all exception
 ** processing.  It is used in the following manor:
 **
 **    ASGLOBAL(foo_handler)
 **           PREP("foo", 11, DEBUG_FOO_BIT, No_SSBR_Stuff, No_Precheck)
 **           CALL(_C_LABEL(trapXXX), T_FOO_FAULT, r31)
 **           DONE(DEBUG_FOO_BIT)
 **
 ** This defines the exception handler for the "foo" exception.
 ** The arguments ro PREP():
 **   NAME -    String for debugging (more info later)
 **   NUM  -    The exception number [see the manual, Table 6-1]
 **   BIT  -    Bit to check in eh_debug for debugging (more info later)
 **   SSBR_STUFF -
 **      If the exception might leave some bits in the SSBR set,
 **      this should indicate how they are cleared.
 **   FLAG_PRECHECK -
 **      This is for the data access exception only. See it for
 **      more info.
 **
 **
 ** What's in between PREP() and DONE() (usually a CALL) is the actual
 ** servicing of the interrupt.  During this time, any register may
 ** be used freely as they've all been saved in the exception frame
 ** (which is pointed-to by r31).
 **/

#ifdef M88100
#define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK)	; \
	xcr	FLAGS, FLAGS, SR1			; \
	FLAG_PRECHECK					; \
							; \
	/* the bsr later clobbers r1, so save now */	; \
	stcr	r1, SR2   /* r1 now free */		; \
	/* set or clear the FLAG_FROM_KERNEL bit */	; \
	ldcr	r1, EPSR				; \
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f		; \
	clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
	set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
							; \
	/* get a stack (exception frame) */		; \
1:	bsr	setup_phase_one				; \
							; \
	/* TMP2 now free -- use to set EF_VECTOR */	; \
	or	TMP2, r0, NUM				; \
	st	TMP2, r31, REG_OFF(EF_VECTOR)		; \
	/* TMP3 also free -- use to set last_vector */	; \
	or.u	TMP3, r0,   hi16(_last_vector)		; \
	st	TMP2, TMP3, lo16(_last_vector)		; \
							; \
	/* Clear any bits in the SSBR (held in TMP) */	; \
	/* SSBR_STUFF may be empty, though.         */	; \
	SSBR_STUFF					; \
							; \
	/* call setup_phase_two to restart the FPU  */	; \
	/* and to save all general registers.       */	; \
	bsr	setup_phase_two				; \
							; \
	/* All general regs free -- do any debugging */	; \
	PREP_DEBUG(BIT, NAME)
#endif /* m88100 */

#ifdef M88110
#define PREP2(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK); \
	SAVE_CTX					; \
	xcr	FLAGS, FLAGS, SR1			; \
	FLAG_PRECHECK					; \
	/* the bsr later clobbers r1, so save now */	; \
	stcr    r1, SR2   /* r1 now free */		; \
	/* set or clear the FLAG_FROM_KERNEL bit */	; \
	ldcr    r1, EPSR 				; \
	bb0.n   PSR_SUPERVISOR_MODE_BIT, r1, 1f 	; \
	clr     FLAGS, FLAGS, 1<FLAG_FROM_KERNEL> 	; \
	set     FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
							; \
	/* get a stack (exception frame) */		; \
1:	bsr	m88110_setup_phase_one			; \
							; \
	/* TMP2 now free -- use to set EF_VECTOR */	; \
	or	TMP2, r0, NUM				; \
	st	TMP2, r31, REG_OFF(EF_VECTOR)		; \
							; \
	/* call setup_phase_two to restart the FPU  */	; \
	/* and to save all general registers.       */	; \
	bsr	m88110_setup_phase_two			; \
							; \
	/* All general regs free -- do any debugging */	; \
	PREP_DEBUG(BIT, NAME)
#endif /* M88110 */

/* Some defines for use with PREP() */
#define No_SSBR_Stuff      /* empty */
#define Clear_SSBR_Dest      bsr clear_dest_ssbr_bit
#define No_Precheck      /* empty */
#define Data_Precheck \
   bb1.n   FLAG_IGNORE_DATA_EXCEPTION, FLAGS, ignore_data_exception
#define M88110_Data_Precheck \
   bb1.n   FLAG_IGNORE_DATA_EXCEPTION, FLAGS, m88110_ignore_data_exception

#ifdef EH_DEBUG
   /*
    * If we allow debugging, there is a variable "eh_debug"
    * in which there is a bit for each exception.  If the bit
    * is set for an exception, debugging information is printed
    * about that exception whenever it occurs.
    *
    * The bits are defined in "asm.h"
    */

GLOBAL(eh_debug)	word 0x00000000
   
   /*
    * additional pre-servicing preparation to be done when
    * debugging... check eh_debug and make the call if
    * need be.
    */
#define PREP_DEBUG(DebugNumber, Name)  \
	or.u	r2, r0, hi16(_eh_debug)		; \
	ld	r3, r2, lo16(_eh_debug)		; \
	bb0	DebugNumber, r3, 4f		; \
	/* call MY_info(ef,thread,flags,kind)*/	; \
	or	r2, r30, r0			; \
	ldcr	r3, SR0				; \
	ldcr	r4, SR1				; \
	or.u	r5, r0, hi16(2f)		; \
	or	r5, r5, lo16(2f)		; \
	bsr.n	_MY_info			; \
	subu	r31, r31, 40			; \
	br.n	4f				; \
	addu	r31, r31, 40			; \
	data					; \
	2: string Name				; \
	byte	0				; \
	align	4				; \
	text					; \
	4:


   /*
    * Post-servicing work to be done.
    * When debugging, check "eh_debug" and call the
    * debug routined if neeed be.
    *
    * Then, return from the interrupt handler.
    */
#define DONE(DebugNumber)  \
	or.u	r2, r0, hi16(_eh_debug)	; \
	ld	r3, r2, lo16(_eh_debug)	; \
	bb0	DebugNumber, r3, 2f	; \
	ldcr	r4, SR1			; \
	CALL(_MY_info_done, r31, r4)	; \
2:	br	return_from_exception_handler
#else
   /*
    * If not debugging, then no debug-prep to do.
    * Also, when you're done, you're done!   (no debug check).
    */
#define PREP_DEBUG(bit, name)
#define DONE(num)      br return_from_exception_handler
#endif

#ifdef M88100
/*#########################################################################*/
/*#### THE ACTUAL EXCEPTION HANDLER ENTRY POINTS for MVME18x ##############*/
/*#########################################################################*/

/* unknown exception handler */
GLOBAL(unknown_handler)
	PREP("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_UNKNOWN_BIT)

/* interrupt exception handler */
GLOBAL(interrupt_handler)
	PREP("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
	/* interrupt_func is set in mvme_bootstrap() */
	CALL(_C_LABEL(m88100_trap), T_INT, r30)
	/*CALLP(_interrupt_func, 1, r30) */
	DONE(DEBUG_INTERRUPT_BIT)

/* instruction access exception handler */
GLOBAL(instruction_access_handler)
	PREP("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_INSTFLT, r30)
	DONE(DEBUG_INSTRUCTION_BIT)

/*
 * data access exception handler --
 *  See badaddr() below for info about Data_Precheck.
 */
GLOBAL(data_exception_handler)
	PREP("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, Data_Precheck)
	DONE(DEBUG_DATA_BIT)

/* misaligned access exception handler */
GLOBAL(misaligned_handler)
	PREP("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_MISALGNFLT, r30)
	DONE(DEBUG_MISALIGN_BIT)

/* unimplemented opcode exception handler */
GLOBAL(unimplemented_handler)
	PREP("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_ILLFLT, r30)
	DONE(DEBUG_UNIMPLEMENTED_BIT)

/*
 * Some versions of the chip have a bug whereby false privilege
 * violation exceptions are raised. If the valid bit in the SXIP is clear,
 * it is false.  If so, just return.  The code before PREP handles this....
 */
GLOBAL(privilege_handler)
	stcr    r1, SR2    /* hold r1 for a moment */
	ldcr    r1, SXIP   /* look at the sxip... valid bit set? */
	bb1.n   RTE_VALID_BIT, r1, 1f /*skip over return if a valid exception*/
	ldcr    r1, SR2    /* restore r1 */
	RTE
1:	PREP("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_PRIVINFLT, r30) 
	DONE(DEBUG_PRIVILEGE_BIT)

/*
 * I'm not sure what the trap(T_BNDFLT,...) does, but it doesn't send
 * a signal to the process...
 */
GLOBAL(bounds_handler)
	PREP("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_BNDFLT, r30)
	DONE(DEBUG_BOUNDS_BIT)

/* integer divide-by-zero exception handler */
GLOBAL(divide_handler)
	PREP("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_ZERODIV, r30)
	DONE(DEBUG_DIVIDE_BIT)

/* integer overflow exception handler */
GLOBAL(overflow_handler)
	PREP("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_OVFFLT, r30)
	DONE(DEBUG_OVERFLOW_BIT)

/* Floating-point precise handler */
#define FPp_SSBR_STUFF bsr clear_FPp_ssbr_bit
GLOBAL(fp_precise_handler)
	PREP("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF, No_Precheck)
	CALL(_m88100_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/
	DONE(DEBUG_FPp_BIT)

/* Floating-point imprecise handler */
#define FPi_SSBR_STUFF  bsr clear_FPi_ssbr_bit
GLOBAL(fp_imprecise_handler)
	PREP("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF, No_Precheck)
	CALL(_Xfp_imprecise, r0, r30) /*call fp_imprecise(??,exception_frame)*/
	DONE(DEBUG_FPi_BIT)

/* All standard system calls.  */
GLOBAL(syscall_handler)
	PREP("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r13, r30, GENREG_OFF(13)
	CALL(_m88100_syscall, r13, r30) /* system call no. is in r13 */
	DONE(DEBUG_SYSCALL_BIT)

/* trap 496 comes here */
GLOBAL(bugtrap)
	PREP("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
	DONE(DEBUG_BUGCALL_BIT)

GLOBAL(sigsys)
	PREP("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_SIGSYS, r30)
	DONE(DEBUG_SIGSYS_BIT)

GLOBAL(sigtrap)
	PREP("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_SIGTRAP, r30)
	DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(stepbpt)
	PREP("stepbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_STEPBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(userbpt)
	PREP("userbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_USERBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)

#if DDB
GLOBAL(break)
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_KDB_BREAK, r30)
	DONE(DEBUG_BREAK_BIT)

GLOBAL(trace)
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_KDB_TRACE, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(entry)
	PREP("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_KDB_ENTRY, r30)
	DONE(DEBUG_KDB_BIT)

#else /* else not DDB */
GLOBAL(break)
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_BREAK_BIT)

GLOBAL(trace)
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(entry)
	PREP("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_KDB_BIT)
#endif   /* DDB */

/*--------------------------------------------------------------------------*/

/*
 * The error exception handler.
 * The error exception is raised when any other non-trap exception is raised
 * while shadowing is off. This is Bad News.
 *
 * The shadow registers are not valid in this case (shadowing was off, ne).
 * R1-R31 may be interesting though, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(error_handler)
        /* pick up the slavestack */
	or	r26, r0, r31           /* save old stack */
	or.u	r31, r0,  hi16(_intstack_end)
	or	r31, r31, lo16(_intstack_end)

	/* zero the stack, so we'll know what we're lookin' at */
	or.u	r27, r0,  hi16(_intstack)
	or	r27, r27, lo16(_intstack)
1:	cmp	r28, r27, r31
	bb1	ge,  r28, 2f   /* branch if at the end of the stack */
	st	r0,  r0,  r27
	br.n	1b
	addu	r27, r27, 4   /* bump up */
2:   /* stack has been cleared */

   /* ensure that stack is 8-byte aligned */
        clr     r31, r31, 3<0>  /* round down to 8-byte boundary */

   /* create exception frame on stack */
        subu    r31, r31, SIZEOF_EF             /* r31 now our E.F. */

   /* save old R31 and other R registers */
        st.d    r0 , r31, GENREG_OFF(0)
        st.d    r2 , r31, GENREG_OFF(2)
        st.d    r4 , r31, GENREG_OFF(4)
        st.d    r6 , r31, GENREG_OFF(6)
        st.d    r8 , r31, GENREG_OFF(8)
        st.d    r10, r31, GENREG_OFF(10)
        st.d    r12, r31, GENREG_OFF(12)
        st.d    r14, r31, GENREG_OFF(14)
        st.d    r16, r31, GENREG_OFF(16)
        st.d    r18, r31, GENREG_OFF(18)
        st.d    r20, r31, GENREG_OFF(20)
        st.d    r22, r31, GENREG_OFF(22)
        st.d    r24, r31, GENREG_OFF(24)
        st      r30, r31, GENREG_OFF(30)
	st	r26, r31, GENREG_OFF(31)
	
	/* save shadow registers (are OLD if error_handler, though) */
	ldcr	r10, EPSR
	st	r10, r31, REG_OFF(EF_EPSR)
	ldcr	r10, SXIP
	st	r10, r31, REG_OFF(EF_SXIP)
	ldcr	r10, SNIP
	st	r10, r31, REG_OFF(EF_SNIP)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)
	ldcr	r10, SFIP
	st	r10, r31, REG_OFF(EF_SFIP)
	ldcr	r10, SSBR
	st	r10, r31, REG_OFF(EF_SSBR)
	stcr	r0,  SSBR  /* won't want shadow bits bothering us later */
	ldcr	r10, DMT0
	st	r10, r31, REG_OFF(EF_DMT0)
	ldcr	r11, DMD0
	st	r11, r31, REG_OFF(EF_DMD0)
	ldcr	r12, DMA0
	st	r12, r31, REG_OFF(EF_DMA0)
	ldcr	r10, DMT1
	st	r10, r31, REG_OFF(EF_DMT1)
	FLUSH_PIPELINE
	ldcr	r11, DMD1
	st 	r11, r31, REG_OFF(EF_DMD1)
	ldcr	r12, DMA1
	st	r12, r31, REG_OFF(EF_DMA1)

	ldcr	r10, DMT2
	st	r10, r31, REG_OFF(EF_DMT2)
	ldcr	r11, DMD2
	st	r11, r31, REG_OFF(EF_DMD2)
	ldcr	r12, DMA2
	st	r12, r31, REG_OFF(EF_DMA2)
	
	/* shove sr2 into EF_FPLS1 */
	ldcr	r10, SR2
	st	r10, r31, REG_OFF(EF_FPLS1)

	/* shove sr3 into EF_FPHS2 */
	ldcr	r10, SR3
	st	r10, r31, REG_OFF(EF_FPHS2)

	/* error vector is 10 */
	or	r10, r0, 10
	st	r10, r31, REG_OFF(EF_VECTOR)

#if 0 /* MVME188 */
#define IST_REG      0xfff84040	/* interrupt status addr */
	/* check if it's a mvme188 */
	or.u	r10,  r0,   hi16(_brdtyp)
	ld	r11,  r10,  lo16(_brdtyp)
	cmp	r10,  r11,  BRD_188
	bb1	ne,   r10,  3f
	or.u	r10,  r0,   hi16(IST_REG) /* interrupt status register */
	ld	r11,  r10,  lo16(IST_REG)
	st	r11, r31,   REG_OFF(EF_MASK) /* put in EF_MASK for regdump */ 
#endif /* MVME188 */ 
	/*
	 * Cheap way to enable FPU and start shadowing again.
	 */
3:      ldcr    r10, PSR
        clr     r10, r10, 1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
        clr     r10, r10, 1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
        stcr    r10, PSR  /* bang */
	FLUSH_PIPELINE

	/* put pointer to regs into r30... r31 will become a simple stack */
	or	r30, r31, r0

        subu	r31, r31, 0x10 /* make some breathing space */
        st	r30, r31, 0x0c /* store frame pointer on the st */
        st	r30, r31, 0x08 /* store again for the debugger to recognize */ 
	or.u	r20,  r0, hi16(0x87654321)
	or	r20, r20, lo16(0x87654321)
	st	r20, r31, 0x04
	st	r20, r31, 0x00

        CALL(_C_LABEL(error_fault), r30, r30)

        /* TURN INTERUPTS back on */
        ldcr r1, PSR
	clr  r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
        stcr r1, PSR
        FLUSH_PIPELINE

GLOBAL(error_loop) bsr _error_loop
   /* never returns*/

/*
 * The reset exception handler.
 * The reset exception is raised when the RST signal is asserted (machine 
 * is reset), the value of VBR is changed after exceptions are enabled, 
 * or when a jmp, br/bsr to addr 0 (accidents do happen :-)
 *
 * To tell the difference, you should check the value of r1 and the valid
 * bit of SXIP.
 *
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0 
 * to handle it!!! 
 *
 * This is totaly different than _error_handler.  Shadowing might or 
 * might not be on.
 * R1-R31 could tell u alot about what happend, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(reset_handler)
        /* pick up the slavestack */
	or	r26, r0, r31           /* save old stack */
	or.u	r31, r0,  hi16(_intstack_end)
	or	r31, r31, lo16(_intstack_end)

	/* zero the stack, so we'll know what we're lookin' at */
	or.u	r27, r0,  hi16(_intstack)
	or	r27, r27, lo16(_intstack)
1:	cmp	r28, r27, r31
	bb1	ge,  r28, 2f   /* branch if at the end of the stack */
	st	r0,  r0,  r27
	br.n	1b
	addu	r27, r27, 4   /* bump up */
2:	/* stack has been cleared */

	/* ensure that stack is 8-byte aligned */
	clr	r31, r31, 3<0>  /* round down to 8-byte boundary */

	/* create exception frame on stack */
	subu	r31, r31, SIZEOF_EF             /* r31 now our E.F. */

	/* save old R31 and other R registers */
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st	r30, r31, GENREG_OFF(30)
	st	r26, r31, GENREG_OFF(31)

	/* save shadow registers */
	ldcr	r10, EPSR
	st	r10, r31, REG_OFF(EF_EPSR)
	ldcr	r10, SXIP
	st	r10, r31, REG_OFF(EF_SXIP)
	ldcr	r10, SNIP
	st	r10, r31, REG_OFF(EF_SNIP)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)
	ldcr	r10, SFIP
	st	r10, r31, REG_OFF(EF_SFIP)
	ldcr	r10, SSBR
	st	r10, r31, REG_OFF(EF_SSBR)
	stcr	r0,  SSBR  /* won't want shadow bits bothering us later */

	ldcr	r10, DMT0
	st	r10, r31, REG_OFF(EF_DMT0)
	ldcr	r11, DMD0
	st	r11, r31, REG_OFF(EF_DMD0)
	ldcr	r12, DMA0
	st	r12, r31, REG_OFF(EF_DMA0)

	ldcr	r10, DMT1
	st	r10, r31, REG_OFF(EF_DMT1)
	FLUSH_PIPELINE
	ldcr	r11, DMD1
	st 	r11, r31, REG_OFF(EF_DMD1)
	ldcr	r12, DMA1
	st	r12, r31, REG_OFF(EF_DMA1)

	ldcr	r10, DMT2
	st	r10, r31, REG_OFF(EF_DMT2)
	ldcr	r11, DMD2
	st	r11, r31, REG_OFF(EF_DMD2)
	ldcr	r12, DMA2
	st	r12, r31, REG_OFF(EF_DMA2)

	/* shove sr2 into EF_FPLS1 */
	ldcr	r10, SR2
	st	r10, r31, REG_OFF(EF_FPLS1)

	/* shove sr3 into EF_FPHS2 */
	ldcr	r10, SR3
	st	r10, r31, REG_OFF(EF_FPHS2)

	/* error vector is zippo numero el'zeroooo */
	st	r0,  r31, REG_OFF(EF_VECTOR)

	/*
	 * Cheap way to enable FPU and start shadowing again.
	 */
        ldcr    r10, PSR
        clr     r10, r10, 1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
        clr     r10, r10, 1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
   
        stcr    r10, PSR  /* bang */
	FLUSH_PIPELINE

	/* put pointer to regs into r30... r31 will become a simple stack */
	or	r30, r31, r0

	subu	r31, r31, 0x10 /* make some breathing space */
	st 	r30, r31, 0x0c /* store frame pointer on the st */
	st 	r30, r31, 0x08 /* store again for the debugger to recognize */ 
	or.u	r20,  r0, hi16(0x87654321)
	or	r20, r20, lo16(0x87654321)
	st	r20, r31, 0x04
	st	r20, r31, 0x00

	CALL(_C_LABEL(error_reset), r30, r30)

	/* TURN INTERUPTS back on */
	ldcr r1, PSR
	clr  r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr r1, PSR
	FLUSH_PIPELINE

GLOBAL(error_loop2) bsr _error_loop2
/* never returns*/

/*
 * This is part of baddadr (below).
 */
ASGLOBAL(ignore_data_exception)
	/******************************************************\
	*  SR0: pointer to the current thread structure        *
	*  SR1: previous FLAGS reg                *
	*  SR2: free                                           *
	*  SR3: must presere                                   *
	*  FLAGS:  CPU status flags                            *
	\******************************************************/
	xcr   FLAGS, FLAGS, SR1   /* replace SR1, FLAGS */

	/*
	 * For more info, see badaddr() below.
	 *
	 * We just want to jump to "badaddr__return_nonzero" below.
	 *
	 * We don't worry about trashing R2 here because we're
	 * jumping back to the function badaddr() where we're allowd
	 * to blast r2..r9 as we see fit.
	 */

	/* the "+2" below is to set the VALID bit. */
	or.u	r2, r0, hi16(badaddr__return_nonzero + 2)
	or	r2, r2, lo16(badaddr__return_nonzero + 2)
	stcr	r2, SNIP   /* Make it the next instruction to execute */
	
	addu	r2, r2, 4
	stcr	r2, SFIP   /* and the next one after that, too. */
	stcr	r0, SSBR   /* make the scoreboard happy. */
1:   

	/* the following jumps to "badaddr__return_nonzero" in below */
	RTE
#endif /* m88100 */

#ifdef M88110
/*
 * This is part of baddadr (below).
 */
ASGLOBAL(m88110_ignore_data_exception)
	/******************************************************\
	*  SR0: pointer to the current thread structure        *
	*  SR1: previous FLAGS reg                             *
	*  SR2: free                                           *
	*  SR3: must preserve                                  *
	*  FLAGS:  CPU status flags                            *
	\******************************************************/
	xcr   FLAGS, FLAGS, SR1   /* replace SR1, FLAGS */

	/*
	 * For more info, see badaddr() below.
	 *
	 * We just want to jump to "m88110_badaddr__return_nonzero" below.
	 *
	 * We don't worry about trashing R2 here because we're
	 * jumping back to the function badaddr() where we're allowd
	 * to blast r2..r9 as we see fit.
	 */

	or.u	r2, r0, hi16(m88110_badaddr__return_nonzero)
	or	r2, r2, lo16(m88110_badaddr__return_nonzero)
	stcr	r2, EXIP   /* Make it the next instruction to execute */
	
	/* the following jumps to "m88110_badaddr__return_nonzero" below */ 
	NOP
	RTE
#endif /* M88110 */
	

/*
 * extern boolean_t badaddr(unsigned addr, unsigned len)
 *
 * Returns true (non-zero) if the given LEN bytes starting at ADDR are
 * not all currently accessable by the kernel.
 *
 * If all LEN bytes starting at ADDR are accessable, zero is returned.
 *
 * Len may be be 1, 2, or 4.
 *
 * This is implementd by setting a special flag in SR1 before trying to access
 * the given address. If a data access exception is raised, the address
 * is inaccessable. The exception handler will notice the special CPU flag
 * and not try to swap the address in. Rather, it will return to
 * "badaddr__return_nonzero" in this routine so that we may return non-zero
 * to the calling routine.
 *
 * If no fault is raised, we continue to where we return zero to the calling
 * routine (after removing the special CPU flag).
 */

GLOBAL(badaddr)
	/*
	 * Disable interrupts ... don't want a context switch while we're
	 * doing this! Also, save the old PSR in R8 to restore later.
	 */
	ldcr	r8, PSR
	set	r4, r8, 1<PSR_INTERRUPT_DISABLE_BIT>
	FLUSH_PIPELINE
	stcr	r4, PSR

	ldcr	r5, SR1
	set	r5, r5, 1<FLAG_IGNORE_DATA_EXCEPTION>
	/* resetting r5 to SR1 done in the delay slot below. */

	/*
	 * If it's a word we're doing, do that here. Otherwise,
	 * see if it's a halfword.....
	 */
	sub	r6,  r3, 4
	bcnd.n	ne0, r6, badaddr__maybe_halfword
	stcr	r5,  SR1
	FLUSH_PIPELINE

	/*
	 * It's a bad address if it's misaligned.
	 */
	bb1   0, r2, badaddr__return_nonzero
	bb1   1, r2, badaddr__return_nonzero
	/*
	 * The next line will either fault or not. If it faults, execution
	 * will go to:  data_access_handler (see above)
	 * and then to: ignore_data_exception (see above)
	 * and then to: badaddr__return_nonzero (see below)
	 * which will return to the calling function.
	 *
	 * If there is no fault, execution just continues as normal.
	 */
	ld   r5, r2, 0
	FLUSH_PIPELINE
	br.n   badaddr__return
	or   r2, r0, r0   /* indicate a zero (address not bad) return.*/

badaddr__maybe_halfword:
	/* More or less like the code for checking a word above */
	sub   r6, r3, 2
	bcnd   ne0, r6, badaddr__maybe_byte

	/* it's bad if it's misaligned */
	bb1   0, r2, badaddr__return_nonzero

	FLUSH_PIPELINE
	ld.h   r5, r2, 0
	FLUSH_PIPELINE
	br.n   badaddr__return
	or   r2, r0, r0

badaddr__maybe_byte:
	/* More or less like the code for checking a word above */
	sub   r6, r3, 1
	bcnd   ne0, r6, badaddr__unknown_size
	FLUSH_PIPELINE
	ld.b   r5, r2, 0
	FLUSH_PIPELINE
	br.n   badaddr__return
	or   r2, r0, r0
badaddr__unknown_size:
#ifndef NDEBUG
	data
1: 	string "bad length (%d) to badaddr() from 0x%x"
	text
	or.u   r2, r0, hi16(1b)
	or     r2, r2, lo16(1b)
	or   r4, r0, r1
	bsr   _C_LABEL(printf)
	or.u   r2, r0, hi16(1b)
	or     r2, r2, lo16(1b)
	bsr   _C_LABEL(panic)
	/*NOTREACHED*/
#endif

ASGLOBAL(badaddr__return_nonzero)
	or   r2, r0, 1
	/* fall through to badaddr__return */

ASGLOBAL(badaddr__return)
	ldcr   r4, SR1
	clr   r4, r4, 1<FLAG_IGNORE_DATA_EXCEPTION>
	stcr   r4, SR1

	/*
	 * Restore the PSR to what it was before.
	 * The only difference is that we might be enabling interrupts
	 * (which we turned off above).  If interrupts were already off,
	 * we do not want to turn them on now, so we just restore from
	 * where we saved it.
	 */
	FLUSH_PIPELINE
	stcr   r8, PSR
	jmp     r1

ASGLOBAL(m88110_badaddr__return_nonzero)
	/* 
	 * On mc88110, we possibly took an exception 
	 * and we have to clear DSR after the rte
	 * instruction clears the EFRZ bit in 
	 * the PSR. 
	 */
	stcr r0, DSR	/* Clear DSR reg on mc88110 */
	stcr r0, DLAR	/* Clear DLAR reg on mc88110 */
	br.n badaddr__return_nonzero
	stcr r0, DPAR	/* Clear DPAR reg on mc88110 */

/*
******************************************************************************
******************************************************************************
******************************************************************************
*/

#ifdef M88100 

ASGLOBAL(setup_phase_one)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: saved copy of exception-time r1                          *
	* SR3: must be preserved .. may be the exception-time stack     *
	* r1: return address to calling exception handler               *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*    Decide where we're going to put the exception frame.       *
	*   Might be at the end of R31, SR3, or the thread's            *
	*   pcb.                                                        *
	\***************************************************************/
	
	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
	NOP
	xcr	r1,   r1,   SR2
	NOP
	NOP
	NOP

	bb1	FLAG_ENABLING_FPU, FLAGS, use_SR3_pcb
	/* are we coming in from user mode? If so, pick up thread pcb */
	bb0	FLAG_FROM_KERNEL, FLAGS, pickup_stack

	/* Interrupt in kernel mode, not FPU restart */
ASGLOBAL(already_on_kernel_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; may be important for other exceptions *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   We're already on the kernel stack, but not having           *
	*   needed to use SR3. We can just make room on the             *
	*    stack (r31) for our exception frame.                       *
	\***************************************************************/
	subu	r31,  r31,  SIZEOF_EF            /* r31 now our E.F. */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st	r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/

	ldcr	r1,   SR3                        /* save previous SR3 */
	st	r1,   r31,  REG_OFF(EF_SR3)

	addu	r1,   r31,  SIZEOF_EF            /* save previous r31 */
	br.n	have_pcb
	st 	r1,   r31,  GENREG_OFF(31)


ASGLOBAL(use_SR3_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; exception-time stack pointer          *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   An exception occured while enabling the FPU. Since r31      *
	*   is the user's r31 while enabling the FPU, we had put        *
	*   our pcb pointer into SR3, so make room from                 *
	*   there for our stack pointer.                                *
	*       We need to check if SR3 is the old stack pointer or the *
	*       pointer off to the user pcb. If it pointing to the user *
	*       pcb, we need to pick up the kernel stack. Otherwise     *
	*       we need to allocate a frame upon it.                    *
	*       We look at the EPSR to see if it was from user mode     *
	*       Unfortunately, we have no registers free at the moment  *
	*       But we know register 0 in the pcb frame will always be  *
	*       zero, so we can use it as scratch storage.              *
	*                                                               *
	*                                                               *
	\***************************************************************/
	xcr	r30,  r30,  SR3                  /* r30 = old exception frame */ 
	st	r1,   r30,  GENREG_OFF(0)        /* free up r1 */
	ld	r1,   r30,  REG_OFF(EF_EPSR)     /* get back the epsr */
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f  /* if user mode */
	ld	r1,   r30,  GENREG_OFF(0)        /* restore r1 */
	/* we were in kernel mode - dump frame upon the stack */
	st	r0,   r30,  GENREG_OFF(0)        /* repair old frame */
	subu	r30,  r30,  SIZEOF_EF            /* r30 now our E.F. */
	st	FLAGS,r30,  REG_OFF(EF_FLAGS)    /* save flags */
	st	r1,   r30,  GENREG_OFF(1)        /* save prev. r1 (now r1 free) */

	st	r31,  r30,  GENREG_OFF(31)       /* save previous r31 */
	or	r31,  r0,   r30                  /* make r31 our pointer. */ 
	addu	r30,  r30,  SIZEOF_EF            /* r30 now has previous SR3 */ 
	st	r30,  r31,  REG_OFF(EF_SR3)      /* save previous SR3 */
	br.n	have_pcb
	xcr	r30,  r30,  SR3                  /* restore r30 */
1:
	/* we took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30) */
	or.u	r1,   r0,   hi16(_kstack)
	ld	r1,   r1,   lo16(_kstack)
	addu	r1,   r1,   USIZE-SIZEOF_EF
	st	FLAGS,r1,   REG_OFF(EF_FLAGS)    /* store flags */
	st	r31,  r1,   GENREG_OFF(31)       /* store r31 - now free */ 
	st	r30,  r1,   REG_OFF(EF_SR3)      /* store old SR3 (pcb) */
	or	r31,  r1,   r0                   /* make r31 our exception frame pointer */
	ld	r1,   r30,  GENREG_OFF(0)        /* restore old r1 */
	st	r0,   r30,  GENREG_OFF(0)        /* repair that frame */
	st	r1,   r31,  GENREG_OFF(1)        /* store r1 in its proper place */ 
	br.n	have_pcb
	xcr	r30,  r30,  SR3                  /* restore r30 */

ASGLOBAL(pickup_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* FLAGS: CPU status flags                                      *
	***************************************************            *
	* immediate goal:                                              *
	*    Since we're servicing an exception from user mode, we     *
	*   know that SR3 is free.  We use it to free up a temp.       *
	*   register to be used in getting the thread's pcb            *
	\***************************************************************/
	stcr	r31,  SR3      /* save previous r31 */

	/* switch to the thread's kernel stack. */
	or.u	r31,  r0,   hi16(_curpcb)
	ld	r31,  r31,  lo16(_curpcb)
	addu	r31,  r31,  PCB_USER_STATE       /* point to user save area */ 
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st	r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/ 
	ldcr	r1,   SR3                        /* save previous r31 */
	st	r1,   r31,  GENREG_OFF(31)
	/*FALLTHROUGH */

ASGLOBAL(have_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* r1:  free                                                    *
	* FLAGS: CPU status flags                                      *
	* r31: our exception frame                                     *
	* Valid in the exception frame:                                *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception SR3, if appropriate.                             *
	***************************************************            *
	* immediate goal:                                              *
	*    Save the shadow registers that need to be saved to        *
	*   the exception frame.                                       *
	\***************************************************************/
	stcr	TMP, SR3   /* free up TMP, TMP2, TMP3 */
	SAVE_TMP2
	SAVE_TMP3

	/* save some exception-time registers to the exception frame */
	ldcr	TMP,  EPSR
	st	TMP,  r31,  REG_OFF(EF_EPSR)
	ldcr	TMP3, SNIP
	st	TMP3, r31,  REG_OFF(EF_SNIP)
	ldcr	TMP2, SFIP
	st	TMP2, r31,  REG_OFF(EF_SFIP)
	/* get and store the cpu number */	
	extu	TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>  /* TMP = cpu# */
	st	TMP,  r31,  REG_OFF(EF_CPU)
   
	/*
	 * Save Pbus fault status register from data and inst CMMU.
	 */
#ifdef MVME188
	/* check if it's a mvme188 */
	or.u	TMP,  r0,   hi16(_brdtyp)
	ld	TMP2, TMP,  lo16(_brdtyp)
	cmp	TMP,  TMP2, BRD_188
	bb1	ne,   TMP,  5f
	
	extu	TMP,  FLAGS, FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
	cmp	TMP2, TMP, 0x0				/* CPU0 ? */     
	bb1	eq,   TMP2, 1f
	cmp	TMP2, TMP, 0x1				/* CPU1 ? */     
	bb1	eq,   TMP2, 2f
	cmp	TMP2, TMP, 0x2				/* CPU2 ? */     
	bb1	eq,   TMP2, 3f
	cmp	TMP2, TMP, 0x3				/* CPU3 ? */     
	bb1	eq,   TMP2, 4f
	/* Arrrrg! bad cpu# */ 
	br	Lbadcpupanic				
1:
	/* must be CPU0 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I0)
	ld	TMP2, TMP,  lo16(VME_CMMU_I0) + 0x108
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D0)
	ld	TMP2, TMP,  lo16(VME_CMMU_D0) + 0x108
	st	TMP2, r31,  REG_OFF(EF_DPFSR)
	br	pfsr_done
2:
	/* must be CPU1 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I1)
	ld	TMP2, TMP,  lo16(VME_CMMU_I1) + 0x108
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D1)
	ld	TMP2, TMP,  lo16(VME_CMMU_D1) + 0x108
	st	TMP2, r31,  REG_OFF(EF_DPFSR)
	br	pfsr_done
3:
	/* must be CPU2 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I2)
	ld	TMP2, TMP,  lo16(VME_CMMU_I2) + 0x108
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D2)
	ld	TMP2, TMP,  lo16(VME_CMMU_D2) + 0x108
	st	TMP2, r31,  REG_OFF(EF_DPFSR)
	br	pfsr_done
4:
	/* must be CPU3 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I3)
	ld	TMP2, TMP,  lo16(VME_CMMU_I3) + 0x108
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D3)
	ld	TMP2, TMP,  lo16(VME_CMMU_D3) + 0x108
	st	TMP2, r31,  REG_OFF(EF_DPFSR)
	br	pfsr_done
5: 
#endif   /* MVME188 */
   /* it's a single processor SBC   */  
	or.u	TMP,  r0,   hi16(SBC_CMMU_I)
	ld	TMP2, TMP,  lo16(SBC_CMMU_I) + 0x108
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(SBC_CMMU_D)
	ld	TMP2, TMP,  lo16(SBC_CMMU_D) + 0x108
	st	TMP2, r31,  REG_OFF(EF_DPFSR)

ASGLOBAL(pfsr_done)
	ldcr	TMP,  SSBR
	ldcr	TMP2, SXIP
	ldcr	TMP3, DMT0
	st	TMP2, r31,  REG_OFF(EF_SXIP)
   
#if 0
   /*
    * The following is a kludge so that
    * a core file will have a copy of
    * DMT0 so that 'sim' can display it
    * correctly.
    * After a data fault has been noticed,
    * the real EF_DTM0 is cleared, so I need
    * to throw this somewhere.
    * There's no special reason I chose this
    * register (FPIT)... it's just one of many
    * for which it causes no pain to do this.
    */
	st	TMP3, r31,  REG_OFF(EF_FPIT)
#endif

   /*
    * The above shadow registers are obligatory for any and all
    * exceptions.  Now, if the data access pipeline is not clear,
    * we must save the DMx shadow registers, as well as clear
    * the appropriate SSBR bits for the destination registers of
    * loads or xmems.
    */
	bb0.n	DMT_VALID_BIT, TMP3, DMT_check_finished
	st	TMP3, r31,  REG_OFF(EF_DMT0)

	ldcr	TMP2, DMT1
	ldcr	TMP3, DMT2
	st	TMP2, r31,  REG_OFF(EF_DMT1)
	st	TMP3, r31,  REG_OFF(EF_DMT2)

	ldcr	TMP2, DMA0
	ldcr	TMP3, DMA1
	st	TMP2, r31,  REG_OFF(EF_DMA0)
	st	TMP3, r31,  REG_OFF(EF_DMA1)

	ldcr	TMP2, DMA2
	ldcr	TMP3, DMD0
	st	TMP2, r31,  REG_OFF(EF_DMA2)
	st	TMP3, r31,  REG_OFF(EF_DMD0)

	tb1	0,    r0,   0
	ldcr	TMP2, DMD1
	ldcr	TMP3, DMD2
	st	TMP2, r31,  REG_OFF(EF_DMD1)
	st	TMP3, r31,  REG_OFF(EF_DMD2)

   /*
    *---------------------------------------------------------------
    * need to clear "appropriate" bits in the SSBR before
    * we restart the FPU
    */

ASGLOBAL(check_DMT0)
	ldcr	TMP2, DMT0
	bb0.n	DMT_VALID_BIT, TMP2, DMT_check_finished
	stcr	r0,   DMT0 /* so an exception at fpu_enable doesn't see our DMT0*/ 
	bb1	DMT_LOCK_BIT,  TMP2, do_DMT0
	bb1	DMT_WRITE_BIT, TMP2, check_DMT1

ASGLOBAL(do_DMT0)
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	set	TMP2, TMP2, 1<5>
	clr	TMP,  TMP,  TMP2

ASGLOBAL(check_DMT1)
	ldcr	TMP2, DMT1
	bb0	DMT_VALID_BIT, TMP2, check_DMT2
	bb1	DMT_LOCK_BIT,  TMP2, do_DMT1
	bb1	DMT_WRITE_BIT, TMP2, check_DMT2

ASGLOBAL(do_DMT1)
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	set	TMP2, TMP2, 1<5>
	clr	TMP,  TMP,  TMP2

ASGLOBAL(check_DMT2)
	ldcr	TMP2, DMT2
	bb0	DMT_VALID_BIT, TMP2, DMT_check_finished
	bb1	DMT_LOCK_BIT,  TMP2, do_DMT2_single
	bb1	DMT_WRITE_BIT, TMP2, DMT_check_finished
	bb1	DMT_DOUBLE_BIT,TMP2, do_DMT2_double

ASGLOBAL(do_DMT2_single)
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	br.n	1f
	set	TMP2, TMP2, 1<5>

ASGLOBAL(do_DMT2_double)
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	set	TMP2, TMP2, 1<6>
1:	clr	TMP,  TMP,  TMP2

ASGLOBAL(DMT_check_finished)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: saved TMP                                               *
	* r1:  free                                                    *
	* TMP: possibly revised SSBR                                   *
	* TMP2: free                                                   *
	* TMP3: free                                                   *
	* FLAGS: CPU status flags                                      *
	* r31: exception frame                                         *
	*    Valid in the exception frame:                             *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception-time TMP2, TMP3.                                 *
	*   Exception-time espr, sfip, snip, sxip.                     *
	*   Dmt0.                                                      *
	*   Other data pipeline control registers, if appropriate.     *
	*   Exception SR3, if appropriate.                             *
	\***************************************************************/
	ldcr	r1,   SR2
	jmp	r1 /* return to allow the handler to clear more SSBR bits */

#endif /* m88100 */

/************************************************************************/
/************************************************************************/

ASGLOBAL(clear_FPi_ssbr_bit)
	/*
	 * Clear floatingpont-imprecise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
	fldcr	TMP2, FPSR
	fldcr	TMP3, FPCR
	st	TMP2, r31,  REG_OFF(EF_FPSR)
	st	TMP3, r31,  REG_OFF(EF_FPCR)

	fldcr	TMP2, FPECR
	fldcr	TMP3, FPRH
	st	TMP2, r31,  REG_OFF(EF_FPECR)
	st	TMP3, r31,  REG_OFF(EF_FPRH)

	fldcr 	TMP2, FPIT
	fldcr	TMP3, FPRL
	st	TMP2, r31,  REG_OFF(EF_FPIT)
	st	TMP3, r31,  REG_OFF(EF_FPRL)

	/*
	 * We only need clear the bit in the SSBR for the
	 * 2nd reg of a double result [see section 6.8.5]
	 */
#define FPIT_SIZE_BIT   10
	bb0	FPIT_SIZE_BIT, TMP2, not_double_fpi
	extu	TMP2, TMP2, 5<0>  /* get the reg. */
	set	TMP2, TMP2, 1<6>  /* set width (width=2 will clear two bits) */ 
	clr   	TMP,  TMP,  TMP2

ASGLOBAL(not_double_fpi)
	jmp   r1


/************************************************************************/
/************************************************************************/


ASGLOBAL(clear_FPp_ssbr_bit)
	/*
	 * Clear floating pont precise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
	fldcr TMP2, FPSR
	fldcr TMP3, FPCR
	st    TMP2, r31,  REG_OFF(EF_FPSR)
	st    TMP3, r31,  REG_OFF(EF_FPCR)
	
	fldcr TMP3, FPECR
	st    TMP3, r31,  REG_OFF(EF_FPECR)
	fldcr TMP2, FPHS1
	fldcr TMP3, FPHS2
	st    TMP2, r31,  REG_OFF(EF_FPHS1)
	st    TMP3, r31,  REG_OFF(EF_FPHS2)
	
	fldcr TMP2, FPLS1
	fldcr TMP3, FPLS2
	st    TMP2, r31,  REG_OFF(EF_FPLS1)
	st    TMP3, r31,  REG_OFF(EF_FPLS2)
	
	fldcr TMP2, FPPT
	st    TMP2, r31,  REG_OFF(EF_FPPT)
1:   

#define FPPT_SIZE_BIT   5
	bb1.n FPPT_SIZE_BIT, TMP2, 2f
	extu  TMP3, TMP2, 5<0> /* get FP operation dest reg */
	br.n  3f
	set   TMP3, TMP3, 1<5> /* set size=1 -- clear one bit for "float" */
2:	set   TMP3, TMP3, 1<6> /* set size=2 -- clear two bit for "double" */ 
3:	clr   TMP,  TMP,  TMP3   /* clear bit(s) in ssbr. */
4:	jmp   r1


/************************************************************************/
/************************************************************************/

ASGLOBAL(clear_dest_ssbr_bit)
	/*
	 * There are various cases where an exception can leave the
	 * destination register's bit in the SB set.
	 * Examples:
	 *   misaligned or privilege exception on a LD or XMEM
	 *   DIV or DIVU by zero.
	 *
	 * I think that if the instruction is LD.D, then two bits must
	 * be cleared.
	 *
	 * Even though there are a number of instructions/exception
	 * combinations that could fire this code up, it's only required
	 * to be run for the above cases.  However, I don't think it'll
	 * ever be a problem to run this in other cases (ST instructions,
	 * for example), so I don't bother checking.  If we had to check
	 * for every possible instruction, this code would be much larger.
	 *
	 * The only checking, then, is to see if it's a LD.D or not.
	 *
	 * At the moment....
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
	
	ldcr  TMP3, EPSR   /* going to check: user or system memory? */
	ldcr  TMP2, SXIP   /* get the instruction's address */
	bb1.n PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
	clr   TMP2, TMP2, 2<0> /* get rid of valid and error bits. */
	
1:	/* user space load here */
#if ERRATA__XXX_USR
	NOP
	ld.usr TMP2,TMP2, r0      /* get the instruction itself */
	NOP
	NOP
	NOP
	br    3f
#else
	br.n  3f
	ld.usr TMP2,TMP2, r0      /* get the instruction itself */
#endif

2:	/* system space load here */
	ld    TMP2, TMP2, r0      /* get the instruction itself */

3:	/* now have the instruction..... */
	/*
	 * Now see if it's a double load
	 * There are three forms of double load [IMM16, scaled, unscaled],
	 * which can be checked by matching against two templates:
	 *          -- 77776666555544443333222211110000 --
	 *   if (((instruction & 11111100000000000000000000000000) ==
	 *             00010000000000000000000000000000) ;;
	 *       ((instruction & 11111100000000001111110011100000) ==
	 *             11110100000000000001000000000000))
	 *   {
	 *      It's a load double, so
	 *      clear two SSBR bits.
	 *   } else {
	 *      It's not a load double.
	 *      Must be a load single, xmem, or st
	 *      Thus, clear one SSBR bit.
	 *   }
	 */
	/* check the first pattern for ld.d */
	extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
	mask  TMP3, TMP3, 0xFC00   /* apply the mask */
	cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
	bb1   eq,   TMP3, misaligned_double
	
	/* still could be -- check the second pattern for ld.d */
	/* look at the upper 16 bits first */
	extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
	mask  TMP3, TMP3, 0xFC00   /* apply the mask */
	cmp   TMP3, TMP3, 0xF400   /* if equal, it might be a load double */
	bb1   ne,   TMP3, misaligned_single /* not equal, so must be single */
	
	/* now look at the lower 16 bits */
	extu  TMP3, TMP2, 16<0>    /* get the lower 16 bits */
	mask  TMP3, TMP3, 0xFCE0   /* apply the mask */
	cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
	bb1   eq,   TMP3, misaligned_double
	
ASGLOBAL(misaligned_single)
	extu  TMP2, TMP2, 5<21>    /* get the destination register */
	br.n  1f
	set   TMP2, TMP2, 1<5>     /* set size=1 */

ASGLOBAL(misaligned_double)
	extu  TMP2, TMP2, 5<21>    /* get the destination register */
	set   TMP2, TMP2, 1<6>     /* set size=2 -- clear two bit for "ld.d" */

1:	jmp.n   r1
	clr   TMP,  TMP,  TMP2     /* clear bit(s) in ssbr. */

/************************************************************************/
/************************************************************************/

#ifdef M88100

ASGLOBAL(setup_phase_two)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: saved return address to calling exception handler        *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: free                                                     *
	* SR3: saved TMP                                                *
	* r1:  return address to calling exception handler              *
	* TMP: possibly revised SSBR                                    *
	* TMP2: free                                                    *
	* TMP3: free                                                    *
	* FLAGS: CPU status flags                                       *
	* r31: our exception frame                                      *
	*    Valid in the exception frame:                              *
	*   Exception-time r1, r31, FLAGS.                              *
	*   Exception-time TMP2, TMP3.                                  *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   restore the system to the exception-time state (except      *
	* SR3 will be OUR stack pointer) so that we may resart the FPU. *
	\***************************************************************/
	/*stcr   r1, SR0*/      /* save return address */
	
	stcr  TMP,  SSBR   /* done with SSBR, TMP now free */
	RESTORE_TMP2      /* done with extra temp regs */
	RESTORE_TMP3      /* done with extra temp regs */
	
	/* Get the current PSR and modify for the rte to enable the FPU */
#if 1
	ldcr  TMP,  PSR
	clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
	clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
	stcr  TMP,  EPSR
	
	/* the "+2" below is to set the VALID_BIT */
	or.u  TMP,  r0,   hi16(fpu_enable +2)
	or    TMP,  TMP,  lo16(fpu_enable +2)
	stcr  TMP,  SNIP      /* jump to here fpu_enable */
	addu  TMP,  TMP,  4
	stcr  TMP,  SFIP      /* and then continue after that */
#else
	ldcr  TMP,  PSR
	or.u  TMP,  TMP,  0x8000    /* set supervisor mode */
	and   TMP,  TMP,  0xfff7    /* also enable shadowing */
	stcr  TMP,  EPSR
	stcr  r0,   SXIP       /* clear valid bit */
	stcr  r0,   SNIP       /* clear valid bit */
	or.u  TMP,  r0,   hi16(fpu_enable)
	or    TMP,  TMP,  lo16(fpu_enable)
	or    TMP,  TMP,  0x2 /* set the VALID_BIT and clear Exception bit */
	stcr  TMP,  SFIP      /* jump to here fpu_enable */
#endif

setup_phase_two_cont:
	set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
	xcr   FLAGS, FLAGS, SR1
	st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
	ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */
	
	xcr   TMP,  r31,  SR3   /* TMP now restored. R31 now saved in SR3 */
	ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: CPU flags                                                *
	* SR2: free                                                     *
	* SR3: pointer to our exception frame (our stack pointer)       *
	* r1 through r31: original exception-time values                *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	*   Held temporarly in the exception frame:                     *
	*   Return address to the calling excption handler.             *
	***************************************************             *
	* immediate goal:                                               *
	*   Do an RTE to restart the fpu and jump to "fpu_enable"       *
	*   Another exception (or exceptions) may be raised in          *
	*   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
	\***************************************************************/
	
	RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */
	
ASGLOBAL(fpu_enable)
	FLUSH_PIPELINE
	xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
	st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
	or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
	ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/
	
	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr   FLAGS,FLAGS,SR1
	clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr   FLAGS,FLAGS,SR1
	
	xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */
	
	/* now save all regs to the exception frame. */
	st.d  r0 ,  r31,  GENREG_OFF(0)
	st.d  r2 ,  r31,  GENREG_OFF(2)
	st.d  r4 ,  r31,  GENREG_OFF(4)
	st.d  r6 ,  r31,  GENREG_OFF(6)
	st.d  r8 ,  r31,  GENREG_OFF(8)
	st.d  r10,  r31,  GENREG_OFF(10)
	st.d  r12,  r31,  GENREG_OFF(12)
	st.d  r14,  r31,  GENREG_OFF(14)
	st.d  r16,  r31,  GENREG_OFF(16)
	st.d  r18,  r31,  GENREG_OFF(18)
	st.d  r20,  r31,  GENREG_OFF(20)
	st.d  r22,  r31,  GENREG_OFF(22)
	st.d  r24,  r31,  GENREG_OFF(24)
	st.d  r26,  r31,  GENREG_OFF(26)
	st.d  r28,  r31,  GENREG_OFF(28)
#ifdef JEFF_DEBUG
	/* mark beginning of frame with notable value */
	or.u  r20,  r0,   hi16(0x12345678)
	or    r20,  r20,  lo16(0x12345678)
	st    r20,  r31,  GENREG_OFF(0)
#endif

	/* get and save IPL */
	bsr	_C_LABEL(getipl)
	st	r2, r31, REG_OFF(EF_MASK)
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: free                                                     *
	* SR2: free                                                     *
	* SR3: previous exception-time SR3                              *
	* r1: return address to the calling exception handler           *
	* r2 through r30: free                                          *
	* r31: our exception frame                                      *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time r0 through r31.                              *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   Pick up a stack if we came in from user mode. Put           *
	*       A copy of the exception frame pointer into r30          *
	*       bump the stack a doubleword and write the exception     *
	*       frame pointer.                                          *
	*   if not an interrupt exception,                              *
	*       Turn on interrupts and service any outstanding          *
	*       data access exceptions.                                 *
	*   Return to calling exception handler to                      *
	*   service the exception.                                      *
	\***************************************************************/
	
	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
#if INTSTACK
	/*
	 * If interrupt exception, switch to interrupt stack if not
	 * already there. Else, switch to kernel stack.
	 */
#endif
	or    r30,  r0,   r31		/* get a copy of the e.f. pointer */ 
	ld    r2,   r31,  REG_OFF(EF_EPSR)
	bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */

#if INTSTACK
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1      /* is interrupt ? */
	bb0   eq,   r3,   2f
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
	br    3f
2:
#endif
	or.u  r31,  r0,   hi16(_kstack)
	ld    r31,  r31,  lo16(_kstack)
	addu  r31,  r31,  USIZE        /* point at proper end */
	br    3f
1:
#if INTSTACK
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1       /* is interrupt ? */
	bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
#endif /* INTSTACK */
	/* This label is here for debugging */
exception_handler_has_ksp:  global exception_handler_has_ksp
3:	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	*/
	subu  r31,  r31,  8  /* make some breathing space */
	st    r30,  r31,  0  /* store frame pointer on the stack */
#if DDB
	st    r30,  r31,  4  /* store it again for the debugger to recognize */
#endif /* DDB */

	ld    r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n eq0, r2,   return_to_calling_exception_handler  /* is error */
	ld    r14,  r30,  REG_OFF(EF_RET)
	cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
	bb1.n eq,   r3,   return_to_calling_exception_handler /* skip if so */

#if DDB
	cmp   r3,   r2,   130 /* DDB break exception */
	bb1.n eq,   r3,   return_to_calling_exception_handler
	cmp   r3,   r2,   132 /* DDB entry exception */
	bb1.n eq,   r3,   return_to_calling_exception_handler
#endif

	ldcr  r2,   PSR
	clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
	stcr  r2,   PSR
#if     DDB
	FLUSH_PIPELINE
#endif

	/* service any outstanding data pipeline stuff
	   - check dmt0 anything outstanding?*/

	ld    r3,   r30,  REG_OFF(EF_DMT0)
	bb0   DMT_VALID_BIT, r3, return_to_calling_exception_handler

	/*
	  r30 can be clobbered by calls. So stuff its value into a
	  preserved register, say r15. R14 is in use (see return_to_... below). 
	 */
	or    r15,  r0,   r30

	CALL(_C_LABEL(m88100_trap), T_DATAFLT, r15)
	CALL(_data_access_emulation, r15, r0)

	/*   restore it... */
	or    r30,  r0,   r15

	/* clear the dmt0 word in the E.F */
	st    r0,   r30,  REG_OFF(EF_DMT0)

ASGLOBAL(return_to_calling_exception_handler)
	jmp   r14 /* loaded above */
#endif /* m88100 */


/*
 * proc_trampoline.
 * When a process setup by cpu_set_kpc() resumes, it will find itself in
 * proc_trampoline, with r31 pointing to a ksigframe. proc_trampoline will
 * load func and proc values from ksigframe, call the function, and on return
 * pop off the ksigframe. Then, it will load pc from the switchframe and
 * jump there.
 */

ENTRY(proc_trampoline)
	ld	r1,r31,0	/* load func */
	ld	r2,r31,4 	/* load proc pointer */
	jsr.n	r1
	subu	r31,r31,40	/* create stack space for function */
	addu	r31,r31,48	/* stack space above + ksigframe */
	ld	r1, r31,0	/* load pc */
	ld	r2, r31,4	/* & proc pointer from switch frame */ 
	jsr.n	r1
	addu	r31,r31,8
	bsr	_C_LABEL(panic)

/*
 * proc_do_uret 
 * this is called as proc_do_uret(proc) from proc_trampoline(). This function
 * loads r31 with a pointer to the trap frame for the given proc and calls
 * return_from_exception_handler which loads all the registers and does an
 * rte.
 */

ENTRY(proc_do_uret)
	ld	r3,r2,P_ADDR		/* p->p_addr */
	addu	r3,r3,PCB_USER_STATE	/* p->p_addr.u_pcb.user_state */
	st	r3,r31,0		/* put it on the stack */
	br	return_from_exception_handler

ASGLOBAL(return_from_exception_handler)
	/*
	 * Regs r1-r30 are free. R31 is pointing at the word
	 * on the kernel stack where our pointer to the exception frame
	 * it stored. Reload it now.
	 *
	 * At this point, if EF_DMT0 is not zero, then
	 * this must have been an interrupt where the fault didn't
	 * get corrected above.  We'll do that now.
	 *
	 * We load it into r14 since it is preserved across function
	 * calls, and we may have to call some routines from within here.
	 *
	 * control is transfered here from obvious places in this file
	 * and thread_bootstrap in luna88k/locore.c.
	 *
	 */
#ifdef M88110	
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb1	eq, r2, m88110_return_code        
#endif 
#ifdef M88100
#define FPTR    r14
	ld	FPTR, r31, 0                 /* grab exception frame pointer */ 
	ld	r3, FPTR, REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r3, check_ast /*[Oh well, nothing to do here] */

#if 1
	/*
	 * This might happen for non-interrupts  If the user sets DMT0
	 * in an exception handler.........
	 */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1 /* interrupt is exception #1 ; Is an interrupt? */ 
	bb1	eq, r2, 1f
	or.u	r4, r0, hi16(2f)
	or	r4, r4, lo16(2f)
#if DDB
	CALL(_C_LABEL(db_printf), r4, r0)
	tb0	0, r0, 132
#endif
	br 1f
	data
2:	string "OOPS: DMT0 not zero and not interrupt.\n\000"
	align 8
	text
1:
#endif
	/*
	 * If it's the interrupt exception, enable interrupt.
	 * Take care of any data access exception...... 90/8/15 add by yama
	 */
	
	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 */
	ld    r2, FPTR, REG_OFF(EF_VECTOR)
	cmp   r2, r2, 1   /* interrupt is exception #1 ; Is an interrupt? */
        bb1   ne, r2, 1f  /* If not so, skip */

	/* if EPSR has interrupts disabled, skip also */
	ld    r2, FPTR, REG_OFF(EF_EPSR)
        bb1   PSR_INTERRUPT_DISABLE_BIT, r2, 1f		/* skip if disabled */
	ldcr  r2, PSR
	clr   r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* enable interrupts */
	FLUSH_PIPELINE
        stcr  r2, PSR
1:
	ld    r2, FPTR, REG_OFF(EF_DMT0)
	bb0   DMT_VALID_BIT, r2, 2f

	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */
	CALL(_C_LABEL(m88100_trap), T_DATAFLT, r30)
	CALL(_C_LABEL(data_access_emulation), r30, r0) /* really only 2 args */
	/* clear the dmt0 word in the E.F. */
	st   r0 , FPTR, REG_OFF(EF_DMT0)
2:
	br   check_ast
#endif /* m88100 */

#ifdef M88110
ASLOCAL(m88110_return_code)
#define FPTR    r14
	ld	FPTR, r31, 0                 /* grab exception frame pointer */ 

	/*
	 * If it's the interrupt exception, enable interrupt.
	 * If it's the data access exception, take care of it.
	 */

	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 * 
	 * On mc88110, you can.  The NMI interrupt. aka ABORT. XXX smurph
	 */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1   /* Is it an interrupt? */ 
	bb1	ne, r2, 1f  /* If not, skip */

	/* if EPSR has interrupts disabled, skip also */
	ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f  /* skip if disabled */ 
	ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>    /* enable interrupts */ 
	FLUSH_PIPELINE
	stcr	r2, PSR
1:
	br 2f	/* temp XXX smurph */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 3   /* Is it a data access exception? */ 
	bb1	ne, r2, 2f  /* If not, skip */

	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r30)

	/* clear the dsr word in the E.F. */
	st	r0, FPTR, REG_OFF(EF_DSR)
	st	r0, FPTR, REG_OFF(EF_DLAR)
	st	r0, FPTR, REG_OFF(EF_DPAR)
2:
#endif /* M88110 */

/*
 *   If the saved ipl is 0, then call dosoftint() to process soft
 *   interrupts.
 *   If returning to user land, look for ASTs
 */
ASLOCAL(check_ast)

        ld      r2, FPTR, REG_OFF(EF_EPSR)   /* get pre-exception PSR */
        bb1     PSR_INTERRUPT_DISABLE_BIT, r2, 1f /* skip if ints off */
        ld      r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
        bcnd    ne0, r2, 1f		/* can't do softint's */
        
	subu	r31, r31, 32
	bsr.n   _C_LABEL(setipl)
        or      r2,r0,1
	/* at ipl 1 now */	
	addu	r31, r31, 32
        bsr     _C_LABEL(dosoftint)
        /* is this needed? we are going to restore the ipl below XXX nivas */
	subu	r31, r31, 32
        bsr.n   _C_LABEL(setipl)
        or      r2,r0,0			/* ints are enabled */
	addu	r31, r31, 32
	/* at ipl 0 now */
1:
        ld      r2, FPTR, REG_OFF(EF_EPSR)   /* get pre-exception PSR */
        bb1     PSR_SUPERVISOR_MODE_BIT, r2, no_ast /*skip if in system mode */

        /* should assert here - not in user mode with ints off XXX nivas */
        /* get and check want_ast */
        or.u	r2, r0, hi16(_C_LABEL(want_ast))
        ld	r3, r2, lo16(_C_LABEL(want_ast))
        bcnd	eq0, r3, no_ast

        /*
         * trap(AST,...) will service ast's.
         */
#if defined(M88110) && defined(M88100)
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb0	eq, r2, 2f
#endif
#if defined(M88110)
        CALL(_C_LABEL(m88110_trap), T_ASTFLT, FPTR)
#endif
#if defined(M88110) && defined(M88100)
	br	no_ast
2:
#endif
#ifdef M88100
        CALL(_C_LABEL(m88100_trap), T_ASTFLT, FPTR)
#endif

ASLOCAL(no_ast)

        /* disable interrupts */
        ldcr    r1, PSR                 
        set     r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
        FLUSH_PIPELINE
        stcr    r1, PSR

        /* now ready to return....*/
	subu	r31, r31, 40
	bsr.n   _C_LABEL(setipl)
	 ld	r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
	addu	r31, r31, 40
        
        /*
         * Transfer the frame pointer to r31, since we no longer need a stack.
         * No page faults here, and interrupts are disabled.
         */
        or      r31, r0,  FPTR
        /* restore r1 later */
        ld.d    r2 , r31, GENREG_OFF(2)
        ld.d    r4 , r31, GENREG_OFF(4)
        ld.d    r6 , r31, GENREG_OFF(6)
        ld.d    r8 , r31, GENREG_OFF(8)
        ld.d    r10, r31, GENREG_OFF(10)
        ld.d    r12, r31, GENREG_OFF(12)
        ld.d    r14, r31, GENREG_OFF(14)
        ld.d    r16, r31, GENREG_OFF(16)
        ld.d    r18, r31, GENREG_OFF(18)
        ld.d    r20, r31, GENREG_OFF(20)
        ld.d    r22, r31, GENREG_OFF(22)
        ld.d    r24, r31, GENREG_OFF(24)
        ld.d    r26, r31, GENREG_OFF(26)
        ld.d    r28, r31, GENREG_OFF(28)
        /* restore r1, r30, r31 later */

        /* disable shadowing */
        ldcr    r1, PSR
        set     r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
        FLUSH_PIPELINE
        stcr    r1, PSR

	/* reload the control regs*/
#ifdef M88110
        or.u	r1, r0, hi16(_C_LABEL(cputyp))
	ld	r30, r1, lo16(_C_LABEL(cputyp))
	cmp	r1, r30, CPU_88110
	bb1	ne, r1, 1f
        /* mc88110 needs the EXIP */
	ld      r30, r31, REG_OFF(EF_ENIP)
        ld      r1,  r31, REG_OFF(EF_EXIP)
        stcr    r30, ENIP
        stcr    r1,  EXIP
	br 	2f      
1:
#endif 
        st      r0, r31, REG_OFF(EF_IPFSR)
        st      r0, r31, REG_OFF(EF_DPFSR)

        /*
         * Note: no need to restore the SXIP.
         * When the "rte" causes execution to continue
         * first with the instruction pointed to by the NIP
         * and then the FIP.
         *
         * See MC88100 Risc Processor User's Manual, 2nd Edition,
         * section 6.4.3.1.2-4
         */
        ld      r30, r31, REG_OFF(EF_SNIP)
        ld      r1,  r31, REG_OFF(EF_SFIP)
        stcr    r0,  SSBR
        stcr    r30, SNIP
        stcr    r1,  SFIP

2:        
	ld      r30, r31, REG_OFF(EF_EPSR)
        ld      r1,  r31, REG_OFF(EF_MODE)
        stcr    r30, EPSR

        /* Now restore r1, r30, and r31 */
        ld      r1,  r31, GENREG_OFF(1)
        ld.d    r30, r31, GENREG_OFF(30)

        RTE

#ifdef M88110 	
/*#########################################################################*/
/*#### THE ACTUAL EXCEPTION HANDLER ENTRY POINTS - MVME197 ################*/
/*#########################################################################*/

/* unknown exception handler */
GLOBAL(m88110_unknown_handler)
	PREP2("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_UNKNOWN_BIT)

/* interrupt exception handler */
GLOBAL(m88110_interrupt_handler)
	PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_INT, r30)
	DONE(DEBUG_INTERRUPT_BIT)

/* instruction access exception handler */
GLOBAL(m88110_instruction_access_handler)
	PREP2("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_INSTFLT, r30)
	DONE(DEBUG_INSTRUCTION_BIT)
/*
 * data access exception handler --
 *  See badaddr() below for info about Data_Precheck.
 */
GLOBAL(m88110_data_exception_handler)
	PREP2("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, M88110_Data_Precheck)
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r30)
	DONE(DEBUG_DATA_BIT)

/* misaligned access exception handler */
GLOBAL(m88110_misaligned_handler)
	PREP2("misalign", 4, DEBUG_MISALIGN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_MISALGNFLT, r30)
	DONE(DEBUG_MISALIGN_BIT)

/* unimplemented opcode exception handler */
GLOBAL(m88110_unimplemented_handler)
	PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_ILLFLT, r30)
	DONE(DEBUG_UNIMPLEMENTED_BIT)

/* privilege exception handler */
GLOBAL(m88110_privilege_handler)
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT, No_SSBR_Stuff, No_Precheck) 
	CALL(_C_LABEL(m88110_trap), T_PRIVINFLT, r30)
	DONE(DEBUG_PRIVILEGE_BIT)

/*
 * I'm not sure what the trap(T_BNDFLT,...) does, but it doesn't send
 * a signal to the process...
 */
GLOBAL(m88110_bounds_handler)
	PREP2("bounds", 7, DEBUG_BOUNDS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_BNDFLT, r30)
	DONE(DEBUG_BOUNDS_BIT)

/* integer divide-by-zero exception handler */
GLOBAL(m88110_divide_handler)
	PREP2("divide", 8, DEBUG_DIVIDE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_ZERODIV, r30)
	DONE(DEBUG_DIVIDE_BIT)

/* integer overflow exception handler */
GLOBAL(m88110_overflow_handler)
	PREP2("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_OVFFLT, r30)
	DONE(DEBUG_OVERFLOW_BIT)

/* Floating-point precise handler */
GLOBAL(m88110_fp_precise_handler)
	PREP2("FPU precise", 114, DEBUG_FPp_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/
	DONE(DEBUG_FPp_BIT)

/* MVME197 non-maskable interrupt handler (ABORT button) */
GLOBAL(m88110_nonmaskable)
	PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_NON_MASK, r30)
	DONE(DEBUG_NON_MASK_BIT)

/* MVME197 data MMU read miss handler */
GLOBAL(m88110_data_read_miss)
	PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_197_READ, r30)
	DONE(DEBUG_197_READ_BIT)

/* MVME197 data MMU write miss handler */
GLOBAL(m88110_data_write_miss)
	PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_197_WRITE, r30)
	DONE(DEBUG_197_WRITE_BIT)

/* MVME197 inst MMU ATC miss handler */
GLOBAL(m88110_inst_atc_miss)
	PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_197_INST, r30)
	DONE(DEBUG_197_INST_BIT)

/* All standard system calls.  */
GLOBAL(m88110_syscall_handler)
	PREP2("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r13, r30, GENREG_OFF(13)
	CALL(_m88110_syscall, r13, r30) /* system call no. is in r13 */
	DONE(DEBUG_SYSCALL_BIT)

/* trap 496 comes here */
GLOBAL(m88110_bugtrap)
	PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
	DONE(DEBUG_BUGCALL_BIT)

GLOBAL(m88110_sigsys)
	PREP2("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_SIGSYS, r30)
	DONE(DEBUG_SIGSYS_BIT)

GLOBAL(m88110_sigtrap)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_SIGTRAP, r30)
	DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m88110_stepbpt)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_STEPBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m88110_userbpt)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_USERBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)

#if DDB
GLOBAL(m88110_break)
	PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_KDB_BREAK, r30)
	DONE(DEBUG_BREAK_BIT)

GLOBAL(m88110_trace)
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_KDB_TRACE, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(m88110_entry)
	PREP2("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_KDB_ENTRY, r30)
	DONE(DEBUG_KDB_BIT)
#else /* else not DDB */
GLOBAL(m88110_break)
	PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_BREAK_BIT)

GLOBAL(m88110_trace)
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(m88110_entry)
	PREP2("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_KDB_BIT)
#endif   /* DDB */


/*--------------------------------------------------------------------------*/
/*
 * The error exception handler.
 * The error exception is raised when any other non-trap exception is raised
 * while shadowing is off. This is Bad News.
 *
 * The shadow registers are not valid in this case (shadowing was off, ne).
 * R1-R31 may be interesting though, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(m88110_error_handler)
	xcr	r2, r2,	SRX
	or	r2, r0, 10
	stcr	r2, 	SR0
	br.n	_C_LABEL(m88110_fatal)
	xcr	r2, r2,	SRX

/*
 * The reset exception handler.
 * The reset exception is raised when the RST signal is asserted (machine 
 * is reset), the value of VBR is changed after exceptions are enabled, 
 * or when a jmp, br/bsr to addr 0 (accidents do happen :-)
 *
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0 
 * to handle it!!! 
 *
 * This is totaly different than _error_handler.  Shadowing might or 
 * might not be on.
 * R1-R31 could tell u alot about what happend, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(m88110_reset_handler)
	stcr	r0, 	SR0
	/* FALL THROUGH */
GLOBAL(m88110_fatal)
        /* pick up the slavestack */
	or	r26, r0, r31           /* save old stack */
	or.u	r31, r0,  hi16(_intstack_end)
	or	r31, r31, lo16(_intstack_end)

	/* zero the stack, so we'll know what we're lookin' at */
	or.u	r27, r0,  hi16(_intstack)
	or	r27, r27, lo16(_intstack)
1:	cmp	r28, r27, r31
	bb1	ge,  r28, 2f   /* branch if at the end of the stack */
	st	r0,  r0,  r27
	br.n	1b
	addu	r27, r27, 4   /* bump up */
2:	/* stack has been cleared */

	/* ensure that stack is 8-byte aligned */
        clr     r31, r31, 3<0>  /* round down to 8-byte boundary */

	/* create exception frame on stack */
        subu    r31, r31, SIZEOF_EF             /* r31 now our E.F. */

	/* save old R31 and other R registers */
        st.d    r0 , r31, GENREG_OFF(0)
        st.d    r2 , r31, GENREG_OFF(2)
        st.d    r4 , r31, GENREG_OFF(4)
        st.d    r6 , r31, GENREG_OFF(6)
        st.d    r8 , r31, GENREG_OFF(8)
        st.d    r10, r31, GENREG_OFF(10)
        st.d    r12, r31, GENREG_OFF(12)
        st.d    r14, r31, GENREG_OFF(14)
        st.d    r16, r31, GENREG_OFF(16)
        st.d    r18, r31, GENREG_OFF(18)
        st.d    r20, r31, GENREG_OFF(20)
        st.d    r22, r31, GENREG_OFF(22)
        st.d    r24, r31, GENREG_OFF(24)
        st      r30, r31, GENREG_OFF(30)
	st	r26, r31, GENREG_OFF(31)

	/* vector is put in SRO (either 0 or 10 at this point) */
	ldcr	r10, SR0
	st	r10,  r31, REG_OFF(EF_VECTOR)
	cmp	r10, r10, 0	/* Is it the reset exception? */
	bb1.n	ne,  r10, 1f	/* If not, skip. */
	
	/* save shadow registers (are OLD if error_handler, though) */
	ldcr	r10, EPSR
	st	r10, r31, REG_OFF(EF_EPSR)
	ldcr	r10, EXIP
	st	r10, r31, REG_OFF(EF_EXIP)
	ldcr	r10, ENIP
	st	r10, r31, REG_OFF(EF_ENIP)
	ldcr	r10, DSR
	st	r10, r31, REG_OFF(EF_DSR)
	ldcr	r10, DLAR
	st	r10, r31, REG_OFF(EF_DLAR)
	ldcr	r10, DPAR
	st	r10, r31, REG_OFF(EF_DPAR)
	ldcr	r10, ISR
	st	r10, r31, REG_OFF(EF_ISR)
	ldcr	r10, ILAR
	st	r10, r31, REG_OFF(EF_ILAR)
	ldcr	r10, IPAR
	st	r10, r31, REG_OFF(EF_IPAR)
	ldcr	r10, SR1
	br.n	2f
	st	r10, r31, REG_OFF(EF_MODE)

1:	
	/* retrieve saved shadow registers for error_handler, though) */
	or.u	r30, r0,  hi16(_save_frame)
	or	r30, r30, lo16(_save_frame)
	ld	r10, r30, REG_OFF(EF_EPSR)
	st	r10, r31, REG_OFF(EF_EPSR)
	ld	r10, r30, REG_OFF(EF_EXIP)
	st	r10, r31, REG_OFF(EF_ENIP)
	ld	r10, r30, REG_OFF(EF_DSR)
	st	r10, r31, REG_OFF(EF_DSR)
	ld	r10, r30, REG_OFF(EF_DLAR)
	st	r10, r31, REG_OFF(EF_DLAR)
	ld	r10, r30, REG_OFF(EF_DPAR)
	st	r10, r31, REG_OFF(EF_DPAR)
	ld	r10, r30, REG_OFF(EF_ISR)
	st	r10, r31, REG_OFF(EF_ISR)
	ld	r10, r30, REG_OFF(EF_ILAR)
	st	r10, r31, REG_OFF(EF_ILAR)
	ld	r10, r30, REG_OFF(EF_IPAR)
	st	r10, r31, REG_OFF(EF_IPAR)
	ld	r10, r30, REG_OFF(EF_ISAP)
	st	r10, r31, REG_OFF(EF_ISAP)
	ld	r10, r30, REG_OFF(EF_DSAP)
	st	r10, r31, REG_OFF(EF_DSAP)
	ld	r10, r30, REG_OFF(EF_IUAP)
	st	r10, r31, REG_OFF(EF_IUAP)
	ld	r10, r30, REG_OFF(EF_DUAP)
	st	r10, r31, REG_OFF(EF_DUAP)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)
2:
	/* shove sr2 into EF_FPLS1 */
	ldcr	r10, SR2
	st	r10, r31, REG_OFF(EF_FPLS1)

	/* shove sr3 into EF_FPHS2 */
	ldcr	r10, SR3
	st	r10, r31, REG_OFF(EF_FPHS2)

	
	/*
	 * Cheap way to enable FPU and start shadowing again.
	 */
        ldcr    r10, PSR
        clr     r10, r10, 1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
        clr     r10, r10, 1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
   
        stcr    r10, PSR  /* bang */
	FLUSH_PIPELINE

	/* put pointer to regs into r30... r31 will become a simple stack */
	or	r30, r31, r0

        subu	r31, r31, 0x10 /* make some breathing space */
        st	r30, r31, 0x0c /* store frame pointer on the st */
        st	r30, r31, 0x08 /* store again for the debugger to recognize */ 
	or.u	r20,  r0, hi16(0x87654321)
	or	r20, r20, lo16(0x87654321)
	st	r20, r31, 0x04
	st	r20, r31, 0x00
        
	CALL(_error_fatal, r30, r30)

        /* TURN INTERUPTS back on */
        ldcr r1, PSR
	clr  r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
        stcr r1, PSR
        FLUSH_PIPELINE

ASGLOBAL(m88110_error_loop)
	bsr m88110_error_loop
   /* never returns*/

ASGLOBAL(m88110_setup_phase_one)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: saved copy of exception-time r1                          *
	* SR3: must be preserved .. may be the exception-time stack     *
	* r1: return address to calling exception handler               *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*    Decide where we're going to put the exception frame.       *
	*   Might be at the end of R31, SR3, or the thread's            *
	*   pcb.                                                        *
	\***************************************************************/
	
	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
	NOP
	xcr   r1,   r1,   SR2
	NOP
	NOP
	NOP
	
	bb1   FLAG_ENABLING_FPU, FLAGS, m88110_use_SR3_pcb
	/* are we coming in from user mode? If so, pick up process pcb */
	bb0   FLAG_FROM_KERNEL, FLAGS, m88110_pickup_stack
	
	/* Interrupt in kernel mode, not FPU restart */
ASGLOBAL(m88110_already_on_kernel_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; may be important for other exceptions *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   We're already on the kernel stack, but not having           *
	*   needed to use SR3. We can just make room on the             *
	*    stack (r31) for our exception frame.                       *
	\***************************************************************/
	subu  r31,  r31,  SIZEOF_EF            /* r31 now our E.F. */
	st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
	
	ldcr  r1,   SR3                        /* save previous SR3 */
	st    r1,   r31,  REG_OFF(EF_SR3)
	
	addu  r1,   r31,  SIZEOF_EF            /* save previous r31 */
	br.n  m88110_have_pcb
	st    r1,   r31,  GENREG_OFF(31)
	
	
ASGLOBAL(m88110_use_SR3_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; exception-time stack pointer          *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   An exception occured while enabling the FPU. Since r31      *
	*   is the user's r31 while enabling the FPU, we had put        *
	*   our pcb pointer into SR3, so make room from                 *
	*   there for our stack pointer.                                *
	*       We need to check if SR3 is the old stack pointer or the *
	*       pointer off to the user pcb. If it pointing to the user *
	*       pcb, we need to pick up the kernel stack. Otherwise     *
	*       we need to allocate a frame upon it.                    *
	*       We look at the EPSR to see if it was from user mode     *
	*       Unfortunately, we have no registers free at the moment  *
	*       But we know register 0 in the pcb frame will always be  *
	*       zero, so we can use it as scratch storage.              *
	*                                                               *
	*                                                               *
	\***************************************************************/
	xcr	r2, r2,	SRX
	or	r2, r0, 10
	stcr	r2, 	SR0
	br.n	_C_LABEL(m88110_fatal)
	xcr	r2, r2,	SRX
	/* Testing!!! */
	xcr   r30,  r30,  SR3                  /* r30 = old exception frame */
	st    r1,   r30,  GENREG_OFF(0)        /* free up r1 */
	ld    r1,   r30,  REG_OFF(EF_EPSR)     /* get back the epsr */
	bb0.n PSR_SUPERVISOR_MODE_BIT, r1, 1f  /* if user mode */
	ld    r1,   r30,  GENREG_OFF(0)        /* restore r1 */
	/* we were in kernel mode - dump frame upon the stack */
	st    r0,   r30,  GENREG_OFF(0)        /* repair old frame */
	subu  r30,  r30,  SIZEOF_EF            /* r30 now our E.F. */
	st    FLAGS,r30,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r30,  GENREG_OFF(1)        /* save prev. r1 (now r1 free) */
	
	st    r31,  r30,  GENREG_OFF(31)       /* save previous r31 */
	or    r31,  r0,   r30                  /* make r31 our pointer. */
	addu  r30,  r30,  SIZEOF_EF            /* r30 now has previous SR3 */
	st    r30,  r31,  REG_OFF(EF_SR3)      /* save previous SR3 */
	br.n  m88110_have_pcb
	xcr   r30,  r30,  SR3                  /* restore r30 */
1:
	/* we took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30) */
	or.u  r1,   r0,   hi16(_kstack)
	ld    r1,   r1,   lo16(_kstack)
	addu  r1,   r1,   USIZE-SIZEOF_EF
	st    FLAGS,r1,   REG_OFF(EF_FLAGS)    /* store flags */
	st    r31,  r1,   GENREG_OFF(31)       /* store r31 - now free */
	st    r30,  r1,   REG_OFF(EF_SR3)      /* store old SR3 (pcb) */
	or    r31,  r1,   r0                   /* make r31 our exception frame pointer */
	ld    r1,   r30,  GENREG_OFF(0)        /* restore old r1 */
	st    r0,   r30,  GENREG_OFF(0)        /* repair that frame */
	st    r1,   r31,  GENREG_OFF(1)        /* store r1 in its proper place */
	br.n  m88110_have_pcb
	xcr   r30,  r30,  SR3                  /* restore r30 */
	
ASGLOBAL(m88110_pickup_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* FLAGS: CPU status flags                                      *
	***************************************************            *
	* immediate goal:                                              *
	*    Since we're servicing an exception from user mode, we     *
	*   know that SR3 is free.  We use it to free up a temp.       *
	*   register to be used in getting the thread's pcb            *
	\***************************************************************/
	stcr  r31,  SR3      /* save previous r31 */
	
	/* switch to the thread's kernel stack. */
	or.u  r31,  r0,   hi16(_curpcb)
	ld    r31,  r31,  lo16(_curpcb)
	addu  r31,  r31,  PCB_USER_STATE       /* point to user save area */
	st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
	ldcr  r1,   SR3                        /* save previous r31 */
	st    r1,   r31,  GENREG_OFF(31)
	/*FALLTHROUGH */
	
ASGLOBAL(m88110_have_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* r1:  free                                                    *
	* FLAGS: CPU status flags                                      *
	* r31: our exception frame                                     *
	*    Valid in the exception frame:                             *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception SR3, if appropriate.                             *
	***************************************************            *
	* immediate goal:                                              *
	*    Save the shadow registers that need to be saved to        *
	*   the exception frame.                                       *
	\***************************************************************/
	stcr   TMP, SR3   /* free up TMP, TMP2, TMP3 */
	SAVE_TMP2
	SAVE_TMP3
	
	/* save some exception-time registers to the exception frame */
	ldcr  TMP,  EPSR
	st    TMP,  r31,  REG_OFF(EF_EPSR)
	ldcr  TMP2, EXIP
	st    TMP2, r31,  REG_OFF(EF_EXIP)
	bb0.n 0,    TMP2, 1f
	/* The instruction was NOT in the delay slot, zero ENIP. */
	st    r0,   r31,  REG_OFF(EF_ENIP)
	/* The instruction was in the delay slot, save ENIP. */
	ldcr  TMP3, ENIP
	st    TMP3, r31,  REG_OFF(EF_ENIP)
1:
	/* NO SFIP on mc88110, zero it */
	st    r0,   r31,  REG_OFF(EF_SFIP)
	
	/* get and store the cpu number */	
	extu  TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>  /* TMP = cpu# */
	st    TMP,  r31,  REG_OFF(EF_CPU)
	
	/*
	 * Save Pbus fault status register from data and inst CMMU.
	 */
	ldcr  TMP,  ISR
	ldcr  TMP2, ILAR
	ldcr  TMP3, IPAR
	st    TMP,  r31,  REG_OFF(EF_ISR)
	st    TMP2, r31,  REG_OFF(EF_ILAR)
	st    TMP3, r31,  REG_OFF(EF_IPAR)
	ldcr  TMP,  ISAP
	ldcr  TMP2, IUAP
	st    TMP,  r31,  REG_OFF(EF_ISAP)
	st    TMP2, r31,  REG_OFF(EF_IUAP)
	ldcr  TMP,  DSR
	ldcr  TMP2, DLAR
	ldcr  TMP3, DPAR
	st    TMP,  r31,  REG_OFF(EF_DSR)
	st    TMP2, r31,  REG_OFF(EF_DLAR)
	st    TMP3, r31,  REG_OFF(EF_DPAR)
	ldcr  TMP,  DSAP
	ldcr  TMP2, DUAP
	st    TMP,  r31,  REG_OFF(EF_DSAP)
	st    TMP2, r31,  REG_OFF(EF_DUAP)
	
	ldcr  r1,   SR2
	jmp   r1 /* return */
	
/************************************************************************/
/************************************************************************/

ASGLOBAL(m88110_setup_phase_two)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: saved return address to calling exception handler        *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: free                                                     *
	* SR3: saved TMP                                                *
	* r1:  return address to calling exception handler              *
	* TMP: possibly revised SSBR                                    *
	* TMP2: free                                                    *
	* TMP3: free                                                    *
	* FLAGS: CPU status flags                                       *
	* r31: our exception frame                                      *
	*    Valid in the exception frame:                              *
	*   Exception-time r1, r31, FLAGS.                              *
	*   Exception-time TMP2, TMP3.                                  *
	*   Exception-time espr, enip, exip.                            *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   restore the system to the exception-time state (except      *
	* SR3 will be OUR stack pointer) so that we may resart the FPU. *
	\***************************************************************/
	/*stcr   r1, SR0*/      /* save return address */
	
	RESTORE_TMP2      /* done with extra temp regs */
	RESTORE_TMP3      /* done with extra temp regs */
	
	ldcr  TMP,  PSR
	clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
	clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
	stcr  TMP,  EPSR
	
	or.u  TMP,  r0,   hi16(m88110_fpu_enable)
	or    TMP,  TMP,  lo16(m88110_fpu_enable)
	stcr  TMP,  EXIP      /* jump to here fpu_enable */
	addu  TMP,  TMP,  4
	stcr  TMP,  ENIP      /* and then continue after that */
	
	set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
	xcr   FLAGS, FLAGS, SR1
	st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
	ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */
	
	ldcr  TMP, SR3
	stcr  r31, SR3	/* TMP now restored. R31 now saved in SR3 */
	ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: CPU flags                                                *
	* SR2: free                                                     *
	* SR3: pointer to our exception frame (our stack pointer)       *
	* r1 through r31: original exception-time values                *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, enip, exip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	*   Held temporarly in the exception frame:                     *
	*   Return address to the calling excption handler.             *
	***************************************************             *
	* immediate goal:                                               *
	*   Do an RTE to restart the fpu and jump to "fpu_enable"       *
	*   Another exception (or exceptions) may be raised in          *
	*   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
	\***************************************************************/
	NOP
	RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */
	
ASGLOBAL(m88110_fpu_enable)
	FLUSH_PIPELINE
	/* Now we can handle another exception!!! */
	/* Now that EFZE is cleared, we can clear these */
	stcr  r0, ISR	/* Clear ISR */
	stcr  r0, ILAR	/* Clear ILAR */
	stcr  r0, IPAR	/* Clear IPAR */
	stcr  r0, DSR	/* Clear DSR */
	stcr  r0, DLAR	/* Clear DLAR */
	stcr  r0, DPAR	/* Clear DPAR */
	xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
	st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
	or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
	ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/

	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr   FLAGS,FLAGS,SR1
	clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr   FLAGS,FLAGS,SR1

	xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */

	/* now save all regs to the exception frame. */
	st.d  r0 ,  r31,  GENREG_OFF(0)
	st.d  r2 ,  r31,  GENREG_OFF(2)
	st.d  r4 ,  r31,  GENREG_OFF(4)
	st.d  r6 ,  r31,  GENREG_OFF(6)
	st.d  r8 ,  r31,  GENREG_OFF(8)
	st.d  r10,  r31,  GENREG_OFF(10)
	st.d  r12,  r31,  GENREG_OFF(12)
	st.d  r14,  r31,  GENREG_OFF(14)
	st.d  r16,  r31,  GENREG_OFF(16)
	st.d  r18,  r31,  GENREG_OFF(18)
	st.d  r20,  r31,  GENREG_OFF(20)
	st.d  r22,  r31,  GENREG_OFF(22)
	st.d  r24,  r31,  GENREG_OFF(24)
	st.d  r26,  r31,  GENREG_OFF(26)
	st.d  r28,  r31,  GENREG_OFF(28)
#ifdef JEFF_DEBUG
	/* mark beginning of frame with notable value */
	or.u  r20,  r0,   hi16(0x12345678)
	or    r20,  r20,  lo16(0x12345678)
	st    r20,  r31,  GENREG_OFF(0)
#endif
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: free                                                     *
	* SR2: free                                                     *
	* SR3: previous exception-time SR3                              *
	* r1: return address to the calling exception handler           *
	* r2 through r30: free                                          *
	* r31: our exception frame                                      *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time r0 through r31.                              *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, enip, exip.                            *
	*   Exception number (EF_VECTOR).                               *
	*   DSR                                                         *
	* Other data pipeline control registers, if appropriate.        *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   Pick up a stack if we came in from user mode. Put           *
	*       A copy of the exception frame pointer into r30          *
	*       bump the stack a doubleword and write the exception     *
	*       frame pointer.                                          *
	*   if not an interrupt exception,                              *
	*       Turn on interrupts and service any outstanding          *
	*       data access exceptions.                                 *
	*   Return to calling exception handler to                      *
	*   service the exception.                                      *
	\***************************************************************/
	
	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
	or    r30,  r0,   r31              /* get a copy of the e.f. pointer */
	ld    r2,   r31,  REG_OFF(EF_EPSR)
	bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */

#if INTSTACK
	/*
	 * If interrupt exception, switch to interrupt stack if not
	 * already there. Else, switch to kernel stack.
	 */
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1      /* is interrupt ? */
	bb0   eq,   r3,   2f
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
	br    3f
2:
#endif
	or.u  r31,  r0,   hi16(_kstack)
	ld    r31,  r31,  lo16(_kstack)
	addu  r31,  r31,  USIZE        /* point at proper end */
	br    3f
1:
#if INTSTACK
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1       /* is interrupt ? */
	bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
#endif	/* INTSTACK */
	/* This label is here for debugging */
m88110_exception_handler_has_ksp:  global m88110_exception_handler_has_ksp
3:	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	 */
	subu  r31,  r31,  8  /* make some breathing space */
	st    r30,  r31,  0  /* store frame pointer on the stack */
#if DDB
	st    r30,  r31,  4  /* store it again for the debugger to recognize */
#endif /* DDB */

	ld    r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n eq0, r2,   m88110_return_to_calling_exception_handler  /* is error */
	ld    r14,  r30,  REG_OFF(EF_RET) /* load return value XXX!!! */
	cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
	bb1.n   eq,   r3,   m88110_return_to_calling_exception_handler /* skip if so */

#if DDB
	cmp   r3,   r2,   130 /* DDB break exception */
	bb1.n eq,   r3,   m88110_return_to_calling_exception_handler

	cmp   r3,   r2,   132 /* DDB entry exception */
	bb1.n eq,   r3,   m88110_return_to_calling_exception_handler
#endif

	ldcr  r2,   PSR
	clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
	stcr  r2,   PSR
#if     DDB
	FLUSH_PIPELINE
#endif
#if 1 /* test */
	br  m88110_return_to_calling_exception_handler
#endif
	/* service any outstanding data pipeline stuff
	   - check dsr... anything outstanding?*/

	ld    r3,   r30,  REG_OFF(EF_DSR)
	cmp   r3,   r3,   0
	bb1   eq,   r3,   m88110_return_to_calling_exception_handler

/*
 * r30 can be clobbered by calls. So stuff its value into a
 * preserved register, say r15. R14 is in use (see return_to_... below).
 */
	or    r15,  r0,   r30
#if 0
	CALL(_C_LABEL(test_trap), r15, r0)
#endif   
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r15)

	/*   restore it... */
	or    r30,  r0,   r15

	/* clear the dsr word in the E.F */
	st    r0,   r30,  REG_OFF(EF_DSR)

ASGLOBAL(m88110_return_to_calling_exception_handler)
	jmp   r14 /* loaded above */
	
	data
	.align 8
GLOBAL(save_frame)
	space SIZEOF_EF	
#endif
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.30 2003/08/03 23:34:09 miod Exp $   */
d34 4
a37 3
 * 2. Make up my mind what is _kstack. I think it should be p->p_addr+UPAGES.
 *    (p_addr is pointing to user struct and swapin is making sure it is
 *    updated)
d41 19
a59 15

/*
 * In the following discussion, references are made to:
 *    MC88100 - RISC MICROPROCESSOR USER'S MANUAL
 * (second edition). Reference in []s refer to section numbers.
 *
 * This discussion assumes that you are at least vaguely familiar with 88100
 * exception handling (chapter 6), the MACH kernel, and that you have a brain
 * (and use it while reading this).
 *
 * I also assume (and hope) that you're not offended by frequent misspellings.
 *
 * Jeffrey Friedl
 * jfriedl@@rna.ncl.omron.co.jp
 * December, 1989
a216 1

d219 2
a220 2
#include <machine/param.h>		/* CPU_ and BRD_ defines */
#include <machine/trap.h>		/* for T_ defines */
d228 5
a232 6
 * EF_SR3
 *   A place to save the exception-time SR3 from just after the
 *   time when an exception is raised until just after the FPU
 *   has been restarted.  This does not necessarly conflict with
 *   the general registers (though it can if you're not careful)
 *   and so we can use a spot later used to save a general register.
d234 1
a234 2
 * EF_FLAGS
 *   This is just the old EF_MODE. "EF_MODE" isn't a very good name.
d236 2
a237 5
#define	EF_SR3		(EF_R0 + 5)
#define	EF_FLAGS	EF_MODE

/* Define this to make interrupts use their own stack */
#undef	INTSTACK
d239 1
d243 2
a244 2
	string	"eh.S: bad cpu number in FLAGS"

d249 3
a251 3
	or.u	r2, r0, hi16(sbadcpupanic)
	or	r2, r2, lo16(sbadcpupanic)
	bsr	_C_LABEL(panic)
d255 11
a265 11
#define	OFF_VEC		0
#define	OFF_EPSR	4
#define	OFF_EXIP	8
#define	OFF_ENIP	12
#define	OFF_DSR		16
#define	OFF_DLAR	20
#define	OFF_DPAR	24
#define	OFF_ISR		28
#define	OFF_ILAR	32
#define	OFF_IPAR	36
#define	OFF_TMP		40
d268 1
a268 1
#define SAVE_CTX \
d317 1
a317 1
	/* Restore r1, r2, r3, and r31 */	; \
d322 31
a352 32
/*
 *
 * #define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_CHECK)
 *
 * This is the "exception processing preparaton" common to all exception
 * processing.  It is used in the following manor:
 *
 *	ASGLOBAL(foo_handler)
 *		PREP("foo", 11, DEBUG_FOO_BIT, No_SSBR_Stuff, No_Precheck)
 *		CALL(_C_LABEL(trapXXX), T_FOO_FAULT, r31)
 *		DONE(DEBUG_FOO_BIT)
 *
 * This defines the exception handler for the "foo" exception.
 * The arguments ro PREP():
 * NAME
 *	String for debugging (more info later)
 * NUM
 *	The exception number [see the manual, Table 6-1]
 * BIT
 *	Bit to check in eh_debug for debugging (more info later)
 * SSBR_STUFF
 *	If the exception might leave some bits in the SSBR set,
 *	this should indicate how they are cleared.
 * FLAG_PRECHECK
 *	This is for the data access exception only. See it for
 *	more info.
 *
 * What's in between PREP() and DONE() (usually a CALL) is the actual
 * servicing of the interrupt.  During this time, any register may
 * be used freely as they've all been saved in the exception frame
 * (which is pointed-to by r31).
 */
d355 1
a355 1
#define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK) \
d358 1
d360 1
a360 1
	stcr	r1, SR2	/* r1 now free */		; \
d364 1
a364 1
	 clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
d366 1
d369 1
d376 1
d380 1
d384 1
d387 1
a387 1
#endif
d390 1
a390 1
#define PREP2(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK) \
d395 1
a395 1
	stcr	r1, SR2	/* r1 now free */		; \
d397 5
a401 4
	ldcr	r1, EPSR 				; \
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f 	; \
	 clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL> 	; \
	set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
d404 1
d408 1
d412 1
d415 1
a415 1
#endif
d418 7
a424 8
#define	No_SSBR_Stuff		/* empty */
#define	Clear_SSBR_Dest \
	bsr	clear_dest_ssbr_bit
#define	No_Precheck		/* empty */
#define	Data_Precheck \
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, ignore_data_exception
#define	M88110_Data_Precheck \
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, m88110_ignore_data_exception
d427 17
a443 18
/*
 * If we allow debugging, there is a variable "eh_debug"
 * in which there is a bit for each exception.  If the bit
 * is set for an exception, debugging information is printed
 * about that exception whenever it occurs.
 *
 * The bits are defined in "asm.h"
 */

GLOBAL(eh_debug)
	word	0x00000000

/*
 * additional pre-servicing preparation to be done when
 * debugging... check eh_debug and make the call if
 * need be.
 */
#define PREP_DEBUG(DebugNumber, Name) \
d454 1
a454 1
	 subu	r31, r31, 40			; \
d456 1
a456 1
	 addu	r31, r31, 40			; \
d458 1
a458 1
2:	string Name				; \
d462 1
a462 1
4:
d465 8
a472 8
/*
 * Post-servicing work to be done.
 * When debugging, check "eh_debug" and call the
 * debug routined if neeed be.
 *
 * Then, return from the interrupt handler.
 */
#define DONE(DebugNumber) \
d480 7
a486 8
/*
 * If not debugging, then no debug-prep to do.
 * Also, when you're done, you're done!   (no debug check).
 */
#define	PREP_DEBUG(bit, name)
#define	DONE(num) \
	br	return_from_exception_handler
#endif	/* EH_DEBUG */
d489 3
a491 3
/*
 * MVME18x exception handlers
 */
d539 4
a542 4
	stcr	r1, SR2		/* hold r1 for a moment */
	ldcr	r1, SXIP	/* look at the sxip... valid bit set? */
	bb1.n	RTE_VALID_BIT, r1, 1f	/* skip over if a valid exception */
	 ldcr	r1, SR2		/* restore r1 */
d545 1
a545 1
	CALL(_C_LABEL(m88100_trap), T_PRIVINFLT, r30)
d570 1
a570 2
#define	FPp_SSBR_STUFF \
	bsr	clear_FPp_ssbr_bit
d573 1
a573 1
	CALL(_m88100_Xfp_precise, r0, r30)
d577 1
a577 2
#define	FPi_SSBR_STUFF \
	bsr	clear_FPi_ssbr_bit
d580 1
a580 1
	CALL(_Xfp_imprecise, r0, r30)
d586 2
a587 2
	ld	r13, r30, GENREG_OFF(13)
	CALL(_m88100_syscall, r13, r30)	/* system call no. is in r13 */
d593 2
a594 2
	ld	r9, r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)	/* system call no. is in r9 */
d617 1
a617 1
#ifdef DDB
d632 2
a633 1
#else
d648 3
a650 1
#endif
d664 2
a665 2
	/* pick up the slavestack */
	or	r26, r0,  r31	/* save old stack */
d673 1
a673 1
	bb1	ge,  r28, 2f	/* branch if at the end of the stack */
d676 2
a677 2
	 addu	r27, r27, 4	/* bump up */
2:	/* stack has been cleared */
d679 2
a680 2
	/* ensure that stack is 8-byte aligned */
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d682 2
a683 2
	/* create exception frame on stack */
	subu	r31, r31, SIZEOF_EF	/* r31 now our E.F. */
d685 15
a699 15
	/* save old R31 and other R registers */
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st	r30, r31, GENREG_OFF(30)
d701 1
a701 1

d715 1
a715 1
	stcr	r0,  SSBR	/* won't want shadow bits bothering us later */
d736 1
a736 1

d750 1
a750 1
#define	IST_REG		0xfff84040	/* interrupt status addr */
d756 1
a756 1
	or.u	r10,  r0,   hi16(IST_REG)	/* interrupt status register */
d758 2
a759 2
	st	r11,  r31,  REG_OFF(EF_MASK)	/* put in EF_MASK for regdump */
#endif /* MVME188 */
d763 4
a766 4
3:	ldcr	r10, PSR
	clr	r10, r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	r10, r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	r10, PSR
d772 3
a774 3
	subu	r31, r31, 0x10	/* make some breathing space */
	st	r30, r31, 0x0c	/* store frame pointer on the st */
	st	r30, r31, 0x08	/* store again for the debugger to recognize */
d780 1
a780 1
	CALL(_C_LABEL(error_fault), r30, r30)
d782 5
a786 5
	/* turn interupts back on */
	ldcr	r1, PSR
	clr	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE
d788 2
a789 3
GLOBAL(error_loop)
	bsr	_error_loop
	/* never returns*/
d793 2
a794 2
 * The reset exception is raised when the RST signal is asserted (machine
 * is reset), the value of VBR is changed after exceptions are enabled,
d800 2
a801 2
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0
 * to handle it!!!
d803 1
a803 1
 * This is totaly different than _error_handler.  Shadowing might or
d811 2
a812 2
	/* pick up the slavestack */
	or	r26, r0, r31	/* save old stack */
d820 1
a820 1
	bb1	ge,  r28, 2f	/* branch if at the end of the stack */
d823 1
a823 1
	 addu	r27, r27, 4	/* bump up */
d827 1
a827 1
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d830 1
a830 1
	subu	r31, r31, SIZEOF_EF	/* r31 now our E.F. */
d862 1
a862 1
	stcr	r0,  SSBR	/* won't want shadow bits bothering us later */
d900 5
a904 5
	ldcr	r10, PSR
	clr	r10, r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	r10, r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */

	stcr	r10, PSR
d910 3
a912 3
	subu	r31, r31, 0x10	/* make some breathing space */
	st 	r30, r31, 0x0c	/* store frame pointer on the st */
	st 	r30, r31, 0x08	/* store again for the debugger to recognize */
d920 4
a923 4
	/* turn interupts back on */
	ldcr	r1, PSR
	clr	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
d926 2
a927 3
GLOBAL(error_loop2)
	bsr	_error_loop2
	/* never returns*/
d933 8
a940 8
	/*
	 * SR0: pointer to the current thread structure
	 * SR1: previous FLAGS reg
	 * SR2: free
	 * SR3: must presere
	 * FLAGS: CPU status flags
	 */
	xcr	FLAGS, FLAGS, SR1	/* replace SR1, FLAGS */
d955 6
a960 1
	stcr	r2, SNIP	/* Make it the next instruction to execute */
a961 4
	addu	r2, r2, 4
	stcr	r2, SFIP	/* and the next one after that, too. */
	stcr	r0, SSBR	/* make the scoreboard happy. */
1:
d971 8
a978 8
	/*
	 * SR0: pointer to the current thread structure
	 * SR1: previous FLAGS reg
	 * SR2: free
	 * SR3: must preserve
	 * FLAGS: CPU status flags
	 */
	xcr	FLAGS, FLAGS, SR1	/* replace SR1, FLAGS */
d992 3
a994 3
	stcr	r2, EXIP	/* Make it the next instruction to execute */

	/* the following jumps to "m88110_badaddr__return_nonzero" below */
d998 1
d1041 1
a1041 1
	 stcr	r5,  SR1
d1047 2
a1048 2
	bb1	0, r2, badaddr__return_nonzero
	bb1	1, r2, badaddr__return_nonzero
d1058 1
a1058 1
	ld	r5, r2, 0
d1060 2
a1061 2
	br.n	badaddr__return
	 or	r2, r0, r0	/* indicate a zero (address not bad) return.*/
d1065 2
a1066 2
	sub	r6, r3, 2
	bcnd	ne0, r6, badaddr__maybe_byte
d1069 1
a1069 1
	bb1	0, r2, badaddr__return_nonzero
d1072 1
a1072 1
	ld.h	r5, r2, 0
d1074 2
a1075 2
	br.n	badaddr__return
	 or	r2, r0, r0
d1079 2
a1080 2
	sub	r6, r3, 1
	bcnd	ne0, r6, badaddr__unknown_size
d1082 1
a1082 1
	ld.b	r5, r2, 0
d1084 2
a1085 2
	br.n	badaddr__return
	 or	r2, r0, r0
d1087 1
a1087 1
#ifdef	DEBUG
d1091 7
a1097 7
	or.u	r2, r0, hi16(1b)
	or	r2, r2, lo16(1b)
	or	r4, r0, r1
	bsr	_C_LABEL(printf)
	or.u	r2, r0, hi16(1b)
	or	r2, r2, lo16(1b)
	bsr	_C_LABEL(panic)
d1102 1
a1102 1
	or	r2, r0, 1
d1106 3
a1108 3
	ldcr	r4, SR1
	clr	r4, r4, 1<FLAG_IGNORE_DATA_EXCEPTION>
	stcr	r4, SR1
d1118 2
a1119 2
	stcr	r8, PSR
	jmp	r1
d1122 2
a1123 2
	/*
	 * On mc88110, we possibly took an exception
d1125 2
a1126 2
	 * instruction clears the EFRZ bit in
	 * the PSR.
d1128 4
a1131 4
	stcr	r0, DSR	/* Clear DSR reg on mc88110 */
	stcr	r0, DLAR	/* Clear DLAR reg on mc88110 */
	br.n	badaddr__return_nonzero
	 stcr	r0, DPAR	/* Clear DPAR reg on mc88110 */
d1133 7
a1139 1
#ifdef M88100
d1142 14
a1155 13
	/*
	 * SR0: current thread (if any, null if not)
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: saved copy of exception-time r1
	 * SR3: must be preserved .. may be the exception-time stack
	 * r1: return address to calling exception handler
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *  Decide where we're going to put the exception frame.
	 *  Might be at the end of R31, SR3, or the thread's pcb.
	 */

d1170 15
a1184 15
	/*
	 * SR0: current thread (if any, null if not)
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; may be important for other exceptions
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   We're already on the kernel stack, but not having
	 *   needed to use SR3. We can just make room on the
	 *   stack (r31) for our exception frame.
	 */
	subu	r31,  r31,  SIZEOF_EF		/* r31 now our E.F. */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now r1 free)*/
d1186 1
a1186 1
	ldcr	r1,   SR3			/* save previous SR3 */
d1189 1
a1189 1
	addu	r1,   r31,  SIZEOF_EF		/* save previous r31 */
d1191 2
a1192 1
	 st 	r1,   r31,  GENREG_OFF(31)
d1195 28
a1222 26
	/*
	 * SR0: current thread (if any, null if not)
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; exception-time stack pointer
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   An exception occured while enabling the FPU. Since r31
	 *   is the user's r31 while enabling the FPU, we had put
	 *   our pcb pointer into SR3, so make room from
	 *   there for our stack pointer.
	 *   We need to check if SR3 is the old stack pointer or the
	 *   pointer off to the user pcb. If it pointing to the user
	 *   pcb, we need to pick up the kernel stack. Otherwise
	 *   we need to allocate a frame upon it.
	 *   We look at the EPSR to see if it was from user mode
	 *   Unfortunately, we have no registers free at the moment
	 *   But we know register 0 in the pcb frame will always be
	 *   zero, so we can use it as scratch storage.
	 */
	xcr	r30,  r30,  SR3			/* r30 = old exception frame */
	st	r1,   r30,  GENREG_OFF(0)	/* free up r1 */
	ld	r1,   r30,  REG_OFF(EF_EPSR)	/* get back the epsr */
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f	/* if user mode */
	 ld	r1,   r30,  GENREG_OFF(0)	/* restore r1 */
d1224 9
a1232 9
	st	r0,   r30,  GENREG_OFF(0)	/* repair old frame */
	subu	r30,  r30,  SIZEOF_EF		/* r30 now our E.F. */
	st	FLAGS,r30,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r30,  GENREG_OFF(1)	/* save prev r1 (now free) */

	st	r31,  r30,  GENREG_OFF(31)	/* save previous r31 */
	or	r31,  r0,   r30			/* make r31 our pointer. */
	addu	r30,  r30,  SIZEOF_EF		/* r30 now has previous SR3 */
	st	r30,  r31,  REG_OFF(EF_SR3)	/* save previous SR3 */
d1234 1
a1234 1
	 xcr	r30,  r30,  SR3			/* restore r30 */
d1243 7
a1249 7
	st	FLAGS,r1,   REG_OFF(EF_FLAGS)	/* store flags */
	st	r31,  r1,   GENREG_OFF(31)	/* store r31 - now free */
	st	r30,  r1,   REG_OFF(EF_SR3)	/* store old SR3 (pcb) */
	or	r31,  r1,   r0			/* make r31 our exception fp */
	ld	r1,   r30,  GENREG_OFF(0)	/* restore old r1 */
	st	r0,   r30,  GENREG_OFF(0)	/* repair that frame */
	st	r1,   r31,  GENREG_OFF(1)	/* store r1 */
d1251 1
a1251 1
	 xcr	r30,  r30,  SR3			/* restore r30 */
d1254 13
a1266 13
	/*
	 * SR0: current thread
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Since we're servicing an exception from user mode, we
	 *   know that SR3 is free.  We use it to free up a temp.
	 *   register to be used in getting the thread's pcb
	 */
	stcr	r31,  SR3	/* save previous r31 */
d1271 4
a1274 4
	addu	r31,  r31,  PCB_USER_STATE	/* point to user save area */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free) */
	ldcr	r1,   SR3			/* save previous r31 */
d1276 1
a1276 1
	/* FALLTHROUGH */
d1279 17
a1295 17
	/*
	 * SR0: current thread
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * r1:  free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Save the shadow registers that need to be saved to
	 *   the exception frame.
	 */
	stcr	TMP, SR3	/* free up TMP, TMP2, TMP3 */
d1306 2
a1307 2
	/* get and store the cpu number */
	extu	TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
d1309 1
a1309 1

d1319 1
a1319 1

d1321 1
a1321 1
	cmp	TMP2, TMP, 0x0				/* CPU0 ? */
d1323 1
a1323 1
	cmp	TMP2, TMP, 0x1				/* CPU1 ? */
d1325 1
a1325 1
	cmp	TMP2, TMP, 0x2				/* CPU2 ? */
d1327 1
a1327 1
	cmp	TMP2, TMP, 0x3				/* CPU3 ? */
d1329 2
a1330 2
	/* Arrrrg! bad cpu# */
	br	Lbadcpupanic
d1367 1
a1367 1
5:
d1369 1
a1369 1
	/* it's a single processor SBC */
d1382 1
a1382 1

d1384 12
a1395 12
/*
 * The following is a kludge so that
 * a core file will have a copy of
 * DMT0 so that 'sim' can display it
 * correctly.
 * After a data fault has been noticed,
 * the real EF_DTM0 is cleared, so I need
 * to throw this somewhere.
 * There's no special reason I chose this
 * register (FPIT)... it's just one of many
 * for which it causes no pain to do this.
 */
d1399 7
a1405 7
/*
 * The above shadow registers are obligatory for any and all
 * exceptions.  Now, if the data access pipeline is not clear,
 * we must save the DMx shadow registers, as well as clear
 * the appropriate SSBR bits for the destination registers of
 * loads or xmems.
 */
d1407 1
a1407 1
	 st	TMP3, r31,  REG_OFF(EF_DMT0)
d1430 5
a1434 4
/*
 * need to clear "appropriate" bits in the SSBR before
 * we restart the FPU
 */
d1439 1
a1439 2
	/* make sure an exception in fpu_enable will not see our DMT0 */
	 stcr	r0,   DMT0
d1469 1
a1469 1
	 set	TMP2, TMP2, 1<5>
d1477 19
a1495 19
	/*
	 * SR0: current thread
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: saved TMP
	 * r1:  free
	 * TMP: possibly revised SSBR
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r31: exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Dmt0.
	 *   Other data pipeline control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 */
d1497 1
a1497 1
	jmp	r1	/* allow the handler to clear more SSBR bits */
d1499 4
a1502 1
#endif /* M88100 */
d1509 4
a1512 4
	 * r1:  return address to calling exception handler
	 * TMP: (possibly) revised ssbr
	 * TMP2: free
	 * TMP3: free
d1535 3
a1537 3
	extu	TMP2, TMP2, 5<0>	/* get the reg. */
	set	TMP2, TMP2, 1<6>	/* set width */
	clr	TMP,  TMP,  TMP2
d1540 5
a1544 1
	jmp	r1
d1552 25
a1576 9
	 * r1:  return address to calling exception handler
	 * TMP: (possibly) revised ssbr
	 * TMP2: free
	 * TMP3: free
	 */
	fldcr	TMP2, FPSR
	fldcr	TMP3, FPCR
	st	TMP2, r31,  REG_OFF(EF_FPSR)
	st	TMP3, r31,  REG_OFF(EF_FPCR)
d1578 8
a1585 15
	fldcr	TMP3, FPECR
	st	TMP3, r31,  REG_OFF(EF_FPECR)
	fldcr	TMP2, FPHS1
	fldcr	TMP3, FPHS2
	st	TMP2, r31,  REG_OFF(EF_FPHS1)
	st	TMP3, r31,  REG_OFF(EF_FPHS2)

	fldcr	TMP2, FPLS1
	fldcr	TMP3, FPLS2
	st	TMP2, r31,  REG_OFF(EF_FPLS1)
	st	TMP3, r31,  REG_OFF(EF_FPLS2)

	fldcr	TMP2, FPPT
	st	TMP2, r31,  REG_OFF(EF_FPPT)
1:
a1586 8
#define FPPT_SIZE_BIT   5
	bb1.n	FPPT_SIZE_BIT, TMP2, 2f
	 extu	TMP3, TMP2, 5<0>	/* get FP operation dest reg */
	br.n	3f
	 set	TMP3, TMP3, 1<5>	/* size=1 - clear one bit for float */
2:	set	TMP3, TMP3, 1<6>	/* size=2 - clear two bit for double */
3:	clr	TMP,  TMP,  TMP3	/* clear bit(s) in ssbr. */
4:	jmp	r1
d1588 2
d1613 10
a1622 10
	 *  TMP: (possibly) revised ssbr
	 *  TMP2: free
	 *  TMP3: free
	 */

	ldcr	TMP3, EPSR	/* going to check: user or system memory? */
	ldcr	TMP2, SXIP	/* get the instruction's address */
	bb1.n	PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
	 clr	TMP2, TMP2, 2<0>	/* get rid of valid and error bits. */

d1626 1
a1626 1
	ld.usr	TMP2,TMP2, r0	/* get the instruction itself */
d1633 1
a1633 1
	 ld.usr	TMP2,TMP2, r0	/* get the instruction itself */
d1637 1
a1637 1
	ld	TMP2, TMP2, r0	/* get the instruction itself */
d1639 1
a1639 1
3:	/* now we have the instruction..... */
d1659 5
a1663 5
	extu	TMP3, TMP2, 16<16>	/* get the upper 16 bits */
	mask	TMP3, TMP3, 0xFC00	/* apply the mask */
	cmp	TMP3, TMP3, 0x1000	/* if equal, it's a load double */
	bb1	eq,   TMP3, misaligned_double

d1666 5
a1670 5
	extu	TMP3, TMP2, 16<16>	/* get the upper 16 bits */
	mask	TMP3, TMP3, 0xFC00	/* apply the mask */
	cmp	TMP3, TMP3, 0xF400	/* if equal, might be a load double */
	bb1	ne,   TMP3, misaligned_single	/* not equal, must be single */

d1672 5
a1676 5
	extu	TMP3, TMP2, 16<0>	/* get the lower 16 bits */
	mask	TMP3, TMP3, 0xFCE0	/* apply the mask */
	cmp	TMP3, TMP3, 0x1000	/* if equal, it's a load double */
	bb1	eq,   TMP3, misaligned_double

d1678 3
a1680 3
	extu	TMP2, TMP2, 5<21>	/* get the destination register */
	br.n	1f
	 set	TMP2, TMP2, 1<5>	/* set size=1 */
d1683 5
a1687 2
	extu	TMP2, TMP2, 5<21>	/* get the destination register */
	set	TMP2, TMP2, 1<6>	/* set size=2 -- clear two bits */
d1689 2
a1690 2
1:	jmp.n	r1
	 clr	TMP,  TMP,  TMP2	/* clear bit(s) in ssbr. */
d1695 31
a1725 31
	/*
	 * SR0: saved return address to calling exception handler
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: free
	 * SR3: saved TMP
	 * r1:  return address to calling exception handler
	 * TMP: possibly revised SSBR
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 *    Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   restore the system to the exception-time state (except
	 *   SR3 will be OUR stack pointer) so that we may resart the FPU.
	 */
	/*stcr	r1, SR0*/	/* save return address */

	stcr	TMP,  SSBR	/* done with SSBR, TMP now free */
	RESTORE_TMP2	/* done with extra temp regs */
	RESTORE_TMP3	/* done with extra temp regs */

d1728 5
a1732 5
	ldcr	TMP,  PSR
	clr	TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	TMP,  EPSR

d1734 5
a1738 5
	or.u	TMP,  r0,   hi16(fpu_enable +2)
	or	TMP,  TMP,  lo16(fpu_enable +2)
	stcr	TMP,  SNIP	/* jump to here fpu_enable */
	addu	TMP,  TMP,  4
	stcr	TMP,  SFIP	/* and then continue after that */
d1740 10
a1749 10
	ldcr	TMP,  PSR
	or.u	TMP,  TMP,  0x8000	/* set supervisor mode */
	and	TMP,  TMP,  0xfff7	/* also enable shadowing */
	stcr	TMP,  EPSR
	stcr	r0,   SXIP	/* clear valid bit */
	stcr	r0,   SNIP	/* clear valid bit */
	or.u	TMP,  r0,   hi16(fpu_enable)
	or	TMP,  TMP,  lo16(fpu_enable)
	or	TMP,  TMP,  0x2	/* set the VALID_BIT and clear Exception bit */
	stcr	TMP,  SFIP	/* jump to here fpu_enable */
d1753 34
a1786 34
	set	FLAGS, FLAGS, 1<FLAG_ENABLING_FPU>
	xcr	FLAGS, FLAGS, SR1
	st	r1,   r31,  REG_OFF(EF_RET)	/* save the return address */
	ld	r1,   r31,  GENREG_OFF(1)	/* get original r1 */

	xcr	TMP,  r31,  SR3	/* TMP now restored. R31 now saved in SR3 */
	ld	r31,  r31,  GENREG_OFF(31)	/* get original r31 */

	/*
	 * SR0: current thread
	 * SR1: CPU flags
	 * SR2: free
	 * SR3: pointer to our exception frame (our stack pointer)
	 * r1 through r31: original exception-time values
	 *
	 * Valid in the exception frame:
	 *   Exception-time FLAGS.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *   Held temporarly in the exception frame:
	 *   Return address to the calling excption handler.
	 *
	 * immediate goal:
	 *   Do an RTE to restart the fpu and jump to "fpu_enable"
	 *   Another exception (or exceptions) may be raised in
	 *   this, which is why FLAG_ENABLING_FPU is set in SR1.
	 */

	RTE	/* jumps to "fpu_enable" on the next line to enable the FPU. */

d1789 5
a1793 5
	xcr	TMP,  TMP,  SR3			/* get E.F. pointer */
	st.d	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
	or	r31,  TMP,  r0			/* transfer E.F. pointer to r31 */
	ld	TMP,  r31,  REG_OFF(EF_SR3)	/* get previous SR3 */

d1795 6
a1800 6
	xcr	FLAGS,FLAGS,SR1
	clr	FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr	FLAGS,FLAGS,SR1

	xcr	TMP,  TMP,  SR3	/* replace TMP, SR3 */

d1802 15
a1816 15
	st.d	r0 ,  r31,  GENREG_OFF(0)
	st.d	r2 ,  r31,  GENREG_OFF(2)
	st.d	r4 ,  r31,  GENREG_OFF(4)
	st.d	r6 ,  r31,  GENREG_OFF(6)
	st.d	r8 ,  r31,  GENREG_OFF(8)
	st.d	r10,  r31,  GENREG_OFF(10)
	st.d	r12,  r31,  GENREG_OFF(12)
	st.d	r14,  r31,  GENREG_OFF(14)
	st.d	r16,  r31,  GENREG_OFF(16)
	st.d	r18,  r31,  GENREG_OFF(18)
	st.d	r20,  r31,  GENREG_OFF(20)
	st.d	r22,  r31,  GENREG_OFF(22)
	st.d	r24,  r31,  GENREG_OFF(24)
	st.d	r26,  r31,  GENREG_OFF(26)
	st.d	r28,  r31,  GENREG_OFF(28)
d1819 3
a1821 3
	or.u	r20,  r0,   hi16(0x12345678)
	or	r20,  r20,  lo16(0x12345678)
	st	r20,  r31,  GENREG_OFF(0)
d1827 32
a1858 29

	/*
	 * SR0: current thread
	 * SR1: free
	 * SR2: free
	 * SR3: previous exception-time SR3
	 * r1: return address to the calling exception handler
	 * r2 through r30: free
	 * r31: our exception frame
	 *
	 * Valid in the exception frame:
	 *   Exception-time r0 through r31.
	 *   Exception-time FLAGS.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Pick up a stack if we came in from user mode.
	 *   Put a copy of the exception frame pointer into r30
	 *   Bump the stack a doubleword and write the exception frame pointer.
	 *   If not an interrupt exception, turn on interrupts and service any
	 *     outstanding data access exceptions.
	 *   Return to calling exception handler to service the exception.
	 */

d1863 1
a1863 1
#ifdef INTSTACK
d1869 11
a1879 11
	or	r30,  r0,   r31		/* get a copy of the e.f. pointer */
	ld	r2,   r31,  REG_OFF(EF_EPSR)
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, 1f	/* if in kernel mode */

#ifdef INTSTACK
	ld	r3,   r31,  REG_OFF(EF_VECTOR)
	cmp	r3,   r3,   1	/* is interrupt ? */
	bb0	eq,   r3,   2f
	or.u	r31,  r0,   hi16(_intstack_end)	/* switch to int stack */
	or	r31,  r31,  lo16(_intstack_end)
	br	3f
d1882 4
a1885 4
	or.u	r31,  r0,   hi16(_kstack)
	ld	r31,  r31,  lo16(_kstack)
	addu	r31,  r31,  USIZE	/* point at proper end */
	br	3f
d1887 7
a1893 7
#ifdef INTSTACK
	ld	r3,   r31,  REG_OFF(EF_VECTOR)
	cmp	r3,   r3,   1	/* is interrupt ? */
	bb0	eq,   r3,   3f	/* no, we will stay on kern stack */
	or.u	r31,  r0,   hi16(_intstack_end)	/* switch to int stack */
	or	r31,  r31,  lo16(_intstack_end)
#endif
d1895 1
a1895 2
exception_handler_has_ksp:
global exception_handler_has_ksp
d1899 5
a1903 5
	 */
	subu	r31,  r31,  8	/* make some breathing space */
	st	r30,  r31,  0	/* store frame pointer on the stack */
#ifdef DDB
	st	r30,  r31,  4	/* store it for the debugger to recognize */
d1906 17
a1922 18
	ld	r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n	eq0,  r2,   return_to_calling_exception_handler	/* is error */
	 ld	r14,  r30,  REG_OFF(EF_RET)
	cmp	r3,   r2,   1	/* is an interrupt? */
	bb1.n	eq,   r3,   return_to_calling_exception_handler	/* skip if so */

#ifdef DDB
	 cmp	r3,   r2,   130	/* DDB break exception */
	bb1.n	eq,   r3,   return_to_calling_exception_handler
	 cmp	r3,   r2,   132	/* DDB entry exception */
	bb1.n	eq,   r3,   return_to_calling_exception_handler
#endif

	/* enable interrupts */
	 ldcr	r2,   PSR
	clr	r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2,   PSR
#ifdef     DDB
d1927 1
a1927 1
	   - check dmt0 anything outstanding? */
d1929 2
a1930 2
	ld	r3,   r30,  REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r3, return_to_calling_exception_handler
d1933 2
a1934 2
	 * r30 can be clobbered by calls. So stuff its value into a preserved
	 * register, say r15. R14 is in use (see return_to_... below).
d1936 1
a1936 1
	or	r15,  r0,   r30
d1941 2
a1942 2
	/* restore it... */
	or	r30,  r0,   r15
d1945 1
a1945 1
	st	r0,   r30,  REG_OFF(EF_DMT0)
d1948 3
a1950 2
	jmp	r14	/* loaded above */
#endif /* M88100 */
d1965 1
a1965 1
	 subu	r31,r31,40	/* create stack space for function */
d1968 1
a1968 1
	ld	r2, r31,4	/* & proc pointer from switch frame */
d1970 1
a1970 1
	 addu	r31,r31,8
d1974 1
a1974 1
 * proc_do_uret
d2004 1
a2004 1
#ifdef M88110
d2008 2
a2009 2
	bb1	eq, r2, m88110_return_code
#endif
d2011 2
a2012 2
#define	FPTR	r14
	ld	FPTR, r31, 0	/* grab exception frame pointer */
d2014 1
a2014 1
	bb0	DMT_VALID_BIT, r3, check_ast
d2019 1
a2019 1
	 * in an exception handler...
d2022 1
a2022 1
	cmp	r2, r2, 1	/* is an interrupt? */
d2026 1
a2026 1
#ifdef DDB
d2030 1
a2030 1
	br	1f
d2041 1
a2041 1

d2046 3
a2048 3
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1	/* is an interrupt? */
        bb1	ne, r2, 1f	/* If not so, skip */
d2051 4
a2054 4
	ld	r2, FPTR, REG_OFF(EF_EPSR)
        bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f	/* skip if disabled */
	ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* enable interrupts */
d2056 1
a2056 1
        stcr	r2, PSR
d2058 2
a2059 2
	ld	r2, FPTR, REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r2, 2f
d2066 1
a2066 1
	CALL(_C_LABEL(data_access_emulation), r30, r0)	/* really only 2 args */
d2068 1
a2068 1
	st	r0 , FPTR, REG_OFF(EF_DMT0)
d2070 2
a2071 2
	br	check_ast
#endif /* M88100 */
d2075 2
a2076 2
#define	FPTR	r14
	ld	FPTR, r31, 0	/* grab exception frame pointer */
d2086 1
a2086 1
	 *
d2090 2
a2091 2
	cmp	r2, r2, 1	/* Is it an interrupt? */
	bb1	ne, r2, 1f	/* If not, skip */
d2095 1
a2095 1
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f	/* skip if disabled */
d2097 1
a2097 1
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* enable interrupts */
d2101 1
a2101 1
	br	2f	/* temp XXX smurph */
d2103 2
a2104 2
	cmp	r2, r2, 3	/* Is it a data access exception? */
	bb1	ne, r2, 2f	/* If not, skip */
a2124 4
	ld	r2, FPTR, REG_OFF(EF_EPSR)	/* get pre-exception PSR */
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f	/* skip if ints off */
	ld	r2, FPTR, REG_OFF(EF_MASK)	/* get pre-exception ipl */
	bcnd	ne0, r2, 1f		/* can't do softint's */
d2126 5
d2132 3
a2134 3
	bsr.n	_C_LABEL(setipl)
	 or	r2,r0,1
	/* at ipl 1 now */
d2136 1
a2136 1
	bsr	_C_LABEL(dosoftint)
d2139 2
a2140 2
	bsr.n	_C_LABEL(setipl)
	 or	r2,r0,0			/* ints are enabled */
d2144 2
a2145 2
	ld	r2, FPTR, REG_OFF(EF_EPSR)	/* get pre-exception PSR */
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, no_ast	/*skip if system mode */
d2147 9
a2155 9
	/* should assert here - not in user mode with ints off XXX nivas */
	/* get and check want_ast */
	or.u	r2, r0, hi16(_C_LABEL(want_ast))
	ld	r3, r2, lo16(_C_LABEL(want_ast))
	bcnd	eq0, r3, no_ast

	/*
	 * trap(AST,...) will service ast's.
	 */
d2163 1
a2163 1
	CALL(_C_LABEL(m88110_trap), T_ASTFLT, FPTR)
d2170 1
a2170 1
	CALL(_C_LABEL(m88100_trap), T_ASTFLT, FPTR)
a2173 5
	/* disable interrupts */
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	FLUSH_PIPELINE
	stcr	r1, PSR
d2175 7
a2181 1
	/* now ready to return....*/
d2183 2
a2184 2
	bsr.n	_C_LABEL(setipl)
	 ld	r2, FPTR, REG_OFF(EF_MASK)	/* get pre-exception ipl */
d2186 28
a2213 28

	/*
	 * Transfer the frame pointer to r31, since we no longer need a stack.
	 * No page faults here, and interrupts are disabled.
	 */
	or	r31, r0,  FPTR
	/* restore r1 later */
	ld.d	r2 , r31, GENREG_OFF(2)
	ld.d	r4 , r31, GENREG_OFF(4)
	ld.d	r6 , r31, GENREG_OFF(6)
	ld.d	r8 , r31, GENREG_OFF(8)
	ld.d	r10, r31, GENREG_OFF(10)
	ld.d	r12, r31, GENREG_OFF(12)
	ld.d	r14, r31, GENREG_OFF(14)
	ld.d	r16, r31, GENREG_OFF(16)
	ld.d	r18, r31, GENREG_OFF(18)
	ld.d	r20, r31, GENREG_OFF(20)
	ld.d	r22, r31, GENREG_OFF(22)
	ld.d	r24, r31, GENREG_OFF(24)
	ld.d	r26, r31, GENREG_OFF(26)
	ld.d	r28, r31, GENREG_OFF(28)
	/* restore r1, r30, r31 later */

	/* disable shadowing */
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
	FLUSH_PIPELINE
	stcr	r1, PSR
d2217 1
a2217 1
	or.u	r1, r0, hi16(_C_LABEL(cputyp))
d2221 6
a2226 6
	/* mc88110 needs the EXIP */
	ld	r30, r31, REG_OFF(EF_ENIP)
	ld	r1,  r31, REG_OFF(EF_EXIP)
	stcr	r30, ENIP
	stcr	r1,  EXIP
	br	2f
d2228 34
a2261 33
#endif
	st	r0, r31, REG_OFF(EF_IPFSR)
	st	r0, r31, REG_OFF(EF_DPFSR)

	/*
	 * Note: no need to restore the SXIP.
	 * When the "rte" causes execution to continue
	 * first with the instruction pointed to by the NIP
	 * and then the FIP.
	 *
	 * See MC88100 Risc Processor User's Manual, 2nd Edition,
	 * section 6.4.3.1.2-4
	 */
	ld	r30, r31, REG_OFF(EF_SNIP)
	ld	r1,  r31, REG_OFF(EF_SFIP)
	stcr	r0,  SSBR
	stcr	r30, SNIP
	stcr	r1,  SFIP
2:
	ld	r30, r31, REG_OFF(EF_EPSR)
	ld	r1,  r31, REG_OFF(EF_MODE)
	stcr	r30, EPSR

	/* Now restore r1, r30, and r31 */
	ld	r1,  r31, GENREG_OFF(1)
	ld.d	r30, r31, GENREG_OFF(30)

	RTE

#ifdef M88110
/*
 * MVME197 exception handlers
 */
d2303 1
a2303 1
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT, No_SSBR_Stuff, No_Precheck)
d2331 1
a2331 1
	CALL(_m88110_Xfp_precise, r0, r30)
d2361 2
a2362 2
	ld	r13, r30, GENREG_OFF(13)
	CALL(_m88110_syscall, r13, r30)	/* system call no. is in r13 */
d2368 2
a2369 2
	ld	r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)	/* system call no. is in r9 */
d2392 1
a2392 1
#ifdef DDB
d2407 1
a2407 1
#else
d2422 2
a2423 1
#endif
d2425 1
d2438 1
a2438 1
	xcr	r2, r2, SRX
d2440 1
a2440 1
	stcr	r2,  SR0
d2442 1
a2442 1
	 xcr	r2, r2, SRX
d2446 2
a2447 2
 * The reset exception is raised when the RST signal is asserted (machine
 * is reset), the value of VBR is changed after exceptions are enabled,
d2450 2
a2451 2
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0
 * to handle it!!!
d2453 1
a2453 1
 * This is totaly different than _error_handler.  Shadowing might or
d2461 2
a2462 2
	stcr	r0, SR0
	/* FALLTHROUGH */
d2464 2
a2465 2
	/* pick up the slavestack */
	or	r26, r0, r31	/* save old stack */
d2473 1
a2473 1
	bb1	ge,  r28, 2f	/* branch if at the end of the stack */
d2476 1
a2476 1
	 addu	r27, r27, 4	/* bump up */
d2480 1
a2480 1
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d2483 1
a2483 1
	subu	r31, r31, SIZEOF_EF		/* r31 now our E.F. */
d2486 14
a2499 14
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st	r30, r31, GENREG_OFF(30)
d2504 4
a2507 4
	st	r10, r31, REG_OFF(EF_VECTOR)
	cmp	r10, r10, 0	/* is it the reset exception? */
	bb1.n	ne,  r10, 1f	/* if not, skip */

d2509 1
a2509 1
	 ldcr	r10, EPSR
d2529 1
a2529 1
	 st	r10, r31, REG_OFF(EF_MODE)
d2531 1
a2531 1
1:
d2570 1
d2574 5
a2578 4
	ldcr	r10, PSR
	clr	r10, r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	r10, r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	r10, PSR
d2584 3
a2586 3
	subu	r31, r31, 0x10	/* make some breathing space */
	st	r30, r31, 0x0c	/* store frame pointer on the st */
	st	r30, r31, 0x08	/* store again for the debugger to recognize */
d2591 1
a2591 1

d2594 5
a2598 5
	/* turn interupts back on */
	ldcr	r1, PSR
	clr	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE
d2601 2
a2602 2
	bsr	m88110_error_loop
	/* never returns*/
d2605 14
a2618 13
	/*
	 * SR0: current thread (if any, null if not)
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: saved copy of exception-time r1
	 * SR3: must be preserved .. may be the exception-time stack
	 * r1: return address to calling exception handler
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Decide where we're going to put the exception frame.
	 *   Might be at the end of R31, SR3, or the thread's pcb.
	 */

d2622 1
a2622 1
	xcr	r1,   r1,   SR2
d2626 2
a2627 2

	bb1	FLAG_ENABLING_FPU, FLAGS, m88110_use_SR3_pcb
d2629 2
a2630 2
	bb0	FLAG_FROM_KERNEL, FLAGS, m88110_pickup_stack

d2633 24
a2656 23
	/*
	 * SR0: current thread (if any, null if not)
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; may be important for other exceptions
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   We're already on the kernel stack, but not having
	 *   needed to use SR3. We can just make room on the
	 *   stack (r31) for our exception frame.
	 */
	subu	r31,  r31,  SIZEOF_EF		/* r31 now our E.F. */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free) */

	ldcr	r1,   SR3			/* save previous SR3 */
	st	r1,   r31,  REG_OFF(EF_SR3)

	addu	r1,   r31,  SIZEOF_EF		/* save previous r31 */
	br.n	m88110_have_pcb
	 st	r1,   r31,  GENREG_OFF(31)

d2658 24
a2681 21
	/*
	 * SR0: current thread (if any, null if not)
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; exception-time stack pointer
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   An exception occured while enabling the FPU. Since r31 is the
	 *   user's r31 while enabling the FPU, we had put our pcb pointer
	 *   into SR3, so make room from there for our stack pointer.
	 *   We need to check if SR3 is the old stack pointer or the pointer
	 *   off to the user pcb. If it pointing to the user pcb, we need to
	 *   pick up the kernel stack. Otherwise we need to allocate a frame
	 *   upon it.
	 *   We look at the EPSR to see if it was from user mode
	 *   Unfortunately, we have no registers free at the moment, but we
	 *   know register 0 in the pcb frame will always be zero, so we can
	 *   use it as scratch storage.
	 */
	xcr	r2, r2, SRX
d2683 1
a2683 1
	stcr	r2,  SR0
d2685 1
a2685 1
	 xcr	r2, r2, SRX
d2687 5
a2691 5
	xcr	r30,  r30,  SR3			/* r30 = old exception frame */
	st	r1,   r30,  GENREG_OFF(0)	/* free up r1 */
	ld	r1,   r30,  REG_OFF(EF_EPSR)	/* get back the epsr */
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f	/* if user mode */
	 ld	r1,   r30,  GENREG_OFF(0)	/* restore r1 */
d2693 11
a2703 11
	st	r0,   r30,  GENREG_OFF(0)	/* repair old frame */
	subu	r30,  r30,  SIZEOF_EF		/* r30 now our E.F. */
	st	FLAGS,r30,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r30,  GENREG_OFF(1)	/* save prev. r1 (now free) */

	st	r31,  r30,  GENREG_OFF(31)	/* save previous r31 */
	or	r31,  r0,   r30			/* make r31 our pointer. */
	addu	r30,  r30,  SIZEOF_EF		/* r30 now has previous SR3 */
	st	r30,  r31,  REG_OFF(EF_SR3)	/* save previous SR3 */
	br.n	m88110_have_pcb
	 xcr	r30,  r30,  SR3			/* restore r30 */
d2705 1
a2705 2
	/*
	 * We took an exception while restarting the FPU from user space.
d2708 14
a2721 15
	 * r30)
	 */
	or.u	r1,   r0,   hi16(_kstack)
	ld	r1,   r1,   lo16(_kstack)
	addu	r1,   r1,   USIZE-SIZEOF_EF
	st	FLAGS,r1,   REG_OFF(EF_FLAGS)	/* store flags */
	st	r31,  r1,   GENREG_OFF(31)	/* store r31 - now free */
	st	r30,  r1,   REG_OFF(EF_SR3)	/* store old SR3 (pcb) */
	or	r31,  r1,   r0			/* make r31 our exception fp */
	ld	r1,   r30,  GENREG_OFF(0)	/* restore old r1 */
	st	r0,   r30,  GENREG_OFF(0)	/* repair that frame */
	st	r1,   r31,  GENREG_OFF(1)	/* store r1 */
	br.n	m88110_have_pcb
	 xcr	r30,  r30,  SR3			/* restore r30 */

d2723 14
a2736 14
	/*
	 * SR0: current thread
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Since we're servicing an exception from user mode, we
	 *   know that SR3 is free.  We use it to free up a temporary
	 *   register to be used in getting the thread's pcb.
	 */
	stcr	r31,  SR3	/* save previous r31 */

d2738 9
a2746 9
	or.u	r31,  r0,   hi16(_curpcb)
	ld	r31,  r31,  lo16(_curpcb)
	addu	r31,  r31,  PCB_USER_STATE	/* point to user save area */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free)*/
	ldcr	r1,   SR3			/* save previous r31 */
	st	r1,   r31,  GENREG_OFF(31)
	/* FALLTHROUGH */

d2748 17
a2764 17
	/*
	 * SR0: current thread
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * r1:  free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Save the shadow registers that need to be saved to
	 *   the exception frame.
	 */
	stcr	TMP, SR3	/* free up TMP, TMP2, TMP3 */
d2767 1
a2767 1

d2769 5
a2773 5
	ldcr	TMP,  EPSR
	st	TMP,  r31,  REG_OFF(EF_EPSR)
	ldcr	TMP2, EXIP
	st	TMP2, r31,  REG_OFF(EF_EXIP)
	bb0.n	0,    TMP2, 1f
d2775 1
a2775 1
	 st	r0,   r31,  REG_OFF(EF_ENIP)
d2777 2
a2778 2
	ldcr	TMP3, ENIP
	st	TMP3, r31,  REG_OFF(EF_ENIP)
d2781 6
a2786 6
	st	r0,   r31,  REG_OFF(EF_SFIP)

	/* get and store the cpu number */
	extu	TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
	st	TMP,  r31,  REG_OFF(EF_CPU)

d2790 26
a2815 23
	ldcr	TMP,  ISR
	ldcr	TMP2, ILAR
	ldcr	TMP3, IPAR
	st	TMP,  r31,  REG_OFF(EF_ISR)
	st	TMP2, r31,  REG_OFF(EF_ILAR)
	st	TMP3, r31,  REG_OFF(EF_IPAR)
	ldcr	TMP,  ISAP
	ldcr	TMP2, IUAP
	st	TMP,  r31,  REG_OFF(EF_ISAP)
	st	TMP2, r31,  REG_OFF(EF_IUAP)
	ldcr	TMP,  DSR
	ldcr	TMP2, DLAR
	ldcr	TMP3, DPAR
	st	TMP,  r31,  REG_OFF(EF_DSR)
	st	TMP2, r31,  REG_OFF(EF_DLAR)
	st	TMP3, r31,  REG_OFF(EF_DPAR)
	ldcr	TMP,  DSAP
	ldcr	TMP2, DUAP
	st	TMP,  r31,  REG_OFF(EF_DSAP)
	st	TMP2, r31,  REG_OFF(EF_DUAP)

	ldcr	r1,   SR2
	jmp	r1
d2818 73
a2890 73
	/*
	 * SR0: saved return address to calling exception handler
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: free
	 * SR3: saved TMP
	 * r1:  return address to calling exception handler
	 * TMP: possibly revised SSBR
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time espr, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   restore the system to the exception-time state (except SR3 will
	 *   be OUR stack pointer) so that we may resart the FPU.
	 */
	/*stcr	r1, SR0*/	/* save return address */

	RESTORE_TMP2	/* done with extra temp regs */
	RESTORE_TMP3	/* done with extra temp regs */

	ldcr	TMP,  PSR
	clr	TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	TMP,  EPSR

	or.u	TMP,  r0,   hi16(m88110_fpu_enable)
	or	TMP,  TMP,  lo16(m88110_fpu_enable)
	stcr	TMP,  EXIP	/* jump to here fpu_enable */
	addu	TMP,  TMP,  4
	stcr	TMP,  ENIP	/* and then continue after that */

	set	FLAGS, FLAGS, 1<FLAG_ENABLING_FPU>
	xcr	FLAGS, FLAGS, SR1
	st	r1,   r31,  REG_OFF(EF_RET)	/* save the return address */
	ld	r1,   r31,  GENREG_OFF(1)	/* get original r1 */

	ldcr	TMP, SR3
	stcr	r31, SR3	/* TMP now restored. R31 now saved in SR3 */
	ld	r31,  r31,  GENREG_OFF(31)	/* get original r31 */

	/*
	 * SR0: current thread
	 * SR1: CPU flags
	 * SR2: free
	 * SR3: pointer to our exception frame (our stack pointer)
	 * r1 through r31: original exception-time values
	 *
	 * Valid in the exception frame:
	 *   Exception-time FLAGS.
	 *   Exception-time espr, sfip, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 * Held temporarly in the exception frame:
	 *   Return address to the calling excption handler.
	 *
	 * immediate goal:
	 *   Do an RTE to restart the fpu and jump to "fpu_enable"
	 *   Another exception (or exceptions) may be raised in
	 *   this, which is why FLAG_ENABLING_FPU is set in SR1.
	 */
d2892 2
a2893 2
	RTE	/* jumps to "fpu_enable" on the next line to enable the FPU. */

d2898 10
a2907 10
	stcr	r0, ISR				/* Clear ISR */
	stcr	r0, ILAR			/* Clear ILAR */
	stcr	r0, IPAR			/* Clear IPAR */
	stcr	r0, DSR				/* Clear DSR */
	stcr	r0, DLAR			/* Clear DLAR */
	stcr	r0, DPAR			/* Clear DPAR */
	xcr	TMP,  TMP,  SR3			/* get E.F. pointer */
	st.d	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
	or	r31,  TMP,  r0			/* transfer E.F. pointer */
	ld	TMP,  r31,  REG_OFF(EF_SR3)	/* get previous SR3 */
d2910 3
a2912 3
	xcr	FLAGS,FLAGS,SR1
	clr	FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr	FLAGS,FLAGS,SR1
d2914 1
a2914 1
	xcr	TMP,  TMP,  SR3	/* replace TMP, SR3 */
d2917 15
a2931 15
	st.d	r0 ,  r31,  GENREG_OFF(0)
	st.d	r2 ,  r31,  GENREG_OFF(2)
	st.d	r4 ,  r31,  GENREG_OFF(4)
	st.d	r6 ,  r31,  GENREG_OFF(6)
	st.d	r8 ,  r31,  GENREG_OFF(8)
	st.d	r10,  r31,  GENREG_OFF(10)
	st.d	r12,  r31,  GENREG_OFF(12)
	st.d	r14,  r31,  GENREG_OFF(14)
	st.d	r16,  r31,  GENREG_OFF(16)
	st.d	r18,  r31,  GENREG_OFF(18)
	st.d	r20,  r31,  GENREG_OFF(20)
	st.d	r22,  r31,  GENREG_OFF(22)
	st.d	r24,  r31,  GENREG_OFF(24)
	st.d	r26,  r31,  GENREG_OFF(26)
	st.d	r28,  r31,  GENREG_OFF(28)
d2934 36
a2969 33
	or.u	r20,  r0,   hi16(0x12345678)
	or	r20,  r20,  lo16(0x12345678)
	st	r20,  r31,  GENREG_OFF(0)
#endif

	/*
	 * SR0: current thread
	 * SR1: free
	 * SR2: free
	 * SR3: previous exception-time SR3
	 * r1: return address to the calling exception handler
	 * r2 through r30: free
	 * r31: our exception frame
	 *
	 * Valid in the exception frame:
	 *   Exception-time r0 through r31.
	 *   Exception-time FLAGS.
	 *   Exception-time espr, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *   DSR
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Pick up a stack if we came in from user mode.
	 *   Put a copy of the exception frame pointer into r30
	 *   Bump the stack a doubleword and write the exception frame pointer.
	 *   If not an interrupt exception, turn on interrupts and service any
	 *     outstanding data access exceptions.
	 *   Return to calling exception handler to service the exception.
	 */

d2974 3
a2976 3
	or	r30,  r0,   r31		/* get a copy of the e.f. pointer */
	ld	r2,   r31,  REG_OFF(EF_EPSR)
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, 1f	/* if in kernel mode */
d2978 1
a2978 1
#ifdef INTSTACK
d2983 6
a2988 6
	ld	r3,   r31,  REG_OFF(EF_VECTOR)
	cmp	r3,   r3,   1	/* is interrupt ? */
	bb0	eq,   r3,   2f
	or.u	r31,  r0,   hi16(_intstack_end)	/* switch to int stack */
	or	r31,  r31,  lo16(_intstack_end)
	br	3f
d2991 4
a2994 4
	or.u	r31,  r0,   hi16(_kstack)
	ld	r31,  r31,  lo16(_kstack)
	addu	r31,  r31,  USIZE		/* point at proper end */
	br	3f
d2996 7
a3002 7
#ifdef INTSTACK
	ld	r3,   r31,  REG_OFF(EF_VECTOR)
	cmp	r3,   r3,   1	/* is interrupt ? */
	bb0	eq,   r3,   3f	/* no, we will stay on kern stack */
	or.u	r31,  r0,   hi16(_intstack_end)	/* switch to int stack */
	or	r31,  r31,  lo16(_intstack_end)
#endif
d3004 1
a3004 2
m88110_exception_handler_has_ksp:
global m88110_exception_handler_has_ksp
d3009 4
a3012 4
	subu	r31,  r31,  8	/* make some breathing space */
	st	r30,  r31,  0	/* store frame pointer on the stack */
#ifdef DDB
	st	r30,  r31,  4	/* store it again for the debugger */
d3015 18
a3032 19
	ld	r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n	eq0,  r2,   m88110_return_to_calling_exception_handler
	 ld	r14,  r30,  REG_OFF(EF_RET)	/* load return value XXX!!! */
	cmp	r3,   r2,   1	/* is an interrupt? */
	bb1.n	eq,   r3,   m88110_return_to_calling_exception_handler

#ifdef DDB
	 cmp	r3,   r2,   130	/* DDB break exception */
	bb1.n	eq,   r3,   m88110_return_to_calling_exception_handler

	 cmp	r3,   r2,   132	/* DDB entry exception */
	bb1.n	eq,   r3,   m88110_return_to_calling_exception_handler
#endif

	/* enable interrupts */
	 ldcr	r2,   PSR
	clr	r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2,   PSR
#ifdef     DDB
d3036 1
a3036 1
	br	m88110_return_to_calling_exception_handler
d3039 1
a3039 1
	   - check dsr... anything outstanding? */
d3041 3
a3043 3
	ld	r3,   r30,  REG_OFF(EF_DSR)
	cmp	r3,   r3,   0
	bb1	eq,   r3,   m88110_return_to_calling_exception_handler
d3049 4
a3052 1
	or	r15,  r0,   r30
d3055 2
a3056 2
	/* restore it... */
	or	r30,  r0,   r15
d3059 1
a3059 1
	st	r0,   r30,  REG_OFF(EF_DSR)
d3062 2
a3063 2
	jmp	r14 /* loaded above */

d3067 2
a3068 2
	space SIZEOF_EF
#endif	/* M88110 */
@


1.1.1.3
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.32 2003/08/13 08:52:44 miod Exp $   */
d34 1
a34 1
 * 2. Make up my mind what is kstack. I think it should be p->p_addr+UPAGES.
d37 2
a38 1
 *   Whatever is kstack, its usage in this file should be revisited.
d217 1
d242 2
a243 2
ASLOCAL(sbadcpupanic)
	string	"eh.S: bad cpu number in FLAGS\000"
d248 4
a251 4
ASLOCAL(Lbadcpupanic)
	or.u	r2, r0, hi16(_ASM_LABEL(sbadcpupanic))
	bsr.n	_C_LABEL(panic)
	 or	r2, r2, lo16(_ASM_LABEL(sbadcpupanic))
d270 2
a271 2
	or.u	r31, r0,  hi16(_ASM_LABEL(save_frame))	; \
	or	r31, r31, lo16(_ASM_LABEL(save_frame))	; \
d359 1
a359 1
	/* the bsr later clobbers r1, so save now */	  \
d361 1
a361 1
	/* set or clear the FLAG_FROM_KERNEL bit */	  \
d366 3
a368 3
	/* get a stack (exception frame) */		  \
1:	bsr	_ASM_LABEL(setup_phase_one)		; \
	/* TMP2 now free -- use to set EF_VECTOR */	  \
d371 5
a375 5
	/* TMP3 also free -- use to set last_vector */	  \
	or.u	TMP3, r0,   hi16(_C_LABEL(last_vector))	; \
	st	TMP2, TMP3, lo16(_C_LABEL(last_vector))	; \
	/* Clear any bits in the SSBR (held in TMP) */	  \
	/* SSBR_STUFF may be empty, though.         */	  \
d377 4
a380 4
	/* call setup_phase_two to restart the FPU  */	  \
	/* and to save all general registers.       */	  \
	bsr	_ASM_LABEL(setup_phase_two)		; \
	/* All general regs free -- do any debugging */	  \
d397 1
a397 1
1:	bsr	_ASM_LABEL(m88110_setup_phase_one)	; \
d403 1
a403 1
	bsr	_ASM_LABEL(m88110_setup_phase_two)	; \
d411 1
a411 1
	bsr	_ASM_LABEL(clear_dest_ssbr_bit)
d414 1
a414 2
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, \
		_ASM_LABEL(ignore_data_exception)
d416 1
a416 2
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, \
		_ASM_LABEL(m88110_ignore_data_exception)
d428 1
a428 1
ASGLOBAL(eh_debug)
d437 18
a454 18
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 4f			; \
	/* call MY_info(ef,thread,flags,kind)*/		  \
	or	r2, r30, r0				; \
	ldcr	r3, SR0					; \
	ldcr	r4, SR1					; \
	or.u	r5, r0, hi16(2f)			; \
	or	r5, r5, lo16(2f)			; \
	bsr.n	_C_LABEL(MY_info)			; \
	 subu	r31, r31, 40				; \
	br.n	4f					; \
	 addu	r31, r31, 40				; \
	data						; \
2:	string Name					; \
	byte	0					; \
	align	4					; \
	text						; \
d466 6
a471 6
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 2f			; \
	ldcr	r4, SR1					; \
	CALL(_C_LABEL(MY_info_done), r31, r4)		; \
2:	br	_ASM_LABEL(return_from_exception_handler)
d479 1
a479 1
	br	_ASM_LABEL(return_from_exception_handler)
d498 1
d565 1
a565 1
	bsr	_ASM_LABEL(clear_FPp_ssbr_bit)
d568 1
a568 1
	CALL(_ASM_LABEL(m88100_Xfp_precise), r0, r30)
d573 1
a573 1
	bsr	_ASM_LABEL(clear_FPi_ssbr_bit)
d576 1
a576 1
	CALL(_ASM_LABEL(Xfp_imprecise), r0, r30)
d583 1
a583 1
	CALL(_C_LABEL(m88100_syscall), r13, r30)
d590 1
a590 1
	CALL(_C_LABEL(bugsyscall), r9, r30)
d659 2
a660 2
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
d663 2
a664 2
	or.u	r27, r0,  hi16(_C_LABEL(intstack))
	or	r27, r27, lo16(_C_LABEL(intstack))
d745 2
a746 2
	or.u	r10,  r0,   hi16(_C_LABEL(brdtyp))
	ld	r11,  r10,  lo16(_C_LABEL(brdtyp))
d781 2
a782 2
ASLOCAL(error_loop)
	bsr	_ASM_LABEL(error_loop)
d807 2
a808 2
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
d811 2
a812 2
	or.u	r27, r0,  hi16(_C_LABEL(intstack))
	or	r27, r27, lo16(_C_LABEL(intstack))
d920 2
a921 2
ASLOCAL(error_loop2)
	bsr	_ASM_LABEL(error_loop2)
d927 1
a927 1
ASLOCAL(ignore_data_exception)
d948 2
a949 2
	or.u	r2, r0, hi16(_ASM_LABEL(badaddr__return_nonzero) + 2)
	or	r2, r2, lo16(_ASM_LABEL(badaddr__return_nonzero) + 2)
d964 1
a964 1
ASLOCAL(m88110_ignore_data_exception)
d984 2
a985 2
	or.u	r2, r0, hi16(_ASM_LABEL(m88110_badaddr__return_nonzero))
	or	r2, r2, lo16(_ASM_LABEL(m88110_badaddr__return_nonzero))
d1021 1
a1022 1
	FLUSH_PIPELINE
d1033 1
a1033 1
	bcnd.n	ne0, r6, _ASM_LABEL(badaddr__maybe_halfword)
d1040 2
a1041 2
	bb1	0, r2, _ASM_LABEL(badaddr__return_nonzero)
	bb1	1, r2, _ASM_LABEL(badaddr__return_nonzero)
d1053 1
a1053 1
	br.n	_ASM_LABEL(badaddr__return)
d1056 1
a1056 1
ASLOCAL(badaddr__maybe_halfword)
d1059 1
a1059 1
	bcnd	ne0, r6, _ASM_LABEL(badaddr__maybe_byte)
d1062 1
a1062 1
	bb1	0, r2, _ASM_LABEL(badaddr__return_nonzero)
d1067 1
a1067 1
	br.n	_ASM_LABEL(badaddr__return)
d1070 1
a1070 1
ASLOCAL(badaddr__maybe_byte)
d1073 1
a1073 1
	bcnd	ne0, r6, _ASM_LABEL(badaddr__unknown_size)
d1077 1
a1077 1
	br.n	_ASM_LABEL(badaddr__return)
d1079 1
a1079 1
ASLOCAL(badaddr__unknown_size)
d1082 1
a1082 1
1: 	string "bad length (%d) to badaddr() from 0x%x\000"
d1086 5
a1090 2
	bsr.n	_C_LABEL(panic)
	 or	r4, r0, r1
d1110 1
a1111 1
	FLUSH_PIPELINE
d1114 1
a1114 1
ASLOCAL(m88110_badaddr__return_nonzero)
d1123 1
a1123 1
	br.n	_ASM_LABEL(badaddr__return_nonzero)
d1128 1
a1128 1
ASLOCAL(setup_phase_one)
d1138 2
a1139 2
	 *   Decide where we're going to put the exception frame.
	 *   Might be at the end of R31, SR3, or the thread's pcb.
d1150 1
a1150 1
	bb1	FLAG_ENABLING_FPU, FLAGS, _ASM_LABEL(use_SR3_pcb)
d1152 1
a1152 1
	bb0	FLAG_FROM_KERNEL, FLAGS, _ASM_LABEL(pickup_stack)
d1155 1
d1176 1
a1176 1
	br.n	_ASM_LABEL(have_pcb)
d1179 1
a1179 1
ASLOCAL(use_SR3_pcb)
d1216 1
a1216 1
	br.n	_ASM_LABEL(have_pcb)
d1223 2
a1224 2
	or.u	r1,   r0,   hi16(_ASM_LABEL(kstack))
	ld	r1,   r1,   lo16(_ASM_LABEL(kstack))
d1233 1
a1233 1
	br.n	_ASM_LABEL(have_pcb)
d1236 1
a1236 1
ASLOCAL(pickup_stack)
d1252 2
a1253 2
	or.u	r31,  r0,   hi16(_C_LABEL(curpcb))
	ld	r31,  r31,  lo16(_C_LABEL(curpcb))
d1261 1
a1261 1
ASLOCAL(have_pcb)
d1298 2
a1299 2
	or.u	TMP,  r0,   hi16(_C_LABEL(brdtyp))
	ld	TMP2, TMP,  lo16(_C_LABEL(brdtyp))
d1313 1
a1313 1
	br	_ASM_LABEL(Lbadcpupanic)
d1322 1
a1322 1
	br	_ASM_LABEL(pfsr_done)
d1331 1
a1331 1
	br	_ASM_LABEL(pfsr_done)
d1340 1
a1340 1
	br	_ASM_LABEL(pfsr_done)
d1349 1
a1349 1
	br	_ASM_LABEL(pfsr_done)
d1360 1
a1360 1
ASLOCAL(pfsr_done)
d1389 1
a1389 1
	bb0.n	DMT_VALID_BIT, TMP3, 8f
d1418 1
d1420 1
a1420 1
	bb0.n	DMT_VALID_BIT, TMP2, 8f
d1423 4
a1426 3
	bb1	DMT_LOCK_BIT,  TMP2, 1f
	bb1	DMT_WRITE_BIT, TMP2, 2f
1:
d1430 2
a1431 1
2:
d1433 5
a1437 4
	bb0	DMT_VALID_BIT, TMP2, 4f
	bb1	DMT_LOCK_BIT,  TMP2, 3f
	bb1	DMT_WRITE_BIT, TMP2, 4f
3:
d1441 2
a1442 1
4:
d1444 6
a1449 5
	bb0	DMT_VALID_BIT, TMP2, 8f
	bb1	DMT_LOCK_BIT,  TMP2, 5f
	bb1	DMT_WRITE_BIT, TMP2, 8f
	bb1	DMT_DOUBLE_BIT,TMP2, 6f
5:
d1451 4
a1454 3
	br.n	7f
	 set	TMP2, TMP2, 1<5>	/* single */
6:
d1456 4
a1459 4
	set	TMP2, TMP2, 1<6>	/* double */
7:
	clr	TMP,  TMP,  TMP2
8:
d1484 1
a1484 1
ASLOCAL(clear_FPi_ssbr_bit)
d1514 1
a1514 1
	bb0	FPIT_SIZE_BIT, TMP2, 1f
d1518 2
a1519 1
1:
d1523 1
a1523 1
ASLOCAL(clear_FPp_ssbr_bit)
d1559 3
a1561 5
2:
	set	TMP3, TMP3, 1<6>	/* size=2 - clear two bit for double */
3:
	clr	TMP,  TMP,  TMP3	/* clear bit(s) in ssbr. */
	jmp	r1
d1564 1
a1564 1
ASLOCAL(clear_dest_ssbr_bit)
d1596 1
a1596 1
	/* user space load here */
d1635 1
a1635 1
	bb1	eq,   TMP3, 2f
d1642 1
a1642 1
	bb1	ne,   TMP3, 1f		/* not equal, must be single */
d1648 1
a1648 1
	bb1	eq,   TMP3, 2f
d1650 1
a1650 1
1:	/* misaligned single */
d1652 1
a1652 1
	br.n	3f
d1655 1
a1655 1
2:	/* misaligned double */
d1658 2
a1659 2
3:
	jmp.n	r1
d1664 1
a1664 1
ASLOCAL(setup_phase_two)
d1704 2
a1705 2
	or.u	TMP,  r0,   hi16(_ASM_LABEL(fpu_enable) + 2)
	or	TMP,  TMP,  lo16(_ASM_LABEL(fpu_enable) + 2)
d1716 2
a1717 2
	or.u	TMP,  r0,   hi16(_ASM_LABEL(fpu_enable))
	or	TMP,  TMP,  lo16(_ASM_LABEL(fpu_enable))
d1722 1
d1757 1
a1757 1
ASLOCAL(fpu_enable)
d1830 6
a1840 4
	/*
	 * If interrupt exception, switch to interrupt stack if not
	 * already there. Else, switch to kernel stack.
	 */
d1844 2
a1845 2
	or.u	r31,  r0,   hi16(_ASM_LABEL(intstack_end))
	or	r31,  r31,  lo16(_ASM_LABEL(intstack_end))
d1849 2
a1850 2
	or.u	r31,  r0,   hi16(_ASM_LABEL(kstack))
	ld	r31,  r31,  lo16(_ASM_LABEL(kstack))
d1858 2
a1859 2
	or.u	r31,  r0,   hi16(_ASM_LABEL(intstack_end))
	or	r31,  r31,  lo16(_ASM_LABEL(intstack_end))
d1861 4
a1864 3

3:
	/*
d1875 1
a1875 1
	bcnd.n	eq0,  r2,   8f			/* is error */
d1877 2
a1878 2
	cmp	r3,   r2,   1			/* is an interrupt? */
	bb1.n	eq,   r3,   8f			/* skip if so */
d1882 1
a1882 1
	bb1.n	eq,   r3,   8f
d1884 1
a1884 1
	bb1.n	eq,   r3,   8f
d1891 1
d1893 1
d1899 1
a1899 1
	bb0	DMT_VALID_BIT, r3, 8f
d1908 1
a1908 1
	CALL(_C_LABEL(data_access_emulation), r15, r0)
d1916 1
a1916 1
8:
d1939 1
d1953 1
a1953 1
	br	_ASM_LABEL(return_from_exception_handler)
d1955 1
a1955 1
ASLOCAL(return_from_exception_handler)
d1976 1
a1976 1
	bb1	eq, r2, _ASM_LABEL(m88110_return_code)
d1982 1
a1982 1
	bb0	DMT_VALID_BIT, r3, _ASM_LABEL(check_ast)
d2023 1
a2024 1
	FLUSH_PIPELINE
d2038 1
a2038 1
	br	_ASM_LABEL(check_ast)
d2066 1
a2067 1
	FLUSH_PIPELINE
d2144 1
a2145 1
	FLUSH_PIPELINE
d2178 1
a2179 1
	FLUSH_PIPELINE
d2296 1
a2296 1
	CALL(_ASM_LABEL(m88110_Xfp_precise), r0, r30)
d2327 1
a2327 1
	CALL(_C_LABEL(m88110_syscall), r13, r30)
d2334 1
a2334 1
	CALL(_C_LABEL(bugsyscall), r9, r30)
d2416 1
a2416 1
 * This is totaly different than error_handler.  Shadowing might or
d2418 1
a2418 1
 * R1-R31 could tell you alot about what happened, so we'll save them.
d2429 2
a2430 2
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
d2433 2
a2434 2
	or.u	r27, r0,  hi16(_C_LABEL(intstack))
	or	r27, r27, lo16(_C_LABEL(intstack))
d2496 2
a2497 2
	or.u	r30, r0,  hi16(_ASM_LABEL(save_frame))
	or	r30, r30, lo16(_ASM_LABEL(save_frame))
d2553 1
a2553 1
	CALL(_C_LABEL(error_fatal), r30, r30)
d2561 2
a2562 2
ASLOCAL(m88110_error_loop)
	bsr	_ASM_LABEL(m88110_error_loop)
d2565 1
a2565 1
ASLOCAL(m88110_setup_phase_one)
d2587 1
a2587 1
	bb1	FLAG_ENABLING_FPU, FLAGS, _ASM_LABEL(m88110_use_SR3_pcb)
d2589 1
a2589 1
	bb0	FLAG_FROM_KERNEL, FLAGS, _ASM_LABEL(m88110_pickup_stack)
d2592 1
d2613 1
a2613 1
	br.n	_ASM_LABEL(m88110_have_pcb)
d2616 1
a2616 1
ASLOCAL(m88110_use_SR3_pcb)
d2658 1
a2658 1
	br.n	_ASM_LABEL(m88110_have_pcb)
d2667 2
a2668 2
	or.u	r1,   r0,   hi16(_ASM_LABEL(kstack))
	ld	r1,   r1,   lo16(_ASM_LABEL(kstack))
d2677 1
a2677 1
	br.n	_ASM_LABEL(m88110_have_pcb)
d2680 1
a2680 1
ASLOCAL(m88110_pickup_stack)
d2696 2
a2697 2
	or.u	r31,  r0,   hi16(_C_LABEL(curpcb))
	ld	r31,  r31,  lo16(_C_LABEL(curpcb))
d2705 1
a2705 1
ASLOCAL(m88110_have_pcb)
d2772 1
a2772 1
ASLOCAL(m88110_setup_phase_two)
d2808 3
a2810 3
	or.u	TMP,  r0,   hi16(_ASM_LABEL(m88110_fpu_enable))
	or	TMP,  TMP,  lo16(_ASM_LABEL(m88110_fpu_enable))
	stcr	TMP,  EXIP	/* jump to here m88110_fpu_enable */
d2842 1
a2842 1
	 *   Do an RTE to restart the fpu and jump to "m88110_fpu_enable"
d2847 1
a2847 1
	RTE	/* jumps to "m88110_fpu_enable" on the next line to enable the FPU. */
d2849 1
a2849 1
ASLOCAL(m88110_fpu_enable)
d2938 2
a2939 2
	or.u	r31,  r0,   hi16(_ASM_LABEL(intstack_end))
	or	r31,  r31,  lo16(_ASM_LABEL(intstack_end))
d2943 2
a2944 2
	or.u	r31,  r0,   hi16(_ASM_LABEL(kstack))
	ld	r31,  r31,  lo16(_ASM_LABEL(kstack))
d2952 2
a2953 2
	or.u	r31,  r0,   hi16(_ASM_LABEL(intstack_end))
	or	r31,  r31,  lo16(_ASM_LABEL(intstack_end))
d2955 3
a2957 1

d2969 1
a2969 1
	bcnd.n	eq0,  r2,   8f
d2972 1
a2972 1
	bb1.n	eq,   r3,   8f
d2976 1
a2976 1
	bb1.n	eq,   r3,   8f
d2979 1
a2979 1
	bb1.n	eq,   r3,   8f
d2986 1
d2988 4
a2991 3
#if 1 /* XXX test */
	br	8f
#else
d2997 1
a2997 1
	bb1	eq,   r3,   8f
d3012 1
a3012 2
#endif
8:
d3017 1
a3017 1
ASLOCAL(save_frame)
@


1.1.1.4
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.33 2003/08/21 20:45:43 miod Exp $   */
d2082 1
a2082 1
	 or	r2, r0, IPL_SOFTCLOCK
d2089 1
a2089 1
	 or	r2, r0, IPL_NONE		/* ints are enabled */
@


1.1.1.5
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.42 2003/09/20 13:57:37 miod Exp $   */
d32 9
d194 2
a195 1
 * Now is a good time to recap SR1..SR3 usage:
d235 3
a246 1
	subu	r31, r31, 32
a249 1
	addu	r31, r31, 32
d253 13
a265 1
#ifdef M88110
d317 1
a317 2
	ld	r2 , r31, GENREG_OFF(2)		; \
	ld	r3 , r31, GENREG_OFF(3)		; \
a318 1
#endif
d383 1
a383 1
#define PREP2(NAME, NUM, BIT, FLAG_PRECHECK) \
d440 1
a440 1
	/* call MY_info(ef,SR0,flags,kind)*/		  \
d447 1
a447 1
	 subu	r31, r31, 32				; \
d449 1
a449 1
	 addu	r31, r31, 32				; \
a471 7
#define DONE2(DebugNumber) \
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 2f			; \
	ldcr	r4, SR1					; \
	CALL(_C_LABEL(MY_info_done), r31, r4)		; \
2:	br	_ASM_LABEL(m88110_return_code)
a479 2
#define	DONE2(num) \
	br	_ASM_LABEL(m88110_return_code)
d496 1
a511 1
	/* No need to call m88100_trap(T_DATAFLT) as PREP will do this for us */
d541 4
a544 1
/* bounds checking exception handler */
d593 1
a593 1
	PREP("sigsys", 501, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
d598 1
a598 1
	PREP("sigtrap", 510, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d603 1
a603 1
	PREP("stepbpt", 504, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d608 1
a608 1
	PREP("userbpt", 511, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d639 1
a639 1
	PREP("unknown", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
d645 1
a645 2
 * The error exception and reset exception handler.
 *
d649 137
d789 1
d792 1
d796 3
a798 3
 * The shadow registers are not valid in this case (shadowing was off, if this
 * was an error exception, and may not be on, if this was a reset exception).
 * R1-R31 may be interesting though, so we'll save them.
a802 3
GLOBAL(error_handler)
	br.n	1f
	 or	r29, r0, 10
a803 2
	or	r29, r0, 0
1:
d805 1
a805 1
	or	r26, r0,  r31	/* save old stack */
a808 1
#ifdef DEBUG
a817 1
#endif
d842 1
a842 1
	/* save shadow registers (are OLD if error_handler, though) */
d862 1
a863 1
	st	r12, r31, REG_OFF(EF_DMA0)
d887 2
a888 2
	/* save error vector */
	st	r29, r31, REG_OFF(EF_VECTOR)
d896 1
d904 2
a905 2
	st	r30, r31, 0x0c	/* store frame pointer on the st */
	st	r30, r31, 0x08	/* store again for the debugger to recognize */
d911 1
a911 1
	CALL(_C_LABEL(error_fatal), r30, r30)
d919 2
a920 2
ASLOCAL(error_loop)
	br	_ASM_LABEL(error_loop)
d928 1
d965 1
a1082 1
	subu	r31, r31, 32
a1086 1
	addu	r31, r31, 32
d1126 1
d1152 1
d1176 1
d1233 1
d1258 1
a1291 1
#ifdef MVME187
a1296 1
#endif
a1308 1
	/* XXX WHAT ABOUT MODULES WITH SPLIT U/S CMMUS ??? */
a1346 1
#ifdef MVME187
a1353 1
#endif
d1361 16
d1402 1
a1402 1
	FLUSH_PIPELINE
d1449 1
d1655 1
d1679 1
d1686 1
d1698 12
d1720 1
d1748 1
a1748 2
	st	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
	st	r31,  TMP,  GENREG_OFF(31)	/* save previous r30, r31 */
d1760 15
a1774 30
	st	r0 ,  r31,  GENREG_OFF(0)
	st	r1 ,  r31,  GENREG_OFF(1)
	st	r2 ,  r31,  GENREG_OFF(2)
	st	r3 ,  r31,  GENREG_OFF(3)
	st	r4 ,  r31,  GENREG_OFF(4)
	st	r5 ,  r31,  GENREG_OFF(5)
	st	r6 ,  r31,  GENREG_OFF(6)
	st	r7 ,  r31,  GENREG_OFF(7)
	st	r8 ,  r31,  GENREG_OFF(8)
	st	r9 ,  r31,  GENREG_OFF(9)
	st	r10,  r31,  GENREG_OFF(10)
	st	r11,  r31,  GENREG_OFF(11)
	st	r12,  r31,  GENREG_OFF(12)
	st	r13,  r31,  GENREG_OFF(13)
	st	r14,  r31,  GENREG_OFF(14)
	st	r15,  r31,  GENREG_OFF(15)
	st	r16,  r31,  GENREG_OFF(16)
	st	r17,  r31,  GENREG_OFF(17)
	st	r18,  r31,  GENREG_OFF(18)
	st	r19,  r31,  GENREG_OFF(19)
	st	r20,  r31,  GENREG_OFF(20)
	st	r21,  r31,  GENREG_OFF(21)
	st	r22,  r31,  GENREG_OFF(22)
	st	r23,  r31,  GENREG_OFF(23)
	st	r24,  r31,  GENREG_OFF(24)
	st	r25,  r31,  GENREG_OFF(25)
	st	r26,  r31,  GENREG_OFF(26)
	st	r27,  r31,  GENREG_OFF(27)
	st	r28,  r31,  GENREG_OFF(28)
	st	r29,  r31,  GENREG_OFF(29)
d1783 1
a1783 3
	bsr.n	_C_LABEL(getipl)
	 subu	r31, r31, 32
	addu	r31, r31, 32
d1787 1
d1822 13
d1838 1
d1840 7
d1848 1
d1860 1
a1860 1
	bcnd.n	eq0,  r2,   8f			/* error exception */
a1861 5

	/*
	 * Do not process possible data exceptions here if this is an interrupt.
	 * Instead, the interrupt handler will take care of this by itself.
	 */
d1872 1
a1872 1
	/* turn interupts back on */
d1878 3
a1880 1
	/* service any outstanding data pipeline stuff */
d1889 1
d1891 3
d1896 3
d1913 2
a1914 2
	ld	r1, r31, 0		/* load func */
	ld	r2, r31, 4 		/* load proc pointer */
d1916 4
a1919 4
	 subu	r31, r31, 32		/* create stack space for function */
	addu	r31, r31, 32 + 8	/* stack space above + ksigframe */
	ld	r1,  r31, 0		/* load pc */
	ld	r2,  r31, 4		/* & proc pointer from switch frame */
d1921 1
a1921 1
	 addu	r31, r31, 8
d1935 1
a1935 9
#if defined(M88100) && defined(M88110)
#ifdef M88110
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb1	eq, r2, _ASM_LABEL(m88110_return_code)
	/* br	_ASM_LABEL(return_from_exception_handler) */
#endif
#endif
d1937 1
d1943 1
a1943 1
	 * At this point, if EF_DMT0 is not zero on MC88100, then
d1950 3
a1952 1
	 * Control is transfered here from obvious places in this file.
d1954 6
a1959 1

a1960 6
ASLOCAL(return_from_exception_handler)
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */

d1966 1
d1968 2
a1969 2
	 * If it's the interrupt exception, and interrupts were
	 * initially disabled, enable interrupts again...
d1973 18
a1990 1
	bb1.n	ne, r2, 1f	/* if not so, skip */
d1992 7
a1998 3
	/* ...unless they were already disabled */
	 ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1.n	PSR_INTERRUPT_DISABLE_BIT, r2, 1f
d2000 6
a2005 3
	 ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
d2008 2
d2011 4
d2016 4
a2027 1
#if 0
d2030 1
d2041 1
a2041 5
	bb1.n	ne, r2, 1f	/* If not, skip */

	/* ...unless they were already disabled */
	 ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1.n	PSR_INTERRUPT_DISABLE_BIT, r2, 1f
d2043 4
a2046 1
	 ldcr	r2, PSR
d2051 16
a2066 1
#endif
d2084 1
d2086 2
a2087 1
	/* is this needed? we are going to restore the ipl below XXX nivas */
d2130 1
a2130 1
	subu	r31, r31, 32
d2133 1
a2133 1
	addu	r31, r31, 32
d2141 14
a2154 28
	ld	r2 , r31, GENREG_OFF(2)
	ld	r3 , r31, GENREG_OFF(3)
	ld	r4 , r31, GENREG_OFF(4)
	ld	r5 , r31, GENREG_OFF(5)
	ld	r6 , r31, GENREG_OFF(6)
	ld	r7 , r31, GENREG_OFF(7)
	ld	r8 , r31, GENREG_OFF(8)
	ld	r9 , r31, GENREG_OFF(9)
	ld	r10, r31, GENREG_OFF(10)
	ld	r11, r31, GENREG_OFF(11)
	ld	r12, r31, GENREG_OFF(12)
	ld	r13, r31, GENREG_OFF(13)
	ld	r14, r31, GENREG_OFF(14)
	ld	r15, r31, GENREG_OFF(15)
	ld	r16, r31, GENREG_OFF(16)
	ld	r17, r31, GENREG_OFF(17)
	ld	r18, r31, GENREG_OFF(18)
	ld	r19, r31, GENREG_OFF(19)
	ld	r20, r31, GENREG_OFF(20)
	ld	r21, r31, GENREG_OFF(21)
	ld	r22, r31, GENREG_OFF(22)
	ld	r23, r31, GENREG_OFF(23)
	ld	r24, r31, GENREG_OFF(24)
	ld	r25, r31, GENREG_OFF(25)
	ld	r26, r31, GENREG_OFF(26)
	ld	r27, r31, GENREG_OFF(27)
	ld	r28, r31, GENREG_OFF(28)
	ld	r29, r31, GENREG_OFF(29)
a2164 1
#ifdef M88100
a2168 1
#endif
a2173 1
#ifdef M88100
a2176 2
#endif
#ifdef M88100
a2194 1
#endif
d2201 1
a2201 2
	ld	r30, r31, GENREG_OFF(30)
	ld	r31, r31, GENREG_OFF(31)
d2212 1
a2212 1
	PREP2("unknown", 0, DEBUG_UNKNOWN_BIT, No_Precheck)
d2214 1
a2214 1
	DONE2(DEBUG_UNKNOWN_BIT)
d2218 1
a2218 1
	PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT, No_Precheck)
d2220 1
a2220 1
	DONE2(DEBUG_INTERRUPT_BIT)
d2224 1
a2224 1
	PREP2("inst", 2, DEBUG_INSTRUCTION_BIT, No_Precheck)
d2226 1
a2226 1
	DONE2(DEBUG_INSTRUCTION_BIT)
d2232 1
a2232 1
	PREP2("data", 3, DEBUG_DATA_BIT, M88110_Data_Precheck)
d2234 1
a2234 1
	DONE2(DEBUG_DATA_BIT)
d2238 1
a2238 1
	PREP2("misalign", 4, DEBUG_MISALIGN_BIT, No_Precheck)
d2240 1
a2240 1
	DONE2(DEBUG_MISALIGN_BIT)
d2244 1
a2244 1
	PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_Precheck)
d2246 1
a2246 1
	DONE2(DEBUG_UNIMPLEMENTED_BIT)
d2250 1
a2250 1
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT, No_Precheck)
d2252 1
a2252 1
	DONE2(DEBUG_PRIVILEGE_BIT)
d2259 1
a2259 1
	PREP2("bounds", 7, DEBUG_BOUNDS_BIT, No_Precheck)
d2261 1
a2261 1
	DONE2(DEBUG_BOUNDS_BIT)
d2265 1
a2265 1
	PREP2("divide", 8, DEBUG_DIVIDE_BIT, No_Precheck)
d2267 1
a2267 1
	DONE2(DEBUG_DIVIDE_BIT)
d2271 1
a2271 1
	PREP2("overflow", 9, DEBUG_OVERFLOW_BIT, No_Precheck)
d2273 1
a2273 1
	DONE2(DEBUG_OVERFLOW_BIT)
d2277 1
a2277 1
	PREP2("FPU precise", 114, DEBUG_FPp_BIT, No_Precheck)
d2279 1
a2279 1
	DONE2(DEBUG_FPp_BIT)
d2283 1
a2283 1
	PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT, No_Precheck)
d2285 1
a2285 1
	DONE2(DEBUG_NON_MASK_BIT)
d2289 1
a2289 1
	PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT, No_Precheck)
d2291 1
a2291 1
	DONE2(DEBUG_197_READ_BIT)
d2295 1
a2295 1
	PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT, No_Precheck)
d2297 1
a2297 1
	DONE2(DEBUG_197_WRITE_BIT)
d2301 1
a2301 1
	PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT, No_Precheck)
d2303 1
a2303 1
	DONE2(DEBUG_197_INST_BIT)
d2307 1
a2307 1
	PREP2("syscall", 128, DEBUG_SYSCALL_BIT, No_Precheck)
d2310 1
a2310 1
	DONE2(DEBUG_SYSCALL_BIT)
d2314 1
a2314 1
	PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_Precheck)
d2317 1
a2317 1
	DONE2(DEBUG_BUGCALL_BIT)
d2320 1
a2320 1
	PREP2("sigsys", 501, DEBUG_SIGSYS_BIT, No_Precheck)
d2322 1
a2322 1
	DONE2(DEBUG_SIGSYS_BIT)
d2325 1
a2325 1
	PREP2("sigtrap", 510, DEBUG_SIGTRAP_BIT, No_Precheck)
d2327 1
a2327 1
	DONE2(DEBUG_SIGTRAP_BIT)
d2330 1
a2330 1
	PREP2("stepbpt", 504, DEBUG_SIGTRAP_BIT, No_Precheck)
d2332 1
a2332 1
	DONE2(DEBUG_SIGTRAP_BIT)
d2335 1
a2335 1
	PREP2("userbpt", 511, DEBUG_SIGTRAP_BIT, No_Precheck)
d2337 1
a2337 1
	DONE2(DEBUG_SIGTRAP_BIT)
d2341 1
a2341 1
	PREP2("break", 130, DEBUG_BREAK_BIT, No_Precheck)
d2343 1
a2343 1
	DONE2(DEBUG_BREAK_BIT)
d2346 1
a2346 1
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_Precheck)
d2348 1
a2348 1
	DONE2(DEBUG_TRACE_BIT)
d2351 1
a2351 1
	PREP2("kdb", 132, DEBUG_KDB_BIT, No_Precheck)
d2353 1
a2353 1
	DONE2(DEBUG_KDB_BIT)
d2356 1
a2356 1
	PREP2("break", 130, DEBUG_BREAK_BIT, No_Precheck)
d2358 1
a2358 1
	DONE2(DEBUG_BREAK_BIT)
d2361 1
a2361 1
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_Precheck)
d2363 1
a2363 1
	DONE2(DEBUG_TRACE_BIT)
d2366 1
a2366 1
	PREP2("unknown", 132, DEBUG_KDB_BIT, No_Precheck)
d2368 1
a2368 1
	DONE2(DEBUG_KDB_BIT)
d2372 1
a2372 2
 * The error exception and reset exception handler.
 *
d2376 15
d2394 1
d2398 3
a2400 3
 * The shadow registers are not valid in this case (shadowing was off, if this
 * was an error exception, and may not be on, if this was a reset exception).
 * R1-R31 may be interesting though, so we'll save them.
a2404 3
GLOBAL(m88110_error_handler)
	br.n	1f
	 or	r29, r0, 10
d2406 3
a2408 2
	or	r29, r0, 0
1:
a2413 1
#ifdef DEBUG
a2422 1
#endif
d2448 4
a2451 3
	st	r29, r31, REG_OFF(EF_VECTOR)
	cmp	r29, r29, 0	/* is it the reset exception? */
	bb1.n	ne,  r29, 1f	/* if not, skip */
d2544 1
a2544 1
	br	_ASM_LABEL(m88110_error_loop)
d2549 1
d2575 1
d2599 1
d2618 5
a2622 3
#if 1
	br	_C_LABEL(m88110_error_handler)
#else
a2659 1
#endif
d2663 1
d2688 1
d2755 1
d2779 1
d2805 1
d2833 1
a2833 1
	/* Now that EFRZ is cleared, we can clear these */
d2841 1
a2841 2
	st	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
	st	r31,  TMP,  GENREG_OFF(31)	/* save previous r30, r31 */
d2853 15
a2867 30
	st	r0 ,  r31,  GENREG_OFF(0)
	st	r1 ,  r31,  GENREG_OFF(1)
	st	r2 ,  r31,  GENREG_OFF(2)
	st	r3 ,  r31,  GENREG_OFF(3)
	st	r4 ,  r31,  GENREG_OFF(4)
	st	r5 ,  r31,  GENREG_OFF(5)
	st	r6 ,  r31,  GENREG_OFF(6)
	st	r7 ,  r31,  GENREG_OFF(7)
	st	r8 ,  r31,  GENREG_OFF(8)
	st	r9 ,  r31,  GENREG_OFF(9)
	st	r10,  r31,  GENREG_OFF(10)
	st	r11,  r31,  GENREG_OFF(11)
	st	r12,  r31,  GENREG_OFF(12)
	st	r13,  r31,  GENREG_OFF(13)
	st	r14,  r31,  GENREG_OFF(14)
	st	r15,  r31,  GENREG_OFF(15)
	st	r16,  r31,  GENREG_OFF(16)
	st	r17,  r31,  GENREG_OFF(17)
	st	r18,  r31,  GENREG_OFF(18)
	st	r19,  r31,  GENREG_OFF(19)
	st	r20,  r31,  GENREG_OFF(20)
	st	r21,  r31,  GENREG_OFF(21)
	st	r22,  r31,  GENREG_OFF(22)
	st	r23,  r31,  GENREG_OFF(23)
	st	r24,  r31,  GENREG_OFF(24)
	st	r25,  r31,  GENREG_OFF(25)
	st	r26,  r31,  GENREG_OFF(26)
	st	r27,  r31,  GENREG_OFF(27)
	st	r28,  r31,  GENREG_OFF(28)
	st	r29,  r31,  GENREG_OFF(29)
a2874 6
	/* get and save IPL */
	bsr.n	_C_LABEL(getipl)
	 subu	r31, r31, 32
	addu	r31, r31, 32
	st	r2, r31, REG_OFF(EF_MASK)

d2876 1
d2911 13
d2927 1
d2929 7
d2937 1
a2937 1
	/*
d2961 1
a2961 1
	/* turn interupts back on */
d2966 5
d2972 18
d2991 1
a2991 1
	jmp	r14		/* loaded above */
d2994 1
a2994 1
	.align 8		/* needs align 8 for ld.d/st.d */
@


1.1.1.6
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.46 2003/11/03 06:54:26 david Exp $   */
d304 1
a304 1
 * processing.  It is used in the following manner:
d307 1
a307 1
 *		PREP("foo", 11, DEBUG_FOO_BIT, SSBR_Stuff, Precheck_Stuff)
d386 1
d389 1
d477 1
a477 1
	PREP("unknown", 0, DEBUG_UNKNOWN_BIT,,)
d483 1
a483 1
	PREP("interrupt", 1, DEBUG_INTERRUPT_BIT,,)
d489 1
a489 1
	PREP("inst", 2, DEBUG_INSTRUCTION_BIT,,)
d498 1
a498 1
	PREP("data", 3, DEBUG_DATA_BIT,, Data_Precheck)
d504 1
a504 1
	PREP("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest,)
d510 1
a510 1
	PREP("unimp", 5, DEBUG_UNIMPLEMENTED_BIT,,)
d525 1
a525 1
1:	PREP("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest,)
d531 1
a531 1
	PREP("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest,)
d537 1
a537 1
	PREP("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest,)
d543 1
a543 1
	PREP("overflow", 9, DEBUG_OVERFLOW_BIT,,)
d551 1
a551 1
	PREP("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF,)
d559 1
a559 1
	PREP("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF,)
d565 1
a565 1
	PREP("syscall", 128, DEBUG_SYSCALL_BIT,,)
d572 1
a572 1
	PREP("bugsyscall", 496, DEBUG_BUGCALL_BIT,,)
d578 1
a578 1
	PREP("sigsys", 501, DEBUG_SIGSYS_BIT,,)
d583 1
a583 1
	PREP("sigtrap", 510, DEBUG_SIGTRAP_BIT,,)
d588 1
a588 1
	PREP("stepbpt", 504, DEBUG_SIGTRAP_BIT,,)
d593 1
a593 1
	PREP("userbpt", 511, DEBUG_SIGTRAP_BIT,,)
d599 1
a599 1
	PREP("break", 130, DEBUG_BREAK_BIT,,)
d604 1
a604 1
	PREP("trace", 131, DEBUG_TRACE_BIT,,)
d609 1
a609 1
	PREP("kdb", 132, DEBUG_KDB_BIT,,)
d614 1
a614 1
	PREP("break", 130, DEBUG_BREAK_BIT,,)
d619 1
a619 1
	PREP("trace", 131, DEBUG_TRACE_BIT,,)
d624 1
a624 1
	PREP("unknown", 132, DEBUG_KDB_BIT,,)
d766 1
a766 1
	/* turn interrupts back on */
d772 3
a774 4
1:
	br	1b
	/* NOTREACHED */
#endif	/* M88100 */
a778 1
#ifdef M88100
d802 1
d806 2
d809 1
a809 1
#endif /* M88100 */
d837 3
a920 1
#ifdef DEBUG
a923 1
#endif
d943 1
a943 12
#ifdef M88110
ASLOCAL(m88110_badaddr__return_nonzero)
	/*
	 * On mc88110, we possibly took an exception and we have to clear
	 * DSR before the rte instruction clears the EFRZ bit in the PSR.
	 */
	stcr	r0, DSR
	stcr	r0, DLAR
	stcr	r0, DPAR
	/* FALLTHROUGH */
#endif
ASLOCAL(badaddr__return_nonzero)
d945 1
a945 1
	/* FALLTHROUGH */
d947 1
a947 1
ASLOCAL(badaddr__return)
d963 12
d976 1
d1692 1
a1692 1
	/* turn interrupts back on */
d1768 1
a1768 1
	 * Control is transferred here from obvious places in this file.
d1999 1
a1999 1
	PREP2("unknown", 0, DEBUG_UNKNOWN_BIT,)
d2005 1
a2005 1
	PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT,)
d2011 1
a2011 1
	PREP2("inst", 2, DEBUG_INSTRUCTION_BIT,)
d2025 1
a2025 1
	PREP2("misalign", 4, DEBUG_MISALIGN_BIT,)
d2031 1
a2031 1
	PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT,)
d2037 1
a2037 1
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT,)
d2046 1
a2046 1
	PREP2("bounds", 7, DEBUG_BOUNDS_BIT,)
d2052 1
a2052 1
	PREP2("divide", 8, DEBUG_DIVIDE_BIT,)
d2058 1
a2058 1
	PREP2("overflow", 9, DEBUG_OVERFLOW_BIT,)
d2064 1
a2064 1
	PREP2("FPU precise", 114, DEBUG_FPp_BIT,)
d2070 1
a2070 1
	PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT,)
d2076 1
a2076 1
	PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT,)
d2082 1
a2082 1
	PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT,)
d2088 1
a2088 1
	PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT,)
d2094 1
a2094 1
	PREP2("syscall", 128, DEBUG_SYSCALL_BIT,)
d2101 1
a2101 1
	PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT,)
d2107 1
a2107 1
	PREP2("sigsys", 501, DEBUG_SIGSYS_BIT,)
d2112 1
a2112 1
	PREP2("sigtrap", 510, DEBUG_SIGTRAP_BIT,)
d2117 1
a2117 1
	PREP2("stepbpt", 504, DEBUG_SIGTRAP_BIT,)
d2122 1
a2122 1
	PREP2("userbpt", 511, DEBUG_SIGTRAP_BIT,)
d2128 1
a2128 1
	PREP2("break", 130, DEBUG_BREAK_BIT,)
d2133 1
a2133 1
	PREP2("trace", 131, DEBUG_TRACE_BIT,)
d2138 1
a2138 1
	PREP2("kdb", 132, DEBUG_KDB_BIT,)
d2143 1
a2143 1
	PREP2("break", 130, DEBUG_BREAK_BIT,)
d2148 1
a2148 1
	PREP2("trace", 131, DEBUG_TRACE_BIT,)
d2153 1
a2153 1
	PREP2("unknown", 132, DEBUG_KDB_BIT,)
d2312 1
a2312 1
	/* turn interrupts back on */
d2318 3
a2320 3
1:
	br	1b
	/* NOTREACHED */
d2727 1
a2727 1
	/* turn interrupts back on */
@


1.1.1.7
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.48 2004/01/19 17:21:25 miod Exp $   */
a201 1
#include <machine/param.h>
d204 2
a205 4
#ifdef MVME188
#include <machine/m8820x.h>
#endif
#include <machine/trap.h>
d348 3
@


1.1.1.8
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.50 2004/01/29 21:39:05 deraadt Exp $   */
d794 1
a794 1
	 * jumping back to the function badaddr() where we're allowed
d841 1
a841 1
 * not all currently accessible by the kernel.
d843 1
a843 1
 * If all LEN bytes starting at ADDR are accessible, zero is returned.
d847 1
a847 1
 * This is implemented by setting a special flag in SR1 before trying to access
d849 1
a849 1
 * is inaccessible. The exception handler will notice the special CPU flag
d1027 1
a1027 1
	 *   An exception occurred while enabling the FPU. Since r31
d1304 1
a1304 1
	 * Clear floatingpoint-imprecise ssbr bits.
d1549 1
a1549 1
	 *   Return address to the calling exception handler.
d2372 1
a2372 1
	 *   An exception occurred while enabling the FPU. Since r31 is the
d2474 1
a2474 1
	/* if the instruction was NOT in the delay slot, ignore ENIP */
d2476 3
a2478 1
	 st	TMP2, r31,  REG_OFF(EF_EXIP)
d2482 2
d2579 2
a2580 2
	 * Held temporarily in the exception frame:
	 *   Return address to the calling exception handler.
@


