head	1.2;
access;
symbols
	cvs-200401271800:1.1.1.7
	cvs-200401261630:1.1.1.7
	cvs-200401021645:1.1.1.6
	cvs-200312222040:1.1.1.5
	cvs-200310020700:1.1.1.4
	cvs-200309271030:1.1.1.4
	cvs-200309261655:1.1.1.3
	cvs-200309251530:1.1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	cvs-200307072125:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200307021520:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.04.06.04.29.31;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.50.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.50.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.11.18.35.48;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.09.25.16.35.58;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.09.27.11.08.18;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.22.21.00.01;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.01.02.17.49.47;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.01.26.18.42.39;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove "some dead architectures".

These are all but i386 and x86-64 (which is not in the tree yet),
because I have no machines to work with.

Re-adding support should be fairly easy, just cvs adding a partial
OpenBSD checkout and pulling in stuff like kernel signal patch, humantime,
etc. which got added to i386 as well.

You will need gcc support as well.
@
text
@/*	$OpenBSD: trap.c,v 1.39 2003/01/13 20:12:18 miod Exp $	*/
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/syscall.h>
#include <sys/systm.h>
#include <sys/ktrace.h>

#include "systrace.h"
#include <dev/systrace.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>   /* enable/disable interrupts */
#include <machine/bugio.h>		/* bugreturn() */
#include <machine/cpu.h>
#include <machine/locore.h>
#ifdef M88100
#include <machine/m88100.h>
#endif
#ifdef M88110
#include <machine/m88110.h>
#endif
#include <machine/pcb.h>		/* FIP_E, etc. */
#include <machine/psl.h>		/* FIP_E, etc. */
#include <machine/trap.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_output.h>		/* db_printf()		*/
#else 
   #define PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
           ((regs->sxip & 2) ?  regs->sxip & ~3 : \
	(regs->snip & 2 ? regs->snip & ~3 : regs->sfip & ~3))

#define inst_return(I) (((I)&0xfffffbffU) == 0xf400c001U ? TRUE : FALSE)
#define inst_call(I) ({ unsigned i = (I); \
	   ((((i) & 0xf8000000U) == 0xc8000000U || /*bsr*/ \
      ((i) & 0xfffffbe0U) == 0xf400c800U)   /*jsr*/ \
	   ? TRUE : FALSE) \
      ;})
#endif /* DDB */
#define SSBREAKPOINT (0xF000D1F8U) /* Single Step Breakpoint */

#define TRAPTRACE

#if defined(TRAPTRACE)
unsigned traptrace = 0;
#endif

#if DDB
#define DEBUG_MSG db_printf
#else
#define DEBUG_MSG printf
#endif /* DDB */

#define USERMODE(PSR)   (((struct psr*)&(PSR))->psr_mode == 0)
#define SYSTEMMODE(PSR) (((struct psr*)&(PSR))->psr_mode != 0)

/* sigh */
extern int procfs_domem(struct proc *, struct proc *, void *, struct uio *);

extern void regdump(struct trapframe *f);
void error_fatal(struct m88100_saved_state *frame);
void error_fault(struct m88100_saved_state *frame);
void error_reset(struct m88100_saved_state *frame);

char  *trap_type[] = {
	"Reset",
	"Interrupt Exception",
	"Instruction Access",
	"Data Access Exception",
	"Misaligned Access",
	"Unimplemented Opcode",
	"Privilege Violation"
	"Bounds Check Violation",
	"Illegal Integer Divide",
	"Integer Overflow",
	"Error Exception",
	"Non-Maskable Exception",
};

char  *pbus_exception_type[] = {
	"Success (No Fault)",
	"unknown 1",
	"unknown 2",
	"Bus Error",
	"Segment Fault",
	"Page Fault",
	"Supervisor Violation",
	"Write Violation",
};

int   trap_types = sizeof trap_type / sizeof trap_type[0];

static inline void
userret(struct proc *p, struct m88100_saved_state *frame, u_quad_t oticks)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	p->p_priority = p->p_usrpri;

	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, frame->sxip & ~3,
		    (int)(p->p_sticks - oticks) * psratio);
	}
	curpriority = p->p_priority;
}

void
panictrap(int type, struct m88100_saved_state *frame)
{
	static int panicing = 0;

	if (panicing++ == 0) {
		if (cputyp != CPU_88110) {
		if (type == 2) {  /* instruction exception */
			DEBUG_MSG("\nInstr access fault (%s) v = %x, frame %x\n",
				  pbus_exception_type[(frame->ipfsr >> 16) & 0x7],
				  frame->sxip & ~3, frame);
		} else if (type == 3) {	/* data access exception */
			DEBUG_MSG("\nData access fault (%s) v = %x, frame %x\n",
				  pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
				  frame->sxip & ~3, frame);
		} else
			DEBUG_MSG("\ntrap type %d, v = %x, frame %x\n", type, frame->sxip & ~3, frame);
		}
		regdump(frame);
	}
	if ((u_int)type < trap_types)
		panic(trap_type[type]);
	panic("trap");
	/*NOTREACHED*/
}

#ifdef M88100
unsigned last_trap[4] = {0,0,0,0};
unsigned last_vector = 0;

/*ARGSUSED*/
void
m88100_trap(unsigned type, struct m88100_saved_state *frame)
{
	struct proc *p;
	u_quad_t sticks = 0;
	struct vm_map *map;
	vm_offset_t va;
	vm_prot_t ftype;
	int fault_type;
	u_long fault_code;
	unsigned nss, fault_addr;
	struct vmspace *vm;
	union sigval sv;
	int result = 0;  
	int sig = 0;
	unsigned pc = PC_REGS(frame);  /* get program counter (sxip) */

	extern struct vm_map *kernel_map;
	extern unsigned guarded_access_start;
	extern unsigned guarded_access_end;
	extern unsigned guarded_access_bad;

	if (type != last_trap[3]) {
		last_trap[0] = last_trap[1];
		last_trap[1] = last_trap[2];
		last_trap[2] = last_trap[3];
		last_trap[3] = type;
	}
	uvmexp.traps++;
	if ((p = curproc) == NULL)
		p = &proc0;

	if (USERMODE(frame->epsr)) {
		sticks = p->p_sticks;
		type += T_USER;
		p->p_md.md_tf = frame;	/* for ptrace/signals */
		fault_type = 0;
		fault_code = 0;
	}
	switch (type) {
	default:
		panictrap(frame->vector, frame);
		/*NOTREACHED*/

#if defined(DDB)
	case T_KDB_BREAK:
		/*FALLTHRU*/
	case T_KDB_BREAK+T_USER:
		{
			int s = splhigh();
			db_enable_interrupt();
			ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
			db_disable_interrupt();
			splx(s);
			return;
		}
	case T_KDB_ENTRY:
		/*FALLTHRU*/
	case T_KDB_ENTRY+T_USER:
		{
			int s = splhigh();
			db_enable_interrupt();
			ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
			db_disable_interrupt();
			splx(s);
			return;
		}

#if 0
	case T_ILLFLT:
		{
			int s = splhigh();
			db_enable_interrupt();
			ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
				       "error fault", (db_regs_t*)frame);
			db_disable_interrupt();
			splx(s);
			return;
		}
#endif /* 0 */
#endif /* DDB */
	case T_INT:
	case T_INT+T_USER:
		/* This function pointer is set in machdep.c 
		   It calls m188_ext_int or sbc_ext_int depending
		   on the value of brdtyp - smurph */
		(*md.interrupt_func)(T_INT, frame);
		return;

	case T_MISALGNFLT:
		DEBUG_MSG("kernel misaligned "
			  "access exception @@ 0x%08x\n", frame->sxip);
		panictrap(frame->vector, frame);
		break;

	case T_INSTFLT:
		/* kernel mode instruction access fault.
		 * Should never, never happen for a non-paged kernel.
		 */
		DEBUG_MSG("kernel mode instruction "
			  "page fault @@ 0x%08x\n", frame->sxip);
		panictrap(frame->vector, frame);
		break;

	case T_DATAFLT:
		/* kernel mode data fault */
		/*
		 * If the faulting address is in user space, handle it in
		 * the context of the user process. Else, use kernel map.
		 */

		if (type == T_DATAFLT) {
			fault_addr = frame->dma0;
			if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				fault_code = VM_PROT_WRITE;
			} else {
				ftype = VM_PROT_READ;
				fault_code = VM_PROT_READ;
			}
		} else {
			fault_addr = frame->sxip & XIP_ADDR;
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		}

		va = trunc_page((vm_offset_t)fault_addr);

		vm = p->p_vmspace;
		map = &vm->vm_map;

		/* data fault on a kernel address... */
		if (frame->dmt0 & DMT_DAS)
			map = kernel_map;

		/* data fault on the user address */
		if (type == T_DATAFLT && (frame->dmt0 & DMT_DAS) == 0) {
			type = T_DATAFLT + T_USER;
			goto user_fault;
		}
#if 0
		printf("\nKernel Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		       ((frame->dpfsr >> 16) & 0x7),
		       pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
		       fault_addr, frame, frame->cpu);
#endif 
		/*
		 * If it is a guarded access, bus error is OK.
		 */
		if ((frame->dpfsr >> 16 & 0x7) == 0x3 &&     /* bus error */
		    (frame->sxip & ~3) >= (unsigned)&guarded_access_start &&
		    (frame->sxip & ~3) <= (unsigned)&guarded_access_end) {

			frame->snip = ((unsigned)&guarded_access_bad    ) | NIP_V;
			frame->sfip = ((unsigned)&guarded_access_bad + 4) | FIP_V;
			frame->sxip = 0;
			/* We sort of resolved the fault ourselves because 
			 * we know where it came from.  [gaurded_assess()]
			 * But we must still think about the other possible 
			 * transactions in dmt1 & dmt2.  Mark dmt0 so that 
			 * data_access_emulation skips it.  XXX smurph
			 */
			frame->dmt0 = DMT_SKIP;
			frame->dpfsr = 0;
                        data_access_emulation((unsigned *)frame);
                        /* so data_access_emulation doesn't get called again. */
			frame->dmt0 = 0;
			return;
		}
		/*
		 *	On a no fault, just return.
		 */
		if ((frame->dpfsr >> 16 & 0x7) == 0x0) {     /* no fault  */
			/*
			 * The fault was resolved. Call data_access_emulation 
			 * to drain the data unit pipe line and reset dmt0 
			 * so that trap won't get called again. 
			 * For inst faults, back up the pipe line.
			 */
				if (type == T_DATAFLT) {
					/*
					printf("calling data_access_emulation()\n");
					*/
					data_access_emulation((unsigned *)frame);
					frame->dmt0 = 0;
					frame->dpfsr = 0;
				} else {
					frame->sfip = frame->snip & ~FIP_E;
					frame->snip = frame->sxip & ~NIP_E;
				}
				return;
		}

		/*
		 *	On a segment or a page fault, call vm_fault() to resolve
		 *	the fault.
		 */
		if ((unsigned)map & 3) {
			printf("map is not word aligned! 0x%x\n", map);
#ifdef DDB
			Debugger();
#endif
		}
		if ((frame->dpfsr >> 16 & 0x7) == 0x4	     /* seg fault  */
		    || (frame->dpfsr >> 16 & 0x7) == 0x5) {  /* page fault */
			result = uvm_fault(map, va, 0, ftype);
			if (result == 0) {
			/*
			 * We could resolve the fault. Call
			 * data_access_emulation to drain the data unit pipe
			 * line and reset dmt0 so that trap won't get called
			 * again. For inst faults, back up the pipe line.
			 */
				if (type == T_DATAFLT) {
					/*
					printf("calling data_access_emulation()\n");
					*/
					data_access_emulation((unsigned *)frame);
					frame->dmt0 = 0;
					frame->dpfsr = 0;
				} else {
					frame->sfip = frame->snip & ~FIP_E;
					frame->snip = frame->sxip & ~NIP_E;
				}
				return;
			}
		}
		/*
		printf ("PBUS Fault %d (%s) va = 0x%x\n", ((frame->dpfsr >> 16) & 0x7), 
			pbus_exception_type[(frame->dpfsr >> 16) & 0x7], va);
		*/
		/*
		 * if still the fault is not resolved ...
		 */
		if (!p->p_addr->u_pcb.pcb_onfault)
			panictrap(frame->vector, frame);

		frame->snip = ((unsigned)p->p_addr->u_pcb.pcb_onfault    ) | FIP_V;
		frame->sfip = ((unsigned)p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
		frame->sxip = 0;
		/* We sort of resolved the fault ourselves because 
		 * we know where it came from.  [fuwintr() or suwintr()]
		 * But we must still think about the other possible 
		 * transactions in dmt1 & dmt2.  Mark dmt0 so that 
		 * data_access_emulation skips it. XXX smurph
		 */
		frame->dmt0 = DMT_SKIP;
		frame->dpfsr = 0;
		data_access_emulation((unsigned *)frame);
		/* so data_access_emulation doesn't get called again. */
		frame->dmt0 = 0;
		return;
	case T_INSTFLT+T_USER:
		/* User mode instruction access fault */
		/* FALLTHRU */
	case T_DATAFLT+T_USER:
		user_fault:
		if (type == T_INSTFLT+T_USER) {
			fault_addr = frame->sxip & XIP_ADDR;
		} else {
			fault_addr = frame->dma0;
		}
#if 0
		printf("User Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		       ((frame->dpfsr >> 16) & 0x7),
		       pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
		       fault_addr, frame, frame->cpu);
#endif 

		if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
			ftype = VM_PROT_READ|VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
		} else {
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		}

		va = trunc_page((vm_offset_t)fault_addr);

		vm = p->p_vmspace;
		map = &vm->vm_map;
		if ((unsigned)map & 3) {
			printf("map is not word aligned! 0x%x\n", map);
#ifdef DDB
			Debugger();
#endif
		}
		/* Call vm_fault() to resolve non-bus error faults */
		if ((frame->ipfsr >> 16 & 0x7) != 0x3 &&
		    (frame->dpfsr >> 16 & 0x7) != 0x3) {
			result = uvm_fault(map, va, 0, ftype);
			frame->ipfsr = frame->dpfsr = 0;
		}

		if ((caddr_t)va >= vm->vm_maxsaddr) {
			if (result == 0) {
				nss = btoc(USRSTACK - va);/* XXX check this */
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (result == EACCES)
				result = EFAULT;
		}

		if (result == 0) {
			if (type == T_DATAFLT+T_USER) {
			/*
			 * We could resolve the fault. Call
			 * data_access_emulation to drain the data unit
			 * pipe line and reset dmt0 so that trap won't
			 * get called again.
			 */
				data_access_emulation((unsigned *)frame);
				frame->dmt0 = 0;
				frame->dpfsr = 0;
			} else {
			/* back up SXIP, SNIP clearing the the Error bit */
				frame->sfip = frame->snip & ~FIP_E;
				frame->snip = frame->sxip & ~NIP_E;
			}
		} else {
			sig = result == EACCES ?
				SIGBUS : SIGSEGV;
			fault_type = result == EACCES ?
				BUS_ADRERR : SEGV_MAPERR;
		}
		break;
	case T_MISALGNFLT+T_USER:
		sig = SIGBUS;
		fault_type = BUS_ADRALN;
		break;
	case T_PRIVINFLT+T_USER:
	case T_ILLFLT+T_USER:
		sig = SIGILL;
		break;
	case T_BNDFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_ZERODIV+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTDIV;
		break;
	case T_OVFFLT+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTOVF;
		break;
	case T_FPEPFLT+T_USER:
	case T_FPEIFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_SIGTRAP+T_USER:
		sig = SIGTRAP;
		fault_type = TRAP_TRACE;
		break;
	case T_STEPBPT+T_USER:
		/*
		 * This trap is used by the kernel to support single-step
		 * debugging (although any user could generate this trap
		 * which should probably be handled differently). When a
		 * process is continued by a debugger with the PT_STEP
		 * function of ptrace (single step), the kernel inserts
		 * one or two breakpoints in the user process so that only
		 * one instruction (or two in the case of a delayed branch)
		 * is executed.  When this breakpoint is hit, we get the
		 * T_STEPBPT trap.
		 */
		{
			register unsigned va;
			unsigned instr;
			struct uio uio;
			struct iovec iov;

			/* compute address of break instruction */
			va = pc;

			/* read break instruction */
			copyin((caddr_t)pc, &instr, sizeof(unsigned));
#if 0
			printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
			       p->p_comm, p->p_pid, instr, pc,
			       p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
			/* check and see if we got here by accident */
			if ((p->p_md.md_ss_addr != pc && 
			     p->p_md.md_ss_taken_addr != pc) ||
			    instr != SSBREAKPOINT) {
				sig = SIGTRAP;
				fault_type = TRAP_TRACE;
				break;
			}
			/* restore original instruction and clear BP  */
			instr = p->p_md.md_ss_instr;
			va = p->p_md.md_ss_addr;
			if (va != 0) {
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int); 
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1; 
				uio.uio_offset = (off_t)va;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
				procfs_domem(p, p, NULL, &uio);
			}

			/* branch taken instruction */
			instr = p->p_md.md_ss_taken_instr;
			va = p->p_md.md_ss_taken_addr;
			if (instr != 0) {
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int); 
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1; 
				uio.uio_offset = (off_t)va;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
				procfs_domem(p, p, NULL, &uio);
			}
#if 1
			frame->sfip = frame->snip;    /* set up next FIP */
			frame->snip = pc;    /* set up next NIP */
			frame->snip |= 2;	  /* set valid bit   */
#endif
			p->p_md.md_ss_addr = 0;
			p->p_md.md_ss_instr = 0;
			p->p_md.md_ss_taken_addr = 0;
			p->p_md.md_ss_taken_instr = 0;
			sig = SIGTRAP;
			fault_type = TRAP_BRKPT;
		}
		break;

	case T_USERBPT+T_USER:
		/*
		 * This trap is meant to be used by debuggers to implement
		 * breakpoint debugging.  When we get this trap, we just
		 * return a signal which gets caught by the debugger.
		 */
		frame->sfip = frame->snip;    /* set up the next FIP */
		frame->snip = frame->sxip;    /* set up the next NIP */
		sig = SIGTRAP;
		fault_type = TRAP_BRKPT;
		break;

	case T_ASTFLT+T_USER:
		uvmexp.softs++;
		want_ast = 0;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
		break;
	}

	/*
	 * If trap from supervisor mode, just return
	 */
	if (SYSTEMMODE(frame->epsr))
		return;

	if (sig) {
		sv.sival_int = fault_addr;
		trapsignal(p, sig, fault_code, fault_type, sv);
		/*		
		 * don't want multiple faults - we are going to
		 * deliver signal.
		 */
		frame->dmt0 = 0;
		frame->dpfsr = 0;
	}

	userret(p, frame, sticks);
}
#endif /* m88100 */
unsigned v_fault = 0;

#ifdef M88110
/*ARGSUSED*/
void
m88110_trap(unsigned type, struct m88100_saved_state *frame)
{
	struct proc *p;
	u_quad_t sticks = 0;
	struct vm_map *map;
	vm_offset_t va;
	vm_prot_t ftype;
	int fault_type;
	u_long fault_code;
	unsigned nss, fault_addr;
	struct vmspace *vm;
	union sigval sv;
        int s; /* IPL */
	int result = 0;  /* Assume Success */
	int sig = 0;
	unsigned pc = PC_REGS(frame);  /* get program counter (exip) */
	unsigned user = 0, data = 0;
	pt_entry_t *pte;
	extern struct vm_map *kernel_map;
	extern unsigned guarded_access_start;
	extern unsigned guarded_access_end;
	extern pt_entry_t *pmap_pte(pmap_t, vm_offset_t);

	uvmexp.traps++;

	if ((p = curproc) == NULL)
		p = &proc0;
#if 1
	if (type != T_INT && type != T_ASTFLT && type != T_KDB_ENTRY ) {
		printf("m88110_trap: %d %s\n", type, frame->vector < trap_types ? trap_type[frame->vector] : "unknown");
	}
#endif

	if (USERMODE(frame->epsr)) {
		sticks = p->p_sticks;
		type += T_USER;
		p->p_md.md_tf = frame;	/* for ptrace/signals */
		fault_type = 0;
		fault_code = 0;
		user = 1;
	}
	
	switch (type) {
	default:
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
	case T_197_READ+T_USER:
	case T_197_READ:
		DEBUG_MSG("DMMU read miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
	case T_197_WRITE+T_USER:
	case T_197_WRITE:
		DEBUG_MSG("DMMU write miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
	case T_197_INST+T_USER:
	case T_197_INST:
		DEBUG_MSG("IMMU miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
   #if defined(DDB)
	case T_KDB_TRACE:
		s = splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_TRACE,(db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
	case T_KDB_BREAK:
		/*FALLTHRU*/
	case T_KDB_BREAK+T_USER:
		s = splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
	case T_KDB_ENTRY:
		/*FALLTHRU*/
	case T_KDB_ENTRY+T_USER:
		s = splhigh();
		db_enable_interrupt();
		ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
		db_disable_interrupt();
		if (frame->enip) {
			frame->exip = frame->enip;
		} else {
                               frame->exip += 4;
		}
		splx(s);
		return;
#if 0
	case T_ILLFLT:
		s = splhigh();
		db_enable_interrupt();
		ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
		       "error fault", (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
#endif /* 0 */
#endif /* DDB */
	case T_ILLFLT:
		DEBUG_MSG("Unimplemented opcode!\n");
		panictrap(frame->vector, frame);
		break;
	case T_NON_MASK:
	case T_NON_MASK+T_USER:
		/* This function pointer is set in machdep.c 
		   It calls m197_ext_int - smurph */
		(*md.interrupt_func)(T_NON_MASK, frame);
		return;
	case T_INT:
	case T_INT+T_USER:
		(*md.interrupt_func)(T_INT, frame);
		return;
	case T_MISALGNFLT:
		DEBUG_MSG("kernel mode misaligned "
			  "access exception @@ 0x%08x\n", frame->exip);
		panictrap(frame->vector, frame);
		/*NOTREACHED*/

	case T_INSTFLT:
		/* kernel mode instruction access fault.
		 * Should never, never happen for a non-paged kernel.
		 */
		DEBUG_MSG("kernel mode instruction "
			  "page fault @@ 0x%08x\n", frame->exip);
		panictrap(frame->vector, frame);
		/*NOTREACHED*/

	case T_DATAFLT:
		/* kernel mode data fault */
		/*
		 * If the faulting address is in user space, handle it in
		 * the context of the user process. Else, use kernel map.
		 */
		if (type == T_DATAFLT) {
			fault_addr = frame->dlar;
			if (frame->dsr & CMMU_DSR_RW) {
				ftype = VM_PROT_READ;
				fault_code = VM_PROT_READ;
			} else {
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				fault_code = VM_PROT_WRITE;
			}
			data = 1;
		} else {
			fault_addr = frame->exip & XIP_ADDR;
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		}

		va = trunc_page((vm_offset_t)fault_addr);
		vm = p->p_vmspace;
		map = &vm->vm_map;

		/* data fault on a kernel address... */
		if (type == T_DATAFLT) {
			if (frame->dsr & CMMU_DSR_SU) {
				map = kernel_map;
			}
		}

		/* data fault on the user address */
		if (type == T_DATAFLT && (frame->dsr & CMMU_DSR_SU) == 0) {
			type = T_DATAFLT + T_USER;
			goto m88110_user_fault;
		}

		/*
		 *	If it is a guarded access, bus error is OK.
		 */

		if ((frame->dsr & CMMU_DSR_BE) &&     /* bus error */
		    (frame->exip & ~3) >= (unsigned)&guarded_access_start &&
		    (frame->exip & ~3) <= (unsigned)&guarded_access_end) {
			return;
		}
		/*
		 *	On a segment or a page fault, call vm_fault() to resolve
		 *	the fault.
		 */
		if (type == T_DATAFLT) {
			if ((frame->dsr & CMMU_DSR_SI)	      /* seg fault  */
			    || (frame->dsr & CMMU_DSR_PI)) { /* page fault */
				result = uvm_fault(map, va, 0, ftype);
				if (result == 0) {
					return;
				}
			}
			if (frame->dsr & CMMU_DSR_WE) { /* write fault  */
			/* This could be a write protection fault or an 
			 * exception to set the used and modified bits
			 * in the pte.  Basicly, if we got a write error, 
			 * then we already have a pte entry that faulted 
			 * in from a previous seg fault or page fault.
			 * Get the pte and check the status of the 
			 * modified and valid bits to determine if this 
			 * indeed a real write fault.  XXX smurph
			 */
				pte = pmap_pte(map->pmap, va);
				if (pte == PT_ENTRY_NULL)
					panic("NULL pte on write fault??");
				if (!(*pte & PG_M) && !(*pte & PG_RO)) {
					/* Set modified bit and try the write again. */
					*pte |= PG_M;
					return;
				}
			}
		} else {
			if ((frame->isr & CMMU_ISR_SI)	      /* seg fault  */
			    || (frame->isr & CMMU_ISR_PI)) { /* page fault */
				result = uvm_fault(map, va, 0, ftype);
				if (result == 0) {
					return;
				}
			}
		}
		/*
		 * if still the fault is not resolved ...
		 */
		if (!p->p_addr->u_pcb.pcb_onfault)
			panictrap(frame->vector, frame);

		frame->exip = ((unsigned)p->p_addr->u_pcb.pcb_onfault);
		return;
	case T_INSTFLT+T_USER:
		/* User mode instruction access fault */
		/*FALLTHRU*/
	case T_DATAFLT+T_USER:
m88110_user_fault:
		if (type == T_INSTFLT+T_USER) {
			fault_addr = frame->exip & XIP_ADDR;
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		} else {
			fault_addr = frame->dlar;
			if (frame->dsr & CMMU_DSR_RW) {
				ftype = VM_PROT_READ;
				fault_code = VM_PROT_READ;
			} else {
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				fault_code = VM_PROT_WRITE;
			}
		}

		va = trunc_page((vm_offset_t)fault_addr);

		vm = p->p_vmspace;
		map = &vm->vm_map;

		/* Call vm_fault() to resolve non-bus error faults */
		if (type == T_DATAFLT+T_USER) {

			if (frame->dsr & (CMMU_DSR_SI |   /* seg fault  */
					  CMMU_DSR_PI)) { /* page fault */
				result = uvm_fault(map, va, 0, ftype);
				if (result != 0) {
					printf("Data Access Error @@ 0x%x\n", va);
				}
				v_fault++;
			} else if (frame->dsr & CMMU_DSR_BE) {	/* bus error */
				result = EFAULT;
			} else if ((frame->dsr & CMMU_DSR_CP)
				   || (frame->dsr & CMMU_DSR_WA)) {
				result = 0;
			} else if (frame->dsr & CMMU_DSR_WE) {	/* write fault  */
			/* This could be a write protection fault or an 
			 * exception to set the used and modified bits
			 * in the pte.  Basicly, if we got a write error, 
			 * then we already have a pte entry that faulted 
			 * in from a previous seg fault or page fault.
			 * Get the pte and check the status of the 
			 * modified and valid bits to determine if this 
			 * indeed a real write fault.  XXX smurph
			 */
				pte = pmap_pte(vm_map_pmap(map), va);
				if (pte == PT_ENTRY_NULL)
					panic("NULL pte on write fault??");
				if (!(*pte & PG_M) && !(*pte & PG_PROT)) {
					/* Set modified bit and try the write again. */
					*pte |= PG_M;
					/* invalidate ATCs to force table search */
					set_dcmd(CMMU_DCMD_INV_UATC);
					return;
				} else {
					/* This must be a real write protection fault */
					printf("Write protect???? mod = %d, wp = %d\n", !!(*pte & PG_M), !!(*pte & PG_PROT));
					result = uvm_fault(map, va, 0, ftype);
				}
			}
		} else {
			if ((frame->isr & CMMU_ISR_SI)	      /* seg fault  */
			    || (frame->isr & CMMU_ISR_PI)) { /* page fault */
				result = uvm_fault(map, va, 0, ftype);
				v_fault++;
			} else if ((frame->isr & CMMU_ISR_BE)
				   || (frame->isr & CMMU_ISR_SP)
				   || (frame->isr & CMMU_ISR_TBE)) { /* bus error */
				result = EACCES;
			}
		}

		if ((caddr_t)va >= vm->vm_maxsaddr) {
			if (result == 0) {
				nss = btoc(USRSTACK - va);/* XXX check this */
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (result == EACCES)
				result = EFAULT;
		}

		if (result != 0) {
#ifdef smurph_debug
			printf("Access failed! result = %d\n\n", result);
			frame->mode = v_fault;
			regdump(frame);
			Debugger();
			sig = result == EACCES ? SIGBUS : SIGSEGV;
			fault_type = result == EACCES ? BUS_ADRERR : SEGV_MAPERR;
#endif		
		}
		break;
	case T_MISALGNFLT+T_USER:
		sig = SIGBUS;
		fault_type = BUS_ADRALN;
		break;
	case T_PRIVINFLT+T_USER:
	case T_ILLFLT+T_USER:
		sig = SIGILL;
		break;
	case T_BNDFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_ZERODIV+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTDIV;
		break;
	case T_OVFFLT+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTOVF;
		break;
	case T_FPEPFLT+T_USER:
	case T_FPEIFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_SIGTRAP+T_USER:
		sig = SIGTRAP;
		fault_type = TRAP_TRACE;
		break;
	case T_STEPBPT+T_USER:
		/*
		 * This trap is used by the kernel to support single-step
		 * debugging (although any user could generate this trap
		 * which should probably be handled differently). When a
		 * process is continued by a debugger with the PT_STEP
		 * function of ptrace (single step), the kernel inserts
		 * one or two breakpoints in the user process so that only
		 * one instruction (or two in the case of a delayed branch)
		 * is executed.  When this breakpoint is hit, we get the
		 * T_STEPBPT trap.
		 */
#if 0
		frame->sfip = frame->snip;    /* set up next FIP */
		frame->snip = frame->sxip;    /* set up next NIP */
		break;
#endif
		{
			register unsigned va;
			unsigned instr;
			struct uio uio;
			struct iovec iov;

			/* compute address of break instruction */
			va = pc;

			/* read break instruction */
			copyin((caddr_t)pc, &instr, sizeof(unsigned));
#if 1
			printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
			       p->p_comm, p->p_pid, instr, pc,
			       p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
			/* check and see if we got here by accident */
#ifdef notyet
			if (p->p_md.md_ss_addr != pc || instr != SSBREAKPOINT) {
				sig = SIGTRAP;
				fault_type = TRAP_TRACE;
				break;
			}
#endif 
			/* restore original instruction and clear BP  */
			/*sig = suiword((caddr_t)pc, p->p_md.md_ss_instr);*/
			instr = p->p_md.md_ss_instr;
			if (instr == 0) {
				printf("Warning: can't restore instruction at %x: %x\n",
				       p->p_md.md_ss_addr, p->p_md.md_ss_instr);
			} else {
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int); 
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1; 
				uio.uio_offset = (off_t)pc;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
			}

			p->p_md.md_ss_addr = 0;
			sig = SIGTRAP;
			fault_type = TRAP_BRKPT;
			break;
		}
	case T_USERBPT+T_USER:
		/*
		 * This trap is meant to be used by debuggers to implement
		 * breakpoint debugging.  When we get this trap, we just
		 * return a signal which gets caught by the debugger.
		 */
		sig = SIGTRAP;
		fault_type = TRAP_BRKPT;
		break;

	case T_ASTFLT+T_USER:
		uvmexp.softs++;
		want_ast = 0;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
		break;
	}
	/*
	 * If trap from supervisor mode, just return
	 */
	if (SYSTEMMODE(frame->epsr))
		return;

	if (sig) {
		sv.sival_int = fault_addr;
		trapsignal(p, sig, fault_code, fault_type, sv);
		/*		
		 * don't want multiple faults - we are going to
		 * deliver signal.
		 */
		frame->dsr = 0;
		frame->isr = 0;
	}
	userret(p, frame, sticks);
}

#endif /* MVME197 */

void
test_trap(struct m88100_saved_state *frame)
{
	DEBUG_MSG("\n[test_trap (Good News[tm]) frame 0x%08x]\n", frame);
	regdump((struct trapframe*)frame);
	bugreturn();
}

void
error_fatal(struct m88100_saved_state *frame)
{
	switch (frame->vector) {
	case 0:
		DEBUG_MSG("\n[RESET EXCEPTION (Really Bad News[tm]) frame 0x%08x]\n", frame);
		DEBUG_MSG("This is usually caused by a branch to a NULL function pointer.\n");
		DEBUG_MSG("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
		break;
	default:
		DEBUG_MSG("\n[ERROR EXCEPTION (Bad News[tm]) frame 0x%08x]\n", frame);
		DEBUG_MSG("This is usually an exception within an exception.  The trap\n");
		DEBUG_MSG("frame shadow registers you are about to see are invalid.\n");
		DEBUG_MSG("(read totaly useless)  But R1 to R31 might be interesting.\n");
		break;
	}
	regdump((struct trapframe*)frame);
#if DDB 
	Debugger();
	DEBUG_MSG("You really can't restart after exception %d!\n", frame->vector);
	Debugger();
#endif /* DDB */
	bugreturn();  /* This gets us to Bug instead of a loop forever */

}

void
error_fault(struct m88100_saved_state *frame)
{
	DEBUG_MSG("\n[ERROR EXCEPTION (Bad News[tm]) frame 0x%08x]\n", frame);
	DEBUG_MSG("This is usually an exception within an exception.  The trap\n");
	DEBUG_MSG("frame shadow registers you are about to see are invalid.\n");
	DEBUG_MSG("(read totaly useless)  But R1 to R31 might be interesting.\n");
	regdump((struct trapframe*)frame);
#ifdef M88100
	DEBUG_MSG("trap trace %d -> %d -> %d -> %d  ", last_trap[0], last_trap[1], last_trap[2], last_trap[3]);
	DEBUG_MSG("last exception vector = %d\n", last_vector);
#endif 
#if DDB 
	Debugger();
	DEBUG_MSG("You really can't restart after an error exception!\n");
	Debugger();
#endif /* DDB */
	bugreturn();  /* This gets us to Bug instead of a loop forever */
}

void
error_reset(struct m88100_saved_state *frame) 
{
	DEBUG_MSG("\n[RESET EXCEPTION (Really Bad News[tm]) frame 0x%08x]\n", frame);
	DEBUG_MSG("This is usually caused by a branch to a NULL function pointer.\n");
	DEBUG_MSG("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
#if DDB 
	Debugger();
	DEBUG_MSG("It's useless to restart after a reset exception! You might as well reboot.\n");
	Debugger();
#endif /* DDB */
	bugreturn();  /* This gets us to Bug instead of a loop forever */
}

#ifdef M88100
void
m88100_syscall(register_t code, struct m88100_saved_state *tf)
{
	register int i, nsys, *ap, nap;
	register struct sysent *callp;
	register struct proc *p;
	int error;
	struct args {
		int i[8];
	} args;
	int rval[2];
	u_quad_t sticks;
	extern struct pcb *curpcb;

	uvmexp.syscalls++;

	p = curproc;

	callp = p->p_emul->e_sysent;
	nsys  = p->p_emul->e_nsysent;

#ifdef DIAGNOSTIC
	if (USERMODE(tf->epsr) == 0)
		panic("syscall");
	if (curpcb != &p->p_addr->u_pcb)
		panic("syscall curpcb/ppcb");
	if (tf != (struct trapframe *)&curpcb->user_state)
		panic("syscall trapframe");
#endif

	sticks = p->p_sticks;
	p->p_md.md_tf = tf;

	/*
	 * For 88k, all the arguments are passed in the registers (r2-r12)
	 * For syscall (and __syscall), r2 (and r3) has the actual code.
	 * __syscall  takes a quad syscall number, so that other
	 * arguments are at their natural alignments.
	 */
	ap = &tf->r[2];
	nap = 6;

	switch (code) {
	case SYS_syscall:
		code = *ap++;
		nap--;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		code = ap[_QUAD_LOWWORD];
		ap += 2;
		nap -= 2;
		break;
	}

	/* Callp currently points to syscall, which returns ENOSYS. */
	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;
	else {
		callp += code;
		i = callp->sy_argsize / sizeof(register_t);
		if (i > 8)
			panic("syscall nargs");
		/*
		 * just copy them; syscall stub made sure all the
		 * args are moved from user stack to registers.
		 */
		bcopy((caddr_t)ap, (caddr_t)args.i, i * sizeof(register_t));
	}
#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args.i);
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, callp->sy_argsize, args.i);
#endif
	rval[0] = 0;
	rval[1] = 0;
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, &args, rval);
	else
#endif
		error = (*callp->sy_call)(p, &args, rval);
	/*
	 * system call will look like:
	 *	 ld r10, r31, 32; r10,r11,r12 might be garbage.
	 *	 ld r11, r31, 36
	 *	 ld r12, r31, 40
	 *	 or r13, r0, <code>
	 *       tb0 0, r0, <128> <- sxip
	 *	 br err 	  <- snip
	 *       jmp r1 	  <- sfip
	 *  err: or.u r3, r0, hi16(errno)
	 *	 st r2, r3, lo16(errno)
	 *	 subu r2, r0, 1 
	 *	 jmp r1
	 *
	 * So, when we take syscall trap, sxip/snip/sfip will be as
	 * shown above.
	 * Given this,
	 * 1. If the system call returned 0, need to skip nip.
	 *	nip = fip, fip += 4
	 *    (doesn't matter what fip + 4 will be but we will never
	 *    execute this since jmp r1 at nip will change the execution flow.)
	 * 2. If the system call returned an errno > 0, plug the value
	 *    in r2, and leave nip and fip unchanged. This will have us
	 *    executing "br err" on return to user space.
	 * 3. If the system call code returned ERESTART,
	 *    we need to rexecute the trap instruction. Back up the pipe
	 *    line.
	 *     fip = nip, nip = xip
	 * 4. If the system call returned EJUSTRETURN, don't need to adjust
	 *    any pointers.
	 */

	if (error == 0) {
		/*
		 * If fork succeeded and we are the child, our stack
		 * has moved and the pointer tf is no longer valid,
		 * and p is wrong.  Compute the new trapframe pointer.
		 * (The trap frame invariably resides at the
		 * tippity-top of the u. area.)
		 */
		p = curproc;
		tf = USER_REGS(p);
		tf->r[2] = rval[0];
		tf->r[3] = rval[1];
		tf->epsr &= ~PSR_C;
		tf->snip = tf->sfip & ~NIP_E;
		tf->sfip = tf->snip + 4;
	} else if (error > 0) {
		/* error != ERESTART && error != EJUSTRETURN*/
		tf->r[2] = error;
		tf->epsr |= PSR_C;   /* fail */
		tf->snip = tf->snip & ~NIP_E;
		tf->sfip = tf->sfip & ~FIP_E;
	} else if (error == ERESTART) {
		/*
		 * If (error == ERESTART), back up the pipe line. This
		 * will end up reexecuting the trap.
		 */
		tf->epsr &= ~PSR_C;
		tf->sfip = tf->snip & ~FIP_E;
		tf->snip = tf->sxip & ~NIP_E;
	} else {
		/* if (error == EJUSTRETURN), leave the ip's alone */
		tf->epsr &= ~PSR_C;
	}
#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif
	userret(p, tf, sticks);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
#endif
}
#endif /* M88100 */

#ifdef M88110

/* Instruction pointers opperate differently on mc88110 */
void
m88110_syscall(register_t code, struct m88100_saved_state *tf)
{
	register int i, nsys, *ap, nap;
	register struct sysent *callp;
	register struct proc *p;
	int error;
	struct args {
		int i[8];
	} args;
	int rval[2];
	u_quad_t sticks;
	extern struct pcb *curpcb;

	uvmexp.syscalls++;

	p = curproc;

	callp = p->p_emul->e_sysent;
	nsys  = p->p_emul->e_nsysent;

#ifdef DIAGNOSTIC
	if (USERMODE(tf->epsr) == 0)
		panic("syscall");
	if (curpcb != &p->p_addr->u_pcb)
		panic("syscall curpcb/ppcb");
	if (tf != (struct trapframe *)&curpcb->user_state)
		panic("syscall trapframe");
#endif

	sticks = p->p_sticks;
	p->p_md.md_tf = tf;

	/*
	 * For 88k, all the arguments are passed in the registers (r2-r12)
	 * For syscall (and __syscall), r2 (and r3) has the actual code.
	 * __syscall  takes a quad syscall number, so that other
	 * arguments are at their natural alignments.
	 */
	ap = &tf->r[2];
	nap = 6;

	switch (code) {
	case SYS_syscall:
		code = *ap++;
		nap--;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		code = ap[_QUAD_LOWWORD];
		ap += 2;
		nap -= 2;
		break;
	}

	/* Callp currently points to syscall, which returns ENOSYS. */
	printf("syscall code is %d\n", code);
	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;
	else {
		callp += code;
		i = callp->sy_argsize / sizeof(register_t);
		if (i > 8)
			panic("syscall nargs");
		/*
		 * just copy them; syscall stub made sure all the
		 * args are moved from user stack to registers.
		 */
		bcopy((caddr_t)ap, (caddr_t)args.i, i * sizeof(register_t));
	}
#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args.i);
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, callp->sy_argsize, args.i);
#endif
	rval[0] = 0;
	rval[1] = 0;
	error = (*callp->sy_call)(p, &args, rval);
	/*
	 * system call will look like:
	 *	 ld r10, r31, 32; r10,r11,r12 might be garbage.
	 *	 ld r11, r31, 36
	 *	 ld r12, r31, 40
	 *	 or r13, r0, <code>
	 *       tb0 0, r0, <128> <- exip
	 *	 br err 	  <- enip
	 *       jmp r1
	 *  err: or.u r3, r0, hi16(errno)
	 *	 st r2, r3, lo16(errno)
	 *	 subu r2, r0, 1 
	 *	 jmp r1
	 *
	 * So, when we take syscall trap, exip/enip will be as
	 * shown above.
	 * Given this,
	 * 1. If the system call returned 0, need to jmp r1.
	 *	   exip += 8
	 * 2. If the system call returned an errno > 0, increment 
	 *    exip += 4 and plug the value in r2. This will have us
	 *    executing "br err" on return to user space.
	 * 3. If the system call code returned ERESTART,
	 *    we need to rexecute the trap instruction. leave exip as is.
	 * 4. If the system call returned EJUSTRETURN, just return.
	 *    exip += 4
	 */

	switch (error) {
	case 0:
		printf("syscall success!\n");
		/*
		 * If fork succeeded and we are the child, our stack
		 * has moved and the pointer tf is no longer valid,
		 * and p is wrong.  Compute the new trapframe pointer.
		 * (The trap frame invariably resides at the
		 * tippity-top of the u. area.)
		 */
		p = curproc;
		tf = USER_REGS(p);
		tf->r[2] = rval[0];
		tf->r[3] = rval[1];
		tf->epsr &= ~PSR_C;
		tf->exip += 8; 
		tf->exip &= ~3;
		break;
	case ERESTART:
		printf("syscall restart!\n");
		/*
		 * Reexecute the trap.
		 * exip is already at the trap instruction, so
		 * there is nothing to do.
		 */
		tf->epsr &= ~PSR_C;
		break;
	case EJUSTRETURN:
		printf("syscall just return!\n");
		/* if (error == EJUSTRETURN) */
		tf->epsr &= ~PSR_C;
		tf->exip += 4;
		tf->exip &= ~3;
		break;
	default:
		printf("syscall error %d!\n", error);
		/* error != ERESTART && error != EJUSTRETURN*/
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		tf->r[2] = error;
		tf->epsr |= PSR_C;   /* fail */
		tf->exip += 4;
		tf->exip &= ~3;
		break;
	}

#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif
	userret(p, tf, sticks);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
#endif
}
#endif	/* MVME197 */

/*
 * Set up return-value registers as fork() libc stub expects,
 * and do normal return-to-user-mode stuff.
 */
void
child_return(arg)
	void *arg;
{
	struct proc *p = arg;
	struct trapframe *tf;

	tf = USER_REGS(p);
	tf->r[2] = 0;
	tf->r[3] = 0;
	tf->epsr &= ~PSR_C;
	if (cputyp != CPU_88110) {
		tf->snip = tf->sfip & ~3;
		tf->sfip = tf->snip + 4;
	} else {
		tf->exip += 8;
		tf->exip &= ~3;
	}

	userret(p, tf, p->p_sticks);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, SYS_fork, 0, 0);
#endif
}

/************************************\
* User Single Step Debugging Support *
\************************************/

unsigned 
ss_get_value(struct proc *p, unsigned addr, int size)
{
	struct uio uio;
	struct iovec iov;
	unsigned value;

	iov.iov_base = (caddr_t)&value;
	iov.iov_len = size; 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = size;
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	procfs_domem(curproc, p, NULL, &uio);
	return value;
}

int 
ss_put_value(struct proc *p, unsigned addr, unsigned value, int size)
{
	struct uio uio;
	struct iovec iov;
	int i;

	iov.iov_base = (caddr_t)&value;
	iov.iov_len = size; 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = size;
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = curproc;
	i = procfs_domem(curproc, p, NULL, &uio);
	return i;
}

/*
 * ss_branch_taken(instruction, program counter, func, func_data)
 *
 * instruction will be a control flow instruction location at address pc.
 * Branch taken is supposed to return the address to which the instruction
 * would jump if the branch is taken. Func can be used to get the current
 * register values when invoked with a register number and func_data as
 * arguments.
 *
 * If the instruction is not a control flow instruction, panic.
 */
unsigned
ss_branch_taken(
	       unsigned inst,
	       unsigned pc,
	       unsigned (*func)(unsigned int, struct trapframe *),
	       struct trapframe *func_data)  /* 'opaque' */
{

	/* check if br/bsr */
	if ((inst & 0xf0000000U) == 0xc0000000U) {
		/* signed 26 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x03ffffffU)<<2;
		/* check if sign extension is needed */
		if (inst & 0x08000000U)
			inst |= 0xf0000000U;
		return pc + inst;
	}

	/* check if bb0/bb1/bcnd case */
	switch ((inst & 0xf8000000U)) {
	case 0xd0000000U: /* bb0 */
	case 0xd8000000U: /* bb1 */
	case 0xe8000000U: /* bcnd */
		/* signed 16 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x0000ffffU)<<2;
		/* check if sign extension is needed */
		if (inst & 0x00020000U)
			inst |= 0xfffc0000U;
		return pc + inst;
	}

	/* check jmp/jsr case */
	/* check bits 5-31, skipping 10 & 11 */
	if ((inst & 0xfffff3e0U) == 0xf400c000U)
		return (*func)(inst & 0x1f, func_data);	 /* the register value */

	return 0; /* keeps compiler happy */
}

/*
 * ss_getreg_val - handed a register number and an exception frame.
 *              Returns the value of the register in the specified
 *              frame. Only makes sense for general registers.
 */
unsigned
ss_getreg_val(unsigned regno, struct trapframe *tf)
{
	if (regno == 0)
		return 0;
	else if (regno < 31)
		return tf->r[regno];
	else {
		panic("bad register number to ss_getreg_val.");
		return 0;/*to make compiler happy */
	}
}

int
ss_inst_branch(unsigned ins)
{
	/* check high five bits */

	switch (ins >> (32-5)) {
	case 0x18: /* br */
	case 0x1a: /* bb0 */
	case 0x1b: /* bb1 */
	case 0x1d: /* bcnd */
		return TRUE;
		break;
	case 0x1e: /* could be jmp */
		if ((ins & 0xfffffbe0U) == 0xf400c000U)
			return TRUE;
	}

	return FALSE;
}

/* ss_inst_delayed - this instruction is followed by a delay slot. Could be
   br.n, bsr.n bb0.n, bb1.n, bcnd.n or jmp.n or jsr.n */

int
ss_inst_delayed(unsigned ins)
{
	/* check the br, bsr, bb0, bb1, bcnd cases */
	switch ((ins & 0xfc000000U)>>(32-6)) {
	case 0x31: /* br */
	case 0x33: /* bsr */
	case 0x35: /* bb0 */
	case 0x37: /* bb1 */
	case 0x3b: /* bcnd */
		return TRUE;
	}

	/* check the jmp, jsr cases */
	/* mask out bits 0-4, bit 11 */
	return ((ins & 0xfffff7e0U) == 0xf400c400U) ? TRUE : FALSE;
}

unsigned
ss_next_instr_address(struct proc *p, unsigned pc, unsigned delay_slot)
{
	if (delay_slot == 0)
		return pc + 4;
	else {
		if (ss_inst_delayed(ss_get_value(p, pc, sizeof(int))))
			return pc + 4;
		else
			return pc;
	}
}

int
cpu_singlestep(p)
register struct proc *p;
{
	struct trapframe *sstf = USER_REGS(p); /*p->p_md.md_tf;*/
	unsigned pc, brpc;
	int i;
	int bpinstr = SSBREAKPOINT;
	unsigned curinstr;

	pc = PC_REGS(sstf);
	/*
	 * User was stopped at pc, e.g. the instruction
	 * at pc was not executed.
	 * Fetch what's at the current location.
	 */
	curinstr = ss_get_value(p, pc, sizeof(int));

	/* compute next address after current location */
	if (curinstr != 0) {
		if (ss_inst_branch(curinstr) || inst_call(curinstr) || inst_return(curinstr)) {
			brpc = ss_branch_taken(curinstr, pc, ss_getreg_val, sstf);
			if (brpc != pc) {   /* self-branches are hopeless */
#if 0
				printf("SS %s (%d): next taken breakpoint set at %x\n", 
				       p->p_comm, p->p_pid, brpc);
#endif 
				p->p_md.md_ss_taken_addr = brpc;
				p->p_md.md_ss_taken_instr = ss_get_value(p, brpc, sizeof(int));
				/* Store breakpoint instruction at the "next" location now. */
				i = ss_put_value(p, brpc, bpinstr, sizeof(int));
				if (i < 0) return (EFAULT);
			}
		}
		pc = ss_next_instr_address(p, pc, 0);
#if 0
		printf("SS %s (%d): next breakpoint set at %x\n", 
		       p->p_comm, p->p_pid, pc);
#endif 
	} else {
		pc = PC_REGS(sstf) + 4;
#if 0
		printf("SS %s (%d): next breakpoint set at %x\n", 
		       p->p_comm, p->p_pid, pc);
#endif 
	}

	if (p->p_md.md_ss_addr) {
		printf("SS %s (%d): breakpoint already set at %x (va %x)\n",
		       p->p_comm, p->p_pid, p->p_md.md_ss_addr, pc); /* XXX */
		return (EFAULT);
	}

	p->p_md.md_ss_addr = pc;

	/* Fetch what's at the "next" location. */
	p->p_md.md_ss_instr = ss_get_value(p, pc, sizeof(int));

	/* Store breakpoint instruction at the "next" location now. */
	i = ss_put_value(p, pc, bpinstr, sizeof(int));

	if (i < 0) return (EFAULT);
	return (0);
}


#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	oldipl = getipl();

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		setipl(wantipl);
	}
}
#endif
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2003/08/09 21:19:59 miod Exp $	*/
a697 1
#ifdef DDB
a698 1
#endif
d714 1
a714 5
	if (type != T_INT && type != T_ASTFLT
#ifdef DDB
	    && type != T_KDB_ENTRY
#endif
	   ) {
d747 1
a747 1
#ifdef DDB
a1222 1
#ifdef DIAGNOSTIC
a1223 1
#endif
a1386 1
#ifdef DIAGNOSTIC
a1387 1
#endif
@


1.1.1.3
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2003/09/17 22:22:32 miod Exp $	*/
a66 1
#include <machine/m8820x.h>
d75 1
a76 1
#ifdef DDB
d78 11
d112 2
d180 2
a181 2
		if (type == 2 && cputyp == CPU_88100) {
			/* instruction exception */
d185 1
a185 2
		} else if (type == 3 && cputyp == CPU_88100) {
			/* data access exception */
d191 1
d204 1
d213 1
a213 1
	int fault_type, pbus_type;
d218 1
a218 1
	int result;
d251 2
d262 2
a285 4
	case T_ILLFLT:
		DEBUG_MSG("Unimplemented opcode!\n");
		panictrap(frame->vector, frame);
		break;
d311 4
d316 9
a324 10
		/* data fault on the user address? */
		if ((frame->dmt0 & DMT_DAS) == 0) {
			type = T_DATAFLT + T_USER;
			goto user_fault;
		}

		fault_addr = frame->dma0;
		if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
			ftype = VM_PROT_READ|VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
d326 1
a331 3
		if (va == 0) {
			panic("trap: bad kernel access at %x", fault_addr);
		}
d334 5
a338 1
		map = kernel_map;
d340 9
a348 4
		pbus_type = (frame->dpfsr >> 16) & 0x07;
#ifdef DEBUG
		printf("Kernel Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		       pbus_type, pbus_exception_type[pbus_type],
d351 27
a377 30

		switch (pbus_type) {
		case CMMU_PFSR_BERROR:
			/*
		 	 * If it is a guarded access, bus error is OK.
		 	 */
			if ((frame->sxip & ~3) >=
			      (unsigned)&guarded_access_start &&
			    (frame->sxip & ~3) <=
			      (unsigned)&guarded_access_end) {
				frame->snip =
				  ((unsigned)&guarded_access_bad    ) | NIP_V;
				frame->sfip =
				  ((unsigned)&guarded_access_bad + 4) | FIP_V;
				frame->sxip = 0;
				/* We sort of resolved the fault ourselves
				 * because we know where it came from
				 * [guarded_access()]. But we must still think
				 * about the other possible transactions in
				 * dmt1 & dmt2.  Mark dmt0 so that
				 * data_access_emulation skips it.  XXX smurph
				 */
				frame->dmt0 = DMT_SKIP;
				data_access_emulation((unsigned *)frame);
				frame->dpfsr = 0;
				frame->dmt0 = 0;
				return;
			}
			break;
		case CMMU_PFSR_SUCCESS:
d384 26
a409 6
			data_access_emulation((unsigned *)frame);
			frame->dpfsr = 0;
			frame->dmt0 = 0;
			return;
		case CMMU_PFSR_SFAULT:
		case CMMU_PFSR_PFAULT:
d412 17
a428 10
				/*
				 * We could resolve the fault. Call
				 * data_access_emulation to drain the data
				 * unit pipe line and reset dmt0 so that trap
				 * won't get called again. For inst faults,
				 * back up the pipe line.
				 */
				data_access_emulation((unsigned *)frame);
				frame->dpfsr = 0;
				frame->dmt0 = 0;
a430 1
			break;
d432 4
a435 4
#ifdef DEBUG
		printf ("PBUS Fault %d (%s) va = 0x%x\n", pbus_type,
			pbus_exception_type[pbus_type], va);
#endif
d439 1
a439 1
		if (p->p_addr->u_pcb.pcb_onfault == 0)
d442 2
a443 4
		frame->snip =
		    ((unsigned)p->p_addr->u_pcb.pcb_onfault    ) | FIP_V;
		frame->sfip =
		    ((unsigned)p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
d446 1
a446 1
		 * we know where it came from [copyxxx()]
d452 1
d454 1
a454 1
		frame->dpfsr = 0;
d459 1
a459 1
		/* FALLTHROUGH */
d461 1
a461 1
user_fault:
a463 1
			pbus_type = (frame->ipfsr >> 16) & 0x07;
a465 1
			pbus_type = (frame->dpfsr >> 16) & 0x07;
d467 1
a467 1
#ifdef DEBUG
d469 2
a470 1
		       pbus_type, pbus_exception_type[pbus_type],
d486 9
a494 10

		/* Call uvm_fault() to resolve non-bus error faults */
		switch (pbus_type) {
		case CMMU_PFSR_SUCCESS:
			result = 0;
			break;
		case CMMU_PFSR_BERROR:
			result = EACCES;
			break;
		default:
d496 1
a496 1
			break;
d510 6
a515 6
				/*
			 	 * We could resolve the fault. Call
			 	 * data_access_emulation to drain the data unit
			 	 * pipe line and reset dmt0 so that trap won't
			 	 * get called again.
			 	 */
d517 1
a518 1
				frame->dmt0 = 0;
d520 1
a520 4
				/*
				 * back up SXIP, SNIP,
				 * clearing the the Error bit
				 */
a522 1
				frame->ipfsr = 0;
d525 2
a526 1
			sig = result == EACCES ? SIGBUS : SIGSEGV;
a536 8
#ifndef DDB
	case T_KDB_BREAK:
	case T_KDB_ENTRY:
#endif
	case T_KDB_BREAK+T_USER:
	case T_KDB_ENTRY+T_USER:
	case T_KDB_TRACE:
	case T_KDB_TRACE+T_USER:
a553 3
	case T_SIGSYS+T_USER:
		sig = SIGSYS;
		break;
d571 1
a571 1
			unsigned va;
d576 3
d664 1
a664 1
	if (type < T_USER)
d675 1
a675 1
		frame->ipfsr = frame->dpfsr = 0;
d681 1
d684 1
d701 1
a701 1
	int result;
d704 1
a705 1

d712 1
d715 1
a715 2

#ifdef DEBUG
d731 1
d733 1
d762 2
d771 2
d780 1
a780 1
			frame->exip += 4;
d826 16
a841 9

		/* data fault on the user address? */
		if ((frame->dsr & CMMU_DSR_SU) == 0) {
			type = T_DATAFLT + T_USER;
			goto m88110_user_fault;
		}

		fault_addr = frame->dlar;
		if (frame->dsr & CMMU_DSR_RW) {
a843 3
		} else {
			ftype = VM_PROT_READ|VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
a846 4
		if (va == 0) {
			panic("trap: bad kernel access at %x", fault_addr);
		}

d848 1
a848 1
		map = kernel_map;
d850 4
a853 9
		if (frame->dsr & CMMU_DSR_BE) {
			/*
			 * If it is a guarded access, bus error is OK.
			 */
			if ((frame->exip & ~3) >=
			      (unsigned)&guarded_access_start &&
			    (frame->exip & ~3) <=
			      (unsigned)&guarded_access_end) {
				return;
d856 15
a870 8
		if (frame->dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
			/*
			 * On a segment or a page fault, call uvm_fault() to
			 * resolve the fault.
			 */
			result = uvm_fault(map, va, 0, ftype);
			if (result == 0)
				return;
d872 14
a885 3
		if (frame->dsr & CMMU_DSR_WE) {	/* write fault  */
			/*
			 * This could be a write protection fault or an 
d887 1
a887 1
			 * in the pte. Basically, if we got a write error, 
d894 12
a905 14
			pte = pmap_pte(map->pmap, va);
			if (pte == PT_ENTRY_NULL)
				panic("NULL pte on write fault??");
			if (!(*pte & PG_M) && !(*pte & PG_RO)) {
				/* Set modified bit and try the write again. */
				*pte |= PG_M;
				return;
#if 1	/* shouldn't happen */
			} else {
				/* must be a real wp fault */
#ifdef DEBUG
				printf("Kernel Write protect???? pte %x\n",
				    *pte);
#endif
d907 1
a907 1
				if (result == 0)
d909 1
a909 1
#endif
a911 1

d922 1
a922 1
		/* FALLTHROUGH */
d945 1
a945 4
		/*
		 * Call uvm_fault() to resolve non-bus error faults
		 * whenever possible.
		 */
d947 3
a949 7
			/* data faults */
			if (frame->dsr & CMMU_DSR_BE) {
				/* bus error */
				result = EACCES;
			} else
			if (frame->dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
				/* segment or page fault */
d951 1
a951 2
#ifdef DEBUG
				if (result != 0)
d953 6
a958 4
#endif
			} else
			if (frame->dsr & (CMMU_DSR_CP | CMMU_DSR_WA)) {
				/* copyback or write allocate error */
d960 10
a969 13
			} else
			if (frame->dsr & CMMU_DSR_WE) {
				/* write fault  */
				/* This could be a write protection fault or an 
				 * exception to set the used and modified bits
				 * in the pte. Basically, if we got a write
				 * error, then we already have a pte entry that
				 * faulted in from a previous seg fault or page
				 * fault.
				 * Get the pte and check the status of the 
				 * modified and valid bits to determine if this 
				 * indeed a real write fault.  XXX smurph
				 */
d973 2
a974 5
				if (!(*pte & PG_M) && !(*pte & PG_RO)) {
					/*
					 * Set modified bit and try the
					 * write again.
					 */
d976 1
a976 4
					/*
					 * invalidate ATCs to force
					 * table search
					 */
d980 2
a981 5
					/* must be a real wp fault */
#ifdef DEBUG
					printf("Write protect???? pte %x\n",
					    *pte);
#endif
a983 6
			} else {
#ifdef DEBUG
				printf("unexpected data fault dsr %x\n",
				    frame->dsr);
#endif
				result = uvm_fault(map, va, 0, ftype);
d986 2
a987 3
			/* instruction faults */
			if (frame->isr & (CMMU_ISR_SI | CMMU_ISR_PI)) {
				/* segment or page fault */
d989 4
a992 4
			} else
			if (frame->isr &
			    (CMMU_ISR_BE | CMMU_ISR_SP | CMMU_ISR_TBE)) {
				/* bus error, supervisor protection */
a993 6
			} else {
#ifdef DEBUG
				printf("unexpected instr fault dsr %x\n",
				    frame->isr);
#endif
				result = uvm_fault(map, va, 0, ftype);
d1007 5
d1013 2
a1014 2
			fault_type = result == EACCES ?
			    BUS_ADRERR : SEGV_MAPERR;
a1022 8
#ifndef DDB
	case T_KDB_BREAK:
	case T_KDB_ENTRY:
	case T_KDB_TRACE:
#endif
	case T_KDB_BREAK+T_USER:
	case T_KDB_ENTRY+T_USER:
	case T_KDB_TRACE+T_USER:
a1039 3
	case T_SIGSYS+T_USER:
		sig = SIGSYS;
		break;
d1056 5
d1062 1
d1067 3
d1072 1
a1072 1
#if 0
d1088 4
a1091 1
			if (instr != 0) {
a1126 1

d1130 1
a1130 1
	if (type < T_USER)
d1140 2
a1141 1
		frame->dsr = frame->isr = 0;
a1142 1

d1149 8
d1173 17
d1196 1
a1196 1
	DEBUG_MSG("You really can't restart after exception %d!\n", frame->vector);
d1200 1
d1202 12
d1336 1
a1336 2
	switch (error) {
	case 0:
d1351 7
a1357 2
		break;
	case ERESTART:
d1365 1
a1365 2
		break;
	case EJUSTRETURN:
a1367 10
		break;
	default:
		/* error != ERESTART && error != EJUSTRETURN*/
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		tf->r[2] = error;
		tf->epsr |= PSR_C;   /* fail */
		tf->snip = tf->snip & ~NIP_E;
		tf->sfip = tf->sfip & ~FIP_E;
		break;
d1382 1
a1382 1
/* Instruction pointers operate differently on mc88110 */
a1441 1
#ifdef DEBUG
a1442 1
#endif
d1465 1
a1465 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, &args, rval);
	else
#endif
		error = (*callp->sy_call)(p, &args, rval);
a1495 1
#ifdef DEBUG
a1496 1
#endif
d1509 1
a1509 1
		tf->exip += 4 + 4;
a1512 1
#ifdef DEBUG
a1513 1
#endif
a1521 1
#ifdef DEBUG
d1523 1
a1523 1
#endif
a1528 1
#ifdef DEBUG
a1529 1
#endif
d1570 1
a1570 1
		tf->exip += 4 + 4;
a1794 1
#if 0
a1796 1
#endif
@


1.1.1.4
log
@cvs is playing games with me.

@@@@@@ CONSIDER THE TREE LOCKED NOW @@@@@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2003/09/26 19:04:30 miod Exp $	*/
d94 2
a95 2
#define USERMODE(PSR)   (((PSR) & PSR_MODE) == 0)
#define SYSTEMMODE(PSR) (((PSR) & PSR_MODE) != 0)
@


1.1.1.5
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2003/12/19 22:30:18 miod Exp $	*/
d62 1
d66 2
a67 2
#include <machine/m88100.h>		/* DMT_xxx */
#include <machine/m8820x.h>		/* CMMU_PFSR_xxx */
d88 2
a89 2
#ifdef DDB
#define DEBUG_MSG(x) db_printf x
d91 1
a91 1
#define DEBUG_MSG(x)
d101 1
a101 1
__dead void error_fatal(struct m88100_saved_state *frame);
d156 1
a156 1
		addupc_task(p, frame->sxip & XIP_ADDR,
d162 1
a162 1
__dead void
a164 1
#ifdef DDB
d170 1
a170 1
			db_printf("\nInstr access fault (%s) v = %x, frame %p\n",
d172 1
a172 1
				  frame->sxip & XIP_ADDR, frame);
d175 1
a175 1
			db_printf("\nData access fault (%s) v = %x, frame %p\n",
d177 1
a177 1
				  frame->sxip & XIP_ADDR, frame);
d179 1
a179 1
			db_printf("\ntrap type %d, v = %x, frame %p\n", type, frame->sxip & XIP_ADDR, frame);
a181 1
#endif
d184 1
a184 2
	else
		panic("trap %d", type);
d198 1
a198 1
	vaddr_t va;
a205 3
#ifdef DDB
	int s;
#endif
d210 3
a212 3
	extern caddr_t guarded_access_start;
	extern caddr_t guarded_access_end;
	extern caddr_t guarded_access_bad;
d228 2
a230 4
	fault_type = 0;
	fault_code = 0;
	fault_addr = frame->sxip & XIP_ADDR;

a233 1
		break;
d238 8
a245 6
		s = splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_BREAK, (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
d247 21
a267 6
		s = splhigh();
		db_enable_interrupt();
		ddb_entry_trap(T_KDB_ENTRY, (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
d270 1
a270 1
		DEBUG_MSG(("Unimplemented opcode!\n"));
d275 1
a275 1
		/* This function pointer is set in machdep.c
d282 2
a283 2
		DEBUG_MSG(("kernel misaligned "
			  "access exception @@ 0x%08x\n", frame->sxip));
d291 2
a292 2
		DEBUG_MSG(("kernel mode instruction "
			  "page fault @@ 0x%08x\n", frame->sxip));
d314 1
a314 1
		va = trunc_page((vaddr_t)fault_addr);
d327 1
a327 1
#endif
d334 1
a334 1
			if ((frame->sxip & XIP_ADDR) >=
d336 1
a336 1
			    (frame->sxip & XIP_ADDR) <=
d350 1
a350 1
				frame->dmt0 |= DMT_SKIP;
d359 4
a362 3
			 * The fault was resolved. Call data_access_emulation
			 * to drain the data unit pipe line and reset dmt0
			 * so that trap won't get called again.
d370 1
a370 1
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
d376 2
a377 1
				 * won't get called again.
d401 1
a401 1
		/* We sort of resolved the fault ourselves because
d403 2
a404 2
		 * But we must still think about the other possible
		 * transactions in dmt1 & dmt2.  Mark dmt0 so that
d407 1
a407 1
		frame->dmt0 |= DMT_SKIP;
d417 2
a418 1
		if (type == T_INSTFLT + T_USER) {
d428 1
a428 1
#endif
d430 2
a431 2
		if (frame->dmt0 & (DMT_WRITE | DMT_LOCKBAR)) {
			ftype = VM_PROT_READ | VM_PROT_WRITE;
d438 1
a438 1
		va = trunc_page((vaddr_t)fault_addr);
d452 1
a452 1
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
d479 1
a479 1
				 * clearing the Error bit
d555 1
a555 1
			if ((p->p_md.md_ss_addr != pc &&
d567 1
a567 1
				iov.iov_len = sizeof(int);
d569 1
a569 1
				uio.uio_iovcnt = 1;
d583 1
a583 1
				iov.iov_len = sizeof(int);
d585 1
a585 1
				uio.uio_iovcnt = 1;
d638 1
a638 1
		/*
d657 1
a657 1
	vaddr_t va;
a663 1
	int result;
d667 1
d675 1
a675 2
	extern unsigned guarded_access_bad;
	extern pt_entry_t *pmap_pte(pmap_t, vaddr_t);
d695 2
a697 4
	fault_type = 0;
	fault_code = 0;
	fault_addr = frame->exip & XIP_ADDR;

a700 1
		break;
a701 1

d704 1
a704 1
		DEBUG_MSG(("DMMU read miss: Hardware Table Searches should be enabled!\n"));
a705 1
		break;
d709 1
a709 1
		DEBUG_MSG(("DMMU write miss: Hardware Table Searches should be enabled!\n"));
a710 1
		break;
d714 1
a714 1
		DEBUG_MSG(("IMMU miss: Hardware Table Searches should be enabled!\n"));
a715 1
		break;
d721 1
a721 1
		ddb_break_trap(T_KDB_TRACE, (db_regs_t*)frame);
d728 1
a728 1
		ddb_break_trap(T_KDB_BREAK, (db_regs_t*)frame);
d735 1
a735 1
		ddb_entry_trap(T_KDB_ENTRY, (db_regs_t*)frame);
d756 1
a756 1
		DEBUG_MSG(("Unimplemented opcode!\n"));
d761 1
a761 1
		/* This function pointer is set in machdep.c
d770 2
a771 2
		DEBUG_MSG(("kernel mode misaligned "
			  "access exception @@ 0x%08x\n", frame->exip));
a772 1
		break;
d779 2
a780 2
		DEBUG_MSG(("kernel mode instruction "
			  "page fault @@ 0x%08x\n", frame->exip));
a781 1
		break;
d802 1
a802 1
		va = trunc_page((vaddr_t)fault_addr);
d814 1
a814 1
			if ((frame->exip & XIP_ADDR) >=
d816 1
a816 1
			    (frame->exip & XIP_ADDR) <=
a817 1
				frame->exip = (unsigned)&guarded_access_bad;
a821 1
			frame->dsr &= ~CMMU_DSR_WE;	/* undefined */
d826 1
a826 1
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
d832 1
a832 1
			 * This could be a write protection fault or an
d834 2
a835 2
			 * in the pte. Basically, if we got a write error,
			 * then we already have a pte entry that faulted
d837 2
a838 2
			 * Get the pte and check the status of the
			 * modified and valid bits to determine if this
d855 1
a855 1
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
d876 1
d890 1
a890 1
		va = trunc_page((vaddr_t)fault_addr);
d907 1
a907 1
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
d919 1
a919 1
				/* This could be a write protection fault or an
d925 2
a926 2
				 * Get the pte and check the status of the
				 * modified and valid bits to determine if this
d950 1
a950 1
					result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
d957 1
a957 1
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
d963 1
a963 1
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
d974 1
a974 1
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
d1062 1
a1062 1
#endif
d1068 1
a1068 1
				iov.iov_len = sizeof(int);
d1070 1
a1070 1
				uio.uio_iovcnt = 1;
d1112 1
a1112 1
		/*
d1124 1
a1124 1
__dead void
a1126 1
#ifdef DDB
d1129 3
a1131 3
		db_printf("\n[RESET EXCEPTION (Really Bad News[tm]) frame %8p]\n", frame);
		db_printf("This is usually caused by a branch to a NULL function pointer.\n");
		db_printf("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
d1134 4
a1137 4
		db_printf("\n[ERROR EXCEPTION (Bad News[tm]) frame %p]\n", frame);
		db_printf("This is usually an exception within an exception.  The trap\n");
		db_printf("frame shadow registers you are about to see are invalid.\n");
		db_printf("(read totaly useless)  But R1 to R31 might be interesting.\n");
d1142 6
a1147 3
	db_printf("trap trace %d -> %d -> %d -> %d  ", last_trap[0], last_trap[1], last_trap[2], last_trap[3]);
	db_printf("last exception vector = %d\n", last_vector);
#endif
d1150 2
a1151 1
	panic("unrecoverable exception %d", frame->vector);
d1253 1
a1253 1
	 *	 subu r2, r0, 1
d1429 1
a1429 1
	 *	 subu r2, r0, 1
d1437 1
a1437 1
	 * 2. If the system call returned an errno > 0, increment
d1448 3
d1464 1
a1464 1
		tf->exip &= XIP_ADDR;
d1467 3
d1478 3
d1483 1
a1483 1
		tf->exip &= XIP_ADDR;
d1486 4
d1495 1
a1495 1
		tf->exip &= XIP_ADDR;
d1526 1
a1526 1
		tf->snip = tf->sfip & XIP_ADDR;
d1530 1
a1530 1
		tf->exip &= XIP_ADDR;
d1544 1
a1544 1
unsigned
d1552 1
a1552 1
	iov.iov_len = size;
d1554 1
a1554 1
	uio.uio_iovcnt = 1;
d1564 1
a1564 1
int
d1572 1
a1572 1
	iov.iov_len = size;
d1574 1
a1574 1
	uio.uio_iovcnt = 1;
d1730 1
a1730 1
				printf("SS %s (%d): next taken breakpoint set at %x\n",
d1732 1
a1732 1
#endif
d1742 1
a1742 1
		printf("SS %s (%d): next breakpoint set at %x\n",
d1744 1
a1744 1
#endif
d1748 1
a1748 1
		printf("SS %s (%d): next breakpoint set at %x\n",
d1750 1
a1750 1
#endif
@


1.1.1.6
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.62 2003/12/24 15:30:13 miod Exp $	*/
d379 22
a400 2
		panictrap(frame->vector, frame);
		/* NOTREACHED */
a440 2
			if (result == EACCES)
				result = EFAULT;
d449 2
a450 17
			}
		}

		/*
		 * This could be a fault caused in copyin*()
		 * while accessing user space.
		 */
		if (result != 0 && p->p_addr->u_pcb.pcb_onfault != NULL) {
			frame->snip = p->p_addr->u_pcb.pcb_onfault | NIP_V;
			frame->sfip = (p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
			frame->sxip = 0;
			/*
			 * Continue as if the fault had been resolved, but
			 * do not try to complete the faulting access.
			 */
			frame->dmt0 |= DMT_SKIP;
			result = 0;
d476 1
a476 1
			    BUS_ADRERR : SEGV_MAPERR;
d861 9
a869 2
		panictrap(frame->vector, frame);
		/* NOTREACHED */
a906 2
				if (result == EACCES)
					result = EFAULT;
a949 2
					if (result == EACCES)
						result = EFAULT;
a956 2
				if (result == EACCES)
					result = EFAULT;
a962 2
				if (result == EACCES)
					result = EFAULT;
a973 2
				if (result == EACCES)
					result = EFAULT;
d982 2
a983 14
			}
		}

		/*
		 * This could be a fault caused in copyin*()
		 * while accessing user space.
		 */
		if (result != 0 && p->p_addr->u_pcb.pcb_onfault != NULL) {
			frame->exip = p->p_addr->u_pcb.pcb_onfault;
			frame->dsr = frame->isr = 0;
			/*
			 * Continue as if the fault had been resolved.
			 */
			result = 0;
d1154 3
a1156 3
	int i, nsys, nap;
	struct sysent *callp;
	struct proc *p;
d1158 4
a1161 1
	register_t args[11], rval[2], *ap;
d1193 1
a1193 1
	nap = 11; /* r2-r12 */
d1215 1
a1215 1
		if (i > nap)
d1221 1
a1221 1
		bcopy((caddr_t)ap, (caddr_t)args, i * sizeof(register_t));
a1222 1

d1224 1
a1224 1
	scdebug_call(p, code, args);
d1228 1
a1228 1
		ktrsyscall(p, code, callp->sy_argsize, args);
d1234 1
a1234 1
		error = systrace_redirect(code, p, args, rval);
d1237 1
a1237 1
		error = (*callp->sy_call)(p, args, rval);
d1327 3
a1329 3
	int i, nsys, nap;
	struct sysent *callp;
	struct proc *p;
d1331 4
a1334 1
	register_t args[11], rval[2], *ap;
d1366 1
a1366 1
	nap = 11;	/* r2-r12 */
d1391 1
a1391 1
		if (i > nap)
d1397 1
a1397 1
		bcopy((caddr_t)ap, (caddr_t)args, i * sizeof(register_t));
d1400 1
a1400 1
	scdebug_call(p, code, args);
d1404 1
a1404 1
		ktrsyscall(p, code, callp->sy_argsize, args);
d1410 1
a1410 1
		error = systrace_redirect(code, p, args, rval);
d1413 1
a1413 1
		error = (*callp->sy_call)(p, args, rval);
@


1.1.1.7
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.70 2004/01/20 14:34:40 miod Exp $	*/
d81 6
a98 3
__dead void panictrap(int, struct trapframe *);
__dead void error_fatal(struct trapframe *);

d100 1
d102 1
a102 1
const char *trap_type[] = {
a115 1
const int trap_types = sizeof trap_type / sizeof trap_type[0];
d117 1
a117 1
const char *pbus_exception_type[] = {
d128 2
d131 1
a131 1
userret(struct proc *p, struct trapframe *frame, u_quad_t oticks)
d155 1
a155 1
		addupc_task(p, frame->tf_sxip & XIP_ADDR,
d162 1
a162 1
panictrap(int type, struct trapframe *frame)
d168 12
a179 29
		switch (cputyp) {
#ifdef M88100
		case CPU_88100:
			if (type == 2) {
				/* instruction exception */
				db_printf("\nInstr access fault (%s) v = %x, "
				    "frame %p\n",
				    pbus_exception_type[
				      CMMU_PFSR_FAULT(frame->tf_ipfsr)],
				    frame->tf_sxip & XIP_ADDR, frame);
			} else if (type == 3) {
				/* data access exception */
				db_printf("\nData access fault (%s) v = %x, "
				    "frame %p\n",
				    pbus_exception_type[
				      CMMU_PFSR_FAULT(frame->tf_dpfsr)],
				    frame->tf_sxip & XIP_ADDR, frame);
			} else
				db_printf("\nTrap type %d, v = %x, frame %p\n",
				    type, frame->tf_sxip & XIP_ADDR, frame);
			break;
#endif
#ifdef M88110
		case CPU_88110:
			db_printf("\nTrap type %d, v = %x, frame %p\n",
			    type, frame->tf_exip, frame);
			break;
#endif
		}
d191 3
d195 1
a195 1
m88100_trap(unsigned type, struct trapframe *frame)
d212 1
d219 6
d229 1
a229 1
	if (USERMODE(frame->tf_epsr)) {
d236 1
a236 1
	fault_addr = frame->tf_sxip & XIP_ADDR;
d240 1
a240 1
		panictrap(frame->tf_vector, frame);
d262 1
a262 1
		panictrap(frame->tf_vector, frame);
d274 2
a275 2
			  "access exception @@ 0x%08x\n", frame->tf_sxip));
		panictrap(frame->tf_vector, frame);
d282 3
a284 7
#ifdef TRAPDEBUG
		pbus_type = CMMU_PFSR_FAULT(frame->tf_ipfsr);
		printf("Kernel Instruction fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		    pbus_type, pbus_exception_type[pbus_type],
		    fault_addr, frame, frame->tf_cpu);
#endif
		panictrap(frame->tf_vector, frame);
d291 1
a291 1
		if ((frame->tf_dmt0 & DMT_DAS) == 0) {
d296 2
a297 2
		fault_addr = frame->tf_dma0;
		if (frame->tf_dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
d313 2
a314 2
		pbus_type = CMMU_PFSR_FAULT(frame->tf_dpfsr);
#ifdef TRAPDEBUG
d316 2
a317 2
		    pbus_type, pbus_exception_type[pbus_type],
		    fault_addr, frame, frame->tf_cpu);
d325 1
a325 1
			if ((frame->tf_sxip & XIP_ADDR) >=
d327 1
a327 1
			    (frame->tf_sxip & XIP_ADDR) <=
d329 1
a329 1
				frame->tf_snip =
d331 1
a331 1
				frame->tf_sfip =
d333 1
a333 1
				frame->tf_sxip = 0;
d341 1
a341 1
				frame->tf_dmt0 |= DMT_SKIP;
d343 2
a344 2
				frame->tf_dpfsr = 0;
				frame->tf_dmt0 = 0;
d355 2
a356 2
			frame->tf_dpfsr = 0;
			frame->tf_dmt0 = 0;
d369 2
a370 2
				frame->tf_dpfsr = 0;
				frame->tf_dmt0 = 0;
d375 3
a377 3
#ifdef TRAPDEBUG
		printf("PBUS Fault %d (%s) va = 0x%x\n", pbus_type,
		    pbus_exception_type[pbus_type], va);
d379 1
a379 1
		panictrap(frame->tf_vector, frame);
d387 1
a387 6
			pbus_type = CMMU_PFSR_FAULT(frame->tf_ipfsr);
#ifdef TRAPDEBUG
			printf("User Instruction fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
			    pbus_type, pbus_exception_type[pbus_type],
			    fault_addr, frame, frame->tf_cpu);
#endif
d389 7
a395 6
			fault_addr = frame->tf_dma0;
			pbus_type = CMMU_PFSR_FAULT(frame->tf_dpfsr);
#ifdef TRAPDEBUG
			printf("User Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
			    pbus_type, pbus_exception_type[pbus_type],
			    fault_addr, frame, frame->tf_cpu);
a396 1
		}
d398 1
a398 1
		if (frame->tf_dmt0 & (DMT_WRITE | DMT_LOCKBAR)) {
d439 3
a441 3
			frame->tf_snip = p->p_addr->u_pcb.pcb_onfault | NIP_V;
			frame->tf_sfip = (p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
			frame->tf_sxip = 0;
d446 1
a446 1
			frame->tf_dmt0 |= DMT_SKIP;
d459 2
a460 2
				frame->tf_dpfsr = 0;
				frame->tf_dmt0 = 0;
d466 3
a468 3
				frame->tf_sfip = frame->tf_snip & ~FIP_E;
				frame->tf_snip = frame->tf_sxip & ~NIP_E;
				frame->tf_ipfsr = 0;
a530 1
			unsigned pc = PC_REGS(&frame->tf_regs);
d579 3
a581 3
			frame->tf_sfip = frame->tf_snip;    /* set up next FIP */
			frame->tf_snip = pc;    /* set up next NIP */
			frame->tf_snip |= 2;	  /* set valid bit   */
d598 2
a599 2
		frame->tf_sfip = frame->tf_snip;    /* set up the next FIP */
		frame->tf_snip = frame->tf_sxip;    /* set up the next NIP */
d627 2
a628 2
		frame->tf_dmt0 = 0;
		frame->tf_ipfsr = frame->tf_dpfsr = 0;
d637 1
a637 1
m88110_trap(unsigned type, struct trapframe *frame)
d654 1
d667 11
a677 1
	if (USERMODE(frame->tf_epsr)) {
d684 1
a684 1
	fault_addr = frame->tf_exip & XIP_ADDR;
d688 1
a688 1
		panictrap(frame->tf_vector, frame);
d695 1
a695 1
		panictrap(frame->tf_vector, frame);
d701 1
a701 1
		panictrap(frame->tf_vector, frame);
d707 1
a707 1
		panictrap(frame->tf_vector, frame);
d730 2
a731 2
		if (frame->tf_enip) {
			frame->tf_exip = frame->tf_enip;
d733 1
a733 1
			frame->tf_exip += 4;
d750 1
a750 1
		panictrap(frame->tf_vector, frame);
d764 2
a765 2
			  "access exception @@ 0x%08x\n", frame->tf_exip));
		panictrap(frame->tf_vector, frame);
d773 3
a775 5
#ifdef TRAPDEBUG
		printf("Kernel Instruction fault exip %x isr %x ilar %x\n",
		    frame->tf_exip, frame->tf_isr, frame->tf_ilar);
#endif
		panictrap(frame->tf_vector, frame);
d783 1
a783 1
		if ((frame->tf_dsr & CMMU_DSR_SU) == 0) {
d788 2
a789 7
#ifdef TRAPDEBUG
		printf("Kernel Data access fault exip %x dsr %x dlar %x\n",
		    frame->tf_exip, frame->tf_dsr, frame->tf_dlar);
#endif

		fault_addr = frame->tf_dlar;
		if (frame->tf_dsr & CMMU_DSR_RW) {
d805 1
a805 1
		if (frame->tf_dsr & CMMU_DSR_BE) {
d809 1
a809 1
			if ((frame->tf_exip & XIP_ADDR) >=
d811 1
a811 1
			    (frame->tf_exip & XIP_ADDR) <=
d813 1
a813 1
				frame->tf_exip = (unsigned)&guarded_access_bad;
d817 2
a818 2
		if (frame->tf_dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
			frame->tf_dsr &= ~CMMU_DSR_WE;	/* undefined */
d827 1
a827 1
		if (frame->tf_dsr & CMMU_DSR_WE) {	/* write fault  */
a842 4
#ifdef TRAPDEBUG
				printf("Corrected kernel write fault, map %x pte %x\n",
				    map->pmap, *pte);
#endif
d848 3
a850 3
#ifdef TRAPDEBUG
				printf("Uncorrected kernel write fault, map %x pte %x\n",
				    map->pmap, *pte);
d858 1
a858 1
		panictrap(frame->tf_vector, frame);
a867 4
#ifdef TRAPDEBUG
			printf("User Instruction fault exip %x isr %x ilar %x\n",
			    frame->tf_exip, frame->tf_isr, frame->tf_ilar);
#endif
d869 2
a870 2
			fault_addr = frame->tf_dlar;
			if (frame->tf_dsr & CMMU_DSR_RW) {
a876 4
#ifdef TRAPDEBUG
			printf("User Data access fault exip %x dsr %x dlar %x\n",
			    frame->tf_exip, frame->tf_dsr, frame->tf_dlar);
#endif
d890 1
a890 1
			if (frame->tf_dsr & CMMU_DSR_BE) {
d894 1
a894 1
			if (frame->tf_dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
d899 4
d904 1
a904 1
			if (frame->tf_dsr & (CMMU_DSR_CP | CMMU_DSR_WA)) {
d908 1
a908 1
			if (frame->tf_dsr & CMMU_DSR_WE) {
a920 1
#ifdef DEBUG
a922 1
#endif
a927 4
#ifdef TRAPDEBUG
					printf("Corrected userland write fault, map %x pte %x\n",
					    map->pmap, *pte);
#endif
d937 3
a939 3
#ifdef TRAPDEBUG
					printf("Uncorrected userland write fault, map %x pte %x\n",
					    map->pmap, *pte);
d946 3
a948 3
#ifdef TRAPDEBUG
				printf("Unexpected Data access fault dsr %x\n",
				    frame->tf_dsr);
d950 3
a952 1
				panictrap(frame->tf_vector, frame);
d956 7
a962 1
			if (frame->tf_isr &
d966 5
a970 3
			} else
			if (frame->tf_isr & (CMMU_ISR_SI | CMMU_ISR_PI)) {
				/* segment or page fault */
a973 6
			} else {
#ifdef TRAPDEBUG
				printf("Unexpected Instruction fault isr %x\n",
				    frame->tf_isr);
#endif
				panictrap(frame->tf_vector, frame);
d990 2
a991 2
			frame->tf_exip = p->p_addr->u_pcb.pcb_onfault;
			frame->tf_dsr = frame->tf_isr = 0;
a1057 1
			unsigned pc = PC_REGS(&frame->tf_regs);
d1127 1
a1127 1
		frame->tf_dsr = frame->tf_isr = 0;
d1132 1
d1136 1
a1136 1
error_fatal(struct trapframe *frame)
d1139 1
a1139 1
	switch (frame->tf_vector) {
d1153 5
d1159 1
a1159 1
	panic("unrecoverable exception %d", frame->tf_vector);
d1164 1
a1164 1
m88100_syscall(register_t code, struct trapframe *tf)
d1184 1
a1184 1
	if (USERMODE(tf->tf_epsr) == 0)
d1201 1
a1201 1
	ap = &tf->tf_r[2];
d1290 6
a1295 6
		tf = (struct trapframe *)USER_REGS(p);
		tf->tf_r[2] = rval[0];
		tf->tf_r[3] = rval[1];
		tf->tf_epsr &= ~PSR_C;
		tf->tf_snip = tf->tf_sfip & ~NIP_E;
		tf->tf_sfip = tf->tf_snip + 4;
d1302 3
a1304 3
		tf->tf_epsr &= ~PSR_C;
		tf->tf_sfip = tf->tf_snip & ~FIP_E;
		tf->tf_snip = tf->tf_sxip & ~NIP_E;
d1308 1
a1308 1
		tf->tf_epsr &= ~PSR_C;
d1314 4
a1317 4
		tf->tf_r[2] = error;
		tf->tf_epsr |= PSR_C;   /* fail */
		tf->tf_snip = tf->tf_snip & ~NIP_E;
		tf->tf_sfip = tf->tf_sfip & ~FIP_E;
d1332 1
d1335 1
a1335 1
m88110_syscall(register_t code, struct trapframe *tf)
d1355 1
a1355 1
	if (USERMODE(tf->tf_epsr) == 0)
d1372 1
a1372 1
	ap = &tf->tf_r[2];
d1390 3
d1459 6
a1464 6
		tf = (struct trapframe *)USER_REGS(p);
		tf->tf_r[2] = rval[0];
		tf->tf_r[3] = rval[1];
		tf->tf_epsr &= ~PSR_C;
		tf->tf_exip += 4 + 4;
		tf->tf_exip &= XIP_ADDR;
d1472 1
a1472 1
		tf->tf_epsr &= ~PSR_C;
d1475 3
a1477 3
		tf->tf_epsr &= ~PSR_C;
		tf->tf_exip += 4;
		tf->tf_exip &= XIP_ADDR;
d1482 4
a1485 4
		tf->tf_r[2] = error;
		tf->tf_epsr |= PSR_C;   /* fail */
		tf->tf_exip += 4;
		tf->tf_exip &= XIP_ADDR;
d1511 4
a1514 4
	tf = (struct trapframe *)USER_REGS(p);
	tf->tf_r[2] = 0;
	tf->tf_r[3] = 0;
	tf->tf_epsr &= ~PSR_C;
d1516 2
a1517 2
		tf->tf_snip = tf->tf_sfip & XIP_ADDR;
		tf->tf_sfip = tf->tf_snip + 4;
d1519 2
a1520 2
		tf->tf_exip += 4 + 4;
		tf->tf_exip &= XIP_ADDR;
d1530 3
a1532 16
#ifdef PTRACE

/*
 * User Single Step Debugging Support
 */

#include <sys/ptrace.h>

unsigned ss_get_value(struct proc *, unsigned, int);
int ss_put_value(struct proc *, unsigned, unsigned, int);
unsigned ss_branch_taken(unsigned, unsigned,
    unsigned (*func)(unsigned int, struct reg *), struct reg *);
unsigned int ss_getreg_val(unsigned int, struct reg *);
int ss_inst_branch(unsigned);
int ss_inst_delayed(unsigned);
unsigned ss_next_instr_address(struct proc *, unsigned, unsigned);
d1559 1
d1570 2
a1571 1
	return procfs_domem(curproc, p, NULL, &uio);
d1586 5
a1590 2
ss_branch_taken(unsigned inst, unsigned pc,
    unsigned (*func)(unsigned int, struct reg *), struct reg *func_data)
d1592 1
d1594 1
a1594 1
	if ((inst & 0xf0000000) == 0xc0000000) {
d1596 1
a1596 1
		inst = (inst & 0x03ffffff) << 2;
d1598 3
a1600 3
		if (inst & 0x08000000)
			inst |= 0xf0000000;
		return (pc + inst);
d1604 4
a1607 4
	switch (inst & 0xf8000000) {
	case 0xd0000000: /* bb0 */
	case 0xd8000000: /* bb1 */
	case 0xe8000000: /* bcnd */
d1609 1
a1609 1
		inst = (inst & 0x0000ffff) << 2;
d1611 3
a1613 3
		if (inst & 0x00020000)
			inst |= 0xfffc0000;
		return (pc + inst);
d1618 1
a1618 1
	if ((inst & 0xfffff3e0) == 0xf400c000)
d1621 1
a1621 2
	/* can't happen */
	return (0);
d1629 2
a1630 2
unsigned int
ss_getreg_val(unsigned int regno, struct reg *regs)
d1632 8
a1639 1
	return (regno == 0 ? 0 : regs->r[regno]);
d1647 1
a1647 1
	switch (ins >> (32 - 5)) {
d1655 1
a1655 1
		if ((ins & 0xfffffbe0) == 0xf400c000)
d1669 1
a1669 1
	switch ((ins & 0xfc000000) >> (32 - 6)) {
d1680 1
a1680 1
	return ((ins & 0xfffff7e0) == 0xf400c400) ? TRUE : FALSE;
d1687 1
a1687 1
		return (pc + 4);
d1690 1
a1690 1
			return (pc + 4);
d1698 1
a1698 1
	struct proc *p;
d1700 1
a1700 1
	struct reg *sstf = USER_REGS(p);
d1702 1
d1716 1
a1716 2
		if (ss_inst_branch(curinstr) ||
		    inst_call(curinstr) || inst_return(curinstr)) {
d1719 4
d1724 4
a1727 7
				p->p_md.md_ss_taken_instr =
				    ss_get_value(p, brpc, sizeof(int));
				/* Store breakpoint instruction at the
				   "next" location now. */
				if (ss_put_value(p, brpc, bpinstr,
				    sizeof(int)) != 0)
					return (EFAULT);
d1731 4
d1737 4
d1743 5
a1747 1
	if (p->p_md.md_ss_addr != NULL) {
d1757 1
a1757 2
	if (ss_put_value(p, pc, bpinstr, sizeof(int)) != 0)
		return (EFAULT);
d1759 1
a1762 1
#endif	/* PTRACE */
d1770 1
a1770 5
	/*
	 * This will raise the spl if too low,
	 * in a feeble attempt to reduce further damage.
	 */
	oldipl = raiseipl(wantipl);
d1774 5
@


