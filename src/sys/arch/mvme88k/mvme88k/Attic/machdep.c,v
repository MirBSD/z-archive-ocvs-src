head	1.2;
access;
symbols
	cvs-200405160640:1.1.1.10
	cvs-200401271800:1.1.1.9
	cvs-200401261630:1.1.1.9
	cvs-200401021645:1.1.1.8
	cvs-200312222040:1.1.1.7
	cvs-200310020700:1.1.1.6
	cvs-200309271030:1.1.1.5
	cvs-200309261655:1.1.1.5
	cvs-200309251530:1.1.1.5
	cvs-200308302005:1.1.1.4
	cvs-200308171200:1.1.1.4
	ctm-3496:1.1.1.3
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	cvs-200307072125:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200307021520:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.04.06.04.29.31;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.50.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.50.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.21.19.06.07;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.11.18.35.47;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.17.14.31.28;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.09.25.16.35.57;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.10.02.07.39.39;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.12.22.21.00.00;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.01.02.17.49.46;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.01.26.18.42.36;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.05.16.08.37.40;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove "some dead architectures".

These are all but i386 and x86-64 (which is not in the tree yet),
because I have no machines to work with.

Re-adding support should be fairly easy, just cvs adding a partial
OpenBSD checkout and pulling in stuff like kernel signal patch, humantime,
etc. which got added to i386 as well.

You will need gcc support as well.
@
text
@/* $OpenBSD: machdep.c,v 1.100 2003/01/13 20:12:18 miod Exp $	*/
/*
 * Copyright (c) 1998, 1999, 2000, 2001 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/syscallargs.h>
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
#include <sys/ioctl.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/errno.h>
#include <sys/extent.h>
#include <sys/core.h>
#include <sys/kcore.h>

#include <net/netisr.h>

#include <machine/asm_macro.h>   /* enable/disable interrupts */
#include <machine/mmu.h>
#include <machine/board.h>
#include <machine/bug.h>
#include <machine/bugio.h>
#include <machine/cmmu.h>		/* CMMU stuff	*/
#include <machine/cpu.h>
#include <machine/cpu_number.h>
#include <machine/kcore.h>
#include <machine/locore.h>
#include <machine/prom.h>
#include <machine/reg.h>
#include <machine/trap.h>
#ifdef M88100
#include <machine/m88100.h>		/* DMT_VALID	*/
#endif 

#include <dev/cons.h>

#include <uvm/uvm_extern.h>

#include <mvme88k/dev/sysconreg.h>
#include <mvme88k/dev/pcctworeg.h>
#include <mvme88k/dev/busswreg.h>

#include "assym.h"			/* EF_EPSR, etc. */
#include "ksyms.h"
#if DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
#include <ddb/db_output.h>		/* db_printf()		*/
#endif /* DDB */

#if DDB
#define DEBUG_MSG db_printf
#else
#define DEBUG_MSG printf
#endif /* DDB */

struct intrhand *intr_handlers[256];
vm_offset_t interrupt_stack[MAX_CPUS] = {0};

/* machine dependant function pointers. */
struct md_p md;

/* prototypes */
void m88100_Xfp_precise(void);
void m88110_Xfp_precise(void);
void setupiackvectors(void);
void regdump(struct trapframe *f);
void dumpsys(void);
void consinit(void);
vm_offset_t size_memory(void);
vm_offset_t memsize187(void);
int getcpuspeed(void);
int getscsiid(void);
void identifycpu(void);
void save_u_area(struct proc *, vm_offset_t);
void load_u_area(struct proc *);
void dumpconf(void);
void m187_ext_int(u_int v, struct m88100_saved_state *eframe);
void m188_ext_int(u_int v, struct m88100_saved_state *eframe);
void m197_ext_int(u_int v, struct m88100_saved_state *eframe);

unsigned char *volatile ivec[] = {
	(unsigned char *)0xFFFE0003, /* not used, no such thing as int 0 */
	(unsigned char *)0xFFFE0007,
	(unsigned char *)0xFFFE000B,
	(unsigned char *)0xFFFE000F,
	(unsigned char *)0xFFFE0013,
	(unsigned char *)0xFFFE0017,
	(unsigned char *)0xFFFE001B,
	(unsigned char *)0xFFFE001F,
	(unsigned char *)0x00000000,
};

#ifdef MVME188
/*
 * *int_mask_reg[CPU]
 * Points to the hardware interrupt status register for each CPU.
 */
unsigned int *volatile int_mask_reg[MAX_CPUS] = {
	(unsigned int *)IEN0_REG,
	(unsigned int *)IEN1_REG,
	(unsigned int *)IEN2_REG,
	(unsigned int *)IEN3_REG
};
#endif 

volatile vm_offset_t bugromva;
volatile vm_offset_t sramva;
volatile vm_offset_t obiova;
#ifdef MVME188
volatile vm_offset_t utilva;
#endif

int ssir;
int want_ast;
int want_resched;

int physmem;	  /* available physical memory, in pages */
int longformat = 1;  /* for regdump() */
/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = IPL_NONE;

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

/*
 * iomap stuff is for managing chunks of virtual address space that
 * can be allocated to IO devices.
 * VMEbus drivers use this at this now. Only on-board IO devices' addresses
 * are mapped so that pa == va. XXX smurph.
 */

vaddr_t iomapbase;

struct extent *iomap_extent;
struct vm_map *iomap_map;

/*
 * Declare these as initialized data so we can patch them.
 */
#ifdef	NBUF
int   nbuf = NBUF;
#else
int   nbuf = 0;
#endif

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef	BUFPAGES
int   bufpages = BUFPAGES;
#else
int   bufpages = 0;
#endif
int   bufcachepercent = BUFCACHEPERCENT;

caddr_t allocsys(caddr_t);

/*
 * Info for CTL_HW
 */
char  machine[] = MACHINE;	 /* cpu "architecture" */
char  cpu_model[120];

struct bugenv bugargs;

struct kernel {
	void *entry;
	void *symtab;
	void *esym;
	int   bflags;
	int   bdev;
	char *kname;
	void *smini;
	void *emini;
	void *end_load;
}kflags;
#if defined(DDB) || NKSYMS > 0
extern char *esym;
#endif

int boothowto;	/* set in locore.S */
int bootdev;	/* set in locore.S */
int cputyp;	/* set in locore.S */
int brdtyp;	/* set in locore.S */
int cpumod = 0; /* set in mvme_bootstrap() */
int cpuspeed = 25;   /* 25 MHZ XXX should be read from NVRAM */

vm_offset_t first_addr = 0;
vm_offset_t last_addr = 0;

vm_offset_t avail_start, avail_end;
vm_offset_t virtual_avail, virtual_end;

pcb_t    curpcb;
extern struct user *proc0paddr;

/* 
 *  XXX this is to fake out the console routines, while 
 *  booting. New and improved! :-) smurph
 */
void bootcnprobe(struct consdev *);
void bootcninit(struct consdev *);
void bootcnputc(dev_t, int);
int  bootcngetc(dev_t);
extern void nullcnpollc(dev_t, int);

#define bootcnpollc nullcnpollc

static struct consdev bootcons = {
	NULL, 
	NULL, 
	bootcngetc, 
	bootcnputc,
	bootcnpollc,
	NULL,
	makedev(14,0),
	1
};

/*
 * Console initialization: called early on from main,
 * before vm init or startup.  Do enough configuration
 * to choose and initialize a console.
 */
void
consinit()
{
	extern struct consdev *cn_tab;

	/*
	 * Initialize the console before we print anything out.
	 */
	cn_tab = NULL;
	cninit();

#if defined(DDB)
	db_machine_init();
	ddb_init();
	if (boothowto & RB_KDB)
		Debugger();
#endif
}

#ifdef MVME187
/*
 * Figure out how much memory is available, by querying the memory controllers
 */
#include <mvme88k/dev/memcreg.h>
vm_offset_t
memsize187()
{
	struct memcreg *memc;
	vm_offset_t x;

	memc = (struct memcreg *)0xfff43000;
	x = MEMC_MEMCONF_RTOB(memc->memc_memconf);

	memc = (struct memcreg *)0xfff43100;
	if (!badaddr((vm_offset_t)&memc->memc_memconf, 1))
		x += MEMC_MEMCONF_RTOB(memc->memc_memconf);

	return x;
}
#endif

#if defined(MVME188) || defined(MVME197)
/*
 * Figure out how much real memory is available.
 * Start looking from the megabyte after the end of the kernel data,
 * until we find non-memory.
 */
vm_offset_t
size_memory()
{
	unsigned int *volatile look;
	unsigned int *max;
	extern char *end;
#define PATTERN   0x5a5a5a5a
#define STRIDE    (4*1024) 	/* 4k at a time */
#define Roundup(value, stride) (((unsigned)(value) + (stride) - 1) & ~((stride)-1))
	/*
	 * count it up.
	 */
	max = (void *)MAXPHYSMEM;
	for (look = (void *)Roundup(end, STRIDE); look < max;
	    look = (int *)((unsigned)look + STRIDE)) {
		unsigned save;

		/* if can't access, we've reached the end */
		if (badwordaddr((vaddr_t)look)) {
#if defined(DEBUG)
			printf("%x\n", look);
#endif
			look = (int *)((int)look - STRIDE);
			break;
		}

		/*
		 * If we write a value, we expect to read the same value back.
		 * We'll do this twice, the 2nd time with the opposite bit
		 * pattern from the first, to make sure we check all bits.
		 */
		save = *look;
		if (*look = PATTERN, *look != PATTERN)
			break;
		if (*look = ~PATTERN, *look != ~PATTERN)
			break;
		*look = save;
	}
	if ((look > (unsigned int *)0x01FFF000) && (brdtyp == BRD_188)) {
                /* temp hack to fake 32Meg on MVME188 */
		look = (unsigned int *)0x01FFF000; 
	}
	
	return (trunc_page((unsigned)look));
}
#endif	/* defined(MVME188) || defined(MVME197) */

int
getcpuspeed()
{
	struct mvmeprom_brdid brdid;
	int speed = 0;
	int i, c;
	bugbrdid(&brdid);
	for (i=0; i<4; i++) {
		c=(unsigned char)brdid.speed[i];
		c-= '0';
		speed *=10;
		speed +=c;
	}
	speed = speed / 100;
	return (speed);
}

int
getscsiid()
{
	struct mvmeprom_brdid brdid;
	int scsiid = 0;
	int i, c;
	bugbrdid(&brdid);
	for (i=0; i<2; i++) {
		c=(unsigned char)brdid.scsiid[i];
		scsiid *=10;
		c-= '0';
		scsiid +=c;
	}
	printf("SCSI ID = %d\n", scsiid);
	return (7); /* hack! */
}

void
identifycpu()
{
	cpuspeed = getcpuspeed();
	sprintf(cpu_model, "Motorola MVME%x, %dMHz", brdtyp, cpuspeed);
	printf("\nModel: %s\n", cpu_model);
}

/*
 *	Setup u area ptes for u area double mapping.
 */

void
save_u_area(struct proc *p, vm_offset_t va)
{
	int i; 
	for (i=0; i<UPAGES; i++) {
		p->p_md.md_upte[i] = *((pt_entry_t *)kvtopte((va + (i * NBPG))));
	}
}

void
load_u_area(struct proc *p)
{
	pt_entry_t *t;

	int i; 
	for (i=0; i<UPAGES; i++) {
		t = kvtopte((UADDR + (i * NBPG)));
		*t = p->p_md.md_upte[i];
	}
	for (i=0; i<UPAGES; i++) {
		cmmu_flush_tlb(1, (UADDR + (i * NBPG)), NBPG);
	}
}

/*
 * Set up real-time clocks.
 * These function pointers are set in dev/clock.c and dev/sclock.c
 */
void 
cpu_initclocks()
{
#ifdef DEBUG
	printf("cpu_initclocks(): ");
#endif 
	if (md.clock_init_func != NULL) {
#ifdef DEBUG
		printf("[interval clock] ");
#endif 
		(*md.clock_init_func)();
	}
	if (md.statclock_init_func != NULL) {
#ifdef DEBUG
		printf("[statistics clock]");
#endif 
		(*md.statclock_init_func)();
	}
#ifdef DEBUG
	printf("\n");
#endif 
}

void
setstatclockrate(int newhz)
{
   /* function stub */
}


void
cpu_startup()
{
	caddr_t v;
	int sz, i;
	vm_size_t size;    
	int base, residual;
	vaddr_t minaddr, maxaddr, uarea_pages;

	/*
	 * Initialize error message buffer (at end of core).
	 * avail_end was pre-decremented in mvme_bootstrap() to compensate.
	 */
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
		pmap_kenter_pa((vm_offset_t)msgbufp, 
			   avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE);
	pmap_update(pmap_kernel());
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	identifycpu();
	printf("real mem  = %d\n", ctob(physmem));

	/*
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);

	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
	 * Grab UADDR virtual address
	 */
	uarea_pages = UADDR;
	uvm_map(kernel_map, (vaddr_t *)&uarea_pages, USPACE,
		NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
						     UVM_PROT_NONE,
						     UVM_INH_NONE,
						     UVM_ADV_NORMAL, 0));
	if (uarea_pages != UADDR) {
		printf("uarea_pages %x: UADDR not free\n", uarea_pages);
		panic("bad UADDR");
	}
	
	/* 
	 * Grab machine dependant memory spaces
	 */
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
		/*
		 * Grab the SRAM space that we hardwired in pmap_bootstrap
		 */
		sramva = SRAM_START;
		uvm_map(kernel_map, (vaddr_t *)&sramva, SRAM_SIZE,
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));

		if (sramva != SRAM_START) {
			printf("sramva %x: SRAM not free\n", sramva);
			panic("bad sramva");
		}
#endif 
#ifdef MVME197
	case BRD_197:
#endif 
#if defined(MVME187) || defined(MVME197)
		/*
		 * Grab the BUGROM space that we hardwired in pmap_bootstrap
		 */
		bugromva = BUGROM_START;

		uvm_map(kernel_map, (vaddr_t *)&bugromva, BUGROM_SIZE,
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));
		if (bugromva != BUGROM_START) {
			printf("bugromva %x: BUGROM not free\n", bugromva);
			panic("bad bugromva");
		}
		
		/*
		 * Grab the OBIO space that we hardwired in pmap_bootstrap
		 */
		obiova = OBIO_START;
		uvm_map(kernel_map, (vaddr_t *)&obiova, OBIO_SIZE,
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));
		if (obiova != OBIO_START) {
			printf("obiova %x: OBIO not free\n", obiova);
			panic("bad OBIO");
		}
		break;
#endif 
#ifdef MVME188
	case BRD_188:
		/*
		 * Grab the UTIL space that we hardwired in pmap_bootstrap
		 */
		utilva = MVME188_UTILITY;
		uvm_map(kernel_map, (vaddr_t *)&utilva, MVME188_UTILITY_SIZE,
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));
		if (utilva != MVME188_UTILITY) {
			printf("utilva %x: UTILITY area not free\n", utilva);
			panic("bad utilva");
		}
		break;
#endif
	}

	/*
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");
	minaddr = (vaddr_t)buffers;

	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
	base = bufpages / nbuf;
	residual = bufpages % nbuf;

	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				      "buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
	
	/*
	 * Allocate map for physio.
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);

	/* 
	 * Allocate map for external I/O.
	 */
	iomap_map = uvm_km_suballoc(kernel_map, &iomapbase, &maxaddr,
				   IOMAP_SIZE, 0, FALSE, NULL);

	iomap_extent = extent_create("iomap", iomapbase,
	    iomapbase + IOMAP_SIZE, M_DEVBUF, NULL, 0, EX_NOWAIT);
	if (iomap_extent == NULL)
		panic("unable to allocate extent for iomap");

	printf("avail mem = %ld (%ld pages)\n", ptoa(uvmexp.free), uvmexp.free);
	printf("using %d buffers containing %d bytes of memory\n", nbuf,
	    bufpages * PAGE_SIZE);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * zero out intr_handlers
	 */
	bzero((void *)intr_handlers, 256 * sizeof(struct intrhand *));
	setupiackvectors();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(v)
	register caddr_t v;
{

#define	valloc(name, type, num) \
	    v = (caddr_t)(((name) = (type *)v) + (num))

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

	/*
	 * Determine how many buffers to allocate.  We use 10% of the
	 * first 2MB of memory, and 5% of the rest, with a minimum of 16
	 * buffers.  We allocate 1/2 as many swap buffer headers as file
	 * i/o buffers.
	 */
	if (bufpages == 0) {
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / 10;
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) *
			    bufcachepercent / 100;
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 70% filled kvm */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 7 / 10) 
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);

	return v;
}

/*
 * Set registers on exec.
 * Clear all except sp and pc.
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	int retval[2];
{
	register struct trapframe *tf = USER_REGS(p);

	/*
	 * The syscall will ``return'' to snip; set it.
	 * argc, argv, envp are placed on the stack by copyregs.
	 * Point r2 to the stack. crt0 should extract envp from
	 * argc & argv before calling user's main.
	 */
#if 0
	/*
	 * I don't think I need to mess with fpstate on 88k because
	 * we make sure the floating point pipeline is drained in
	 * the trap handlers. Should check on this later. XXX Nivas.
	 */

	if ((fs = p->p_md.md_fpstate) != NULL) {
		/*
		 * We hold an FPU state.  If we own *the* FPU chip state
		 * we must get rid of it, and the only way to do that is
		 * to save it.  In any case, get rid of our FPU state.
		 */
		if (p == fpproc) {
			savefpstate(fs);
			fpproc = NULL;
		}
		free((void *)fs, M_SUBPROC);
		p->p_md.md_fpstate = NULL;
	}
#endif /* 0 */
	bzero((caddr_t)tf, sizeof *tf);
	
	if (cputyp == CPU_88110) {
		/* 
		 * user mode, serialize mem, interrupts enabled, 
		 * graphics unit, fp enabled 
		 */
		tf->epsr = PSR_SRM | PSR_SFD;  
	} else {
		/* 
		 * user mode, interrupts enabled, 
		 * no graphics unit, fp enabled 
		 */
		tf->epsr = PSR_SFD | PSR_SFD2;
	}

	/*
	 * We want to start executing at pack->ep_entry. The way to
	 * do this is force the processor to fetch from ep_entry. Set
	 * NIP to something bogus and invalid so that it will be a NOOP.
	 * And set sfip to ep_entry with valid bit on so that it will be
	 * fetched.  mc88110 - just set exip to pack->ep_entry.
	 */
	if (cputyp == CPU_88110) {
		tf->exip = pack->ep_entry & ~3;
		printf("exec @@ 0x%x\n", tf->exip);
	} else {
	tf->snip = pack->ep_entry & ~3;
	tf->sfip = (pack->ep_entry & ~3) | FIP_V;
	}
	tf->r[2] = stack;
	tf->r[31] = stack;
	retval[1] = 0;
}

struct sigstate {
	int   ss_flags;	     /* which of the following are valid */
	struct   trapframe ss_frame;  /* original exception frame */
};

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signo
 * thru sf_handler so... don't screw with them!
 */
struct sigframe {
	int   sf_signo;	     /* signo for handler */
	siginfo_t *sf_sip;
	struct   sigcontext *sf_scp;  /* context ptr for handler */
	sig_t sf_handler;    /* handler addr for u_sigc */
	struct   sigcontext sf_sc; /* actual context */
	siginfo_t sf_si;
};

#ifdef DEBUG
int sigdebug = 0;
int sigpid = 0;
   #define SDB_FOLLOW	0x01
   #define SDB_KSTACK	0x02
   #define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	unsigned long code;
	int type;
	union sigval val;
{
	register struct proc *p = curproc;
	register struct trapframe *tf;
	register struct sigacts *psp = p->p_sigacts;
	struct sigframe *fp;
	int oonstack, fsize;
	struct sigframe sf;
	int addr;

	tf = p->p_md.md_tf;
	oonstack = psp->ps_sigstk.ss_flags & SA_ONSTACK;
	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in data space, the
	 * call to grow() is a nop, and the copyout()
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct sigframe);
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    (psp->ps_sigstk.ss_flags & SA_ONSTACK) == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SA_ONSTACK;
	} else
		fp = (struct sigframe *)(tf->r[31] - fsize);
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)uvm_grow(p, (unsigned)fp);

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && (p->p_pid == sigpid)))
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc);
#endif
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	sf.sf_signo = sig;
	sf.sf_scp = &fp->sf_sc;
	sf.sf_handler = catcher;
	sf.sf_sc.sc_onstack = oonstack;
	sf.sf_sc.sc_mask = mask;

	if (psp->ps_siginfo & sigmask(sig)) {
		sf.sf_sip = &fp->sf_si;
		initsiginfo(&sf.sf_si, sig, code, type, val);
	}

	/*
	 * Copy the whole user context into signal context that we
	 * are building.
	 */
	bcopy((caddr_t)tf->r, (caddr_t)sf.sf_sc.sc_regs,
	      sizeof(sf.sf_sc.sc_regs));
	if (cputyp != CPU_88110) {
		/* mc88100 */
	sf.sf_sc.sc_xip = tf->sxip & ~3;
	sf.sf_sc.sc_nip = tf->snip & ~3;
	sf.sf_sc.sc_fip = tf->sfip & ~3;
	} else {
		/* mc88110 */
		sf.sf_sc.sc_xip = tf->exip & ~3;
		sf.sf_sc.sc_nip = tf->enip & ~3;
		sf.sf_sc.sc_fip = 0;
	}
	sf.sf_sc.sc_ps = tf->epsr;
	sf.sf_sc.sc_sp  = tf->r[31];
	sf.sf_sc.sc_fpsr = tf->fpsr;
	sf.sf_sc.sc_fpcr = tf->fpcr;
	if (cputyp != CPU_88110) {
		/* mc88100 */
	sf.sf_sc.sc_ssbr = tf->ssbr;
	sf.sf_sc.sc_dmt0 = tf->dmt0;
	sf.sf_sc.sc_dmd0 = tf->dmd0;
	sf.sf_sc.sc_dma0 = tf->dma0;
	sf.sf_sc.sc_dmt1 = tf->dmt1;
	sf.sf_sc.sc_dmd1 = tf->dmd1;
	sf.sf_sc.sc_dma1 = tf->dma1;
	sf.sf_sc.sc_dmt2 = tf->dmt2;
	sf.sf_sc.sc_dmd2 = tf->dmd2;
	sf.sf_sc.sc_dma2 = tf->dma2;
	} else {
		/* mc88110 */
		sf.sf_sc.sc_dsr  = tf->dsr;
		sf.sf_sc.sc_dlar = tf->dlar;
		sf.sf_sc.sc_dpar = tf->dpar;
		sf.sf_sc.sc_isr  = tf->isr;
		sf.sf_sc.sc_ilar = tf->ilar;
		sf.sf_sc.sc_ipar = tf->ipar;
		sf.sf_sc.sc_isap = tf->isap;
		sf.sf_sc.sc_dsap = tf->dsap;
		sf.sf_sc.sc_iuap = tf->iuap;
		sf.sf_sc.sc_duap = tf->duap;
	}
	sf.sf_sc.sc_fpecr = tf->fpecr;
	sf.sf_sc.sc_fphs1 = tf->fphs1;
	sf.sf_sc.sc_fpls1 = tf->fpls1;
	sf.sf_sc.sc_fphs2 = tf->fphs2;
	sf.sf_sc.sc_fpls2 = tf->fpls2;
	sf.sf_sc.sc_fppt = tf->fppt;
	sf.sf_sc.sc_fprh = tf->fprh;
	sf.sf_sc.sc_fprl = tf->fprl;
	sf.sf_sc.sc_fpit = tf->fpit;
	if (copyout((caddr_t)&sf, (caddr_t)fp, sizeof sf)) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
	/* 
	 * Build the argument list for the signal handler.
	 * Signal trampoline code is at base of user stack.
	 */
	addr = p->p_sigcode;
	if (cputyp != CPU_88110) {
		/* mc88100 */
	tf->snip = (addr & ~3) | NIP_V;
	tf->sfip = (tf->snip + 4) | FIP_V;
	} else {
		/* mc88110 */
		tf->exip = (addr & ~3);
		tf->enip = (tf->exip + 4);
	}
	tf->r[31] = (unsigned)fp;
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sendsig(%d): sig %d returns\n", p->p_pid, sig);
#endif
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */

/* ARGSUSED */
int
sys_sigreturn(p, v, retval)
struct proc *p;
void *v;
register_t *retval;
{
	struct sys_sigreturn_args /* {
	   syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	register struct sigcontext *scp;
	register struct trapframe *tf;
	struct sigcontext ksc;

	scp = (struct sigcontext *)SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
#endif
	if ((int)scp & 3 || uvm_useracc((caddr_t)scp, sizeof *scp, B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(struct sigcontext)))
		return (EINVAL);

	tf = p->p_md.md_tf;
	scp = &ksc;
	/*
	 * xip, nip and fip must be multiples of 4.  This is all
	 * that is required; if it holds, just do it.
	 */
#if 0
	if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0)
		return (EINVAL);
#endif /* 0 */
#if DIAGNOSTIC
	if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0){
		printf("xip %x nip %x fip %x\n",
		       scp->sc_xip, scp->sc_nip, scp->sc_fip);
		return (EINVAL);
	}
#endif 
	/*
	 * this can be improved by doing
	 *	 bcopy(sc_reg to tf, sizeof sigcontext - 2 words)
	 * XXX nivas
	 */
	bcopy((caddr_t)scp->sc_regs, (caddr_t)tf->r, sizeof(scp->sc_regs));
	if (cputyp != CPU_88110) {
		/* mc88100 */
	tf->sxip = (scp->sc_xip) | XIP_V;
	tf->snip = (scp->sc_nip) | NIP_V;
	tf->sfip = (scp->sc_fip) | FIP_V;
	} else {
		/* mc88110 */
		tf->exip = (scp->sc_xip);
		tf->enip = (scp->sc_nip);
		tf->sfip = 0;
	}
	tf->epsr = scp->sc_ps;
	tf->r[31] = scp->sc_sp;
	tf->fpsr = scp->sc_fpsr;
	tf->fpcr = scp->sc_fpcr;
	if (cputyp != CPU_88110) {
		/* mc88100 */
	tf->ssbr = scp->sc_ssbr;
	tf->dmt0 = scp->sc_dmt0;
	tf->dmd0 = scp->sc_dmd0;
	tf->dma0 = scp->sc_dma0;
	tf->dmt1 = scp->sc_dmt1;
	tf->dmd1 = scp->sc_dmd1;
	tf->dma1 = scp->sc_dma1;
	tf->dmt2 = scp->sc_dmt2;
	tf->dmd2 = scp->sc_dmd2;
	tf->dma2 = scp->sc_dma2;
	} else {
		/* mc88110 */
		tf->dsr  = scp->sc_dsr;
		tf->dlar = scp->sc_dlar;
		tf->dpar = scp->sc_dpar;
		tf->isr  = scp->sc_isr;
		tf->ilar = scp->sc_ilar;
		tf->ipar = scp->sc_ipar;
		tf->isap = scp->sc_isap;
		tf->dsap = scp->sc_dsap;
		tf->iuap = scp->sc_iuap;
		tf->duap = scp->sc_duap;
	}
	tf->fpecr = scp->sc_fpecr;
	tf->fphs1 = scp->sc_fphs1;
	tf->fpls1 = scp->sc_fpls1;
	tf->fphs2 = scp->sc_fphs2;
	tf->fpls2 = scp->sc_fpls2;
	tf->fppt = scp->sc_fppt;
	tf->fprh = scp->sc_fprh;
	tf->fprl = scp->sc_fprl;
	tf->fpit = scp->sc_fpit;

	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
	p->p_sigmask = scp->sc_mask & ~sigcantmask;
	return (EJUSTRETURN);
}

__dead void
_doboot()
{
	cmmu_shutdown_now();
	bugreturn();
	/*NOTREACHED*/
	for (;;);		/* appease gcc */
}

__dead void
boot(howto)
	register int howto;
{
	/* take a snap shot before clobbering any registers */
	if (curproc && curproc->p_addr)
		savectx(curpcb);

	/* If system is cold, just halt. */
	if (cold) {
		howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0) {
		vfs_shutdown();
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0)
			resettodr();
		else
			printf("WARNING: not updating battery clock\n");
	}

	/* Disable interrupts. */
	splhigh();

	/* If rebooting and a dump is requested, do it. */
	if (howto & RB_DUMP)
		dumpsys();

haltsys:
	/* Run any shutdown hooks. */
	doshutdownhooks();

	if (howto & RB_HALT) {
		printf("halted\n\n");
	} else {
		doboot();
	}

	for (;;);  /* to keep compiler happy, and me from going crazy */
	/*NOTREACHED*/
}

#ifdef MVME188
void 
m188_reset()
{
	volatile int cnt;

	*sys_syscon->ien0 = 0;
	*sys_syscon->ien1 = 0;
	*sys_syscon->ien2 = 0;
	*sys_syscon->ien3 = 0;
	*sys_syscon->glbres = 1;  /* system reset */
	*sys_syscon->ucsr |= 0x2000; /* clear SYSFAIL* */
	for (cnt = 0; cnt < 5*1024*1024; cnt++)
		;
	*sys_syscon->ucsr |= 0x2000; /* clear SYSFAIL* */
}
#endif   /* MVME188 */

unsigned dumpmag = 0x8fca0101;	 /* magic number for savecore */
int   dumpsize = 0;	/* also for savecore */
long  dumplo = 0;
cpu_kcore_hdr_t cpu_kcore_hdr;

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first PAGE_SIZE of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf()
{
	int nblks;	/* size of dump area */
	int maj;

	if (dumpdev == NODEV)
		return;
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
	if (nblks <= ctod(1))
		return;

	dumpsize = physmem;

	/* mvme88k only uses a single segment. */
	cpu_kcore_hdr.ram_segs[0].start = 0;
	cpu_kcore_hdr.ram_segs[0].size = ctob(physmem);
	cpu_kcore_hdr.cputype = cputyp;

	/*
	 * Don't dump on the first block
	 * in case the dump device includes a disk label.
	 */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize + 1 > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo) - 1;
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;
}

/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
void
dumpsys()
{
	int maj;
	int psize;
	daddr_t blkno;		/* current block to write */
				/* dump routine */
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int pg;			/* page being dumped */
	paddr_t maddr;		/* PA being dumped */
	int error;		/* error code from (*dump)() */
	kcore_seg_t *kseg_p;
	cpu_kcore_hdr_t *chdr_p;
	char dump_hdr[dbtob(1)];	/* XXX assume hdr fits in 1 block */

	extern int msgbufmapped;

	msgbufmapped = 0;

	/* Make sure dump device is valid. */
	if (dumpdev == NODEV)
		return;
	if (dumpsize == 0) {
		dumpconf();
		if (dumpsize == 0)
			return;
	}
	maj = major(dumpdev);
	if (dumplo < 0) {
		printf("\ndump to dev %u,%u not possible\n", maj,
		    minor(dumpdev));
		return;
	}
	dump = bdevsw[maj].d_dump;
	blkno = dumplo;

	printf("\ndumping to dev %u,%u offset %ld\n", maj,
	    minor(dumpdev), dumplo);

	/* Setup the dump header */
	kseg_p = (kcore_seg_t *)dump_hdr;
	chdr_p = (cpu_kcore_hdr_t *)&dump_hdr[ALIGN(sizeof(*kseg_p))];
	bzero(dump_hdr, sizeof(dump_hdr));

	CORE_SETMAGIC(*kseg_p, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg_p->c_size = dbtob(1) - ALIGN(sizeof(*kseg_p));
	*chdr_p = cpu_kcore_hdr;

	printf("dump ");
	psize = (*bdevsw[maj].d_psize)(dumpdev);
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}

	/* Dump the header. */
	error = (*dump)(dumpdev, blkno++, (caddr_t)dump_hdr, dbtob(1));
	if (error != 0)
		goto abort;

	maddr = (paddr_t)0;
	for (pg = 0; pg < dumpsize; pg++) {
#define NPGMB	(1024 * 1024 / PAGE_SIZE)
		/* print out how many MBs we have dumped */
		if (pg != 0 && (pg % NPGMB) == 0)
			printf("%d ", pg / NPGMB);
#undef NPGMB
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, maddr,
		    VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);

		error = (*dump)(dumpdev, blkno, vmmap, PAGE_SIZE);
		if (error == 0) {
			maddr += PAGE_SIZE;
			blkno += btodb(PAGE_SIZE);
		} else
			break;
	}
abort:
	switch (error) {
	case 0:
		printf("succeeded\n");
		break;
	
	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	default:
		printf("error %d\n", error);
		break;
	}
}

/*
 * fill up ivec array with interrupt response vector addresses.
 */
void
setupiackvectors()
{
	register u_char *vaddr;
#undef MAP_VEC /* Switching to new virtual addresses XXX smurph */
#ifdef MAP_VEC
	extern vm_offset_t iomap_mapin(vm_offset_t, vm_size_t,  boolean_t);
#endif
	/*
	 * map a page in for phys address 0xfffe0000 (M187) and set the
	 * addresses for various levels.
	 */
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
#ifdef MAP_VEC /* do for MVME188 too */
		vaddr = (u_char *)iomap_mapin(M187_IACK, NBPG, 1);
#else
		vaddr = (u_char *)M187_IACK;
#endif
		break;
#endif /* MVME187 */
#ifdef MVME188
	case BRD_188:
#ifdef MAP_VEC /* do for MVME188 too */
		vaddr = (u_char *)iomap_mapin(M188_IACK, NBPG, 1);
#else
		vaddr = (u_char *)M188_IACK;
#endif
		ivec[0] = vaddr;	/* We dont use level 0 */
		ivec[1] = vaddr + 0x04;
		ivec[2] = vaddr + 0x08;
		ivec[3] = vaddr + 0x0c;
		ivec[4] = vaddr + 0x10;
		ivec[5] = vaddr + 0x14;
		ivec[6] = vaddr + 0x18;
		ivec[7] = vaddr + 0x1c;
		ivec[8] = vaddr + 0x20;	/* for self inflicted interrupts */
		*ivec[8] = M188_IVEC;	/* supply a vector base for m188ih */
		break;
#endif /* MVME188 */
#ifdef MVME197
	case BRD_197:
#ifdef MAP_VEC /* do for MVME188 too */
		vaddr = (u_char *)iomap_mapin(M197_IACK, NBPG, 1);
#else
		vaddr = (u_char *)M197_IACK;
#endif
		break;
#endif /* MVME197 */
	}
#ifdef DEBUG
	printf("interrupt ACK address mapped at 0x%x\n", vaddr);
#endif 

#if defined(MVME187) || defined(MVME197)
	if (brdtyp != BRD_188) {
		ivec[0] = vaddr + 0x03;	/* We dont use level 0 */
		ivec[1] = vaddr + 0x07;
		ivec[2] = vaddr + 0x0b;
		ivec[3] = vaddr + 0x0f;
		ivec[4] = vaddr + 0x13;
		ivec[5] = vaddr + 0x17;
		ivec[6] = vaddr + 0x1b;
		ivec[7] = vaddr + 0x1f;
	}
#endif
}

/* gets an interrupt stack for slave processors */
vm_offset_t 
get_slave_stack()
{
	vm_offset_t addr = 0;
	addr = (vm_offset_t)uvm_km_zalloc(kernel_map, INTSTACK_SIZE + 4096);

	if (addr == NULL)
		panic("Cannot allocate slave stack");

	if (interrupt_stack[0] == 0)
		interrupt_stack[0] = (vm_offset_t) intstack;
	interrupt_stack[cpu_number()] = addr;
	return addr;
}

/*
 * Slave CPU pre-main routine.
 * Determine CPU number and set it.
 *
 * Running on an interrupt stack here; do nothing fancy.
 *
 * Called from "mvme88k/locore.S"
 */
void slave_pre_main()
{
   set_cpu_number(cmmu_cpu_number()); /* Determine cpu number by CMMU */
   splhigh();
   enable_interrupt();
}

/* dummy main routine for slave processors */
int
slave_main()
{
	printf("slave CPU%d started\n", cpu_number());
	while (1); /* spin forever */
	return 0;
}

/*
 * Search for the first avilable interrupt vector in the range start, end.
 * This should really only be used by VME devices.
 */
int
intr_findvec(start, end)
	int start, end;
{
	int vec;

#ifdef DIAGNOSTIC
	/* Sanity check! */
	if (start < 0 || end > 255 || start > end)
		panic("intr_findvec(): bad parameters");
#endif

	for (vec = start; vec < end; vec++){
		if (intr_handlers[vec] == NULL)
			return (vec);
	}
#ifdef DIAGNOSTIC
	printf("intr_findvec(): uh oh....\n", vec);
#endif
	return (-1);
}

/*
 * Insert ihand in the list of handlers at vector vec.
 * Return return different error codes for the different
 * errors and let the caller decide what to do.
 */
int
intr_establish(int vec, struct intrhand *ihand)
{
	register struct intrhand *intr;

	if (vec < 0 || vec > 255) {
#if DIAGNOSTIC
		panic("intr_establish: vec (0x%x) not between 0x00 and 0xff",
		      vec);
#endif /* DIAGNOSTIC */
		return (INTR_EST_BADVEC);
	}

	if ((intr = intr_handlers[vec]) != NULL) {
		if (intr->ih_ipl != ihand->ih_ipl) {
#if DIAGNOSTIC
			panic("intr_establish: there are other handlers with vec (0x%x) at ipl %x, but you want it at %x",
			      intr->ih_ipl, vec, ihand->ih_ipl);
#endif /* DIAGNOSTIC */
			return (INTR_EST_BADIPL);
		}

		/*
		 * Go to the end of the chain
		 */
		while (intr->ih_next)
			intr = intr->ih_next;
	}

	ihand->ih_next = 0;

	if (intr)
		intr->ih_next = ihand;
	else
		intr_handlers[vec] = ihand;

	return (INTR_EST_SUCC);
}

#ifdef MVME188

/*
 *	Device interrupt handler for MVME188
 *
 *      when we enter, interrupts are disabled;
 *      when we leave, they should be disabled,
 *      but they need not be disabled throughout
 *      the routine.
 */

/* Hard coded vector table for onboard devices. */

unsigned obio_vec[32] = {
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
        0,SYSCV_SCC,0,0,SYSCV_SYSF,SYSCV_TIMER2,0,0,
	0,0,0,0,SYSCV_TIMER1,0,SYSCV_ACF,SYSCV_ABRT, 
};

#define GET_MASK(cpu, val)	*int_mask_reg[cpu] & (val)
#define VME_VECTOR_MASK		0x1ff 		/* mask into VIACK register */
#define VME_BERR_MASK		0x100 		/* timeout during VME IACK cycle */

void 
m188_ext_int(u_int v, struct m88100_saved_state *eframe)
{
	register int cpu = cpu_number();
	register unsigned int cur_mask;
	register unsigned int level, old_spl;
	register struct intrhand *intr;
	int ret, intbit;
	unsigned vec;

	cur_mask = ISR_GET_CURRENT_MASK(cpu);
	old_spl = m188_curspl[cpu];
	eframe->mask = old_spl;

	if (cur_mask == 0) {
		/*
		 * Spurious interrupts - may be caused by debug output clearing
		 * DUART interrupts.
		 */
		flush_pipeline();
		return;
	}

	uvmexp.intrs++;

	/* 
	 * We want to service all interrupts marked in the IST register
	 * They are all valid because the mask would have prevented them
	 * from being generated otherwise.  We will service them in order of
	 * priority. 
	 */
	do {
		level = safe_level(cur_mask, old_spl);

		if (old_spl >= level) {
			register int i;

			printf("safe level %d <= old level %d\n", level, old_spl);
			printf("cur_mask = 0x%b\n", cur_mask, IST_STRING);
			for (i = 0; i < 4; i++)
				printf("IEN%d = 0x%b  ", i, *int_mask_reg[i], IST_STRING);
			printf("\nCPU0 spl %d  CPU1 spl %d  CPU2 spl %d  CPU3 spl %d\n",
			       m188_curspl[0], m188_curspl[1],
			       m188_curspl[2], m188_curspl[3]);
			for (i = 0; i < 8; i++)
				printf("int_mask[%d] = 0x%08x\n", i, int_mask_val[i]);
			printf("--CPU %d halted--\n", cpu_number());
			spl7();
			for(;;) ;
		}

		if (level > 7 || (char)level < 0) {
			panic("int level (%x) is not between 0 and 7", level);
		}

		setipl(level);
	  
		enable_interrupt();
		
		/* generate IACK and get the vector */

		/* 
		 * This is tricky.  If you don't catch all the 
		 * interrupts, you die. Game over. Insert coin... 
		 * XXX smurph
		 */

		/* find the first bit set in the current mask */
		intbit = ff1(cur_mask);
		if (OBIO_INTERRUPT_MASK & (1 << intbit)) {
			if (guarded_access(ivec[level], 4, (u_char *)&vec) ==
			    EFAULT) {
				panic("unable to get vector for this vmebus "
				    "interrupt (level %x)", level);
			}
			vec = obio_vec[intbit];
			if (vec == 0) {
				panic("unknown onboard interrupt: mask = 0x%b",
				    1 << intbit, IST_STRING);
			}
		} else if (HW_FAILURE_MASK & (1 << intbit)) {
			vec = obio_vec[intbit];
			if (vec == 0) {
				panic("unknown hardware failure: mask = 0x%b",
				    1 << intbit, IST_STRING);
			}
		} else if (VME_INTERRUPT_MASK & (1 << intbit)) {
			if (guarded_access(ivec[level], 4, (u_char *)&vec) ==
			    EFAULT) {
				panic("unable to get vector for this vmebus "
				    "interrupt (level %x)", level);
			}
			vec &= VME_VECTOR_MASK;
			if (vec & VME_BERR_MASK) {
				panic("vme vec timeout");
			}
			if (vec == 0) {
				panic("unknown vme interrupt: mask = 0x%b",
				    1 << intbit, IST_STRING);
			}
		} else {
			panic("unknown interrupt: level = %d intbit = 0x%x "
			    "mask = 0x%b",
			    level, intbit, 1 << intbit, IST_STRING);
		}
		if (vec > 0xFF) {
			panic("interrupt vector 0x%x greater than 255!"
			    "level = %d iack = 0x%x", 
			    vec, level, ivec[level]);
		}

		if ((intr = intr_handlers[vec]) == NULL) {
			/* increment intr counter */
			intrcnt[M88K_SPUR_IRQ]++; 
			printf("Spurious interrupt: level = %d vec = 0x%x, "
			    "intbit = %d mask = 0x%b\n",
			    level, vec, intbit, 1 << intbit, IST_STRING);
		} else {
			/*
			 * Walk through all interrupt handlers in the chain
			 * for the given vector, calling each handler in turn,
			 * till some handler returns a value != 0.
			 */
			for (ret = 0; intr; intr = intr->ih_next) {
				if (intr->ih_wantframe != 0)
					ret = (*intr->ih_fn)((void *)eframe);
				else
					ret = (*intr->ih_fn)(intr->ih_arg);
				if (ret != 0) {
					/* increment intr counter */
					intrcnt[level]++; 
					break;
				}
			}
			if (ret == 0) {
				printf("Unclaimed interrupt: level = %d "
				    "vec = 0x%x, intbit = %d mask = 0x%b\n",
				    level, vec, intbit,
				    1 << intbit, IST_STRING);
				break;
			}
		}
	} while ((cur_mask = ISR_GET_CURRENT_MASK(cpu)) != 0);

	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	disable_interrupt();
	if (eframe->dmt0 & DMT_VALID) {
		m88100_trap(T_DATAFLT, eframe);
		data_access_emulation((unsigned *)eframe);
		eframe->dmt0 &= ~DMT_VALID;
	}

	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl(eframe->mask);
	flush_pipeline();
}

#endif /* MVME188 */

/*
 *	Device interrupt handler for MVME1x7
 *
 *      when we enter, interrupts are disabled;
 *      when we leave, they should be disabled,
 *      but they need not be disabled throughout
 *      the routine.
 */

#ifdef MVME187
void
m187_ext_int(u_int v, struct m88100_saved_state *eframe)
{
	register u_char mask, level;
	register struct intrhand *intr;
	int ret;
	u_char vec;

	/* get level and mask */
	mask = *md.intr_mask & 0x07;
	level = *md.intr_ipl & 0x07;

	/*
	 * It is really bizarre for the mask and level to the be the same.
	 * pcc2 for 187 blocks all interrupts at and below the mask value,
	 * so we should not be getting an interrupt at the level that is
	 * already blocked. I can't explain this case XXX nivas
	 */

	if ((mask == level) && level) {
		panic("mask == level, %d", level);
	}

	/*
	 * Interrupting level cannot be 0--0 doesn't produce an interrupt.
	 * Weird! XXX nivas
	 */

	if (level == 0) {
		panic("Bogons... level %x and mask %x", level, mask);
	}

	/* and block interrupts at level or lower */
	setipl(level);
	/* and stash it away in the trap frame */
	eframe->mask = mask;

	uvmexp.intrs++;

	/* generate IACK and get the vector */
	flush_pipeline();
	if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
		panic("Unable to get vector for this interrupt (level %x)", level);
	}
	flush_pipeline();
	flush_pipeline();
	flush_pipeline();

	if (vec > 0xff) {
		panic("interrupt vector %x greater than 255", vec);
	}

	enable_interrupt();

	if ((intr = intr_handlers[vec]) == NULL) {
		/* increment intr counter */
		intrcnt[M88K_SPUR_IRQ]++; 
		printf("Spurious interrupt (level %x and vec %x)\n",
		       level, vec);
	} else {
		if (intr && intr->ih_ipl != level) {
			panic("Handler ipl %x not the same as level %x. "
			    "vec = 0x%x",
			    intr->ih_ipl, level, vec);
		}

		/*
		 * Walk through all interrupt handlers in the chain for the
		 * given vector, calling each handler in turn, till some handler
		 * returns a value != 0.
		 */

		for (ret = 0; intr; intr = intr->ih_next) {
			if (intr->ih_wantframe != 0)
				ret = (*intr->ih_fn)((void *)eframe);
			else
				ret = (*intr->ih_fn)(intr->ih_arg);
			if (ret != 0) {
				/* increment intr counter */
				intrcnt[level]++; 
				break;
			}
		}

		if (ret == 0) {
			printf("Unclaimed interrupt (level %x and vec %x)\n",
			    level, vec);
		}
	}

	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	disable_interrupt();

	if (eframe->dmt0 & DMT_VALID) {
		m88100_trap(T_DATAFLT, eframe);
		data_access_emulation((unsigned *)eframe);
		eframe->dmt0 &= ~DMT_VALID;
	}

	mask = eframe->mask;

	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl(mask);
}
#endif /* MVME187 */

#ifdef MVME197
void
m197_ext_int(u_int v, struct m88100_saved_state *eframe)
{
	register u_char mask, level, src;
	register struct intrhand *intr;
	int ret;
	u_char vec;

	/* get src and mask */
	mask = *md.intr_mask & 0x07;
	src = *md.intr_src;
	
	if (v == T_NON_MASK) {
		/* This is the abort switch */
		level = IPL_NMI;
		vec = BS_ABORTVEC;
	} else {
		/* get level  */
		level = *md.intr_ipl & 0x07;
	}

	/*
	 * Interrupting level cannot be 0--0 doesn't produce an interrupt.
	 * Weird! XXX nivas
	 */

	if (level == 0) {
		panic("Bogons... level %x and mask %x", level, mask);
	}

	/* and block interrupts at level or lower */
	setipl(level);
	/* and stash it away in the trap frame */
	eframe->mask = mask;

	uvmexp.intrs++;

	if (v != T_NON_MASK) {
		/* generate IACK and get the vector */
		flush_pipeline();
		if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
			panic("Unable to get vector for this interrupt (level %x)", level);
		}
		flush_pipeline();
		flush_pipeline();
		flush_pipeline();
	}

	if (vec > 0xff) {
		panic("interrupt vector %x greater than 255", vec);
	}

	enable_interrupt();

	if ((intr = intr_handlers[vec]) == NULL) {
		/* increment intr counter */
		intrcnt[M88K_SPUR_IRQ]++; 
		printf("Spurious interrupt (level %x and vec %x)\n",
		       level, vec);
	} else {
		if (intr && intr->ih_ipl != level) {
			panic("Handler ipl %x not the same as level %x. "
			    "vec = 0x%x",
			    intr->ih_ipl, level, vec);
		}

		/*
		 * Walk through all interrupt handlers in the chain for the
		 * given vector, calling each handler in turn, till some handler
		 * returns a value != 0.
		 */
		for (ret = 0; intr; intr = intr->ih_next) {
			if (intr->ih_wantframe != 0)
				ret = (*intr->ih_fn)((void *)eframe);
			else
				ret = (*intr->ih_fn)(intr->ih_arg);
			if (ret != 0) {
				/* increment intr counter */
				intrcnt[level]++; 
				break;
			}
		}

		if (ret == 0) {
			printf("Unclaimed interrupt (level %x and vec %x)\n",
			    level, vec);
		}
	}

	disable_interrupt();

	mask = eframe->mask;

	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl(mask);
}
#endif 

int
cpu_exec_aout_makecmds(p, epp)
struct proc *p;
struct exec_package *epp;
{
#ifdef COMPAT_25
	/*
	 * Keep compatibility with older OpenBSD/mvme88k binaries
	 * for a while, to make transition easier.
	 */
	u_long midmag, magic;
	u_short mid;
	struct exec *execp = epp->ep_hdr;

	midmag = ntohl(execp->a_midmag);
	mid = (midmag >> 16) & 0x3ff;
	magic = midmag & 0xffff;

	midmag = mid << 16 | magic;

	switch (midmag) {
	case (OLD_MID_MACHINE << 16) | ZMAGIC:
		return exec_aout_prep_zmagic(p, epp);
	case (OLD_MID_MACHINE << 16) | NMAGIC:
		return exec_aout_prep_nmagic(p, epp);
	case (OLD_MID_MACHINE << 16) | OMAGIC:
		return exec_aout_prep_omagic(p, epp);
	}
#endif

	return ENOEXEC;
}

int
sys_sysarch(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#if 0
	struct sys_sysarch_args	/* {
	   syscallarg(int) op;
	   syscallarg(char *) parm;
	} */ *uap = v;
#endif

	return (ENOSYS);
}

/*
 * machine dependent system variables.
 */

int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	dev_t consdev;

	/* all sysctl names are this level are terminal */
	if (namelen != 1)
		return (ENOTDIR); /* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	default:
		return (EOPNOTSUPP);
	}
	/*NOTREACHED*/
}

/*
 * insert an element into a queue 
 */

void
_insque(velement, vhead)
	void *velement, *vhead;
{
	register struct prochd *element, *head;
	element = velement;
	head = vhead;
	element->ph_link = head->ph_link;
	head->ph_link = (struct proc *)element;
	element->ph_rlink = (struct proc *)head;
	((struct prochd *)(element->ph_link))->ph_rlink=(struct proc *)element;
}

/*
 * remove an element from a queue
 */

void
_remque(velement)
	void *velement;
{
	register struct prochd *element;
	element = velement;
	((struct prochd *)(element->ph_link))->ph_rlink = element->ph_rlink;
	((struct prochd *)(element->ph_rlink))->ph_link = element->ph_link;
	element->ph_rlink = (struct proc *)0;
}

int
copystr(fromaddr, toaddr, maxlength, lencopied)
	const void *fromaddr;
	void *toaddr;
	size_t maxlength;
	size_t *lencopied;
{
	u_int tally;

	tally = 0;

	while (maxlength--) {
		*(u_char *)toaddr = *(u_char *)fromaddr++;
		tally++;
		if (*(u_char *)toaddr++ == 0) {
			if (lencopied) *lencopied = tally;
			return (0);
		}
	}

	if (lencopied)
		*lencopied = tally;

	return (ENAMETOOLONG);
}

void
setrunqueue(p)
	register struct proc *p;
{
	register struct prochd *q;
	register struct proc *oldlast;
	register int which = p->p_priority >> 2;

	if (p->p_back != NULL)
		panic("setrunqueue %x", p);
	q = &qs[which];
	whichqs |= 1 << which;
	p->p_forw = (struct proc *)q;
	p->p_back = oldlast = q->ph_rlink;
	q->ph_rlink = p;
	oldlast->p_forw = p;
}

/*
 * Remove process p from its run queue, which should be the one
 * indicated by its priority.  Calls should be made at splstatclock().
 */
void
remrunqueue(vp)
	struct proc *vp;
{
	register struct proc *p = vp;
	register int which = p->p_priority >> 2;
	register struct prochd *q;

	if ((whichqs & (1 << which)) == 0)
		panic("remrq %x", p);
	p->p_forw->p_back = p->p_back;
	p->p_back->p_forw = p->p_forw;
	p->p_back = NULL;
	q = &qs[which];
	if (q->ph_link == (struct proc *)q)
		whichqs &= ~(1 << which);
}

/* dummys for now */

void
bugsyscall()
{
}

void
myetheraddr(cp)
	u_char *cp;
{
	struct mvmeprom_brdid brdid;

	bugbrdid(&brdid);
	bcopy(&brdid.etheraddr, cp, 6);
}

void
dosoftint()
{
	if (ssir & SIR_NET) {
		siroff(SIR_NET);
		uvmexp.softs++;
#define DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << bit)) { \
			netisr &= ~(1 << bit); \
			fn(); \
		} \
	} while (0)
#include <net/netisr_dispatch.h>
#undef DONETISR
	}

	if (ssir & SIR_CLOCK) {
		siroff(SIR_CLOCK);
		uvmexp.softs++;
		softclock();
	}
}

int
spl0()
{
	int x;
	x = splsoftclock();

	if (ssir) {
		dosoftint();
	}

	setipl(0);

	return (x);
}

#ifdef EH_DEBUG

void
MY_info(f, p, flags, s)
struct trapframe  *f;
caddr_t     p;
int         flags;
char        *s;
{
	regdump(f);
	printf("proc %x flags %x type %s\n", p, flags, s);
}  

void
MY_info_done(f, flags)
	struct trapframe  *f;
	int         flags;
{
	regdump(f);
} 

#endif

void
nmihand(void *framep)
{
#if 0
	struct m88100_saved_state *frame = framep;
#endif

#if DDB
	DEBUG_MSG("Abort Pressed\n");
	Debugger();
#else
	DEBUG_MSG("Spurious NMI?\n");
#endif /* DDB */
}

void
regdump(struct trapframe *f)
{
#define R(i) f->r[i]
	printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(0),R(1),R(2),R(3),R(4),R(5));
	printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(6),R(7),R(8),R(9),R(10),R(11));
	printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(12),R(13),R(14),R(15),R(16),R(17));
	printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(18),R(19),R(20),R(21),R(22),R(23));
	printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(24),R(25),R(26),R(27),R(28),R(29));
	printf("R30-31: 0x%08x  0x%08x\n",R(30),R(31));
	if (cputyp == CPU_88110) {
		printf("exip %x enip %x\n", f->exip, f->enip);
	} else {
		printf("sxip %x snip %x sfip %x\n", f->sxip, f->snip, f->sfip);
	}
#ifdef M88100
	if (f->vector == 0x3 && cputyp != CPU_88110) {
		/* print dmt stuff for data access fault */
		printf("dmt0 %x dmd0 %x dma0 %x\n", f->dmt0, f->dmd0, f->dma0);
		printf("dmt1 %x dmd1 %x dma1 %x\n", f->dmt1, f->dmd1, f->dma1);
		printf("dmt2 %x dmd2 %x dma2 %x\n", f->dmt2, f->dmd2, f->dma2);
		printf("fault type %d\n", (f->dpfsr >> 16) & 0x7);
		dae_print((unsigned *)f);
	}
	if (longformat && cputyp != CPU_88110) {
		printf("fpsr %x fpcr %x epsr %x ssbr %x\n", 
		       f->fpsr, f->fpcr, f->epsr, f->ssbr);
		printf("fpecr %x fphs1 %x fpls1 %x fphs2 %x fpls2 %x\n", 
		       f->fpecr, f->fphs1, f->fpls1, f->fphs2, f->fpls2);
		printf("fppt %x fprh %x fprl %x fpit %x\n", 
		       f->fppt, f->fprh, f->fprl, f->fpit);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n", 
		       f->vector, f->mask, f->mode, f->scratch1, f->cpu);
	}
#endif 
#ifdef M88110
	if (longformat && cputyp == CPU_88110) {
		printf("fpsr %x fpcr %x fpecr %x epsr %x\n", 
		       f->fpsr, f->fpcr, f->fpecr, f->epsr);
		printf("dsap %x duap %x dsr %x dlar %x dpar %x\n",
		       f->dsap, f->duap, f->dsr, f->dlar, f->dpar);
		printf("isap %x iuap %x isr %x ilar %x ipar %x\n",
		       f->isap, f->iuap, f->isr, f->ilar, f->ipar);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n", 
		       f->vector, f->mask, f->mode, f->scratch1, f->cpu);
	}
#endif
#ifdef MVME188
	if (brdtyp == BRD_188 ) {
		unsigned int istr, cur_mask;

		istr = *(int *volatile)IST_REG;
		cur_mask = GET_MASK(0, istr);
		printf("emask = 0x%b\n", f->mask, IST_STRING);
		printf("istr  = 0x%b\n", istr, IST_STRING);
		printf("cmask = 0x%b\n", cur_mask, IST_STRING);
	}
#endif 
}

/*
 * Called from locore.S during boot,
 * this is the first C code that's run.
 */

void
mvme_bootstrap()
{
	extern int kernelstart;
	extern struct consdev *cn_tab;
	extern void set_tcfp(void);

	struct mvmeprom_brdid brdid;
	
	/*
	 * Must initialize p_addr before autoconfig or
	 * the fault handler will get a NULL reference.
	 * Do this early so that we can take a data or 
	 * instruction fault and survive it. XXX smurph
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;

	/* zreo out the machine dependant function pointers */
	bzero(&md, sizeof(struct md_p));

	buginit(); /* init the bug routines */
	bugbrdid(&brdid);
	brdtyp = brdid.model;

	/* to support the M8120.  It's based off of MVME187 */
	if (brdtyp == BRD_8120)
		brdtyp = BRD_187;

	/* 
	 * set up interrupt and fp exception handlers 
	 * based on the machine.
	 */
	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		cmmu = &cmmu8820x;
		md.interrupt_func = &m188_ext_int;
		md.intr_mask = NULL;
		md.intr_ipl = NULL;
		md.intr_src = NULL;
		/* clear and disable all interrupts */
		*int_mask_reg[0] = 0;
		*int_mask_reg[1] = 0;
		*int_mask_reg[2] = 0;
		*int_mask_reg[3] = 0;
		break;
#endif /* MVME188 */
#ifdef MVME187
	case BRD_187:
		cmmu = &cmmu8820x;
		md.interrupt_func = &m187_ext_int;
		md.intr_mask = (u_char *)M187_IMASK;
		md.intr_ipl = (u_char *)M187_ILEVEL;
		md.intr_src = NULL;
		break;
#endif /* MVME187 */
#ifdef MVME197
	case BRD_197:
		cmmu = &cmmu88110;
		md.interrupt_func = &m197_ext_int;
		md.intr_mask = (u_char *)M197_IMASK;
		md.intr_ipl = (u_char *)M197_ILEVEL;
		md.intr_src = (u_char *)M197_ISRC;
		set_tcfp(); /* Set Time Critical Floating Point Mode */
		break;
#endif /* MVME197 */
	default:
		panic("mvme_bootstrap: Can't determine cpu type.");
	}

	/* startup fake console driver.  It will be replaced by consinit() */
	cn_tab = &bootcons;

	uvmexp.pagesize = NBPG;
	uvm_setpagesize();
	first_addr = round_page(first_addr);

	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
		last_addr = memsize187();
		break;
#endif
#ifdef MVME188
	case BRD_188:
#endif
#ifdef MVME197
	case BRD_197:
#endif
		last_addr = size_memory();
		break;
	}
	physmem = btoc(last_addr);

	cmmu_parity_enable();

	setup_board_config();
	cmmu_init();
	master_cpu = cmmu_cpu_number();
	set_cpu_number(master_cpu);
	printf("CPU%d is master CPU\n", master_cpu);

#ifdef notevenclose
	if (brdtyp == BRD_188 && (boothowto & RB_MINIROOT)) {
		int i;
		for (i=0; i<MAX_CPUS; i++) {
			if (!spin_cpu(i))
				printf("CPU%d started\n", i);
		}
	}
#endif 
	avail_start = first_addr;
	avail_end = last_addr;
	/*
	 * Steal MSGBUFSIZE at the top of physical memory for msgbuf
	 */
	avail_end -= round_page(MSGBUFSIZE);

#ifdef DEBUG
	printf("MVME%x boot: memory from 0x%x to 0x%x\n", brdtyp, avail_start, avail_end);
#endif 
	pmap_bootstrap((vm_offset_t)trunc_page((unsigned)&kernelstart) /* = loadpt */, 
		       &avail_start, &avail_end, &virtual_avail,
		       &virtual_end);
	/*
	 * Tell the VM system about available physical memory.  
	 * mvme88k only has one segment.
	 */
	uvm_page_physload(atop(avail_start), atop(avail_end),
			  atop(avail_start), atop(avail_end),VM_FREELIST_DEFAULT);

	/* Initialize cached PTEs for u-area mapping. */
	save_u_area(&proc0, (vm_offset_t)proc0paddr);

	/*
	 * Map proc0's u-area at the standard address (UADDR).
	 */
	load_u_area(&proc0);

	/* Initialize the "u-area" pages. */
	bzero((caddr_t)UADDR, UPAGES*NBPG);
#ifdef DEBUG
	printf("leaving mvme_bootstrap()\n");
#endif 
}

/*
 * Boot console routines: 
 * Enables printing of boot messages before consinit().
 */
void
bootcnprobe(cp)
	struct consdev *cp;
{
	cp->cn_dev = makedev(14, 0);
	cp->cn_pri = CN_NORMAL;
}

void
bootcninit(cp)
	struct consdev *cp;
{
	/* Nothing to do */
}

int
bootcngetc(dev)
	dev_t dev;
{
	return (buginchr());
}

void
bootcnputc(dev, c)
	dev_t dev;
	int c;
{
	if ((char)c == '\n')
		bugoutchr('\r');
	bugoutchr((char)c);
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.101 2003/05/11 19:41:11 deraadt Exp $	*/
d421 1
a421 2
	snprintf(cpu_model, sizeof cpu_model,
	    "Motorola MVME%x, %dMHz", brdtyp, cpuspeed);
@


1.1.1.3
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.104 2003/08/07 17:23:43 miod Exp $	*/
d101 1
d835 2
a836 2
		tf->snip = pack->ep_entry & ~3;
		tf->sfip = (pack->ep_entry & ~3) | FIP_V;
d889 1
a889 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d899 1
a899 1
	    (psp->ps_sigstk.ss_flags & SS_ONSTACK) == 0 &&
d903 1
a903 1
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d937 3
a939 3
		sf.sf_sc.sc_xip = tf->sxip & ~3;
		sf.sf_sc.sc_nip = tf->snip & ~3;
		sf.sf_sc.sc_fip = tf->sfip & ~3;
d952 10
a961 10
		sf.sf_sc.sc_ssbr = tf->ssbr;
		sf.sf_sc.sc_dmt0 = tf->dmt0;
		sf.sf_sc.sc_dmd0 = tf->dmd0;
		sf.sf_sc.sc_dma0 = tf->dma0;
		sf.sf_sc.sc_dmt1 = tf->dmt1;
		sf.sf_sc.sc_dmd1 = tf->dmd1;
		sf.sf_sc.sc_dma1 = tf->dma1;
		sf.sf_sc.sc_dmt2 = tf->dmt2;
		sf.sf_sc.sc_dmd2 = tf->dmd2;
		sf.sf_sc.sc_dma2 = tf->dma2;
d1004 2
a1005 2
		tf->snip = (addr & ~3) | NIP_V;
		tf->sfip = (tf->snip + 4) | FIP_V;
d1033 3
a1035 3
	struct proc *p;
	void *v;
	register_t *retval;
d1049 1
a1049 1
	if ((int)scp & 3 ||
d1078 3
a1080 3
		tf->sxip = (scp->sc_xip) | XIP_V;
		tf->snip = (scp->sc_nip) | NIP_V;
		tf->sfip = (scp->sc_fip) | FIP_V;
d1093 10
a1102 10
		tf->ssbr = scp->sc_ssbr;
		tf->dmt0 = scp->sc_dmt0;
		tf->dmd0 = scp->sc_dmd0;
		tf->dma0 = scp->sc_dma0;
		tf->dmt1 = scp->sc_dmt1;
		tf->dmd1 = scp->sc_dmd1;
		tf->dma1 = scp->sc_dma1;
		tf->dmt2 = scp->sc_dmt2;
		tf->dmd2 = scp->sc_dmd2;
		tf->dma2 = scp->sc_dma2;
d1130 1
a1130 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d1132 1
a1132 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
d1473 1
a1473 2
void
slave_pre_main()
d1974 2
a1975 2
	struct proc *p;
	struct exec_package *epp;
d2213 4
a2216 4
	struct trapframe  *f;
	caddr_t     p;
	int         flags;
	char        *s;
a2401 1
#if defined(MVME188) || defined(MVME197)
a2408 3
		break;
#endif
	default:
@


1.1.1.4
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.105 2003/08/11 20:45:17 miod Exp $	*/
d122 2
d1149 1
a1149 1
	/* take a snapshot before clobbering any registers */
d2336 1
a2336 1
	/* zero out the machine dependant function pointers */
@


1.1.1.5
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.113 2003/09/20 13:57:37 miod Exp $	*/
d116 1
a116 1
vm_offset_t interrupt_stack[MAX_CPUS];
d129 1
a162 3
#if defined(MVME187) || defined(MVME197)
volatile vm_offset_t obiova;
#ifdef MVME187
d165 1
a165 5
#endif
#ifdef MVME197
volatile vm_offset_t flashva;
#endif
#endif
d246 2
a247 2
int cpumod;	/* set in mvme_bootstrap() */
int cpuspeed;
d270 1
a270 1
struct consdev bootcons = {
a385 1

d387 5
a391 8

	for (i = 0; i < 4; i++) {
		c = (unsigned char)brdid.speed[i];
		if (c == ' ')
			c = '0';
		else if (c > '9' || c < '0')
			goto fail;
		speed = speed * 10 + (c - '0');
d395 1
d397 15
a411 9
fail:
	/*
	 * If we end up here, the board information block is
	 * damaged and we can't trust it.
	 * Suppose we are running at 25MHz and hope for the best.
	 */
	printf("WARNING: Board Configuration Data invalid, "
	    "replace NVRAM and restore values\n");
	return (25);
d420 1
d499 1
a499 1
		pmap_kenter_pa((vm_offset_t)msgbufp + i * NBPG,
d527 8
a534 5
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	        UVM_ADV_NORMAL, 0));
	if (uarea_pages != UADDR)
		panic("uarea_pages %x: UADDR not free\n", uarea_pages);
d547 9
a555 28
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (sramva != SRAM_START)
			panic("sramva %x: SRAM not free\n", sramva);

		/*
		 * Grab the BUGROM space that we hardwired in pmap_bootstrap
		 */
		bugromva = BUG187_START;
		uvm_map(kernel_map, (vaddr_t *)&bugromva, BUG187_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (bugromva != BUG187_START)
			panic("bugromva %x: BUGROM not free\n", bugromva);
		
		/*
		 * Grab the OBIO space that we hardwired in pmap_bootstrap
		 */
		obiova = OBIO_START;
		uvm_map(kernel_map, (vaddr_t *)&obiova, OBIO_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (obiova != OBIO_START)
			panic("obiova %x: OBIO not free\n", obiova);
		break;
d559 2
d562 1
a562 1
		 * Grab the FLASH space that we hardwired in pmap_bootstrap
d564 11
a574 7
		flashva = FLASH_START;
		uvm_map(kernel_map, (vaddr_t *)&flashva, FLASH_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (flashva != FLASH_START)
			panic("flashva %x: FLASH not free\n", flashva);
d581 8
a588 5
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (obiova != OBIO_START)
			panic("obiova %x: OBIO not free\n", obiova);
d598 8
a605 5
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (utilva != MVME188_UTILITY)
			panic("utilva %x: UTILITY area not free\n", utilva);
d616 3
a618 2
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
	      UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
d661 1
a661 1
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d667 1
a667 1
	    VM_PHYS_SIZE, 0, FALSE, NULL);
d673 1
a673 1
	    IOMAP_SIZE, 0, FALSE, NULL);
a812 4
		/*
		 * XXX disable OoO for now...
		 */
		tf->epsr |= PSR_SER;
a829 1
#ifdef DEBUG
a830 1
#endif
d1450 2
a1451 3
	vm_offset_t addr;

	addr = (vm_offset_t)uvm_km_zalloc(kernel_map, INTSTACK_SIZE);
d1454 1
a1454 2
		panic("Cannot allocate slave stack for cpu %d",
		    cpu_number());
d1456 2
d1730 1
a1730 1
	if (eframe->dmt0 & DMT_VALID)
d1732 3
d1759 2
a1760 2
	int mask, level;
	struct intrhand *intr;
d1804 4
d1829 1
a1829 1
			if (intr->ih_wantframe != 0) {
d1831 1
a1831 1
			} else
d1851 2
a1852 1
	if (eframe->dmt0 & DMT_VALID)
d1854 5
d1864 1
a1864 1
	setipl(eframe->mask);
d1872 2
a1873 2
	int mask, level, src;
	struct intrhand *intr;
d1917 4
d1960 2
d1966 1
a1966 1
	setipl(eframe->mask);
d2298 1
a2298 1
	if (brdtyp == BRD_188) {
d2342 1
a2342 1
	if (brdtyp == BRD_8120) {
a2343 2
		/* XXX Need to flag the 8120 has a second cl(4) device on-board */
	}
d2421 1
d2423 2
a2424 9
	/*
	 * If we have more than one CPU, mention which one is the master.
	 * We will also want to spin up slave CPUs on the long run...
	 */
	switch (brdtyp) {
	case BRD_188:
		printf("CPU%d is master CPU\n", master_cpu);

#if 0
d2426 1
a2426 1
		for (i = 0; i < MAX_CPUS; i++) {
d2430 1
a2431 10
		break;
	case BRD_197:
		/*
		 * In the 197DP case, mention which CPU is the master
		 * there too...
		 * XXX TBD
		 */
		break;
	}

@


1.1.1.6
log
@Import OpenBSD source tree again, with critical bug fixes
(OpenSSL, bc, dc, sensorsd, pf, ...)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.114 2003/09/28 22:13:45 miod Exp $	*/
d377 4
d1595 4
a1598 4
	int cpu = cpu_number();
	unsigned int cur_mask;
	unsigned int level, old_spl;
	struct intrhand *intr;
d1612 1
a1612 1
		goto out;
a1642 1
#ifdef DEBUG
a1645 1
#endif
d1649 1
a1649 9
		/*
		 * Do not enable interrupts yet if we know, from cur_mask,
		 * that we have not cleared enough conditions yet.
		 * For now, only the timer interrupt requires its condition
		 * to be cleared before interrupts are enabled.
		 */
		if ((cur_mask & DTI_BIT) == 0) {
			enable_interrupt();
		}
d1662 5
d1686 1
a1686 2
				printf("vme vec timeout");
				break;
d1697 5
a1740 1
out:
d1749 1
@


1.1.1.7
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.122 2003/12/19 22:30:18 miod Exp $	*/
d91 1
a91 1
#endif
d116 1
a116 1
vaddr_t interrupt_stack[MAX_CPUS];
d118 1
a118 1
/* machine dependent function pointers. */
d126 2
a127 2
vaddr_t size_memory(void);
vaddr_t memsize187(void);
d130 1
a130 1
void save_u_area(struct proc *, vaddr_t);
d160 1
a160 1
#endif
d163 1
a163 1
volatile vaddr_t obiova;
d165 2
a166 2
volatile vaddr_t bugromva;
volatile vaddr_t sramva;
d169 1
a169 1
volatile vaddr_t flashva;
d173 1
a173 1
volatile vaddr_t utilva;
d255 2
a256 2
vaddr_t first_addr;
vaddr_t last_addr;
d258 2
a259 2
vaddr_t avail_start, avail_end;
vaddr_t virtual_avail, virtual_end;
d261 1
a261 1
extern struct pcb *curpcb;
d264 2
a265 2
/*
 *  XXX this is to fake out the console routines, while
d268 6
a273 1
cons_decl(boot);
d277 3
a279 3
	NULL,
	NULL,
	bootcngetc,
d316 1
a316 1
vaddr_t
d320 1
a320 1
	vaddr_t x;
d322 1
a322 1
	memc = (struct memcreg *)MEM_CTLR;
d325 2
a326 2
	memc = (struct memcreg *)(MEM_CTLR + 0x100);
	if (!badaddr((vaddr_t)&memc->memc_memconf, 1))
d339 1
a339 1
vaddr_t
d377 1
a377 1

d426 1
a426 1
save_u_area(struct proc *p, vaddr_t va)
d428 3
a430 5
	int i;

	for (i = 0; i < UPAGES; i++) {
		p->p_md.md_upte[i] = *((pt_entry_t *)kvtopte(va));
		va += NBPG;
a436 2
	int i;
	vaddr_t va;
d439 3
a441 2
	for (i = 0, va = UADDR; i < UPAGES; i++) {
		t = kvtopte(va);
a442 1
		va += NBPG;
d444 3
a446 1
	cmmu_flush_tlb(1, va, USPACE);
d453 1
a453 1
void
d456 3
d460 3
d466 3
d471 3
d479 1
a479 1
	/* function stub */
d488 1
a488 1
	vsize_t size;
d497 2
a498 2
		pmap_kenter_pa((paddr_t)msgbufp + i * NBPG,
		    avail_end + i * NBPG, VM_PROT_READ | VM_PROT_WRITE);
d529 4
a532 4
		panic("uarea_pages %lx: UADDR not free", uarea_pages);

	/*
	 * Grab machine dependent memory spaces
d546 1
a546 1
			panic("sramva %lx: SRAM not free", sramva);
d557 2
a558 2
			panic("bugromva %lx: BUGROM not free", bugromva);

d568 1
a568 1
			panic("obiova %lx: OBIO not free", obiova);
d570 1
a570 1
#endif
d582 2
a583 2
			panic("flashva %lx: FLASH not free", flashva);

d593 1
a593 1
			panic("obiova %lx: OBIO not free", obiova);
d595 1
a595 1
#endif
d607 1
a607 1
			panic("utilva %lx: UTILITY area not free", utilva);
d641 1
a641 1
		curbuf = (vaddr_t)buffers + (i * MAXBSIZE);
d650 1
a650 1
			    VM_PROT_READ | VM_PROT_WRITE);
d663 1
a663 1

d670 1
a670 1
	/*
d681 1
a681 1
	printf("avail mem = %ld (%d pages)\n", ptoa(uvmexp.free), uvmexp.free);
d719 1
a719 1
	caddr_t v;
d753 2
a754 2
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
d777 1
a777 1
	struct trapframe *tf = USER_REGS(p);
d807 1
a807 1

d809 3
a811 3
		/*
		 * user mode, serialize mem, interrupts enabled,
		 * graphics unit, fp enabled
d813 1
a813 1
		tf->epsr = PSR_SRM | PSR_SFD;
d819 3
a821 3
		/*
		 * user mode, interrupts enabled,
		 * no graphics unit, fp enabled
d884 3
a886 3
	struct proc *p = curproc;
	struct trapframe *tf;
	struct sigacts *psp = p->p_sigacts;
d910 1
a910 1
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
d1001 1
a1001 1
	/*
d1044 2
a1045 2
	struct sigcontext *scp;
	struct trapframe *tf;
d1073 1
a1073 1
#endif
d1152 1
a1152 1
	int howto;
d1200 1
a1200 1
void
d1354 1
a1354 1

d1387 1
a1387 1
	u_char *vaddr;
d1390 1
a1390 1
	extern vaddr_t iomap_mapin(paddr_t, psize_t,  boolean_t);
d1437 1
a1437 1
#endif
d1454 1
a1454 1
vaddr_t
d1457 1
a1457 1
	vaddr_t addr;
d1459 1
a1459 1
	addr = (vaddr_t)uvm_km_zalloc(kernel_map, INTSTACK_SIZE);
d1504 1
a1504 1
#ifdef DEBUG
d1507 1
a1507 1
		panic("intr_findvec(%d,%d): bad parameters", start, end);
d1515 1
a1515 1
	printf("intr_findvec(%d,%d): no vector available\n", start, end);
d1528 1
a1528 1
	struct intrhand *intr;
d1581 1
a1581 1
	0,0,0,0,SYSCV_TIMER1,0,SYSCV_ACF,SYSCV_ABRT,
d1588 1
a1588 1
void
d1613 1
a1613 1
	/*
d1617 1
a1617 1
	 * priority.
d1623 1
a1623 1
			int i;
d1646 1
a1646 1

d1656 1
a1656 1

d1659 3
a1661 3
		/*
		 * This is tricky.  If you don't catch all the
		 * interrupts, you die. Game over. Insert coin...
d1702 1
a1702 1
			intrcnt[M88K_SPUR_IRQ]++;
d1719 1
a1719 1
					intrcnt[level]++;
a1772 1
#ifdef DIAGNOSTIC
d1792 5
a1796 1
#endif
a1808 3
	/* block interrupts at level or lower */
	setipl(level);

d1813 1
a1813 1
		intrcnt[M88K_SPUR_IRQ]++;
a1816 1
#ifdef DIAGNOSTIC
a1821 1
#endif
d1836 1
a1836 1
				intrcnt[level]++;
d1859 1
a1859 1
	setipl(mask);
d1875 1
a1875 1

d1916 1
a1916 1
		intrcnt[M88K_SPUR_IRQ]++;
d1938 1
a1938 1
				intrcnt[level]++;
d1957 1
a1957 1
#endif
d2043 1
a2043 1
 * insert an element into a queue
d2050 1
a2050 1
	struct prochd *element, *head;
d2067 1
a2067 1
	struct prochd *element;
d2102 1
a2102 1
	struct proc *p;
d2104 3
a2106 3
	struct prochd *q;
	struct proc *oldlast;
	int which = p->p_priority >> 2;
d2109 1
a2109 1
		panic("setrunqueue %p", p);
d2126 3
a2128 3
	struct proc *p = vp;
	int which = p->p_priority >> 2;
	struct prochd *q;
d2131 1
a2131 1
		panic("remrq %p", p);
a2156 2
int netisr;

d2207 1
a2207 1
}
d2215 1
a2215 1
}
d2264 1
a2264 1
		printf("fpsr %x fpcr %x epsr %x ssbr %x\n",
d2266 1
a2266 1
		printf("fpecr %x fphs1 %x fpls1 %x fphs2 %x fpls2 %x\n",
d2268 1
a2268 1
		printf("fppt %x fprh %x fprl %x fpit %x\n",
d2270 1
a2270 1
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n",
d2273 1
a2273 1
#endif
d2276 1
a2276 1
		printf("fpsr %x fpcr %x fpecr %x epsr %x\n",
d2282 1
a2282 1
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n",
d2296 1
a2296 1
#endif
a2308 6
#ifdef MVME197
	extern struct cmmu_p cmmu88110;
#endif
#if defined(MVME187) || defined(MVME188)
	extern struct cmmu_p cmmu8820x;
#endif
d2312 1
a2312 1

d2316 1
a2316 1
	 * Do this early so that we can take a data or
d2323 1
a2323 1
	/* zero out the machine dependent function pointers */
d2336 2
a2337 2
	/*
	 * set up interrupt and fp exception handlers
d2427 1
a2427 1
#endif
d2447 2
a2448 2
#endif
	pmap_bootstrap((vaddr_t)trunc_page((unsigned)&kernelstart) /* = loadpt */,
d2452 1
a2452 1
	 * Tell the VM system about available physical memory.
d2459 1
a2459 1
	save_u_area(&proc0, (vaddr_t)proc0paddr);
d2470 1
a2470 1
#endif
d2474 1
a2474 1
 * Boot console routines:
@


1.1.1.8
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.123 2003/12/22 23:29:33 miod Exp $	*/
a923 6

	/*
	 * Be sure to keep the xip values intact, especially on 88100: should
	 * we return back to the process, it must be in the same instruction
	 * fetching state, or bad things will happen...
	 */
d926 3
a928 3
		sf.sf_sc.sc_xip = tf->sxip;
		sf.sf_sc.sc_nip = tf->snip;
		sf.sf_sc.sc_fip = tf->sfip;
d931 2
a932 2
		sf.sf_sc.sc_xip = tf->exip;
		sf.sf_sc.sc_nip = tf->enip;
a972 1

d1044 15
a1058 1

d1067 3
a1069 3
		tf->sxip = scp->sc_xip;
		tf->snip = scp->sc_nip;
		tf->sfip = scp->sc_fip;
d1072 2
a1073 2
		tf->exip = scp->sc_xip;
		tf->enip = scp->sc_nip;
d1118 1
a1118 1
	if (scp->sc_onstack & SS_ONSTACK)
@


1.1.1.9
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.133 2004/01/14 11:49:49 miod Exp $	*/
d56 2
d59 1
d66 1
a96 1
#ifdef MVME188
d98 1
a98 2
#endif
#ifdef MVME197
a99 1
#endif
d133 3
a135 3
void m187_ext_int(u_int v, struct trapframe *eframe);
void m188_ext_int(u_int v, struct trapframe *eframe);
void m197_ext_int(u_int v, struct trapframe *eframe);
d231 13
d443 1
a443 1
	cmmu_flush_tlb(cpu_number(), 1, UADDR, USPACE);
a521 1
	case BRD_8120:
d762 1
a762 1
	struct trapframe *tf = (struct trapframe *)USER_REGS(p);
d798 1
a798 1
		tf->tf_epsr = PSR_SRM | PSR_SFD;
d802 1
a802 1
		tf->tf_epsr |= PSR_SER;
d808 1
a808 1
		tf->tf_epsr = PSR_SFD | PSR_SFD2;
d819 1
a819 1
		tf->tf_exip = pack->ep_entry & ~3;
d821 1
a821 1
		printf("exec @@ 0x%x\n", tf->tf_exip);
d824 2
a825 2
		tf->tf_snip = pack->ep_entry & ~3;
		tf->tf_sfip = (pack->ep_entry & ~3) | FIP_V;
d827 2
a828 2
	tf->tf_r[2] = stack;
	tf->tf_r[31] = stack;
d839 1
a839 1
 * through sf_handler so... don't screw with them!
d842 6
a847 6
	int			sf_signo;	/* signo for handler */
	siginfo_t *		sf_sip;
	struct sigcontext *	sf_scp;		/* context ptr for handler */
	sig_t			sf_handler;	/* handler addr for u_sigc */
	struct sigcontext	sf_sc;		/* actual context */
	siginfo_t		sf_si;
d894 1
a894 6
		fp = (struct sigframe *)(tf->tf_r[31] - fsize);

	/* make sure the frame is aligned on a 8 byte boundary */
	if (((vaddr_t)fp & 0x07) != 0)
		fp = (struct sigframe *)((vaddr_t)fp & ~0x07);

d922 57
a978 2
	bcopy((const void *)&tf->tf_regs, (void *)&sf.sf_sc.sc_regs,
	    sizeof(sf.sf_sc.sc_regs));
d1000 2
a1001 2
		tf->tf_snip = (addr & ~3) | NIP_V;
		tf->tf_sfip = (tf->tf_snip + 4) | FIP_V;
d1004 2
a1005 2
		tf->tf_exip = (addr & ~3);
		tf->tf_enip = (tf->tf_exip + 4);
d1007 1
a1007 1
	tf->tf_r[31] = (unsigned)fp;
d1045 1
a1045 1
	if (((vaddr_t)scp & 3) != 0 ||
d1057 50
a1106 2
	bcopy((const void *)&scp->sc_regs, (caddr_t)&tf->tf_regs,
	    sizeof(scp->sc_regs));
a1115 1

a1376 1
	case BRD_8120:
d1567 1
a1567 1
m188_ext_int(u_int v, struct trapframe *eframe)
d1578 1
a1578 1
	eframe->tf_mask = old_spl;
d1717 1
a1717 1
	if (eframe->tf_dmt0 & DMT_VALID)
d1724 1
a1724 1
	setipl(eframe->tf_mask);
d1740 1
a1740 1
m187_ext_int(u_int v, struct trapframe *eframe)
d1832 1
a1832 1
	if (eframe->tf_dmt0 & DMT_VALID)
d1845 1
a1845 1
m197_ext_int(u_int v, struct trapframe *eframe)
a1864 1
#ifdef DIAGNOSTIC
d1873 5
a1877 1
#endif
a1891 3
	/* block interrupts at level or lower */
	setipl(level);

a1899 1
#ifdef DIAGNOSTIC
a1904 1
#endif
a1910 1

d1935 1
a1935 1
	setipl(mask);
d1937 1
a1937 1
#endif	/* MVME197 */
d1944 12
d1957 13
a1969 1
	return (ENOEXEC);
d2205 1
a2205 1
	struct trapframe *frame = framep;
d2219 1
a2219 1
#define R(i) f->tf_r[i]
d2232 1
a2232 1
		printf("exip %x enip %x\n", f->tf_exip, f->tf_enip);
d2234 1
a2234 2
		printf("sxip %x snip %x sfip %x\n",
		    f->tf_sxip, f->tf_snip, f->tf_sfip);
d2237 1
a2237 1
	if (f->tf_vector == 0x3 && cputyp != CPU_88110) {
d2239 4
a2242 7
		printf("dmt0 %x dmd0 %x dma0 %x\n",
		    f->tf_dmt0, f->tf_dmd0, f->tf_dma0);
		printf("dmt1 %x dmd1 %x dma1 %x\n",
		    f->tf_dmt1, f->tf_dmd1, f->tf_dma1);
		printf("dmt2 %x dmd2 %x dma2 %x\n",
		    f->tf_dmt2, f->tf_dmd2, f->tf_dma2);
		printf("fault type %d\n", (f->tf_dpfsr >> 16) & 0x7);
d2247 1
a2247 1
		    f->tf_fpsr, f->tf_fpcr, f->tf_epsr, f->tf_ssbr);
d2249 1
a2249 2
		    f->tf_fpecr, f->tf_fphs1, f->tf_fpls1,
		    f->tf_fphs2, f->tf_fpls2);
d2251 1
a2251 1
		    f->tf_fppt, f->tf_fprh, f->tf_fprl, f->tf_fpit);
d2253 1
a2253 2
		    f->tf_vector, f->tf_mask, f->tf_mode,
		    f->tf_scratch1, f->tf_cpu);
d2259 1
a2259 1
		    f->tf_fpsr, f->tf_fpcr, f->tf_fpecr, f->tf_epsr);
d2261 1
a2261 1
		    f->tf_dsap, f->tf_duap, f->tf_dsr, f->tf_dlar, f->tf_dpar);
d2263 1
a2263 1
		    f->tf_isap, f->tf_iuap, f->tf_isr, f->tf_ilar, f->tf_ipar);
d2265 1
a2265 2
		    f->tf_vector, f->tf_mask, f->tf_mode,
		    f->tf_scratch1, f->tf_cpu);
d2274 1
a2274 1
		printf("emask = 0x%b\n", f->tf_mask, IST_STRING);
d2318 6
a2344 1
	case BRD_8120:
a2375 1
	case BRD_8120:
@


1.1.1.10
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.142 2004/05/06 18:32:08 miod Exp $	*/
d251 2
a252 4
 * This is to fake out the console routines, while booting.
 * We could use directly the bugtty console, but we want to be able to
 * configure a kernel without bugtty since we do not necessarily need a
 * full-blown console driver.
d269 3
a271 3
 * Early console initialization: called early on from main, before vm init.
 * We want to stick to the BUG routines for now, and we'll switch to the
 * real console in cpu_startup().
d276 1
d278 5
a282 1
	cn_tab = &bootcons;
d376 2
a377 4
		else if (c > '9' || c < '0') {
			speed = 0;
			break;
		}
d381 1
d383 1
a383 25
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
	case BRD_8120:
		if (speed == 25 || speed == 33)
			return speed;
		speed = 25;
		break;
#endif
#ifdef MVME188
	case BRD_188:
		if (speed == 20 || speed == 25)
			return speed;
		speed = 25;
		break;
#endif
#ifdef MVME197
	case BRD_197:
		if (speed == 40 || speed == 50)
			return speed;
		speed = 50;
		break;
#endif
	}

d385 3
a387 4
	 * If we end up here, the board information block is damaged and
	 * we can't trust it.
	 * Suppose we are running at the most common speed for our board,
	 * and hope for the best (this really only affects osiop).
d391 1
a391 1
	return speed;
d922 7
a928 2
		sigexit(p, SIGILL);
		/* NOTREACHED */
d1028 1
a1028 3
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
d1063 1
a1063 1
	for (;;);
d1068 1
a1068 1
__dead void
d1073 6
a1078 14
	*(volatile u_int32_t *)IEN0_REG = 0;
	*(volatile u_int32_t *)IEN1_REG = 0;
	*(volatile u_int32_t *)IEN2_REG = 0;
	*(volatile u_int32_t *)IEN3_REG = 0;

	if ((*(volatile u_int8_t *)GLB1) & M188_SYSCONNEG) {
		/* Force only a local reset */
		*(volatile u_int8_t *)GLB1 |= M188_LRST;
	} else {
		/* Force a complete VMEbus reset */
		*(volatile u_int32_t *)GLBRES_REG = 1;
	}

	*(volatile u_int32_t *)UCSR_REG |= 0x2000;	/* clear SYSFAIL */
d1081 1
a1081 5
	*(volatile u_int32_t *)UCSR_REG |= 0x2000;	/* clear SYSFAIL */

	printf("reset failed\n");
	for (;;);
	/* NOTREACHED */
d1368 2
a1369 1
intr_findvec(int start, int end, int skip)
d1374 1
d1379 1
a1379 3
	for (vec = start; vec <= end; vec++) {
		if (vec == skip)
			continue;
d1384 1
a1384 2
	printf("intr_findvec(%d,%d,%d): no vector available\n",
	    start, end, skip);
d1410 1
a1410 2
			panic("intr_establish: there are other handlers with "
			    "vec (0x%x) at ipl %x, but you want it at %x",
d1445 2
a1446 1
const unsigned int obio_vec[32] = {
d1537 1
a1537 1
			vec = SYSCON_VECT + obio_vec[intbit];
d1543 1
a1543 1
			vec = SYSCON_VECT + obio_vec[intbit];
d1892 32
d2309 3
a2311 2
	pmap_bootstrap((vaddr_t)trunc_page((unsigned)&kernelstart));

d2317 1
a2317 1
	    atop(avail_start), atop(avail_end), VM_FREELIST_DEFAULT);
@


