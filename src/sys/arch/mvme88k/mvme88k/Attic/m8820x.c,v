head	1.2;
access;
symbols
	cvs-200405160640:1.1.1.9
	cvs-200401271800:1.1.1.8
	cvs-200401261630:1.1.1.8
	cvs-200401021645:1.1.1.7
	cvs-200312222040:1.1.1.6
	cvs-200310020700:1.1.1.5
	cvs-200309271030:1.1.1.5
	cvs-200309261655:1.1.1.4
	cvs-200309251530:1.1.1.4
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	cvs-200307072125:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200307021520:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.04.06.04.29.31;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.50.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.50.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.11.18.35.46;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.30.23.13.31;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.09.25.16.35.57;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.09.27.11.08.17;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.22.21.00.00;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.01.02.17.49.45;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.01.26.18.42.36;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.16.08.37.34;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove "some dead architectures".

These are all but i386 and x86-64 (which is not in the tree yet),
because I have no machines to work with.

Re-adding support should be fairly easy, just cvs adding a partial
OpenBSD checkout and pulling in stuff like kernel signal patch, humantime,
etc. which got added to i386 as well.

You will need gcc support as well.
@
text
@/*	$OpenBSD: m8820x.c,v 1.14 2002/03/14 03:15:57 millert Exp $	*/
/*
 * Copyright (c) 2001 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
#ifdef M88100

#include <sys/param.h>
#include <sys/types.h>
#include <sys/systm.h>
#include <sys/simplelock.h>

#include <machine/asm_macro.h>
#include <machine/board.h>
#include <machine/cpus.h>
#include <machine/cpu_number.h>
#include <machine/locore.h>

#include <machine/cmmu.h>

#ifdef DDB
#include <ddb/db_output.h>		/* db_printf()		*/
#define DEBUG_MSG db_printf
#else
#define DEBUG_MSG printf
#endif /* DDB */


/* On some versions of 88200, page size flushes don't work. I am using
 * sledge hammer approach till I find for sure which ones are bad XXX nivas */
#define BROKEN_MMU_MASK	

#ifdef DEBUG
#define DB_CMMU	0x4000	/* MMU debug */
unsigned int m8820x_debuglevel = 0;
#define dprintf(_L_,_X_) \
	do { \
		if (m8820x_debuglevel & (_L_)) { \
			unsigned int psr = disable_interrupts_return_psr(); \
			printf("%d: ", cpu_number()); \
			printf _X_;  \
			set_psr(psr); \
		} \
	} while (0)
#else
#define dprintf(_L_,_X_) do { } while (0)
#endif 
#undef	SHADOW_BATC		/* don't use BATCs for now XXX nivas */

/* This is the function table for the mc8820x CMMUs */
struct cmmu_p cmmu8820x = {
	m8820x_cmmu_init,
	m8820x_show_apr,
	m8820x_setup_board_config,
	m8820x_setup_cmmu_config,
	m8820x_cmmu_dump_config,
	m8820x_cpu_configuration_print,
	m8820x_cmmu_shutdown_now,
	m8820x_cmmu_parity_enable,
	m8820x_cmmu_cpu_number,
	m8820x_cmmu_get_idr,
	m8820x_cmmu_set_sapr,
	m8820x_cmmu_remote_set_sapr,
	m8820x_cmmu_set_uapr,
	m8820x_cmmu_set_batc_entry,
	m8820x_cmmu_set_pair_batc_entry,
	m8820x_cmmu_flush_remote_tlb,
	m8820x_cmmu_flush_tlb,
	m8820x_cmmu_pmap_activate,
	m8820x_cmmu_flush_remote_cache,
	m8820x_cmmu_flush_cache,
	m8820x_cmmu_flush_remote_inst_cache,
	m8820x_cmmu_flush_inst_cache,
	m8820x_cmmu_flush_remote_data_cache,
	m8820x_cmmu_flush_data_cache,
	m8820x_dma_cachectl,
#ifdef DDB
	m8820x_cmmu_get_by_mode,
	m8820x_cmmu_show_translation,
	m8820x_cmmu_cache_state,
	m8820x_show_cmmu_info,
#endif /* end if DDB */
};

struct cmmu_regs {
   /* base + $000 */volatile unsigned idr; 
   /* base + $004 */volatile unsigned scr; 
   /* base + $008 */volatile unsigned ssr; 
   /* base + $00C */volatile unsigned sar; 
   /*             */unsigned padding1[0x3D]; 
   /* base + $104 */volatile unsigned sctr; 
   /* base + $108 */volatile unsigned pfSTATUSr; 
   /* base + $10C */volatile unsigned pfADDRr; 
   /*             */unsigned padding2[0x3C]; 
   /* base + $200 */volatile unsigned sapr; 
   /* base + $204 */volatile unsigned uapr; 
   /*             */unsigned padding3[0x7E]; 
   /* base + $400 */volatile unsigned bwp[8]; 
   /*             */unsigned padding4[0xF8]; 
   /* base + $800 */volatile unsigned cdp[4]; 
   /*             */unsigned padding5[0x0C]; 
   /* base + $840 */volatile unsigned ctp[4]; 
   /*             */unsigned padding6[0x0C]; 
   /* base + $880 */volatile unsigned cssp;

   /* The rest for the 88204 */
#define cssp0 cssp
   /*             */ unsigned padding7[0x03]; 
   /* base + $890 */volatile unsigned cssp1; 
   /*             */unsigned padding8[0x03]; 
   /* base + $8A0 */volatile unsigned cssp2; 
   /*             */unsigned padding9[0x03]; 
   /* base + $8B0 */volatile unsigned cssp3;
};

struct m8820x_cmmu {
	struct cmmu_regs *cmmu_regs;	/* CMMU "base" area */
	unsigned char  cmmu_cpu;	/* cpu number it is attached to */
	unsigned char  which;		/* either INST_CMMU || DATA_CMMU */
	unsigned char  cmmu_access;	/* either CMMU_ACS_{SUPER,USER,BOTH} */
	unsigned char  cmmu_alive;
#define CMMU_DEAD	0		/* This cmmu not there */
#define CMMU_AVAILABLE	1		/* It's there, but which cpu's? */
#define CMMU_ALIVE	1		/* It's there. */
#define CMMU_MARRIED	2		/* Know which cpu it belongs to. */
	vm_offset_t    cmmu_addr;	/* address range */
	vm_offset_t    cmmu_addr_mask;	/* address mask */
	int            cmmu_addr_match;	/* return value of address comparison */
#ifdef SHADOW_BATC
	unsigned batc[8];
#endif
}; 
/*
 * We rely upon and use INST_CMMU == 0 and DATA_CMMU == 1
 */
#if INST_CMMU != 0 || DATA_CMMU != 1
error("ack gag barf!");
#endif

/*
 * CMMU(cpu,data) Is the cmmu struct for the named cpu's indicated cmmu.
 * REGS(cpu,data) is the actual register structure.
 */

#define CMMU(cpu, data) cpu_cmmu[(cpu)].pair[(data)?DATA_CMMU:INST_CMMU]
#define REGS(cpu, data) (*CMMU(cpu, data)->cmmu_regs)

/* 
 * This lock protects the cmmu SAR and SCR's; other ports 
 * can be accessed without locking it 
 *
 * May be used from "db_interface.c".
 */

int      vme188_config;

/* local prototypes */
unsigned m8820x_cmmu_get(int mmu, int reg);
void m8820x_cmmu_store(int, int, unsigned);
void m8820x_cmmu_set(int, unsigned, int, int, int, int, vm_offset_t);
void m8820x_cmmu_sync_cache(vm_offset_t, int);
void m8820x_cmmu_sync_inval_cache(vm_offset_t, int);
void m8820x_cmmu_inval_cache(vm_offset_t, int);
int m8820x_cmmu_alive(int);

void
m8820x_show_apr(value)
	unsigned value;
{
	union apr_template apr_template;
	apr_template.bits = value;

	printf("table @@ 0x%x000", apr_template.field.st_base);
	if (apr_template.field.wt) printf(", writethrough");
	if (apr_template.field.g)  printf(", global");
	if (apr_template.field.ci) printf(", cache inhibit");
	if (apr_template.field.te) printf(", valid");
	else			   printf(", not valid");
	printf("\n");
}

/*----------------------------------------------------------------
 * The cmmu.c module was initially designed for the Omron Luna 88K
 * layout consisting of 4 CPUs with 2 CMMUs each, one for data
 * and one for instructions.
 *
 * Trying to support a few more board configurations for the
 * Motorola MVME188 we have these layouts:
 *
 *  - config 0: 4 CPUs, 8 CMMUs
 *  - config 1: 2 CPUs, 8 CMMUs
 *  - config 2: 1 CPUs, 8 CMMUs
 *  - config 5: 2 CPUs, 4 CMMUs
 *  - config 6: 1 CPU,  4 CMMUs
 *  - config A: 1 CPU,  2 CMMUs
 *
 * We use these splitup schemas:
 *  - split between data and instructions (always enabled)
 *  - split between user/spv (and A14 in config 2)
 *  - split because of A12 (and A14 in config 2)
 *  - one SRAM supervisor, other rest
 *  - one whole SRAM, other rest
 *
 * The main problem is to find the right suited CMMU for a given
 * CPU number at those configurations.
 *                                         em, 10.5.94
 *
 * WARNING: the code was never tested on a uniprocessor
 * system. All effort was made to support these configuration
 * but the kernel never ran on such a system.
 *
 *					   em, 12.7.94
 */

/*
 * This structure describes the CMMU per CPU split strategies
 * used for data and instruction CMMUs.
 */
struct cmmu_strategy {
	int inst;
	int data;
} cpu_cmmu_strategy[] = {
	/*     inst                 data */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV},	 /* CPU 0 */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV},	 /* CPU 1 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}, /* CPU 2 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}  /* CPU 3 */
};

/*
 * The following list of structs describe the different
 * MVME188 configurations which are supported by this module.
 */
struct board_config {
	int supported;
	int ncpus;
	int ncmmus;
} bd_config[] =
{
	/* sup, CPU MMU */
	{  1,  4,  8}, /* 4P128 - 4P512 */
	{  1,  2,  8}, /* 2P128 - 2P512 */
	{  1,  1,  8}, /* 1P128 - 1P512 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  1,  2,  4}, /* 2P64  - 2P256 */
	{  1,  1,  4}, /* 1P64  - 1P256 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  1,  1,  2}, /* 1P32  - 1P128 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1}
};

/*
 * Structure for accessing MMUS properly.
 */

struct m8820x_cmmu m8820x_cmmu[MAX_CMMUS] =
{
	/* addr    cpu       mode           access
      alive   addr mask */
	{(void *)VME_CMMU_I0, -1, INST_CMMU, CMMU_ACS_BOTH, 
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_D0, -1, DATA_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_I1, -1, INST_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_D1, -1, DATA_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_I2, -1, INST_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_D2, -1, DATA_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_I3, -1, INST_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_D3, -1, DATA_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0}
};

struct cpu_cmmu {
	struct m8820x_cmmu *pair[2];
} cpu_cmmu[MAX_CPUS];

void 
m8820x_setup_board_config()
{
	unsigned long *volatile whoami;

	master_cpu = 0;	/* temp to get things going */
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
		vme188_config = 10; /* There is no WHOAMI reg on MVME187 - fake it... */
		m8820x_cmmu[0].cmmu_regs = (void *)SBC_CMMU_I;
		m8820x_cmmu[0].cmmu_cpu = 0;
		m8820x_cmmu[1].cmmu_regs = (void *)SBC_CMMU_D;
		m8820x_cmmu[1].cmmu_cpu = 0;
		m8820x_cmmu[2].cmmu_regs = (void *)NULL;
		m8820x_cmmu[3].cmmu_regs = (void *)NULL;
		m8820x_cmmu[4].cmmu_regs = (void *)NULL;
		m8820x_cmmu[5].cmmu_regs = (void *)NULL;
		m8820x_cmmu[6].cmmu_regs = (void *)NULL;
		m8820x_cmmu[7].cmmu_regs = (void *)NULL;
		max_cpus = 1;
		max_cmmus = 2;
		break;
#endif /* MVME187 */
#ifdef MVME188
	case BRD_188:
		whoami = (unsigned long *volatile)MVME188_WHOAMI;
		vme188_config = (*whoami & 0xf0) >> 4;
		dprintf(DB_CMMU,("m8820x_setup_board_config: WHOAMI @@ 0x%08x holds value 0x%08x vme188_config = %d\n",
				 whoami, *whoami, vme188_config));
		max_cpus = bd_config[vme188_config].ncpus;
		max_cmmus = bd_config[vme188_config].ncmmus;
		break;
#endif /* MVME188 */
	}
	cpu_cmmu_ratio = max_cmmus / max_cpus;
	switch (bd_config[vme188_config].supported) {
	case 0:
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", brdtyp, 
		       vme188_config, max_cpus, max_cmmus);
		panic("This configuration is not supported - go and get another OS.");
		/* NOTREACHED */
		break;
	case 1:
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", brdtyp,
		       vme188_config, max_cpus, max_cmmus);
		m8820x_setup_cmmu_config();
		break;
	default:
		panic("UNKNOWN MVME%x board configuration: WHOAMI = 0x%02x", brdtyp, *whoami);
		/* NOTREACHED */
		break;
	}
	return;
}

/*
 * This routine sets up the CPU/CMMU tables used in the
 * motorola/m88k/m88100/cmmu.c module.
 */
void 
m8820x_setup_cmmu_config()
{
	register int num, cmmu_num;
#ifdef MVME188
	register int val1, val2;
	unsigned long *volatile pcnfa;
	unsigned long *volatile pcnfb;
#endif 

	dprintf(DB_CMMU,("m8820x_setup_cmmu_config: initializing with %d CPU(s) and %d CMMU(s)\n",
			 max_cpus, max_cmmus));

	/*
	 * Probe for available MMUs
	 */
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++)
		if (!badwordaddr((vm_offset_t)m8820x_cmmu[cmmu_num].cmmu_regs)) {
			union cpupid id;

			id.cpupid = m8820x_cmmu[cmmu_num].cmmu_regs->idr;
			if (id.m88200.type != M88200_ID &&
			    id.m88200.type != M88204_ID) {
				printf("WARNING: non M8820x circuit found at CMMU address 0x%08x\n",
				       m8820x_cmmu[cmmu_num].cmmu_regs);
				continue;
			}
			m8820x_cmmu[cmmu_num].cmmu_alive = CMMU_ALIVE;
			dprintf(DB_CMMU,("m8820x_setup_cmmu_config: CMMU %d found at 0x%08x\n",
					 cmmu_num, m8820x_cmmu[cmmu_num].cmmu_regs));
		}

		/*
		 * Now that we know which CMMUs are there, let's report on which
		 * CPU/CMMU sets seem complete (hopefully all)
		 */
	for (num = 0; num < max_cpus; num++) {
		register int i;
		union cpupid id;

		for (i = 0; i < cpu_cmmu_ratio; i++) {
			dprintf(DB_CMMU,("cmmu_init: testing CMMU %d for CPU %d\n",
					 num*cpu_cmmu_ratio+i, num));
			if (!m8820x_cmmu_alive(num*cpu_cmmu_ratio + i)) {
				printf("CMMU %d attached to CPU %d is not working\n",
					 num*cpu_cmmu_ratio+i, num);
				panic("m8820x_setup_cmmu_config");
			}
		}
		cpu_sets[num] = 1;   /* This cpu installed... */
		id.cpupid = m8820x_cmmu[num*cpu_cmmu_ratio].cmmu_regs->idr;

		if (id.m88200.type == M88204_ID)
			printf("CPU%d is attached with %d MC88204 CMMUs\n",
			       num, cpu_cmmu_ratio);
		else
			printf("CPU%d is attached with %d MC88200 CMMUs\n",
			       num, cpu_cmmu_ratio);
	}

	for (num = 0; num < max_cpus; num++) {
		cpu_cmmu_strategy[num].inst &= CMMU_SPLIT_MASK;
		cpu_cmmu_strategy[num].data &= CMMU_SPLIT_MASK;
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: CPU %d inst strat %d data strat %d\n",
				 num, cpu_cmmu_strategy[num].inst, cpu_cmmu_strategy[num].data));
	}

	switch (vme188_config) {
	/*
	 * These configurations have hardwired CPU/CMMU configurations.
	 */
	case CONFIG_0:
	case CONFIG_5:
	case CONFIG_A:
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: resetting strategies\n"));
		for (num = 0; num < max_cpus; num++)
			cpu_cmmu_strategy[num].inst = cpu_cmmu_strategy[num].data =
						      CMMU_SPLIT_ADDRESS;
		break;
#ifdef MVME188
	/*
	 * Configure CPU/CMMU strategy into PCNFA and PCNFB board registers.
	 */
	case CONFIG_1:
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
		pcnfb = (unsigned long *volatile)MVME188_PCNFB;
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].data;
		val2 = (cpu_cmmu_strategy[1].inst << 2) | cpu_cmmu_strategy[1].data;
		*pcnfa = val1;
		*pcnfb = val2;
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: 2P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
		break;
	case CONFIG_2:
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
		pcnfb = (unsigned long *volatile)MVME188_PCNFB;
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].inst;
		val2 = (cpu_cmmu_strategy[0].data << 2) | cpu_cmmu_strategy[0].data;
		*pcnfa = val1;
		*pcnfb = val2;
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: 1P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
		break;
	case CONFIG_6:
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].data;
		*pcnfa = val1;
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: 1P64: PCNFA = 0x%x\n", val1));
		break;
#endif /* MVME188 */
	default:
		panic("m8820x_setup_cmmu_config");
		break;
	}

#ifdef MVME188
	dprintf(DB_CMMU,("m8820x_setup_cmmu_config: PCNFA = 0x%x, PCNFB = 0x%x\n", *pcnfa, *pcnfb));
#endif /* MVME188 */

	/*
	 * Calculate the CMMU<->CPU connections
	 */
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		m8820x_cmmu[cmmu_num].cmmu_cpu =
		(int) (((float) cmmu_num) * ((float) max_cpus) / ((float) max_cmmus));
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: CMMU %d connected with CPU %d\n",
				 cmmu_num, m8820x_cmmu[cmmu_num].cmmu_cpu));
	}

	/*
	 * Now set m8820x_cmmu[].cmmu_access and addr
	 */
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		/*
		 * We don't set up anything for the hardwired configurations.
		 */
		if (cpu_cmmu_ratio == 2) {
			m8820x_cmmu[cmmu_num].cmmu_addr =
			m8820x_cmmu[cmmu_num].cmmu_addr_mask = 0;
			m8820x_cmmu[cmmu_num].cmmu_addr_match = 1;
			m8820x_cmmu[cmmu_num].cmmu_access = CMMU_ACS_BOTH;
			continue;
		}

		/*
		 * First we set the address/mask pairs for the exact address
		 * matches.
		 */
		switch ((m8820x_cmmu[cmmu_num].which == INST_CMMU) ?
			cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
			cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data) {
		case CMMU_SPLIT_ADDRESS:
			m8820x_cmmu[cmmu_num].cmmu_addr = ((cmmu_num & 0x2) ^ 0x2) << 11;
			m8820x_cmmu[cmmu_num].cmmu_addr_mask = CMMU_A12_MASK;
			m8820x_cmmu[cmmu_num].cmmu_addr_match = 1;
			break;
		case CMMU_SPLIT_SPV:
			m8820x_cmmu[cmmu_num].cmmu_addr =
			m8820x_cmmu[cmmu_num].cmmu_addr_mask = 0;
			m8820x_cmmu[cmmu_num].cmmu_addr_match = 1;
			break;
		case CMMU_SPLIT_SRAM_ALL:
			m8820x_cmmu[cmmu_num].cmmu_addr = CMMU_SRAM;
			m8820x_cmmu[cmmu_num].cmmu_addr_mask = CMMU_SRAM_MASK;
			m8820x_cmmu[cmmu_num].cmmu_addr_match = (cmmu_num & 0x2) ? 1 : 0;
			break;
		case CMMU_SPLIT_SRAM_SPV:
			if (cmmu_num & 0x2) {
				m8820x_cmmu[cmmu_num].cmmu_addr = CMMU_SRAM;
				m8820x_cmmu[cmmu_num].cmmu_addr_mask = CMMU_SRAM_MASK;
			} else {
				m8820x_cmmu[cmmu_num].cmmu_addr =
				m8820x_cmmu[cmmu_num].cmmu_addr_mask = 0;
			}
			m8820x_cmmu[cmmu_num].cmmu_addr_match = 1;
			break;
		}

		/*
		 * For MVME188 single processors, we've got to look at A14.
		 * This bit splits the CMMUs independent of the enabled strategy.
		 *
		 * NOT TESTED!!! - em
		 */
		if (cpu_cmmu_ratio > 4) {
			m8820x_cmmu[cmmu_num].cmmu_addr |= ((cmmu_num & 0x4) ^ 0x4) << 12;
			m8820x_cmmu[cmmu_num].cmmu_addr_mask |= CMMU_A14_MASK;
		}

		/*
		 * Next we cope with the various access modes.
		 */
		switch ((m8820x_cmmu[cmmu_num].which == INST_CMMU) ?
			cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
			cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data) {
		case CMMU_SPLIT_SPV:
			m8820x_cmmu[cmmu_num].cmmu_access =
			(cmmu_num & 0x2 ) ? CMMU_ACS_USER : CMMU_ACS_SUPER;
			break;
		case CMMU_SPLIT_SRAM_SPV:
			m8820x_cmmu[cmmu_num].cmmu_access =
			(cmmu_num & 0x2 ) ? CMMU_ACS_SUPER : CMMU_ACS_BOTH;
			break;
		default:
			m8820x_cmmu[cmmu_num].cmmu_access = CMMU_ACS_BOTH;
			break;
		}
	}
	return;
}

#ifdef MVME188
static char *cmmu_strat_string[] = {
	"address split ",
	"user/spv split",
	"spv SRAM split",
	"all SRAM split"
};
#endif 

void 
m8820x_cmmu_dump_config()
{
#ifdef MVME188
	unsigned long *volatile pcnfa;
	unsigned long *volatile pcnfb;
	register int cmmu_num;
#endif /* MVME188 */

	DEBUG_MSG("Current CPU/CMMU configuration:\n\n");

	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
		DEBUG_MSG("VME1x7 split mode\n\n");
#endif /* MVME187 */
#ifdef MVME188
	case BRD_188:
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
		pcnfb = (unsigned long *volatile)MVME188_PCNFB;
		DEBUG_MSG("VME188 address decoder: PCNFA = 0x%1x, PCNFB = 0x%1x\n\n", *pcnfa & 0xf, *pcnfb & 0xf);
		for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
			DEBUG_MSG("CMMU #%d: %s CMMU for CPU %d:\n Strategy: %s\n %s access addr 0x%08x mask 0x%08x match %s\n",
				  cmmu_num,
				  (m8820x_cmmu[cmmu_num].which == INST_CMMU) ? "inst" : "data",
				  m8820x_cmmu[cmmu_num].cmmu_cpu,
				  cmmu_strat_string[(m8820x_cmmu[cmmu_num].which == INST_CMMU) ?
						    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
						    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data],
				  (m8820x_cmmu[cmmu_num].cmmu_access == CMMU_ACS_BOTH) ?   "User and spv" :
				  ((m8820x_cmmu[cmmu_num].cmmu_access == CMMU_ACS_USER) ? "User        " :
				   "Supervisor  "),
				  m8820x_cmmu[cmmu_num].cmmu_addr,
				  m8820x_cmmu[cmmu_num].cmmu_addr_mask,
				  m8820x_cmmu[cmmu_num].cmmu_addr_match ? "TRUE" : "FALSE");
		}
#endif /* MVME188 */
	}
}

/* To be implemented as a macro for speedup - XXX-em */
void
m8820x_cmmu_store(mmu, reg, val)
	int mmu, reg;
	unsigned val;
{
	*(unsigned *volatile)(reg + (char *)(m8820x_cmmu[mmu].cmmu_regs)) = val;
}

int 
m8820x_cmmu_alive(mmu)
	int mmu;
{
	return (m8820x_cmmu[mmu].cmmu_alive == CMMU_ALIVE);
}

unsigned 
m8820x_cmmu_get(mmu, reg)
	int mmu, reg;
{
	return *(unsigned *volatile)(reg + (char *)(m8820x_cmmu[mmu].cmmu_regs));
}

/*
 * This function is called by the MMU module and pokes values
 * into the CMMU's registers.
 */
void 
m8820x_cmmu_set(reg, val, flags, num, mode, access, addr)
	int reg;
	unsigned val;
	int flags, num, mode, access;
	vm_offset_t addr;
{
	register int mmu;

	if (flags & NUM_CMMU) {
		/*
		 * Special case: user supplied CMMU number directly as argument.
		 * Simply store the value away.
		 */
		/* assert(num < max_cmmus); */
		m8820x_cmmu_store(num, reg, val);
		return;
	}

	/*
	 * We scan all CMMUs to find the matching ones and store the
	 * values there.
	 */
	for (mmu = num*cpu_cmmu_ratio; mmu < (num+1)*cpu_cmmu_ratio; mmu++) {
		if (((flags & MODE_VAL)) &&
		    (m8820x_cmmu[mmu].which != mode))
			continue;
		if (((flags & ACCESS_VAL)) &&
		    (m8820x_cmmu[mmu].cmmu_access != access) &&
		    (m8820x_cmmu[mmu].cmmu_access != CMMU_ACS_BOTH))
			continue;
		if (flags & ADDR_VAL) {
			if (((addr & m8820x_cmmu[mmu].cmmu_addr_mask) == m8820x_cmmu[mmu].cmmu_addr)
			    != m8820x_cmmu[mmu].cmmu_addr_match) {
				continue;
			}
		}
		m8820x_cmmu_store(mmu, reg, val);
	}
}

#ifdef DDB
/*
 * Used by DDB for cache probe functions
 */
unsigned 
m8820x_cmmu_get_by_mode(cpu, mode)
	int cpu, mode;
{
	register int mmu;

	for (mmu = cpu*cpu_cmmu_ratio; mmu < (cpu+1)*cpu_cmmu_ratio; mmu++)
		if (m8820x_cmmu[mmu].which == mode)
			return mmu;
	printf("can't figure out first %s CMMU for CPU %d\n",
	       (mode == DATA_CMMU) ? "data" : "instruction", cpu);
	panic("m8820x_cmmu_get_by_mode");
	/* NOTREACHED */
	return(0);
}
#endif

static char *mmutypes[8] = {
	"Unknown (0)",
	"Unknown (1)",
	"Unknown (2)",
	"Unknown (3)",
	"Unknown (4)",
	"M88200 (16K)",
	"M88204 (64K)",
	"Unknown (7)"
};

/*
 * Should only be called after the calling cpus knows its cpu
 * number and master/slave status . Should be called first
 * by the master, before the slaves are started.
*/
void 
m8820x_cpu_configuration_print(master)
	int master;
{
	int pid = read_processor_identification_register();
	int proctype = (pid & 0xff00) >> 8;
	int procvers = (pid & 0xe) >> 1;
	int mmu, cpu = cpu_number();
	struct simplelock print_lock;

	if (master)
		simple_lock_init(&print_lock);

	simple_lock(&print_lock);

	printf("Processor %d: ", cpu);
	if (proctype)
		printf("Architectural Revision 0x%x UNKNOWN CPU TYPE Version 0x%x\n",
		       proctype, procvers);
	else
		printf("M88100 Version 0x%x\n", procvers);

#ifndef ERRATA__XXX_USR
	if (procvers < 2)
		printf("WARNING: M88100 bug workaround code not enabled!!!\n");
#endif

	for (mmu = cpu*cpu_cmmu_ratio; mmu < (cpu+1)*cpu_cmmu_ratio; mmu++) {
		int idr = m8820x_cmmu_get(mmu, CMMU_IDR);
		int mmuid = (0xe00000 & idr)>>21;

		printf(" %s %s Cache: ",
		       (m8820x_cmmu[mmu].cmmu_access == CMMU_ACS_BOTH) ?  "Spv and User" :
		       ((m8820x_cmmu[mmu].cmmu_access == CMMU_ACS_USER) ? "User        " :
			"Supervisor  "),
		       (m8820x_cmmu[mmu].which == INST_CMMU) ?   "Instruction" :
		       "Data       ");
		if (mmutypes[mmuid][0] == 'U')
			printf("Type 0x%x ", mmuid);
		else
			printf("%s ", mmutypes[mmuid]);
		printf("Version 0x%x\n", (idr & 0x1f0000)>>16);
	}
	printf  (" Configured as %s and started\n", master ? "master" : "slave");

	simple_unlock(&print_lock);
}

/*
 * CMMU initialization routine
 */
void
m8820x_cmmu_init()
{
	unsigned tmp, cmmu_num;
	union cpupid id;
	int cpu;

	for (cpu = 0; cpu < max_cpus; cpu++) {
		cpu_cmmu[cpu].pair[INST_CMMU] = cpu_cmmu[cpu].pair[DATA_CMMU] = 0;
	}

	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++){
		if (m8820x_cmmu_alive(cmmu_num)) {
			id.cpupid = m8820x_cmmu[cmmu_num].cmmu_regs->idr;

			cpu_cmmu[m8820x_cmmu[cmmu_num].cmmu_cpu].pair[m8820x_cmmu[cmmu_num].which] =
			&m8820x_cmmu[cmmu_num];
			/*
			 * Reset cache data....
			 * as per M88200 Manual (2nd Ed.) section 3.11.
			 */
			for (tmp = 0; tmp < 255; tmp++) {
				m8820x_cmmu[cmmu_num].cmmu_regs->sar = tmp << 4;
				m8820x_cmmu[cmmu_num].cmmu_regs->cssp = 0x3f0ff000;
			}

			/* 88204 has additional cache to clear */
			if (id.m88200.type == M88204_ID) {
				for (tmp = 0; tmp < 255; tmp++) {
					m8820x_cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					m8820x_cmmu[cmmu_num].cmmu_regs->cssp1 = 0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					m8820x_cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					m8820x_cmmu[cmmu_num].cmmu_regs->cssp2 = 0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					m8820x_cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					m8820x_cmmu[cmmu_num].cmmu_regs->cssp3 = 0x3f0ff000;
				}
			}

			/*
			 * Set the SCTR, SAPR, and UAPR to some known state
			 * (I don't trust the reset to do it).
			 */
			tmp =
			! CMMU_SCTR_PE |   /* not parity enable */
			! CMMU_SCTR_SE | /* not snoop enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
			m8820x_cmmu[cmmu_num].cmmu_regs->sctr = tmp;

			tmp =
			(0x00000 << PG_BITS) |  /* segment table base address */
			AREA_D_WT |	 /* write through */
			AREA_D_G  | /* global */
			AREA_D_CI | /* cache inhibit */
			! AREA_D_TE ;	/* not translation enable */
			m8820x_cmmu[cmmu_num].cmmu_regs->sapr =
			m8820x_cmmu[cmmu_num].cmmu_regs->uapr = tmp;


#ifdef SHADOW_BATC
			m8820x_cmmu[cmmu_num].batc[0] =
			m8820x_cmmu[cmmu_num].batc[1] =
			m8820x_cmmu[cmmu_num].batc[2] =
			m8820x_cmmu[cmmu_num].batc[3] =
			m8820x_cmmu[cmmu_num].batc[4] =
			m8820x_cmmu[cmmu_num].batc[5] =
			m8820x_cmmu[cmmu_num].batc[6] =
			m8820x_cmmu[cmmu_num].batc[7] = 0;
#endif
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[0] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[1] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[2] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[3] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[4] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[5] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[6] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[7] = 0;
			m8820x_cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_CACHE_INV_ALL;
			m8820x_cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_SUPER_ALL;
			m8820x_cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_USER_ALL;
		}
	}
	/*
	 * Enable snooping...
	 */
	for (cpu = 0; cpu < max_cpus; cpu++) {
		if (!cpu_sets[cpu])
			continue;

		/*
		 * Enable snooping.
		 * We enable it for instruction cmmus as well so that we can have
		 * breakpoints, etc, and modify code.
		 */
		if (brdtyp == BRD_188) {
			tmp =
			! CMMU_SCTR_PE |  /* not parity enable */
			CMMU_SCTR_SE |	/* snoop enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
		} else {
			tmp =
			! CMMU_SCTR_PE |  /* not parity enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
		}
		m8820x_cmmu_set(CMMU_SCTR, tmp, 0, cpu, DATA_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCTR, tmp, 0, cpu, INST_CMMU, 0, 0);

		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL,
			      cpu, INST_CMMU, CMMU_ACS_SUPER, 0);
	}

	/*
	 * Turn on some cache.
	 */
	for (cpu = 0; cpu < max_cpus; cpu++) {
		if (!cpu_sets[cpu])
			continue;
		/*
		 * Enable some caching for the instruction stream.
		 * Can't cache data yet 'cause device addresses can never
		 * be cached, and we don't have those no-caching zones
		 * set up yet....
		 */
		tmp =
		(0x00000 << PG_BITS) | /* segment table base address */
		AREA_D_WT |	  /* write through */
		AREA_D_G  |	  /* global */
		AREA_D_CI |	  /* cache inhibit */
		! AREA_D_TE ;	  /* not translation enable */
		/*
		REGS(cpu, INST_CMMU).sapr = tmp;
		*/
		m8820x_cmmu_set(CMMU_SAPR, tmp, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);

		/*
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
		*/
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL|MODE_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
	}
}

/*
 * Just before poweroff or reset....
 */
void
m8820x_cmmu_shutdown_now()
{
	unsigned tmp;
	unsigned cmmu_num;

	CMMU_LOCK;
	/*
	 * Now set some state as we like...
	 */
	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
		if (brdtyp == BRD_188) {
			tmp =
			! CMMU_SCTR_PE |   /* parity enable */
			! CMMU_SCTR_SE |   /* snoop enable */
			! CMMU_SCTR_PR ;   /* priority arbitration */
		} else {
			tmp =
			! CMMU_SCTR_PE |   /* parity enable */
			! CMMU_SCTR_PR ;   /* priority arbitration */
		}

		m8820x_cmmu[cmmu_num].cmmu_regs->sctr = tmp;

		tmp = 
		(0x00000 << PG_BITS) |  /* segment table base address */
		! AREA_D_WT |	   /* write through */
		! AREA_D_G  |	   /* global */
		AREA_D_CI |	   /* cache inhibit */
		! AREA_D_TE ;	   /* translation disable */

		m8820x_cmmu[cmmu_num].cmmu_regs->sapr = tmp;
		m8820x_cmmu[cmmu_num].cmmu_regs->uapr = tmp;
	}
	CMMU_UNLOCK;
}

#define PARITY_ENABLE
/*
 * enable parity
 */
void 
m8820x_cmmu_parity_enable()
{
#ifdef PARITY_ENABLE
	register int cmmu_num;
	CMMU_LOCK;

	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		if (m8820x_cmmu_alive(cmmu_num)) {
			register unsigned val1 = 
				m8820x_cmmu_get(cmmu_num, CMMU_SCTR);

			/*
			m8820x_cmmu[cmmu_num].cmmu_regs->sctr |= CMMU_SCTR_PE;
			*/
			m8820x_cmmu_set(CMMU_SCTR, val1 | CMMU_SCTR_PE, 
				      NUM_CMMU, cmmu_num, 0, 0, 0);
		}
	}
	CMMU_UNLOCK;
#endif  /* PARITY_ENABLE */
}

/*
 * Find out the CPU number from accessing CMMU
 * Better be at splhigh, or even better, with interrupts
 * disabled.
 */
#define ILLADDRESS	U(0x0F000000) 	/* any faulty address */

unsigned 
m8820x_cmmu_cpu_number()
{
	register unsigned cmmu_no;
	int i;

	CMMU_LOCK;

	for (i=0; i < 10; i++) {
		/* clear CMMU p-bus status registers */
		for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) {
			if (m8820x_cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
			    m8820x_cmmu[cmmu_no].which == DATA_CMMU)
				m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;
		}

		/* access faulting address */
		badwordaddr((vm_offset_t)ILLADDRESS);

		/* check which CMMU reporting the fault  */
		for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) {
			if (m8820x_cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
			    m8820x_cmmu[cmmu_no].which == DATA_CMMU &&
			    m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000) {
				if (m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000) {
					m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;	/* to be clean */
					m8820x_cmmu[cmmu_no].cmmu_alive = CMMU_MARRIED;
					return m8820x_cmmu[cmmu_no].cmmu_cpu;
				}
			}
		}
	}
	panic("m8820x_cmmu_cpu_number: could not determine my cpu number");
	CMMU_UNLOCK;
	return 0; /* to make compiler happy */
}

#if 0
/*
 * Functions that actually modify CMMU registers.
 */
void
m8820x_cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x)
{
	*(unsigned *volatile)(r + (char *)&REGS(cpu,data)) = x;
}

/*
 * cmmu_cpu_lock should be held when called if read
 * the CMMU_SCR or CMMU_SAR.
 */
unsigned
m8820x_cmmu_remote_get(unsigned cpu, unsigned r, unsigned data)
{
	return (*(unsigned *volatile)(r + (char *)&REGS(cpu,data)));
}
#endif 

/* Needs no locking - read only registers */
unsigned
m8820x_cmmu_get_idr(data)
	unsigned data;
{
	int cpu;
	cpu = cpu_number();
	return REGS(cpu,data).idr;
}

void
m8820x_cmmu_set_sapr(ap)
	unsigned ap;
{
	int cpu;
	cpu = cpu_number();

	CMMU_LOCK;
	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;
	m8820x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_SUPER, 0);
	CMMU_UNLOCK;
}

void
m8820x_cmmu_remote_set_sapr(cpu, ap)
	unsigned cpu, ap;
{
	CMMU_LOCK;
	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;
	m8820x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_SUPER, 0);
	CMMU_UNLOCK;
}

void
m8820x_cmmu_set_uapr(ap)
	unsigned ap;
{
	register int s = splhigh();
	int cpu;
	
	cpu = cpu_number();

	CMMU_LOCK;
	/* this functionality also mimiced in m8820x_cmmu_pmap_activate() */
	m8820x_cmmu_set(CMMU_UAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_USER, 0);
	CMMU_UNLOCK;
	splx(s);
}

/*
 * Set batc entry number entry_no to value in 
 * the data or instruction cache depending on data.
 *
 * Except for the cmmu_init, this function, m8820x_cmmu_set_pair_batc_entry,
 * and m8820x_cmmu_pmap_activate are the only functions which may set the
 * batc values.
 */
void
m8820x_cmmu_set_batc_entry(cpu, entry_no, data, value)
	unsigned cpu, entry_no;
	unsigned data;	/* 1 = data, 0 = instruction */
	unsigned value;	/* the value to stuff into the batc */
{
	CMMU_LOCK;
	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, data, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
	CMMU(cpu,data)->batc[entry_no] = value;
#endif
#if 0 /* was for debugging piece (peace?) of mind */
	REGS(cpu,data).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,data).scr = CMMU_FLUSH_USER_ALL;
#endif
	CMMU_UNLOCK;
}

/*
 * Set batc entry number entry_no to value in 
 * the data and instruction cache for the named CPU.
 */
void
m8820x_cmmu_set_pair_batc_entry(cpu, entry_no, value)
	unsigned cpu, entry_no;
	unsigned value;	/* the value to stuff into the batc */
{
	CMMU_LOCK;
	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, DATA_CMMU, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
	CMMU(cpu,DATA_CMMU)->batc[entry_no] = value;
#endif
	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, INST_CMMU, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
	CMMU(cpu,INST_CMMU)->batc[entry_no] = value;
#endif

#if 0  /* was for debugging piece (peace?) of mind */
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
#endif
	CMMU_UNLOCK;
}

/*
 * Functions that invalidate TLB entries.
 */

/*
 *	flush any tlb
 *	Some functionality mimiced in m8820x_cmmu_pmap_activate.
 */
void
m8820x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size)
	unsigned cpu, kernel;
	vm_offset_t vaddr;
	int size;
{
	register int s = splhigh();
	CMMU_LOCK;

	if (cpu > max_cpus) {
		cpu = cpu_number();
	}

	if ((unsigned)size > PAGE_SIZE) {
		m8820x_cmmu_set(CMMU_SCR, kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL, ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, 0);
	} else { /* a page or smaller */
		m8820x_cmmu_set(CMMU_SAR, vaddr, ADDR_VAL|ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
		m8820x_cmmu_set(CMMU_SCR, kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE, ADDR_VAL|ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
	}
	CMMU_UNLOCK;
	splx(s);
}

/*
 *	flush my personal tlb
 */
void
m8820x_cmmu_flush_tlb(kernel, vaddr, size)
	unsigned kernel;
	vm_offset_t vaddr;
	int size;
{
	int cpu;
	cpu = cpu_number();
	m8820x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
}

/*
 * New fast stuff for pmap_activate.
 * Does what a few calls used to do.
 * Only called from pmap.c's _pmap_activate().
 */
void
m8820x_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc)
	unsigned cpu, uapr;
	batc_template_t i_batc[BATC_MAX];
	batc_template_t d_batc[BATC_MAX];
{
	int entry_no;
	CMMU_LOCK;

	/* the following is from m8820x_cmmu_set_uapr */
	m8820x_cmmu_set(CMMU_UAPR, uapr, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_USER, 0);

	for (entry_no = 0; entry_no < BATC_MAX; entry_no++) {
		m8820x_cmmu_set(CMMU_BWP(entry_no), i_batc[entry_no].bits, MODE_VAL|ACCESS_VAL,
			      cpu, INST_CMMU, CMMU_ACS_USER, 0);
		m8820x_cmmu_set(CMMU_BWP(entry_no), d_batc[entry_no].bits, MODE_VAL|ACCESS_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
		CMMU(cpu,INST_CMMU)->batc[entry_no] = i_batc[entry_no].bits;
		CMMU(cpu,DATA_CMMU)->batc[entry_no] = d_batc[entry_no].bits;
#endif
	}

	/*
	 * Flush the user TLB.
	 * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
	 * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
	 */
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_USER_ALL, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_USER, 0);
	CMMU_UNLOCK;
}

/*
 * Functions that invalidate caches.
 *
 * Cache invalidates require physical addresses.  Care must be exercised when
 * using segment invalidates.  This implies that the starting physical address
 * plus the segment length should be invalidated.  A typical mistake is to
 * extract the first physical page of a segment from a virtual address, and
 * then expecting to invalidate when the pages are not physically contiguous.
 *
 * We don't push Instruction Caches prior to invalidate because they are not
 * snooped and never modified (I guess it doesn't matter then which form
 * of the command we use then).
 */

/*
 *	flush both Instruction and Data caches
 */
void
m8820x_cmmu_flush_remote_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
	CMMU_LOCK;

#if !defined(BROKEN_MMU_MASK)

	if (size < 0 || size > NBSG ) {
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, 0,
			      cpu, 0, 0, 0);
	} else if (size <= 16) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE , ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE , ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, 0,
			      cpu, 0, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, 0,
			      cpu, 0, 0, 0);
	}

#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, 0,
		      cpu, 0, 0, 0);
#endif /* !BROKEN_MMU_MASK */
	CMMU_UNLOCK;
	splx(s);
}

/*
 *	flush both Instruction and Data caches
 */
void
m8820x_cmmu_flush_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	int cpu = cpu_number();
	m8820x_cmmu_flush_remote_cache(cpu, physaddr, size);
}

/*
 *	flush Instruction caches
 */
void
m8820x_cmmu_flush_remote_inst_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
	CMMU_LOCK;

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {

		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	}
#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
#endif /* !BROKEN_MMU_MASK */

	CMMU_UNLOCK;
	splx(s);
}

/*
 *	flush Instruction caches
 */
void
m8820x_cmmu_flush_inst_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	int cpu;
	cpu = cpu_number();
	m8820x_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
}

void
m8820x_cmmu_flush_remote_data_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
	CMMU_LOCK;

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {

		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= 16) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);

	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}
#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
#endif /* !BROKEN_MMU_MASK */
	CMMU_UNLOCK;
	splx(s);
}

/*
 * flush data cache
 */ 
void
m8820x_cmmu_flush_data_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{ 
	int cpu;
	cpu = cpu_number();
	m8820x_cmmu_flush_remote_data_cache(cpu, physaddr, size);
}

/*
 * sync dcache (and icache too)
 */
void
m8820x_cmmu_sync_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
	int cpu;
	
	CMMU_LOCK;
	cpu = cpu_number();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}
#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
#endif /* !BROKEN_MMU_MASK */
	splx(s);
	CMMU_UNLOCK;
}

void 
m8820x_cmmu_sync_inval_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();
	CMMU_LOCK;

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}

#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
#endif /* !BROKEN_MMU_MASK */
	CMMU_UNLOCK;
	splx(s);
}

void
m8820x_cmmu_inval_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();
	CMMU_LOCK;

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}
#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
#endif /* !BROKEN_MMU_MASK */
	CMMU_UNLOCK;
	splx(s);
}

void
m8820x_dma_cachectl(va, size, op)
	vm_offset_t va;
	int size, op;
{
#if !defined(BROKEN_MMU_MASK)
	int count;

	while (size) {
		count = NBPG - ((int)va & PGOFSET);

		if (size < count)
			count = size;

		if (op == DMA_CACHE_SYNC)
			m8820x_cmmu_sync_cache(kvtop(va), count);
		else if (op == DMA_CACHE_SYNC_INVAL)
			m8820x_cmmu_sync_inval_cache(kvtop(va), count);
		else
			m8820x_cmmu_inval_cache(kvtop(va), count);

		va = (vm_offset_t)((int)va + count);
		size -= count;
	}
#else

	if (op == DMA_CACHE_SYNC)
		m8820x_cmmu_sync_cache(kvtop(va), size);
	else if (op == DMA_CACHE_SYNC_INVAL)
		m8820x_cmmu_sync_inval_cache(kvtop(va), size);
	else
		m8820x_cmmu_inval_cache(kvtop(va), size);
#endif /* !BROKEN_MMU_MASK */
}

#ifdef DDB
union ssr {
   unsigned bits;
   struct {
      unsigned  :16,
      ce:1,
      be:1,
      :4,
      wt:1,
      sp:1,
      g:1,
      ci:1,
      :1,
      m:1,
      u:1,
      wp:1,
      bh:1,
      v:1;
   } field;
};

union cssp {
   unsigned bits;
   struct {
      unsigned   : 2,
      l: 6,
      d3: 1,
      d2: 1,
      d1: 1,
      d0: 1,
      vv3: 2,
      vv2: 2,
      vv1: 2,
      vv0: 2,
      :12;
   } field;
};

union batcu {
   unsigned bits;
   struct {              /* block address translation register */
      unsigned int
      lba:13,            /* logical block address */
      pba:13,            /* physical block address */
      s:1,               /* supervisor */
      wt:4,              /* write through */
      g:1,               /* global */
      ci:1,              /* cache inhibit */
      wp:1,              /* write protect */
      v:1;               /* valid */
   } field;
};

   #define VV_EX_UNMOD		0
   #define VV_EX_MOD		1
   #define VV_SHARED_UNMOD		2
   #define VV_INVALID		3

   #define D(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.d3 : \
	 ((LINE) == 2 ? (UNION).field.d2 : \
	  ((LINE) == 1 ? (UNION).field.d1 : \
	   ((LINE) == 0 ? (UNION).field.d0 : ~0))))
   #define VV(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.vv3 : \
	 ((LINE) == 2 ? (UNION).field.vv2 : \
	  ((LINE) == 1 ? (UNION).field.vv1 : \
	   ((LINE) == 0 ? (UNION).field.vv0 : ~0))))

   #undef VEQR_ADDR
   #define  VEQR_ADDR 0
/*
 * Show (for debugging) how the given CMMU translates the given ADDRESS.
 * If cmmu == -1, the data cmmu for the current cpu is used.
 */
void
m8820x_cmmu_show_translation(address, supervisor_flag, verbose_flag, cmmu_num)
	unsigned address, supervisor_flag, verbose_flag;
	int cmmu_num;
{
	/*
	 * A virtual address is split into three fields. Two are used as
	 * indicies into tables (segment and page), and one is an offset into
	 * a page of memory.
	 */
	union {
		unsigned bits;
		struct {
			unsigned segment_table_index:SDT_BITS,
			page_table_index:PDT_BITS,
			page_offset:PG_BITS;
		} field;
	} virtual_address;
	unsigned value;

	if (verbose_flag)
		DEBUG_MSG("-------------------------------------------\n");



	/****** ACCESS PROPER CMMU or THREAD ***********/
#if 0 /* no thread */
	if (thread != 0) {
		/* the following tidbit from _pmap_activate in m88k/pmap.c */
		register apr_template_t apr_data;
		supervisor_flag = 0; /* thread implies user */

		if (thread->task == 0) {
			DEBUG_MSG("[thread %x has empty task pointer]\n", thread);
			return;
		} else if (thread->task->map == 0) {
			DEBUG_MSG("[thread/task %x/%x has empty map pointer]\n",
				  thread, thread->task);
			return;
		} else if (thread->task->map->pmap == 0) {
			DEBUG_MSG("[thread/task/map %x/%x/%x has empty pmap pointer]\n",
				  thread, thread->task, thread->task->map);
			return;
		}
		if (thread->task->map->pmap->lock.lock_data) {
			DEBUG_MSG("[Warning: thread %x's task %x's map %x's "
				  "pmap %x is locked]\n", thread, thread->task,
				  thread->task->map, thread->task->map->pmap);
		}
		apr_data.bits = 0;
		apr_data.field.st_base = atop(thread->task->map->pmap->sdt_paddr);
		apr_data.field.wt = 0;
		apr_data.field.g  = 1;
		apr_data.field.ci = 0;
		apr_data.field.te = 1;
		value = apr_data.bits;
		if (verbose_flag) {
			DEBUG_MSG("[thread %x task %x map %x pmap %x UAPR is %x]\n",
				  thread, thread->task, thread->task->map,
				  thread->task->map->pmap, value);
		}
	} else
#endif /* 0 */
	{
		if (cmmu_num == -1) {
			int cpu = cpu_number();
			if (cpu_cmmu[cpu].pair[DATA_CMMU] == 0) {
				DEBUG_MSG("ack! can't figure my own data cmmu number.\n");
				return;
			}
			cmmu_num = cpu_cmmu[cpu].pair[DATA_CMMU] - m8820x_cmmu;
			if (verbose_flag)
				DEBUG_MSG("The data cmmu for cpu#%d is cmmu#%d.\n",
					  0, cmmu_num);
		} else if (cmmu_num < 0 || cmmu_num >= MAX_CMMUS) {
			DEBUG_MSG("invalid cpu number [%d]... must be in range [0..%d]\n",
				  cmmu_num, MAX_CMMUS - 1);

			return;
		}

		if (m8820x_cmmu[cmmu_num].cmmu_alive == 0) {
			DEBUG_MSG("warning: cmmu %d is not alive.\n", cmmu_num);
#if 0
			return;
#endif
		}

		if (!verbose_flag) {
			if (!(m8820x_cmmu[cmmu_num].cmmu_regs->sctr & CMMU_SCTR_SE))
				DEBUG_MSG("WARNING: snooping not enabled for CMMU#%d.\n",
					  cmmu_num);
		} else {
			int i;
			for (i=0; i<MAX_CMMUS; i++)
				if ((i == cmmu_num || m8820x_cmmu[i].cmmu_alive) &&
				    (verbose_flag>1 || !(m8820x_cmmu[i].cmmu_regs->sctr&CMMU_SCTR_SE))) {
					DEBUG_MSG("CMMU#%d (cpu %d %s) snooping %s\n", i,
						  m8820x_cmmu[i].cmmu_cpu, m8820x_cmmu[i].which ? "data" : "inst",
						  (m8820x_cmmu[i].cmmu_regs->sctr & CMMU_SCTR_SE) ? "on":"OFF");
				}
		}

		if (supervisor_flag)
			value = m8820x_cmmu[cmmu_num].cmmu_regs->sapr;
		else
			value = m8820x_cmmu[cmmu_num].cmmu_regs->uapr;

	}

	/******* LOOK AT THE BATC ** (if not a thread) **************/
#if 0
#ifdef SHADOW_BATC
	if (thread == 0) {
		int i;
		union batcu batc;
		for (i = 0; i < 8; i++) {
			batc.bits = m8820x_cmmu[cmmu_num].batc[i];
			if (batc.field.v == 0) {
				if (verbose_flag>1)
					DEBUG_MSG("cmmu #%d batc[%d] invalid.\n", cmmu_num, i);
			} else {
				DEBUG_MSG("cmmu#%d batc[%d] v%08x p%08x", cmmu_num, i,
					  batc.field.lba << 18, batc.field.pba);
				if (batc.field.s)  DEBUG_MSG(", supervisor");
				if (batc.field.wt) DEBUG_MSG(", wt.th");
				if (batc.field.g)  DEBUG_MSG(", global");
				if (batc.field.ci) DEBUG_MSG(", cache inhibit");
				if (batc.field.wp) DEBUG_MSG(", write protect");
			}
		}
	}
#endif	/* SHADOW_BATC */
#endif	/* 0 */

	/******* SEE WHAT A PROBE SAYS (if not a thread) ***********/
#if 0
	if (thread == 0)
#endif /* 0 */
	{
		union ssr ssr;
		struct cmmu_regs *cmmu_regs = m8820x_cmmu[cmmu_num].cmmu_regs;
		cmmu_regs->sar = address;
		cmmu_regs->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;
		ssr.bits = cmmu_regs->ssr;
		if (verbose_flag > 1)
			DEBUG_MSG("probe of 0x%08x returns ssr=0x%08x\n",
				  address, ssr.bits);
		if (ssr.field.v)
			DEBUG_MSG("PROBE of 0x%08x returns phys=0x%x",
				  address, cmmu_regs->sar);
		else
			DEBUG_MSG("PROBE fault at 0x%x", cmmu_regs->pfADDRr);
		if (ssr.field.ce) DEBUG_MSG(", copyback err");
		if (ssr.field.be) DEBUG_MSG(", bus err");
		if (ssr.field.wt) DEBUG_MSG(", writethrough");
		if (ssr.field.sp) DEBUG_MSG(", sup prot");
		if (ssr.field.g)  DEBUG_MSG(", global");
		if (ssr.field.ci) DEBUG_MSG(", cache inhibit");
		if (ssr.field.m)  DEBUG_MSG(", modified");
		if (ssr.field.u)  DEBUG_MSG(", used");
		if (ssr.field.wp) DEBUG_MSG(", write prot");
		if (ssr.field.bh) DEBUG_MSG(", BATC");
		DEBUG_MSG(".\n");
	}

	/******* INTERPRET AREA DESCRIPTOR *********/
	{
		union apr_template apr_template;
		apr_template.bits = value;
		if (verbose_flag > 1) {
			DEBUG_MSG("CMMU#%d", cmmu_num);
#if 0
			if (thread == 0)
				DEBUG_MSG("CMMU#%d", cmmu_num);
			else
				DEBUG_MSG("THREAD %x", thread);
#endif /* 0 */
			DEBUG_MSG(" %cAPR is 0x%08x\n",
				  supervisor_flag ? 'S' : 'U', apr_template.bits);
		}
		DEBUG_MSG("CMMU#%d", cmmu_num);
#if 0
		if (thread == 0)
			DEBUG_MSG("CMMU#%d", cmmu_num);
		else
			DEBUG_MSG("THREAD %x", thread);
#endif /* 0 */
		DEBUG_MSG(" %cAPR: SegTbl: 0x%x000p",
			  supervisor_flag ? 'S' : 'U', apr_template.field.st_base);
		if (apr_template.field.wt) DEBUG_MSG(", WTHRU");
		else			   DEBUG_MSG(", !wthru");
		if (apr_template.field.g)  DEBUG_MSG(", GLOBAL");
		else			   DEBUG_MSG(", !global");
		if (apr_template.field.ci) DEBUG_MSG(", $INHIBIT");
		else			   DEBUG_MSG(", $ok");
		if (apr_template.field.te) DEBUG_MSG(", VALID");
		else			   DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");

		/* if not valid, done now */
		if (apr_template.field.te == 0) {
			DEBUG_MSG("<would report an error, valid bit not set>\n");

			return;
		}

		value = apr_template.field.st_base << PG_BITS; /* now point to seg page */
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	virtual_address.bits = address;

	/****** ACCESS SEGMENT TABLE AND INTERPRET SEGMENT DESCRIPTOR  *******/
	{
		sdt_entry_t sdt;
		if (verbose_flag)
			DEBUG_MSG("will follow to entry %d of page at 0x%x...\n",
				  virtual_address.field.segment_table_index, value);
		value |= virtual_address.field.segment_table_index *
			 sizeof(sdt_entry_t);

		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("ERROR: unable to access page at 0x%08x.\n", value);
			return;
		}

		sdt = *(sdt_entry_t *)value;
		if (verbose_flag > 1)
			DEBUG_MSG("SEG DESC @@0x%x is 0x%08x\n", value, sdt);
		DEBUG_MSG("SEG DESC @@0x%x: PgTbl: 0x%x000",
			  value, PG_PFNUM(sdt));
		if (sdt & CACHE_WT)		    DEBUG_MSG(", WTHRU");
		else				    DEBUG_MSG(", !wthru");
		if (sdt & SG_SO)		    DEBUG_MSG(", S-PROT");
		else				    DEBUG_MSG(", UserOk");
		if (sdt & CACHE_GLOBAL)		    DEBUG_MSG(", GLOBAL");
		else				    DEBUG_MSG(", !global");
		if (sdt & CACHE_INH)		    DEBUG_MSG(", $INHIBIT");
		else				    DEBUG_MSG(", $ok");
		if (sdt & SG_PROT)		    DEBUG_MSG(", W-PROT");
		else				    DEBUG_MSG(", WriteOk");
		if (sdt & SG_V)			    DEBUG_MSG(", VALID");
		else				    DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");

		/* if not valid, done now */
		if (!(sdt & SG_V)) {
			DEBUG_MSG("<would report an error, STD entry not valid>\n");
			return;
		}

		value = ptoa(PG_PFNUM(sdt));
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	/******* PAGE TABLE *********/
	{
		pt_entry_t pte;
		if (verbose_flag)
			DEBUG_MSG("will follow to entry %d of page at 0x%x...\n",
				  virtual_address.field.page_table_index, value);
		value |= virtual_address.field.page_table_index *
			 sizeof(pt_entry_t);

		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("error: unable to access page at 0x%08x.\n", value);

			return;
		}

		pte = *(pt_entry_t *)value;
		if (verbose_flag > 1)
			DEBUG_MSG("PAGE DESC @@0x%x is 0x%08x.\n", value, pte);
		DEBUG_MSG("PAGE DESC @@0x%x: page @@%x000",
			  value, PG_PFNUM(pte));
		if (pte & PG_W)			DEBUG_MSG(", WIRE");
		else				DEBUG_MSG(", !wire");
		if (pte & CACHE_WT)		DEBUG_MSG(", WTHRU");
		else				DEBUG_MSG(", !wthru");
		if (pte & PG_SO)		DEBUG_MSG(", S-PROT");
		else				DEBUG_MSG(", UserOk");
		if (pte & CACHE_GLOBAL)		DEBUG_MSG(", GLOBAL");
		else				DEBUG_MSG(", !global");
		if (pte & CACHE_INH)		DEBUG_MSG(", $INHIBIT");
		else				DEBUG_MSG(", $ok");
		if (pte & PG_M)			DEBUG_MSG(", MOD");
		else				DEBUG_MSG(", !mod");
		if (pte & PG_U)			DEBUG_MSG(", USED");
		else				DEBUG_MSG(", !used");
		if (pte & PG_PROT)		DEBUG_MSG(", W-PROT");
		else				DEBUG_MSG(", WriteOk");
		if (pte & PG_V)			DEBUG_MSG(", VALID");
		else				DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");

		/* if not valid, done now */
		if (!(pte & PG_V)) {
			DEBUG_MSG("<would report an error, PTE entry not valid>\n");
			return;
		}

		value = ptoa(PG_PFNUM(pte));
		if (verbose_flag)
			DEBUG_MSG("will follow to byte %d of page at 0x%x...\n",
				  virtual_address.field.page_offset, value);
		value |= virtual_address.field.page_offset;

		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("error: unable to access page at 0x%08x.\n", value);
			return;
		}
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	DEBUG_MSG("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);

}

void
m8820x_cmmu_cache_state(addr, supervisor_flag)
	unsigned addr, supervisor_flag;
{
	static char *vv_name[4] =
	{"exclu-unmod", "exclu-mod", "shared-unmod", "invalid"};
	int cmmu_num;

	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
		union ssr ssr;
		union cssp cssp;
		struct cmmu_regs *R;
		unsigned tag, line;
		if (!m8820x_cmmu[cmmu_num].cmmu_alive)
			continue;
		R = m8820x_cmmu[cmmu_num].cmmu_regs;
		DEBUG_MSG("cmmu #%d %s cmmu for cpu %d.\n", cmmu_num,
			  m8820x_cmmu[cmmu_num].which ? "data" : "inst", 
			  m8820x_cmmu[cmmu_num].cmmu_cpu);
		R->sar = addr;
		R->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;

		ssr.bits = R->ssr;
		if (!ssr.field.v) {
			DEBUG_MSG("PROBE of 0x%08x faults.\n",addr);
			continue;
		}
		DEBUG_MSG("PROBE of 0x%08x returns phys=0x%x", addr, R->sar);

		tag = R->sar & ~0xfff;
		cssp.bits = R->cssp;

		/* check to see if any of the tags for the set match the address */
		for (line = 0; line < 4; line++) {
			if (VV(cssp, line) == VV_INVALID) {
				DEBUG_MSG("line %d invalid.\n", line);
				continue; /* line is invalid */
			}
			if (D(cssp, line)) {
				DEBUG_MSG("line %d disabled.\n", line);
				continue; /* line is disabled */
			}

			if ((R->ctp[line] & ~0xfff) != tag) {
				DEBUG_MSG("line %d address tag is %x.\n", line,
					  (R->ctp[line] & ~0xfff));
				continue;
			}
			DEBUG_MSG("found in line %d as %08x (%s).\n",
				  line, R->cdp[line], vv_name[VV(cssp, line)]);
		}
	}

}

#endif /* DDB */

void
m8820x_show_cmmu_info(addr)
	unsigned addr;
{
	int cmmu_num;
	m8820x_cmmu_cache_state(addr, 1);

	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
		if (m8820x_cmmu[cmmu_num].cmmu_alive) {
			DEBUG_MSG("cmmu #%d %s cmmu for cpu %d: ", cmmu_num,
				  m8820x_cmmu[cmmu_num].which ? "data" : "inst", 
				  m8820x_cmmu[cmmu_num].cmmu_cpu);
			m8820x_cmmu_show_translation(addr, 1, 0, cmmu_num);
		}
}

#endif /* M88100 */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.15 2003/08/09 21:19:59 miod Exp $	*/
d2133 2
a2150 1
#endif /* DDB */
@


1.1.1.3
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.16 2003/08/21 20:45:43 miod Exp $	*/
d60 1
d379 10
a388 7
	if (bd_config[vme188_config].supported) {
		/* 187 has a fixed configuration, no need to print it */
		if (brdtyp == BRD_188) {
			printf("MVME188 board configuration #%X "
			    "(%d CPUs %d CMMUs)\n",
			    vme188_config, max_cpus, max_cmmus);
		}
d390 5
a394 4
	} else {
		panic("unsupported MVME%x board configuration "
		    "#%X (%d CPUs %d CMMUs)",
		    brdtyp, vme188_config, max_cpus, max_cmmus);
d396 1
d609 1
d2150 1
@


1.1.1.4
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.18 2003/09/16 20:53:41 miod Exp $	*/
d774 6
a779 7
	printf("cpu%d: ", cpu);
	if (proctype != 0) {
		printf("unknown model arch 0x%x rev 0x%x\n",
		    proctype, procvers);
		simple_unlock(&print_lock);
		return;
	}
d781 3
a783 4
	printf("M88100 rev 0x%x", procvers);
#if 0	/* not useful yet */
	if (brdtyp == BRD_188)
		printf(", %s", master ? "master" : "slave");
a784 1
	printf(", %d CMMU", cpu_cmmu_ratio);
d786 1
a786 2
	for (mmu = cpu * cpu_cmmu_ratio; mmu < (cpu + 1) * cpu_cmmu_ratio;
	    mmu++) {
a788 6
		int access = m8820x_cmmu[mmu].cmmu_access;

		if ((mmu - cpu * cpu_cmmu_ratio) % 2 == 0)
			printf("\ncpu%d: ", cpu);
		else
			printf(", ");
d790 6
d797 1
a797 1
			printf("unknown model id 0x%x", mmuid);
d799 2
a800 6
			printf("%s", mmutypes[mmuid]);
		printf(" rev 0x%x, %s %scache",
		    (idr & 0x1f0000) >> 16,
		    access == CMMU_ACS_BOTH ? "global" :
		    (access == CMMU_ACS_USER ? "user" : "sup"),
		    m8820x_cmmu[mmu].which == INST_CMMU ? "I" : "D");
d802 1
a802 14
	printf("\n");

#ifndef ERRATA__XXX_USR
	{
		static int errata_warn = 0;

		if (proctype != 0 && procvers < 2) {
			if (!errata_warn++)
				printf("WARNING: M88100 bug workaround code "
				    "not enabled.\nPlease recompile the kernel "
				    "with option ERRATA__XXX_USR !\n");
		}
	}
#endif
d856 4
a859 4
			tmp = 0 & ~(
			    CMMU_SCTR_PE |   /* not parity enable */
			    CMMU_SCTR_SE | /* not snoop enable */
			    CMMU_SCTR_PR);  /* not priority arbitration */
d862 6
a867 2
			tmp = ((0x00000 << PG_BITS) | AREA_D_WT | AREA_D_G |
			    AREA_D_CI) & ~AREA_D_TE;
d908 4
a911 1
			tmp = CMMU_SCTR_SE & ~(CMMU_SCTR_PE | CMMU_SCTR_PR);
d913 3
a915 1
			tmp = 0 & ~(CMMU_SCTR_PE | CMMU_SCTR_PR);
d938 9
a946 2
		tmp = ((0x00000 << PG_BITS) | AREA_D_WT | AREA_D_G | AREA_D_CI)
		    & ~AREA_D_TE;
d950 3
d973 4
a976 1
			tmp = 0 & ~(CMMU_SCTR_PE | CMMU_SCTR_SE | CMMU_SCTR_PR);
d978 3
a980 1
			tmp = 0 & ~(CMMU_SCTR_PE | CMMU_SCTR_PR);
d985 6
a990 2
		tmp = ((0x00000 << PG_BITS) | AREA_D_CI) &
		    ~(AREA_D_WT | AREA_D_G | AREA_D_TE);
d1030 1
a1030 1
#define ILLADDRESS	0x0F000000 	/* any faulty address */
d1069 21
d1164 4
d1192 6
@


1.1.1.5
log
@cvs is playing games with me.

@@@@@@ CONSIDER THE TREE LOCKED NOW @@@@@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.19 2003/09/26 22:27:26 miod Exp $	*/
d223 9
a231 9
	printf("table @@ 0x%x000", PG_PFNUM(value));
	if (value & CACHE_WT)
		printf(", writethrough");
	if (value & CACHE_GLOBAL)
		printf(", global");
	if (value & CACHE_INH)
		printf(", cache inhibit");
	if (value & APR_V)
		printf(", valid");
d1219 2
a1220 2
	u_int32_t i_batc[BATC_MAX];
	u_int32_t d_batc[BATC_MAX];
d1230 4
a1233 4
		m8820x_cmmu_set(CMMU_BWP(entry_no), i_batc[entry_no],
		    MODE_VAL | ACCESS_VAL, cpu, INST_CMMU, CMMU_ACS_USER, 0);
		m8820x_cmmu_set(CMMU_BWP(entry_no), d_batc[entry_no],
		    MODE_VAL | ACCESS_VAL, cpu, DATA_CMMU, CMMU_ACS_USER, 0);
d1235 2
a1236 2
		CMMU(cpu,INST_CMMU)->batc[entry_no] = i_batc[entry_no];
		CMMU(cpu,DATA_CMMU)->batc[entry_no] = d_batc[entry_no];
d1720 1
a1720 1
	u_int32_t value;
d1730 2
a1731 1
		/* the following tidbit from pmap_activate() */
d1751 7
a1757 2
		value = CACHE_GLOBAL | APR_V |
		    (atop(thread->task->map->pmap->sdt_paddr) << PG_SHIFT);
d1870 2
d1881 1
a1881 1
				  supervisor_flag ? 'S' : 'U', value);
d1891 10
a1900 10
			  supervisor_flag ? 'S' : 'U', PG_PFNUM(value));
		if (value & CACHE_WT)
			DEBUG_MSG(", WTHRU");
		if (value & CACHE_GLOBAL)
			DEBUG_MSG(", GLOBAL");
		if (value & CACHE_INH)
			DEBUG_MSG(", INHIBIT");
		if (value & APR_V)
			DEBUG_MSG(", VALID");
		DEBUG_MSG("\n");
d1903 1
a1903 1
		if ((value & APR_V) == 0) {
d1909 1
a1909 1
		value &= PG_FRAME;	/* now point to seg page */
@


1.1.1.6
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.24 2003/12/19 22:30:18 miod Exp $	*/
d68 1
a72 1
#include <machine/m8820x.h>
d76 3
a80 5
/*
 * On some versions of the 88200, page size flushes don't work. I am using
 * sledge hammer approach till I find for sure which ones are bad XXX nivas
 */
#define BROKEN_MMU_MASK
d82 3
a84 1
#undef	SHADOW_BATC		/* don't use BATCs for now XXX nivas */
d89 1
a89 1
#define dprintf(_X_) \
d91 1
a91 1
		if (m8820x_debuglevel & DB_CMMU) { \
d99 3
a101 26
#define dprintf(_X_) do { } while (0)
#endif

void m8820x_cmmu_init(void);
void m8820x_setup_board_config(void);
void m8820x_cpu_configuration_print(int);
void m8820x_cmmu_shutdown_now(void);
void m8820x_cmmu_parity_enable(void);
unsigned m8820x_cmmu_cpu_number(void);
void m8820x_cmmu_remote_set_sapr(unsigned, unsigned);
void m8820x_cmmu_set_uapr(unsigned);
void m8820x_cmmu_set_pair_batc_entry(unsigned, unsigned, unsigned);
void m8820x_cmmu_flush_remote_tlb(unsigned, unsigned, vaddr_t, vsize_t);
void m8820x_cmmu_flush_tlb(unsigned, vaddr_t, vsize_t);
void m8820x_cmmu_pmap_activate(unsigned, unsigned,
    u_int32_t i_batc[BATC_MAX], u_int32_t d_batc[BATC_MAX]);
void m8820x_cmmu_flush_remote_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_cache(paddr_t, psize_t);
void m8820x_cmmu_flush_remote_inst_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_inst_cache(paddr_t, psize_t);
void m8820x_cmmu_flush_remote_data_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_data_cache(paddr_t, psize_t);
void m8820x_dma_cachectl(vaddr_t, vsize_t, int);
void m8820x_cmmu_dump_config(void);
void m8820x_cmmu_show_translation(unsigned, unsigned, unsigned, int);
void m8820x_show_apr(unsigned);
d106 1
d108 2
d114 2
d118 1
d131 1
a131 1
	m8820x_cmmu_dump_config,
d133 3
a135 9
#else
	NULL,
	NULL,
#endif
#ifdef DEBUG
	m8820x_show_apr,
#else
	NULL,
#endif
d139 18
a156 18
   /* base + $000 */volatile unsigned idr;
   /* base + $004 */volatile unsigned scr;
   /* base + $008 */volatile unsigned ssr;
   /* base + $00C */volatile unsigned sar;
   /*             */unsigned padding1[0x3D];
   /* base + $104 */volatile unsigned sctr;
   /* base + $108 */volatile unsigned pfSTATUSr;
   /* base + $10C */volatile unsigned pfADDRr;
   /*             */unsigned padding2[0x3C];
   /* base + $200 */volatile unsigned sapr;
   /* base + $204 */volatile unsigned uapr;
   /*             */unsigned padding3[0x7E];
   /* base + $400 */volatile unsigned bwp[8];
   /*             */unsigned padding4[0xF8];
   /* base + $800 */volatile unsigned cdp[4];
   /*             */unsigned padding5[0x0C];
   /* base + $840 */volatile unsigned ctp[4];
   /*             */unsigned padding6[0x0C];
d161 5
a165 5
   /*             */ unsigned padding7[0x03];
   /* base + $890 */volatile unsigned cssp1;
   /*             */unsigned padding8[0x03];
   /* base + $8A0 */volatile unsigned cssp2;
   /*             */unsigned padding9[0x03];
d171 5
a175 5
	unsigned char	cmmu_cpu;	/* cpu number it is attached to */
	unsigned char	which;		/* either INST_CMMU || DATA_CMMU */
	unsigned char	cmmu_access;	/* either CMMU_ACS_{SUPER,USER,BOTH} */
	unsigned char	cmmu_alive;
#define CMMU_DEAD	0		/* This cmmu is not there */
d177 1
d179 3
a181 3
	vaddr_t		cmmu_addr;	/* address range */
	vaddr_t		cmmu_addr_mask;	/* address mask */
	int		cmmu_addr_match;/* return value of address comparison */
d183 1
a183 1
	unsigned batc[BATC_MAX];
d185 1
a185 2
};

d193 5
a197 2
#ifdef SHADOW_BATC
/* CMMU(cpu,data) is the cmmu struct for the named cpu's indicated cmmu.  */
d199 1
a199 1
#endif
d201 6
a206 14
/* local prototypes */
void m8820x_cmmu_set(int, unsigned, int, int, int, int, vaddr_t);
void m8820x_cmmu_sync_cache(paddr_t, psize_t);
void m8820x_cmmu_sync_inval_cache(paddr_t, psize_t);
void m8820x_cmmu_inval_cache(paddr_t, psize_t);

/* Flags passed to m8820x_cmmu_set() */
#define MODE_VAL		0x01
#define ACCESS_VAL		0x02
#define ADDR_VAL		0x04

#define	m8820x_cmmu_store(mmu, reg, val) \
	*(unsigned *volatile)((reg) + (char *)(m8820x_cmmu[(mmu)].cmmu_regs)) =\
	    (val)
d208 1
a208 2
#define m8820x_cmmu_get(mmu, reg) \
	*(unsigned *volatile)(reg + (char *)(m8820x_cmmu[mmu].cmmu_regs))
d210 8
a217 2
#define m8820x_cmmu_alive(mmu) \
	(m8820x_cmmu[mmu].cmmu_alive != CMMU_DEAD)
a218 1
#ifdef DEBUG
a233 1
#endif
a282 1
#ifdef MVME188
d287 1
a287 1
const struct board_config {
d291 2
a292 1
} bd_config[] = {
a310 1
#endif
d318 18
a335 9
	/* address, cpu, mode, access, alive, addr, mask */
	{(struct cmmu_regs *)VME_CMMU_I0, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_D0, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_I1, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_D1, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_I2, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_D2, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_I3, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_D3, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0}
d342 1
a342 4
/*
 * This routine sets up the CPU/CMMU configuration.
 */
void
d345 1
a345 9
	int num, cmmu_num;
	int vme188_config;
	struct cmmu_regs *cr;
#ifdef MVME188
	int val1, val2;
	u_int32_t *volatile whoami;
	unsigned long *volatile pcnfa;
	unsigned long *volatile pcnfb;
#endif
d351 1
a351 2
		/* There is no WHOAMI reg on MVME187 - fake it... */
		vme188_config = 10;
d368 1
a368 1
		whoami = (u_int32_t *volatile)MVME188_WHOAMI;
d370 1
a370 1
		dprintf(("m8820x_setup_board_config: WHOAMI @@ 0x%08x holds value 0x%08x vme188_config = %d\n",
a376 1

a377 2

#ifdef MVME188
d385 1
d391 18
a408 1
#endif
d413 10
a422 11
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		cr = m8820x_cmmu[cmmu_num].cmmu_regs;
		if (!badwordaddr((vaddr_t)cr)) {
			int type;

			type = CMMU_TYPE(cr->idr);
#ifdef DIAGNOSTIC
			if (type != M88200_ID && type != M88204_ID) {
				printf("WARNING: non M8820x circuit found "
				    "at CMMU address %p\n", cr);
				continue;	/* will probably die quickly */
d424 3
a426 4
#endif
			m8820x_cmmu[cmmu_num].cmmu_alive = CMMU_AVAILABLE;
			dprintf(("m8820x_setup_cmmu_config: CMMU %d found at %p\n",
			    cmmu_num, cr));
a427 1
	}
d429 4
a432 4
	/*
	 * Now that we know which CMMUs are there, let's report on which
	 * CPU/CMMU sets seem complete (hopefully all)
	 */
d434 2
a435 1
		int i, type;
d438 3
a440 4
			dprintf(("cmmu_init: testing CMMU %d for CPU %d\n",
			    num * cpu_cmmu_ratio + i, num));
#ifdef DIAGNOSTIC
			if (!m8820x_cmmu_alive(num * cpu_cmmu_ratio + i)) {
d442 2
a443 2
				    num * cpu_cmmu_ratio + i, num);
				continue;	/* will probably die quickly */
a444 1
#endif
d447 1
a447 2
		type = CMMU_TYPE(m8820x_cmmu[num * cpu_cmmu_ratio].
		    cmmu_regs->idr);
d449 6
a454 2
		printf("CPU%d is attached with %d MC%x CMMUs\n",
		    num, cpu_cmmu_ratio, type == M88204_ID ? 0x88204 : 0x88200);
d460 1
a460 1
		dprintf(("m8820x_setup_cmmu_config: CPU %d inst strat %d data strat %d\n",
a467 1
#ifdef MVME188
a469 1
#endif
d471 1
a471 1
		dprintf(("m8820x_setup_cmmu_config: resetting strategies\n"));
d473 2
a474 2
			cpu_cmmu_strategy[num].inst = CMMU_SPLIT_ADDRESS;
			cpu_cmmu_strategy[num].data = CMMU_SPLIT_ADDRESS;
d483 2
a484 4
		val1 = (cpu_cmmu_strategy[0].inst << 2) |
		    cpu_cmmu_strategy[0].data;
		val2 = (cpu_cmmu_strategy[1].inst << 2) |
		    cpu_cmmu_strategy[1].data;
d487 1
a487 1
		dprintf(("m8820x_setup_cmmu_config: 2P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
d492 2
a493 4
		val1 = (cpu_cmmu_strategy[0].inst << 2) |
		    cpu_cmmu_strategy[0].inst;
		val2 = (cpu_cmmu_strategy[0].data << 2) |
		    cpu_cmmu_strategy[0].data;
d496 1
a496 1
		dprintf(("m8820x_setup_cmmu_config: 1P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
d500 1
a500 2
		val1 = (cpu_cmmu_strategy[0].inst << 2) |
		    cpu_cmmu_strategy[0].data;
d502 1
a502 1
		dprintf(("m8820x_setup_cmmu_config: 1P64: PCNFA = 0x%x\n", val1));
d506 1
a506 1
		panic("m8820x_setup_cmmu_config: unsupported configuration");
d511 1
a511 1
	dprintf(("m8820x_setup_cmmu_config: PCNFA = 0x%x, PCNFB = 0x%x\n", *pcnfa, *pcnfb));
d519 3
a521 3
		(cmmu_num * max_cpus) / max_cmmus;
		dprintf(("m8820x_setup_cmmu_config: CMMU %d connected with CPU %d\n",
		    cmmu_num, m8820x_cmmu[cmmu_num].cmmu_cpu));
d532 1
a532 1
			m8820x_cmmu[cmmu_num].cmmu_addr = 0;
d544 2
a545 2
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data) {
d547 1
a547 2
			m8820x_cmmu[cmmu_num].cmmu_addr =
			    ((cmmu_num & 0x2) ^ 0x2) << 11;
d552 1
a552 1
			m8820x_cmmu[cmmu_num].cmmu_addr = 0;
d559 1
a559 2
			m8820x_cmmu[cmmu_num].cmmu_addr_match =
			    (cmmu_num & 0x2) ? 1 : 0;
d564 1
a564 2
				m8820x_cmmu[cmmu_num].cmmu_addr_mask =
				    CMMU_SRAM_MASK;
d566 1
a566 1
				m8820x_cmmu[cmmu_num].cmmu_addr = 0;
d575 1
a575 1
		 * This bit splits the CMMUs independent of the enabled strategy
d579 2
a580 3
		if (cpu_cmmu_ratio > 4) {	/* XXX only handles 1P128!!! */
			m8820x_cmmu[cmmu_num].cmmu_addr |=
			    ((cmmu_num & 0x4) ^ 0x4) << 12;
d588 2
a589 2
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data) {
d592 1
a592 1
			    (cmmu_num & 0x2 ) ? CMMU_ACS_USER : CMMU_ACS_SUPER;
d596 1
a596 1
			    (cmmu_num & 0x2 ) ? CMMU_ACS_SUPER : CMMU_ACS_BOTH;
a604 2
#ifdef DDB

d606 1
a606 1
const char *cmmu_strat_string[] = {
d612 1
a612 1
#endif
d614 1
a614 1
void
d620 4
a623 1
	int cmmu_num;
d625 1
d627 42
a668 3
	if (brdtyp != BRD_188)
		return;
#endif
d670 5
a674 21
	db_printf("Current CPU/CMMU configuration:\n");
	pcnfa = (unsigned long *volatile)MVME188_PCNFA;
	pcnfb = (unsigned long *volatile)MVME188_PCNFB;
	db_printf("VME188 address decoder: PCNFA = 0x%1lx, PCNFB = 0x%1lx\n\n",
	    *pcnfa & 0xf, *pcnfb & 0xf);
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		db_printf("CMMU #%d: %s CMMU for CPU %d:\n Strategy: %s\n %s access addr 0x%08lx mask 0x%08lx match %s\n",
		  cmmu_num,
		  (m8820x_cmmu[cmmu_num].which == INST_CMMU) ? "inst" : "data",
		  m8820x_cmmu[cmmu_num].cmmu_cpu,
		  cmmu_strat_string[(m8820x_cmmu[cmmu_num].which == INST_CMMU) ?
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data],
		  (m8820x_cmmu[cmmu_num].cmmu_access == CMMU_ACS_BOTH) ?   "User and spv" :
		  ((m8820x_cmmu[cmmu_num].cmmu_access == CMMU_ACS_USER) ? "User        " :
		   "Supervisor  "),
		  m8820x_cmmu[cmmu_num].cmmu_addr,
		  m8820x_cmmu[cmmu_num].cmmu_addr_mask,
		  m8820x_cmmu[cmmu_num].cmmu_addr_match ? "TRUE" : "FALSE");
	}
#endif /* MVME188 */
a675 1
#endif	/* DDB */
d681 1
a681 1
void
d686 1
a686 1
	vaddr_t addr;
d688 11
a698 1
	int mmu;
d704 1
a704 2
	for (mmu = num * cpu_cmmu_ratio;
	    mmu < (num + 1) * cpu_cmmu_ratio; mmu++) {
d722 22
a743 1
const char *mmutypes[8] = {
d759 1
a759 1
void
a783 1
#ifdef MVME188
a786 1
#endif
d792 1
a792 1
		int mmuid = CMMU_TYPE(idr);
d835 2
a836 2
	int cpu, type;
	struct cmmu_regs *cr;
d839 1
a839 2
		cpu_cmmu[cpu].pair[INST_CMMU] = 0;
		cpu_cmmu[cpu].pair[DATA_CMMU] = 0;
d842 1
a842 1
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
d844 1
a844 2
			cr = m8820x_cmmu[cmmu_num].cmmu_regs;
			type = CMMU_TYPE(cr->idr);
d847 1
a847 2
			    &m8820x_cmmu[cmmu_num];

d853 2
a854 2
				cr->sar = tmp << 4;
				cr->cssp = 0x3f0ff000;
d858 1
a858 1
			if (type == M88204_ID) {
d860 2
a861 2
					cr->sar = tmp << 4;
					cr->cssp1 = 0x3f0ff000;
d864 2
a865 2
					cr->sar = tmp << 4;
					cr->cssp2 = 0x3f0ff000;
d868 2
a869 2
					cr->sar = tmp << 4;
					cr->cssp3 = 0x3f0ff000;
d875 1
d877 7
a883 4
			cr->sctr &=
			    ~(CMMU_SCTR_PE | CMMU_SCTR_SE | CMMU_SCTR_PR);
			cr->sapr = cr->uapr =
			    ((0x00000 << PG_BITS) | AREA_D_WT | AREA_D_G |
d885 3
d899 11
a909 5
			cr->bwp[0] = cr->bwp[1] = cr->bwp[2] = cr->bwp[3] =
			cr->bwp[4] = cr->bwp[5] = cr->bwp[6] = cr->bwp[7] = 0;
			cr->scr = CMMU_FLUSH_CACHE_INV_ALL;
			cr->scr = CMMU_FLUSH_SUPER_ALL;
			cr->scr = CMMU_FLUSH_USER_ALL;
a911 2

#ifdef MVME188
d913 1
a913 3
	 * Enable snooping on MVME188 only.
	 * Snooping is enabled for instruction cmmus as well so that
	 * we can have breakpoints, modify code, etc.
d915 3
a917 4
	if (brdtyp == BRD_188) {
		for (cpu = 0; cpu < max_cpus; cpu++) {
			if (!cpu_sets[cpu])
				continue;
d919 17
a935 9
			m8820x_cmmu_set(CMMU_SCTR, CMMU_SCTR_SE, 0, cpu,
			    DATA_CMMU, 0, 0);
			m8820x_cmmu_set(CMMU_SCTR, CMMU_SCTR_SE, 0, cpu,
			    INST_CMMU, 0, 0);

			m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL,
			    ACCESS_VAL, cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
			/* Icache gets flushed just below */
		}
a936 1
#endif
d939 1
a939 4
	 * Enable instruction cache.
	 * Data cache can not be enabled at this point, because some device
	 * addresses can never be cached, and the no-caching zones are not
	 * set up yet.
d944 10
d955 2
a956 6
		tmp = ((0x00000 << PG_BITS) | AREA_D_WT | AREA_D_G)
		    & ~(AREA_D_CI | AREA_D_TE);

		m8820x_cmmu_set(CMMU_SAPR, tmp, MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL,
		    ACCESS_VAL, cpu, 0, CMMU_ACS_SUPER, 0);
d966 1
a967 1
	struct cmmu_regs *cr;
d970 14
a983 3
	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
		if (m8820x_cmmu_alive(cmmu_num)) {
			cr = m8820x_cmmu[cmmu_num].cmmu_regs;
d985 3
a987 6
			cr->sctr &=
			    ~(CMMU_SCTR_PE | CMMU_SCTR_SE | CMMU_SCTR_PR);
			cr->sapr = cr->uapr =
			    ((0x00000 << PG_BITS) | AREA_D_CI) &
			    ~(AREA_D_WT | AREA_D_G | AREA_D_TE);
		}
d991 1
d995 1
a995 1
void
d998 2
a999 3
	unsigned cmmu_num;
	struct cmmu_regs *cr;

d1002 1
a1002 1
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++)
d1004 2
a1005 1
			cr = m8820x_cmmu[cmmu_num].cmmu_regs;
d1007 5
a1011 1
			cr->sctr |= CMMU_SCTR_PE;
d1013 1
a1013 1

d1015 1
d1025 1
a1025 1
unsigned
d1028 2
a1029 2
	unsigned cmmu_no;
	int i, cpu;
d1033 1
a1033 1
	for (i = 0; i < 10; i++) {
d1042 1
a1042 1
		badwordaddr((vaddr_t)ILLADDRESS);
d1048 6
a1053 8
			    ((m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr >> 16) &
			    0x7) != 0) {
				/* clean register, just in case... */
				m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;
				m8820x_cmmu[cmmu_no].cmmu_alive = CMMU_MARRIED;
				cpu = m8820x_cmmu[cmmu_no].cmmu_cpu;
				CMMU_UNLOCK;
				return cpu;
d1057 1
d1059 2
d1062 23
a1084 1
	panic("m8820x_cmmu_cpu_number: could not determine my cpu number");
d1094 2
a1095 1
	m8820x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL, cpu, 0, CMMU_ACS_SUPER, 0);
d1103 4
a1106 2
	int s = splhigh();
	int cpu = cpu_number();
d1110 2
a1111 1
	m8820x_cmmu_set(CMMU_UAPR, ap, ACCESS_VAL, cpu, 0, CMMU_ACS_USER, 0);
d1117 24
a1140 1
 * Set batc entry number entry_no to value in
a1141 3
 *
 * Except for the cmmu_init, this function and m8820x_cmmu_pmap_activate
 * are the only functions which may set the batc values.
d1149 2
a1150 3

	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL | ACCESS_VAL,
	    cpu, DATA_CMMU, CMMU_ACS_USER, 0);
d1154 2
a1155 2
	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL | ACCESS_VAL,
	    cpu, INST_CMMU, CMMU_ACS_USER, 0);
d1172 4
a1175 2
m8820x_cmmu_flush_remote_tlb(unsigned cpu, unsigned kernel, vaddr_t vaddr,
    vsize_t size)
d1177 1
a1177 2
	int s = splhigh();

d1180 2
a1181 15
#if !defined(BROKEN_MMU_MASK)
	if (size > PAGE_SIZE) {
		m8820x_cmmu_set(CMMU_SCR,
		    kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL,
		    ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, 0);
	} else {
		/* a page or smaller */
		m8820x_cmmu_set(CMMU_SAR, vaddr,
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
		m8820x_cmmu_set(CMMU_SCR,
		    kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE,
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
a1182 6
#else
	m8820x_cmmu_set(CMMU_SCR,
	    kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL,
	    ACCESS_VAL, cpu, 0,
	    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, 0);
#endif
d1184 9
d1201 4
a1204 1
m8820x_cmmu_flush_tlb(unsigned kernel, vaddr_t vaddr, vsize_t size)
d1206 2
a1207 1
	int cpu = cpu_number();
d1214 1
a1214 1
 * Only called from pmap_activate().
a1222 1

d1246 1
a1246 2
	    cpu, 0, CMMU_ACS_USER, 0);

a1261 2
 *
 * XXX miod WHAT? Above comment seems 200% bogus wrt snooping!
d1268 4
a1271 1
m8820x_cmmu_flush_remote_cache(int cpu, paddr_t physaddr, psize_t size)
d1273 1
a1273 1
	int s = splhigh();
d1277 2
a1278 1
	if (size > NBSG) {
d1280 1
a1280 1
		    cpu, 0, 0, 0);
d1283 3
a1285 3
		    cpu, 0, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, ADDR_VAL,
		    cpu, 0, 0, (unsigned)physaddr);
d1288 3
a1290 3
		    cpu, 0, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, ADDR_VAL,
		    cpu, 0, 0, (unsigned)physaddr);
d1293 1
a1293 1
		    cpu, 0, 0, 0);
d1295 1
a1295 1
		    cpu, 0, 0, 0);
d1297 1
d1300 1
a1300 1
	    cpu, 0, 0, 0);
a1301 1

d1310 3
a1312 1
m8820x_cmmu_flush_cache(paddr_t physaddr, psize_t size)
d1322 4
a1325 1
m8820x_cmmu_flush_remote_inst_cache(int cpu, paddr_t physaddr, psize_t size)
d1327 1
a1327 1
	int s = splhigh();
d1331 1
a1331 1
	if (size > NBSG) {
d1333 1
a1333 1
		    cpu, INST_CMMU, 0, 0);
d1335 5
a1339 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1341 4
a1344 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1346 4
a1349 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1353 1
a1353 1
	    cpu, INST_CMMU, 0, 0);
d1364 3
a1366 1
m8820x_cmmu_flush_inst_cache(paddr_t physaddr, psize_t size)
d1368 2
a1369 1
	int cpu = cpu_number();
d1374 4
a1377 1
m8820x_cmmu_flush_remote_data_cache(int cpu, paddr_t physaddr, psize_t size)
d1379 1
a1379 1
	int s = splhigh();
d1383 2
a1384 1
	if (size > NBSG) {
d1386 1
a1386 1
		    cpu, DATA_CMMU, 0, 0);
d1388 5
a1392 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1394 4
a1397 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1399 4
a1402 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1406 1
a1406 1
	    cpu, DATA_CMMU, 0, 0);
a1407 1

d1414 1
a1414 1
 */
d1416 6
a1421 3
m8820x_cmmu_flush_data_cache(paddr_t physaddr, psize_t size)
{
	int cpu = cpu_number();
d1429 7
a1435 5
m8820x_cmmu_sync_cache(paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	int cpu = cpu_number();

d1437 1
d1440 1
a1440 1
	if (size > NBSG) {
d1442 1
a1442 1
		    cpu, DATA_CMMU, 0, 0);
d1444 1
a1444 1
		    cpu, INST_CMMU, 0, 0);
d1446 8
a1453 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1455 8
a1462 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1464 8
a1471 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1475 1
a1475 1
	    cpu, DATA_CMMU, 0, 0);
d1477 1
a1477 1
	    cpu, INST_CMMU, 0, 0);
d1479 1
a1479 1

a1480 1
	splx(s);
d1483 8
a1490 6
void
m8820x_cmmu_sync_inval_cache(paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	int cpu = cpu_number();

d1494 1
a1494 1
	if (size > NBSG) {
d1496 1
a1496 1
		    cpu, DATA_CMMU, 0, 0);
d1498 1
a1498 1
		    cpu, INST_CMMU, 0, 0);
d1500 8
a1507 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1509 8
a1516 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1518 8
a1525 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1527 1
d1530 1
a1530 1
	    cpu, DATA_CMMU, 0, 0);
d1532 1
a1532 1
	    cpu, INST_CMMU, 0, 0);
a1533 1

d1539 7
a1545 5
m8820x_cmmu_inval_cache(paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	int cpu = cpu_number();

d1549 1
a1549 1
	if (size > NBSG) {
d1551 1
a1551 1
		    cpu, DATA_CMMU, 0, 0);
d1553 1
a1553 1
		    cpu, INST_CMMU, 0, 0);
d1555 8
a1562 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1564 8
a1571 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1573 8
a1580 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1584 1
a1584 1
	    cpu, DATA_CMMU, 0, 0);
d1586 1
a1586 1
	    cpu, INST_CMMU, 0, 0);
a1587 1

d1593 3
a1595 1
m8820x_dma_cachectl(vaddr_t va, vsize_t size, int op)
d1598 1
a1598 1
	psize_t count;
d1600 2
a1601 2
	while (size != 0) {
		count = NBPG - (va & PGOFSET);
d1606 1
a1606 2
		switch (op) {
		case DMA_CACHE_SYNC:
d1608 1
a1608 2
			break;
		case DMA_CACHE_SYNC_INVAL:
d1610 1
a1610 2
			break;
		default:
a1611 2
			break;
		}
d1613 1
a1613 1
		va += count;
d1617 2
a1618 2
	switch (op) {
	case DMA_CACHE_SYNC:
d1620 1
a1620 2
		break;
	case DMA_CACHE_SYNC_INVAL:
d1622 1
a1622 2
		break;
	default:
a1623 2
		break;
	}
d1723 1
a1723 1
		db_printf("-------------------------------------------\n");
d1728 11
a1738 4
	if (cmmu_num == -1) {
		int cpu = cpu_number();
		if (cpu_cmmu[cpu].pair[DATA_CMMU] == 0) {
			db_printf("ack! can't figure my own data cmmu number.\n");
d1740 16
d1757 16
a1772 7
		cmmu_num = cpu_cmmu[cpu].pair[DATA_CMMU] - m8820x_cmmu;
		if (verbose_flag)
			db_printf("The data cmmu for cpu#%d is cmmu#%d.\n",
				  0, cmmu_num);
	} else if (cmmu_num < 0 || cmmu_num >= MAX_CMMUS) {
		db_printf("invalid cpu number [%d]... must be in range [0..%d]\n",
			  cmmu_num, MAX_CMMUS - 1);
d1774 2
a1775 2
		return;
	}
d1777 2
a1778 2
	if (m8820x_cmmu[cmmu_num].cmmu_alive == 0) {
		db_printf("warning: cmmu %d is not alive.\n", cmmu_num);
d1780 1
a1780 1
		return;
d1782 21
a1802 1
	}
a1803 13
	if (!verbose_flag) {
		if (!(m8820x_cmmu[cmmu_num].cmmu_regs->sctr & CMMU_SCTR_SE))
			db_printf("WARNING: snooping not enabled for CMMU#%d.\n",
				  cmmu_num);
	} else {
		int i;
		for (i=0; i<MAX_CMMUS; i++)
			if ((i == cmmu_num || m8820x_cmmu[i].cmmu_alive) &&
			    (verbose_flag>1 || !(m8820x_cmmu[i].cmmu_regs->sctr&CMMU_SCTR_SE))) {
				db_printf("CMMU#%d (cpu %d %s) snooping %s\n", i,
					  m8820x_cmmu[i].cmmu_cpu, m8820x_cmmu[i].which ? "data" : "inst",
					  (m8820x_cmmu[i].cmmu_regs->sctr & CMMU_SCTR_SE) ? "on":"OFF");
			}
d1806 2
a1807 5
	if (supervisor_flag)
		value = m8820x_cmmu[cmmu_num].cmmu_regs->sapr;
	else
		value = m8820x_cmmu[cmmu_num].cmmu_regs->uapr;

d1809 1
a1809 1
	{
d1816 1
a1816 1
					db_printf("cmmu #%d batc[%d] invalid.\n", cmmu_num, i);
d1818 1
a1818 1
				db_printf("cmmu#%d batc[%d] v%08x p%08x", cmmu_num, i,
d1820 5
a1824 5
				if (batc.field.s)  db_printf(", supervisor");
				if (batc.field.wt) db_printf(", wt.th");
				if (batc.field.g)  db_printf(", global");
				if (batc.field.ci) db_printf(", cache inhibit");
				if (batc.field.wp) db_printf(", write protect");
d1829 1
d1832 3
d1842 1
a1842 1
			db_printf("probe of 0x%08x returns ssr=0x%08x\n",
d1845 1
a1845 1
			db_printf("PROBE of 0x%08x returns phys=0x%x",
d1848 12
a1859 12
			db_printf("PROBE fault at 0x%x", cmmu_regs->pfADDRr);
		if (ssr.field.ce) db_printf(", copyback err");
		if (ssr.field.be) db_printf(", bus err");
		if (ssr.field.wt) db_printf(", writethrough");
		if (ssr.field.sp) db_printf(", sup prot");
		if (ssr.field.g)  db_printf(", global");
		if (ssr.field.ci) db_printf(", cache inhibit");
		if (ssr.field.m)  db_printf(", modified");
		if (ssr.field.u)  db_printf(", used");
		if (ssr.field.wp) db_printf(", write prot");
		if (ssr.field.bh) db_printf(", BATC");
		db_printf(".\n");
d1865 8
a1872 2
			db_printf("CMMU#%d", cmmu_num);
			db_printf(" %cAPR is 0x%08x\n",
d1875 8
a1882 2
		db_printf("CMMU#%d", cmmu_num);
		db_printf(" %cAPR: SegTbl: 0x%x000p",
d1885 1
a1885 1
			db_printf(", WTHRU");
d1887 1
a1887 1
			db_printf(", GLOBAL");
d1889 1
a1889 1
			db_printf(", INHIBIT");
d1891 2
a1892 2
			db_printf(", VALID");
		db_printf("\n");
d1896 1
a1896 1
			db_printf("<would report an error, valid bit not set>\n");
d1906 1
a1906 1
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d1915 1
a1915 1
			db_printf("will follow to entry %d of page at 0x%x...\n",
d1920 2
a1921 2
		if (badwordaddr((vaddr_t)value)) {
			db_printf("ERROR: unable to access page at 0x%08x.\n", value);
d1927 2
a1928 2
			db_printf("SEG DESC @@0x%x is 0x%08x\n", value, sdt);
		db_printf("SEG DESC @@0x%x: PgTbl: 0x%x000",
d1930 13
a1942 13
		if (sdt & CACHE_WT)		    db_printf(", WTHRU");
		else				    db_printf(", !wthru");
		if (sdt & SG_SO)		    db_printf(", S-PROT");
		else				    db_printf(", UserOk");
		if (sdt & CACHE_GLOBAL)		    db_printf(", GLOBAL");
		else				    db_printf(", !global");
		if (sdt & CACHE_INH)		    db_printf(", $INHIBIT");
		else				    db_printf(", $ok");
		if (sdt & SG_PROT)		    db_printf(", W-PROT");
		else				    db_printf(", WriteOk");
		if (sdt & SG_V)			    db_printf(", VALID");
		else				    db_printf(", !valid");
		db_printf(".\n");
d1946 1
a1946 1
			db_printf("<would report an error, STD entry not valid>\n");
d1955 1
a1955 1
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d1962 1
a1962 1
			db_printf("will follow to entry %d of page at 0x%x...\n",
d1967 2
a1968 2
		if (badwordaddr((vaddr_t)value)) {
			db_printf("error: unable to access page at 0x%08x.\n", value);
d1975 2
a1976 2
			db_printf("PAGE DESC @@0x%x is 0x%08x.\n", value, pte);
		db_printf("PAGE DESC @@0x%x: page @@%x000",
d1978 19
a1996 19
		if (pte & PG_W)			db_printf(", WIRE");
		else				db_printf(", !wire");
		if (pte & CACHE_WT)		db_printf(", WTHRU");
		else				db_printf(", !wthru");
		if (pte & PG_SO)		db_printf(", S-PROT");
		else				db_printf(", UserOk");
		if (pte & CACHE_GLOBAL)		db_printf(", GLOBAL");
		else				db_printf(", !global");
		if (pte & CACHE_INH)		db_printf(", $INHIBIT");
		else				db_printf(", $ok");
		if (pte & PG_M)			db_printf(", MOD");
		else				db_printf(", !mod");
		if (pte & PG_U)			db_printf(", USED");
		else				db_printf(", !used");
		if (pte & PG_PROT)		db_printf(", W-PROT");
		else				db_printf(", WriteOk");
		if (pte & PG_V)			db_printf(", VALID");
		else				db_printf(", !valid");
		db_printf(".\n");
d2000 1
a2000 1
			db_printf("<would report an error, PTE entry not valid>\n");
d2006 1
a2006 1
			db_printf("will follow to byte %d of page at 0x%x...\n",
d2010 2
a2011 2
		if (badwordaddr((vaddr_t)value)) {
			db_printf("error: unable to access page at 0x%08x.\n", value);
d2018 1
a2018 1
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d2021 1
a2021 1
	db_printf("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);
d2024 72
@


1.1.1.7
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.25 2003/12/22 20:10:23 miod Exp $	*/
a73 2
#include <uvm/uvm_extern.h>

a1477 1
	paddr_t pa;
a1486 20
		if (pmap_extract(pmap_kernel(), va, &pa) != FALSE) {
			switch (op) {
			case DMA_CACHE_SYNC:
				m8820x_cmmu_sync_cache(pa, count);
				break;
			case DMA_CACHE_SYNC_INVAL:
				m8820x_cmmu_sync_inval_cache(pa, count);
				break;
			default:
				m8820x_cmmu_inval_cache(pa, count);
				break;
			}
		}

		va += count;
		size -= count;
	}
#else
	/* XXX This assumes the space is also physically contiguous */
	if (pmap_extract(pmap_kernel(), va, &pa) != FALSE) {
d1489 1
a1489 1
			m8820x_cmmu_sync_cache(pa, size);
d1492 1
a1492 1
			m8820x_cmmu_sync_inval_cache(pa, size);
d1495 1
a1495 1
			m8820x_cmmu_inval_cache(pa, size);
d1498 15
@


1.1.1.8
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 25
/*	$OpenBSD: m8820x.c,v 1.31 2004/01/20 14:35:54 miod Exp $	*/
/*
 * Copyright (c) 2004, Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
d33 1
d62 1
d89 2
a90 1
unsigned int m8820x_debuglevel;
d93 1
a93 1
		if (m8820x_debuglevel != 0) { \
d110 1
a110 1
void m8820x_cmmu_set_sapr(unsigned, unsigned);
d113 2
a114 1
void m8820x_cmmu_flush_tlb(unsigned, unsigned, vaddr_t, vsize_t);
d117 6
a122 3
void m8820x_cmmu_flush_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_inst_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_data_cache(int, paddr_t, psize_t);
d136 1
a136 1
	m8820x_cmmu_set_sapr,
d139 1
d142 1
d144 1
d146 1
d163 30
a192 25
/*
 * This code was initially designed for the Omron Luna 88K layout consisting
 * of up to 4 CPUs with 2 CMMUs each, one for data and one for instructions.
 *
 * Trying to support a few more board configurations for the
 * Motorola MVME188, we have the following layouts:
 *
 *  - config 0: 4 CPUs, 8 CMMUs
 *  - config 1: 2 CPUs, 8 CMMUs
 *  - config 2: 1 CPUs, 8 CMMUs
 *  - config 5: 2 CPUs, 4 CMMUs
 *  - config 6: 1 CPU,  4 CMMUs
 *  - config A: 1 CPU,  2 CMMUs
 *
 * We use these splitup schemes:
 *  - split between data and instructions (always enabled)
 *  - split between user/spv (and A14 in config 2)
 *  - split because of A12 (and A14 in config 2)
 *  - one SRAM supervisor, other rest
 *  - one whole SRAM, other rest
 *
 * The main problem is to find the right suited CMMU for a given
 * CPU number at those configurations.
 *                                         em, 10.5.94
 */
a193 3
/*
 * CMMU kernel information
 */
d195 5
a199 10
	unsigned *volatile cmmu_regs;	/* CMMU "base" area */
	unsigned int	cmmu_cpu;	/* cpu number it is attached to */
	unsigned int	cmmu_type;
#define	INST_CMMU	0
#define	DATA_CMMU	1
	unsigned int	cmmu_access;
#define	CMMU_ACS_USER	0
#define	CMMU_ACS_SUPER	1
#define	CMMU_ACS_BOTH	2
	unsigned int	cmmu_alive;
a210 5
#ifdef SHADOW_BATC
/* CMMU(cpu,data) is the cmmu struct for the named cpu's indicated cmmu.  */
#define CMMU(cpu, data) cpu_cmmu[(cpu)].pair[(data) ? DATA_CMMU : INST_CMMU]
#endif

d212 1
a212 1
 * Structure for accessing MMUS properly
d214 3
d218 3
a220 67
struct m8820x_cmmu m8820x_cmmu[MAX_CMMUS] =
{
	/* address, cpu, mode, access, alive, addr, mask */
	{(unsigned *volatile)VME_CMMU_I0, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D0, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_I1, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D1, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_I2, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D2, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_I3, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D3, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0}
};

struct cpu_cmmu {
	struct m8820x_cmmu *pair[2];
} cpu_cmmu[MAX_CPUS];

/*
 * CMMU per CPU split strategies
 */

#define	CMMU_SPLIT_ADDRESS	0x00
#define	CMMU_SPLIT_SPV		0x01
#define	CMMU_SPLIT_SRAM_SPV	0x02
#define	CMMU_SPLIT_SRAM_ALL	0x03

#define	CMMU_SPLIT_MASK		0x03

struct cmmu_strategy {
	int inst;
	int data;
} cpu_cmmu_strategy[] = {
	/*     inst                 data */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV}, 	/* CPU 0 */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV}, 	/* CPU 1 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS},	/* CPU 2 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}	/* CPU 3 */
};

unsigned int cmmu_shift;

#ifdef MVME188
/*
 * The following list describes the different MVME188 configurations
 * which are supported by this code.
 */
const struct board_config {
	int ncpus;
	int ncmmus;
} bd_config[] = {
	{ 4, 8 },	/* 4P128 - 4P512 */
	{ 2, 8 },	/* 2P128 - 2P512 */
	{ 1, 8 },	/* 1P128 - 1P512 */
	{ 0, 0 },
	{ 0, 0 },
	{ 2, 4 },	/* 2P64  - 2P256 */
	{ 1, 4 },	/* 1P64  - 1P256 */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 1, 2 },	/* 1P32  - 1P128 */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 }
};
a224 1
void m8820x_cmmu_wait(int);
d234 10
d262 99
d369 1
a369 1
	unsigned *volatile cr;
a380 1
	case BRD_8120:
d409 1
a409 1
	cmmu_shift = ff1(max_cmmus / max_cpus);
d412 1
a412 1
	if (bd_config[vme188_config].ncpus > 0) {
d431 1
a431 1
		if (badwordaddr((vaddr_t)cr) == 0) {
d434 1
a434 1
			type = CMMU_TYPE(cr[CMMU_IDR]);
d455 1
a455 1
		for (i = 0; i < (1 << cmmu_shift); i++) {
d457 1
a457 1
			    (num << cmmu_shift) | i, num));
d459 1
a459 1
			if (m8820x_cmmu[(num << cmmu_shift) | i].cmmu_alive == CMMU_DEAD) {
d461 1
a461 1
				    (num << cmmu_shift) | i, num);
d467 2
a468 2
		type = CMMU_TYPE(m8820x_cmmu[num << cmmu_shift].
		    cmmu_regs[CMMU_IDR]);
d471 1
a471 1
		    num, 1 << cmmu_shift, type == M88204_ID ? 0x88204 : 0x88200);
d478 1
a478 1
		    num, cpu_cmmu_strategy[num].inst, cpu_cmmu_strategy[num].data));
d486 2
a487 2
	case 0x00:
	case 0x05:
d489 1
a489 1
	case 0x0a:
d499 1
a499 1
	case 0x01:
d510 1
a510 1
	case 0x02:
d521 1
a521 1
	case 0x06:
d543 1
a543 1
		    (cmmu_num * max_cpus) / max_cmmus;
d555 1
a555 1
		if (cmmu_shift == 1) {
d567 1
a567 1
		switch ((m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ?
d603 2
d606 1
a606 1
		if (cmmu_shift >= 2) {
d615 1
a615 1
		switch ((m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ?
d620 1
a620 1
			    (cmmu_num & 0x2) ? CMMU_ACS_USER : CMMU_ACS_SUPER;
d624 1
a624 1
			    (cmmu_num & 0x2) ? CMMU_ACS_SUPER : CMMU_ACS_BOTH;
d665 1
a665 1
		  (m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ? "inst" : "data",
d667 1
a667 1
		  cmmu_strat_string[(m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ?
d698 2
a699 2
	for (mmu = num << cmmu_shift;
	    mmu < (num + 1) << cmmu_shift; mmu++) {
d701 1
a701 1
		    (m8820x_cmmu[mmu].cmmu_type != mode))
d713 1
a713 28
		m8820x_cmmu[mmu].cmmu_regs[reg] = val;
	}
}

/*
 * Force a read from the CMMU status register, thereby forcing execution to
 * stop until all pending CMMU operations are finished.
 * This is used by the various cache invalidation functions.
 */
void
m8820x_cmmu_wait(int cpu)
{
	int mmu;

	/*
	 * We scan all related CMMUs and read their status register.
	 */
	for (mmu = cpu << cmmu_shift;
	    mmu < (cpu + 1) << cmmu_shift; mmu++) {
#ifdef DEBUG
		if (m8820x_cmmu[mmu].cmmu_regs[CMMU_SSR] & CMMU_SSR_BE) {
			panic("cache flush failed!");
		}
#else
		/* force the read access, but do not issue this statement... */
		__asm__ __volatile__ ("|or r0, r0, %0" ::
		    "r" (m8820x_cmmu[mmu].cmmu_regs[CMMU_SSR]));
#endif
d763 1
a763 1
	printf(", %d CMMU", 1 << cmmu_shift);
d765 1
a765 1
	for (mmu = cpu << cmmu_shift; mmu < (cpu + 1) << cmmu_shift;
d767 1
a767 1
		int idr = m8820x_cmmu[mmu].cmmu_regs[CMMU_IDR];
d771 1
a771 1
		if (mmu % 2 == 0)
d781 1
a781 1
		    CMMU_VERSION(idr),
d784 1
a784 1
		    m8820x_cmmu[mmu].cmmu_type == INST_CMMU ? "I" : "D");
d810 3
a812 4
	unsigned int line, cmmu_num;
	int cssp, cpu, type;
	u_int32_t apr;
	unsigned *volatile cr;
d820 1
a820 1
		if (m8820x_cmmu[cmmu_num].cmmu_alive != CMMU_DEAD) {
d822 1
a822 1
			type = CMMU_TYPE(cr[CMMU_IDR]);
d824 1
a824 2
			cpu_cmmu[m8820x_cmmu[cmmu_num].cmmu_cpu].
			  pair[m8820x_cmmu[cmmu_num].cmmu_type] =
d828 2
a829 1
			 * Reset cache
d831 14
a844 13
			for (cssp = type == M88204_ID ? 3 : 0;
			    cssp >= 0; cssp--)
				for (line = 0; line <= 255; line++) {
					cr[CMMU_SAR] =
					    line << MC88200_CACHE_SHIFT;
					cr[CMMU_CSSP(cssp)] =
					    CMMU_CSSP_L5 | CMMU_CSSP_L4 |
					    CMMU_CSSP_L3 | CMMU_CSSP_L2 |
					    CMMU_CSSP_L1 | CMMU_CSSP_L0 |
					    CMMU_CSSP_VV(3, CMMU_VV_INVALID) |
					    CMMU_CSSP_VV(2, CMMU_VV_INVALID) |
					    CMMU_CSSP_VV(1, CMMU_VV_INVALID) |
					    CMMU_CSSP_VV(0, CMMU_VV_INVALID);
d846 5
d855 1
a855 1
			cr[CMMU_SCTR] &=
d857 3
a859 3
			cr[CMMU_SAPR] = cr[CMMU_UAPR] =
			    ((0x00000 << PG_BITS) | CACHE_WT | CACHE_GLOBAL |
			    CACHE_INH) & ~APR_V;
d871 5
a875 9
			cr[CMMU_BWP0] = cr[CMMU_BWP1] =
			cr[CMMU_BWP2] = cr[CMMU_BWP3] =
			cr[CMMU_BWP4] = cr[CMMU_BWP5] =
			cr[CMMU_BWP6] = cr[CMMU_BWP7] = 0;
			cr[CMMU_SCR] = CMMU_FLUSH_CACHE_INV_ALL;
			__asm__ __volatile__ ("|or r0, r0, %0" ::
			    "r" (cr[CMMU_SSR]));
			cr[CMMU_SCR] = CMMU_FLUSH_SUPER_ALL;
			cr[CMMU_SCR] = CMMU_FLUSH_USER_ALL;
d879 1
d883 1
a883 1
	 * we can share breakpoints.
a884 1
#ifdef MVME188
d887 1
a887 1
			if (cpu_sets[cpu] == 0)
d890 1
a890 1
			m8820x_cmmu_set(CMMU_SCTR, CMMU_SCTR_SE, MODE_VAL, cpu,
d892 1
a892 1
			m8820x_cmmu_set(CMMU_SCTR, CMMU_SCTR_SE, MODE_VAL, cpu,
d896 1
a896 2
			    ACCESS_VAL, cpu, 0, CMMU_ACS_SUPER, 0);
			m8820x_cmmu_wait(cpu);
d909 1
a909 1
		if (cpu_sets[cpu] == 0)
d912 2
a913 2
		apr = ((0x00000 << PG_BITS) | CACHE_WT | CACHE_GLOBAL)
		    & ~(CACHE_INH | APR_V);
d915 1
a915 1
		m8820x_cmmu_set(CMMU_SAPR, apr, MODE_VAL, cpu, INST_CMMU, 0, 0);
a917 1
		m8820x_cmmu_wait(cpu);
d928 1
a928 1
	unsigned *volatile cr;
d932 1
a932 1
		if (m8820x_cmmu[cmmu_num].cmmu_alive != CMMU_DEAD) {
d935 1
a935 1
			cr[CMMU_SCTR] &=
d937 3
a939 3
			cr[CMMU_SAPR] = cr[CMMU_UAPR] =
			    ((0x00000 << PG_BITS) | CACHE_INH) &
			    ~(CACHE_WT | CACHE_GLOBAL | APR_V);
d951 1
a951 1
	unsigned *volatile cr;
d956 1
a956 1
		if (m8820x_cmmu[cmmu_num].cmmu_alive != CMMU_DEAD) {
d958 2
a959 1
			cr[CMMU_SCTR] |= CMMU_SCTR_PE;
d970 1
a970 1
#define ILLADDRESS	0x0f000000 	/* any faulty address */
d984 2
a985 2
			    m8820x_cmmu[cmmu_no].cmmu_type == DATA_CMMU)
				m8820x_cmmu[cmmu_no].cmmu_regs[CMMU_PFSR] = 0;
d994 3
a996 3
			    m8820x_cmmu[cmmu_no].cmmu_type == DATA_CMMU &&
			    CMMU_PFSR_FAULT(m8820x_cmmu[cmmu_no].
			      cmmu_regs[CMMU_PFSR]) != CMMU_PFSR_SUCCESS) {
d998 1
a998 1
				m8820x_cmmu[cmmu_no].cmmu_regs[CMMU_PFSR] = 0;
d1012 1
a1012 1
m8820x_cmmu_set_sapr(cpu, ap)
d1016 2
d1073 1
a1073 1
m8820x_cmmu_flush_tlb(unsigned cpu, unsigned kernel, vaddr_t vaddr,
d1080 2
a1081 17
	/*
	 * Since segment operations are horribly expensive, don't
	 * do any here. Invalidations of up to three pages are performed
	 * as page invalidations, otherwise the entire tlb is flushed.
	 *
	 * Note that this code relies upon size being a multiple of
	 * a page and vaddr being page-aligned.
	 */
	if (size == PAGE_SIZE) {	/* most frequent situation */
		m8820x_cmmu_set(CMMU_SAR, vaddr,
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
		m8820x_cmmu_set(CMMU_SCR,
		    kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE,
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
	} else if (size > 3 * PAGE_SIZE) {
d1086 2
a1087 2
	} else
	while (size != 0) {
a1094 3

		size -= PAGE_SIZE;
		vaddr += PAGE_SIZE;
d1096 6
d1108 10
d1150 1
a1150 1
	 * THE SUPERVISOR TLBs SHOULD BE FLUSHED AS WELL.
d1170 2
d1178 1
a1178 1
m8820x_cmmu_flush_cache(int cpu, paddr_t physaddr, psize_t size)
d1187 1
a1187 1
	} else if (size <= MC88200_CACHE_LINE) {
a1207 2
	m8820x_cmmu_wait(cpu);

d1213 10
d1226 1
a1226 1
m8820x_cmmu_flush_inst_cache(int cpu, paddr_t physaddr, psize_t size)
d1235 1
a1235 1
	} else if (size <= MC88200_CACHE_LINE) {
a1255 2
	m8820x_cmmu_wait(cpu);

d1260 3
d1264 8
a1271 1
m8820x_cmmu_flush_data_cache(int cpu, paddr_t physaddr, psize_t size)
d1280 1
a1280 1
	} else if (size <= MC88200_CACHE_LINE) {
a1300 2
	m8820x_cmmu_wait(cpu);

d1306 10
d1332 1
a1332 1
	} else if (size <= MC88200_CACHE_LINE) {
a1366 2
	m8820x_cmmu_wait(cpu);

d1385 1
a1385 1
	} else if (size <= MC88200_CACHE_LINE) {
a1419 2
	m8820x_cmmu_wait(cpu);

d1438 1
a1438 1
	} else if (size <= MC88200_CACHE_LINE) {
a1472 2
	m8820x_cmmu_wait(cpu);

d1643 1
a1643 1
	if (m8820x_cmmu[cmmu_num].cmmu_alive == CMMU_DEAD) {
d1651 1
a1651 1
		if (!(m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_SCTR] & CMMU_SCTR_SE))
d1656 3
a1658 3
		for (i = 0; i < MAX_CMMUS; i++)
			if ((i == cmmu_num || m8820x_cmmu[i].cmmu_alive != CMMU_DEAD) &&
			    (verbose_flag > 1 || !(m8820x_cmmu[i].cmmu_regs[CMMU_SCTR] & CMMU_SCTR_SE))) {
d1660 2
a1661 2
					  m8820x_cmmu[i].cmmu_cpu, m8820x_cmmu[i].cmmu_type ? "data" : "inst",
					  (m8820x_cmmu[i].cmmu_regs[CMMU_SCTR] & CMMU_SCTR_SE) ? "on":"OFF");
d1666 1
a1666 1
		value = m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_SAPR];
d1668 1
a1668 1
		value = m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_UAPR];
d1695 4
a1698 4
		unsigned *volatile cmmu_regs = m8820x_cmmu[cmmu_num].cmmu_regs;
		cmmu_regs[CMMU_SAR] = address;
		cmmu_regs[CMMU_SCR] = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;
		ssr.bits = cmmu_regs[CMMU_SSR];
d1704 1
a1704 1
				  address, cmmu_regs[CMMU_SAR]);
d1706 1
a1706 1
			db_printf("PROBE fault at 0x%x", cmmu_regs[CMMU_PFAR]);
@


1.1.1.9
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.32 2004/05/07 18:06:35 miod Exp $	*/
a140 1
void m8820x_dma_cachectl_pa(paddr_t, psize_t, int);
a161 1
	m8820x_dma_cachectl_pa,
a1500 42
	}
#endif /* !BROKEN_MMU_MASK */
}

void
m8820x_dma_cachectl_pa(paddr_t pa, psize_t size, int op)
{
#if !defined(BROKEN_MMU_MASK)
	psize_t count;

	while (size != 0) {
		count = NBPG - (va & PGOFSET);

		if (size < count)
			count = size;

		switch (op) {
		case DMA_CACHE_SYNC:
			m8820x_cmmu_sync_cache(pa, count);
			break;
		case DMA_CACHE_SYNC_INVAL:
			m8820x_cmmu_sync_inval_cache(pa, count);
			break;
		default:
			m8820x_cmmu_inval_cache(pa, count);
			break;
		}

		pa += count;
		size -= count;
	}
#else
	switch (op) {
	case DMA_CACHE_SYNC:
		m8820x_cmmu_sync_cache(pa, size);
		break;
	case DMA_CACHE_SYNC_INVAL:
		m8820x_cmmu_sync_inval_cache(pa, size);
		break;
	default:
		m8820x_cmmu_inval_cache(pa, size);
		break;
@


