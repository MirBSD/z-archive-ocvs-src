head	1.5;
access;
symbols
	cvs-200405160640:1.1.1.6
	cvs-200401271800:1.1.1.5
	cvs-200401261630:1.1.1.4
	cvs-200401021645:1.1.1.4
	cvs-200312222040:1.1.1.4
	cvs-200312171912:1.1.1.4
	cvs-200310020700:1.1.1.4
	cvs-200309271030:1.1.1.4
	cvs-200309261655:1.1.1.4
	cvs-200309251530:1.1.1.4
	cvs-200309192030:1.1.1.4
	cvs-200309181930:1.1.1.4
	cvs-200309131952:1.1.1.4
	cvs-200308302005:1.1.1.4
	cvs-200308221505:1.1.1.4
	cvs-200308171200:1.1.1.4
	ctm-3496:1.1.1.4
	ctm-3449:1.1.1.4
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	cvs-200307072125:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200307021520:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	ctm-3255:1.1.1.2
	ctm-3229:1.1.1.2
	MIRBSD_4:1.2
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2003.05.23.13.50.42;	author tg;	state dead;
branches;
next	1.4;

1.4
date	2003.05.03.17.12.12;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.03.14.09.10;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.52.17;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.49.37;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.49.37;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.24.09.05.37;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.34.27;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.29.17.29.42;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.01.27.19.08.43;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.16.08.42.50;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@move bootblocks (pbr and mbr) into their directories
@
text
@/*	$MirBSD: biosboot.S,v 1.4 2003/05/03 17:12:12 tg Exp $	*/
/*	$OpenBSD: biosboot.S,v 1.33 2003/04/17 03:43:18 drahn Exp $	*/

/*
 * Copyright (c) 1997 Michael Shalayeff, Tobias Weingartner, Thorsten Glaser
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
	.file	"biosboot.S"

#include <machine/asm.h>
#include <assym.h>

#define	BLKCNT	36

#define BOOTSEG		0x07c0	/* boot loaded here */
#define BOOTSTACK	0xfffc	/* stack starts here */
#define LFMAGIC		0x464c  /* LFMAGIC (only uses two bytes of \7fELF */


/* Clobbers %al - maybe more */
#define putc(c)			\
	movb	$c, %al;	\
	call	Lchr;

/* Clobbers %esi - maybe more */
#define	puts(s)			\
	mov	$s, %si;	\
	call	Lmessage


	.text
	.code16
	.globl	_start
_start:
	jmp	1f
	nop

	. = _start + 3
	.asciz	"OpenBSD"
	/* BPB */
	. = _start + 0x0b
bpb:	.word	DEV_BSIZE	/* sector size */
	.byte	1		/* sectors/cluster */
	.word	0		/* reserved sectors */
	.byte	0		/* # of FAT */
	.word	0		/* root entries */
	.word	0		/* small sectors */
	.byte	0xf8		/* media type (hd) */
	.word	0		/* sectors/fat */
	.word	0		/* sectors per track */
	.word	0		/* # of heads */

	/* EBPB */
	. = _start + 0x1c
ebpb:	.long	16		/* hidden sectors */
	.long	0		/* large sectors */
	.word	0		/* physical disk */
	.byte	0x29		/* signature, needed by NT */
	.space	4, 0		/* volume serial number */
	.asciz	"UNIX LABEL"
	.ascii	"UFS 4.4"
	.globl	lba_flag
	.type lba_flag, @@function
lba_flag:
	.ascii	"C"		/* L=LBA, everything else=CHS */

	/* boot code */
	. = _start + 0x3e

1:
	/* Fix up %cs just in case */
	data32 ljmp	$BOOTSEG, $1f

load_msg:
	.asciz	"reading boot"

1:
	/* set up stack (%ss:%esp) */
	cli			/* disable interrupts w/o stack */
	xor	%ax, %ax
	mov	%ax, %ss
	movl	$BOOTSTACK, %esp
	sti			/* we have stack, do ints */
	cld

	/* Set up other segment regs */
	mov	$BOOTSEG, %ax
	mov	%ax, %ds
	mov	%ax, %fs
	mov	%ax, %gs

#ifdef SERIAL
	# Initialize the serial port to 9600 baud, 8N1.
	push	%dx
	mov	$0x00e3, %ax
	mov	SERIAL, %dx
	int	$0x14
	pop	%dx
#endif

#ifdef BDEBUG
	putc('R')
#endif

	/* Print pretty message */
	puts(load_msg)

	/* set up %es, (where we will load /boot to) */
	mov	$(LOADADDR >> 4), %ax
	mov	%ax, %es

	xorl	%ebx, %ebx		/* put it at %es:0 */
	movb	block_count, %cl	/* how many to read */
	movzbl	%cl, %ecx
	movw	$block_table, %si

1:
	push	%cx
	putc('.')		/* show progress indicator */

	.intel_syntax noprefix
	cmp	byte ptr [lba_flag],0x4C /* 'L' */
	jne	Lloadchs
	lodsd
	mov	[Lblknm],eax
	lodsb
	mov	[Lblkct],al
	push	ax		/* for incrementing bx */
	mov	ax,es
	shl	eax,16
	mov	ax,bx
	mov	[Lblkbf],eax
	push	si
	mov	si,offset Llbablk
	mov	ah,0x42
	int	0x13
	pop	si
	jc	Lrderr
	jmp	3f

	.att_syntax
Lloadchs:
	lodsw	/* word */	/* cylinder/sector */
	mov	%ax, %cx
	lodsw			/* head */
	movb	%al, %dh
	lodsb			/* # of sectors to load */
	movb	$0x2, %ah
	push	%ax
	int	$0x13
	jnc	3f
Lrderr:
	/* read error */
	puts(2f)
	jmp	halt
2:	.asciz	"\r\nRead error\r\n"

3:	/* read next block */

	pop	%ax
	movzbl	%al, %eax
	shl	$9, %ax		/* 512 bytes sectors */
	add	%ax, %bx
	pop	%cx
	loop	1b

	puts(2f)

	xor	%si, %si
	/* check /boot magic */
	es;lodsw;es;lodsw	/* no need for high word */
	cmp	$LFMAGIC, %ax
	je	3f

	puts(1f)
halt:
	.intel_syntax noprefix
	xor	ah,ah
	int	0x16
	jmp	0xF000,0xFFF0
	.att_syntax
1:	.ascii	"Bad magic"
2:	.asciz	"\r\n"

3:	/* At this point we could try to use the entry point in
	 * the image we just loaded.  But if we do that, we also
	 * have to potentially support loading that image where it
	 * is supposed to go.  Screw it, just assume that the image
	 * is sane.
	 */
#ifdef BDEBUG
	putc('P')
#endif

#ifdef	BDEBUG
	movl	$0xb8004, %ebx
	movl	$0x074f0747, (%ebx)
#endif

	movzbl	%dl, %eax	/* drive number is in the lowest byte */
	pushl	%eax
	pushl	$BOOTMAGIC	/* use some magic */

	/* jmp	/boot */
	/* data32 */
	ljmp $(LINKADDR >> 4), $0
	/* not reached */

/* LBA parameter block */
Llbablk:
	.word	0x0010		/* length, reserved */
Lblkct:	.word	0x0001		/* num. of sectors */
Lblkbf:	.long	0x00007C00	/* transfer buffer */
Lblknm:	.long	0,0		/* LBA block number */

/*
 * Display string
 */
Lmessage:
	push	%ax
1:
	lodsb			# load a byte into %al
	testb	%al, %al
	jz	1f
	call	Lchr
	jmp	1b

#
#	Lchr: write the character in %al to console
#
Lchr:
	push	%ax

#ifndef SERIAL
	push	%bx
	movb	$0x0e, %ah
	xor	%bx, %bx
	inc	%bx		/* movw $0x01, %bx */
	int	$0x10
	pop	%bx
#else
	push	%dx
	movb	$0x01, %ah
	xor	%dx, %dx
	movb	SERIAL, %dl
	int	$0x14
	pop	%dx
#endif
1:
	pop	%ax
	ret

	#.data
	.globl	block_table, block_count
	.type block_count, @@function
	.type block_table, @@function
block_count:
	.byte	BLKCNT	/* entries in block_table */
block_table:
	.word	0	/* cylinder/sector */
	.word	0	/* head (high), drive (low) UNUSED! */
	.byte	0	/* nsect */
	. = block_table + BLKCNT*5

	. = 0x200 - 2
	/* a little signature */
	.word	DOSMBR_SIGNATURE
@


1.4
log
@believe it or not, but I was able to boot
a /boot that lies completely in LBA zone
(cylinder 1200-something)...
@
text
@d1 1
a1 1
/*	$MirBSD: biosboot.S,v 1.3 2003/05/03 14:09:10 tg Exp $	*/
@


1.3
log
@extend block table from 4 to 5 bytes each entry
implement LBA support
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
d160 1
d164 1
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 2
a2 1
/*	$OpenBSD: biosboot.S,v 1.32 2002/08/28 20:15:34 mickey Exp $	*/
d5 1
a5 1
 * Copyright (c) 1997 Michael Shalayeff, Tobias Weingartner
d40 1
a40 1
#define	BLKCNT	52
d88 5
a92 1
	.asciz	"UFS 4.4"
d111 1
a115 1
	mov	%ax, %es
d147 21
a167 1
	cld
d170 1
a170 1
	lodsb			/* head */
d177 1
a177 1

a194 1
	cld
d202 5
a206 4
	cli
99:
	hlt
	jmp 99b
d234 7
a245 1
	cld
d286 1
a286 1
	.byte	0	/* head */
d288 1
a288 1
	. = block_table + BLKCNT*4
@


1.1
log
@Initial revision
@
text
@d39 1
a39 4
#define addr32  .byte 0x67
#define data32  .byte 0x66

#define	BLKCNT	12
d43 1
a43 1
#define ZMAGIC		0x0b01	/* ZMAGIC */
d49 1
a49 2
	.byte	0xe8;		\
	.word	Lchr - . - 2
d53 2
a54 4
	data32;			\
	movl	$s, %esi;	\
	.byte	0xe8;		\
	.word	Lmessage - . - 2
d58 3
a60 2
	.globl	start
start:
d64 1
a64 1
	. = start + 3
d67 1
a67 1
	. = start + 0x0b
d80 1
a80 1
	. = start + 0x1c
d90 1
a90 1
	. = start + 0x3e
d94 1
a94 2
	data32
	ljmp	$BOOTSEG, $1f
d102 2
a103 3
	xorl	%ax, %ax
	movl	%ax, %ss
	data32
d108 5
a112 7
	# movw	$BOOTSEG, %ax
	.byte	0xb8
	.word	BOOTSEG
	movl	%ax, %ds
	movl	%ax, %es
	movl	%ax, %fs
	movl	%ax, %gs
d116 3
a118 7
	pushl	%dx
	# movw	$0x00e3, %ax
	.byte	0xb8
	.word	0x00e3
	# movw	SERIAL, %dx
	.byte	0xba
	.word	SERIAL
d120 1
a120 1
	popl	%dx
d131 2
a132 4
	# movw	$(LOADADDR >> 4), %ax
	.byte	0xb8
	.word	LOADADDR >> 4
	movl	%ax, %es
a133 1
	data32
d135 1
a135 2
	addr32
	movb	_block_count, %cl	/* how many to read */
d137 1
a137 3
	# movw	$_block_table, %si
	.byte	0xbe
	.word	_block_table
d140 1
a140 1
	pushl	%cx
d143 2
a144 2
	lodsl	/* word */	/* cylinder/sector */
	movl	%ax, %cx
d149 1
a149 1
	pushl	%ax
d160 1
a160 2
	popl	%ax
	data32
d162 3
a164 3
	shll	$9, %ax		/* 512 bytes sectors */
	addl	%ax, %bx
	popl	%cx
d169 1
a169 1
	xorl	%si, %si
d172 2
a173 4
	es;lodsl;es;lodsl	/* no need for high word */
	# cmpw	$ZMAGIC, %ax
	.byte	0x3d
	.word	ZMAGIC
d179 1
d181 1
a194 34
	/* change to protected mode */
	/* guarantee that interrupts are disabled when in prot mode */
	cli

	/* load the gdtr */
	addr32
	data32
	lgdt	Gdtr

	/* set the PE bit of CR0 */
	movl	%cr0, %eax
	data32
	orl	$CR0_PE, %eax
	movl	%eax, %cr0 

	/*
	 * make intrasegment jump to flush the processor pipeline and
	 * reload CS register
	 */
	data32
	ljmp	$8, $(BOOTSEG << 4) + 1f

1:	/*
	 * 32bit mode
	 * set up %ds, %ss, %es, etc
	 */
	movl	$0x10, %eax
	movl	%ax, %ds
	movl	%ax, %ss
	movl	%ax, %es
	movl	%ax, %fs
	movl	%ax, %gs
	movl	$BOOTSTACK, %esp

d205 2
a206 1
	ljmp	$8, $(LOADADDR + 0x20)
d213 1
a213 2
	data32
	pushl	%eax
d219 1
a219 3
	# call	Lchr
	.byte	0xe8
	.word	Lchr - . - 2
d226 1
a226 2
	data32
	pushl	%eax
d229 1
a229 2
	data32
	pushl	%ebx
d231 2
a232 2
	xorl	%bx, %bx
	incl	%bx		/* movw $0x01, %bx */
d234 1
a234 2
	data32
	popl	%ebx
d236 1
a236 2
	data32
	pushl	%edx
d238 1
a238 1
	xorl	%dx, %dx
d241 1
a241 2
	data32
	popl	%edx
d244 1
a244 2
	data32
	popl	%eax
d247 7
a253 24
	.align	3
1:		/* 0x00 : null */
	.long	0, 0
		/* 0x08 : flat code */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMERAC | 0 | 0x80	# RWXAC, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
		/* 0x10 : flat data */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMRWA | 0 | 0x80	# RWA, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
Gdtr:	.word	. - 1b
	.long	(BOOTSEG << 4) + 1b

	.globl	_block_table, _block_count
_block_count:
	.byte	BLKCNT	/* entries in _block_table */
_block_table:
d257 1
a257 1
	. = _block_table + BLKCNT*4
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import some parts of OpenBSD-current (after their ELF switch) to ease future merging and reduce diffs against their codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.33 2003/04/17 03:43:18 drahn Exp $	*/
d39 4
a42 1
#define	BLKCNT	52
d46 1
a46 1
#define LFMAGIC		0x464c  /* LFMAGIC (only uses two bytes of \7fELF */
d52 2
a53 1
	call	Lchr;
d57 4
a60 2
	mov	$s, %si;	\
	call	Lmessage
d64 2
a65 3
	.code16
	.globl	_start
_start:
d69 1
a69 1
	. = _start + 3
d72 1
a72 1
	. = _start + 0x0b
d85 1
a85 1
	. = _start + 0x1c
d95 1
a95 1
	. = _start + 0x3e
d99 2
a100 1
	data32 ljmp	$BOOTSEG, $1f
d108 3
a110 2
	xor	%ax, %ax
	mov	%ax, %ss
d115 7
a121 5
	mov	$BOOTSEG, %ax
	mov	%ax, %ds
	mov	%ax, %es
	mov	%ax, %fs
	mov	%ax, %gs
d125 7
a131 3
	push	%dx
	mov	$0x00e3, %ax
	mov	SERIAL, %dx
d133 1
a133 1
	pop	%dx
d144 4
a147 2
	mov	$(LOADADDR >> 4), %ax
	mov	%ax, %es
d149 1
d151 2
a152 1
	movb	block_count, %cl	/* how many to read */
d154 3
a156 1
	movw	$block_table, %si
d159 1
a159 1
	push	%cx
d162 2
a163 2
	lodsw	/* word */	/* cylinder/sector */
	mov	%ax, %cx
d168 1
a168 1
	push	%ax
d179 2
a180 1
	pop	%ax
d182 3
a184 3
	shl	$9, %ax		/* 512 bytes sectors */
	add	%ax, %bx
	pop	%cx
d189 1
a189 1
	xor	%si, %si
d192 4
a195 2
	es;lodsw;es;lodsw	/* no need for high word */
	cmp	$LFMAGIC, %ax
a200 1
99:
a201 1
	jmp 99b
d215 34
d259 1
a259 2
	/* data32 */
	ljmp $(LINKADDR >> 4), $0
d266 2
a267 1
	push	%ax
d273 3
a275 1
	call	Lchr
d282 2
a283 1
	push	%ax
d286 2
a287 1
	push	%bx
d289 2
a290 2
	xor	%bx, %bx
	inc	%bx		/* movw $0x01, %bx */
d292 2
a293 1
	pop	%bx
d295 2
a296 1
	push	%dx
d298 1
a298 1
	xor	%dx, %dx
d301 2
a302 1
	pop	%dx
d305 2
a306 1
	pop	%ax
d309 24
a332 7
	#.data
	.globl	block_table, block_count
	.type block_count, @@function
	.type block_table, @@function
block_count:
	.byte	BLKCNT	/* entries in block_table */
block_table:
d336 1
a336 1
	. = block_table + BLKCNT*4
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.34 2003/06/03 20:22:11 mickey Exp $	*/
d15 5
@


1.1.1.4
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.35 2003/06/27 18:27:53 weingart Exp $	*/
a3 1
 * Copyright (c) 2003 Tobias Weingartner
d34 1
a34 1
#define	BLKCNT	63
d36 1
a36 1
#define BOOTSEG		0x07c0	/* biosboot loaded here */
d89 1
a89 1
	ljmp	$BOOTSEG, $1f
d95 1
a95 1
	/* set up stack (%ss:%sp) */
d99 1
a99 1
	mov	$BOOTSTACK, %sp
d102 1
a102 1
	/* Set up needed data segment reg */
d105 3
d129 1
a129 1
	xorw	%bx, %bx		/* put it at %es:0 */
d131 1
a131 1
	movzbw	%cl, %cx
d156 1
a156 1
	movzbw	%al, %ax
d190 5
d200 1
@


1.1.1.5
log
@using: ========= cvsim-base-obsd _MirBSD: cvsim-src-openbsd,v 1.3 2004/01/27 17:17:54 tg Exp $ =========

In contrast to what people might believe now,
I am not "specially" attracted by CVS Imports
(neither am I a version number hunter).
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.36 2004/01/26 23:21:49 tom Exp $	*/
a4 1
 * Copyright (c) 2003 Tom Cosgrove <tom.cosgrove@@arches-consulting.com>
d35 1
a35 5
/* Error indicators */
#define PBR_READ_ERROR			'R'
#define PBR_CANT_BOOT			'X'
#define PBR_BAD_MAGIC			'M'
#define PBR_TOO_MANY_INDIRECTS		'I'
a36 35
#define CHAR_BLOCK_READ		'.'
#define CHAR_CHS_READ		';'

/*
 * Memory layout:
 *
 * 0x00000 -> 0x079FF	our stack		(to  30k5)
 * 0x07A00 -> 0x07BFF	typical MBR loc		(at  30k5)
 * 0x07C00 -> 0x07DFF	our code		(at  31k)
 * 0x07E00 -> ...    	/boot inode block	(at  31k5)
 * 0x07E00 -> ...    	(indirect block if nec)
 * 0x40000 -> ...	/boot			(at 256k)
 *
 * The BIOS loads the MBR at physical address 0x07C00.  It then relocates
 * itself to (typically) 0x07A00.
 *
 * The MBR then loads us at physical address 0x07C00.
 *
 * We use a long jmp to normalise our address to seg:offset 07C0:0000.
 * (In real mode on x86, segment registers contain a base address in
 * paragraphs (16 bytes).  0000:00010 is the same as 0001:0000.)
 *
 * We set the stack to start at 0000:79FC (grows down on i386)
 *
 * We then read the inode for /boot into memory just above us at
 * 07E0:0000, and run through the direct block table (and the first
 * indirect block table, if necessary).
 *
 * We load /boot at seg:offset 4000:0000.
 *
 * Previous versions limited the size of /boot to 64k (loaded in a single
 * segment).  This version does not have this limitation.
 */
#define INODESEG	0x07e0	/* where we put /boot's inode's block */
#define INDIRECTSEG	0x07e0	/* where we put indirect table, if nec */
d38 2
a39 3
#define BOOTSTACKOFF  ((BOOTSEG << 4) - 4)  /* stack starts here, grows down */
#define LFMAGIC		0x464c  /* LFMAGIC (last two bytes of \7fELF) */
#define ELFMAGIC    0x464c457f  /* ELFMAGIC ("\7fELF") */
a40 51
#define INODEOFF  ((INODESEG-BOOTSEG) << 4)

/*
 * The data passed by installboot is:
 *
 * inodeblk	uint32	the filesystem block that holds /boot's inode
 * inodedbl	uint32	the memory offset to the beginning of the
 *			direct block list (di_db[]).  (This is the
 *			offset within the block + $INODEOFF, which is
 *			where we load the block to.)
 * fs_bsize_p	uint16	the filesystem block size _in paragraphs_
 *			(i.e. fs_bsize / 16)
 * fs_bsize_s	uint16	the number of 512-byte sectors in a filesystem
 *			block (i.e. fs_bsize / 512).  Directly written
 *			into the LBA command block, at lba_count.
 *			XXX LIMITED TO 127 BY PHOENIX EDD SPEC.
 * fsbtodb	uint8	shift count to convert filesystem blocks to
 *			disk blocks (sectors).  Note that this is NOT
 *			log2 fs_bsize, since fragmentation allows
 *			the trailing part of a file to use part of a
 *			filesystem block.  In other words, filesystem
 *			block numbers can point into the middle of
 *			filesystem blocks.
 * p_offset	uint32	the starting disk block (sector) of the
 *			filesystem
 * nblocks	uint16	the number of filesystem blocks to read.
 *			While this can be calculated as
 *			howmany(di_size, fs_bsize) it takes us too
 *			many code bytes to do it.
 *
 * All of these are patched directly into the code where they are used
 * (once only, each), to save space.
 *
 * One more symbol is exported, in anticipation of a "-c" flag in
 * installboot to force CHS reads:
 *
 * force_chs	uint8	set to the value 1 to force biosboot to use CHS
 *			reads (this will of course cause the boot sequence
 *			to fail if /boot is above 8 GB).
 */

	.globl	inodeblk, inodedbl, fs_bsize_p, fsbtodb, p_offset, nblocks
	.globl	fs_bsize_s, force_chs
	.type	inodeblk, @@function
	.type	inodedbl, @@function
	.type	fs_bsize_p, @@function
	.type	fs_bsize_s, @@function
	.type	fsbtodb, @@function
	.type	p_offset, @@function
	.type	nblocks, @@function
	.type	force_chs, @@function
d42 9
a50 6

/* Clobbers %ax, maybe more */
#define	putc(c)		movb	$c, %al;	call	Lchr

/* Clobbers %ax, %si, maybe more */
#define	puts(s)		movw	$s, %si;	call	Lmessage
d57 1
a57 1
	jmp	begin
a59 20
	/*
	 * BIOS Parameter Block.  Read by many disk utilities.
	 *
	 * We would have liked biosboot to go from the superblock to
	 * the root directory to the inode for /boot, thence to read
	 * its blocks into memory.
	 *
	 * As code and data space is quite tight in the 512-byte
	 * partition boot sector, we instead get installboot to pass
	 * us some pre-processed fields.
	 *
	 * We would have liked to put these in the BIOS parameter block,
	 * as that seems to be the right place to put them (it's really
	 * the equivalent of the superblock for FAT filesystems), but
	 * caution prevents us.
	 *
	 * For now, these fields are either directly in the code (when they
	 * are used once only) or at the end of this sector.
	 */

a60 1

a61 1

d64 10
a73 10
bpb:	.word	DEV_BSIZE			/* sector size */
	.byte	2				/* sectors/cluster */
	.word	0				/* reserved sectors */
	.byte	0				/* # of FAT */
	.word	0				/* root entries */
	.word	0				/* small sectors */
	.byte	0xf8				/* media type (hd) */
	.word	0				/* sectors/fat */
	.word	0				/* sectors per track */
	.word	0				/* # of heads */
d77 6
a82 6
ebpb:	.long	16			/* hidden sectors */
	.long	0			/* large sectors */
	.word	0			/* physical disk */
	.byte	0x29			/* signature, needed by NT */
	.space	4, 0			/* volume serial number */
	.ascii	"UNIX LABEL"
d88 1
a88 1
begin:
d90 1
a90 1
	ljmp	$BOOTSEG, $main
d92 10
a101 15
	/*
	 * Come here if we have to do a CHS boot, but we get an error from
	 * BIOS get drive parameters, or it returns nsectors == 0 (in which
	 * case we can't do the division we need to convert LBA sector
	 * number to CHS).
	 */
cant_boot:
	movb	$PBR_CANT_BOOT, %al
	jmp	err_print_crlf

main:
	/* Set up stack */
	xorw	%ax, %ax
	movw	%ax, %ss
	movw	$BOOTSTACKOFF, %sp
d104 2
a105 2
	pushw	%cs
	popw	%ds			/* Now %cs == %ds, != %ss (%ss == 0) */
d108 1
a108 1
	/* Initialize the serial port to 9600 baud, 8N1 */
d110 2
a111 2
	movw	$0x00e3, %ax
	movw	SERIAL, %dx
a119 39
	/*
	 * We're going to print our sign-on message.
	 *
	 * We're now LBA-aware, and will use LBA to load /boot if the
	 * BIOS says it's available.  However, we have seen machines
	 * where CHS is required even when LBA is available.  Therefore
	 * we provide a way to force CHS use:
	 *
	 * If the SHIFT key is held down on entry, force CHS reads.
	 */
	movw	$load_msg+1, %si	/* "Loading" */
	movb	%dl, %dh

	/*
	 * BIOS call "INT 0x16 Get Keyboard Shift Flags
	 *	Call with	%ah = 0x02
	 *	Return:
	 *			%al = shift flags
	 *			%ah - undefined by many BIOSes
	 */
	movb	$0x02, %ah
	int	$0x16

	/*
	 * We provide the ability to force CHS use without having to hold
	 * down the SHIFT key each boot.  Just set the byte at force_chs
	 * to 1 (more accurately any value with either of the bottom two
	 * bits set, but the use of 1 is recommended).
	 */
force_chs = .+1
	orb	$0, %al

	testb	$0x3, %al		/* Either shift key down? */
	jz	no_force_chs

	decw	%si			/* "!Loading" indicates forced CHS */
	xorb	%dh, %dh		/* Pretend a floppy, so no LBA use */

no_force_chs:
d121 1
a121 1
	call	Lmessage
d123 8
a130 3
	/*
	 * We will use LBA reads if we have LBA support, so find out.
	 */
d132 11
a142 31
	/*
	 * But don't even try on floppies, OR if forcing to CHS.
	 *
	 * (We're really testing %dl, but use %dh so we can force the
	 * top bit to zero to force CHS boot.)
	 */
	testb	$0x80, %dh
	jz	no_lba

	/*
	 * BIOS call "INT 0x13 Extensions Installation Check"
	 *	Call with	%ah = 0x41
	 *			%bx = 0x55AA
	 *			%dl = drive (0x80 for 1st hd, 0x81 for 2nd, etc)
	 *	Return:
	 *			carry set: failure
	 *				%ah = error code (0x01, invalid func)
	 *			carry clear: success
	 *				%bx = 0xAA55 (must verify)
	 *				%ah = major version of extensions
	 *				%al   (internal use)
	 *				%cx = capabilities bitmap
	 *					0x0001 - extnd disk access funcs
	 *					0x0002 - rem. drive ctrl funcs
	 *					0x0004 - EDD functions with EBP
	 *				%dx   (extension version?)
	 */

	pushw	%dx			/* Save the drive number (%dl) */
	movw	$0x55AA, %bx
	movb	$0x41, %ah
d144 1
a144 1
	popw	%dx			/* Retrieve drive number */
d146 13
a158 137
	jc	no_lba			/* Did the command work? Jump if not */
	cmpw	$0xAA55, %bx		/* Check that bl, bh exchanged */
	jne	no_lba			/* If not, don't have EDD extensions */
	testb	$0x01, %cl		/* And do we have "read" available? */
	jz	no_lba			/* Again, use CHS if not */

	/* We have LBA support, so that's the vector to use */

	movw	$load_lba, load_fsblock
	jmp	get_going

no_lba:
	pushw	%dx

	/*
	 * BIOS call "INT 0x13 Function 0x08" to get drive parameters
	 *	Call with        %ah = 0x08
	 *                       %dl = drive (0x80 for 1st hd, 0x81 for 2nd...)
	 *       Return:
	 *                       carry set: failure
	 *                           %ah = err code
	 *                       carry clear: success
	 *                           %ah = 0x00
	 *                           %al = 0x00 (some BIOSes)
	 *                           %ch = 0x00 (some BIOSes)
	 *                           %ch = max-cylinder & 0xFF
	 *                           %cl = max sector | rest of max-cyl bits
	 *                           %dh = max head number
	 *                           %dl = number of drives
	 *                                 (according to Ralph Brown Int List)
	 */
	movb	$0x08, %ah
	int	$0x13			/* We need to know heads & sectors */

	jc	cant_boot		/* If error, can't boot */

	movb	%dh, maxheads		/* Remember this */

	andb	$0x3F, %cl
	jz	cant_boot
	movb	%cl, nsectors

	putc(CHAR_CHS_READ)		/* Indicate (subtly) CHS reads */

	popw	%dx			/* Retrieve the drive number */

get_going:
	/*
	 * Older versions of biosboot used to set up the destination
	 * segment, and increase the target offset every time a number
	 * of blocks was read.  That limits /boot to 64k.
	 *
	 * In order to support /boots > 64k, we always read to offset
	 * 0000 in the target segment, and just increase the target segment
	 * each time.
	 */

	/*
	 * We would do movl inodeblk, %eax  here, but that instruction
	 * is 4 bytes long; add 4 bytes for data takes 8 bytes.  Using
	 * a load immediate takes 6 bytes, and we just get installboot
	 * to patch here, rather than data anywhere else.
	 */
inodeblk = .+2
	movl	$0x90909090, %eax	/* mov $inodeblk, %eax */

	movw	$INODESEG, %bx		/* Where to put /boot's inode */

	/*
	 * %eax - filesystem block to read
	 * %bx  - target segment (target offset is 0000)
	 * %dl  - BIOS drive number
	 */
	call	*load_fsblock		/* This will crash'n'burn on errs */

	/*
	 * We now have /boot's inode in memory.
	 *
	 * /usr/include/ufs/ufs/dinode.h for the details:
	 *
	 * Offset  8 (decimal): 64-bit file size (only use low 32 bits)
	 * Offset 40 (decimal): list of NDADDR (12) direct disk blocks
	 * Offset 88 (decimal): list of NIADDR (3) indirect disk blocks
	 *
	 * NOTE: list of indirect blocks immediately follows list of
	 * direct blocks.  We use this fact in the code.
	 *
	 * We only support loading from direct blocks plus the first
	 * indirect block.  This is the same as the previous biosboot/
	 * installboot limit.  Note that, with default 16,384-bytes
	 * filesystem blocks, the direct block list supports files up
	 * to 192 KB.  /boot is currently around 60 KB.
	 *
	 * The on-disk format can't change (filesystems with this format
	 * already exist) so okay to hardcode offsets here.
	 *
	 * The nice thing about doing things with filesystem blocks
	 * rather than sectors is that filesystem blocks numbers have
	 * 32 bits, so fit into a single register (even if "e"d).
	 *
	 * Note that this code does need updating if booting from a new
	 * filesystem is required.
	 */
#define NDADDR	12
#define di_db	40			/* Not used; addr put in by instboot */
#define di_ib	88			/* Not used; run on from direct blks */

	/*
	 * Register usage:
	 *
	 * %eax - block number for load_fsblock
	 * %bx  - target segment (target offset is 0000) for load_fsblock
	 * %dl  - BIOS drive number for load_fsblock
	 * %esi - points to block table in inode/indirect block
	 * %cx  - number of blocks to load within loop (i.e. from current
	 *	  block list, which is either the direct block list di_db[]
	 *	  or the indirect block list)
	 * %di  - total number of blocks to load
	 */

	/*
	 * We would do movl inodedbl, %esi  here, but that instruction
	 * is 4 bytes long; add 4 bytes for data takes 8 bytes.  Using
	 * a load immediate takes 6 bytes, and we just get installboot
	 * to patch here, rather than in data anywhere else.
	 */
inodedbl = .+2
	movl	$0x90909090, %esi	/* mov $inodedbl, %esi */
					/* Now esi -> di_db[] */

nblocks = .+1
	movw	$0x9090, %di		/* mov nblocks, %di */
	movw	%di, %cx
	cmpw	$NDADDR, %cx
	jc	1f
	movw	$NDADDR, %cx
1:					/* %cx = min(nblocks, $NADDR) */
d160 1
a160 4
	movw	$(LOADADDR >> 4), %bx	/* Target segment for /boot */

load_blocks:
	putc(CHAR_BLOCK_READ)		/* Show progress indicator */
d162 1
d164 4
d169 2
a170 114
	/* Get the next filesystem block number into %eax */
	lodsl			/* %eax = *(%si++), make sure 0x66 0xad */

	pushal				/* Save all 32-bit registers */

	/*
	 * Read a single filesystem block (will almost certainly be multiple
	 * disk sectors)
	 *
	 * %eax - filesystem block to read
	 * %bx  - target segment (target offset is 0000)
	 * %dl  - BIOS drive number
	 */
	call	*load_fsblock		/* This will crash'n'burn on errs */

	popal				/* Restore 32-bit registers */

	/*
	 * We want to put addw fs_bsize_p, %bx, which takes 4 bytes
	 * of code and two bytes of data.
	 *
	 * Instead, use an immediate load, and have installboot patch
	 * here directly.
	 */
	/* Move on one filesystem block */
fs_bsize_p = .+2
	addw	$0x9090, %bx		/* addw $fs_bsize_p, %bx */

	decw	%di
	loop	load_blocks

	/* %cx == 0 ... important it stays this way (used later) */

	/*
	 * Finished reading a set of blocks.
	 *
	 * This was either the direct blocks, and there may or may not
	 * be indirect blocks to read, or it was the indirect blocks,
	 * and we may or may not have read in all of /boot.  (Ideally
	 * will have read in all of /boot.)
	 */
	orw	%di, %di
	jz	done_load		/* No more sectors to read */

	/* We have more blocks to load */

	/* We only support a single indirect block (the same as previous
	 * versions of installboot.  This is required for the boot floppies.
	 *
	 * We use a bit of the code to store a flag that indicates
	 * whether we have read the first indirect block or not.
	 *
	 * If we've already read the indirect list, we can't load this /boot.
	 *
	 * indirect	uint8	0 => running through load_blocks loop reading
	 *			direct blocks.  If != 0, we're reading the
	 *			indirect blocks.  Must use a field that is
	 *			initialised to 0.
	 */
indirect = .+2
	movw	$PBR_TOO_MANY_INDIRECTS, %ax	/* movb $PRB_TOO..., %al */
						/* movb indirect, %ah */
	orb	%ah, %ah
	jnz	err_print_crlf

	incb	indirect		/* No need to worry about wrap */
					/* around, as this will only be done */
					/* once before we fail */

	/* Okay, let's read in the indirect block */

	lodsl				/* Get blk num of 1st indirect blk */

	pushw	%bx			/* Remember where we got to */
	movw	$INODESEG, %bx
	call	*load_fsblock		/* This will crash'n'burn on errs */
	popw	%bx			/* Indirect blocks get added on to */
					/* just after where we got to */
	movl	$INODEOFF, %esi
	movw	%di, %cx		/* How many blocks left to read */

	jmp	load_blocks

done_load:
	puts(crlf)

	/* %cx == 0 from loop above... keep it that way */

	/*
	 * Check the magic signature at the beginning of /boot.
	 * Since /boot is now ELF, this should be 0xFF E L F.
	 */
	movw	$(LOADADDR >> 4), %ax	/* Target segment */
	movw	%ax, %es

	/*
	 * We cheat a little here, and only check the L and F.
	 *
	 * (Saves 3 bytes of code... the two signature bytes we
	 * don't check, and the operand size prefix that's not
	 * needed.)
	 */
	cmpw	$LFMAGIC, %es:2(,1)
	je	exec_boot

	movb	$PBR_BAD_MAGIC, %al

err_print:
	movw	$err_txt, %si
err_print2:
	movb	%al, err_id
err_stop:
	call	Lmessage
stay_stopped:
d172 1
d174 3
a176 1
	jmp	stay_stopped		/* Just to make sure :-) */
d178 1
a178 2
exec_boot:
	/* At this point we could try to use the entry point in
d188 2
a189 13
	/* %cx == 0 from loop above... keep it that way */

	/*
	 * We want to do movzbl %dl, %eax ; pushl %eax to zero-extend the
	 * drive number to 32 bits and pass it to /boot.  However, this
	 * takes 6 bytes.
	 *
	 * Doing it this way saves 2 bytes.
	 */
	pushw	%cx
	movb	%dl, %cl
	pushw	%cx

a195 208

/*
 * Load a single filesystem block into memory using CHS calls.
 *
 * Input:	%eax - 32-bit filesystem block number
 * 		%bx  - target segment (target offset is 0000)
 * 		%dl  - BIOS drive number
 *
 * Output:	block successfully read in (panics if not)
 *		all general purpose registers may have been trashed
 */
load_chs:
	/*
	 * BIOS call "INT 0x13 Function 0x2" to read sectors from disk into
	 * memory.
	 *	Call with        %ah = 0x42
	 *                       %ah = 0x2
	 *                       %al = number of sectors
	 *                       %ch = cylinder & 0xFF
	 *                       %cl = sector (0-63) | rest of cylinder bits
	 *                       %dh = head
	 *                       %dl = drive (0x80 for 1st hd, 0x81 for 2nd...)
	 *                       %es:%bx = segment:offset of buffer
	 *       Return:
	 *                       carry set: failure
	 *                           %ah = err code
	 *                           %al = number of sectors transferred
	 *                       carry clear: success
	 *                           %al = 0x0 OR number of sectors transferred
	 *                                 (depends on BIOS!)
	 *                                 (according to Ralph Brown Int List)
	 */

	/* Convert the filesystem block into a sector value */
	call	fsbtosector
	movl	lba_sector, %eax	/* we can only use 24 bits, really */

	movw	fs_bsize_s, %cx	/* sectors per filesystem block */

	/*
	 * Some BIOSes require that reads don't cross track boundaries.
	 * Therefore we do all CHS reads single-sector.
	 */
calc_chs:
	pushal
	movw	%bx, %es	/* Set up target segment */

	pushw	%dx		/* Save drive number (in %dl) */
	xorl	%edx, %edx
	movl	%edx, %ecx

nsectors = .+1
	movb	$0x90, %cl	/* movb $nsectors, %cl */
				/* Doing it this way saves 4-2 = 2 bytes code */
				/* bytes (no data, since we would overload) */

	divl	%ecx, %eax
				/* Now have sector number in %dl */
	pushw	%dx		/* Remember for later */

	xorl	%edx, %edx

maxheads = .+1
	movb	$0x90, %cl	/* movb $maxheads, %cl; 0 <= maxheads <= 255 */
				/* Doing it this way saves 4-2 = 2 code */
				/* bytes (no data, since we would overload */

	incw	%cx		/* Number of heads is 1..256, no "/0" worries */

	divl	%ecx, %eax
				/* Have head number in %dl */
				/* Cylinder number in %ax */
	movb	%al, %ch	/* Bottom 8 bits of cyl number */
	shlb	$6, %ah		/* Move up top 2 bits of cyl number */
	movb	%ah, %cl	/* Top 2 bits of cyl number in here */

	popw	%bx		/* (pushed %dx, but need %dl for now */
	incb	%bl		/* Sector numbers run from 1, not 0 */
	orb	%bl, %cl	/* Or the sector number into top bits cyl */

				/* Remember, %dl has head number */
	popw	%ax
				/* %al has BIOS drive number -> %dl */

	movb	%dl, %dh	/* Now %dh has head number (from 0) */
	movb	%al, %dl	/* Now %dl has BIOS drive number */

	xorw	%bx, %bx	/* Set up target offset */

	movw	$0x0201, %ax	/* %al = 1 - read one sector at a time */
				/* %ah = 2 - int 0x13 function for CHS read */

	call	do_int_13	/* saves us 1 byte :-) */

	/* Get the next sector */

	popal
	incl	%eax
	addw	$32, %bx	/* Number of segments/paras in a sector */
	loop	calc_chs

	ret

	/* read error */
read_error:
	movb	$PBR_READ_ERROR, %al
err_print_crlf:
	movw	$err_txt_crlf, %si
	jmp	err_print2


/*
 * Load a single filesystem block into memory using LBA calls.
 *
 * Input:	%eax - 32-bit filesystem block number
 * 		%bx  - target segment (target offset is 0000)
 * 		%dl  - BIOS drive number
 *
 * Output:	block successfully read in (panics if not)
 *		all general purpose registers may have been trashed
 */
load_lba:
	/*
	 * BIOS call "INT 0x13 Extensions Extended Read"
	 *	Call with	%ah = 0x42
	 *			%dl = drive (0x80 for 1st hd, 0x81 for 2nd, etc)
	 *			%ds:%si = segment:offset of command packet
	 *	Return:
	 *			carry set: failure
	 *				%ah = error code (0x01, invalid func)
	 *				command packet's sector count field set
	 *				to the number of sectors successfully
	 *				transferred
	 *			carry clear: success
	 *				%ah = 0 (success)
	 *	Command Packet:
	 *			0x0000	BYTE	packet size (0x10 or 0x18)
	 *			0x0001	BYTE	reserved (should be 0)
	 *			0x0002	WORD	sectors to transfer (max 127)
	 *			0x0004	DWORD	seg:offset of transfer buffer
	 *			0x0008	QWORD	starting sector number
	 */
	call	fsbtosector		/* Set up lba_sector & lba_sector+4 */

	/* movb	%dh, lba_count		<- XXX done by installboot */
	movw	%bx, lba_seg
	movw	$lba_command, %si
	movb	$0x42, %ah
do_int_13:
	int	$0x13
	jc	read_error

	ret


/*
 * Converts a given filesystem block number into a disk sector
 * at lba_sector and lba_sector+4.
 *
 * Input:	%eax - 32-bit filesystem block number
 *
 * Output:	lba_sector and lba_sector+4 set up
 *		XXX
 */
fsbtosector:
	/*
	 * We want to do
	 *
	 * movb	fsbtodb, %ch		/# Shift counts we'll need #/
	 * movb	$32, %cl
	 *
	 * which is 6 bytes of code + 1 byte of data.
	 *
	 * We'll actually code it with an immediate 16-bit load into %cx,
	 * which is just 3 bytes of data (saves 4 bytes).
	 */
fsbtodb = .+2
	movw	$0x9020, %cx		/* %ch = fsbtodb, %cl = 0x20 */

	pushl	%eax
	subb	%ch, %cl
	shrl	%cl, %eax
	movl	%eax, lba_sector+4
	popl	%eax

	movb	%ch, %cl
	shll	%cl, %eax

	/*
	 * And add p_offset, which is the block offset to the start
	 * of the filesystem.
	 *
	 * We would do addl p_offset, %eax, which is 5 bytes of code
	 * and 4 bytes of data, but it's more efficient to have
	 * installboot patch directly in the code (this variable is
	 * only used here) for 6 bytes of code (but no data).
	 */
p_offset = .+2
	addl	$0x90909090, %eax	/* addl $p_offset, %eax */

	movl	%eax, lba_sector
	jnc	1f

	incl	lba_sector+4
1:
	ret


d200 1
d203 2
a204 2
	lodsb			/* load a byte into %al */
	orb	%al, %al
d209 3
a211 3
/*
 *	Lchr: write the character in %al to console
 */
d213 11
a223 2
#ifdef SERIAL
	pushw	%dx
d225 1
a225 1
	xorw	%dx, %dx
d228 1
a228 8
	popw	%dx
#else
	pushw	%bx
	movb	$0x0e, %ah
	xorw	%bx, %bx
	incw	%bx		/* movw $0x01, %bx */
	int	$0x10
	popw	%bx
d231 1
d234 11
a244 42
	/* .data */

/* vector to the routine to read a particular filesystem block for us */
load_fsblock:
	.word	load_chs


/* This next block is used for the EDD command packet used to read /boot
 * sectors.
 *
 * lba_count is set up for us by installboot.  It is the number of sectors
 * in a filesystem block.  (Max value 127.)
 *
 * XXX The EDD limit of 127 sectors in one read means that we currently
 *     restrict filesystem blocks to 127 sectors, or < 64 KB.  That is
 *     effectively a 32 KB block limit, as filesystem block sizes are
 *     powers of two.  The default filesystem block size is 16 KB.
 *
 *     I say we run with this limitation and see where it bites us...
 */

lba_command:
	.byte	0x10			/* size of command packet */
	.byte	0x00			/* reserved */
fs_bsize_s:
lba_count:
	.word	0			/* sectors to transfer, max 127 */
	.word	0			/* target buffer, offset */
lba_seg:
	.word	0			/* target buffer, segment */
lba_sector:
	.long	0, 0			/* sector number */

load_msg:
	.asciz	"!Loading"
err_txt_crlf:
	.ascii	"\r\n"
err_txt:
	.ascii	"ERR "
err_id:
	.ascii	"?"
crlf:	.asciz	"\r\n"
@


1.1.1.6
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.37 2004/02/10 00:35:16 tom Exp $	*/
d575 2
a576 2
	sti				/* Ensure Ctl-Alt-Del will work */
	hlt				/* (don't require power cycle) */
@


