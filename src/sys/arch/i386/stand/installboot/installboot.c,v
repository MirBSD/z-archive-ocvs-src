head	1.32;
access;
symbols
	tg-mergetmp-mirosx-1:1.32
	tg-mergefixes-1-branch:1.32.0.8
	tg-mergefixes-1-base:1.32
	MIROS_X:1.32.0.6
	MIROS_X_BASE:1.32
	tg-mergetmp-3:1.32
	MIRBSD_XP_MIRPPC:1.32.0.4
	MIRBSD_XP_SPARC_BASE:1.32
	MIRBSD_XP_SPARC:1.32.0.2
	MIRBSD_7quater:1.23
	cvs-200405160640:1.1.1.8
	cvs-200401271800:1.1.1.7
	cvs-200401261630:1.1.1.6
	cvs-200401021645:1.1.1.5
	MIRBSD_7_ALPHA:1.23.0.6
	MIRBSD_7:1.23.0.4
	cvs-200312222040:1.1.1.5
	cvs-200312171912:1.1.1.5
	MIRBSD_7ter:1.23
	MIRBSD_7_DEV:1.23.0.2
	cvs-200310020700:1.1.1.5
	cvs-200309271030:1.1.1.5
	cvs-200309261655:1.1.1.5
	cvs-200309251530:1.1.1.5
	cvs-200309192030:1.1.1.5
	cvs-200309181930:1.1.1.5
	cvs-200309131952:1.1.1.5
	cvs-200308302005:1.1.1.5
	cvs-200308221505:1.1.1.4
	cvs-200308171200:1.1.1.4
	ctm-3496:1.1.1.3
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	cvs-200307072125:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200307021520:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.19
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	ctm-3255:1.1.1.2
	ctm-3229:1.1.1.2
	MIRBSD_4:1.2
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2004.08.02.17.56.41;	author tg;	state Stab;
branches;
next	1.31;

1.31
date	2004.01.27.17.42.22;	author tg;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.05.21.50.08;	author tg;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.04.18.55.04;	author tg;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.03.18.29.51;	author tg;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.03.01.10.08;	author tg;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.02.23.44.14;	author tg;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.02.23.42.13;	author tg;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.17.16.49.55;	author tg;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.31.20.54.51;	author tg;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.17.18.56.20;	author tg;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.16.12.25.56;	author tg;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.16.12.24.29;	author tg;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.07.12.49.21;	author tg;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.05.21.33.51;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.05.20.30.39;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.05.20.19.26;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.05.20.11.27;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.05.19.42.19;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.05.19.40.21;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.05.19.30.23;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.05.19.07.42;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.05.19.07.13;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.05.18.46.10;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.05.18.45.38;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.05.18.25.33;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.24.08.06.14;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.21.19.00.37;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.03.17.12.33;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.03.14.09.14;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.52.17;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.49.37;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.49.37;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.24.09.05.38;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.11.18.34.20;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.17.14.28.48;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.08.30.23.10.19;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.01.26.18.39.41;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.01.27.19.08.44;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.16.08.43.01;	author tg;	state Exp;
branches;
next	;


desc
@@


1.32
log
@I'm sick that every piece of code has got to have its own version
number - just use the MirOS patchlevel for the bootloader.

Also, rename /usr/mdec/pbr_ffs to ffspbr for a better tabcomplete,
now that we've got the pxeboot
@
text
@/* $MirBSD: src/sys/arch/i386/stand/installboot/installboot.c,v 1.31 2004/01/27 17:42:22 tg Exp $	*/
/* $OpenBSD: installboot.c,v 1.42 2004/01/20 23:02:26 tom Exp $	*/
/* $NetBSD: installboot.c,v 1.5 1995/11/17 23:23:50 gwr Exp $ */

/* Copyright (c) 2003, 2004
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publically perform, modi-
 * fy, merge, distribute, sell, give away or sublicence, provided the
 * above copyright notices, these terms and the disclaimer are retai-
 * ned in all redistributions, or reproduced in accompanying documen-
 * tation or other materials provided with binary redistributions.
 *
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of covered work, even if advised of the possibility of such damage.
 */

/*
 * Copyright (c) 1997 Michael Shalayeff
 * Copyright (c) 1994 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mount.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <sys/ioctl.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>
#include <sys/reboot.h>
#include <sys/errno.h>

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>

#include <machine/cpu.h>
#include <machine/biosvar.h>

#include <err.h>
#include <a.out.h>
#include <sys/exec_elf.h>
#include <fcntl.h>
#include <nlist.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

extern	char *__progname;
int	verbose, nowrite, nheads, nsectors, userspec = 0;
char	*boot, *proto, *dev, *realdev;
struct nlist nl[] = {
#define X_BLOCK_COUNT	0
	{{"_blkcnt"}},
#define X_BLOCK_TABLE	1
	{{"_blktbl"}},
#define	X_NUM_SECS	2
	{{"_bpbspt"}},
#define	X_NUM_HEADS	3
	{{"_bpbtpc"}},
	{{NULL}}
};

u_int8_t *block_count_p;	/* block count var. in prototype image */
u_int8_t *block_table_p;	/* block number array in prototype image */
u_int8_t *num_heads_p;		/* number of tracks per cylinder */
u_int8_t *num_secs_p;		/* number of sectors per track */
int	maxblocklen;		/* size of this array */
int	curblocklen = 0;	/* actually used up bytes */
int	force_mbr = 0;		/* install into MBR */

int biosdev;

char		*loadprotoblocks(char *, long *);
int		loadblocknums(char *, int, struct disklabel *);
static void	devread(int, void *, daddr_t, size_t, char *);
static void	usage(void);
static int	record_block(u_int8_t *, daddr_t, u_int, struct disklabel *);

static const char RCSId[]="$MirBSD: src/sys/arch/i386/stand/installboot/installboot.c,v 1.31 2004/01/27 17:42:22 tg Exp $";

static int record_block(u_int8_t *bt, daddr_t blk, u_int bs,
	struct disklabel *dl);
static int do_record(u_int8_t *bt, daddr_t blk, u_int bs,
	struct disklabel *dl);


static void
usage(void)
{
	fprintf(stderr, "usage: %s [-n] [-v] [-s sec-per-track] "
	    "[-h track-per-cyl] boot ffspbr device\n", __progname);
	exit(1);
}

int
read_pt(int f, long offs, struct dos_mbr *target, size_t secsize)
{
#ifdef	DEBUG
	fprintf(stderr, "debug: read_pt at %d (0x%X)\n", offs, offs);
#endif
	if (lseek(f, (off_t)offs * secsize, SEEK_SET) < 0)
		return -1;
	if (read(f, target, secsize) < secsize)
		return -1;
	return 0;
}

int
scan_pt(struct dos_partition *dp, u_int8_t what)
{
	int part;

	for (part = 0; part < NDOSPART; ++part) {
		if ((!get_le(&dp[part].dp_size)) || (dp[part].dp_typ != what))
			continue;
		fprintf(stderr, "# found partition %d: "
		    "type %02X ofs %d (0x%Xh) size %d (0x%X)%s\n",
		    part, dp[part].dp_typ,
		    get_le(&dp[part].dp_start), get_le(&dp[part].dp_start),
		    get_le(&dp[part].dp_size), get_le(&dp[part].dp_size),
		    ( ((what == DOSPTYP_EXTENDL) || (what == DOSPTYP_EXTENDLX)
		       || (what == DOSPTYP_EXTEND)) ? ", chaining..." : "."));
		return part;
	}
	return NDOSPART;
}

int
main(int argc, char *argv[])
{
	int	c;
	int	devfd;
	char	*protostore;
	long	protosize;
	struct stat sb;
	struct disklabel dl;
	struct dos_mbr mbr;
	struct dos_partition *dp;
	off_t startoff = 0;
	int mib[4];
	size_t size;
	dev_t devno;
	bios_diskinfo_t di;
	long mbrofs;
	int mbrpart;

	fprintf(stderr, "MirOS BSD installboot " __BOOT_VER "\n");

	nsectors = nheads = -1;
	while ((c = getopt(argc, argv, "Mvnh:s:")) != -1) {
		switch (c) {
		case 'M':
#if 0
			++force_mbr;
#else
			fprintf(stderr, "error: -M not supported yet!\n");
#endif
			break;
		case 'h':
			nheads = atoi(optarg);
			if (nheads < 1 || nheads > 256) {
				warnx("invalid value for -h");
				nheads = -1;
			} else	userspec = 1;
			break;
		case 's':
			nsectors = atoi(optarg);
			if (nsectors < 1 || nsectors > 63) {
				warnx("invalid value for -s");
				nsectors = -1;
			} else	userspec = 1;
			break;
		case 'n':
			/* Do not actually write the bootblock to disk */
			nowrite = 1;
			break;
		case 'v':
			/* Chat */
			verbose = 1;
			break;
		default:
			usage();
		}
	}

	if (argc - optind < 3) {
		usage();
	}

	boot = argv[optind];
	proto = argv[optind + 1];
	realdev = dev = argv[optind + 2];

	/* Open and check raw disk device */
	if ((devfd = opendev(dev, (nowrite? O_RDONLY:O_RDWR),
			     OPENDEV_PART, &realdev)) < 0)
		err(1, "open: %s", realdev);

	if (verbose) {
		fprintf(stderr, "boot: %s\n", boot);
		fprintf(stderr, "proto: %s\n", proto);
		fprintf(stderr, "device: %s\n", realdev);
	}

	if (ioctl(devfd, DIOCGDINFO, &dl) != 0)
		err(1, "disklabel: %s", realdev);

	/* check disklabel */
	if (dl.d_magic != DISKMAGIC)
		err(1, "bad disklabel magic=%0x8x", dl.d_magic);

	/* warn on unknown disklabel types */
	if (dl.d_type == 0)
		warnx("disklabel type unknown");

	/* Load proto blocks into core */
	if ((protostore = loadprotoblocks(proto, &protosize)) == NULL)
		exit(1);

	/* XXX - Paranoia: Make sure size is aligned! */
	if (protosize & (DEV_BSIZE - 1))
		err(1, "proto %s bad size=%ld", proto, protosize);

	/* Write patched proto bootblocks into the superblock */
	if (protosize > SBSIZE - DEV_BSIZE)
		errx(1, "proto bootblocks too big");

	if (fstat(devfd, &sb) < 0)
		err(1, "stat: %s", realdev);

	if (!S_ISCHR(sb.st_mode))
		errx(1, "%s: Not a character device", realdev);

	if (nheads == -1 || nsectors == -1) {
		mib[0] = CTL_MACHDEP;
		mib[1] = CPU_CHR2BLK;
		mib[2] = sb.st_rdev;
		size = sizeof(devno);
		if(sysctl(mib, 3, &devno, &size, NULL, 0) >= 0) {
			devno = MAKEBOOTDEV(major(devno), 0, 0,
			    DISKUNIT(devno), RAW_PART);
			mib[0] = CTL_MACHDEP;
			mib[1] = CPU_BIOS;
			mib[2] = BIOS_DISKINFO;
			mib[3] = devno;
			size = sizeof(di);
			if(sysctl(mib, 4, &di, &size, NULL, 0) >= 0) {
				nheads = di.bios_heads;
				nsectors = di.bios_sectors;
			}
		}
	}

	if (nheads == -1 || nsectors == -1)
		fprintf(stderr, "warning: Unable to get BIOS geometry, must/should specify -h and -s\nwarning: the drive may not boot in non-LBA mode");

	/* Extract and load block numbers */
	if (loadblocknums(boot, devfd, &dl) != 0)
		exit(1);

	/* Sync filesystems (to clean in-memory superblock?) */
	sync(); sleep(1);

	if (dl.d_type != 0 && dl.d_type != DTYPE_FLOPPY &&
	    dl.d_type != DTYPE_VND && !force_mbr) {
		mbrofs = DOSBBSECTOR;
loop:		if (read_pt(devfd, mbrofs, &mbr, dl.d_secsize))
			err(4, "can't read partition table");

		if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
			errx(1, "broken MBR");

		dp = mbr.dmbr_parts;
		for (mbrpart = 0; mbrpart < NDOSPART; ++mbrpart)
			set_le(&dp[mbrpart].dp_start,
			    get_le(&dp[mbrpart].dp_start) + mbrofs);

		if ((mbrpart = scan_pt(dp, DOSPTYP_MIRBSD)) < NDOSPART)
			goto found;
		if ((mbrpart = scan_pt(dp, DOSPTYP_OPENBSD)) < NDOSPART)
			goto found;
		if ((mbrpart = scan_pt(dp, DOSPTYP_NETBSD)) < NDOSPART) {
			warnx("using NetBSD partition!");
			goto found;
		}
		if ((mbrpart = scan_pt(dp, DOSPTYP_FREEBSD)) < NDOSPART) {
			warnx("using FreeBSD partition!");
			goto found;
		}

		/* no native partition found, try extended ones */
		if ((mbrpart = scan_pt(dp, DOSPTYP_EXTEND)) == NDOSPART)
		    if ((mbrpart = scan_pt(dp, DOSPTYP_EXTENDL)) == NDOSPART)
		    if ((mbrpart = scan_pt(dp, DOSPTYP_EXTENDLX)) == NDOSPART)
			errx(1, "no BSD partition");

		/* found extended partition, loop back */
		mbrofs = get_le(&dp[mbrpart].dp_start);
		goto loop;

found:		startoff = (off_t)get_le(&dp[mbrpart].dp_start);
	}

	fprintf(stderr, "writing bootblock to sector %ld (0x%lX)\n",
	    (long) startoff, (unsigned long)startoff);
	startoff *= dl.d_secsize;

	*num_heads_p = nheads;
	*num_secs_p = nsectors;

	if (!nowrite) {
		if (lseek(devfd, startoff, SEEK_SET) < 0 ||
		    write(devfd, protostore, protosize) != protosize)
			err(1, "write bootstrap");
	}

	(void)close(devfd);

	return 0;
}

char *
loadprotoblocks(char *fname, long *size)
{
	int	fd;
	size_t	tdsize;		/* text+data size */
	char	*bp;
	struct	nlist *nlp;
	Elf_Ehdr eh;
	Elf_Word phsize;
	Elf_Phdr *ph;

	fd = -1;
	bp = NULL;

	/* Locate block number array in proto file */
	if (nlist(fname, nl) != 0) {
		warnx("nlist: %s: symbols not found", fname);
		return NULL;
	}
	/* Validate symbol types (global data). */
	for (nlp = nl; nlp->n_un.n_name; nlp++) {
		if (nlp->n_type != (N_TEXT)) {
			warnx("nlist: %s: wrong type %x", nlp->n_un.n_name,
			nlp->n_type);
			return NULL;
		}
	}

	if ((fd = open(fname, O_RDONLY)) < 0) {
		warn("open: %s", fname);
		return NULL;
	}
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh)) {
		warn("read: %s", fname);
		goto bad;
	}
	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
	}

	/*
	 * We have to include the exec header in the beginning of
	 * the buffer, and leave extra space at the end in case
	 * the actual write to disk wants to skip the header.
	 */

	/* program load header */
	if (eh.e_phnum != 1) {
		errx(1, "%s: only supports one ELF load section", boot);
	}
	phsize = eh.e_phnum * sizeof(Elf_Phdr);
	ph = malloc(phsize);
	if (ph == NULL) {
		errx(1, "%s: unable to allocate program header space",
		    boot);
	}
	lseek(fd, eh.e_phoff, SEEK_SET);

	if (read(fd, ph, phsize) != phsize) {
		errx(1, "%s: unable to read program header space", boot);
	}

	tdsize = ph->p_filesz;

	/*
	 * Allocate extra space here because the caller may copy
	 * the boot block starting at the end of the exec header.
	 * This prevents reading beyond the end of the buffer.
	 */
	if ((bp = calloc(tdsize, 1)) == NULL) {
		warnx("malloc: %s: no memory", fname);
		goto bad;
	}
	/* Read the rest of the file. */
	lseek(fd, ph->p_offset, SEEK_SET);
	if (read(fd, bp, tdsize) != tdsize) {
		warn("read: %s", fname);
		goto bad;
	}

	*size = tdsize;	/* not aligned to DEV_BSIZE */

	/* Calculate the symbols' locations within the proto file */
	block_count_p = (u_int8_t *) (bp + nl[X_BLOCK_COUNT].n_value);
	block_table_p = (u_int8_t *) (bp + nl[X_BLOCK_TABLE].n_value);
	num_heads_p = (u_int8_t *) (bp + nl[X_NUM_HEADS].n_value);
	num_secs_p = (u_int8_t *) (bp + nl[X_NUM_SECS].n_value);
	maxblocklen = *block_count_p;
	if (force_mbr) maxblocklen -= 64;

	if (verbose) {
		fprintf(stderr, "%s: entry point %#x\n", fname, eh.e_entry);
		fprintf(stderr, "proto bootblock size %ld\n", *size);
		fprintf(stderr,
		    "room for average %d filesystem blocks (%d bytes) at %#lx\n",
		    (int)(((double)maxblocklen)/4.5), maxblocklen,
		    nl[X_BLOCK_TABLE].n_value);
	}

	close(fd);
	return bp;

 bad:
	if (bp)
		free(bp);
	if (fd >= 0)
		close(fd);
	return NULL;
}

static void
devread(int fd, void *buf, daddr_t blk, size_t size, char *msg)
{
	if (lseek(fd, dbtob((off_t)blk), SEEK_SET) != dbtob((off_t)blk))
		err(1, "%s: devread: lseek", msg);

	if (read(fd, buf, size) != size)
		err(1, "%s: devread: read", msg);
}

static char sblock[SBSIZE];

int
loadblocknums(char *boot, int devfd, struct disklabel *dl)
{
	int		i, fd;
	struct stat	statbuf, sb;
	struct statfs	statfsbuf;
	struct partition *pl;
	struct fs	*fs;
	char		*buf;
	daddr_t		blk, *ap;
	struct ufs1_dinode	*ip;
	int		ndb;
	u_int8_t	*bt;
	int mib[4];
	size_t		size;
	dev_t dev;

	/*
	 * Open 2nd-level boot program and record the block numbers
	 * it occupies on the filesystem represented by 'devfd'.
	 */

	/* Make sure the (probably new) boot file is on disk. */
	sync(); sleep(1);

	if ((fd = open(boot, O_RDONLY)) < 0)
		err(1, "open: %s", boot);

	if (fstatfs(fd, &statfsbuf) != 0)
		err(1, "statfs: %s", boot);

	if (strncmp(statfsbuf.f_fstypename, "ffs", MFSNAMELEN) &&
	    strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN) ) {
		errx(1, "%s: must be on an FFS filesystem", boot);
	}

#if 0
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh)) {
		errx(1, "read: %s", boot);
	}

	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
	}
#endif

	if (fsync(fd) != 0)
		err(1, "fsync: %s", boot);

	if (fstat(fd, &statbuf) != 0)
		err(1, "fstat: %s", boot);

	if (fstat(devfd, &sb) != 0)
		err(1, "fstat: %s", realdev);

	/* check devices */
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CHR2BLK;
	mib[2] = sb.st_rdev;
	size = sizeof(dev);
	if (sysctl(mib, 3, &dev, &size, NULL, 0) >= 0)
		if (statbuf.st_dev / MAXPARTITIONS != dev / MAXPARTITIONS)
			errx(1, "cross-device install");

	pl = &dl->d_partitions[DISKPART(statbuf.st_dev)];
	close(fd);

	/* Read superblock */
	devread(devfd, sblock, pl->p_offset + SBLOCK, SBSIZE, "superblock");
	fs = (struct fs *)sblock;

	/* Sanity-check super-block. */
	if (fs->fs_magic != FS_MAGIC)
		errx(1, "Bad magic number in superblock");
	if (fs->fs_inopb <= 0)
		err(1, "Bad inopb=%d in superblock", fs->fs_inopb);

	/* Read inode */
	if ((buf = malloc(fs->fs_bsize)) == NULL)
		errx(1, "No memory for filesystem block");

	blk = fsbtodb(fs, ino_to_fsba(fs, statbuf.st_ino));
	devread(devfd, buf, pl->p_offset + blk, fs->fs_bsize, "inode");
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);

	/*
	 * Have the inode.  Figure out how many blocks we need.
	 */
	ndb = howmany(ip->di_size, fs->fs_bsize);
	if (ndb <= 0)
		errx(1, "No blocks to load");
	if (verbose)
		fprintf(stderr, "Will load %d blocks of size %d each.\n",
			ndb, fs->fs_bsize);

	if ((dl->d_type != 0 && dl->d_type != DTYPE_FLOPPY &&
	    dl->d_type != DTYPE_VND) || userspec ) {
		/* adjust disklabel w/ synthetic geometry */
		dl->d_nsectors = nsectors;
		dl->d_secpercyl = dl->d_nsectors * nheads;
	}

	if (verbose)
		fprintf(stderr, "Using disk geometry of %u sectors and %u heads.\n",
			dl->d_nsectors, dl->d_secpercyl/dl->d_nsectors);

	/*
	 * Get the block numbers; we don't handle fragments
	 */
	ap = ip->di_db;
	bt = block_table_p;
	for (i = 0; i < NDADDR && *ap && ndb; i++, ap++, ndb--)
		bt += record_block(bt, pl->p_offset + fsbtodb(fs, *ap),
					    fs->fs_bsize / 512, dl);
	if (ndb != 0) {

		/*
		 * Just one level of indirections; there isn't much room
		 * for more in the 2nd-level /boot anyway.
		 */
		blk = fsbtodb(fs, ip->di_ib[0]);
		devread(devfd, buf, pl->p_offset + blk, fs->fs_bsize,
			"indirect block");
		ap = (daddr_t *)buf;
		for (; i < NINDIR(fs) && *ap && ndb; i++, ap++, ndb--)
			bt += record_block(bt, pl->p_offset + fsbtodb(fs, *ap),
					   fs->fs_bsize / 512, dl);
	}

	bt += record_block(bt, 0, 0, dl);

	if (bt > (block_table_p + maxblocklen))
		errx(1, "Too many blocks");

	if (verbose)
		fprintf(stderr, "%s: %d entries total (%d bytes)\n",
			boot, block_count_p[0], curblocklen);

	return 0;
}

static int
record_block(u_int8_t *bt, daddr_t blk, u_int bs, struct disklabel *dl)
{
	static u_int W_num = 0;
	static daddr_t W_ofs = 0;

	int flush = 0, cache = 0, retval = 0;
	int i;

	if (!blk) {
		++flush;
	} else if (!W_ofs) {
		++cache;
	} else if (blk == (W_ofs+W_num)) {
		++cache;
	} else {
		++flush;
		++cache;
	}

	if (flush) {
		/*
		 * Flush the blocks cached to the disc.
		 * Obey the track boundaries if possible.
		 */
		if (!W_num) goto flush_end;
		if ((nheads == -1) || (nsectors == -1)) {
			retval += do_record(bt+retval, W_ofs, W_num, dl);
			goto flush_end;
		}

		i = W_ofs % nsectors;		/* sector within track -1 */
		if (i < (nsectors-1)) {
			i = nsectors - i;
			if (i > W_num) i=W_num;
			retval += do_record(bt+retval, W_ofs, i, dl);
			W_ofs += i;
			W_num -= i;
		}

		while (W_num > nsectors) {
			retval += do_record(bt+retval, W_ofs, nsectors, dl);
			W_ofs += nsectors;
			W_num -= nsectors;
		}

		if (W_num)
			retval += do_record(bt+retval, W_ofs, W_num, dl);

	flush_end:
		W_ofs=0; W_num=0;
	}

	if (cache) {
		if (!W_ofs) W_ofs = blk;
		W_num += bs;
	}

	return (retval);
}

static int
do_record(u_int8_t *bt, daddr_t blk, u_int bs, struct disklabel *dl)
{
	static u_int i = 0;
	u_int8_t tv, len;
	u_int64_t bk, wbk;
	u_int j;
	int wbs, retval = 0;
	u_int8_t *wbt;

	if ((!blk) || (!bt))
		return 0;

	if (bs > 768)	/* after that there's VGA memory */
		errx(1, "Too many blocks in a chunk!");

	wbs = bs;
	wbt = bt;
	bk = blk;
	if (verbose)
		fprintf(stderr, "%2d: %2d @@%lld (0x%08llX)\n",
		    i, bs, bk, bk);

	do {
		++i;

		if (bk < 0x0000000000000100ULL)
			len = 0;
		else if (bk < 0x0000000000010000ULL)
			len = 1;
		else if (bk < 0x0000000001000000ULL)
			len = 2;
		else if (bk < 0x0000000100000000ULL)
			len = 3;
		else if (bk < 0x0000010000000000ULL)
			len = 4;
		else if (bk < 0x0001000000000000ULL)
			len = 5;
		else if (bk < 0x0100000000000000ULL)
			len = 6;
		else	len = 7;

		if (wbs < 33)
			tv = (len << 5) | (wbs - 1);
		  else	tv = (len << 5) | 31;

		*(wbt++) = tv;
		wbk = bk;
		bk += 1 + (tv & 31);
		for (j = 0; j <= len; ++j) {
			*(wbt++) = (wbk & 0xFF);
			wbk >>= 8;
		}

		wbs -= 32;
		retval += (len+2);
	} while (wbs > 0);

	*block_count_p = i;
	curblocklen += retval;
	return (retval);
}
@


1.31
log
@first part of mergeing OpenBSD and fixing whitespace and RCS IDs
@
text
@d1 3
a3 3
/*	$MirBSD: installboot.c,v 1.30 2004/01/05 21:50:08 tg Exp $	*/
/*	$OpenBSD: installboot.c,v 1.42 2004/01/20 23:02:26 tom Exp $	*/
/*	$NetBSD: installboot.c,v 1.5 1995/11/17 23:23:50 gwr Exp $ */
d6 1
a6 1
 *	Thorsten Glaser <x86@@ePost.de> for the MirOS Project
d8 6
a13 6
 * Subject to these terms, everybody who obtained a copy of this work
 * is hereby permitted to deal in the work without restriction inclu-
 * ding without limitation the rights to use, distribute, sell, modi-
 * fy, publically perform, give away, merge or sublicence it provided
 * this notice is kept and the authors and contributors are given due
 * credit in derivates or accompanying documents.
d15 7
a21 5
 * This work is provided "as is" with no explicit or implicit warran-
 * ties whatsoever to the maximum extent permitted by applicable law;
 * in no event may an author or contributor be held liable for damage
 * that is, directly or indirectly, caused by the work, even if advi-
 * sed of the possibility of such damage.
d116 1
a116 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.30 2004/01/05 21:50:08 tg Exp $";
d128 1
a128 1
	    "[-h track-per-cyl] boot pbr_ffs device\n", __progname);
@


1.30
log
@revert change - code to install pbr into mbr isn't ready yet
(this cost me 3 hours today to fix jannis' router w/o net)...
and usage() isn't fixed either
@
text
@d1 2
a2 2
/*	$MirBSD: installboot.c,v 1.29 2004/01/04 18:55:04 tg Exp $	*/
/*	$OpenBSD: installboot.c,v 1.41 2003/08/25 23:27:43 tedu Exp $	*/
d114 1
a114 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.29 2004/01/04 18:55:04 tg Exp $";
d196 4
a199 1
			userspec = 1;
d203 4
a206 1
			userspec = 1;
@


1.29
log
@allow to install pbr_ffs into the MBR, not overwriting the
64 bytes partition table
XXX someone fixup the man page (sort options etc.)
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.28 2004/01/03 18:29:51 tg Exp $	*/
d114 1
a114 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.28 2004/01/03 18:29:51 tg Exp $";
d188 1
d190 3
@


1.28
log
@it appears to work, moving out the partition with the disklabel
into an extended partition.

snippets from dmesg, fdisk and disklabel:

MirBSD#7u96 3.4-20040103 (GENERIC) #330: Sat Jan  3 18:04:27 UTC 2004
	tg@@odem.66h.42h.de:/usr/src/sys/arch/i386/compile/GENERIC
[...]
Searching for raid components...
debug: found partition 0: type 0F ofs 1 (0x1h) size 1 (0x1), chaining...
debug: found partition 3: type 27 ofs 15200640 (0xE7F180h) size 23869440 (0x16C3800).
warning: broken MBR signature
warning: broken MBR signature
dkcsum: wd0 matched BIOS disk 80



Disk: wd0	geometry: 38760/16/63 [39070080 Sectors]
Offset: 0	Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 0F    0   0  2 -    0   0  2 [           1:           1 ] Extended LBA
 1: DB  510   0  1 - 15079  15 63 [      514080:    14686560 ] CPM/C.DOS/C*
 2: 06    0   0  3 -  509  15 63 [           2:      514078 ] DOS > 32MB
*3: DB 15080   0  1 - 38759  15 63 [    15200640:    23869440 ] CPM/C.DOS/C*
Offset: 1	Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 1: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
*3: 27 15080   0  1 - 38759  15 63 [    15200640:    23869440 ] MirBSD



# found partition 0: type 0F ofs 1 (0x1h) size 1 (0x1), chaining...
# found partition 3: type 27 ofs 15200640 (0xE7F180h) size 23869440 (0x16C3800).
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: IC25N020ATCS04-0
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 39070080
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0		# microseconds
track-to-track seek: 0	# microseconds
drivedata: 0

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a: 17053344 22016736    4.2BSD     2048 16384   328 	# (Cyl. 21842 - 38759)
  b:   524160 15200640      swap                      	# (Cyl. 15080 - 15599)
  c: 39070080        0    unused        0     0       	# (Cyl.    0 - 38759)
  d:  6291936 15724800    4.2BSD     2048 16384   328 	# (Cyl. 15600 - 21841)
  e: 14686560   514080    4.2BSD     2048 16384   328 	# (Cyl.  510 - 15079)
  m:   514078        2     MSDOS                      	# (Cyl.    0*- 509)
  p:        2        0   unknown                      	# (Cyl.    0 - 0*)
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.27 2004/01/03 01:10:08 tg Exp $	*/
d104 1
d114 1
a114 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.27 2004/01/03 01:10:08 tg Exp $";
d185 1
a185 1
	while ((c = getopt(argc, argv, "vnh:s:")) != -1) {
d187 3
d290 1
a290 1
	    dl.d_type != DTYPE_VND) {
d438 1
@


1.27
log
@match other changes
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.26 2004/01/02 23:44:14 tg Exp $	*/
d5 17
a22 2
 * Copyright (c) 2003, 2004
 *	Thorsten Glaser <x86@@ePost.de> for the MirOS Project
d113 1
a113 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.26 2004/01/02 23:44:14 tg Exp $";
d124 2
a125 2
	fprintf(stderr, "usage: %s [-n] [-v] [-s sec-per-track] [-h track-per-cyl] "
	    "boot pbr_ffs device\n", __progname);
d130 1
a130 1
read_pt(int f, long offs, struct dos_mbr *target, size_t howmuch)
d132 4
a135 1
	if (lseek(f, (off_t)offs, SEEK_SET) < 0)
d137 1
a137 1
	if (read(f, target, howmuch) < howmuch)
d288 2
a289 2
loop:		if (read_pt(devfd, mbrofs, &mbr, sizeof(mbr)))
			err(4, "can't read master boot record");
d316 1
a316 1
			errx(1, "no MirBSD or OpenBSD partition");
d319 1
a319 1
		mbrofs = dp[mbrpart].dp_start;
d322 1
a322 1
found:		startoff = (off_t)dp[mbrpart].dp_start * dl.d_secsize;
d324 4
a327 2
	fprintf(stderr, "writing bootblock to absolute sector %d (0x%X)\n",
	    startoff, startoff);
@


1.26
log
@prefer NetBSD over FreeBSD one, mirrors libsa and fbsd has only 8 entries
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.25 2004/01/02 23:42:13 tg Exp $	*/
d98 1
a98 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.25 2004/01/02 23:42:13 tg Exp $";
d277 4
d306 2
@


1.25
log
@also here: check for all four BSD types and all three types
of extended partitions
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.24 2003/11/17 16:49:55 tg Exp $	*/
d98 1
a98 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.24 2003/11/17 16:49:55 tg Exp $";
d281 4
a286 4
			goto found;
		}
		if ((mbrpart = scan_pt(dp, DOSPTYP_NETBSD)) < NDOSPART) {
			warnx("using NetBSD partition!");
@


1.24
log
@I knew I would break it.
Have installboot know its version, while here.
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.23 2003/08/31 20:54:51 tg Exp $	*/
d6 2
a7 1
 * Copyright (c) 2003 Thorsten Glaser
d98 1
a98 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.23 2003/08/31 20:54:51 tg Exp $";
d115 30
d160 2
d269 2
a270 2
		if (lseek(devfd, (off_t)DOSBBSECTOR, SEEK_SET) < 0 ||
		    read(devfd, &mbr, sizeof(mbr)) < sizeof(mbr))
d276 8
a283 11
		/* Find MirBSD partition. */
		for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART]; dp++) {
			if (dp->dp_size && dp->dp_typ == DOSPTYP_MIRBSD) {
				startoff = (off_t)dp->dp_start * dl.d_secsize;
				fprintf(stderr, "using MBR partition %ld: "
					"type %d (0x%02x) offset %d (0x%x)\n",
					(long)(dp - mbr.dmbr_parts),
					dp->dp_typ, dp->dp_typ,
					dp->dp_start, dp->dp_start);
				break;
			}
d285 3
a287 12
		/* Find OpenBSD partition. */
		if (dp >= &mbr.dmbr_parts[NDOSPART])
		for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART]; dp++) {
			if (dp->dp_size && dp->dp_typ == DOSPTYP_OPENBSD) {
				startoff = (off_t)dp->dp_start * dl.d_secsize;
				fprintf(stderr, "using MBR partition %ld: "
					"type %d (0x%02x) offset %d (0x%x)\n",
					(long)(dp - mbr.dmbr_parts),
					dp->dp_typ, dp->dp_typ,
					dp->dp_start, dp->dp_start);
				break;
			}
d289 5
a293 2
		/* don't check for old part number, that is ;-p */
		if (dp >= &mbr.dmbr_parts[NDOSPART])
d295 6
@


1.23
log
@Merge import of OpenBSD source, ports and XF4 tree.

While here,
o clean up differences where possible
o whitespace cleanup
o ifdef ./. if defined()
o '...' ./. "..."
o echo foo > bar ./. echo foo >bar
o `...` ./. $(...) ./. $$(...)
o `...' ./. '...'
o modernize "our" tree, e.g. WWW in ports
o fix some typos and brainos introduced when renaming OpenBSD to MirBSD
o use hardware 80387 by default
o migrate Apache 1.3.28 OpenBSD ./. MirBSD ./. KAME
o work around as many CVS bugs as possible (add back/delete files, ...)

Synchronize stuff, ready for ongoing changes.
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.22 2003/08/17 18:56:20 tg Exp $	*/
d97 1
a97 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.22 2003/08/17 18:56:20 tg Exp $";
d129 2
@


1.22
log
@merge OpenBSD, remove a few 0x60
@
text
@d1 2
a2 2
/*	$MirBSD: installboot.c,v 1.21 2003/08/16 12:25:56 tg Exp $	*/
/*	$OpenBSD: installboot.c,v 1.40 2003/08/15 21:17:27 deraadt Exp $	*/
d6 1
d97 1
a97 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.21 2003/08/16 12:25:56 tg Exp $";
d419 1
a419 1
	struct dinode	*ip;
d495 1
a495 1
	ip = (struct dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);
@


1.21
log
@KNF, ANSIfy in the MirBSD-specific part, too
@
text
@d1 2
a2 2
/*	$MirBSD: installboot.c,v 1.20 2003/08/16 12:24:29 tg Exp $	*/
/*	$OpenBSD: installboot.c,v 1.39 2003/08/08 07:37:28 deraadt Exp $	*/
d24 1
a24 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
d96 1
a96 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.20 2003/08/16 12:24:29 tg Exp $";
d335 1
a335 1
		errx(1, "%s: only supports one ELF load section\n", boot);
d340 1
a340 1
		errx(1, "%s: unable to allocate program header space\n",
d343 1
a343 1
	lseek(fd,  eh.e_phoff, SEEK_SET);
d346 1
a346 1
		errx(1, "%s: unable to read program header space\n", boot);
d427 1
a427 1
	 * it occupies on the filesystem represented by `devfd'.
@


1.20
log
@Merge OpenBSD
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.19 2003/06/07 12:49:21 tg Exp $	*/
d96 1
a96 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.19 2003/06/07 12:49:21 tg Exp $";
d614 1
a614 5
do_record(bt, blk, bs, dl)
	u_int8_t *bt;
	daddr_t blk;
	u_int bs;
	struct disklabel *dl;
@


1.19
log
@support the MirBSD MBR partition type &h27 as well
as the OpenBSD MBR partition type 0xA6
@
text
@d1 2
a2 2
/*	$MirBSD: installboot.c,v 1.18 2003/06/05 21:33:51 tg Exp $	*/
/*	$OpenBSD: installboot.c,v 1.38 2003/04/17 03:43:18 drahn Exp $	*/
d96 1
a96 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.18 2003/06/05 21:33:51 tg Exp $";
d105 1
a105 1
usage()
d113 1
a113 3
main(argc, argv)
	int argc;
	char *argv[];
d285 1
a285 3
loadprotoblocks(fname, size)
	char *fname;
	long *size;
d326 1
d397 1
a397 6
devread(fd, buf, blk, size, msg)
	int	fd;
	void	*buf;
	daddr_t	blk;
	size_t	size;
	char	*msg;
d409 1
a409 4
loadblocknums(boot, devfd, dl)
	char	*boot;
	int	devfd;
	struct disklabel *dl;
d553 1
a553 5
record_block(bt, blk, bs, dl)
	u_int8_t *bt;
	daddr_t blk;
	u_int bs;
	struct disklabel *dl;
@


1.18
log
@various improvements found out "the hard way"
in single user mode
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.17 2003/06/05 20:30:39 tg Exp $	*/
d96 1
a96 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.17 2003/06/05 20:30:39 tg Exp $";
d242 12
d255 1
d269 1
a269 1
			errx(1, "no OpenBSD partition");
@


1.17
log
@fix thinko (swapping values)
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.16 2003/06/05 20:19:26 tg Exp $	*/
d96 1
a96 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.16 2003/06/05 20:19:26 tg Exp $";
d624 1
a624 1
	u_int64_t bk;
d627 1
d636 1
d665 3
a667 1
		*bt = tv;
d669 2
a670 2
			*(bt + j + 1) = (bk & 0xFF);
			bk >>= 8;
@


1.16
log
@(hopefully) fix off-by-one
adjust max. /boot size to 384K (as this is REALly a limit)
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.15 2003/06/05 20:11:27 tg Exp $	*/
d74 1
a74 1
#define	X_NUM_HEADS	2
d76 1
a76 1
#define	X_NUM_SECS	3
d96 1
a96 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.15 2003/06/05 20:11:27 tg Exp $";
@


1.15
log
@EXPERIMENTAL: allow for splitting the LBA blocks
on track boundaries. Good especially for floppies
and old boxen.
Splitting is not done if heads/secs are not specified.
Splitting can make problems on very large drives with
a very large second stage boot loader, due to the size
of the table.
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.14 2003/06/05 19:42:19 tg Exp $	*/
d96 1
a96 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.14 2003/06/05 19:42:19 tg Exp $";
d585 2
a586 2
		i = 1 + (W_ofs % nsectors);	/* sector within track */
		if (i != nsectors) {
d631 1
a631 1
	if (bs > 512)	/* 256K max size for /boot */
@


1.14
log
@kill relict from the past, where installboot
was to choose between CHS and LBA
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.13 2003/06/05 19:40:21 tg Exp $	*/
d96 7
a102 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.13 2003/06/05 19:40:21 tg Exp $";
d538 2
d552 65
@


1.13
log
@don't confuse logical AND with bitwise AND
man 7 operator
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.12 2003/06/05 19:30:23 tg Exp $	*/
d96 1
a96 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.12 2003/06/05 19:30:23 tg Exp $";
d564 1
a564 1
		fprintf(stderr, "%2d: %2d @@%lld (0x%08llX) LBA\n",
@


1.12
log
@hmpf, how the fuck is PBR supposed to translate
from LBA to CHS when I don't tell it how many
heads and sectors it has?
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.11 2003/06/05 19:07:42 tg Exp $	*/
d96 1
a96 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.11 2003/06/05 19:07:42 tg Exp $";
d592 1
a592 1
			*(bt + j + 1) = (bk && 0xFF);
@


1.11
log
@fix compiler warning
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.10 2003/06/05 19:07:13 tg Exp $	*/
d96 1
a96 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.10 2003/06/05 19:07:13 tg Exp $";
d252 3
@


1.10
log
@fix displaying values
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.9 2003/06/05 18:46:10 tg Exp $	*/
d96 1
a96 1
static const char RCSId[]="$MirBSD: installboot.c,v 1.9 2003/06/05 18:46:10 tg Exp $";
d362 1
a362 1
		    (((double)maxblocklen)/4.5), maxblocklen,
@


1.9
log
@add RCS Id
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.8 2003/06/05 18:45:38 tg Exp $	*/
d86 1
d96 1
a96 1
static const char RCSId[]="$MirBSD$";
d360 4
a363 2
		fprintf(stderr, "room for average %d filesystem blocks at %#lx\n",
			maxblocklen/4, nl[X_BLOCK_TABLE].n_value);
d534 1
a534 1
			boot, block_count_p[0], (int)(bt - block_table_p));
d598 1
@


1.8
log
@fix warnings and comments
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.7 2003/06/05 18:25:33 tg Exp $	*/
d94 2
@


1.7
log
@implement the new boot sector code from scratch,
which can boot from LBA and CHS by converting between
LBA and CHS at run-time (idea from Toby Weingartner),
and adjust installboot accordingly.
Work done by me.
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.4 2003/05/03 17:12:33 tg Exp $	*/
d529 1
a529 1
			boot, bt, *block_count_p);
d556 1
a556 1
		fprintf(stderr, "%2d: %2d @@%d (0x%08X) LBA\n",
@


1.6
log
@back out previous installboot change until pbr_ffs
gets written.
Temporarily back add last mirbsd/openbsd biosboot,
so we can at least build the tree (hopefully).
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.3 2003/05/03 14:09:14 tg Exp $	*/
d71 1
a71 1
	{{"_block_count"}},
d73 5
a77 3
	{{"_block_table"}},
#define X_LBA_FLAG	2
	{{"_lba_flag"}},
d83 3
a85 1
int	maxblocknum;		/* size of this array */
a87 2
int use_lba = 0;
u_int8_t *lba_flag_p;
d98 2
a99 2
	fprintf(stderr, "usage: %s [-n] [-l] [-v] [-s sec-per-track] [-h track-per-cyl] "
	    "boot biosboot device\n", __progname);
d123 1
a123 1
	while ((c = getopt(argc, argv, "lvnh:s:")) != -1) {
a124 3
		case 'l':
			use_lba = 1;
			break;
d214 2
a215 2
	if (((nheads == -1) || (nsectors == -1)) && (use_lba == 0))
		errx(1, "Unable to get BIOS geometry, must specify -h and -s");
d350 3
a352 6
	lba_flag_p = (u_int8_t *) (bp + nl[X_LBA_FLAG].n_value);
	maxblocknum = *block_count_p;

	/* Patch the LBA flag if necessary */
	if (use_lba != 0)
		*lba_flag_p = 0x4C;
d357 2
a358 3
		fprintf(stderr, "room for %d filesystem blocks at %#lx\n",
			maxblocknum, nl[X_BLOCK_TABLE].n_value);
		fprintf(stderr, "LBA flag set to %c\n", *lba_flag_p);
d497 1
a497 1
	if (verbose && !use_lba)
d506 1
a506 1
	for (i = 0; i < NDADDR && *ap && ndb; i++, ap++, ndb--) {
a508 3
		if ((bt - block_table_p) / 4 > maxblocknum)
			errx(1, "Too many blocks");
	}
d519 1
a519 1
		for (; i < NINDIR(fs) && *ap && ndb; i++, ap++, ndb--) {
a521 3
			if ((bt - block_table_p) / 4 > maxblocknum)
				errx(1, "Too many blocks");
		}
d524 1
a524 6
	/* write out remaining piece */
	bt += record_block(bt, 0, 0, dl);
	/* and again */
	bt += record_block(bt, 0, 0, dl);
	*block_count_p = (bt - block_table_p) / 4;
	if (*block_count_p > maxblocknum)
d528 2
a529 2
		fprintf(stderr, "%s: %d entries total\n",
			boot, *block_count_p);
d541 5
a545 53
	static u_int ss = 0, l = 0, i = 0; /* start and len of group */
	int ret = 0;

    if (!use_lba) {

	/* printf("%u, %u\n", blk, bs); */
	if (ss == 0) { /* very beginning */
		ss = blk;
		l = bs;
		return 0;
	} else if (l == 0)
		return 0;

	/* record on track boundary or non-contig blocks or last call */
	if ((ss + l) != blk ||
	    (ss % dl->d_nsectors + l) >= dl->d_nsectors) {
		register u_int c = ss / dl->d_secpercyl,
			s = ss % dl->d_nsectors + 1;

		/* nsectors */
		if ((ss % dl->d_nsectors + l) >= dl->d_nsectors)
			bt[4] = dl->d_nsectors - s + 1;
		else
			bt[4] = l; /* non-contig or last block piece */

		bt[2] = (ss % dl->d_secpercyl) / dl->d_nsectors; /* head */
		*(u_int16_t *)bt = (s & 0x3f) | /* sect, cyl */
			((c & 0xff) << 8) | ((c & 0x300) >> 2);

		if (verbose)
			fprintf(stderr, "%2d: %2d @@(%d %d %d) (%d-%d)\n",
				i, bt[4], c, bt[2], s, ss, ss + bt[4] - 1);
		i++;

		ss += bt[4];
		l -= bt[4];
		if ((ss + l) != blk) {
			/* printf ("l=%u\n", l); */
		 	if (l)
				ret += record_block(bt + 5, 0, 0, dl);
			ss = blk;
			l = bs;
		} else
			l += bs;

		ret += 5;
	} else {
		l += bs;
	}

	return ret;

  } else { /* use_lba */
d550 2
a551 2
	*((u_int32_t *)bt) = blk;
	bt[4] = bs;
d553 2
d557 30
a586 1
		    i, bt[4], *((u_int32_t *)bt), *((u_int32_t *)bt));
d588 3
a590 2
	++i;
	return 5;
d592 2
a593 1
  }
@


1.5
log
@first attempt at newish boot loader code
yes i know it breaks the tree, but what does not *sigh*
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.4 2003/05/03 17:12:33 tg Exp $	*/
d74 2
a75 4
#define	X_NUM_HEADS	2
	{{"_num_heads"}},
#define	X_NUM_SECS	3
	{{"_num_secs"}},
d81 1
a81 3
u_int8_t *num_heads_p;		/* number of tracks per cylinder */
u_int8_t *num_secs_p;		/* number of sectors per track */
int	maxblocklen;		/* size of this array */
d84 2
d96 1
a96 1
	fprintf(stderr, "usage: %s [-n] [-v] [-s sec-per-track] [-h track-per-cyl] "
d121 1
a121 1
	while ((c = getopt(argc, argv, "vnh:s:")) != -1) {
d123 3
d215 2
a216 2
	if (nheads == -1 || nsectors == -1)
		fprintf(stderr, "warning: Unable to get BIOS geometry, must/should specify -h and -s");
d351 6
a356 3
	num_heads_p = (u_int8_t *) (bp + nl[X_NUM_HEADS].n_value);
	num_secs_p = (u_int8_t *) (bp + nl[X_NUM_SECS].n_value);
	maxblocklen = *block_count_p;
d361 3
a363 2
		fprintf(stderr, "room for average %d filesystem blocks at %#lx\n",
			maxblocklen/4, nl[X_BLOCK_TABLE].n_value);
d502 1
a502 1
	if (verbose)
d511 1
a511 1
	for (i = 0; i < NDADDR && *ap && ndb; i++, ap++, ndb--)
d514 3
d527 1
a527 1
		for (; i < NINDIR(fs) && *ap && ndb; i++, ap++, ndb--)
d530 3
d535 6
a540 1
	if (bt > (block_table_p + maxblocklen))
d544 2
a545 2
		fprintf(stderr, "%s: %d entries total (%d bytes)\n",
			boot, bt, *block_count_p);
d557 53
a609 4
	static u_int i = 0;
	u_int8_t tv, len;
	u_int64_t bk;
	u_int j;
d614 2
a615 2
	if (bs > 32)
		errx(1, "Too many blocks in a chunk!");
a616 1
	bk = blk;
d619 2
a620 1
		    i, bs, bk, bk);
d622 1
d624 1
a624 26
	if (bk < 0x0000000000000100ULL)
		len = 0;
	else if (bk < 0x0000000000010000ULL)
		len = 1;
	else if (bk < 0x0000000001000000ULL)
		len = 2;
	else if (bk < 0x0000000100000000ULL)
		len = 3;
	else if (bk < 0x0000010000000000ULL)
		len = 4;
	else if (bk < 0x0001000000000000ULL)
		len = 5;
	else if (bk < 0x0100000000000000ULL)
		len = 6;
	else	len = 7;

	tv = (len << 5) | (bs - 1);

	*bt = tv;
	for (j = 0; j <= len; ++j) {
		*(bt + j + 1) = (bk && 0xFF);
		bk >>= 8;
	}

	*block_count_p = i;
	return (len+2);
@


1.4
log
@Implement LBA booting support
@
text
@d1 1
a1 1
/*	$MirBSD: installboot.c,v 1.3 2003/05/03 14:09:14 tg Exp $	*/
d74 4
a77 2
#define X_LBA_FLAG	2
	{{"_lba_flag"}},
d83 3
a85 1
int	maxblocknum;		/* size of this array */
a87 2
int use_lba = 0;
u_int8_t *lba_flag_p;
d98 1
a98 1
	fprintf(stderr, "usage: %s [-n] [-l] [-v] [-s sec-per-track] [-h track-per-cyl] "
d123 1
a123 1
	while ((c = getopt(argc, argv, "lvnh:s:")) != -1) {
a124 3
		case 'l':
			use_lba = 1;
			break;
d214 2
a215 2
	if (((nheads == -1) || (nsectors == -1)) && (use_lba == 0))
		errx(1, "Unable to get BIOS geometry, must specify -h and -s");
d350 3
a352 6
	lba_flag_p = (u_int8_t *) (bp + nl[X_LBA_FLAG].n_value);
	maxblocknum = *block_count_p;

	/* Patch the LBA flag if necessary */
	if (use_lba != 0)
		*lba_flag_p = 0x4C;
d357 2
a358 3
		fprintf(stderr, "room for %d filesystem blocks at %#lx\n",
			maxblocknum, nl[X_BLOCK_TABLE].n_value);
		fprintf(stderr, "LBA flag set to %c\n", *lba_flag_p);
d497 1
a497 1
	if (verbose && !use_lba)
d506 1
a506 1
	for (i = 0; i < NDADDR && *ap && ndb; i++, ap++, ndb--) {
a508 3
		if ((bt - block_table_p) / 4 > maxblocknum)
			errx(1, "Too many blocks");
	}
d519 1
a519 1
		for (; i < NINDIR(fs) && *ap && ndb; i++, ap++, ndb--) {
a521 3
			if ((bt - block_table_p) / 4 > maxblocknum)
				errx(1, "Too many blocks");
		}
d524 1
a524 6
	/* write out remaining piece */
	bt += record_block(bt, 0, 0, dl);
	/* and again */
	bt += record_block(bt, 0, 0, dl);
	*block_count_p = (bt - block_table_p) / 4;
	if (*block_count_p > maxblocknum)
d528 2
a529 2
		fprintf(stderr, "%s: %d entries total\n",
			boot, *block_count_p);
d541 4
a544 53
	static u_int ss = 0, l = 0, i = 0; /* start and len of group */
	int ret = 0;

    if (!use_lba) {

	/* printf("%u, %u\n", blk, bs); */
	if (ss == 0) { /* very beginning */
		ss = blk;
		l = bs;
		return 0;
	} else if (l == 0)
		return 0;

	/* record on track boundary or non-contig blocks or last call */
	if ((ss + l) != blk ||
	    (ss % dl->d_nsectors + l) >= dl->d_nsectors) {
		register u_int c = ss / dl->d_secpercyl,
			s = ss % dl->d_nsectors + 1;

		/* nsectors */
		if ((ss % dl->d_nsectors + l) >= dl->d_nsectors)
			bt[4] = dl->d_nsectors - s + 1;
		else
			bt[4] = l; /* non-contig or last block piece */

		bt[2] = (ss % dl->d_secpercyl) / dl->d_nsectors; /* head */
		*(u_int16_t *)bt = (s & 0x3f) | /* sect, cyl */
			((c & 0xff) << 8) | ((c & 0x300) >> 2);

		if (verbose)
			fprintf(stderr, "%2d: %2d @@(%d %d %d) (%d-%d)\n",
				i, bt[4], c, bt[2], s, ss, ss + bt[4] - 1);
		i++;

		ss += bt[4];
		l -= bt[4];
		if ((ss + l) != blk) {
			/* printf ("l=%u\n", l); */
		 	if (l)
				ret += record_block(bt + 5, 0, 0, dl);
			ss = blk;
			l = bs;
		} else
			l += bs;

		ret += 5;
	} else {
		l += bs;
	}

	return ret;

  } else { /* use_lba */
d549 2
a550 2
	*((u_int32_t *)bt) = blk;
	bt[4] = bs;
d552 1
d555 2
a556 1
		    i, bt[4], *((u_int32_t *)bt), *((u_int32_t *)bt));
d558 23
a580 2
	++i;
	return 5;
d582 2
a583 1
  }
@


1.3
log
@extend block table from 4 to 5 bytes each entry
implement LBA support (stubbed out)
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
d85 1
a217 3
	if (use_lba != 0)
		errx(ENOCOFFEE, "LBA support not implemented yet!");

d351 1
d354 4
d363 1
d502 1
a502 1
	if (verbose)
d560 2
d608 17
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 2
a2 1
/*	$OpenBSD: installboot.c,v 1.37 2002/05/03 13:59:08 espie Exp $	*/
d47 1
d74 2
d84 1
d95 1
a95 1
	fprintf(stderr, "usage: %s [-n] [-v] [-s sec-per-track] [-h track-per-cyl] "
d120 1
a120 1
	while ((c = getopt(argc, argv, "vnh:s:")) != -1) {
d122 3
d214 1
a214 1
	if (nheads == -1 || nsectors == -1)
d217 3
a405 3
#if 0
	Elf_Ehdr	eh;
#endif
d572 1
a572 1
			bt[3] = dl->d_nsectors - s + 1;
d574 1
a574 1
			bt[3] = l; /* non-contig or last block piece */
d582 1
a582 1
				i, bt[3], c, bt[2], s, ss, ss + bt[3] - 1);
d585 2
a586 2
		ss += bt[3];
		l -= bt[3];
d590 1
a590 1
				ret += record_block(bt + 4, 0, 0, dl);
d596 1
a596 1
		ret += 4;
@


1.1
log
@Initial revision
@
text
@d55 1
d174 1
a174 1
		err(1, "proto bootblock bad size=%ld", protosize);
d262 3
a264 1
	struct	exec eh;
d276 3
a278 2
		if (nlp->n_type != (N_TEXT | N_EXT)) {
			warnx("nlist: %s: wrong type", nlp->n_un.n_name);
d291 5
a295 3
	if (N_GETMAGIC(eh) != OMAGIC) {
		warn("bad magic: 0x%x", eh.a_midmag);
		goto bad;
d302 18
a319 1
	tdsize = eh.a_text + eh.a_data;
d331 1
d345 1
a345 1
		fprintf(stderr, "%s: entry point %#x\n", fname, eh.a_entry);
d395 3
a397 1
	struct exec	eh;
d421 1
d426 5
a430 2
	if (N_GETMAGIC(eh) != ZMAGIC) {
		errx(1, "%s: bad magic: 0x%x", boot, eh.a_midmag);
d432 1
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import some parts of OpenBSD-current (after their ELF switch) to ease future merging and reduce diffs against their codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.38 2003/04/17 03:43:18 drahn Exp $	*/
a54 1
#include <sys/exec_elf.h>
d173 1
a173 1
		err(1, "proto %s bad size=%ld", proto, protosize);
d261 1
a261 3
	Elf_Ehdr eh;
	Elf_Word phsize;
	Elf_Phdr *ph;
d273 2
a274 3
		if (nlp->n_type != (N_TEXT)) {
			warnx("nlist: %s: wrong type %x", nlp->n_un.n_name,
			nlp->n_type);
d287 3
a289 5
	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
d296 1
a296 18

	/* program load header */
	if (eh.e_phnum != 1) {
		errx(1, "%s: only supports one ELF load section\n", boot);
	}
	phsize = eh.e_phnum * sizeof(Elf_Phdr);
	ph = malloc(phsize);
	if (ph == NULL) {
		errx(1, "%s: unable to allocate program header space\n",
		    boot);
	}
	lseek(fd,  eh.e_phoff, SEEK_SET);

	if (read(fd, ph, phsize) != phsize) {
		errx(1, "%s: unable to read program header space\n", boot);
	}

	tdsize = ph->p_filesz;
a307 1
	lseek(fd, ph->p_offset, SEEK_SET);
d321 1
a321 1
		fprintf(stderr, "%s: entry point %#x\n", fname, eh.e_entry);
d371 1
a394 1
#if 0
d399 2
a400 5
	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
a401 1
#endif
@


1.1.1.3
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.39 2003/08/08 07:37:28 deraadt Exp $	*/
d88 1
a88 1
usage(void)
d96 3
a98 1
main(int argc, char *argv[])
d254 3
a256 1
loadprotoblocks(char *fname, long *size)
a296 1

d363 6
a368 1
devread(int fd, void *buf, daddr_t blk, size_t size, char *msg)
d380 4
a383 1
loadblocknums(char *boot, int devfd, struct disklabel *dl)
d536 5
a540 1
record_block(u_int8_t *bt, daddr_t blk, u_int bs, struct disklabel *dl)
@


1.1.1.4
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.40 2003/08/15 21:17:27 deraadt Exp $	*/
d302 1
a302 1
		errx(1, "%s: only supports one ELF load section", boot);
d307 1
a307 1
		errx(1, "%s: unable to allocate program header space",
d310 1
a310 1
	lseek(fd, eh.e_phoff, SEEK_SET);
d313 1
a313 1
		errx(1, "%s: unable to read program header space", boot);
@


1.1.1.5
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.41 2003/08/25 23:27:43 tedu Exp $	*/
d381 1
a381 1
	struct ufs1_dinode	*ip;
d457 1
a457 1
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);
@


1.1.1.6
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.42 2004/01/20 23:02:26 tom Exp $	*/
a116 2
			if (nheads < 1 || nheads > 256)
				errx(1, "invalid value for -h");
a120 2
			if (nsectors < 1 || nsectors > 63)
				errx(1, "invalid value for -s");
@


1.1.1.7
log
@using: ========= cvsim-base-obsd _MirBSD: cvsim-src-openbsd,v 1.3 2004/01/27 17:17:54 tg Exp $ =========

In contrast to what people might believe now,
I am not "specially" attracted by CVS Imports
(neither am I a version number hunter).
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.43 2004/01/26 23:21:49 tom Exp $	*/
a4 1
 * Copyright (c) 2003 Tom Cosgrove <tom.cosgrove@@arches-consulting.com>
a63 7
struct	sym_data {
	char		*sym_name;		/* Must be initialised */
	int		sym_size;		/* And this one */
	int		sym_set;		/* Rest set at runtime */
	u_int32_t	sym_value;
};

d65 1
a65 1
int	verbose, nowrite = 0;
d67 6
a72 9
struct sym_data pbr_symbols[] = {
	{"_fs_bsize_p",	2},
	{"_fs_bsize_s",	2},
	{"_fsbtodb",	1},
	{"_p_offset",	4},
	{"_inodeblk",	4},
	{"_inodedbl",	4},
	{"_nblocks",	2},
	{NULL}
d75 3
a77 2
#define INODESEG	0x07e0	/* where we will put /boot's inode's block */
#define BOOTSEG		0x07c0	/* biosboot loaded here */
d79 1
a79 1
#define INODEOFF  ((INODESEG-BOOTSEG) << 4)
d81 2
a82 2
static char	*loadproto(char *, long *);
static int	getbootparams(char *, int, struct disklabel *);
a83 2
static void	sym_set_value(struct sym_data *, char *, u_int32_t);
static void	pbr_set_symbols(char *, char *, struct sym_data *);
d85 1
d90 2
a91 1
	fprintf(stderr, "usage: %s [-nv] boot biosboot device\n", __progname);
a94 5
/*
 * Read information about /boot's inode and filesystem parameters, then
 * put biosboot (partition boot record) on the target drive with these
 * parameters patched in.
 */
d102 9
a110 5
	struct	stat sb;
	struct	disklabel dl;
	struct	dos_mbr mbr;
	struct	dos_partition *dp;
	off_t	startoff = 0;
d112 2
a113 1
	while ((c = getopt(argc, argv, "vn")) != -1) {
d115 12
d128 1
a128 1
			/* Do not actually write the bootblock to disk. */
d132 1
a132 1
			/* Give more information. */
d140 1
a140 1
	if (argc - optind < 3)
d142 1
d148 1
a148 1
	/* Open and check raw disk device. */
d150 1
a150 1
	    OPENDEV_PART, &realdev)) < 0)
d162 1
a162 1
	/* Check disklabel. */
d166 1
a166 1
	/* Warn on unknown disklabel types. */
d170 2
a171 2
	/* Load proto blocks into core. */
	if ((protostore = loadproto(proto, &protosize)) == NULL)
d178 1
a178 1
	/* Write patched proto bootblock(s) into the superblock. */
d186 24
a209 1
		errx(1, "%s: not a character device", realdev);
d211 2
a212 2
	/* Get bootstrap parameters that are to be patched into proto. */
	if (getbootparams(boot, devfd, &dl) != 0)
d215 2
a216 7
	/* Patch the parameters into the proto bootstrap sector. */
	pbr_set_symbols(proto, protostore, pbr_symbols);

	if (!nowrite) {
		/* Sync filesystems (to clean in-memory superblock?). */
		sync(); sleep(1);
	}
d228 1
a228 2
		for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART];
		    dp++) {
d232 4
a235 4
				    "type %d (0x%02x) offset %d (0x%x)\n",
				    (long)(dp - mbr.dmbr_parts),
				    dp->dp_typ, dp->dp_typ,
				    dp->dp_start, dp->dp_start);
d239 1
a239 1
		/* Don't check for old part number, that is ;-p */
d255 2
a256 5
/*
 * Load the prototype boot sector (biosboot) into memory.
 */
static char *
loadproto(char *fname, long *size)
d261 1
d266 2
a267 2
	if ((fd = open(fname, O_RDONLY)) < 0)
		err(1, "%s", fname);
d269 13
a281 2
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh))
		errx(1, "%s: read failed", fname);
d283 9
a291 1
	if (!IS_ELF(eh))
d293 4
a296 3
		    boot,
		    eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		    eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
d304 4
a307 5
	/* Program load header. */
	if (eh.e_phnum != 1)
		errx(1, "%s: %u ELF load sections (only support 1)",
		    boot, eh.e_phnum);

d310 4
a313 3
	if (ph == NULL)
		err(1, NULL);

d316 3
a318 2
	if (read(fd, ph, phsize) != phsize)
		errx(1, "%s: can't read header", boot);
d328 2
a329 1
		err(1, NULL);
a330 1

d334 2
a335 1
		errx(1, "%s: read failed", fname);
d340 5
d348 2
d354 7
d375 2
a376 6
/*
 * Read information about /boot's inode, then put this and filesystem
 * parameters from the superblock into pbr_symbols.
 */
static int
getbootparams(char *boot, int devfd, struct disklabel *dl)
d378 1
a378 1
	int		fd;
d387 2
a388 1
	int		mib[4];
d390 1
a390 1
	dev_t		dev;
d393 2
a394 5
	 * Open 2nd-level boot program and record enough details about
	 * where it is on the filesystem represented by `devfd'
	 * (inode block, offset within that block, and various filesystem
	 * parameters essentially taken from the superblock) for biosboot
	 * to be able to load it later.
d407 3
a409 2
	    strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN) )
		errx(1, "%s: not on an FFS filesystem", boot);
d412 1
a412 1
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh))
d414 1
d418 3
a420 3
		    boot,
		    eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		    eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
d433 1
a433 1
	/* Check devices. */
d438 1
a438 1
	if (sysctl(mib, 3, &dev, &size, NULL, 0) >= 0) {
a440 1
	}
d445 1
a445 1
	/* Read superblock. */
d455 1
a455 1
	/* Read inode. */
d457 1
a457 1
		err(1, NULL);
a459 1

d464 1
a464 2
	 * Have the inode.  Figure out how many filesystem blocks (not disk
	 * sectors) there are for biosboot to load.
d470 13
a482 2
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, ndb, fs->fs_bsize);
d485 1
a485 2
	 * Now set the values that will need to go into biosboot
	 * (the partition boot record, a.k.a. the PBR).
a486 6
	sym_set_value(pbr_symbols, "_fs_bsize_p", (fs->fs_bsize / 16));
	sym_set_value(pbr_symbols, "_fs_bsize_s", (fs->fs_bsize / 512));
	sym_set_value(pbr_symbols, "_fsbtodb", fs->fs_fsbtodb);
	sym_set_value(pbr_symbols, "_p_offset", pl->p_offset);
	sym_set_value(pbr_symbols, "_inodeblk",
	    ino_to_fsba(fs, statbuf.st_ino));
d488 23
a510 15
	sym_set_value(pbr_symbols, "_inodedbl",
	    ((((char *)ap) - buf) + INODEOFF));
	sym_set_value(pbr_symbols, "_nblocks", ndb);

	return 0;
}

static void
sym_set_value(struct sym_data *sym_list, char *sym, u_int32_t value)
{
	struct sym_data *p;

	for (p = sym_list; p->sym_name != NULL; p++) {
		if (strcmp(p->sym_name, sym) == 0)
			break;
d513 7
a519 2
	if (p->sym_name == NULL)
		errx(1, "%s: no such symbol", sym);
d521 3
a523 2
	if (p->sym_set)
		errx(1, "%s already set", p->sym_name);
d525 1
a525 2
	p->sym_value = value;
	p->sym_set = 1;
d528 2
a529 6
/*
 * Write the parameters stored in sym_list into the in-memory copy of
 * the prototype biosboot (proto), ready for it to be written to disk.
 */
static void
pbr_set_symbols(char *fname, char *proto, struct sym_data *sym_list)
d531 2
a532 53
	struct sym_data *sym;
	struct nlist	*nl;
	char		*vp;
	u_int32_t	*lp;
	u_int16_t	*wp;
	u_int8_t	*bp;

	for (sym = sym_list; sym->sym_name != NULL; sym++) {
		if (!sym->sym_set)
			errx(1, "%s not set", sym->sym_name);

		/* Allocate space for 2; second is null-terminator for list. */
		nl = calloc(2, sizeof(struct nlist));
		if (nl == NULL)
			err(1, NULL);

		nl->n_un.n_name = sym->sym_name;

		if (nlist(fname, nl) != 0)
			errx(1, "%s: symbol %s not found",
			    fname, sym->sym_name);

		if (nl->n_type != (N_TEXT))
			errx(1, "%s: %s: wrong type (%x)",
			    fname, sym->sym_name, nl->n_type);

		/* Get a pointer to where the symbol's value needs to go. */
		vp = proto + nl->n_value;

		switch (sym->sym_size) {
		case 4:					/* u_int32_t */
			lp = (u_int32_t *) vp;
			*lp = sym->sym_value;
			break;
		case 2:					/* u_int16_t */
			if (sym->sym_value >= 0x10000)	/* out of range */
				errx(1, "%s: symbol out of range (%u)",
				    sym->sym_name, sym->sym_value);
			wp = (u_int16_t *) vp;
			*wp = (u_int16_t) sym->sym_value;
			break;
		case 1:					/* u_int16_t */
			if (sym->sym_value >= 0x100)	/* out of range */
				errx(1, "%s: symbol out of range (%u)",
				    sym->sym_name, sym->sym_value);
			bp = (u_int8_t *) vp;
			*bp = (u_int8_t) sym->sym_value;
			break;
		default:
			errx(1, "%s: bad symbol size %d",
			    sym->sym_name, sym->sym_size);
			/* NOTREACHED */
		}
d534 23
a556 1
		free(nl);
d559 18
a576 2
			fprintf(stderr, "%s = %u\n",
			    sym->sym_name, sym->sym_value);
d578 2
@


1.1.1.8
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.46 2004/05/05 04:33:56 mickey Exp $	*/
d173 1
a173 1
		errx(1, "proto %s bad size=%ld", proto, protosize);
d422 3
a440 10
	if (verbose) {
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, ndb, fs->fs_bsize);
		fprintf(stderr, "fs block shift %u; part offset %u; "
		    "inode block %u, offset %u\n",
		    fs->fs_fsbtodb, pl->p_offset,
		    ino_to_fsba(fs, statbuf.st_ino),
		    ((((char *)ap) - buf) + INODEOFF));
	}

d526 4
@


