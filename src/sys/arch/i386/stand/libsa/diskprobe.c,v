head	1.25;
access;
symbols
	tg-mergetmp-mirosx-1:1.25
	tg-mergefixes-1-branch:1.25.0.4
	tg-mergefixes-1-base:1.25
	MIROS_X:1.25.0.2
	MIROS_X_BASE:1.25
	tg-mergetmp-3:1.25
	MIRBSD_XP_MIRPPC:1.24.0.4
	MIRBSD_XP_SPARC_BASE:1.24
	MIRBSD_XP_SPARC:1.24.0.2
	MIRBSD_7quater:1.12
	cvs-200405160640:1.1.1.6
	cvs-200401271800:1.1.1.5
	cvs-200401261630:1.1.1.5
	cvs-200401021645:1.1.1.5
	MIRBSD_7_ALPHA:1.12.0.6
	MIRBSD_7:1.12.0.4
	cvs-200312222040:1.1.1.5
	cvs-200312171912:1.1.1.5
	MIRBSD_7ter:1.12
	MIRBSD_7_DEV:1.12.0.2
	cvs-200310020700:1.1.1.4
	cvs-200309271030:1.1.1.4
	cvs-200309261655:1.1.1.4
	cvs-200309251530:1.1.1.4
	cvs-200309192030:1.1.1.4
	cvs-200309181930:1.1.1.3
	cvs-200309131952:1.1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308221505:1.1.1.3
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.3
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	cvs-200307072125:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200307021520:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.6
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	MIRBSD_4:1.2
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2004.12.05.13.25.36;	author tg;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.23.20.15.43;	author tg;	state Stab;
branches;
next	1.23;

1.23
date	2003.12.26.21.59.38;	author tg;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.21.19.13.19;	author tg;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.17.20.42.35;	author tg;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.17.12.49.19;	author tg;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.14.21.12.12;	author tg;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.14.20.49.44;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.14.19.28.17;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.09.12.54.28;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.31.22.05.37;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.31.21.20.18;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.31.21.07.55;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.20.04.27.56;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.20.02.52.31;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.19.21.57.06;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.19.20.44.04;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.16.15.25.42;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.06.20.22.28;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.05.20.35.33;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.21.18.14.53;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.03.18.32.35;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.24.11.05.30;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.52.18;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.49.37;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.49.37;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.06.05.17.34.28;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.11.18.34.21;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.09.19.20.36.49;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.17.19.13.38;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.16.08.42.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.25
log
@* replace all occurences of old eMail addresses of mine
  with their more recent counterparts
* no $Log keyword!
* update licence template to most recent version in files touched
* in some places, don't add our own licence boilerplate, just
  add my name to the others
* make dev/rndvar.h suitable for inclusion in asm code
* include dev/rndvar.h by in_cksum.s instead of
  hardcoding pool size
* ENTRY(a); ENTRY(b) -> NENTRY(a); ENTRY(b)
* RCS IDs belong into .comment not .text
@
text
@/**	$MirBSD$ */
/*	$OpenBSD: diskprobe.c,v 1.26 2004/03/19 13:48:18 tom Exp $	*/

/*
 * Copyright (c) 1997 Tobias Weingartner
 * Copyright (c) 2002, 2003
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/* We don't want the disk type names from disklabel.h */
#undef DKTYPENAMES

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>
#include <stand/boot/bootarg.h>
#include <machine/biosvar.h>
#define	_BSD_STANDXX
#include <lib/libz/zlib.h>
#include "disk.h"
#include "biosdev.h"
#include "libsa.h"

#define MAX_CKSUMLEN MAXBSIZE / DEV_BSIZE	/* Max # of blks to cksum */

extern u_int32_t tori_bootflag;

/* Local Prototypes */
static int disksum(int);

/* List of disk devices we found/probed */
struct disklist_lh disklist;

/* Pointer to boot device */
struct diskinfo *bootdev_dip;

extern int debug;

/* Probe for all BIOS floppies */
static void
floppyprobe(void)
{
	struct diskinfo *dip;
	int i;

	/* Floppies */
	for (i = 0; i < 4; i++) {
		dip = alloc(sizeof(struct diskinfo));
		memset(dip, 0, sizeof(*dip));

		if (bios_getdiskinfo(i, &dip->bios_info)) {
#ifdef BIOS_DEBUG
			if (debug)
				printf(" <!fd%u>", i);
#endif
			free(dip, 0);
			break;
		}

		printf(" fd%u", i);

		/* Fill out best we can - (fd?) */
		dip->bios_info.bsd_dev = MAKEBOOTDEV(2, 0, 0, i, RAW_PART);
		/* Defer disklabel lookup until it is needed */
		dip->bios_info.flags |= BDI_BADLABEL;

		/* Add to queue of disks */
		TAILQ_INSERT_TAIL(&disklist, dip, list);
	}
}


/* Probe for all BIOS hard disks */
static void
hardprobe(void)
{
	struct diskinfo *dip;
	int i;
	u_int bsdunit, type;
	u_int scsi = 0, ide = 0;

	/* CD-ROM */
	if (tori_bootflag) {
		printf(" cd0");
		dip = alloc(sizeof(struct diskinfo));
		memset(dip, 0, sizeof(*dip));
		dip->bios_info.bsd_dev = MAKEBOOTDEV(6, 0, 0, 0, RAW_PART);
		dip->bios_info.flags |= (BDI_INVALID | BDI_ELTORITO);
		dip->bios_info.bios_number = tori_bootflag & 0xFF;
		TAILQ_INSERT_TAIL(&disklist, dip, list);
	}

	/* Hard disks */
	for (i = 0x80; i < 0x88; i++) {
		if ((tori_bootflag) && (i == (tori_bootflag & 0xFF)))
			continue;

		dip = alloc(sizeof(struct diskinfo));
		memset(dip, 0, sizeof(*dip));

		if (bios_getdiskinfo(i, &dip->bios_info)) {
#ifdef BIOS_DEBUG
			if (debug)
				printf(" <!hd%u>", i&0x7f);
#endif
			free(dip, 0);
			break;
		}

		printf(" hd%u%s", i&0x7f, (dip->bios_info.bios_edd > 0?"+":""));

		/* Try to find the label, to figure out device type */
		if (bios_getdisklabel(&dip->bios_info, &dip->disklabel) != NULL) {
			printf("*");
			bsdunit = ide++;
			type = 0;	/* XXX let it be IDE */
		} else {
			/* Best guess */
			switch (dip->disklabel.d_type) {
			case DTYPE_SCSI:
				type = 4;
				bsdunit = scsi++;
				dip->bios_info.flags |= BDI_GOODLABEL;
				break;

			case DTYPE_ESDI:
			case DTYPE_ST506:
				type = 0;
				bsdunit = ide++;
				dip->bios_info.flags |= BDI_GOODLABEL;
				break;

			default:
				dip->bios_info.flags |= BDI_BADLABEL;
				type = 0;	/* XXX Suggest IDE */
				bsdunit = ide++;
			}
		}

		dip->bios_info.checksum = 0; /* just in case */
		/* Fill out best we can */
		dip->bios_info.bsd_dev =
		    MAKEBOOTDEV(type, 0, 0, bsdunit, RAW_PART);

		/* Add to queue of disks */
		TAILQ_INSERT_TAIL(&disklist, dip, list);
	}
}


/* Probe for all BIOS supported disks */
u_int32_t bios_cksumlen;
void
diskprobe(void)
{
	struct diskinfo *dip;
	int i;

	/* These get passed to kernel */
	bios_diskinfo_t *bios_diskinfo;

	/* Init stuff */
	TAILQ_INIT(&disklist);

	/* Do probes */
	floppyprobe();
#ifdef BIOS_DEBUG
	if (debug)
		printf(";");
#endif
	hardprobe();

	/* Checksumming of hard disks */
	for (i = 0; disksum(i++) && i < MAX_CKSUMLEN; )
		;
	bios_cksumlen = i;

	/* Get space for passing bios_diskinfo stuff to kernel */
	for (i = 0, dip = TAILQ_FIRST(&disklist); dip;
	    dip = TAILQ_NEXT(dip, list))
		i++;
	bios_diskinfo = alloc(++i * sizeof(bios_diskinfo_t));

	/* Copy out the bios_diskinfo stuff */
	for (i = 0, dip = TAILQ_FIRST(&disklist); dip;
	    dip = TAILQ_NEXT(dip, list))
		bios_diskinfo[i++] = dip->bios_info;

	bios_diskinfo[i++].bios_number = -1;
	/* Register for kernel use */
	addbootarg(BOOTARG_CKSUMLEN, sizeof(u_int32_t), &bios_cksumlen);
	addbootarg(BOOTARG_DISKINFO, i * sizeof(bios_diskinfo_t),
	    bios_diskinfo);
}


/* Find info on given BIOS disk */
struct diskinfo *
dklookup(int dev)
{
	struct diskinfo *dip;

	for(dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if((dip->bios_info.bios_number == dev) &&
		    !(dip->bios_info.flags & BDI_ELTORITO))
			return(dip);

	return NULL;
}

void
dump_diskinfo(void)
{
	struct diskinfo *dip;

	printf("Disk\tBIOS#\tType\tCyls\tHeads\tSecs\tFlags\tChecksum\n");
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
		bios_diskinfo_t *bdi = &dip->bios_info;
		int d = bdi->bios_number;

		printf("%cd%d\t0x%X\t%s\t%d\t%d\t%d\t0x%X\t0x%X\n",
		    (bdi->flags & BDI_ELTORITO) ? 'c' : ((d & 0x80)?'h':'f'),
		    (bdi->flags & BDI_ELTORITO) ?  0  : d & 0x7F, d,
			(bdi->flags & BDI_BADLABEL)?"*none*":"label",
		    bdi->bios_cylinders, bdi->bios_heads, bdi->bios_sectors,
		    bdi->flags, bdi->checksum);
	}
}

/* Find BIOS portion on given BIOS disk
 * XXX - Use dklookup() instead.
 */
bios_diskinfo_t *
bios_dklookup(int dev)
{
	struct diskinfo *dip;

	dip = dklookup(dev);
	if (dip)
		return &dip->bios_info;

	return NULL;
}

/*
 * Checksum one more block on all harddrives
 *
 * Use the adler32() function from libz,
 * as it is quick, small, and available.
 */
int
disksum(int blk)
{
	struct diskinfo *dip, *dip2;
	int st, reprobe = 0;
	char *buf;

	buf = alloca(DEV_BSIZE);
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
		bios_diskinfo_t *bdi = &dip->bios_info;

		/* Skip this disk if it is not a HD or has had an I/O error */
		if (!(bdi->bios_number & 0x80) || bdi->flags & BDI_INVALID)
			continue;

		/* Adler32 checksum */
		st = biosd_io(F_READ, bdi, blk, 1, buf);
		if (st) {
			bdi->flags |= BDI_INVALID;
			continue;
		}
		bdi->checksum = adler32(bdi->checksum, buf, DEV_BSIZE);

		for (dip2 = TAILQ_FIRST(&disklist); dip2 != dip;
				dip2 = TAILQ_NEXT(dip2, list)) {
			bios_diskinfo_t *bd = &dip2->bios_info;
			if ((bd->bios_number & 0x80) &&
			    !(bd->flags & BDI_INVALID) &&
			    bdi->checksum == bd->checksum)
				reprobe = 1;
		}
	}

	return reprobe;
}
@


1.24
log
@* first futile attempt to merge OpenBSD 3.5-current
* damn! they got pxeboot! -> disable for now
  (there's still ports/sysutils/pxegrub; we'll have pxeboot later)
* I don't know if that ... bootloader still works
* nuke netbsd emul (was unused anyways)
* nuke a plethora of syscalls not being used, and mark
  the other two (COMPAT_35) for deletion RSN
* merge new MI-GENERIC into i386 GENERIC
* resolve numeric conflicts for
  - syscalls
  - sysctls
  - device majors
  - pcidevs
* (c) cleanup - no need to add a bsd-like licence when
  there's already one; just add my name
* and much more
@
text
@d1 1
a1 1
/*	$MirBSD: src/sys/arch/i386/stand/libsa/diskprobe.c,v 1.23 2003/12/26 21:59:38 tg Exp $	*/
d6 2
a7 1
 * Copyright (c) 2002, 2003 Thorsten Glaser <x86@@ePost.de>
@


1.23
log
@adjust with recent changes; v2.65 compiles and runs fine
even on wbx@@s crappy lent notebook
@
text
@d1 2
a2 2
/*	$MirBSD: diskprobe.c,v 1.22 2003/12/21 19:13:19 tg Exp $	*/
/*	$OpenBSD: diskprobe.c,v 1.24 2003/12/16 22:53:13 deraadt Exp $	*/
d70 1
a70 1
	for(i = 0; i < 4; i++) {
d74 1
a74 1
		if(bios_getdiskinfo(i, &dip->bios_info)) {
d124 1
a124 1
		if(bios_getdiskinfo(i, &dip->bios_info)) {
d165 2
a166 1
		dip->bios_info.bsd_dev = MAKEBOOTDEV(type, 0, 0, bsdunit, RAW_PART);
a185 1
	printf("disk:");
d202 2
a203 1
	for(i = 0, dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
d208 2
a209 1
	for(i = 0, dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
d215 2
a216 3
	addbootarg(BOOTARG_DISKINFO, i * sizeof(bios_diskinfo_t), bios_diskinfo);

	printf("\n");
d231 1
a231 1
	return(NULL);
d240 1
a240 1
	for(dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)){
d262 2
a263 2
	if(dip)
		return(&dip->bios_info);
d265 1
a265 1
	return(NULL);
d282 1
a282 1
	for(dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)){
d297 2
a298 2
		for(dip2 = TAILQ_FIRST(&disklist); dip2 != dip;
				dip2 = TAILQ_NEXT(dip2, list)){
d307 1
a307 1
	return (reprobe);
@


1.22
log
@correctly display CD devices in 'machine diskinfo' output
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.21 2003/12/17 20:42:35 tg Exp $	*/
d41 1
@


1.21
log
@merge OpenBSD
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.20 2003/11/17 12:49:19 tg Exp $	*/
d243 2
a244 1
		    (d & 0x80)?'h':'f', d & 0x7F, d,
@


1.20
log
@let's just remove bzero, bcmp, bcopy and look what happens.
	bcmp	-> memcmp
	bcopy	-> memmove
	bzero	-> memset
	memcpy	-> memmove *)

*) it happens that old memcpy was implemented
   as per semantics of memmove, thats why I changed
@
text
@d1 2
a2 2
/*	$MirBSD: diskprobe.c,v 1.19 2003/11/14 21:12:12 tg Exp $	*/
/*	$OpenBSD: diskprobe.c,v 1.22 2003/09/19 05:25:12 fgsch Exp $	*/
d32 2
a33 2
/* We want the disk type names from disklabel.h */
#define DKTYPENAMES
a236 2
	(void)fstypenames, (void)fstypesnames;

d244 1
a244 2
			(bdi->flags & BDI_BADLABEL)?"*none*":
				dktypenames[B_TYPE(dip->disklabel.d_type)],
@


1.19
log
@remove silly debugging everywhere; cdboot even loads a
kernel from CD-ROM fine now (which segfaults later...)
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.18 2003/11/14 20:49:44 tg Exp $	*/
d71 1
a71 1
		bzero(dip, sizeof(*dip));
d108 1
a108 1
		bzero(dip, sizeof(*dip));
d121 1
a121 1
		bzero(dip, sizeof(*dip));
@


1.18
log
@switch to boot-new, which shares a common srt0 between CD and BIOS
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.17 2003/11/14 19:28:17 tg Exp $	*/
a67 1
printf("deb:fd\n");
@


1.17
log
@unbreak /boot a little
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.15 2003/10/31 22:05:37 tg Exp $	*/
d68 1
d112 1
a112 1
		dip->bios_info.bios_number = tori_bootflag;
d118 1
a118 1
		if (i == (tori_bootflag & 0xFF))
@


1.16
log
@Mostly... not fully...

One weekend's worth of work.

- catch up website log with changes really done till today
- add catch-up entries for wbx@@ and bsiegert@@, too
- move GNU documentation to src/gnu/doc and simplify it
- re-run autoconf on the gnu part of the tree again, to
  catch up with the GFDL-documentation removal
- provide non-GFDL-licenced as(1) and ld(1) manual pages
  XXX these are more than outdated!
- bump MirOS patchlevel
- build the system through, fixing showstoppers where
  they are encountered
- index.cgi and index.php come before index.htm,
  default.htm and index.html in httpd.conf
- speed up PHP processing
- prepare for "new" OpenBSD pkgtools (unsupported by MirBSD,
  but some MirPorts people want to play with them)
- move old weblog to CMS; update my info again
- update hRef""s in old weblogs
- move release announcements to /historic/
- copy feature list from last release announcement
  XXX need a "readible short list", or even
  XXX	a separation for the target environment
  XXX	(e.g. suits / techies / clients)
- add some recent news, so the page ain't empty
  missing:
	- about
	  + MirOS
	  + MirPorts
	- get MirOS!	(http d/l, http install, install docs)
	- relations	(to other BSD)
	  + ??? events ??? (here?)
	- history
	- older releases	(historic)
	- help pages
	  + FAQ
	  + Docs/Tuts	(hi wbx@@ here comes your place)
	    + install docs
	  + mailing lists
	- developers
	  + wbx
	  + bsiegert
	  + cnuke
	- CVSweb	(XXX need BSDadvocacy.org fix before)
	- AnonCVS	(howto; link to)
	- Links
  alternatively, change the layout? suggestions?
  why am I the only one who cares about www?
- merge development plan
- put a "project" into the miros page head
- fix cdboot Makefile
- fix gas wanting us a.out again (wut?)
  (turned out to be a must-fix in configure.in)
- stand/cdboot/NOTES merged into stand/README
- sync distrib set lists
- have TORI device (i386 libsa) always use bounce buffers
  (which, in fact, makes it succeed in loading the kernel)
  XXX kernel says it has less than 4 meg ram (degraded mode)
  XXX may be a bochs issue?
- fix random.S again
- move determining of file name / raw file flag in both
  bios/toridev.c to the end of bios/toriopen()
  => enables us to have two drivers at once
- fix disk probing for CD devices wrt BIOS driver

(eww. The tree isn't fully broken, but neither boot
 nor cdboot.bin are usable at all at the moment.
 I'll fix that ASAP.)
@
text
@a70 1
printf("detect fd=<%x> dip=<%x>\n",i,(u_int32_t)dip);
a107 1
printf("detect cd=<%x> dip=<%x>\n",0,(u_int32_t)dip);
a120 1
printf("detect hd=<%x> dip=<%x>\n",i,(u_int32_t)dip);
a214 2
printf("disklist: addr=<%x> cont=<%x>\n",(u_int32_t)(&disklist),*((u_int32_t *)(&disklist)));
dump_diskinfo();
a222 2
printf("disklist: addr=<%x> cont=<%x>\n",(u_int32_t)(&disklist),*((u_int32_t *)(&disklist)));
dump_diskinfo();
d224 1
a224 4
printf("dkllokup: dev<%x> ",dev);
	for(dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
printf("dip<%x> bsddev=<%x> bootdev=<%x> bios_info.bios_number=<%x> flags=<%x>",
(u_int32_t)dip, dip->bsddev, dip->bootdev, dip->bios_info.bios_number, dip->bios_info.flags);
d226 1
a226 2
		    !(dip->bios_info.flags & BDI_ELTORITO)) {
printf(" ja\n");
a227 3
		}
printf(" nein\n");
	}
@


1.15
log
@my stupid ego tried to set a variable's content in .bss
before the .bss region was even cleared...
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.14 2003/10/31 21:20:18 tg Exp $	*/
d71 1
d109 1
d112 2
a113 1
		dip->bios_info.flags |= BDI_INVALID;
d123 1
d218 2
d228 2
d231 7
a237 2
	for(dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if(dip->bios_info.bios_number == dev)
d239 3
@


1.14
log
@well, without the 'tori files, nothing would work anyways
and #ifdef CDBOOT in libsa isn't a good idea in general either
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.13 2003/10/31 21:07:55 tg Exp $	*/
a44 3
#ifdef	CDBOOT
#include "tori.h"
#endif
d48 1
a48 1
volatile u_int32_t tori_bootflag;
a104 1
printf("debug tori_bootflag=%x\n", tori_bootflag);
@


1.13
log
@I've come so far that it at least boots /boot (in bochs)
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.12 2003/09/20 04:27:56 tg Exp $	*/
d51 2
d107 11
d120 1
a120 3

#ifdef	CDBOOT
		if (i == T_DRV)
a121 1
#endif
a171 7
#ifdef	CDBOOT
	printf(" cd0");
	dip = alloc(sizeof(struct diskinfo));
	bzero(dip, sizeof(*dip));
	dip->bios_info.bsd_dev = MAKEBOOTDEV(6, 0, 0, 0, RAW_PART);
	TAILQ_INSERT_TAIL(&disklist, dip, list);
#endif
@


1.12
log
@now, if _that_ doesn't render a usable boot loader, it's FUBAR
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.8 2003/08/16 15:25:42 tg Exp $	*/
d45 3
d107 6
d162 7
@


1.11
log
@the last bootblock was a disaster.
everything worked - except for booting from a simple floppy.
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.10 2003/09/19 21:57:06 tg Exp $	*/
@


1.10
log
@back out some changes which failed regression:
a generated floppy or CD was not even bootable in my machine.

This is now the version MirOS BSD #7 will ship with.
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.9 2003/09/19 20:44:04 tg Exp $	*/
d6 1
a6 1
 * Copyright (c) 2002 by Thorsten Glaser <x86@@ePost.de>
d84 1
a84 1
		/* Defer disklabel lookup until it is needed -mirabile */
@


1.9
log
@sync boot code with latest OpenBSD and bump minor
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.8 2003/08/16 15:25:42 tg Exp $	*/
d18 2
a19 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
a100 1
	const char *dc = (const char *)((0x40 << 4) + 0x75);
d103 1
a103 1
	for (i = 0x80; i < (0x80 + *dc); i++) {
@


1.8
log
@Merge OpenBSD
@
text
@d1 2
a2 2
/*	$MirBSD: diskprobe.c,v 1.7 2003/07/06 20:22:28 tg Exp $	*/
/*	$OpenBSD: diskprobe.c,v 1.21 2003/08/11 06:23:09 deraadt Exp $	*/
d101 1
d104 1
a104 1
	for(i = 0x80; i < 0x88; i++) {
@


1.7
log
@mop up
@
text
@d1 2
a2 2
/*	$MirBSD: diskprobe.c,v 1.6 2003/06/05 20:35:33 tg Exp $	*/
/*	$OpenBSD: diskprobe.c,v 1.20 2003/06/04 17:04:05 deraadt Exp $	*/
d61 1
a61 1
floppyprobe()
d95 1
a95 1
hardprobe()
d159 1
a159 1
diskprobe()
d204 1
a204 2
dklookup(dev)
	int dev;
d216 1
a216 1
dump_diskinfo()
d240 1
a240 2
bios_dklookup(dev)
	register int dev;
d258 1
a258 2
disksum(blk)
	int blk;
@


1.6
log
@merge cvs import conflicts in i386-stand
so I can continue bootloader work
@
text
@d1 1
a1 1
/*	$MirBSD: diskprobe.c,v 1.5 2003/05/21 18:14:53 tg Exp $	*/
d6 1
a6 1
 * Copyright (c) 2002 by Thorsten "mirabile" Glaser <x86@@ePost.de>
@


1.5
log
@make /boot LBA capable, from Tobias Weingartner
@
text
@d1 2
a2 2
/*	$MirBSD: diskprobe.c,v 1.4 2003/05/03 18:32:35 tg Exp $	*/
/*	$OpenBSD: diskprobe.c,v 1.18 2002/03/14 01:26:34 millert Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.4
log
@prepare for booting by means of EDD
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
a269 1
	int hpc, spt, dev;
a270 1
	int cyl, head, sect;
a279 4
		dev = bdi->bios_number;
		hpc = bdi->bios_heads;
		spt = bdi->bios_sectors;

d281 1
a281 3
		btochs(blk, cyl, head, sect, hpc, spt);
		st = biosd_io(F_READ, dev, cyl, head, sect, 1, buf,
		    (bdi->bios_edd>0)?1:0);
@


1.3
log
@fix cvs import mess, merge OpenBSD-current
implement optional a.out support in /boot
@
text
@d1 1
d288 2
a289 1
		st = biosd_io(F_READ, dev, cyl, head, sect, 1, buf);
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d232 1
a232 1
		printf("%cd%d\t0x%x\t%s\t%d\t%d\t%d\t0x%x\t0x%x\n",
@


1.1
log
@Initial revision
@
text
@d5 1
d22 1
a22 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
d88 2
a89 4
		if((bios_getdisklabel(&dip->bios_info, &dip->disklabel)) != 0) 
			dip->bios_info.flags |= BDI_BADLABEL;
		else
			dip->bios_info.flags |= BDI_GOODLABEL;
d123 1
a123 1
		if((bios_getdisklabel(&dip->bios_info, &dip->disklabel)) ) {
a305 1

@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.20 2003/06/04 17:04:05 deraadt Exp $	*/
d15 5
d270 1
d272 1
d282 4
d287 2
a288 1
		st = biosd_io(F_READ, bdi, blk, 1, buf);
@


1.1.1.3
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.21 2003/08/11 06:23:09 deraadt Exp $	*/
d59 1
a59 1
floppyprobe(void)
d95 1
a95 1
hardprobe(void)
d159 1
a159 1
diskprobe(void)
d204 2
a205 1
dklookup(int dev)
d217 1
a217 1
dump_diskinfo(void)
d241 2
a242 1
bios_dklookup(int dev)
d260 2
a261 1
disksum(int blk)
@


1.1.1.4
log
@live import from NetzLaden.org: boot code from OpenBSD, again.
Rationale: test with broken BIOS (I've access to one here), and release.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.22 2003/09/19 05:25:12 fgsch Exp $	*/
a100 1
	const char *dc = (const char *)((0x40 << 4) + 0x75);
d103 1
a103 1
	for (i = 0x80; i < (0x80 + *dc); i++) {
@


1.1.1.5
log
@some OpenBSD boot code sync (so I don't have to do it later)
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.24 2003/12/16 22:53:13 deraadt Exp $	*/
d31 1
a31 1
#undef DKTYPENAMES
d82 4
a85 8

		/*
		 * Delay reading the disklabel until we're sure we want
		 * to boot from the floppy. Doing this avoids a delay
		 * (sometimes very long) when trying to read the label
		 * and the drive is unplugged.
		 */
		dip->bios_info.flags |= BDI_BADLABEL;
d221 2
d230 2
a231 1
			(bdi->flags & BDI_BADLABEL)?"*none*":"label",
@


1.1.1.6
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.26 2004/03/19 13:48:18 tom Exp $	*/
d16 2
a17 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
d65 1
a65 1
	for (i = 0; i < 4; i++) {
d69 1
a69 1
		if (bios_getdiskinfo(i, &dip->bios_info)) {
d112 1
a112 1
		if (bios_getdiskinfo(i, &dip->bios_info)) {
d124 1
a124 1
		if ((bios_getdisklabel(&dip->bios_info, &dip->disklabel)) ) {
d153 1
a153 2
		dip->bios_info.bsd_dev =
		    MAKEBOOTDEV(type, 0, 0, bsdunit, RAW_PART);
d173 1
d190 1
a190 2
	for (i = 0, dip = TAILQ_FIRST(&disklist); dip;
	    dip = TAILQ_NEXT(dip, list))
d195 1
a195 2
	for (i = 0, dip = TAILQ_FIRST(&disklist); dip;
	    dip = TAILQ_NEXT(dip, list))
d201 3
a203 2
	addbootarg(BOOTARG_DISKINFO, i * sizeof(bios_diskinfo_t),
	    bios_diskinfo);
d213 3
a215 3
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if (dip->bios_info.bios_number == dev)
			return dip;
d217 1
a217 1
	return NULL;
d226 1
a226 1
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
d232 1
a232 1
		    (bdi->flags & BDI_BADLABEL)?"*none*":"label",
d247 2
a248 2
	if (dip)
		return &dip->bios_info;
d250 1
a250 1
	return NULL;
d267 1
a267 1
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
d282 2
a283 2
		for (dip2 = TAILQ_FIRST(&disklist); dip2 != dip;
				dip2 = TAILQ_NEXT(dip2, list)) {
d292 1
a292 1
	return reprobe;
d294 1
@


