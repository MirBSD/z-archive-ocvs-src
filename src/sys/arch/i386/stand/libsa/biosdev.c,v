head	1.35;
access;
symbols
	tg-mergetmp-mirosx-1:1.35
	tg-mergefixes-1-branch:1.35.0.4
	tg-mergefixes-1-base:1.35
	MIROS_X:1.35.0.2
	MIROS_X_BASE:1.35
	tg-mergetmp-3:1.35
	MIRBSD_XP_MIRPPC:1.34.0.4
	MIRBSD_XP_SPARC_BASE:1.34
	MIRBSD_XP_SPARC:1.34.0.2
	MIRBSD_7quater:1.25
	cvs-200405160640:1.1.1.11
	cvs-200401271800:1.1.1.10
	cvs-200401261630:1.1.1.10
	cvs-200401021645:1.1.1.10
	MIRBSD_7_ALPHA:1.25.0.6
	MIRBSD_7:1.25.0.4
	cvs-200312222040:1.1.1.10
	cvs-200312171912:1.1.1.10
	MIRBSD_7ter:1.25
	MIRBSD_7_DEV:1.25.0.2
	cvs-200310020700:1.1.1.9
	cvs-200309271030:1.1.1.9
	cvs-200309261655:1.1.1.9
	cvs-200309251530:1.1.1.9
	cvs-200309192030:1.1.1.8
	cvs-200309181930:1.1.1.7
	cvs-200309131952:1.1.1.6
	cvs-200308302005:1.1.1.5
	cvs-200308221505:1.1.1.5
	cvs-200308171200:1.1.1.5
	ctm-3496:1.1.1.5
	ctm-3449:1.1.1.4
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	cvs-200307072125:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200307021520:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.3
	MIRBSD_5:1.9
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	ctm-3255:1.1.1.2
	ctm-3229:1.1.1.2
	MIRBSD_4:1.2
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2004.12.05.13.25.36;	author tg;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.23.20.15.42;	author tg;	state Stab;
branches;
next	1.33;

1.33
date	2004.01.03.18.29.52;	author tg;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.03.01.10.09;	author tg;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.02.23.47.47;	author tg;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.17.20.42.34;	author tg;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.17.12.49.18;	author tg;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.14.19.28.17;	author tg;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.09.12.54.27;	author tg;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.31.21.07.54;	author tg;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.25.21.00.06;	author tg;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.20.05.23.35;	author tg;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.20.04.51.36;	author tg;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.20.04.29.49;	author tg;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.20.04.27.56;	author tg;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.20.02.52.30;	author tg;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.19.21.57.06;	author tg;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.19.20.44.04;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.18.19.42.27;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.13.20.22.52;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.13.20.15.11;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.13.20.07.51;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.13.20.03.34;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.13.19.56.28;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.16.15.25.41;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.29.19.50.44;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.07.13.55.15;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.05.20.35.33;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.25.11.43.39;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.21.18.14.53;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.20.20.00.57;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.03.18.32.35;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.24.11.05.30;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.52.18;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.49.37;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.49.37;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.24.09.05.38;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.34.28;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.29.17.29.42;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.08.11.18.34.21;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.09.13.19.55.24;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.09.18.19.33.59;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.09.19.20.36.44;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.09.25.16.35.06;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.12.17.19.13.30;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2004.05.16.08.42.38;	author tg;	state Exp;
branches;
next	;


desc
@@


1.35
log
@* replace all occurences of old eMail addresses of mine
  with their more recent counterparts
* no $Log keyword!
* update licence template to most recent version in files touched
* in some places, don't add our own licence boilerplate, just
  add my name to the others
* make dev/rndvar.h suitable for inclusion in asm code
* include dev/rndvar.h by in_cksum.s instead of
  hardcoding pool size
* ENTRY(a); ENTRY(b) -> NENTRY(a); ENTRY(b)
* RCS IDs belong into .comment not .text
@
text
@/**	$MirBSD$ */
/*	$OpenBSD: biosdev.c,v 1.68 2004/03/09 19:12:12 tom Exp $	*/

/*
 * Copyright (c) 1996 Michael Shalayeff
 * Copyright (c) 2003 Tobias Weingartner
 * Copyright (c) 2002, 2003, 2004
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>
#include <machine/tss.h>
#include <machine/biosvar.h>
#include <lib/libsa/saerrno.h>
#include "disk.h"
#include "debug.h"
#include "libsa.h"
#include "biosdev.h"

const char *biosdisk_err(u_int);
int biosdisk_errno(u_int);

static __inline int CHS_rw_real (int, int, int, int, int, int, void *);
static __inline int CHS_rw (int, int, int, int, int, int, void *);
static __inline int EDD_rw (int, int, u_int64_t, u_int32_t, void *);

extern int debug;
int bios_bootdev;
int i386_flag_oldbios = 0;

#if 0
struct biosdisk {
	bios_diskinfo_t *bios_info;
	dev_t	bsddev;
	struct disklabel disklabel;
};
#endif

struct EDD_CB {
	u_int8_t  edd_len;	/* size of packet */
	u_int8_t  edd_res1;	/* reserved */
	u_int8_t  edd_nblk;	/* # of blocks to transfer */
	u_int8_t  edd_res2;	/* reserved */
	u_int16_t edd_off;	/* address of buffer (offset) */
	u_int16_t edd_seg;	/* address of buffer (segment) */
	u_int64_t edd_daddr;	/* starting block */
};

/*
 * reset disk system
 */
int
biosdreset(int dev)
{
	int rv;

	__asm __volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
	    : "0" (0), "d" (dev) : "%ecx", "cc");

	return ((rv & 0xff)? rv >> 8 : 0);
}

/*
 * Fill out a bios_diskinfo_t for this device.
 * Return 0 if all ok.
 * Return 1 if not ok.
 */
int
bios_getdiskinfo(int dev, bios_diskinfo_t *pdi)
{
	u_int rv;

	/* Just reset, don't check return code */
	rv = biosdreset(dev);

#ifdef BIOS_DEBUG
	if (debug)
		printf("getinfo: try #8, 0x%X, %p\n", dev, pdi);
#endif
	__asm __volatile (DOINT(0x13) "\n\t"
	    "setc %b0; movzbl %h1, %1\n\t"
	    "movzbl %%cl, %3; andb $0x3f, %b3\n\t"
	    "xchgb %%cl, %%ch; rolb $2, %%ch"
	    : "=a" (rv), "=d" (pdi->bios_heads),
	      "=c" (pdi->bios_cylinders),
	      "=b" (pdi->bios_sectors)
	    : "0" (0x0800), "1" (dev) : "cc");

#ifdef BIOS_DEBUG
	if (debug) {
		printf("getinfo: got #8\n");
		printf("disk 0x%X: %d,%d,%d\n", dev, pdi->bios_cylinders,
		    pdi->bios_heads, pdi->bios_sectors);
	}
	getchar();
#endif
	if (rv & 0xff)
		return 1;

	/* Fix up info */
	pdi->bios_number = dev;
	pdi->bios_heads++;
	pdi->bios_cylinders &= 0x3ff;
	pdi->bios_cylinders++;

	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors) {
#ifdef BIOS_DEBUG
		printf("sanity: c/h/s value zero: %d/%d/%d\n",
		    pdi->bios_cylinders, pdi->bios_heads, pdi->bios_sectors);
#endif
		return(1);
	}

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2) {
#ifdef BIOS_DEBUG
		printf("sanity: c/h/s heads < 2\n");
#endif
		return(1);
	}

	if (dev & 0x80 && (dev == 0x80 || dev == 0x81 || dev == bios_bootdev)) {
		int bm;
#ifdef BIOS_DEBUG
		if (debug)
			printf("getinfo: try #41, 0x%X\n", dev);
#endif
		/* EDD support check */
		__asm __volatile(DOINT(0x13) "; setc %b0"
			 : "=a" (rv), "=c" (bm)
			 : "0" (0x4100), "b" (0x55aa), "d" (dev) : "cc");
		if (!(rv & 0xff) && (BIOS_regs.biosr_bx & 0xffff) == 0xaa55)
			pdi->bios_edd = (bm & 0xffff) | ((rv & 0xff) << 16);
		else
			pdi->bios_edd = -1;
#ifdef BIOS_DEBUG
		if (debug) {
			printf("getinfo: got #41: %X\n", pdi->bios_edd);
			printf("disk 0x%X: 0x%X\n", dev, bm);
		}
		getchar();
#endif
	} else
		pdi->bios_edd = -1;

	return 0;
}

/*
 * Read/Write a block from given place using the BIOS.
 */
static __inline int
CHS_rw(int rw, int dev, int cyl, int head, int sect, int nsect, void *buf)
{
	int rv = 0;

	if (!i386_flag_oldbios)
		return CHS_rw_real(rw, dev, cyl, head, sect, nsect, buf);

	while (!rv && nsect) {
		rv = CHS_rw_real(rw, dev, cyl, head, sect, 1, buf);
		++sect;
		--nsect;
		buf += 512;
	}
	return rv;
}

/*
 * Do the actual (sector-wise or multi-block) BIOS disc I/O in CHS mode.
 */
static __inline int
CHS_rw_real(int rw, int dev, int cyl, int head, int sect, int nsect, void *buf)
{
	int rv;

	rw = rw == F_READ ? 2 : 3;
	BIOS_regs.biosr_es = (u_int32_t)buf >> 4;
	__asm __volatile ("movb %b7, %h1\n\t"
	    "movb %b6, %%dh\n\t"
	    "andl $0xf, %4\n\t"
	    /* cylinder; the highest 2 bits of cyl is in %cl */
	    "xchgb %%ch, %%cl\n\t"
	    "rorb  $2, %%cl\n\t"
	    "orb %b5, %%cl\n\t"
	    "inc %%cx\n\t"
	    DOINT(0x13) "\n\t"
	    "setc %b0"
	    : "=a" (rv)
	    : "0" (nsect), "d" (dev), "c" (cyl),
	      "b" (buf), "m" (sect), "m" (head),
	      "m" (rw)
	    : "cc", "memory");

	return ((rv & 0xff)? rv >> 8 : 0);
}

static __inline int
EDD_rw(int rw, int dev, u_int64_t daddr, u_int32_t nblk, void *buf)
{
	int rv;
	volatile static struct EDD_CB cb;

	/* Zero out reserved stuff */
	cb.edd_res1 = 0;
	cb.edd_res2 = 0;

	/* Fill in parameters */
	cb.edd_len = sizeof(cb);
	cb.edd_nblk = nblk;
	cb.edd_seg = ((u_int32_t)buf >> 4) & 0xffff;
	cb.edd_off = (u_int32_t)buf & 0xf;
	cb.edd_daddr = daddr;

	/* if offset/segment are zero, punt */
	if (!cb.edd_seg && !cb.edd_off)
		return 1;

	/* Call extended read/write (with disk packet) */
	BIOS_regs.biosr_ds = (u_int32_t)&cb >> 4;
	__asm __volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
	    : "0" ((rw == F_READ)? 0x4200: 0x4300),
	      "d" (dev), "S" ((int) (&cb) & 0xf) : "%ecx", "cc");
	return ((rv & 0xff)? rv >> 8 : 0);
}

/*
 * Read given sector, handling retry/errors/etc.
 */
int
biosd_io(int rw, bios_diskinfo_t *bd, daddr_t off, int nsect, void *buf)
{
	int dev = bd->bios_number;
	int j, error;
	void *bb;

	/* use a bounce buffer to not cross 64k DMA boundary */
	if ((((u_int32_t)buf) & ~0xffff) !=
	    (((u_int32_t)buf + nsect * DEV_BSIZE) & ~0xffff)) {
		/*
		 * XXX we believe that all the io is buffered
		 * by fs routines, so no big reads anyway
		 */
		bb = alloca(nsect * DEV_BSIZE);
		if (rw != F_READ)
			memmove(bb, buf, nsect * DEV_BSIZE);
	} else
		bb = buf;

	/* Try to do operation up to 5 times */
	for (error = 1, j = 5; j-- && error; ) {
		/* CHS or LBA access? */
		if (bd->bios_edd != -1) {
			error = EDD_rw(rw, dev, off, nsect, bb);
		} else {
			int cyl, head, sect;
			size_t i, n;
			char *p = bb;

			/* Handle track boundaries */
			for (error = i = 0; error == 0 && i < nsect;
			    i += n, off += n, p += n * DEV_BSIZE) {

				btochs(off, cyl, head, sect, bd->bios_heads,
				    bd->bios_sectors);

				if ((sect + (nsect - i)) >= bd->bios_sectors)
					n = bd->bios_sectors - sect;
				else
					n = nsect - i;

				error = CHS_rw(rw, dev, cyl, head, sect, n, p);

				/* ECC corrected */
				if (error == 0x11)
					error = 0;
			}
		}
		switch (error) {
		case 0x00:	/* No errors */
		case 0x11:	/* ECC corrected */
			error = 0;
			break;

		default:	/* All other errors */
#ifdef BIOS_DEBUG
			if (debug) {
				printf("\nBIOS error 0x%X (%s)\n",
					error, biosdisk_err(error));
				getchar();
			}
#endif
			biosdreset(dev);
			break;
		}
	}

	if (bb != buf && rw == F_READ)
		memmove(buf, bb, nsect * DEV_BSIZE);

#ifdef BIOS_DEBUG
	if (debug) {
		if (error != 0)
			printf("=0x%X(%s)", error, biosdisk_err(error));
		putchar('\n');
	}
#endif

	return error;
}

/*
 * Try to read the bsd label on the given BIOS device
 */
const char *
bios_getdisklabel(bios_diskinfo_t *bd, struct disklabel *label)
{
	daddr_t off = LABELSECTOR;
	char *buf;
	struct dos_mbr mbr;
	int error, i;
	long mbrofs;

	/* Sanity check */
	if (bd->bios_heads == 0 || bd->bios_sectors == 0)
		return "failed to read disklabel";

	/* MBR is a harddisk thing */
	if (bd->bios_number & 0x80) {
		/* Read MBR */
		mbrofs = DOSBBSECTOR;
loop:		error = biosd_io(F_READ, bd, mbrofs, 1, &mbr);
		if (error)
			return (biosdisk_err(error));

		/* check mbr signature */
		if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
			return "bad MBR signature\n";

		/* Search for MirBSD partition */
		for (off = 0, i = 0; off == 0 && i < NDOSPART; i++) {
			mbr.dmbr_parts[i].dp_start += mbrofs;
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_MIRBSD)
				off = i + 1;
		}

		/* just in case */
		if (!off) for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_OPENBSD)
				off = i + 1;

		/* just in case */
		if (!off) for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_NETBSD)
				off = i + 1;

		/* just in case */
		if (!off) {
		    for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_EXTEND) {
				mbrofs = mbr.dmbr_parts[i].dp_start;
				goto loop;
			}
		    for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_EXTENDL) {
				mbrofs = mbr.dmbr_parts[i].dp_start;
				goto loop;
			}
		    for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_EXTENDLX) {
				mbrofs = mbr.dmbr_parts[i].dp_start;
				goto loop;
			}
		}
		if (!off)
			return("no BSD partition\n");

		off = mbr.dmbr_parts[off - 1].dp_start + LABELSECTOR;
	} else
		off = LABELSECTOR;

	/* Load BSD disklabel */
	buf = alloca(DEV_BSIZE);
#ifdef BIOS_DEBUG
	if (debug)
		printf("loading disklabel @@%u\n", off);
#endif
	/* read disklabel */
	error = biosd_io(F_READ, bd, off, 1, buf);

	if(error)
		return("failed to read disklabel (try again if floppy!)");

	/* Fill in disklabel */
	return (getdisklabel(buf, label));
}

int
biosopen(struct open_file *f, ...)
{
	va_list ap;
	register char	*cp, **file;
	dev_t maj, unit, part;
	struct diskinfo *dip;
	int biosdev;

	va_start(ap, f);
	cp = *(file = va_arg(ap, char **));
	va_end(ap);

#ifdef BIOS_DEBUG
	if (debug)
		printf("%s\n", cp);
#endif

	f->f_devdata = NULL;
	/* search for device specification */
	cp += 2;
	if (cp[2] != ':') {
		if (cp[3] != ':')
			return ENOENT;
		else
			cp++;
	}

	for (maj = 0; maj < nbdevs &&
	     strncmp(*file, bdevs[maj], cp - *file); maj++)
		;
	if (maj >= nbdevs) {
		printf("Unknown device: ");
		for (cp = *file; *cp != ':'; cp++)
			putchar(*cp);
		putchar('\n');
		return EADAPT;
	}

	/* get unit */
	if ('0' <= *cp && *cp <= '9')
		unit = *cp++ - '0';
	else {
		printf("Bad unit number\n");
		return EUNIT;
	}
	/* get partition */
	if ('a' <= *cp && *cp <= 'p')
		part = *cp++ - 'a';
	else {
		printf("Bad partition id\n");
		return EPART;
	}

	cp++;	/* skip ':' */
	if (*cp != 0)
		*file = cp;
	else
		f->f_flags |= F_RAW;

	biosdev = unit;
	switch (maj) {
	case 0:  /* wd */
	case 4:  /* sd */
	case 17: /* hd */
		biosdev |= 0x80;
		break;
	case 2:  /* fd */
		break;
	default:
		return ENXIO;
	}

	/* Find device */
	bootdev_dip = dip = dklookup(biosdev);

	/* Fix up bootdev */
	{ dev_t bsd_dev;
		bsd_dev = dip->bios_info.bsd_dev;
		dip->bsddev = MAKEBOOTDEV(B_TYPE(bsd_dev), B_ADAPTOR(bsd_dev),
		    B_CONTROLLER(bsd_dev), unit, part);
		dip->bootdev = MAKEBOOTDEV(B_TYPE(bsd_dev), B_ADAPTOR(bsd_dev),
		    B_CONTROLLER(bsd_dev), B_UNIT(bsd_dev), part);
	}

#if 0
	dip->bios_info.bsd_dev = dip->bootdev;
	bootdev = dip->bootdev;
#endif

#ifdef BIOS_DEBUG
	if (debug) {
		printf("BIOS geometry: heads=%u, s/t=%u; EDD=%d\n",
		    dip->bios_info.bios_heads, dip->bios_info.bios_sectors,
		    dip->bios_info.bios_edd);
	}
#endif

	/* Try for disklabel again (might be removable media) */
	if(dip->bios_info.flags & BDI_BADLABEL) {
		const char *st = bios_getdisklabel(&dip->bios_info,
		    &dip->disklabel);
		if (st != NULL) {
			printf("%s\n", st);
			return ERDLAB;
		}
		dip->bios_info.flags &= !BDI_BADLABEL;
	}

	f->f_devdata = dip;

	cp++;	/* skip ':' */
	if (*cp != 0)
		*file = cp;
	else
		f->f_flags |= F_RAW;

	return 0;
}

const u_char bidos_errs[] =
/* ignored	"\x00" "successful completion\0" */
		"\x01" "invalid function/parameter\0"
		"\x02" "address mark not found\0"
		"\x03" "write-protected\0"
		"\x04" "sector not found\0"
		"\x05" "reset failed\0"
		"\x06" "disk changed\0"
		"\x07" "drive parameter activity failed\0"
		"\x08" "DMA overrun\0"
		"\x09" "data boundary error\0"
		"\x0A" "bad sector detected\0"
		"\x0B" "bad track detected\0"
		"\x0C" "invalid media\0"
		"\x0E" "control data address mark detected\0"
		"\x0F" "DMA arbitration level out of range\0"
		"\x10" "uncorrectable CRC or ECC error on read\0"
/* ignored	"\x11" "data ECC corrected\0" */
		"\x20" "controller failure\0"
		"\x31" "no media in drive\0"
		"\x32" "incorrect drive type in CMOS\0"
		"\x40" "seek failed\0"
		"\x80" "operation timed out\0"
		"\xAA" "drive not ready\0"
		"\xB0" "volume not locked in drive\0"
		"\xB1" "volume locked in drive\0"
		"\xB2" "volume not removable\0"
		"\xB3" "volume in use\0"
		"\xB4" "lock count exceeded\0"
		"\xB5" "valid eject request failed\0"
		"\xBB" "undefined error\0"
		"\xCC" "write fault\0"
		"\xE0" "status register error\0"
		"\xFF" "sense operation failed\0"
		"\x00" "\0";

const char *
biosdisk_err(u_int error)
{
	register const u_char *p = bidos_errs;

	while (*p && *p != error)
		while (*p++);

	return ++p;
}

const struct biosdisk_errors {
	u_char error;
	u_char errno;
} tab[] = {
	{ 0x01, EINVAL },
	{ 0x03, EROFS },
	{ 0x08, EINVAL },
	{ 0x09, EINVAL },
	{ 0x0A, EBSE },
	{ 0x0B, EBSE },
	{ 0x0C, ENXIO },
	{ 0x0D, EINVAL },
	{ 0x10, EECC },
	{ 0x20, EHER },
	{ 0x31, ENXIO },
	{ 0x32, ENXIO },
	{ 0x00, EIO }
};

int
biosdisk_errno(u_int error)
{
	register const struct biosdisk_errors *p;

	if (error == 0)
		return 0;

	for (p = tab; p->error && p->error != error; p++);

	return p->errno;
}

int
biosstrategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
    size_t *rsize)
{
	struct diskinfo *dip = (struct diskinfo *)devdata;
	bios_diskinfo_t *bd = &dip->bios_info;
	u_int8_t error = 0;
	size_t nsect;

	nsect = (size + DEV_BSIZE-1) / DEV_BSIZE;
	if (rsize != NULL)
		blk += dip->disklabel.
			d_partitions[B_PARTITION(dip->bsddev)].p_offset;

	/* Read all, sub-functions handle track boundaries */
	error = biosd_io(rw, bd, blk, nsect, buf);

#ifdef BIOS_DEBUG
	if (debug) {
		if (error != 0)
			printf("=0x%X(%s)", error, biosdisk_err(error));
		putchar('\n');
	}
#endif

	if (rsize != NULL)
		*rsize = nsect * DEV_BSIZE;

	return (biosdisk_errno(error));
}

int
biosclose(struct open_file *f)
{
	f->f_devdata = NULL;

	return 0;
}

int
biosioctl(struct open_file *f, u_long cmd, void *data)
{
	return 0;
}
@


1.34
log
@* first futile attempt to merge OpenBSD 3.5-current
* damn! they got pxeboot! -> disable for now
  (there's still ports/sysutils/pxegrub; we'll have pxeboot later)
* I don't know if that ... bootloader still works
* nuke netbsd emul (was unused anyways)
* nuke a plethora of syscalls not being used, and mark
  the other two (COMPAT_35) for deletion RSN
* merge new MI-GENERIC into i386 GENERIC
* resolve numeric conflicts for
  - syscalls
  - sysctls
  - device majors
  - pcidevs
* (c) cleanup - no need to add a bsd-like licence when
  there's already one; just add my name
* and much more
@
text
@d1 1
a1 1
/*	$MirBSD: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.33 2004/01/03 18:29:52 tg Exp $	*/
d8 1
a8 1
 *	Thorsten Glaser <x86@@ePost.de> for the MirOS Project
@


1.33
log
@it appears to work, moving out the partition with the disklabel
into an extended partition.

snippets from dmesg, fdisk and disklabel:

MirBSD#7u96 3.4-20040103 (GENERIC) #330: Sat Jan  3 18:04:27 UTC 2004
	tg@@odem.66h.42h.de:/usr/src/sys/arch/i386/compile/GENERIC
[...]
Searching for raid components...
debug: found partition 0: type 0F ofs 1 (0x1h) size 1 (0x1), chaining...
debug: found partition 3: type 27 ofs 15200640 (0xE7F180h) size 23869440 (0x16C3800).
warning: broken MBR signature
warning: broken MBR signature
dkcsum: wd0 matched BIOS disk 80



Disk: wd0	geometry: 38760/16/63 [39070080 Sectors]
Offset: 0	Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 0F    0   0  2 -    0   0  2 [           1:           1 ] Extended LBA
 1: DB  510   0  1 - 15079  15 63 [      514080:    14686560 ] CPM/C.DOS/C*
 2: 06    0   0  3 -  509  15 63 [           2:      514078 ] DOS > 32MB
*3: DB 15080   0  1 - 38759  15 63 [    15200640:    23869440 ] CPM/C.DOS/C*
Offset: 1	Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 1: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
*3: 27 15080   0  1 - 38759  15 63 [    15200640:    23869440 ] MirBSD



# found partition 0: type 0F ofs 1 (0x1h) size 1 (0x1), chaining...
# found partition 3: type 27 ofs 15200640 (0xE7F180h) size 23869440 (0x16C3800).
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: IC25N020ATCS04-0
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 39070080
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0		# microseconds
track-to-track seek: 0	# microseconds
drivedata: 0

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a: 17053344 22016736    4.2BSD     2048 16384   328 	# (Cyl. 21842 - 38759)
  b:   524160 15200640      swap                      	# (Cyl. 15080 - 15599)
  c: 39070080        0    unused        0     0       	# (Cyl.    0 - 38759)
  d:  6291936 15724800    4.2BSD     2048 16384   328 	# (Cyl. 15600 - 21841)
  e: 14686560   514080    4.2BSD     2048 16384   328 	# (Cyl.  510 - 15079)
  m:   514078        2     MSDOS                      	# (Cyl.    0*- 509)
  p:        2        0   unknown                      	# (Cyl.    0 - 0*)
@
text
@d1 2
a2 2
/*	$MirBSD: biosdev.c,v 1.32 2004/01/03 01:10:09 tg Exp $	*/
/*	$OpenBSD: biosdev.c,v 1.67 2003/11/27 00:33:24 espie Exp $	*/
d65 7
a71 7
	u_int8_t  edd_len;   /* size of packet */
	u_int8_t  edd_res1;  /* reserved */
	u_int8_t  edd_nblk;  /* # of blocks to transfer */
	u_int8_t  edd_res2;  /* reserved */
	u_int16_t edd_off;   /* address of buffer (offset) */
	u_int16_t edd_seg;   /* address of buffer (segment) */
	u_int64_t edd_daddr; /* starting block */
d81 1
d83 3
a85 2
			  : "0" (0), "d" (dev) : "%ecx", "cc");
	return (rv & 0xff)? rv >> 8 : 0;
d106 7
a112 7
			  "setc %b0; movzbl %h1, %1\n\t"
			  "movzbl %%cl, %3; andb $0x3f, %b3\n\t"
			  "xchgb %%cl, %%ch; rolb $2, %%ch"
			  : "=a" (rv), "=d" (pdi->bios_heads),
			    "=c" (pdi->bios_cylinders),
			    "=b" (pdi->bios_sectors)
			  : "0" (0x0800), "1" (dev) : "cc");
d118 1
a118 1
			pdi->bios_heads, pdi->bios_sectors);
d123 1
a123 1
		return (1);
d172 1
a172 1
	return(0);
d206 14
a219 14
			  "movb %b6, %%dh\n\t"
			  "andl $0xf, %4\n\t"
			  /* cylinder; the highest 2 bits of cyl is in %cl */
			  "xchgb %%ch, %%cl\n\t"
			  "rorb  $2, %%cl\n\t"
			  "orb %b5, %%cl\n\t"
			  "inc %%cx\n\t"
			  DOINT(0x13) "\n\t"
			  "setc %b0"
			  : "=a" (rv)
			  : "0" (nsect), "d" (dev), "c" (cyl),
			    "b" (buf), "m" (sect), "m" (head),
			    "m" (rw)
			  : "cc", "memory");
d221 1
a221 1
	return (rv & 0xff)? rv >> 8 : 0;
d243 1
a243 1
		return (1);
d248 3
a250 3
			  : "0" ((rw == F_READ)? 0x4200: 0x4300),
			    "d" (dev), "S" ((int) (&cb) & 0xf) : "%ecx", "cc");
	return (rv & 0xff)? rv >> 8 : 0;
d277 1
a277 1
	for (error = 1, j = 5; j-- && error;) {
d288 4
a291 1
 					i += n, off += n, p += n * DEV_BSIZE) {
a292 1
				btochs(off, cyl, head, sect, bd->bios_heads, bd->bios_sectors);
d335 1
a335 1
	return (error);
d350 4
d360 1
a360 1
			return(biosdisk_err(error));
d364 1
a364 1
			return("bad MBR signature\n");
a400 1

d429 1
a429 1
	dev_t	maj, unit, part;
d453 2
a454 1
	     strncmp(*file, bdevs[maj], cp - *file); maj++);
d478 6
d504 1
a504 1
			B_CONTROLLER(bsd_dev), unit, part);
d506 1
a506 1
			B_CONTROLLER(bsd_dev), B_UNIT(bsd_dev), part);
d517 2
a518 2
			dip->bios_info.bios_heads, dip->bios_info.bios_sectors,
			dip->bios_info.bios_edd);
d586 1
a586 1
		while(*p++);
d615 1
a615 1
	if (!error)
d651 1
a651 1
	return biosdisk_errno(error);
d658 1
@


1.32
log
@match other changes
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.31 2004/01/02 23:47:47 tg Exp $	*/
d6 1
a8 1
 * Copyright (c) 2003 Tobias Weingartner
d405 1
a405 1
		printf("loading disklabel @@ %u\n", off);
@


1.31
log
@extended partition support for the bootloader
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.30 2003/12/17 20:42:34 tg Exp $	*/
d359 2
a360 1
		for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
d363 1
@


1.30
log
@merge OpenBSD
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.29 2003/11/17 12:49:18 tg Exp $	*/
d6 2
a7 1
 * Copyright (c) 2002, 2003 Thorsten Glaser <x86@@ePost.de>
d344 1
d349 2
a350 1
		error = biosd_io(F_READ, bd, DOSBBSECTOR, 1, &mbr);
d373 20
a392 1
		if (off == 0)
@


1.29
log
@let's just remove bzero, bcmp, bcopy and look what happens.
	bcmp	-> memcmp
	bcopy	-> memmove
	bzero	-> memset
	memcpy	-> memmove *)

*) it happens that old memcpy was implemented
   as per semantics of memmove, thats why I changed
@
text
@d1 2
a2 2
/*	$MirBSD: biosdev.c,v 1.28 2003/11/14 19:28:17 tg Exp $	*/
/*	$OpenBSD: biosdev.c,v 1.66 2003/09/20 05:23:42 fgsch Exp $	*/
d200 1
d215 1
a215 1
			    "m" ((rw == F_READ)? 2: 3)
@


1.28
log
@unbreak /boot a little
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.26 2003/10/31 21:07:54 tg Exp $	*/
d268 1
a268 1
			bcopy (buf, bb, nsect * DEV_BSIZE);
d319 1
a319 1
		bcopy (bb, buf, nsect * DEV_BSIZE);
@


1.27
log
@Mostly... not fully...

One weekend's worth of work.

- catch up website log with changes really done till today
- add catch-up entries for wbx@@ and bsiegert@@, too
- move GNU documentation to src/gnu/doc and simplify it
- re-run autoconf on the gnu part of the tree again, to
  catch up with the GFDL-documentation removal
- provide non-GFDL-licenced as(1) and ld(1) manual pages
  XXX these are more than outdated!
- bump MirOS patchlevel
- build the system through, fixing showstoppers where
  they are encountered
- index.cgi and index.php come before index.htm,
  default.htm and index.html in httpd.conf
- speed up PHP processing
- prepare for "new" OpenBSD pkgtools (unsupported by MirBSD,
  but some MirPorts people want to play with them)
- move old weblog to CMS; update my info again
- update hRef""s in old weblogs
- move release announcements to /historic/
- copy feature list from last release announcement
  XXX need a "readible short list", or even
  XXX	a separation for the target environment
  XXX	(e.g. suits / techies / clients)
- add some recent news, so the page ain't empty
  missing:
	- about
	  + MirOS
	  + MirPorts
	- get MirOS!	(http d/l, http install, install docs)
	- relations	(to other BSD)
	  + ??? events ??? (here?)
	- history
	- older releases	(historic)
	- help pages
	  + FAQ
	  + Docs/Tuts	(hi wbx@@ here comes your place)
	    + install docs
	  + mailing lists
	- developers
	  + wbx
	  + bsiegert
	  + cnuke
	- CVSweb	(XXX need BSDadvocacy.org fix before)
	- AnonCVS	(howto; link to)
	- Links
  alternatively, change the layout? suggestions?
  why am I the only one who cares about www?
- merge development plan
- put a "project" into the miros page head
- fix cdboot Makefile
- fix gas wanting us a.out again (wut?)
  (turned out to be a must-fix in configure.in)
- stand/cdboot/NOTES merged into stand/README
- sync distrib set lists
- have TORI device (i386 libsa) always use bounce buffers
  (which, in fact, makes it succeed in loading the kernel)
  XXX kernel says it has less than 4 meg ram (degraded mode)
  XXX may be a bochs issue?
- fix random.S again
- move determining of file name / raw file flag in both
  bios/toridev.c to the end of bios/toriopen()
  => enables us to have two drivers at once
- fix disk probing for CD devices wrt BIOS driver

(eww. The tree isn't fully broken, but neither boot
 nor cdboot.bin are usable at all at the moment.
 I'll fix that ASAP.)
@
text
@a84 9
void    *xalloca(size_t);
void    *alloca(size_t x)
{
	void *y;
	y=xalloca(x);
	printf("biosd_io alloca=%x\n",(u_int32_t)y);
	return y;
}

a459 2
	if (dip == NULL)
		return ENXIO;
a462 1
printf("deb:f0 ");
a463 14
printf("f1 ");
printf("bsd_dev=<%x> ", bsd_dev);
printf("TYPE_bsd_dev=<%x> ", B_TYPE(bsd_dev));
printf("ADAP_bsd_dev=<%x> ", B_ADAPTOR(bsd_dev));
printf("CTRL_bsd_dev=<%x> ", B_CONTROLLER(bsd_dev));
printf("unit=<%x> ", unit);
printf("part=<%x> ", part);
printf("mbd=<%x> ", MAKEBOOTDEV(B_TYPE(bsd_dev), B_ADAPTOR(bsd_dev),
                        B_CONTROLLER(bsd_dev), unit, part));
printf("dip=<%x> ", (u_int32_t)dip);
printf("dip->bsddev=<%x> ", (u_int32_t)dip->bsddev);
		dip->bsddev = 0xa0000053;
printf("f2a ");

a465 1
printf("f2 ");
a467 1
printf("fe\n");
@


1.26
log
@I've come so far that it at least boots /boot (in bochs)
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.25 2003/09/25 21:00:06 tg Exp $	*/
d85 9
a453 6
	cp++;	/* skip ':' */
	if (*cp != 0)
		*file = cp;
	else
		f->f_flags |= F_RAW;

d469 2
d474 1
d476 14
d492 1
d495 1
d523 6
@


1.25
log
@Merge OpenBSD-current
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.24 2003/09/20 05:23:35 tg Exp $	*/
d44 2
a45 2
static const char *biosdisk_err(u_int);
static int biosdisk_errno(u_int);
d76 1
a76 1
static int
d541 1
a541 1
static const char *
d571 1
a571 1
static int
@


1.24
log
@tell the user that floppies may need retries...
@
text
@d1 2
a2 2
/*	$MirBSD: biosdev.c,v 1.23 2003/09/20 04:51:36 tg Exp $	*/
/*	$OpenBSD: biosdev.c,v 1.65 2003/09/19 04:17:00 fgsch Exp $	*/
@


1.23
log
@o sprinkle a few getchar() to enable waiting [debugging]
o move sanity checks to _after_ the values read out from
  the registers after the BIOS call have been corrected.
  This should be submitted upstream!
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.22 2003/09/20 04:29:49 tg Exp $	*/
d386 1
a386 1
		return("failed to read disklabel");
@


1.22
log
@match prototypes with reality (d'oh, OpenBSD didn't)
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.21 2003/09/20 04:27:56 tg Exp $	*/
d117 1
d122 6
d129 5
a133 1
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
d135 1
d138 4
a141 1
	if (pdi->bios_heads < 2)
d143 1
a143 6

	/* Fix up info */
	pdi->bios_number = dev;
	pdi->bios_heads++;
	pdi->bios_cylinders &= 0x3ff;
	pdi->bios_cylinders++;
d164 1
d307 1
a307 1
			if (debug)
d310 2
@


1.21
log
@now, if _that_ doesn't render a usable boot loader, it's FUBAR
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.11 2003/08/16 15:25:41 tg Exp $	*/
d47 3
a49 3
static int CHS_rw_real (int, int, int, int, int, int, void *);
static int CHS_rw (int, int, int, int, int, int, void *);
static int EDD_rw (int, int, u_int64_t, u_int32_t, void *);
@


1.20
log
@the last bootblock was a disaster.
everything worked - except for booting from a simple floppy.
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.19 2003/09/19 21:57:06 tg Exp $	*/
d47 1
a48 1
static int CHS_rw_real (int, int, int, int, int, int, void *);
d53 1
a53 1
int i386_use_soekris = 0;
a136 1

d139 1
a139 1
			printf("getinfo: try #41, 0x%x\n", dev);
a148 1

d151 2
a152 2
			printf("getinfo: got #41\n");
			printf("disk 0x%x: 0x%x\n", dev, bm);
d162 21
a182 3
 * Read/Write a block from given place using the BIOS. This is the "real"
 * BIOS-calling routine, which is chained to by the soekris-and-broken-BIOS
 * helper routine below, which feeds it sector by sector to myself.
a208 21
/*
 * Read/Write a block from given place using the BIOS.
 */
static __inline int
CHS_rw(int rw, int dev, int cyl, int head, int sect, int nsect, void *buf)
{
	int rv = 0;

	if (!i386_use_soekris)
		return CHS_rw_real(rw, dev, cyl, head, sect, nsect, buf);

	while (nsect && !rv) {
		rv = CHS_rw_real(rw, dev, cyl, head, sect, 1, buf);
		buf += 512;
		++sect;
		--nsect;
	}

	return (rv);
}

d344 1
a344 1
				off = mbr.dmbr_parts[i].dp_start + LABELSECTOR;
d347 1
a347 2
		if (off == 0)
		for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
d349 1
a349 1
				off = mbr.dmbr_parts[i].dp_start + LABELSECTOR;
d352 3
a354 4
		if (off == 0)
			for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
				if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_NETBSD)
					off = mbr.dmbr_parts[i].dp_start + LABELSECTOR;
d358 2
@


1.19
log
@back out some changes which failed regression:
a generated floppy or CD was not even bootable in my machine.

This is now the version MirOS BSD #7 will ship with.
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.18 2003/09/19 20:44:04 tg Exp $	*/
d121 8
a134 10
	/* NOTE:
	 * This currently hangs/reboots some machines
	 * The IBM Thinkpad 750ED for one.
	 *
	 * Funny that an IBM/MS extension would not be
	 * implemented by an IBM system...
	 *
	 * Future hangs (when reported) can be "fixed"
	 * with getSYSCONFaddr() and an exceptions list.
	 */
a159 8
	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return(1);

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2)
		return(1);

a334 4
	/* Sanity check */
	if(bd->bios_heads == 0 || bd->bios_sectors == 0)
		return("failed to read disklabel");

a489 1
		dip->bios_info.flags |= BDI_GOODLABEL;
@


1.18
log
@sync boot code with latest OpenBSD and bump minor
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.17 2003/09/18 19:42:27 tg Exp $	*/
a120 8
	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return(1);

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2)
		return(1);

a158 6
		/*
		 * If extended disk access functions are not supported
		 * there is not much point on doing EDD.
		 */
		if (!(pdi->bios_edd & EXT_BM_EDA))
			pdi->bios_edd = -1;
d161 8
@


1.17
log
@screw up bootcode again (neccessarily...)
@
text
@d1 2
a2 2
/*	$MirBSD: biosdev.c,v 1.16 2003/09/13 20:22:52 tg Exp $	*/
/*	$OpenBSD: biosdev.c,v 1.64 2003/09/18 08:24:11 fgsch Exp $	*/
d100 1
a100 1
		printf("getinfo: try #8, %X,%p\n", dev, pdi);
d147 5
d161 6
@


1.16
log
@move new routine below to circumvent gcc error
@
text
@d1 2
a2 2
/*	$MirBSD: biosdev.c,v 1.15 2003/09/13 20:15:11 tg Exp $	*/
/*	$OpenBSD: biosdev.c,v 1.61 2003/09/11 17:39:35 deraadt Exp $	*/
d121 8
d160 1
a160 1
		if (!(pdi->bios_edd & 1))
a164 8
	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return(1);

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2)
		return(1);

d492 2
a493 1
		const char *st = bios_getdisklabel(&dip->bios_info, &dip->disklabel);
d499 1
@


1.15
log
@add a "machine oldbios" command which toggles the oldbios/soekris helper
default: off (for performance reasons :-)

remove a few more whitespace
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.14 2003/09/13 20:07:51 tg Exp $	*/
a168 21
 * Read/Write a block from given place using the BIOS.
 */
static __inline int
CHS_rw(int rw, int dev, int cyl, int head, int sect, int nsect, void *buf)
{
	int rv = 0;

	if (!i386_use_soekris)
		return CHS_rw_real(rw, dev, cyl, head, sect, nsect, buf);

	while (nsect && !rv) {
		rv = CHS_rw_real(rw, dev, cyl, head, sect, 1, buf);
		buf += 512;
		++sect;
		--nsect;
	}

	return (rv);
}

/*
d171 1
a171 1
 * helper routine above, which feeds it sector by sector to myself.
d196 21
@


1.14
log
@sector-by-sector diff (see misc@@ thread:

thanks to Quentin Garnier, forwarded to me by Charles E. Hill
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.13 2003/09/13 20:03:34 tg Exp $	*/
d53 1
d175 3
@


1.13
log
@pure whitespace diff:
KNF -> remove whitespace at EOL
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.12 2003/09/13 19:56:28 tg Exp $	*/
d48 1
d172 20
@


1.12
log
@merge OpenBSD import
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.11 2003/08/16 15:25:41 tg Exp $	*/
d19 2
a20 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d396 1
a396 1
	for (maj = 0; maj < nbdevs && 
d420 1
a420 1
		
d480 1
a480 1
const u_char bidos_errs[] = 
d540 1
a540 1
	{ 0x20, EHER },	
@


1.11
log
@Merge OpenBSD
@
text
@d1 2
a2 2
/*	$MirBSD: biosdev.c,v 1.10 2003/06/29 19:50:44 tg Exp $	*/
/*	$OpenBSD: biosdev.c,v 1.60 2003/08/11 06:23:09 deraadt Exp $	*/
d144 7
@


1.10
log
@merge the import
amd (automount dæmon) bites the dust
rewrite fake-NLS emulation, copyright to me
foobar! fnord!
@
text
@d1 2
a2 2
/*	$MirBSD: biosdev.c,v 1.9 2003/06/07 13:55:15 tg Exp $	*/
/*	$OpenBSD: biosdev.c,v 1.59 2003/06/27 05:13:19 weingart Exp $	*/
d75 1
a75 2
biosdreset(dev)
	int dev;
d89 1
a89 3
bios_getdiskinfo(dev, pdi)
	int dev;
	bios_diskinfo_t *pdi;
d163 1
a163 4
CHS_rw(rw, dev, cyl, head, sect, nsect, buf)
	int rw, dev, cyl, head;
	int sect, nsect;
	void * buf;
d166 1
d188 1
a188 5
EDD_rw(rw, dev, daddr, nblk, buf)
	int rw, dev;
	u_int64_t daddr;
	u_int32_t nblk;
	void *buf;
d220 1
a220 6
biosd_io(rw, bd, off, nsect, buf)
	int rw;
	bios_diskinfo_t *bd;
	daddr_t off;
	int nsect;
	void* buf;
d301 1
a301 3
bios_getdisklabel(bd, label)
	bios_diskinfo_t *bd;
	struct disklabel *label;
d510 1
a510 2
biosdisk_err(error)
	u_int error;
d538 1
d540 1
a540 2
biosdisk_errno(error)
	u_int error;
d553 2
a554 7
biosstrategy(devdata, rw, blk, size, buf, rsize)
	void *devdata;
	int rw;
	daddr_t blk;
	size_t size;
	void *buf;
	size_t *rsize;
d584 1
a584 2
biosclose(f)
	struct open_file *f;
d591 1
a591 4
biosioctl(f, cmd, data)
	struct open_file *f;
	u_long cmd;
	void *data;
@


1.9
log
@oops... it recognized the MBR partition (27) correctly,
but zeroed it out and looked after an OpenBSD one (A6)
directly after that. Don't - look if we didn't already
find the MirBSD one already first!
@
text
@d1 2
a2 2
/*	$MirBSD: biosdev.c,v 1.8 2003/06/05 20:35:33 tg Exp $	*/
/*	$OpenBSD: biosdev.c,v 1.58 2003/06/03 20:22:11 mickey Exp $	*/
d51 1
d94 1
a94 1
	u_int rv, secl, sech;
a127 16
	/*
	 * NOTE: This seems to hang on certain machines.  Use function #8
	 * first, and verify with #21 IFF #8 succeeds first.
	 * Do not try this for floppy 0 (to support CD-ROM boot).
	 */
	if (dev) {
		__asm __volatile (DOINT(0x13) ";setc %b0"
				: "=a" (rv), "=d" (secl), "=c" (sech)
				: "0" (0x15FF), "1" (dev), "2" (0xFFFF)
				: "cc");
		if (!(rv & 0xff00))
			return (1);
		if (rv & 0xff)
			return (1);
	}

d138 1
a138 1
	if (dev & 0x80) {
@


1.8
log
@merge cvs import conflicts in i386-stand
so I can continue bootloader work
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.7 2003/05/25 11:43:39 tg Exp $	*/
d360 1
@


1.7
log
@nuke leftover from last cvs import
@
text
@d1 2
a2 2
/*	$MirBSD: biosdev.c,v 1.6 2003/05/21 18:14:53 tg Exp $	*/
/*	$OpenBSD: biosdev.c,v 1.55 2003/04/17 03:43:18 drahn Exp $	*/
d6 1
a6 1
 * Copyright (c) 2002-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d47 2
a48 2
static int CHS_rw __P((int, int, int, int, int, int, void *));
static int EDD_rw __P((int, int, u_int64_t, u_int32_t, void *));
@


1.6
log
@make /boot LBA capable, from Tobias Weingartner
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.5 2003/05/20 20:00:57 tg Exp $	*/
a312 2
			if (j == 2)
				use_edd = 0; /* fall back */
@


1.5
log
@employ our own idea of a MirBSD disklabel and partition type:
 0xA6 OpenBSD is used as fall-back
 0x27 MirBSD disklabel is the new type
reason: addition of FS_* constants in sys/sys/disklabel.h
might get us outta sync with OpenBSD laters (NTFS here)

talk about "slices" in disklabel
remove trailing newlines etc. in fdisk
@
text
@d1 1
a1 1
/*	$MirBSD: biosdev.c,v 1.4 2003/05/03 18:32:35 tg Exp $	*/
d6 2
a7 1
 * Copyright (c) 2002 by Thorsten "mirabile" Glaser <x86@@ePost.de>
d52 3
d67 5
a71 3
	u_int8_t  edd_res;   /* reserved */
	u_int16_t edd_nblk;  /* # of blocks to transfer */
	u_int32_t edd_buf;   /* address of buffer */
d98 1
a98 1
	u_int rv;
d101 1
a101 1
	biosdreset(dev);
d124 1
a124 1
		return(1);
d132 16
a147 2
#if 0
/* XXX this code is not accepted by gcc XXX */
d154 3
d161 1
a161 1
		__asm __volatile("int $2;" DOINT(0x13) "; setc %b0"
d163 1
a163 2
			 : "0" (0x4100), "2" (0x55aa), "d" (dev) : "cc");
		DUMP_REGS;
d165 1
a165 1
			pdi->bios_edd = bm & 0xffff;
a169 3
#else
	pdi->bios_edd = -1;
#endif
d171 1
a171 15
	/*
	 * NOTE: This seems to hang on certain machines.  Use function #8
	 * first, and verify with #21 IFF #8 succeeds first.
	 * Do not try this for floppy 0 (to support CD-ROM boot).
	 */
	if (dev) {
		__asm __volatile (DOINT(0x13) "; setc %b0"
			: "=a" (rv) : "0" (0x1500), "d" (dev) : "%ecx", "cc");
		if(!(rv & 0xff00))
			return(1);
		if(rv & 0xff)
			return(1);
	}

	/* XXX - Sanity check */
d186 1
a186 1
biosd_rw(rw, dev, cyl, head, sect, nsect, buf)
d212 1
a212 1
int
d220 5
a224 1
	struct EDD_CB cb;
d226 1
d229 2
a230 1
	cb.edd_buf = (u_int32_t)buf;
d233 6
d241 1
a241 1
			    "d" (dev), "S" (&cb) : "%ecx", "cc");
d249 6
a254 5
biosd_io(rw, dev, cyl, head, sect, nsect, buf, use_edd)
	int rw, dev, cyl, head;
	int sect, nsect;
	void * buf;
	int use_edd;
d256 1
a259 8
#ifdef BIOS_DEBUG
	if (debug)
		printf("biosd_io(%s,%X,%u,%u,%u,%u,%p,%s)\n",
		       (rw==F_READ?"reading":"writing"), dev,
			   cyl, head, sect, nsect, buf,
			   (use_edd==0?"CHS":"LBA"));
#endif

d272 1
a272 4
#ifdef BIOS_DEBUG
	if (debug)
		printf(" (%d,%d,%d,%d)@@%p", cyl, head, sect, nsect, bb);
#endif
d274 27
a300 6
	for (error = 1, j = 5; j-- && error;)
		switch (error = (
		    (use_edd == 0)
		    ? (biosd_rw(rw, dev, cyl, head, sect, nsect, bb))
		    : (EDD_rw(rw, dev, cyl, head, sect, nsect, bb))
		    )) {
d317 1
d330 1
a330 1
	return biosdisk_errno(error);
a343 1
	int cyl, head, sect;
d346 1
a346 1
	/* XXX - Sanity check */
d350 1
a350 1
	/* MBR is a hard thing */
d353 2
a354 7
		btochs(DOSBBSECTOR, cyl, head, sect,
		       bd->bios_heads, bd->bios_sectors);

		error = biosd_io(F_READ, bd->bios_number,
				 cyl, head, sect, 1, &mbr,
				 (bd->bios_edd>0)?1:0);
		if(error)
d389 1
a389 3
	btochs(off, cyl, head, sect, bd->bios_heads, bd->bios_sectors);
	error = biosd_io(F_READ, bd->bios_number, cyl, head, sect, 1, buf,
	    (bd->bios_edd>0)?1:0);
d599 2
d602 1
a602 3
	struct diskinfo *dip = (struct diskinfo *)devdata;
	register size_t i, nsect, n, spt, tpc;
	int dev;
d609 2
a610 23
	/* handle floppies w/ different from drive geometry */
	if (!(dip->bios_info.bios_number & 0x80) &&
	    dip->disklabel.d_nsectors != 0)
		spt = dip->disklabel.d_nsectors;
	else
		spt = dip->bios_info.bios_sectors;

	tpc = dip->bios_info.bios_heads;
	dev = dip->bios_info.bios_number;

	for (i = 0; error == 0 && i < nsect;
	     i += n, blk += n, buf += n * DEV_BSIZE) {
		register int	cyl, hd, sect;

		btochs(blk, cyl, hd, sect, tpc, spt);
		if ((sect + (nsect - i)) >= spt)
			n = spt - sect;
		else
			n = nsect - i;
		
		error = biosd_io(rw, dev, cyl, hd, sect, n, buf,
		    (dip->bios_info.bios_edd>0)?1:0);
	}
d621 1
a621 1
		*rsize = i * DEV_BSIZE;
@


1.4
log
@prepare for booting by means of EDD
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
d337 6
a342 1
		/* Search for OpenBSD partition */
@


1.3
log
@fix cvs import mess, merge OpenBSD-current
implement optional a.out support in /boot
@
text
@d1 1
d127 1
d232 1
a232 1
biosd_io(rw, dev, cyl, head, sect, nsect, buf)
d236 1
d243 1
a243 1
		printf("biosd_io(%s,%X,%u,%u,%u,%u,%p)\n",
d245 2
a246 1
			   cyl, head, sect, nsect, buf);
d267 5
a271 1
		switch (error = biosd_rw(rw, dev, cyl, head, sect, nsect, bb)) {
d284 2
d328 2
a329 1
				 cyl, head, sect, 1, &mbr);
d361 2
a362 1
	error = biosd_io(F_READ, bd->bios_number, cyl, head, sect, 1, buf);
d602 2
a603 1
		error = biosd_io(rw, dev, cyl, hd, sect, n, buf);
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.54 2002/03/14 03:15:54 millert Exp $	*/
d98 1
a98 1
		printf("getinfo: try #8, %x,%p\n", dev, pdi);
d112 1
a112 1
		printf("disk 0x%x: %d,%d,%d\n", dev, pdi->bios_cylinders,
d240 1
a240 1
		printf("biosd_io(%s,%x,%u,%u,%u,%u,%p)\n",
d272 1
a272 1
				printf("\nBIOS error 0x%x (%s)\n",
d285 1
a285 1
			printf("=0x%x(%s)", error, biosdisk_err(error));
d596 1
a596 1
			printf("=0x%x(%s)", error, biosdisk_err(error));
@


1.1
log
@Initial revision
@
text
@d5 1
d22 1
a22 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
d193 1
a193 1
			  "incl %%cx\n\t"
d457 3
a459 3
	if(dip->bios_info.flags & BDI_BADLABEL){
		const char *st = bios_getdisklabel((void *)biosdev, &dip->disklabel);
		if (debug && st)
d461 3
a463 2

		return ERDLAB;
a622 1

@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import some parts of OpenBSD-current (after their ELF switch) to ease future merging and reduce diffs against their codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.55 2003/04/17 03:43:18 drahn Exp $	*/
d192 1
a192 1
			  "inc %%cx\n\t"
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.58 2003/06/03 20:22:11 mickey Exp $	*/
a4 1
 * Copyright (c) 2003 Tobias Weingartner
d15 5
a48 3
static int CHS_rw (int, int, int, int, int, int, void *);
static int EDD_rw (int, int, u_int64_t, u_int32_t, void *);

d61 3
a63 5
	u_int8_t  edd_res1;  /* reserved */
	u_int8_t  edd_nblk;  /* # of blocks to transfer */
	u_int8_t  edd_res2;  /* reserved */
	u_int16_t edd_off;   /* address of buffer (offset) */
	u_int16_t edd_seg;   /* address of buffer (segment) */
d90 1
a90 1
	u_int rv, secl, sech;
d93 1
a93 1
	rv = biosdreset(dev);
d116 1
a116 1
		return (1);
d124 1
a124 16
	/*
	 * NOTE: This seems to hang on certain machines.  Use function #8
	 * first, and verify with #21 IFF #8 succeeds first.
	 * Do not try this for floppy 0 (to support CD-ROM boot).
	 */
	if (dev) {
		__asm __volatile (DOINT(0x13) ";setc %b0"
				: "=a" (rv), "=d" (secl), "=c" (sech)
				: "0" (0x15FF), "1" (dev), "2" (0xFFFF)
				: "cc");
		if (!(rv & 0xff00))
			return (1);
		if (rv & 0xff)
			return (1);
	}

a130 3
	 *
	 * Future hangs (when reported) can be "fixed"
	 * with getSYSCONFaddr() and an exceptions list.
d135 1
a135 1
		__asm __volatile(DOINT(0x13) "; setc %b0"
d137 2
a138 1
			 : "0" (0x4100), "b" (0x55aa), "d" (dev) : "cc");
d140 1
a140 1
			pdi->bios_edd = (bm & 0xffff) | ((rv & 0xff) << 16);
d145 3
d149 15
a163 1
	/* Sanity check */
d178 1
a178 1
CHS_rw(rw, dev, cyl, head, sect, nsect, buf)
d204 1
a204 1
static __inline int
d212 1
a212 5
	volatile static struct EDD_CB cb;

	/* Zero out reserved stuff */
	cb.edd_res1 = 0;
	cb.edd_res2 = 0;
a213 1
	/* Fill in parameters */
d216 1
a216 2
	cb.edd_seg = ((u_int32_t)buf >> 4) & 0xffff;
	cb.edd_off = (u_int32_t)buf & 0xf;
a218 6
	/* if offset/segment are zero, punt */
	if (!cb.edd_seg && !cb.edd_off)
		return (1);

	/* Call extended read/write (with disk packet) */
	BIOS_regs.biosr_ds = (u_int32_t)&cb >> 4;
d221 1
a221 1
			    "d" (dev), "S" ((int) (&cb) & 0xf) : "%ecx", "cc");
d229 4
a232 6
biosd_io(rw, bd, off, nsect, buf)
	int rw;
	bios_diskinfo_t *bd;
	daddr_t off;
	int nsect;
	void* buf;
a233 1
	int dev = bd->bios_number;
d237 7
d256 4
a259 1

d261 2
a262 27
	for (error = 1, j = 5; j-- && error;) {
		/* CHS or LBA access? */
		if (bd->bios_edd != -1) {
			error = EDD_rw(rw, dev, off, nsect, bb);
		} else {
			int cyl, head, sect;
			size_t i, n;
			char *p = bb;

			/* Handle track boundaries */
			for (error = i = 0; error == 0 && i < nsect;
 					i += n, off += n, p += n * DEV_BSIZE) {

				btochs(off, cyl, head, sect, bd->bios_heads, bd->bios_sectors);
				if ((sect + (nsect - i)) >= bd->bios_sectors)
					n = bd->bios_sectors - sect;
				else
					n = nsect - i;

				error = CHS_rw(rw, dev, cyl, head, sect, n, p);

				/* ECC corrected */
				if (error == 0x11)
					error = 0;
			}
		}
		switch (error) {
a276 1
	}
d289 1
a289 1
	return (error);
d303 1
d306 1
a306 1
	/* Sanity check */
d310 1
a310 1
	/* MBR is a harddisk thing */
d313 6
a318 2
		error = biosd_io(F_READ, bd, DOSBBSECTOR, 1, &mbr);
		if (error)
d348 2
a349 1
	error = biosd_io(F_READ, bd, off, 1, buf);
d558 1
d560 2
a561 3
	bios_diskinfo_t *bd = &dip->bios_info;
	u_int8_t error = 0;
	size_t nsect;
d568 22
a589 2
	/* Read all, sub-functions handle track boundaries */
	error = biosd_io(rw, bd, blk, nsect, buf);
d600 1
a600 1
		*rsize = nsect * DEV_BSIZE;
@


1.1.1.4
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.59 2003/06/27 05:13:19 weingart Exp $	*/
a48 1
int bios_bootdev;
d91 1
a91 1
	u_int rv;
d125 16
d151 1
a151 1
	if (dev & 0x80 && (dev == 0x80 || dev == 0x81 || dev == bios_bootdev)) {
@


1.1.1.5
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.60 2003/08/11 06:23:09 deraadt Exp $	*/
d73 2
a74 1
biosdreset(int dev)
d88 3
a90 1
bios_getdiskinfo(int dev, bios_diskinfo_t *pdi)
d164 4
a167 1
CHS_rw(int rw, int dev, int cyl, int head, int sect, int nsect, void *buf)
a169 1

d191 5
a195 1
EDD_rw(int rw, int dev, u_int64_t daddr, u_int32_t nblk, void *buf)
d227 6
a232 1
biosd_io(int rw, bios_diskinfo_t *bd, daddr_t off, int nsect, void *buf)
d313 3
a315 1
bios_getdisklabel(bios_diskinfo_t *bd, struct disklabel *label)
d517 2
a518 1
biosdisk_err(u_int error)
a545 1

d547 2
a548 1
biosdisk_errno(u_int error)
d561 7
a567 2
biosstrategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
    size_t *rsize)
d597 2
a598 1
biosclose(struct open_file *f)
d605 4
a608 1
biosioctl(struct open_file *f, u_long cmd, void *data)
@


1.1.1.6
log
@Import the last "new" OpenBSD boot loader code
reason: we've got to bump version number anyways...
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.61 2003/09/11 17:39:35 deraadt Exp $	*/
a141 7
			pdi->bios_edd = -1;

		/*
		 * If extended disk access functions are not supported
		 * there is not much point on doing EDD.
		 */
		if (!(pdi->bios_edd & 1))
@


1.1.1.7
log
@Whoops, they did it again... boot system changes
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.64 2003/09/18 08:24:11 fgsch Exp $	*/
a116 8
	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return(1);

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2)
		return(1);

d148 1
a148 1
		if (!(pdi->bios_edd & EXT_BM_EDA))
d153 8
d459 1
a459 3
		const char *st = bios_getdisklabel(&dip->bios_info,
		    &dip->disklabel);
#ifdef BIOS_DEBUG
d462 2
a463 6
#endif
		if (!st) {
			dip->bios_info.flags &= ~BDI_BADLABEL;
			dip->bios_info.flags |= BDI_GOODLABEL;
		} else
			return (ERDLAB);
@


1.1.1.8
log
@live import from NetzLaden.org: boot code from OpenBSD, again.
Rationale: test with broken BIOS (I've access to one here), and release.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.65 2003/09/19 04:17:00 fgsch Exp $	*/
d96 1
a96 1
		printf("getinfo: try #8, 0x%x, %p\n", dev, pdi);
a142 5

#ifdef BIOS_DEBUG
		if (debug)
			printf("getinfo: try #41, 0x%x\n", dev);
#endif
a151 6
#ifdef BIOS_DEBUG
		if (debug) {
			printf("getinfo: got #41\n");
			printf("disk 0x%x: 0x%x\n", dev, bm);
		}
#endif
@


1.1.1.9
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.66 2003/09/20 05:23:42 fgsch Exp $	*/
a116 6
	/* Fix up info */
	pdi->bios_number = dev;
	pdi->bios_heads++;
	pdi->bios_cylinders &= 0x3ff;
	pdi->bios_cylinders++;

d124 6
@


1.1.1.10
log
@some OpenBSD boot code sync (so I don't have to do it later)
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.67 2003/11/27 00:33:24 espie Exp $	*/
a182 1
	rw = rw == F_READ ? 2 : 3;
d197 1
a197 1
			    "m" (rw)
@


1.1.1.11
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.68 2004/03/09 19:12:12 tom Exp $	*/
d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
d60 7
a66 7
	u_int8_t  edd_len;	/* size of packet */
	u_int8_t  edd_res1;	/* reserved */
	u_int8_t  edd_nblk;	/* # of blocks to transfer */
	u_int8_t  edd_res2;	/* reserved */
	u_int16_t edd_off;	/* address of buffer (offset) */
	u_int16_t edd_seg;	/* address of buffer (segment) */
	u_int64_t edd_daddr;	/* starting block */
a75 1

d77 2
a78 3
	    : "0" (0), "d" (dev) : "%ecx", "cc");

	return ((rv & 0xff)? rv >> 8 : 0);
d99 7
a105 7
	    "setc %b0; movzbl %h1, %1\n\t"
	    "movzbl %%cl, %3; andb $0x3f, %b3\n\t"
	    "xchgb %%cl, %%ch; rolb $2, %%ch"
	    : "=a" (rv), "=d" (pdi->bios_heads),
	      "=c" (pdi->bios_cylinders),
	      "=b" (pdi->bios_sectors)
	    : "0" (0x0800), "1" (dev) : "cc");
d111 1
a111 1
		    pdi->bios_heads, pdi->bios_sectors);
d115 1
a115 1
		return 1;
d125 1
a125 1
		return 1;
d129 1
a129 1
		return 1;
d172 1
a172 1
	return 0;
d186 14
a199 14
	    "movb %b6, %%dh\n\t"
	    "andl $0xf, %4\n\t"
	    /* cylinder; the highest 2 bits of cyl is in %cl */
	    "xchgb %%ch, %%cl\n\t"
	    "rorb  $2, %%cl\n\t"
	    "orb %b5, %%cl\n\t"
	    "inc %%cx\n\t"
	    DOINT(0x13) "\n\t"
	    "setc %b0"
	    : "=a" (rv)
	    : "0" (nsect), "d" (dev), "c" (cyl),
	      "b" (buf), "m" (sect), "m" (head),
	      "m" (rw)
	    : "cc", "memory");
d201 1
a201 1
	return ((rv & 0xff)? rv >> 8 : 0);
d223 1
a223 1
		return 1;
d228 3
a230 3
	    : "0" ((rw == F_READ)? 0x4200: 0x4300),
	      "d" (dev), "S" ((int) (&cb) & 0xf) : "%ecx", "cc");
	return ((rv & 0xff)? rv >> 8 : 0);
d252 1
a252 1
			bcopy(buf, bb, nsect * DEV_BSIZE);
d257 1
a257 1
	for (error = 1, j = 5; j-- && error; ) {
d268 1
a268 4
			    i += n, off += n, p += n * DEV_BSIZE) {

				btochs(off, cyl, head, sect, bd->bios_heads,
				    bd->bios_sectors);
d270 1
d293 1
a293 1
				    error, biosdisk_err(error));
d301 1
a301 1
		bcopy(bb, buf, nsect * DEV_BSIZE);
d311 1
a311 1
	return error;
d326 2
a327 2
	if (bd->bios_heads == 0 || bd->bios_sectors == 0)
		return "failed to read disklabel";
d334 1
a334 1
			return (biosdisk_err(error));
d338 1
a338 1
			return "bad MBR signature\n";
d349 1
a349 2
					off = mbr.dmbr_parts[i].dp_start +
					    LABELSECTOR;
d352 1
a352 1
			return "no BSD partition\n";
d365 2
a366 2
	if (error)
		return "failed to read disklabel";
d377 1
a377 1
	dev_t maj, unit, part;
d400 2
a401 2
	for (maj = 0; maj < nbdevs && strncmp(*file, bdevs[maj], cp - *file); )
	    maj++;
d424 1
a424 1

d451 1
a451 1
		    B_CONTROLLER(bsd_dev), unit, part);
d453 1
a453 1
		    B_CONTROLLER(bsd_dev), B_UNIT(bsd_dev), part);
d464 2
a465 2
		    dip->bios_info.bios_heads, dip->bios_info.bios_sectors,
		    dip->bios_info.bios_edd);
d470 1
a470 1
	if (dip->bios_info.flags & BDI_BADLABEL){
d481 1
a481 1
			return ERDLAB;
d489 1
a489 1
const u_char bidos_errs[] =
d531 1
a531 1
		while (*p++);
d549 1
a549 1
	{ 0x20, EHER },
d560 1
a560 1
	if (error == 0)
d596 1
a596 1
	return (biosdisk_errno(error));
a602 1

d611 1
@


