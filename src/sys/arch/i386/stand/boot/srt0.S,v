head	1.26;
access;
symbols
	tg-mergetmp-mirosx-1:1.26
	tg-mergefixes-1-branch:1.26.0.4
	tg-mergefixes-1-base:1.26
	MIROS_X:1.26.0.2
	MIROS_X_BASE:1.26
	tg-mergetmp-3:1.26
	MIRBSD_XP_MIRPPC:1.25.0.4
	MIRBSD_XP_SPARC_BASE:1.25
	MIRBSD_XP_SPARC:1.25.0.2
	MIRBSD_7quater:1.1.1.4
	cvs-200405160640:1.1.1.5
	cvs-200401271800:1.1.1.5
	cvs-200401261630:1.1.1.5
	cvs-200401021645:1.1.1.5
	MIRBSD_7_ALPHA:1.1.1.4.0.6
	MIRBSD_7:1.1.1.4.0.4
	cvs-200312222040:1.1.1.5
	cvs-200312171912:1.1.1.5
	MIRBSD_7ter:1.1.1.4
	MIRBSD_7_DEV:1.1.1.4.0.2
	cvs-200310020700:1.1.1.4
	cvs-200309271030:1.1.1.4
	cvs-200309261655:1.1.1.4
	cvs-200309251530:1.1.1.4
	cvs-200309192030:1.1.1.4
	cvs-200309181930:1.1.1.4
	cvs-200309131952:1.1.1.4
	cvs-200308302005:1.1.1.4
	cvs-200308221505:1.1.1.4
	cvs-200308171200:1.1.1.4
	ctm-3496:1.1.1.4
	ctm-3449:1.1.1.4
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	cvs-200307072125:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200307021520:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.3
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	ctm-3255:1.1.1.2
	ctm-3229:1.1.1.2
	MIRBSD_4:1.2
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.26
date	2004.12.05.13.25.35;	author tg;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.07.21.18.36;	author tg;	state Stab;
branches;
next	1.24;

1.24
date	2004.03.05.22.01.59;	author tg;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.26.21.59.37;	author tg;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.21.22.07.53;	author tg;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.21.19.52.16;	author tg;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.21.19.28.22;	author tg;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.21.17.36.32;	author tg;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.19.21.07.26;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.19.20.58.29;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.19.20.03.41;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.19.19.18.27;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.19.18.52.44;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.19.18.31.37;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.19.16.51.28;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.11.21.51.50;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.01.18.49.38;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.14.22.23.34;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.14.20.49.43;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.09.12.54.23;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.31.23.14.56;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.31.22.05.35;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.31.21.20.16;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.30.13.18.44;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.52.17;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.49.37;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.49.37;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.24.09.05.38;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.34.27;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.29.17.29.42;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.17.19.13.21;	author tg;	state Exp;
branches;
next	;


desc
@@


1.26
log
@* replace all occurences of old eMail addresses of mine
  with their more recent counterparts
* no $Log keyword!
* update licence template to most recent version in files touched
* in some places, don't add our own licence boilerplate, just
  add my name to the others
* make dev/rndvar.h suitable for inclusion in asm code
* include dev/rndvar.h by in_cksum.s instead of
  hardcoding pool size
* ENTRY(a); ENTRY(b) -> NENTRY(a); ENTRY(b)
* RCS IDs belong into .comment not .text
@
text
@/**	$MirBSD: src/share/misc/licence.template,v 1.20 2004/12/03 16:18:37 tg Rel $ */

/*-
 * Copyright (c) 2003, 2004
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * All advertising materials mentioning features or use of this soft-
 * ware must display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
 *-
 * Initialisation code for second-stage or stand-alone boot loader.
 *
 * This code is responsible for:
 * - setting up a known environment, with no knowledge about current
 *   CPU state (except that we are in real mode and DL is the BIOS
 *   boot device)
 * - relocate ourselfes to a known sane location (0x4000:0x0120)
 * - checking if we're called from an El Torito bootable CD-ROM via
 *   the BIOS, or from a PBR, or from within MS-DOS, and take
 *   appropiate set-up action
 * - for El Torito, load in the full boot code again, as we cannot
 *   guarantee that faulty BIOSes load more than the first 2048 bytes
 * - if faulty BIOS makes problems, use the table which can be written
 *   with 'mkisofs -no-emul-boot -boot-load-size 4 -boot-info-table'
 *   into the image to locate start of the boot file; always load 64K
 * - set up some variables, load GDT, set up protected mode and
 *   jump into C code
 */

#include <machine/asm.h>
#include <assym.h>

	.intel_syntax noprefix
	.text
	.code16

/* It's hard to fight vs. broken BIOSes */
#ifdef	UTEST
#ifdef	UHARD
#define	UD(x)	push bp; mov bp,(0x4040 + x); \
		gs mov [(0x0C80 + (2 * x))], bp; pop bp; \
		push ax; xor ax,ax; int 0x16; pop ax
#ifdef	UANAL
#define	UDX(x)	push bp; mov bp,(0x0940 + x); \
		gs mov [0x0C80], bp; pop bp; \
		push ax; xor ax,ax; int 0x16; pop ax
#else	/* UTEST, UHARD, not UANAL */
#define	UDX(x)	/* nothing */
#endif	/* UTEST, UHARD, not UANAL */
#else	/* UTEST, not UHARD */
#define	UD(x)	push bp; mov bp,(0x4040 + x); \
		gs mov [(0x0C80 + (2 * x))], bp; pop bp
#ifdef	UANAL
#define	UDX(x)	push bp; mov bp,(0x0940 + x); \
		gs mov [0x0C80], bp; pop bp
#else	/* UTEST, not UHARD, not UANAL */
#define	UDX(x)	/* nothing */
#endif	/* UTEST, not UHARD, not UANAL */
#endif	/* UTEST, not UHARD */
#define	UD32(x)	mov ebx,(0xB8A00 + (2 * x)); \
		mov word ptr [ebx],(0x4040 + x)
#else	/* not UTEST */
#define	UD(x)	/* nothing */
#define	UD32(x)	/* nothing */
#define	UDX(x)	/* nothing */
#endif	/* not UTEST */

	.globl	Gdtr
	.globl	_C_LABEL(_rtt)
	.globl	_rval
	.globl	_start
	.globl	_C_LABEL(bios_bootdev)
	.globl	_C_LABEL(boot)
	.globl	_C_LABEL(edata)
	.globl	_C_LABEL(end)
	.globl	_ASM_LABEL(pmm_init)
	.globl	_C_LABEL(tori_bootflag)
	.globl	_C_LABEL(tori_pblk)

_start:	cli
	jmp	_star2
	. = _start + 0x08	/* "EL TORITO BOOT INFO TABLE" */
	.long	0		/* filled in by mkisofs: */
Lbofs:	.long	0xcafebabe	/* LBA address of boot file */
	. = _start + 0x40
_star2:	mov	bx,SA_LOADSEG
	mov	ss,bx
	mov	esp,0xC0
	sti
	push	dx
	call	Linit
_rval:	.ascii	"\03Omi"	/* _start + 0x50 */
Linit:	pop	di
	mov	ax,0xB800
	mov	gs,ax		/* for UD() */
	UD(0)			/** @@: we're here */
	mov	ax,bx
	add	ah,0x10		/* add 64K (apparent max. code size) */
	push	ax		/* future SS */
	add	ah,0x10		/* add that 64K for a safe buffer */
	mov	fs,ax		/* for buffer I/O */
	xor	eax,eax
	push	eax
	popfd
	UD(1)			/** A: flags set */
	mov	ax,di
	and	ax,0x000F	/* test for alignment */
Lirrf:	jnz	Lirrf		/* forever loop */
	mov	ax,di
	shr	ax,4
	mov	cx,cs
	add	ax,cx		/* ax:0000 is now _start+0x50 */
	mov	cx,ax
	sub	cx,RL_VAL
	cld
	xor	si,si
	UD(2)			/** B: alignment okay */
	cmp	cx,bx		/* bx is still SA_LOADSEG */
	je	LisRel		/* already relocated */
	jnb	LdoRel		/* loaded above target address */
	UD(3)			/** C: below target */
	std
	dec	si		/* loaded below target addr, go backwards */
LdoRel:	UD(4)			/** D: doing reloc */
	xor	cx,cx
	dec	cx
	mov	di,si
	sub	ax,5		/* make up for stuff above _rval */
	mov	ds,ax
	add	bx,RL_VAL
	sub	bx,5		/* dito */
	mov	es,bx
	rep	movsb
LisRel:	UD(5)			/** E: done reloc, or not needed */
	cld
	jmp	SA_LOADSEG,offset Lstart

/*
 * Stuff which MUST NOT be placed in the .bss section
 */

_C_LABEL(tori_bootflag):
	.long	0
_C_LABEL(tori_pblk):
Ltblk:	.long	0x13,0,0,0	/* El Torito parameter block */
	.byte	0,0,0
Lbdev:	.byte	0		/* local copy of BIOS boot device */
Llba:	.word	0x0010		/* LBA parameter block */
	.word	0x0001
	.long	0,0,0

/*
 * Code which can assume sane location
 */

Lstart:	UD(6)			/** F: jump successful */
	pop	ax		/* saved future stack base */
	pop	dx		/* saved BIOS drive */
	mov	ss,ax
	mov	sp,0xFFFC	/* another nearly-64K for stack */
	mov	ax,cs
	mov	ds,ax
	mov	es,ax
	mov	[Lbdev],dl
#ifdef	EXTRALOUD
	call	L..e1
	.asciz	"00 at DL\r\n"
L..e1:	mov	al,dl
	pop	si
	mov	di,si
	call	LpBY
	call	Lotxt
#endif
#ifdef	LOUD
	mov	si,offset Lsrt0
	call	Lotxt
#endif
#ifdef	DEBUG_OFS
	mov	[Lofsd],esi
#endif

#ifdef	WANT_ELTORITO_CHECK
	/* check for El Torito */
	mov	ax,0x4B01
	mov	si,offset Ltblk
	int	0x13
#ifdef	EXTRALOUD
	pushf
	pusha
	pushf
	call	L..e2
	.ascii	"Load SPEC returned, DL = "
L..e21:	.ascii	"00; CF="
L..e22:	.ascii	"00; [SI+2]="
L..e23:	.asciz	"00\r\n"
L..e2:	xor	ax,ax
	pop	bp
	popf
	adc	al,0
	mov	di,offset L..e22
	call	LpBY
	mov	al,dl
	mov	di,offset L..e21
	call	LpBY
	mov	al,[si+2]
	mov	di,offset L..e23
	call	LpBY
	mov	si,bp
	call	Lotxt
	popa
	popf
#endif
	jc	LnoCD
	UD(7)			/** G: El Torito found */
	xor	eax,eax
	dec	eax
	mov	al,dl
	mov	[_C_LABEL(tori_bootflag)],eax

	/*
	 * now we have to find out where on the CD-ROM the bootable
	 * image is located (looking for "default" image)
	 */

	/* get boot record */
	mov	eax,0x11
	call	LcdLDS		/* loads to FS:0x0000 */
	UD(8)			/** H: boot record loaded */
	fs mov	eax,[0]
	cmp	eax,0x30444300	/* '\0CD001' magic */
	jne	LbmCD		/* bad magic CD */

	/* get boot catalogue */
	fs mov	eax,[0x47]
	call	LcdLDS
	UD(9)			/** I: boot catalogue loaded */
	fs mov	ax,[0]
	dec	ax
	jne	LbmCD
	fs mov	ax,[0x1E]
	cmp	ax,0xAA55
	jne	LbmCD
	fs mov	ax,[0x20]
	cmp	ax,0x0088	/* no emulation, default entry */
	jne	LbmCD
	fs mov	eax,[0x28]	/* address */
	UD(10)			/** J: boot image found, no fake */
#else	/* not WANT_ELTORITO_CHECK */
	jmp	LnoCD
#endif	/* not def WANT_ELTORITO_CHECK */

LisCD:	mov	bx,SA_LINKSEG	/* target segment */
	inc	eax		/* don't load the first sector again */
	add	bx,0x80		/* 2048 bytes in paragraphs */
	UDX(2)
	mov	byte ptr [2+Llba],31	/* we don't load more anyways */
	push	fs
	mov	fs,bx
	call	LcdLDS
	UDX(3)
	pop	fs
	UD(11)			/** K: boot image loaded */
#ifdef	DEBUG_OFS
	mov	eax,[Lofsd]
	cmp	eax,0xfeedcafe
	je	L..37
	UD(37)			/** e: magic check failed */
#ifdef	LOUD
	call	L..37a
	.asciz	"Load magic failed!\r\nPress a key to reboot..."
L..37a:	pop	si
	call	Lotxt
#endif
	xor	ax,ax
	int	0x16
	jmp	0xF000,0xFFF0
#endif
L..37:	jmp	LpreCD		/* prepare boot from CD */

#ifdef	LOUD
Lotxt:	lodsb
	or	al,al
	je	Lretn
	mov	ah,0x0E
	mov	bx,7
	int	0x10
	jmp	Lotxt

Lsrt0:	.ascii	"MirOS boot v"
	.ascii	__BOOT_VER
	.asciz	" srt0 initialising\r\n"
#endif

LcdLDS:	pusha
	push	eax
	UDX(4)
#ifdef	EXTRALOUD
	pusha
	call	L..e3
	.ascii	"called LDS at LBA="
L..e31:	.ascii	"00000000 DL="
L..e32:	.ascii	"00 #="
L..e33:	.asciz	"0000 "
L..e3:	mov	di,offset L..e31
	call	LpDW
	mov	al,dl
	pop	si
	mov	di,offset L..e32
	call	LpBY
	mov	di,offset L..e33
	mov	ax,[2+Llba]
	call	LpWO
	call	Lotxt
	popa
	pop	eax
	push	eax
#endif
	xor	bp,bp
	mov	[8+Llba],eax	/* block number */
	mov	ax,fs
	mov	[6+Llba],ax	/* transfer address */
LcdLD0:	mov	ah,0x42
	mov	si,offset Llba
	int	0x13
#ifdef	UANAL
	pushf
	UDX(5)
	popf
#endif
	jc	LcdLD1
	UDX(6)
	pop	eax
	popa
Lretn:	ret
LcdLD1:	pusha
	UDX(33)
	xor	ah,ah
	int	0x13
	mov	ax,0x0E40
	mov	bx,7
	int	0x10
	popa
	inc	bp
	cmp	bp,5
	jb	LcdLD0
	UDX(34)
	UD(33)			/** a: CD read failed */
	/* FALL-THROUGH */

LbmCD:	UD(34)			/** b: CD bad magic */
#ifdef	LOUD
	call	L..34
	.asciz	"Bad Magic reading from CD\r\n"
L..34:	pop	si
	call	Lotxt
#endif
	xor	eax,eax		/* reset to default floppy boot */
	mov	[_C_LABEL(tori_bootflag)],eax
	/* FALL-THROUGH */

LnoCD:	mov	ebp,0xcafebabe	/* kludge! */
	mov	eax,ebp
	xchg	eax,[Lbofs]	/* only once */
	cmp	eax,ebp
	je	L..12
	push	eax
	UD(36)			/** d: attention fake torito */
#ifdef	LOUD
	call	L..36
	.asciz	"Attention: faking El Torito boot!\r\n"
L..36:	pop	si
	call	Lotxt
#endif
	UDX(1)
	mov	dl,[Lbdev]
	xor	eax,eax
	dec	eax
	mov	al,dl
	mov	[_C_LABEL(tori_bootflag)],eax
	mov	[2+Ltblk],al
	mov	ax,0x07C0
	mov	[12+Ltblk],ax
	mov	ax,32
	mov	[14+Ltblk],ax
	pop	eax
	mov	[4+Ltblk],eax
	jmp	LisCD		/* and be it the devil */

	/* "real" floppy boot */
L..12:	UD(12)			/** L: floppy boot */
#ifdef	LOUD
	call	LdebFD		/* debug msgs */
#endif
	jmp	LpreFD

LpreCD:	UD(13)			/** M: cd-rom boot */
#ifdef	LOUD
	call	LdebCD		/* debug msgs */
#endif
	/* FALL-THROUGH */

LpreFD:	/* prepare booting */
	UD(14)			/** N: preparing 32-bit */
	xor	edx,edx
	mov	dl,[Lbdev]	/* carry this over to VPAM */
	cli
	addr32 data32 lgdt (Gdtr - SA_LOADADDR)
	mov	ax,1
	lmsw	ax		/* switch to protected mode */
	data32 jmp 8,offset Lpmode

#ifdef	LOUD
	/*
	 * debugging routines for LOUD mode
	 */
LiscdM:	.ascii	"CD Drive "			/* drive no */
Liscd0:	.ascii	"00 on "			/* load seg */
Liscd1:	.ascii	"0000:0000, "			/* sectors  */
Liscd2:	.ascii	"0000 sectors starting at "	/* img offs */
Liscd3:	.asciz	"00000000 LBA\r\n"
LisfdM:	.ascii	"BIOS Drive "			/* bootdev */
Lisfd0:	.asciz	"00 initialized.\r\n"

LdebFD:	/* debug message for floppy/hdd boot */
	mov	al,[Lbdev]
	mov	di,offset Lisfd0
	call	LpBY
	mov	si,offset LisfdM
	jmp	Lotxt

LdebCD:	/* debug message for El Torito boot */
	mov	di,offset Liscd0
	mov	al,[Lbdev]
	call	LpBY
	mov	di,offset Liscd1
	mov	ax,[12+Ltblk]
	call	LpWO
	mov	di,offset Liscd2
	mov	ax,[14+Ltblk]
	call	LpWO
	mov	di,offset Liscd3
	mov	eax,[4+Ltblk]
	call	LpDW
	mov	si,offset LiscdM
	jmp	Lotxt

/* the formatting routines */

LpDW:	push	eax
	shr	eax,16
	call	LpWO
	pop	eax
	/* fall-through */
LpWO:	push	ax
	xchg	ah,al
	call	LpBY
	pop	ax
	/* fall-through */
LpBY:	mov	ah,al
	and	ah,0x0F
	shr	al,4
	add	ax,0x3030
	cmp	al,0x39
	jna	4f
	add	al,7
4:	cmp	ah,0x39
	jna	5f
	add	ah,7
5:	stosw
	ret
#endif

	/*
	 * 32-bit code in 16-bit code segment
	 * attention when adding code fragments below!
	 */

	.code32
Lpmode:	mov	eax,0x10
	mov	ss,ax
	mov	esp,0x0000FFFC
	mov	es,ax
	mov	ds,ax
	mov	fs,ax
	mov	gs,ax
	push	edx
	UD32(15)		/** O: 32-bit reached */
	call	_ASM_LABEL(pmm_init)
	UD32(16)		/** P: PMM initialised */
	/* zero out .bss section */
	xor	eax,eax
	mov	ecx,offset _C_LABEL(end)
	mov	edi,offset _C_LABEL(edata)
	sub	ecx,edi
	push	ecx
	shr	ecx,2
	cld
	rep	stosd
	pop	ecx
	and	ecx,0x00000003
	rep	stosb
	/* store saved BIOS boot device */
	mov	[_C_LABEL(bios_bootdev)],edx
	UD32(17)		/** Q: jump into C code */
	/* jump into boot loader C code */
	call	_C_LABEL(boot)
	UD32(35)		/** c: return from C code */
	jmp	_C_LABEL(_rtt)

#ifdef	DEBUG_OFS
	. = _start + 0x0900
Lofsd:	.long	0xfeedcafe	/* just another bad magic */
#endif

	/*
	 * End of File. Attention, 32-bit mode!
	 */
@


1.25
log
@small warnings fixup
@
text
@d1 5
a5 4
/* $MirBSD: srt0.S,v 1.24 2004/03/05 22:01:59 tg Exp $
 *-
 * Copyright (c) 2003
 *	Thorsten Glaser <x86@@ePost.de> for the MirOS Project
d7 6
a12 6
 * Subject to these terms, everybody who obtained a copy of this work
 * is hereby permitted to deal in the work without restriction inclu-
 * ding without limitation the rights to use, distribute, sell, modi-
 * fy, publically perform, give away, merge or sublicence it provided
 * this notice is kept and the authors and contributors are given due
 * credit in derivates or accompanying documents.
d14 11
a24 5
 * This work is provided "as is" with no explicit or implicit warran-
 * ties whatsoever to the maximum extent permitted by applicable law;
 * in no event may an author or contributor be held liable for damage
 * that is, directly or indirectly, caused by the work, even if advi-
 * sed of the possibility of such damage.
@


1.24
log
@a) I've actually encountered a PC with a BIOS which, when
   probing El Torito, overwrites the boot loader!
b) It didn't work for some time now

-> disable El Torito check, and, with that, CD boot (almost)
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.23 2003/12/26 21:59:37 tg Exp $
d256 3
a286 3
#else	/* not WANT_ELTORITO_CHECK */
	jmp	L..12
#endif	/* not def WANT_ELTORITO_CHECK */
a368 1
#ifdef	WANT_ELTORITO_CHECK
a395 1
#endif	/* def WANT_ELTORITO_CHECK */
@


1.23
log
@adjust with recent changes; v2.65 compiles and runs fine
even on wbx@@s crappy lent notebook
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.22 2003/12/21 22:07:53 tg Exp $
d190 1
d284 3
d369 1
d397 1
@


1.22
log
@ > > >                #######   ###    #####  #     # #######   ###
 > > >                #          #    #     # #     #    #      ###
 > > >                #          #    #       #     #    #      ###
 > > >                #####      #    #  #### #######    #       #
 > > >                #          #    #     # #     #    #
 > > >                #          #    #     # #     #    #      ###
 > > >                #         ###    #####  #     #    #      ###


                        \   /   ,---.
     mirabile            \ /    `--_          broken BIOS
                          V     -__-'  o


               #####   #####  ####### ######  #######    #
              #     # #     # #     # #     # #         ###
              #       #       #     # #     # #          #
               #####  #       #     # ######  #####
                    # #       #     # #   #   #          #
              #     # #     # #     # #    #  #         ###
               #####   #####  ####### #     # #######    #


       *****                                     *****
      *     *                                   *     *
            *                                         *
       *****                                     *****
            *                                   *
      *     *                                   *
       *****                                    *******


    %    %     %    %%%%%     %%    %%%%%      %    %       %%%%%%
    %%  %%     %    %    %   %  %   %    %     %    %       %
    % %% %     %    %    %  %    %  %%%%%      %    %       %%%%%
    %    %     %    %%%%%   %%%%%%  %    %     %    %       %
    %    %     %    %   %   %    %  %    %     %    %       %
    %    %     %    %    %  %    %  %%%%%      %    %%%%%%  %%%%%%


    %   %           %    %     %    %    %   %%%%           %   %
     % %            %    %     %    %%   %  %                % %
   %%%%%%%          %    %     %    % %  %   %%%%          %%%%%%%
     % %            % %% %     %    %  % %       %           % %
    %   %           %%  %%     %    %   %%  %    %          %   %
                    %    %     %    %    %   %%%%



The new bootloader code works on CD-R, hard disc and MS-DOS in real broken
hardware, as well as on CD ISO in bochs.
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.21 2003/12/21 19:52:16 tg Exp $
a221 3
	mov	al,[2+Ltblk]
	mov	[Lbdev],al
	mov	dl,al
@


1.21
log
@popping more is always good - if you pushed something hard enough, that is ;-)
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.20 2003/12/21 19:28:22 tg Exp $
d45 1
d48 2
a49 2
#define	UD(x)	mov bp,(0x4040 + x); \
		gs mov [(0x0C80 + (2 * x))], bp; \
d52 2
a53 2
#define	UDX(x)	mov bp,(0x0940 + x); \
		gs mov [0x0C80], bp; \
d59 2
a60 2
#define	UD(x)	mov bp,(0x4040 + x); \
		gs mov [(0x0C80 + (2 * x))], bp
d62 2
a63 2
#define	UDX(x)	mov bp,(0x0940 + x); \
		gs mov [0x0C80], bp
d73 1
d96 1
a96 1
	mov	esp,0x120
d107 1
a107 4
	pop	dx
	mov	ss,ax
	mov	sp,0xFFFC	/* another nearly-64K for stack */
	push	dx
d165 1
d167 2
d257 1
a257 5
LisCD:	UD(10)			/** J: boot image found */

	/* get image, sector by sector, 64K in total, skip first sector */
	mov	dh,31		/* number of sectors to load in total */
	mov	bx,SA_LINKSEG	/* target segment */
d259 2
a260 2
LgimCD:	/* increment the numbers */
	inc	eax
d263 3
a265 1
	/* load */
d267 2
a268 17
	UDX(6)
	/* move */
	push	ds
	push	es
	push	fs
	pop	ds
	mov	es,bx
	mov	cx,0x200	/* 2048 bytes in doublewords */
	xor	si,si
	xor	di,di
	rep	movsd
	pop	es
	pop	ds
	UDX(7)
	dec	dh
	jne	LgimCD		/* loop */
	UDX(8)
d303 1
a303 1
	UDX(3)
d309 2
a310 1
L..e32:	.asciz	"00        "
d317 3
d328 1
a328 1
	mov	[6+Llba],ax	/* transfer address (segment) */
d334 1
a334 1
	UDX(4)
d338 1
a338 1
	UDX(5)
@


1.20
log
@various improvements and anal debugging helpers
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.19 2003/12/21 17:36:32 tg Exp $
d50 8
a57 1
#else
d60 7
a66 1
#endif
d69 1
a69 1
#else
d72 1
a72 1
#endif
d264 1
d267 1
d280 1
d283 1
d317 2
d333 2
d343 5
d349 2
d354 1
d364 1
d392 1
@


1.19
log
@increase stack from 0x120 to 64K
add some more checkpointing

no (real) functional changes yet
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.18 2003/12/19 21:07:26 tg Exp $
d31 3
d83 1
a83 1
	nop
d92 1
d95 1
a97 1
	push	dx
d141 1
a141 1
Ltblk:	.long	0,0,0,0		/* El Torito parameter block */
d158 9
d179 26
a205 3
	mov	ax,[12+Ltblk]
	or	ax,ax
	je	LnoCD
d300 15
d354 1
a361 1
	push	eax
d367 7
d423 1
a423 1
	mov	ax,[12+_C_LABEL(tori_pblk)]
d426 1
a426 1
	mov	ax,[14+_C_LABEL(tori_pblk)]
d429 1
a429 1
	mov	eax,[4+_C_LABEL(tori_pblk)]
d499 1
a499 1
Lofsd:	.long	0xfeedcafe
@


1.18
log
@fix relocating and repeating issue
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.17 2003/12/19 20:58:29 tg Exp $
a83 1
	push	dx
d88 4
a91 1
	add	ax,0x1800	/* add 96K to us for a safe buffer */
d93 1
d158 3
d232 16
a247 1
	jmp	LpreCD		/* prepare boot from CD */
d438 5
@


1.17
log
@kludge around more, making use of an option of mkisofs to
write the information table into the boot image itself;
idea seen at various other ISO boot places.

Now it comes until the switch into protected mode on my
machine. This is where I'll stop for now.
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.16 2003/12/19 20:03:41 tg Exp $
d117 1
d120 1
d277 4
a280 3
LnoCD:	xor	eax,eax
	xchg	eax,[Lbofs]
	cmp	eax,0xcafebabe	/* kludge! */
@


1.16
log
@some "spelling" fixes, cosmetics etc.
including minor corrections
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.15 2003/12/19 19:18:27 tg Exp $
d60 1
d71 6
a76 1
	mov	bx,SA_LOADSEG
d80 1
d82 1
a82 2
	. = _start + 0x10
	.ascii	"\03Omi"
d101 1
a101 1
	add	ax,cx		/* ax:0000 is now _start+0x10 */
d198 1
a198 1
	UD(10)			/** J: boot image found */
d275 21
a295 1
LnoCD:	UD(12)			/** L: floppy boot */
@


1.15
log
@Now that it works[0], remove debugging

[0]: ms-dos on real hardware, floppy and hdd and cd on bochs
     cd on real broken hardware just reboots, that's why
     I'll test with -DUHARD now.
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.14 2003/12/19 18:52:44 tg Exp $
d126 1
a126 1
Lblk:	.long	0,0,0,0
d128 2
a129 3
Lbootdv:
	.byte	0	/* local copy of BIOS boot device */
Llba:	.word	0x0010
d142 1
a142 1
	mov	[Lbootdv],dl
d150 1
a150 1
	mov	si,offset Lblk
d153 1
a153 1
	mov	ax,[12+Lblk]
d157 2
a158 2
	mov	al,[2+Lblk]
	mov	[Lbootdv],al
d172 1
a172 1
	call	LcdLDS		/* loads to GS:0x0000 */
d255 1
a255 1
	UD(97)			/** a: CD read failed */
d258 1
a258 1
LbmCD:	UD(98)			/** b: CD bad magic */
d260 1
a260 1
	call	L..98
d262 1
a262 1
L..98:	pop	si
d284 1
a284 1
	mov	dl,[Lbootdv]	/* carry this over to VPAM */
d304 1
a304 1
	mov	al,[Lbootdv]
d312 2
a313 1
	call	LpBY		/* prereq: al=[Lbootdv] */
d386 1
a386 1
	UD32(99)		/** c: return from C code */
@


1.14
log
@With a few simple thinko fixes, this does work indeed.
Tested:
 * bochs, floppy
 * bochs, CD-ROM
To be tested:
 * bochs, HDD
 * hardware, CD-ROM
 * bochs, MS-DOS
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.13 2003/12/19 18:31:37 tg Exp $
d43 5
d50 1
d95 1
a95 1
	or	ax,cx		/* ax:0000 is now _start+0x10 */
@


1.13
log
@new, self-relocatable, self-loading init code for /boot
works on floppy in bochs (tested)
@
text
@d1 1
a1 1
/* $MirBSD: licence.template,v 1.8 2003/12/17 14:35:00 tg Exp $
d44 1
a44 1
		gs mov [(0x0A00 + (2 * x))], bp
d205 2
@


1.12
log
@current bootstrap tree:
 * debugging is on for (current, to be replaced) srt0.S
 * /boot works
 * dosboot.com goes away, /boot will be a MS-DOS .COM compatible
   programme soon enough, and so nobody tries to load a kernel
   from msdosfs right now (though that might come as well)
 * booting from floppy in bochs works (tested)
 * pbr_ffs is incompatible with prior versions, because /boot
   now comes as binary, not ELF32 file
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.11 2003/12/11 21:51:50 tg Exp $
d4 1
a4 1
 *	Thorsten Glaser <x86@@ePost.de>, for the MirOS Project
d9 1
a9 1
 * fy, publically perform, give away, merge or sublicense it provided
d14 1
a14 1
 * ties whatsoever to the maximum extend permitted by applicable law;
d19 1
a19 1
 * Second Stage or El Torito "No Emulation" Boot Loader initialisation code
d21 12
a32 12
 * This code checks if it's booted from a CD-ROM drive via the
 * El Torito BIOS specification. If errors occur or the result
 * is negative, it assumes it is being loaded from a floppy or
 * hard disc drive.
 * Then it sets up protected mode and jumps into the main boot
 * loader C code.
 *
 * It is planned to add functions to "chain" to another CD-ROM
 * El Torito boot image, which are callable from the MD C code
 * then.
 *
 * With apologies to Michael Shalayeff and Linus Torvalds.
d39 1
d41 11
d62 1
d64 2
a65 2
	mov	ax,SA_LOADSEG
	mov	ss,ax
d69 1
d71 9
a79 1
Linit:	xor	eax,eax
d82 29
d114 16
a129 3
 * Routine for outputting debug messages, formatting bytes or words
 * into ASCII, and the messages itself. Only compiled in if LOUD is
 * defined, due to size constraints (<56 kB).
d132 81
d216 1
a216 1
	je	Lotxt0
d218 1
a218 1
	mov	bx,0x0007
a220 1
Lotxt0:	ret
d222 1
a222 2
Lfail:	.asciz	"CD/BIOS boot failed. Press a key to reboot..."
Lsrt0:	.ascii	"MirOS boot(8) "
d224 64
a287 2
	.asciz	" srt0 initializing\r\n"
Lerrc:	.asciz	"warning: returned CY\r\ncontinuing..."
d344 4
a347 14
/*
 * Stuff which MUST NOT be placed in the .bss section
 */
_C_LABEL(tori_bootflag):
	.long	0
_C_LABEL(tori_pblk):
	.long	0,0,0,0
	.byte	0,0,0
Lbootdv:
	.byte	0	/* local copy of BIOS boot device */

/*
 * 16-bit initialisation code
 */
a348 70
Lstart:	sti
	mov	ax,cs
	mov	ds,ax
	mov	es,ax
	mov	[Lbootdv],dl
	call	Lgenv
	jnc	Lboot
#ifdef	LOUD
	mov	si,offset Lfail
	call	Lotxt
#endif
	xor	ah,ah
	int	0x16
	int	0x19
	jmp	0xF000,0xFFF0
	/* NOTREACHED */

Lgenv:	/* say hello */
#ifdef	LOUD
	mov	si,offset Lsrt0
	call	Lotxt
#endif
	/* get El Torito parameter block */
	mov	ax,0x4B01
	mov	si,offset _C_LABEL(tori_pblk)
	int	0x13
	jnc	Lckcd
#ifdef	LOUD
	mov	si,offset Lerrc
	call	Lotxt
#endif
	jmp	Lnocd
Lckcd:	/* kludgy test if it's really a CD device */
	mov	ax,[12+_C_LABEL(tori_pblk)]
	or	ax,ax
	je	Lnocd	/* no load segment */
	/* we're hooked up on our CD drive now */
	mov	al,[2+_C_LABEL(tori_pblk)]
	mov	[Lbootdv],al
#ifdef	LOUD
	/* print out debug message */
	call	LdebCD
#endif
	xor	eax,eax
	dec	eax
	mov	al,[Lbootdv]
	mov	[_C_LABEL(tori_bootflag)],eax
	clc
	ret

Lnocd:	/* floppy or hard disc, BIOS device */
#ifdef	LOUD
	/*print out debug message */
	call	LdebFD
#endif
	xor	eax,eax
	mov	[_C_LABEL(tori_bootflag)],eax
	clc
	ret

/*
 * 32-bit initialisation and system boot
 */
Lboot:	xor	edx,edx
	mov	dl,[Lbootdv]	/* carry over to VPAM32 */
	cli
	addr32 data32 lgdt (Gdtr - SA_LOADADDR)
	mov	ax,1
	lmsw	ax		/* protected mode ON */
	data32 jmp 8,offset Lpmode
d358 1
d360 1
d369 1
a369 2
	rep
	stosd
d372 1
a372 2
	rep
	stosb
d375 1
d378 1
d380 4
@


1.11
log
@don't assume a sane BIOS which sets up the stack correctly
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.10 2003/12/01 18:49:38 tg Exp $
d51 1
a51 1
	mov	ax,cs
d53 5
a57 3
	mov	sp,0x120
	/* clean up fully */
	xor	eax,eax
a59 3
	mov	ax,SA_LOADSEG
	mov	ss,ax
	mov	esp,0x120
d155 1
d159 1
a159 1
	call	Linit
d171 1
a171 1
Linit:	/* say hello */
@


1.10
log
@The boot loader seems to have been broken since the MirOS #7 releases.
Apologies to Jannis Konrad for blaming on his (nevertheless
totally broken) hardware. Thanks to Bill Gates and his company
for writing DEBUG.COM which allowed me to get into my system
again, since it apparently can't boot our /boot from CD-ROM
(this is still not fixed, but it's fine in bochs, and my box
 doesn't even get as far as the Lsrt0 message,
	MirOS boot(8) 2.54 srt0 initializing
 when booting from CD, so it must be broke too).

While here, rewrite several chunks of the code, and extend the
size of the argv[] array for boot commands to make echo work.

Tested:
 bochs CD passed
 mybox CD failed
 mybox HD passed
 mybox MS-DOS passed
@
text
@d1 1
a1 1
/* $MirBSD: licence.template,v 1.7 2003/12/01 16:18:24 tg Exp $
d50 6
a55 1
_start:	xor	eax,eax
@


1.9
log
@bump version number and shrink displaying layout a bit
we're almost there: it can boot a kernel from CD and floppy,
although it only succeeded for bsd.gz (ramdiskM) and bsd.rd.gz (ramdisk_cd)
plus, it only handles 8.3 filenames

while here: don't come back into timeout mode if cmd boot fails

status:
 * boots fd1a:/bsd if loaded from fd0
 * boots fd1a:/bsd if loaded from cd0
 * boots cd0a:/bsd.gz if loaded from cd0
 * boots cd0a:/bsd.str if loaded from cd0 (XXX bsd.strip)
 * boots cd0a:/bsdrd.gz if loaded from cd0
 * loads cd0a:/bsd.rd if loaded from cd0; segfault in rdsize()
   before root is mounted [wtf? XXX]
 * you still need to burn boot.bin
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.8 2003/11/14 20:49:43 tg Exp $
d3 2
a4 1
 * Copyright (c) 2003 Thorsten Glaser <x86@@ePost.de> for the MirOS Project
d12 1
d19 13
a31 3
 * CD Boot runtime environment - checks if CD booting, outputs messa-
 * if not and reboots system. Provides functions for booting into an-
 * other (floppy?) image. (XXX later)
d40 1
a40 3
	.globl	_C_LABEL(end)
	.globl	_C_LABEL(edata)
	.globl	_C_LABEL(boot)
d42 1
d44 5
a49 4
	.globl	_C_LABEL(tori_bootflag)
	.globl	_ASM_LABEL(pmm_init)
	.globl	Gdtr
	.globl	_start
d55 1
a55 1
	mov	esp,0x120		/* XXX ?? 0xFFFC */
a56 14
Lstart:	sti
	mov	ds,ax
	mov	es,ax
	mov	[Lbootdv],dl
	call	Lcdini
	jnc	Lboot
#ifdef	LOUD
	mov	si,offset Lfail
	call	Lotxt
#endif
	xor	ah,ah
	int	0x16
	int	0x19
	jmp	0xF000,0xFFF0
d58 5
a62 30
Lboot:	xor	edx,edx
	mov	dl,[Lbootdv]
	cli
	addr32 data32 lgdt (Gdtr - SA_LOADADDR)
	mov	ax,1
	lmsw	ax
	data32 jmp 8,offset Lpmon
	.code32
Lpmon:	mov	eax,0x10
	mov	ss,ax
	mov	esp,0xFFFC
	mov	es,ax
	mov	ds,ax
	mov	fs,ax
	mov	gs,ax
	push	edx
	call	_ASM_LABEL(pmm_init)
	/* zero out .bss */
	xor	eax,eax
	mov	ecx,offset _C_LABEL(end)
	mov	edi,offset _C_LABEL(edata)
	sub	ecx,edi
	cld
	rep
	stosb
	/* save BIOS boot device */
	mov	[_C_LABEL(bios_bootdev)],edx
	/* jump into the boot loader */
	call	_C_LABEL(boot)
	jmp	_C_LABEL(_rtt)
a63 1
	.code16
a64 2
Lfail:	.asciz	"CD/BIOS Boot failed. Press a key to reboot..."

d67 3
a69 3
	jz	Lretn
	mov	ah,14
	mov	bx,7
d72 1
a72 1
#endif
d74 5
a78 14
Lcdini:
#ifdef	LOUD
	call	1f
	.asciz	"MirOS BOOT srt0 initializing\r\n"
1:	pop	si
	call	Lotxt
#endif
	/* get parameter block */
	mov	ax,0x4B01
	mov	si,offset _C_LABEL(tori_pblk)
	int	0x13
	jnc	Lckcd
Lretn:	ret
#ifdef	LOUD
a85 13
#endif
Lckcd:	/* kludgy test if it's really a CD device */
	mov	ax,[12+_C_LABEL(tori_pblk)]
	or	ax,ax
	je	Lisfd	/* no load segment -> floppy */
#if 0
	cmp	ax,SA_LINKSEG
	je	Liscd	/* bail out if LINKSEG differs? */
	stc
	ret
#else
	jmp	Liscd
#endif
d87 1
a87 2
Lisfd:	/* it's a floppy or hard disc drive */
#ifdef	LOUD
d92 1
a92 6
	call	Lotxt
#endif
	xor	eax,eax
	mov	[_C_LABEL(tori_bootflag)],eax
	clc
	ret
d94 1
a94 4
Liscd:	/* we're hooked up on our CD drive now */
	mov	al,[2+_C_LABEL(tori_pblk)]
	mov	[Lbootdv],al
#ifdef	LOUD
d96 1
a96 1
	call	LpBY
d105 1
a105 5
	push	ax
	shr	eax,16
	call	LpWO
	pop	ax
	call	LpWO
d107 1
a107 2
	call	Lotxt
#endif
d109 1
a109 4
	xor	eax,eax
	dec	eax
	mov	al,[Lbootdv]
	mov	[_C_LABEL(tori_bootflag)],eax
d111 6
a116 15

	/* XXX ENOCOFFEE
	 * this is a good place for giving the user the
	 * choice if he wants to continue loading our
	 * cdboot.bin image, or rather boot from a floppy
	 * image (e.g. Linux, DOS, even Win2k NOEMUL)
	 * ALTERNATIVELY, this might be done from C code.
	 */

	clc
	ret

#ifdef	LOUD
LpWO:
	push	ax
d135 3
a137 1
	/* don't place these in .bss *fg* */
d146 102
a247 1
	/* EOF */
@


1.8
log
@switch to boot-new, which shares a common srt0 between CD and BIOS
@
text
@d1 1
a1 1
/* $MirBSD: srt0.S,v 1.8 2003/11/09 12:54:25 tg Exp $
d70 1
a70 1
	mov	esp,0x10000
@


1.7
log
@Mostly... not fully...

One weekend's worth of work.

- catch up website log with changes really done till today
- add catch-up entries for wbx@@ and bsiegert@@, too
- move GNU documentation to src/gnu/doc and simplify it
- re-run autoconf on the gnu part of the tree again, to
  catch up with the GFDL-documentation removal
- provide non-GFDL-licenced as(1) and ld(1) manual pages
  XXX these are more than outdated!
- bump MirOS patchlevel
- build the system through, fixing showstoppers where
  they are encountered
- index.cgi and index.php come before index.htm,
  default.htm and index.html in httpd.conf
- speed up PHP processing
- prepare for "new" OpenBSD pkgtools (unsupported by MirBSD,
  but some MirPorts people want to play with them)
- move old weblog to CMS; update my info again
- update hRef""s in old weblogs
- move release announcements to /historic/
- copy feature list from last release announcement
  XXX need a "readible short list", or even
  XXX	a separation for the target environment
  XXX	(e.g. suits / techies / clients)
- add some recent news, so the page ain't empty
  missing:
	- about
	  + MirOS
	  + MirPorts
	- get MirOS!	(http d/l, http install, install docs)
	- relations	(to other BSD)
	  + ??? events ??? (here?)
	- history
	- older releases	(historic)
	- help pages
	  + FAQ
	  + Docs/Tuts	(hi wbx@@ here comes your place)
	    + install docs
	  + mailing lists
	- developers
	  + wbx
	  + bsiegert
	  + cnuke
	- CVSweb	(XXX need BSDadvocacy.org fix before)
	- AnonCVS	(howto; link to)
	- Links
  alternatively, change the layout? suggestions?
  why am I the only one who cares about www?
- merge development plan
- put a "project" into the miros page head
- fix cdboot Makefile
- fix gas wanting us a.out again (wut?)
  (turned out to be a must-fix in configure.in)
- stand/cdboot/NOTES merged into stand/README
- sync distrib set lists
- have TORI device (i386 libsa) always use bounce buffers
  (which, in fact, makes it succeed in loading the kernel)
  XXX kernel says it has less than 4 meg ram (degraded mode)
  XXX may be a bochs issue?
- fix random.S again
- move determining of file name / raw file flag in both
  bios/toridev.c to the end of bios/toriopen()
  => enables us to have two drivers at once
- fix disk probing for CD devices wrt BIOS driver

(eww. The tree isn't fully broken, but neither boot
 nor cdboot.bin are usable at all at the moment.
 I'll fix that ASAP.)
@
text
@d1 3
a3 27
/*	$MirBSD$	*/
/*	$OpenBSD: srt0.S,v 1.13 2003/06/27 05:13:19 weingart Exp $	*/

/*
 * Copyright (c) 1997 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d5 16
d22 1
d26 2
a27 2
#define BOOTSTACK 0xfffc

d33 1
a34 1
	.globl	_C_LABEL(tori_pblk)
a36 3

	.text
	.code16
d38 16
a53 7
_start:
	popl %eax
	cmpl $BOOTMAGIC, %eax
	je	1f
#ifdef DEBUG
	movl	$0xb80a0, %ebx
	movl	$0x07420742, (%ebx)
d55 7
a61 2
1:
	popl %edx
d63 4
a66 8
	pushl	%cs
	popl	%ds
	addr32 data32 lgdt	(Gdtr - LINKADDR)
	movl	%cr0, %eax
	orl $CR0_PE, %eax
	data32 movl %eax, %cr0
	data32 ljmp $8, $1f
1:
d68 8
a75 11
	movl	$0x10,%eax
	mov	%ax,%ds
	mov	%ax,%ss
	mov	%ax,%es
	mov	%ax,%fs
	mov	%ax,%gs
	movl	$BOOTSTACK,%esp
	pushl	%edx
	movl	%edx, _C_LABEL(bios_bootdev)

	/* Now do it all */
d77 5
a81 9
#ifdef DEBUG
	movl	$0xb80a4, %ebx
	movl	$0x07520752, (%ebx)
#endif
	/* zero .bss */
	xorl	%eax, %eax
	movl	$_C_LABEL(end), %ecx
	subl	$_C_LABEL(edata),%ecx
	movl	$_C_LABEL(edata), %edi
d83 7
a89 1
	rep;	stosb
d91 121
a211 1
	call	_C_LABEL(boot)
d213 1
a213 1
	jmp	_C_LABEL(_rtt)
d219 4
@


1.6
log
@thinko -> unbreak /boot for floppy
@
text
@d1 1
d41 1
d97 3
@


1.5
log
@my stupid ego tried to set a variable's content in .bss
before the .bss region was even cleared...
@
text
@a81 2
	xorl	%eax, %eax
	movl	%eax, _C_LABEL(tori_bootflag)
@


1.4
log
@well, without the 'tori files, nothing would work anyways
and #ifdef CDBOOT in libsa isn't a good idea in general either
@
text
@d95 2
@


1.3
log
@* add (experimental, untested) cdboot programme
* fix swapped thinko, which led to mbr being installed as
  ELF binary, and pbr installed RAW (must be the reverse)
* move version number declare to stand/Makefile.inc
  and bump to 2.30
* mention CDBOOT in boot(8)
* whitespace, etc. cleanup while here
@
text
@d39 1
d82 2
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 1
a1 1
/*	$OpenBSD: srt0.S,v 1.10 1998/05/14 20:59:12 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d16 2
a17 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d38 1
d73 1
a91 1

@


1.1
log
@Initial revision
@
text
@d35 3
d44 1
d47 6
a52 2
	.globl	start
start:
d57 22
a83 8
	popl	%eax
	cmpl	$BOOTMAGIC, %eax
	je	1f
#ifdef DEBUG
	movl	$0xb80a8, %ebx
	movl	$0xcf41cf4d, (%ebx)
#endif
1:
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import some parts of OpenBSD-current (after their ELF switch) to ease future merging and reduce diffs against their codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: srt0.S,v 1.11 2003/04/17 03:43:18 drahn Exp $	*/
a34 3
#include <assym.h>

#define BOOTSTACK 0xfffc
a40 1
	.globl	Gdtr
d43 2
a44 6
	.code16
	.globl	_start
_start:
	popl %eax
	cmpl $BOOTMAGIC, %eax
	je	1f
a48 22
1:
	popl %edx
	cli
	pushl	%cs
	popl	%ds
	addr32 data32 lgdt	(Gdtr - LINKADDR)
	movl	%cr0, %eax
	orl $CR0_PE, %eax
	data32 movl %eax, %cr0
	data32 ljmp $8, $1f
1:
	.code32
	movl	$0x10,%eax
	mov	%ax,%ds
	mov	%ax,%ss
	mov	%ax,%es
	mov	%ax,%fs
	mov	%ax,%gs
	movl	$BOOTSTACK,%esp
	pushl	%edx

	/* Now do it all */
d54 8
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: srt0.S,v 1.12 2003/06/03 20:22:11 mickey Exp $	*/
d15 5
@


1.1.1.4
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: srt0.S,v 1.13 2003/06/27 05:13:19 weingart Exp $	*/
a37 1
	.globl	_C_LABEL(bios_bootdev)
a71 1
	movl	%edx, _C_LABEL(bios_bootdev)
@


1.1.1.5
log
@some OpenBSD boot code sync (so I don't have to do it later)
@
text
@d1 1
a1 1
/*	$OpenBSD: srt0.S,v 1.14 2003/11/22 09:18:25 grange Exp $	*/
d51 1
a51 1
	addr32 movl $0x07420742, (%ebx)
@


