head	1.6;
access;
symbols
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.8
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.6
	MIROS_X_BASE:1.6
	tg-mergetmp-3:1.6
	MIRBSD_XP_MIRPPC:1.6.0.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	MIRBSD_7quater:1.1.1.6
	cvs-200405160640:1.1.1.9
	cvs-200401271800:1.1.1.8
	cvs-200401261630:1.1.1.8
	cvs-200401021645:1.1.1.7
	MIRBSD_7_ALPHA:1.1.1.6.0.6
	MIRBSD_7:1.1.1.6.0.4
	cvs-200312222040:1.1.1.7
	MIRBSD_7ter:1.1.1.6
	MIRBSD_7_DEV:1.1.1.6.0.2
	cvs-200310020700:1.1.1.6
	cvs-200309271030:1.1.1.6
	cvs-200309261655:1.1.1.6
	cvs-200309251530:1.1.1.6
	cvs-200308302005:1.1.1.5
	cvs-200308171200:1.1.1.5
	ctm-3496:1.1.1.4
	ctm-3449:1.1.1.4
	ctm-3437:1.1.1.4
	cvs-200307191805:1.1.1.4
	ctm-3425:1.1.1.4
	cvs-200307091500:1.1.1.4
	cvs-200307072125:1.1.1.4
	ctm-3389:1.1.1.4
	cvs-200307021520:1.1.1.4
	cvs-200306301805:1.1.1.4
	cvs-200306301405:1.1.1.4
	cvs-200306291430:1.1.1.4
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.3
	cvs-200306091240:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.3
	ctm-3264:1.1.1.3
	cvs-200305071630:1.1.1.3
	ctm-3255:1.1.1.3
	ctm-3229:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.06.13.20.56.49;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.05.23.20.16.40;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.27.17.42.36;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.25.21.25.37;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.17.18.33.35;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.52.03;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.52.03;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.24.09.11.44;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.05.18.57.30;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.51.05;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.08.17.14.40.22;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.09.25.16.39.45;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.12.22.21.04.37;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.01.26.18.53.57;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.16.08.36.08;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@* regenerate generated files (MAKEDEV, syscalls)
* regenerate i386->FLOPPY and sparc->GENERIC manually
* remove sun4 support from sparc kernel, because our CFLAGS
  prevent v7 from working anyways
* patch in Claudio Jeker's tap-for-tun diff, and fix his
  spelling and whitespace-at-eol (he delivers good KNF tho)
* move cccp.1 manpage to where gcc-local.1 landed as well
  (the FSF COPYING is a bit more restrictive, but easy enough;
  we have worse things in usr.sbin/?????/)
* bcopy, bcmp, bzero removal
* memcpy -> memmove where memcpy() is not available
* overhaul of headers (bcopy, too)
* a bunch more NULL and time_t fixes
@
text
@/* $MirBSD: src/sys/net/if_tun.c,v 1.5 2004/05/23 20:16:40 tg Exp $	*/
/* $OpenBSD: if_tun.c,v 1.59 2004/04/25 18:50:01 henning Exp $	*/
/* $NetBSD: if_tun.c,v 1.24 1996/05/07 02:40:48 thorpej Exp $	*/

/*
 * Copyright (c) 1988, Julian Onions <Julian.Onions@@nexor.co.uk>
 * Nottingham University 1987.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This driver takes packets off the IP i/f and hands them up to a
 * user process to have its wicked way with. This driver has its
 * roots in a similar driver written by Phil Cockcroft (formerly) at
 * UCL. This driver is based much more on read/write/select mode of
 * operation though.
 */

/* #define	TUN_DEBUG	9 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/select.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/device.h>
#include <sys/vnode.h>
#include <sys/signalvar.h>
#include <sys/poll.h>
#include <sys/conf.h>

#include <machine/cpu.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/route.h>

#ifdef	INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#ifdef	IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#endif

#ifdef	NETATALK
#include <netatalk/at.h>
#include <netatalk/at_var.h>
#endif

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/rndvar.h>
#include <net/if_tun.h>

struct tun_softc {
	struct	arpcom arpcom;		/* ethernet common data */
#define tun_if	arpcom.ac_if
	u_short	tun_flags;		/* misc flags */
	pid_t	tun_pgid;		/* the process group - if any */
	uid_t	tun_siguid;		/* uid for process that set tun_pgid */
	uid_t	tun_sigeuid;		/* euid for process that set tun_pgid */
	struct	selinfo	tun_rsel;	/* read select */
	struct	selinfo	tun_wsel;	/* write select (not used) */
	int	tun_unit;
	LIST_ENTRY(tun_softc) tun_list;	/* all tunnel interfaces */
};

#ifdef	TUN_DEBUG
int	tundebug = TUN_DEBUG;
#define	TUNDEBUG(a)	(tundebug? printf a : 0)
#else
#define	TUNDEBUG(a)	/* (tundebug? printf a : 0) */
#endif

extern int ifqmaxlen;

void	tunattach(int);
int	tunopen(dev_t, int, int, struct proc *);
int	tunclose(dev_t, int, int, struct proc *);
int	tun_ioctl(struct ifnet *, u_long, caddr_t);
int	tun_output(struct ifnet *, struct mbuf *, struct sockaddr *,
		        struct rtentry *rt);
int	tunioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	tunread(dev_t, struct uio *, int);
int	tunwrite(dev_t, struct uio *, int);
int	tunpoll(dev_t, int, struct proc *);
int	tunkqfilter(dev_t, struct knote *);
int	tun_clone_create(struct if_clone *, int);
int	tun_create(struct if_clone *, int, int);
int	tun_clone_destroy(struct ifnet *);
struct	tun_softc *tun_lookup(int);
void	tun_wakeup(struct tun_softc *);
int	tun_switch(struct tun_softc *, int);

static int tuninit(struct tun_softc *);
static void tunstart(struct ifnet *);
int	filt_tunread(struct knote *, long);
int	filt_tunwrite(struct knote *, long);
void	filt_tunrdetach(struct knote *);
void	filt_tunwdetach(struct knote *);

struct filterops tunread_filtops =
	{ 1, NULL, filt_tunrdetach, filt_tunread};

struct filterops tunwrite_filtops =
	{ 1, NULL, filt_tunwdetach, filt_tunwrite};

LIST_HEAD(, tun_softc) tun_softc_list;

struct if_clone tun_cloner =
    IF_CLONE_INITIALIZER("tun", tun_clone_create, tun_clone_destroy);

void
tunattach(int n)
{
	LIST_INIT(&tun_softc_list);
	if_clone_attach(&tun_cloner);
}

int
tun_clone_create(struct if_clone *ifc, int unit)
{
	return tun_create(ifc, unit, 0);
}

int
tun_create(struct if_clone *ifc, int unit, int flags)
{
	struct tun_softc *tp;
	struct ifnet *ifp;
	u_int32_t macaddr_rnd;
	int s;

	tp = malloc(sizeof(*tp), M_DEVBUF, M_NOWAIT);
	if (!tp)
		return (ENOMEM);
	bzero(tp, sizeof(*tp));

	tp->tun_unit = unit;
	tp->tun_flags = TUN_INITED;

	/* generate fake MAC address: 00 bd xx xx xx unit_no */
	tp->arpcom.ac_enaddr[0] = 0x00;
	tp->arpcom.ac_enaddr[1] = 0xbd;
	/*
	 * This no longer happens pre-scheduler so let's use the real
	 * random subsystem instead of random().
	 */
	macaddr_rnd = arc4random();
	memmove(&tp->arpcom.ac_enaddr[2], &macaddr_rnd, sizeof(u_int32_t));
	tp->arpcom.ac_enaddr[5] = (u_char)unit + 1;

	ifp = &tp->tun_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name,
	    unit);
	ifp->if_softc = tp;
	ifp->if_ioctl = tun_ioctl;
	ifp->if_output = tun_output;
	ifp->if_start = tunstart;
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
	IFQ_SET_READY(&ifp->if_snd);
	if ((flags & TUN_LAYER2) == 0) {
		tp->tun_flags &= ~TUN_LAYER2;
		ifp->if_mtu = TUNMTU;
		ifp->if_flags = IFF_POINTOPOINT;
		ifp->if_type  = IFT_PROPVIRTUAL;
		ifp->if_hdrlen = sizeof(u_int32_t);
		if_attach(ifp);
		if_alloc_sadl(ifp);
#if NBPFILTER > 0
		bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
#endif
	} else {
		tp->tun_flags |= TUN_LAYER2;
		ifp->if_flags =
		    (IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST|IFF_LINK0);
		if_attach(ifp);
		ether_ifattach(ifp);
	}
	/* force output function to our function */
	ifp->if_output = tun_output;

	s = splimp();
	LIST_INSERT_HEAD(&tun_softc_list, tp, tun_list);
	splx(s);

	return (0);
}

int
tun_clone_destroy(struct ifnet *ifp)
{
	struct tun_softc *tp = ifp->if_softc;
	int s;

	tun_wakeup(tp);

	s = splhigh();
	klist_invalidate(&tp->tun_rsel.si_note);
	klist_invalidate(&tp->tun_wsel.si_note);
	splx(s);

	s = splimp();
	LIST_REMOVE(tp, tun_list);
	splx(s);

	if (tp->tun_flags & TUN_LAYER2)
		ether_ifdetach(ifp);

	if_detach(ifp);

	free(tp, M_DEVBUF);
	return (0);
}

struct tun_softc *
tun_lookup(int unit)
{
	struct tun_softc *tp;

	LIST_FOREACH(tp, &tun_softc_list, tun_list)
		if (tp->tun_unit == unit)
			return (tp);
	return (NULL);
}

int
tun_switch(struct tun_softc *tp, int flags)
{
	struct ifnet *ifp = &tp->tun_if;
	int unit, open, r;

	if ((tp->tun_flags & TUN_LAYER2) == (flags & TUN_LAYER2))
		return (0);

	/* tp will be removed so store unit number */
	unit = tp->tun_unit;
	open = tp->tun_flags & TUN_OPEN;
	TUNDEBUG(("%s: switching to layer %d\n", ifp->if_xname,
		    flags & TUN_LAYER2 ? 2 : 3));

	/*
	 * remove old device
	 */
	tun_clone_destroy(ifp);

	/*
	 * attach new interface
	 */
	r = tun_create(&tun_cloner, unit, flags);
	if (open && r == 0) {
		/* already opened before ifconfig tunX link0 */
		if ((tp = tun_lookup(unit)) == NULL)
			/* this should never fail */
			return (ENXIO);
		tp->tun_flags |= TUN_OPEN;
		TUNDEBUG(("%s: already open\n", tp->tun_if.if_xname));
	}
	return (r);
}

/*
 * tunnel open - must be superuser & the device must be
 * configured in
 */
int
tunopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct tun_softc *tp;
	struct ifnet	*ifp;
	int error, s;

	if ((error = suser(p, 0)) != 0)
		return (error);

	if ((tp = tun_lookup(minor(dev))) == NULL) {
		/* create on demand */
                (void) tun_clone_create(&tun_cloner, minor(dev));

		if ((tp = tun_lookup(minor(dev))) == NULL)
			return (ENXIO);
	}

	if (tp->tun_flags & TUN_OPEN)
		return EBUSY;

	ifp = &tp->tun_if;
	tp->tun_flags |= TUN_OPEN;

	/* automaticaly UP the interface on open */
	s = splimp();
	if_up(ifp);
	splx(s);

	TUNDEBUG(("%s: open\n", ifp->if_xname));
	return (0);
}

/*
 * tunclose - close the device; if closing the real device, flush pending
 *  output and (unless set STAYUP) bring down the interface.
 */
int
tunclose(dev_t dev, int flag, int mode, struct proc *p)
{
	extern int if_detach_rtdelete(struct radix_node *, void *);
	int			 s, i;
	struct tun_softc	*tp;
	struct ifnet		*ifp;
	struct radix_node_head	*rnh;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

	ifp = &tp->tun_if;
	tp->tun_flags &= ~TUN_OPEN;

	/*
	 * junk all pending output
	 */
	s = splimp();
	IFQ_PURGE(&ifp->if_snd);
	splx(s);

	if ((ifp->if_flags & IFF_UP) && !(tp->tun_flags & TUN_STAYUP)) {
		s = splimp();
		if_down(ifp);
		if (ifp->if_flags & IFF_RUNNING) {
			/* find internet addresses and delete routes */
			struct ifaddr *ifa = NULL;

			TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
#ifdef	INET
				if (ifa->ifa_addr->sa_family == AF_INET) {
					rtinit(ifa, (int)RTM_DELETE,
					    (tp->tun_flags & TUN_DSTADDR)?
					    RTF_HOST : 0);
				}
				/* XXX INET6 */
#endif
			}
			/*
			 * Find and remove all routes which are using this
			 * interface. Stolen from if.c if_detach().
			 */
			for (i = 1; i <= AF_MAX; i++) {
				rnh = rt_tables[i];
				if (rnh)
					while ((*rnh->rnh_walktree)(rnh,
					    if_detach_rtdelete, ifp) == EAGAIN)
						;
			}
			ifp->if_flags &= ~IFF_RUNNING;
		}
		splx(s);
	}
	tp->tun_pgid = 0;
	selwakeup(&tp->tun_rsel);
	KNOTE(&tp->tun_rsel.si_note, 0);

	TUNDEBUG(("%s: closed\n", ifp->if_xname));
	return (0);
}

static int
tuninit(struct tun_softc *tp)
{
	struct ifnet	*ifp = &tp->tun_if;
	struct ifaddr *ifa;

	TUNDEBUG(("%s: tuninit\n", ifp->if_xname));

	ifp->if_flags |= IFF_UP | IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE; /* we are never active */

	tp->tun_flags &= ~(TUN_IASET|TUN_DSTADDR|TUN_BRDADDR);
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
#ifdef	INET
		if (ifa->ifa_addr->sa_family == AF_INET) {
			struct sockaddr_in *sin;

			sin = satosin(ifa->ifa_addr);
			if (sin && sin->sin_addr.s_addr)
				tp->tun_flags |= TUN_IASET;

			if (ifp->if_flags & IFF_POINTOPOINT) {
				sin = satosin(ifa->ifa_dstaddr);
				if (sin && sin->sin_addr.s_addr)
					tp->tun_flags |= TUN_DSTADDR;
			} else
				tp->tun_flags &= ~TUN_DSTADDR;

			if (ifp->if_flags & IFF_BROADCAST) {
				sin = satosin(ifa->ifa_broadaddr);
				if (sin && sin->sin_addr.s_addr)
					tp->tun_flags |= TUN_BRDADDR;
			} else
				tp->tun_flags &= ~TUN_BRDADDR;
		}
#endif
#ifdef	INET6
		if (ifa->ifa_addr->sa_family == AF_INET6) {
			struct sockaddr_in6 *sin;

			sin = (struct sockaddr_in6 *)ifa->ifa_addr;
			if (!IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr))
				tp->tun_flags |= TUN_IASET;

			if (ifp->if_flags & IFF_POINTOPOINT) {
				sin = (struct sockaddr_in6 *)ifa->ifa_dstaddr;
				if (sin &&
				    !IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr))
					tp->tun_flags |= TUN_DSTADDR;
			} else
				tp->tun_flags &= ~TUN_DSTADDR;
		}
#endif /* INET6 */
	}

	return 0;
}

/*
 * Process an ioctl request.
 */
int
tun_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct tun_softc *tp = (struct tun_softc *)(ifp->if_softc);
	struct ifreq *ifr = (struct ifreq *)data;
	int	error = 0, s;

	s = splimp();
	if (tp->tun_flags & TUN_LAYER2)
		if ((error = ether_ioctl(ifp, &tp->arpcom, cmd, data)) > 0) {
			splx(s);
			return (error);
		}
	switch(cmd) {
	case SIOCSIFADDR:
		tuninit(tp);
		TUNDEBUG(("%s: address set\n", ifp->if_xname));
		if (tp->tun_flags & TUN_LAYER2)
			switch (((struct ifaddr *)data)->ifa_addr->sa_family) {
#ifdef INET
			case AF_INET:
				arp_ifinit(&tp->arpcom, (struct ifaddr *)data);
				break;
#endif
			default:
				break;
			}
		break;
	case SIOCSIFDSTADDR:
		tuninit(tp);
		TUNDEBUG(("%s: destination address set\n", ifp->if_xname));
		break;
	case SIOCSIFBRDADDR:
		tuninit(tp);
		TUNDEBUG(("%s: broadcast address set\n", ifp->if_xname));
		break;
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > TUNMRU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI: {
		if (ifr == 0) {
			error = EAFNOSUPPORT;	   /* XXX */
			break;
		}

		if (tp->tun_flags & TUN_LAYER2) {
			error = (cmd == SIOCADDMULTI) ?
			    ether_addmulti(ifr, &tp->arpcom) :
			    ether_delmulti(ifr, &tp->arpcom);
			if (error == ENETRESET) {
				/*
				 * Multicast list has changed; set the hardware
				 * filter accordingly. The good thing is we do
				 * not have a hardware filter (:
				 */
				error = 0;
			}
			break;
		}

		switch (ifr->ifr_addr.sa_family) {
#ifdef	INET
		case AF_INET:
			break;
#endif
#ifdef	INET6
		case AF_INET6:
			break;
#endif
		default:
			error = EAFNOSUPPORT;
			break;
		}
		break;
	}

	case SIOCSIFFLAGS:
		error = tun_switch(tp,
		    ifr->ifr_flags & IFF_LINK0 ? TUN_LAYER2 : 0);
		break;
	default:
		error = EINVAL;
	}
	splx(s);
	return (error);
}

/*
 * tun_output - queue packets from higher level ready to put out.
 */
int
tun_output(struct ifnet *ifp, struct mbuf *m0,
    struct sockaddr *dst, struct rtentry *rt)
{
	struct tun_softc *tp = ifp->if_softc;
	int		s, len, error;
	u_int32_t	*af;

	TUNDEBUG(("%s: tun_output\n", ifp->if_xname));

	if ((tp->tun_flags & TUN_READY) != TUN_READY) {
		TUNDEBUG(("%s: not ready %#x\n", ifp->if_xname,
			  tp->tun_flags));
		m_freem (m0);
		return EHOSTDOWN;
	}

	if (tp->tun_flags & TUN_LAYER2)
		/* call ether_output and that will call tunstart at the end */
		return (ether_output(ifp, m0, dst, rt));

	M_PREPEND(m0, sizeof(*af), M_DONTWAIT);
	af = mtod(m0, u_int32_t *);
	*af = htonl(dst->sa_family);

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m0);
#endif

	len = m0->m_pkthdr.len + sizeof(*af);
	s = splimp();
	IFQ_ENQUEUE(&ifp->if_snd, m0, NULL, error);
	if (error) {
		splx(s);
		ifp->if_collisions++;
		return (error);
	}
	splx(s);
	ifp->if_opackets++;
	ifp->if_obytes += len;

	tun_wakeup(tp);
	return 0;
}

void
tun_wakeup(tp)
	struct tun_softc *tp;
{
	if (tp->tun_flags & TUN_RWAIT) {
		tp->tun_flags &= ~TUN_RWAIT;
		wakeup((caddr_t)tp);
	}
	if (tp->tun_flags & TUN_ASYNC && tp->tun_pgid)
		csignal(tp->tun_pgid, SIGIO,
		    tp->tun_siguid, tp->tun_sigeuid);
	selwakeup(&tp->tun_rsel);
	KNOTE(&tp->tun_rsel.si_note, 0);
}

/*
 * the cdevsw interface is now pretty minimal.
 */
int
tunioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int		s;
	struct tun_softc *tp;
	struct tuninfo *tunp;
	struct mbuf *m;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

	s = splimp();
	switch (cmd) {
	case TUNSIFINFO:
		tunp = (struct tuninfo *)data;
		tp->tun_if.if_mtu = tunp->mtu;
		tp->tun_if.if_type = tunp->type;
		tp->tun_if.if_flags = tunp->flags;
		tp->tun_if.if_baudrate = tunp->baudrate;
		break;
	case TUNGIFINFO:
		tunp = (struct tuninfo *)data;
		tunp->mtu = tp->tun_if.if_mtu;
		tunp->type = tp->tun_if.if_type;
		tunp->flags = tp->tun_if.if_flags;
		tunp->baudrate = tp->tun_if.if_baudrate;
		break;
#ifdef	TUN_DEBUG
	case TUNSDEBUG:
		tundebug = *(int *)data;
		break;
	case TUNGDEBUG:
		*(int *)data = tundebug;
		break;
#endif
        case TUNSIFMODE:
	        switch (*(int *)data & (IFF_POINTOPOINT|IFF_BROADCAST)) {
                case IFF_POINTOPOINT:
                case IFF_BROADCAST:
                        tp->tun_if.if_flags &=
                                ~(IFF_BROADCAST|IFF_POINTOPOINT|IFF_MULTICAST);
                        tp->tun_if.if_flags |= *(int *)data;
                        break;
                default:
		        splx(s);
                        return (EINVAL);
                }
                break;

       	case FIONBIO:
		if (*(int *)data)
			tp->tun_flags |= TUN_NBIO;
		else
			tp->tun_flags &= ~TUN_NBIO;
		break;
	case FIOASYNC:
		if (*(int *)data)
			tp->tun_flags |= TUN_ASYNC;
		else
			tp->tun_flags &= ~TUN_ASYNC;
		break;
	case FIONREAD:
		IFQ_POLL(&tp->tun_if.if_snd, m);
		if (m != NULL)
			*(int *)data = m->m_pkthdr.len;
		else
			*(int *)data = 0;
		break;
	case TIOCSPGRP:
		tp->tun_pgid = *(int *)data;
		tp->tun_siguid = p->p_cred->p_ruid;
		tp->tun_sigeuid = p->p_ucred->cr_uid;
		break;
	case TIOCGPGRP:
		*(int *)data = tp->tun_pgid;
		break;
	case OSIOCGIFADDR:
	case SIOCGIFADDR:
		if (!(tp->tun_flags & TUN_LAYER2)) {
			splx(s);
			return (EINVAL);
		}
		bcopy(tp->arpcom.ac_enaddr, data,
		    sizeof(tp->arpcom.ac_enaddr));
		break;

	case SIOCSIFADDR:
		if (!(tp->tun_flags & TUN_LAYER2)) {
			splx(s);
			return (EINVAL);
		}
		bcopy(data, tp->arpcom.ac_enaddr,
		    sizeof(tp->arpcom.ac_enaddr));
		break;
	default:
		splx(s);
		return (ENOTTY);
	}
	splx(s);
	return (0);
}

/*
 * The cdevsw read interface - reads a packet at a time, or at
 * least as much of a packet as can be read.
 */
int
tunread(dev_t dev, struct uio *uio, int ioflag)
{
	struct tun_softc *tp;
	struct ifnet	*ifp;
	struct mbuf	*m, *m0;
	int		error = 0, len, s;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

	ifp = &tp->tun_if;
	TUNDEBUG(("%s: read\n", ifp->if_xname));
	if ((tp->tun_flags & TUN_READY) != TUN_READY) {
		TUNDEBUG(("%s: not ready %#x\n", ifp->if_xname,
			  tp->tun_flags));
		return EHOSTDOWN;
	}

	tp->tun_flags &= ~TUN_RWAIT;

	s = splimp();
	do {
		while ((tp->tun_flags & TUN_READY) != TUN_READY)
			if ((error = tsleep((caddr_t)tp,
			    (PZERO+1)|PCATCH, "tunread", 0)) != 0) {
				splx(s);
				return (error);
			}
		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m0 == 0) {
			if (tp->tun_flags & TUN_NBIO && ioflag & IO_NDELAY) {
				splx(s);
				return EWOULDBLOCK;
			}
			tp->tun_flags |= TUN_RWAIT;
			if ((error = tsleep((caddr_t)tp,
			    (PZERO + 1)|PCATCH, "tunread", 0)) != 0) {
				splx(s);
				return (error);
			}
		}
	} while (m0 == 0);
	splx(s);

	while (m0 && uio->uio_resid > 0 && error == 0) {
		len = min(uio->uio_resid, m0->m_len);
		if (len != 0)
			error = uiomove(mtod(m0, caddr_t), len, uio);
		MFREE(m0, m);
		m0 = m;
	}

	if (m0) {
		TUNDEBUG(("Dropping mbuf\n"));
		m_freem(m0);
	}
	if (error)
		ifp->if_ierrors++;

	return error;
}

/*
 * the cdevsw write interface - an atomic write is a packet - or else!
 */
int
tunwrite(dev_t dev, struct uio *uio, int ioflag)
{
	struct tun_softc *tp;
	struct ifnet	*ifp;
	struct ifqueue	*ifq;
	u_int32_t	*th;
	struct mbuf	*top, **mp, *m;
	int		isr;
	int		error=0, s, tlen, mlen;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

	ifp = &tp->tun_if;
	TUNDEBUG(("%s: tunwrite\n", ifp->if_xname));

	if (uio->uio_resid == 0 || uio->uio_resid > ifp->if_mtu +
	    (tp->tun_flags & TUN_LAYER2 ? ETHER_HDR_LEN : sizeof(*th))) {
		TUNDEBUG(("%s: len=%d!\n", ifp->if_xname, uio->uio_resid));
		return EMSGSIZE;
	}
	tlen = uio->uio_resid;

	/* get a header mbuf */
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return ENOBUFS;
	mlen = MHLEN;

	top = 0;
	mp = &top;
	if (tp->tun_flags & TUN_LAYER2) {
		/*
		 * Pad so that IP header is correctly aligned
		 * this is neccessary for all strict aligned architectures.
		 */
		mlen -= ETHER_ALIGN;
		m_adj(m, ETHER_ALIGN);
	}
	while (error == 0 && uio->uio_resid > 0) {
		m->m_len = min(mlen, uio->uio_resid);
		error = uiomove(mtod (m, caddr_t), m->m_len, uio);
		*mp = m;
		mp = &m->m_next;
		if (error == 0 && uio->uio_resid > 0) {
			MGET (m, M_DONTWAIT, MT_DATA);
			if (m == 0) {
				error = ENOBUFS;
				break;
			}
			mlen = MLEN;
		}
	}
	if (error) {
		if (top)
			m_freem (top);
		ifp->if_ierrors++;
		return error;
	}

	top->m_pkthdr.len = tlen;
	top->m_pkthdr.rcvif = ifp;

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, top);
#endif

	if (tp->tun_flags & TUN_LAYER2) {
		ether_input_mbuf(ifp, top);
		ifp->if_ipackets++; /* ibytes are counted in ether_input */
		return (0);
	}

	th = mtod(top, u_int32_t *);
	/* strip the tunnel header */
	top->m_data += sizeof(*th);
	top->m_len  -= sizeof(*th);
	top->m_pkthdr.len -= sizeof(*th);

	switch (ntohl(*th)) {
#ifdef	INET
	case AF_INET:
		ifq = &ipintrq;
		isr = NETISR_IP;
		break;
#endif
#ifdef	INET6
	case AF_INET6:
		ifq = &ip6intrq;
		isr = NETISR_IPV6;
		break;
#endif
#ifdef	NS
	case AF_NS:
		ifq = &nsintrq;
		isr = NETISR_NS;
		break;
#endif
#ifdef	IPX
	case AF_IPX:
		ifq = &ipxintrq;
		isr = NETISR_IPX;
		break;
#endif
#ifdef	NETATALK
	case AF_APPLETALK:
		ifq = &atintrq2;
		isr = NETISR_ATALK;
		break;
#endif
#ifdef	ISO
	case AF_ISO:
		ifq = &clnlintrq;
		isr = NETISR_ISO;
		break;
#endif
	default:
		m_freem(top);
		return EAFNOSUPPORT;
	}

	s = splimp();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		splx(s);
		ifp->if_collisions++;
		m_freem(top);
		if (!ifq->ifq_congestion)
			if_congestion(ifq);
		return ENOBUFS;
	}
	IF_ENQUEUE(ifq, top);
	schednetisr(isr);
	ifp->if_ipackets++;
	ifp->if_ibytes += top->m_pkthdr.len;
	splx(s);
	return error;
}

/*
 * tunpoll - the poll interface, this is only useful on reads
 * really. The write detect always returns true, write never blocks
 * anyway, it either accepts the packet or drops it.
 */
int
tunpoll(dev_t dev, int events, struct proc *p)
{
	int		revents, s;
	struct tun_softc *tp;
	struct ifnet	*ifp;
	struct mbuf	*m;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

	ifp = &tp->tun_if;
	revents = 0;
	s = splimp();
	TUNDEBUG(("%s: tunpoll\n", ifp->if_xname));

	if (events & (POLLIN | POLLRDNORM)) {
		IFQ_POLL(&ifp->if_snd, m);
		if (m != NULL) {
			TUNDEBUG(("%s: tunselect q=%d\n", ifp->if_xname,
				  ifp->if_snd.ifq_len));
			revents |= events & (POLLIN | POLLRDNORM);
		} else {
			TUNDEBUG(("%s: tunpoll waiting\n", ifp->if_xname));
			selrecord(p, &tp->tun_rsel);
		}
	}
	if (events & (POLLOUT | POLLWRNORM))
		revents |= events & (POLLOUT | POLLWRNORM);
	splx(s);
	return (revents);
}

/*
 * kqueue(2) support.
 *
 * The tun driver uses an array of tun_softc's based on the minor number
 * of the device.  kn->kn_hook gets set to the specific tun_softc.
 *
 * filt_tunread() sets kn->kn_data to the iface qsize
 * filt_tunwrite() sets kn->kn_data to the MTU size
 */
int
tunkqfilter(dev_t dev,struct knote *kn)
{
	int s;
	struct klist *klist;
	struct tun_softc *tp;
	struct ifnet *ifp;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

	ifp = &tp->tun_if;

	s = splimp();
	TUNDEBUG(("%s: tunkqfilter\n", ifp->if_xname));
	splx(s);

	switch (kn->kn_filter) {
		case EVFILT_READ:
			klist = &tp->tun_rsel.si_note;
			kn->kn_fop = &tunread_filtops;
			break;
		case EVFILT_WRITE:
			klist = &tp->tun_wsel.si_note;
			kn->kn_fop = &tunwrite_filtops;
			break;
		default:
			return EPERM;	/* 1 */
	}

	kn->kn_hook = (caddr_t)tp;

	s = splhigh();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return 0;
}

void
filt_tunrdetach(struct knote *kn)
{
	int s;
	struct tun_softc *tp = (struct tun_softc *)kn->kn_hook;

	s = splhigh();
	if (!(kn->kn_status & KN_DETACHED))
		SLIST_REMOVE(&tp->tun_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_tunread(struct knote *kn, long hint)
{
	int s;
	struct tun_softc *tp;
	struct ifnet *ifp;
	struct mbuf *m;

	if (kn->kn_status & KN_DETACHED) {
		kn->kn_data = 0;
		return 1;
	}

	tp = (struct tun_softc *)kn->kn_hook;
	ifp = &tp->tun_if;

	s = splnet();
	IFQ_POLL(&ifp->if_snd, m);
	if (m != NULL) {
		splx(s);
		kn->kn_data = ifp->if_snd.ifq_len;

		TUNDEBUG(("%s: tunkqread q=%d\n", ifp->if_xname,
					ifp->if_snd.ifq_len));
		return 1;
	}
	splx(s);
	TUNDEBUG(("%s: tunkqread waiting\n", ifp->if_xname));
	return 0;
}

void
filt_tunwdetach(struct knote *kn)
{
	int s;
	struct tun_softc *tp = (struct tun_softc *)kn->kn_hook;

	s = splhigh();
	if (!(kn->kn_status & KN_DETACHED))
		SLIST_REMOVE(&tp->tun_wsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_tunwrite(struct knote *kn, long hint)
{
	struct tun_softc *tp;
	struct ifnet *ifp;

	if (kn->kn_status & KN_DETACHED) {
		kn->kn_data = 0;
		return 1;
	}

	tp = (struct tun_softc *)kn->kn_hook;
	ifp = &tp->tun_if;

	kn->kn_data = ifp->if_mtu;

	return 1;
}

/*
 * Start packet transmission on the interface.
 * when the interface queue is rate-limited by ALTQ or TBR,
 * if_start is needed to drain packets from the queue in order
 * to notify readers when outgoing packets become ready.
 * In layer 2 mode this function is called from ether_output.
 */
static void
tunstart(struct ifnet *ifp)
{
	struct tun_softc *tp = ifp->if_softc;
	struct mbuf *m;

	if (!(tp->tun_flags & TUN_LAYER2) &&
	    !ALTQ_IS_ENABLED(&ifp->if_snd) &&
	    !TBR_IS_ENABLED(&ifp->if_snd))
		return;

	IFQ_POLL(&ifp->if_snd, m);
	if (m != NULL) {
		if (tp->tun_flags & TUN_LAYER2) {
#if NBPFILTER > 0
			if (ifp->if_bpf)
				bpf_mtap(ifp->if_bpf, m);
#endif
			ifp->if_opackets++;
		}
		tun_wakeup(tp);
	}
}
@


1.5
log
@* first futile attempt to merge OpenBSD 3.5-current
* damn! they got pxeboot! -> disable for now
  (there's still ports/sysutils/pxegrub; we'll have pxeboot later)
* I don't know if that ... bootloader still works
* nuke netbsd emul (was unused anyways)
* nuke a plethora of syscalls not being used, and mark
  the other two (COMPAT_35) for deletion RSN
* merge new MI-GENERIC into i386 GENERIC
* resolve numeric conflicts for
  - syscalls
  - sysctls
  - device majors
  - pcidevs
* (c) cleanup - no need to add a bsd-like licence when
  there's already one; just add my name
* and much more
@
text
@d1 3
a3 3
/*	$MirBSD: src/sys/net/if_tun.c,v 1.4 2004/01/27 17:42:36 tg Exp $	*/
/*	$OpenBSD: if_tun.c,v 1.59 2004/04/25 18:50:01 henning Exp $	*/
/*	$NetBSD: if_tun.c,v 1.24 1996/05/07 02:40:48 thorpej Exp $	*/
d72 1
a72 6
/* #include <netinet/if_ether.h> */
#endif

#ifdef	NS
#include <netns/ns.h>
#include <netns/ns_if.h>
a84 5
#ifdef	ISO
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#endif

d90 1
d94 2
a95 1
	struct	ifnet tun_if;		/* the interface */
d127 1
d131 1
a133 1
#ifdef	ALTQ
a134 1
#endif
d161 6
d169 1
d180 11
a194 1
	ifp->if_mtu = TUNMTU;
a196 1
#ifdef ALTQ
a197 3
#endif
	ifp->if_flags = IFF_POINTOPOINT;
	ifp->if_type  = IFT_PROPVIRTUAL;
d200 8
a207 10
	ifp->if_hdrlen = sizeof(u_int32_t);
	ifp->if_collisions = 0;
	ifp->if_ierrors = 0;
	ifp->if_oerrors = 0;
	ifp->if_ipackets = 0;
	ifp->if_opackets = 0;
	ifp->if_ibytes = 0;
	ifp->if_obytes = 0;
	if_attach(ifp);
	if_alloc_sadl(ifp);
d209 1
a209 1
	bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
d211 10
d234 2
d245 3
a247 4
	tun_wakeup(tp);
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
d265 35
d309 1
a309 1
	int error;
d327 6
d344 5
a348 3
	int	s;
	struct tun_softc *tp;
	struct ifnet	*ifp;
d368 2
a369 1
			struct ifaddr *ifa;
d374 2
a375 2
					       (tp->tun_flags & TUN_DSTADDR)?
							RTF_HOST : 0);
d377 1
d380 12
d412 1
d467 2
d472 5
d479 1
a479 1
		tuninit((struct tun_softc *)(ifp->if_softc));
d481 10
d493 1
a493 1
		tuninit((struct tun_softc *)(ifp->if_softc));
d497 1
a497 1
		tuninit((struct tun_softc *)(ifp->if_softc));
d501 4
a504 1
		ifp->if_mtu = ((struct ifreq *)data)->ifr_mtu;
a507 1
		struct ifreq *ifr = (struct ifreq *)data;
d512 16
d545 2
d569 1
a569 1
		TUNDEBUG(("%s: not ready 0%o\n", ifp->if_xname,
d575 4
a660 4
                        if (tp->tun_if.if_flags & IFF_UP) {
                                splx(s);
                                return (EBUSY);
                        }
d698 18
d742 1
a742 1
		TUNDEBUG(("%s: not ready 0%o\n", ifp->if_xname,
d811 2
a812 1
	if (uio->uio_resid == 0 || uio->uio_resid > TUNMRU) {
d826 8
d863 6
d936 1
a936 1
 * tunselect - the select interface, this is only useful on reads
d996 1
a996 1
	TUNDEBUG(("%s: tunselect\n", ifp->if_xname));
a1094 1
#ifdef	ALTQ
d1100 1
d1108 3
a1110 1
	if (!ALTQ_IS_ENABLED(&ifp->if_snd) && !TBR_IS_ENABLED(&ifp->if_snd))
d1114 8
a1121 1
	if (m != NULL)
d1123 1
a1124 1
#endif
@


1.4
log
@first part of mergeing OpenBSD and fixing whitespace and RCS IDs
@
text
@d1 2
a2 2
/*	$MirBSD: if_tun.c,v 1.3 2003/12/25 21:25:37 tg Exp $	*/
/*	$OpenBSD: if_tun.c,v 1.57 2004/01/12 04:48:25 tedu Exp $	*/
d703 1
a703 1
		if (uio->uio_resid > 0) {
d781 2
@


1.3
log
@* complete merging OpenBSD import for src/sys
* in addition to that, cope for some miros specialties
new:
+ the "OpenBSD" and "OpenBSDx_y" (x=3 y=4) preprocessor syms
	aren't defined any more
+ the "MirOS" symbol is defined to the same as MACHINE_OS
	(ie, BSD or Linux without string operator) iff
	the system is running MirBSD or MirLinux
bump patchlevel
@
text
@d1 2
a2 2
/*	$MirBSD: if_tun.c,v 1.2 2003/11/17 18:33:35 tg Exp $	*/
/*	$OpenBSD: if_tun.c,v 1.55 2003/12/16 20:33:25 markus Exp $	*/
d221 5
d884 2
a885 1
	SLIST_REMOVE(&tp->tun_rsel.si_note, kn, knote, kn_selnext);
d897 5
d927 2
a928 1
	SLIST_REMOVE(&tp->tun_wsel.si_note, kn, knote, kn_selnext);
d937 5
@


1.2
log
@KNF, MirBSDify
@
text
@d1 2
a2 2
/*	$MirBSD$	*/
/*	$OpenBSD: if_tun.c,v 1.50 2003/09/23 16:51:13 millert Exp $	*/
d110 2
a120 3
struct tun_softc *tunctl;
int ntun;

d134 4
a137 1

d143 15
d162 8
a169 1
	register int i;
d171 6
d178 29
a206 14
	ntun = n;
	tunctl = malloc(ntun * sizeof(*tunctl), M_DEVBUF, M_WAITOK);
	bzero(tunctl, ntun * sizeof(*tunctl));
	for (i = 0; i < ntun; i++) {
		tunctl[i].tun_flags = TUN_INITED;

		ifp = &tunctl[i].tun_if;
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "tun%d", i);
		ifp->if_softc = &tunctl[i];
		ifp->if_mtu = TUNMTU;
		ifp->if_ioctl = tun_ioctl;
		ifp->if_output = tun_output;
#ifdef	ALTQ
		ifp->if_start = tunstart;
d208 18
a225 14
		ifp->if_flags = IFF_POINTOPOINT;
		ifp->if_type  = IFT_PROPVIRTUAL;
		IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
		IFQ_SET_READY(&ifp->if_snd);
		ifp->if_hdrlen = sizeof(u_int32_t);
		ifp->if_collisions = 0;
		ifp->if_ierrors = 0;
		ifp->if_oerrors = 0;
		ifp->if_ipackets = 0;
		ifp->if_opackets = 0;
		ifp->if_ibytes = 0;
		ifp->if_obytes = 0;
		if_attach(ifp);
		if_alloc_sadl(ifp);
d227 1
a227 1
		bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
d229 15
a243 1
	}
d255 1
a255 1
	register int	unit, error;
d260 7
a266 2
	if ((unit = minor(dev)) >= ntun)
		return (ENXIO);
a267 1
	tp = &tunctl[unit];
d284 1
a284 1
	register int	unit, s;
d288 1
a288 1
	if ((unit = minor(dev)) >= ntun)
a290 1
	tp = &tunctl[unit];
d306 1
a306 1
			register struct ifaddr *ifa;
d321 1
d331 1
a331 1
	register struct ifaddr *ifa;
d482 8
d498 1
a498 1
	return 0;
d507 1
a507 1
	int	unit, s;
d512 1
a512 1
	if ((unit = minor(dev)) >= ntun)
a514 2
	tp = &tunctl[unit];

a598 1
	int		unit;
d604 1
a604 1
	if ((unit = minor(dev)) >= ntun)
a606 1
	tp = &tunctl[unit];
d665 1
a665 1
	int		unit;
d673 1
a673 1
	if ((unit = minor(dev)) >= ntun)
d676 1
a676 1
	ifp = &tunctl[unit].tun_if;
d794 1
a794 1
	int		unit, revents, s;
d799 1
a799 1
	if ((unit = minor(dev)) >= ntun)
a801 1
	tp = &tunctl[unit];
d824 58
a881 1
/* Does not currently work */
d884 1
a884 1
tunkqfilter(dev_t dev, struct knote *kn)
d886 46
a931 1
	return (1);
d951 2
a952 10
	if (m != NULL) {
		if (tp->tun_flags & TUN_RWAIT) {
			tp->tun_flags &= ~TUN_RWAIT;
			wakeup((caddr_t)tp);
		}
		if (tp->tun_flags & TUN_ASYNC && tp->tun_pgid)
			csignal(tp->tun_pgid, SIGIO,
			    tp->tun_siguid, tp->tun_sigeuid);
		selwakeup(&tp->tun_rsel);
	}
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: if_tun.c,v 1.45 2003/01/07 09:00:34 kjc Exp $	*/
d19 1
a19 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
d57 1
d67 1
a67 1
#ifdef INET
d75 1
a75 1
#ifdef NS
d80 1
a80 1
#ifdef IPX
d85 1
a85 1
#ifdef NETATALK
d90 1
a90 1
#ifdef ISO
d114 1
a114 1
#define TUNDEBUG(a)	(tundebug? printf a : 0)
d116 1
a116 1
#define TUNDEBUG(a)	/* (tundebug? printf a : 0) */
d133 1
a133 1
int	tunselect(dev_t, int, struct proc *);
d138 1
a138 1
#ifdef ALTQ
d143 1
a143 2
tunattach(n)
	int n;
d155 1
a155 1
		sprintf(ifp->if_xname, "tun%d", i);
d160 1
a160 1
#ifdef ALTQ
d188 1
a188 4
tunopen(dev, flag, mode, p)
	dev_t	dev;
	int	flag, mode;
	struct proc *p;
d194 1
a194 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d215 1
a215 5
tunclose(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
d242 1
a242 1
#ifdef INET
d255 1
a255 1
		
d261 1
a261 2
tuninit(tp)
	struct tun_softc *tp;
d272 1
a272 1
#ifdef INET
d295 17
d321 1
a321 4
tun_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long	cmd;
	caddr_t	data;
d350 1
a350 1
#ifdef INET
d354 1
a354 1
#ifdef INET6
d378 2
a379 5
tun_output(ifp, m0, dst, rt)
	struct ifnet   *ifp;
	struct mbuf    *m0;
	struct sockaddr *dst;
	struct rtentry *rt;
d430 1
a430 6
tunioctl(dev, cmd, data, flag, p)
	dev_t		dev;
	u_long		cmd;
	caddr_t		data;
	int		flag;
	struct proc	*p;
d432 1
a432 1
	int		unit, s;
d435 1
d458 1
a458 1
#ifdef TUN_DEBUG
d497 4
a500 3
		if (tp->tun_if.if_snd.ifq_head)
			*(int *)data = tp->tun_if.if_snd.ifq_head->m_pkthdr.len;
		else	
d524 1
a524 4
tunread(dev, uio, ioflag)
	dev_t		dev;
	struct uio	*uio;
	int		ioflag;
d592 1
a592 4
tunwrite(dev, uio, ioflag)
	dev_t		dev;
	struct uio	*uio;
	int		ioflag;
d658 1
a658 1
#ifdef INET
d664 1
a664 1
#ifdef INET6
d670 1
a670 1
#ifdef NS
d676 1
a676 1
#ifdef IPX
d682 1
a682 1
#ifdef NETATALK
d688 1
a688 1
#ifdef ISO
d721 1
a721 4
tunselect(dev, rw, p)
	dev_t		dev;
	int		rw;
	struct proc	*p;
d723 1
a723 1
	int		unit, s;
d726 1
d733 1
d735 1
a735 1
	TUNDEBUG(("%s: tunselect\n", ifp->if_xname));
d737 3
a739 4
	switch (rw) {
	case FREAD:
		if (ifp->if_snd.ifq_len > 0) {
			splx(s);
d742 4
a745 1
			return 1;
a746 5
		selrecord(curproc, &tp->tun_rsel);
		break;
	case FWRITE:
		splx(s);
		return 1;
d748 2
d751 1
a751 2
	TUNDEBUG(("%s: tunselect waiting\n", ifp->if_xname));
	return 0;
d757 1
a757 1
tunkqfilter(dev_t dev,struct knote *kn)
d762 1
a762 1
#ifdef ALTQ
d770 1
a770 2
tunstart(ifp)
	struct ifnet *ifp;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import some parts of OpenBSD-current (after their ELF switch) to ease future merging and reduce diffs against their codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.46 2003/04/18 05:26:13 jason Exp $	*/
a301 17
#ifdef INET6
		if (ifa->ifa_addr->sa_family == AF_INET6) {
			struct sockaddr_in6 *sin;

			sin = (struct sockaddr_in6 *)ifa->ifa_addr;
			if (!IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr))
				tp->tun_flags |= TUN_IASET;

			if (ifp->if_flags & IFF_POINTOPOINT) {
				sin = (struct sockaddr_in6 *)ifa->ifa_dstaddr;
				if (sin &&
				    !IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr))
					tp->tun_flags |= TUN_DSTADDR;
			} else
				tp->tun_flags &= ~TUN_DSTADDR;
		}
#endif /* INET6 */
@


1.1.1.3
log
@Import OpenBSD cvs as of now, CTM delta 3255, just before the i386 flag day
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.47 2003/05/03 21:15:11 deraadt Exp $	*/
d154 1
a154 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "tun%d", i);
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.48 2003/06/12 10:49:17 henning Exp $	*/
a452 1
	struct mbuf *m;
d514 2
a515 3
		IFQ_POLL(&tp->tun_if.if_snd, m);
		if (m != NULL)
			*(int *)data = m->m_pkthdr.len;
a750 1
	struct mbuf	*m;
d762 1
a762 2
		IFQ_POLL(&ifp->if_snd, m);
		if (m != NULL) {
@


1.1.1.5
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.49 2003/08/15 20:32:19 tedu Exp $	*/
d196 1
a196 1
	if ((error = suser(p, 0)) != 0)
@


1.1.1.6
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.50 2003/09/23 16:51:13 millert Exp $	*/
a55 1
#include <sys/poll.h>
d131 1
a131 1
int	tunpoll(dev_t, int, struct proc *);
d745 1
a745 1
tunpoll(dev, events, p)
d747 1
a747 1
	int		events;
d750 1
a750 1
	int		unit, revents, s;
a759 1
	revents = 0;
d761 1
a761 1
	TUNDEBUG(("%s: tunpoll\n", ifp->if_xname));
d763 2
a764 1
	if (events & (POLLIN | POLLRDNORM)) {
d767 1
d770 1
a770 4
			revents |= events & (POLLIN | POLLRDNORM);
		} else {
			TUNDEBUG(("%s: tunpoll waiting\n", ifp->if_xname));
			selrecord(p, &tp->tun_rsel);
d772 5
a777 2
	if (events & (POLLOUT | POLLWRNORM))
		revents |= events & (POLLOUT | POLLWRNORM);
d779 2
a780 1
	return (revents);
@


1.1.1.7
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.55 2003/12/16 20:33:25 markus Exp $	*/
a108 2
	int	tun_unit;
	LIST_ENTRY(tun_softc) tun_list;	/* all tunnel interfaces */
d118 3
d134 1
a134 4
int	tun_clone_create(struct if_clone *, int);
int	tun_clone_destroy(struct ifnet *);
struct	tun_softc *tun_lookup(int);
void	tun_wakeup(struct tun_softc *);
a139 15
int	filt_tunread(struct knote *, long);
int	filt_tunwrite(struct knote *, long);
void	filt_tunrdetach(struct knote *);
void	filt_tunwdetach(struct knote *);

struct filterops tunread_filtops =
	{ 1, NULL, filt_tunrdetach, filt_tunread};

struct filterops tunwrite_filtops =
	{ 1, NULL, filt_tunwdetach, filt_tunwrite};

LIST_HEAD(, tun_softc) tun_softc_list;

struct if_clone tun_cloner =
    IF_CLONE_INITIALIZER("tun", tun_clone_create, tun_clone_destroy);
d145 1
a145 10
	LIST_INIT(&tun_softc_list);
	if_clone_attach(&tun_cloner);
}

int
tun_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
{
	struct tun_softc *tp;
a146 6
	int s;

	tp = malloc(sizeof(*tp), M_DEVBUF, M_NOWAIT);
	if (!tp)
		return (ENOMEM);
	bzero(tp, sizeof(*tp));
d148 12
a159 10
	tp->tun_unit = unit;
	tp->tun_flags = TUN_INITED;

	ifp = &tp->tun_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name, 
	    unit);
	ifp->if_softc = tp;
	ifp->if_mtu = TUNMTU;
	ifp->if_ioctl = tun_ioctl;
	ifp->if_output = tun_output;
d161 1
a161 1
	ifp->if_start = tunstart;
d163 14
a176 14
	ifp->if_flags = IFF_POINTOPOINT;
	ifp->if_type  = IFT_PROPVIRTUAL;
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
	IFQ_SET_READY(&ifp->if_snd);
	ifp->if_hdrlen = sizeof(u_int32_t);
	ifp->if_collisions = 0;
	ifp->if_ierrors = 0;
	ifp->if_oerrors = 0;
	ifp->if_ipackets = 0;
	ifp->if_opackets = 0;
	ifp->if_ibytes = 0;
	ifp->if_obytes = 0;
	if_attach(ifp);
	if_alloc_sadl(ifp);
d178 1
a178 1
	bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
d180 1
a180 38
	s = splimp();
	LIST_INSERT_HEAD(&tun_softc_list, tp, tun_list);
	splx(s);

	return (0);
}

int
tun_clone_destroy(ifp)
	struct ifnet *ifp;
{
	struct tun_softc *tp = ifp->if_softc;
	int s;

	s = splimp();
	LIST_REMOVE(tp, tun_list);
	splx(s);

	tun_wakeup(tp);
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
	if_detach(ifp);

	free(tp, M_DEVBUF);
	return (0);
}

struct tun_softc *
tun_lookup(unit)
	int unit;
{
	struct tun_softc *tp;

	LIST_FOREACH(tp, &tun_softc_list, tun_list)
		if (tp->tun_unit == unit)
			return (tp);
	return (NULL);
d195 1
a195 1
	int error;
d200 2
a201 7
	if ((tp = tun_lookup(minor(dev))) == NULL) {
		/* create on demand */
                (void) tun_clone_create(&tun_cloner, minor(dev));

		if ((tp = tun_lookup(minor(dev))) == NULL)
			return (ENXIO);
	}
d203 1
d224 1
a224 1
	int	s;
d228 1
a228 1
	if ((tp = tun_lookup(minor(dev))) == NULL)
d231 1
d247 1
a247 1
			struct ifaddr *ifa;
a261 1
	KNOTE(&tp->tun_rsel.si_note, 0);
d272 1
a272 1
	struct ifaddr *ifa;
a428 8
	tun_wakeup(tp);
	return 0;
}

void
tun_wakeup(tp)
	struct tun_softc *tp;
{
d437 1
a437 1
	KNOTE(&tp->tun_rsel.si_note, 0);
d451 1
a451 1
	int		s;
d456 1
a456 1
	if ((tp = tun_lookup(minor(dev))) == NULL)
d459 2
d548 1
d554 1
a554 1
	if ((tp = tun_lookup(minor(dev))) == NULL)
d557 1
d619 1
a619 1
	struct tun_softc *tp;
d627 1
a627 1
	if ((tp = tun_lookup(minor(dev))) == NULL)
d630 1
a630 1
	ifp = &tp->tun_if;
d751 1
a751 1
	int		revents, s;
d756 1
a756 1
	if ((tp = tun_lookup(minor(dev))) == NULL)
d759 1
d782 2
a783 9
/*
 * kqueue(2) support.
 *
 * The tun driver uses an array of tun_softc's based on the minor number
 * of the device.  kn->kn_hook gets set to the specific tun_softc.
 *
 * filt_tunread() sets kn->kn_data to the iface qsize
 * filt_tunwrite() sets kn->kn_data to the MTU size
 */
d787 1
a787 96
	int s;
	struct klist *klist;
	struct tun_softc *tp;
	struct ifnet *ifp;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

	ifp = &tp->tun_if;

	s = splimp();
	TUNDEBUG(("%s: tunselect\n", ifp->if_xname));
	splx(s);

	switch (kn->kn_filter) {
		case EVFILT_READ:
			klist = &tp->tun_rsel.si_note;
			kn->kn_fop = &tunread_filtops;
			break;
		case EVFILT_WRITE:
			klist = &tp->tun_wsel.si_note;
			kn->kn_fop = &tunwrite_filtops;
			break;
		default:
			return EPERM;	/* 1 */
	}

	kn->kn_hook = (caddr_t)tp;

	s = splhigh();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return 0;
}

void
filt_tunrdetach(struct knote *kn)
{
	int s;
	struct tun_softc *tp = (struct tun_softc *)kn->kn_hook;

	s = splhigh();
	SLIST_REMOVE(&tp->tun_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_tunread(struct knote *kn, long hint)
{
	int s;
	struct tun_softc *tp;
	struct ifnet *ifp;
	struct mbuf *m;

	tp = (struct tun_softc *)kn->kn_hook;
	ifp = &tp->tun_if;

	s = splnet();
	IFQ_POLL(&ifp->if_snd, m);
	if (m != NULL) {
		splx(s);
		kn->kn_data = ifp->if_snd.ifq_len;

		TUNDEBUG(("%s: tunkqread q=%d\n", ifp->if_xname,
					ifp->if_snd.ifq_len));
		return 1;
	}
	splx(s);
	TUNDEBUG(("%s: tunkqread waiting\n", ifp->if_xname));
	return 0;
}

void
filt_tunwdetach(struct knote *kn)
{
	int s;
	struct tun_softc *tp = (struct tun_softc *)kn->kn_hook;

	s = splhigh();
	SLIST_REMOVE(&tp->tun_wsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_tunwrite(struct knote *kn, long hint)
{
	struct tun_softc *tp;
	struct ifnet *ifp;

	tp = (struct tun_softc *)kn->kn_hook;
	ifp = &tp->tun_if;

	kn->kn_data = ifp->if_mtu;

	return 1;
d808 10
a817 2
	if (m != NULL)
		tun_wakeup(tp);
@


1.1.1.8
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.57 2004/01/12 04:48:25 tedu Exp $	*/
a223 5
	s = splhigh();
	klist_invalidate(&tp->tun_rsel.si_note);
	klist_invalidate(&tp->tun_wsel.si_note);
	splx(s);

d911 1
a911 2
	if (!(kn->kn_status & KN_DETACHED))
		SLIST_REMOVE(&tp->tun_rsel.si_note, kn, knote, kn_selnext);
a922 5
	if (kn->kn_status & KN_DETACHED) {
		kn->kn_data = 0;
		return 1;
	}

d948 1
a948 2
	if (!(kn->kn_status & KN_DETACHED))
		SLIST_REMOVE(&tp->tun_wsel.si_note, kn, knote, kn_selnext);
a956 5

	if (kn->kn_status & KN_DETACHED) {
		kn->kn_data = 0;
		return 1;
	}
@


1.1.1.9
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.59 2004/04/25 18:50:01 henning Exp $	*/
d732 1
a732 1
		if (error == 0 && uio->uio_resid > 0) {
a809 2
		if (!ifq->ifq_congestion)
			if_congestion(ifq);
@


