head	1.2;
access;
symbols
	tg-mergetmp-mirosx-1:1.2
	tg-mergefixes-1-branch:1.2.0.4
	tg-mergefixes-1-base:1.2
	MIROS_X:1.2.0.2
	MIROS_X_BASE:1.2
	tg-mergetmp-3:1.2
	MIRBSD_XP_MIRPPC:1.1.1.19.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.19
	MIRBSD_XP_SPARC:1.1.1.19.0.2
	MIRBSD_7quater:1.1.1.16
	cvs-200405160640:1.1.1.19
	cvs-200401271800:1.1.1.18
	cvs-200401261630:1.1.1.18
	cvs-200401021645:1.1.1.18
	MIRBSD_7_ALPHA:1.1.1.16.0.6
	MIRBSD_7:1.1.1.16.0.4
	cvs-200312222040:1.1.1.17
	MIRBSD_7ter:1.1.1.16
	MIRBSD_7_DEV:1.1.1.16.0.2
	cvs-200310020700:1.1.1.16
	cvs-200309271030:1.1.1.16
	cvs-200309261655:1.1.1.15
	cvs-200309251530:1.1.1.15
	cvs-200308302005:1.1.1.15
	cvs-200308171200:1.1.1.14
	ctm-3496:1.1.1.14
	ctm-3449:1.1.1.13
	ctm-3437:1.1.1.13
	cvs-200307191805:1.1.1.13
	ctm-3425:1.1.1.12
	cvs-200307091500:1.1.1.12
	cvs-200307072125:1.1.1.12
	ctm-3389:1.1.1.12
	cvs-200307021520:1.1.1.11
	cvs-200306301805:1.1.1.10
	cvs-200306301405:1.1.1.10
	cvs-200306291430:1.1.1.9
	ctm-3341:1.1.1.8
	MIRBSD_5:1.1.1.8
	cvs-200306091240:1.1.1.8
	cvs-200306082100:1.1.1.7
	ctm-3316:1.1.1.6
	ctm-3272:1.1.1.5
	ctm-3264:1.1.1.4
	cvs-200305071630:1.1.1.4
	ctm-3255:1.1.1.4
	ctm-3229:1.1.1.3
	MIRBSD_4:1.1.1.3
	ctm-3203:1.1.1.3
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.12.07.22.17.27;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.52.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.52.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.10.14.52.55;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.04.15.17.45.10;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.05.18.57.31;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.21.19.10.59;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.06.05.17.41.06;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.06.08.23.30.53;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.06.09.12.48.57;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.06.29.17.34.33;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.06.30.14.13.15;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2003.07.02.15.38.13;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2003.07.06.15.48.45;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2003.07.19.18.56.46;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2003.08.11.18.41.32;	author tg;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2003.08.30.23.26.40;	author tg;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2003.09.27.11.12.08;	author tg;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2003.12.22.21.04.43;	author tg;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2004.01.02.17.55.02;	author tg;	state Exp;
branches;
next	1.1.1.19;

1.1.1.19
date	2004.05.16.08.36.21;	author tg;	state Stab;
branches;
next	;


desc
@@


1.2
log
@remove pf features which are broken:
 ($interface) -> did never work correctly
 antispoof -> dangerous, false sense of security, side impacts, only for lazies

remove kernel stuff accordingly, but don't change ABI

update documentation
remove orphaned documentation nobody maintains
@
text
@/**	$MirBSD$ */
/*	$OpenBSD: pfvar.h,v 1.194 2004/05/11 07:34:11 dhartmei Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef _NET_PFVAR_H_
#define _NET_PFVAR_H_

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>

#include <net/radix.h>
#include <netinet/ip_ipsp.h>
#include <netinet/tcp_fsm.h>

struct ip;

#define	PF_TCPS_PROXY_SRC	((TCP_NSTATES)+0)
#define	PF_TCPS_PROXY_DST	((TCP_NSTATES)+1)

enum	{ PF_INOUT, PF_IN, PF_OUT };
enum	{ PF_LAN_EXT, PF_EXT_GWY, PF_ID };
enum	{ PF_PASS, PF_DROP, PF_SCRUB, PF_NAT, PF_NONAT,
	  PF_BINAT, PF_NOBINAT, PF_RDR, PF_NORDR, PF_SYNPROXY_DROP };
enum	{ PF_RULESET_SCRUB, PF_RULESET_FILTER, PF_RULESET_NAT,
	  PF_RULESET_BINAT, PF_RULESET_RDR, PF_RULESET_MAX };
enum	{ PF_OP_NONE, PF_OP_IRG, PF_OP_EQ, PF_OP_NE, PF_OP_LT,
	  PF_OP_LE, PF_OP_GT, PF_OP_GE, PF_OP_XRG, PF_OP_RRG };
enum	{ PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC, PF_DEBUG_NOISY };
enum	{ PF_CHANGE_NONE, PF_CHANGE_ADD_HEAD, PF_CHANGE_ADD_TAIL,
	  PF_CHANGE_ADD_BEFORE, PF_CHANGE_ADD_AFTER,
	  PF_CHANGE_REMOVE, PF_CHANGE_GET_TICKET };
/*
 * Note about PFTM_*: real indices into pf_rule.timeout[] come before
 * PFTM_MAX, special cases afterwards. See pf_state_expires().
 */
enum	{ PFTM_TCP_FIRST_PACKET, PFTM_TCP_OPENING, PFTM_TCP_ESTABLISHED,
	  PFTM_TCP_CLOSING, PFTM_TCP_FIN_WAIT, PFTM_TCP_CLOSED,
	  PFTM_UDP_FIRST_PACKET, PFTM_UDP_SINGLE, PFTM_UDP_MULTIPLE,
	  PFTM_ICMP_FIRST_PACKET, PFTM_ICMP_ERROR_REPLY,
	  PFTM_OTHER_FIRST_PACKET, PFTM_OTHER_SINGLE,
	  PFTM_OTHER_MULTIPLE, PFTM_FRAG, PFTM_INTERVAL,
	  PFTM_ADAPTIVE_START, PFTM_ADAPTIVE_END, PFTM_SRC_NODE,
	  PFTM_TS_DIFF, PFTM_MAX, PFTM_PURGE, PFTM_UNTIL_PACKET };
enum	{ PF_NOPFROUTE, PF_FASTROUTE, PF_ROUTETO, PF_DUPTO, PF_REPLYTO };
enum	{ PF_LIMIT_STATES, PF_LIMIT_SRC_NODES, PF_LIMIT_FRAGS, PF_LIMIT_MAX };
#define PF_POOL_IDMASK		0x0f
enum	{ PF_POOL_NONE, PF_POOL_BITMASK, PF_POOL_RANDOM,
	  PF_POOL_SRCHASH, PF_POOL_ROUNDROBIN };
enum	{ PF_ADDR_ADDRMASK, PF_ADDR_NOROUTE, PF_ADDR_DYNIFTL_doesnotwork,
	  PF_ADDR_TABLE };
#define PF_POOL_TYPEMASK	0x0f
#define PF_POOL_STICKYADDR	0x20
#define	PF_WSCALE_FLAG		0x80
#define	PF_WSCALE_MASK		0x0f

struct pf_addr {
	union {
		struct in_addr		v4;
		struct in6_addr		v6;
		u_int8_t		addr8[16];
		u_int16_t		addr16[8];
		u_int32_t		addr32[4];
	} pfa;		    /* 128-bit address */
#define v4	pfa.v4
#define v6	pfa.v6
#define addr8	pfa.addr8
#define addr16	pfa.addr16
#define addr32	pfa.addr32
};

#define	PF_TABLE_NAME_SIZE	 32

#define PFI_AFLAG_NETWORK	0x01
#define PFI_AFLAG_BROADCAST	0x02
#define PFI_AFLAG_PEER		0x04
#define PFI_AFLAG_MODEMASK	0x07
#define PFI_AFLAG_NOALIAS	0x08

struct pf_addr_wrap {
	union {
		struct {
			struct pf_addr		 addr;
			struct pf_addr		 mask;
		}			 a;
		char			 ifname[IFNAMSIZ];
		char			 tblname[PF_TABLE_NAME_SIZE];
	}			 v;
	union {
		struct pfi_dynaddr	*dyn;
		struct pfr_ktable	*tbl;
		int			 dyncnt;
		int			 tblcnt;
	}			 p;
	u_int8_t		 type;		/* PF_ADDR_* */
	u_int8_t		 iflags;	/* PFI_AFLAG_* */
};

#ifdef _KERNEL

struct pfi_dynaddr {
	struct pf_addr		 pfid_addr4;
	struct pf_addr		 pfid_mask4;
	struct pf_addr		 pfid_addr6;
	struct pf_addr		 pfid_mask6;
	struct pfr_ktable	*pfid_kt;
	struct pfi_kif		*pfid_kif;
	void			*pfid_hook_cookie;
	int			 pfid_net;	/* optional mask, or 128 */
	int			 pfid_acnt4;	/* address count, IPv4 */
	int			 pfid_acnt6;	/* address count, IPv6 */
	sa_family_t		 pfid_af;	/* rule address family */
	u_int8_t		 pfid_iflags;	/* PFI_AFLAG_* */
};

/*
 * Address manipulation macros
 */

#ifdef INET
#ifndef INET6
#define PF_INET_ONLY
#endif /* ! INET6 */
#endif /* INET */

#ifdef INET6
#ifndef INET
#define PF_INET6_ONLY
#endif /* ! INET */
#endif /* INET6 */

#ifdef INET
#ifdef INET6
#define PF_INET_INET6
#endif /* INET6 */
#endif /* INET */

#else

#define PF_INET_INET6

#endif /* _KERNEL */

/* Both IPv4 and IPv6 */
#ifdef PF_INET_INET6

#define PF_AEQ(a, b, c) \
	((c == AF_INET && (a)->addr32[0] == (b)->addr32[0]) || \
	((a)->addr32[3] == (b)->addr32[3] && \
	(a)->addr32[2] == (b)->addr32[2] && \
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[0] == (b)->addr32[0])) \

#define PF_ANEQ(a, b, c) \
	((c == AF_INET && (a)->addr32[0] != (b)->addr32[0]) || \
	((a)->addr32[3] != (b)->addr32[3] || \
	(a)->addr32[2] != (b)->addr32[2] || \
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[0] != (b)->addr32[0])) \

#define PF_AZERO(a, c) \
	((c == AF_INET && !(a)->addr32[0]) || \
	(!(a)->addr32[0] && !(a)->addr32[1] && \
	!(a)->addr32[2] && !(a)->addr32[3] )) \

#define PF_MATCHA(n, a, m, b, f) \
	pf_match_addr(n, a, m, b, f)

#define PF_ACPY(a, b, f) \
	pf_addrcpy(a, b, f)

#define PF_AINC(a, f) \
	pf_addr_inc(a, f)

#define PF_POOLMASK(a, b, c, d, f) \
	pf_poolmask(a, b, c, d, f)

#else

/* Just IPv6 */

#ifdef PF_INET6_ONLY

#define PF_AEQ(a, b, c) \
	((a)->addr32[3] == (b)->addr32[3] && \
	(a)->addr32[2] == (b)->addr32[2] && \
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[0] == (b)->addr32[0]) \

#define PF_ANEQ(a, b, c) \
	((a)->addr32[3] != (b)->addr32[3] || \
	(a)->addr32[2] != (b)->addr32[2] || \
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[0] != (b)->addr32[0]) \

#define PF_AZERO(a, c) \
	(!(a)->addr32[0] && \
	!(a)->addr32[1] && \
	!(a)->addr32[2] && \
	!(a)->addr32[3] ) \

#define PF_MATCHA(n, a, m, b, f) \
	pf_match_addr(n, a, m, b, f)

#define PF_ACPY(a, b, f) \
	pf_addrcpy(a, b, f)

#define PF_AINC(a, f) \
	pf_addr_inc(a, f)

#define PF_POOLMASK(a, b, c, d, f) \
	pf_poolmask(a, b, c, d, f)

#else

/* Just IPv4 */
#ifdef PF_INET_ONLY

#define PF_AEQ(a, b, c) \
	((a)->addr32[0] == (b)->addr32[0])

#define PF_ANEQ(a, b, c) \
	((a)->addr32[0] != (b)->addr32[0])

#define PF_AZERO(a, c) \
	(!(a)->addr32[0])

#define PF_MATCHA(n, a, m, b, f) \
	pf_match_addr(n, a, m, b, f)

#define PF_ACPY(a, b, f) \
	(a)->v4.s_addr = (b)->v4.s_addr

#define PF_AINC(a, f) \
	do { \
		(a)->addr32[0] = htonl(ntohl((a)->addr32[0]) + 1); \
	} while (0)

#define PF_POOLMASK(a, b, c, d, f) \
	do { \
		(a)->addr32[0] = ((b)->addr32[0] & (c)->addr32[0]) | \
		(((c)->addr32[0] ^ 0xffffffff ) & (d)->addr32[0]); \
	} while (0)

#endif /* PF_INET_ONLY */
#endif /* PF_INET6_ONLY */
#endif /* PF_INET_INET6 */

#define	PF_MISMATCHAW(aw, x, af, not)				\
	(							\
		(((aw)->type == PF_ADDR_NOROUTE &&		\
		    pf_routable((x), (af))) ||			\
		((aw)->type == PF_ADDR_TABLE &&			\
		    !pfr_match_addr((aw)->p.tbl, (x), (af))) ||	\
		((aw)->type == PF_ADDR_ADDRMASK &&		\
		    !PF_AZERO(&(aw)->v.a.mask, (af)) &&		\
		    !PF_MATCHA(0, &(aw)->v.a.addr,		\
		    &(aw)->v.a.mask, (x), (af)))) !=		\
		(not)						\
	)

struct pf_rule_uid {
	uid_t		 uid[2];
	u_int8_t	 op;
};

struct pf_rule_gid {
	uid_t		 gid[2];
	u_int8_t	 op;
};

struct pf_rule_addr {
	struct pf_addr_wrap	 addr;
	u_int16_t		 port[2];
	u_int8_t		 not;
	u_int8_t		 port_op;
};

struct pf_pooladdr {
	struct pf_addr_wrap		 addr;
	TAILQ_ENTRY(pf_pooladdr)	 entries;
	char				 ifname[IFNAMSIZ];
	struct pfi_kif			*kif;
};

TAILQ_HEAD(pf_palist, pf_pooladdr);

struct pf_poolhashkey {
	union {
		u_int8_t		key8[16];
		u_int16_t		key16[8];
		u_int32_t		key32[4];
	} pfk;		    /* 128-bit hash key */
#define key8	pfk.key8
#define key16	pfk.key16
#define key32	pfk.key32
};

struct pf_pool {
	struct pf_palist	 list;
	struct pf_pooladdr	*cur;
	struct pf_poolhashkey	 key;
	struct pf_addr		 counter;
	int			 tblidx;
	u_int16_t		 proxy_port[2];
	u_int8_t		 port_op;
	u_int8_t		 opts;
};


/* A packed Operating System description for fingerprinting */
typedef u_int32_t pf_osfp_t;
#define PF_OSFP_ANY	((pf_osfp_t)0)
#define PF_OSFP_UNKNOWN	((pf_osfp_t)-1)
#define PF_OSFP_NOMATCH	((pf_osfp_t)-2)

struct pf_osfp_entry {
	SLIST_ENTRY(pf_osfp_entry) fp_entry;
	pf_osfp_t		fp_os;
	int			fp_enflags;
#define PF_OSFP_EXPANDED	0x001		/* expanded entry */
#define PF_OSFP_GENERIC		0x002		/* generic signature */
#define PF_OSFP_NODETAIL	0x004		/* no p0f details */
#define PF_OSFP_LEN	32
	char			fp_class_nm[PF_OSFP_LEN];
	char			fp_version_nm[PF_OSFP_LEN];
	char			fp_subtype_nm[PF_OSFP_LEN];
};
#define PF_OSFP_ENTRY_EQ(a, b) \
    ((a)->fp_os == (b)->fp_os && \
    memcmp((a)->fp_class_nm, (b)->fp_class_nm, PF_OSFP_LEN) == 0 && \
    memcmp((a)->fp_version_nm, (b)->fp_version_nm, PF_OSFP_LEN) == 0 && \
    memcmp((a)->fp_subtype_nm, (b)->fp_subtype_nm, PF_OSFP_LEN) == 0)

/* handle pf_osfp_t packing */
#define _FP_RESERVED_BIT	1  /* For the special negative #defines */
#define _FP_UNUSED_BITS		1
#define _FP_CLASS_BITS		10 /* OS Class (Windows, Linux) */
#define _FP_VERSION_BITS	10 /* OS version (95, 98, NT, 2.4.54, 3.2) */
#define _FP_SUBTYPE_BITS	10 /* patch level (NT SP4, SP3, ECN patch) */
#define PF_OSFP_UNPACK(osfp, class, version, subtype) do { \
	(class) = ((osfp) >> (_FP_VERSION_BITS+_FP_SUBTYPE_BITS)) & \
	    ((1 << _FP_CLASS_BITS) - 1); \
	(version) = ((osfp) >> _FP_SUBTYPE_BITS) & \
	    ((1 << _FP_VERSION_BITS) - 1);\
	(subtype) = (osfp) & ((1 << _FP_SUBTYPE_BITS) - 1); \
} while(0)
#define PF_OSFP_PACK(osfp, class, version, subtype) do { \
	(osfp) = ((class) & ((1 << _FP_CLASS_BITS) - 1)) << (_FP_VERSION_BITS \
	    + _FP_SUBTYPE_BITS); \
	(osfp) |= ((version) & ((1 << _FP_VERSION_BITS) - 1)) << \
	    _FP_SUBTYPE_BITS; \
	(osfp) |= (subtype) & ((1 << _FP_SUBTYPE_BITS) - 1); \
} while(0)

/* the fingerprint of an OSes TCP SYN packet */
typedef u_int64_t	pf_tcpopts_t;
struct pf_os_fingerprint {
	SLIST_HEAD(pf_osfp_enlist, pf_osfp_entry) fp_oses; /* list of matches */
	pf_tcpopts_t		fp_tcpopts;	/* packed TCP options */
	u_int16_t		fp_wsize;	/* TCP window size */
	u_int16_t		fp_psize;	/* ip->ip_len */
	u_int16_t		fp_mss;		/* TCP MSS */
	u_int16_t		fp_flags;
#define PF_OSFP_WSIZE_MOD	0x0001		/* Window modulus */
#define PF_OSFP_WSIZE_DC	0x0002		/* Window don't care */
#define PF_OSFP_WSIZE_MSS	0x0004		/* Window multiple of MSS */
#define PF_OSFP_WSIZE_MTU	0x0008		/* Window multiple of MTU */
#define PF_OSFP_PSIZE_MOD	0x0010		/* packet size modulus */
#define PF_OSFP_PSIZE_DC	0x0020		/* packet size don't care */
#define PF_OSFP_WSCALE		0x0040		/* TCP window scaling */
#define PF_OSFP_WSCALE_MOD	0x0080		/* TCP window scale modulus */
#define PF_OSFP_WSCALE_DC	0x0100		/* TCP window scale dont-care */
#define PF_OSFP_MSS		0x0200		/* TCP MSS */
#define PF_OSFP_MSS_MOD		0x0400		/* TCP MSS modulus */
#define PF_OSFP_MSS_DC		0x0800		/* TCP MSS dont-care */
#define PF_OSFP_DF		0x1000		/* IPv4 don't fragment bit */
#define PF_OSFP_TS0		0x2000		/* Zero timestamp */
	u_int8_t		fp_optcnt;	/* TCP option count */
	u_int8_t		fp_wscale;	/* TCP window scaling */
	u_int8_t		fp_ttl;		/* IPv4 TTL */
#define PF_OSFP_MAXTTL_OFFSET	40
/* TCP options packing */
#define PF_OSFP_TCPOPT_NOP	0x0		/* TCP NOP option */
#define PF_OSFP_TCPOPT_WSCALE	0x1		/* TCP window scaling option */
#define PF_OSFP_TCPOPT_MSS	0x2		/* TCP max segment size opt */
#define PF_OSFP_TCPOPT_SACK	0x3		/* TCP SACK OK option */
#define PF_OSFP_TCPOPT_TS	0x4		/* TCP timestamp option */
#define PF_OSFP_TCPOPT_BITS	3		/* bits used by each option */
#define PF_OSFP_MAX_OPTS \
    (sizeof(((struct pf_os_fingerprint *)0)->fp_tcpopts) * 8) \
    / PF_OSFP_TCPOPT_BITS

	SLIST_ENTRY(pf_os_fingerprint)	fp_next;
};

struct pf_osfp_ioctl {
	struct pf_osfp_entry	fp_os;
	pf_tcpopts_t		fp_tcpopts;	/* packed TCP options */
	u_int16_t		fp_wsize;	/* TCP window size */
	u_int16_t		fp_psize;	/* ip->ip_len */
	u_int16_t		fp_mss;		/* TCP MSS */
	u_int16_t		fp_flags;
	u_int8_t		fp_optcnt;	/* TCP option count */
	u_int8_t		fp_wscale;	/* TCP window scaling */
	u_int8_t		fp_ttl;		/* IPv4 TTL */

	int			fp_getnum;	/* DIOCOSFPGET number */
};


union pf_rule_ptr {
	struct pf_rule		*ptr;
	u_int32_t		 nr;
};

struct pf_rule {
	struct pf_rule_addr	 src;
	struct pf_rule_addr	 dst;
#define PF_SKIP_IFP		0
#define PF_SKIP_DIR		1
#define PF_SKIP_AF		2
#define PF_SKIP_PROTO		3
#define PF_SKIP_SRC_ADDR	4
#define PF_SKIP_SRC_PORT	5
#define PF_SKIP_DST_ADDR	6
#define PF_SKIP_DST_PORT	7
#define PF_SKIP_COUNT		8
	union pf_rule_ptr	 skip[PF_SKIP_COUNT];
#define PF_RULE_LABEL_SIZE	 64
	char			 label[PF_RULE_LABEL_SIZE];
#define PF_QNAME_SIZE		 16
	char			 ifname[IFNAMSIZ];
	char			 qname[PF_QNAME_SIZE];
	char			 pqname[PF_QNAME_SIZE];
#define	PF_ANCHOR_NAME_SIZE	 16
	char			 anchorname[PF_ANCHOR_NAME_SIZE];
#define	PF_TAG_NAME_SIZE	 16
	char			 tagname[PF_TAG_NAME_SIZE];
	char			 match_tagname[PF_TAG_NAME_SIZE];

	TAILQ_ENTRY(pf_rule)	 entries;
	struct pf_pool		 rpool;

	u_int64_t		 evaluations;
	u_int64_t		 packets;
	u_int64_t		 bytes;

	struct pfi_kif		*kif;
	struct pf_anchor	*anchor;

	pf_osfp_t		 os_fingerprint;

	u_int32_t		 timeout[PFTM_MAX];
	u_int32_t		 states;
	u_int32_t		 max_states;
	u_int32_t		 src_nodes;
	u_int32_t		 max_src_nodes;
	u_int32_t		 max_src_states;
	u_int32_t		 qid;
	u_int32_t		 pqid;
	u_int32_t		 rt_listid;
	u_int32_t		 nr;
	u_int32_t		 prob;

	u_int16_t		 return_icmp;
	u_int16_t		 return_icmp6;
	u_int16_t		 max_mss;
	u_int16_t		 tag;
	u_int16_t		 match_tag;

	struct pf_rule_uid	 uid;
	struct pf_rule_gid	 gid;

	u_int32_t		 rule_flag;
	u_int8_t		 action;
	u_int8_t		 direction;
	u_int8_t		 log;
	u_int8_t		 quick;
	u_int8_t		 ifnot;
	u_int8_t		 match_tag_not;
	u_int8_t		 natpass;

#define PF_STATE_NORMAL		0x1
#define PF_STATE_MODULATE	0x2
#define PF_STATE_SYNPROXY	0x3
	u_int8_t		 keep_state;
	sa_family_t		 af;
	u_int8_t		 proto;
	u_int8_t		 type;
	u_int8_t		 code;
	u_int8_t		 flags;
	u_int8_t		 flagset;
	u_int8_t		 min_ttl;
	u_int8_t		 allow_opts;
	u_int8_t		 rt;
	u_int8_t		 return_ttl;
	u_int8_t		 tos;
};

/* rule flags */
#define	PFRULE_DROP		0x0000
#define	PFRULE_RETURNRST	0x0001
#define	PFRULE_FRAGMENT		0x0002
#define	PFRULE_RETURNICMP	0x0004
#define	PFRULE_RETURN		0x0008
#define	PFRULE_NOSYNC		0x0010
#define PFRULE_SRCTRACK		0x0020  /* track source states */
#define PFRULE_RULESRCTRACK	0x0040  /* per rule */

/* scrub flags */
#define	PFRULE_NODF		0x0100
#define	PFRULE_FRAGCROP		0x0200	/* non-buffering frag cache */
#define	PFRULE_FRAGDROP		0x0400	/* drop funny fragments */
#define PFRULE_RANDOMID		0x0800
#define PFRULE_REASSEMBLE_TCP	0x1000

/* rule flags again */
#define PFRULE_IFBOUND		0x00010000	/* if-bound */
#define PFRULE_GRBOUND		0x00020000	/* group-bound */

#define PFSTATE_HIWAT		10000	/* default state table size */

struct pf_src_node {
	RB_ENTRY(pf_src_node) entry;
	struct pf_addr	 addr;
	struct pf_addr	 raddr;
	union pf_rule_ptr rule;
	struct pfi_kif	*kif;
	u_int32_t	 bytes;
	u_int32_t	 packets;
	u_int32_t	 states;
	u_int32_t	 creation;
	u_int32_t	 expire;
	sa_family_t	 af;
	u_int8_t	 ruletype;
};

#define PFSNODE_HIWAT		10000	/* default source node table size */

struct pf_state_scrub {
	struct timeval	pfss_last;	/* time received last packet	*/
	u_int32_t	pfss_tsecr;	/* last echoed timestamp	*/
	u_int32_t	pfss_tsval;	/* largest timestamp		*/
	u_int32_t	pfss_tsval0;	/* original timestamp		*/
	u_int16_t	pfss_flags;
#define PFSS_TIMESTAMP	0x0001		/* modulate timestamp		*/
#define PFSS_PAWS	0x0010		/* stricter PAWS checks		*/
#define PFSS_PAWS_IDLED	0x0020		/* was idle too long.  no PAWS	*/
#define PFSS_DATA_TS	0x0040		/* timestamp on data packets	*/
#define PFSS_DATA_NOTS	0x0080		/* no timestamp on data packets	*/
	u_int8_t	pfss_ttl;	/* stashed TTL			*/
	u_int8_t	pad;
	u_int32_t	pfss_ts_mod;	/* timestamp modulation		*/
};

struct pf_state_host {
	struct pf_addr	addr;
	u_int16_t	port;
	u_int16_t	pad;
};

struct pf_state_peer {
	u_int32_t	seqlo;		/* Max sequence number sent	*/
	u_int32_t	seqhi;		/* Max the other end ACKd + win	*/
	u_int32_t	seqdiff;	/* Sequence number modulator	*/
	u_int16_t	max_win;	/* largest window (pre scaling)	*/
	u_int8_t	state;		/* active state level		*/
	u_int8_t	wscale;		/* window scaling factor	*/
	u_int16_t	mss;		/* Maximum segment size option	*/
	struct pf_state_scrub	*scrub;	/* state is scrubbed		*/
};

TAILQ_HEAD(pf_state_queue, pf_state);

struct pf_state {
	u_int64_t	 id;
	union {
		struct {
			RB_ENTRY(pf_state)	 entry_lan_ext;
			RB_ENTRY(pf_state)	 entry_ext_gwy;
			RB_ENTRY(pf_state)	 entry_id;
			TAILQ_ENTRY(pf_state)	 entry_updates;
			struct pfi_kif		*kif;
		} s;
		char	 ifname[IFNAMSIZ];
	} u;
	struct pf_state_host lan;
	struct pf_state_host gwy;
	struct pf_state_host ext;
	struct pf_state_peer src;
	struct pf_state_peer dst;
	union pf_rule_ptr rule;
	union pf_rule_ptr anchor;
	union pf_rule_ptr nat_rule;
	struct pf_addr	 rt_addr;
	struct pfi_kif	*rt_kif;
	struct pf_src_node	*src_node;
	struct pf_src_node	*nat_src_node;
	u_int32_t	 creation;
	u_int32_t	 expire;
	u_int32_t	 pfsync_time;
	u_int32_t	 packets[2];
	u_int32_t	 bytes[2];
	u_int32_t	 creatorid;
	sa_family_t	 af;
	u_int8_t	 proto;
	u_int8_t	 direction;
	u_int8_t	 log;
	u_int8_t	 allow_opts;
	u_int8_t	 timeout;
	u_int8_t	 sync_flags;
#define	PFSTATE_NOSYNC	 0x01
#define	PFSTATE_FROMSYNC 0x02
	u_int8_t	 pad;
};

TAILQ_HEAD(pf_rulequeue, pf_rule);

struct pf_anchor;

struct pf_ruleset {
	TAILQ_ENTRY(pf_ruleset)	 entries;
#define PF_RULESET_NAME_SIZE	 16
	char			 name[PF_RULESET_NAME_SIZE];
	struct {
		struct pf_rulequeue	 queues[2];
		struct {
			struct pf_rulequeue	*ptr;
			u_int32_t		 ticket;
			int			 open;
		}			 active, inactive;
	}			 rules[PF_RULESET_MAX];
	struct pf_anchor	*anchor;
	u_int32_t		 tticket;
	int			 tables;
	int			 topen;
};

TAILQ_HEAD(pf_rulesetqueue, pf_ruleset);

struct pf_anchor {
	TAILQ_ENTRY(pf_anchor)	 entries;
	char			 name[PF_ANCHOR_NAME_SIZE];
	struct pf_rulesetqueue	 rulesets;
	int			 tables;
	int			 refcnt;	/* anchor rules */
};

TAILQ_HEAD(pf_anchorqueue, pf_anchor);

#define PF_RESERVED_ANCHOR	"_pf"
#define PF_INTERFACE_RULESET	"_if"

#define PFR_TFLAG_PERSIST	0x00000001
#define PFR_TFLAG_CONST		0x00000002
#define PFR_TFLAG_ACTIVE	0x00000004
#define PFR_TFLAG_INACTIVE	0x00000008
#define PFR_TFLAG_REFERENCED	0x00000010
#define PFR_TFLAG_REFDANCHOR	0x00000020
#define PFR_TFLAG_USRMASK	0x00000003
#define PFR_TFLAG_SETMASK	0x0000003C
#define PFR_TFLAG_ALLMASK	0x0000003F

struct pfr_table {
	char			 pfrt_anchor[PF_ANCHOR_NAME_SIZE];
	char			 pfrt_ruleset[PF_RULESET_NAME_SIZE];
	char			 pfrt_name[PF_TABLE_NAME_SIZE];
	u_int32_t		 pfrt_flags;
	u_int8_t		 pfrt_fback;
};

enum { PFR_FB_NONE, PFR_FB_MATCH, PFR_FB_ADDED, PFR_FB_DELETED,
	PFR_FB_CHANGED, PFR_FB_CLEARED, PFR_FB_DUPLICATE,
	PFR_FB_NOTMATCH, PFR_FB_CONFLICT, PFR_FB_MAX };

struct pfr_addr {
	union {
		struct in_addr	 _pfra_ip4addr;
		struct in6_addr	 _pfra_ip6addr;
	}		 pfra_u;
	u_int8_t	 pfra_af;
	u_int8_t	 pfra_net;
	u_int8_t	 pfra_not;
	u_int8_t	 pfra_fback;
};
#define	pfra_ip4addr	pfra_u._pfra_ip4addr
#define	pfra_ip6addr	pfra_u._pfra_ip6addr

enum { PFR_DIR_IN, PFR_DIR_OUT, PFR_DIR_MAX };
enum { PFR_OP_BLOCK, PFR_OP_PASS, PFR_OP_ADDR_MAX, PFR_OP_TABLE_MAX };
#define PFR_OP_XPASS	PFR_OP_ADDR_MAX

struct pfr_astats {
	struct pfr_addr	 pfras_a;
	u_int64_t	 pfras_packets[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t	 pfras_bytes[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	long		 pfras_tzero;
};

enum { PFR_REFCNT_RULE, PFR_REFCNT_ANCHOR, PFR_REFCNT_MAX };

struct pfr_tstats {
	struct pfr_table pfrts_t;
	u_int64_t	 pfrts_packets[PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_bytes[PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_match;
	u_int64_t	 pfrts_nomatch;
	long		 pfrts_tzero;
	int		 pfrts_cnt;
	int		 pfrts_refcnt[PFR_REFCNT_MAX];
};
#define	pfrts_name	pfrts_t.pfrt_name
#define pfrts_flags	pfrts_t.pfrt_flags

SLIST_HEAD(pfr_kentryworkq, pfr_kentry);
struct pfr_kentry {
	struct radix_node	 pfrke_node[2];
	union sockaddr_union	 pfrke_sa;
	u_int64_t		 pfrke_packets[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t		 pfrke_bytes[PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	SLIST_ENTRY(pfr_kentry)	 pfrke_workq;
	long			 pfrke_tzero;
	u_int8_t		 pfrke_af;
	u_int8_t		 pfrke_net;
	u_int8_t		 pfrke_not;
	u_int8_t		 pfrke_mark;
};

SLIST_HEAD(pfr_ktableworkq, pfr_ktable);
RB_HEAD(pfr_ktablehead, pfr_ktable);
struct pfr_ktable {
	struct pfr_tstats	 pfrkt_ts;
	RB_ENTRY(pfr_ktable)	 pfrkt_tree;
	SLIST_ENTRY(pfr_ktable)	 pfrkt_workq;
	struct radix_node_head	*pfrkt_ip4;
	struct radix_node_head	*pfrkt_ip6;
	struct pfr_ktable	*pfrkt_shadow;
	struct pfr_ktable	*pfrkt_root;
	struct pf_ruleset	*pfrkt_rs;
	long			 pfrkt_larg;
	int			 pfrkt_nflags;
};
#define pfrkt_t		pfrkt_ts.pfrts_t
#define pfrkt_name	pfrkt_t.pfrt_name
#define pfrkt_anchor	pfrkt_t.pfrt_anchor
#define pfrkt_ruleset	pfrkt_t.pfrt_ruleset
#define pfrkt_flags	pfrkt_t.pfrt_flags
#define pfrkt_cnt	pfrkt_ts.pfrts_cnt
#define pfrkt_refcnt	pfrkt_ts.pfrts_refcnt
#define pfrkt_packets	pfrkt_ts.pfrts_packets
#define pfrkt_bytes	pfrkt_ts.pfrts_bytes
#define pfrkt_match	pfrkt_ts.pfrts_match
#define pfrkt_nomatch	pfrkt_ts.pfrts_nomatch
#define pfrkt_tzero	pfrkt_ts.pfrts_tzero

RB_HEAD(pf_state_tree_lan_ext, pf_state);
RB_PROTOTYPE(pf_state_tree_lan_ext, pf_state,
    u.s.entry_lan_ext, pf_state_compare_lan_ext);

RB_HEAD(pf_state_tree_ext_gwy, pf_state);
RB_PROTOTYPE(pf_state_tree_ext_gwy, pf_state,
    u.s.entry_ext_gwy, pf_state_compare_ext_gwy);

struct pfi_if {
	char				 pfif_name[IFNAMSIZ];
	u_int64_t			 pfif_packets[2][2][2];
	u_int64_t			 pfif_bytes[2][2][2];
	u_int64_t			 pfif_addcnt;
	u_int64_t			 pfif_delcnt;
	long				 pfif_tzero;
	int				 pfif_states;
	int				 pfif_rules;
	int				 pfif_flags;
};

TAILQ_HEAD(pfi_grouphead, pfi_kif);
TAILQ_HEAD(pfi_statehead, pfi_kif);
RB_HEAD(pfi_ifhead, pfi_kif);
struct pfi_kif {
	struct pfi_if			 pfik_if;
	RB_ENTRY(pfi_kif)		 pfik_tree;
	struct pf_state_tree_lan_ext	 pfik_lan_ext;
	struct pf_state_tree_ext_gwy	 pfik_ext_gwy;
	struct pfi_grouphead		 pfik_grouphead;
	TAILQ_ENTRY(pfi_kif)		 pfik_instances;
	TAILQ_ENTRY(pfi_kif)		 pfik_w_states;
	struct hook_desc_head		*pfik_ah_head;
	void				*pfik_ah_cookie;
	struct pfi_kif			*pfik_parent;
	struct ifnet			*pfik_ifp;
	int				 pfik_states;
	int				 pfik_rules;
};
#define pfik_name	pfik_if.pfif_name
#define pfik_packets	pfik_if.pfif_packets
#define pfik_bytes	pfik_if.pfif_bytes
#define pfik_tzero	pfik_if.pfif_tzero
#define pfik_flags	pfik_if.pfif_flags
#define pfik_addcnt	pfik_if.pfif_addcnt
#define pfik_delcnt	pfik_if.pfif_delcnt
#define pfik_states	pfik_if.pfif_states
#define pfik_rules	pfik_if.pfif_rules

#define PFI_IFLAG_GROUP		0x0001	/* group of interfaces */
#define PFI_IFLAG_INSTANCE	0x0002	/* single instance */
#define PFI_IFLAG_CLONABLE	0x0010	/* clonable group */
#define PFI_IFLAG_DYNAMIC	0x0020	/* dynamic group */
#define PFI_IFLAG_ATTACHED	0x0040	/* interface attached */

struct pf_pdesc {
	u_int64_t	 tot_len;	/* Make Mickey money */
	union {
		struct tcphdr		*tcp;
		struct udphdr		*udp;
		struct icmp		*icmp;
#ifdef INET6
		struct icmp6_hdr	*icmp6;
#endif /* INET6 */
		void			*any;
	} hdr;
	struct pf_addr	 baddr;		/* address before translation */
	struct pf_addr	 naddr;		/* address after translation */
	struct pf_rule	*nat_rule;	/* nat/rdr rule applied to packet */
	struct pf_addr	*src;
	struct pf_addr	*dst;
	struct ether_header
			*eh;
	u_int16_t	*ip_sum;
	u_int32_t	 p_len;		/* total length of payload */
	u_int16_t	 flags;		/* Let SCRUB trigger behavior in
					 * state code. Easier than tags */
#define PFDESC_TCP_NORM	0x0001		/* TCP shall be statefully scrubbed */
#define PFDESC_IP_REAS	0x0002		/* IP frags would've been reassembled */
	sa_family_t	 af;
	u_int8_t	 proto;
	u_int8_t	 tos;
};

/* flags for RDR options */
#define PF_DPORT_RANGE	0x01		/* Dest port uses range */
#define PF_RPORT_RANGE	0x02		/* RDR'ed port uses range */

/* Reasons code for passing/dropping a packet */
#define PFRES_MATCH	0		/* Explicit match of a rule */
#define PFRES_BADOFF	1		/* Bad offset for pull_hdr */
#define PFRES_FRAG	2		/* Dropping following fragment */
#define PFRES_SHORT	3		/* Dropping short packet */
#define PFRES_NORM	4		/* Dropping by normalizer */
#define PFRES_MEMORY	5		/* Dropped due to lacking mem */
#define PFRES_TS	6		/* Bad TCP Timestamp (RFC1323) */
#define PFRES_MAX	7		/* total+1 */

#define PFRES_NAMES { \
	"match", \
	"bad-offset", \
	"fragment", \
	"short", \
	"normalize", \
	"memory", \
	"bad-timestamp", \
	NULL \
}

/* UDP state enumeration */
#define PFUDPS_NO_TRAFFIC	0
#define PFUDPS_SINGLE		1
#define PFUDPS_MULTIPLE		2

#define PFUDPS_NSTATES		3	/* number of state levels */

#define PFUDPS_NAMES { \
	"NO_TRAFFIC", \
	"SINGLE", \
	"MULTIPLE", \
	NULL \
}

/* Other protocol state enumeration */
#define PFOTHERS_NO_TRAFFIC	0
#define PFOTHERS_SINGLE		1
#define PFOTHERS_MULTIPLE	2

#define PFOTHERS_NSTATES	3	/* number of state levels */

#define PFOTHERS_NAMES { \
	"NO_TRAFFIC", \
	"SINGLE", \
	"MULTIPLE", \
	NULL \
}

#define FCNT_STATE_SEARCH	0
#define FCNT_STATE_INSERT	1
#define FCNT_STATE_REMOVALS	2
#define FCNT_MAX		3

#define SCNT_SRC_NODE_SEARCH	0
#define SCNT_SRC_NODE_INSERT	1
#define SCNT_SRC_NODE_REMOVALS	2
#define SCNT_MAX		3

#define ACTION_SET(a, x) \
	do { \
		if ((a) != NULL) \
			*(a) = (x); \
	} while (0)

#define REASON_SET(a, x) \
	do { \
		if ((a) != NULL) \
			*(a) = (x); \
		if (x < PFRES_MAX) \
			pf_status.counters[x]++; \
	} while (0)

struct pf_status {
	u_int64_t	counters[PFRES_MAX];
	u_int64_t	fcounters[FCNT_MAX];
	u_int64_t	scounters[SCNT_MAX];
	u_int64_t	pcounters[2][2][3];
	u_int64_t	bcounters[2][2];
	u_int64_t	stateid;
	u_int32_t	running;
	u_int32_t	states;
	u_int32_t	src_nodes;
	u_int32_t	since;
	u_int32_t	debug;
	u_int32_t	hostid;
	char		ifname[IFNAMSIZ];
};

struct cbq_opts {
	u_int		minburst;
	u_int		maxburst;
	u_int		pktsize;
	u_int		maxpktsize;
	u_int		ns_per_byte;
	u_int		maxidle;
	int		minidle;
	u_int		offtime;
	int		flags;
};

struct priq_opts {
	int		flags;
};

struct hfsc_opts {
	/* real-time service curve */
	u_int		rtsc_m1;	/* slope of the 1st segment in bps */
	u_int		rtsc_d;		/* the x-projection of m1 in msec */
	u_int		rtsc_m2;	/* slope of the 2nd segment in bps */
	/* link-sharing service curve */
	u_int		lssc_m1;
	u_int		lssc_d;
	u_int		lssc_m2;
	/* upper-limit service curve */
	u_int		ulsc_m1;
	u_int		ulsc_d;
	u_int		ulsc_m2;
	int		flags;
};

struct pf_altq {
	char			 ifname[IFNAMSIZ];

	void			*altq_disc;	/* discipline-specific state */
	TAILQ_ENTRY(pf_altq)	 entries;

	/* scheduler spec */
	u_int8_t		 scheduler;	/* scheduler type */
	u_int16_t		 tbrsize;	/* tokenbucket regulator size */
	u_int32_t		 ifbandwidth;	/* interface bandwidth */

	/* queue spec */
	char			 qname[PF_QNAME_SIZE];	/* queue name */
	char			 parent[PF_QNAME_SIZE];	/* parent name */
	u_int32_t		 parent_qid;	/* parent queue id */
	u_int32_t		 bandwidth;	/* queue bandwidth */
	u_int8_t		 priority;	/* priority */
	u_int16_t		 qlimit;	/* queue size limit */
	u_int16_t		 flags;		/* misc flags */
	union {
		struct cbq_opts		 cbq_opts;
		struct priq_opts	 priq_opts;
		struct hfsc_opts	 hfsc_opts;
	} pq_u;

	u_int32_t		 qid;		/* return value */
};

struct pf_tag {
	u_int16_t	tag;		/* tag id */
};

struct pf_tagname {
	TAILQ_ENTRY(pf_tagname)	entries;
	char			name[PF_TAG_NAME_SIZE];
	u_int16_t		tag;
	int			ref;
};

#define PFFRAG_FRENT_HIWAT	5000	/* Number of fragment entries */
#define PFFRAG_FRAG_HIWAT	1000	/* Number of fragmented packets */
#define PFFRAG_FRCENT_HIWAT	50000	/* Number of fragment cache entries */
#define PFFRAG_FRCACHE_HIWAT	10000	/* Number of fragment descriptors */

/*
 * ioctl parameter structures
 */

struct pfioc_pooladdr {
	u_int32_t		 action;
	u_int32_t		 ticket;
	u_int32_t		 nr;
	u_int32_t		 r_num;
	u_int8_t		 r_action;
	u_int8_t		 r_last;
	u_int8_t		 af;
	char			 anchor[PF_ANCHOR_NAME_SIZE];
	char			 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_pooladdr	 addr;
};

struct pfioc_rule {
	u_int32_t	 action;
	u_int32_t	 ticket;
	u_int32_t	 pool_ticket;
	u_int32_t	 nr;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 ruleset[PF_RULESET_NAME_SIZE];
	struct pf_rule	 rule;
};

struct pfioc_natlook {
	struct pf_addr	 saddr;
	struct pf_addr	 daddr;
	struct pf_addr	 rsaddr;
	struct pf_addr	 rdaddr;
	u_int16_t	 sport;
	u_int16_t	 dport;
	u_int16_t	 rsport;
	u_int16_t	 rdport;
	sa_family_t	 af;
	u_int8_t	 proto;
	u_int8_t	 direction;
};

struct pfioc_state {
	u_int32_t	 nr;
	struct pf_state	 state;
};

struct pfioc_state_kill {
	/* XXX returns the number of states killed in psk_af */
	sa_family_t		psk_af;
	int			psk_proto;
	struct pf_rule_addr	psk_src;
	struct pf_rule_addr	psk_dst;
	char			psk_ifname[IFNAMSIZ];
};

struct pfioc_states {
	int	ps_len;
	union {
		caddr_t		 psu_buf;
		struct pf_state	*psu_states;
	} ps_u;
#define ps_buf		ps_u.psu_buf
#define ps_states	ps_u.psu_states
};

struct pfioc_src_nodes {
	int	psn_len;
	union {
		caddr_t		 psu_buf;
		struct pf_src_node	*psu_src_nodes;
	} psn_u;
#define psn_buf		psn_u.psu_buf
#define psn_src_nodes	psn_u.psu_src_nodes
};

struct pfioc_if {
	char		 ifname[IFNAMSIZ];
};

struct pfioc_tm {
	int		 timeout;
	int		 seconds;
};

struct pfioc_limit {
	int		 index;
	unsigned	 limit;
};

struct pfioc_altq {
	u_int32_t	 action;
	u_int32_t	 ticket;
	u_int32_t	 nr;
	struct pf_altq	 altq;
};

struct pfioc_qstats {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	void		*buf;
	int		 nbytes;
	u_int8_t	 scheduler;
};

struct pfioc_anchor {
	u_int32_t	 nr;
	char		 name[PF_ANCHOR_NAME_SIZE];
};

struct pfioc_ruleset {
	u_int32_t	 nr;
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 name[PF_RULESET_NAME_SIZE];
};

#define PF_RULESET_ALTQ		(PF_RULESET_MAX)
#define PF_RULESET_TABLE	(PF_RULESET_MAX+1)
struct pfioc_trans {
	int		 size;	/* number of elements */
	int		 esize; /* size of each element in bytes */
	struct pfioc_trans_e {
		int		rs_num;
		char		anchor[PF_ANCHOR_NAME_SIZE];
		char		ruleset[PF_RULESET_NAME_SIZE];
		u_int32_t	ticket;
	}		*array;
};

#define PFR_FLAG_ATOMIC		0x00000001
#define PFR_FLAG_DUMMY		0x00000002
#define PFR_FLAG_FEEDBACK	0x00000004
#define PFR_FLAG_CLSTATS	0x00000008
#define PFR_FLAG_ADDRSTOO	0x00000010
#define PFR_FLAG_REPLACE	0x00000020
#define PFR_FLAG_ALLRSETS	0x00000040
#define PFR_FLAG_ALLMASK	0x0000007F
#ifdef _KERNEL
#define PFR_FLAG_USERIOCTL	0x10000000
#endif

struct pfioc_table {
	struct pfr_table	 pfrio_table;
	void			*pfrio_buffer;
	int			 pfrio_esize;
	int			 pfrio_size;
	int			 pfrio_size2;
	int			 pfrio_nadd;
	int			 pfrio_ndel;
	int			 pfrio_nchange;
	int			 pfrio_flags;
	u_int32_t		 pfrio_ticket;
};
#define	pfrio_exists	pfrio_nadd
#define	pfrio_nzero	pfrio_nadd
#define	pfrio_nmatch	pfrio_nadd
#define pfrio_naddr	pfrio_size2
#define pfrio_setflag	pfrio_size2
#define pfrio_clrflag	pfrio_nadd


#define PFI_FLAG_GROUP		0x0001	/* gets groups of interfaces */
#define PFI_FLAG_INSTANCE	0x0002	/* gets single interfaces */
#define PFI_FLAG_ALLMASK	0x0003

struct pfioc_iface {
	char	 pfiio_name[IFNAMSIZ];
	void	*pfiio_buffer;
	int	 pfiio_esize;
	int	 pfiio_size;
	int	 pfiio_nzero;
	int	 pfiio_flags;
};


/*
 * ioctl operations
 */

#define DIOCSTART	_IO  ('D',  1)
#define DIOCSTOP	_IO  ('D',  2)
#define DIOCBEGINRULES	_IOWR('D',  3, struct pfioc_rule)
#define DIOCADDRULE	_IOWR('D',  4, struct pfioc_rule)
#define DIOCCOMMITRULES	_IOWR('D',  5, struct pfioc_rule)
#define DIOCGETRULES	_IOWR('D',  6, struct pfioc_rule)
#define DIOCGETRULE	_IOWR('D',  7, struct pfioc_rule)
/* XXX cut 8 - 17 */
#define DIOCCLRSTATES	_IOWR('D', 18, struct pfioc_state_kill)
#define DIOCGETSTATE	_IOWR('D', 19, struct pfioc_state)
#define DIOCSETSTATUSIF _IOWR('D', 20, struct pfioc_if)
#define DIOCGETSTATUS	_IOWR('D', 21, struct pf_status)
#define DIOCCLRSTATUS	_IO  ('D', 22)
#define DIOCNATLOOK	_IOWR('D', 23, struct pfioc_natlook)
#define DIOCSETDEBUG	_IOWR('D', 24, u_int32_t)
#define DIOCGETSTATES	_IOWR('D', 25, struct pfioc_states)
#define DIOCCHANGERULE	_IOWR('D', 26, struct pfioc_rule)
/* XXX cut 26 - 28 */
#define DIOCSETTIMEOUT	_IOWR('D', 29, struct pfioc_tm)
#define DIOCGETTIMEOUT	_IOWR('D', 30, struct pfioc_tm)
#define DIOCADDSTATE	_IOWR('D', 37, struct pfioc_state)
#define DIOCCLRRULECTRS	_IO  ('D', 38)
#define DIOCGETLIMIT	_IOWR('D', 39, struct pfioc_limit)
#define DIOCSETLIMIT	_IOWR('D', 40, struct pfioc_limit)
#define DIOCKILLSTATES	_IOWR('D', 41, struct pfioc_state_kill)
#define DIOCSTARTALTQ	_IO  ('D', 42)
#define DIOCSTOPALTQ	_IO  ('D', 43)
#define DIOCBEGINALTQS	_IOWR('D', 44, u_int32_t)
#define DIOCADDALTQ	_IOWR('D', 45, struct pfioc_altq)
#define DIOCCOMMITALTQS	_IOWR('D', 46, u_int32_t)
#define DIOCGETALTQS	_IOWR('D', 47, struct pfioc_altq)
#define DIOCGETALTQ	_IOWR('D', 48, struct pfioc_altq)
#define DIOCCHANGEALTQ	_IOWR('D', 49, struct pfioc_altq)
#define DIOCGETQSTATS	_IOWR('D', 50, struct pfioc_qstats)
#define DIOCBEGINADDRS	_IOWR('D', 51, struct pfioc_pooladdr)
#define DIOCADDADDR	_IOWR('D', 52, struct pfioc_pooladdr)
#define DIOCGETADDRS	_IOWR('D', 53, struct pfioc_pooladdr)
#define DIOCGETADDR	_IOWR('D', 54, struct pfioc_pooladdr)
#define DIOCCHANGEADDR	_IOWR('D', 55, struct pfioc_pooladdr)
#define	DIOCGETANCHORS	_IOWR('D', 56, struct pfioc_anchor)
#define	DIOCGETANCHOR	_IOWR('D', 57, struct pfioc_anchor)
#define	DIOCGETRULESETS	_IOWR('D', 58, struct pfioc_ruleset)
#define	DIOCGETRULESET	_IOWR('D', 59, struct pfioc_ruleset)
#define	DIOCRCLRTABLES	_IOWR('D', 60, struct pfioc_table)
#define	DIOCRADDTABLES	_IOWR('D', 61, struct pfioc_table)
#define	DIOCRDELTABLES	_IOWR('D', 62, struct pfioc_table)
#define	DIOCRGETTABLES	_IOWR('D', 63, struct pfioc_table)
#define	DIOCRGETTSTATS	_IOWR('D', 64, struct pfioc_table)
#define DIOCRCLRTSTATS  _IOWR('D', 65, struct pfioc_table)
#define	DIOCRCLRADDRS	_IOWR('D', 66, struct pfioc_table)
#define	DIOCRADDADDRS	_IOWR('D', 67, struct pfioc_table)
#define	DIOCRDELADDRS	_IOWR('D', 68, struct pfioc_table)
#define	DIOCRSETADDRS	_IOWR('D', 69, struct pfioc_table)
#define	DIOCRGETADDRS	_IOWR('D', 70, struct pfioc_table)
#define	DIOCRGETASTATS	_IOWR('D', 71, struct pfioc_table)
#define DIOCRCLRASTATS  _IOWR('D', 72, struct pfioc_table)
#define	DIOCRTSTADDRS	_IOWR('D', 73, struct pfioc_table)
#define	DIOCRSETTFLAGS	_IOWR('D', 74, struct pfioc_table)
#define DIOCRINABEGIN	_IOWR('D', 75, struct pfioc_table)
#define DIOCRINACOMMIT	_IOWR('D', 76, struct pfioc_table)
#define DIOCRINADEFINE	_IOWR('D', 77, struct pfioc_table)
#define DIOCOSFPFLUSH	_IO('D', 78)
#define DIOCOSFPADD	_IOWR('D', 79, struct pf_osfp_ioctl)
#define DIOCOSFPGET	_IOWR('D', 80, struct pf_osfp_ioctl)
#define DIOCXBEGIN      _IOWR('D', 81, struct pfioc_trans)
#define DIOCXCOMMIT     _IOWR('D', 82, struct pfioc_trans)
#define DIOCXROLLBACK   _IOWR('D', 83, struct pfioc_trans)
#define DIOCGETSRCNODES	_IOWR('D', 84, struct pfioc_src_nodes)
#define DIOCCLRSRCNODES	_IO('D', 85)
#define DIOCSETHOSTID	_IOWR('D', 86, u_int32_t)
#define DIOCIGETIFACES	_IOWR('D', 87, struct pfioc_iface)
#define DIOCICLRISTATS  _IOWR('D', 88, struct pfioc_iface)

#ifdef _KERNEL
RB_HEAD(pf_src_tree, pf_src_node);
RB_PROTOTYPE(pf_src_tree, pf_src_node, entry, pf_src_compare);
extern struct pf_src_tree tree_src_tracking;

RB_HEAD(pf_state_tree_id, pf_state);
RB_PROTOTYPE(pf_state_tree_id, pf_state,
    entry_id, pf_state_compare_id);
extern struct pf_state_tree_id tree_id;
extern struct pf_state_queue state_updates;

extern struct pf_anchorqueue		  pf_anchors;
extern struct pf_ruleset		  pf_main_ruleset;
TAILQ_HEAD(pf_poolqueue, pf_pool);
extern struct pf_poolqueue		  pf_pools[2];
TAILQ_HEAD(pf_altqqueue, pf_altq);
extern struct pf_altqqueue		  pf_altqs[2];
extern struct pf_palist			  pf_pabuf;
extern struct pfi_kif			**pfi_index2kif;

extern u_int32_t		 ticket_altqs_active;
extern u_int32_t		 ticket_altqs_inactive;
extern int			 altqs_inactive_open;
extern u_int32_t		 ticket_pabuf;
extern struct pf_altqqueue	*pf_altqs_active;
extern struct pf_altqqueue	*pf_altqs_inactive;
extern struct pf_poolqueue	*pf_pools_active;
extern struct pf_poolqueue	*pf_pools_inactive;
extern int			 pf_tbladdr_setup(struct pf_ruleset *,
				    struct pf_addr_wrap *);
extern void			 pf_tbladdr_remove(struct pf_addr_wrap *);
extern void			 pf_tbladdr_copyout(struct pf_addr_wrap *);
extern void			 pf_calc_skip_steps(struct pf_rulequeue *);
extern struct pool		 pf_src_tree_pl, pf_rule_pl;
extern struct pool		 pf_state_pl, pf_altq_pl, pf_pooladdr_pl;
extern struct pool		 pf_state_scrub_pl;
extern void			 pf_purge_timeout(void *);
extern void			 pf_purge_expired_src_nodes(void);
extern void			 pf_purge_expired_states(void);
extern void			 pf_purge_expired_state(struct pf_state *);
extern int			 pf_insert_state(struct pfi_kif *,
				    struct pf_state *);
extern int			 pf_insert_src_node(struct pf_src_node **,
				    struct pf_rule *, struct pf_addr *,
				    sa_family_t);
void				 pf_src_tree_remove_state(struct pf_state *);
extern struct pf_state		*pf_find_state_byid(struct pf_state *);
extern struct pf_state		*pf_find_state_all(struct pf_state *key,
				    u_int8_t tree, int *more);
extern void			 pf_print_state(struct pf_state *);
extern void			 pf_print_flags(u_int8_t);
extern struct pf_anchor		*pf_find_anchor(const char *);
extern struct pf_ruleset	*pf_find_ruleset(char *, char *);
extern struct pf_ruleset	*pf_find_or_create_ruleset(
				    char[PF_ANCHOR_NAME_SIZE],
				    char[PF_RULESET_NAME_SIZE]);
extern void			 pf_remove_if_empty_ruleset(
				    struct pf_ruleset *);
extern u_int16_t		 pf_cksum_fixup(u_int16_t, u_int16_t, u_int16_t,
				    u_int8_t);

extern struct ifnet		*sync_ifp;
extern struct pf_rule		 pf_default_rule;
extern void			 pf_addrcpy(struct pf_addr *, struct pf_addr *,
				    u_int8_t);
void				 pf_rm_rule(struct pf_rulequeue *,
				    struct pf_rule *);

#ifdef INET
int	pf_test(int, struct ifnet *, struct mbuf **);
int	pf_test_eh(int, struct ifnet *, struct mbuf **, struct ether_header *);
#endif /* INET */

#ifdef INET6
int	pf_test6(int, struct ifnet *, struct mbuf **);
int	pf_test6_eh(int, struct ifnet *, struct mbuf **, struct ether_header *);
void	pf_poolmask(struct pf_addr *, struct pf_addr*,
	    struct pf_addr *, struct pf_addr *, u_int8_t);
void	pf_addr_inc(struct pf_addr *, sa_family_t);
#endif /* INET6 */

void   *pf_pull_hdr(struct mbuf *, int, void *, int, u_short *, u_short *,
	    sa_family_t);
void	pf_change_a(void *, u_int16_t *, u_int32_t, u_int8_t);
int	pflog_packet(struct pfi_kif *, struct mbuf *, sa_family_t, u_int8_t,
	    u_int8_t, struct pf_rule *, struct pf_rule *, struct pf_ruleset *);
int	pf_match_addr(u_int8_t, struct pf_addr *, struct pf_addr *,
	    struct pf_addr *, sa_family_t);
int	pf_match(u_int8_t, u_int32_t, u_int32_t, u_int32_t);
int	pf_match_port(u_int8_t, u_int16_t, u_int16_t, u_int16_t);
int	pf_match_uid(u_int8_t, uid_t, uid_t, uid_t);
int	pf_match_gid(u_int8_t, gid_t, gid_t, gid_t);

void	pf_normalize_init(void);
int	pf_normalize_ip(struct mbuf **, int, struct pfi_kif *, u_short *,
	    struct pf_pdesc *);
int	pf_normalize_ip6(struct mbuf **, int, struct pfi_kif *, u_short *,
	    struct pf_pdesc *);
int	pf_normalize_tcp(int, struct pfi_kif *, struct mbuf *, int, int, void *,
	    struct pf_pdesc *);
void	pf_normalize_tcp_cleanup(struct pf_state *);
int	pf_normalize_tcp_init(struct mbuf *, int, struct pf_pdesc *,
	    struct tcphdr *, struct pf_state_peer *, struct pf_state_peer *);
int	pf_normalize_tcp_stateful(struct mbuf *, int, struct pf_pdesc *,
	    u_short *, struct tcphdr *, struct pf_state *,
	    struct pf_state_peer *, struct pf_state_peer *, int *);
u_int32_t
	pf_state_expires(const struct pf_state *);
void	pf_purge_expired_fragments(void);
int	pf_routable(struct pf_addr *addr, sa_family_t af);
void	pfr_initialize(void);
int	pfr_match_addr(struct pfr_ktable *, struct pf_addr *, sa_family_t);
void	pfr_update_stats(struct pfr_ktable *, struct pf_addr *, sa_family_t,
	    u_int64_t, int, int, int);
int	pfr_pool_get(struct pfr_ktable *, int *, struct pf_addr *,
	    struct pf_addr **, struct pf_addr **, sa_family_t);
void	pfr_dynaddr_update(struct pfr_ktable *, struct pfi_dynaddr *);
struct pfr_ktable *
	pfr_attach_table(struct pf_ruleset *, char *);
void	pfr_detach_table(struct pfr_ktable *);
int	pfr_clr_tables(struct pfr_table *, int *, int);
int	pfr_add_tables(struct pfr_table *, int, int *, int);
int	pfr_del_tables(struct pfr_table *, int, int *, int);
int	pfr_get_tables(struct pfr_table *, struct pfr_table *, int *, int);
int	pfr_get_tstats(struct pfr_table *, struct pfr_tstats *, int *, int);
int	pfr_clr_tstats(struct pfr_table *, int, int *, int);
int	pfr_set_tflags(struct pfr_table *, int, int, int, int *, int *, int);
int	pfr_clr_addrs(struct pfr_table *, int *, int);
int	pfr_add_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_del_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_set_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int *, int *, int *, int);
int	pfr_get_addrs(struct pfr_table *, struct pfr_addr *, int *, int);
int	pfr_get_astats(struct pfr_table *, struct pfr_astats *, int *, int);
int	pfr_clr_astats(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_tst_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int);
int	pfr_ina_begin(struct pfr_table *, u_int32_t *, int *, int);
int	pfr_ina_rollback(struct pfr_table *, u_int32_t, int *, int);
int	pfr_ina_commit(struct pfr_table *, u_int32_t, int *, int *, int);
int	pfr_ina_define(struct pfr_table *, struct pfr_addr *, int, int *,
	    int *, u_int32_t, int);

void		 pfi_initialize(void);
void		 pfi_attach_clone(struct if_clone *);
void		 pfi_attach_ifnet(struct ifnet *);
void		 pfi_detach_ifnet(struct ifnet *);
struct pfi_kif	*pfi_lookup_create(const char *);
struct pfi_kif	*pfi_lookup_if(const char *);
int		 pfi_maybe_destroy(struct pfi_kif *);
struct pfi_kif	*pfi_attach_rule(const char *);
void		 pfi_detach_rule(struct pfi_kif *);
void		 pfi_attach_state(struct pfi_kif *);
void		 pfi_detach_state(struct pfi_kif *);
void		 pfi_fill_oldstatus(struct pf_status *);
int		 pfi_clr_istats(const char *, int *, int);
int		 pfi_get_ifaces(const char *, struct pfi_if *, int *, int);
int		 pfi_match_addr(struct pfi_dynaddr *, struct pf_addr *,
		    sa_family_t);

extern struct pfi_statehead	pfi_statehead;

u_int16_t	pf_tagname2tag(char *);
void		pf_tag2tagname(u_int16_t, char *);
void		pf_tag_unref(u_int16_t);
int		pf_tag_packet(struct mbuf *, struct pf_tag *, int);
u_int32_t	pf_qname2qid(char *);
void		pf_qid2qname(u_int32_t, char *);
void		pf_qid_unref(u_int32_t);

extern struct pf_status	pf_status;
extern struct pool	pf_frent_pl, pf_frag_pl;

struct pf_pool_limit {
	void		*pp;
	unsigned	 limit;
};
extern struct pf_pool_limit	pf_pool_limits[PF_LIMIT_MAX];

#endif /* _KERNEL */

/* The fingerprint functions can be linked into userland programs (tcpdump) */
int	pf_osfp_add(struct pf_osfp_ioctl *);
#ifdef _KERNEL
struct pf_osfp_enlist *
	pf_osfp_fingerprint(struct pf_pdesc *, struct mbuf *, int,
	    const struct tcphdr *);
#endif /* _KERNEL */
struct pf_osfp_enlist *
	pf_osfp_fingerprint_hdr(const struct ip *, const struct tcphdr *);
void	pf_osfp_flush(void);
int	pf_osfp_get(struct pf_osfp_ioctl *);
void	pf_osfp_initialize(void);
int	pf_osfp_match(struct pf_osfp_enlist *, pf_osfp_t);
struct pf_os_fingerprint *
	pf_osfp_validate(void);


#endif /* _NET_PFVAR_H_ */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: pfvar.h,v 1.136 2003/03/03 14:33:17 cedric Exp $ */
d43 6
d51 1
d53 1
a53 1
	  PF_BINAT, PF_NOBINAT, PF_RDR, PF_NORDR };
d58 1
a58 1
enum	{ PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC };
d62 4
d71 3
a73 1
	  PFTM_OTHER_MULTIPLE, PFTM_FRAG, PFTM_INTERVAL, PFTM_MAX };
d75 1
a75 1
enum	{ PF_LIMIT_STATES, PF_LIMIT_FRAGS, PF_LIMIT_MAX };
d79 1
a79 1
enum	{ PF_ADDR_ADDRMASK, PF_ADDR_NOROUTE, PF_ADDR_DYNIFTL,
d82 1
a82 1
#define PF_POOL_STATICPORT	0x10
d103 6
d119 1
a119 1
		struct pf_addr_dyn	*dyn;
d121 1
d125 1
d128 15
a142 7
struct pf_addr_dyn {
	char			 ifname[IFNAMSIZ];
	struct ifnet		*ifp;
	struct pf_addr		*addr;
	sa_family_t		 af;
	void			*hook_cookie;
	u_int8_t		 undefined;
a148 2
#ifdef _KERNEL

d178 2
a179 1
	((a)->addr32[0] == (b)->addr32[0] && \
d181 1
a181 2
	(a)->addr32[2] == (b)->addr32[2] && \
	(a)->addr32[3] == (b)->addr32[3])) \
d185 2
a186 1
	((a)->addr32[0] != (b)->addr32[0] || \
d188 1
a188 2
	(a)->addr32[2] != (b)->addr32[2] || \
	(a)->addr32[3] != (b)->addr32[3])) \
d214 2
a215 1
	((a)->addr32[0] == (b)->addr32[0] && \
d217 1
a217 2
	(a)->addr32[2] == (b)->addr32[2] && \
	(a)->addr32[3] == (b)->addr32[3]) \
d220 2
a221 1
	((a)->addr32[0] != (b)->addr32[0] || \
d223 1
a223 2
	(a)->addr32[2] != (b)->addr32[2] || \
	(a)->addr32[3] != (b)->addr32[3]) \
a283 5
		((aw)->type == PF_ADDR_DYNIFTL &&		\
		    ((aw)->p.dyn->undefined ||			\
		    (!PF_AZERO(&(aw)->v.a.mask, (af)) &&	\
		    !PF_MATCHA(0, &(aw)->v.a.addr,		\
		    &(aw)->v.a.mask, (x), (af))))) ||		\
d309 1
a309 1
	struct pf_rule_addr		 addr;
d312 1
a312 1
	struct ifnet			*ifp;
d333 1
d339 107
d458 1
a458 4
	union {
		struct pf_rule	*ptr;
		u_int32_t	 nr;
	}			 skip[PF_SKIP_COUNT];
a460 1
	u_int32_t		 timeout[PFTM_MAX];
d467 4
d478 1
a478 1
	struct ifnet		*ifp;
d481 3
d486 3
d492 2
a494 1
	u_int16_t		 nr;
d498 2
d504 1
d510 2
d515 1
a520 1

a522 1
	u_int8_t		 rule_flag;
d530 20
a549 9
#define	PFRULE_DROP		0x00
#define	PFRULE_RETURNRST	0x01
#define	PFRULE_NODF		0x02
#define	PFRULE_FRAGMENT		0x04
#define	PFRULE_RETURNICMP	0x08
#define	PFRULE_FRAGCROP		0x10	/* non-buffering frag cache */
#define	PFRULE_FRAGDROP		0x20	/* drop funny fragments */
#define	PFRULE_RETURN		0x40
#define PFRULE_RANDOMID		0x80
d553 33
d596 5
a600 3
	u_int16_t	max_win;
	u_int8_t	state;
	u_int8_t	wscale;
d603 2
d606 11
d622 3
a624 5
	union {
		struct pf_rule	*ptr;
		u_int32_t	 nr;
	} rule;
	struct pf_rule	*nat_rule;
d626 3
a628 1
	struct ifnet	*rt_ifp;
d631 4
a634 2
	u_int32_t	 packets;
	u_int32_t	 bytes;
d640 5
a644 10
	u_int8_t	 pad[3];
};

struct pf_tree_node {
	RB_ENTRY(pf_tree_node) entry;
	struct pf_state	*state;
	struct pf_addr	 addr[2];
	u_int16_t	 port[2];
	sa_family_t	 af;
	u_int8_t	 proto;
d660 1
d664 3
d675 2
d681 3
d689 1
d691 2
a692 2
#define	PFR_TFLAG_SETMASK	0x0000001C
#define PFR_TFLAG_ALLMASK	0x0000001F
d695 2
d699 1
d730 2
d740 1
a740 1
	int		 pfrts_refcnt;
d768 3
d775 2
d786 54
d851 3
d856 2
d862 2
d880 2
a881 1
#define PFRES_MAX	6		/* total+1 */
d890 1
d927 4
d949 1
d952 1
d955 1
d958 1
d1002 1
a1002 1
	u_int16_t		 tbrsize;	/* tokenbuket regulator size */
d1022 11
d1090 1
d1103 10
d1153 13
d1172 5
a1176 1
#define PFR_FLAG_ALLMASK	0x0000003F
d1181 1
d1188 1
a1188 1
	int			 pfrio_ticket;
d1198 14
d1224 1
a1224 1
#define DIOCCLRSTATES	_IO  ('D', 18)
d1277 11
d1290 9
a1298 3
RB_HEAD(pf_state_tree, pf_tree_node);
RB_PROTOTYPE(pf_state_tree, pf_tree_node, entry, pf_state_compare);
extern struct pf_state_tree tree_lan_ext, tree_ext_gwy;
d1300 2
a1301 2
extern struct pf_anchorqueue		 pf_anchors;
extern struct pf_ruleset		 pf_main_ruleset;
d1303 1
a1303 1
extern struct pf_poolqueue		 pf_pools[2];
d1305 3
a1307 3
extern struct pf_altqqueue		 pf_altqs[2];
extern struct pf_palist			 pf_pabuf;

d1311 1
d1317 2
a1318 1
extern int			 pf_tbladdr_setup(struct pf_addr_wrap *);
a1320 4
extern int			 pf_dynaddr_setup(struct pf_addr_wrap *,
				    sa_family_t);
extern void			 pf_dynaddr_copyout(struct pf_addr_wrap *);
extern void			 pf_dynaddr_remove(struct pf_addr_wrap *);
d1322 1
a1322 2
extern void			 pf_update_anchor_rules(void);
extern struct pool		 pf_tree_pl, pf_rule_pl, pf_addr_pl;
d1324 1
d1326 1
a1326 1
extern int			 pftm_interval;
d1328 12
a1339 3
extern int			 pf_insert_state(struct pf_state *);
extern struct pf_state		*pf_find_state(struct pf_state_tree *,
				    struct pf_tree_node *);
d1341 11
a1351 2
extern struct ifnet		*status_ifp;
extern int			*pftm_timeouts[PFTM_MAX];
d1354 2
d1359 1
d1364 5
a1368 1
#endif /* INET */
d1370 5
a1374 2
int	pflog_packet(struct ifnet *, struct mbuf *, sa_family_t, u_short,
	    u_short, struct pf_rule *);
d1377 1
a1377 1
int	pf_match(u_int8_t, u_int16_t, u_int16_t, u_int16_t);
d1383 14
a1396 1
int	pf_normalize_ip(struct mbuf **, int, struct ifnet *, u_short *);
d1403 3
d1407 1
a1407 1
	pfr_attach_table(char *);
d1409 1
a1409 1
int	pfr_clr_tables(int *, int);
d1412 2
a1413 2
int	pfr_get_tables(struct pfr_table *, int *, int);
int	pfr_get_tstats(struct pfr_tstats *, int *, int);
d1429 3
a1431 2
int	pfr_ina_begin(int *, int *, int);
int	pfr_ina_commit(int, int *, int *, int);
d1433 28
a1460 1
	    int *, int, int);
d1472 17
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.139 2003/04/09 15:32:59 cedric Exp $ */
a314 5
union pf_rule_ptr {
	struct pf_rule		*ptr;
	u_int32_t		 nr;
};

d327 4
a330 1
	union pf_rule_ptr	 skip[PF_SKIP_COUNT];
a354 1
	u_int32_t		 nr;
d356 1
d421 5
a425 3
	union pf_rule_ptr rule;
	union pf_rule_ptr anchor;
	union pf_rule_ptr nat_rule;
d968 1
d975 1
a975 1
extern struct pf_rule		 pf_default_rule;
a977 2
void				 pf_rm_rule(struct pf_rulequeue *,
				    struct pf_rule *);
@


1.1.1.3
log
@Import OpenBSD source with the "new" command line as well,
in order to be able to provide a MirBSD release which bases
upon a fairly current OpenBSD base source code tree deemed
stable enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.140 2003/04/11 14:40:57 henning Exp $ */
a963 2
extern void			 pf_rule_set_qid(struct pf_rulequeue *);
extern u_int32_t		 pf_qname_to_qid(char *);
@


1.1.1.4
log
@Import OpenBSD cvs as of now, CTM delta 3255, just before the i386 flag day
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.142 2003/04/30 12:30:27 cedric Exp $ */
a481 1
#define PFR_TFLAG_REFDANCHOR	0x00000020
d483 2
a484 2
#define PFR_TFLAG_SETMASK	0x0000003C
#define PFR_TFLAG_ALLMASK	0x0000003F
a486 2
	char			 pfrt_anchor[PF_ANCHOR_NAME_SIZE];
	char			 pfrt_ruleset[PF_RULESET_NAME_SIZE];
a488 1
	u_int8_t		 pfrt_fback;
a518 2
enum { PFR_REFCNT_RULE, PFR_REFCNT_ANCHOR, PFR_REFCNT_MAX };

d527 1
a527 1
	int		 pfrts_refcnt[PFR_REFCNT_MAX];
a554 1
	struct pfr_ktable	*pfrkt_root;
a558 2
#define pfrkt_anchor    pfrkt_t.pfrt_anchor
#define pfrkt_ruleset   pfrkt_t.pfrt_ruleset
a852 1
	int			 pfrio_esize;
d956 1
a956 2
extern int			 pf_tbladdr_setup(struct pf_ruleset *,
				    struct pf_addr_wrap *);
d1008 1
a1008 1
	pfr_attach_table(struct pf_ruleset *, char *);
@


1.1.1.5
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.152 2003/05/17 02:01:21 henning Exp $ */
a41 4
#include <netinet/tcp_fsm.h>

#define	PF_TCPS_PROXY_SRC	((TCP_NSTATES)+0)
#define	PF_TCPS_PROXY_DST	((TCP_NSTATES)+1)
d45 1
a45 1
	  PF_BINAT, PF_NOBINAT, PF_RDR, PF_NORDR, PF_SYNPROXY_DROP };
a53 4
/*
 * Note about PFTM_*: real indices into pf_rule.timeout[] come before
 * PFTM_MAX, special cases afterwards. See pf_state_expires().
 */
d59 1
a59 3
	  PFTM_OTHER_MULTIPLE, PFTM_FRAG, PFTM_INTERVAL,
	  PFTM_ADAPTIVE_START, PFTM_ADAPTIVE_END, PFTM_MAX,
	  PFTM_PURGE, PFTM_UNTIL_PACKET };
d150 2
a151 1
	((a)->addr32[3] == (b)->addr32[3] && \
d153 1
a153 2
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[0] == (b)->addr32[0])) \
d157 2
a158 1
	((a)->addr32[3] != (b)->addr32[3] || \
d160 1
a160 2
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[0] != (b)->addr32[0])) \
d186 2
a187 1
	((a)->addr32[3] == (b)->addr32[3] && \
d189 1
a189 2
	(a)->addr32[1] == (b)->addr32[1] && \
	(a)->addr32[0] == (b)->addr32[0]) \
d192 2
a193 1
	((a)->addr32[3] != (b)->addr32[3] || \
d195 1
a195 2
	(a)->addr32[1] != (b)->addr32[1] || \
	(a)->addr32[0] != (b)->addr32[0]) \
a341 4
#define	PF_TAG_NAME_SIZE	 16
	char			 tagname[PF_TAG_NAME_SIZE];
	char			 match_tagname[PF_TAG_NAME_SIZE];

a361 2
	u_int16_t		 tag;
	u_int16_t		 match_tag;
a365 1
	u_int32_t		 rule_flag;
a370 1
	u_int8_t		 match_tag_not;
a373 1
#define PF_STATE_SYNPROXY	0x3
d379 1
d382 1
d390 9
a398 13
/* rule flags */
#define	PFRULE_DROP		0x0000
#define	PFRULE_RETURNRST	0x0001
#define	PFRULE_FRAGMENT		0x0002
#define	PFRULE_RETURNICMP	0x0004
#define	PFRULE_RETURN		0x0008

/* scrub flags */
#define	PFRULE_NODF		0x0100
#define	PFRULE_FRAGCROP		0x0200	/* non-buffering frag cache */
#define	PFRULE_FRAGDROP		0x0400	/* drop funny fragments */
#define PFRULE_RANDOMID		0x0800
#define PFRULE_REASSEMBLE_TCP	0x1000
a401 9

struct pf_state_scrub {
	u_int16_t	pfss_flags;
#define PFSS_TIMESTAMP	0x0001		/* modulate timestamp	*/
	u_int8_t	pfss_ttl;	/* stashed TTL		*/
	u_int8_t	pad;
	u_int32_t	pfss_ts_mod;	/* timestamp modulation	*/
};

d412 3
a414 4
	u_int16_t	max_win;	/* largest window (pre scaling)	*/
	u_int8_t	state;		/* active state level		*/
	u_int8_t	wscale;		/* window scaling factor	*/
	struct pf_state_scrub	*scrub;	/* state is scrubbed		*/
d437 1
a437 2
	u_int8_t	 timeout;
	u_int8_t	 pad[2];
a593 1
#define PFDESC_TCP_NORM	0x0001		/* TCP shall be statefully scrubbed */
a741 13
struct pf_tag {
	u_int16_t	tag;		/* tag id */
};

struct pf_tagname {
	TAILQ_ENTRY(pf_tagname)	entries;
	char			name[PF_TAG_NAME_SIZE];
	u_int16_t		tag;
	int			ref;
};

TAILQ_HEAD(pf_tagnames, pf_tagname);

a979 1
extern struct pool		 pf_state_scrub_pl;
d1001 2
a1002 5
void   *pf_pull_hdr(struct mbuf *, int, void *, int, u_short *, u_short *,
	    sa_family_t);
void	pf_change_a(void *, u_int16_t *, u_int32_t, u_int8_t);
int	pflog_packet(struct ifnet *, struct mbuf *, sa_family_t, u_int8_t,
	    u_int8_t, struct pf_rule *, struct pf_rule *, struct pf_ruleset *);
a1011 10
int	pf_normalize_tcp(int, struct ifnet *, struct mbuf *, int, int, void *,
	    struct pf_pdesc *);
void	pf_normalize_tcp_cleanup(struct pf_state *);
int	pf_normalize_tcp_init(struct mbuf *, int, struct pf_pdesc *,
	    struct tcphdr *, struct pf_state_peer *, struct pf_state_peer *);
int	pf_normalize_tcp_stateful(struct mbuf *, int, struct pf_pdesc *,
	    u_short *, struct tcphdr *, struct pf_state_peer *,
	    struct pf_state_peer *, int *);
u_int32_t
	pf_state_expires(const struct pf_state *);
@


1.1.1.6
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.153 2003/06/03 12:34:04 henning Exp $ */
a1104 5

u_int16_t	pf_tagname2tag(char *);
void		pf_tag2tagname(u_int16_t, char *);
void		pf_tag_unref(u_int16_t);
int		pf_tag_packet(struct mbuf *, struct pf_tag *, int);
@


1.1.1.7
log
@Import OpenBSD CVS of roughly 2000-2200 UTC. Last import before release.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.154 2003/06/08 09:41:08 cedric Exp $ */
a496 1
	int			 tables;
a504 1
	int			 tables;
a593 1
	struct pf_ruleset	*pfrkt_rs;
d903 1
a903 2
#define PFR_FLAG_ALLRSETS	0x00000040
#define PFR_FLAG_ALLMASK	0x0000007F
a1032 5
extern struct pf_ruleset	*pf_find_ruleset(char *, char *);
extern struct pf_ruleset	*pf_find_or_create_ruleset(char *, char *);
extern void			 pf_remove_if_empty_ruleset(
				    struct pf_ruleset *);

d1081 1
a1081 1
int	pfr_clr_tables(struct pfr_table *, int *, int);
d1084 2
a1085 2
int	pfr_get_tables(struct pfr_table *, struct pfr_table *, int *, int);
int	pfr_get_tstats(struct pfr_table *, struct pfr_tstats *, int *, int);
@


1.1.1.8
log
@MFC latest OpenBSD fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.155 2003/06/09 11:14:46 mcbride Exp $ */
d78 1
@


1.1.1.9
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.157 2003/06/21 09:07:01 djm Exp $ */
a443 1
	u_int16_t	mss;		/* Maximum segment size option	*/
d460 2
a461 2
	u_int32_t	 packets[2];
	u_int32_t	 bytes[2];
@


1.1.1.10
log
@more fixes from -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.159 2003/06/30 10:50:16 henning Exp $ */
a1070 1
int	pf_normalize_ip6(struct mbuf **, int, struct ifnet *, u_short *);
a1117 1
void		pf_tag_purge(void);
@


1.1.1.11
log
@most important fixes from -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.160 2003/06/30 19:09:25 henning Exp $ */
d1119 1
@


1.1.1.12
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.162 2003/07/04 10:39:31 henning Exp $ */
a387 1
	u_int8_t		 natpass;
d788 2
@


1.1.1.13
log
@Another sync to OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.163 2003/07/19 13:08:58 cedric Exp $ */
d295 1
a295 1
	struct pf_addr_wrap		 addr;
@


1.1.1.14
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.166 2003/08/09 14:56:48 cedric Exp $ */
a318 1
	int			 tblidx;
a497 1
	u_int32_t		 tticket;
a498 1
	int			 topen;
d918 1
a918 1
	u_int32_t		 pfrio_ticket;
d1054 1
a1054 4
void	pf_poolmask(struct pf_addr *, struct pf_addr*,
	    struct pf_addr *, struct pf_addr *, u_int8_t);
void	pf_addr_inc(struct pf_addr *, sa_family_t);
#endif /* INET6 */
d1063 1
a1063 1
int	pf_match(u_int8_t, u_int32_t, u_int32_t, u_int32_t);
a1086 2
int	pfr_pool_get(struct pfr_ktable *, int *, struct pf_addr *,
	    struct pf_addr **, struct pf_addr **, sa_family_t);
d1110 2
a1111 2
int	pfr_ina_begin(struct pfr_table *, u_int32_t *, int *, int);
int	pfr_ina_commit(struct pfr_table *, u_int32_t, int *, int *, int);
d1113 1
a1113 1
	    int *, u_int32_t, int);
@


1.1.1.15
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.170 2003/08/22 21:50:34 david Exp $ */
a43 2
struct ip;

d54 1
a54 1
enum	{ PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC, PF_DEBUG_NOISY };
a324 102

/* A packed Operating System description for fingerprinting */
typedef u_int32_t pf_osfp_t;
#define PF_OSFP_ANY	((pf_osfp_t)0)
#define PF_OSFP_UNKNOWN	((pf_osfp_t)-1)
#define PF_OSFP_NOMATCH	((pf_osfp_t)-2)

struct pf_osfp_entry {
	SLIST_ENTRY(pf_osfp_entry) fp_entry;
	pf_osfp_t		fp_os;
	int			fp_enflags;
#define PF_OSFP_EXPANDED	0x001		/* expanded entry */
#define PF_OSFP_GENERIC		0x002		/* generic signature */
#define PF_OSFP_NODETAIL	0x004		/* no p0f details */
#define PF_OSFP_LEN	32
	char			fp_class_nm[PF_OSFP_LEN];
	char			fp_version_nm[PF_OSFP_LEN];
	char			fp_subtype_nm[PF_OSFP_LEN];
};
#define PF_OSFP_ENTRY_EQ(a, b) \
    ((a)->fp_os == (b)->fp_os && \
    memcmp((a)->fp_class_nm, (b)->fp_class_nm, PF_OSFP_LEN) == 0 && \
    memcmp((a)->fp_version_nm, (b)->fp_version_nm, PF_OSFP_LEN) == 0 && \
    memcmp((a)->fp_subtype_nm, (b)->fp_subtype_nm, PF_OSFP_LEN) == 0)

/* handle pf_osfp_t packing */
#define _FP_RESERVED_BIT	1  /* For the special negative #defines */
#define _FP_UNUSED_BITS		1
#define _FP_CLASS_BITS		10 /* OS Class (Windows, Linux) */
#define _FP_VERSION_BITS	10 /* OS version (95, 98, NT, 2.4.54, 3.2) */
#define _FP_SUBTYPE_BITS	10 /* patch level (NT SP4, SP3, ECN patch) */
#define PF_OSFP_UNPACK(osfp, class, version, subtype) do { \
	(class) = ((osfp) >> (_FP_VERSION_BITS+_FP_SUBTYPE_BITS)) & \
	    ((1 << _FP_CLASS_BITS) - 1); \
	(version) = ((osfp) >> _FP_SUBTYPE_BITS) & \
	    ((1 << _FP_VERSION_BITS) - 1);\
	(subtype) = (osfp) & ((1 << _FP_SUBTYPE_BITS) - 1); \
} while(0)
#define PF_OSFP_PACK(osfp, class, version, subtype) do { \
	(osfp) = ((class) & ((1 << _FP_CLASS_BITS) - 1)) << (_FP_VERSION_BITS \
	    + _FP_SUBTYPE_BITS); \
	(osfp) |= ((version) & ((1 << _FP_VERSION_BITS) - 1)) << \
	    _FP_SUBTYPE_BITS; \
	(osfp) |= (subtype) & ((1 << _FP_SUBTYPE_BITS) - 1); \
} while(0)

/* the fingerprint of an OSes TCP SYN packet */
typedef u_int64_t	pf_tcpopts_t;
struct pf_os_fingerprint {
	SLIST_HEAD(pf_osfp_enlist, pf_osfp_entry) fp_oses; /* list of matches */
	pf_tcpopts_t		fp_tcpopts;	/* packed TCP options */
	u_int16_t		fp_wsize;	/* TCP window size */
	u_int16_t		fp_psize;	/* ip->ip_len */
	u_int16_t		fp_mss;		/* TCP MSS */
	u_int16_t		fp_flags;
#define PF_OSFP_WSIZE_MOD	0x0001		/* Window modulus */
#define PF_OSFP_WSIZE_DC	0x0002		/* Window don't care */
#define PF_OSFP_WSIZE_MSS	0x0004		/* Window multiple of MSS */
#define PF_OSFP_WSIZE_MTU	0x0008		/* Window multiple of MTU */
#define PF_OSFP_PSIZE_MOD	0x0010		/* packet size modulus */
#define PF_OSFP_PSIZE_DC	0x0020		/* packet size don't care */
#define PF_OSFP_WSCALE		0x0040		/* TCP window scaling */
#define PF_OSFP_WSCALE_MOD	0x0080		/* TCP window scale modulus */
#define PF_OSFP_WSCALE_DC	0x0100		/* TCP window scale dont-care */
#define PF_OSFP_MSS		0x0200		/* TCP MSS */
#define PF_OSFP_MSS_MOD		0x0400		/* TCP MSS modulus */
#define PF_OSFP_MSS_DC		0x0800		/* TCP MSS dont-care */
#define PF_OSFP_DF		0x1000		/* IPv4 don't fragment bit */
#define PF_OSFP_TS0		0x2000		/* Zero timestamp */
	u_int8_t		fp_optcnt;	/* TCP option count */
	u_int8_t		fp_wscale;	/* TCP window scaling */
	u_int8_t		fp_ttl;		/* IPv4 TTL */
#define PF_OSFP_MAXTTL_OFFSET	40
/* TCP options packing */
#define PF_OSFP_TCPOPT_NOP	0x0		/* TCP NOP option */
#define PF_OSFP_TCPOPT_WSCALE	0x1		/* TCP window scaling option */
#define PF_OSFP_TCPOPT_MSS	0x2		/* TCP max segment size opt */
#define PF_OSFP_TCPOPT_SACK	0x3		/* TCP SACK OK option */
#define PF_OSFP_TCPOPT_TS	0x4		/* TCP timestamp option */
#define PF_OSFP_TCPOPT_BITS	3		/* bits used by each option */
#define PF_OSFP_MAX_OPTS \
    (sizeof(((struct pf_os_fingerprint *)0)->fp_tcpopts) * 8) \
    / PF_OSFP_TCPOPT_BITS

	SLIST_ENTRY(pf_os_fingerprint)	fp_next;
};

struct pf_osfp_ioctl {
	struct pf_osfp_entry	fp_os;
	pf_tcpopts_t		fp_tcpopts;	/* packed TCP options */
	u_int16_t		fp_wsize;	/* TCP window size */
	u_int16_t		fp_psize;	/* ip->ip_len */
	u_int16_t		fp_mss;		/* TCP MSS */
	u_int16_t		fp_flags;
	u_int8_t		fp_optcnt;	/* TCP option count */
	u_int8_t		fp_wscale;	/* TCP window scaling */
	u_int8_t		fp_ttl;		/* IPv4 TTL */

	int			fp_getnum;	/* DIOCOSFPGET number */
};


a365 1
	pf_osfp_t		 os_fingerprint;
d762 1
a762 1
	u_int16_t		 tbrsize;	/* tokenbucket regulator size */
a995 3
#define DIOCOSFPFLUSH	_IO('D', 78)
#define DIOCOSFPADD	_IOWR('D', 79, struct pf_osfp_ioctl)
#define DIOCOSFPGET	_IOWR('D', 80, struct pf_osfp_ioctl)
a1137 17

/* The fingerprint functions can be linked into userland programs (tcpdump) */
int	pf_osfp_add(struct pf_osfp_ioctl *);
#ifdef _KERNEL
struct pf_osfp_enlist *
	pf_osfp_fingerprint(struct pf_pdesc *, struct mbuf *, int,
	    const struct tcphdr *);
#endif /* _KERNEL */
struct pf_osfp_enlist *
	pf_osfp_fingerprint_hdr(const struct ip *, const struct tcphdr *);
void	pf_osfp_flush(void);
int	pf_osfp_get(struct pf_osfp_ioctl *);
void	pf_osfp_initialize(void);
int	pf_osfp_match(struct pf_osfp_enlist *, pf_osfp_t);
struct pf_os_fingerprint *
	pf_osfp_validate(void);

@


1.1.1.16
log
@cvs is playing games with me.

@@@@@@ CONSIDER THE TREE LOCKED NOW @@@@@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.171 2003/09/26 21:44:09 cedric Exp $ */
a600 1
			int			 open;
a1006 13
#define PF_RULESET_ALTQ		(PF_RULESET_MAX)
#define PF_RULESET_TABLE 	(PF_RULESET_MAX+1)
struct pfioc_trans {
	int		 size;	/* number of elements */
	int		 esize; /* size of each element in bytes */
	struct pfioc_trans_e {
		int		rs_num;
		char		anchor[PF_ANCHOR_NAME_SIZE];
		char		ruleset[PF_RULESET_NAME_SIZE];
		u_int32_t	ticket;
	}		*array;
};

a1103 4
#define DIOCXBEGIN      _IOWR('D', 81, struct pfioc_trans)
#define DIOCXCOMMIT     _IOWR('D', 82, struct pfioc_trans)
#define DIOCXROLLBACK   _IOWR('D', 83, struct pfioc_trans)

a1120 1
extern int			 altqs_inactive_open;	
a1226 1
int	pfr_ina_rollback(struct pfr_table *, u_int32_t, int *, int);
@


1.1.1.17
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.179 2003/12/15 09:10:26 henning Exp $ */
a49 1
enum	{ PF_LAN_EXT, PF_EXT_GWY, PF_ID };
d70 2
a71 2
	  PFTM_ADAPTIVE_START, PFTM_ADAPTIVE_END, PFTM_SRC_NODE,
	  PFTM_MAX, PFTM_PURGE, PFTM_UNTIL_PACKET };
d73 1
a73 1
enum	{ PF_LIMIT_STATES, PF_LIMIT_SRC_NODES, PF_LIMIT_FRAGS, PF_LIMIT_MAX };
a79 1
#define PF_POOL_STICKYADDR	0x20
d449 1
a470 2

	u_int32_t		 timeout[PFTM_MAX];
a472 3
	u_int32_t		 src_nodes;
	u_int32_t		 max_src_nodes;
	u_int32_t		 max_src_states;
a518 3
#define	PFRULE_NOSYNC		0x0010
#define PFRULE_SRCTRACK		0x0020  /* track source states */
#define PFRULE_RULESRCTRACK	0x0040  /* per rule */
a528 14
struct pf_src_node {
	RB_ENTRY(pf_src_node) entry;
	struct pf_addr	 addr;
	struct pf_addr	 raddr;
	union pf_rule_ptr rule;
	struct ifnet	*ifp;
	u_int32_t	 bytes;
	u_int32_t	 packets;
	u_int32_t        states;
	u_int32_t	 creation;
	u_int32_t	 expire;
	sa_family_t	 af;
	u_int8_t	 ruletype;
};
a555 4
	u_int64_t	 id;
	RB_ENTRY(pf_state) entry_lan_ext;
	RB_ENTRY(pf_state) entry_ext_gwy;
	RB_ENTRY(pf_state) entry_id;
a565 2
	struct pf_src_node	*src_node;
	struct pf_src_node	*nat_src_node;
a569 1
	u_int32_t        creatorid;
d576 10
a585 4
	u_int8_t	 sync_flags;
#define	PFSTATE_NOSYNC	 0x01
#define	PFSTATE_FROMSYNC 0x02
	u_int8_t	 pad;
a732 3
	struct pf_addr   baddr;         /* address before translation */
	struct pf_addr   naddr;         /* address after translation */
	struct pf_rule	*nat_rule;	/* nat/rdr rule applied to packet */
a800 4
#define SCNT_SRC_NODE_SEARCH	0
#define SCNT_SRC_NODE_INSERT	1
#define SCNT_SRC_NODE_REMOVALS	2
#define SCNT_MAX		3
a818 1
	u_int64_t	scounters[SCNT_MAX];
a820 1
	u_int64_t	stateid;
a822 1
	u_int32_t	src_nodes;
a824 1
	u_int32_t	hostid;
a967 10
struct pfioc_src_nodes {
	int	psn_len;
	union {
		caddr_t		 psu_buf;
		struct pf_src_node	*psu_src_nodes;
	} psn_u;
#define psn_buf		psn_u.psu_buf
#define psn_src_nodes	psn_u.psu_src_nodes
};

d1009 1
a1009 1
#define PF_RULESET_TABLE	(PF_RULESET_MAX+1)
d1121 1
a1121 3
#define DIOCGETSRCNODES	_IOWR('D', 84, struct pfioc_src_nodes)
#define DIOCCLRSRCNODES	_IO('D', 85)
#define DIOCSETHOSTID	_IOWR('D', 86, u_int32_t)
d1124 3
a1126 18
RB_HEAD(pf_src_tree, pf_src_node);
RB_PROTOTYPE(pf_src_tree, pf_src_node, entry, pf_src_compare);
extern struct pf_src_tree tree_src_tracking;

RB_HEAD(pf_state_tree_lan_ext, pf_state);
RB_PROTOTYPE(pf_state_tree_lan_ext, pf_state,
    entry_lan_ext, pf_state_compare_lan_ext);
extern struct pf_state_tree_lan_ext tree_lan_ext;

RB_HEAD(pf_state_tree_ext_gwy, pf_state);
RB_PROTOTYPE(pf_state_tree_ext_gwy, pf_state,
    entry_ext_gwy, pf_state_compare_ext_gwy);
extern struct pf_state_tree_ext_gwy tree_ext_gwy;

RB_HEAD(pf_state_tree_id, pf_state);
RB_PROTOTYPE(pf_state_tree_id, pf_state,
    entry_id, pf_state_compare_id);
extern struct pf_state_tree_id tree_id;
d1139 1
a1139 1
extern int			 altqs_inactive_open;
d1149 4
d1157 1
a1157 1
extern struct pool		 pf_src_tree_pl, pf_rule_pl, pf_addr_pl;
a1160 1
extern void			 pf_purge_expired_src_nodes(void);
d1163 2
a1164 5
extern int			 pf_insert_src_node(struct pf_src_node **,
				    struct pf_rule *, struct pf_addr *,
				    sa_family_t);
void				 pf_src_tree_remove_state(struct pf_state *);
extern struct pf_state		*pf_find_state(struct pf_state *, u_int8_t);
d1171 1
a1171 1
extern struct ifnet		*status_ifp, *sync_ifp;
a1249 4

int	pfi_dynaddr_setup(struct pf_addr_wrap *, sa_family_t);
void	pfi_dynaddr_copyout(struct pf_addr_wrap *);
void	pfi_dynaddr_remove(struct pf_addr_wrap *);
@


1.1.1.18
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.180 2003/12/31 11:18:25 cedric Exp $ */
a101 6
#define PFI_AFLAG_NETWORK	0x01
#define PFI_AFLAG_BROADCAST	0x02
#define PFI_AFLAG_PEER		0x04
#define PFI_AFLAG_MODEMASK	0x07
#define PFI_AFLAG_NOALIAS	0x08

d112 1
a112 1
		struct pfi_dynaddr	*dyn;
a113 1
		int			 dyncnt;
a116 1
	u_int8_t		 iflags;	/* PFI_AFLAG_* */
d119 7
a125 15
#ifdef _KERNEL

struct pfi_dynaddr {
	struct pf_addr		 pfid_addr4;
	struct pf_addr		 pfid_mask4;
	struct pf_addr		 pfid_addr6;
	struct pf_addr		 pfid_mask6;
	struct pfr_ktable	*pfid_kt;
	struct pfi_kif		*pfid_kif;
	void			*pfid_hook_cookie;
	int			 pfid_net;	/* optional mask, or 128 */
	int			 pfid_acnt4;	/* address count, IPv4 */
	int			 pfid_acnt6;	/* address count, IPv6 */
	sa_family_t		 pfid_af;	/* rule address family */
	u_int8_t		 pfid_iflags;	/* PFI_AFLAG_* */
d132 2
d270 4
a273 1
		    !pfi_match_addr((aw)->p.dyn, (x), (af))) || \
d302 1
a302 1
	struct pfi_kif			*kif;
d468 1
a468 1
	struct pfi_kif		*kif;
a535 4
/* rule flags again */
#define PFRULE_IFBOUND		0x00010000	/* if-bound */
#define PFRULE_GRBOUND		0x00020000	/* group-bound */

d543 1
a543 1
	struct pfi_kif	*kif;
d580 3
a582 9
	union {
		struct {
			RB_ENTRY(pf_state)	 entry_lan_ext;
			RB_ENTRY(pf_state)	 entry_ext_gwy;
			RB_ENTRY(pf_state)	 entry_id;
			struct pfi_kif		*kif;
		} s;
		char	 ifname[IFNAMSIZ];
	} u;
d592 1
a592 1
	struct pfi_kif	*rt_kif;
a644 3
#define PF_RESERVED_ANCHOR	"_pf"
#define PF_INTERFACE_RULESET	"_if"

a730 1
	long			 pfrkt_larg;
a745 54
RB_HEAD(pf_state_tree_lan_ext, pf_state);
RB_PROTOTYPE(pf_state_tree_lan_ext, pf_state,
    u.s.entry_lan_ext, pf_state_compare_lan_ext);

RB_HEAD(pf_state_tree_ext_gwy, pf_state);
RB_PROTOTYPE(pf_state_tree_ext_gwy, pf_state,
    u.s.entry_ext_gwy, pf_state_compare_ext_gwy);

struct pfi_if {
	char				 pfif_name[IFNAMSIZ];
        u_int64_t			 pfif_packets[2][2][2];
        u_int64_t			 pfif_bytes[2][2][2];
	u_int64_t			 pfif_addcnt;
	u_int64_t			 pfif_delcnt;
	long				 pfif_tzero;
	int				 pfif_states;
	int				 pfif_rules;
	int				 pfif_flags;
};

TAILQ_HEAD(pfi_grouphead, pfi_kif);
TAILQ_HEAD(pfi_statehead, pfi_kif);
RB_HEAD(pfi_ifhead, pfi_kif);
struct pfi_kif {
	struct pfi_if			 pfik_if;
	RB_ENTRY(pfi_kif)		 pfik_tree;
	struct pf_state_tree_lan_ext	 pfik_lan_ext;
	struct pf_state_tree_ext_gwy	 pfik_ext_gwy;
	struct pfi_grouphead		 pfik_grouphead;
	TAILQ_ENTRY(pfi_kif)		 pfik_instances;
	TAILQ_ENTRY(pfi_kif)		 pfik_w_states;
	struct hook_desc_head		*pfik_ah_head;
	void				*pfik_ah_cookie;
	struct pfi_kif			*pfik_parent;
	struct ifnet			*pfik_ifp;
	int				 pfik_states;
	int				 pfik_rules;
};
#define pfik_name	pfik_if.pfif_name
#define pfik_packets	pfik_if.pfif_packets
#define pfik_bytes	pfik_if.pfif_bytes
#define pfik_tzero	pfik_if.pfif_tzero
#define pfik_flags	pfik_if.pfif_flags
#define pfik_addcnt	pfik_if.pfif_addcnt
#define pfik_delcnt	pfik_if.pfif_delcnt
#define pfik_states	pfik_if.pfif_states
#define pfik_rules	pfik_if.pfif_rules

#define PFI_IFLAG_GROUP		0x0001	/* group of interfaces */
#define PFI_IFLAG_INSTANCE	0x0002	/* single instance */
#define PFI_IFLAG_CLONABLE	0x0010	/* clonable group */
#define PFI_IFLAG_DYNAMIC	0x0020	/* dynamic group */
#define PFI_IFLAG_ATTACHED	0x0040	/* interface attached */

a1073 3
#ifdef _KERNEL
#define PFR_FLAG_USERIOCTL	0x10000000
#endif
a1094 14
#define PFI_FLAG_GROUP		0x0001	/* gets groups of interfaces */
#define PFI_FLAG_INSTANCE	0x0002	/* gets single interfaces */
#define PFI_FLAG_ALLMASK	0x0003

struct pfioc_iface {
	char			 pfiio_name[IFNAMSIZ];
        void                    *pfiio_buffer;
        int                      pfiio_esize;
        int                      pfiio_size;
	int			 pfiio_nzero;
        int                      pfiio_flags;
};


a1168 2
#define DIOCIGETIFACES	_IOWR('D', 87, struct pfioc_iface)
#define DIOCICLRISTATS  _IOWR('D', 88, struct pfioc_iface)
d1175 10
d1190 2
a1191 2
extern struct pf_anchorqueue		  pf_anchors;
extern struct pf_ruleset		  pf_main_ruleset;
d1193 1
a1193 1
extern struct pf_poolqueue		  pf_pools[2];
d1195 3
a1197 3
extern struct pf_altqqueue		  pf_altqs[2];
extern struct pf_palist			  pf_pabuf;
extern struct pfi_kif			**pfi_index2kif;
d1215 1
a1215 1
extern struct pool		 pf_src_tree_pl, pf_rule_pl;
d1221 1
a1221 2
extern int			 pf_insert_state(struct pfi_kif *,
				    struct pf_state *);
d1226 1
a1226 3
extern struct pf_state		*pf_find_state_byid(struct pf_state *);
extern struct pf_state		*pf_find_state_all(struct pf_state *key,
				    u_int8_t tree, int *more);
d1229 1
a1229 3
extern struct pf_ruleset	*pf_find_or_create_ruleset(
				    char[PF_ANCHOR_NAME_SIZE],
				    char[PF_RULESET_NAME_SIZE]);
d1233 1
a1233 1
extern struct ifnet		*sync_ifp;
d1254 1
a1254 1
int	pflog_packet(struct pfi_kif *, struct mbuf *, sa_family_t, u_int8_t,
d1264 3
a1266 3
int	pf_normalize_ip(struct mbuf **, int, struct pfi_kif *, u_short *);
int	pf_normalize_ip6(struct mbuf **, int, struct pfi_kif *, u_short *);
int	pf_normalize_tcp(int, struct pfi_kif *, struct mbuf *, int, int, void *,
a1283 1
void	pfr_dynaddr_update(struct pfr_ktable *, struct pfi_dynaddr *);
d1313 3
a1315 20
void		 pfi_initialize(void);
void		 pfi_attach_clone(struct if_clone *);
void		 pfi_attach_ifnet(struct ifnet *);
void		 pfi_detach_ifnet(struct ifnet *);
struct pfi_kif	*pfi_lookup_create(const char *);
int		 pfi_maybe_destroy(struct pfi_kif *);
struct pfi_kif	*pfi_attach_rule(const char *);
void		 pfi_detach_rule(struct pfi_kif *);
void		 pfi_attach_state(struct pfi_kif *);
void		 pfi_detach_state(struct pfi_kif *);
int		 pfi_dynaddr_setup(struct pf_addr_wrap *, sa_family_t);
void		 pfi_dynaddr_copyout(struct pf_addr_wrap *);
void		 pfi_dynaddr_remove(struct pf_addr_wrap *);
void		 pfi_fill_oldstatus(struct pf_status *);
int		 pfi_clr_istats(const char *, int *, int);
int		 pfi_get_ifaces(const char *, struct pfi_if *, int *, int);
int		 pfi_match_addr(struct pfi_dynaddr *, struct pf_addr *,
		    sa_family_t);

extern struct pfi_statehead	pfi_statehead;
@


1.1.1.19
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfvar.h,v 1.194 2004/05/11 07:34:11 dhartmei Exp $ */
d72 1
a72 1
	  PFTM_TS_DIFF, PFTM_MAX, PFTM_PURGE, PFTM_UNTIL_PACKET };
a493 1
	u_int32_t		 prob;
d561 1
a561 1
	u_int32_t	 states;
a567 2
#define PFSNODE_HIWAT		10000	/* default source node table size */

a568 4
	struct timeval	pfss_last;	/* time received last packet	*/
	u_int32_t	pfss_tsecr;	/* last echoed timestamp	*/
	u_int32_t	pfss_tsval;	/* largest timestamp		*/
	u_int32_t	pfss_tsval0;	/* original timestamp		*/
d570 2
a571 6
#define PFSS_TIMESTAMP	0x0001		/* modulate timestamp		*/
#define PFSS_PAWS	0x0010		/* stricter PAWS checks		*/
#define PFSS_PAWS_IDLED	0x0020		/* was idle too long.  no PAWS	*/
#define PFSS_DATA_TS	0x0040		/* timestamp on data packets	*/
#define PFSS_DATA_NOTS	0x0080		/* no timestamp on data packets	*/
	u_int8_t	pfss_ttl;	/* stashed TTL			*/
d573 1
a573 1
	u_int32_t	pfss_ts_mod;	/* timestamp modulation		*/
a592 2
TAILQ_HEAD(pf_state_queue, pf_state);

a599 1
			TAILQ_ENTRY(pf_state)	 entry_updates;
a617 1
	u_int32_t	 pfsync_time;
d620 1
a620 1
	u_int32_t	 creatorid;
a661 1
	int			 refcnt;	/* anchor rules */
d760 2
a761 2
#define pfrkt_anchor	pfrkt_t.pfrt_anchor
#define pfrkt_ruleset	pfrkt_t.pfrt_ruleset
d781 2
a782 2
	u_int64_t			 pfif_packets[2][2][2];
	u_int64_t			 pfif_bytes[2][2][2];
d836 2
a837 2
	struct pf_addr	 baddr;		/* address before translation */
	struct pf_addr	 naddr;		/* address after translation */
a840 2
	struct ether_header
			*eh;
a845 1
#define PFDESC_IP_REAS	0x0002		/* IP frags would've been reassembled */
d862 1
a862 2
#define PFRES_TS	6		/* Bad TCP Timestamp (RFC1323) */
#define PFRES_MAX	7		/* total+1 */
a870 1
	"bad-timestamp", \
a1069 1
	char			psk_ifname[IFNAMSIZ];
d1182 6
a1187 6
	char	 pfiio_name[IFNAMSIZ];
	void	*pfiio_buffer;
	int	 pfiio_esize;
	int	 pfiio_size;
	int	 pfiio_nzero;
	int	 pfiio_flags;
d1203 1
a1203 1
#define DIOCCLRSTATES	_IOWR('D', 18, struct pfioc_state_kill)
a1276 1
extern struct pf_state_queue state_updates;
d1300 3
a1308 1
extern void			 pf_purge_expired_state(struct pf_state *);
a1317 2
extern void			 pf_print_state(struct pf_state *);
extern void			 pf_print_flags(u_int8_t);
a1324 2
extern u_int16_t		 pf_cksum_fixup(u_int16_t, u_int16_t, u_int16_t,
				    u_int8_t);
a1334 1
int	pf_test_eh(int, struct ifnet *, struct mbuf **, struct ether_header *);
a1338 1
int	pf_test6_eh(int, struct ifnet *, struct mbuf **, struct ether_header *);
d1357 2
a1358 4
int	pf_normalize_ip(struct mbuf **, int, struct pfi_kif *, u_short *,
	    struct pf_pdesc *);
int	pf_normalize_ip6(struct mbuf **, int, struct pfi_kif *, u_short *,
	    struct pf_pdesc *);
d1365 2
a1366 2
	    u_short *, struct tcphdr *, struct pf_state *,
	    struct pf_state_peer *, struct pf_state_peer *, int *);
a1411 1
struct pfi_kif	*pfi_lookup_if(const char *);
a1431 3
u_int32_t	pf_qname2qid(char *);
void		pf_qid2qname(u_int32_t, char *);
void		pf_qid_unref(u_int32_t);
@


