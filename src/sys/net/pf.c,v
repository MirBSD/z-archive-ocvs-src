head	1.7;
access;
symbols
	tg-mergetmp-mirosx-1:1.7
	tg-mergefixes-1-branch:1.7.0.4
	tg-mergefixes-1-base:1.7
	MIROS_X:1.7.0.2
	MIROS_X_BASE:1.7
	tg-mergetmp-3:1.7
	MIRBSD_XP_MIRPPC:1.1.1.27.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.27
	MIRBSD_XP_SPARC:1.1.1.27.0.2
	MIRBSD_7quater:1.1.1.22.4.1
	cvs-200405160640:1.1.1.27
	cvs-200401271800:1.1.1.26
	cvs-200401261630:1.1.1.25
	cvs-200401021645:1.1.1.24
	MIRBSD_7_ALPHA:1.1.1.22.0.6
	MIRBSD_7:1.1.1.22.0.4
	cvs-200312222040:1.1.1.23
	MIRBSD_7ter:1.1.1.22
	MIRBSD_7_DEV:1.1.1.22.0.2
	cvs-200310020700:1.1.1.22
	cvs-200309271030:1.1.1.21
	cvs-200309261655:1.1.1.20
	cvs-200309251530:1.1.1.19
	cvs-200308302005:1.1.1.18
	cvs-200308171200:1.1.1.17
	ctm-3496:1.1.1.16
	ctm-3449:1.1.1.15
	ctm-3437:1.1.1.15
	cvs-200307191805:1.1.1.15
	ctm-3425:1.1.1.14
	cvs-200307091500:1.1.1.13
	cvs-200307072125:1.1.1.13
	ctm-3389:1.1.1.13
	cvs-200307021520:1.1.1.12
	cvs-200306301805:1.1.1.12
	cvs-200306301405:1.1.1.12
	cvs-200306291430:1.1.1.11
	ctm-3341:1.1.1.10
	MIRBSD_5:1.1.1.9
	cvs-200306091240:1.1.1.9
	cvs-200306082100:1.1.1.8
	ctm-3316:1.1.1.8
	ctm-3272:1.1.1.7
	ctm-3264:1.1.1.6
	cvs-200305071630:1.1.1.6
	ctm-3255:1.1.1.5
	ctm-3229:1.1.1.4
	MIRBSD_4:1.5
	ctm-3203:1.1.1.4
	cvs-20030410-1130:1.1.1.3
	ctm-3155:1.1.1.2
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.12.07.22.17.26;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.05.19.20.51;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.15.20.12.01;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.10.20.12.23;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.29.21.33.34;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.23.21.52.51;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.52.03;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.52.03;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.03.29.19.48.02;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.04.10.14.52.55;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.04.15.17.45.09;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.05.18.57.31;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.05.07.17.51.37;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2003.05.21.19.10.58;	author tg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2003.06.05.17.41.05;	author tg;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2003.06.09.12.48.56;	author tg;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2003.06.19.12.51.09;	author tg;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2003.06.29.17.34.30;	author tg;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2003.06.30.14.13.14;	author tg;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2003.07.06.15.48.44;	author tg;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2003.07.18.13.50.30;	author tg;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2003.07.19.18.56.44;	author tg;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2003.08.11.18.41.30;	author tg;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2003.08.17.14.40.23;	author tg;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2003.08.30.23.26.37;	author tg;	state Exp;
branches;
next	1.1.1.19;

1.1.1.19
date	2003.09.25.16.39.45;	author tg;	state Exp;
branches;
next	1.1.1.20;

1.1.1.20
date	2003.09.26.17.10.28;	author tg;	state Exp;
branches;
next	1.1.1.21;

1.1.1.21
date	2003.09.27.11.12.07;	author tg;	state Exp;
branches;
next	1.1.1.22;

1.1.1.22
date	2003.10.02.07.42.47;	author tg;	state Exp;
branches
	1.1.1.22.4.1;
next	1.1.1.23;

1.1.1.23
date	2003.12.22.21.04.40;	author tg;	state Exp;
branches;
next	1.1.1.24;

1.1.1.24
date	2004.01.02.17.55.01;	author tg;	state Exp;
branches;
next	1.1.1.25;

1.1.1.25
date	2004.01.26.18.53.55;	author tg;	state Exp;
branches;
next	1.1.1.26;

1.1.1.26
date	2004.01.27.19.15.42;	author tg;	state Exp;
branches;
next	1.1.1.27;

1.1.1.27
date	2004.05.16.08.36.02;	author tg;	state Stab;
branches;
next	;

1.1.1.22.4.1
date	2004.05.25.21.03.48;	author bsiegert;	state Exp;
branches;
next	1.1.1.22.4.2;

1.1.1.22.4.2
date	2004.07.21.19.25.00;	author bsiegert;	state Exp;
branches;
next	1.1.1.22.4.3;

1.1.1.22.4.3
date	2005.01.30.17.48.18;	author bsiegert;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove pf features which are broken:
 ($interface) -> did never work correctly
 antispoof -> dangerous, false sense of security, side impacts, only for lazies

remove kernel stuff accordingly, but don't change ABI

update documentation
remove orphaned documentation nobody maintains
@
text
@/**	$MirBSD$ */
/*	$OpenBSD: pf.c,v 1.448 2004/05/11 07:34:11 dhartmei Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002,2003 Henning Brauer
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include "bpfilter.h"
#include "pflog.h"
#include "pfsync.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/filio.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/kernel.h>
#include <sys/time.h>
#include <sys/pool.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/bpf.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_seq.h>
#include <netinet/udp.h>
#include <netinet/ip_icmp.h>
#include <netinet/in_pcb.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/udp_var.h>
#include <netinet/icmp_var.h>
#include <netinet/if_ether.h>

#include <dev/rndvar.h>
#include <net/pfvar.h>
#include <net/if_pflog.h>

#if NPFSYNC > 0
#include <net/if_pfsync.h>
#endif /* NPFSYNC > 0 */

#ifdef INET6
#include <netinet/ip6.h>
#include <netinet/in_pcb.h>
#include <netinet/icmp6.h>
#include <netinet6/nd6.h>
#endif /* INET6 */


#define DPFPRINTF(n, x)	if (pf_status.debug >= (n)) printf x

/*
 * Global variables
 */

struct pf_anchorqueue	 pf_anchors;
struct pf_ruleset	 pf_main_ruleset;
struct pf_altqqueue	 pf_altqs[2];
struct pf_palist	 pf_pabuf;
struct pf_altqqueue	*pf_altqs_active;
struct pf_altqqueue	*pf_altqs_inactive;
struct pf_status	 pf_status;

u_int32_t		 ticket_altqs_active;
u_int32_t		 ticket_altqs_inactive;
int			 altqs_inactive_open;
u_int32_t		 ticket_pabuf;

struct timeout		 pf_expire_to;			/* expire timeout */

struct pool		 pf_src_tree_pl, pf_rule_pl;
struct pool		 pf_state_pl, pf_altq_pl, pf_pooladdr_pl;

void			 pf_print_host(struct pf_addr *, u_int16_t, u_int8_t);

void			 pf_change_ap(struct pf_addr *, u_int16_t *,
			    u_int16_t *, u_int16_t *, struct pf_addr *,
			    u_int16_t, u_int8_t, sa_family_t);
#ifdef INET6
void			 pf_change_a6(struct pf_addr *, u_int16_t *,
			    struct pf_addr *, u_int8_t);
#endif /* INET6 */
void			 pf_change_icmp(struct pf_addr *, u_int16_t *,
			    struct pf_addr *, struct pf_addr *, u_int16_t,
			    u_int16_t *, u_int16_t *, u_int16_t *,
			    u_int16_t *, u_int8_t, sa_family_t);
void			 pf_send_tcp(const struct pf_rule *, sa_family_t,
			    const struct pf_addr *, const struct pf_addr *,
			    u_int16_t, u_int16_t, u_int32_t, u_int32_t,
			    u_int8_t, u_int16_t, u_int16_t, u_int8_t, int,
			    struct ether_header *, struct ifnet *);
void			 pf_send_icmp(struct mbuf *, u_int8_t, u_int8_t,
			    sa_family_t, struct pf_rule *);
struct pf_rule		*pf_match_translation(struct pf_pdesc *, struct mbuf *,
			    int, int, struct pfi_kif *,
			    struct pf_addr *, u_int16_t, struct pf_addr *,
			    u_int16_t, int);
struct pf_rule		*pf_get_translation(struct pf_pdesc *, struct mbuf *,
			    int, int, struct pfi_kif *, struct pf_src_node **,
			    struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t *);
int			 pf_test_tcp(struct pf_rule **, struct pf_state **,
			    int, struct pfi_kif *, struct mbuf *, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **, struct ifqueue *);
int			 pf_test_udp(struct pf_rule **, struct pf_state **,
			    int, struct pfi_kif *, struct mbuf *, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **, struct ifqueue *);
int			 pf_test_icmp(struct pf_rule **, struct pf_state **,
			    int, struct pfi_kif *, struct mbuf *, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **, struct ifqueue *);
int			 pf_test_other(struct pf_rule **, struct pf_state **,
			    int, struct pfi_kif *, struct mbuf *, int, void *,
			    struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **, struct ifqueue *);
int			 pf_test_fragment(struct pf_rule **, int,
			    struct pfi_kif *, struct mbuf *, void *,
			    struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
int			 pf_test_state_tcp(struct pf_state **, int,
			    struct pfi_kif *, struct mbuf *, int,
			    void *, struct pf_pdesc *, u_short *);
int			 pf_test_state_udp(struct pf_state **, int,
			    struct pfi_kif *, struct mbuf *, int,
			    void *, struct pf_pdesc *);
int			 pf_test_state_icmp(struct pf_state **, int,
			    struct pfi_kif *, struct mbuf *, int,
			    void *, struct pf_pdesc *);
int			 pf_test_state_other(struct pf_state **, int,
			    struct pfi_kif *, struct pf_pdesc *);
struct pf_tag		*pf_get_tag(struct mbuf *);
int			 pf_match_tag(struct mbuf *, struct pf_rule *,
			     struct pf_rule *, struct pf_tag **, int *);
void			 pf_hash(struct pf_addr *, struct pf_addr *,
			    struct pf_poolhashkey *, sa_family_t);
int			 pf_map_addr(u_int8_t, struct pf_rule *,
			    struct pf_addr *, struct pf_addr *,
			    struct pf_addr *, struct pf_src_node **);
int			 pf_get_sport(sa_family_t, u_int8_t, struct pf_rule *,
			    struct pf_addr *, struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t*, u_int16_t, u_int16_t,
			    struct pf_src_node **);
void			 pf_route(struct mbuf **, struct pf_rule *, int,
			    struct ifnet *, struct pf_state *);
void			 pf_route6(struct mbuf **, struct pf_rule *, int,
			    struct ifnet *, struct pf_state *);
int			 pf_socket_lookup(uid_t *, gid_t *,
			    int, struct pf_pdesc *);
u_int8_t		 pf_get_wscale(struct mbuf *, int, u_int16_t,
			    sa_family_t);
u_int16_t		 pf_get_mss(struct mbuf *, int, u_int16_t,
			    sa_family_t);
u_int16_t		 pf_calc_mss(struct pf_addr *, sa_family_t,
				u_int16_t);
void			 pf_set_rt_ifp(struct pf_state *,
			    struct pf_addr *);
int			 pf_check_proto_cksum(struct mbuf *, int, int,
			    u_int8_t, sa_family_t);
int			 pf_addr_wrap_neq(struct pf_addr_wrap *,
			    struct pf_addr_wrap *);
static int		 pf_add_mbuf_tag(struct mbuf *, u_int);
struct pf_state		*pf_find_state_recurse(struct pfi_kif *,
			    struct pf_state *, u_int8_t);
int			 pf_check_congestion(struct ifqueue *);

struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] = {
	{ &pf_state_pl, PFSTATE_HIWAT },
	{ &pf_src_tree_pl, PFSNODE_HIWAT },
	{ &pf_frent_pl, PFFRAG_FRENT_HIWAT }
};

#define STATE_LOOKUP()							\
	do {								\
		if (direction == PF_IN)					\
			*state = pf_find_state_recurse(		\
			    kif, &key, PF_EXT_GWY);			\
		else							\
			*state = pf_find_state_recurse(		\
			    kif, &key, PF_LAN_EXT);			\
		if (*state == NULL)					\
			return (PF_DROP);				\
		if (direction == PF_OUT &&				\
		    (((*state)->rule.ptr->rt == PF_ROUTETO &&		\
		    (*state)->rule.ptr->direction == PF_OUT) ||		\
		    ((*state)->rule.ptr->rt == PF_REPLYTO &&		\
		    (*state)->rule.ptr->direction == PF_IN)) &&		\
		    (*state)->rt_kif != NULL &&				\
		    (*state)->rt_kif != kif)				\
			return (PF_PASS);				\
	} while (0)

#define	STATE_TRANSLATE(s) \
	(s)->lan.addr.addr32[0] != (s)->gwy.addr.addr32[0] || \
	((s)->af == AF_INET6 && \
	((s)->lan.addr.addr32[1] != (s)->gwy.addr.addr32[1] || \
	(s)->lan.addr.addr32[2] != (s)->gwy.addr.addr32[2] || \
	(s)->lan.addr.addr32[3] != (s)->gwy.addr.addr32[3])) || \
	(s)->lan.port != (s)->gwy.port

#define BOUND_IFACE(r, k) (((r)->rule_flag & PFRULE_IFBOUND) ? (k) :   \
	((r)->rule_flag & PFRULE_GRBOUND) ? (k)->pfik_parent :	       \
	(k)->pfik_parent->pfik_parent)

static __inline int pf_src_compare(struct pf_src_node *, struct pf_src_node *);
static __inline int pf_state_compare_lan_ext(struct pf_state *,
	struct pf_state *);
static __inline int pf_state_compare_ext_gwy(struct pf_state *,
	struct pf_state *);
static __inline int pf_state_compare_id(struct pf_state *,
	struct pf_state *);

struct pf_src_tree tree_src_tracking;

struct pf_state_tree_id tree_id;
struct pf_state_queue state_updates;

RB_GENERATE(pf_src_tree, pf_src_node, entry, pf_src_compare);
RB_GENERATE(pf_state_tree_lan_ext, pf_state,
    u.s.entry_lan_ext, pf_state_compare_lan_ext);
RB_GENERATE(pf_state_tree_ext_gwy, pf_state,
    u.s.entry_ext_gwy, pf_state_compare_ext_gwy);
RB_GENERATE(pf_state_tree_id, pf_state,
    u.s.entry_id, pf_state_compare_id);

static __inline int
pf_src_compare(struct pf_src_node *a, struct pf_src_node *b)
{
	int	diff;

	if (a->rule.ptr > b->rule.ptr)
		return (1);
	if (a->rule.ptr < b->rule.ptr)
		return (-1);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	switch (a->af) {
#ifdef INET
	case AF_INET:
		if (a->addr.addr32[0] > b->addr.addr32[0])
			return (1);
		if (a->addr.addr32[0] < b->addr.addr32[0])
			return (-1);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (a->addr.addr32[3] > b->addr.addr32[3])
			return (1);
		if (a->addr.addr32[3] < b->addr.addr32[3])
			return (-1);
		if (a->addr.addr32[2] > b->addr.addr32[2])
			return (1);
		if (a->addr.addr32[2] < b->addr.addr32[2])
			return (-1);
		if (a->addr.addr32[1] > b->addr.addr32[1])
			return (1);
		if (a->addr.addr32[1] < b->addr.addr32[1])
			return (-1);
		if (a->addr.addr32[0] > b->addr.addr32[0])
			return (1);
		if (a->addr.addr32[0] < b->addr.addr32[0])
			return (-1);
		break;
#endif /* INET6 */
	}
	return (0);
}

static __inline int
pf_state_compare_lan_ext(struct pf_state *a, struct pf_state *b)
{
	int	diff;

	if ((diff = a->proto - b->proto) != 0)
		return (diff);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	switch (a->af) {
#ifdef INET
	case AF_INET:
		if (a->lan.addr.addr32[0] > b->lan.addr.addr32[0])
			return (1);
		if (a->lan.addr.addr32[0] < b->lan.addr.addr32[0])
			return (-1);
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (a->lan.addr.addr32[3] > b->lan.addr.addr32[3])
			return (1);
		if (a->lan.addr.addr32[3] < b->lan.addr.addr32[3])
			return (-1);
		if (a->ext.addr.addr32[3] > b->ext.addr.addr32[3])
			return (1);
		if (a->ext.addr.addr32[3] < b->ext.addr.addr32[3])
			return (-1);
		if (a->lan.addr.addr32[2] > b->lan.addr.addr32[2])
			return (1);
		if (a->lan.addr.addr32[2] < b->lan.addr.addr32[2])
			return (-1);
		if (a->ext.addr.addr32[2] > b->ext.addr.addr32[2])
			return (1);
		if (a->ext.addr.addr32[2] < b->ext.addr.addr32[2])
			return (-1);
		if (a->lan.addr.addr32[1] > b->lan.addr.addr32[1])
			return (1);
		if (a->lan.addr.addr32[1] < b->lan.addr.addr32[1])
			return (-1);
		if (a->ext.addr.addr32[1] > b->ext.addr.addr32[1])
			return (1);
		if (a->ext.addr.addr32[1] < b->ext.addr.addr32[1])
			return (-1);
		if (a->lan.addr.addr32[0] > b->lan.addr.addr32[0])
			return (1);
		if (a->lan.addr.addr32[0] < b->lan.addr.addr32[0])
			return (-1);
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		break;
#endif /* INET6 */
	}

	if ((diff = a->lan.port - b->lan.port) != 0)
		return (diff);
	if ((diff = a->ext.port - b->ext.port) != 0)
		return (diff);

	return (0);
}

static __inline int
pf_state_compare_ext_gwy(struct pf_state *a, struct pf_state *b)
{
	int	diff;

	if ((diff = a->proto - b->proto) != 0)
		return (diff);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	switch (a->af) {
#ifdef INET
	case AF_INET:
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		if (a->gwy.addr.addr32[0] > b->gwy.addr.addr32[0])
			return (1);
		if (a->gwy.addr.addr32[0] < b->gwy.addr.addr32[0])
			return (-1);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (a->ext.addr.addr32[3] > b->ext.addr.addr32[3])
			return (1);
		if (a->ext.addr.addr32[3] < b->ext.addr.addr32[3])
			return (-1);
		if (a->gwy.addr.addr32[3] > b->gwy.addr.addr32[3])
			return (1);
		if (a->gwy.addr.addr32[3] < b->gwy.addr.addr32[3])
			return (-1);
		if (a->ext.addr.addr32[2] > b->ext.addr.addr32[2])
			return (1);
		if (a->ext.addr.addr32[2] < b->ext.addr.addr32[2])
			return (-1);
		if (a->gwy.addr.addr32[2] > b->gwy.addr.addr32[2])
			return (1);
		if (a->gwy.addr.addr32[2] < b->gwy.addr.addr32[2])
			return (-1);
		if (a->ext.addr.addr32[1] > b->ext.addr.addr32[1])
			return (1);
		if (a->ext.addr.addr32[1] < b->ext.addr.addr32[1])
			return (-1);
		if (a->gwy.addr.addr32[1] > b->gwy.addr.addr32[1])
			return (1);
		if (a->gwy.addr.addr32[1] < b->gwy.addr.addr32[1])
			return (-1);
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		if (a->gwy.addr.addr32[0] > b->gwy.addr.addr32[0])
			return (1);
		if (a->gwy.addr.addr32[0] < b->gwy.addr.addr32[0])
			return (-1);
		break;
#endif /* INET6 */
	}

	if ((diff = a->ext.port - b->ext.port) != 0)
		return (diff);
	if ((diff = a->gwy.port - b->gwy.port) != 0)
		return (diff);

	return (0);
}

static __inline int
pf_state_compare_id(struct pf_state *a, struct pf_state *b)
{
	if (a->id > b->id)
		return (1);
	if (a->id < b->id)
		return (-1);
	if (a->creatorid > b->creatorid)
		return (1);
	if (a->creatorid < b->creatorid)
		return (-1);

	return (0);
}

#ifdef INET6
void
pf_addrcpy(struct pf_addr *dst, struct pf_addr *src, sa_family_t af)
{
	switch (af) {
#ifdef INET
	case AF_INET:
		dst->addr32[0] = src->addr32[0];
		break;
#endif /* INET */
	case AF_INET6:
		dst->addr32[0] = src->addr32[0];
		dst->addr32[1] = src->addr32[1];
		dst->addr32[2] = src->addr32[2];
		dst->addr32[3] = src->addr32[3];
		break;
	}
}
#endif /* INET6 */

struct pf_state *
pf_find_state_byid(struct pf_state *key)
{
	pf_status.fcounters[FCNT_STATE_SEARCH]++;
	return (RB_FIND(pf_state_tree_id, &tree_id, key));
}

struct pf_state *
pf_find_state_recurse(struct pfi_kif *kif, struct pf_state *key, u_int8_t tree)
{
	struct pf_state *s;

	pf_status.fcounters[FCNT_STATE_SEARCH]++;

	switch (tree) {
	case PF_LAN_EXT:
		for (; kif != NULL; kif = kif->pfik_parent) {
			s = RB_FIND(pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext, key);
			if (s != NULL)
				return (s);
		}
		return (NULL);
	case PF_EXT_GWY:
		for (; kif != NULL; kif = kif->pfik_parent) {
			s = RB_FIND(pf_state_tree_ext_gwy,
			    &kif->pfik_ext_gwy, key);
			if (s != NULL)
				return (s);
		}
		return (NULL);
	default:
		panic("pf_find_state_recurse");
	}
}

struct pf_state *
pf_find_state_all(struct pf_state *key, u_int8_t tree, int *more)
{
	struct pf_state *s, *ss = NULL;
	struct pfi_kif	*kif;

	pf_status.fcounters[FCNT_STATE_SEARCH]++;

	switch (tree) {
	case PF_LAN_EXT:
		TAILQ_FOREACH(kif, &pfi_statehead, pfik_w_states) {
			s = RB_FIND(pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext, key);
			if (s == NULL)
				continue;
			if (more == NULL)
				return (s);
			ss = s;
			(*more)++;
		}
		return (ss);
	case PF_EXT_GWY:
		TAILQ_FOREACH(kif, &pfi_statehead, pfik_w_states) {
			s = RB_FIND(pf_state_tree_ext_gwy,
			    &kif->pfik_ext_gwy, key);
			if (s == NULL)
				continue;
			if (more == NULL)
				return (s);
			ss = s;
			(*more)++;
		}
		return (ss);
	default:
		panic("pf_find_state_all");
	}
}

int
pf_insert_src_node(struct pf_src_node **sn, struct pf_rule *rule,
    struct pf_addr *src, sa_family_t af)
{
	struct pf_src_node	k;

	if (*sn == NULL) {
		k.af = af;
		PF_ACPY(&k.addr, src, af);
		if (rule->rule_flag & PFRULE_RULESRCTRACK ||
		    rule->rpool.opts & PF_POOL_STICKYADDR)
			k.rule.ptr = rule;
		else
			k.rule.ptr = NULL;
		pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
		*sn = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
	}
	if (*sn == NULL) {
		if (!rule->max_src_nodes ||
		    rule->src_nodes < rule->max_src_nodes)
			(*sn) = pool_get(&pf_src_tree_pl, PR_NOWAIT);
		if ((*sn) == NULL)
			return (-1);
		bzero(*sn, sizeof(struct pf_src_node));
		(*sn)->af = af;
		if (rule->rule_flag & PFRULE_RULESRCTRACK ||
		    rule->rpool.opts & PF_POOL_STICKYADDR)
			(*sn)->rule.ptr = rule;
		else
			(*sn)->rule.ptr = NULL;
		PF_ACPY(&(*sn)->addr, src, af);
		if (RB_INSERT(pf_src_tree,
		    &tree_src_tracking, *sn) != NULL) {
			if (pf_status.debug >= PF_DEBUG_MISC) {
				printf("pf: src_tree insert failed: ");
				pf_print_host(&(*sn)->addr, 0, af);
				printf("\n");
			}
			pool_put(&pf_src_tree_pl, *sn);
			return (-1);
		}
		(*sn)->creation = time.tv_sec;
		(*sn)->ruletype = rule->action;
		if ((*sn)->rule.ptr != NULL)
			(*sn)->rule.ptr->src_nodes++;
		pf_status.scounters[SCNT_SRC_NODE_INSERT]++;
		pf_status.src_nodes++;
	} else {
		if (rule->max_src_states &&
		    (*sn)->states >= rule->max_src_states)
			return (-1);
	}
	return (0);
}

int
pf_insert_state(struct pfi_kif *kif, struct pf_state *state)
{
	/* Thou MUST NOT insert multiple duplicate keys */
	state->u.s.kif = kif;
	if (RB_INSERT(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state)) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: tree_lan_ext");
			printf(" lan: ");
			pf_print_host(&state->lan.addr, state->lan.port,
			    state->af);
			printf(" gwy: ");
			pf_print_host(&state->gwy.addr, state->gwy.port,
			    state->af);
			printf(" ext: ");
			pf_print_host(&state->ext.addr, state->ext.port,
			    state->af);
			if (state->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
			printf("\n");
		}
		return (-1);
	}

	if (RB_INSERT(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy, state)) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: tree_ext_gwy");
			printf(" lan: ");
			pf_print_host(&state->lan.addr, state->lan.port,
			    state->af);
			printf(" gwy: ");
			pf_print_host(&state->gwy.addr, state->gwy.port,
			    state->af);
			printf(" ext: ");
			pf_print_host(&state->ext.addr, state->ext.port,
			    state->af);
			if (state->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
			printf("\n");
		}
		RB_REMOVE(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state);
		return (-1);
	}

	if (state->id == 0 && state->creatorid == 0) {
		state->id = htobe64(pf_status.stateid++);
		state->creatorid = pf_status.hostid;
	}
	if (RB_INSERT(pf_state_tree_id, &tree_id, state) != NULL) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: "
			    "id: %016llx creatorid: %08x",
			    betoh64(state->id), ntohl(state->creatorid));
			if (state->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
			printf("\n");
		}
		RB_REMOVE(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state);
		RB_REMOVE(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy, state);
		return (-1);
	}
	TAILQ_INSERT_HEAD(&state_updates, state, u.s.entry_updates);

	pf_status.fcounters[FCNT_STATE_INSERT]++;
	pf_status.states++;
	pfi_attach_state(kif);
#if NPFSYNC
	pfsync_insert_state(state);
#endif
	return (0);
}

void
pf_purge_timeout(void *arg)
{
	struct timeout	*to = arg;
	int		 s;

	s = splsoftnet();
	pf_purge_expired_states();
	pf_purge_expired_fragments();
	pf_purge_expired_src_nodes();
	splx(s);

	timeout_add(to, pf_default_rule.timeout[PFTM_INTERVAL] * hz);
}

u_int32_t
pf_state_expires(const struct pf_state *state)
{
	u_int32_t	timeout;
	u_int32_t	start;
	u_int32_t	end;
	u_int32_t	states;

	/* handle all PFTM_* > PFTM_MAX here */
	if (state->timeout == PFTM_PURGE)
		return (time.tv_sec);
	if (state->timeout == PFTM_UNTIL_PACKET)
		return (0);
	KASSERT(state->timeout < PFTM_MAX);
	timeout = state->rule.ptr->timeout[state->timeout];
	if (!timeout)
		timeout = pf_default_rule.timeout[state->timeout];
	start = state->rule.ptr->timeout[PFTM_ADAPTIVE_START];
	if (start) {
		end = state->rule.ptr->timeout[PFTM_ADAPTIVE_END];
		states = state->rule.ptr->states;
	} else {
		start = pf_default_rule.timeout[PFTM_ADAPTIVE_START];
		end = pf_default_rule.timeout[PFTM_ADAPTIVE_END];
		states = pf_status.states;
	}
	if (end && states > start && start < end) {
		if (states < end)
			return (state->expire + timeout * (end - states) /
			    (end - start));
		else
			return (time.tv_sec);
	}
	return (state->expire + timeout);
}

void
pf_purge_expired_src_nodes(void)
{
	 struct pf_src_node		*cur, *next;

	 for (cur = RB_MIN(pf_src_tree, &tree_src_tracking); cur; cur = next) {
		 next = RB_NEXT(pf_src_tree, &tree_src_tracking, cur);

		 if (cur->states <= 0 && cur->expire <= time.tv_sec) {
			 if (cur->rule.ptr != NULL) {
				 cur->rule.ptr->src_nodes--;
				 if (cur->rule.ptr->states <= 0 &&
				     cur->rule.ptr->max_src_nodes <= 0)
					 pf_rm_rule(NULL, cur->rule.ptr);
			 }
			 RB_REMOVE(pf_src_tree, &tree_src_tracking, cur);
			 pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
			 pf_status.src_nodes--;
			 pool_put(&pf_src_tree_pl, cur);
		 }
	 }
}

void
pf_src_tree_remove_state(struct pf_state *s)
{
	u_int32_t timeout;

	if (s->src_node != NULL) {
		if (--s->src_node->states <= 0) {
			timeout = s->rule.ptr->timeout[PFTM_SRC_NODE];
			if (!timeout)
				timeout =
				    pf_default_rule.timeout[PFTM_SRC_NODE];
			s->src_node->expire = time.tv_sec + timeout;
		}
	}
	if (s->nat_src_node != s->src_node && s->nat_src_node != NULL) {
		if (--s->nat_src_node->states <= 0) {
			timeout = s->rule.ptr->timeout[PFTM_SRC_NODE];
			if (!timeout)
				timeout =
				    pf_default_rule.timeout[PFTM_SRC_NODE];
			s->nat_src_node->expire = time.tv_sec + timeout;
		}
	}
	s->src_node = s->nat_src_node = NULL;
}

void
pf_purge_expired_state(struct pf_state *cur)
{
	if (cur->src.state == PF_TCPS_PROXY_DST)
		pf_send_tcp(cur->rule.ptr, cur->af,
		    &cur->ext.addr, &cur->lan.addr,
		    cur->ext.port, cur->lan.port,
		    cur->src.seqhi, cur->src.seqlo + 1,
		    TH_RST|TH_ACK, 0, 0, 0, 1, NULL, NULL);
	RB_REMOVE(pf_state_tree_ext_gwy,
	    &cur->u.s.kif->pfik_ext_gwy, cur);
	RB_REMOVE(pf_state_tree_lan_ext,
	    &cur->u.s.kif->pfik_lan_ext, cur);
	RB_REMOVE(pf_state_tree_id, &tree_id, cur);
#if NPFSYNC
	pfsync_delete_state(cur);
#endif
	pf_src_tree_remove_state(cur);
	if (--cur->rule.ptr->states <= 0 &&
	    cur->rule.ptr->src_nodes <= 0)
		pf_rm_rule(NULL, cur->rule.ptr);
	if (cur->nat_rule.ptr != NULL)
		if (--cur->nat_rule.ptr->states <= 0 &&
			cur->nat_rule.ptr->src_nodes <= 0)
			pf_rm_rule(NULL, cur->nat_rule.ptr);
	if (cur->anchor.ptr != NULL)
		if (--cur->anchor.ptr->states <= 0)
			pf_rm_rule(NULL, cur->anchor.ptr);
	pf_normalize_tcp_cleanup(cur);
	pfi_detach_state(cur->u.s.kif);
	TAILQ_REMOVE(&state_updates, cur, u.s.entry_updates);
	pool_put(&pf_state_pl, cur);
	pf_status.fcounters[FCNT_STATE_REMOVALS]++;
	pf_status.states--;
}

void
pf_purge_expired_states(void)
{
	struct pf_state		*cur, *next;

	for (cur = RB_MIN(pf_state_tree_id, &tree_id);
	    cur; cur = next) {
		next = RB_NEXT(pf_state_tree_id, &tree_id, cur);
		if (pf_state_expires(cur) <= time.tv_sec)
			pf_purge_expired_state(cur);
	}
}

int
pf_tbladdr_setup(struct pf_ruleset *rs, struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_TABLE)
		return (0);
	if ((aw->p.tbl = pfr_attach_table(rs, aw->v.tblname)) == NULL)
		return (1);
	return (0);
}

void
pf_tbladdr_remove(struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_TABLE || aw->p.tbl == NULL)
		return;
	pfr_detach_table(aw->p.tbl);
	aw->p.tbl = NULL;
}

void
pf_tbladdr_copyout(struct pf_addr_wrap *aw)
{
	struct pfr_ktable *kt = aw->p.tbl;

	if (aw->type != PF_ADDR_TABLE || kt == NULL)
		return;
	if (!(kt->pfrkt_flags & PFR_TFLAG_ACTIVE) && kt->pfrkt_root != NULL)
		kt = kt->pfrkt_root;
	aw->p.tbl = NULL;
	aw->p.tblcnt = (kt->pfrkt_flags & PFR_TFLAG_ACTIVE) ?
		kt->pfrkt_cnt : -1;
}

void
pf_print_host(struct pf_addr *addr, u_int16_t p, sa_family_t af)
{
	switch (af) {
#ifdef INET
	case AF_INET: {
		u_int32_t a = ntohl(addr->addr32[0]);
		printf("%u.%u.%u.%u", (a>>24)&255, (a>>16)&255,
		    (a>>8)&255, a&255);
		if (p) {
			p = ntohs(p);
			printf(":%u", p);
		}
		break;
	}
#endif /* INET */
#ifdef INET6
	case AF_INET6: {
		u_int16_t b;
		u_int8_t i, curstart = 255, curend = 0,
		    maxstart = 0, maxend = 0;
		for (i = 0; i < 8; i++) {
			if (!addr->addr16[i]) {
				if (curstart == 255)
					curstart = i;
				else
					curend = i;
			} else {
				if (curstart) {
					if ((curend - curstart) >
					    (maxend - maxstart)) {
						maxstart = curstart;
						maxend = curend;
						curstart = 255;
					}
				}
			}
		}
		for (i = 0; i < 8; i++) {
			if (i >= maxstart && i <= maxend) {
				if (maxend != 7) {
					if (i == maxstart)
						printf(":");
				} else {
					if (i == maxend)
						printf(":");
				}
			} else {
				b = ntohs(addr->addr16[i]);
				printf("%x", b);
				if (i < 7)
					printf(":");
			}
		}
		if (p) {
			p = ntohs(p);
			printf("[%u]", p);
		}
		break;
	}
#endif /* INET6 */
	}
}

void
pf_print_state(struct pf_state *s)
{
	switch (s->proto) {
	case IPPROTO_TCP:
		printf("TCP ");
		break;
	case IPPROTO_UDP:
		printf("UDP ");
		break;
	case IPPROTO_ICMP:
		printf("ICMP ");
		break;
	case IPPROTO_ICMPV6:
		printf("ICMPV6 ");
		break;
	default:
		printf("%u ", s->proto);
		break;
	}
	pf_print_host(&s->lan.addr, s->lan.port, s->af);
	printf(" ");
	pf_print_host(&s->gwy.addr, s->gwy.port, s->af);
	printf(" ");
	pf_print_host(&s->ext.addr, s->ext.port, s->af);
	printf(" [lo=%u high=%u win=%u modulator=%u", s->src.seqlo,
	    s->src.seqhi, s->src.max_win, s->src.seqdiff);
	if (s->src.wscale && s->dst.wscale)
		printf(" wscale=%u", s->src.wscale & PF_WSCALE_MASK);
	printf("]");
	printf(" [lo=%u high=%u win=%u modulator=%u", s->dst.seqlo,
	    s->dst.seqhi, s->dst.max_win, s->dst.seqdiff);
	if (s->src.wscale && s->dst.wscale)
		printf(" wscale=%u", s->dst.wscale & PF_WSCALE_MASK);
	printf("]");
	printf(" %u:%u", s->src.state, s->dst.state);
}

void
pf_print_flags(u_int8_t f)
{
	if (f)
		printf(" ");
	if (f & TH_FIN)
		printf("F");
	if (f & TH_SYN)
		printf("S");
	if (f & TH_RST)
		printf("R");
	if (f & TH_PUSH)
		printf("P");
	if (f & TH_ACK)
		printf("A");
	if (f & TH_URG)
		printf("U");
	if (f & TH_ECE)
		printf("E");
	if (f & TH_CWR)
		printf("W");
}

#define	PF_SET_SKIP_STEPS(i)					\
	do {							\
		while (head[i] != cur) {			\
			head[i]->skip[i].ptr = cur;		\
			head[i] = TAILQ_NEXT(head[i], entries);	\
		}						\
	} while (0)

void
pf_calc_skip_steps(struct pf_rulequeue *rules)
{
	struct pf_rule *cur, *prev, *head[PF_SKIP_COUNT];
	int i;

	cur = TAILQ_FIRST(rules);
	prev = cur;
	for (i = 0; i < PF_SKIP_COUNT; ++i)
		head[i] = cur;
	while (cur != NULL) {

		if (cur->kif != prev->kif || cur->ifnot != prev->ifnot)
			PF_SET_SKIP_STEPS(PF_SKIP_IFP);
		if (cur->direction != prev->direction)
			PF_SET_SKIP_STEPS(PF_SKIP_DIR);
		if (cur->af != prev->af)
			PF_SET_SKIP_STEPS(PF_SKIP_AF);
		if (cur->proto != prev->proto)
			PF_SET_SKIP_STEPS(PF_SKIP_PROTO);
		if (cur->src.not != prev->src.not ||
		    pf_addr_wrap_neq(&cur->src.addr, &prev->src.addr))
			PF_SET_SKIP_STEPS(PF_SKIP_SRC_ADDR);
		if (cur->src.port[0] != prev->src.port[0] ||
		    cur->src.port[1] != prev->src.port[1] ||
		    cur->src.port_op != prev->src.port_op)
			PF_SET_SKIP_STEPS(PF_SKIP_SRC_PORT);
		if (cur->dst.not != prev->dst.not ||
		    pf_addr_wrap_neq(&cur->dst.addr, &prev->dst.addr))
			PF_SET_SKIP_STEPS(PF_SKIP_DST_ADDR);
		if (cur->dst.port[0] != prev->dst.port[0] ||
		    cur->dst.port[1] != prev->dst.port[1] ||
		    cur->dst.port_op != prev->dst.port_op)
			PF_SET_SKIP_STEPS(PF_SKIP_DST_PORT);

		prev = cur;
		cur = TAILQ_NEXT(cur, entries);
	}
	for (i = 0; i < PF_SKIP_COUNT; ++i)
		PF_SET_SKIP_STEPS(i);
}

int
pf_addr_wrap_neq(struct pf_addr_wrap *aw1, struct pf_addr_wrap *aw2)
{
	if (aw1->type != aw2->type)
		return (1);
	switch (aw1->type) {
	case PF_ADDR_ADDRMASK:
		if (PF_ANEQ(&aw1->v.a.addr, &aw2->v.a.addr, 0))
			return (1);
		if (PF_ANEQ(&aw1->v.a.mask, &aw2->v.a.mask, 0))
			return (1);
		return (0);
	case PF_ADDR_NOROUTE:
		return (0);
	case PF_ADDR_TABLE:
		return (aw1->p.tbl != aw2->p.tbl);
	default:
		printf("invalid address type: %d\n", aw1->type);
		return (1);
	}
}

u_int16_t
pf_cksum_fixup(u_int16_t cksum, u_int16_t old, u_int16_t new, u_int8_t udp)
{
	u_int32_t	l;

	if (udp && !cksum)
		return (0x0000);
	l = cksum + old - new;
	l = (l >> 16) + (l & 65535);
	l = l & 65535;
	if (udp && !l)
		return (0xFFFF);
	return (l);
}

void
pf_change_ap(struct pf_addr *a, u_int16_t *p, u_int16_t *ic, u_int16_t *pc,
    struct pf_addr *an, u_int16_t pn, u_int8_t u, sa_family_t af)
{
	struct pf_addr	ao;
	u_int16_t	po = *p;

	PF_ACPY(&ao, a, af);
	PF_ACPY(a, an, af);

	*p = pn;

	switch (af) {
#ifdef INET
	case AF_INET:
		*ic = pf_cksum_fixup(pf_cksum_fixup(*ic,
		    ao.addr16[0], an->addr16[0], 0),
		    ao.addr16[1], an->addr16[1], 0);
		*p = pn;
		*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
		    ao.addr16[0], an->addr16[0], u),
		    ao.addr16[1], an->addr16[1], u),
		    po, pn, u);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
		    ao.addr16[0], an->addr16[0], u),
		    ao.addr16[1], an->addr16[1], u),
		    ao.addr16[2], an->addr16[2], u),
		    ao.addr16[3], an->addr16[3], u),
		    ao.addr16[4], an->addr16[4], u),
		    ao.addr16[5], an->addr16[5], u),
		    ao.addr16[6], an->addr16[6], u),
		    ao.addr16[7], an->addr16[7], u),
		    po, pn, u);
		break;
#endif /* INET6 */
	}
}


/* Changes a u_int32_t.  Uses a void * so there are no align restrictions */
void
pf_change_a(void *a, u_int16_t *c, u_int32_t an, u_int8_t u)
{
	u_int32_t	ao;

	memcpy(&ao, a, sizeof(ao));
	memcpy(a, &an, sizeof(u_int32_t));
	*c = pf_cksum_fixup(pf_cksum_fixup(*c, ao / 65536, an / 65536, u),
	    ao % 65536, an % 65536, u);
}

#ifdef INET6
void
pf_change_a6(struct pf_addr *a, u_int16_t *c, struct pf_addr *an, u_int8_t u)
{
	struct pf_addr	ao;

	PF_ACPY(&ao, a, AF_INET6);
	PF_ACPY(a, an, AF_INET6);

	*c = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
	    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
	    pf_cksum_fixup(pf_cksum_fixup(*c,
	    ao.addr16[0], an->addr16[0], u),
	    ao.addr16[1], an->addr16[1], u),
	    ao.addr16[2], an->addr16[2], u),
	    ao.addr16[3], an->addr16[3], u),
	    ao.addr16[4], an->addr16[4], u),
	    ao.addr16[5], an->addr16[5], u),
	    ao.addr16[6], an->addr16[6], u),
	    ao.addr16[7], an->addr16[7], u);
}
#endif /* INET6 */

void
pf_change_icmp(struct pf_addr *ia, u_int16_t *ip, struct pf_addr *oa,
    struct pf_addr *na, u_int16_t np, u_int16_t *pc, u_int16_t *h2c,
    u_int16_t *ic, u_int16_t *hc, u_int8_t u, sa_family_t af)
{
	struct pf_addr	oia, ooa;

	PF_ACPY(&oia, ia, af);
	PF_ACPY(&ooa, oa, af);

	/* Change inner protocol port, fix inner protocol checksum. */
	if (ip != NULL) {
		u_int16_t	oip = *ip;
		u_int32_t	opc;

		if (pc != NULL)
			opc = *pc;
		*ip = np;
		if (pc != NULL)
			*pc = pf_cksum_fixup(*pc, oip, *ip, u);
		*ic = pf_cksum_fixup(*ic, oip, *ip, 0);
		if (pc != NULL)
			*ic = pf_cksum_fixup(*ic, opc, *pc, 0);
	}
	/* Change inner ip address, fix inner ip and icmp checksums. */
	PF_ACPY(ia, na, af);
	switch (af) {
#ifdef INET
	case AF_INET: {
		u_int32_t	 oh2c = *h2c;

		*h2c = pf_cksum_fixup(pf_cksum_fixup(*h2c,
		    oia.addr16[0], ia->addr16[0], 0),
		    oia.addr16[1], ia->addr16[1], 0);
		*ic = pf_cksum_fixup(pf_cksum_fixup(*ic,
		    oia.addr16[0], ia->addr16[0], 0),
		    oia.addr16[1], ia->addr16[1], 0);
		*ic = pf_cksum_fixup(*ic, oh2c, *h2c, 0);
		break;
	}
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		*ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(*ic,
		    oia.addr16[0], ia->addr16[0], u),
		    oia.addr16[1], ia->addr16[1], u),
		    oia.addr16[2], ia->addr16[2], u),
		    oia.addr16[3], ia->addr16[3], u),
		    oia.addr16[4], ia->addr16[4], u),
		    oia.addr16[5], ia->addr16[5], u),
		    oia.addr16[6], ia->addr16[6], u),
		    oia.addr16[7], ia->addr16[7], u);
		break;
#endif /* INET6 */
	}
	/* Change outer ip address, fix outer ip or icmpv6 checksum. */
	PF_ACPY(oa, na, af);
	switch (af) {
#ifdef INET
	case AF_INET:
		*hc = pf_cksum_fixup(pf_cksum_fixup(*hc,
		    ooa.addr16[0], oa->addr16[0], 0),
		    ooa.addr16[1], oa->addr16[1], 0);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		*ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(*ic,
		    ooa.addr16[0], oa->addr16[0], u),
		    ooa.addr16[1], oa->addr16[1], u),
		    ooa.addr16[2], oa->addr16[2], u),
		    ooa.addr16[3], oa->addr16[3], u),
		    ooa.addr16[4], oa->addr16[4], u),
		    ooa.addr16[5], oa->addr16[5], u),
		    ooa.addr16[6], oa->addr16[6], u),
		    ooa.addr16[7], oa->addr16[7], u);
		break;
#endif /* INET6 */
	}
}

void
pf_send_tcp(const struct pf_rule *r, sa_family_t af,
    const struct pf_addr *saddr, const struct pf_addr *daddr,
    u_int16_t sport, u_int16_t dport, u_int32_t seq, u_int32_t ack,
    u_int8_t flags, u_int16_t win, u_int16_t mss, u_int8_t ttl, int tag,
    struct ether_header *eh, struct ifnet *ifp)
{
	struct mbuf	*m;
	int		 len, tlen;
#ifdef INET
	struct ip	*h;
#endif /* INET */
#ifdef INET6
	struct ip6_hdr	*h6;
#endif /* INET6 */
	struct tcphdr	*th;
	char *opt;

	/* maximum segment size tcp option */
	tlen = sizeof(struct tcphdr);
	if (mss)
		tlen += 4;

	switch (af) {
#ifdef INET
	case AF_INET:
		len = sizeof(struct ip) + tlen;
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		len = sizeof(struct ip6_hdr) + tlen;
		break;
#endif /* INET6 */
	}

	/* create outgoing mbuf */
	m = m_gethdr(M_DONTWAIT, MT_HEADER);
	if (m == NULL)
		return;
	if (tag) {
		struct m_tag	*mtag;

		mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
		if (mtag == NULL) {
			m_freem(m);
			return;
		}
		m_tag_prepend(m, mtag);
	}
#ifdef ALTQ
	if (r != NULL && r->qid) {
		struct m_tag	*mtag;
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m, struct ip *);
			m_tag_prepend(m, mtag);
		}
	}
#endif /* ALTQ */
	m->m_data += max_linkhdr;
	m->m_pkthdr.len = m->m_len = len;
	m->m_pkthdr.rcvif = NULL;
	bzero(m->m_data, len);
	switch (af) {
#ifdef INET
	case AF_INET:
		h = mtod(m, struct ip *);

		/* IP header fields included in the TCP checksum */
		h->ip_p = IPPROTO_TCP;
		h->ip_len = htons(tlen);
		h->ip_src.s_addr = saddr->v4.s_addr;
		h->ip_dst.s_addr = daddr->v4.s_addr;

		th = (struct tcphdr *)((caddr_t)h + sizeof(struct ip));
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		h6 = mtod(m, struct ip6_hdr *);

		/* IP header fields included in the TCP checksum */
		h6->ip6_nxt = IPPROTO_TCP;
		h6->ip6_plen = htons(tlen);
		memcpy(&h6->ip6_src, &saddr->v6, sizeof(struct in6_addr));
		memcpy(&h6->ip6_dst, &daddr->v6, sizeof(struct in6_addr));

		th = (struct tcphdr *)((caddr_t)h6 + sizeof(struct ip6_hdr));
		break;
#endif /* INET6 */
	}

	/* TCP header */
	th->th_sport = sport;
	th->th_dport = dport;
	th->th_seq = htonl(seq);
	th->th_ack = htonl(ack);
	th->th_off = tlen >> 2;
	th->th_flags = flags;
	th->th_win = htons(win);

	if (mss) {
		opt = (char *)(th + 1);
		opt[0] = TCPOPT_MAXSEG;
		opt[1] = 4;
		HTONS(mss);
		bcopy((caddr_t)&mss, (caddr_t)(opt + 2), 2);
	}

	switch (af) {
#ifdef INET
	case AF_INET:
		/* TCP checksum */
		th->th_sum = in_cksum(m, len);

		/* Finish the IP header */
		h->ip_v = 4;
		h->ip_hl = sizeof(*h) >> 2;
		h->ip_tos = IPTOS_LOWDELAY;
		h->ip_len = htons(len);
		h->ip_off = htons(ip_mtudisc ? IP_DF : 0);
		h->ip_ttl = ttl ? ttl : ip_defttl;
		h->ip_sum = 0;
		if (eh == NULL) {
			ip_output(m, (void *)NULL, (void *)NULL, 0,
			    (void *)NULL, (void *)NULL);
		} else {
			struct route		 ro;
			struct rtentry		 rt;
			struct ether_header	*e = (void *)ro.ro_dst.sa_data;

			if (ifp == NULL) {
				m_freem(m);
				return;
			}
			rt.rt_ifp = ifp;
			ro.ro_rt = &rt;
			ro.ro_dst.sa_len = sizeof(ro.ro_dst);
			ro.ro_dst.sa_family = pseudo_AF_HDRCMPLT;
			bcopy(eh->ether_dhost, e->ether_shost, ETHER_ADDR_LEN);
			bcopy(eh->ether_shost, e->ether_dhost, ETHER_ADDR_LEN);
			e->ether_type = eh->ether_type;
			ip_output(m, (void *)NULL, &ro, IP_ROUTETOETHER,
			    (void *)NULL, (void *)NULL);
		}
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		/* TCP checksum */
		th->th_sum = in6_cksum(m, IPPROTO_TCP,
		    sizeof(struct ip6_hdr), tlen);

		h6->ip6_vfc |= IPV6_VERSION;
		h6->ip6_hlim = IPV6_DEFHLIM;

		ip6_output(m, NULL, NULL, 0, NULL, NULL);
		break;
#endif /* INET6 */
	}
}

void
pf_send_icmp(struct mbuf *m, u_int8_t type, u_int8_t code, sa_family_t af,
    struct pf_rule *r)
{
	struct m_tag	*mtag;
	struct mbuf	*m0;

	mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
	if (mtag == NULL)
		return;
	m0 = m_copy(m, 0, M_COPYALL);
	if (m0 == NULL) {
		m_tag_free(mtag);
		return;
	}
	m_tag_prepend(m0, mtag);

#ifdef ALTQ
	if (r->qid) {
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m0, struct ip *);
			m_tag_prepend(m0, mtag);
		}
	}
#endif /* ALTQ */

	switch (af) {
#ifdef INET
	case AF_INET:
		icmp_error(m0, type, code, 0, (void *)NULL);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		icmp6_error(m0, type, code, 0);
		break;
#endif /* INET6 */
	}
}

/*
 * Return 1 if the addresses a and b match (with mask m), otherwise return 0.
 * If n is 0, they match if they are equal. If n is != 0, they match if they
 * are different.
 */
int
pf_match_addr(u_int8_t n, struct pf_addr *a, struct pf_addr *m,
    struct pf_addr *b, sa_family_t af)
{
	int	match = 0;

	switch (af) {
#ifdef INET
	case AF_INET:
		if ((a->addr32[0] & m->addr32[0]) ==
		    (b->addr32[0] & m->addr32[0]))
			match++;
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (((a->addr32[0] & m->addr32[0]) ==
		     (b->addr32[0] & m->addr32[0])) &&
		    ((a->addr32[1] & m->addr32[1]) ==
		     (b->addr32[1] & m->addr32[1])) &&
		    ((a->addr32[2] & m->addr32[2]) ==
		     (b->addr32[2] & m->addr32[2])) &&
		    ((a->addr32[3] & m->addr32[3]) ==
		     (b->addr32[3] & m->addr32[3])))
			match++;
		break;
#endif /* INET6 */
	}
	if (match) {
		if (n)
			return (0);
		else
			return (1);
	} else {
		if (n)
			return (1);
		else
			return (0);
	}
}

int
pf_match(u_int8_t op, u_int32_t a1, u_int32_t a2, u_int32_t p)
{
	switch (op) {
	case PF_OP_IRG:
		return ((p > a1) && (p < a2));
	case PF_OP_XRG:
		return ((p < a1) || (p > a2));
	case PF_OP_RRG:
		return ((p >= a1) && (p <= a2));
	case PF_OP_EQ:
		return (p == a1);
	case PF_OP_NE:
		return (p != a1);
	case PF_OP_LT:
		return (p < a1);
	case PF_OP_LE:
		return (p <= a1);
	case PF_OP_GT:
		return (p > a1);
	case PF_OP_GE:
		return (p >= a1);
	}
	return (0); /* never reached */
}

int
pf_match_port(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
{
	NTOHS(a1);
	NTOHS(a2);
	NTOHS(p);
	return (pf_match(op, a1, a2, p));
}

int
pf_match_uid(u_int8_t op, uid_t a1, uid_t a2, uid_t u)
{
	if (u == UID_MAX && op != PF_OP_EQ && op != PF_OP_NE)
		return (0);
	return (pf_match(op, a1, a2, u));
}

int
pf_match_gid(u_int8_t op, gid_t a1, gid_t a2, gid_t g)
{
	if (g == GID_MAX && op != PF_OP_EQ && op != PF_OP_NE)
		return (0);
	return (pf_match(op, a1, a2, g));
}

struct pf_tag *
pf_get_tag(struct mbuf *m)
{
	struct m_tag	*mtag;

	if ((mtag = m_tag_find(m, PACKET_TAG_PF_TAG, NULL)) != NULL)
		return ((struct pf_tag *)(mtag + 1));
	else
		return (NULL);
}

int
pf_match_tag(struct mbuf *m, struct pf_rule *r, struct pf_rule *nat_rule,
    struct pf_tag **pftag, int *tag)
{
	if (*tag == -1) {	/* find mbuf tag */
		*pftag = pf_get_tag(m);
		if (*pftag != NULL)
			*tag = (*pftag)->tag;
		else
			*tag = 0;
		if (nat_rule != NULL && nat_rule->tag)
			*tag = nat_rule->tag;
	}

	return ((!r->match_tag_not && r->match_tag == *tag) ||
	    (r->match_tag_not && r->match_tag != *tag));
}

int
pf_tag_packet(struct mbuf *m, struct pf_tag *pftag, int tag)
{
	struct m_tag	*mtag;

	if (tag <= 0)
		return (0);

	if (pftag == NULL) {
		mtag = m_tag_get(PACKET_TAG_PF_TAG, sizeof(*pftag), M_NOWAIT);
		if (mtag == NULL)
			return (1);
		((struct pf_tag *)(mtag + 1))->tag = tag;
		m_tag_prepend(m, mtag);
	} else
		pftag->tag = tag;

	return (0);
}

#define PF_STEP_INTO_ANCHOR(r, a, s, n)					\
	do {								\
		if ((r) == NULL || (r)->anchor == NULL ||		\
		    (s) != NULL || (a) != NULL)				\
			panic("PF_STEP_INTO_ANCHOR");			\
		(a) = (r);						\
		(s) = TAILQ_FIRST(&(r)->anchor->rulesets);		\
		(r) = NULL;						\
		while ((s) != NULL && ((r) =				\
		    TAILQ_FIRST((s)->rules[n].active.ptr)) == NULL)	\
			(s) = TAILQ_NEXT((s), entries);			\
		if ((r) == NULL) {					\
			(r) = TAILQ_NEXT((a), entries);			\
			(a) = NULL;					\
		}							\
	} while (0)

#define PF_STEP_OUT_OF_ANCHOR(r, a, s, n)				\
	do {								\
		if ((r) != NULL || (a) == NULL || (s) == NULL)		\
			panic("PF_STEP_OUT_OF_ANCHOR");			\
		(s) = TAILQ_NEXT((s), entries);				\
		while ((s) != NULL && ((r) =				\
		    TAILQ_FIRST((s)->rules[n].active.ptr)) == NULL)	\
			(s) = TAILQ_NEXT((s), entries);			\
		if ((r) == NULL) {					\
			(r) = TAILQ_NEXT((a), entries);			\
			(a) = NULL;					\
		}							\
	} while (0)

#ifdef INET6
void
pf_poolmask(struct pf_addr *naddr, struct pf_addr *raddr,
    struct pf_addr *rmask, struct pf_addr *saddr, sa_family_t af)
{
	switch (af) {
#ifdef INET
	case AF_INET:
		naddr->addr32[0] = (raddr->addr32[0] & rmask->addr32[0]) |
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]);
		break;
#endif /* INET */
	case AF_INET6:
		naddr->addr32[0] = (raddr->addr32[0] & rmask->addr32[0]) |
		((rmask->addr32[0] ^ 0xffffffff ) & saddr->addr32[0]);
		naddr->addr32[1] = (raddr->addr32[1] & rmask->addr32[1]) |
		((rmask->addr32[1] ^ 0xffffffff ) & saddr->addr32[1]);
		naddr->addr32[2] = (raddr->addr32[2] & rmask->addr32[2]) |
		((rmask->addr32[2] ^ 0xffffffff ) & saddr->addr32[2]);
		naddr->addr32[3] = (raddr->addr32[3] & rmask->addr32[3]) |
		((rmask->addr32[3] ^ 0xffffffff ) & saddr->addr32[3]);
		break;
	}
}

void
pf_addr_inc(struct pf_addr *addr, sa_family_t af)
{
	switch (af) {
#ifdef INET
	case AF_INET:
		addr->addr32[0] = htonl(ntohl(addr->addr32[0]) + 1);
		break;
#endif /* INET */
	case AF_INET6:
		if (addr->addr32[3] == 0xffffffff) {
			addr->addr32[3] = 0;
			if (addr->addr32[2] == 0xffffffff) {
				addr->addr32[2] = 0;
				if (addr->addr32[1] == 0xffffffff) {
					addr->addr32[1] = 0;
					addr->addr32[0] =
					    htonl(ntohl(addr->addr32[0]) + 1);
				} else
					addr->addr32[1] =
					    htonl(ntohl(addr->addr32[1]) + 1);
			} else
				addr->addr32[2] =
				    htonl(ntohl(addr->addr32[2]) + 1);
		} else
			addr->addr32[3] =
			    htonl(ntohl(addr->addr32[3]) + 1);
		break;
	}
}
#endif /* INET6 */

#define mix(a,b,c) \
	do {					\
		a -= b; a -= c; a ^= (c >> 13);	\
		b -= c; b -= a; b ^= (a << 8);	\
		c -= a; c -= b; c ^= (b >> 13);	\
		a -= b; a -= c; a ^= (c >> 12);	\
		b -= c; b -= a; b ^= (a << 16);	\
		c -= a; c -= b; c ^= (b >> 5);	\
		a -= b; a -= c; a ^= (c >> 3);	\
		b -= c; b -= a; b ^= (a << 10);	\
		c -= a; c -= b; c ^= (b >> 15);	\
	} while (0)

/*
 * hash function based on bridge_hash in if_bridge.c
 */
void
pf_hash(struct pf_addr *inaddr, struct pf_addr *hash,
    struct pf_poolhashkey *key, sa_family_t af)
{
	u_int32_t	a = 0x9e3779b9, b = 0x9e3779b9, c = key->key32[0];

	switch (af) {
#ifdef INET
	case AF_INET:
		a += inaddr->addr32[0];
		b += key->key32[1];
		mix(a, b, c);
		hash->addr32[0] = c + key->key32[2];
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		a += inaddr->addr32[0];
		b += inaddr->addr32[2];
		mix(a, b, c);
		hash->addr32[0] = c;
		a += inaddr->addr32[1];
		b += inaddr->addr32[3];
		c += key->key32[1];
		mix(a, b, c);
		hash->addr32[1] = c;
		a += inaddr->addr32[2];
		b += inaddr->addr32[1];
		c += key->key32[2];
		mix(a, b, c);
		hash->addr32[2] = c;
		a += inaddr->addr32[3];
		b += inaddr->addr32[0];
		c += key->key32[3];
		mix(a, b, c);
		hash->addr32[3] = c;
		break;
#endif /* INET6 */
	}
}

int
pf_map_addr(sa_family_t af, struct pf_rule *r, struct pf_addr *saddr,
    struct pf_addr *naddr, struct pf_addr *init_addr, struct pf_src_node **sn)
{
	unsigned char		 hash[16];
	struct pf_pool		*rpool = &r->rpool;
	struct pf_addr		*raddr = &rpool->cur->addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.v.a.mask;
	struct pf_pooladdr	*acur = rpool->cur;
	struct pf_src_node	 k;

	if (*sn == NULL && r->rpool.opts & PF_POOL_STICKYADDR &&
	    (r->rpool.opts & PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		k.af = af;
		PF_ACPY(&k.addr, saddr, af);
		if (r->rule_flag & PFRULE_RULESRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR)
			k.rule.ptr = r;
		else
			k.rule.ptr = NULL;
		pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
		*sn = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
		if (*sn != NULL && !PF_AZERO(&(*sn)->raddr, af)) {
			PF_ACPY(naddr, &(*sn)->raddr, af);
			if (pf_status.debug >= PF_DEBUG_MISC) {
				printf("pf_map_addr: src tracking maps ");
				pf_print_host(&k.addr, 0, af);
				printf(" to ");
				pf_print_host(naddr, 0, af);
				printf("\n");
			}
			return (0);
		}
	}

	if (rpool->cur->addr.type == PF_ADDR_NOROUTE)
		return (1);
	if (rpool->cur->addr.type == PF_ADDR_TABLE) {
		if ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN)
			return (1); /* unsupported */
	} else {
		raddr = &rpool->cur->addr.v.a.addr;
		rmask = &rpool->cur->addr.v.a.mask;
	}

	switch (rpool->opts & PF_POOL_TYPEMASK) {
	case PF_POOL_NONE:
		PF_ACPY(naddr, raddr, af);
		break;
	case PF_POOL_BITMASK:
		PF_POOLMASK(naddr, raddr, rmask, saddr, af);
		break;
	case PF_POOL_RANDOM:
		if (init_addr != NULL && PF_AZERO(init_addr, af)) {
			switch (af) {
#ifdef INET
			case AF_INET:
				rpool->counter.addr32[0] = htonl(arc4random());
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				if (rmask->addr32[3] != 0xffffffff)
					rpool->counter.addr32[3] =
					    htonl(arc4random());
				else
					break;
				if (rmask->addr32[2] != 0xffffffff)
					rpool->counter.addr32[2] =
					    htonl(arc4random());
				else
					break;
				if (rmask->addr32[1] != 0xffffffff)
					rpool->counter.addr32[1] =
					    htonl(arc4random());
				else
					break;
				if (rmask->addr32[0] != 0xffffffff)
					rpool->counter.addr32[0] =
					    htonl(arc4random());
				break;
#endif /* INET6 */
			}
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af);
			PF_ACPY(init_addr, naddr, af);

		} else {
			PF_AINC(&rpool->counter, af);
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af);
		}
		break;
	case PF_POOL_SRCHASH:
		pf_hash(saddr, (struct pf_addr *)&hash, &rpool->key, af);
		PF_POOLMASK(naddr, raddr, rmask, (struct pf_addr *)&hash, af);
		break;
	case PF_POOL_ROUNDROBIN:
		if (rpool->cur->addr.type == PF_ADDR_TABLE) {
			if (!pfr_pool_get(rpool->cur->addr.p.tbl,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af))
				goto get_addr;
		} else if (pf_match_addr(0, raddr, rmask, &rpool->counter, af))
			goto get_addr;

	try_next:
		if ((rpool->cur = TAILQ_NEXT(rpool->cur, entries)) == NULL)
			rpool->cur = TAILQ_FIRST(&rpool->list);
		if (rpool->cur->addr.type == PF_ADDR_TABLE) {
			rpool->tblidx = -1;
			if (pfr_pool_get(rpool->cur->addr.p.tbl,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af)) {
				/* table contains no address of type 'af' */
				if (rpool->cur != acur)
					goto try_next;
				return (1);
			}
		} else {
			raddr = &rpool->cur->addr.v.a.addr;
			rmask = &rpool->cur->addr.v.a.mask;
			PF_ACPY(&rpool->counter, raddr, af);
		}

	get_addr:
		PF_ACPY(naddr, &rpool->counter, af);
		PF_AINC(&rpool->counter, af);
		break;
	}
	if (*sn != NULL)
		PF_ACPY(&(*sn)->raddr, naddr, af);

	if (pf_status.debug >= PF_DEBUG_MISC &&
	    (rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		printf("pf_map_addr: selected address ");
		pf_print_host(naddr, 0, af);
		printf("\n");
	}

	return (0);
}

int
pf_get_sport(sa_family_t af, u_int8_t proto, struct pf_rule *r,
    struct pf_addr *saddr, struct pf_addr *daddr, u_int16_t dport,
    struct pf_addr *naddr, u_int16_t *nport, u_int16_t low, u_int16_t high,
    struct pf_src_node **sn)
{
	struct pf_state		key;
	struct pf_addr		init_addr;
	u_int16_t		cut;

	bzero(&init_addr, sizeof(init_addr));
	if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn))
		return (1);

	do {
		key.af = af;
		key.proto = proto;
		PF_ACPY(&key.ext.addr, daddr, key.af);
		PF_ACPY(&key.gwy.addr, naddr, key.af);
		key.ext.port = dport;

		/*
		 * port search; start random, step;
		 * similar 2 portloop in in_pcbbind
		 */
		if (!(proto == IPPROTO_TCP || proto == IPPROTO_UDP)) {
			key.gwy.port = 0;
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL)
				return (0);
		} else if (low == 0 && high == 0) {
			key.gwy.port = *nport;
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL)
				return (0);
		} else if (low == high) {
			key.gwy.port = htons(low);
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL) {
				*nport = htons(low);
				return (0);
			}
		} else {
			u_int16_t tmp;

			if (low > high) {
				tmp = low;
				low = high;
				high = tmp;
			}
			/* low < high */
			cut = htonl(arc4random()) % (1 + high - low) + low;
			/* low <= cut <= high */
			for (tmp = cut; tmp <= high; ++(tmp)) {
				key.gwy.port = htons(tmp);
				if (pf_find_state_all(&key, PF_EXT_GWY, NULL) ==
				    NULL) {
					*nport = htons(tmp);
					return (0);
				}
			}
			for (tmp = cut - 1; tmp >= low; --(tmp)) {
				key.gwy.port = htons(tmp);
				if (pf_find_state_all(&key, PF_EXT_GWY, NULL) ==
				    NULL) {
					*nport = htons(tmp);
					return (0);
				}
			}
		}

		switch (r->rpool.opts & PF_POOL_TYPEMASK) {
		case PF_POOL_RANDOM:
		case PF_POOL_ROUNDROBIN:
			if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn))
				return (1);
			break;
		case PF_POOL_NONE:
		case PF_POOL_SRCHASH:
		case PF_POOL_BITMASK:
		default:
			return (1);
		}
	} while (! PF_AEQ(&init_addr, naddr, af) );

	return (1);					/* none available */
}

struct pf_rule *
pf_match_translation(struct pf_pdesc *pd, struct mbuf *m, int off,
    int direction, struct pfi_kif *kif, struct pf_addr *saddr, u_int16_t sport,
    struct pf_addr *daddr, u_int16_t dport, int rs_num)
{
	struct pf_rule		*r, *rm = NULL, *anchorrule = NULL;
	struct pf_ruleset	*ruleset = NULL;

	r = TAILQ_FIRST(pf_main_ruleset.rules[rs_num].active.ptr);
	while (r && rm == NULL) {
		struct pf_rule_addr	*src = NULL, *dst = NULL;
		struct pf_addr_wrap	*xdst = NULL;

		if (r->action == PF_BINAT && direction == PF_IN) {
			src = &r->dst;
			if (r->rpool.cur != NULL)
				xdst = &r->rpool.cur->addr;
		} else {
			src = &r->src;
			dst = &r->dst;
		}

		r->evaluations++;
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != pd->af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&src->addr, saddr, pd->af, src->not))
			r = r->skip[src == &r->src ? PF_SKIP_SRC_ADDR :
			    PF_SKIP_DST_ADDR].ptr;
		else if (src->port_op && !pf_match_port(src->port_op,
		    src->port[0], src->port[1], sport))
			r = r->skip[src == &r->src ? PF_SKIP_SRC_PORT :
			    PF_SKIP_DST_PORT].ptr;
		else if (dst != NULL &&
		    PF_MISMATCHAW(&dst->addr, daddr, pd->af, dst->not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (xdst != NULL && PF_MISMATCHAW(xdst, daddr, pd->af, 0))
			r = TAILQ_NEXT(r, entries);
		else if (dst != NULL && dst->port_op &&
		    !pf_match_port(dst->port_op, dst->port[0],
		    dst->port[1], dport))
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		else if (r->os_fingerprint != PF_OSFP_ANY && (pd->proto !=
		    IPPROTO_TCP || !pf_osfp_match(pf_osfp_fingerprint(pd, m,
		    off, pd->hdr.tcp), r->os_fingerprint)))
			r = TAILQ_NEXT(r, entries);
		else if (r->anchor == NULL)
				rm = r;
		else
			PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset, rs_num);
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
			    rs_num);
	}
	if (rm != NULL && (rm->action == PF_NONAT ||
	    rm->action == PF_NORDR || rm->action == PF_NOBINAT))
		return (NULL);
	return (rm);
}

struct pf_rule *
pf_get_translation(struct pf_pdesc *pd, struct mbuf *m, int off, int direction,
    struct pfi_kif *kif, struct pf_src_node **sn,
    struct pf_addr *saddr, u_int16_t sport,
    struct pf_addr *daddr, u_int16_t dport,
    struct pf_addr *naddr, u_int16_t *nport)
{
	struct pf_rule	*r = NULL;

	if (direction == PF_OUT) {
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
		    sport, daddr, dport, PF_RULESET_BINAT);
		if (r == NULL)
			r = pf_match_translation(pd, m, off, direction, kif,
			    saddr, sport, daddr, dport, PF_RULESET_NAT);
	} else {
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
		    sport, daddr, dport, PF_RULESET_RDR);
		if (r == NULL)
			r = pf_match_translation(pd, m, off, direction, kif,
			    saddr, sport, daddr, dport, PF_RULESET_BINAT);
	}

	if (r != NULL) {
		switch (r->action) {
		case PF_NONAT:
		case PF_NOBINAT:
		case PF_NORDR:
			return (NULL);
		case PF_NAT:
			if (pf_get_sport(pd->af, pd->proto, r, saddr,
			    daddr, dport, naddr, nport, r->rpool.proxy_port[0],
			    r->rpool.proxy_port[1], sn)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: NAT proxy port allocation "
				    "(%u-%u) failed\n",
				    r->rpool.proxy_port[0],
				    r->rpool.proxy_port[1]));
				return (NULL);
			}
			break;
		case PF_BINAT:
			switch (direction) {
			case PF_OUT:
					PF_POOLMASK(naddr,
					    &r->rpool.cur->addr.v.a.addr,
					    &r->rpool.cur->addr.v.a.mask,
					    saddr, pd->af);
				break;
			case PF_IN:
					PF_POOLMASK(naddr,
					    &r->src.addr.v.a.addr,
					    &r->src.addr.v.a.mask, daddr,
					    pd->af);
				break;
			}
			break;
		case PF_RDR: {
			if (pf_map_addr(r->af, r, saddr, naddr, NULL, sn))
				return (NULL);

			if (r->rpool.proxy_port[1]) {
				u_int32_t	tmp_nport;

				tmp_nport = ((ntohs(dport) -
				    ntohs(r->dst.port[0])) %
				    (r->rpool.proxy_port[1] -
				    r->rpool.proxy_port[0] + 1)) +
				    r->rpool.proxy_port[0];

				/* wrap around if necessary */
				if (tmp_nport > 65535)
					tmp_nport -= 65535;
				*nport = htons((u_int16_t)tmp_nport);
			} else if (r->rpool.proxy_port[0])
				*nport = htons(r->rpool.proxy_port[0]);
			break;
		}
		default:
			return (NULL);
		}
	}

	return (r);
}

int
pf_socket_lookup(uid_t *uid, gid_t *gid, int direction, struct pf_pdesc *pd)
{
	struct pf_addr		*saddr, *daddr;
	u_int16_t		 sport, dport;
	struct inpcbtable	*tb;
	struct inpcb		*inp;

	*uid = UID_MAX;
	*gid = GID_MAX;
	switch (pd->proto) {
	case IPPROTO_TCP:
		sport = pd->hdr.tcp->th_sport;
		dport = pd->hdr.tcp->th_dport;
		tb = &tcbtable;
		break;
	case IPPROTO_UDP:
		sport = pd->hdr.udp->uh_sport;
		dport = pd->hdr.udp->uh_dport;
		tb = &udbtable;
		break;
	default:
		return (0);
	}
	if (direction == PF_IN) {
		saddr = pd->src;
		daddr = pd->dst;
	} else {
		u_int16_t	p;

		p = sport;
		sport = dport;
		dport = p;
		saddr = pd->dst;
		daddr = pd->src;
	}
	switch (pd->af) {
#ifdef INET
	case AF_INET:
		inp = in_pcbhashlookup(tb, saddr->v4, sport, daddr->v4, dport);
		if (inp == NULL) {
			inp = in_pcblookup_listen(tb, daddr->v4, dport, 0);
			if (inp == NULL)
				return (0);
		}
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		inp = in6_pcbhashlookup(tb, &saddr->v6, sport, &daddr->v6,
		    dport);
		if (inp == NULL) {
			inp = in6_pcblookup_listen(tb, &daddr->v6, dport, 0);
			if (inp == NULL)
				return (0);
		}
		break;
#endif /* INET6 */

	default:
		return (0);
	}
	*uid = inp->inp_socket->so_euid;
	*gid = inp->inp_socket->so_egid;
	return (1);
}

u_int8_t
pf_get_wscale(struct mbuf *m, int off, u_int16_t th_off, sa_family_t af)
{
	int		 hlen;
	u_int8_t	 hdr[60];
	u_int8_t	*opt, optlen;
	u_int8_t	 wscale = 0;

	hlen = th_off << 2;		/* hlen <= sizeof(hdr) */
	if (hlen <= sizeof(struct tcphdr))
		return (0);
	if (!pf_pull_hdr(m, off, hdr, hlen, NULL, NULL, af))
		return (0);
	opt = hdr + sizeof(struct tcphdr);
	hlen -= sizeof(struct tcphdr);
	while (hlen >= 3) {
		switch (*opt) {
		case TCPOPT_EOL:
		case TCPOPT_NOP:
			++opt;
			--hlen;
			break;
		case TCPOPT_WINDOW:
			wscale = opt[2];
			if (wscale > TCP_MAX_WINSHIFT)
				wscale = TCP_MAX_WINSHIFT;
			wscale |= PF_WSCALE_FLAG;
			/* FALLTHROUGH */
		default:
			optlen = opt[1];
			if (optlen < 2)
				optlen = 2;
			hlen -= optlen;
			opt += optlen;
			break;
		}
	}
	return (wscale);
}

u_int16_t
pf_get_mss(struct mbuf *m, int off, u_int16_t th_off, sa_family_t af)
{
	int		 hlen;
	u_int8_t	 hdr[60];
	u_int8_t	*opt, optlen;
	u_int16_t	 mss = tcp_mssdflt;

	hlen = th_off << 2;	/* hlen <= sizeof(hdr) */
	if (hlen <= sizeof(struct tcphdr))
		return (0);
	if (!pf_pull_hdr(m, off, hdr, hlen, NULL, NULL, af))
		return (0);
	opt = hdr + sizeof(struct tcphdr);
	hlen -= sizeof(struct tcphdr);
	while (hlen >= TCPOLEN_MAXSEG) {
		switch (*opt) {
		case TCPOPT_EOL:
		case TCPOPT_NOP:
			++opt;
			--hlen;
			break;
		case TCPOPT_MAXSEG:
			bcopy((caddr_t)(opt + 2), (caddr_t)&mss, 2);
			/* FALLTHROUGH */
		default:
			optlen = opt[1];
			if (optlen < 2)
				optlen = 2;
			hlen -= optlen;
			opt += optlen;
			break;
		}
	}
	return (mss);
}

u_int16_t
pf_calc_mss(struct pf_addr *addr, sa_family_t af, u_int16_t offer)
{
#ifdef INET
	struct sockaddr_in	*dst;
	struct route		 ro;
#endif /* INET */
#ifdef INET6
	struct sockaddr_in6	*dst6;
	struct route_in6	 ro6;
#endif /* INET6 */
	struct rtentry		*rt = NULL;
	int			 hlen;
	u_int16_t		 mss = tcp_mssdflt;

	switch (af) {
#ifdef INET
	case AF_INET:
		hlen = sizeof(struct ip);
		bzero(&ro, sizeof(ro));
		dst = (struct sockaddr_in *)&ro.ro_dst;
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = addr->v4;
		rtalloc_noclone(&ro, NO_CLONING);
		rt = ro.ro_rt;
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		hlen = sizeof(struct ip6_hdr);
		bzero(&ro6, sizeof(ro6));
		dst6 = (struct sockaddr_in6 *)&ro6.ro_dst;
		dst6->sin6_family = AF_INET6;
		dst6->sin6_len = sizeof(*dst6);
		dst6->sin6_addr = addr->v6;
		rtalloc_noclone((struct route *)&ro6, NO_CLONING);
		rt = ro6.ro_rt;
		break;
#endif /* INET6 */
	}

	if (rt && rt->rt_ifp) {
		mss = rt->rt_ifp->if_mtu - hlen - sizeof(struct tcphdr);
		mss = max(tcp_mssdflt, mss);
		RTFREE(rt);
	}
	mss = min(mss, offer);
	mss = max(mss, 64);		/* sanity - at least max opt space */
	return (mss);
}

void
pf_set_rt_ifp(struct pf_state *s, struct pf_addr *saddr)
{
	struct pf_rule *r = s->rule.ptr;

	s->rt_kif = NULL;
	if (!r->rt || r->rt == PF_FASTROUTE)
		return;
	switch (s->af) {
#ifdef INET
	case AF_INET:
		pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL,
		    &s->nat_src_node);
		s->rt_kif = r->rpool.cur->kif;
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		pf_map_addr(AF_INET6, r, saddr, &s->rt_addr, NULL,
		    &s->nat_src_node);
		s->rt_kif = r->rpool.cur->kif;
		break;
#endif /* INET6 */
	}
}

int
pf_test_tcp(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    struct ifqueue *ifq)
{
	struct pf_rule		*nr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct tcphdr		*th = pd->hdr.tcp;
	u_int16_t		 bport, nport = 0;
	sa_family_t		 af = pd->af;
	int			 lookup = -1;
	uid_t			 uid;
	gid_t			 gid;
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_src_node	*nsn = NULL;
	u_short			 reason;
	int			 rewrite = 0;
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
	u_int16_t		 mss = tcp_mssdflt;

	if (pf_check_congestion(ifq))
		return (PF_DROP);

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

	if (direction == PF_OUT) {
		bport = nport = th->th_sport;
		/* check outgoing packet for BINAT/NAT */
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
		    saddr, th->th_sport, daddr, th->th_dport,
		    &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &pd->naddr, nport, 0, af);
			rewrite++;
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	} else {
		bport = nport = th->th_dport;
		/* check incoming packet for BINAT/RDR */
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
		    saddr, th->th_sport, daddr, th->th_dport,
		    &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &pd->naddr, nport, 0, af);
			rewrite++;
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	}

	while (r != NULL) {
		r->evaluations++;
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != IPPROTO_TCP)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (r->src.port_op && !pf_match_port(r->src.port_op,
		    r->src.port[0], r->src.port[1], th->th_sport))
			r = r->skip[PF_SKIP_SRC_PORT].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
		    r->dst.port[0], r->dst.port[1], th->th_dport))
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		else if ((r->flagset & th->th_flags) != r->flags)
			r = TAILQ_NEXT(r, entries);
		else if (r->uid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
		    !pf_match_uid(r->uid.op, r->uid.uid[0], r->uid.uid[1],
		    uid))
			r = TAILQ_NEXT(r, entries);
		else if (r->gid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
		    !pf_match_gid(r->gid.op, r->gid.gid[0], r->gid.gid[1],
		    gid))
			r = TAILQ_NEXT(r, entries);
		else if (r->prob && r->prob <= arc4random())
			r = TAILQ_NEXT(r, entries);
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
			r = TAILQ_NEXT(r, entries);
		else if (r->os_fingerprint != PF_OSFP_ANY && !pf_osfp_match(
		    pf_osfp_fingerprint(pd, m, off, th), r->os_fingerprint))
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->tag)
				tag = r->tag;
			if (r->anchor == NULL) {
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
		}
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	REASON_SET(&reason, PFRES_MATCH);

	if (r->log) {
		if (rewrite)
			m_copyback(m, off, sizeof(*th), th);
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
	}

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNRST) ||
	    (r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		/* undo NAT changes, if they have taken place */
		if (nr != NULL) {
			if (direction == PF_OUT) {
				pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
				    &th->th_sum, &pd->baddr, bport, 0, af);
				rewrite++;
			} else {
				pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
				    &th->th_sum, &pd->baddr, bport, 0, af);
				rewrite++;
			}
		}
		if (((r->rule_flag & PFRULE_RETURNRST) ||
		    (r->rule_flag & PFRULE_RETURN)) &&
		    !(th->th_flags & TH_RST)) {
			u_int32_t ack = ntohl(th->th_seq) + pd->p_len;

			if (th->th_flags & TH_SYN)
				ack++;
			if (th->th_flags & TH_FIN)
				ack++;
			pf_send_tcp(r, af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    ntohl(th->th_ack), ack, TH_RST|TH_ACK, 0, 0,
			    r->return_ttl, 1, pd->eh, kif->pfik_ifp);
		} else if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
	}

	if (r->action == PF_DROP)
		return (PF_DROP);

	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

	if (r->keep_state || nr != NULL ||
	    (pd->flags & PFDESC_TCP_NORM)) {
		/* create new state */
		u_int16_t	 len;
		struct pf_state	*s = NULL;
		struct pf_src_node *sn = NULL;

		len = pd->tot_len - off - (th->th_off << 2);

		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL) {
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
			REASON_SET(&reason, PFRES_MEMORY);
			return (PF_DROP);
		}
		bzero(s, sizeof(*s));
		r->states++;
		if (a != NULL)
			a->states++;
		s->rule.ptr = r;
		s->nat_rule.ptr = nr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
		s->proto = IPPROTO_TCP;
		s->direction = direction;
		s->af = af;
		if (direction == PF_OUT) {
			PF_ACPY(&s->gwy.addr, saddr, af);
			s->gwy.port = th->th_sport;		/* sport */
			PF_ACPY(&s->ext.addr, daddr, af);
			s->ext.port = th->th_dport;
			if (nr != NULL) {
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
				s->lan.port = bport;
			} else {
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
				s->lan.port = s->gwy.port;
			}
		} else {
			PF_ACPY(&s->lan.addr, daddr, af);
			s->lan.port = th->th_dport;
			PF_ACPY(&s->ext.addr, saddr, af);
			s->ext.port = th->th_sport;
			if (nr != NULL) {
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
				s->gwy.port = bport;
			} else {
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
				s->gwy.port = s->lan.port;
			}
		}

		s->src.seqlo = ntohl(th->th_seq);
		s->src.seqhi = s->src.seqlo + len + 1;
		if ((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
		    r->keep_state == PF_STATE_MODULATE) {
			/* Generate sequence number modulator */
			while ((s->src.seqdiff = htonl(arc4random())) == 0)
				;
			pf_change_a(&th->th_seq, &th->th_sum,
			    htonl(s->src.seqlo + s->src.seqdiff), 0);
			rewrite = 1;
		} else
			s->src.seqdiff = 0;
		if (th->th_flags & TH_SYN) {
			s->src.seqhi++;
			s->src.wscale = pf_get_wscale(m, off, th->th_off, af);
		}
		s->src.max_win = MAX(ntohs(th->th_win), 1);
		if (s->src.wscale & PF_WSCALE_MASK) {
			/* Remove scale factor from initial window */
			int win = s->src.max_win;
			win += 1 << (s->src.wscale & PF_WSCALE_MASK);
			s->src.max_win = (win - 1) >>
			    (s->src.wscale & PF_WSCALE_MASK);
		}
		if (th->th_flags & TH_FIN)
			s->src.seqhi++;
		s->dst.seqhi = 1;
		s->dst.max_win = 1;
		s->src.state = TCPS_SYN_SENT;
		s->dst.state = TCPS_CLOSED;
		s->creation = time.tv_sec;
		s->expire = time.tv_sec;
		s->timeout = PFTM_TCP_FIRST_PACKET;
		pf_set_rt_ifp(s, saddr);
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
		if ((pd->flags & PFDESC_TCP_NORM) && pf_normalize_tcp_init(m,
		    off, pd, th, &s->src, &s->dst)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pf_src_tree_remove_state(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
		if ((pd->flags & PFDESC_TCP_NORM) && s->src.scrub &&
		    pf_normalize_tcp_stateful(m, off, pd, &reason, th, s,
		    &s->src, &s->dst, &rewrite)) {
			/* This really shouldn't happen!!! */
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf_normalize_tcp_stateful failed on first pkt"));
			pf_normalize_tcp_cleanup(s);
			pf_src_tree_remove_state(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
			pf_normalize_tcp_cleanup(s);
			REASON_SET(&reason, PFRES_MEMORY);
			pf_src_tree_remove_state(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		} else
			*sm = s;
		if ((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
		    r->keep_state == PF_STATE_SYNPROXY) {
			s->src.state = PF_TCPS_PROXY_SRC;
			if (nr != NULL) {
				if (direction == PF_OUT) {
					pf_change_ap(saddr, &th->th_sport,
					    pd->ip_sum, &th->th_sum, &pd->baddr,
					    bport, 0, af);
				} else {
					pf_change_ap(daddr, &th->th_dport,
					    pd->ip_sum, &th->th_sum, &pd->baddr,
					    bport, 0, af);
				}
			}
			s->src.seqhi = htonl(arc4random());
			/* Find mss option */
			mss = pf_get_mss(m, off, th->th_off, af);
			mss = pf_calc_mss(saddr, af, mss);
			mss = pf_calc_mss(daddr, af, mss);
			s->src.mss = mss;
			pf_send_tcp(r, af, daddr, saddr, th->th_dport,
			    th->th_sport, s->src.seqhi, ntohl(th->th_seq) + 1,
			    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, NULL, NULL);
			return (PF_SYNPROXY_DROP);
		}
	}

	/* copy back packet headers if we performed NAT operations */
	if (rewrite)
		m_copyback(m, off, sizeof(*th), th);

	return (PF_PASS);
}

int
pf_test_udp(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    struct ifqueue *ifq)
{
	struct pf_rule		*nr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct udphdr		*uh = pd->hdr.udp;
	u_int16_t		 bport, nport = 0;
	sa_family_t		 af = pd->af;
	int			 lookup = -1;
	uid_t			 uid;
	gid_t			 gid;
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_src_node	*nsn = NULL;
	u_short			 reason;
	int			 rewrite = 0;
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;

	if (pf_check_congestion(ifq))
		return (PF_DROP);

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

	if (direction == PF_OUT) {
		bport = nport = uh->uh_sport;
		/* check outgoing packet for BINAT/NAT */
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
		    saddr, uh->uh_sport, daddr, uh->uh_dport,
		    &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &pd->naddr, nport, 1, af);
			rewrite++;
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	} else {
		bport = nport = uh->uh_dport;
		/* check incoming packet for BINAT/RDR */
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
		    saddr, uh->uh_sport, daddr, uh->uh_dport, &pd->naddr,
		    &nport)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &pd->naddr, nport, 1, af);
			rewrite++;
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	}

	while (r != NULL) {
		r->evaluations++;
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != IPPROTO_UDP)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (r->src.port_op && !pf_match_port(r->src.port_op,
		    r->src.port[0], r->src.port[1], uh->uh_sport))
			r = r->skip[PF_SKIP_SRC_PORT].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
		    r->dst.port[0], r->dst.port[1], uh->uh_dport))
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		else if (r->uid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
		    !pf_match_uid(r->uid.op, r->uid.uid[0], r->uid.uid[1],
		    uid))
			r = TAILQ_NEXT(r, entries);
		else if (r->gid.op && (lookup != -1 || (lookup =
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
		    !pf_match_gid(r->gid.op, r->gid.gid[0], r->gid.gid[1],
		    gid))
			r = TAILQ_NEXT(r, entries);
		else if (r->prob && r->prob <= arc4random())
			r = TAILQ_NEXT(r, entries);
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
			r = TAILQ_NEXT(r, entries);
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->tag)
				tag = r->tag;
			if (r->anchor == NULL) {
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
		}
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	REASON_SET(&reason, PFRES_MATCH);

	if (r->log) {
		if (rewrite)
			m_copyback(m, off, sizeof(*uh), uh);
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
	}

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		/* undo NAT changes, if they have taken place */
		if (nr != NULL) {
			if (direction == PF_OUT) {
				pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
				    &uh->uh_sum, &pd->baddr, bport, 1, af);
				rewrite++;
			} else {
				pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
				    &uh->uh_sum, &pd->baddr, bport, 1, af);
				rewrite++;
			}
		}
		if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
	}

	if (r->action == PF_DROP)
		return (PF_DROP);

	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

	if (r->keep_state || nr != NULL) {
		/* create new state */
		struct pf_state	*s = NULL;
		struct pf_src_node *sn = NULL;

		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL) {
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
			REASON_SET(&reason, PFRES_MEMORY);
			return (PF_DROP);
		}
		bzero(s, sizeof(*s));
		r->states++;
		if (a != NULL)
			a->states++;
		s->rule.ptr = r;
		s->nat_rule.ptr = nr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
		s->proto = IPPROTO_UDP;
		s->direction = direction;
		s->af = af;
		if (direction == PF_OUT) {
			PF_ACPY(&s->gwy.addr, saddr, af);
			s->gwy.port = uh->uh_sport;
			PF_ACPY(&s->ext.addr, daddr, af);
			s->ext.port = uh->uh_dport;
			if (nr != NULL) {
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
				s->lan.port = bport;
			} else {
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
				s->lan.port = s->gwy.port;
			}
		} else {
			PF_ACPY(&s->lan.addr, daddr, af);
			s->lan.port = uh->uh_dport;
			PF_ACPY(&s->ext.addr, saddr, af);
			s->ext.port = uh->uh_sport;
			if (nr != NULL) {
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
				s->gwy.port = bport;
			} else {
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
				s->gwy.port = s->lan.port;
			}
		}
		s->src.state = PFUDPS_SINGLE;
		s->dst.state = PFUDPS_NO_TRAFFIC;
		s->creation = time.tv_sec;
		s->expire = time.tv_sec;
		s->timeout = PFTM_UDP_FIRST_PACKET;
		pf_set_rt_ifp(s, saddr);
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pf_src_tree_remove_state(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		} else
			*sm = s;
	}

	/* copy back packet headers if we performed NAT operations */
	if (rewrite)
		m_copyback(m, off, sizeof(*uh), uh);

	return (PF_PASS);
}

int
pf_test_icmp(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    struct ifqueue *ifq)
{
	struct pf_rule		*nr = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_src_node	*nsn = NULL;
	u_short			 reason;
	u_int16_t		 icmpid;
	sa_family_t		 af = pd->af;
	u_int8_t		 icmptype, icmpcode;
	int			 state_icmp = 0;
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
#ifdef INET6
	int			 rewrite = 0;
#endif /* INET6 */

	if (pf_check_congestion(ifq))
		return (PF_DROP);

	switch (pd->proto) {
#ifdef INET
	case IPPROTO_ICMP:
		icmptype = pd->hdr.icmp->icmp_type;
		icmpcode = pd->hdr.icmp->icmp_code;
		icmpid = pd->hdr.icmp->icmp_id;

		if (icmptype == ICMP_UNREACH ||
		    icmptype == ICMP_SOURCEQUENCH ||
		    icmptype == ICMP_REDIRECT ||
		    icmptype == ICMP_TIMXCEED ||
		    icmptype == ICMP_PARAMPROB)
			state_icmp++;
		break;
#endif /* INET */
#ifdef INET6
	case IPPROTO_ICMPV6:
		icmptype = pd->hdr.icmp6->icmp6_type;
		icmpcode = pd->hdr.icmp6->icmp6_code;
		icmpid = pd->hdr.icmp6->icmp6_id;

		if (icmptype == ICMP6_DST_UNREACH ||
		    icmptype == ICMP6_PACKET_TOO_BIG ||
		    icmptype == ICMP6_TIME_EXCEEDED ||
		    icmptype == ICMP6_PARAM_PROB)
			state_icmp++;
		break;
#endif /* INET6 */
	}

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

	if (direction == PF_OUT) {
		/* check outgoing packet for BINAT/NAT */
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&saddr->v4.s_addr, pd->ip_sum,
				    pd->naddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				pf_change_a6(saddr, &pd->hdr.icmp6->icmp6_cksum,
				    &pd->naddr, 0);
				rewrite++;
				break;
#endif /* INET6 */
			}
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	} else {
		/* check incoming packet for BINAT/RDR */
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&daddr->v4.s_addr,
				    pd->ip_sum, pd->naddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				pf_change_a6(daddr, &pd->hdr.icmp6->icmp6_cksum,
				    &pd->naddr, 0);
				rewrite++;
				break;
#endif /* INET6 */
			}
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	}

	while (r != NULL) {
		r->evaluations++;
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, saddr, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, daddr, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->type && r->type != icmptype + 1)
			r = TAILQ_NEXT(r, entries);
		else if (r->code && r->code != icmpcode + 1)
			r = TAILQ_NEXT(r, entries);
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		else if (r->prob && r->prob <= arc4random())
			r = TAILQ_NEXT(r, entries);
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
			r = TAILQ_NEXT(r, entries);
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->tag)
				tag = r->tag;
			if (r->anchor == NULL) {
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
		}
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	REASON_SET(&reason, PFRES_MATCH);

	if (r->log) {
#ifdef INET6
		if (rewrite)
			m_copyback(m, off, sizeof(struct icmp6_hdr),
			    pd->hdr.icmp6);
#endif /* INET6 */
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
	}

	if (r->action != PF_PASS)
		return (PF_DROP);

	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

	if (!state_icmp && (r->keep_state || nr != NULL)) {
		/* create new state */
		struct pf_state	*s = NULL;
		struct pf_src_node *sn = NULL;

		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL) {
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
			REASON_SET(&reason, PFRES_MEMORY);
			return (PF_DROP);
		}
		bzero(s, sizeof(*s));
		r->states++;
		if (a != NULL)
			a->states++;
		s->rule.ptr = r;
		s->nat_rule.ptr = nr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
		s->proto = pd->proto;
		s->direction = direction;
		s->af = af;
		if (direction == PF_OUT) {
			PF_ACPY(&s->gwy.addr, saddr, af);
			s->gwy.port = icmpid;
			PF_ACPY(&s->ext.addr, daddr, af);
			s->ext.port = icmpid;
			if (nr != NULL)
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
			else
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
			s->lan.port = icmpid;
		} else {
			PF_ACPY(&s->lan.addr, daddr, af);
			s->lan.port = icmpid;
			PF_ACPY(&s->ext.addr, saddr, af);
			s->ext.port = icmpid;
			if (nr != NULL)
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
			else
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
			s->gwy.port = icmpid;
		}
		s->creation = time.tv_sec;
		s->expire = time.tv_sec;
		s->timeout = PFTM_ICMP_FIRST_PACKET;
		pf_set_rt_ifp(s, saddr);
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pf_src_tree_remove_state(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		} else
			*sm = s;
	}

#ifdef INET6
	/* copy back packet headers if we performed IPv6 NAT operations */
	if (rewrite)
		m_copyback(m, off, sizeof(struct icmp6_hdr),
		    pd->hdr.icmp6);
#endif /* INET6 */

	return (PF_PASS);
}

int
pf_test_other(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct pfi_kif *kif, struct mbuf *m, int off, void *h, struct pf_pdesc *pd,
    struct pf_rule **am, struct pf_ruleset **rsm, struct ifqueue *ifq)
{
	struct pf_rule		*nr = NULL;
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_src_node	*nsn = NULL;
	struct pf_addr		*saddr = pd->src, *daddr = pd->dst;
	sa_family_t		 af = pd->af;
	u_short			 reason;
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;

	if (pf_check_congestion(ifq))
		return (PF_DROP);

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

	if (direction == PF_OUT) {
		/* check outgoing packet for BINAT/NAT */
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&saddr->v4.s_addr, pd->ip_sum,
				    pd->naddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(saddr, &pd->naddr, af);
				break;
#endif /* INET6 */
			}
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	} else {
		/* check incoming packet for BINAT/RDR */
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&daddr->v4.s_addr,
				    pd->ip_sum, pd->naddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(daddr, &pd->naddr, af);
				break;
#endif /* INET6 */
			}
			if (nr->natpass)
				r = NULL;
			pd->nat_rule = nr;
		}
	}

	while (r != NULL) {
		r->evaluations++;
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->rule_flag & PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		else if (r->prob && r->prob <= arc4random())
			r = TAILQ_NEXT(r, entries);
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
			r = TAILQ_NEXT(r, entries);
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->tag)
				tag = r->tag;
			if (r->anchor == NULL) {
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
		}
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	REASON_SET(&reason, PFRES_MATCH);

	if (r->log)
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		struct pf_addr *a = NULL;

		if (nr != NULL) {
			if (direction == PF_OUT)
				a = saddr;
			else
				a = daddr;
		}
		if (a != NULL) {
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&a->v4.s_addr, pd->ip_sum,
				    pd->baddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(a, &pd->baddr, af);
				break;
#endif /* INET6 */
			}
		}
		if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
	}

	if (r->action != PF_PASS)
		return (PF_DROP);

	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

	if (r->keep_state || nr != NULL) {
		/* create new state */
		struct pf_state	*s = NULL;
		struct pf_src_node *sn = NULL;

		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL) {
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
			REASON_SET(&reason, PFRES_MEMORY);
			return (PF_DROP);
		}
		bzero(s, sizeof(*s));
		r->states++;
		if (a != NULL)
			a->states++;
		s->rule.ptr = r;
		s->nat_rule.ptr = nr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
		s->proto = pd->proto;
		s->direction = direction;
		s->af = af;
		if (direction == PF_OUT) {
			PF_ACPY(&s->gwy.addr, saddr, af);
			PF_ACPY(&s->ext.addr, daddr, af);
			if (nr != NULL)
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
			else
				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
		} else {
			PF_ACPY(&s->lan.addr, daddr, af);
			PF_ACPY(&s->ext.addr, saddr, af);
			if (nr != NULL)
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
			else
				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
		}
		s->src.state = PFOTHERS_SINGLE;
		s->dst.state = PFOTHERS_NO_TRAFFIC;
		s->creation = time.tv_sec;
		s->expire = time.tv_sec;
		s->timeout = PFTM_OTHER_FIRST_PACKET;
		pf_set_rt_ifp(s, saddr);
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pf_src_tree_remove_state(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		} else
			*sm = s;
	}

	return (PF_PASS);
}

int
pf_test_fragment(struct pf_rule **rm, int direction, struct pfi_kif *kif,
    struct mbuf *m, void *h, struct pf_pdesc *pd, struct pf_rule **am,
    struct pf_ruleset **rsm)
{
	struct pf_rule		*r, *a = NULL;
	struct pf_ruleset	*ruleset = NULL;
	sa_family_t		 af = pd->af;
	u_short			 reason;
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
	while (r != NULL) {
		r->evaluations++;
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.not))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.not))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->tos && !(r->tos & pd->tos))
			r = TAILQ_NEXT(r, entries);
		else if (r->src.port_op || r->dst.port_op ||
		    r->flagset || r->type || r->code ||
		    r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
		else if (r->prob && r->prob <= arc4random())
			r = TAILQ_NEXT(r, entries);
		else if (r->match_tag && !pf_match_tag(m, r, NULL, &pftag, &tag))
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->anchor == NULL) {
				*rm = r;
				*am = a;
				*rsm = ruleset;
				if ((*rm)->quick)
					break;
				r = TAILQ_NEXT(r, entries);
			} else
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
				    PF_RULESET_FILTER);
		}
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
			    PF_RULESET_FILTER);
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	REASON_SET(&reason, PFRES_MATCH);

	if (r->log)
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);

	if (r->action != PF_PASS)
		return (PF_DROP);

	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

	return (PF_PASS);
}

int
pf_test_state_tcp(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd,
    u_short *reason)
{
	struct pf_state		 key;
	struct tcphdr		*th = pd->hdr.tcp;
	u_int16_t		 win = ntohs(th->th_win);
	u_int32_t		 ack, end, seq, orig_seq;
	u_int8_t		 sws, dws;
	int			 ackskew;
	int			 copyback = 0;
	struct pf_state_peer	*src, *dst;

	key.af = pd->af;
	key.proto = IPPROTO_TCP;
	if (direction == PF_IN)	{
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = th->th_sport;
		key.gwy.port = th->th_dport;
	} else {
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = th->th_sport;
		key.ext.port = th->th_dport;
	}

	STATE_LOOKUP();

	if (direction == (*state)->direction) {
		src = &(*state)->src;
		dst = &(*state)->dst;
	} else {
		src = &(*state)->dst;
		dst = &(*state)->src;
	}

	if ((*state)->src.state == PF_TCPS_PROXY_SRC) {
		if (direction != (*state)->direction)
			return (PF_SYNPROXY_DROP);
		if (th->th_flags & TH_SYN) {
			if (ntohl(th->th_seq) != (*state)->src.seqlo)
				return (PF_DROP);
			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    (*state)->src.seqhi, ntohl(th->th_seq) + 1,
			    TH_SYN|TH_ACK, 0, (*state)->src.mss, 0, 1,
			    NULL, NULL);
			return (PF_SYNPROXY_DROP);
		} else if (!(th->th_flags & TH_ACK) ||
		    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
		    (ntohl(th->th_seq) != (*state)->src.seqlo + 1))
			return (PF_DROP);
		else
			(*state)->src.state = PF_TCPS_PROXY_DST;
	}
	if ((*state)->src.state == PF_TCPS_PROXY_DST) {
		struct pf_state_host *src, *dst;

		if (direction == PF_OUT) {
			src = &(*state)->gwy;
			dst = &(*state)->ext;
		} else {
			src = &(*state)->ext;
			dst = &(*state)->lan;
		}
		if (direction == (*state)->direction) {
			if (((th->th_flags & (TH_SYN|TH_ACK)) != TH_ACK) ||
			    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
			    (ntohl(th->th_seq) != (*state)->src.seqlo + 1))
				return (PF_DROP);
			(*state)->src.max_win = MAX(ntohs(th->th_win), 1);
			if ((*state)->dst.seqhi == 1)
				(*state)->dst.seqhi = htonl(arc4random());
			pf_send_tcp((*state)->rule.ptr, pd->af, &src->addr,
			    &dst->addr, src->port, dst->port,
			    (*state)->dst.seqhi, 0, TH_SYN, 0,
			    (*state)->src.mss, 0, 0, NULL, NULL);
			return (PF_SYNPROXY_DROP);
		} else if (((th->th_flags & (TH_SYN|TH_ACK)) !=
		    (TH_SYN|TH_ACK)) ||
		    (ntohl(th->th_ack) != (*state)->dst.seqhi + 1))
			return (PF_DROP);
		else {
			(*state)->dst.max_win = MAX(ntohs(th->th_win), 1);
			(*state)->dst.seqlo = ntohl(th->th_seq);
			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    ntohl(th->th_ack), ntohl(th->th_seq) + 1,
			    TH_ACK, (*state)->src.max_win, 0, 0, 1,
			    NULL, NULL);
			pf_send_tcp((*state)->rule.ptr, pd->af, &src->addr,
			    &dst->addr, src->port, dst->port,
			    (*state)->src.seqhi + 1, (*state)->src.seqlo + 1,
			    TH_ACK, (*state)->dst.max_win, 0, 0, 0,
			    NULL, NULL);
			(*state)->src.seqdiff = (*state)->dst.seqhi -
			    (*state)->src.seqlo;
			(*state)->dst.seqdiff = (*state)->src.seqhi -
			    (*state)->dst.seqlo;
			(*state)->src.seqhi = (*state)->src.seqlo +
			    (*state)->src.max_win;
			(*state)->dst.seqhi = (*state)->dst.seqlo +
			    (*state)->dst.max_win;
			(*state)->src.wscale = (*state)->dst.wscale = 0;
			(*state)->src.state = (*state)->dst.state =
			    TCPS_ESTABLISHED;
			return (PF_SYNPROXY_DROP);
		}
	}

	if (src->wscale && dst->wscale && !(th->th_flags & TH_SYN)) {
		sws = src->wscale & PF_WSCALE_MASK;
		dws = dst->wscale & PF_WSCALE_MASK;
	} else
		sws = dws = 0;

	/*
	 * Sequence tracking algorithm from Guido van Rooij's paper:
	 *   http://www.madison-gurkha.com/publications/tcp_filtering/
	 *	tcp_filtering.ps
	 */

	orig_seq = seq = ntohl(th->th_seq);
	if (src->seqlo == 0) {
		/* First packet from this end. Set its state */

		if ((pd->flags & PFDESC_TCP_NORM || dst->scrub) &&
		    src->scrub == NULL) {
			if (pf_normalize_tcp_init(m, off, pd, th, src, dst)) {
				REASON_SET(reason, PFRES_MEMORY);
				return (PF_DROP);
			}
		}

		/* Deferred generation of sequence number modulator */
		if (dst->seqdiff && !src->seqdiff) {
			while ((src->seqdiff = htonl(arc4random())) == 0)
				;
			ack = ntohl(th->th_ack) - dst->seqdiff;
			pf_change_a(&th->th_seq, &th->th_sum, htonl(seq +
			    src->seqdiff), 0);
			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack), 0);
			copyback = 1;
		} else {
			ack = ntohl(th->th_ack);
		}

		end = seq + pd->p_len;
		if (th->th_flags & TH_SYN) {
			end++;
			if (dst->wscale & PF_WSCALE_FLAG) {
				src->wscale = pf_get_wscale(m, off, th->th_off,
				    pd->af);
				if (src->wscale & PF_WSCALE_FLAG) {
					/* Remove scale factor from initial
					 * window */
					sws = src->wscale & PF_WSCALE_MASK;
					win = ((u_int32_t)win + (1 << sws) - 1)
					    >> sws;
					dws = dst->wscale & PF_WSCALE_MASK;
				} else {
					/* fixup other window */
					dst->max_win <<= dst->wscale &
					    PF_WSCALE_MASK;
					/* in case of a retrans SYN|ACK */
					dst->wscale = 0;
				}
			}
		}
		if (th->th_flags & TH_FIN)
			end++;

		src->seqlo = seq;
		if (src->state < TCPS_SYN_SENT)
			src->state = TCPS_SYN_SENT;

		/*
		 * May need to slide the window (seqhi may have been set by
		 * the crappy stack check or if we picked up the connection
		 * after establishment)
		 */
		if (src->seqhi == 1 ||
		    SEQ_GEQ(end + MAX(1, dst->max_win << dws), src->seqhi))
			src->seqhi = end + MAX(1, dst->max_win << dws);
		if (win > src->max_win)
			src->max_win = win;

	} else {
		ack = ntohl(th->th_ack) - dst->seqdiff;
		if (src->seqdiff) {
			/* Modulate sequence numbers */
			pf_change_a(&th->th_seq, &th->th_sum, htonl(seq +
			    src->seqdiff), 0);
			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack), 0);
			copyback = 1;
		}
		end = seq + pd->p_len;
		if (th->th_flags & TH_SYN)
			end++;
		if (th->th_flags & TH_FIN)
			end++;
	}

	if ((th->th_flags & TH_ACK) == 0) {
		/* Let it pass through the ack skew check */
		ack = dst->seqlo;
	} else if ((ack == 0 &&
	    (th->th_flags & (TH_ACK|TH_RST)) == (TH_ACK|TH_RST)) ||
	    /* broken tcp stacks do not set ack */
	    (dst->state < TCPS_SYN_SENT)) {
		/*
		 * Many stacks (ours included) will set the ACK number in an
		 * FIN|ACK if the SYN times out -- no sequence to ACK.
		 */
		ack = dst->seqlo;
	}

	if (seq == end) {
		/* Ease sequencing restrictions on no data packets */
		seq = src->seqlo;
		end = seq;
	}

	ackskew = dst->seqlo - ack;

#define MAXACKWINDOW (0xffff + 1500)	/* 1500 is an arbitrary fudge factor */
	if (SEQ_GEQ(src->seqhi, end) &&
	    /* Last octet inside other's window space */
	    SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws)) &&
	    /* Retrans: not more than one window back */
	    (ackskew >= -MAXACKWINDOW) &&
	    /* Acking not more than one reassembled fragment backwards */
	    (ackskew <= (MAXACKWINDOW << sws)) &&
	    /* Acking not more than one window forward */
	    ((th->th_flags & TH_RST) == 0 || orig_seq == src->seqlo ||
	    (pd->flags & PFDESC_IP_REAS) == 0)) {
	    /* Require an exact sequence match on resets when possible */

		if (dst->scrub || src->scrub) {
			if (pf_normalize_tcp_stateful(m, off, pd, reason, th,
			    *state, src, dst, &copyback))
				return (PF_DROP);
		}

		/* update max window */
		if (src->max_win < win)
			src->max_win = win;
		/* synchronize sequencing */
		if (SEQ_GT(end, src->seqlo))
			src->seqlo = end;
		/* slide the window of what the other end can send */
		if (SEQ_GEQ(ack + (win << sws), dst->seqhi))
			dst->seqhi = ack + MAX((win << sws), 1);


		/* update states */
		if (th->th_flags & TH_SYN)
			if (src->state < TCPS_SYN_SENT)
				src->state = TCPS_SYN_SENT;
		if (th->th_flags & TH_FIN)
			if (src->state < TCPS_CLOSING)
				src->state = TCPS_CLOSING;
		if (th->th_flags & TH_ACK) {
			if (dst->state == TCPS_SYN_SENT)
				dst->state = TCPS_ESTABLISHED;
			else if (dst->state == TCPS_CLOSING)
				dst->state = TCPS_FIN_WAIT_2;
		}
		if (th->th_flags & TH_RST)
			src->state = dst->state = TCPS_TIME_WAIT;

		/* update expire time */
		(*state)->expire = time.tv_sec;
		if (src->state >= TCPS_FIN_WAIT_2 &&
		    dst->state >= TCPS_FIN_WAIT_2)
			(*state)->timeout = PFTM_TCP_CLOSED;
		else if (src->state >= TCPS_FIN_WAIT_2 ||
		    dst->state >= TCPS_FIN_WAIT_2)
			(*state)->timeout = PFTM_TCP_FIN_WAIT;
		else if (src->state < TCPS_ESTABLISHED ||
		    dst->state < TCPS_ESTABLISHED)
			(*state)->timeout = PFTM_TCP_OPENING;
		else if (src->state >= TCPS_CLOSING ||
		    dst->state >= TCPS_CLOSING)
			(*state)->timeout = PFTM_TCP_CLOSING;
		else
			(*state)->timeout = PFTM_TCP_ESTABLISHED;

		/* Fall through to PASS packet */

	} else if ((dst->state < TCPS_SYN_SENT ||
		dst->state >= TCPS_FIN_WAIT_2 ||
		src->state >= TCPS_FIN_WAIT_2) &&
	    SEQ_GEQ(src->seqhi + MAXACKWINDOW, end) &&
	    /* Within a window forward of the originating packet */
	    SEQ_GEQ(seq, src->seqlo - MAXACKWINDOW)) {
	    /* Within a window backward of the originating packet */

		/*
		 * This currently handles three situations:
		 *  1) Stupid stacks will shotgun SYNs before their peer
		 *     replies.
		 *  2) When PF catches an already established stream (the
		 *     firewall rebooted, the state table was flushed, routes
		 *     changed...)
		 *  3) Packets get funky immediately after the connection
		 *     closes (this should catch Solaris spurious ACK|FINs
		 *     that web servers like to spew after a close)
		 *
		 * This must be a little more careful than the above code
		 * since packet floods will also be caught here. We don't
		 * update the TTL here to mitigate the damage of a packet
		 * flood and so the same code can handle awkward establishment
		 * and a loosened connection close.
		 * In the establishment case, a correct peer response will
		 * validate the connection, go through the normal state code
		 * and keep updating the state TTL.
		 */

		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: loose state match: ");
			pf_print_state(*state);
			pf_print_flags(th->th_flags);
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d:%d\n",
			    seq, ack, pd->p_len, ackskew,
			    (*state)->packets[0], (*state)->packets[1]);
		}

		if (dst->scrub || src->scrub) {
			if (pf_normalize_tcp_stateful(m, off, pd, reason, th,
			    *state, src, dst, &copyback))
				return (PF_DROP);
		}

		/* update max window */
		if (src->max_win < win)
			src->max_win = win;
		/* synchronize sequencing */
		if (SEQ_GT(end, src->seqlo))
			src->seqlo = end;
		/* slide the window of what the other end can send */
		if (SEQ_GEQ(ack + (win << sws), dst->seqhi))
			dst->seqhi = ack + MAX((win << sws), 1);

		/*
		 * Cannot set dst->seqhi here since this could be a shotgunned
		 * SYN and not an already established connection.
		 */

		if (th->th_flags & TH_FIN)
			if (src->state < TCPS_CLOSING)
				src->state = TCPS_CLOSING;
		if (th->th_flags & TH_RST)
			src->state = dst->state = TCPS_TIME_WAIT;

		/* Fall through to PASS packet */

	} else {
		if ((*state)->dst.state == TCPS_SYN_SENT &&
		    (*state)->src.state == TCPS_SYN_SENT) {
			/* Send RST for state mismatches during handshake */
			if (!(th->th_flags & TH_RST)) {
				u_int32_t ack = ntohl(th->th_seq) + pd->p_len;

				if (th->th_flags & TH_SYN)
					ack++;
				if (th->th_flags & TH_FIN)
					ack++;
				pf_send_tcp((*state)->rule.ptr, pd->af,
				    pd->dst, pd->src, th->th_dport,
				    th->th_sport, ntohl(th->th_ack), ack,
				    TH_RST|TH_ACK, 0, 0,
				    (*state)->rule.ptr->return_ttl, 1,
				    pd->eh, kif->pfik_ifp);
			}
			src->seqlo = 0;
			src->seqhi = 1;
			src->max_win = 1;
		} else if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: BAD state: ");
			pf_print_state(*state);
			pf_print_flags(th->th_flags);
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d:%d "
			    "dir=%s,%s\n", seq, ack, pd->p_len, ackskew,
			    (*state)->packets[0], (*state)->packets[1],
			    direction == PF_IN ? "in" : "out",
			    direction == (*state)->direction ? "fwd" : "rev");
			printf("pf: State failure on: %c %c %c %c | %c %c\n",
			    SEQ_GEQ(src->seqhi, end) ? ' ' : '1',
			    SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws)) ?
			    ' ': '2',
			    (ackskew >= -MAXACKWINDOW) ? ' ' : '3',
			    (ackskew <= (MAXACKWINDOW << sws)) ? ' ' : '4',
			    SEQ_GEQ(src->seqhi + MAXACKWINDOW, end) ?' ' :'5',
			    SEQ_GEQ(seq, src->seqlo - MAXACKWINDOW) ?' ' :'6');
		}
		return (PF_DROP);
	}


	/* Any packets which have gotten here are to be passed */

	/* translate source/destination address, if necessary */
	if (STATE_TRANSLATE(*state)) {
		if (direction == PF_OUT)
			pf_change_ap(pd->src, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &(*state)->gwy.addr,
			    (*state)->gwy.port, 0, pd->af);
		else
			pf_change_ap(pd->dst, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &(*state)->lan.addr,
			    (*state)->lan.port, 0, pd->af);
		m_copyback(m, off, sizeof(*th), th);
	} else if (copyback) {
		/* Copyback sequence modulation or stateful scrub changes */
		m_copyback(m, off, sizeof(*th), th);
	}

	return (PF_PASS);
}

int
pf_test_state_udp(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd)
{
	struct pf_state_peer	*src, *dst;
	struct pf_state		 key;
	struct udphdr		*uh = pd->hdr.udp;

	key.af = pd->af;
	key.proto = IPPROTO_UDP;
	if (direction == PF_IN)	{
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = uh->uh_sport;
		key.gwy.port = uh->uh_dport;
	} else {
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = uh->uh_sport;
		key.ext.port = uh->uh_dport;
	}

	STATE_LOOKUP();

	if (direction == (*state)->direction) {
		src = &(*state)->src;
		dst = &(*state)->dst;
	} else {
		src = &(*state)->dst;
		dst = &(*state)->src;
	}

	/* update states */
	if (src->state < PFUDPS_SINGLE)
		src->state = PFUDPS_SINGLE;
	if (dst->state == PFUDPS_SINGLE)
		dst->state = PFUDPS_MULTIPLE;

	/* update expire time */
	(*state)->expire = time.tv_sec;
	if (src->state == PFUDPS_MULTIPLE && dst->state == PFUDPS_MULTIPLE)
		(*state)->timeout = PFTM_UDP_MULTIPLE;
	else
		(*state)->timeout = PFTM_UDP_SINGLE;

	/* translate source/destination address, if necessary */
	if (STATE_TRANSLATE(*state)) {
		if (direction == PF_OUT)
			pf_change_ap(pd->src, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &(*state)->gwy.addr,
			    (*state)->gwy.port, 1, pd->af);
		else
			pf_change_ap(pd->dst, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &(*state)->lan.addr,
			    (*state)->lan.port, 1, pd->af);
		m_copyback(m, off, sizeof(*uh), uh);
	}

	return (PF_PASS);
}

int
pf_test_state_icmp(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd)
{
	struct pf_addr	*saddr = pd->src, *daddr = pd->dst;
	u_int16_t	 icmpid, *icmpsum;
	u_int8_t	 icmptype;
	int		 state_icmp = 0;

	switch (pd->proto) {
#ifdef INET
	case IPPROTO_ICMP:
		icmptype = pd->hdr.icmp->icmp_type;
		icmpid = pd->hdr.icmp->icmp_id;
		icmpsum = &pd->hdr.icmp->icmp_cksum;

		if (icmptype == ICMP_UNREACH ||
		    icmptype == ICMP_SOURCEQUENCH ||
		    icmptype == ICMP_REDIRECT ||
		    icmptype == ICMP_TIMXCEED ||
		    icmptype == ICMP_PARAMPROB)
			state_icmp++;
		break;
#endif /* INET */
#ifdef INET6
	case IPPROTO_ICMPV6:
		icmptype = pd->hdr.icmp6->icmp6_type;
		icmpid = pd->hdr.icmp6->icmp6_id;
		icmpsum = &pd->hdr.icmp6->icmp6_cksum;

		if (icmptype == ICMP6_DST_UNREACH ||
		    icmptype == ICMP6_PACKET_TOO_BIG ||
		    icmptype == ICMP6_TIME_EXCEEDED ||
		    icmptype == ICMP6_PARAM_PROB)
			state_icmp++;
		break;
#endif /* INET6 */
	}

	if (!state_icmp) {

		/*
		 * ICMP query/reply message not related to a TCP/UDP packet.
		 * Search for an ICMP state.
		 */
		struct pf_state		key;

		key.af = pd->af;
		key.proto = pd->proto;
		if (direction == PF_IN)	{
			PF_ACPY(&key.ext.addr, pd->src, key.af);
			PF_ACPY(&key.gwy.addr, pd->dst, key.af);
			key.ext.port = icmpid;
			key.gwy.port = icmpid;
		} else {
			PF_ACPY(&key.lan.addr, pd->src, key.af);
			PF_ACPY(&key.ext.addr, pd->dst, key.af);
			key.lan.port = icmpid;
			key.ext.port = icmpid;
		}

		STATE_LOOKUP();

		(*state)->expire = time.tv_sec;
		(*state)->timeout = PFTM_ICMP_ERROR_REPLY;

		/* translate source/destination address, if necessary */
		if (PF_ANEQ(&(*state)->lan.addr, &(*state)->gwy.addr, pd->af)) {
			if (direction == PF_OUT) {
				switch (pd->af) {
#ifdef INET
				case AF_INET:
					pf_change_a(&saddr->v4.s_addr,
					    pd->ip_sum,
					    (*state)->gwy.addr.v4.s_addr, 0);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					pf_change_a6(saddr,
					    &pd->hdr.icmp6->icmp6_cksum,
					    &(*state)->gwy.addr, 0);
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
					    pd->hdr.icmp6);
					break;
#endif /* INET6 */
				}
			} else {
				switch (pd->af) {
#ifdef INET
				case AF_INET:
					pf_change_a(&daddr->v4.s_addr,
					    pd->ip_sum,
					    (*state)->lan.addr.v4.s_addr, 0);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					pf_change_a6(daddr,
					    &pd->hdr.icmp6->icmp6_cksum,
					    &(*state)->lan.addr, 0);
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
					    pd->hdr.icmp6);
					break;
#endif /* INET6 */
				}
			}
		}

		return (PF_PASS);

	} else {
		/*
		 * ICMP error message in response to a TCP/UDP packet.
		 * Extract the inner TCP/UDP header and search for that state.
		 */

		struct pf_pdesc	pd2;
#ifdef INET
		struct ip	h2;
#endif /* INET */
#ifdef INET6
		struct ip6_hdr	h2_6;
		int		terminal = 0;
#endif /* INET6 */
		int		ipoff2;
		int		off2;

		pd2.af = pd->af;
		switch (pd->af) {
#ifdef INET
		case AF_INET:
			/* offset of h2 in mbuf chain */
			ipoff2 = off + ICMP_MINLEN;

			if (!pf_pull_hdr(m, ipoff2, &h2, sizeof(h2),
			    NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short "
				    "(ip)\n"));
				return (PF_DROP);
			}
			/*
			 * ICMP error messages don't refer to non-first
			 * fragments
			 */
			if (h2.ip_off & htons(IP_OFFMASK))
				return (PF_DROP);

			/* offset of protocol header that follows h2 */
			off2 = ipoff2 + (h2.ip_hl << 2);

			pd2.proto = h2.ip_p;
			pd2.src = (struct pf_addr *)&h2.ip_src;
			pd2.dst = (struct pf_addr *)&h2.ip_dst;
			pd2.ip_sum = &h2.ip_sum;
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
			ipoff2 = off + sizeof(struct icmp6_hdr);

			if (!pf_pull_hdr(m, ipoff2, &h2_6, sizeof(h2_6),
			    NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short "
				    "(ip6)\n"));
				return (PF_DROP);
			}
			pd2.proto = h2_6.ip6_nxt;
			pd2.src = (struct pf_addr *)&h2_6.ip6_src;
			pd2.dst = (struct pf_addr *)&h2_6.ip6_dst;
			pd2.ip_sum = NULL;
			off2 = ipoff2 + sizeof(h2_6);
			do {
				switch (pd2.proto) {
				case IPPROTO_FRAGMENT:
					/*
					 * ICMPv6 error messages for
					 * non-first fragments
					 */
					return (PF_DROP);
				case IPPROTO_AH:
				case IPPROTO_HOPOPTS:
				case IPPROTO_ROUTING:
				case IPPROTO_DSTOPTS: {
					/* get next header and header length */
					struct ip6_ext opt6;

					if (!pf_pull_hdr(m, off2, &opt6,
					    sizeof(opt6), NULL, NULL, pd2.af)) {
						DPFPRINTF(PF_DEBUG_MISC,
						    ("pf: ICMPv6 short opt\n"));
						return (PF_DROP);
					}
					if (pd2.proto == IPPROTO_AH)
						off2 += (opt6.ip6e_len + 2) * 4;
					else
						off2 += (opt6.ip6e_len + 1) * 8;
					pd2.proto = opt6.ip6e_nxt;
					/* goto the next header */
					break;
				}
				default:
					terminal++;
					break;
				}
			} while (!terminal);
			break;
#endif /* INET6 */
		}

		switch (pd2.proto) {
		case IPPROTO_TCP: {
			struct tcphdr		 th;
			u_int32_t		 seq;
			struct pf_state		 key;
			struct pf_state_peer	*src, *dst;
			u_int8_t		 dws;
			int			 copyback = 0;

			/*
			 * Only the first 8 bytes of the TCP header can be
			 * expected. Don't access any TCP header fields after
			 * th_seq, an ackskew test is not possible.
			 */
			if (!pf_pull_hdr(m, off2, &th, 8, NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short "
				    "(tcp)\n"));
				return (PF_DROP);
			}

			key.af = pd2.af;
			key.proto = IPPROTO_TCP;
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = th.th_dport;
				key.gwy.port = th.th_sport;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = th.th_dport;
				key.ext.port = th.th_sport;
			}

			STATE_LOOKUP();

			if (direction == (*state)->direction) {
				src = &(*state)->dst;
				dst = &(*state)->src;
			} else {
				src = &(*state)->src;
				dst = &(*state)->dst;
			}

			if (src->wscale && dst->wscale &&
			    !(th.th_flags & TH_SYN))
				dws = dst->wscale & PF_WSCALE_MASK;
			else
				dws = 0;

			/* Demodulate sequence number */
			seq = ntohl(th.th_seq) - src->seqdiff;
			if (src->seqdiff) {
				pf_change_a(&th.th_seq, icmpsum,
				    htonl(seq), 0);
				copyback = 1;
			}

			if (!SEQ_GEQ(src->seqhi, seq) ||
			    !SEQ_GEQ(seq, src->seqlo - (dst->max_win << dws))) {
				if (pf_status.debug >= PF_DEBUG_MISC) {
					printf("pf: BAD ICMP %d:%d ",
					    icmptype, pd->hdr.icmp->icmp_code);
					pf_print_host(pd->src, 0, pd->af);
					printf(" -> ");
					pf_print_host(pd->dst, 0, pd->af);
					printf(" state: ");
					pf_print_state(*state);
					printf(" seq=%u\n", seq);
				}
				return (PF_DROP);
			}

			if (STATE_TRANSLATE(*state)) {
				if (direction == PF_IN) {
					pf_change_icmp(pd2.src, &th.th_sport,
					    daddr, &(*state)->lan.addr,
					    (*state)->lan.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
				} else {
					pf_change_icmp(pd2.dst, &th.th_dport,
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
				}
				copyback = 1;
			}

			if (copyback) {
				switch (pd2.af) {
#ifdef INET
				case AF_INET:
					m_copyback(m, off, ICMP_MINLEN,
					    pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2),
					    &h2);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
					    pd->hdr.icmp6);
					m_copyback(m, ipoff2, sizeof(h2_6),
					    &h2_6);
					break;
#endif /* INET6 */
				}
				m_copyback(m, off2, 8, &th);
			}

			return (PF_PASS);
			break;
		}
		case IPPROTO_UDP: {
			struct udphdr		uh;
			struct pf_state		key;

			if (!pf_pull_hdr(m, off2, &uh, sizeof(uh),
			    NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short "
				    "(udp)\n"));
				return (PF_DROP);
			}

			key.af = pd2.af;
			key.proto = IPPROTO_UDP;
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = uh.uh_dport;
				key.gwy.port = uh.uh_sport;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = uh.uh_dport;
				key.ext.port = uh.uh_sport;
			}

			STATE_LOOKUP();

			if (STATE_TRANSLATE(*state)) {
				if (direction == PF_IN) {
					pf_change_icmp(pd2.src, &uh.uh_sport,
					    daddr, &(*state)->lan.addr,
					    (*state)->lan.port, &uh.uh_sum,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 1, pd2.af);
				} else {
					pf_change_icmp(pd2.dst, &uh.uh_dport,
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, &uh.uh_sum,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 1, pd2.af);
				}
				switch (pd2.af) {
#ifdef INET
				case AF_INET:
					m_copyback(m, off, ICMP_MINLEN,
					    pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2), &h2);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
					    pd->hdr.icmp6);
					m_copyback(m, ipoff2, sizeof(h2_6),
					    &h2_6);
					break;
#endif /* INET6 */
				}
				m_copyback(m, off2, sizeof(uh), &uh);
			}

			return (PF_PASS);
			break;
		}
#ifdef INET
		case IPPROTO_ICMP: {
			struct icmp		iih;
			struct pf_state		key;

			if (!pf_pull_hdr(m, off2, &iih, ICMP_MINLEN,
			    NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short i"
				    "(icmp)\n"));
				return (PF_DROP);
			}

			key.af = pd2.af;
			key.proto = IPPROTO_ICMP;
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = iih.icmp_id;
				key.gwy.port = iih.icmp_id;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = iih.icmp_id;
				key.ext.port = iih.icmp_id;
			}

			STATE_LOOKUP();

			if (STATE_TRANSLATE(*state)) {
				if (direction == PF_IN) {
					pf_change_icmp(pd2.src, &iih.icmp_id,
					    daddr, &(*state)->lan.addr,
					    (*state)->lan.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET);
				} else {
					pf_change_icmp(pd2.dst, &iih.icmp_id,
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET);
				}
				m_copyback(m, off, ICMP_MINLEN, pd->hdr.icmp);
				m_copyback(m, ipoff2, sizeof(h2), &h2);
				m_copyback(m, off2, ICMP_MINLEN, &iih);
			}

			return (PF_PASS);
			break;
		}
#endif /* INET */
#ifdef INET6
		case IPPROTO_ICMPV6: {
			struct icmp6_hdr	iih;
			struct pf_state		key;

			if (!pf_pull_hdr(m, off2, &iih,
			    sizeof(struct icmp6_hdr), NULL, NULL, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: ICMP error message too short "
				    "(icmp6)\n"));
				return (PF_DROP);
			}

			key.af = pd2.af;
			key.proto = IPPROTO_ICMPV6;
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = iih.icmp6_id;
				key.gwy.port = iih.icmp6_id;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = iih.icmp6_id;
				key.ext.port = iih.icmp6_id;
			}

			STATE_LOOKUP();

			if (STATE_TRANSLATE(*state)) {
				if (direction == PF_IN) {
					pf_change_icmp(pd2.src, &iih.icmp6_id,
					    daddr, &(*state)->lan.addr,
					    (*state)->lan.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET6);
				} else {
					pf_change_icmp(pd2.dst, &iih.icmp6_id,
					    saddr, &(*state)->gwy.addr,
					    (*state)->gwy.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, AF_INET6);
				}
				m_copyback(m, off, sizeof(struct icmp6_hdr),
				    pd->hdr.icmp6);
				m_copyback(m, ipoff2, sizeof(h2_6), &h2_6);
				m_copyback(m, off2, sizeof(struct icmp6_hdr),
				    &iih);
			}

			return (PF_PASS);
			break;
		}
#endif /* INET6 */
		default: {
			struct pf_state		key;

			key.af = pd2.af;
			key.proto = pd2.proto;
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = 0;
				key.gwy.port = 0;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = 0;
				key.ext.port = 0;
			}

			STATE_LOOKUP();

			if (STATE_TRANSLATE(*state)) {
				if (direction == PF_IN) {
					pf_change_icmp(pd2.src, NULL,
					    daddr, &(*state)->lan.addr,
					    0, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
				} else {
					pf_change_icmp(pd2.dst, NULL,
					    saddr, &(*state)->gwy.addr,
					    0, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
				}
				switch (pd2.af) {
#ifdef INET
				case AF_INET:
					m_copyback(m, off, ICMP_MINLEN,
					    pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2), &h2);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
					    pd->hdr.icmp6);
					m_copyback(m, ipoff2, sizeof(h2_6),
					    &h2_6);
					break;
#endif /* INET6 */
				}
			}

			return (PF_PASS);
			break;
		}
		}
	}
}

int
pf_test_state_other(struct pf_state **state, int direction, struct pfi_kif *kif,
    struct pf_pdesc *pd)
{
	struct pf_state_peer	*src, *dst;
	struct pf_state		 key;

	key.af = pd->af;
	key.proto = pd->proto;
	if (direction == PF_IN)	{
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = 0;
		key.gwy.port = 0;
	} else {
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = 0;
		key.ext.port = 0;
	}

	STATE_LOOKUP();

	if (direction == (*state)->direction) {
		src = &(*state)->src;
		dst = &(*state)->dst;
	} else {
		src = &(*state)->dst;
		dst = &(*state)->src;
	}

	/* update states */
	if (src->state < PFOTHERS_SINGLE)
		src->state = PFOTHERS_SINGLE;
	if (dst->state == PFOTHERS_SINGLE)
		dst->state = PFOTHERS_MULTIPLE;

	/* update expire time */
	(*state)->expire = time.tv_sec;
	if (src->state == PFOTHERS_MULTIPLE && dst->state == PFOTHERS_MULTIPLE)
		(*state)->timeout = PFTM_OTHER_MULTIPLE;
	else
		(*state)->timeout = PFTM_OTHER_SINGLE;

	/* translate source/destination address, if necessary */
	if (STATE_TRANSLATE(*state)) {
		if (direction == PF_OUT)
			switch (pd->af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&pd->src->v4.s_addr,
				    pd->ip_sum, (*state)->gwy.addr.v4.s_addr,
				    0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(pd->src, &(*state)->gwy.addr, pd->af);
				break;
#endif /* INET6 */
			}
		else
			switch (pd->af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&pd->dst->v4.s_addr,
				    pd->ip_sum, (*state)->lan.addr.v4.s_addr,
				    0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(pd->dst, &(*state)->lan.addr, pd->af);
				break;
#endif /* INET6 */
			}
	}

	return (PF_PASS);
}

/*
 * ipoff and off are measured from the start of the mbuf chain.
 * h must be at "ipoff" on the mbuf chain.
 */
void *
pf_pull_hdr(struct mbuf *m, int off, void *p, int len,
    u_short *actionp, u_short *reasonp, sa_family_t af)
{
	switch (af) {
#ifdef INET
	case AF_INET: {
		struct ip	*h = mtod(m, struct ip *);
		u_int16_t	 fragoff = (ntohs(h->ip_off) & IP_OFFMASK) << 3;

		if (fragoff) {
			if (fragoff >= len)
				ACTION_SET(actionp, PF_PASS);
			else {
				ACTION_SET(actionp, PF_DROP);
				REASON_SET(reasonp, PFRES_FRAG);
			}
			return (NULL);
		}
		if (m->m_pkthdr.len < off + len ||
		    ntohs(h->ip_len) < off + len) {
			ACTION_SET(actionp, PF_DROP);
			REASON_SET(reasonp, PFRES_SHORT);
			return (NULL);
		}
		break;
	}
#endif /* INET */
#ifdef INET6
	case AF_INET6: {
		struct ip6_hdr	*h = mtod(m, struct ip6_hdr *);

		if (m->m_pkthdr.len < off + len ||
		    (ntohs(h->ip6_plen) + sizeof(struct ip6_hdr)) <
		    (unsigned)(off + len)) {
			ACTION_SET(actionp, PF_DROP);
			REASON_SET(reasonp, PFRES_SHORT);
			return (NULL);
		}
		break;
	}
#endif /* INET6 */
	}
	m_copydata(m, off, len, p);
	return (p);
}

int
pf_routable(struct pf_addr *addr, sa_family_t af)
{
	struct sockaddr_in	*dst;
	struct route		 ro;
	int			 ret = 0;

	bzero(&ro, sizeof(ro));
	dst = satosin(&ro.ro_dst);
	dst->sin_family = af;
	dst->sin_len = sizeof(*dst);
	dst->sin_addr = addr->v4;
	rtalloc_noclone(&ro, NO_CLONING);

	if (ro.ro_rt != NULL) {
		ret = 1;
		RTFREE(ro.ro_rt);
	}

	return (ret);
}

#ifdef INET
void
pf_route(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp,
    struct pf_state *s)
{
	struct mbuf		*m0, *m1;
	struct m_tag		*mtag;
	struct route		 iproute;
	struct route		*ro;
	struct sockaddr_in	*dst;
	struct ip		*ip;
	struct ifnet		*ifp = NULL;
	struct pf_addr		 naddr;
	struct pf_src_node	*sn = NULL;
	int			 error = 0;

	if (m == NULL || *m == NULL || r == NULL ||
	    (dir != PF_IN && dir != PF_OUT) || oifp == NULL)
		panic("pf_route: invalid parameters");

	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
			return;
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
	} else {
		if ((r->rt == PF_REPLYTO) == (r->direction == dir))
			return;
		m0 = *m;
	}

	if (m0->m_len < sizeof(struct ip))
		panic("pf_route: m0->m_len < sizeof(struct ip)");
	ip = mtod(m0, struct ip *);

	ro = &iproute;
	bzero((caddr_t)ro, sizeof(*ro));
	dst = satosin(&ro->ro_dst);
	dst->sin_family = AF_INET;
	dst->sin_len = sizeof(*dst);
	dst->sin_addr = ip->ip_dst;

	if (r->rt == PF_FASTROUTE) {
		rtalloc(ro);
		if (ro->ro_rt == 0) {
			ipstat.ips_noroute++;
			goto bad;
		}

		ifp = ro->ro_rt->rt_ifp;
		ro->ro_rt->rt_use++;

		if (ro->ro_rt->rt_flags & RTF_GATEWAY)
			dst = satosin(ro->ro_rt->rt_gateway);
	} else {
		if (TAILQ_EMPTY(&r->rpool.list))
			panic("pf_route: TAILQ_EMPTY(&r->rpool.list)");
		if (s == NULL) {
			pf_map_addr(AF_INET, r, (struct pf_addr *)&ip->ip_src,
			    &naddr, NULL, &sn);
			if (!PF_AZERO(&naddr, AF_INET))
				dst->sin_addr.s_addr = naddr.v4.s_addr;
			ifp = r->rpool.cur->kif ?
			    r->rpool.cur->kif->pfik_ifp : NULL;
		} else {
			if (!PF_AZERO(&s->rt_addr, AF_INET))
				dst->sin_addr.s_addr =
				    s->rt_addr.v4.s_addr;
			ifp = s->rt_kif ? s->rt_kif->pfik_ifp : NULL;
		}
	}
	if (ifp == NULL)
		goto bad;

	if (oifp != ifp) {
		if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip))
			panic("pf_route: m0->m_len < sizeof(struct ip)");
		ip = mtod(m0, struct ip *);
	}

	/* Copied from ip_output. */
#ifdef IPSEC
	/*
	 * If deferred crypto processing is needed, check that the
	 * interface supports it.
	 */
	if ((mtag = m_tag_find(m0, PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED, NULL))
	    != NULL && (ifp->if_capabilities & IFCAP_IPSEC) == 0) {
		/* Notify IPsec to do its own crypto. */
		ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
		goto bad;
	}
#endif /* IPSEC */

	/* Catch routing changes wrt. hardware checksumming for TCP or UDP. */
	if (m0->m_pkthdr.csum & M_TCPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_TCPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m0);
			m0->m_pkthdr.csum &= ~M_TCPV4_CSUM_OUT; /* Clear */
		}
	} else if (m0->m_pkthdr.csum & M_UDPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_UDPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m0);
			m0->m_pkthdr.csum &= ~M_UDPV4_CSUM_OUT; /* Clear */
		}
	}

	if (ntohs(ip->ip_len) <= ifp->if_mtu) {
		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		    ifp->if_bridge == NULL) {
			m0->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
			ipstat.ips_outhwcsum++;
		} else {
			ip->ip_sum = 0;
			ip->ip_sum = in_cksum(m0, ip->ip_hl << 2);
		}
		/* Update relevant hardware checksum stats for TCP/UDP */
		if (m0->m_pkthdr.csum & M_TCPV4_CSUM_OUT)
			tcpstat.tcps_outhwcsum++;
		else if (m0->m_pkthdr.csum & M_UDPV4_CSUM_OUT)
			udpstat.udps_outhwcsum++;
		error = (*ifp->if_output)(ifp, m0, sintosa(dst), NULL);
		goto done;
	}

	/*
	 * Too large for interface; fragment if possible.
	 * Must be able to put at least 8 bytes per fragment.
	 */
	if (ip->ip_off & htons(IP_DF)) {
		ipstat.ips_cantfrag++;
		if (r->rt != PF_DUPTO) {
			icmp_error(m0, ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG, 0,
			    ifp);
			goto done;
		} else
			goto bad;
	}

	m1 = m0;
	error = ip_fragment(m0, ifp, ifp->if_mtu);
	if (error) {
		m0 = NULL;
		goto bad;
	}

	for (m0 = m1; m0; m0 = m1) {
		m1 = m0->m_nextpkt;
		m0->m_nextpkt = 0;
		if (error == 0)
			error = (*ifp->if_output)(ifp, m0, sintosa(dst),
			    NULL);
		else
			m_freem(m0);
	}

	if (error == 0)
		ipstat.ips_fragmented++;

done:
	if (r->rt != PF_DUPTO)
		*m = NULL;
	if (ro == &iproute && ro->ro_rt)
		RTFREE(ro->ro_rt);
	return;

bad:
	m_freem(m0);
	goto done;
}
#endif /* INET */

#ifdef INET6
void
pf_route6(struct mbuf **m, struct pf_rule *r, int dir, struct ifnet *oifp,
    struct pf_state *s)
{
	struct mbuf		*m0;
	struct m_tag		*mtag;
	struct route_in6	 ip6route;
	struct route_in6	*ro;
	struct sockaddr_in6	*dst;
	struct ip6_hdr		*ip6;
	struct ifnet		*ifp = NULL;
	struct pf_addr		 naddr;
	struct pf_src_node	*sn = NULL;
	int			 error = 0;

	if (m == NULL || *m == NULL || r == NULL ||
	    (dir != PF_IN && dir != PF_OUT) || oifp == NULL)
		panic("pf_route6: invalid parameters");

	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
			return;
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
	} else {
		if ((r->rt == PF_REPLYTO) == (r->direction == dir))
			return;
		m0 = *m;
	}

	if (m0->m_len < sizeof(struct ip6_hdr))
		panic("pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
	ip6 = mtod(m0, struct ip6_hdr *);

	ro = &ip6route;
	bzero((caddr_t)ro, sizeof(*ro));
	dst = (struct sockaddr_in6 *)&ro->ro_dst;
	dst->sin6_family = AF_INET6;
	dst->sin6_len = sizeof(*dst);
	dst->sin6_addr = ip6->ip6_dst;

	/* Cheat. */
	if (r->rt == PF_FASTROUTE) {
		mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
		if (mtag == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
		ip6_output(m0, NULL, NULL, 0, NULL, NULL);
		return;
	}

	if (TAILQ_EMPTY(&r->rpool.list))
		panic("pf_route6: TAILQ_EMPTY(&r->rpool.list)");
	if (s == NULL) {
		pf_map_addr(AF_INET6, r, (struct pf_addr *)&ip6->ip6_src,
		    &naddr, NULL, &sn);
		if (!PF_AZERO(&naddr, AF_INET6))
			PF_ACPY((struct pf_addr *)&dst->sin6_addr,
			    &naddr, AF_INET6);
		ifp = r->rpool.cur->kif ? r->rpool.cur->kif->pfik_ifp : NULL;
	} else {
		if (!PF_AZERO(&s->rt_addr, AF_INET6))
			PF_ACPY((struct pf_addr *)&dst->sin6_addr,
			    &s->rt_addr, AF_INET6);
		ifp = s->rt_kif ? s->rt_kif->pfik_ifp : NULL;
	}
	if (ifp == NULL)
		goto bad;

	if (oifp != ifp) {
		if (pf_test6(PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip6_hdr))
			panic("pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
		ip6 = mtod(m0, struct ip6_hdr *);
	}

	/*
	 * If the packet is too large for the outgoing interface,
	 * send back an icmp6 error.
	 */
	if (IN6_IS_ADDR_LINKLOCAL(&dst->sin6_addr))
		dst->sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	if ((u_long)m0->m_pkthdr.len <= ifp->if_mtu) {
		error = nd6_output(ifp, ifp, m0, dst, NULL);
	} else {
		in6_ifstat_inc(ifp, ifs6_in_toobig);
		if (r->rt != PF_DUPTO)
			icmp6_error(m0, ICMP6_PACKET_TOO_BIG, 0, ifp->if_mtu);
		else
			goto bad;
	}

done:
	if (r->rt != PF_DUPTO)
		*m = NULL;
	return;

bad:
	m_freem(m0);
	goto done;
}
#endif /* INET6 */


/*
 * check protocol (tcp/udp/icmp/icmp6) checksum and set mbuf flag
 *   off is the offset where the protocol header starts
 *   len is the total length of protocol header plus payload
 * returns 0 when the checksum is valid, otherwise returns 1.
 */
int
pf_check_proto_cksum(struct mbuf *m, int off, int len, u_int8_t p,
    sa_family_t af)
{
	u_int16_t flag_ok, flag_bad;
	u_int16_t sum;

	switch (p) {
	case IPPROTO_TCP:
		flag_ok = M_TCP_CSUM_IN_OK;
		flag_bad = M_TCP_CSUM_IN_BAD;
		break;
	case IPPROTO_UDP:
		flag_ok = M_UDP_CSUM_IN_OK;
		flag_bad = M_UDP_CSUM_IN_BAD;
		break;
	case IPPROTO_ICMP:
#ifdef INET6
	case IPPROTO_ICMPV6:
#endif /* INET6 */
		flag_ok = flag_bad = 0;
		break;
	default:
		return (1);
	}
	if (m->m_pkthdr.csum & flag_ok)
		return (0);
	if (m->m_pkthdr.csum & flag_bad)
		return (1);
	if (off < sizeof(struct ip) || len < sizeof(struct udphdr))
		return (1);
	if (m->m_pkthdr.len < off + len)
		return (1);
		switch (af) {
#ifdef INET
	case AF_INET:
		if (p == IPPROTO_ICMP) {
			if (m->m_len < off)
				return (1);
			m->m_data += off;
			m->m_len -= off;
			sum = in_cksum(m, len);
			m->m_data -= off;
			m->m_len += off;
		} else {
			if (m->m_len < sizeof(struct ip))
				return (1);
			sum = in4_cksum(m, p, off, len);
		}
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (m->m_len < sizeof(struct ip6_hdr))
			return (1);
		sum = in6_cksum(m, p, off, len);
		break;
#endif /* INET6 */
	default:
		return (1);
	}
	if (sum) {
		m->m_pkthdr.csum |= flag_bad;
		switch (p) {
		case IPPROTO_TCP:
			tcpstat.tcps_rcvbadsum++;
			break;
		case IPPROTO_UDP:
			udpstat.udps_badsum++;
			break;
		case IPPROTO_ICMP:
			icmpstat.icps_checksum++;
			break;
#ifdef INET6
		case IPPROTO_ICMPV6:
			icmp6stat.icp6s_checksum++;
			break;
#endif /* INET6 */
		}
		return (1);
	}
	m->m_pkthdr.csum |= flag_ok;
	return (0);
}

static int
pf_add_mbuf_tag(struct mbuf *m, u_int tag)
{
	struct m_tag *mtag;

	if (m_tag_find(m, tag, NULL) != NULL)
		return (0);
	mtag = m_tag_get(tag, 0, M_NOWAIT);
	if (mtag == NULL)
		return (1);
	m_tag_prepend(m, mtag);
	return (0);
}

#ifdef INET
int
pf_test(int dir, struct ifnet *ifp, struct mbuf **m0)
{
	return pf_test_eh(dir, ifp, m0, NULL);
}

int
pf_test_eh(int dir, struct ifnet *ifp, struct mbuf **m0,
    struct ether_header *eh)
{
	struct pfi_kif		*kif;
	u_short			 action, reason = 0, log = 0;
	struct mbuf		*m = *m0;
	struct ip		*h;
	struct pf_rule		*a = NULL, *r = &pf_default_rule, *tr, *nr;
	struct pf_state		*s = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_pdesc		 pd;
	int			 off, dirndx, pqid = 0;

	if (!pf_status.running ||
	    (m_tag_find(m, PACKET_TAG_PF_GENERATED, NULL) != NULL))
		return (PF_PASS);

	kif = pfi_index2kif[ifp->if_index];
	if (kif == NULL)
		return (PF_DROP);

#ifdef DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("non-M_PKTHDR is passed to pf_test");
#endif /* DIAGNOSTIC */

	memset(&pd, 0, sizeof(pd));
	if (m->m_pkthdr.len < (int)sizeof(*h)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_SHORT);
		log = 1;
		goto done;
	}

	/* We do IP header normalization and packet reassembly here */
	if (pf_normalize_ip(m0, dir, kif, &reason, &pd) != PF_PASS) {
		action = PF_DROP;
		goto done;
	}
	m = *m0;
	h = mtod(m, struct ip *);

	off = h->ip_hl << 2;
	if (off < (int)sizeof(*h)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_SHORT);
		log = 1;
		goto done;
	}

	pd.src = (struct pf_addr *)&h->ip_src;
	pd.dst = (struct pf_addr *)&h->ip_dst;
	PF_ACPY(&pd.baddr, dir == PF_OUT ? pd.src : pd.dst, AF_INET);
	pd.ip_sum = &h->ip_sum;
	pd.proto = h->ip_p;
	pd.af = AF_INET;
	pd.tos = h->ip_tos;
	pd.tot_len = ntohs(h->ip_len);
	pd.eh = eh;

	/* handle fragments that didn't get reassembled by normalization */
	if (h->ip_off & htons(IP_MF | IP_OFFMASK)) {
		action = pf_test_fragment(&r, dir, kif, m, h,
		    &pd, &a, &ruleset);
		goto done;
	}

	switch (h->ip_p) {

	case IPPROTO_TCP: {
		struct tcphdr	th;

		pd.hdr.tcp = &th;
		if (!pf_pull_hdr(m, off, &th, sizeof(th),
		    &action, &reason, AF_INET)) {
			log = action != PF_PASS;
			goto done;
		}
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    ntohs(h->ip_len) - off, IPPROTO_TCP, AF_INET)) {
			action = PF_DROP;
			goto done;
		}
		pd.p_len = pd.tot_len - off - (th.th_off << 2);
		if ((th.th_flags & TH_ACK) && pd.p_len == 0)
			pqid = 1;
		action = pf_normalize_tcp(dir, kif, m, 0, off, h, &pd);
		if (action == PF_DROP)
			goto done;
		action = pf_test_state_tcp(&s, dir, kif, m, off, h, &pd,
		    &reason);
		if (action == PF_PASS) {
#if NPFSYNC
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_tcp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
		break;
	}

	case IPPROTO_UDP: {
		struct udphdr	uh;

		pd.hdr.udp = &uh;
		if (!pf_pull_hdr(m, off, &uh, sizeof(uh),
		    &action, &reason, AF_INET)) {
			log = action != PF_PASS;
			goto done;
		}
		if (dir == PF_IN && uh.uh_sum && pf_check_proto_cksum(m,
		    off, ntohs(h->ip_len) - off, IPPROTO_UDP, AF_INET)) {
			action = PF_DROP;
			goto done;
		}
		if (uh.uh_dport == 0 ||
		    ntohs(uh.uh_ulen) > m->m_pkthdr.len - off ||
		    ntohs(uh.uh_ulen) < sizeof(struct udphdr)) {
			action = PF_DROP;
			goto done;
		}
		action = pf_test_state_udp(&s, dir, kif, m, off, h, &pd);
		if (action == PF_PASS) {
#if NPFSYNC
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_udp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
		break;
	}

	case IPPROTO_ICMP: {
		struct icmp	ih;

		pd.hdr.icmp = &ih;
		if (!pf_pull_hdr(m, off, &ih, ICMP_MINLEN,
		    &action, &reason, AF_INET)) {
			log = action != PF_PASS;
			goto done;
		}
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    ntohs(h->ip_len) - off, IPPROTO_ICMP, AF_INET)) {
			action = PF_DROP;
			goto done;
		}
		action = pf_test_state_icmp(&s, dir, kif, m, off, h, &pd);
		if (action == PF_PASS) {
#if NPFSYNC
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_icmp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
		break;
	}

	default:
		action = pf_test_state_other(&s, dir, kif, &pd);
		if (action == PF_PASS) {
#if NPFSYNC
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_other(&r, &s, dir, kif, m, off, h,
			    &pd, &a, &ruleset, &ipintrq);
		break;
	}

done:
	if (action == PF_PASS && h->ip_hl > 5 &&
	    !((s && s->allow_opts) || r->allow_opts)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_SHORT);
		log = 1;
		DPFPRINTF(PF_DEBUG_MISC,
		    ("pf: dropping packet with ip options\n"));
	}

#ifdef ALTQ
	if (action == PF_PASS && r->qid) {
		struct m_tag	*mtag;
		struct altq_tag	*atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			if (pqid || pd.tos == IPTOS_LOWDELAY)
				atag->qid = r->pqid;
			else
				atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = AF_INET;
			atag->hdr = h;
			m_tag_prepend(m, mtag);
		}
	}
#endif /* ALTQ */

	/*
	 * connections redirected to loopback should not match sockets
	 * bound specifically to loopback due to security implications,
	 * see tcp_input() and in_pcblookup_listen().
	 */
	if (dir == PF_IN && action == PF_PASS && (pd.proto == IPPROTO_TCP ||
	    pd.proto == IPPROTO_UDP) && s != NULL && s->nat_rule.ptr != NULL &&
	    (s->nat_rule.ptr->action == PF_RDR ||
	    s->nat_rule.ptr->action == PF_BINAT) &&
	    (ntohl(pd.dst->v4.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET &&
	    pf_add_mbuf_tag(m, PACKET_TAG_PF_TRANSLATE_LOCALHOST)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_MEMORY);
	}

	if (log)
		PFLOG_PACKET(kif, h, m, AF_INET, dir, reason, r, a, ruleset);

	kif->pfik_bytes[0][dir == PF_OUT][action != PF_PASS] += pd.tot_len;
	kif->pfik_packets[0][dir == PF_OUT][action != PF_PASS]++;

	if (action == PF_PASS || r->action == PF_DROP) {
		r->packets++;
		r->bytes += pd.tot_len;
		if (a != NULL) {
			a->packets++;
			a->bytes += pd.tot_len;
		}
		if (s != NULL) {
			dirndx = (dir == s->direction) ? 0 : 1;
			s->packets[dirndx]++;
			s->bytes[dirndx] += pd.tot_len;
			if (s->nat_rule.ptr != NULL) {
				s->nat_rule.ptr->packets++;
				s->nat_rule.ptr->bytes += pd.tot_len;
			}
			if (s->src_node != NULL) {
				s->src_node->packets++;
				s->src_node->bytes += pd.tot_len;
			}
			if (s->nat_src_node != NULL) {
				s->nat_src_node->packets++;
				s->nat_src_node->bytes += pd.tot_len;
			}
		}
		tr = r;
		nr = (s != NULL) ? s->nat_rule.ptr : pd.nat_rule;
		if (nr != NULL) {
			struct pf_addr *x;
			/*
			 * XXX: we need to make sure that the addresses
			 * passed to pfr_update_stats() are the same than
			 * the addresses used during matching (pfr_match)
			 */
			if (r == &pf_default_rule) {
				tr = nr;
				x = (s == NULL || s->direction == dir) ?
				    &pd.baddr : &pd.naddr;
			} else
				x = (s == NULL || s->direction == dir) ?
				    &pd.naddr : &pd.baddr;
			if (x == &pd.baddr || s == NULL) {
				/* we need to change the address */
				if (dir == PF_OUT)
					pd.src = x;
				else
					pd.dst = x;
			}
		}
		if (tr->src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->src.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.src : pd.dst, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->src.not);
		if (tr->dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->dst.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.dst : pd.src, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->dst.not);
	}


	if (action == PF_SYNPROXY_DROP) {
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} else if (r->rt)
		/* pf_route can free the mbuf causing *m0 to become NULL */
		pf_route(m0, r, dir, ifp, s);

	return (action);
}
#endif /* INET */

#ifdef INET6
int
pf_test6(int dir, struct ifnet *ifp, struct mbuf **m0)
{
	return pf_test6_eh(dir, ifp, m0, NULL);
}

int
pf_test6_eh(int dir, struct ifnet *ifp, struct mbuf **m0,
    struct ether_header *eh)
{
	struct pfi_kif		*kif;
	u_short			 action, reason = 0, log = 0;
	struct mbuf		*m = *m0;
	struct ip6_hdr		*h;
	struct pf_rule		*a = NULL, *r = &pf_default_rule, *tr, *nr;
	struct pf_state		*s = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_pdesc		 pd;
	int			 off, terminal = 0, dirndx;

	if (!pf_status.running ||
	    (m_tag_find(m, PACKET_TAG_PF_GENERATED, NULL) != NULL))
		return (PF_PASS);

	kif = pfi_index2kif[ifp->if_index];
	if (kif == NULL)
		return (PF_DROP);

#ifdef DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("non-M_PKTHDR is passed to pf_test");
#endif /* DIAGNOSTIC */

	memset(&pd, 0, sizeof(pd));
	if (m->m_pkthdr.len < (int)sizeof(*h)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_SHORT);
		log = 1;
		goto done;
	}

	/* We do IP header normalization and packet reassembly here */
	if (pf_normalize_ip6(m0, dir, kif, &reason, &pd) != PF_PASS) {
		action = PF_DROP;
		goto done;
	}
	m = *m0;
	h = mtod(m, struct ip6_hdr *);

	pd.src = (struct pf_addr *)&h->ip6_src;
	pd.dst = (struct pf_addr *)&h->ip6_dst;
	PF_ACPY(&pd.baddr, dir == PF_OUT ? pd.src : pd.dst, AF_INET6);
	pd.ip_sum = NULL;
	pd.af = AF_INET6;
	pd.tos = 0;
	pd.tot_len = ntohs(h->ip6_plen) + sizeof(struct ip6_hdr);
	pd.eh = eh;

	off = ((caddr_t)h - m->m_data) + sizeof(struct ip6_hdr);
	pd.proto = h->ip6_nxt;
	do {
		switch (pd.proto) {
		case IPPROTO_FRAGMENT:
			action = pf_test_fragment(&r, dir, kif, m, h,
			    &pd, &a, &ruleset);
			if (action == PF_DROP)
				REASON_SET(&reason, PFRES_FRAG);
			goto done;
		case IPPROTO_AH:
		case IPPROTO_HOPOPTS:
		case IPPROTO_ROUTING:
		case IPPROTO_DSTOPTS: {
			/* get next header and header length */
			struct ip6_ext	opt6;

			if (!pf_pull_hdr(m, off, &opt6, sizeof(opt6),
			    NULL, NULL, pd.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: IPv6 short opt\n"));
				action = PF_DROP;
				REASON_SET(&reason, PFRES_SHORT);
				log = 1;
				goto done;
			}
			if (pd.proto == IPPROTO_AH)
				off += (opt6.ip6e_len + 2) * 4;
			else
				off += (opt6.ip6e_len + 1) * 8;
			pd.proto = opt6.ip6e_nxt;
			/* goto the next header */
			break;
		}
		default:
			terminal++;
			break;
		}
	} while (!terminal);

	switch (pd.proto) {

	case IPPROTO_TCP: {
		struct tcphdr	th;

		pd.hdr.tcp = &th;
		if (!pf_pull_hdr(m, off, &th, sizeof(th),
		    &action, &reason, AF_INET6)) {
			log = action != PF_PASS;
			goto done;
		}
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    ntohs(h->ip6_plen), IPPROTO_TCP, AF_INET6)) {
			action = PF_DROP;
			goto done;
		}
		pd.p_len = pd.tot_len - off - (th.th_off << 2);
		action = pf_normalize_tcp(dir, kif, m, 0, off, h, &pd);
		if (action == PF_DROP)
			goto done;
		action = pf_test_state_tcp(&s, dir, kif, m, off, h, &pd,
		    &reason);
		if (action == PF_PASS) {
#if NPFSYNC
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_tcp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
		break;
	}

	case IPPROTO_UDP: {
		struct udphdr	uh;

		pd.hdr.udp = &uh;
		if (!pf_pull_hdr(m, off, &uh, sizeof(uh),
		    &action, &reason, AF_INET6)) {
			log = action != PF_PASS;
			goto done;
		}
		if (dir == PF_IN && uh.uh_sum && pf_check_proto_cksum(m,
		    off, ntohs(h->ip6_plen), IPPROTO_UDP, AF_INET6)) {
			action = PF_DROP;
			goto done;
		}
		if (uh.uh_dport == 0 ||
		    ntohs(uh.uh_ulen) > m->m_pkthdr.len - off ||
		    ntohs(uh.uh_ulen) < sizeof(struct udphdr)) {
			action = PF_DROP;
			goto done;
		}
		action = pf_test_state_udp(&s, dir, kif, m, off, h, &pd);
		if (action == PF_PASS) {
#if NPFSYNC
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_udp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
		break;
	}

	case IPPROTO_ICMPV6: {
		struct icmp6_hdr	ih;

		pd.hdr.icmp6 = &ih;
		if (!pf_pull_hdr(m, off, &ih, sizeof(ih),
		    &action, &reason, AF_INET6)) {
			log = action != PF_PASS;
			goto done;
		}
		if (dir == PF_IN && pf_check_proto_cksum(m, off,
		    ntohs(h->ip6_plen), IPPROTO_ICMPV6, AF_INET6)) {
			action = PF_DROP;
			goto done;
		}
		action = pf_test_state_icmp(&s, dir, kif,
		    m, off, h, &pd);
		if (action == PF_PASS) {
#if NPFSYNC
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_icmp(&r, &s, dir, kif,
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
		break;
	}

	default:
		action = pf_test_state_other(&s, dir, kif, &pd);
		if (action == PF_PASS) {
#if NPFSYNC
			pfsync_update_state(s);
#endif /* NPFSYNC */
			r = s->rule.ptr;
			a = s->anchor.ptr;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_other(&r, &s, dir, kif, m, off, h,
			    &pd, &a, &ruleset, &ip6intrq);
		break;
	}

done:
	/* XXX handle IPv6 options, if not allowed. not implemented. */

#ifdef ALTQ
	if (action == PF_PASS && r->qid) {
		struct m_tag	*mtag;
		struct altq_tag	*atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			if (pd.tos == IPTOS_LOWDELAY)
				atag->qid = r->pqid;
			else
				atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = AF_INET6;
			atag->hdr = h;
			m_tag_prepend(m, mtag);
		}
	}
#endif /* ALTQ */

	if (dir == PF_IN && action == PF_PASS && (pd.proto == IPPROTO_TCP ||
	    pd.proto == IPPROTO_UDP) && s != NULL && s->nat_rule.ptr != NULL &&
	    (s->nat_rule.ptr->action == PF_RDR ||
	    s->nat_rule.ptr->action == PF_BINAT) &&
	    IN6_IS_ADDR_LOOPBACK(&pd.dst->v6) &&
	    pf_add_mbuf_tag(m, PACKET_TAG_PF_TRANSLATE_LOCALHOST)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_MEMORY);
	}

	if (log)
		PFLOG_PACKET(kif, h, m, AF_INET6, dir, reason, r, a, ruleset);

	kif->pfik_bytes[1][dir == PF_OUT][action != PF_PASS] += pd.tot_len;
	kif->pfik_packets[1][dir == PF_OUT][action != PF_PASS]++;

	if (action == PF_PASS || r->action == PF_DROP) {
		r->packets++;
		r->bytes += pd.tot_len;
		if (a != NULL) {
			a->packets++;
			a->bytes += pd.tot_len;
		}
		if (s != NULL) {
			dirndx = (dir == s->direction) ? 0 : 1;
			s->packets[dirndx]++;
			s->bytes[dirndx] += pd.tot_len;
			if (s->nat_rule.ptr != NULL) {
				s->nat_rule.ptr->packets++;
				s->nat_rule.ptr->bytes += pd.tot_len;
			}
			if (s->src_node != NULL) {
				s->src_node->packets++;
				s->src_node->bytes += pd.tot_len;
			}
			if (s->nat_src_node != NULL) {
				s->nat_src_node->packets++;
				s->nat_src_node->bytes += pd.tot_len;
			}
		}
		tr = r;
		nr = (s != NULL) ? s->nat_rule.ptr : pd.nat_rule;
		if (nr != NULL) {
			struct pf_addr *x;
			/*
			 * XXX: we need to make sure that the addresses
			 * passed to pfr_update_stats() are the same than
			 * the addresses used during matching (pfr_match)
			 */
			if (r == &pf_default_rule) {
				tr = nr;
				x = (s == NULL || s->direction == dir) ?
				    &pd.baddr : &pd.naddr;
			} else {
				x = (s == NULL || s->direction == dir) ?
				    &pd.naddr : &pd.baddr;
			}
			if (x == &pd.baddr || s == NULL) {
				if (dir == PF_OUT)
					pd.src = x;
				else
					pd.dst = x;
			}
		}
		if (tr->src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->src.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.src : pd.dst, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->src.not);
		if (tr->dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->dst.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.dst : pd.src, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->dst.not);
	}


	if (action == PF_SYNPROXY_DROP) {
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} else if (r->rt)
		/* pf_route6 can free the mbuf causing *m0 to become NULL */
		pf_route6(m0, r, dir, ifp, s);

	return (action);
}
#endif /* INET6 */

int
pf_check_congestion(struct ifqueue *ifq)
{
	if (ifq->ifq_congestion)
		return (1);
	else
		return (0);
}
@


1.6
log
@merge last cvs import conflicts

TODO:
 - sync the various files
 - make a kernel that can build the new W^X
   (i.e. temporarily disable the old W^X)
 - build new kernel, binutils, ld.so, userland
 - import new flag day change
 - build new binutils, ld.so, userland, kernel

includes:
CVSROOT:        /cvs
Module name:    src
Changes by:     drahn@@cvs.openbsd.org   2003/04/28 15:32:08

Modified files:
        lib/libc/sys   : mquery.c
        libexec/ld.so  : library_mquery.c
        libexec/ld.so/i386: archdep.h
        sys/kern       : syscalls.master
        sys/sys        : mman.h
        sys/uvm        : uvm_mmap.c

Log message:
Change mquery() function call signature to be the same a mmap(). It
needs the prot/flags info and passing the addresses via arg/return allows
it to be traced via ktrace better than an in/out paramter.
This adds a new mquery syscall and renames the old one to omquery.
New kernel _MUST_ be built, booted, and 'make includes' before building
ld.so with this change.
@
text
@d1 2
a2 1
/*	$OpenBSD: pf.c,v 1.339 2003/04/30 12:30:27 cedric Exp $ */
d6 1
a63 1
#include <netinet/tcp_fsm.h>
d72 1
d77 2
d80 1
d86 1
a88 4
#ifdef ALTQ
#include <altq/if_altq.h>
#endif

a90 1
struct pf_state_tree;
a102 1
struct ifnet		*status_ifp;
d106 1
d111 1
a111 1
struct pool		 pf_tree_pl, pf_rule_pl, pf_addr_pl;
a113 8
void			 pf_addrcpy(struct pf_addr *, struct pf_addr *,
			    sa_family_t);
int			 pf_insert_state(struct pf_state *);
struct pf_state		*pf_find_state(struct pf_state_tree *,
			    struct pf_tree_node *);
void			 pf_purge_expired_states(void);
void			 pf_purge_timeout(void *);
void			 pf_dynaddr_update(void *);
a114 2
void			 pf_print_state(struct pf_state *);
void			 pf_print_flags(u_int8_t);
a115 2
u_int16_t		 pf_cksum_fixup(u_int16_t, u_int16_t, u_int16_t,
			    u_int8_t);
a118 2
void			 pf_change_a(u_int32_t *, u_int16_t *, u_int32_t,
			    u_int8_t);
d127 5
a131 3
void			 pf_send_reset(int, struct tcphdr *,
			    struct pf_pdesc *, sa_family_t, u_int8_t,
			    struct pf_rule *);
d134 2
a135 1
struct pf_rule		*pf_match_translation(int, struct ifnet *, u_int8_t,
d137 3
a139 2
			    u_int16_t, sa_family_t, int);
struct pf_rule		*pf_get_translation(int, struct ifnet *, u_int8_t,
d142 9
a150 7
			    struct pf_addr *, u_int16_t *, sa_family_t);
int			 pf_test_tcp(struct pf_rule **, struct pf_state **, int,
			    struct ifnet *, struct mbuf *, int, int, void *,
			    struct pf_pdesc *, struct pf_rule **);
int			 pf_test_udp(struct pf_rule **, struct pf_state **, int,
			    struct ifnet *, struct mbuf *, int, int, void *,
			    struct pf_pdesc *, struct pf_rule **);
d152 3
a154 2
			    int, struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *, struct pf_rule **);
d156 3
a158 2
			    int, struct ifnet *, struct mbuf *, void *,
			    struct pf_pdesc *, struct pf_rule **);
d160 3
a162 2
			    struct ifnet *, struct mbuf *, void *,
			    struct pf_pdesc *, struct pf_rule **);
d164 2
a165 2
			    struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *);
d167 1
a167 1
			    struct ifnet *, struct mbuf *, int, int,
d170 1
a170 1
			    struct ifnet *, struct mbuf *, int, int,
d173 4
a176 13
			    struct ifnet *, struct pf_pdesc *);
void			*pf_pull_hdr(struct mbuf *, int, void *, int,
			    u_short *, u_short *, sa_family_t);
void			 pf_calc_skip_steps(struct pf_rulequeue *);
void			 pf_rule_set_qid(struct pf_rulequeue *);
u_int32_t		 pf_qname_to_qid(char *);

#ifdef INET6
void			 pf_poolmask(struct pf_addr *, struct pf_addr*,
			    struct pf_addr *, struct pf_addr *, u_int8_t);
void			 pf_addr_inc(struct pf_addr *, sa_family_t);
#endif /* INET6 */

d179 1
a179 1
int			 pf_map_addr(u_int8_t, struct pf_pool *,
d181 2
a182 2
			    struct pf_addr *);
int			 pf_get_sport(sa_family_t, u_int8_t, struct pf_pool *,
d184 2
a185 3
			    struct pf_addr *, u_int16_t*, u_int16_t, u_int16_t);
int			 pf_normalize_tcp(int, struct ifnet *, struct mbuf *,
			    int, int, void *, struct pf_pdesc *);
d190 1
a190 1
int			 pf_socket_lookup(uid_t *, gid_t *, int, sa_family_t,
d194 6
d202 12
a213 3

struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] =
    { { &pf_state_pl, PFSTATE_HIWAT }, { &pf_frent_pl, PFFRAG_FRENT_HIWAT } };
d218 2
a219 1
			*state = pf_find_state(&tree_ext_gwy, &key);	\
d221 2
a222 1
			*state = pf_find_state(&tree_lan_ext, &key);	\
d230 2
a231 2
		    (*state)->rt_ifp != NULL &&				\
		    (*state)->rt_ifp != ifp)				\
d243 24
a266 2
#define TIMEOUT(r,i) \
	((r)->timeout[(i)] ? (r)->timeout[(i)] : pf_default_rule.timeout[(i)])
d268 4
a271 2
static __inline int pf_state_compare(struct pf_tree_node *,
			struct pf_tree_node *);
d273 38
a310 2
struct pf_state_tree tree_lan_ext, tree_ext_gwy;
RB_GENERATE(pf_state_tree, pf_tree_node, entry, pf_state_compare);
d313 1
a313 1
pf_state_compare(struct pf_tree_node *a, struct pf_tree_node *b)
d324 1
a324 1
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
d326 1
a326 1
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
d328 1
a328 1
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
d330 1
a330 1
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
d336 1
a336 1
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
d338 1
a338 1
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
d340 1
a340 1
		if (a->addr[0].addr32[1] > b->addr[0].addr32[1])
d342 1
a342 1
		if (a->addr[0].addr32[1] < b->addr[0].addr32[1])
d344 1
a344 1
		if (a->addr[0].addr32[2] > b->addr[0].addr32[2])
d346 1
a346 1
		if (a->addr[0].addr32[2] < b->addr[0].addr32[2])
d348 1
a348 1
		if (a->addr[0].addr32[3] > b->addr[0].addr32[3])
d350 1
a350 1
		if (a->addr[0].addr32[3] < b->addr[0].addr32[3])
d352 1
a352 1
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
d354 1
a354 1
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
d356 1
a356 1
		if (a->addr[1].addr32[1] > b->addr[1].addr32[1])
d358 1
a358 1
		if (a->addr[1].addr32[1] < b->addr[1].addr32[1])
d360 1
a360 1
		if (a->addr[1].addr32[2] > b->addr[1].addr32[2])
d362 1
a362 1
		if (a->addr[1].addr32[2] < b->addr[1].addr32[2])
d364 1
a364 1
		if (a->addr[1].addr32[3] > b->addr[1].addr32[3])
d366 1
a366 1
		if (a->addr[1].addr32[3] < b->addr[1].addr32[3])
d372 1
a372 1
	if ((diff = a->port[0] - b->port[0]) != 0)
d374 1
a374 1
	if ((diff = a->port[1] - b->port[1]) != 0)
d380 83
d481 8
a488 1
#endif
d491 1
a491 1
pf_find_state(struct pf_state_tree *tree, struct pf_tree_node *key)
d493 1
a493 1
	struct pf_tree_node	*k;
d496 17
a512 4
	k = RB_FIND(pf_state_tree, tree, key);
	if (k)
		return (k->state);
	else
d514 41
d558 2
a559 1
pf_insert_state(struct pf_state *state)
d561 1
a561 1
	struct pf_tree_node	*keya, *keyb;
d563 48
a610 10
	keya = pool_get(&pf_tree_pl, PR_NOWAIT);
	if (keya == NULL)
		return (-1);
	keya->state = state;
	keya->proto = state->proto;
	keya->af = state->af;
	PF_ACPY(&keya->addr[0], &state->lan.addr, state->af);
	keya->port[0] = state->lan.port;
	PF_ACPY(&keya->addr[1], &state->ext.addr, state->af);
	keya->port[1] = state->ext.port;
d612 3
d616 2
a617 1
	if (RB_INSERT(pf_state_tree, &tree_lan_ext, keya) != NULL) {
d629 2
a632 9
		pool_put(&pf_tree_pl, keya);
		return (-1);
	}

	keyb = pool_get(&pf_tree_pl, PR_NOWAIT);
	if (keyb == NULL) {
		/* Need to pull out the other state */
		RB_REMOVE(pf_state_tree, &tree_lan_ext, keya);
		pool_put(&pf_tree_pl, keya);
a634 7
	keyb->state = state;
	keyb->proto = state->proto;
	keyb->af = state->af;
	PF_ACPY(&keyb->addr[0], &state->ext.addr, state->af);
	keyb->port[0] = state->ext.port;
	PF_ACPY(&keyb->addr[1], &state->gwy.addr, state->af);
	keyb->port[1] = state->gwy.port;
d636 1
a636 1
	if (RB_INSERT(pf_state_tree, &tree_ext_gwy, keyb) != NULL) {
d648 19
d669 2
a670 3
		RB_REMOVE(pf_state_tree, &tree_lan_ext, keya);
		pool_put(&pf_tree_pl, keya);
		pool_put(&pf_tree_pl, keyb);
d673 1
d677 1
d693 1
d699 36
d736 1
a736 1
pf_purge_expired_states(void)
d738 1
a738 2
	struct pf_tree_node	*cur, *peer, *next;
	struct pf_tree_node	 key;
d740 2
a741 2
	for (cur = RB_MIN(pf_state_tree, &tree_ext_gwy); cur; cur = next) {
		next = RB_NEXT(pf_state_tree, &tree_ext_gwy, cur);
d743 19
a761 2
		if (cur->state->expire <= (unsigned)time.tv_sec) {
			RB_REMOVE(pf_state_tree, &tree_ext_gwy, cur);
d763 20
a782 15
			/* Need this key's peer (in the other tree) */
			key.state = cur->state;
			key.proto = cur->state->proto;
			key.af = cur->state->af;
			PF_ACPY(&key.addr[0], &cur->state->lan.addr,
			    cur->state->af);
			key.port[0] = cur->state->lan.port;
			PF_ACPY(&key.addr[1], &cur->state->ext.addr,
			    cur->state->af);
			key.port[1] = cur->state->ext.port;

			peer = RB_FIND(pf_state_tree, &tree_lan_ext, &key);
			KASSERT(peer);
			KASSERT(peer->state == cur->state);
			RB_REMOVE(pf_state_tree, &tree_lan_ext, peer);
d784 14
d799 1
a799 1
			pfsync_delete_state(cur->state);
d801 29
a829 16
			if (--cur->state->rule.ptr->states <= 0)
				pf_rm_rule(NULL, cur->state->rule.ptr);
			if (cur->state->nat_rule.ptr != NULL)
				if (--cur->state->nat_rule.ptr->states <= 0)
					pf_rm_rule(NULL,
					    cur->state->nat_rule.ptr);
			if (cur->state->anchor.ptr != NULL)
				if (--cur->state->anchor.ptr->states <= 0)
					pf_rm_rule(NULL,
					    cur->state->anchor.ptr);
			pool_put(&pf_state_pl, cur->state);
			pool_put(&pf_tree_pl, cur);
			pool_put(&pf_tree_pl, peer);
			pf_status.fcounters[FCNT_STATE_REMOVALS]++;
			pf_status.states--;
		}
d855 1
a855 5
	if (aw->type != PF_ADDR_TABLE || aw->p.tbl == NULL)
		return;
	aw->p.tblcnt = (aw->p.tbl->pfrkt_flags & PFR_TFLAG_ACTIVE) ?
		aw->p.tbl->pfrkt_cnt : -1;
}
d857 1
a857 79
int
pf_dynaddr_setup(struct pf_addr_wrap *aw, sa_family_t af)
{
	if (aw->type != PF_ADDR_DYNIFTL)
		return (0);
	aw->p.dyn = pool_get(&pf_addr_pl, PR_NOWAIT);
	if (aw->p.dyn == NULL)
		return (1);
	bcopy(aw->v.ifname, aw->p.dyn->ifname, sizeof(aw->p.dyn->ifname));
	aw->p.dyn->ifp = ifunit(aw->p.dyn->ifname);
	if (aw->p.dyn->ifp == NULL) {
		pool_put(&pf_addr_pl, aw->p.dyn);
		aw->p.dyn = NULL;
		return (1);
	}
	aw->p.dyn->addr = &aw->v.a.addr;
	aw->p.dyn->af = af;
	aw->p.dyn->undefined = 1;
	aw->p.dyn->hook_cookie = hook_establish(
	    aw->p.dyn->ifp->if_addrhooks, 1,
	    pf_dynaddr_update, aw->p.dyn);
	if (aw->p.dyn->hook_cookie == NULL) {
		pool_put(&pf_addr_pl, aw->p.dyn);
		aw->p.dyn = NULL;
		return (1);
	}
	pf_dynaddr_update(aw->p.dyn);
	return (0);
}

void
pf_dynaddr_update(void *p)
{
	struct pf_addr_dyn	*ad = (struct pf_addr_dyn *)p;
	struct ifaddr		*ia;
	int			 s, changed = 0;

	if (ad == NULL || ad->ifp == NULL)
		panic("pf_dynaddr_update");
	s = splsoftnet();
	TAILQ_FOREACH(ia, &ad->ifp->if_addrlist, ifa_list)
		if (ia->ifa_addr != NULL &&
		    ia->ifa_addr->sa_family == ad->af) {
			if (ad->af == AF_INET) {
				struct in_addr *a, *b;

				a = &ad->addr->v4;
				b = &((struct sockaddr_in *)ia->ifa_addr)
				    ->sin_addr;
				if (ad->undefined ||
				    memcmp(a, b, sizeof(*a))) {
					bcopy(b, a, sizeof(*a));
					changed = 1;
				}
			} else if (ad->af == AF_INET6) {
				struct in6_addr *a, *b;

				a = &ad->addr->v6;
				b = &((struct sockaddr_in6 *)ia->ifa_addr)
				    ->sin6_addr;
				if (ad->undefined ||
				    memcmp(a, b, sizeof(*a))) {
					bcopy(b, a, sizeof(*a));
					changed = 1;
				}
			}
			if (changed)
				ad->undefined = 0;
			break;
		}
	if (ia == NULL)
		ad->undefined = 1;
	splx(s);
}

void
pf_dynaddr_remove(struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL)
d859 5
a863 13
	hook_disestablish(aw->p.dyn->ifp->if_addrhooks,
	    aw->p.dyn->hook_cookie);
	pool_put(&pf_addr_pl, aw->p.dyn);
	aw->p.dyn = NULL;
}

void
pf_dynaddr_copyout(struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL)
		return;
	bcopy(aw->p.dyn->ifname, aw->v.ifname, sizeof(aw->v.ifname));
	aw->p.dyn = (struct pf_addr_dyn *)1;
d1011 1
a1011 1
		if (cur->ifp != prev->ifp || cur->ifnot != prev->ifnot)
d1019 2
a1020 11
		if (cur->src.addr.type == PF_ADDR_DYNIFTL ||
		    prev->src.addr.type == PF_ADDR_DYNIFTL ||
		    cur->src.addr.type == PF_ADDR_TABLE ||
		    prev->src.addr.type == PF_ADDR_TABLE ||
		    cur->src.not != prev->src.not ||
		    (cur->src.addr.type == PF_ADDR_NOROUTE) !=
		    (prev->src.addr.type == PF_ADDR_NOROUTE) ||
		    !PF_AEQ(&cur->src.addr.v.a.addr,
		    &prev->src.addr.v.a.addr, 0) ||
		    !PF_AEQ(&cur->src.addr.v.a.mask,
		    &prev->src.addr.v.a.mask, 0))
d1026 2
a1027 11
		if (cur->dst.addr.type == PF_ADDR_DYNIFTL ||
		    prev->dst.addr.type == PF_ADDR_DYNIFTL ||
		    cur->dst.addr.type == PF_ADDR_TABLE ||
		    prev->dst.addr.type == PF_ADDR_TABLE ||
		    cur->dst.not != prev->dst.not ||
		    (cur->dst.addr.type == PF_ADDR_NOROUTE) !=
		    (prev->dst.addr.type == PF_ADDR_NOROUTE) ||
		    !PF_AEQ(&cur->dst.addr.v.a.addr,
		    &prev->dst.addr.v.a.addr, 0) ||
		    !PF_AEQ(&cur->dst.addr.v.a.mask,
		    &prev->dst.addr.v.a.mask, 0))
d1041 2
a1042 2
void
pf_rule_set_qid(struct pf_rulequeue *rules)
d1044 17
a1060 37
	struct pf_rule *rule;

	TAILQ_FOREACH(rule, rules, entries)
		if (rule->qname[0] != 0) {
			rule->qid = pf_qname_to_qid(rule->qname);
			if (rule->pqname[0] != 0)
				rule->pqid = pf_qname_to_qid(rule->pqname);
			else
				rule->pqid = rule->qid;
		}
}

u_int32_t
pf_qname_to_qid(char *qname)
{
	struct pf_altq		*altq;

	TAILQ_FOREACH(altq, pf_altqs_active, entries)
		if (!strcmp(altq->qname, qname))
			return (altq->qid);

	return (0);
}

void
pf_update_anchor_rules()
{
	struct pf_rule	*rule;
	int		 i;

	for (i = 0; i < PF_RULESET_MAX; ++i)
		TAILQ_FOREACH(rule, pf_main_ruleset.rules[i].active.ptr,
		    entries)
			if (rule->anchorname[0])
				rule->anchor = pf_find_anchor(rule->anchorname);
			else
				rule->anchor = NULL;
d1122 2
d1125 1
a1125 1
pf_change_a(u_int32_t *a, u_int16_t *c, u_int32_t an, u_int8_t u)
d1127 1
a1127 1
	u_int32_t	ao = *a;
d1129 2
a1130 1
	*a = an;
a1163 2
	u_int32_t	opc;
	u_int16_t	oip = *ip;
a1164 1
	opc = 0U;
a1167 2
	if (pc != NULL)
		opc = *pc;
d1169 14
a1182 6
	*ip = np;
	if (pc != NULL)
		*pc = pf_cksum_fixup(*pc, oip, *ip, u);
	*ic = pf_cksum_fixup(*ic, oip, *ip, 0);
	if (pc != NULL)
		*ic = pf_cksum_fixup(*ic, opc, *pc, 0);
a1183 1
	/* Change inner ip address, fix inner ipv4 and icmp checksums. */
d1215 1
a1215 1
	/* Change outer ip address, fix outer ipv4 or icmpv6 checksum. */
d1244 5
a1248 2
pf_send_reset(int off, struct tcphdr *th, struct pf_pdesc *pd, sa_family_t af,
    u_int8_t return_ttl, struct pf_rule *r)
d1251 1
a1251 2
	struct m_tag	*mtag;
	int		 len;
d1253 1
a1253 1
	struct ip	*h2 = NULL;
d1256 1
a1256 1
	struct ip6_hdr	*h2_6 = NULL;
d1258 7
a1264 1
	struct tcphdr	*th2 = NULL;
d1269 1
a1269 1
		len = sizeof(struct ip) + sizeof(struct tcphdr);
d1274 1
a1274 1
		len = sizeof(struct ip6_hdr) + sizeof(struct tcphdr);
a1276 2
	default:
		printf("panic: trying to send RST to an unhandled address family\n");
a1278 4
	/* don't reply to RST packets */
	if (th->th_flags & TH_RST)
		return;

a1279 3
	mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
	if (mtag == NULL)
		return;
d1281 1
a1281 2
	if (m == NULL) {
		m_tag_free(mtag);
d1283 24
d1308 1
a1308 1
	m_tag_prepend(m, mtag);
d1316 1
a1316 1
		h2 = mtod(m, struct ip *);
d1319 4
a1322 4
		h2->ip_p = IPPROTO_TCP;
		h2->ip_len = htons(sizeof(*th2));
		h2->ip_src.s_addr = pd->dst->v4.s_addr;
		h2->ip_dst.s_addr = pd->src->v4.s_addr;
d1324 1
a1324 1
		th2 = (struct tcphdr *)((caddr_t)h2 + sizeof(struct ip));
d1329 1
a1329 1
		h2_6 = mtod(m, struct ip6_hdr *);
d1332 4
a1335 4
		h2_6->ip6_nxt = IPPROTO_TCP;
		h2_6->ip6_plen = htons(sizeof(*th2));
		memcpy(&h2_6->ip6_src, pd->dst, sizeof(struct in6_addr));
		memcpy(&h2_6->ip6_dst, pd->src, sizeof(struct in6_addr));
d1337 1
a1337 1
		th2 = (struct tcphdr *)((caddr_t)h2_6 + sizeof(struct ip6_hdr));
d1343 14
a1356 29
	th2->th_sport = th->th_dport;
	th2->th_dport = th->th_sport;
	if (th->th_flags & TH_ACK) {
		th2->th_seq = th->th_ack;
		th2->th_flags = TH_RST;
	} else {
		int tlen = pd->p_len;
		if (th->th_flags & TH_SYN)
			tlen++;
		if (th->th_flags & TH_FIN)
			tlen++;
		th2->th_ack = htonl(ntohl(th->th_seq) + tlen);
		th2->th_flags = TH_RST | TH_ACK;
	}
	th2->th_off = sizeof(*th2) >> 2;

#ifdef ALTQ
	if (r->qid) {
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m, struct ip *);
			m_tag_prepend(m, mtag);
		}
a1357 1
#endif
d1363 1
a1363 1
		th2->th_sum = in_cksum(m, len);
d1366 29
a1394 10
		h2->ip_v = 4;
		h2->ip_hl = sizeof(*h2) >> 2;
		if (!return_ttl)
			return_ttl = ip_defttl;
		h2->ip_ttl = return_ttl;
		h2->ip_sum = 0;
		h2->ip_len = len;
		h2->ip_off = ip_mtudisc ? IP_DF : 0;
		ip_output(m, (void *)NULL, (void *)NULL, 0, (void *)NULL,
		    (void *)NULL);
d1400 2
a1401 2
		th2->th_sum = in6_cksum(m, IPPROTO_TCP,
		    sizeof(struct ip6_hdr), sizeof(*th));
d1403 2
a1404 4
		h2_6->ip6_vfc |= IPV6_VERSION;
		if (!return_ttl)
			return_ttl = IPV6_DEFHLIM;
		h2_6->ip6_hlim = return_ttl;
d1407 1
d1443 1
a1443 1
#endif
d1448 1
a1448 1
		icmp_error(m0, type, code, 0, 0);
d1506 1
a1506 1
pf_match(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
d1556 49
d1662 1
a1662 1
pf_addr_inc(struct pf_addr *addr, u_int8_t af)
d1750 34
a1783 7
int
pf_map_addr(u_int8_t af, struct pf_pool *rpool, struct pf_addr *saddr,
    struct pf_addr *naddr, struct pf_addr *init_addr)
{
	unsigned char		 hash[16];
	struct pf_addr		*raddr = &rpool->cur->addr.addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.addr.v.a.mask;
d1785 1
a1785 5
	if (rpool->cur->addr.addr.type == PF_ADDR_NOROUTE ||
	    rpool->cur->addr.addr.type == PF_ADDR_TABLE)
		return (1);
	if (rpool->cur->addr.addr.type == PF_ADDR_DYNIFTL &&
	    rpool->cur->addr.addr.p.dyn->undefined)
d1787 7
d1807 1
a1807 1
				rpool->counter.addr32[0] = arc4random();
d1813 2
a1814 1
					rpool->counter.addr32[3] = arc4random();
d1818 2
a1819 1
					rpool->counter.addr32[2] = arc4random();
d1823 2
a1824 1
					rpool->counter.addr32[1] = arc4random();
d1828 2
a1829 1
					rpool->counter.addr32[0] = arc4random();
d1846 21
a1866 4
		if (pf_match_addr(0, &rpool->cur->addr.addr.v.a.addr,
		    &rpool->cur->addr.addr.v.a.mask, &rpool->counter, af)) {
			PF_ACPY(naddr, &rpool->counter, af);
			PF_AINC(&rpool->counter, af);
d1868 3
a1870 7
			if ((rpool->cur =
			    TAILQ_NEXT(rpool->cur, entries)) == NULL)
				rpool->cur = TAILQ_FIRST(&rpool->list);
			PF_ACPY(naddr, &rpool->cur->addr.addr.v.a.addr, af);
			PF_ACPY(&rpool->counter,
			    &rpool->cur->addr.addr.v.a.addr, af);
			PF_AINC(&rpool->counter, af);
d1872 4
d1878 2
d1883 1
a1883 1
		printf("pf_map_addr: selected address: ");
d1892 1
a1892 1
pf_get_sport(sa_family_t af, u_int8_t proto, struct pf_pool *rpool,
d1894 2
a1895 1
    struct pf_addr *naddr, u_int16_t *nport, u_int16_t low, u_int16_t high)
d1897 1
a1897 1
	struct pf_tree_node	key;
d1902 1
a1902 1
	if (pf_map_addr(af, rpool, saddr, naddr, &init_addr))
d1908 3
a1910 3
		PF_ACPY(&key.addr[0], daddr, key.af);
		PF_ACPY(&key.addr[1], naddr, key.af);
		key.port[0] = dport;
d1917 2
a1918 6
			key.port[1] = 0;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL)
				return (0);
		} else if (rpool->opts & PF_POOL_STATICPORT) {
			key.port[1] = *nport;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL)
d1921 2
a1922 3
			key.port[1] = *nport;
			if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
				NTOHS(*nport);
a1923 1
			}
d1925 3
a1927 3
			key.port[1] = htons(low);
			if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
				*nport = low;
d1931 2
a1933 2
				u_int16_t tmp;

d1939 1
a1939 1
			cut = arc4random() % (1 + high - low) + low;
d1941 5
a1945 3
			for (*nport = cut; *nport <= high; ++(*nport)) {
				key.port[1] = htons(*nport);
				if (pf_find_state(&tree_ext_gwy, &key) == NULL)
d1947 1
d1949 5
a1953 3
			for (*nport = cut - 1; *nport >= low; --(*nport)) {
				key.port[1] = htons(*nport);
				if (pf_find_state(&tree_ext_gwy, &key) == NULL)
d1955 1
d1959 1
a1959 1
		switch (rpool->opts & PF_POOL_TYPEMASK) {
d1962 1
a1962 1
			if (pf_map_addr(af, rpool, saddr, naddr, &init_addr))
a1969 1
			break;
d1977 3
a1979 3
pf_match_translation(int direction, struct ifnet *ifp, u_int8_t proto,
    struct pf_addr *saddr, u_int16_t sport, struct pf_addr *daddr,
    u_int16_t dport, sa_family_t af, int rs_num)
d1987 1
d1992 1
a1992 1
				dst = &r->rpool.cur->addr;
d1999 2
a2000 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d2004 1
a2004 1
		else if (r->af && r->af != af)
d2006 1
a2006 1
		else if (r->proto && r->proto != proto)
d2008 1
a2008 1
		else if (PF_MISMATCHAW(&src->addr, saddr, af, src->not))
d2016 4
a2019 3
		    PF_MISMATCHAW(&dst->addr, daddr, af, dst->not))
			r = dst == &r->dst ? r->skip[PF_SKIP_DST_ADDR].ptr :
			    TAILQ_NEXT(r, entries);
d2023 4
a2026 3
			r = dst == &r->dst ? r->skip[PF_SKIP_DST_PORT].ptr :
			    TAILQ_NEXT(r, entries);
		else if (r->anchorname[0] && r->anchor == NULL)
d2043 2
a2044 1
pf_get_translation(int direction, struct ifnet *ifp, u_int8_t proto,
d2047 1
a2047 1
    struct pf_addr *naddr, u_int16_t *nport, sa_family_t af)
d2052 2
a2053 2
		r = pf_match_translation(direction, ifp, proto,
		    saddr, sport, daddr, dport, af, PF_RULESET_BINAT);
d2055 2
a2056 2
			r = pf_match_translation(direction, ifp, proto,
			    saddr, sport, daddr, dport, af, PF_RULESET_NAT);
d2058 2
a2059 2
		r = pf_match_translation(direction, ifp, proto,
		    saddr, sport, daddr, dport, af, PF_RULESET_RDR);
d2061 2
a2062 2
			r = pf_match_translation(direction, ifp, proto,
			    saddr, sport, daddr, dport, af, PF_RULESET_BINAT);
a2070 1
			break;
d2072 3
a2074 3
			if (pf_get_sport(af, proto, &r->rpool, saddr, daddr,
			    dport, naddr, nport, r->rpool.proxy_port[0],
			    r->rpool.proxy_port[1])) {
a2085 5
				if (r->rpool.cur->addr.addr.type ==
				    PF_ADDR_DYNIFTL &&
				    r->rpool.cur->addr.addr.p.dyn->undefined)
					return (NULL);
				else
d2087 3
a2089 3
					    &r->rpool.cur->addr.addr.v.a.addr,
					    &r->rpool.cur->addr.addr.v.a.mask,
					    saddr, af);
a2091 4
				if (r->src.addr.type == PF_ADDR_DYNIFTL &&
				    r->src.addr.p.dyn->undefined)
					return (NULL);
				else
d2094 2
a2095 1
					    &r->src.addr.v.a.mask, saddr, af);
d2100 1
a2100 2
			if (pf_map_addr(r->af, &r->rpool,
			    &r->src.addr.v.a.addr, naddr, NULL))
a2121 1
			break;
d2129 1
a2129 2
pf_socket_lookup(uid_t *uid, gid_t *gid, int direction, sa_family_t af,
    int proto, struct pf_pdesc *pd)
d2138 1
a2138 1
	switch (proto) {
d2164 2
a2165 1
	switch(af) {
d2169 1
a2169 2
			inp = in_pcblookup(tb, &saddr->v4, sport, &daddr->v4,
			    dport, INPLOOKUP_WILDCARD);
d2174 1
d2180 1
a2180 2
			inp = in_pcblookup(tb, &saddr->v6, sport, &daddr->v6,
			    dport, INPLOOKUP_WILDCARD | INPLOOKUP_IPV6);
d2222 1
a2222 1
			/* fallthrough */
d2229 1
d2235 115
d2352 3
a2354 2
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
    struct pf_pdesc *pd, struct pf_rule **am)
d2356 1
a2356 1
	struct pf_rule		*nat = NULL, *rdr = NULL;
a2357 1
	struct pf_addr		 baddr, naddr;
d2366 1
d2369 8
d2381 1
a2381 1
		if ((nat = pf_get_translation(PF_OUT, ifp, IPPROTO_TCP,
d2383 2
a2384 2
		    &naddr, &nport, af)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
d2386 1
a2386 1
			    &th->th_sum, &naddr, nport, 0, af);
d2388 3
d2395 1
a2395 1
		if ((rdr = pf_get_translation(PF_IN, ifp, IPPROTO_TCP,
d2397 2
a2398 2
		    &naddr, &nport, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
d2400 1
a2400 1
			    &th->th_sum, &naddr, nport, 0, af);
d2402 3
a2407 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d2410 2
a2411 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d2436 1
a2436 2
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP,
		    pd), 1)) &&
d2441 1
a2441 2
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP,
		    pd), 1)) &&
d2445 6
a2450 1
		else if (r->anchorname[0] && r->anchor == NULL)
d2453 2
d2458 1
d2472 1
a2473 6
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
d2478 2
a2479 2
			m_copyback(m, off, sizeof(*th), (caddr_t)th);
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d2486 11
a2496 9
		/* undo NAT/RST changes, if they have taken place */
		if (nat != NULL) {
			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &baddr, bport, 0, af);
			rewrite++;
		} else if (rdr != NULL) {
			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &baddr, bport, 0, af);
			rewrite++;
d2498 14
a2511 5
		if ((r->rule_flag & PFRULE_RETURNRST) ||
		    (r->rule_flag & PFRULE_RETURN))
			pf_send_reset(off, th, pd, af,
			    r->return_ttl, r);
		else if ((af == AF_INET) && r->return_icmp)
d2522 7
a2528 1
	if (r->keep_state || nat != NULL || rdr != NULL) {
d2532 1
d2535 16
a2550 2
		if (!r->max_states || r->states < r->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
d2552 14
d2574 1
a2574 4
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
d2588 2
a2589 3
			if (nat != NULL) {
				PF_ACPY(&s->lan.addr, &baddr, af);
				s->lan.addr = baddr;
d2600 2
a2601 2
			if (rdr != NULL) {
				PF_ACPY(&s->gwy.addr, &baddr, af);
d2614 1
a2614 1
			while ((s->src.seqdiff = arc4random()) == 0)
d2625 8
a2634 2
		s->src.max_win = MAX(ntohs(th->th_win), 1);
		s->dst.seqlo = 0;	/* Haven't seen these yet */
a2636 1
		s->dst.seqdiff = 0;	/* Defer random generation */
d2640 32
a2671 4
		s->expire = s->creation + TIMEOUT(r, PFTM_TCP_FIRST_PACKET);
		s->packets = 1;
		s->bytes = pd->tot_len;
		if (pf_insert_state(s)) {
d2673 1
d2678 25
d2707 1
a2707 1
		m_copyback(m, off, sizeof(*th), (caddr_t)th);
d2714 3
a2716 2
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
    struct pf_pdesc *pd, struct pf_rule **am)
d2718 1
a2718 1
	struct pf_rule		*nat = NULL, *rdr = NULL;
a2719 1
	struct pf_addr		 baddr, naddr;
d2728 1
d2731 7
d2742 1
a2742 1
		if ((nat = pf_get_translation(PF_OUT, ifp, IPPROTO_UDP,
d2744 2
a2745 2
		    &naddr, &nport, af)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
d2747 1
a2747 1
			    &uh->uh_sum, &naddr, nport, 1, af);
d2749 3
d2756 4
a2759 4
		if ((rdr = pf_get_translation(PF_IN, ifp, IPPROTO_UDP,
		    saddr, uh->uh_sport, daddr, uh->uh_dport,
		    &naddr, &nport, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
d2761 1
a2761 1
			    &uh->uh_sum, &naddr, nport, 1, af);
d2763 3
a2768 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d2771 2
a2772 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d2795 1
a2795 2
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP,
		    pd), 1)) &&
d2800 1
a2800 2
		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP,
		    pd), 1)) &&
d2804 5
a2808 1
		else if (r->anchorname[0] && r->anchor == NULL)
d2811 2
d2816 1
d2830 1
a2831 6
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
d2836 2
a2837 2
			m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d2843 11
a2853 9
		/* undo NAT/RST changes, if they have taken place */
		if (nat != NULL) {
			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &baddr, bport, 1, af);
			rewrite++;
		} else if (rdr != NULL) {
			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &baddr, bport, 1, af);
			rewrite++;
d2866 6
a2871 1
	if (r->keep_state || nat != NULL || rdr != NULL) {
d2874 1
d2876 31
a2906 3
		if (!r->max_states || r->states < r->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL)
d2908 1
a2912 1

d2914 1
a2914 4
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
d2928 2
a2929 2
			if (nat != NULL) {
				PF_ACPY(&s->lan.addr, &baddr, af);
d2940 2
a2941 2
			if (rdr != NULL) {
				PF_ACPY(&s->gwy.addr, &baddr, af);
a2947 4
		s->src.seqlo = 0;
		s->src.seqhi = 0;
		s->src.seqdiff = 0;
		s->src.max_win = 0;
a2948 4
		s->dst.seqlo = 0;
		s->dst.seqhi = 0;
		s->dst.seqdiff = 0;
		s->dst.max_win = 0;
d2951 13
a2963 4
		s->expire = s->creation + TIMEOUT(r, PFTM_UDP_FIRST_PACKET);
		s->packets = 1;
		s->bytes = pd->tot_len;
		if (pf_insert_state(s)) {
d2965 1
d2974 1
a2974 1
		m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
d2981 3
a2983 2
    struct ifnet *ifp, struct mbuf *m, int ipoff, int off, void *h,
    struct pf_pdesc *pd, struct pf_rule **am)
d2985 1
a2985 1
	struct pf_rule		*nat = NULL, *rdr = NULL;
a2986 1
	struct pf_addr		 baddr, naddr;
d2989 1
d2995 2
d3001 3
a3031 2
	default:
		return (PF_DROP);
d3034 2
d3038 3
a3040 3
		if ((nat = pf_get_translation(PF_OUT, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
d3045 1
a3045 1
				    naddr.v4.s_addr, 0);
d3051 1
a3051 1
				    &naddr, 0);
d3056 3
d3062 3
a3064 3
		if ((rdr = pf_get_translation(PF_IN, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
			PF_ACPY(&baddr, daddr, af);
d3069 1
a3069 1
				    pd->ip_sum, naddr.v4.s_addr, 0);
d3075 1
a3075 1
				    &naddr, 0);
d3080 3
a3085 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d3088 2
a3089 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d3109 5
a3113 1
		else if (r->anchorname[0] && r->anchor == NULL)
d3116 2
d3121 1
d3135 1
a3136 6
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
d3142 2
a3143 2
			m_copyback(m, off, ICMP_MINLEN,
			    (caddr_t)pd->hdr.icmp6);
d3145 1
a3145 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d3151 6
a3156 2
	if (!state_icmp && (r->keep_state ||
	    nat != NULL || rdr != NULL)) {
d3159 1
d3161 31
a3191 3
		if (!r->max_states || r->states < r->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL)
d3193 1
a3197 1

d3199 1
a3199 4
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
d3213 2
a3214 2
			if (nat != NULL)
				PF_ACPY(&s->lan.addr, &baddr, af);
d3223 2
a3224 2
			if (rdr != NULL)
				PF_ACPY(&s->gwy.addr, &baddr, af);
a3228 10
		s->src.seqlo = 0;
		s->src.seqhi = 0;
		s->src.seqdiff = 0;
		s->src.max_win = 0;
		s->src.state = 0;
		s->dst.seqlo = 0;
		s->dst.seqhi = 0;
		s->dst.seqdiff = 0;
		s->dst.max_win = 0;
		s->dst.state = 0;
d3230 13
a3242 4
		s->expire = s->creation + TIMEOUT(r, PFTM_ICMP_FIRST_PACKET);
		s->packets = 1;
		s->bytes = pd->tot_len;
		if (pf_insert_state(s)) {
d3244 1
d3254 2
a3255 2
		m_copyback(m, off, ICMP_MINLEN,
		    (caddr_t)pd->hdr.icmp6);
d3263 2
a3264 2
    struct ifnet *ifp, struct mbuf *m, void *h, struct pf_pdesc *pd,
    struct pf_rule **am)
d3266 1
a3266 1
	struct pf_rule		*nat = NULL, *rdr = NULL;
d3269 1
a3270 1
	struct pf_addr		 baddr, naddr;
d3273 7
d3283 3
a3285 3
		if ((nat = pf_get_translation(PF_OUT, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
			PF_ACPY(&baddr, saddr, af);
d3290 1
a3290 1
				    naddr.v4.s_addr, 0);
d3295 1
a3295 1
				PF_ACPY(saddr, &naddr, af);
d3299 3
d3305 3
a3307 2
		if ((rdr = pf_get_translation(PF_IN, ifp, pd->proto,
		    saddr, 0, daddr, 0, &naddr, NULL, af)) != NULL) {
d3312 1
a3312 1
				    pd->ip_sum, naddr.v4.s_addr, 0);
d3317 1
a3317 1
				PF_ACPY(daddr, &naddr, af);
d3321 3
a3326 1
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
d3329 2
a3330 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d3346 5
a3350 1
		else if (r->anchorname[0] && r->anchor == NULL)
d3353 2
d3358 1
d3372 1
a3373 6
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
d3375 1
d3377 35
a3411 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d3416 6
a3421 1
	if (r->keep_state || nat != NULL || rdr != NULL) {
d3424 1
d3426 31
a3456 3
		if (!r->max_states || r->states < r->max_states)
			s = pool_get(&pf_state_pl, PR_NOWAIT);
		if (s == NULL)
d3458 1
a3462 1

d3464 1
a3464 4
		if (nat != NULL)
			s->nat_rule.ptr = nat;
		else
			s->nat_rule.ptr = rdr;
a3474 1
			s->gwy.port = 0;
d3476 2
a3477 3
			s->ext.port = 0;
			if (nat != NULL)
				PF_ACPY(&s->lan.addr, &baddr, af);
a3479 1
			s->lan.port = 0;
a3481 1
			s->lan.port = 0;
d3483 2
a3484 3
			s->ext.port = 0;
			if (rdr != NULL)
				PF_ACPY(&s->gwy.addr, &baddr, af);
a3486 1
			s->gwy.port = 0;
a3487 4
		s->src.seqlo = 0;
		s->src.seqhi = 0;
		s->src.seqdiff = 0;
		s->src.max_win = 0;
a3488 4
		s->dst.seqlo = 0;
		s->dst.seqhi = 0;
		s->dst.seqdiff = 0;
		s->dst.max_win = 0;
d3491 13
a3503 4
		s->expire = s->creation + TIMEOUT(r, PFTM_OTHER_FIRST_PACKET);
		s->packets = 1;
		s->bytes = pd->tot_len;
		if (pf_insert_state(s)) {
d3505 1
a3505 3
			if (r->log)
				PFLOG_PACKET(ifp, h, m, af, direction, reason,
				    a ? a : r);
d3516 3
a3518 2
pf_test_fragment(struct pf_rule **rm, int direction, struct ifnet *ifp,
    struct mbuf *m, void *h, struct pf_pdesc *pd, struct pf_rule **am)
d3524 2
d3530 2
a3531 2
		if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
		    (r->ifp == ifp && r->ifnot)))
d3546 2
a3547 1
		    r->flagset || r->type || r->code)
d3549 3
a3551 1
		else if (r->anchorname[0] && r->anchor == NULL)
d3557 1
d3571 1
a3572 6
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
d3574 1
d3576 1
a3576 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d3581 5
d3590 3
a3592 2
pf_test_state_tcp(struct pf_state **state, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d3594 1
a3594 1
	struct pf_tree_node	 key;
d3597 1
a3597 1
	u_int32_t		 ack, end, seq;
d3600 1
d3605 11
a3615 4
	PF_ACPY(&key.addr[0], pd->src, key.af);
	PF_ACPY(&key.addr[1], pd->dst, key.af);
	key.port[0] = th->th_sport;
	key.port[1] = th->th_dport;
d3624 75
a3698 1
		dst = &(*state)->src;
d3713 1
a3713 1
	seq = ntohl(th->th_seq);
d3717 8
d3726 2
a3727 2
		if (dst->seqdiff) {
			while ((src->seqdiff = arc4random()) == 0)
d3733 1
d3741 18
a3758 1
			src->wscale = pf_get_wscale(m, off, th->th_off, pd->af);
d3785 1
d3822 2
a3823 2
	    /* Acking not more than one window back */
	    (ackskew <= MAXACKWINDOW)) {
d3825 9
a3833 3

		(*state)->packets++;
		(*state)->bytes += pd->tot_len;
d3863 1
d3866 1
a3866 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_CLOSED);
d3869 1
a3869 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_FIN_WAIT);
d3872 1
a3872 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_OPENING);
d3875 1
a3875 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_CLOSING);
d3877 1
a3877 2
			(*state)->expire = time.tv_sec +
			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_ESTABLISHED);
d3914 3
a3916 2
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d\n",
			    seq, ack, pd->p_len, ackskew, (*state)->packets);
d3919 5
a3923 2
		(*state)->packets++;
		(*state)->bytes += pd->tot_len;
d3952 14
a3965 2
			pf_send_reset(off, th, pd, pd->af, 0,
			    (*state)->rule.ptr);
d3973 1
a3973 1
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d "
d3975 1
a3975 1
			    ++(*state)->packets,
d3983 1
a3983 1
			    (ackskew <= MAXACKWINDOW) ? ' ' : '4',
d3990 1
d3993 1
a3993 1
	/* translate source/destination address, if needed */
d4003 4
a4006 4
		m_copyback(m, off, sizeof(*th), (caddr_t)th);
	} else if (src->seqdiff) {
		/* Copyback sequence modulation */
		m_copyback(m, off, sizeof(*th), (caddr_t)th);
a4008 10
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
	}
d4013 2
a4014 2
pf_test_state_udp(struct pf_state **state, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
d4017 1
a4017 1
	struct pf_tree_node	 key;
d4022 11
a4032 4
	PF_ACPY(&key.addr[0], pd->src, key.af);
	PF_ACPY(&key.addr[1], pd->dst, key.af);
	key.port[0] = pd->hdr.udp->uh_sport;
	key.port[1] = pd->hdr.udp->uh_dport;
a4043 3
	(*state)->packets++;
	(*state)->bytes += pd->tot_len;

d4051 1
d4053 1
a4053 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_UDP_MULTIPLE);
d4055 1
a4055 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_UDP_SINGLE);
d4067 1
a4067 1
		m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
a4069 10
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
	}
d4074 2
a4075 2
pf_test_state_icmp(struct pf_state **state, int direction, struct ifnet *ifp,
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
a4109 2
		default:
			return (PF_DROP);
d4118 1
a4118 1
		struct pf_tree_node	key;
d4122 11
a4132 4
		PF_ACPY(&key.addr[0], saddr, key.af);
		PF_ACPY(&key.addr[1], daddr, key.af);
		key.port[0] = icmpid;
		key.port[1] = icmpid;
d4136 2
a4137 4
		(*state)->packets++;
		(*state)->bytes += pd->tot_len;
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_ICMP_ERROR_REPLY);
d4139 1
a4139 1
		/* translate source/destination address, if needed */
d4155 3
a4157 2
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp6);
d4175 3
a4177 2
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp6);
d4221 1
a4221 1
			if (ntohs(h2.ip_off) & IP_OFFMASK)
a4284 2
		default:
			return (PF_DROP);
d4291 1
a4291 1
			struct pf_tree_node	 key;
d4294 1
d4310 11
a4320 4
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = th.th_dport;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = th.th_sport;
d4332 2
a4333 1
			if (src->wscale && dst->wscale && !(th.th_flags & TH_SYN))
d4340 2
a4341 2
			if (src->seqdiff)
				pf_change_a(&th.th_seq, &th.th_sum,
d4343 2
d4349 6
a4354 1
					printf("pf: BAD ICMP state: ");
d4364 1
a4364 1
					    saddr, &(*state)->lan.addr,
d4375 4
d4383 1
a4383 1
					    (caddr_t)pd->hdr.icmp);
d4385 1
a4385 1
					    (caddr_t)&h2);
d4390 3
a4392 2
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp6);
d4394 1
a4394 1
					    (caddr_t)&h2_6);
d4398 1
a4398 3
				m_copyback(m, off2, 8, (caddr_t)&th);
			} else if (src->seqdiff) {
				m_copyback(m, off2, 8, (caddr_t)&th);
d4406 1
a4406 1
			struct pf_tree_node	key;
d4418 11
a4428 4
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = uh.uh_dport;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = uh.uh_sport;
d4450 2
a4451 3
					    (caddr_t)pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2),
					    (caddr_t)&h2);
d4456 3
a4458 2
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp6);
d4460 1
a4460 1
					    (caddr_t)&h2_6);
d4464 1
a4464 2
				m_copyback(m, off2, sizeof(uh),
				    (caddr_t)&uh);
d4473 1
a4473 1
			struct pf_tree_node	key;
d4485 11
a4495 4
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = iih.icmp_id;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = iih.icmp_id;
d4513 3
a4515 6
				m_copyback(m, off, ICMP_MINLEN,
				    (caddr_t)pd->hdr.icmp);
				m_copyback(m, ipoff2, sizeof(h2),
				    (caddr_t)&h2);
				m_copyback(m, off2, ICMP_MINLEN,
				    (caddr_t)&iih);
d4525 1
a4525 1
			struct pf_tree_node	key;
d4527 2
a4528 2
			if (!pf_pull_hdr(m, off2, &iih, ICMP_MINLEN,
			    NULL, NULL, pd2.af)) {
d4537 11
a4547 4
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = iih.icmp6_id;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = iih.icmp6_id;
d4565 5
a4569 6
				m_copyback(m, off, ICMP_MINLEN,
				    (caddr_t)pd->hdr.icmp6);
				m_copyback(m, ipoff2, sizeof(h2_6),
				    (caddr_t)&h2_6);
				m_copyback(m, off2, ICMP_MINLEN,
				    (caddr_t)&iih);
d4576 56
a4631 4
		default:
			DPFPRINTF(PF_DEBUG_MISC,
			    ("pf: ICMP error message for bad proto\n"));
			return (PF_DROP);
a4632 1

d4637 1
a4637 1
pf_test_state_other(struct pf_state **state, int direction, struct ifnet *ifp,
d4641 1
a4641 1
	struct pf_tree_node	 key;
d4645 11
a4655 4
	PF_ACPY(&key.addr[0], pd->src, key.af);
	PF_ACPY(&key.addr[1], pd->dst, key.af);
	key.port[0] = 0;
	key.port[1] = 0;
a4666 3
	(*state)->packets++;
	(*state)->bytes += pd->tot_len;

d4674 1
d4676 1
a4676 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_OTHER_MULTIPLE);
d4678 1
a4678 2
		(*state)->expire = time.tv_sec +
		    TIMEOUT((*state)->rule.ptr, PFTM_OTHER_SINGLE);
a4713 10
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
	}
d4729 1
a4729 1
		u_int16_t	 fragoff = (h->ip_off & IP_OFFMASK) << 3;
d4740 2
a4741 1
		if (m->m_pkthdr.len < off + len || h->ip_len < off + len) {
d4796 1
a4801 1
	struct m_tag		*mtag;
d4803 1
d4810 18
d4829 1
a4829 10
		m0 = *m;
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
		}
		m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT);
		if (m0 == NULL)
d4831 3
d4867 2
a4868 3
			pf_map_addr(AF_INET, &r->rpool,
			    (struct pf_addr *)&ip->ip_src,
			    &naddr, NULL);
d4871 2
a4872 1
			ifp = r->rpool.cur->ifp;
a4873 6
			if (s->rt_ifp == NULL) {
				pf_map_addr(AF_INET, &r->rpool,
				    (struct pf_addr *)&ip->ip_src,
				    &s->rt_addr, NULL);
				s->rt_ifp = r->rpool.cur->ifp;
			}
d4877 1
a4877 1
			ifp = s->rt_ifp;
a4879 1

d4884 35
a4918 14
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
			if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
				goto bad;
			else if (m0 == NULL)
				goto done;
			if (m0->m_len < sizeof(struct ip))
				panic("pf_route: m0->m_len < "
				    "sizeof(struct ip)");
			ip = mtod(m0, struct ip *);
d4922 1
a4922 4
	/* Copied from ip_output. */
	if (ip->ip_len <= ifp->if_mtu) {
		ip->ip_len = htons((u_int16_t)ip->ip_len);
		ip->ip_off = htons((u_int16_t)ip->ip_off);
d4944 1
a4944 1
	if (ip->ip_off & IP_DF) {
d4956 2
a4957 1
	if (error == EMSGSIZE)
d4959 1
d5000 1
d5007 18
d5026 1
a5026 10
		m0 = *m;
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
		}
		m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT);
		if (m0 == NULL)
d5028 3
d5054 1
a5054 1
		ip6_output(m0, NULL, NULL, NULL, NULL, NULL);
d5061 2
a5062 2
		pf_map_addr(AF_INET6, &r->rpool,
		    (struct pf_addr *)&ip6->ip6_src, &naddr, NULL);
d5066 1
a5066 1
		ifp = r->rpool.cur->ifp;
a5067 6
		if (s->rt_ifp == NULL) {
			pf_map_addr(AF_INET6, &r->rpool,
			    (struct pf_addr *)&ip6->ip6_src,
			    &s->rt_addr, NULL);
			s->rt_ifp = r->rpool.cur->ifp;
		}
d5071 1
a5071 1
		ifp = s->rt_ifp;
a5072 1

d5077 7
a5083 11
		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
			if (mtag == NULL)
				goto bad;
			m_tag_prepend(m0, mtag);
			if (pf_test6(PF_OUT, ifp, &m0) != PF_PASS)
				goto bad;
			else if (m0 == NULL)
				goto done;
		}
d5090 2
d5093 1
a5093 2
		error = (*ifp->if_output)(ifp, m0, (struct sockaddr *)dst,
		    NULL);
d5121 2
a5122 1
pf_check_proto_cksum(struct mbuf *m, int off, int len, u_int8_t p, sa_family_t af)
d5154 1
d5170 1
d5205 14
d5223 16
a5238 8
	u_short		 action, reason = 0, log = 0;
	struct mbuf	*m = *m0;
	struct ip	*h;
	struct pf_rule	*a = NULL, *r = &pf_default_rule;
	struct pf_state	*s = NULL;
	struct pf_pdesc	 pd;
	int		 off;
	int		 pqid = 0;
d5244 4
d5251 1
a5251 1
#endif
d5253 1
d5262 2
a5263 2
	if (pf_normalize_ip(m0, dir, ifp, &reason) != PF_PASS) {
		ACTION_SET(&action, PF_DROP);
d5279 1
d5284 2
a5285 1
	pd.tot_len = h->ip_len;
d5288 3
a5290 2
	if (h->ip_off & (IP_MF | IP_OFFMASK)) {
		action = pf_test_fragment(&r, dir, ifp, m, h, &pd, &a);
d5306 1
a5306 1
		    h->ip_len - off, IPPROTO_TCP, AF_INET)) {
d5313 1
a5313 1
		action = pf_normalize_tcp(dir, ifp, m, 0, off, h, &pd);
d5315 3
a5317 2
			break;
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd);
d5319 3
d5323 1
d5326 2
a5327 2
			action = pf_test_tcp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a);
d5341 1
a5341 1
		    off, h->ip_len - off, IPPROTO_UDP, AF_INET)) {
d5345 7
a5351 1
		action = pf_test_state_udp(&s, dir, ifp, m, 0, off, h, &pd);
d5353 3
d5360 2
a5361 2
			action = pf_test_udp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a);
d5375 1
a5375 1
		    h->ip_len - off, IPPROTO_ICMP, AF_INET)) {
d5379 1
a5379 1
		action = pf_test_state_icmp(&s, dir, ifp, m, 0, off, h, &pd);
d5381 3
a5384 2
			r->packets++;
			r->bytes += h->ip_len;
a5385 4
			if (a != NULL) {
				a->packets++;
				a->bytes += h->ip_len;
			}
d5388 2
a5389 2
			action = pf_test_icmp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a);
d5394 1
a5394 1
		action = pf_test_state_other(&s, dir, ifp, &pd);
d5396 3
d5403 2
a5404 1
			action = pf_test_other(&r, &s, dir, ifp, m, h, &pd, &a);
a5407 5
	if (ifp == status_ifp) {
		pf_status.bcounters[0][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[0][dir == PF_OUT][action]++;
	}

d5409 1
a5409 12
	if (r->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->src.not);
	if (r->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->dst.not);

	if (action != PF_DROP && h->ip_hl > 5 &&
d5419 1
a5419 1
	if (action != PF_DROP && r->qid) {
d5436 16
a5451 1
#endif
d5454 65
a5518 1
		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, a ? a : r);
d5520 6
a5525 2
	/* pf_route can free the mbuf causing *m0 to become NULL */
	if (r->rt)
d5536 16
a5551 7
	u_short		 action, reason = 0, log = 0;
	struct mbuf	*m = *m0;
	struct ip6_hdr	*h;
	struct pf_rule	*a = NULL, *r = &pf_default_rule;
	struct pf_state	*s = NULL;
	struct pf_pdesc pd;
	int		off, terminal = 0;
d5557 4
d5564 1
a5564 1
#endif
d5566 1
d5574 5
d5584 1
d5589 1
d5596 2
a5597 1
			action = pf_test_fragment(&r, dir, ifp, m, h, &pd, &a);
d5648 1
a5648 1
		action = pf_normalize_tcp(dir, ifp, m, 0, off, h, &pd);
d5650 3
a5652 2
			break;
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd);
d5654 3
d5658 1
d5661 2
a5662 2
			action = pf_test_tcp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a);
d5680 7
a5686 1
		action = pf_test_state_udp(&s, dir, ifp, m, 0, off, h, &pd);
d5688 3
d5692 1
d5695 2
a5696 2
			action = pf_test_udp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a);
d5714 2
a5715 2
		action = pf_test_state_icmp(&s, dir, ifp,
		    m, 0, off, h, &pd);
d5717 3
d5721 1
a5721 2
			r->packets++;
			r->bytes += h->ip6_plen;
d5724 2
a5725 2
			action = pf_test_icmp(&r, &s, dir, ifp,
			    m, 0, off, h, &pd, &a);
d5730 11
a5740 1
		action = pf_test_other(&r, &s, dir, ifp, m, h, &pd, &a);
a5743 5
	if (ifp == status_ifp) {
		pf_status.bcounters[1][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[1][dir == PF_OUT][action]++;
	}

a5744 11
	if (r->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->src.not);
	if (r->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(r->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    r->dst.not);

d5748 1
a5748 1
	if (action != PF_DROP && r->qid) {
d5765 11
a5775 1
#endif
d5778 64
a5841 1
		PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, a ? a : r);
d5843 7
a5849 2
	/* pf_route6 can free the mbuf causing *m0 to become NULL */
	if (r->rt)
d5855 9
@


1.5
log
@clean up after cvs
fix some stuff

in the hope to fully have removed sys_mhint... they implemented
it in the name of sys_mquery *d'oh*
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.337 2003/04/11 14:40:57 henning Exp $ */
a119 2
int			 pf_tbladdr_setup(struct pf_addr_wrap *);
void			 pf_tbladdr_remove(struct pf_addr_wrap *);
d493 1
a493 1
pf_tbladdr_setup(struct pf_addr_wrap *aw)
d497 1
a497 1
	if ((aw->p.tbl = pfr_attach_table(aw->v.tblname)) == NULL)
a1553 1
	int			step;
d1592 6
a1597 6
			if (low < high) {
				step = 1;
				cut = arc4random() % (1 + high - low) + low;
			} else {
				step = -1;
				cut = arc4random() % (1 + low - high) + high;
d1599 4
a1602 4

			*nport = cut - step;
			do {
				*nport += step;
d1606 2
a1607 6
			} while (*nport != low && *nport != high);

			step = -step;
			*nport = cut;
			do {
				*nport += step;
d1611 1
a1611 1
			} while (*nport != low && *nport != high);
@


1.4
log
@clean up the cvs import mess

nb, this doesnt mean the tree builds.
its bed time
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.336 2003/04/09 18:21:58 henning Exp $ */
d183 2
d808 27
@


1.3
log
@merge OpenBSD cvs import conflicts
enable /etc/isdn directory and MAKEDEV.i4b
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.328 2003/03/21 12:47:36 cedric Exp $ */
a107 22
/* Timeouts */
int			 pftm_tcp_first_packet = 120;	/* First TCP packet */
int			 pftm_tcp_opening = 30;		/* No response yet */
int			 pftm_tcp_established = 24*60*60;  /* established */
int			 pftm_tcp_closing = 15 * 60;	/* Half closed */
int			 pftm_tcp_fin_wait = 45;	/* Got both FINs */
int			 pftm_tcp_closed = 90;		/* Got a RST */

int			 pftm_udp_first_packet = 60;	/* First UDP packet */
int			 pftm_udp_single = 30;		/* Unidirectional */
int			 pftm_udp_multiple = 60;	/* Bidirectional */

int			 pftm_icmp_first_packet = 20;	/* First ICMP packet */
int			 pftm_icmp_error_reply = 10;	/* Got error response */

int			 pftm_other_first_packet = 60;	/* First packet */
int			 pftm_other_single = 30;	/* Unidirectional */
int			 pftm_other_multiple = 60;	/* Bidirectional */

int			 pftm_frag = 30;		/* Fragment expire */

int			 pftm_interval = 10;		/* expire interval */
a109 11
int			*pftm_timeouts[PFTM_MAX] = { &pftm_tcp_first_packet,
				&pftm_tcp_opening, &pftm_tcp_established,
				&pftm_tcp_closing, &pftm_tcp_fin_wait,
				&pftm_tcp_closed, &pftm_udp_first_packet,
				&pftm_udp_single, &pftm_udp_multiple,
				&pftm_icmp_first_packet, &pftm_icmp_error_reply,
				&pftm_other_first_packet, &pftm_other_single,
				&pftm_other_multiple, &pftm_frag,
				&pftm_interval };


d156 1
a156 1
			    struct pf_pdesc *);
d159 1
a159 1
			    struct pf_pdesc *);
d162 1
a162 1
			    void *, struct pf_pdesc *);
d165 1
a165 1
			    struct pf_pdesc *);
d168 1
a168 1
			    struct pf_pdesc *);
a222 1
		    (*state)->rule.ptr != NULL &&			\
d241 1
a241 1
	(((r) && (r)->timeout[(i)]) ? (r)->timeout[(i)] : *pftm_timeouts[(i)])
d439 1
a439 1
	timeout_add(to, pftm_interval * hz);
d473 10
a482 4
			if (cur->state->rule.ptr != NULL)
				cur->state->rule.ptr->states--;
			if (cur->state->nat_rule != NULL)
				cur->state->nat_rule->states--;
d1024 2
a1025 2
    default:
	printf("panic: trying to send RST to an unhandled address family\n");
d1093 1
a1093 1
	if (r != NULL && r->qid) {
d1161 1
a1161 1
	if (r != NULL && r->qid) {
d1879 1
a1879 1
    struct pf_pdesc *pd)
d1890 1
a1890 1
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
a1894 2
	*rm = NULL;

d1964 1
a1964 1
				rs = (anchorrule == NULL ? r : anchorrule);
d1969 1
a1969 1
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
d1972 2
a1973 2
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
d1976 2
d1979 27
a2005 39
	if (*rm != NULL) {
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
		REASON_SET(&reason, PFRES_MATCH);

		if ((*rm)->log) {
			if (rewrite)
				m_copyback(m, off, sizeof(*th), (caddr_t)th);
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
		}

		if (((*rm)->action == PF_DROP) &&
		    (((*rm)->rule_flag & PFRULE_RETURNRST) ||
		    ((*rm)->rule_flag & PFRULE_RETURNICMP) ||
		    ((*rm)->rule_flag & PFRULE_RETURN))) {
			/* undo NAT/RST changes, if they have taken place */
			if (nat != NULL) {
				pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
				    &th->th_sum, &baddr, bport, 0, af);
				rewrite++;
			} else if (rdr != NULL) {
				pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
				    &th->th_sum, &baddr, bport, 0, af);
				rewrite++;
			}
			if (((*rm)->rule_flag & PFRULE_RETURNRST) ||
			    ((*rm)->rule_flag & PFRULE_RETURN))
				pf_send_reset(off, th, pd, af,
				    (*rm)->return_ttl, *rm);
			else if ((af == AF_INET) && (*rm)->return_icmp)
				pf_send_icmp(m, (*rm)->return_icmp >> 8,
				    (*rm)->return_icmp & 255, af, *rm);
			else if ((af == AF_INET6) && (*rm)->return_icmp6)
				pf_send_icmp(m, (*rm)->return_icmp6 >> 8,
				    (*rm)->return_icmp6 & 255, af, *rm);
d2007 11
d2019 2
a2020 3
		if ((*rm)->action == PF_DROP)
			return (PF_DROP);
	}
d2022 1
a2022 2
	if (((*rm != NULL) && (*rm)->keep_state) ||
	    nat != NULL || rdr != NULL) {
d2028 1
a2028 2
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
d2035 4
a2038 4
		if (rs != NULL)
			rs->states++;

		s->rule.ptr = rs;
d2040 1
a2040 1
			s->nat_rule = nat;
d2042 6
a2047 5
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
d2081 1
a2081 1
		    *rm != NULL && (*rm)->keep_state == PF_STATE_MODULATE) {
d2104 1
a2104 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_TCP_FIRST_PACKET);
d2125 1
a2125 1
    struct pf_pdesc *pd)
d2136 1
a2136 1
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
a2140 2
	*rm = NULL;

d2208 1
a2208 1
				rs = (anchorrule == NULL ? r : anchorrule);
d2213 1
a2213 1
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
d2216 2
a2217 2
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
d2220 2
d2223 26
a2248 34
	if (*rm != NULL) {
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
		REASON_SET(&reason, PFRES_MATCH);

		if ((*rm)->log) {
			if (rewrite)
				m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
		}

		if (((*rm)->action == PF_DROP) &&
		    (((*rm)->rule_flag & PFRULE_RETURNICMP) ||
		    ((*rm)->rule_flag & PFRULE_RETURN))) {
			/* undo NAT/RST changes, if they have taken place */
			if (nat != NULL) {
				pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
				    &uh->uh_sum, &baddr, bport, 1, af);
				rewrite++;
			} else if (rdr != NULL) {
				pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
				    &uh->uh_sum, &baddr, bport, 1, af);
				rewrite++;
			}
			if ((af == AF_INET) && (*rm)->return_icmp)
				pf_send_icmp(m, (*rm)->return_icmp >> 8,
				    (*rm)->return_icmp & 255, af, *rm);
			else if ((af == AF_INET6) && (*rm)->return_icmp6)
				pf_send_icmp(m, (*rm)->return_icmp6 >> 8,
				    (*rm)->return_icmp6 & 255, af, *rm);
d2250 7
d2258 2
a2259 3
		if ((*rm)->action == PF_DROP)
			return (PF_DROP);
	}
d2261 1
a2261 2
	if ((*rm != NULL && (*rm)->keep_state) ||
	    nat != NULL || rdr != NULL) {
d2265 1
a2265 2
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
d2270 3
a2272 2
		if (rs != NULL)
			rs->states++;
d2274 1
a2274 1
		s->rule.ptr = rs;
d2276 1
a2276 1
			s->nat_rule = nat;
d2278 6
a2283 5
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
d2323 1
a2323 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_UDP_FIRST_PACKET);
d2344 1
a2344 1
    struct pf_pdesc *pd)
d2349 1
a2349 1
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
a2359 2
	*rm = NULL;

d2465 1
a2465 1
				rs = (anchorrule == NULL ? r : anchorrule);
d2470 1
a2470 1
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
d2473 2
a2474 2
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
d2477 2
d2480 7
a2486 8
	if (*rm != NULL) {
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
		REASON_SET(&reason, PFRES_MATCH);
d2488 1
a2488 1
		if ((*rm)->log) {
d2490 3
a2492 3
			if (rewrite)
				m_copyback(m, off, ICMP_MINLEN,
				    (caddr_t)pd->hdr.icmp6);
d2494 2
a2495 2
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
		}
d2497 2
a2498 3
		if ((*rm)->action != PF_PASS)
			return (PF_DROP);
	}
d2500 1
a2500 1
	if (!state_icmp && ((*rm != NULL && (*rm)->keep_state) ||
d2505 1
a2505 2
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
d2510 3
a2512 2
		if (rs != NULL)
			rs->states++;
d2514 1
a2514 1
		s->rule.ptr = rs;
d2516 1
a2516 1
			s->nat_rule = nat;
d2518 6
a2523 5
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
d2559 1
a2559 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_ICMP_FIRST_PACKET);
d2582 2
a2583 1
    struct ifnet *ifp, struct mbuf *m, void *h, struct pf_pdesc *pd)
d2586 1
a2586 1
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
a2592 2
	*rm = NULL;

d2657 1
a2657 1
				rs = (anchorrule == NULL ? r : anchorrule);
d2662 1
a2662 1
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
d2665 2
a2666 2
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
d2669 2
d2672 9
a2680 10
	if (*rm != NULL) {
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
		REASON_SET(&reason, PFRES_MATCH);
		if ((*rm)->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);
d2682 2
a2683 3
		if ((*rm)->action != PF_PASS)
			return (PF_DROP);
	}
d2685 1
a2685 2
	if ((*rm != NULL && (*rm)->keep_state) || nat != NULL ||
	    rdr != NULL) {
d2689 1
a2689 2
		if (*rm == NULL || !(*rm)->max_states ||
		    (*rm)->states < (*rm)->max_states)
d2694 3
a2696 2
		if (rs != NULL)
			rs->states++;
d2698 1
a2698 1
		s->rule.ptr = rs;
d2700 1
a2700 1
			s->nat_rule = nat;
d2702 6
a2707 5
			s->nat_rule = rdr;
		if (s->nat_rule != NULL)
			s->nat_rule->states++;
		s->allow_opts = *rm && (*rm)->allow_opts;
		s->log = *rm && ((*rm)->log & 2);
d2743 1
a2743 1
		s->expire = s->creation + TIMEOUT(*rm, PFTM_OTHER_FIRST_PACKET);
d2748 1
a2748 1
			if (*rm && (*rm)->log)
d2750 1
a2750 1
				    rs);
d2762 1
a2762 1
    struct mbuf *m, void *h, struct pf_pdesc *pd)
d2764 1
a2764 1
	struct pf_rule		*r, *rs = NULL, *anchorrule = NULL;
d2767 1
a2767 2

	*rm = NULL;
d2795 1
a2795 1
				rs = (anchorrule == NULL ? r : anchorrule);
d2800 1
a2800 1
				PF_STEP_INTO_ANCHOR(r, anchorrule, ruleset,
d2803 2
a2804 2
		if (r == NULL && anchorrule != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, anchorrule, ruleset,
d2807 2
d2810 9
a2818 2
	if (*rm != NULL) {
		u_short	reason;
d2820 2
a2821 13
		(*rm)->packets++;
		(*rm)->bytes += pd->tot_len;
		if (rs != *rm) {
			rs->packets++;
			rs->bytes += pd->tot_len;
		}
		REASON_SET(&reason, PFRES_MATCH);
		if ((*rm)->log)
			PFLOG_PACKET(ifp, h, m, af, direction, reason, rs);

		if ((*rm)->action != PF_PASS)
			return (PF_DROP);
	}
d3117 9
a3125 7
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->nat_rule != NULL) {
		(*state)->nat_rule->packets++;
		(*state)->nat_rule->bytes += pd->tot_len;
d3185 9
a3193 7
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->nat_rule != NULL) {
		(*state)->nat_rule->packets++;
		(*state)->nat_rule->bytes += pd->tot_len;
d3747 9
a3755 7
	if ((*state)->rule.ptr != NULL) {
		(*state)->rule.ptr->packets++;
		(*state)->rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->nat_rule != NULL) {
		(*state)->nat_rule->packets++;
		(*state)->nat_rule->bytes += pd->tot_len;
d4222 1
a4222 1
	struct pf_rule	*r = NULL;
d4270 1
a4270 1
		action = pf_test_fragment(&r, dir, ifp, m, h, &pd);
d4302 1
a4302 1
			    m, 0, off, h, &pd);
d4323 1
d4327 1
a4327 1
			    m, 0, off, h, &pd);
d4348 6
a4353 3
			if (r != NULL) {
				r->packets++;
				r->bytes += h->ip_len;
d4358 1
a4358 1
			    m, 0, off, h, &pd);
d4366 1
d4369 1
a4369 1
			action = pf_test_other(&r, &s, dir, ifp, m, h, &pd);
d4379 1
a4379 1
	if (r != NULL && r->src.addr.type == PF_ADDR_TABLE)
d4384 1
a4384 1
	if (r != NULL && r->dst.addr.type == PF_ADDR_TABLE)
d4391 1
a4391 1
	    !((s && s->allow_opts) || (r && r->allow_opts))) {
d4400 1
a4400 1
	if (action != PF_DROP && r != NULL && r->qid) {
d4419 2
a4420 12
	if (log) {
		if (r == NULL) {
			struct pf_rule	r0;

			r0.ifp = ifp;
			r0.action = action;
			r0.nr = -1;
			if (h != NULL)
				PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, &r0);
		} else if (h != NULL)
			PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, r);
	}
d4423 1
a4423 1
	if (r != NULL && r->rt)
d4437 1
a4437 1
	struct pf_rule	*r = NULL;
d4473 1
a4473 1
			action = pf_test_fragment(&r, dir, ifp, m, h, &pd);
d4533 1
a4533 1
			    m, 0, off, h, &pd);
d4557 1
a4557 1
			    m, 0, off, h, &pd);
d4579 2
a4580 4
			if (r != NULL) {
				r->packets++;
				r->bytes += h->ip6_plen;
			}
d4584 1
a4584 1
			    m, 0, off, h, &pd);
d4589 1
a4589 1
		action = pf_test_other(&r, &s, dir, ifp, m, h, &pd);
d4599 1
a4599 1
	if (r != NULL && r->src.addr.type == PF_ADDR_TABLE)
d4604 1
a4604 1
	if (r != NULL && r->dst.addr.type == PF_ADDR_TABLE)
d4613 1
a4613 1
	if (action != PF_DROP && r != NULL && r->qid) {
d4632 2
a4633 11
	if (log) {
		if (r == NULL) {
			struct pf_rule	r0;

			r0.ifp = ifp;
			r0.action = action;
			r0.nr = -1;
			PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, &r0);
		} else
			PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, r);
	}
d4636 1
a4636 1
	if (r != NULL && r->rt)
@


1.2
log
@Merge MirBSD-old entirely
Remove krb, yp, afs, GPL'd stuff in kernel
Adjust some other stuff

Not to be compiled yet...
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.327 2003/03/09 20:26:12 frantzen Exp $ */
d4408 1
a4408 1
		    (r->direction == dir) ? pd.src : pd.dst, pd.af,
d4413 1
a4413 1
		    (r->direction == dir) ? pd.dst : pd.src, pd.af,
d4640 1
a4640 1
		    (r->direction == dir) ? pd.src : pd.dst, pd.af,
d4645 1
a4645 1
		    (r->direction == dir) ? pd.dst : pd.src, pd.af,
@


1.1
log
@Initial revision
@
text
@d952 1
d1034 1
a1034 1
	struct ip	*h2;
d1037 1
a1037 1
	struct ip6_hdr	*h2_6;
d1039 1
a1039 1
	struct tcphdr	*th2;
d1052 2
d2423 2
d3269 2
d3439 2
d4453 3
a4455 2
			PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, &r0);
		} else
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD repository of CTM 3155 (roughly today at noon).
Mostly in order to go 3.3-current and ease further merges of
both OpenBSD and ELFdiffs after the MirBSD has been enabled
to build again.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.328 2003/03/21 12:47:36 cedric Exp $ */
d4399 1
a4399 1
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
d4404 1
a4404 1
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
d4630 1
a4630 1
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
d4635 1
a4635 1
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
@


1.1.1.3
log
@Import OpenBSD cvs as of roughly 11:11 UTC today,
or CTM delta 3188/3189/3190.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.336 2003/04/09 18:21:58 henning Exp $ */
d108 22
d132 11
d189 1
a189 1
			    struct pf_pdesc *, struct pf_rule **);
d192 1
a192 1
			    struct pf_pdesc *, struct pf_rule **);
d195 1
a195 1
			    void *, struct pf_pdesc *, struct pf_rule **);
d198 1
a198 1
			    struct pf_pdesc *, struct pf_rule **);
d201 1
a201 1
			    struct pf_pdesc *, struct pf_rule **);
d256 1
d275 1
a275 1
	((r)->timeout[(i)] ? (r)->timeout[(i)] : pf_default_rule.timeout[(i)])
d473 1
a473 1
	timeout_add(to, pf_default_rule.timeout[PFTM_INTERVAL] * hz);
d507 4
a510 10
			if (--cur->state->rule.ptr->states <= 0)
				pf_rm_rule(NULL, cur->state->rule.ptr);
			if (cur->state->nat_rule.ptr != NULL)
				if (--cur->state->nat_rule.ptr->states <= 0)
					pf_rm_rule(NULL,
					    cur->state->nat_rule.ptr);
			if (cur->state->anchor.ptr != NULL)
				if (--cur->state->anchor.ptr->states <= 0)
					pf_rm_rule(NULL,
					    cur->state->anchor.ptr);
d1118 1
a1118 1
	if (r->qid) {
d1186 1
a1186 1
	if (r->qid) {
d1904 1
a1904 1
    struct pf_pdesc *pd, struct pf_rule **am)
d1915 1
a1915 1
	struct pf_rule		*r, *a = NULL;
d1920 2
d1991 1
a1991 1
				*am = a;
d1996 1
a1996 1
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
d1999 2
a2000 2
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
a2002 2
	r = *rm;
	a = *am;
d2004 39
a2042 27
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);

	if (r->log) {
		if (rewrite)
			m_copyback(m, off, sizeof(*th), (caddr_t)th);
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
	}

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNRST) ||
	    (r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		/* undo NAT/RST changes, if they have taken place */
		if (nat != NULL) {
			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
			    &th->th_sum, &baddr, bport, 0, af);
			rewrite++;
		} else if (rdr != NULL) {
			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
			    &th->th_sum, &baddr, bport, 0, af);
			rewrite++;
d2044 3
a2046 10
		if ((r->rule_flag & PFRULE_RETURNRST) ||
		    (r->rule_flag & PFRULE_RETURN))
			pf_send_reset(off, th, pd, af,
			    r->return_ttl, r);
		else if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
d2049 2
a2050 4
	if (r->action == PF_DROP)
		return (PF_DROP);

	if (r->keep_state || nat != NULL || rdr != NULL) {
d2056 2
a2057 1
		if (!r->max_states || r->states < r->max_states)
d2064 4
a2067 4
		r->states++;
		if (a != NULL)
			a->states++;
		s->rule.ptr = r;
d2069 1
a2069 1
			s->nat_rule.ptr = nat;
d2071 5
a2075 6
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d2109 1
a2109 1
		    r->keep_state == PF_STATE_MODULATE) {
d2132 1
a2132 1
		s->expire = s->creation + TIMEOUT(r, PFTM_TCP_FIRST_PACKET);
d2153 1
a2153 1
    struct pf_pdesc *pd, struct pf_rule **am)
d2164 1
a2164 1
	struct pf_rule		*r, *a = NULL;
d2169 2
d2238 1
a2238 1
				*am = a;
d2243 1
a2243 1
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
d2246 2
a2247 2
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
a2249 2
	r = *rm;
	a = *am;
d2251 34
a2284 26
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);

	if (r->log) {
		if (rewrite)
			m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
	}

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		/* undo NAT/RST changes, if they have taken place */
		if (nat != NULL) {
			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
			    &uh->uh_sum, &baddr, bport, 1, af);
			rewrite++;
		} else if (rdr != NULL) {
			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
			    &uh->uh_sum, &baddr, bport, 1, af);
			rewrite++;
d2286 3
a2288 6
		if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
d2291 2
a2292 4
	if (r->action == PF_DROP)
		return (PF_DROP);

	if (r->keep_state || nat != NULL || rdr != NULL) {
d2296 2
a2297 1
		if (!r->max_states || r->states < r->max_states)
d2302 2
a2303 3
		r->states++;
		if (a != NULL)
			a->states++;
d2305 1
a2305 1
		s->rule.ptr = r;
d2307 1
a2307 1
			s->nat_rule.ptr = nat;
d2309 5
a2313 6
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d2353 1
a2353 1
		s->expire = s->creation + TIMEOUT(r, PFTM_UDP_FIRST_PACKET);
d2374 1
a2374 1
    struct pf_pdesc *pd, struct pf_rule **am)
d2379 1
a2379 1
	struct pf_rule		*r, *a = NULL;
d2390 2
d2495 1
a2495 1
				*am = a;
d2500 1
a2500 1
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
d2503 2
a2504 2
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
a2506 2
	r = *rm;
	a = *am;
d2508 8
a2515 7
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);
d2517 1
a2517 1
	if (r->log) {
d2519 3
a2521 3
		if (rewrite)
			m_copyback(m, off, ICMP_MINLEN,
			    (caddr_t)pd->hdr.icmp6);
d2523 5
a2527 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d2530 1
a2530 4
	if (r->action != PF_PASS)
		return (PF_DROP);

	if (!state_icmp && (r->keep_state ||
d2535 2
a2536 1
		if (!r->max_states || r->states < r->max_states)
d2541 2
a2542 3
		r->states++;
		if (a != NULL)
			a->states++;
d2544 1
a2544 1
		s->rule.ptr = r;
d2546 1
a2546 1
			s->nat_rule.ptr = nat;
d2548 5
a2552 6
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d2588 1
a2588 1
		s->expire = s->creation + TIMEOUT(r, PFTM_ICMP_FIRST_PACKET);
d2611 1
a2611 2
    struct ifnet *ifp, struct mbuf *m, void *h, struct pf_pdesc *pd,
    struct pf_rule **am)
d2614 1
a2614 1
	struct pf_rule		*r, *a = NULL;
d2621 2
d2687 1
a2687 1
				*am = a;
d2692 1
a2692 1
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
d2695 2
a2696 2
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
a2698 2
	r = *rm;
	a = *am;
d2700 10
a2709 9
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);
	if (r->log)
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d2711 3
a2713 2
	if (r->action != PF_PASS)
		return (PF_DROP);
d2715 2
a2716 1
	if (r->keep_state || nat != NULL || rdr != NULL) {
d2720 2
a2721 1
		if (!r->max_states || r->states < r->max_states)
d2726 2
a2727 3
		r->states++;
		if (a != NULL)
			a->states++;
d2729 1
a2729 1
		s->rule.ptr = r;
d2731 1
a2731 1
			s->nat_rule.ptr = nat;
d2733 5
a2737 6
			s->nat_rule.ptr = rdr;
		if (s->nat_rule.ptr != NULL)
			s->nat_rule.ptr->states++;
		s->anchor.ptr = a;
		s->allow_opts = r->allow_opts;
		s->log = r->log & 2;
d2773 1
a2773 1
		s->expire = s->creation + TIMEOUT(r, PFTM_OTHER_FIRST_PACKET);
d2778 1
a2778 1
			if (r->log)
d2780 1
a2780 1
				    a ? a : r);
d2792 1
a2792 1
    struct mbuf *m, void *h, struct pf_pdesc *pd, struct pf_rule **am)
d2794 1
a2794 1
	struct pf_rule		*r, *a = NULL;
d2797 2
a2798 1
	u_short			 reason;
d2826 1
a2826 1
				*am = a;
d2831 1
a2831 1
				PF_STEP_INTO_ANCHOR(r, a, ruleset,
d2834 2
a2835 2
		if (r == NULL && a != NULL)
			PF_STEP_OUT_OF_ANCHOR(r, a, ruleset,
a2837 2
	r = *rm;
	a = *am;
d2839 2
a2840 9
	r->packets++;
	r->bytes += pd->tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd->tot_len;
	}
	REASON_SET(&reason, PFRES_MATCH);
	if (r->log)
		PFLOG_PACKET(ifp, h, m, af, direction, reason, a ? a : r);
d2842 13
a2854 2
	if (r->action != PF_PASS)
		return (PF_DROP);
d3150 7
a3156 9
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
d3216 7
a3222 9
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
d3772 7
a3778 9
	(*state)->rule.ptr->packets++;
	(*state)->rule.ptr->bytes += pd->tot_len;
	if ((*state)->nat_rule.ptr != NULL) {
		(*state)->nat_rule.ptr->packets++;
		(*state)->nat_rule.ptr->bytes += pd->tot_len;
	}
	if ((*state)->anchor.ptr != NULL) {
		(*state)->anchor.ptr->packets++;
		(*state)->anchor.ptr->bytes += pd->tot_len;
d4245 1
a4245 1
	struct pf_rule	*a = NULL, *r = &pf_default_rule;
d4293 1
a4293 1
		action = pf_test_fragment(&r, dir, ifp, m, h, &pd, &a);
d4325 1
a4325 1
			    m, 0, off, h, &pd, &a);
a4345 1
			a = s->anchor.ptr;
d4349 1
a4349 1
			    m, 0, off, h, &pd, &a);
d4370 3
a4372 6
			r->packets++;
			r->bytes += h->ip_len;
			a = s->anchor.ptr;
			if (a != NULL) {
				a->packets++;
				a->bytes += h->ip_len;
d4377 1
a4377 1
			    m, 0, off, h, &pd, &a);
a4384 1
			a = s->anchor.ptr;
d4387 1
a4387 1
			action = pf_test_other(&r, &s, dir, ifp, m, h, &pd, &a);
d4397 1
a4397 1
	if (r->src.addr.type == PF_ADDR_TABLE)
d4402 1
a4402 1
	if (r->dst.addr.type == PF_ADDR_TABLE)
d4409 1
a4409 1
	    !((s && s->allow_opts) || r->allow_opts)) {
d4418 1
a4418 1
	if (action != PF_DROP && r->qid) {
d4437 11
a4447 2
	if (log)
		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, a ? a : r);
d4450 1
a4450 1
	if (r->rt)
d4464 1
a4464 1
	struct pf_rule	*a = NULL, *r = &pf_default_rule;
d4500 1
a4500 1
			action = pf_test_fragment(&r, dir, ifp, m, h, &pd, &a);
d4560 1
a4560 1
			    m, 0, off, h, &pd, &a);
d4584 1
a4584 1
			    m, 0, off, h, &pd, &a);
d4606 4
a4609 2
			r->packets++;
			r->bytes += h->ip6_plen;
d4613 1
a4613 1
			    m, 0, off, h, &pd, &a);
d4618 1
a4618 1
		action = pf_test_other(&r, &s, dir, ifp, m, h, &pd, &a);
d4628 1
a4628 1
	if (r->src.addr.type == PF_ADDR_TABLE)
d4633 1
a4633 1
	if (r->dst.addr.type == PF_ADDR_TABLE)
d4642 1
a4642 1
	if (action != PF_DROP && r->qid) {
d4661 11
a4671 2
	if (log)
		PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, a ? a : r);
d4674 1
a4674 1
	if (r->rt)
@


1.1.1.4
log
@Import OpenBSD source with the "new" command line as well,
in order to be able to provide a MirBSD release which bases
upon a fairly current OpenBSD base source code tree deemed
stable enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.337 2003/04/11 14:40:57 henning Exp $ */
a182 2
void			 pf_rule_set_qid(struct pf_rulequeue *);
u_int32_t		 pf_qname_to_qid(char *);
a805 27
}

void
pf_rule_set_qid(struct pf_rulequeue *rules)
{
	struct pf_rule *rule;

	TAILQ_FOREACH(rule, rules, entries)
		if (rule->qname[0] != 0) {
			rule->qid = pf_qname_to_qid(rule->qname);
			if (rule->pqname[0] != 0)
				rule->pqid = pf_qname_to_qid(rule->pqname);
			else
				rule->pqid = rule->qid;
		}
}

u_int32_t
pf_qname_to_qid(char *qname)
{
	struct pf_altq		*altq;

	TAILQ_FOREACH(altq, pf_altqs_active, entries)
		if (!strcmp(altq->qname, qname))
			return (altq->qid);

	return (0);
@


1.1.1.5
log
@Import OpenBSD cvs as of now, CTM delta 3255, just before the i386 flag day
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.339 2003/04/30 12:30:27 cedric Exp $ */
d120 2
d495 1
a495 1
pf_tbladdr_setup(struct pf_ruleset *rs, struct pf_addr_wrap *aw)
d499 1
a499 1
	if ((aw->p.tbl = pfr_attach_table(rs, aw->v.tblname)) == NULL)
d1553 1
d1592 7
a1598 2
			if (low > high) {
				u_int16_t tmp;
d1600 3
a1602 8
				tmp = low;
				low = high;
				high = tmp;
			}
			/* low < high */
			cut = arc4random() % (1 + high - low) + low;
			/* low <= cut <= high */
			for (*nport = cut; *nport <= high; ++(*nport)) {
d1606 6
a1611 2
			}
			for (*nport = cut - 1; *nport >= low; --(*nport)) {
d1615 1
a1615 1
			}
@


1.1.1.6
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.340 2003/05/06 21:21:23 dhartmei Exp $ */
a2632 1
			PF_ACPY(&baddr, daddr, af);
@


1.1.1.7
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.360 2003/05/18 19:58:56 henning Exp $ */
d62 1
a101 1
struct pf_tagnames	 pf_tagnames;
d130 2
d140 3
a142 4
void			 pf_send_tcp(const struct pf_rule *, sa_family_t,
			    const struct pf_addr *, const struct pf_addr *,
			    u_int16_t, u_int16_t, u_int32_t, u_int32_t,
			    u_int8_t, u_int16_t, u_int8_t);
d152 6
a157 8
int			 pf_test_tcp(struct pf_rule **, struct pf_state **,
			    int, struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
int			 pf_test_udp(struct pf_rule **, struct pf_state **,
			    int, struct ifnet *, struct mbuf *, int, int,
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
d160 1
a160 2
			    void *, struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
d163 1
a163 2
			    struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
d166 1
a166 2
			    struct pf_pdesc *, struct pf_rule **,
			    struct pf_ruleset **);
d169 1
a169 1
			    void *, struct pf_pdesc *, u_short *);
d178 2
a182 6
struct pf_tag		*pf_get_tag(struct mbuf *);
int			 pf_match_tag(struct mbuf *, struct pf_rule *,
			     struct pf_rule *, struct pf_rule *,
			     struct pf_tag *, int *);
int			 pf_tag_packet(struct mbuf *, struct pf_tag *,
			     int);
d198 2
d240 3
d273 1
a273 1
		if (a->addr[0].addr32[3] > b->addr[0].addr32[3])
d275 1
a275 1
		if (a->addr[0].addr32[3] < b->addr[0].addr32[3])
d277 1
a277 1
		if (a->addr[1].addr32[3] > b->addr[1].addr32[3])
d279 1
a279 1
		if (a->addr[1].addr32[3] < b->addr[1].addr32[3])
d285 1
a285 1
		if (a->addr[1].addr32[2] > b->addr[1].addr32[2])
d287 1
a287 1
		if (a->addr[1].addr32[2] < b->addr[1].addr32[2])
d289 1
a289 1
		if (a->addr[0].addr32[1] > b->addr[0].addr32[1])
d291 1
a291 1
		if (a->addr[0].addr32[1] < b->addr[0].addr32[1])
d297 1
a297 1
		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
d299 1
a299 1
		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
d301 1
a301 1
		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
d303 1
a303 1
		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
a441 36
u_int32_t
pf_state_expires(const struct pf_state *state)
{
	u_int32_t	timeout;
	u_int32_t	start;
	u_int32_t	end;
	u_int32_t	states;

	/* handle all PFTM_* > PFTM_MAX here */
	if (state->timeout == PFTM_PURGE)
		return (time.tv_sec);
	if (state->timeout == PFTM_UNTIL_PACKET)
		return (0);
	KASSERT(state->timeout < PFTM_MAX);
	timeout = state->rule.ptr->timeout[state->timeout];
	if (!timeout)
		timeout = pf_default_rule.timeout[state->timeout];
	start = state->rule.ptr->timeout[PFTM_ADAPTIVE_START];
	if (start) {
		end = state->rule.ptr->timeout[PFTM_ADAPTIVE_END];
		states = state->rule.ptr->states;
	} else {
		start = pf_default_rule.timeout[PFTM_ADAPTIVE_START];
		end = pf_default_rule.timeout[PFTM_ADAPTIVE_END];
		states = pf_status.states;
	}
	if (end && states > start && start < end) {
		if (states < end)
			return (state->expire + timeout * (end - states) /
			    (end - start));
		else
			return (time.tv_sec);
	}
	return (state->expire + timeout);
}

d451 1
a451 11
		if (pf_state_expires(cur->state) <= time.tv_sec) {
			if (cur->state->src.state == PF_TCPS_PROXY_DST)
				pf_send_tcp(cur->state->rule.ptr,
				    cur->state->af,
				    &cur->state->ext.addr,
				    &cur->state->lan.addr,
				    cur->state->ext.port,
				    cur->state->lan.port,
				    cur->state->src.seqhi,
				    cur->state->src.seqlo + 1,
				    TH_RST|TH_ACK, 0, 0);
a482 1
			pf_normalize_tcp_cleanup(cur->state);
a908 2

/* Changes a u_int32_t.  Uses a void * so there are no align restrictions */
d910 1
a910 1
pf_change_a(void *a, u_int16_t *c, u_int32_t an, u_int8_t u)
d912 1
a912 1
	u_int32_t	ao;
d914 1
a914 2
	memcpy(&ao, a, sizeof(ao));
	memcpy(a, &an, sizeof(u_int32_t));
d948 2
d954 2
d957 6
a962 14
	if (ip != NULL) {
		u_int16_t	oip = *ip;
		u_int32_t	opc;

		if (pc != NULL)
			opc = *pc;
		*ip = np;
		if (pc != NULL)
			*pc = pf_cksum_fixup(*pc, oip, *ip, u);
		*ic = pf_cksum_fixup(*ic, oip, *ip, 0);
		if (pc != NULL)
			*ic = pf_cksum_fixup(*ic, opc, *pc, 0);
	}
	/* Change inner ip address, fix inner ip and icmp checksums. */
d964 1
d996 1
a996 1
	/* Change outer ip address, fix outer ip or icmpv6 checksum. */
d1025 2
a1026 4
pf_send_tcp(const struct pf_rule *r, sa_family_t af,
    const struct pf_addr *saddr, const struct pf_addr *daddr,
    u_int16_t sport, u_int16_t dport, u_int32_t seq, u_int32_t ack,
    u_int8_t flags, u_int16_t win, u_int8_t ttl)
d1032 1
a1032 1
	struct ip	*h;
d1035 1
a1035 1
	struct ip6_hdr	*h6;
d1037 1
a1037 1
	struct tcphdr	*th;
d1052 4
a1065 15
#ifdef ALTQ
	if (r != NULL && r->qid) {
		struct altq_tag *atag;

		mtag = m_tag_get(PACKET_TAG_PF_QID, sizeof(*atag), M_NOWAIT);
		if (mtag != NULL) {
			atag = (struct altq_tag *)(mtag + 1);
			atag->qid = r->qid;
			/* add hints for ecn */
			atag->af = af;
			atag->hdr = mtod(m, struct ip *);
			m_tag_prepend(m, mtag);
		}
	}
#endif
d1073 1
a1073 1
		h = mtod(m, struct ip *);
d1076 4
a1079 4
		h->ip_p = IPPROTO_TCP;
		h->ip_len = htons(sizeof(*th));
		h->ip_src.s_addr = saddr->v4.s_addr;
		h->ip_dst.s_addr = daddr->v4.s_addr;
d1081 1
a1081 1
		th = (struct tcphdr *)((caddr_t)h + sizeof(struct ip));
d1086 1
a1086 1
		h6 = mtod(m, struct ip6_hdr *);
d1089 4
a1092 4
		h6->ip6_nxt = IPPROTO_TCP;
		h6->ip6_plen = htons(sizeof(*th));
		memcpy(&h6->ip6_src, &saddr->v6, sizeof(struct in6_addr));
		memcpy(&h6->ip6_dst, &daddr->v6, sizeof(struct in6_addr));
d1094 1
a1094 1
		th = (struct tcphdr *)((caddr_t)h6 + sizeof(struct ip6_hdr));
d1100 31
a1130 7
	th->th_sport = sport;
	th->th_dport = dport;
	th->th_seq = htonl(seq);
	th->th_ack = htonl(ack);
	th->th_off = sizeof(*th) >> 2;
	th->th_flags = flags;
	th->th_win = htons(win);
d1136 1
a1136 1
		th->th_sum = in_cksum(m, len);
d1139 8
a1146 7
		h->ip_v = 4;
		h->ip_hl = sizeof(*h) >> 2;
		h->ip_tos = IPTOS_LOWDELAY;
		h->ip_len = len;
		h->ip_off = ip_mtudisc ? IP_DF : 0;
		h->ip_ttl = ttl ? ttl : ip_defttl;
		h->ip_sum = 0;
d1154 1
a1154 1
		th->th_sum = in6_cksum(m, IPPROTO_TCP,
d1157 4
a1160 2
		h6->ip6_vfc |= IPV6_VERSION;
		h6->ip6_hlim = IPV6_DEFHLIM;
a1310 51
struct pf_tag *
pf_get_tag(struct mbuf *m)
{
	struct m_tag	*mtag;

	if ((mtag = m_tag_find(m, PACKET_TAG_PF_TAG, NULL)) != NULL)
		return ((struct pf_tag *)(mtag + 1));
	else
		return (NULL);
}

int
pf_match_tag(struct mbuf *m, struct pf_rule *r, struct pf_rule *nat,
    struct pf_rule *rdr, struct pf_tag *pftag, int *tag)
{
	if (*tag == -1) {	/* find mbuf tag */
		pftag = pf_get_tag(m);
		if (pftag != NULL)
			*tag = pftag->tag;
		else
			*tag = 0;
		if (nat != NULL && nat->tag)
			*tag = nat->tag;
		if (rdr != NULL && rdr->tag)
			*tag = rdr->tag;
	}

	return ((!r->match_tag_not && r->match_tag == *tag) ||
	    (r->match_tag_not && r->match_tag != *tag));
}

int
pf_tag_packet(struct mbuf *m, struct pf_tag *pftag, int tag)
{
	struct m_tag	*mtag;

	if (tag <= 0)
		return (0);

	if (pftag == NULL) {
		mtag = m_tag_get(PACKET_TAG_PF_TAG, sizeof(*pftag), M_NOWAIT);
		if (mtag == NULL)
			return (1);
		((struct pf_tag *)(mtag + 1))->tag = tag;
		m_tag_prepend(m, mtag);
	} else
		pftag->tag = tag;

	return (0);
}

d1758 2
a1759 1
			if (pf_map_addr(r->af, &r->rpool, saddr, naddr, NULL))
d1898 1
a1898 1
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
a1912 2
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
a1979 3
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
			r = TAILQ_NEXT(r, entries);
a1980 2
			if (r->tag)
				tag = r->tag;
a1983 1
				*rsm = ruleset;
a1996 1
	ruleset = *rsm;
d2009 1
a2009 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
d2016 1
a2016 1
		/* undo NAT changes, if they have taken place */
d2026 5
a2030 14
		if (((r->rule_flag & PFRULE_RETURNRST) ||
		    (r->rule_flag & PFRULE_RETURN)) &&
		    !(th->th_flags & TH_RST)) {
			u_int32_t ack = ntohl(th->th_seq) + pd->p_len;

			if (th->th_flags & TH_SYN)
				ack++;
			if (th->th_flags & TH_FIN)
				ack++;
			pf_send_tcp(r, af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    ntohl(th->th_ack), ack, TH_RST|TH_ACK, 0,
			    r->return_ttl);
		} else if ((af == AF_INET) && r->return_icmp)
d2041 1
a2041 7
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

	if (r->keep_state || nat != NULL || rdr != NULL ||
	    (pd->flags & PFDESC_TCP_NORM)) {
a2112 8
		s->src.max_win = MAX(ntohs(th->th_win), 1);
		if (s->src.wscale & PF_WSCALE_MASK) {
			/* Remove scale factor from initial window */
			int win = s->src.max_win;
			win += 1 << (s->src.wscale & PF_WSCALE_MASK);
			s->src.max_win = (win - 1) >>
			    (s->src.wscale & PF_WSCALE_MASK);
		}
d2115 1
d2123 1
a2123 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_TCP_FIRST_PACKET;
a2125 14

		if ((pd->flags & PFDESC_TCP_NORM) && pf_normalize_tcp_init(m,
		    off, pd, th, &s->src, &s->dst)) {
			REASON_SET(&reason, PFRES_MEMORY);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
		if ((pd->flags & PFDESC_TCP_NORM) && s->src.scrub &&
		    pf_normalize_tcp_stateful(m, off, pd, &reason, th, &s->src,
		    &s->dst, &rewrite)) {
			pf_normalize_tcp_cleanup(s);
			pool_put(&pf_state_pl, s);
			return (PF_DROP);
		}
a2126 1
			pf_normalize_tcp_cleanup(s);
a2131 17
		if ((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
		    r->keep_state == PF_STATE_SYNPROXY) {
			s->src.state = PF_TCPS_PROXY_SRC;
			if (nat != NULL)
				pf_change_ap(saddr, &th->th_sport,
				    pd->ip_sum, &th->th_sum, &baddr,
				    bport, 0, af);
			else if (rdr != NULL)
				pf_change_ap(daddr, &th->th_dport,
				    pd->ip_sum, &th->th_sum, &baddr,
				    bport, 0, af);
			s->src.seqhi = arc4random();
			pf_send_tcp(r, af, daddr, saddr, th->th_dport,
			    th->th_sport, s->src.seqhi,
			    ntohl(th->th_seq) + 1, TH_SYN|TH_ACK, 0, 0);
			return (PF_SYNPROXY_DROP);
		}
d2144 1
a2144 1
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
a2158 2
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
a2221 3
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
			r = TAILQ_NEXT(r, entries);
a2224 2
			if (r->tag)
				tag = r->tag;
a2227 1
				*rsm = ruleset;
a2240 1
	ruleset = *rsm;
d2253 1
a2253 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
d2259 1
a2259 1
		/* undo NAT changes, if they have taken place */
a2279 5
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

d2342 1
a2342 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_UDP_FIRST_PACKET;
d2363 1
a2363 1
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm)
a2374 2
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
a2476 3
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
			r = TAILQ_NEXT(r, entries);
a2479 2
			if (r->tag)
				tag = r->tag;
a2482 1
				*rsm = ruleset;
a2495 1
	ruleset = *rsm;
d2508 1
a2508 1
			m_copyback(m, off, sizeof(struct icmp6_hdr),
d2511 1
a2511 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
a2516 5
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

d2576 1
a2576 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_ICMP_FIRST_PACKET;
d2590 1
a2590 1
		m_copyback(m, off, sizeof(struct icmp6_hdr),
d2600 1
a2600 1
    struct pf_rule **am, struct pf_ruleset **rsm)
a2608 2
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
a2669 3
		else if (r->match_tag &&
		    !pf_match_tag(m, r, nat, rdr, pftag, &tag))
			r = TAILQ_NEXT(r, entries);
a2672 2
			if (r->tag)
				tag = r->tag;
a2675 1
				*rsm = ruleset;
a2688 1
	ruleset = *rsm;
d2698 1
a2698 33
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);

	if ((r->action == PF_DROP) &&
	    ((r->rule_flag & PFRULE_RETURNICMP) ||
	    (r->rule_flag & PFRULE_RETURN))) {
		struct pf_addr *a = NULL;

		if (nat != NULL)
			a = saddr;
		else if (rdr != NULL)
			a = daddr;
		if (a != NULL) {
			switch (af) {
#ifdef INET
			case AF_INET:
				pf_change_a(&a->v4.s_addr, pd->ip_sum,
				    baddr.v4.s_addr, 0);
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				PF_ACPY(a, &baddr, af);
				break;
#endif /* INET6 */
			}
		}
		if ((af == AF_INET) && r->return_icmp)
			pf_send_icmp(m, r->return_icmp >> 8,
			    r->return_icmp & 255, af, r);
		else if ((af == AF_INET6) && r->return_icmp6)
			pf_send_icmp(m, r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, af, r);
	}
a2702 5
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

d2761 1
a2761 2
		s->expire = time.tv_sec;
		s->timeout = PFTM_OTHER_FIRST_PACKET;
d2768 1
a2768 1
				    r, a, ruleset);
d2780 1
a2780 2
    struct mbuf *m, void *h, struct pf_pdesc *pd, struct pf_rule **am,
    struct pf_ruleset **rsm)
a2785 2
	struct pf_tag		*pftag = NULL;
	int			 tag = -1;
a2807 3
		else if (r->match_tag &&
		    !pf_match_tag(m, r, NULL, NULL, pftag, &tag))
			r = TAILQ_NEXT(r, entries);
a2813 1
				*rsm = ruleset;
a2826 1
	ruleset = *rsm;
d2836 1
a2836 1
		PFLOG_PACKET(ifp, h, m, af, direction, reason, r, a, ruleset);
a2840 5
	if (pf_tag_packet(m, pftag, tag)) {
		REASON_SET(&reason, PFRES_MEMORY);
		return (PF_DROP);
	}

d2846 1
a2846 2
    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd,
    u_short *reason)
a2853 1
	int			 copyback = 0;
a2872 70
	if ((*state)->src.state == PF_TCPS_PROXY_SRC) {
		if (direction != (*state)->direction)
			return (PF_SYNPROXY_DROP);
		if (th->th_flags & TH_SYN) {
			if (ntohl(th->th_seq) != (*state)->src.seqlo)
				return (PF_DROP);
			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    (*state)->src.seqhi, ntohl(th->th_seq) + 1,
			    TH_SYN|TH_ACK, 0, 0);
			return (PF_SYNPROXY_DROP);
		} else if (!(th->th_flags & TH_ACK) ||
		    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
		    (ntohl(th->th_seq) != (*state)->src.seqlo + 1))
			return (PF_DROP);
		else
			(*state)->src.state = PF_TCPS_PROXY_DST;
	}
	if ((*state)->src.state == PF_TCPS_PROXY_DST) {
		struct pf_state_host *src, *dst;

		if (direction == PF_OUT) {
			src = &(*state)->gwy;
			dst = &(*state)->ext;
		} else {
			src = &(*state)->ext;
			dst = &(*state)->lan;
		}
		if (direction == (*state)->direction) {
			if (((th->th_flags & (TH_SYN|TH_ACK)) != TH_ACK) ||
			    (ntohl(th->th_ack) != (*state)->src.seqhi + 1) ||
			    (ntohl(th->th_seq) != (*state)->src.seqlo + 1))
				return (PF_DROP);
			(*state)->src.max_win = MAX(ntohs(th->th_win), 1);
			if ((*state)->dst.seqhi == 1)
				(*state)->dst.seqhi = arc4random();
			pf_send_tcp((*state)->rule.ptr, pd->af, &src->addr,
			    &dst->addr, src->port, dst->port,
			    (*state)->dst.seqhi, 0, TH_SYN, 0, 0);
			return (PF_SYNPROXY_DROP);
		} else if (((th->th_flags & (TH_SYN|TH_ACK)) !=
		    (TH_SYN|TH_ACK)) ||
		    (ntohl(th->th_ack) != (*state)->dst.seqhi + 1))
			return (PF_DROP);
		else {
			(*state)->dst.max_win = MAX(ntohs(th->th_win), 1);
			(*state)->dst.seqlo = ntohl(th->th_seq);
			pf_send_tcp((*state)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    ntohl(th->th_ack), ntohl(th->th_seq) + 1,
			    TH_ACK, (*state)->src.max_win, 0);
			pf_send_tcp((*state)->rule.ptr, pd->af, &src->addr,
			    &dst->addr, src->port, dst->port,
			    (*state)->src.seqhi + 1, (*state)->src.seqlo + 1,
			    TH_ACK, (*state)->dst.max_win, 0);
			(*state)->src.seqdiff = (*state)->dst.seqhi -
			    (*state)->src.seqlo;
			(*state)->dst.seqdiff = (*state)->src.seqhi -
			    (*state)->dst.seqlo;
			(*state)->src.seqhi = (*state)->src.seqlo +
			    (*state)->src.max_win;
			(*state)->dst.seqhi = (*state)->dst.seqlo +
			    (*state)->dst.max_win;
			(*state)->src.wscale = (*state)->dst.wscale = 0;
			(*state)->src.state = (*state)->dst.state =
			    TCPS_ESTABLISHED;
			return (PF_SYNPROXY_DROP);
		}
	}

a2888 8
		if ((pd->flags & PFDESC_TCP_NORM || dst->scrub) &&
		    src->scrub == NULL) {
			if (pf_normalize_tcp_init(m, off, pd, th, src, dst)) {
				REASON_SET(reason, PFRES_MEMORY);
				return (PF_DROP);
			}
		}

d2890 1
a2890 1
		if (dst->seqdiff && !src->seqdiff) {
a2896 1
			copyback = 1;
d2904 1
a2904 18
			if (dst->wscale & PF_WSCALE_FLAG) {
				src->wscale = pf_get_wscale(m, off, th->th_off,
				    pd->af);
				if (src->wscale & PF_WSCALE_FLAG) {
					/* Remove scale factor from initial
					 * window */
					sws = src->wscale & PF_WSCALE_MASK;
					win = ((u_int32_t)win + (1 << sws) - 1)
					    >> sws;
					dws = dst->wscale & PF_WSCALE_MASK;
				} else {
					/* fixup other window */
					dst->max_win <<= dst->wscale &
					    PF_WSCALE_MASK;
					/* in case of a retrans SYN|ACK */
					dst->wscale = 0;
				}
			}
a2930 1
			copyback = 1;
d2967 2
a2968 2
	    /* Acking not more than one reassembled fragment backwards */
	    (ackskew <= (MAXACKWINDOW << dws))) {
a3001 1
		(*state)->expire = time.tv_sec;
d3004 2
a3005 1
			(*state)->timeout = PFTM_TCP_CLOSED;
d3008 2
a3009 1
			(*state)->timeout = PFTM_TCP_FIN_WAIT;
d3012 2
a3013 1
			(*state)->timeout = PFTM_TCP_OPENING;
d3016 2
a3017 1
			(*state)->timeout = PFTM_TCP_CLOSING;
d3019 2
a3020 1
			(*state)->timeout = PFTM_TCP_ESTABLISHED;
d3091 2
a3092 13
			if (!(th->th_flags & TH_RST)) {
				u_int32_t ack = ntohl(th->th_seq) + pd->p_len;

				if (th->th_flags & TH_SYN)
					ack++;
				if (th->th_flags & TH_FIN)
					ack++;
				pf_send_tcp((*state)->rule.ptr, pd->af,
				    pd->dst, pd->src, th->th_dport,
				    th->th_sport, ntohl(th->th_ack), ack,
				    TH_RST|TH_ACK, 0,
				    (*state)->rule.ptr->return_ttl);
			}
a3116 6
	if (dst->scrub || src->scrub) {
		if (pf_normalize_tcp_stateful(m, off, pd, reason, th, src, dst,
		    &copyback))
			return (PF_DROP);
	}

d3130 2
a3131 2
	} else if (copyback) {
		/* Copyback sequence modulation or stateful scrub changes */
a3182 1
	(*state)->expire = time.tv_sec;
d3184 2
a3185 1
		(*state)->timeout = PFTM_UDP_MULTIPLE;
d3187 2
a3188 1
		(*state)->timeout = PFTM_UDP_SINGLE;
d3274 2
a3275 2
		(*state)->expire = time.tv_sec;
		(*state)->timeout = PFTM_ICMP_ERROR_REPLY;
d3293 1
a3293 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3312 1
a3312 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3506 1
a3506 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3567 1
a3567 2
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
d3634 2
a3635 2
			if (!pf_pull_hdr(m, off2, &iih,
			    sizeof(struct icmp6_hdr), NULL, NULL, pd2.af)) {
d3665 1
a3665 1
				m_copyback(m, off, sizeof(struct icmp6_hdr),
d3669 1
a3669 1
				m_copyback(m, off2, sizeof(struct icmp6_hdr),
d3677 5
a3681 9
		default: {
			struct pf_tree_node	key;

			key.af = pd2.af;
			key.proto = pd2.proto;
			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
			key.port[0] = 0;
			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
			key.port[1] = 0;
a3682 41
			STATE_LOOKUP();

			if (STATE_TRANSLATE(*state)) {
				if (direction == PF_IN) {
					pf_change_icmp(pd2.src, NULL,
					    daddr, &(*state)->lan.addr,
					    0, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
				} else {
					pf_change_icmp(pd2.dst, NULL,
					    saddr, &(*state)->gwy.addr,
					    0, NULL,
					    pd2.ip_sum, icmpsum,
					    pd->ip_sum, 0, pd2.af);
				}
				switch (pd2.af) {
#ifdef INET
				case AF_INET:
					m_copyback(m, off, ICMP_MINLEN,
					    (caddr_t)pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2),
					    (caddr_t)&h2);
					break;
#endif /* INET */
#ifdef INET6
				case AF_INET6:
					m_copyback(m, off,
					    sizeof(struct icmp6_hdr),
					    (caddr_t)pd->hdr.icmp6);
					m_copyback(m, ipoff2, sizeof(h2_6),
					    (caddr_t)&h2_6);
					break;
#endif /* INET6 */
				}
			}

			return (PF_PASS);
			break;
		}
		}
a3719 1
	(*state)->expire = time.tv_sec;
d3721 2
a3722 1
		(*state)->timeout = PFTM_OTHER_MULTIPLE;
d3724 2
a3725 1
		(*state)->timeout = PFTM_OTHER_SINGLE;
d4233 8
a4240 9
	u_short		   action, reason = 0, log = 0;
	struct mbuf	  *m = *m0;
	struct ip	  *h;
	struct pf_rule	  *a = NULL, *r = &pf_default_rule;
	struct pf_state	  *s = NULL;
	struct pf_ruleset *ruleset = NULL;
	struct pf_pdesc	   pd;
	int		   off;
	int		   pqid = 0;
d4260 1
a4260 1
		action = PF_DROP;
d4284 1
a4284 2
		action = pf_test_fragment(&r, dir, ifp, m, h,
		    &pd, &a, &ruleset);
d4310 1
a4310 2
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd,
		    &reason);
d4316 1
a4316 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4341 1
a4341 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4372 1
a4372 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4383 1
a4383 2
			action = pf_test_other(&r, &s, dir, ifp, m, h,
			    &pd, &a, &ruleset);
d4389 1
a4389 1
		pf_status.pcounters[0][dir == PF_OUT][action != PF_PASS]++;
d4404 1
a4404 1
	if (action == PF_PASS && h->ip_hl > 5 &&
d4414 1
a4414 1
	if (action == PF_PASS && r->qid) {
d4434 1
a4434 1
		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, r, a, ruleset);
d4436 2
a4437 6
	if (action == PF_SYNPROXY_DROP) {
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} else if (r->rt)
		/* pf_route can free the mbuf causing *m0 to become NULL */
d4448 7
a4454 8
	u_short		   action, reason = 0, log = 0;
	struct mbuf	  *m = *m0;
	struct ip6_hdr	  *h;
	struct pf_rule	  *a = NULL, *r = &pf_default_rule;
	struct pf_state	  *s = NULL;
	struct pf_ruleset *ruleset = NULL;
	struct pf_pdesc    pd;
	int		   off, terminal = 0;
d4487 1
a4487 2
			action = pf_test_fragment(&r, dir, ifp, m, h,
			    &pd, &a, &ruleset);
d4541 1
a4541 2
		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd,
		    &reason);
d4547 1
a4547 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4571 1
a4571 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4598 1
a4598 1
			    m, 0, off, h, &pd, &a, &ruleset);
d4603 1
a4603 2
		action = pf_test_other(&r, &s, dir, ifp, m, h,
		    &pd, &a, &ruleset);
d4609 1
a4609 1
		pf_status.pcounters[1][dir == PF_OUT][action != PF_PASS]++;
d4627 1
a4627 1
	if (action == PF_PASS && r->qid) {
d4647 1
a4647 1
		PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, r, a, ruleset);
d4649 2
a4650 6
	if (action == PF_SYNPROXY_DROP) {
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} else if (r->rt)
		/* pf_route6 can free the mbuf causing *m0 to become NULL */
@


1.1.1.8
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.361 2003/06/03 12:34:04 henning Exp $ */
d189 2
@


1.1.1.9
log
@MFC latest OpenBSD fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.362 2003/06/09 11:14:46 mcbride Exp $ */
d1663 4
d1670 1
d1676 1
a1676 1
				*nport = htons(low);
d1680 2
a1681 1
			u_int16_t tmp;
a1682 1
			if (low > high) {
d1690 3
a1692 5
			for (tmp = cut; tmp <= high; ++(tmp)) {
				key.port[1] = htons(tmp);
				if (pf_find_state(&tree_ext_gwy, &key) ==
				    NULL) {
					*nport = htons(tmp);
a1693 1
				}
d1695 3
a1697 5
			for (tmp = cut - 1; tmp >= low; --(tmp)) {
				key.port[1] = htons(tmp);
				if (pf_find_state(&tree_ext_gwy, &key) ==
				    NULL) {
					*nport = htons(tmp);
a1698 1
				}
@


1.1.1.10
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.364 2003/06/14 07:23:15 dhartmei Exp $ */
d3312 1
a3312 1
	    (ackskew <= (MAXACKWINDOW << sws))) {
d3461 1
a3461 1
			    (ackskew <= (MAXACKWINDOW << sws)) ? ' ' : '4',
a4678 1
	memset(&pd, 0, sizeof(pd));
a4887 1
	memset(&pd, 0, sizeof(pd));
@


1.1.1.11
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.371 2003/06/29 12:25:03 itojun Exp $ */
a79 1
#include <netinet6/nd6.h>
d101 1
d113 7
d141 1
a141 1
			    u_int8_t, u_int16_t, u_int16_t, u_int8_t);
d182 3
a211 4
u_int16_t		 pf_get_mss(struct mbuf *, int, u_int16_t,
			    sa_family_t);
u_int16_t		 pf_calc_mss(struct pf_addr *, sa_family_t,
				u_int16_t);
a497 1
					0,
d1082 1
a1082 1
    u_int8_t flags, u_int16_t win, u_int16_t mss, u_int8_t ttl)
d1086 1
a1086 1
	int		 len, tlen;
a1093 6
	char *opt;

	/* maximum segment size tcp option */
	tlen = sizeof(struct tcphdr);
	if (mss)
		tlen += 4;
d1098 1
a1098 1
		len = sizeof(struct ip) + tlen;
d1103 1
a1103 1
		len = sizeof(struct ip6_hdr) + tlen;
d1144 1
a1144 1
		h->ip_len = htons(tlen);
d1157 1
a1157 1
		h6->ip6_plen = htons(tlen);
d1171 1
a1171 1
	th->th_off = tlen >> 2;
a1174 8
	if (mss) {
		opt = (char *)(th + 1);
		opt[0] = TCPOPT_MAXSEG;
		opt[1] = 4;
		HTONS(mss);
		bcopy((caddr_t)&mss, (caddr_t)(opt + 2), 2);
	}

d1197 1
a1197 1
		    sizeof(struct ip6_hdr), tlen);
a1985 88
u_int16_t
pf_get_mss(struct mbuf *m, int off, u_int16_t th_off, sa_family_t af)
{
	int		 hlen;
	u_int8_t	 hdr[60];
	u_int8_t	*opt, optlen;
	u_int16_t	 mss = tcp_mssdflt;

	hlen = th_off << 2;	/* hlen <= sizeof(hdr) */
	if (hlen <= sizeof(struct tcphdr))
		return (0);
	if (!pf_pull_hdr(m, off, hdr, hlen, NULL, NULL, af))
		return (0);
	opt = hdr + sizeof(struct tcphdr);
	hlen -= sizeof(struct tcphdr);
	while (hlen >= TCPOLEN_MAXSEG) {
		switch (*opt) {
		case TCPOPT_EOL:
		case TCPOPT_NOP:
			++opt;
			--hlen;
			break;
		case TCPOPT_MAXSEG:
			bcopy((caddr_t)(opt + 2), (caddr_t)&mss, 2);
			/* fallthrough */
		default:
			optlen = opt[1];
			if (optlen < 2)
				optlen = 2;
			hlen -= optlen;
			opt += optlen;
		}
	}
	return (mss);
}

u_int16_t
pf_calc_mss(struct pf_addr *addr, sa_family_t af, u_int16_t offer)
{
#ifdef INET
	struct sockaddr_in	*dst;
	struct route		 ro;
#endif /* INET */
#ifdef INET6
	struct sockaddr_in6	*dst6;
	struct route_in6	 ro6;
#endif /* INET6 */
	struct rtentry		*rt = NULL;
	int			 hlen;
	u_int16_t		 mss = tcp_mssdflt;

	switch (af) {
#ifdef INET
	case AF_INET:
		hlen = sizeof(struct ip);
		bzero(&ro, sizeof(ro));
		dst = (struct sockaddr_in *)&ro.ro_dst;
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = addr->v4;
		rtalloc_noclone(&ro, NO_CLONING);
		rt = ro.ro_rt;
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		hlen = sizeof(struct ip6_hdr);
		bzero(&ro6, sizeof(ro6));
		dst6 = (struct sockaddr_in6 *)&ro6.ro_dst;
		dst6->sin6_family = AF_INET6;
		dst6->sin6_len = sizeof(*dst6);
		dst6->sin6_addr = addr->v6;
		rtalloc_noclone((struct route *)&ro6, NO_CLONING);
		rt = ro6.ro_rt;
		break;
#endif /* INET6 */
	}

	if (rt && rt->rt_ifp) {
		mss = rt->rt_ifp->if_mtu - hlen - sizeof(struct tcphdr);
		mss = max(tcp_mssdflt, mss);
		RTFREE(rt);
	}
	mss = min(mss, offer);
	mss = max(mss, 64);		/* sanity - at least max opt space */
	return (mss);
}

a2005 1
	u_int16_t		 mss = tcp_mssdflt;
d2137 1
a2137 1
			    ntohl(th->th_ack), ack, TH_RST|TH_ACK, 0, 0,
d2247 2
a2248 2
		s->packets[0] = 1;
		s->bytes[0] = pd->tot_len;
a2281 5
			/* Find mss option */
			mss = pf_get_mss(m, off, th->th_off, af);
			mss = pf_calc_mss(saddr, af, mss);
			mss = pf_calc_mss(daddr, af, mss);
			s->src.mss = mss;
d2284 1
a2284 1
			    ntohl(th->th_seq) + 1, TH_SYN|TH_ACK, 0, s->src.mss, 0);
d2513 2
a2514 2
		s->packets[0] = 1;
		s->bytes[0] = pd->tot_len;
d2762 2
a2763 2
		s->packets[0] = 1;
		s->bytes[0] = pd->tot_len;
d2994 2
a2995 2
		s->packets[0] = 1;
		s->bytes[0] = pd->tot_len;
d3099 1
a3099 1
	int			 ackskew, dirndx;
a3114 1
		dirndx = 0;
a3117 1
		dirndx = 1;
d3129 1
a3129 1
			    TH_SYN|TH_ACK, 0, (*state)->src.mss, 0);
d3158 1
a3158 1
			    (*state)->dst.seqhi, 0, TH_SYN, 0, (*state)->src.mss, 0);
d3170 1
a3170 1
			    TH_ACK, (*state)->src.max_win, 0, 0);
d3174 1
a3174 1
			    TH_ACK, (*state)->dst.max_win, 0, 0);
d3315 2
a3316 2
		(*state)->packets[dirndx]++;
		(*state)->bytes[dirndx] += pd->tot_len;
d3397 2
a3398 3
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d:%d\n",
			    seq, ack, pd->p_len, ackskew,
			    (*state)->packets[0], (*state)->packets[1]);
d3401 2
a3402 2
		(*state)->packets[dirndx]++;
		(*state)->bytes[dirndx] += pd->tot_len;
d3441 1
a3441 1
				    TH_RST|TH_ACK, 0, 0,
d3451 1
a3451 1
			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d:%d "
d3453 1
a3453 1
			    (*state)->packets[0], (*state)->packets[1],
a3511 1
	int			dirndx;
a3524 1
		dirndx = 0;
a3527 1
		dirndx = 1;
d3530 2
a3531 2
	(*state)->packets[dirndx]++;
	(*state)->bytes[dirndx] += pd->tot_len;
d3579 1
a3579 1
	int		 state_icmp = 0, dirndx;
d3628 2
a3629 3
		dirndx = (direction == (*state)->direction) ? 0 : 1;
		(*state)->packets[dirndx]++;
		(*state)->bytes[dirndx] += pd->tot_len;
d3832 1
a3832 6
					printf("pf: BAD ICMP %d:%d ",
					    icmptype, pd->hdr.icmp->icmp_code);
					pf_print_host(pd->src, 0, pd->af);
					printf(" -> ");
					pf_print_host(pd->dst, 0, pd->af);
					printf(" state: ");
a4096 1
	int			dirndx;
a4109 1
		dirndx = 0;
a4112 1
		dirndx = 1;
d4115 2
a4116 2
	(*state)->packets[dirndx]++;
	(*state)->bytes[dirndx] += pd->tot_len;
a4521 2
	if (IN6_IS_ADDR_LINKLOCAL(&dst->sin6_addr))
		dst->sin6_addr.s6_addr16[1] = htons(ifp->if_index);
d4523 2
a4524 1
		error = nd6_output(ifp, ifp, m0, dst, NULL);
@


1.1.1.12
log
@more fixes from -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.372 2003/06/29 23:37:12 itojun Exp $ */
a5004 5
	/* We do IP header normalization and packet reassembly here */
	if (pf_normalize_ip6(m0, dir, ifp, &reason) != PF_PASS) {
		action = PF_DROP;
		goto done;
	}
@


1.1.1.13
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.375 2003/07/04 10:57:27 markus Exp $ */
a2104 2
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

a2114 2
			if (nat->natpass)
				r = NULL;
a2125 2
			if (rdr->natpass)
				r = NULL;
d2129 1
d2169 2
a2173 2
		else if (r->anchorname[0] && r->anchor == NULL)
			r = TAILQ_NEXT(r, entries);
d2290 1
a2419 2
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

a2429 2
			if (nat->natpass)
				r = NULL;
a2440 2
			if (rdr->natpass)
				r = NULL;
d2444 1
d2558 1
a2558 2
		if (s == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
a2559 1
		}
d2564 1
a2683 2
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

a2703 2
			if (nat->natpass)
				r = NULL;
a2724 2
			if (rdr->natpass)
				r = NULL;
d2728 1
d2811 1
a2811 2
		if (s == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
a2812 1
		}
d2817 1
a2899 2
	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

a2917 2
			if (nat->natpass)
				r = NULL;
a2936 2
			if (rdr->natpass)
				r = NULL;
d2940 1
d3043 1
a3043 2
		if (s == NULL) {
			REASON_SET(&reason, PFRES_MEMORY);
a3044 1
		}
d3049 1
d3582 1
a3582 1
	/* translate source/destination address, if necessary */
d3624 2
a3625 2
	key.port[0] = uh->uh_sport;
	key.port[1] = uh->uh_dport;
d3743 1
a3743 1
		/* translate source/destination address, if necessary */
@


1.1.1.14
log
@Synchronize source tree with OpenBSD
note: due to recent changes in the codebase of OpenBSD,
out libcom_err will be incompatible with theirs...
but this is no issue because we don't provide a dynamically
linked one, and theirs won't be provided longer any more anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.377 2003/07/12 09:36:23 dhartmei Exp $ */
d1194 2
a1195 2
		h->ip_len = htons(len);
		h->ip_off = htons(ip_mtudisc ? IP_DF : 0);
d3847 1
a3847 1
			if (h2.ip_off & htons(IP_OFFMASK))
d4330 1
a4330 1
		u_int16_t	 fragoff = (ntohs(h->ip_off) & IP_OFFMASK) << 3;
d4341 1
a4341 1
		if (m->m_pkthdr.len < off + len || ntohs(h->ip_len) < off + len) {
d4496 3
a4498 1
	if (ntohs(ip->ip_len) <= ifp->if_mtu) {
d4520 1
a4520 1
	if (ip->ip_off & htons(IP_DF)) {
d4827 1
a4827 1
	pd.tot_len = ntohs(h->ip_len);
d4830 1
a4830 1
	if (h->ip_off & htons(IP_MF | IP_OFFMASK)) {
d4848 1
a4848 1
		    ntohs(h->ip_len) - off, IPPROTO_TCP, AF_INET)) {
d4879 1
a4879 1
		    off, ntohs(h->ip_len) - off, IPPROTO_UDP, AF_INET)) {
d4904 1
a4904 1
		    ntohs(h->ip_len) - off, IPPROTO_ICMP, AF_INET)) {
d4912 1
a4912 1
			r->bytes += ntohs(h->ip_len);
d4916 1
a4916 1
				a->bytes += ntohs(h->ip_len);
@


1.1.1.15
log
@Another sync to OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.378 2003/07/19 13:08:58 cedric Exp $ */
d1561 2
a1562 2
	struct pf_addr		*raddr = &rpool->cur->addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.v.a.mask;
d1564 2
a1565 2
	if (rpool->cur->addr.type == PF_ADDR_NOROUTE ||
	    rpool->cur->addr.type == PF_ADDR_TABLE)
d1567 2
a1568 2
	if (rpool->cur->addr.type == PF_ADDR_DYNIFTL &&
	    rpool->cur->addr.p.dyn->undefined)
d1618 2
a1619 2
		if (pf_match_addr(0, &rpool->cur->addr.v.a.addr,
		    &rpool->cur->addr.v.a.mask, &rpool->counter, af)) {
d1626 1
a1626 1
			PF_ACPY(naddr, &rpool->cur->addr.v.a.addr, af);
d1628 1
a1628 1
			    &rpool->cur->addr.v.a.addr, af);
a1740 1
		struct pf_addr_wrap	*xdst = NULL;
d1745 1
a1745 1
				xdst = &r->rpool.cur->addr;
d1770 2
a1771 3
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (xdst != NULL && PF_MISMATCHAW(xdst, daddr, af, 0))
			r = TAILQ_NEXT(r, entries);
d1775 2
a1776 1
			r = r->skip[PF_SKIP_DST_PORT].ptr;
d1837 1
a1837 1
				if (r->rpool.cur->addr.type ==
d1839 1
a1839 1
				    r->rpool.cur->addr.p.dyn->undefined)
d1843 2
a1844 2
					    &r->rpool.cur->addr.v.a.addr,
					    &r->rpool.cur->addr.v.a.mask,
@


1.1.1.16
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.382 2003/08/09 14:56:48 cedric Exp $ */
d179 7
a205 2
void			 pf_set_rt_ifp(struct pf_state *,
			    struct pf_addr *);
a207 3
int			 pf_addr_wrap_neq(struct pf_addr_wrap *,
			    struct pf_addr_wrap *);

d811 11
a821 2
		if (cur->src.not != prev->src.not ||
		    pf_addr_wrap_neq(&cur->src.addr, &prev->src.addr))
d827 11
a837 2
		if (cur->dst.not != prev->dst.not ||
		    pf_addr_wrap_neq(&cur->dst.addr, &prev->dst.addr))
a850 28
int
pf_addr_wrap_neq(struct pf_addr_wrap *aw1, struct pf_addr_wrap *aw2)
{
	if (aw1->type != aw2->type)
		return (1);
	switch (aw1->type) {
	case PF_ADDR_ADDRMASK:
		if (PF_ANEQ(&aw1->v.a.addr, &aw2->v.a.addr, 0))
			return (1);
		if (PF_ANEQ(&aw1->v.a.mask, &aw2->v.a.mask, 0))
			return (1);
		return (0);
	case PF_ADDR_DYNIFTL:
		if (aw1->p.dyn->ifp != aw2->p.dyn->ifp)
			return (1);
		if (PF_ANEQ(&aw1->v.a.mask, &aw2->v.a.mask, 0))
			return (1);
		return (0);
	case PF_ADDR_NOROUTE:
		return (0);
	case PF_ADDR_TABLE:
		return (aw1->p.tbl != aw2->p.tbl);
	default:
		printf("invalid address type: %d\n", aw1->type);
		return (1);
	}
}

d1310 1
a1310 1
pf_match(u_int8_t op, u_int32_t a1, u_int32_t a2, u_int32_t p)
d1561 2
a1562 3
	struct pf_addr		*raddr;
	struct pf_addr		*rmask;
	struct pf_pooladdr	*acur = rpool->cur;
d1564 2
a1565 1
	if (rpool->cur->addr.type == PF_ADDR_NOROUTE)
a1569 7
	if (rpool->cur->addr.type == PF_ADDR_TABLE) {
	    	if ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN)
			return (1); /* unsupported */
	} else {
		raddr = &rpool->cur->addr.v.a.addr;
		rmask = &rpool->cur->addr.v.a.mask;
	}
d1618 4
a1621 21
		if (rpool->cur->addr.type == PF_ADDR_TABLE) {
			if (!pfr_pool_get(rpool->cur->addr.p.tbl,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af))
				goto get_addr;
		} else if (pf_match_addr(0, raddr, rmask, &rpool->counter, af))
			goto get_addr;

	try_next:
		if ((rpool->cur = TAILQ_NEXT(rpool->cur, entries)) == NULL)
			rpool->cur = TAILQ_FIRST(&rpool->list);
		if (rpool->cur->addr.type == PF_ADDR_TABLE) {
			rpool->tblidx = -1;
			if (pfr_pool_get(rpool->cur->addr.p.tbl,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af)) {
				/* table contain no address of type 'af' */
				if (rpool->cur != acur)
					goto try_next;
				return (1);
			}
d1623 7
a1629 3
			raddr = &rpool->cur->addr.v.a.addr;
			rmask = &rpool->cur->addr.v.a.mask;
			PF_ACPY(&rpool->counter, raddr, af);
a1630 4

	get_addr:
		PF_ACPY(naddr, &rpool->counter, af);
		PF_AINC(&rpool->counter, af);
a2083 26
void
pf_set_rt_ifp(struct pf_state *s, struct pf_addr *saddr)
{
	struct pf_rule *r = s->rule.ptr;

	s->rt_ifp = NULL;
	if (!r->rt || r->rt == PF_FASTROUTE)
		return;
	switch (s->af) {
#ifdef INET
	case AF_INET:
		pf_map_addr(AF_INET, &r->rpool, saddr,
		    &s->rt_addr, NULL);
		s->rt_ifp = r->rpool.cur->ifp;
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		pf_map_addr(AF_INET6, &r->rpool, saddr,
		    &s->rt_addr, NULL);
		s->rt_ifp = r->rpool.cur->ifp;
		break;
#endif /* INET6 */
	}
}

a2351 1
		pf_set_rt_ifp(s, saddr);
a2628 1
		pf_set_rt_ifp(s, saddr);
a2883 1
		pf_set_rt_ifp(s, saddr);
a3121 1
		pf_set_rt_ifp(s, saddr);
d4462 6
d4628 6
@


1.1.1.17
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.383 2003/08/14 19:00:12 jason Exp $ */
d2270 1
a2270 1
			m_copyback(m, off, sizeof(*th), th);
d2458 1
a2458 1
		m_copyback(m, off, sizeof(*th), th);
d2588 1
a2588 1
			m_copyback(m, off, sizeof(*uh), uh);
d2699 1
a2699 1
		m_copyback(m, off, sizeof(*uh), uh);
d2867 1
a2867 1
			    pd->hdr.icmp6);
d2957 1
a2957 1
		    pd->hdr.icmp6);
d3677 1
a3677 1
		m_copyback(m, off, sizeof(*th), th);
d3680 1
a3680 1
		m_copyback(m, off, sizeof(*th), th);
d3750 1
a3750 1
		m_copyback(m, off, sizeof(*uh), uh);
d3846 1
a3846 1
					    pd->hdr.icmp6);
d3866 1
a3866 1
					    pd->hdr.icmp6);
d4057 1
a4057 1
					    pd->hdr.icmp);
d4059 1
a4059 1
					    &h2);
d4066 1
a4066 1
					    pd->hdr.icmp6);
d4068 1
a4068 1
					    &h2_6);
d4072 1
a4072 1
				m_copyback(m, off2, 8, &th);
d4074 1
a4074 1
				m_copyback(m, off2, 8, &th);
d4119 3
a4121 2
					    pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2), &h2);
d4128 1
a4128 1
					    pd->hdr.icmp6);
d4130 1
a4130 1
					    &h2_6);
d4134 2
a4135 1
				m_copyback(m, off2, sizeof(uh), &uh);
d4177 6
a4182 3
				m_copyback(m, off, ICMP_MINLEN, pd->hdr.icmp);
				m_copyback(m, ipoff2, sizeof(h2), &h2);
				m_copyback(m, off2, ICMP_MINLEN, &iih);
d4226 3
a4228 2
				    pd->hdr.icmp6);
				m_copyback(m, ipoff2, sizeof(h2_6), &h2_6);
d4230 1
a4230 1
				    &iih);
d4267 3
a4269 2
					    pd->hdr.icmp);
					m_copyback(m, ipoff2, sizeof(h2), &h2);
d4276 1
a4276 1
					    pd->hdr.icmp6);
d4278 1
a4278 1
					    &h2_6);
@


1.1.1.18
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.387 2003/08/28 09:41:03 cedric Exp $ */
d137 1
a137 2
struct pf_rule		*pf_match_translation(struct pf_pdesc *, struct mbuf *,
			    int, int, struct ifnet *,
d139 2
a140 3
			    u_int16_t, int);
struct pf_rule		*pf_get_translation(struct pf_pdesc *, struct mbuf *,
			    int, int, struct ifnet *,
d143 1
a143 1
			    struct pf_addr *, u_int16_t *);
d157 1
a157 1
			    int, struct ifnet *, struct mbuf *, int, void *,
d555 1
a555 3
	struct pfr_ktable *kt = aw->p.tbl;

	if (aw->type != PF_ADDR_TABLE || kt == NULL)
d557 2
a558 5
	if (!(kt->pfrkt_flags & PFR_TFLAG_ACTIVE) && kt->pfrkt_root != NULL)
		kt = kt->pfrkt_root;
	aw->p.tbl = NULL;
	aw->p.tblcnt = (kt->pfrkt_flags & PFR_TFLAG_ACTIVE) ?
		kt->pfrkt_cnt : -1;
a1219 1
		break;
d1763 3
a1765 3
pf_match_translation(struct pf_pdesc *pd, struct mbuf *m, int off,
    int direction, struct ifnet *ifp, struct pf_addr *saddr, u_int16_t sport,
    struct pf_addr *daddr, u_int16_t dport, int rs_num)
d1790 1
a1790 1
		else if (r->af && r->af != pd->af)
d1792 1
a1792 1
		else if (r->proto && r->proto != pd->proto)
d1794 1
a1794 1
		else if (PF_MISMATCHAW(&src->addr, saddr, pd->af, src->not))
d1802 1
a1802 1
		    PF_MISMATCHAW(&dst->addr, daddr, pd->af, dst->not))
d1804 1
a1804 1
		else if (xdst != NULL && PF_MISMATCHAW(xdst, daddr, pd->af, 0))
a1809 4
		else if (r->os_fingerprint != PF_OSFP_ANY && (pd->proto !=
		    IPPROTO_TCP || !pf_osfp_match(pf_osfp_fingerprint(pd, m,
		    off, pd->hdr.tcp), r->os_fingerprint)))
			r = TAILQ_NEXT(r, entries);
d1827 1
a1827 2
pf_get_translation(struct pf_pdesc *pd, struct mbuf *m, int off, int direction,
    struct ifnet *ifp,
d1830 1
a1830 1
    struct pf_addr *naddr, u_int16_t *nport)
d1835 2
a1836 2
		r = pf_match_translation(pd, m, off, direction, ifp, saddr,
		    sport, daddr, dport, PF_RULESET_BINAT);
d1838 2
a1839 2
			r = pf_match_translation(pd, m, off, direction, ifp,
			    saddr, sport, daddr, dport, PF_RULESET_NAT);
d1841 2
a1842 2
		r = pf_match_translation(pd, m, off, direction, ifp, saddr,
		    sport, daddr, dport, PF_RULESET_RDR);
d1844 2
a1845 2
			r = pf_match_translation(pd, m, off, direction, ifp,
			    saddr, sport, daddr, dport, PF_RULESET_BINAT);
d1856 2
a1857 2
			if (pf_get_sport(pd->af, pd->proto, &r->rpool, saddr,
			    daddr, dport, naddr, nport, r->rpool.proxy_port[0],
d1878 1
a1878 1
					    saddr, pd->af);
d1887 1
a1887 2
					    &r->src.addr.v.a.mask, saddr,
					    pd->af);
d2169 1
a2169 1
		if ((nat = pf_get_translation(pd, m, off, PF_OUT, ifp,
d2171 1
a2171 1
		    &naddr, &nport)) != NULL) {
d2182 3
a2184 3
		if ((rdr = pf_get_translation(pd, m, off, PF_IN, ifp, saddr,
		    th->th_sport, daddr, th->th_dport,
		    &naddr, &nport)) != NULL) {
a2237 3
		else if (r->os_fingerprint != PF_OSFP_ANY && !pf_osfp_match(
		    pf_osfp_fingerprint(pd, m, off, th), r->os_fingerprint))
			r = TAILQ_NEXT(r, entries);
d2489 1
a2489 1
		if ((nat = pf_get_translation(pd, m, off, PF_OUT, ifp,
d2491 1
a2491 1
		    &naddr, &nport)) != NULL) {
d2502 3
a2504 3
		if ((rdr = pf_get_translation(pd, m, off, PF_IN, ifp, saddr,
		    uh->uh_sport, daddr, uh->uh_dport, &naddr, &nport))
		    != NULL) {
a2555 2
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
d2759 2
a2760 2
		if ((nat = pf_get_translation(pd, m, off, PF_OUT, ifp, saddr, 0,
		    daddr, 0, &naddr, NULL)) != NULL) {
d2782 2
a2783 2
		if ((rdr = pf_get_translation(pd, m, off, PF_IN, ifp, saddr, 0,
		    daddr, 0, &naddr, NULL)) != NULL) {
a2832 2
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
d2965 1
a2965 1
    struct ifnet *ifp, struct mbuf *m, int off, void *h, struct pf_pdesc *pd,
d2982 2
a2983 2
		if ((nat = pf_get_translation(pd, m, off, PF_OUT, ifp, saddr, 0,
		    daddr, 0, &naddr, NULL)) != NULL) {
d3003 2
a3004 2
		if ((rdr = pf_get_translation(pd, m, off, PF_IN, ifp, saddr, 0,
		    daddr, 0, &naddr, NULL)) != NULL) {
a3047 2
		else if (r->os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
d3229 1
a3229 2
		    r->flagset || r->type || r->code ||
		    r->os_fingerprint != PF_OSFP_ANY)
d4527 16
a4542 18
	mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
	if (mtag == NULL) {
		struct m_tag *mtag;

		mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
		if (mtag == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
	}

	if (oifp != ifp && mtag == NULL) {
		if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip))
			panic("pf_route: m0->m_len < sizeof(struct ip)");
		ip = mtod(m0, struct ip *);
d4663 1
a4663 1
		ip6_output(m0, NULL, NULL, 0, NULL, NULL);
d4974 1
a4974 1
			action = pf_test_other(&r, &s, dir, ifp, m, off, h,
d5208 1
a5208 1
		action = pf_test_other(&r, &s, dir, ifp, m, off, h,
@


1.1.1.19
log
@Release Time. Synchronize with OpenBSD 3.4-current (base system).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.390 2003/09/24 17:18:03 mcbride Exp $ */
d1587 1
a1587 1
		if ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN)
d2416 1
d2419 1
d2692 4
d2697 4
d2950 10
d3172 1
d3174 1
d3179 1
d3182 1
d3184 1
d3189 1
d3191 4
d3196 4
d4849 1
a4849 1
	struct pf_rule	  *a = NULL, *r = &pf_default_rule, *tr;
d5011 2
a5012 5
	tr = r;
	if (r == &pf_default_rule && s != NULL && s->nat_rule.ptr != NULL)
		tr = s->nat_rule.ptr;
	if (tr->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->src.addr.p.tbl,
d5015 3
a5017 3
		    tr->src.not);
	if (tr->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->dst.addr.p.tbl,
d5020 1
a5020 1
		    tr->dst.not);
d5073 1
a5073 1
	struct pf_rule	  *a = NULL, *r = &pf_default_rule, *tr;
d5245 2
a5246 5
	tr = r;
	if (r == &pf_default_rule && s != NULL && s->nat_rule.ptr != NULL)
		tr = s->nat_rule.ptr;
	if (tr->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->src.addr.p.tbl,
d5249 3
a5251 3
		    tr->src.not);
	if (tr->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->dst.addr.p.tbl,
d5254 1
a5254 1
		    tr->dst.not);
@


1.1.1.20
log
@Import some pieces of OpenBSD changes I unbedingtly wanted to have
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.391 2003/09/26 14:48:19 mcbride Exp $ */
d2277 6
d2423 2
d2595 6
d2695 2
d2866 6
d2943 2
d3073 6
a3079 1

d3170 2
d3246 6
a3252 1

d3277 1
a3277 1
	int			 ackskew;
d3293 1
d3297 1
d3495 3
d3582 3
d3673 10
d3693 1
d3707 1
d3711 1
d3714 3
d3743 10
d3763 1
a3763 1
	int		 state_icmp = 0;
d3812 3
d4280 1
d4294 1
d4298 1
d4301 3
d4351 10
d4819 2
a4820 1
	int		   off, dirndx, pqid = 0;
d4891 1
a4891 1
			goto done;
d4971 5
d4977 14
a5022 35
	if (ifp == status_ifp) {
		pf_status.bcounters[0][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[0][dir == PF_OUT][action != PF_PASS]++;
	}

	r->packets++;
	r->bytes += pd.tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd.tot_len;
	}
	if (s != NULL) {
		dirndx = (dir == s->direction) ? 0 : 1;
		s->packets[dirndx]++;
		s->bytes[dirndx] += pd.tot_len;
		if (s->nat_rule.ptr != NULL) {
			s->nat_rule.ptr->packets++;
			s->nat_rule.ptr->bytes += pd.tot_len;
		}
	}
	tr = r;
	if (r == &pf_default_rule && s != NULL && s->nat_rule.ptr != NULL)
		tr = s->nat_rule.ptr;
	if (tr->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->src.not);
	if (tr->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->dst.not);


d5046 1
a5046 1
	int		   off, terminal = 0, dirndx;
d5139 1
a5139 1
			goto done;
d5208 5
d5214 14
a5251 35

	if (ifp == status_ifp) {
		pf_status.bcounters[1][dir == PF_OUT] += pd.tot_len;
		pf_status.pcounters[1][dir == PF_OUT][action != PF_PASS]++;
	}

	r->packets++;
	r->bytes += pd.tot_len;
	if (a != NULL) {
		a->packets++;
		a->bytes += pd.tot_len;
	}
	if (s != NULL) {
		dirndx = (dir == s->direction) ? 0 : 1;
		s->packets[dirndx]++;
		s->bytes[dirndx] += pd.tot_len;
		if (s->nat_rule.ptr != NULL) {
			s->nat_rule.ptr->packets++;
			s->nat_rule.ptr->bytes += pd.tot_len;
		}
	}
	tr = r;
	if (r == &pf_default_rule && s != NULL && s->nat_rule.ptr != NULL)
		tr = s->nat_rule.ptr;
	if (tr->src.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->src.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.src : pd.dst, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->src.not);
	if (tr->dst.addr.type == PF_ADDR_TABLE)
		pfr_update_stats(tr->dst.addr.p.tbl,
		    (s == NULL || s->direction == dir) ? pd.dst : pd.src, pd.af,
		    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
		    tr->dst.not);

@


1.1.1.21
log
@cvs is playing games with me.

@@@@@@ CONSIDER THE TREE LOCKED NOW @@@@@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.392 2003/09/26 21:44:08 cedric Exp $ */
a105 1
int			 altqs_inactive_open;
@


1.1.1.22
log
@Import OpenBSD source tree again, with critical bug fixes
(OpenSSL, bc, dc, sensorsd, pf, ...)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.393 2003/10/02 05:47:30 itojun Exp $ */
d4484 1
a4484 1
	if (error)
@


1.1.1.22.4.1
log
@Five fixes from OpenBSD 3.4-stable:

fix binat for incoming connections when a netblock (not just a single
address) is used for source in the binat rule. closes PR 3535, reported
by Karl O.Pinc.

plug mbuf leak (ip_fragment() always free mbuf on error).

Properly m_copyback() modified TCP sequence number after demodulation

Fix icmp checksum when sequence number modlation is being used.
Also fix a daddr vs saddr cut-n-paste error in ICMP error handling.
Fixes PR 3724

prevent an endless loop with route-to lo0, fixes PR 3736
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.389.2.4 2004/04/30 23:27:57 brad Exp $ */
d1901 1
a1901 1
					    &r->src.addr.v.a.mask, daddr,
a3900 1
			int			 copyback = 0;
d3938 2
a3939 2
			if (src->seqdiff) {
				pf_change_a(&th.th_seq, icmpsum,
a3940 2
				copyback = 1;
			}
d3960 1
a3960 1
					    daddr, &(*state)->lan.addr,
a3970 4
				copyback = 1;
			}

			if (copyback) {
d3991 2
d4429 9
a4437 6
	if (m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL) != NULL)
		goto bad;
	mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0, M_NOWAIT);
	if (mtag == NULL)
		goto bad;
	m_tag_prepend(m0, mtag);
d4439 1
a4439 1
	if (oifp != ifp) {
d4484 1
a4484 2
	if (error) {
		m0 = NULL;
a4485 1
	}
@


1.1.1.22.4.2
log
@Fix from OpenBSD 3.4-stable:

change pf_route() loop detection: introduce a counter (number of times
a packet is routed already) in the mbuf tag, allow at most four times.
Fixes some legitimate cases broken by the previous change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.389.2.5 2004/07/17 03:32:12 brad Exp $ */
a4358 1
	struct m_tag		*mtag;
d4364 1
d4372 8
a4379 6
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
d4381 2
a4382 13
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
a4383 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
d4430 1
d4434 7
d4536 8
a4543 6
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
d4545 2
a4546 13
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
a4547 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
d4590 1
d4595 11
a4605 7
		if (pf_test6(PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip6_hdr))
			panic("pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
		ip6 = mtod(m0, struct ip6_hdr *);
@


1.1.1.22.4.3
log
@SECURITY: Four (!) fixes from OpenBSD 3.5-stable:

For RST generated due to state mismatch during handshake, don't set
th_flags TH_ACK and leave th_ack 0, just like the RST generated by
the stack in this case. Fixes the Raptor workaround.


Initialise init_addr in pf_map_addr() in the PF_POOL_ROUNDROBIN,
prevents a possible endless loop in pf_get_sport() with 'static-port'

Reported by adm at celeritystorm dot com in FreeBSD PR74930, debugging
by dhartmei@@


IPv6 packets can contain headers (like options) before the TCP/UDP/ICMP6
header. pf finds the first TCP/UDP/ICMP6 header to filter by traversing
the header chain. In the case where headers are skipped, the protocol
checksum verification used the wrong length (included the skipped headers),
leading to incorrectly mismatching checksums. Such IPv6 packets with
headers were silently dropped. Reported by Bernhard Schmidt.


ICMP state entries use the ICMP ID as port for the unique state key. When
checking for a usable key, construct the key in the same way. Otherwise,
a colliding key might be missed or a state insertion might be refused even
though it could be inserted. The second case triggers the endless loop
fixed by 1.474, possibly allowing a NATed LAN client to lock up the kernel.
Report and test data by Srebrenko Sehic.


The fix from 1.433.2.4 was not necessary to apply, as the bug was introduced
in a later revision than the one we have. The fix from 1.433.2.7 (the last
one) was manually backported by me.
@
text
@a1 3
/* also contains changes from: */
/*	$OpenBSD: pf.c,v 1.433.2.7 2005/01/06 14:15:43 brad Exp $ */

a1670 2
		if (init_addr != NULL && PF_AZERO(init_addr, af))
			PF_ACPY(init_addr, naddr, af);
d1710 1
a1710 1
			key.port[1] = dport;
d3569 7
a3575 1
			if (!(th->th_flags & TH_RST))
d3578 2
a3579 2
				    th->th_sport, ntohl(th->th_ack), 0,
				    TH_RST, 0, 0,
d3581 1
d5074 1
a5074 2
		    ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_TCP, AF_INET6)) {
d5103 1
a5103 2
		    off, ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_UDP, AF_INET6)) {
d5127 1
a5127 2
		    ntohs(h->ip6_plen) - (off - sizeof(struct ip6_hdr)),
		    IPPROTO_ICMPV6, AF_INET6)) {
@


1.1.1.23
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.413 2003/12/19 16:12:43 henning Exp $ */
a4 1
 * Copyright (c) 2002,2003 Henning Brauer
d89 1
d111 1
a111 1
struct pool		 pf_src_tree_pl, pf_rule_pl, pf_addr_pl;
d114 1
d143 1
a143 1
			    int, int, struct ifnet *, struct pf_src_node **,
d148 1
a148 1
			    int, struct ifnet *, struct mbuf *, int,
d152 1
a152 1
			    int, struct ifnet *, struct mbuf *, int,
d156 1
a156 1
			    int, struct ifnet *, struct mbuf *, int,
d168 1
a168 1
			    struct ifnet *, struct mbuf *, int,
d171 1
a171 1
			    struct ifnet *, struct mbuf *, int,
d174 1
a174 1
			    struct ifnet *, struct mbuf *, int,
d180 2
a181 1
			     struct pf_rule *, struct pf_tag *, int *);
d184 1
a184 1
int			 pf_map_addr(u_int8_t, struct pf_rule *,
d186 2
a187 2
			    struct pf_addr *, struct pf_src_node **);
int			 pf_get_sport(sa_family_t, u_int8_t, struct pf_rule *,
d189 1
a189 2
			    struct pf_addr *, u_int16_t*, u_int16_t, u_int16_t,
			    struct pf_src_node **);
d194 1
a194 1
int			 pf_socket_lookup(uid_t *, gid_t *,
a207 1
static int		 pf_add_mbuf_tag(struct mbuf *, u_int);
d216 1
a216 1
			*state = pf_find_state(&key, PF_EXT_GWY);	\
d218 1
a218 1
			*state = pf_find_state(&key, PF_LAN_EXT);	\
d239 2
a240 129
static __inline int pf_src_compare(struct pf_src_node *, struct pf_src_node *);
static __inline int pf_state_compare_lan_ext(struct pf_state *,
	struct pf_state *);
static __inline int pf_state_compare_ext_gwy(struct pf_state *,
	struct pf_state *);
static __inline int pf_state_compare_id(struct pf_state *,
	struct pf_state *);

struct pf_src_tree tree_src_tracking;
struct pf_state_tree_lan_ext tree_lan_ext;
struct pf_state_tree_ext_gwy tree_ext_gwy;
struct pf_state_tree_id tree_id;

RB_GENERATE(pf_src_tree, pf_src_node, entry, pf_src_compare);
RB_GENERATE(pf_state_tree_lan_ext, pf_state,
    entry_lan_ext, pf_state_compare_lan_ext);
RB_GENERATE(pf_state_tree_ext_gwy, pf_state,
    entry_ext_gwy, pf_state_compare_ext_gwy);
RB_GENERATE(pf_state_tree_id, pf_state,
    entry_id, pf_state_compare_id);

static __inline int
pf_src_compare(struct pf_src_node *a, struct pf_src_node *b)
{
	int	diff;

	if (a->rule.ptr > b->rule.ptr)
		return (1);
	if (a->rule.ptr < b->rule.ptr)
		return (-1);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	switch (a->af) {
#ifdef INET
	case AF_INET:
		if (a->addr.addr32[0] > b->addr.addr32[0])
			return (1);
		if (a->addr.addr32[0] < b->addr.addr32[0])
			return (-1);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (a->addr.addr32[3] > b->addr.addr32[3])
			return (1);
		if (a->addr.addr32[3] < b->addr.addr32[3])
			return (-1);
		if (a->addr.addr32[2] > b->addr.addr32[2])
			return (1);
		if (a->addr.addr32[2] < b->addr.addr32[2])
			return (-1);
		if (a->addr.addr32[1] > b->addr.addr32[1])
			return (1);
		if (a->addr.addr32[1] < b->addr.addr32[1])
			return (-1);
		if (a->addr.addr32[0] > b->addr.addr32[0])
			return (1);
		if (a->addr.addr32[0] < b->addr.addr32[0])
			return (-1);
		break;
#endif /* INET6 */
	}
	return (0);
}

static __inline int
pf_state_compare_lan_ext(struct pf_state *a, struct pf_state *b)
{
	int	diff;

	if ((diff = a->proto - b->proto) != 0)
		return (diff);
	if ((diff = a->af - b->af) != 0)
		return (diff);
	switch (a->af) {
#ifdef INET
	case AF_INET:
		if (a->lan.addr.addr32[0] > b->lan.addr.addr32[0])
			return (1);
		if (a->lan.addr.addr32[0] < b->lan.addr.addr32[0])
			return (-1);
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		if (a->lan.addr.addr32[3] > b->lan.addr.addr32[3])
			return (1);
		if (a->lan.addr.addr32[3] < b->lan.addr.addr32[3])
			return (-1);
		if (a->ext.addr.addr32[3] > b->ext.addr.addr32[3])
			return (1);
		if (a->ext.addr.addr32[3] < b->ext.addr.addr32[3])
			return (-1);
		if (a->lan.addr.addr32[2] > b->lan.addr.addr32[2])
			return (1);
		if (a->lan.addr.addr32[2] < b->lan.addr.addr32[2])
			return (-1);
		if (a->ext.addr.addr32[2] > b->ext.addr.addr32[2])
			return (1);
		if (a->ext.addr.addr32[2] < b->ext.addr.addr32[2])
			return (-1);
		if (a->lan.addr.addr32[1] > b->lan.addr.addr32[1])
			return (1);
		if (a->lan.addr.addr32[1] < b->lan.addr.addr32[1])
			return (-1);
		if (a->ext.addr.addr32[1] > b->ext.addr.addr32[1])
			return (1);
		if (a->ext.addr.addr32[1] < b->ext.addr.addr32[1])
			return (-1);
		if (a->lan.addr.addr32[0] > b->lan.addr.addr32[0])
			return (1);
		if (a->lan.addr.addr32[0] < b->lan.addr.addr32[0])
			return (-1);
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
			return (1);
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
			return (-1);
		break;
#endif /* INET6 */
	}

	if ((diff = a->lan.port - b->lan.port) != 0)
		return (diff);
	if ((diff = a->ext.port - b->ext.port) != 0)
		return (diff);
d242 2
a243 2
	return (0);
}
d246 1
a246 1
pf_state_compare_ext_gwy(struct pf_state *a, struct pf_state *b)
d257 1
a257 1
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
d259 1
a259 1
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
d261 1
a261 1
		if (a->gwy.addr.addr32[0] > b->gwy.addr.addr32[0])
d263 1
a263 1
		if (a->gwy.addr.addr32[0] < b->gwy.addr.addr32[0])
d269 1
a269 1
		if (a->ext.addr.addr32[3] > b->ext.addr.addr32[3])
d271 1
a271 1
		if (a->ext.addr.addr32[3] < b->ext.addr.addr32[3])
d273 1
a273 1
		if (a->gwy.addr.addr32[3] > b->gwy.addr.addr32[3])
d275 1
a275 1
		if (a->gwy.addr.addr32[3] < b->gwy.addr.addr32[3])
d277 1
a277 1
		if (a->ext.addr.addr32[2] > b->ext.addr.addr32[2])
d279 1
a279 1
		if (a->ext.addr.addr32[2] < b->ext.addr.addr32[2])
d281 1
a281 1
		if (a->gwy.addr.addr32[2] > b->gwy.addr.addr32[2])
d283 1
a283 1
		if (a->gwy.addr.addr32[2] < b->gwy.addr.addr32[2])
d285 1
a285 1
		if (a->ext.addr.addr32[1] > b->ext.addr.addr32[1])
d287 1
a287 1
		if (a->ext.addr.addr32[1] < b->ext.addr.addr32[1])
d289 1
a289 1
		if (a->gwy.addr.addr32[1] > b->gwy.addr.addr32[1])
d291 1
a291 1
		if (a->gwy.addr.addr32[1] < b->gwy.addr.addr32[1])
d293 1
a293 1
		if (a->ext.addr.addr32[0] > b->ext.addr.addr32[0])
d295 1
a295 1
		if (a->ext.addr.addr32[0] < b->ext.addr.addr32[0])
d297 1
a297 1
		if (a->gwy.addr.addr32[0] > b->gwy.addr.addr32[0])
d299 1
a299 1
		if (a->gwy.addr.addr32[0] < b->gwy.addr.addr32[0])
d305 1
a305 1
	if ((diff = a->ext.port - b->ext.port) != 0)
d307 1
a307 1
	if ((diff = a->gwy.port - b->gwy.port) != 0)
a312 15
static __inline int
pf_state_compare_id(struct pf_state *a, struct pf_state *b)
{
	if (a->id > b->id)
		return (1);
	if (a->id < b->id)
		return (-1);
	if (a->creatorid > b->creatorid)
		return (1);
	if (a->creatorid < b->creatorid)
		return (-1);

	return (0);
}

d334 1
a334 1
pf_find_state(struct pf_state *key, u_int8_t tree)
d336 1
a336 1
	struct pf_state	*s;
d339 5
a343 18

	switch (tree) {
	case PF_LAN_EXT:
		s = RB_FIND(pf_state_tree_lan_ext, &tree_lan_ext, key);
		break;
	case PF_EXT_GWY:
		s = RB_FIND(pf_state_tree_ext_gwy, &tree_ext_gwy, key);
		break;
	case PF_ID:
		s = RB_FIND(pf_state_tree_id, &tree_id, key);
		break;
	default:
		/* XXX should we just return NULL? */
		panic("pf_find_state");
		break;
	}

	return (s);
d347 1
a347 2
pf_insert_src_node(struct pf_src_node **sn, struct pf_rule *rule,
    struct pf_addr *src, sa_family_t af)
d349 1
a349 1
	struct pf_src_node  k;
d351 10
a360 48
	if (*sn == NULL) {
		k.af = af;
		PF_ACPY(&k.addr, src, af);
		if (rule->rule_flag & PFRULE_RULESRCTRACK ||
		    rule->rpool.opts & PF_POOL_STICKYADDR)
			k.rule.ptr = rule;
		else
			k.rule.ptr = NULL;
		pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
		*sn = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
	}
	if (*sn == NULL) {
		if (!rule->max_src_nodes ||
		    rule->src_nodes < rule->max_src_nodes)
			(*sn) = pool_get(&pf_src_tree_pl, PR_NOWAIT);
		if ((*sn) == NULL)
			return (-1);
		bzero(*sn, sizeof(struct pf_src_node));
		(*sn)->af = af;
		if (rule->rule_flag & PFRULE_RULESRCTRACK ||
		    rule->rpool.opts & PF_POOL_STICKYADDR)
			(*sn)->rule.ptr = rule;
		else
			(*sn)->rule.ptr = NULL;
		PF_ACPY(&(*sn)->addr, src, af);
		if (RB_INSERT(pf_src_tree,
		    &tree_src_tracking, *sn) != NULL) {
			if (pf_status.debug >= PF_DEBUG_MISC) {
				printf("pf: src_tree insert failed: ");
				pf_print_host(&(*sn)->addr, 0, af);
				printf("\n");
			}
			pool_put(&pf_src_tree_pl, *sn);
			return (-1);
		}
		(*sn)->creation = time.tv_sec;
		(*sn)->ruletype = rule->action;
		if ((*sn)->rule.ptr != NULL)
			(*sn)->rule.ptr->src_nodes++;
		 pf_status.scounters[SCNT_SRC_NODE_INSERT]++;
		 pf_status.src_nodes++;
	} else {
		if (rule->max_src_states &&
		    (*sn)->states >= rule->max_src_states)
			return (-1);
	}
	return (0);
}
a361 3
int
pf_insert_state(struct pf_state *state)
{
d363 1
a363 1
	if (RB_INSERT(pf_state_tree_lan_ext, &tree_lan_ext, state)) {
a374 2
			if (state->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
d377 1
a377 1
		pf_src_tree_remove_state(state);
d381 16
a396 1
	if (RB_INSERT(pf_state_tree_ext_gwy, &tree_ext_gwy, state) != NULL) {
a407 20
			if (state->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
			printf("\n");
		}
		RB_REMOVE(pf_state_tree_lan_ext, &tree_lan_ext, state);
		pf_src_tree_remove_state(state);
		return (-1);
	}

	if (state->id == 0 && state->creatorid == 0) {
		state->id = htobe64(pf_status.stateid++);
		state->creatorid = pf_status.hostid;
	}
	if (RB_INSERT(pf_state_tree_id, &tree_id, state) != NULL) {
		if (pf_status.debug >= PF_DEBUG_MISC) {
			printf("pf: state insert failed: "
			    "id: %016llx creatorid: %08x",
			    betoh64(state->id), ntohl(state->creatorid));
			if (state->sync_flags & PFSTATE_FROMSYNC)
				printf(" (from sync)");
d410 3
a412 2
		RB_REMOVE(pf_state_tree_lan_ext, &tree_lan_ext, state);
		RB_REMOVE(pf_state_tree_ext_gwy, &tree_ext_gwy, state);
a432 1
	pf_purge_expired_src_nodes();
a474 46
pf_purge_expired_src_nodes(void)
{
	 struct pf_src_node		*cur, *next;

	 for (cur = RB_MIN(pf_src_tree, &tree_src_tracking); cur; cur = next) {
		 next = RB_NEXT(pf_src_tree, &tree_src_tracking, cur);

		 if (cur->states <= 0 && cur->expire <= time.tv_sec) {
			 if (cur->rule.ptr != NULL) {
				 cur->rule.ptr->src_nodes--;
				 if (cur->rule.ptr->states <= 0 &&
				     cur->rule.ptr->max_src_nodes <= 0)
					 pf_rm_rule(NULL, cur->rule.ptr);
			 }
			 RB_REMOVE(pf_src_tree, &tree_src_tracking, cur);
			 pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
			 pf_status.src_nodes--;
			 pool_put(&pf_src_tree_pl, cur);
		 }
	 }
}

void
pf_src_tree_remove_state(struct pf_state *s)
{
	u_int32_t timeout;

	if (s->src_node != NULL) {
		if (--s->src_node->states <= 0) {
			timeout = s->rule.ptr->timeout[PFTM_SRC_NODE];
			if (!timeout)
				timeout = pf_default_rule.timeout[PFTM_SRC_NODE];
			s->src_node->expire = time.tv_sec + timeout;
		}
	}
	if (s->nat_src_node != s->src_node && s->nat_src_node != NULL) {
		if (--s->nat_src_node->states <= 0) {
			timeout = s->rule.ptr->timeout[PFTM_SRC_NODE];
			if (!timeout)
				timeout = pf_default_rule.timeout[PFTM_SRC_NODE];
			s->nat_src_node->expire = time.tv_sec + timeout;
		}
	}
}

void
d477 2
a478 1
	struct pf_state		*cur, *next;
d480 2
a481 2
	for (cur = RB_MIN(pf_state_tree_ext_gwy, &tree_ext_gwy); cur; cur = next) {
		next = RB_NEXT(pf_state_tree_ext_gwy, &tree_ext_gwy, cur);
d483 11
a493 6
		if (pf_state_expires(cur) <= time.tv_sec) {
			if (cur->src.state == PF_TCPS_PROXY_DST)
				pf_send_tcp(cur->rule.ptr, cur->af,
				    &cur->ext.addr, &cur->lan.addr,
				    cur->ext.port, cur->lan.port,
				    cur->src.seqhi, cur->src.seqlo + 1, 0,
d495 17
a511 3
			RB_REMOVE(pf_state_tree_ext_gwy, &tree_ext_gwy, cur);
			RB_REMOVE(pf_state_tree_lan_ext, &tree_lan_ext, cur);
			RB_REMOVE(pf_state_tree_id, &tree_id, cur);
d514 1
a514 1
			pfsync_delete_state(cur);
d516 14
a529 13
			pf_src_tree_remove_state(cur);
			if (--cur->rule.ptr->states <= 0 &&
			    cur->rule.ptr->src_nodes <= 0)
				pf_rm_rule(NULL, cur->rule.ptr);
			if (cur->nat_rule.ptr != NULL)
				if (--cur->nat_rule.ptr->states <= 0 &&
					cur->nat_rule.ptr->src_nodes <= 0)
					pf_rm_rule(NULL, cur->nat_rule.ptr);
			if (cur->anchor.ptr != NULL)
				if (--cur->anchor.ptr->states <= 0)
					pf_rm_rule(NULL, cur->anchor.ptr);
			pf_normalize_tcp_cleanup(cur);
			pool_put(&pf_state_pl, cur);
d569 95
d1389 2
a1390 2
pf_match_tag(struct mbuf *m, struct pf_rule *r, struct pf_rule *nat_rule,
    struct pf_tag *pftag, int *tag)
d1398 4
a1401 2
		if (nat_rule != NULL && nat_rule->tag)
			*tag = nat_rule->tag;
d1485 1
a1485 1
pf_addr_inc(struct pf_addr *addr, sa_family_t af)
d1574 2
a1575 2
pf_map_addr(sa_family_t af, struct pf_rule *r, struct pf_addr *saddr,
    struct pf_addr *naddr, struct pf_addr *init_addr, struct pf_src_node **sn)
d1578 3
a1580 29
	struct pf_pool		*rpool = &r->rpool;
	struct pf_addr		*raddr = &rpool->cur->addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.v.a.mask;
	struct pf_pooladdr      *acur = rpool->cur;
	struct pf_src_node	 k;

	if (*sn == NULL && r->rpool.opts & PF_POOL_STICKYADDR &&
	    (r->rpool.opts & PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		k.af = af;
		PF_ACPY(&k.addr, saddr, af);
		if (r->rule_flag & PFRULE_RULESRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR)
			k.rule.ptr = r;
		else
			k.rule.ptr = NULL;
		pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
		*sn = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
		if (*sn != NULL && !PF_AZERO(&(*sn)->raddr, af)) {
			PF_ACPY(naddr, &(*sn)->raddr, af);
			if (pf_status.debug >= PF_DEBUG_MISC) {
				printf("pf_map_addr: src tracking maps ");
				pf_print_host(&k.addr, 0, af);
				printf(" to ");
				pf_print_host(naddr, 0, af);
				printf("\n");
			}
			return (0);
		}
	}
a1673 2
	if (*sn != NULL)
		PF_ACPY(&(*sn)->raddr, naddr, af);
d1677 1
a1677 1
		printf("pf_map_addr: selected address ");
d1686 1
a1686 1
pf_get_sport(sa_family_t af, u_int8_t proto, struct pf_rule *r,
d1688 1
a1688 2
    struct pf_addr *naddr, u_int16_t *nport, u_int16_t low, u_int16_t high,
    struct pf_src_node **sn)
d1690 1
a1690 1
	struct pf_state		key;
d1695 1
a1695 1
	if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn))
d1701 3
a1703 3
		PF_ACPY(&key.ext.addr, daddr, key.af);
		PF_ACPY(&key.gwy.addr, naddr, key.af);
		key.ext.port = dport;
d1710 2
a1711 2
			key.gwy.port = 0;
			if (pf_find_state(&key, PF_EXT_GWY) == NULL)
d1714 2
a1715 2
			key.gwy.port = *nport;
			if (pf_find_state(&key, PF_EXT_GWY) == NULL) {
d1719 2
a1720 2
			key.gwy.port = htons(low);
			if (pf_find_state(&key, PF_EXT_GWY) == NULL) {
d1736 2
a1737 2
				key.gwy.port = htons(tmp);
				if (pf_find_state(&key, PF_EXT_GWY) ==
d1744 2
a1745 2
				key.gwy.port = htons(tmp);
				if (pf_find_state(&key, PF_EXT_GWY) ==
d1753 1
a1753 1
		switch (r->rpool.opts & PF_POOL_TYPEMASK) {
d1756 1
a1756 1
			if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn))
d1841 1
a1841 1
    struct ifnet *ifp, struct pf_src_node **sn,
d1870 1
a1870 1
			if (pf_get_sport(pd->af, pd->proto, r, saddr,
d1872 1
a1872 1
			    r->rpool.proxy_port[1], sn)) {
d1901 1
a1901 1
					    &r->src.addr.v.a.mask, daddr,
d1907 1
a1907 1
			if (pf_map_addr(r->af, r, saddr, naddr, NULL, sn))
d1937 2
a1938 1
pf_socket_lookup(uid_t *uid, gid_t *gid, int direction, struct pf_pdesc *pd)
d1947 1
a1947 1
	switch (pd->proto) {
d1973 1
a1973 1
	switch(pd->af) {
d1977 2
a1978 1
			inp = in_pcblookup_listen(tb, daddr->v4, dport, 0);
d1988 2
a1989 1
			inp = in6_pcblookup_listen(tb, &daddr->v6, dport, 0);
d2142 2
a2143 1
		pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL, &s->nat_src_node);
d2149 2
a2150 1
		pf_map_addr(AF_INET6, r, saddr, &s->rt_addr, NULL, &s->nat_src_node);
d2159 1
a2159 1
    struct ifnet *ifp, struct mbuf *m, int off, void *h,
d2162 1
a2162 1
	struct pf_rule		*nr = NULL;
d2164 1
a2172 1
	struct pf_src_node	*nsn = NULL;
d2184 1
a2184 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, ifp, &nsn,
d2186 2
a2187 2
		    &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
d2189 1
a2189 1
			    &th->th_sum, &pd->naddr, nport, 0, af);
d2191 1
a2191 1
			if (nr->natpass)
a2192 1
			pd->nat_rule = nr;
d2197 4
a2200 4
		if ((nr = pf_get_translation(pd, m, off, PF_IN, ifp, &nsn,
		    saddr, th->th_sport, daddr, th->th_dport,
		    &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
d2202 1
a2202 1
			    &th->th_sum, &pd->naddr, nport, 0, af);
d2204 1
a2204 1
			if (nr->natpass)
a2205 1
			pd->nat_rule = nr;
d2237 2
a2238 1
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
d2243 2
a2244 1
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
d2248 2
a2249 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
d2291 8
a2298 10
		if (nr != NULL) {
			if (direction == PF_OUT) {
				pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
				    &th->th_sum, &pd->baddr, bport, 0, af);
				rewrite++;
			} else {
				pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
				    &th->th_sum, &pd->baddr, bport, 0, af);
				rewrite++;
			}
d2329 1
a2329 1
	if (r->keep_state || nr != NULL ||
a2333 1
		struct pf_src_node *sn = NULL;
d2336 2
a2337 16

		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
a2338 14
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
d2347 4
a2350 1
		s->nat_rule.ptr = nr;
d2364 2
a2365 2
			if (nr != NULL) {
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
d2376 2
a2377 2
			if (nr != NULL) {
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
d2419 1
a2419 9
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
a2422 1
			pf_src_tree_remove_state(s);
a2429 1
			pf_src_tree_remove_state(s);
a2435 1
			pf_src_tree_remove_state(s);
d2443 8
a2450 11
			if (nr != NULL) {
				if (direction == PF_OUT) {
					pf_change_ap(saddr, &th->th_sport,
					    pd->ip_sum, &th->th_sum, &pd->baddr,
					    bport, 0, af);
				} else {
					pf_change_ap(daddr, &th->th_dport,
					    pd->ip_sum, &th->th_sum, &pd->baddr,
					    bport, 0, af);
				}
			}
d2473 1
a2473 1
    struct ifnet *ifp, struct mbuf *m, int off, void *h,
d2476 1
a2476 1
	struct pf_rule		*nr = NULL;
d2478 1
a2486 1
	struct pf_src_node	*nsn = NULL;
d2497 1
a2497 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, ifp, &nsn,
d2499 2
a2500 2
		    &pd->naddr, &nport)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
d2502 1
a2502 1
			    &uh->uh_sum, &pd->naddr, nport, 1, af);
d2504 1
a2504 1
			if (nr->natpass)
a2505 1
			pd->nat_rule = nr;
d2510 4
a2513 4
		if ((nr = pf_get_translation(pd, m, off, PF_IN, ifp, &nsn,
		    saddr, uh->uh_sport, daddr, uh->uh_dport, &pd->naddr,
		    &nport)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
d2515 1
a2515 1
			    &uh->uh_sum, &pd->naddr, nport, 1, af);
d2517 1
a2517 1
			if (nr->natpass)
a2518 1
			pd->nat_rule = nr;
d2548 2
a2549 1
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
d2554 2
a2555 1
		    pf_socket_lookup(&uid, &gid, direction, pd), 1)) &&
d2559 2
a2560 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
d2600 8
a2607 10
		if (nr != NULL) {
			if (direction == PF_OUT) {
				pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
				    &uh->uh_sum, &pd->baddr, bport, 1, af);
				rewrite++;
			} else {
				pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
				    &uh->uh_sum, &pd->baddr, bport, 1, af);
				rewrite++;
			}
d2625 1
a2625 1
	if (r->keep_state || nr != NULL) {
a2627 1
		struct pf_src_node *sn = NULL;
d2629 2
a2630 15
		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
a2631 14
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
d2640 4
a2643 1
		s->nat_rule.ptr = nr;
d2657 2
a2658 2
			if (nr != NULL) {
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
d2669 2
a2670 2
			if (nr != NULL) {
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
a2682 9
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
a2684 1
			pf_src_tree_remove_state(s);
d2700 1
a2700 1
    struct ifnet *ifp, struct mbuf *m, int off, void *h,
d2703 1
a2703 1
	struct pf_rule		*nr = NULL;
d2705 1
a2707 1
	struct pf_src_node	*nsn = NULL;
d2753 3
a2755 3
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, ifp, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
d2760 1
a2760 1
				    pd->naddr.v4.s_addr, 0);
d2766 1
a2766 1
				    &pd->naddr, 0);
d2771 1
a2771 1
			if (nr->natpass)
a2772 1
			pd->nat_rule = nr;
d2776 3
a2778 3
		if ((nr = pf_get_translation(pd, m, off, PF_IN, ifp, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
d2783 1
a2783 1
				    pd->ip_sum, pd->naddr.v4.s_addr, 0);
d2789 1
a2789 1
				    &pd->naddr, 0);
d2794 1
a2794 1
			if (nr->natpass)
a2795 1
			pd->nat_rule = nr;
d2822 2
a2823 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
d2870 2
a2871 1
	if (!state_icmp && (r->keep_state || nr != NULL)) {
a2873 1
		struct pf_src_node *sn = NULL;
d2875 2
a2876 15
		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
a2877 14
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
d2886 4
a2889 1
		s->nat_rule.ptr = nr;
d2903 2
a2904 2
			if (nr != NULL)
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
d2913 2
a2914 2
			if (nr != NULL)
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
a2922 9
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
a2924 1
			pf_src_tree_remove_state(s);
d2946 1
a2946 1
	struct pf_rule		*nr = NULL;
a2948 1
	struct pf_src_node	*nsn = NULL;
d2950 1
d2960 3
a2962 3
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, ifp, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, saddr, af);
d2967 1
a2967 1
				    pd->naddr.v4.s_addr, 0);
d2972 1
a2972 1
				PF_ACPY(saddr, &pd->naddr, af);
d2976 1
a2976 1
			if (nr->natpass)
a2977 1
			pd->nat_rule = nr;
d2981 3
a2983 3
		if ((nr = pf_get_translation(pd, m, off, PF_IN, ifp, &nsn,
		    saddr, 0, daddr, 0, &pd->naddr, NULL)) != NULL) {
			PF_ACPY(&pd->baddr, daddr, af);
d2988 1
a2988 1
				    pd->ip_sum, pd->naddr.v4.s_addr, 0);
d2993 1
a2993 1
				PF_ACPY(daddr, &pd->naddr, af);
d2997 1
a2997 1
			if (nr->natpass)
a2998 1
			pd->nat_rule = nr;
d3021 2
a3022 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, pftag, &tag))
d3060 4
a3063 6
		if (nr != NULL) {
			if (direction == PF_OUT)
				a = saddr;
			else
				a = daddr;
		}
d3069 1
a3069 1
				    pd->baddr.v4.s_addr, 0);
d3074 1
a3074 1
				PF_ACPY(a, &pd->baddr, af);
d3095 1
a3095 1
	if (r->keep_state || nr != NULL) {
a3097 1
		struct pf_src_node *sn = NULL;
d3099 2
a3100 15
		/* check maximums */
		if (r->max_states && (r->states >= r->max_states))
			goto cleanup;
		/* src node for flter rule */
		if ((r->rule_flag & PFRULE_SRCTRACK ||
		    r->rpool.opts & PF_POOL_STICKYADDR) &&
		    pf_insert_src_node(&sn, r, saddr, af) != 0)
			goto cleanup;
		/* src node for translation rule */
		if (nr != NULL && (nr->rpool.opts & PF_POOL_STICKYADDR) &&
		    ((direction == PF_OUT &&
		    pf_insert_src_node(&nsn, nr, &pd->baddr, af) != 0) ||
		    (pf_insert_src_node(&nsn, nr, saddr, af) != 0)))
			goto cleanup;
		s = pool_get(&pf_state_pl, PR_NOWAIT);
a3101 14
cleanup:
			if (sn != NULL && sn->states == 0 && sn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, sn);
			}
			if (nsn != sn && nsn != NULL && nsn->states == 0 &&
			    nsn->expire == 0) {
				RB_REMOVE(pf_src_tree, &tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&pf_src_tree_pl, nsn);
			}
d3110 4
a3113 1
		s->nat_rule.ptr = nr;
d3125 2
a3126 2
			if (nr != NULL)
				PF_ACPY(&s->lan.addr, &pd->baddr, af);
d3132 2
a3133 2
			if (nr != NULL)
				PF_ACPY(&s->gwy.addr, &pd->baddr, af);
a3142 9
		if (sn != NULL) {
			s->src_node = sn;
			s->src_node->states++;
		}
		if (nsn != NULL) {
			PF_ACPY(&nsn->raddr, &pd->naddr, af);
			s->nat_src_node = nsn;
			s->nat_src_node->states++;
		}
a3147 1
			pf_src_tree_remove_state(s);
d3191 2
a3192 1
		else if (r->match_tag && !pf_match_tag(m, r, NULL, pftag, &tag))
d3234 1
a3234 1
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd,
d3237 1
a3237 1
	struct pf_state		 key;
d3248 4
a3251 11
	if (direction == PF_IN)	{
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = th->th_sport;
		key.gwy.port = th->th_dport;
	} else {
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = th->th_sport;
		key.ext.port = th->th_dport;
	}
d3607 2
a3608 2
		if (pf_normalize_tcp_stateful(m, off, pd, reason, th,
		    src, dst, &copyback))
d3635 1
a3635 1
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd)
d3638 1
a3638 1
	struct pf_state		 key;
d3643 4
a3646 11
	if (direction == PF_IN)	{
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = uh->uh_sport;
		key.gwy.port = uh->uh_dport;
	} else {
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = uh->uh_sport;
		key.ext.port = uh->uh_dport;
	}
d3689 1
a3689 1
    struct mbuf *m, int off, void *h, struct pf_pdesc *pd)
d3732 1
a3732 1
		struct pf_state		key;
d3736 4
a3739 11
		if (direction == PF_IN)	{
			PF_ACPY(&key.ext.addr, pd->src, key.af);
			PF_ACPY(&key.gwy.addr, pd->dst, key.af);
			key.ext.port = icmpid;
			key.gwy.port = icmpid;
		} else {
			PF_ACPY(&key.lan.addr, pd->src, key.af);
			PF_ACPY(&key.ext.addr, pd->dst, key.af);
			key.lan.port = icmpid;
			key.ext.port = icmpid;
		}
d3898 1
a3898 1
			struct pf_state		 key;
d3916 4
a3919 11
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = th.th_dport;
				key.gwy.port = th.th_sport;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = th.th_dport;
				key.ext.port = th.th_sport;
			}
d4000 1
a4000 1
			struct pf_state		key;
d4012 4
a4015 11
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = uh.uh_dport;
				key.gwy.port = uh.uh_sport;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = uh.uh_dport;
				key.ext.port = uh.uh_sport;
			}
d4060 1
a4060 1
			struct pf_state		key;
d4072 4
a4075 11
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = iih.icmp_id;
				key.gwy.port = iih.icmp_id;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = iih.icmp_id;
				key.ext.port = iih.icmp_id;
			}
d4105 1
a4105 1
			struct pf_state		key;
d4117 4
a4120 11
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = iih.icmp6_id;
				key.gwy.port = iih.icmp6_id;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = iih.icmp6_id;
				key.ext.port = iih.icmp6_id;
			}
d4150 1
a4150 1
			struct pf_state		key;
d4154 4
a4157 11
			if (direction == PF_IN)	{
				PF_ACPY(&key.ext.addr, pd2.dst, key.af);
				PF_ACPY(&key.gwy.addr, pd2.src, key.af);
				key.ext.port = 0;
				key.gwy.port = 0;
			} else {
				PF_ACPY(&key.lan.addr, pd2.dst, key.af);
				PF_ACPY(&key.ext.addr, pd2.src, key.af);
				key.lan.port = 0;
				key.ext.port = 0;
			}
d4207 1
a4207 1
	struct pf_state		 key;
d4211 4
a4214 11
	if (direction == PF_IN)	{
		PF_ACPY(&key.ext.addr, pd->src, key.af);
		PF_ACPY(&key.gwy.addr, pd->dst, key.af);
		key.ext.port = 0;
		key.gwy.port = 0;
	} else {
		PF_ACPY(&key.lan.addr, pd->src, key.af);
		PF_ACPY(&key.ext.addr, pd->dst, key.af);
		key.lan.port = 0;
		key.ext.port = 0;
	}
a4360 1
	struct pf_src_node	*sn = NULL;
d4412 3
a4414 2
			pf_map_addr(AF_INET, r, (struct pf_addr *)&ip->ip_src,
			    &naddr, NULL, &sn);
a4449 28
#ifdef IPSEC
	/*
	 * If deferred crypto processing is needed, check that the
	 * interface supports it.
	 */
	if ((mtag = m_tag_find(m0, PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED, NULL))
	    != NULL && (ifp->if_capabilities & IFCAP_IPSEC) == 0) {
		/* Notify IPsec to do its own crypto. */
		ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
		goto bad;
	}
#endif /* IPSEC */

	/* Catch routing changes wrt. hardware checksumming for TCP or UDP. */
	if (m0->m_pkthdr.csum & M_TCPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_TCPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m0);
			m0->m_pkthdr.csum &= ~M_TCPV4_CSUM_OUT; /* Clear */
		}
	} else if (m0->m_pkthdr.csum & M_UDPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_UDPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m0);
			m0->m_pkthdr.csum &= ~M_UDPV4_CSUM_OUT; /* Clear */
		}
	}

a4525 1
	struct pf_src_node	*sn = NULL;
d4574 2
a4575 2
		pf_map_addr(AF_INET6, r, (struct pf_addr *)&ip6->ip6_src,
		    &naddr, NULL, &sn);
a4719 14
static int
pf_add_mbuf_tag(struct mbuf *m, u_int tag)
{
	struct m_tag *mtag;

	if (m_tag_find(m, tag, NULL) != NULL)
		return (0);
	mtag = m_tag_get(tag, 0, M_NOWAIT);
	if (mtag == NULL)
		return (1);
	m_tag_prepend(m, mtag);
	return (0);
}

d4727 1
a4727 1
	struct pf_rule	  *a = NULL, *r = &pf_default_rule, *tr, *nr;
a4741 1
	memset(&pd, 0, sizeof(pd));
d4765 1
a4767 1
	PF_ACPY(&pd.baddr, dir == PF_OUT ? pd.src : pd.dst, AF_INET);
d4803 1
a4803 1
		action = pf_test_state_tcp(&s, dir, ifp, m, off, h, &pd,
a4805 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
a4806 1
			a = s->anchor.ptr;
d4810 1
a4810 1
			    m, off, h, &pd, &a, &ruleset);
d4828 1
a4828 1
		action = pf_test_state_udp(&s, dir, ifp, m, off, h, &pd);
a4829 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
d4835 1
a4835 1
			    m, off, h, &pd, &a, &ruleset);
d4853 1
a4853 1
		action = pf_test_state_icmp(&s, dir, ifp, m, off, h, &pd);
a4854 4
#if NPFSYNC
			pfsync_update_state(s);
#endif

d4856 2
d4859 4
d4866 1
a4866 1
			    m, off, h, &pd, &a, &ruleset);
a4872 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
a4911 15
	/*
	 * connections redirected to loopback should not match sockets
	 * bound specifically to loopback due to security implications,
	 * see tcp_input() and in_pcblookup_listen().
	 */
	if (dir == PF_IN && action == PF_PASS && (pd.proto == IPPROTO_TCP ||
	    pd.proto == IPPROTO_UDP) && s != NULL && s->nat_rule.ptr != NULL &&
	    (s->nat_rule.ptr->action == PF_RDR ||
	    s->nat_rule.ptr->action == PF_BINAT) &&
	    (ntohl(pd.dst->v4.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET &&
	    pf_add_mbuf_tag(m, PACKET_TAG_PF_TRANSLATE_LOCALHOST)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_MEMORY);
	}

d4920 28
a4947 59
	if (action == PF_PASS || r->action == PF_DROP) {
		r->packets++;
		r->bytes += pd.tot_len;
		if (a != NULL) {
			a->packets++;
			a->bytes += pd.tot_len;
		}
		if (s != NULL) {
			dirndx = (dir == s->direction) ? 0 : 1;
			s->packets[dirndx]++;
			s->bytes[dirndx] += pd.tot_len;
			if (s->nat_rule.ptr != NULL) {
				s->nat_rule.ptr->packets++;
				s->nat_rule.ptr->bytes += pd.tot_len;
			}
			if (s->src_node != NULL) {
				s->src_node->packets++;
				s->src_node->bytes += pd.tot_len;
			}
			if (s->nat_src_node != NULL) {
				s->nat_src_node->packets++;
				s->nat_src_node->bytes += pd.tot_len;
			}
		}
		tr = r;
		nr = (s != NULL) ? s->nat_rule.ptr : pd.nat_rule;
		if (nr != NULL) {
			struct pf_addr *x;
			/*
			 * XXX: we need to make sure that the addresses
			 * passed to pfr_update_stats() are the same than
			 * the addresses used during matching (pfr_match)
			 */
			if (r == &pf_default_rule) {
				tr = nr;
				x = (s == NULL || s->direction == dir) ?
				    &pd.baddr : &pd.naddr;
			} else
				x = (s == NULL || s->direction == dir) ?
				    &pd.naddr : &pd.baddr;
			if (x == &pd.baddr || s == NULL) {
				/* we need to change the address */
				if (dir == PF_OUT)
					pd.src = x;
				else
					pd.dst = x;
			}
		}
		if (tr->src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->src.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.src : pd.dst, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->src.not);
		if (tr->dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->dst.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.dst : pd.src, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->dst.not);
	}
d4969 1
a4969 1
	struct pf_rule	  *a = NULL, *r = &pf_default_rule, *tr, *nr;
a4983 1
	memset(&pd, 0, sizeof(pd));
d4999 1
a5001 1
	PF_ACPY(&pd.baddr, dir == PF_OUT ? pd.src : pd.dst, AF_INET6);
d5067 1
a5067 1
		action = pf_test_state_tcp(&s, dir, ifp, m, off, h, &pd,
a5069 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
a5070 1
			a = s->anchor.ptr;
d5074 1
a5074 1
			    m, off, h, &pd, &a, &ruleset);
d5092 1
a5092 1
		action = pf_test_state_udp(&s, dir, ifp, m, off, h, &pd);
a5093 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
a5094 1
			a = s->anchor.ptr;
d5098 1
a5098 1
			    m, off, h, &pd, &a, &ruleset);
d5117 1
a5117 1
		    m, off, h, &pd);
a5118 3
#if NPFSYNC
			pfsync_update_state(s);
#endif
d5120 2
a5121 1
			a = s->anchor.ptr;
d5125 1
a5125 1
			    m, off, h, &pd, &a, &ruleset);
d5130 2
a5131 8
		action = pf_test_state_other(&s, dir, ifp, &pd);
		if (action == PF_PASS) {
			r = s->rule.ptr;
			a = s->anchor.ptr;
			log = s->log;
		} else if (s == NULL)
			action = pf_test_other(&r, &s, dir, ifp, m, off, h,
			    &pd, &a, &ruleset);
a5157 10
	if (dir == PF_IN && action == PF_PASS && (pd.proto == IPPROTO_TCP ||
	    pd.proto == IPPROTO_UDP) && s != NULL && s->nat_rule.ptr != NULL &&
	    (s->nat_rule.ptr->action == PF_RDR ||
	    s->nat_rule.ptr->action == PF_BINAT) &&
	    IN6_IS_ADDR_LOOPBACK(&pd.dst->v6) &&
	    pf_add_mbuf_tag(m, PACKET_TAG_PF_TRANSLATE_LOCALHOST)) {
		action = PF_DROP;
		REASON_SET(&reason, PFRES_MEMORY);
	}

d5166 28
a5193 59
	if (action == PF_PASS || r->action == PF_DROP) {
		r->packets++;
		r->bytes += pd.tot_len;
		if (a != NULL) {
			a->packets++;
			a->bytes += pd.tot_len;
		}
		if (s != NULL) {
			dirndx = (dir == s->direction) ? 0 : 1;
			s->packets[dirndx]++;
			s->bytes[dirndx] += pd.tot_len;
			if (s->nat_rule.ptr != NULL) {
				s->nat_rule.ptr->packets++;
				s->nat_rule.ptr->bytes += pd.tot_len;
			}
			if (s->src_node != NULL) {
				s->src_node->packets++;
				s->src_node->bytes += pd.tot_len;
			}
			if (s->nat_src_node != NULL) {
				s->nat_src_node->packets++;
				s->nat_src_node->bytes += pd.tot_len;
			}
		}
		tr = r;
		nr = (s != NULL) ? s->nat_rule.ptr : pd.nat_rule;
		if (nr != NULL) {
			struct pf_addr *x;
			/*
			 * XXX: we need to make sure that the addresses
			 * passed to pfr_update_stats() are the same than
			 * the addresses used during matching (pfr_match)
			 */
			if (r == &pf_default_rule) {
				tr = nr;
				x = (s == NULL || s->direction == dir) ?
				    &pd.baddr : &pd.naddr;
			} else {
				x = (s == NULL || s->direction == dir) ?
				    &pd.naddr : &pd.baddr;
			}
			if (x == &pd.baddr || s == NULL) {
				if (dir == PF_OUT)
					pd.src = x;
				else
					pd.dst = x;
			}
		}
		if (tr->src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->src.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.src : pd.dst, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->src.not);
		if (tr->dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr->dst.addr.p.tbl, (s == NULL ||
			    s->direction == dir) ? pd.dst : pd.src, pd.af,
			    pd.tot_len, dir == PF_OUT, r->action == PF_PASS,
			    tr->dst.not);
	}
@


1.1.1.24
log
@Import OpenBSD again, for various reasons.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.415 2003/12/31 22:14:42 deraadt Exp $ */
d102 1
d111 1
a111 1
struct pool		 pf_src_tree_pl, pf_rule_pl;
d138 1
a138 1
			    int, int, struct pfi_kif *,
d142 1
a142 1
			    int, int, struct pfi_kif *, struct pf_src_node **,
d147 1
a147 1
			    int, struct pfi_kif *, struct mbuf *, int,
d151 1
a151 1
			    int, struct pfi_kif *, struct mbuf *, int,
d155 1
a155 1
			    int, struct pfi_kif *, struct mbuf *, int,
d159 1
a159 1
			    int, struct pfi_kif *, struct mbuf *, int, void *,
d163 1
a163 1
			    struct pfi_kif *, struct mbuf *, void *,
d167 1
a167 1
			    struct pfi_kif *, struct mbuf *, int,
d170 1
a170 1
			    struct pfi_kif *, struct mbuf *, int,
d173 1
a173 1
			    struct pfi_kif *, struct mbuf *, int,
d176 1
a176 1
			    struct pfi_kif *, struct pf_pdesc *);
d208 1
a208 2
struct pf_state		*pf_find_state_recurse(struct pfi_kif *,
			    struct pf_state *, u_int8_t);
d216 1
a216 2
			*state = pf_find_state_recurse(		\
			    kif, &key, PF_EXT_GWY);			\
d218 1
a218 2
			*state = pf_find_state_recurse(		\
			    kif, &key, PF_LAN_EXT);			\
d226 2
a227 2
		    (*state)->rt_kif != NULL &&				\
		    (*state)->rt_kif != kif)				\
a238 4
#define LOCKED_IF(r, k) (((r)->rule_flag & PFRULE_IFBOUND) ? (k) :    \
	((r)->rule_flag & PFRULE_GRBOUND) ? (k)->pfik_parent :	       \
	(k)->pfik_parent->pfik_parent)

d248 2
a249 1

d254 1
a254 1
    u.s.entry_lan_ext, pf_state_compare_lan_ext);
d256 1
a256 1
    u.s.entry_ext_gwy, pf_state_compare_ext_gwy);
d258 1
a258 1
    u.s.entry_id, pf_state_compare_id);
d476 1
a476 8
pf_find_state_byid(struct pf_state *key)
{
	pf_status.fcounters[FCNT_STATE_SEARCH]++;
	return RB_FIND(pf_state_tree_id, &tree_id, key);
}

struct pf_state *
pf_find_state_recurse(struct pfi_kif *kif, struct pf_state *key, u_int8_t tree)
d478 1
a478 1
	struct pf_state *s;
d484 2
a485 7
		for (; kif != NULL; kif = kif->pfik_parent) {
			s = RB_FIND(pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext, key);
			if (s != NULL)
				return (s);
		}
		return (NULL);
d487 5
a491 7
		for (; kif != NULL; kif = kif->pfik_parent) {
			s = RB_FIND(pf_state_tree_ext_gwy,
			    &kif->pfik_ext_gwy, key);
			if (s != NULL)
				return (s);
		}
		return (NULL);
d493 3
a495 1
		panic("pf_find_state_recurse");
a496 9
}

struct pf_state *
pf_find_state_all(struct pf_state *key, u_int8_t tree, int *more)
{
	struct pf_state *s, *ss = NULL;
	struct pfi_kif	*kif;

	pf_status.fcounters[FCNT_STATE_SEARCH]++;
d498 1
a498 28
	switch(tree) {
	case PF_LAN_EXT:
		TAILQ_FOREACH(kif, &pfi_statehead, pfik_w_states) {
			s = RB_FIND(pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext, key);
			if (s == NULL)
				continue;
			if (more == NULL)
				return (s);
			ss = s;
			(*more)++;
		}
		return (ss);
	case PF_EXT_GWY:
		TAILQ_FOREACH(kif, &pfi_statehead, pfik_w_states) {
			s = RB_FIND(pf_state_tree_ext_gwy,
			    &kif->pfik_ext_gwy, key);
			if (s == NULL)
				continue;
			if (more == NULL)
				return (s);
			ss = s;
			(*more)++;
		}
		return (ss);
	default:
		panic("pf_find_state_all");
	}
d557 1
a557 1
pf_insert_state(struct pfi_kif *kif, struct pf_state *state)
d560 1
a560 2
	state->u.s.kif = kif;
	if (RB_INSERT(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state)) {
d580 1
a580 1
	if (RB_INSERT(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy, state)) {
d596 1
a596 1
		RB_REMOVE(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state);
d614 2
a615 2
		RB_REMOVE(pf_state_tree_lan_ext, &kif->pfik_lan_ext, state);
		RB_REMOVE(pf_state_tree_ext_gwy, &kif->pfik_ext_gwy, state);
a620 1
	pfi_attach_state(kif);
d729 2
a730 3
	for (cur = RB_MIN(pf_state_tree_id, &tree_id);
	    cur; cur = next) {
		next = RB_NEXT(pf_state_tree_id, &tree_id, cur);
d739 2
a740 4
			RB_REMOVE(pf_state_tree_ext_gwy,
			    &cur->u.s.kif->pfik_ext_gwy, cur);
			RB_REMOVE(pf_state_tree_lan_ext,
			    &cur->u.s.kif->pfik_lan_ext, cur);
d742 1
a757 1
			pfi_detach_state(cur->u.s.kif);
d943 1
a943 1
		if (cur->kif != prev->kif || cur->ifnot != prev->ifnot)
d986 5
a990 1
		return (aw1->p.dyn->pfid_kt != aw2->p.dyn->pfid_kt);
d1742 4
a1745 17
	if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
		if (af == AF_INET) {
			if (rpool->cur->addr.p.dyn->pfid_acnt4 < 1 &&
			    (rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN)
				return (1);
			 raddr = &rpool->cur->addr.p.dyn->pfid_addr4;
			 rmask = &rpool->cur->addr.p.dyn->pfid_mask4;
		} else {
			if (rpool->cur->addr.p.dyn->pfid_acnt6 < 1 &&
			    (rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN)
				return (1);
			raddr = &rpool->cur->addr.p.dyn->pfid_addr6;
			rmask = &rpool->cur->addr.p.dyn->pfid_mask6;
		}
	} else if (rpool->cur->addr.type == PF_ADDR_TABLE) {
a1804 5
		} else if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
			if (!pfr_pool_get(rpool->cur->addr.p.dyn->pfid_kt,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af))
				goto get_addr;
a1820 10
		} else if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
			rpool->tblidx = -1;
			if (pfr_pool_get(rpool->cur->addr.p.dyn->pfid_kt,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af)) {
				/* table contain no address of type 'af' */
				if (rpool->cur != acur)
					goto try_next;
				return (1);
			}
d1872 1
a1872 1
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL)
d1876 1
a1876 1
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL)
d1878 1
d1881 1
a1881 1
			if (pf_find_state_all(&key, PF_EXT_GWY, NULL) == NULL) {
d1898 1
a1898 1
				if (pf_find_state_all(&key, PF_EXT_GWY, NULL) ==
d1906 1
a1906 1
				if (pf_find_state_all(&key, PF_EXT_GWY, NULL) ==
d1934 1
a1934 1
    int direction, struct pfi_kif *kif, struct pf_addr *saddr, u_int16_t sport,
d1955 2
a1956 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d2002 1
a2002 1
    struct pfi_kif *kif, struct pf_src_node **sn,
d2010 1
a2010 1
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
d2013 1
a2013 1
			r = pf_match_translation(pd, m, off, direction, kif,
d2016 1
a2016 1
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
d2019 1
a2019 1
			r = pf_match_translation(pd, m, off, direction, kif,
d2045 5
a2049 23
				if (r->rpool.cur->addr.type == PF_ADDR_DYNIFTL){
					if (pd->af == AF_INET) {
						if (r->rpool.cur->addr.p.dyn->
						    pfid_acnt4 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_addr4,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_mask4,
						    saddr, AF_INET);
					} else {
						if (r->rpool.cur->addr.p.dyn->
						    pfid_acnt6 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_addr6,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_mask6,
						    saddr, AF_INET6);
					}
				} else
d2056 4
a2059 23
				if (r->rpool.cur->addr.type == PF_ADDR_DYNIFTL){
					if (pd->af == AF_INET) {
						if (r->src.addr.p.dyn->
						    pfid_acnt4 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->src.addr.p.dyn->
						    pfid_addr4,
						    &r->src.addr.p.dyn->
						    pfid_mask4,
						    daddr, AF_INET);
					} else {
						if (r->src.addr.p.dyn->
						    pfid_acnt6 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->src.addr.p.dyn->
						    pfid_addr6,
						    &r->src.addr.p.dyn->
						    pfid_mask6,
						    daddr, AF_INET6);
					}
				} else
d2294 1
a2294 1
	s->rt_kif = NULL;
d2301 1
a2301 1
		s->rt_kif = r->rpool.cur->kif;
d2307 1
a2307 1
		s->rt_kif = r->rpool.cur->kif;
d2315 1
a2315 1
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
d2340 1
a2340 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
d2354 1
a2354 1
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
d2369 2
a2370 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d2438 1
a2438 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d2626 1
a2626 1
		if (pf_insert_state(LOCKED_IF(r, kif), s)) {
d2670 1
a2670 1
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
d2694 1
a2694 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
d2708 1
a2708 1
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
d2723 2
a2724 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d2789 1
a2789 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d2915 1
a2915 1
		if (pf_insert_state(LOCKED_IF(r, kif), s)) {
d2933 1
a2933 1
    struct pfi_kif *kif, struct mbuf *m, int off, void *h,
d2986 1
a2986 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
d3010 1
a3010 1
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
d3036 2
a3037 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d3093 1
a3093 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d3190 1
a3190 1
		if (pf_insert_state(LOCKED_IF(r, kif), s)) {
d3211 1
a3211 1
    struct pfi_kif *kif, struct mbuf *m, int off, void *h, struct pf_pdesc *pd,
d3228 1
a3228 1
		if ((nr = pf_get_translation(pd, m, off, PF_OUT, kif, &nsn,
d3250 1
a3250 1
		if ((nr = pf_get_translation(pd, m, off, PF_IN, kif, &nsn,
d3274 2
a3275 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d3322 1
a3322 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d3448 1
a3448 1
		if (pf_insert_state(LOCKED_IF(r, kif), s)) {
d3451 1
a3451 1
				PFLOG_PACKET(kif, h, m, af, direction, reason,
d3464 1
a3464 1
pf_test_fragment(struct pf_rule **rm, int direction, struct pfi_kif *kif,
d3478 2
a3479 2
		if (r->kif != NULL &&
		    (r->kif != kif && r->kif != kif->pfik_parent) == !r->ifnot)
d3524 1
a3524 1
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset);
d3538 1
a3538 1
pf_test_state_tcp(struct pf_state **state, int direction, struct pfi_kif *kif,
d3946 1
a3946 1
pf_test_state_udp(struct pf_state **state, int direction, struct pfi_kif *kif,
d4007 1
a4007 1
pf_test_state_icmp(struct pf_state **state, int direction, struct pfi_kif *kif,
d4564 1
a4564 1
pf_test_state_other(struct pf_state **state, int direction, struct pfi_kif *kif,
d4785 1
a4785 2
			ifp = r->rpool.cur->kif ?
			    r->rpool.cur->kif->pfik_ifp : NULL;
d4790 1
a4790 1
			ifp = s->rt_kif ? s->rt_kif->pfik_ifp : NULL;
d4976 1
a4976 1
		ifp = r->rpool.cur->kif ? r->rpool.cur->kif->pfik_ifp : NULL;
d4981 1
a4981 1
		ifp = s->rt_kif ? s->rt_kif->pfik_ifp : NULL;
a5134 1
	struct pfi_kif	  *kif = pfi_index2kif[ifp->if_index];
d5162 1
a5162 1
	if (pf_normalize_ip(m0, dir, kif, &reason) != PF_PASS) {
d5188 1
a5188 1
		action = pf_test_fragment(&r, dir, kif, m, h,
d5212 1
a5212 1
		action = pf_normalize_tcp(dir, kif, m, 0, off, h, &pd);
d5215 1
a5215 1
		action = pf_test_state_tcp(&s, dir, kif, m, off, h, &pd,
d5225 1
a5225 1
			action = pf_test_tcp(&r, &s, dir, kif,
d5244 1
a5244 1
		action = pf_test_state_udp(&s, dir, kif, m, off, h, &pd);
d5253 1
a5253 1
			action = pf_test_udp(&r, &s, dir, kif,
d5272 1
a5272 1
		action = pf_test_state_icmp(&s, dir, kif, m, off, h, &pd);
d5277 1
d5282 1
a5282 1
			action = pf_test_icmp(&r, &s, dir, kif,
d5288 1
a5288 1
		action = pf_test_state_other(&s, dir, kif, &pd);
d5297 1
a5297 1
			action = pf_test_other(&r, &s, dir, kif, m, off, h,
d5348 1
a5348 1
		PFLOG_PACKET(kif, h, m, AF_INET, dir, reason, r, a, ruleset);
d5350 4
a5353 2
	kif->pfik_bytes[0][dir == PF_OUT][action != PF_PASS] += pd.tot_len;
	kif->pfik_packets[0][dir == PF_OUT][action != PF_PASS]++;
a5431 1
	struct pfi_kif	  *kif = pfi_index2kif[ifp->if_index];
d5459 1
a5459 1
	if (pf_normalize_ip6(m0, dir, kif, &reason) != PF_PASS) {
d5479 1
a5479 1
			action = pf_test_fragment(&r, dir, kif, m, h,
d5531 1
a5531 1
		action = pf_normalize_tcp(dir, kif, m, 0, off, h, &pd);
d5534 1
a5534 1
		action = pf_test_state_tcp(&s, dir, kif, m, off, h, &pd,
d5544 1
a5544 1
			action = pf_test_tcp(&r, &s, dir, kif,
d5563 1
a5563 1
		action = pf_test_state_udp(&s, dir, kif, m, off, h, &pd);
d5572 1
a5572 1
			action = pf_test_udp(&r, &s, dir, kif,
d5591 1
a5591 1
		action = pf_test_state_icmp(&s, dir, kif,
d5601 1
a5601 1
			action = pf_test_icmp(&r, &s, dir, kif,
d5607 1
a5607 1
		action = pf_test_state_other(&s, dir, kif, &pd);
d5613 1
a5613 1
			action = pf_test_other(&r, &s, dir, kif, m, off, h,
d5652 1
a5652 1
		PFLOG_PACKET(kif, h, m, AF_INET6, dir, reason, r, a, ruleset);
d5654 4
a5657 2
	kif->pfik_bytes[1][dir == PF_OUT][action != PF_PASS] += pd.tot_len;
	kif->pfik_packets[1][dir == PF_OUT][action != PF_PASS]++;
@


1.1.1.25
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.418 2004/01/06 20:24:33 dhartmei Exp $ */
d241 1
a241 1
#define BOUND_IFACE(r, k) (((r)->rule_flag & PFRULE_IFBOUND) ? (k) :   \
d1457 1
a1457 1
		icmp_error(m0, type, code, 0, (void *)NULL);
d2744 1
a2744 1
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
d3033 1
a3033 1
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
d3308 1
a3308 1
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
d3566 1
a3566 1
		if (pf_insert_state(BOUND_IFACE(r, kif), s)) {
a5363 6
		if (uh.uh_dport == 0 ||
		    ntohs(uh.uh_ulen) > m->m_pkthdr.len - off ||
		    ntohs(uh.uh_ulen) < sizeof(struct udphdr)) {
			action = PF_DROP;
			goto done;
		}
a5677 6
			action = PF_DROP;
			goto done;
		}
		if (uh.uh_dport == 0 ||
		    ntohs(uh.uh_ulen) > m->m_pkthdr.len - off ||
		    ntohs(uh.uh_ulen) < sizeof(struct udphdr)) {
@


1.1.1.26
log
@using: ========= cvsim-base-obsd _MirBSD: cvsim-src-openbsd,v 1.3 2004/01/27 17:17:54 tg Exp $ =========

In contrast to what people might believe now,
I am not "specially" attracted by CVS Imports
(neither am I a version number hunter).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.419 2004/01/27 09:31:15 markus Exp $ */
a5267 3
	if (kif == NULL)
		return (PF_DROP);

a5567 3

	if (kif == NULL)
		return (PF_DROP);
@


1.1.1.27
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.448 2004/05/11 07:34:11 dhartmei Exp $ */
a70 1
#include <netinet/if_ether.h>
a74 2

#if NPFSYNC > 0
a75 1
#endif /* NPFSYNC > 0 */
d84 4
d114 2
d117 2
d133 1
a133 2
			    u_int8_t, u_int16_t, u_int16_t, u_int8_t, int,
			    struct ether_header *, struct ifnet *);
d148 1
a148 1
			    struct pf_ruleset **, struct ifqueue *);
d152 1
a152 1
			    struct pf_ruleset **, struct ifqueue *);
d156 1
a156 1
			    struct pf_ruleset **, struct ifqueue *);
d160 1
a160 1
			    struct pf_ruleset **, struct ifqueue *);
d178 1
a178 1
			     struct pf_rule *, struct pf_tag **, int *);
a208 1
int			 pf_check_congestion(struct ifqueue *);
d210 2
a211 5
struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] = {
	{ &pf_state_pl, PFSTATE_HIWAT },
	{ &pf_src_tree_pl, PFSNODE_HIWAT },
	{ &pf_frent_pl, PFFRAG_FRENT_HIWAT }
};
a255 1
struct pf_state_queue state_updates;
d478 1
a478 1
#endif /* INET6 */
d484 1
a484 1
	return (RB_FIND(pf_state_tree_id, &tree_id, key));
d524 1
a524 1
	switch (tree) {
d558 1
a558 1
	struct pf_src_node	k;
d599 2
a600 2
		pf_status.scounters[SCNT_SRC_NODE_INSERT]++;
		pf_status.src_nodes++;
d630 1
d651 1
a671 1
	TAILQ_INSERT_HEAD(&state_updates, state, u.s.entry_updates);
d765 1
a765 2
				timeout =
				    pf_default_rule.timeout[PFTM_SRC_NODE];
d773 1
a773 2
				timeout =
				    pf_default_rule.timeout[PFTM_SRC_NODE];
a776 37
	s->src_node = s->nat_src_node = NULL;
}

void
pf_purge_expired_state(struct pf_state *cur)
{
	if (cur->src.state == PF_TCPS_PROXY_DST)
		pf_send_tcp(cur->rule.ptr, cur->af,
		    &cur->ext.addr, &cur->lan.addr,
		    cur->ext.port, cur->lan.port,
		    cur->src.seqhi, cur->src.seqlo + 1,
		    TH_RST|TH_ACK, 0, 0, 0, 1, NULL, NULL);
	RB_REMOVE(pf_state_tree_ext_gwy,
	    &cur->u.s.kif->pfik_ext_gwy, cur);
	RB_REMOVE(pf_state_tree_lan_ext,
	    &cur->u.s.kif->pfik_lan_ext, cur);
	RB_REMOVE(pf_state_tree_id, &tree_id, cur);
#if NPFSYNC
	pfsync_delete_state(cur);
#endif
	pf_src_tree_remove_state(cur);
	if (--cur->rule.ptr->states <= 0 &&
	    cur->rule.ptr->src_nodes <= 0)
		pf_rm_rule(NULL, cur->rule.ptr);
	if (cur->nat_rule.ptr != NULL)
		if (--cur->nat_rule.ptr->states <= 0 &&
			cur->nat_rule.ptr->src_nodes <= 0)
			pf_rm_rule(NULL, cur->nat_rule.ptr);
	if (cur->anchor.ptr != NULL)
		if (--cur->anchor.ptr->states <= 0)
			pf_rm_rule(NULL, cur->anchor.ptr);
	pf_normalize_tcp_cleanup(cur);
	pfi_detach_state(cur->u.s.kif);
	TAILQ_REMOVE(&state_updates, cur, u.s.entry_updates);
	pool_put(&pf_state_pl, cur);
	pf_status.fcounters[FCNT_STATE_REMOVALS]++;
	pf_status.states--;
d787 33
a819 2
		if (pf_state_expires(cur) <= time.tv_sec)
			pf_purge_expired_state(cur);
d1055 42
d1281 1
a1281 2
    u_int8_t flags, u_int16_t win, u_int16_t mss, u_int8_t ttl, int tag,
    struct ether_header *eh, struct ifnet *ifp)
d1284 1
d1314 3
d1318 2
a1319 1
	if (m == NULL)
a1320 9
	if (tag) {
		struct m_tag	*mtag;

		mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
		if (mtag == NULL) {
			m_freem(m);
			return;
		}
		m_tag_prepend(m, mtag);
d1322 1
a1324 1
		struct m_tag	*mtag;
d1337 1
a1337 1
#endif /* ALTQ */
d1402 2
a1403 22
		if (eh == NULL) {
			ip_output(m, (void *)NULL, (void *)NULL, 0,
			    (void *)NULL, (void *)NULL);
		} else {
			struct route		 ro;
			struct rtentry		 rt;
			struct ether_header	*e = (void *)ro.ro_dst.sa_data;

			if (ifp == NULL) {
				m_freem(m);
				return;
			}
			rt.rt_ifp = ifp;
			ro.ro_rt = &rt;
			ro.ro_dst.sa_len = sizeof(ro.ro_dst);
			ro.ro_dst.sa_family = pseudo_AF_HDRCMPLT;
			bcopy(eh->ether_dhost, e->ether_shost, ETHER_ADDR_LEN);
			bcopy(eh->ether_shost, e->ether_dhost, ETHER_ADDR_LEN);
			e->ether_type = eh->ether_type;
			ip_output(m, (void *)NULL, &ro, IP_ROUTETOETHER,
			    (void *)NULL, (void *)NULL);
		}
d1452 1
a1452 1
#endif /* ALTQ */
d1578 1
a1578 1
    struct pf_tag **pftag, int *tag)
d1581 3
a1583 3
		*pftag = pf_get_tag(m);
		if (*pftag != NULL)
			*tag = (*pftag)->tag;
d1767 1
a1767 1
	struct pf_pooladdr	*acur = rpool->cur;
d1797 1
a1797 3
		switch (af) {
#ifdef INET
		case AF_INET:
d1804 1
a1804 4
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
a1810 2
			break;
#endif /* INET6 */
d1832 1
a1832 1
				rpool->counter.addr32[0] = htonl(arc4random());
d1838 1
a1838 2
					rpool->counter.addr32[3] =
					    htonl(arc4random());
d1842 1
a1842 2
					rpool->counter.addr32[2] =
					    htonl(arc4random());
d1846 1
a1846 2
					rpool->counter.addr32[1] =
					    htonl(arc4random());
d1850 1
a1850 2
					rpool->counter.addr32[0] =
					    htonl(arc4random());
d1888 1
a1888 1
				/* table contains no address of type 'af' */
d1898 1
a1898 1
				/* table contains no address of type 'af' */
d1975 1
a1975 1
			cut = htonl(arc4random()) % (1 + high - low) + low;
d2006 1
d2065 2
d2110 1
d2127 1
a2127 3
					switch (pd->af) {
#ifdef INET
					case AF_INET:
d2137 1
a2137 4
						break;
#endif /* INET */
#ifdef INET6
					case AF_INET6:
a2146 2
						break;
#endif /* INET6 */
d2156 1
a2156 3
					switch (pd->af) {
#ifdef INET
					case AF_INET:
d2166 1
a2166 4
						break;
#endif /* INET */
#ifdef INET6
					case AF_INET6:
a2175 2
						break;
#endif /* INET6 */
d2208 1
d2251 1
a2251 2
	switch (pd->af) {
#ifdef INET
a2259 1
#endif /* INET */
d2307 1
a2307 1
			/* FALLTHROUGH */
a2313 1
			break;
d2343 1
a2343 1
			/* FALLTHROUGH */
a2349 1
			break;
d2418 1
a2418 2
		pf_map_addr(AF_INET, r, saddr, &s->rt_addr, NULL,
		    &s->nat_src_node);
d2424 1
a2424 2
		pf_map_addr(AF_INET6, r, saddr, &s->rt_addr, NULL,
		    &s->nat_src_node);
d2434 1
a2434 2
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    struct ifqueue *ifq)
a2452 3
	if (pf_check_congestion(ifq))
		return (PF_DROP);

d2522 1
a2522 1
		else if (r->prob && r->prob <= arc4random())
d2524 1
a2524 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d2587 1
a2587 1
			    r->return_ttl, 1, pd->eh, kif->pfik_ifp);
d2691 1
a2691 1
			while ((s->src.seqdiff = htonl(arc4random())) == 0)
d2737 2
a2738 5
		    pf_normalize_tcp_stateful(m, off, pd, &reason, th, s,
		    &s->src, &s->dst, &rewrite)) {
			/* This really shouldn't happen!!! */
			DPFPRINTF(PF_DEBUG_URGENT,
			    ("pf_normalize_tcp_stateful failed on first pkt"));
d2766 1
a2766 1
			s->src.seqhi = htonl(arc4random());
d2773 2
a2774 2
			    th->th_sport, s->src.seqhi, ntohl(th->th_seq) + 1,
			    TH_SYN|TH_ACK, 0, s->src.mss, 0, 1, NULL, NULL);
d2789 1
a2789 2
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    struct ifqueue *ifq)
a2806 3
	if (pf_check_congestion(ifq))
		return (PF_DROP);

d2874 1
a2874 1
		else if (r->prob && r->prob <= arc4random())
d2876 1
a2876 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d3052 1
a3052 2
    struct pf_pdesc *pd, struct pf_rule **am, struct pf_ruleset **rsm,
    struct ifqueue *ifq)
a3069 3
	if (pf_check_congestion(ifq))
		return (PF_DROP);

d3175 1
a3175 1
		else if (r->prob && r->prob <= arc4random())
d3177 1
a3177 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d3330 1
a3330 1
    struct pf_rule **am, struct pf_ruleset **rsm, struct ifqueue *ifq)
a3341 3
	if (pf_check_congestion(ifq))
		return (PF_DROP);

d3409 1
a3409 1
		else if (r->prob && r->prob <= arc4random())
d3411 1
a3411 1
		else if (r->match_tag && !pf_match_tag(m, r, nr, &pftag, &tag))
d3568 3
d3615 1
a3615 1
		else if (r->prob && r->prob <= arc4random())
d3617 1
a3617 1
		else if (r->match_tag && !pf_match_tag(m, r, NULL, &pftag, &tag))
d3663 1
a3663 1
	u_int32_t		 ack, end, seq, orig_seq;
d3702 1
a3702 2
			    TH_SYN|TH_ACK, 0, (*state)->src.mss, 0, 1,
			    NULL, NULL);
d3728 1
a3728 1
				(*state)->dst.seqhi = htonl(arc4random());
d3731 1
a3731 2
			    (*state)->dst.seqhi, 0, TH_SYN, 0,
			    (*state)->src.mss, 0, 0, NULL, NULL);
d3743 1
a3743 2
			    TH_ACK, (*state)->src.max_win, 0, 0, 1,
			    NULL, NULL);
d3747 1
a3747 2
			    TH_ACK, (*state)->dst.max_win, 0, 0, 0,
			    NULL, NULL);
d3775 1
a3775 1
	orig_seq = seq = ntohl(th->th_seq);
d3789 1
a3789 1
			while ((src->seqdiff = htonl(arc4random())) == 0)
d3885 1
a3885 1
	    (ackskew <= (MAXACKWINDOW << sws)) &&
a3886 9
	    ((th->th_flags & TH_RST) == 0 || orig_seq == src->seqlo ||
	    (pd->flags & PFDESC_IP_REAS) == 0)) {
	    /* Require an exact sequence match on resets when possible */

		if (dst->scrub || src->scrub) {
			if (pf_normalize_tcp_stateful(m, off, pd, reason, th,
			    *state, src, dst, &copyback))
				return (PF_DROP);
		}
a3971 6
		if (dst->scrub || src->scrub) {
			if (pf_normalize_tcp_stateful(m, off, pd, reason, th,
			    *state, src, dst, &copyback))
				return (PF_DROP);
		}

d4010 1
a4010 2
				    (*state)->rule.ptr->return_ttl, 1,
				    pd->eh, kif->pfik_ifp);
d4036 5
a4344 1
			int			 copyback = 0;
d4382 1
a4382 2
			if (src->wscale && dst->wscale &&
			    !(th.th_flags & TH_SYN))
d4389 2
a4390 2
			if (src->seqdiff) {
				pf_change_a(&th.th_seq, icmpsum,
a4391 2
				copyback = 1;
			}
d4411 1
a4411 1
					    daddr, &(*state)->lan.addr,
a4421 4
				copyback = 1;
			}

			if (copyback) {
d4442 2
d4785 1
a4785 2
		if (m->m_pkthdr.len < off + len ||
		    ntohs(h->ip_len) < off + len) {
a4839 1
	struct m_tag		*mtag;
d4845 1
d4854 8
a4861 14
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
d4863 2
a4864 5
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
a4865 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
d4912 1
d4916 11
a4926 1
	if (oifp != ifp) {
d4999 1
a4999 2
	if (error) {
		m0 = NULL;
a5000 1
	}
d5048 8
a5055 6
	if ((mtag = m_tag_find(*m, PACKET_TAG_PF_ROUTED, NULL)) == NULL) {
		if ((mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 1, M_NOWAIT)) ==
		    NULL) {
			m0 = *m;
			*m = NULL;
			goto bad;
d5057 2
a5058 13
		*(char *)(mtag + 1) = 1;
		m_tag_prepend(*m, mtag);
	} else {
		if (*(char *)(mtag + 1) > 3) {
			m0 = *m;
			*m = NULL;
			goto bad;
		}
		(*(char *)(mtag + 1))++;
	}

	if (r->rt == PF_DUPTO) {
		if ((m0 = m_copym2(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
a5059 3
		if ((mtag = m_tag_copy(mtag)) == NULL)
			goto bad;
		m_tag_prepend(m0, mtag);
d5102 1
d5107 11
a5117 7
		if (pf_test6(PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip6_hdr))
			panic("pf_route6: m0->m_len < sizeof(struct ip6_hdr)");
		ip6 = mtod(m0, struct ip6_hdr *);
d5155 1
a5155 2
pf_check_proto_cksum(struct mbuf *m, int off, int len, u_int8_t p,
    sa_family_t af)
a5186 1
#ifdef INET
a5201 1
#endif /* INET */
d5254 9
a5262 16
	return pf_test_eh(dir, ifp, m0, NULL);
}

int
pf_test_eh(int dir, struct ifnet *ifp, struct mbuf **m0,
    struct ether_header *eh)
{
	struct pfi_kif		*kif;
	u_short			 action, reason = 0, log = 0;
	struct mbuf		*m = *m0;
	struct ip		*h;
	struct pf_rule		*a = NULL, *r = &pf_default_rule, *tr, *nr;
	struct pf_state		*s = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_pdesc		 pd;
	int			 off, dirndx, pqid = 0;
a5267 1
	kif = pfi_index2kif[ifp->if_index];
d5274 1
a5274 1
#endif /* DIAGNOSTIC */
d5285 1
a5285 1
	if (pf_normalize_ip(m0, dir, kif, &reason, &pd) != PF_PASS) {
a5307 1
	pd.eh = eh;
d5343 1
a5343 1
#endif /* NPFSYNC */
d5349 1
a5349 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
d5377 1
a5377 1
#endif /* NPFSYNC */
d5383 1
a5383 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
d5405 1
a5405 1
#endif /* NPFSYNC */
d5411 1
a5411 1
			    m, off, h, &pd, &a, &ruleset, &ipintrq);
d5420 1
a5420 1
#endif /* NPFSYNC */
d5426 1
a5426 1
			    &pd, &a, &ruleset, &ipintrq);
d5458 1
a5458 1
#endif /* ALTQ */
d5558 9
a5566 16
	return pf_test6_eh(dir, ifp, m0, NULL);
}

int
pf_test6_eh(int dir, struct ifnet *ifp, struct mbuf **m0,
    struct ether_header *eh)
{
	struct pfi_kif		*kif;
	u_short			 action, reason = 0, log = 0;
	struct mbuf		*m = *m0;
	struct ip6_hdr		*h;
	struct pf_rule		*a = NULL, *r = &pf_default_rule, *tr, *nr;
	struct pf_state		*s = NULL;
	struct pf_ruleset	*ruleset = NULL;
	struct pf_pdesc		 pd;
	int			 off, terminal = 0, dirndx;
a5571 1
	kif = pfi_index2kif[ifp->if_index];
d5578 1
a5578 1
#endif /* DIAGNOSTIC */
d5589 1
a5589 1
	if (pf_normalize_ip6(m0, dir, kif, &reason, &pd) != PF_PASS) {
a5602 1
	pd.eh = eh;
d5669 1
a5669 1
#endif /* NPFSYNC */
d5675 1
a5675 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
d5703 1
a5703 1
#endif /* NPFSYNC */
d5709 1
a5709 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
d5732 1
a5732 1
#endif /* NPFSYNC */
d5738 1
a5738 1
			    m, off, h, &pd, &a, &ruleset, &ip6intrq);
a5744 3
#if NPFSYNC
			pfsync_update_state(s);
#endif /* NPFSYNC */
d5750 1
a5750 1
			    &pd, &a, &ruleset, &ip6intrq);
d5775 1
a5775 1
#endif /* ALTQ */
a5864 9

int
pf_check_congestion(struct ifqueue *ifq)
{
	if (ifq->ifq_congestion)
		return (1);
	else
		return (0);
}
@


