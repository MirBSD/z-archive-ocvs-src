head	1.7;
access;
symbols
	MIRBSD_7quater:1.1.1.3
	cvs-200405160640:1.1.1.4
	cvs-200401271800:1.1.1.3
	cvs-200401261630:1.1.1.3
	cvs-200401021645:1.1.1.3
	MIRBSD_7_ALPHA:1.1.1.3.0.6
	MIRBSD_7:1.1.1.3.0.4
	cvs-200312222040:1.1.1.3
	MIRBSD_7ter:1.1.1.3
	MIRBSD_7_DEV:1.1.1.3.0.2
	cvs-200310020700:1.1.1.3
	cvs-200309271030:1.1.1.3
	cvs-200309261655:1.1.1.3
	cvs-200309251530:1.1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	cvs-200307072125:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200307030815:1.1.1.2
	cvs-200307021520:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.07.15.19.32.17;	author tg;	state dead;
branches;
next	1.6;

1.6
date	2004.06.19.01.48.14;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.19.01.36.10;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.27.19.32.50;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.27.19.10.43;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.05.19.28.01;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.50.39;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.50.39;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.21.19.07.29;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.30.23.18.04;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.16.08.53.10;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@sparc has to die :(

it was nice while it lasted, but I couldn't even live up to
my promise to provide XFree86 4.4.0 on sparc due to lack of
time (and money and health).

also, compat_freebsd dies, without prejudice.

<mirabile> benz: sparc darf sterben?
<mirabile> compat_freebsd darf sterben?
<benz> na gut

in addition, some set shuffling (it was a good idea originally
to pull out gcc3 specifics to the egcs set, but with gcc3 being
the only compiler that isn't it any more)
@
text
@/*	$MirBSD: src/sys/compat/freebsd/freebsd_syscallargs.h,v 1.6 2004/06/19 01:48:14 tg Exp $	*/

/*
 * System call argument lists.
 *
 * DO NOT EDIT-- this file is automatically generated.
 * created from	MirBSD: src/sys/compat/freebsd/syscalls.master,v 1.3 2004/06/19 01:36:10 tg Exp 
 */

#ifdef	syscallarg
#undef	syscallarg
#endif

#define	syscallarg(x)							\
	union {								\
		register_t pad;						\
		struct { x datum; } le;					\
		struct {						\
			int8_t pad[ (sizeof (register_t) < sizeof (x))	\
				? 0					\
				: sizeof (register_t) - sizeof (x)];	\
			x datum;					\
		} be;							\
	}

struct freebsd_sys_open_args {
	syscallarg(char *) path;
	syscallarg(int) flags;
	syscallarg(int) mode;
};

struct compat_43_freebsd_sys_creat_args {
	syscallarg(char *) path;
	syscallarg(int) mode;
};

struct freebsd_sys_link_args {
	syscallarg(char *) path;
	syscallarg(char *) link;
};

struct freebsd_sys_unlink_args {
	syscallarg(char *) path;
};

struct freebsd_sys_chdir_args {
	syscallarg(char *) path;
};

struct freebsd_sys_mknod_args {
	syscallarg(char *) path;
	syscallarg(int) mode;
	syscallarg(int) dev;
};

struct freebsd_sys_chmod_args {
	syscallarg(char *) path;
	syscallarg(int) mode;
};

struct freebsd_sys_chown_args {
	syscallarg(char *) path;
	syscallarg(int) uid;
	syscallarg(int) gid;
};

struct freebsd_sys_getfsstat_args {
	syscallarg(struct freebsd_statfs *) buf;
	syscallarg(long) bufsize;
	syscallarg(int) flags;
};

struct freebsd_sys_mount_args {
	syscallarg(int) type;
	syscallarg(char *) path;
	syscallarg(int) flags;
	syscallarg(caddr_t) data;
};

struct freebsd_sys_unmount_args {
	syscallarg(char *) path;
	syscallarg(int) flags;
};

struct freebsd_sys_ptrace_args {
	syscallarg(int) req;
	syscallarg(pid_t) pid;
	syscallarg(caddr_t) addr;
	syscallarg(int) data;
};

struct freebsd_sys_access_args {
	syscallarg(char *) path;
	syscallarg(int) flags;
};

struct freebsd_sys_chflags_args {
	syscallarg(char *) path;
	syscallarg(int) flags;
};

struct compat_43_freebsd_sys_stat_args {
	syscallarg(char *) path;
	syscallarg(struct ostat *) ub;
};

struct compat_43_freebsd_sys_lstat_args {
	syscallarg(char *) path;
	syscallarg(struct ostat *) ub;
};

struct freebsd_sys_ioctl_args {
	syscallarg(int) fd;
	syscallarg(u_long) com;
	syscallarg(caddr_t) data;
};

struct freebsd_sys_revoke_args {
	syscallarg(char *) path;
};

struct freebsd_sys_symlink_args {
	syscallarg(char *) path;
	syscallarg(char *) link;
};

struct freebsd_sys_readlink_args {
	syscallarg(char *) path;
	syscallarg(char *) buf;
	syscallarg(int) count;
};

struct freebsd_sys_execve_args {
	syscallarg(char *) path;
	syscallarg(char **) argp;
	syscallarg(char **) envp;
};

struct freebsd_sys_chroot_args {
	syscallarg(char *) path;
};

struct freebsd_sys_madvise_args {
	syscallarg(caddr_t) addr;
	syscallarg(size_t) len;
	syscallarg(int) behav;
};

struct freebsd_sys_fcntl_args {
	syscallarg(int) fd;
	syscallarg(int) cmd;
	syscallarg(void *) arg;
};

struct freebsd_sys_sigreturn_args {
	syscallarg(struct freebsd_sigcontext *) scp;
};

struct freebsd_sys_rename_args {
	syscallarg(char *) from;
	syscallarg(char *) to;
};

struct compat_43_freebsd_sys_truncate_args {
	syscallarg(char *) path;
	syscallarg(long) length;
};

struct freebsd_sys_mkfifo_args {
	syscallarg(char *) path;
	syscallarg(int) mode;
};

struct freebsd_sys_mkdir_args {
	syscallarg(char *) path;
	syscallarg(int) mode;
};

struct freebsd_sys_rmdir_args {
	syscallarg(char *) path;
};

struct freebsd_sys_statfs_args {
	syscallarg(char *) path;
	syscallarg(struct freebsd_statfs *) buf;
};

struct freebsd_sys_fstatfs_args {
	syscallarg(int) fd;
	syscallarg(struct freebsd_statfs *) buf;
};

struct freebsd_sys_getfh_args {
	syscallarg(char *) fname;
	syscallarg(fhandle_t *) fhp;
};

struct freebsd_sys_rtprio_args {
	syscallarg(int) function;
	syscallarg(pid_t) pid;
	syscallarg(struct freebsd_rtprio *) rtp;
};

struct freebsd_sys_stat_args {
	syscallarg(char *) path;
	syscallarg(struct stat *) ub;
};

struct freebsd_sys_lstat_args {
	syscallarg(char *) path;
	syscallarg(struct stat *) ub;
};

struct freebsd_sys_pathconf_args {
	syscallarg(char *) path;
	syscallarg(int) name;
};

struct freebsd_sys_truncate_args {
	syscallarg(char *) path;
	syscallarg(int) pad;
	syscallarg(off_t) length;
};

struct freebsd_sys_undelete_args {
	syscallarg(char *) path;
};

struct freebsd_sys_poll2_args {
	syscallarg(struct pollfd *) fds;
	syscallarg(unsigned long) nfds;
	syscallarg(int) timeout;
};

struct freebsd_sys_sigprocmask40_args {
	syscallarg(int) how;
	syscallarg(const freebsd_sigset_t *) set;
	syscallarg(freebsd_sigset_t *) oset;
};

struct freebsd_sys_sigsuspend40_args {
	syscallarg(const freebsd_sigset_t *) sigmask;
};

struct freebsd_sys_sigaction40_args {
	syscallarg(int) sig;
	syscallarg(const struct freebsd_sigaction *) act;
	syscallarg(struct freebsd_sigaction *) oact;
};

struct freebsd_sys_sigpending40_args {
	syscallarg(freebsd_sigset_t *) set;
};

/*
 * System call prototypes.
 */

int	sys_nosys(struct proc *, void *, register_t *);
int	sys_exit(struct proc *, void *, register_t *);
int	sys_fork(struct proc *, void *, register_t *);
int	sys_read(struct proc *, void *, register_t *);
int	sys_write(struct proc *, void *, register_t *);
int	freebsd_sys_open(struct proc *, void *, register_t *);
int	sys_close(struct proc *, void *, register_t *);
int	sys_wait4(struct proc *, void *, register_t *);
int	compat_43_freebsd_sys_creat(struct proc *, void *, register_t *);
int	freebsd_sys_link(struct proc *, void *, register_t *);
int	freebsd_sys_unlink(struct proc *, void *, register_t *);
int	freebsd_sys_chdir(struct proc *, void *, register_t *);
int	sys_fchdir(struct proc *, void *, register_t *);
int	freebsd_sys_mknod(struct proc *, void *, register_t *);
int	freebsd_sys_chmod(struct proc *, void *, register_t *);
int	freebsd_sys_chown(struct proc *, void *, register_t *);
int	sys_obreak(struct proc *, void *, register_t *);
int	freebsd_sys_getfsstat(struct proc *, void *, register_t *);
int	compat_43_sys_lseek(struct proc *, void *, register_t *);
int	sys_getpid(struct proc *, void *, register_t *);
int	freebsd_sys_mount(struct proc *, void *, register_t *);
int	freebsd_sys_unmount(struct proc *, void *, register_t *);
int	sys_setuid(struct proc *, void *, register_t *);
int	sys_getuid(struct proc *, void *, register_t *);
int	sys_geteuid(struct proc *, void *, register_t *);
#ifdef PTRACE
int	freebsd_sys_ptrace(struct proc *, void *, register_t *);
#else
#endif
int	sys_recvmsg(struct proc *, void *, register_t *);
int	sys_sendmsg(struct proc *, void *, register_t *);
int	sys_recvfrom(struct proc *, void *, register_t *);
int	sys_accept(struct proc *, void *, register_t *);
int	sys_getpeername(struct proc *, void *, register_t *);
int	sys_getsockname(struct proc *, void *, register_t *);
int	freebsd_sys_access(struct proc *, void *, register_t *);
int	freebsd_sys_chflags(struct proc *, void *, register_t *);
int	sys_fchflags(struct proc *, void *, register_t *);
int	sys_sync(struct proc *, void *, register_t *);
int	sys_kill(struct proc *, void *, register_t *);
int	compat_43_freebsd_sys_stat(struct proc *, void *, register_t *);
int	sys_getppid(struct proc *, void *, register_t *);
int	compat_43_freebsd_sys_lstat(struct proc *, void *, register_t *);
int	sys_dup(struct proc *, void *, register_t *);
int	sys_opipe(struct proc *, void *, register_t *);
int	sys_getegid(struct proc *, void *, register_t *);
int	sys_profil(struct proc *, void *, register_t *);
#ifdef KTRACE
int	sys_ktrace(struct proc *, void *, register_t *);
#else
#endif
int	sys_sigaction(struct proc *, void *, register_t *);
int	sys_getgid(struct proc *, void *, register_t *);
int	sys_sigprocmask(struct proc *, void *, register_t *);
int	sys_getlogin(struct proc *, void *, register_t *);
int	sys_setlogin(struct proc *, void *, register_t *);
int	sys_acct(struct proc *, void *, register_t *);
int	sys_sigpending(struct proc *, void *, register_t *);
int	sys_sigaltstack(struct proc *, void *, register_t *);
int	freebsd_sys_ioctl(struct proc *, void *, register_t *);
int	sys_reboot(struct proc *, void *, register_t *);
int	freebsd_sys_revoke(struct proc *, void *, register_t *);
int	freebsd_sys_symlink(struct proc *, void *, register_t *);
int	freebsd_sys_readlink(struct proc *, void *, register_t *);
int	freebsd_sys_execve(struct proc *, void *, register_t *);
int	sys_umask(struct proc *, void *, register_t *);
int	freebsd_sys_chroot(struct proc *, void *, register_t *);
int	compat_43_sys_fstat(struct proc *, void *, register_t *);
int	compat_43_sys_getkerninfo(struct proc *, void *, register_t *);
int	compat_43_sys_getpagesize(struct proc *, void *, register_t *);
int	sys_msync(struct proc *, void *, register_t *);
int	sys_vfork(struct proc *, void *, register_t *);
int	sys_sbrk(struct proc *, void *, register_t *);
int	sys_sstk(struct proc *, void *, register_t *);
int	compat_43_sys_mmap(struct proc *, void *, register_t *);
int	sys_ovadvise(struct proc *, void *, register_t *);
int	sys_munmap(struct proc *, void *, register_t *);
int	sys_mprotect(struct proc *, void *, register_t *);
int	freebsd_sys_madvise(struct proc *, void *, register_t *);
int	sys_mincore(struct proc *, void *, register_t *);
int	sys_getgroups(struct proc *, void *, register_t *);
int	sys_setgroups(struct proc *, void *, register_t *);
int	sys_getpgrp(struct proc *, void *, register_t *);
int	sys_setpgid(struct proc *, void *, register_t *);
int	sys_setitimer(struct proc *, void *, register_t *);
int	compat_43_sys_wait(struct proc *, void *, register_t *);
int	compat_25_sys_swapon(struct proc *, void *, register_t *);
int	sys_getitimer(struct proc *, void *, register_t *);
int	compat_43_sys_gethostname(struct proc *, void *, register_t *);
int	compat_43_sys_sethostname(struct proc *, void *, register_t *);
int	compat_43_sys_getdtablesize(struct proc *, void *, register_t *);
int	sys_dup2(struct proc *, void *, register_t *);
int	freebsd_sys_fcntl(struct proc *, void *, register_t *);
int	sys_select(struct proc *, void *, register_t *);
int	sys_fsync(struct proc *, void *, register_t *);
int	sys_setpriority(struct proc *, void *, register_t *);
int	sys_socket(struct proc *, void *, register_t *);
int	sys_connect(struct proc *, void *, register_t *);
int	compat_43_sys_accept(struct proc *, void *, register_t *);
int	sys_getpriority(struct proc *, void *, register_t *);
int	compat_43_sys_send(struct proc *, void *, register_t *);
int	compat_43_sys_recv(struct proc *, void *, register_t *);
int	freebsd_sys_sigreturn(struct proc *, void *, register_t *);
int	sys_bind(struct proc *, void *, register_t *);
int	sys_setsockopt(struct proc *, void *, register_t *);
int	sys_listen(struct proc *, void *, register_t *);
int	compat_43_sys_sigvec(struct proc *, void *, register_t *);
int	compat_43_sys_sigblock(struct proc *, void *, register_t *);
int	compat_43_sys_sigsetmask(struct proc *, void *, register_t *);
int	sys_sigsuspend(struct proc *, void *, register_t *);
int	compat_43_sys_sigstack(struct proc *, void *, register_t *);
int	compat_43_sys_recvmsg(struct proc *, void *, register_t *);
int	compat_43_sys_sendmsg(struct proc *, void *, register_t *);
#ifdef TRACE
int	sys_vtrace(struct proc *, void *, register_t *);
#else
#endif
int	sys_gettimeofday(struct proc *, void *, register_t *);
int	sys_getrusage(struct proc *, void *, register_t *);
int	sys_getsockopt(struct proc *, void *, register_t *);
int	sys_readv(struct proc *, void *, register_t *);
int	sys_writev(struct proc *, void *, register_t *);
int	sys_settimeofday(struct proc *, void *, register_t *);
int	sys_fchown(struct proc *, void *, register_t *);
int	sys_fchmod(struct proc *, void *, register_t *);
int	compat_43_sys_recvfrom(struct proc *, void *, register_t *);
int	sys_setreuid(struct proc *, void *, register_t *);
int	sys_setregid(struct proc *, void *, register_t *);
int	freebsd_sys_rename(struct proc *, void *, register_t *);
int	compat_43_freebsd_sys_truncate(struct proc *, void *, register_t *);
int	compat_43_sys_ftruncate(struct proc *, void *, register_t *);
int	sys_flock(struct proc *, void *, register_t *);
int	freebsd_sys_mkfifo(struct proc *, void *, register_t *);
int	sys_sendto(struct proc *, void *, register_t *);
int	sys_shutdown(struct proc *, void *, register_t *);
int	sys_socketpair(struct proc *, void *, register_t *);
int	freebsd_sys_mkdir(struct proc *, void *, register_t *);
int	freebsd_sys_rmdir(struct proc *, void *, register_t *);
int	sys_utimes(struct proc *, void *, register_t *);
int	sys_adjtime(struct proc *, void *, register_t *);
int	compat_43_sys_getpeername(struct proc *, void *, register_t *);
int	compat_43_sys_gethostid(struct proc *, void *, register_t *);
int	compat_43_sys_sethostid(struct proc *, void *, register_t *);
int	compat_43_sys_getrlimit(struct proc *, void *, register_t *);
int	compat_43_sys_setrlimit(struct proc *, void *, register_t *);
int	compat_43_sys_killpg(struct proc *, void *, register_t *);
int	sys_setsid(struct proc *, void *, register_t *);
int	sys_quotactl(struct proc *, void *, register_t *);
int	compat_43_sys_quota(struct proc *, void *, register_t *);
int	compat_43_sys_getsockname(struct proc *, void *, register_t *);
#if defined(NFSCLIENT) || defined(NFSSERVER)
int	sys_nfssvc(struct proc *, void *, register_t *);
#else
#endif
int	compat_43_sys_getdirentries(struct proc *, void *, register_t *);
int	freebsd_sys_statfs(struct proc *, void *, register_t *);
int	freebsd_sys_fstatfs(struct proc *, void *, register_t *);
#ifdef NFSCLIENT
int	freebsd_sys_getfh(struct proc *, void *, register_t *);
#else
#endif
int	compat_09_sys_getdomainname(struct proc *, void *, register_t *);
int	compat_09_sys_setdomainname(struct proc *, void *, register_t *);
int	compat_09_sys_uname(struct proc *, void *, register_t *);
int	sys_sysarch(struct proc *, void *, register_t *);
int	freebsd_sys_rtprio(struct proc *, void *, register_t *);
#if defined(SYSVSEM) && !defined(alpha)
int	compat_10_sys_semsys(struct proc *, void *, register_t *);
#else
#endif
#if defined(SYSVMSG) && !defined(alpha)
int	compat_10_sys_msgsys(struct proc *, void *, register_t *);
#else
#endif
#if defined(SYSVSHM) && !defined(alpha)
int	compat_10_sys_shmsys(struct proc *, void *, register_t *);
#else
#endif
int	sys_pread(struct proc *, void *, register_t *);
int	sys_pwrite(struct proc *, void *, register_t *);
int	sys_setgid(struct proc *, void *, register_t *);
int	sys_setegid(struct proc *, void *, register_t *);
int	sys_seteuid(struct proc *, void *, register_t *);
#ifdef LFS
int	lfs_bmapv(struct proc *, void *, register_t *);
int	lfs_markv(struct proc *, void *, register_t *);
int	lfs_segclean(struct proc *, void *, register_t *);
int	lfs_segwait(struct proc *, void *, register_t *);
#else
#endif
int	freebsd_sys_stat(struct proc *, void *, register_t *);
int	sys_fstat(struct proc *, void *, register_t *);
int	freebsd_sys_lstat(struct proc *, void *, register_t *);
int	freebsd_sys_pathconf(struct proc *, void *, register_t *);
int	sys_fpathconf(struct proc *, void *, register_t *);
int	sys_getrlimit(struct proc *, void *, register_t *);
int	sys_setrlimit(struct proc *, void *, register_t *);
int	sys_getdirentries(struct proc *, void *, register_t *);
int	sys_mmap(struct proc *, void *, register_t *);
int	sys_nosys(struct proc *, void *, register_t *);
int	sys_lseek(struct proc *, void *, register_t *);
int	freebsd_sys_truncate(struct proc *, void *, register_t *);
int	sys_ftruncate(struct proc *, void *, register_t *);
int	sys___sysctl(struct proc *, void *, register_t *);
int	sys_mlock(struct proc *, void *, register_t *);
int	sys_munlock(struct proc *, void *, register_t *);
#ifdef FREEBSD_BASED_ON_44LITE_R2
int	freebsd_sys_undelete(struct proc *, void *, register_t *);
#else
#endif
int	sys_getpgid(struct proc *, void *, register_t *);
int	sys_poll(struct proc *, void *, register_t *);
#ifdef SYSVSEM
int	sys___semctl(struct proc *, void *, register_t *);
int	sys_semget(struct proc *, void *, register_t *);
int	sys_semop(struct proc *, void *, register_t *);
#else
#endif
#ifdef SYSVMSG
int	sys_msgctl(struct proc *, void *, register_t *);
int	sys_msgget(struct proc *, void *, register_t *);
int	sys_msgsnd(struct proc *, void *, register_t *);
int	sys_msgrcv(struct proc *, void *, register_t *);
#else
#endif
#ifdef SYSVSHM
int	sys_shmat(struct proc *, void *, register_t *);
int	sys_shmctl(struct proc *, void *, register_t *);
int	sys_shmdt(struct proc *, void *, register_t *);
int	sys_shmget(struct proc *, void *, register_t *);
#else
#endif
int	sys_clock_gettime(struct proc *, void *, register_t *);
int	sys_nanosleep(struct proc *, void *, register_t *);
int	sys_minherit(struct proc *, void *, register_t *);
int	sys_rfork(struct proc *, void *, register_t *);
int	freebsd_sys_poll2(struct proc *, void *, register_t *);
int	sys_issetugid(struct proc *, void *, register_t *);
int	sys_lchown(struct proc *, void *, register_t *);
int	sys_setresuid(struct proc *, void *, register_t *);
int	sys_setresgid(struct proc *, void *, register_t *);
int	freebsd_sys_sigprocmask40(struct proc *, void *, register_t *);
int	freebsd_sys_sigsuspend40(struct proc *, void *, register_t *);
int	freebsd_sys_sigaction40(struct proc *, void *, register_t *);
int	freebsd_sys_sigpending40(struct proc *, void *, register_t *);
int	sys_kqueue(struct proc *, void *, register_t *);
int	sys_kevent(struct proc *, void *, register_t *);
@


1.6
log
@* sync
* make msdosfs not spit out E2BIG diagnostics to console unmotiviedly
  (msdosfs sucks, someone ought to do a better FAT-compatible FS impl)
* speed up make by defining OSNAME only if it's not already defined
  in <sys.mk> (you might use the environment for example)
* bump OS patchlevel
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
@


1.5
log
@reverting just enough and fixing here and there so to make
the linuxulator back work
@
text
@d7 1
a7 1
 * created from	MirBSD: src/sys/compat/freebsd/syscalls.master,v 1.2 2004/05/27 19:10:44 tg Exp 
@


1.4
log
@* syscall files: sync
* exec_elf stuff: recognize "MirOS BSD" and "MirOS Linux", respectively
@
text
@a72 6
struct compat_43_sys_lseek_args {
	syscallarg(int) fd;
	syscallarg(long) offset;
	syscallarg(int) whence;
};

a142 21
struct compat_43_sys_fstat_args {
	syscallarg(int) fd;
	syscallarg(struct ostat *) sb;
};

struct compat_43_sys_getkerninfo_args {
	syscallarg(int) op;
	syscallarg(char *) where;
	syscallarg(int *) size;
	syscallarg(int) arg;
};

struct compat_43_sys_mmap_args {
	syscallarg(caddr_t) addr;
	syscallarg(size_t) len;
	syscallarg(int) prot;
	syscallarg(int) flags;
	syscallarg(int) fd;
	syscallarg(long) pos;
};

a148 14
struct compat_25_sys_swapon_args {
	syscallarg(char *) name;
};

struct compat_43_sys_gethostname_args {
	syscallarg(char *) hostname;
	syscallarg(u_int) len;
};

struct compat_43_sys_sethostname_args {
	syscallarg(char *) hostname;
	syscallarg(u_int) len;
};

a158 40
struct compat_43_sys_sigvec_args {
	syscallarg(int) signum;
	syscallarg(struct sigvec *) nsv;
	syscallarg(struct sigvec *) osv;
};

struct compat_43_sys_sigblock_args {
	syscallarg(int) mask;
};

struct compat_43_sys_sigsetmask_args {
	syscallarg(int) mask;
};

struct compat_43_sys_sigstack_args {
	syscallarg(struct sigstack *) nss;
	syscallarg(struct sigstack *) oss;
};

struct compat_43_sys_recvmsg_args {
	syscallarg(int) s;
	syscallarg(struct omsghdr *) msg;
	syscallarg(int) flags;
};

struct compat_43_sys_sendmsg_args {
	syscallarg(int) s;
	syscallarg(caddr_t) msg;
	syscallarg(int) flags;
};

struct compat_43_sys_recvfrom_args {
	syscallarg(int) s;
	syscallarg(caddr_t) buf;
	syscallarg(size_t) len;
	syscallarg(int) flags;
	syscallarg(caddr_t) from;
	syscallarg(int *) fromlenaddr;
};

a168 5
struct compat_43_sys_ftruncate_args {
	syscallarg(int) fd;
	syscallarg(long) length;
};

a182 33
struct compat_43_sys_getpeername_args {
	syscallarg(int) fdes;
	syscallarg(caddr_t) asa;
	syscallarg(int *) alen;
};

struct compat_43_sys_sethostid_args {
	syscallarg(int32_t) hostid;
};

struct compat_43_sys_getrlimit_args {
	syscallarg(u_int) which;
	syscallarg(struct ogetrlimit *) rlp;
};

struct compat_43_sys_killpg_args {
	syscallarg(int) pgid;
	syscallarg(int) signum;
};

struct compat_43_sys_getsockname_args {
	syscallarg(int) fdec;
	syscallarg(caddr_t) asa;
	syscallarg(int *) alen;
};

struct compat_43_sys_getdirentries_args {
	syscallarg(int) fd;
	syscallarg(char *) buf;
	syscallarg(u_int) count;
	syscallarg(long *) basep;
};

a197 14
struct compat_09_sys_getdomainname_args {
	syscallarg(char *) domainname;
	syscallarg(int) len;
};

struct compat_09_sys_setdomainname_args {
	syscallarg(char *) domainname;
	syscallarg(int) len;
};

struct compat_09_sys_uname_args {
	syscallarg(struct outsname *) name;
};

a201 24
};

struct compat_10_sys_semsys_args {
	syscallarg(int) which;
	syscallarg(int) a2;
	syscallarg(int) a3;
	syscallarg(int) a4;
	syscallarg(int) a5;
};

struct compat_10_sys_msgsys_args {
	syscallarg(int) which;
	syscallarg(int) a2;
	syscallarg(int) a3;
	syscallarg(int) a4;
	syscallarg(int) a5;
	syscallarg(int) a6;
};

struct compat_10_sys_shmsys_args {
	syscallarg(int) which;
	syscallarg(int) a2;
	syscallarg(int) a3;
	syscallarg(int) a4;
@


1.3
log
@* make kernel (GENERIC i386) build
* nuke more NS parts
* nuke more SVR4 compat
* fix compats
* more MirOS RCS IDs
* better randomness usage/distribution
* better paranoia checks in random stuff
* use \$SHELL instead of sh
etc.pp
@
text
@d7 1
a7 1
 * created from	MirBSD
@


1.2
log
@regen. *oops* is that late.

includes:
CVSROOT:        /cvs
Module name:    src
Changes by:     millert@@cvs.openbsd.org 2003/01/29 20:32:44

Modified files:
        sys/sys        : syscallargs.h syscall.h
        sys/kern       : syscalls.c
        sys/compat/bsdos: bsdos_syscall.h bsdos_syscallargs.h
                          bsdos_syscalls.c bsdos_sysent.c
        sys/compat/freebsd: freebsd_syscall.h freebsd_syscallargs.h
                            freebsd_syscalls.c freebsd_sysent.c
        sys/compat/netbsd: netbsd_syscall.h netbsd_syscallargs.h
                           netbsd_syscalls.c netbsd_sysent.c
        sys/compat/osf1: osf1_syscall.h osf1_syscallargs.h
                         osf1_syscalls.c osf1_sysent.c
        sys/compat/sunos: sunos_syscall.h sunos_syscallargs.h
                          sunos_syscalls.c sunos_sysent.c
        sys/compat/svr4: svr4_syscall.h svr4_syscallargs.h
                         svr4_syscalls.c svr4_sysent.c
        sys/compat/ultrix: ultrix_syscall.h ultrix_syscallargs.h
                           ultrix_syscalls.c ultrix_sysent.c

Log message:
regen now that setreuid/setregid have moved out of compat and into kern
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d7 1
a7 1
 * created from	OpenBSD: syscalls.master,v 1.20 2003/01/30 03:29:49 millert Exp 
d73 6
d149 21
d176 14
d200 40
d250 5
d269 33
d317 14
d337 24
d502 1
a502 1
int	sys_swapon(struct proc *, void *, register_t *);
d594 2
d661 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_syscallargs.h,v 1.23 2003/01/30 03:32:44 millert Exp $	*/
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_syscallargs.h,v 1.24 2003/05/10 17:55:56 miod Exp $	*/
d7 1
a7 1
 * created from	OpenBSD: syscalls.master,v 1.21 2003/05/10 17:53:57 miod Exp 
d345 1
a345 1
int	compat_25_sys_swapon(struct proc *, void *, register_t *);
@


1.1.1.3
log
@Synchronize with OpenBSD 3.4-beta
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_syscallargs.h,v 1.25 2003/08/24 00:03:03 tedu Exp $	*/
d7 1
a7 1
 * created from	OpenBSD: syscalls.master,v 1.22 2003/08/24 00:02:42 tedu Exp 
a436 2
int	sys_pread(struct proc *, void *, register_t *);
int	sys_pwrite(struct proc *, void *, register_t *);
@


1.1.1.4
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_syscallargs.h,v 1.26 2004/02/17 20:09:08 tedu Exp $	*/
d7 1
a7 1
 * created from	OpenBSD: syscalls.master,v 1.23 2004/02/17 20:08:43 tedu Exp 
a503 2
int	sys_kqueue(struct proc *, void *, register_t *);
int	sys_kevent(struct proc *, void *, register_t *);
@


