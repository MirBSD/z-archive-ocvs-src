head	1.2;
access;
symbols
	tg-mergetmp-mirosx-1:1.2
	tg-mergefixes-1-branch:1.2.0.4
	tg-mergefixes-1-base:1.2
	MIROS_X:1.2.0.2
	MIROS_X_BASE:1.2
	tg-mergetmp-3:1.2
	cvs-200412092114:1.1.1.4
	MIRBSD_XP_MIRPPC:1.1.1.3.0.4
	cvs-200410261930:1.1.1.4
	MIRBSD_XP_SPARC_BASE:1.1.1.3
	MIRBSD_XP_SPARC:1.1.1.3.0.2
	cvs-200405160640:1.1.1.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	cvs-200401021645:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.12.09.21.38.39;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.02.17.55.54;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.01.02.17.55.54;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.01.26.18.56.13;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.16.09.12.22;	author tg;	state Stab;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.12.09.21.15.37;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@some amount of un-merging required for kernel to build
@
text
@/* $OpenBSD: ufs_dirhash.c,v 1.7 2004/03/16 06:28:27 tedu Exp $	*/
/*
 * Copyright (c) 2001, 2002 Ian Dowse.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * This implements a hash-based lookup scheme for UFS directories.
 */

#if 0
__FBSDID("$FreeBSD: src/sys/ufs/ufs/ufs_dirhash.c,v 1.18 2004/02/15 21:39:35 dwmalone Exp $");
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/lock.h>
#include <sys/rwlock.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/sysctl.h>
#include <sys/hash.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ufs/dirhash.h>
#include <ufs/ufs/extattr.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#define WRAPINCR(val, limit)	(((val) + 1 == (limit)) ? 0 : ((val) + 1))
#define WRAPDECR(val, limit)	(((val) == 0) ? ((limit) - 1) : ((val) - 1))
#define OFSFMT(vp)		((vp)->v_mount->mnt_maxsymlinklen <= 0)
#define BLKFREE2IDX(n)		((n) > DH_NFSTATS ? DH_NFSTATS : (n))

int ufs_mindirhashsize;
int ufs_dirhashmaxmem;
int ufs_dirhashmem;
int ufs_dirhashcheck;


int ufsdirhash_hash(struct dirhash *dh, char *name, int namelen);
void ufsdirhash_adjfree(struct dirhash *dh, doff_t offset, int diff);
void ufsdirhash_delslot(struct dirhash *dh, int slot);
int ufsdirhash_findslot(struct dirhash *dh, char *name, int namelen,
   doff_t offset);
doff_t ufsdirhash_getprev(struct direct *dp, doff_t offset);
int ufsdirhash_recycle(int wanted);

struct pool		ufsdirhash_pool;

#define	DIRHASHLIST_LOCK()	rw_enter_write(&ufsdirhash_mtx, curproc)
#define	DIRHASHLIST_UNLOCK()	rw_exit_write(&ufsdirhash_mtx)
#define	DIRHASH_LOCK(dh)	rw_enter_write(&(dh)->dh_mtx, curproc)
#define	DIRHASH_UNLOCK(dh)	rw_exit_write(&(dh)->dh_mtx)
#define	DIRHASH_BLKALLOC_WAITOK()	pool_get(&ufsdirhash_pool, PR_WAITOK)
#define	DIRHASH_BLKFREE(v)		pool_put(&ufsdirhash_pool, v)

#define	mtx_assert(l, f)	/* nothing */
#define DIRHASH_ASSERT(e, m)	KASSERT((e))

/* Dirhash list; recently-used entries are near the tail. */
TAILQ_HEAD(, dirhash) ufsdirhash_list;

/* Protects: ufsdirhash_list, `dh_list' field, ufs_dirhashmem. */
struct rwlock		ufsdirhash_mtx;

/*
 * Locking order:
 *	ufsdirhash_mtx
 *	dh_mtx
 *
 * The dh_mtx mutex should be acquired either via the inode lock, or via
 * ufsdirhash_mtx. Only the owner of the inode may free the associated
 * dirhash, but anything can steal its memory and set dh_hash to NULL.
 */

/*
 * Attempt to build up a hash table for the directory contents in
 * inode 'ip'. Returns 0 on success, or -1 of the operation failed.
 */
int
ufsdirhash_build(struct inode *ip)
{
	struct dirhash *dh;
	struct buf *bp = NULL;
	struct direct *ep;
	struct vnode *vp;
	doff_t bmask, pos;
	int dirblocks, i, j, memreqd, nblocks, narrays, nslots, slot;

	/* Check if we can/should use dirhash. */
	if (ip->i_dirhash == NULL) {
		if (ip->i_size < ufs_mindirhashsize || OFSFMT(ip->i_vnode))
			return (-1);
	} else {
		/* Hash exists, but sysctls could have changed. */
		if (ip->i_size < ufs_mindirhashsize ||
		    ufs_dirhashmem > ufs_dirhashmaxmem) {
			ufsdirhash_free(ip);
			return (-1);
		}
		/* Check if hash exists and is intact (note: unlocked read). */
		if (ip->i_dirhash->dh_hash != NULL)
			return (0);
		/* Free the old, recycled hash and build a new one. */
		ufsdirhash_free(ip);
	}

	/* Don't hash removed directories. */
	if (ip->i_effnlink == 0)
		return (-1);

	vp = ip->i_vnode;
	/* Allocate 50% more entries than this dir size could ever need. */
	DIRHASH_ASSERT(ip->i_size >= DIRBLKSIZ, ("ufsdirhash_build size"));
	nslots = ip->i_size / DIRECTSIZ(1);
	nslots = (nslots * 3 + 1) / 2;
	narrays = howmany(nslots, DH_NBLKOFF);
	nslots = narrays * DH_NBLKOFF;
	dirblocks = howmany(ip->i_size, DIRBLKSIZ);
	nblocks = (dirblocks * 3 + 1) / 2;

	memreqd = sizeof(*dh) + narrays * sizeof(*dh->dh_hash) +
	    narrays * DH_NBLKOFF * sizeof(**dh->dh_hash) +
	    nblocks * sizeof(*dh->dh_blkfree);
	DIRHASHLIST_LOCK();
	if (memreqd + ufs_dirhashmem > ufs_dirhashmaxmem) {
		DIRHASHLIST_UNLOCK();
		if (memreqd > ufs_dirhashmaxmem / 2)
			return (-1);

		/* Try to free some space. */
		if (ufsdirhash_recycle(memreqd) != 0)
			return (-1);
		/* Enough was freed, and list has been locked. */
	}
	ufs_dirhashmem += memreqd;
	DIRHASHLIST_UNLOCK();

	/*
	 * Use non-blocking mallocs so that we will revert to a linear
	 * lookup on failure rather than potentially blocking forever.
	 */
	MALLOC(dh, struct dirhash *, sizeof *dh, M_DIRHASH, M_NOWAIT);
	if (dh == NULL) {
		DIRHASHLIST_LOCK();
		ufs_dirhashmem -= memreqd;
		DIRHASHLIST_UNLOCK();
		return (-1);
	}
	memset(dh, 0, sizeof *dh);
	dh->dh_hash = malloc(narrays * sizeof(dh->dh_hash[0]),
	    M_DIRHASH, M_NOWAIT);
	memset(dh->dh_hash, 0, narrays * sizeof(dh->dh_hash[0]));
	dh->dh_blkfree = malloc(nblocks * sizeof(dh->dh_blkfree[0]),
	    M_DIRHASH, M_NOWAIT);
	if (dh->dh_hash == NULL || dh->dh_blkfree == NULL)
		goto fail;
	for (i = 0; i < narrays; i++) {
		if ((dh->dh_hash[i] = DIRHASH_BLKALLOC_WAITOK()) == NULL)
			goto fail;
		for (j = 0; j < DH_NBLKOFF; j++)
			dh->dh_hash[i][j] = DIRHASH_EMPTY;
	}

	/* Initialise the hash table and block statistics. */
	rw_init(&dh->dh_mtx);
	dh->dh_narrays = narrays;
	dh->dh_hlen = nslots;
	dh->dh_nblk = nblocks;
	dh->dh_dirblks = dirblocks;
	for (i = 0; i < dirblocks; i++)
		dh->dh_blkfree[i] = DIRBLKSIZ / DIRALIGN;
	for (i = 0; i < DH_NFSTATS; i++)
		dh->dh_firstfree[i] = -1;
	dh->dh_firstfree[DH_NFSTATS] = 0;
	dh->dh_seqopt = 0;
	dh->dh_seqoff = 0;
	dh->dh_score = DH_SCOREINIT;
	ip->i_dirhash = dh;

	bmask = VFSTOUFS(vp->v_mount)->um_mountp->mnt_stat.f_iosize - 1;
	pos = 0;
	while (pos < ip->i_size) {
		/* If necessary, get the next directory block. */
		if ((pos & bmask) == 0) {
			if (bp != NULL)
				brelse(bp);
			if (UFS_BUFATOFF(ip, (off_t)pos, NULL, &bp) != 0)
				goto fail;
		}

		/* Add this entry to the hash. */
		ep = (struct direct *)((char *)bp->b_data + (pos & bmask));
		if (ep->d_reclen == 0 || ep->d_reclen >
		    DIRBLKSIZ - (pos & (DIRBLKSIZ - 1))) {
			/* Corrupted directory. */
			brelse(bp);
			goto fail;
		}
		if (ep->d_ino != 0) {
			/* Add the entry (simplified ufsdirhash_add). */
			slot = ufsdirhash_hash(dh, ep->d_name, ep->d_namlen);
			while (DH_ENTRY(dh, slot) != DIRHASH_EMPTY)
				slot = WRAPINCR(slot, dh->dh_hlen);
			dh->dh_hused++;
			DH_ENTRY(dh, slot) = pos;
			ufsdirhash_adjfree(dh, pos, -DIRSIZ(0, ep));
		}
		pos += ep->d_reclen;
	}

	if (bp != NULL)
		brelse(bp);
	DIRHASHLIST_LOCK();
	TAILQ_INSERT_TAIL(&ufsdirhash_list, dh, dh_list);
	dh->dh_onlist = 1;
	DIRHASHLIST_UNLOCK();
	return (0);

fail:
	if (dh->dh_hash != NULL) {
		for (i = 0; i < narrays; i++)
			if (dh->dh_hash[i] != NULL)
				DIRHASH_BLKFREE(dh->dh_hash[i]);
		free(dh->dh_hash, M_DIRHASH);
	}
	if (dh->dh_blkfree != NULL)
		free(dh->dh_blkfree, M_DIRHASH);
	FREE(dh, M_DIRHASH);
	ip->i_dirhash = NULL;
	DIRHASHLIST_LOCK();
	ufs_dirhashmem -= memreqd;
	DIRHASHLIST_UNLOCK();
	return (-1);
}

/*
 * Free any hash table associated with inode 'ip'.
 */
void
ufsdirhash_free(struct inode *ip)
{
	struct dirhash *dh;
	int i, mem;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASHLIST_LOCK();
	DIRHASH_LOCK(dh);
	if (dh->dh_onlist)
		TAILQ_REMOVE(&ufsdirhash_list, dh, dh_list);
	DIRHASH_UNLOCK(dh);
	DIRHASHLIST_UNLOCK();

	/* The dirhash pointed to by 'dh' is exclusively ours now. */

	mem = sizeof(*dh);
	if (dh->dh_hash != NULL) {
		for (i = 0; i < dh->dh_narrays; i++)
			DIRHASH_BLKFREE(dh->dh_hash[i]);
		free(dh->dh_hash, M_DIRHASH);
		free(dh->dh_blkfree, M_DIRHASH);
		mem += dh->dh_narrays * sizeof(*dh->dh_hash) +
		    dh->dh_narrays * DH_NBLKOFF * sizeof(**dh->dh_hash) +
		    dh->dh_nblk * sizeof(*dh->dh_blkfree);
	}
	FREE(dh, M_DIRHASH);
	ip->i_dirhash = NULL;

	DIRHASHLIST_LOCK();
	ufs_dirhashmem -= mem;
	DIRHASHLIST_UNLOCK();
}

/*
 * Find the offset of the specified name within the given inode.
 * Returns 0 on success, ENOENT if the entry does not exist, or
 * EJUSTRETURN if the caller should revert to a linear search.
 *
 * If successful, the directory offset is stored in *offp, and a
 * pointer to a struct buf containing the entry is stored in *bpp. If
 * prevoffp is non-NULL, the offset of the previous entry within
 * the DIRBLKSIZ-sized block is stored in *prevoffp (if the entry
 * is the first in a block, the start of the block is used).
 */
int
ufsdirhash_lookup(struct inode *ip, char *name, int namelen, doff_t *offp,
    struct buf **bpp, doff_t *prevoffp)
{
	struct dirhash *dh, *dh_next;
	struct direct *dp;
	struct vnode *vp;
	struct buf *bp;
	doff_t blkoff, bmask, offset, prevoff;
	int i, slot;

	if ((dh = ip->i_dirhash) == NULL)
		return (EJUSTRETURN);
	/*
	 * Move this dirhash towards the end of the list if it has a
	 * score higher than the next entry, and acquire the dh_mtx.
	 * Optimise the case where it's already the last by performing
	 * an unlocked read of the TAILQ_NEXT pointer.
	 *
	 * In both cases, end up holding just dh_mtx.
	 */
	if (TAILQ_NEXT(dh, dh_list) != NULL) {
		DIRHASHLIST_LOCK();
		DIRHASH_LOCK(dh);
		/*
		 * If the new score will be greater than that of the next
		 * entry, then move this entry past it. With both mutexes
		 * held, dh_next won't go away, but its dh_score could
		 * change; that's not important since it is just a hint.
		 */
		if (dh->dh_hash != NULL &&
		    (dh_next = TAILQ_NEXT(dh, dh_list)) != NULL &&
		    dh->dh_score >= dh_next->dh_score) {
			DIRHASH_ASSERT(dh->dh_onlist, ("dirhash: not on list"));
			TAILQ_REMOVE(&ufsdirhash_list, dh, dh_list);
			TAILQ_INSERT_AFTER(&ufsdirhash_list, dh_next, dh,
			    dh_list);
		}
		DIRHASHLIST_UNLOCK();
	} else {
		/* Already the last, though that could change as we wait. */
		DIRHASH_LOCK(dh);
	}
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return (EJUSTRETURN);
	}

	/* Update the score. */
	if (dh->dh_score < DH_SCOREMAX)
		dh->dh_score++;

	vp = ip->i_vnode;
	bmask = VFSTOUFS(vp->v_mount)->um_mountp->mnt_stat.f_iosize - 1;
	blkoff = -1;
	bp = NULL;
restart:
	slot = ufsdirhash_hash(dh, name, namelen);

	if (dh->dh_seqopt) {
		/*
		 * Sequential access optimisation. dh_seqoff contains the
		 * offset of the directory entry immediately following
		 * the last entry that was looked up. Check if this offset
		 * appears in the hash chain for the name we are looking for.
		 */
		for (i = slot; (offset = DH_ENTRY(dh, i)) != DIRHASH_EMPTY;
		    i = WRAPINCR(i, dh->dh_hlen))
			if (offset == dh->dh_seqoff)
				break;
		if (offset == dh->dh_seqoff) {
			/*
			 * We found an entry with the expected offset. This
			 * is probably the entry we want, but if not, the
			 * code below will turn off seqoff and retry.
			 */
			slot = i;
		} else
			dh->dh_seqopt = 0;
	}

	for (; (offset = DH_ENTRY(dh, slot)) != DIRHASH_EMPTY;
	    slot = WRAPINCR(slot, dh->dh_hlen)) {
		if (offset == DIRHASH_DEL)
			continue;
		DIRHASH_UNLOCK(dh);

		if (offset < 0 || offset >= ip->i_size)
			panic("ufsdirhash_lookup: bad offset in hash array");
		if ((offset & ~bmask) != blkoff) {
			if (bp != NULL)
				brelse(bp);
			blkoff = offset & ~bmask;
			if (UFS_BUFATOFF(ip, (off_t)blkoff, NULL, &bp) != 0)
				return (EJUSTRETURN);
		}
		dp = (struct direct *)(bp->b_data + (offset & bmask));
		if (dp->d_reclen == 0 || dp->d_reclen >
		    DIRBLKSIZ - (offset & (DIRBLKSIZ - 1))) {
			/* Corrupted directory. */
			brelse(bp);
			return (EJUSTRETURN);
		}
		if (dp->d_namlen == namelen &&
		    bcmp(dp->d_name, name, namelen) == 0) {
			/* Found. Get the prev offset if needed. */
			if (prevoffp != NULL) {
				if (offset & (DIRBLKSIZ - 1)) {
					prevoff = ufsdirhash_getprev(dp,
					    offset);
					if (prevoff == -1) {
						brelse(bp);
						return (EJUSTRETURN);
					}
				} else
					prevoff = offset;
				*prevoffp = prevoff;
			}

			/* Check for sequential access, and update offset. */
			if (dh->dh_seqopt == 0 && dh->dh_seqoff == offset)
				dh->dh_seqopt = 1;
			dh->dh_seqoff = offset + DIRSIZ(0, dp);

			*bpp = bp;
			*offp = offset;
			return (0);
		}

		DIRHASH_LOCK(dh);
		if (dh->dh_hash == NULL) {
			DIRHASH_UNLOCK(dh);
			if (bp != NULL)
				brelse(bp);
			ufsdirhash_free(ip);
			return (EJUSTRETURN);
		}
		/*
		 * When the name doesn't match in the seqopt case, go back
		 * and search normally.
		 */
		if (dh->dh_seqopt) {
			dh->dh_seqopt = 0;
			goto restart;
		}
	}
	DIRHASH_UNLOCK(dh);
	if (bp != NULL)
		brelse(bp);
	return (ENOENT);
}

/*
 * Find a directory block with room for 'slotneeded' bytes. Returns
 * the offset of the directory entry that begins the free space.
 * This will either be the offset of an existing entry that has free
 * space at the end, or the offset of an entry with d_ino == 0 at
 * the start of a DIRBLKSIZ block.
 *
 * To use the space, the caller may need to compact existing entries in
 * the directory. The total number of bytes in all of the entries involved
 * in the compaction is stored in *slotsize. In other words, all of
 * the entries that must be compacted are exactly contained in the
 * region beginning at the returned offset and spanning *slotsize bytes.
 *
 * Returns -1 if no space was found, indicating that the directory
 * must be extended.
 */
doff_t
ufsdirhash_findfree(struct inode *ip, int slotneeded, int *slotsize)
{
	struct direct *dp;
	struct dirhash *dh;
	struct buf *bp;
	doff_t pos, slotstart;
	int dirblock, error, freebytes, i;

	if ((dh = ip->i_dirhash) == NULL)
		return (-1);
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return (-1);
	}

	/* Find a directory block with the desired free space. */
	dirblock = -1;
	for (i = howmany(slotneeded, DIRALIGN); i <= DH_NFSTATS; i++)
		if ((dirblock = dh->dh_firstfree[i]) != -1)
			break;
	if (dirblock == -1) {
		DIRHASH_UNLOCK(dh);
		return (-1);
	}

	DIRHASH_ASSERT(dirblock < dh->dh_nblk &&
	    dh->dh_blkfree[dirblock] >= howmany(slotneeded, DIRALIGN),
	    ("ufsdirhash_findfree: bad stats"));
	DIRHASH_UNLOCK(dh);
	pos = dirblock * DIRBLKSIZ;
	error = UFS_BUFATOFF(ip, (off_t)pos, (char **)&dp, &bp);
	if (error)
		return (-1);

	/* Find the first entry with free space. */
	for (i = 0; i < DIRBLKSIZ; ) {
		if (dp->d_reclen == 0) {
			brelse(bp);
			return (-1);
		}
		if (dp->d_ino == 0 || dp->d_reclen > DIRSIZ(0, dp))
			break;
		i += dp->d_reclen;
		dp = (struct direct *)((char *)dp + dp->d_reclen);
	}
	if (i > DIRBLKSIZ) {
		brelse(bp);
		return (-1);
	}
	slotstart = pos + i;

	/* Find the range of entries needed to get enough space */
	freebytes = 0;
	while (i < DIRBLKSIZ && freebytes < slotneeded) {
		freebytes += dp->d_reclen;
		if (dp->d_ino != 0)
			freebytes -= DIRSIZ(0, dp);
		if (dp->d_reclen == 0) {
			brelse(bp);
			return (-1);
		}
		i += dp->d_reclen;
		dp = (struct direct *)((char *)dp + dp->d_reclen);
	}
	if (i > DIRBLKSIZ) {
		brelse(bp);
		return (-1);
	}
	if (freebytes < slotneeded)
		panic("ufsdirhash_findfree: free mismatch");
	brelse(bp);
	*slotsize = pos + i - slotstart;
	return (slotstart);
}

/*
 * Return the start of the unused space at the end of a directory, or
 * -1 if there are no trailing unused blocks.
 */
doff_t
ufsdirhash_enduseful(struct inode *ip)
{

	struct dirhash *dh;
	int i;

	if ((dh = ip->i_dirhash) == NULL)
		return (-1);
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return (-1);
	}

	if (dh->dh_blkfree[dh->dh_dirblks - 1] != DIRBLKSIZ / DIRALIGN) {
		DIRHASH_UNLOCK(dh);
		return (-1);
	}

	for (i = dh->dh_dirblks - 1; i >= 0; i--)
		if (dh->dh_blkfree[i] != DIRBLKSIZ / DIRALIGN)
			break;
	DIRHASH_UNLOCK(dh);
	return ((doff_t)(i + 1) * DIRBLKSIZ);
}

/*
 * Insert information into the hash about a new directory entry. dirp
 * points to a struct direct containing the entry, and offset specifies
 * the offset of this entry.
 */
void
ufsdirhash_add(struct inode *ip, struct direct *dirp, doff_t offset)
{
	struct dirhash *dh;
	int slot;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	DIRHASH_ASSERT(offset < dh->dh_dirblks * DIRBLKSIZ,
	    ("ufsdirhash_add: bad offset"));
	/*
	 * Normal hash usage is < 66%. If the usage gets too high then
	 * remove the hash entirely and let it be rebuilt later.
	 */
	if (dh->dh_hused >= (dh->dh_hlen * 3) / 4) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	/* Find a free hash slot (empty or deleted), and add the entry. */
	slot = ufsdirhash_hash(dh, dirp->d_name, dirp->d_namlen);
	while (DH_ENTRY(dh, slot) >= 0)
		slot = WRAPINCR(slot, dh->dh_hlen);
	if (DH_ENTRY(dh, slot) == DIRHASH_EMPTY)
		dh->dh_hused++;
	DH_ENTRY(dh, slot) = offset;

	/* Update the per-block summary info. */
	ufsdirhash_adjfree(dh, offset, -DIRSIZ(0, dirp));
	DIRHASH_UNLOCK(dh);
}

/*
 * Remove the specified directory entry from the hash. The entry to remove
 * is defined by the name in `dirp', which must exist at the specified
 * `offset' within the directory.
 */
void
ufsdirhash_remove(struct inode *ip, struct direct *dirp, doff_t offset)
{
	struct dirhash *dh;
	int slot;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	DIRHASH_ASSERT(offset < dh->dh_dirblks * DIRBLKSIZ,
	    ("ufsdirhash_remove: bad offset"));
	/* Find the entry */
	slot = ufsdirhash_findslot(dh, dirp->d_name, dirp->d_namlen, offset);

	/* Remove the hash entry. */
	ufsdirhash_delslot(dh, slot);

	/* Update the per-block summary info. */
	ufsdirhash_adjfree(dh, offset, DIRSIZ(0, dirp));
	DIRHASH_UNLOCK(dh);
}

/*
 * Change the offset associated with a directory entry in the hash. Used
 * when compacting directory blocks.
 */
void
ufsdirhash_move(struct inode *ip, struct direct *dirp, doff_t oldoff,
    doff_t newoff)
{
	struct dirhash *dh;
	int slot;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	DIRHASH_ASSERT(oldoff < dh->dh_dirblks * DIRBLKSIZ &&
	    newoff < dh->dh_dirblks * DIRBLKSIZ,
	    ("ufsdirhash_move: bad offset"));
	/* Find the entry, and update the offset. */
	slot = ufsdirhash_findslot(dh, dirp->d_name, dirp->d_namlen, oldoff);
	DH_ENTRY(dh, slot) = newoff;
	DIRHASH_UNLOCK(dh);
}

/*
 * Inform dirhash that the directory has grown by one block that
 * begins at offset (i.e. the new length is offset + DIRBLKSIZ).
 */
void
ufsdirhash_newblk(struct inode *ip, doff_t offset)
{
	struct dirhash *dh;
	int block;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	DIRHASH_ASSERT(offset == dh->dh_dirblks * DIRBLKSIZ,
	    ("ufsdirhash_newblk: bad offset"));
	block = offset / DIRBLKSIZ;
	if (block >= dh->dh_nblk) {
		/* Out of space; must rebuild. */
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}
	dh->dh_dirblks = block + 1;

	/* Account for the new free block. */
	dh->dh_blkfree[block] = DIRBLKSIZ / DIRALIGN;
	if (dh->dh_firstfree[DH_NFSTATS] == -1)
		dh->dh_firstfree[DH_NFSTATS] = block;
	DIRHASH_UNLOCK(dh);
}

/*
 * Inform dirhash that the directory is being truncated.
 */
void
ufsdirhash_dirtrunc(struct inode *ip, doff_t offset)
{
	struct dirhash *dh;
	int block, i;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	DIRHASH_ASSERT(offset <= dh->dh_dirblks * DIRBLKSIZ,
	    ("ufsdirhash_dirtrunc: bad offset"));
	block = howmany(offset, DIRBLKSIZ);
	/*
	 * If the directory shrinks to less than 1/8 of dh_nblk blocks
	 * (about 20% of its original size due to the 50% extra added in
	 * ufsdirhash_build) then free it, and let the caller rebuild
	 * if necessary.
	 */
	if (block < dh->dh_nblk / 8 && dh->dh_narrays > 1) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	/*
	 * Remove any `first free' information pertaining to the
	 * truncated blocks. All blocks we're removing should be
	 * completely unused.
	 */
	if (dh->dh_firstfree[DH_NFSTATS] >= block)
		dh->dh_firstfree[DH_NFSTATS] = -1;
	for (i = block; i < dh->dh_dirblks; i++)
		if (dh->dh_blkfree[i] != DIRBLKSIZ / DIRALIGN)
			panic("ufsdirhash_dirtrunc: blocks in use");
	for (i = 0; i < DH_NFSTATS; i++)
		if (dh->dh_firstfree[i] >= block)
			panic("ufsdirhash_dirtrunc: first free corrupt");
	dh->dh_dirblks = block;
	DIRHASH_UNLOCK(dh);
}

/*
 * Debugging function to check that the dirhash information about
 * a directory block matches its actual contents. Panics if a mismatch
 * is detected.
 *
 * On entry, `buf' should point to the start of an in-core
 * DIRBLKSIZ-sized directory block, and `offset' should contain the
 * offset from the start of the directory of that block.
 */
void
ufsdirhash_checkblock(struct inode *ip, char *buf, doff_t offset)
{
	struct dirhash *dh;
	struct direct *dp;
	int block, ffslot, i, nfree;

	if (!ufs_dirhashcheck)
		return;
	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	block = offset / DIRBLKSIZ;
	if ((offset & (DIRBLKSIZ - 1)) != 0 || block >= dh->dh_dirblks)
		panic("ufsdirhash_checkblock: bad offset");

	nfree = 0;
	for (i = 0; i < DIRBLKSIZ; i += dp->d_reclen) {
		dp = (struct direct *)(buf + i);
		if (dp->d_reclen == 0 || i + dp->d_reclen > DIRBLKSIZ)
			panic("ufsdirhash_checkblock: bad dir");

		if (dp->d_ino == 0) {
#if 0
			/*
			 * XXX entries with d_ino == 0 should only occur
			 * at the start of a DIRBLKSIZ block. However the
			 * ufs code is tolerant of such entries at other
			 * offsets, and fsck does not fix them.
			 */
			if (i != 0)
				panic("ufsdirhash_checkblock: bad dir inode");
#endif
			nfree += dp->d_reclen;
			continue;
		}

		/* Check that the entry	exists (will panic if it doesn't). */
		ufsdirhash_findslot(dh, dp->d_name, dp->d_namlen, offset + i);

		nfree += dp->d_reclen - DIRSIZ(0, dp);
	}
	if (i != DIRBLKSIZ)
		panic("ufsdirhash_checkblock: bad dir end");

	if (dh->dh_blkfree[block] * DIRALIGN != nfree)
		panic("ufsdirhash_checkblock: bad free count");

	ffslot = BLKFREE2IDX(nfree / DIRALIGN);
	for (i = 0; i <= DH_NFSTATS; i++)
		if (dh->dh_firstfree[i] == block && i != ffslot)
			panic("ufsdirhash_checkblock: bad first-free");
	if (dh->dh_firstfree[ffslot] == -1)
		panic("ufsdirhash_checkblock: missing first-free entry");
	DIRHASH_UNLOCK(dh);
}

/*
 * Hash the specified filename into a dirhash slot.
 */
int
ufsdirhash_hash(struct dirhash *dh, char *name, int namelen)
{
	u_int32_t hash;

	/*
	 * We hash the name and then some other bit of data that is
	 * invariant over the dirhash's lifetime. Otherwise names
	 * differing only in the last byte are placed close to one
	 * another in the table, which is bad for linear probing.
	 */
	hash = hash32_buf(name, namelen, HASHINIT);
	hash = hash32_buf(&dh, sizeof(dh), hash);
	return (hash % dh->dh_hlen);
}

/*
 * Adjust the number of free bytes in the block containing `offset'
 * by the value specified by `diff'.
 *
 * The caller must ensure we have exclusive access to `dh'; normally
 * that means that dh_mtx should be held, but this is also called
 * from ufsdirhash_build() where exclusive access can be assumed.
 */
void
ufsdirhash_adjfree(struct dirhash *dh, doff_t offset, int diff)
{
	int block, i, nfidx, ofidx;

	/* Update the per-block summary info. */
	block = offset / DIRBLKSIZ;
	DIRHASH_ASSERT(block < dh->dh_nblk && block < dh->dh_dirblks,
	     ("dirhash bad offset"));
	ofidx = BLKFREE2IDX(dh->dh_blkfree[block]);
	dh->dh_blkfree[block] = (int)dh->dh_blkfree[block] + (diff / DIRALIGN);
	nfidx = BLKFREE2IDX(dh->dh_blkfree[block]);

	/* Update the `first free' list if necessary. */
	if (ofidx != nfidx) {
		/* If removing, scan forward for the next block. */
		if (dh->dh_firstfree[ofidx] == block) {
			for (i = block + 1; i < dh->dh_dirblks; i++)
				if (BLKFREE2IDX(dh->dh_blkfree[i]) == ofidx)
					break;
			dh->dh_firstfree[ofidx] = (i < dh->dh_dirblks) ? i : -1;
		}

		/* Make this the new `first free' if necessary */
		if (dh->dh_firstfree[nfidx] > block ||
		    dh->dh_firstfree[nfidx] == -1)
			dh->dh_firstfree[nfidx] = block;
	}
}

/*
 * Find the specified name which should have the specified offset.
 * Returns a slot number, and panics on failure.
 *
 * `dh' must be locked on entry and remains so on return.
 */
int
ufsdirhash_findslot(struct dirhash *dh, char *name, int namelen, doff_t offset)
{
	int slot;

	mtx_assert(&dh->dh_mtx, MA_OWNED);

	/* Find the entry. */
	DIRHASH_ASSERT(dh->dh_hused < dh->dh_hlen, ("dirhash find full"));
	slot = ufsdirhash_hash(dh, name, namelen);
	while (DH_ENTRY(dh, slot) != offset &&
	    DH_ENTRY(dh, slot) != DIRHASH_EMPTY)
		slot = WRAPINCR(slot, dh->dh_hlen);
	if (DH_ENTRY(dh, slot) != offset)
		panic("ufsdirhash_findslot: '%.*s' not found", namelen, name);

	return (slot);
}

/*
 * Remove the entry corresponding to the specified slot from the hash array.
 *
 * `dh' must be locked on entry and remains so on return.
 */
void
ufsdirhash_delslot(struct dirhash *dh, int slot)
{
	int i;

	mtx_assert(&dh->dh_mtx, MA_OWNED);

	/* Mark the entry as deleted. */
	DH_ENTRY(dh, slot) = DIRHASH_DEL;

	/* If this is the end of a chain of DIRHASH_DEL slots, remove them. */
	for (i = slot; DH_ENTRY(dh, i) == DIRHASH_DEL; )
		i = WRAPINCR(i, dh->dh_hlen);
	if (DH_ENTRY(dh, i) == DIRHASH_EMPTY) {
		i = WRAPDECR(i, dh->dh_hlen);
		while (DH_ENTRY(dh, i) == DIRHASH_DEL) {
			DH_ENTRY(dh, i) = DIRHASH_EMPTY;
			dh->dh_hused--;
			i = WRAPDECR(i, dh->dh_hlen);
		}
		DIRHASH_ASSERT(dh->dh_hused >= 0, ("ufsdirhash_delslot neg hlen"));
	}
}

/*
 * Given a directory entry and its offset, find the offset of the
 * previous entry in the same DIRBLKSIZ-sized block. Returns an
 * offset, or -1 if there is no previous entry in the block or some
 * other problem occurred.
 */
doff_t
ufsdirhash_getprev(struct direct *dirp, doff_t offset)
{
	struct direct *dp;
	char *blkbuf;
	doff_t blkoff, prevoff;
	int entrypos, i;

	blkoff = offset & ~(DIRBLKSIZ - 1);	/* offset of start of block */
	entrypos = offset & (DIRBLKSIZ - 1);	/* entry relative to block */
	blkbuf = (char *)dirp - entrypos;
	prevoff = blkoff;

	/* If `offset' is the start of a block, there is no previous entry. */
	if (entrypos == 0)
		return (-1);

	/* Scan from the start of the block until we get to the entry. */
	for (i = 0; i < entrypos; i += dp->d_reclen) {
		dp = (struct direct *)(blkbuf + i);
		if (dp->d_reclen == 0 || i + dp->d_reclen > entrypos)
			return (-1);	/* Corrupted directory. */
		prevoff = blkoff + i;
	}
	return (prevoff);
}

/*
 * Try to free up `wanted' bytes by stealing memory from existing
 * dirhashes. Returns zero with list locked if successful.
 */
int
ufsdirhash_recycle(int wanted)
{
	struct dirhash *dh;
	doff_t **hash;
	u_int8_t *blkfree;
	int i, mem, narrays;

	DIRHASHLIST_LOCK();
	while (wanted + ufs_dirhashmem > ufs_dirhashmaxmem) {
		/* Find a dirhash, and lock it. */
		if ((dh = TAILQ_FIRST(&ufsdirhash_list)) == NULL) {
			DIRHASHLIST_UNLOCK();
			return (-1);
		}
		DIRHASH_LOCK(dh);
		DIRHASH_ASSERT(dh->dh_hash != NULL, ("dirhash: NULL hash on list"));

		/* Decrement the score; only recycle if it becomes zero. */
		if (--dh->dh_score > 0) {
			DIRHASH_UNLOCK(dh);
			DIRHASHLIST_UNLOCK();
			return (-1);
		}

		/* Remove it from the list and detach its memory. */
		TAILQ_REMOVE(&ufsdirhash_list, dh, dh_list);
		dh->dh_onlist = 0;
		hash = dh->dh_hash;
		dh->dh_hash = NULL;
		blkfree = dh->dh_blkfree;
		dh->dh_blkfree = NULL;
		narrays = dh->dh_narrays;
		mem = narrays * sizeof(*dh->dh_hash) +
		    narrays * DH_NBLKOFF * sizeof(**dh->dh_hash) +
		    dh->dh_nblk * sizeof(*dh->dh_blkfree);

		/* Unlock everything, free the detached memory. */
		DIRHASH_UNLOCK(dh);
		DIRHASHLIST_UNLOCK();
		for (i = 0; i < narrays; i++)
			DIRHASH_BLKFREE(hash[i]);
		free(hash, M_DIRHASH);
		free(blkfree, M_DIRHASH);

		/* Account for the returned memory, and repeat if necessary. */
		DIRHASHLIST_LOCK();
		ufs_dirhashmem -= mem;
	}
	/* Success; return with list locked. */
	return (0);
}


void
ufsdirhash_init()
{
	pool_init(&ufsdirhash_pool, DH_NBLKOFF * sizeof(doff_t), 0, 0, 0,
	    "dirhash", &pool_allocator_nointr);
	rw_init(&ufsdirhash_mtx);
	TAILQ_INIT(&ufsdirhash_list);
#if defined (__sparc__)
	if (!CPU_ISSUN4OR4C)
#elif defined (__vax__)
	if (0)
#endif
		ufs_dirhashmaxmem = 2 * 1024 * 1024;
	ufs_mindirhashsize = 5 * DIRBLKSIZ;
}

void
ufsdirhash_uninit()
{
	DIRHASH_ASSERT(TAILQ_EMPTY(&ufsdirhash_list), ("ufsdirhash_uninit"));
	pool_destroy(&ufsdirhash_pool);
}
@


1.1
log
@Initial revision
@
text
@d1 1
d31 4
d62 2
a63 2
int ufs_mindirhashsize = DIRBLKSIZ * 5;
int ufs_dirhashmaxmem = 2 * 1024 * 1024;
d65 1
a65 1
int ufs_dirhashcheck = 0;
d76 12
a90 5
#ifdef __FreeBSD__
static uma_zone_t	ufsdirhash_zone;
#define		DIRHASH_ALLOC()	uma_zalloc(ufsdirhash_zone, M_WAITOK)
#define		DIRHASH_FREE(v)	uma_zfree(ufsdirhash_zone, v)

a91 8
static struct mtx	ufsdirhash_mtx;
#define		LOCK(l)		mtx_lock(l)
#define		UNLOCK(l)	mtx_unlock(l)
#else
struct pool		ufsdirhash_pool;
#define		DIRHASH_ALLOC()	pool_get(&ufsdirhash_pool, PR_WAITOK)
#define		DIRHASH_FREE(v)	pool_put(&ufsdirhash_pool, v)

a92 6
#define		LOCK(l)		rw_enter_write(l, curproc)
#define		UNLOCK(l)	rw_exit_write(l)
#define		mtx_assert(l, f)	/* nothing */

#define DIRHASH_ASSERT(e, m)	KASSERT((e))
#endif
d153 1
a153 1
	LOCK(&ufsdirhash_mtx);
d155 1
a155 1
		UNLOCK(&ufsdirhash_mtx);
d162 1
a162 1
		/* Enough was freed, and ufsdirhash_mtx has been locked. */
d165 1
a165 1
	UNLOCK(&ufsdirhash_mtx);
d173 1
a173 1
		LOCK(&ufsdirhash_mtx);
d175 1
a175 1
		UNLOCK(&ufsdirhash_mtx);
d187 1
a187 1
		if ((dh->dh_hash[i] = DIRHASH_ALLOC()) == NULL)
a193 3
#ifdef __FreeBSD__
	mtx_init(&dh->dh_mtx, "dirhash", NULL, MTX_DEF);
#else
a194 1
#endif
d242 1
a242 1
	LOCK(&ufsdirhash_mtx);
d245 1
a245 1
	UNLOCK(&ufsdirhash_mtx);
d252 1
a252 1
				DIRHASH_FREE(dh->dh_hash[i]);
d259 1
a259 1
	LOCK(&ufsdirhash_mtx);
d261 1
a261 1
	UNLOCK(&ufsdirhash_mtx);
d276 2
a277 2
	LOCK(&ufsdirhash_mtx);
	LOCK(&dh->dh_mtx);
d280 2
a281 2
	UNLOCK(&dh->dh_mtx);
	UNLOCK(&ufsdirhash_mtx);
d288 1
a288 1
			DIRHASH_FREE(dh->dh_hash[i]);
a294 3
#ifdef __FreeBSD__
	mtx_destroy(&dh->dh_mtx);
#endif
d298 1
a298 1
	LOCK(&ufsdirhash_mtx);
d300 1
a300 1
	UNLOCK(&ufsdirhash_mtx);
d336 2
a337 2
		LOCK(&ufsdirhash_mtx);
		LOCK(&dh->dh_mtx);
d352 1
a352 1
		UNLOCK(&ufsdirhash_mtx);
d355 1
a355 1
		LOCK(&dh->dh_mtx);
d358 1
a358 1
		UNLOCK(&dh->dh_mtx);
d400 1
a400 1
		UNLOCK(&dh->dh_mtx);
d444 1
a444 1
		LOCK(&dh->dh_mtx);
d446 1
a446 1
			UNLOCK(&dh->dh_mtx);
d461 1
a461 1
	UNLOCK(&dh->dh_mtx);
d494 1
a494 1
	LOCK(&dh->dh_mtx);
d496 1
a496 1
		UNLOCK(&dh->dh_mtx);
d507 1
a507 1
		UNLOCK(&dh->dh_mtx);
d514 1
a514 1
	UNLOCK(&dh->dh_mtx);
d574 1
a574 1
	LOCK(&dh->dh_mtx);
d576 1
a576 1
		UNLOCK(&dh->dh_mtx);
d582 1
a582 1
		UNLOCK(&dh->dh_mtx);
d589 1
a589 1
	UNLOCK(&dh->dh_mtx);
d606 1
a606 1
	LOCK(&dh->dh_mtx);
d608 1
a608 1
		UNLOCK(&dh->dh_mtx);
d620 1
a620 1
		UNLOCK(&dh->dh_mtx);
d635 1
a635 1
	UNLOCK(&dh->dh_mtx);
d651 1
a651 1
	LOCK(&dh->dh_mtx);
d653 1
a653 1
		UNLOCK(&dh->dh_mtx);
d668 1
a668 1
	UNLOCK(&dh->dh_mtx);
d684 1
a684 1
	LOCK(&dh->dh_mtx);
d686 1
a686 1
		UNLOCK(&dh->dh_mtx);
d697 1
a697 1
	UNLOCK(&dh->dh_mtx);
d712 1
a712 1
	LOCK(&dh->dh_mtx);
d714 1
a714 1
		UNLOCK(&dh->dh_mtx);
d724 1
a724 1
		UNLOCK(&dh->dh_mtx);
d734 1
a734 1
	UNLOCK(&dh->dh_mtx);
d748 1
a748 1
	LOCK(&dh->dh_mtx);
d750 1
a750 1
		UNLOCK(&dh->dh_mtx);
d765 1
a765 1
		UNLOCK(&dh->dh_mtx);
d784 1
a784 1
	UNLOCK(&dh->dh_mtx);
d807 1
a807 1
	LOCK(&dh->dh_mtx);
d809 1
a809 1
		UNLOCK(&dh->dh_mtx);
d856 1
a856 1
	UNLOCK(&dh->dh_mtx);
d1005 1
a1005 1
 * dirhashes. Returns zero with ufsdirhash_mtx locked if successful.
d1015 1
a1015 1
	LOCK(&ufsdirhash_mtx);
d1019 1
a1019 1
			UNLOCK(&ufsdirhash_mtx);
d1022 1
a1022 1
		LOCK(&dh->dh_mtx);
d1027 2
a1028 2
			UNLOCK(&dh->dh_mtx);
			UNLOCK(&ufsdirhash_mtx);
d1045 2
a1046 2
		UNLOCK(&dh->dh_mtx);
		UNLOCK(&ufsdirhash_mtx);
d1048 1
a1048 1
			DIRHASH_FREE(hash[i]);
d1053 1
a1053 1
		LOCK(&ufsdirhash_mtx);
d1056 1
a1056 1
	/* Success; return with ufsdirhash_mtx locked. */
a1063 5
#ifdef __FreeBSD__
	ufsdirhash_zone = uma_zcreate("DIRHASH", DH_NBLKOFF * sizeof(doff_t),
	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, 0);
	mtx_init(&ufsdirhash_mtx, "dirhash list", NULL, MTX_DEF);
#else
d1067 5
d1073 2
a1074 1
	TAILQ_INIT(&ufsdirhash_list);
a1080 4
#ifdef __FreeBSD__
	uma_zdestroy(ufsdirhash_zone);
	mtx_destroy(&ufsdirhash_mtx);
#else
a1081 1
#endif
@


1.1.1.1
log
@Import OpenBSD again, for various reasons.
@
text
@@


1.1.1.2
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d57 2
a58 2
int ufs_mindirhashsize;
int ufs_dirhashmaxmem;
d60 1
a60 1
int ufs_dirhashcheck;
d74 10
d89 2
a90 2
#define		DIRHASH_LOCK(l)		rw_enter_write(l, curproc)
#define		DIRHASH_UNLOCK(l)	rw_exit_write(l)
d94 1
d155 1
a155 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d157 1
a157 1
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d167 1
a167 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d175 1
a175 1
		DIRHASH_LOCK(&ufsdirhash_mtx);
d177 1
a177 1
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d196 3
d200 1
d248 1
a248 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d251 1
a251 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d265 1
a265 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d267 1
a267 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d282 2
a283 2
	DIRHASH_LOCK(&ufsdirhash_mtx);
	DIRHASH_LOCK(&dh->dh_mtx);
d286 2
a287 2
	DIRHASH_UNLOCK(&dh->dh_mtx);
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d301 3
d307 1
a307 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d309 1
a309 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d345 2
a346 2
		DIRHASH_LOCK(&ufsdirhash_mtx);
		DIRHASH_LOCK(&dh->dh_mtx);
d361 1
a361 1
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d364 1
a364 1
		DIRHASH_LOCK(&dh->dh_mtx);
d367 1
a367 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d409 1
a409 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d453 1
a453 1
		DIRHASH_LOCK(&dh->dh_mtx);
d455 1
a455 1
			DIRHASH_UNLOCK(&dh->dh_mtx);
d470 1
a470 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d503 1
a503 1
	DIRHASH_LOCK(&dh->dh_mtx);
d505 1
a505 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d516 1
a516 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d523 1
a523 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d583 1
a583 1
	DIRHASH_LOCK(&dh->dh_mtx);
d585 1
a585 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d591 1
a591 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d598 1
a598 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d615 1
a615 1
	DIRHASH_LOCK(&dh->dh_mtx);
d617 1
a617 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d629 1
a629 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d644 1
a644 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d660 1
a660 1
	DIRHASH_LOCK(&dh->dh_mtx);
d662 1
a662 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d677 1
a677 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d693 1
a693 1
	DIRHASH_LOCK(&dh->dh_mtx);
d695 1
a695 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d706 1
a706 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d721 1
a721 1
	DIRHASH_LOCK(&dh->dh_mtx);
d723 1
a723 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d733 1
a733 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d743 1
a743 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d757 1
a757 1
	DIRHASH_LOCK(&dh->dh_mtx);
d759 1
a759 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d774 1
a774 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d793 1
a793 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d816 1
a816 1
	DIRHASH_LOCK(&dh->dh_mtx);
d818 1
a818 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d865 1
a865 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d1024 1
a1024 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d1028 1
a1028 1
			DIRHASH_UNLOCK(&ufsdirhash_mtx);
d1031 1
a1031 1
		DIRHASH_LOCK(&dh->dh_mtx);
d1036 2
a1037 2
			DIRHASH_UNLOCK(&dh->dh_mtx);
			DIRHASH_UNLOCK(&ufsdirhash_mtx);
d1054 2
a1055 2
		DIRHASH_UNLOCK(&dh->dh_mtx);
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d1062 1
a1062 1
		DIRHASH_LOCK(&ufsdirhash_mtx);
d1073 5
d1081 1
a1082 7
#if defined (__sparc__)
	if (!CPU_ISSUN4OR4C)
#elif defined (__vax__)
	if (0)
#endif
		ufs_dirhashmaxmem = 2 * 1024 * 1024;
	ufs_mindirhashsize = 5 * DIRBLKSIZ;
d1089 4
d1094 1
@


1.1.1.3
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@a0 1
/* $OpenBSD: ufs_dirhash.c,v 1.7 2004/03/16 06:28:27 tedu Exp $	*/
a29 4
#if 0
__FBSDID("$FreeBSD: src/sys/ufs/ufs/ufs_dirhash.c,v 1.18 2004/02/15 21:39:35 dwmalone Exp $");
#endif

d71 3
d75 2
d78 4
a81 6
#define	DIRHASHLIST_LOCK()	rw_enter_write(&ufsdirhash_mtx, curproc)
#define	DIRHASHLIST_UNLOCK()	rw_exit_write(&ufsdirhash_mtx)
#define	DIRHASH_LOCK(dh)	rw_enter_write(&(dh)->dh_mtx, curproc)
#define	DIRHASH_UNLOCK(dh)	rw_exit_write(&(dh)->dh_mtx)
#define	DIRHASH_BLKALLOC_WAITOK()	pool_get(&ufsdirhash_pool, PR_WAITOK)
#define	DIRHASH_BLKFREE(v)		pool_put(&ufsdirhash_pool, v)
a82 1
#define	mtx_assert(l, f)	/* nothing */
a84 6
/* Dirhash list; recently-used entries are near the tail. */
TAILQ_HEAD(, dirhash) ufsdirhash_list;

/* Protects: ufsdirhash_list, `dh_list' field, ufs_dirhashmem. */
struct rwlock		ufsdirhash_mtx;

d144 1
a144 1
	DIRHASHLIST_LOCK();
d146 1
a146 1
		DIRHASHLIST_UNLOCK();
d153 1
a153 1
		/* Enough was freed, and list has been locked. */
d156 1
a156 1
	DIRHASHLIST_UNLOCK();
d164 1
a164 1
		DIRHASHLIST_LOCK();
d166 1
a166 1
		DIRHASHLIST_UNLOCK();
d178 1
a178 1
		if ((dh->dh_hash[i] = DIRHASH_BLKALLOC_WAITOK()) == NULL)
d233 1
a233 1
	DIRHASHLIST_LOCK();
d236 1
a236 1
	DIRHASHLIST_UNLOCK();
d243 1
a243 1
				DIRHASH_BLKFREE(dh->dh_hash[i]);
d250 1
a250 1
	DIRHASHLIST_LOCK();
d252 1
a252 1
	DIRHASHLIST_UNLOCK();
d267 2
a268 2
	DIRHASHLIST_LOCK();
	DIRHASH_LOCK(dh);
d271 2
a272 2
	DIRHASH_UNLOCK(dh);
	DIRHASHLIST_UNLOCK();
d279 1
a279 1
			DIRHASH_BLKFREE(dh->dh_hash[i]);
d289 1
a289 1
	DIRHASHLIST_LOCK();
d291 1
a291 1
	DIRHASHLIST_UNLOCK();
d327 2
a328 2
		DIRHASHLIST_LOCK();
		DIRHASH_LOCK(dh);
d343 1
a343 1
		DIRHASHLIST_UNLOCK();
d346 1
a346 1
		DIRHASH_LOCK(dh);
d349 1
a349 1
		DIRHASH_UNLOCK(dh);
d391 1
a391 1
		DIRHASH_UNLOCK(dh);
d435 1
a435 1
		DIRHASH_LOCK(dh);
d437 1
a437 1
			DIRHASH_UNLOCK(dh);
d452 1
a452 1
	DIRHASH_UNLOCK(dh);
d485 1
a485 1
	DIRHASH_LOCK(dh);
d487 1
a487 1
		DIRHASH_UNLOCK(dh);
d498 1
a498 1
		DIRHASH_UNLOCK(dh);
d505 1
a505 1
	DIRHASH_UNLOCK(dh);
d565 1
a565 1
	DIRHASH_LOCK(dh);
d567 1
a567 1
		DIRHASH_UNLOCK(dh);
d573 1
a573 1
		DIRHASH_UNLOCK(dh);
d580 1
a580 1
	DIRHASH_UNLOCK(dh);
d597 1
a597 1
	DIRHASH_LOCK(dh);
d599 1
a599 1
		DIRHASH_UNLOCK(dh);
d611 1
a611 1
		DIRHASH_UNLOCK(dh);
d626 1
a626 1
	DIRHASH_UNLOCK(dh);
d642 1
a642 1
	DIRHASH_LOCK(dh);
d644 1
a644 1
		DIRHASH_UNLOCK(dh);
d659 1
a659 1
	DIRHASH_UNLOCK(dh);
d675 1
a675 1
	DIRHASH_LOCK(dh);
d677 1
a677 1
		DIRHASH_UNLOCK(dh);
d688 1
a688 1
	DIRHASH_UNLOCK(dh);
d703 1
a703 1
	DIRHASH_LOCK(dh);
d705 1
a705 1
		DIRHASH_UNLOCK(dh);
d715 1
a715 1
		DIRHASH_UNLOCK(dh);
d725 1
a725 1
	DIRHASH_UNLOCK(dh);
d739 1
a739 1
	DIRHASH_LOCK(dh);
d741 1
a741 1
		DIRHASH_UNLOCK(dh);
d756 1
a756 1
		DIRHASH_UNLOCK(dh);
d775 1
a775 1
	DIRHASH_UNLOCK(dh);
d798 1
a798 1
	DIRHASH_LOCK(dh);
d800 1
a800 1
		DIRHASH_UNLOCK(dh);
d847 1
a847 1
	DIRHASH_UNLOCK(dh);
d996 1
a996 1
 * dirhashes. Returns zero with list locked if successful.
d1006 1
a1006 1
	DIRHASHLIST_LOCK();
d1010 1
a1010 1
			DIRHASHLIST_UNLOCK();
d1013 1
a1013 1
		DIRHASH_LOCK(dh);
d1018 2
a1019 2
			DIRHASH_UNLOCK(dh);
			DIRHASHLIST_UNLOCK();
d1036 2
a1037 2
		DIRHASH_UNLOCK(dh);
		DIRHASHLIST_UNLOCK();
d1039 1
a1039 1
			DIRHASH_BLKFREE(hash[i]);
d1044 1
a1044 1
		DIRHASHLIST_LOCK();
d1047 1
a1047 1
	/* Success; return with list locked. */
@


1.1.1.4
log
@OpenBSD vnode locking etc. fixes
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.8 2004/07/21 12:10:20 art Exp $	*/
d78 1
a78 1
#define	DIRHASHLIST_LOCK()	rw_enter_write(&ufsdirhash_mtx)
d80 1
a80 1
#define	DIRHASH_LOCK(dh)	rw_enter_write(&(dh)->dh_mtx)
@


