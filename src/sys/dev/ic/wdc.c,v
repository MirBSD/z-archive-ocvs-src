head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.7
	tg-mergefixes-1-branch:1.1.1.7.0.8
	tg-mergefixes-1-base:1.1.1.7
	MIROS_X:1.1.1.7.0.6
	MIROS_X_BASE:1.1.1.7
	tg-mergetmp-3:1.1.1.7
	MIRBSD_XP_MIRPPC:1.1.1.7.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.7
	MIRBSD_XP_SPARC:1.1.1.7.0.2
	MIRBSD_7quater:1.1.1.4
	cvs-200405160640:1.1.1.7
	cvs-200401271800:1.1.1.6
	cvs-200401261630:1.1.1.6
	cvs-200401021645:1.1.1.5
	MIRBSD_7_ALPHA:1.1.1.4.0.6
	MIRBSD_7:1.1.1.4.0.4
	cvs-200312222040:1.1.1.5
	MIRBSD_7ter:1.1.1.4
	MIRBSD_7_DEV:1.1.1.4.0.2
	cvs-200310020700:1.1.1.4
	cvs-200309271030:1.1.1.3
	cvs-200309261655:1.1.1.3
	cvs-200309251530:1.1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.3
	ctm-3449:1.1.1.3
	ctm-3437:1.1.1.3
	cvs-200307191805:1.1.1.3
	ctm-3425:1.1.1.3
	cvs-200307091500:1.1.1.3
	cvs-200307072125:1.1.1.3
	ctm-3389:1.1.1.3
	cvs-200307021520:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	cvs-200305131745:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.17.51.03;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.51.03;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.06.29.17.32.31;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.07.06.15.45.47;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.10.02.07.41.04;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.22.21.02.06;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.01.26.18.48.17;	author tg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.16.08.57.53;	author tg;	state Stab;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*      $OpenBSD: wdc.c,v 1.60 2003/02/21 20:10:33 grange Exp $     */
/*	$NetBSD: wdc.c,v 1.68 1999/06/23 19:00:17 bouyer Exp $ */


/*
 * Copyright (c) 1998, 2001 Manuel Bouyer.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Manuel Bouyer.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum, by Onno van der Linden and by Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/proc.h>
#include <sys/pool.h>
#include <uvm/uvm_extern.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/ata/atavar.h>
#include <dev/ata/atareg.h>
#include <dev/ic/wdcreg.h>
#include <dev/ic/wdcvar.h>
#include <dev/ic/wdcevent.h>

#include "atapiscsi.h"

#define WDCDELAY  100 /* 100 microseconds */
#define WDCNDELAY_RST (WDC_RESET_WAIT * 1000 / WDCDELAY)
#if 0
/* If you enable this, it will report any delays more than WDCDELAY * N long. */
#define WDCNDELAY_DEBUG	50
#endif

struct pool wdc_xfer_pool;

static void  __wdcerror(struct channel_softc*, char *);
static int   __wdcwait_reset(struct channel_softc *, int);
void  __wdccommand_done(struct channel_softc *, struct wdc_xfer *);
void  __wdccommand_start(struct channel_softc *, struct wdc_xfer *);	
int   __wdccommand_intr(struct channel_softc *, struct wdc_xfer *, int);
int   wdprint(void *, const char *);
void  wdc_kill_pending(struct channel_softc *);

#define DEBUG_INTR   0x01
#define DEBUG_XFERS  0x02
#define DEBUG_STATUS 0x04
#define DEBUG_FUNCS  0x08
#define DEBUG_PROBE  0x10
#define DEBUG_STATUSX 0x20
#define DEBUG_SDRIVE 0x40
#define DEBUG_DETACH 0x80

#ifdef WDCDEBUG
int wdcdebug_mask = 0;
int wdc_nxfer = 0;
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_mask & (level)) != 0)	\
		printf args;			\
} while (0)
#else
#define WDCDEBUG_PRINT(args, level)
#endif

int at_poll = AT_POLL;

u_int8_t wdc_default_read_reg(struct channel_softc *, enum wdc_regs);
void wdc_default_write_reg(struct channel_softc *, enum wdc_regs, u_int8_t);
void wdc_default_read_raw_multi_2(struct channel_softc *, 
    void *, unsigned int);
void wdc_default_write_raw_multi_2(struct channel_softc *, 
    void *, unsigned int);
void wdc_default_read_raw_multi_4(struct channel_softc *, 
    void *, unsigned int);
void wdc_default_write_raw_multi_4(struct channel_softc *, 
    void *, unsigned int);

int wdc_floating_bus(struct channel_softc *, int);
int wdc_preata_drive(struct channel_softc *, int);
int wdc_ata_present(struct channel_softc *, int);

struct channel_softc_vtbl wdc_default_vtbl = {
	wdc_default_read_reg,
	wdc_default_write_reg,
	wdc_default_read_raw_multi_2,
	wdc_default_write_raw_multi_2,
	wdc_default_read_raw_multi_4,
	wdc_default_write_raw_multi_4
};

static char *wdc_log_buf = NULL;
static int wdc_tail = 0;
static int wdc_head = 0;
static int wdc_size = 16 * 1024;
static int chp_idx = 1;

void
wdc_log(struct channel_softc *chp, enum wdcevent_type type, 
    unsigned int size, char val[]) 
{
	unsigned int request_size;
	int idx;
	char *ptr;
	int nbytes;

	if (wdc_head < 0 || wdc_head > wdc_size ||
	    wdc_tail < 0 || wdc_tail > wdc_size) {
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head, wdc_tail);
		return;
	}

	if (size > wdc_size / 2) {
		printf ("wdc_log: type %d size %x\n", type, size);
	}

	if (wdc_log_buf == NULL) {
		wdc_log_buf = malloc(wdc_size, M_DEVBUF, M_NOWAIT);
		if (wdc_log_buf == NULL) 
			return;
	}
	if (chp->ch_log_idx == 0)
		chp->ch_log_idx = chp_idx++;

	request_size = size + 2;

	/* Check how many bytes are left */
	nbytes = wdc_head - wdc_tail;
	if (nbytes < 0) nbytes += wdc_size;

	if (nbytes + request_size >= wdc_size) {
		wdc_tail = (wdc_tail + request_size * 2) % wdc_size;
	}

	/* Avoid wrapping in the middle of a request */
	if (wdc_head + request_size >= wdc_size) {
		memset(&wdc_log_buf[wdc_head], 0, wdc_size - wdc_head);
		wdc_head = 0;
	}

	ptr = &wdc_log_buf[wdc_head];
	*ptr++ = type & 0xff;		
	*ptr++ = ((chp->ch_log_idx & 0x7) << 5) | (size & 0x1f);
				  
	idx = 0;
	while (size--) {
		*ptr++ = val[idx];
		idx++;
	}
	wdc_head += request_size;
}

char *wdc_get_log(unsigned int *, unsigned int *);

char *
wdc_get_log(unsigned int * size, unsigned int *left)
{
        int  bytes = (wdc_head - wdc_tail);
        char *retbuf;
        int  ot, c1, c2;

	if (left != NULL)
		*left = 0;

        if (bytes < 0) bytes += wdc_size;
	if (bytes > *size) { 
		if (left != NULL) {
			*left = bytes - *size;
		}
		bytes = *size;
	}

	if (wdc_log_buf == NULL) {
		*size = 0;
		*left = 0;
		return (NULL);
	}

	if (wdc_head < 0 || wdc_head > wdc_size ||
	    wdc_tail < 0 || wdc_tail > wdc_size) {
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head, wdc_tail);
		*size = 0;
		*left = 0;
		return (NULL);
	}

        retbuf = malloc(bytes, M_TEMP, M_NOWAIT);
	if (retbuf == NULL) {
		*size = 0;
		*left = bytes;
		return (NULL);
	}

	*size = bytes;

        ot = wdc_tail;
        wdc_tail += bytes;
        if (wdc_tail > wdc_size) {
                wdc_tail -= wdc_size;
                c2 = wdc_tail;
                c1 = bytes - wdc_tail;
        } else {
                c1 = bytes;
                c2 = 0;
        }

        memcpy(retbuf, &wdc_log_buf[ot], c1);
        memcpy(&retbuf[c1], &wdc_log_buf[0], c2);

        return (retbuf);
}


u_int8_t
wdc_default_read_reg(chp, reg)
	struct channel_softc *chp;
	enum wdc_regs reg;
{
#ifdef DIAGNOSTIC	
	if (reg & _WDC_WRONLY) {
		printf ("wdc_default_read_reg: reading from a write-only register %d\n", reg);
	}
#endif

	if (reg & _WDC_AUX) 
		return (bus_space_read_1(chp->ctl_iot, chp->ctl_ioh,
		    reg & _WDC_REGMASK));
	else
		return (bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
		    reg & _WDC_REGMASK));
}

void
wdc_default_write_reg(chp, reg, val)
	struct channel_softc *chp;
	enum wdc_regs reg;
	u_int8_t val;
{
#ifdef DIAGNOSTIC	
	if (reg & _WDC_RDONLY) {
		printf ("wdc_default_write_reg: writing to a read-only register %d\n", reg);
	}
#endif

	if (reg & _WDC_AUX) 
		bus_space_write_1(chp->ctl_iot, chp->ctl_ioh,
		    reg & _WDC_REGMASK, val);
	else
		bus_space_write_1(chp->cmd_iot, chp->cmd_ioh,
		    reg & _WDC_REGMASK, val);
}


void
wdc_default_read_raw_multi_2(chp, data, nbytes)
	struct channel_softc *chp;
	void *data;
	unsigned int nbytes;
{
	if (data == NULL) {
		int i;

		for (i = 0; i < nbytes; i += 2) {
			bus_space_read_2(chp->cmd_iot, chp->cmd_ioh, 0);
		}

		return;
	}

	bus_space_read_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0, 
	    data, nbytes);
	return;
}


void
wdc_default_write_raw_multi_2(chp, data, nbytes)
	struct channel_softc *chp;
	void *data;
	unsigned int nbytes;
{
	if (data == NULL) {
		int i;

		for (i = 0; i < nbytes; i += 2) {
			bus_space_write_2(chp->cmd_iot, chp->cmd_ioh, 0, 0);
		}

		return;
	}

	bus_space_write_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0, 
	    data, nbytes);
	return;
}


void
wdc_default_write_raw_multi_4(chp, data, nbytes)
	struct channel_softc *chp;
	void *data;
	unsigned int nbytes;
{
	if (data == NULL) {
		int i;

		for (i = 0; i < nbytes; i += 4) {
			bus_space_write_4(chp->cmd_iot, chp->cmd_ioh, 0, 0);
		}

		return;
	}

	bus_space_write_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0, 
	    data, nbytes);
	return;
}


void
wdc_default_read_raw_multi_4(chp, data, nbytes)
	struct channel_softc *chp;
	void *data;
	unsigned int nbytes;
{
	if (data == NULL) {
		int i;

		for (i = 0; i < nbytes; i += 4) {
			bus_space_read_4(chp->cmd_iot, chp->cmd_ioh, 0);
		}

		return;
	}

	bus_space_read_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0, 
	    data, nbytes);
	return;
}


int
wdprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct ata_atapi_attach *aa_link = aux;
	if (pnp)
		printf("drive at %s", pnp);
	printf(" channel %d drive %d", aa_link->aa_channel,
	    aa_link->aa_drv_data->drive);
	return (UNCONF);
}

int
atapi_print(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct ata_atapi_attach *aa_link = aux;
	if (pnp)
		printf("atapiscsi at %s", pnp);
	printf(" channel %d", aa_link->aa_channel);
	return (UNCONF);
}

void
wdc_disable_intr(chp)
        struct channel_softc *chp;
{
        CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);
}

void
wdc_enable_intr(chp)
        struct channel_softc *chp;
{
        CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
}

void
wdc_set_drive(struct channel_softc *chp, int drive) 
{
	CHP_WRITE_REG(chp, wdr_sdh, (drive << 4) | WDSD_IBM);
	WDC_LOG_SET_DRIVE(chp, drive);
}

int
wdc_floating_bus(chp, drive)
	struct channel_softc *chp;
	int drive;
	
{
	u_int8_t cumulative_status, status;
	int      iter;

	wdc_set_drive(chp, drive);
	delay(10);

	/* Stolen from Phoenix BIOS Drive Autotyping document */
	cumulative_status = 0;
	for (iter = 0; iter < 100; iter++) {
		CHP_WRITE_REG(chp, wdr_seccnt, 0x7f);
		delay (1);

		status = CHP_READ_REG(chp, wdr_status);

		/* The other bits are meaningless if BSY is set */
		if (status & WDCS_BSY)
			continue;

		cumulative_status |= status;

#define BAD_BIT_COMBO  (WDCS_DRDY | WDCS_DSC | WDCS_DRQ | WDCS_ERR)
		if ((cumulative_status & BAD_BIT_COMBO) == BAD_BIT_COMBO)
			return 1;
	}


	return 0;
}


int
wdc_preata_drive(chp, drive)
	struct channel_softc *chp;
	int drive;

{
	if (wdc_floating_bus(chp, drive)) {
		WDCDEBUG_PRINT(("%s:%d:%d: floating bus detected\n",
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}

	wdc_set_drive(chp, drive);
	delay(100);
	if (wdcwait(chp, WDCS_DRDY | WDCS_DRQ, WDCS_DRDY, 10000) != 0) {
		WDCDEBUG_PRINT(("%s:%d:%d: not ready\n",
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}
	
	CHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);
	WDC_LOG_ATA_CMDSHORT(chp, WDCC_RECAL);
	if (wdcwait(chp, WDCS_DRDY | WDCS_DRQ, WDCS_DRDY, 10000) != 0) {
		WDCDEBUG_PRINT(("%s:%d:%d: WDCC_RECAL failed\n",
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, drive), DEBUG_PROBE);
		return 0;
	}

	return 1;
}

int
wdc_ata_present(chp, drive)
	struct channel_softc *chp;
	int drive;
{
	int time_to_done;
	int retry_cnt = 0;

	wdc_set_drive(chp, drive);
	delay(10);

 retry:
	/* 
	   You're actually supposed to wait up to 10 seconds
	   for DRDY. However, as a practical matter, most
	   drives assert DRDY very quickly after dropping BSY.

	   The 10 seconds wait is sub-optimal because, according
	   to the ATA standard, the master should reply with 00
	   for any reads to a non-existant slave. 
	*/
	time_to_done = wdc_wait_for_status(chp,
	    (WDCS_DRDY | WDCS_DSC | WDCS_DRQ), 
	    (WDCS_DRDY | WDCS_DSC), 1000);
      	if (time_to_done == -1) {
		if (retry_cnt == 0 && chp->ch_status == 0x00) {
			/* At least one flash card needs to be kicked */
			wdccommandshort(chp, drive, WDCC_CHECK_PWR);
			retry_cnt++;
			goto retry;
		}
		WDCDEBUG_PRINT(("%s:%d:%d: DRDY test timed out with status"
		    " %02x\n", 
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe", 
		    chp->channel, drive, chp->ch_status),
		    DEBUG_PROBE);
		return 0;
	}

	if ((chp->ch_status & 0xfc) != (WDCS_DRDY | WDCS_DSC)) {
		WDCDEBUG_PRINT(("%s:%d:%d: status test for 0x50 failed with"
		    " %02x\n", 
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe", 
		    chp->channel, drive, chp->ch_status),
		    DEBUG_PROBE);

		return 0;
	}

	WDCDEBUG_PRINT(("%s:%d:%d: waiting for ready %d msec\n",
	    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
	    chp->channel, drive, time_to_done), DEBUG_PROBE);

	/*
	 * Test register writability
	 */
	CHP_WRITE_REG(chp, wdr_cyl_lo, 0xaa);
	CHP_WRITE_REG(chp, wdr_cyl_hi, 0x55);
	CHP_WRITE_REG(chp, wdr_seccnt, 0xff);
       	DELAY(10);

	if (CHP_READ_REG(chp, wdr_cyl_lo) != 0xaa &&
	    CHP_READ_REG(chp, wdr_cyl_hi) != 0x55) {
		WDCDEBUG_PRINT(("%s:%d:%d: register writability failed\n",
		  chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
	          chp->channel, drive), DEBUG_PROBE);
		return 0;
	}

	return 1;
}


/* 
   Test to see controller with at least one attached drive is there.
   Returns a bit for each possible drive found (0x01 for drive 0,
   0x02 for drive 1).
 */

int
wdcprobe(chp)
	struct channel_softc *chp;
{
	u_int8_t st0, st1, sc, sn, cl, ch;
	u_int8_t ret_value = 0x03;
	u_int8_t drive;

	if (chp->_vtbl == 0) {
		int s = splbio();
		chp->_vtbl = &wdc_default_vtbl;
		splx(s);
	}

#ifdef WDCDEBUG
	if ((chp->ch_flags & WDCF_VERBOSE_PROBE) ||
	    (chp->wdc &&
	    (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)))
		wdcdebug_mask |= DEBUG_PROBE;	
#endif

	if (chp->wdc == NULL ||
	    (chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {
		/* Sample the statuses of drive 0 and 1 into st0 and st1 */
		wdc_set_drive(chp, 0);
		delay(10);
		st0 = CHP_READ_REG(chp, wdr_status);
		WDC_LOG_STATUS(chp, st0);
		wdc_set_drive(chp, 1);
		delay(10);
		st1 = CHP_READ_REG(chp, wdr_status);
		WDC_LOG_STATUS(chp, st1);

		WDCDEBUG_PRINT(("%s:%d: before reset, st0=0x%x, st1=0x%x\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, st0, st1), DEBUG_PROBE);

		/* 
		   If the status is 0x7f or 0xff, then it's
		   an empty channel with pull-up resistors.
		*/
		if ((st0 & 0x7f) == 0x7f)
			ret_value &= ~0x01;
		if ((st1 & 0x7f) == 0x7f)
			ret_value &= ~0x02;
		if (ret_value == 0) 
			return 0;
	}

	/* reset the channel */
	CHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_4BIT); 
	delay(10);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
	delay(2000);

	ret_value = __wdcwait_reset(chp, ret_value);
	WDCDEBUG_PRINT(("%s:%d: after reset, ret_value=0x%d\n",
	    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe", chp->channel,
	    ret_value), DEBUG_PROBE);

	if (ret_value == 0)
		return 0;

	/*
	 * Use signatures to find potential ATAPI drives
	 */
	for (drive = 0; drive < 2; drive++) {
 		if ((ret_value & (0x01 << drive)) == 0)
			continue;
		wdc_set_drive(chp, drive);
		delay(10);
		/* Save registers contents */
		st0 = CHP_READ_REG(chp, wdr_status);
		sc = CHP_READ_REG(chp, wdr_seccnt);
		sn = CHP_READ_REG(chp, wdr_sector);
		cl = CHP_READ_REG(chp, wdr_cyl_lo);
		ch = CHP_READ_REG(chp, wdr_cyl_hi);
		WDC_LOG_REG(chp, wdr_cyl_lo, (ch << 8) | cl);

		WDCDEBUG_PRINT(("%s:%d:%d: after reset, st=0x%x, sc=0x%x"
		    " sn=0x%x cl=0x%x ch=0x%x\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
	    	    chp->channel, drive, st0, sc, sn, cl, ch), DEBUG_PROBE);
		/*
		 * This is a simplification of the test in the ATAPI
		 * spec since not all drives seem to set the other regs
		 * correctly.
		 */
		if (cl == 0x14 && ch == 0xeb)
			chp->ch_drive[drive].drive_flags |= DRIVE_ATAPI;
	}

	/* 
	 * Detect ATA drives by poking around the registers
	 */ 
	for (drive = 0; drive < 2; drive++) {
 		if ((ret_value & (0x01 << drive)) == 0)
			continue;
		if (chp->ch_drive[drive].drive_flags & DRIVE_ATAPI)
			continue;

		wdc_disable_intr(chp);
		/* ATA detect */
		if (wdc_ata_present(chp, drive)) {
			chp->ch_drive[drive].drive_flags |= DRIVE_ATA;
			if (chp->wdc == NULL ||
			    (chp->wdc->cap & WDC_CAPABILITY_PREATA) != 0)
				chp->ch_drive[drive].drive_flags |= DRIVE_OLD;
		} else {
			ret_value &= ~(1 << drive);
		}
		wdc_enable_intr(chp);
	}

#ifdef WDCDEBUG
	if ((chp->ch_flags & WDCF_VERBOSE_PROBE) ||
	    (chp->wdc &&
	    (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)))
		wdcdebug_mask &= ~DEBUG_PROBE;
#endif
	return (ret_value);	
}

/*
 * Call activate routine of underlying devices.
 */
int
wdcactivate(self, act)
	struct device *self;
	enum devact act;
{
	int error = 0;
	int s;

	s = splbio();
	config_activate_children(self, act);
	splx(s);

	return (error);
}

void
wdcattach(chp)
	struct channel_softc *chp;
{
	int channel_flags, ctrl_flags, i;
#ifndef __OpenBSD__
	int error;
#endif
	struct ata_atapi_attach aa_link;
	static int inited = 0;
#ifdef WDCDEBUG
	int    savedmask = wdcdebug_mask;
#endif

	if (!cold)
		at_poll = AT_WAIT;

	timeout_set(&chp->ch_timo, wdctimeout, chp);

#ifndef __OpenBSD__
	if ((error = wdc_addref(chp)) != 0) {
		printf("%s: unable to enable controller\n",
		    chp->wdc->sc_dev.dv_xname);
		return;
	}
#endif
	if (!chp->_vtbl)
		chp->_vtbl = &wdc_default_vtbl;

	if (wdcprobe(chp) == 0) {
		/* If no drives, abort attach here. */
#ifndef __OpenBSD__
		wdc_delref(chp);
#endif
		return;
	}

	/* ATAPI drives need settling time. Give them 250ms */
	if ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||
	    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {
		delay(250 * 1000);
	}

#ifdef WDCDEBUG
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		wdcdebug_mask |= DEBUG_PROBE;

	if ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||
	    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {
		wdcdebug_mask = DEBUG_PROBE;
	}
#endif

	/* initialise global data */
	if (inited == 0) {
		/* Initialize the wdc_xfer pool. */
		pool_init(&wdc_xfer_pool, sizeof(struct wdc_xfer), 0,
		    0, 0, "wdcspl", NULL);
		inited++;
	}
	TAILQ_INIT(&chp->ch_queue->sc_xfer);
	
	for (i = 0; i < 2; i++) {
		struct ata_drive_datas *drvp = &chp->ch_drive[i];

		drvp->chnl_softc = chp;
		drvp->drive = i;
		/* If controller can't do 16bit flag the drives as 32bit */
		if ((chp->wdc->cap &
		    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==
		    WDC_CAPABILITY_DATA32)
			drvp->drive_flags |= DRIVE_CAP32;

		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		if (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))
			chp->ch_flags |= WDCF_ONESLAVE;
		/*
		 * Issue an IDENTIFY command in order to distinct ATA from OLD.
		 * This also kill ATAPI ghost.
		 */
		if (ata_get_params(&chp->ch_drive[i], at_poll, &drvp->id) ==
		    CMD_OK) {
			/* If IDENTIFY succeded, this is not an OLD ctrl */
			drvp->drive_flags &= ~DRIVE_OLD;
		} else {
			drvp->drive_flags &=
			    ~(DRIVE_ATA | DRIVE_ATAPI);
			WDCDEBUG_PRINT(("%s:%d:%d: IDENTIFY failed\n",
			    chp->wdc->sc_dev.dv_xname,
			    chp->channel, i), DEBUG_PROBE);

			if ((drvp->drive_flags & DRIVE_OLD) && 
			    !wdc_preata_drive(chp, i))
				drvp->drive_flags &= ~DRIVE_OLD;
		}
	}
	ctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;
	channel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;

	WDCDEBUG_PRINT(("wdcattach: ch_drive_flags 0x%x 0x%x\n",
	    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),
	    DEBUG_PROBE);

	/* If no drives, abort here */
	if ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&
	    (chp->ch_drive[1].drive_flags & DRIVE) == 0)
		goto exit;

	for (i = 0; i < 2; i++) {
		if ((chp->ch_drive[i].drive_flags & DRIVE) == 0) {
			continue;
		}
		bzero(&aa_link, sizeof(struct ata_atapi_attach));
		if (chp->ch_drive[i].drive_flags & DRIVE_ATAPI)
			aa_link.aa_type = T_ATAPI;
		else
			aa_link.aa_type = T_ATA;
		aa_link.aa_channel = chp->channel;
		aa_link.aa_openings = 1;
		aa_link.aa_drv_data = &chp->ch_drive[i];
		config_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);
	}

	/*
	 * reset drive_flags for unnatached devices, reset state for attached
	 *  ones
	 */
	for (i = 0; i < 2; i++) {
		if (chp->ch_drive[i].drive_name[0] == 0)
			chp->ch_drive[i].drive_flags = 0;
	}

#ifndef __OpenBSD__
	wdc_delref(chp);
#endif

 exit:
#ifdef WDCDEBUG
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		wdcdebug_mask &= ~DEBUG_PROBE;

	wdcdebug_mask = savedmask;
#endif
	return;
}

/*
 * Start I/O on a controller, for the given channel.
 * The first xfer may be not for our channel if the channel queues
 * are shared.
 */
void
wdcstart(chp)
	struct channel_softc *chp;
{
	struct wdc_xfer *xfer;

	splassert(IPL_BIO);

	/* is there a xfer ? */
	if ((xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer)) == NULL) {
		return;
	}

	/* adjust chp, in case we have a shared queue */
	chp = xfer->chp;

	if ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {
		return; /* channel already active */
	}
#ifdef DIAGNOSTIC
	if ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)
		panic("wdcstart: channel waiting for irq");
#endif
	if (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)
		if (!(chp->wdc->claim_hw)(chp, 0))
			return;

	WDCDEBUG_PRINT(("wdcstart: xfer %p channel %d drive %d\n", xfer,
	    chp->channel, xfer->drive), DEBUG_XFERS);
	chp->ch_flags |= WDCF_ACTIVE;
	if (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {
		chp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;
		chp->ch_drive[xfer->drive].state = 0;
	}
	xfer->c_start(chp, xfer);
}

int
wdcdetach(chp, flags)
	struct channel_softc *chp;
	int flags;
{
	int s, rv;

	s = splbio();
	wdc_kill_pending(chp);

	rv = config_detach_children((struct device *)chp->wdc, flags);
	splx(s);

	return (rv);
}

/* restart an interrupted I/O */
void
wdcrestart(v)
	void *v;
{
	struct channel_softc *chp = v;
	int s;

	s = splbio();
	wdcstart(chp);
	splx(s);
}
	

/*
 * Interrupt routine for the controller.  Acknowledge the interrupt, check for
 * errors on the current operation, mark it done if necessary, and start the
 * next request.  Also check for a partially done transfer, and continue with
 * the next chunk if so.
 */
int
wdcintr(arg)
	void *arg;
{
	struct channel_softc *chp = arg;
	struct wdc_xfer *xfer;
	int ret;
	
	if ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {
		/* Acknowledge interrupt by reading status */
		if (chp->_vtbl == 0) {
			bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, 
			    wdr_status & _WDC_REGMASK);
		} else {
			CHP_READ_REG(chp, wdr_status);
		}

		WDCDEBUG_PRINT(("wdcintr: inactive controller\n"), DEBUG_INTR);
		return 0;
	}

	WDCDEBUG_PRINT(("wdcintr\n"), DEBUG_INTR);
	xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
	chp->ch_flags &= ~WDCF_IRQ_WAIT;
        ret = xfer->c_intr(chp, xfer, 1);
	if (ret == 0)	/* irq was not for us, still waiting for irq */
		chp->ch_flags |= WDCF_IRQ_WAIT;
	return (ret);
}

/* Put all disk in RESET state */
void wdc_reset_channel(drvp)
	struct ata_drive_datas *drvp;
{
	struct channel_softc *chp = drvp->chnl_softc;
	int drive;
	WDCDEBUG_PRINT(("ata_reset_channel %s:%d for drive %d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),
	    DEBUG_FUNCS);
	(void) wdcreset(chp, VERBOSE);
	for (drive = 0; drive < 2; drive++) {
		chp->ch_drive[drive].state = 0;
	}
}

int
wdcreset(chp, verb)
	struct channel_softc *chp;
	int verb;
{
	int drv_mask1, drv_mask2;

	if (!chp->_vtbl)
		chp->_vtbl = &wdc_default_vtbl;

	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_4BIT);
	delay(10);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
	delay(2000);

	drv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;
	drv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;
	drv_mask2 = __wdcwait_reset(chp, drv_mask1);
	if (verb && drv_mask2 != drv_mask1) {
		printf("%s channel %d: reset failed for",
		    chp->wdc->sc_dev.dv_xname, chp->channel);
		if ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)
			printf(" drive 0");
		if ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)
			printf(" drive 1");
		printf("\n");
	}

	return  (drv_mask1 != drv_mask2) ? 1 : 0;
}

static int
__wdcwait_reset(chp, drv_mask)
	struct channel_softc *chp;
	int drv_mask;
{
	int timeout;
	u_int8_t st0, st1;

	/* wait for BSY to deassert */
	for (timeout = 0; timeout < WDCNDELAY_RST; timeout++) {
		wdc_set_drive(chp, 0);
		delay(10);
		st0 = CHP_READ_REG(chp, wdr_status);
		wdc_set_drive(chp, 1);
		delay(10);
		st1 = CHP_READ_REG(chp, wdr_status);

		if ((drv_mask & 0x01) == 0) {
			/* no master */
			if ((drv_mask & 0x02) != 0 && (st1 & WDCS_BSY) == 0) {
				/* No master, slave is ready, it's done */
				goto end;
			}
		} else if ((drv_mask & 0x02) == 0) {
			/* no slave */
			if ((drv_mask & 0x01) != 0 && (st0 & WDCS_BSY) == 0) {
				/* No slave, master is ready, it's done */
				goto end;
			}
		} else {
			/* Wait for both master and slave to be ready */
			if ((st0 & WDCS_BSY) == 0 && (st1 & WDCS_BSY) == 0) {
				goto end;
			}
		}
		delay(WDCDELAY);
	}
	/* Reset timed out. Maybe it's because drv_mask was not right */
	if (st0 & WDCS_BSY)
		drv_mask &= ~0x01;
	if (st1 & WDCS_BSY)
		drv_mask &= ~0x02;
end:
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x, "
			"reset time=%d msec\n",
	    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe", chp->channel,
	    st0, st1, timeout*WDCDELAY/1000), DEBUG_PROBE);

	return drv_mask;
}

/*
 * Wait for a drive to be !BSY, and have mask in its status register.
 * return -1 for a timeout after "timeout" ms.
 */
int
wdc_wait_for_status(chp, mask, bits, timeout)
	struct channel_softc *chp;
	int mask, bits, timeout;
{
	u_char status;
	int time = 0;

	WDCDEBUG_PRINT(("wdcwait %s:%d\n", chp->wdc ?chp->wdc->sc_dev.dv_xname
	    :"none", chp->channel), DEBUG_STATUS);
	chp->ch_error = 0;

	timeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */

	for (;;) {
		chp->ch_status = status = CHP_READ_REG(chp, wdr_status);
		WDC_LOG_STATUS(chp, chp->ch_status);

		if (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {
			wdc_set_drive(chp, 1);
			chp->ch_status = status = 
			    CHP_READ_REG(chp, wdr_status);
			WDC_LOG_STATUS(chp, chp->ch_status);
		}
		if ((status & WDCS_BSY) == 0 && (status & mask) == bits)
			break;
		if (++time > timeout) {
			WDCDEBUG_PRINT(("wdcwait: timeout, status %x "
			    "error %x\n", status,
			    CHP_READ_REG(chp, wdr_error)),
			    DEBUG_STATUSX | DEBUG_STATUS); 
			return -1;
		}
		delay(WDCDELAY);
	}
	if (status & WDCS_ERR) {
		chp->ch_error = CHP_READ_REG(chp, wdr_error);
		WDC_LOG_ERROR(chp, chp->ch_error);

		WDCDEBUG_PRINT(("wdcwait: error %x\n", chp->ch_error),
			       DEBUG_STATUSX | DEBUG_STATUS);
	}

#ifdef WDCNDELAY_DEBUG
	/* After autoconfig, there should be no long delays. */
	if (!cold && time > WDCNDELAY_DEBUG) {
		struct wdc_xfer *xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
		if (xfer == NULL)
			printf("%s channel %d: warning: busy-wait took %dus\n",
			    chp->wdc->sc_dev.dv_xname, chp->channel,
			    WDCDELAY * time);
		else 
			printf("%s:%d:%d: warning: busy-wait took %dus\n",
			    chp->wdc->sc_dev.dv_xname, chp->channel,
			    xfer->drive,
			    WDCDELAY * time);
	}
#endif
	return time;
}

void
wdctimeout(arg)
	void *arg;
{
	struct channel_softc *chp = (struct channel_softc *)arg;
	struct wdc_xfer *xfer;
	int s;

	WDCDEBUG_PRINT(("wdctimeout\n"), DEBUG_FUNCS);

	s = splbio();
	xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);

	/* Did we lose a race with the interrupt? */
	if (xfer == NULL ||
	    !timeout_triggered(&chp->ch_timo)) {
		splx(s);
		return;
	}	
	if ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {
		__wdcerror(chp, "timeout");
		printf("\ttype: %s\n", (xfer->c_flags & C_ATAPI) ?
		    "atapi":"ata");
		printf("\tc_bcount: %d\n", xfer->c_bcount);
		printf("\tc_skip: %d\n", xfer->c_skip);
		/*
		 * Call the interrupt routine. If we just missed and interrupt,
		 * it will do what's needed. Else, it will take the needed
		 * action (reset the device).
		 */
		xfer->c_flags |= C_TIMEOU;
		chp->ch_flags &= ~WDCF_IRQ_WAIT;
		xfer->c_intr(chp, xfer, 1);
	} else
		__wdcerror(chp, "missing untimeout");
	splx(s);
}

/*
 * Probe drive's capabilites, for use by the controller later
 * Assumes drvp points to an existing drive. 
 * XXX this should be a controller-indep function
 */
void
wdc_probe_caps(drvp, params)
	struct ata_drive_datas *drvp;
	struct ataparams *params;
{
	struct channel_softc *chp = drvp->chnl_softc;
	struct wdc_softc *wdc = chp->wdc;
	int i, valid_mode_found;
	int cf_flags = drvp->cf_flags;

	if ((wdc->cap & (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==
	    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) {
		struct ataparams params2;

		/*
		 * Controller claims 16 and 32 bit transfers.
		 * Re-do an IDENTIFY with 32-bit transfers,
		 * and compare results.
		 */
		drvp->drive_flags |= DRIVE_CAP32;
		ata_get_params(drvp, at_poll, &params2);
		if (bcmp(params, &params2, sizeof(struct ataparams)) != 0) {
			/* Not good. fall back to 16bits */
			drvp->drive_flags &= ~DRIVE_CAP32;
		}
	}
#if 0 /* Some ultra-DMA drives claims to only support ATA-3. sigh */
	if (params->atap_ata_major > 0x01 && 
	    params->atap_ata_major != 0xffff) {
		for (i = 14; i > 0; i--) {
			if (params->atap_ata_major & (1 << i)) {
				printf("%sATA version %d\n", sep, i);
				drvp->ata_vers = i;
				break;
			}
		}
	} else 
#endif
	/* Use PIO mode 3 as a default value for ATAPI devices */
	if (drvp->drive_flags & DRIVE_ATAPI)
		drvp->PIO_mode = 3;

	WDCDEBUG_PRINT(("wdc_probe_caps: wdc_cap %d cf_flags %d\n", 
		    wdc->cap, cf_flags), DEBUG_PROBE);

	valid_mode_found = 0;

	WDCDEBUG_PRINT(("%s: atap_oldpiotiming=%d\n", __func__,
	    params->atap_oldpiotiming), DEBUG_PROBE);
	/*
	 * ATA-4 compliant devices contain PIO mode
	 * number in atap_oldpiotiming.
	 */
	if (params->atap_oldpiotiming <= 2) {
		drvp->PIO_cap = params->atap_oldpiotiming;
		valid_mode_found = 1;
		drvp->drive_flags |= DRIVE_MODE;
	} else if (params->atap_oldpiotiming > 180 &&
	    params->atap_oldpiotiming <= 600) {
		/*
		 * ATA-2 compliant devices contain cycle
		 * time in atap_oldpiotiming.
		 * A device with a cycle time of 180ns
		 * or less is at least PIO mode 3 and
		 * should be reporting that in
		 * atap_piomode_supp, so ignore it here.
		 * A cycle time greater than 600ns seems
		 * to be invalid.
		 */
		if (params->atap_oldpiotiming <= 240) {
			drvp->PIO_cap = 2;
		} else if (params->atap_oldpiotiming <= 480) {
			drvp->PIO_cap = 1;
		} else {
			drvp->PIO_cap = 0;
		}
		valid_mode_found = 1;
		drvp->drive_flags |= DRIVE_MODE;
	}
	if (valid_mode_found)
		drvp->PIO_mode = drvp->PIO_cap;

	/*
	 * It's not in the specs, but it seems that some drive 
	 * returns 0xffff in atap_extensions when this field is invalid
	 */
	if (params->atap_extensions != 0xffff &&
	    (params->atap_extensions & WDC_EXT_MODES)) {
		/*
		 * XXX some drives report something wrong here (they claim to
		 * support PIO mode 8 !). As mode is coded on 3 bits in
		 * SET FEATURE, limit it to 7 (so limit i to 4).
		 * If higther mode than 7 is found, abort.
		 */
		for (i = 7; i >= 0; i--) {
			if ((params->atap_piomode_supp & (1 << i)) == 0)
				continue;
			if (i > 4)
				return;

			valid_mode_found = 1;

			if ((wdc->cap & WDC_CAPABILITY_MODE) == 0) {
				drvp->PIO_cap = i + 3;
				continue;
			}

                        /*
			 * See if mode is accepted.
			 * If the controller can't set its PIO mode,
			 * assume the BIOS set it up correctly
			 */
			if (ata_set_mode(drvp, 0x08 | (i + 3),
				at_poll) != CMD_OK)
				continue;

			/*
			 * If controller's driver can't set its PIO mode,
			 * set the highest one the controller supports
			 */
			if (wdc->PIO_cap >= i + 3) {
				drvp->PIO_mode = i + 3;
				drvp->PIO_cap = i + 3;
				break;
			}
		}
		if (!valid_mode_found) {
			/* 
			 * We didn't find a valid PIO mode.
			 * Assume the values returned for DMA are buggy too
			 */
			return;
		}
		drvp->drive_flags |= DRIVE_MODE;

		/* Some controllers don't support ATAPI DMA */
		if ((drvp->drive_flags & DRIVE_ATAPI) &&
		    (wdc->cap & WDC_CAPABILITY_NO_ATAPI_DMA))
			return;

		valid_mode_found = 0;
		for (i = 7; i >= 0; i--) {
			if ((params->atap_dmamode_supp & (1 << i)) == 0)
				continue;
			if ((wdc->cap & WDC_CAPABILITY_DMA) &&
			    (wdc->cap & WDC_CAPABILITY_MODE))
				if (ata_set_mode(drvp, 0x20 | i, at_poll)
				    != CMD_OK)
					continue;

			valid_mode_found = 1;

			if (wdc->cap & WDC_CAPABILITY_DMA) {
				if ((wdc->cap & WDC_CAPABILITY_MODE) &&
				    wdc->DMA_cap < i)
					continue;
				drvp->DMA_mode = i;
				drvp->DMA_cap = i;
				drvp->drive_flags |= DRIVE_DMA;
			}
			break;
		}
		if (params->atap_extensions & WDC_EXT_UDMA_MODES) {
			for (i = 7; i >= 0; i--) {
				if ((params->atap_udmamode_supp & (1 << i))
				    == 0)
					continue;
				if ((wdc->cap & WDC_CAPABILITY_MODE) &&
				    (wdc->cap & WDC_CAPABILITY_UDMA))
					if (ata_set_mode(drvp, 0x40 | i,
					    at_poll) != CMD_OK)
						continue;
				if (wdc->cap & WDC_CAPABILITY_UDMA) {
					if ((wdc->cap & WDC_CAPABILITY_MODE) &&
					    wdc->UDMA_cap < i)
						continue;
					drvp->UDMA_mode = i;
					drvp->UDMA_cap = i;
					drvp->drive_flags |= DRIVE_UDMA;
				}
				break;
			}
		}
	}

	/* Try to guess ATA version here, if it didn't get reported */
	if (drvp->ata_vers == 0) {
		if (drvp->drive_flags & DRIVE_UDMA)
			drvp->ata_vers = 4; /* should be at last ATA-4 */
		else if (drvp->PIO_cap > 2)
			drvp->ata_vers = 2; /* should be at last ATA-2 */
	}
	if (cf_flags & ATA_CONFIG_PIO_SET) {
		drvp->PIO_mode =
		    (cf_flags & ATA_CONFIG_PIO_MODES) >> ATA_CONFIG_PIO_OFF;
		drvp->drive_flags |= DRIVE_MODE;
	}
	if ((wdc->cap & WDC_CAPABILITY_DMA) == 0) {
		/* don't care about DMA modes */
		return;
	}
	if (cf_flags & ATA_CONFIG_DMA_SET) {
		if ((cf_flags & ATA_CONFIG_DMA_MODES) ==
		    ATA_CONFIG_DMA_DISABLE) {
			drvp->drive_flags &= ~DRIVE_DMA;
		} else {
			drvp->DMA_mode = (cf_flags & ATA_CONFIG_DMA_MODES) >>
			    ATA_CONFIG_DMA_OFF;
			drvp->drive_flags |= DRIVE_DMA | DRIVE_MODE;
		}
	}
	if ((wdc->cap & WDC_CAPABILITY_UDMA) == 0) {
		/* don't care about UDMA modes */
		return;
	}
	if (cf_flags & ATA_CONFIG_UDMA_SET) {
		if ((cf_flags & ATA_CONFIG_UDMA_MODES) ==
		    ATA_CONFIG_UDMA_DISABLE) {
			drvp->drive_flags &= ~DRIVE_UDMA;
		} else {
			drvp->UDMA_mode = (cf_flags & ATA_CONFIG_UDMA_MODES) >>
			    ATA_CONFIG_UDMA_OFF;
			drvp->drive_flags |= DRIVE_UDMA | DRIVE_MODE;
		}
	}
}

void
wdc_output_bytes(drvp, bytes, buflen)
	struct ata_drive_datas *drvp;
	void *bytes;
	unsigned int buflen;
{
	struct channel_softc *chp = drvp->chnl_softc;
	unsigned int off = 0;
	unsigned int len = buflen, roundlen;	

	if (drvp->drive_flags & DRIVE_CAP32) {
		roundlen = len & ~3;

		CHP_WRITE_RAW_MULTI_4(chp, 
		    (void *)((u_int8_t *)bytes + off), roundlen);

		off += roundlen;
		len -= roundlen;
	}

	if (len > 0) {
		roundlen = (len + 1) & ~0x1;

	        CHP_WRITE_RAW_MULTI_2(chp,
		    (void *)((u_int8_t *)bytes + off), roundlen);
	}

	return;
}

void
wdc_input_bytes(drvp, bytes, buflen)
	struct ata_drive_datas *drvp;
	void *bytes;
	unsigned int buflen;
{
	struct channel_softc *chp = drvp->chnl_softc;
	unsigned int off = 0;
	unsigned int len = buflen, roundlen;

	if (drvp->drive_flags & DRIVE_CAP32) {
		roundlen = len & ~3;

		CHP_READ_RAW_MULTI_4(chp,
		    (void *)((u_int8_t *)bytes + off), roundlen);

		off += roundlen;
		len -= roundlen;
	}

	if (len > 0) {
		roundlen = (len + 1) & ~0x1;

		CHP_READ_RAW_MULTI_2(chp,
		    (void *)((u_int8_t *)bytes + off), roundlen);
	}

	return;
}

void
wdc_print_caps(drvp)
	struct ata_drive_datas *drvp;
{
	/* This is actually a lie until we fix the _probe_caps
	   algorithm. Don't print out lies */
#if 0
 	printf("%s: can use ", drvp->drive_name);

	if (drvp->drive_flags & DRIVE_CAP32) {
		printf("32-bit");
	} else 
		printf("16-bit");

	printf(", PIO mode %d", drvp->PIO_cap);

	if (drvp->drive_flags & DRIVE_DMA) {
		printf(", DMA mode %d", drvp->DMA_cap);
	}

	if (drvp->drive_flags & DRIVE_UDMA) {
		printf(", Ultra-DMA mode %d", drvp->UDMA_cap);
	}
			
	printf("\n");
#endif
}

void
wdc_print_current_modes(chp)
	struct channel_softc *chp;
{
	int drive;
	struct ata_drive_datas *drvp;

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;

		printf("%s(%s:%d:%d):",
 		    drvp->drive_name,
		    chp->wdc->sc_dev.dv_xname, chp->channel, drive);

		if ((chp->wdc->cap & WDC_CAPABILITY_MODE) == 0 &&
		    !(drvp->cf_flags & ATA_CONFIG_PIO_SET))
			printf(" using BIOS timings");
		else
			printf(" using PIO mode %d", drvp->PIO_mode);
		if (drvp->drive_flags & DRIVE_DMA)
			printf(", DMA mode %d", drvp->DMA_mode);
		if (drvp->drive_flags & DRIVE_UDMA)
			printf(", Ultra-DMA mode %d", drvp->UDMA_mode);
		printf("\n");
	}
}

/*
 * downgrade the transfer mode of a drive after an error. return 1 if
 * downgrade was possible, 0 otherwise.
 */
int
wdc_downgrade_mode(drvp)
	struct ata_drive_datas *drvp;
{
	struct channel_softc *chp = drvp->chnl_softc;
	struct wdc_softc *wdc = chp->wdc;
	int cf_flags = drvp->cf_flags;

	/* if drive or controller don't know its mode, we can't do much */
	if ((drvp->drive_flags & DRIVE_MODE) == 0 ||
	    (wdc->cap & WDC_CAPABILITY_MODE) == 0)
		return 0;
	/* current drive mode was set by a config flag, let it this way */
	if ((cf_flags & ATA_CONFIG_PIO_SET) ||
	    (cf_flags & ATA_CONFIG_DMA_SET) ||
	    (cf_flags & ATA_CONFIG_UDMA_SET))
		return 0;

	/*
	 * We'd ideally like to use an Ultra DMA mode since they have the
	 * protection of a CRC. So we try each Ultra DMA mode and see if
	 * we can find any working combo
	 */
	if ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode > 0) {
		drvp->UDMA_mode = drvp->UDMA_mode - 1;
		printf("%s: transfer error, downgrading to Ultra-DMA mode %d\n",
		    drvp->drive_name, drvp->UDMA_mode);
	} else 	if ((drvp->drive_flags & DRIVE_UDMA) &&
	    (drvp->drive_flags & DRIVE_DMAERR) == 0) {
		/* 
		 * If we were using ultra-DMA, don't downgrade to
		 * multiword DMA if we noticed a CRC error. It has
		 * been noticed that CRC errors in ultra-DMA lead to
		 * silent data corruption in multiword DMA.  Data
		 * corruption is less likely to occur in PIO mode.  
		 */
		drvp->drive_flags &= ~DRIVE_UDMA;
		drvp->drive_flags |= DRIVE_DMA;
		drvp->DMA_mode = drvp->DMA_cap;
		printf("%s: transfer error, downgrading to DMA mode %d\n",
		    drvp->drive_name, drvp->DMA_mode);
	} else if (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) {
		drvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);
		drvp->PIO_mode = drvp->PIO_cap;
		printf("%s: transfer error, downgrading to PIO mode %d\n",
		    drvp->drive_name, drvp->PIO_mode);
	} else /* already using PIO, can't downgrade */
		return 0;

	wdc->set_modes(chp);
	/* reset the channel, which will schedule all drives for setup */
	wdc_reset_channel(drvp);
	return 1;
}

int
wdc_exec_command(drvp, wdc_c)
	struct ata_drive_datas *drvp;
	struct wdc_command *wdc_c;
{
	struct channel_softc *chp = drvp->chnl_softc;
	struct wdc_xfer *xfer;
	int s, ret;

	WDCDEBUG_PRINT(("wdc_exec_command %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),
	    DEBUG_FUNCS);

	/* set up an xfer and queue. Wait for completion */
	xfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :
	    WDC_NOSLEEP);
	if (xfer == NULL) {
		return WDC_TRY_AGAIN;
	 }

	if (wdc_c->flags & AT_POLL)
		xfer->c_flags |= C_POLL;
	xfer->drive = drvp->drive;
	xfer->databuf = wdc_c->data;
	xfer->c_bcount = wdc_c->bcount;
	xfer->cmd = wdc_c;
	xfer->c_start = __wdccommand_start;
	xfer->c_intr = __wdccommand_intr;
	xfer->c_kill_xfer = __wdccommand_done;

	s = splbio();
	wdc_exec_xfer(chp, xfer);
#ifdef DIAGNOSTIC
	if ((wdc_c->flags & AT_POLL) != 0 &&
	    (wdc_c->flags & AT_DONE) == 0)
		panic("wdc_exec_command: polled command not done");
#endif
	if (wdc_c->flags & AT_DONE) {
		ret = WDC_COMPLETE;
	} else {
		if (wdc_c->flags & AT_WAIT) {
			WDCDEBUG_PRINT(("wdc_exec_command sleeping"),
				       DEBUG_FUNCS);

			while ((wdc_c->flags & AT_DONE) == 0) {
				tsleep(wdc_c, PRIBIO, "wdccmd", 0);
			}
			ret = WDC_COMPLETE;
		} else {
			ret = WDC_QUEUED;
		}
	}
	splx(s);
	return ret;
}

void
__wdccommand_start(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
{   
	int drive = xfer->drive;
	struct wdc_command *wdc_c = xfer->cmd;

	WDCDEBUG_PRINT(("__wdccommand_start %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),
	    DEBUG_FUNCS);

	/*
	 * Disable interrupts if we're polling
	 */
	if (xfer->c_flags & C_POLL) {
		wdc_disable_intr(chp);
	}

	wdc_set_drive(chp, drive);
	DELAY(1);

	/*
	 * For resets, we don't really care to make sure that
	 * the bus is free
	 */
	if (wdc_c->r_command != ATAPI_SOFT_RESET) {
		if (wdcwait(chp, wdc_c->r_st_bmask | WDCS_DRQ, wdc_c->r_st_bmask,
		    wdc_c->timeout) != 0) {
			goto timeout;
		}
	} else
		DELAY(10);

	wdccommand(chp, drive, wdc_c->r_command, wdc_c->r_cyl, wdc_c->r_head,
	    wdc_c->r_sector, wdc_c->r_count, wdc_c->r_precomp);

	if ((wdc_c->flags & AT_WRITE) == AT_WRITE) {
		delay(10);
		if (wait_for_unbusy(chp, wdc_c->timeout) != 0)
			goto timeout;
		
		if ((chp->ch_status & (WDCS_DRQ | WDCS_ERR)) == WDCS_ERR) {
			__wdccommand_done(chp, xfer);
			return;
		}

		if (wait_for_drq(chp, wdc_c->timeout) != 0)
			goto timeout;

		wdc_output_bytes(&chp->ch_drive[drive], 
		    wdc_c->data, wdc_c->bcount);
	}

	if ((wdc_c->flags & AT_POLL) == 0) {
		chp->ch_flags |= WDCF_IRQ_WAIT; /* wait for interrupt */
		timeout_add(&chp->ch_timo, wdc_c->timeout / 1000 * hz);
		return;
	}

	/*
	 * Polled command. Wait for drive ready or drq. Done in intr().
	 * Wait for at last 400ns for status bit to be valid.
	 */
	delay(10);
	__wdccommand_intr(chp, xfer, 0);
	return;

 timeout:
	wdc_c->flags |= AT_TIMEOU;
	__wdccommand_done(chp, xfer);
	return;
}

int
__wdccommand_intr(chp, xfer, irq)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int irq;
{
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	struct wdc_command *wdc_c = xfer->cmd;
	int bcount = wdc_c->bcount;
	char *data = wdc_c->data;

	WDCDEBUG_PRINT(("__wdccommand_intr %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_INTR);
	if (wdcwait(chp, wdc_c->r_st_pmask, wdc_c->r_st_pmask,
	     (irq == 0)  ? wdc_c->timeout : 0)) {
		if (irq && (xfer->c_flags & C_TIMEOU) == 0) 
			return 0; /* IRQ was not for us */
		wdc_c->flags |= AT_TIMEOU;
		__wdccommand_done(chp, xfer);
		WDCDEBUG_PRINT(("__wdccommand_intr returned\n"), DEBUG_INTR);
		return 1;
	}
        if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
                chp->wdc->irqack(chp);

	if ((wdc_c->flags & AT_READ) && (chp->ch_status & WDCS_DRQ)) {
		wdc_input_bytes(drvp, data, bcount);
		/* Should we wait for device to indicate idle? */
	}
	__wdccommand_done(chp, xfer);
	WDCDEBUG_PRINT(("__wdccommand_intr returned\n"), DEBUG_INTR);
	return 1;
}

void
__wdccommand_done(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
{
	struct wdc_command *wdc_c = xfer->cmd;

	WDCDEBUG_PRINT(("__wdccommand_done %s:%d:%d %02x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, chp->ch_status), DEBUG_FUNCS);
	if (chp->ch_status & WDCS_DWF)
		wdc_c->flags |= AT_DF;
	if (chp->ch_status & WDCS_ERR) {
		wdc_c->flags |= AT_ERROR;
		wdc_c->r_error = chp->ch_error;
	}
	wdc_c->flags |= AT_DONE;
	if (wdc_c->flags & AT_READREG && (wdc_c->flags & (AT_ERROR | AT_DF))
								== 0) {
		wdc_c->r_head = CHP_READ_REG(chp, wdr_sdh);
		wdc_c->r_cyl = CHP_READ_REG(chp, wdr_cyl_hi) << 8;
		wdc_c->r_cyl |= CHP_READ_REG(chp, wdr_cyl_lo);
		wdc_c->r_sector = CHP_READ_REG(chp, wdr_sector);
		wdc_c->r_count = CHP_READ_REG(chp, wdr_seccnt);
		wdc_c->r_error = CHP_READ_REG(chp, wdr_error);
		wdc_c->r_precomp = wdc_c->r_error; 
		/* XXX CHP_READ_REG(chp, wdr_precomp); - precomp
		   isn't a readable register */
	}

	if (xfer->c_flags & C_POLL) {
		wdc_enable_intr(chp);
	}

	wdc_free_xfer(chp, xfer);
	WDCDEBUG_PRINT(("__wdccommand_done before callback\n"), DEBUG_INTR);

	if (wdc_c->flags & AT_WAIT)
		wakeup(wdc_c);
	else
		if (wdc_c->callback)
			wdc_c->callback(wdc_c->callback_arg);
	wdcstart(chp);
	WDCDEBUG_PRINT(("__wdccommand_done returned\n"), DEBUG_INTR);
	return;
}

/*
 * Send a command. The drive should be ready.
 * Assumes interrupts are blocked.
 */
void
wdccommand(chp, drive, command, cylin, head, sector, count, precomp)
	struct channel_softc *chp;
	u_int8_t drive;
	u_int8_t command;
	u_int16_t cylin;
	u_int8_t head, sector, count, precomp;
{
	WDCDEBUG_PRINT(("wdccommand %s:%d:%d: command=0x%x cylin=%d head=%d "
	    "sector=%d count=%d precomp=%d\n", chp->wdc->sc_dev.dv_xname,
	    chp->channel, drive, command, cylin, head, sector, count, precomp),
	    DEBUG_FUNCS);
	WDC_LOG_ATA_CMDLONG(chp, head, precomp, cylin, cylin >> 8, sector,
	    count, command);

	/* Select drive, head, and addressing mode. */
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4) | head);

	/* Load parameters. wdr_features(ATA/ATAPI) = wdr_precomp(ST506) */
	CHP_WRITE_REG(chp, wdr_precomp, precomp);
	CHP_WRITE_REG(chp, wdr_cyl_lo, cylin);
	CHP_WRITE_REG(chp, wdr_cyl_hi, cylin >> 8);
	CHP_WRITE_REG(chp, wdr_sector, sector);
	CHP_WRITE_REG(chp, wdr_seccnt, count);

	/* Send command. */
	CHP_WRITE_REG(chp, wdr_command, command);
	return;
}

/*
 * Send a 48-bit addressing command. The drive should be ready.
 * Assumes interrupts are blocked.
 */
void
wdccommandext(chp, drive, command, blkno, count)
	struct channel_softc *chp;
	u_int8_t drive;
	u_int8_t command;
	u_int64_t blkno;
	u_int16_t count;
{
	WDCDEBUG_PRINT(("wdccommandext %s:%d:%d: command=0x%x blkno=%llu "
	    "count=%d\n", chp->wdc->sc_dev.dv_xname,
	    chp->channel, drive, command, blkno, count),
	    DEBUG_FUNCS);
	WDC_LOG_ATA_CMDEXT(chp, blkno >> 40, blkno >> 16, blkno >> 32,
	    blkno >> 8, blkno >> 24, blkno, count >> 8, count, command);

	/* Select drive and LBA mode. */
	CHP_WRITE_REG(chp, wdr_sdh, (drive << 4) | WDSD_LBA);

	/* Load parameters. All registers are two byte deep FIFOs. */
	CHP_WRITE_REG(chp, wdr_lba_hi, blkno >> 40);
	CHP_WRITE_REG(chp, wdr_lba_hi, blkno >> 16);
	CHP_WRITE_REG(chp, wdr_lba_mi, blkno >> 32);
	CHP_WRITE_REG(chp, wdr_lba_mi, blkno >> 8);
	CHP_WRITE_REG(chp, wdr_lba_lo, blkno >> 24);
	CHP_WRITE_REG(chp, wdr_lba_lo, blkno);
	CHP_WRITE_REG(chp, wdr_seccnt, count >> 8);
	CHP_WRITE_REG(chp, wdr_seccnt, count);

	/* Send command. */
	CHP_WRITE_REG(chp, wdr_command, command);
	return;
}

/*
 * Simplified version of wdccommand().  Unbusy/ready/drq must be
 * tested by the caller.
 */
void
wdccommandshort(chp, drive, command)
	struct channel_softc *chp;
	int drive;
	int command;
{

	WDCDEBUG_PRINT(("wdccommandshort %s:%d:%d command 0x%x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),
	    DEBUG_FUNCS);
	WDC_LOG_ATA_CMDSHORT(chp, command);

	/* Select drive. */
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));
	CHP_WRITE_REG(chp, wdr_command, command);
}

/* Add a command to the queue and start controller. Must be called at splbio */

void
wdc_exec_xfer(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
{
	WDCDEBUG_PRINT(("wdc_exec_xfer %p channel %d drive %d\n", xfer,
	    chp->channel, xfer->drive), DEBUG_XFERS);

	/* complete xfer setup */
	xfer->chp = chp;

	/*
	 * If we are a polled command, and the list is not empty,
	 * we are doing a dump. Drop the list to allow the polled command
	 * to complete, we're going to reboot soon anyway.
	 */
	if ((xfer->c_flags & C_POLL) != 0 &&
	    !TAILQ_EMPTY(&chp->ch_queue->sc_xfer)) {
		TAILQ_INIT(&chp->ch_queue->sc_xfer);
	}
	/* insert at the end of command list */
	TAILQ_INSERT_TAIL(&chp->ch_queue->sc_xfer,xfer , c_xferchain);
	WDCDEBUG_PRINT(("wdcstart from wdc_exec_xfer, flags 0x%x\n",
	    chp->ch_flags), DEBUG_XFERS);
	wdcstart(chp);
}

struct wdc_xfer *
wdc_get_xfer(flags)
	int flags;
{
	struct wdc_xfer *xfer;
	int s;

	s = splbio();
	xfer = pool_get(&wdc_xfer_pool,
	    ((flags & WDC_NOSLEEP) != 0 ? PR_NOWAIT : PR_WAITOK));
	splx(s);
	if (xfer != NULL)
		memset(xfer, 0, sizeof(struct wdc_xfer));
	return xfer;
}

void
wdc_free_xfer(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
{
	struct wdc_softc *wdc = chp->wdc;
	int s;

	if (wdc->cap & WDC_CAPABILITY_HWLOCK)
		(*wdc->free_hw)(chp);
	s = splbio();
	chp->ch_flags &= ~WDCF_ACTIVE;
	TAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);
	pool_put(&wdc_xfer_pool, xfer);
	splx(s);
}


/*
 * Kill off all pending xfers for a channel_softc.
 *
 * Must be called at splbio().
 */
void
wdc_kill_pending(chp)
	struct channel_softc *chp;
{
	struct wdc_xfer *xfer;

	while ((xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer)) != NULL) {
		chp = xfer->chp;
		(*xfer->c_kill_xfer)(chp, xfer);
	}
}

static void
__wdcerror(chp, msg) 
	struct channel_softc *chp;
	char *msg;
{
	struct wdc_xfer *xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
	if (xfer == NULL)
		printf("%s:%d: %s\n", chp->wdc->sc_dev.dv_xname, chp->channel,
		    msg);
	else 
		printf("%s(%s:%d:%d): %s\n", 
		    chp->ch_drive[xfer->drive].drive_name,
		    chp->wdc->sc_dev.dv_xname,
		    chp->channel, xfer->drive, msg);
}

/* 
 * the bit bucket
 */
void
wdcbit_bucket(chp, size)
	struct channel_softc *chp; 
	int size;
{
	CHP_READ_RAW_MULTI_2(chp, NULL, size);
}


#include <sys/ataio.h>
#include <sys/file.h>
#include <sys/buf.h>

/*
 * Glue necessary to hook ATAIOCCOMMAND into physio
 */

struct wdc_ioctl {
	LIST_ENTRY(wdc_ioctl) wi_list;
	struct buf wi_bp;
	struct uio wi_uio;
	struct iovec wi_iov;
	atareq_t wi_atareq;
	struct ata_drive_datas *wi_drvp;
};

struct	wdc_ioctl *wdc_ioctl_find(struct buf *);
void	wdc_ioctl_free(struct wdc_ioctl *);
struct	wdc_ioctl *wdc_ioctl_get(void);
void	wdc_ioctl_strategy(struct buf *);

LIST_HEAD(, wdc_ioctl) wi_head;

/*
 * Allocate space for a ioctl queue structure.  Mostly taken from
 * scsipi_ioctl.c
 */
struct wdc_ioctl *
wdc_ioctl_get()
{
	struct wdc_ioctl *wi;
	int s;

	wi = malloc(sizeof(struct wdc_ioctl), M_TEMP, M_WAITOK);
	bzero(wi, sizeof (struct wdc_ioctl));
	s = splbio();
	LIST_INSERT_HEAD(&wi_head, wi, wi_list);
	splx(s);
	return (wi);
}

/*
 * Free an ioctl structure and remove it from our list
 */

void
wdc_ioctl_free(wi)
	struct wdc_ioctl *wi;
{
	int s;

	s = splbio();
	LIST_REMOVE(wi, wi_list);
	splx(s);
	free(wi, M_TEMP);
}

/*
 * Find a wdc_ioctl structure based on the struct buf.
 */

struct wdc_ioctl *
wdc_ioctl_find(bp)
	struct buf *bp;
{
	struct wdc_ioctl *wi;
	int s;

	s = splbio();
	LIST_FOREACH(wi, &wi_head, wi_list)
		if (bp == &wi->wi_bp)
			break;
	splx(s);
	return (wi);
}

/*
 * Ioctl pseudo strategy routine
 *
 * This is mostly stolen from scsipi_ioctl.c:scsistrategy().  What
 * happens here is:
 *
 * - wdioctl() queues a wdc_ioctl structure.
 *
 * - wdioctl() calls physio/wdc_ioctl_strategy based on whether or not
 *   user space I/O is required.  If physio() is called, physio() eventually
 *   calls wdc_ioctl_strategy().
 *
 * - In either case, wdc_ioctl_strategy() calls wdc_exec_command()
 *   to perform the actual command
 *
 * The reason for the use of the pseudo strategy routine is because
 * when doing I/O to/from user space, physio _really_ wants to be in
 * the loop.  We could put the entire buffer into the ioctl request
 * structure, but that won't scale if we want to do things like download
 * microcode.
 */

void
wdc_ioctl_strategy(bp)
	struct buf *bp;
{
	struct wdc_ioctl *wi;
	struct wdc_command wdc_c;
	int error = 0;
	int s;

	wi = wdc_ioctl_find(bp);
	if (wi == NULL) {
		printf("user_strat: No ioctl\n");
		error = EINVAL;
		goto bad;
	}

	bzero(&wdc_c, sizeof(wdc_c));

	/*
	 * Abort if physio broke up the transfer
	 */

	if (bp->b_bcount != wi->wi_atareq.datalen) {
		printf("physio split wd ioctl request... cannot proceed\n");
		error = EIO;
		goto bad;
	}

	/*
	 * Make sure a timeout was supplied in the ioctl request
	 */

	if (wi->wi_atareq.timeout == 0) {
		error = EINVAL;
		goto bad;
	}

	if (wi->wi_atareq.flags & ATACMD_READ)
		wdc_c.flags |= AT_READ;
	else if (wi->wi_atareq.flags & ATACMD_WRITE)
		wdc_c.flags |= AT_WRITE;

	if (wi->wi_atareq.flags & ATACMD_READREG)
		wdc_c.flags |= AT_READREG;

	wdc_c.flags |= AT_WAIT;

	wdc_c.timeout = wi->wi_atareq.timeout;
	wdc_c.r_command = wi->wi_atareq.command;
	wdc_c.r_head = wi->wi_atareq.head & 0x0f;
	wdc_c.r_cyl = wi->wi_atareq.cylinder;
	wdc_c.r_sector = wi->wi_atareq.sec_num;
	wdc_c.r_count = wi->wi_atareq.sec_count;
	wdc_c.r_precomp = wi->wi_atareq.features;
	if (wi->wi_drvp->drive_flags & DRIVE_ATAPI) {
		wdc_c.r_st_bmask = 0;
		wdc_c.r_st_pmask = 0;
		if (wdc_c.r_command == WDCC_IDENTIFY)
			wdc_c.r_command = ATAPI_IDENTIFY_DEVICE;
	} else {
		wdc_c.r_st_bmask = WDCS_DRDY;
		wdc_c.r_st_pmask = WDCS_DRDY;
	}
	wdc_c.data = wi->wi_bp.b_data;
	wdc_c.bcount = wi->wi_bp.b_bcount;

	if (wdc_exec_command(wi->wi_drvp, &wdc_c) != WDC_COMPLETE) {
		wi->wi_atareq.retsts = ATACMD_ERROR;
		goto bad;
	}

	if (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {
		if (wdc_c.flags & AT_ERROR) {
			wi->wi_atareq.retsts = ATACMD_ERROR;
			wi->wi_atareq.error = wdc_c.r_error;
		} else if (wdc_c.flags & AT_DF)
			wi->wi_atareq.retsts = ATACMD_DF;
		else
			wi->wi_atareq.retsts = ATACMD_TIMEOUT;
	} else {
		wi->wi_atareq.retsts = ATACMD_OK;
		if (wi->wi_atareq.flags & ATACMD_READREG) {
			wi->wi_atareq.head = wdc_c.r_head ;
			wi->wi_atareq.cylinder = wdc_c.r_cyl;
			wi->wi_atareq.sec_num = wdc_c.r_sector;
			wi->wi_atareq.sec_count = wdc_c.r_count; 
			wi->wi_atareq.features = wdc_c.r_precomp; 
			wi->wi_atareq.error = wdc_c.r_error; 
		}
	}

	bp->b_error = 0;
	s = splbio();
	biodone(bp);
	splx(s);
	return;
bad:
	bp->b_flags |= B_ERROR;
	bp->b_error = error;
	s = splbio();
	biodone(bp);
	splx(s);
}

int
wdc_ioctl(drvp, xfer, addr, flag, p)
	struct ata_drive_datas *drvp;
	u_long xfer;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	int error = 0;

	switch (xfer) {
	case ATAIOGETTRACE: {
		atagettrace_t *agt = (atagettrace_t *)addr;
		unsigned int size = 0;
		char *log_to_copy;
		
		size = agt->buf_size;
		if (size > 65536) {
			size = 65536;
		}

		log_to_copy = wdc_get_log(&size, &agt->bytes_left);

		if (log_to_copy != NULL) {
			error = copyout(log_to_copy, agt->buf, size);
			free(log_to_copy, M_TEMP);
		}

		agt->bytes_copied = size;
		break;
	}

	case ATAIOCCOMMAND:
		/*
		 * Make sure this command is (relatively) safe first
		 */
		if ((((atareq_t *) addr)->flags & ATACMD_READ) == 0 &&
		    (flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
		{
		struct wdc_ioctl *wi;
		atareq_t *atareq = (atareq_t *) addr;

		wi = wdc_ioctl_get();
		wi->wi_drvp = drvp;
		wi->wi_atareq = *atareq;

		if (atareq->datalen && atareq->flags &
		    (ATACMD_READ | ATACMD_WRITE)) {
			wi->wi_iov.iov_base = atareq->databuf;
			wi->wi_iov.iov_len = atareq->datalen;
			wi->wi_uio.uio_iov = &wi->wi_iov;
			wi->wi_uio.uio_iovcnt = 1;
			wi->wi_uio.uio_resid = atareq->datalen;
			wi->wi_uio.uio_offset = 0;
			wi->wi_uio.uio_segflg = UIO_USERSPACE;
			wi->wi_uio.uio_rw =
			    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE;
			wi->wi_uio.uio_procp = curproc;
			error = physio(wdc_ioctl_strategy, &wi->wi_bp, 0,
			    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE,
			    minphys, &wi->wi_uio);
		} else {
			/* No need to call physio if we don't have any
			   user data */
			wi->wi_bp.b_flags = 0;
			wi->wi_bp.b_data = 0;
			wi->wi_bp.b_bcount = 0;
			wi->wi_bp.b_dev = 0;
			wi->wi_bp.b_proc = curproc;
			LIST_INIT(&wi->wi_bp.b_dep);
			wdc_ioctl_strategy(&wi->wi_bp);
			error = wi->wi_bp.b_error;
		}
		*atareq = wi->wi_atareq;
		wdc_ioctl_free(wi);
		goto exit;
		}
	default:
		error = ENOTTY;
		goto exit;
	}

 exit:
	return (error);
}
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.61 2003/06/25 17:53:10 henric Exp $     */
d98 1
a98 1
#endif /* 0 */
d128 1
a128 1
#endif /* WDCDEBUG */
d287 1
a287 1
#endif /* DIAGNOSTIC */
d307 1
a307 1
#endif /* DIAGNOSTIC */
a607 3
#ifdef WDCDEBUG
	int savedmask = wdcdebug_mask;
#endif
d620 1
a620 1
#endif /* WDCDEBUG */
d716 4
a719 1
	wdcdebug_mask = savedmask;
d767 1
a767 1
#endif /* __OpenBSD__ */
d793 1
a793 1
#endif /* WDCDEBUG */
d882 3
d917 1
a917 1
#endif /* DIAGNOSTIC */
d1156 1
a1156 1
#endif /* WDCNDELAY_DEBUG */
d1240 1
a1240 1
#endif /* 0 */
d1515 1
a1515 1
#endif /* 0 */
d1642 1
a1642 1
#endif /* DIAGNOSTIC */
@


1.1.1.3
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.62 2003/07/06 08:25:16 grange Exp $     */
d134 1
a134 1
void wdc_default_read_raw_multi_2(struct channel_softc *,
d136 1
a136 1
void wdc_default_write_raw_multi_2(struct channel_softc *,
d138 1
a138 1
void wdc_default_read_raw_multi_4(struct channel_softc *,
d140 1
a140 1
void wdc_default_write_raw_multi_4(struct channel_softc *,
d163 2
a164 2
wdc_log(struct channel_softc *chp, enum wdcevent_type type,
    unsigned int size, char val[])
d183 1
a183 1
		if (wdc_log_buf == NULL)
d208 1
a208 1

d230 1
a230 1
	if (bytes > *size) {
d289 1
a289 1
	if (reg & _WDC_AUX)
d309 1
a309 1
	if (reg & _WDC_AUX)
d334 1
a334 1
	bus_space_read_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0,
d356 1
a356 1
	bus_space_write_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0,
d378 1
a378 1
	bus_space_write_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0,
d400 1
a400 1
	bus_space_read_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0,
d446 1
a446 1
wdc_set_drive(struct channel_softc *chp, int drive)
d534 1
a534 1
	/*
d541 1
a541 1
	   for any reads to a non-existant slave.
d544 1
a544 1
	    (WDCS_DRDY | WDCS_DSC | WDCS_DRQ),
d554 2
a555 2
		    " %02x\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
d563 2
a564 2
		    " %02x\n",
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
d595 1
a595 1
/*
d641 1
a641 1
		/*
d649 1
a649 1
		if (ret_value == 0)
d654 1
a654 1
	CHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_4BIT);
d696 1
a696 1
	/*
d698 1
a698 1
	 */
d835 1
a835 1
			if ((drvp->drive_flags & DRIVE_OLD) &&
d976 1
a976 1
			bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
d1116 1
a1116 1
			chp->ch_status = status =
d1126 1
a1126 1
			    DEBUG_STATUSX | DEBUG_STATUS);
d1147 1
a1147 1
		else
d1197 1
a1197 1
 * Assumes drvp points to an existing drive.
d1227 1
a1227 1
	if (params->atap_ata_major > 0x01 &&
d1236 1
a1236 1
	} else
d1242 1
a1242 1
	WDCDEBUG_PRINT(("wdc_probe_caps: wdc_cap %d cf_flags %d\n",
d1283 1
a1283 1
	 * It's not in the specs, but it seems that some drive
d1327 1
a1327 1
			/*
d1440 1
a1440 1
		CHP_WRITE_RAW_MULTI_4(chp,
d1498 1
a1498 1
	} else
d1577 1
a1577 1
		/*
d1582 1
a1582 1
		 * corruption is less likely to occur in PIO mode.
d1663 1
a1663 1
{
d1709 1
a1709 1
		wdc_output_bytes(&chp->ch_drive[drive],
d1748 1
a1748 1
		if (irq && (xfer->c_flags & C_TIMEOU) == 0)
d1791 1
a1791 1
		wdc_c->r_precomp = wdc_c->r_error;
d1986 1
a1986 1
__wdcerror(chp, msg)
d1994 2
a1995 2
	else
		printf("%s(%s:%d:%d): %s\n",
d2001 1
a2001 1
/*
d2006 1
a2006 1
	struct channel_softc *chp;
d2197 3
a2199 3
			wi->wi_atareq.sec_count = wdc_c.r_count;
			wi->wi_atareq.features = wdc_c.r_precomp;
			wi->wi_atareq.error = wdc_c.r_error;
@


1.1.1.4
log
@Import OpenBSD source tree again, with critical bug fixes
(OpenSSL, bc, dc, sensorsd, pf, ...)
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.63 2003/09/28 21:01:43 grange Exp $     */
d105 1
a105 1
void  __wdccommand_start(struct channel_softc *, struct wdc_xfer *);
d206 1
a206 1
	*ptr++ = type & 0xff;
d283 1
a283 1
#ifdef DIAGNOSTIC
d303 1
a303 1
#ifdef DIAGNOSTIC
d456 1
a456 1

d509 1
a509 1

d622 1
a622 1
		wdcdebug_mask |= DEBUG_PROBE;
d721 1
a721 1
	return (ret_value);
d803 1
a803 1

d957 1
a957 1

d972 1
a972 1

d1175 1
a1175 1
	}
d1435 1
a1435 1
	unsigned int len = buflen, roundlen;
d1510 1
a1510 1

d1700 1
a1700 1

d2231 1
a2231 1

@


1.1.1.5
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.81 2003/12/16 03:37:37 millert Exp $     */
d102 2
a103 3
void  __wdcerror(struct channel_softc *, char *);
void  __wdcdo_reset(struct channel_softc *);
int   __wdcwait_reset(struct channel_softc *, int);
d110 5
a114 5
#define DEBUG_INTR    0x01
#define DEBUG_XFERS   0x02
#define DEBUG_STATUS  0x04
#define DEBUG_FUNCS   0x08
#define DEBUG_PROBE   0x10
d116 2
a117 2
#define DEBUG_SDRIVE  0x40
#define DEBUG_DETACH  0x80
d120 1
a120 4
#ifndef WDCDEBUG_MASK
#define WDCDEBUG_MASK 0x00
#endif
int wdcdebug_mask = WDCDEBUG_MASK;
d157 3
a159 3
static unsigned int wdc_tail = 0;
static unsigned int wdc_head = 0;
static unsigned int wdc_size = 16 * 1024;
d173 1
a173 2
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head,
		    wdc_tail);
d222 3
a224 3
	int  bytes = (wdc_head - wdc_tail);
	char *retbuf;
	int  ot, c1, c2;
d229 2
a230 3
	if (bytes < 0)
		bytes += wdc_size;
	if ((u_int)bytes > *size) {
d245 1
a245 2
		printf ("wdc_log: wdc_head %x wdc_tail %x\n", wdc_head,
		    wdc_tail);
d251 1
a251 1
	retbuf = malloc(bytes, M_TEMP, M_NOWAIT);
d260 10
a269 10
	ot = wdc_tail;
	wdc_tail += bytes;
	if (wdc_tail > wdc_size) {
		wdc_tail -= wdc_size;
		c2 = wdc_tail;
		c1 = bytes - wdc_tail;
	} else {
		c1 = bytes;
		c2 = 0;
	}
d271 2
a272 2
	memcpy(retbuf, &wdc_log_buf[ot], c1);
	memcpy(&retbuf[c1], &wdc_log_buf[0], c2);
d274 1
a274 1
	return (retbuf);
d325 1
a325 1
		unsigned int i;
d347 1
a347 1
		unsigned int i;
d369 1
a369 1
		unsigned int i;
d391 1
a391 1
		unsigned int i;
d433 1
a433 1
	struct channel_softc *chp;
d435 1
a435 1
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);
d440 1
a440 1
	struct channel_softc *chp;
d442 1
a442 1
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
d533 1
a533 1
retry:
d541 1
a541 1
	   for any reads to a non-existent slave.
d546 1
a546 1
	if (time_to_done == -1) {
d581 1
a581 1
	DELAY(10);
d586 2
a587 2
		    chp->wdc ? chp->wdc->sc_dev.dv_xname : "wdcprobe",
		    chp->channel, drive), DEBUG_PROBE);
d596 3
a598 12
 * Test to see controller with at least one attached drive is there.
 * Returns a bit for each possible drive found (0x01 for drive 0,
 * 0x02 for drive 1).
 * Logic:
 * - If a status register is at 0x7f or 0xff, assume there is no drive here
 *   (ISA has pull-up resistors).  Similarly if the status register has
 *   the value we last wrote to the bus (for IDE interfaces without pullups).
 *   If no drive at all -> return.
 * - reset the controller, wait for it to complete (may take up to 31s !).
 *   If timeout -> return.
 * - test ATA/ATAPI signatures. If at last one drive found -> return.
 * - try an ATA command on the master.
d641 5
a645 1
		if ((st0 & 0x7f) == 0x7f || st0 == WDSD_IBM)
d647 1
a647 1
		if ((st1 & 0x7f) == 0x7f || st1 == (WDSD_IBM | 0x10))
d654 4
a657 1
	__wdcdo_reset(chp);
d686 1
a686 1
		    chp->channel, drive, st0, sc, sn, cl, ch), DEBUG_PROBE);
d821 2
a822 2
		 * Wait a bit, some devices are weird just after a reset.
		 * Then issue a IDENTIFY command, to try to detect slave ghost.
a823 1
		delay(5000);
d826 1
a826 1
			/* If IDENTIFY succeeded, this is not an OLD ctrl */
d868 1
a868 1
	 * reset drive_flags for unattached devices, reset state for attached
d880 1
a880 1
exit:
a987 10
	if (chp->ch_flags & WDCF_DMA_WAIT) {
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, chp->channel,
		    xfer->drive, 0);
		if (chp->wdc->dma_status & WDC_DMAST_NOIRQ) {
			/* IRQ not for us, not detected by DMA engine */
			return 0;
		}
		chp->ch_flags &= ~WDCF_DMA_WAIT;
	}
d989 1
a989 1
	ret = xfer->c_intr(chp, xfer, 1);
d1020 4
a1023 1
	__wdcdo_reset(chp);
d1038 1
a1038 1
	return (drv_mask1 != drv_mask2) ? 1 : 0;
d1041 1
a1041 12
void
__wdcdo_reset(struct channel_softc *chp)
{
	wdc_set_drive(chp, 0);
	DELAY(10);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT | WDCTL_RST);
	delay(10000);
	CHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);
	delay(10000);
}

int
d1047 1
a1047 1
	u_int8_t st0, er0, st1, er1;
a1053 1
		er0 = CHP_READ_REG(chp, wdr_error);
a1056 1
		er1 = CHP_READ_REG(chp, wdr_error);
d1084 2
a1085 2
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%x, er0=0x%x, "
	    "st1=0x%x, er1=0x%x, reset time=%d msec\n",
d1087 1
a1087 1
	    st0, er0, st1, er1, timeout * WDCDELAY / 1000), DEBUG_PROBE);
d1123 2
a1124 2
			WDCDEBUG_PRINT(("wdcwait: timeout, status 0x%x "
			    "error 0x%x\n", status,
a1156 24
/*
 * Busy-wait for DMA to complete
 */
int
wdc_dmawait(chp, xfer, timeout)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
{
	int time;
	for (time = 0; time < timeout * 1000 / WDCDELAY; time++) {
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
		    chp->channel, xfer->drive, 0);
		if ((chp->wdc->dma_status & WDC_DMAST_NOIRQ) == 0)
			return 0;
		delay(WDCDELAY);
	}
	/* timeout, force a DMA halt */
	chp->wdc->dma_status = (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
	    chp->channel, xfer->drive, 1);
	return 1;
}

a1181 6
		if (chp->ch_flags & WDCF_DMA_WAIT) {
			chp->wdc->dma_status =
			    (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
			    chp->channel, xfer->drive, 1);
			chp->ch_flags &= ~WDCF_DMA_WAIT;
		}
d1196 1
a1196 1
 * Probe drive's capabilities, for use by the controller later.
a1209 15
	if ((wdc->cap & WDC_CAPABILITY_SATA) != 0 &&
	    (params->atap_sata_caps != 0x0000 &&
	    params->atap_sata_caps != 0xffff)) {
		WDCDEBUG_PRINT(("%s: atap_sata_caps=0x%x\n", __func__,
		    params->atap_sata_caps), DEBUG_PROBE);

		/* Skip ATA modes detection for native SATA drives */
		drvp->PIO_mode = drvp->PIO_cap = 4;
		drvp->DMA_mode = drvp->DMA_cap = 2;
		drvp->UDMA_mode = drvp->UDMA_cap = 5;
		drvp->drive_flags |= DRIVE_SATA | DRIVE_MODE | DRIVE_UDMA;
		drvp->ata_vers = 4;
		return;
	}

d1242 2
a1243 2
	WDCDEBUG_PRINT(("wdc_probe_caps: wdc_cap 0x%x cf_flags 0x%x\n",
	    wdc->cap, cf_flags), DEBUG_PROBE);
d1257 2
a1258 1
	} else if (params->atap_oldpiotiming > 180) {
d1266 2
d1271 2
d1274 1
a1274 1
			drvp->PIO_cap = 1;
a1281 6
	WDCDEBUG_PRINT(("%s: atap_extensions=0x%x, atap_piomode_supp=0x%x, "
	    "atap_dmamode_supp=0x%x, atap_udmamode_supp=0x%x\n",
	    __func__, params->atap_extensions, params->atap_piomode_supp,
	    params->atap_dmamode_supp, params->atap_udmamode_supp),
	    DEBUG_PROBE);

d1292 1
a1292 1
		 * If higher mode than 7 is found, abort.
d1307 1
a1307 1
			/*
d1313 1
a1313 1
			    at_poll) != CMD_OK)
d1450 1
a1450 1
		CHP_WRITE_RAW_MULTI_2(chp,
d1621 1
a1621 1
	}
d1686 2
a1687 2
		if (wdcwait(chp, wdc_c->r_st_bmask | WDCS_DRQ,
		    wdc_c->r_st_bmask, wdc_c->timeout) != 0) {
d1697 1
a1697 2
		/* wait at least 400ns before reading status register */
		DELAY(10);
d1727 1
a1727 1
timeout:	
d1730 1
d1747 1
a1747 1
	    (irq == 0) ? wdc_c->timeout : 0)) {
d1751 3
a1753 1
		goto out;
d1755 4
a1758 7
	if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
		chp->wdc->irqack(chp);
	if (wdc_c->flags & AT_READ) {
		if ((chp->ch_status & WDCS_DRQ) == 0) {
			wdc_c->flags |= AT_TIMEOU;
			goto out;
		}
a1761 1
out:
d1775 1
a1775 2
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
	    chp->ch_status), DEBUG_FUNCS);
d1783 2
a1784 2
	if ((wdc_c->flags & AT_READREG) != 0 &&
	    (wdc_c->flags & (AT_ERROR | AT_DF)) == 0) {
d1810 1
d1985 1
a1985 1
void
d2134 1
a2134 1
	if ((u_long)bp->b_bcount != wi->wi_atareq.datalen) {
d2301 1
a2301 1
exit:
@


1.1.1.6
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.82 2004/01/23 20:48:33 grange Exp $     */
d653 1
a653 1
		WDCDEBUG_PRINT(("%s:%d: before reset, st0=0x%b, st1=0x%b\n",
d655 1
a655 2
		    chp->channel, st0, WDCS_BITS, st1, WDCS_BITS),
		    DEBUG_PROBE);
d692 1
a692 1
		WDCDEBUG_PRINT(("%s:%d:%d: after reset, st=0x%b, sc=0x%x"
d695 1
a695 2
		    chp->channel, drive, st0, WDCS_BITS, sc, sn, cl, ch),
		    DEBUG_PROBE);
d1114 2
a1115 2
	WDCDEBUG_PRINT(("%s:%d: wdcwait_reset() end, st0=0x%b, er0=0x%x, "
	    "st1=0x%b, er1=0x%x, reset time=%d msec\n",
d1117 1
a1117 2
	    st0, WDCS_BITS, er0, st1, WDCS_BITS, er1,
	    timeout * WDCDELAY / 1000), DEBUG_PROBE);
d1153 2
a1154 2
			WDCDEBUG_PRINT(("wdcwait: timeout, status 0x%b "
			    "error 0x%x\n", status, WDCS_BITS,
@


1.1.1.7
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc.c,v 1.83 2004/02/19 21:16:21 grange Exp $     */
d163 1
a163 1
static unsigned int wdc_log_cap = 16 * 1024;
d171 1
d173 6
a178 9
	int log_size;
	unsigned int head = wdc_head;
	unsigned int tail = wdc_tail;

#ifdef DIAGNOSTIC
	if (head < 0 || head > wdc_log_cap ||
	    tail < 0 || tail > wdc_log_cap) {
		printf ("wdc_log: head %x wdc_tail %x\n", head,
		    tail);
d182 1
a182 1
	if (size > wdc_log_cap / 2) {
a183 1
		return;
a184 1
#endif
d187 1
a187 1
		wdc_log_buf = malloc(wdc_log_cap, M_DEVBUF, M_NOWAIT);
d197 2
a198 2
	log_size = head - tail;
	if (log_size < 0) log_size += wdc_log_cap;
d200 2
a201 12
	if (log_size + request_size >= wdc_log_cap) {
		int nb = 0; 
		int rec_size;

		while (nb <= (request_size * 2)) {
			if (wdc_log_buf[tail] == 0)
				rec_size = 1;
			else
				rec_size = (wdc_log_buf[tail + 1] & 0x1f) + 2;
			tail = (tail + rec_size) % wdc_log_cap;
			nb += rec_size;
		}
d205 3
a207 3
	if (head + request_size >= wdc_log_cap) {
		memset(&wdc_log_buf[head], 0, wdc_log_cap - head);
		head = 0;
d210 1
a210 1
	ptr = &wdc_log_buf[head];
a212 1
	memcpy(ptr, val, size);
d214 6
a219 2
	wdc_head = (head + request_size) % wdc_log_cap;
	wdc_tail = tail;
d227 3
a229 8
	int  log_size;
	char *retbuf = NULL;
	int  nb, tocopy;
	int  s;
	unsigned int head = wdc_head;
	unsigned int tail = wdc_tail;

	s = splbio();
a230 1
	log_size = (head - tail);
d234 8
a241 6
	if (log_size < 0)
		log_size += wdc_log_cap;

	tocopy = log_size;
	if ((u_int)tocopy > *size)
		tocopy = *size;
d246 1
a246 1
		goto out;
d249 4
a252 5
#ifdef DIAGNOSTIC
	if (head < 0 || head > wdc_log_cap ||
	    tail < 0 || tail > wdc_log_cap) {
		printf ("wdc_log: head %x tail %x\n", head,
		    tail);
d255 1
a255 1
		goto out;
a256 1
#endif
d258 1
a258 1
	retbuf = malloc(tocopy, M_TEMP, M_NOWAIT);
d261 2
a262 2
		*left = log_size;
		goto out;
d265 1
a265 11
	nb = 0;
	for (;;) {
		int rec_size;

		if (wdc_log_buf[tail] == 0)
			rec_size = 1;
		else
			rec_size = (wdc_log_buf[tail + 1] & 0x1f) + 2;

		if ((nb + rec_size) >= tocopy)
			break;
d267 9
a275 3
		memcpy(&retbuf[nb], &wdc_log_buf[tail], rec_size);
		tail = (tail + rec_size) % wdc_log_cap;
		nb += rec_size;
d278 2
a279 3
	wdc_tail = tail;
	*size = nb;
	*left = log_size - nb;
a280 2
 out:
	splx(s);
@


