head	1.3;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.3
	tg-mergefixes-1-branch:1.1.1.3.0.8
	tg-mergefixes-1-base:1.1.1.3
	MIROS_X:1.1.1.3.0.6
	MIROS_X_BASE:1.1.1.3
	tg-mergetmp-3:1.1.1.3
	MIRBSD_XP_MIRPPC:1.1.1.3.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.3
	MIRBSD_XP_SPARC:1.1.1.3.0.2
	MIRBSD_7quater:1.2.2.1
	cvs-200405160640:1.1.1.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.2.2.1.0.4
	MIRBSD_7:1.2.2.1.0.2
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.2.2.1
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.2
	cvs-200309271030:1.1.1.2
	cvs-200309261655:1.1.1.2
	cvs-200309251530:1.1.1.2
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	cvs-200307072125:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200307021520:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	cvs-200305131745:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2003.12.17.18.36.50;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.19.20.24.13;	author tg;	state dead;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.03.22.17.51.38;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.51.38;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.06.29.17.33.42;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.16.09.04.14;	author tg;	state Stab;
branches;
next	;

1.2.2.1
date	2003.10.25.22.47.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@second (piecewise) attempt to merge MirBSD #7ter into HEAD
@
text
@/*	$OpenBSD: stp4020.c,v 1.10 2003/06/25 22:49:06 mickey Exp $	*/
/*	$NetBSD: stp4020.c,v 1.23 2002/06/01 23:51:03 lukem Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * STP4020: SBus/PCMCIA bridge supporting two Type-3 PCMCIA cards.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/extent.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/device.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciachip.h>

#include <machine/bus.h>

#include <dev/sbus/stp4020reg.h>
#include <dev/sbus/stp4020var.h>

/*
 * We use the three available windows per socket in a simple, fixed
 * arrangement. Each window maps (at full 1 MB size) one of the pcmcia
 * spaces into sbus space.
 */
#define STP_WIN_ATTR	0	/* index of the attribute memory space window */
#define	STP_WIN_MEM	1	/* index of the common memory space window */
#define	STP_WIN_IO	2	/* index of the io space window */

#ifdef STP4020_DEBUG
int stp4020_debug = 0;
#define DPRINTF(x)	do { if (stp4020_debug) printf x; } while(0)
#else
#define DPRINTF(x)
#endif

/*
 * Event queue; events detected in an interrupt context go here
 * awaiting attention from our event handling thread.
 */
struct stp4020_event {
	SIMPLEQ_ENTRY(stp4020_event) se_q;
	int	se_type;
	int	se_sock;
};

/* Defined event types */
#define STP4020_EVENT_INSERTION	0
#define STP4020_EVENT_REMOVAL	1

int	stp4020print(void *, const char *);
void	stp4020_map_window(struct stp4020_socket *, int, int);
void	stp4020_calc_speed(int, int, int *, int *);

struct	cfdriver stp_cd = {
	NULL, "stp", DV_DULL
};

#ifdef STP4020_DEBUG
static void	stp4020_dump_regs(struct stp4020_socket *);
#endif

static u_int16_t stp4020_rd_sockctl(struct stp4020_socket *, int);
static void	stp4020_wr_sockctl(struct stp4020_socket *, int, u_int16_t);
static u_int16_t stp4020_rd_winctl(struct stp4020_socket *, int, int);
static void	stp4020_wr_winctl(struct stp4020_socket *, int, int, u_int16_t);

void	stp4020_delay(unsigned int);
void	stp4020_attach_socket(struct stp4020_socket *, int);
void	stp4020_create_event_thread(void *);
void	stp4020_event_thread(void *);
void	stp4020_queue_event(struct stp4020_softc *, int, int);

int	stp4020_chip_mem_alloc(pcmcia_chipset_handle_t, bus_size_t,
	    struct pcmcia_mem_handle *);
void	stp4020_chip_mem_free(pcmcia_chipset_handle_t,
	    struct pcmcia_mem_handle *);
int	stp4020_chip_mem_map(pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *);
void	stp4020_chip_mem_unmap(pcmcia_chipset_handle_t, int);

int	stp4020_chip_io_alloc(pcmcia_chipset_handle_t,
	    bus_addr_t, bus_size_t, bus_size_t, struct pcmcia_io_handle *);
void	stp4020_chip_io_free(pcmcia_chipset_handle_t,
	    struct pcmcia_io_handle *);
int	stp4020_chip_io_map(pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_io_handle *, int *);
void	stp4020_chip_io_unmap(pcmcia_chipset_handle_t, int);

void	stp4020_chip_socket_enable(pcmcia_chipset_handle_t);
void	stp4020_chip_socket_disable(pcmcia_chipset_handle_t);
void	*stp4020_chip_intr_establish(pcmcia_chipset_handle_t,
	    struct pcmcia_function *, int, int (*) (void *), void *, char *);
void	stp4020_chip_intr_disestablish(pcmcia_chipset_handle_t, void *);

/* Our PCMCIA chipset methods */
static struct pcmcia_chip_functions stp4020_functions = {
	stp4020_chip_mem_alloc,
	stp4020_chip_mem_free,
	stp4020_chip_mem_map,
	stp4020_chip_mem_unmap,

	stp4020_chip_io_alloc,
	stp4020_chip_io_free,
	stp4020_chip_io_map,
	stp4020_chip_io_unmap,

	stp4020_chip_intr_establish,
	stp4020_chip_intr_disestablish,

	stp4020_chip_socket_enable,
	stp4020_chip_socket_disable
};


static __inline__ u_int16_t
stp4020_rd_sockctl(h, idx)
	struct stp4020_socket *h;
	int idx;
{
	int o = ((STP4020_SOCKREGS_SIZE * (h->sock)) + idx);
	return (bus_space_read_2(h->tag, h->regs, o));
}

static __inline__ void
stp4020_wr_sockctl(h, idx, v)
	struct stp4020_socket *h;
	int idx;
	u_int16_t v;
{
	int o = (STP4020_SOCKREGS_SIZE * (h->sock)) + idx;
	bus_space_write_2(h->tag, h->regs, o, v);
}

static __inline__ u_int16_t
stp4020_rd_winctl(h, win, idx)
	struct stp4020_socket *h;
	int win;
	int idx;
{
	int o = (STP4020_SOCKREGS_SIZE * (h->sock)) +
	    (STP4020_WINREGS_SIZE * win) + idx;
	return (bus_space_read_2(h->tag, h->regs, o));
}

static __inline__ void
stp4020_wr_winctl(h, win, idx, v)
	struct stp4020_socket *h;
	int win;
	int idx;
	u_int16_t v;
{
	int o = (STP4020_SOCKREGS_SIZE * (h->sock)) +
	    (STP4020_WINREGS_SIZE * win) + idx;
	bus_space_write_2(h->tag, h->regs, o, v);
}


int
stp4020print(aux, busname)
	void *aux;
	const char *busname;
{
	struct pcmciabus_attach_args *paa = aux;
	struct stp4020_socket *h = paa->pch;

	printf(" socket %d", h->sock);
	return (UNCONF);
}

/*
 * Attach all the sub-devices we can find
 */
void
stpattach_common(struct stp4020_softc *sc, int clockfreq)
{
	int i, rev;

	rev = stp4020_rd_sockctl(&sc->sc_socks[0], STP4020_ISR1_IDX) &
	    STP4020_ISR1_REV_M;
	printf(": rev %x\n", rev);

	sc->sc_pct = (pcmcia_chipset_tag_t)&stp4020_functions;

	/*
	 * Arrange that a kernel thread be created to handle
	 * insert/removal events.
	 */
	SIMPLEQ_INIT(&sc->events);
	kthread_create_deferred(stp4020_create_event_thread, sc);

	for (i = 0; i < STP4020_NSOCK; i++) {
		struct stp4020_socket *h = &sc->sc_socks[i];
		h->sock = i;
		h->sc = sc;
#ifdef STP4020_DEBUG
		if (stp4020_debug)
			stp4020_dump_regs(h);
#endif
		stp4020_attach_socket(h, clockfreq);
	}
}

void
stp4020_attach_socket(h, speed)
	struct stp4020_socket *h;
	int speed;
{
	struct pcmciabus_attach_args paa;
	int v;

	/* Map all three windows */
	stp4020_map_window(h, STP_WIN_ATTR, speed);
	stp4020_map_window(h, STP_WIN_MEM, speed);
	stp4020_map_window(h, STP_WIN_IO, speed);

	/* Configure one pcmcia device per socket */
	paa.paa_busname = "pcmcia";
	paa.pct = (pcmcia_chipset_tag_t)h->sc->sc_pct;
	paa.pch = (pcmcia_chipset_handle_t)h;
	paa.iobase = 0;
	paa.iosize = STP4020_WINDOW_SIZE;

	h->pcmcia = config_found(&h->sc->sc_dev, &paa, stp4020print);

	if (h->pcmcia == NULL)
		return;

	/*
	 * There's actually a pcmcia bus attached; initialize the slot.
	 */

	/*
	 * Clear things up before we enable status change interrupts.
	 * This seems to not be fully initialized by the PROM.
	 */
	stp4020_wr_sockctl(h, STP4020_ICR1_IDX, 0);
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, 0);
	stp4020_wr_sockctl(h, STP4020_ISR1_IDX, 0x3fff);
	stp4020_wr_sockctl(h, STP4020_ISR0_IDX, 0x3fff);

	/*
	 * Enable socket status change interrupts.
	 * We use SB_INT[1] for status change interrupts.
	 */
	v = STP4020_ICR0_ALL_STATUS_IE | STP4020_ICR0_SCILVL_SB1;
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, v);

	/* Get live status bits from ISR0 */
	v = stp4020_rd_sockctl(h, STP4020_ISR0_IDX);
	if ((v & (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST)) == 0)
		return;

	pcmcia_card_attach(h->pcmcia);
	h->flags |= STP4020_SOCKET_BUSY;
}


/*
 * Deferred thread creation callback.
 */
void
stp4020_create_event_thread(arg)
	void *arg;
{
	struct stp4020_softc *sc = arg;
	const char *name = sc->sc_dev.dv_xname;

	if (kthread_create(stp4020_event_thread, sc, &sc->event_thread,
	    "%s", name)) {
		panic("%s: unable to create event thread", name);
	}
}

/*
 * The actual event handling thread.
 */
void
stp4020_event_thread(arg)
	void *arg;
{
	struct stp4020_softc *sc = arg;
	struct stp4020_event *e;
	int s;

	while (1) {
		struct stp4020_socket *h;
		int n;

		s = splhigh();
		if ((e = SIMPLEQ_FIRST(&sc->events)) == NULL) {
			splx(s);
			(void)tsleep(&sc->events, PWAIT, "pcicev", 0);
			continue;
		}
		SIMPLEQ_REMOVE_HEAD(&sc->events, e, se_q);
		splx(s);

		n = e->se_sock;
		if (n < 0 || n >= STP4020_NSOCK)
			panic("stp4020_event_thread: wayward socket number %d",
			    n);

		h = &sc->sc_socks[n];
		switch (e->se_type) {
		case STP4020_EVENT_INSERTION:
			pcmcia_card_attach(h->pcmcia);
			break;
		case STP4020_EVENT_REMOVAL:
			pcmcia_card_detach(h->pcmcia, DETACH_FORCE);
			break;
		default:
			panic("stp4020_event_thread: unknown event type %d",
			    e->se_type);
		}
		free(e, M_TEMP);
	}
}

void
stp4020_queue_event(sc, sock, event)
	struct stp4020_softc *sc;
	int sock, event;
{
	struct stp4020_event *e;
	int s;

	e = malloc(sizeof(*e), M_TEMP, M_NOWAIT);
	if (e == NULL)
		panic("stp4020_queue_event: can't allocate event");

	e->se_type = event;
	e->se_sock = sock;
	s = splhigh();
	SIMPLEQ_INSERT_TAIL(&sc->events, e, se_q);
	splx(s);
	wakeup(&sc->events);
}

int
stp4020_statintr(arg)
	void *arg;
{
	struct stp4020_softc *sc = arg;
	int i, r = 0;

	/*
	 * Check each socket for pending requests.
	 */
	for (i = 0 ; i < STP4020_NSOCK; i++) {
		struct stp4020_socket *h;
		int v;

		h = &sc->sc_socks[i];

		/* Read socket's ISR0 for the interrupt status bits */
		v = stp4020_rd_sockctl(h, STP4020_ISR0_IDX);

#ifdef STP4020_DEBUG
		if (stp4020_debug != 0)
			printf("stp4020_statintr: ISR0=%b\n",
			    v, STP4020_ISR0_IOBITS);
#endif

		/* Ack all interrupts at once */
		stp4020_wr_sockctl(h, STP4020_ISR0_IDX,
		    STP4020_ISR0_ALL_STATUS_IRQ);

		if ((v & STP4020_ISR0_CDCHG) != 0) {
			/*
			 * Card status change detect
			 */
			r = 1;
			if ((v & (STP4020_ISR0_CD1ST|STP4020_ISR0_CD2ST)) ==
			    (STP4020_ISR0_CD1ST|STP4020_ISR0_CD2ST)) {
				if ((h->flags & STP4020_SOCKET_BUSY) == 0) {
					stp4020_queue_event(sc, i,
					    STP4020_EVENT_INSERTION);
					h->flags |= STP4020_SOCKET_BUSY;
				}
			}
			if ((v & (STP4020_ISR0_CD1ST|STP4020_ISR0_CD2ST)) ==
			    0) {
				if ((h->flags & STP4020_SOCKET_BUSY) != 0) {
					stp4020_queue_event(sc, i,
					    STP4020_EVENT_REMOVAL);
					h->flags &= ~STP4020_SOCKET_BUSY;
				}
			}
		}

		/* informational messages */
		if ((v & STP4020_ISR0_BVD1CHG) != 0) {
			DPRINTF(("stp4020[%d]: Battery change 1\n",
			    h->sock));
			r = 1;
		}

		if ((v & STP4020_ISR0_BVD2CHG) != 0) {
			DPRINTF(("stp4020[%d]: Battery change 2\n",
			    h->sock));
			r = 1;
		}

		if ((v & STP4020_ISR0_RDYCHG) != 0) {
			DPRINTF(("stp4020[%d]: Ready/Busy change\n",
			    h->sock));
			r = 1;
		}

		if ((v & STP4020_ISR0_WPCHG) != 0) {
			DPRINTF(("stp4020[%d]: Write protect change\n",
			    h->sock));
			r = 1;
		}

		if ((v & STP4020_ISR0_PCTO) != 0) {
			DPRINTF(("stp4020[%d]: Card access timeout\n",
			    h->sock));
			r = 1;
		}

		if ((v & STP4020_ISR0_SCINT) != 0) {
			DPRINTF(("stp4020[%d]: Status change\n",
			    h->sock));
			r = 1;
		}

		/*
		 * Not an interrupt flag per se, but interrupts occur when
		 * it is asserted, at least on sparc.
		 */
		if ((v & STP4020_ISR0_WAITST) != 0) {
			DPRINTF(("stp4020[%d]: Wait signal\n",
			    h->sock));
			r = 1;
		}
	}

	return (r);
}

int
stp4020_iointr(arg)
	void *arg;
{
	struct stp4020_softc *sc = arg;
	int i, r = 0;

	/*
	 * Check each socket for pending requests.
	 */
	for (i = 0 ; i < STP4020_NSOCK; i++) {
		struct stp4020_socket *h;
		int v;

		h = &sc->sc_socks[i];
		v = stp4020_rd_sockctl(h, STP4020_ISR0_IDX);

		if ((v & STP4020_ISR0_IOINT) != 0) {
			/* we can not deny this is ours, no matter what the
			   card driver says. */
			r = 1;

			/* ack interrupt */
			stp4020_wr_sockctl(h, STP4020_ISR0_IDX, v);

			/* It's a card interrupt */
			if ((h->flags & STP4020_SOCKET_BUSY) == 0) {
				printf("stp4020[%d]: spurious interrupt?\n",
				    h->sock);
				continue;
			}
			/* Call card handler, if any */
			if (h->intrhandler != NULL) {
				/*
				 * Called without handling of it's requested
				 * protection level (h->ipl), since we have
				 * no general queuing mechanism available
				 * right now and we know for sure we are
				 * running at a higher protection level
				 * right now.
				 */
				(*h->intrhandler)(h->intrarg);
			}
		}

	}

	return (r);
}

/*
 * The function gets the sbus speed and a access time and calculates
 * values for the CMDLNG and CMDDLAY registers.
 */
void
stp4020_calc_speed(int bus_speed, int ns, int *length, int *delay)
{
	int result;

	if (ns < STP4020_MEM_SPEED_MIN)
		ns = STP4020_MEM_SPEED_MIN;
	else if (ns > STP4020_MEM_SPEED_MAX)
		ns = STP4020_MEM_SPEED_MAX;
	result = ns * (bus_speed / 1000);
	if (result % 1000000)
		result = result / 1000000 + 1;
	else
		result /= 1000000;
	*length = result;

	/* the sbus frequency range is limited, so we can keep this simple */
	*delay = ns <= STP4020_MEM_SPEED_MIN ? 1 : 2;
}

void
stp4020_map_window(struct stp4020_socket *h, int win, int speed)
{
	int v, length, delay;

	/*
	 * According to the PC Card standard 300ns access timing should be
	 * used for attribute memory access. Our pcmcia framework does not
	 * seem to propagate timing information, so we use that
	 * everywhere.
	 */
	stp4020_calc_speed(speed, 300, &length, &delay);

	/*
	 * Fill in the Address Space Select and Base Address
	 * fields of this windows control register 0.
	 */
	v = ((delay << STP4020_WCR0_CMDDLY_S) & STP4020_WCR0_CMDDLY_M) |
	    ((length << STP4020_WCR0_CMDLNG_S) & STP4020_WCR0_CMDLNG_M);
	switch (win) {
	case STP_WIN_ATTR:
		v |= STP4020_WCR0_ASPSEL_AM;
		break;
	case STP_WIN_MEM:
		v |= STP4020_WCR0_ASPSEL_CM;
		break;
	case STP_WIN_IO:
		v |= STP4020_WCR0_ASPSEL_IO;
		break;
	}
	v |= (STP4020_ADDR2PAGE(0) & STP4020_WCR0_BASE_M);
	stp4020_wr_winctl(h, win, STP4020_WCR0_IDX, v);
	stp4020_wr_winctl(h, win, STP4020_WCR1_IDX,
	    1 << STP4020_WCR1_WAITREQ_S);
}

int
stp4020_chip_mem_alloc(pch, size, pcmhp)
	pcmcia_chipset_handle_t pch;
	bus_size_t size;
	struct pcmcia_mem_handle *pcmhp;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;

	/* we can not do much here, defere work to _mem_map */
	pcmhp->memt = h->wintag;
	pcmhp->size = size;
	pcmhp->addr = 0;
	pcmhp->mhandle = 0;
	pcmhp->realsize = size;

	return (0);
}

void
stp4020_chip_mem_free(pch, pcmhp)
	pcmcia_chipset_handle_t pch;
	struct pcmcia_mem_handle *pcmhp;
{
}

int
stp4020_chip_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)
	pcmcia_chipset_handle_t pch;
	int kind;
	bus_addr_t card_addr;
	bus_size_t size;
	struct pcmcia_mem_handle *pcmhp;
	bus_addr_t *offsetp;
	int *windowp;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;
	int win = (kind & PCMCIA_MEM_ATTR) ? STP_WIN_ATTR : STP_WIN_MEM;

	pcmhp->memt = h->wintag;
	bus_space_subregion(h->wintag, h->windows[win].winaddr,
	    card_addr, size, &pcmhp->memh);
	pcmhp->size = size;
	pcmhp->realsize = STP4020_WINDOW_SIZE - card_addr;
	*offsetp = 0;
	*windowp = win;

	return (0);
}

void
stp4020_chip_mem_unmap(pch, win)
	pcmcia_chipset_handle_t pch;
	int win;
{
}

int
stp4020_chip_io_alloc(pch, start, size, align, pcihp)
	pcmcia_chipset_handle_t pch;
	bus_addr_t start;
	bus_size_t size;
	bus_size_t align;
	struct pcmcia_io_handle *pcihp;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;

	pcihp->iot = h->wintag;
	pcihp->ioh = h->windows[STP_WIN_IO].winaddr;
	pcihp->size = size;
	return (0);
}

void
stp4020_chip_io_free(pch, pcihp)
	pcmcia_chipset_handle_t pch;
	struct pcmcia_io_handle *pcihp;
{
}

int
stp4020_chip_io_map(pch, width, offset, size, pcihp, windowp)
	pcmcia_chipset_handle_t pch;
	int width;
	bus_addr_t offset;
	bus_size_t size;
	struct pcmcia_io_handle *pcihp;
	int *windowp;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;

	pcihp->iot = h->wintag;
	bus_space_subregion(h->wintag, h->windows[STP_WIN_IO].winaddr,
	    offset, size, &pcihp->ioh);
	*windowp = 0;
	return (0);
}

void
stp4020_chip_io_unmap(pch, win)
	pcmcia_chipset_handle_t pch;
	int win;
{
}

void
stp4020_chip_socket_enable(pch)
	pcmcia_chipset_handle_t pch;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;
	int i, v;

	/* this bit is mostly stolen from pcic_attach_card */

	/* Power down the socket to reset it, clear the card reset pin */
	stp4020_wr_sockctl(h, STP4020_ICR1_IDX, 0);

	/*
	 * wait 300ms until power fails (Tpf).  Then, wait 100ms since
	 * we are changing Vcc (Toff).
	 */
	stp4020_delay((300 + 100) * 1000);

	/* Power up the socket */
	v = STP4020_ICR1_MSTPWR;
	stp4020_wr_sockctl(h, STP4020_ICR1_IDX, v);

	/*
	 * wait 100ms until power raise (Tpr) and 20ms to become
	 * stable (Tsu(Vcc)).
	 *
	 * some machines require some more time to be settled
	 * (another 200ms is added here).
	 */
	stp4020_delay((100 + 20 + 200) * 1000);

	v |= STP4020_ICR1_PCIFOE | STP4020_ICR1_VPP1_VCC;
	stp4020_wr_sockctl(h, STP4020_ICR1_IDX, v);
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, 
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) | STP4020_ICR0_RESET);

	/*
	 * hold RESET at least 20us.
	 */
	delay(20);

	/* Clear reset flag */
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX,
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) & ~STP4020_ICR0_RESET);

	/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */
	stp4020_delay(20000);

	/* Wait for the chip to finish initializing (5 seconds max) */
	for (i = 10000; i > 0; i--) {
		v = stp4020_rd_sockctl(h, STP4020_ISR0_IDX);
		if ((v & STP4020_ISR0_RDYST) != 0)
			break;
		delay(500);
	}
	if (i <= 0) {
#ifdef STP4020_DEBUG
		printf("stp4020_chip_socket_enable: not ready: status %b\n",
		    v, STP4020_ISR0_IOBITS);
#endif
		return;
	}

	v = stp4020_rd_sockctl(h, STP4020_ICR0_IDX);

	/*
	 * Check the card type.
	 * Enable socket I/O interrupts for IO cards.
	 * We use level SB_INT[0] for I/O interrupts.
	 */
	if (pcmcia_card_gettype(h->pcmcia) == PCMCIA_IFTYPE_IO) {
		v &= ~(STP4020_ICR0_IOILVL | STP4020_ICR0_IFTYPE);
		v |= STP4020_ICR0_IFTYPE_IO | STP4020_ICR0_IOIE |
		    STP4020_ICR0_IOILVL_SB0 | STP4020_ICR0_SPKREN;
		DPRINTF(("%s: configuring card for IO usage\n",
		    h->sc->sc_dev.dv_xname));
	} else {
		v &= ~(STP4020_ICR0_IOILVL | STP4020_ICR0_IFTYPE |
		    STP4020_ICR0_SPKREN | STP4020_ICR0_IOILVL_SB0 |
		    STP4020_ICR0_IOILVL_SB1 | STP4020_ICR0_SPKREN);
		v |= STP4020_ICR0_IFTYPE_MEM;
		DPRINTF(("%s: configuring card for MEM ONLY usage\n",
		    h->sc->sc_dev.dv_xname));
	}
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, v);
}

void
stp4020_chip_socket_disable(pch)
	pcmcia_chipset_handle_t pch;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;
	int v;

	/*
	 * Disable socket I/O interrupts.
	 */
	v = stp4020_rd_sockctl(h, STP4020_ICR0_IDX);
	v &= ~(STP4020_ICR0_IOIE | STP4020_ICR0_IOILVL);
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, v);

	/* Power down the socket */
	stp4020_wr_sockctl(h, STP4020_ICR1_IDX, 0);

	/*
	 * wait 300ms until power fails (Tpf).
	 */
	stp4020_delay(300 * 1000);
}

void *
stp4020_chip_intr_establish(pch, pf, ipl, handler, arg, xname)
	pcmcia_chipset_handle_t pch;
	struct pcmcia_function *pf;
	int ipl;
	int (*handler) (void *);
	void *arg;
	char *xname;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;

	h->intrhandler = handler;
	h->intrarg = arg;
	h->ipl = ipl;
	return (h);
}

void
stp4020_chip_intr_disestablish(pch, ih)
	pcmcia_chipset_handle_t pch;
	void *ih;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;

	h->intrhandler = NULL;
	h->intrarg = NULL;
}

/*
 * Delay and possibly yield CPU.
 * XXX - assumes a context
 */
void
stp4020_delay(ms)
	unsigned int ms;
{
	unsigned int ticks;

	/* Convert to ticks */
	ticks = (ms * hz ) / 1000000;

	if (cold || ticks == 0) {
		delay(ms);
		return;
	}

#ifdef DIAGNOSTIC
	if (ticks > 60 * hz)
		panic("stp4020: preposterous delay: %u", ticks);
#endif
	tsleep(&ticks, 0, "stp4020_delay", ticks);
}

#ifdef STP4020_DEBUG
void
stp4020_dump_regs(h)
	struct stp4020_socket *h;
{
	/*
	 * Dump control and status registers.
	 */
	printf("socket[%d] registers:\n"
	    "\tICR0=%b\n\tICR1=%b\n\tISR0=%b\n\tISR1=%x\n", h->sock,
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX), STP4020_ICR0_BITS,
	    stp4020_rd_sockctl(h, STP4020_ICR1_IDX), STP4020_ICR1_BITS,
	    stp4020_rd_sockctl(h, STP4020_ISR0_IDX), STP4020_ISR0_IOBITS,
	    stp4020_rd_sockctl(h, STP4020_ISR1_IDX));
}
#endif /* STP4020_DEBUG */
@


1.2
log
@merge OpenBSD tree; bump MirBSD minor
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.4 2002/06/21 07:55:26 fgsch Exp $	*/
a58 1
#include <machine/intr.h>
a59 1
#include <dev/sbus/sbusvar.h>
d61 1
d72 1
a72 2

#if defined(STP4020_DEBUG)
a92 36
/*
 * Per socket data.
 */
struct stp4020_socket {
	struct stp4020_softc	*sc;	/* Back link */
	int		flags;
#define STP4020_SOCKET_BUSY	0x0001
#define STP4020_SOCKET_SHUTDOWN	0x0002
	int		sock;		/* Socket number (0 or 1) */
	bus_space_tag_t	tag;		/* socket control space */
	bus_space_handle_t	regs;	/* 			*/
	struct device	*pcmcia;	/* Associated PCMCIA device */
	int		(*intrhandler)	/* Card driver interrupt handler */
			    (void *);
	void		*intrarg;	/* Card interrupt handler argument */
	int		ipl;		/* Interrupt level suggested by card */
	struct {
		bus_space_handle_t	winaddr;/* this window's address */
	} windows[STP4020_NWIN];

};

struct stp4020_softc {
	struct device	sc_dev;		/* Base device */
	struct sbusdev	sc_sd;		/* SBus device */
	bus_space_tag_t	sc_bustag;
	bus_dma_tag_t	sc_dmatag;
	pcmcia_chipset_tag_t	sc_pct;	/* Chipset methods */

	struct proc	*event_thread;		/* event handling thread */
	SIMPLEQ_HEAD(, stp4020_event)	events;	/* Pending events for thread */

	struct stp4020_socket sc_socks[STP4020_NSOCK];
};


a93 4
int	stpmatch(struct device *, void *, void *);
void	stpattach(struct device *, struct device *, void *);
int	stp4020_iointr(void *);
int	stp4020_statintr(void *);
d97 1
a97 5
struct cfattach stp_ca = {
	sizeof(struct stp4020_softc), stpmatch, stpattach
};

struct cfdriver stp_cd = {
d105 4
a108 4
static int	stp4020_rd_sockctl(struct stp4020_socket *, int);
static void	stp4020_wr_sockctl(struct stp4020_socket *, int, int);
static int	stp4020_rd_winctl(struct stp4020_socket *, int, int);
static void	stp4020_wr_winctl(struct stp4020_socket *, int, int, int);
d158 1
a158 1
static __inline__ int
d171 1
a171 1
	int v;
d177 1
a177 1
static __inline__ int
d193 1
a193 1
	int v;
a212 11
int
stpmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct sbus_attach_args *sa = aux;

	return (strcmp("SUNW,pcmcia", sa->sa_name) == 0);
}

d217 1
a217 3
stpattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d219 1
a219 79
	struct sbus_attach_args *sa = aux;
	struct stp4020_softc *sc = (void *)self;
	int node, rev;
	int i;
	bus_space_handle_t bh;

	node = sa->sa_node;

	/* Transfer bus tags */
	sc->sc_bustag = sa->sa_bustag;
	sc->sc_dmatag = sa->sa_dmatag;

	/* Set up per-socket static initialization */
	sc->sc_socks[0].sc = sc->sc_socks[1].sc = sc;
	sc->sc_socks[0].tag = sc->sc_socks[1].tag = sa->sa_bustag;

	if (sa->sa_nreg < 8) {
		printf(": only %d register sets\n", sa->sa_nreg);
		return;
	}

	if (sa->sa_nintr != 2) {
		printf(": expect 2 interrupt Sbus levels; got %d\n",
		    sa->sa_nintr);
		return;
	}

#define STP4020_BANK_PROM	0
#define STP4020_BANK_CTRL	4
	for (i = 0; i < 8; i++) {

		/*
		 * STP4020 Register address map:
		 *	bank  0:   Forth PROM
		 *	banks 1-3: socket 0, windows 0-2
		 *	bank  4:   control registers
		 *	banks 5-7: socket 1, windows 0-2
		 */

		if (i == STP4020_BANK_PROM)
			/* Skip the PROM */
			continue;

		if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[i].sbr_slot,
		    sa->sa_reg[i].sbr_offset, sa->sa_reg[i].sbr_size,
		    BUS_SPACE_MAP_LINEAR, 0, &bh) != 0) {
			printf(": attach: cannot map registers\n");
			return;
		}

		if (i == STP4020_BANK_CTRL) {
			/*
			 * Copy tag and handle to both socket structures
			 * for easy access in control/status IO functions.
			 */
			sc->sc_socks[0].regs = sc->sc_socks[1].regs = bh;
		} else if (i < STP4020_BANK_CTRL) {
			/* banks 1-3 */
			sc->sc_socks[0].windows[i-1].winaddr = bh;
		} else {
			/* banks 5-7 */
			sc->sc_socks[1].windows[i-5].winaddr = bh;
		}
	}

	sbus_establish(&sc->sc_sd, &sc->sc_dev);

	/*
	 * We get to use two SBus interrupt levels.
	 * The higher level we use for status change interrupts;
	 * the lower level for PC card I/O.
	 */
	if (sa->sa_nintr != 0) {
		bus_intr_establish(sa->sa_bustag, sa->sa_intr[1].sbi_pri,
		    IPL_NONE, 0, stp4020_statintr, sc);

		bus_intr_establish(sa->sa_bustag, sa->sa_intr[0].sbi_pri,
		    IPL_NONE, 0, stp4020_iointr, sc);
	}
d242 1
a242 1
		stp4020_attach_socket(h, sa->sa_frequency);
d402 3
a404 6
		if (stp4020_debug != 0) {
			char bits[64];
			bitmask_snprintf(v, STP4020_ISR0_IOBITS,
			    bits, sizeof(bits));
			printf("stp4020_statintr: ISR0=%s\n", bits);
		}
d464 16
d529 1
d604 1
a604 1
	pcmhp->memt = h->tag;
d633 2
a634 2
	pcmhp->memt = h->tag;
	bus_space_subregion(h->tag, h->windows[win].winaddr,
d639 1
a639 1
	*windowp = 0;
d661 1
a661 1
	pcihp->iot = h->tag;
d685 2
a686 2
	pcihp->iot = h->tag;
	bus_space_subregion(h->tag, h->windows[STP_WIN_IO].winaddr,
d724 3
d728 1
a728 1
	stp4020_delay((100 + 20) * 1000);
d732 2
d736 1
a736 1
	 * hold RESET at least 10us.
d738 1
a738 1
	delay(10);
d741 2
a742 3
	v = stp4020_rd_sockctl(h, STP4020_ICR0_IDX);
	v &= ~STP4020_ICR0_RESET;
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, v);
d755 3
a757 6
#if STP4020_DEBUG
		char bits[64];
		bitmask_snprintf(stp4020_rd_sockctl(h, STP4020_ISR0_IDX),
		    STP4020_ISR0_IOBITS, bits, sizeof(bits));
		printf("stp4020_chip_socket_enable: not ready: status %s\n",
		    bits);
a866 1
	char bits[64];
d870 6
a875 16
	printf("socket[%d] registers:\n", h->sock);
	bitmask_snprintf(stp4020_rd_sockctl(h, STP4020_ICR0_IDX),
	    STP4020_ICR0_BITS, bits, sizeof(bits));
	printf("\tICR0=%s\n", bits);

	bitmask_snprintf(stp4020_rd_sockctl(h, STP4020_ICR1_IDX),
	    STP4020_ICR1_BITS, bits, sizeof(bits));
	printf("\tICR1=%s\n", bits);

	bitmask_snprintf(stp4020_rd_sockctl(h, STP4020_ISR0_IDX),
	    STP4020_ISR0_IOBITS, bits, sizeof(bits));
	printf("\tISR0=%s\n", bits);

	bitmask_snprintf(stp4020_rd_sockctl(h, STP4020_ISR1_IDX),
	    STP4020_ISR1_BITS, bits, sizeof(bits));
	printf("\tISR1=%s\n", bits);
@


1.2.2.1
log
@fix sparc builds even more (kernel time):
* some emulation doesn't exist
* bring back to live some files
* update tty-related stuff...

root@@demoscene:/root # ll /bsd;uname -ap
-r--r--r--  1 root  wheel  2915123 Oct 25 22:20 /bsd
OpenBSD demoscene.66h.42h.de 3.4 GENERIC#0 sparc SUNW,SPARCstation-20, TMS390Z50 v0 or TMS390Z55 @@ 50 MHz, on-chip FPU
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.10 2003/06/25 22:49:06 mickey Exp $	*/
d59 1
d61 1
a62 1
#include <dev/sbus/stp4020var.h>
d73 2
a74 1
#ifdef STP4020_DEBUG
d95 36
d132 4
d139 5
a143 1
struct	cfdriver stp_cd = {
d151 4
a154 4
static u_int16_t stp4020_rd_sockctl(struct stp4020_socket *, int);
static void	stp4020_wr_sockctl(struct stp4020_socket *, int, u_int16_t);
static u_int16_t stp4020_rd_winctl(struct stp4020_socket *, int, int);
static void	stp4020_wr_winctl(struct stp4020_socket *, int, int, u_int16_t);
d204 1
a204 1
static __inline__ u_int16_t
d217 1
a217 1
	u_int16_t v;
d223 1
a223 1
static __inline__ u_int16_t
d239 1
a239 1
	u_int16_t v;
d259 11
d274 3
a276 1
stpattach_common(struct stp4020_softc *sc, int clockfreq)
d278 79
a356 1
	int i, rev;
d379 1
a379 1
		stp4020_attach_socket(h, clockfreq);
d539 6
a544 3
		if (stp4020_debug != 0)
			printf("stp4020_statintr: ISR0=%b\n",
			    v, STP4020_ISR0_IOBITS);
a603 16

		if ((v & STP4020_ISR0_SCINT) != 0) {
			DPRINTF(("stp4020[%d]: Status change\n",
			    h->sock));
			r = 1;
		}

		/*
		 * Not an interrupt flag per se, but interrupts occur when
		 * it is asserted, at least on sparc.
		 */
		if ((v & STP4020_ISR0_WAITST) != 0) {
			DPRINTF(("stp4020[%d]: Wait signal\n",
			    h->sock));
			r = 1;
		}
a652 1

d727 1
a727 1
	pcmhp->memt = h->wintag;
d756 2
a757 2
	pcmhp->memt = h->wintag;
	bus_space_subregion(h->wintag, h->windows[win].winaddr,
d762 1
a762 1
	*windowp = win;
d784 1
a784 1
	pcihp->iot = h->wintag;
d808 2
a809 2
	pcihp->iot = h->wintag;
	bus_space_subregion(h->wintag, h->windows[STP_WIN_IO].winaddr,
a846 3
	 *
	 * some machines require some more time to be settled
	 * (another 200ms is added here).
d848 1
a848 1
	stp4020_delay((100 + 20 + 200) * 1000);
a851 2
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, 
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) | STP4020_ICR0_RESET);
d854 1
a854 1
	 * hold RESET at least 20us.
d856 1
a856 1
	delay(20);
d859 3
a861 2
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX,
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) & ~STP4020_ICR0_RESET);
d874 6
a879 3
#ifdef STP4020_DEBUG
		printf("stp4020_chip_socket_enable: not ready: status %b\n",
		    v, STP4020_ISR0_IOBITS);
d989 1
d993 16
a1008 6
	printf("socket[%d] registers:\n"
	    "\tICR0=%b\n\tICR1=%b\n\tISR0=%b\n\tISR1=%x\n", h->sock,
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX), STP4020_ICR0_BITS,
	    stp4020_rd_sockctl(h, STP4020_ICR1_IDX), STP4020_ICR1_BITS,
	    stp4020_rd_sockctl(h, STP4020_ISR0_IDX), STP4020_ISR0_IOBITS,
	    stp4020_rd_sockctl(h, STP4020_ISR1_IDX));
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.10 2003/06/25 22:49:06 mickey Exp $	*/
d59 1
d61 1
a62 1
#include <dev/sbus/stp4020var.h>
d73 2
a74 1
#ifdef STP4020_DEBUG
d95 36
d132 4
d139 5
a143 1
struct	cfdriver stp_cd = {
d151 4
a154 4
static u_int16_t stp4020_rd_sockctl(struct stp4020_socket *, int);
static void	stp4020_wr_sockctl(struct stp4020_socket *, int, u_int16_t);
static u_int16_t stp4020_rd_winctl(struct stp4020_socket *, int, int);
static void	stp4020_wr_winctl(struct stp4020_socket *, int, int, u_int16_t);
d204 1
a204 1
static __inline__ u_int16_t
d217 1
a217 1
	u_int16_t v;
d223 1
a223 1
static __inline__ u_int16_t
d239 1
a239 1
	u_int16_t v;
d259 11
d274 3
a276 1
stpattach_common(struct stp4020_softc *sc, int clockfreq)
d278 79
a356 1
	int i, rev;
d379 1
a379 1
		stp4020_attach_socket(h, clockfreq);
d539 6
a544 3
		if (stp4020_debug != 0)
			printf("stp4020_statintr: ISR0=%b\n",
			    v, STP4020_ISR0_IOBITS);
a603 16

		if ((v & STP4020_ISR0_SCINT) != 0) {
			DPRINTF(("stp4020[%d]: Status change\n",
			    h->sock));
			r = 1;
		}

		/*
		 * Not an interrupt flag per se, but interrupts occur when
		 * it is asserted, at least on sparc.
		 */
		if ((v & STP4020_ISR0_WAITST) != 0) {
			DPRINTF(("stp4020[%d]: Wait signal\n",
			    h->sock));
			r = 1;
		}
a652 1

d727 1
a727 1
	pcmhp->memt = h->wintag;
d756 2
a757 2
	pcmhp->memt = h->wintag;
	bus_space_subregion(h->wintag, h->windows[win].winaddr,
d762 1
a762 1
	*windowp = win;
d784 1
a784 1
	pcihp->iot = h->wintag;
d808 2
a809 2
	pcihp->iot = h->wintag;
	bus_space_subregion(h->wintag, h->windows[STP_WIN_IO].winaddr,
a846 3
	 *
	 * some machines require some more time to be settled
	 * (another 200ms is added here).
d848 1
a848 1
	stp4020_delay((100 + 20 + 200) * 1000);
a851 2
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, 
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) | STP4020_ICR0_RESET);
d854 1
a854 1
	 * hold RESET at least 20us.
d856 1
a856 1
	delay(20);
d859 3
a861 2
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX,
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) & ~STP4020_ICR0_RESET);
d874 6
a879 3
#ifdef STP4020_DEBUG
		printf("stp4020_chip_socket_enable: not ready: status %b\n",
		    v, STP4020_ISR0_IOBITS);
d989 1
d993 16
a1008 6
	printf("socket[%d] registers:\n"
	    "\tICR0=%b\n\tICR1=%b\n\tISR0=%b\n\tISR1=%x\n", h->sock,
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX), STP4020_ICR0_BITS,
	    stp4020_rd_sockctl(h, STP4020_ICR1_IDX), STP4020_ICR1_BITS,
	    stp4020_rd_sockctl(h, STP4020_ISR0_IDX), STP4020_ISR0_IOBITS,
	    stp4020_rd_sockctl(h, STP4020_ISR1_IDX));
@


1.1.1.3
log
@large-scale import of OpenBSD 3.5-current source base including many fixes
note: from now, we will not be binary compatible with OpenBSD apps any
longer (due to syscall numbering differences); both an OpenBSD compat and
a conversion tool for old MirOS #7 apps will be delivered later.

The src/ tree is locked from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.12 2004/03/03 21:47:39 miod Exp $	*/
d41 1
a41 2
 * STP4020: SBus/PCMCIA bridge supporting one Type-3 PCMCIA card, or up to
 * two Type-1 and Type-2 PCMCIA cards..
d47 1
d79 14
d114 1
a114 1
void	stp4020_queue_event(struct stp4020_softc *, int);
d231 1
a231 1
	sc->events = 0;
d293 5
a297 5
	h->sense = v & (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST);
	if (h->sense != 0) {
		h->flags |= STP4020_SOCKET_BUSY;
		pcmcia_card_attach(h->pcmcia);
	}
d325 2
a326 2
	int s, sense;
	unsigned int socket;
d328 1
a328 1
	for (;;) {
d330 1
d333 1
a333 1
		if ((socket = ffs(sc->events)) == 0) {
d335 1
a335 1
			(void)tsleep(&sc->events, PWAIT, "stp4020_ev", 0);
d338 1
a338 2
		socket--;
		sc->events &= ~(1 << socket);
d341 16
a356 34
		if (socket >= STP4020_NSOCK) {
#ifdef DEBUG
			printf("stp4020_event_thread: wayward socket number %d\n",
			    socket);
#endif
			continue;
		}

		h = &sc->sc_socks[socket];

		/* Read socket's ISR0 for the interrupt status bits */
		sense = stp4020_rd_sockctl(h, STP4020_ISR0_IDX) &
		    (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST);

		if (sense > h->sense) {
			/*
			 * If at least one more sensor is asserted, this is
			 * a card insertion.
			 */
			h->sense = sense;
			if ((h->flags & STP4020_SOCKET_BUSY) == 0) {
				h->flags |= STP4020_SOCKET_BUSY;
				pcmcia_card_attach(h->pcmcia);
			}
		} else if (sense < h->sense) {
			/*
			 * If at least one less sensor is asserted, this is
			 * a card removal.
			 */
			h->sense = sense;
			if (h->flags & STP4020_SOCKET_BUSY) {
				h->flags &= ~STP4020_SOCKET_BUSY;
				pcmcia_card_detach(h->pcmcia, DETACH_FORCE);
			}
d358 1
d363 1
a363 1
stp4020_queue_event(sc, sock)
d365 1
a365 1
	int sock;
d367 1
d370 6
d377 1
a377 1
	sc->events |= (1 << sock);
d387 1
a387 1
	int i, sense, r = 0;
a399 1
		sense = v & (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST);
a411 2
			r = 1;

d413 1
a413 11
			 * Card detect status changed. In an ideal world,
			 * both card detect sensors should be set if a card
			 * is in the slot, and clear if it is not.
			 *
			 * Unfortunately, it turns out that we can get the
			 * notification before both sensors are set (or
			 * clear).
			 *
			 * This can be very funny if only one sensor is set.
			 * Is this a removal or an insertion operation?
			 * Defer appropriate action to the worker thread.
d415 17
a431 3
			if (sense != h->sense)
				stp4020_queue_event(sc, i);

d472 2
a473 2
		 * Not interrupts flag per se, but interrupts can occur when
		 * they are asserted, at least during our slot enable routine.
d475 3
a477 2
		if ((h->flags & STP4020_SOCKET_ENABLING) &&
		    (v & (STP4020_ISR0_WAITST | STP4020_ISR0_PWRON)))
d479 1
d519 6
a524 4
				 * We ought to be at an higher ipl level
				 * than the callback, since the first
				 * interrupt of this device is usually
				 * higher than IPL_CLOCK.
a525 1
				splassert(h->ipl);
a705 2
	h->flags |= STP4020_SOCKET_ENABLING;

d732 2
a737 2
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, 
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) | STP4020_ICR0_RESET);
d739 2
a749 5
		/* If the card has been removed, abort */
		if ((v & (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST)) == 0) {
			h->flags &= ~STP4020_SOCKET_ENABLING;
			return;
		}
a758 1
		h->flags &= ~STP4020_SOCKET_ENABLING;
d777 2
a778 1
		    STP4020_ICR0_SPKREN | STP4020_ICR0_IOIE);
a783 2

	h->flags &= ~STP4020_SOCKET_ENABLING;
d797 1
a797 2
	v &= ~(STP4020_ICR0_IOILVL | STP4020_ICR0_IFTYPE |
	    STP4020_ICR0_SPKREN | STP4020_ICR0_IOIE);
d848 1
a848 1
	ticks = (ms * hz) / 1000000;
d855 1
a855 1
#ifdef DEBUG
@


