head	1.3;
branch	1.1.1;
access;
symbols
	tg-mergetmp-mirosx-1:1.1.1.6
	tg-mergefixes-1-branch:1.1.1.6.0.8
	tg-mergefixes-1-base:1.1.1.6
	MIROS_X:1.1.1.6.0.6
	MIROS_X_BASE:1.1.1.6
	tg-mergetmp-3:1.1.1.6
	MIRBSD_XP_MIRPPC:1.1.1.6.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.6
	MIRBSD_XP_SPARC:1.1.1.6.0.2
	MIRBSD_7quater:1.2.2.1
	cvs-200405160640:1.1.1.6
	cvs-200401271800:1.1.1.6
	cvs-200401261630:1.1.1.6
	cvs-200401021645:1.1.1.6
	MIRBSD_7_ALPHA:1.2.2.1.0.4
	MIRBSD_7:1.2.2.1.0.2
	cvs-200312222040:1.1.1.6
	MIRBSD_7ter:1.2.2.1
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.6
	cvs-200309271030:1.1.1.6
	cvs-200309261655:1.1.1.6
	cvs-200309251530:1.1.1.6
	cvs-200308302005:1.1.1.6
	cvs-200308171200:1.1.1.6
	ctm-3496:1.1.1.6
	ctm-3449:1.1.1.6
	ctm-3437:1.1.1.6
	cvs-200307191805:1.1.1.6
	ctm-3425:1.1.1.6
	cvs-200307091500:1.1.1.6
	cvs-200307072125:1.1.1.6
	ctm-3389:1.1.1.6
	cvs-200307021520:1.1.1.5
	cvs-200306291430:1.1.1.5
	ctm-3341:1.1.1.4
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.2
	cvs-200305131745:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	ctm-3255:1.1.1.2
	ctm-3229:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-3203:1.1.1.2
	cvs-20030410-1130:1.1.1.2
	ctm-3155:1.1.1.2
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2003.12.17.18.34.06;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.19.20.24.12;	author tg;	state dead;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.03.22.17.51.37;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.51.37;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.03.29.19.47.19;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.06.05.17.39.52;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.06.19.12.50.11;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.06.29.17.33.37;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.07.06.15.47.49;	author tg;	state Stab;
branches;
next	;

1.2.2.1
date	2003.10.25.22.47.23;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@second (piecewise) attempt to merge MirBSD #7ter into HEAD
@
text
@/*	$OpenBSD: cgsix.c,v 1.44 2003/07/03 21:02:13 jason Exp $	*/

/*
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>

#include <dev/sbus/sbusvar.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>
#include <dev/sbus/cgsixreg.h>
#include <dev/ic/bt458reg.h>

struct wsscreen_descr cgsix_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgsix_scrlist[] = {
	&cgsix_stdscreen,
	/* XXX other formats? */
};

struct wsscreen_list cgsix_screenlist = {
	sizeof(cgsix_scrlist) / sizeof(struct wsscreen_descr *), cgsix_scrlist
};

int cgsix_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgsix_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgsix_free_screen(void *, void *);
int cgsix_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgsix_mmap(void *, off_t, int);
int cgsix_is_console(int);
int cg6_bt_getcmap(union bt_cmap *, struct wsdisplay_cmap *);
int cg6_bt_putcmap(union bt_cmap *, struct wsdisplay_cmap *);
void cgsix_loadcmap_immediate(struct cgsix_softc *, u_int, u_int);
void cgsix_loadcmap_deferred(struct cgsix_softc *, u_int, u_int);
void cgsix_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void cgsix_reset(struct cgsix_softc *, u_int32_t);
void cgsix_hardreset(struct cgsix_softc *);
void cgsix_burner(void *, u_int, u_int);
int cgsix_intr(void *);
void cgsix_ras_init(struct cgsix_softc *);
void cgsix_ras_copyrows(void *, int, int, int);
void cgsix_ras_copycols(void *, int, int, int, int);
void cgsix_ras_erasecols(void *, int, int, int, long int);
void cgsix_ras_eraserows(void *, int, int, long int);
void cgsix_ras_do_cursor(struct rasops_info *);
void cgsix_ras_updatecursor(struct rasops_info *);
int cgsix_setcursor(struct cgsix_softc *, struct wsdisplay_cursor *);
int cgsix_updatecursor(struct cgsix_softc *, u_int);

struct wsdisplay_accessops cgsix_accessops = {
	cgsix_ioctl,
	cgsix_mmap,
	cgsix_alloc_screen,
	cgsix_free_screen,
	cgsix_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgsix_burner,
};

int	cgsixmatch(struct device *, void *, void *);
void	cgsixattach(struct device *, struct device *, void *);

struct cfattach cgsix_ca = {
	sizeof (struct cgsix_softc), cgsixmatch, cgsixattach
};

struct cfdriver cgsix_cd = {
	NULL, "cgsix", DV_DULL
};

int
cgsixmatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct sbus_attach_args *sa = aux;

	return (strcmp(cf->cf_driver->cd_name, sa->sa_name) == 0);
}

void    
cgsixattach(struct device *parent, struct device *self, void *aux)
{
	struct cgsix_softc *sc = (struct cgsix_softc *)self;
	struct sbus_attach_args *sa = aux;
	struct wsemuldisplaydev_attach_args waa;
	int console, i;
	u_int32_t fhc, rev;

	sc->sc_bustag = sa->sa_bustag;
	sc->sc_paddr = sbus_bus_addr(sa->sa_bustag, sa->sa_slot, sa->sa_offset);

	if (sa->sa_nreg != 1) {
		printf(": expected %d registers, got %d\n", 1, sa->sa_nreg);
		goto fail;
	}

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, sa->sa_node, 0);

	/*
	 * Map just BT, FHC, FBC, THC, and video RAM.
	 */
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_BT_OFFSET,
	    CGSIX_BT_SIZE, 0, 0, &sc->sc_bt_regs) != 0) {
		printf(": cannot map bt registers\n");
		goto fail_bt;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_FHC_OFFSET,
	    CGSIX_FHC_SIZE, 0, 0, &sc->sc_fhc_regs) != 0) {
		printf(": cannot map fhc registers\n");
		goto fail_fhc;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_THC_OFFSET,
	    CGSIX_THC_SIZE, 0, 0, &sc->sc_thc_regs) != 0) {
		printf(": cannot map thc registers\n");
		goto fail_thc;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_VID_OFFSET,
	    sc->sc_sunfb.sf_fbsize, BUS_SPACE_MAP_LINEAR,
	    0, &sc->sc_vid_regs) != 0) {
		printf(": cannot map vid registers\n");
		goto fail_vid;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_TEC_OFFSET,
	    CGSIX_TEC_SIZE, 0, 0, &sc->sc_tec_regs) != 0) {
		printf(": cannot map tec registers\n");
		goto fail_tec;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_FBC_OFFSET,
	    CGSIX_FBC_SIZE, 0, 0, &sc->sc_fbc_regs) != 0) {
		printf(": cannot map fbc registers\n");
		goto fail_fbc;
	}

	if ((sc->sc_ih = bus_intr_establish(sa->sa_bustag, sa->sa_pri,
	    IPL_TTY, 0, cgsix_intr, sc, self->dv_xname)) == NULL) {
		printf(": couldn't establish interrupt, pri %d\n", sa->sa_pri);
		goto fail_intr;
	}

	/* if prom didn't initialize us, do it the hard way */
	if (OF_getproplen(sa->sa_node, "width") != sizeof(u_int32_t))
		cgsix_hardreset(sc);

	console = cgsix_is_console(sa->sa_node);

	fhc = FHC_READ(sc);
	rev = (fhc & FHC_REV_MASK) >> FHC_REV_SHIFT;
	cgsix_reset(sc, rev);

	/* grab the current palette */
	BT_WRITE(sc, BT_ADDR, 0);
	for (i = 0; i < 256; i++) {
		sc->sc_cmap.cm_map[i][0] = BT_READ(sc, BT_CMAP) >> 24;
		sc->sc_cmap.cm_map[i][1] = BT_READ(sc, BT_CMAP) >> 24;
		sc->sc_cmap.cm_map[i][2] = BT_READ(sc, BT_CMAP) >> 24;
	}

	cgsix_burner(sc, 1, 0);

	sbus_establish(&sc->sc_sd, self);

	sc->sc_sunfb.sf_ro.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
	    sc->sc_vid_regs);
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, console ? 0 : RI_CLEAR);

	/*
	 * Old rev. cg6 cards do not like the current acceleration code.
	 *
	 * Some hints from Sun point out at timing and cache problems, which
	 * will be investigated later.
	 */
	if (rev < 5)
		sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags |= CG6_CFFLAG_NOACCEL;

	if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL)
	    == 0) {
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_sunfb.sf_ro.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_do_cursor = cgsix_ras_do_cursor;
		cgsix_ras_init(sc);
	}

	cgsix_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgsix_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

	printf("\n");

	fbwscons_setcolormap(&sc->sc_sunfb, cgsix_setcolor);

	if (console) {
		sc->sc_sunfb.sf_ro.ri_updatecursor = cgsix_ras_updatecursor;
		fbwscons_console_init(&sc->sc_sunfb, &cgsix_stdscreen, -1,
		    cgsix_burner);
	}

	waa.console = console;
	waa.scrdata = &cgsix_screenlist;
	waa.accessops = &cgsix_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);

	return;

fail_intr:
	bus_space_unmap(sa->sa_bustag, sc->sc_fbc_regs, CGSIX_FBC_SIZE);
fail_fbc:
	bus_space_unmap(sa->sa_bustag, sc->sc_tec_regs, CGSIX_TEC_SIZE);
fail_tec:
	bus_space_unmap(sa->sa_bustag, sc->sc_vid_regs, CGSIX_VID_SIZE);
fail_vid:
	bus_space_unmap(sa->sa_bustag, sc->sc_thc_regs, CGSIX_THC_SIZE);
fail_thc:
	bus_space_unmap(sa->sa_bustag, sc->sc_fhc_regs, CGSIX_FHC_SIZE);
fail_fhc:
	bus_space_unmap(sa->sa_bustag, sc->sc_bt_regs, CGSIX_BT_SIZE);
fail_bt:
fail:
;
}

int
cgsix_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct cgsix_softc *sc = v;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cursor *curs;
	struct wsdisplay_curpos *pos;
	u_char r[2], g[2], b[2];
	int error, s;
	u_int mode;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG6;
		break;
	case WSDISPLAYIO_SMODE:
		mode = *(u_int *)data;
		if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags &
		    CG6_CFFLAG_NOACCEL) == 0) {
			if (sc->sc_mode != WSDISPLAYIO_MODE_EMUL &&
			    mode == WSDISPLAYIO_MODE_EMUL)
				cgsix_ras_init(sc);
		}
		sc->sc_mode = mode;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (void *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cg6_bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		break;
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cg6_bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		cgsix_loadcmap_deferred(sc, cm->index, cm->count);
		break;
	case WSDISPLAYIO_SCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		return (cgsix_setcursor(sc, curs));
	case WSDISPLAYIO_GCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		if (curs->which & WSDISPLAY_CURSOR_DOCUR)
			curs->enable = sc->sc_curs_enabled;
		if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
			curs->pos.x = sc->sc_curs_pos.x;
			curs->pos.y = sc->sc_curs_pos.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
			curs->hot.x = sc->sc_curs_hot.x;
			curs->hot.y = sc->sc_curs_hot.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
			curs->cmap.index = 0;
			curs->cmap.count = 2;
			r[0] = sc->sc_curs_fg >> 16;
			g[0] = sc->sc_curs_fg >> 8;
			b[0] = sc->sc_curs_fg >> 0;
			r[1] = sc->sc_curs_bg >> 16;
			g[1] = sc->sc_curs_bg >> 8;
			b[1] = sc->sc_curs_bg >> 0;
			error = copyout(r, curs->cmap.red, sizeof(r));
			if (error)
				return (error);
			error = copyout(g, curs->cmap.green, sizeof(g));
			if (error)
				return (error);
			error = copyout(b, curs->cmap.blue, sizeof(b));
			if (error)
				return (error);
		}
		if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
			size_t l;

			curs->size.x = sc->sc_curs_size.x;
			curs->size.y = sc->sc_curs_size.y;
			l = (sc->sc_curs_size.x * sc->sc_curs_size.y) / NBBY;
			error = copyout(sc->sc_curs_image, curs->image, l);
			if (error)
				return (error);
			error = copyout(sc->sc_curs_mask, curs->mask, l);
			if (error)
				return (error);
		}
		break;
	case WSDISPLAYIO_GCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = sc->sc_curs_pos.x;
		pos->y = sc->sc_curs_pos.y;
		break;
	case WSDISPLAYIO_SCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		s = spltty();
		sc->sc_curs_pos.x = pos->x;
		sc->sc_curs_pos.y = pos->y;
		cgsix_updatecursor(sc, WSDISPLAY_CURSOR_DOPOS);
		splx(s);
		break;
	case WSDISPLAYIO_GCURMAX:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = pos->y = 32;
		break;
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	default:
		return -1; /* not supported */
        }

	return (0);
}

int
cgsix_setcursor(struct cgsix_softc *sc, struct wsdisplay_cursor *curs)
{
	u_int8_t r[2], g[2], b[2], image[128], mask[128];
	int s, error;
	size_t imcount;

	/*
	 * Do stuff that can generate errors first, then we'll blast it
	 * all at once.
	 */
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		if (curs->cmap.count < 2)
			return (EINVAL);
		error = copyin(curs->cmap.red, r, sizeof(r));
		if (error)
			return (error);
		error = copyin(curs->cmap.green, g, sizeof(g));
		if (error)
			return (error);
		error = copyin(curs->cmap.blue, b, sizeof(b));
		if (error)
			return (error);
	}

	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		if (curs->size.x > CG6_MAX_CURSOR ||
		    curs->size.y > CG6_MAX_CURSOR)
			return (EINVAL);
		imcount = (curs->size.x * curs->size.y) / NBBY;
		error = copyin(curs->image, image, imcount);
		if (error)
			return (error);
		error = copyin(curs->mask, mask, imcount);
		if (error)
			return (error);
	}

	/*
	 * Ok, everything is in kernel space and sane, update state.
	 */
	s = spltty();

	if (curs->which & WSDISPLAY_CURSOR_DOCUR)
		sc->sc_curs_enabled = curs->enable;
	if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
		sc->sc_curs_pos.x = curs->pos.x;
		sc->sc_curs_pos.y = curs->pos.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
		sc->sc_curs_hot.x = curs->hot.x;
		sc->sc_curs_hot.y = curs->hot.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		sc->sc_curs_fg = ((r[0] << 16) | (g[0] << 8) | (b[0] << 0));
		sc->sc_curs_bg = ((r[1] << 16) | (g[1] << 8) | (b[1] << 0));
	}
	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		sc->sc_curs_size.x = curs->size.x;
		sc->sc_curs_size.y = curs->size.y;
		bcopy(image, sc->sc_curs_image, imcount);
		bcopy(mask, sc->sc_curs_mask, imcount);
	}

	cgsix_updatecursor(sc, curs->which);
	splx(s);

	return (0);
}

int
cgsix_updatecursor(struct cgsix_softc *sc, u_int which)
{
	if (which & WSDISPLAY_CURSOR_DOCMAP) {
		BT_WRITE(sc, BT_ADDR, BT_OV1 << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x00ff0000) >> 16) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x0000ff00) >> 8) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x000000ff) >> 0) << 24);

		BT_WRITE(sc, BT_ADDR, BT_OV3 << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x00ff0000) >> 16) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x0000ff00) >> 8) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x000000ff) >> 0) << 24);
	}

	if (which & (WSDISPLAY_CURSOR_DOPOS | WSDISPLAY_CURSOR_DOHOT)) {
		u_int32_t x, y;

		x = sc->sc_curs_pos.x + CG6_MAX_CURSOR - sc->sc_curs_hot.x;
		y = sc->sc_curs_pos.y + CG6_MAX_CURSOR - sc->sc_curs_hot.y;
		THC_WRITE(sc, CG6_THC_CURSXY,
		    ((x & 0xffff) << 16) | (y & 0xffff));
	}

	if (which & WSDISPLAY_CURSOR_DOCUR) {
		u_int32_t c;

		/* Enable or disable the cursor overlay planes */
		if (sc->sc_curs_enabled) {
			BT_WRITE(sc, BT_ADDR, BT_CR << 24);
			c = BT_READ(sc, BT_CTRL);
			c |= (BTCR_DISPENA_OV0 | BTCR_DISPENA_OV1) << 24;
			BT_WRITE(sc, BT_CTRL, c);
		} else {
			BT_WRITE(sc, BT_ADDR, BT_CR << 24);
			c = BT_READ(sc, BT_CTRL);
			c &= ~((BTCR_DISPENA_OV0 | BTCR_DISPENA_OV1) << 24);
			BT_WRITE(sc, BT_CTRL, c);
			THC_WRITE(sc, CG6_THC_CURSXY, THC_CURSOFF);
		}
	}

	return (0);
}

int
cgsix_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct cgsix_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgsix_free_screen(void *v, void *cookie)
{
	struct cgsix_softc *sc = v;

	sc->sc_nscreens--;
}

int
cgsix_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return (0);
}

struct mmo {
	off_t mo_uaddr;
	bus_size_t mo_size;
	bus_size_t mo_physoff;
};

paddr_t
cgsix_mmap(void *v, off_t off, int prot)
{
	struct cgsix_softc *sc = v;
	struct mmo *mo;
	bus_addr_t u;
	bus_size_t sz;

	static struct mmo mmo[] = {
		{ CG6_USER_RAM, 0, CGSIX_VID_OFFSET },

		/* do not actually know how big most of these are! */
		{ CG6_USER_FBC, 1, CGSIX_FBC_OFFSET },
		{ CG6_USER_TEC, 1, CGSIX_TEC_OFFSET },
		{ CG6_USER_BTREGS, 8192 /* XXX */, CGSIX_BT_OFFSET },
		{ CG6_USER_FHC, 1, CGSIX_FHC_OFFSET },
		{ CG6_USER_THC, CGSIX_THC_SIZE, CGSIX_THC_OFFSET },
		{ CG6_USER_ROM, 65536, CGSIX_ROM_OFFSET },
		{ CG6_USER_DHC, 1, CGSIX_DHC_OFFSET },
	};
#define	NMMO (sizeof mmo / sizeof *mmo)

	if (off & PGOFSET || off < 0)
		return (-1);

	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
		for (mo = mmo; mo < &mmo[NMMO]; mo++) {
			if (off < mo->mo_uaddr)
				continue;
			u = off - mo->mo_uaddr;
			sz = mo->mo_size ? mo->mo_size : sc->sc_sunfb.sf_fbsize;
			if (u < sz) {
				return (bus_space_mmap(sc->sc_bustag,
				    sc->sc_paddr, u + mo->mo_physoff,
				    prot, BUS_SPACE_MAP_LINEAR));
			}
		}
		break;

	case WSDISPLAYIO_MODE_DUMBFB:
		/* Allow mapping as a dumb framebuffer from offset 0 */
		if (off >= 0 && off < sc->sc_sunfb.sf_fbsize)
			return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
			    off + CGSIX_VID_OFFSET, prot,
			    BUS_SPACE_MAP_LINEAR));
		break;
	}

	return (-1);
}

int
cgsix_is_console(int node)
{
	extern int fbnode;

	return (fbnode == node);
}

int
cg6_bt_getcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyout(&bcm->cm_map[index + i][0],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][1],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][2],
		    &rcm->blue[i], 1)) != 0)
			return (error);
	}
	return (0);
}

int
cg6_bt_putcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &bcm->cm_map[index + i][0], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &bcm->cm_map[index + i][1], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &bcm->cm_map[index + i][2], 1)) != 0)
			return (error);
	}
	return (0);
}

void
cgsix_loadcmap_deferred(struct cgsix_softc *sc, u_int start, u_int ncolors)
{
	u_int32_t thcm;

	thcm = THC_READ(sc, CG6_THC_MISC);
	thcm &= ~THC_MISC_RESET;
	thcm |= THC_MISC_INTEN;
	THC_WRITE(sc, CG6_THC_MISC, thcm);
}

void
cgsix_loadcmap_immediate(struct cgsix_softc *sc, u_int start, u_int ncolors)
{
	u_int cstart;
	u_int32_t v;
	int count;

	cstart = BT_D4M3(start);
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	BT_WRITE(sc, BT_ADDR, BT_D4M4(start) << 24);
	while (--count >= 0) {
		v = sc->sc_cmap.cm_chip[cstart];
		BT_WRITE(sc, BT_CMAP, v << 0);
		BT_WRITE(sc, BT_CMAP, v << 8);
		BT_WRITE(sc, BT_CMAP, v << 16);
		BT_WRITE(sc, BT_CMAP, v << 24);
		cstart++;
	}
}

void
cgsix_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct cgsix_softc *sc = v;
	union bt_cmap *bcm = &sc->sc_cmap;

	bcm->cm_map[index][0] = r;
	bcm->cm_map[index][1] = g;
	bcm->cm_map[index][2] = b;
	cgsix_loadcmap_immediate(sc, index, 1);
}

void
cgsix_reset(struct cgsix_softc *sc, u_int32_t fhcrev)
{
	u_int32_t fhc;

	/* hide the cursor, just in case */
	THC_WRITE(sc, CG6_THC_CURSXY, THC_CURSOFF);

	TEC_WRITE(sc, CG6_TEC_MV, 0);
	TEC_WRITE(sc, CG6_TEC_CLIP, 0);
	TEC_WRITE(sc, CG6_TEC_VDC, 0);

	/* take core of hardware bugs in old revisions */
	if (fhcrev < 5) {
		/*
		 * Keep current resolution; set cpu to 68020, set test
		 * window (size 1Kx1K), and for rev 1, disable dest cache.
		 */
		fhc = FHC_READ(sc);
		fhc &= FHC_RES_MASK;
		fhc |= FHC_CPU_68020 | FHC_TEST |
		    (11 << FHC_TESTX_SHIFT) | (11 << FHC_TESTY_SHIFT);
		if (fhcrev < 2)
			fhc |= FHC_DST_DISABLE;
		FHC_WRITE(sc, fhc);
	}

	/* enable cursor overlays in brooktree DAC */
	BT_WRITE(sc, BT_ADDR, BT_CR << 24);
	BT_WRITE(sc, BT_CTRL, BT_READ(sc, BT_CTRL) |
	    ((BTCR_DISPENA_OV1 | BTCR_DISPENA_OV0) << 24));
}

void
cgsix_hardreset(struct cgsix_softc *sc)
{
	u_int32_t fhc, rev;

	/* enable all of the bit planes */
	BT_WRITE(sc, BT_ADDR, BT_RMR << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0xff << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	/* no bit planes should blink */
	BT_WRITE(sc, BT_ADDR, BT_BMR << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00 << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	/*
	 * enable the RAMDAC, disable blink, disable overlay 0 and 1,
	 * use 4:1 multiplexor.
	 */
	BT_WRITE(sc, BT_ADDR, BT_CR << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL,
	    (BTCR_MPLX_4 | BTCR_RAMENA | BTCR_BLINK_6464) << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	/* disable the D/A read pins */
	BT_WRITE(sc, BT_ADDR, BT_CTR << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00 << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	/* configure thc */
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_RESET | THC_MISC_INTR |
	    THC_MISC_CYCLS);
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_INTR | THC_MISC_CYCLS);

	THC_WRITE(sc, CG6_THC_HSYNC1, 0x10009);
	THC_WRITE(sc, CG6_THC_HSYNC2, 0x570000);
	THC_WRITE(sc, CG6_THC_HSYNC3, 0x15005d);
	THC_WRITE(sc, CG6_THC_VSYNC1, 0x10005);
	THC_WRITE(sc, CG6_THC_VSYNC2, 0x2403a8);
	THC_WRITE(sc, CG6_THC_REFRESH, 0x16b);

	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_RESET | THC_MISC_INTR |
	    THC_MISC_CYCLS);
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_INTR | THC_MISC_CYCLS);

	/* configure fhc (1152x900) */
	fhc = FHC_READ(sc);
	rev = (fhc & FHC_REV_MASK) >> FHC_REV_SHIFT;

	fhc = FHC_RES_1152 | FHC_CPU_68020 | FHC_TEST;
	if (rev < 1)
		fhc |= FHC_FROP_DISABLE;
	if (rev < 2)
		fhc |= FHC_DST_DISABLE;
	FHC_WRITE(sc, fhc);
}

void
cgsix_burner(void *vsc, u_int on, u_int flags)
{
	struct cgsix_softc *sc = vsc;
	int s;
	u_int32_t thcm;

	s = splhigh();
	thcm = THC_READ(sc, CG6_THC_MISC);
	if (on)
		thcm |= THC_MISC_VIDEN | THC_MISC_SYNCEN;
	else {
		thcm &= ~THC_MISC_VIDEN;
		if (flags & WSDISPLAY_BURN_VBLANK)
			thcm &= ~THC_MISC_SYNCEN;
	}
	THC_WRITE(sc, CG6_THC_MISC, thcm);
	splx(s);
}

int
cgsix_intr(void *vsc)
{
	struct cgsix_softc *sc = vsc;
	u_int32_t thcm;

	thcm = THC_READ(sc, CG6_THC_MISC);
	if ((thcm & (THC_MISC_INTEN | THC_MISC_INTR)) !=
	    (THC_MISC_INTEN | THC_MISC_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}

	/* Acknowledge the interrupt and disable it. */
	thcm &= ~(THC_MISC_RESET | THC_MISC_INTEN);
	thcm |= THC_MISC_INTR;
	THC_WRITE(sc, CG6_THC_MISC, thcm);
	cgsix_loadcmap_immediate(sc, 0, 256);
	return (1);
}

void
cgsix_ras_init(struct cgsix_softc *sc)
{
	u_int32_t m;

	CG6_DRAIN(sc);
	m = FBC_READ(sc, CG6_FBC_MODE);
	m &= ~FBC_MODE_MASK;
	m |= FBC_MODE_VAL;
	FBC_WRITE(sc, CG6_FBC_MODE, m);
}

void
cgsix_ras_copyrows(void *cookie, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if (dst == src)
		return;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_rows)
		n = ri->ri_rows - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_rows)
		n = ri->ri_rows - dst;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_COPY);
	FBC_WRITE(sc, CG6_FBC_X0, ri->ri_xorigin);
	FBC_WRITE(sc, CG6_FBC_Y0, ri->ri_yorigin + src);
	FBC_WRITE(sc, CG6_FBC_X1, ri->ri_xorigin + ri->ri_emuwidth - 1);
	FBC_WRITE(sc, CG6_FBC_Y1, ri->ri_yorigin + src + n - 1);
	FBC_WRITE(sc, CG6_FBC_X2, ri->ri_xorigin);
	FBC_WRITE(sc, CG6_FBC_Y2, ri->ri_yorigin + dst);
	FBC_WRITE(sc, CG6_FBC_X3, ri->ri_xorigin + ri->ri_emuwidth - 1);
	FBC_WRITE(sc, CG6_FBC_Y3, ri->ri_yorigin + dst + n - 1);
	CG6_BLIT_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_copycols(void *cookie, int row, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if (dst == src)
		return;
	if ((row < 0) || (row >= ri->ri_rows))
		return;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_cols)
		n = ri->ri_cols - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_cols)
		n = ri->ri_cols - dst;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_COPY);
	FBC_WRITE(sc, CG6_FBC_X0, ri->ri_xorigin + src);
	FBC_WRITE(sc, CG6_FBC_Y0, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_X1, ri->ri_xorigin + src + n - 1);
	FBC_WRITE(sc, CG6_FBC_Y1,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_X2, ri->ri_xorigin + dst);
	FBC_WRITE(sc, CG6_FBC_Y2, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_X3, ri->ri_xorigin + dst + n - 1);
	FBC_WRITE(sc, CG6_FBC_Y3,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	CG6_BLIT_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_erasecols(void *cookie, int row, int col, int n, long int attr)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if ((row < 0) || (row >= ri->ri_rows))
		return;
	if (col < 0) {
		n += col;
		col = 0;
	}
	if (col + n > ri->ri_cols)
		n = ri->ri_cols - col;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FILL);
	FBC_WRITE(sc, CG6_FBC_FG, ri->ri_devcmap[(attr >> 16) & 0xf]);
	FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col);
	FBC_WRITE(sc, CG6_FBC_ARECTY,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col + n - 1);
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_eraserows(void *cookie, int row, int n, long int attr)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if (row < 0) {
		n += row;
		row = 0;
	}
	if (row + n > ri->ri_rows)
		n = ri->ri_rows - row;
	if (n <= 0)
		return;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FILL);
	FBC_WRITE(sc, CG6_FBC_FG, ri->ri_devcmap[(attr >> 16) & 0xf]);
	if ((n == ri->ri_rows) && (ri->ri_flg & RI_FULLCLEAR)) {
		FBC_WRITE(sc, CG6_FBC_ARECTY, 0);
		FBC_WRITE(sc, CG6_FBC_ARECTX, 0);
		FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_height - 1);
		FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_width - 1);
	} else {
		row *= ri->ri_font->fontheight;
		FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
		FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin);
		FBC_WRITE(sc, CG6_FBC_ARECTY,
		    ri->ri_yorigin + row + (n * ri->ri_font->fontheight) - 1);
		FBC_WRITE(sc, CG6_FBC_ARECTX,
		    ri->ri_xorigin + ri->ri_emuwidth - 1);
	}
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_do_cursor(struct rasops_info *ri)
{
	struct cgsix_softc *sc = ri->ri_hw;
	int row, col;

	row = ri->ri_crow * ri->ri_font->fontheight;
	col = ri->ri_ccol * ri->ri_font->fontwidth;
	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FLIP);
	FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col);
	FBC_WRITE(sc, CG6_FBC_ARECTY,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_ARECTX,
	    ri->ri_xorigin + col + ri->ri_font->fontwidth - 1);
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_updatecursor(struct rasops_info *ri)
{
	struct cgsix_softc *sc = ri->ri_hw;

	if (sc->sc_sunfb.sf_crowp != NULL)
		*sc->sc_sunfb.sf_crowp = ri->ri_crow;
	if (sc->sc_sunfb.sf_ccolp != NULL)
		*sc->sc_sunfb.sf_ccolp = ri->ri_ccol;
}
@


1.2
log
@merge OpenBSD tree; bump MirBSD minor
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.34 2003/02/12 19:41:20 henric Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d52 1
d54 1
a57 5
	0, 0,	/* will be filled in -- XXX shouldn't, it's global. */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d81 1
a81 2
void cgsix_setcolor(struct cgsix_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t);
a85 1
static int a2int(char *, int);
d93 2
d120 1
a120 3
cgsixmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
d129 1
a129 3
cgsixattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a134 1
	long defattr;
d145 2
d173 2
a174 1
	    CGSIX_VID_SIZE, BUS_SPACE_MAP_LINEAR, 0, &sc->sc_vid_regs) != 0) {
d194 1
a194 1
	    IPL_TTY, 0, cgsix_intr, sc)) == NULL) {
a218 5
	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);

d221 1
a221 5
	sc->sc_rasops.ri_depth = sc->sc_depth;
	sc->sc_rasops.ri_stride = sc->sc_linebytes;
	sc->sc_rasops.ri_flg = RI_CENTER |
	    (console ? 0 : RI_CLEAR);
	sc->sc_rasops.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
d223 2
a224 8
	sc->sc_rasops.ri_width = sc->sc_width;
	sc->sc_rasops.ri_height = sc->sc_height;
	sc->sc_rasops.ri_hw = sc;

	rasops_init(&sc->sc_rasops,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34),
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));
	sc->sc_rasops.ri_hw = sc;
d233 1
a233 1
		sc->sc_dev.dv_cfdata->cf_flags |= CG6_CFFLAG_NOACCEL;
d235 7
a241 6
	if ((sc->sc_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL) == 0) {
		sc->sc_rasops.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_rasops.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_rasops.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_rasops.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_rasops.ri_do_cursor = cgsix_ras_do_cursor;
d245 4
a248 5
	cgsix_stdscreen.nrows = sc->sc_rasops.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_rasops.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_rasops.ri_ops;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
d252 1
a252 9
	cgsix_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
	cgsix_setcolor(sc, 255, 0, 0, 0);
	cgsix_setcolor(sc, WSCOL_RED, 255, 0, 0);
	cgsix_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
	cgsix_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
	cgsix_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
	cgsix_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
	cgsix_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
	cgsix_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
d255 3
a257 10
		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_crowp = sc->sc_ccolp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;
		sc->sc_rasops.ri_updatecursor = cgsix_ras_updatecursor;

		wsdisplay_cnattach(&cgsix_stdscreen, &sc->sc_rasops,
		    sc->sc_rasops.ri_ccol, sc->sc_rasops.ri_crow, defattr);
d286 1
a286 6
cgsix_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
d291 4
a294 1
	int error;
d299 1
a299 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d303 6
a308 3
		if (sc->sc_mode != WSDISPLAYIO_MODE_EMUL &&
		    mode == WSDISPLAYIO_MODE_EMUL)
			cgsix_ras_init(sc);
d313 3
a315 3
		wdf->height = sc->sc_height;
		wdf->width  = sc->sc_width;
		wdf->depth  = sc->sc_depth;
d319 1
a319 1
		*(u_int *)data = sc->sc_linebytes;
a320 1

a326 1

d334 36
d371 11
a381 2
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
d383 4
d388 7
d396 5
a400 2
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d402 1
a402 1
		return -1; /* not supported yet */
d409 123
a531 6
cgsix_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d538 1
a538 1
	*cookiep = &sc->sc_rasops;
d541 1
a541 1
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
d548 1
a548 3
cgsix_free_screen(v, cookie)
	void *v;
	void *cookie;
d556 2
a557 6
cgsix_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d569 1
a569 4
cgsix_mmap(v, off, prot)
	void *v;
	off_t off;
	int prot;
d599 1
a599 2
			sz = mo->mo_size ? mo->mo_size :
			    sc->sc_linebytes * sc->sc_height;
d610 1
a610 1
		if (off >= 0 && off < (sc->sc_linebytes * sc->sc_height))
a619 12
static int
a2int(char *cp, int deflt)
{
	int i = 0;

	if (*cp == '\0')
		return (deflt);
	while (*cp != '\0')
		i = i * 10 + *cp++ - '0';
	return (i);
}

d621 1
a621 2
cgsix_is_console(node)
	int node;
d629 1
a629 3
cg6_bt_getcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
d651 1
a651 3
cg6_bt_putcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
d673 1
a673 3
cgsix_loadcmap_deferred(sc, start, ncolors)
	struct cgsix_softc *sc;
	u_int start, ncolors;
d684 1
a684 3
cgsix_loadcmap_immediate(sc, start, ncolors)
	struct cgsix_softc *sc;
	u_int start, ncolors;
d704 1
a704 4
cgsix_setcolor(sc, index, r, g, b)
	struct cgsix_softc *sc;
	u_int index;
	u_int8_t r, g, b;
d706 1
d716 1
a716 3
cgsix_reset(sc, fhcrev)
	struct cgsix_softc *sc;
	u_int32_t fhcrev;
d742 4
a745 3
	/* enable cursor in brooktree DAC */
	BT_WRITE(sc, BT_ADDR, 0x6 << 24);
	BT_WRITE(sc, BT_CTRL, BT_READ(sc, BT_CTRL) | (0x3 << 24));
d749 1
a749 2
cgsix_hardreset(sc)
	struct cgsix_softc *sc;
d753 2
a754 2
	/* setup brooktree */
	BT_WRITE(sc, BT_ADDR, 0x04 << 24);
d759 2
a760 1
	BT_WRITE(sc, BT_ADDR, 0x05 << 24);
d765 5
a769 1
	BT_WRITE(sc, BT_ADDR, 0x06 << 24);
d771 2
a772 1
	BT_WRITE(sc, BT_CTRL, 0x70 << 24);
d775 2
a776 1
	BT_WRITE(sc, BT_ADDR, 0x07 << 24);
a780 1

d810 1
a810 3
cgsix_burner(vsc, on, flags)
	void *vsc;
	u_int on, flags;
d830 1
a830 2
cgsix_intr(vsc)
	void *vsc;
d851 1
a851 2
cgsix_ras_init(sc)
	struct cgsix_softc *sc;
d863 1
a863 3
cgsix_ras_copyrows(cookie, src, dst, n)
	void *cookie;
	int src, dst, n;
d910 1
a910 3
cgsix_ras_copycols(cookie, row, src, dst, n)
	void *cookie;
	int row, src, dst, n;
d962 1
a962 4
cgsix_ras_erasecols(cookie, row, col, n, attr)
	void *cookie;
	int row, col, n;
	long int attr;
d1001 1
a1001 4
cgsix_ras_eraserows(cookie, row, n, attr)
	void *cookie;
	int row, n;
	long int attr;
d1044 1
a1044 2
cgsix_ras_do_cursor(ri)
	struct rasops_info *ri;
d1071 1
a1071 2
cgsix_ras_updatecursor(ri)
	struct rasops_info *ri;
d1075 4
a1078 4
	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.2.2.1
log
@fix sparc builds even more (kernel time):
* some emulation doesn't exist
* bring back to live some files
* update tty-related stuff...

root@@demoscene:/root # ll /bsd;uname -ap
-r--r--r--  1 root  wheel  2915123 Oct 25 22:20 /bsd
OpenBSD demoscene.66h.42h.de 3.4 GENERIC#0 sparc SUNW,SPARCstation-20, TMS390Z50 v0 or TMS390Z55 @@ 50 MHz, on-chip FPU
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.44 2003/07/03 21:02:13 jason Exp $	*/
d15 5
a56 1
#include <machine/fbvar.h>
a57 1
#include <dev/ic/bt458reg.h>
d61 5
d89 2
a90 1
void cgsix_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
d95 1
a102 2
int cgsix_setcursor(struct cgsix_softc *, struct wsdisplay_cursor *);
int cgsix_updatecursor(struct cgsix_softc *, u_int);
d128 3
a130 1
cgsixmatch(struct device *parent, void *vcf, void *aux)
d139 3
a141 1
cgsixattach(struct device *parent, struct device *self, void *aux)
d147 1
a157 2
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, sa->sa_node, 0);

d184 1
a184 2
	    sc->sc_sunfb.sf_fbsize, BUS_SPACE_MAP_LINEAR,
	    0, &sc->sc_vid_regs) != 0) {
d204 1
a204 1
	    IPL_TTY, 0, cgsix_intr, sc, self->dv_xname)) == NULL) {
d229 5
d236 5
a240 1
	sc->sc_sunfb.sf_ro.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
d242 8
a249 2
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, console ? 0 : RI_CLEAR);
d258 1
a258 1
		sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags |= CG6_CFFLAG_NOACCEL;
d260 6
a265 7
	if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL)
	    == 0) {
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_sunfb.sf_ro.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_do_cursor = cgsix_ras_do_cursor;
d269 5
a273 4
	cgsix_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgsix_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d277 9
a285 1
	fbwscons_setcolormap(&sc->sc_sunfb, cgsix_setcolor);
d288 10
a297 3
		sc->sc_sunfb.sf_ro.ri_updatecursor = cgsix_ras_updatecursor;
		fbwscons_console_init(&sc->sc_sunfb, &cgsix_stdscreen, -1,
		    cgsix_burner);
d326 6
a331 1
cgsix_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
d336 1
a336 4
	struct wsdisplay_cursor *curs;
	struct wsdisplay_curpos *pos;
	u_char r[2], g[2], b[2];
	int error, s;
d341 1
a341 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG6;
d345 3
a347 6
		if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags &
		    CG6_CFFLAG_NOACCEL) == 0) {
			if (sc->sc_mode != WSDISPLAYIO_MODE_EMUL &&
			    mode == WSDISPLAYIO_MODE_EMUL)
				cgsix_ras_init(sc);
		}
d352 3
a354 3
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
d358 1
a358 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d360 1
d367 1
a374 36
	case WSDISPLAYIO_SCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		return (cgsix_setcursor(sc, curs));
	case WSDISPLAYIO_GCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		if (curs->which & WSDISPLAY_CURSOR_DOCUR)
			curs->enable = sc->sc_curs_enabled;
		if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
			curs->pos.x = sc->sc_curs_pos.x;
			curs->pos.y = sc->sc_curs_pos.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
			curs->hot.x = sc->sc_curs_hot.x;
			curs->hot.y = sc->sc_curs_hot.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
			curs->cmap.index = 0;
			curs->cmap.count = 2;
			r[0] = sc->sc_curs_fg >> 16;
			g[0] = sc->sc_curs_fg >> 8;
			b[0] = sc->sc_curs_fg >> 0;
			r[1] = sc->sc_curs_bg >> 16;
			g[1] = sc->sc_curs_bg >> 8;
			b[1] = sc->sc_curs_bg >> 0;
			error = copyout(r, curs->cmap.red, sizeof(r));
			if (error)
				return (error);
			error = copyout(g, curs->cmap.green, sizeof(g));
			if (error)
				return (error);
			error = copyout(b, curs->cmap.blue, sizeof(b));
			if (error)
				return (error);
		}
		if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
			size_t l;
d376 2
a377 11
			curs->size.x = sc->sc_curs_size.x;
			curs->size.y = sc->sc_curs_size.y;
			l = (sc->sc_curs_size.x * sc->sc_curs_size.y) / NBBY;
			error = copyout(sc->sc_curs_image, curs->image, l);
			if (error)
				return (error);
			error = copyout(sc->sc_curs_mask, curs->mask, l);
			if (error)
				return (error);
		}
		break;
a378 4
		pos = (struct wsdisplay_curpos *)data;
		pos->x = sc->sc_curs_pos.x;
		pos->y = sc->sc_curs_pos.y;
		break;
a379 7
		pos = (struct wsdisplay_curpos *)data;
		s = spltty();
		sc->sc_curs_pos.x = pos->x;
		sc->sc_curs_pos.y = pos->y;
		cgsix_updatecursor(sc, WSDISPLAY_CURSOR_DOPOS);
		splx(s);
		break;
d381 2
a382 5
		pos = (struct wsdisplay_curpos *)data;
		pos->x = pos->y = 32;
		break;
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
d384 1
a384 1
		return -1; /* not supported */
d391 6
a396 123
cgsix_setcursor(struct cgsix_softc *sc, struct wsdisplay_cursor *curs)
{
	u_int8_t r[2], g[2], b[2], image[128], mask[128];
	int s, error;
	size_t imcount;

	/*
	 * Do stuff that can generate errors first, then we'll blast it
	 * all at once.
	 */
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		if (curs->cmap.count < 2)
			return (EINVAL);
		error = copyin(curs->cmap.red, r, sizeof(r));
		if (error)
			return (error);
		error = copyin(curs->cmap.green, g, sizeof(g));
		if (error)
			return (error);
		error = copyin(curs->cmap.blue, b, sizeof(b));
		if (error)
			return (error);
	}

	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		if (curs->size.x > CG6_MAX_CURSOR ||
		    curs->size.y > CG6_MAX_CURSOR)
			return (EINVAL);
		imcount = (curs->size.x * curs->size.y) / NBBY;
		error = copyin(curs->image, image, imcount);
		if (error)
			return (error);
		error = copyin(curs->mask, mask, imcount);
		if (error)
			return (error);
	}

	/*
	 * Ok, everything is in kernel space and sane, update state.
	 */
	s = spltty();

	if (curs->which & WSDISPLAY_CURSOR_DOCUR)
		sc->sc_curs_enabled = curs->enable;
	if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
		sc->sc_curs_pos.x = curs->pos.x;
		sc->sc_curs_pos.y = curs->pos.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
		sc->sc_curs_hot.x = curs->hot.x;
		sc->sc_curs_hot.y = curs->hot.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		sc->sc_curs_fg = ((r[0] << 16) | (g[0] << 8) | (b[0] << 0));
		sc->sc_curs_bg = ((r[1] << 16) | (g[1] << 8) | (b[1] << 0));
	}
	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		sc->sc_curs_size.x = curs->size.x;
		sc->sc_curs_size.y = curs->size.y;
		bcopy(image, sc->sc_curs_image, imcount);
		bcopy(mask, sc->sc_curs_mask, imcount);
	}

	cgsix_updatecursor(sc, curs->which);
	splx(s);

	return (0);
}

int
cgsix_updatecursor(struct cgsix_softc *sc, u_int which)
{
	if (which & WSDISPLAY_CURSOR_DOCMAP) {
		BT_WRITE(sc, BT_ADDR, BT_OV1 << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x00ff0000) >> 16) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x0000ff00) >> 8) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x000000ff) >> 0) << 24);

		BT_WRITE(sc, BT_ADDR, BT_OV3 << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x00ff0000) >> 16) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x0000ff00) >> 8) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x000000ff) >> 0) << 24);
	}

	if (which & (WSDISPLAY_CURSOR_DOPOS | WSDISPLAY_CURSOR_DOHOT)) {
		u_int32_t x, y;

		x = sc->sc_curs_pos.x + CG6_MAX_CURSOR - sc->sc_curs_hot.x;
		y = sc->sc_curs_pos.y + CG6_MAX_CURSOR - sc->sc_curs_hot.y;
		THC_WRITE(sc, CG6_THC_CURSXY,
		    ((x & 0xffff) << 16) | (y & 0xffff));
	}

	if (which & WSDISPLAY_CURSOR_DOCUR) {
		u_int32_t c;

		/* Enable or disable the cursor overlay planes */
		if (sc->sc_curs_enabled) {
			BT_WRITE(sc, BT_ADDR, BT_CR << 24);
			c = BT_READ(sc, BT_CTRL);
			c |= (BTCR_DISPENA_OV0 | BTCR_DISPENA_OV1) << 24;
			BT_WRITE(sc, BT_CTRL, c);
		} else {
			BT_WRITE(sc, BT_ADDR, BT_CR << 24);
			c = BT_READ(sc, BT_CTRL);
			c &= ~((BTCR_DISPENA_OV0 | BTCR_DISPENA_OV1) << 24);
			BT_WRITE(sc, BT_CTRL, c);
			THC_WRITE(sc, CG6_THC_CURSXY, THC_CURSOFF);
		}
	}

	return (0);
}

int
cgsix_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
d403 1
a403 1
	*cookiep = &sc->sc_sunfb.sf_ro;
d406 1
a406 1
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
d413 3
a415 1
cgsix_free_screen(void *v, void *cookie)
d423 6
a428 2
cgsix_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
d440 4
a443 1
cgsix_mmap(void *v, off_t off, int prot)
d473 2
a474 1
			sz = mo->mo_size ? mo->mo_size : sc->sc_sunfb.sf_fbsize;
d485 1
a485 1
		if (off >= 0 && off < sc->sc_sunfb.sf_fbsize)
d495 12
d508 2
a509 1
cgsix_is_console(int node)
d517 3
a519 1
cg6_bt_getcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
d541 3
a543 1
cg6_bt_putcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
d565 3
a567 1
cgsix_loadcmap_deferred(struct cgsix_softc *sc, u_int start, u_int ncolors)
d578 3
a580 1
cgsix_loadcmap_immediate(struct cgsix_softc *sc, u_int start, u_int ncolors)
d600 4
a603 1
cgsix_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
a604 1
	struct cgsix_softc *sc = v;
d614 3
a616 1
cgsix_reset(struct cgsix_softc *sc, u_int32_t fhcrev)
d642 3
a644 4
	/* enable cursor overlays in brooktree DAC */
	BT_WRITE(sc, BT_ADDR, BT_CR << 24);
	BT_WRITE(sc, BT_CTRL, BT_READ(sc, BT_CTRL) |
	    ((BTCR_DISPENA_OV1 | BTCR_DISPENA_OV0) << 24));
d648 2
a649 1
cgsix_hardreset(struct cgsix_softc *sc)
d653 2
a654 2
	/* enable all of the bit planes */
	BT_WRITE(sc, BT_ADDR, BT_RMR << 24);
d659 1
a659 2
	/* no bit planes should blink */
	BT_WRITE(sc, BT_ADDR, BT_BMR << 24);
d664 1
a664 5
	/*
	 * enable the RAMDAC, disable blink, disable overlay 0 and 1,
	 * use 4:1 multiplexor.
	 */
	BT_WRITE(sc, BT_ADDR, BT_CR << 24);
d666 1
a666 2
	BT_WRITE(sc, BT_CTRL,
	    (BTCR_MPLX_4 | BTCR_RAMENA | BTCR_BLINK_6464) << 24);
d669 1
a669 2
	/* disable the D/A read pins */
	BT_WRITE(sc, BT_ADDR, BT_CTR << 24);
d674 1
d704 3
a706 1
cgsix_burner(void *vsc, u_int on, u_int flags)
d726 2
a727 1
cgsix_intr(void *vsc)
d748 2
a749 1
cgsix_ras_init(struct cgsix_softc *sc)
d761 3
a763 1
cgsix_ras_copyrows(void *cookie, int src, int dst, int n)
d810 3
a812 1
cgsix_ras_copycols(void *cookie, int row, int src, int dst, int n)
d864 4
a867 1
cgsix_ras_erasecols(void *cookie, int row, int col, int n, long int attr)
d906 4
a909 1
cgsix_ras_eraserows(void *cookie, int row, int n, long int attr)
d952 2
a953 1
cgsix_ras_do_cursor(struct rasops_info *ri)
d980 2
a981 1
cgsix_ras_updatecursor(struct rasops_info *ri)
d985 4
a988 4
	if (sc->sc_sunfb.sf_crowp != NULL)
		*sc->sc_sunfb.sf_crowp = ri->ri_crow;
	if (sc->sc_sunfb.sf_ccolp != NULL)
		*sc->sc_sunfb.sf_ccolp = ri->ri_ccol;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD repository of CTM 3155 (roughly today at noon).
Mostly in order to go 3.3-current and ease further merges of
both OpenBSD and ELFdiffs after the MirBSD has been enabled
to build again.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.39 2003/03/28 15:03:41 jason Exp $	*/
a102 2
int cgsix_setcursor(struct cgsix_softc *, struct wsdisplay_cursor *);
int cgsix_updatecursor(struct cgsix_softc *, u_int);
a157 5
	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);

d184 1
a184 2
	    sc->sc_linebytes * sc->sc_height, BUS_SPACE_MAP_LINEAR,
	    0, &sc->sc_vid_regs) != 0) {
d229 5
d278 1
a285 3
	/* for cursor inversion */
	cgsix_setcolor(sc, (~WSCOL_WHITE) & 0xff, 0, 0, 0);
	cgsix_setcolor(sc, (~WSCOL_BLACK) & 0xff, 255, 255, 255);
d336 1
a336 4
	struct wsdisplay_cursor *curs;
	struct wsdisplay_curpos *pos;
	u_char r[2], g[2], b[2];
	int error, s;
d341 1
a341 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG6;
d345 3
a347 6
		if ((sc->sc_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL)
		    == 0) {
			if (sc->sc_mode != WSDISPLAYIO_MODE_EMUL &&
			    mode == WSDISPLAYIO_MODE_EMUL)
				cgsix_ras_init(sc);
		}
d360 1
d367 1
d375 3
a377 48
	case WSDISPLAYIO_SCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		return (cgsix_setcursor(sc, curs));
	case WSDISPLAYIO_GCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		if (curs->which & WSDISPLAY_CURSOR_DOCUR)
			curs->enable = sc->sc_curs_enabled;
		if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
			curs->pos.x = sc->sc_curs_pos.x;
			curs->pos.y = sc->sc_curs_pos.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
			curs->hot.x = sc->sc_curs_hot.x;
			curs->hot.y = sc->sc_curs_hot.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
			curs->cmap.index = 0;
			curs->cmap.count = 2;
			r[0] = sc->sc_curs_fg >> 16;
			g[0] = sc->sc_curs_fg >> 8;
			b[0] = sc->sc_curs_fg >> 0;
			r[1] = sc->sc_curs_bg >> 16;
			g[1] = sc->sc_curs_bg >> 8;
			b[1] = sc->sc_curs_bg >> 0;
			error = copyout(r, curs->cmap.red, sizeof(r));
			if (error)
				return (error);
			error = copyout(g, curs->cmap.green, sizeof(g));
			if (error)
				return (error);
			error = copyout(b, curs->cmap.blue, sizeof(b));
			if (error)
				return (error);
		}
		if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
			size_t l;

			curs->size.x = sc->sc_curs_size.x;
			curs->size.y = sc->sc_curs_size.y;
			l = (sc->sc_curs_size.x * sc->sc_curs_size.y) / NBBY;
			error = copyout(sc->sc_curs_image, curs->image, l);
			if (error)
				return (error);
			error = copyout(sc->sc_curs_mask, curs->mask, l);
			if (error)
				return (error);
		}
		break;
a378 4
		pos = (struct wsdisplay_curpos *)data;
		pos->x = sc->sc_curs_pos.x;
		pos->y = sc->sc_curs_pos.y;
		break;
a379 7
		pos = (struct wsdisplay_curpos *)data;
		s = spltty();
		sc->sc_curs_pos.x = pos->x;
		sc->sc_curs_pos.y = pos->y;
		cgsix_updatecursor(sc, WSDISPLAY_CURSOR_DOPOS);
		splx(s);
		break;
d381 2
a382 5
		pos = (struct wsdisplay_curpos *)data;
		pos->x = pos->y = 32;
		break;
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
d384 1
a384 1
		return -1; /* not supported */
a385 114

	return (0);
}

int
cgsix_setcursor(struct cgsix_softc *sc, struct wsdisplay_cursor *curs)
{
	u_int8_t r[2], g[2], b[2], image[128], mask[128];
	int s, error;
	size_t imcount;

	/*
	 * Do stuff that can generate errors first, then we'll blast it
	 * all at once.
	 */
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		if (curs->cmap.count < 2)
			return (EINVAL);
		error = copyin(curs->cmap.red, r, sizeof(r));
		if (error)
			return (error);
		error = copyin(curs->cmap.green, g, sizeof(g));
		if (error)
			return (error);
		error = copyin(curs->cmap.blue, b, sizeof(b));
		if (error)
			return (error);
	}

	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		if (curs->size.x > CG6_MAX_CURSOR ||
		    curs->size.y > CG6_MAX_CURSOR)
			return (EINVAL);
		imcount = (curs->size.x * curs->size.y) / NBBY;
		error = copyin(curs->image, image, imcount);
		if (error)
			return (error);
		error = copyin(curs->mask, mask, imcount);
		if (error)
			return (error);
	}

	/*
	 * Ok, everything is in kernel space and sane, update state.
	 */
	s = spltty();

	if (curs->which & WSDISPLAY_CURSOR_DOCUR)
		sc->sc_curs_enabled = curs->enable;
	if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
		sc->sc_curs_pos.x = curs->pos.x;
		sc->sc_curs_pos.y = curs->pos.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
		sc->sc_curs_hot.x = curs->hot.x;
		sc->sc_curs_hot.y = curs->hot.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		sc->sc_curs_fg = ((r[0] << 16) | (g[0] << 8) | (b[0] << 0));
		sc->sc_curs_bg = ((r[1] << 16) | (g[1] << 8) | (b[1] << 0));
	}
	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		sc->sc_curs_size.x = curs->size.x;
		sc->sc_curs_size.y = curs->size.y;
		bcopy(image, sc->sc_curs_image, imcount);
		bcopy(mask, sc->sc_curs_mask, imcount);
	}

	cgsix_updatecursor(sc, curs->which);
	splx(s);

	return (0);
}

int
cgsix_updatecursor(struct cgsix_softc *sc, u_int which)
{
	if (which & WSDISPLAY_CURSOR_DOCMAP) {
		BT_WRITE(sc, BT_ADDR, 1 << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x00ff0000)>> 16) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x0000ff00)>> 8) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x000000ff)>> 0) << 24);

		BT_WRITE(sc, BT_ADDR, 3 << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x00ff0000)>> 16) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x0000ff00)>> 8) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x000000ff)>> 0) << 24);
	}

	if (which & (WSDISPLAY_CURSOR_DOPOS | WSDISPLAY_CURSOR_DOHOT)) {
		u_int32_t x, y;

		x = sc->sc_curs_pos.x + CG6_MAX_CURSOR - sc->sc_curs_hot.x;
		y = sc->sc_curs_pos.y + CG6_MAX_CURSOR - sc->sc_curs_hot.y;
		THC_WRITE(sc, CG6_THC_CURSXY,
		    ((x & 0xffff) << 16) | (y & 0xffff));
	}

	if (which & WSDISPLAY_CURSOR_DOCUR) {
		u_int32_t c;

		if (sc->sc_curs_enabled) {
			BT_WRITE(sc, BT_ADDR, 6 << 24);
			c = BT_READ(sc, BT_CTRL);
			c |= 3 << 24;
			BT_WRITE(sc, BT_CTRL, c);
		} else {
			BT_WRITE(sc, BT_ADDR, 6 << 24);
			c = BT_READ(sc, BT_CTRL);
			c &= ~(3 << 24);
			BT_WRITE(sc, BT_CTRL, c);
			THC_WRITE(sc, CG6_THC_CURSXY, THC_CURSOFF);
		}
	}
@


1.1.1.3
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.41 2003/06/02 18:32:41 jason Exp $	*/
d15 5
a57 1
#include <dev/ic/bt458reg.h>
d532 9
a540 15
		BT_WRITE(sc, BT_ADDR, BT_OV1 << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x00ff0000) >> 16) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x0000ff00) >> 8) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x000000ff) >> 0) << 24);

		BT_WRITE(sc, BT_ADDR, BT_OV3 << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x00ff0000) >> 16) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x0000ff00) >> 8) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x000000ff) >> 0) << 24);
a554 1
		/* Enable or disable the cursor overlay planes */
d556 1
a556 1
			BT_WRITE(sc, BT_ADDR, BT_CR << 24);
d558 1
a558 1
			c |= (BTCR_DISPENA_OV0 | BTCR_DISPENA_OV1) << 24;
d561 1
a561 1
			BT_WRITE(sc, BT_ADDR, BT_CR << 24);
d563 1
a563 1
			c &= ~((BTCR_DISPENA_OV0 | BTCR_DISPENA_OV1) << 24);
d824 3
a826 4
	/* enable cursor overlays in brooktree DAC */
	BT_WRITE(sc, BT_ADDR, BT_CR << 24);
	BT_WRITE(sc, BT_CTRL, BT_READ(sc, BT_CTRL) |
	    ((BTCR_DISPENA_OV1 | BTCR_DISPENA_OV0) << 24));
d835 2
a836 2
	/* enable all of the bit planes */
	BT_WRITE(sc, BT_ADDR, BT_RMR << 24);
d841 1
a841 2
	/* no bit planes should blink */
	BT_WRITE(sc, BT_ADDR, BT_BMR << 24);
d846 1
a846 5
	/*
	 * enable the RAMDAC, disable blink, disable overlay 0 and 1,
	 * use 4:1 multiplexor.
	 */
	BT_WRITE(sc, BT_ADDR, BT_CR << 24);
d848 1
a848 2
	BT_WRITE(sc, BT_CTRL,
	    (BTCR_MPLX_4 | BTCR_RAMENA | BTCR_BLINK_6464) << 24);
d851 1
a851 2
	/* disable the D/A read pins */
	BT_WRITE(sc, BT_ADDR, BT_CTR << 24);
d855 1
@


1.1.1.4
log
@sync with OpenBSD, this gives us a fair amount of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.42 2003/06/18 17:35:30 miod Exp $	*/
a51 1
#include <machine/fbvar.h>
d57 5
d85 2
a86 1
void cgsix_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
d91 1
d145 1
d156 4
a159 1
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, sa->sa_node, 0);
d187 1
a187 1
	    sc->sc_sunfb.sf_fbsize, BUS_SPACE_MAP_LINEAR,
d235 5
a239 1
	sc->sc_sunfb.sf_ro.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
d241 8
a248 2
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, console ? 0 : RI_CLEAR);
d257 1
a257 1
		sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags |= CG6_CFFLAG_NOACCEL;
d259 6
a264 7
	if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL)
	    == 0) {
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_sunfb.sf_ro.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_do_cursor = cgsix_ras_do_cursor;
d268 5
a272 4
	cgsix_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgsix_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d276 11
a286 1
	fbwscons_setcolormap(&sc->sc_sunfb, cgsix_setcolor);
d289 10
a298 3
		sc->sc_sunfb.sf_ro.ri_updatecursor = cgsix_ras_updatecursor;
		fbwscons_console_init(&sc->sc_sunfb, &cgsix_stdscreen, -1,
		    cgsix_burner);
d349 2
a350 2
		if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags &
		    CG6_CFFLAG_NOACCEL) == 0) {
d359 3
a361 3
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
d365 1
a365 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d588 1
a588 1
	*cookiep = &sc->sc_sunfb.sf_ro;
d591 1
a591 1
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
d658 2
a659 1
			sz = mo->mo_size ? mo->mo_size : sc->sc_sunfb.sf_fbsize;
d670 1
a670 1
		if (off >= 0 && off < sc->sc_sunfb.sf_fbsize)
d680 12
d785 4
a788 1
cgsix_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
a789 1
	struct cgsix_softc *sc = v;
d1177 4
a1180 4
	if (sc->sc_sunfb.sf_crowp != NULL)
		*sc->sc_sunfb.sf_crowp = ri->ri_crow;
	if (sc->sc_sunfb.sf_ccolp != NULL)
		*sc->sc_sunfb.sf_ccolp = ri->ri_ccol;
@


1.1.1.5
log
@the previous cvs import did not finish due to 'memory fault'
sync with OpenBSD-cvs
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.43 2003/06/24 21:54:38 henric Exp $	*/
d198 1
a198 1
	    IPL_TTY, 0, cgsix_intr, sc, self->dv_xname)) == NULL) {
@


1.1.1.6
log
@Import OpenBSD base system minus kerberos from CTM,
kernel source from CVS right now (no diffs though)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.44 2003/07/03 21:02:13 jason Exp $	*/
d120 3
a122 1
cgsixmatch(struct device *parent, void *vcf, void *aux)
d131 3
a133 1
cgsixattach(struct device *parent, struct device *self, void *aux)
d290 6
a295 1
cgsix_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
d539 6
a544 2
cgsix_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
d561 3
a563 1
cgsix_free_screen(void *v, void *cookie)
d571 6
a576 2
cgsix_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
d588 4
a591 1
cgsix_mmap(void *v, off_t off, int prot)
d643 2
a644 1
cgsix_is_console(int node)
d652 3
a654 1
cg6_bt_getcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
d676 3
a678 1
cg6_bt_putcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
d700 3
a702 1
cgsix_loadcmap_deferred(struct cgsix_softc *sc, u_int start, u_int ncolors)
d713 3
a715 1
cgsix_loadcmap_immediate(struct cgsix_softc *sc, u_int start, u_int ncolors)
d747 3
a749 1
cgsix_reset(struct cgsix_softc *sc, u_int32_t fhcrev)
d782 2
a783 1
cgsix_hardreset(struct cgsix_softc *sc)
d844 3
a846 1
cgsix_burner(void *vsc, u_int on, u_int flags)
d866 2
a867 1
cgsix_intr(void *vsc)
d888 2
a889 1
cgsix_ras_init(struct cgsix_softc *sc)
d901 3
a903 1
cgsix_ras_copyrows(void *cookie, int src, int dst, int n)
d950 3
a952 1
cgsix_ras_copycols(void *cookie, int row, int src, int dst, int n)
d1004 4
a1007 1
cgsix_ras_erasecols(void *cookie, int row, int col, int n, long int attr)
d1046 4
a1049 1
cgsix_ras_eraserows(void *cookie, int row, int n, long int attr)
d1092 2
a1093 1
cgsix_ras_do_cursor(struct rasops_info *ri)
d1120 2
a1121 1
cgsix_ras_updatecursor(struct rasops_info *ri)
@


