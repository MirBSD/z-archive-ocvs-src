head	1.4;
access;
symbols
	MIRBSD_7quater:1.1.1.2
	cvs-200405160640:1.1.1.4
	cvs-200401271800:1.1.1.4
	cvs-200401261630:1.1.1.4
	cvs-200401021645:1.1.1.3
	MIRBSD_7_ALPHA:1.1.1.2.0.6
	MIRBSD_7:1.1.1.2.0.4
	cvs-200312222040:1.1.1.3
	MIRBSD_7ter:1.1.1.2
	cvs-200311112115:1.1.5.1
	netbsd:1.1.5
	MIRBSD_7_DEV:1.1.1.2.0.2
	cvs-200310020700:1.1.1.2
	cvs-200309271030:1.1.1.2
	cvs-200309261655:1.1.1.2
	cvs-200309251530:1.1.1.2
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	cvs-200307072125:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200307021520:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	ctm-3229:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.03.21.15.13.53;	author tg;	state dead;
branches;
next	1.3;

1.3
date	2003.11.11.21.23.15;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.11.21.21.52;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.52.07;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.5.1;
next	;

1.1.1.1
date	2003.03.22.17.52.07;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.06.05.17.41.11;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.22.21.04.50;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.01.26.18.54.17;	author tg;	state Exp;
branches;
next	;

1.1.5.1
date	2003.11.11.21.16.09;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@nuke netccitt, netiso, netns (as announced earlier)
netatalk stays in as per bsiegert@@

sync kernel
sync bktr(4) options with reality
@
text
@/*	$MirBSD: pk_subr.c,v 1.3 2003/11/11 21:23:15 tg Exp $	*/
/*	$NetBSD: pk_subr.c,v 1.24 2003/08/07 16:33:04 agc Exp $	*/

/*
 * Copyright (c) 1991, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by the
 * Laboratory for Computation Vision and the Computer Science Department
 * of the University of British Columbia and the Computer Science
 * Department (IV) of the University of Erlangen-Nuremberg, Germany.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pk_subr.c	8.1 (Berkeley) 6/10/93
 */

/*
 * Copyright (c) 1984 University of British Columbia.
 * Copyright (c) 1992 Computer Science Department IV,
 * 		University of Erlangen-Nuremberg, Germany.
 *
 * This code is derived from software contributed to Berkeley by the
 * Laboratory for Computation Vision and the Computer Science Department
 * of the University of British Columbia and the Computer Science
 * Department (IV) of the University of Erlangen-Nuremberg, Germany.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pk_subr.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD: pk_subr.c,v 1.24 2003/08/07 16:33:04 agc Exp $");

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>

#include <net/if.h>
#include <net/route.h>

#include <netccitt/dll.h>
#include <netccitt/x25.h>
#include <netccitt/x25err.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>
#include <netccitt/pk_extern.h>

#include <machine/stdarg.h>

int             pk_sendspace = 1024 * 2 + 8;
int             pk_recvspace = 1024 * 2 + 8;

struct pklcd_q  pklcd_q = {&pklcd_q, &pklcd_q};

const struct x25bitslice x25_bitslice[] = {
	/* mask, shift value */
	{0xf0, 0x4},
	{0xf, 0x0},
	{0x80, 0x7},
	{0x40, 0x6},
	{0x30, 0x4},
	{0xe0, 0x5},
	{0x10, 0x4},
	{0xe, 0x1},
	{0x1, 0x0}
};


static struct x25_ifaddr *pk_ifwithaddr(struct sockaddr_x25 *);
static void pk_reset(struct pklcd *, int);

/*
 * Attach X.25 protocol to socket, allocate logical channel descripter and
 * buffer space, and enter LISTEN state if we are to accept IN-COMMING CALL
 * packets.
 *
 */

struct pklcd *
pk_attach(so)
	struct socket  *so;
{
	struct pklcd *lcp;
	int    error = ENOBUFS;

	MALLOC(lcp, struct pklcd *, sizeof(*lcp), M_PCB, M_NOWAIT);
	if (lcp) {
		bzero((caddr_t) lcp, sizeof(*lcp));
		insque(&lcp->lcd_q, &pklcd_q);
		lcp->lcd_state = READY;
		lcp->lcd_send = pk_output;
		if (so) {
			error = soreserve(so, pk_sendspace, pk_recvspace);
			lcp->lcd_so = so;
			if (so->so_options & SO_ACCEPTCONN)
				lcp->lcd_state = LISTEN;
		} else
			sbreserve(&lcp->lcd_sb, pk_sendspace);
	}
	if (so) {
		so->so_pcb = lcp;
		so->so_error = error;
	}
	return (lcp);
}

/*
 * Disconnect X.25 protocol from socket.
 */
void
pk_disconnect(lcp)
	struct pklcd *lcp;
{
	struct socket *so = lcp->lcd_so;

	switch (lcp->lcd_state) {
	case LISTEN:
		TAILQ_REMOVE(&pk_listenhead, lcp, lcd_listen);
		pk_close(lcp);
		break;

	case READY:
		pk_acct(lcp);
		pk_close(lcp);
		break;

	case SENT_CLEAR:
	case RECEIVED_CLEAR:
		break;

	default:
		pk_acct(lcp);
		if (so) {
			soisdisconnecting(so);
			sbflush(&so->so_rcv);
		}
		pk_clear(lcp, 241, 0);	/* Normal Disconnect */

	}
}

/*
 * Close an X.25 Logical Channel. Discard all space held by the connection
 * and internal descriptors. Wake up any sleepers.
 */

void
pk_close(lcp)
	struct pklcd   *lcp;
{
	struct socket *so = lcp->lcd_so;

	/*
	 * If the X.25 connection is torn down due to link
	 * level failure (e.g. LLC2 FRMR) and at the same the user
	 * level is still filling up the socket send buffer that
	 * send buffer is locked. An attempt to sbflush () that send
	 * buffer will lead us into - no, not temptation but - panic!
	 * So - we'll just check wether the send buffer is locked
	 * and if that's the case we'll mark the lcp as zombie and
	 * have the pk_timer () do the cleaning ...
	 */

	if (so && so->so_snd.sb_flags & SB_LOCK)
		lcp->lcd_state = LCN_ZOMBIE;
	else
		pk_freelcd(lcp);

	if (so == NULL)
		return;

	so->so_pcb = 0;
	soisdisconnected(so);
#if 0
	sofree (so);	/* gak!!! you can't do that here */
#endif
}

/*
 * Create a template to be used to send X.25 packets on a logical channel. It
 * allocates an mbuf and fills in a skeletal packet depending on its type.
 * This packet is passed to pk_output where the remainer of the packet is
 * filled in.
 */

struct mbuf *
pk_template(lcn, type)
	int             lcn, type;
{
	struct mbuf *m;
	struct x25_packet *xp;

	MGETHDR(m, M_DONTWAIT, MT_HEADER);
	if (m == 0)
		panic("pk_template");
	m->m_nextpkt = 0;

	/*
	 * Efficiency hack: leave a four byte gap at the beginning
	 * of the packet level header with the hope that this will
	 * be enough room for the link level to insert its header.
	 */
	m->m_data += max_linkhdr;
	m->m_pkthdr.len = m->m_len = PKHEADERLN;

	xp = mtod(m, struct x25_packet *);
	*(long *) xp = 0;	/* ugly, but fast */
	/* xp->q_bit = 0; */
	X25SBITS(xp->bits, fmt_identifier, 1);
	/* xp->lc_group_number = 0; */

	SET_LCN(xp, lcn);
	xp->packet_type = type;

	return (m);
}

/*
 * This routine restarts all the virtual circuits. Actually, the virtual
 * circuits are not "restarted" as such. Instead, any active switched circuit
 * is simply returned to READY state.
 */

void
pk_restart(pkp, restart_cause)
	struct pkcb *pkp;
	int             restart_cause;
{
	struct mbuf *m;
	struct pklcd *lcp;
	int    i;

	/* Restart all logical channels. */
	if (pkp->pk_chan == 0)
		return;

	/*
	 * Don't do this if we're doing a restart issued from
	 * inside pk_connect () --- which is only done if and
	 * only if the X.25 link is down, i.e. a RESTART needs
	 * to be done to get it up.
	 */
	if (!(pkp->pk_dxerole & DTE_CONNECTPENDING)) {
		for (i = 1; i <= pkp->pk_maxlcn; ++i)
			if ((lcp = pkp->pk_chan[i]) != NULL) {
				if (lcp->lcd_so) {
					lcp->lcd_so->so_error = ENETRESET;
					pk_close(lcp);
				} else {
					pk_flush(lcp);
					lcp->lcd_state = READY;
					if (lcp->lcd_upper)
						(*lcp->lcd_upper)(NULL, lcp);
				}
			}
	}
	if (restart_cause < 0)
		return;

	pkp->pk_state = DTE_SENT_RESTART;
	pkp->pk_dxerole &= ~(DTE_PLAYDCE | DTE_PLAYDTE);
	lcp = pkp->pk_chan[0];
	m = lcp->lcd_template = pk_template(lcp->lcd_lcn, X25_RESTART);
	m->m_pkthdr.len = m->m_len += 2;
	mtod(m, struct x25_packet *)->packet_data = 0;	/* DTE only */
	mtod(m, octet *)[4] = restart_cause;
	pk_output(lcp);
}


/*
 * This procedure frees up the Logical Channel Descripter.
 */

void
pk_freelcd(lcp)
	struct pklcd *lcp;
{
	if (lcp == NULL)
		return;

	if (lcp->lcd_lcn > 0)
		lcp->lcd_pkp->pk_chan[lcp->lcd_lcn] = NULL;

	pk_flush(lcp);
	remque(&lcp->lcd_q);
	free((caddr_t) lcp, M_PCB);
}

static struct x25_ifaddr *
pk_ifwithaddr(sx)
	struct sockaddr_x25 *sx;
{
	struct ifnet   *ifp;
	struct ifaddr  *ifa;
	struct x25_ifaddr *ia;
	char           *addr = sx->x25_addr;

	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
		for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
		     ifa = ifa->ifa_list.tqe_next)
			if (ifa->ifa_addr->sa_family == AF_CCITT) {
				ia = (struct x25_ifaddr *) ifa;
				if (bcmp(addr, ia->ia_xc.xc_addr.x25_addr,
					 16) == 0)
					return (ia);

			}
	return ((struct x25_ifaddr *) 0);
}


/*
 * Bind a address and protocol value to a socket.  The important part is the
 * protocol value - the first four characters of the Call User Data field.
 */

#define XTRACTPKP(rt)	((rt)->rt_flags & RTF_GATEWAY ? \
			 ((rt)->rt_llinfo ? \
			  (struct pkcb *) ((struct rtentry *)((rt)->rt_llinfo))->rt_llinfo : \
			  (struct pkcb *) NULL) : \
			 (struct pkcb *)((rt)->rt_llinfo))

int
pk_bind(lcp, nam)
	struct pklcd   *lcp;
	struct mbuf    *nam;
{
	struct pklcd *pp;
	struct sockaddr_x25 *sa;

	if (nam == NULL)
		return (EADDRNOTAVAIL);
	if (lcp->lcd_ceaddr)	/* XXX */
		return (EADDRINUSE);
	if (pk_checksockaddr(nam))
		return (EINVAL);
	sa = mtod(nam, struct sockaddr_x25 *);

	/*
	 * If the user wishes to accept calls only from a particular
	 * net (net != 0), make sure the net is known
	 */

	if (sa->x25_addr[0]) {
		if (!pk_ifwithaddr(sa))
			return (ENETUNREACH);
	} else if (sa->x25_net) {
		if (!ifa_ifwithnet((struct sockaddr *) sa))
			return (ENETUNREACH);
	}
	/*
	 * For ISO's sake permit default listeners, but only one such . . .
	 */
	for (pp = pk_listenhead.tqh_first; pp; pp = pp->lcd_listen.tqe_next) {
		struct sockaddr_x25 *sa2 = pp->lcd_ceaddr;
		if ((sa2->x25_udlen == sa->x25_udlen) &&
		    (sa2->x25_udlen == 0 ||
		     (bcmp(sa2->x25_udata, sa->x25_udata,
			   min(sa2->x25_udlen, sa->x25_udlen)) == 0)))
			return (EADDRINUSE);
	}
	lcp->lcd_laddr = *sa;
	lcp->lcd_ceaddr = &lcp->lcd_laddr;
	return (0);
}

/*
 * Include a bound control block in the list of listeners.
 */
int
pk_listen(lcp)
	struct pklcd *lcp;
{
	if (lcp->lcd_ceaddr == 0)
		return (EDESTADDRREQ);

	lcp->lcd_state = LISTEN;
	/*
	 * Add default listener at end, any others at start.
	 */
	if (lcp->lcd_ceaddr->x25_udlen == 0) {
		TAILQ_INSERT_TAIL(&pk_listenhead, lcp, lcd_listen);
	} else {
		TAILQ_INSERT_HEAD(&pk_listenhead, lcp, lcd_listen);
	}
	return (0);
}

/*
 * Include a listening control block for the benefit of other protocols.
 */
int
pk_protolisten(spi, spilen, callee)
	int		spi;
	int		spilen;
	int             (*callee)(struct mbuf *, void *);
{
	struct pklcd *lcp = pk_attach((struct socket *) 0);
	struct mbuf *nam;
	struct sockaddr_x25 *sa;
	int             error = ENOBUFS;

	if (lcp) {
		if ((nam = m_getclr(M_DONTWAIT, MT_SONAME)) != NULL) {
			sa = mtod(nam, struct sockaddr_x25 *);
			sa->x25_family = AF_CCITT;
			sa->x25_len = nam->m_len = sizeof(*sa);
			sa->x25_udlen = spilen;
			sa->x25_udata[0] = spi;
			lcp->lcd_upper = callee;
			lcp->lcd_flags = X25_MBS_HOLD;
			if ((error = pk_bind(lcp, nam)) == 0)
				error = pk_listen(lcp);
			(void) m_free(nam);
		}
		if (error)
			pk_freelcd(lcp);
	}
	return error;		/* Hopefully Zero ! */
}

/*
 * Associate a logical channel descriptor with a network.
 * Fill in the default network specific parameters and then
 * set any parameters explicitly specified by the user or
 * by the remote DTE.
 */

void
pk_assoc(pkp, lcp, sa)
	struct pkcb *pkp;
	struct pklcd *lcp;
	struct sockaddr_x25 *sa;
{

	lcp->lcd_pkp = pkp;
	lcp->lcd_packetsize = pkp->pk_xcp->xc_psize;
	lcp->lcd_windowsize = pkp->pk_xcp->xc_pwsize;
	lcp->lcd_rsn = MODULUS - 1;
	pkp->pk_chan[lcp->lcd_lcn] = lcp;

	if (sa->x25_opts.op_psize)
		lcp->lcd_packetsize = sa->x25_opts.op_psize;
	else
		sa->x25_opts.op_psize = lcp->lcd_packetsize;
	if (sa->x25_opts.op_wsize)
		lcp->lcd_windowsize = sa->x25_opts.op_wsize;
	else
		sa->x25_opts.op_wsize = lcp->lcd_windowsize;
	sa->x25_net = pkp->pk_xcp->xc_addr.x25_net;
	lcp->lcd_flags |= sa->x25_opts.op_flags;
	lcp->lcd_stime = time.tv_sec;
}

int
pk_connect(lcp, sa)
	struct pklcd *lcp;
	struct sockaddr_x25 *sa;
{
	struct pkcb *pkp;
	struct rtentry *rt;
	struct rtentry *nrt;

	if (sa->x25_addr[0] == '\0')
		return (EDESTADDRREQ);

	/*
	 * Is the destination address known?
	 */
	if (!(rt = rtalloc1((struct sockaddr *) sa, 1)))
		return (ENETUNREACH);

	if (!(pkp = XTRACTPKP(rt)))
		pkp = pk_newlink((struct x25_ifaddr *) (rt->rt_ifa),
				 (caddr_t) 0);

	/*
	 * Have we entered the LLC address?
	 */
	if ((nrt = npaidb_enter((struct sockaddr_dl *) rt->rt_gateway,
				rt_key(rt), rt, 0)) != NULL)
		pkp->pk_llrt = nrt;

	/*
	 * Have we allocated an LLC2 link yet?
	 */
	if (pkp->pk_llnext == (caddr_t) 0 && pkp->pk_llctlinput) {
		struct dll_ctlinfo ctlinfo;

		ctlinfo.dlcti_rt = rt;
		ctlinfo.dlcti_pcb = (caddr_t) pkp;
		ctlinfo.dlcti_conf =
			(struct dllconfig *) (&((struct x25_ifaddr *) (rt->rt_ifa))->ia_xc);
		pkp->pk_llnext =
			(*pkp->pk_llctlinput)(PRC_CONNECT_REQUEST,
					      NULL, &ctlinfo);
	}
	if (pkp->pk_state != DTE_READY && pkp->pk_state != DTE_WAITING)
		return (ENETDOWN);
	if ((lcp->lcd_lcn = pk_getlcn(pkp)) == 0)
		return (EMFILE);

	lcp->lcd_faddr = *sa;
	lcp->lcd_ceaddr = &lcp->lcd_faddr;
	pk_assoc(pkp, lcp, lcp->lcd_ceaddr);

	/*
	 * If the link is not up yet, initiate an X.25 RESTART
	 */
	if (pkp->pk_state == DTE_WAITING) {
		pkp->pk_dxerole |= DTE_CONNECTPENDING;
		pk_ctlinput(PRC_LINKUP, NULL, pkp);
		if (lcp->lcd_so)
			soisconnecting(lcp->lcd_so);
		return 0;
	}
	if (lcp->lcd_so)
		soisconnecting(lcp->lcd_so);
	lcp->lcd_template = pk_template(lcp->lcd_lcn, X25_CALL);
	pk_callrequest(lcp, lcp->lcd_ceaddr, pkp->pk_xcp);
	return (*pkp->pk_ia->ia_start) (lcp);
}

/*
 * Complete all pending X.25 call requests --- this gets called after
 * the X.25 link has been restarted.
 */
#define RESHUFFLELCN(maxlcn, lcn) ((maxlcn) - (lcn) + 1)

void
pk_callcomplete(pkp)
	struct pkcb *pkp;
{
	struct pklcd *lcp;
	int    i;
	int    ni;


	if (pkp->pk_dxerole & DTE_CONNECTPENDING)
		pkp->pk_dxerole &= ~DTE_CONNECTPENDING;
	else
		return;

	if (pkp->pk_chan == 0)
		return;

	/*
	 * We pretended to be a DTE for allocating lcns, if
	 * it turns out that we are in reality performing as a
	 * DCE we need to reshuffle the lcps.
	 *
         *             /+---------------+--------     -
	 *            / | a  (maxlcn-1) |              \
	 *           /  +---------------+              	\
	 *     +--- *   | b  (maxlcn-2) |         	 \
	 *     |     \  +---------------+         	  \
	 *   r |      \ | c  (maxlcn-3) |         	   \
	 *   e |       \+---------------+         	    |
	 *   s |        |	 .                	    |
	 *   h |        |        .                	    | m
	 *   u |        |	 .      	  	    | a
	 *   f |        |	 .      	  	    | x
	 *   f |        |	 .                	    | l
	 *   l |       /+---------------+         	    | c
	 *   e |      / | c' (   3    ) |         	    | n
	 *     |     /  +---------------+         	    |
	 *     +--> *   | b' (   2    ) |         	   /
	 *           \  +---------------+         	  /
	 *            \ | a' (   1    ) |         	 /
    	 *             \+---------------+               /
         *              | 0             |              /
	 *              +---------------+--------     -
	 *
	 */
	if (pkp->pk_dxerole & DTE_PLAYDCE) {
		/* Sigh, reshuffle it */
		for (i = pkp->pk_maxlcn; i > 0; --i)
			if (pkp->pk_chan[i]) {
				ni = RESHUFFLELCN(pkp->pk_maxlcn, i);
				pkp->pk_chan[ni] = pkp->pk_chan[i];
				pkp->pk_chan[i] = NULL;
				pkp->pk_chan[ni]->lcd_lcn = ni;
			}
	}
	for (i = 1; i <= pkp->pk_maxlcn; ++i)
		if ((lcp = pkp->pk_chan[i]) != NULL) {
			/*
			 * if (lcp->lcd_so) soisconnecting (lcp->lcd_so);
			 */
			lcp->lcd_template = pk_template(lcp->lcd_lcn, X25_CALL);
			pk_callrequest(lcp, lcp->lcd_ceaddr, pkp->pk_xcp);
			(*pkp->pk_ia->ia_start) (lcp);
		}
}

struct bcdinfo {
	octet          *cp;
	unsigned        posn;
};

/*
 * Build the rest of the CALL REQUEST packet. Fill in calling address,
 * facilities fields and the user data field.
 */

void
pk_callrequest(lcp, sa, xcp)
	struct pklcd   *lcp;
	struct sockaddr_x25 *sa;
	struct x25config *xcp;
{
	struct x25_calladdr *a;
	struct mbuf *m = lcp->lcd_template;
	struct x25_packet *xp = mtod(m, struct x25_packet *);
	struct bcdinfo  b;

	if (lcp->lcd_flags & X25_DBIT)
		X25SBITS(xp->bits, d_bit, 1);
	a = (struct x25_calladdr *) & xp->packet_data;
	b.cp = (octet *) a->address_field;
	b.posn = 0;
	X25SBITS(a->addrlens, called_addrlen, to_bcd(&b, sa, xcp));
	X25SBITS(a->addrlens, calling_addrlen, to_bcd(&b, &xcp->xc_addr, xcp));
	if (b.posn & 0x01)
		*b.cp++ &= 0xf0;
	m->m_pkthdr.len = m->m_len += b.cp - (octet *) a;

	if (lcp->lcd_facilities) {
		m->m_pkthdr.len +=
			(m->m_next = lcp->lcd_facilities)->m_pkthdr.len;
		lcp->lcd_facilities = 0;
	} else
		pk_build_facilities(m, sa, (int) xcp->xc_type);

	m_copyback(m, m->m_pkthdr.len, sa->x25_udlen, sa->x25_udata);
}

void
pk_build_facilities(m, sa, type)
	struct mbuf *m;
	struct sockaddr_x25 *sa;
	int type;
{
	octet *cp;
	octet *fcp;
	int    revcharge;

	cp = mtod(m, octet *) + m->m_len;
	fcp = cp + 1;
	revcharge = sa->x25_opts.op_flags & X25_REVERSE_CHARGE ? 1 : 0;
	/*
	 * This is specific to Datapac X.25(1976) DTEs.  International
	 * calls must have the "hi priority" bit on.
	 */
	if (type == X25_1976 && sa->x25_opts.op_psize == X25_PS128)
		revcharge |= 02;
	if (revcharge) {
		*fcp++ = FACILITIES_REVERSE_CHARGE;
		*fcp++ = revcharge;
	}
	switch (type) {
	case X25_1980:
	case X25_1984:
		*fcp++ = FACILITIES_PACKETSIZE;
		*fcp++ = sa->x25_opts.op_psize;
		*fcp++ = sa->x25_opts.op_psize;

		*fcp++ = FACILITIES_WINDOWSIZE;
		*fcp++ = sa->x25_opts.op_wsize;
		*fcp++ = sa->x25_opts.op_wsize;
	}
	*cp = fcp - cp - 1;
	m->m_pkthdr.len = (m->m_len += *cp + 1);
}

int
to_bcd(b, sa, xcp)
	struct bcdinfo *b;
	struct sockaddr_x25 *sa;
	struct x25config *xcp;
{
	char  *x = sa->x25_addr;
	unsigned        start = b->posn;
	/*
	 * The nodnic and prepnd0 stuff looks tedious,
	 * but it does allow full X.121 addresses to be used,
	 * which is handy for routing info (& OSI type 37 addresses).
	 */
	if (xcp->xc_addr.x25_net && (xcp->xc_nodnic || xcp->xc_prepnd0)) {
		char            dnicname[sizeof(long) * NBBY / 3 + 2];
		char  *p = dnicname;

		sprintf(p, "%d", xcp->xc_addr.x25_net & 0x7fff);
		for (; *p; p++)	/* *p == 0 means dnic matched */
			if ((*p ^ *x++) & 0x0f)
				break;
		if (*p || xcp->xc_nodnic == 0)
			x = sa->x25_addr;
		if (*p && xcp->xc_prepnd0) {
			if ((b->posn)++ & 0x01)
				(b->cp)++;
			else
				*(b->cp) = 0;
		}
	}
	while (*x)
		if ((b->posn)++ & 0x01)
			*(b->cp)++ |= *x++ & 0x0F;
		else
			*(b->cp) = *x++ << 4;
	return ((b->posn) - start);
}

/*
 * This routine gets the  first available logical channel number.  The search
 * is - from the highest number to lowest number if playing DTE, and - from
 * lowest to highest number if playing DCE.
 */

int
pk_getlcn(pkp)
	struct pkcb *pkp;
{
	int    i;

	if (pkp->pk_chan == 0)
		return (0);
	if (pkp->pk_dxerole & DTE_PLAYDCE) {
		for (i = 1; i <= pkp->pk_maxlcn; ++i)
			if (pkp->pk_chan[i] == NULL)
				break;
	} else {
		for (i = pkp->pk_maxlcn; i > 0; --i)
			if (pkp->pk_chan[i] == NULL)
				break;
	}
	i = (i > pkp->pk_maxlcn ? 0 : i);
	return (i);
}

/*
 * This procedure sends a CLEAR request packet. The lc state is set to
 * "SENT_CLEAR".
 */

void
pk_clear(lcp, diagnostic, abortive)
	struct pklcd *lcp;
	int diagnostic;
	int abortive;
{
	struct mbuf *m = pk_template(lcp->lcd_lcn, X25_CLEAR);

	m->m_len += 2;
	m->m_pkthdr.len += 2;
	mtod(m, struct x25_packet *)->packet_data = 0;
	mtod(m, octet *)[4] = diagnostic;
	if (lcp->lcd_facilities) {
		m->m_next = lcp->lcd_facilities;
		m->m_pkthdr.len += m->m_next->m_len;
		lcp->lcd_facilities = 0;
	}
	if (abortive)
		lcp->lcd_template = m;
	else {
		struct socket  *so = lcp->lcd_so;
		struct sockbuf *sb = so ? &so->so_snd : &lcp->lcd_sb;
		sbappendrecord(sb, m);
	}
	pk_output(lcp);

}

/*
 * This procedure generates RNR's or RR's to inhibit or enable
 * inward data flow, if the current state changes (blocked ==> open or
 * vice versa), or if forced to generate one.  One forces RNR's to ack data.
 */
void
pk_flowcontrol(lcp, inhibit, forced)
	struct pklcd *lcp;
	int inhibit;
	int forced;
{
	inhibit = (inhibit != 0);
	if (lcp == 0 || lcp->lcd_state != DATA_TRANSFER ||
	    (forced == 0 && lcp->lcd_rxrnr_condition == inhibit))
		return;
	lcp->lcd_rxrnr_condition = inhibit;
	lcp->lcd_template =
		pk_template(lcp->lcd_lcn, inhibit ? X25_RNR : X25_RR);
	pk_output(lcp);
}

/*
 * This procedure sends a RESET request packet. It re-intializes virtual
 * circuit.
 */

static void
pk_reset(lcp, diagnostic)
	struct pklcd *lcp;
	int diagnostic;
{
	struct mbuf *m;
	struct socket *so = lcp->lcd_so;

	if (lcp->lcd_state != DATA_TRANSFER)
		return;

	if (so)
		so->so_error = ECONNRESET;
	lcp->lcd_reset_condition = TRUE;

	/* Reset all the control variables for the channel. */
	pk_flush(lcp);
	lcp->lcd_window_condition = lcp->lcd_rnr_condition =
		lcp->lcd_intrconf_pending = FALSE;
	lcp->lcd_rsn = MODULUS - 1;
	lcp->lcd_ssn = 0;
	lcp->lcd_output_window = lcp->lcd_input_window =
		lcp->lcd_last_transmitted_pr = 0;
	m = lcp->lcd_template = pk_template(lcp->lcd_lcn, X25_RESET);
	m->m_pkthdr.len = m->m_len += 2;
	mtod(m, struct x25_packet *)->packet_data = 0;
	mtod(m, octet *)[4] = diagnostic;
	pk_output(lcp);

}

/*
 * This procedure frees all data queued for output or delivery on a
 *  virtual circuit.
 */
void
pk_flush(lcp)
	struct pklcd *lcp;
{
	struct socket *so;

	if (lcp->lcd_template)
		m_freem(lcp->lcd_template);

	if (lcp->lcd_cps) {
		m_freem(lcp->lcd_cps);
		lcp->lcd_cps = 0;
	}
	if (lcp->lcd_facilities) {
		m_freem(lcp->lcd_facilities);
		lcp->lcd_facilities = 0;
	}
	if ((so = lcp->lcd_so) != NULL)
		sbflush(&so->so_snd);
	else
		sbflush(&lcp->lcd_sb);
}

/*
 * This procedure handles all local protocol procedure errors.
 */

void
pk_procerror(error, lcp, errstr, diagnostic)
	int error;
	struct pklcd *lcp;
	char *errstr;
	int diagnostic;
{

	pk_message(lcp->lcd_lcn, lcp->lcd_pkp->pk_xcp, "%s", errstr);

	switch (error) {
	case PK_CLEAR:
		if (lcp->lcd_so) {
			lcp->lcd_so->so_error = ECONNABORTED;
			soisdisconnecting(lcp->lcd_so);
		}
		pk_clear(lcp, diagnostic, 1);
		break;

	case PK_RESET:
		pk_reset(lcp, diagnostic);
	}
}

/*
 * This procedure is called during the DATA TRANSFER state to check and
 * process  the P(R) values  received  in the DATA,  RR OR RNR packets.
 */

int
pk_ack(lcp, pr)
	struct pklcd   *lcp;
	unsigned        pr;
{
	struct socket *so = lcp->lcd_so;

	if (lcp->lcd_output_window == pr)
		return (PACKET_OK);
	if (lcp->lcd_output_window < lcp->lcd_ssn) {
		if (pr < lcp->lcd_output_window || pr > lcp->lcd_ssn) {
			pk_procerror(PK_RESET, lcp,
				     "p(r) flow control error", 2);
			return (ERROR_PACKET);
		}
	} else {
		if (pr < lcp->lcd_output_window && pr > lcp->lcd_ssn) {
			pk_procerror(PK_RESET, lcp,
				     "p(r) flow control error #2", 2);
			return (ERROR_PACKET);
		}
	}

	lcp->lcd_output_window = pr;	/* Rotate window. */
	if (lcp->lcd_window_condition == TRUE)
		lcp->lcd_window_condition = FALSE;

	if (so && sb_notify(&(so->so_snd)))
		sowwakeup(so);

	return (PACKET_OK);
}

/*
 * This procedure decodes the X.25 level 3 packet returning a code to be used
 * in switchs or arrays.
 */

int
pk_decode(xp)
	struct x25_packet *xp;
{
	int    type;

	if (X25GBITS(xp->bits, fmt_identifier) != 1)
		return (PK_INVALID_PACKET);
#ifdef ancient_history
	/*
	 * Make sure that the logical channel group number is 0. This
	 * restriction may be removed at some later date.
	 */
	if (xp->lc_group_number != 0)
		return (PK_INVALID_PACKET);
#endif
	/*
	 * Test for data packet first.
	 */
	if (!(xp->packet_type & DATA_PACKET_DESIGNATOR))
		return (PK_DATA);

	/*
	 * Test if flow control packet (RR or RNR).
	 */
	if (!(xp->packet_type & RR_OR_RNR_PACKET_DESIGNATOR))
		switch (xp->packet_type & 0x1f) {
		case X25_RR:
			return (PK_RR);
		case X25_RNR:
			return (PK_RNR);
		case X25_REJECT:
			return (PK_REJECT);
		}

	/*
	 * Determine the rest of the packet types.
	 */
	switch (xp->packet_type) {
	case X25_CALL:
		type = PK_CALL;
		break;

	case X25_CALL_ACCEPTED:
		type = PK_CALL_ACCEPTED;
		break;

	case X25_CLEAR:
		type = PK_CLEAR;
		break;

	case X25_CLEAR_CONFIRM:
		type = PK_CLEAR_CONF;
		break;

	case X25_INTERRUPT:
		type = PK_INTERRUPT;
		break;

	case X25_INTERRUPT_CONFIRM:
		type = PK_INTERRUPT_CONF;
		break;

	case X25_RESET:
		type = PK_RESET;
		break;

	case X25_RESET_CONFIRM:
		type = PK_RESET_CONF;
		break;

	case X25_RESTART:
		type = PK_RESTART;
		break;

	case X25_RESTART_CONFIRM:
		type = PK_RESTART_CONF;
		break;

	case X25_DIAGNOSTIC:
		type = PK_DIAG_TYPE;
		break;

	default:
		type = PK_INVALID_PACKET;
	}
	return (type);
}

/*
 * A restart packet has been received. Print out the reason for the restart.
 */

void
pk_restartcause(pkp, xp)
	struct pkcb    *pkp;
	struct x25_packet *xp;
{
	struct x25config *xcp = pkp->pk_xcp;
	int    lcn = LCN(xp);

	switch (xp->packet_data) {
	case X25_RESTART_LOCAL_PROCEDURE_ERROR:
		pk_message(lcn, xcp, "restart: local procedure error");
		break;

	case X25_RESTART_NETWORK_CONGESTION:
		pk_message(lcn, xcp, "restart: network congestion");
		break;

	case X25_RESTART_NETWORK_OPERATIONAL:
		pk_message(lcn, xcp, "restart: network operational");
		break;

	default:
		pk_message(lcn, xcp, "restart: unknown cause");
	}
}

#define MAXRESETCAUSE	7

int             Reset_cause[] = {
	EXRESET, EXROUT, 0, EXRRPE, 0, EXRLPE, 0, EXRNCG
};

/*
 * A reset packet has arrived. Return the cause to the user.
 */

void
pk_resetcause(pkp, xp)
	struct pkcb    *pkp;
	struct x25_packet *xp;
{
	struct pklcd *lcp =
	pkp->pk_chan[LCN(xp)];
	int    code = xp->packet_data;

	if (code > MAXRESETCAUSE)
		code = 7;	/* EXRNCG */

	pk_message(LCN(xp), lcp->lcd_pkp->pk_xcp,
		   "reset code 0x%x, diagnostic 0x%x",
		   xp->packet_data, 4[(u_char *) xp]);

	if (lcp->lcd_so)
		lcp->lcd_so->so_error = Reset_cause[code];
}

#define MAXCLEARCAUSE	25

int Clear_cause[] = {
	EXCLEAR, EXCBUSY, 0, EXCINV, 0, EXCNCG, 0,
	0, 0, EXCOUT, 0, EXCAB, 0, EXCNOB, 0, 0, 0, EXCRPE,
	0, EXCLPE, 0, 0, 0, 0, 0, EXCRRC
};

/*
 * A clear packet has arrived. Return the cause to the user.
 */
void
pk_clearcause(pkp, xp)
	struct pkcb    *pkp;
	struct x25_packet *xp;
{
	struct pklcd *lcp =
	pkp->pk_chan[LCN(xp)];
	int    code = xp->packet_data;

	if (code > MAXCLEARCAUSE)
		code = 5;	/* EXRNCG */
	if (lcp->lcd_so)
		lcp->lcd_so->so_error = Clear_cause[code];
}

char *
format_ntn(xcp)
	struct x25config *xcp;
{

	return (xcp->xc_addr.x25_addr);
}

/* VARARGS1 */
void
#if __STDC__
pk_message(int lcn, struct x25config * xcp, char * fmt,...)
#else
pk_message(lcn, xcp, fmt, va_alist)
	int             lcn;
	struct x25config *xcp;
	char           *fmt;
	va_dcl
#endif
{
	va_list         ap;

	if (lcn)
		if (!PQEMPTY)
			printf("X.25(%s): lcn %d: ", format_ntn(xcp), lcn);
		else
			printf("X.25: lcn %d: ", lcn);
	else if (!PQEMPTY)
		printf("X.25(%s): ", format_ntn(xcp));
	else
		printf("X.25: ");

	va_start(ap, fmt);
	vprintf(fmt, ap);
	printf("\n");
	va_end(ap);
}

int
pk_fragment(lcp, m0, qbit, mbit, wait)
	struct mbuf    *m0;
	struct pklcd *lcp;
	int qbit, mbit, wait;
{
	struct mbuf *m = m0;
	struct x25_packet *xp;
	struct sockbuf *sb;
	struct mbuf    *head = 0, *next, **mp = &head;
	int             totlen, psize = 1 << (lcp->lcd_packetsize);

	if (m == 0)
		return 0;
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("pk_fragment");
	totlen = m->m_pkthdr.len;
	m->m_nextpkt = 0;
	sb = lcp->lcd_so ? &lcp->lcd_so->so_snd : &lcp->lcd_sb;
	do {
		if (totlen > psize) {
			if ((next = m_split(m, psize, wait)) == 0)
				goto abort;
			totlen -= psize;
		} else
			next = 0;
		M_PREPEND(m, PKHEADERLN, wait);
		if (m == 0)
			goto abort;
		*mp = m;
		mp = &m->m_nextpkt;
		*mp = 0;
		xp = mtod(m, struct x25_packet *);
		0[(char *) xp] = 0;
		if (qbit)
			X25SBITS(xp->bits, q_bit, 1);
		if (lcp->lcd_flags & X25_DBIT)
			X25SBITS(xp->bits, d_bit, 1);
		X25SBITS(xp->bits, fmt_identifier, 1);
		xp->packet_type = X25_DATA;
		SET_LCN(xp, lcp->lcd_lcn);
		if (next || (mbit && (totlen == psize ||
				      (lcp->lcd_flags & X25_DBIT))))
			SMBIT(xp, 1);
	} while ((m = next) != NULL);
	for (m = head; m; m = next) {
		next = m->m_nextpkt;
		m->m_nextpkt = 0;
		sbappendrecord(sb, m);
	}
	return 0;
abort:
	if (wait)
		panic("pk_fragment null mbuf after wait");
	if (next)
		m_freem(next);
	for (m = head; m; m = next) {
		next = m->m_nextpkt;
		m_freem(m);
	}
	return ENOBUFS;
}
@


1.3
log
@__P() removal
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
@


1.2
log
@whitespace
@
text
@d1 1
d125 2
a126 2
static struct x25_ifaddr *pk_ifwithaddr __P((struct sockaddr_x25 *));
static void pk_reset __P((struct pklcd *, int));
d453 1
a453 1
	int             (*callee) __P((struct mbuf *, void *));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 2
/*	$OpenBSD: pk_subr.c,v 1.7 2003/02/18 13:14:43 jmc Exp $	*/
/*	$NetBSD: pk_subr.c,v 1.12 1996/03/30 21:54:33 christos Exp $	*/
a3 3
 * Copyright (c) University of British Columbia, 1984
 * Copyright (C) Computer Science Department IV,
 * 		 University of Erlangen-Nuremberg, Germany, 1992
d9 38
a46 1
 * of the the University of British Columbia and the Computer Science
d80 3
d110 1
a110 1
struct x25bitslice x25_bitslice[] = {
d124 2
a125 2
static struct x25_ifaddr *pk_ifwithaddr(struct sockaddr_x25 *);
static void pk_reset(struct pklcd *, int);
d131 1
a131 1
 * 
d138 2
a139 2
	register struct pklcd *lcp;
	register int    error = ENOBUFS;
d167 1
a167 1
	register struct pklcd *lcp;
d169 1
a169 2
	register struct socket *so = lcp->lcd_so;
	register struct pklcd *l, *p;
d173 1
a173 6
		for (p = 0, l = pk_listenhead; l && l != lcp; p = l, l = l->lcd_listen);
		if (p == 0) {
			if (l != 0)
				pk_listenhead = l->lcd_listen;
		} else if (l != 0)
			p->lcd_listen = l->lcd_listen;
d206 1
a206 1
	register struct socket *so = lcp->lcd_so;
d245 2
a246 2
	register struct mbuf *m;
	register struct x25_packet *xp;
d251 1
a251 1
	m->m_act = 0;
d281 1
a281 1
	register struct pkcb *pkp;
d284 3
a286 3
	register struct mbuf *m;
	register struct pklcd *lcp;
	register int    i;
d332 1
a332 1
	register struct pklcd *lcp;
d351 1
a351 1
	register struct x25_ifaddr *ia;
d384 2
a385 2
	register struct pklcd *pp;
	register struct sockaddr_x25 *sa;
d410 2
a411 2
	for (pp = pk_listenhead; pp; pp = pp->lcd_listen) {
		register struct sockaddr_x25 *sa2 = pp->lcd_ceaddr;
d428 1
a428 1
	register struct pklcd *lcp;
a429 2
	register struct pklcd **pp;

d438 1
a438 3
		for (pp = &pk_listenhead; *pp;)
			pp = &((*pp)->lcd_listen);
		*pp = lcp;
d440 1
a440 2
		lcp->lcd_listen = pk_listenhead;
		pk_listenhead = lcp;
d452 1
a452 1
	int             (*callee)(struct mbuf *, void *);
d454 3
a456 3
	register struct pklcd *lcp = pk_attach((struct socket *) 0);
	register struct mbuf *nam;
	register struct sockaddr_x25 *sa;
d487 3
a489 3
	register struct pkcb *pkp;
	register struct pklcd *lcp;
	register struct sockaddr_x25 *sa;
d513 2
a514 2
	register struct pklcd *lcp;
	register struct sockaddr_x25 *sa;
d516 3
a518 3
	register struct pkcb *pkp;
	register struct rtentry *rt;
	register struct rtentry *nrt;
d588 1
a588 1
	register struct pkcb *pkp;
d590 3
a592 3
	register struct pklcd *lcp;
	register int    i;
	register int    ni;
d665 2
a666 2
	register struct sockaddr_x25 *sa;
	register struct x25config *xcp;
d668 3
a670 3
	register struct x25_calladdr *a;
	register struct mbuf *m = lcp->lcd_template;
	register struct x25_packet *xp = mtod(m, struct x25_packet *);
d696 1
a696 1
	register struct mbuf *m;
d700 3
a702 3
	register octet *cp;
	register octet *fcp;
	register int    revcharge;
d734 1
a734 1
	register struct bcdinfo *b;
d736 1
a736 1
	register struct x25config *xcp;
d738 1
a738 1
	register char  *x = sa->x25_addr;
d747 1
a747 1
		register char  *p = dnicname;
d778 1
a778 1
	register struct pkcb *pkp;
d780 1
a780 1
	register int    i;
d804 1
a804 1
	register struct pklcd *lcp;
d808 1
a808 1
	register struct mbuf *m = pk_template(lcp->lcd_lcn, X25_CLEAR);
d837 1
a837 1
	register struct pklcd *lcp;
d852 1
a852 1
 * This procedure sends a RESET request packet. It re-initializes virtual
d858 1
a858 1
	register struct pklcd *lcp;
d861 2
a862 2
	register struct mbuf *m;
	register struct socket *so = lcp->lcd_so;
d893 1
a893 1
	register struct pklcd *lcp;
d895 1
a895 1
	register struct socket *so;
d921 1
a921 1
	register struct pklcd *lcp;
d926 1
a926 1
	pk_message(lcp->lcd_lcn, lcp->lcd_pkp->pk_xcp, errstr);
d952 1
a952 1
	register struct socket *so = lcp->lcd_so;
d987 1
a987 1
	register struct x25_packet *xp;
d989 1
a989 1
	register int    type;
d1081 1
a1081 1
	register struct x25_packet *xp;
d1083 2
a1084 2
	register struct x25config *xcp = pkp->pk_xcp;
	register int    lcn = LCN(xp);
d1117 1
a1117 1
	register struct x25_packet *xp;
d1119 1
a1119 1
	register struct pklcd *lcp =
d1121 1
a1121 1
	register int    code = xp->packet_data;
d1148 1
a1148 1
	register struct x25_packet *xp;
d1150 1
a1150 1
	register struct pklcd *lcp =
d1152 1
a1152 1
	register int    code = xp->packet_data;
d1162 1
a1162 1
	register struct x25config *xcp;
d1170 1
d1172 7
d1182 1
a1182 1
	if (lcn) {
d1187 1
a1187 1
	} else if (!PQEMPTY)
d1193 2
a1194 1
	printf("%:\n", fmt, ap);
d1201 1
a1201 1
	register struct pklcd *lcp;
d1204 3
a1206 3
	register struct mbuf *m = m0;
	register struct x25_packet *xp;
	register struct sockbuf *sb;
d1215 1
a1215 1
	m->m_act = 0;
d1228 1
a1228 1
		mp = &m->m_act;
d1244 2
a1245 2
		next = m->m_act;
		m->m_act = 0;
d1255 1
a1255 1
		next = m->m_act;
@


1.1.5.1
log
@Import netccitt from NetBSD of today into vendor branch
XXX could need ANSIfying (__P removal etc.),
XXX but is in general newer than ours
@
text
@d1 2
a2 1
/*	$NetBSD: pk_subr.c,v 1.24 2003/08/07 16:33:04 agc Exp $	*/
d5 3
d13 1
a13 38
 * of the University of British Columbia and the Computer Science
 * Department (IV) of the University of Erlangen-Nuremberg, Germany.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pk_subr.c	8.1 (Berkeley) 6/10/93
 */

/*
 * Copyright (c) 1984 University of British Columbia.
 * Copyright (c) 1992 Computer Science Department IV,
 * 		University of Erlangen-Nuremberg, Germany.
 *
 * This code is derived from software contributed to Berkeley by the
 * Laboratory for Computation Vision and the Computer Science Department
 * of the University of British Columbia and the Computer Science
a46 3
#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD: pk_subr.c,v 1.24 2003/08/07 16:33:04 agc Exp $");

d74 1
a74 1
const struct x25bitslice x25_bitslice[] = {
d88 2
a89 2
static struct x25_ifaddr *pk_ifwithaddr __P((struct sockaddr_x25 *));
static void pk_reset __P((struct pklcd *, int));
d102 2
a103 2
	struct pklcd *lcp;
	int    error = ENOBUFS;
d131 1
a131 1
	struct pklcd *lcp;
d133 2
a134 1
	struct socket *so = lcp->lcd_so;
d138 6
a143 1
		TAILQ_REMOVE(&pk_listenhead, lcp, lcd_listen);
d176 1
a176 1
	struct socket *so = lcp->lcd_so;
d215 2
a216 2
	struct mbuf *m;
	struct x25_packet *xp;
d221 1
a221 1
	m->m_nextpkt = 0;
d251 1
a251 1
	struct pkcb *pkp;
d254 3
a256 3
	struct mbuf *m;
	struct pklcd *lcp;
	int    i;
d302 1
a302 1
	struct pklcd *lcp;
d321 1
a321 1
	struct x25_ifaddr *ia;
d354 2
a355 2
	struct pklcd *pp;
	struct sockaddr_x25 *sa;
d380 2
a381 2
	for (pp = pk_listenhead.tqh_first; pp; pp = pp->lcd_listen.tqe_next) {
		struct sockaddr_x25 *sa2 = pp->lcd_ceaddr;
d398 1
a398 1
	struct pklcd *lcp;
d400 2
d410 3
a412 1
		TAILQ_INSERT_TAIL(&pk_listenhead, lcp, lcd_listen);
d414 2
a415 1
		TAILQ_INSERT_HEAD(&pk_listenhead, lcp, lcd_listen);
d427 1
a427 1
	int             (*callee) __P((struct mbuf *, void *));
d429 3
a431 3
	struct pklcd *lcp = pk_attach((struct socket *) 0);
	struct mbuf *nam;
	struct sockaddr_x25 *sa;
d462 3
a464 3
	struct pkcb *pkp;
	struct pklcd *lcp;
	struct sockaddr_x25 *sa;
d488 2
a489 2
	struct pklcd *lcp;
	struct sockaddr_x25 *sa;
d491 3
a493 3
	struct pkcb *pkp;
	struct rtentry *rt;
	struct rtentry *nrt;
d563 1
a563 1
	struct pkcb *pkp;
d565 3
a567 3
	struct pklcd *lcp;
	int    i;
	int    ni;
d640 2
a641 2
	struct sockaddr_x25 *sa;
	struct x25config *xcp;
d643 3
a645 3
	struct x25_calladdr *a;
	struct mbuf *m = lcp->lcd_template;
	struct x25_packet *xp = mtod(m, struct x25_packet *);
d671 1
a671 1
	struct mbuf *m;
d675 3
a677 3
	octet *cp;
	octet *fcp;
	int    revcharge;
d709 1
a709 1
	struct bcdinfo *b;
d711 1
a711 1
	struct x25config *xcp;
d713 1
a713 1
	char  *x = sa->x25_addr;
d722 1
a722 1
		char  *p = dnicname;
d753 1
a753 1
	struct pkcb *pkp;
d755 1
a755 1
	int    i;
d779 1
a779 1
	struct pklcd *lcp;
d783 1
a783 1
	struct mbuf *m = pk_template(lcp->lcd_lcn, X25_CLEAR);
d812 1
a812 1
	struct pklcd *lcp;
d827 1
a827 1
 * This procedure sends a RESET request packet. It re-intializes virtual
d833 1
a833 1
	struct pklcd *lcp;
d836 2
a837 2
	struct mbuf *m;
	struct socket *so = lcp->lcd_so;
d868 1
a868 1
	struct pklcd *lcp;
d870 1
a870 1
	struct socket *so;
d896 1
a896 1
	struct pklcd *lcp;
d901 1
a901 1
	pk_message(lcp->lcd_lcn, lcp->lcd_pkp->pk_xcp, "%s", errstr);
d927 1
a927 1
	struct socket *so = lcp->lcd_so;
d962 1
a962 1
	struct x25_packet *xp;
d964 1
a964 1
	int    type;
d1056 1
a1056 1
	struct x25_packet *xp;
d1058 2
a1059 2
	struct x25config *xcp = pkp->pk_xcp;
	int    lcn = LCN(xp);
d1092 1
a1092 1
	struct x25_packet *xp;
d1094 1
a1094 1
	struct pklcd *lcp =
d1096 1
a1096 1
	int    code = xp->packet_data;
d1123 1
a1123 1
	struct x25_packet *xp;
d1125 1
a1125 1
	struct pklcd *lcp =
d1127 1
a1127 1
	int    code = xp->packet_data;
d1137 1
a1137 1
	struct x25config *xcp;
a1144 1
#if __STDC__
a1145 7
#else
pk_message(lcn, xcp, fmt, va_alist)
	int             lcn;
	struct x25config *xcp;
	char           *fmt;
	va_dcl
#endif
d1149 1
a1149 1
	if (lcn)
d1154 1
a1154 1
	else if (!PQEMPTY)
d1160 1
a1160 2
	vprintf(fmt, ap);
	printf("\n");
d1167 1
a1167 1
	struct pklcd *lcp;
d1170 3
a1172 3
	struct mbuf *m = m0;
	struct x25_packet *xp;
	struct sockbuf *sb;
d1181 1
a1181 1
	m->m_nextpkt = 0;
d1194 1
a1194 1
		mp = &m->m_nextpkt;
d1210 2
a1211 2
		next = m->m_nextpkt;
		m->m_nextpkt = 0;
d1221 1
a1221 1
		next = m->m_nextpkt;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import latest OpenBSD CVS tree by CTM in order
to sync the base system and ports tree with Them.

This includes the recent licence changes as well - by
importing the changed base and re-applying the diffs
(with cvs up -j -j) they are inherited, and we're not
bound to the removed clauses any longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.8 2003/06/02 23:28:13 millert Exp $	*/
d24 5
a28 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.1.3
log
@Time to import OpenBSD once again. Expect breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.10 2003/12/21 15:30:21 miod Exp $	*/
d98 2
a99 2
	struct pklcd *lcp;
	int    error = ENOBUFS;
d127 1
a127 1
	struct pklcd *lcp;
d129 2
a130 2
	struct socket *so = lcp->lcd_so;
	struct pklcd *l, *p;
d172 1
a172 1
	struct socket *so = lcp->lcd_so;
d211 2
a212 2
	struct mbuf *m;
	struct x25_packet *xp;
d247 1
a247 1
	struct pkcb *pkp;
d250 3
a252 3
	struct mbuf *m;
	struct pklcd *lcp;
	int    i;
d298 1
a298 1
	struct pklcd *lcp;
d317 1
a317 1
	struct x25_ifaddr *ia;
d350 2
a351 2
	struct pklcd *pp;
	struct sockaddr_x25 *sa;
d377 1
a377 1
		struct sockaddr_x25 *sa2 = pp->lcd_ceaddr;
d394 1
a394 1
	struct pklcd *lcp;
d396 1
a396 1
	struct pklcd **pp;
d425 3
a427 3
	struct pklcd *lcp = pk_attach((struct socket *) 0);
	struct mbuf *nam;
	struct sockaddr_x25 *sa;
d458 3
a460 3
	struct pkcb *pkp;
	struct pklcd *lcp;
	struct sockaddr_x25 *sa;
d484 2
a485 2
	struct pklcd *lcp;
	struct sockaddr_x25 *sa;
d487 3
a489 3
	struct pkcb *pkp;
	struct rtentry *rt;
	struct rtentry *nrt;
d559 1
a559 1
	struct pkcb *pkp;
d561 3
a563 3
	struct pklcd *lcp;
	int    i;
	int    ni;
d636 2
a637 2
	struct sockaddr_x25 *sa;
	struct x25config *xcp;
d639 3
a641 3
	struct x25_calladdr *a;
	struct mbuf *m = lcp->lcd_template;
	struct x25_packet *xp = mtod(m, struct x25_packet *);
d667 1
a667 1
	struct mbuf *m;
d671 3
a673 3
	octet *cp;
	octet *fcp;
	int    revcharge;
d705 1
a705 1
	struct bcdinfo *b;
d707 1
a707 1
	struct x25config *xcp;
d709 1
a709 1
	char  *x = sa->x25_addr;
d718 1
a718 1
		char  *p = dnicname;
d749 1
a749 1
	struct pkcb *pkp;
d751 1
a751 1
	int    i;
d775 1
a775 1
	struct pklcd *lcp;
d779 1
a779 1
	struct mbuf *m = pk_template(lcp->lcd_lcn, X25_CLEAR);
d808 1
a808 1
	struct pklcd *lcp;
d829 1
a829 1
	struct pklcd *lcp;
d832 2
a833 2
	struct mbuf *m;
	struct socket *so = lcp->lcd_so;
d864 1
a864 1
	struct pklcd *lcp;
d866 1
a866 1
	struct socket *so;
d892 1
a892 1
	struct pklcd *lcp;
d923 1
a923 1
	struct socket *so = lcp->lcd_so;
d958 1
a958 1
	struct x25_packet *xp;
d960 1
a960 1
	int    type;
d1052 1
a1052 1
	struct x25_packet *xp;
d1054 2
a1055 2
	struct x25config *xcp = pkp->pk_xcp;
	int    lcn = LCN(xp);
d1088 1
a1088 1
	struct x25_packet *xp;
d1090 1
a1090 1
	struct pklcd *lcp =
d1092 1
a1092 1
	int    code = xp->packet_data;
d1119 1
a1119 1
	struct x25_packet *xp;
d1121 1
a1121 1
	struct pklcd *lcp =
d1123 1
a1123 1
	int    code = xp->packet_data;
d1133 1
a1133 1
	struct x25config *xcp;
d1156 1
a1156 1
	vprintf(fmt, ap);
a1157 1
	printf("\n");
d1163 1
a1163 1
	struct pklcd *lcp;
d1166 3
a1168 3
	struct mbuf *m = m0;
	struct x25_packet *xp;
	struct sockbuf *sb;
@


1.1.1.4
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.11 2004/01/03 14:08:53 espie Exp $	*/
d63 1
a63 1
#include <sys/stdarg.h>
@


