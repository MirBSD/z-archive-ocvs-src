head	1.2;
access;
symbols
	gpc-20030830:1.1.2.1 FSF:1.1.2;
locks; strict;
comment	@# @;


1.2
date	2004.01.11.18.35.54;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2004.01.11.18.00.37;	author tg;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.01.11.18.00.37;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@since the gpc people (and others) state gcc 3.3 isn't production quality yet,
let's just play with gpc and the other funky stuff right now, even if that
means still no sparc-gcc3 in current.

also, NO_CXX and friends change from defined/undef'd to yes/no
@
text
@Changes for GCC version 2.8.1 for GNU Pascal

Before applying these diffs, go to the directory gcc-2.8.1
and use the command

    patch -p1

feeding it the following diffs as input.

*** gcc-2.8.1/stor-layout.c.orig	Sat Nov  8 15:12:07 1997
--- gcc-2.8.1/stor-layout.c	Mon Sep 11 11:00:40 2000
***************
*** 19,24 ****
--- 19,26 ----
  Boston, MA 02111-1307, USA.  */
  
  
+ /* @@@@ PATCHED FOR GPC 20030218 @@@@ */
+
  #include "config.h"
  #include <stdio.h>
  
***************
*** 51,56 ****
--- 53,71 ----
     May be overridden by front-ends.  */
  int set_alignment = 0;
  
+ #ifdef GPC
+ /* The word size of a bitstring or (power-)set value, in bits.
+    Must be non-zero.
+    May be overridden by front-ends.  */
+ int set_word_size = BITS_PER_UNIT;
+ 
+ /* If non-zero, bits in (power-)sets start with the highest bit.
+    May be overridden by front-ends.
+    In order to be backward-compatible, the Chill frontend should
+    initialize this to BYTES_BIG_ENDIAN.  */
+ int set_words_big_endian = 0;
+ #endif /* GPC */
+ 
  static enum machine_mode smallest_mode_for_size  PROTO((unsigned int,
  							enum mode_class));
  static tree layout_record	PROTO((tree));
***************
*** 962,973 ****
--- 977,1003 ----
  #ifndef SET_WORD_SIZE
  #define SET_WORD_SIZE BITS_PER_WORD
  #endif
+ #ifdef GPC
+           int alignment = set_alignment ? set_alignment : set_word_size;
+           int lower_bound = TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (type)));
+           int upper_bound = TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)));
+           int size_in_bits, rounded_size;
+           if (set_alignment)
+             size_in_bits = upper_bound - (lower_bound / alignment) * alignment + 1;
+           else
+             size_in_bits
+               = (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))
+                  - TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) + 1);
+           rounded_size
+             = ((size_in_bits + alignment - 1) / alignment) * alignment;
+ #else /* not GPC */
  	  int alignment = set_alignment ? set_alignment : SET_WORD_SIZE;
  	  int size_in_bits
  	    = (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))
  	       - TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) + 1);
  	  int rounded_size
  	    = ((size_in_bits + alignment - 1) / alignment) * alignment;
+ #endif /* not GPC */
  	  if (rounded_size > alignment)
  	    TYPE_MODE (type) = BLKmode;
  	  else
*** gcc-2.8.1/Makefile.in.orig	Tue Mar  3 02:54:31 1998
--- gcc-2.8.1/Makefile.in	Mon Sep 11 11:00:40 2000
***************
*** 189,194 ****
--- 189,196 ----
  PREMADE_ATTRTAB_MD = Makefile  # Guaranteed not to cmp equal to md.
  PREMADE_ATTRTAB = 
  
+ build=@@build@@
+ host=@@host@@
  target=@@target@@
  target_alias=@@target_alias@@
  xmake_file=@@dep_host_xmake_file@@
***************
*** 369,375 ****
  
  # List of things which should already be built whenever we try to use xgcc
  # to compile anything (without linking).
! GCC_PASSES=xgcc cc1 cpp $(EXTRA_PASSES)
  
  # List of things which should already be built whenever we try to use xgcc
  # to link anything.
--- 371,377 ----
  
  # List of things which should already be built whenever we try to use xgcc
  # to compile anything (without linking).
! GCC_PASSES=xgcc$(exeext) cc1$(exeext) cpp$(exeext) $(EXTRA_PASSES)
  
  # List of things which should already be built whenever we try to use xgcc
  # to link anything.
***************
*** 544,549 ****
--- 546,555 ----
  	"RANLIB_TEST_FOR_TARGET=$(RANLIB_TEST_FOR_TARGET)" \
  	"SHELL=$(SHELL)" \
  	"STAGE_PREFIX=@@stage_prefix_set_by_configure@@" \
+ 	"target_alias=$(target_alias)" \
+ 	"program_transform_name=$(program_transform_name)" \
+ 	"program_transform_cross_name=$(program_transform_cross_name)" \
+ 	"version=$(version)" \
  	"exeext=$(exeext)" \
  	"objext=$(objext)" \
  	"exec_prefix=$(exec_prefix)" \
***************
*** 729,746 ****
  all.cross: native gcc-cross specs stmp-headers $(LIBGCC) $(STMP_FIXPROTO) \
  	$(LIBGCC1_TEST) $(EXTRA_PARTS) lang.all.cross
  # This is what to compile if making gcc with a cross-compiler.
! all.build: native xgcc $(EXTRA_PARTS) lang.all.build
  # This is what must be made before installing GCC and converting libraries.
! start.encap: native xgcc specs $(LIBGCC1) xlimits.h lang.start.encap
  # These can't be made until after GCC can run.
  rest.encap: stmp-headers $(LIBGCC) $(STMP_FIXPROTO) $(EXTRA_PARTS) lang.rest.encap
  # This is what is made with the host's compiler
  # whether making a cross compiler or not.
! native: config.status auto-config.h cpp $(LANGUAGES) \
  	$(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(USE_COLLECT2)
  
  # Define the names for selecting languages in LANGUAGES.
! C c: cc1
  PROTO: proto
  
  # Tell GNU make these are phony targets.
--- 735,752 ----
  all.cross: native gcc-cross specs stmp-headers $(LIBGCC) $(STMP_FIXPROTO) \
  	$(LIBGCC1_TEST) $(EXTRA_PARTS) lang.all.cross
  # This is what to compile if making gcc with a cross-compiler.
! all.build: native xgcc$(exeext) $(EXTRA_PARTS) lang.all.build
  # This is what must be made before installing GCC and converting libraries.
! start.encap: native xgcc$(exeext) specs $(LIBGCC1) xlimits.h lang.start.encap
  # These can't be made until after GCC can run.
  rest.encap: stmp-headers $(LIBGCC) $(STMP_FIXPROTO) $(EXTRA_PARTS) lang.rest.encap
  # This is what is made with the host's compiler
  # whether making a cross compiler or not.
! native: config.status auto-config.h cpp$(exeext) $(LANGUAGES) \
  	$(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(USE_COLLECT2)
  
  # Define the names for selecting languages in LANGUAGES.
! C c: cc1$(exeext)
  PROTO: proto
  
  # Tell GNU make these are phony targets.
***************
*** 756,762 ****
  	@@echo "Testing libgcc1.  Ignore linker warning messages."
  	$(GCC_FOR_TARGET) $(GCC_CFLAGS) libgcc1-test.o -o libgcc1-test \
  	  -nostartfiles -nostdlib `$(GCC_FOR_TARGET) --print-libgcc-file-name`
! libgcc1-test.o: libgcc1-test.c native xgcc
  	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) -c $(srcdir)/libgcc1-test.c
  
  # Recompile all the language-independent object files.
--- 762,768 ----
  	@@echo "Testing libgcc1.  Ignore linker warning messages."
  	$(GCC_FOR_TARGET) $(GCC_CFLAGS) libgcc1-test.o -o libgcc1-test \
  	  -nostartfiles -nostdlib `$(GCC_FOR_TARGET) --print-libgcc-file-name`
! libgcc1-test.o: libgcc1-test.c native xgcc$(exeext)
  	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) -c $(srcdir)/libgcc1-test.c
  
  # Recompile all the language-independent object files.
***************
*** 771,793 ****
  # We call this executable `xgcc' rather than `gcc'
  # to avoid confusion if the current directory is in the path
  # and CC is `gcc'.  It is renamed to `gcc' when it is installed.
! xgcc: gcc.o version.o choose-temp.o pexecute.o prefix.o version.o \
     $(LIBDEPS) $(EXTRA_GCC_OBJS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@@ gcc.o prefix.o version.o \
  	  choose-temp.o pexecute.o $(EXTRA_GCC_OBJS) $(LIBS)
  
  # Dump a specs file to make -B./ read these specs over installed ones.
! specs: xgcc
  	$(GCC_FOR_TARGET) -dumpspecs > tmp-specs
! 	mv tmp-specs specs
  
  # We do want to create an executable named `xgcc', so we can use it to
  # compile libgcc2.a.
  # Also create gcc-cross, so that install-common will install properly.
! gcc-cross: xgcc
  	cp xgcc$(exeext) gcc-cross$(exeext)
  
! cc1: $(P) $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBDEPS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@@ $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBS)
  
  # Copy float.h from its source.
--- 777,803 ----
  # We call this executable `xgcc' rather than `gcc'
  # to avoid confusion if the current directory is in the path
  # and CC is `gcc'.  It is renamed to `gcc' when it is installed.
! xgcc$(exeext): gcc.o version.o choose-temp.o pexecute.o prefix.o version.o \
     $(LIBDEPS) $(EXTRA_GCC_OBJS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@@ gcc.o prefix.o version.o \
  	  choose-temp.o pexecute.o $(EXTRA_GCC_OBJS) $(LIBS)
  
  # Dump a specs file to make -B./ read these specs over installed ones.
! specs: xgcc$(exeext)
  	$(GCC_FOR_TARGET) -dumpspecs > tmp-specs
! 	if [ $(target) = $(host) ]; \
!         then sed -e '/^\*cross_compile:/,/^$$/s/^[01]/0/'; \
! 	else sed -e '/^\*cross_compile:/,/^$$/s/^[01]/1/'; \
!         fi < tmp-specs > specs
! 	rm tmp-specs
  
  # We do want to create an executable named `xgcc', so we can use it to
  # compile libgcc2.a.
  # Also create gcc-cross, so that install-common will install properly.
! gcc-cross: xgcc$(exeext)
  	cp xgcc$(exeext) gcc-cross$(exeext)
  
! cc1$(exeext): $(P) $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBDEPS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@@ $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBS)
  
  # Copy float.h from its source.
***************
*** 851,856 ****
--- 861,867 ----
  libgcc1.null: $(GCC_PASSES)
  	echo "__foo () {}" > dummy.c
  	$(GCC_FOR_TARGET) $(GCC_CFLAGS) -c dummy.c
+ 	rm -f libgcc1.null
  	$(OLDAR) $(OLDAR_FLAGS) libgcc1.null dummy$(objext)
  	rm -f dummy$(objext) dummy.c
  
***************
*** 1739,1749 ****
  # Remake cpp and protoize.
  
  # Making the preprocessor
! cpp: $(CCCP)
  	-rm -f cpp$(exeext)
  	ln $(CCCP)$(exeext) cpp$(exeext) > /dev/null 2>&1 \
  	 || cp $(CCCP)$(exeext) cpp$(exeext)
! cccp: cccp.o cexp.o version.o prefix.o $(LIBDEPS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@@ cccp.o cexp.o prefix.o \
  	  version.o $(LIBS)
  cexp.o: $(srcdir)/cexp.c $(CONFIG_H)
--- 1750,1760 ----
  # Remake cpp and protoize.
  
  # Making the preprocessor
! cpp$(exeext): $(CCCP)$(exeext)
  	-rm -f cpp$(exeext)
  	ln $(CCCP)$(exeext) cpp$(exeext) > /dev/null 2>&1 \
  	 || cp $(CCCP)$(exeext) cpp$(exeext)
! cccp$(exeext): cccp.o cexp.o version.o prefix.o $(LIBDEPS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@@ cccp.o cexp.o prefix.o \
  	  version.o $(LIBS)
  cexp.o: $(srcdir)/cexp.c $(CONFIG_H)
***************
*** 2248,2254 ****
  
  # Install the driver program as $(target_alias)-gcc
  # and also as either gcc (if native) or $(tooldir)/bin/gcc.
! install-driver: xgcc
  	-if [ -f gcc-cross$(exeext) ] ; then \
  	  rm -f $(bindir)/$(GCC_CROSS_NAME)$(exeext); \
  	  $(INSTALL_PROGRAM) gcc-cross$(exeext) $(bindir)/$(GCC_CROSS_NAME)$(exeext); \
--- 2259,2265 ----
  
  # Install the driver program as $(target_alias)-gcc
  # and also as either gcc (if native) or $(tooldir)/bin/gcc.
! install-driver: xgcc$(exeext)
  	-if [ -f gcc-cross$(exeext) ] ; then \
  	  rm -f $(bindir)/$(GCC_CROSS_NAME)$(exeext); \
  	  $(INSTALL_PROGRAM) gcc-cross$(exeext) $(bindir)/$(GCC_CROSS_NAME)$(exeext); \
*** gcc-2.8.1/acconfig.h.orig	Tue Feb  3 21:52:21 1998
--- gcc-2.8.1/acconfig.h	Mon Sep 11 11:00:40 2000
***************
*** 1,3 ****
--- 1,6 ----
+ /* Define if you can safely include both <string.h> and <strings.h>.  */
+ #undef STRING_WITH_STRINGS
+ 
  /* Define if you have a working <inttypes.h> header file.  */
  #undef HAVE_INTTYPES_H
  
*** gcc-2.8.1/aclocal.m4.orig	Sat Nov 22 12:55:05 1997
--- gcc-2.8.1/aclocal.m4	Mon Sep 11 11:00:40 2000
***************
*** 1,3 ****
--- 1,14 ----
+ dnl See whether we can include both string.h and strings.h.
+ AC_DEFUN(GCC_HEADER_STRING,
+ [AC_CACHE_CHECK([whether string.h and strings.h may both be included],
+   gcc_cv_header_string,
+ [AC_TRY_COMPILE([#include <string.h>
+ #include <strings.h>], , gcc_cv_header_string=yes, gcc_cv_header_string=no)])
+ if test $gcc_cv_header_string = yes; then
+   AC_DEFINE(STRING_WITH_STRINGS)
+ fi
+ ])
+ 
  dnl See whether we need a declaration for a function.
  AC_DEFUN(GCC_NEED_DECLARATION,
  [AC_MSG_CHECKING([whether $1 must be declared])
*** gcc-2.8.1/ansidecl.h.orig	Mon Sep 11 20:46:33 2000
--- gcc-2.8.1/ansidecl.h	Mon Sep 11 11:00:40 2000
***************
*** 0 ****
--- 1,489 ----
+ /* ANSI and traditional C compatability macros
+    Copyright 1991, 1992, 1996 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ 
+ /* ANSI and traditional C compatibility macros
+ 
+    ANSI C is assumed if __STDC__ is #defined.
+ 
+    Macro	ANSI C definition	Traditional C definition
+    -----	---- - ----------	----------- - ----------
+    PTR		`void *'		`char *'
+    LONG_DOUBLE	`long double'		`double'
+    VOLATILE	`volatile'		`'
+    SIGNED	`signed'		`'
+    PTRCONST	`void *const'		`char *'
+    ANSI_PROTOTYPES  1			not defined
+ 
+    CONST is also defined, but is obsolete.  Just use const.
+ 
+    obsolete --     DEFUN (name, arglist, args)
+ 
+ 	Defines function NAME.
+ 
+ 	ARGLIST lists the arguments, separated by commas and enclosed in
+ 	parentheses.  ARGLIST becomes the argument list in traditional C.
+ 
+ 	ARGS list the arguments with their types.  It becomes a prototype in
+ 	ANSI C, and the type declarations in traditional C.  Arguments should
+ 	be separated with `AND'.  For functions with a variable number of
+ 	arguments, the last thing listed should be `DOTS'.
+ 
+    obsolete --     DEFUN_VOID (name)
+ 
+ 	Defines a function NAME, which takes no arguments.
+ 
+    obsolete --     EXFUN (name, (prototype))	-- obsolete.
+ 
+ 	Replaced by PARAMS.  Do not use; will disappear someday soon.
+ 	Was used in external function declarations.
+ 	In ANSI C it is `NAME PROTOTYPE' (so PROTOTYPE should be enclosed in
+ 	parentheses).  In traditional C it is `NAME()'.
+ 	For a function that takes no arguments, PROTOTYPE should be `(void)'.
+ 
+    obsolete --     PROTO (type, name, (prototype)    -- obsolete.
+ 
+ 	This one has also been replaced by PARAMS.  Do not use.
+ 
+    PARAMS ((args))
+ 
+ 	We could use the EXFUN macro to handle prototype declarations, but
+ 	the name is misleading and the result is ugly.  So we just define a
+ 	simple macro to handle the parameter lists, as in:
+ 
+ 	      static int foo PARAMS ((int, char));
+ 
+ 	This produces:  `static int foo();' or `static int foo (int, char);'
+ 
+ 	EXFUN would have done it like this:
+ 
+ 	      static int EXFUN (foo, (int, char));
+ 
+ 	but the function is not external...and it's hard to visually parse
+ 	the function name out of the mess.   EXFUN should be considered
+ 	obsolete; new code should be written to use PARAMS.
+ 
+    DOTS is also obsolete.
+ 
+    Examples:
+ 
+ 	extern int printf PARAMS ((const char *format, ...));
+ */
+ 
+ #ifndef	_ANSIDECL_H
+ 
+ #define	_ANSIDECL_H	1
+ 
+ 
+ /* Every source file includes this file,
+    so they will all get the switch for lint.  */
+ /* LINTLIBRARY */
+ 
+ 
+ #if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)
+ /* All known AIX compilers implement these things (but don't always
+    define __STDC__).  The RISC/OS MIPS compiler defines these things
+    in SVR4 mode, but does not define __STDC__.  */
+ 
+ #define	PTR		void *
+ #define	PTRCONST	void *CONST
+ #define	LONG_DOUBLE	long double
+ 
+ #ifndef IN_GCC
+ #define	AND		,
+ #define	NOARGS		void
+ #define	VOLATILE	volatile
+ #define	SIGNED		signed
+ #endif /* !IN_GCC */
+ 
+ #define PARAMS(paramlist)		paramlist
+ #define ANSI_PROTOTYPES			1
+ 
+ #define VPARAMS(ARGS)			ARGS
+ #define VA_START(va_list,var)		va_start(va_list,var)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST				const
+ #define DOTS				, ...
+ #define PROTO(type, name, arglist)	type name arglist
+ #define EXFUN(name, proto)		name proto
+ #define DEFUN(name, arglist, args)	name(args)
+ #define DEFUN_VOID(name)		name(void)
+ #endif /* !IN_GCC */
+ 
+ #else	/* Not ANSI C.  */
+ 
+ #define	PTR		char *
+ #define	PTRCONST	PTR
+ #define	LONG_DOUBLE	double
+ 
+ #ifndef IN_GCC
+ #define	AND		;
+ #define	NOARGS
+ #define	VOLATILE
+ #define	SIGNED
+ #endif /* !IN_GCC */
+ 
+ #ifndef const /* some systems define it in header files for non-ansi mode */
+ #define	const
+ #endif
+ 
+ #define PARAMS(paramlist)		()
+ 
+ #define VPARAMS(ARGS)			(va_alist) va_dcl
+ #define VA_START(va_list,var)		va_start(va_list)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST
+ #define DOTS
+ #define PROTO(type, name, arglist)	type name ()
+ #define EXFUN(name, proto)		name()
+ #define DEFUN(name, arglist, args)	name arglist args;
+ #define DEFUN_VOID(name)		name()
+ #endif /* !IN_GCC */
+ 
+ #endif	/* ANSI C.  */
+ 
+ #endif	/* ansidecl.h	*/
+ /* ANSI and traditional C compatability macros
+    Copyright 1991, 1992, 1996 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ 
+ /* ANSI and traditional C compatibility macros
+ 
+    ANSI C is assumed if __STDC__ is #defined.
+ 
+    Macro	ANSI C definition	Traditional C definition
+    -----	---- - ----------	----------- - ----------
+    PTR		`void *'		`char *'
+    LONG_DOUBLE	`long double'		`double'
+    VOLATILE	`volatile'		`'
+    SIGNED	`signed'		`'
+    PTRCONST	`void *const'		`char *'
+    ANSI_PROTOTYPES  1			not defined
+ 
+    CONST is also defined, but is obsolete.  Just use const.
+ 
+    obsolete --     DEFUN (name, arglist, args)
+ 
+ 	Defines function NAME.
+ 
+ 	ARGLIST lists the arguments, separated by commas and enclosed in
+ 	parentheses.  ARGLIST becomes the argument list in traditional C.
+ 
+ 	ARGS list the arguments with their types.  It becomes a prototype in
+ 	ANSI C, and the type declarations in traditional C.  Arguments should
+ 	be separated with `AND'.  For functions with a variable number of
+ 	arguments, the last thing listed should be `DOTS'.
+ 
+    obsolete --     DEFUN_VOID (name)
+ 
+ 	Defines a function NAME, which takes no arguments.
+ 
+    obsolete --     EXFUN (name, (prototype))	-- obsolete.
+ 
+ 	Replaced by PARAMS.  Do not use; will disappear someday soon.
+ 	Was used in external function declarations.
+ 	In ANSI C it is `NAME PROTOTYPE' (so PROTOTYPE should be enclosed in
+ 	parentheses).  In traditional C it is `NAME()'.
+ 	For a function that takes no arguments, PROTOTYPE should be `(void)'.
+ 
+    obsolete --     PROTO (type, name, (prototype)    -- obsolete.
+ 
+ 	This one has also been replaced by PARAMS.  Do not use.
+ 
+    PARAMS ((args))
+ 
+ 	We could use the EXFUN macro to handle prototype declarations, but
+ 	the name is misleading and the result is ugly.  So we just define a
+ 	simple macro to handle the parameter lists, as in:
+ 
+ 	      static int foo PARAMS ((int, char));
+ 
+ 	This produces:  `static int foo();' or `static int foo (int, char);'
+ 
+ 	EXFUN would have done it like this:
+ 
+ 	      static int EXFUN (foo, (int, char));
+ 
+ 	but the function is not external...and it's hard to visually parse
+ 	the function name out of the mess.   EXFUN should be considered
+ 	obsolete; new code should be written to use PARAMS.
+ 
+    DOTS is also obsolete.
+ 
+    Examples:
+ 
+ 	extern int printf PARAMS ((const char *format, ...));
+ */
+ 
+ #ifndef	_ANSIDECL_H
+ 
+ #define	_ANSIDECL_H	1
+ 
+ 
+ /* Every source file includes this file,
+    so they will all get the switch for lint.  */
+ /* LINTLIBRARY */
+ 
+ 
+ #if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)
+ /* All known AIX compilers implement these things (but don't always
+    define __STDC__).  The RISC/OS MIPS compiler defines these things
+    in SVR4 mode, but does not define __STDC__.  */
+ 
+ #define	PTR		void *
+ #define	PTRCONST	void *CONST
+ #define	LONG_DOUBLE	long double
+ 
+ #ifndef IN_GCC
+ #define	AND		,
+ #define	NOARGS		void
+ #define	VOLATILE	volatile
+ #define	SIGNED		signed
+ #endif /* !IN_GCC */
+ 
+ #define PARAMS(paramlist)		paramlist
+ #define ANSI_PROTOTYPES			1
+ 
+ #define VPARAMS(ARGS)			ARGS
+ #define VA_START(va_list,var)		va_start(va_list,var)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST				const
+ #define DOTS				, ...
+ #define PROTO(type, name, arglist)	type name arglist
+ #define EXFUN(name, proto)		name proto
+ #define DEFUN(name, arglist, args)	name(args)
+ #define DEFUN_VOID(name)		name(void)
+ #endif /* !IN_GCC */
+ 
+ #else	/* Not ANSI C.  */
+ 
+ #define	PTR		char *
+ #define	PTRCONST	PTR
+ #define	LONG_DOUBLE	double
+ 
+ #ifndef IN_GCC
+ #define	AND		;
+ #define	NOARGS
+ #define	VOLATILE
+ #define	SIGNED
+ #endif /* !IN_GCC */
+ 
+ #ifndef const /* some systems define it in header files for non-ansi mode */
+ #define	const
+ #endif
+ 
+ #define PARAMS(paramlist)		()
+ 
+ #define VPARAMS(ARGS)			(va_alist) va_dcl
+ #define VA_START(va_list,var)		va_start(va_list)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST
+ #define DOTS
+ #define PROTO(type, name, arglist)	type name ()
+ #define EXFUN(name, proto)		name()
+ #define DEFUN(name, arglist, args)	name arglist args;
+ #define DEFUN_VOID(name)		name()
+ #endif /* !IN_GCC */
+ 
+ #endif	/* ANSI C.  */
+ 
+ #endif	/* ansidecl.h	*/
+ /* ANSI and traditional C compatability macros
+    Copyright 1991, 1992, 1996 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ 
+ /* ANSI and traditional C compatibility macros
+ 
+    ANSI C is assumed if __STDC__ is #defined.
+ 
+    Macro	ANSI C definition	Traditional C definition
+    -----	---- - ----------	----------- - ----------
+    PTR		`void *'		`char *'
+    LONG_DOUBLE	`long double'		`double'
+    VOLATILE	`volatile'		`'
+    SIGNED	`signed'		`'
+    PTRCONST	`void *const'		`char *'
+    ANSI_PROTOTYPES  1			not defined
+ 
+    CONST is also defined, but is obsolete.  Just use const.
+ 
+    obsolete --     DEFUN (name, arglist, args)
+ 
+ 	Defines function NAME.
+ 
+ 	ARGLIST lists the arguments, separated by commas and enclosed in
+ 	parentheses.  ARGLIST becomes the argument list in traditional C.
+ 
+ 	ARGS list the arguments with their types.  It becomes a prototype in
+ 	ANSI C, and the type declarations in traditional C.  Arguments should
+ 	be separated with `AND'.  For functions with a variable number of
+ 	arguments, the last thing listed should be `DOTS'.
+ 
+    obsolete --     DEFUN_VOID (name)
+ 
+ 	Defines a function NAME, which takes no arguments.
+ 
+    obsolete --     EXFUN (name, (prototype))	-- obsolete.
+ 
+ 	Replaced by PARAMS.  Do not use; will disappear someday soon.
+ 	Was used in external function declarations.
+ 	In ANSI C it is `NAME PROTOTYPE' (so PROTOTYPE should be enclosed in
+ 	parentheses).  In traditional C it is `NAME()'.
+ 	For a function that takes no arguments, PROTOTYPE should be `(void)'.
+ 
+    obsolete --     PROTO (type, name, (prototype)    -- obsolete.
+ 
+ 	This one has also been replaced by PARAMS.  Do not use.
+ 
+    PARAMS ((args))
+ 
+ 	We could use the EXFUN macro to handle prototype declarations, but
+ 	the name is misleading and the result is ugly.  So we just define a
+ 	simple macro to handle the parameter lists, as in:
+ 
+ 	      static int foo PARAMS ((int, char));
+ 
+ 	This produces:  `static int foo();' or `static int foo (int, char);'
+ 
+ 	EXFUN would have done it like this:
+ 
+ 	      static int EXFUN (foo, (int, char));
+ 
+ 	but the function is not external...and it's hard to visually parse
+ 	the function name out of the mess.   EXFUN should be considered
+ 	obsolete; new code should be written to use PARAMS.
+ 
+    DOTS is also obsolete.
+ 
+    Examples:
+ 
+ 	extern int printf PARAMS ((const char *format, ...));
+ */
+ 
+ #ifndef	_ANSIDECL_H
+ 
+ #define	_ANSIDECL_H	1
+ 
+ 
+ /* Every source file includes this file,
+    so they will all get the switch for lint.  */
+ /* LINTLIBRARY */
+ 
+ 
+ #if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)
+ /* All known AIX compilers implement these things (but don't always
+    define __STDC__).  The RISC/OS MIPS compiler defines these things
+    in SVR4 mode, but does not define __STDC__.  */
+ 
+ #define	PTR		void *
+ #define	PTRCONST	void *CONST
+ #define	LONG_DOUBLE	long double
+ 
+ #ifndef IN_GCC
+ #define	AND		,
+ #define	NOARGS		void
+ #define	VOLATILE	volatile
+ #define	SIGNED		signed
+ #endif /* !IN_GCC */
+ 
+ #define PARAMS(paramlist)		paramlist
+ #define ANSI_PROTOTYPES			1
+ 
+ #define VPARAMS(ARGS)			ARGS
+ #define VA_START(va_list,var)		va_start(va_list,var)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST				const
+ #define DOTS				, ...
+ #define PROTO(type, name, arglist)	type name arglist
+ #define EXFUN(name, proto)		name proto
+ #define DEFUN(name, arglist, args)	name(args)
+ #define DEFUN_VOID(name)		name(void)
+ #endif /* !IN_GCC */
+ 
+ #else	/* Not ANSI C.  */
+ 
+ #define	PTR		char *
+ #define	PTRCONST	PTR
+ #define	LONG_DOUBLE	double
+ 
+ #ifndef IN_GCC
+ #define	AND		;
+ #define	NOARGS
+ #define	VOLATILE
+ #define	SIGNED
+ #endif /* !IN_GCC */
+ 
+ #ifndef const /* some systems define it in header files for non-ansi mode */
+ #define	const
+ #endif
+ 
+ #define PARAMS(paramlist)		()
+ 
+ #define VPARAMS(ARGS)			(va_alist) va_dcl
+ #define VA_START(va_list,var)		va_start(va_list)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST
+ #define DOTS
+ #define PROTO(type, name, arglist)	type name ()
+ #define EXFUN(name, proto)		name()
+ #define DEFUN(name, arglist, args)	name arglist args;
+ #define DEFUN_VOID(name)		name()
+ #endif /* !IN_GCC */
+ 
+ #endif	/* ANSI C.  */
+ 
+ #endif	/* ansidecl.h	*/
*** gcc-2.8.1/config.in.orig	Fri Feb  6 19:51:33 1998
--- gcc-2.8.1/config.in	Mon Sep 11 11:00:40 2000
***************
*** 1,4 ****
--- 1,7 ----
  /* config.in.  Generated automatically from configure.in by autoheader.  */
+ /* Define if you can safely include both <string.h> and <strings.h>.  */
+ #undef STRING_WITH_STRINGS
+ 
  /* Define if you have a working <inttypes.h> header file.  */
  #undef HAVE_INTTYPES_H
  
*** gcc-2.8.1/configure.in.orig	Sat Feb 28 21:58:12 1998
--- gcc-2.8.1/configure.in	Mon Sep 11 11:00:40 2000
***************
*** 134,139 ****
--- 134,140 ----
  
  AC_HEADER_STDC
  AC_HEADER_TIME
+ GCC_HEADER_STRING
  AC_CHECK_HEADERS(limits.h stddef.h string.h strings.h stdlib.h time.h fcntl.h unistd.h sys/file.h sys/time.h sys/resource.h sys/param.h sys/times.h)
  
  # Use <inttypes.h> only if it exists,
*** gcc-2.8.1/convert.c.orig	Thu Aug  7 12:44:17 1997
--- gcc-2.8.1/convert.c	Mon Sep 11 11:00:40 2000
***************
*** 288,294 ****
--- 288,299 ----
  
  		/* Can't do arithmetic in enumeral types
  		   so use an integer type that will hold the values.  */
+ #ifdef GPC
+ 		if (TREE_CODE (typex) == ENUMERAL_TYPE
+ 		    || TREE_CODE (typex) == BOOLEAN_TYPE)
+ #else /* not GPC */
  		if (TREE_CODE (typex) == ENUMERAL_TYPE)
+ #endif /* not GPC */
  		  typex = type_for_size (TYPE_PRECISION (typex),
  					 TREE_UNSIGNED (typex));
  
***************
*** 326,332 ****
--- 331,343 ----
  
  	    /* Can't do arithmetic in enumeral types
  	       so use an integer type that will hold the values.  */
+ #ifdef GPC
+ 	    if (TREE_CODE (typex) == ENUMERAL_TYPE
+ 		|| TREE_CODE (typex) == CHAR_TYPE
+ 		|| TREE_CODE (typex) == BOOLEAN_TYPE)
+ #else /* not GPC */
  	    if (TREE_CODE (typex) == ENUMERAL_TYPE)
+ #endif /* not GPC */
  	      typex = type_for_size (TYPE_PRECISION (typex),
  				     TREE_UNSIGNED (typex));
  
*** gcc-2.8.1/demangle.h.orig	Wed Jul 30 21:02:03 1997
--- gcc-2.8.1/demangle.h	Mon Sep 11 11:00:40 2000
***************
*** 22,28 ****
  
  #ifdef IN_GCC
  #include "gansidecl.h"
- #define PARAMS(ARGS) PROTO(ARGS)
  #else /* ! IN_GCC */
  #include <ansidecl.h>
  #endif /* IN_GCC */
--- 22,27 ----
*** gcc-2.8.1/dwarfout.h.orig	Mon Sep 11 20:46:33 2000
--- gcc-2.8.1/dwarfout.h	Mon Sep 11 11:00:40 2000
***************
*** 0 ****
--- 1,4 ----
+ extern void dwarfout_define PARAMS((register unsigned, register char *));
+ extern void dwarfout_undef PARAMS((register unsigned, register char *));
+ extern void dwarfout_start_new_source_file PARAMS((register char *));
+ extern void dwarfout_resume_previous_source_file PARAMS((register unsigned));
*** gcc-2.8.1/expr.c.orig	Wed Mar  4 03:32:19 1998
--- gcc-2.8.1/expr.c	Mon Sep 11 11:00:40 2000
***************
*** 3961,3966 ****
--- 3961,3973 ----
  
        domain_min = convert (sizetype, TYPE_MIN_VALUE (domain));
        domain_max = convert (sizetype, TYPE_MAX_VALUE (domain));
+ 
+ #ifdef GPC
+       /* Align the set.  */
+       if (set_alignment)
+         domain_min = size_binop (BIT_AND_EXPR, domain_min, size_int (-set_alignment));
+ #endif /* GPC */
+ 
        bitlength = size_binop (PLUS_EXPR,
  			      size_binop (MINUS_EXPR, domain_max, domain_min),
  			      size_one_node);
***************
*** 3975,3981 ****
--- 3982,3990 ----
        if (GET_MODE (target) != BLKmode || nbits <= 2 * BITS_PER_WORD
  	  || (nbytes <= 32 && TREE_CHAIN (elt) != NULL_TREE))
  	{
+ #ifndef GPC
  	  int set_word_size = TYPE_ALIGN (TREE_TYPE (exp));
+ #endif /* not GPC */
  	  enum machine_mode mode = mode_for_size (set_word_size, MODE_INT, 1);
  	  char *bit_buffer = (char *) alloca (nbits);
  	  HOST_WIDE_INT word = 0;
***************
*** 3987,3993 ****
--- 3996,4006 ----
  	    {
  	      if (bit_buffer[ibit])
  		{
+ #ifdef GPC
+                   if (set_words_big_endian)
+ #else /* not GPC */
  		  if (BYTES_BIG_ENDIAN)
+ #endif /* not GPC */
  		    word |= (1 << (set_word_size - 1 - bit_pos));
  		  else
  		    word |= 1 << bit_pos;
***************
*** 4087,4092 ****
--- 4100,4111 ----
  	      && (startb = TREE_INT_CST_LOW (startbit)) % BITS_PER_UNIT == 0
  	      && (endb = TREE_INT_CST_LOW (endbit) + 1) % BITS_PER_UNIT == 0)
  	    {
+ #ifdef GPC
+               /* The language-specific run time library must provide
+                  a suitable `__setbits()' function whose action coincides
+                  with the values of `set_word_size', `set_alignment', and
+                  `set_words_big_endian'.  */
+ #endif /* GPC */
  	      emit_library_call (memset_libfunc, 0,
  				 VOIDmode, 3,
  				 plus_constant (XEXP (targetx, 0),
***************
*** 5453,5458 ****
--- 5472,5491 ----
  	 store directly into the target unless the type is large enough
  	 that memcpy will be used.  If we are making an initializer and
  	 all operands are constant, put it in memory as well.  */
+ #ifdef GPC
+       else if (TREE_CODE (TREE_TYPE (exp)) != SET_TYPE
+ 	       &&
+ 	       ((TREE_STATIC (exp)
+ 		&& ((mode == BLKmode
+ 		     && !(target != 0 && safe_from_p (target, exp, 1)))
+ 		    || TREE_ADDRESSABLE (exp)
+ 		    || (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST
+ 			&& (move_by_pieces_ninsns
+ 			    (TREE_INT_CST_LOW (TYPE_SIZE (type)),
+ 			     TYPE_ALIGN (type))
+ 			    > MOVE_RATIO))))
+ 	       || (modifier == EXPAND_INITIALIZER && TREE_CONSTANT (exp))))
+ #else /* not GPC */
        else if ((TREE_STATIC (exp)
  		&& ((mode == BLKmode
  		     && ! (target != 0 && safe_from_p (target, exp, 1)))
***************
*** 5464,5469 ****
--- 5497,5503 ----
  			    > MOVE_RATIO)
  			&& ! mostly_zeros_p (exp))))
  	       || (modifier == EXPAND_INITIALIZER && TREE_CONSTANT (exp)))
+ #endif /* not GPC */
  	{
  	  rtx constructor = output_constant_def (exp);
  	  if (modifier != EXPAND_CONST_ADDRESS
***************
*** 9085,9091 ****
  	  || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))
  	      != INTEGER_TYPE)
  	  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0
! 	  || (INTEGER_CST
  	      != (TREE_CODE (TREE_TYPE
  			     (TREE_VALUE
  			      (TREE_CHAIN (TREE_CHAIN (arglist))))))))
--- 9085,9091 ----
  	  || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))
  	      != INTEGER_TYPE)
  	  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0
! 	  || (INTEGER_TYPE
  	      != (TREE_CODE (TREE_TYPE
  			     (TREE_VALUE
  			      (TREE_CHAIN (TREE_CHAIN (arglist))))))))
*** gcc-2.8.1/fold-const.c.orig	Sat Feb 28 21:58:15 1998
--- gcc-2.8.1/fold-const.c	Mon Sep 11 11:00:40 2000
***************
*** 1225,1232 ****
--- 1225,1236 ----
      }
  
    TREE_OVERFLOW (t)
+ #ifdef GPC
+     = ((notrunc ? overflow : force_fit_type (t, overflow))
+ #else /* not GPC */
      = ((notrunc ? (!uns || forsize) && overflow
  	: force_fit_type (t, (!uns || forsize) && overflow) && ! no_overflow)
+ #endif /* not GPC */
         | TREE_OVERFLOW (arg1)
         | TREE_OVERFLOW (arg2));
    /* If we're doing a size calculation, unsigned arithmetic does overflow.
***************
*** 4201,4210 ****
  				    TREE_TYPE (TREE_TYPE (arg0)),
  				    TREE_OPERAND (arg0, 1))));
        else if (TREE_CODE (arg0) == COMPLEX_CST)
! 	return build_complex (type, TREE_OPERAND (arg0, 0),
  			      fold (build1 (NEGATE_EXPR,
  					    TREE_TYPE (TREE_TYPE (arg0)),
! 					    TREE_OPERAND (arg0, 1))));
        else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)
  	return fold (build (TREE_CODE (arg0), type,
  			    fold (build1 (CONJ_EXPR, type,
--- 4205,4214 ----
  				    TREE_TYPE (TREE_TYPE (arg0)),
  				    TREE_OPERAND (arg0, 1))));
        else if (TREE_CODE (arg0) == COMPLEX_CST)
! 	return build_complex (type, TREE_REALPART (arg0),
  			      fold (build1 (NEGATE_EXPR,
  					    TREE_TYPE (TREE_TYPE (arg0)),
! 					    TREE_IMAGPART (arg0))));
        else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)
  	return fold (build (TREE_CODE (arg0), type,
  			    fold (build1 (CONJ_EXPR, type,
*** gcc-2.8.1/gansidecl.h.orig	Sat Feb 14 17:31:43 1998
--- gcc-2.8.1/gansidecl.h	Mon Sep 11 11:00:40 2000
***************
*** 22,107 ****
     in binutils and gdb releases.
     ??? Over time the two should be merged into one.  */
  
! #ifndef	ANSIDECL_H
! #define	ANSIDECL_H
  
! /* Add prototype support.  */
! #ifndef PROTO
! #if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
! #define PROTO(ARGS) ARGS
! #else
! #define PROTO(ARGS) ()
! #endif
! #endif
  
! #ifndef VPROTO
! #ifdef __STDC__
! #define PVPROTO(ARGS)		ARGS
! #define VPROTO(ARGS)            ARGS
! #define VA_START(va_list,var)  va_start(va_list,var)
! #else
! #define PVPROTO(ARGS)		()
! #define VPROTO(ARGS)            (va_alist) va_dcl
! #define VA_START(va_list,var)  va_start(va_list)
! #endif
! #endif
! 
! /* Define a generic NULL if one hasn't already been defined.  */
! 
! #ifndef NULL
! #define NULL 0
! #endif
  
! #ifndef GENERIC_PTR
! #if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
! #define GENERIC_PTR void *
! #else
! #define GENERIC_PTR char *
! #endif
! #endif
  
  #ifndef NULL_PTR
! #define NULL_PTR ((GENERIC_PTR) 0)
! #endif
! 
! #ifdef __STDC__
! 
! #define	PTR void *
! 
! #else
! 
! #define	PTR char *
! #ifndef const
! #define const
  #endif
  
! #endif /* ! __STDC__ */
! 
! /* We don't have autoconf for libgcc2.c since it's a target, so don't
!    define these functions, which aren't used there anyway.  */
! 
! #ifndef IN_LIBGCC2
! 
! #ifndef HAVE_BCOPY
! #define bcopy(src,dst,len) memcpy ((dst),(src),(len))
! #endif
! 
! #ifndef HAVE_BZERO
! #define bzero(dst,len) memset ((dst),0,(len))
! #endif
! 
! #ifndef HAVE_BCMP
! #define bcmp(left,right,len) memcmp ((left),(right),(len))
! #endif
! 
! #ifndef HAVE_RINDEX
! #define rindex strrchr
! #endif
! 
! #ifndef HAVE_INDEX
! #define index strchr
! #endif
! 
! #endif /* IN_LIBGCC2 */
! 
! #endif /* ANSIDECL_H */
--- 22,64 ----
     in binutils and gdb releases.
     ??? Over time the two should be merged into one.  */
  
! #ifndef	__GANSIDECL_H__
! #define	__GANSIDECL_H__
  
! #include "ansidecl.h"
  
! /* Undef ansidecl.h's "obsolete" version. */
! #undef PROTO
! /* These macros are deprecated, use ansidecl.h's PARAMS style instead. */
! #define PROTO(ARGS) PARAMS(ARGS)
! #define VPROTO(ARGS) VPARAMS(ARGS)
! #define PVPROTO(ARGS) PARAMS(ARGS)
! 
! #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
! # define __attribute__(x)
! #endif
! 
! #ifndef ATTRIBUTE_UNUSED
! #define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
! #endif /* ATTRIBUTE_UNUSED */
! 
! #ifndef ATTRIBUTE_NORETURN
! #define ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))
! #endif /* ATTRIBUTE_NORETURN */
! 
! #ifndef ATTRIBUTE_PRINTF
! #define ATTRIBUTE_PRINTF(m, n) __attribute__ ((format (__printf__, m, n)))
! #define ATTRIBUTE_PRINTF_1 ATTRIBUTE_PRINTF(1, 2)
! #define ATTRIBUTE_PRINTF_2 ATTRIBUTE_PRINTF(2, 3)
! #define ATTRIBUTE_PRINTF_3 ATTRIBUTE_PRINTF(3, 4)
! #define ATTRIBUTE_PRINTF_4 ATTRIBUTE_PRINTF(4, 5)
! #define ATTRIBUTE_PRINTF_5 ATTRIBUTE_PRINTF(5, 6)
! #endif /* ATTRIBUTE_PRINTF */
  
! #define GENERIC_PTR PTR
  
  #ifndef NULL_PTR
! #define NULL_PTR ((PTR) 0)
  #endif
  
! #endif /* __GANSIDECL_H__ */
*** gcc-2.8.1/gcc.c.orig	Mon Sep 11 11:01:16 2000
--- gcc-2.8.1/gcc.c	Mon Sep 11 20:42:14 2000
***************
*** 710,715 ****
--- 710,720 ----
  /* We want %{T*} after %{L*} and %D so that it can be used to specify linker
     scripts which exist in user specified directories, or in standard
     directories.  */
+ #ifdef LINK_COMMAND_SPEC
+ /* Provide option to override link_command_spec from machine specific
+    configuration files.  */
+ static char *link_command_spec = LINK_COMMAND_SPEC;
+ #else /* not LINK_COMMAND_SPEC */
  #ifdef LINK_LIBGCC_SPECIAL
  /* Don't generate -L options.  */
  static char *link_command_spec = "\
***************
*** 722,728 ****
  			%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\
  			%{T*}\
  			\n }}}}}}";
! #else
  /* Use -L.  */
  static char *link_command_spec = "\
  %{!fsyntax-only: \
--- 727,733 ----
  			%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\
  			%{T*}\
  			\n }}}}}}";
! #else /* not LINK_LIBGCC_SPECIAL */
  /* Use -L.  */
  static char *link_command_spec = "\
  %{!fsyntax-only: \
***************
*** 734,740 ****
  			%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\
  			%{T*}\
  			\n }}}}}}";
! #endif
  
  /* A vector of options to give to the linker.
     These options are accumulated by %x,
--- 739,746 ----
  			%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\
  			%{T*}\
  			\n }}}}}}";
! #endif /* not LINK_LIBGCC_SPECIAL */
! #endif /* not LINK_COMMAND_SPEC */
  
  /* A vector of options to give to the linker.
     These options are accumulated by %x,
***************
*** 2529,2534 ****
--- 2535,2542 ----
  	  init_spec ();
  	  for (sl = specs; sl; sl = sl->next)
  	    printf ("*%s:\n%s\n\n", sl->name, *(sl->ptr_spec));
+           if (link_command_spec)
+             printf ("*link_command:\n%s\n\n", link_command_spec);
  	  exit (0);
  	}
        else if (! strcmp (argv[i], "-dumpversion"))
*** gcc-2.8.1/optabs.c.orig	Sat Feb 14 12:41:17 1998
--- gcc-2.8.1/optabs.c	Mon Sep 11 11:00:40 2000
***************
*** 1379,1384 ****
--- 1379,1422 ----
  
  	      ok = 1;
  	    }
+ #ifdef GPC
+           /* Optimization if real part of divisor is zero.  */
+ 	  else if (real1 == 0)
+ 	    {
+ 	      /* (a+ib) / (0+id) == -i(a+ib) / d == (b/d + i(-a/d) */
+ 
+ 	      /* Fetch imag1 from memory only once.  */
+ 	      imag1 = force_reg (submode, imag1);
+ 
+ 	      if (class == MODE_COMPLEX_FLOAT)
+ 		res = expand_binop (submode, binoptab, imag0, imag1,
+ 				    realr, unsignedp, methods);
+ 	      else
+ 		res = expand_divmod (0, TRUNC_DIV_EXPR, submode,
+ 				     imag0, imag1, realr, unsignedp);
+ 	      if (res == 0)
+ 		break;
+ 	      else if (res != realr)
+ 		emit_move_insn (realr, res);
+ 
+ 	      if (class == MODE_COMPLEX_FLOAT)
+ 		res = expand_binop (submode, binoptab, real0,
+ 				    imag1, imagr, unsignedp, methods);
+ 	      else
+ 		res = expand_divmod (0, TRUNC_DIV_EXPR, submode,
+ 				     real0, imag1, imagr, unsignedp);
+ 
+ 	      /* Negate the imaginary part.  */
+ 	      res = expand_unop (submode, neg_optab,
+ 				 res, imagr, unsignedp);
+ 	      if (res == 0)
+ 		break;
+ 	      else if (res != imagr)
+ 		emit_move_insn (imagr, res);
+ 
+ 	      ok = 1;
+ 	    }
+ #endif /* GPC */
  	  else
  	    {
  	      /* Divisor is of complex type:
*** gcc-2.8.1/prefix.c.orig	Fri Feb  6 15:04:22 1998
--- gcc-2.8.1/prefix.c	Mon Sep 11 11:00:40 2000
***************
*** 232,238 ****
       char *name;
  {
    char code = name[0];
!   char *key, *prefix = 0;
    int keylen;
  
    if (code != '@@' && code != '$')
--- 232,238 ----
       char *name;
  {
    char code = name[0];
!   char *key, *prefix = 0, *oldname = name;
    int keylen;
  
    if (code != '@@' && code != '$')
***************
*** 272,278 ****
        prefix[strlen (prefix) - 1] = 0;
      }
  
!   return concat (prefix, name, NULL_PTR);
  }
  
  /* Update PATH using KEY if PATH starts with PREFIX.  */
--- 272,283 ----
        prefix[strlen (prefix) - 1] = 0;
      }
  
!   name = concat (prefix, name, NULL_PTR);
! 
!   if (!strcmp (name, oldname))
!     return 0;
! 
!   return name;
  }
  
  /* Update PATH using KEY if PATH starts with PREFIX.  */
*** gcc-2.8.1/rtl.h.orig	Sat Feb  7 01:38:46 1998
--- gcc-2.8.1/rtl.h	Mon Sep 11 11:00:40 2000
***************
*** 1002,1004 ****
--- 1002,1007 ----
  
  extern int computed_jump_p	PROTO((rtx));
  
+ extern int get_first_label_num PARAMS((void));
+ extern void set_new_first_and_last_label_num PARAMS((int, int));
+ extern int max_label_num PARAMS((void));
*** gcc-2.8.1/system.h.orig	Mon Sep 11 20:46:33 2000
--- gcc-2.8.1/system.h	Mon Sep 11 11:00:40 2000
***************
*** 0 ****
--- 1,1179 ----
+ /* system.h - Get common system includes and various definitions and
+    declarations based on autoconf macros.
+    Copyright (C) 1998 Free Software Foundation, Inc.
+ 
+  */
+ 
+ #ifndef __GCC_SYSTEM_H__
+ #define __GCC_SYSTEM_H__
+ 
+ /* We must include stdarg.h/varargs.h before stdio.h. */
+ #ifdef ANSI_PROTOTYPES
+ #include <stdarg.h>
+ #else
+ #include <varargs.h>
+ #endif
+ 
+ #include <stdio.h>
+ 
+ /* Define a generic NULL if one hasn't already been defined.  */
+ #ifndef NULL
+ #define NULL 0
+ #endif
+ 
+ /* The compiler is not a multi-threaded application and therefore we
+    do not have to use the locking functions.  */
+ #ifdef HAVE_PUTC_UNLOCKED
+ # undef putc
+ # define putc(C, Stream) putc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTC_UNLOCKED
+ # undef fputc
+ # define fputc(C, Stream) fputc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTS_UNLOCKED
+ # undef fputs
+ # define fputs(String, Stream) fputs_unlocked (String, Stream)
+ #endif
+ 
+ #include <ctype.h>
+ 
+ /* Jim Meyering writes:
+ 
+    "... Some ctype macros are valid only for character codes that
+    isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
+    using /bin/cc or gcc but without giving an ansi option).  So, all
+    ctype uses should be through macros like ISPRINT...  If
+    STDC_HEADERS is defined, then autoconf has verified that the ctype
+    macros don't need to be guarded with references to isascii. ...
+    Defining isascii to 1 should let any compiler worth its salt
+    eliminate the && through constant folding."
+ 
+    Bruno Haible adds:
+ 
+    "... Furthermore, isupper(c) etc. have an undefined result if c is
+    outside the range -1 <= c <= 255. One is tempted to write isupper(c)
+    with c being of type `char', but this is wrong if c is an 8-bit
+    character >= 128 which gets sign-extended to a negative value.
+    The macro ISUPPER protects against this as well."  */
+ 
+ #if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
+ # define IN_CTYPE_DOMAIN(c) 1
+ #else
+ # define IN_CTYPE_DOMAIN(c) isascii(c)
+ #endif
+ 
+ #ifdef isblank
+ # define ISBLANK(c) (IN_CTYPE_DOMAIN (c) && isblank (c))
+ #else
+ # define ISBLANK(c) ((c) == ' ' || (c) == '\t')
+ #endif
+ #ifdef isgraph
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isgraph (c))
+ #else
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isprint (c) && !isspace (c))
+ #endif
+ 
+ #define ISPRINT(c) (IN_CTYPE_DOMAIN (c) && isprint (c))
+ #define ISALNUM(c) (IN_CTYPE_DOMAIN (c) && isalnum (c))
+ #define ISALPHA(c) (IN_CTYPE_DOMAIN (c) && isalpha (c))
+ #define ISCNTRL(c) (IN_CTYPE_DOMAIN (c) && iscntrl (c))
+ #define ISLOWER(c) (IN_CTYPE_DOMAIN (c) && islower (c))
+ #define ISPUNCT(c) (IN_CTYPE_DOMAIN (c) && ispunct (c))
+ #define ISSPACE(c) (IN_CTYPE_DOMAIN (c) && isspace (c))
+ #define ISUPPER(c) (IN_CTYPE_DOMAIN (c) && isupper (c))
+ #define ISXDIGIT(c) (IN_CTYPE_DOMAIN (c) && isxdigit (c))
+ #define ISDIGIT_LOCALE(c) (IN_CTYPE_DOMAIN (c) && isdigit (c))
+ 
+ /* ISDIGIT differs from ISDIGIT_LOCALE, as follows:
+    - Its arg may be any int or unsigned int; it need not be an unsigned char.
+    - It's guaranteed to evaluate its argument exactly once.
+    - It's typically faster.
+    Posix 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that
+    only '0' through '9' are digits.  Prefer ISDIGIT to ISDIGIT_LOCALE unless
+    it's important to use the locale's definition of `digit' even when the
+    host does not conform to Posix.  */
+ #define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)
+ 
+ 
+ #include <sys/types.h>
+ #include <errno.h>
+ 
+ #ifndef errno
+ extern int errno;
+ #endif
+ 
+ #ifdef STRING_WITH_STRINGS
+ # include <string.h>
+ # include <strings.h>
+ #else
+ # ifdef HAVE_STRING_H
+ #  include <string.h>
+ # else
+ #  ifdef HAVE_STRINGS_H
+ #   include <strings.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_STDLIB_H
+ # include <stdlib.h>
+ #endif
+ 
+ #ifdef HAVE_UNISTD_H
+ # include <unistd.h>
+ #endif
+ 
+ #ifdef HAVE_SYS_PARAM_H
+ # include <sys/param.h>
+ #endif
+ 
+ #if HAVE_LIMITS_H
+ # include <limits.h>
+ #endif
+ 
+ #ifdef TIME_WITH_SYS_TIME
+ # include <sys/time.h>
+ # include <time.h>
+ #else
+ # if HAVE_SYS_TIME_H
+ #  include <sys/time.h>
+ # else
+ #  ifdef HAVE_TIME_H
+ #   include <time.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_FCNTL_H
+ # include <fcntl.h>
+ #else
+ # ifdef HAVE_SYS_FILE_H
+ #  include <sys/file.h>
+ # endif
+ #endif
+ 
+ #ifndef SEEK_SET
+ # define SEEK_SET 0
+ # define SEEK_CUR 1
+ # define SEEK_END 2
+ #endif
+ #ifndef F_OK
+ # define F_OK 0
+ # define X_OK 1
+ # define W_OK 2
+ # define R_OK 4
+ #endif
+ #ifndef O_RDONLY
+ # define O_RDONLY 0
+ #endif
+ #ifndef O_WRONLY
+ # define O_WRONLY 1
+ #endif
+ 
+ #ifdef HAVE_SYS_WAIT_H
+ #include <sys/wait.h>
+ #endif
+ 
+ #ifndef WIFSIGNALED
+ #define WIFSIGNALED(S) (((S) & 0xff) != 0 && ((S) & 0xff) != 0x7f)
+ #endif
+ #ifndef WTERMSIG
+ #define WTERMSIG(S) ((S) & 0x7f)
+ #endif
+ #ifndef WIFEXITED
+ #define WIFEXITED(S) (((S) & 0xff) == 0)
+ #endif
+ #ifndef WEXITSTATUS
+ #define WEXITSTATUS(S) (((S) & 0xff00) >> 8)
+ #endif
+ 
+ 
+ 
+ #ifndef bcopy
+ # ifdef HAVE_BCOPY
+ #  ifdef NEED_DECLARATION_BCOPY
+ extern void bcopy ();
+ #  endif
+ # else /* !HAVE_BCOPY */
+ #  define bcopy(src,dst,len) memcpy ((dst),(src),(len))
+ # endif
+ #endif
+ 
+ #ifndef bcmp
+ # ifdef HAVE_BCMP
+ #  ifdef NEED_DECLARATION_BCMP
+ extern int bcmp ();
+ #  endif
+ # else /* !HAVE_BCMP */
+ #  define bcmp(left,right,len) memcmp ((left),(right),(len))
+ # endif
+ #endif
+ 
+ #ifndef bzero
+ # ifdef HAVE_BZERO
+ #  ifdef NEED_DECLARATION_BZERO
+ extern void bzero ();
+ #  endif
+ # else /* !HAVE_BZERO */
+ #  define bzero(dst,len) memset ((dst),0,(len))
+ # endif
+ #endif
+ 
+ #ifndef index
+ # ifdef HAVE_INDEX
+ #  ifdef NEED_DECLARATION_INDEX
+ extern char *index ();
+ #  endif
+ # else /* !HAVE_INDEX */
+ #  define index strchr
+ # endif
+ #endif
+ 
+ #ifndef rindex
+ # ifdef HAVE_RINDEX
+ #  ifdef NEED_DECLARATION_RINDEX
+ extern char *rindex ();
+ #  endif
+ # else /* !HAVE_RINDEX */
+ #  define rindex strrchr
+ # endif
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOF
+ extern double atof ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOL
+ extern long atol();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_FREE
+ extern void free ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETCWD
+ extern char *getcwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETENV
+ extern char *getenv ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETWD
+ extern char *getwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_SBRK
+ extern char *sbrk ();
+ #endif
+ 
+ #ifdef HAVE_STRERROR
+ # ifdef NEED_DECLARATION_STRERROR
+ #  ifndef strerror
+ extern char *strerror ();
+ #  endif
+ # endif
+ #else /* !HAVE_STRERROR */
+ extern int sys_nerr;
+ extern char *sys_errlist[];
+ #endif /* HAVE_STRERROR */
+ 
+ #ifdef HAVE_STRSIGNAL
+ # ifdef NEED_DECLARATION_STRSIGNAL
+ #  ifndef strsignal
+ extern char * strsignal ();
+ #  endif
+ # endif
+ #else /* !HAVE_STRSIGNAL */
+ # ifndef SYS_SIGLIST_DECLARED
+ #  ifndef NO_SYS_SIGLIST
+ extern char * sys_siglist[];
+ #  endif
+ # endif
+ #endif /* HAVE_STRSIGNAL */
+ 
+ #ifdef HAVE_GETRLIMIT
+ # ifdef NEED_DECLARATION_GETRLIMIT
+ #  ifndef getrlimit
+ extern int getrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_SETRLIMIT
+ # ifdef NEED_DECLARATION_SETRLIMIT
+ #  ifndef setrlimit
+ extern int setrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ /* HAVE_VOLATILE only refers to the stage1 compiler.  We also check
+    __STDC__ and assume gcc sets it and has volatile in stage >=2. */
+ #if !defined(HAVE_VOLATILE) && !defined(__STDC__) && !defined(volatile)
+ #define volatile
+ #endif
+ 
+ /* Redefine abort to report an internal error w/o coredump, and reporting the
+    location of the error in the source file.  */
+ #ifndef abort
+ #ifndef __STDC__
+ #ifndef __GNUC__
+ #ifndef USE_SYSTEM_ABORT
+ #define USE_SYSTEM_ABORT
+ #endif /* !USE_SYSTEM_ABORT */
+ #endif /* !__GNUC__ */
+ #endif /* !__STDC__ */
+ 
+ #ifdef USE_SYSTEM_ABORT
+ # ifdef NEED_DECLARATION_ABORT
+ extern void abort ();
+ # endif
+ #else
+ #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error\n", __FILE__, __LINE__),	\
+  exit (FATAL_EXIT_CODE))
+ 
+ #else
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error in function %s\n",		\
+ 	  __FILE__, __LINE__, __PRETTY_FUNCTION__),			\
+  exit (FATAL_EXIT_CODE))
+ 
+ #endif /* recent gcc */
+ #endif /* USE_SYSTEM_ABORT */
+ #endif /* !abort */
+ 
+ 
+ /* Define a STRINGIFY macro that's right for ANSI or traditional C.
+    HAVE_CPP_STRINGIFY only refers to the stage1 compiler.  Assume that
+    (non-traditional) gcc used in stage2 or later has this feature.
+ 
+    Note: if the argument passed to STRINGIFY is itself a macro, eg
+    #define foo bar, STRINGIFY(foo) will produce "foo", not "bar".
+    Although the __STDC__ case could be made to expand this via a layer
+    of indirection, the traditional C case can not do so.  Therefore
+    this behavior is not supported. */
+ #ifndef STRINGIFY
+ # if defined(HAVE_CPP_STRINGIFY) || (defined(__GNUC__) && defined(__STDC__))
+ #  define STRINGIFY(STRING) #STRING
+ # else
+ #  define STRINGIFY(STRING) "STRING"
+ # endif
+ #endif /* !STRINGIFY */
+ 
+ 
+ /* These macros are here in preparation for the use of gettext in egcs.  */
+ #define _(String) String
+ #define N_(String) String
+ 
+ #if HAVE_SYS_STAT_H
+ # include <sys/stat.h>
+ #endif
+ 
+ /* Test if something is a normal file.  */
+ #ifndef S_ISREG
+ #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+ #endif
+ 
+ /* Test if something is a directory.  */
+ #ifndef S_ISDIR
+ #define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+ #endif
+ 
+ #if !defined(GPC) || defined(EGCS)
+ /* Get libiberty declarations. */
+ #include "libiberty.h"
+ #endif
+ 
+ #endif /* __GCC_SYSTEM_H__ */
+ /* system.h - Get common system includes and various definitions and
+    declarations based on autoconf macros.
+    Copyright (C) 1998 Free Software Foundation, Inc.
+ 
+  */
+ 
+ #ifndef __GCC_SYSTEM_H__
+ #define __GCC_SYSTEM_H__
+ 
+ /* We must include stdarg.h/varargs.h before stdio.h. */
+ #ifdef ANSI_PROTOTYPES
+ #include <stdarg.h>
+ #else
+ #include <varargs.h>
+ #endif
+ 
+ #include <stdio.h>
+ 
+ /* Define a generic NULL if one hasn't already been defined.  */
+ #ifndef NULL
+ #define NULL 0
+ #endif
+ 
+ /* The compiler is not a multi-threaded application and therefore we
+    do not have to use the locking functions.  */
+ #ifdef HAVE_PUTC_UNLOCKED
+ # undef putc
+ # define putc(C, Stream) putc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTC_UNLOCKED
+ # undef fputc
+ # define fputc(C, Stream) fputc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTS_UNLOCKED
+ # undef fputs
+ # define fputs(String, Stream) fputs_unlocked (String, Stream)
+ #endif
+ 
+ #include <ctype.h>
+ 
+ /* Jim Meyering writes:
+ 
+    "... Some ctype macros are valid only for character codes that
+    isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
+    using /bin/cc or gcc but without giving an ansi option).  So, all
+    ctype uses should be through macros like ISPRINT...  If
+    STDC_HEADERS is defined, then autoconf has verified that the ctype
+    macros don't need to be guarded with references to isascii. ...
+    Defining isascii to 1 should let any compiler worth its salt
+    eliminate the && through constant folding."
+ 
+    Bruno Haible adds:
+ 
+    "... Furthermore, isupper(c) etc. have an undefined result if c is
+    outside the range -1 <= c <= 255. One is tempted to write isupper(c)
+    with c being of type `char', but this is wrong if c is an 8-bit
+    character >= 128 which gets sign-extended to a negative value.
+    The macro ISUPPER protects against this as well."  */
+ 
+ #if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
+ # define IN_CTYPE_DOMAIN(c) 1
+ #else
+ # define IN_CTYPE_DOMAIN(c) isascii(c)
+ #endif
+ 
+ #ifdef isblank
+ # define ISBLANK(c) (IN_CTYPE_DOMAIN (c) && isblank (c))
+ #else
+ # define ISBLANK(c) ((c) == ' ' || (c) == '\t')
+ #endif
+ #ifdef isgraph
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isgraph (c))
+ #else
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isprint (c) && !isspace (c))
+ #endif
+ 
+ #define ISPRINT(c) (IN_CTYPE_DOMAIN (c) && isprint (c))
+ #define ISALNUM(c) (IN_CTYPE_DOMAIN (c) && isalnum (c))
+ #define ISALPHA(c) (IN_CTYPE_DOMAIN (c) && isalpha (c))
+ #define ISCNTRL(c) (IN_CTYPE_DOMAIN (c) && iscntrl (c))
+ #define ISLOWER(c) (IN_CTYPE_DOMAIN (c) && islower (c))
+ #define ISPUNCT(c) (IN_CTYPE_DOMAIN (c) && ispunct (c))
+ #define ISSPACE(c) (IN_CTYPE_DOMAIN (c) && isspace (c))
+ #define ISUPPER(c) (IN_CTYPE_DOMAIN (c) && isupper (c))
+ #define ISXDIGIT(c) (IN_CTYPE_DOMAIN (c) && isxdigit (c))
+ #define ISDIGIT_LOCALE(c) (IN_CTYPE_DOMAIN (c) && isdigit (c))
+ 
+ /* ISDIGIT differs from ISDIGIT_LOCALE, as follows:
+    - Its arg may be any int or unsigned int; it need not be an unsigned char.
+    - It's guaranteed to evaluate its argument exactly once.
+    - It's typically faster.
+    Posix 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that
+    only '0' through '9' are digits.  Prefer ISDIGIT to ISDIGIT_LOCALE unless
+    it's important to use the locale's definition of `digit' even when the
+    host does not conform to Posix.  */
+ #define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)
+ 
+ 
+ #include <sys/types.h>
+ #include <errno.h>
+ 
+ #ifndef errno
+ extern int errno;
+ #endif
+ 
+ #ifdef STRING_WITH_STRINGS
+ # include <string.h>
+ # include <strings.h>
+ #else
+ # ifdef HAVE_STRING_H
+ #  include <string.h>
+ # else
+ #  ifdef HAVE_STRINGS_H
+ #   include <strings.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_STDLIB_H
+ # include <stdlib.h>
+ #endif
+ 
+ #ifdef HAVE_UNISTD_H
+ # include <unistd.h>
+ #endif
+ 
+ #ifdef HAVE_SYS_PARAM_H
+ # include <sys/param.h>
+ #endif
+ 
+ #if HAVE_LIMITS_H
+ # include <limits.h>
+ #endif
+ 
+ #ifdef TIME_WITH_SYS_TIME
+ # include <sys/time.h>
+ # include <time.h>
+ #else
+ # if HAVE_SYS_TIME_H
+ #  include <sys/time.h>
+ # else
+ #  ifdef HAVE_TIME_H
+ #   include <time.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_FCNTL_H
+ # include <fcntl.h>
+ #else
+ # ifdef HAVE_SYS_FILE_H
+ #  include <sys/file.h>
+ # endif
+ #endif
+ 
+ #ifndef SEEK_SET
+ # define SEEK_SET 0
+ # define SEEK_CUR 1
+ # define SEEK_END 2
+ #endif
+ #ifndef F_OK
+ # define F_OK 0
+ # define X_OK 1
+ # define W_OK 2
+ # define R_OK 4
+ #endif
+ #ifndef O_RDONLY
+ # define O_RDONLY 0
+ #endif
+ #ifndef O_WRONLY
+ # define O_WRONLY 1
+ #endif
+ 
+ #ifdef HAVE_SYS_WAIT_H
+ #include <sys/wait.h>
+ #endif
+ 
+ #ifndef WIFSIGNALED
+ #define WIFSIGNALED(S) (((S) & 0xff) != 0 && ((S) & 0xff) != 0x7f)
+ #endif
+ #ifndef WTERMSIG
+ #define WTERMSIG(S) ((S) & 0x7f)
+ #endif
+ #ifndef WIFEXITED
+ #define WIFEXITED(S) (((S) & 0xff) == 0)
+ #endif
+ #ifndef WEXITSTATUS
+ #define WEXITSTATUS(S) (((S) & 0xff00) >> 8)
+ #endif
+ 
+ 
+ 
+ #ifndef bcopy
+ # ifdef HAVE_BCOPY
+ #  ifdef NEED_DECLARATION_BCOPY
+ extern void bcopy ();
+ #  endif
+ # else /* !HAVE_BCOPY */
+ #  define bcopy(src,dst,len) memcpy ((dst),(src),(len))
+ # endif
+ #endif
+ 
+ #ifndef bcmp
+ # ifdef HAVE_BCMP
+ #  ifdef NEED_DECLARATION_BCMP
+ extern int bcmp ();
+ #  endif
+ # else /* !HAVE_BCMP */
+ #  define bcmp(left,right,len) memcmp ((left),(right),(len))
+ # endif
+ #endif
+ 
+ #ifndef bzero
+ # ifdef HAVE_BZERO
+ #  ifdef NEED_DECLARATION_BZERO
+ extern void bzero ();
+ #  endif
+ # else /* !HAVE_BZERO */
+ #  define bzero(dst,len) memset ((dst),0,(len))
+ # endif
+ #endif
+ 
+ #ifndef index
+ # ifdef HAVE_INDEX
+ #  ifdef NEED_DECLARATION_INDEX
+ extern char *index ();
+ #  endif
+ # else /* !HAVE_INDEX */
+ #  define index strchr
+ # endif
+ #endif
+ 
+ #ifndef rindex
+ # ifdef HAVE_RINDEX
+ #  ifdef NEED_DECLARATION_RINDEX
+ extern char *rindex ();
+ #  endif
+ # else /* !HAVE_RINDEX */
+ #  define rindex strrchr
+ # endif
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOF
+ extern double atof ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOL
+ extern long atol();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_FREE
+ extern void free ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETCWD
+ extern char *getcwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETENV
+ extern char *getenv ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETWD
+ extern char *getwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_SBRK
+ extern char *sbrk ();
+ #endif
+ 
+ #ifdef HAVE_STRERROR
+ # ifdef NEED_DECLARATION_STRERROR
+ #  ifndef strerror
+ extern char *strerror ();
+ #  endif
+ # endif
+ #else /* !HAVE_STRERROR */
+ extern int sys_nerr;
+ extern char *sys_errlist[];
+ #endif /* HAVE_STRERROR */
+ 
+ #ifdef HAVE_STRSIGNAL
+ # ifdef NEED_DECLARATION_STRSIGNAL
+ #  ifndef strsignal
+ extern char * strsignal ();
+ #  endif
+ # endif
+ #else /* !HAVE_STRSIGNAL */
+ # ifndef SYS_SIGLIST_DECLARED
+ #  ifndef NO_SYS_SIGLIST
+ extern char * sys_siglist[];
+ #  endif
+ # endif
+ #endif /* HAVE_STRSIGNAL */
+ 
+ #ifdef HAVE_GETRLIMIT
+ # ifdef NEED_DECLARATION_GETRLIMIT
+ #  ifndef getrlimit
+ extern int getrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_SETRLIMIT
+ # ifdef NEED_DECLARATION_SETRLIMIT
+ #  ifndef setrlimit
+ extern int setrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ /* HAVE_VOLATILE only refers to the stage1 compiler.  We also check
+    __STDC__ and assume gcc sets it and has volatile in stage >=2. */
+ #if !defined(HAVE_VOLATILE) && !defined(__STDC__) && !defined(volatile)
+ #define volatile
+ #endif
+ 
+ /* Redefine abort to report an internal error w/o coredump, and reporting the
+    location of the error in the source file.  */
+ #ifndef abort
+ #ifndef __STDC__
+ #ifndef __GNUC__
+ #ifndef USE_SYSTEM_ABORT
+ #define USE_SYSTEM_ABORT
+ #endif /* !USE_SYSTEM_ABORT */
+ #endif /* !__GNUC__ */
+ #endif /* !__STDC__ */
+ 
+ #ifdef USE_SYSTEM_ABORT
+ # ifdef NEED_DECLARATION_ABORT
+ extern void abort ();
+ # endif
+ #else
+ #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error\n", __FILE__, __LINE__),	\
+  exit (FATAL_EXIT_CODE))
+ 
+ #else
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error in function %s\n",		\
+ 	  __FILE__, __LINE__, __PRETTY_FUNCTION__),			\
+  exit (FATAL_EXIT_CODE))
+ 
+ #endif /* recent gcc */
+ #endif /* USE_SYSTEM_ABORT */
+ #endif /* !abort */
+ 
+ 
+ /* Define a STRINGIFY macro that's right for ANSI or traditional C.
+    HAVE_CPP_STRINGIFY only refers to the stage1 compiler.  Assume that
+    (non-traditional) gcc used in stage2 or later has this feature.
+ 
+    Note: if the argument passed to STRINGIFY is itself a macro, eg
+    #define foo bar, STRINGIFY(foo) will produce "foo", not "bar".
+    Although the __STDC__ case could be made to expand this via a layer
+    of indirection, the traditional C case can not do so.  Therefore
+    this behavior is not supported. */
+ #ifndef STRINGIFY
+ # if defined(HAVE_CPP_STRINGIFY) || (defined(__GNUC__) && defined(__STDC__))
+ #  define STRINGIFY(STRING) #STRING
+ # else
+ #  define STRINGIFY(STRING) "STRING"
+ # endif
+ #endif /* !STRINGIFY */
+ 
+ 
+ /* These macros are here in preparation for the use of gettext in egcs.  */
+ #define _(String) String
+ #define N_(String) String
+ 
+ #if HAVE_SYS_STAT_H
+ # include <sys/stat.h>
+ #endif
+ 
+ /* Test if something is a normal file.  */
+ #ifndef S_ISREG
+ #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+ #endif
+ 
+ /* Test if something is a directory.  */
+ #ifndef S_ISDIR
+ #define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+ #endif
+ 
+ #if !defined(GPC) || defined(EGCS)
+ /* Get libiberty declarations. */
+ #include "libiberty.h"
+ #endif
+ 
+ #endif /* __GCC_SYSTEM_H__ */
+ /* system.h - Get common system includes and various definitions and
+    declarations based on autoconf macros.
+    Copyright (C) 1998 Free Software Foundation, Inc.
+ 
+  */
+ 
+ #ifndef __GCC_SYSTEM_H__
+ #define __GCC_SYSTEM_H__
+ 
+ /* We must include stdarg.h/varargs.h before stdio.h. */
+ #ifdef ANSI_PROTOTYPES
+ #include <stdarg.h>
+ #else
+ #include <varargs.h>
+ #endif
+ 
+ #include <stdio.h>
+ 
+ /* Define a generic NULL if one hasn't already been defined.  */
+ #ifndef NULL
+ #define NULL 0
+ #endif
+ 
+ /* The compiler is not a multi-threaded application and therefore we
+    do not have to use the locking functions.  */
+ #ifdef HAVE_PUTC_UNLOCKED
+ # undef putc
+ # define putc(C, Stream) putc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTC_UNLOCKED
+ # undef fputc
+ # define fputc(C, Stream) fputc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTS_UNLOCKED
+ # undef fputs
+ # define fputs(String, Stream) fputs_unlocked (String, Stream)
+ #endif
+ 
+ #include <ctype.h>
+ 
+ /* Jim Meyering writes:
+ 
+    "... Some ctype macros are valid only for character codes that
+    isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
+    using /bin/cc or gcc but without giving an ansi option).  So, all
+    ctype uses should be through macros like ISPRINT...  If
+    STDC_HEADERS is defined, then autoconf has verified that the ctype
+    macros don't need to be guarded with references to isascii. ...
+    Defining isascii to 1 should let any compiler worth its salt
+    eliminate the && through constant folding."
+ 
+    Bruno Haible adds:
+ 
+    "... Furthermore, isupper(c) etc. have an undefined result if c is
+    outside the range -1 <= c <= 255. One is tempted to write isupper(c)
+    with c being of type `char', but this is wrong if c is an 8-bit
+    character >= 128 which gets sign-extended to a negative value.
+    The macro ISUPPER protects against this as well."  */
+ 
+ #if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
+ # define IN_CTYPE_DOMAIN(c) 1
+ #else
+ # define IN_CTYPE_DOMAIN(c) isascii(c)
+ #endif
+ 
+ #ifdef isblank
+ # define ISBLANK(c) (IN_CTYPE_DOMAIN (c) && isblank (c))
+ #else
+ # define ISBLANK(c) ((c) == ' ' || (c) == '\t')
+ #endif
+ #ifdef isgraph
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isgraph (c))
+ #else
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isprint (c) && !isspace (c))
+ #endif
+ 
+ #define ISPRINT(c) (IN_CTYPE_DOMAIN (c) && isprint (c))
+ #define ISALNUM(c) (IN_CTYPE_DOMAIN (c) && isalnum (c))
+ #define ISALPHA(c) (IN_CTYPE_DOMAIN (c) && isalpha (c))
+ #define ISCNTRL(c) (IN_CTYPE_DOMAIN (c) && iscntrl (c))
+ #define ISLOWER(c) (IN_CTYPE_DOMAIN (c) && islower (c))
+ #define ISPUNCT(c) (IN_CTYPE_DOMAIN (c) && ispunct (c))
+ #define ISSPACE(c) (IN_CTYPE_DOMAIN (c) && isspace (c))
+ #define ISUPPER(c) (IN_CTYPE_DOMAIN (c) && isupper (c))
+ #define ISXDIGIT(c) (IN_CTYPE_DOMAIN (c) && isxdigit (c))
+ #define ISDIGIT_LOCALE(c) (IN_CTYPE_DOMAIN (c) && isdigit (c))
+ 
+ /* ISDIGIT differs from ISDIGIT_LOCALE, as follows:
+    - Its arg may be any int or unsigned int; it need not be an unsigned char.
+    - It's guaranteed to evaluate its argument exactly once.
+    - It's typically faster.
+    Posix 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that
+    only '0' through '9' are digits.  Prefer ISDIGIT to ISDIGIT_LOCALE unless
+    it's important to use the locale's definition of `digit' even when the
+    host does not conform to Posix.  */
+ #define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)
+ 
+ 
+ #include <sys/types.h>
+ #include <errno.h>
+ 
+ #ifndef errno
+ extern int errno;
+ #endif
+ 
+ #ifdef STRING_WITH_STRINGS
+ # include <string.h>
+ # include <strings.h>
+ #else
+ # ifdef HAVE_STRING_H
+ #  include <string.h>
+ # else
+ #  ifdef HAVE_STRINGS_H
+ #   include <strings.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_STDLIB_H
+ # include <stdlib.h>
+ #endif
+ 
+ #ifdef HAVE_UNISTD_H
+ # include <unistd.h>
+ #endif
+ 
+ #ifdef HAVE_SYS_PARAM_H
+ # include <sys/param.h>
+ #endif
+ 
+ #if HAVE_LIMITS_H
+ # include <limits.h>
+ #endif
+ 
+ #ifdef TIME_WITH_SYS_TIME
+ # include <sys/time.h>
+ # include <time.h>
+ #else
+ # if HAVE_SYS_TIME_H
+ #  include <sys/time.h>
+ # else
+ #  ifdef HAVE_TIME_H
+ #   include <time.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_FCNTL_H
+ # include <fcntl.h>
+ #else
+ # ifdef HAVE_SYS_FILE_H
+ #  include <sys/file.h>
+ # endif
+ #endif
+ 
+ #ifndef SEEK_SET
+ # define SEEK_SET 0
+ # define SEEK_CUR 1
+ # define SEEK_END 2
+ #endif
+ #ifndef F_OK
+ # define F_OK 0
+ # define X_OK 1
+ # define W_OK 2
+ # define R_OK 4
+ #endif
+ #ifndef O_RDONLY
+ # define O_RDONLY 0
+ #endif
+ #ifndef O_WRONLY
+ # define O_WRONLY 1
+ #endif
+ 
+ #ifdef HAVE_SYS_WAIT_H
+ #include <sys/wait.h>
+ #endif
+ 
+ #ifndef WIFSIGNALED
+ #define WIFSIGNALED(S) (((S) & 0xff) != 0 && ((S) & 0xff) != 0x7f)
+ #endif
+ #ifndef WTERMSIG
+ #define WTERMSIG(S) ((S) & 0x7f)
+ #endif
+ #ifndef WIFEXITED
+ #define WIFEXITED(S) (((S) & 0xff) == 0)
+ #endif
+ #ifndef WEXITSTATUS
+ #define WEXITSTATUS(S) (((S) & 0xff00) >> 8)
+ #endif
+ 
+ 
+ 
+ #ifndef bcopy
+ # ifdef HAVE_BCOPY
+ #  ifdef NEED_DECLARATION_BCOPY
+ extern void bcopy ();
+ #  endif
+ # else /* !HAVE_BCOPY */
+ #  define bcopy(src,dst,len) memcpy ((dst),(src),(len))
+ # endif
+ #endif
+ 
+ #ifndef bcmp
+ # ifdef HAVE_BCMP
+ #  ifdef NEED_DECLARATION_BCMP
+ extern int bcmp ();
+ #  endif
+ # else /* !HAVE_BCMP */
+ #  define bcmp(left,right,len) memcmp ((left),(right),(len))
+ # endif
+ #endif
+ 
+ #ifndef bzero
+ # ifdef HAVE_BZERO
+ #  ifdef NEED_DECLARATION_BZERO
+ extern void bzero ();
+ #  endif
+ # else /* !HAVE_BZERO */
+ #  define bzero(dst,len) memset ((dst),0,(len))
+ # endif
+ #endif
+ 
+ #ifndef index
+ # ifdef HAVE_INDEX
+ #  ifdef NEED_DECLARATION_INDEX
+ extern char *index ();
+ #  endif
+ # else /* !HAVE_INDEX */
+ #  define index strchr
+ # endif
+ #endif
+ 
+ #ifndef rindex
+ # ifdef HAVE_RINDEX
+ #  ifdef NEED_DECLARATION_RINDEX
+ extern char *rindex ();
+ #  endif
+ # else /* !HAVE_RINDEX */
+ #  define rindex strrchr
+ # endif
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOF
+ extern double atof ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOL
+ extern long atol();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_FREE
+ extern void free ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETCWD
+ extern char *getcwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETENV
+ extern char *getenv ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETWD
+ extern char *getwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_SBRK
+ extern char *sbrk ();
+ #endif
+ 
+ #ifdef HAVE_STRERROR
+ # ifdef NEED_DECLARATION_STRERROR
+ #  ifndef strerror
+ extern char *strerror ();
+ #  endif
+ # endif
+ #else /* !HAVE_STRERROR */
+ extern int sys_nerr;
+ extern char *sys_errlist[];
+ #endif /* HAVE_STRERROR */
+ 
+ #ifdef HAVE_STRSIGNAL
+ # ifdef NEED_DECLARATION_STRSIGNAL
+ #  ifndef strsignal
+ extern char * strsignal ();
+ #  endif
+ # endif
+ #else /* !HAVE_STRSIGNAL */
+ # ifndef SYS_SIGLIST_DECLARED
+ #  ifndef NO_SYS_SIGLIST
+ extern char * sys_siglist[];
+ #  endif
+ # endif
+ #endif /* HAVE_STRSIGNAL */
+ 
+ #ifdef HAVE_GETRLIMIT
+ # ifdef NEED_DECLARATION_GETRLIMIT
+ #  ifndef getrlimit
+ extern int getrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_SETRLIMIT
+ # ifdef NEED_DECLARATION_SETRLIMIT
+ #  ifndef setrlimit
+ extern int setrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ /* HAVE_VOLATILE only refers to the stage1 compiler.  We also check
+    __STDC__ and assume gcc sets it and has volatile in stage >=2. */
+ #if !defined(HAVE_VOLATILE) && !defined(__STDC__) && !defined(volatile)
+ #define volatile
+ #endif
+ 
+ /* Redefine abort to report an internal error w/o coredump, and reporting the
+    location of the error in the source file.  */
+ #ifndef abort
+ #ifndef __STDC__
+ #ifndef __GNUC__
+ #ifndef USE_SYSTEM_ABORT
+ #define USE_SYSTEM_ABORT
+ #endif /* !USE_SYSTEM_ABORT */
+ #endif /* !__GNUC__ */
+ #endif /* !__STDC__ */
+ 
+ #ifdef USE_SYSTEM_ABORT
+ # ifdef NEED_DECLARATION_ABORT
+ extern void abort ();
+ # endif
+ #else
+ #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error\n", __FILE__, __LINE__),	\
+  exit (FATAL_EXIT_CODE))
+ 
+ #else
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error in function %s\n",		\
+ 	  __FILE__, __LINE__, __PRETTY_FUNCTION__),			\
+  exit (FATAL_EXIT_CODE))
+ 
+ #endif /* recent gcc */
+ #endif /* USE_SYSTEM_ABORT */
+ #endif /* !abort */
+ 
+ 
+ /* Define a STRINGIFY macro that's right for ANSI or traditional C.
+    HAVE_CPP_STRINGIFY only refers to the stage1 compiler.  Assume that
+    (non-traditional) gcc used in stage2 or later has this feature.
+ 
+    Note: if the argument passed to STRINGIFY is itself a macro, eg
+    #define foo bar, STRINGIFY(foo) will produce "foo", not "bar".
+    Although the __STDC__ case could be made to expand this via a layer
+    of indirection, the traditional C case can not do so.  Therefore
+    this behavior is not supported. */
+ #ifndef STRINGIFY
+ # if defined(HAVE_CPP_STRINGIFY) || (defined(__GNUC__) && defined(__STDC__))
+ #  define STRINGIFY(STRING) #STRING
+ # else
+ #  define STRINGIFY(STRING) "STRING"
+ # endif
+ #endif /* !STRINGIFY */
+ 
+ 
+ /* These macros are here in preparation for the use of gettext in egcs.  */
+ #define _(String) String
+ #define N_(String) String
+ 
+ #if HAVE_SYS_STAT_H
+ # include <sys/stat.h>
+ #endif
+ 
+ /* Test if something is a normal file.  */
+ #ifndef S_ISREG
+ #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+ #endif
+ 
+ /* Test if something is a directory.  */
+ #ifndef S_ISDIR
+ #define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+ #endif
+ 
+ #if !defined(GPC) || defined(EGCS)
+ /* Get libiberty declarations. */
+ #include "libiberty.h"
+ #endif
+ 
+ #endif /* __GCC_SYSTEM_H__ */
*** gcc-2.8.1/toplev.c.orig	Thu Feb 26 03:04:46 1998
--- gcc-2.8.1/toplev.c	Mon Sep 11 11:00:40 2000
***************
*** 111,117 ****
  #endif
  
  /* If more than one debugging type is supported, you must define
!    PREFERRED_DEBUGGING_TYPE to choose a format in a system-dependent way. 
  
     This is one long line cause VAXC can't handle a \-newline.  */
  #if 1 < (defined (DBX_DEBUGGING_INFO) + defined (SDB_DEBUGGING_INFO) + defined (DWARF_DEBUGGING_INFO) + defined (DWARF2_DEBUGGING_INFO) + defined (XCOFF_DEBUGGING_INFO))
--- 111,117 ----
  #endif
  
  /* If more than one debugging type is supported, you must define
!    PREFERRED_DEBUGGING_TYPE to choose a format in a system-dependent way.
  
     This is one long line cause VAXC can't handle a \-newline.  */
  #if 1 < (defined (DBX_DEBUGGING_INFO) + defined (SDB_DEBUGGING_INFO) + defined (DWARF_DEBUGGING_INFO) + defined (DWARF2_DEBUGGING_INFO) + defined (XCOFF_DEBUGGING_INFO))
***************
*** 585,591 ****
  int flag_schedule_insns_after_reload = 0;
  
  /* -finhibit-size-directive inhibits output of .size for ELF.
!    This is used only for compiling crtstuff.c, 
     and it may be extended to other effects
     needed for crtstuff.c on other systems.  */
  int flag_inhibit_size_directive = 0;
--- 585,591 ----
  int flag_schedule_insns_after_reload = 0;
  
  /* -finhibit-size-directive inhibits output of .size for ELF.
!    This is used only for compiling crtstuff.c,
     and it may be extended to other effects
     needed for crtstuff.c on other systems.  */
  int flag_inhibit_size_directive = 0;
***************
*** 854,860 ****
  /* Nonzero means warn about any objects definitions whose size is larger
     than N bytes.  Also want about function definitions whose returned
     values are larger than N bytes. The value N is in `larger_than_size'.  */
!  
  int warn_larger_than;
  unsigned larger_than_size;
  
--- 854,860 ----
  /* Nonzero means warn about any objects definitions whose size is larger
     than N bytes.  Also want about function definitions whose returned
     values are larger than N bytes. The value N is in `larger_than_size'.  */
! 
  int warn_larger_than;
  unsigned larger_than_size;
  
***************
*** 1292,1298 ****
      {
        char fmt[sizeof "%.255s"];
        long width = p - s;
!              
        if (width > 255L) width = 255L;	/* arbitrary */
        sprintf (fmt, "%%.%lds", width);
        fprintf (stderr, fmt, s);
--- 1292,1298 ----
      {
        char fmt[sizeof "%.255s"];
        long width = p - s;
! 
        if (width > 255L) width = 255L;	/* arbitrary */
        sprintf (fmt, "%%.%lds", width);
        fprintf (stderr, fmt, s);
***************
*** 1887,1893 ****
    return value;
  }
  
! /* Same as `realloc' but report error if no memory available.  
     Also handle null PTR even if the vendor realloc gets it wrong.  */
  
  char *
--- 1887,1893 ----
    return value;
  }
  
! /* Same as `realloc' but report error if no memory available.
     Also handle null PTR even if the vendor realloc gets it wrong.  */
  
  char *
***************
*** 2348,2361 ****
       When our EH mechanism is low enough overhead that we can enable
       it by default for languages other than C++, then all this braindamage
       will go away.  */
!   
    /* Perform language-specific initialization.
       This may set main_input_filename.  */
    lang_init ();
  
    if (flag_exceptions == 2)
      flag_exceptions = 0;
!      
    /* If the input doesn't start with a #line, use the input name
       as the official input file name.  */
    if (main_input_filename == 0)
--- 2348,2361 ----
       When our EH mechanism is low enough overhead that we can enable
       it by default for languages other than C++, then all this braindamage
       will go away.  */
! 
    /* Perform language-specific initialization.
       This may set main_input_filename.  */
    lang_init ();
  
    if (flag_exceptions == 2)
      flag_exceptions = 0;
! 
    /* If the input doesn't start with a #line, use the input name
       as the official input file name.  */
    if (main_input_filename == 0)
***************
*** 2431,2437 ****
  	 Therefore, I took out that change.
  	 In future versions we should find another way to solve
  	 that dbx problem.  -- rms, 23 May 93.  */
!       
        /* Don't let the first function fall at the same address
  	 as gcc_compiled., if profiling.  */
        if (profile_flag || profile_block_flag)
--- 2431,2437 ----
  	 Therefore, I took out that change.
  	 In future versions we should find another way to solve
  	 that dbx problem.  -- rms, 23 May 93.  */
! 
        /* Don't let the first function fall at the same address
  	 as gcc_compiled., if profiling.  */
        if (profile_flag || profile_block_flag)
***************
*** 2625,2631 ****
  	    && ! DECL_ARTIFICIAL (decl)
  	    && ! TREE_PUBLIC (decl))
  	  {
! 	    pedwarn_with_decl (decl, 
  			       "`%s' declared `static' but never defined");
  	    /* This symbol is effectively an "extern" declaration now.  */
  	    TREE_PUBLIC (decl) = 1;
--- 2625,2631 ----
  	    && ! DECL_ARTIFICIAL (decl)
  	    && ! TREE_PUBLIC (decl))
  	  {
! 	    pedwarn_with_decl (decl,
  			       "`%s' declared `static' but never defined");
  	    /* This symbol is effectively an "extern" declaration now.  */
  	    TREE_PUBLIC (decl) = 1;
***************
*** 2895,2901 ****
  		 /* Don't output anything
  		    when a tentative file-scope definition is seen.
  		    But at end of compilation, do output code for them.  */
! 		 if (! (! at_end && top_level
  			&& (DECL_INITIAL (decl) == 0
  			    || DECL_INITIAL (decl) == error_mark_node)))
  		   assemble_variable (decl, top_level, at_end, 0);
--- 2895,2901 ----
  		 /* Don't output anything
  		    when a tentative file-scope definition is seen.
  		    But at end of compilation, do output code for them.  */
! 	       if (! (! at_end && top_level
  			&& (DECL_INITIAL (decl) == 0
  			    || DECL_INITIAL (decl) == error_mark_node)))
  		   assemble_variable (decl, top_level, at_end, 0);
***************
*** 3835,3840 ****
--- 3835,3844 ----
    /* Initialize register usage now so switches may override.  */
    init_reg_sets ();
  
+ #ifdef GPC
+   pascal_init_options ();
+ #endif
+ 
    for (i = 1; i < argc; i++)
      {
        int j;
***************
*** 4102,4108 ****
  #if !defined (FUNCTION_BLOCK_PROFILER_EXIT) || !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)
  	      warning ("`-ax' option (jump profiling) not supported");
  #else
! 	      profile_block_flag = (!profile_block_flag 
  	                               || profile_block_flag == 2) ? 2 : 3;
  #endif
  	    }
--- 4106,4112 ----
  #if !defined (FUNCTION_BLOCK_PROFILER_EXIT) || !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)
  	      warning ("`-ax' option (jump profiling) not supported");
  #else
! 	      profile_block_flag = (!profile_block_flag
  	                               || profile_block_flag == 2) ? 2 : 3;
  #endif
  	    }
***************
*** 4484,4490 ****
    pos += len;
    return pos;
  }
!      
  /* Print active target switches to FILE.
     POS is the current cursor position and MAX is the size of a "line".
     Each line begins with INDENT and ends with TERM.
--- 4488,4494 ----
    pos += len;
    return pos;
  }
! 
  /* Print active target switches to FILE.
     POS is the current cursor position and MAX is the size of a "line".
     Each line begins with INDENT and ends with TERM.
***************
*** 4585,4591 ****
    if (debug_info_level == DINFO_LEVEL_VERBOSE
        && write_symbols == DWARF2_DEBUG)
      dwarf2out_start_source_file (filename);
! #endif /* DWARF2_DEBUGGING_INFO */  
  #ifdef SDB_DEBUGGING_INFO
    if (write_symbols == SDB_DEBUG)
      sdbout_start_new_source_file (filename);
--- 4589,4595 ----
    if (debug_info_level == DINFO_LEVEL_VERBOSE
        && write_symbols == DWARF2_DEBUG)
      dwarf2out_start_source_file (filename);
! #endif /* DWARF2_DEBUGGING_INFO */
  #ifdef SDB_DEBUGGING_INFO
    if (write_symbols == SDB_DEBUG)
      sdbout_start_new_source_file (filename);
*** gcc-2.8.1/toplev.h.orig	Mon Sep 11 20:46:33 2000
--- gcc-2.8.1/toplev.h	Mon Sep 11 11:00:40 2000
***************
*** 0 ****
--- 1,10 ----
+ extern void warning_with_decl PARAMS((tree decl, char *s, ...));
+ extern void pedwarn_with_decl PARAMS((tree decl, char *s, ...));
+ extern void pedwarn_with_file_and_line PARAMS((char *file, int line, char *s, ...));
+ extern void error_with_file_and_line PARAMS((const char *file, int line, char *s, ...));
+ extern void announce_function PARAMS((tree));
+ extern void rest_of_compilation PARAMS((tree));
+ extern void debug_start_source_file PARAMS ((char *));
+ extern void debug_end_source_file PARAMS ((unsigned));
+ extern void debug_define PARAMS ((unsigned, char *));
+ extern void debug_undef PARAMS ((unsigned, char *));
*** gcc-2.8.1/tree.c.orig	Tue Mar  3 01:37:46 1998
--- gcc-2.8.1/tree.c	Mon Sep 11 11:00:40 2000
***************
*** 1264,1270 ****
  
  tree
  get_identifier (text)
!      register char *text;
  {
    register int hi;
    register int i;
--- 1264,1270 ----
  
  tree
  get_identifier (text)
!      register const char *text;
  {
    register int hi;
    register int i;
***************
*** 1522,1528 ****
  tree
  build_string (len, str)
       int len;
!      char *str;
  {
    /* Put the string in saveable_obstack since it will be placed in the RTL
       for an "asm" statement and will also be kept around a while if
--- 1522,1528 ----
  tree
  build_string (len, str)
       int len;
!      const char *str;
  {
    /* Put the string in saveable_obstack since it will be placed in the RTL
       for an "asm" statement and will also be kept around a while if
***************
*** 4739,4744 ****
--- 4739,4753 ----
    HOST_WIDE_INT domain_min
      = TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (init))));
    tree non_const_bits = NULL_TREE;
+ 
+ #ifdef GPC
+   /* Align the set.  */
+   if (set_alignment)
+     /* Note: `domain_min -= domain_min % set_alignment' would be wrong for negative
+        numbers (rounding towards 0, while we have to round towards -inf). */
+     domain_min &= -set_alignment;
+ #endif /* GPC */
+ 
    for (i = 0; i < bit_size; i++)
      buffer[i] = 0;
  
***************
*** 4758,4765 ****
  	  HOST_WIDE_INT hi_index
  	    = TREE_INT_CST_LOW (TREE_VALUE (vals)) - domain_min;
  	  if (lo_index < 0 || lo_index >= bit_size
! 	    || hi_index < 0 || hi_index >= bit_size)
! 	    abort ();
  	  for ( ; lo_index <= hi_index; lo_index++)
  	    buffer[lo_index] = 1;
  	}
--- 4767,4777 ----
  	  HOST_WIDE_INT hi_index
  	    = TREE_INT_CST_LOW (TREE_VALUE (vals)) - domain_min;
  	  if (lo_index < 0 || lo_index >= bit_size
! 	      || hi_index < 0 || hi_index >= bit_size)
! 	    {
! 	      error ("invalid set initializer");
! 	      return NULL_TREE;
! 	    }
  	  for ( ; lo_index <= hi_index; lo_index++)
  	    buffer[lo_index] = 1;
  	}
***************
*** 4770,4776 ****
  	    = TREE_INT_CST_LOW (TREE_VALUE (vals)) - domain_min;
  	  if (index < 0 || index >= bit_size)
  	    {
! 	      error ("invalid initializer for bit string");
  	      return NULL_TREE;
  	    }
  	  buffer[index] = 1;
--- 4782,4788 ----
  	    = TREE_INT_CST_LOW (TREE_VALUE (vals)) - domain_min;
  	  if (index < 0 || index >= bit_size)
  	    {
! 	      error ("invalid set initializer");
  	      return NULL_TREE;
  	    }
  	  buffer[index] = 1;
***************
*** 4792,4799 ****
--- 4799,4810 ----
  {
    int i;
    tree vals = TREE_OPERAND (init, 1);
+ #ifdef GPC
+   int bit_size = wd_size * BITS_PER_UNIT;
+ #else /* not GPC */
    int set_word_size = BITS_PER_UNIT;
    int bit_size = wd_size * set_word_size;
+ #endif /* not GPC */
    int bit_pos = 0;
    unsigned char *bytep = buffer;
    char *bit_buffer = (char *) alloca(bit_size);
***************
*** 4804,4809 ****
--- 4815,4838 ----
  
    for (i = 0; i < bit_size; i++)
      {
+ #ifdef GPC
+       if (bit_buffer[i])
+         {
+           int k = bit_pos / BITS_PER_UNIT;
+           if (WORDS_BIG_ENDIAN)
+             k = set_word_size / BITS_PER_UNIT - 1 - k;
+           if (set_words_big_endian)
+             bytep[k] |= (1 << (BITS_PER_UNIT - 1 - bit_pos % BITS_PER_UNIT));
+           else
+             bytep[k] |= (1 << (bit_pos % BITS_PER_UNIT));
+         }
+       bit_pos++;
+       if (bit_pos >= set_word_size)
+         {
+           bit_pos = 0;
+           bytep += set_word_size / BITS_PER_UNIT;
+         }
+ #else /* not GPC */
        if (bit_buffer[i])
  	{
  	  if (BYTES_BIG_ENDIAN)
***************
*** 4814,4819 ****
--- 4843,4849 ----
        bit_pos++;
        if (bit_pos >= set_word_size)
  	bit_pos = 0, bytep++;
+ #endif /* not GPC */
      }
    return non_const_bits;
  }
*** gcc-2.8.1/tree.h.orig	Sat Feb 28 21:58:23 1998
--- gcc-2.8.1/tree.h	Mon Sep 11 11:00:40 2000
***************
*** 19,24 ****
--- 19,27 ----
  Boston, MA 02111-1307, USA.  */
  
  #include "machmode.h"
+ #ifdef GPC
+ #include <stdio.h>
+ #endif
  
  #ifndef RTX_CODE
  struct rtx_def;
***************
*** 1258,1264 ****
  /* Return the (unique) IDENTIFIER_NODE node for a given name.
     The name is supplied as a char *.  */
  
! extern tree get_identifier		PROTO((char *));
  
  /* If an identifier with the name TEXT (a null-terminated string) has
     previously been referred to, return that node; otherwise return
--- 1265,1271 ----
  /* Return the (unique) IDENTIFIER_NODE node for a given name.
     The name is supplied as a char *.  */
  
! extern tree get_identifier		PROTO((const char *));
  
  /* If an identifier with the name TEXT (a null-terminated string) has
     previously been referred to, return that node; otherwise return
***************
*** 1279,1285 ****
  extern tree build_real			PROTO((tree, REAL_VALUE_TYPE));
  extern tree build_real_from_int_cst 	PROTO((tree, tree));
  extern tree build_complex		PROTO((tree, tree, tree));
! extern tree build_string		PROTO((int, char *));
  extern tree build1			PROTO((enum tree_code, tree, tree));
  extern tree build_tree_list		PROTO((tree, tree));
  extern tree build_decl_list		PROTO((tree, tree));
--- 1286,1292 ----
  extern tree build_real			PROTO((tree, REAL_VALUE_TYPE));
  extern tree build_real_from_int_cst 	PROTO((tree, tree));
  extern tree build_complex		PROTO((tree, tree, tree));
! extern tree build_string		PROTO((int, const char *));
  extern tree build1			PROTO((enum tree_code, tree, tree));
  extern tree build_tree_list		PROTO((tree, tree));
  extern tree build_decl_list		PROTO((tree, tree));
***************
*** 1409,1414 ****
--- 1419,1432 ----
  /* If non-zero, the alignment of a bitstring or (power-)set value, in bits. */
  extern int set_alignment;
  
+ #ifdef GPC
+ /* The word size of a bitstring or (power-)set value, in bits.  */
+ extern int set_word_size;
+ 
+ /* If non-zero, bits in (power-)sets start with the highest bit.  */
+ extern int set_words_big_endian;
+ #endif /* GPC */
+ 
  /* Concatenate two lists (chains of TREE_LIST nodes) X and Y
     by making the last node in X point to Y.
     Returns X, except if X is 0 returns Y.  */
***************
*** 1891,1893 ****
--- 1909,1945 ----
  
  /* Pop the obstack selection stack.  */
  extern void pop_obstacks PROTO((void));
+ 
+ #ifdef GPC
+ extern void set_identifier_size PARAMS((int));
+ extern void put_var_into_stack PARAMS((tree));
+ extern void expand_asm_operands PARAMS((tree, tree, tree, tree, int, char *, int));
+ extern void free_temp_slots PARAMS((void));
+ extern int exact_log2_wide PARAMS((register unsigned HOST_WIDE_INT));
+ extern int floor_log2_wide PARAMS((register unsigned HOST_WIDE_INT));
+ extern void print_node PARAMS((FILE *, const char *, tree, int));
+ extern void indent_to PARAMS((FILE *, int));
+ extern void push_function_context PARAMS((void));
+ extern void output_inline_function PARAMS((tree));
+ extern void pop_function_context PARAMS((void));
+ extern void remember_end_note PARAMS((register tree));
+ extern void push_obstacks PARAMS((struct obstack *, struct obstack *saveable));
+ extern int chain_member PARAMS((tree, tree));
+ extern void declare_nonlocal_label PARAMS((tree));
+ extern void resume_temporary_allocation PARAMS((void));
+ extern void fixup_signed_type PARAMS((tree));
+ extern void start_identifier_warnings PARAMS((void));
+ extern void expand_decl PARAMS((register tree));
+ extern void temporary_allocation PARAMS((void));
+ extern void preserve_initializer PARAMS((void));
+ extern void preserve_data PARAMS((void));
+ extern void init_function_start PARAMS((tree, char*, int));
+ extern void mark_varargs PARAMS((void));
+ extern void expand_function_start PARAMS((tree, int));
+ extern void expand_main_function PARAMS((void));
+ extern void setjmp_protect PARAMS((tree));
+ extern void setjmp_protect_args PARAMS((void));
+ extern void expand_function_end PARAMS((char *, int, int));
+ extern void assemble_alias PARAMS((tree, tree));
+ extern void declare_weak PARAMS((tree));
+ #endif
*** gcc-2.8.1/config/i386/go32.h.orig	Fri Aug  8 22:18:23 1997
--- gcc-2.8.1/config/i386/go32.h	Mon Sep 11 11:00:40 2000
***************
*** 16,23 ****
  #ifdef CPP_PREDEFINES
  #undef CPP_PREDEFINES
  #endif
! #define CPP_PREDEFINES "-Dunix -Di386 -DGO32 -DMSDOS \
    -Asystem(unix) -Asystem(msdos) -Acpu(i386) -Amachine(i386)"
  
  #undef EXTRA_SECTIONS
  #define EXTRA_SECTIONS in_ctor, in_dtor
--- 16,31 ----
  #ifdef CPP_PREDEFINES
  #undef CPP_PREDEFINES
  #endif
! #define CPP_PREDEFINES "-Dunix -Di386 -DGO32 -DMSDOS -DDJGPP=2 \
    -Asystem(unix) -Asystem(msdos) -Acpu(i386) -Amachine(i386)"
+ 
+ #define LINK_COMMAND_SPEC \
+   "%{!c:%{!M:%{!MM:%{!E:%{!S:ld %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n}" \
+   "       %{r} %{s} %{t} %{u*} %{x} %{z}" \
+   "       %{!A:%{!nostartfiles:%{!nostdlib:%S}}} %{static:}" \
+   "       %{L*} %D %{T*} %o -Tdjgpp.djl" \
+   "       %{!nostdlib:-lgcc %L -lgcc %{!A:%E}}}}}}}\n" \
+   "%{!c:%{!M:%{!MM:%{!E:%{!S:stubify %{v} %{o*:%*} %{!o*:a.out} }}}}}"
  
  #undef EXTRA_SECTIONS
  #define EXTRA_SECTIONS in_ctor, in_dtor
*** gcc-2.8.1/stor-layout.c.orig	Tue Sep 12 05:08:51 2000
--- gcc-2.8.1/stor-layout.c	Wed Nov 14 08:05:50 2001
***************
*** 983,989 ****
            int upper_bound = TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)));
            int size_in_bits, rounded_size;
            if (set_alignment)
!             size_in_bits = upper_bound - (lower_bound / alignment) * alignment + 1;
            else
              size_in_bits
                = (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))
--- 983,989 ----
            int upper_bound = TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)));
            int size_in_bits, rounded_size;
            if (set_alignment)
!             size_in_bits = upper_bound - (lower_bound & (-alignment)) + 1;
            else
              size_in_bits
                = (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))
*** gcc-2.8.1/expr.c.orig	Thu Nov 29 18:39:47 2001
--- gcc-2.8.1/expr.c	Thu Nov 29 18:39:21 2001
***************
*** 4001,4009 ****
  #else /* not GPC */
  		  if (BYTES_BIG_ENDIAN)
  #endif /* not GPC */
! 		    word |= (1 << (set_word_size - 1 - bit_pos));
  		  else
! 		    word |= 1 << bit_pos;
  		}
  	      bit_pos++;  ibit++;
  	      if (bit_pos >= set_word_size || ibit == nbits)
--- 4001,4009 ----
  #else /* not GPC */
  		  if (BYTES_BIG_ENDIAN)
  #endif /* not GPC */
! 		    word |= ((HOST_WIDE_INT) 1 << (set_word_size - 1 - bit_pos));
  		  else
! 		    word |= (HOST_WIDE_INT) 1 << bit_pos;
  		}
  	      bit_pos++;  ibit++;
  	      if (bit_pos >= set_word_size || ibit == nbits)
*** gcc-2.8.1/tree.c.orig	Sat Feb  2 12:16:54 2002
--- gcc-2.8.1/tree.c	Mon Feb  4 02:32:18 2002
***************
*** 645,650 ****
--- 645,667 ----
      = (char *) obstack_alloc (function_maybepermanent_obstack, 0);
  }
  
+ #ifdef GPC
+ /* When building a type copy or something similar, and the original
+    type (whose obstack is used, which is done by the caller) is
+    placed on the function_maybepermanent_obstack *before* its limit
+    (maybepermanent_firstobj), the new type must be there as well
+    because it is kept as a variant of the original type, i.e. we
+    must set the limit here. */
+ static void
+ check_type_obstack (type)
+      tree type;
+ {
+   if (TYPE_OBSTACK (type) == function_maybepermanent_obstack
+       && (char *) type < maybepermanent_firstobj)
+     preserve_data ();
+ }
+ #endif
+ 
  void
  preserve_initializer ()
  {
***************
*** 3196,3201 ****
--- 3212,3220 ----
  
        ntype = copy_node (ttype);
        current_obstack = ambient_obstack;
+ #ifdef GPC
+       check_type_obstack (ttype);
+ #endif
  
        TYPE_POINTER_TO (ntype) = 0;
        TYPE_REFERENCE_TO (ntype) = 0;
***************
*** 3495,3500 ****
--- 3514,3522 ----
    current_obstack = TYPE_OBSTACK (type);
    t = copy_node (type);
    current_obstack = ambient_obstack;
+ #ifdef GPC
+   check_type_obstack (type);
+ #endif
  
    TYPE_POINTER_TO (t) = 0;
    TYPE_REFERENCE_TO (t) = 0;
***************
*** 3950,3955 ****
--- 3972,3980 ----
    push_obstacks (TYPE_OBSTACK (to_type), TYPE_OBSTACK (to_type));
    t = make_node (POINTER_TYPE);
    pop_obstacks ();
+ #ifdef GPC
+   check_type_obstack (to_type);
+ #endif
  
    TREE_TYPE (t) = to_type;
  
***************
*** 3985,3990 ****
--- 4010,4018 ----
    push_obstacks (TYPE_OBSTACK (itype), TYPE_OBSTACK (itype));
    TYPE_MAX_VALUE (itype) = convert (sizetype, maxval);
    pop_obstacks ();
+ #ifdef GPC
+   check_type_obstack (itype);
+ #endif
  
    TYPE_MODE (itype) = TYPE_MODE (sizetype);
    TYPE_SIZE (itype) = TYPE_SIZE (sizetype);
***************
*** 4024,4029 ****
--- 4052,4060 ----
    TYPE_MIN_VALUE (itype) = convert (type, lowval);
    TYPE_MAX_VALUE (itype) = convert (type, highval);
    pop_obstacks ();
+ #ifdef GPC
+   check_type_obstack (itype);
+ #endif
  
    TYPE_PRECISION (itype) = TYPE_PRECISION (type);
    TYPE_MODE (itype) = TYPE_MODE (type);
***************
*** 4169,4174 ****
--- 4200,4208 ----
    push_obstacks (TYPE_OBSTACK (to_type), TYPE_OBSTACK (to_type));
    t = make_node (REFERENCE_TYPE);
    pop_obstacks ();
+ #ifdef GPC
+   check_type_obstack (to_type);
+ #endif
  
    TREE_TYPE (t) = to_type;
  
*** gcc-2.8.1/Makefile.in.orig	Tue Sep 12 05:08:50 2000
--- gcc-2.8.1/Makefile.in	Sun Feb 10 12:49:56 2002
***************
*** 1346,1353 ****
--- 1346,1363 ----
     insn-flags.h insn-config.h insn-codes.h expr.h real.h regs.h function.h \
     bytecode.h output.h $(RECOG_H) except.h
  
+ # @@@@ GPC based on gcc-2.8.1 crashes (fjf559i.pas, compiling with `-O' or
+ #    higher) when jump.c is compiled with `-O3' (sic!). Since gcc-2.8.1 is
+ #    not maintained anymore, it might not be worth the effort to debug this
+ #    further (until the problem starts appearing with other GCC versions
+ #    ...), so "don't to that then". So I'm adding `-fno-inline-functions'
+ #    here. For the same reason, it's probably not worth making it conditional
+ #    on GPC (which would take more than a simple `#ifdef' in the C files).
+ #    -- Frank
  jump.o : jump.c $(CONFIG_H) $(RTL_H) flags.h hard-reg-set.h regs.h \
     insn-config.h insn-flags.h $(RECOG_H) expr.h real.h except.h
+ 	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -fno-inline-functions $<
+ 
  stupid.o : stupid.c $(CONFIG_H) $(RTL_H) regs.h hard-reg-set.h flags.h
  
  cse.o : cse.c $(CONFIG_H) $(RTL_H) regs.h hard-reg-set.h flags.h real.h \
*** gcc-2.8.1/toplev.c.orig	Tue Sep 12 05:08:51 2000
--- gcc-2.8.1/toplev.c	Fri Apr 26 23:20:46 2002
***************
*** 171,177 ****
  extern void regset_release_memory ();
  
  void rest_of_decl_compilation ();
! void error_with_file_and_line PVPROTO((char *file, int line, char *s, ...));
  void error_with_decl PVPROTO((tree decl, char *s, ...));
  void error_for_asm PVPROTO((rtx insn, char *s, ...));
  void error PVPROTO((char *s, ...));
--- 171,177 ----
  extern void regset_release_memory ();
  
  void rest_of_decl_compilation ();
! void error_with_file_and_line PVPROTO((const char *file, int line, char *s, ...));
  void error_with_decl PVPROTO((tree decl, char *s, ...));
  void error_for_asm PVPROTO((rtx insn, char *s, ...));
  void error PVPROTO((char *s, ...));
***************
*** 1241,1247 ****
  
  static void
  v_message_with_file_and_line (file, line, prefix, s, ap)
!      char *file;
       int line;
       char *prefix;
       char *s;
--- 1241,1247 ----
  
  static void
  v_message_with_file_and_line (file, line, prefix, s, ap)
!      const char *file;
       int line;
       char *prefix;
       char *s;
***************
*** 1359,1365 ****
  
  static void
  v_error_with_file_and_line (file, line, s, ap)
!      char *file;
       int line;
       char *s;
       va_list ap;
--- 1359,1365 ----
  
  static void
  v_error_with_file_and_line (file, line, s, ap)
!      const char *file;
       int line;
       char *s;
       va_list ap;
***************
*** 1370,1379 ****
  }
  
  void
! error_with_file_and_line VPROTO((char *file, int line, char *s, ...))
  {
  #ifndef __STDC__
!   char *file;
    int line;
    char *s;
  #endif
--- 1370,1379 ----
  }
  
  void
! error_with_file_and_line VPROTO((const char *file, int line, char *s, ...))
  {
  #ifndef __STDC__
!   const char *file;
    int line;
    char *s;
  #endif
***************
*** 1382,1388 ****
    VA_START (ap, s);
  
  #ifndef __STDC__
!   file = va_arg (ap, char *);
    line = va_arg (ap, int);
    s = va_arg (ap, char *);
  #endif
--- 1382,1388 ----
    VA_START (ap, s);
  
  #ifndef __STDC__
!   file = va_arg (ap, const char *);
    line = va_arg (ap, int);
    s = va_arg (ap, char *);
  #endif
*** gcc-2.8.1/toplev.c.orig	Tue Sep 12 05:08:51 2000
--- gcc-2.8.1/toplev.c	Fri Apr 26 23:20:46 2002
***************
*** 1151,1157 ****
  
  void
  default_print_error_function (file)
!      char *file;
  {
    if (last_error_function != current_function_decl)
      {
--- 1151,1157 ----
  
  void
  default_print_error_function (file)
!      const char *file;
  {
    if (last_error_function != current_function_decl)
      {
***************
*** 1178,1191 ****
  /* Called by report_error_function to print out function name.
   * Default may be overridden by language front-ends.  */
  
! void (*print_error_function) PROTO((char *)) = default_print_error_function;
  
  /* Prints out, if necessary, the name of the current function
    that caused an error.  Called from all error and warning functions.  */
  
  void
  report_error_function (file)
!      char *file;
  {
    struct file_stack *p;
  
--- 1178,1191 ----
  /* Called by report_error_function to print out function name.
   * Default may be overridden by language front-ends.  */
  
! void (*print_error_function) PROTO((const char *)) = default_print_error_function;
  
  /* Prints out, if necessary, the name of the current function
    that caused an error.  Called from all error and warning functions.  */
  
  void
  report_error_function (file)
!      const char *file;
  {
    struct file_stack *p;
  
*** gcc-2.8.1/genattr.c.orig	Wed Oct  9 13:25:39 1996
--- gcc-2.8.1/genattr.c	Tue Oct 22 17:05:21 2002
***************
*** 215,221 ****
  
  static void
  fatal (s, a1, a2)
!      char *s;
  {
    fprintf (stderr, "genattr: ");
    fprintf (stderr, s, a1, a2);
--- 215,221 ----
  
  static void
  fatal (s, a1, a2)
!      const char *s;
  {
    fprintf (stderr, "genattr: ");
    fprintf (stderr, s, a1, a2);
*** gcc-2.8.1/genattrtab.c.orig	Fri Feb  6 21:18:02 1998
--- gcc-2.8.1/genattrtab.c	Tue Oct 22 17:39:42 2002
***************
*** 106,111 ****
--- 106,113 ----
  #include "rtl.h"
  #include "insn-config.h"	/* For REGISTER_CONSTRAINTS */
  
+ #include "auto-config.h"
+ 
  #ifdef TIME_WITH_SYS_TIME
  # include <sys/time.h>
  # include <time.h>
*** gcc-2.8.1/genattr.c.orig	Tue Oct 22 17:05:21 2002
--- gcc-2.8.1/genattr.c	Tue Oct 22 17:43:10 2002
***************
*** 35,41 ****
  extern rtx read_rtx PROTO((FILE *));
  
  char *xmalloc PROTO((unsigned));
! static void fatal ();
  void fancy_abort PROTO((void));
  
  /* A range of values.  */
--- 35,42 ----
  extern rtx read_rtx PROTO((FILE *));
  
  char *xmalloc PROTO((unsigned));
! static void fatal PROTO((const char *));
! static void fatal1 PROTO((const char *, const char *));
  void fancy_abort PROTO((void));
  
  /* A range of values.  */
***************
*** 214,224 ****
  }
  
  static void
! fatal (s, a1, a2)
       const char *s;
  {
    fprintf (stderr, "genattr: ");
!   fprintf (stderr, s, a1, a2);
    fprintf (stderr, "\n");
    exit (FATAL_EXIT_CODE);
  }
--- 215,235 ----
  }
  
  static void
! fatal (s)
       const char *s;
  {
    fprintf (stderr, "genattr: ");
!   fprintf (stderr, s);
!   fprintf (stderr, "\n");
!   exit (FATAL_EXIT_CODE);
! }
! 
! static void
! fatal1 (s, a1)
!      const char *s, *a1;
! {
!   fprintf (stderr, "genattr: ");
!   fprintf (stderr, s, a1);
    fprintf (stderr, "\n");
    exit (FATAL_EXIT_CODE);
  }
***************
*** 353,359 ****
  	    }
  	  else if (unit->multiplicity != multiplicity
  		   || unit->simultaneity != simultaneity)
! 	    fatal ("Differing specifications given for `%s' function unit.",
  		   unit->name);
  
  	  extend_range (&unit->ready_cost, ready_cost, ready_cost);
--- 364,370 ----
  	    }
  	  else if (unit->multiplicity != multiplicity
  		   || unit->simultaneity != simultaneity)
! 	    fatal1 ("Differing specifications given for `%s' function unit.",
  		   unit->name);
  
  	  extend_range (&unit->ready_cost, ready_cost, ready_cost);
*** gcc-2.8.1/dbxout.c.orig	Sun Jan 27 00:38:14 2002
--- gcc-2.8.1/dbxout.c	Sat Nov  2 07:06:00 2002
***************
*** 1129,1134 ****
--- 1129,1138 ----
  	  fprintf (asmfile, ";0;127;");
  	}
        else if (use_gnu_debug_info_extensions
+ #ifdef GPC
+ 	       && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST
+ 	       && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST
+ #endif
  	       && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)
  		   || TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT))
  	{
*** gcc-2.8.1/dwarf2out.c.orig	Sat Feb 28 21:58:13 1998
--- gcc-2.8.1/dwarf2out.c	Tue Oct  8 12:01:09 2002
***************
*** 7068,7082 ****
        /* Else leave out the attribute.  */
        break;
  
-     case MAX_EXPR:
      case VAR_DECL:
      case COMPONENT_REF:
!       /* ??? These types of bounds can be created by the Ada front end,
! 	 and it isn't clear how to emit debug info for them.  */
        break;
  
      default:
!       abort ();
      }
  }
  
--- 7068,7084 ----
        /* Else leave out the attribute.  */
        break;
  
      case VAR_DECL:
      case COMPONENT_REF:
!     case PARM_DECL:
!       /* ??? These types of bounds as well as all kinds of expressions
!              can be created by the Ada and Pascal front ends,
!              and it isn't clear how to emit debug info for them.  */
        break;
  
      default:
!       if (TREE_CODE_CLASS (TREE_CODE (bound)) != 'e')
!         abort ();
      }
  }
  
***************
*** 7414,7420 ****
        if (i == 0)
  	{
  	  assert (scope_die == comp_unit_die);
! 	  assert (TREE_CODE_CLASS (TREE_CODE (containing_scope)) == 't');
  	  if (debug_info_level > DINFO_LEVEL_TERSE)
  	    assert (TREE_ASM_WRITTEN (containing_scope));
  	}
--- 7416,7423 ----
        if (i == 0)
  	{
  	  assert (scope_die == comp_unit_die);
! 	  assert (TREE_CODE_CLASS (TREE_CODE (containing_scope)) == 't'
! 	          || TREE_CODE_CLASS (TREE_CODE (containing_scope)) == 'd');
  	  if (debug_info_level > DINFO_LEVEL_TERSE)
  	    assert (TREE_ASM_WRITTEN (containing_scope));
  	}
*** gcc-2.8.1/function.c.orig	Sat Feb 28 21:58:16 1998
--- gcc-2.8.1/function.c	Sat Nov  9 03:49:23 2002
***************
*** 1377,1383 ****
  
    /* If this is a variable-size object with a pseudo to address it,
       put that pseudo into the stack, if the var is nonlocal.  */
!   if (DECL_NONLOCAL (decl)
        && GET_CODE (reg) == MEM
        && GET_CODE (XEXP (reg, 0)) == REG
        && REGNO (XEXP (reg, 0)) > LAST_VIRTUAL_REGISTER)
--- 1377,1383 ----
  
    /* If this is a variable-size object with a pseudo to address it,
       put that pseudo into the stack, if the var is nonlocal.  */
!   if (TREE_CODE (decl) != SAVE_EXPR && DECL_NONLOCAL (decl)
        && GET_CODE (reg) == MEM
        && GET_CODE (XEXP (reg, 0)) == REG
        && REGNO (XEXP (reg, 0)) > LAST_VIRTUAL_REGISTER)
*** gcc-2.8.1/configure.orig	Fri Aug 31 05:50:18 2001
--- gcc-2.8.1/configure	Thu Nov 14 16:34:34 2002
***************
*** 5713,5719 ****
  			echo "${srcdir}/$s/config-lang.in doesn't set \$language." 1>&2
  			exit 1
  		fi
! 		all_lang_makefiles="$all_lang_makefiles ${srcdir}/$s/Make-lang.in ${srcdir}/$s/Makefile.in"
  		all_languages="$all_languages $language"
  		if [ "x$boot_language" = xyes ]
  		then
--- 5713,5722 ----
  			echo "${srcdir}/$s/config-lang.in doesn't set \$language." 1>&2
  			exit 1
  		fi
! 		all_lang_makefiles="$all_lang_makefiles ${srcdir}/$s/Make-lang.in"
! 		if test -f ${srcdir}/$s/Makefile.in
! 		then all_lang_makefiles="$all_lang_makefiles ${srcdir}/$s/Makefile.in"
! 		fi
  		all_languages="$all_languages $language"
  		if [ "x$boot_language" = xyes ]
  		then
*** gcc-2.8.1/configure.lang.orig	Thu Nov 14 16:54:53 2002
--- gcc-2.8.1/configure.lang	Thu Nov 14 16:57:07 2002
***************
*** 50,55 ****
--- 50,56 ----
  	test -d $subdir || mkdir $subdir
  	cd $subdir
  
+ if test -f Makefile.in; then
  	# Create Makefile.tem from Makefile.in.
  	# Make it set VPATH if necessary so that the sources are found.
  	# Also change its value of srcdir.
***************
*** 157,162 ****
--- 158,164 ----
  		mv Makefile.xx Makefile.tem
  		rm -f Makefile.ll
  	fi
+ fi
  
  	# If the host supports
  	# symlinks, point stage[123] at ../stage[123] so bootstrapping and the
***************
*** 169,174 ****
--- 171,177 ----
  		$symbolic_link ../$t $t 2>/dev/null
  	done
  
+ if test -f Makefile.in; then
  	# Remove all formfeeds, since some Makes get confused by them.
  	# Also arrange to give the variables `target', `target_alias',
  	# `host_xmake_file', `tmake_file', `prefix', `local_prefix',
***************
*** 225,230 ****
--- 228,234 ----
  	rm -f Makefile
  	mv Makefile.tem Makefile
  	echo "Created \`$subdir/Makefile'."
+ fi
  
  	cd $STARTDIR
  done   # end of current-dir SUBDIRS loop
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Import an alpha version of GNU Pascal Compiler into the tree
(not to be connected to the build before the upgrade to gcc 3.3).

We couldn't use gpc 2.1 because it's too old and doesn't support
gcc 3.x at all.
@
text
@@
