head	1.2;
access;
symbols
	gpc-20030830:1.1.2.1 FSF:1.1.2;
locks; strict;
comment	@# @;


1.2
date	2004.01.11.18.16.57;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2004.01.11.18.01.03;	author tg;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.01.11.18.01.03;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@nuke some unused, redundant or generated files
@
text
@This is ../p/doc/info/gpc.info, produced by makeinfo version 4.1 from
gpc.texi.

INFO-DIR-SECTION GNU programming tools
START-INFO-DIR-ENTRY
* GPC: (gpc).                   The GNU Pascal Compiler.
END-INFO-DIR-ENTRY
INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* GPC: (gpc)Invoking GPC.       The GNU Pascal Compiler.
END-INFO-DIR-ENTRY

   This file documents the GNU Pascal Compiler.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Copyright (C) 1988-2003 Free Software Foundation, Inc.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License", "The GNU
Project", "The GNU Manifesto" and "Funding for free Software" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License", "The GNU Project", "The GNU Manifesto" and "Funding for Free
Software" and this permission notice, may be included in translations
approved by the Free Software Foundation instead of in the original
English.


File: gpc.info,  Node: BitSizeOf,  Next: BlockRead,  Prev: BindingType,  Up: Reference

BitSizeOf
=========

Synopsis
--------

     function BitSizeOf (var x): SizeType;

Description
-----------

   Returns the size of a type or variable in bits.

Conforming to
-------------

   `BitSizeOf' is a GNU Pascal extension.

Example
-------

     program BitSizeOfDemo;
     type
       Int12 = Integer attribute (Size = 12);
     var
       a: Integer;
       b: array [1 .. 8] of Char;
       c: Int12;
       d: packed record
            x: Int12;
            y: 0 .. 3
          end;
     begin
       WriteLn (BitSizeOf (a));    { Size of an `Integer'; usually 32 bits. }
       WriteLn (BitSizeOf (Integer));  { The same. }
       WriteLn (BitSizeOf (b));    { Size of eight `Char's; usually 64 bits. }
       WriteLn (BitSizeOf (c));    { e.g. 16 bits (smallest addressable space). }
       WriteLn (BitSizeOf (d));    { e.g. 16 }
       WriteLn (BitSizeOf (d.x));  { 12 }
       WriteLn (BitSizeOf (d.y))   { 2 }
     end.

See also
--------

   *Note SizeOf::, *Note AlignOf::, *Note TypeOf::.


File: gpc.info,  Node: BlockRead,  Next: BlockWrite,  Prev: BitSizeOf,  Up: Reference

BlockRead
=========

   (Under construction.)

Synopsis
--------

     procedure BlockRead (var F: File; var Buffer; Blocks: Integer);
   or
     procedure BlockRead (var F: File; var Buffer; Blocks: Integer;
                          var BlocksRead: Integer);

Description
-----------

Conforming to
-------------

   `BlockRead' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: BlockWrite,  Next: Boolean,  Prev: BlockRead,  Up: Reference

BlockWrite
==========

   (Under construction.)

Synopsis
--------

     procedure BlockWrite (var F: File; const Buffer; Blocks: Integer);
   or
     procedure BlockWrite (var F: File; const Buffer; Blocks: Integer;
                           var BlocksWritten: Integer);

Description
-----------

Conforming to
-------------

   `BlockWrite' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: Boolean,  Next: Break,  Prev: BlockWrite,  Up: Reference

Boolean
=======

Synopsis
--------

     type
       Boolean = (False, True); { built-in type }

Description
-----------

   The intrinsic `Boolean' represents boolean values, i.e. it can only
assume the two values `True' and `False' (which are predefined
constants).

Conforming to
-------------

   `Boolean' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program BooleanDemo;
     var
       a: Boolean;
     begin
       a := True;
       WriteLn (a)
     end.

See also
--------

   *Note Boolean (Intrinsic)::, *Note True::, *Note False::, *Note
CBoolean::, *Note ByteBool::, *Note ShortBool::, *Note MedBool::, *Note
WordBool::, *Note LongBool::, *Note LongestBool::.


File: gpc.info,  Node: Break,  Next: Byte,  Prev: Boolean,  Up: Reference

Break
=====

Synopsis
--------

     Break  { simple statement }

Description
-----------

   With `Break' you can exit the body of the current loop instantly.
It can only be used within a WHILE, REPEAT or a FOR statement.

Conforming to
-------------

   `Break' is a Borland Pascal extension.

Example
-------

     program BreakDemo;
     var
       Foo: Integer;
     begin
       while True do
         begin
           repeat
             WriteLn ('Enter a number less than 100:');
             ReadLn (Foo);
             if Foo < 100 then
               Break;  { Exits `repeat' loop }
             WriteLn (Foo, ' is not exactly less than 100! Try again ...')
           until False;
           if Foo > 50 then
             Break;  { Exits `while' loop }
           WriteLn ('The number entered was not greater than 50.')
         end
     end.

See also
--------

   *Note Loop Control Statements::, *Note Continue::, *Note Exit::,
*Note Halt::, *Note Return::, *Note goto::.


File: gpc.info,  Node: Byte,  Next: ByteBool,  Prev: Break,  Up: Reference

Byte
====

Synopsis
--------

     type
       Byte  { built-in type }

Description
-----------

   `Byte' is an unsigned integer type which is one "unit" wide.  On
most platforms one unit has 8 bits, therefore the type is named "byte"
and usually has a range of `0..255'. (It is the same as *Note
ByteCard::.)

   `Byte' in GNU Pascal is compatible to `unsigned char' in GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `Byte' is a Borland Pascal extension. (For something equivalent in
ISO Pascal, see *Note Subrange Types::.)

Example
-------

     program ByteDemo;
     var
       a: Byte;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc.info,  Node: ByteBool,  Next: ByteCard,  Prev: Byte,  Up: Reference

ByteBool
========

Synopsis
--------

     type
       ByteBool = Boolean attribute (Size = BitSizeOf (Byte)); { built-in type }

Description
-----------

   The intrinsic `ByteBool' represents boolean values, but occupies the
same memory space as a `Byte'.  It is used when you need to define a
parameter or record that conforms to some external library or system
specification.

Conforming to
-------------

   `ByteBool' is a Borland Pascal extension.

Example
-------

     program ByteBoolDemo;
     var
       a: ByteBool;
     begin
       Byte (a) := 1;
       if a then WriteLn ('Ord (True) = 1')
     end.

See also
--------

   *Note Boolean (Intrinsic)::, *Note Boolean::, *Note True::, *Note
False::, *Note CBoolean::, *Note ShortBool::, *Note MedBool::, *Note
WordBool::, *Note LongBool::, *Note LongestBool::.


File: gpc.info,  Node: ByteCard,  Next: ByteInt,  Prev: ByteBool,  Up: Reference

ByteCard
========

Synopsis
--------

     type
       ByteCard = Cardinal attribute (Size = BitSizeOf (Byte));

Description
-----------

   `ByteCard' is an unsigned integer type which is one "unit" wide.  On
most platforms one unit has 8 bits, therefore the type is prefixed
"byte-" and usually has a range of `0..255'.

   `ByteCard' in GNU Pascal is compatible to `unsigned char' in GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `ByteCard' is a GNU Pascal extension.

Example
-------

     program ByteCardDemo;
     var
       a: ByteCard;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc.info,  Node: ByteInt,  Next: c,  Prev: ByteCard,  Up: Reference

ByteInt
=======

Synopsis
--------

     type
       ByteInt = Integer attribute (Size = BitSizeOf (Byte));

Description
-----------

   `ByteInt' is a signed integer type which is one "unit" wide.  On
most platforms one unit has 8 bits, therefore the type is prefixed
"byte-" and usually has a range of `-128..127'.

   `ByteInt' in GNU Pascal is compatible to `signed char' in GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `ByteInt' is a GNU Pascal extension.

   `ByteInt' in GNU Pascal corresponds to *Note ShortInt:: in Borland
Pascal.

Example
-------

     program ByteIntDemo;
     var
       a: ByteInt;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc.info,  Node: c,  Next: Card,  Prev: ByteInt,  Up: Reference

c
=

Synopsis
--------

Description
-----------

   *Deprecated*! Use `external' now.

Conforming to
-------------

Example
-------

See also
--------

   *Note Keywords::, *Note Importing Libraries from Other Languages::,
*Note external::.


File: gpc.info,  Node: Card,  Next: Cardinal,  Prev: c,  Up: Reference

Card
====

Synopsis
--------

     function Card (S: ANY_SET): Integer;

Description
-----------

   The function `Card (S)' returns the number of elements in the set
`S'.

Conforming to
-------------

   `Card' is an ISO 10206 Extended Pascal extension.

Example
-------

     program CardDemo;
     var
       Foo: set of 1 .. 100;
     begin
       Foo := [1, 2, 3, 5, 1, 1, 1, 2, 2, 2, 3, 3, 5, 5];  { four elements }
       WriteLn ('foo consists of ', Card (Foo), ' elements')
     end.

See also
--------

   *Note set::


File: gpc.info,  Node: Cardinal,  Next: case,  Prev: Card,  Up: Reference

Cardinal
========

Synopsis
--------

     type
       Cardinal  { built-in type }

Description
-----------

   `Cardinal' is the "natural" unsigned integer type in GNU Pascal.  On
most platforms it is 32 bits wide and thus has a range of
`0..4294967295'. Use it whenever you need a general-purpose unsigned
integer type and don't need to care about compatibility to other Pascal
dialects.

   `Cardinal' in GNU Pascal is compatible to `unsigned int' in GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `Cardinal' is not defined in ISO Pascal, but several Pascal
compilers support it as an extension. In Borland Delphi, for instance,
it is an unsigned 16-bit in version 1.0, an unsigned 31-bit integer
from version 2.0 on, and an unsigned 32-bit integer from version 4.0 on.

Example
-------

     program CardinalDemo;
     var
       a: Cardinal;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc.info,  Node: case,  Next: CBoolean,  Prev: Cardinal,  Up: Reference

case
====

Synopsis
--------

     case EXPRESSION of
       SELECTOR: STATEMENT;
       ...
       SELECTOR: STATEMENT;
     end;
   or, with alternative statement sequence:
     case EXPRESSION of
       SELECTOR: STATEMENT;
       ...
       SELECTOR: STATEMENT;
     otherwise  { ``else'' instead of ``otherwise'' is allowed }
       STATEMENT;
       ...
       STATEMENT;
     end;
   or, as part of the invariant `record' type definition:
     foo = record
       FIELD_DECLARATIONS
     case bar: VARIANT_TYPE of
       SELECTOR: (FIELD_DECLARATIONS);
       SELECTOR: (FIELD_DECLARATIONS);
       ...
     end;
   or, without a variant selector field,
     foo = record
       FIELD_DECLARATIONS
     case VARIANT_TYPE of
       SELECTOR: (FIELD_DECLARATIONS);
       SELECTOR: (FIELD_DECLARATIONS);
       ...
     end;

Description
-----------

   `case' opens a case statement. For further description see *Note
case Statement::.

   For `case' in a variant record type definition, see *Note Record
Types::.

Conforming to
-------------

   The `case' statement is defined in ISO 7185 Pascal and supported by
all known Pascal variants.

   According to ISO 7185 Pascal, the selector type must be a named
type. UCSD Pascal and Borland Pascal allow any ordinal type here.

   The alternative statement execution with `otherwise' it is an
Extended Pascal extension; with `else' it is a Borland Pascal
extension. In GNU Pascal, both are allowed.

Example
-------

     program CaseDemo;
     var
       Foo: String (10);
       Bar: Integer;
     begin
       WriteLn ('Enter up to ten arbitrary characters:');
       ReadLn (Foo);
       for Bar := 1 to Length (Foo) do
         begin
           Write (Foo[Bar], ' is ');
           case Foo[Bar] of
             'A' .. 'Z', 'a' .. 'z':
               WriteLn ('an English letter');
             '0' .. '9':
               WriteLn ('a number');
           otherwise
             WriteLn ('an unrecognized character')
           end
         end
     end.

See also
--------

   *Note Keywords::, *Note if Statement::, *Note Record Types::, *Note
else::, *Note otherwise::


File: gpc.info,  Node: CBoolean,  Next: Char,  Prev: case,  Up: Reference

CBoolean
========

   (Under construction.)

Synopsis
--------

     type
       CBoolean  { built-in type }

Description
-----------

   `CBoolean' is a Boolean type. In GNU Pascal it is compatible to
`_Bool' in GNU C (which is defined as `bool' in `stdbool.h'). This
compatibility is the reason why `CBoolean' exists.

Conforming to
-------------

   `CBoolean' is a GNU Pascal extension.

Example
-------

     program CBooleanDemo;
     var
       a: CBoolean;
     begin
       a := True;
       if Ord (a) = 1 then WriteLn ('Ord (True) = 1')
     end.

See also
--------

   *Note Boolean (Intrinsic)::, *Note Integer Types::, *Note Boolean::,
*Note True::, *Note False::, *Note ByteBool::, *Note ShortBool::, *Note
MedBool::, *Note WordBool::, *Note LongBool::, *Note LongestBool::.


File: gpc.info,  Node: Char,  Next: ChDir,  Prev: CBoolean,  Up: Reference

Char
====

Synopsis
--------

     type
       Char  { built-in type }

Description
-----------

   The built-in type `Char' holds elements of the operating system's
character set (usually ASCII). The `Char' type is a special case of
ordinal type. Conversion between character types and ordinal types is
possible with the built-in functions `Ord' and `Chr'.

Conforming to
-------------

   `Char' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program CharDemo;
     var
       a: Char;
     begin
       a := 'x';
       WriteLn (a)
     end.

See also
--------

   *Note Character Types::, *Note Ordinal Types::, *Note Type Casts::,
*Note Ord::, *Note Chr::.


File: gpc.info,  Node: ChDir,  Next: Chr,  Prev: Char,  Up: Reference

ChDir
=====

Synopsis
--------

     procedure ChDir (Directory: String);

Description
-----------

   `ChDir' changes the current directory to DIRECTORY, if its argument
is a valid parameter to the related operating system's function.
Otherwise, a runtime error is caused.

Conforming to
-------------

   `ChDir' is a Borland Pascal extension.

Example
-------

     program ChDirDemo;
     var
       Foo: String (127);
     begin
       WriteLn ('Enter directory name to change to:');
       ReadLn (Foo);
       {$I-}  { Don't abort the program on error }
       ChDir (Foo);
       if IOResult <> 0 then
         WriteLn ('Cannot change to directory `', Foo, '''.')
       else
         WriteLn ('Okay.')
     end.

See also
--------

   *Note MkDir::, *Note RmDir::


File: gpc.info,  Node: Chr,  Next: c_language,  Prev: ChDir,  Up: Reference

Chr
===

Synopsis
--------

     function Chr (AsciiCode: Integer): Char;

Description
-----------

   `Chr' returns a character whose ASCII code corresponds to the value
given by `AsciiCode'.

Conforming to
-------------

   `Chr' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program ChrDemo;
     var
       x: Integer;
     begin
       for x := 32 to 122 do
         Write (Chr (x))
     end.

See also
--------

   *Note Character Types::, *Note Ord::, *Note Char::


File: gpc.info,  Node: c_language,  Next: class,  Prev: Chr,  Up: Reference

c_language
==========

Synopsis
--------

Description
-----------

   *Deprecated*! Use `external' now.

Conforming to
-------------

Example
-------

See also
--------

   *Note Keywords::, *Note Importing Libraries from Other Languages::,
*Note external::.


File: gpc.info,  Node: class,  Next: Close,  Prev: c_language,  Up: Reference

class
=====

   Not yet implemented.

Synopsis
--------

Description
-----------

   OOE/Delphi style object class.

Conforming to
-------------

   `class' is an Object Pascal and a Borland Delphi extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc.info,  Node: Close,  Next: Cmplx,  Prev: class,  Up: Reference

Close
=====

   (Under construction.)

Synopsis
--------

     procedure Close (var F: ANY_FILE);

Description
-----------

Conforming to
-------------

   `Close' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: Cmplx,  Next: Comp,  Prev: Close,  Up: Reference

Cmplx
=====

Synopsis
--------

     function Cmplx (RealPart, ImaginaryPart: Real): Complex;

Description
-----------

   `Cmplx' makes a complex number from `RealPart' and `ImaginaryPart'.

Conforming to
-------------

   `Cmplx' is an ISO 10206 Extended Pascal extension.

Example
-------

     program CmplxDemo;
     var
       z: Complex;
       x, y: Real;
     begin
       z := Cmplx (x, y)  { z := x + iy }
     end.

See also
--------

   *Note Re::, *Note Im::, *Note Polar::, *Note Arg::


File: gpc.info,  Node: Comp,  Next: CompilerAssert,  Prev: Cmplx,  Up: Reference

Comp
====

Synopsis
--------

     type
       Comp = LongInt;

Description
-----------

   `Comp' is a signed integer type which is longer than `Integer'. On
most platforms it is 64 bits wide and thus has a range of
`-9223372036854775808..9223372036854775807'.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `Comp' is a Borland Pascal extension.

   In some contexts, Borland Pascal treats `Comp' as a "real" type -
this behaviour is not supported by GPC.

Example
-------

     program CompDemo;
     var
       a: Comp;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc.info,  Node: CompilerAssert,  Next: Complex,  Prev: Comp,  Up: Reference

CompilerAssert
==============

Synopsis
--------

     procedure CompilerAssert (Condition: Boolean);
   or
     function CompilerAssert (Condition: Boolean): Boolean;
   or
     function CompilerAssert (Condition: Boolean;
                ResultValue: ANY_TYPE): type of ResultValue;

Description
-----------

   `CompilerAssert' checks the given `Condition' at compile-time. If it
is a compile-time constant of Boolean type with the value `True', it
returns `ResultValue', or if called with only one argument, it returns
`True' or nothing if used as a procedure.

   If `Condition' cannot be evaluated at compile-time or does not have
the value `True', it causes a compile-time error.

   So it can be used to make sure that certain assumptions hold before
relying on them.

   `CompilerAssert' does not depend on the `--[no-]assertions' options.
It does not generate any run-time code.

Conforming to
-------------

   `CompilerAssert' is a GNU Pascal extension.

Example
-------

   program CompilerAssertDemo;

   var   a: LongInt;

   const   { Make sure that the highest value a can hold is larger than
   MaxInt, and set b to that value. }   b = CompilerAssert (High (a) >
MaxInt, High (a));

   { Do a similar check for the minimum value, setting c to True
(which can be ignored). }   c = CompilerAssert (Low (a) < Low
(Integer));

   begin   { Procedure-like use of CompilerAssert in the statement
part. }   CompilerAssert (MaxInt >= 100000);

   WriteLn (b, ' ', c) end.

See also
--------

   *Note Assert::.


File: gpc.info,  Node: Complex,  Next: Concat,  Prev: CompilerAssert,  Up: Reference

Complex
=======

   (Under construction.)

Synopsis
--------

     type
       Internal_Complex = record  { not visible }
         RealPart, ImaginaryPart: Real
       end;
       Complex = restricted Internal_Complex;

Description
-----------

Conforming to
-------------

   `Complex' is an ISO 10206 Extended Pascal extension.

Example
-------

     program ComplexDemo;
     var
       a: Complex;
     begin
       a := Cmplx (42, 3);
       WriteLn (Re (a), ' + ', Im (a), ' i')
     end.

See also
--------


File: gpc.info,  Node: Concat,  Next: Conjugate,  Prev: Complex,  Up: Reference

Concat
======

   (Under construction.)

Synopsis
--------

     function Concat (S1, S2: String): String;
   or
     function Concat (S1, S2, S3: String): String;
   or
     ...

Description
-----------

Conforming to
-------------

   `Concat' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: Conjugate,  Next: const,  Prev: Concat,  Up: Reference

Conjugate
=========

Synopsis
--------

     function Conjugate (z: Complex): Complex;

Description
-----------

   `Conjugate' computes the complex conjugate of the complex number `z'

Conforming to
-------------

   `Conjugate' is a GNU Pascal extension.

Example
-------

     program ConjugateDemo;
     var
       z: Complex;
     begin
       z := Cmplx (2, 3);  { z is 2 + i * 3 }
       WriteLn ('z = ', Re (z) : 0 : 5, ' + i * ', Im (z) : 0 : 5);
       z := Conjugate (z);  { z conjugate is 2 - i * 3 }
       WriteLn ('z conjugate = ', Re (z) : 0 : 5,' + i * ', Im (z) : 0 : 5)
     end.

See also
--------

   *Note Cmplx::, *Note Re::, *Note Im::, *Note Abs::


File: gpc.info,  Node: const,  Next: constructor,  Prev: Conjugate,  Up: Reference

const
=====

   (Under construction.)

Synopsis
--------

Description
-----------

   Constant declaration or constant parameter declaration.

Conforming to
-------------

   `const' is defined in ISO 7185 Pascal and supported by all known
Pascal variants. `const' parameters are a Borland Pascal extension.
Pointers to `const' are a GNU Pascal extension.

   Constant declarations allow you to define names for constant
(unchanging) values, such as using `SecondsPerHour' instead of 3600.
This can make your program much more readable and maintainable.

   GNU Pascal allows you to define constant strings, records and arrays
as well as simple numeric constants.

   GNU Pascal also implements the const parameter extension which
allows the compiler to pass parameters by reference while still
allowing you to pass constant values as inputs.  See *Note Subroutine
Parameter List Declaration:: for more information.

   @@@@ Pointers to `const' @@@@

Example
-------

     program ConstDemo;
     
     type
       Rec = record
         x: Integer;
         y: Integer;
       end;
     
     const
       a = 5;
       constr: Rec = (10, 12);
     
     procedure doit (const r: Rec; const s: String);
     begin
       WriteLn (r.x);
       WriteLn (r.y);
       WriteLn (s);
     end;
     
     var
       variabler: Rec;
     
     begin
       variabler.x := 16;
       variabler.y := 7;
       doit (variabler, 'Should be 16 and 7');
       doit (constr, 'Should be 10 and 12');
     end.

See also
--------

   *Note Keywords::, *Note var::, *Note protected::, *Note Subroutine
Parameter List Declaration::.


File: gpc.info,  Node: constructor,  Next: Continue,  Prev: const,  Up: Reference

constructor
===========

   (Under construction.) ;-)

Synopsis
--------

Description
-----------

   Object constructor.

Conforming to
-------------

   `constructor' is an Object Pascal and a Borland Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc.info,  Node: Continue,  Next: Copy,  Prev: constructor,  Up: Reference

Continue
========

Synopsis
--------

     Continue  { simple statement }

Description
-----------

   `Continue' goes on with loop iteration by jumping to the end of the
current loop body. Note: `Continue' can only stand within a WHILE,
REPEAT or a FOR statement.

Conforming to
-------------

   `Continue' is a Borland Pascal extension.

Example
-------

     program ContinueDemo;
     var
       Foo, Bar: Integer;
     begin
       WriteLn ('Enter three numbers:');
       for Bar := 1 to 3 do
         begin
           ReadLn (Foo);
           if Foo < 5 then
             Continue;
           WriteLn ('Your number was greater than 5.')
         end
     end.

See also
--------

   *Note Loop Control Statements::, *Note Break::, *Note Exit::, *Note
Halt::, *Note Return::, *Note goto::.


File: gpc.info,  Node: Copy,  Next: Cos,  Prev: Continue,  Up: Reference

Copy
====

Synopsis
--------

     function Copy (S: String; FirstChar, Count: Integer): String;
   or
     function Copy (S: String; FirstChar: Integer): String;

Description
-----------

   `Copy' returns a sub-string of `S' starting with the character at
position FIRSTCHAR. If COUNT is given, such many characters will be
copied into the sub-string. If COUNT is omitted, the sub-string will
range to the end of S.

   If `Count' is too large for the sub-string to fit in S, the result
will be truncated at the end of S. If `FirstChar' exceeds the length of
S, the empty string will be returned. (For a function which does not
truncate but triggers a runtime error instead, see *Note SubStr::.)

   Please note that GPC's strings may be longer than 255 characters. If
you want to isolate the second half of a string S starting with the
third character, use `Copy (S, 3)' instead of `Copy (S, 3, 255)'.

Conforming to
-------------

   `Copy' is a UCSD Pascal extension. The possibility to omit the third
parameter is a GNU Pascal extension.

Example
-------

     program CopyDemo;
     var
       S: String (42);
     begin
       S := 'Hello';
       WriteLn (Copy (S, 2, 3));  { yields `ell' }
       WriteLn (Copy (S, 3));     { yields `llo' }
       WriteLn (Copy (S, 4, 7));  { yields `lo' }
       WriteLn (Copy (S, 42))     { yields the empty string }
     end.

See also
--------

   *Note SubStr::, *Note String Slice Access::.


File: gpc.info,  Node: Cos,  Next: CString,  Prev: Copy,  Up: Reference

Cos
===

Synopsis
--------

     function Cos (x: Real): Real;
   or
     function Cos (z: Complex): Complex;

Description
-----------

   `Cos' returns the cosine of the argument.  The result is in the
range `-1 < Cos (x) < 1' for real arguments.

Conforming to
-------------

   The function `Cos' is defined in ISO 7185 Pascal; its application to
complex values is defined in ISO 10206 Extended Pascal.

Example
-------

     program CosDemo;
     begin
       { yields 0.5 since Cos (Pi / 3) = 0.5 }
       WriteLn (Cos (Pi / 3) : 0 : 5)
     end.

See also
--------

   *Note ArcTan::, *Note Sin::, *Note Ln::, *Note Arg::.


File: gpc.info,  Node: CString,  Next: CString2String,  Prev: Cos,  Up: Reference

CString
=======

   (Under construction.)

Synopsis
--------

     type
       CString = ^Char;

Description
-----------

Conforming to
-------------

   `CString' is a GNU Pascal extension.

Example
-------

     program CStringDemo;
     var
       s: CString;
     begin
       s := 'Hello, world!';
       {$X+}
       WriteLn (s)
     end.

See also
--------


File: gpc.info,  Node: CString2String,  Next: CStringCopyString,  Prev: CString,  Up: Reference

CString2String
==============

   (Under construction.)

Synopsis
--------

     function CString2String (S: CString): String;

Description
-----------

Conforming to
-------------

   `CString2String' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: CStringCopyString,  Next: CurrentRoutineName,  Prev: CString2String,  Up: Reference

CStringCopyString
=================

   (Under construction.)

Synopsis
--------

     function CStringCopyString (Dest: CString; const Source: String): CString;

Description
-----------

Conforming to
-------------

   `CStringCopyString' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: CurrentRoutineName,  Next: Date,  Prev: CStringCopyString,  Up: Reference

CurrentRoutineName
==================

Synopsis
--------

     function CurrentRoutineName: String;

Description
-----------

   `CurrentRoutineName' returns the name of the current routine from
where it's called.

Conforming to
-------------

   `CurrentRoutineName' is a GNU Pascal extension.

Example
-------

     program CurrentRoutineNameDemo;
     
     procedure FooBar;
     begin
       WriteLn (CurrentRoutineName)  { `FooBar' }
     end;
     
     begin
       WriteLn (CurrentRoutineName);  { `main program' }
       FooBar
     end.

See also
--------


File: gpc.info,  Node: Date,  Next: Dec,  Prev: CurrentRoutineName,  Up: Reference

Date
====

Synopsis
--------

     function Date (T: TimeStamp): packed array [1 .. DATE_LENGTH] of Char;

Description
-----------

   Date takes a `TimeStamp' parameter and returns the date as a string
(in the form of a packed array of `Char').  DATE_LENGTH is an
implementation defined invisible constant.

Conforming to
-------------

   `Date' is an ISO 10206 Extended Pascal extension.

Example
-------

   Set *Note TimeStamp::.

See also
--------

   *Note TimeStamp::, *Note GetTimeStamp::, *Note Time::, *Note Date
And Time Routines::.


File: gpc.info,  Node: Dec,  Next: DefineSize,  Prev: Date,  Up: Reference

Dec
===

Synopsis
--------

   For ordinal types:
     procedure Dec (var x: ORDINAL_TYPE);
   or
     procedure Dec (var x: ORDINAL_TYPE; Amount: Integer);

   For pointer types:
     procedure Dec (var p: ANY_POINTER_TYPE);
   or
     procedure Dec (var p: ANY_POINTER_TYPE; Amount: Integer);

Description
-----------

   For ordinal types, `Dec' decreases the value of `x' by one or by
`amount' if specified.

   If the argument `p' is pointing to a specified type (typed pointer),
`Dec' decreases the address of `p' by the size of the type `p' is
pointing to or by `amount' times that size respectively. If `p' is an
untyped pointer (i.e. `p' is of type *Note Pointer::), `p' is decreased
by one, otherwise by `amount' if specified.

Conforming to
-------------

   `Dec' is a Borland Pascal extension. The combination of the second
argument with application to pointers is a GNU Pascal extension.

Example
-------

     program DecDemo;
     var
       x: Integer;
       y: array [1 .. 5] of Integer;
       p: ^Integer;
     begin
       x := 9;
       Dec (x, 10);  { yields -1 }
       {$X+}         { Turn on extended systax }
       p := @@y[5];   { p points to y[5] }
       Dec (p, 3)    { p points to y[2] }
     end.

See also
--------

   *Note Inc::, *Note Pred::, *Note Succ::, *Note Pointer Arithmetics::.


File: gpc.info,  Node: DefineSize,  Next: Delete,  Prev: Dec,  Up: Reference

DefineSize
==========

   (Under construction.)

Synopsis
--------

     procedure DefineSize (var F: ANY_FILE; NewSize: Integer);

Description
-----------

Conforming to
-------------

   `DefineSize' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: Delete,  Next: destructor,  Prev: DefineSize,  Up: Reference

Delete
======

   (Under construction.)

Synopsis
--------

     procedure Delete (var S: String; FirstChar, Count: Integer);
   or
     procedure Delete (var S: String; FirstChar: Integer);

Description
-----------

Conforming to
-------------

   `Delete' is a UCSD Pascal extension. The possibility to omit the
third parameter is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: destructor,  Next: Dispose,  Prev: Delete,  Up: Reference

destructor
==========

   (Under construction.)

Synopsis
--------

Description
-----------

   Object destructor.

Conforming to
-------------

   `destructor' is an Object Pascal and a Borland Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc.info,  Node: Dispose,  Next: div,  Prev: destructor,  Up: Reference

Dispose
=======

   (Under construction.)

Synopsis
--------

     Dispose (PointerVar: Pointer);
   or
     Dispose (PointerVar: Pointer; TAG_FIELD_VALUES);
   or
     Dispose (ObjectPointerVar: Pointer; DESTRUCTOR_CALL);

Description
-----------

Conforming to
-------------

   `Dispose' is defined in ISO 7185 Pascal and supported by most known
Pascal variants, but not by UCSD Pascal.  Its use for objects is a
Borland Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: div,  Next: do,  Prev: Dispose,  Up: Reference

div
===

Synopsis
--------

     operator div (p, q: Integer) = r: Integer;

Description
-----------

   Integer division operator.

Conforming to
-------------

   `div' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program DivDemo;
     
     var
       a, b: Integer;
     
     begin
       a := 16;
       b := 7;
       WriteLn (a div b);  { `2' }
     end.

See also
--------

   *Note Keywords::.


File: gpc.info,  Node: do,  Next: Double,  Prev: div,  Up: Reference

do
==

Synopsis
--------

     for ... do
       STATEMENT
   or
     while ... do
       STATEMENT
   or
     with ... do
       STATEMENT
   or
     to begin do
       STATEMENT
   or
     to end do
       STATEMENT

Description
-----------

   The `do' reserved word is used in combination with other Pascal
keywords in many ways. For description and examples see the relevant
reference sections: `for', `while', `with', `to begin', `to end'.

Conforming to
-------------

   `do' is defined in ISO 7185 Pascal and supported by all known Pascal
variants.

Example
-------

   See references.

See also
--------

   *Note Keywords::, *Note for::, *Note while::, *Note with::, *Note to
begin do::, *Note to end do::.


File: gpc.info,  Node: Double,  Next: downto,  Prev: do,  Up: Reference

Double
======

   (Under construction.)

Synopsis
--------

     type
       Double = Real;

Description
-----------

   `Double' is a synonym for the `Real' data type and supported for
compatibility with other compilers.

Conforming to
-------------

   `Double' is a Borland Pascal extension.

Example
-------

     program DoubleDemo;
     var
       A: Double;  { There is nothing special with `Double'. }
       B: Real;
     begin
       A := Pi;
       A := B
     end.

See also
--------


File: gpc.info,  Node: downto,  Next: else,  Prev: Double,  Up: Reference

downto
======

Synopsis
--------

     for VARIABLE := VALUE1 downto VALUE2 do
       STATEMENT

Description
-----------

   The `downto' reserved word is used in combination with `for' to
build a `for' loop.

Conforming to
-------------

   `downto' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

   See *Note for::.

See also
--------

   *Note Keywords::, *Note for::.


File: gpc.info,  Node: else,  Next: Empty,  Prev: downto,  Up: Reference

else
====

Synopsis
--------

   As part of the `if' ... `then' ... `else' statement:
     if BOOLEAN_EXPRESSION then
       STATEMENT1
     else
       STATEMENT2
   or, as part of the `case' ... `else' statement:
     case EXPRESSION of
       SELECTOR: STATEMENT;
       ...
       SELECTOR: STATEMENT
     else  { ``otherwise'' instead of ``else'' is allowed }
       STATEMENT;
       ...
       STATEMENT
     end

Description
-----------

   `else' is part of the `if ... then ... else' statement which
provides a possibility to execute statements alternatively. In the
`case' statement, `else' starts a series of statements which is
executed if no selector fit in EXPRESSION. In this situation, `else' is
a synonym for `otherwise'.

Conforming to
-------------

   `else' in `if' statements is defined in ISO 7185 Pascal and
supported by all known Pascal variants. `else' in `case' statements is
a Borland Pascal extension; ISO 10206 Extended Pascal has `otherwise'
instead.

Example
-------

     program ElseDemo;
     var
       i: Integer;
     begin
       Write ('Enter a number: ');
       ReadLn (i);
       if i > 42 then
         WriteLn ('The number is greater than 42')
       else
         WriteLn ('The number is not greater than 42')
     end.

See also
--------

   *Note Keywords::, *Note if::, *Note case::, *Note otherwise::.


File: gpc.info,  Node: Empty,  Next: end,  Prev: else,  Up: Reference

Empty
=====

   (Under construction.)

Synopsis
--------

     function Empty (var F: ANY_FILE): Boolean;

Description
-----------

Conforming to
-------------

   `Empty' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: end,  Next: EOF,  Prev: Empty,  Up: Reference

end
===

Synopsis
--------

     begin
       STATEMENT;
       STATEMENT;
       ...
       STATEMENT
     end

Description
-----------

   The reserved word `end' closes a `begin' ... `end'; statement which
joins several STATEMENTS together into one compound statement.

   @@@@ end of a `case' statement @@@@ end of a record or object declaration
@@@@ part of a `to end do' module destructor

Conforming to
-------------

   `end' is defined in ISO 7185 Pascal and supported by all Pascal
variants.

Example
-------

     program EndDemo;
     begin
       if True then
         WriteLn ('single statement');
       if True then
         begin  { clamp statement1 ... }
           WriteLn ('statement1');
           WriteLn ('statement2')
         end    { ... to statement2 }
     end.

See also
--------

   *Note Keywords::, *Note begin end Compound Statement::, *Note begin::


File: gpc.info,  Node: EOF,  Next: EOLn,  Prev: end,  Up: Reference

EOF
===

   (Under construction.)

Synopsis
--------

     function EOF ([var F: ANY_FILE]): Boolean;
   or
     function EOF: Boolean;

Description
-----------

Conforming to
-------------

   `EOF' is defined in ISO 7185 Pascal and supported by all Pascal
variants.

Example
-------

See also
--------


File: gpc.info,  Node: EOLn,  Next: EpsReal,  Prev: EOF,  Up: Reference

EOLn
====

   (Under construction.)

Synopsis
--------

     function EOLn ([var F: Text]): Boolean;
   or
     function EOLn: Boolean;

Description
-----------

Conforming to
-------------

   `EOLn' is defined in ISO 7185 Pascal and supported by all Pascal
variants.

Example
-------

See also
--------


File: gpc.info,  Node: EpsReal,  Next: EQ,  Prev: EOLn,  Up: Reference

EpsReal
=======

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `EpsReal' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: EQ,  Next: EQPad,  Prev: EpsReal,  Up: Reference

EQ
==

   (Under construction.)

Synopsis
--------

     function EQ (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `EQ' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: EQPad,  Next: Erase,  Prev: EQ,  Up: Reference

EQPad
=====

   (Under construction.)

Synopsis
--------

     function EQPad (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `EQPad' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: Erase,  Next: Exclude,  Prev: EQPad,  Up: Reference

Erase
=====

   (Under construction.)

Synopsis
--------

     procedure Erase (var F: ANY_FILE);

Description
-----------

Conforming to
-------------

   `Erase' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: Exclude,  Next: Exit,  Prev: Erase,  Up: Reference

Exclude
=======

Synopsis
--------

     Exclude (SET_VARIABLE, ORDINAL_VALUE);

Description
-----------

   Remove (subtract) a single element from a set.  ORDINAL_VALUE must
be compatible with the base type of SET_VARIABLE.  Exclude is
equivalent to:

     SET_VARIABLE := SET_VARIABLE - [ORDINAL_VALUE];

   If SET_VARIABLE does not contain ORDINAL_VALUE, nothing happens.

Conforming to
-------------

   `Exclude' is a Borland Pascal extension.

Example
-------

     program ExcludeDemo;
     
     var
       Ch: Char;
       MyCharSet: set of Char;
     
     begin
       MyCharSet := ['P','N','L'];
       Exclude (MyCharSet , 'N'); { L, P }
     end.

   See other examples in *Note set:: and *Note Set Operations::.

See also
--------

   *Note Keywords::, *Note Set Operations::, *Note set::, *Note in::,
*Note Include::.


File: gpc.info,  Node: Exit,  Next: Exp,  Prev: Exclude,  Up: Reference

Exit
====

Synopsis
--------

     procedure Exit;

Description
-----------

   `Exit' leaves the currently executed procedure or function.  Note:
If `Exit' is called within the main program, it will be terminated
instantly.

Conforming to
-------------

   `Exit' is a UCSD Pascal extension. GNU Pascal supports it only as
defined in Borland Pascal; not the following two UCSD Pascal uses:
jumping out of several nested routines by giving an outer routine name
as an optional argument, and `Exit (program)' which means the same as
`Halt'.

Example
-------

     program ExitDemo;
     
     procedure Foo (Bar: Integer);
     var
       Baz, Fac: Integer;
     begin
       if Bar < 1 then
         Exit;  { Exit `Foo' }
       Fac := 1;
       for Baz := 1 to Bar do
         begin
           Fac := Fac * Baz;
           if Fac >= Bar then
             Exit;  { Exit `Foo' }
           WriteLn (Bar,' is greater than ', Baz, '!, which is equal to ', Fac)
       end
     end;
     
     begin
       Foo (-1);
       Foo (789);
       Exit;            { Terminates program }
       Foo (987654321)  { This is not executed anymore }
     end.

See also
--------

   *Note Break::, *Note Continue::, *Note Halt::.


File: gpc.info,  Node: Exp,  Next: export,  Prev: Exit,  Up: Reference

Exp
===

Synopsis
--------

     function Exp (x: Real): Real;
   or
     function Exp (z: Complex): Complex;

Description
-----------

   The exponential function `Exp' computes the value of e to the power
of x, where the Euler number e = Exp (1) is the base of the natural
logarithm.

Conforming to
-------------

   The function `Exp' is defined in ISO 7185 Pascal; its application to
complex values is defined in ISO 10206 Extended Pascal.

Example
-------

     program ExpDemo;
     var
       z: Complex;
     begin
       z := Cmplx (1, - 2 * Pi);  { z = 1 - 2 pi i }
       z := Exp (z);  { yields e = Exp (1), since Exp ix = Cos x + i Sin x }
       WriteLn (Ln (Re (z)) : 0 : 5)  { prints 1 = Ln (Exp (1)) }
     end.

See also
--------

   *Note Ln::


File: gpc.info,  Node: export,  Next: exports,  Prev: Exp,  Up: Reference

export
======

   (Under construction.)

Synopsis
--------

     export `interface_name' = (IDENTIFIER, IDENTIFIER, ...);

   or

     export `interface_name' = all;

Description
-----------

   Interface export for Extended Pascal modules.

   `all' means to automatically export all identifiers declared in the
interface module.

Conforming to
-------------

   `export' is an ISO 10206 Extended Pascal extension. It also exists
in Borland Pascal, but with a different meaning, not (yet) supported by
GPC.

   `export all' is a GNU Pascal extension.

Example
-------

     program ExportDemo;
     
     import AllInterface in 'somemodule.pas';
     
     begin
       Bar (a);
       WriteLn (b)
     end.

     module SomeModule interface;
     
     export
       SomeInterface = (a);
       AllInterface = all;  { Same as `AllInterface = (a, b, Bar);' }
     
     var
       a, b: Integer;
     
     procedure Bar (i: Integer);
     
     end.
     
     module SomeModule implementation;
     
     procedure Bar (i: Integer);
     begin
       b := a
     end;
     
     to begin do
       a := 42;
     
     end.

See also
--------

   *Note Keywords::, *Note Modules::.


File: gpc.info,  Node: exports,  Next: Extend,  Prev: export,  Up: Reference

exports
=======

   Not yet implemented.

Synopsis
--------

Description
-----------

   Library export.

Conforming to
-------------

   `exports' is a Borland Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc.info,  Node: Extend,  Next: Extended,  Prev: exports,  Up: Reference

Extend
======

   (Under construction.)

Synopsis
--------

     procedure Extend (var F: ANY_FILE; [FileName: String;]
                                         [BlockSize: Cardinal]);

Description
-----------

   `Extend' opens a file for writing. If the file does not exist, it is
created. If it does exist, the file pointer is positioned after the
last element.

   Like `Rewrite', `Reset' and `Append' do, `Extend' accepts an
optional second and third parameter for the name of the file in the
filesystem and, for untyped files, the block size of the file. (For
details, see *Note Rewrite::.)

Conforming to
-------------

   `Extend' is an ISO 10206 Extended extension. Borland Pascal has
*Note Append:: instead.  The `BlockSize' parameter is a Borland Pascal
extension.  The `FileName' parameter is a GNU Pascal extension.

Example
-------

     program ExtendDemo;
     var
       Sample: Text;
     begin
       Assign (Sample, 'sample.txt');
       Rewrite (Sample);
       WriteLn (Sample, 'Hello, World!');  { `sample.txt' now has one line }
       Close (Sample);
     
       { ... }
     
       Extend (Sample);
       WriteLn (Sample, 'Hello again!');  { `sample.txt' now has two lines }
       Close (Sample)
     end.

See also
--------

   *Note Assign::, *Note Reset::, *Note Rewrite::, *Note Update::,
*Note Append::.


File: gpc.info,  Node: Extended,  Next: external,  Prev: Extend,  Up: Reference

Extended
========

   (Under construction.)

Synopsis
--------

     type
       Extended = LongReal;

Description
-----------

Conforming to
-------------

   `Extended' is a Borland Pascal extension.

Example
-------

     program ExtendedDemo;
     var
       a: Extended;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------


File: gpc.info,  Node: external,  Next: Fail,  Prev: Extended,  Up: Reference

external
========

   (Under construction.)

Synopsis
--------

     DECLARATION external;

   or

     DECLARATION external name LINKER_NAME;

Description
-----------

   Declaration of external object.

Conforming to
-------------

   `external' is a UCSD Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc.info,  Node: Fail,  Next: False,  Prev: external,  Up: Reference

Fail
====

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `Fail' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: False,  Next: far,  Prev: Fail,  Up: Reference

False
=====

Synopsis
--------

     type
       Boolean = (False, True);  { built-in type }

Description
-----------

   `False' is one of the two Boolean values and is used to represent a
condition which is never fullfilled. For example, the expression, `1 =
2' always yields `False'. It is the opposite of `True'. `False' has the
ordinal value 0.

Conforming to
-------------

   `False' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program FalseDemo;
     
     var
       a: Boolean;
     
     begin
       a := 1 = 2;  { yields False }
       WriteLn (Ord (False));  { 0 }
       WriteLn (a);  { False }
       if False then WriteLn ('This is not executed.')
     end.

See also
--------

   *Note Boolean (Intrinsic)::, *Note True::, *Note Boolean::.


File: gpc.info,  Node: far,  Next: file,  Prev: False,  Up: Reference

far
===

Synopsis
--------

Description
-----------

   The `far' directive can be appended to a procedure or function
heading but is ignored by GPC. It is there for Borland compatibility,
only. (Since the GNU compilers provide a flat memory model, the
distinction between `near' and `far' pointers is void.)

Conforming to
-------------

   `far' is a Borland Pascal extension.

Example
-------

     program FarDemo;
     
     var
       p: procedure;
     
     {$W no-near-far}  { Don't warn about the uselessness of `far' }
     
     procedure Foo; far;  { `far' has no effect in GPC }
     begin
       WriteLn ('Foo')
     end;
     
     begin
       p := Foo;  { Would also work without `far' in GPC. }
       p
     end.

See also
--------

   *Note Keywords::, *Note near::.


File: gpc.info,  Node: file,  Next: FilePos,  Prev: far,  Up: Reference

file
====

   (Under construction.)

Synopsis
--------

   In type definitions:
     File of TYPE
   or
     File

Description
-----------

   Non-text file type declaration.

Conforming to
-------------

   `file' is a Borland Pascal extension.

Example
-------

See also
--------

   *Note Keywords::, *Note Text::, *Note AnyFile::.


File: gpc.info,  Node: FilePos,  Next: FileSize,  Prev: file,  Up: Reference

FilePos
=======

   (Under construction.)

Synopsis
--------

     function FilePos (var F: ANY_FILE): Integer;

Description
-----------

Conforming to
-------------

   `FilePos' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: FileSize,  Next: FillChar,  Prev: FilePos,  Up: Reference

FileSize
========

   (Under construction.)

Synopsis
--------

     function FileSize (var F: ANY_FILE): Integer;

Description
-----------

Conforming to
-------------

   `FileSize' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: FillChar,  Next: finalization,  Prev: FileSize,  Up: Reference

FillChar
========

   (Under construction.)

Synopsis
--------

     procedure FillChar (var Dest; Count: SizeType; Val: Char);
   or
     procedure FillChar (var Dest; Count: SizeType; Val: Byte);

Description
-----------

Conforming to
-------------

   `FillChar' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc.info,  Node: finalization,  Next: Finalize,  Prev: FillChar,  Up: Reference

finalization
============

   (Under construction.)

Synopsis
--------

Description
-----------

   Unit finalization.

   It is equivalent to Extended Pascal's `to end do'.

Conforming to
-------------

   `finalization' is a Borland Delphi extension.

Example
-------

See also
--------

   *Note Keywords::, *Note initialization::, *Note to end do::.


File: gpc.info,  Node: Finalize,  Next: Flush,  Prev: finalization,  Up: Reference

Finalize
========

   (Under construction.)

Synopsis
--------

     procedure Finalize (var Aynthing);

Description
-----------

   `Finalize' does all necessary clean-ups for the parameter. This is
normally done automatically when a variable goes out of scope, so you
need to call `Finalize' only in special situations, e.g.  when you
deallocate a dynamic variable with `FreeMem' rather than `Dispose'.

Conforming to
-------------

   `Finalize' is a Borland Delphi extension.

Example
-------

See also
--------

   *Note Initialize::, *Note Dispose::, *Note FreeMem::.

@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Import an alpha version of GNU Pascal Compiler into the tree
(not to be connected to the build before the upgrade to gcc 3.3).

We couldn't use gpc 2.1 because it's too old and doesn't support
gcc 3.x at all.
@
text
@@
