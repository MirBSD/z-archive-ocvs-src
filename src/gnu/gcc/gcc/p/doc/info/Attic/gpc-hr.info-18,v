head	1.2;
access;
symbols
	gpc-20030830:1.1.2.1 FSF:1.1.2;
locks; strict;
comment	@# @;


1.2
date	2004.01.11.18.16.28;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2004.01.11.18.01.11;	author tg;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.01.11.18.01.11;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@nuke some unused, redundant or generated files
@
text
@This is ../p/doc/info/gpc-hr.info, produced by makeinfo version 4.1
from gpc.texi.

INFO-DIR-SECTION GNU programski alati
START-INFO-DIR-ENTRY
* GPC: (gpc-hr).                GNU Pascal prevodilac (compiler).
END-INFO-DIR-ENTRY
INFO-DIR-SECTION Pojedini alati
START-INFO-DIR-ENTRY
* GPC: (gpc-hr)Pozivanje GPC-a. GNU Pascal prevodilac (compiler).
END-INFO-DIR-ENTRY

   Ova datoteka dokumentira GPC prevodilac (engl. compiler).

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Copyright (C) 1988-2003 Free Software Foundation, Inc.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License", "The GNU
Project", "The GNU Manifesto" and "Funding for free Software" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License", "The GNU Project", "The GNU Manifesto" and "Funding for Free
Software" and this permission notice, may be included in translations
approved by the Free Software Foundation instead of in the original
English.


File: gpc-hr.info,  Node: RmDir,  Next: Round,  Prev: Rewrite,  Up: Reference

RmDir
=====

Synopsis
--------

     procedure RmDir (Directory: String);

Description
-----------

   `RmDir' removes the given DIRECTORY if its argument is a valid
parameter to the related operating system's function. Otherwise a
runtime error is caused.

Conforming to
-------------

   `RmDir' is a Borland Pascal extension.

Example
-------

     program RmDirDemo;
     var
       Foo: String (127);
     begin
       WriteLn ('Enter directory name to remove: ');
       ReadLn (Foo);
       {$I-}  { Don't abort on I/O errors }
       RmDir (Foo);
       if IOResult <> 0 then
         WriteLn ('Directory ', Foo, ' could not be removed.')
       else
         WriteLn ('Okay.')
     end.

See also
--------

   *Note ChDir::, *Note MkDir::


File: gpc-hr.info,  Node: Round,  Next: RunError,  Prev: RmDir,  Up: Reference

Round
=====

Synopsis
--------

     function Round (x: Real): Integer;

Description
-----------

   `Round' returns the nearest integer to `x'. The result is of type
integer. In the case of equidistance, the result is machine-dependent
(or depends on the behaviour of the processor).

Conforming to
-------------

   `Round' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program RoundDemo;
     var
       Foo: Real;
     begin
       Foo := 9.876543;
       WriteLn (Round (Foo));  { Prints 10 }
       Foo := 3.456789;
       WriteLn (Round (Foo));  { Prints 3 }
     
       WriteLn (Frac (12.345) : 1 : 5);  { 0.34500 }
       WriteLn (Int (12.345) : 1 : 5);  { 12.00000 }
       WriteLn (Round (12.345) : 1);  { 12 }
       WriteLn (Trunc (12.345) : 1);  { 12 }
     
       WriteLn (Frac (-12.345) : 1 : 5);  { -0.34500 }
       WriteLn (Int (-12.345) : 1 : 5);  { -12.00000 }
       WriteLn (Round (-12.345) : 1);  { -12 }
       WriteLn (Trunc (-12.345) : 1);  { -12 }
     
       WriteLn (Frac (12.543) : 1 : 5);  { 0.54300 }
       WriteLn (Int (12.543) : 1 : 5);  { 12.00000 }
       WriteLn (Round (12.543) : 1);  { 13 }
       WriteLn (Trunc (12.543) : 1);  { 12 }
     
       WriteLn (Frac (-12.543) : 1 : 5);  { -0.54300 }
       WriteLn (Int (-12.543) : 1 : 5);  { -12.00000 }
       WriteLn (Round (-12.543) : 1);  { -13 }
       WriteLn (Trunc (-12.543) : 1);  { -12 }
     end.

See also
--------

   *Note Real Types::, *Note Real::, *Note Int::, *Note Frac::, *Note
Trunc::.


File: gpc-hr.info,  Node: RunError,  Next: Seek,  Prev: Round,  Up: Reference

RunError
========

   (Under construction.)

Synopsis
--------

     procedure RunError (ErrorCode: Integer);

Description
-----------

Conforming to
-------------

   `RunError' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: Seek,  Next: SeekEOF,  Prev: RunError,  Up: Reference

Seek
====

   (Under construction.)

Synopsis
--------

     procedure Seek (var F: TYPED_FILE; NewPosition: Integer);

Description
-----------

Conforming to
-------------

   `Seek' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: SeekEOF,  Next: SeekEOLn,  Prev: Seek,  Up: Reference

SeekEOF
=======

   (Under construction.)

Synopsis
--------

     function SeekEOF ([var F: Text]): Boolean;

Description
-----------

Conforming to
-------------

   `SeekEOF' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: SeekEOLn,  Next: SeekRead,  Prev: SeekEOF,  Up: Reference

SeekEOLn
========

   (Under construction.)

Synopsis
--------

     function SeekEOLn ([var F: Text]): Boolean;

Description
-----------

Conforming to
-------------

   `SeekEOLn' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: SeekRead,  Next: SeekUpdate,  Prev: SeekEOLn,  Up: Reference

SeekRead
========

   (Under construction.)

Synopsis
--------

     procedure SeekRead (var F: TYPED_FILE; NewPosition: Integer);

Description
-----------

Conforming to
-------------

   `SeekRead' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: SeekUpdate,  Next: SeekWrite,  Prev: SeekRead,  Up: Reference

SeekUpdate
==========

   (Under construction.)

Synopsis
--------

     procedure SeekUpdate (var F: TYPED_FILE; NewPosition: Integer);

Description
-----------

Conforming to
-------------

   `SeekUpdate' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: SeekWrite,  Next: segment,  Prev: SeekUpdate,  Up: Reference

SeekWrite
=========

   (Under construction.)

Synopsis
--------

     procedure SeekWrite (var F: TYPED_FILE; NewPosition: Integer);

Description
-----------

Conforming to
-------------

   `SeekWrite' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: segment,  Next: Self,  Prev: SeekWrite,  Up: Reference

segment
=======

   Not yet implemented.

Synopsis
--------

Description
-----------

   Segment specification.

Conforming to
-------------

   `segment' is a UCSD Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: Self,  Next: set,  Prev: segment,  Up: Reference

Self
====

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `Self' is an Object Pascal and a Borland Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: set,  Next: SetFileTime,  Prev: Self,  Up: Reference

set
===

Synopsis
--------

   In type definitions:
     set of TYPE  { built-in type class }

Description
-----------

   A set contains zero or more elements from an ordinal type, e.g.
Char, a subrange of Char, or a subrange of an enumerated type or
integers. Sets do not have any ordering (that is a set containing 'B'
and 'A' is the same as a set containing 'A' and 'B'), nor can an
element be included more than once. Sets simply store the information
about which elements are included in the set.

Conforming to
-------------

   `set' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program SetDemo;
     
     type
       TCharSet = set of Char;
     
     var
       Ch: Char;
       MyCharSet: TCharSet;
     begin
       MyCharSet := ['P','N','L'];
       if 'A' in MyCharSet then
         WriteLn ('Wrong: A in set MyCharSet')
       else
         WriteLn ('Right: A is not in set MyCharSet');
       Include (MyCharSet, 'A');  { A, L, N, P }
       Exclude (MyCharSet, 'N');  { A, L, P }
       MyCharSet := MyCharSet + ['B','C'];  { A, B, C, L, P }
       MyCharSet := MyCharSet - ['C','D'];  { A, B, L, P }
       WriteLn ('set MyCharSet contains:');
       for Ch in MyCharSet do
         WriteLn (Ch);
     end.

   Set also *Note Set Operations:: or examples of some of the many set
operations.

See also
--------

   *Note Keywords::, *Note Set Operations::, *Note in::, *Note
Exclude::, *Note Include::.


File: gpc-hr.info,  Node: SetFileTime,  Next: SetLength,  Prev: set,  Up: Reference

SetFileTime
===========

     procedure SetFileTime (var f: ANY_FILE;
                            AccessTime, ModificationTime: UnixTimeType);

Synopsis
--------

Description
-----------

Conforming to
-------------

   `SetFileTime' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: SetLength,  Next: SetType,  Prev: SetFileTime,  Up: Reference

SetLength
=========

Synopsis
--------

     procedure SetLength (var S: String; NewLength: Integer);

Description
-----------

   `SetLength' explicitly assigns a new length `NewLength' to the
string parameter `S'. The contents of the string is _not_ changed; if
the operation increases the length of the string, the characters
appended at the end are _undefined_.

Conforming to
-------------

   `SetLength' is a Borland Delphi 2.0 extension.

Example
-------

     program SetLengthDemo;
     
     var
       S: String (26);
     
     begin
       S := 'Hello, world!';
       SetLength (S, Length ('Hello'));
       WriteLn (S);                                           { 'Hello' }
     
       SetLength (S, 26);
       WriteLn (S);                     { 'Hello, world!(%$xy"!#&~+(/]' }
                                 { undefined characters ^^^^^^^^^^^^^^  }
     
       SetLength (S, 42);       { The overflow is *not* (yet) detected. }
       WriteLn (S);        { This might cause a runtime error or crash. }
     end.

See also
--------

   *Note Length::, *Note String::.


File: gpc-hr.info,  Node: SetType,  Next: shl,  Prev: SetLength,  Up: Reference

SetType
=======

Synopsis
--------

     procedure SetType (var SomeObject; VMT: PObjectType);

Description
-----------

   The procedure `SetType' explicitly assigns a value to the implicit
VMT field of an object. This is normally done implicitly when a
constructor is called.

   You can use this to write a polymorphic I/O routine which reads an
object from a file. In this case, you cannot reasonably use `New' to
allocate the storage, but you `GetMem' it and initialize the object
manually using `SetType' before calling the constructor explicitly.

   The only values you should assign to an object via `SetType' are
actual VMT pointers that were obtained via `TypeOf'. In particular,
declaring a record like the one shown in the description of
`PObjectType' and assigning a pointer to it to an object via `SetType'
will usually not work because the virtual method pointers are missing.

   Since `SetType' is a dangerous feature, it yields a warning unless
`{$X+}' is given.

Conforming to
-------------

   `SetType' is a GNU Pascal extension.

Example
-------

     program SetTypeDemo;
     
     type
       BasePtr = ^BaseObj;
     
       BaseObj = object
         constructor Load;
       end;
     
       ChildObj = object (BaseObj)
         constructor Load;
       end;
     
     constructor BaseObj.Load;
     begin
     end;
     
     constructor ChildObj.Load;
     begin
     end;
     
     {$X+}
     
     { This is somewhat fragmentary code. }
     function GetObject (var InputFile: File) = Result: BasePtr;
     const
       VMTTable: array [1 .. 2] of PObjectType =
         (TypeOf (BaseObj), TypeOf (ChildObj));
     var
       Size: Cardinal;
       TypeID: Integer;
       VMT: PObjectType;
     begin
       { Read the size of the object from some file and store it in `Size'. }
       BlockRead (InputFile, Size, SizeOf (Size));
     
       { Allocate memory for the object. }
       GetMem (Result, Size);
     
       { Read some ID from some file. }
       BlockRead (InputFile, TypeID, SizeOf (TypeID));
     
       { Look up the `VMT' from some table. }
       { Range checking wouldn't be a bad idea here ... }
       VMT := VMTTable[TypeID];
     
       SetType (Result^, VMT);
     
       { Now the object is ready, and the constructor can be called. }
       { Look up the correct constructor from some table and call it. }
     end;
     
     begin
     end.

See also
--------

   *Note PObjectType::, *Note TypeOf::, *Note OOP::.


File: gpc-hr.info,  Node: shl,  Next: ShortBool,  Prev: SetType,  Up: Reference

shl
===

Synopsis
--------

     operator shl (operand1, operand2: INTEGER_TYPE) = Result: INTEGER_TYPE;
   or
     procedure shl (var operand1: INTEGER_TYPE; operand2: INTEGER_TYPE);

Description
-----------

   In GNU Pascal, `shl' has two built-in meanings:

  1. Bitwise shift left of an integer-type expression by another
     integer value.  The result is of the type of the first operand.

  2. Use as a "procedure": `operand1' is shifted left by `operand2';
     the result is stored in `operand1'.


Conforming to
-------------

   `shl' is a Borland Pascal extension.

   Use of `shl' as a "procedure" is a GNU Pascal extension.

Example
-------

     program ShlDemo;
     var
       a: Integer;
     begin
       a := 1 shl 7;  { yields 128 = 2 pow 7 }
       shl (a, 4)  { same as `a := a shl 4' }
     end.

See also
--------

   *Note Keywords::, *Note shr::, *Note Operators::.


File: gpc-hr.info,  Node: ShortBool,  Next: ShortCard,  Prev: shl,  Up: Reference

ShortBool
=========

Synopsis
--------

     type
       ShortBool = Boolean attribute (Size = BitSizeOf (ShortInt));

Description
-----------

   The intrinsic `ShortBool' represents boolean values, but occupies
the same memory space as a `ShortInt'.  It is used when you need to
define a parameter or record that conforms to some external library or
system specification.

Conforming to
-------------

   `ShortBool' is a GNU Pascal extension.

Example
-------

     program ShortBoolDemo;
     var
       a: ShortBool;
     begin
       ShortInt (a) := 1;
       if a then WriteLn ('Ord (True) = 1')
     end.

See also
--------

   *Note Boolean (Intrinsic)::, *Note Boolean::, *Note True::, *Note
False::, *Note CBoolean::, *Note ByteBool::, *Note MedBool::, *Note
WordBool::, *Note LongBool::, *Note LongestBool::.


File: gpc-hr.info,  Node: ShortCard,  Next: ShortInt,  Prev: ShortBool,  Up: Reference

ShortCard
=========

Synopsis
--------

     type
       ShortCard = Cardinal attribute (Size = BitSizeOf (ShortInt));

Description
-----------

   `ShortCard' is an unsigned integer type which is not larger than
`Cardinal'. On most platforms it is 16 bits wide and thus has a range
of `0..65535'.

   `ShortCard' in GNU Pascal is compatible to `short unsigned int' in
GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `ShortCard' is a GNU Pascal extension.

Example
-------

     program ShortCardDemo;
     var
       a: ShortCard;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-hr.info,  Node: ShortInt,  Next: ShortReal,  Prev: ShortCard,  Up: Reference

ShortInt
========

Synopsis
--------

     type
       ShortInt  { built-in type }

Description
-----------

   `ShortInt' is a signed integer type which is not larger than
`Integer'. On most platforms it is 16 bits wide and thus has a range of
`-32768..32767'.

   `ShortInt' in GNU Pascal is compatible to `short int' in GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `ShortInt' is a Borland Pascal extension. In Borland Pascal,
`ShortInt' is an 8-bit signed integer type (`ByteInt' in GNU Pascal).

Example
-------

     program ShortIntDemo;
     var
       a: ShortInt;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-hr.info,  Node: ShortReal,  Next: ShortWord,  Prev: ShortInt,  Up: Reference

ShortReal
=========

   (Under construction.)

Synopsis
--------

     type
       ShortReal  { built-in type }

Description
-----------

Conforming to
-------------

   `ShortReal' is a GNU Pascal extension.

Example
-------

     program ShortRealDemo;
     var
       a: ShortReal;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------


File: gpc-hr.info,  Node: ShortWord,  Next: shr,  Prev: ShortReal,  Up: Reference

ShortWord
=========

Synopsis
--------

     type
       ShortWord = ShortCard;

Description
-----------

   `ShortWord' is an unsigned integer type which is not larger than
`Word'. On most platforms it is 16 bits wide and thus has a range of
`0..65535'. It is the same as *Note ShortCard::.

   `ShortWord' in GNU Pascal is compatible to `short unsigned int' in
GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `ShortWord' is a GNU Pascal extension.

   `ShortWord' in GNU Pascal essentially corresponds to `Word' in
Borland Pascal and Delphi where it is a 16-bit unsigned integer type.

Example
-------

     program ShortWordDemo;
     var
       a: ShortWord;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-hr.info,  Node: shr,  Next: Sin,  Prev: ShortWord,  Up: Reference

shr
===

Synopsis
--------

     operator shr (operand1, operand2: INTEGER_TYPE) = Result: INTEGER_TYPE;
   or
     procedure shr (var operand1: INTEGER_TYPE; operand2: INTEGER_TYPE);

Description
-----------

   In GNU Pascal, `shr' has two built-in meanings:

  1. Bitwise shift right of an integer-type expression by another
     integer value.  The result is of the type of the first operand.

  2. Use as a "procedure": `operand1' is shifted right by `operand2';
     the result is stored in `operand1'.


Conforming to
-------------

   `shr' is a Borland Pascal extension.

   Unlike the Borland compilers, GNU Pascal cares about the signedness
of the first operand: If a signed integer with a negative value is
shifted right, "one" bits are filled in from the left.

   Use of `shr' as a "procedure" is a GNU Pascal extension.

Example
-------

     program ShrDemo;
     var
       a: Integer;
     begin
       a := 1024 shr 4;  { yields 64 }
       a := -127 shr 4;  { yields -8 }
       shr (a, 2)  { same as `a := a shr 2' }
     end.

See also
--------

   *Note Keywords::, *Note shl::, *Note Operators::.


File: gpc-hr.info,  Node: Sin,  Next: Single,  Prev: shr,  Up: Reference

Sin
===

Synopsis
--------

     function Sin (x: Real): Real;
   or
     function Sin (z: Complex): Complex;

Description
-----------

   `Sin' returns the sine of the argument.  The result is in the range
`-1 <= Sin (x) <= 1' for real arguments.

Conforming to
-------------

   The function `Sin' is defined in ISO 7185 Pascal; its application to
complex values is defined in ISO 10206 Extended Pascal.

Example
-------

     program SinDemo;
     begin
       { yields 0.5 since Sin (Pi / 6) = 0.5 }
       WriteLn (Sin (Pi / 6) : 0 : 5)
     end.

See also
--------

   *Note ArcTan::, *Note Cos::, *Note Ln::, *Note Arg::.


File: gpc-hr.info,  Node: Single,  Next: SizeOf,  Prev: Sin,  Up: Reference

Single
======

   (Under construction.)

Synopsis
--------

     type
       Single = ShortReal;

Description
-----------

Conforming to
-------------

   `Single' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: SizeOf,  Next: SizeType,  Prev: Single,  Up: Reference

SizeOf
======

Synopsis
--------

     function SizeOf (var x): SizeType;

Description
-----------

   Returns the size of a type or variable in bytes.

   `SizeOf' can be applied to expressions and type names. If the
argument is a polymorphic object, the size of its actual type is
returned.

Conforming to
-------------

   `SizeOf' is a UCSD Pascal extension.

Example
-------

     program SizeOfDemo;
     var
       a: Integer;
       b: array [1 .. 8] of Char;
     begin
       WriteLn (SizeOf (a));        { Size of an `Integer'; often 4 bytes. }
       WriteLn (SizeOf (Integer));  { The same. }
       WriteLn (SizeOf (b))         { Size of eight `Char's; usually 8 bytes. }
     end.

See also
--------

   *Note BitSizeOf::, *Note AlignOf::, *Note TypeOf::.


File: gpc-hr.info,  Node: SizeType,  Next: SmallInt,  Prev: SizeOf,  Up: Reference

SizeType
========

Synopsis
--------

     type
       SizeType  { built-in type }

Description
-----------

   `SizeType' is an integer type (usually unsigned) to represent the
size of objects in memory.

Conforming to
-------------

   `SizeType' is a GNU Pascal extension.

Example
-------

     program SizeTypeDemo;
     var
       a: array [1 .. 10] of Integer;
       Size: SizeType;
     begin
       Size := SizeOf (a);
       WriteLn (Size)
     end.

See also
--------


File: gpc-hr.info,  Node: SmallInt,  Next: Sqr,  Prev: SizeType,  Up: Reference

SmallInt
========

Synopsis
--------

     type
       SmallInt = ShortInt;

Description
-----------

   `SmallInt' is a signed integer type which is not larger than
`Integer'. On most platforms it is 16 bits wide and thus has a range of
`-32768..32767'. It is the same as `ShortInt' (see *Note ShortInt::).

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `SmallInt' is a Borland Delphi 2.0 extension.

Example
-------

     program SmallIntDemo;
     var
       a: SmallInt;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note ShortInt::, *Note Integer Types::, *Note Subrange Types::.


File: gpc-hr.info,  Node: Sqr,  Next: SqRt,  Prev: SmallInt,  Up: Reference

Sqr
===

Synopsis
--------

     function Sqr (i: INTEGER_TYPE): INTEGER_TYPE;
   or
     function Sqr (x: REAL_TYPE): REAL_TYPE;
   or
     function Sqr (z: COMPLEX_TYPE): COMPLEX_TYPE;

Description
-----------

   Returns the square of the argument:

     function Sqr (x: SOME_TYPE): SOME_TYPE;
     begin
       Sqr := x * x  { or: x pow 2 }
     end;

Conforming to
-------------

   The function `Sqr' is defined in ISO 7185 Pascal; its application to
complex values is defined in ISO 10206 Extended Pascal.

Example
-------

     program SqrDemo;
     
     var
       i: Complex;
     
     begin
       i := Cmplx (0, 1);
       WriteLn (Re (Sqr (i)) : 0 : 3)  { yields -1.000 }
     end.

See also
--------

   *Note pow::, *Note SqRt::, *Note Abs::, *Note Operators::.


File: gpc-hr.info,  Node: SqRt,  Next: StandardError,  Prev: Sqr,  Up: Reference

SqRt
====

Synopsis
--------

     function SqRt (x: REAL_TYPE): REAL_TYPE;
   or
     function SqRt (z: COMPLEX_TYPE): COMPLEX_TYPE;

Description
-----------

   Returns the positive square root of the argument.

   For real arguments, it is an error if the argument is negative.

   For complex arguments, `SqRt' returns the principal value of the
root of the argument, i.e. the root with positive real part, or, if the
real part is zero, that one with positive imaginary part.

Conforming to
-------------

   The function `SqRt' is defined in ISO 7185 Pascal; its application
to complex values is defined in ISO 10206 Extended Pascal.

Example
-------

     program SqRtDemo;
     
     var
       m1: Complex;
     
     begin
       m1 := Cmplx (-1, 0);  { -1 }
       WriteLn (Re (SqRt (m1)) : 6 : 3, Im (SqRt (m1)) : 6 : 3);
         { yields 1.000 -1.000, i.e. the imaginary unit, i }
     end.

See also
--------

   *Note pow::, *Note Sqr::, *Note Operators::.


File: gpc-hr.info,  Node: StandardError,  Next: StandardInput,  Prev: SqRt,  Up: Reference

StandardError
=============

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `StandardError' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: StandardInput,  Next: StandardOutput,  Prev: StandardError,  Up: Reference

StandardInput
=============

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `StandardInput' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: StandardOutput,  Next: StdErr,  Prev: StandardInput,  Up: Reference

StandardOutput
==============

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `StandardOutput' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: StdErr,  Next: Str,  Prev: StandardOutput,  Up: Reference

StdErr
======

Synopsis
--------

     var
       StdErr: Text;

Description
-----------

   The `StdErr' variable is connected to the standard error file
handle. To report errors, you should prefer `WriteLn (StdErr,
'everything wrong')' over `WriteLn ('everything wrong')'.

Conforming to
-------------

   `StdErr' is a GNU Pascal extension.

Example
-------

     program StdErrDemo;
     var
       Denominator: Integer;
     begin
       ReadLn (Denominator);
       if Denominator = 0 then
         WriteLn (StdErr, ParamStr (0), ': division by zero')
       else
         WriteLn ('1 / ', Denominator, ' = ', 1 / Denominator)
     end.

See also
--------

   *Note StandardError::, *Note Output::, *Note Input::.


File: gpc-hr.info,  Node: Str,  Next: String,  Prev: StdErr,  Up: Reference

Str
===

   (Under construction.)

Synopsis
--------

     procedure Str (x: INTEGER_OR_REAL; var Dest: String);
   or
     procedure Str (x: INTEGER_OR_REAL : FIELD_WIDTH; var Dest: String);
   or
     procedure Str (x: Real : FIELD_WIDTH : PRECISION; var Dest: String);
   or
     procedure Str (REPEATED_CONSTRUCTS_AS_DESCRIBED_ABOVE; var Dest: String);

Description
-----------

Conforming to
-------------

   `Str' is a UCSD Pascal extension, generalized by Borland Pascal. The
possibility to handle more than one variable with one call to `Str' is
a GNU Pascal extension.

   ISO 10206 Extended Pascal defines `WriteStr' instead of `Str'.

Example
-------

See also
--------

   *Note WriteStr::.


File: gpc-hr.info,  Node: String,  Next: String2CString,  Prev: Str,  Up: Reference

String
======

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `String' is an Extended Pascal and a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: String2CString,  Next: SubStr,  Prev: String,  Up: Reference

String2CString
==============

   (Under construction.)

Synopsis
--------

     function String2CString (const S: String): CString;

Description
-----------

Conforming to
-------------

   `String2CString' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: SubStr,  Next: Succ,  Prev: String2CString,  Up: Reference

SubStr
======

Synopsis
--------

     function SubStr (S: String; FirstChar: Integer): String;
   or
     function SubStr (S: String; FirstChar, Count: Integer): String;

Description
-----------

   `SubStr' returns a sub-string of S starting with the character at
position FIRSTCHAR. If COUNT is given, such many characters will be
copied into the sub-string. If COUNT is omitted, the sub-string will
range to the end of S.

   If `Count' is too large for the sub-string to fit in S or if
`FirstChar' exceeds the length of S, `SubStr' triggers a runtime error.
(For a function returning the empty string instead, see *Note Copy::.)

Conforming to
-------------

   `SubStr' is an ISO 10206 Extended Pascal extension.

Example
-------

     program SubStrDemo;
     var
       S: String (42);
     begin
       S := 'Hello';
       WriteLn (SubStr (S, 2, 3));   { yields `ell' }
       WriteLn (SubStr (S, 3));      { yields `llo' }
       WriteLn (SubStr (S, 4, 7));   { yields a runtime error }
       WriteLn (SubStr (S, 42));     { yields a runtime error }
     end.

See also
--------

   *Note Copy::, *Note String Slice Access::.


File: gpc-hr.info,  Node: Succ,  Next: Text,  Prev: SubStr,  Up: Reference

Succ
====

Synopsis
--------

     function Succ (i: ORDINAL_TYPE): ORDINAL_TYPE;
   or
     function Succ (i: ORDINAL_TYPE; j: Integer): ORDINAL_TYPE;

   or, with extended syntax (`--extended-syntax' or `{$X+}'),

     function Succ (p: POINTER_TYPE): POINTER_TYPE;
   or
     function Succ (p: POINTER_TYPE; j: Integer): POINTER_TYPE;

Description
-----------

   Returns the successor of the ORDINAL_TYPE value `i', or, if the
second argument `j' is given, its `j'th successor.  For integer values
`i', this is `i + 1' (or `i + j').  (No, `Succ' does _not_ work faster
than plain addition.  Both are optimized the same way, often to a
single machine instruction.)

   If extended syntax is on, the argument may also be a pointer value.
In this case, the address is incremented by the size of the variable
pointed to, or, if `j' is given, by `j' times the size of the variable
pointed to. If `p' points to an element of an array, the returned
pointer will point to the (`j'th) next element of the array.

Conforming to
-------------

   The `Succ' function is defined in ISO 7185 Pascal. The optional
second parameter is defined in ISO 10206 Extended Pascal.  Application
of `Succ' to pointers is defined in Borland Pascal.  The combination of
the second argument with application to pointers is a GNU Pascal
extension.

Example
-------

     program SuccDemo;
     
     type
       Metasyntactical = (foo, bar, baz);
     
     var
       m: Metasyntactical;
       c: Char;
       a: array [1 .. 7] of Integer;
       p: ^Integer;
     
     begin
       m := Succ (foo);     { bar }
       c := Succ ('A', 4);  { 'E' }
       a[1] := 42;
       a[2] := Succ (a[1]);     { 43 }
       a[5] := Succ (a[2], 7);  { 50 }
       {$X+}
       p := @@a[1];
       p := Succ (p);     { points to `a[2]' now }
       p := Succ (p, 3);  { points to `a[5]' now }
     end.

See also
--------

   *Note Pred::, *Note Inc::, *Note Pointer Arithmetics::.


File: gpc-hr.info,  Node: Text,  Next: then,  Prev: Succ,  Up: Reference

Text
====

   (Under construction.)

Synopsis
--------

     type
       Text  { built-in type }

Description
-----------

Conforming to
-------------

   `Text' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program TextDemo;
     var
       t: Text;
     begin
       Rewrite (t, 'hello.txt');
       WriteLn (t, 'Hello, world!')
     end.

See also
--------

   *Note file::, *Note AnyFile::.


File: gpc-hr.info,  Node: then,  Next: Time,  Prev: Text,  Up: Reference

then
====

   (Under construction.)

Synopsis
--------

Description
-----------

   Part of an `if' statement or part of the `and then' operator.

Conforming to
-------------

   `then' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program ThenDemo;
     var
       i: Integer;
     begin
       Write ('Enter a number: ');
       ReadLn (i);
       if i > 42 then
         WriteLn ('The number is greater than 42')
     end.

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: Time,  Next: TimeStamp,  Prev: then,  Up: Reference

Time
====

Synopsis
--------

     function Time (T: TimeStamp): packed array [1 .. TIME_LENGTH] of Char;

Description
-----------

   Date takes a `TimeStamp' parameter and returns the time as a string
(in the form of a packed array of `Char').  TIME_LENGTH is an
implementation defined invisible constant.

Conforming to
-------------

   `Time' is an ISO 10206 Extended Pascal extension.

Example
-------

   Set *Note TimeStamp::.

See also
--------

   *Note TimeStamp::, *Note GetTimeStamp::, *Note Date::, *Note Date
And Time Routines::.


File: gpc-hr.info,  Node: TimeStamp,  Next: to,  Prev: Time,  Up: Reference

TimeStamp
=========

Synopsis
--------

     type
       TimeStamp = packed record
         DateValid,
         TimeValid  : Boolean;
         Year       : Integer;
         Month      : 1 .. 12;
         Day        : 1 .. 31;
         DayOfWeek  : 0 .. 6;   { 0 means Sunday }
         Hour       : 0 .. 23;
         Minute     : 0 .. 59;
         Second     : 0 .. 61;  { to allow for leap seconds }
         MicroSecond: 0 .. 999999;
         TimeZone   : Integer;  { in seconds east of UTC }
         DST        : Boolean;
         TZName1,
         TZName2    : String (32);
       end;

   The fields `DateValid', `TimeValid', `Year', `Month', `Day', `Hour',
`Minute', `Second' are required by Extended Pascal, the other ones are
extensions.

Description
-----------

   The `TimeStamp' record holds all the information about a particular
time. You can get the current time with `GetTimeStamp' and you can get
the date or time in a printable form using the `Date' and `Time'
functions.

Conforming to
-------------

   `TimeStamp' is an ISO 10206 Extended Pascal extension.

Example
-------

     program TimeStampDemo;
     
     var
       t: TimeStamp;
     
     begin
       GetTimeStamp (t);
       WriteLn ('DateValid: ', t.DateValid);
       WriteLn ('TimeValid: ', t.TimeValid);
       WriteLn ('Year: ', t.Year);
       WriteLn ('Month: ', t.Month);
       WriteLn ('Day: ', t.Day);
       WriteLn ('DayOfWeek (0..6, 0=Sunday): ', t.DayOfWeek);
       WriteLn ('Hour (0..23): ', t.Hour);
       WriteLn ('Minute (0..59): ', t.Minute);
       WriteLn ('Second (0..61): ', t.Second);
       WriteLn ('MicroSecond (0..999999): ', t.MicroSecond);
       WriteLn ('TimeZone (in seconds east of UTC): ', t.TimeZone);
       WriteLn ('DST: ', t.DST);
       WriteLn ('TZName1: ', t.TZName1);
       WriteLn ('TZName2: ', t.TZName2);
       WriteLn;
       WriteLn ('Date is: ', Date (t));
       WriteLn ('Time is: ', Time (t));
     end.

See also
--------

   *Note GetTimeStamp::, *Note Date::, *Note Time::, *Note Date And
Time Routines::.


File: gpc-hr.info,  Node: to,  Next: to begin do,  Prev: TimeStamp,  Up: Reference

to
==

   (Under construction.)

Synopsis
--------

Description
-----------

   Part of a `for' loop counting upwards or a `to begin do' or `to end
do' module constructor or destructor.

Conforming to
-------------

   `to' is defined in ISO 7185 Pascal and supported by all known Pascal
variants.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: to begin do,  Next: to end do,  Prev: to,  Up: Reference

to begin do
===========

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `to begin do' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: to end do,  Next: Trim,  Prev: to begin do,  Up: Reference

to end do
=========

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `to begin end' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: Trim,  Next: True,  Prev: to end do,  Up: Reference

Trim
====

   (Under construction.)

Synopsis
--------

     function Trim (S: String): String;

Description
-----------

Conforming to
-------------

   `Trim' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: True,  Next: Trunc,  Prev: Trim,  Up: Reference

True
====

Synopsis
--------

     type
       Boolean = (False, True);  { built-in type }

Description
-----------

   `True' is one of the two Boolean values and is used to represent a
condition which is always fullfilled. For example, the expression `1 =
1' always yields the value `True'. It is the opposite of `False'.
`True' has the ordinal value 1.

Conforming to
-------------

   `True' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program TrueDemo;
     
     var
       a: Boolean;
     
     begin
       a := 1 = 1;  { yields True }
       WriteLn (Ord (True));  { 1 }
       WriteLn (a);  { True }
       if True then WriteLn ('This is executed.')
     end.

See also
--------

   *Note Boolean (Intrinsic)::, *Note False::, *Note Boolean::.


File: gpc-hr.info,  Node: Trunc,  Next: Truncate,  Prev: True,  Up: Reference

Trunc
=====

Synopsis
--------

     function Trunc (x: Real): Integer;

Description
-----------

   `Trunc' returns the integer part of a floating point number as an
integer. Use `Int' to get the integer part as a floating point number.

Conforming to
-------------

   `Trunc' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program TruncDemo;
     
     begin
       WriteLn (Frac (12.345) : 1 : 5);  { 0.34500 }
       WriteLn (Int (12.345) : 1 : 5);  { 12.00000 }
       WriteLn (Round (12.345) : 1);  { 12 }
       WriteLn (Trunc (12.345) : 1);  { 12 }
     
       WriteLn (Frac (-12.345) : 1 : 5);  { -0.34500 }
       WriteLn (Int (-12.345) : 1 : 5);  { -12.00000 }
       WriteLn (Round (-12.345) : 1);  { -12 }
       WriteLn (Trunc (-12.345) : 1);  { -12 }
     
       WriteLn (Frac (12.543) : 1 : 5);  { 0.54300 }
       WriteLn (Int (12.543) : 1 : 5);  { 12.00000 }
       WriteLn (Round (12.543) : 1);  { 13 }
       WriteLn (Trunc (12.543) : 1);  { 12 }
     
       WriteLn (Frac (-12.543) : 1 : 5);  { -0.54300 }
       WriteLn (Int (-12.543) : 1 : 5);  { -12.00000 }
       WriteLn (Round (-12.543) : 1);  { -13 }
       WriteLn (Trunc (-12.543) : 1);  { -12 }
     end.

See also
--------

   *Note Real Types::, *Note Real::, *Note Int::, *Note Frac::, *Note
Round::.


File: gpc-hr.info,  Node: Truncate,  Next: type,  Prev: Trunc,  Up: Reference

Truncate
========

   (Under construction.)

Synopsis
--------

     procedure Truncate (var F: ANY_FILE);

Description
-----------

Conforming to
-------------

   `Truncate' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: type,  Next: type of,  Prev: Truncate,  Up: Reference

type
====

Synopsis
--------

   As a type declaration:
     type
       TYPE_INDENTIFIER = TYPE_DEFINITION;
   or with initialization:
     type
       TYPE_INDENTIFIER = TYPE_DEFINITION value CONSTANT_EXPRESSION;

Description
-----------

   The reserved word `type' starts the declaration of a TYPE IDENTIFIER
which is defined by TYPE_DEFINITION. For further description see *Note
Type Declaration::, *Note Type Declaration::, *Note Type Definition::,
*Note Data Types::.

Conforming to
-------------

   `type' is defined in ISO 7185 Pascal and supported by all known
Pascal variants. Initializers are an ISO 10206 Extended Pascal
extension.

Example
-------

     program TypeDemo;
     type
       { This side is the }    { That side is the }
       { type declaration }    { type definition  }
     
       { array type }
       ArrayType                  = array [0 .. 9] of Integer;
     
       { record type }
       RecordType                 = record
                                      Bar: Integer
                                    end;
     
       { subrange type }
       SubrangeType               = -123 .. 456;
     
       { enumeration type }
       EnumeratedType             = (Mon, Tue, Wed, Thu, Fri, Sat, Sun);
     
       { set type }
       CharSetType                = set of Char;
     
       { object type }
       ObjectType                 = object
                                      constructor Init;
                                      procedure Method;
                                      destructor Done
                                    end;
     
       { pointer type to another type identifier }
       PArrayType                 = ^ArrayType;
     
       { an alias name for another type identifier }
       IntegerType                = Integer;
     
       { an integer which is initialized by 123 }
       InitializedInt             = Integer value 123;
     
       { a schema with discriminants x and y of type Integer }
       SchemaType (x, y: Integer) = array [x .. y] of Integer;
     
     { Dummy methods of the object type }
     constructor ObjectType.Init;
     begin
     end;
     
     procedure ObjectType.Method;
     begin
     end;
     
     destructor ObjectType.Done;
     begin
     end;
     
     begin
     end.

See also
--------

   *Note Keywords::, *Note Type Declaration::, *Note Type Definition::,
*Note Data Types::, *Note Variable Declaration::, *Note array::, *Note
record::, *Note object::, *Note set::, *Note Pointer::, *Note value::.


File: gpc-hr.info,  Node: type of,  Next: TypeOf,  Prev: type,  Up: Reference

type of
=======

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: TypeOf,  Next: Unbind,  Prev: type of,  Up: Reference

TypeOf
======

Synopsis
--------

     function TypeOf (var x): PObjectType;

Description
-----------

   Returns a pointer to the VMT of an _object_ type or variable.  This
pointer can be used to identify the type of an object.

   `TypeOf' can be applied to expressions of object type and to object
type names. In the former case, the actual type of polymorphic objects
is returned.

Conforming to
-------------

   `TypeOf' is a Borland Pascal extension.

Example
-------

     program TypeOfDemo;
     type
       FooPtr = ^Foo;
       BarPtr = ^Bar;
     
       Foo = object         { Has a VMT, though it doesn't }
         x: Integer;        { contain virtual methods.     }
         constructor Init;
       end;
     
       Bar = object (Foo)
         y: Integer;
       end;
     
     constructor Foo.Init;
     begin
     end;
     
     var
       MyFoo: FooPtr;
     
     begin
       MyFoo := New (BarPtr, Init);
       if TypeOf (MyFoo^) = TypeOf (Bar) then  { True }
         WriteLn ('OK')
     end.

See also
--------

   *Note BitSizeOf::, *Note AlignOf::, *Note PObjectType::, *Note
SetType::, *Note SizeOf::, *Note OOP::.


File: gpc-hr.info,  Node: Unbind,  Next: unit,  Prev: TypeOf,  Up: Reference

Unbind
======

   (Under construction.)

Synopsis
--------

     procedure Unbind (var F: ANY_FILE);

Description
-----------

Conforming to
-------------

   `Unbind' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: unit,  Next: Unpack,  Prev: Unbind,  Up: Reference

unit
====

   (Under construction.)

Synopsis
--------

Description
-----------

   UCSD and BP style unit declaration.

Conforming to
-------------

   `unit' is a UCSD Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: Unpack,  Next: until,  Prev: unit,  Up: Reference

Unpack
======

   (Under construction.)

Synopsis
--------

     procedure Unpack (Source: PACKED_ARRAY;
                       var Dest: UNPACKED_ARRAY;
                       FirstElement: INDEX_TYPE);

Description
-----------

Conforming to
-------------

   `Unpack' is defined in ISO 7185 Pascal and supported by all known
Pascal variants except UCSD/Borland Pascal and its variants.

Example
-------

See also
--------


File: gpc-hr.info,  Node: until,  Next: UpCase,  Prev: Unpack,  Up: Reference

until
=====

   (Under construction.)

Synopsis
--------

Description
-----------

   `until' is part of the `repeat ... until' loop statement.

Conforming to
-------------

   `until' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------

   *Note Keywords::, *Note repeat::, *Note while::, *Note for::.


File: gpc-hr.info,  Node: UpCase,  Next: Update,  Prev: until,  Up: Reference

UpCase
======

   (Under construction.)

Synopsis
--------

     function UpCase (Ch: Char): Char;

Description
-----------

Conforming to
-------------

   `UpCase' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: Update,  Next: uses,  Prev: UpCase,  Up: Reference

Update
======

   (Under construction.)

Synopsis
--------

     procedure Update (var F: ANY_FILE);

Description
-----------

Conforming to
-------------

   `Update' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: uses,  Next: Val,  Prev: Update,  Up: Reference

uses
====

Synopsis
--------

   In a program:

     program @@@@fragment foo;
     
     uses
       bar1,
       bar2 in 'baz.pas',
       bar3;
     
     [...]

   In a unit:

     unit @@@@fragment Bar3;
     
     interface
     
     uses
       bar1,
       bar2 in 'baz.pas';
     
     [...]
     
     implementation
     
     uses
       bar3,
       bar4 in 'qux.pas';
     
     [...]

Description
-----------

   The reserved word `uses' in the _import part_ of a program or unit
makes the program or unit import an interface.

   The keyword `in' tells GPC to look for the `unit' in the specified
file; otherwise the file name is derived from the name of the
interface, coverted to lower-case, by adding first `.p', then `.pas'.

   There must be at most one import part in a program.

   In a unit, there can be one import part in the interface part and
one in the implementation part.

   The imported interface needn't be a UCSD/Borland Pascal unit, it may
be an interface exported by an Extended Pascal module as well.

Conforming to
-------------

   ISO Pascal does not define `uses' and units at all. UCSD and Borland
Pascal do, but without the `in' extension. Delphi supports `uses' like
described above.

Example
-------

See also
--------

   *Note Keywords::, *Note unit::, *Note module::, *Note import::.


File: gpc-hr.info,  Node: Val,  Next: value,  Prev: uses,  Up: Reference

Val
===

   (Under construction.)

Synopsis
--------

     procedure Val (const Source: String; var x: INTEGER_OR_REAL;
                    var ErrorPosition: Integer);

Description
-----------

   `Val' converts the integer or real number that is represented by the
characters in the string `Source' and places it into `x'.

   The `Source' string can have a base prefix (`$' for hexadecimal or
`Base#'). The optional `ErrorCode' will be set to the position of the
first invalid character, or to a 0 if the entire string represents a
valid number. In case an invalid character occurrs in `Source', `x'
will be undefined.

Conforming to
-------------

   `Val' is a Borland Pascal extension.

Example
-------

     program ValDemo;
     var
       x, ec: Integer;
       l: LongInt;
       r: Real;
     begin
       Val ('123', x, ec);                { x :=            123; ec := 0; }
       Val ('-123', x, ec);               { x :=           -123; ec := 0; }
       Val ('123.456', r, ec);            { r :=        123.456; ec := 0; }
       Val ('$ffff', x, ec);              { x :=          65535; ec := 0; }
       Val ('$F000', x, ec);              { x :=          61440; ec := 0; }
       Val ('-$ffff', x, ec);             { x :=         -65535; ec := 0; }
       Val ('12#100', x, ec);             { x :=            144; ec := 0; }
       Val ('-2#11111111', x, ec);        { x :=           -255; ec := 0; }
       { here we have the invalid character 'X' for base 16 }
       Val ('$fffeX', x, ec);             { x :=    <undefined>; ec := 6; }
       Val ('12#100invalid', x, ec);      { x :=    <undefined>; ec := 7; }
       Val ('36#Jerusalem', l, ec);       { l := 54758821170910; ec := 0; }
     end.

See also
--------

   *Note ReadLn::, *Note ReadStr::, *Note WriteLn::, *Note WriteStr::,
*Note Str::.


File: gpc-hr.info,  Node: value,  Next: var,  Prev: Val,  Up: Reference

value
=====

Synopsis
--------

Description
-----------

   The reserved word `value' is part of a type or var declaration.  It
can be replaced by `:=' or `='.

Conforming to
-------------

   `value' is an ISO 10206 Extended Pascal extension. `:=' in this
context is a VAX Pascal extension, and `=' is a Borland Delphi
extension.

Example
-------

See also
--------

   *Note Keywords::, *Note var::, *Note type::, *Note Variable
Declaration::, *Note Type Declaration::.


File: gpc-hr.info,  Node: var,  Next: view,  Prev: value,  Up: Reference

var
===

Synopsis
--------

   As part of a variable declaration part or in a statement block:
     var VARIABLE_IDENTIFIER: TYPE_IDENTIFIER;
   or
     var VARIABLE_IDENTIFIER: TYPE_DEFINITION;
   and with initializing value:
     var VARIABLE_IDENTIFIER: TYPE_IDENTIFIER value CONSTANT_EXPRESSION;
   or
     var VARIABLE_IDENTIFIER: TYPE_DEFINITION value CONSTANT_EXPRESSION;

As part of a parameter list (passing by reference):
     var VAR_PARAMETER: TYPE_IDENTIFIER;
   or without type declaration
     var VAR_PARAMETER;

or protected (i.e., the called routine can't modify the parameter):
     protected var VAR_PARAMETER: TYPE_IDENTIFIER;
   or without type declaration
     protected var VAR_PARAMETER;

Description
-----------

   In a declaration part: The reserved word `var' declares a
VARIABLE_IDENTIFIER whose type is of TYPE_IDENTIFIER or which is
defined by TYPE_DEFINITION. For further description see *Note Variable
Declaration::, *Note Type Declaration::, *Note Type Definition::, *Note
Data Types::.

   In a parameter list: see *Note Subroutine Parameter List
Declaration::.

Conforming to
-------------

   `var' is defined in ISO 7185 Pascal and supported by all known
Pascal variants. Untyped `var' parameters in parameter lists are a UCSD
Pascal extension. The ability to do `var' declarations in a statement
block is a GNU Pascal extension.

Example
-------

     program VarDemo;
     
     type
       FooType = Integer;
     
     var
       Bar: FooType;
       ArrayFoo: array [0 .. 9] of Integer;   { array var definition }
       FecordFoo: record                      { record var definition }
                    Bar: Integer
                  end;
       CharsetFoo: set of Char;               { set var }
       SubrangeFoo: -123 .. 456;              { subrange var }
       EnumeratedFoo: (Mon, Tue, Wed, Thu, Fri, Sat, Sun);  {enumerated var }
       PointerBar: ^FooType;                  { pointer var }
     
     procedure ReadFoo (var Foo: FooType);
     begin
       ReadLn (Foo)
     end;
     
     begin
       var Bar: Integer;  { GNU Pascal extension }
       Bar := 42
     end.

See also
--------

   *Note Keywords::, *Note type::, *Note array::, *Note record::, *Note
set::, *Note Subrange Types::, *Note Pointer::, *Note protected::.


File: gpc-hr.info,  Node: view,  Next: virtual,  Prev: var,  Up: Reference

view
====

   Not yet implemented.

Synopsis
--------

Description
-----------

   Object class view.

Conforming to
-------------

   `view' is an Object Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.

@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Import an alpha version of GNU Pascal Compiler into the tree
(not to be connected to the build before the upgrade to gcc 3.3).

We couldn't use gpc 2.1 because it's too old and doesn't support
gcc 3.x at all.
@
text
@@
