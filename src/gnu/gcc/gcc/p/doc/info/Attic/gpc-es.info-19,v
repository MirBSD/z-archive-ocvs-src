head	1.2;
access;
symbols
	gpc-20030830:1.1.2.1 FSF:1.1.2;
locks; strict;
comment	@# @;


1.2
date	2004.01.11.18.15.56;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2004.01.11.18.01.20;	author tg;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.01.11.18.01.20;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@nuke some unused, redundant or generated files
@
text
@This is ../p/doc/info/gpc-es.info, produced by makeinfo version 4.1
from gpc.texi.

INFO-DIR-SECTION GNU programming tools
START-INFO-DIR-ENTRY
* GPC: (gpc).                   The GNU Pascal Compiler.
END-INFO-DIR-ENTRY
INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* GPC: (gpc)Invoking GPC.       The GNU Pascal Compiler.
END-INFO-DIR-ENTRY

   This file documents the GNU Pascal Compiler.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Copyright (C) 1988-2003 Free Software Foundation, Inc.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License", "The GNU
Project", "The GNU Manifesto" and "Funding for free Software" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License", "The GNU Project", "The GNU Manifesto" and "Funding for Free
Software" and this permission notice, may be included in translations
approved by the Free Software Foundation instead of in the original
English.


File: gpc-es.info,  Node: virtual,  Next: Void,  Prev: view,  Up: Reference

virtual
=======

   (Under construction.)

Synopsis
--------

Description
-----------

   Virtual object method declaration.

Conforming to
-------------

   `virtual' is an Object Pascal and a Borland Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: Void,  Next: while,  Prev: virtual,  Up: Reference

Void
====

   (Under construction.)

Synopsis
--------

     type
       Void  { built-in type }

Description
-----------

Conforming to
-------------

   `Void' is a GNU Pascal extension.

Example
-------

     program VoidDemo;
     
     procedure p (var x: Void);
     begin
     end;
     
     var
       i: Integer;
       s: String (42);
     
     begin
       p (i);
       p (s)
     end.

See also
--------


File: gpc-es.info,  Node: while,  Next: with,  Prev: Void,  Up: Reference

while
=====

Synopsis
--------

     while BOOLEAN_EXPRESSION do
       STATEMENT

Description
-----------

   The `while' statement declares a loop. For further description see
*Note while Statement::.

Conforming to
-------------

   `while' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program WhileDemo;
     var
       Foo, Bar: Integer;
     begin
       WriteLn ('Enter an descending series of integer numbers.');
       WriteLn ('Terminate by breaking this rule.');
       WriteLn ('Enter start number: ');
       Bar := MaxInt;
       ReadLn (Foo);
       while Foo < Bar do
         begin
           Bar := Foo;
           ReadLn (Foo)
         end;
       WriteLn ('The last number of your series was: ', Bar)
     end.

See also
--------

   *Note Keywords::, *Note repeat Statement::, *Note for Statement::.


File: gpc-es.info,  Node: with,  Next: Word,  Prev: while,  Up: Reference

with
====

   (Under construction.)

Synopsis
--------

Description
-----------

   Automatic `record' or object field access.

Conforming to
-------------

   `with' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

   ...

   { Note bar is overwritten by foo.bar }  ...

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: Word,  Next: WordBool,  Prev: with,  Up: Reference

Word
====

Synopsis
--------

     type
       Word = Cardinal;

Description
-----------

   `Word' is the "natural" unsigned integer type in GNU Pascal.  On
most platforms it is 32 bits wide and thus has a range of
`0..4294967295'. It is the same as *Note Cardinal::, introduced for
compatibility with other Pascal compilers.

   `Word' in GNU Pascal is compatible to `unsigned int' in GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   ISO Pascal does not define `Cardinal'.  (However see *Note Subrange
Types::.)

   The `Word' type appears in Borland Pascal and Delphi, too, where it
is a 16-bit unsigned integer type.

Example
-------

     program WordDemo;
     var
       a: Word;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-es.info,  Node: WordBool,  Next: Write,  Prev: Word,  Up: Reference

WordBool
========

Synopsis
--------

     type
       WordBool = Boolean attribute (Size = BitSizeOf (Word));

Description
-----------

   The intrinsic `WordBool' represents boolean values, but occupies the
same memory space as a `Word'.  It is used when you need to define a
parameter or record that conforms to some external library or system
specification.

Conforming to
-------------

   `WordBool' is a Borland Pascal extension.

Example
-------

     program WordBoolDemo;
     var
       a: WordBool;
     begin
       Word (a) := 1;
       if a then WriteLn ('Ord (True) = 1')
     end.

See also
--------

   *Note Boolean (Intrinsic)::, *Note Boolean::, *Note True::, *Note
False::, *Note CBoolean::, *Note ByteBool::, *Note ShortBool::, *Note
MedBool::, *Note LongBool::, *Note LongestBool::.


File: gpc-es.info,  Node: Write,  Next: WriteLn,  Prev: WordBool,  Up: Reference

Write
=====

   (Under construction.)

Synopsis
--------

     procedure Write (var F: TYPED_FILE; VARIABLE);
   or
     procedure Write (var F: Text; VALUES_AND_FORMAT_SPECIFICATIONS);
   or
     procedure Write (VALUES_AND_FORMAT_SPECIFICATIONS);

Description
-----------

Conforming to
-------------

   `Write' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------


File: gpc-es.info,  Node: WriteLn,  Next: WriteStr,  Prev: Write,  Up: Reference

WriteLn
=======

   (Under construction.)

Synopsis
--------

     procedure WriteLn (var F: Text; VALUES_AND_FORMAT_SPECIFICATIONS);
   or
     procedure WriteLn (VALUES_AND_FORMAT_SPECIFICATIONS);

Description
-----------

Conforming to
-------------

   `WriteLn' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------


File: gpc-es.info,  Node: WriteStr,  Next: xor,  Prev: WriteLn,  Up: Reference

WriteStr
========

   (Under construction.)

Synopsis
--------

     procedure WriteStr (var Dest: String; VALUES_AND_FORMAT_SPECIFICATIONS);

Description
-----------

Conforming to
-------------

   `WriteStr' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: xor,  Prev: WriteStr,  Up: Reference

xor
===

Synopsis
--------

     operator xor (operand1, operand2: Boolean) = Result: Boolean;
   or
     operator xor (operand1, operand2: INTEGER_TYPE) = Result: INTEGER_TYPE;
   or
     procedure xor (var operand1: INTEGER_TYPE; operand2: INTEGER_TYPE);

Description
-----------

   In GNU Pascal, `xor' has three built-in meanings:

  1. Logical "exclusive or" between two `Boolean'-type expressions. The
     result of the operation is of `Boolean' type.  (Logical `foo xor
     bar' in fact has the same effect as `foo <> bar'.)

  2. Bitwise "exclusive or" between two integer-type expressions.  The
     result is of the common integer type of both expressions.

  3. Use as a "procedure": `operand1' is "xor"ed bitwise with
     `operand2'; the result is stored in `operand1'.


Conforming to
-------------

   ISO Pascal does not define the `xor' operator; Borland Pascal and
Delphi do.

   Use of `xor' as a "procedure" is a GNU Pascal extension.

Example
-------

     program XorDemo;
     var
       a, b, c: Integer;
     begin
       if (a = 0) xor (b = 0) then
         c := 1  { happens if either `a' or `b' is zero,    }
                 { but not if both are zero or both nonzero }
       else if (a xor b) = 0 then  { bitwise xor }
         c := 2  { happens if a = b }
       else
         xor (c, a)  { same as `c := c xor a' }
     end.

See also
--------

   *Note Keywords::, *Note and::, *Note or::, *Note Operators::.


File: gpc-es.info,  Node: Keywords,  Next: Support,  Prev: Reference,  Up: Top

Pascal keywords and operators supported by GNU Pascal.
******************************************************

   This chapter lists all keywords understood by GNU Pascal. The
keywords are taken from the following standards:

   * ISO 7185 Pascal (CP)

   * ISO 10206 Extended Pascal (EP)

   * ANSI draft Object Pascal (OP)

   * UCSD Pascal (UCSD)

   * Borland Pascal 7.0 (BP)

   * Borland Delphi (BD)

   * Pascal-SC (PXSC, Pascal eXtensions for Scientific Calculations)

   * VAX Pascal (VP)

   * Sun Pascal (SP)

   * Traditional Macintosh Pascal (MP)

   * GNU Pascal extensions (GPC)

   The table below lists all known keywords with short descriptions.
The links point to the longer descriptions in the reference.

   By default (using GPC extensions) all keywords are enabled. Only
those are marked `GPC' in the table below that are valid _only_ in the
GPC extensions.

   All keywords that are specific to some dialects (i.e., not marked
"any") can also be used as identifiers (with a few exceptions, see
below). Then, however, they generally cannot be used as keywords
anymore. So you can compile code from dialects that use them as
keywords and code that uses them as identifiers, i.e., you do not have
to modify your correct ISO 7185 programs in order to compile them with
GPC without any dialect option. Some words can even be used as keywords
and identifiers in parallel, including `forward' (according to ISO 7185
Pascal), and `near' and `far' (according to Borland Pascal).

   The exceptions are:

   * `Operator' can't be used as a type, untyped constant or exported
     interface, i.e. when it would be followed by `=' (unless it's
     disabled as a keyword explicitly or by dialect options, see
     below). This is because of a conflict with a definition of the
     operator `='. (It can be used as a typed constant, but it might be
     confusing if you later decide to make it untyped, so use with
     care.)

   * The first statement after `initialization' (Delphi specific unit
     initialization) must not start with `('.  (Statements starting
     with `(' are uncommon, anyway, but not impossible.) This does not
     restrict the usage of `Initialization' as an identifier.

   * The following keywords can't be used _immediately_ after an
     `import' part: `uses', `implementation', `operator',
     `constructor', `destructor'. Using `uses' instead of `import', or
     putting some other declaration between `import' and the
     problematic keyword helps.

   A dialect option turns off all keywords that do not belong to this
dialect. Besides, any keyword can be enabled and disabled with the
compiler options `{$enable-keyword}' and `{$disable-keyword}'.

absolute (BP, BD) (*note absolute::)
     overloaded variable declaration

abstract (OP) (*note abstract::)
     abstract object type or method declaration

all (all) (*note all::)
     `export' (*note export::) extension (`export foo = all')

and (any) (*note and::)
     Boolean or bitwise `and' operator or part of the `and then' (*note
     and then::) operator

and_then (EP, OP) (*note and_then::)
     short-circuit Boolean `and' (*note and::) operator

array (any) (*note array::)
     array type declaration

as (OP, BD) (*note as::)
     object type membership test and conversion

asm (BP, BD) (*note asm::)
     GNU style inline assembler code

asmname (GPC) (*note asmname::)
     DEPRECATED! linker name of routines and variables

attribute (GPC) (*note attribute::)
     attributes of routines and variables

begin (any) (*note begin::)
     begin of a code block, part of a `to begin do' (*note to begin
     do::) module constructor

bindable (EP, OP) (*note bindable::)
     external bindability of files

c (GPC) (*note c::)
     DEPRECATED! declaration of external routine

case (any) (*note case::)
     multi-branch conditional statement or variant `record' (*note
     record::) type

c_language (GPC) (*note c_language::)
     DEPRECATED! declaration of external routine

class (OP, BD) (*note class::)
     OOE/Delphi style object class (not yet implemented)

const (any) (*note const::)
     constant declaration or constant parameter declaration

constructor (OP, BP, BD) (*note constructor::)
     object constructor

destructor (OP, BP, BD) (*note destructor::)
     object destructor

div (any) (*note div::)
     integer division operator

do (any) (*note do::)
     part of a `while' (*note while::) or `for' (*note for::) loop, a
     `with' (*note with::) statement, or a `to begin do' (*note to
     begin do::) or `to end do' (*note to end do::) module constructor
     or destructor

downto (any) (*note downto::)
     part of a `for' (*note for::) loop counting downwards

else (any) (*note else::)
     alternative part of an `if' (*note if::) statement, default `case'
     (*note case::) branch or part of the `or else' (*note or else::)
     operator

end (any) (*note end::)
     end of a code block, end of a `case' (*note case::) statement, end
     of a `record' (*note record::) or object declaration, part of a
     `to end do' (*note to end do::) module destructor

export (export) (*note export::)
     module interface export

exports (BP, BD) (*note exports::)
     library export (not yet implemented)

external (UCSD, BP, BD, MP) (*note external::)
     declaration of external object

far (BP, BD) (*note far::)
     BP directive (ignored)

file (any) (*note file::)
     non-text file type declaration

finalization (BD) (*note finalization::)
     unit finalization

for (any) (*note for::)
     loop statement where the number of loops is known in advance

forward (any) (*note forward::)
     declaration of a routine whose definition follows below

function (any) (*note function::)
     function declaration

goto (any) (*note goto::)
     statement to jump to a `label' (*note label::)

if (any) (*note if::)
     conditional statement

implementation (all except CP) (*note implementation::)
     module or unit implementation part

import (EP, OP) (*note import::)
     module interface import

in (any) (*note in::)
     set membership test or part of a `for' (*note for::) loop
     iterating through sets

inherited (OP, BP, BD, MP) (*note inherited::)
     reference to methods of ancestor object types

initialization (BD) (*note initialization::)
     unit initialization

interface (interface) (*note interface::)
     module or unit interface part

interrupt (BP, BD) (*note interrupt::)
     interrupt handler declaration (not yet implemented)

is (OP, BD) (*note is::)
     object type membership test

label (any) (*note label::)
     label declaration for a `goto' (*note goto::) statement

library (BP, BD) (*note library::)
     library declaration (not yet implemented)

mod (any) (*note mod::)
     integer remainder operator

module (module) (*note module::)
     EP style or PXSC style module

name (name) (*note name::)
     linker name

near (BP, BD) (*note near::)
     BP directive (ignored)

nil (any) (*note nil::)
     reserved value for unassigned pointers

not (any) (*note not::)
     Boolean or bitwise negation operator

object (BP, BD, MP) (*note object::)
     BP style object declaration

of (any) (*note of::)
     part of an `array' (*note array::), `set' (*note set::) or typed
     `file' (*note file::) type declaration, a `case' (*note case::)
     statement, a variant `record' (*note record::) type or a `type of'
     (*note type of::) type inquiry

only (EP, OP) (*note only::)
     import specification

operator (PXSC) (*note operator::)
     operator declaration

or (any) (*note or::)
     Boolean or bitwise `or' operator or part of the `or else' (*note
     or else::) operator

or_else (EP, OP) (*note or_else::)
     short-circuit Boolean `or' (*note or::) operator

otherwise (EP, OP, MP) (*note otherwise::)
     default `case' (*note case::) branch

packed (any) (*note packed::)
     declaration of packed `record' (*note record::) or `array' (*note
     array::) types, also packed ordinal subranges

pow (EP, OP) (*note pow::)
     exponentiation operator with integer exponent

private (private) (*note private::)
     private object fields

procedure (any) (*note procedure::)
     procedure declaration

program (any) (*note program::)
     start of a Pascal program

property (OP, BD) (*note property::)
     object properties (not yet implemented)

protected (protected) (*note protected::)
     read-only formal parameters or module export and protected object
     fields

public (public) (*note public::)
     public object fields

published (published) (*note published::)
     published object fields

qualified (qualified) (*note qualified::)
     import specification

record (any) (*note record::)
     structured type declaration

repeat (any) (*note repeat::)
     loop statement

resident (BP, BD) (*note resident::)
     library export specification (not yet implemented)

restricted (EP, OP) (*note restricted::)
     restricted type specification

segment (UCSD) (*note segment::)
     segment specification (not yet implemented)

set (any) (*note set::)
     set type declaration

shl (BP, BD, MP) (*note shl::)
     bitwise left shift operator

shr (BP, BD, MP) (*note shr::)
     bitwise right shift operator

then (any) (*note then::)
     part of an `if' (*note if::) statement or part of the `and then'
     (*note and then::) operator

to (any) (*note to::)
     part of a `for' (*note for::) loop counting upwards or a `to begin
     do' (*note to begin do::) or `to end do' (*note to end do::)
     module constructor or destructor

type (any) (*note type::)
     type declaration or part of a `type of' (*note type of::) type
     inquiry

unit (UCSD, BP, BD, MP) (*note unit::)
     UCSD and BP style unit declaration

until (any) (*note until::)
     end of a `repeat' (*note repeat::) statement

uses (UCSD, BP, BD, MP) (*note uses::)
     unit import

value (EP, OP) (*note value::)
     variable/type initializer

var (any) (*note var::)
     variable declaration or reference parameter declaration

view (OP) (*note view::)
     object class view (not yet implemented)

virtual (OP, BP, BD, MP) (*note virtual::)
     virtual object method declaration

while (any) (*note while::)
     loop statement

with (any) (*note with::)
     automatic `record' (*note record::) or object field access

xor (BP, BD, MP) (*note xor::)
     Boolean or bitwise `exclusive or' operator


File: gpc-es.info,  Node: Support,  Next: To Do,  Prev: Keywords,  Up: Top

Where to get support for GNU Pascal; how to report bugs.
********************************************************

   Here you can find information on where to find the most up-to-date
information about GPC, how you can get support (professional or
voluntary), how to use GPC's Test Suite, and how to report new bugs you
might encounter.

   If you have problems with GNU Pascal, please read the relevant
sections of the GPC Manual. The most current version of the manual is
available at `http://www.gnu-pascal.de/gpc/index.html' for online
browsing.  You can also download the complete manual in HTML format
(tar.bz2) (`gpc-html.tar.bz2' on GPC's WWW home page).  The manual is
also available in DVI format (compressed with bzip2) (`gpc.dvi.bz2' on
GPC's WWW home page) and PostScript format (compressed with bzip2)
(`gpc.ps.bz2' on GPC's WWW home page) for printing.

   If the manual doesn't help you, here is what we recommend you to do:

*Note FAQ::                Check the GPC FAQ

* Menu:

* Mailing List::           Join the GPC Mailing List
* Mailing List Archives::  Look in the Mailing List Archives
* Newsgroups::             Ask in a newsgroup
* Professional Support::   Get individual support for GPC
* Compiler Crashes::       If the compiler crashes ...
* Reporting Bugs::         Find out how to report GPC bugs
* Testing::                If you have GPC sources, learn how to run
                           the Test Suite to test your bugs reported


File: gpc-es.info,  Node: Mailing List,  Next: Mailing List Archives,  Up: Support

The GPC Mailing List
====================

   There is a mailing list devoted to GNU Pascal. You can write to the
mailing list, e.g. if you have problems installing GPC or if you found
a problem with GPC (please see *Note Reporting Bugs::). You can also
use it to discuss suggestions for improving GPC and, most welcome, to
offer your help or contribute code, documentation or other work. Mails
to the list should be in English.

   To subscribe to the mailing list, send the command
     subscribe gpc your@@email.address
   in the body of a mail to <majordomo@@gnu.de> (*not* to
`gpc@@gnu.de'!). The subject is ignored. (Please replace
`your@@email.address' with your real email address.) For more info, send
a line `help' to <majordomo@@gnu.de>.

   After subscribing, you can send a message to the mailing list by
sending email to the list address <gpc@@gnu.de> as if it were a person.

   To leave the mailing list, send the command
     unsubscribe gpc your@@email.address
   to <majordomo@@gnu.de>.

   You can reach a human moderator at _gpc-owner@@gnu.de_.

   There is a separate mailing list for discussions about GPC
documentation, <gpc-doc@@gnu.de>. To subscribe, send the command
     subscribe gpc-doc your@@email.address
   to <majordomo@@gnu.de>.

   There is also a (low-traffic) announce list, <gpc-announce@@gnu.de>
that you can subscribe to stay up-to-date. To subscribe to the list,
write an email with
     subscribe gpc-announce your@@email.address
   in the body to <majordomo@@gnu.de>. If you like to announce a
contribution, a service or an event related to GPC, you are invited to
post to this list rather than `gpc@@gnu.de', but please don't use the
announce list for questions or discussions. Please note that all mail
sent to the announce list is forwarded to the regular list, so you
won't have to subscribe to both lists if you don't want to miss
anything. For the same reason, please don't cross-post to both lists.

   There is also a German speaking mailing list, <gpc-de@@gnu.de>. To
subscribe send the command
     subscribe gpc-de your@@email.address
   in the body of a mail to <majordomo@@gnu.de> (note the hints above).


File: gpc-es.info,  Node: Mailing List Archives,  Next: Newsgroups,  Prev: Mailing List,  Up: Support

The GPC Mailing List Archives
=============================

   Perhaps your problem was already discussed on the list. There is a
searchable archive of the mailing list on the WWW. It can be browsed or
searched at
     `http://www.gnu-pascal.de/crystal/gpc/en/'

   The archive of the documentation list is at
     `http://www.gnu-pascal.de/crystal/gpc-doc/en/'

   The archive of the announce list is at
     `http://www.gnu-pascal.de/crystal/gpc-announce/en/'

   The archive of the German GPC list is at
     `http://www.gnu-pascal.de/crystal/gpc-de/de/'


File: gpc-es.info,  Node: Newsgroups,  Next: Professional Support,  Prev: Mailing List Archives,  Up: Support

Newsgroups relevant to GPC
==========================

   To get support, you can also ask the Usenet newsgroups for help.
There are several Pascal related newsgroups, but none is dedicated just
to GNU Pascal, so use the one which is most appropriate for your
problem. For general Pascal questions, we recommend the following one:

`news://comp.lang.pascal.misc'       Pascal in general and ungrouped
                                     Pascals.

   Pascal syntax related questions may be appropriate in:

`news://comp.lang.pascal.ansi-iso'   Pascal according to ANSI and ISO
                                     standards.

   The next newsgroup is a haven for beginners, answering questions
that would apply to almost any Pascal. However, if you have a
GPC-specific question don't post there - use the GPC mailing list.  And
when in doubt use the GPC mailing list.

`news://comp.lang.pascal.borland'    Borland Pascal questions.

   Don't forget to give back what you have obtained. None of us is
getting money for answering your questions (unless you pay us by
yourself). Please do your part by answering the questions of others
instead.


File: gpc-es.info,  Node: Professional Support,  Next: Compiler Crashes,  Prev: Newsgroups,  Up: Support

Where to get individual support for GPC
=======================================

   GPC is free software and comes *without any warranty*.

   If you want to get professional support, you can hire an individual
or a company for providing such a service.

   G-N-U GmbH (http://www.g-n-u.de) is doing large parts of the
development of GNU Pascal. This company offers special support for GPC
and can be contacted at <info@@g-n-u.de>.

   More generally, to find a company or an individual who offers
support and other consulting services for free software, look into the
GNU Service Directory (http://www.gnu.org/prep/service.html).


File: gpc-es.info,  Node: Compiler Crashes,  Next: Reporting Bugs,  Prev: Professional Support,  Up: Support

If the compiler crashes ...
===========================

   If the compiler crashes, you have discovered a bug. A reliable
compiler never crashes. To help the maintainers fix this bug, it is
important that you send us a problem report.

   If you're on Unix, you can find out where the compiler crashed if
you enable coredumps, then load the compiler (`gpc1') plus the core
file in the debugger (`gdb /your_path_here/gpc1 core'), then type
`backtrace' to get a stacktrace. Include this stacktrace in your bug
report.


File: gpc-es.info,  Node: Reporting Bugs,  Next: Testing,  Prev: Compiler Crashes,  Up: Support

How to report GPC bugs
======================

   If you encounter a bug with GPC, please check whether it is one of
the known bugs (*note Known Bugs::). If not, please report it to the
GNU Pascal mailing list (*note Mailing List::). That way, they always
reach the maintainers. Please note the following points.

   * Please send a description of the problem. Try to give as much
     information as possible, with the full text of any error messages
     encountered, or a description of how some output varies from the
     expected output. Always specify the operating system type with
     version and the machine type (try `uname -a' if unsure) as well as
     the version of GPC which you get by typing `gpc -v'.

   * A good article on submitting bug reports can be found at either
     `http://www.chiark.greenend.org.uk/~sgtatham/bugs.html' or
     `http://freshmeat.net/news/2000/02/26/951627540.html'

     Another good article "How To Ask Questions The Smart Way" is
     available as `http://www.catb.org/~esr/faqs/smart-questions.html'


   If the problem is with the compiler itself, not an installation
problem or something like this, please provide a test program to
reproduce the problem, and note the following hints. You can also
contribute test programs for features that are working in GPC to ensure
they will not break in future releases.

   * The test program should be as short as possible, but *by all
     means*, please send a *complete* program and *make sure* that it
     still reproduces the problem before you send it. Too often, users
     have sent code which contained obvious syntax errors far before
     the actual problem, or just code fragments that we could only make
     wild guesses about. This is unproductive for us and doesn't help
     you get your problem solved.


   The preferred form for test programs is the form that the automated
GPC Test Suite understands. Please, if at all possible, send your test
programs in this form which should be easy to do, so we won't have to
waste our time to bring them into this form, and can concentrate on
fixing the problem.

   * The file containing the main program _must_ have a name ending
     with `.pas' and contain the keyword `program' (case-insensitively)
     and a `;' in the same line to be recognized by the Test Suite at
     all. Other files whose name ends in `.pas' (e.g., units or modules
     needed by the program), must not contain this.

   * Since the Test Suite must run under very ... nah ... strange
     operating systems, too, file names must be distinguished in their
     first eight characters (case-insensitively) and should not contain
     anything but letters, numbers, hyphens, underscores and a single
     dot. Furthermore, any ancillary files (units, modules, includes,
     data files) should not be longer than "8+3" characters; the same
     applies to the names of unit/module interfaces (because GPC will
     create `.gpi' file names based on those). It is often a good idea
     to use your name, nickname or initials followed by a number as the
     file name.

   * If your test program needs any units or modules, don't give them
     (or their interfaces in case of modules) common names like `Test',
     `Foo' or `MyUnit', unless you have very special reasons to,
     because there might be subtle problems if several test programs
     use the same name. Instead, it is recommended to prefix the
     unit/module/interface names with the name of the main test program
     or an abbreviation of it (if necessary because of the file name
     restrictions). Furthermore, please avoid the use of units and
     modules at all if the bug is not specific to them, in order to keep
     the test as simple as possible.

   * The test program, when run, should produce a line of output
     consisting of the string `OK' (followed by a newline) if
     everything went as expected, and something else (e.g. `failed',
     possibly followed by the reason of failure) if something went
     wrong.  In the latter case you might want to output additional
     information such as the values of important variables or an
     indication in which place the program failed if there are several
     possible places.

   * However, if the program is intended to check whether GPC catches an
     (intentional) compile-time error in the program, place the string
     `WRONG' somewhere in the test program, preferably in a comment in
     the line that contains the intentional error. `WRONG' tests will
     be run with the option `-w' to suppress all warnings, so only real
     errors will be detected.

     *Note:* While it is possible to combine several `OK' tests in a
     single test program (if you make sure that it outputs `OK' only if
     all tests pass), you cannot put several `WRONG' tests into one
     test program. This is because the compiler will fail (and the test
     therefore be regarded as successful) already if _one_ error
     occurs. So, for `WRONG' tests, do only one check per test program.
     Also, try to keep such a test program as small and simple as
     possible, to avoid the risk that it will fail because of other
     problems (and therefore the test be mistakenly considered
     successful).

   * If the test should merely provoke a GPC warning, use `WARN'
     instead of `WRONG'. This will run the test without `-w', but with
     `-Werror'. However, such tests will also appear to succeed if they
     produce a compiler error, not only a warning.  Therefore, when
     checking for a warning, it is often a good idea to provide a
     complementary test (with expected success) and with `-w' in `FLAG'
     or a compiler directive `{$W-}' to make sure that it's really just
     a warning, not an error.

   * Runtime errors must be detected by the test itself. One way to do
     so is to insert code like the following into your test program:

          uses GPC;
          
          procedure ExpectError;
          begin
            if ExitCode = 0 then
              WriteLn ('failed')
            else
              begin
                WriteLn ('OK');
                Halt (0)
              end
          end;
          
          begin
            AtExit (ExpectError);
            { Your code which should provoke a runtime error }
          end.

   * For a test that reproduces an existing problem (which is not
     expected to be fixed soon), please put a comment at the top that
     describes the problem in a few words, and start it with `BUG'.
     This is not required by the test scripts, it's just to make it
     easier for those who will try to fix the problem to see immediately
     what the test is about. Tests for new (planned) features should not
     say `BUG'.


   The following special features of the Test Suite may be helpful for
constructing slightly unusual tests:

   * If the expected output is something else than `OK', place it in a
     file `<basename>.out' (where `<basename>' is the name of the test
     program without the `.pas' extension).

   * If the test program expects some input, place it in a file
     `<basename>.in'. It will automatically be redirected to the
     program's standard input.

   * If the test needs some special flags to be given to the GPC command
     line, place them in a comment preceded by `FLAG', e.g.:

          { FLAG --extended-pascal -Werror }

   * If the test program creates a file, use `.dat' as a file name
     suffix and no directory (the Makefiles will remove such files in
     the `mostlyclean' etc. targets) and do not assume that this file
     exists, does not exist, or anything else about it when the test
     starts. If possible, use an internal (unnamed) file, so these
     issues will not apply.

   * The source file name of the test program will be passed as the
     first command-line argument to the test program run.

   * If a test needs to be run in a special way, you can accompany the
     program with a script `<basename>.run' that will do the actual
     test after the test program was compiled. This script will be run
     by `sh' (regardless of its first line). In order to be portable,
     it should only use standard tools and features present in all `sh'
     compatible shells (e.g., `ash', `bash', but not necessarily
     `csh'). The source file name of the test program will be passed as
     the first command-line argument to the run script in this case.
     The compiled file is called `./a.out' on most systems, but, e.g.,
     `./a.exe' on Cygwin. The environment variable `A_OUT' contains the
     base name (i.e., `a.out' or `a.exe', so you can always invoke the
     program as `./"$A_OUT"').

   * If a test needs to be compiled in a special way (e.g., to decide
     whether to skip the test), place the commands in a script
     (preferably called `<basename>.cmp'), and put the file name of the
     script (without directory) in a comment preceded by `COMPILE-CMD:'
     into the source of the test program. The compile script will be
     run *instead* of the compiler and any other action otherwise done
     for this test program, so it gives you maximum flexibility to do
     whatever you need to do. This script will be run by `sh'
     (regardless of its first line). In order to be portable, it should
     only use standard tools and features present in all `sh'
     compatible shells (see above). The first command-line argument to
     the compile script will be the compiler to use, including all
     options. The second argument will be the source file name of the
     test program. For some typical tests, there are standard compile
     scripts, e.g. `asm.cmp' which will skip the test unless run on a
     platform supported by the few tests that contain `asm' statements.
     Of course, it's generally better not to have to use such scripts
     when possible.

   * In some cases you may want to write _randomized_ tests. This is
     not usually recommended since it makes problems found harder to
     reproduce, but sometimes it might be useful (e.g., if you want to
     cover a large parameter space). In such a case, the following
     strategy can be used:

          ...
          
          uses GPC;
          
          var
            RandomSeed: Integer;
          
          begin
            RandomSeed := Random (MaxInt);
            SeedRandom (RandomSeed);
          
            ... { do your normal tests }
          
            { when printing an error message: }
            if ... then
              begin
                WriteLn ('failed (', RandomSeed, ') ',
                         ... { possibly additional information } );
                Halt
              end
          end.

     This is a little unnatural since a random number is used to
     (re-)seed the random number generator, but there's currently no way
     to retrieve the internal state of the random number generator (and
     in fact, it's not represented by a single number, but by a large
     array).

     Given the value of `RandomSeed' in an error message, it should
     then be possible to reproduce the problem by inserting this value
     in place of the `Random (MaxInt)'. Just be sure to print this
     value in *every* message of failure the program may produce.



File: gpc-es.info,  Node: Testing,  Prev: Reporting Bugs,  Up: Support

Running the GPC Test Suite
==========================

   _Note:_ If you have installed a GPC binary distribution, you usually
don't have the Test Suite installed (you can download the GPC source
distribution to get it, however), so this section does not apply to
you. Still, you can find in the section `Contributing Tests to the Test
Suite' how to report GPC bugs in the form of new test programs so we
can fix them as fast as possible.

   The files in the test directory and subdirectories are for testing
GPC only and should not be of any other use.

   Note: A few of the tests do not make sense on all systems. They are
equipped with checks and will be skipped if they find the system not
suitable. Skipped tests do *not* indicate a GPC bug, unless you have a
reason to be sure that the particular test should make sense on your
system.

   * To run the whole Test Suite, type `make' in the test directory (or
     `make check' in the `p' object directory after building GPC).

   * The output will show all errors encountered (hopefully none) and
     tests skipped, and finally display a summary giving the number of
     successful, failed and skipped tests. Any failed test indicates a
     bug in GPC which should be reported to the GPC mailing list,
     <gpc@@gnu.de>. Don't forget to mention the operating system you ran
     the test on and any other relevant information about what you did.

   * You can also type `make pascal.check-long' to get a long output
     which is a sequence of file names followed by `OK' for successful
     tests, `SKIPPED' for skipped tests (both in capital letters), and
     anything else for failed tests.

   * To run only some of the tests, you can type something like `make
     MASK="foo[1-7]*.pas"' or `make MASK="foo42.pas" pascal.check-long'.

   * To clean up after running the tests, type `make clean'.



File: gpc-es.info,  Node: To Do,  Next: Internals,  Prev: Support,  Up: Top

The GNU Pascal To-Do List.
**************************

   This is the To-Do list for the GNU Pascal Compiler.

   The GNU Pascal development team is constantly working on making GNU
Pascal more reliable and more comfortable. However, there are some
known bugs which will take some time to be fixed (any help welcome!),
and we do not want to hide them from you. You might also be interested
to know what features are planned to be implemented in the future. This
list is meant to keep track of the known bugs and wanted features of
GPC.

   If you want to report a new bug or suggest a new feature, the best
way to do it is in the mailing list. This way, other GPC users can
provide additional ideas, perhaps work-arounds for bugs, and the GPC
maintainers can sooner start to think about how to solve the problem.
The GPC mailing list is <gpc@@gnu.de>. To subscribe, send the command
`subscribe gpc your@@email.address' in the body of a mail to
<majordomo@@gnu.de> (the subject is ignored). An archive of the mailing
list can be found at `http://www.gnu-pascal.de/crystal/gpc/en/'.

   The list changes regularly. The present version refers to the
current GPC snapshot, 20030830.

   This list is part of the GNU Pascal Manual, included in GPC
distributions and snapshots. You can always browse the most current
version of the list on GPC's WWW page. If you check the To-Do list
regularly you can decide if and when to try a new snapshort.

* Menu:

* Known Bugs::        Known bugs in GPC
* Planned Features::  Features planned for GPC
* Fixed Bugs::        Fixed bugs


File: gpc-es.info,  Node: Known Bugs,  Next: Planned Features,  Up: To Do

Known bugs in GPC
=================

   In this section, you can find information about GPC bugs that are
known to the developers.

   If you encounter a bug with GPC, please check whether it is one of
the known bugs. If not, report it to the GNU Pascal mailing list.  (But
always report if you solve the problem! :-)

   Solved problems are moved to "Fixed Bugs" (*note Fixed Bugs::), and
implemented features to the "News" chapter (*note News::).

   A message ID (like `<42@@foo.bar>') refers to a message in the GPC
mailing list or a newsgroup where the topic was discussed (often a bug
report). A note of the form `(xy20001231)' refers to an internal
message of the GPC developers. A file name like `(foo42.pas)' refers to
the according program in the GPC test suite included in the GPC source
distribution.

   * `setlimit' is applied when it shouldn't be ((a) variable/constant
     declarations, (b) `set of ShortCard', (c) constant sets)

   * problem with string operations and `goto' (contourbug.pas,
     martin1.pas, berend3.pas)

   * initializers of packed arrays (emil5.pas) and variant records
     don't work

   * global variables of dynamic size don't work (john1.pas)

   * declaring a procedure in the implementation with the same name as
     an imported procedure doesn't work (chief18.pas), detect name
     collisions between imported EP modules (mod9.pas)

   * dynamic sets don't work

   * there are some bugs with mathematical functions; GPC fails, for
     example, the Paranoia test

   * check `goto' targets more strictly
     <261020020000077022%gpaeper@@empirenet.com>,
     <Pine.LNX.4.44.0210281004000.31943-100000@@duch.mimuw.edu.pl>
     (fjf701*.pas)

   * AIX: `ReturnAddress' doesn't work after use of dynmamic variables
     (gcc-2 bug, maybe fixed in gcc-3) (build with
     `CFLAGS=-DRETADDR_BUG' to aviod crashing)


File: gpc-es.info,  Node: Planned Features,  Next: Fixed Bugs,  Prev: Known Bugs,  Up: To Do

Features planned for GPC
========================

   In the following sections, you can find informations about features
which have been suggested and/or discussed for inclusion into GPC,
usually in the GPC mailing list. The division into the sections and the
names of the sections may change when this seems useful. The entries
within each section are in no particular order.

   Some of the entries may be a bit difficult to read. Double question
marks (`??') within the entries mean that it's not yet clear how to do
the thing. Triple question marks (`???') mean that it's not clear
whether to do it at all. ;-)

* Menu:

* Planned - Strings::            String types
* Planned - Records/arrays::     Record and array types
* Planned - Files::              Files
* Planned - Other types::        Other types
* Planned - OOP::                Object oriented programming extensions
* Planned - Misc::               Miscellaneous GPC topics
* Planned - Utilities::          Useful utilities for GPC


File: gpc-es.info,  Node: Planned - Strings,  Next: Planned - Records/arrays,  Up: Planned Features

Planned features: Strings
-------------------------

   * const/var `AnyString' parameters and pointers (records internally,
     cf. gpc.pas) (GetCapacity; only for var parameters)

   * `SetLength' for non-Pascal string types; use truncate-flag

   * make work on all string types: string functions from
     rts/string*.pas, Concat/+ (function with conformant array;
     Optimize `s := s + ch') (fh19971105)

   * new option `--arrays-of-char-as-cstrings={none,zero-based,all}' to
     allow assigning [zero-based] arrays of char to cstring variables
     (warning otherwise) (cstrini2.pas); make padding of those arrays
     in initialized variables and in assignments dependent on this
     switch (fh19970921) (fjf57.pas, ok) and if the length matches
     exactly, give a warning (fh19971013) (cstrassign.pas); pass those
     arrays as cstrings in read*, write*, str (P_*STRING; current
     length=-1 in two places); compile time warning (and treatment as
     non-zero-based) if it's not clear at compile time if a conformant
     array or schema is zero-based or not, and an operation depends on
     this in the zero-based state

   * Short strings (Length, Capacity) and switches
     (tc19980326.2,tc19980327); allow `type x=string' (undiscriminated)
     when switch is set so that strings don't default to length 255
     (fh19971113) (fjf97.pas, ok); don't add a #0 terminator when
     passing as a CString parameter (automatically use String2CString)

   * automatically convert CStrings to Strings?

   * general switch `--bp-strings'

   * wide characters

   * open array/string parameters (`$P', `$V' in BP; undocumented
     `OpenString' identifier in BP)

   * variables of type undiscriminated schema/strings -> remove
     pointers to string constants; functions returning undiscriminated
     schemata (pg19980813.3)


File: gpc-es.info,  Node: Planned - Records/arrays,  Next: Planned - Files,  Prev: Planned - Strings,  Up: Planned Features

Planned features: Records/arrays
--------------------------------

   * variant records: EP: check that all values of tag-type have
     exactly one matching variant

   * ISO structured constants (constdef.pas); variant records
     <C1256791.0021F002.00@@synln01.synstar.de>;
     <200106170346.f5H3ksj22229@@mail.bcpl.net>; (note structured values
     and `const' parameters)

   * initialized types in records/arrays (inirec[24].pas)

   * when applying `New' to a variant record type with a selector
     given, only allocate the space necessary for the selected variant
     (varrec2.pas) ???

   * Oregon and Vax Pascal structured constants
     <80256540.005E7D08.00@@buffer1.quantel.com> ???

   * automatically detected upper array bounds in structured
     constants/intialized variables (-> PXSC)

   * transpose arrays (Fortran)? <918557$mke$1@@nnrp1.deja.com>


File: gpc-es.info,  Node: Planned - Files,  Next: Planned - Other types,  Prev: Planned - Records/arrays,  Up: Planned Features

Planned features: Files
-----------------------

   * keep files in FDRList while they live, not only while they're
     open, so `DoneFDR' can be applied to all of them

   * packed files (EP) ??

   * improve TFDDs

   * read/write operators ???


File: gpc-es.info,  Node: Planned - Other types,  Next: Planned - OOP,  Prev: Planned - Files,  Up: Planned Features

Planned features: Other types
-----------------------------

   * UCSD Pascal's `Integer[n]' ??? BCD?

   * enum/record type extensions (syntax??)

   * check for dereferencing nil pointers

   * general subtypes ???

   * type-cast operators ???

   * make `SizeOf' work on specially declared untyped var and const
     parameters (`AnyType'?)

   * sparse sets; sets of arbitrary types ?? ???

   * initalization and finalization code for arbitrary types (e.g. GMP
     types)

   * `SELECTED_REAL_KIND' for real types (cf. Fortran, drf) ?? ???

   * resize schemata (cf. `SetLength' in Delphi)

   * `ShortComplex', `LongComplex'
     <Pine.GSO.4.44.0207151258290.5058-100000@@bonsai.fernuni-hagen.de>


File: gpc-es.info,  Node: Planned - OOP,  Next: Planned - Misc,  Prev: Planned - Other types,  Up: Planned Features

Planned features: OOP
---------------------

   * `ProcVar := Obj.Method' {$X+}; method pointers
     (`procedure/function of object') (-> Delphi) ???

   * destructor: reset VMT link to 0 ???

   * checks: `@@Obj <> nil', `TypeOf (Obj) <> nil', `TypeOf (Obj)^.Size
     = -TypeOf (Obj)^.NegatedSize'; separate switches; function
     initialized (that does these 3 tests) ???

   * `CLASS is CLASS' (implemented in Pascal with `Parent')

   * BP compatible dynamic method dispatcher ?? ???

   * `class' (reference to an object type); allow classes and object
     types to inherit from each other; OOE;
     <01BD7A3A.6B187A20.prucha@@helicon.co.at>; obpascal.zip

   * `New': Delphi syntax; Dispose?? (automatically?; set references
     automatically to nil) (-> FPC)

   * `--base-class=foo', `--base-object=bar' ???

   * properties <01BD7A3A.6B187A20.prucha@@helicon.co.at>,
     <16131.199805071354@@potter.cc.keele.ac.uk>

   * VMTs (also for local classes (EP modules???)!) in GPI files,
     written to assembler file by main program; `--cfiles=foo': .s file
     with VMTs for C/assembler??? (also .h???)

   * method overloading ??? ??

   * interfaces (cf. OOE, Java); `OBJ is INTERFACE' (not so easy?) ???;
     variables of type pointer to more than one interface [and class]
     (also possible!); VMT problem with interfaces (my solution??? also
     with dynamic linking???)

   * virtual constructors; in interfaces (load)???

   * VMT: ClassID (64/128 bits?) default 0, error when duplicated,
     warning when 0 and inherited from class with <>0 ?, not allowed
     for abstract classes!; ClassName (also for abstract classes?); [];
     ProgrammerID, BaseClassID at beginning of unit (redeclarable?) ???

   * VMT: Children: list of pVMT

   * find class by ClassID/ClassName (implementable in Pascal with
     `Child')

   * object constants, class variables (-> other name for `VMT');
     virtual/static

   * store in GPI: whether ClassID used, ClassName used, which classes
     are instantiated

@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Import an alpha version of GNU Pascal Compiler into the tree
(not to be connected to the build before the upgrade to gcc 3.3).

We couldn't use gpc 2.1 because it's too old and doesn't support
gcc 3.x at all.
@
text
@@
