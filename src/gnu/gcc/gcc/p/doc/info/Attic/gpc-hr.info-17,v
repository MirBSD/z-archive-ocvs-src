head	1.2;
access;
symbols
	gpc-20030830:1.1.2.1 FSF:1.1.2;
locks; strict;
comment	@# @;


1.2
date	2004.01.11.18.16.26;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2004.01.11.18.01.11;	author tg;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.01.11.18.01.11;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@nuke some unused, redundant or generated files
@
text
@This is ../p/doc/info/gpc-hr.info, produced by makeinfo version 4.1
from gpc.texi.

INFO-DIR-SECTION GNU programski alati
START-INFO-DIR-ENTRY
* GPC: (gpc-hr).                GNU Pascal prevodilac (compiler).
END-INFO-DIR-ENTRY
INFO-DIR-SECTION Pojedini alati
START-INFO-DIR-ENTRY
* GPC: (gpc-hr)Pozivanje GPC-a. GNU Pascal prevodilac (compiler).
END-INFO-DIR-ENTRY

   Ova datoteka dokumentira GPC prevodilac (engl. compiler).

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Copyright (C) 1988-2003 Free Software Foundation, Inc.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License", "The GNU
Project", "The GNU Manifesto" and "Funding for free Software" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License", "The GNU Project", "The GNU Manifesto" and "Funding for Free
Software" and this permission notice, may be included in translations
approved by the Free Software Foundation instead of in the original
English.


File: gpc-hr.info,  Node: name,  Next: NE,  Prev: MoveRight,  Up: Reference

name
====

   (Under construction.)

Synopsis
--------

   PROCEDURE/FUNCTION_HEADER; external name NAME;

   PROCEDURE/FUNCTION_HEADER; attribute (name = NAME);

   or

   VARIABLE_DECLARATION; external name NAME;

   VARIABLE_DECLARATION; attribute (name = NAME);

   or

   unit NAME; attribute (name = NAME);

Description
-----------

   The `name' directive declares the external name of a procedure,
function or variable. It can be used after `external' or within
`attribute'.

   This directive declares the external name of a procedure, function
or variable. The external name of the routine is given explicitly as a
case-sensitive constant string expression. This is useful when
interfacing with libraries written in other languages.

   With this extension it is possible to access all external functions,
for example the X11 interface functions, and not only those written in
lowercase.

   `name' can also be applied to units and module interfaces. In this
case it denotes the _prefix_ prepended to the external name of the
initializer of the unit: While it is normally called `init_Modulename',
it is called `init_NAME_Modulename' when `name' is given.

   This is not of interest under normal circumstances since the
initializers are called automatically. It can help avoiding conflicts
when there are several units of the same name within one program.
Again, this does not happen normally, but e.g., when a program uses a
unit/module that has the same name as one of the units the RTS consists
of: The RTS uses `GPC' as the name for its units to avoid conflicts.

   In the future, a `name' directive applied to units, modules and
programs (the latter is recognized syntactically already, but has no
effect yet) will also affect the default external name of routines and
variables which have no `name' directive themselves. Again, this is
mostly useful for libraries etc., and will not be necessary for normal
units, modules and programs.

Conforming to
-------------

   `name' is a Borland Pascal extension. `attribute' and the
application of `name' to units, modules and programs are GNU Pascal
extensions.

Example
-------

     program NameDemo;
     
     { Make two variables aliases of each other by using `name'.
       This is not good style. If you must have aliases for any reason,
       `absolute' declarations may be the lesser evil ... }
     var
       Foo: Integer; attribute (name = 'Foo_Bar');
       Bar: Integer; external name 'Foo_Bar';
     
     { A function from the C library }
     function PutS (Str: CString): Integer; external name 'puts';
     
     var
       Result: Integer;
     begin
       Result := PutS ('Hello World!');
       WriteLn ('puts wrote ', Result, ' characters (including a newline).');
       Foo := 42;
       WriteLn ('Foo = ', Foo);
       Bar := 17;
       WriteLn ('Setting Bar to 17.');
       WriteLn ('Now, Foo = ', Foo, '!!!')
     end.

See also
--------

   *Note Keywords::, *Note attribute::, *Note external::, *Note
Importing Libraries from Other Languages::.


File: gpc-hr.info,  Node: NE,  Next: near,  Prev: name,  Up: Reference

NE
==

   (Under construction.)

Synopsis
--------

     function NE (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `NE' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: near,  Next: NEPad,  Prev: NE,  Up: Reference

near
====

Synopsis
--------

Description
-----------

   The `near' directive can be appended to a procedure or function
heading but is ignored by GPC. It is there for Borland compatibility,
only. (Since the GNU compilers provide a flat memory model, the
distinction between `near' and `far' pointers is void.)

Conforming to
-------------

   `near' is a Borland Pascal extension.

Example
-------

     program NearDemo;
     
     var
       p: procedure;
     
     {$W no-near-far}  { Don't warn about the uselessness of `near' }
     
     procedure Foo; near;  { `near' has no effect in GPC }
     begin
       WriteLn ('Foo')
     end;
     
     begin
       p := Foo;  { Works, despite the `near'. }
       p
     end.

See also
--------

   *Note Keywords::, *Note far::.


File: gpc-hr.info,  Node: NEPad,  Next: New,  Prev: near,  Up: Reference

NEPad
=====

   (Under construction.)

Synopsis
--------

     function NEPad (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `NEPad' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: New,  Next: NewCString,  Prev: NEPad,  Up: Reference

New
===

   (Under construction.)

Synopsis
--------

     procedure New (var P: ANY_POINTER);
   or
     procedure New (var P: POINTER_TO_A_VARIANT_RECORD; TAG_FIELDS);
   or
     procedure New (var P: POINTER_TO_A_SCHEMA; DISCRIMINANTS);
   or
     procedure New (var P: POINTER_TO_AN_OBJECT; CONSTRUCTOR_CALL);
   or
     function New (ANY_POINTER_TYPE): SAME_TYPE;
   or
     function New (VARIANT_RECORD_POINTER_TYPE;
                   TAG_FIELDS): SAME_TYPE;
   or
     function New (SCHEMA_POINTER_TYPE;
                   DISCRIMINANTS): SAME_TYPE;
   or
     function New (OBJECT_POINTER_TYPE;
                   CONSTRUCTOR_CALL): SAME_TYPE;

Description
-----------

Conforming to
-------------

   `New' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------


File: gpc-hr.info,  Node: NewCString,  Next: nil,  Prev: New,  Up: Reference

NewCString
==========

   (Under construction.)

Synopsis
--------

     function NewCString (const S: String): CString;

Description
-----------

Conforming to
-------------

   `NewCString' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: nil,  Next: not,  Prev: NewCString,  Up: Reference

nil
===

Synopsis
--------

   `nil' is a predefined constant

Description
-----------

   `nil' is a predefined pointer constant that indicates an unassigned
pointer. "nil" stands for "not in list". _Every_ pointer type can be
associated with this constant.

Conforming to
-------------

   `nil' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program NilDemo;
     const
       NodeNum = 10;
     type
       PNode = ^TNode;
       TNode = record
         Key: Integer;
         Next: PNode
       end;
     var
       Root, Node: PNode;
       Foo: Integer;
     begin
       New (Root);
       Root^.Key := 1;             { Set root key }
       Node := Root;
       for Foo := 2 to NodeNum do  { Create linked list with NODE_NUM nodes }
         begin
           New (Node^.Next);
           Node := Node^.Next;
           Node^.Key := Foo        { Set key }
         end;
       Node^.Next := nil;          { Mark end of linked list }
       { Shorten list by removing its first element until list is empty }
       while Root <> nil do
         begin
           Node := Root;
           WriteLn ('Current key:', Root^.Key);
           Root := Root^.Next;
           Dispose (Node);
           Node := nil             { Indicate old node is not assigned }
         end
     end.

See also
--------

   *Note Keywords::, *Note Assigned::, *Note Pointer::


File: gpc-hr.info,  Node: not,  Next: Null,  Prev: nil,  Up: Reference

not
===

   (Under construction.)

Synopsis
--------

     operator not (b1, b2: Boolean) = Result: Boolean;
   or
     operator not (i1, i2: INTEGER_TYPE) = Result: INTEGER_TYPE;

Description
-----------

   Boolean or bitwise negation operator.

Conforming to
-------------

   `not' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: Null,  Next: object,  Prev: not,  Up: Reference

Null
====

Synopsis
--------

     var
       Null: Void absolute 0;

Description
-----------

   `Null' is a predefined variable at address `nil'.  `Null' can be
passed as a "void" argument to a procedure, function or operator
expecting a "var" parameter. _Note_: Make sure they can handle this
case, otherwise this is likely to cause an exception and the program
will be terminated. Since `Null' is an L-value, it can be taken as
"nil-reference".

Conforming to
-------------

   `Null' is a Borland Delphi extension.

Example
-------

     program NullDemo;
     type
       PString = ^String;
     var
       Com1: String (25) = 'This is an amazing number';
       Com2: String (25) = 'This is a boring number';
     
     procedure FooBar (Foo: Integer; var Comment: PString);
     begin
       if Odd (Foo) then
         WriteLn ('FooBar:', Foo, ' is odd')
        else
         WriteLn ('FooBar:', Foo, ' is even');
       if @@Comment <> nil then
         if not Odd (Foo) then
           Comment := @@Com1
         else
           Comment := @@Com2
     end;
     
     var
       S: String (25);
       P: PString value @@S;
     
     begin
       { FooBar allows you to leave out variables
         for any information you might not need }
       FooBar (1, Null);
       { But FooBar is flexible, after all }
       FooBar (6, P);
       WriteLn ('FooBar said about 6: `', P^, '''')
     end.

See also
--------

   *Note nil::


File: gpc-hr.info,  Node: object,  Next: Odd,  Prev: Null,  Up: Reference

object
======

Synopsis
--------

Description
-----------

   The keyword `object' is used to declare a new object type:

     type
       foo = object
         a: Integer;
         constructor Init;
         procedure Bar (x: Integer); virtual;
       end;

   (For a longer example, see *Note OOP::.)

Conforming to
-------------

   GNU Pascal follows the Borland Pascal 7.0 object model.

   ISO Pascal does not support Object-oriented programming. There is an
ANSI draft for an "Object Pascal" language which is not yet supported
by GPC, but planned. The Delphi language, also called "Object Pascal"
by Borland, is currently not supported by GPC either.

Example
-------

See also
--------

   *Note Keywords::, *Note OOP::, *Note record::.


File: gpc-hr.info,  Node: Odd,  Next: of,  Prev: object,  Up: Reference

Odd
===

Synopsis
--------

     function Odd (i: Integer): Boolean;

Description
-----------

   `Odd' checks the parity of its argument `i'. It returns `True' if
the argument is odd, `False' if it is even.

Conforming to
-------------

   `Odd' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program OddDemo;
     var
       Foo: Integer;
     begin
       Write ('Please enter an odd number: ');
       ReadLn (Foo);
       if not Odd (Foo) then
         WriteLn ('Odd''s not even! Something''s odd out there ...')
       else
         WriteLn (Foo, ' is pretty odd.')
     end.

See also
--------


File: gpc-hr.info,  Node: of,  Next: only,  Prev: Odd,  Up: Reference

of
==

   (Under construction.)

Synopsis
--------

Description
-----------

   Part of an `array', `set' or typed `file' type declaration, a `case'
statement, a variant `record' type or a `type of' type inquiry.

Conforming to
-------------

   `of' is defined in ISO 7185 Pascal and supported by all known Pascal
variants.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: only,  Next: operator,  Prev: of,  Up: Reference

only
====

   (Under construction.)

Synopsis
--------

Description
-----------

   Import specification.

Conforming to
-------------

   `only' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: operator,  Next: or,  Prev: only,  Up: Reference

operator
========

   (Under construction.)

Synopsis
--------

Description
-----------

   Operator declaration.

Conforming to
-------------

   `operator' is PASCAL_SC extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: or,  Next: Ord,  Prev: operator,  Up: Reference

or
==

Synopsis
--------

     operator or (operand1, operand2: Boolean) = Result: Boolean;
   or
     operator or (operand1, operand2: INTEGER_TYPE) = Result: INTEGER_TYPE;
   or
     procedure or (var operand1: INTEGER_TYPE; operand2: INTEGER_TYPE);

Description
-----------

   In GNU Pascal, `or' has three built-in meanings:

  1. Logical "or" between two `Boolean'-type expressions.  The result
     of the operation is of `Boolean' type.

     By default, `or' acts as a short-circuit operator in GPC: If the
     first operand is `True', the second operand is not evaluated
     because the result is already known to be `True'. You can change
     this to complete evaluation using the `--no-short-circuit'
     command-line option or the `{$B+}' compiler directive.

  2. Bitwise "or" between two integer-type expressions.  The result is
     of the common integer type of both expressions.

  3. Use as a "procedure": `operand1' is "or"ed bitwise with
     `operand2'; the result is stored in `operand1'.


Conforming to
-------------

   The logical `or' operator is defined in ISO 7185 Pascal.

   According to ISO, you cannot rely on `or' being a short-circuit
operator. On the other hand, GPC's default behaviour does _not_
contradict the ISO standard. (See *Note or_else::.) However, since it
seems to be a de-facto standard among ISO Pascal compilers to evaluate
both operands of `or', GPC switches to `--no-short-circuit' mode if one
of the language dialect options selecting ISO Pascal, for instance
`--extended-pascal', is given. Use `--short-circuit' to override.

   Use of `or' as a bitwise operator for integers is a Borland Pascal
extension.

   Use of `or' as a "procedure" is a GNU Pascal extension.

Example
-------

     program OrDemo;
     var
       a, b, c: Integer;
     begin
       if (a = 0) or (b = 0) then  { logical `or' }
         c := 1
       else if (a or b) = 0 then  { bitwise `or' }
         c := 2
       else
         or (c, a)  { same as `c := c or a' }
     end.

   Note the difference between the logical `or' and the bitwise `or':
When `a' is 2 and `b' is 4, then `a or b' is 6. *Beware:* `a or b = 0'
happens to mean the same as `(a = 0) and (b = 0)'. (Note the `and'!)

   Since bitwise `or' has a higher priority than the `=' operator,
parentheses are needed in `if (a = 0) or (b = 0)' because otherwise `0
or b' would be calculated first, and the remainder would cause a parse
error.

See also
--------

   *Note Keywords::, *Note and::, *Note xor::, *Note Operators::.


File: gpc-hr.info,  Node: Ord,  Next: or else,  Prev: or,  Up: Reference

Ord
===

Synopsis
--------

     function Ord (ORDINAL_VALUE): Integer;

Description
-----------

   `Ord' returns the ordinal value of any ordinal variable or constant.
For characters, this would be the ASCII code corresponding to the
character. For enumerated types, this would be the ordinal value of the
constant or variable (remember that ordinal value of enumerated
constants start from zero).

Conforming to
-------------

   `Ord' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program OrdDemo;
     var
       Ch: Char;
       Day: (Monday, Tuesday, Wednesday, Thursday, Friday);
     begin
       Ch := 'A';
       WriteLn (Ord (Ch));  { 65 }
       Day := Thursday;
       WriteLn (Ord (Day));  { 3 }
     end.

See also
--------

   *Note Character Types::, *Note Ordinal Types::, *Note Chr::, *Note
Char::


File: gpc-hr.info,  Node: or else,  Next: or_else,  Prev: Ord,  Up: Reference

or else
=======

Synopsis
--------

     { `or else' is built in. A user-defined operator cannot consist of
        two words. }
     operator or else (operand1, operand2: Boolean) = Result: Boolean;

Description
-----------

   `or else' is an alias for the short-circuit logical operator
`or_else'.

Conforming to
-------------

   While `or_else' is defined in ISO 10206 Extended Pascal, `or else'
is a GNU Pascal extension.

Example
-------

     program OrElseDemo;
     var
       a: Integer;
     begin
       ReadLn (a);
       if (a = 0) or else (100 div a > 42) then  { This is safe. }
         WriteLn ('100 div a > 42')
     end.

See also
--------

   *Note Keywords::, *Note or_else::, *Note or::, *Note and then::.


File: gpc-hr.info,  Node: or_else,  Next: otherwise,  Prev: or else,  Up: Reference

or_else
=======

Synopsis
--------

     operator or_else (operand1, operand2: Boolean) = Result: Boolean;

Description
-----------

   The `or_else' short-circuit logical operator performs the same
operation as the logical operator `or'. But while the ISO standard does
not specify anything about the evaluation of the operands of `or' -
they may be evaluated in any order, or not at all - `or_else' has a
well-defined behaviour: It evaluates the first operand. If the result
is `True', `or_else' returns `True' without evaluating the second
operand. If it is `False', the second operand is evaluated and returned.

   GPC by default treats `or' and `or_else' exactly the same.  If you
want, for some reason, to have both operands of `or' evaluated
completely, you must assign both to temporary variables and then use
`or' - or `or_else', it does not matter.

Conforming to
-------------

   `or_else' is an ISO 10206 Extended Pascal extension.

   Some people think that the ISO standard requires both operands of
`or' to be evaluated. This is false. What the ISO standard _does_ say
is that you cannot rely on a certain order of evaluation of the
operands of `or'; in particular things like the following program can
crash according to ISO Pascal, although they cannot crash when compiled
with GNU Pascal running in default mode.

     program OrBug;
     var
       a: Integer;
     begin
       ReadLn (a);
       if (a = 0) or (100 div a > 42) then  { This is *not* safe! }
         WriteLn ('You''re lucky. But the test could have crashed ...')
     end.

Example
-------

     program Or_ElseDemo;
     var
       a: Integer;
     begin
       ReadLn (a);
       if (a = 0) or_else (100 div a > 42) then  { This is safe. }
         WriteLn ('100 div a > 42')
     end.

See also
--------

   *Note Keywords::, *Note or else::, *Note or::, *Note and_then::.


File: gpc-hr.info,  Node: otherwise,  Next: Output,  Prev: or_else,  Up: Reference

otherwise
=========

Synopsis
--------

   Default `case' branch as part of the `case' ...  `otherwise'
statement:
     case EXPRESSION of
       SELECTOR: STATEMENT;
       ...
       SELECTOR: STATEMENT
     otherwise  { ``else'' instead of ``otherwise'' is allowed }
       STATEMENT;
       ...
       STATEMENT
     end

Description
-----------

   `otherwise' starts a series of statements which is executed if no
selector matches EXPRESSION. In this situation, `else' is a synonym for
`otherwise'.

Conforming to
-------------

   `otherwise' is an ISO 10206 Extended Pascal extension.

Example
-------

   See *Note case::.

See also
--------

   *Note Keywords::, *Note case Statement::, *Note case::, *Note else::.


File: gpc-hr.info,  Node: Output,  Next: Pack,  Prev: otherwise,  Up: Reference

Output
======

   (Under construction.)

Synopsis
--------

     var
       Output: Text;

Description
-----------

Conforming to
-------------

   `Output' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------


File: gpc-hr.info,  Node: Pack,  Next: packed,  Prev: Output,  Up: Reference

Pack
====

   (Under construction.)

Synopsis
--------

Description
-----------

     procedure Pack (Source: UNPACKED_ARRAY;
                     FirstElement: INDEX_TYPE;
                     var Dest: PACKED_ARRAY);

Conforming to
-------------

   `Pack' is defined in ISO 7185 Pascal and supported by all known
Pascal variants except UCSD/Borland Pascal and its variants.

Example
-------

See also
--------


File: gpc-hr.info,  Node: packed,  Next: Page,  Prev: Pack,  Up: Reference

packed
======

Synopsis
--------

Description
-----------

   `packed' is a reserved word. According to ISO 7185 Pascal it can
precede `array' and `record' type definitions to indicate that memory
usage should be minimized for variables of this type, possibly at the
expense of loss of speed.

   As a GNU Pascal extension, `packed' can also be applied to *Note
Subrange Types::.

Conforming to
-------------

   The reserved word `packed' is defined in ISO 7185 Pascal.

   According to ISO standard, only _packed_ arrays of char with lower
bound 1 qualify as strings of fixed length. GNU Pascal neither requires
`packed' nor the lower bound of 1 here.

Example
-------

     program PackedDemo;
     
     type
       MonthInt = packed 1 .. 12;  { needs one byte }
       FastMonthInt = 1 .. 12;     { needs e.g. four bytes }
     
       FixString10 = packed array [1 .. 10] of Char;
       FoxyString10 = array [0 .. 9] of Char;
     
       Flags = packed array [1 .. 32] of Boolean;  { needs four bytes }
     
       Int15 = Integer attribute (Size = 15);
       DateRec = packed record
         Day: 1 .. 31;       { five bits }
         Month: MonthInt;    { four bits }
         Year: Int15         { 15 bits = -16384 .. 16383 }
       end;
     
       Dates = array [1 .. 1000] of DateRec;
     
     var
       S: FixString10;
       T: FoxyString10;
     
     begin
       S := 'Hello!';  { blank padded }
       WriteLn (S);
     
       T := 'GNU Pascal';  { GPC extension: this also works. }
       WriteLn (T)
     end.

   `DateRec' has 24 bits = 3 bytes in total; `Dates' has 3000 bytes.

See also
--------

   *Note Keywords::, *Note Pack::, *Note Unpack::, *Note SizeOf::,
*Note AlignOf::, *Note BitSizeOf::.


File: gpc-hr.info,  Node: Page,  Next: PAnsiChar,  Prev: packed,  Up: Reference

Page
====

   (Under construction.)

Synopsis
--------

     procedure Page ([var F: Text]);
   or
     procedure Page;

Description
-----------

Conforming to
-------------

   `Page' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: PAnsiChar,  Next: ParamCount,  Prev: Page,  Up: Reference

PAnsiChar
=========

   (Under construction.)

Synopsis
--------

     type
       PAnsiChar = ^AnsiChar;

Description
-----------

Conforming to
-------------

   `PAnsiChar' is a Borland Delphi extension.

Example
-------

     program PAnsiCharDemo;
     var
       s: PAnsiChar;
     begin
       s := 'Hello, world!';
       {$X+}
       WriteLn (s)
     end.

See also
--------


File: gpc-hr.info,  Node: ParamCount,  Next: ParamStr,  Prev: PAnsiChar,  Up: Reference

ParamCount
==========

Synopsis
--------

     function ParamCount: Integer;

Description
-----------

   `ParamCount' returns the number of command-line arguments given to
the program. `ParamCount' returns 0 if no arguments have been given to
the program; the name of the program as an implicit argument is not
counted.

Conforming to
-------------

   `ParamCount' is a Borland Pascal extension.

Example
-------

     program ParamCountDemo;
     
     var
       i: Integer;
     
     begin
       WriteLn ('You have invoked this program with ',
                ParamCount, ' arguments.');
       WriteLn ('These are:');
       for i := 1 to ParamCount do
         WriteLn (ParamStr (i))
     end.

See also
--------

   *Note ParamStr::.


File: gpc-hr.info,  Node: ParamStr,  Next: PChar,  Prev: ParamCount,  Up: Reference

ParamStr
========

   (Under construction.)

Synopsis
--------

     function ParamStr (ParmNumber: Integer): String;

Description
-----------

   *Note:* If you are using the Dos (DJGPP) or MS-Windows (mingw32)
version of GPC and are getting unexpected results from `ParamStr',
please see the section "Command-line Arguments Handling in DJGPP" of
the DJGPP FAQ list.

Conforming to
-------------

   `ParamStr' is a Borland Pascal extension.

Example
-------

     program ParamStrDemo;
     
     var
       i: Integer;
     
     begin
       WriteLn ('You have invoked this program with ',
                ParamCount, ' arguments.');
       WriteLn ('These are:');
       for i := 1 to ParamCount do
         WriteLn (ParamStr (i))
     end.

See also
--------


File: gpc-hr.info,  Node: PChar,  Next: Pi,  Prev: ParamStr,  Up: Reference

PChar
=====

   (Under construction.)

Synopsis
--------

     type
       PChar = ^Char;
   or
     type
       PChar = CString;

Description
-----------

Conforming to
-------------

   `PChar' is a Borland Pascal extension.

Example
-------

     program PCharDemo;
     var
       s: PChar;
     begin
       s := 'Hello, world!';
       {$X+}
       WriteLn (s)
     end.

See also
--------


File: gpc-hr.info,  Node: Pi,  Next: PObjectType,  Prev: PChar,  Up: Reference

Pi
==

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `Pi' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: PObjectType,  Next: Pointer,  Prev: Pi,  Up: Reference

PObjectType
===========

Synopsis
--------

     type
       InternalSignedSizeType = Integer attribute (Size = BitSizeOf (SizeType));
       PObjectType = ^const record
         Size:    SizeType;
         NegSize: InternalSignedSizeType;
         Parent:  PObjectType;
         Name:    ^const String
       end;

   (Note: `^record' is not valid syntax. It is just used here in the
explanation because the record type has no name by itself.  Because of
the added method pointers (see below), there is no useful usage of the
record type.)

Description
-----------

   `PObjectType' is the type returned by `TypeOf' and required by
`SetType'. In fact, the record pointed to (the "VMT", "virtual method
table") also contains pointers to the virtual methods. However, these
are not declared in `PObjectType' because they vary from object type to
object type. The fields declared here are those that are shared by every
object type and can be accessed via `TypeOf'.

   `Size' contains the size of the object type, `NegSize' contains the
size negated (for runtime checks). `Parent' contains a pointer to the
parent type's VMT (or nil if the type has no parent). `Name' points to
a string containing the type's name.

Conforming to
-------------

   `PObjectType' is a GNU Pascal extension.

Example
-------

See also
--------

   *Note TypeOf::, *Note SetType::, *Note OOP::.


File: gpc-hr.info,  Node: Pointer,  Next: Polar,  Prev: PObjectType,  Up: Reference

Pointer
=======

   (Under construction.)

Synopsis
--------

     type
       Pointer  { built-in type }

Description
-----------

Conforming to
-------------

   `Pointer' is a Borland Pascal extension.

Example
-------

     program PointerDemo;
     var
       a: Integer;
       b: Boolean;
       p: Pointer;
     begin
       p := nil;
       p := @@a;
       p := @@b
     end.

See also
--------


File: gpc-hr.info,  Node: Polar,  Next: Pos,  Prev: Pointer,  Up: Reference

Polar
=====

   (Under construction.)

Synopsis
--------

     function Polar (rho, phi: Real): Complex;

Description
-----------

Conforming to
-------------

   `Polar' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: Pos,  Next: Position,  Prev: Polar,  Up: Reference

Pos
===

   (Under construction.)

Synopsis
--------

     function Pos (SearchPattern, Source: String): Integer;

Description
-----------

Conforming to
-------------

   `Pos' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: Position,  Next: pow,  Prev: Pos,  Up: Reference

Position
========

   (Under construction.)

Synopsis
--------

     function Position (var F: TYPED_FILE);

Description
-----------

Conforming to
-------------

   `Position' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: pow,  Next: Pred,  Prev: Position,  Up: Reference

pow
===

   (Under construction.)

Synopsis
--------

     operator pow (base: Real; exponent: Integer) = power: Real;
   or
     operator pow (base: Complex; exponent: Integer) = power: Complex;

Description
-----------

   Exponentiation operator with integer exponent.

Conforming to
-------------

   `pow' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: Pred,  Next: private,  Prev: pow,  Up: Reference

Pred
====

Synopsis
--------

     function Pred (i: ORDINAL_TYPE): ORDINAL_TYPE;
   or
     function Pred (i: ORDINAL_TYPE; j: Integer): ORDINAL_TYPE;

   or, with extended syntax (`--extended-syntax' or `{$X+}'),

     function Pred (p: POINTER_TYPE): POINTER_TYPE;
   or
     function Pred (p: POINTER_TYPE; j: Integer): POINTER_TYPE;

Description
-----------

   Returns the predecessor of the ORDINAL_TYPE value `i', or, if the
second argument `j' is given, its `j'th predecessor. For integer values
`i', this is `i - 1' (or `i - j'). (No, `Pred' does _not_ work faster
than plain subtraction. Both are optimized the same way, often to a
single machine instruction.)

   If extended syntax is on, the argument may also be a pointer value.
In this case, the address is decremented by the size of the variable
pointed to, or, if `j' is given, by `j' times the size of the variable
pointed to. If `p' points to an element of an array, the returned
pointer will point to the (`j'th) previous element of the array.

Conforming to
-------------

   The `Pred' function is defined in ISO 7185 Pascal. The optional
second parameter is defined in ISO 10206 Extended Pascal.  Application
of `Pred' to pointers is defined in Borland Pascal.  The combination of
the second argument with application to pointers is a GNU Pascal
extension.

Example
-------

     program PredDemo;
     
     type
       Metasyntactical = (foo, bar, baz);
     
     var
       m: Metasyntactical;
       c: Char;
       a: array [1 .. 7] of Integer;
       p: ^Integer;
     
     begin
       m := Pred (bar);     { foo }
       c := Pred ('Z', 2);  { 'X' }
       a[1] := 42;
       a[4] := Pred (a[1]);     { 41 }
       a[5] := Pred (a[4], 3);  { 38 }
       {$X+}
       p := @@a[5];
       p := Pred (p);     { now p points to a[4] }
       p := Pred (p, 3);  { now p points to a[1] }
     end.

See also
--------

   *Note Succ::, *Note Dec::, *Note Pointer Arithmetics::.


File: gpc-hr.info,  Node: private,  Next: procedure,  Prev: Pred,  Up: Reference

private
=======

   (Under construction.)

Synopsis
--------

Description
-----------

   GPC currently accepts but ignores the `private' directive in object
type declarations.

Conforming to
-------------

   `private' is a Borland Pascal extension.

Example
-------

See also
--------

   *Note Keywords::, *Note protected::, *Note public::, *Note
published::.


File: gpc-hr.info,  Node: procedure,  Next: program,  Prev: private,  Up: Reference

procedure
=========

   (Under construction.)

Synopsis
--------

Description
-----------

   Procedure declaration.

Conforming to
-------------

   `procedure' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: program,  Next: property,  Prev: procedure,  Up: Reference

program
=======

   (Under construction.)

Synopsis
--------

Description
-----------

   Start of a Pascal program.

Conforming to
-------------

   `program' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: property,  Next: protected,  Prev: program,  Up: Reference

property
========

   Not yet implemented.

Synopsis
--------

Description
-----------

   Object properties.

Conforming to
-------------

   `property' is an Object Pascal and a Borland Delphi extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: protected,  Next: PtrCard,  Prev: property,  Up: Reference

protected
=========

   (Under construction.)

Synopsis
--------

Description
-----------

   The Extended Pascal meaning of `protected' is supported by GPC.

   GPC currently accepts but ignores the `protected' directive in
object type declarations.

Conforming to
-------------

   Extended Pascal and Borland Pascal, but with different meanings.

Example
-------

See also
--------

   *Note Keywords::, *Note const::, *Note import::, *Note private::,
*Note public::, *Note published::.


File: gpc-hr.info,  Node: PtrCard,  Next: PtrDiffType,  Prev: protected,  Up: Reference

PtrCard
=======

   (Under construction.)

Synopsis
--------

     type
       PtrCard = Cardinal attribute (Size = BitSizeOf (Pointer));

Description
-----------

   An unsigned integer type of the same size as a pointer.

Conforming to
-------------

   `PtrCard' is a GNU Pascal extension.

Example
-------

     program PtrCardDemo;
     var
       a: PtrCard;
       p: Pointer;
     begin
       GetMem (p, 10);
       a := PtrCard (p);
       Inc (a);
       p := Pointer (a)
     end.

See also
--------


File: gpc-hr.info,  Node: PtrDiffType,  Next: PtrInt,  Prev: PtrCard,  Up: Reference

PtrDiffType
===========

   (Under construction.)

Synopsis
--------

     type
       PtrDiffType  { built-in type }

Description
-----------

   `PtrDiffType' is a (signed) integer type to represent the difference
between two positions in memory. It is not needed except for rather
low-level purposes.

Conforming to
-------------

   `PtrDiffType' is a GNU Pascal extension.

Example
-------

     program PtrDiffTypeDemo;
     var
       a: array [1 .. 10] of Integer;
       d: PtrDiffType;
       p, q: ^Integer;
     begin
       p := @@a[1];
       q := @@a[4];
       {$X+}
       d := q - p
     end.

See also
--------


File: gpc-hr.info,  Node: PtrInt,  Next: PtrWord,  Prev: PtrDiffType,  Up: Reference

PtrInt
======

   (Under construction.)

Synopsis
--------

     type
       PtrCard = Integer attribute (Size = BitSizeOf (Pointer));

Description
-----------

   A signed integer type of the same size as a pointer.

Conforming to
-------------

   `PtrInt' is a GNU Pascal extension.

Example
-------

     program PtrIntDemo;
     var
       a: PtrInt;
       p: Pointer;
     begin
       GetMem (p, 10);
       a := PtrInt (p);
       Inc (a);
       p := Pointer (a)
     end.

See also
--------


File: gpc-hr.info,  Node: PtrWord,  Next: public,  Prev: PtrInt,  Up: Reference

PtrWord
=======

   (Under construction.)

Synopsis
--------

     type
       PtrWord = PtrCard;

Description
-----------

   An unsigned integer type of the same size as a pointer.

Conforming to
-------------

   `PtrWord' is a GNU Pascal extension.

Example
-------

     program PtrWordDemo;
     var
       a: PtrWord;
       p: Pointer;
     begin
       GetMem (p, 10);
       a := PtrWord (p);
       Inc (a);
       p := Pointer (a)
     end.

See also
--------


File: gpc-hr.info,  Node: public,  Next: published,  Prev: PtrWord,  Up: Reference

public
======

   (Under construction.)

Synopsis
--------

Description
-----------

   GPC currently accepts but ignores the `public' directive in object
type declarations.

Conforming to
-------------

   `public' is a Borland Pascal extension.

Example
-------

See also
--------

   *Note Keywords::, *Note private::, *Note protected::, *Note
published::.


File: gpc-hr.info,  Node: published,  Next: Put,  Prev: public,  Up: Reference

published
=========

   (Under construction.)

Synopsis
--------

Description
-----------

   GPC currently accepts but ignores the `published' directive in
object type declarations.

Conforming to
-------------

   `published' is a Borland Delphi extension.

Example
-------

See also
--------

   *Note Keywords::, *Note private::, *Note protected::, *Note public::.


File: gpc-hr.info,  Node: Put,  Next: qualified,  Prev: published,  Up: Reference

Put
===

   (Under construction.)

Synopsis
--------

     procedure Put (var F: TYPED_FILE);

Description
-----------

Conforming to
-------------

   `Put' is defined in ISO 7185 Pascal and supported by all known
Pascal variants except UCSD/Borland Pascal and its variants.

Example
-------

See also
--------


File: gpc-hr.info,  Node: qualified,  Next: Random,  Prev: Put,  Up: Reference

qualified
=========

   (Under construction.)

Synopsis
--------

Description
-----------

   Import specification.

Conforming to
-------------

   `qualified' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: Random,  Next: Randomize,  Prev: qualified,  Up: Reference

Random
======

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `Random' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: Randomize,  Next: Re,  Prev: Random,  Up: Reference

Randomize
=========

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `Randomize' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: Re,  Next: Read,  Prev: Randomize,  Up: Reference

Re
==

Synopsis
--------

     function Re (z: Complex): Real;

Description
-----------

   `Re' extracts the real part of the complex number `z'.

Conforming to
-------------

   `Re' is an ISO 10206 Extended Pascal extension.

Example
-------

     program ReDemo;
     var
       z: Complex;
     begin
       z := Cmplx (1, 2);
       WriteLn (Re (z) : 0 : 5)
     end.

See also
--------

   *Note Cmplx::, *Note Im::, *Note Arg::


File: gpc-hr.info,  Node: Read,  Next: ReadLn,  Prev: Re,  Up: Reference

Read
====

   (Under construction.)

Synopsis
--------

     procedure Read (var F: TYPED_FILE; VARIABLE);
   or
     procedure Read (var F: Text; VARIABLES);
   or
     procedure Read (VARIABLES);

Description
-----------

Conforming to
-------------

   `Read' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------


File: gpc-hr.info,  Node: ReadLn,  Next: ReadStr,  Prev: Read,  Up: Reference

ReadLn
======

   (Under construction.)

Synopsis
--------

     procedure ReadLn (var F: Text; VARIABLES);
   or
     procedure ReadLn (VARIABLES);

Description
-----------

Conforming to
-------------

   `ReadLn' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------


File: gpc-hr.info,  Node: ReadStr,  Next: Real,  Prev: ReadLn,  Up: Reference

ReadStr
=======

   (Under construction.)

Synopsis
--------

     procedure ReadStr (const S: String; VARIABLES);

Description
-----------

Conforming to
-------------

   `ReadStr' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: Real,  Next: record,  Prev: ReadStr,  Up: Reference

Real
====

   (Under construction.)

Synopsis
--------

     type
       Real  { built-in type }

Description
-----------

Conforming to
-------------

   `Real' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program RealDemo;
     var
       a: Real;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Real Types::, *Note Int::, *Note Frac::, *Note Round::, *Note
Trunc::.


File: gpc-hr.info,  Node: record,  Next: Release,  Prev: Real,  Up: Reference

record
======

Synopsis
--------

   In type definitions:
     RECORD_TYPE_IDENTIFIER = record
       FIELD_IDENTIFIER: TYPE_DEFINITION
       ...
       FIELD_IDENTIFIER: TYPE_DEFINITION
     end;

   or, with a variant part,

     RECORD_TYPE_IDENTIFIER = record
       FIELD_IDENTIFIER: TYPE_DEFINITION
       ...
       FIELD_IDENTIFIER: TYPE_DEFINITION
       case bar: VARIANT_TYPE of
         SELECTOR: (FIELD_DECLARATIONS);
         SELECTOR: (FIELD_DECLARATIONS);
         ...
     end;

   or, without a variant selector field,

     RECORD_TYPE_IDENTIFIER = record
       FIELD_IDENTIFIER: TYPE_DEFINITION
       ...
       FIELD_IDENTIFIER: TYPE_DEFINITION
       case VARIANT_TYPE of
         SELECTOR: (FIELD_DECLARATIONS);
         SELECTOR: (FIELD_DECLARATIONS);
         ...
     end;

Description
-----------

   The reserved word `record' starts the definition of a new record
type.

   Records can be `packed' to save memory usage at the expense of speed.

   The variants of a variant record may - but are not required to -
share one location in memory (inside the record).

   Sometimes variant records are used to emulate type casting in ISO
7185 Pascal. This is in fact a violation of the standard and not
portable. There is intentionally _no_ possibility in ISO 7185 Pascal to
emulate type casting.

Conforming to
-------------

   The reserved word `record' and record types are defined in ISO 7185
Pascal.

   According to ISO Pascal, the variant type must be an identifier.
GNU Pascal, like UCSD and Borland Pascal, also allows a subrange here.

   Subranges in the variant fields, e.g. `case Integer of 2 .. 5', are
a GPC extension.

Example
-------

     program RecordDemo;
     
     type
       FooPtr = ^Foo;
     
       Foo = record
         Bar: Integer;
         NextFoo: FooPtr;
         case Choice: 1 .. 3 of
           1: (a: Integer);  { These three choices may share }
           2: (b: Real);     { one location in memory. }
           3: (c: Char;
               d: Boolean);
       end;
     
       Int5 = Integer attribute (Size = 5);
       SmallFoo = packed record
         b: 0 .. 3;
         a: Int5;
         r: Boolean
       end;  { needs 1 byte }
     
     var
       f: Foo;
     
     begin
       f.b := 3.14;
       WriteLn (f.a)  { yields some strange number which is part of the   }
                      { internal representation of the real number `f.b'. }
     end.

See also
--------

   *Note Keywords::, *Note packed::, *Note case Statement::


File: gpc-hr.info,  Node: Release,  Next: Rename,  Prev: record,  Up: Reference

Release
=======

   (Under construction.)

Synopsis
--------

     procedure Release (P: Pointer);

Description
-----------

Conforming to
-------------

   `Release' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: Rename,  Next: repeat,  Prev: Release,  Up: Reference

Rename
======

   (Under construction.)

Synopsis
--------

     procedure Rename (var F: ANY_FILE; NewName: String);

Description
-----------

Conforming to
-------------

   `Rename' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: repeat,  Next: Reset,  Prev: Rename,  Up: Reference

repeat
======

Synopsis
--------

     repeat
       STATEMENT;
       ...
       STATEMENT;
     until BOOLEAN_EXPRESSION;

Description
-----------

   The `repeat ... until' statement declares a loop. For further
description see *Note repeat Statement::.

Conforming to
-------------

   `repeat' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program RepeatDemo;
     var
       Number, Sum: Integer;
     begin
       WriteLn ('Black Jack for beginners.');
       WriteLn ('You can choose your cards yourself. :-)');
       Sum := 0;
       repeat
         Write ('Your card (number)? ');
         ReadLn (Number);
         Inc (Sum, Number);
         WriteLn ('You have ', Sum, '.')
       until Sum >= 21;
       if Sum = 21 then
         WriteLn ('You win!')
       else
         WriteLn ('You lose.')
     end.

See also
--------

   *Note Keywords::, *Note while Statement::, *Note for Statement::.


File: gpc-hr.info,  Node: Reset,  Next: resident,  Prev: repeat,  Up: Reference

Reset
=====

   (Under construction.)

Synopsis
--------

     procedure Reset (var F: ANY_FILE; [FileName: String;]
                                         [BlockSize: Cardinal]);

Description
-----------

   `Reset' opens an existing file for reading. The file pointer is
positioned at the beginning of the file.

   Like `Rewrite', `Append' and `Extend' do, `Reset' accepts an
optional second and third parameter for the name of the file in the
filesystem and, for untyped files, the block size of the file. (For
details, see *Note Rewrite::.)

Conforming to
-------------

   `Reset' is defined in ISO 7185 Pascal.  The `BlockSize' parameter is
a Borland Pascal extension.  The `FileName' parameter is a GNU Pascal
extension.

Example
-------

     program ResetDemo;
     var
       Sample: Text;
       s: String (42);
     begin
       Rewrite (Sample);  { Open an internal file for writing }
       WriteLn (Sample, 'Hello, World!');
       Reset (Sample);  { Open it again for reading }
       ReadLn (Sample, s);
       WriteLn (s);
       Close (Sample)
     end.

See also
--------

   *Note Assign::, *Note Rewrite::, *Note Append::, *Note Extend::.


File: gpc-hr.info,  Node: resident,  Next: restricted,  Prev: Reset,  Up: Reference

resident
========

   Not yet implemented.

Synopsis
--------

Description
-----------

   Library export specification.

Conforming to
-------------

   `resident' is a Borland Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: restricted,  Next: Result,  Prev: resident,  Up: Reference

restricted
==========

   (Under construction.)

Synopsis
--------

Description
-----------

   Restricted type specification.

Conforming to
-------------

   `restricted' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-hr.info,  Node: Result,  Next: Return,  Prev: restricted,  Up: Reference

Result
======

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `Result' is a Borland Delphi extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: Return,  Next: ReturnAddress,  Prev: Result,  Up: Reference

Return
======

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `Return' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: ReturnAddress,  Next: Rewrite,  Prev: Return,  Up: Reference

ReturnAddress
=============

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `ReturnAddress' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-hr.info,  Node: Rewrite,  Next: RmDir,  Prev: ReturnAddress,  Up: Reference

Rewrite
=======

   (Under construction.)

Synopsis
--------

     procedure Rewrite (var F: ANY_FILE; [FileName: String;]
                                         [BlockSize: Cardinal]);

Description
-----------

   `Rewrite' opens a file for writing. If the file does not exist, it
is created. The file pointer is positioned at the beginning of the file.

   Like `Reset', `Append' and `Extend' do, `Rewrite' accepts an
optional second and third parameter.

   The second parameter can specify the name of the file in the
filesystem. If it is omitted, the following alternative ways can be
used to specify the name. There are so many different ways in order to
be compatible to the idiosyncrasies of as many other Pascal compilers
as possible. (If you know about yet other ways, let us know ...)

   - The `Assign' procedure (*note Assign::)

   - The `Bind' procedure (*note Bind::)

   The following ways are only available if the file is external, i.e.
a global variable which is mentioned in the program header.  Otherwise,
the file will be internal, i.e. get no name in the file system (it may
get a name temporarily, but will then be erased automatically again).
This is useful to store some data and read them back within a program
without the need for permanent storage.

   - A command-line parameter of the form `--gpc-rts=-nF:NAME' where F
     is the identifier of the file variable.

   - If the file was mentioned in the program header and the option
     `--transparent file names' (*note GPC Command Line Options::) was
     set, the file name will be identical to the identifier converted
     to lower-case.

   - Otherwise, the user will be prompted for a file name.

   The last optional parameter determines the block size of the file.
It is valid only for untyped files. Almost always, 1 is the most
reasonable value here. However, the existence of this parameter is a BP
compatibility feature, and in BP it defaults to 128 because of historic
misdesign. Therefore, GPC requires this parameter to be present. In
`--borland-pascal' mode, it makes it optional (like BP does), but warns
about the strange default if omitted.

Conforming to
-------------

   `Rewrite' is defined in ISO 7185 Pascal.  The `BlockSize' parameter
is a Borland Pascal extension.  The `FileName' parameter is a GNU
Pascal extension.

Example
-------

     program RewriteDemo;
     var
       Sample: Text;
     begin
       Assign (Sample, 'sample.txt');
       Rewrite (Sample);
       WriteLn (Sample, 'Hello, World!');
       Close (Sample)
     end.

See also
--------

   *Note Assign::, *Note Reset::, *Note Append::, *Note Extend::, *Note
Update::.

@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Import an alpha version of GNU Pascal Compiler into the tree
(not to be connected to the build before the upgrade to gcc 3.3).

We couldn't use gpc 2.1 because it's too old and doesn't support
gcc 3.x at all.
@
text
@@
