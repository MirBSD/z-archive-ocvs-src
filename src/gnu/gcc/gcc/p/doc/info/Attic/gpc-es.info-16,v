head	1.2;
access;
symbols
	gpc-20030830:1.1.2.1 FSF:1.1.2;
locks; strict;
comment	@# @;


1.2
date	2004.01.11.18.15.52;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2004.01.11.18.01.19;	author tg;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.01.11.18.01.19;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@nuke some unused, redundant or generated files
@
text
@This is ../p/doc/info/gpc-es.info, produced by makeinfo version 4.1
from gpc.texi.

INFO-DIR-SECTION GNU programming tools
START-INFO-DIR-ENTRY
* GPC: (gpc).                   The GNU Pascal Compiler.
END-INFO-DIR-ENTRY
INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* GPC: (gpc)Invoking GPC.       The GNU Pascal Compiler.
END-INFO-DIR-ENTRY

   This file documents the GNU Pascal Compiler.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Copyright (C) 1988-2003 Free Software Foundation, Inc.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License", "The GNU
Project", "The GNU Manifesto" and "Funding for free Software" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License", "The GNU Project", "The GNU Manifesto" and "Funding for Free
Software" and this permission notice, may be included in translations
approved by the Free Software Foundation instead of in the original
English.


File: gpc-es.info,  Node: Finalize,  Next: Flush,  Prev: finalization,  Up: Reference

Finalize
========

   (Under construction.)

Synopsis
--------

     procedure Finalize (var Aynthing);

Description
-----------

   `Finalize' does all necessary clean-ups for the parameter. This is
normally done automatically when a variable goes out of scope, so you
need to call `Finalize' only in special situations, e.g.  when you
deallocate a dynamic variable with `FreeMem' rather than `Dispose'.

Conforming to
-------------

   `Finalize' is a Borland Delphi extension.

Example
-------

See also
--------

   *Note Initialize::, *Note Dispose::, *Note FreeMem::.


File: gpc-es.info,  Node: Flush,  Next: for,  Prev: Finalize,  Up: Reference

Flush
=====

   (Under construction.)

Synopsis
--------

     procedure Flush (var F: ANY_FILE);

Description
-----------

Conforming to
-------------

   `Flush' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: for,  Next: FormatString,  Prev: Flush,  Up: Reference

for
===

Synopsis
--------

   For ordinal index variables:
     for ORDINAL_VARIABLE := INITIAL_VALUE to FINAL_VALUE do
       STATEMENT
   or
     for ORDINAL_VARIABLE := INITIAL_VALUE downto FINAL_VALUE do
       STATEMENT

   For sets:
     for SET_ELEMENT_TYPE_VARIABLE in SOME_SET do
       STATEMENT

   For pointer index variables:
     for POINTER_VARIABLE := INITIAL_ADDRESS to FINAL_ADDRESS do
       STATEMENT
   or
     for POINTER_VARIABLE := INITIAL_ADDRESS downto FINAL_ADDRESS do
       STATEMENT

   @@@@ Set member iteration

Description
-----------

   The `for' statement is a count loop. For further information see
*Note for Statement::.

Conforming to
-------------

   `for' is defined in ISO 7185 Pascal and supported by all Pascal
variants. Iteration of Pointers is a Borland Pascal extension.  Set
member iteration is an ISO 10206 Extended Pascal extension.

Example
-------

     program ForDemo;
     var
       CharSet: set of Char;
       c: Char;
       n: Integer;
       Fac: array [0 .. 10] of Integer;
       PInt: ^Integer;
     begin
        CharSet := ['g', 'p', 'c'];
        for c in CharSet do
          WriteLn (c);  { prints `c', `g', `p' in three lines }
        Fac[0] := 1;
        for n := 1 to 10 do  { computes the factorial of n for n = 0 .. 10 }
          Fac[n] := Fac[n - 1] * n;
        {$X+}
        { prints n! for n = 0 .. 10 }
        for PInt := @@Fac[0] to @@Fac[10] do
          WriteLn (PInt - @@Fac[0], '! = ', PInt^)
     end.

See also
--------

   *Note Keywords::, *Note Set Types::, *Note Pointer Arithmetics::


File: gpc-es.info,  Node: FormatString,  Next: forward,  Prev: for,  Up: Reference

FormatString
============

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `FormatString' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: forward,  Next: Frac,  Prev: FormatString,  Up: Reference

forward
=======

   (Under construction.)

Synopsis
--------

Description
-----------

   Declaration of a routine whose definition follows below.

Conforming to
-------------

   `forward' is a UCSD Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: Frac,  Next: FrameAddress,  Prev: forward,  Up: Reference

Frac
====

Synopsis
--------

     function Frac (x: Real): Real;

Description
-----------

   `Frac' returns the fractional part of a floating point number.

Conforming to
-------------

   `Frac' is a Borland Pascal extension.

Example
-------

     program FracDemo;
     
     begin
       WriteLn (Frac (12.345) : 1 : 5);  { 0.34500 }
       WriteLn (Int (12.345) : 1 : 5);  { 12.00000 }
       WriteLn (Round (12.345) : 1);  { 12 }
       WriteLn (Trunc (12.345) : 1);  { 12 }
     
       WriteLn (Frac (-12.345) : 1 : 5);  { -0.34500 }
       WriteLn (Int (-12.345) : 1 : 5);  { -12.00000 }
       WriteLn (Round (-12.345) : 1);  { -12 }
       WriteLn (Trunc (-12.345) : 1);  { -12 }
     
       WriteLn (Frac (12.543) : 1 : 5);  { 0.54300 }
       WriteLn (Int (12.543) : 1 : 5);  { 12.00000 }
       WriteLn (Round (12.543) : 1);  { 13 }
       WriteLn (Trunc (12.543) : 1);  { 12 }
     
       WriteLn (Frac (-12.543) : 1 : 5);  { -0.54300 }
       WriteLn (Int (-12.543) : 1 : 5);  { -12.00000 }
       WriteLn (Round (-12.543) : 1);  { -13 }
       WriteLn (Trunc (-12.543) : 1);  { -12 }
     end.

See also
--------

   *Note Real Types::, *Note Real::, *Note Int::, *Note Round::, *Note
Trunc::.


File: gpc-es.info,  Node: FrameAddress,  Next: FreeMem,  Prev: Frac,  Up: Reference

FrameAddress
============

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `FrameAddress' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: FreeMem,  Next: function,  Prev: FrameAddress,  Up: Reference

FreeMem
=======

Synopsis
--------

     procedure FreeMem (var p: Pointer; Size: Cardinal);
   or
     procedure FreeMem (var p: Pointer);

Description
-----------

   Releases a chunk of memory previously allocated using `GetMem'.  The
parameter SIZE is optional. Its value is currently ignored.

   Since Extended Pascal's schemata provide a cleaner way to implement
dynamical arrays and such, we recommend using `GetMem' and `FreeMem'
only for low-level applications or for interfacing with other languages.

Conforming to
-------------

   `FreeMem' is a Borland Pascal extension. `FreeMem' with only one
parameter is a GNU Pascal extension.

Example
-------

   *Note GetMem::.

See also
--------

   *Note GetMem::, *Note Schema Types::, *Note Dispose::, *Note Mark::,
*Note Release::.


File: gpc-es.info,  Node: function,  Next: GE,  Prev: FreeMem,  Up: Reference

function
========

   (Under construction.)

Synopsis
--------

Description
-----------

   Function declaration.

Conforming to
-------------

   `function' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: GE,  Next: GEPad,  Prev: function,  Up: Reference

GE
==

   (Under construction.)

Synopsis
--------

     function GE (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `GE' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: GEPad,  Next: Get,  Prev: GE,  Up: Reference

GEPad
=====

   (Under construction.)

Synopsis
--------

     function GEPad (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `GEPad' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: Get,  Next: GetMem,  Prev: GEPad,  Up: Reference

Get
===

   (Under construction.)

Synopsis
--------

     procedure Get (var F: TYPED_FILE);

Description
-----------

Conforming to
-------------

   `Get' is defined in ISO 7185 Pascal and supported by all known
Pascal variants except UCSD/Borland Pascal and its variants.

Example
-------

See also
--------


File: gpc-es.info,  Node: GetMem,  Next: GetTimeStamp,  Prev: Get,  Up: Reference

GetMem
======

Synopsis
--------

     procedure GetMem (var p: Pointeger; Size: Cardinal);

Description
-----------

   Allocates dynamical storage on the heap and returns a pointer to it
in `p'.

   Since Extended Pascal's schemata provide a cleaner way to implement
dynamical arrays and such, we recommend using `GetMem' and `FreeMem'
only for low-level applications.

Conforming to
-------------

   `GetMem' is a Borland Pascal extension.

Example
-------

   The Borland-comatibility unit `Graph' from the `BPcompat' package
supports a `GetImage' and a `PutImage' procedure which need a variable
of size `ImageSize' as a buffer. Since these are "black box" routines,
the buffer can't reasonably be a schema providing a dynamical array.
Instead, we have to use `GetMem' and `FreeMem' for dynamical memory
allocation.

     program GetMemDemo;
     var
       Buffer: Pointer;
       Size: Cardinal;
     begin
       Size := Random (10000);  { the size can be determined at run time }
       GetMem (Buffer, Size);
       { Do something with Buffer }
       FreeMem (Buffer)  { or: FreeMem (Buffer, Size) }
     end.

See also
--------

   *Note FreeMem::, *Note New::, *Note Schema Types::.


File: gpc-es.info,  Node: GetTimeStamp,  Next: goto,  Prev: GetMem,  Up: Reference

GetTimeStamp
============

Synopsis
--------

     procedure GetTimeStamp (var T: TimeStamp);

Description
-----------

   GetTimeStamp gets the current local date and time as a `TimeStamp'
record containing the Year, Month, Day, Hour, Minute, Second, and so on.

Conforming to
-------------

   `GetTimeStamp' is an ISO 10206 Extended Pascal extension.

Example
-------

   Set *Note TimeStamp::.

See also
--------

   *Note TimeStamp::, *Note Date::, *Note Time::, *Note Date And Time
Routines::.


File: gpc-es.info,  Node: goto,  Next: GT,  Prev: GetTimeStamp,  Up: Reference

goto
====

   (Under construction.)

Synopsis
--------

     goto LABEL

Description
-----------

   The `goto' statement transfers control to statement with the label
`label'.

Conforming to
-------------

   `goto' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: GT,  Next: GTPad,  Prev: goto,  Up: Reference

GT
==

   (Under construction.)

Synopsis
--------

     function GT (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `GT' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: GTPad,  Next: Halt,  Prev: GT,  Up: Reference

GTPad
=====

   (Under construction.)

Synopsis
--------

     function GTPad (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `GTPad' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: Halt,  Next: High,  Prev: GTPad,  Up: Reference

Halt
====

Synopsis
--------

     Halt;
   or
     Halt (ExitCode: Integer);

Description
-----------

   `Halt' terminates the program with exitcode 0. If `ExitCode', is
specified, it is returned by `Halt' on exit.

Conforming to
-------------

   `Halt' is an Extended Pascal and a UCSD Pascal extension.

Example
-------

     program HaltDemo;
     begin
       WriteLn ('This string will always be this program''s output.');
       Halt;  { Terminate right here and right now. }
       WriteLn ('And this string won''t ever!')
     end.

See also
--------

   *Note Break::, *Note Continue::, *Note Exit::, *Note Return::, *Note
goto::.


File: gpc-es.info,  Node: High,  Next: if,  Prev: Halt,  Up: Reference

High
====

Synopsis
--------

     function High (ORDINAL_TYPE_OR_VARIABLE): ORDINAL_TYPE;
   or
     function High (ARRAY_TYPE_OR_VARIABLE): ARRAY_INDEX_TYPE;
   or
     function High (STRING_VARIABLE): Integer;

Description
-----------

   For ordinal types or variables of that type, `High' returns the
highest value a variable of that type can assume.

   For array types or variables of that type, `High' returns the
highest index a variable of that type can assume. Note: the result is of
the same type as the array index is. If the array has more than one
dimension, `High' returns the highest index in the first dimension.

   If the argument is a string variable, `High' returns the
discriminant of the string type (i.e. its capacity).

Conforming to
-------------

   `High' is a Borland Pascal extension.

Example
-------

     program HighDemo;
     type
       Colors = (Red, Green, Blue);
     var
       Col: array [Colors] of (Love, Hope, Faithfulness);
       Foo: Colors;
       Bar: Integer;
       Baz: String (123);
     begin
       Foo := High (Col);             { yields Blue }
       Bar := Ord (High (Col[Foo]));  { yields Ord (Faithfulness), i.e., 2 }
       Bar := High (Integer);         { returns highest possible ``Integer'' }
       Bar := High (Baz)              { returns 123 }
     end.

See also
--------

   *Note Low::


File: gpc-es.info,  Node: if,  Next: Im,  Prev: High,  Up: Reference

if
==

Synopsis
--------

     if BOOLEAN_EXPRESSION then
       STATEMENT
   or with an alternative statement:
     if BOOLEAN_EXPRESSION then
       STATEMENT1
     else
       STATEMENT2

Description
-----------

   The `if ... then' statement executes STATEMENT1 depending on
`Boolean expression' being true. If `else' is specified, it continues
executing STATEMENT2 instead.

Conforming to
-------------

   `if' is defined in ISO 7185 Pascal and supported by all Pascal
variants.

Example
-------

     program IfDemo;
     var
       Foo, Bar: Boolean;
     begin
       Foo := True;
       Bar := False;
       if ((1 = 1) or (2 = 3)) and (Foo = not Bar) then
         begin
           { This is executed if either Foo is true but not Bar or vice versa }
           WriteLn ('Either Foo or Bar is true.');
           if Bar then
             WriteLn ('You will see this text if Bar is true.')
         end
       else { This whole `else' branch is not executed }
         if 1 = 1 then
           if True = False then
             WriteLn ('This text is never written on screen.')
           else  { Note: This ``else'' belongs to ``if True = False'' }
             WriteLn ('This text is never written on screen as well.')
         else  { Note: This ``else'' belongs to ``if 1 = 1'' }
           WriteLn ('Nor is this.')
     end.

See also
--------

   *Note Keywords::, *Note if Statement::, *Note else::, *Note then::


File: gpc-es.info,  Node: Im,  Next: implementation,  Prev: if,  Up: Reference

Im
==

Synopsis
--------

     function Im (z: Complex): Real;

Description
-----------

   `Im' extracts the imaginary part of the complex number `z'.  The
result is a real value.

Conforming to
-------------

   `Im' is an ISO 10206 Extended Pascal extension.

Example
-------

     program ImDemo;
     var
       z: Complex;
     begin
       z := Cmplx (1, 2);  { 1 + i * 2 }
       WriteLn (Im (z) : 0 : 5)  { 2.00000 }
     end.

See also
--------

   *Note Cmplx::, *Note Re::, *Note Arg::.


File: gpc-es.info,  Node: implementation,  Next: import,  Prev: Im,  Up: Reference

implementation
==============

   (Under construction.)

Synopsis
--------

Description
-----------

   Module or unit implementation part.

Conforming to
-------------

   `implementation' is an Extended Pascal and a UCSD Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: import,  Next: in,  Prev: implementation,  Up: Reference

import
======

Synopsis
--------

     program @@@@fragment foo;
     
     import
       bar1;
       bar3 (baz1 => glork1) in 'baz.pas';
       bar2 only (baz2, baz3 => glork2);
     
     [...]

Description
-----------

   The reserved word `import' in the _import part_ of a program makes
the program import an interface.

   The `in' above tells GPC to look for the module in the specified
file; otherwise the file name is derived from the name of the interface
by adding first `.p', then `.pas' - which only works if the name of the
exported interface coincides with the file name.

   The symbol `=>' denotes import renaming: The entity which is
exported under the name `baz1' by the interface `bar3' will be known
under the new name `glork1' in the program.

   The `only' qualifier means that only the listed identifiers will be
imported from the interface. Renaming works together with `only', too.

   There must be at most one import part in a program.

   The interfaces needn't be exported by Extended Pascal modules but
may be UCSD/Borland Pascal units as well.

Conforming to
-------------

   `import' and modules in general are an ISO 10206 Extended Pascal
extension.

   GNU Pascal does not yet support `qualified' import.

Example
-------

See also
--------

   *Note Keywords::, *Note module::, *Note unit::, *Note uses::.


File: gpc-es.info,  Node: in,  Next: Inc,  Prev: import,  Up: Reference

in
==

Synopsis
--------

   As part of the `set' membership test, as a boolean expression:
     ORDINAL_VALUE in SET_EXPRESSION
   or, as part of a `for' loop iterating through a set:
     for ORDINAL_VARIABLE in SET_EXPRESSION do ...

Description
-----------

   When `in' is used as a membership test, it acts as a binary operator
taking ORDINAL_VALUE as its left parameter and SET_EXPRESSION as its
right parameter and returning a boolean result which is true if
SET_EXPRESSION contains the element ORDINAL_VALUE.

   When `in' is used as part of a `for' loop, it iterates
ORDINAL_VARIABLE over the elements contained in SET_EXPRESSION, that is
every ORDINAL_VALUE that would return true if tested as `ORDINAL_VALUE
in SET_EXPRESSION'.

Conforming to
-------------

   `in' is defined in ISO 7185 Pascal and supported by all known Pascal
variants.

Example
-------

   Set *Note set::

See also
--------

   *Note Keywords::, *Note Set Operations::, *Note set::, *Note
Exclude::, *Note Include::, *Note for::.


File: gpc-es.info,  Node: Inc,  Next: Include,  Prev: in,  Up: Reference

Inc
===

Synopsis
--------

   For ordinal types:
     procedure Inc (var x: ORDINAL_TYPE);
   or
     procedure Inc (var x: ORDINAL_TYPE; Amount: Integer);

   For pointer types:
     procedure Inc (var p: ANY_POINTER_TYPE);
   or
     procedure Inc (var p: ANY_POINTER_TYPE; Amount: Integer);

Description
-----------

   For ordinal types, `inc' increases the value of `x' by one or by
`amount' if it is given.

   If the argument `p' is pointing to a specified type (typed pointer),
`inc' increases the address of `p' by the size of the type `p' is
pointing to or by `amount' times that size respectively. If `p' is an
untyped pointer (i.e. `p' is of type *Note Pointer::), `p' is increased
by one.

Conforming to
-------------

   `Inc' is a Borland Pascal extension.  Yet application of `Inc' to
pointers is defined in Borland Pascal.  The combination of the second
argument with application to pointers is a GNU Pascal extension.

Example
-------

     program IncDemo;
     var
       Foo: Integer;
       Bar: array [1 .. 5] of Integer;
       Baz: ^Integer;
     begin
       Foo := 4;
       Inc (Foo, 5);    { yields 9 }
       {$X+}            { Turn on extended systax }
       Baz := @@Bar[1];  { Baz points to y[1] }
       Inc (Baz, 2);    { Baz points to y[3] }
     end.

See also
--------

   *Note Dec::, *Note Pred::, *Note Succ::, *Note Pointer Arithmetics::.


File: gpc-es.info,  Node: Include,  Next: Index,  Prev: Inc,  Up: Reference

Include
=======

Synopsis
--------

     Include (SET_VARIABLE, ORDINAL_VALUE);

Description
-----------

   Add (join) a single element to a set. ORDINAL_VALUE must be
compatible with the base type of SET_VARIABLE.  Include is equivalent
to:

     SET_VARIABLE := SET_VARIABLE + [ORDINAL_VALUE];

   If SET_VARIABLE already contains ORDINAL_VALUE, nothing happens.

Conforming to
-------------

   `Include' is a Borland Pascal extension.

Example
-------

     program IncludeDemo;
     
     var
       Ch: Char;
       MyCharSet: set of Char;
     
     begin
       MyCharSet := ['P','N','L'];
       Include (MyCharSet , 'A');  { A, L, N, P }
     end.

   See other examples in *Note set:: and *Note Set Operations::.

See also
--------

   *Note Keywords::, *Note Set Operations::, *Note set::, *Note in::,
*Note Exclude::.


File: gpc-es.info,  Node: Index,  Next: inherited,  Prev: Include,  Up: Reference

Index
=====

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `Index' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: inherited,  Next: initialization,  Prev: Index,  Up: Reference

inherited
=========

   (Under construction.)

Synopsis
--------

Description
-----------

   Reference to methods of ancestor object types.

Conforming to
-------------

   `inherited' is an Object Pascal, Borland Pascal and traditional
Macintosh Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: initialization,  Next: Initialize,  Prev: inherited,  Up: Reference

initialization
==============

   (Under construction.)

Synopsis
--------

Description
-----------

   Unit initialization.

   It is equivalent to Extended Pascal's `to begin do'.

Conforming to
-------------

   `initialization' is a Borland Delphi extension.

Example
-------

See also
--------

   *Note Keywords::, *Note finalization::, *Note to begin do::.


File: gpc-es.info,  Node: Initialize,  Next: InOutRes,  Prev: initialization,  Up: Reference

Initialize
==========

   (Under construction.)

Synopsis
--------

     procedure Initialize (var Aynthing);

Description
-----------

   `Initialize' does all necessary initializations for the parameter
(e.g., setting of string and schema discriminants, and object VMT
pointers, initialization of file variables). This is normally done
automatically at the start of the lifetime of a variable, so you need
to call `Initialize' only in special situations, e.g. when you allocate
a dynamic variable with `GetMem' rather than `New'.

Conforming to
-------------

   `Initialize' is a Borland Delphi extension.

Example
-------

See also
--------

   *Note Finalize::, *Note New::, *Note GetMem::.


File: gpc-es.info,  Node: InOutRes,  Next: Input,  Prev: Initialize,  Up: Reference

InOutRes
========

   (Under construction.)

Synopsis
--------

     var
       InOutRes: Integer;

Description
-----------

Conforming to
-------------

   `InOutRes' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: Input,  Next: Insert,  Prev: InOutRes,  Up: Reference

Input
=====

   (Under construction.)

Synopsis
--------

     var
       Input: Text;

Description
-----------

Conforming to
-------------

   `Input' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------


File: gpc-es.info,  Node: Insert,  Next: Int,  Prev: Input,  Up: Reference

Insert
======

   (Under construction.)

Synopsis
--------

     procedure Insert (Source: String; var Dest: String; Position: Integer);

Description
-----------

Conforming to
-------------

   `Insert' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: Int,  Next: Integer,  Prev: Insert,  Up: Reference

Int
===

Synopsis
--------

     function Int (x: Real): Real;

Description
-----------

   `Int' returns the integer part of a floating point number as a
floating point number. Use `Trunc' to get the integer part as an
integer.

Conforming to
-------------

   `Int' is a UCSD Pascal extension.

Example
-------

     program IntDemo;
     
     begin
       WriteLn (Frac (12.345) : 1 : 5);  { 0.34500 }
       WriteLn (Int (12.345) : 1 : 5);  { 12.00000 }
       WriteLn (Round (12.345) : 1);  { 12 }
       WriteLn (Trunc (12.345) : 1);  { 12 }
     
       WriteLn (Frac (-12.345) : 1 : 5);  { -0.34500 }
       WriteLn (Int (-12.345) : 1 : 5);  { -12.00000 }
       WriteLn (Round (-12.345) : 1);  { -12 }
       WriteLn (Trunc (-12.345) : 1);  { -12 }
     
       WriteLn (Frac (12.543) : 1 : 5);  { 0.54300 }
       WriteLn (Int (12.543) : 1 : 5);  { 12.00000 }
       WriteLn (Round (12.543) : 1);  { 13 }
       WriteLn (Trunc (12.543) : 1);  { 12 }
     
       WriteLn (Frac (-12.543) : 1 : 5);  { -0.54300 }
       WriteLn (Int (-12.543) : 1 : 5);  { -12.00000 }
       WriteLn (Round (-12.543) : 1);  { -13 }
       WriteLn (Trunc (-12.543) : 1);  { -12 }
     end.

See also
--------

   *Note Real Types::, *Note Real::, *Note Frac::, *Note Round::, *Note
Trunc::.


File: gpc-es.info,  Node: Integer,  Next: interface,  Prev: Int,  Up: Reference

Integer
=======

Synopsis
--------

     type
       Integer  { built-in type }

Description
-----------

   `Integer' is the "natural" signed integer type in GNU Pascal.  On
most platforms it is 32 bits wide and thus has a range of `-2147483648
.. 2147483647'. Use it whenever you need a general-purpose signed
integer type.

   `Integer' in GNU Pascal is compatible to `Int' in GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   In ISO Pascal, `Integer' is the only built-in integer type.
(However see *Note Subrange Types::.)

Example
-------

     program IntegerDemo;
     var
       a: Integer;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-es.info,  Node: interface,  Next: interrupt,  Prev: Integer,  Up: Reference

interface
=========

   (Under construction.)

Synopsis
--------

Description
-----------

   Module or unit interface part.

Conforming to
-------------

   `interface' is an Extended Pascal and a UCSD Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: interrupt,  Next: IOResult,  Prev: interface,  Up: Reference

interrupt
=========

   Not yet implemented.

Synopsis
--------

Description
-----------

   Interrupt handler declaration (not yet implemented).

Conforming to
-------------

   `interrupt' is a Borland Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: IOResult,  Next: is,  Prev: interrupt,  Up: Reference

IOResult
========

   (Under construction.)

Synopsis
--------

     function IOResult: Integer;

Description
-----------

Conforming to
-------------

   `IOResult' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: is,  Next: label,  Prev: IOResult,  Up: Reference

is
==

Synopsis
--------

Description
-----------

   Object type membership test.

Conforming to
-------------

   `is' is an Object Pascal and a Borland Delphi extension.

Example
-------

See also
--------

   *Note Keywords::, *Note as::, *Note TypeOf::, *Note OOP::.


File: gpc-es.info,  Node: label,  Next: LastPosition,  Prev: is,  Up: Reference

label
=====

   (Under construction.)

Synopsis
--------

Description
-----------

   Label declaration for a `goto' statement.

Conforming to
-------------

   `label' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: LastPosition,  Next: LE,  Prev: label,  Up: Reference

LastPosition
============

   (Under construction.)

Synopsis
--------

     function LastPosition (var F: TYPED_FILE): Integer;

Description
-----------

Conforming to
-------------

   `LastPosition' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: LE,  Next: Length,  Prev: LastPosition,  Up: Reference

LE
==

   (Under construction.)

Synopsis
--------

     function LE (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `LE' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: Length,  Next: LEPad,  Prev: LE,  Up: Reference

Length
======

   (Under construction.)

Synopsis
--------

     function Length (S: String): Integer;

Description
-----------

Conforming to
-------------

   `Length' is an Extended Pascal and a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: LEPad,  Next: library,  Prev: Length,  Up: Reference

LEPad
=====

   (Under construction.)

Synopsis
--------

     function LEPad (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `LEPad' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: library,  Next: Ln,  Prev: LEPad,  Up: Reference

library
=======

   Not yet implemented.

Synopsis
--------

Description
-----------

   Library declaration.

Conforming to
-------------

   `library' is a Borland Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: Ln,  Next: LoCase,  Prev: library,  Up: Reference

Ln
==

Synopsis
--------

     function Ln (x: Real): Real;
   or
     function Ln (z: Complex): Complex;

Description
-----------

   The natural logarith `Ln' is the logarithm with base e, where e is
the Euler number e = Exp (1) = 2.718281828...

Conforming to
-------------

   The function `Ln' is defined in ISO 7185 Pascal; its application to
complex values is defined in ISO 10206 Extended Pascal.

Example
-------

     program LnDemo;
     var
       z: Complex;
     begin
       z := Cmplx (1, 1);
       z := Ln (z)  { yields Ln (SqRt (2)) + i * Pi / 4 }
                    { since Ln (i * x) = Ln Abs (x) + i * Arg (x) }
     end.

See also
--------


File: gpc-es.info,  Node: LoCase,  Next: LongBool,  Prev: Ln,  Up: Reference

LoCase
======

   (Under construction.)

Synopsis
--------

     function LoCase (Ch: Char): Char;

Description
-----------

Conforming to
-------------

   `LoCase' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: LongBool,  Next: LongCard,  Prev: LoCase,  Up: Reference

LongBool
========

Synopsis
--------

     type
       LongBool = Boolean attribute (Size = BitSizeOf (LongInt));

Description
-----------

   The intrinsic `LongBool' represents boolean values, but occupies the
same memory space as a `LongInt'.  It is used when you need to define a
parameter or record that conforms to some external library or system
specification.

Conforming to
-------------

   `LongBool' is a Borland Pascal extension.

Example
-------

     program LongBoolDemo;
     var
       a: LongBool;
     begin
       LongInt (a) := 1;
       if a then WriteLn ('Ord (True) = 1')
     end.

See also
--------

   *Note Boolean (Intrinsic)::, *Note Boolean::, *Note True::, *Note
False::, *Note CBoolean::, *Note ByteBool::, *Note ShortBool::, *Note
MedBool::, *Note WordBool::, *Note LongestBool::.


File: gpc-es.info,  Node: LongCard,  Next: LongestBool,  Prev: LongBool,  Up: Reference

LongCard
========

Synopsis
--------

     type
       LongCard = Cardinal attribute (Size = BitSizeOf (LongInt));

Description
-----------

   `LongCard' is an unsigned integer type which is longer than
`Cardinal'. On most platforms it is 64 bits wide and thus has a range
of `0..18446744073709551615'.

   `LongCard' in GNU Pascal is compatible to `long long unsigned int'
in GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `LongCard' is a GNU Pascal extension.

Example
-------

     program LongCardDemo;
     var
       a: LongCard;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-es.info,  Node: LongestBool,  Next: LongestCard,  Prev: LongCard,  Up: Reference

LongestBool
===========

Synopsis
--------

     type
       LongestBool = Boolean attribute (Size = BitSizeOf (LongestInt));

Description
-----------

   The intrinsic `LongestBool' represents boolean values, but occupies
the same memory space as a `LongestInt'.  It is used when you need to
define a parameter or record that conforms to some external library or
system specification.

Conforming to
-------------

   `LongestBool' is a GNU Pascal extension.

Example
-------

     program LongestBoolDemo;
     var
       a: LongestBool;
     begin
       LongestInt (a) := 1;
       if a then WriteLn ('Ord (True) = 1')
     end.

See also
--------

   *Note Boolean (Intrinsic)::, *Note Boolean::, *Note True::, *Note
False::, *Note CBoolean::, *Note ByteBool::, *Note ShortBool::, *Note
MedBool::, *Note WordBool::, *Note LongBool::.


File: gpc-es.info,  Node: LongestCard,  Next: LongestInt,  Prev: LongestBool,  Up: Reference

LongestCard
===========

Synopsis
--------

     type
       LongestCard = Cardinal attribute (Size = BitSizeOf (LongestInt));

Description
-----------

   `LongestCard' is GPC's longest-possible unsigned integer type.
Currently, this is the same as *Note LongCard::.  On most platforms it
is 64 bits wide and thus has a range of `0..18446744073709551615'.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `LongestCard' is a GNU Pascal extension.

Example
-------

     program LongestCardDemo;
     var
       a: LongestCard;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-es.info,  Node: LongestInt,  Next: LongestReal,  Prev: LongestCard,  Up: Reference

LongestInt
==========

Synopsis
--------

     type
       LongestInt = LongInt;  { might get bigger than LongInt someday }

Description
-----------

   `LongestInt' is GPC's longest-possible signed integer type.
Currently, this is the same as *Note LongInt::.  On most platforms it
is 64 bits wide and thus has a range of
`-9223372036854775808..9223372036854775807'.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `LongestInt' is a GNU Pascal extension.

Example
-------

     program LongestIntDemo;
     var
       a: LongestInt;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-es.info,  Node: LongestReal,  Next: LongestWord,  Prev: LongestInt,  Up: Reference

LongestReal
===========

   (Under construction.)

Synopsis
--------

     type
       LongestReal = LongReal;  { might get bigger than LongReal someday }

Description
-----------

Conforming to
-------------

   `LongestReal' is a GNU Pascal extension.

Example
-------

     program LongestRealDemo;
     var
       a: LongestReal;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------


File: gpc-es.info,  Node: LongestWord,  Next: LongInt,  Prev: LongestReal,  Up: Reference

LongestWord
===========

Synopsis
--------

     type
       LongestWord = LongestCard;

Description
-----------

   `LongestWord' is GPC's longest-possible unsigned integer type.
Currently, this is the same as *Note LongWord::.  On most platforms it
is 64 bits wide and thus has a range of `0..18446744073709551615'. (It
is the same as *Note LongestCard::.)

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `LongestWord' is a GNU Pascal extension.

Example
-------

     program LongestWordDemo;
     var
       a: LongestWord;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-es.info,  Node: LongInt,  Next: LongReal,  Prev: LongestWord,  Up: Reference

LongInt
=======

Synopsis
--------

     type
       LongInt  { built-in type }

Description
-----------

   `LongInt' is a signed integer type which is longer than `Integer'.
On most platforms it is 64 bits wide and thus has a range of
`-9223372036854775808..9223372036854775807'.

   `LongInt' in GNU Pascal is compatible to `long long int' in GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `LongInt' is a Borland Pascal extension. Borland Pascal defines
`LongInt' as a 32-bit signed integer type (*Note Integer:: in GNU
Pascal).

Example
-------

     program LongIntDemo;
     var
       a: LongInt;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-es.info,  Node: LongReal,  Next: LongWord,  Prev: LongInt,  Up: Reference

LongReal
========

   (Under construction.)

Synopsis
--------

     type
       LongReal  { built-in type }

Description
-----------

Conforming to
-------------

   `LongReal' is a GNU Pascal extension.

Example
-------

     program LongRealDemo;
     var
       a: LongReal;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------


File: gpc-es.info,  Node: LongWord,  Next: Low,  Prev: LongReal,  Up: Reference

LongWord
========

Synopsis
--------

     type
       LongWord = LongCard;

Description
-----------

   `LongWord' is an unsigned integer type which is larger than `Word'.
On most platforms it is 64 bits wide and thus has a range of
`0..18446744073709551615'. It is the same as *Note LongCard::.

   `LongWord' in GNU Pascal is compatible to `long long unsigned int'
in GNU C.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `LongWord' is a GNU Pascal extension.

Example
-------

     program LongWordDemo;
     var
       a: LongWord;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-es.info,  Node: Low,  Next: LT,  Prev: LongWord,  Up: Reference

Low
===

Synopsis
--------

     function Low (ORDINAL_TYPE_OR_VARIABLE): ORDINAL_TYPE;
   or
     function Low (ARRAY_TYPE_OR_VARIABLE): ARRAY_ELEMENT_TYPE;
   or
     function Low (STRING_VARIABLE): Integer;

Description
-----------

   For ordinal types or variables of that type, `Low' returns the
lowest value a variable of that type can assume.

   For array types or variables of that type, `Low' returns the lowest
index a variable of that type can assume. Note: the result is of the
same type as the array index is. If the array has more than one
dimension, `Low' returns the lowest index in the first dimension.

   If the argument is a string variable, `Low' returns one.

Conforming to
-------------

   `Low' is a Borland Pascal extension.

Example
-------

     program LowDemo;
     type
       Colors = (Red, Green, Blue);
     var
       Col: array [12 .. 20] of Colors;
       Foo: 12 .. 20;
       Bar: Integer;
     begin
       Foo := Low (Col);            { returns 12 }
       Col[Foo] := Low (Col[Foo]);  { returns Red }
       Bar := Low (Integer)         { returns lowest ``Integer'' value }
     end.

See also
--------

   *Note High::


File: gpc-es.info,  Node: LT,  Next: LTPad,  Prev: Low,  Up: Reference

LT
==

   (Under construction.)

Synopsis
--------

     function LT (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `LT' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: LTPad,  Next: Mark,  Prev: LT,  Up: Reference

LTPad
=====

   (Under construction.)

Synopsis
--------

     function LTPad (S1, S2: String): Boolean;

Description
-----------

Conforming to
-------------

   `LTPad' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: Mark,  Next: Max,  Prev: LTPad,  Up: Reference

Mark
====

   (Under construction.)

Synopsis
--------

     procedure Mark (var P: Pointer);

Description
-----------

Conforming to
-------------

   `Mark' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: Max,  Next: MaxChar,  Prev: Mark,  Up: Reference

Max
===

   (Under construction.)

Synopsis
--------

     function Max (x1, x2: ORDINAL_OR_REAL_TYPE): SAME_TYPE;

Description
-----------

Conforming to
-------------

   `Max' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: MaxChar,  Next: MaxInt,  Prev: Max,  Up: Reference

MaxChar
=======

   (Under construction.)

Synopsis
--------

Description
-----------

   The value of `MaxChar' is the largest value of `Char'.

Conforming to
-------------

   `MaxChar' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: MaxInt,  Next: MaxReal,  Prev: MaxChar,  Up: Reference

MaxInt
======

   (Under construction.)

Synopsis
--------

Description
-----------

   The `MaxInt' constant defines the maximum value of `Integer'. This
constant is a built-in compiler value.

Conforming to
-------------

   `MaxInt' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------


File: gpc-es.info,  Node: MaxReal,  Next: MedBool,  Prev: MaxInt,  Up: Reference

MaxReal
=======

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `MaxReal' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------

   *Note MinReal::.


File: gpc-es.info,  Node: MedBool,  Next: MedCard,  Prev: MaxReal,  Up: Reference

MedBool
=======

Synopsis
--------

     type
       MedBool = Boolean attribute (Size = BitSizeOf (MedInt));

Description
-----------

   The intrinsic `MedBool' represents boolean values, but occupies the
same memory space as a `MedInt'.  It is used when you need to define a
parameter or record that conforms to some external library or system
specification.

Conforming to
-------------

   `MedBool' is a GNU Pascal extension.

Example
-------

     program MedBoolDemo;
     var
       a: MedBool;
     begin
       MedInt (a) := 1;
       if a then WriteLn ('Ord (True) = 1')
     end.

See also
--------

   *Note Boolean (Intrinsic)::, *Note Boolean::, *Note True::, *Note
False::, *Note CBoolean::, *Note ByteBool::, *Note ShortBool::, *Note
WordBool::, *Note LongBool::, *Note LongestBool::.


File: gpc-es.info,  Node: MedCard,  Next: MedInt,  Prev: MedBool,  Up: Reference

MedCard
=======

Synopsis
--------

     type
       MedCard = Cardinal attribute (Size = BitSizeOf (MedInt));

Description
-----------

   `MedCard' is an unsigned integer type which is not smaller than
`Cardinal'. On most platforms it actually is the same as `Cardinal' and
32 bits wide and thus has a range of `0..4294967295'.

   `MedCard' in GNU Pascal is compatible to `long unsigned int' in GNU
C. This compatibility is the reason why `MedCard' exists.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `MedCard' is a GNU Pascal extension.

Example
-------

     program MedCardDemo;
     var
       a: MedCard;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-es.info,  Node: MedInt,  Next: MedReal,  Prev: MedCard,  Up: Reference

MedInt
======

Synopsis
--------

     type
       MedInt  { built-in type }

Description
-----------

   `MedInt' is a signed integer type which is not smaller than
`Integer'. On most platforms it actually is the same as `Integer' and
32 bits wide and thus has a range of `-2147483648..2147483647'.

   `MedInt' in GNU Pascal is compatible to `long int' in GNU C. This
compatibility is the reason why `MedInt' exists.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `MedInt' is a GNU Pascal extension.

Example
-------

     program MedIntDemo;
     var
       a: MedInt;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-es.info,  Node: MedReal,  Next: MedWord,  Prev: MedInt,  Up: Reference

MedReal
=======

   (Under construction.)

Synopsis
--------

     type
       MedReal = Real;

Description
-----------

Conforming to
-------------

   `MedReal' is a GNU Pascal extension.

Example
-------

     program MedRealDemo;
     var
       a: MedReal;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------


File: gpc-es.info,  Node: MedWord,  Next: Min,  Prev: MedReal,  Up: Reference

MedWord
=======

Synopsis
--------

     type
       MedWord = MedCard;

Description
-----------

   `MedWord' is an unsigned integer type which is not smaller than
`Word'. On most platforms it actually is the same as `Word' and 32 bits
wide and thus has a range of `0..4294967295'. It is the same as *Note
MedCard::.

   `MedWord' in GNU Pascal is compatible to `long unsigned int' in GNU
C. This compatibility is the reason why `MedWord' exists.

   There are lots of other integer types in GPC, see *Note Integer
Types::.

Conforming to
-------------

   `MedWord' is a GNU Pascal extension.

Example
-------

     program MedWordDemo;
     var
       a: MedWord;
     begin
       a := 42;
       WriteLn (a)
     end.

See also
--------

   *Note Integer Types::, *Note Subrange Types::.


File: gpc-es.info,  Node: Min,  Next: MinReal,  Prev: MedWord,  Up: Reference

Min
===

   (Under construction.)

Synopsis
--------

     function Min (x1, x2: ORDINAL_OR_REAL_TYPE): SAME_TYPE;

Description
-----------

Conforming to
-------------

   `Min' is a GNU Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: MinReal,  Next: MkDir,  Prev: Min,  Up: Reference

MinReal
=======

   (Under construction.)

Synopsis
--------

Description
-----------

Conforming to
-------------

   `MinReal' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------

   *Note MaxReal::.


File: gpc-es.info,  Node: MkDir,  Next: mod,  Prev: MinReal,  Up: Reference

MkDir
=====

Synopsis
--------

     procedure MkDir (Directory: String);

Description
-----------

   `MkDir' creates the given DIRECTORY, if its argument is a valid
parameter to the related operating system's function.  Otherwise a
runtime error is caused.

Conforming to
-------------

   `MkDir' is a Borland Pascal extension.

Example
-------

     program MkDirDemo;
     var
       Foo: String (127);
     begin
       WriteLn ('Enter directory name to create:');
       ReadLn (Foo);
       {$I-}  { Don't abort program on error }
       MkDir (Foo);
       if IOResult <> 0 then
         WriteLn ('Directory `', Foo, ''' could not be created')
       else
         WriteLn ('Okay')
     end.

See also
--------

   *Note ChDir::, *Note RmDir::


File: gpc-es.info,  Node: mod,  Next: module,  Prev: MkDir,  Up: Reference

mod
===

   (Under construction.)

Synopsis
--------

     operator mod (p, q: Integer) = r: Integer;

Description
-----------

   Integer remainder operator.

Conforming to
-------------

   `mod' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: module,  Next: Move,  Prev: mod,  Up: Reference

module
======

   (Under construction.)

Synopsis
--------

Description
-----------

   EP style or PXSC style module.

Conforming to
-------------

   `module' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: Move,  Next: MoveLeft,  Prev: module,  Up: Reference

Move
====

   (Under construction.)

Synopsis
--------

     procedure Move (const Source; var Dest; Count: Integer);

Description
-----------

Conforming to
-------------

   `Move' is a Borland Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: MoveLeft,  Next: MoveRight,  Prev: Move,  Up: Reference

MoveLeft
========

   (Under construction.)

Synopsis
--------

     procedure MoveLeft (const Source; var Dest; Count: Integer);

Description
-----------

Conforming to
-------------

   `MoveLeft' is a UCSD Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: MoveRight,  Next: name,  Prev: MoveLeft,  Up: Reference

MoveRight
=========

   (Under construction.)

Synopsis
--------

     procedure MoveRight (const Source; var Dest; count: Integer);

Description
-----------

Conforming to
-------------

   `MoveRight' is a UCSD Pascal extension.

Example
-------

See also
--------

@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Import an alpha version of GNU Pascal Compiler into the tree
(not to be connected to the build before the upgrade to gcc 3.3).

We couldn't use gpc 2.1 because it's too old and doesn't support
gcc 3.x at all.
@
text
@@
