head	1.2;
access;
symbols
	gpc-20030830:1.1.2.1 FSF:1.1.2;
locks; strict;
comment	@# @;


1.2
date	2004.01.11.18.15.49;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2004.01.11.18.01.18;	author tg;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.01.11.18.01.18;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@nuke some unused, redundant or generated files
@
text
@This is ../p/doc/info/gpc-es.info, produced by makeinfo version 4.1
from gpc.texi.

INFO-DIR-SECTION GNU programming tools
START-INFO-DIR-ENTRY
* GPC: (gpc).                   The GNU Pascal Compiler.
END-INFO-DIR-ENTRY
INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* GPC: (gpc)Invoking GPC.       The GNU Pascal Compiler.
END-INFO-DIR-ENTRY

   This file documents the GNU Pascal Compiler.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Copyright (C) 1988-2003 Free Software Foundation, Inc.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License", "The GNU
Project", "The GNU Manifesto" and "Funding for free Software" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License", "The GNU Project", "The GNU Manifesto" and "Funding for Free
Software" and this permission notice, may be included in translations
approved by the Free Software Foundation instead of in the original
English.


File: gpc-es.info,  Node: Files,  Next: Built-in Constants,  Prev: BP Procedural Types,  Up: Borland Pascal

Files
=====

   * GPC supports files like in Borland Pascal, including untyped files,
     `BlockRead', `BlockWrite' and `Assign'. Instead of `Assign', you
     can also use the `Bind' mechanism of Extended Pascal.

     Besides the routines supproted by BP, there are many more routines
     available that deal with files, file names and similar things in a
     portable way. In contrast to Borland Pascal, you don't have to use
     any platform-specific units to do these kinds of things, though
     portable emulations of those units (e.g., of the `Dos' and
     `WinDos' units) are also available for compatibility.



File: gpc-es.info,  Node: Built-in Constants,  Next: Built-in Operators in BP and GPC,  Prev: Files,  Up: Borland Pascal

Built-in Constants
==================

   * The `MaxInt', `MaxLongInt', `Pi' constants are supported like in
     BP.

   * Other built-in constants: GNU Pascal has `MaxChar', `MaxReal',
     `MinReal', `EpsReal' and a number of other useful constants.


File: gpc-es.info,  Node: Built-in Operators in BP and GPC,  Next: Built-in Procedures and Functions,  Prev: Built-in Constants,  Up: Borland Pascal

Built-in Operators in BP and GPC
================================

   Besides the operators found in Borland Pascal, GNU Pascal supports
the following operators:

   * Exponentiation: According to Extended Pascal, GNU Pascal supports
     the exponentiation operators `pow' and `**' which do not exist in
     Borland Pascal. You can use `x pow y' for integer and `x ** y' for
     real or complex exponents. The basis may be integer, real or
     complex in both cases.

   * GNU Pascal has a symmetric set difference operator `set1 >< set2'.
     For more about this, see *Note Set Operations::.


File: gpc-es.info,  Node: Built-in Procedures and Functions,  Next: Special Parameters,  Prev: Built-in Operators in BP and GPC,  Up: Borland Pascal

Built-in Procedures and Functions
=================================

   * `GetMem' and `FreeMem' are supported like in BP.

     The second parameter to `FreeMem' is ignored by GNU Pascal and may
     be omitted. Memory blocks are always freed with the same size they
     were allocated with.

     Remark: Extended Pascal Schema types provide a cleaner approach to
     most of the applications of `GetMem' and `FreeMem'.

   * `Min' and `Max': GNU Pascal has built-in `Min' and `Max' functions
     (two arguments) which work for all ordinal types (`Integer',
     `Char', ...) plus `Real'.

   * `UpCase', `High', `Low' and similar functions are built-in. In
     contrast to Borland Pascal, GNU Pascal's `UpCase' function is
     aware of non-ASCII characters of certain languages (e.g., accented
     letters and "umlauts"), but for compatibility this feature is
     disables in `--borland-pascal' mode. There is also a `LoCase'
     function.

   * `Lo', `Hi', `Swap' functions: not built-in, but available in the
     `System' unit.


File: gpc-es.info,  Node: Special Parameters,  Next: Miscellaneous,  Prev: Built-in Procedures and Functions,  Up: Borland Pascal

Special Parameters
==================

   * Untyped reference parameters can be denoted by

          procedure Foo (var x);

     like in Borland Pascal. In GNU Pascal, you can also use

          procedure Foo (var x: Void);

   * GNU Pascal defines "ellipsis" parameters for variable argument
     lists:

          procedure Foo (a: Integer; ...);

     However, GPC does not (yet) provide a portable mechanism to access
     the additional arguments.

   * Structured function result types: According to Extended Pascal, GNU
     Pascal allows functions to return records and arrays.

   * BP style "open array parameters"
          procedure Foo (a: array of Integer);
     are implemented. However, Standard Pascal `conformant array
     parameters' are usually a cleaner mechanism to pass arrays of
     variable size.

   * Besides BP compatible procedural types and procedure pointers
     (*note BP Procedural Types::), GNU Pascal supports Standard
     Pascal's procedural parameters:

          procedure DrawGraph (function f (x: Real): Real);


File: gpc-es.info,  Node: Miscellaneous,  Next: BP and Extended Pascal,  Prev: Special Parameters,  Up: Borland Pascal

Miscellaneous
=============

   * Headlines: According to Extended Pascal, a program headline must
     contain the program's parameters:

          program Foo (Input, Output);
          begin
          end.

     In GNU Pascal, headline parameters are optional. If the headline is
     omitted entirely, a warning is given unless you have specified
     `--borland-pascal' in the command line.

   * `case' statements: In a `case' statement, GNU Pascal allows
     `otherwise' (according to Extended Pascal) as an alternative to
     `else':

          program CaseOtherwiseDemo;
          var x: Integer;
          begin
            ReadLn (x);
            case x of
              1: WriteLn ('one');
              2: WriteLn ('two');
              otherwise
                 WriteLn ('many')
            end
          end.

     Note: In the absence of a `case' or `otherwise' branch, missing
     cases labels cause an error in Extended Pascal (which goes
     unnoticed in Borland Pascal). GPC does not give this error, but a
     warning if the `-Wswitch' option is given, however only for
     enumeration types.

   * Character constants: BP compatible character constants like `^M'
     as well as `#13' are implemented into GNU Pascal.

   * Sets: GNU Pascal has a `Card' function for sets which counts their
     elements. Unlike Borland Pascal, GNU Pascal does not limit sets to
     the range 0 .. 255.

   * Inline: GNU Pascal allows "inline" Pascal procedures and
     functions, while Borland Pascal only allows machine code to be
     inlined:

     Borland Pascal:

          function Max (x, y: Integer): Integer;
            inline ($58 / $59 / $3b / $c1 / $7f / $01 / $91);

     GNU Pascal:

          program InlineDemo;
          
          function Max (x, y: Integer): Integer; attribute (inline);
          begin
            if x > y then
              Max := x
            else
              Max := y
          end;
          
          begin
            WriteLn (Max (42, 17), ' ', Max (-4, -2))
          end.

     (Actually, a more general `Max' function is already built in.)

     This feature is not so important as it might seem because in
     optimization level 3 or higher (*note GPC Options::), GNU Pascal
     automatically inlines short procedures and functions.


File: gpc-es.info,  Node: BP and Extended Pascal,  Next: Portability hints,  Prev: Miscellaneous,  Up: Borland Pascal

BP and Extended Pascal
======================

   Pascal is a well-known programming language and hardly needs to be
described here. Note, however, that there is a large difference between
the language used by the BP compiler and the Pascal Standards.

   Extended Pascal is a standardized language based on the original
Standard Pascal, but with significant extensions. Unfortunately,
Borland Pascal does not conform to any of the Pascal standards.
Writing a program that both complies to Extended Pascal (or even
Standard Pascal) and compiles with BP is almost impossible for any
non-trivial task.

   On the other hand, BP has some nice features that make it very
powerful in the environments in which it runs. However, some of those
features are of little use on non-Dos systems and would not be good
candidates for standardization.

   There are also several BP features which are semantically similar to
features in Standard Pascal or Extended Pascal, but syntactically
different.

   Therefore, in order to be useful to users coming from either side,
GPC supports both the standards and the BP dialect as good as possible.
By default, GPC allows features from any dialect it knows.  By giving a
dialect option such as `--borland-pascal' or `--extended-pascal', you
can tell GPC to disable the features not found in that dialect, and to
adjust its warning behaviour to the dialect.

   The different sets of reserved words are a little problem, but GPC
solves it by making the words in question only "conditionally reserved"
which works transparently without problems in most cases. Still, giving
a dialect option will disable all keywords not part of this dialect.

   Apart from this, there are surprisingly few real conflicts between
the dialects. Therefore, you can usually compile your BP code without
the `--borland-pascal' option and make use of all of GPC's features.
You might be surprised, though, when GPC accepts things you didn't know
were allowed. :-)

   Finally, if you want to make use of some of GPC's extensions
(compared to BP) and still keep the code compileable with BP without
using `ifdef's all over the place, we suggest you look at the unit
`gpc-bp.pas', shipped with GPC, which contains BP versions of some of
GPC's features. Please read the comments at the beginning of the unit
to find out more about it.


File: gpc-es.info,  Node: Portability hints,  Prev: BP and Extended Pascal,  Up: Borland Pascal

Portability hints
=================

   GPC offers you the possibility to make your code fully portable to
each of the many platforms supported by GPC. It would be a pity not to
make use of this.

   This section lists some known pitfalls that often hinder otherwise
well-written programs to take full advantage of GPC. If you have never
used any compiler but Borland Pascal and similar compilers, some of the
advices might look strange to you. But this is just the same level of
strangeness that your old programs will have for you once you have
understood the principles of cross-platform portability. Remember that
many tricks you have always been applying almost automatically in
Borland Pascal were necessary to overcome certain limitations of the
Dos platform and to compensate for the compiler's missing optimization.
Programming with an optimizing compiler like GPC for platforms without
a 64 kB limit is a completely new experience - and perhaps it is among
the reasons why you are now working with GPC in the first place?

Portability - why?
------------------

   _Okay - but why should I bother and make my program portable?  I
know that all who want to use my program are running WXYZ-OS anyway._

   Yes, but that's the result of a self-fulfilling prophecy. It depends
on *you* whether it will always remain like this or not.  Consider a
program ABC written for a single platform, WXYZ-OS.  Naturally, only
WXYZ-OS-users get interested in ABC. The author gets feedback only from
WXYZ-OS users and does not see any reason to make the program
cross-platform. Then people realize that if they want to run ABC they
must move to WXYZ-OS. The author concludes that people only want
WXYZ-OS programs, and so on.

   To break out, just create a portable version of your program *now*.
Then all OSes have equal chances to show their abilities when running
your program, and your customers can choose their OS. Then, maybe, they
decide to use your program just for the reason that they can be sure
that it will run on all present and future platforms and not only on a
specific one - who knows?

   _My program is a tool specifically designed to make the best of the
STUV feature of WXYZ-OS. There is no point in making it portable._

   How much do you know about non-WXYZ-OSes? Just ask an expert how the
STUV feature is named elsewhere. Be sure, if it is of value, it exists
almost everywhere.

Low-level features
------------------

   _I am using a lot of low-level stuff in my programs, so they cannot
be portable._

   You do not use those low-level routines directly in your high-level
routines, do you? There should always be a layer "in-between" that
encapsulates the low-level routines and present an API to your program
that exactly reflects the needs of your application.  This "API in
between" is the point where you can exchange the low-level routines by
portable calls to GPC's Run Time System.

   If you do not have such a layer in-between, then the API of the
low-level routines you call are your first approximation for such a
layer.  If you have ever thought "it would be great if that API
function had that additional parameter", then your own extended version
of that API function that *has* that parameter can become part of your
"API in between".  But then don't stop here: Certainly the API of the
OS is *not* ideal for your program's needs. Just create more routines
that encapsulate all OS-specific stuff ...

   When the low-level stuff in question consists of interrupts,
assembler and similar things, then the first thing you need is a
portable replacement of the functionality. Fortunately, GPC covers many
things already in Pascal that require assembler in Borland Pascal:

   * GPC's libraries come with source. You do not need to learn
     assembler and to write a complete replacement for the CRT unit if
     you only want to adapt some tiny detail in the behavior of CRT to
     your personal needs.

   * GPC's Run Time System is fairly complete. For example, to extract
     the assigned name of a `File' variable, you do not need to mess
     around with the internal representation of those variables, but you
     can type `uses GPC' and then use the `FileName' function.  In the
     same unit, you will find a `FileExists' function and much more.

   * Manually "constructing" an object is covered by the `SetType'
     procedure in GPC. This is where Turbo Vision uses assembler to load
     an object from a stream.

   * Calling local procedures and functions via pointers simply works in
     GPC. This is another place where, for instance, Turbo Vision's
     `ForEach' method uses assembler, while GPC lets you do the same
     thing in Pascal.

   * Interfacing with the OS can be done through library calls. GPC's
     built-in functions and the GPC unit offer a rather complete set of
     routines. And again: You have the source of all this.

   * Using `FillChar' and `Move' does not necessarily speed up your
     programs. Using them to circumvent restrictions of the language
     (e.g. for direct assignments between variables of object or file
     type) is asking for trouble. `FillChar' was created in UCSD Pascal
     to set consecutive chars in a string to the same value, and `Move'
     was created to move the chars within the same string.  Better do
     not use them for other purposes.



File: gpc-es.info,  Node: Reference,  Next: Keywords,  Prev: Borland Pascal,  Up: Top

The Alphabetical GPC Language Reference
***************************************

   *This chapter is still under development. All keywords and built-in
identifiers are listed, but not all with explanations.*

   This chapter contains an alphabetical list of all keywords (reserved
words) and built-in identifiers of the GNU Pascal compiler. For
detailed and comprehensive description of syntax and reserved words,
see *Note Programming::. This chapter explains only built-in procedures
and functions in detail. It does not cover extensions provided by
external units and libraries which are supposed to come with their own
documentation.

* Menu:

* Abs::
* absolute::
* abstract::
* Addr::
* AlignOf::
* all::
* and::
* and then::
* and_then::
* AnsiChar::
* AnyFile::
* Append::
* ArcCos::
* ArcSin::
* ArcTan::
* Arg::
* array::
* as::
* asm::
* asmname::
* Assert::
* Assign::
* Assigned::
* attribute::
* begin::
* Bind::
* bindable::
* Binding::
* BindingType::
* BitSizeOf::
* BlockRead::
* BlockWrite::
* Boolean::
* Break::
* Byte::
* ByteBool::
* ByteCard::
* ByteInt::
* c::
* Card::
* Cardinal::
* case::
* CBoolean::
* Char::
* ChDir::
* Chr::
* c_language::
* class::
* Close::
* Cmplx::
* Comp::
* CompilerAssert::
* Complex::
* Concat::
* Conjugate::
* const::
* constructor::
* Continue::
* Copy::
* Cos::
* CString::
* CString2String::
* CStringCopyString::
* CurrentRoutineName::
* Date::
* Dec::
* DefineSize::
* Delete::
* destructor::
* Dispose::
* div::
* do::
* Double::
* downto::
* else::
* Empty::
* end::
* EOF::
* EOLn::
* EpsReal::
* EQ::
* EQPad::
* Erase::
* Exclude::
* Exit::
* Exp::
* export::
* exports::
* Extend::
* Extended::
* external::
* Fail::
* False::
* far::
* file::
* FilePos::
* FileSize::
* FillChar::
* finalization::
* Finalize::
* Flush::
* for::
* FormatString::
* forward::
* Frac::
* FrameAddress::
* FreeMem::
* function::
* GE::
* GEPad::
* Get::
* GetMem::
* GetTimeStamp::
* goto::
* GT::
* GTPad::
* Halt::
* High::
* if::
* Im::
* implementation::
* import::
* in::
* Inc::
* Include::
* Index::
* inherited::
* initialization::
* Initialize::
* InOutRes::
* Input::
* Insert::
* Int::
* Integer::
* interface::
* interrupt::
* IOResult::
* is::
* label::
* LastPosition::
* LE::
* Length::
* LEPad::
* library::
* Ln::
* LoCase::
* LongBool::
* LongCard::
* LongestBool::
* LongestCard::
* LongestInt::
* LongestReal::
* LongestWord::
* LongInt::
* LongReal::
* LongWord::
* Low::
* LT::
* LTPad::
* Mark::
* Max::
* MaxChar::
* MaxInt::
* MaxReal::
* MedBool::
* MedCard::
* MedInt::
* MedReal::
* MedWord::
* Min::
* MinReal::
* MkDir::
* mod::
* module::
* Move::
* MoveLeft::
* MoveRight::
* name::
* NE::
* near::
* NEPad::
* New::
* NewCString::
* nil::
* not::
* Null::
* object::
* Odd::
* of::
* only::
* operator::
* or::
* Ord::
* or else::
* or_else::
* otherwise::
* Output::
* Pack::
* packed::
* Page::
* PAnsiChar::
* ParamCount::
* ParamStr::
* PChar::
* Pi::
* PObjectType::
* Pointer::
* Polar::
* Pos::
* Position::
* pow::
* Pred::
* private::
* procedure::
* program::
* property::
* protected::
* PtrCard::
* PtrDiffType::
* PtrInt::
* PtrWord::
* public::
* published::
* Put::
* qualified::
* Random::
* Randomize::
* Re::
* Read::
* ReadLn::
* ReadStr::
* Real::
* record::
* Release::
* Rename::
* repeat::
* Reset::
* resident::
* restricted::
* Result::
* Return::
* ReturnAddress::
* Rewrite::
* RmDir::
* Round::
* RunError::
* Seek::
* SeekEOF::
* SeekEOLn::
* SeekRead::
* SeekUpdate::
* SeekWrite::
* segment::
* Self::
* set::
* SetFileTime::
* SetLength::
* SetType::
* shl::
* ShortBool::
* ShortCard::
* ShortInt::
* ShortReal::
* ShortWord::
* shr::
* Sin::
* Single::
* SizeOf::
* SizeType::
* SmallInt::
* Sqr::
* SqRt::
* StandardError::
* StandardInput::
* StandardOutput::
* StdErr::
* Str::
* String::
* String2CString::
* SubStr::
* Succ::
* Text::
* then::
* Time::
* TimeStamp::
* to::
* to begin do::
* to end do::
* Trim::
* True::
* Trunc::
* Truncate::
* type::
* type of::
* TypeOf::
* Unbind::
* unit::
* Unpack::
* until::
* UpCase::
* Update::
* uses::
* Val::
* value::
* var::
* view::
* virtual::
* Void::
* while::
* with::
* Word::
* WordBool::
* Write::
* WriteLn::
* WriteStr::
* xor::


File: gpc-es.info,  Node: Abs,  Next: absolute,  Up: Reference

Abs
===

Synopsis
--------

     function Abs (i: INTEGER_TYPE): INTEGER_TYPE;
   or
     function Abs (x: REAL_TYPE): REAL_TYPE;
   or
     function Abs (z: COMPLEX_TYPE): REAL_TYPE;

Description
-----------

   Returns the absolute value of the argument. For integer or real
values of `x', the definition is

     function Abs (x: INTEGER_OR_REAL_TYPE): INTEGER_OR_REAL_TYPE;
     begin
       if x < 0 then
         Abs := -x
       else
         Abs := x
     end;

whereas for complex values it is

     function Abs (x: Complex): Real;
     begin
       Abs := SqRt (x * Conjugate (x))
     end;

Conforming to
-------------

   The function `Abs' is defined in ISO 7185 Pascal; its application to
complex values is defined in ISO 10206 Extended Pascal.

Example
-------

     program AbsDemo;
     var
       i1: Complex;
     begin
       WriteLn (Abs (42));             { 42 }
       WriteLn (Abs (-42));            { 42 }
       WriteLn (Abs (-12.1) : 0 : 1);  { 12.1 }
       i1 := Cmplx (1, 1);             { 1 + i }
       WriteLn (Abs (i1) : 0 : 3)      { 1.414, i.e. SqRt (2) }
     end.

See also
--------

   *Note Sqr::.


File: gpc-es.info,  Node: absolute,  Next: abstract,  Prev: Abs,  Up: Reference

absolute
========

Synopsis
--------

     var
       VARIABLE_NAME: DATA_TYPE absolute VARIABLE_REFERENCE;
   or
     var
       VARIABLE_NAME: DATA_TYPE absolute INTEGER_EXPRESSION;

Description
-----------

   The first meaning of the `absolute' directive allows to put a
variable to the address of another one and thus provides a type-casting
mechanism.

   In most cases, VARIABLE_REFERENCE will be just a variable name, but
GPC also allows arbitrary pointer expressions here. If
VARIABLE_REFERENCE has neither a constant address nor is a variable
parameter, GPC prints a warning. This warning is suppressed in
"extended syntax" mode which is switched on by the `--extended-syntax'
option or the `{$X+}' compiler directive.

   GPC also allows explicit type casts. Variant records (as defined in
ISO 7185 Pascal), however, have no _guaranteed_ overlaying and are
therefore _not_ suitable for type casts.

   The second meaning of `absolute' places a variable at a specified
address. This is useful on machines without virtual memory addressing
for doing certain low-level operations, but should be avoided on
systems with memory protection such as Unix-like systems.  GPC does not
check whether the specified virtual address makes any sense and does
not provide a built-in mechanism to map it to a real address.

   GPC warns about this second use of `absolute' unless "extended
syntax" has been requested.

Conforming to
-------------

   `absolute' is a Borland Pascal extension.

   Borland Pascal has a slightly different syntax for the second
meaning related to the addressing scheme of IA32 processors working in
real mode.

   Allowing arbitrary memory references instead of just variable names
in the first meaning of `absolute' is a GNU Pascal extension.

Example
-------

     program AbsoluteDemo;
     
     {$X+}
     
     const
       IOMem = $f0000000;
       MaxVarSize = MaxInt div 8;
     
     var
       Mem: array [0 .. MaxVarSize - 1] of Byte absolute 0;
     
       { This address has no actual meaning }
       MyPort: Byte absolute IOMem + $c030;
     
     { Beware: Using any of the variables above will crash
       your program unless you know exactly what you do!
       That's why GPC warns about it without the $X+ directive. }
     
     var
       x: Real;
       a: array [1 .. SizeOf (Real)] of Byte absolute x;
       i: Integer;
       b: Byte absolute a[i];  { GNU Pascal extension:
                                  non-constant memory reference. }
     
     begin
       x := 3.14;
     
       { Look at the internal representation of a real variable. }
       for i := 1 to SizeOf (Real) do
         Write (a[i] : 4);
       WriteLn;
     
       { The same again, more ugly ... }
       for i := 1 to SizeOf (Real) do
         Write (b : 4);
       WriteLn;
     
       { And yes, there's an even more ugly way to do it ... }
       for i := 1 to SizeOf (Real) do
         Write (Mem[PtrCard (@@x) + i - 1] : 4);
       WriteLn
     end.

See also
--------

   *Note Keywords::, *Note record::, *Note Type Casts::.


File: gpc-es.info,  Node: abstract,  Next: Addr,  Prev: absolute,  Up: Reference

abstract
========

   Not yet implemented.

Synopsis
--------

Description
-----------

   Abstract object type or method declaration.

Conforming to
-------------

   `abstract' is an Object Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: Addr,  Next: AlignOf,  Prev: abstract,  Up: Reference

Addr
====

Synopsis
--------

     function Addr (const Foo): Pointer;

Description
-----------

   `Addr' returns the address of its argument. It is equivalent to the
address operator.

   Note: In BP, `Addr' returns an untyped pointer. GPC does this only
with `--borland-pascal'. Otherwise it returns a typed pointer. `Addr'
never depends on the `--[no]-typed-address' option/compiler directive,
unlike the address operator. (It is recommended you never rely on
untyped pointer results, but use a type-cast if really necessary.)

Conforming to
-------------

   `Addr' is a Borland Pascal extension.

Example
-------

     program AddrDemo;
     var
       Foo: ^Integer;
       Bar: Integer;
     begin
       Foo := Addr (Bar);  { Let `Foo' point to `Bar'. }
       Bar := 17;
       Foo^ := 42;  { Change the value of `Bar' to 42 }
       WriteLn (Bar)
     end.

See also
--------

   *Note Operators::.


File: gpc-es.info,  Node: AlignOf,  Next: all,  Prev: Addr,  Up: Reference

AlignOf
=======

Synopsis
--------

     function AlignOf (var x): Integer;

Description
-----------

   Returns the alignment of a type or variable in bytes.

Conforming to
-------------

   `AlignOf' is a GNU Pascal extension.

Example
-------

     program AlignOfDemo;
     var
       a: Integer;
       b: array [1 .. 8] of Char;
     begin
       WriteLn (AlignOf (a));        { Alignment of `Integer'; usually 4 bytes. }
       WriteLn (AlignOf (Integer));  { The same. }
       WriteLn (AlignOf (b));        { Alignment of `Char'; usually 1 byte. }
     end.

   Although the array is bigger than a single char, it is accessed char
by char, so there usually is no need to align it on a 4 byte boundary or
such. (This may be false on some platforms.)

See also
--------

   *Note SizeOf::, *Note BitSizeOf::, *Note TypeOf::.


File: gpc-es.info,  Node: all,  Next: and,  Prev: AlignOf,  Up: Reference

all
===

   (Under construction.)

Synopsis
--------

Description
-----------

   `export' extension (`export foo = all').

Conforming to
-------------

   `all' is a GNU Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: and,  Next: and then,  Prev: all,  Up: Reference

and
===

Synopsis
--------

     operator and (operand1, operand2: Boolean) = Result: Boolean;
   or
     operator and (operand1, operand2: INTEGER_TYPE) = Result: INTEGER_TYPE;
   or
     procedure and (var operand1: INTEGER_TYPE; operand2: INTEGER_TYPE);

Description
-----------

   In GNU Pascal, `and' has three built-in meanings:

  1. Logical "and" between two `Boolean'-type expressions.  The result
     of the operation is of `Boolean' type.

     By default, `and' acts as a short-circuit operator in GPC: If the
     first operand is `False', the second operand is not evaluated
     because the result is already known to be `False'.  You can change
     this to complete evaluation using the `--no-short-circuit'
     command-line option or the `{$B+}' compiler directive.

  2. Bitwise "and" between two integer-type expressions.  The result is
     of the common integer type of both expressions.

  3. Use as a "procedure": `operand1' is "and"ed bitwise with
     `operand2'; the result is stored in `operand1'.


Conforming to
-------------

   The logical `and' operator is defined in ISO 7185 Pascal.

   According to ISO, you cannot rely on `and' being a short-circuit
operator. On the other hand, GPC's default behaviour does _not_
contradict the ISO standard. (See *Note and_then::.)  However, since it
seems to be a de-facto standard among ISO Pascal compilers to evaluate
both operands of `and', GPC switches to `--no-short-circuit' mode if
one of the language dialect options selecting ISO Pascal, for instance
`--extended-pascal', is given. Use `--short-circuit' to override.

   Use of `and' as a bitwise operator for integers is a Borland Pascal
extension.

   Use of `and' as a "procedure" is a GNU Pascal extension.

Example
-------

     program AndDemo;
     var
       a, b, c: Integer;
     begin
       if (a = 0) and (b = 0) then  { logical `and' }
         c := 1
       else if (a and b) = 0 then  { bitwise `and' }
         c := 2
       else
         and (c, a)  { same as `c := c and a' }
     end.

   Note the difference between the logical `and' and the bitwise `and':
When `a' is 2 and `b' is 4, then `a and b' is 0.  *Beware:* `a and b =
0' has nothing to do with `(a = 0) and (b = 0)'!

   Since bitwise `and' has a higher priority than the `=' operator,
parentheses are needed in `if (a = 0) and (b = 0)' because otherwise `0
and b' would be calculated first, and the remainder would cause a parse
error.

See also
--------

   *Note Keywords::, *Note and_then::, *Note and then::, *Note or::,
*Note xor::, *Note Operators::.


File: gpc-es.info,  Node: and then,  Next: and_then,  Prev: and,  Up: Reference

and then
========

Synopsis
--------

     { `and then' is built in. A user-defined operator cannot consist of
        two words. }
     operator and then (operand1, operand2: Boolean) = Result: Boolean;

Description
-----------

   `and then' is an alias for the short-circuit logical operator
`and_then'.

Conforming to
-------------

   While `and_then' is defined in ISO 10206 Extended Pascal, `and then'
is a GNU Pascal extension.

Example
-------

     program AndThenDemo;
     var
       p: ^Integer;
     begin
       New (p);
       ReadLn (p^);
       if (p <> nil) and then (p^ < 42) then  { This is safe. }
         WriteLn (p^, ' is less than 42')
     end.

See also
--------

   *Note Keywords::, *Note and_then::, *Note and::, *Note or else::.


File: gpc-es.info,  Node: and_then,  Next: AnsiChar,  Prev: and then,  Up: Reference

and_then
========

Synopsis
--------

     operator and_then (operand1, operand2: Boolean) = Result: Boolean;

Description
-----------

   The `and_then' short-circuit logical operator performs the same
operation as the logical operator `and'. But while the ISO standard
does not specify anything about the evaluation of the operands of `and'
- they may be evaluated in any order, or not at all - `and_then' has a
well-defined behaviour: It evaluates the first operand. If the result is
`False', `and_then' returns `False' without evaluating the second
operand. If it is `True', the second operand is evaluated and returned.

   Since the behaviour described above is the most efficient way to
implement `and', GPC by default treats `and' and `and_then' exactly the
same. If you want, for some reason, to have both operands of `and'
evaluated completely, you must assign both to temporary variables and
then use `and' - or `and_then', it does not matter.

Conforming to
-------------

   `and_then' is an ISO 10206 Extended Pascal extension.

   Some people think that the ISO standard requires both operands of
`and' to be evaluated. This is false. What the ISO standard _does_ say
is that you cannot rely on a certain order of evaluation of the
operands of `and'; in particular things like the following program can
crash according to ISO Pascal, although they cannot crash when compiled
with GNU Pascal running in default mode.

     program AndBug;
     var
       p: ^Integer;
     begin
       New (p);
       ReadLn (p^);
       if (p <> nil) and (p^ < 42) then  { This is NOT safe! }
         WriteLn ('You''re lucky. But the test could have crashed ...')
     end.

Example
-------

     program And_ThenDemo;
     var
       p: ^Integer;
     begin
       New (p);
       ReadLn (p^);
       if (p <> nil) and_then (p^ < 42) then  { This is safe. }
         WriteLn (p^, ' is less than 42')
     end.

See also
--------

   *Note Keywords::, *Note and then::, *Note and::, *Note or_else::.


File: gpc-es.info,  Node: AnsiChar,  Next: AnyFile,  Prev: and_then,  Up: Reference

AnsiChar
========

Synopsis
--------

     type
       AnsiChar = Char;

Description
-----------

   `AnsiChar' is an 8 bit char type. Currently, it is the same as
`Char', but this might change in the future, once `wide chars' (16 bit
chars) will be introduced into GPC. Depending on the platform, `Char'
might be either `AnsiChar' or `WideChar' then.

Conforming to
-------------

   `AnsiChar' is a Borland Delphi extension.

Example
-------

     program AnsiCharDemo;
     var
       A: AnsiChar;  { There is nothing special with `AnsiChar'. }
       B: Char;
     begin
       A := 'A';
       A := B
     end.

See also
--------

   *Note PAnsiChar::, *Note Char::.


File: gpc-es.info,  Node: AnyFile,  Next: Append,  Prev: AnsiChar,  Up: Reference

AnyFile
=======

Synopsis
--------

     type
       AnyFile  { built-in type }

Description
-----------

   `AnyFile' is a built-in type that can only be used for parameters
and pointer targets. Any kind of file variable (`Text', untyped and
typed `file') can be passed to such a parameter and their address
assigned to such a pointer. On the other side, only generic file
operations are possible with `AnyFile' parameters/pointer targets.

   This type is useful for implementing generic file handling routines.
Also some built-in file routines use this type for their parameters,
e.g. `IOSelectRead' (*note Run Time System::).

   `BlockRead' (*note BlockRead::) and `BlockWrite' (*note
BlockWrite::) treat `AnyFile' specially, in that they accept all
`AnyFile's as arguments (even if the actual file is a typed or `Text'
file) and always use a block size of 1 (even if the actual file is an
untyped file with different block size or a typed file of a type with
size not equal to one). This is the only way to reliably read/write a
certain amount of data from/to an `AnyFile'.

   `AnyFile' pointers cannot be allocated with `New' (because it would
be unspecified which kind of file to create).

Conforming to
-------------

   `AnyFile' is a GNU Pascal extension.

Example
-------

     program AnyFileDemo;
     
     procedure Test (var f: AnyFile);
     var v: ^AnyFile;
     begin
       { Generic file operations are allowed for `AnyFile' }
       Rewrite (f);
     
       { `AnyFile' can also be accessed via pointers }
       v := @@f;
       Close (v^)
     end;
     
     var
       t: Text;
       f: file;
       g: file of Integer;
     
     begin
       { Any kind of file variable can be passed as `AnyFile' }
       Test (t);
       Test (f);
       Test (g)
     end.

See also
--------

   *Note Text::, *Note file::.


File: gpc-es.info,  Node: Append,  Next: ArcCos,  Prev: AnyFile,  Up: Reference

Append
======

Synopsis
--------

     procedure Append (var F: ANY_FILE; [FileName: String;]
                                         [BlockSize: Cardinal]);

Description
-----------

   `Append' opens a file for writing. If the file does not exist, it is
created. If it does exist, the file pointer is positioned after the
last element.

   Like `Rewrite', `Reset' and `Extend' do, `Append' accepts an
optional second and third parameter for the name of the file in the
filesystem and, for untyped files, the block size of the file. (For
details, see *Note Rewrite::.)

Conforming to
-------------

   `Append', including the `BlockSize' parameter, is a Borland Pascal
extension. ISO 10206 Extended Pascal has *Note Extend:: instead.  The
`FileName' parameter is a GNU Pascal extension.

Example
-------

     program AppendDemo;
     var
       Sample: Text;
     begin
       Assign (Sample, 'sample.txt');
       Rewrite (Sample);
       WriteLn (Sample, 'Hello, World!');  { `sample.txt' now has one line }
       Close (Sample);
     
       { ... }
     
       Append (Sample);
       WriteLn (Sample, 'Hello again!');  { `sample.txt' now has two lines }
       Close (Sample)
     end.

See also
--------

   *Note Assign::, *Note Reset::, *Note Rewrite::, *Note Update::,
*Note Extend::.


File: gpc-es.info,  Node: ArcCos,  Next: ArcSin,  Prev: Append,  Up: Reference

ArcCos
======

Synopsis
--------

     function ArcCos (x: Real): Real;
   or
     function ArcCos (z: Complex): Complex;

Description
-----------

   `ArcCos' returns the (principal value of the) arcus cosine of the
argument. The result is in the range `0 < ArcCos (x) < Pi' for real
arguments.

Conforming to
-------------

   `ArcCos' is a GNU Pascal extension.

Example
-------

     program ArcCosDemo;
     begin
       { yields 3.14159 as ArcCos (0.5) = Pi / 3 }
       WriteLn (3 * ArcCos (0.5) : 0 : 5)
     end.

See also
--------

   *Note ArcSin::, *Note ArcTan::, *Note Sin::, *Note Cos::, *Note
Ln::, *Note Arg::.


File: gpc-es.info,  Node: ArcSin,  Next: ArcTan,  Prev: ArcCos,  Up: Reference

ArcSin
======

Synopsis
--------

     function ArcSin (x: Real): Real;
   or
     function ArcSin (z: Complex): Complex;

Description
-----------

   `ArcSin' returns the (principal value of the) arcus sine of the
argument. The result is in the range `-Pi / 2 < ArcSin (x) < Pi / 2'
for real arguments.

Conforming to
-------------

   `ArcSin' is a GNU Pascal extension.

Example
-------

     program ArcSinDemo;
     begin
       { yields 3.14159 as ArcSin (0.5) = Pi / 6 }
       WriteLn (6 * ArcSin (0.5) : 0 : 5)
     end.

See also
--------

   *Note ArcCos::, *Note ArcTan::, *Note Sin::, *Note Cos::, *Note
Ln::, *Note Arg::.


File: gpc-es.info,  Node: ArcTan,  Next: Arg,  Prev: ArcSin,  Up: Reference

ArcTan
======

Synopsis
--------

     function ArcTan (x: Real): Real;
   or
     function ArcTan (z: Complex): Complex;

Description
-----------

   `ArcTan' returns the (principal value of the) arcus tangent of the
argument. The result is in the range `-Pi / 2 < ArcTan (x) < Pi / 2'
for real arguments.

Conforming to
-------------

   `ArcTan' is defined in ISO 7185 Pascal; its application to complex
values is defined in ISO 10206 Extended Pascal.

Example
-------

     program ArcTanDemo;
     begin
       { yields 3.14159 as ArcTan (1) = Pi / 4 }
       WriteLn (4 * ArcTan (1) : 0 : 5)
     end.

See also
--------

   *Note ArcSin::, *Note ArcCos::, *Note Sin::, *Note Cos::, *Note
Ln::, *Note Arg::.


File: gpc-es.info,  Node: Arg,  Next: array,  Prev: ArcTan,  Up: Reference

Arg
===

Synopsis
--------

     function Arg (z: Complex): Real;

Description
-----------

   `Arg' returns the complex "argument", i.e. the angle (in radian) in
the complex plane with respect to the real axis, of its parameter `z'.
The result is in the range of `-Pi < Arg (z) <= Pi'.

Conforming to
-------------

   `Arg' is an ISO 10206 Extended Pascal extension.

Example
-------

     program ArgDemo;
     var
       z: Complex;
     begin
       z := Cmplx (1, 1);  { 1 + i }
       WriteLn (Arg (z) : 0 : 5)  { yields 0.78540, i.e. Pi / 4 }
     end.

See also
--------

   *Note ArcTan::, *Note Ln::, *Note Polar::.


File: gpc-es.info,  Node: array,  Next: as,  Prev: Arg,  Up: Reference

array
=====

Synopsis
--------

   In type definitions:
     array [INDEX_TYPE] of ELEMENT_TYPE
   or
     array [INDEX_TYPE, ..., INDEX_TYPE] of ELEMENT_TYPE

   In parameter list declarations:
     array of ELEMENT_TYPE

Description
-----------

   The reserved word `array' is used to define an array type.

   @@@@conformant/open arrays

Conforming to
-------------

   Array types are defined in ISO 7185 Pascal.

Example
-------

     program ArrayDemo;
     type
       IntArray = array [1 .. 20] of Integer;
       WeekDayChars = array [(Mon, Tue, Wed, Thu, Fri, Sat, Sun)] of Char;
       Foo = array [0 .. 9, 'a' .. 'z', (Baz, Glork1, Fred)] of Real;
       TwoDimIntArray = array [1 .. 10] of IntArray;
       { is equivalent to: }
       TwoDimIntArray2 = array [1 .. 10, 1 .. 20] of Integer;
     
     procedure PrintChars (F: array of Char);
     var
       i: Integer;
     begin
       for i := Low (F) to High (F) do
         WriteLn (F[i])
     end;
     
     var
       Waldo: WeekDayChars;
     
     begin
       Waldo := 'HiWorld';
       PrintChars (Waldo)
     end.

See also
--------

   *Note Keywords::, *Note Array Types::, *Note High::, *Note Low::


File: gpc-es.info,  Node: as,  Next: asm,  Prev: array,  Up: Reference

as
==

   (Under construction.)

Synopsis
--------

Description
-----------

   Object type membership test and conversion.

Conforming to
-------------

   `as' is an Object Pascal and a Borland Delphi extension.

Example
-------

See also
--------

   *Note Keywords::, *Note is::, *Note TypeOf::, *Note OOP::.


File: gpc-es.info,  Node: asm,  Next: asmname,  Prev: as,  Up: Reference

asm
===

   (Under construction.)

Synopsis
--------

Description
-----------

   See `http://www.gnu-pascal.de/contrib/misc/gpcasm.zip'.

Conforming to
-------------

   `asm', as implemented in GPC, is a GNU Pascal extension. It is
mostly compatible to GCC's `asm', but not compatible to that of Borland
Pascal.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: asmname,  Next: Assert,  Prev: asm,  Up: Reference

asmname
=======

Synopsis
--------

Description
-----------

   *Deprecated*! Use `external name' now.

Conforming to
-------------

Example
-------

See also
--------

   *Note Keywords::, *Note external::, *Note name::, *Note Importing
Libraries from Other Languages::.


File: gpc-es.info,  Node: Assert,  Next: Assign,  Prev: asmname,  Up: Reference

Assert
======

Synopsis
--------

     procedure Assert (Condition: Boolean);
   or
     procedure Assert (Condition: Boolean; const Message: String);

Description
-----------

   `Assert' checks the given `Condition' at run-time. If it is true, it
does nothing. If it is false, it raises a runtime error, using the
second argument for the message if given.

   However, if the switch `--no-assertions' is given (*note GPC Command
Line Options::), `Assert' is deactivated. It still evaluates the
condition if it has side effects, but never raises a runtime error.

Conforming to
-------------

   `Assert' is a Borland Delphi extension.

Example
-------

See also
--------

   *Note CompilerAssert::.


File: gpc-es.info,  Node: Assign,  Next: Assigned,  Prev: Assert,  Up: Reference

Assign
======

   (Under contruction.)

Synopsis
--------

     procedure Assign (var F: ANY_FILE; FileName: String);

Description
-----------

Conforming to
-------------

   `Assign' is a Borland Pascal extension.

Example
-------

See also
--------

   *Note Reset::, *Note Rewrite::, *Note Update::, *Note Extend::,
*Note Append::.


File: gpc-es.info,  Node: Assigned,  Next: attribute,  Prev: Assign,  Up: Reference

Assigned
========

   (Under construction.)

Synopsis
--------

     function Assigned (p: Pointer): Boolean;
   or
     function Assigned (p: PROCEDURAL_TYPE): Boolean;

Description
-----------

   The `Assigned' function returns `True' if the pointer parameter or
the address of the procedural parameter is not `nil'; it returns
`False' if it is `nil'.

Conforming to
-------------

   `Assigned' is a Borland Pascal extension.

Example
-------

     program AssignedDemo;
     type
       PInt = ^Integer;
     
     procedure TellIfOdd (p: PInt);
     begin
       if Assigned (p) and then Odd (p^) then
         WriteLn ('The pointer p points to an odd value.')
     end;
     
     var
       foo: Integer;
     begin
       TellIfOdd (nil);
       foo := 1;
       TellIfOdd (@@foo);
       foo := 2;
       TellIfOdd (@@foo)
     end.

See also
--------

   *Note Null::, *Note nil::, *Note Pointer::.


File: gpc-es.info,  Node: attribute,  Next: begin,  Prev: Assigned,  Up: Reference

attribute
=========

   (Under construction.)

Synopsis
--------

     DECLARATION attribute (NAME);

   or

     DECLARATION attribute (NAME = PARAMETER);

   or

     DECLARATION attribute (NAME (PARAMETER, PARAMETER ...));

Description
-----------

   Several attributes can be given in one `attribute' directive,
separated with `,', or in several `attribute' directives.

   Besides the attributes that GCC supports (*note Attribute Syntax:
(gcc)Attribute Syntax.), GPC allows the following attributes for
variables:

   * static

   * register

   * volatile

   * const

   * external

   * name (with a string constant parameter)

   For routines it allows the following additional attributes:

   * ignorable

   * inline

   * iocritical

   * name (with a string constant parameter)

   For types it allows the following additional attributes:

   * iocritical (for procedural [pointer] types)

   * size (with an integer constant parameter)

   `Size' can be applied to integer and Boolean types to produce types
with a specified size in bits; for example

     type
       Card16 = Cardinal attribute (Size = 16);

defines an unsigned integer type with 16 bits.

   Variable and routine attributes are preceded by a `;', type
attributes are not. So, e.g., in the following example, the `Size'
attribute applies to the type, and the `static' attribute to the
variable.
     var a: Integer attribute (Size = 64); attribute (static);

Conforming to
-------------

   `attribute' is a GNU Pascal extension.

Example
-------

     program AttributeDemo;
     
     { Demo for `iocritical' attribute. }
     
     { Program will abort with a runtime error! }
     
     {$I-}
     procedure p; attribute (iocritical);
     var t: Text;
     begin
       Reset (t)  { Will not cause a runtime error here because I/O
                    checking is off, but leave InOutRes set. }
     end;
     {$I+}
     
     begin
     
       p;
       { Since `p' was declared `iocritical', and I/O checking is now on,
         InOutRes is checked immediately after the call to p, and a
         runtime error raised. }
     
       { So this statement is never reached. }
       InOutRes := 0;
     
       { Neither this one, which would be reached without the
         `iocritical' attribute. }
       WriteLn ('never gets here')
     
     end.

See also
--------

   *Note Keywords::, *Note external::.


File: gpc-es.info,  Node: begin,  Next: Bind,  Prev: attribute,  Up: Reference

begin
=====

Synopsis
--------

     begin
       STATEMENT;
       STATEMENT;
       ...
       STATEMENT
     end;

Description
-----------

   The reserved word `begin' opens a `begin ... end' statement which
joins several STATEMENTS to one compound statement.

Conforming to
-------------

   `begin' is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

Example
-------

     program BeginDemo;
     begin
       if True then
         WriteLn ('single statement');
       if True then
         begin                     { clamp statement1 ... }
           WriteLn ('statement1');
           WriteLn ('statement2')
         end                       { ... to statement2 }
     end.

See also
--------

   *Note Keywords::, *Note begin end Compound Statement::, *Note end::


File: gpc-es.info,  Node: Bind,  Next: bindable,  Prev: begin,  Up: Reference

Bind
====

   (Under construction.)

Synopsis
--------

     procedure Bind (var F: ANY_FILE; B: BindingType);

Description
-----------

Conforming to
-------------

   `Bind' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: bindable,  Next: Binding,  Prev: Bind,  Up: Reference

bindable
========

   (Under construction.)

Synopsis
--------

Description
-----------

   External bindability of files.

Conforming to
-------------

   `bindable' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------

   *Note Keywords::.


File: gpc-es.info,  Node: Binding,  Next: BindingType,  Prev: bindable,  Up: Reference

Binding
=======

   (Under construction.)

Synopsis
--------

     function Binding (F: ANY_FILE): BindingType;

Description
-----------

Conforming to
-------------

   `Binding' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------


File: gpc-es.info,  Node: BindingType,  Next: BitSizeOf,  Prev: Binding,  Up: Reference

BindingType
===========

   (Under construction.)

Synopsis
--------

     type
       UnixTimeType = LongInt;
       BindingType = {@@@@packed} record
         Bound           : Boolean;
         Force           : Boolean;      { Can be set to allow binding to
                                           directories or inaccessible files }
         Extensions_Valid: Boolean;
         Readable        : Boolean;
         Writable        : Boolean;
         Executable      : Boolean;
         Existing        : Boolean;      { Binding points to an existing file }
         Directory       : Boolean;      { Binding points to an existing
                                           directory; `Existing' is False then }
         Special         : Boolean;      { Binding points to an existing
                                           special file (device, pipe, socket,
                                           etc.); `Existing' is False then }
         SymLink         : Boolean;      { Binding points to a symbolic link }
         AccessTime,                     { Time of last access }
         ModificationTime,               { Time of last modification }
         ChangeTime      : UnixTimeType; { Time of last change }
         User,                           { User ID of owner }
         Group,                          { Group ID of owner }
         Mode,                           { Access permissions, cf. ChMod }
         Device,                         { Device the file is on }
         INode           : Integer;      { Unix INode number }
         TextBinary      : Boolean;      { Open a Text file in binary mode }
         Handle          : Integer;      { Can be set to bind a Pascal file to
                                           a given file handle }
         CloseFlag       : Boolean;      { If Handle is used, tell whether to
                                           close it when file is closed }
         Name            : String (Binding_Name_Length)
       end;

   (@@@@ Currently, in GPC, BindingType is not actually packed.)

   The fields `Bound' and `Name' are required by Extended Pascal.

   `Binding_Name_Length' is an implementation-defined constant.

Description
-----------

Conforming to
-------------

   `BindingType' is an ISO 10206 Extended Pascal extension.

Example
-------

See also
--------

@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Import an alpha version of GNU Pascal Compiler into the tree
(not to be connected to the build before the upgrade to gcc 3.3).

We couldn't use gpc 2.1 because it's too old and doesn't support
gcc 3.x at all.
@
text
@@
