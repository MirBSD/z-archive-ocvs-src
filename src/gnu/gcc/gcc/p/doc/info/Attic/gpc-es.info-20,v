head	1.2;
access;
symbols
	gpc-20030830:1.1.2.1 FSF:1.1.2;
locks; strict;
comment	@# @;


1.2
date	2004.01.11.18.15.59;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2004.01.11.18.01.20;	author tg;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.01.11.18.01.20;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@nuke some unused, redundant or generated files
@
text
@This is ../p/doc/info/gpc-es.info, produced by makeinfo version 4.1
from gpc.texi.

INFO-DIR-SECTION GNU programming tools
START-INFO-DIR-ENTRY
* GPC: (gpc).                   The GNU Pascal Compiler.
END-INFO-DIR-ENTRY
INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* GPC: (gpc)Invoking GPC.       The GNU Pascal Compiler.
END-INFO-DIR-ENTRY

   This file documents the GNU Pascal Compiler.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Copyright (C) 1988-2003 Free Software Foundation, Inc.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License", "The GNU
Project", "The GNU Manifesto" and "Funding for free Software" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License", "The GNU Project", "The GNU Manifesto" and "Funding for Free
Software" and this permission notice, may be included in translations
approved by the Free Software Foundation instead of in the original
English.


File: gpc-es.info,  Node: Planned - Misc,  Next: Planned - Utilities,  Prev: Planned - OOP,  Up: Planned Features

Planned features: Misc
----------------------

   * qualified identifiers <34508F33.4F685BD1@@keele.ac.uk> (also
     `program_name.identifier'?) (problem module.id vs. record.field);
     also for operators; `gpc' for built-in identifiers; duplicate
     identifiers in different units (fjf260[ab].pas); don't capitalize
     variable names in error messages and file name queries (store the
     casing of the first occurrence of an identifier) -> remove
     `{$no-debug-info}'; `name' for units/modules; qualified import
     (mod10.pas)

   * check for using, incrementing, ... unused variables
     <199711270257.VAA06393@@mint.mint.net> (kevin2.pas), especially for
     strings, also for `for'-loop counters after the loop (EP 6.8.1)

   * inline functions in GPI files

   * unit inheritance (of a complete interface with one statement or
     selectively)
     <Pine.HPP.3.96.971105161603.28577A-100000@@tea.geophysik.tu-freiberg.de>,
     <199711061008.LAA25341@@agnes.dida.physik.uni-essen.de> ??; virtual
     procedures ???

   * read Booleans and enum types from files, write enum types to files

   * options to warn about everything that could cause portability
     problems

   * libraries (static/shared; DLL)
     <Pine.HPP.3.96.971110183550.7996B-100000@@tea.geophysik.tu-freiberg.de>

   * smart linking (split `foo.s', as `foo*.s', ar `foo*.o' or split
     `foo.o')

   * overflow (right operand of mod <=0 is an error), nil pointer,
     string length, variant, object VMT (pointer, negative size field),
     etc. checking <199911040915.KAA11168@@humulus.daimi.au.dk>; check
     that strings converted to CStrings don't contain #0 characters;
     initialize strings (length field), pointers, ordinal values and
     reals(?) with invalid values if checking is on

   * overloading of unary operators (`+', `-', `not')

   * intel assembler syntax; BP BASM ???

   * function overloading (in units and static methods?? - with
     different parameters, override or overload?); linker name??
     (perhaps: first occurrence of a procedure with normal name (=> all
     non-overloaded procedures get normal names)?); cf. Delphi methods
     without `override'

   * `?:' (`x := if c then bar else baz')

   * `for var: type = foo to bar do' ???

   * error/exception handling (Java,Delphi?)
     <01BD7A3A.6B187A20.prucha@@helicon.co.at> (tc20000623)

   * RTS checking (libgpc_g), switch?

   * simplify math functions
     <199708091006.MAA26576@@agnes.dida.physik.uni-essen.de>

   * variable number of arguments <32F9CFE7.5CB@@lmemw.ericsson.se> ??
     ???

   * multithreading support ?? ???

   * `--wirth-pascal' :-)

   * PXSC standard ... (`pxsc.zip', `contrib/peter/pxsc') (??)

   * Object Oriented Extensions (Technical Report) (??)

   * generic types (cf. OOE section C.1) (gentypes.pas) ???

   * default parameters (cf. OOE section C.4; Delphi 4?)
     (iniparm[12].pas) <E183vio-000IyH-00@@f12.mail.ru>

   * Pascal++ standard ... (??) ???

   * Ignore{Value,Result}/Discard for arbitrary types (type-cast to
     `Void'?)

   * Delphi features: CompToCurrency, CurrencyToComp, Slice, TypeInfo
     ???, dynamic arrays (tc19991012)

   * output column numbers in error messages ??

   * consider assembler blocks volatile by default ??? (fh19980829.4)

   * debug info: `with' statements


File: gpc-es.info,  Node: Planned - Utilities,  Prev: Planned - Misc,  Up: Planned Features

Planned features: Utilities
---------------------------

   * `gp' make utility to replace automake; compile and link programs,
     but compile units without linking and without a warning that there
     is nothing to link; store GPC version numbers, platform and
     options in GPD files and re-compile automatically in `--automake'
     mode when they don't match; `external LIB' like `$L' (-> BP,
     Delphi) ?? (fh19990325.2)

   * `pas2texi' <200301290441.FAA30843@@goedel.fjf.gnu.de>

   * C header to Pascal translator

   * gdb: Pascal types (sets, files, subranges, schemata, ...)

   * `indent'-like source code formatter for Pascal

   * AT&T <-> Intel assembler syntax converter ???


File: gpc-es.info,  Node: Fixed Bugs,  Prev: Planned Features,  Up: To Do

Problems that have been solved
==============================

   This section lists the bugs fixed since the last (non alpha/beta)
GPC release, together with the date (YYYYMMDD) on which they were
fixed, so you can check if some problem has already been solved in a
recent release or developer version.

   Note: New features are not listed here anymore. See *Note News::.

   * 20030830: open internal files with `O_EXCL' on `Rewrite' (as a
     protection against symlink attacks)

   * 20030819: GPC accepts, but ignores, options with invalid suffixes
     (e.g. `--delphi-pascal')

   * 20030729: `pow' and `**' are EP conformant now (in particular `x
     pow y = (1 div x) pow (­y)' if `y' is negative and `x <> 0')
     (fjf908.pas)

   * 20030714: `--enable-keyword'/`--disable-keyword' on the
     command-line makes GPC crash (david5.pas)

   * 20030704: wrong type-error when applying `Inc' to a type-casted
     pointer (peter3.pas)

   * 20030702: with range checking enabled, check dynamic
     subrange/array size (fjf222*.pas, fjf813*.pas, fjf900*.pas)

   * 20030701: GPC allows modification of conformant array bounds,
     result of `High'/`Low' etc. (fjf897*.pas)

   * 20030626: don't allow linker names starting with a digit
     (fjf894.pas)

   * 20030625: `SubStr' with constant arguments doesn't work in
     constants (gale1.pas)

   * 20030617: handle `BitSizeOf' correctly for packed array fields,
     don't allow `SizeOf' on them (fjf891*.pas)

   * 20030612: System: `BPReal' must be a packed record
     <3EE8A26D.C919BE7D@@flexim.de>

   * 20030610: schema types with initializers (drf1.pas, fjf886*.pas)

   * 20030610: `Return' doesn't work for sets (fjf885.pas)

   * 20030609: bug with arrays as fields of `packed' records
     (waldek6.pas)

   * 20030607: don't allow duplicate imports in a module interface and
     implementation (nick1b.pas)

   * 20030604: compensate for parser read-ahead in the lexer, so
     compiler directives don't become effective too early and error
     messages refer more closely to the correct source position

   * 20030603: bug when dividing two integers with `/' (fjf481.pas)

   * 20030509: don't allow `absolute' in type definitions

   * 20030502: subranges with variable limits (couper[23].pas)

   * 20030502: Sparc with gcc-2.95.x: `goto' jumping out of two
     procedure nesting levels doesn't work (GCC bug; fixed in gcc-3)
     <200111170922.KAA09125@@goedel.fjf.gnu.de> (fjf558[op].pas) (fixed
     with gcc-3 or when using `--longjmp-all-nonlocal-labels')

   * 20030502: the parser does not always recover well after a parse
     error <199911040915.KAA11168@@humulus.daimi.au.dk> (fixed the case
     given in this report; if there are other cases, please report)

   * 20030501: detect conflicts between object fields and local
     variables in methods

   * 20030430: packed array/record fields don't work in `Read' etc.
     (tom5.pas)

   * 20030430: file parameters must not automatically be bindable in
     `--extended-pascal' (fjf193[c-e].pas)

   * 20030423: give an error rather than a warning when casting between
     types of different size in `{$X-}'

   * 20030423: simplify code generated to compute size of dynamical
     variables if no bitfields are involved (ok with gcc-3)

   * 20030422: initialized object variables don't work (fjf445*.pas)

   * 20030422: declarations of a module interface are not visible in
     the implementation (kevin13.pas, mod12.pas)
     <Pine.BSI.3.96.971110210330.7570A-100000@@malasada.lava.net>

   * 20030422: detect invalid array slice access with constant indices
     at compile-time (peter2*.pas)

   * 20030421: automatically close dynamically allocated files on
     `Dispose' and files declared in a statement block at the end of
     the statement block <6r9ir5$7v5$1@@nntpd.lkg.dec.com>
     (fjf219[a-d].pas, fjf502.pas)

   * 20030421: initialize local static variables in the main
     constructor, not in each routine call (fjf458*.pas)

   * 20030421: check parameter and result variable names in repeated
     forward etc. declarations <20010321204051.A611@@plato> (fjf284.pas,
     markus8.pas, fjf850*.pas)

   * 20030417: modifying `for'-loop counters within the loop or in a
     subroutine is not allowed <200005240807.EAA05355@@mail.bcpl.net>,
     <Pine.LNX.4.44.0210281004000.31943-100000@@duch.mimuw.edu.pl>
     (az47.pas, fjf837*.pas)

   * 20030417: possible stack overflow when using string concatenation
     in a loop (fjf419*.pas, fjf345e.pas, fjf460b.pas) - breaks
     berend3.pas (less important because strange test case, and just
     another instance of existing contourbug.pas)

   * 20030416: some functions in boolean shortcuts are always called
     (fjf226*.pas)

   * 20030414: label declarations must not be allowed in unit/module
     interfaces and module implementations (but in unit
     implementations, BP compatible, though we don't allow nonlocal
     `goto's into the constructor) (fjf835*.pas)

   * 20030321: variables declared in interfaces of modules are not
     initialized (capacity of strings etc.) (daj3.pas, sven14c.pas,
     nick1.pas)

   * 20030321: subranges whose size is exactly one or two bytes are not
     packed in packed arrays (daj14a.pas)

   * 20030321: `prior parameter's size depends on `Foo'' with `const'
     string parameters in module interfaces (fjf667.pas)

   * 20030313: operators don't always work across units (fjf803.pas)

   * 20030312: overloading `<=', `>=', `<>' and some certain words
     doesn't work (fjf789.pas, fjf794*.pas, fjf800.pas, fjf802.pas,
     fjf804.pas)

   * 20030311: when passing a schema variable as an untyped argument,
     the whole schema, including the discriminants is passed
     (fjf798.pas)

   * 20030302: discriminant identifiers as variant record selectors

   * 20030227: GPC crashes when taking the address of local variables
     in an initializer (nicola4*.pas)

   * 20030225: the warnings about uninitialized/unused variables don't
     work for strings, objects, etc. (fjf779*.pas)

   * 20030221: gcc-2.95.x: `configure --silent' doesn't work (passes
     wrong options to sub-configures, so the subsequent make fails)
     (GCC bug; fixed in 3.x)

   * 20030215: forward referencing pointers generate debug info that
     appears as generic pointers

   * 20030202: count of parameters in error messages should not include
     `Self' in methods or internal parameters for conformant/open
     arrays
     <8F990E3D9A6FD1118F3B0000F81EA1D84985CE@@exchsa2.dsto.defence.gov.au>

   * 20030129: check for unresolved `forward', interface and method
     declarations (az32.pas, fjf758*.pas)

   * 20030129: several standard conformance bugs
     (az{1..24,26..42,44..46}*.pas, emil23*.pas)

   * 20030126: some bugs with complicated schema usage (emil22*.pas,
     fjf750*.pas)

   * 20030122: subtraction of unsigned types with a negative result
     doesn't work (ml4.pas)

   * 20021229: declaring huge enum types and exporting subranges of
     them is very slow (quadratic time behaviour); some bugs regarding
     exporting of subranges (fjf736*.pas)

   * 20021213: Linux: `crtscreen' should react to `SIGWINCH'

   * 20021120: `Card' doesn't work with set constructors; `Include' and
     `Exclude' should not accept set constructors (eike3*.pas)

   * 20021105: type initializers are not type-checked until a variable
     of the type is declared (fjf704.pas); with gcc-2.x: bug when
     variables of a type with initializer are declared locally in more
     than one routine (couper13.pas)

   * 20021105: `packed object' should not be allowed (fjf703.pas)

   * 20021101: bug when replacing a non-virtual method by a virtual one
     in a descendant object type (fjf702.pas)

   * 20021027: classic Pascal does not know the empty string
     <Pine.LNX.4.44.0210181332470.29475-100000@@duch.mimuw.edu.pl>
     (fjf693*.pas)

   * 20021027: relational and exponentiation operators have no
     associativity
     <Pine.LNX.4.44.0210210807410.18095-100000@@duch.mimuw.edu.pl>
     (fjf692.pas, fjf566[k-m].pas)

   * 20021002: `gpc -BDIR' requires a trailing dir separator

   * 20021001: constructors are accepted as the argument to `Dispose'
     (fjf674.pas)

   * 20021001: align file fields in packed records on machines with
     strict alignment requirements (chief38*.pas)

   * 20021001: bug on machines with strict alignment requirements
     <199906021618.MAA06228@@sten27.software.mitel.com> (richard1.pas)

   * 20020930: duplicate variable declarations are allowed

   * 20020929: `attribute's of variables are ignored (fjf673.pas)

   * 20020929: `volatile' for `external' variables without `asmname' is
     ignored (fjf672.pas)

   * 20020926: numbers with base specifiers are allowed as labels
     (fjf417*.pas)

   * 20020923: System: `MemAvail'/`MaxAvail' can go into an endless loop

   * 20020920: the number of times the preprocessor is invoked by the
     automake mechanism might grow exponentially with the number of
     units involved <02091610572303.14626@@dutw54.wbmt.tudelft.nl>

   * 20020918: importing `StandardOutput' etc. in the interface of a
     module doesn't work (sietse2*.pas)

   * 20020904: comparisons between signed and unsigned integers
     sometimes give wrong results (eike2.pas, fjf664.pas, martin5.pas)

   * 20020903: `IOSelect' fails with file handles >= 8 on some systems
     (e.g., Solaris) (fjf663.pas)

   * 20020831: GPC creates wrong debug info for many built-in types
     <200208280012.g7S0CWj07637@@mail.bcpl.net>

   * 20020827: comparisons of `packed' subrange variables don't work
     right (martin4[ab].pas)

   * 20020824: operators defined in units don't always work (maur11.pas)

   * 20020824: object methods that contain an ISO style procedural
     parameter forget the implicit `with Self do' (fjf662a.pas)

   * 20020615: `if Pass[i] in 'A' .. 'Z'' makes GPC crash (miklos6.pas)

   * 20020603: compiling a program (not a unit or module) with
     `--interface-only' or `--syntax-only' segfaults (waldek1.pas)

   * 20020603: `--nested-comments' fails without `-Wall' (waldek2.pas)

   * 20020514: powerpc: `--strength-reduce' doesn't work with `for'
     loops [kludged now]

   * 20020514: guarantee complete evaluation in `{$B+}' mode
     (fjf552*.pas)

   * 20020514: spurious warning with `for' loops using a `ByteCard'
     counter (toby1.pas)


File: gpc-es.info,  Node: Internals,  Next: Copying,  Prev: To Do,  Up: Top

The GPC Source Reference
************************

     "The Source will be with you. Always."

   This chapter describes internals of GPC. It is meant for GPC
developers and those who want to become developers, or just want to
know more about how the compiler works. It does not contain information
needed to just use GPC to compile programs.

   This chapter tells you how to look up additional information about
the GNU Pascal compiler from its source code.

   *Note:* If you intend to modify GPC's source, please check the top
of each file you're going to modify. A number of files are generated
automatically by various tools. The top of these files will tell you by
which tool and from what file they were generated.  Modifying a
generated file is pointless, since it will be overwritten the next time
the tool is run. Instead, modify the original source (which will
usually be easier in fact, e.g. a bison input file vs. the generated C
code). This also holds for various documentation and other files.

   Proprietary compilers often come with a lot of technical information
about the internals of the compiler. This is necessary because their
vendors want to avoid to distribute the source of the compiler - which
is always the most definitive source of this technical information.

   With GNU compilers, on the other hand, you are free to get the
source code, look how your compiler works internally, customize it for
your own needs, and to re-distribute it in modified or unmodified form.
You may even take money for this redistribution.  (For details, see the
GNU General Public License, *Note Copying::.)

   The following subsections are your guide to the GNU Pascal source
code. If you have further questions, be welcome to ask them at the GNU
Pascal mailing list (see *Note Support::).

   All file paths mentioned in this chapter are relative to the GNU
Pascal source directory, a subdirectory `gcc/p' below the top-level GCC
source directory.

   The following sections roughly coincide with the order of the steps
a Pascal source passes through during compilation (omitting the code
generation which is the job of the GCC backend, and the assembler and
linker steps at the end which are done by the programs `as' and `ld' of
binutils and possibly other utilities like `collect2'). Also missing
here is the compiler driver `gpc' which behaves very similarly to `gcc'
and whose main job is to invoke the other parts in the right order,
with the right arguments etc.

   Note, this chapter docuemnts only selected parts of the compiler.
Many things are missing because nobody has yet had the time to write
something about them. In any case, for real understanding of the inner
workings, you should always refer to the source code.

* Menu:

* Preprocessor::         `gpcpp.c' -- The Pascal preprocessor
* Lexical analyzer::     `gpc-lex.c' -- How GPC reads your source.
* Language definition::  `parse.y' -- ``Syntax diagrams'' as ``Bison'' source.
* Tree nodes::           `../tree.*' -- How GPC stores your program internally.
* Parameter passing::    `typecheck.c' -- How GPC passes parameters.
* GPI files::            `module.c' -- How GPC's precompiled module/unit interfaces work.
* Automake::             `module.c' -- How GPC automatically ``makes'' a large project.
* File Layout::          Files that make up GPC
* Planned::              Planned features

   For more information, see the manual of GCC internals, *Note Top:
(gccint)Top.


File: gpc-es.info,  Node: Preprocessor,  Next: Lexical analyzer,  Up: Internals

The Pascal preprocessor
=======================

   `gpcpp' is based on the C preprocessor, so it does everything `cpp'
does (see the cpp manual) and some more.  In particular:

   * Comments like `cpp' does, but within `{ ... }' and `(* ... *)',
     also after `//' if `delphi-comments' is active, never within `/*
     ... */'.  Also mixed comments (`{ ... *)', `(* ... }') if enabled
     (`mixed-comments') and nested comments (e.g.  `{ ... { ... } ...
     }') if enabled (`nested-comments')

   * Macros and conditionals like `cpp' does, but both case sensitive
     and insensitive ones; `no-macros' to turn macro expansion off
     (e.g., for BP compatibility)

   * `ifopt' for short and long options

   * Include files like `cpp' does, but also with `{$I ...}' (BP
     style), which allows the file name extension to be omitted

   * Recognize Pascal strings (to avoid looking for comments and
     directives within strings) enclosed in single (like Standard
     Pascal) or double quotes (like C).

   * Option handling, sharing tables in `gpc-options.h' with the
     compiler:
        - Default option settings

        - Options can imply other options (e.g., `borland-pascal' ->
          `no-macros' etc.)

        - Short compiler directives

        - Short directive `W' (warnings) is disabled in
          `borland-pascal' and `delphi' because it has another meaning
          there

   * Compiler directives (`{$...}' or `(*$...*)'):
        - pass them through, so the compiler can handle them

        - keep track of them for `ifopt'

        - handle those that affect the preprocessor (e.g., about
          comments)

        - allow comments within compiler directives if nested comments
          are enabled

        - local directives

        - case insensitive

   * Slightly Pascal-like syntax for conditional compilation (`not' ->
     `!', `and' -> `&&', `or' -> `||', `xor' -> `!=', `shl' -> `<<',
     `shr' -> `>>', `False' -> `0', `True' -> `1', `<>' -> `!=', `=' ->
     `==')

   * Line directives like `cpp' does, but recognize BP style (`#42' or
     `#$f0') character constants and don't confuse them with line
     directives (the latter seem to always have a space after the `#')



File: gpc-es.info,  Node: Lexical analyzer,  Next: Language definition,  Prev: Preprocessor,  Up: Internals

GPC's Lexical Analyzer
======================

   The source file `gpc-lex.c' contains the so-called _lexical
analyzer_ of the GNU Pascal compiler. (For those of you who know
`flex': This file was _not_ created using `flex' but is maintained
manually.) This very-first stage of the compiler (after the
preprocessor which is a separate executable) is responsible for reading
what you have written and dividing it into _tokens_, the "atoms" of
each computer language. The source `gpc-lex.c' essentially contains one
large function, `yylex()'.

   Here is, for example, where the real number `3.14' and the subrange
of integers `3..14' are distinguished, and where strings constants,
symbols etc. are recognized.

* Menu:

* BP character constants::
* Compiler directives internally::


File: gpc-es.info,  Node: BP character constants,  Next: Compiler directives internally,  Up: Lexical analyzer

BP character constants
----------------------

   Borland-style character constants of the form `^M' need special
care. For example look at the following type declaration:

     type
       X = Integer;
       Y = ^X;        { pointer type }
       Z = ^X .. ^Y;  { subrange type }

   One way to resolve this is to try to let the parser tell the lexer
(via a global flag) whether a character constant or the symbol `^' (to
create pointer types or to dereference pointer expressions) is suitable
in the current context. This was done in previous versions, but it had
a number of disadvantages: First, any dependency of the lexer on the
parser (*note Lexical Tie-Ins: (bison)Lexical Tie-Ins.) is problematic
by itself since it must be taken care of manually in each relevant
parser rule. Furthermore, the parser read-ahead must be taken into
account, so the flag must usually be changed apparently one token too
early. Using a more powerful parsing algorithm such as GLR (*note GLR
Parsers: (bison)GLR Parsers.) adds to this problem since it may read
many tokens while the parser is split before it can perform any
semantic action (which is where the flag could be modified). Secondly,
as the example above shows, there are contexts in which both meanings
are acceptable. So further look-ahead (within the lexer) was needed to
resolve the problem.

   Therefore, the current version of GPC uses another approach. When
seeing `^X', the lexer returns two tokens, a regular `^' and a special
token `LEX_CARET_LETTER' with semantic value `X'. The parser then
accepts `LEX_CARET_LETTER' wherever an identifier is accepted (and
turns it into the identifier `X' via the nonterminal `caret_letter').
Furthermore, it accepts the sequence `^', `LEX_CARET_LETTER' as a
string constant (whose value is a one-character string). Since
`LEX_CARET_LETTER' is only produced by the lexer immediately after `^'
(no white-space in between), this works (whereas otherwise, pasting
tokens in the parser is not reliable due to white-space, e.g. the token
sequence `:' and `=' could stand for `:=' (if `:=' weren't a token by
itself), but also for `: =' with a space in between). With this trick,
we can handle `^' followed by a single letter or underscore. The fact
that this doesn't cause any conflicts in the bison parser tell us that
this method works.

   However, BP even allows any other character after `^' as a char
constant. Some characters are unproblematic because they can never
occur after a `^' in its regular meaning, so the sequence can be lexed
as a char constant directly. These are all characters that are not part
of any Pascal tokens at all (which includes all control characters
except white-space, all non-ASCII characters and the characters `!',
`&', `%', `?', `\', ``', `|', `~' and `}' - the last one occurs at the
end of comments, but within a comment this issue doesn't occur, anyway)
and those characters that can only start constants because a constant
can never follow a `^' in Pascal (which are `#', `$', `'', `"' and the
digits).

   For `^' followed by whitespace, we return the token
`LEX_CARET_WHITE' which the parser accepts as either a string constant
or equivalent to `^' (because in the regular meaning, the white-space
is meaningless).

   If `^' is followed by one of the tokens `,', `.', `:', `;', `(',
`)', `[', `]', `+', `-', `*', `/', `<', `=', `>', `@@', `^', the lexer
just returns the tokens regularly, and the parser accepts these
sequences as a char constant (besides the normal meaning of the
tokens). (Again, since white-space after `^' is already dealt with,
this token pasting works here.)

   But `^' can also be followed by a multi-character alphanumeric
sequence such as `^cto' which might be read as `^ cto' or `^c to'
(since BP also allows omitting white-space after constants), or by a
multi-character token such as `^<=' which could be `^ <=' or `^< ='.
Both could be solved with extra tokens, e.g. lexing `^<=' as `^',
`LEX_CARET_LESS', `=' and accepting `^', `LEX_CARET_LESS' in the parser
as a string constant and `LEX_CARET_LESS', `=' as equivalent to `<='
(relying on the fact that the lexer doesn't produce `LEX_CARET_LESS' if
there's white-space after the `<' because then the simple `^', `<' will
work, so justifying the token-pasting once again). This has not been
done yet (in the alphanumeric case, this might add a lot of special
tokens because of keywords etc., and it's doubtful whether that's worth
it).

   Finally, we have `^{' and `^(*'. This is so incredibly stupid (e.g.,
think of the construct `type c = Integer; foo = ^{ .. ^|; bar = {} c;'
which would become ambiguous then), that perhaps we should not attempt
to handle this ...

   (As a side-note, BP itself doesn't handle `^' character constants in
many situations, including many that GPC does handle with the
mechanisms described above, probably the clearest sign for a design
bug. But if we support them at all, we might just as well do it better
than BP ... :-)


File: gpc-es.info,  Node: Compiler directives internally,  Prev: BP character constants,  Up: Lexical analyzer

Compiler directives internally
------------------------------

   Compiler directives are mostly handled in `options.c', mostly in
common with command-line options, using the definitions in
`lang-options.h' and the tables in `gpc-options.h'.

   A special problem is that the parser sometimes has to read tokens
before they're used to decide what to do next. This is generally
harmless, but if there is a compiler directive before such a look-ahead
token, it would be handled apparently too early. This looks strange
from the programmer's point of view - even more so since the programmer
cannot easily predict when the parser needs to read ahead and when not,
and therefore cannot be sure where exactly to place the directive
(especially for local directives that are meant to have a scope as
small as possible).

   To solve this problem (and in turn give the parser more freedom for
further look ahead which is useful, e.g., for a GLR parser), GPC keeps
the options that can be changed by directives in a `struct options'.
There are several pointers to such a structure:

   `lexer_options' are the options current to the lexer. These are
always the ones read most recently. Compiler directives are applied
here when read. Each directive creates a new `struct options' which is
chained in a linked list to the previous ones.

   `compiler_options' points to the options current for the compiler,
i.e. seen before the last token handled in a parser rule.  To
facilitate this, we abuse Bison's location tracking feature (*note
Locations: (bison)Locations.) and refer to the options seen before a
token in the token's location (`yylloc'). Before each grammar rule is
handled, the compiler options are updated to those of the last token
involved in the rules handled so far, using Bison's `YYLLOC_DEFAULT'
feature. Actual locations, used for error messages etc., are handled
the same way (according to the real purpose of Bison's location
tracking), also distinct for the lexer and compiler.

   Note: Tokens are not always handled in order. E.g., in `2 + 3 * 4',
first `3 * 4' is evaluated, then `2 + 12', i.e., the tokens `2' and `+'
are handled after the following tokens.  To avoid jumping back in the
options, we store a counter, rather than a pointer, in `yyloc', so we
can compare it to the current counter. This also allows us to free any
`struct options' that `compiler_options' has advanced beyond because it
can never go back.

   Finally, the pointer `co' points to the current options which is
`lexer_options' when we're in the lexer and `compiler_options'
otherwise. All routines that use or set options refer to `co', so there
is no problem when they may be called both from the lexer and from
other parts of the compiler (e.g., `lookup_name').

   Note: Some of the options are flags declared in the backend. Since
we can't keep them in `struct option' directly, we have to copy them
back and forth in `activate_options'. This is a little annoyance, but
no real problem.


File: gpc-es.info,  Node: Language definition,  Next: Tree nodes,  Prev: Lexical analyzer,  Up: Internals

Language Definition: GPC's Parser
=================================

   The file `parse.y' contains the "bison" source code of GNU Pascal's
parser. This stage of the compilation analyzes and checks the syntax of
your Pascal program, and it generates an intermediate,
language-independent code which is then passed to the GNU back-end.

   The _bison_ language essentially is a machine-readable form of the
Backus-Naur Form, the symbolic notation of grammars of computer
languages. "Syntax diagrams" are a graphical variant of the Backus-Naur
Form.

   For details about the "bison" language, see the Bison manual. A
short overview how to pick up some information you might need for
programming follows.

   Suppose you have forgotten how a variable is declared in Pascal.
After some searching in `parse.y' you have found the following:

     simple_decl_1:
         ...
       | p_var variable_declaration_list
           { [...] }
       ;
     
     variable_declaration_list:
         variable_declaration { }
       | variable_declaration_list variable_declaration
       ;

   Translated into English, this means: "A declaration can (amoung
other things like types and constants, omitted here) consist of the
keyword (lexical token) `var' followed by a `variable declaration
list'. A `variable declaration list' in turn consists of one or more
`variable declarations'." (The latter explanation requires that you
understand the recursive nature of the definition of
`variable_declaration_list'.)

   Now we can go on and search for `variable_declaration'.

     variable_declaration:
         id_list_limited ':' type_denoter_with_attributes
           { [...] }
         absolute_or_value_specification optional_variable_directive_list ';'
           { [...] }
       ;

   The `[...]' are placeholders for some C statements, the "semantic
actions" which (for the most part) aren't important for understanding
GPC's grammar.

   From this you can look up that a variable declaration in GNU Pascal
consists of an identifier list, followed by a colon, "type denoter with
attributes", an "absolute or value specification" and an "optional
variable directive list", terminated by a semicolon.  Some of these
parts are easy to understand, the others you can look up from
`parse.y'. Remember that the reserved word `var' precedes all this.

   Now you know how to get the exact grammar of the GNU Pascal language
from the source.

   The semantic actions, not shown above, are in some sense the most
important part of the bison source, because they are responsible for
the generation of the intermediate code of the GNU Pascal front-end,
the so-called _tree nodes_ (which are used to represent most things in
the compiler). For instance, the C code in "type denoter" returns
(assigns to `$$') information about the type in a variable of type
`tree'.

   The "variable declaration" gets this and other information in the
numbered arguments (`$1' etc.) and passes it to some C functions
declared in the other source files. Generally, those functions do the
real work, while the main job of the C statements in the parser is to
call them with the right arguments.

   This, the parser, is the place where it becomes Pascal.

* Menu:

* Parsing keywords::   So many keywords, so many problems ...
* Parsing subranges::  Expressions as lower bounds of subranges


File: gpc-es.info,  Node: Parsing keywords,  Next: Parsing subranges,  Up: Language definition

So many keywords, so many problems ...
--------------------------------------

   Keywords can be potential problems since they are (generally) not
available for use as identifiers. Only those keywords that are defined
in ISO 7185 Pascal are unproblematic because no valid program should
ever use them as identifiers.

   To cope with this problem, GPC does several things:

   * If a dialect option is set, only keywords of the specified dialect
     are enabled. All possible keywords, together with their dialects,
     are defined in `predef.h'. However, compiling with dialect options
     is usually not recommended, so this is no good general solution.

   * The user can turn off individual keywords using the compiler
     directive `{$disable-keyword}'. This makes sure that every
     conflict with a user's identifier _can_ be avoided, but with extra
     work on part of the user.

   * The parser used to enable and disable keywords in certain syntactic
     contexts. However, this was rather fragile since it interacts with
     the parser's read-ahead, and it requires attention on every related
     change in the parser. Therefore, this mechanism was removed.

   * Many of the problematic keywords are now treated as "weak". This
     means, they are only recognized as keywords if no current
     declaration of this name exists. However, so that this can work, it
     must be possible to create new declarations of this name in the
     first place - at this point, no declaration exists yet, so the name
     is recognized as a keyword.

     This is solved by listing these keywords in the `new_identifier'
     rule of the parser. This means, first the lexer recognizes them as
     keywords, then the parser "turns them back" into identifiers. The
     advantage, compared to explicit enabling and disabling of
     keywords, is that bison automatically finds the places in which to
     apply the `new_identifier' rule, i.e. treat them as plain
     identifiers.

     Of course, there is a catch. Since the keyword tokens are listed in
     `new_identifier', they can conflict with occurrences of the actual
     keywords (bison will find such cases as S/R or R/R conflicts).
     Such conflicts have to be sorted out carefully.  Fortunately, for
     many keywords, this turned out quite easy - in some cases no
     conflicts at all arose. One especially complicated example is
     explained below in detail. If it is not possible to solve the
     conflicts for a particular keyword, this keyword cannot be handled
     this way.

   The following sections describe the most problematic keywords:

* Menu:

* attribute as a weak keyword::
* external as a weak keyword::
* forward near far::
* implementation constructor destructor operator uses import initialization::

   These descriptions should make it clear that we're walking on the
bleeding edge of what's possible with LALR(1) and lexer tricks.  Trying
much more will probably increase the complexity to the unmanageable.


File: gpc-es.info,  Node: attribute as a weak keyword,  Next: external as a weak keyword,  Up: Parsing keywords

`attribute' as a weak keyword
.............................

   Note that in the following we use the spelling `attribute' when
referring to the directive and `Attribute' for an identifier.  This is
according to the GPCS and might make the following text clearer.
However, it cannot be a criterion for resolving the conflict since the
compiler must treat both spellings equally. The same applies, of
course, to the line-breaks and white-space used here for readability.

   Making `attribute' a weak keyword leads to a S/R conflict in
variable declarations (whereas routine declarations go without
conflicts). Consider this case:

     var
       a: Integer; attribute (...)

   vs.

     var
       a: Integer;
       Attribute: ...

   After reading the `;', the parser must decide whether to shift it,
or to reduce to a variable declaration. But the next token `attribute'
doesn't decide it, and bison can only look ahead one token.

   The following token would resolve the problem, since the directive
`attribute' is always followed by `(' whereas an identifier in a
variable declaration can be followed by `,' or `:', but never `('.

   More generally, an identifier in an `id_list' in the parser can
never be followed by `(' (while identifiers in other contexts can be,
e.g. in function calls). This must be carefully checked manually
through the whole grammar!

   Thus, the solution consists of two steps. Firstly, the _lexer_ does
the additional look-ahead that bison can't do. When it reads the word
`attribute' (and it is not disabled by dialect options or by the user
or shadowed by some declaration), then if the next token is not `(', it
can only be an identifier, so the lexer returns `LEX_ID'. If the next
token is `(', the lexer returns `p_attribute'.

   Lexer look-ahead is not really nice, either, e.g. because it
increases the "shift" of compiler directives. At least, we only have to
read ahead two characters plus preceding white-space (two because of
`(.'), and not an actual token - the latter would add additiional
complications of saving and restoring lexer semantic values and the
state of lexer/parser interrelation variables such as
`lex_const_equal', and then either lex the token again later or handle
the cases where the parser modifies these variables in between. This
would get really messy.

   Secondly, the parser accepts `p_attribute' as an identifier _except_
in an `id_list'. To achieve this, the nonterminal
`new_identifier_limited' is used within `id_list'.

   _Note:_ Using `new_identifier_limited' does _not_ mean that
`Attribute' can't be used as an identifier in this place. Instead, this
nonterminal can never be followed by `(', so the lexer will have turned
`Attribute' into a `LEX_ID' token already.

   Actually, that's not all: In a `constant_definition', the conflict
is not against `id_list', but against a simple `new_identifier'. But we
can just use `new_identifier_limited' instead in the
`constant_definition' rule.

   This finally solves all conflicts with `attribute'.  `fjf792*.pas'
are test programs for these cases.


File: gpc-es.info,  Node: external as a weak keyword,  Next: forward near far,  Prev: attribute as a weak keyword,  Up: Parsing keywords

`external' as a weak keyword
............................

   The situation about `external' is similar to `attribute'.  However,
on the positive side, we don't have to worry about constants which
cannot be external - by definition, since initialization and external
declaration contradict each other.

   The new problems are that an `external' directive can be followed by
`;', `name' and by many more tokens if GPC will support a BP compatible
`external LIBNAME' where LIBNAME can be a string constant expression.

   So we have to consider the problem from the other side. In an
`id_list' of a variable declaration (which is the only conflict, given
the notes about attribute, *Note attribute as a weak keyword::.), an
identifier can be followed only by `,' and `:'. These two tokens cannot
follow an `external' directive (not even in `external LIBNAME').

   However, in other contexts, identifiers can be followed by other
tokens (even in an `id_list', e.g. `procedure Foo (var External; i:
Integer);'), so we accept `p_external' as a `new_identifier' everywhere
except in variable declarations (`new_identifier_limited'
`id_list_limited').

   `fjf793*.pas' are test programs for `external'.

   (Basically the same applies to the deprecated `asmname'.)


File: gpc-es.info,  Node: forward near far,  Next: implementation constructor destructor operator uses import initialization,  Prev: external as a weak keyword,  Up: Parsing keywords

`forward', `near' and `far' as weak keywords
............................................

   `forward' is a little special in ISO 7185 in that it is no keyword,
so it may be used as an identifier and a directive at the same time.
That's more than what our weak keywords allow.

   This problem would be easy to solve if we just parsed it as a plain
identifier (`LEX_ID') and then check that it was in fact `forward'.

   However, the same applies to the BP directives `near' and `far'. (At
least so it seems - the BP documentation claims they're reserved words,
but the compiler seems to think otherwise.)

   Parsing all the three together as an identifier and then checking
which one it was fails because `forward' is a remote directive, i.e. a
routine declared so has no body, while `near' and `far' are not. So it
makes a syntactical difference for what follows.

   So we need a new trick: We lex the three like regular (non-weak)
keywords, but throw their tokens together with `LEX_ID' very early in
the parser, in the `id' rule which is used everywhere an existing
identifier is expected. But in the context of these three directives,
no identifier is allowed, so the three tokens can be used without
conflicts between each other or with `id'.

@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Import an alpha version of GNU Pascal Compiler into the tree
(not to be connected to the build before the upgrade to gcc 3.3).

We couldn't use gpc 2.1 because it's too old and doesn't support
gcc 3.x at all.
@
text
@@
