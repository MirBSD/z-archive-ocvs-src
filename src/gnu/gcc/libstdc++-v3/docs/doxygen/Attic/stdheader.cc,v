head	1.2;
access;
symbols
	gcc-3_2_3:1.1.2.1 FSF:1.1.2;
locks; strict;
comment	@// @;


1.2
date	2003.11.04.17.23.47;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.10.27.19.29.51;	author tg;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.10.27.19.29.51;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Yours sincerely, licence auditor, strikes again.


Remove stuff under the so-called "GNU Free Documentation License".

You are actually even breaching the licence when you are
storing GFDL-licenced documents on an encrypted filesystem,
or "even  storing  it  on  a  file-sharing  system  with
non-world-readable permissions", according to the information
found at http://home.twcny.rr.com/nerode/neroden/fdl.html
via Slashdot.

I am thinking whether to adopt the (amended) Debian Social
Contract, and either the DFSG or the OSD (or both) for MirOS.
(see the /. story)

src/gnu/libstdc++:

| The Docs: FDL
|
|    The documentation shipped with the library and made available over the
|    web,   including   the  pages  generated  from  source  comments,  are
|    copyrighted  by  the  Free  Software  Foundation, and placed under the
|    [3]GNU   Free   Documentation   License  version  1.1.  There  are  no
|    Front-Cover Texts, no Back-Cover Texts, and no Invariant Sections.

Of course this doesn't apply to documentation for libstdc++ generated by
ourselfes from GPL'd or LGPL'd files, because the GFDL is incompatible
with both of them.


Hint: if you can dig out older versions of the GNU tools man pages, such
as gcc 3.0 and binutils 2.12/2.13 (for example), which are not yet GFDL
licenced, please give me a hint (I'm not actively searching myself now)
or mail them to me, and be sure I'll commit them, together with a warning
about inactuality.
@
text
@// This is a slow larval-stage kludge to help massage the generated man
// pages.  It's used like this:
const char* const usage = 
"\nTakes on stdin, whitespace-separated words of the form\n"
"\n"
"    [bits/]stl_foo.h\n"
"    [bits/]std_foo.h\n"
"\n"
"and writes on stdout the nearest matching standard header name.\n"
"\n"
"Takes no command-line arguments.\n"
"\n";

#include <string>
#include <map>
#include <iostream>

typedef std::map<std::string, std::string>   Map;

Map  headers;

void init_map()
{
    // Enter the glamourous world of data entry!!  Maintain these!
    headers["algo.h"]                   = "algorithm";
    headers["algobase.h"]               = "algorithm";
    headers["algorithm.h"]              = "algorithm";
    headers["alloc.h"]                  = "memory";
    headers["basic_ios.h"]              = "ios";
    headers["basic_ios.tcc"]            = "ios";
    headers["basic_string.h"]           = "string";
    headers["basic_string.tcc"]         = "string";
    headers["bitset.h"]                 = "bitset";
    headers["bvector.h"]                = "vector";
    //headers["char_traits.h"]            uhhhhhh
    headers["complex.h"]                = "complex";
    //headers["construct.h"]              stl_construct.h entirely internal
    headers["deque.h"]                  = "deque";
    headers["fstream.h"]                = "fstream";
    headers["fstream.tcc"]              = "fstream";
    headers["function.h"]               = "functional";
    headers["functional.h"]             = "functional";
    headers["heap.h"]                   = "algorithm";
    headers["iomanip.h"]                = "iomanip";
    headers["ios.h"]                    = "ios";
    headers["iosfwd.h"]                 = "iosfwd";
    headers["iostream.h"]               = "iostream";
    headers["istream.h"]                = "istream";
    headers["istream.tcc"]              = "istream";
    headers["iterator.h"]               = "iterator";
    headers["iterator_base_funcs.h"]    = "iterator";
    headers["iterator_base_types.h"]    = "iterator";
    headers["limits.h"]                 = "limits";
    headers["list.h"]                   = "list";
    headers["locale.h"]                 = "locale";
    headers["locale_facets.h"]          = "locale";
    headers["locale_facets.tcc"]        = "locale";
    headers["map.h"]                    = "map";
    headers["memory.h"]                 = "memory";
    headers["multimap.h"]               = "map";
    headers["multiset.h"]               = "set";
    headers["numeric.h"]                = "numeric";
    headers["ostream.h"]                = "ostream";
    headers["ostream.tcc"]              = "ostream";
    headers["pair.h"]                   = "utility";
    //headers["pthread_alloc.h"]          who knows
    headers["queue.h"]                  = "queue";
    headers["raw_storage_iter.h"]       = "memory";
    headers["relops.h"]                 = "utility";
    headers["set.h"]                    = "set";
    headers["sstream.h"]                = "sstream";
    headers["sstream.tcc"]              = "sstream";
    headers["stack.h"]                  = "stack";
    headers["stdexcept.h"]              = "stdexcept";
    headers["streambuf.h"]              = "streambuf";
    headers["streambuf.tcc"]            = "streambuf";
    headers["string.h"]                 = "string";
    headers["tempbuf.h"]                = "memory";
    //headers["threads.h"]                who knows
    headers["tree.h"]                   = "backward/tree.h";
    headers["uninitialized.h"]          = "memory";
    headers["utility.h"]                = "utility";
    headers["valarray.h"]               = "valarray";
    headers["valarray_array.h"]         = "valarray";
    headers["valarray_array.tcc"]       = "valarray";
    headers["valarray_meta.h"]          = "valarray";
    headers["vector.h"]                 = "vector";

    // C wrappers -- probably was an easier way to do these, but oh well
    headers["cassert.h"]                = "cassert";
    headers["cctype.h"]                 = "cctype";
    headers["cerrno.h"]                 = "cerrno";
    headers["cfloat.h"]                 = "cfloat";
    headers["climits.h"]                = "climits";
    headers["clocale.h"]                = "clocale";
    headers["cmath.h"]                  = "cmath";
    headers["csetjmp.h"]                = "csetjmp";
    headers["csignal.h"]                = "csignal";
    headers["cstdarg.h"]                = "cstdarg";
    headers["cstddef.h"]                = "cstddef";
    headers["cstdio.h"]                 = "cstdio";
    headers["cstdlib.h"]                = "cstdlib";
    headers["cstring.h"]                = "cstring";
    headers["ctime.h"]                  = "ctime";
    headers["cwchar.h"]                 = "cwchar";
    headers["cwctype.h"]                = "cwctype";
}


void do_word (std::string const& longheader)
{
    std::string::size_type start = 0;

    // if it doesn't contain a "." then it's already a std header
    if (longheader.find(".") == std::string::npos)
    {
        std::cout << longheader << '\n';
        return;
    }

    if (longheader.substr(start,5) == "bits/")  start += 5;
    if ((longheader.substr(start,4) == "stl_") ||
        (longheader.substr(start,4) == "std_"))
    {
        start += 4;
    }

    // come on, gdb, find `p' already...
    const char* p = longheader.substr(start).c_str();
    Map::iterator word = headers.find(p);
    if (word != headers.end())
        std::cout << word->second << '\n';
    else std::cout << "MAYBE_AN_ERROR_MESSAGE_HERE\n";
}


int main (int argc, char**)
{
    if (argc > 1)
    {
        std::cerr << usage;
        exit(0);
    }

    init_map();

    std::string w;
    while (std::cin >> w)
        do_word (w);
}

// vim:ts=4:et:

@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@tg@@odem:/home/tg $ bzip2 -dc /data/gcc-3.2.3.tar.bz2 | tar xf -
tg@@odem:/home/tg $ cd gcc-3.2.3/
tg@@odem:/home/tg/gcc-3.2.3 $ find . -name .cvsignore | xargs rm
tg@@odem:/home/tg/gcc-3.2.3 $ rm -rf libjava gcc/java
tg@@odem:/home/tg/gcc-3.2.3 $ rm -rf boehm-gc fastjar libffi libiberty zlib
tg@@odem:/home/tg/gcc-3.2.3 $ cvs -qz6 -d tg@@herc:/cvs import -I ! -I CVS -b 1.1.2 src/gnu/gcc FSF gcc-3_2_3

We'll try it again. Not gcc 3.3 this time.
@
text
@@
