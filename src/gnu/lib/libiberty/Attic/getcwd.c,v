head	1.2;
access;
symbols
	MIRBSD_7quater:1.1.2.1
	MIRBSD_7_ALPHA:1.1.2.1.0.6
	MIRBSD_7:1.1.2.1.0.4
	MIRBSD_7ter:1.1.2.1
	MIRBSD_7_DEV:1.1.2.1.0.2
	binutils_2_14:1.1.2.1
	FSF:1.1.2;
locks; strict;
comment	@ * @;


1.2
date	2004.08.09.19.35.23;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.09.23.15.13.24;	author tg;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.09.23.15.13.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update; new location; new shlib version (2.0)
old hash table functions are now "in"
@
text
@/* Emulate getcwd using getwd.
   This function is in the public domain. */

/*

@@deftypefn Supplemental char* getcwd (char *@@var{pathname}, int @@var{len})

Copy the absolute pathname for the current working directory into
@@var{pathname}, which is assumed to point to a buffer of at least
@@var{len} bytes, and return a pointer to the buffer.  If the current
directory's path doesn't fit in @@var{len} characters, the result is
@@code{NULL} and @@code{errno} is set.  If @@var{pathname} is a null pointer,
@@code{getcwd} will obtain @@var{len} bytes of space using
@@code{malloc}.

@@end deftypefn

*/

#include "config.h"

#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#include <errno.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

extern char *getwd ();
extern int errno;

#ifndef MAXPATHLEN
#define MAXPATHLEN 1024
#endif

char *
getcwd (buf, len)
  char *buf;
  size_t len;
{
  char ourbuf[MAXPATHLEN];
  char *result;

  result = getwd (ourbuf);
  if (result) {
    if (strlen (ourbuf) >= len) {
      errno = ERANGE;
      return 0;
    }
    if (!buf) {
       buf = (char*)malloc(len);
       if (!buf) {
           errno = ENOMEM;
	   return 0;
       }
    }
    strcpy (buf, ourbuf);
  }
  return buf;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Import GNU libiberty (LGPL licenced) from the FSF binutils 2.14 sources
via the vendor branch (to ease future updating)
@
text
@@
