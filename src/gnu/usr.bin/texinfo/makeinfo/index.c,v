head	1.3;
access;
symbols
	texinfo-4_8:1.1.2.2
	tg-mergetmp-mirosx-1:1.3
	tg-mergefixes-1-branch:1.3.0.8
	tg-mergefixes-1-base:1.3
	MIROS_X:1.3.0.6
	MIROS_X_BASE:1.3
	MIRBSD_XP_MIRPPC:1.3.0.4
	texinfo-4_7:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	testing_SYNC_A:1.3
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.08.17.29.23;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.08.08.17.26.07;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.44.18;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.44.18;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2004.10.16.23.10.07;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.01.06.23.37.23;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@switch to texinfo 4.7 based system
@
text
@/* index.c -- indexing for Texinfo.
   $Id: index.c,v 1.1.2.1 2004/08/08 16:18:01 tg Exp $

   Copyright (C) 1998, 1999, 2002, 2003, 2004 Free Software Foundation,
   Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "system.h"
#include "files.h"
#include "footnote.h"
#include "html.h"
#include "index.h"
#include "lang.h"
#include "macro.h"
#include "sectioning.h"
#include "toc.h"
#include "xml.h"

INDEX_ALIST **name_index_alist = NULL;

/* An array of pointers.  Each one is for a different index.  The
   "synindex" command changes which array slot is pointed to by a
   given "index". */
INDEX_ELT **the_indices = NULL;

/* The number of defined indices. */
int defined_indices = 0;

/* This is the order of the index.  */
int index_counter = 0;

/* Stuff for defining commands on the fly. */
COMMAND **user_command_array = NULL;
int user_command_array_len = 0;

/* How to compare index entries for sorting.  May be set to strcoll.  */
int (*index_compare_fn) (const char *a, const char *b) = strcasecmp;

/* Function to compare index entries for sorting.  (Calls
   `index_compare_fn' above.)  */
int index_element_compare (const void *element1, const void *element2);

/* Find which element in the known list of indices has this name.
   Returns -1 if NAME isn't found. */
static int
find_index_offset (char *name)
{
  int i;
  for (i = 0; i < defined_indices; i++)
    if (name_index_alist[i] && STREQ (name, name_index_alist[i]->name))
      return i;
  return -1;
}

/* Return a pointer to the entry of (name . index) for this name.
   Return NULL if the index doesn't exist. */
static INDEX_ALIST *
find_index (char *name)
{
  int offset = find_index_offset (name);
  if (offset > -1)
    return name_index_alist[offset];
  else
    return NULL;
}

/* User-defined commands, which happens only from user-defined indexes.
   Used to initialize the builtin indices, too.  */
static void
define_user_command (char *name, COMMAND_FUNCTION (*proc), int needs_braces_p)
{
  int slot = user_command_array_len;
  user_command_array_len++;

  if (!user_command_array)
    user_command_array = xmalloc (1 * sizeof (COMMAND *));

  user_command_array = xrealloc (user_command_array,
                            (1 + user_command_array_len) * sizeof (COMMAND *));

  user_command_array[slot] = xmalloc (sizeof (COMMAND));
  user_command_array[slot]->name = xstrdup (name);
  user_command_array[slot]->proc = proc;
  user_command_array[slot]->argument_in_braces = needs_braces_p;
}

/* Please release me, let me go... */
static void
free_index (INDEX_ELT *index)
{
  INDEX_ELT *temp;

  while ((temp = index))
    {
      free (temp->entry);
      free (temp->entry_text);
      /* Do not free the node, because we already freed the tag table,
         which freed all the node names.  */
      /* free (temp->node); */
      index = index->next;
      free (temp);
    }
}

/* Flush an index by name.  This will delete the list of entries that
   would be written by a @@printindex command for this index. */
static void
undefindex (char *name)
{
  int i;
  int which = find_index_offset (name);

  /* The index might have already been freed if this was the target of
     an @@synindex.  */
  if (which < 0 || !name_index_alist[which])
    return;

  i = name_index_alist[which]->read_index;

  free_index (the_indices[i]);
  the_indices[i] = NULL;

  free (name_index_alist[which]->name);
  free (name_index_alist[which]);
  name_index_alist[which] = NULL;
}

/* Add the arguments to the current index command to the index NAME.  */
static void
index_add_arg (char *name)
{
  int which;
  char *index_entry;
  INDEX_ALIST *tem;

  tem = find_index (name);

  which = tem ? tem->write_index : -1;

  if (macro_expansion_output_stream && !executing_string)
    append_to_expansion_output (input_text_offset + 1);

  get_rest_of_line (0, &index_entry);
  ignore_blank_line ();

  if (macro_expansion_output_stream && !executing_string)
    {
      char *index_line = xmalloc (strlen (index_entry) + 2);
      sprintf (index_line, "%s\n", index_entry);
      me_execute_string_keep_state (index_line, NULL);
      free (index_line);
    }

  if (which < 0)
    {
      line_error (_("Unknown index `%s'"), name);
      free (index_entry);
    }
  else
    {
      INDEX_ELT *new = xmalloc (sizeof (INDEX_ELT));

      index_counter++;

      /* Get output line number updated before doing anything.  */
      if (!html && !xml)
        flush_output ();

      new->next = the_indices[which];
      new->entry_text = index_entry;
      new->entry = NULL;
      /* Since footnotes are handled at the very end of the document,
         node name in the non-split HTML outputs always show the last
         node.  We artificially make it ``Footnotes''.  */
      if (html && !splitting && already_outputting_pending_notes)
        new->node = xstrdup (_("Footnotes"));
      else
        new->node = current_node ? current_node : xstrdup ("");
      if (!html && !xml && no_headers)
        {
          new->section = current_sectioning_number ();
          if (strlen (new->section) == 0)
            new->section_name = current_sectioning_name ();
          else
            new->section_name = "";
        }
      new->code = tem->code;
      new->defining_line = line_number - 1;
      new->output_line = no_headers ? output_line_number : node_line_number;
      /* We need to make a copy since input_filename may point to
         something that goes away, for example, inside a macro.
         (see the findexerr test).  */
      new->defining_file = xstrdup (input_filename);
      the_indices[which] = new;

      new->entry_number = index_counter;

      if (html && splitting)
        {
          if (current_output_filename && *current_output_filename)
            new->output_file = filename_part (current_output_filename);
          else
            new->output_file = xstrdup ("");
        }

#if 0
      /* The index breaks if there are colons in the entry.
         -- This is true, but it's too painful to force changing index
         entries to use `colon', and too confusing for users.  The real
         fix is to change Info support to support arbitrary characters
         in node names, and we're not ready to do that.  --karl,
         19mar02.  */
      if (strchr (new->entry_text, ':'))
        warning (_("Info cannot handle `:' in index entry `%s'"),
                 new->entry_text);
#endif

      if (html)
        {
          /* Anchor.  */
          int removed_empty_elt = 0;

          /* We must put the anchor outside the <dl> and <ul> blocks.  */
          if (rollback_empty_tag ("dl"))
            removed_empty_elt = 1;
          else if (rollback_empty_tag ("ul"))
            removed_empty_elt = 2;

          add_word ("<a name=\"index-");
          add_escaped_anchor_name (index_entry);
          add_word_args ("-%d\"></a>", index_counter);

          if (removed_empty_elt == 1)
            add_html_block_elt_args ("\n<dl>");
          else if (removed_empty_elt == 2)
            add_html_block_elt_args ("\n<ul>");
        }
    }

  if (xml)
    xml_insert_indexterm (index_entry, name);
}

/* The function which user defined index commands call. */
static void
gen_index (void)
{
  char *name = xstrdup (command);
  if (strlen (name) >= strlen ("index"))
    name[strlen (name) - strlen ("index")] = 0;
  index_add_arg (name);
  free (name);
}

/* Define an index known as NAME.  We assign the slot number.
   If CODE is nonzero, make this a code index. */
static void
defindex (char *name, int code)
{
  int i, slot;

  /* If it already exists, flush it. */
  undefindex (name);

  /* Try to find an empty slot. */
  slot = -1;
  for (i = 0; i < defined_indices; i++)
    if (!name_index_alist[i])
      {
        slot = i;
        break;
      }

  if (slot < 0)
    { /* No such luck.  Make space for another index. */
      slot = defined_indices;
      defined_indices++;

      name_index_alist = (INDEX_ALIST **)
        xrealloc (name_index_alist, (1 + defined_indices)
                                    * sizeof (INDEX_ALIST *));
      the_indices = (INDEX_ELT **)
        xrealloc (the_indices, (1 + defined_indices) * sizeof (INDEX_ELT *));
    }

  /* We have a slot.  Start assigning. */
  name_index_alist[slot] = xmalloc (sizeof (INDEX_ALIST));
  name_index_alist[slot]->name = xstrdup (name);
  name_index_alist[slot]->read_index = slot;
  name_index_alist[slot]->write_index = slot;
  name_index_alist[slot]->code = code;

  the_indices[slot] = NULL;
}

/* Define an index NAME, implicitly @@code if CODE is nonzero.  */
static void
top_defindex (char *name, int code)
{
  char *temp;

  temp = xmalloc (1 + strlen (name) + strlen ("index"));
  sprintf (temp, "%sindex", name);
  define_user_command (temp, gen_index, 0);
  defindex (name, code);
  free (temp);
}

/* Set up predefined indices.  */
void
init_indices (void)
{
  int i;

  /* Create the default data structures. */

  /* Initialize data space. */
  if (!the_indices)
    {
      the_indices = xmalloc ((1 + defined_indices) * sizeof (INDEX_ELT *));
      the_indices[defined_indices] = NULL;

      name_index_alist = xmalloc ((1 + defined_indices)
                                  * sizeof (INDEX_ALIST *));
      name_index_alist[defined_indices] = NULL;
    }

  /* If there were existing indices, get rid of them now. */
  for (i = 0; i < defined_indices; i++)
    {
      if (name_index_alist[i])
        { /* Suppose we're called with two input files, and the first
             does a @@synindex pg cp.  Then, when we get here to start
             the second file, the "pg" element won't get freed by
             undefindex (because it's pointing to "cp").  So free it
             here; otherwise, when we try to define the pg index again
             just below, it will still point to cp.  */
          undefindex (name_index_alist[i]->name);

          /* undefindex sets all this to null in some cases.  */
          if (name_index_alist[i])
            {
              free (name_index_alist[i]->name);
              free (name_index_alist[i]);
              name_index_alist[i] = NULL;
            }
        }
    }

  /* Add the default indices. */
  top_defindex ("cp", 0);           /* cp is the only non-code index.  */
  top_defindex ("fn", 1);
  top_defindex ("ky", 1);
  top_defindex ("pg", 1);
  top_defindex ("tp", 1);
  top_defindex ("vr", 1);
}

/* Given an index name, return the offset in the_indices of this index,
   or -1 if there is no such index. */
static int
translate_index (char *name)
{
  INDEX_ALIST *which = find_index (name);

  if (which)
    return which->read_index;
  else
    return -1;
}

/* Return the index list which belongs to NAME. */
INDEX_ELT *
index_list (char *name)
{
  int which = translate_index (name);
  if (which < 0)
    return (INDEX_ELT *) -1;
  else
    return the_indices[which];
}

/* Define a new index command.  Arg is name of index. */
static void
gen_defindex (int code)
{
  char *name;
  get_rest_of_line (0, &name);

  if (find_index (name))
    {
      line_error (_("Index `%s' already exists"), name);
    }
  else
    {
      char *temp = xmalloc (strlen (name) + sizeof ("index"));
      sprintf (temp, "%sindex", name);
      define_user_command (temp, gen_index, 0);
      defindex (name, code);
      free (temp);
    }

  free (name);
}

void
cm_defindex (void)
{
  gen_defindex (0);
}

void
cm_defcodeindex (void)
{
  gen_defindex (1);
}

/* Expects 2 args, on the same line.  Both are index abbreviations.
   Make the first one be a synonym for the second one, i.e. make the
   first one have the same index as the second one. */
void
cm_synindex (void)
{
  int source, target;
  char *abbrev1, *abbrev2;

  skip_whitespace ();
  get_until_in_line (0, " ", &abbrev1);
  target = find_index_offset (abbrev1);
  skip_whitespace ();
  get_until_in_line (0, " ", &abbrev2);
  source = find_index_offset (abbrev2);
  if (source < 0 || target < 0)
    {
      line_error (_("Unknown index `%s' and/or `%s' in @@synindex"),
                  abbrev1, abbrev2);
    }
  else
    {
      if (xml && !docbook)
        xml_synindex (abbrev1, abbrev2);
      else
        name_index_alist[target]->write_index
          = name_index_alist[source]->write_index;
    }

  free (abbrev1);
  free (abbrev2);
}

void
cm_pindex (void)                    /* Pinhead index. */
{
  index_add_arg ("pg");
}

void
cm_vindex (void)                    /* Variable index. */
{
  index_add_arg ("vr");
}

void
cm_kindex (void)                    /* Key index. */
{
  index_add_arg ("ky");
}

void
cm_cindex (void)                    /* Concept index. */
{
  index_add_arg ("cp");
}

void
cm_findex (void)                    /* Function index. */
{
  index_add_arg ("fn");
}

void
cm_tindex (void)                    /* Data Type index. */
{
  index_add_arg ("tp");
}

int
index_element_compare (const void *element1, const void *element2)
{
  INDEX_ELT **elt1 = (INDEX_ELT **) element1;
  INDEX_ELT **elt2 = (INDEX_ELT **) element2;

  return index_compare_fn ((*elt1)->entry, (*elt2)->entry);
}

/* Force all index entries to be unique. */
static void
make_index_entries_unique (INDEX_ELT **array, int count)
{
  int i, j;
  INDEX_ELT **copy;
  int counter = 1;

  copy = xmalloc ((1 + count) * sizeof (INDEX_ELT *));

  for (i = 0, j = 0; i < count; i++)
    {
      if (i == (count - 1)
          || array[i]->node != array[i + 1]->node
          || !STREQ (array[i]->entry, array[i + 1]->entry))
        copy[j++] = array[i];
      else
        {
          free (array[i]->entry);
          free (array[i]->entry_text);
          free (array[i]);
        }
    }
  copy[j] = NULL;

  /* Now COPY contains only unique entries.  Duplicated entries in the
     original array have been freed.  Replace the current array with
     the copy, fixing the NEXT pointers. */
  for (i = 0; copy[i]; i++)
    {
      copy[i]->next = copy[i + 1];

      /* Fix entry names which are the same.  They point to different nodes,
         so we make the entry name unique. */
      if (copy[i+1]
          && STREQ (copy[i]->entry, copy[i + 1]->entry)
          && !html)
        {
          char *new_entry_name;

          new_entry_name = xmalloc (10 + strlen (copy[i]->entry));
          sprintf (new_entry_name, "%s <%d>", copy[i]->entry, counter);
          free (copy[i]->entry);
          copy[i]->entry = new_entry_name;
          counter++;
        }
      else
        counter = 1;

      array[i] = copy[i];
    }
  array[i] = NULL;

  /* Free the storage used only by COPY. */
  free (copy);
}


/* Sort the index passed in INDEX, returning an array of pointers to
   elements.  The array is terminated with a NULL pointer.  */

static INDEX_ELT **
sort_index (INDEX_ELT *index)
{
  INDEX_ELT **array;
  INDEX_ELT *temp;
  int count = 0;
  int save_line_number = line_number;
  char *save_input_filename = input_filename;
  int save_html = html;

  /* Pretend we are in non-HTML mode, for the purpose of getting the
     expanded index entry that lacks any markup and other HTML escape
     characters which could produce a wrong sort order.  */
  /* fixme: html: this still causes some markup, such as non-ASCII
     characters @@AE{} etc., to sort incorrectly.  */
  html = 0;

  for (temp = index, count = 0; temp; temp = temp->next, count++)
    ;
  /* We have the length, now we can allocate an array. */
  array = xmalloc ((count + 1) * sizeof (INDEX_ELT *));

  for (temp = index, count = 0; temp; temp = temp->next, count++)
    {
      /* Allocate new memory for the return array, since parts of the
         original INDEX get freed.  Otherwise, if the document calls
         @@printindex twice on the same index, with duplicate entries,
         we'll have garbage the second time.  There are cleaner ways to
         deal, but this will suffice for now.  */
      array[count] = xmalloc (sizeof (INDEX_ELT));
      *(array[count]) = *(temp);  /* struct assignment, hope it's ok */

      /* Adjust next pointers to use the new memory.  */
      if (count > 0)
        array[count-1]->next = array[count];

      /* Set line number and input filename to the source line for this
         index entry, as this expansion finds any errors.  */
      line_number = array[count]->defining_line;
      input_filename = array[count]->defining_file;

      /* If this particular entry should be printed as a "code" index,
         then expand it as @@code{entry}, i.e., as in fixed-width font.  */
      array[count]->entry = expansion (temp->entry_text, array[count]->code);
    }
  array[count] = NULL;    /* terminate the array. */

  line_number = save_line_number;
  input_filename = save_input_filename;
  html = save_html;

#ifdef HAVE_STRCOLL
  /* This is not perfect.  We should set (then restore) the locale to the
     documentlanguage, so strcoll operates according to the document's
     locale, not the user's.  For now, I'm just going to assume that
     those few new documents which use @@documentlanguage will be
     processed in the appropriate locale.  In any case, don't use
     strcoll in the C (aka POSIX) locale, that is the ASCII ordering.  */
  if (language_code != en)
    {
      char *lang_env = getenv ("LANG");
      if (lang_env && !STREQ (lang_env, "C") && !STREQ (lang_env, "POSIX"))
        index_compare_fn = strcoll;
    }
#endif /* HAVE_STRCOLL */

  /* Sort the array. */
  qsort (array, count, sizeof (INDEX_ELT *), index_element_compare);

  /* Remove duplicate entries.  */
  make_index_entries_unique (array, count);

  /* Replace the original index with the sorted one, in case the
     document wants to print it again.  If the index wasn't empty.  */
  if (index)
    *index = **array;

  return array;
}

static void
insert_index_output_line_no (int line_number, int output_line_number_len)
{
  int last_column;
  int str_size = output_line_number_len + strlen (_("(line )"))
    + sizeof (NULL);
  char *out_line_no_str = (char *) xmalloc (str_size + 1);

  /* Do not translate ``(line NNN)'' below for !no_headers case (Info output),
     because it's something like the ``* Menu'' strings.  For plaintext output
     it should be translated though.  */
  sprintf (out_line_no_str,
      no_headers ? _("(line %*d)") : "(line %*d)",
      output_line_number_len, line_number);

  {
    int i = output_paragraph_offset; 
    while (0 < i && output_paragraph[i-1] != '\n')
      i--;
    last_column = output_paragraph_offset - i;
  }

  if (last_column + strlen (out_line_no_str) > fill_column)
    {
      insert ('\n');
      last_column = 0;
    }

  while (last_column + strlen (out_line_no_str) < fill_column)
    {
      insert (' ');
      last_column++;
    }

  insert_string (out_line_no_str);
  insert ('\n');

  free (out_line_no_str);
}

/* Nonzero means that we are in the middle of printing an index. */
int printing_index = 0;

/* Takes one arg, a short name of an index to print.
   Outputs a menu of the sorted elements of the index. */
void
cm_printindex (void)
{
  char *index_name;
  get_rest_of_line (0, &index_name);

  /* get_rest_of_line increments the line number by one,
     so to make warnings/errors point to the correct line,
     we decrement the line_number again.  */
  if (!handling_delayed_writes)
    line_number--;

  if (xml && !docbook)
    {
      xml_insert_element (PRINTINDEX, START);
      insert_string (index_name);
      xml_insert_element (PRINTINDEX, END);
    }
  else if (!handling_delayed_writes)
    {
      int command_len = sizeof ("@@ ") + strlen (command) + strlen (index_name);
      char *index_command = xmalloc (command_len + 1);

      close_paragraph ();
      if (docbook)
        xml_begin_index ();

      sprintf (index_command, "@@%s %s", command, index_name);
      register_delayed_write (index_command);
      free (index_command);
    }
  else
    {
      int item;
      INDEX_ELT *index;
      INDEX_ELT *last_index = 0;
      INDEX_ELT **array;
      unsigned line_length;
      char *line;
      int saved_inhibit_paragraph_indentation = inhibit_paragraph_indentation;
      int saved_filling_enabled = filling_enabled;
      int saved_line_number = line_number;
      char *saved_input_filename = input_filename;
      unsigned output_line_number_len;

      index = index_list (index_name);
      if (index == (INDEX_ELT *)-1)
        {
          line_error (_("Unknown index `%s' in @@printindex"), index_name);
          free (index_name);
          return;
        }

      /* Do this before sorting, so execute_string is in the good environment */
      if (xml && docbook)
        xml_begin_index ();

      /* Do this before sorting, so execute_string in index_element_compare
         will give the same results as when we actually print.  */
      printing_index = 1;
      filling_enabled = 0;
      inhibit_paragraph_indentation = 1;
      xml_sort_index = 1;
      array = sort_index (index);
      xml_sort_index = 0;
      close_paragraph ();
      if (html)
        add_html_block_elt_args ("<ul class=\"index-%s\" compact>",
                                 index_name);
      else if (!no_headers && !docbook)
        { /* Info.  Add magic cookie for info readers (to treat this
             menu differently), and the usual start-of-menu.  */
          add_char ('\0');
          add_word ("\010[index");
          add_char ('\0');
          add_word ("\010]\n");
          add_word ("* Menu:\n\n");
        }

      me_inhibit_expansion++;

      /* This will probably be enough.  */
      line_length = 100;
      line = xmalloc (line_length);

      {
        char *max_output_line_number = (char *) xmalloc (25 * sizeof (char));

        if (no_headers)
          sprintf (max_output_line_number, "%d", output_line_number);
        else
          {
            INDEX_ELT *tmp_entry = index;
            unsigned tmp = 0;
            for (tmp_entry = index; tmp_entry; tmp_entry = tmp_entry->next)
              tmp = tmp_entry->output_line > tmp ? tmp_entry->output_line : tmp;
            sprintf (max_output_line_number, "%d", tmp);
          }

        output_line_number_len = strlen (max_output_line_number);
        free (max_output_line_number);
      }

      for (item = 0; (index = array[item]); item++)
        {
          /* A pathological document might have an index entry outside of any
             node.  Don't crash; try using the section name instead.  */
          char *index_node = index->node;

          line_number = index->defining_line;
          input_filename = index->defining_file;

          if ((!index_node || !*index_node) && html)
            index_node = toc_find_section_of_node (index_node);

          if (!index_node || !*index_node)
            {
              line_error (_("Entry for index `%s' outside of any node"),
                          index_name);
              if (html || !no_headers)
                index_node = (char *) _("(outside of any node)");
            }

          if (html)
            /* fixme: html: we should use specific index anchors pointing
           to the actual location of the indexed position (but then we
           have to find something to wrap the anchor around). */
            {
              /* In the HTML case, the expanded index entry is not
                 good for us, since it was expanded for non-HTML mode
                 inside sort_index.  So we need to HTML-escape and
                 expand the original entry text here.  */
              char *escaped_entry = xstrdup (index->entry_text);
              char *expanded_entry;

              /* expansion() doesn't HTML-escape the argument, so need
                 to do it separately.  */
              escaped_entry = escape_string (escaped_entry);
              expanded_entry = expansion (escaped_entry, index->code);
              add_html_block_elt_args ("\n<li><a href=\"%s#index-",
                  (splitting ? index->output_file : ""), index_name);
              add_escaped_anchor_name (index->entry_text);
              add_word_args ("-%d\">%s</a>: ", index->entry_number,
                  expanded_entry);
              free (escaped_entry);
              free (expanded_entry);

              add_word ("<a href=\"");
              if (index->node && *index->node)
                {
                  /* Make sure any non-macros in the node name are expanded.  */
                  char *expanded_index;

                  in_fixed_width_font++;
                  expanded_index = expansion (index_node, 0);
                  in_fixed_width_font--;
                  add_anchor_name (expanded_index, 1);
		  expanded_index = escape_string (expanded_index);
                  add_word_args ("\">%s</a>", expanded_index);
                  free (expanded_index);
                }
              else if (STREQ (index_node, _("(outside of any node)")))
                {
                  add_anchor_name (index_node, 1);
                  add_word_args ("\">%s</a>", index_node);
                }
              else
                /* If we use the section instead of the (missing) node, then
                   index_node already includes all we need except the #.  */
                add_word_args ("#%s</a>", index_node);

              add_html_block_elt ("</li>");
            }
          else if (xml && docbook)
            {
              /* In the DocBook case, the expanded index entry is not
                 good for us, since it was expanded for non-DocBook mode
                 inside sort_index.  So we send the original entry text
                 to be used with execute_string.  */
              xml_insert_indexentry (index->entry_text, index_node);
            }
          else
            {
              unsigned new_length = strlen (index->entry);

              if (new_length < 50) /* minimum length used below */
                new_length = 50;
              new_length += strlen (index_node) + 7; /* * : .\n\0 */

              if (new_length > line_length)
                {
                  line_length = new_length;
                  line = xrealloc (line, line_length);
                }
              /* Print the entry, nicely formatted.  We've already
                 expanded any commands in index->entry, including any
                 implicit @@code.  Thus, can't call execute_string, since
                 @@@@ has turned into @@. */
              if (!no_headers)
                {
                  sprintf (line, "* %-37s  ", index->entry);
                  line[2 + strlen (index->entry)] = ':';
                  insert_string (line);
                  /* Make sure any non-macros in the node name are expanded.  */
                  in_fixed_width_font++;
                  execute_string ("%s. ", index_node);
                  insert_index_output_line_no (index->output_line,
                      output_line_number_len);
                  in_fixed_width_font--;
                }
              else
                {
                  /* With --no-headers, the @@node lines are gone, so
                     there's little sense in referring to them in the
                     index.  Instead, output the number or name of the
                     section that corresponds to that node.  */
                  sprintf (line, "%-*s ", number_sections ? 46 : 1, index->entry);
                  line[strlen (index->entry)] = ':';
                  insert_string (line);

                  if (strlen (index->section) > 0)
                    { /* We got your number.  */
                      insert_string ((char *) _("See "));
                      insert_string (index->section);
                    }
                  else
                    { /* Sigh, index in an @@unnumbered. :-\  */
                      insert_string ("\n          ");
                      insert_string ((char *) _("See "));
                      insert_string ("``");
                      insert_string (expansion (index->section_name, 0));
                      insert_string ("''");
                    }

                  insert_string (". ");
                  insert_index_output_line_no (index->output_line,
                      output_line_number_len);
                }
            }

          /* Prevent `output_paragraph' from growing to the size of the
             whole index.  */
          flush_output ();
          last_index = index;
        }

      free (line);

      me_inhibit_expansion--;
      printing_index = 0;

      close_single_paragraph ();
      filling_enabled = saved_filling_enabled;
      inhibit_paragraph_indentation = saved_inhibit_paragraph_indentation;
      input_filename = saved_input_filename;
      line_number = saved_line_number;

      if (html)
        add_html_block_elt ("</ul>");
      else if (xml && docbook)
        xml_end_index ();
    }

  free (index_name);
  /* Re-increment the line number, because get_rest_of_line
     left us looking at the next line after the command.  */
  line_number++;
}
@


1.2
log
@remove old texinfo 4.2
@
text
@d2 1
a2 1
   $Id: index.c,v 1.1 2003/03/22 17:44:18 tg Exp $
d4 2
a5 1
   Copyright (C) 1998, 99, 2002 Free Software Foundation, Inc.
d22 3
d28 1
a31 47
/* An index element... */
typedef struct index_elt
{
  struct index_elt *next;
  char *entry;                  /* The index entry itself, after expansion. */
  char *entry_text;             /* The original, non-expanded entry text. */
  char *node;                   /* The node from whence it came. */
  int code;                     /* Nonzero means add `@@code{...}' when
                                   printing this element. */
  int defining_line;            /* Line number where this entry was written. */
  char *defining_file;          /* Source file for defining_line. */
} INDEX_ELT;


/* A list of short-names for each index.
   There are two indices into the the_indices array.
   * read_index is the index that points to the list of index
     entries that we will find if we ask for the list of entries for
     this name.
   * write_index is the index that points to the list of index entries
     that we will add new entries to.

   Initially, read_index and write_index are the same, but the
   @@syncodeindex and @@synindex commands can change the list we add
   entries to.

   For example, after the commands
     @@cindex foo
     @@defindex ii
     @@synindex cp ii
     @@cindex bar

   the cp index will contain the entry `foo', and the new ii
   index will contain the entry `bar'.  This is consistent with the
   way texinfo.tex handles the same situation.

   In addition, for each index, it is remembered whether that index is
   a code index or not.  Code indices have @@code{} inserted around the
   first word when they are printed with printindex. */
typedef struct
{
  char *name;
  int read_index;   /* index entries for `name' */
  int write_index;  /* store index entries here, @@synindex can change it */
  int code;
} INDEX_ALIST;

d42 3
d50 5
a54 1
int (*index_compare_fn) () = strcasecmp;
d59 1
a59 2
find_index_offset (name)
     char *name;
d70 2
a71 3
INDEX_ALIST *
find_index (name)
     char *name;
d82 2
a83 5
void
define_user_command (name, proc, needs_braces_p)
     char *name;
     COMMAND_FUNCTION *proc;
     int needs_braces_p;
d102 1
a102 2
free_index (index)
     INDEX_ELT *index;
d121 1
a121 2
undefindex (name)
     char *name;
d141 1
a141 2
/* Add the arguments to the current index command to the index NAME.
   html fixxme generate specific html anchor */
d143 1
a143 2
index_add_arg (name)
     char *name;
d175 7
d185 15
a199 1
      new->node = current_node ? current_node : xstrdup ("");
d202 1
d208 11
d230 21
d252 1
d259 1
a259 1
gen_index ()
d271 1
a271 3
defindex (name, code)
     char *name;
     int code;
d311 1
a311 3
top_defindex (name, code)
     char *name;
     int code;
d324 1
a324 1
init_indices ()
a343 1
      undefindex (name_index_alist[i]->name);
d351 9
a359 3
          free (name_index_alist[i]->name);
          free (name_index_alist[i]);
          name_index_alist[i] = NULL;
d374 2
a375 3
int
translate_index (name)
     char *name;
d387 1
a387 2
index_list (name)
     char *name;
d398 1
a398 2
gen_defindex (code)
     int code;
d420 1
a420 1
cm_defindex ()
d426 1
a426 1
cm_defcodeindex ()
d435 1
a435 1
cm_synindex ()
d453 5
a457 2
      name_index_alist[target]->write_index
        = name_index_alist[source]->write_index;
d465 1
a465 1
cm_pindex ()                    /* Pinhead index. */
d471 1
a471 1
cm_vindex ()                    /* Variable index. */
d477 1
a477 1
cm_kindex ()                    /* Key index. */
d483 1
a483 1
cm_cindex ()                    /* Concept index. */
d489 1
a489 1
cm_findex ()                    /* Function index. */
d495 1
a495 1
cm_tindex ()                    /* Data Type index. */
d501 1
a501 2
index_element_compare (element1, element2)
     INDEX_ELT **element1, **element2;
d503 4
a506 1
  return index_compare_fn ((*element1)->entry, (*element2)->entry);
d510 2
a511 4
void
make_index_entries_unique (array, count)
     INDEX_ELT **array;
     int count;
d566 6
a571 7
/* Sort the index passed in INDEX, returning an array of
   pointers to elements.  The array is terminated with a NULL
   pointer.  We call qsort because it's supposed to be fast.
   I think this looks bad. */
INDEX_ELT **
sort_index (index)
     INDEX_ELT *index;
d574 1
a574 1
  INDEX_ELT *temp = index;
d587 3
a589 8
  while (temp)
    {
      count++;
      temp = temp->next;
    }

  /* We have the length.  Make an array. */

a590 2
  count = 0;
  temp = index;
d592 1
a592 1
  while (temp)
d594 11
a604 1
      array[count++] = temp;
d608 2
a609 2
      line_number = array[count - 1]->defining_line;
      input_filename = array[count - 1]->defining_file;
d612 2
a613 5
         then expand it as @@code{entry}, i.e. as in fixed-width font.  */
      array[count-1]->entry = expansion (temp->entry_text,
				         array[count-1]->code);

      temp = temp->next;
d616 1
d634 1
a634 1
#endif /* HAVE_STRCOLL */    
d638 2
d641 6
d650 40
d696 1
a696 1
cm_printindex ()
d698 9
a708 2
      char *index_name;
      get_rest_of_line (0, &index_name);
d713 13
a731 1
      char *index_name;
d738 1
a738 3

      close_paragraph ();
      get_rest_of_line (0, &index_name);
d742 6
a747 6
	{
	  line_error (_("Unknown index `%s' in @@printindex"), index_name);
	  free (index_name);
	  return;
	}
      
d750 2
a751 2
	xml_begin_index ();
      
d753 1
a753 1
	 will give the same results as when we actually print.  */
d762 2
a763 1
	add_word ("<ul compact>");
d765 9
a773 2
	add_word ("* Menu:\n\n");
      
d775 1
a775 1
      
d779 19
a797 1
      
d799 21
a819 21
	{
	  /* A pathological document might have an index entry outside of any
	     node.  Don't crash; try using the section name instead.  */
	  char *index_node = index->node;
	  
	  line_number = index->defining_line;
	  input_filename = index->defining_file;
	  
	  if ((!index_node || !*index_node) && html)
	    index_node = toc_find_section_of_node (index_node);
	  
	  if (!index_node || !*index_node)
	    {
	      line_error (_("Entry for index `%s' outside of any node"),
			  index_name);
	      if (html || !no_headers)
		index_node = _("(outside of any node)");
	    }
	  
	  if (html)
	    /* fixme: html: we should use specific index anchors pointing
d822 118
a939 121
	    {
	      if (last_index
		  && STREQ (last_index->entry_text, index->entry_text))
		add_word (", ");  /* Don't repeat the previous entry. */
	      else
		{
		  /* In the HTML case, the expanded index entry is not
		     good for us, since it was expanded for non-HTML mode
		     inside sort_index.  So we need to HTML-escape and
		     expand the original entry text here.  */
		  char *escaped_entry = xstrdup (index->entry_text);
		  char *expanded_entry;
		  
		  /* expansion() doesn't HTML-escape the argument, so need
		     to do it separately.  */
		  escaped_entry = escape_string (escaped_entry);
		  expanded_entry = expansion (escaped_entry, index->code);
		  add_word_args ("\n<li>%s: ", expanded_entry);
		  free (escaped_entry);
		  free (expanded_entry);
		}
	      add_word ("<a href=\"");
	      if (index->node && *index->node)
		{
		  /* Make sure any non-macros in the node name are expanded.  */
		  in_fixed_width_font++;
		  index_node = expansion (index_node, 0);
		  in_fixed_width_font--;
		  add_anchor_name (index_node, 1);
		  add_word_args ("\">%s</a>", index_node);
		  free (index_node);
		}
	      else if (STREQ (index_node, _("(outside of any node)")))
		{
		  add_anchor_name (index_node, 1);
		  add_word_args ("\">%s</a>", index_node);
		}
	      else
		/* If we use the section instead of the (missing) node, then
		   index_node already includes all we need except the #.  */
		add_word_args ("#%s</a>", index_node);
	    }
	  else if (xml && docbook)
	    {
	      xml_insert_indexentry (index->entry, index_node);
	    }
	  else
	    {
	      unsigned new_length = strlen (index->entry);
	      
	      if (new_length < 50) /* minimum length used below */
		new_length = 50;
	      new_length += strlen (index_node) + 7; /* * : .\n\0 */
	      
	      if (new_length > line_length)
		{
		  line_length = new_length;
		  line = xrealloc (line, line_length);
		}
	      /* Print the entry, nicely formatted.  We've already
		 expanded any commands in index->entry, including any
		 implicit @@code.  Thus, can't call execute_string, since
		 @@@@ has turned into @@. */
	      if (!no_headers)
		{
		  sprintf (line, "* %-37s  ", index->entry);
		  line[2 + strlen (index->entry)] = ':';
		  insert_string (line);
		  /* Make sure any non-macros in the node name are expanded.  */
		  in_fixed_width_font++;
		  execute_string ("%s.\n", index_node);
		  in_fixed_width_font--;
		}
	      else
		{
		  /* With --no-headers, the @@node lines are gone, so
		     there's little sense in referring to them in the
		     index.  Instead, output the number or name of the
		     section that corresponds to that node.  */
		  char *section_name = toc_find_section_of_node (index_node);
		  
		  sprintf (line, "%-*s ", number_sections ? 50 : 1, index->entry);
		  line[strlen (index->entry)] = ':';
		  insert_string (line);
		  if (section_name)
		    {
		      int idx = 0;
		      unsigned ref_len = strlen (section_name) + 30;
		      
		      if (ref_len > line_length)
			{
			  line_length = ref_len;
			  line = xrealloc (line, line_length);
			}
		      
		      if (number_sections)
			{
			  while (section_name[idx]
				 && (isdigit (section_name[idx])
				     || (idx && section_name[idx] == '.')))
			    idx++;
			}
		      if (idx)
			sprintf (line, " See %.*s.\n", idx, section_name);
		      else
			sprintf (line, "\n          See ``%s''.\n", section_name);
		      insert_string (line);
		    }
		  else
		    {
		      insert_string (" "); /* force a blank */
		      execute_string ("See node %s.\n", index_node);
		    }
		}
	    }
	  
	  /* Prevent `output_paragraph' from growing to the size of the
	     whole index.  */
	  flush_output ();
	  last_index = index;
	}
d942 1
a942 2
      free (index_name);
      
a943 1
      
d945 1
a945 1
      free (array);
d951 1
a951 1
      
d953 1
a953 1
	add_word ("</ul>");
d955 1
a955 1
	xml_end_index ();
d957 5
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   $Id: index.c,v 1.1.1.2 2002/06/10 13:21:16 espie Exp $
@


1.1.2.1
log
@(stripped down to actually needed files) pristine GNU texinfo 4.7
@
text
@d2 1
a2 1
   $Id: index.c,v 1.22 2004/03/25 00:24:07 karl Exp $
d4 1
a4 2
   Copyright (C) 1998, 1999, 2002, 2003, 2004 Free Software Foundation,
   Inc.
a20 3
#include "files.h"
#include "footnote.h"
#include "html.h"
a23 1
#include "sectioning.h"
d27 47
a83 3
/* This is the order of the index.  */
int index_counter = 0;

d89 1
a89 5
int (*index_compare_fn) (const char *a, const char *b) = strcasecmp;

/* Function to compare index entries for sorting.  (Calls
   `index_compare_fn' above.)  */
int index_element_compare (const void *element1, const void *element2);
d94 2
a95 1
find_index_offset (char *name)
d106 3
a108 2
static INDEX_ALIST *
find_index (char *name)
d119 5
a123 2
static void
define_user_command (char *name, COMMAND_FUNCTION (*proc), int needs_braces_p)
d142 2
a143 1
free_index (INDEX_ELT *index)
d162 2
a163 1
undefindex (char *name)
d183 2
a184 1
/* Add the arguments to the current index command to the index NAME.  */
d186 2
a187 1
index_add_arg (char *name)
a218 7

      index_counter++;

      /* Get output line number updated before doing anything.  */
      if (!html && !xml)
        flush_output ();

d222 1
a222 15
      /* Since footnotes are handled at the very end of the document,
         node name in the non-split HTML outputs always show the last
         node.  We artificially make it ``Footnotes''.  */
      if (html && !splitting && already_outputting_pending_notes)
        new->node = xstrdup (_("Footnotes"));
      else
        new->node = current_node ? current_node : xstrdup ("");
      if (!html && !xml && no_headers)
        {
          new->section = current_sectioning_number ();
          if (strlen (new->section) == 0)
            new->section_name = current_sectioning_name ();
          else
            new->section_name = "";
        }
a224 1
      new->output_line = no_headers ? output_line_number : node_line_number;
a229 11

      new->entry_number = index_counter;

      if (html && splitting)
        {
          if (current_output_filename && *current_output_filename)
            new->output_file = filename_part (current_output_filename);
          else
            new->output_file = xstrdup ("");
        }

a240 21

      if (html)
        {
          /* Anchor.  */
          int removed_empty_elt = 0;

          /* We must put the anchor outside the <dl> and <ul> blocks.  */
          if (rollback_empty_tag ("dl"))
            removed_empty_elt = 1;
          else if (rollback_empty_tag ("ul"))
            removed_empty_elt = 2;

          add_word ("<a name=\"index-");
          add_escaped_anchor_name (index_entry);
          add_word_args ("-%d\"></a>", index_counter);

          if (removed_empty_elt == 1)
            add_html_block_elt_args ("\n<dl>");
          else if (removed_empty_elt == 2)
            add_html_block_elt_args ("\n<ul>");
        }
a241 1

d248 1
a248 1
gen_index (void)
d260 3
a262 1
defindex (char *name, int code)
d302 3
a304 1
top_defindex (char *name, int code)
d317 1
a317 1
init_indices (void)
d337 1
d345 3
a347 9
          undefindex (name_index_alist[i]->name);

          /* undefindex sets all this to null in some cases.  */
          if (name_index_alist[i])
            {
              free (name_index_alist[i]->name);
              free (name_index_alist[i]);
              name_index_alist[i] = NULL;
            }
d362 3
a364 2
static int
translate_index (char *name)
d376 2
a377 1
index_list (char *name)
d388 2
a389 1
gen_defindex (int code)
d411 1
a411 1
cm_defindex (void)
d417 1
a417 1
cm_defcodeindex (void)
d426 1
a426 1
cm_synindex (void)
d444 2
a445 5
      if (xml && !docbook)
        xml_synindex (abbrev1, abbrev2);
      else
        name_index_alist[target]->write_index
          = name_index_alist[source]->write_index;
d453 1
a453 1
cm_pindex (void)                    /* Pinhead index. */
d459 1
a459 1
cm_vindex (void)                    /* Variable index. */
d465 1
a465 1
cm_kindex (void)                    /* Key index. */
d471 1
a471 1
cm_cindex (void)                    /* Concept index. */
d477 1
a477 1
cm_findex (void)                    /* Function index. */
d483 1
a483 1
cm_tindex (void)                    /* Data Type index. */
d489 2
a490 1
index_element_compare (const void *element1, const void *element2)
d492 1
a492 4
  INDEX_ELT **elt1 = (INDEX_ELT **) element1;
  INDEX_ELT **elt2 = (INDEX_ELT **) element2;

  return index_compare_fn ((*elt1)->entry, (*elt2)->entry);
d496 4
a499 2
static void
make_index_entries_unique (INDEX_ELT **array, int count)
d554 7
a560 6

/* Sort the index passed in INDEX, returning an array of pointers to
   elements.  The array is terminated with a NULL pointer.  */

static INDEX_ELT **
sort_index (INDEX_ELT *index)
d563 1
a563 1
  INDEX_ELT *temp;
d576 8
a583 3
  for (temp = index, count = 0; temp; temp = temp->next, count++)
    ;
  /* We have the length, now we can allocate an array. */
d585 2
d588 1
a588 1
  for (temp = index, count = 0; temp; temp = temp->next, count++)
d590 1
a590 11
      /* Allocate new memory for the return array, since parts of the
         original INDEX get freed.  Otherwise, if the document calls
         @@printindex twice on the same index, with duplicate entries,
         we'll have garbage the second time.  There are cleaner ways to
         deal, but this will suffice for now.  */
      array[count] = xmalloc (sizeof (INDEX_ELT));
      *(array[count]) = *(temp);  /* struct assignment, hope it's ok */

      /* Adjust next pointers to use the new memory.  */
      if (count > 0)
        array[count-1]->next = array[count];
d594 2
a595 2
      line_number = array[count]->defining_line;
      input_filename = array[count]->defining_file;
d598 5
a602 2
         then expand it as @@code{entry}, i.e., as in fixed-width font.  */
      array[count]->entry = expansion (temp->entry_text, array[count]->code);
a604 1

d622 1
a622 1
#endif /* HAVE_STRCOLL */
a625 2

  /* Remove duplicate entries.  */
a626 6

  /* Replace the original index with the sorted one, in case the
     document wants to print it again.  If the index wasn't empty.  */
  if (index)
    *index = **array;

a629 40
static void
insert_index_output_line_no (int line_number, int output_line_number_len)
{
  int last_column;
  int str_size = output_line_number_len + strlen (_("(line )"))
    + sizeof (NULL);
  char *out_line_no_str = (char *) xmalloc (str_size + 1);

  /* Do not translate ``(line NNN)'' below for !no_headers case (Info output),
     because it's something like the ``* Menu'' strings.  For plaintext output
     it should be translated though.  */
  sprintf (out_line_no_str,
      no_headers ? _("(line %*d)") : "(line %*d)",
      output_line_number_len, line_number);

  {
    int i = output_paragraph_offset; 
    while (0 < i && output_paragraph[i-1] != '\n')
      i--;
    last_column = output_paragraph_offset - i;
  }

  if (last_column + strlen (out_line_no_str) > fill_column)
    {
      insert ('\n');
      last_column = 0;
    }

  while (last_column + strlen (out_line_no_str) < fill_column)
    {
      insert (' ');
      last_column++;
    }

  insert_string (out_line_no_str);
  insert ('\n');

  free (out_line_no_str);
}

d636 1
a636 1
cm_printindex (void)
a637 9
  char *index_name;
  get_rest_of_line (0, &index_name);

  /* get_rest_of_line increments the line number by one,
     so to make warnings/errors point to the correct line,
     we decrement the line_number again.  */
  if (!handling_delayed_writes)
    line_number--;

d640 2
a645 13
  else if (!handling_delayed_writes)
    {
      int command_len = sizeof ("@@ ") + strlen (command) + strlen (index_name);
      char *index_command = xmalloc (command_len + 1);

      close_paragraph ();
      if (docbook)
        xml_begin_index ();

      sprintf (index_command, "@@%s %s", command, index_name);
      register_delayed_write (index_command);
      free (index_command);
    }
d652 1
d659 3
a661 1
      unsigned output_line_number_len;
d665 6
a670 6
        {
          line_error (_("Unknown index `%s' in @@printindex"), index_name);
          free (index_name);
          return;
        }

d673 2
a674 2
        xml_begin_index ();

d676 1
a676 1
         will give the same results as when we actually print.  */
d685 1
a685 2
        add_html_block_elt_args ("<ul class=\"index-%s\" compact>",
                                 index_name);
d687 2
a688 9
        { /* Info.  Add magic cookie for info readers (to treat this
             menu differently), and the usual start-of-menu.  */
          add_char ('\0');
          add_word ("\010[index");
          add_char ('\0');
          add_word ("\010]\n");
          add_word ("* Menu:\n\n");
        }

d690 1
a690 1

d694 1
a694 19

      {
        char *max_output_line_number = (char *) xmalloc (25 * sizeof (char));

        if (no_headers)
          sprintf (max_output_line_number, "%d", output_line_number);
        else
          {
            INDEX_ELT *tmp_entry = index;
            unsigned tmp = 0;
            for (tmp_entry = index; tmp_entry; tmp_entry = tmp_entry->next)
              tmp = tmp_entry->output_line > tmp ? tmp_entry->output_line : tmp;
            sprintf (max_output_line_number, "%d", tmp);
          }

        output_line_number_len = strlen (max_output_line_number);
        free (max_output_line_number);
      }

d696 21
a716 21
        {
          /* A pathological document might have an index entry outside of any
             node.  Don't crash; try using the section name instead.  */
          char *index_node = index->node;

          line_number = index->defining_line;
          input_filename = index->defining_file;

          if ((!index_node || !*index_node) && html)
            index_node = toc_find_section_of_node (index_node);

          if (!index_node || !*index_node)
            {
              line_error (_("Entry for index `%s' outside of any node"),
                          index_name);
              if (html || !no_headers)
                index_node = (char *) _("(outside of any node)");
            }

          if (html)
            /* fixme: html: we should use specific index anchors pointing
d719 121
a839 118
            {
              /* In the HTML case, the expanded index entry is not
                 good for us, since it was expanded for non-HTML mode
                 inside sort_index.  So we need to HTML-escape and
                 expand the original entry text here.  */
              char *escaped_entry = xstrdup (index->entry_text);
              char *expanded_entry;

              /* expansion() doesn't HTML-escape the argument, so need
                 to do it separately.  */
              escaped_entry = escape_string (escaped_entry);
              expanded_entry = expansion (escaped_entry, index->code);
              add_html_block_elt_args ("\n<li><a href=\"%s#index-",
                  (splitting ? index->output_file : ""), index_name);
              add_escaped_anchor_name (index->entry_text);
              add_word_args ("-%d\">%s</a>: ", index->entry_number,
                  expanded_entry);
              free (escaped_entry);
              free (expanded_entry);

              add_word ("<a href=\"");
              if (index->node && *index->node)
                {
                  /* Make sure any non-macros in the node name are expanded.  */
                  char *expanded_index;

                  in_fixed_width_font++;
                  expanded_index = expansion (index_node, 0);
                  in_fixed_width_font--;
                  add_anchor_name (expanded_index, 1);
		  expanded_index = escape_string (expanded_index);
                  add_word_args ("\">%s</a>", expanded_index);
                  free (expanded_index);
                }
              else if (STREQ (index_node, _("(outside of any node)")))
                {
                  add_anchor_name (index_node, 1);
                  add_word_args ("\">%s</a>", index_node);
                }
              else
                /* If we use the section instead of the (missing) node, then
                   index_node already includes all we need except the #.  */
                add_word_args ("#%s</a>", index_node);

              add_html_block_elt ("</li>");
            }
          else if (xml && docbook)
            {
              /* In the DocBook case, the expanded index entry is not
                 good for us, since it was expanded for non-DocBook mode
                 inside sort_index.  So we send the original entry text
                 to be used with execute_string.  */
              xml_insert_indexentry (index->entry_text, index_node);
            }
          else
            {
              unsigned new_length = strlen (index->entry);

              if (new_length < 50) /* minimum length used below */
                new_length = 50;
              new_length += strlen (index_node) + 7; /* * : .\n\0 */

              if (new_length > line_length)
                {
                  line_length = new_length;
                  line = xrealloc (line, line_length);
                }
              /* Print the entry, nicely formatted.  We've already
                 expanded any commands in index->entry, including any
                 implicit @@code.  Thus, can't call execute_string, since
                 @@@@ has turned into @@. */
              if (!no_headers)
                {
                  sprintf (line, "* %-37s  ", index->entry);
                  line[2 + strlen (index->entry)] = ':';
                  insert_string (line);
                  /* Make sure any non-macros in the node name are expanded.  */
                  in_fixed_width_font++;
                  execute_string ("%s. ", index_node);
                  insert_index_output_line_no (index->output_line,
                      output_line_number_len);
                  in_fixed_width_font--;
                }
              else
                {
                  /* With --no-headers, the @@node lines are gone, so
                     there's little sense in referring to them in the
                     index.  Instead, output the number or name of the
                     section that corresponds to that node.  */
                  sprintf (line, "%-*s ", number_sections ? 46 : 1, index->entry);
                  line[strlen (index->entry)] = ':';
                  insert_string (line);

                  if (strlen (index->section) > 0)
                    { /* We got your number.  */
                      insert_string ((char *) _("See "));
                      insert_string (index->section);
                    }
                  else
                    { /* Sigh, index in an @@unnumbered. :-\  */
                      insert_string ("\n          ");
                      insert_string ((char *) _("See "));
                      insert_string ("``");
                      insert_string (expansion (index->section_name, 0));
                      insert_string ("''");
                    }

                  insert_string (". ");
                  insert_index_output_line_no (index->output_line,
                      output_line_number_len);
                }
            }

          /* Prevent `output_paragraph' from growing to the size of the
             whole index.  */
          flush_output ();
          last_index = index;
        }
d842 2
a843 1

d845 1
d847 1
a847 1

d853 1
a853 1

d855 1
a855 1
        add_html_block_elt ("</ul>");
d857 1
a857 1
        xml_end_index ();
a858 5

  free (index_name);
  /* Re-increment the line number, because get_rest_of_line
     left us looking at the next line after the command.  */
  line_number++;
@


1.1.2.2
log
@GNU Texinfo 4.8 here, too
@
text
@d2 1
a2 1
   $Id: index.c,v 1.17 2004/11/30 02:03:23 karl Exp $
d183 1
a184 1
      new->entry_text = index_entry;
a199 5
      else
        {
          new->section = NULL;
          new->section_name = NULL;
        }
d207 3
a217 5
      else
        new->output_file = NULL;        

      new->entry_number = index_counter;
      the_indices[which] = new;
d243 1
a243 1
          add_escaped_anchor_name (index_entry, 0);
d819 3
d823 11
a833 10
              /* For HTML, we need to expand and HTML-escape the
                 original entry text, at the same time.  Consider
                 @@cindex J@@"urgen.  We want J&uuml;urgen.  We can't
                 expand and then escape since we'll end up with
                 J&amp;uuml;rgen.  We can't escape and then expand
                 because then `expansion' will see J@@&quot;urgen, and
                 @@&quot;urgen is not a command.  */
              char *html_entry =
                maybe_escaped_expansion (index->entry_text, index->code, 1);

d835 2
a836 2
                  (splitting && index->output_file) ? index->output_file : "");
              add_escaped_anchor_name (index->entry_text, 0);
d838 3
a840 2
                  html_entry);
              free (html_entry);
d845 1
a845 1
                  /* Ensure any non-macros in the node name are expanded.  */
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
