head	1.3;
access;
symbols
	texinfo-4_8:1.1.2.2
	tg-mergetmp-mirosx-1:1.3
	tg-mergefixes-1-branch:1.3.0.8
	tg-mergefixes-1-base:1.3
	MIROS_X:1.3.0.6
	MIROS_X_BASE:1.3
	MIRBSD_XP_MIRPPC:1.3.0.4
	texinfo-4_7:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	testing_SYNC_A:1.3
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.08.17.29.18;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.08.08.17.26.05;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.44.18;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.44.18;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2004.10.16.23.10.07;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.01.06.23.37.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@switch to texinfo 4.7 based system
@
text
@/* cmds.c -- Texinfo commands.
   $Id: cmds.c,v 1.1.2.1 2004/08/08 16:18:02 tg Exp $

   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "system.h"
#include "cmds.h"
#include "defun.h"
#include "files.h"
#include "footnote.h"
#include "html.h"
#include "insertion.h"
#include "lang.h"
#include "macro.h"
#include "makeinfo.h"
#include "node.h"
#include "sectioning.h"
#include "toc.h"
#include "xml.h"

#ifdef TM_IN_SYS_TIME
#include <sys/time.h>
#else
#include <time.h>
#endif

/* Options. */
static void cm_exampleindent (void),
     cm_firstparagraphindent (void),
     cm_paragraphindent (void),
     cm_novalidate (void);

/* Internals. */
static void cm_obsolete (int arg, int start, int end),
     not_fixed_width (int arg);

/* The dispatch table.  */
COMMAND command_table[] = {
  { "\t", insert_space, NO_BRACE_ARGS },
  { "\n", insert_space, NO_BRACE_ARGS },
  { " ", insert_space, NO_BRACE_ARGS },
  { "!", cm_punct, NO_BRACE_ARGS },
  { "\"", cm_accent_umlaut, MAYBE_BRACE_ARGS },
  { "'", cm_accent_acute, MAYBE_BRACE_ARGS },
  { "*", cm_asterisk, NO_BRACE_ARGS },
  { ",", cm_accent_cedilla, MAYBE_BRACE_ARGS },
  { "-", cm_no_op, NO_BRACE_ARGS },
  { ".", cm_punct, NO_BRACE_ARGS },
  { "/", cm_no_op, NO_BRACE_ARGS },
  { ":", cm_colon, NO_BRACE_ARGS },
  { "=", cm_accent, MAYBE_BRACE_ARGS },
  { "?", cm_punct, NO_BRACE_ARGS },
  { "@@", insert_self, NO_BRACE_ARGS },
  { "\\", insert_self, NO_BRACE_ARGS },
  { "^", cm_accent_hat, MAYBE_BRACE_ARGS },
  { "`", cm_accent_grave, MAYBE_BRACE_ARGS },
  { "{", insert_self, NO_BRACE_ARGS },
  { "|", cm_no_op, NO_BRACE_ARGS },
  { "}", insert_self, NO_BRACE_ARGS },
  { "~", cm_accent_tilde, MAYBE_BRACE_ARGS },
  { "AA", cm_special_char, BRACE_ARGS },
  { "AE", cm_special_char, BRACE_ARGS },
  { "H", cm_accent, MAYBE_BRACE_ARGS },
  { "L", cm_special_char, BRACE_ARGS },
  { "LaTeX", cm_LaTeX, BRACE_ARGS },
  { "O", cm_special_char, BRACE_ARGS },
  { "OE", cm_special_char, BRACE_ARGS },
  { "TeX", cm_TeX, BRACE_ARGS },
  { "aa", cm_special_char, BRACE_ARGS },
  { "acronym", cm_acronym, BRACE_ARGS },
  { "ae", cm_special_char, BRACE_ARGS },
  { "afivepaper", cm_ignore_line, NO_BRACE_ARGS },
  { "afourlatex", cm_ignore_line, NO_BRACE_ARGS },
  { "afourpaper", cm_ignore_line, NO_BRACE_ARGS },
  { "afourwide", cm_ignore_line, NO_BRACE_ARGS },
  { "alias", cm_alias, NO_BRACE_ARGS },
  { "anchor", cm_anchor, BRACE_ARGS },
  { "appendix", cm_appendix, NO_BRACE_ARGS },
  { "appendixsection", cm_appendixsec, NO_BRACE_ARGS },
  { "appendixsec", cm_appendixsec, NO_BRACE_ARGS },
  { "appendixsubsec", cm_appendixsubsec, NO_BRACE_ARGS },
  { "appendixsubsubsec", cm_appendixsubsubsec, NO_BRACE_ARGS },
  { "asis", cm_no_op, BRACE_ARGS },
  { "author", cm_author, NO_BRACE_ARGS },
  { "b", cm_b, BRACE_ARGS },
  { "bullet", cm_bullet, BRACE_ARGS },
  { "bye", cm_bye, NO_BRACE_ARGS },
  { "c", cm_comment, NO_BRACE_ARGS },
  { "caption", cm_caption, BRACE_ARGS },
  { "cartouche", cm_cartouche, NO_BRACE_ARGS },
  { "center", cm_center, NO_BRACE_ARGS },
  { "centerchap", cm_unnumbered, NO_BRACE_ARGS },
  { "chapheading", cm_chapheading, NO_BRACE_ARGS },
  { "chapter", cm_chapter, NO_BRACE_ARGS },
  { "cindex", cm_cindex, NO_BRACE_ARGS },
  { "cite", cm_cite, BRACE_ARGS },
  { "clear", cm_clear, NO_BRACE_ARGS },
  { "code", cm_code, BRACE_ARGS },
  { "comma", cm_comma, BRACE_ARGS },
  { "command", cm_code, BRACE_ARGS },
  { "comment", cm_comment, NO_BRACE_ARGS },
  { "contents", cm_contents, NO_BRACE_ARGS },
  { "copying", cm_copying, NO_BRACE_ARGS },
  { "copyright", cm_copyright, BRACE_ARGS },
  { "ctrl", cm_obsolete, BRACE_ARGS },
  { "defcodeindex", cm_defcodeindex, NO_BRACE_ARGS },
  { "defcv", cm_defun, NO_BRACE_ARGS },
  { "defcvx", cm_defun, NO_BRACE_ARGS },
  { "deffn", cm_defun, NO_BRACE_ARGS },
  { "deffnx", cm_defun, NO_BRACE_ARGS },
  { "defindex", cm_defindex, NO_BRACE_ARGS },
  { "definfoenclose", cm_definfoenclose, NO_BRACE_ARGS },
  { "defivar", cm_defun, NO_BRACE_ARGS },
  { "defivarx", cm_defun, NO_BRACE_ARGS },
  { "defmac", cm_defun, NO_BRACE_ARGS },
  { "defmacx", cm_defun, NO_BRACE_ARGS },
  { "defmethod", cm_defun, NO_BRACE_ARGS },
  { "defmethodx", cm_defun, NO_BRACE_ARGS },
  { "defop", cm_defun, NO_BRACE_ARGS },
  { "defopt", cm_defun, NO_BRACE_ARGS },
  { "defoptx", cm_defun, NO_BRACE_ARGS },
  { "defopx", cm_defun, NO_BRACE_ARGS },
  { "defspec", cm_defun, NO_BRACE_ARGS },
  { "defspecx", cm_defun, NO_BRACE_ARGS },
  { "deftp", cm_defun, NO_BRACE_ARGS },
  { "deftpx", cm_defun, NO_BRACE_ARGS },
  { "deftypecv", cm_defun, NO_BRACE_ARGS },
  { "deftypecvx", cm_defun, NO_BRACE_ARGS },
  { "deftypefn", cm_defun, NO_BRACE_ARGS },
  { "deftypefnx", cm_defun, NO_BRACE_ARGS },
  { "deftypefun", cm_defun, NO_BRACE_ARGS },
  { "deftypefunx", cm_defun, NO_BRACE_ARGS },
  { "deftypeivar", cm_defun, NO_BRACE_ARGS },
  { "deftypeivarx", cm_defun, NO_BRACE_ARGS },
  { "deftypemethod", cm_defun, NO_BRACE_ARGS },
  { "deftypemethodx", cm_defun, NO_BRACE_ARGS },
  { "deftypeop", cm_defun, NO_BRACE_ARGS },
  { "deftypeopx", cm_defun, NO_BRACE_ARGS },
  { "deftypevar", cm_defun, NO_BRACE_ARGS },
  { "deftypevarx", cm_defun, NO_BRACE_ARGS },
  { "deftypevr", cm_defun, NO_BRACE_ARGS },
  { "deftypevrx", cm_defun, NO_BRACE_ARGS },
  { "defun", cm_defun, NO_BRACE_ARGS },
  { "defunx", cm_defun, NO_BRACE_ARGS },
  { "defvar", cm_defun, NO_BRACE_ARGS },
  { "defvarx", cm_defun, NO_BRACE_ARGS },
  { "defvr", cm_defun, NO_BRACE_ARGS },
  { "defvrx", cm_defun, NO_BRACE_ARGS },
  { "detailmenu", cm_detailmenu, NO_BRACE_ARGS },
  { "dfn", cm_dfn, BRACE_ARGS },
  { "dircategory", cm_dircategory, NO_BRACE_ARGS },
  { "direntry", cm_direntry, NO_BRACE_ARGS },
  { "display", cm_display, NO_BRACE_ARGS },
  { "dmn", cm_dmn, BRACE_ARGS },
  { "docbook", cm_docbook, NO_BRACE_ARGS },
  { "documentdescription", cm_documentdescription, NO_BRACE_ARGS },
  { "documentencoding", cm_documentencoding, NO_BRACE_ARGS },
  { "documentlanguage", cm_documentlanguage, NO_BRACE_ARGS },
  { "dotaccent", cm_accent, MAYBE_BRACE_ARGS },
  { "dotless", cm_dotless, BRACE_ARGS },
  { "dots", cm_dots, BRACE_ARGS },
  { "email", cm_email, BRACE_ARGS },
  { "emph", cm_emph, BRACE_ARGS },
  { "end", cm_end, NO_BRACE_ARGS },
  { "enddots", cm_enddots, BRACE_ARGS },
  { "enumerate", cm_enumerate, NO_BRACE_ARGS },
  { "env", cm_code, BRACE_ARGS },
  { "equiv", cm_equiv, BRACE_ARGS },
  { "error", cm_error, BRACE_ARGS },
  { "evenfooting", cm_ignore_line, NO_BRACE_ARGS },
  { "evenheading", cm_ignore_line, NO_BRACE_ARGS },
  { "everyfooting", cm_ignore_line, NO_BRACE_ARGS },
  { "everyheading", cm_ignore_line, NO_BRACE_ARGS },
  { "example", cm_example, NO_BRACE_ARGS },
  { "exampleindent", cm_exampleindent, NO_BRACE_ARGS },
  { "exclamdown", cm_special_char, BRACE_ARGS },
  { "exdent", cm_exdent, NO_BRACE_ARGS },
  { "expansion", cm_expansion, BRACE_ARGS },
  { "file", cm_code, BRACE_ARGS },
  { "finalout", cm_no_op, NO_BRACE_ARGS },
  { "findex", cm_findex, NO_BRACE_ARGS },
  { "firstparagraphindent", cm_firstparagraphindent, NO_BRACE_ARGS },
  { "float", cm_float, NO_BRACE_ARGS },
  { "flushleft", cm_flushleft, NO_BRACE_ARGS },
  { "flushright", cm_flushright, NO_BRACE_ARGS },
  { "footnote", cm_footnote, NO_BRACE_ARGS}, /* self-arg eater */
  { "footnotestyle", cm_footnotestyle, NO_BRACE_ARGS },
  { "format", cm_format, NO_BRACE_ARGS },
  { "ftable", cm_ftable, NO_BRACE_ARGS },
  { "group", cm_group, NO_BRACE_ARGS },
  { "heading", cm_heading, NO_BRACE_ARGS },
  { "headings", cm_ignore_line, NO_BRACE_ARGS },
  { "headitem", cm_headitem, NO_BRACE_ARGS },
  { "html", cm_html, NO_BRACE_ARGS },
  { "hyphenation", cm_ignore_arg, BRACE_ARGS },
  { "i", cm_i, BRACE_ARGS },
  { "ifclear", cm_ifclear, NO_BRACE_ARGS },
  { "ifeq", cm_ifeq, NO_BRACE_ARGS },
  { "ifdocbook", cm_ifdocbook, NO_BRACE_ARGS },
  { "ifhtml", cm_ifhtml, NO_BRACE_ARGS },
  { "ifinfo", cm_ifinfo, NO_BRACE_ARGS },
  { "ifnotdocbook", cm_ifnotdocbook, NO_BRACE_ARGS },
  { "ifnothtml", cm_ifnothtml, NO_BRACE_ARGS },
  { "ifnotinfo", cm_ifnotinfo, NO_BRACE_ARGS },
  { "ifnotplaintext", cm_ifnotplaintext, NO_BRACE_ARGS },
  { "ifnottex", cm_ifnottex, NO_BRACE_ARGS },
  { "ifnotxml", cm_ifnotxml, NO_BRACE_ARGS },
  { "ifplaintext", cm_ifplaintext, NO_BRACE_ARGS },
  { "ifset", cm_ifset, NO_BRACE_ARGS },
  { "iftex", cm_iftex, NO_BRACE_ARGS },
  { "ifxml", cm_ifxml, NO_BRACE_ARGS },
  { "ignore", command_name_condition, NO_BRACE_ARGS },
  { "image", cm_image, BRACE_ARGS },
  { "include", cm_include, NO_BRACE_ARGS },
  { "indent", cm_indent, NO_BRACE_ARGS },
  { "indicateurl", cm_indicate_url, BRACE_ARGS },
  { "inforef", cm_inforef, BRACE_ARGS },
  { "insertcopying", cm_insert_copying, NO_BRACE_ARGS },
  { "item", cm_item, NO_BRACE_ARGS },
  { "itemize", cm_itemize, NO_BRACE_ARGS },
  { "itemx", cm_itemx, NO_BRACE_ARGS },
  { "kbd", cm_kbd, BRACE_ARGS },
  { "kbdinputstyle", cm_ignore_line, NO_BRACE_ARGS },
  { "key", cm_key, BRACE_ARGS },
  { "kindex", cm_kindex, NO_BRACE_ARGS },
  { "l", cm_special_char, BRACE_ARGS },
  { "lisp", cm_lisp, NO_BRACE_ARGS },
  { "listoffloats", cm_listoffloats, NO_BRACE_ARGS },
  { "lowersections", cm_lowersections, NO_BRACE_ARGS },
  { "macro", cm_macro, NO_BRACE_ARGS },
  { "majorheading", cm_majorheading, NO_BRACE_ARGS },
  { "math", cm_math, BRACE_ARGS },
  { "menu", cm_menu, NO_BRACE_ARGS },
  { "minus", cm_minus, BRACE_ARGS },
  { "multitable", cm_multitable, NO_BRACE_ARGS },
  { "need", cm_ignore_line, NO_BRACE_ARGS },
  { "node", cm_node, NO_BRACE_ARGS },
  { "noindent", cm_noindent_cmd, NO_BRACE_ARGS },
  { "novalidate", cm_novalidate, NO_BRACE_ARGS },
  { "nwnode", cm_node, NO_BRACE_ARGS },
  { "o", cm_special_char, BRACE_ARGS },
  { "oddfooting", cm_ignore_line, NO_BRACE_ARGS },
  { "oddheading", cm_ignore_line, NO_BRACE_ARGS },
  { "oe", cm_special_char, BRACE_ARGS },
  { "option", cm_code, BRACE_ARGS },
  { "ordf", cm_special_char, BRACE_ARGS },
  { "ordm", cm_special_char, BRACE_ARGS },
  { "page", cm_no_op, NO_BRACE_ARGS },
  { "pagesizes", cm_ignore_line, NO_BRACE_ARGS },
  { "paragraphindent", cm_paragraphindent, NO_BRACE_ARGS },
  { "pindex", cm_pindex, NO_BRACE_ARGS },
  { "point", cm_point, BRACE_ARGS },
  { "pounds", cm_special_char, BRACE_ARGS },
  { "print", cm_print, BRACE_ARGS },
  { "printindex", cm_printindex, NO_BRACE_ARGS },
  { "pxref", cm_pxref, BRACE_ARGS },
  { "questiondown", cm_special_char, BRACE_ARGS },
  { "quotation", cm_quotation, NO_BRACE_ARGS },
  { "r", cm_r, BRACE_ARGS },
  { "raisesections", cm_raisesections, NO_BRACE_ARGS },
  { "ref", cm_ref, BRACE_ARGS },
  { "refill", cm_no_op, NO_BRACE_ARGS },
  { "registeredsymbol", cm_registeredsymbol, BRACE_ARGS },
  { "result", cm_result, BRACE_ARGS },
  { "ringaccent", cm_accent, MAYBE_BRACE_ARGS },
  { "rmacro", cm_rmacro, NO_BRACE_ARGS },
  { "samp", cm_code, BRACE_ARGS },
  { "sc", cm_sc, BRACE_ARGS },
  { "section", cm_section, NO_BRACE_ARGS },
  { "set", cm_set, NO_BRACE_ARGS },
  { "setchapternewpage", cm_ignore_line, NO_BRACE_ARGS },
  { "setchapterstyle", cm_obsolete, NO_BRACE_ARGS },
  { "setcontentsaftertitlepage", cm_no_op, NO_BRACE_ARGS },
  { "setfilename", cm_setfilename, NO_BRACE_ARGS },
  { "setshortcontentsaftertitlepage", cm_no_op, NO_BRACE_ARGS },
  { "settitle", cm_settitle, NO_BRACE_ARGS },
  { "shortcaption", cm_caption, BRACE_ARGS },
  { "shortcontents", cm_contents, NO_BRACE_ARGS },
  { "shorttitlepage", cm_ignore_line, NO_BRACE_ARGS },
  { "smallbook", cm_ignore_line, NO_BRACE_ARGS },
  { "smalldisplay", cm_smalldisplay, NO_BRACE_ARGS },
  { "smallexample", cm_smallexample, NO_BRACE_ARGS },
  { "smallformat", cm_smallformat, NO_BRACE_ARGS },
  { "smalllisp", cm_smalllisp, NO_BRACE_ARGS },
  { "sp", cm_sp, NO_BRACE_ARGS },
  { "ss", cm_special_char, BRACE_ARGS },
  { "strong", cm_strong, BRACE_ARGS },
  { "subheading", cm_subheading, NO_BRACE_ARGS },
  { "subsection", cm_subsection, NO_BRACE_ARGS },
  { "subsubheading", cm_subsubheading, NO_BRACE_ARGS },
  { "subsubsection", cm_subsubsection, NO_BRACE_ARGS },
  { "subtitle", cm_titlepage_cmds, NO_BRACE_ARGS },
  { "summarycontents", cm_contents, NO_BRACE_ARGS },
  { "syncodeindex", cm_synindex, NO_BRACE_ARGS },
  { "synindex", cm_synindex, NO_BRACE_ARGS },
  { "t", cm_tt, BRACE_ARGS },
  { "tab", cm_tab, NO_BRACE_ARGS },
  { "table", cm_table, NO_BRACE_ARGS },
  { "tex", cm_tex, NO_BRACE_ARGS },
  { "tie", cm_tie, BRACE_ARGS },
  { "tieaccent", cm_accent, MAYBE_BRACE_ARGS },
  { "tindex", cm_tindex, NO_BRACE_ARGS },
  { "title", cm_titlepage_cmds, NO_BRACE_ARGS },
  { "titlefont", cm_titlefont, BRACE_ARGS },
  { "titlepage", cm_titlepage, NO_BRACE_ARGS },
  { "today", cm_today, BRACE_ARGS },
  { "top", cm_top, NO_BRACE_ARGS  },
  { "u", cm_accent, MAYBE_BRACE_ARGS },
  { "ubaraccent", cm_accent, MAYBE_BRACE_ARGS },
  { "udotaccent", cm_accent, MAYBE_BRACE_ARGS },
  { "unmacro", cm_unmacro, NO_BRACE_ARGS },
  { "unnumbered", cm_unnumbered, NO_BRACE_ARGS },
  { "unnumberedsec", cm_unnumberedsec, NO_BRACE_ARGS },
  { "unnumberedsubsec", cm_unnumberedsubsec, NO_BRACE_ARGS },
  { "unnumberedsubsubsec", cm_unnumberedsubsubsec, NO_BRACE_ARGS },
  { "uref", cm_uref, BRACE_ARGS },
  { "url", cm_uref, BRACE_ARGS },
  { "v", cm_accent, MAYBE_BRACE_ARGS },
  { "value", cm_value, BRACE_ARGS },
  { "var", cm_var, BRACE_ARGS },
  { "verb", cm_verb, NO_BRACE_ARGS },
  { "verbatim", cm_verbatim, NO_BRACE_ARGS },
  { "verbatiminclude", cm_verbatiminclude, NO_BRACE_ARGS },
  { "vindex", cm_vindex, NO_BRACE_ARGS },
  { "vtable", cm_vtable, NO_BRACE_ARGS },
  { "vskip", cm_ignore_line, NO_BRACE_ARGS },
  { "w", cm_w, BRACE_ARGS },
  { "xml", cm_xml, NO_BRACE_ARGS },
  { "xref", cm_xref, BRACE_ARGS },

  /* Deprecated commands.  These used to be for italics.  */
  { "iappendix", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsection", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsubsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "ichapter", cm_ideprecated, NO_BRACE_ARGS },
  { "isection", cm_ideprecated, NO_BRACE_ARGS },
  { "isubsection", cm_ideprecated, NO_BRACE_ARGS },
  { "isubsubsection", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumbered", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsubsubsec", cm_ideprecated, NO_BRACE_ARGS },

  /* Now @@include does what this was used to. */
  { "infoinclude", cm_obsolete, NO_BRACE_ARGS },
  { "titlespec", cm_obsolete, NO_BRACE_ARGS },

  { NULL, NULL, NO_BRACE_ARGS }
};

/* The bulk of the Texinfo commands. */

/* Commands which insert their own names. */
void
insert_self (int arg)
{
  if (arg == START)
    add_word (command);
}

void
insert_space (int arg)
{
  if (arg == START)
    {
      if (xml && !docbook)
        xml_insert_entity ("space");
      else
        add_char (' ');
    }
}

/* Insert a comma.  Useful when a literal , would break our parsing of
   multiple arguments.  */
void
cm_comma (int arg)
{
  if (arg == START)
    add_char (',');
}


/* Force a line break in the output. */
void
cm_asterisk (void)
{
  if (html)
    add_word ("<br>");
  else if (xml && !docbook)
    xml_insert_entity ("linebreak");
  else if (docbook) 
    xml_asterisk ();
  else
    {
      close_single_paragraph ();
      cm_noindent ();
    }
}

/* Insert ellipsis. */
void
cm_dots (int arg)
{
  if (arg == START)
    {
      if (xml && !docbook)
        xml_insert_entity ("dots");
      else if (docbook)
        xml_insert_entity ("hellip");
      else
	if (html && !in_fixed_width_font)
	  insert_string ("<small class=\"dots\">...</small>");
	else
	  add_word ("...");
    }
}

/* Insert ellipsis for sentence end. */
void
cm_enddots (int arg)
{
  if (arg == START)
    {
      if (xml && !docbook)
	xml_insert_entity ("enddots");
      else if (docbook)
	{
	  xml_insert_entity ("hellip");
	  add_char ('.');
	}
      else
	if (html && !in_fixed_width_font)
	  insert_string ("<small class=\"enddots\">....</small>");
	else
	  add_word ("....");
    }
}

void
cm_bullet (int arg)
{
  if (arg == START)
    {
      if (html)
        add_word ("&bull;");
      else if (xml && !docbook)
	xml_insert_entity ("bullet");
      else if (docbook)
	xml_insert_entity ("bull");
      else
        add_char ('*');
    }
}

void
cm_minus (int arg)
{
  if (arg == START)
    {
      if (xml)
	xml_insert_entity ("minus");
      else if (html)
        add_word ("&minus;");
      else
	add_char ('-');
    }
}

/* Formatting a dimension unit.  */
void
cm_dmn (int arg)
{
  if (html)
    insert_html_tag_with_attribute (arg, "span", "class=\"dmn\"");
  else if (docbook)
    /* No units in docbook yet.  */
    ;
  else if (xml)
    xml_insert_element (DIMENSION, arg);
}

/* Insert "TeX". */
void
cm_TeX (int arg)
{
  static int last_position;

  if (arg == START)
    {
      if (xml)
	xml_insert_entity ("tex");
      else
	add_word ("TeX");

      last_position = output_paragraph_offset;
    }
  else if (last_position != output_paragraph_offset)
    {
      warning (_("arguments to @@%s ignored"), command);
      output_paragraph_offset = last_position;
    }
}

/* Insert "LaTeX".  */
void
cm_LaTeX (int arg)
{
  static int last_position;

  if (arg == START)
    {
      if (xml)
        xml_insert_entity ("latex");
      else
        add_word ("LaTeX");

      last_position = output_paragraph_offset;
    }
  else if (last_position != output_paragraph_offset)
    {
      warning (_("arguments to @@%s ignored"), command);
      output_paragraph_offset = last_position;
    }
}

/* Copyright symbol.  */
void
cm_copyright (int arg)
{
  if (arg == START)
    {
    if (html)
      add_word ("&copy;");
    else if (xml && !docbook)
      xml_insert_entity ("copyright");
    else if (docbook)
      xml_insert_entity ("copy");
    else
      add_word ("(C)");
    }
}

/* Registered symbol.  */
void
cm_registeredsymbol (int arg)
{
  if (arg == START)
    {
      if (html)
        add_word ("&reg;");
      else if (docbook)
        xml_insert_entity ("reg");
      else if (xml && !docbook)
        xml_insert_entity ("registered");
      else
        add_word ("(R)");
    }
}

void
cm_today (int arg)
{
  static char *months[12] =
    { N_("January"), N_("February"), N_("March"), N_("April"), N_("May"),
      N_("June"), N_("July"), N_("August"), N_("September"), N_("October"),
      N_("November"), N_("December") };
  if (arg == START)
    {
      time_t timer = time (0);
      struct tm *ts = localtime (&timer);
      add_word_args ("%d %s %d", ts->tm_mday, _(months[ts->tm_mon]),
                     ts->tm_year + 1900);
    }
}

void
cm_comment (void)
{
  /* For HTML, do not output comments before HTML header is written,
     otherwise comments before @@settitle cause an empty <title> in the
     header.  */
  if ((html && html_output_head_p) || xml)
    {
      char *line;
      get_rest_of_line (0, &line);

      if (strlen (line) > 0)
        {
          int save_inhibit_indentation = inhibit_paragraph_indentation;
          int save_paragraph_is_open = paragraph_is_open;
          int save_escape_html = escape_html;
          int save_xml_no_para = xml_no_para;
          int i;

          inhibit_paragraph_indentation = 1;
          escape_html = 0;
          xml_no_para = 1;

          /* @@c and @@comment can appear between @@item and @@itemx,
             @@deffn and @@deffnx.  */
          xml_dont_touch_items_defs++;

          /* Use insert for HTML, and XML when indentation is enabled.
             For Docbook, use add_char.  */
          if (xml && xml_indentation_increment > 0
              && output_paragraph[output_paragraph_offset-1] != '\n')
            insert ('\n');

          /* Crunch double hyphens in comments.  */
          add_html_block_elt ("<!-- ");
          for (i = 0; i < strlen (line); i++)
            if (line[i] != '-' || (i && line[i-1] != '-'))
              add_char (line[i]);
          add_word (" -->");

          if (html)
            add_char ('\n');

          inhibit_paragraph_indentation = save_inhibit_indentation;
          paragraph_is_open = save_paragraph_is_open;
          escape_html = save_escape_html;
          xml_no_para = save_xml_no_para;
          xml_dont_touch_items_defs--;
        }

      free (line);
    }
  else
    cm_ignore_line ();
}

/* We keep acronyms with two arguments around, to be able to refer to them
   later with only one argument.  */
static ACRONYM_DESC *acronyms_stack = NULL;

void
cm_acronym (int arg)
{
  char *acronym, *description;
  unsigned len;

  /* We do everything at START.  */
  if (arg == END)
    return;

  get_until_in_braces (",", &acronym);
  if (input_text[input_text_offset] == ',')
    input_text_offset++;
  get_until_in_braces ("}", &description);

  canon_white (acronym);
  canon_white (description);

  /* If not enclosed in braces, strip after comma to be compatible
     with texinfo.tex.  */
  if (description[0] != '{' && index (description, ',') != NULL)
    {
      int i = 0;
      while (description[i] != ',')
        i++;
      /* For now, just terminate the string at comma.  */
      description[i] = '\0';
    }

  /* Get description out of braces.  */
  if (description[0] == '{')
    description++;

  len = strlen (description);
  if (len && description[len-1] == '}')
    description[len-1] = '\0';

  /* Save new description.  */
  if (strlen (description) > 0)
    {
      ACRONYM_DESC *new = xmalloc (sizeof (ACRONYM_DESC));

      new->acronym = xstrdup (acronym);
      new->description = xstrdup (description);
      new->next = acronyms_stack;
      acronyms_stack = new;
    }

  if (html)
    {
      add_word ("<acronym");

      if (strlen (description) > 0)
        add_word_args (" title=\"%s\"", text_expansion (description));
      else if (acronyms_stack)
        {
          /* No second argument, get from previous.  Search order is from
             last to first defined, so we get the most recent version of
             the description.  */
          ACRONYM_DESC *temp = acronyms_stack;

          while (temp)
            {
              if (STREQ (acronym, temp->acronym) && strlen (temp->description) > 0)
                {
                  add_word_args (" title=\"%s\"", text_expansion (temp->description));
                  break;
                }
              temp = temp->next;
            }
        }

      add_char ('>');
      execute_string ("%s", acronym);
      add_word ("</acronym>");
    }
  else if (docbook)
    {
      xml_insert_element (ACRONYM, START);
      execute_string ("%s", acronym);
      xml_insert_element (ACRONYM, END);
    }
  else if (xml)
    {
      xml_insert_element (ACRONYM, START);

      xml_insert_element (ACRONYMWORD, START);
      execute_string ("%s", acronym);
      xml_insert_element (ACRONYMWORD, END);

      if (strlen (description) > 0)
        {
          xml_insert_element (ACRONYMDESC, START);
          execute_string ("%s", description);
          xml_insert_element (ACRONYMDESC, END);
        }

      xml_insert_element (ACRONYM, END);
    }
  else
    execute_string ("%s", acronym);

  /* Put description into parenthesis after the acronym for all outputs
     except XML.  */
  if (strlen (description) > 0 && (!xml || docbook))
    add_word_args (" (%s)", description);
}

void
cm_tt (int arg)
{
  /* @@t{} is a no-op in Info.  */
  if (html)
    insert_html_tag (arg, "tt");
  else if (xml)
    xml_insert_element (TT, arg);
}

void
cm_code (int arg)
{
  if (arg == START)
    in_fixed_width_font++;

  if (xml)
    {
      if (STREQ (command, "command"))
	xml_insert_element (COMMAND_TAG, arg);
      else if (STREQ (command, "env"))
	xml_insert_element (ENV, arg);
      else if (STREQ (command, "file"))
	xml_insert_element (FILE_TAG, arg);
      else if (STREQ (command, "option"))
	xml_insert_element (OPTION, arg);
      else if (STREQ (command, "samp"))
        {
          if (docbook && arg == START)
            {
              /* Even though @@samp is in_fixed_width_font, it
                 should always start a paragraph.  Unfortunately,
                 in_fixed_width_font inhibits that.  */
              xml_start_para ();
              xml_insert_entity ("lsquo");
            }
          xml_insert_element (SAMP, arg);
          if (docbook && arg == END)
            xml_insert_entity ("rsquo");
        }
      else
	xml_insert_element (CODE, arg);
    }
  else if (html)
    {
      if (STREQ (command, "code"))
        insert_html_tag (arg, "code");
      else
        insert_html_tag_with_attribute (arg, "span", "class=\"%s\"", command);
    }
  else
    {
      extern int printing_index;

      if (!printing_index)
        {
          if (arg == START)
            add_char ('`');
          else
            add_meta_char ('\'');
        }
    }
}

void
cm_kbd (int arg)
{
  if (xml)
    xml_insert_element (KBD, arg);
  else if (html)
    { /* Seems like we should increment in_fixed_width_font for Info
         format too, but then the quote-omitting special case gets
         confused.  Punt.  */
      if (arg == START)
        in_fixed_width_font++;
      insert_html_tag (arg, "kbd");
    }
  else
    { /* People use @@kbd in an example to get the "user input" font.
         We don't want quotes in that case.  */
      if (!in_fixed_width_font)
        cm_code (arg);
    }
}

/* Just show a url (http://example.org/..., for example), don't link to it.  */
void
cm_indicate_url (int arg, int start, int end)
{
  if (xml)
    xml_insert_element (URL, arg);
  else if (html)
    {
      if (arg == START)
        add_word ("&lt;");
      insert_html_tag (arg, "code");
      if (arg != START)
        add_word ("&gt;");
    }
  else
    if (arg == START)
      add_word ("<");
    else
      add_word (">");
}

void
cm_key (int arg)
{
  if (xml)
    xml_insert_element (KEY, arg);
  else if (html)
    add_word (arg == START ? "&lt;" : "&gt;");
  else
    add_char (arg == START ? '<' : '>');
}

/* Handle a command that switches to a non-fixed-width font.  */
void
not_fixed_width (int arg)
{
  if (arg == START)
    in_fixed_width_font = 0;
}

/* @@var in makeinfo just uppercases the text. */
void
cm_var (int arg, int start_pos, int end_pos)
{
  if (xml)
    xml_insert_element (VAR, arg);
  else
    {
  not_fixed_width (arg);

  if (html)
    insert_html_tag (arg, "var");
  else if (arg == END)
    {
      while (start_pos < end_pos)
        {
          unsigned char c = output_paragraph[start_pos];
          if (strchr ("[](),", c))
            warning (_("unlikely character %c in @@var"), c);
          output_paragraph[start_pos] = coerce_to_upper (c);
          start_pos++;
        }
    }
    }
}

void
cm_sc (int arg, int start_pos, int end_pos)
{
  if (xml)
    xml_insert_element (SC, arg);
  else
    {
      not_fixed_width (arg);

      if (arg == START)
        {
          if (html)
            insert_html_tag_with_attribute (arg, "span", "class=\"sc\"");
        }
      else
        {
          int all_upper;

          if (html)
            start_pos += sizeof ("<span class=\"sc\">") - 1; /* skip <span> */

          /* Avoid the warning below if there's no text inside @@sc{}, or
             when processing menus under --no-headers.  */
          all_upper = start_pos < end_pos;

          while (start_pos < end_pos)
            {
              unsigned char c = output_paragraph[start_pos];
              if (!isupper (c))
                all_upper = 0;
              if (!html)
                output_paragraph[start_pos] = coerce_to_upper (c);
              start_pos++;
            }
          if (all_upper)
            warning (_("@@sc argument all uppercase, thus no effect"));

          if (html)
            insert_html_tag (arg, "span");
        }
    }
}

void
cm_dfn (int arg, int position)
{
  if (xml)
    xml_insert_element (DFN, arg);
  else
    {
  if (html)
    insert_html_tag (arg, "dfn");
  else if (arg == START)
    add_char ('"');
  else
    add_meta_char ('"');
    }
}

void
cm_emph (int arg)
{
  if (xml)
    xml_insert_element (EMPH, arg);
  else if (html)
    insert_html_tag (arg, "em");
  else
    add_char ('_');
}

void
cm_verb (int arg)
{
  int character;
  int delimiter = 0; /* avoid warning */
  int seen_end = 0;

  in_fixed_width_font++;
  /* are these necessary ? */
  last_char_was_newline = 0;

  if (html)
    add_word ("<tt>");

  if (input_text_offset < input_text_length)
    {
      character = curchar ();
      if (character == '{')
	input_text_offset++;
      else
	line_error (_("`{' expected, but saw `%c'"), character);
    }
    
  if (input_text_offset < input_text_length)
    {
      delimiter = curchar ();
      input_text_offset++;
    }

  while (input_text_offset < input_text_length)
    {
      character = curchar ();

      if (character == '\n')
        {
          line_number++;
          if (html)
            add_word ("<br>\n");
        }

      else if (html && character == '<')
        add_word ("&lt;");

      else if (html && character == '&')
        add_word ("&amp;");

      else if (character == delimiter && input_text[input_text_offset+1] == '}')
	{ /* Assume no newlines in END_VERBATIM. */
	  seen_end = 1;
	  input_text_offset++;
	  break;
	}

      else
        add_char (character);

      input_text_offset++;
    }

  if (!seen_end)
    warning (_("end of file inside verb block"));
  
  if (input_text_offset < input_text_length)
    {
      character = curchar ();
      if (character == '}')
	input_text_offset++;
      else
	line_error (_("`}' expected, but saw `%c'"), character);
    }

  if (html)
    add_word ("</tt>");

  in_fixed_width_font--;
}


void
cm_strong (int arg, int start_pos, int end_pos)
{
  if (docbook && arg == START)
    xml_insert_element_with_attribute (B, arg, "role=\"bold\"");
  else if (xml)
    xml_insert_element (STRONG, arg);
  else if (html)
    insert_html_tag (arg, "strong");
  else
    add_char ('*');
  
  if (!xml && !html && !docbook && !no_headers
      && arg == END
      && end_pos - start_pos >= 6
      && strncmp ((char *) output_paragraph + start_pos, "*Note:*", 6) == 0)
    /* Translators: "Note:" is literal here and should not be
       translated.  @@strong{Nota}, say, does not cause the problem.  */
    warning (_("@@strong{Note:} produces a spurious cross-reference in Info; reword to avoid that"));

}

void
cm_cite (int arg, int position)
{
  if (xml)
    xml_insert_element (CITE, arg);        
  else if (html)
    insert_html_tag (arg, "cite");
  else
    {
      if (arg == START)
        add_char ('`');
      else
        add_char ('\'');
    }
}

/* No highlighting, but argument switches fonts.  */
void
cm_not_fixed_width (int arg, int start, int end)
{
  if (xml)
    xml_insert_element (NOTFIXEDWIDTH, arg);
  not_fixed_width (arg);
}

void
cm_i (int arg)
{
  /* Make use of <lineannotation> of Docbook, if we are
     inside an @@example or similar.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
    xml_insert_element (I, arg);
  else if (html)
    insert_html_tag (arg, "i");
  else
    not_fixed_width (arg);
}

void
cm_b (int arg)
{
  /* See cm_i comments.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (docbook && arg == START)
    xml_insert_element_with_attribute (B, arg, "role=\"bold\"");
  else if (xml)
    xml_insert_element (B, arg);
  else if (html)
    insert_html_tag (arg, "b");
  else
    not_fixed_width (arg);
}

void
cm_r (int arg)
{
  /* See cm_i comments.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
    xml_insert_element (R, arg);
  else if (html)
    insert_html_tag_with_attribute (arg, "span", "class=\"roman\"");
  else
    not_fixed_width (arg);
}

void
cm_titlefont (int arg)
{
  if (xml)
    xml_insert_element (TITLEFONT, arg);
  else
   {
     not_fixed_width (arg);
     if (html)
	{
	  html_title_written = 1; /* suppress title from @@settitle */
	  if (arg == START)
	    add_word ("<h1 class=\"titlefont\">");
	  else
	    add_word ("</h1>\n");
	}
   }
}


/* Unfortunately, we cannot interpret @@math{} contents like TeX does.  We just
   pass them through.  */
void
cm_math (int arg)
{
  if (xml && !docbook)
    xml_insert_element (MATH, arg);
}

/* Various commands are no-op's. */
void
cm_no_op (void)
{
}


/* For proofing single chapters, etc.  */
void
cm_novalidate (void)
{
  validating = 0;
}


/* Prevent the argument from being split across two lines. */
void
cm_w (int arg)
{
  if (arg == START)
    non_splitting_words++;
  else
    {
      if (docbook || html || xml)
        /* This is so @@w{$}Log$ doesn't end up as <dollar>Log<dollar>
           in the output.  */
        insert_string ("<!-- /@@w -->");
        
      non_splitting_words--;
    }
}


/* An unbreakable word space.  Same as @@w{ } for makeinfo, but different
   for TeX (the space stretches and stretches, and does not inhibit
   hyphenation).  */
void
cm_tie (int arg)
{
  if (arg == START)
    {
      cm_w (START);
      add_char (' ');
    }
  else
    cm_w (END);
}

/* Explain that this command is obsolete, thus the user shouldn't
   do anything with it. */
static void
cm_obsolete (int arg, int start, int end)
{
  if (arg == START)
    warning (_("%c%s is obsolete"), COMMAND_PREFIX, command);
}


/* Inhibit the indentation of the next paragraph, but not of following
   paragraphs.  */
void
cm_noindent (void)
{
  if (!inhibit_paragraph_indentation)
    inhibit_paragraph_indentation = -1;
}

void
cm_noindent_cmd (void)
{
  cm_noindent ();
  xml_no_indent = 1;
  skip_whitespace_and_newlines();

  if (xml)
    xml_start_para ();
  else if (html && !paragraph_is_open)
    add_html_block_elt ("<p class=\"noindent\">");
  else
    {
      paragraph_is_open = 0;
      start_paragraph ();
    }
}

/* Force indentation of the next paragraph. */
void
cm_indent (void)
{
  inhibit_paragraph_indentation = 0;
  xml_no_indent = 0;
  skip_whitespace_and_newlines();
  
  if (xml)
    xml_start_para ();
  else if (html && !paragraph_is_open)
    add_html_block_elt ("<p class=\"indent\">");
  else
    start_paragraph ();
}

/* I don't know exactly what to do with this.  Should I allow
   someone to switch filenames in the middle of output?  Since the
   file could be partially written, this doesn't seem to make sense.
   Another option: ignore it, since they don't really want to
   switch files.  Finally, complain, or at least warn.  It doesn't
   really matter, anyway, since this doesn't get executed.  */
void
cm_setfilename (void)
{
  char *filename;
  get_rest_of_line (1, &filename);
  /* warning ("`@@%s %s' encountered and ignored", command, filename); */
  if (xml)
    add_word_args ("<setfilename>%s</setfilename>", filename);
  free (filename);
}

void
cm_settitle (void)
{
  if (xml)
    {
      xml_begin_document (current_output_filename);
      xml_insert_element (SETTITLE, START);
      xml_in_book_title = 1;
      get_rest_of_line (0, &title);
      execute_string ("%s", title);
      xml_in_book_title = 0;
      xml_insert_element (SETTITLE, END);
    }
  else
    get_rest_of_line (0, &title);
}


/* Ignore argument in braces.  */
void
cm_ignore_arg (int arg, int start_pos, int end_pos)
{
  if (arg == END)
    output_paragraph_offset = start_pos;
}

/* Ignore argument on rest of line.  */
void
cm_ignore_line (void)
{
  discard_until ("\n");
}

/* Insert the number of blank lines passed as argument. */
void
cm_sp (void)
{
  int lines;
  char *line;

  /* Due to tricky stuff in execute_string(), @@value{} can't be expanded.
     So there is really no reason to enable expansion for @@sp parameters.  */
  get_rest_of_line (0, &line);

  if (sscanf (line, "%d", &lines) != 1 || lines <= 0)
    line_error (_("@@sp requires a positive numeric argument, not `%s'"), line);
  else
    {
      if (xml)
	{
          /* @@sp can appear between @@item and @@itemx, @@deffn and @@deffnx.  */
          xml_dont_touch_items_defs++;
	  xml_insert_element_with_attribute (SP, START, "lines=\"%s\"", line);
	  /*	  insert_string (line);*/
	  xml_insert_element (SP, END);
          xml_dont_touch_items_defs--;
	}
      else
        {
          /* Must disable filling since otherwise multiple newlines is like
             multiple spaces.  Must close paragraph since that's what the
             manual says and that's what TeX does.  */
          int save_filling_enabled = filling_enabled;
          filling_enabled = 0;

          /* close_paragraph generates an extra blank line.  */
          close_single_paragraph ();

          if (lines && html && !executing_string)
            html_output_head ();

          if (html)
            add_html_block_elt ("<pre class=\"sp\">\n");

          while (lines--)
            add_char ('\n');

          if (html)
            add_html_block_elt ("</pre>\n");

          filling_enabled = save_filling_enabled;
        }
    }
  free (line);
}

/* @@dircategory LINE outputs INFO-DIR-SECTION LINE, unless --no-headers.  */ 
void
cm_dircategory (void)
{
  char *line;

  if (html || docbook)
    cm_ignore_line ();
  else if (xml)
    {
      xml_insert_element (DIRCATEGORY, START);
      get_rest_of_line (1, &line);
      insert_string (line);
      free (line);
      xml_insert_element (DIRCATEGORY, END);
    }
  else
    {
      get_rest_of_line (1, &line);

      if (!no_headers && !html)
        {
          kill_self_indent (-1); /* make sure there's no indentation */
          insert_string ("INFO-DIR-SECTION ");
          insert_string (line);
          insert ('\n');
        }

      free (line);
    }
}

/* Start a new line with just this text on it.
   Then center the line of text.
   */
void
cm_center (void)
{
  if (xml)
    {
      unsigned char *line;
      xml_insert_element (CENTER, START);
      get_rest_of_line (0, (char **)&line);
      execute_string ("%s", (char *)line);
      free (line);
      xml_insert_element (CENTER, END);
    }
  else
    {
      int i, start, length;
      unsigned char *line;
      int save_indented_fill = indented_fill;
      int save_filling_enabled = filling_enabled;
      int fudge_factor = 1;

      filling_enabled = indented_fill = 0;
      cm_noindent ();
      start = output_paragraph_offset;

      if (html)
        add_html_block_elt ("<div align=\"center\">");

      inhibit_output_flushing ();
      get_rest_of_line (0, (char **)&line);
      execute_string ("%s", (char *)line);
      free (line);
      uninhibit_output_flushing ();
      if (html)
        add_html_block_elt ("</div>");

       else
         {
           i = output_paragraph_offset - 1;
           while (i > (start - 1) && output_paragraph[i] == '\n')
             i--;

           output_paragraph_offset = ++i;
           length = output_paragraph_offset - start;

           if (length < (fill_column - fudge_factor))
             {
               line = xmalloc (1 + length);
               memcpy (line, (char *)(output_paragraph + start), length);

               i = (fill_column - fudge_factor - length) / 2;
               output_paragraph_offset = start;

               while (i--)
                 insert (' ');

               for (i = 0; i < length; i++)
                 insert (line[i]);

               free (line);
             }
         }

      insert ('\n');
      filling_enabled = save_filling_enabled;
      indented_fill = save_indented_fill;
      close_single_paragraph ();
      if (looking_at("\n"))
        insert ('\n');
    }
}

/* Show what an expression returns. */
void
cm_result (int arg)
{
  if (arg == END)
    add_word (html ? "=&gt;" : "=>");
}

/* What an expression expands to. */
void
cm_expansion (int arg)
{
  if (arg == END)
    add_word (html ? "==&gt;" : "==>");
}

/* Indicates two expressions are equivalent. */
void
cm_equiv (int arg)
{
  if (arg == END)
    add_word ("==");
}

/* What an expression may print. */
void
cm_print (int arg)
{
  if (arg == END)
    add_word ("-|");
}

/* An error signaled. */
void
cm_error (int arg)
{
  if (arg == END)
    add_word (html ? "error--&gt;" : "error-->");
}

/* The location of point in an example of a buffer. */
void
cm_point (int arg)
{
  if (arg == END)
    add_word ("-!-");
}

/* @@exdent: Start a new line with just this text on it.
   The text is outdented one level if possible. */
void
cm_exdent (void)
{
  char *line;
  int save_indent = current_indent;
  int save_in_fixed_width_font = in_fixed_width_font;

  /* Read argument.  */
  get_rest_of_line (0, &line);

  /* Exdent the output.  Actually this may be a no-op.   */
  if (current_indent)
    current_indent -= default_indentation_increment;

  /* @@exdent arg is supposed to be in roman.  */
  in_fixed_width_font = 0;
  
  /* The preceding newline already inserted the `current_indent'.
     Remove one level's worth.  */
  kill_self_indent (default_indentation_increment);

  if (html)
    add_word ("<br>");
  else if (docbook)
    xml_insert_element (LINEANNOTATION, START);
  else if (xml)
    xml_insert_element (EXDENT, START);

  /* Can't close_single_paragraph, then we lose preceding blank lines.  */
  flush_output ();
  execute_string ("%s", line);
  free (line);

  if (html)
    add_word ("<br>");
  else if (xml)
    {
      xml_insert_element (docbook ? LINEANNOTATION : EXDENT, END);
      insert ('\n');
    }

  close_single_paragraph ();

  current_indent = save_indent;
  in_fixed_width_font = save_in_fixed_width_font;
  if (!xml)
    start_paragraph ();
}

/* 
  Read include-filename, process the include-file:
    verbatim_include == 0: process through reader_loop
    verbatim_include != 0: process through handle_verbatim_environment
 */
static void
handle_include (int verbatim_include)
{
  char *arg, *filename;

  if (macro_expansion_output_stream && !executing_string)
    me_append_before_this_command ();

  if (!insertion_stack)
    close_paragraph ();  /* No blank lines etc. if not at outer level.  */
    
  get_rest_of_line (0, &arg);
  /* We really only want to expand @@value, but it's easier to just do
     everything.  TeX will only work with @@value.  */
  filename = text_expansion (arg);
  free (arg);

  if (macro_expansion_output_stream && !executing_string)
    remember_itext (input_text, input_text_offset);

  pushfile ();

  /* In verbose mode we print info about including another file. */
  if (verbose_mode)
    {
      int i = 0;
      FSTACK *stack = filestack;

      for (i = 0, stack = filestack; stack; stack = stack->next, i++);

      i *= 2;

      printf ("%*s", i, "");
      printf ("%c%s `%s'\n", COMMAND_PREFIX, command, filename);
      fflush (stdout);
    }

  if (!find_and_load (filename))
    {
      popfile ();
      line_number--;

      /* /wh/bar:5: @@include/@@verbatiminclude `foo': No such file or dir */
      line_error ("%c%s `%s': %s", COMMAND_PREFIX, command, filename,
                  strerror (errno));

      free (filename);
      return;
    }
  else
    {
      if (macro_expansion_output_stream && !executing_string)
	remember_itext (input_text, input_text_offset);

      if (!verbatim_include)
	reader_loop ();
      else
	handle_verbatim_environment (0);
    }
  free (filename);
  popfile ();
}


/* Include file as if put in @@verbatim environment */
void
cm_verbatiminclude (void)
{
  handle_include (1); 
}


/* Remember this file, and move onto the next. */
void
cm_include (void)
{
  handle_include (0); 
}


/* @@bye: Signals end of processing.  Easy to make this happen. */

void
cm_bye (void)
{
  discard_braces (); /* should not have any unclosed braces left */
  input_text_offset = input_text_length;
}

/* @@paragraphindent */

static void
cm_paragraphindent (void)
{
  char *arg;

  get_rest_of_line (1, &arg);
  if (set_paragraph_indent (arg) != 0)
    line_error (_("Bad argument to %c%s"), COMMAND_PREFIX, command);

  free (arg);
}


/* @@exampleindent: change indentation of example-like environments.   */
static int
set_example_indentation_increment (char *string)
{
  if (strcmp (string, "asis") == 0 || strcmp (string, _("asis")) == 0)
    ;
  else if (strcmp (string, "none") == 0 || strcmp (string, _("none")) == 0)
    example_indentation_increment = 0;
  else if (sscanf (string, "%d", &example_indentation_increment) != 1)
    return -1;
  return 0;
}

static void
cm_exampleindent (void)
{
  char *arg;
  
  get_rest_of_line (1, &arg);
  if (set_example_indentation_increment (arg) != 0)
    line_error (_("Bad argument to @@%s"), command);

  if (input_text[input_text_offset] == '\n')
    close_single_paragraph ();

  free (arg);
}


/* @@firstparagraphindent: suppress indentation in first paragraphs after
   headings. */
static int
set_firstparagraphindent (char *string)
{
  if (STREQ (string, "insert") || STREQ (string, _("insert")))
    do_first_par_indent = 1;
  else if (STREQ (string, "none") || STREQ (string, _("none")))
    do_first_par_indent = 0;
  else
    return -1;
  return 0;
}

static void
cm_firstparagraphindent (void)
{
  char *arg;

  get_rest_of_line (1, &arg);
  if (set_firstparagraphindent (arg) != 0)
    line_error (_("Bad argument to %c%s"), COMMAND_PREFIX, command);

  free (arg);
}

/* For DocBook and XML, produce &period; for `.@@:'. This gives the processing
   software a fighting chance to treat it specially by not adding extra space.
  
   Do this also for ?, !, and :.  */
void
cm_colon (void)
{
  if (xml)
    {
      if (strchr (".?!:", input_text[input_text_offset-3]) != NULL)
        {
          /* Erase literal character that's there, except `>', which is
             part of the XML tag.  */
          if (output_paragraph[output_paragraph_offset-1] != '>')
            output_paragraph_offset--;

          switch (input_text[input_text_offset-3])
            {
            case '.':
              xml_insert_entity ("period");
              break;
            case '?':
              xml_insert_entity ("quest");
              break;
            case '!':
              xml_insert_entity ("excl");
              break;
            case ':':
              xml_insert_entity ("colon");
              break;
            }
        }
    }
}

/* Ending sentences explicitly.  Currently, only outputs entities for XML
   output, for other formats it calls insert_self.  */
void
cm_punct (int arg)
{
  if (xml && !docbook)
    {
      switch (input_text[input_text_offset-1])
        {
        case '.':
          xml_insert_entity ("eosperiod");
          break;
        case '?':
          xml_insert_entity ("eosquest");
          break;
        case '!':
          xml_insert_entity ("eosexcl");
          break;
        }
    }
  else
    {
      insert_self (arg);
    }
}
@


1.2
log
@remove old texinfo 4.2
@
text
@d2 1
a2 1
   $Id: cmds.c,v 1.1 2003/03/22 17:44:18 tg Exp $
d4 2
a5 1
   Copyright (C) 1998, 99, 2000, 01, 02 Free Software Foundation, Inc.
d26 1
a41 34

void insert_self (), insert_space (), cm_ignore_line (), cm_ignore_arg ();

void
  cm_TeX (), cm_acronym (), cm_asterisk (), cm_b (), cm_bullet (), cm_cite (),
  cm_code (), cm_copyright (), cm_ctrl (), cm_dfn (), cm_dircategory (),
  cm_direntry (), cm_dmn (), cm_dots (), cm_emph (), cm_enddots (), cm_i (),
  cm_image (), cm_kbd (), cm_key (), cm_no_op (), 
  cm_novalidate (), cm_not_fixed_width (), cm_r (),
  cm_strong (), cm_var (), cm_sc (), cm_w (), cm_email (), cm_url (),
  cm_verb (), cm_copying (), cm_insert_copying (),
  cm_documentdescription ();

void
  cm_anchor (), cm_node (), cm_menu (), cm_xref (), cm_ftable (),
  cm_vtable (), cm_pxref (), cm_inforef (), cm_uref (), cm_email (),
  cm_quotation (), cm_display (), cm_smalldisplay (), cm_itemize (),
  cm_enumerate (), cm_tab (), cm_table (), cm_itemx (), cm_noindent (),
  cm_setfilename (), cm_br (), cm_sp (), cm_page (), cm_group (),
  cm_center (), cm_ref (), cm_include (), cm_bye (), cm_item (), cm_end (),
  cm_kindex (), cm_cindex (), cm_findex (), cm_pindex (), cm_vindex (),
  cm_tindex (), cm_synindex (), cm_printindex (), cm_minus (),
  cm_example (), cm_smallexample (), cm_smalllisp (), cm_lisp (),
  cm_format (), cm_smallformat (), cm_exdent (), cm_defindex (),
  cm_defcodeindex (), cm_result (), cm_expansion (), cm_equiv (),
  cm_print (), cm_error (), cm_point (), cm_today (), cm_flushleft (),
  cm_flushright (), cm_finalout (), cm_cartouche (), cm_detailmenu (),
  cm_multitable (), cm_settitle (), cm_titlefont (), cm_tt (),
  cm_verbatim (), cm_verbatiminclude ();

/* Conditionals. */
void cm_set (), cm_clear (), cm_ifset (), cm_ifclear ();
void cm_value (), cm_ifeq ();

d43 4
a46 1
static void cm_paragraphindent (), cm_exampleindent ();
d49 2
a50 4
static void cm_obsolete ();

/* A random string.  */
static const char small_tag[] = "small";
d57 1
a57 1
  { "!", insert_self, NO_BRACE_ARGS },
d63 3
a65 2
  { ".", insert_self, NO_BRACE_ARGS },
  { ":", cm_no_op, NO_BRACE_ARGS },
d67 1
a67 1
  { "?", insert_self, NO_BRACE_ARGS },
d80 1
d99 1
d103 2
a104 1
  { "c", cm_ignore_line, NO_BRACE_ARGS },
d114 1
d116 1
a116 1
  { "comment", cm_ignore_line, NO_BRACE_ARGS },
d142 2
d169 2
a170 1
  { "dmn", cm_no_op, BRACE_ARGS },
d197 2
d208 1
d214 1
d217 1
d222 1
d226 1
d230 2
d243 1
d247 1
a247 1
  { "math", cm_no_op, BRACE_ARGS },
d253 2
a254 2
  { "noindent", cm_noindent, NO_BRACE_ARGS },
  { "noindent", cm_novalidate, NO_BRACE_ARGS },
d261 2
d278 1
d292 2
a293 1
  { "shortcontents", cm_shortcontents, NO_BRACE_ARGS },
d307 2
a308 1
  { "summarycontents", cm_shortcontents, NO_BRACE_ARGS },
d315 1
d318 1
d320 1
a320 1
  { "titlepage", command_name_condition, NO_BRACE_ARGS },
d332 1
a332 1
  { "url", cm_url, BRACE_ARGS },
d341 1
d343 1
d372 1
a372 2
insert_self (arg)
    int arg;
d379 1
a379 2
insert_space (arg)
    int arg;
d384 1
a384 1
	xml_insert_entity ("space");
d386 1
a386 1
	add_char (' ');
d390 10
d402 1
a402 1
cm_asterisk ()
d419 1
a419 2
cm_dots (arg)
     int arg;
d424 1
a424 1
	xml_insert_entity ("dots");
d426 1
a426 1
	xml_insert_entity ("hellip");
d428 4
a431 1
	add_word (html ? "<small>...</small>" : "...");
d437 1
a437 2
cm_enddots (arg)
     int arg;
d449 4
a452 1
	add_word (html ? "<small>...</small>." : "....");
d457 1
a457 2
cm_bullet (arg)
     int arg;
d462 1
a462 1
        add_word ("&#149;");
d473 1
a473 2
cm_minus (arg)
     int arg;
d479 2
d486 13
d501 1
a501 2
cm_TeX (arg)
     int arg;
d503 2
d507 1
a507 1
      if (xml && ! docbook)
d511 29
d545 1
a545 2
cm_copyright (arg)
    int arg;
d560 1
d562 17
a578 2
cm_today (arg)
     int arg;
d594 61
a654 2
cm_acronym (arg)
     int arg;
d656 45
d702 33
a734 1
    insert_html_tag (arg, small_tag);
d736 23
a758 1
    xml_insert_element (ACRONYM, arg);
d762 1
a762 2
cm_tt (arg)
     int arg;
d772 1
a772 2
cm_code (arg)
     int arg;
d774 3
a777 2
    xml_insert_element (CODE, arg);
  else
d779 26
a804 3
  extern int printing_index;

  if (arg == START)
d806 1
a806 3
      in_fixed_width_font++;

      if (html)
d808 2
a809 2
      else if (!printing_index)
        add_char ('`');
a810 2
  else if (html)
    insert_html_tag (arg, "code");
d813 2
d816 6
a821 2
        add_meta_char ('\'');
    }
d826 1
a826 2
cm_kbd (arg)
     int arg;
d846 1
d848 1
a848 1
cm_url (arg, start, end)
d855 4
a858 3
        add_word ("&lt;<code>");
      else
	add_word ("</code>&gt;");
d868 1
a868 2
cm_key (arg)
     int arg;
d880 1
a880 2
not_fixed_width (arg)
     int arg;
d888 1
a888 2
cm_var (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
d913 1
a913 2
cm_sc (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
d919 1
a919 1
  not_fixed_width (arg);
d921 8
a928 8
  if (arg == START)
    {
      if (html)
	insert_html_tag (arg, small_tag);
    }
  else
    {
      int all_upper;
d930 2
a931 2
      if (html)
        start_pos += sizeof (small_tag) + 2 - 1; /* skip <small> */
d933 15
a947 3
      /* Avoid the warning below if there's no text inside @@sc{}, or
         when processing menus under --no-headers.  */
      all_upper = start_pos < end_pos;
d949 2
a950 7
      while (start_pos < end_pos)
        {
          unsigned char c = output_paragraph[start_pos];
          if (!isupper (c))
            all_upper = 0;
          output_paragraph[start_pos] = coerce_to_upper (c);
          start_pos++;
a951 6
      if (all_upper)
        warning (_("@@sc argument all uppercase, thus no effect"));
        
      if (html)
	insert_html_tag (arg, small_tag);
    }
d956 1
a956 2
cm_dfn (arg, position)
     int arg, position;
d972 1
a972 2
cm_emph (arg)
     int arg;
d983 1
a983 2
cm_verb (arg)
     int arg;
d986 1
a986 1
  int delimiter;
d994 1
a994 1
    add_word ("<pre>");
d1016 14
a1029 6
        line_number++;
      /*
	Assume no newlines in END_VERBATIM
      */
      else if (character == delimiter)
	{
d1035 3
a1037 1
      add_char (character);
d1054 3
a1056 1
    add_word ("</pre>");
d1059 1
d1061 1
a1061 2
cm_strong (arg, position)
     int arg, position;
d1063 3
a1065 1
  if (xml)
d1071 9
d1083 1
a1083 2
cm_cite (arg, position)
     int arg, position;
d1100 1
a1100 2
cm_not_fixed_width (arg, start, end)
     int arg, start, end;
d1108 1
a1108 2
cm_i (arg)
     int arg;
d1110 6
a1115 1
  if (xml)
d1124 1
a1124 2
cm_b (arg)
     int arg;
d1126 7
a1132 1
  if (xml)
d1141 1
a1141 2
cm_r (arg)
     int arg;
d1143 5
a1147 1
  if (xml)
d1149 2
d1152 2
a1153 2
    {
      extern int printing_index;
d1155 9
a1163 10
      /* People use @@r{} in index entries like this:
	 
      @@findex foo@@r{, some text}
      
      This is supposed to produce output as if the entry were saying
      "@@code{foo}, some text", since the "fn" index is typeset as
      @@code.  The following attempts to do the same in HTML.  Note that
      this relies on the fact that only @@code bumps up the variable
      in_fixed_width_font while processing index entries in HTML mode.  */
      if (html && printing_index)
d1165 5
a1169 4
	  int level = in_fixed_width_font;
	  
	  while (level--)
	    insert_html_tag (arg == START ? END : START, "code");
d1171 1
a1171 3
      
      not_fixed_width (arg);
    }
d1174 3
d1178 1
a1178 2
cm_titlefont (arg)
     int arg;
d1180 2
a1181 4
  if (xml)
    xml_insert_element (TITLEFONT, arg);
  else
  not_fixed_width (arg);
d1186 1
a1186 1
cm_no_op ()
d1193 1
a1193 1
cm_novalidate ()
d1201 1
a1201 2
cm_w (arg, start, end)
     int arg, start, end;
d1206 8
a1213 1
    non_splitting_words--;
d1217 15
d1235 1
a1235 2
cm_obsolete (arg, start, end)
     int arg, start, end;
d1242 2
a1243 2
/* This says to inhibit the indentation of the next paragraph, but
   not of following paragraphs.  */
d1245 1
a1245 1
cm_noindent ()
d1251 34
d1288 1
a1288 1
   Another option: ignore it, since they don't *really* want to
d1292 1
a1292 1
cm_setfilename ()
d1303 1
a1303 1
cm_settitle ()
d1309 1
d1312 1
d1322 1
a1322 2
cm_ignore_arg (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
d1330 1
a1330 1
cm_ignore_line ()
d1337 1
a1337 1
cm_sp ()
d1342 3
a1344 1
  get_rest_of_line (1, &line);
d1352 2
d1357 1
d1360 15
a1374 9
	{
	  /* Must disable filling since otherwise multiple newlines is like
         multiple spaces.  Must close paragraph since that's what the
         manual says and that's what TeX does.  */
      int save_filling_enabled = filling_enabled;
      filling_enabled = 0;
      
      /* close_paragraph generates an extra blank line.  */
      close_single_paragraph ();
d1376 2
a1377 2
      if (lines && html && !executing_string)
	html_output_head ();
d1379 2
a1380 7
      while (lines--)
	{
	  if (html)
	    insert_string ("<br><p>\n");
	  else
	    add_char ('\n');
	}
d1382 2
a1383 2
      filling_enabled = save_filling_enabled;
    }
d1390 1
a1390 1
cm_dircategory ()
d1424 1
a1424 1
cm_center ()
d1437 34
a1470 5
  int i, start, length;
  unsigned char *line;
  int save_indented_fill = indented_fill;
  int save_filling_enabled = filling_enabled;
  int fudge_factor = 1;
d1472 8
a1479 3
  filling_enabled = indented_fill = 0;
  cm_noindent ();
  start = output_paragraph_offset;
d1481 3
a1483 2
  if (html)
    add_word ("<div align=\"center\">");
d1485 6
a1490 38
  inhibit_output_flushing ();
  get_rest_of_line (0, (char **)&line);
  execute_string ("%s", (char *)line);
  free (line);
  uninhibit_output_flushing ();
   if (html)
    add_word ("</div>");

   else
     {
       i = output_paragraph_offset - 1;
       while (i > (start - 1) && output_paragraph[i] == '\n')
	 i--;

       output_paragraph_offset = ++i;
       length = output_paragraph_offset - start;

       if (length < (fill_column - fudge_factor))
	 {
	   line = xmalloc (1 + length);
	   memcpy (line, (char *)(output_paragraph + start), length);

	   i = (fill_column - fudge_factor - length) / 2;
	   output_paragraph_offset = start;

	   while (i--)
	     insert (' ');

	   for (i = 0; i < length; i++)
	     insert (line[i]);

	   free (line);
	 }
     }

  insert ('\n');
  filling_enabled = save_filling_enabled;
  indented_fill = save_indented_fill;
d1496 1
a1496 2
cm_result (arg)
     int arg;
d1504 1
a1504 2
cm_expansion (arg)
     int arg;
d1512 1
a1512 2
cm_equiv (arg)
     int arg;
d1520 1
a1520 2
cm_print (arg)
     int arg;
d1528 1
a1528 2
cm_error (arg)
     int arg;
d1536 1
a1536 2
cm_point (arg)
     int arg;
d1545 1
a1545 1
cm_exdent ()
d1551 1
a1551 1
  /* Read argument  */
d1567 4
d1579 6
d1589 2
d1599 1
a1599 2
handle_include (verbatim_include)
  int verbatim_include;
d1601 1
a1601 1
  char *filename;
d1606 8
a1613 2
  close_paragraph ();
  get_rest_of_line (0, &filename);
a1636 2
      extern int errno;

d1664 1
a1664 1
cm_verbatiminclude ()
d1672 1
a1672 1
cm_include ()
d1681 1
a1681 1
cm_bye ()
a1683 1
  flush_output ();
d1690 1
a1690 1
cm_paragraphindent ()
d1701 1
d1704 1
a1704 2
set_default_indentation_increment (string)
     char *string;
d1709 2
a1710 2
    default_indentation_increment = 0;
  else if (sscanf (string, "%d", &default_indentation_increment) != 1)
d1716 1
a1716 1
cm_exampleindent ()
d1721 31
a1751 1
  if (set_default_indentation_increment (arg) != 0)
d1755 61
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   $Id: cmds.c,v 1.1.1.2 2002/06/10 13:21:15 espie Exp $
@


1.1.2.1
log
@(stripped down to actually needed files) pristine GNU texinfo 4.7
@
text
@d2 1
a2 1
   $Id: cmds.c,v 1.47 2004/04/07 20:17:38 karl Exp $
d4 1
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
a24 1
#include "html.h"
d40 34
d75 1
a75 4
static void cm_exampleindent (void),
     cm_firstparagraphindent (void),
     cm_paragraphindent (void),
     cm_novalidate (void);
d78 4
a81 2
static void cm_obsolete (int arg, int start, int end),
     not_fixed_width (int arg);
d88 1
a88 1
  { "!", cm_punct, NO_BRACE_ARGS },
d94 2
a95 3
  { ".", cm_punct, NO_BRACE_ARGS },
  { "/", cm_no_op, NO_BRACE_ARGS },
  { ":", cm_colon, NO_BRACE_ARGS },
d97 1
a97 1
  { "?", cm_punct, NO_BRACE_ARGS },
a109 1
  { "LaTeX", cm_LaTeX, BRACE_ARGS },
a127 1
  { "author", cm_author, NO_BRACE_ARGS },
d131 1
a131 2
  { "c", cm_comment, NO_BRACE_ARGS },
  { "caption", cm_caption, BRACE_ARGS },
a140 1
  { "comma", cm_comma, BRACE_ARGS },
d142 1
a142 1
  { "comment", cm_comment, NO_BRACE_ARGS },
a167 2
  { "deftypecv", cm_defun, NO_BRACE_ARGS },
  { "deftypecvx", cm_defun, NO_BRACE_ARGS },
d193 1
a193 2
  { "dmn", cm_dmn, BRACE_ARGS },
  { "docbook", cm_docbook, NO_BRACE_ARGS },
a219 2
  { "firstparagraphindent", cm_firstparagraphindent, NO_BRACE_ARGS },
  { "float", cm_float, NO_BRACE_ARGS },
a228 1
  { "headitem", cm_headitem, NO_BRACE_ARGS },
a233 1
  { "ifdocbook", cm_ifdocbook, NO_BRACE_ARGS },
a235 1
  { "ifnotdocbook", cm_ifnotdocbook, NO_BRACE_ARGS },
a239 1
  { "ifnotxml", cm_ifnotxml, NO_BRACE_ARGS },
a242 1
  { "ifxml", cm_ifxml, NO_BRACE_ARGS },
a245 2
  { "indent", cm_indent, NO_BRACE_ARGS },
  { "indicateurl", cm_indicate_url, BRACE_ARGS },
a256 1
  { "listoffloats", cm_listoffloats, NO_BRACE_ARGS },
d260 1
a260 1
  { "math", cm_math, BRACE_ARGS },
d266 2
a267 2
  { "noindent", cm_noindent_cmd, NO_BRACE_ARGS },
  { "novalidate", cm_novalidate, NO_BRACE_ARGS },
a273 2
  { "ordf", cm_special_char, BRACE_ARGS },
  { "ordm", cm_special_char, BRACE_ARGS },
a288 1
  { "registeredsymbol", cm_registeredsymbol, BRACE_ARGS },
d302 1
a302 2
  { "shortcaption", cm_caption, BRACE_ARGS },
  { "shortcontents", cm_contents, NO_BRACE_ARGS },
d316 1
a316 2
  { "subtitle", cm_titlepage_cmds, NO_BRACE_ARGS },
  { "summarycontents", cm_contents, NO_BRACE_ARGS },
a322 1
  { "tie", cm_tie, BRACE_ARGS },
a324 1
  { "title", cm_titlepage_cmds, NO_BRACE_ARGS },
d326 1
a326 1
  { "titlepage", cm_titlepage, NO_BRACE_ARGS },
d338 1
a338 1
  { "url", cm_uref, BRACE_ARGS },
a346 1
  { "vskip", cm_ignore_line, NO_BRACE_ARGS },
a347 1
  { "xml", cm_xml, NO_BRACE_ARGS },
d376 2
a377 1
insert_self (int arg)
d384 2
a385 1
insert_space (int arg)
d390 1
a390 1
        xml_insert_entity ("space");
d392 1
a392 1
        add_char (' ');
a395 10
/* Insert a comma.  Useful when a literal , would break our parsing of
   multiple arguments.  */
void
cm_comma (int arg)
{
  if (arg == START)
    add_char (',');
}


d398 1
a398 1
cm_asterisk (void)
d415 2
a416 1
cm_dots (int arg)
d421 1
a421 1
        xml_insert_entity ("dots");
d423 1
a423 1
        xml_insert_entity ("hellip");
d425 1
a425 4
	if (html && !in_fixed_width_font)
	  insert_string ("<small class=\"dots\">...</small>");
	else
	  add_word ("...");
d431 2
a432 1
cm_enddots (int arg)
d444 1
a444 4
	if (html && !in_fixed_width_font)
	  insert_string ("<small class=\"enddots\">....</small>");
	else
	  add_word ("....");
d449 2
a450 1
cm_bullet (int arg)
d455 1
a455 1
        add_word ("&bull;");
d466 2
a467 1
cm_minus (int arg)
a472 2
      else if (html)
        add_word ("&minus;");
a477 13
/* Formatting a dimension unit.  */
void
cm_dmn (int arg)
{
  if (html)
    insert_html_tag_with_attribute (arg, "span", "class=\"dmn\"");
  else if (docbook)
    /* No units in docbook yet.  */
    ;
  else if (xml)
    xml_insert_element (DIMENSION, arg);
}

d480 2
a481 1
cm_TeX (int arg)
a482 2
  static int last_position;

d485 1
a485 1
      if (xml)
a488 29

      last_position = output_paragraph_offset;
    }
  else if (last_position != output_paragraph_offset)
    {
      warning (_("arguments to @@%s ignored"), command);
      output_paragraph_offset = last_position;
    }
}

/* Insert "LaTeX".  */
void
cm_LaTeX (int arg)
{
  static int last_position;

  if (arg == START)
    {
      if (xml)
        xml_insert_entity ("latex");
      else
        add_word ("LaTeX");

      last_position = output_paragraph_offset;
    }
  else if (last_position != output_paragraph_offset)
    {
      warning (_("arguments to @@%s ignored"), command);
      output_paragraph_offset = last_position;
d494 2
a495 1
cm_copyright (int arg)
a509 1
/* Registered symbol.  */
d511 2
a512 17
cm_registeredsymbol (int arg)
{
  if (arg == START)
    {
      if (html)
        add_word ("&reg;");
      else if (docbook)
        xml_insert_entity ("reg");
      else if (xml && !docbook)
        xml_insert_entity ("registered");
      else
        add_word ("(R)");
    }
}

void
cm_today (int arg)
d528 2
a529 61
cm_comment (void)
{
  /* For HTML, do not output comments before HTML header is written,
     otherwise comments before @@settitle cause an empty <title> in the
     header.  */
  if ((html && html_output_head_p) || xml)
    {
      char *line;
      get_rest_of_line (0, &line);

      if (strlen (line) > 0)
        {
          int save_inhibit_indentation = inhibit_paragraph_indentation;
          int save_paragraph_is_open = paragraph_is_open;
          int save_escape_html = escape_html;
          int save_xml_no_para = xml_no_para;
          int i;

          inhibit_paragraph_indentation = 1;
          escape_html = 0;
          xml_no_para = 1;

          /* @@c and @@comment can appear between @@item and @@itemx,
             @@deffn and @@deffnx.  */
          xml_dont_touch_items_defs++;

          /* Use insert for HTML, and XML when indentation is enabled.
             For Docbook, use add_char.  */
          if (xml && xml_indentation_increment > 0
              && output_paragraph[output_paragraph_offset-1] != '\n')
            insert ('\n');

          /* Crunch double hyphens in comments.  */
          add_html_block_elt ("<!-- ");
          for (i = 0; i < strlen (line); i++)
            if (line[i] != '-' || (i && line[i-1] != '-'))
              add_char (line[i]);
          add_word (" -->");

          if (html)
            add_char ('\n');

          inhibit_paragraph_indentation = save_inhibit_indentation;
          paragraph_is_open = save_paragraph_is_open;
          escape_html = save_escape_html;
          xml_no_para = save_xml_no_para;
          xml_dont_touch_items_defs--;
        }

      free (line);
    }
  else
    cm_ignore_line ();
}

/* We keep acronyms with two arguments around, to be able to refer to them
   later with only one argument.  */
static ACRONYM_DESC *acronyms_stack = NULL;

void
cm_acronym (int arg)
a530 45
  char *acronym, *description;
  unsigned len;

  /* We do everything at START.  */
  if (arg == END)
    return;

  get_until_in_braces (",", &acronym);
  if (input_text[input_text_offset] == ',')
    input_text_offset++;
  get_until_in_braces ("}", &description);

  canon_white (acronym);
  canon_white (description);

  /* If not enclosed in braces, strip after comma to be compatible
     with texinfo.tex.  */
  if (description[0] != '{' && index (description, ',') != NULL)
    {
      int i = 0;
      while (description[i] != ',')
        i++;
      /* For now, just terminate the string at comma.  */
      description[i] = '\0';
    }

  /* Get description out of braces.  */
  if (description[0] == '{')
    description++;

  len = strlen (description);
  if (len && description[len-1] == '}')
    description[len-1] = '\0';

  /* Save new description.  */
  if (strlen (description) > 0)
    {
      ACRONYM_DESC *new = xmalloc (sizeof (ACRONYM_DESC));

      new->acronym = xstrdup (acronym);
      new->description = xstrdup (description);
      new->next = acronyms_stack;
      acronyms_stack = new;
    }

d532 1
a532 33
    {
      add_word ("<acronym");

      if (strlen (description) > 0)
        add_word_args (" title=\"%s\"", text_expansion (description));
      else if (acronyms_stack)
        {
          /* No second argument, get from previous.  Search order is from
             last to first defined, so we get the most recent version of
             the description.  */
          ACRONYM_DESC *temp = acronyms_stack;

          while (temp)
            {
              if (STREQ (acronym, temp->acronym) && strlen (temp->description) > 0)
                {
                  add_word_args (" title=\"%s\"", text_expansion (temp->description));
                  break;
                }
              temp = temp->next;
            }
        }

      add_char ('>');
      execute_string ("%s", acronym);
      add_word ("</acronym>");
    }
  else if (docbook)
    {
      xml_insert_element (ACRONYM, START);
      execute_string ("%s", acronym);
      xml_insert_element (ACRONYM, END);
    }
d534 1
a534 23
    {
      xml_insert_element (ACRONYM, START);

      xml_insert_element (ACRONYMWORD, START);
      execute_string ("%s", acronym);
      xml_insert_element (ACRONYMWORD, END);

      if (strlen (description) > 0)
        {
          xml_insert_element (ACRONYMDESC, START);
          execute_string ("%s", description);
          xml_insert_element (ACRONYMDESC, END);
        }

      xml_insert_element (ACRONYM, END);
    }
  else
    execute_string ("%s", acronym);

  /* Put description into parenthesis after the acronym for all outputs
     except XML.  */
  if (strlen (description) > 0 && (!xml || docbook))
    add_word_args (" (%s)", description);
d538 2
a539 1
cm_tt (int arg)
d549 2
a550 1
cm_code (int arg)
a551 3
  if (arg == START)
    in_fixed_width_font++;

d553 2
d556 3
a558 26
      if (STREQ (command, "command"))
	xml_insert_element (COMMAND_TAG, arg);
      else if (STREQ (command, "env"))
	xml_insert_element (ENV, arg);
      else if (STREQ (command, "file"))
	xml_insert_element (FILE_TAG, arg);
      else if (STREQ (command, "option"))
	xml_insert_element (OPTION, arg);
      else if (STREQ (command, "samp"))
        {
          if (docbook && arg == START)
            {
              /* Even though @@samp is in_fixed_width_font, it
                 should always start a paragraph.  Unfortunately,
                 in_fixed_width_font inhibits that.  */
              xml_start_para ();
              xml_insert_entity ("lsquo");
            }
          xml_insert_element (SAMP, arg);
          if (docbook && arg == END)
            xml_insert_entity ("rsquo");
        }
      else
	xml_insert_element (CODE, arg);
    }
  else if (html)
d560 3
a562 1
      if (STREQ (command, "code"))
d564 2
a565 2
      else
        insert_html_tag_with_attribute (arg, "span", "class=\"%s\"", command);
d567 2
a570 2
      extern int printing_index;

d572 2
a573 6
        {
          if (arg == START)
            add_char ('`');
          else
            add_meta_char ('\'');
        }
d578 2
a579 1
cm_kbd (int arg)
a598 1
/* Just show a url (http://example.org/..., for example), don't link to it.  */
d600 1
a600 1
cm_indicate_url (int arg, int start, int end)
d607 3
a609 4
        add_word ("&lt;");
      insert_html_tag (arg, "code");
      if (arg != START)
        add_word ("&gt;");
d619 2
a620 1
cm_key (int arg)
d632 2
a633 1
not_fixed_width (int arg)
d641 2
a642 1
cm_var (int arg, int start_pos, int end_pos)
d667 2
a668 1
cm_sc (int arg, int start_pos, int end_pos)
d674 1
a674 1
      not_fixed_width (arg);
d676 8
a683 8
      if (arg == START)
        {
          if (html)
            insert_html_tag_with_attribute (arg, "span", "class=\"sc\"");
        }
      else
        {
          int all_upper;
d685 2
a686 2
          if (html)
            start_pos += sizeof ("<span class=\"sc\">") - 1; /* skip <span> */
d688 3
a690 15
          /* Avoid the warning below if there's no text inside @@sc{}, or
             when processing menus under --no-headers.  */
          all_upper = start_pos < end_pos;

          while (start_pos < end_pos)
            {
              unsigned char c = output_paragraph[start_pos];
              if (!isupper (c))
                all_upper = 0;
              if (!html)
                output_paragraph[start_pos] = coerce_to_upper (c);
              start_pos++;
            }
          if (all_upper)
            warning (_("@@sc argument all uppercase, thus no effect"));
d692 7
a698 2
          if (html)
            insert_html_tag (arg, "span");
d700 6
d710 2
a711 1
cm_dfn (int arg, int position)
d727 2
a728 1
cm_emph (int arg)
d739 2
a740 1
cm_verb (int arg)
d743 1
a743 1
  int delimiter = 0; /* avoid warning */
d751 1
a751 1
    add_word ("<tt>");
d773 6
a778 14
        {
          line_number++;
          if (html)
            add_word ("<br>\n");
        }

      else if (html && character == '<')
        add_word ("&lt;");

      else if (html && character == '&')
        add_word ("&amp;");

      else if (character == delimiter && input_text[input_text_offset+1] == '}')
	{ /* Assume no newlines in END_VERBATIM. */
d784 1
a784 3
      else
        add_char (character);

d801 1
a801 3
    add_word ("</tt>");

  in_fixed_width_font--;
a803 1

d805 2
a806 1
cm_strong (int arg, int start_pos, int end_pos)
d808 1
a808 3
  if (docbook && arg == START)
    xml_insert_element_with_attribute (B, arg, "role=\"bold\"");
  else if (xml)
a813 9
  
  if (!xml && !html && !docbook && !no_headers
      && arg == END
      && end_pos - start_pos >= 6
      && strncmp ((char *) output_paragraph + start_pos, "*Note:*", 6) == 0)
    /* Translators: "Note:" is literal here and should not be
       translated.  @@strong{Nota}, say, does not cause the problem.  */
    warning (_("@@strong{Note:} produces a spurious cross-reference in Info; reword to avoid that"));

d817 2
a818 1
cm_cite (int arg, int position)
d835 2
a836 1
cm_not_fixed_width (int arg, int start, int end)
d844 2
a845 1
cm_i (int arg)
d847 1
a847 6
  /* Make use of <lineannotation> of Docbook, if we are
     inside an @@example or similar.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
d856 2
a857 1
cm_b (int arg)
d859 1
a859 7
  /* See cm_i comments.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (docbook && arg == START)
    xml_insert_element_with_attribute (B, arg, "role=\"bold\"");
  else if (xml)
d868 2
a869 1
cm_r (int arg)
d871 1
a871 5
  /* See cm_i comments.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
a872 2
  else if (html)
    insert_html_tag_with_attribute (arg, "span", "class=\"roman\"");
d874 22
a895 1
    not_fixed_width (arg);
d899 2
a900 1
cm_titlefont (int arg)
d905 1
a905 21
   {
     not_fixed_width (arg);
     if (html)
	{
	  html_title_written = 1; /* suppress title from @@settitle */
	  if (arg == START)
	    add_word ("<h1 class=\"titlefont\">");
	  else
	    add_word ("</h1>\n");
	}
   }
}


/* Unfortunately, we cannot interpret @@math{} contents like TeX does.  We just
   pass them through.  */
void
cm_math (int arg)
{
  if (xml && !docbook)
    xml_insert_element (MATH, arg);
d910 1
a910 1
cm_no_op (void)
d917 1
a917 1
cm_novalidate (void)
d925 2
a926 1
cm_w (int arg)
d931 1
a931 8
    {
      if (docbook || html || xml)
        /* This is so @@w{$}Log$ doesn't end up as <dollar>Log<dollar>
           in the output.  */
        insert_string ("<!-- /@@w -->");
        
      non_splitting_words--;
    }
a934 15
/* An unbreakable word space.  Same as @@w{ } for makeinfo, but different
   for TeX (the space stretches and stretches, and does not inhibit
   hyphenation).  */
void
cm_tie (int arg)
{
  if (arg == START)
    {
      cm_w (START);
      add_char (' ');
    }
  else
    cm_w (END);
}

d938 2
a939 1
cm_obsolete (int arg, int start, int end)
d946 2
a947 2
/* Inhibit the indentation of the next paragraph, but not of following
   paragraphs.  */
d949 1
a949 1
cm_noindent (void)
a954 34
void
cm_noindent_cmd (void)
{
  cm_noindent ();
  xml_no_indent = 1;
  skip_whitespace_and_newlines();

  if (xml)
    xml_start_para ();
  else if (html && !paragraph_is_open)
    add_html_block_elt ("<p class=\"noindent\">");
  else
    {
      paragraph_is_open = 0;
      start_paragraph ();
    }
}

/* Force indentation of the next paragraph. */
void
cm_indent (void)
{
  inhibit_paragraph_indentation = 0;
  xml_no_indent = 0;
  skip_whitespace_and_newlines();
  
  if (xml)
    xml_start_para ();
  else if (html && !paragraph_is_open)
    add_html_block_elt ("<p class=\"indent\">");
  else
    start_paragraph ();
}

d958 1
a958 1
   Another option: ignore it, since they don't really want to
d962 1
a962 1
cm_setfilename (void)
d973 1
a973 1
cm_settitle (void)
a978 1
      xml_in_book_title = 1;
a980 1
      xml_in_book_title = 0;
d990 2
a991 1
cm_ignore_arg (int arg, int start_pos, int end_pos)
d999 1
a999 1
cm_ignore_line (void)
d1006 1
a1006 1
cm_sp (void)
d1011 1
a1011 3
  /* Due to tricky stuff in execute_string(), @@value{} can't be expanded.
     So there is really no reason to enable expansion for @@sp parameters.  */
  get_rest_of_line (0, &line);
a1018 2
          /* @@sp can appear between @@item and @@itemx, @@deffn and @@deffnx.  */
          xml_dont_touch_items_defs++;
a1021 1
          xml_dont_touch_items_defs--;
d1024 9
a1032 6
        {
          /* Must disable filling since otherwise multiple newlines is like
             multiple spaces.  Must close paragraph since that's what the
             manual says and that's what TeX does.  */
          int save_filling_enabled = filling_enabled;
          filling_enabled = 0;
d1034 2
a1035 2
          /* close_paragraph generates an extra blank line.  */
          close_single_paragraph ();
d1037 7
a1043 2
          if (lines && html && !executing_string)
            html_output_head ();
d1045 2
a1046 11
          if (html)
            add_html_block_elt ("<pre class=\"sp\">\n");

          while (lines--)
            add_char ('\n');

          if (html)
            add_html_block_elt ("</pre>\n");

          filling_enabled = save_filling_enabled;
        }
d1053 1
a1053 1
cm_dircategory (void)
d1087 1
a1087 1
cm_center (void)
d1100 5
a1104 5
      int i, start, length;
      unsigned char *line;
      int save_indented_fill = indented_fill;
      int save_filling_enabled = filling_enabled;
      int fudge_factor = 1;
d1106 3
a1108 3
      filling_enabled = indented_fill = 0;
      cm_noindent ();
      start = output_paragraph_offset;
d1110 2
a1111 2
      if (html)
        add_html_block_elt ("<div align=\"center\">");
d1113 38
a1150 41
      inhibit_output_flushing ();
      get_rest_of_line (0, (char **)&line);
      execute_string ("%s", (char *)line);
      free (line);
      uninhibit_output_flushing ();
      if (html)
        add_html_block_elt ("</div>");

       else
         {
           i = output_paragraph_offset - 1;
           while (i > (start - 1) && output_paragraph[i] == '\n')
             i--;

           output_paragraph_offset = ++i;
           length = output_paragraph_offset - start;

           if (length < (fill_column - fudge_factor))
             {
               line = xmalloc (1 + length);
               memcpy (line, (char *)(output_paragraph + start), length);

               i = (fill_column - fudge_factor - length) / 2;
               output_paragraph_offset = start;

               while (i--)
                 insert (' ');

               for (i = 0; i < length; i++)
                 insert (line[i]);

               free (line);
             }
         }

      insert ('\n');
      filling_enabled = save_filling_enabled;
      indented_fill = save_indented_fill;
      close_single_paragraph ();
      if (looking_at("\n"))
        insert ('\n');
d1156 2
a1157 1
cm_result (int arg)
d1165 2
a1166 1
cm_expansion (int arg)
d1174 2
a1175 1
cm_equiv (int arg)
d1183 2
a1184 1
cm_print (int arg)
d1192 2
a1193 1
cm_error (int arg)
d1201 2
a1202 1
cm_point (int arg)
d1211 1
a1211 1
cm_exdent (void)
d1217 1
a1217 1
  /* Read argument.  */
a1232 4
  else if (docbook)
    xml_insert_element (LINEANNOTATION, START);
  else if (xml)
    xml_insert_element (EXDENT, START);
a1240 6
  else if (xml)
    {
      xml_insert_element (docbook ? LINEANNOTATION : EXDENT, END);
      insert ('\n');
    }

a1244 2
  if (!xml)
    start_paragraph ();
d1253 2
a1254 1
handle_include (int verbatim_include)
d1256 1
a1256 1
  char *arg, *filename;
d1261 2
a1262 8
  if (!insertion_stack)
    close_paragraph ();  /* No blank lines etc. if not at outer level.  */
    
  get_rest_of_line (0, &arg);
  /* We really only want to expand @@value, but it's easier to just do
     everything.  TeX will only work with @@value.  */
  filename = text_expansion (arg);
  free (arg);
d1286 2
d1315 1
a1315 1
cm_verbatiminclude (void)
d1323 1
a1323 1
cm_include (void)
d1332 1
a1332 1
cm_bye (void)
d1335 1
d1342 1
a1342 1
cm_paragraphindent (void)
a1352 1

d1355 2
a1356 1
set_example_indentation_increment (char *string)
d1361 2
a1362 2
    example_indentation_increment = 0;
  else if (sscanf (string, "%d", &example_indentation_increment) != 1)
d1368 1
a1368 1
cm_exampleindent (void)
d1373 1
a1373 31
  if (set_example_indentation_increment (arg) != 0)
    line_error (_("Bad argument to @@%s"), command);

  if (input_text[input_text_offset] == '\n')
    close_single_paragraph ();

  free (arg);
}


/* @@firstparagraphindent: suppress indentation in first paragraphs after
   headings. */
static int
set_firstparagraphindent (char *string)
{
  if (STREQ (string, "insert") || STREQ (string, _("insert")))
    do_first_par_indent = 1;
  else if (STREQ (string, "none") || STREQ (string, _("none")))
    do_first_par_indent = 0;
  else
    return -1;
  return 0;
}

static void
cm_firstparagraphindent (void)
{
  char *arg;

  get_rest_of_line (1, &arg);
  if (set_firstparagraphindent (arg) != 0)
a1376 61
}

/* For DocBook and XML, produce &period; for `.@@:'. This gives the processing
   software a fighting chance to treat it specially by not adding extra space.
  
   Do this also for ?, !, and :.  */
void
cm_colon (void)
{
  if (xml)
    {
      if (strchr (".?!:", input_text[input_text_offset-3]) != NULL)
        {
          /* Erase literal character that's there, except `>', which is
             part of the XML tag.  */
          if (output_paragraph[output_paragraph_offset-1] != '>')
            output_paragraph_offset--;

          switch (input_text[input_text_offset-3])
            {
            case '.':
              xml_insert_entity ("period");
              break;
            case '?':
              xml_insert_entity ("quest");
              break;
            case '!':
              xml_insert_entity ("excl");
              break;
            case ':':
              xml_insert_entity ("colon");
              break;
            }
        }
    }
}

/* Ending sentences explicitly.  Currently, only outputs entities for XML
   output, for other formats it calls insert_self.  */
void
cm_punct (int arg)
{
  if (xml && !docbook)
    {
      switch (input_text[input_text_offset-1])
        {
        case '.':
          xml_insert_entity ("eosperiod");
          break;
        case '?':
          xml_insert_entity ("eosquest");
          break;
        case '!':
          xml_insert_entity ("eosexcl");
          break;
        }
    }
  else
    {
      insert_self (arg);
    }
@


1.1.2.2
log
@GNU Texinfo 4.8 here, too
@
text
@d2 1
a2 1
   $Id: cmds.c,v 1.55 2004/12/14 00:15:36 karl Exp $
a84 1
  { "abbr", cm_abbr, BRACE_ARGS },
a184 1
  { "euro", cm_special_char, BRACE_ARGS },
a282 1
  { "sansserif", cm_sansserif, BRACE_ARGS },
a294 1
  { "slanted", cm_slanted, BRACE_ARGS },
a648 2


d653 2
a654 2
static void
cm_acronym_or_abbr (int arg, int is_abbr)
d656 1
a656 1
  char *aa, *description;
d663 1
a663 1
  get_until_in_braces (",", &aa);
d668 1
a668 1
  canon_white (aa);
d673 1
a673 1
  if (description[0] != '{' && strchr (description, ',') != NULL)
d679 1
a679 1
      description[i] = 0;
d688 1
a688 1
    description[len-1] = 0;
d695 1
a695 1
      new->acronym = xstrdup (aa);
d703 1
a703 1
      add_word (is_abbr ? "<abbr" : "<acronym");
d716 1
a716 2
              if (STREQ (aa, temp->acronym)
                  && strlen (temp->description) > 0)
d718 1
a718 2
                  add_word_args (" title=\"%s\"",
                                 text_expansion (temp->description));
d726 2
a727 2
      execute_string ("%s", aa);
      add_word (is_abbr ? "</abbr>" : "</acronym>");
d731 3
a733 3
      xml_insert_element (is_abbr ? ABBREV : ACRONYM, START);
      execute_string ("%s", aa);
      xml_insert_element (is_abbr ? ABBREV : ACRONYM, END);
d737 1
a737 1
      xml_insert_element (is_abbr ? ABBREV : ACRONYM, START);
d739 3
a741 3
      xml_insert_element (is_abbr ? ABBREVWORD : ACRONYMWORD, START);
      execute_string ("%s", aa);
      xml_insert_element (is_abbr ? ABBREVWORD : ACRONYMWORD, END);
d745 1
a745 1
          xml_insert_element (is_abbr ? ABBREVDESC : ACRONYMDESC, START);
d747 1
a747 1
          xml_insert_element (is_abbr ? ABBREVDESC : ACRONYMDESC, END);
d750 1
a750 1
      xml_insert_element (is_abbr ? ABBREV : ACRONYM, END);
d753 1
a753 1
    execute_string ("%s", aa);
a761 12
cm_acronym (int arg)
{
  cm_acronym_or_abbr (arg, 0);
}

void
cm_abbr (int arg)
{
  cm_acronym_or_abbr (arg, 1);
}

void
d809 1
a809 13
        { /* Use <samp> tag in general to get typewriter.  */
          if (arg == START)
            { /* If @@samp specifically, add quotes a la TeX output.  */
              if (STREQ (command, "samp")) add_char ('`');
              add_word ("<samp>");
            }
          insert_html_tag_with_attribute (arg, "span", "class=\"%s\"",command);
          if (arg == END)
            {
              add_word ("</samp>");
              if (STREQ (command, "samp")) add_char ('\'');
            }
        }
d1075 5
a1079 9
      && (STRNCASEEQ ((char *) output_paragraph + start_pos, "*Note:", 6)
          || STRNCASEEQ ((char *) output_paragraph + start_pos, "*Note ", 6)))
    {
      /* Translators: "Note:" is literal here and should not be
         translated.  @@strong{Nota}, say, does not cause the problem.  */
      warning (_("@@strong{Note...} produces a spurious cross-reference in Info; reword to avoid that"));
      /* Adjust the output to avoid writing the bad xref.  */
      output_paragraph[start_pos + 5] = '_';
    }
a1123 16
cm_slanted (int arg)
{
  /* Make use of <lineannotation> of Docbook, if we are
     inside an @@example or similar.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
    xml_insert_element (SLANTED, arg);
  else if (html)
    insert_html_tag (arg, "i");
  else
    not_fixed_width (arg);
}

void
a1155 15
cm_sansserif (int arg)
{
  /* See cm_i comments.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
    xml_insert_element (SANSSERIF, arg);
  else if (html)
    insert_html_tag_with_attribute (arg, "span", "class=\"sansserif\"");
  else
    not_fixed_width (arg);
}

void
d1428 1
a1428 1
      char *line;
d1430 2
a1431 2
      get_rest_of_line (0, &line);
      execute_string ("%s", line);
d1438 1
a1438 1
      char *line;
d1451 2
a1452 2
      get_rest_of_line (0, &line);
      execute_string ("%s", line);
d1635 1
a1635 1
  if (!find_and_load (filename, 1))
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
