head	1.3;
access;
symbols
	binutils-2_15:1.1.2.2
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.21.17.48;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.05.10;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.40.52;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.40.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.30.09;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.43.35;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.09.23;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* gmon_io.c - Input and output from/to gmon.out files.

   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "gprof.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "cg_arcs.h"
#include "basic_blocks.h"
#include "corefile.h"
#include "call_graph.h"
#include "gmon_io.h"
#include "gmon_out.h"
#include "gmon.h"		/* Fetch header for old format.  */
#include "hertz.h"
#include "hist.h"
#include "libiberty.h"

enum gmon_ptr_size {
  ptr_32bit,
  ptr_64bit
};

enum gmon_ptr_signedness {
  ptr_signed,
  ptr_unsigned
};

static enum gmon_ptr_size gmon_get_ptr_size PARAMS ((void));
static enum gmon_ptr_signedness gmon_get_ptr_signedness PARAMS ((void));

#ifdef BFD_HOST_U_64_BIT
static int gmon_io_read_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT *));
static int gmon_io_write_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT));
#endif
static int gmon_read_raw_arc
  PARAMS ((FILE *, bfd_vma *, bfd_vma *, unsigned long *));
static int gmon_write_raw_arc
  PARAMS ((FILE *, bfd_vma, bfd_vma, unsigned long));

int gmon_input = 0;
int gmon_file_version = 0;	/* 0 == old (non-versioned) file format.  */

static enum gmon_ptr_size
gmon_get_ptr_size ()
{
  int size;

  /* Pick best size for pointers.  Start with the ELF size, and if not
     elf go with the architecture's address size.  */
  size = bfd_get_arch_size (core_bfd);
  if (size == -1)
    size = bfd_arch_bits_per_address (core_bfd);

  switch (size)
    {
    case 32:
      return ptr_32bit;

    case 64:
      return ptr_64bit;

    default:
      fprintf (stderr, _("%s: address size has unexpected value of %u\n"),
	       whoami, size);
      done (1);
    }
}

static enum gmon_ptr_signedness
gmon_get_ptr_signedness ()
{
  int sext;

  /* Figure out whether to sign extend.  If BFD doesn't know, assume no.  */
  sext = bfd_get_sign_extend_vma (core_bfd);
  if (sext == -1)
    return ptr_unsigned;
  return (sext ? ptr_signed : ptr_unsigned);
}

int
gmon_io_read_32 (ifp, valp)
     FILE *ifp;
     unsigned int *valp;
{
  char buf[4];

  if (fread (buf, 1, 4, ifp) != 4)
    return 1;
  *valp = bfd_get_32 (core_bfd, buf);
  return 0;
}

#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_read_64 (ifp, valp)
     FILE *ifp;
     BFD_HOST_U_64_BIT *valp;
{
  char buf[8];

  if (fread (buf, 1, 8, ifp) != 8)
    return 1;
  *valp = bfd_get_64 (core_bfd, buf);
  return 0;
}
#endif

int
gmon_io_read_vma (ifp, valp)
     FILE *ifp;
     bfd_vma *valp;
{
  unsigned int val32;
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT val64;
#endif

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &val32))
	return 1;
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (int) val32;
      else
        *valp = val32;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &val64))
	return 1;
#ifdef BFD_HOST_64_BIT
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (BFD_HOST_64_BIT) val64;
      else
#endif
        *valp = val64;
      break;
#endif
    }
  return 0;
}

int
gmon_io_read (ifp, buf, n)
     FILE *ifp;
     char *buf;
     size_t n;
{
  if (fread (buf, 1, n, ifp) != n)
    return 1;
  return 0;
}

int
gmon_io_write_32 (ofp, val)
     FILE *ofp;
     unsigned int val;
{
  char buf[4];

  bfd_put_32 (core_bfd, (bfd_vma) val, buf);
  if (fwrite (buf, 1, 4, ofp) != 4)
    return 1;
  return 0;
}

#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_write_64 (ofp, val)
     FILE *ofp;	
     BFD_HOST_U_64_BIT val;
{
  char buf[8];

  bfd_put_64 (core_bfd, (bfd_vma) val, buf);
  if (fwrite (buf, 1, 8, ofp) != 8)
    return 1;
  return 0;
}
#endif

int
gmon_io_write_vma (ofp, val)
     FILE *ofp;
     bfd_vma val;
{

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) val))
	return 1;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) val))
	return 1;
      break;
#endif
    }
  return 0;
}

int
gmon_io_write_8 (ofp, val)
     FILE *ofp;	
     unsigned int val;
{
  char buf[1];

  bfd_put_8 (core_bfd, val, buf);
  if (fwrite (buf, 1, 1, ofp) != 1)
    return 1;
  return 0;
}

int
gmon_io_write (ofp, buf, n)
     FILE *ofp;	
     char *buf;
     size_t n;
{
  if (fwrite (buf, 1, n, ofp) != n)
    return 1;
  return 0;
}

static int
gmon_read_raw_arc (ifp, fpc, spc, cnt)
     FILE *ifp;
     bfd_vma *fpc;
     bfd_vma *spc;
     unsigned long *cnt;
{
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT cnt64;
#endif
  unsigned int cnt32;

  if (gmon_io_read_vma (ifp, fpc)
      || gmon_io_read_vma (ifp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &cnt32))
	return 1;
      *cnt = cnt32;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &cnt64))
	return 1;
      *cnt = cnt64;
      break;
#endif
    }
  return 0;
}

static int
gmon_write_raw_arc (ofp, fpc, spc, cnt)
     FILE *ofp;
     bfd_vma fpc;
     bfd_vma spc;
     unsigned long cnt;
{

  if (gmon_io_write_vma (ofp, fpc)
      || gmon_io_write_vma (ofp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) cnt))
	return 1;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) cnt))
	return 1;
      break;
#endif
    }
  return 0;
}

void
gmon_out_read (filename)
     const char *filename;
{
  FILE *ifp;
  struct gmon_hdr ghdr;
  unsigned char tag;
  int nhist = 0, narcs = 0, nbbs = 0;

  /* Open gmon.out file.  */
  if (strcmp (filename, "-") == 0)
    {
      ifp = stdin;
#ifdef SET_BINARY
      SET_BINARY (fileno (stdin));
#endif
    }
  else
    {
      ifp = fopen (filename, FOPEN_RB);

      if (!ifp)
	{
	  perror (filename);
	  done (1);
	}
    }

  if (fread (&ghdr, sizeof (struct gmon_hdr), 1, ifp) != 1)
    {
      fprintf (stderr, _("%s: file too short to be a gmon file\n"),
	       filename);
      done (1);
    }

  if ((file_format == FF_MAGIC)
      || (file_format == FF_AUTO && !strncmp (&ghdr.cookie[0], GMON_MAGIC, 4)))
    {
      if (file_format == FF_MAGIC && strncmp (&ghdr.cookie[0], GMON_MAGIC, 4))
	{
	  fprintf (stderr, _("%s: file `%s' has bad magic cookie\n"),
		   whoami, filename);
	  done (1);
	}

      /* Right magic, so it's probably really a new gmon.out file.  */
      gmon_file_version = bfd_get_32 (core_bfd, (bfd_byte *) ghdr.version);

      if (gmon_file_version != GMON_VERSION && gmon_file_version != 0)
	{
	  fprintf (stderr,
		   _("%s: file `%s' has unsupported version %d\n"),
		   whoami, filename, gmon_file_version);
	  done (1);
	}

      /* Read in all the records.  */
      while (fread (&tag, sizeof (tag), 1, ifp) == 1)
	{
	  switch (tag)
	    {
	    case GMON_TAG_TIME_HIST:
	      ++nhist;
	      gmon_input |= INPUT_HISTOGRAM;
	      hist_read_rec (ifp, filename);
	      break;

	    case GMON_TAG_CG_ARC:
	      ++narcs;
	      gmon_input |= INPUT_CALL_GRAPH;
	      cg_read_rec (ifp, filename);
	      break;

	    case GMON_TAG_BB_COUNT:
	      ++nbbs;
	      gmon_input |= INPUT_BB_COUNTS;
	      bb_read_rec (ifp, filename);
	      break;

	    default:
	      fprintf (stderr,
		       _("%s: %s: found bad tag %d (file corrupted?)\n"),
		       whoami, filename, tag);
	      done (1);
	    }
	}
    }
  else if (file_format == FF_AUTO
	   || file_format == FF_BSD
	   || file_format == FF_BSD44)
    {
      struct hdr
      {
	bfd_vma low_pc;
	bfd_vma high_pc;
	int ncnt;
      };
      int i, samp_bytes, header_size = 0;
      unsigned long count;
      bfd_vma from_pc, self_pc;
      static struct hdr h;
      UNIT raw_bin_count;
      struct hdr tmp;
      int version;

      /* Information from a gmon.out file is in two parts: an array of
	 sampling hits within pc ranges, and the arcs.  */
      gmon_input = INPUT_HISTOGRAM | INPUT_CALL_GRAPH;

      /* This fseek() ought to work even on stdin as long as it's
	 not an interactive device (heck, is there anybody who would
	 want to type in a gmon.out at the terminal?).  */
      if (fseek (ifp, 0, SEEK_SET) < 0)
	{
	  perror (filename);
	  done (1);
	}

      /* The beginning of the old BSD header and the 4.4BSD header
	 are the same: lowpc, highpc, ncnt  */
      if (gmon_io_read_vma (ifp, &tmp.low_pc)
          || gmon_io_read_vma (ifp, &tmp.high_pc)
          || gmon_io_read_32 (ifp, &tmp.ncnt))
	{
 bad_gmon_file:
          fprintf (stderr, _("%s: file too short to be a gmon file\n"),
		   filename);
	  done (1);
	}

      /* Check to see if this a 4.4BSD-style header.  */
      if (gmon_io_read_32 (ifp, &version))
	goto bad_gmon_file;

      if (version == GMONVERSION)
	{
	  int profrate;

	  /* 4.4BSD format header.  */
          if (gmon_io_read_32 (ifp, &profrate))
	    goto bad_gmon_file;

	  if (!s_highpc)
	    hz = profrate;
	  else if (hz != profrate)
	    {
	      fprintf (stderr,
		       _("%s: profiling rate incompatible with first gmon file\n"),
		       filename);
	      done (1);
	    }

	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_BSD44_64;
	      break;
	    }
	}
      else
	{
	  /* Old style BSD format.  */
	  if (file_format == FF_BSD44)
	    {
	      fprintf (stderr, _("%s: file `%s' has bad magic cookie\n"),
		       whoami, filename);
	      done (1);
	    }

	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_OLDBSD_64;
	      break;
	    }
	}

      /* Position the file to after the header.  */
      if (fseek (ifp, header_size, SEEK_SET) < 0)
	{
	  perror (filename);
	  done (1);
	}

      if (s_highpc && (tmp.low_pc != h.low_pc
		       || tmp.high_pc != h.high_pc || tmp.ncnt != h.ncnt))
	{
	  fprintf (stderr, _("%s: incompatible with first gmon file\n"),
		   filename);
	  done (1);
	}

      h = tmp;
      s_lowpc = (bfd_vma) h.low_pc;
      s_highpc = (bfd_vma) h.high_pc;
      lowpc = (bfd_vma) h.low_pc / sizeof (UNIT);
      highpc = (bfd_vma) h.high_pc / sizeof (UNIT);
      samp_bytes = h.ncnt - header_size;
      hist_num_bins = samp_bytes / sizeof (UNIT);

      DBG (SAMPLEDEBUG,
	   printf ("[gmon_out_read] lowpc 0x%lx highpc 0x%lx ncnt %d\n",
		   (unsigned long) h.low_pc, (unsigned long) h.high_pc,
		   h.ncnt);
	   printf ("[gmon_out_read]   s_lowpc 0x%lx   s_highpc 0x%lx\n",
		   (unsigned long) s_lowpc, (unsigned long) s_highpc);
	   printf ("[gmon_out_read]     lowpc 0x%lx     highpc 0x%lx\n",
		   (unsigned long) lowpc, (unsigned long) highpc);
	   printf ("[gmon_out_read] samp_bytes %d hist_num_bins %d\n",
		   samp_bytes, hist_num_bins));

      /* Make sure that we have sensible values.  */
      if (samp_bytes < 0 || lowpc > highpc)
	{
	  fprintf (stderr,
	    _("%s: file '%s' does not appear to be in gmon.out format\n"),
	    whoami, filename);
	  done (1);
	}

      if (hist_num_bins)
	++nhist;

      if (!hist_sample)
	{
	  hist_sample =
	    (int *) xmalloc (hist_num_bins * sizeof (hist_sample[0]));

	  memset (hist_sample, 0, hist_num_bins * sizeof (hist_sample[0]));
	}

      for (i = 0; i < hist_num_bins; ++i)
	{
	  if (fread (raw_bin_count, sizeof (raw_bin_count), 1, ifp) != 1)
	    {
	      fprintf (stderr,
		       _("%s: unexpected EOF after reading %d/%d bins\n"),
		       whoami, --i, hist_num_bins);
	      done (1);
	    }

	  hist_sample[i] += bfd_get_16 (core_bfd, (bfd_byte *) raw_bin_count);
	}

      /* The rest of the file consists of a bunch of
	 <from,self,count> tuples.  */
      while (gmon_read_raw_arc (ifp, &from_pc, &self_pc, &count) == 0)
	{
	  ++narcs;

	  DBG (SAMPLEDEBUG,
	     printf ("[gmon_out_read] frompc 0x%lx selfpc 0x%lx count %lu\n",
		     (unsigned long) from_pc, (unsigned long) self_pc, count));

	  /* Add this arc.  */
	  cg_tally (from_pc, self_pc, count);
	}

      fclose (ifp);

      if (hz == HZ_WRONG)
	{
	  /* How many ticks per second?  If we can't tell, report
	     time in ticks.  */
	  hz = hertz ();

	  if (hz == HZ_WRONG)
	    {
	      hz = 1;
	      fprintf (stderr, _("time is in ticks, not seconds\n"));
	    }
	}
    }
  else
    {
      fprintf (stderr, _("%s: don't know how to deal with file format %d\n"),
	       whoami, file_format);
      done (1);
    }

  if (output_style & STYLE_GMON_INFO)
    {
      printf (_("File `%s' (version %d) contains:\n"),
	      filename, gmon_file_version);
      printf (nhist == 1 ?
	      _("\t%d histogram record\n") :
	      _("\t%d histogram records\n"), nhist);
      printf (narcs == 1 ?
	      _("\t%d call-graph record\n") :
	      _("\t%d call-graph records\n"), narcs);
      printf (nbbs == 1 ?
	      _("\t%d basic-block count record\n") :
	      _("\t%d basic-block count records\n"), nbbs);
      first_output = FALSE;
    }
}


void
gmon_out_write (filename)
     const char *filename;
{
  FILE *ofp;
  struct gmon_hdr ghdr;

  ofp = fopen (filename, FOPEN_WB);
  if (!ofp)
    {
      perror (filename);
      done (1);
    }

  if (file_format == FF_AUTO || file_format == FF_MAGIC)
    {
      /* Write gmon header.  */

      memcpy (&ghdr.cookie[0], GMON_MAGIC, 4);
      bfd_put_32 (core_bfd, (bfd_vma) GMON_VERSION, (bfd_byte *) ghdr.version);

      if (fwrite (&ghdr, sizeof (ghdr), 1, ofp) != 1)
	{
	  perror (filename);
	  done (1);
	}

      /* Write execution time histogram if we have one.  */
      if (gmon_input & INPUT_HISTOGRAM)
	hist_write_hist (ofp, filename);

      /* Write call graph arcs if we have any.  */
      if (gmon_input & INPUT_CALL_GRAPH)
	cg_write_arcs (ofp, filename);

      /* Write basic-block info if we have it.  */
      if (gmon_input & INPUT_BB_COUNTS)
	bb_write_blocks (ofp, filename);
    }
  else if (file_format == FF_BSD || file_format == FF_BSD44)
    {
      UNIT raw_bin_count;
      int i, hdrsize;
      unsigned padsize;
      char pad[3*4];
      Arc *arc;
      Sym *sym;

      memset (pad, 0, sizeof (pad));

      hdrsize = 0;
      /* Decide how large the header will be.  Use the 4.4BSD format
         header if explicitly specified, or if the profiling rate is
         non-standard.  Otherwise, use the old BSD format.  */
      if (file_format == FF_BSD44
	  || hz != hertz())
	{
	  padsize = 3*4;
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_BSD44_64;
	      break;
	    }
	}
      else
	{
	  padsize = 0;
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_64;
	      /* FIXME: Checking host compiler defines here means that we can't
		 use a cross gprof alpha OSF.  */ 
#if defined(__alpha__) && defined (__osf__)
	      padsize = 4;
#endif
	      break;
	    }
	}

      /* Write the parts of the headers that are common to both the
	 old BSD and 4.4BSD formats.  */
      if (gmon_io_write_vma (ofp, s_lowpc)
          || gmon_io_write_vma (ofp, s_highpc)
          || gmon_io_write_32 (ofp, hist_num_bins * sizeof (UNIT) + hdrsize))
	{
	  perror (filename);
	  done (1);
	}

      /* Write out the 4.4BSD header bits, if that's what we're using.  */
      if (file_format == FF_BSD44
	  || hz != hertz())
	{
          if (gmon_io_write_32 (ofp, GMONVERSION)
	      || gmon_io_write_32 (ofp, (unsigned int) hz))
	    {
	      perror (filename);
	      done (1);
	    }
	}

      /* Now write out any necessary padding after the meaningful
	 header bits.  */
      if (padsize != 0
          && fwrite (pad, 1, padsize, ofp) != padsize)
        {
          perror (filename);
	  done (1);
	}

      /* Dump the samples.  */
      for (i = 0; i < hist_num_bins; ++i)
	{
	  bfd_put_16 (core_bfd, (bfd_vma) hist_sample[i],
		      (bfd_byte *) &raw_bin_count[0]);
	  if (fwrite (&raw_bin_count[0], sizeof (raw_bin_count), 1, ofp) != 1)
	    {
	      perror (filename);
	      done (1);
	    }
	}

      /* Dump the normalized raw arc information.  */
      for (sym = symtab.base; sym < symtab.limit; ++sym)
	{
	  for (arc = sym->cg.children; arc; arc = arc->next_child)
	    {
	      if (gmon_write_raw_arc (ofp, arc->parent->addr,
				      arc->child->addr, arc->count))
		{
		  perror (filename);
		  done (1);
		}
	      DBG (SAMPLEDEBUG,
		   printf ("[dumpsum] frompc 0x%lx selfpc 0x%lx count %lu\n",
			   (unsigned long) arc->parent->addr,
			   (unsigned long) arc->child->addr, arc->count));
	    }
	}

      fclose (ofp);
    }
  else
    {
      fprintf (stderr, _("%s: don't know how to deal with file format %d\n"),
	       whoami, file_format);
      done (1);
    }
}
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d22 4
a27 1
#include "bfd.h"
a32 1
#include "gprof.h"
d37 22
d62 2
a63 2
int
DEFUN (gmon_io_read_vma, (ifp, valp), FILE * ifp AND bfd_vma *valp)
d65 7
a71 2
  char buf[8];
  bfd_vma val;
d73 1
a73 1
  switch (GMON_PTR_SIZE)
d75 2
a76 5
    case 4:
      if (fread (buf, 1, 4, ifp) != 4)
	return 1;
      val = bfd_get_32 (core_bfd, buf);
      break;
d78 2
a79 5
    case 8:
      if (fread (buf, 1, 8, ifp) != 8)
	return 1;
      val = bfd_get_64 (core_bfd, buf);
      break;
d82 2
a83 2
      fprintf (stderr, _("%s: GMON_PTR_SIZE has unexpected value of %u\n"),
	       whoami, GMON_PTR_SIZE);
d86 12
a97 2
  *valp = val;
  return 0;
d101 3
a103 1
DEFUN (gmon_io_read_32, (ifp, valp), FILE * ifp AND unsigned int *valp)
d113 5
a117 2
int
DEFUN (gmon_io_read, (ifp, buf, n), FILE * ifp AND char *buf AND size_t n)
d119 3
a121 1
  if (fread (buf, 1, n, ifp) != n)
d123 1
d126 1
d129 8
a136 3
DEFUN (gmon_io_write_vma, (ofp, val), FILE * ofp AND bfd_vma val)
{
  char buf[8];
d138 1
a138 1
  switch (GMON_PTR_SIZE)
d140 2
a141 3
    case 4:
      bfd_put_32 (core_bfd, val, buf);
      if (fwrite (buf, 1, 4, ofp) != 4)
d143 4
d149 3
a151 3
    case 8:
      bfd_put_64 (core_bfd, val, buf);
      if (fwrite (buf, 1, 8, ofp) != 8)
d153 6
d160 4
d165 8
a172 5
    default:
      fprintf (stderr, _("%s: GMON_PTR_SIZE has unexpected value of %u\n"),
	       whoami, GMON_PTR_SIZE);
      done (1);
    }
d177 3
a179 1
DEFUN (gmon_io_write_32, (ofp, val), FILE * ofp AND unsigned int val)
d183 1
a183 1
  bfd_put_32 (core_bfd, val, buf);
d189 15
d205 26
a230 1
DEFUN (gmon_io_write_8, (ofp, val), FILE * ofp AND unsigned char val)
d241 4
a244 1
DEFUN (gmon_io_write, (ofp, buf, n), FILE * ofp AND char *buf AND size_t n)
d251 31
a281 14
/* get_vma and put_vma are for backwards compatibility only */
static bfd_vma
DEFUN (get_vma, (abfd, addr), bfd * abfd AND bfd_byte * addr)
{
  switch (sizeof (char*))
    {
    case 4:
      return bfd_get_32 (abfd, addr);
    case 8:
      return bfd_get_64 (abfd, addr);
    default:
      fprintf (stderr, _("%s: bfd_vma has unexpected size of %ld bytes\n"),
	       whoami, (long) sizeof (char*));
      done (1);
d283 1
d286 6
a291 2
static void
DEFUN (put_vma, (abfd, val, addr), bfd * abfd AND bfd_vma val AND bfd_byte * addr)
d293 6
a298 1
  switch (sizeof (char*))
d300 3
a302 2
    case 4:
      bfd_put_32 (abfd, val, addr);
d304 5
a308 2
    case 8:
      bfd_put_64 (abfd, val, addr);
d310 1
a310 4
    default:
      fprintf (stderr, _("%s: bfd_vma has unexpected size of %ld bytes\n"),
	       whoami, (long) sizeof (char*));
      done (1);
d312 1
d316 2
a317 1
DEFUN (gmon_out_read, (filename), const char *filename)
d412 1
a412 1
      int i, samp_bytes, header_size;
a414 2
      struct raw_arc raw_arc;
      struct raw_phdr raw;
d418 1
d433 5
a437 2
      if (fread (&raw, 1, sizeof (struct raw_phdr), ifp)
	  != sizeof (struct raw_phdr))
d439 2
a440 1
	  fprintf (stderr, _("%s: file too short to be a gmon file\n"),
d445 3
a447 3
      tmp.low_pc = get_vma (core_bfd, (bfd_byte *) &raw.low_pc[0]);
      tmp.high_pc = get_vma (core_bfd, (bfd_byte *) &raw.high_pc[0]);
      tmp.ncnt = bfd_get_32 (core_bfd, (bfd_byte *) &raw.ncnt[0]);
d449 1
a449 2
      if (bfd_get_32 (core_bfd, (bfd_byte *) &raw.version[0])
	  == GMONVERSION)
d454 2
a455 1
	  profrate = bfd_get_32 (core_bfd, (bfd_byte *) &raw.profrate[0]);
d467 10
a476 1
	  header_size = sizeof (struct raw_phdr);
d488 1
a488 1
	  if (fseek (ifp, sizeof (struct old_raw_phdr), SEEK_SET) < 0)
d490 7
a496 2
	      perror (filename);
	      done (1);
d498 1
d500 5
a504 1
	  header_size = sizeof (struct old_raw_phdr);
d569 1
a569 1
      while (fread (&raw_arc, sizeof (raw_arc), 1, ifp) == 1)
a571 3
	  from_pc = get_vma (core_bfd, (bfd_byte *) raw_arc.from_pc);
	  self_pc = get_vma (core_bfd, (bfd_byte *) raw_arc.self_pc);
	  count = bfd_get_32 (core_bfd, (bfd_byte *) raw_arc.count);
d607 9
a615 6
      printf (_("\t%d histogram record%s\n"),
	      nhist, nhist == 1 ? "" : "s");
      printf (_("\t%d call-graph record%s\n"),
	      narcs, narcs == 1 ? "" : "s");
      printf (_("\t%d basic-block count record%s\n"),
	      nbbs, nbbs == 1 ? "" : "s");
d622 2
a623 1
DEFUN (gmon_out_write, (filename), const char *filename)
d640 1
a640 1
      bfd_put_32 (core_bfd, GMON_VERSION, (bfd_byte *) ghdr.version);
a661 1
      struct raw_arc raw_arc;
d663 3
a665 2
      struct raw_phdr h;
      int i;
d669 6
a674 10
      memset (&h, 0, sizeof h);
      put_vma (core_bfd, s_lowpc, (bfd_byte *) &h.low_pc);
      put_vma (core_bfd, s_highpc, (bfd_byte *) &h.high_pc);
      bfd_put_32 (core_bfd,
		  hist_num_bins * sizeof (UNIT) + sizeof (struct raw_phdr),
		  (bfd_byte *) &h.ncnt);

      /* Write header.  Use new style BSD format is explicitly
	 specified, or if the profiling rate is non-standard;
	 otherwise, use the old BSD format.  */
d676 1
a676 1
	  || hz != hertz ())
d678 2
a679 3
	  bfd_put_32 (core_bfd, GMONVERSION, (bfd_byte *) &h.version);
	  bfd_put_32 (core_bfd, hz, (bfd_byte *) &h.profrate);
	  if (fwrite (&h, sizeof (struct raw_phdr), 1, ofp) != 1)
d681 7
a687 2
	      perror (filename);
	      done (1);
d692 34
a725 1
	  if (fwrite (&h, sizeof (struct old_raw_phdr), 1, ofp) != 1)
d732 9
d744 2
a745 1
	  bfd_put_16 (core_bfd, hist_sample[i], (bfd_byte *) & raw_bin_count[0]);
d758 2
a759 6
	      put_vma (core_bfd, arc->parent->addr,
		       (bfd_byte *) raw_arc.from_pc);
	      put_vma (core_bfd, arc->child->addr,
		       (bfd_byte *) raw_arc.self_pc);
	      bfd_put_32 (core_bfd, arc->count, (bfd_byte *) raw_arc.count);
	      if (fwrite (&raw_arc, sizeof (raw_arc), 1, ofp) != 1)
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
a21 4
#include "gprof.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
d24 1
d30 1
a34 22
enum gmon_ptr_size {
  ptr_32bit,
  ptr_64bit
};

enum gmon_ptr_signedness {
  ptr_signed,
  ptr_unsigned
};

static enum gmon_ptr_size gmon_get_ptr_size PARAMS ((void));
static enum gmon_ptr_signedness gmon_get_ptr_signedness PARAMS ((void));

#ifdef BFD_HOST_U_64_BIT
static int gmon_io_read_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT *));
static int gmon_io_write_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT));
#endif
static int gmon_read_raw_arc
  PARAMS ((FILE *, bfd_vma *, bfd_vma *, unsigned long *));
static int gmon_write_raw_arc
  PARAMS ((FILE *, bfd_vma, bfd_vma, unsigned long));

d38 2
a39 2
static enum gmon_ptr_size
gmon_get_ptr_size ()
d41 2
a42 1
  int size;
d44 1
a44 7
  /* Pick best size for pointers.  Start with the ELF size, and if not
     elf go with the architecture's address size.  */
  size = bfd_get_arch_size (core_bfd);
  if (size == -1)
    size = bfd_arch_bits_per_address (core_bfd);

  switch (size)
d46 5
a50 2
    case 32:
      return ptr_32bit;
d52 5
a56 2
    case 64:
      return ptr_64bit;
d59 2
a60 2
      fprintf (stderr, _("%s: address size has unexpected value of %u\n"),
	       whoami, size);
d63 2
a64 12
}

static enum gmon_ptr_signedness
gmon_get_ptr_signedness ()
{
  int sext;

  /* Figure out whether to sign extend.  If BFD doesn't know, assume no.  */
  sext = bfd_get_sign_extend_vma (core_bfd);
  if (sext == -1)
    return ptr_unsigned;
  return (sext ? ptr_signed : ptr_unsigned);
d68 1
a68 3
gmon_io_read_32 (ifp, valp)
     FILE *ifp;
     unsigned int *valp;
d78 2
a79 5
#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_read_64 (ifp, valp)
     FILE *ifp;
     BFD_HOST_U_64_BIT *valp;
d81 1
a81 3
  char buf[8];

  if (fread (buf, 1, 8, ifp) != 8)
a82 1
  *valp = bfd_get_64 (core_bfd, buf);
a84 1
#endif
d87 3
a89 8
gmon_io_read_vma (ifp, valp)
     FILE *ifp;
     bfd_vma *valp;
{
  unsigned int val32;
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT val64;
#endif
d91 1
a91 1
  switch (gmon_get_ptr_size ())
d93 3
a95 2
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &val32))
a96 4
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (int) val32;
      else
        *valp = val32;
d99 3
a101 3
#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &val64))
a102 6
#ifdef BFD_HOST_64_BIT
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (BFD_HOST_64_BIT) val64;
      else
#endif
        *valp = val64;
d104 5
a108 1
#endif
d114 1
a114 14
gmon_io_read (ifp, buf, n)
     FILE *ifp;
     char *buf;
     size_t n;
{
  if (fread (buf, 1, n, ifp) != n)
    return 1;
  return 0;
}

int
gmon_io_write_32 (ofp, val)
     FILE *ofp;
     unsigned int val;
d118 1
a118 1
  bfd_put_32 (core_bfd, (bfd_vma) val, buf);
a123 15
#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_write_64 (ofp, val)
     FILE *ofp;	
     BFD_HOST_U_64_BIT val;
{
  char buf[8];

  bfd_put_64 (core_bfd, (bfd_vma) val, buf);
  if (fwrite (buf, 1, 8, ofp) != 8)
    return 1;
  return 0;
}
#endif

d125 1
a125 26
gmon_io_write_vma (ofp, val)
     FILE *ofp;
     bfd_vma val;
{

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) val))
	return 1;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) val))
	return 1;
      break;
#endif
    }
  return 0;
}

int
gmon_io_write_8 (ofp, val)
     FILE *ofp;	
     unsigned int val;
d136 1
a136 4
gmon_io_write (ofp, buf, n)
     FILE *ofp;	
     char *buf;
     size_t n;
d143 14
a156 31
static int
gmon_read_raw_arc (ifp, fpc, spc, cnt)
     FILE *ifp;
     bfd_vma *fpc;
     bfd_vma *spc;
     unsigned long *cnt;
{
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT cnt64;
#endif
  unsigned int cnt32;

  if (gmon_io_read_vma (ifp, fpc)
      || gmon_io_read_vma (ifp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &cnt32))
	return 1;
      *cnt = cnt32;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &cnt64))
	return 1;
      *cnt = cnt64;
      break;
#endif
a157 1
  return 0;
d160 2
a161 6
static int
gmon_write_raw_arc (ofp, fpc, spc, cnt)
     FILE *ofp;
     bfd_vma fpc;
     bfd_vma spc;
     unsigned long cnt;
d163 1
a163 6

  if (gmon_io_write_vma (ofp, fpc)
      || gmon_io_write_vma (ofp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
d165 2
a166 3
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) cnt))
	return 1;
d168 2
a169 5

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) cnt))
	return 1;
d171 4
a174 1
#endif
a175 1
  return 0;
d179 1
a179 2
gmon_out_read (filename)
     const char *filename;
d274 1
a274 1
      int i, samp_bytes, header_size = 0;
d277 2
a281 1
      int version;
d296 2
a297 5
      /* The beginning of the old BSD header and the 4.4BSD header
	 are the same: lowpc, highpc, ncnt  */
      if (gmon_io_read_vma (ifp, &tmp.low_pc)
          || gmon_io_read_vma (ifp, &tmp.high_pc)
          || gmon_io_read_32 (ifp, &tmp.ncnt))
d299 1
a299 2
 bad_gmon_file:
          fprintf (stderr, _("%s: file too short to be a gmon file\n"),
d304 3
a306 3
      /* Check to see if this a 4.4BSD-style header.  */
      if (gmon_io_read_32 (ifp, &version))
	goto bad_gmon_file;
d308 2
a309 1
      if (version == GMONVERSION)
d314 1
a314 2
          if (gmon_io_read_32 (ifp, &profrate))
	    goto bad_gmon_file;
d326 1
a326 10
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_BSD44_64;
	      break;
	    }
d338 1
a338 1
	  switch (gmon_get_ptr_size ())
d340 2
a341 7
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_OLDBSD_64;
	      break;
a342 1
	}
d344 1
a344 5
      /* Position the file to after the header.  */
      if (fseek (ifp, header_size, SEEK_SET) < 0)
	{
	  perror (filename);
	  done (1);
d409 1
a409 1
      while (gmon_read_raw_arc (ifp, &from_pc, &self_pc, &count) == 0)
d412 3
d450 6
a455 9
      printf (nhist == 1 ?
	      _("\t%d histogram record\n") :
	      _("\t%d histogram records\n"), nhist);
      printf (narcs == 1 ?
	      _("\t%d call-graph record\n") :
	      _("\t%d call-graph records\n"), narcs);
      printf (nbbs == 1 ?
	      _("\t%d basic-block count record\n") :
	      _("\t%d basic-block count records\n"), nbbs);
d462 1
a462 2
gmon_out_write (filename)
     const char *filename;
d479 1
a479 1
      bfd_put_32 (core_bfd, (bfd_vma) GMON_VERSION, (bfd_byte *) ghdr.version);
d501 1
d503 2
a504 3
      int i, hdrsize;
      unsigned padsize;
      char pad[3*4];
d508 10
a517 6
      memset (pad, 0, sizeof (pad));

      hdrsize = 0;
      /* Decide how large the header will be.  Use the 4.4BSD format
         header if explicitly specified, or if the profiling rate is
         non-standard.  Otherwise, use the old BSD format.  */
d519 1
a519 1
	  || hz != hertz())
d521 3
a523 2
	  padsize = 3*4;
	  switch (gmon_get_ptr_size ())
d525 2
a526 7
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_BSD44_64;
	      break;
d531 1
a531 34
	  padsize = 0;
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_64;
	      /* FIXME: Checking host compiler defines here means that we can't
		 use a cross gprof alpha OSF.  */ 
#if defined(__alpha__) && defined (__osf__)
	      padsize = 4;
#endif
	      break;
	    }
	}

      /* Write the parts of the headers that are common to both the
	 old BSD and 4.4BSD formats.  */
      if (gmon_io_write_vma (ofp, s_lowpc)
          || gmon_io_write_vma (ofp, s_highpc)
          || gmon_io_write_32 (ofp, hist_num_bins * sizeof (UNIT) + hdrsize))
	{
	  perror (filename);
	  done (1);
	}

      /* Write out the 4.4BSD header bits, if that's what we're using.  */
      if (file_format == FF_BSD44
	  || hz != hertz())
	{
          if (gmon_io_write_32 (ofp, GMONVERSION)
	      || gmon_io_write_32 (ofp, (unsigned int) hz))
a537 9
      /* Now write out any necessary padding after the meaningful
	 header bits.  */
      if (padsize != 0
          && fwrite (pad, 1, padsize, ofp) != padsize)
        {
          perror (filename);
	  done (1);
	}

d541 1
a541 2
	  bfd_put_16 (core_bfd, (bfd_vma) hist_sample[i],
		      (bfd_byte *) &raw_bin_count[0]);
d554 6
a559 2
	      if (gmon_write_raw_arc (ofp, arc->parent->addr,
				      arc->child->addr, arc->count))
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
a21 4
#include "gprof.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
d24 1
d30 1
a34 22
enum gmon_ptr_size {
  ptr_32bit,
  ptr_64bit
};

enum gmon_ptr_signedness {
  ptr_signed,
  ptr_unsigned
};

static enum gmon_ptr_size gmon_get_ptr_size PARAMS ((void));
static enum gmon_ptr_signedness gmon_get_ptr_signedness PARAMS ((void));

#ifdef BFD_HOST_U_64_BIT
static int gmon_io_read_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT *));
static int gmon_io_write_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT));
#endif
static int gmon_read_raw_arc
  PARAMS ((FILE *, bfd_vma *, bfd_vma *, unsigned long *));
static int gmon_write_raw_arc
  PARAMS ((FILE *, bfd_vma, bfd_vma, unsigned long));

d38 2
a39 2
static enum gmon_ptr_size
gmon_get_ptr_size ()
d41 2
a42 1
  int size;
d44 1
a44 7
  /* Pick best size for pointers.  Start with the ELF size, and if not
     elf go with the architecture's address size.  */
  size = bfd_get_arch_size (core_bfd);
  if (size == -1)
    size = bfd_arch_bits_per_address (core_bfd);

  switch (size)
d46 5
a50 2
    case 32:
      return ptr_32bit;
d52 5
a56 2
    case 64:
      return ptr_64bit;
d59 2
a60 2
      fprintf (stderr, _("%s: address size has unexpected value of %u\n"),
	       whoami, size);
d63 2
a64 12
}

static enum gmon_ptr_signedness
gmon_get_ptr_signedness ()
{
  int sext;

  /* Figure out whether to sign extend.  If BFD doesn't know, assume no.  */
  sext = bfd_get_sign_extend_vma (core_bfd);
  if (sext == -1)
    return ptr_unsigned;
  return (sext ? ptr_signed : ptr_unsigned);
d68 1
a68 3
gmon_io_read_32 (ifp, valp)
     FILE *ifp;
     unsigned int *valp;
d78 2
a79 5
#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_read_64 (ifp, valp)
     FILE *ifp;
     BFD_HOST_U_64_BIT *valp;
d81 1
a81 3
  char buf[8];

  if (fread (buf, 1, 8, ifp) != 8)
a82 1
  *valp = bfd_get_64 (core_bfd, buf);
a84 1
#endif
d87 3
a89 8
gmon_io_read_vma (ifp, valp)
     FILE *ifp;
     bfd_vma *valp;
{
  unsigned int val32;
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT val64;
#endif
d91 1
a91 1
  switch (gmon_get_ptr_size ())
d93 3
a95 2
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &val32))
a96 4
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (int) val32;
      else
        *valp = val32;
d99 3
a101 3
#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &val64))
a102 6
#ifdef BFD_HOST_64_BIT
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (BFD_HOST_64_BIT) val64;
      else
#endif
        *valp = val64;
d104 5
a108 1
#endif
d114 1
a114 14
gmon_io_read (ifp, buf, n)
     FILE *ifp;
     char *buf;
     size_t n;
{
  if (fread (buf, 1, n, ifp) != n)
    return 1;
  return 0;
}

int
gmon_io_write_32 (ofp, val)
     FILE *ofp;
     unsigned int val;
d118 1
a118 1
  bfd_put_32 (core_bfd, (bfd_vma) val, buf);
a123 15
#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_write_64 (ofp, val)
     FILE *ofp;	
     BFD_HOST_U_64_BIT val;
{
  char buf[8];

  bfd_put_64 (core_bfd, (bfd_vma) val, buf);
  if (fwrite (buf, 1, 8, ofp) != 8)
    return 1;
  return 0;
}
#endif

d125 1
a125 26
gmon_io_write_vma (ofp, val)
     FILE *ofp;
     bfd_vma val;
{

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) val))
	return 1;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) val))
	return 1;
      break;
#endif
    }
  return 0;
}

int
gmon_io_write_8 (ofp, val)
     FILE *ofp;	
     unsigned int val;
d136 1
a136 4
gmon_io_write (ofp, buf, n)
     FILE *ofp;	
     char *buf;
     size_t n;
d143 14
a156 31
static int
gmon_read_raw_arc (ifp, fpc, spc, cnt)
     FILE *ifp;
     bfd_vma *fpc;
     bfd_vma *spc;
     unsigned long *cnt;
{
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT cnt64;
#endif
  unsigned int cnt32;

  if (gmon_io_read_vma (ifp, fpc)
      || gmon_io_read_vma (ifp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &cnt32))
	return 1;
      *cnt = cnt32;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &cnt64))
	return 1;
      *cnt = cnt64;
      break;
#endif
a157 1
  return 0;
d160 2
a161 6
static int
gmon_write_raw_arc (ofp, fpc, spc, cnt)
     FILE *ofp;
     bfd_vma fpc;
     bfd_vma spc;
     unsigned long cnt;
d163 1
a163 6

  if (gmon_io_write_vma (ofp, fpc)
      || gmon_io_write_vma (ofp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
d165 2
a166 3
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) cnt))
	return 1;
d168 2
a169 5

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) cnt))
	return 1;
d171 4
a174 1
#endif
a175 1
  return 0;
d179 1
a179 2
gmon_out_read (filename)
     const char *filename;
d274 1
a274 1
      int i, samp_bytes, header_size = 0;
d277 2
a281 1
      int version;
d296 2
a297 5
      /* The beginning of the old BSD header and the 4.4BSD header
	 are the same: lowpc, highpc, ncnt  */
      if (gmon_io_read_vma (ifp, &tmp.low_pc)
          || gmon_io_read_vma (ifp, &tmp.high_pc)
          || gmon_io_read_32 (ifp, &tmp.ncnt))
d299 1
a299 2
 bad_gmon_file:
          fprintf (stderr, _("%s: file too short to be a gmon file\n"),
d304 3
a306 3
      /* Check to see if this a 4.4BSD-style header.  */
      if (gmon_io_read_32 (ifp, &version))
	goto bad_gmon_file;
d308 2
a309 1
      if (version == GMONVERSION)
d314 1
a314 2
          if (gmon_io_read_32 (ifp, &profrate))
	    goto bad_gmon_file;
d326 1
a326 10
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_BSD44_64;
	      break;
	    }
d338 1
a338 1
	  switch (gmon_get_ptr_size ())
d340 2
a341 7
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_OLDBSD_64;
	      break;
a342 1
	}
d344 1
a344 5
      /* Position the file to after the header.  */
      if (fseek (ifp, header_size, SEEK_SET) < 0)
	{
	  perror (filename);
	  done (1);
d409 1
a409 1
      while (gmon_read_raw_arc (ifp, &from_pc, &self_pc, &count) == 0)
d412 3
d450 6
a455 9
      printf (nhist == 1 ?
	      _("\t%d histogram record\n") :
	      _("\t%d histogram records\n"), nhist);
      printf (narcs == 1 ?
	      _("\t%d call-graph record\n") :
	      _("\t%d call-graph records\n"), narcs);
      printf (nbbs == 1 ?
	      _("\t%d basic-block count record\n") :
	      _("\t%d basic-block count records\n"), nbbs);
d462 1
a462 2
gmon_out_write (filename)
     const char *filename;
d479 1
a479 1
      bfd_put_32 (core_bfd, (bfd_vma) GMON_VERSION, (bfd_byte *) ghdr.version);
d501 1
d503 2
a504 3
      int i, hdrsize;
      unsigned padsize;
      char pad[3*4];
d508 10
a517 6
      memset (pad, 0, sizeof (pad));

      hdrsize = 0;
      /* Decide how large the header will be.  Use the 4.4BSD format
         header if explicitly specified, or if the profiling rate is
         non-standard.  Otherwise, use the old BSD format.  */
d519 1
a519 1
	  || hz != hertz())
d521 3
a523 2
	  padsize = 3*4;
	  switch (gmon_get_ptr_size ())
d525 2
a526 7
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_BSD44_64;
	      break;
d531 1
a531 34
	  padsize = 0;
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_64;
	      /* FIXME: Checking host compiler defines here means that we can't
		 use a cross gprof alpha OSF.  */ 
#if defined(__alpha__) && defined (__osf__)
	      padsize = 4;
#endif
	      break;
	    }
	}

      /* Write the parts of the headers that are common to both the
	 old BSD and 4.4BSD formats.  */
      if (gmon_io_write_vma (ofp, s_lowpc)
          || gmon_io_write_vma (ofp, s_highpc)
          || gmon_io_write_32 (ofp, hist_num_bins * sizeof (UNIT) + hdrsize))
	{
	  perror (filename);
	  done (1);
	}

      /* Write out the 4.4BSD header bits, if that's what we're using.  */
      if (file_format == FF_BSD44
	  || hz != hertz())
	{
          if (gmon_io_write_32 (ofp, GMONVERSION)
	      || gmon_io_write_32 (ofp, (unsigned int) hz))
a537 9
      /* Now write out any necessary padding after the meaningful
	 header bits.  */
      if (padsize != 0
          && fwrite (pad, 1, padsize, ofp) != padsize)
        {
          perror (filename);
	  done (1);
	}

d541 1
a541 2
	  bfd_put_16 (core_bfd, (bfd_vma) hist_sample[i],
		      (bfd_byte *) &raw_bin_count[0]);
d554 6
a559 2
	      if (gmon_write_raw_arc (ofp, arc->parent->addr,
				      arc->child->addr, arc->count))
@

