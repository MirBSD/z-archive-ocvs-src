head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.21.00.40;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.01.55;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.39.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.39.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.31.13;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.41.27;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.05.20;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.10.41;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* tc-h8300.c -- Assemble code for the Renesas H8/300
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001, 2002, 2003 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Written By Steve Chamberlain <sac@@cygnus.com>.  */

#include <stdio.h>
#include "as.h"
#include "subsegs.h"
#include "bfd.h"

#ifdef BFD_ASSEMBLER
#include "dwarf2dbg.h"
#endif

#define DEFINE_TABLE
#define h8_opcodes ops
#include "opcode/h8300.h"
#include "safe-ctype.h"

#ifdef OBJ_ELF
#include "elf/h8.h"
#endif

const char comment_chars[] = ";";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = "";

void cons        PARAMS ((int));
void sbranch     PARAMS ((int));
void h8300hmode  PARAMS ((int));
void h8300smode  PARAMS ((int));
void h8300hnmode PARAMS ((int));
void h8300snmode PARAMS ((int));
static void pint PARAMS ((int));

int Hmode;
int Smode;
int Nmode;

#define PSIZE (Hmode ? L_32 : L_16)
#define DMODE (L_16)
#define DSYMMODE (Hmode ? L_24 : L_16)

int bsize = L_8;		/* Default branch displacement.  */

struct h8_instruction
{
  int length;
  int noperands;
  int idx;
  int size;
  const struct h8_opcode *opcode;
};

struct h8_instruction *h8_instructions;

void
h8300hmode (arg)
     int arg ATTRIBUTE_UNUSED;
{
  Hmode = 1;
  Smode = 0;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300h))
    as_warn (_("could not set architecture and machine"));
#endif
}

void
h8300smode (arg)
     int arg ATTRIBUTE_UNUSED;
{
  Smode = 1;
  Hmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300s))
    as_warn (_("could not set architecture and machine"));
#endif
}

void
h8300hnmode (arg)
     int arg ATTRIBUTE_UNUSED;
{
  Hmode = 1;
  Smode = 0;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300hn))
    as_warn (_("could not set architecture and machine"));
#endif
}

void
h8300snmode (arg)
     int arg ATTRIBUTE_UNUSED;
{
  Smode = 1;
  Hmode = 1;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sn))
    as_warn (_("could not set architecture and machine"));
#endif
}

void
sbranch (size)
     int size;
{
  bsize = size;
}

static void
pint (arg)
     int arg ATTRIBUTE_UNUSED;
{
  cons (Hmode ? 4 : 2);
}

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */

const pseudo_typeS md_pseudo_table[] =
{
  {"h8300h", h8300hmode, 0},
  {"h8300hn", h8300hnmode, 0},
  {"h8300s", h8300smode, 0},
  {"h8300sn", h8300snmode, 0},
  {"sbranch", sbranch, L_8},
  {"lbranch", sbranch, L_16},

#ifdef BFD_ASSEMBLER
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  {"loc", dwarf2_directive_loc, 0 },
#endif

  {"int", pint, 0},
  {"data.b", cons, 1},
  {"data.w", cons, 2},
  {"data.l", cons, 4},
  {"form", listing_psize, 0},
  {"heading", listing_title, 0},
  {"import", s_ignore, 0},
  {"page", listing_eject, 0},
  {"program", s_ignore, 0},
  {0, 0, 0}
};

const int md_reloc_size;

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant
   As in 0f12.456
   or    0d1.2345e12.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

static struct hash_control *opcode_hash_control;	/* Opcode mnemonics.  */

/* This function is called once, at assembler startup time.  This
   should set up all the tables, etc. that the MD part of the assembler
   needs.  */

void
md_begin ()
{
  unsigned int nopcodes;
  const struct h8_opcode *p;
  struct h8_instruction *pi;
  char prev_buffer[100];
  int idx = 0;

#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300))
    as_warn (_("could not set architecture and machine"));
#endif

  opcode_hash_control = hash_new ();
  prev_buffer[0] = 0;

  nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);
  
  h8_instructions = (struct h8_instruction *)
    xmalloc (nopcodes * sizeof (struct h8_instruction));

  for (p = h8_opcodes, pi = h8_instructions; p->name; p++, pi++)
    {
      /* Strip off any . part when inserting the opcode and only enter
         unique codes into the hash table.  */
      char *src = p->name;
      unsigned int len = strlen (src);
      char *dst = malloc (len + 1);
      char *buffer = dst;

      pi->size = 0;
      while (*src)
	{
	  if (*src == '.')
	    {
	      src++;
	      pi->size = *src;
	      break;
	    }
	  *dst++ = *src++;
	}
      *dst++ = 0;
      if (strcmp (buffer, prev_buffer))
	{
	  hash_insert (opcode_hash_control, buffer, (char *) pi);
	  strcpy (prev_buffer, buffer);
	  idx++;
	}
      pi->idx = idx;

      /* Find the number of operands.  */
      pi->noperands = 0;
      while (p->args.nib[pi->noperands] != E)
	pi->noperands++;

      /* Find the length of the opcode in bytes.  */
      pi->length = 0;
      while (p->data.nib[pi->length * 2] != E)
	pi->length++;

      pi->opcode = p;
    }

  /* Add entry for the NULL vector terminator.  */
  pi->length = 0;
  pi->noperands = 0;
  pi->idx = 0;
  pi->size = 0;
  pi->opcode = p;

  linkrelax = 1;
}

struct h8_exp
{
  char *e_beg;
  char *e_end;
  expressionS e_exp;
};

int dispreg;
int opsize;			/* Set when a register size is seen.  */

struct h8_op
{
  op_type mode;
  unsigned reg;
  expressionS exp;
};

static void clever_message PARAMS ((const struct h8_instruction *, struct h8_op *));
static void build_bytes    PARAMS ((const struct h8_instruction *, struct h8_op *));
static void do_a_fix_imm   PARAMS ((int, struct h8_op *, int));
static void check_operand  PARAMS ((struct h8_op *, unsigned int, char *));
static const struct h8_instruction * get_specific PARAMS ((const struct h8_instruction *, struct h8_op *, int));
static char * get_operands PARAMS ((unsigned, char *, struct h8_op *));
static void   get_operand  PARAMS ((char **, struct h8_op *, unsigned, int));
static char * skip_colonthing PARAMS ((char *, expressionS *, int *));
static char * parse_exp PARAMS ((char *, expressionS *));
static int    parse_reg PARAMS ((char *, op_type *, unsigned *, int));
char * colonmod24 PARAMS ((struct h8_op *, char *));

/*
  parse operands
  WREG r0,r1,r2,r3,r4,r5,r6,r7,fp,sp
  r0l,r0h,..r7l,r7h
  @@WREG
  @@WREG+
  @@-WREG
  #const
  ccr
*/

/* Try to parse a reg name.  Return the number of chars consumed.  */

static int
parse_reg (src, mode, reg, direction)
     char *src;
     op_type *mode;
     unsigned int *reg;
     int direction;
{
  char *end;
  int len;

  /* Cribbed from get_symbol_end.  */
  if (!is_name_beginner (*src) || *src == '\001')
    return 0;
  end = src + 1;
  while (is_part_of_name (*end) || *end == '\001')
    end++;
  len = end - src;

  if (len == 2 && src[0] == 's' && src[1] == 'p')
    {
      *mode = PSIZE | REG | direction;
      *reg = 7;
      return len;
    }
  if (len == 3 && src[0] == 'c' && src[1] == 'c' && src[2] == 'r')
    {
      *mode = CCR;
      *reg = 0;
      return len;
    }
  if (len == 3 && src[0] == 'e' && src[1] == 'x' && src[2] == 'r')
    {
      *mode = EXR;
      *reg = 0;
      return len;
    }
  if (len == 2 && src[0] == 'f' && src[1] == 'p')
    {
      *mode = PSIZE | REG | direction;
      *reg = 6;
      return len;
    }
  if (len == 3 && src[0] == 'e' && src[1] == 'r'
      && src[2] >= '0' && src[2] <= '7')
    {
      *mode = L_32 | REG | direction;
      *reg = src[2] - '0';
      if (!Hmode)
	as_warn (_("Reg not valid for H8/300"));
      return len;
    }
  if (len == 2 && src[0] == 'e' && src[1] >= '0' && src[1] <= '7')
    {
      *mode = L_16 | REG | direction;
      *reg = src[1] - '0' + 8;
      if (!Hmode)
	as_warn (_("Reg not valid for H8/300"));
      return len;
    }

  if (src[0] == 'r')
    {
      if (src[1] >= '0' && src[1] <= '7')
	{
	  if (len == 3 && src[2] == 'l')
	    {
	      *mode = L_8 | REG | direction;
	      *reg = (src[1] - '0') + 8;
	      return len;
	    }
	  if (len == 3 && src[2] == 'h')
	    {
	      *mode = L_8 | REG | direction;
	      *reg = (src[1] - '0');
	      return len;
	    }
	  if (len == 2)
	    {
	      *mode = L_16 | REG | direction;
	      *reg = (src[1] - '0');
	      return len;
	    }
	}
    }

  return 0;
}

static char *
parse_exp (s, op)
     char *s;
     expressionS *op;
{
  char *save = input_line_pointer;
  char *new;

  input_line_pointer = s;
  expression (op);
  if (op->X_op == O_absent)
    as_bad (_("missing operand"));
  new = input_line_pointer;
  input_line_pointer = save;
  return new;
}

static char *
skip_colonthing (ptr, exp, mode)
     char *ptr;
     expressionS *exp ATTRIBUTE_UNUSED;
     int *mode;
{
  if (*ptr == ':')
    {
      ptr++;
      *mode &= ~SIZE;
      if (*ptr == '8')
	{
	  ptr++;
	  /* ff fill any 8 bit quantity.  */
	  /* exp->X_add_number -= 0x100; */
	  *mode |= L_8;
	}
      else
	{
	  if (*ptr == '2')
	    {
	      *mode |= L_24;
	    }
	  else if (*ptr == '3')
	    {
	      *mode |= L_32;
	    }
	  else if (*ptr == '1')
	    {
	      *mode |= L_16;
	    }
	  while (ISDIGIT (*ptr))
	    ptr++;
	}
    }
  return ptr;
}

/* The many forms of operand:

   Rn			Register direct
   @@Rn			Register indirect
   @@(exp[:16], Rn)	Register indirect with displacement
   @@Rn+
   @@-Rn
   @@aa:8		absolute 8 bit
   @@aa:16		absolute 16 bit
   @@aa			absolute 16 bit

   #xx[:size]		immediate data
   @@(exp:[8], pc)	pc rel
   @@@@aa[:8]		memory indirect.  */

char *
colonmod24 (op, src)
     struct h8_op *op;
     char *src;
{
  int mode = 0;
  src = skip_colonthing (src, &op->exp, &mode);

  if (!mode)
    {
      /* Choose a default mode.  */
      if (op->exp.X_add_number < -32768
	  || op->exp.X_add_number > 32767)
	{
	  if (Hmode)
	    mode = L_24;
	  else
	    mode = L_16;
	}
      else if (op->exp.X_add_symbol
	       || op->exp.X_op_symbol)
	mode = DSYMMODE;
      else
	mode = DMODE;
    }

  op->mode |= mode;
  return src;
}

static void
get_operand (ptr, op, dst, direction)
     char **ptr;
     struct h8_op *op;
     unsigned int dst ATTRIBUTE_UNUSED;
     int direction;
{
  char *src = *ptr;
  op_type mode;
  unsigned int num;
  unsigned int len;

  op->mode = E;

  /* Check for '(' and ')' for instructions ldm and stm.  */
  if (src[0] == '(' && src[8] == ')')
    ++ src;

  /* Gross.  Gross.  ldm and stm have a format not easily handled
     by get_operand.  We deal with it explicitly here.  */
  if (src[0] == 'e' && src[1] == 'r' && ISDIGIT (src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && ISDIGIT (src[6]))
    {
      int low, high;

      low = src[2] - '0';
      high = src[6] - '0';

      if (high < low)
	as_bad (_("Invalid register list for ldm/stm\n"));

      if (low % 2)
	as_bad (_("Invalid register list for ldm/stm\n"));

      if (high - low > 3)
	as_bad (_("Invalid register list for ldm/stm\n"));

      if (high - low != 1
	  && low % 4)
	as_bad (_("Invalid register list for ldm/stm\n"));

      /* Even sicker.  We encode two registers into op->reg.  One
	 for the low register to save, the other for the high
	 register to save;  we also set the high bit in op->reg
	 so we know this is "very special".  */
      op->reg = 0x80000000 | (high << 8) | low;
      op->mode = REG;
      if (src[7] == ')')
	*ptr = src + 8;
      else
	*ptr = src + 7;
      return;
    }

  len = parse_reg (src, &op->mode, &op->reg, direction);
  if (len)
    {
      *ptr = src + len;
      return;
    }

  if (*src == '@@')
    {
      src++;
      if (*src == '@@')
	{
	  src++;
	  src = parse_exp (src, &op->exp);

	  src = skip_colonthing (src, &op->exp, &op->mode);

	  *ptr = src;

	  op->mode = MEMIND;
	  return;
	}

      if (*src == '-')
	{
	  src++;
	  len = parse_reg (src, &mode, &num, direction);
	  if (len == 0)
	    {
	      /* Oops, not a reg after all, must be ordinary exp.  */
	      src--;
	      /* Must be a symbol.  */
	      op->mode = ABS | PSIZE | direction;
	      *ptr = skip_colonthing (parse_exp (src, &op->exp),
				      &op->exp, &op->mode);

	      return;
	    }

	  if ((mode & SIZE) != PSIZE)
	    as_bad (_("Wrong size pointer register for architecture."));
	  op->mode = RDDEC;
	  op->reg = num;
	  *ptr = src + len;
	  return;
	}
      if (*src == '(')
	{
	  /* Disp.  */
	  src++;

	  /* Start off assuming a 16 bit offset.  */

	  src = parse_exp (src, &op->exp);

	  src = colonmod24 (op, src);

	  if (*src == ')')
	    {
	      src++;
	      op->mode |= ABS | direction;
	      *ptr = src;
	      return;
	    }

	  if (*src != ',')
	    {
	      as_bad (_("expected @@(exp, reg16)"));
	      return;

	    }
	  src++;

	  len = parse_reg (src, &mode, &op->reg, direction);
	  if (len == 0 || !(mode & REG))
	    {
	      as_bad (_("expected @@(exp, reg16)"));
	      return;
	    }
	  op->mode |= DISP | direction;
	  dispreg = op->reg;
	  src += len;
	  src = skip_colonthing (src, &op->exp, &op->mode);

	  if (*src != ')' && '(')
	    {
	      as_bad (_("expected @@(exp, reg16)"));
	      return;
	    }
	  *ptr = src + 1;

	  return;
	}
      len = parse_reg (src, &mode, &num, direction);

      if (len)
	{
	  src += len;
	  if (*src == '+')
	    {
	      src++;
	      if ((mode & SIZE) != PSIZE)
		as_bad (_("Wrong size pointer register for architecture."));
	      op->mode = RSINC;
	      op->reg = num;
	      *ptr = src;
	      return;
	    }
	  if ((mode & SIZE) != PSIZE)
	    as_bad (_("Wrong size pointer register for architecture."));

	  op->mode = direction | IND | PSIZE;
	  op->reg = num;
	  *ptr = src;

	  return;
	}
      else
	{
	  /* must be a symbol */

	  op->mode = ABS | direction;
	  src = parse_exp (src, &op->exp);

	  *ptr = colonmod24 (op, src);

	  return;
	}
    }

  if (*src == '#')
    {
      src++;
      op->mode = IMM;
      src = parse_exp (src, &op->exp);
      *ptr = skip_colonthing (src, &op->exp, &op->mode);

      return;
    }
  else if (strncmp (src, "mach", 4) == 0
	   || strncmp (src, "macl", 4) == 0)
    {
      op->reg = src[3] == 'l';
      op->mode = MACREG;
      *ptr = src + 4;
      return;
    }
  else
    {
      src = parse_exp (src, &op->exp);
      /* Trailing ':' size ? */
      if (*src == ':')
	{
	  if (src[1] == '1' && src[2] == '6')
	    {
	      op->mode = PCREL | L_16;
	      src += 3;
	    }
	  else if (src[1] == '8')
	    {
	      op->mode = PCREL | L_8;
	      src += 2;
	    }
	  else
	    as_bad (_("expect :8 or :16 here"));
	}
      else
	op->mode = PCREL | bsize;

      *ptr = src;
    }
}

static char *
get_operands (noperands, op_end, operand)
     unsigned int noperands;
     char *op_end;
     struct h8_op *operand;
{
  char *ptr = op_end;

  switch (noperands)
    {
    case 0:
      operand[0].mode = 0;
      operand[1].mode = 0;
      break;

    case 1:
      ptr++;
      get_operand (&ptr, operand + 0, 0, SRC);
      if (*ptr == ',')
	{
	  ptr++;
	  get_operand (&ptr, operand + 1, 1, DST);
	}
      else
	{
	  operand[1].mode = 0;
	}
      break;

    case 2:
      ptr++;
      get_operand (&ptr, operand + 0, 0, SRC);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, 1, DST);
      break;

    default:
      abort ();
    }

  return ptr;
}

/* Passed a pointer to a list of opcodes which use different
   addressing modes, return the opcode which matches the opcodes
   provided.  */

static const struct h8_instruction *
get_specific (instruction, operands, size)
     const struct h8_instruction *instruction;
     struct h8_op *operands;
     int size;
{
  const struct h8_instruction *this_try = instruction;
  int found = 0;
  int this_index = instruction->idx;

  /* There's only one ldm/stm and it's easier to just
     get out quick for them.  */
  if (strcmp (instruction->opcode->name, "stm.l") == 0
      || strcmp (instruction->opcode->name, "ldm.l") == 0)
    return this_try;

  while (this_index == instruction->idx && !found)
    {
      found = 1;

      this_try = instruction++;
      if (this_try->noperands == 0)
	{
	  int this_size;

	  this_size = this_try->opcode->how & SN;
	  if (this_size != size && (this_size != SB || size != SN))
	    found = 0;
	}
      else
	{
	  int i;

	  for (i = 0; i < this_try->noperands && found; i++)
	    {
	      op_type op = this_try->opcode->args.nib[i];
	      int x = operands[i].mode;

	      if ((op & (DISP | REG)) == (DISP | REG)
		  && ((x & (DISP | REG)) == (DISP | REG)))
		{
		  dispreg = operands[i].reg;
		}
	      else if (op & REG)
		{
		  if (!(x & REG))
		    found = 0;

		  if (x & L_P)
		    x = (x & ~L_P) | (Hmode ? L_32 : L_16);
		  if (op & L_P)
		    op = (op & ~L_P) | (Hmode ? L_32 : L_16);

		  opsize = op & SIZE;

		  /* The size of the reg is v important.  */
		  if ((op & SIZE) != (x & SIZE))
		    found = 0;
		}
	      else if ((op & ABSJMP) && (x & ABS))
		{
		  operands[i].mode &= ~ABS;
		  operands[i].mode |= ABSJMP;
		  /* But it may not be 24 bits long.  */
		  if (!Hmode)
		    {
		      operands[i].mode &= ~SIZE;
		      operands[i].mode |= L_16;
		    }
		}
	      else if ((op & (KBIT | DBIT)) && (x & IMM))
		{
		  /* This is ok if the immediate value is sensible.  */
		}
	      else if (op & PCREL)
		{
		  /* The size of the displacement is important.  */
		  if ((op & SIZE) != (x & SIZE))
		    found = 0;
		}
	      else if ((op & (DISP | IMM | ABS))
		       && (op & (DISP | IMM | ABS)) == (x & (DISP | IMM | ABS)))
		{
		  /* Promote a L_24 to L_32 if it makes us match.  */
		  if ((x & L_24) && (op & L_32))
		    {
		      x &= ~L_24;
		      x |= L_32;
		    }
		  /* Promote an L8 to L_16 if it makes us match.  */
		  if (op & ABS && op & L_8 && op & DISP)
		    {
		      if (x & L_16)
			found = 1;
		    }
		  else if ((x & SIZE) != 0
			   && ((op & SIZE) != (x & SIZE)))
		    found = 0;
		}
	      else if ((op & MACREG) != (x & MACREG))
		{
		  found = 0;
		}
	      else if ((op & MODE) != (x & MODE))
		{
		  found = 0;
		}
	    }
	}
    }
  if (found)
    return this_try;
  else
    return 0;
}

static void
check_operand (operand, width, string)
     struct h8_op *operand;
     unsigned int width;
     char *string;
{
  if (operand->exp.X_add_symbol == 0
      && operand->exp.X_op_symbol == 0)
    {
      /* No symbol involved, let's look at offset, it's dangerous if
	 any of the high bits are not 0 or ff's, find out by oring or
	 anding with the width and seeing if the answer is 0 or all
	 fs.  */

      if ((operand->exp.X_add_number & ~width) != 0 &&
	  (operand->exp.X_add_number | width) != (unsigned)(~0))
	{
	  if (width == 255
	      && (operand->exp.X_add_number & 0xff00) == 0xff00)
	    {
	      /* Just ignore this one - which happens when trying to
		 fit a 16 bit address truncated into an 8 bit address
		 of something like bset.  */
	    }
	  else if (strcmp (string, "@@") == 0
		   && width == 0xffff
		   && (operand->exp.X_add_number & 0xff8000) == 0xff8000)
	    {
	      /* Just ignore this one - which happens when trying to
		 fit a 24 bit address truncated into a 16 bit address
		 of something like mov.w.  */
	    }
	  else
	    {
	      as_warn (_("operand %s0x%lx out of range."), string,
		       (unsigned long) operand->exp.X_add_number);
	    }
	}
    }
}

/* RELAXMODE has one of 3 values:

   0 Output a "normal" reloc, no relaxing possible for this insn/reloc

   1 Output a relaxable 24bit absolute mov.w address relocation
     (may relax into a 16bit absolute address).

   2 Output a relaxable 16/24 absolute mov.b address relocation
     (may relax into an 8bit absolute address).  */

static void
do_a_fix_imm (offset, operand, relaxmode)
     int offset;
     struct h8_op *operand;
     int relaxmode;
{
  int idx;
  int size;
  int where;

  char *t = operand->mode & IMM ? "#" : "@@";

  if (operand->exp.X_add_symbol == 0)
    {
      char *bytes = frag_now->fr_literal + offset;
      switch (operand->mode & SIZE)
	{
	case L_2:
	  check_operand (operand, 0x3, t);
	  bytes[0] |= (operand->exp.X_add_number) << 4;
	  break;
	case L_3:
	  check_operand (operand, 0x7, t);
	  bytes[0] |= (operand->exp.X_add_number) << 4;
	  break;
	case L_8:
	  check_operand (operand, 0xff, t);
	  bytes[0] = operand->exp.X_add_number;
	  break;
	case L_16:
	  check_operand (operand, 0xffff, t);
	  bytes[0] = operand->exp.X_add_number >> 8;
	  bytes[1] = operand->exp.X_add_number >> 0;
	  break;
	case L_24:
	  check_operand (operand, 0xffffff, t);
	  bytes[0] = operand->exp.X_add_number >> 16;
	  bytes[1] = operand->exp.X_add_number >> 8;
	  bytes[2] = operand->exp.X_add_number >> 0;
	  break;

	case L_32:
	  /* This should be done with bfd.  */
	  bytes[0] = operand->exp.X_add_number >> 24;
	  bytes[1] = operand->exp.X_add_number >> 16;
	  bytes[2] = operand->exp.X_add_number >> 8;
	  bytes[3] = operand->exp.X_add_number >> 0;
	  if (relaxmode != 0)
	    {
	      idx = (relaxmode == 2) ? R_MOV24B1 : R_MOVL1;
	      fix_new_exp (frag_now, offset, 4, &operand->exp, 0, idx);
	    }
	  break;
	}
    }
  else
    {
      switch (operand->mode & SIZE)
	{
	case L_24:
	case L_32:
	  size = 4;
	  where = (operand->mode & SIZE) == L_24 ? -1 : 0;
	  if (relaxmode == 2)
	    idx = R_MOV24B1;
	  else if (relaxmode == 1)
	    idx = R_MOVL1;
	  else
	    idx = R_RELLONG;
	  break;
	default:
	  as_bad (_("Can't work out size of operand.\n"));
	case L_16:
	  size = 2;
	  where = 0;
	  if (relaxmode == 2)
	    idx = R_MOV16B1;
	  else
	    idx = R_RELWORD;
	  operand->exp.X_add_number =
	    ((operand->exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
	  break;
	case L_8:
	  size = 1;
	  where = 0;
	  idx = R_RELBYTE;
	  operand->exp.X_add_number =
	    ((operand->exp.X_add_number & 0xff) ^ 0x80) - 0x80;
	}

      fix_new_exp (frag_now,
		   offset + where,
		   size,
		   &operand->exp,
		   0,
		   idx);
    }
}

/* Now we know what sort of opcodes it is, let's build the bytes.  */

static void
build_bytes (this_try, operand)
     const struct h8_instruction *this_try;
     struct h8_op *operand;
{
  int i;
  char *output = frag_more (this_try->length);
  op_type *nibble_ptr = this_try->opcode->data.nib;
  op_type c;
  unsigned int nibble_count = 0;
  int absat = 0;
  int immat = 0;
  int nib = 0;
  int movb = 0;
  char asnibbles[30];
  char *p = asnibbles;

  if (!(this_try->opcode->inbase || Hmode))
    as_warn (_("Opcode `%s' with these operand types not available in H8/300 mode"),
	     this_try->opcode->name);

  while (*nibble_ptr != E)
    {
      int d;
      c = *nibble_ptr++;

      d = (c & (DST | SRC_IN_DST)) != 0;

      if (c < 16)
	nib = c;
      else
	{
	  if (c & (REG | IND | INC | DEC))
	    nib = operand[d].reg;

	  else if ((c & DISPREG) == (DISPREG))
	    nib = dispreg;

	  else if (c & ABS)
	    {
	      operand[d].mode = c;
	      absat = nibble_count / 2;
	      nib = 0;
	    }
	  else if (c & (IMM | PCREL | ABS | ABSJMP | DISP))
	    {
	      operand[d].mode = c;
	      immat = nibble_count / 2;
	      nib = 0;
	    }
	  else if (c & IGNORE)
	    nib = 0;

	  else if (c & DBIT)
	    {
	      switch (operand[0].exp.X_add_number)
		{
		case 1:
		  nib = c;
		  break;
		case 2:
		  nib = 0x8 | c;
		  break;
		default:
		  as_bad (_("Need #1 or #2 here"));
		}
	    }
	  else if (c & KBIT)
	    {
	      switch (operand[0].exp.X_add_number)
		{
		case 1:
		  nib = 0;
		  break;
		case 2:
		  nib = 8;
		  break;
		case 4:
		  if (!Hmode)
		    as_warn (_("#4 not valid on H8/300."));
		  nib = 9;
		  break;

		default:
		  as_bad (_("Need #1 or #2 here"));
		  break;
		}
	      /* Stop it making a fix.  */
	      operand[0].mode = 0;
	    }

	  if (c & MEMRELAX)
	    operand[d].mode |= MEMRELAX;

	  if (c & B31)
	    nib |= 0x8;

	  if (c & MACREG)
	    {
	      if (operand[0].mode == MACREG)
		/* stmac has mac[hl] as the first operand.  */
		nib = 2 + operand[0].reg;
	      else
		/* ldmac has mac[hl] as the second operand.  */
		nib = 2 + operand[1].reg;
	    }
	}
      nibble_count++;

      *p++ = nib;
    }

  /* Disgusting.  Why, oh why didn't someone ask us for advice
     on the assembler format.  */
  if (strcmp (this_try->opcode->name, "stm.l") == 0
      || strcmp (this_try->opcode->name, "ldm.l") == 0)
    {
      int high, low;
      high = (operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg >> 8) & 0xf;
      low = operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg & 0xf;

      asnibbles[2] = high - low;
      asnibbles[7] = (this_try->opcode->name[0] == 'l') ? high : low;
    }

  for (i = 0; i < this_try->length; i++)
    output[i] = (asnibbles[i * 2] << 4) | asnibbles[i * 2 + 1];

  /* Note if this is a movb instruction -- there's a special relaxation
     which only applies to them.  */
  if (strcmp (this_try->opcode->name, "mov.b") == 0)
    movb = 1;

  /* Output any fixes.  */
  for (i = 0; i < 2; i++)
    {
      int x = operand[i].mode;

      if (x & (IMM | DISP))
	do_a_fix_imm (output - frag_now->fr_literal + immat,
		      operand + i, (x & MEMRELAX) != 0);

      else if (x & ABS)
	do_a_fix_imm (output - frag_now->fr_literal + absat,
		      operand + i, (x & MEMRELAX) ? movb + 1 : 0);

      else if (x & PCREL)
	{
	  int size16 = x & (L_16);
	  int where = size16 ? 2 : 1;
	  int size = size16 ? 2 : 1;
	  int type = size16 ? R_PCRWORD : R_PCRBYTE;
	  fixS *fixP;

	  check_operand (operand + i, size16 ? 0x7fff : 0x7f, "@@");

	  if (operand[i].exp.X_add_number & 1)
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);
#ifndef OBJ_ELF
	  /* The COFF port has always been off by one, changing it
	     now would be an incompatible change, so we leave it as-is.

	     We don't want to do this for ELF as we want to be
	     compatible with the proposed ELF format from Hitachi.  */
	  operand[i].exp.X_add_number -= 1;
#endif
	  operand[i].exp.X_add_number =
	    ((operand[i].exp.X_add_number & 0xff) ^ 0x80) - 0x80;

	  fixP = fix_new_exp (frag_now,
			      output - frag_now->fr_literal + where,
			      size,
			      &operand[i].exp,
			      1,
			      type);
	  fixP->fx_signed = 1;
	}
      else if (x & MEMIND)
	{
	  check_operand (operand + i, 0xff, "@@@@");
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + 1,
		       1,
		       &operand[i].exp,
		       0,
		       R_MEM_INDIRECT);
	}
      else if (x & ABSJMP)
	{
	  int where = 0;

#ifdef OBJ_ELF
	  /* To be compatible with the proposed H8 ELF format, we
	     want the relocation's offset to point to the first byte
	     that will be modified, not to the start of the instruction.  */
	  where += 1;
#endif

	  /* This jmp may be a jump or a branch.  */

	  check_operand (operand + i, Hmode ? 0xffffff : 0xffff, "@@");

	  if (operand[i].exp.X_add_number & 1)
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);

	  if (!Hmode)
	    operand[i].exp.X_add_number =
	      ((operand[i].exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + where,
		       4,
		       &operand[i].exp,
		       0,
		       R_JMPL1);
	}
    }
}

/* Try to give an intelligent error message for common and simple to
   detect errors.  */

static void
clever_message (instruction, operand)
     const struct h8_instruction *instruction;
     struct h8_op *operand;
{
  /* Find out if there was more than one possible opcode.  */

  if ((instruction + 1)->idx != instruction->idx)
    {
      int argn;

      /* Only one opcode of this flavour, try to guess which operand
         didn't match.  */
      for (argn = 0; argn < instruction->noperands; argn++)
	{
	  switch (instruction->opcode->args.nib[argn])
	    {
	    case RD16:
	      if (operand[argn].mode != RD16)
		{
		  as_bad (_("destination operand must be 16 bit register"));
		  return;

		}
	      break;

	    case RS8:
	      if (operand[argn].mode != RS8)
		{
		  as_bad (_("source operand must be 8 bit register"));
		  return;
		}
	      break;

	    case ABS16DST:
	      if (operand[argn].mode != ABS16DST)
		{
		  as_bad (_("destination operand must be 16bit absolute address"));
		  return;
		}
	      break;
	    case RD8:
	      if (operand[argn].mode != RD8)
		{
		  as_bad (_("destination operand must be 8 bit register"));
		  return;
		}
	      break;

	    case ABS16SRC:
	      if (operand[argn].mode != ABS16SRC)
		{
		  as_bad (_("source operand must be 16bit absolute address"));
		  return;
		}
	      break;

	    }
	}
    }
  as_bad (_("invalid operands"));
}

/* This is the guts of the machine-dependent assembler.  STR points to
   a machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles.  */

void
md_assemble (str)
     char *str;
{
  char *op_start;
  char *op_end;
  struct h8_op operand[2];
  const struct h8_instruction *instruction;
  const struct h8_instruction *prev_instruction;

  char *dot = 0;
  char c;
  int size;

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the op code end.  */
  for (op_start = op_end = str;
       *op_end != 0 && *op_end != ' ';
       op_end++)
    {
      if (*op_end == '.')
	{
	  dot = op_end + 1;
	  *op_end = 0;
	  op_end += 2;
	  break;
	}
    }

  if (op_end == op_start)
    {
      as_bad (_("can't find opcode "));
    }
  c = *op_end;

  *op_end = 0;

  instruction = (const struct h8_instruction *)
    hash_find (opcode_hash_control, op_start);

  if (instruction == NULL)
    {
      as_bad (_("unknown opcode"));
      return;
    }

  /* We used to set input_line_pointer to the result of get_operands,
     but that is wrong.  Our caller assumes we don't change it.  */

  (void) get_operands (instruction->noperands, op_end, operand);
  *op_end = c;
  prev_instruction = instruction;

  size = SN;
  if (dot)
    {
      switch (*dot)
	{
	case 'b':
	  size = SB;
	  break;

	case 'w':
	  size = SW;
	  break;

	case 'l':
	  size = SL;
	  break;
	}
    }
  instruction = get_specific (instruction, operand, size);

  if (instruction == 0)
    {
      /* Couldn't find an opcode which matched the operands.  */
      char *where = frag_more (2);

      where[0] = 0x0;
      where[1] = 0x0;
      clever_message (prev_instruction, operand);

      return;
    }
  if (instruction->size && dot)
    {
      if (instruction->size != *dot)
	{
	  as_warn (_("mismatch between opcode size and operand size"));
	}
    }

  build_bytes (instruction, operand);

#ifdef BFD_ASSEMBLER
  dwarf2_emit_insn (instruction->length);
#endif
}

#ifndef BFD_ASSEMBLER
void
tc_crawl_symbol_chain (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
{
  printf (_("call to tc_crawl_symbol_chain \n"));
}
#endif

symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}

#ifndef BFD_ASSEMBLER
void
tc_headers_hook (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
{
  printf (_("call to tc_headers_hook \n"));
}
#endif

/* Various routines to kill one day */
/* Equal to MAX_PRECISION in atof-ieee.c */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

const char *md_shortopts = "";
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
{
  return 0;
}

void
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
{
}

void tc_aout_fix_to_chars PARAMS ((void));

void
tc_aout_fix_to_chars ()
{
  printf (_("call to tc_aout_fix_to_chars \n"));
  abort ();
}

void
md_convert_frag (headers, seg, fragP)
#ifdef BFD_ASSEMBLER
     bfd *headers ATTRIBUTE_UNUSED;
#else
     object_headers *headers ATTRIBUTE_UNUSED;
#endif
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
{
  printf (_("call to md_convert_frag \n"));
  abort ();
}

#ifdef BFD_ASSEMBLER
valueT
md_section_align (segment, size)
     segT segment;
     valueT size;
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  return ((size + (1 << align) - 1) & (-1 << align));
}
#else
valueT
md_section_align (seg, size)
     segT seg;
     valueT size;
{
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
}
#endif


void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
{
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  long val = *valP;

  switch (fixP->fx_size)
    {
    case 1:
      *buf++ = val;
      break;
    case 2:
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    case 4:
      *buf++ = (val >> 24);
      *buf++ = (val >> 16);
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    default:
      abort ();
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

int
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP ATTRIBUTE_UNUSED;
     register segT segment_type ATTRIBUTE_UNUSED;
{
  printf (_("call tomd_estimate_size_before_relax \n"));
  abort ();
}

/* Put number into target byte order.  */
void
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
{
  number_to_chars_bigendian (ptr, use, nbytes);
}

long
md_pcrel_from (fixP)
     fixS *fixP ATTRIBUTE_UNUSED;
{
  abort ();
}

#ifndef BFD_ASSEMBLER
void
tc_reloc_mangle (fix_ptr, intr, base)
     fixS *fix_ptr;
     struct internal_reloc *intr;
     bfd_vma base;

{
  symbolS *symbol_ptr;

  symbol_ptr = fix_ptr->fx_addsy;

  /* If this relocation is attached to a symbol then it's ok
     to output it.  */
  if (fix_ptr->fx_r_type == TC_CONS_RELOC)
    {
      /* cons likes to create reloc32's whatever the size of the reloc..
       */
      switch (fix_ptr->fx_size)
	{
	case 4:
	  intr->r_type = R_RELLONG;
	  break;
	case 2:
	  intr->r_type = R_RELWORD;
	  break;
	case 1:
	  intr->r_type = R_RELBYTE;
	  break;
	default:
	  abort ();
	}
    }
  else
    {
      intr->r_type = fix_ptr->fx_r_type;
    }

  intr->r_vaddr = fix_ptr->fx_frag->fr_address + fix_ptr->fx_where + base;
  intr->r_offset = fix_ptr->fx_offset;

  if (symbol_ptr)
    {
      if (symbol_ptr->sy_number != -1)
	intr->r_symndx = symbol_ptr->sy_number;
      else
	{
	  symbolS *segsym;

	  /* This case arises when a reference is made to `.'.  */
	  segsym = seg_info (S_GET_SEGMENT (symbol_ptr))->dot;
	  if (segsym == NULL)
	    intr->r_symndx = -1;
	  else
	    {
	      intr->r_symndx = segsym->sy_number;
	      intr->r_offset += S_GET_VALUE (symbol_ptr);
	    }
	}
    }
  else
    intr->r_symndx = -1;
}
#else /* BFD_ASSEMBLER */
arelent *
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *rel;
  bfd_reloc_code_real_type r_type;

  if (fixp->fx_addsy && fixp->fx_subsy)
    {
      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
	  || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"Difference of symbols in different sections is not supported");
	  return NULL;
	}
    }

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
  rel->addend = fixp->fx_offset;

  r_type = fixp->fx_r_type;

#define DEBUG 0
#if DEBUG
  fprintf (stderr, "%s\n", bfd_get_reloc_code_name (r_type));
  fflush(stderr);
#endif
  rel->howto = bfd_reloc_type_lookup (stdoutput, r_type);
  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (r_type));
      return NULL;
    }

  return rel;
}
#endif
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
/* tc-h8300.c -- Assemble code for the Hitachi H8/300
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000
   Free Software Foundation, Inc.
d28 5
d36 5
a40 1
#include <ctype.h>
d46 7
a52 8
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
   */

void cons ();
d56 2
d61 13
a73 1
int bsize = L_8;		/* default branch displacement */
d76 2
a77 1
h8300hmode ()
d81 4
d88 2
a89 1
h8300smode ()
d93 30
d133 2
a134 1
pint ()
d139 6
d148 1
d150 1
d154 5
d175 3
a177 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d180 1
a180 1
static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */
d185 1
d189 3
a191 1
  struct h8_opcode *opcode;
d195 5
d203 6
a208 1
  for (opcode = h8_opcodes; opcode->name; opcode++)
d212 1
a212 1
      char *src = opcode->name;
d217 1
a217 1
      opcode->size = 0;
d223 1
a223 1
	      opcode->size = *src;
d231 1
a231 1
	  hash_insert (opcode_hash_control, buffer, (char *) opcode);
d235 1
a235 1
      opcode->idx = idx;
d238 3
a240 3
      opcode->noperands = 0;
      while (opcode->args.nib[opcode->noperands] != E)
	opcode->noperands++;
d243 5
a247 3
      opcode->length = 0;
      while (opcode->data.nib[opcode->length * 2] != E)
	opcode->length++;
d250 7
d268 1
a268 1
int opsize;			/* Set when a register size is seen */
d277 12
a307 1

d420 1
a420 1
	  /* ff fill any 8 bit quantity */
d438 1
a438 1
	  while (isdigit (*ptr))
d458 1
a458 3
   @@@@aa[:8]		memory indirect

   */
a463 1

d485 1
a487 1

d504 4
d510 2
a511 2
  if (src[0] == 'e' && src[1] == 'r' && isdigit (src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && isdigit (src[6]))
d537 4
a540 1
      *ptr = src + 7;
d708 1
a708 3
	    {
	      as_bad (_("expect :8 or :16 here"));
	    }
d711 2
a712 3
	{
	  op->mode = PCREL | bsize;
	}
d764 4
a767 3
static struct h8_opcode *
get_specific (opcode, operands, size)
     struct h8_opcode *opcode;
d771 1
a771 1
  struct h8_opcode *this_try = opcode;
d773 1
a773 2

  unsigned int this_index = opcode->idx;
d777 2
a778 2
  if (strcmp (opcode->name, "stm.l") == 0
      || strcmp (opcode->name, "ldm.l") == 0)
d781 1
a781 1
  while (this_index == opcode->idx && !found)
d785 1
a785 1
      this_try = opcode++;
d790 1
a790 1
	  this_size = this_try->how & SN;
d796 1
a796 1
	  unsigned int i;
d800 1
a800 1
	      op_type op = this_try->args.nib[i];
d896 1
a896 1
	  (operand->exp.X_add_number | width) != (~0))
d905 8
d1032 1
d1035 1
a1035 1
     struct h8_opcode *this_try;
d1038 1
a1038 2
  unsigned int i;

d1040 1
a1040 1
  op_type *nibble_ptr = this_try->data.nib;
d1043 3
a1045 3
  int absat;
  int immat;
  int nib;
d1050 1
a1050 1
  if (!(this_try->inbase || Hmode))
d1052 1
a1052 1
	     this_try->name);
d1062 1
a1062 3
	{
	  nib = c;
	}
d1066 2
a1067 3
	    {
	      nib = operand[d].reg;
	    }
d1069 2
a1070 3
	    {
	      nib = dispreg;
	    }
d1084 2
a1085 3
	    {
	      nib = 0;
	    }
d1125 1
a1125 3
	    {
	      operand[d].mode |= MEMRELAX;
	    }
d1128 1
a1128 3
	    {
	      nib |= 0x8;
	    }
d1147 2
a1148 2
  if (strcmp (this_try->name, "stm.l") == 0
      || strcmp (this_try->name, "ldm.l") == 0)
d1151 2
a1152 2
      high = (operand[this_try->name[0] == 'l' ? 1 : 0].reg >> 8) & 0xf;
      low = operand[this_try->name[0] == 'l' ? 1 : 0].reg & 0xf;
d1155 1
a1155 1
      asnibbles[7] = (this_try->name[0] == 'l') ? high : low;
d1159 1
a1159 3
    {
      output[i] = (asnibbles[i * 2] << 4) | asnibbles[i * 2 + 1];
    }
d1163 1
a1163 1
  if (strcmp (this_try->name, "mov.b") == 0)
d1172 3
a1174 4
	{
	  do_a_fix_imm (output - frag_now->fr_literal + immat,
			operand + i, x & MEMRELAX != 0);
	}
d1176 3
a1178 4
	{
	  do_a_fix_imm (output - frag_now->fr_literal + absat,
			operand + i, x & MEMRELAX ? movb + 1 : 0);
	}
d1181 1
a1181 1
	  int size16 = x & L_16;
d1185 1
d1190 5
a1194 4
	    {
	      as_warn (_("branch operand has odd offset (%lx)\n"),
		       (unsigned long) operand->exp.X_add_number);
	    }
d1196 2
d1199 1
d1203 7
a1209 6
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + where,
		       size,
		       &operand[i].exp,
		       1,
		       type);
d1223 9
d1235 1
d1237 3
a1239 4
	    {
	      as_warn (_("branch operand has odd offset (%lx)\n"),
		       (unsigned long) operand->exp.X_add_number);
	    }
d1244 1
a1244 1
		       output - frag_now->fr_literal,
d1255 1
d1257 2
a1258 2
clever_message (opcode, operand)
     struct h8_opcode *opcode;
d1263 1
a1263 1
  if ((opcode + 1)->idx != opcode->idx)
d1265 1
a1265 1
      unsigned int argn;
d1269 1
a1269 1
      for (argn = 0; argn < opcode->noperands; argn++)
d1271 1
a1271 1
	  switch (opcode->args.nib[argn])
d1322 1
d1330 2
a1331 2
  struct h8_opcode *opcode;
  struct h8_opcode *prev_opcode;
d1363 2
a1364 2
  opcode = (struct h8_opcode *) hash_find (opcode_hash_control,
					   op_start);
d1366 1
a1366 1
  if (opcode == NULL)
d1375 1
a1375 1
  (void) get_operands (opcode->noperands, op_end, operand);
d1377 1
a1377 1
  prev_opcode = opcode;
d1397 1
a1397 1
  opcode = get_specific (opcode, operand, size);
d1399 1
a1399 1
  if (opcode == 0)
d1406 1
a1406 1
      clever_message (prev_opcode, operand);
d1410 1
a1410 1
  if (opcode->size && dot)
d1412 1
a1412 1
      if (opcode->size != *dot)
d1418 5
a1422 1
  build_bytes (opcode, operand);
d1425 1
d1432 1
d1441 1
d1448 1
a1468 1
  char *atof_ieee ();
d1513 1
a1513 1
CONST char *md_shortopts = "";
d1534 2
d1545 3
d1549 1
d1557 10
d1575 2
d1579 1
a1579 1
md_apply_fix (fixP, val)
d1581 2
a1582 1
     long val;
d1585 1
d1605 3
d1636 1
d1699 45
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d1 3
a3 3
/* tc-h8300.c -- Assemble code for the Renesas H8/300
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001, 2002, 2003 Free Software Foundation, Inc.
a27 5

#ifdef BFD_ASSEMBLER
#include "dwarf2dbg.h"
#endif

d31 1
a31 5
#include "safe-ctype.h"

#ifdef OBJ_ELF
#include "elf/h8.h"
#endif
d37 8
a44 7
void cons        PARAMS ((int));
void sbranch     PARAMS ((int));
void h8300hmode  PARAMS ((int));
void h8300smode  PARAMS ((int));
void h8300hnmode PARAMS ((int));
void h8300snmode PARAMS ((int));
static void pint PARAMS ((int));
a47 2
int Nmode;

d51 1
a51 13

int bsize = L_8;		/* Default branch displacement.  */

struct h8_instruction
{
  int length;
  int noperands;
  int idx;
  int size;
  const struct h8_opcode *opcode;
};

struct h8_instruction *h8_instructions;
d54 1
a54 2
h8300hmode (arg)
     int arg ATTRIBUTE_UNUSED;
a57 4
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300h))
    as_warn (_("could not set architecture and machine"));
#endif
d61 1
a61 2
h8300smode (arg)
     int arg ATTRIBUTE_UNUSED;
a64 30
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300s))
    as_warn (_("could not set architecture and machine"));
#endif
}

void
h8300hnmode (arg)
     int arg ATTRIBUTE_UNUSED;
{
  Hmode = 1;
  Smode = 0;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300hn))
    as_warn (_("could not set architecture and machine"));
#endif
}

void
h8300snmode (arg)
     int arg ATTRIBUTE_UNUSED;
{
  Smode = 1;
  Hmode = 1;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sn))
    as_warn (_("could not set architecture and machine"));
#endif
d75 1
a75 2
pint (arg)
     int arg ATTRIBUTE_UNUSED;
a79 6
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */

a82 1
  {"h8300hn", h8300hnmode, 0},
a83 1
  {"h8300sn", h8300snmode, 0},
a86 5
#ifdef BFD_ASSEMBLER
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  {"loc", dwarf2_directive_loc, 0 },
#endif

d103 3
a105 3
/* Chars that mean this number is a floating point constant
   As in 0f12.456
   or    0d1.2345e12.  */
d108 1
a108 1
static struct hash_control *opcode_hash_control;	/* Opcode mnemonics.  */
a112 1

d116 1
a116 3
  unsigned int nopcodes;
  const struct h8_opcode *p;
  struct h8_instruction *pi;
a119 5
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300))
    as_warn (_("could not set architecture and machine"));
#endif

d123 1
a123 6
  nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);
  
  h8_instructions = (struct h8_instruction *)
    xmalloc (nopcodes * sizeof (struct h8_instruction));

  for (p = h8_opcodes, pi = h8_instructions; p->name; p++, pi++)
d127 1
a127 1
      char *src = p->name;
d132 1
a132 1
      pi->size = 0;
d138 1
a138 1
	      pi->size = *src;
d146 1
a146 1
	  hash_insert (opcode_hash_control, buffer, (char *) pi);
d150 1
a150 1
      pi->idx = idx;
d153 3
a155 3
      pi->noperands = 0;
      while (p->args.nib[pi->noperands] != E)
	pi->noperands++;
d158 3
a160 5
      pi->length = 0;
      while (p->data.nib[pi->length * 2] != E)
	pi->length++;

      pi->opcode = p;
a162 7
  /* Add entry for the NULL vector terminator.  */
  pi->length = 0;
  pi->noperands = 0;
  pi->idx = 0;
  pi->size = 0;
  pi->opcode = p;

d174 1
a174 1
int opsize;			/* Set when a register size is seen.  */
a182 12
static void clever_message PARAMS ((const struct h8_instruction *, struct h8_op *));
static void build_bytes    PARAMS ((const struct h8_instruction *, struct h8_op *));
static void do_a_fix_imm   PARAMS ((int, struct h8_op *, int));
static void check_operand  PARAMS ((struct h8_op *, unsigned int, char *));
static const struct h8_instruction * get_specific PARAMS ((const struct h8_instruction *, struct h8_op *, int));
static char * get_operands PARAMS ((unsigned, char *, struct h8_op *));
static void   get_operand  PARAMS ((char **, struct h8_op *, unsigned, int));
static char * skip_colonthing PARAMS ((char *, expressionS *, int *));
static char * parse_exp PARAMS ((char *, expressionS *));
static int    parse_reg PARAMS ((char *, op_type *, unsigned *, int));
char * colonmod24 PARAMS ((struct h8_op *, char *));

d202 1
d315 1
a315 1
	  /* ff fill any 8 bit quantity.  */
d333 1
a333 1
	  while (ISDIGIT (*ptr))
d353 3
a355 1
   @@@@aa[:8]		memory indirect.  */
d361 1
a382 1

d385 1
a401 4
  /* Check for '(' and ')' for instructions ldm and stm.  */
  if (src[0] == '(' && src[8] == ')')
    ++ src;

d404 2
a405 2
  if (src[0] == 'e' && src[1] == 'r' && ISDIGIT (src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && ISDIGIT (src[6]))
d431 1
a431 4
      if (src[7] == ')')
	*ptr = src + 8;
      else
	*ptr = src + 7;
d599 3
a601 1
	    as_bad (_("expect :8 or :16 here"));
d604 3
a606 2
	op->mode = PCREL | bsize;

d658 3
a660 4

static const struct h8_instruction *
get_specific (instruction, operands, size)
     const struct h8_instruction *instruction;
d664 1
a664 1
  const struct h8_instruction *this_try = instruction;
d666 2
a667 1
  int this_index = instruction->idx;
d671 2
a672 2
  if (strcmp (instruction->opcode->name, "stm.l") == 0
      || strcmp (instruction->opcode->name, "ldm.l") == 0)
d675 1
a675 1
  while (this_index == instruction->idx && !found)
d679 1
a679 1
      this_try = instruction++;
d684 1
a684 1
	  this_size = this_try->opcode->how & SN;
d690 1
a690 1
	  int i;
d694 1
a694 1
	      op_type op = this_try->opcode->args.nib[i];
d790 1
a790 1
	  (operand->exp.X_add_number | width) != (unsigned)(~0))
a798 8
	  else if (strcmp (string, "@@") == 0
		   && width == 0xffff
		   && (operand->exp.X_add_number & 0xff8000) == 0xff8000)
	    {
	      /* Just ignore this one - which happens when trying to
		 fit a 24 bit address truncated into a 16 bit address
		 of something like mov.w.  */
	    }
a917 1

d920 1
a920 1
     const struct h8_instruction *this_try;
d923 2
a924 1
  int i;
d926 1
a926 1
  op_type *nibble_ptr = this_try->opcode->data.nib;
d929 3
a931 3
  int absat = 0;
  int immat = 0;
  int nib = 0;
d936 1
a936 1
  if (!(this_try->opcode->inbase || Hmode))
d938 1
a938 1
	     this_try->opcode->name);
d948 3
a950 1
	nib = c;
d954 3
a956 2
	    nib = operand[d].reg;

d958 3
a960 2
	    nib = dispreg;

d974 3
a976 2
	    nib = 0;

d1016 3
a1018 1
	    operand[d].mode |= MEMRELAX;
d1021 3
a1023 1
	    nib |= 0x8;
d1042 2
a1043 2
  if (strcmp (this_try->opcode->name, "stm.l") == 0
      || strcmp (this_try->opcode->name, "ldm.l") == 0)
d1046 2
a1047 2
      high = (operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg >> 8) & 0xf;
      low = operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg & 0xf;
d1050 1
a1050 1
      asnibbles[7] = (this_try->opcode->name[0] == 'l') ? high : low;
d1054 3
a1056 1
    output[i] = (asnibbles[i * 2] << 4) | asnibbles[i * 2 + 1];
d1060 1
a1060 1
  if (strcmp (this_try->opcode->name, "mov.b") == 0)
d1069 4
a1072 3
	do_a_fix_imm (output - frag_now->fr_literal + immat,
		      operand + i, (x & MEMRELAX) != 0);

d1074 4
a1077 3
	do_a_fix_imm (output - frag_now->fr_literal + absat,
		      operand + i, (x & MEMRELAX) ? movb + 1 : 0);

d1080 1
a1080 1
	  int size16 = x & (L_16);
a1083 1
	  fixS *fixP;
d1088 4
a1091 5
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);
#ifndef OBJ_ELF
	  /* The COFF port has always been off by one, changing it
	     now would be an incompatible change, so we leave it as-is.
a1092 2
	     We don't want to do this for ELF as we want to be
	     compatible with the proposed ELF format from Hitachi.  */
a1093 1
#endif
d1097 6
a1102 7
	  fixP = fix_new_exp (frag_now,
			      output - frag_now->fr_literal + where,
			      size,
			      &operand[i].exp,
			      1,
			      type);
	  fixP->fx_signed = 1;
a1115 9
	  int where = 0;

#ifdef OBJ_ELF
	  /* To be compatible with the proposed H8 ELF format, we
	     want the relocation's offset to point to the first byte
	     that will be modified, not to the start of the instruction.  */
	  where += 1;
#endif

a1118 1

d1120 4
a1123 3
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);

d1128 1
a1128 1
		       output - frag_now->fr_literal + where,
a1138 1

d1140 2
a1141 2
clever_message (instruction, operand)
     const struct h8_instruction *instruction;
d1146 1
a1146 1
  if ((instruction + 1)->idx != instruction->idx)
d1148 1
a1148 1
      int argn;
d1152 1
a1152 1
      for (argn = 0; argn < instruction->noperands; argn++)
d1154 1
a1154 1
	  switch (instruction->opcode->args.nib[argn])
a1204 1

d1212 2
a1213 2
  const struct h8_instruction *instruction;
  const struct h8_instruction *prev_instruction;
d1245 2
a1246 2
  instruction = (const struct h8_instruction *)
    hash_find (opcode_hash_control, op_start);
d1248 1
a1248 1
  if (instruction == NULL)
d1257 1
a1257 1
  (void) get_operands (instruction->noperands, op_end, operand);
d1259 1
a1259 1
  prev_instruction = instruction;
d1279 1
a1279 1
  instruction = get_specific (instruction, operand, size);
d1281 1
a1281 1
  if (instruction == 0)
d1288 1
a1288 1
      clever_message (prev_instruction, operand);
d1292 1
a1292 1
  if (instruction->size && dot)
d1294 1
a1294 1
      if (instruction->size != *dot)
d1300 1
a1300 5
  build_bytes (instruction, operand);

#ifdef BFD_ASSEMBLER
  dwarf2_emit_insn (instruction->length);
#endif
a1302 1
#ifndef BFD_ASSEMBLER
a1308 1
#endif
a1316 1
#ifndef BFD_ASSEMBLER
a1322 1
#endif
d1343 1
d1388 1
a1388 1
const char *md_shortopts = "";
a1408 2
void tc_aout_fix_to_chars PARAMS ((void));

a1417 3
#ifdef BFD_ASSEMBLER
     bfd *headers ATTRIBUTE_UNUSED;
#else
a1418 1
#endif
a1425 10
#ifdef BFD_ASSEMBLER
valueT
md_section_align (segment, size)
     segT segment;
     valueT size;
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  return ((size + (1 << align) - 1) & (-1 << align));
}
#else
a1433 2
#endif

d1436 1
a1436 1
md_apply_fix3 (fixP, valP, seg)
d1438 1
a1438 2
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
a1440 1
  long val = *valP;
a1459 3

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
a1487 1
#ifndef BFD_ASSEMBLER
a1549 45
#else /* BFD_ASSEMBLER */
arelent *
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *rel;
  bfd_reloc_code_real_type r_type;

  if (fixp->fx_addsy && fixp->fx_subsy)
    {
      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
	  || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"Difference of symbols in different sections is not supported");
	  return NULL;
	}
    }

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
  rel->addend = fixp->fx_offset;

  r_type = fixp->fx_r_type;

#define DEBUG 0
#if DEBUG
  fprintf (stderr, "%s\n", bfd_get_reloc_code_name (r_type));
  fflush(stderr);
#endif
  rel->howto = bfd_reloc_type_lookup (stdoutput, r_type);
  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (r_type));
      return NULL;
    }

  return rel;
}
#endif
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d46 7
a52 8
static void sbranch (int);
static void h8300hmode (int);
static void h8300smode (int);
static void h8300hnmode (int);
static void h8300snmode (int);
static void h8300sxmode (int);
static void h8300sxnmode (int);
static void pint (int);
a56 1
int SXmode;
d58 3
a60 1
#define PSIZE (Hmode && !Nmode ? L_32 : L_16)
d62 1
a62 1
static int bsize = L_8;		/* Default branch displacement.  */
d73 1
a73 1
static struct h8_instruction *h8_instructions;
d75 3
a77 2
static void
h8300hmode (int arg ATTRIBUTE_UNUSED)
d87 3
a89 2
static void
h8300smode (int arg ATTRIBUTE_UNUSED)
d99 3
a101 2
static void
h8300hnmode (int arg ATTRIBUTE_UNUSED)
d112 3
a114 2
static void
h8300snmode (int arg ATTRIBUTE_UNUSED)
d125 3
a127 27
static void
h8300sxmode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
  SXmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sx))
    as_warn (_("could not set architecture and machine"));
#endif
}

static void
h8300sxnmode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
  SXmode = 1;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sxn))
    as_warn (_("could not set architecture and machine"));
#endif
}

static void
sbranch (int size)
d133 2
a134 1
pint (int arg ATTRIBUTE_UNUSED)
d147 1
a147 1
  {"h8300h",  h8300hmode,  0},
d149 1
a149 1
  {"h8300s",  h8300smode,  0},
a150 2
  {"h8300sx", h8300sxmode, 0},
  {"h8300sxn", h8300sxnmode, 0},
d154 5
d165 2
a166 2
  {"import",  s_ignore, 0},
  {"page",    listing_eject, 0},
d187 1
a187 1
md_begin (void)
d190 1
a190 1
  struct h8_opcode *p, *p1;
d208 8
a215 13
  pi = h8_instructions;
  p1 = h8_opcodes;
  /* We do a minimum amount of sorting on the opcode table; this is to
     make it easy to describe the mova instructions without unnecessary
     code duplication.
     Sorting only takes place inside blocks of instructions of the form
     X/Y, so for example mova/b, mova/w and mova/l can be intermixed.  */
  while (p1)
    {
      struct h8_opcode *first_skipped = 0;
      int len, cmplen = 0;
      char *src = p1->name;
      char *dst, *buffer;
d217 1
a217 5
      if (p1->name == 0)
	break;
      /* Strip off any . part when inserting the opcode and only enter
	 unique codes into the hash table.  */
      dst = buffer = malloc (strlen (src) + 1);
d223 1
a225 2
	  if (*src == '/')
	    cmplen = src - p1->name + 1;
d228 18
a245 37
      *dst = 0;
      len = dst - buffer;
      if (cmplen == 0)
	cmplen = len;
      hash_insert (opcode_hash_control, buffer, (char *) pi);
      strcpy (prev_buffer, buffer);
      idx++;

      for (p = p1; p->name; p++)
	{
	  /* A negative TIME is used to indicate that we've added this opcode
	     already.  */
	  if (p->time == -1)
	    continue;
	  if (strncmp (p->name, buffer, cmplen) != 0
	      || (p->name[cmplen] != '\0' && p->name[cmplen] != '.'
		  && p->name[cmplen - 1] != '/'))
	    {
	      if (first_skipped == 0)
		first_skipped = p;
	      break;
	    }
	  if (strncmp (p->name, buffer, len) != 0)
	    {
	      if (first_skipped == 0)
		first_skipped = p;
	      continue;
	    }

	  p->time = -1;
	  pi->size = p->name[len] == '.' ? p->name[len + 1] : 0;
	  pi->idx = idx;

	  /* Find the number of operands.  */
	  pi->noperands = 0;
	  while (pi->noperands < 3 && p->args.nib[pi->noperands] != (op_type) E)
	    pi->noperands++;
d247 1
a247 9
	  /* Find the length of the opcode in bytes.  */
	  pi->length = 0;
	  while (p->data.nib[pi->length * 2] != (op_type) E)
	    pi->length++;

	  pi->opcode = p;
	  pi++;
	}
      p1 = first_skipped;
d255 1
a255 1
  pi->opcode = 0;
d260 10
d277 11
a287 14
static void clever_message (const struct h8_instruction *, struct h8_op *);
static void fix_operand_size (struct h8_op *, int);
static void build_bytes (const struct h8_instruction *, struct h8_op *);
static void do_a_fix_imm (int, int, struct h8_op *, int);
static void check_operand (struct h8_op *, unsigned int, char *);
static const struct h8_instruction * get_specific (const struct h8_instruction *, struct h8_op *, int) ;
static char *get_operands (unsigned, char *, struct h8_op *);
static void get_operand (char **, struct h8_op *, int);
static int parse_reg (char *, op_type *, unsigned *, int);
static char *skip_colonthing (char *, int *);
static char *parse_exp (char *, struct h8_op *);

static int constant_fits_width_p (struct h8_op *, unsigned int);
static int constant_fits_size_p (struct h8_op *, int, int);
d303 5
a307 1
parse_reg (char *src, op_type *mode, unsigned int *reg, int direction)
d316 1
a316 1
  while ((is_part_of_name (*end) && *end != '.') || *end == '\001')
d320 1
a320 1
  if (len == 2 && TOLOWER (src[0]) == 's' && TOLOWER (src[1]) == 'p')
d326 1
a326 4
  if (len == 3 && 
      TOLOWER (src[0]) == 'c' && 
      TOLOWER (src[1]) == 'c' && 
      TOLOWER (src[2]) == 'r')
d332 1
a332 4
  if (len == 3 && 
      TOLOWER (src[0]) == 'e' && 
      TOLOWER (src[1]) == 'x' && 
      TOLOWER (src[2]) == 'r')
d335 1
a335 19
      *reg = 1;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 'v' && 
      TOLOWER (src[1]) == 'b' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = VBR;
      *reg = 6;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 's' && 
      TOLOWER (src[1]) == 'b' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = SBR;
      *reg = 7;
d338 1
a338 1
  if (len == 2 && TOLOWER (src[0]) == 'f' && TOLOWER (src[1]) == 'p')
d344 2
a345 2
  if (len == 3 && TOLOWER (src[0]) == 'e' && TOLOWER (src[1]) == 'r' &&
      src[2] >= '0' && src[2] <= '7')
d353 1
a353 1
  if (len == 2 && TOLOWER (src[0]) == 'e' && src[1] >= '0' && src[1] <= '7')
d362 1
a362 1
  if (TOLOWER (src[0]) == 'r')
d366 1
a366 1
	  if (len == 3 && TOLOWER (src[2]) == 'l')
d372 1
a372 1
	  if (len == 3 && TOLOWER (src[2]) == 'h')
a389 5

/* Parse an immediate or address-related constant and store it in OP.
   If the user also specifies the operand's size, store that size
   in OP->MODE, otherwise leave it for later code to decide.  */

d391 10
a400 8
parse_exp (char *src, struct h8_op *op)
{
  char *save;

  save = input_line_pointer;
  input_line_pointer = src;
  expression (&op->exp);
  if (op->exp.X_op == O_absent)
d402 1
a402 1
  src = input_line_pointer;
d404 1
a404 2

  return skip_colonthing (src, &op->mode);
a406 4

/* If SRC starts with an explicit operand size, skip it and store the size
   in *MODE.  Leave *MODE unchanged otherwise.  */

d408 4
a411 1
skip_colonthing (char *src, int *mode)
d413 1
a413 1
  if (*src == ':')
d415 1
a415 1
      src++;
d417 7
a423 16
      if (src[0] == '8' && !ISDIGIT (src[1]))
	*mode |= L_8;
      else if (src[0] == '2' && !ISDIGIT (src[1]))
	*mode |= L_2;
      else if (src[0] == '3' && !ISDIGIT (src[1]))
	*mode |= L_3;
      else if (src[0] == '4' && !ISDIGIT (src[1]))
	*mode |= L_4;
      else if (src[0] == '5' && !ISDIGIT (src[1]))
	*mode |= L_5;
      else if (src[0] == '2' && src[1] == '4' && !ISDIGIT (src[2]))
	*mode |= L_24;
      else if (src[0] == '3' && src[1] == '2' && !ISDIGIT (src[2]))
	*mode |= L_32;
      else if (src[0] == '1' && src[1] == '6' && !ISDIGIT (src[2]))
	*mode |= L_16;
d425 16
a440 4
	as_bad (_("invalid operand size requested"));

      while (ISDIGIT (*src))
	src++;
d442 1
a442 1
  return src;
d460 4
a463 2
static int
constant_fits_width_p (struct h8_op *operand, unsigned int width)
d465 2
a466 3
  return ((operand->exp.X_add_number & ~width) == 0
	  || (operand->exp.X_add_number | width) == (unsigned)(~0));
}
d468 1
a468 8
static int
constant_fits_size_p (struct h8_op *operand, int size, int no_symbols)
{
  offsetT num = operand->exp.X_add_number;
  if (no_symbols
      && (operand->exp.X_add_symbol != 0 || operand->exp.X_op_symbol != 0))
    return 0;
  switch (size)
d470 14
a483 22
    case L_2:
      return (num & ~3) == 0;
    case L_3:
      return (num & ~7) == 0;
    case L_3NZ:
      return num >= 1 && num < 8;
    case L_4:
      return (num & ~15) == 0;
    case L_5:
      return num >= 1 && num < 32;
    case L_8:
      return (num & ~0xFF) == 0 || ((unsigned)num | 0x7F) == ~0u;
    case L_8U:
      return (num & ~0xFF) == 0;
    case L_16:
      return (num & ~0xFFFF) == 0 || ((unsigned)num | 0x7FFF) == ~0u;
    case L_16U:
      return (num & ~0xFFFF) == 0;
    case L_32:
      return 1;
    default:
      abort ();
d485 3
d491 5
a495 1
get_operand (char **ptr, struct h8_op *op, int direction)
d502 1
a502 1
  op->mode = 0;
d510 2
a511 3
  if (TOLOWER (src[0]) == 'e' && TOLOWER (src[1]) == 'r' && 
      ISDIGIT (src[2]) && src[3] == '-' &&
      TOLOWER (src[4]) == 'e' && TOLOWER (src[5]) == 'r' && ISDIGIT (src[6]))
d518 11
a528 10
       /* Check register pair's validity as per tech note TN-H8*-193A/E
	  from Renesas for H8S and H8SX hardware manual.  */
      if (   !(low == 0 && (high == 1 || high == 2 || high == 3))
          && !(low == 1 && (high == 2 || high == 3 || high == 4) && SXmode)
          && !(low == 2 && (high == 3 || ((high == 4 || high == 5) && SXmode)))
          && !(low == 3 && (high == 4 || high == 5 || high == 6) && SXmode)
          && !(low == 4 && (high == 5 || high == 6))
          && !(low == 4 && high == 7 && SXmode)
          && !(low == 5 && (high == 6 || high == 7) && SXmode)
          && !(low == 6 && high == 7 && SXmode))
d547 1
a547 31
      src += len;
      if (*src == '.')
	{
	  int size = op->mode & SIZE;
	  switch (src[1])
	    {
	    case 'l': case 'L':
	      if (size != L_32)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      break;
	    case 'w': case 'W':
	      if (size != L_32 && size != L_16)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      op->mode = (op->mode & ~SIZE) | L_16;
	      break;
	    case 'b': case 'B':
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      if (size != L_32 && size != L_8)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      op->mode = (op->mode & ~SIZE) | L_8;
	      break;
	    default:
	      as_warn ("invalid suffix after register.");
	      break;
	    }
	  src += 2;
	}
      *ptr = src;
d556 4
a559 4
	  *ptr = parse_exp (src + 1, op);
	  if (op->exp.X_add_number >= 0x100)
	    {
	      int divisor = 1;
d561 1
a561 8
	      op->mode = VECIND;
	      /* FIXME : 2?  or 4?  */
	      if (op->exp.X_add_number >= 0x400)
		as_bad (_("address too high for vector table jmp/jsr"));
	      else if (op->exp.X_add_number >= 0x200)
		divisor = 4;
	      else
		divisor = 2;
d563 1
a563 4
	      op->exp.X_add_number = op->exp.X_add_number / divisor - 0x80;
	    }
	  else
	    op->mode = MEMIND;
d567 1
a567 1
      if (*src == '-' || *src == '+')
d569 2
a570 1
	  len = parse_reg (src + 1, &mode, &num, direction);
d574 6
a579 2
	      op->mode = ABS | direction;
	      *ptr = parse_exp (src, op);
d583 1
a583 3
	  if (((mode & SIZE) != PSIZE)
	      /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
	      && (!Nmode || ((mode & SIZE) != L_32)))
d585 1
a585 2

	  op->mode = src[0] == '-' ? RDPREDEC : RDPREINC;
d587 1
a587 1
	  *ptr = src + 1 + len;
d592 1
d595 1
a595 33
	  /* See if this is @@(ERn.x, PC).  */
	  len = parse_reg (src, &mode, &op->reg, direction);
	  if (len != 0 && (mode & MODE) == REG && src[len] == '.')
	    {
	      switch (TOLOWER (src[len + 1]))
		{
		case 'b':
		  mode = PCIDXB | direction;
		  break;
		case 'w':
		  mode = PCIDXW | direction;
		  break;
		case 'l':
		  mode = PCIDXL | direction;
		  break;
		default:
		  mode = 0;
		  break;
		}
	      if (mode
		  && src[len + 2] == ','
		  && TOLOWER (src[len + 3]) != 'p' 
		  && TOLOWER (src[len + 4]) != 'c'
		  && src[len + 5] != ')')
		{
		  *ptr = src + len + 6;
		  op->mode |= mode;
		  return;
		}
	      /* Fall through into disp case - the grammar is somewhat
		 ambiguous, so we should try whether it's a DISP operand
		 after all ("ER3.L" might be a poorly named label...).  */
	    }
d597 1
a597 1
	  /* Disp.  */
d599 1
a599 1
	  /* Start off assuming a 16 bit offset.  */
a600 1
	  src = parse_exp (src, op);
d603 1
d605 1
a605 1
	      *ptr = src + 1;
d613 1
d618 1
a618 1
	  if (len == 0 || (mode & MODE) != REG)
d623 2
d626 1
a626 22
	  if (src[0] == '.')
	    {
	      switch (TOLOWER (src[1]))
		{
		case 'b':
		  op->mode |= INDEXB | direction;
		  break;
		case 'w':
		  op->mode |= INDEXW | direction;
		  break;
		case 'l':
		  op->mode |= INDEXL | direction;
		  break;
		default:
		  as_bad (_("expected .L, .W or .B for register in indexed addressing mode"));
		}
	      src += 2;
	      op->reg &= 7;
	    }
	  else
	    op->mode |= DISP | direction;
	  src = skip_colonthing (src, &op->mode);
d634 1
d642 1
a642 1
	  if (*src == '+' || *src == '-')
d644 2
a645 3
	      if (((mode & SIZE) != PSIZE)
		  /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
		  && (!Nmode || ((mode & SIZE) != L_32)))
d647 1
a647 1
	      op->mode = *src == '+' ? RSPOSTINC : RSPOSTDEC;
a648 1
	      src++;
d652 1
a652 3
	  if (((mode & SIZE) != PSIZE)
	      /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
	      && (!Nmode || ((mode & SIZE) != L_32)))
d666 4
a669 1
	  *ptr = parse_exp (src, op);
d676 1
d678 3
a680 1
      *ptr = parse_exp (src + 1, op);
d683 2
a684 4
  else if (strncmp (src, "mach", 4) == 0 || 
	   strncmp (src, "macl", 4) == 0 ||
	   strncmp (src, "MACH", 4) == 0 || 
	   strncmp (src, "MACL", 4) == 0)
d686 1
a686 1
      op->reg = TOLOWER (src[3]) == 'l';
d693 21
a713 2
      op->mode = PCREL;
      *ptr = parse_exp (src, op);
d718 4
a721 1
get_operands (unsigned int noperands, char *op_end, struct h8_op *operand)
d728 2
d734 1
a734 1
      get_operand (&ptr, operand + 0, SRC);
d738 5
a742 1
	  get_operand (&ptr, operand + 1, DST);
d748 1
a748 1
      get_operand (&ptr, operand + 0, SRC);
d751 1
a751 12
      get_operand (&ptr, operand + 1, DST);
      break;

    case 3:
      ptr++;
      get_operand (&ptr, operand + 0, SRC);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, DST);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 2, OP3);
a760 121
/* MOVA has special requirements.  Rather than adding twice the amount of
   addressing modes, we simply special case it a bit.  */
static void
get_mova_operands (char *op_end, struct h8_op *operand)
{
  char *ptr = op_end;

  if (ptr[1] != '@@' || ptr[2] != '(')
    goto error;
  ptr += 3;
  operand[0].mode = 0;
  ptr = parse_exp (ptr, &operand[0]);

  if (*ptr !=',')
    goto error;
  ptr++;
  get_operand (&ptr, operand + 1, DST);

  if (*ptr =='.')
    {
      ptr++;
      switch (*ptr++)
	{
	case 'b': case 'B':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXB;
	  break;
	case 'w': case 'W':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXW;
	  break;
	case 'l': case 'L':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXL;
	  break;
	default:
	  goto error;
	}
    }
  else if ((operand[1].mode & MODE) == LOWREG)
    {
      switch (operand[1].mode & SIZE) 
	{
	case L_8:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXB;
	  break;
	case L_16:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXW;
	  break;
	case L_32:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXL;
	  break;
	default:
	  goto error;
	}
    }
  else
    goto error;

  if (*ptr++ != ')' || *ptr++ != ',')
    goto error;
  get_operand (&ptr, operand + 2, OP3);
  /* See if we can use the short form of MOVA.  */
  if (((operand[1].mode & MODE) == REG || (operand[1].mode & MODE) == LOWREG)
      && (operand[2].mode & MODE) == REG
      && (operand[1].reg & 7) == (operand[2].reg & 7))
    {
      operand[1].mode = operand[2].mode = 0;
      operand[0].reg = operand[2].reg & 7;
    }
  return;

 error:
  as_bad (_("expected valid addressing mode for mova: \"@@(disp, ea.sz),ERn\""));
}

static void
get_rtsl_operands (char *ptr, struct h8_op *operand)
{
  int mode, num, num2, len, type = 0;

  ptr++;
  if (*ptr == '(')
    {
      ptr++;
      type = 1;
    }
  len = parse_reg (ptr, &mode, &num, SRC);
  if (len == 0 || (mode & MODE) != REG)
    {
      as_bad (_("expected register"));
      return;
    }
  ptr += len;
  if (*ptr == '-')
    {
      len = parse_reg (++ptr, &mode, &num2, SRC);
      if (len == 0 || (mode & MODE) != REG)
	{
	  as_bad (_("expected register"));
	  return;
	}
      ptr += len;
      /* CONST_xxx are used as placeholders in the opcode table.  */
      num = num2 - num;
      if (num < 0 || num > 3)
	{
	  as_bad (_("invalid register list"));
	  return;
	}
    }
  else
    num2 = num, num = 0;
  if (type == 1 && *ptr++ != ')')
    {
      as_bad (_("expected closing paren"));
      return;
    }
  operand[0].mode = RS32;
  operand[1].mode = RD32;
  operand[0].reg = num;
  operand[1].reg = num2;
}

d766 4
a769 2
get_specific (const struct h8_instruction *instruction,
	      struct h8_op *operands, int size)
a771 1
  const struct h8_instruction *found_other = 0, *found_mismatched = 0;
a773 1
  int noperands = 0;
d777 2
a778 2
  if (OP_KIND (instruction->opcode->how) == O_LDM
      || OP_KIND (instruction->opcode->how) == O_STM)
a780 3
  while (noperands < 3 && operands[noperands].mode != 0)
    noperands++;

d783 1
a783 1
      int this_size;
a784 1
      found = 1;
d786 3
a788 1
      this_size = this_try->opcode->how & SN;
d790 5
a794 3
      if (this_try->noperands != noperands)
	found = 0;
      else if (this_try->noperands > 0)
a800 2
	      int op_mode = op & MODE;
	      int op_size = op & SIZE;
a801 2
	      int x_mode = x & MODE;
	      int x_size = x & SIZE;
d803 2
a804 1
	      if (op_mode == LOWREG && (x_mode == REG || x_mode == LOWREG))
d806 1
a806 6
		  if ((x_size == L_8 && (operands[i].reg & 8) == 0)
		      || (x_size == L_16 && (operands[i].reg & 8) == 8))
		    as_warn (_("can't use high part of register in operand %d"), i);

		  if (x_size != op_size)
		    found = 0;
d808 1
a808 1
	      else if (op_mode == REG)
d810 1
a810 3
		  if (x_mode == LOWREG)
		    x_mode = REG;
		  if (x_mode != REG)
d813 6
a818 4
		  if (x_size == L_P)
		    x_size = (Hmode ? L_32 : L_16);
		  if (op_size == L_P)
		    op_size = (Hmode ? L_32 : L_16);
d821 1
a821 1
		  if (op_size != x_size)
d824 1
a824 1
	      else if (op_mode & CTRL)	/* control register */
d826 1
a826 44
		  if (!(x_mode & CTRL))
		    found = 0;

		  switch (x_mode)
		    {
		    case CCR:
		      if (op_mode != CCR &&
			  op_mode != CCR_EXR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case EXR:
		      if (op_mode != EXR &&
			  op_mode != CCR_EXR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case MACH:
		      if (op_mode != MACH &&
			  op_mode != MACREG)
			found = 0;
		      break;
		    case MACL:
		      if (op_mode != MACL &&
			  op_mode != MACREG)
			found = 0;
		      break;
		    case VBR:
		      if (op_mode != VBR &&
			  op_mode != VBR_SBR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case SBR:
		      if (op_mode != SBR &&
			  op_mode != VBR_SBR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    }
		}
	      else if ((op & ABSJMP) && (x_mode == ABS || x_mode == PCREL))
		{
		  operands[i].mode &= ~MODE;
d829 1
a829 1
		  if (x_mode == ABS && !Hmode)
a833 3
		  if ((operands[i].mode & SIZE) == L_32
		      && (op_mode & SIZE) != L_32)
		   found = 0;
d835 1
a835 1
	      else if (x_mode == IMM && op_mode != IMM)
d837 1
a837 13
		  offsetT num = operands[i].exp.X_add_number;
		  if (op_mode == KBIT || op_mode == DBIT)
		    /* This is ok if the immediate value is sensible.  */;
		  else if (op_mode == CONST_2)
		    found = num == 2;
		  else if (op_mode == CONST_4)
		    found = num == 4;
		  else if (op_mode == CONST_8)
		    found = num == 8;
		  else if (op_mode == CONST_16)
		    found = num == 16;
		  else
		    found = 0;
d839 1
a839 1
	      else if (op_mode == PCREL && op_mode == x_mode)
a840 8
		  /* movsd, bsr/bc and bsr/bs only come in PCREL16 flavour:
		     If x_size is L_8, promote it.  */
		  if (OP_KIND (this_try->opcode->how) == O_MOVSD
		      || OP_KIND (this_try->opcode->how) == O_BSRBC
		      || OP_KIND (this_try->opcode->how) == O_BSRBS)
		    if (x_size == L_8)
		      x_size = L_16;

d842 1
a842 1
		  if (op_size != x_size)
d845 2
a846 4
	      else if ((op_mode == DISP || op_mode == IMM || op_mode == ABS
			|| op_mode == INDEXB || op_mode == INDEXW
			|| op_mode == INDEXL)
		       && op_mode == x_mode)
d849 1
a849 1
		  if (x_size == L_24 && op_size == L_32)
d851 2
a852 2
		      x &= ~SIZE;
		      x |= x_size = L_32;
a853 2

#if 0 /* ??? */
d855 1
a855 1
		  if ((op_mode == ABS || op_mode == DISP) && x_size == L_8)
d857 2
a858 2
		      if (op_size == L_16)
			x_size = L_16;
d860 2
a861 16
#endif

		  if (((x_size == L_16 && op_size == L_16U)
		       || (x_size == L_8 && op_size == L_8U)
		       || (x_size == L_3 && op_size == L_3NZ))
		      /* We're deliberately more permissive for ABS modes.  */
		      && (op_mode == ABS
			  || constant_fits_size_p (operands + i, op_size,
						   op & NO_SYMBOLS)))
		    x_size = op_size;

		  if (x_size != 0 && op_size != x_size)
		    found = 0;
		  else if (x_size == 0
			   && ! constant_fits_size_p (operands + i, op_size,
						      op & NO_SYMBOLS))
d864 5
a868 1
	      else if (op_mode != x_mode)
a873 10
      if (found)
	{
	  if ((this_try->opcode->available == AV_H8SX && ! SXmode)
	      || (this_try->opcode->available == AV_H8S && ! Smode)
	      || (this_try->opcode->available == AV_H8H && ! Hmode))
	    found = 0, found_other = this_try;
	  else if (this_size != size && (this_size != SN && size != SN))
	    found_mismatched = this_try, found = 0;

	}
d877 2
a878 15
  if (found_other)
    {
      as_warn (_("Opcode `%s' with these operand types not available in %s mode"),
	       found_other->opcode->name,
	       (! Hmode && ! Smode ? "H8/300"
		: SXmode ? "H8sx"
		: Smode ? "H8/300S"
		: "H8/300H"));
    }
  else if (found_mismatched)
    {
      as_warn (_("mismatch between opcode size and operand size"));
      return found_mismatched;
    }
  return 0;
d882 4
a885 1
check_operand (struct h8_op *operand, unsigned int width, char *string)
d895 2
a896 1
      if (! constant_fits_width_p (operand, width))
d933 4
a936 1
do_a_fix_imm (int offset, int nibble, struct h8_op *operand, int relaxmode)
a940 1
  char *bytes = frag_now->fr_literal + offset;
d942 1
a942 1
  char *t = ((operand->mode & MODE) == IMM) ? "#" : "@@";
d946 1
d951 1
a951 1
	  bytes[0] |= (operand->exp.X_add_number & 3) << (nibble ? 0 : 4);
a953 1
	case L_3NZ:
d955 1
a955 9
	  bytes[0] |= (operand->exp.X_add_number & 7) << (nibble ? 0 : 4);
	  break;
	case L_4:
	  check_operand (operand, 0xF, t);
	  bytes[0] |= (operand->exp.X_add_number & 15) << (nibble ? 0 : 4);
	  break;
	case L_5:
	  check_operand (operand, 0x1F, t);
	  bytes[0] |= operand->exp.X_add_number & 31;
a957 1
	case L_8U:
d959 1
a959 1
	  bytes[0] |= operand->exp.X_add_number;
a961 1
	case L_16U:
d963 2
a964 2
	  bytes[0] |= operand->exp.X_add_number >> 8;
	  bytes[1] |= operand->exp.X_add_number >> 0;
d968 3
a970 3
	  bytes[0] |= operand->exp.X_add_number >> 16;
	  bytes[1] |= operand->exp.X_add_number >> 8;
	  bytes[2] |= operand->exp.X_add_number >> 0;
d975 4
a978 4
	  bytes[0] |= operand->exp.X_add_number >> 24;
	  bytes[1] |= operand->exp.X_add_number >> 16;
	  bytes[2] |= operand->exp.X_add_number >> 8;
	  bytes[3] |= operand->exp.X_add_number >> 0;
a1004 1
	case L_16U:
a1012 1
	  operand->exp.X_add_number |= (bytes[0] << 8) | bytes[1];
a1019 1
	  operand->exp.X_add_number |= bytes[0];
d1034 3
a1036 1
build_bytes (const struct h8_instruction *this_try, struct h8_op *operand)
d1043 2
a1044 1
  int op_at[3];
d1047 1
a1047 1
  char asnibbles[100];
a1048 1
  int high, low;
d1050 1
a1050 1
  if (!Hmode && this_try->opcode->available != AV_H8)
a1052 11
  else if (!Smode 
	   && this_try->opcode->available != AV_H8 
	   && this_try->opcode->available != AV_H8H)
    as_warn (_("Opcode `%s' with these operand types not available in H8/300H mode"),
	     this_try->opcode->name);
  else if (!SXmode 
	   && this_try->opcode->available != AV_H8
	   && this_try->opcode->available != AV_H8H
	   && this_try->opcode->available != AV_H8S)
    as_warn (_("Opcode `%s' with these operand types not available in H8/300S mode"),
	     this_try->opcode->name);
d1054 1
a1054 1
  while (*nibble_ptr != (op_type) E)
a1056 2

      nib = 0;
d1059 1
a1059 1
      d = (c & OP3) == OP3 ? 2 : (c & DST) == DST ? 1 : 0;
d1065 1
a1065 12
	  int c2 = c & MODE;

	  if (c2 == REG || c2 == LOWREG
	      || c2 == IND || c2 == PREINC || c2 == PREDEC
	      || c2 == POSTINC || c2 == POSTDEC)
	    {
	      nib = operand[d].reg;
	      if (c2 == LOWREG)
		nib &= 7;
	    }

	  else if (c & CTRL)	/* Control reg operand.  */
d1069 3
a1071 4
	    {
	      nib = operand[d].reg;
	    }
	  else if (c2 == ABS)
d1074 1
a1074 1
	      op_at[d] = nibble_count;
d1077 1
a1077 2
	  else if (c2 == IMM || c2 == PCREL || c2 == ABS
		   || (c & ABSJMP) || c2 == DISP)
d1080 1
a1080 1
	      op_at[d] = nibble_count;
d1083 1
a1083 1
	  else if ((c & IGNORE) || (c & DATA))
d1086 1
a1086 1
	  else if (c2 == DBIT)
d1100 1
a1100 1
	  else if (c2 == KBIT)
d1130 1
a1130 10
	  if (c & B21)
	    nib |= 0x4;

	  if (c & B11)
	    nib |= 0x2;

	  if (c & B01)
	    nib |= 0x1;

	  if (c2 == MACREG)
d1147 2
a1148 1
  if (OP_KIND (this_try->opcode->how) == O_LDM)
d1150 4
a1153 2
      high = (operand[1].reg >> 8) & 0xf;
      low  = (operand[1].reg) & 0xf;
d1155 1
a1155 8
      asnibbles[7] = high;
    }
  else if (OP_KIND (this_try->opcode->how) == O_STM)
    {
      high = (operand[0].reg >> 8) & 0xf;
      low  = (operand[0].reg) & 0xf;
      asnibbles[2] = high - low;
      asnibbles[7] = low;
d1161 3
a1163 17
  /* Note if this is a movb or a bit manipulation instruction
     there is a special relaxation which only applies.  */
  if (   this_try->opcode->how == O (O_MOV,   SB)
      || this_try->opcode->how == O (O_BCLR,  SB)
      || this_try->opcode->how == O (O_BAND,  SB)
      || this_try->opcode->how == O (O_BIAND, SB)
      || this_try->opcode->how == O (O_BILD,  SB)
      || this_try->opcode->how == O (O_BIOR,  SB)
      || this_try->opcode->how == O (O_BIST,  SB)
      || this_try->opcode->how == O (O_BIXOR, SB)
      || this_try->opcode->how == O (O_BLD,   SB)
      || this_try->opcode->how == O (O_BNOT,  SB)
      || this_try->opcode->how == O (O_BOR,   SB)
      || this_try->opcode->how == O (O_BSET,  SB)
      || this_try->opcode->how == O (O_BST,   SB)
      || this_try->opcode->how == O (O_BTST,  SB)
      || this_try->opcode->how == O (O_BXOR,  SB))
d1167 1
a1167 1
  for (i = 0; i < this_try->noperands; i++)
a1169 5
      int x_mode = x & MODE;

      if (x_mode == IMM || x_mode == DISP)
	do_a_fix_imm (output - frag_now->fr_literal + op_at[i] / 2,
		      op_at[i] & 1, operand + i, (x & MEMRELAX) != 0);
d1171 7
a1177 4
      else if (x_mode == ABS)
	do_a_fix_imm (output - frag_now->fr_literal + op_at[i] / 2,
		      op_at[i] & 1, operand + i,
		      (x & MEMRELAX) ? movb + 1 : 0);
d1179 1
a1179 1
      else if (x_mode == PCREL)
d1181 2
a1182 1
	  int size16 = (x & SIZE) == L_16;
d1200 2
a1201 14
	  if (size16)
	    {
	      operand[i].exp.X_add_number =
		((operand[i].exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
	    }
	  else
	    {
	      operand[i].exp.X_add_number =
		((operand[i].exp.X_add_number & 0xff) ^ 0x80) - 0x80;
	    }

	  /* For BRA/S.  */
	  if (! size16)
	    operand[i].exp.X_add_number |= output[op_at[i] / 2];
d1204 1
a1204 1
			      output - frag_now->fr_literal + op_at[i] / 2,
d1211 1
a1211 1
      else if (x_mode == MEMIND)
a1220 13
      else if (x_mode == VECIND)
	{
	  check_operand (operand + i, 0x7f, "@@@@");
	  /* FIXME: approximating the effect of "B31" here...
	     This is very hackish, and ought to be done a better way.  */
	  operand[i].exp.X_add_number |= 0x80;
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + 1,
		       1,
		       &operand[i].exp,
		       0,
		       R_MEM_INDIRECT);
	}
a1223 1
	  bfd_reloc_code_real_type reloc_type = R_JMPL1;
d1229 1
a1229 8
	  
	  if ((operand->mode & SIZE) == L_32)
	    {
	      where = 2;
	      reloc_type = R_RELLONG;
	    }
	  else
	    where = 1;
d1234 1
a1234 3
	  check_operand (operand + i, 
			 SXmode ? 0xffffffff : Hmode ? 0xffffff : 0xffff, 
			 "@@");
d1248 1
a1248 1
		       reloc_type);
d1257 3
a1259 2
clever_message (const struct h8_instruction *instruction,
		struct h8_op *operand)
a1318 67

/* If OPERAND is part of an address, adjust its size and value given
   that it addresses SIZE bytes.

   This function decides how big non-immediate constants are when no
   size was explicitly given.  It also scales down the assembly-level
   displacement in an @@(d:2,ERn) operand.  */

static void
fix_operand_size (struct h8_op *operand, int size)
{
  if (SXmode && (operand->mode & MODE) == DISP)
    {
      /* If the user didn't specify an operand width, see if we
	 can use @@(d:2,ERn).  */
      if ((operand->mode & SIZE) == 0
	  && operand->exp.X_add_symbol == 0
	  && operand->exp.X_op_symbol == 0
	  && (operand->exp.X_add_number == size
	      || operand->exp.X_add_number == size * 2
	      || operand->exp.X_add_number == size * 3))
	operand->mode |= L_2;

      /* Scale down the displacement in an @@(d:2,ERn) operand.
	 X_add_number then contains the desired field value.  */
      if ((operand->mode & SIZE) == L_2)
	{
	  if (operand->exp.X_add_number % size != 0)
	    as_warn (_("operand/size mis-match"));
	  operand->exp.X_add_number /= size;
	}
    }

  if ((operand->mode & SIZE) == 0)
    switch (operand->mode & MODE)
      {
      case DISP:
      case INDEXB:
      case INDEXW:
      case INDEXL:
      case ABS:
	/* Pick a 24-bit address unless we know that a 16-bit address
	   is safe.  get_specific() will relax L_24 into L_32 where
	   necessary.  */
	if (Hmode
	    && !Nmode 
	    && (operand->exp.X_add_number < -32768
		|| operand->exp.X_add_number > 32767
		|| operand->exp.X_add_symbol != 0
		|| operand->exp.X_op_symbol != 0))
	  operand->mode |= L_24;
	else
	  operand->mode |= L_16;
	break;

      case PCREL:
	/* This condition is long standing, though somewhat suspect.  */
	if (operand->exp.X_add_number > -128
	    && operand->exp.X_add_number < 127)
	  operand->mode |= L_8;
	else
	  operand->mode |= L_16;
	break;
      }
}


d1324 2
a1325 1
md_assemble (char *str)
d1329 1
a1329 1
  struct h8_op operand[3];
a1333 1
  char *slash = 0;
d1335 1
a1335 1
  int size, i;
a1352 2
      else if (*op_end == '/' && ! slash)
	slash = op_end;
a1362 6
  /* The assembler stops scanning the opcode at slashes, so it fails
     to make characters following them lower case.  Fix them.  */
  if (slash)
    while (*++slash)
      *slash = TOLOWER (*slash);

d1375 1
a1375 14
  operand[0].mode = 0;
  operand[1].mode = 0;
  operand[2].mode = 0;

  if (OP_KIND (instruction->opcode->how) == O_MOVAB
      || OP_KIND (instruction->opcode->how) == O_MOVAW
      || OP_KIND (instruction->opcode->how) == O_MOVAL)
    get_mova_operands (op_end, operand);
  else if (OP_KIND (instruction->opcode->how) == O_RTEL
	   || OP_KIND (instruction->opcode->how) == O_RTSL)
    get_rtsl_operands (op_end, operand);
  else
    get_operands (instruction->noperands, op_end, operand);

a1378 21
  /* Now we have operands from instruction.
     Let's check them out for ldm and stm.  */
  if (OP_KIND (instruction->opcode->how) == O_LDM)
    {
      /* The first operand must be @@er7+, and the
	 second operand must be a register pair.  */
      if ((operand[0].mode != RSINC)
           || (operand[0].reg != 7)
           || ((operand[1].reg & 0x80000000) == 0))
	as_bad (_("invalid operand in ldm"));
    }
  else if (OP_KIND (instruction->opcode->how) == O_STM)
    {
      /* The first operand must be a register pair,
	 and the second operand must be @@-er7.  */
      if (((operand[0].reg & 0x80000000) == 0)
            || (operand[1].mode != RDDEC)
            || (operand[1].reg != 7))
	as_bad (_("invalid operand in stm"));
    }

d1382 1
a1382 1
      switch (TOLOWER (*dot))
a1396 37
  if (OP_KIND (instruction->opcode->how) == O_MOVAB ||
      OP_KIND (instruction->opcode->how) == O_MOVAW ||
      OP_KIND (instruction->opcode->how) == O_MOVAL)
    {
      switch (operand[0].mode & MODE)
	{
	case INDEXB:
	default:
	  fix_operand_size (&operand[1], 1);
	  break;
	case INDEXW:
	  fix_operand_size (&operand[1], 2);
	  break;
	case INDEXL:
	  fix_operand_size (&operand[1], 4);
	  break;
	}
    }
  else
    {
      for (i = 0; i < 3 && operand[i].mode != 0; i++)
	switch (size)
	  {
	  case SN:
	  case SB:
	  default:
	    fix_operand_size (&operand[i], 1);
	    break;
	  case SW:
	    fix_operand_size (&operand[i], 2);
	    break;
	  case SL:
	    fix_operand_size (&operand[i], 4);
	    break;
	  }
    }

d1410 7
d1427 2
a1428 1
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
d1435 2
a1436 1
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
d1443 2
a1444 1
tc_headers_hook (object_headers *headers ATTRIBUTE_UNUSED)
d1460 4
a1463 1
md_atof (int type, char *litP, int *sizeP)
d1521 3
a1523 1
md_parse_option (int c ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED)
d1529 2
a1530 1
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
d1534 1
a1534 1
void tc_aout_fix_to_chars (void);
d1537 1
a1537 1
tc_aout_fix_to_chars (void)
d1544 1
a1544 1
md_convert_frag (
d1546 1
a1546 1
		 bfd *headers ATTRIBUTE_UNUSED,
d1548 1
a1548 1
		 object_headers *headers ATTRIBUTE_UNUSED,
d1550 2
a1551 2
		 segT seg ATTRIBUTE_UNUSED,
		 fragS *fragP ATTRIBUTE_UNUSED)
d1559 3
a1561 1
md_section_align (segT segment, valueT size)
d1568 3
a1570 1
md_section_align (segT seg, valueT size)
d1579 4
a1582 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
d1611 3
a1613 2
md_estimate_size_before_relax (register fragS *fragP ATTRIBUTE_UNUSED,
			       register segT segment_type ATTRIBUTE_UNUSED)
d1621 4
a1624 1
md_number_to_chars (char *ptr, valueT use, int nbytes)
d1630 2
a1631 1
md_pcrel_from (fixS *fixP ATTRIBUTE_UNUSED)
d1638 5
a1642 1
tc_reloc_mangle (fixS *fix_ptr, struct internal_reloc *intr, bfd_vma base)
d1701 3
a1703 1
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d1 3
a3 3
/* tc-h8300.c -- Assemble code for the Renesas H8/300
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001, 2002, 2003 Free Software Foundation, Inc.
a27 5

#ifdef BFD_ASSEMBLER
#include "dwarf2dbg.h"
#endif

d31 1
a31 5
#include "safe-ctype.h"

#ifdef OBJ_ELF
#include "elf/h8.h"
#endif
d37 8
a44 7
void cons        PARAMS ((int));
void sbranch     PARAMS ((int));
void h8300hmode  PARAMS ((int));
void h8300smode  PARAMS ((int));
void h8300hnmode PARAMS ((int));
void h8300snmode PARAMS ((int));
static void pint PARAMS ((int));
a47 2
int Nmode;

d51 1
a51 13

int bsize = L_8;		/* Default branch displacement.  */

struct h8_instruction
{
  int length;
  int noperands;
  int idx;
  int size;
  const struct h8_opcode *opcode;
};

struct h8_instruction *h8_instructions;
d54 1
a54 2
h8300hmode (arg)
     int arg ATTRIBUTE_UNUSED;
a57 4
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300h))
    as_warn (_("could not set architecture and machine"));
#endif
d61 1
a61 2
h8300smode (arg)
     int arg ATTRIBUTE_UNUSED;
a64 30
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300s))
    as_warn (_("could not set architecture and machine"));
#endif
}

void
h8300hnmode (arg)
     int arg ATTRIBUTE_UNUSED;
{
  Hmode = 1;
  Smode = 0;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300hn))
    as_warn (_("could not set architecture and machine"));
#endif
}

void
h8300snmode (arg)
     int arg ATTRIBUTE_UNUSED;
{
  Smode = 1;
  Hmode = 1;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sn))
    as_warn (_("could not set architecture and machine"));
#endif
d75 1
a75 2
pint (arg)
     int arg ATTRIBUTE_UNUSED;
a79 6
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */

a82 1
  {"h8300hn", h8300hnmode, 0},
a83 1
  {"h8300sn", h8300snmode, 0},
a86 5
#ifdef BFD_ASSEMBLER
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  {"loc", dwarf2_directive_loc, 0 },
#endif

d103 3
a105 3
/* Chars that mean this number is a floating point constant
   As in 0f12.456
   or    0d1.2345e12.  */
d108 1
a108 1
static struct hash_control *opcode_hash_control;	/* Opcode mnemonics.  */
a112 1

d116 1
a116 3
  unsigned int nopcodes;
  const struct h8_opcode *p;
  struct h8_instruction *pi;
a119 5
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300))
    as_warn (_("could not set architecture and machine"));
#endif

d123 1
a123 6
  nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);
  
  h8_instructions = (struct h8_instruction *)
    xmalloc (nopcodes * sizeof (struct h8_instruction));

  for (p = h8_opcodes, pi = h8_instructions; p->name; p++, pi++)
d127 1
a127 1
      char *src = p->name;
d132 1
a132 1
      pi->size = 0;
d138 1
a138 1
	      pi->size = *src;
d146 1
a146 1
	  hash_insert (opcode_hash_control, buffer, (char *) pi);
d150 1
a150 1
      pi->idx = idx;
d153 3
a155 3
      pi->noperands = 0;
      while (p->args.nib[pi->noperands] != E)
	pi->noperands++;
d158 3
a160 5
      pi->length = 0;
      while (p->data.nib[pi->length * 2] != E)
	pi->length++;

      pi->opcode = p;
a162 7
  /* Add entry for the NULL vector terminator.  */
  pi->length = 0;
  pi->noperands = 0;
  pi->idx = 0;
  pi->size = 0;
  pi->opcode = p;

d174 1
a174 1
int opsize;			/* Set when a register size is seen.  */
a182 12
static void clever_message PARAMS ((const struct h8_instruction *, struct h8_op *));
static void build_bytes    PARAMS ((const struct h8_instruction *, struct h8_op *));
static void do_a_fix_imm   PARAMS ((int, struct h8_op *, int));
static void check_operand  PARAMS ((struct h8_op *, unsigned int, char *));
static const struct h8_instruction * get_specific PARAMS ((const struct h8_instruction *, struct h8_op *, int));
static char * get_operands PARAMS ((unsigned, char *, struct h8_op *));
static void   get_operand  PARAMS ((char **, struct h8_op *, unsigned, int));
static char * skip_colonthing PARAMS ((char *, expressionS *, int *));
static char * parse_exp PARAMS ((char *, expressionS *));
static int    parse_reg PARAMS ((char *, op_type *, unsigned *, int));
char * colonmod24 PARAMS ((struct h8_op *, char *));

d202 1
d315 1
a315 1
	  /* ff fill any 8 bit quantity.  */
d333 1
a333 1
	  while (ISDIGIT (*ptr))
d353 3
a355 1
   @@@@aa[:8]		memory indirect.  */
d361 1
a382 1

d385 1
a401 4
  /* Check for '(' and ')' for instructions ldm and stm.  */
  if (src[0] == '(' && src[8] == ')')
    ++ src;

d404 2
a405 2
  if (src[0] == 'e' && src[1] == 'r' && ISDIGIT (src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && ISDIGIT (src[6]))
d431 1
a431 4
      if (src[7] == ')')
	*ptr = src + 8;
      else
	*ptr = src + 7;
d599 3
a601 1
	    as_bad (_("expect :8 or :16 here"));
d604 3
a606 2
	op->mode = PCREL | bsize;

d658 3
a660 4

static const struct h8_instruction *
get_specific (instruction, operands, size)
     const struct h8_instruction *instruction;
d664 1
a664 1
  const struct h8_instruction *this_try = instruction;
d666 2
a667 1
  int this_index = instruction->idx;
d671 2
a672 2
  if (strcmp (instruction->opcode->name, "stm.l") == 0
      || strcmp (instruction->opcode->name, "ldm.l") == 0)
d675 1
a675 1
  while (this_index == instruction->idx && !found)
d679 1
a679 1
      this_try = instruction++;
d684 1
a684 1
	  this_size = this_try->opcode->how & SN;
d690 1
a690 1
	  int i;
d694 1
a694 1
	      op_type op = this_try->opcode->args.nib[i];
d790 1
a790 1
	  (operand->exp.X_add_number | width) != (unsigned)(~0))
a798 8
	  else if (strcmp (string, "@@") == 0
		   && width == 0xffff
		   && (operand->exp.X_add_number & 0xff8000) == 0xff8000)
	    {
	      /* Just ignore this one - which happens when trying to
		 fit a 24 bit address truncated into a 16 bit address
		 of something like mov.w.  */
	    }
a917 1

d920 1
a920 1
     const struct h8_instruction *this_try;
d923 2
a924 1
  int i;
d926 1
a926 1
  op_type *nibble_ptr = this_try->opcode->data.nib;
d929 3
a931 3
  int absat = 0;
  int immat = 0;
  int nib = 0;
d936 1
a936 1
  if (!(this_try->opcode->inbase || Hmode))
d938 1
a938 1
	     this_try->opcode->name);
d948 3
a950 1
	nib = c;
d954 3
a956 2
	    nib = operand[d].reg;

d958 3
a960 2
	    nib = dispreg;

d974 3
a976 2
	    nib = 0;

d1016 3
a1018 1
	    operand[d].mode |= MEMRELAX;
d1021 3
a1023 1
	    nib |= 0x8;
d1042 2
a1043 2
  if (strcmp (this_try->opcode->name, "stm.l") == 0
      || strcmp (this_try->opcode->name, "ldm.l") == 0)
d1046 2
a1047 2
      high = (operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg >> 8) & 0xf;
      low = operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg & 0xf;
d1050 1
a1050 1
      asnibbles[7] = (this_try->opcode->name[0] == 'l') ? high : low;
d1054 3
a1056 1
    output[i] = (asnibbles[i * 2] << 4) | asnibbles[i * 2 + 1];
d1060 1
a1060 1
  if (strcmp (this_try->opcode->name, "mov.b") == 0)
d1069 4
a1072 3
	do_a_fix_imm (output - frag_now->fr_literal + immat,
		      operand + i, (x & MEMRELAX) != 0);

d1074 4
a1077 3
	do_a_fix_imm (output - frag_now->fr_literal + absat,
		      operand + i, (x & MEMRELAX) ? movb + 1 : 0);

d1080 1
a1080 1
	  int size16 = x & (L_16);
a1083 1
	  fixS *fixP;
d1088 4
a1091 5
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);
#ifndef OBJ_ELF
	  /* The COFF port has always been off by one, changing it
	     now would be an incompatible change, so we leave it as-is.
a1092 2
	     We don't want to do this for ELF as we want to be
	     compatible with the proposed ELF format from Hitachi.  */
a1093 1
#endif
d1097 6
a1102 7
	  fixP = fix_new_exp (frag_now,
			      output - frag_now->fr_literal + where,
			      size,
			      &operand[i].exp,
			      1,
			      type);
	  fixP->fx_signed = 1;
a1115 9
	  int where = 0;

#ifdef OBJ_ELF
	  /* To be compatible with the proposed H8 ELF format, we
	     want the relocation's offset to point to the first byte
	     that will be modified, not to the start of the instruction.  */
	  where += 1;
#endif

a1118 1

d1120 4
a1123 3
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);

d1128 1
a1128 1
		       output - frag_now->fr_literal + where,
a1138 1

d1140 2
a1141 2
clever_message (instruction, operand)
     const struct h8_instruction *instruction;
d1146 1
a1146 1
  if ((instruction + 1)->idx != instruction->idx)
d1148 1
a1148 1
      int argn;
d1152 1
a1152 1
      for (argn = 0; argn < instruction->noperands; argn++)
d1154 1
a1154 1
	  switch (instruction->opcode->args.nib[argn])
a1204 1

d1212 2
a1213 2
  const struct h8_instruction *instruction;
  const struct h8_instruction *prev_instruction;
d1245 2
a1246 2
  instruction = (const struct h8_instruction *)
    hash_find (opcode_hash_control, op_start);
d1248 1
a1248 1
  if (instruction == NULL)
d1257 1
a1257 1
  (void) get_operands (instruction->noperands, op_end, operand);
d1259 1
a1259 1
  prev_instruction = instruction;
d1279 1
a1279 1
  instruction = get_specific (instruction, operand, size);
d1281 1
a1281 1
  if (instruction == 0)
d1288 1
a1288 1
      clever_message (prev_instruction, operand);
d1292 1
a1292 1
  if (instruction->size && dot)
d1294 1
a1294 1
      if (instruction->size != *dot)
d1300 1
a1300 5
  build_bytes (instruction, operand);

#ifdef BFD_ASSEMBLER
  dwarf2_emit_insn (instruction->length);
#endif
a1302 1
#ifndef BFD_ASSEMBLER
a1308 1
#endif
a1316 1
#ifndef BFD_ASSEMBLER
a1322 1
#endif
d1343 1
d1388 1
a1388 1
const char *md_shortopts = "";
a1408 2
void tc_aout_fix_to_chars PARAMS ((void));

a1417 3
#ifdef BFD_ASSEMBLER
     bfd *headers ATTRIBUTE_UNUSED;
#else
a1418 1
#endif
a1425 10
#ifdef BFD_ASSEMBLER
valueT
md_section_align (segment, size)
     segT segment;
     valueT size;
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  return ((size + (1 << align) - 1) & (-1 << align));
}
#else
a1433 2
#endif

d1436 1
a1436 1
md_apply_fix3 (fixP, valP, seg)
d1438 1
a1438 2
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
a1440 1
  long val = *valP;
a1459 3

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
a1487 1
#ifndef BFD_ASSEMBLER
a1549 45
#else /* BFD_ASSEMBLER */
arelent *
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *rel;
  bfd_reloc_code_real_type r_type;

  if (fixp->fx_addsy && fixp->fx_subsy)
    {
      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
	  || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"Difference of symbols in different sections is not supported");
	  return NULL;
	}
    }

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
  rel->addend = fixp->fx_offset;

  r_type = fixp->fx_r_type;

#define DEBUG 0
#if DEBUG
  fprintf (stderr, "%s\n", bfd_get_reloc_code_name (r_type));
  fflush(stderr);
#endif
  rel->howto = bfd_reloc_type_lookup (stdoutput, r_type);
  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (r_type));
      return NULL;
    }

  return rel;
}
#endif
@

