head	1.2;
access;
symbols
	cvs-200501080000:1.1.2.2
	tg-mergetmp-mirosx-1:1.1.3.2
	tg-mergefixes-1-branch:1.1.3.2.0.8
	tg-mergefixes-1-base:1.1.3.2
	MIROS_X:1.1.3.2.0.6
	MIROS_X_BASE:1.1.3.2
	MIRBSD_XP_MIRPPC:1.1.3.2.0.4
	MIRBSD_XP_SPARC_BASE:1.1.3.2
	MIRBSD_XP_SPARC:1.1.3.2.0.2
	cvs-200409160000:1.1.2.1
	FSF:1.1.2
	testing_SYNC_D:1.1.3.2
	testing_SYNC_C:1.1.3.2
	testing_SYNC_B:1.1.3.1
	testing_SYNC_A:1.1.3.1
	tg:1.1.3;
locks; strict;
comment	@ * @;


1.2
date	2005.01.13.19.44.15;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.11.20.33.52;	author tg;	state Exp;
branches
	1.1.2.1
	1.1.3.1;
next	;

1.1.2.1
date	2004.09.16.21.26.39;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.01.08.22.51.59;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.08.11.20.33.52;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.08.12.20.08.08;	author tg;	state Stab;
branches;
next	;


desc
@@


1.2
log
@merge binutils update (quick)
@
text
@/* tc-xtensa.c -- Assemble Xtensa instructions.
   Copyright 2003, 2004 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,
   MA 02111-1307, USA.  */

#include <string.h>
#include <limits.h>
#include "as.h"
#include "sb.h"
#include "safe-ctype.h"
#include "tc-xtensa.h"
#include "frags.h"
#include "subsegs.h"
#include "xtensa-relax.h"
#include "xtensa-istack.h"
#include "dwarf2dbg.h"
#include "struc-symbol.h"
#include "xtensa-config.h"

#ifndef uint32
#define uint32 unsigned int
#endif
#ifndef int32
#define int32 signed int
#endif

/* Notes:

   Naming conventions (used somewhat inconsistently):
      The xtensa_ functions are exported
      The xg_ functions are internal

   We also have a couple of different extensibility mechanisms.
   1) The idiom replacement:
      This is used when a line is first parsed to
      replace an instruction pattern with another instruction
      It is currently limited to replacements of instructions
      with constant operands.
   2) The xtensa-relax.c mechanism that has stronger instruction
      replacement patterns.  When an instruction's immediate field
      does not fit the next instruction sequence is attempted.
      In addition, "narrow" opcodes are supported this way.  */


/* Define characters with special meanings to GAS.  */
const char comment_chars[] = "#";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = ";";
const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "rRsSfFdDxXpP";


/* Flags to indicate whether the hardware supports the density and
   absolute literals options.  */

bfd_boolean density_supported = XCHAL_HAVE_DENSITY;
bfd_boolean absolute_literals_supported = XSHAL_USE_ABSOLUTE_LITERALS;

/* Maximum width we would pad an unreachable frag to get alignment.  */
#define UNREACHABLE_MAX_WIDTH  8

static vliw_insn cur_vinsn;

size_t xtensa_fetch_width = XCHAL_INST_FETCH_WIDTH;

static enum debug_info_type xt_saved_debug_type = DEBUG_NONE;

/* Some functions are only valid in the front end.  This variable
   allows us to assert that we haven't crossed over into the 
   back end.  */
static bfd_boolean past_xtensa_end = FALSE;

/* Flags for properties of the last instruction in a segment.  */
#define FLAG_IS_A0_WRITER	0x1
#define FLAG_IS_BAD_LOOPEND	0x2


/* We define a special segment names ".literal" to place literals
   into.  The .fini and .init sections are special because they
   contain code that is moved together by the linker.  We give them
   their own special .fini.literal and .init.literal sections.  */

#define LITERAL_SECTION_NAME		xtensa_section_rename (".literal")
#define LIT4_SECTION_NAME		xtensa_section_rename (".lit4")
#define FINI_SECTION_NAME		xtensa_section_rename (".fini")
#define INIT_SECTION_NAME		xtensa_section_rename (".init")
#define FINI_LITERAL_SECTION_NAME	xtensa_section_rename (".fini.literal")
#define INIT_LITERAL_SECTION_NAME	xtensa_section_rename (".init.literal")


/* This type is used for the directive_stack to keep track of the
   state of the literal collection pools.  */

typedef struct lit_state_struct
{
  const char *lit_seg_name;
  const char *lit4_seg_name;
  const char *init_lit_seg_name;
  const char *fini_lit_seg_name;
  segT lit_seg;
  segT lit4_seg;
  segT init_lit_seg;
  segT fini_lit_seg;
} lit_state;

static lit_state default_lit_sections;


/* We keep lists of literal segments.  The seg_list type is the node
   for such a list.  The *_literal_head locals are the heads of the
   various lists.  All of these lists have a dummy node at the start.  */

typedef struct seg_list_struct
{
  struct seg_list_struct *next;
  segT seg;
} seg_list;

static seg_list literal_head_h;
static seg_list *literal_head = &literal_head_h;
static seg_list init_literal_head_h;
static seg_list *init_literal_head = &init_literal_head_h;
static seg_list fini_literal_head_h;
static seg_list *fini_literal_head = &fini_literal_head_h;


/* Lists of symbols.  We keep a list of symbols that label the current
   instruction, so that we can adjust the symbols when inserting alignment
   for various instructions.  We also keep a list of all the symbols on
   literals, so that we can fix up those symbols when the literals are
   later moved into the text sections.  */

typedef struct sym_list_struct
{
  struct sym_list_struct *next;
  symbolS *sym;
} sym_list;

static sym_list *insn_labels = NULL;
static sym_list *free_insn_labels = NULL;
static sym_list *saved_insn_labels = NULL;

static sym_list *literal_syms;


/* Flags to determine whether to prefer const16 or l32r
   if both options are available.  */
int prefer_const16 = 0;
int prefer_l32r = 0;

/* Global flag to indicate when we are emitting literals.  */
int generating_literals = 0;

/* The following PROPERTY table definitions are copied from
   <elf/xtensa.h> and must be kept in sync with the code there.  */

/* Flags in the property tables to specify whether blocks of memory
   are literals, instructions, data, or unreachable.  For
   instructions, blocks that begin loop targets and branch targets are
   designated.  Blocks that do not allow density, instruction
   reordering or transformation are also specified.  Finally, for
   branch targets, branch target alignment priority is included.
   Alignment of the next block is specified in the current block
   and the size of the current block does not include any fill required
   to align to the next block.  */

#define XTENSA_PROP_LITERAL		0x00000001
#define XTENSA_PROP_INSN		0x00000002
#define XTENSA_PROP_DATA		0x00000004
#define XTENSA_PROP_UNREACHABLE		0x00000008
/* Instruction only properties at beginning of code.  */
#define XTENSA_PROP_INSN_LOOP_TARGET	0x00000010
#define XTENSA_PROP_INSN_BRANCH_TARGET	0x00000020
/* Instruction only properties about code.  */
#define XTENSA_PROP_INSN_NO_DENSITY	0x00000040
#define XTENSA_PROP_INSN_NO_REORDER	0x00000080
#define XTENSA_PROP_INSN_NO_TRANSFORM	0x00000100

/*  Branch target alignment information.  This transmits information
    to the linker optimization about the priority of aligning a
    particular block for branch target alignment: None, low priority,
    high priority, or required.  These only need to be checked in
    instruction blocks marked as XTENSA_PROP_INSN_BRANCH_TARGET.
    Common usage is

    switch (GET_XTENSA_PROP_BT_ALIGN (flags))
    case XTENSA_PROP_BT_ALIGN_NONE:
    case XTENSA_PROP_BT_ALIGN_LOW:
    case XTENSA_PROP_BT_ALIGN_HIGH:
    case XTENSA_PROP_BT_ALIGN_REQUIRE:
*/
#define XTENSA_PROP_BT_ALIGN_MASK       0x00000600

/* No branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_NONE       0x0
/* Low priority branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_LOW        0x1
/* High priority branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_HIGH       0x2
/* Required branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_REQUIRE    0x3

#define GET_XTENSA_PROP_BT_ALIGN(flag) \
  (((unsigned) ((flag) & (XTENSA_PROP_BT_ALIGN_MASK))) >> 9)
#define SET_XTENSA_PROP_BT_ALIGN(flag, align) \
  (((flag) & (~XTENSA_PROP_BT_ALIGN_MASK)) | \
    (((align) << 9) & XTENSA_PROP_BT_ALIGN_MASK))


/* Alignment is specified in the block BEFORE the one that needs
   alignment.  Up to 5 bits.  Use GET_XTENSA_PROP_ALIGNMENT(flags) to
   get the required alignment specified as a power of 2.  Use
   SET_XTENSA_PROP_ALIGNMENT(flags, pow2) to set the required
   alignment.  Be careful of side effects since the SET will evaluate
   flags twice.  Also, note that the SIZE of a block in the property
   table does not include the alignment size, so the alignment fill
   must be calculated to determine if two blocks are contiguous.
   TEXT_ALIGN is not currently implemented but is a placeholder for a
   possible future implementation.  */

#define XTENSA_PROP_ALIGN		0x00000800

#define XTENSA_PROP_ALIGNMENT_MASK      0x0001f000

#define GET_XTENSA_PROP_ALIGNMENT(flag) \
  (((unsigned) ((flag) & (XTENSA_PROP_ALIGNMENT_MASK))) >> 12)
#define SET_XTENSA_PROP_ALIGNMENT(flag, align) \
  (((flag) & (~XTENSA_PROP_ALIGNMENT_MASK)) | \
    (((align) << 12) & XTENSA_PROP_ALIGNMENT_MASK))

#define XTENSA_PROP_INSN_ABSLIT 0x00020000


/* Structure for saving instruction and alignment per-fragment data
   that will be written to the object file.  This structure is
   equivalent to the actual data that will be written out to the file
   but is easier to use.   We provide a conversion to file flags
   in frag_flags_to_number.  */

typedef struct frag_flags_struct frag_flags;

struct frag_flags_struct
{
  /* is_literal should only be used after xtensa_move_literals.
     If you need to check if you are generating a literal fragment,
     then use the generating_literals global.  */

  unsigned is_literal : 1;
  unsigned is_insn : 1;
  unsigned is_data : 1;
  unsigned is_unreachable : 1;

  struct
  {
    unsigned is_loop_target : 1;
    unsigned is_branch_target : 1; /* Branch targets have a priority.  */
    unsigned bt_align_priority : 2;

    unsigned is_no_density : 1;
    /* no_longcalls flag does not need to be placed in the object file.  */
    /* is_specific_opcode implies no_transform.  */
    unsigned is_no_transform : 1;

    unsigned is_no_reorder : 1;

    /* Uses absolute literal addressing for l32r.  */
    unsigned is_abslit : 1;
  } insn;
  unsigned is_align : 1;
  unsigned alignment : 5;
};


/* Structure for saving information about a block of property data
   for frags that have the same flags.  */
struct xtensa_block_info_struct
{
  segT sec;
  bfd_vma offset;
  size_t size;
  frag_flags flags;
  struct xtensa_block_info_struct *next;
};


/* Structure for saving the current state before emitting literals.  */
typedef struct emit_state_struct
{
  const char *name;
  segT now_seg;
  subsegT now_subseg;
  int generating_literals;
} emit_state;


/* Opcode placement information */

typedef unsigned long long bitfield;
#define bit_is_set(bit, bf)	((bf) & (0x01ll << (bit)))
#define set_bit(bit, bf)	((bf) |= (0x01ll << (bit)))
#define clear_bit(bit, bf)	((bf) &= ~(0x01ll << (bit)))

#define MAX_FORMATS 32

typedef struct op_placement_info_struct
{
  int num_formats;
  /* A number describing how restrictive the issue is for this
     opcode.  For example, an opcode that fits lots of different
     formats has a high freedom, as does an opcode that fits 
     only one format but many slots in that format.  The most
     restrictive is the opcode that fits only one slot in one 
     format.  */
  int issuef;
  /* The single format (i.e., if the op can live in a bundle by itself),
     narrowest format, and widest format the op can be bundled in 
     and their sizes:  */
  xtensa_format single;
  xtensa_format narrowest;
  xtensa_format widest;
  char narrowest_size;
  char widest_size;
  char single_size;

  /* formats is a bitfield with the Nth bit set
     if the opcode fits in the Nth xtensa_format.  */
  bitfield formats;

  /* slots[N]'s Mth bit is set if the op fits in the
     Mth slot of the Nth xtensa_format.  */
  bitfield slots[MAX_FORMATS];

  /* A count of the number of slots in a given format
     an op can fit (i.e., the bitcount of the slot field above).  */
  char slots_in_format[MAX_FORMATS];

} op_placement_info, *op_placement_info_table;

op_placement_info_table op_placement_table;


/* Extra expression types.  */

#define O_pltrel	O_md1	/* like O_symbol but use a PLT reloc */
#define O_hi16		O_md2	/* use high 16 bits of symbolic value */
#define O_lo16		O_md3	/* use low 16 bits of symbolic value */


/* Directives.  */

typedef enum
{
  directive_none = 0,
  directive_literal,
  directive_density,
  directive_transform,
  directive_freeregs,
  directive_longcalls,
  directive_literal_prefix,
  directive_schedule,
  directive_absolute_literals,
  directive_last_directive
} directiveE;

typedef struct
{
  const char *name;
  bfd_boolean can_be_negated;
} directive_infoS;

const directive_infoS directive_info[] =
{
  { "none",		FALSE },
  { "literal",		FALSE },
  { "density",		TRUE },
  { "transform",	TRUE },
  { "freeregs",		FALSE },
  { "longcalls",	TRUE },
  { "literal_prefix",	FALSE },
  { "schedule",		TRUE },
  { "absolute-literals", TRUE }
};

bfd_boolean directive_state[] =
{
  FALSE,			/* none */
  FALSE,			/* literal */
#if !XCHAL_HAVE_DENSITY
  FALSE,			/* density */
#else
  TRUE,				/* density */
#endif
  TRUE,				/* transform */
  FALSE,			/* freeregs */
  FALSE,			/* longcalls */
  FALSE,			/* literal_prefix */
  TRUE,				/* schedule */
#if XSHAL_USE_ABSOLUTE_LITERALS
  TRUE				/* absolute_literals */
#else
  FALSE				/* absolute_literals */
#endif
};


/* Directive functions.  */

static void xtensa_begin_directive (int);
static void xtensa_end_directive (int);
static void xtensa_dwarf2_directive_loc (int);
static void xtensa_literal_prefix (char const *, int);
static void xtensa_literal_position (int);
static void xtensa_literal_pseudo (int);
static void xtensa_frequency_pseudo (int);
static void xtensa_elf_cons (int);

/* Parsing and Idiom Translation.  */

static bfd_reloc_code_real_type xtensa_elf_suffix (char **, expressionS *);

/* Various Other Internal Functions.  */

static void xtensa_mark_literal_pool_location (void);
static addressT get_expanded_loop_offset (xtensa_opcode);
static fragS *get_literal_pool_location (segT);
static void set_literal_pool_location (segT, fragS *);
static void xtensa_set_frag_assembly_state (fragS *);
static void finish_vinsn (vliw_insn *);
static bfd_boolean emit_single_op (TInsn *);
static int total_frag_text_expansion (fragS *);

/* Alignment Functions.  */

static size_t get_text_align_power (int);
static addressT get_text_align_max_fill_size (int, bfd_boolean, bfd_boolean);

/* Helpers for xtensa_relax_frag().  */

static long relax_frag_add_nop (fragS *);

/* Accessors for additional per-subsegment information.  */

static unsigned get_last_insn_flags (segT, subsegT);
static void set_last_insn_flags (segT, subsegT, unsigned, bfd_boolean);
static float get_subseg_total_freq (segT, subsegT);
static float get_subseg_target_freq (segT, subsegT);
static void set_subseg_freq (segT, subsegT, float, float);

/* Segment list functions.  */

static void xtensa_move_literals (void);
static void xtensa_reorder_segments (void);
static void xtensa_switch_to_literal_fragment (emit_state *);
static void xtensa_switch_to_non_abs_literal_fragment (emit_state *);
static void xtensa_switch_section_emit_state (emit_state *, segT, subsegT);
static void xtensa_restore_emit_state (emit_state *);
static void cache_literal_section
  (seg_list *, const char *, segT *, bfd_boolean);

/* Import from elf32-xtensa.c in BFD library.  */

extern char *xtensa_get_property_section_name (asection *, const char *);

/* op_placement_info functions.  */

static void init_op_placement_info_table (void);
extern bfd_boolean opcode_fits_format_slot (xtensa_opcode, xtensa_format, int);
static int xg_get_single_size (xtensa_opcode);
static xtensa_format xg_get_single_format (xtensa_opcode);

/* TInsn and IStack functions.  */

static bfd_boolean tinsn_has_symbolic_operands (const TInsn *);
static bfd_boolean tinsn_has_invalid_symbolic_operands (const TInsn *);
static bfd_boolean tinsn_has_complex_operands (const TInsn *);
static bfd_boolean tinsn_to_insnbuf (TInsn *, xtensa_insnbuf);
static bfd_boolean tinsn_check_arguments (const TInsn *);
static void tinsn_from_chars (TInsn *, char *, int);
static void tinsn_immed_from_frag (TInsn *, fragS *, int);
static int get_num_stack_text_bytes (IStack *);
static int get_num_stack_literal_bytes (IStack *);

/* vliw_insn functions.  */

static void xg_init_vinsn (vliw_insn *);
static void xg_clear_vinsn (vliw_insn *);
static bfd_boolean vinsn_has_specific_opcodes (vliw_insn *);
static void xg_free_vinsn (vliw_insn *);
static bfd_boolean vinsn_to_insnbuf
  (vliw_insn *, char *, fragS *, bfd_boolean);
static void vinsn_from_chars (vliw_insn *, char *);

/* Expression Utilities.  */

bfd_boolean expr_is_const (const expressionS *);
offsetT get_expr_const (const expressionS *);
void set_expr_const (expressionS *, offsetT);
bfd_boolean expr_is_register (const expressionS *);
offsetT get_expr_register (const expressionS *);
void set_expr_symbol_offset (expressionS *, symbolS *, offsetT);
static void set_expr_symbol_offset_diff
  (expressionS *, symbolS *, symbolS *, offsetT);
bfd_boolean expr_is_equal (expressionS *, expressionS *);
static void copy_expr (expressionS *, const expressionS *);

/* Section renaming.  */

static void build_section_rename (const char *);


/* ISA imported from bfd.  */
extern xtensa_isa xtensa_default_isa;

extern int target_big_endian;

static xtensa_opcode xtensa_addi_opcode;
static xtensa_opcode xtensa_addmi_opcode;
static xtensa_opcode xtensa_call0_opcode;
static xtensa_opcode xtensa_call4_opcode;
static xtensa_opcode xtensa_call8_opcode;
static xtensa_opcode xtensa_call12_opcode;
static xtensa_opcode xtensa_callx0_opcode;
static xtensa_opcode xtensa_callx4_opcode;
static xtensa_opcode xtensa_callx8_opcode;
static xtensa_opcode xtensa_callx12_opcode;
static xtensa_opcode xtensa_const16_opcode;
static xtensa_opcode xtensa_entry_opcode;
static xtensa_opcode xtensa_movi_opcode;
static xtensa_opcode xtensa_movi_n_opcode;
static xtensa_opcode xtensa_isync_opcode;
static xtensa_opcode xtensa_jx_opcode;
static xtensa_opcode xtensa_l32r_opcode;
static xtensa_opcode xtensa_loop_opcode;
static xtensa_opcode xtensa_loopnez_opcode;
static xtensa_opcode xtensa_loopgtz_opcode;
static xtensa_opcode xtensa_nop_opcode;
static xtensa_opcode xtensa_nop_n_opcode;
static xtensa_opcode xtensa_or_opcode;
static xtensa_opcode xtensa_ret_opcode;
static xtensa_opcode xtensa_ret_n_opcode;
static xtensa_opcode xtensa_retw_opcode;
static xtensa_opcode xtensa_retw_n_opcode;
static xtensa_opcode xtensa_rsr_lcount_opcode;
static xtensa_opcode xtensa_waiti_opcode;


/* Command-line Options.  */

bfd_boolean use_literal_section = TRUE;
static bfd_boolean align_targets = TRUE;
static bfd_boolean warn_unaligned_branch_targets = FALSE;
static bfd_boolean has_a0_b_retw = FALSE;
static bfd_boolean workaround_a0_b_retw = FALSE;
static bfd_boolean workaround_b_j_loop_end = FALSE;
static bfd_boolean workaround_short_loop = FALSE;
static bfd_boolean maybe_has_short_loop = FALSE;
static bfd_boolean workaround_close_loop_end = FALSE;
static bfd_boolean maybe_has_close_loop_end = FALSE;

/* When workaround_short_loops is TRUE, all loops with early exits must
   have at least 3 instructions.  workaround_all_short_loops is a modifier
   to the workaround_short_loop flag.  In addition to the
   workaround_short_loop actions, all straightline loopgtz and loopnez
   must have at least 3 instructions.  */

static bfd_boolean workaround_all_short_loops = FALSE;


static void
xtensa_setup_hw_workarounds (int earliest, int latest)
{
  if (earliest > latest)
    as_fatal (_("illegal range of target hardware versions"));

  /* Enable all workarounds for pre-T1050.0 hardware.  */
  if (earliest < 105000 || latest < 105000)
    {
      workaround_a0_b_retw |= TRUE;
      workaround_b_j_loop_end |= TRUE;
      workaround_short_loop |= TRUE;
      workaround_close_loop_end |= TRUE;
      workaround_all_short_loops |= TRUE;
    }
}


enum
{
  option_density = OPTION_MD_BASE,
  option_no_density,

  option_relax,
  option_no_relax,

  option_link_relax,
  option_no_link_relax,

  option_generics,
  option_no_generics,

  option_transform,
  option_no_transform,

  option_text_section_literals,
  option_no_text_section_literals,

  option_absolute_literals,
  option_no_absolute_literals,

  option_align_targets,
  option_no_align_targets,

  option_warn_unaligned_targets,

  option_longcalls,
  option_no_longcalls,

  option_workaround_a0_b_retw,
  option_no_workaround_a0_b_retw,

  option_workaround_b_j_loop_end,
  option_no_workaround_b_j_loop_end,

  option_workaround_short_loop,
  option_no_workaround_short_loop,

  option_workaround_all_short_loops,
  option_no_workaround_all_short_loops,

  option_workaround_close_loop_end,
  option_no_workaround_close_loop_end,

  option_no_workarounds,

  option_rename_section_name,

  option_prefer_l32r,
  option_prefer_const16,

  option_target_hardware
};

const char *md_shortopts = "";

struct option md_longopts[] =
{
  { "density", no_argument, NULL, option_density },
  { "no-density", no_argument, NULL, option_no_density },

  /* Both "relax" and "generics" are deprecated and treated as equivalent
     to the "transform" option.  */
  { "relax", no_argument, NULL, option_relax },
  { "no-relax", no_argument, NULL, option_no_relax },
  { "generics", no_argument, NULL, option_generics },
  { "no-generics", no_argument, NULL, option_no_generics },

  { "transform", no_argument, NULL, option_transform },
  { "no-transform", no_argument, NULL, option_no_transform },
  { "text-section-literals", no_argument, NULL, option_text_section_literals },
  { "no-text-section-literals", no_argument, NULL,
    option_no_text_section_literals },
  { "absolute-literals", no_argument, NULL, option_absolute_literals },
  { "no-absolute-literals", no_argument, NULL, option_no_absolute_literals },
  /* This option was changed from -align-target to -target-align
     because it conflicted with the "-al" option.  */
  { "target-align", no_argument, NULL, option_align_targets },
  { "no-target-align", no_argument, NULL, option_no_align_targets },
  { "warn-unaligned-targets", no_argument, NULL,
    option_warn_unaligned_targets },
  { "longcalls", no_argument, NULL, option_longcalls },
  { "no-longcalls", no_argument, NULL, option_no_longcalls },

  { "no-workaround-a0-b-retw", no_argument, NULL,
    option_no_workaround_a0_b_retw },
  { "workaround-a0-b-retw", no_argument, NULL, option_workaround_a0_b_retw },

  { "no-workaround-b-j-loop-end", no_argument, NULL,
    option_no_workaround_b_j_loop_end },
  { "workaround-b-j-loop-end", no_argument, NULL,
    option_workaround_b_j_loop_end },

  { "no-workaround-short-loops", no_argument, NULL,
    option_no_workaround_short_loop },
  { "workaround-short-loops", no_argument, NULL,
    option_workaround_short_loop },

  { "no-workaround-all-short-loops", no_argument, NULL,
    option_no_workaround_all_short_loops },
  { "workaround-all-short-loop", no_argument, NULL,
    option_workaround_all_short_loops },

  { "prefer-l32r", no_argument, NULL, option_prefer_l32r },
  { "prefer-const16", no_argument, NULL, option_prefer_const16 },

  { "no-workarounds", no_argument, NULL, option_no_workarounds },

  { "no-workaround-close-loop-end", no_argument, NULL,
    option_no_workaround_close_loop_end },
  { "workaround-close-loop-end", no_argument, NULL,
    option_workaround_close_loop_end },

  { "rename-section", required_argument, NULL, option_rename_section_name },

  { "link-relax", no_argument, NULL, option_link_relax },
  { "no-link-relax", no_argument, NULL, option_no_link_relax },

  { "target-hardware", required_argument, NULL, option_target_hardware },

  { NULL, no_argument, NULL, 0 }
};

size_t md_longopts_size = sizeof md_longopts;


int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case option_density:
      as_warn (_("--density option is ignored"));
      return 1;
    case option_no_density:
      as_warn (_("--no-density option is ignored"));
      return 1;
    case option_link_relax:
      linkrelax = 1;
      return 1;
    case option_no_link_relax:
      linkrelax = 0;
      return 1;
    case option_generics:
      as_warn (_("--generics is deprecated; use --transform instead"));
      return md_parse_option (option_transform, arg);
    case option_no_generics:
      as_warn (_("--no-generics is deprecated; use --no-transform instead"));
      return md_parse_option (option_no_transform, arg);
    case option_relax:
      as_warn (_("--relax is deprecated; use --transform instead"));
      return md_parse_option (option_transform, arg);
    case option_no_relax:
      as_warn (_("--no-relax is deprecated; use --no-transform instead"));
      return md_parse_option (option_no_transform, arg);
    case option_longcalls:
      directive_state[directive_longcalls] = TRUE;
      return 1;
    case option_no_longcalls:
      directive_state[directive_longcalls] = FALSE;
      return 1;
    case option_text_section_literals:
      use_literal_section = FALSE;
      return 1;
    case option_no_text_section_literals:
      use_literal_section = TRUE;
      return 1;
    case option_absolute_literals:
      if (!absolute_literals_supported)
	{
	  as_fatal (_("--absolute-literals option not supported in this Xtensa configuration"));
	  return 0;
	}
      directive_state[directive_absolute_literals] = TRUE;
      return 1;
    case option_no_absolute_literals:
      directive_state[directive_absolute_literals] = FALSE;
      return 1;

    case option_workaround_a0_b_retw:
      workaround_a0_b_retw = TRUE;
      return 1;
    case option_no_workaround_a0_b_retw:
      workaround_a0_b_retw = FALSE;
      return 1;
    case option_workaround_b_j_loop_end:
      workaround_b_j_loop_end = TRUE;
      return 1;
    case option_no_workaround_b_j_loop_end:
      workaround_b_j_loop_end = FALSE;
      return 1;

    case option_workaround_short_loop:
      workaround_short_loop = TRUE;
      return 1;
    case option_no_workaround_short_loop:
      workaround_short_loop = FALSE;
      return 1;

    case option_workaround_all_short_loops:
      workaround_all_short_loops = TRUE;
      return 1;
    case option_no_workaround_all_short_loops:
      workaround_all_short_loops = FALSE;
      return 1;

    case option_workaround_close_loop_end:
      workaround_close_loop_end = TRUE;
      return 1;
    case option_no_workaround_close_loop_end:
      workaround_close_loop_end = FALSE;
      return 1;

    case option_no_workarounds:
      workaround_a0_b_retw = FALSE;
      workaround_b_j_loop_end = FALSE;
      workaround_short_loop = FALSE;
      workaround_all_short_loops = FALSE;
      workaround_close_loop_end = FALSE;
      return 1;

    case option_align_targets:
      align_targets = TRUE;
      return 1;
    case option_no_align_targets:
      align_targets = FALSE;
      return 1;

    case option_warn_unaligned_targets:
      warn_unaligned_branch_targets = TRUE;
      return 1;

    case option_rename_section_name:
      build_section_rename (arg);
      return 1;

    case 'Q':
      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
         should be emitted or not.  FIXME: Not implemented.  */
      return 1;
      
    case option_prefer_l32r:
      if (prefer_const16)
	as_fatal (_("prefer-l32r conflicts with prefer-const16"));
      prefer_l32r = 1;
      return 1;

    case option_prefer_const16:
      if (prefer_l32r)
	as_fatal (_("prefer-const16 conflicts with prefer-l32r"));
      prefer_const16 = 1;
      return 1;

    case option_target_hardware: 
      {
	int earliest, latest = 0;
	if (*arg == 0 || *arg == '-')
	  as_fatal (_("invalid target hardware version"));

	earliest = strtol (arg, &arg, 0);

	if (*arg == 0)
	  latest = earliest;
	else if (*arg == '-')
	  {
	    if (*++arg == 0)
	      as_fatal (_("invalid target hardware version"));
	    latest = strtol (arg, &arg, 0);
	  }
	if (*arg != 0)
	  as_fatal (_("invalid target hardware version"));

	xtensa_setup_hw_workarounds (earliest, latest);
	return 1;
      }

    case option_transform:
      /* This option has no affect other than to use the defaults,
	 which are already set.  */
      return 1;

    case option_no_transform:
      /* This option turns off all transformations of any kind.
	 However, because we want to preserve the state of other
	 directives, we only change its own field.  Thus, before
	 you perform any transformation, always check if transform
	 is available.  If you use the functions we provide for this
	 purpose, you will be ok.  */
      directive_state[directive_transform] = FALSE;
      return 1;

    default:
      return 0;
    }
}


void
md_show_usage (FILE *stream)
{
  fputs ("\n\
Xtensa options:\n\
  --[no-]text-section-literals\n\
                          [Do not] put literals in the text section\n\
  --[no-]absolute-literals\n\
                          [Do not] default to use non-PC-relative literals\n\
  --[no-]target-align     [Do not] try to align branch targets\n\
  --[no-]longcalls        [Do not] emit 32-bit call sequences\n\
  --[no-]transform        [Do not] transform instructions\n\
  --rename-section old=new Rename section 'old' to 'new'\n", stream);
}


/* Functions related to the list of current label symbols.  */

static void
xtensa_add_insn_label (symbolS *sym)
{
  sym_list *l;

  if (!free_insn_labels)
    l = (sym_list *) xmalloc (sizeof (sym_list));
  else
    {
      l = free_insn_labels;
      free_insn_labels = l->next;
    }

  l->sym = sym;
  l->next = insn_labels;
  insn_labels = l;
}


static void
xtensa_clear_insn_labels (void)
{
  sym_list **pl;

  for (pl = &free_insn_labels; *pl != NULL; pl = &(*pl)->next)
    ;
  *pl = insn_labels;
  insn_labels = NULL;
}


/* The "loops_ok" argument is provided to allow ignoring labels that 
   define loop ends.  This fixes a bug where the NOPs to align a 
   loop opcode were included in a previous zero-cost loop:

   loop a0, loopend
     <loop1 body>
   loopend:

   loop a2, loopend2
     <loop2 body>

   would become:

   loop a0, loopend
     <loop1 body>
     nop.n <===== bad!
   loopend:

   loop a2, loopend2
     <loop2 body>

   This argument is used to prevent moving the NOP to before the
   loop-end label, which is what you want in this special case.  */

static void
xtensa_move_labels (fragS *new_frag, valueT new_offset, bfd_boolean loops_ok)
{
  sym_list *lit;

  for (lit = insn_labels; lit; lit = lit->next)
    {
      symbolS *lit_sym = lit->sym;
      if (loops_ok || ! symbol_get_tc (lit_sym)->is_loop_target)
	{
	  S_SET_VALUE (lit_sym, new_offset);
	  symbol_set_frag (lit_sym, new_frag);
	}
    }
}


/* Directive data and functions.  */

typedef struct state_stackS_struct
{
  directiveE directive;
  bfd_boolean negated;
  bfd_boolean old_state;
  const char *file;
  unsigned int line;
  const void *datum;
  struct state_stackS_struct *prev;
} state_stackS;

state_stackS *directive_state_stack;

const pseudo_typeS md_pseudo_table[] =
{
  { "align", s_align_bytes, 0 }, /* Defaulting is invalid (0).  */
  { "literal_position", xtensa_literal_position, 0 },
  { "frame", s_ignore, 0 },	/* Formerly used for STABS debugging.  */
  { "long", xtensa_elf_cons, 4 },
  { "word", xtensa_elf_cons, 4 },
  { "short", xtensa_elf_cons, 2 },
  { "begin", xtensa_begin_directive, 0 },
  { "end", xtensa_end_directive, 0 },
  { "loc", xtensa_dwarf2_directive_loc, 0 },
  { "literal", xtensa_literal_pseudo, 0 },
  { "frequency", xtensa_frequency_pseudo, 0 },
  { NULL, 0, 0 },
};


static bfd_boolean
use_transform (void)
{
  /* After md_end, you should be checking frag by frag, rather
     than state directives.  */
  assert (!past_xtensa_end);
  return directive_state[directive_transform];
}


static bfd_boolean
use_longcalls (void)
{
  /* After md_end, you should be checking frag by frag, rather
     than state directives.  */
  assert (!past_xtensa_end);
  return directive_state[directive_longcalls] && use_transform ();
}


static bfd_boolean
do_align_targets (void)
{
  /* After md_end, you should be checking frag by frag, rather
     than state directives.  */
  assert (!past_xtensa_end);
  return align_targets && use_transform ();
}


static void
directive_push (directiveE directive, bfd_boolean negated, const void *datum)
{
  char *file;
  unsigned int line;
  state_stackS *stack = (state_stackS *) xmalloc (sizeof (state_stackS));

  as_where (&file, &line);

  stack->directive = directive;
  stack->negated = negated;
  stack->old_state = directive_state[directive];
  stack->file = file;
  stack->line = line;
  stack->datum = datum;
  stack->prev = directive_state_stack;
  directive_state_stack = stack;

  directive_state[directive] = !negated;
}


static void
directive_pop (directiveE *directive,
	       bfd_boolean *negated,
	       const char **file,
	       unsigned int *line,
	       const void **datum)
{
  state_stackS *top = directive_state_stack;

  if (!directive_state_stack)
    {
      as_bad (_("unmatched end directive"));
      *directive = directive_none;
      return;
    }

  directive_state[directive_state_stack->directive] = top->old_state;
  *directive = top->directive;
  *negated = top->negated;
  *file = top->file;
  *line = top->line;
  *datum = top->datum;
  directive_state_stack = top->prev;
  free (top);
}


static void
directive_balance (void)
{
  while (directive_state_stack)
    {
      directiveE directive;
      bfd_boolean negated;
      const char *file;
      unsigned int line;
      const void *datum;

      directive_pop (&directive, &negated, &file, &line, &datum);
      as_warn_where ((char *) file, line,
		     _(".begin directive with no matching .end directive"));
    }
}


static bfd_boolean
inside_directive (directiveE dir)
{
  state_stackS *top = directive_state_stack;

  while (top && top->directive != dir)
    top = top->prev;

  return (top != NULL);
}


static void
get_directive (directiveE *directive, bfd_boolean *negated)
{
  int len;
  unsigned i;
  char *directive_string;

  if (strncmp (input_line_pointer, "no-", 3) != 0)
    *negated = FALSE;
  else
    {
      *negated = TRUE;
      input_line_pointer += 3;
    }

  len = strspn (input_line_pointer,
		"abcdefghijklmnopqrstuvwxyz_-/0123456789.");

  /* This code is a hack to make .begin [no-][generics|relax] exactly
     equivalent to .begin [no-]transform.  We should remove it when
     we stop accepting those options.  */
     
  if (strncmp (input_line_pointer, "generics", strlen ("generics")) == 0)
    {
      as_warn (_("[no-]generics is deprecated; use [no-]transform instead"));
      directive_string = "transform";
    }
  else if (strncmp (input_line_pointer, "relax", strlen ("relax")) == 0)
    {
      as_warn (_("[no-]relax is deprecated; use [no-]transform instead"));
      directive_string = "transform";
    }    
  else
    directive_string = input_line_pointer;

  for (i = 0; i < sizeof (directive_info) / sizeof (*directive_info); ++i)
    {
      if (strncmp (directive_string, directive_info[i].name, len) == 0)
	{
	  input_line_pointer += len;
	  *directive = (directiveE) i;
	  if (*negated && !directive_info[i].can_be_negated)
	    as_bad (_("directive %s cannot be negated"),
		    directive_info[i].name);
	  return;
	}
    }

  as_bad (_("unknown directive"));
  *directive = (directiveE) XTENSA_UNDEFINED;
}


static void
xtensa_begin_directive (int ignore ATTRIBUTE_UNUSED)
{
  directiveE directive;
  bfd_boolean negated;
  emit_state *state;
  int len;
  lit_state *ls;

  get_directive (&directive, &negated);
  if (directive == (directiveE) XTENSA_UNDEFINED)
    {
      discard_rest_of_line ();
      return;
    }

  if (cur_vinsn.inside_bundle)
    as_bad (_("directives are not valid inside bundles"));

  switch (directive)
    {
    case directive_literal:
      if (!inside_directive (directive_literal))
	{
	  /* Previous labels go with whatever follows this directive, not with
	     the literal, so save them now.  */
	  saved_insn_labels = insn_labels;
	  insn_labels = NULL;
	}
      as_warn (_(".begin literal is deprecated; use .literal instead"));
      state = (emit_state *) xmalloc (sizeof (emit_state));
      xtensa_switch_to_literal_fragment (state);
      directive_push (directive_literal, negated, state);
      break;

    case directive_literal_prefix:
      /* Have to flush pending output because a movi relaxed to an l32r 
	 might produce a literal.  */
      md_flush_pending_output ();
      /* Check to see if the current fragment is a literal
	 fragment.  If it is, then this operation is not allowed.  */
      if (generating_literals)
	{
	  as_bad (_("cannot set literal_prefix inside literal fragment"));
	  return;
	}

      /* Allocate the literal state for this section and push
	 onto the directive stack.  */
      ls = xmalloc (sizeof (lit_state));
      assert (ls);

      *ls = default_lit_sections;

      directive_push (directive_literal_prefix, negated, ls);

      /* Parse the new prefix from the input_line_pointer.  */
      SKIP_WHITESPACE ();
      len = strspn (input_line_pointer,
		    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		    "abcdefghijklmnopqrstuvwxyz_/0123456789.$");

      /* Process the new prefix.  */
      xtensa_literal_prefix (input_line_pointer, len);

      /* Skip the name in the input line.  */
      input_line_pointer += len;
      break;

    case directive_freeregs:
      /* This information is currently unused, but we'll accept the statement
         and just discard the rest of the line.  This won't check the syntax,
         but it will accept every correct freeregs directive.  */
      input_line_pointer += strcspn (input_line_pointer, "\n");
      directive_push (directive_freeregs, negated, 0);
      break;

    case directive_schedule:
      md_flush_pending_output ();
      frag_var (rs_fill, 0, 0, frag_now->fr_subtype,
		frag_now->fr_symbol, frag_now->fr_offset, NULL);
      directive_push (directive_schedule, negated, 0);
      xtensa_set_frag_assembly_state (frag_now);
      break;

    case directive_density:
      as_warn (_(".begin [no-]density is ignored"));
      break;

    case directive_absolute_literals:
      md_flush_pending_output ();
      if (!absolute_literals_supported && !negated)
	{
	  as_warn (_("Xtensa absolute literals option not supported; ignored"));
	  break;
	}
      xtensa_set_frag_assembly_state (frag_now);
      directive_push (directive, negated, 0);
      break;

    default:
      md_flush_pending_output ();
      xtensa_set_frag_assembly_state (frag_now);
      directive_push (directive, negated, 0);
      break;
    }

  demand_empty_rest_of_line ();
}


static void
xtensa_end_directive (int ignore ATTRIBUTE_UNUSED)
{
  directiveE begin_directive, end_directive;
  bfd_boolean begin_negated, end_negated;
  const char *file;
  unsigned int line;
  emit_state *state;
  emit_state **state_ptr;
  lit_state *s;

  if (cur_vinsn.inside_bundle)
    as_bad (_("directives are not valid inside bundles"));

  get_directive (&end_directive, &end_negated);

  md_flush_pending_output ();

  switch (end_directive)
    {
    case (directiveE) XTENSA_UNDEFINED:
      discard_rest_of_line ();
      return;

    case directive_density:
      as_warn (_(".end [no-]density is ignored"));
      demand_empty_rest_of_line ();
      break;

    case directive_absolute_literals:
      if (!absolute_literals_supported && !end_negated)
	{
	  as_warn (_("Xtensa absolute literals option not supported; ignored"));
	  demand_empty_rest_of_line ();
	  return;
	}
      break;

    default:
      break;
    }

  state_ptr = &state; /* use state_ptr to avoid type-punning warning */
  directive_pop (&begin_directive, &begin_negated, &file, &line,
		 (const void **) state_ptr);

  if (begin_directive != directive_none)
    {
      if (begin_directive != end_directive || begin_negated != end_negated)
	{
	  as_bad (_("does not match begin %s%s at %s:%d"),
		  begin_negated ? "no-" : "",
		  directive_info[begin_directive].name, file, line);
	}
      else
	{
	  switch (end_directive)
	    {
	    case directive_literal:
	      frag_var (rs_fill, 0, 0, 0, NULL, 0, NULL);
	      xtensa_restore_emit_state (state);
	      xtensa_set_frag_assembly_state (frag_now);
	      free (state);
	      if (!inside_directive (directive_literal))
		{
		  /* Restore the list of current labels.  */
		  xtensa_clear_insn_labels ();
		  insn_labels = saved_insn_labels;
		}
	      break;

	    case directive_literal_prefix:
	      /* Restore the default collection sections from saved state.  */
	      s = (lit_state *) state;
	      assert (s);

	      if (use_literal_section)
		default_lit_sections = *s;

	      /* free the state storage */
	      free (s);
	      break;

	    case directive_schedule:
	    case directive_freeregs:
	      break;

	    default:
	      xtensa_set_frag_assembly_state (frag_now);
	      break;
	    }
	}
    }

  demand_empty_rest_of_line ();
}


/* Wrap dwarf2 functions so that we correctly support the .loc directive.  */

static bfd_boolean xtensa_loc_directive_seen = FALSE;

static void
xtensa_dwarf2_directive_loc (int x)
{
  xtensa_loc_directive_seen = TRUE;
  dwarf2_directive_loc (x);
}


static void
xtensa_dwarf2_emit_insn (int size, struct dwarf2_line_info *loc)
{
  if (debug_type != DEBUG_DWARF2 && ! xtensa_loc_directive_seen)
    return;
  xtensa_loc_directive_seen = FALSE;
  dwarf2_gen_line_info (frag_now_fix () - size, loc);
}


/* Place an aligned literal fragment at the current location.  */

static void
xtensa_literal_position (int ignore ATTRIBUTE_UNUSED)
{
  md_flush_pending_output ();

  if (inside_directive (directive_literal))
    as_warn (_(".literal_position inside literal directive; ignoring"));
  xtensa_mark_literal_pool_location ();

  demand_empty_rest_of_line ();
  xtensa_clear_insn_labels ();
}


/* Support .literal label, expr, ...  */

static void
xtensa_literal_pseudo (int ignored ATTRIBUTE_UNUSED)
{
  emit_state state;
  char *p, *base_name;
  char c;
  segT dest_seg;

  if (inside_directive (directive_literal))
    {
      as_bad (_(".literal not allowed inside .begin literal region"));
      ignore_rest_of_line ();
      return;
    }

  md_flush_pending_output ();

  /* Previous labels go with whatever follows this directive, not with
     the literal, so save them now.  */
  saved_insn_labels = insn_labels;
  insn_labels = NULL;

  /* If we are using text-section literals, then this is the right value... */
  dest_seg = now_seg;

  base_name = input_line_pointer;

  xtensa_switch_to_literal_fragment (&state);

  /* ...but if we aren't using text-section-literals, then we
     need to put them in the section we just switched to.  */
  if (use_literal_section || directive_state[directive_absolute_literals])
    dest_seg = now_seg;

  /* All literals are aligned to four-byte boundaries.  */
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

  c = get_symbol_end ();
  /* Just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',' && *input_line_pointer != ':')
    {
      as_bad (_("expected comma or colon after symbol name; "
		"rest of line ignored"));
      ignore_rest_of_line ();
      xtensa_restore_emit_state (&state);
      return;
    }
  *p = 0;

  colon (base_name);

  *p = c;
  input_line_pointer++;		/* skip ',' or ':' */

  xtensa_elf_cons (4);

  xtensa_restore_emit_state (&state);

  /* Restore the list of current labels.  */
  xtensa_clear_insn_labels ();
  insn_labels = saved_insn_labels;
}


static void
xtensa_literal_prefix (char const *start, int len)
{
  char *name, *linkonce_suffix;
  char *newname, *newname4;
  size_t linkonce_len;

  /* Get a null-terminated copy of the name.  */
  name = xmalloc (len + 1);
  assert (name);

  strncpy (name, start, len);
  name[len] = 0;

  /* Allocate the sections (interesting note: the memory pointing to
     the name is actually used for the name by the new section). */

  newname = xmalloc (len + strlen (".literal") + 1);
  newname4 = xmalloc (len + strlen (".lit4") + 1);

  linkonce_len = sizeof (".gnu.linkonce.") - 1;
  if (strncmp (name, ".gnu.linkonce.", linkonce_len) == 0
      && (linkonce_suffix = strchr (name + linkonce_len, '.')) != 0)
    {
      strcpy (newname, ".gnu.linkonce.literal");
      strcpy (newname4, ".gnu.linkonce.lit4");

      strcat (newname, linkonce_suffix);
      strcat (newname4, linkonce_suffix);
    }
  else
    {
      int suffix_pos = len;

      /* If the section name ends with ".text", then replace that suffix
	 instead of appending an additional suffix.  */
      if (len >= 5 && strcmp (name + len - 5, ".text") == 0)
	suffix_pos -= 5;

      strcpy (newname, name);
      strcpy (newname4, name);

      strcpy (newname + suffix_pos, ".literal");
      strcpy (newname4 + suffix_pos, ".lit4");
    }

  /* Note that cache_literal_section does not create a segment if
     it already exists.  */
  default_lit_sections.lit_seg = NULL;
  default_lit_sections.lit4_seg = NULL;

  /* Canonicalizing section names allows renaming literal
     sections to occur correctly.  */
  default_lit_sections.lit_seg_name = tc_canonicalize_symbol_name (newname);
  default_lit_sections.lit4_seg_name = tc_canonicalize_symbol_name (newname4);

  free (name);
}


/* Support ".frequency branch_target_frequency fall_through_frequency".  */

static void
xtensa_frequency_pseudo (int ignored ATTRIBUTE_UNUSED)
{
  float fall_through_f, target_f;

  fall_through_f = (float) strtod (input_line_pointer, &input_line_pointer);
  if (fall_through_f < 0)
    {
      as_bad (_("fall through frequency must be greater than 0"));
      ignore_rest_of_line ();
      return;
    }

  target_f = (float) strtod (input_line_pointer, &input_line_pointer);
  if (target_f < 0)
    {
      as_bad (_("branch target frequency must be greater than 0"));
      ignore_rest_of_line ();
      return;
    }

  set_subseg_freq (now_seg, now_subseg, target_f + fall_through_f, target_f);

  demand_empty_rest_of_line ();
}


/* Like normal .long/.short/.word, except support @@plt, etc.
   Clobbers input_line_pointer, checks end-of-line.  */

static void
xtensa_elf_cons (int nbytes)
{
  expressionS exp;
  bfd_reloc_code_real_type reloc;

  md_flush_pending_output ();

  if (cur_vinsn.inside_bundle)
    as_bad (_("directives are not valid inside bundles"));

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      expression (&exp);
      if (exp.X_op == O_symbol
	  && *input_line_pointer == '@@'
	  && ((reloc = xtensa_elf_suffix (&input_line_pointer, &exp))
	      != BFD_RELOC_NONE))
	{
	  reloc_howto_type *reloc_howto =
	    bfd_reloc_type_lookup (stdoutput, reloc);

	  if (reloc == BFD_RELOC_UNUSED || !reloc_howto)
	    as_bad (_("unsupported relocation"));
	  else if ((reloc >= BFD_RELOC_XTENSA_SLOT0_OP
		    && reloc <= BFD_RELOC_XTENSA_SLOT14_OP)
		   || (reloc >= BFD_RELOC_XTENSA_SLOT0_ALT
		       && reloc <= BFD_RELOC_XTENSA_SLOT14_ALT))
	    as_bad (_("opcode-specific %s relocation used outside "
		      "an instruction"), reloc_howto->name);
	  else if (nbytes != (int) bfd_get_reloc_size (reloc_howto))
	    as_bad (_("%s relocations do not fit in %d bytes"),
		    reloc_howto->name, nbytes);
	  else
	    {
	      char *p = frag_more ((int) nbytes);
	      xtensa_set_frag_assembly_state (frag_now);
	      fix_new_exp (frag_now, p - frag_now->fr_literal,
			   nbytes, &exp, 0, reloc);
	    }
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */
  demand_empty_rest_of_line ();
}


/* Parsing and Idiom Translation.  */

/* Parse @@plt, etc. and return the desired relocation.  */
static bfd_reloc_code_real_type
xtensa_elf_suffix (char **str_p, expressionS *exp_p)
{
  struct map_bfd
  {
    char *string;
    int length;
    bfd_reloc_code_real_type reloc;
  };

  char ident[20];
  char *str = *str_p;
  char *str2;
  int ch;
  int len;
  struct map_bfd *ptr;

#define MAP(str,reloc) { str, sizeof (str) - 1, reloc }

  static struct map_bfd mapping[] =
  {
    MAP ("l",		BFD_RELOC_LO16),
    MAP ("h",		BFD_RELOC_HI16),
    MAP ("plt",		BFD_RELOC_XTENSA_PLT),
    { (char *) 0, 0,	BFD_RELOC_UNUSED }
  };

  if (*str++ != '@@')
    return BFD_RELOC_NONE;

  for (ch = *str, str2 = ident;
       (str2 < ident + sizeof (ident) - 1
	&& (ISALNUM (ch) || ch == '@@'));
       ch = *++str)
    {
      *str2++ = (ISLOWER (ch)) ? ch : TOLOWER (ch);
    }

  *str2 = '\0';
  len = str2 - ident;

  ch = ident[0];
  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
    if (ch == ptr->string[0]
	&& len == ptr->length
	&& memcmp (ident, ptr->string, ptr->length) == 0)
      {
	/* Now check for "identifier@@suffix+constant".  */
	if (*str == '-' || *str == '+')
	  {
	    char *orig_line = input_line_pointer;
	    expressionS new_exp;

	    input_line_pointer = str;
	    expression (&new_exp);
	    if (new_exp.X_op == O_constant)
	      {
		exp_p->X_add_number += new_exp.X_add_number;
		str = input_line_pointer;
	      }

	    if (&input_line_pointer != str_p)
	      input_line_pointer = orig_line;
	  }

	*str_p = str;
	return ptr->reloc;
      }

  return BFD_RELOC_UNUSED;
}


static const char *
expression_end (const char *name)
{
  while (1)
    {
      switch (*name)
	{
	case '}':
	case ';':
	case '\0':
	case ',':
	case ':':
	  return name;
	case ' ':
	case '\t':
	  ++name;
	  continue;
	default:
	  return 0;
	}
    }
}


#define ERROR_REG_NUM ((unsigned) -1)

static unsigned
tc_get_register (const char *prefix)
{
  unsigned reg;
  const char *next_expr;
  const char *old_line_pointer;

  SKIP_WHITESPACE ();
  old_line_pointer = input_line_pointer;

  if (*input_line_pointer == '$')
    ++input_line_pointer;

  /* Accept "sp" as a synonym for "a1".  */
  if (input_line_pointer[0] == 's' && input_line_pointer[1] == 'p'
      && expression_end (input_line_pointer + 2))
    {
      input_line_pointer += 2;
      return 1;  /* AR[1] */
    }

  while (*input_line_pointer++ == *prefix++)
    ;
  --input_line_pointer;
  --prefix;

  if (*prefix)
    {
      as_bad (_("bad register name: %s"), old_line_pointer);
      return ERROR_REG_NUM;
    }

  if (!ISDIGIT ((unsigned char) *input_line_pointer))
    {
      as_bad (_("bad register number: %s"), input_line_pointer);
      return ERROR_REG_NUM;
    }

  reg = 0;

  while (ISDIGIT ((int) *input_line_pointer))
    reg = reg * 10 + *input_line_pointer++ - '0';

  if (!(next_expr = expression_end (input_line_pointer)))
    {
      as_bad (_("bad register name: %s"), old_line_pointer);
      return ERROR_REG_NUM;
    }

  input_line_pointer = (char *) next_expr;

  return reg;
}


static void
expression_maybe_register (xtensa_opcode opc, int opnd, expressionS *tok)
{
  xtensa_isa isa = xtensa_default_isa;

  /* Check if this is an immediate operand.  */
  if (xtensa_operand_is_register (isa, opc, opnd) == 0)
    {
      bfd_reloc_code_real_type reloc;
      segT t = expression (tok);
      if (t == absolute_section
	  && xtensa_operand_is_PCrelative (isa, opc, opnd) == 1)
	{
	  assert (tok->X_op == O_constant);
	  tok->X_op = O_symbol;
	  tok->X_add_symbol = &abs_symbol;
	}

      if ((tok->X_op == O_constant || tok->X_op == O_symbol)
	  && (reloc = xtensa_elf_suffix (&input_line_pointer, tok))
	  && (reloc != BFD_RELOC_NONE))
	{
	  switch (reloc)
	    {
	      default:
	      case BFD_RELOC_UNUSED:
		as_bad (_("unsupported relocation"));
	        break;

	      case BFD_RELOC_XTENSA_PLT:
		tok->X_op = O_pltrel;
		break;

	      case BFD_RELOC_LO16:
		if (tok->X_op == O_constant)
		  tok->X_add_number &= 0xffff;
		else
		  tok->X_op = O_lo16;
		break;

	      case BFD_RELOC_HI16:
		if (tok->X_op == O_constant)
		  tok->X_add_number = ((unsigned) tok->X_add_number) >> 16;
		else
		  tok->X_op = O_hi16;
		break;
	    }
	}
    }
  else
    {
      xtensa_regfile opnd_rf = xtensa_operand_regfile (isa, opc, opnd);
      unsigned reg = tc_get_register (xtensa_regfile_shortname (isa, opnd_rf));

      if (reg != ERROR_REG_NUM)	/* Already errored */
	{
	  uint32 buf = reg;
	  if (xtensa_operand_encode (isa, opc, opnd, &buf))
	    as_bad (_("register number out of range"));
	}

      tok->X_op = O_register;
      tok->X_add_symbol = 0;
      tok->X_add_number = reg;
    }
}


/* Split up the arguments for an opcode or pseudo-op.  */

static int
tokenize_arguments (char **args, char *str)
{
  char *old_input_line_pointer;
  bfd_boolean saw_comma = FALSE;
  bfd_boolean saw_arg = FALSE;
  bfd_boolean saw_colon = FALSE;
  int num_args = 0;
  char *arg_end, *arg;
  int arg_len;

  /* Save and restore input_line_pointer around this function.  */
  old_input_line_pointer = input_line_pointer;
  input_line_pointer = str;

  while (*input_line_pointer)
    {
      SKIP_WHITESPACE ();
      switch (*input_line_pointer)
	{
	case '\0':
	case '}':
	  goto fini;

	case ':':
	  input_line_pointer++;
	  if (saw_comma || saw_colon || !saw_arg)
	    goto err;
	  saw_colon = TRUE;
	  break;

	case ',':
	  input_line_pointer++;
	  if (saw_comma || saw_colon || !saw_arg)
	    goto err;
	  saw_comma = TRUE;
	  break;

	default:
	  if (!saw_comma && !saw_colon && saw_arg)
	    goto err;

	  arg_end = input_line_pointer + 1;
	  while (!expression_end (arg_end))
	    arg_end += 1;

	  arg_len = arg_end - input_line_pointer;
	  arg = (char *) xmalloc ((saw_colon ? 1 : 0) + arg_len + 1);
	  args[num_args] = arg;

	  if (saw_colon)
	    *arg++ = ':';
	  strncpy (arg, input_line_pointer, arg_len);
	  arg[arg_len] = '\0';

	  input_line_pointer = arg_end;
	  num_args += 1;
	  saw_comma = FALSE; 
	  saw_colon = FALSE;
	  saw_arg = TRUE; 
	  break;
	}
    }

fini:
  if (saw_comma || saw_colon)
    goto err;
  input_line_pointer = old_input_line_pointer;
  return num_args;

err:
  if (saw_comma)
    as_bad (_("extra comma"));
  else if (saw_colon)
    as_bad (_("extra colon"));
  else if (!saw_arg)
    as_bad (_("missing argument"));  
  else
    as_bad (_("missing comma or colon"));
  input_line_pointer = old_input_line_pointer;
  return -1;
}


/* Parse the arguments to an opcode.  Return TRUE on error.  */

static bfd_boolean
parse_arguments (TInsn *insn, int num_args, char **arg_strings)
{
  expressionS *tok, *last_tok;
  xtensa_opcode opcode = insn->opcode;
  bfd_boolean had_error = TRUE;
  xtensa_isa isa = xtensa_default_isa;
  int n, num_regs = 0;
  int opcode_operand_count;
  int opnd_cnt, last_opnd_cnt;
  unsigned int next_reg = 0;
  char *old_input_line_pointer;

  if (insn->insn_type == ITYPE_LITERAL)
    opcode_operand_count = 1;
  else
    opcode_operand_count = xtensa_opcode_num_operands (isa, opcode);

  tok = insn->tok;
  memset (tok, 0, sizeof (*tok) * MAX_INSN_ARGS);

  /* Save and restore input_line_pointer around this function.  */
  old_input_line_pointer = input_line_pointer;

  last_tok = 0;
  last_opnd_cnt = -1;
  opnd_cnt = 0;

  /* Skip invisible operands.  */
  while (xtensa_operand_is_visible (isa, opcode, opnd_cnt) == 0)
    {
      opnd_cnt += 1;
      tok++;
    }

  for (n = 0; n < num_args; n++)
    {
      input_line_pointer = arg_strings[n];
      if (*input_line_pointer == ':')
	{
	  xtensa_regfile opnd_rf;
	  input_line_pointer++;
	  if (num_regs == 0)
	    goto err;
	  assert (opnd_cnt > 0);
	  num_regs--;
	  opnd_rf = xtensa_operand_regfile (isa, opcode, last_opnd_cnt);
	  if (next_reg
	      != tc_get_register (xtensa_regfile_shortname (isa, opnd_rf)))
	    as_warn (_("incorrect register number, ignoring"));
	  next_reg++;
	}
      else
	{
	  if (opnd_cnt >= opcode_operand_count)
	    {
	      as_warn (_("too many arguments"));
	      goto err;
	    }
	  assert (opnd_cnt < MAX_INSN_ARGS);

	  expression_maybe_register (opcode, opnd_cnt, tok);
	  next_reg = tok->X_add_number + 1;

	  if (tok->X_op == O_illegal || tok->X_op == O_absent)
	    goto err;
	  if (xtensa_operand_is_register (isa, opcode, opnd_cnt) == 1)
	    {
	      num_regs = xtensa_operand_num_regs (isa, opcode, opnd_cnt) - 1;
	      /* minus 1 because we are seeing one right now */
	    }
	  else
	    num_regs = 0;

	  last_tok = tok;
	  last_opnd_cnt = opnd_cnt;

	  do
	    {
	      opnd_cnt += 1;
	      tok++;
	    }
	  while (xtensa_operand_is_visible (isa, opcode, opnd_cnt) == 0);
	}
    }

  if (num_regs > 0 && ((int) next_reg != last_tok->X_add_number + 1))
    goto err;

  insn->ntok = tok - insn->tok;
  had_error = FALSE; 

 err:
  input_line_pointer = old_input_line_pointer;
  return had_error;
}


static int
get_invisible_operands (TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_format fmt;
  xtensa_opcode opc = insn->opcode;
  int slot, opnd, fmt_found;
  unsigned val;

  if (!slotbuf)
    slotbuf = xtensa_insnbuf_alloc (isa);

  /* Find format/slot where this can be encoded.  */
  fmt_found = 0;
  slot = 0;
  for (fmt = 0; fmt < xtensa_isa_num_formats (isa); fmt++)
    {
      for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
	{
	  if (xtensa_opcode_encode (isa, fmt, slot, slotbuf, opc) == 0)
	    {
	      fmt_found = 1;
	      break;
	    }
	}
      if (fmt_found) break;
    }

  if (!fmt_found)
    {
      as_bad (_("cannot encode opcode \"%s\""), xtensa_opcode_name (isa, opc));
      return -1;
    }

  /* First encode all the visible operands
     (to deal with shared field operands).  */
  for (opnd = 0; opnd < insn->ntok; opnd++)
    {
      if (xtensa_operand_is_visible (isa, opc, opnd) == 1
	  && (insn->tok[opnd].X_op == O_register
	      || insn->tok[opnd].X_op == O_constant))
	{
	  val = insn->tok[opnd].X_add_number;
	  xtensa_operand_encode (isa, opc, opnd, &val);
	  xtensa_operand_set_field (isa, opc, opnd, fmt, slot, slotbuf, val);
	}
    }

  /* Then pull out the values for the invisible ones.  */
  for (opnd = 0; opnd < insn->ntok; opnd++)
    {
      if (xtensa_operand_is_visible (isa, opc, opnd) == 0)
	{
	  xtensa_operand_get_field (isa, opc, opnd, fmt, slot, slotbuf, &val);
	  xtensa_operand_decode (isa, opc, opnd, &val);
	  insn->tok[opnd].X_add_number = val;
	  if (xtensa_operand_is_register (isa, opc, opnd) == 1)
	    insn->tok[opnd].X_op = O_register;
	  else
	    insn->tok[opnd].X_op = O_constant;
	}
    }

  return 0;
}


static void
xg_reverse_shift_count (char **cnt_argp)
{
  char *cnt_arg, *new_arg;
  cnt_arg = *cnt_argp;

  /* replace the argument with "31-(argument)" */
  new_arg = (char *) xmalloc (strlen (cnt_arg) + 6);
  sprintf (new_arg, "31-(%s)", cnt_arg);

  free (cnt_arg);
  *cnt_argp = new_arg;
}


/* If "arg" is a constant expression, return non-zero with the value
   in *valp.  */

static int
xg_arg_is_constant (char *arg, offsetT *valp)
{
  expressionS exp;
  char *save_ptr = input_line_pointer;

  input_line_pointer = arg;
  expression (&exp);
  input_line_pointer = save_ptr;

  if (exp.X_op == O_constant)
    {
      *valp = exp.X_add_number;
      return 1;
    }

  return 0;
}


static void
xg_replace_opname (char **popname, char *newop)
{
  free (*popname);
  *popname = (char *) xmalloc (strlen (newop) + 1);
  strcpy (*popname, newop);
}


static int
xg_check_num_args (int *pnum_args,
		   int expected_num,
		   char *opname,
		   char **arg_strings)
{
  int num_args = *pnum_args;

  if (num_args < expected_num)
    {
      as_bad (_("not enough operands (%d) for '%s'; expected %d"),
	      num_args, opname, expected_num);
      return -1;
    }

  if (num_args > expected_num)
    {
      as_warn (_("too many operands (%d) for '%s'; expected %d"),
	       num_args, opname, expected_num);
      while (num_args-- > expected_num)
	{
	  free (arg_strings[num_args]);
	  arg_strings[num_args] = 0;
	}
      *pnum_args = expected_num;
      return -1;
    }

  return 0;
}


/* If the register is not specified as part of the opcode,
   then get it from the operand and move it to the opcode.  */

static int
xg_translate_sysreg_op (char **popname, int *pnum_args, char **arg_strings)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_sysreg sr;
  char *opname, *new_opname;
  const char *sr_name;
  int is_user, is_write;
  bfd_boolean has_underbar = FALSE;

  opname = *popname;
  if (*opname == '_')
    {
      has_underbar = TRUE;
      opname += 1;
    }
  is_user = (opname[1] == 'u');
  is_write = (opname[0] == 'w');

  /* Opname == [rw]ur or [rwx]sr... */

  if (xg_check_num_args (pnum_args, 2, opname, arg_strings))
    return -1;

  /* Check if the argument is a symbolic register name.  */
  sr = xtensa_sysreg_lookup_name (isa, arg_strings[1]);
  /* Handle WSR to "INTSET" as a special case.  */
  if (sr == XTENSA_UNDEFINED && is_write && !is_user
      && !strcasecmp (arg_strings[1], "intset"))
    sr = xtensa_sysreg_lookup_name (isa, "interrupt");
  if (sr == XTENSA_UNDEFINED
      || (xtensa_sysreg_is_user (isa, sr) == 1) != is_user)
    {
      /* Maybe it's a register number.... */
      offsetT val;
      if (!xg_arg_is_constant (arg_strings[1], &val))
	{
	  as_bad (_("invalid register '%s' for '%s' instruction"),
		  arg_strings[1], opname);
	  return -1;
	}
      sr = xtensa_sysreg_lookup (isa, val, is_user);
      if (sr == XTENSA_UNDEFINED)
	{
	  as_bad (_("invalid register number (%ld) for '%s' instruction"),
		  val, opname);
	  return -1;
	}
    }

  /* Remove the last argument, which is now part of the opcode.  */
  free (arg_strings[1]);
  arg_strings[1] = 0;
  *pnum_args = 1;

  /* Translate the opcode.  */
  sr_name = xtensa_sysreg_name (isa, sr);
  /* Another special case for "WSR.INTSET"....  */
  if (is_write && !is_user && !strcasecmp ("interrupt", sr_name))
    sr_name = "intset";
  new_opname = (char *) xmalloc (strlen (sr_name) + 6);
  sprintf (new_opname, "%s%s.%s", (has_underbar ? "_" : ""),
	   *popname, sr_name);
  free (*popname);
  *popname = new_opname;

  return 0;
}


static int
xtensa_translate_old_userreg_ops (char **popname)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_sysreg sr;
  char *opname, *new_opname;
  const char *sr_name;
  bfd_boolean has_underbar = FALSE;

  opname = *popname;
  if (opname[0] == '_')
    {
      has_underbar = TRUE;
      opname += 1;
    }

  sr = xtensa_sysreg_lookup_name (isa, opname + 1);
  if (sr != XTENSA_UNDEFINED)
    {
      /* The new default name ("nnn") is different from the old default
	 name ("URnnn").  The old default is handled below, and we don't
	 want to recognize [RW]nnn, so do nothing if the name is the (new)
	 default.  */
      static char namebuf[10];
      sprintf (namebuf, "%d", xtensa_sysreg_number (isa, sr));
      if (strcmp (namebuf, opname + 1) == 0)
	return 0;
    }
  else
    {
      offsetT val;
      char *end;

      /* Only continue if the reg name is "URnnn".  */
      if (opname[1] != 'u' || opname[2] != 'r')
	return 0;
      val = strtoul (opname + 3, &end, 10);
      if (*end != '\0')
	return 0;

      sr = xtensa_sysreg_lookup (isa, val, 1);
      if (sr == XTENSA_UNDEFINED)
	{
	  as_bad (_("invalid register number (%ld) for '%s'"),
		  val, opname);
	  return -1;
	}
    }

  /* Translate the opcode.  */
  sr_name = xtensa_sysreg_name (isa, sr);
  new_opname = (char *) xmalloc (strlen (sr_name) + 6);
  sprintf (new_opname, "%s%cur.%s", (has_underbar ? "_" : ""),
	   opname[0], sr_name);
  free (*popname);
  *popname = new_opname;

  return 0;
}


static int
xtensa_translate_zero_immed (char *old_op,
			     char *new_op,
			     char **popname,
			     int *pnum_args,
			     char **arg_strings)
{
  char *opname;
  offsetT val;

  opname = *popname;
  assert (opname[0] != '_');

  if (strcmp (opname, old_op) != 0)
    return 0;

  if (xg_check_num_args (pnum_args, 3, opname, arg_strings))
    return -1;
  if (xg_arg_is_constant (arg_strings[1], &val) && val == 0)
    {
      xg_replace_opname (popname, new_op);
      free (arg_strings[1]);
      arg_strings[1] = arg_strings[2];
      arg_strings[2] = 0;
      *pnum_args = 2;
    }

  return 0;
}


/* If the instruction is an idiom (i.e., a built-in macro), translate it.
   Returns non-zero if an error was found.  */

static int
xg_translate_idioms (char **popname, int *pnum_args, char **arg_strings)
{
  char *opname = *popname;
  bfd_boolean has_underbar = FALSE;

  if (cur_vinsn.inside_bundle)
    return 0;

  if (*opname == '_')
    {
      has_underbar = TRUE;
      opname += 1;
    }

  if (strcmp (opname, "mov") == 0)
    {
      if (use_transform () && !has_underbar && density_supported)
	xg_replace_opname (popname, "mov.n");
      else
	{
	  if (xg_check_num_args (pnum_args, 2, opname, arg_strings))
	    return -1;
	  xg_replace_opname (popname, (has_underbar ? "_or" : "or"));
	  arg_strings[2] = (char *) xmalloc (strlen (arg_strings[1]) + 1);
	  strcpy (arg_strings[2], arg_strings[1]);
	  *pnum_args = 3;
	}
      return 0;
    }

  if (strcmp (opname, "bbsi.l") == 0)
    {
      if (xg_check_num_args (pnum_args, 3, opname, arg_strings))
	return -1;
      xg_replace_opname (popname, (has_underbar ? "_bbsi" : "bbsi"));
      if (target_big_endian)
	xg_reverse_shift_count (&arg_strings[1]);
      return 0;
    }

  if (strcmp (opname, "bbci.l") == 0)
    {
      if (xg_check_num_args (pnum_args, 3, opname, arg_strings))
	return -1;
      xg_replace_opname (popname, (has_underbar ? "_bbci" : "bbci"));
      if (target_big_endian)
	xg_reverse_shift_count (&arg_strings[1]);
      return 0;
    }

  if (xtensa_nop_opcode == XTENSA_UNDEFINED
      && strcmp (opname, "nop") == 0)
    {
      if (use_transform () && !has_underbar && density_supported)
	xg_replace_opname (popname, "nop.n");
      else
	{
	  if (xg_check_num_args (pnum_args, 0, opname, arg_strings))
	    return -1;
	  xg_replace_opname (popname, (has_underbar ? "_or" : "or"));
	  arg_strings[0] = (char *) xmalloc (3);
	  arg_strings[1] = (char *) xmalloc (3);
	  arg_strings[2] = (char *) xmalloc (3);
	  strcpy (arg_strings[0], "a1");
	  strcpy (arg_strings[1], "a1");
	  strcpy (arg_strings[2], "a1");
	  *pnum_args = 3;
	}
      return 0;
    }

  /* Recognize [RW]UR and [RWX]SR.  */
  if ((((opname[0] == 'r' || opname[0] == 'w')
	&& (opname[1] == 'u' || opname[1] == 's'))
       || (opname[0] == 'x' && opname[1] == 's'))
      && opname[2] == 'r'
      && opname[3] == '\0')
    return xg_translate_sysreg_op (popname, pnum_args, arg_strings);

  /* Backward compatibility for RUR and WUR: Recognize [RW]UR<nnn> and
     [RW]<name> if <name> is the non-default name of a user register.  */
  if ((opname[0] == 'r' || opname[0] == 'w')
      && xtensa_opcode_lookup (xtensa_default_isa, opname) == XTENSA_UNDEFINED)
    return xtensa_translate_old_userreg_ops (popname);

  /* Relax branches that don't allow comparisons against an immediate value
     of zero to the corresponding branches with implicit zero immediates.  */
  if (!has_underbar && use_transform ())
    {
      if (xtensa_translate_zero_immed ("bnei", "bnez", popname,
				       pnum_args, arg_strings))
	return -1;

      if (xtensa_translate_zero_immed ("beqi", "beqz", popname,
				       pnum_args, arg_strings))
	return -1;

      if (xtensa_translate_zero_immed ("bgei", "bgez", popname,
				       pnum_args, arg_strings))
	return -1;

      if (xtensa_translate_zero_immed ("blti", "bltz", popname,
				       pnum_args, arg_strings))
	return -1;
    }

  return 0;
}


/* Functions for dealing with the Xtensa ISA.  */

/* Currently the assembler only allows us to use a single target per
   fragment.  Because of this, only one operand for a given
   instruction may be symbolic.  If there is a PC-relative operand,
   the last one is chosen.  Otherwise, the result is the number of the
   last immediate operand, and if there are none of those, we fail and
   return -1.  */

static int
get_relaxable_immed (xtensa_opcode opcode)
{
  int last_immed = -1;
  int noperands, opi;

  if (opcode == XTENSA_UNDEFINED)
    return -1;

  noperands = xtensa_opcode_num_operands (xtensa_default_isa, opcode);
  for (opi = noperands - 1; opi >= 0; opi--)
    {
      if (xtensa_operand_is_visible (xtensa_default_isa, opcode, opi) == 0)
	continue;
      if (xtensa_operand_is_PCrelative (xtensa_default_isa, opcode, opi) == 1)
	return opi;
      if (last_immed == -1
	  && xtensa_operand_is_register (xtensa_default_isa, opcode, opi) == 0)
	last_immed = opi;
    }
  return last_immed;
}


static xtensa_opcode
get_opcode_from_buf (const char *buf, int slot)
{
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt;

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  xtensa_insnbuf_from_chars (isa, insnbuf, buf, 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;

  if (slot >= xtensa_format_num_slots (isa, fmt))
    return XTENSA_UNDEFINED;

  xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
  return xtensa_opcode_decode (isa, fmt, slot, slotbuf);
}


#ifdef TENSILICA_DEBUG

/* For debugging, print out the mapping of opcode numbers to opcodes.  */

static void
xtensa_print_insn_table (void)
{
  int num_opcodes, num_operands;
  xtensa_opcode opcode;
  xtensa_isa isa = xtensa_default_isa;

  num_opcodes = xtensa_isa_num_opcodes (xtensa_default_isa);
  for (opcode = 0; opcode < num_opcodes; opcode++)
    {
      int opn;
      fprintf (stderr, "%d: %s: ", opcode, xtensa_opcode_name (isa, opcode));
      num_operands = xtensa_opcode_num_operands (isa, opcode);
      for (opn = 0; opn < num_operands; opn++)
	{
	  if (xtensa_operand_is_visible (isa, opcode, opn) == 0)
	    continue;
	  if (xtensa_operand_is_register (isa, opcode, opn) == 1)
	    {
	      xtensa_regfile opnd_rf =
		xtensa_operand_regfile (isa, opcode, opn);
	      fprintf (stderr, "%s ", xtensa_regfile_shortname (isa, opnd_rf));
	    }
	  else if (xtensa_operand_is_PCrelative (isa, opcode, opn) == 1)
	    fputs ("[lLr] ", stderr);
	  else
	    fputs ("i ", stderr);
	}
      fprintf (stderr, "\n");
    }
}


static void
print_vliw_insn (xtensa_insnbuf vbuf)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format f = xtensa_format_decode (isa, vbuf);
  xtensa_insnbuf sbuf = xtensa_insnbuf_alloc (isa);
  int op;

  fprintf (stderr, "format = %d\n", f);

  for (op = 0; op < xtensa_format_num_slots (isa, f); op++)
    {
      xtensa_opcode opcode;
      const char *opname;
      int operands;

      xtensa_format_get_slot (isa, f, op, vbuf, sbuf);
      opcode = xtensa_opcode_decode (isa, f, op, sbuf);
      opname = xtensa_opcode_name (isa, opcode);

      fprintf (stderr, "op in slot %i is %s;\n", op, opname);
      fprintf (stderr, "   operands = ");
      for (operands = 0;
	   operands < xtensa_opcode_num_operands (isa, opcode);
	   operands++)
	{
	  unsigned int val;
	  if (xtensa_operand_is_visible (isa, opcode, operands) == 0)
	    continue;
	  xtensa_operand_get_field (isa, opcode, operands, f, op, sbuf, &val);
	  xtensa_operand_decode (isa, opcode, operands, &val);
	  fprintf (stderr, "%d ", val);
	}
      fprintf (stderr, "\n");
    }
  xtensa_insnbuf_free (isa, sbuf);
}

#endif /* TENSILICA_DEBUG */


static bfd_boolean
is_direct_call_opcode (xtensa_opcode opcode)
{
  xtensa_isa isa = xtensa_default_isa;
  int n, num_operands;

  if (xtensa_opcode_is_call (isa, opcode) == 0)
    return FALSE;

  num_operands = xtensa_opcode_num_operands (isa, opcode);
  for (n = 0; n < num_operands; n++)
    {
      if (xtensa_operand_is_register (isa, opcode, n) == 0
	  && xtensa_operand_is_PCrelative (isa, opcode, n) == 1)
	return TRUE;
    }
  return FALSE;
}


/* Convert from BFD relocation type code to slot and operand number.
   Returns non-zero on failure.  */

static int
decode_reloc (bfd_reloc_code_real_type reloc, int *slot, bfd_boolean *is_alt)
{
  if (reloc >= BFD_RELOC_XTENSA_SLOT0_OP
      && reloc <= BFD_RELOC_XTENSA_SLOT14_OP)
    {
      *slot = reloc - BFD_RELOC_XTENSA_SLOT0_OP;
      *is_alt = FALSE;
    }
  else if (reloc >= BFD_RELOC_XTENSA_SLOT0_ALT
      && reloc <= BFD_RELOC_XTENSA_SLOT14_ALT)
    {
      *slot = reloc - BFD_RELOC_XTENSA_SLOT0_ALT;
      *is_alt = TRUE;
    }
  else
    return -1;

  return 0;
}


/* Convert from slot number to BFD relocation type code for the
   standard PC-relative relocations.  Return BFD_RELOC_NONE on
   failure.  */

static bfd_reloc_code_real_type
encode_reloc (int slot)
{
  if (slot < 0 || slot > 14)
    return BFD_RELOC_NONE;

  return BFD_RELOC_XTENSA_SLOT0_OP + slot;
}


/* Convert from slot numbers to BFD relocation type code for the
   "alternate" relocations.  Return BFD_RELOC_NONE on failure.  */

static bfd_reloc_code_real_type
encode_alt_reloc (int slot)
{
  if (slot < 0 || slot > 14)
    return BFD_RELOC_NONE;

  return BFD_RELOC_XTENSA_SLOT0_ALT + slot;
}


static void
xtensa_insnbuf_set_operand (xtensa_insnbuf slotbuf,
			    xtensa_format fmt,
			    int slot,
			    xtensa_opcode opcode,
			    int operand,
			    uint32 value,
			    const char *file,
			    unsigned int line)
{
  uint32 valbuf = value;

  if (xtensa_operand_encode (xtensa_default_isa, opcode, operand, &valbuf))
    {
      if (xtensa_operand_is_PCrelative (xtensa_default_isa, opcode, operand)
	  == 1)
	as_bad_where ((char *) file, line,
		      _("operand %u is out of range for '%s'"), value,
		      xtensa_opcode_name (xtensa_default_isa, opcode));
      else
	as_bad_where ((char *) file, line,
		      _("operand %u is invalid for '%s'"), value,
		      xtensa_opcode_name (xtensa_default_isa, opcode));
      return;
    }

  xtensa_operand_set_field (xtensa_default_isa, opcode, operand, fmt, slot,
			    slotbuf, valbuf);
}


static uint32
xtensa_insnbuf_get_operand (xtensa_insnbuf slotbuf,
			    xtensa_format fmt,
			    int slot,
			    xtensa_opcode opcode,
			    int opnum)
{
  uint32 val = 0;
  (void) xtensa_operand_get_field (xtensa_default_isa, opcode, opnum,
				   fmt, slot, slotbuf, &val);
  (void) xtensa_operand_decode (xtensa_default_isa, opcode, opnum, &val);
  return val;
}


/* Checks for rules from xtensa-relax tables.  */

/* The routine xg_instruction_matches_option_term must return TRUE
   when a given option term is true.  The meaning of all of the option
   terms is given interpretation by this function.  This is needed when
   an option depends on the state of a directive, but there are no such
   options in use right now.  */

static bfd_boolean
xg_instruction_matches_option_term (TInsn *insn ATTRIBUTE_UNUSED,
				    const ReqOrOption *option)
{
  if (strcmp (option->option_name, "realnop") == 0
      || strncmp (option->option_name, "IsaUse", 6) == 0)
    {
      /* These conditions were evaluated statically when building the
	 relaxation table.  There's no need to reevaluate them now.  */
      return TRUE;
    }
  else
    {
      as_fatal (_("internal error: unknown option name '%s'"),
		option->option_name);
    }
}


static bfd_boolean
xg_instruction_matches_or_options (TInsn *insn,
				   const ReqOrOptionList *or_option)
{
  const ReqOrOption *option;
  /* Must match each of the AND terms.  */
  for (option = or_option; option != NULL; option = option->next)
    {
      if (xg_instruction_matches_option_term (insn, option))
	return TRUE;
    }
  return FALSE;
}


static bfd_boolean
xg_instruction_matches_options (TInsn *insn, const ReqOptionList *options)
{
  const ReqOption *req_options;
  /* Must match each of the AND terms.  */
  for (req_options = options;
       req_options != NULL;
       req_options = req_options->next)
    {
      /* Must match one of the OR clauses.  */
      if (!xg_instruction_matches_or_options (insn,
					      req_options->or_option_terms))
	return FALSE;
    }
  return TRUE;
}


/* Return the transition rule that matches or NULL if none matches.  */

static bfd_boolean
xg_instruction_matches_rule (TInsn *insn, TransitionRule *rule)
{
  PreconditionList *condition_l;

  if (rule->opcode != insn->opcode)
    return FALSE;

  for (condition_l = rule->conditions;
       condition_l != NULL;
       condition_l = condition_l->next)
    {
      expressionS *exp1;
      expressionS *exp2;
      Precondition *cond = condition_l->precond;

      switch (cond->typ)
	{
	case OP_CONSTANT:
	  /* The expression must be the constant.  */
	  assert (cond->op_num < insn->ntok);
	  exp1 = &insn->tok[cond->op_num];
	  if (expr_is_const (exp1))
	    {
	      switch (cond->cmp)
		{
		case OP_EQUAL:
		  if (get_expr_const (exp1) != cond->op_data)
		    return FALSE;
		  break;
		case OP_NOTEQUAL:
		  if (get_expr_const (exp1) == cond->op_data)
		    return FALSE;
		  break;
		default:
		  return FALSE;
		}
	    }
	  else if (expr_is_register (exp1))
	    {
	      switch (cond->cmp)
		{
		case OP_EQUAL:
		  if (get_expr_register (exp1) != cond->op_data)
		    return FALSE;
		  break;
		case OP_NOTEQUAL:
		  if (get_expr_register (exp1) == cond->op_data)
		    return FALSE;
		  break;
		default:
		  return FALSE;
		}
	    }
	  else
	    return FALSE;
	  break;

	case OP_OPERAND:
	  assert (cond->op_num < insn->ntok);
	  assert (cond->op_data < insn->ntok);
	  exp1 = &insn->tok[cond->op_num];
	  exp2 = &insn->tok[cond->op_data];

	  switch (cond->cmp)
	    {
	    case OP_EQUAL:
	      if (!expr_is_equal (exp1, exp2))
		return FALSE;
	      break;
	    case OP_NOTEQUAL:
	      if (expr_is_equal (exp1, exp2))
		return FALSE;
	      break;
	    }
	  break;

	case OP_LITERAL:
	case OP_LABEL:
	default:
	  return FALSE;
	}
    }
  if (!xg_instruction_matches_options (insn, rule->options))
    return FALSE;

  return TRUE;
}


static int
transition_rule_cmp (const TransitionRule *a, const TransitionRule *b)
{
  bfd_boolean a_greater = FALSE;
  bfd_boolean b_greater = FALSE;

  ReqOptionList *l_a = a->options;
  ReqOptionList *l_b = b->options;

  /* We only care if they both are the same except for
     a const16 vs. an l32r.  */

  while (l_a && l_b && ((l_a->next == NULL) == (l_b->next == NULL)))
    {
      ReqOrOptionList *l_or_a = l_a->or_option_terms;
      ReqOrOptionList *l_or_b = l_b->or_option_terms;
      while (l_or_a && l_or_b && ((l_a->next == NULL) == (l_b->next == NULL)))
	{
	  if (l_or_a->is_true != l_or_b->is_true)
	    return 0;
	  if (strcmp (l_or_a->option_name, l_or_b->option_name) != 0)
	    {
	      /* This is the case we care about.  */
	      if (strcmp (l_or_a->option_name, "IsaUseConst16") == 0
		  && strcmp (l_or_b->option_name, "IsaUseL32R") == 0)
		{
		  if (prefer_const16)
		    a_greater = TRUE;
		  else
		    b_greater = TRUE;
		}
	      else if (strcmp (l_or_a->option_name, "IsaUseL32R") == 0
		       && strcmp (l_or_b->option_name, "IsaUseConst16") == 0)
		{
		  if (prefer_const16)
		    b_greater = TRUE;
		  else
		    a_greater = TRUE;
		}
	      else
		return 0;
	    }
	  l_or_a = l_or_a->next;
	  l_or_b = l_or_b->next;
	}
      if (l_or_a || l_or_b)
	return 0;

      l_a = l_a->next;
      l_b = l_b->next;
    }
  if (l_a || l_b)
    return 0;

  /* Incomparable if the substitution was used differently in two cases.  */
  if (a_greater && b_greater)
    return 0;

  if (b_greater)
    return 1;
  if (a_greater)
    return -1;

  return 0;
}


static TransitionRule *
xg_instruction_match (TInsn *insn)
{
  TransitionTable *table = xg_build_simplify_table (&transition_rule_cmp);
  TransitionList *l;
  assert (insn->opcode < table->num_opcodes);

  /* Walk through all of the possible transitions.  */
  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;
      if (xg_instruction_matches_rule (insn, rule))
	return rule;
    }
  return NULL;
}


/* Various Other Internal Functions.  */

static bfd_boolean
is_unique_insn_expansion (TransitionRule *r)
{
  if (!r->to_instr || r->to_instr->next != NULL)
    return FALSE;
  if (r->to_instr->typ != INSTR_INSTR)
    return FALSE;
  return TRUE;
}


static int
xg_get_build_instr_size (BuildInstr *insn)
{
  assert (insn->typ == INSTR_INSTR);
  return xg_get_single_size (insn->opcode);
}


static bfd_boolean
xg_is_narrow_insn (TInsn *insn)
{
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
  int num_match = 0;
  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;

      if (xg_instruction_matches_rule (insn, rule)
	  && is_unique_insn_expansion (rule))
	{
	  /* It only generates one instruction... */
	  assert (insn->insn_type == ITYPE_INSN);
	  /* ...and it is a larger instruction.  */
	  if (xg_get_single_size (insn->opcode)
	      < xg_get_build_instr_size (rule->to_instr))
	    {
	      num_match++;
	      if (num_match > 1)
		return FALSE;
	    }
	}
    }
  return (num_match == 1);
}


static bfd_boolean
xg_is_single_relaxable_insn (TInsn *insn)
{
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
  int num_match = 0;
  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;

      if (xg_instruction_matches_rule (insn, rule)
	  && is_unique_insn_expansion (rule))
	{
	  /* It only generates one instruction... */
	  assert (insn->insn_type == ITYPE_INSN);
	  /* ... and it is a larger instruction.  */
	  if (xg_get_single_size (insn->opcode)
	      <= xg_get_build_instr_size (rule->to_instr))
	    {
	      num_match++;
	      if (num_match > 1)
		return FALSE;
	    }
	}
    }
  return (num_match == 1);
}


/* Return the maximum number of bytes this opcode can expand to.  */

static int
xg_get_max_insn_widen_size (xtensa_opcode opcode)
{
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
  int max_size = xg_get_single_size (opcode);

  assert (opcode < table->num_opcodes);

  for (l = table->table[opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;
      BuildInstr *build_list;
      int this_size = 0;

      if (!rule)
	continue;
      build_list = rule->to_instr;
      if (is_unique_insn_expansion (rule))
	{
	  assert (build_list->typ == INSTR_INSTR);
	  this_size = xg_get_max_insn_widen_size (build_list->opcode);
	}
      else
	for (; build_list != NULL; build_list = build_list->next)
	  {
	    switch (build_list->typ)
	      {
	      case INSTR_INSTR:
		this_size += xg_get_single_size (build_list->opcode);
		break;
	      case INSTR_LITERAL_DEF:
	      case INSTR_LABEL_DEF:
	      default:
		break;
	      }
	  }
      if (this_size > max_size)
	max_size = this_size;
    }
  return max_size;
}


/* Return the maximum number of literal bytes this opcode can generate.  */

static int
xg_get_max_insn_widen_literal_size (xtensa_opcode opcode)
{
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;
  int max_size = 0;

  assert (opcode < table->num_opcodes);

  for (l = table->table[opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;
      BuildInstr *build_list;
      int this_size = 0;

      if (!rule)
	continue;
      build_list = rule->to_instr;
      if (is_unique_insn_expansion (rule))
	{
	  assert (build_list->typ == INSTR_INSTR);
	  this_size = xg_get_max_insn_widen_literal_size (build_list->opcode);
	}
      else
	for (; build_list != NULL; build_list = build_list->next)
	  {
	    switch (build_list->typ)
	      {
	      case INSTR_LITERAL_DEF:
		/* Hard-coded 4-byte literal.  */
		this_size += 4;
		break;
	      case INSTR_INSTR:
	      case INSTR_LABEL_DEF:
	      default:
		break;
	      }
	  }
      if (this_size > max_size)
	max_size = this_size;
    }
  return max_size;
}


static bfd_boolean
xg_is_relaxable_insn (TInsn *insn, int lateral_steps)
{
  int steps_taken = 0;
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;

  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;

      if (xg_instruction_matches_rule (insn, rule))
	{
	  if (steps_taken == lateral_steps)
	    return TRUE;
	  steps_taken++;
	}
    }
  return FALSE;
}


static symbolS *
get_special_literal_symbol (void)
{
  static symbolS *sym = NULL;

  if (sym == NULL)
    sym = symbol_find_or_make ("SPECIAL_LITERAL0\001");
  return sym;
}


static symbolS *
get_special_label_symbol (void)
{
  static symbolS *sym = NULL;

  if (sym == NULL)
    sym = symbol_find_or_make ("SPECIAL_LABEL0\001");
  return sym;
}


static bfd_boolean
xg_valid_literal_expression (const expressionS *exp)
{
  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_big:
    case O_uminus:
    case O_subtract:
    case O_pltrel:
      return TRUE;
    default:
      return FALSE;
    }
}


/* This will check to see if the value can be converted into the
   operand type.  It will return TRUE if it does not fit.  */

static bfd_boolean
xg_check_operand (int32 value, xtensa_opcode opcode, int operand)
{
  uint32 valbuf = value;
  if (xtensa_operand_encode (xtensa_default_isa, opcode, operand, &valbuf))
    return TRUE;
  return FALSE;
}


/* Assumes: All immeds are constants.  Check that all constants fit
   into their immeds; return FALSE if not.  */

static bfd_boolean
xg_immeds_fit (const TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  int i;

  int n = insn->ntok;
  assert (insn->insn_type == ITYPE_INSN);
  for (i = 0; i < n; ++i)
    {
      const expressionS *expr = &insn->tok[i];
      if (xtensa_operand_is_register (isa, insn->opcode, i) == 1)
	continue;

      switch (expr->X_op)
	{
	case O_register:
	case O_constant:
	  if (xg_check_operand (expr->X_add_number, insn->opcode, i))
	    return FALSE;
	  break;

	default:
	  /* The symbol should have a fixup associated with it.  */
	  assert (FALSE);
	  break;
	}
    }
  return TRUE;
}


/* This should only be called after we have an initial
   estimate of the addresses.  */

static bfd_boolean
xg_symbolic_immeds_fit (const TInsn *insn,
			segT pc_seg,
			fragS *pc_frag,
			offsetT pc_offset,
			long stretch)
{
  xtensa_isa isa = xtensa_default_isa;
  symbolS *symbolP;
  fragS *sym_frag;
  offsetT target, pc;
  uint32 new_offset;
  int i;
  int n = insn->ntok;

  assert (insn->insn_type == ITYPE_INSN);

  for (i = 0; i < n; ++i)
    {
      const expressionS *expr = &insn->tok[i];
      if (xtensa_operand_is_register (isa, insn->opcode, i) == 1)
	continue;

      switch (expr->X_op)
	{
	case O_register:
	case O_constant:
	  if (xg_check_operand (expr->X_add_number, insn->opcode, i))
	    return FALSE;
	  break;

	case O_lo16:
	case O_hi16:
	  /* Check for the worst case.  */
	  if (xg_check_operand (0xffff, insn->opcode, i))
	    return FALSE;
	  break;

	case O_symbol:
	  /* We only allow symbols for pc-relative stuff.
	     If pc_frag == 0, then we don't have frag locations yet.  */
	  if (pc_frag == 0)
	    return FALSE;

	  /* If it is PC-relative and the symbol is not in the same 
	     segment as the PC.... */
	  if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 0
	      || S_GET_SEGMENT (expr->X_add_symbol) != pc_seg)
	    return FALSE;

	  /* If it is a weak symbol, then assume it won't reach.  This will
	     only affect calls when longcalls are enabled, because if
	     longcalls are disabled, then the call is marked as a specific
	     opcode.  */
	  if (S_IS_WEAK (expr->X_add_symbol))
	    return FALSE;

	  symbolP = expr->X_add_symbol;
	  sym_frag = symbol_get_frag (symbolP);
	  target = S_GET_VALUE (symbolP) + expr->X_add_number;
	  pc = pc_frag->fr_address + pc_offset;

	  /* If frag has yet to be reached on this pass, assume it
	     will move by STRETCH just as we did.  If this is not so,
	     it will be because some frag between grows, and that will
	     force another pass.  Beware zero-length frags.  There
	     should be a faster way to do this.  */

	  if (stretch != 0
	      && sym_frag->relax_marker != pc_frag->relax_marker
	      && S_GET_SEGMENT (symbolP) == pc_seg)
	    {
	      target += stretch;
	    }
 
	  new_offset = target;
	  xtensa_operand_do_reloc (isa, insn->opcode, i, &new_offset, pc);
	  if (xg_check_operand (new_offset, insn->opcode, i))
	    return FALSE;
	  break;

	default:
	  /* The symbol should have a fixup associated with it.  */
	  return FALSE;
	}
    }

  return TRUE;
}


/* Return TRUE on success.  */

static bfd_boolean
xg_build_to_insn (TInsn *targ, TInsn *insn, BuildInstr *bi)
{
  BuildOp *op;
  symbolS *sym;

  memset (targ, 0, sizeof (TInsn));
  targ->loc = insn->loc;
  switch (bi->typ)
    {
    case INSTR_INSTR:
      op = bi->ops;
      targ->opcode = bi->opcode;
      targ->insn_type = ITYPE_INSN;
      targ->is_specific_opcode = FALSE;

      for (; op != NULL; op = op->next)
	{
	  int op_num = op->op_num;
	  int op_data = op->op_data;

	  assert (op->op_num < MAX_INSN_ARGS);

	  if (targ->ntok <= op_num)
	    targ->ntok = op_num + 1;

	  switch (op->typ)
	    {
	    case OP_CONSTANT:
	      set_expr_const (&targ->tok[op_num], op_data);
	      break;
	    case OP_OPERAND:
	      assert (op_data < insn->ntok);
	      copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
	      break;
	    case OP_LITERAL:
	      sym = get_special_literal_symbol ();
	      set_expr_symbol_offset (&targ->tok[op_num], sym, 0);
	      break;
	    case OP_LABEL:
	      sym = get_special_label_symbol ();
	      set_expr_symbol_offset (&targ->tok[op_num], sym, 0);
	      break;
	    case OP_OPERAND_HI16U:
	    case OP_OPERAND_LOW16U:
	      assert (op_data < insn->ntok);
	      if (expr_is_const (&insn->tok[op_data]))
		{
		  long val;
		  copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
		  val = xg_apply_userdef_op_fn (op->typ,
						targ->tok[op_num].
						X_add_number);
		  targ->tok[op_num].X_add_number = val;
		}
	      else
		{
		  /* For const16 we can create relocations for these.  */
		  if (targ->opcode == XTENSA_UNDEFINED
		      || (targ->opcode != xtensa_const16_opcode))
		    return FALSE;
		  assert (op_data < insn->ntok);
		  /* Need to build a O_lo16 or O_hi16.  */
		  copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
		  if (targ->tok[op_num].X_op == O_symbol)
		    {
		      if (op->typ == OP_OPERAND_HI16U)
			targ->tok[op_num].X_op = O_hi16;
		      else if (op->typ == OP_OPERAND_LOW16U)
			targ->tok[op_num].X_op = O_lo16;
		      else
			return FALSE;
		    }
		}
	      break;
	    default:
	      /* currently handles:
		 OP_OPERAND_LOW8
		 OP_OPERAND_HI24S
		 OP_OPERAND_F32MINUS */
	      if (xg_has_userdef_op_fn (op->typ))
		{
		  assert (op_data < insn->ntok);
		  if (expr_is_const (&insn->tok[op_data]))
		    {
		      long val;
		      copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
		      val = xg_apply_userdef_op_fn (op->typ,
						    targ->tok[op_num].
						    X_add_number);
		      targ->tok[op_num].X_add_number = val;
		    }
		  else
		    return FALSE; /* We cannot use a relocation for this.  */
		  break;
		}
	      assert (0);
	      break;
	    }
	}
      break;

    case INSTR_LITERAL_DEF:
      op = bi->ops;
      targ->opcode = XTENSA_UNDEFINED;
      targ->insn_type = ITYPE_LITERAL;
      targ->is_specific_opcode = FALSE;
      for (; op != NULL; op = op->next)
	{
	  int op_num = op->op_num;
	  int op_data = op->op_data;
	  assert (op->op_num < MAX_INSN_ARGS);

	  if (targ->ntok <= op_num)
	    targ->ntok = op_num + 1;

	  switch (op->typ)
	    {
	    case OP_OPERAND:
	      assert (op_data < insn->ntok);
	      /* We can only pass resolvable literals through.  */
	      if (!xg_valid_literal_expression (&insn->tok[op_data]))
		return FALSE;
	      copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
	      break;
	    case OP_LITERAL:
	    case OP_CONSTANT:
	    case OP_LABEL:
	    default:
	      assert (0);
	      break;
	    }
	}
      break;

    case INSTR_LABEL_DEF:
      op = bi->ops;
      targ->opcode = XTENSA_UNDEFINED;
      targ->insn_type = ITYPE_LABEL;
      targ->is_specific_opcode = FALSE;
      /* Literal with no ops is a label?  */
      assert (op == NULL);
      break;

    default:
      assert (0);
    }

  return TRUE;
}


/* Return TRUE on success.  */

static bfd_boolean
xg_build_to_stack (IStack *istack, TInsn *insn, BuildInstr *bi)
{
  for (; bi != NULL; bi = bi->next)
    {
      TInsn *next_insn = istack_push_space (istack);

      if (!xg_build_to_insn (next_insn, insn, bi))
	return FALSE;
    }
  return TRUE;
}


/* Return TRUE on valid expansion.  */

static bfd_boolean
xg_expand_to_stack (IStack *istack, TInsn *insn, int lateral_steps)
{
  int stack_size = istack->ninsn;
  int steps_taken = 0;
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;

  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;

      if (xg_instruction_matches_rule (insn, rule))
	{
	  if (lateral_steps == steps_taken)
	    {
	      int i;

	      /* This is it.  Expand the rule to the stack.  */
	      if (!xg_build_to_stack (istack, insn, rule->to_instr))
		return FALSE;

	      /* Check to see if it fits.  */
	      for (i = stack_size; i < istack->ninsn; i++)
		{
		  TInsn *insn = &istack->insn[i];

		  if (insn->insn_type == ITYPE_INSN
		      && !tinsn_has_symbolic_operands (insn)
		      && !xg_immeds_fit (insn))
		    {
		      istack->ninsn = stack_size;
		      return FALSE;
		    }
		}
	      return TRUE;
	    }
	  steps_taken++;
	}
    }
  return FALSE;
}


static bfd_boolean
xg_expand_narrow (TInsn *targ, TInsn *insn)
{
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
  TransitionList *l;

  assert (insn->insn_type == ITYPE_INSN);
  assert (insn->opcode < table->num_opcodes);

  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;
      if (xg_instruction_matches_rule (insn, rule)
	  && is_unique_insn_expansion (rule))
	{
	  /* Is it a larger instruction?  */
	  if (xg_get_single_size (insn->opcode)
	      <= xg_get_build_instr_size (rule->to_instr))
	    {
	      xg_build_to_insn (targ, insn, rule->to_instr);
	      return FALSE;
	    }
	}
    }
  return TRUE;
}


/* Relax the assembly instruction at least "min_steps".
   Return the number of steps taken.  */

static int
xg_assembly_relax (IStack *istack,
		   TInsn *insn,
		   segT pc_seg,
		   fragS *pc_frag,	/* if pc_frag == 0, not pc-relative */
		   offsetT pc_offset,	/* offset in fragment */
		   int min_steps,	/* minimum conversion steps */
		   long stretch)	/* number of bytes stretched so far */
{
  int steps_taken = 0;

  /* assert (has no symbolic operands)
     Some of its immeds don't fit.
     Try to build a relaxed version.
     This may go through a couple of stages
     of single instruction transformations before
     we get there.  */

  TInsn single_target;
  TInsn current_insn;
  int lateral_steps = 0;
  int istack_size = istack->ninsn;

  if (xg_symbolic_immeds_fit (insn, pc_seg, pc_frag, pc_offset, stretch)
      && steps_taken >= min_steps)
    {
      istack_push (istack, insn);
      return steps_taken;
    }
  current_insn = *insn;

  /* Walk through all of the single instruction expansions. */
  while (xg_is_single_relaxable_insn (&current_insn))
    {
      int error_val = xg_expand_narrow (&single_target, &current_insn);

      assert (!error_val);

      if (xg_symbolic_immeds_fit (&single_target, pc_seg, pc_frag, pc_offset,
				  stretch))
	{
	  steps_taken++;
	  if (steps_taken >= min_steps)
	    {
	      istack_push (istack, &single_target);
	      return steps_taken;
	    }
	}
      current_insn = single_target;
    }

  /* Now check for a multi-instruction expansion.  */
  while (xg_is_relaxable_insn (&current_insn, lateral_steps))
    {
      if (xg_symbolic_immeds_fit (&current_insn, pc_seg, pc_frag, pc_offset,
				  stretch))
	{
	  if (steps_taken >= min_steps)
	    {
	      istack_push (istack, &current_insn);
	      return steps_taken;
	    }
	}
      steps_taken++;
      if (xg_expand_to_stack (istack, &current_insn, lateral_steps))
	{
	  if (steps_taken >= min_steps)
	    return steps_taken;
	}
      lateral_steps++;
      istack->ninsn = istack_size;
    }

  /* It's not going to work -- use the original.  */
  istack_push (istack, insn);
  return steps_taken;
}


static void
xg_force_frag_space (int size)
{
  /* This may have the side effect of creating a new fragment for the
     space to go into.  I just do not like the name of the "frag"
     functions.  */
  frag_grow (size);
}


static void
xg_finish_frag (char *last_insn,
		enum xtensa_relax_statesE frag_state,
		enum xtensa_relax_statesE slot0_state,
		int max_growth,
		bfd_boolean is_insn)
{
  /* Finish off this fragment so that it has at LEAST the desired
     max_growth.  If it doesn't fit in this fragment, close this one
     and start a new one.  In either case, return a pointer to the
     beginning of the growth area.  */

  fragS *old_frag;

  xg_force_frag_space (max_growth);

  old_frag = frag_now;

  frag_now->fr_opcode = last_insn;
  if (is_insn)
    frag_now->tc_frag_data.is_insn = TRUE;

  frag_var (rs_machine_dependent, max_growth, max_growth,
	    frag_state, frag_now->fr_symbol, frag_now->fr_offset, last_insn);

  old_frag->tc_frag_data.slot_subtypes[0] = slot0_state;
  xtensa_set_frag_assembly_state (frag_now);

  /* Just to make sure that we did not split it up.  */
  assert (old_frag->fr_next == frag_now);
}


/* Return TRUE if the target frag is one of the next non-empty frags.  */

static bfd_boolean
is_next_frag_target (const fragS *fragP, const fragS *target)
{
  if (fragP == NULL)
    return FALSE;

  for (; fragP; fragP = fragP->fr_next)
    {
      if (fragP == target)
	return TRUE;
      if (fragP->fr_fix != 0)
	return FALSE;
      if (fragP->fr_type == rs_fill && fragP->fr_offset != 0)
	return FALSE;
      if ((fragP->fr_type == rs_align || fragP->fr_type == rs_align_code)
	  && ((fragP->fr_address % (1 << fragP->fr_offset)) != 0))
	return FALSE;
      if (fragP->fr_type == rs_space)
	return FALSE;
    }
  return FALSE;
}


static bfd_boolean
is_branch_jmp_to_next (TInsn *insn, fragS *fragP)
{
  xtensa_isa isa = xtensa_default_isa;
  int i;
  int num_ops = xtensa_opcode_num_operands (isa, insn->opcode);
  int target_op = -1;
  symbolS *sym;
  fragS *target_frag;

  if (xtensa_opcode_is_branch (isa, insn->opcode) == 0
      && xtensa_opcode_is_jump (isa, insn->opcode) == 0)
    return FALSE;

  for (i = 0; i < num_ops; i++)
    {
      if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 1)
	{
	  target_op = i;
	  break;
	}
    }
  if (target_op == -1)
    return FALSE;

  if (insn->ntok <= target_op)
    return FALSE;

  if (insn->tok[target_op].X_op != O_symbol)
    return FALSE;

  sym = insn->tok[target_op].X_add_symbol;
  if (sym == NULL)
    return FALSE;

  if (insn->tok[target_op].X_add_number != 0)
    return FALSE;

  target_frag = symbol_get_frag (sym);
  if (target_frag == NULL)
    return FALSE;

  if (is_next_frag_target (fragP->fr_next, target_frag) 
      && S_GET_VALUE (sym) == target_frag->fr_address)
    return TRUE;

  return FALSE;
}


static void
xg_add_branch_and_loop_targets (TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  int num_ops = xtensa_opcode_num_operands (isa, insn->opcode);

  if (xtensa_opcode_is_loop (isa, insn->opcode) == 1)
    {
      int i = 1;
      if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 1
	  && insn->tok[i].X_op == O_symbol)
	symbol_get_tc (insn->tok[i].X_add_symbol)->is_loop_target = TRUE;
      return;
    }

  if (xtensa_opcode_is_branch (isa, insn->opcode) == 1
      || xtensa_opcode_is_loop (isa, insn->opcode) == 1)
    {
      int i;

      for (i = 0; i < insn->ntok && i < num_ops; i++)
	{
	  if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 1
	      && insn->tok[i].X_op == O_symbol)
	    {
	      symbolS *sym = insn->tok[i].X_add_symbol;
	      symbol_get_tc (sym)->is_branch_target = TRUE;
	      if (S_IS_DEFINED (sym))
		symbol_get_frag (sym)->tc_frag_data.is_branch_target = TRUE;
	    }
	}
    }
}


/* Return FALSE if no error.  */

static bfd_boolean
xg_build_token_insn (BuildInstr *instr_spec, TInsn *old_insn, TInsn *new_insn)
{
  int num_ops = 0;
  BuildOp *b_op;

  switch (instr_spec->typ)
    {
    case INSTR_INSTR:
      new_insn->insn_type = ITYPE_INSN;
      new_insn->opcode = instr_spec->opcode;
      new_insn->is_specific_opcode = FALSE;
      new_insn->loc = old_insn->loc;
      break;
    case INSTR_LITERAL_DEF:
      new_insn->insn_type = ITYPE_LITERAL;
      new_insn->opcode = XTENSA_UNDEFINED;
      new_insn->is_specific_opcode = FALSE;
      new_insn->loc = old_insn->loc;
      break;
    case INSTR_LABEL_DEF:
      as_bad (_("INSTR_LABEL_DEF not supported yet"));
      break;
    }

  for (b_op = instr_spec->ops; b_op != NULL; b_op = b_op->next)
    {
      expressionS *exp;
      const expressionS *src_exp;

      num_ops++;
      switch (b_op->typ)
	{
	case OP_CONSTANT:
	  /* The expression must be the constant.  */
	  assert (b_op->op_num < MAX_INSN_ARGS);
	  exp = &new_insn->tok[b_op->op_num];
	  set_expr_const (exp, b_op->op_data);
	  break;

	case OP_OPERAND:
	  assert (b_op->op_num < MAX_INSN_ARGS);
	  assert (b_op->op_data < (unsigned) old_insn->ntok);
	  src_exp = &old_insn->tok[b_op->op_data];
	  exp = &new_insn->tok[b_op->op_num];
	  copy_expr (exp, src_exp);
	  break;

	case OP_LITERAL:
	case OP_LABEL:
	  as_bad (_("can't handle generation of literal/labels yet"));
	  assert (0);

	default:
	  as_bad (_("can't handle undefined OP TYPE"));
	  assert (0);
	}
    }

  new_insn->ntok = num_ops;
  return FALSE;
}


/* Return TRUE if it was simplified.  */

static bfd_boolean
xg_simplify_insn (TInsn *old_insn, TInsn *new_insn)
{
  TransitionRule *rule;
  BuildInstr *insn_spec;

  if (old_insn->is_specific_opcode || !density_supported)
    return FALSE;

  rule = xg_instruction_match (old_insn);
  if (rule == NULL)
    return FALSE;

  insn_spec = rule->to_instr;
  /* There should only be one.  */
  assert (insn_spec != NULL);
  assert (insn_spec->next == NULL);
  if (insn_spec->next != NULL)
    return FALSE;

  xg_build_token_insn (insn_spec, old_insn, new_insn);

  return TRUE;
}


/* xg_expand_assembly_insn: (1) Simplify the instruction, i.e., l32i ->
   l32i.n. (2) Check the number of operands.  (3) Place the instruction
   tokens into the stack or if we can relax it at assembly time, place
   multiple instructions/literals onto the stack.  Return FALSE if no
   error.  */

static bfd_boolean
xg_expand_assembly_insn (IStack *istack, TInsn *orig_insn)
{
  int noperands;
  TInsn new_insn;
  memset (&new_insn, 0, sizeof (TInsn));

  /* Narrow it if we can.  xg_simplify_insn now does all the
     appropriate checking (e.g., for the density option).  */
  if (xg_simplify_insn (orig_insn, &new_insn))
    orig_insn = &new_insn;

  noperands = xtensa_opcode_num_operands (xtensa_default_isa,
					  orig_insn->opcode);
  if (orig_insn->ntok < noperands)
    {
      as_bad (_("found %d operands for '%s':  Expected %d"),
	      orig_insn->ntok,
	      xtensa_opcode_name (xtensa_default_isa, orig_insn->opcode),
	      noperands);
      return TRUE;
    }
  if (orig_insn->ntok > noperands)
    as_warn (_("found too many (%d) operands for '%s':  Expected %d"),
	     orig_insn->ntok,
	     xtensa_opcode_name (xtensa_default_isa, orig_insn->opcode),
	     noperands);

  /* If there are not enough operands, we will assert above.  If there
     are too many, just cut out the extras here.  */

  orig_insn->ntok = noperands;

  /* Cases:

     Instructions with all constant immeds:
     Assemble them and relax the instruction if possible.
     Give error if not possible; no fixup needed.

     Instructions with symbolic immeds:
     Assemble them with a Fix up (that may cause instruction expansion).
     Also close out the fragment if the fixup may cause instruction expansion.

     There are some other special cases where we need alignment.
     1) before certain instructions with required alignment (OPCODE_ALIGN)
     2) before labels that have jumps (LABEL_ALIGN)
     3) after call instructions (RETURN_ALIGN)
        Multiple of these may be possible on the same fragment.
	If so, make sure to satisfy the required alignment.
	Then try to get the desired alignment.  */

  if (tinsn_has_invalid_symbolic_operands (orig_insn))
    return TRUE;

  if (orig_insn->is_specific_opcode || !use_transform ())
    {
      istack_push (istack, orig_insn);
      return FALSE;
    }

  if (tinsn_has_symbolic_operands (orig_insn))
    {
      if (tinsn_has_complex_operands (orig_insn))
	xg_assembly_relax (istack, orig_insn, 0, 0, 0, 0, 0);
      else
	istack_push (istack, orig_insn);
    }
  else
    {
      if (xg_immeds_fit (orig_insn))
	istack_push (istack, orig_insn);
      else
	xg_assembly_relax (istack, orig_insn, 0, 0, 0, 0, 0);
    }

  return FALSE;
}


/* Return TRUE if the section flags are marked linkonce
   or the name is .gnu.linkonce*.  */

static bfd_boolean
get_is_linkonce_section (bfd *abfd ATTRIBUTE_UNUSED, segT sec)
{
  flagword flags, link_once_flags;

  flags = bfd_get_section_flags (abfd, sec);
  link_once_flags = (flags & SEC_LINK_ONCE);

  /* Flags might not be set yet.  */
  if (!link_once_flags)
    {
      static size_t len = sizeof ".gnu.linkonce.t.";

      if (strncmp (segment_name (sec), ".gnu.linkonce.t.", len - 1) == 0)
	link_once_flags = SEC_LINK_ONCE;
    }
  return (link_once_flags != 0);
}


static void
xtensa_add_literal_sym (symbolS *sym)
{
  sym_list *l;

  l = (sym_list *) xmalloc (sizeof (sym_list));
  l->sym = sym;
  l->next = literal_syms;
  literal_syms = l;
}


static symbolS *
xtensa_create_literal_symbol (segT sec, fragS *frag)
{
  static int lit_num = 0;
  static char name[256];
  symbolS *symbolP;

  sprintf (name, ".L_lit_sym%d", lit_num);

  /* Create a local symbol.  If it is in a linkonce section, we have to
     be careful to make sure that if it is used in a relocation that the
     symbol will be in the output file.  */
  if (get_is_linkonce_section (stdoutput, sec))
    {
      symbolP = symbol_new (name, sec, 0, frag);
      S_CLEAR_EXTERNAL (symbolP);
      /* symbolP->local = 1; */
    }
  else
    symbolP = symbol_new (name, sec, 0, frag);

  xtensa_add_literal_sym (symbolP);

  frag->tc_frag_data.is_literal = TRUE;
  lit_num++;
  return symbolP;
}


/* Currently all literals that are generated here are 32-bit L32R targets.  */

static symbolS *
xg_assemble_literal (/* const */ TInsn *insn)
{
  emit_state state;
  symbolS *lit_sym = NULL;

  /* size = 4 for L32R.  It could easily be larger when we move to
     larger constants.  Add a parameter later.  */
  offsetT litsize = 4;
  offsetT litalign = 2;		/* 2^2 = 4 */
  expressionS saved_loc;
  expressionS * emit_val;

  set_expr_symbol_offset (&saved_loc, frag_now->fr_symbol, frag_now_fix ());

  assert (insn->insn_type == ITYPE_LITERAL);
  assert (insn->ntok == 1);	/* must be only one token here */

  xtensa_switch_to_literal_fragment (&state);

  emit_val = &insn->tok[0];
  if (emit_val->X_op == O_big)
    {
      int size = emit_val->X_add_number * CHARS_PER_LITTLENUM;
      if (size > litsize)
	{
	  /* This happens when someone writes a "movi a2, big_number".  */
	  as_bad_where (frag_now->fr_file, frag_now->fr_line, 
			_("invalid immediate"));
	  xtensa_restore_emit_state (&state);
	  return NULL;
	}
    }

  /* Force a 4-byte align here.  Note that this opens a new frag, so all
     literals done with this function have a frag to themselves.  That's
     important for the way text section literals work.  */
  frag_align (litalign, 0, 0);
  record_alignment (now_seg, litalign);

  if (emit_val->X_op == O_pltrel)
    {
      char *p = frag_more (litsize);
      xtensa_set_frag_assembly_state (frag_now);
      if (emit_val->X_add_symbol)
	emit_val->X_op = O_symbol;
      else
	emit_val->X_op = O_constant;
      fix_new_exp (frag_now, p - frag_now->fr_literal,
		   litsize, emit_val, 0, BFD_RELOC_XTENSA_PLT);
    }
  else
    emit_expr (emit_val, litsize);

  assert (frag_now->tc_frag_data.literal_frag == NULL);
  frag_now->tc_frag_data.literal_frag = get_literal_pool_location (now_seg);
  frag_now->fr_symbol = xtensa_create_literal_symbol (now_seg, frag_now);
  lit_sym = frag_now->fr_symbol;
  frag_now->tc_frag_data.is_literal = TRUE;

  /* Go back.  */
  xtensa_restore_emit_state (&state);
  return lit_sym;
}


static void
xg_assemble_literal_space (/* const */ int size, int slot)
{
  emit_state state;
  /* We might have to do something about this alignment.  It only
     takes effect if something is placed here.  */
  offsetT litalign = 2;		/* 2^2 = 4 */
  fragS *lit_saved_frag;

  assert (size % 4 == 0);

  xtensa_switch_to_literal_fragment (&state);

  /* Force a 4-byte align here.  */
  frag_align (litalign, 0, 0);
  record_alignment (now_seg, litalign);

  xg_force_frag_space (size);

  lit_saved_frag = frag_now;
  frag_now->tc_frag_data.literal_frag = get_literal_pool_location (now_seg);
  frag_now->tc_frag_data.is_literal = TRUE;
  frag_now->fr_symbol = xtensa_create_literal_symbol (now_seg, frag_now);
  xg_finish_frag (0, RELAX_LITERAL, 0, size, FALSE);

  /* Go back.  */
  xtensa_restore_emit_state (&state);
  frag_now->tc_frag_data.literal_frags[slot] = lit_saved_frag;
}


/* Put in a fixup record based on the opcode.
   Return TRUE on success.  */

static bfd_boolean
xg_add_opcode_fix (TInsn *tinsn,
		   int opnum,
		   xtensa_format fmt,
		   int slot,
		   expressionS *expr,
		   fragS *fragP,
		   offsetT offset)
{
  xtensa_opcode opcode = tinsn->opcode;
  bfd_reloc_code_real_type reloc;
  reloc_howto_type *howto;
  int fmt_length;
  fixS *the_fix;

  reloc = BFD_RELOC_NONE;

  /* First try the special cases for "alternate" relocs.  */
  if (opcode == xtensa_l32r_opcode)
    {
      if (fragP->tc_frag_data.use_absolute_literals)
	reloc = encode_alt_reloc (slot);
    }
  else if (opcode == xtensa_const16_opcode)
    {
      if (expr->X_op == O_lo16)
	{
	  reloc = encode_reloc (slot);
	  expr->X_op = O_symbol;
	}
      else if (expr->X_op == O_hi16)
	{
	  reloc = encode_alt_reloc (slot);
	  expr->X_op = O_symbol;
	}
    }

  if (opnum != get_relaxable_immed (opcode))
    {
      as_bad (_("invalid relocation for operand %i of '%s'"),
	      opnum, xtensa_opcode_name (xtensa_default_isa, opcode));
      return FALSE;
    }

  /* Handle erroneous "@@h" and "@@l" expressions here before they propagate
     into the symbol table where the generic portions of the assembler
     won't know what to do with them.  */
  if (expr->X_op == O_lo16 || expr->X_op == O_hi16)
    {
      as_bad (_("invalid expression for operand %i of '%s'"),
	      opnum, xtensa_opcode_name (xtensa_default_isa, opcode));
      return FALSE;
    }

  /* Next try the generic relocs.  */
  if (reloc == BFD_RELOC_NONE)
    reloc = encode_reloc (slot);
  if (reloc == BFD_RELOC_NONE)
    {
      as_bad (_("invalid relocation in instruction slot %i"), slot);
      return FALSE;
    }

  howto = bfd_reloc_type_lookup (stdoutput, reloc);
  if (!howto)
    {
      as_bad (_("undefined symbol for opcode \"%s\""),
	      xtensa_opcode_name (xtensa_default_isa, opcode));
      return FALSE;
    }

  fmt_length = xtensa_format_length (xtensa_default_isa, fmt);
  the_fix = fix_new_exp (fragP, offset, fmt_length, expr,
			 howto->pc_relative, reloc);
  the_fix->fx_no_overflow = 1;

  if (expr->X_add_symbol
      && (S_IS_EXTERNAL (expr->X_add_symbol)
	  || S_IS_WEAK (expr->X_add_symbol)))
    the_fix->fx_plt = TRUE;

  the_fix->tc_fix_data.X_add_symbol = expr->X_add_symbol;
  the_fix->tc_fix_data.X_add_number = expr->X_add_number;
  the_fix->tc_fix_data.slot = slot;
  
  return TRUE;
}


static bfd_boolean
xg_emit_insn_to_buf (TInsn *tinsn,
		     xtensa_format fmt,
		     char *buf,
		     fragS *fragP,
		     offsetT offset,
		     bfd_boolean build_fix)
{
  static xtensa_insnbuf insnbuf = NULL;
  bfd_boolean has_symbolic_immed = FALSE;
  bfd_boolean ok = TRUE;
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  has_symbolic_immed = tinsn_to_insnbuf (tinsn, insnbuf);
  if (has_symbolic_immed && build_fix)
    {
      /* Add a fixup.  */
      int opnum = get_relaxable_immed (tinsn->opcode);
      expressionS *exp = &tinsn->tok[opnum];

      if (!xg_add_opcode_fix (tinsn, opnum, fmt, 0, exp, fragP, offset))
	ok = FALSE;
    }
  fragP->tc_frag_data.is_insn = TRUE;
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf, 0);
  return ok;
}


static void
xg_resolve_literals (TInsn *insn, symbolS *lit_sym)
{
  symbolS *sym = get_special_literal_symbol ();
  int i;
  if (lit_sym == 0)
    return;
  assert (insn->insn_type == ITYPE_INSN);
  for (i = 0; i < insn->ntok; i++)
    if (insn->tok[i].X_add_symbol == sym)
      insn->tok[i].X_add_symbol = lit_sym;

}


static void
xg_resolve_labels (TInsn *insn, symbolS *label_sym)
{
  symbolS *sym = get_special_label_symbol ();
  int i;
  /* assert (!insn->is_literal); */
  for (i = 0; i < insn->ntok; i++)
    if (insn->tok[i].X_add_symbol == sym)
      insn->tok[i].X_add_symbol = label_sym;

}


/* Return TRUE if the instruction can write to the specified
   integer register.  */

static bfd_boolean
is_register_writer (const TInsn *insn, const char *regset, int regnum)
{
  int i;
  int num_ops;
  xtensa_isa isa = xtensa_default_isa;

  num_ops = xtensa_opcode_num_operands (isa, insn->opcode);

  for (i = 0; i < num_ops; i++)
    {
      char inout;
      inout = xtensa_operand_inout (isa, insn->opcode, i);
      if ((inout == 'o' || inout == 'm')
	  && xtensa_operand_is_register (isa, insn->opcode, i) == 1)
	{
	  xtensa_regfile opnd_rf =
	    xtensa_operand_regfile (isa, insn->opcode, i);
	  if (!strcmp (xtensa_regfile_shortname (isa, opnd_rf), regset))
	    {
	      if ((insn->tok[i].X_op == O_register)
		  && (insn->tok[i].X_add_number == regnum))
		return TRUE;
	    }
	}
    }
  return FALSE;
}


static bfd_boolean
is_bad_loopend_opcode (const TInsn *tinsn)
{
  xtensa_opcode opcode = tinsn->opcode;

  if (opcode == XTENSA_UNDEFINED)
    return FALSE;

  if (opcode == xtensa_call0_opcode
      || opcode == xtensa_callx0_opcode
      || opcode == xtensa_call4_opcode
      || opcode == xtensa_callx4_opcode
      || opcode == xtensa_call8_opcode
      || opcode == xtensa_callx8_opcode
      || opcode == xtensa_call12_opcode
      || opcode == xtensa_callx12_opcode
      || opcode == xtensa_isync_opcode
      || opcode == xtensa_ret_opcode
      || opcode == xtensa_ret_n_opcode
      || opcode == xtensa_retw_opcode
      || opcode == xtensa_retw_n_opcode
      || opcode == xtensa_waiti_opcode
      || opcode == xtensa_rsr_lcount_opcode)
    return TRUE;
  
  return FALSE;
}


/* Labels that begin with ".Ln" or ".LM"  are unaligned.
   This allows the debugger to add unaligned labels.
   Also, the assembler generates stabs labels that need
   not be aligned:  FAKE_LABEL_NAME . {"F", "L", "endfunc"}.  */

static bfd_boolean
is_unaligned_label (symbolS *sym)
{
  const char *name = S_GET_NAME (sym);
  static size_t fake_size = 0;

  if (name
      && name[0] == '.'
      && name[1] == 'L' && (name[2] == 'n' || name[2] == 'M'))
    return TRUE;

  /* FAKE_LABEL_NAME followed by "F", "L" or "endfunc" */
  if (fake_size == 0)
    fake_size = strlen (FAKE_LABEL_NAME);

  if (name
      && strncmp (FAKE_LABEL_NAME, name, fake_size) == 0
      && (name[fake_size] == 'F'
	  || name[fake_size] == 'L'
	  || (name[fake_size] == 'e'
	      && strncmp ("endfunc", name+fake_size, 7) == 0)))
    return TRUE;

  return FALSE;
}


static fragS *
next_non_empty_frag (const fragS *fragP)
{
  fragS *next_fragP = fragP->fr_next;

  /* Sometimes an empty will end up here due storage allocation issues. 
     So we have to skip until we find something legit.  */
  while (next_fragP && next_fragP->fr_fix == 0)
    next_fragP = next_fragP->fr_next;

  if (next_fragP == NULL || next_fragP->fr_fix == 0)
    return NULL;

  return next_fragP;
}


static bfd_boolean
next_frag_opcode_is_loop (const fragS *fragP, xtensa_opcode *opcode)
{
  xtensa_opcode out_opcode;
  const fragS *next_fragP = next_non_empty_frag (fragP);

  if (next_fragP == NULL)
    return FALSE;

  out_opcode = get_opcode_from_buf (next_fragP->fr_literal, 0);
  if (xtensa_opcode_is_loop (xtensa_default_isa, out_opcode) == 1)
    {
      *opcode = out_opcode;
      return TRUE;
    }
  return FALSE;
}


static int
frag_format_size (const fragS *fragP)
{
  static xtensa_insnbuf insnbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt;
  int fmt_size; 

  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

  if (fragP == NULL)
    return XTENSA_UNDEFINED;

  xtensa_insnbuf_from_chars (isa, insnbuf, fragP->fr_literal, 0);

  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;
  fmt_size = xtensa_format_length (isa, fmt);

  /* If the next format won't be changing due to relaxation, just
     return the length of the first format.  */
  if (fragP->fr_opcode != fragP->fr_literal)
    return fmt_size;

  /* If during relaxation we have to pull an instruction out of a 
     multi-slot instruction, we will return the more conservative
     number.  This works because alignment on bigger instructions
     is more restrictive than alignment on smaller instructions.
     This is more conservative than we would like, but it happens
     infrequently.  */

  if (xtensa_format_num_slots (xtensa_default_isa, fmt) > 1)
    return fmt_size;

  /* If we aren't doing one of our own relaxations or it isn't
     slot-based, then the insn size won't change.  */
  if (fragP->fr_type != rs_machine_dependent)
    return fmt_size;
  if (fragP->fr_subtype != RELAX_SLOTS)
    return fmt_size;

  /* If an instruction is about to grow, return the longer size.  */
  if (fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED_STEP1
      || fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED_STEP2)
    return 3;
  
  if (fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
    return 2 + fragP->tc_frag_data.text_expansion[0];

  return fmt_size;
}


static int
next_frag_format_size (const fragS *fragP)
{
  const fragS *next_fragP = next_non_empty_frag (fragP);
  return frag_format_size (next_fragP);
}


/* If the next legit fragment is an end-of-loop marker,
   switch its state so it will instantiate a NOP.  */

static void
update_next_frag_state (fragS *fragP)
{
  fragS *next_fragP = fragP->fr_next;
  fragS *new_target = NULL;

  if (align_targets) 
    {
      /* We are guaranteed there will be one of these...   */
      while (!(next_fragP->fr_type == rs_machine_dependent
	       && (next_fragP->fr_subtype == RELAX_MAYBE_UNREACHABLE
		   || next_fragP->fr_subtype == RELAX_UNREACHABLE)))
	next_fragP = next_fragP->fr_next;

      assert (next_fragP->fr_type == rs_machine_dependent
	      && (next_fragP->fr_subtype == RELAX_MAYBE_UNREACHABLE
		  || next_fragP->fr_subtype == RELAX_UNREACHABLE));

      /* ...and one of these.  */
      new_target = next_fragP->fr_next;
      while (!(new_target->fr_type == rs_machine_dependent
	       && (new_target->fr_subtype == RELAX_MAYBE_DESIRE_ALIGN
		   || new_target->fr_subtype == RELAX_DESIRE_ALIGN)))
	new_target = new_target->fr_next;

      assert (new_target->fr_type == rs_machine_dependent
	      && (new_target->fr_subtype == RELAX_MAYBE_DESIRE_ALIGN
		  || new_target->fr_subtype == RELAX_DESIRE_ALIGN));
    }

  while (next_fragP && next_fragP->fr_fix == 0)
    {
      if (next_fragP->fr_type == rs_machine_dependent
	  && next_fragP->fr_subtype == RELAX_LOOP_END)
	{
	  next_fragP->fr_subtype = RELAX_LOOP_END_ADD_NOP;
	  return;
	}

      next_fragP = next_fragP->fr_next;
    }
}


static bfd_boolean
next_frag_is_branch_target (const fragS *fragP)
{
  /* Sometimes an empty will end up here due to storage allocation issues,
     so we have to skip until we find something legit.  */
  for (fragP = fragP->fr_next; fragP; fragP = fragP->fr_next)
    {
      if (fragP->tc_frag_data.is_branch_target)
	return TRUE;
      if (fragP->fr_fix != 0)
	break;
    }
  return FALSE;
}


static bfd_boolean
next_frag_is_loop_target (const fragS *fragP)
{
  /* Sometimes an empty will end up here due storage allocation issues. 
     So we have to skip until we find something legit. */
  for (fragP = fragP->fr_next; fragP; fragP = fragP->fr_next)
    {
      if (fragP->tc_frag_data.is_loop_target)
	return TRUE;
      if (fragP->fr_fix != 0)
	break;
    }
  return FALSE;
}


static addressT
next_frag_pre_opcode_bytes (const fragS *fragp)
{
  const fragS *next_fragp = fragp->fr_next;
  xtensa_opcode next_opcode;

  if (!next_frag_opcode_is_loop (fragp, &next_opcode))
    return 0;

  /* Sometimes an empty will end up here due to storage allocation issues,
     so we have to skip until we find something legit.  */
  while (next_fragp->fr_fix == 0)
    next_fragp = next_fragp->fr_next;

  if (next_fragp->fr_type != rs_machine_dependent)
    return 0;

  /* There is some implicit knowledge encoded in here.
     The LOOP instructions that are NOT RELAX_IMMED have
     been relaxed.  Note that we can assume that the LOOP
     instruction is in slot 0 because loops aren't bundleable.  */
  if (next_fragp->tc_frag_data.slot_subtypes[0] > RELAX_IMMED)
      return get_expanded_loop_offset (next_opcode);

  return 0;
}


/* Mark a location where we can later insert literal frags.  Update
   the section's literal_pool_loc, so subsequent literals can be
   placed nearest to their use.  */

static void
xtensa_mark_literal_pool_location (void)
{
  /* Any labels pointing to the current location need
     to be adjusted to after the literal pool.  */
  emit_state s;
  fragS *pool_location;

  if (use_literal_section && !directive_state[directive_absolute_literals])
    return;

  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

  /* We stash info in the fr_var of these frags
     so we can later move the literal's fixes into this
     frchain's fix list.  We can use fr_var because fr_var's
     interpretation depends solely on the fr_type and subtype.  */
  pool_location = frag_now;
  frag_variant (rs_machine_dependent, 0, (int) frchain_now,
		RELAX_LITERAL_POOL_BEGIN, NULL, 0, NULL);
  xtensa_set_frag_assembly_state (frag_now);
  frag_variant (rs_machine_dependent, 0, (int) now_seg,
		RELAX_LITERAL_POOL_END, NULL, 0, NULL);
  xtensa_set_frag_assembly_state (frag_now);

  /* Now put a frag into the literal pool that points to this location.  */
  set_literal_pool_location (now_seg, pool_location);
  xtensa_switch_to_non_abs_literal_fragment (&s);
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

  /* Close whatever frag is there.  */
  frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
  xtensa_set_frag_assembly_state (frag_now);
  frag_now->tc_frag_data.literal_frag = pool_location;
  frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
  xtensa_restore_emit_state (&s);
  xtensa_set_frag_assembly_state (frag_now);
}


/* Build a nop of the correct size into tinsn.  */

static void
build_nop (TInsn *tinsn, int size)
{
  tinsn_init (tinsn);
  switch (size)
    {
    case 2:
      tinsn->opcode = xtensa_nop_n_opcode;
      tinsn->ntok = 0;
      if (tinsn->opcode == XTENSA_UNDEFINED)
	as_fatal (_("opcode 'NOP.N' unavailable in this configuration"));
      break;

    case 3:
      if (xtensa_nop_opcode == XTENSA_UNDEFINED)
	{
	  tinsn->opcode = xtensa_or_opcode;
	  set_expr_const (&tinsn->tok[0], 1);
	  set_expr_const (&tinsn->tok[1], 1);
	  set_expr_const (&tinsn->tok[2], 1);
	  tinsn->ntok = 3;
	}
      else
	tinsn->opcode = xtensa_nop_opcode;

      assert (tinsn->opcode != XTENSA_UNDEFINED);
    }
}


/* Assemble a NOP of the requested size in the buffer.  User must have
   allocated "buf" with at least "size" bytes.  */

static void
assemble_nop (size_t size, char *buf)
{
  static xtensa_insnbuf insnbuf = NULL;
  TInsn tinsn;

  build_nop (&tinsn, size);

  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  tinsn_to_insnbuf (&tinsn, insnbuf);
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf, 0);
}


/* Return the number of bytes for the offset of the expanded loop
   instruction.  This should be incorporated into the relaxation
   specification but is hard-coded here.  This is used to auto-align
   the loop instruction.  It is invalid to call this function if the
   configuration does not have loops or if the opcode is not a loop
   opcode.  */

static addressT
get_expanded_loop_offset (xtensa_opcode opcode)
{
  /* This is the OFFSET of the loop instruction in the expanded loop.
     This MUST correspond directly to the specification of the loop
     expansion.  It will be validated on fragment conversion.  */
  assert (opcode != XTENSA_UNDEFINED);
  if (opcode == xtensa_loop_opcode)
    return 0;
  if (opcode == xtensa_loopnez_opcode)
    return 3;
  if (opcode == xtensa_loopgtz_opcode)
    return 6;
  as_fatal (_("get_expanded_loop_offset: invalid opcode"));
  return 0;
}


static fragS *
get_literal_pool_location (segT seg)
{
  return seg_info (seg)->tc_segment_info_data.literal_pool_loc;
}


static void
set_literal_pool_location (segT seg, fragS *literal_pool_loc)
{
  seg_info (seg)->tc_segment_info_data.literal_pool_loc = literal_pool_loc;
}


/* Set frag assembly state should be called when a new frag is
   opened and after a frag has been closed.  */

static void
xtensa_set_frag_assembly_state (fragS *fragP)
{
  if (!density_supported)
    fragP->tc_frag_data.is_no_density = TRUE;

  /* This function is called from subsegs_finish, which is called
     after xtensa_end, so we can't use "use_transform" or 
     "use_schedule" here.  */
  if (!directive_state[directive_transform])
    fragP->tc_frag_data.is_no_transform = TRUE;
  fragP->tc_frag_data.use_absolute_literals =
    directive_state[directive_absolute_literals];
  fragP->tc_frag_data.is_assembly_state_set = TRUE;
}


static bfd_boolean
relaxable_section (asection *sec)
{
  return (sec->flags & SEC_DEBUGGING) == 0;
}


static void
xtensa_find_unmarked_state_frags (void)
{
  segT *seclist;

  /* Walk over each fragment of all of the current segments.  For each
     unmarked fragment, mark it with the same info as the previous
     fragment.  */
  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segT sec = *seclist;
      segment_info_type *seginfo;
      fragS *fragP;
      flagword flags;
      flags = bfd_get_section_flags (stdoutput, sec);
      if (flags & SEC_DEBUGGING)
	continue;
      if (!(flags & SEC_ALLOC))
	continue;

      seginfo = seg_info (sec);
      if (seginfo && seginfo->frchainP)
	{
	  fragS *last_fragP = 0;
	  for (fragP = seginfo->frchainP->frch_root; fragP;
	       fragP = fragP->fr_next)
	    {
	      if (fragP->fr_fix != 0
		  && !fragP->tc_frag_data.is_assembly_state_set)
		{
		  if (last_fragP == 0)
		    {
		      as_warn_where (fragP->fr_file, fragP->fr_line,
				     _("assembly state not set for first frag in section %s"),
				     sec->name);
		    }
		  else
		    {
		      fragP->tc_frag_data.is_assembly_state_set = TRUE;
		      fragP->tc_frag_data.is_no_density =
			last_fragP->tc_frag_data.is_no_density;
		      fragP->tc_frag_data.is_no_transform =
			last_fragP->tc_frag_data.is_no_transform;
		      fragP->tc_frag_data.use_absolute_literals =
			last_fragP->tc_frag_data.use_absolute_literals;
		    }
		}
	      if (fragP->tc_frag_data.is_assembly_state_set)
		last_fragP = fragP;
	    }
	}
    }
}


static void
xtensa_find_unaligned_branch_targets (bfd *abfd ATTRIBUTE_UNUSED,
				      asection *sec,
				      void *unused ATTRIBUTE_UNUSED)
{
  flagword flags = bfd_get_section_flags (abfd, sec);
  segment_info_type *seginfo = seg_info (sec);
  fragS *frag = seginfo->frchainP->frch_root;
  
  if (flags & SEC_CODE)
    {  
      xtensa_isa isa = xtensa_default_isa;
      xtensa_insnbuf insnbuf = xtensa_insnbuf_alloc (isa);
      while (frag != NULL)
	{
	  if (frag->tc_frag_data.is_branch_target)
	    {
	      int op_size;
	      int frag_addr;
	      xtensa_format fmt;

	      xtensa_insnbuf_from_chars (isa, insnbuf, frag->fr_literal, 0);
	      fmt = xtensa_format_decode (isa, insnbuf);
	      op_size = xtensa_format_length (isa, fmt);
	      frag_addr = frag->fr_address % xtensa_fetch_width;
	      if (frag_addr + op_size > (int) xtensa_fetch_width)
		as_warn_where (frag->fr_file, frag->fr_line,
			       _("unaligned branch target: %d bytes at 0x%lx"),
			       op_size, frag->fr_address);
	    }
	  frag = frag->fr_next;
	}
      xtensa_insnbuf_free (isa, insnbuf);
    }
}


static void
xtensa_find_unaligned_loops (bfd *abfd ATTRIBUTE_UNUSED,
			     asection *sec,
			     void *unused ATTRIBUTE_UNUSED)
{
  flagword flags = bfd_get_section_flags (abfd, sec);
  segment_info_type *seginfo = seg_info (sec);
  fragS *frag = seginfo->frchainP->frch_root;
  xtensa_isa isa = xtensa_default_isa;
  
  if (flags & SEC_CODE)
    {  
      xtensa_insnbuf insnbuf = xtensa_insnbuf_alloc (isa);
      while (frag != NULL)
	{
	  if (frag->tc_frag_data.is_first_loop_insn)
	    {
	      int op_size;
	      int frag_addr;
	      xtensa_format fmt;

	      xtensa_insnbuf_from_chars (isa, insnbuf, frag->fr_literal, 0);
	      fmt = xtensa_format_decode (isa, insnbuf);
	      op_size = xtensa_format_length (isa, fmt);
	      frag_addr = frag->fr_address % xtensa_fetch_width;

	      if (frag_addr + op_size > (signed) xtensa_fetch_width)
		as_warn_where (frag->fr_file, frag->fr_line,
			       _("unaligned loop: %d bytes at 0x%lx"),
			       op_size, frag->fr_address);
	    }
	  frag = frag->fr_next;
	}
      xtensa_insnbuf_free (isa, insnbuf);
    }
}


static void
xg_apply_tentative_value (fixS *fixP, valueT val)
{
  xtensa_isa isa = xtensa_default_isa;
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_format fmt;
  int slot;
  bfd_boolean alt_reloc;
  xtensa_opcode opcode;
  char *const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;

  (void) decode_reloc (fixP->fx_r_type, &slot, &alt_reloc);
  if (alt_reloc)
    as_fatal (_("unexpected fix"));

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  xtensa_insnbuf_from_chars (isa, insnbuf, fixpos, 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    as_fatal (_("undecodable fix"));
  xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
  opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);
  if (opcode == XTENSA_UNDEFINED)
    as_fatal (_("undecodable fix"));

  /* CONST16 immediates are not PC-relative, despite the fact that we
     reuse the normal PC-relative operand relocations for the low part
     of a CONST16 operand.  The code in tc_gen_reloc does not decode
     the opcodes so it is more convenient to detect this special case
     here.  */
  if (opcode == xtensa_const16_opcode)
    return;

  xtensa_insnbuf_set_operand (slotbuf, fmt, slot, opcode,
			      get_relaxable_immed (opcode), val,
			      fixP->fx_file, fixP->fx_line);

  xtensa_format_set_slot (isa, fmt, slot, insnbuf, slotbuf);
  xtensa_insnbuf_to_chars (isa, insnbuf, fixpos, 0);
}


/* External Functions and Other GAS Hooks.  */

const char *
xtensa_target_format (void)
{
  return (target_big_endian ? "elf32-xtensa-be" : "elf32-xtensa-le");
}


void
xtensa_file_arch_init (bfd *abfd)
{
  bfd_set_private_flags (abfd, 0x100 | 0x200);
}


void
md_number_to_chars (char *buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}


/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc. that the MD part of the assembler will
   need.  */

void
md_begin (void)
{
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  xtensa_isa isa;

  xtensa_default_isa = xtensa_isa_init (0, 0);
  isa = xtensa_default_isa;

  linkrelax = 1;

  /* Set up the .literal, .fini.literal and .init.literal sections.  */
  memset (&default_lit_sections, 0, sizeof (default_lit_sections));
  default_lit_sections.init_lit_seg_name = INIT_LITERAL_SECTION_NAME;
  default_lit_sections.fini_lit_seg_name = FINI_LITERAL_SECTION_NAME;
  default_lit_sections.lit_seg_name = LITERAL_SECTION_NAME;
  default_lit_sections.lit4_seg_name = LIT4_SECTION_NAME;

  subseg_set (current_section, current_subsec);

  xg_init_vinsn (&cur_vinsn);

  xtensa_addi_opcode = xtensa_opcode_lookup (isa, "addi");
  xtensa_addmi_opcode = xtensa_opcode_lookup (isa, "addmi");
  xtensa_call0_opcode = xtensa_opcode_lookup (isa, "call0");
  xtensa_call4_opcode = xtensa_opcode_lookup (isa, "call4");
  xtensa_call8_opcode = xtensa_opcode_lookup (isa, "call8");
  xtensa_call12_opcode = xtensa_opcode_lookup (isa, "call12");
  xtensa_callx0_opcode = xtensa_opcode_lookup (isa, "callx0");
  xtensa_callx4_opcode = xtensa_opcode_lookup (isa, "callx4");
  xtensa_callx8_opcode = xtensa_opcode_lookup (isa, "callx8");
  xtensa_callx12_opcode = xtensa_opcode_lookup (isa, "callx12");
  xtensa_const16_opcode = xtensa_opcode_lookup (isa, "const16");
  xtensa_entry_opcode = xtensa_opcode_lookup (isa, "entry");
  xtensa_movi_opcode = xtensa_opcode_lookup (isa, "movi");
  xtensa_movi_n_opcode = xtensa_opcode_lookup (isa, "movi.n");
  xtensa_isync_opcode = xtensa_opcode_lookup (isa, "isync");
  xtensa_jx_opcode = xtensa_opcode_lookup (isa, "jx");
  xtensa_l32r_opcode = xtensa_opcode_lookup (isa, "l32r");
  xtensa_loop_opcode = xtensa_opcode_lookup (isa, "loop");
  xtensa_loopnez_opcode = xtensa_opcode_lookup (isa, "loopnez");
  xtensa_loopgtz_opcode = xtensa_opcode_lookup (isa, "loopgtz");
  xtensa_nop_opcode = xtensa_opcode_lookup (isa, "nop");
  xtensa_nop_n_opcode = xtensa_opcode_lookup (isa, "nop.n");
  xtensa_or_opcode = xtensa_opcode_lookup (isa, "or");
  xtensa_ret_opcode = xtensa_opcode_lookup (isa, "ret");
  xtensa_ret_n_opcode = xtensa_opcode_lookup (isa, "ret.n");
  xtensa_retw_opcode = xtensa_opcode_lookup (isa, "retw");
  xtensa_retw_n_opcode = xtensa_opcode_lookup (isa, "retw.n");
  xtensa_rsr_lcount_opcode = xtensa_opcode_lookup (isa, "rsr.lcount");
  xtensa_waiti_opcode = xtensa_opcode_lookup (isa, "waiti");

  init_op_placement_info_table ();

  /* Set up the assembly state.  */
  if (!frag_now->tc_frag_data.is_assembly_state_set)
    xtensa_set_frag_assembly_state (frag_now);
}


/* TC_INIT_FIX_DATA hook */

void
xtensa_init_fix_data (fixS *x)
{
  x->tc_fix_data.slot = 0;
  x->tc_fix_data.X_add_symbol = NULL;
  x->tc_fix_data.X_add_number = 0;
}


/* tc_frob_label hook */

void
xtensa_frob_label (symbolS *sym)
{
  /* Since the label was already attached to a frag associated with the
     previous basic block, it now needs to be reset to the current frag.  */
  symbol_set_frag (sym, frag_now);
  S_SET_VALUE (sym, (valueT) frag_now_fix ());

  if (generating_literals)
    xtensa_add_literal_sym (sym);
  else
    xtensa_add_insn_label (sym);

  if (symbol_get_tc (sym)->is_loop_target
      && (get_last_insn_flags (now_seg, now_subseg)
	  & FLAG_IS_BAD_LOOPEND) != 0)
    as_bad (_("invalid last instruction for a zero-overhead loop"));

  /* No target aligning in the absolute section.  */
  if (now_seg != absolute_section
      && do_align_targets ()
      && !is_unaligned_label (sym)
      && !generating_literals)
    {
      float freq = get_subseg_target_freq (now_seg, now_subseg);
      xtensa_set_frag_assembly_state (frag_now);

      /* The only time this type of frag grows is when there is a
	 negatable branch that needs to be relaxed as the last
	 instruction in a zero-overhead loop.  Because alignment frags
	 are so common, marking them all as possibly growing four
	 bytes makes any worst-case analysis appear much worse than it
	 is.  So, we make fr_var not actually reflect the amount of
	 memory allocated at the end of this frag, but rather the
	 amount of memory this frag might grow.  The "4, 0" below
	 allocates four bytes at the end of the frag for room to grow
	 if we need to relax a loop end with a NOP.  Frags prior to
	 this one might grow to align this one, but the frag itself
	 won't grow unless it meets the condition above.  */

#define RELAX_LOOP_END_BYTES 4

      frag_var (rs_machine_dependent,
		RELAX_LOOP_END_BYTES, (int) freq,
		RELAX_DESIRE_ALIGN_IF_TARGET,
		frag_now->fr_symbol, frag_now->fr_offset, NULL);
      xtensa_set_frag_assembly_state (frag_now);
      xtensa_move_labels (frag_now, 0, TRUE);
    }

  /* We need to mark the following properties even if we aren't aligning.  */

  /* If the label is already known to be a branch target, i.e., a
     forward branch, mark the frag accordingly.  Backward branches
     are handled by xg_add_branch_and_loop_targets.  */
  if (symbol_get_tc (sym)->is_branch_target)
    symbol_get_frag (sym)->tc_frag_data.is_branch_target = TRUE;

  /* Loops only go forward, so they can be identified here.  */
  if (symbol_get_tc (sym)->is_loop_target)
    symbol_get_frag (sym)->tc_frag_data.is_loop_target = TRUE;
}


/* tc_unrecognized_line hook */

int
xtensa_unrecognized_line (int ch)
{
  switch (ch)
    {
    case '{' :
      if (cur_vinsn.inside_bundle == 0)
	{
	  /* PR8110: Cannot emit line number info inside a FLIX bundle
	     when using --gstabs.  Temporarily disable debug info.  */
	  generate_lineno_debug ();
	  if (debug_type == DEBUG_STABS)
	    {
	      xt_saved_debug_type = debug_type;
	      debug_type = DEBUG_NONE;
	    }

	  cur_vinsn.inside_bundle = 1;
	}
      else
	{
	  as_bad (_("extra opening brace"));
	  return 0;
	}
      break;

    case '}' :
      if (cur_vinsn.inside_bundle)
	finish_vinsn (&cur_vinsn);
      else
	{
	  as_bad (_("extra closing brace"));
	  return 0;
	}
      break;
    default:
      as_bad (_("syntax error"));
      return 0;
    }
  return 1;
}


/* md_flush_pending_output hook */

void
xtensa_flush_pending_output (void)
{
  if (cur_vinsn.inside_bundle)
    as_bad (_("missing closing brace"));

  /* If there is a non-zero instruction fragment, close it.  */
  if (frag_now_fix () != 0 && frag_now->tc_frag_data.is_insn)
    {
      frag_wane (frag_now);
      frag_new (0);
      xtensa_set_frag_assembly_state (frag_now);
    }
  frag_now->tc_frag_data.is_insn = FALSE;

  xtensa_clear_insn_labels ();
}


/* We had an error while parsing an instruction.  The string might look
   like this: "insn arg1, arg2 }".  If so, we need to see the closing
   brace and reset some fields.  Otherwise, the vinsn never gets closed
   and the num_slots field will grow past the end of the array of slots,
   and bad things happen.  */

static void
error_reset_cur_vinsn (void)
{
  if (cur_vinsn.inside_bundle)
    {
      if (*input_line_pointer == '}'
	  || *(input_line_pointer - 1) == '}'
	  || *(input_line_pointer - 2) == '}')
	xg_clear_vinsn (&cur_vinsn);
    }
}


void
md_assemble (char *str)
{
  xtensa_isa isa = xtensa_default_isa;
  char *opname;
  unsigned opnamelen;
  bfd_boolean has_underbar = FALSE;
  char *arg_strings[MAX_INSN_ARGS];
  int num_args;
  TInsn orig_insn;		/* Original instruction from the input.  */

  tinsn_init (&orig_insn);

  /* Split off the opcode.  */
  opnamelen = strspn (str, "abcdefghijklmnopqrstuvwxyz_/0123456789.");
  opname = xmalloc (opnamelen + 1);
  memcpy (opname, str, opnamelen);
  opname[opnamelen] = '\0';

  num_args = tokenize_arguments (arg_strings, str + opnamelen);
  if (num_args == -1)
    {
      as_bad (_("syntax error"));
      return;
    }

  if (xg_translate_idioms (&opname, &num_args, arg_strings))
    return;

  /* Check for an underbar prefix.  */
  if (*opname == '_')
    {
      has_underbar = TRUE;
      opname += 1;
    }

  orig_insn.insn_type = ITYPE_INSN;
  orig_insn.ntok = 0;
  orig_insn.is_specific_opcode = (has_underbar || !use_transform ());

  orig_insn.opcode = xtensa_opcode_lookup (isa, opname);
  if (orig_insn.opcode == XTENSA_UNDEFINED)
    {
      xtensa_format fmt = xtensa_format_lookup (isa, opname);
      if (fmt == XTENSA_UNDEFINED)
	{
	  as_bad (_("unknown opcode or format name '%s'"), opname);
	  error_reset_cur_vinsn ();
	  return;
	}
      if (!cur_vinsn.inside_bundle)
	{
	  as_bad (_("format names only valid inside bundles"));
	  error_reset_cur_vinsn ();
	  return;
	}
      if (cur_vinsn.format != XTENSA_UNDEFINED)
	as_warn (_("multiple formats specified for one bundle; using '%s'"),
		 opname);
      cur_vinsn.format = fmt;
      free (has_underbar ? opname - 1 : opname);
      error_reset_cur_vinsn ();
      return;
    }

  /* Special case: The call instructions should be marked "specific opcode"
     to keep them from expanding.  */
  if (!use_longcalls () && is_direct_call_opcode (orig_insn.opcode))
    orig_insn.is_specific_opcode = TRUE;

  /* Parse the arguments.  */
  if (parse_arguments (&orig_insn, num_args, arg_strings))
    {
      as_bad (_("syntax error"));
      error_reset_cur_vinsn ();
      return;
    }

  /* Free the opcode and argument strings, now that they've been parsed.  */
  free (has_underbar ? opname - 1 : opname);
  opname = 0;
  while (num_args-- > 0)
    free (arg_strings[num_args]);

  /* Get expressions for invisible operands.  */
  if (get_invisible_operands (&orig_insn))
    {
      error_reset_cur_vinsn ();
      return;
    }

  /* Check for the right number and type of arguments.  */
  if (tinsn_check_arguments (&orig_insn))
    {
      error_reset_cur_vinsn ();
      return;
    }

  dwarf2_where (&orig_insn.loc);
  
  xg_add_branch_and_loop_targets (&orig_insn);

  /* Special-case for "entry" instruction.  */
  if (orig_insn.opcode == xtensa_entry_opcode)
    {
      /* Check that the third opcode (#2) is >= 16.  */
      if (orig_insn.ntok >= 3)
	{
	  expressionS *exp = &orig_insn.tok[2];
	  switch (exp->X_op)
	    {
	    case O_constant:
	      if (exp->X_add_number < 16)
		as_warn (_("entry instruction with stack decrement < 16"));
	      break;

	    default:
	      as_warn (_("entry instruction with non-constant decrement"));
	    }
	}
    }

  /* Finish it off:
     assemble_tokens (opcode, tok, ntok);
     expand the tokens from the orig_insn into the
     stack of instructions that will not expand
     unless required at relaxation time.  */

  if (!cur_vinsn.inside_bundle)
    emit_single_op (&orig_insn);
  else /* We are inside a bundle.  */
    {
      cur_vinsn.slots[cur_vinsn.num_slots] = orig_insn;
      cur_vinsn.num_slots++;
      if (*input_line_pointer == '}'
	  || *(input_line_pointer - 1) == '}'
	  || *(input_line_pointer - 2) == '}')
	finish_vinsn (&cur_vinsn);
    }

  /* We've just emitted a new instruction so clear the list of labels.  */
  xtensa_clear_insn_labels ();
}


/* HANDLE_ALIGN hook */

/* For a .align directive, we mark the previous block with the alignment
   information.  This will be placed in the object file in the
   property section corresponding to this section.  */

void
xtensa_handle_align (fragS *fragP)
{
  if (linkrelax
      && ! fragP->tc_frag_data.is_literal
      && (fragP->fr_type == rs_align
	  || fragP->fr_type == rs_align_code)
      && fragP->fr_address + fragP->fr_fix > 0
      && fragP->fr_offset > 0
      && now_seg != bss_section)
    {
      fragP->tc_frag_data.is_align = TRUE;
      fragP->tc_frag_data.alignment = fragP->fr_offset;
    }

  if (fragP->fr_type == rs_align_test)
    {
      int count;
      count = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
      if (count != 0)
	as_bad_where (fragP->fr_file, fragP->fr_line, 
		      _("unaligned entry instruction"));
    }
}


/* TC_FRAG_INIT hook */

void
xtensa_frag_init (fragS *frag)
{
  xtensa_set_frag_assembly_state (frag);
}


symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return NULL;
}


/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
{
  return size;			/* Byte alignment is fine.  */
}


long
md_pcrel_from (fixS *fixP)
{
  char *insn_p;
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  int opnum;
  uint32 opnd_value;
  xtensa_opcode opcode;
  xtensa_format fmt;
  int slot;
  xtensa_isa isa = xtensa_default_isa;
  valueT addr = fixP->fx_where + fixP->fx_frag->fr_address;
  bfd_boolean alt_reloc;

  if (fixP->fx_done)
    return addr;

  if (fixP->fx_r_type == BFD_RELOC_XTENSA_ASM_EXPAND)
    return addr;

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  insn_p = &fixP->fx_frag->fr_literal[fixP->fx_where];
  xtensa_insnbuf_from_chars (isa, insnbuf, insn_p, 0);
  fmt = xtensa_format_decode (isa, insnbuf);

  if (fmt == XTENSA_UNDEFINED)
    as_fatal (_("bad instruction format"));

  if (decode_reloc (fixP->fx_r_type, &slot, &alt_reloc) != 0)
    as_fatal (_("invalid relocation"));

  xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
  opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);

  /* Check for "alternate" relocation (operand not specified).  */
  if (alt_reloc || opcode == xtensa_const16_opcode)
    {
      if (opcode != xtensa_l32r_opcode
	  && opcode != xtensa_const16_opcode)
	as_fatal (_("invalid relocation for '%s' instruction"),
		  xtensa_opcode_name (isa, opcode));
      return addr;
    }

  opnum = get_relaxable_immed (opcode);
  opnd_value = 0;
  if (xtensa_operand_is_PCrelative (isa, opcode, opnum) != 1
      || xtensa_operand_do_reloc (isa, opcode, opnum, &opnd_value, addr))
    {
      as_bad_where (fixP->fx_file,
		    fixP->fx_line,
		    _("invalid relocation for operand %d of '%s'"),
		    opnum, xtensa_opcode_name (isa, opcode));
      return addr;
    }
  return 0 - opnd_value;
}


/* TC_FORCE_RELOCATION hook */

int
xtensa_force_relocation (fixS *fix)
{
  switch (fix->fx_r_type)
   {
    case BFD_RELOC_XTENSA_SLOT0_ALT:
    case BFD_RELOC_XTENSA_SLOT1_ALT:
    case BFD_RELOC_XTENSA_SLOT2_ALT:
    case BFD_RELOC_XTENSA_SLOT3_ALT:
    case BFD_RELOC_XTENSA_SLOT4_ALT:
    case BFD_RELOC_XTENSA_SLOT5_ALT:
    case BFD_RELOC_XTENSA_SLOT6_ALT:
    case BFD_RELOC_XTENSA_SLOT7_ALT:
    case BFD_RELOC_XTENSA_SLOT8_ALT:
    case BFD_RELOC_XTENSA_SLOT9_ALT:
    case BFD_RELOC_XTENSA_SLOT10_ALT:
    case BFD_RELOC_XTENSA_SLOT11_ALT:
    case BFD_RELOC_XTENSA_SLOT12_ALT:
    case BFD_RELOC_XTENSA_SLOT13_ALT:
    case BFD_RELOC_XTENSA_SLOT14_ALT:
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      return 1;
    default:
      break;
    }

  if (linkrelax && fix->fx_addsy
      && relaxable_section (S_GET_SEGMENT (fix->fx_addsy)))
    return 1;

  return generic_force_reloc (fix);
}


/* NO_PSEUDO_DOT hook */

/* This function has nothing to do with pseudo dots, but this is the
   nearest macro to where the check needs to take place.  FIXME: This
   seems wrong.  */

bfd_boolean
xtensa_check_inside_bundle (void)
{
  if (cur_vinsn.inside_bundle && input_line_pointer[-1] == '.')
    as_bad (_("directives are not valid inside bundles"));

  /* This function must always return FALSE because it is called via a
     macro that has nothing to do with bundling.  */
  return FALSE;
}


/* md_elf_section_change_hook */

void
xtensa_elf_section_change_hook (void)
{
  /* Set up the assembly state.  */
  if (!frag_now->tc_frag_data.is_assembly_state_set)
    xtensa_set_frag_assembly_state (frag_now);
}


/* tc_fix_adjustable hook */

bfd_boolean
xtensa_fix_adjustable (fixS *fixP)
{
  /* An offset is not allowed in combination with the difference of two
     symbols, but that cannot be easily detected after a local symbol
     has been adjusted to a (section+offset) form.  Return 0 so that such
     an fix will not be adjusted.  */
  if (fixP->fx_subsy && fixP->fx_addsy && fixP->fx_offset
      && relaxable_section (S_GET_SEGMENT (fixP->fx_subsy)))
    return 0;

  /* We need the symbol name for the VTABLE entries.  */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  if (fixP->fx_addsy
      && (S_IS_EXTERNAL (fixP->fx_addsy) || S_IS_WEAK (fixP->fx_addsy)))
    return 0;

#if 0
  /* We may someday want to enable this code to preserve relocations for
     non-PC-relative fixes, possibly under control of a PIC flag.  */
  return (fixP->fx_pcrel
	  || (fixP->fx_subsy != NULL
	      && (S_GET_SEGMENT (fixP->fx_subsy)
		  == S_GET_SEGMENT (fixP->fx_addsy)))
	  || S_IS_LOCAL (fixP->fx_addsy));
#else
  return 1;
#endif
}


void
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
    {
      char *const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;

      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_XTENSA_ASM_EXPAND:
	  fixP->fx_done = 1;
	  break;

	case BFD_RELOC_XTENSA_ASM_SIMPLIFY:
	  as_bad (_("unhandled local relocation fix %s"),
		  bfd_get_reloc_code_name (fixP->fx_r_type));
	  break;

	case BFD_RELOC_32:
	case BFD_RELOC_16:
	case BFD_RELOC_8:
	  /* The only one we support that isn't an instruction field.  */
	  md_number_to_chars (fixpos, *valP, fixP->fx_size);
	  fixP->fx_done = 1;
	  break;

	case BFD_RELOC_VTABLE_INHERIT:
	case BFD_RELOC_VTABLE_ENTRY:
	  fixP->fx_done = 0;
	  break;

	default:
	  as_bad (_("unhandled local relocation fix %s"),
		  bfd_get_reloc_code_name (fixP->fx_r_type));
	}
    }
}


char *
md_atof (int type, char *litP, int *sizeP)
{
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizeP = 0;
      return "bad call to md_atof";
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * 2;

  for (i = prec - 1; i >= 0; i--)
    {
      int idx = i;
      if (target_big_endian)
	idx = (prec - 1 - i);

      md_number_to_chars (litP, (valueT) words[idx], 2);
      litP += 2;
    }

  return NULL;
}


int
md_estimate_size_before_relax (fragS *fragP, segT seg ATTRIBUTE_UNUSED)
{
  return total_frag_text_expansion (fragP);
}


/* Translate internal representation of relocation info to BFD target
   format.  */

arelent *
tc_gen_reloc (asection *section, fixS *fixp)
{
  arelent *reloc;
  bfd_boolean apply_tentative_value = FALSE;

  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  /* Make sure none of our internal relocations make it this far.
     They'd better have been fully resolved by this point.  */
  assert ((int) fixp->fx_r_type > 0);

  if (linkrelax && fixp->fx_subsy
      && (fixp->fx_r_type == BFD_RELOC_8
	  || fixp->fx_r_type == BFD_RELOC_16
	  || fixp->fx_r_type == BFD_RELOC_32))
    {
      int diff_size = 0;
      bfd_vma diff_value, diff_mask = 0;

      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_8:
	  fixp->fx_r_type = BFD_RELOC_XTENSA_DIFF8;
	  diff_size = 1;
	  diff_mask = 0xff;
	  break;
	case BFD_RELOC_16:
	  fixp->fx_r_type = BFD_RELOC_XTENSA_DIFF16;
	  diff_size = 2;
	  diff_mask = 0xffff;
	  break;
	case BFD_RELOC_32:
	  fixp->fx_r_type = BFD_RELOC_XTENSA_DIFF32;
	  diff_size = 4;
	  diff_mask = 0xffffffff;
	  break;
	default:
	  break;
	}

      /* An offset is only allowed when it results from adjusting a local
	 symbol into a section-relative offset.  If the offset came from the
	 original expression, tc_fix_adjustable will have prevented the fix
	 from being converted to a section-relative form so that we can flag
	 the error here.  */
      if (fixp->fx_offset != 0 && !symbol_section_p (fixp->fx_addsy))
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("cannot represent subtraction with an offset"));
	  free (reloc->sym_ptr_ptr);
	  free (reloc);
	  return NULL;
	}

      assert (S_GET_SEGMENT (fixp->fx_addsy)
	      == S_GET_SEGMENT (fixp->fx_subsy));

      diff_value = (S_GET_VALUE (fixp->fx_addsy) + fixp->fx_offset
		    - S_GET_VALUE (fixp->fx_subsy));

      /* Check for overflow.  */
      if ((diff_value & ~diff_mask) != 0)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("value of %ld too large"), diff_value);
	  free (reloc->sym_ptr_ptr);
	  free (reloc);
	  return NULL;
	}

      md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
			  diff_value, diff_size);
      reloc->addend = fixp->fx_offset - diff_value;
    }
  else
    {
      reloc->addend = fixp->fx_offset;

      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_XTENSA_SLOT0_OP:
	case BFD_RELOC_XTENSA_SLOT1_OP:
	case BFD_RELOC_XTENSA_SLOT2_OP:
	case BFD_RELOC_XTENSA_SLOT3_OP:
	case BFD_RELOC_XTENSA_SLOT4_OP:
	case BFD_RELOC_XTENSA_SLOT5_OP:
	case BFD_RELOC_XTENSA_SLOT6_OP:
	case BFD_RELOC_XTENSA_SLOT7_OP:
	case BFD_RELOC_XTENSA_SLOT8_OP:
	case BFD_RELOC_XTENSA_SLOT9_OP:
	case BFD_RELOC_XTENSA_SLOT10_OP:
	case BFD_RELOC_XTENSA_SLOT11_OP:
	case BFD_RELOC_XTENSA_SLOT12_OP:
	case BFD_RELOC_XTENSA_SLOT13_OP:
	case BFD_RELOC_XTENSA_SLOT14_OP:
	  /* As a special case, the immediate value for a CONST16 opcode
	     should not be applied, since this kind of relocation is
	     handled specially for CONST16 and is not really PC-relative.
	     Rather than decode the opcode here, just wait and handle it
	     in xg_apply_tentative_value.  */
	  apply_tentative_value = TRUE;
	  break;

	case BFD_RELOC_XTENSA_SLOT0_ALT:
	case BFD_RELOC_XTENSA_SLOT1_ALT:
	case BFD_RELOC_XTENSA_SLOT2_ALT:
	case BFD_RELOC_XTENSA_SLOT3_ALT:
	case BFD_RELOC_XTENSA_SLOT4_ALT:
	case BFD_RELOC_XTENSA_SLOT5_ALT:
	case BFD_RELOC_XTENSA_SLOT6_ALT:
	case BFD_RELOC_XTENSA_SLOT7_ALT:
	case BFD_RELOC_XTENSA_SLOT8_ALT:
	case BFD_RELOC_XTENSA_SLOT9_ALT:
	case BFD_RELOC_XTENSA_SLOT10_ALT:
	case BFD_RELOC_XTENSA_SLOT11_ALT:
	case BFD_RELOC_XTENSA_SLOT12_ALT:
	case BFD_RELOC_XTENSA_SLOT13_ALT:
	case BFD_RELOC_XTENSA_SLOT14_ALT:
	case BFD_RELOC_XTENSA_ASM_EXPAND:
	case BFD_RELOC_32:
	case BFD_RELOC_XTENSA_PLT:
	case BFD_RELOC_VTABLE_INHERIT:
	case BFD_RELOC_VTABLE_ENTRY:
	  break;

	case BFD_RELOC_XTENSA_ASM_SIMPLIFY:
	  as_warn (_("emitting simplification relocation"));
	  break;

	default:
	  as_warn (_("emitting unknown relocation"));
	}
    }

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent `%s' relocation in object file"),
		    bfd_get_reloc_code_name (fixp->fx_r_type));
      free (reloc->sym_ptr_ptr);
      free (reloc);
      return NULL;
    }

  if (!fixp->fx_pcrel != !reloc->howto->pc_relative)
    as_fatal (_("internal error? cannot generate `%s' relocation"),
	      bfd_get_reloc_code_name (fixp->fx_r_type));

  /* Write the tentative value of a PC-relative relocation to a local symbol
     into the instruction.  The value will be ignored by the linker, and it
     makes the object file disassembly readable when the linkrelax flag is
     set and all branch targets are encoded in relocations.  */

  if (linkrelax && apply_tentative_value && fixp->fx_pcrel)
    {
      valueT val;
      assert (fixp->fx_addsy);
      if (S_GET_SEGMENT (fixp->fx_addsy) == section && !fixp->fx_plt
	  && !S_FORCE_RELOC (fixp->fx_addsy, 1))
	{
	  val = (S_GET_VALUE (fixp->fx_addsy) + fixp->fx_offset
		 - md_pcrel_from (fixp));
	  xg_apply_tentative_value (fixp, val);
	}
    }

  return reloc;
}


/* Checks for resource conflicts between instructions.  */

/* The func unit stuff could be implemented as bit-vectors rather 
   than the iterative approach here.  If it ends up being too 
   slow, we will switch it.  */

resource_table * 
new_resource_table (void *data,
		    int cycles,
		    int nu,
		    unit_num_copies_func uncf,
		    opcode_num_units_func onuf,
		    opcode_funcUnit_use_unit_func ouuf,
		    opcode_funcUnit_use_stage_func ousf)
{
  int i;
  resource_table *rt = (resource_table *) xmalloc (sizeof (resource_table));
  rt->data = data;
  rt->cycles = cycles;
  rt->allocated_cycles = cycles;
  rt->num_units = nu;
  rt->unit_num_copies = uncf;
  rt->opcode_num_units = onuf;
  rt->opcode_unit_use = ouuf;
  rt->opcode_unit_stage = ousf;

  rt->units = (char **) xcalloc (cycles, sizeof (char *));
  for (i = 0; i < cycles; i++)
    rt->units[i] = (char *) xcalloc (nu, sizeof (char));

  return rt;
}


void 
clear_resource_table (resource_table *rt)
{
  int i, j;
  for (i = 0; i < rt->allocated_cycles; i++)
    for (j = 0; j < rt->num_units; j++)
      rt->units[i][j] = 0;
}


/* We never shrink it, just fake it into thinking so.  */

void 
resize_resource_table (resource_table *rt, int cycles)
{
  int i, old_cycles;

  rt->cycles = cycles;
  if (cycles <= rt->allocated_cycles)
    return;

  old_cycles = rt->allocated_cycles;
  rt->allocated_cycles = cycles;

  rt->units = xrealloc (rt->units, sizeof (char *) * rt->allocated_cycles);
  for (i = 0; i < old_cycles; i++)
    rt->units[i] = xrealloc (rt->units[i], sizeof (char) * rt->num_units);
  for (i = old_cycles; i < cycles; i++)
    rt->units[i] = xcalloc (rt->num_units, sizeof (char));
}


bfd_boolean 
resources_available (resource_table *rt, xtensa_opcode opcode, int cycle)
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++) 
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      int copies_in_use = rt->units[stage + cycle][unit];
      int copies = (rt->unit_num_copies) (rt->data, unit);
      if (copies_in_use >= copies)
	return FALSE;
    }
  return TRUE;
}
     

void 
reserve_resources (resource_table *rt, xtensa_opcode opcode, int cycle)
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++) 
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      /* Note that this allows resources to be oversubscribed.  That's 
	 essential to the way the optional scheduler works. 
	 resources_available reports when a resource is over-subscribed,
	 so it's easy to tell.  */
      rt->units[stage + cycle][unit]++;
    }
}


void 
release_resources (resource_table *rt, xtensa_opcode opcode, int cycle)
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++) 
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      rt->units[stage + cycle][unit]--;
      assert (rt->units[stage + cycle][unit] >= 0);
    }
}
     

/* Wrapper functions make parameterized resource reservation
   more convenient.  */

int 
opcode_funcUnit_use_unit (void *data, xtensa_opcode opcode, int idx)
{
  xtensa_funcUnit_use *use = xtensa_opcode_funcUnit_use (data, opcode, idx);
  return use->unit;  
}


int 
opcode_funcUnit_use_stage (void *data, xtensa_opcode opcode, int idx)
{
  xtensa_funcUnit_use *use = xtensa_opcode_funcUnit_use (data, opcode, idx);
  return use->stage;
}


/* Note that this function does not check issue constraints, but
   solely whether the hardware is available to execute the given
   instructions together.  It also doesn't check if the tinsns 
   write the same state, or access the same tieports.  That is
   checked by check_t1_t2_reads_and_writes.  */

static bfd_boolean
resources_conflict (vliw_insn *vinsn)
{
  int i;
  static resource_table *rt = NULL;

  /* This is the most common case by far.  Optimize it.  */
  if (vinsn->num_slots == 1)
    return FALSE;

  if (rt == NULL) 
    {
      xtensa_isa isa = xtensa_default_isa;
      rt = new_resource_table
	(isa, xtensa_isa_num_pipe_stages (isa),
	 xtensa_isa_num_funcUnits (isa),
	 (unit_num_copies_func) xtensa_funcUnit_num_copies,
	 (opcode_num_units_func) xtensa_opcode_num_funcUnit_uses,
	 opcode_funcUnit_use_unit,
	 opcode_funcUnit_use_stage);
    }

  clear_resource_table (rt);

  for (i = 0; i < vinsn->num_slots; i++)
    {
      if (!resources_available (rt, vinsn->slots[i].opcode, 0))
	return TRUE;
      reserve_resources (rt, vinsn->slots[i].opcode, 0);
    }

  return FALSE;
}


/* finish_vinsn, emit_single_op and helper functions.  */

static bfd_boolean find_vinsn_conflicts (vliw_insn *);
static xtensa_format xg_find_narrowest_format (vliw_insn *);
static void bundle_single_op (TInsn *);
static void xg_assemble_vliw_tokens (vliw_insn *);


/* We have reached the end of a bundle; emit into the frag.  */

static void
finish_vinsn (vliw_insn *vinsn)
{
  IStack slotstack;
  int i;
  char *file_name;
  int line;

  if (find_vinsn_conflicts (vinsn))
    {
      xg_clear_vinsn (vinsn);
      return;
    }

  /* First, find a format that works.  */
  if (vinsn->format == XTENSA_UNDEFINED)
    vinsn->format = xg_find_narrowest_format (vinsn);

  if (vinsn->format == XTENSA_UNDEFINED)
    {
      as_where (&file_name, &line);
      as_bad_where (file_name, line,
		    _("couldn't find a valid instruction format"));
      fprintf (stderr, _("    ops were: "));
      for (i = 0; i < vinsn->num_slots; i++)
	fprintf (stderr, _(" %s;"),
		 xtensa_opcode_name (xtensa_default_isa,
				     vinsn->slots[i].opcode));
      fprintf (stderr, _("\n"));
      xg_clear_vinsn (vinsn);
      return;
    }

  if (vinsn->num_slots
      != xtensa_format_num_slots (xtensa_default_isa, vinsn->format))
    {
      as_bad (_("format '%s' allows %d slots, but there are %d opcodes"),
	      xtensa_format_name (xtensa_default_isa, vinsn->format),
	      xtensa_format_num_slots (xtensa_default_isa, vinsn->format),
	      vinsn->num_slots);
      xg_clear_vinsn (vinsn);
      return;
    }

  if (resources_conflict (vinsn)) 
    {
      as_where (&file_name, &line);
      as_bad_where (file_name, line, _("illegal resource usage in bundle"));
      fprintf (stderr, "    ops were: ");
      for (i = 0; i < vinsn->num_slots; i++)
	fprintf (stderr, " %s;",
		 xtensa_opcode_name (xtensa_default_isa,
				     vinsn->slots[i].opcode));
      fprintf (stderr, "\n");
      xg_clear_vinsn (vinsn);
      return;
    }

  for (i = 0; i < vinsn->num_slots; i++)
    {
      if (vinsn->slots[i].opcode != XTENSA_UNDEFINED)
	{
	  symbolS *lit_sym = NULL;
	  int j;
	  bfd_boolean e = FALSE;
	  bfd_boolean saved_density = density_supported;

	  /* We don't want to narrow ops inside multi-slot bundles.  */
	  if (vinsn->num_slots > 1)
	    density_supported = FALSE;

	  istack_init (&slotstack);
	  if (vinsn->slots[i].opcode == xtensa_nop_opcode)
	    {
	      vinsn->slots[i].opcode =
		xtensa_format_slot_nop_opcode (xtensa_default_isa,
					       vinsn->format, i);
	      vinsn->slots[i].ntok = 0;
	    }

	  if (xg_expand_assembly_insn (&slotstack, &vinsn->slots[i]))
	    {
	      e = TRUE;
	      continue;
	    }

	  density_supported = saved_density;

	  if (e)
	    {
	      xg_clear_vinsn (vinsn);
	      return;
	    }

	  for (j = 0; j < slotstack.ninsn - 1; j++)
	    {
	      TInsn *insn = &slotstack.insn[j];
	      if (insn->insn_type == ITYPE_LITERAL)
		{
		  assert (lit_sym == NULL);
		  lit_sym = xg_assemble_literal (insn);
		}
	      else
		{
		  if (lit_sym)
		    xg_resolve_literals (insn, lit_sym);
		  emit_single_op (insn);
		}
	    }

	  if (vinsn->num_slots > 1)
	    {
	      if (opcode_fits_format_slot
		  (slotstack.insn[slotstack.ninsn - 1].opcode,
		   vinsn->format, i))
		{
		  vinsn->slots[i] = slotstack.insn[slotstack.ninsn - 1];
		}
	      else
		{
		  bundle_single_op (&slotstack.insn[slotstack.ninsn - 1]);
		  if (vinsn->format == XTENSA_UNDEFINED)
		    vinsn->slots[i].opcode = xtensa_nop_opcode;
		  else
		    vinsn->slots[i].opcode 
		      = xtensa_format_slot_nop_opcode (xtensa_default_isa,
						       vinsn->format, i);

		  vinsn->slots[i].ntok = 0;
		}
	    }
	  else
	    {
	      vinsn->slots[0] = slotstack.insn[slotstack.ninsn - 1];
	      vinsn->format = XTENSA_UNDEFINED;
	    }
	}
    }

  /* Now check resource conflicts on the modified bundle.  */
  if (resources_conflict (vinsn)) 
    {
      as_where (&file_name, &line);
      as_bad_where (file_name, line, _("illegal resource usage in bundle"));
      fprintf (stderr, "    ops were: ");
      for (i = 0; i < vinsn->num_slots; i++)
	fprintf (stderr, " %s;",
		 xtensa_opcode_name (xtensa_default_isa,
				     vinsn->slots[i].opcode));
      fprintf (stderr, "\n");
      xg_clear_vinsn (vinsn);
      return;
    }

  /* First, find a format that works.  */
  if (vinsn->format == XTENSA_UNDEFINED)
      vinsn->format = xg_find_narrowest_format (vinsn);

  xg_assemble_vliw_tokens (vinsn);

  xg_clear_vinsn (vinsn);
}


/* Given an vliw instruction, what conflicts are there in register
   usage and in writes to states and queues?

   This function does two things:
   1. Reports an error when a vinsn contains illegal combinations
      of writes to registers states or queues.
   2. Marks individual tinsns as not relaxable if the combination
      contains antidependencies.

   Job 2 handles things like swap semantics in instructions that need
   to be relaxed.  For example,

	addi a0, a1, 100000

   normally would be relaxed to

	l32r a0, some_label
	add a0, a1, a0

   _but_, if the above instruction is bundled with an a0 reader, e.g.,

	{ addi a0, a1, 10000 ; add a2, a0, a4 ; }

   then we can't relax it into

	l32r a0, some_label
	{ add a0, a1, a0 ; add a2, a0, a4 ; }

   because the value of a0 is trashed before the second add can read it.  */

static char check_t1_t2_reads_and_writes (TInsn *, TInsn *);

static bfd_boolean
find_vinsn_conflicts (vliw_insn *vinsn)
{
  int i, j;
  int branches = 0;
  xtensa_isa isa = xtensa_default_isa;

  assert (!past_xtensa_end);

  for (i = 0 ; i < vinsn->num_slots; i++)
    {
      TInsn *op1 = &vinsn->slots[i];
      if (op1->is_specific_opcode)
	op1->keep_wide = TRUE;
      else
	op1->keep_wide = FALSE;
    }

  for (i = 0 ; i < vinsn->num_slots; i++)
    {
      TInsn *op1 = &vinsn->slots[i];

      if (xtensa_opcode_is_branch (isa, op1->opcode) == 1)
	branches++;

      for (j = 0; j < vinsn->num_slots; j++)
	{
	  if (i != j)
	    {
	      TInsn *op2 = &vinsn->slots[j];
	      char conflict_type = check_t1_t2_reads_and_writes (op1, op2);
	      switch (conflict_type)
		{
		case 'c':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) write the same register"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		case 'd':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) write the same state"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		case 'e':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) write the same queue"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		case 'f':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) both have volatile queue accesses"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		default:
		  /* Everything is OK.  */
		  break;
		}
	      op2->is_specific_opcode = (op2->is_specific_opcode
					 || conflict_type == 'a');
	    }
	}
    }

  if (branches > 1)
    {
      as_bad (_("multiple branches or jumps in the same bundle"));
      return TRUE;
    }

  return FALSE;
}


/* Check how the state used by t1 and t2 relate.
   Cases found are:

   case A: t1 reads a register t2 writes (an antidependency within a bundle)
   case B: no relationship between what is read and written (both could
           read the same reg though)
   case C: t1 writes a register t2 writes (a register conflict within a 
           bundle)
   case D: t1 writes a state that t2 also writes
   case E: t1 writes a tie queue that t2 also writes
   case F: two volatile queue accesses
*/

static char
check_t1_t2_reads_and_writes (TInsn *t1, TInsn *t2)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_regfile t1_regfile, t2_regfile;
  int t1_reg, t2_reg;
  int t1_base_reg, t1_last_reg;
  int t2_base_reg, t2_last_reg;
  char t1_inout, t2_inout;
  int i, j;
  char conflict = 'b';
  int t1_states;
  int t2_states;
  int t1_interfaces;
  int t2_interfaces;
  bfd_boolean t1_volatile = FALSE;
  bfd_boolean t2_volatile = FALSE;

  /* Check registers.  */
  for (j = 0; j < t2->ntok; j++)
    {
      if (xtensa_operand_is_register (isa, t2->opcode, j) != 1)
	continue;

      t2_regfile = xtensa_operand_regfile (isa, t2->opcode, j);
      t2_base_reg = t2->tok[j].X_add_number;
      t2_last_reg = t2_base_reg + xtensa_operand_num_regs (isa, t2->opcode, j);

      for (i = 0; i < t1->ntok; i++)
	{
	  if (xtensa_operand_is_register (isa, t1->opcode, i) != 1)
	    continue;

	  t1_regfile = xtensa_operand_regfile (isa, t1->opcode, i);

	  if (t1_regfile != t2_regfile)
	    continue;

	  t1_inout = xtensa_operand_inout (isa, t1->opcode, i);
	  t2_inout = xtensa_operand_inout (isa, t2->opcode, j);

	  if (xtensa_operand_is_known_reg (isa, t1->opcode, i) == 0
	      || xtensa_operand_is_known_reg (isa, t2->opcode, j) == 0)
	    {
	      if (t1_inout == 'm' || t1_inout == 'o'
		  || t2_inout == 'm' || t2_inout == 'o')
		{
		  conflict = 'a';
		  continue;
		}
	    }

	  t1_base_reg = t1->tok[i].X_add_number;
	  t1_last_reg = (t1_base_reg
			 + xtensa_operand_num_regs (isa, t1->opcode, i));

	  for (t1_reg = t1_base_reg; t1_reg < t1_last_reg; t1_reg++)
	    {
	      for (t2_reg = t2_base_reg; t2_reg < t2_last_reg; t2_reg++)
		{
		  if (t1_reg != t2_reg)
		    continue;

		  if (t2_inout == 'i' && (t1_inout == 'm' || t1_inout == 'o'))
		    {
		      conflict = 'a';
		      continue;
		    }

		  if (t1_inout == 'i' && (t2_inout == 'm' || t2_inout == 'o'))
		    {
		      conflict = 'a';
		      continue;
		    }

		  if (t1_inout != 'i' && t2_inout != 'i')
		    return 'c';
		}
	    }
	}
    }

  /* Check states.  */
  t1_states = xtensa_opcode_num_stateOperands (isa, t1->opcode);
  t2_states = xtensa_opcode_num_stateOperands (isa, t2->opcode);
  for (j = 0; j < t2_states; j++)
    {
      xtensa_state t2_so = xtensa_stateOperand_state (isa, t2->opcode, j);
      t2_inout = xtensa_stateOperand_inout (isa, t2->opcode, j);
      for (i = 0; i < t1_states; i++)
	{
	  xtensa_state t1_so = xtensa_stateOperand_state (isa, t1->opcode, i);
	  t1_inout = xtensa_stateOperand_inout (isa, t1->opcode, i);
	  if (t1_so != t2_so) 
	    continue;

	  if (t2_inout == 'i' && (t1_inout == 'm' || t1_inout == 'o'))
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout == 'i' && (t2_inout == 'm' || t2_inout == 'o'))
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout != 'i' && t2_inout != 'i')
	    return 'd';
	}      
    }

  /* Check tieports.  */
  t1_interfaces = xtensa_opcode_num_interfaceOperands (isa, t1->opcode);
  t2_interfaces = xtensa_opcode_num_interfaceOperands (isa, t2->opcode);
  for (j = 0; j < t2_interfaces; j++) 
    {
      xtensa_interface t2_int
	= xtensa_interfaceOperand_interface (isa, t2->opcode, j);
      int t2_class = xtensa_interface_class_id (isa, t2_int);

      t2_inout = xtensa_interface_inout (isa, j);
      if (xtensa_interface_has_side_effect (isa, t2_int) == 1)
	t2_volatile = TRUE;

      for (i = 0; i < t1_interfaces; i++)
	{
	  xtensa_interface t1_int
	    = xtensa_interfaceOperand_interface (isa, t1->opcode, j);
	  int t1_class = xtensa_interface_class_id (isa, t2_int);

	  t1_inout = xtensa_interface_inout (isa, i);
	  if (xtensa_interface_has_side_effect (isa, t1_int) == 1)
	    t1_volatile = TRUE;

	  if (t1_volatile && t2_volatile && (t1_class == t2_class))
	    return 'f';
	  
	  if (t1_int != t2_int)
	    continue;
	  
	  if (t2_inout == 'i' && t1_inout == 'o')
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout == 'i' && t2_inout == 'o')
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout != 'i' && t2_inout != 'i')
	    return 'e';
	}
    }
  
  return conflict;
}


static xtensa_format
xg_find_narrowest_format (vliw_insn *vinsn)
{
  /* Right now we assume that the ops within the vinsn are properly
     ordered for the slots that the programmer wanted them in.  In
     other words, we don't rearrange the ops in hopes of finding a
     better format.  The scheduler handles that.  */

  xtensa_isa isa = xtensa_default_isa;
  xtensa_format format;
  vliw_insn v_copy = *vinsn;
  xtensa_opcode nop_opcode = xtensa_nop_opcode;

  for (format = 0; format < xtensa_isa_num_formats (isa); format++)
    {
      v_copy = *vinsn;
      if (xtensa_format_num_slots (isa, format) == v_copy.num_slots)
	{
	  int slot;
	  int fit = 0;
	  for (slot = 0; slot < v_copy.num_slots; slot++)
	    {
	      if (v_copy.slots[slot].opcode == nop_opcode)
		{
		  v_copy.slots[slot].opcode =
		    xtensa_format_slot_nop_opcode (isa, format, slot);
		  v_copy.slots[slot].ntok = 0;
		}

	      if (opcode_fits_format_slot (v_copy.slots[slot].opcode,
					   format, slot))
		fit++;
	      else if (v_copy.num_slots > 1)
		{
		  TInsn widened;
		  /* Try the widened version.  */
		  if (!v_copy.slots[slot].keep_wide
		      && !v_copy.slots[slot].is_specific_opcode
		      && xg_is_narrow_insn (&v_copy.slots[slot])
		      && !xg_expand_narrow (&widened, &v_copy.slots[slot])
		      && opcode_fits_format_slot (widened.opcode,
						  format, slot))
		    {
		      /* The xg_is_narrow clause requires some explanation:

			 addi can be "widened" to an addmi, which is then
			 expanded to an addmi/addi pair if the immediate
			 requires it, but here we must have a single widen
			 only.

			 xg_is_narrow tells us that addi isn't really
			 narrow.  The widen_spec_list says that there are
			 other cases.  */

		      v_copy.slots[slot] = widened;
		      fit++;
		    }
		}
	    }
	  if (fit == v_copy.num_slots)
	    {
	      *vinsn = v_copy;
	      xtensa_format_encode (isa, format, vinsn->insnbuf);
	      vinsn->format = format;
	      break;
	    }
	}
    }

  if (format == xtensa_isa_num_formats (isa))
    return XTENSA_UNDEFINED;

  return format;
}


/* Return the additional space needed in a frag
   for possible relaxations of any ops in a VLIW insn.
   Also fill out the relaxations that might be required of
   each tinsn in the vinsn.  */

static int
relaxation_requirements (vliw_insn *vinsn)
{
  int extra_space = 0;
  int slot;

  for (slot = 0; slot < vinsn->num_slots; slot++)
    {
      TInsn *tinsn = &vinsn->slots[slot];
      if (!tinsn_has_symbolic_operands (tinsn))
	{
	  /* A narrow instruction could be widened later to help
	     alignment issues.  */
	  if (xg_is_narrow_insn (tinsn)
	      && !tinsn->is_specific_opcode
	      && vinsn->num_slots == 1)
	    {
	      /* Difference in bytes between narrow and wide insns...  */
	      extra_space += 1;
	      tinsn->subtype = RELAX_NARROW;
	      tinsn->record_fix = TRUE;
	      break;
	    }
	  else
	    {
	      tinsn->record_fix = FALSE;
	      /* No extra_space needed.  */
	    }
	}
      else
	{
	  if (workaround_b_j_loop_end
	      && tinsn->opcode == xtensa_jx_opcode
	      && use_transform ())
	    {
	      /* Add 2 of these.  */
	      extra_space += 3; /* for the nop size */
	      tinsn->subtype = RELAX_ADD_NOP_IF_PRE_LOOP_END;
	    }
	  
	  /* Need to assemble it with space for the relocation.  */
	  if (xg_is_relaxable_insn (tinsn, 0)
	      && !tinsn->is_specific_opcode)
	    {
	      int max_size = xg_get_max_insn_widen_size (tinsn->opcode);
	      int max_literal_size =
		xg_get_max_insn_widen_literal_size (tinsn->opcode);
	      
	      tinsn->literal_space = max_literal_size;
	      
	      tinsn->subtype = RELAX_IMMED;
	      tinsn->record_fix = FALSE;
	      extra_space += max_size;
	    }
	  else
	    {
	      tinsn->record_fix = TRUE;
	      /* No extra space needed.  */
	    }
	}
    }
  return extra_space;
}


static void
bundle_single_op (TInsn *orig_insn)
{
  xtensa_isa isa = xtensa_default_isa;
  vliw_insn v;
  int slot;

  xg_init_vinsn (&v);
  v.format = op_placement_table[orig_insn->opcode].narrowest;
  assert (v.format != XTENSA_UNDEFINED);
  v.num_slots = xtensa_format_num_slots (isa, v.format);

  for (slot = 0;
       !opcode_fits_format_slot (orig_insn->opcode, v.format, slot);
       slot++)
    {
      v.slots[slot].opcode =
	xtensa_format_slot_nop_opcode (isa, v.format, slot);
      v.slots[slot].ntok = 0;
      v.slots[slot].insn_type = ITYPE_INSN;
    }

  v.slots[slot] = *orig_insn;
  slot++;

  for ( ; slot < v.num_slots; slot++)
    {
      v.slots[slot].opcode =
	xtensa_format_slot_nop_opcode (isa, v.format, slot);
      v.slots[slot].ntok = 0;
      v.slots[slot].insn_type = ITYPE_INSN;
    }

  finish_vinsn (&v);
  xg_free_vinsn (&v);
}


static bfd_boolean
emit_single_op (TInsn *orig_insn)
{
  int i;
  IStack istack;		/* put instructions into here */
  symbolS *lit_sym = NULL;
  symbolS *label_sym = NULL;

  istack_init (&istack);

  /* Special-case for "movi aX, foo" which is guaranteed to need relaxing.
     Because the scheduling and bundling characteristics of movi and 
     l32r or const16 are so different, we can do much better if we relax 
     it prior to scheduling and bundling, rather than after.  */
  if ((orig_insn->opcode == xtensa_movi_opcode 
       || orig_insn->opcode == xtensa_movi_n_opcode)
      && !cur_vinsn.inside_bundle
      && (orig_insn->tok[1].X_op == O_symbol
	  || orig_insn->tok[1].X_op == O_pltrel))
    xg_assembly_relax (&istack, orig_insn, now_seg, frag_now, 0, 1, 0);
  else
    if (xg_expand_assembly_insn (&istack, orig_insn))
      return TRUE;

  for (i = 0; i < istack.ninsn; i++)
    {
      TInsn *insn = &istack.insn[i];
      switch (insn->insn_type) 
	{
	case ITYPE_LITERAL:
	  assert (lit_sym == NULL);
	  lit_sym = xg_assemble_literal (insn);
	  break;
	case ITYPE_LABEL:
	  {
	    static int relaxed_sym_idx = 0;
	    char *label = xmalloc (strlen (FAKE_LABEL_NAME) + 12);
	    sprintf (label, "%s_rl_%x", FAKE_LABEL_NAME, relaxed_sym_idx++);
	    colon (label);
	    assert (label_sym == NULL);
	    label_sym = symbol_find_or_make (label);
	    assert (label_sym);
	    free (label);
	  }
	  break;
	case ITYPE_INSN:
	  if (lit_sym)
	    xg_resolve_literals (insn, lit_sym);
	  if (label_sym)
	    xg_resolve_labels (insn, label_sym);
	  bundle_single_op (insn);
	  break;
	default:
	  assert (0);
	  break;
	}
    }
  return FALSE;
}


static int
total_frag_text_expansion (fragS *fragP)
{
  int slot;
  int total_expansion = 0;

  for (slot = 0; slot < MAX_SLOTS; slot++)
    total_expansion += fragP->tc_frag_data.text_expansion[slot];

  return total_expansion;
}


/* Emit a vliw instruction to the current fragment.  */

static void
xg_assemble_vliw_tokens (vliw_insn *vinsn)
{
  bfd_boolean finish_frag = FALSE;
  bfd_boolean is_jump = FALSE;
  bfd_boolean is_branch = FALSE;
  xtensa_isa isa = xtensa_default_isa;
  int i;
  int insn_size;
  int extra_space;
  char *f = NULL;
  int slot;
  struct dwarf2_line_info best_loc;

  best_loc.line = INT_MAX;

  if (generating_literals)
    {
      static int reported = 0;
      if (reported < 4)
	as_bad_where (frag_now->fr_file, frag_now->fr_line,
		      _("cannot assemble into a literal fragment"));
      if (reported == 3)
	as_bad (_("..."));
      reported++;
      return;
    }

  if (frag_now_fix () != 0
      && (! frag_now->tc_frag_data.is_insn
 	  || (vinsn_has_specific_opcodes (vinsn) && use_transform ())
 	  || !use_transform () != frag_now->tc_frag_data.is_no_transform
 	  || (directive_state[directive_absolute_literals]
	      != frag_now->tc_frag_data.use_absolute_literals)))
    {
      frag_wane (frag_now);
      frag_new (0);
      xtensa_set_frag_assembly_state (frag_now);
    }

  if (workaround_a0_b_retw
      && vinsn->num_slots == 1
      && (get_last_insn_flags (now_seg, now_subseg) & FLAG_IS_A0_WRITER) != 0
      && xtensa_opcode_is_branch (isa, vinsn->slots[0].opcode) == 1
      && use_transform ())
    {
      has_a0_b_retw = TRUE;

      /* Mark this fragment with the special RELAX_ADD_NOP_IF_A0_B_RETW.
	 After the first assembly pass we will check all of them and
	 add a nop if needed.  */
      frag_now->tc_frag_data.is_insn = TRUE;
      frag_var (rs_machine_dependent, 4, 4,
		RELAX_ADD_NOP_IF_A0_B_RETW,
		frag_now->fr_symbol,
		frag_now->fr_offset,
		NULL);
      xtensa_set_frag_assembly_state (frag_now);
      frag_now->tc_frag_data.is_insn = TRUE;
      frag_var (rs_machine_dependent, 4, 4,
		RELAX_ADD_NOP_IF_A0_B_RETW,
		frag_now->fr_symbol,
		frag_now->fr_offset,
		NULL);
      xtensa_set_frag_assembly_state (frag_now);
    }

  for (i = 0; i < vinsn->num_slots; i++)
    {
      /* See if the instruction implies an aligned section.  */
      if (xtensa_opcode_is_loop (isa, vinsn->slots[i].opcode) == 1)
	record_alignment (now_seg, 2);
      
      /* Also determine the best line number for debug info.  */
      best_loc = vinsn->slots[i].loc.line < best_loc.line 
	? vinsn->slots[i].loc : best_loc;
    }

  /* Special cases for instructions that force an alignment... */
  /* None of these opcodes are bundle-able.  */
  if (xtensa_opcode_is_loop (isa, vinsn->slots[0].opcode) == 1)
    {
      size_t max_fill;
      
      xtensa_set_frag_assembly_state (frag_now);
      frag_now->tc_frag_data.is_insn = TRUE;
      
      max_fill = get_text_align_max_fill_size
	(get_text_align_power (xtensa_fetch_width),
	 TRUE, frag_now->tc_frag_data.is_no_density);

      if (use_transform ())
	frag_var (rs_machine_dependent, max_fill, max_fill,
		  RELAX_ALIGN_NEXT_OPCODE,
		  frag_now->fr_symbol,
		  frag_now->fr_offset,
		  NULL);
      else
	frag_var (rs_machine_dependent, 0, 0, 
		  RELAX_CHECK_ALIGN_NEXT_OPCODE, 0, 0, NULL);
      xtensa_set_frag_assembly_state (frag_now);
      
      xtensa_move_labels (frag_now, 0, FALSE);
    }

  if (vinsn->slots[0].opcode == xtensa_entry_opcode
      && !vinsn->slots[0].is_specific_opcode)
    {
      xtensa_mark_literal_pool_location ();
      xtensa_move_labels (frag_now, 0, TRUE);
      frag_var (rs_align_test, 1, 1, 0, NULL, 2, NULL);
    }

  if (vinsn->num_slots == 1)
    {
      if (workaround_a0_b_retw && use_transform ())
	set_last_insn_flags (now_seg, now_subseg, FLAG_IS_A0_WRITER,
			     is_register_writer (&vinsn->slots[0], "a", 0));

      set_last_insn_flags (now_seg, now_subseg, FLAG_IS_BAD_LOOPEND,
			   is_bad_loopend_opcode (&vinsn->slots[0]));
    }
  else
    set_last_insn_flags (now_seg, now_subseg, FLAG_IS_BAD_LOOPEND, FALSE);

  insn_size = xtensa_format_length (isa, vinsn->format);

  extra_space = relaxation_requirements (vinsn);

  /* vinsn_to_insnbuf will produce the error.  */
  if (vinsn->format != XTENSA_UNDEFINED)
    {
      f = (char *) frag_more (insn_size + extra_space);
      xtensa_set_frag_assembly_state (frag_now);
      frag_now->tc_frag_data.is_insn = TRUE;
    }

  vinsn_to_insnbuf (vinsn, f, frag_now, TRUE);
  if (vinsn->format == XTENSA_UNDEFINED)
    return;

  xtensa_insnbuf_to_chars (isa, vinsn->insnbuf, f, 0);
  
  xtensa_dwarf2_emit_insn (insn_size - extra_space, &best_loc);

  for (slot = 0; slot < vinsn->num_slots; slot++)
    {
      TInsn *tinsn = &vinsn->slots[slot];
      frag_now->tc_frag_data.slot_subtypes[slot] = tinsn->subtype;
      frag_now->tc_frag_data.slot_symbols[slot] =  tinsn->symbol;
      frag_now->tc_frag_data.slot_sub_symbols[slot] =  tinsn->sub_symbol;
      frag_now->tc_frag_data.slot_offsets[slot] =  tinsn->offset;
      frag_now->tc_frag_data.literal_frags[slot] = tinsn->literal_frag;
      if (tinsn->literal_space != 0)
	xg_assemble_literal_space (tinsn->literal_space, slot);

      if (tinsn->subtype == RELAX_NARROW)
	assert (vinsn->num_slots == 1);
      if (xtensa_opcode_is_jump (isa, tinsn->opcode) == 1)
	is_jump = TRUE;
      if (xtensa_opcode_is_branch (isa, tinsn->opcode) == 1)
	is_branch = TRUE;

      if (tinsn->subtype || tinsn->symbol || tinsn->record_fix 
	  || tinsn->offset || tinsn->literal_frag || is_jump || is_branch)
	finish_frag = TRUE;
    }

  if (vinsn_has_specific_opcodes (vinsn) && use_transform ())
    frag_now->tc_frag_data.is_specific_opcode = TRUE;

  if (finish_frag)
    {
      frag_variant (rs_machine_dependent,
		    extra_space, extra_space, RELAX_SLOTS,
		    frag_now->fr_symbol, frag_now->fr_offset, f);
      xtensa_set_frag_assembly_state (frag_now);
    }

  /* Special cases for loops:
     close_loop_end should be inserted AFTER short_loop.
     Make sure that CLOSE loops are processed BEFORE short_loops
     when converting them.  */

  /* "short_loop": Add a NOP if the loop is < 4 bytes.  */
  if (xtensa_opcode_is_loop (isa, vinsn->slots[0].opcode)
      && !vinsn->slots[0].is_specific_opcode)
    {
      if (workaround_short_loop && use_transform ())
	{
	  maybe_has_short_loop = TRUE;
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 4, 4,
		    RELAX_ADD_NOP_IF_SHORT_LOOP,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 4, 4,
		    RELAX_ADD_NOP_IF_SHORT_LOOP,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	}

      /* "close_loop_end": Add up to 12 bytes of NOPs to keep a
	 loop at least 12 bytes away from another loop's end.  */
      if (workaround_close_loop_end && use_transform ())
	{
	  maybe_has_close_loop_end = TRUE;
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 12, 12,
		    RELAX_ADD_NOP_IF_CLOSE_LOOP_END,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	}
    }

  if (use_transform ())
    {
      if (is_jump)
	{
	  assert (finish_frag);
	  frag_var (rs_machine_dependent,
		    UNREACHABLE_MAX_WIDTH, UNREACHABLE_MAX_WIDTH,
		    RELAX_UNREACHABLE,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  xtensa_set_frag_assembly_state (frag_now);
	}
      else if (is_branch && align_targets)
	{
	  assert (finish_frag);
	  frag_var (rs_machine_dependent,
		    UNREACHABLE_MAX_WIDTH, UNREACHABLE_MAX_WIDTH,
		    RELAX_MAYBE_UNREACHABLE,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  xtensa_set_frag_assembly_state (frag_now);
	  frag_var (rs_machine_dependent,
		    0, 0,
		    RELAX_MAYBE_DESIRE_ALIGN,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  xtensa_set_frag_assembly_state (frag_now);
	}
    }

  /* Now, if the original opcode was a call...  */
  if (do_align_targets ()
      && xtensa_opcode_is_call (isa, vinsn->slots[0].opcode) == 1)
    {
      float freq = get_subseg_total_freq (now_seg, now_subseg);
      frag_now->tc_frag_data.is_insn = TRUE;
      frag_var (rs_machine_dependent, 4, (int) freq, RELAX_DESIRE_ALIGN,
		frag_now->fr_symbol, frag_now->fr_offset, NULL);
      xtensa_set_frag_assembly_state (frag_now);
    }

  if (vinsn_has_specific_opcodes (vinsn) && use_transform ())
    {
      frag_wane (frag_now);
      frag_new (0);
      xtensa_set_frag_assembly_state (frag_now);
    }
}


/* xtensa_end and helper functions.  */

static void xtensa_cleanup_align_frags (void);
static void xtensa_fix_target_frags (void);
static void xtensa_mark_narrow_branches (void);
static void xtensa_mark_zcl_first_insns (void);
static void xtensa_fix_a0_b_retw_frags (void);
static void xtensa_fix_b_j_loop_end_frags (void);
static void xtensa_fix_close_loop_end_frags (void);
static void xtensa_fix_short_loop_frags (void);
static void xtensa_sanity_check (void);

void
xtensa_end (void)
{
  directive_balance ();
  xtensa_flush_pending_output ();

  past_xtensa_end = TRUE;

  xtensa_move_literals ();

  xtensa_reorder_segments ();
  xtensa_cleanup_align_frags ();
  xtensa_fix_target_frags ();
  if (workaround_a0_b_retw && has_a0_b_retw)
    xtensa_fix_a0_b_retw_frags ();
  if (workaround_b_j_loop_end)
    xtensa_fix_b_j_loop_end_frags ();

  /* "close_loop_end" should be processed BEFORE "short_loop".  */
  if (workaround_close_loop_end && maybe_has_close_loop_end)
    xtensa_fix_close_loop_end_frags ();

  if (workaround_short_loop && maybe_has_short_loop)
    xtensa_fix_short_loop_frags ();
  xtensa_mark_narrow_branches ();
  xtensa_mark_zcl_first_insns ();

  xtensa_sanity_check ();
}


static void
xtensa_cleanup_align_frags (void)
{
  frchainS *frchP;

  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;
      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if ((fragP->fr_type == rs_align
	       || fragP->fr_type == rs_align_code
	       || (fragP->fr_type == rs_machine_dependent
		   && (fragP->fr_subtype == RELAX_DESIRE_ALIGN
		       || fragP->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET)))
	      && fragP->fr_fix == 0)
	    {
	      fragS *next = fragP->fr_next;

	      while (next
		     && next->fr_fix == 0
		     && next->fr_type == rs_machine_dependent
		     && next->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET)
		{
		  frag_wane (next);
		  next = next->fr_next;
		}
	    }
	  /* If we don't widen branch targets, then they
	     will be easier to align.  */
	  if (fragP->tc_frag_data.is_branch_target
	      && fragP->fr_opcode == fragP->fr_literal
	      && fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_SLOTS
	      && fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
	    frag_wane (fragP);
	  if (fragP->fr_type == rs_machine_dependent 
	      && fragP->fr_subtype == RELAX_UNREACHABLE)
	    fragP->tc_frag_data.is_unreachable = TRUE;
	}
    }
}


/* Re-process all of the fragments looking to convert all of the
   RELAX_DESIRE_ALIGN_IF_TARGET fragments.  If there is a branch
   target in the next fragment, convert this to RELAX_DESIRE_ALIGN.
   If the next fragment starts with a loop target, AND the previous
   fragment can be expanded to negate the branch, convert this to a
   RELAX_LOOP_END.  Otherwise, convert to a .fill 0.  */

static bfd_boolean frag_can_negate_branch (fragS *);

static void
xtensa_fix_target_frags (void)
{
  frchainS *frchP;

  /* When this routine is called, all of the subsections are still intact
     so we walk over subsections instead of sections.  */
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      bfd_boolean prev_frag_can_negate_branch = FALSE;
      fragS *fragP;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET)
	    {
	      if (next_frag_is_loop_target (fragP))
		{
		  if (prev_frag_can_negate_branch)
		    {
		      fragP->fr_subtype = RELAX_LOOP_END;
		      /* See the comment near the frag_var with a
			 RELAX_DESIRE_ALIGN to see why we do this.  */
		      fragP->fr_var = RELAX_LOOP_END_BYTES;
		    }
		  else
		    {
		      if (next_frag_is_branch_target (fragP))
			fragP->fr_subtype = RELAX_DESIRE_ALIGN;
		      else
			frag_wane (fragP);
		    }
		}
	      else if (next_frag_is_branch_target (fragP))
		fragP->fr_subtype = RELAX_DESIRE_ALIGN;
	      else
		frag_wane (fragP);
	    }
	  if (fragP->fr_fix != 0)
	    prev_frag_can_negate_branch = FALSE;
	  if (frag_can_negate_branch (fragP))
	    prev_frag_can_negate_branch = TRUE;
	}
    }
}


static bfd_boolean
frag_can_negate_branch (fragS *fragP)
{
  xtensa_isa isa = xtensa_default_isa;
  vliw_insn vinsn;
  int slot;

  if (fragP->fr_type != rs_machine_dependent
      || fragP->fr_subtype != RELAX_SLOTS)
    return FALSE;

  vinsn_from_chars (&vinsn, fragP->fr_opcode);

  for (slot = 0; slot < xtensa_format_num_slots (isa, vinsn.format); slot++)
    {
      if ((fragP->tc_frag_data.slot_subtypes[slot] == RELAX_IMMED)
	  && xtensa_opcode_is_branch (isa, vinsn.slots[slot].opcode) == 1)
	return TRUE;
    }

  return FALSE;
}


static bfd_boolean is_narrow_branch_guaranteed_in_range (fragS *, TInsn *);

static void
xtensa_mark_narrow_branches (void)
{
  frchainS *frchP;

  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;
      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_SLOTS
	      && fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED)
	    {
	      vliw_insn vinsn;
	      const expressionS *expr;
	      symbolS *symbolP;

	      vinsn_from_chars (&vinsn, fragP->fr_opcode);
	      tinsn_immed_from_frag (&vinsn.slots[0], fragP, 0);

	      expr = &vinsn.slots[0].tok[1];
	      symbolP = expr->X_add_symbol;

	      if (vinsn.num_slots == 1
		  && xtensa_opcode_is_branch (xtensa_default_isa,
					      vinsn.slots[0].opcode)
		  && xg_get_single_size (vinsn.slots[0].opcode) == 2
		  && is_narrow_branch_guaranteed_in_range (fragP,
							   &vinsn.slots[0]))
		{
		  fragP->fr_subtype = RELAX_SLOTS;
		  fragP->tc_frag_data.slot_subtypes[0] = RELAX_NARROW;
		}
	    }
	}
    }
}


/* A branch is typically widened only when its target is out of
   range.  However, we would like to widen them to align a subsequent
   branch target when possible.

   Because the branch relaxation code is so convoluted, the optimal solution
   (combining the two cases) is difficult to get right in all circumstances.
   We therefore go with an "almost as good" solution, where we only
   use for alignment narrow branches that definitely will not expand to a
   jump and a branch.  These functions find and mark these cases.  */

/* The range in bytes of BNEZ.N and BEQZ.N.  The target operand is encoded
   as PC + 4 + imm6, where imm6 is a 6-bit immediate ranging from 0 to 63.
   We start counting beginning with the frag after the 2-byte branch, so the
   maximum offset is (4 - 2) + 63 = 65.  */
#define MAX_IMMED6 65

static size_t unrelaxed_frag_max_size (fragS *);

static bfd_boolean
is_narrow_branch_guaranteed_in_range (fragS *fragP, TInsn *tinsn)
{
  const expressionS *expr = &tinsn->tok[1];
  symbolS *symbolP = expr->X_add_symbol;
  fragS *target_frag = symbol_get_frag (symbolP);
  size_t max_distance = expr->X_add_number;
  max_distance += (S_GET_VALUE (symbolP) - target_frag->fr_address);
  if (is_branch_jmp_to_next (tinsn, fragP))
    return FALSE;

  /* The branch doesn't branch over it's own frag,
     but over the subsequent ones.  */
  fragP = fragP->fr_next;
  while (fragP != NULL && fragP != target_frag && max_distance <= MAX_IMMED6)
    {
      max_distance += unrelaxed_frag_max_size (fragP);
      fragP = fragP->fr_next;
    }
  if (max_distance <= MAX_IMMED6 && fragP == target_frag)
    return TRUE;
  return FALSE;
}


static void
xtensa_mark_zcl_first_insns (void)
{
  frchainS *frchP;

  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;
      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE
		  || fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE))
	    {
	      /* Find the loop frag.  */
	      fragS *targ_frag = next_non_empty_frag (fragP);
	      /* Find the first insn frag.  */
	      targ_frag = next_non_empty_frag (targ_frag);

	      /* Of course, sometimes (mostly for toy test cases) a
		 zero-cost loop instruction is the last in a section.  */
	      if (targ_frag) 
		{
		  targ_frag->tc_frag_data.is_first_loop_insn = TRUE;
		  if (fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE)
		    frag_wane (fragP);
		}
	    }
	}
    }
}


/* Re-process all of the fragments looking to convert all of the
   RELAX_ADD_NOP_IF_A0_B_RETW.  If the next instruction is a
   conditional branch or a retw/retw.n, convert this frag to one that
   will generate a NOP.  In any case close it off with a .fill 0.  */

static bfd_boolean next_instrs_are_b_retw (fragS *);

static void
xtensa_fix_a0_b_retw_frags (void)
{
  frchainS *frchP;

  /* When this routine is called, all of the subsections are still intact
     so we walk over subsections instead of sections.  */
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_ADD_NOP_IF_A0_B_RETW)
	    {
	      if (next_instrs_are_b_retw (fragP))
		{
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("instruction sequence (write a0, branch, retw) may trigger hardware errata"));
		  else
		    relax_frag_add_nop (fragP);
		}
	      frag_wane (fragP);
	    }
	}
    }
}


static bfd_boolean
next_instrs_are_b_retw (fragS *fragP)
{
  xtensa_opcode opcode;
  xtensa_format fmt;
  const fragS *next_fragP = next_non_empty_frag (fragP);
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
  int offset = 0;
  int slot;
  bfd_boolean branch_seen = FALSE;

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  if (next_fragP == NULL)
    return FALSE;

  /* Check for the conditional branch.  */
  xtensa_insnbuf_from_chars (isa, insnbuf, &next_fragP->fr_literal[offset], 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    return FALSE;

  for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
    {
      xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
      opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);

      branch_seen = (branch_seen
		     || xtensa_opcode_is_branch (isa, opcode) == 1);
    }

  if (!branch_seen)
    return FALSE;

  offset += xtensa_format_length (isa, fmt);
  if (offset == next_fragP->fr_fix)
    {
      next_fragP = next_non_empty_frag (next_fragP);
      offset = 0;
    }

  if (next_fragP == NULL)
    return FALSE;

  /* Check for the retw/retw.n.  */
  xtensa_insnbuf_from_chars (isa, insnbuf, &next_fragP->fr_literal[offset], 0);
  fmt = xtensa_format_decode (isa, insnbuf);

  /* Because RETW[.N] is not bundleable, a VLIW bundle here means that we
     have no problems.  */
  if (fmt == XTENSA_UNDEFINED
      || xtensa_format_num_slots (isa, fmt) != 1)
    return FALSE;

  xtensa_format_get_slot (isa, fmt, 0, insnbuf, slotbuf);
  opcode = xtensa_opcode_decode (isa, fmt, 0, slotbuf);

  if (opcode == xtensa_retw_opcode || opcode == xtensa_retw_n_opcode)
    return TRUE;

  return FALSE;
}


/* Re-process all of the fragments looking to convert all of the
   RELAX_ADD_NOP_IF_PRE_LOOP_END.  If there is one instruction and a
   loop end label, convert this frag to one that will generate a NOP.
   In any case close it off with a .fill 0.  */

static bfd_boolean next_instr_is_loop_end (fragS *);

static void
xtensa_fix_b_j_loop_end_frags (void)
{
  frchainS *frchP;

  /* When this routine is called, all of the subsections are still intact
     so we walk over subsections instead of sections.  */
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_ADD_NOP_IF_PRE_LOOP_END)
	    {
	      if (next_instr_is_loop_end (fragP))
		{
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("branching or jumping to a loop end may trigger hardware errata"));
		  else
		    relax_frag_add_nop (fragP);
		}
	      frag_wane (fragP);
	    }
	}
    }
}


static bfd_boolean
next_instr_is_loop_end (fragS *fragP)
{
  const fragS *next_fragP;

  if (next_frag_is_loop_target (fragP))
    return FALSE;

  next_fragP = next_non_empty_frag (fragP);
  if (next_fragP == NULL)
    return FALSE;

  if (!next_frag_is_loop_target (next_fragP))
    return FALSE;

  /* If the size is >= 3 then there is more than one instruction here.
     The hardware bug will not fire.  */
  if (next_fragP->fr_fix > 3)
    return FALSE;

  return TRUE;
}


/* Re-process all of the fragments looking to convert all of the
   RELAX_ADD_NOP_IF_CLOSE_LOOP_END.  If there is an loop end that is
   not MY loop's loop end within 12 bytes, add enough nops here to
   make it at least 12 bytes away.  In any case close it off with a
   .fill 0.  */

static size_t min_bytes_to_other_loop_end (fragS *, fragS *, offsetT, size_t);

static void
xtensa_fix_close_loop_end_frags (void)
{
  frchainS *frchP;

  /* When this routine is called, all of the subsections are still intact
     so we walk over subsections instead of sections.  */
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;

      fragS *current_target = NULL;
      offsetT current_offset = 0;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && ((fragP->fr_subtype == RELAX_IMMED)
		  || ((fragP->fr_subtype == RELAX_SLOTS)
		      && (fragP->tc_frag_data.slot_subtypes[0]
			  == RELAX_IMMED))))
	    {
	      /* Read it.  If the instruction is a loop, get the target.  */
	      TInsn t_insn;
	      tinsn_from_chars (&t_insn, fragP->fr_opcode, 0);
	      if (xtensa_opcode_is_loop (xtensa_default_isa,
					 t_insn.opcode) == 1)
		{
		  /* Get the current fragment target.  */
		  if (fragP->tc_frag_data.slot_symbols[0])
		    {
		      symbolS *sym = fragP->tc_frag_data.slot_symbols[0];
		      current_target = symbol_get_frag (sym);
		      current_offset = fragP->fr_offset;
		    }
		}
	    }

	  if (current_target
	      && fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_ADD_NOP_IF_CLOSE_LOOP_END)
	    {
	      size_t min_bytes;
	      size_t bytes_added = 0;

#define REQUIRED_LOOP_DIVIDING_BYTES 12
	      /* Max out at 12.  */
	      min_bytes = min_bytes_to_other_loop_end
		(fragP->fr_next, current_target, current_offset,
		 REQUIRED_LOOP_DIVIDING_BYTES);

	      if (min_bytes < REQUIRED_LOOP_DIVIDING_BYTES)
		{
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("loop end too close to another loop end may trigger hardware errata"));
		  else
		    {
		      while (min_bytes + bytes_added
			     < REQUIRED_LOOP_DIVIDING_BYTES)
			{
			  int length = 3;
			  
			  if (fragP->fr_var < length)
			    as_fatal (_("fr_var %lu < length %d"),
				      fragP->fr_var, length);
			  else
			    {
			      assemble_nop (length,
					    fragP->fr_literal + fragP->fr_fix);
			      fragP->fr_fix += length;
			      fragP->fr_var -= length;
			    }
			  bytes_added += length;
			}
		    }
		}
	      frag_wane (fragP);
	    }
	  assert (fragP->fr_type != rs_machine_dependent
		  || fragP->fr_subtype != RELAX_ADD_NOP_IF_CLOSE_LOOP_END);
	}
    }
}


static size_t unrelaxed_frag_min_size (fragS *);

static size_t
min_bytes_to_other_loop_end (fragS *fragP,
			     fragS *current_target,
			     offsetT current_offset,
			     size_t max_size)
{
  size_t offset = 0;
  fragS *current_fragP;

  for (current_fragP = fragP;
       current_fragP;
       current_fragP = current_fragP->fr_next)
    {
      if (current_fragP->tc_frag_data.is_loop_target
	  && current_fragP != current_target)
	return offset + current_offset;

      offset += unrelaxed_frag_min_size (current_fragP);

      if (offset + current_offset >= max_size)
	return max_size;
    }
  return max_size;
}


static size_t
unrelaxed_frag_min_size (fragS *fragP)
{
  size_t size = fragP->fr_fix;

  /* add fill size */
  if (fragP->fr_type == rs_fill)
    size += fragP->fr_offset;

  return size;
}


static size_t
unrelaxed_frag_max_size (fragS *fragP)
{
  size_t size = fragP->fr_fix;
  switch (fragP->fr_type)
    {
    case 0:
      /* Empty frags created by the obstack allocation scheme 
	 end up with type 0.  */
      break;
    case rs_fill:
    case rs_org:
    case rs_space:
      size += fragP->fr_offset;
      break;
    case rs_align:
    case rs_align_code:
    case rs_align_test:
    case rs_leb128:
    case rs_cfa:
    case rs_dwarf2dbg:
      /* No further adjustments needed.  */
      break;
    case rs_machine_dependent:
      if (fragP->fr_subtype != RELAX_DESIRE_ALIGN)
	size += fragP->fr_var;
      break;
    default:
      /* We had darn well better know how big it is.  */
      assert (0);
      break;
    }

  return size;
}


/* Re-process all of the fragments looking to convert all
   of the RELAX_ADD_NOP_IF_SHORT_LOOP.  If:

   A)
     1) the instruction size count to the loop end label
        is too short (<= 2 instructions),
     2) loop has a jump or branch in it

   or B)
     1) workaround_all_short_loops is TRUE
     2) The generating loop was a  'loopgtz' or 'loopnez'
     3) the instruction size count to the loop end label is too short
        (<= 2 instructions)
   then convert this frag (and maybe the next one) to generate a NOP.
   In any case close it off with a .fill 0.  */

static size_t count_insns_to_loop_end (fragS *, bfd_boolean, size_t);
static bfd_boolean branch_before_loop_end (fragS *);

static void
xtensa_fix_short_loop_frags (void)
{
  frchainS *frchP;

  /* When this routine is called, all of the subsections are still intact
     so we walk over subsections instead of sections.  */
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;
      fragS *current_target = NULL;
      offsetT current_offset = 0;
      xtensa_opcode current_opcode = XTENSA_UNDEFINED;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  /* Check on the current loop.  */
	  if (fragP->fr_type == rs_machine_dependent
	      && ((fragP->fr_subtype == RELAX_IMMED)
		  || ((fragP->fr_subtype == RELAX_SLOTS)
		      && (fragP->tc_frag_data.slot_subtypes[0]
			  == RELAX_IMMED))))
	    {
	      TInsn t_insn;

	      /* Read it.  If the instruction is a loop, get the target.  */
	      tinsn_from_chars (&t_insn, fragP->fr_opcode, 0);
	      if (xtensa_opcode_is_loop (xtensa_default_isa,
					 t_insn.opcode) == 1)
		{
		  /* Get the current fragment target.  */
		  if (fragP->tc_frag_data.slot_symbols[0])
		    {
		      symbolS *sym = fragP->tc_frag_data.slot_symbols[0];
		      current_target = symbol_get_frag (sym);
		      current_offset = fragP->fr_offset;
		      current_opcode = t_insn.opcode;
		    }
		}
	    }

	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_ADD_NOP_IF_SHORT_LOOP)
	    {
	      size_t insn_count =
		count_insns_to_loop_end (fragP->fr_next, TRUE, 3);
	      if (insn_count < 3
		  && (branch_before_loop_end (fragP->fr_next)
		      || (workaround_all_short_loops
			  && current_opcode != XTENSA_UNDEFINED
			  && current_opcode != xtensa_loop_opcode)))
		{
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("loop containing less than three instructions may trigger hardware errata"));
		  else
		    relax_frag_add_nop (fragP);
		}
	      frag_wane (fragP);
	    }
	}
    }
}


static size_t unrelaxed_frag_min_insn_count (fragS *);

static size_t
count_insns_to_loop_end (fragS *base_fragP,
			 bfd_boolean count_relax_add,
			 size_t max_count)
{
  fragS *fragP = NULL;
  size_t insn_count = 0;

  fragP = base_fragP;

  for (; fragP && !fragP->tc_frag_data.is_loop_target; fragP = fragP->fr_next)
    {
      insn_count += unrelaxed_frag_min_insn_count (fragP);
      if (insn_count >= max_count)
	return max_count;

      if (count_relax_add)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_ADD_NOP_IF_SHORT_LOOP)
	    {
	      /* In order to add the appropriate number of
	         NOPs, we count an instruction for downstream
	         occurrences.  */
	      insn_count++;
	      if (insn_count >= max_count)
		return max_count;
	    }
	}
    }
  return insn_count;
}


static size_t
unrelaxed_frag_min_insn_count (fragS *fragP)
{
  xtensa_isa isa = xtensa_default_isa;
  static xtensa_insnbuf insnbuf = NULL;
  size_t insn_count = 0;
  int offset = 0;

  if (!fragP->tc_frag_data.is_insn)
    return insn_count;

  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

  /* Decode the fixed instructions.  */
  while (offset < fragP->fr_fix)
    {
      xtensa_format fmt;

      xtensa_insnbuf_from_chars (isa, insnbuf, fragP->fr_literal + offset, 0);
      fmt = xtensa_format_decode (isa, insnbuf);

      if (fmt == XTENSA_UNDEFINED)
	{
	  as_fatal (_("undecodable instruction in instruction frag"));
	  return insn_count;
	}
      offset += xtensa_format_length (isa, fmt);
      insn_count++;
    }

  return insn_count;
}


static bfd_boolean unrelaxed_frag_has_b_j (fragS *);

static bfd_boolean
branch_before_loop_end (fragS *base_fragP)
{
  fragS *fragP;

  for (fragP = base_fragP;
       fragP && !fragP->tc_frag_data.is_loop_target;
       fragP = fragP->fr_next)
    {
      if (unrelaxed_frag_has_b_j (fragP))
	return TRUE;
    }
  return FALSE;
}


static bfd_boolean
unrelaxed_frag_has_b_j (fragS *fragP)
{
  static xtensa_insnbuf insnbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
  int offset = 0;

  if (!fragP->tc_frag_data.is_insn)
    return FALSE;

  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

  /* Decode the fixed instructions.  */
  while (offset < fragP->fr_fix)
    {
      xtensa_format fmt;
      int slot;

      xtensa_insnbuf_from_chars (isa, insnbuf, fragP->fr_literal + offset, 0);
      fmt = xtensa_format_decode (isa, insnbuf);
      if (fmt == XTENSA_UNDEFINED)
	return FALSE;

      for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
	{
	  xtensa_opcode opcode =
	    get_opcode_from_buf (fragP->fr_literal + offset, slot);
	  if (xtensa_opcode_is_branch (isa, opcode) == 1
	      || xtensa_opcode_is_jump (isa, opcode) == 1)
	    return TRUE;
	}
      offset += xtensa_format_length (isa, fmt);
    }
  return FALSE;
}


/* Checks to be made after initial assembly but before relaxation.  */

static bfd_boolean is_empty_loop (const TInsn *, fragS *);
static bfd_boolean is_local_forward_loop (const TInsn *, fragS *);

static void
xtensa_sanity_check (void)
{
  char *file_name;
  int line;

  frchainS *frchP;

  as_where (&file_name, &line);
  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;

      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  /* Currently we only check for empty loops here.  */
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_IMMED)
	    {
	      static xtensa_insnbuf insnbuf = NULL;
	      TInsn t_insn;

	      if (fragP->fr_opcode != NULL)
		{
		  if (!insnbuf)
		    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);
		  tinsn_from_chars (&t_insn, fragP->fr_opcode, 0);
		  tinsn_immed_from_frag (&t_insn, fragP, 0);

		  if (xtensa_opcode_is_loop (xtensa_default_isa,
					     t_insn.opcode) == 1)
		    {
		      if (is_empty_loop (&t_insn, fragP))
			{
			  new_logical_line (fragP->fr_file, fragP->fr_line);
			  as_bad (_("invalid empty loop"));
			}
		      if (!is_local_forward_loop (&t_insn, fragP))
			{
			  new_logical_line (fragP->fr_file, fragP->fr_line);
			  as_bad (_("loop target does not follow "
				    "loop instruction in section"));
			}
		    }
		}
	    }
	}
    }
  new_logical_line (file_name, line);
}


#define LOOP_IMMED_OPN 1

/* Return TRUE if the loop target is the next non-zero fragment.  */

static bfd_boolean
is_empty_loop (const TInsn *insn, fragS *fragP)
{
  const expressionS *expr;
  symbolS *symbolP;
  fragS *next_fragP;

  if (insn->insn_type != ITYPE_INSN)
    return FALSE;

  if (xtensa_opcode_is_loop (xtensa_default_isa, insn->opcode) != 1)
    return FALSE;

  if (insn->ntok <= LOOP_IMMED_OPN)
    return FALSE;

  expr = &insn->tok[LOOP_IMMED_OPN];

  if (expr->X_op != O_symbol)
    return FALSE;

  symbolP = expr->X_add_symbol;
  if (!symbolP)
    return FALSE;

  if (symbol_get_frag (symbolP) == NULL)
    return FALSE;

  if (S_GET_VALUE (symbolP) != 0)
    return FALSE;

  /* Walk through the zero-size fragments from this one.  If we find
     the target fragment, then this is a zero-size loop.  */

  for (next_fragP = fragP->fr_next;
       next_fragP != NULL;
       next_fragP = next_fragP->fr_next)
    {
      if (next_fragP == symbol_get_frag (symbolP))
	return TRUE;
      if (next_fragP->fr_fix != 0)
	return FALSE;
    }
  return FALSE;
}


static bfd_boolean
is_local_forward_loop (const TInsn *insn, fragS *fragP)
{
  const expressionS *expr;
  symbolS *symbolP;
  fragS *next_fragP;

  if (insn->insn_type != ITYPE_INSN)
    return FALSE;

  if (xtensa_opcode_is_loop (xtensa_default_isa, insn->opcode) == 0)
    return FALSE;

  if (insn->ntok <= LOOP_IMMED_OPN)
    return FALSE;

  expr = &insn->tok[LOOP_IMMED_OPN];

  if (expr->X_op != O_symbol)
    return FALSE;

  symbolP = expr->X_add_symbol;
  if (!symbolP)
    return FALSE;

  if (symbol_get_frag (symbolP) == NULL)
    return FALSE;

  /* Walk through fragments until we find the target.
     If we do not find the target, then this is an invalid loop.  */

  for (next_fragP = fragP->fr_next;
       next_fragP != NULL;
       next_fragP = next_fragP->fr_next)
    {
      if (next_fragP == symbol_get_frag (symbolP))
	return TRUE;
    }

  return FALSE;
}


/* Alignment Functions.  */

static size_t
get_text_align_power (int target_size)
{
  size_t i = 0;
  for (i = 0; i < sizeof (size_t); i++)
    {
      if (target_size <= (1 << i))
	return i;
    }
  assert (0);
  return 0;
}


static addressT
get_text_align_max_fill_size (int align_pow,
			      bfd_boolean use_nops,
			      bfd_boolean use_no_density)
{
  if (!use_nops)
    return (1 << align_pow);
  if (use_no_density)
    return 3 * (1 << align_pow);

  return 1 + (1 << align_pow);
}


/* get_text_align_fill_size ()

   Desired alignments:
      give the address
      target_size = size of next instruction
      align_pow = get_text_align_power (target_size).
      use_nops = 0
      use_no_density = 0;
   Loop alignments:
      address = current address + loop instruction size;
      target_size = 3 (for 2 or 3 byte target)
                  = 4 (for 4 byte target)
                  = 8 (for 8 byte target)
      align_pow = get_text_align_power (target_size);
      use_nops = 1
      use_no_density = set appropriately
   Text alignments:
      address = current address + loop instruction size;
      target_size = 0
      align_pow = get_text_align_power (target_size);
      use_nops = 0
      use_no_density = 0.  */

static addressT
get_text_align_fill_size (addressT address,
			  int align_pow,
			  int target_size,
			  bfd_boolean use_nops,
			  bfd_boolean use_no_density)
{
  /* Input arguments:

     align_pow: log2 (required alignment).

     target_size: alignment must allow the new_address and
     new_address+target_size-1.

     use_nops: if TRUE, then we can only use 2- or 3-byte nops.

     use_no_density: if use_nops and use_no_density, we can only use
     3-byte nops.

     Usually the align_pow is the power of 2 that is greater than 
     or equal to the target_size.  This handles the 2-byte, 3-byte 
     and 8-byte instructions.

     Two cases:

     (1) aligning an instruction properly, but without using NOPs.
       E.G.: a 3-byte instruction can go on any address where address mod 4
       is zero or one.  The aligner uses this case to find the optimal
       number of fill bytes for relax_frag_for_align.

     (2) aligning an instruction properly, but where we might need to use
       extra NOPs.  E.G.: when the aligner couldn't find enough widenings
       or similar to get the optimal location.  */

  size_t alignment = (1 << align_pow);

  assert (target_size != 0);
  
  if (!use_nops)
    {
      unsigned fill_bytes;
      for (fill_bytes = 0; fill_bytes < alignment; fill_bytes++)
	{
	  addressT end_address = address + target_size - 1 + fill_bytes;
	  addressT start_address = address + fill_bytes;
	  if ((end_address >> align_pow) == (start_address >> align_pow))
	    return fill_bytes;
	}
      assert (0);
    }

  /* This is the slightly harder case.  */
  assert ((int) alignment >= target_size);
  assert (target_size > 0);
  if (!use_no_density)
    {
      size_t i;
      for (i = 0; i < alignment * 2; i++)
	{
	  if (i == 1)
	    continue;
	  if ((address + i) >> align_pow
	      == (address + i + target_size - 1) >> align_pow)
	    return i;
	}
    }
  else
    {
      size_t i;

      /* Can only fill multiples of 3.  */
      for (i = 0; i <= alignment * 3; i += 3)
	{
	  if ((address + i) >> align_pow
	      == (address + i + target_size - 1) >> align_pow)
	    return i;
	}
    }
  assert (0);
  return 0;
}


/* This will assert if it is not possible.  */

static size_t
get_text_align_nop_count (size_t fill_size, bfd_boolean use_no_density)
{
  size_t count = 0;
  if (use_no_density)
    {
      assert (fill_size % 3 == 0);
      return (fill_size / 3);
    }

  assert (fill_size != 1);	/* Bad argument.  */

  while (fill_size > 1)
    {
      size_t insn_size = 3;
      if (fill_size == 2 || fill_size == 4)
	insn_size = 2;
      fill_size -= insn_size;
      count++;
    }
  assert (fill_size != 1);	/* Bad algorithm.  */
  return count;
}


static size_t
get_text_align_nth_nop_size (size_t fill_size,
			     size_t n,
			     bfd_boolean use_no_density)
{
  size_t count = 0;

  assert (get_text_align_nop_count (fill_size, use_no_density) > n);

  if (use_no_density)
    return 3;

  while (fill_size > 1)
    {
      size_t insn_size = 3;
      if (fill_size == 2 || fill_size == 4)
	insn_size = 2;
      fill_size -= insn_size;
      count++;
      if (n + 1 == count)
	return insn_size;
    }
  assert (0);
  return 0;
}


/* For the given fragment, find the appropriate address
   for it to begin at if we are using NOPs to align it.  */

static addressT
get_noop_aligned_address (fragS *fragP, addressT address)
{
  /* The rule is: get next fragment's FIRST instruction.  Find
     the smallest number of bytes that need to be added to
     ensure that the next fragment's FIRST instruction will fit
     in a single word.
     
     E.G.,   2 bytes : 0, 1, 2 mod 4
	     3 bytes: 0, 1 mod 4
     
     If the FIRST instruction MIGHT be relaxed,
     assume that it will become a 3-byte instruction.
     
     Note again here that LOOP instructions are not bundleable,
     and this relaxation only applies to LOOP opcodes.  */
  
  size_t fill_size = 0;
  int first_insn_size;
  int loop_insn_size;
  addressT pre_opcode_bytes;
  size_t alignment;
  fragS *first_insn;
  xtensa_opcode opcode;
  bfd_boolean is_loop;

  assert (fragP->fr_type == rs_machine_dependent);
  assert (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE);

  /* Find the loop frag.  */
  first_insn = next_non_empty_frag (fragP);
  /* Now find the first insn frag.  */
  first_insn = next_non_empty_frag (first_insn);

  is_loop = next_frag_opcode_is_loop (fragP, &opcode);
  assert (is_loop);
  loop_insn_size = xg_get_single_size (opcode);

  pre_opcode_bytes = next_frag_pre_opcode_bytes (fragP);
  pre_opcode_bytes += loop_insn_size;

  /* For loops, the alignment depends on the size of the
     instruction following the loop, not the LOOP instruction.  */

  if (first_insn == NULL)
    return address;

  assert (first_insn->tc_frag_data.is_first_loop_insn);

  first_insn_size = frag_format_size (first_insn);

  if (first_insn_size == 2 || first_insn_size == XTENSA_UNDEFINED)
    first_insn_size = 3;	/* ISA specifies this */

  /* If it was 8, then we'll need a larger alignment for the section.  */
  alignment = get_text_align_power (first_insn_size);

  /* Is now_seg valid?  */
  record_alignment (now_seg, alignment);
  
  fill_size = get_text_align_fill_size
    (address + pre_opcode_bytes,
     get_text_align_power (first_insn_size),
     first_insn_size, TRUE, fragP->tc_frag_data.is_no_density);

  return address + fill_size;
}


/* 3 mechanisms for relaxing an alignment:

   Align to a power of 2.
   Align so the next fragment's instruction does not cross a word boundary.
   Align the current instruction so that if the next instruction
       were 3 bytes, it would not cross a word boundary.

   We can align with:

   zeros    - This is easy; always insert zeros.
   nops     - 3-byte and 2-byte instructions
              2 - 2-byte nop
              3 - 3-byte nop
              4 - 2 2-byte nops
              >=5 : 3-byte instruction + fn (n-3)
   widening - widen previous instructions.  */

static addressT
get_aligned_diff (fragS *fragP, addressT address, addressT *max_diff)
{
  addressT target_address, loop_insn_offset;
  int target_size;
  xtensa_opcode loop_opcode;
  bfd_boolean is_loop;
  int text_align_power;
  addressT opt_diff;

  assert (fragP->fr_type == rs_machine_dependent);
  switch (fragP->fr_subtype)
    {
    case RELAX_DESIRE_ALIGN:
      target_size = next_frag_format_size (fragP);
      if (target_size == XTENSA_UNDEFINED)
	target_size = 3;
      text_align_power = get_text_align_power (xtensa_fetch_width);
      opt_diff = get_text_align_fill_size (address, text_align_power,
					   target_size, FALSE, FALSE);

      *max_diff = opt_diff + xtensa_fetch_width
	- (target_size + ((address + opt_diff) % xtensa_fetch_width));
      assert (*max_diff >= opt_diff);
      return opt_diff;

    case RELAX_ALIGN_NEXT_OPCODE:
      target_size = next_frag_format_size (fragP);
      loop_insn_offset = 0;
      is_loop = next_frag_opcode_is_loop (fragP, &loop_opcode);
      assert (is_loop);

      /* If the loop has been expanded then the LOOP instruction
	 could be at an offset from this fragment.  */
      if (next_non_empty_frag(fragP)->tc_frag_data.slot_subtypes[0]
	  != RELAX_IMMED)
	loop_insn_offset = get_expanded_loop_offset (loop_opcode);

      if (target_size == 2)
	target_size = 3; /* ISA specifies this */

      /* In an ideal world, which is what we are shooting for here,
	 we wouldn't need to use any NOPs immediately prior to the
	 LOOP instruction.  If this approach fails, relax_frag_loop_align
	 will call get_noop_aligned_address.  */
      target_address =
	address + loop_insn_offset + xg_get_single_size (loop_opcode);
      text_align_power = get_text_align_power (target_size),
      opt_diff = get_text_align_fill_size (target_address, text_align_power,
					   target_size, FALSE, FALSE);

      *max_diff = xtensa_fetch_width
	- ((target_address + opt_diff) % xtensa_fetch_width)
	- target_size + opt_diff;
      assert (*max_diff >= opt_diff);
      return opt_diff;

    default:
      break;
    }
  assert (0);
  return 0;
}


/* md_relax_frag Hook and Helper Functions.  */

static long relax_frag_loop_align (fragS *, long);
static long relax_frag_for_align (fragS *, long);
static long relax_frag_immed
  (segT, fragS *, long, int, xtensa_format, int, int *, bfd_boolean);


/* Return the number of bytes added to this fragment, given that the
   input has been stretched already by "stretch".  */

long
xtensa_relax_frag (fragS *fragP, long stretch, int *stretched_p)
{
  xtensa_isa isa = xtensa_default_isa;
  int unreported = fragP->tc_frag_data.unreported_expansion;
  long new_stretch = 0;
  char *file_name;
  int line, lit_size;
  static xtensa_insnbuf vbuf = NULL;
  int slot, num_slots;
  xtensa_format fmt;

  as_where (&file_name, &line);
  new_logical_line (fragP->fr_file, fragP->fr_line);

  fragP->tc_frag_data.unreported_expansion = 0;

  switch (fragP->fr_subtype)
    {
    case RELAX_ALIGN_NEXT_OPCODE:
      /* Always convert.  */
      if (fragP->tc_frag_data.relax_seen)
	new_stretch = relax_frag_loop_align (fragP, stretch);
      break;

    case RELAX_LOOP_END:
      /* Do nothing.  */
      break;

    case RELAX_LOOP_END_ADD_NOP:
      /* Add a NOP and switch to .fill 0.  */
      new_stretch = relax_frag_add_nop (fragP);
      frag_wane (fragP);
      break;

    case RELAX_DESIRE_ALIGN:
      /* Do nothing. The narrowing before this frag will either align
         it or not.  */
      break;

    case RELAX_LITERAL:
    case RELAX_LITERAL_FINAL:
      return 0;

    case RELAX_LITERAL_NR:
      lit_size = 4;
      fragP->fr_subtype = RELAX_LITERAL_FINAL;
      assert (unreported == lit_size);
      memset (&fragP->fr_literal[fragP->fr_fix], 0, 4);
      fragP->fr_var -= lit_size;
      fragP->fr_fix += lit_size;
      new_stretch = 4;
      break;

    case RELAX_SLOTS:
      if (vbuf == NULL)
	vbuf = xtensa_insnbuf_alloc (isa);

      xtensa_insnbuf_from_chars (isa, vbuf, fragP->fr_opcode, 0);
      fmt = xtensa_format_decode (isa, vbuf);
      num_slots = xtensa_format_num_slots (isa, fmt);

      for (slot = 0; slot < num_slots; slot++)
	{
	  switch (fragP->tc_frag_data.slot_subtypes[slot])
	    {
	    case RELAX_NARROW:
	      if (fragP->tc_frag_data.relax_seen)
		new_stretch += relax_frag_for_align (fragP, stretch);
	      break;

	    case RELAX_IMMED:
	    case RELAX_IMMED_STEP1:
	    case RELAX_IMMED_STEP2:
	      /* Place the immediate.  */
	      new_stretch += relax_frag_immed
		(now_seg, fragP, stretch,
		 fragP->tc_frag_data.slot_subtypes[slot] - RELAX_IMMED,
		 fmt, slot, stretched_p, FALSE);
	      break;

	    default:
	      /* This is OK; see the note in xg_assemble_vliw_tokens.  */
	      break;
	    }
	}
      break;

    case RELAX_LITERAL_POOL_BEGIN:
    case RELAX_LITERAL_POOL_END:
    case RELAX_MAYBE_UNREACHABLE:
    case RELAX_MAYBE_DESIRE_ALIGN:
      /* No relaxation required.  */
      break;

    case RELAX_FILL_NOP:
    case RELAX_UNREACHABLE:
      if (fragP->tc_frag_data.relax_seen)
	new_stretch += relax_frag_for_align (fragP, stretch);
      break;

    default:
      as_bad (_("bad relaxation state"));
    }

  /* Tell gas we need another relaxation pass.  */
  if (! fragP->tc_frag_data.relax_seen) 
    {
      fragP->tc_frag_data.relax_seen = TRUE;
      *stretched_p = 1;
    }

  new_logical_line (file_name, line);
  return new_stretch;
}


static long
relax_frag_loop_align (fragS *fragP, long stretch)
{
  addressT old_address, old_next_address, old_size;
  addressT new_address, new_next_address, new_size;
  addressT growth;

  /* All the frags with relax_frag_for_alignment prior to this one in the
     section have been done, hopefully eliminating the need for a NOP here.
     But, this will put it in if necessary.  */

  /* Calculate the old address of this fragment and the next fragment.  */
  old_address = fragP->fr_address - stretch;
  old_next_address = (fragP->fr_address - stretch + fragP->fr_fix +
		      fragP->tc_frag_data.text_expansion[0]);
  old_size = old_next_address - old_address;

  /* Calculate the new address of this fragment and the next fragment.  */
  new_address = fragP->fr_address;
  new_next_address =
    get_noop_aligned_address (fragP, fragP->fr_address + fragP->fr_fix);
  new_size = new_next_address - new_address;

  growth = new_size - old_size;

  /* Fix up the text_expansion field and return the new growth.  */
  fragP->tc_frag_data.text_expansion[0] += growth;
  return growth;
}


/* Add a NOP instruction.  */

static long
relax_frag_add_nop (fragS *fragP)
{
  char *nop_buf = fragP->fr_literal + fragP->fr_fix;
  int length = fragP->tc_frag_data.is_no_density ? 3 : 2;
  assemble_nop (length, nop_buf);
  fragP->tc_frag_data.is_insn = TRUE;

  if (fragP->fr_var < length)
    {
      as_fatal (_("fr_var (%ld) < length (%d)"), fragP->fr_var, length);
      return 0;
    }

  fragP->fr_fix += length;
  fragP->fr_var -= length;
  return length;
}


static long future_alignment_required (fragS *, long);

static long
relax_frag_for_align (fragS *fragP, long stretch)
{
  /* Overview of the relaxation procedure for alignment:
     We can widen with NOPs or by widening instructions or by filling
     bytes after jump instructions.  Find the opportune places and widen
     them if necessary.  */

  long stretch_me;
  long diff;

  assert (fragP->fr_subtype == RELAX_FILL_NOP
	  || fragP->fr_subtype == RELAX_UNREACHABLE
	  || (fragP->fr_subtype == RELAX_SLOTS
	      && fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW));

  stretch_me = future_alignment_required (fragP, stretch);
  diff = stretch_me - fragP->tc_frag_data.text_expansion[0];
  if (diff == 0)
    return 0;

  if (diff < 0)
    {
      /* We expanded on a previous pass.  Can we shrink now?  */
      long shrink = fragP->tc_frag_data.text_expansion[0] - stretch_me;
      if (shrink <= stretch && stretch > 0)
	{
	  fragP->tc_frag_data.text_expansion[0] = stretch_me;
	  return -shrink;
	}
      return 0;
    }

  /* Below here, diff > 0.  */
  fragP->tc_frag_data.text_expansion[0] = stretch_me;

  return diff;
}


/* Return the address of the next frag that should be aligned.

   By "address" we mean the address it _would_ be at if there
   is no action taken to align it between here and the target frag.
   In other words, if no narrows and no fill nops are used between
   here and the frag to align, _even_if_ some of the frags we use
   to align targets have already expanded on a previous relaxation
   pass.

   Also, count each frag that may be used to help align the target.

   Return 0 if there are no frags left in the chain that need to be
   aligned.  */

static addressT
find_address_of_next_align_frag (fragS **fragPP,
				 int *wide_nops,
				 int *narrow_nops,
				 int *widens,
				 bfd_boolean *paddable)
{
  fragS *fragP = *fragPP;
  addressT address = fragP->fr_address;

  /* Do not reset the counts to 0.  */

  while (fragP)
    {
      /* Limit this to a small search.  */
      if (*widens > 8)
	{
	  *fragPP = fragP;
	  return 0;
	}
      address += fragP->fr_fix;

      if (fragP->fr_type == rs_fill)
	address += fragP->fr_offset * fragP->fr_var;
      else if (fragP->fr_type == rs_machine_dependent)
	{
	  switch (fragP->fr_subtype)
	    {
	    case RELAX_UNREACHABLE:
	      *paddable = TRUE;
	      break;

	    case RELAX_FILL_NOP:
	      (*wide_nops)++;
	      if (!fragP->tc_frag_data.is_no_density)
		(*narrow_nops)++;
	      break;

	    case RELAX_SLOTS:
	      if (fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
		{
		  (*widens)++;
		  break;
		}
	      address += total_frag_text_expansion (fragP);;
	      break;

	    case RELAX_IMMED:
	      address += fragP->tc_frag_data.text_expansion[0];
	      break;

	    case RELAX_ALIGN_NEXT_OPCODE:
	    case RELAX_DESIRE_ALIGN:
	      *fragPP = fragP;
	      return address;

	    case RELAX_MAYBE_UNREACHABLE:
	    case RELAX_MAYBE_DESIRE_ALIGN:
	      /* Do nothing.  */
	      break;

	    default:
	      /* Just punt if we don't know the type.  */
	      *fragPP = fragP;
	      return 0;
	    }
	}
      else 
	{
	  /* Just punt if we don't know the type.  */
	  *fragPP = fragP;
	  return 0;
	}
      fragP = fragP->fr_next;
    }

  *fragPP = fragP;
  return 0;
}


static long bytes_to_stretch (fragS *, int, int, int, int);

/* Undefine LOOKAHEAD_ALIGNER to get the older behavior.
   I'll leave this in until I am more confident this works.  */

#define LOOKAHEAD_ALIGNER 1

static long
future_alignment_required (fragS *fragP, long stretch ATTRIBUTE_UNUSED)
{
  fragS *this_frag = fragP;
  long address;
  int num_widens = 0;
  int wide_nops = 0;
  int narrow_nops = 0;
  bfd_boolean paddable = FALSE;
  offsetT local_opt_diff;
  offsetT opt_diff;
  offsetT max_diff;
  int stretch_amount = 0;
  int local_stretch_amount;
  int global_stretch_amount;

  address = find_address_of_next_align_frag
    (&fragP, &wide_nops, &narrow_nops, &num_widens, &paddable);

  if (address)
    {
      local_opt_diff = get_aligned_diff (fragP, address, &max_diff);
      opt_diff = local_opt_diff;
      assert (opt_diff >= 0);
      assert (max_diff >= opt_diff);
      if (max_diff == 0) 
	return 0;
#ifdef LOOKAHEAD_ALIGNER
      if (fragP)
	fragP = fragP->fr_next;

      while (fragP && opt_diff < max_diff && address)
	{
	  /* We only use these to determine if we can exit early
	     because there will be plenty of ways to align future 
	     align frags.  */
	  unsigned int glob_widens = 0;
	  int dnn = 0;
	  int dw = 0;
	  bfd_boolean glob_pad = 0;
	  address = find_address_of_next_align_frag
	    (&fragP, &glob_widens, &dnn, &dw, &glob_pad);
	  /* If there is a padable portion, then skip.  */
	  if (glob_pad || (glob_widens >= xtensa_fetch_width))
	    break;

	  if (address) 
	    {
	      offsetT next_m_diff;
	      offsetT next_o_diff;

	      /* Downrange frags haven't had stretch added to them yet.  */
	      address += stretch;

	      /* The address also includes any text expansion from this
		 frag in a previous pass, but we don't want that.  */
	      address -= this_frag->tc_frag_data.text_expansion[0];

	      /* Assume we are going to move at least opt_diff.  In
		 reality, we might not be able to, but assuming that
		 we will helps catch cases where moving opt_diff pushes
		 the next target from aligned to unaligned.  */
	      address += opt_diff;

	      next_o_diff = get_aligned_diff (fragP, address, &next_m_diff);

	      /* Now cleanup for the adjustments to address.  */
	      next_o_diff += opt_diff;
	      next_m_diff += opt_diff;
	      if (next_o_diff <= max_diff && next_o_diff > opt_diff)
		opt_diff = next_o_diff;
	      if (next_m_diff < max_diff)
		max_diff = next_m_diff;
	      fragP = fragP->fr_next;
	    }
	}
#endif /* LOOKAHEAD_ALIGNER */
      /* If there are enough wideners in between, do it.  */
      if (paddable)
	{
	  if (this_frag->fr_subtype == RELAX_UNREACHABLE)
	    {
	      assert (opt_diff <= UNREACHABLE_MAX_WIDTH);
	      return opt_diff;
	    }
	  return 0;
	}
      local_stretch_amount 
	= bytes_to_stretch (this_frag, wide_nops, narrow_nops,
			    num_widens, local_opt_diff);
#ifdef LOOKAHEAD_ALIGNER
      global_stretch_amount 
	= bytes_to_stretch (this_frag, wide_nops, narrow_nops, 
			    num_widens, opt_diff);
      /* If the condition below is true, then the frag couldn't 
	 stretch the correct amount for the global case, so we just 
	 optimize locally.  We'll rely on the subsequent frags to get 
	 the correct alignment in the global case.  */
      if (global_stretch_amount < local_stretch_amount)
	stretch_amount = local_stretch_amount;
      else
	stretch_amount = global_stretch_amount;
#else /* ! LOOKAHEAD_ALIGNER */
      stretch_amount = local_stretch_amount;
#endif /* ! LOOKAHEAD_ALIGNER */
      if (this_frag->fr_subtype == RELAX_SLOTS
	  && this_frag->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
	assert (stretch_amount <= 1);
      else if (this_frag->fr_subtype == RELAX_FILL_NOP)
	{
	  if (this_frag->tc_frag_data.is_no_density)
	    assert (stretch_amount == 3 || stretch_amount == 0);
	  else
	    assert (stretch_amount <= 3);
	}
    }
  return stretch_amount;
}


/* The idea: widen everything you can to get a target or loop aligned,
   then start using NOPs.

   When we must have a NOP, here is a table of how we decide
   (so you don't have to fight through the control flow below):

   wide_nops   = the number of wide NOPs available for aligning
   narrow_nops = the number of narrow NOPs available for aligning
		 (a subset of wide_nops)
   widens      = the number of narrow instructions that should be widened

   Desired   wide   narrow
   Diff      nop    nop      widens
   1           0      0         1
   2           0      1         0
   3a          1      0         0
    b          0      1         1 (case 3a makes this case unnecessary)
   4a          1      0         1
    b          0      2         0
    c          0      1         2 (case 4a makes this case unnecessary)
   5a          1      0         2
    b          1      1         0
    c          0      2         1 (case 5b makes this case unnecessary)
   6a          2      0         0
    b          1      0         3
    c          0      1         4 (case 6b makes this case unneccesary)
    d          1      1         1 (case 6a makes this case unnecessary)
    e          0      2         2 (case 6a makes this case unnecessary)
    f          0      3         0 (case 6a makes this case unnecessary)
   7a          1      0         4
    b          2      0         1
    c          1      1         2 (case 7b makes this case unnecessary)
    d          0      1         5 (case 7a makes this case unnecessary)
    e          0      2         3 (case 7b makes this case unnecessary)
    f          0      3         1 (case 7b makes this case unnecessary)
    g          1      2         1 (case 7b makes this case unnecessary)
*/

static long
bytes_to_stretch (fragS *this_frag,
		  int wide_nops,
		  int narrow_nops,
		  int num_widens,
		  int desired_diff)
{
  int bytes_short = desired_diff - num_widens;

  assert (desired_diff >= 0 && desired_diff < 8);
  if (desired_diff == 0)
    return 0;
  
  assert (wide_nops > 0 || num_widens > 0);

  /* Always prefer widening to NOP-filling.  */
  if (bytes_short < 0)
    {
      /* There are enough RELAX_NARROW frags after this one
	 to align the target without widening this frag in any way.  */
      return 0;
    }
  
  if (bytes_short == 0)
    {
      /* Widen every narrow between here and the align target
	 and the align target will be properly aligned.  */
      if (this_frag->fr_subtype == RELAX_FILL_NOP)
	return 0;
      else
	return 1;
    }
  
  /* From here we will need at least one NOP to get an alignment.
     However, we may not be able to align at all, in which case,
     don't widen.  */
  if (this_frag->fr_subtype == RELAX_FILL_NOP)
    {
      switch (desired_diff)
	{
	case 1:
	  return 0;
	case 2:
	  if (!this_frag->tc_frag_data.is_no_density && narrow_nops == 1)
	    return 2; /* case 2 */
	  return 0;
	case 3: 
	  if (wide_nops > 1)
	    return 0;
	  else
	    return 3; /* case 3a */
	case 4:
	  if (num_widens >= 1 && wide_nops == 1)
	    return 3; /* case 4a */
	  if (!this_frag->tc_frag_data.is_no_density && narrow_nops == 2)
	    return 2; /* case 4b */
	  return 0;
	case 5:
	  if (num_widens >= 2 && wide_nops == 1)
	    return 3; /* case 5a */
	  /* We will need two nops.  Are there enough nops 
	     between here and the align target?  */
	  if (wide_nops < 2 || narrow_nops == 0)
	    return 0;
	  /* Are there other nops closer that can serve instead?  */
	  if (wide_nops > 2 && narrow_nops > 1)
	    return 0;
	  /* Take the density one first, because there might not be
	     another density one available.  */
	  if (!this_frag->tc_frag_data.is_no_density)
	    return 2; /* case 5b narrow */
	  else
	    return 3; /* case 5b wide */
	  return 0;
	case 6:
	  if (wide_nops == 2)
	    return 3; /* case 6a */
	  else if (num_widens >= 3 && wide_nops == 1)
	    return 3; /* case 6b */
	  return 0;
	case 7:
	  if (wide_nops == 1 && num_widens >= 4)
	    return 3; /* case 7a */
	  else if (wide_nops == 2 && num_widens >= 1)
	    return 3; /* case 7b */
	  return 0;
	default:
	  assert (0);
	}
    }
  else
    {
      /* We will need a NOP no matter what, but should we widen 
	 this instruction to help?

	 This is a RELAX_FRAG_NARROW frag.  */
      switch (desired_diff)
	{
	case 1:
	  assert (0);
	  return 0;
	case 2:
	case 3:
	  return 0;
	case 4:
	  if (wide_nops >= 1 && num_widens == 1)
	    return 1; /* case 4a */
	  return 0;
	case 5:
	  if (wide_nops >= 1 && num_widens == 2)
	    return 1; /* case 5a */
	  return 0;
	case 6:
	  if (wide_nops >= 2)
	    return 0; /* case 6a */
	  else if (wide_nops >= 1 && num_widens == 3)
	    return 1; /* case 6b */
	  return 0;
	case 7:
	  if (wide_nops >= 1 && num_widens == 4)
	    return 1; /* case 7a */
	  else if (wide_nops >= 2 && num_widens == 1)
	    return 1; /* case 7b */
	  return 0;
	default:
	  assert (0);
	  return 0;
	}
    }
  assert (0);
  return 0;
}


static long
relax_frag_immed (segT segP,
		  fragS *fragP,
		  long stretch,
		  int min_steps,
		  xtensa_format fmt,
		  int slot,
		  int *stretched_p,
		  bfd_boolean estimate_only)
{
  TInsn tinsn;
  vliw_insn orig_vinsn;
  int old_size;
  bfd_boolean negatable_branch = FALSE;
  bfd_boolean branch_jmp_to_next = FALSE;
  bfd_boolean wide_insn = FALSE;
  xtensa_isa isa = xtensa_default_isa;
  IStack istack;
  offsetT frag_offset;
  int num_steps;
  fragS *lit_fragP;
  int num_text_bytes, num_literal_bytes;
  int literal_diff, total_text_diff, this_text_diff, first;

  assert (fragP->fr_opcode != NULL);

  xg_init_vinsn (&orig_vinsn);
  vinsn_from_chars (&orig_vinsn, fragP->fr_opcode);
  if (xtensa_format_num_slots (isa, fmt) > 1)
    wide_insn = TRUE;

  tinsn = orig_vinsn.slots[slot];
  tinsn_immed_from_frag (&tinsn, fragP, slot);

  if (estimate_only && xtensa_opcode_is_loop (isa, tinsn.opcode))
    return 0;

  if (workaround_b_j_loop_end && ! fragP->tc_frag_data.is_no_transform)
    branch_jmp_to_next = is_branch_jmp_to_next (&tinsn, fragP);

  negatable_branch = (xtensa_opcode_is_branch (isa, tinsn.opcode) == 1);

  old_size = xtensa_format_length (isa, fmt);

  /* Special case: replace a branch to the next instruction with a NOP.
     This is required to work around a hardware bug in T1040.0 and also
     serves as an optimization.  */

  if (branch_jmp_to_next
      && ((old_size == 2) || (old_size == 3))
      && !next_frag_is_loop_target (fragP))
    return 0;

  /* Here is the fun stuff: Get the immediate field from this
     instruction.  If it fits, we are done.  If not, find the next
     instruction sequence that fits.  */

  frag_offset = fragP->fr_opcode - fragP->fr_literal;
  istack_init (&istack);
  num_steps = xg_assembly_relax (&istack, &tinsn, segP, fragP, frag_offset,
				 min_steps, stretch);
  if (num_steps < min_steps)
    {
      as_fatal (_("internal error: relaxation failed"));
      return 0;
    }

  if (num_steps > RELAX_IMMED_MAXSTEPS)
    {
      as_fatal (_("internal error: relaxation requires too many steps"));
      return 0;
    }

  fragP->tc_frag_data.slot_subtypes[slot] = (int) RELAX_IMMED + num_steps;

  /* Figure out the number of bytes needed.  */
  lit_fragP = 0;
  num_literal_bytes = get_num_stack_literal_bytes (&istack);
  literal_diff =
    num_literal_bytes - fragP->tc_frag_data.literal_expansion[slot];
  first = 0;
  while (istack.insn[first].opcode == XTENSA_UNDEFINED)
    first++;
  num_text_bytes = get_num_stack_text_bytes (&istack);
  if (wide_insn)
    {
      num_text_bytes += old_size;
      if (opcode_fits_format_slot (istack.insn[first].opcode, fmt, slot))
	num_text_bytes -= xg_get_single_size (istack.insn[first].opcode);
    }
  total_text_diff = num_text_bytes - old_size;
  this_text_diff = total_text_diff - fragP->tc_frag_data.text_expansion[slot];

  /* It MUST get larger.  If not, we could get an infinite loop.  */
  assert (num_text_bytes >= 0);
  assert (literal_diff >= 0);
  assert (total_text_diff >= 0);

  fragP->tc_frag_data.text_expansion[slot] = total_text_diff;
  fragP->tc_frag_data.literal_expansion[slot] = num_literal_bytes;
  assert (fragP->tc_frag_data.text_expansion[slot] >= 0);
  assert (fragP->tc_frag_data.literal_expansion[slot] >= 0);

  /* Find the associated expandable literal for this.  */
  if (literal_diff != 0)
    {
      lit_fragP = fragP->tc_frag_data.literal_frags[slot];
      if (lit_fragP)
	{
	  assert (literal_diff == 4);
	  lit_fragP->tc_frag_data.unreported_expansion += literal_diff;

	  /* We expect that the literal section state has NOT been
	     modified yet.  */
	  assert (lit_fragP->fr_type == rs_machine_dependent
		  && lit_fragP->fr_subtype == RELAX_LITERAL);
	  lit_fragP->fr_subtype = RELAX_LITERAL_NR;

	  /* We need to mark this section for another iteration
	     of relaxation.  */
	  (*stretched_p)++;
	}
    }

  if (negatable_branch && istack.ninsn > 1)
    update_next_frag_state (fragP);

  return this_text_diff;
}


/* md_convert_frag Hook and Helper Functions.  */

static void convert_frag_align_next_opcode (fragS *);
static void convert_frag_narrow (segT, fragS *, xtensa_format, int);
static void convert_frag_fill_nop (fragS *);
static void convert_frag_immed (segT, fragS *, int, xtensa_format, int);

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec, fragS *fragp)
{
  static xtensa_insnbuf vbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
  int slot;
  int num_slots;
  xtensa_format fmt;
  char *file_name;
  int line;

  as_where (&file_name, &line);
  new_logical_line (fragp->fr_file, fragp->fr_line);

  switch (fragp->fr_subtype)
    {
    case RELAX_ALIGN_NEXT_OPCODE:
      /* Always convert.  */
      convert_frag_align_next_opcode (fragp);
      break;

    case RELAX_DESIRE_ALIGN:
      /* Do nothing.  If not aligned already, too bad.  */
      break;

    case RELAX_LITERAL:
    case RELAX_LITERAL_FINAL:
      break;

    case RELAX_SLOTS:
      if (vbuf == NULL)
	vbuf = xtensa_insnbuf_alloc (isa);

      xtensa_insnbuf_from_chars (isa, vbuf, fragp->fr_opcode, 0);
      fmt = xtensa_format_decode (isa, vbuf);
      num_slots = xtensa_format_num_slots (isa, fmt);

      for (slot = 0; slot < num_slots; slot++)
	{
	  switch (fragp->tc_frag_data.slot_subtypes[slot])
	    {
	    case RELAX_NARROW:
	      convert_frag_narrow (sec, fragp, fmt, slot);
	      break;

	    case RELAX_IMMED:
	    case RELAX_IMMED_STEP1:
	    case RELAX_IMMED_STEP2:
	      /* Place the immediate.  */
	      convert_frag_immed
		(sec, fragp,
		 fragp->tc_frag_data.slot_subtypes[slot] - RELAX_IMMED,
		 fmt, slot);
	      break;

	    default:
	      /* This is OK because some slots could have
		 relaxations and others have none.  */
	      break;
	    }
	}
      break;

    case RELAX_UNREACHABLE:
      memset (&fragp->fr_literal[fragp->fr_fix], 0, fragp->fr_var);
      fragp->fr_fix += fragp->tc_frag_data.text_expansion[0];
      fragp->fr_var -= fragp->tc_frag_data.text_expansion[0];
      frag_wane (fragp);
      break;

    case RELAX_MAYBE_UNREACHABLE:
    case RELAX_MAYBE_DESIRE_ALIGN:
      frag_wane (fragp);
      break;

    case RELAX_FILL_NOP:
      convert_frag_fill_nop (fragp);
      break;

    case RELAX_LITERAL_NR:
      if (use_literal_section)
	{
	  /* This should have been handled during relaxation.  When
	     relaxing a code segment, literals sometimes need to be
	     added to the corresponding literal segment.  If that
	     literal segment has already been relaxed, then we end up
	     in this situation.  Marking the literal segments as data
	     would make this happen less often (since GAS always relaxes
	     code before data), but we could still get into trouble if
	     there are instructions in a segment that is not marked as
	     containing code.  Until we can implement a better solution,
	     cheat and adjust the addresses of all the following frags.
	     This could break subsequent alignments, but the linker's
	     literal coalescing will do that anyway.  */

	  fragS *f;
	  fragp->fr_subtype = RELAX_LITERAL_FINAL;
	  assert (fragp->tc_frag_data.unreported_expansion == 4);
	  memset (&fragp->fr_literal[fragp->fr_fix], 0, 4);
	  fragp->fr_var -= 4;
	  fragp->fr_fix += 4;
	  for (f = fragp->fr_next; f; f = f->fr_next)
	    f->fr_address += 4;
	}
      else
	as_bad (_("invalid relaxation fragment result"));
      break;
    }

  fragp->fr_var = 0;
  new_logical_line (file_name, line);
}


static void
convert_frag_align_next_opcode (fragS *fragp)
{
  char *nop_buf;		/* Location for Writing.  */
  size_t i;

  bfd_boolean use_no_density = fragp->tc_frag_data.is_no_density;
  addressT aligned_address;
  size_t fill_size, nop_count;

  aligned_address = get_noop_aligned_address (fragp, fragp->fr_address +
					      fragp->fr_fix);
  fill_size = aligned_address - (fragp->fr_address + fragp->fr_fix);
  nop_count = get_text_align_nop_count (fill_size, use_no_density);
  nop_buf = fragp->fr_literal + fragp->fr_fix;

  for (i = 0; i < nop_count; i++)
    {
      size_t nop_size;
      nop_size = get_text_align_nth_nop_size (fill_size, i, use_no_density);

      assemble_nop (nop_size, nop_buf);
      nop_buf += nop_size;
    }

  fragp->fr_fix += fill_size;
  fragp->fr_var -= fill_size;
}


static void
convert_frag_narrow (segT segP, fragS *fragP, xtensa_format fmt, int slot)
{
  TInsn tinsn, single_target;
  xtensa_format single_fmt;
  int size, old_size, diff, error_val;
  offsetT frag_offset;

  assert (slot == 0);
  tinsn_from_chars (&tinsn, fragP->fr_opcode, 0);

  if (xtensa_opcode_is_branch (xtensa_default_isa, tinsn.opcode) == 1)
    {
      assert (fragP->tc_frag_data.text_expansion[0] == 1
	      || fragP->tc_frag_data.text_expansion[0] == 0);
      convert_frag_immed (segP, fragP, fragP->tc_frag_data.text_expansion[0],
			  fmt, slot);
      return;
    }

  if (fragP->tc_frag_data.text_expansion[0] == 0)
    {
      /* No conversion.  */
      fragP->fr_var = 0;
      return;
    }

  assert (fragP->fr_opcode != NULL);

  /* Frags in this relaxation state should only contain
     single instruction bundles.  */
  tinsn_immed_from_frag (&tinsn, fragP, 0);

  /* Just convert it to a wide form....  */
  size = 0;
  old_size = xg_get_single_size (tinsn.opcode);

  tinsn_init (&single_target);
  frag_offset = fragP->fr_opcode - fragP->fr_literal;

  error_val = xg_expand_narrow (&single_target, &tinsn);
  if (error_val)
    {
      as_bad (_("unable to widen instruction"));
      return;
    }

  size = xg_get_single_size (single_target.opcode);
  single_fmt = xg_get_single_format (single_target.opcode);

  xg_emit_insn_to_buf (&single_target, single_fmt, fragP->fr_opcode,
		       fragP, frag_offset, TRUE);

  diff = size - old_size;
  assert (diff >= 0);
  assert (diff <= fragP->fr_var);
  fragP->fr_var -= diff;
  fragP->fr_fix += diff;

  /* clean it up */
  fragP->fr_var = 0;
}


static void
convert_frag_fill_nop (fragS *fragP)
{
  char *loc = &fragP->fr_literal[fragP->fr_fix];
  int size = fragP->tc_frag_data.text_expansion[0];
  assert ((unsigned) size == (fragP->fr_next->fr_address
			      - fragP->fr_address - fragP->fr_fix));
  if (size == 0)
    {
      /* No conversion.  */
      fragP->fr_var = 0;
      return;
    }
  assemble_nop (size, loc);
  fragP->tc_frag_data.is_insn = TRUE;
  fragP->fr_var -= size;
  fragP->fr_fix += size;
  frag_wane (fragP);
}


static fixS *fix_new_exp_in_seg
  (segT, subsegT, fragS *, int, int, expressionS *, int,
   bfd_reloc_code_real_type);
static void convert_frag_immed_finish_loop (segT, fragS *, TInsn *);

static void
convert_frag_immed (segT segP,
		    fragS *fragP,
		    int min_steps,
		    xtensa_format fmt,
		    int slot)
{
  char *immed_instr = fragP->fr_opcode;
  TInsn orig_tinsn;
  bfd_boolean expanded = FALSE;
  bfd_boolean branch_jmp_to_next = FALSE;
  char *fr_opcode = fragP->fr_opcode;
  vliw_insn orig_vinsn;
  xtensa_isa isa = xtensa_default_isa;
  bfd_boolean wide_insn = FALSE;
  int bytes;
  bfd_boolean is_loop;

  assert (fr_opcode != NULL);

  xg_init_vinsn (&orig_vinsn);

  vinsn_from_chars (&orig_vinsn, fr_opcode);
  if (xtensa_format_num_slots (isa, fmt) > 1)
    wide_insn = TRUE;

  orig_tinsn = orig_vinsn.slots[slot];
  tinsn_immed_from_frag (&orig_tinsn, fragP, slot);

  is_loop = xtensa_opcode_is_loop (xtensa_default_isa, orig_tinsn.opcode) == 1;

  if (workaround_b_j_loop_end && ! fragP->tc_frag_data.is_no_transform)
    branch_jmp_to_next = is_branch_jmp_to_next (&orig_tinsn, fragP);

  if (branch_jmp_to_next && !next_frag_is_loop_target (fragP))
    {
      /* Conversion just inserts a NOP and marks the fix as completed.  */
      bytes = xtensa_format_length (isa, fmt);
      if (bytes >= 4)
	{
	  orig_vinsn.slots[slot].opcode =
	    xtensa_format_slot_nop_opcode (isa, orig_vinsn.format, slot);
	  orig_vinsn.slots[slot].ntok = 0;
	}
      else
	{
	  bytes += fragP->tc_frag_data.text_expansion[0];
	  assert (bytes == 2 || bytes == 3);
	  build_nop (&orig_vinsn.slots[0], bytes);
	  fragP->fr_fix += fragP->tc_frag_data.text_expansion[0];
	}
      vinsn_to_insnbuf (&orig_vinsn, fr_opcode, frag_now, FALSE);
      xtensa_insnbuf_to_chars (isa, orig_vinsn.insnbuf, fr_opcode, 0);
      fragP->fr_var = 0;
    }
  else if (!orig_tinsn.is_specific_opcode)
    {
      /* Here is the fun stuff:  Get the immediate field from this
	 instruction.  If it fits, we're done.  If not, find the next
	 instruction sequence that fits.  */

      IStack istack;
      int i;
      symbolS *lit_sym = NULL;
      int total_size = 0;
      int target_offset = 0;
      int old_size;
      int diff;
      symbolS *gen_label = NULL;
      offsetT frag_offset;
      bfd_boolean first = TRUE;
      bfd_boolean last_is_jump;

      /* It does not fit.  Find something that does and
         convert immediately.  */
      frag_offset = fr_opcode - fragP->fr_literal;
      istack_init (&istack);
      xg_assembly_relax (&istack, &orig_tinsn,
			 segP, fragP, frag_offset, min_steps, 0);

      old_size = xtensa_format_length (isa, fmt);

      /* Assemble this right inline.  */

      /* First, create the mapping from a label name to the REAL label.  */
      target_offset = 0;
      for (i = 0; i < istack.ninsn; i++)
	{
	  TInsn *tinsn = &istack.insn[i];
	  fragS *lit_frag;

	  switch (tinsn->insn_type)
	    {
	    case ITYPE_LITERAL:
	      if (lit_sym != NULL)
		as_bad (_("multiple literals in expansion"));
	      /* First find the appropriate space in the literal pool.  */
	      lit_frag = fragP->tc_frag_data.literal_frags[slot];
	      if (lit_frag == NULL)
		as_bad (_("no registered fragment for literal"));
	      if (tinsn->ntok != 1)
		as_bad (_("number of literal tokens != 1"));

	      /* Set the literal symbol and add a fixup.  */
	      lit_sym = lit_frag->fr_symbol;
	      break;

	    case ITYPE_LABEL:
	      if (align_targets && !is_loop)
		{
		  fragS *unreach = fragP->fr_next;
		  while (!(unreach->fr_type == rs_machine_dependent
			   && (unreach->fr_subtype == RELAX_MAYBE_UNREACHABLE
			       || unreach->fr_subtype == RELAX_UNREACHABLE)))
		    {
		      unreach = unreach->fr_next;
		    }

		  assert (unreach->fr_type == rs_machine_dependent
			  && (unreach->fr_subtype == RELAX_MAYBE_UNREACHABLE
			      || unreach->fr_subtype == RELAX_UNREACHABLE));

		  target_offset += unreach->tc_frag_data.text_expansion[0];
		}
	      assert (gen_label == NULL);
	      gen_label = symbol_new (FAKE_LABEL_NAME, now_seg,
				      fr_opcode - fragP->fr_literal
				      + target_offset, fragP);
	      break;

	    case ITYPE_INSN:
	      if (first && wide_insn)
		{
		  target_offset += xtensa_format_length (isa, fmt);
		  first = FALSE;
		  if (!opcode_fits_format_slot (tinsn->opcode, fmt, slot))
		    target_offset += xg_get_single_size (tinsn->opcode);
		}
	      else
		target_offset += xg_get_single_size (tinsn->opcode);
	      break;
	    }
	}

      total_size = 0;
      first = TRUE;
      last_is_jump = FALSE;
      for (i = 0; i < istack.ninsn; i++)
	{
	  TInsn *tinsn = &istack.insn[i];
	  fragS *lit_frag;
	  int size;
	  segT target_seg;
	  bfd_reloc_code_real_type reloc_type;

	  switch (tinsn->insn_type)
	    {
	    case ITYPE_LITERAL:
	      lit_frag = fragP->tc_frag_data.literal_frags[slot];
	      /* Already checked.  */
	      assert (lit_frag != NULL);
	      assert (lit_sym != NULL);
	      assert (tinsn->ntok == 1);
	      /* Add a fixup.  */
	      target_seg = S_GET_SEGMENT (lit_sym);
	      assert (target_seg);
	      if (tinsn->tok[0].X_op == O_pltrel)
		reloc_type = BFD_RELOC_XTENSA_PLT;
	      else
		reloc_type = BFD_RELOC_32;
	      fix_new_exp_in_seg (target_seg, 0, lit_frag, 0, 4,
				  &tinsn->tok[0], FALSE, reloc_type);
	      break;

	    case ITYPE_LABEL:
	      break;

	    case ITYPE_INSN:
	      xg_resolve_labels (tinsn, gen_label);
	      xg_resolve_literals (tinsn, lit_sym);
	      if (wide_insn && first)
		{
		  first = FALSE;
		  if (opcode_fits_format_slot (tinsn->opcode, fmt, slot))
		    {
		      tinsn->record_fix = TRUE;
		      orig_vinsn.slots[slot] = *tinsn;
		    }
		  else
		    {
		      orig_vinsn.slots[slot].opcode =
			xtensa_format_slot_nop_opcode (isa, fmt, slot);
		      orig_vinsn.slots[slot].ntok = 0;
		      orig_vinsn.slots[slot].record_fix = FALSE;
		    }
		  vinsn_to_insnbuf (&orig_vinsn, immed_instr, fragP, TRUE);
		  xtensa_insnbuf_to_chars (isa, orig_vinsn.insnbuf,
					   immed_instr, 0);
		  fragP->tc_frag_data.is_insn = TRUE;
		  size = xtensa_format_length (isa, fmt);
		  if (!opcode_fits_format_slot (tinsn->opcode, fmt, slot))
		    {
		      xtensa_format single_fmt =
			xg_get_single_format (tinsn->opcode);

		      xg_emit_insn_to_buf
			(tinsn, single_fmt, immed_instr + size, fragP,
			 immed_instr - fragP->fr_literal + size, TRUE);
		      size += xg_get_single_size (tinsn->opcode);
		    }
		}
	      else
		{
		  xtensa_format single_format;
		  size = xg_get_single_size (tinsn->opcode);
		  single_format = xg_get_single_format (tinsn->opcode);
		  xg_emit_insn_to_buf (tinsn, single_format, immed_instr,
				       fragP,
				       immed_instr - fragP->fr_literal, TRUE);
#if 0
		  /* Code to recognize branch-around expansion
		     so the fragment is properly marked as ending in a
		     jump. */
		  if ((((i == istack.ninsn - 2)
			&& (istack.insn[istack.ninsn-1].insn_type
			    == ITYPE_LABEL))
		       || i == istack.ninsn -1)
		      && xtensa_opcode_is_jump (xtensa_default_isa,
						tinsn->opcode) == 1
		      && fragP->fr_next != NULL
		      && ! fragP->fr_next->tc_frag_data.is_unreachable)
		    {
		      /* Create a new unreachable frag of zero size.  */
		      size_t frag_size = sizeof (fragS);
		      fragS *new_fragP = (fragS *) xmalloc (frag_size);
		      memset (new_fragP, 0, frag_size);
		      new_fragP->fr_address = fragP->fr_next->fr_address;
		      new_fragP->fr_next = fragP->fr_next;
		      new_fragP->fr_fix = 0;
		      new_fragP->fr_var = 0;
		      new_fragP->fr_type = rs_fill;
		      new_fragP->tc_frag_data.is_unreachable = TRUE;
		      /* The rest are zeros....  */
		      /* Link it in to the chain.  */
		      fragP->fr_next = new_fragP;
		    }
#endif
		}
	      immed_instr += size;
	      total_size += size;
	      break;
	    }
	}

      diff = total_size - old_size;
      assert (diff >= 0);
      if (diff != 0)
	expanded = TRUE;
      assert (diff <= fragP->fr_var);
      fragP->fr_var -= diff;
      fragP->fr_fix += diff;
    }

  /* Clean it up.  */
  xg_free_vinsn (&orig_vinsn);

  /* Check for undefined immediates in LOOP instructions.  */
  if (is_loop)
    {
      symbolS *sym;
      sym = orig_tinsn.tok[1].X_add_symbol;
      if (sym != NULL && !S_IS_DEFINED (sym))
	{
	  as_bad (_("unresolved loop target symbol: %s"), S_GET_NAME (sym));
	  return;
	}
      sym = orig_tinsn.tok[1].X_op_symbol;
      if (sym != NULL && !S_IS_DEFINED (sym))
	{
	  as_bad (_("unresolved loop target symbol: %s"), S_GET_NAME (sym));
	  return;
	}
    }

  if (expanded && xtensa_opcode_is_loop (isa, orig_tinsn.opcode) == 1)
    convert_frag_immed_finish_loop (segP, fragP, &orig_tinsn);

  if (expanded && is_direct_call_opcode (orig_tinsn.opcode))
    {
      /* Add an expansion note on the expanded instruction.  */
      fix_new_exp_in_seg (now_seg, 0, fragP, fr_opcode - fragP->fr_literal, 4,
			  &orig_tinsn.tok[0], TRUE,
			  BFD_RELOC_XTENSA_ASM_EXPAND);
    }
}


/* Add a new fix expression into the desired segment.  We have to
   switch to that segment to do this.  */

static fixS *
fix_new_exp_in_seg (segT new_seg,
		    subsegT new_subseg,
		    fragS *frag,
		    int where,
		    int size,
		    expressionS *exp,
		    int pcrel,
		    bfd_reloc_code_real_type r_type)
{
  fixS *new_fix;
  segT seg = now_seg;
  subsegT subseg = now_subseg;

  assert (new_seg != 0);
  subseg_set (new_seg, new_subseg);

  new_fix = fix_new_exp (frag, where, size, exp, pcrel, r_type);
  subseg_set (seg, subseg);
  return new_fix;
}


/* Relax a loop instruction so that it can span loop >256 bytes.

                  loop    as, .L1
          .L0:
                  rsr     as, LEND
                  wsr     as, LBEG
                  addi    as, as, lo8 (label-.L1)
                  addmi   as, as, mid8 (label-.L1)
                  wsr     as, LEND
                  isync
                  rsr     as, LCOUNT
                  addi    as, as, 1
          .L1:
                  <<body>>
          label:
*/

static void
convert_frag_immed_finish_loop (segT segP, fragS *fragP, TInsn *tinsn)
{
  TInsn loop_insn;
  TInsn addi_insn;
  TInsn addmi_insn;
  unsigned long target;
  static xtensa_insnbuf insnbuf = NULL;
  unsigned int loop_length, loop_length_hi, loop_length_lo;
  xtensa_isa isa = xtensa_default_isa;
  addressT loop_offset;
  addressT addi_offset = 9;
  addressT addmi_offset = 12;
  fragS *next_fragP;
  size_t target_count;

  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

  /* Get the loop offset.  */
  loop_offset = get_expanded_loop_offset (tinsn->opcode);

  /* Validate that there really is a LOOP at the loop_offset.  Because
     loops are not bundleable, we can assume that the instruction will be
     in slot 0.  */
  tinsn_from_chars (&loop_insn, fragP->fr_opcode + loop_offset, 0);
  tinsn_immed_from_frag (&loop_insn, fragP, 0);

  assert (xtensa_opcode_is_loop (isa, loop_insn.opcode) == 1);
  addi_offset += loop_offset;
  addmi_offset += loop_offset;

  assert (tinsn->ntok == 2);
  if (tinsn->tok[1].X_op == O_constant)
    target = tinsn->tok[1].X_add_number;
  else if (tinsn->tok[1].X_op == O_symbol)
    {
      /* Find the fragment.  */
      symbolS *sym = tinsn->tok[1].X_add_symbol;
      assert (S_GET_SEGMENT (sym) == segP
	      || S_GET_SEGMENT (sym) == absolute_section);
      target = (S_GET_VALUE (sym) + tinsn->tok[1].X_add_number);
    }
  else
    {
      as_bad (_("invalid expression evaluation type %d"), tinsn->tok[1].X_op);
      target = 0;
    }

  know (symbolP);
  know (symbolP->sy_frag);
  know (!(S_GET_SEGMENT (symbolP) == absolute_section)
	|| symbol_get_frag (symbolP) == &zero_address_frag);

  loop_length = target - (fragP->fr_address + fragP->fr_fix);
  loop_length_hi = loop_length & ~0x0ff;
  loop_length_lo = loop_length & 0x0ff;
  if (loop_length_lo >= 128)
    {
      loop_length_lo -= 256;
      loop_length_hi += 256;
    }

  /* Because addmi sign-extends the immediate, 'loop_length_hi' can be at most
     32512.  If the loop is larger than that, then we just fail.  */
  if (loop_length_hi > 32512)
    as_bad_where (fragP->fr_file, fragP->fr_line,
		  _("loop too long for LOOP instruction"));

  tinsn_from_chars (&addi_insn, fragP->fr_opcode + addi_offset, 0);
  assert (addi_insn.opcode == xtensa_addi_opcode);

  tinsn_from_chars (&addmi_insn, fragP->fr_opcode + addmi_offset, 0);
  assert (addmi_insn.opcode == xtensa_addmi_opcode);

  set_expr_const (&addi_insn.tok[2], loop_length_lo);
  tinsn_to_insnbuf (&addi_insn, insnbuf);

  fragP->tc_frag_data.is_insn = TRUE;
  xtensa_insnbuf_to_chars (isa, insnbuf, fragP->fr_opcode + addi_offset, 0);

  set_expr_const (&addmi_insn.tok[2], loop_length_hi);
  tinsn_to_insnbuf (&addmi_insn, insnbuf);
  xtensa_insnbuf_to_chars (isa, insnbuf, fragP->fr_opcode + addmi_offset, 0);

  /* Walk through all of the frags from here to the loop end
     and mark them as no_transform to keep them from being modified
     by the linker.  If we ever have a relocation for the
     addi/addmi of the difference of two symbols we can remove this.  */

  target_count = 0;
  for (next_fragP = fragP; next_fragP != NULL;
       next_fragP = next_fragP->fr_next)
    {
      next_fragP->tc_frag_data.is_no_transform = TRUE;
      if (next_fragP->tc_frag_data.is_loop_target)
	target_count++;
      if (target_count == 2)
	break;
    }
}


/* A map that keeps information on a per-subsegment basis.  This is
   maintained during initial assembly, but is invalid once the
   subsegments are smashed together.  I.E., it cannot be used during
   the relaxation.  */

typedef struct subseg_map_struct
{
  /* the key */
  segT seg;
  subsegT subseg;

  /* the data */
  unsigned flags;
  float total_freq;	/* fall-through + branch target frequency */
  float target_freq;	/* branch target frequency alone */

  struct subseg_map_struct *next;
} subseg_map;


static subseg_map *sseg_map = NULL;

static subseg_map *
get_subseg_info (segT seg, subsegT subseg)
{
  subseg_map *subseg_e;

  for (subseg_e = sseg_map; subseg_e; subseg_e = subseg_e->next)
    {
      if (seg == subseg_e->seg && subseg == subseg_e->subseg)
	break;
    }
  return subseg_e;
}


static subseg_map *
add_subseg_info (segT seg, subsegT subseg)
{
  subseg_map *subseg_e = (subseg_map *) xmalloc (sizeof (subseg_map));
  memset (subseg_e, 0, sizeof (subseg_map));
  subseg_e->seg = seg;
  subseg_e->subseg = subseg;
  subseg_e->flags = 0;
  /* Start off considering every branch target very important.  */
  subseg_e->target_freq = 1.0;
  subseg_e->total_freq = 1.0;
  subseg_e->next = sseg_map;
  sseg_map = subseg_e;
  return subseg_e;
}


static unsigned
get_last_insn_flags (segT seg, subsegT subseg)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (subseg_e)
    return subseg_e->flags;
  return 0;
}


static void
set_last_insn_flags (segT seg,
		     subsegT subseg,
		     unsigned fl,
		     bfd_boolean val)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (! subseg_e)
    subseg_e = add_subseg_info (seg, subseg);
  if (val)
    subseg_e->flags |= fl;
  else
    subseg_e->flags &= ~fl;
}


static float
get_subseg_total_freq (segT seg, subsegT subseg)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (subseg_e)
    return subseg_e->total_freq;
  return 1.0;
}


static float
get_subseg_target_freq (segT seg, subsegT subseg)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (subseg_e)
    return subseg_e->target_freq;
  return 1.0;
}


static void
set_subseg_freq (segT seg, subsegT subseg, float total_f, float target_f)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (! subseg_e)
    subseg_e = add_subseg_info (seg, subseg);
  subseg_e->total_freq = total_f;
  subseg_e->target_freq = target_f;
}


/* Segment Lists and emit_state Stuff.  */

/* Remove the segment from the global sections list.  */

static void
xtensa_remove_section (segT sec)
{
  /* Handle brain-dead bfd_section_list_remove macro, which
     expect the address of the prior section's "next" field, not
     just the address of the section to remove.  */

  segT *ps_next_ptr = &stdoutput->sections;
  while (*ps_next_ptr != sec && *ps_next_ptr != NULL) 
    ps_next_ptr = &(*ps_next_ptr)->next;
  
  assert (*ps_next_ptr != NULL);

  bfd_section_list_remove (stdoutput, ps_next_ptr);
}


static void
xtensa_insert_section (segT after_sec, segT sec)
{
  segT *after_sec_next;
  if (after_sec == NULL)
    after_sec_next = &stdoutput->sections;
  else
    after_sec_next = &after_sec->next;

  bfd_section_list_insert (stdoutput, after_sec_next, sec);
}


static void
xtensa_move_seg_list_to_beginning (seg_list *head)
{
  head = head->next;
  while (head)
    {
      segT literal_section = head->seg;

      /* Move the literal section to the front of the section list.  */
      assert (literal_section);
      xtensa_remove_section (literal_section);
      xtensa_insert_section (NULL, literal_section);

      head = head->next;
    }
}


static void mark_literal_frags (seg_list *);

static void
xtensa_move_literals (void)
{
  seg_list *segment;
  frchainS *frchain_from, *frchain_to;
  fragS *search_frag, *next_frag, *last_frag, *literal_pool, *insert_after;
  fragS **frag_splice;
  emit_state state;
  segT dest_seg;
  fixS *fix, *next_fix, **fix_splice;
  sym_list *lit;

  mark_literal_frags (literal_head->next);
  mark_literal_frags (init_literal_head->next);
  mark_literal_frags (fini_literal_head->next);

  if (use_literal_section)
    return;

  segment = literal_head->next;
  while (segment)
    {
      frchain_from = seg_info (segment->seg)->frchainP;
      search_frag = frchain_from->frch_root;
      literal_pool = NULL;
      frchain_to = NULL;
      frag_splice = &(frchain_from->frch_root);

      while (!search_frag->tc_frag_data.literal_frag)
	{
	  assert (search_frag->fr_fix == 0
		  || search_frag->fr_type == rs_align);
	  search_frag = search_frag->fr_next;
	}

      assert (search_frag->tc_frag_data.literal_frag->fr_subtype
	      == RELAX_LITERAL_POOL_BEGIN);
      xtensa_switch_section_emit_state (&state, segment->seg, 0);

      /* Make sure that all the frags in this series are closed, and
	 that there is at least one left over of zero-size.  This
	 prevents us from making a segment with an frchain without any
	 frags in it.  */
      frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
      xtensa_set_frag_assembly_state (frag_now);
      last_frag = frag_now;
      frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
      xtensa_set_frag_assembly_state (frag_now);

      while (search_frag != frag_now)
	{
	  next_frag = search_frag->fr_next;

	  /* First, move the frag out of the literal section and
	     to the appropriate place.  */
	  if (search_frag->tc_frag_data.literal_frag)
	    {
	      literal_pool = search_frag->tc_frag_data.literal_frag;
	      assert (literal_pool->fr_subtype == RELAX_LITERAL_POOL_BEGIN);
	      /* Note that we set this fr_var to be a fix
		 chain when we created the literal pool location
		 as RELAX_LITERAL_POOL_BEGIN.  */
	      frchain_to = (frchainS *) literal_pool->fr_var;
	    }
	  insert_after = literal_pool;

	  while (insert_after->fr_next->fr_subtype != RELAX_LITERAL_POOL_END)
	    insert_after = insert_after->fr_next;

	  dest_seg = (segT) insert_after->fr_next->fr_var;

	  *frag_splice = next_frag;
	  search_frag->fr_next = insert_after->fr_next;
	  insert_after->fr_next = search_frag;
	  search_frag->tc_frag_data.lit_seg = dest_seg;

	  /* Now move any fixups associated with this frag to the
	     right section.  */
	  fix = frchain_from->fix_root;
	  fix_splice = &(frchain_from->fix_root);
	  while (fix)
	    {
	      next_fix = fix->fx_next;
	      if (fix->fx_frag == search_frag)
		{
		  *fix_splice = next_fix;
		  fix->fx_next = frchain_to->fix_root;
		  frchain_to->fix_root = fix;
		  if (frchain_to->fix_tail == NULL)
		    frchain_to->fix_tail = fix;
		}
	      else
		fix_splice = &(fix->fx_next);
	      fix = next_fix;
	    }
	  search_frag = next_frag;
	}

      if (frchain_from->fix_root != NULL)
	{
	  frchain_from = seg_info (segment->seg)->frchainP;
	  as_warn (_("fixes not all moved from %s"), segment->seg->name);

	  assert (frchain_from->fix_root == NULL);
	}
      frchain_from->fix_tail = NULL;
      xtensa_restore_emit_state (&state);
      segment = segment->next;
    }

  /* Now fix up the SEGMENT value for all the literal symbols.  */
  for (lit = literal_syms; lit; lit = lit->next)
    {
      symbolS *lit_sym = lit->sym;
      segT dest_seg = symbol_get_frag (lit_sym)->tc_frag_data.lit_seg;
      if (dest_seg)
	S_SET_SEGMENT (lit_sym, dest_seg);
    }
}


/* Walk over all the frags for segments in a list and mark them as
   containing literals.  As clunky as this is, we can't rely on frag_var
   and frag_variant to get called in all situations.  */

static void
mark_literal_frags (seg_list *segment)
{
  frchainS *frchain_from;
  fragS *search_frag;

  while (segment)
    {
      frchain_from = seg_info (segment->seg)->frchainP;
      search_frag = frchain_from->frch_root;
      while (search_frag) 
	{
	  search_frag->tc_frag_data.is_literal = TRUE;
	  search_frag = search_frag->fr_next;
	}
      segment = segment->next;
    }
}


static void
xtensa_reorder_seg_list (seg_list *head, segT after)
{
  /* Move all of the sections in the section list to come
     after "after" in the gnu segment list.  */

  head = head->next;
  while (head)
    {
      segT literal_section = head->seg;

      /* Move the literal section after "after".  */
      assert (literal_section);
      if (literal_section != after)
	{
	  xtensa_remove_section (literal_section);
	  xtensa_insert_section (after, literal_section);
	}

      head = head->next;
    }
}


/* Push all the literal segments to the end of the gnu list.  */

static void
xtensa_reorder_segments (void)
{
  segT sec;
  segT last_sec = 0;
  int old_count = 0;
  int new_count = 0;

  for (sec = stdoutput->sections; sec != NULL; sec = sec->next)
    {
      last_sec = sec;
      old_count++;
    }

  /* Now that we have the last section, push all the literal
     sections to the end.  */
  xtensa_reorder_seg_list (literal_head, last_sec);
  xtensa_reorder_seg_list (init_literal_head, last_sec);
  xtensa_reorder_seg_list (fini_literal_head, last_sec);

  /* Now perform the final error check.  */
  for (sec = stdoutput->sections; sec != NULL; sec = sec->next)
    new_count++;
  assert (new_count == old_count);
}


/* Change the emit state (seg, subseg, and frag related stuff) to the
   correct location.  Return a emit_state which can be passed to
   xtensa_restore_emit_state to return to current fragment.  */

static void
xtensa_switch_to_literal_fragment (emit_state *result)
{
  if (directive_state[directive_absolute_literals])
    {
      cache_literal_section (0, default_lit_sections.lit4_seg_name,
			     &default_lit_sections.lit4_seg, FALSE);
      xtensa_switch_section_emit_state (result,
					default_lit_sections.lit4_seg, 0);
    }
  else
    xtensa_switch_to_non_abs_literal_fragment (result);

  /* Do a 4-byte align here.  */
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
}


static void
xtensa_switch_to_non_abs_literal_fragment (emit_state *result)
{
  /* When we mark a literal pool location, we want to put a frag in
     the literal pool that points to it.  But to do that, we want to
     switch_to_literal_fragment.  But literal sections don't have
     literal pools, so their location is always null, so we would
     recurse forever.  This is kind of hacky, but it works.  */

  static bfd_boolean recursive = FALSE;
  fragS *pool_location = get_literal_pool_location (now_seg);
  bfd_boolean is_init = 
    (now_seg && !strcmp (segment_name (now_seg), INIT_SECTION_NAME));

  bfd_boolean is_fini = 
    (now_seg && !strcmp (segment_name (now_seg), FINI_SECTION_NAME));

  if (pool_location == NULL
      && !use_literal_section
      && !recursive
      && !is_init && ! is_fini)
    {
      as_bad (_("literal pool location required for text-section-literals; specify with .literal_position"));
      recursive = TRUE;
      xtensa_mark_literal_pool_location ();
      recursive = FALSE;
    }

  /* Special case: If we are in the ".fini" or ".init" section, then
     we will ALWAYS be generating to the ".fini.literal" and
     ".init.literal" sections.  */

  if (is_init)
    {
      cache_literal_section (init_literal_head,
			     default_lit_sections.init_lit_seg_name,
			     &default_lit_sections.init_lit_seg, TRUE);
      xtensa_switch_section_emit_state (result,
					default_lit_sections.init_lit_seg, 0);
    }
  else if (is_fini)
    {
      cache_literal_section (fini_literal_head,
			     default_lit_sections.fini_lit_seg_name,
			     &default_lit_sections.fini_lit_seg, TRUE);
      xtensa_switch_section_emit_state (result,
					default_lit_sections.fini_lit_seg, 0);
    }
  else
    {
      cache_literal_section (literal_head,
			     default_lit_sections.lit_seg_name,
			     &default_lit_sections.lit_seg, TRUE);
      xtensa_switch_section_emit_state (result,
					default_lit_sections.lit_seg, 0);
    }

  if (!use_literal_section
      && !is_init && !is_fini
      && get_literal_pool_location (now_seg) != pool_location)
    {
      /* Close whatever frag is there.  */
      frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
      xtensa_set_frag_assembly_state (frag_now);
      frag_now->tc_frag_data.literal_frag = pool_location;
      frag_variant (rs_fill, 0, 0, 0, NULL, 0, NULL);
      xtensa_set_frag_assembly_state (frag_now);
    }
}


/* Call this function before emitting data into the literal section.
   This is a helper function for xtensa_switch_to_literal_fragment.
   This is similar to a .section new_now_seg subseg. */

static void
xtensa_switch_section_emit_state (emit_state *state,
				  segT new_now_seg,
				  subsegT new_now_subseg)
{
  state->name = now_seg->name;
  state->now_seg = now_seg;
  state->now_subseg = now_subseg;
  state->generating_literals = generating_literals;
  generating_literals++;
  subseg_set (new_now_seg, new_now_subseg);
}


/* Use to restore the emitting into the normal place.  */

static void
xtensa_restore_emit_state (emit_state *state)
{
  generating_literals = state->generating_literals;
  subseg_set (state->now_seg, state->now_subseg);
}


/* Get a segment of a given name.  If the segment is already
   present, return it; otherwise, create a new one.  */

static void
cache_literal_section (seg_list *head,
		       const char *name,
		       segT *pseg,
		       bfd_boolean is_code)
{
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  segT seg;

  if (*pseg != 0)
    return;

  /* Check if the named section exists.  */
  for (seg = stdoutput->sections; seg; seg = seg->next)
    {
      if (!strcmp (segment_name (seg), name))
	break;
    }

  if (!seg)
    {
      /* Create a new literal section.  */
      seg = subseg_new (name, (subsegT) 0);
      if (head)
	{
	  /* Add the newly created literal segment to the specified list.  */
	  seg_list *n = (seg_list *) xmalloc (sizeof (seg_list));
	  n->seg = seg;
	  n->next = head->next;
	  head->next = n;
	}
      bfd_set_section_flags (stdoutput, seg, SEC_HAS_CONTENTS |
			     SEC_READONLY | SEC_ALLOC | SEC_LOAD
			     | (is_code ? SEC_CODE : SEC_DATA));
      bfd_set_section_alignment (stdoutput, seg, 2);
    }

  *pseg = seg;
  subseg_set (current_section, current_subsec);
}


/* Property Tables Stuff.  */

#define XTENSA_INSN_SEC_NAME ".xt.insn"
#define XTENSA_LIT_SEC_NAME ".xt.lit"
#define XTENSA_PROP_SEC_NAME ".xt.prop"

typedef bfd_boolean (*frag_predicate) (const fragS *);
typedef void (*frag_flags_fn) (const fragS *, frag_flags *);

static bfd_boolean get_frag_is_literal (const fragS *);
static void xtensa_create_property_segments
  (frag_predicate, frag_predicate, const char *, xt_section_type);
static void xtensa_create_xproperty_segments
  (frag_flags_fn, const char *, xt_section_type);
static segment_info_type *retrieve_segment_info (segT);
static segT retrieve_xtensa_section (char *);
static bfd_boolean section_has_property (segT, frag_predicate);
static bfd_boolean section_has_xproperty (segT, frag_flags_fn);
static void add_xt_block_frags
  (segT, segT, xtensa_block_info **, frag_predicate, frag_predicate);
static bfd_boolean xtensa_frag_flags_is_empty (const frag_flags *);
static void xtensa_frag_flags_init (frag_flags *);
static void get_frag_property_flags (const fragS *, frag_flags *);
static bfd_vma frag_flags_to_number (const frag_flags *);
static void add_xt_prop_frags
  (segT, segT, xtensa_block_info **, frag_flags_fn);

/* Set up property tables after relaxation.  */

void
xtensa_post_relax_hook (void)
{
  xtensa_move_seg_list_to_beginning (literal_head);
  xtensa_move_seg_list_to_beginning (init_literal_head);
  xtensa_move_seg_list_to_beginning (fini_literal_head);

  xtensa_find_unmarked_state_frags ();

  if (use_literal_section)
    xtensa_create_property_segments (get_frag_is_literal,
				     NULL,
				     XTENSA_LIT_SEC_NAME,
				     xt_literal_sec);
  xtensa_create_xproperty_segments (get_frag_property_flags,
				    XTENSA_PROP_SEC_NAME,
				    xt_prop_sec);

  if (warn_unaligned_branch_targets)
    bfd_map_over_sections (stdoutput, xtensa_find_unaligned_branch_targets, 0);
  bfd_map_over_sections (stdoutput, xtensa_find_unaligned_loops, 0);
}


/* This function is only meaningful after xtensa_move_literals.  */

static bfd_boolean
get_frag_is_literal (const fragS *fragP)
{
  assert (fragP != NULL);
  return fragP->tc_frag_data.is_literal;
}


static void
xtensa_create_property_segments (frag_predicate property_function,
				 frag_predicate end_property_function,
				 const char *section_name_base,
				 xt_section_type sec_type)
{
  segT *seclist;

  /* Walk over all of the current segments.
     Walk over each fragment
     For each non-empty fragment,
     Build a property record (append where possible).  */

  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segT sec = *seclist;
      flagword flags;

      flags = bfd_get_section_flags (stdoutput, sec);
      if (flags & SEC_DEBUGGING)
	continue;
      if (!(flags & SEC_ALLOC))
	continue;

      if (section_has_property (sec, property_function))
	{
	  char *property_section_name =
	    xtensa_get_property_section_name (sec, section_name_base);
	  segT insn_sec = retrieve_xtensa_section (property_section_name);
	  segment_info_type *xt_seg_info = retrieve_segment_info (insn_sec);
	  xtensa_block_info **xt_blocks =
	    &xt_seg_info->tc_segment_info_data.blocks[sec_type];
	  /* Walk over all of the frchains here and add new sections.  */
	  add_xt_block_frags (sec, insn_sec, xt_blocks, property_function,
			      end_property_function);
	}
    }

  /* Now we fill them out....  */

  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segment_info_type *seginfo;
      xtensa_block_info *block;
      segT sec = *seclist;

      seginfo = seg_info (sec);
      block = seginfo->tc_segment_info_data.blocks[sec_type];

      if (block)
	{
	  xtensa_block_info *cur_block;
	  /* This is a section with some data.  */
	  int num_recs = 0;
	  size_t rec_size;

	  for (cur_block = block; cur_block; cur_block = cur_block->next)
	    num_recs++;

	  rec_size = num_recs * 8;
	  bfd_set_section_size (stdoutput, sec, rec_size);

	  /* In order to make this work with the assembler, we have to
	     build some frags and then build the "fixups" for it.  It
	     would be easier to just set the contents then set the
	     arlents.  */

	  if (num_recs)
	    {
	      /* Allocate a fragment and leak it.  */
	      fragS *fragP;
	      size_t frag_size;
	      fixS *fixes;
	      frchainS *frchainP;
	      int i;
	      char *frag_data;

	      frag_size = sizeof (fragS) + rec_size;
	      fragP = (fragS *) xmalloc (frag_size);

	      memset (fragP, 0, frag_size);
	      fragP->fr_address = 0;
	      fragP->fr_next = NULL;
	      fragP->fr_fix = rec_size;
	      fragP->fr_var = 0;
	      fragP->fr_type = rs_fill;
	      /* The rest are zeros.  */

	      frchainP = seginfo->frchainP;
	      frchainP->frch_root = fragP;
	      frchainP->frch_last = fragP;

	      fixes = (fixS *) xmalloc (sizeof (fixS) * num_recs);
	      memset (fixes, 0, sizeof (fixS) * num_recs);

	      seginfo->fix_root = fixes;
	      seginfo->fix_tail = &fixes[num_recs - 1];
	      cur_block = block;
	      frag_data = &fragP->fr_literal[0];
	      for (i = 0; i < num_recs; i++)
		{
		  fixS *fix = &fixes[i];
		  assert (cur_block);

		  /* Write the fixup.  */
		  if (i != num_recs - 1)
		    fix->fx_next = &fixes[i + 1];
		  else
		    fix->fx_next = NULL;
		  fix->fx_size = 4;
		  fix->fx_done = 0;
		  fix->fx_frag = fragP;
		  fix->fx_where = i * 8;
		  fix->fx_addsy = section_symbol (cur_block->sec);
		  fix->fx_offset = cur_block->offset;
		  fix->fx_r_type = BFD_RELOC_32;
		  fix->fx_file = "Internal Assembly";
		  fix->fx_line = 0;

		  /* Write the length.  */
		  md_number_to_chars (&frag_data[4 + 8 * i],
				      cur_block->size, 4);
		  cur_block = cur_block->next;
		}
	    }
	}
    }
}


static void
xtensa_create_xproperty_segments (frag_flags_fn flag_fn,
				  const char *section_name_base,
				  xt_section_type sec_type)
{
  segT *seclist;

  /* Walk over all of the current segments.
     Walk over each fragment.
     For each fragment that has instructions,
     build an instruction record (append where possible).  */

  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segT sec = *seclist;
      flagword flags;

      flags = bfd_get_section_flags (stdoutput, sec);
      if (flags & SEC_DEBUGGING)
	continue;
      if (!(flags & SEC_ALLOC))
	continue;

      if (section_has_xproperty (sec, flag_fn))
	{
	  char *property_section_name =
	    xtensa_get_property_section_name (sec, section_name_base);
	  segT insn_sec = retrieve_xtensa_section (property_section_name);
	  segment_info_type *xt_seg_info = retrieve_segment_info (insn_sec);
	  xtensa_block_info **xt_blocks =
	    &xt_seg_info->tc_segment_info_data.blocks[sec_type];
	  /* Walk over all of the frchains here and add new sections.  */
	  add_xt_prop_frags (sec, insn_sec, xt_blocks, flag_fn);
	}
    }

  /* Now we fill them out....  */

  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segment_info_type *seginfo;
      xtensa_block_info *block;
      segT sec = *seclist;

      seginfo = seg_info (sec);
      block = seginfo->tc_segment_info_data.blocks[sec_type];

      if (block)
	{
	  xtensa_block_info *cur_block;
	  /* This is a section with some data.  */
	  int num_recs = 0;
	  size_t rec_size;

	  for (cur_block = block; cur_block; cur_block = cur_block->next)
	    num_recs++;

	  rec_size = num_recs * (8 + 4);
	  bfd_set_section_size (stdoutput, sec, rec_size);

	  /* elf_section_data (sec)->this_hdr.sh_entsize = 12; */

	  /* In order to make this work with the assembler, we have to build
	     some frags then build the "fixups" for it.  It would be easier to
	     just set the contents then set the arlents.  */

	  if (num_recs)
	    {
	      /* Allocate a fragment and (unfortunately) leak it.  */
	      fragS *fragP;
	      size_t frag_size;
	      fixS *fixes;
	      frchainS *frchainP;
	      int i;
	      char *frag_data;

	      frag_size = sizeof (fragS) + rec_size;
	      fragP = (fragS *) xmalloc (frag_size);

	      memset (fragP, 0, frag_size);
	      fragP->fr_address = 0;
	      fragP->fr_next = NULL;
	      fragP->fr_fix = rec_size;
	      fragP->fr_var = 0;
	      fragP->fr_type = rs_fill;
	      /* The rest are zeros.  */

	      frchainP = seginfo->frchainP;
	      frchainP->frch_root = fragP;
	      frchainP->frch_last = fragP;

	      fixes = (fixS *) xmalloc (sizeof (fixS) * num_recs);
	      memset (fixes, 0, sizeof (fixS) * num_recs);

	      seginfo->fix_root = fixes;
	      seginfo->fix_tail = &fixes[num_recs - 1];
	      cur_block = block;
	      frag_data = &fragP->fr_literal[0];
	      for (i = 0; i < num_recs; i++)
		{
		  fixS *fix = &fixes[i];
		  assert (cur_block);

		  /* Write the fixup.  */
		  if (i != num_recs - 1)
		    fix->fx_next = &fixes[i + 1];
		  else
		    fix->fx_next = NULL;
		  fix->fx_size = 4;
		  fix->fx_done = 0;
		  fix->fx_frag = fragP;
		  fix->fx_where = i * (8 + 4);
		  fix->fx_addsy = section_symbol (cur_block->sec);
		  fix->fx_offset = cur_block->offset;
		  fix->fx_r_type = BFD_RELOC_32;
		  fix->fx_file = "Internal Assembly";
		  fix->fx_line = 0;

		  /* Write the length.  */
		  md_number_to_chars (&frag_data[4 + (8+4) * i],
				      cur_block->size, 4);
		  md_number_to_chars (&frag_data[8 + (8+4) * i],
				      frag_flags_to_number (&cur_block->flags),
				      4);
		  cur_block = cur_block->next;
		}
	    }
	}
    }
}


static segment_info_type *
retrieve_segment_info (segT seg)
{
  segment_info_type *seginfo;
  seginfo = (segment_info_type *) bfd_get_section_userdata (stdoutput, seg);
  if (!seginfo)
    {
      frchainS *frchainP;

      seginfo = (segment_info_type *) xmalloc (sizeof (*seginfo));
      memset ((void *) seginfo, 0, sizeof (*seginfo));
      seginfo->fix_root = NULL;
      seginfo->fix_tail = NULL;
      seginfo->bfd_section = seg;
      seginfo->sym = 0;
      /* We will not be dealing with these, only our special ones.  */
#if 0
      if (seg == bfd_abs_section_ptr)
	abs_seg_info = seginfo;
      else if (seg == bfd_und_section_ptr)
	und_seg_info = seginfo;
      else
#endif
	bfd_set_section_userdata (stdoutput, seg, (void *) seginfo);
#if 0
      seg_fix_rootP = &segment_info[seg].fix_root;
      seg_fix_tailP = &segment_info[seg].fix_tail;
#endif

      frchainP = (frchainS *) xmalloc (sizeof (frchainS));
      frchainP->frch_root = NULL;
      frchainP->frch_last = NULL;
      frchainP->frch_next = NULL;
      frchainP->frch_seg = seg;
      frchainP->frch_subseg = 0;
      frchainP->fix_root = NULL;
      frchainP->fix_tail = NULL;
      /* Do not init the objstack.  */
      /* obstack_begin (&frchainP->frch_obstack, chunksize); */
      /* frchainP->frch_frag_now = fragP; */
      frchainP->frch_frag_now = NULL;

      seginfo->frchainP = frchainP;
    }

  return seginfo;
}


static segT
retrieve_xtensa_section (char *sec_name)
{
  bfd *abfd = stdoutput;
  flagword flags, out_flags, link_once_flags;
  segT s;

  flags = bfd_get_section_flags (abfd, now_seg);
  link_once_flags = (flags & SEC_LINK_ONCE);
  if (link_once_flags)
    link_once_flags |= (flags & SEC_LINK_DUPLICATES);
  out_flags = (SEC_RELOC | SEC_HAS_CONTENTS | SEC_READONLY | link_once_flags);

  s = bfd_make_section_old_way (abfd, sec_name);
  if (s == NULL)
    as_bad (_("could not create section %s"), sec_name);
  if (!bfd_set_section_flags (abfd, s, out_flags))
    as_bad (_("invalid flag combination on section %s"), sec_name);

  return s;
}


static bfd_boolean
section_has_property (segT sec, frag_predicate property_function)
{
  segment_info_type *seginfo = seg_info (sec);
  fragS *fragP;

  if (seginfo && seginfo->frchainP)
    {
      for (fragP = seginfo->frchainP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (property_function (fragP)
	      && (fragP->fr_type != rs_fill || fragP->fr_fix != 0))
	    return TRUE;
	}
    }
  return FALSE;
}


static bfd_boolean
section_has_xproperty (segT sec, frag_flags_fn property_function)
{
  segment_info_type *seginfo = seg_info (sec);
  fragS *fragP;

  if (seginfo && seginfo->frchainP)
    {
      for (fragP = seginfo->frchainP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  frag_flags prop_flags;
	  property_function (fragP, &prop_flags);
	  if (!xtensa_frag_flags_is_empty (&prop_flags))
	    return TRUE;
	}
    }
  return FALSE;
}


/* Two types of block sections exist right now: literal and insns.  */

static void
add_xt_block_frags (segT sec,
		    segT xt_block_sec,
		    xtensa_block_info **xt_block,
		    frag_predicate property_function,
		    frag_predicate end_property_function)
{
  segment_info_type *seg_info;
  segment_info_type *xt_seg_info;
  bfd_vma seg_offset;
  fragS *fragP;

  xt_seg_info = retrieve_segment_info (xt_block_sec);
  seg_info = retrieve_segment_info (sec);

  /* Build it if needed.  */
  while (*xt_block != NULL)
    xt_block = &(*xt_block)->next;
  /* We are either at NULL at the beginning or at the end.  */

  /* Walk through the frags.  */
  seg_offset = 0;

  if (seg_info->frchainP)
    {
      for (fragP = seg_info->frchainP->frch_root;
	   fragP;
	   fragP = fragP->fr_next)
	{
	  if (property_function (fragP)
	      && (fragP->fr_type != rs_fill || fragP->fr_fix != 0))
	    {
	      if (*xt_block != NULL)
		{
		  if ((*xt_block)->offset + (*xt_block)->size
		      == fragP->fr_address)
		    (*xt_block)->size += fragP->fr_fix;
		  else
		    xt_block = &((*xt_block)->next);
		}
	      if (*xt_block == NULL)
		{
		  xtensa_block_info *new_block = (xtensa_block_info *)
		    xmalloc (sizeof (xtensa_block_info));
		  new_block->sec = sec;
		  new_block->offset = fragP->fr_address;
		  new_block->size = fragP->fr_fix;
		  new_block->next = NULL;
		  xtensa_frag_flags_init (&new_block->flags);
		  *xt_block = new_block;
		}
	      if (end_property_function
		  && end_property_function (fragP))
		{
		  xt_block = &((*xt_block)->next);
		}
	    }
	}
    }
}


/* Break the encapsulation of add_xt_prop_frags here.  */

static bfd_boolean
xtensa_frag_flags_is_empty (const frag_flags *prop_flags)
{
  if (prop_flags->is_literal
      || prop_flags->is_insn
      || prop_flags->is_data
      || prop_flags->is_unreachable)
    return FALSE;
  return TRUE;
}


static void
xtensa_frag_flags_init (frag_flags *prop_flags)
{
  memset (prop_flags, 0, sizeof (frag_flags));
}


static void
get_frag_property_flags (const fragS *fragP, frag_flags *prop_flags)
{
  xtensa_frag_flags_init (prop_flags);
  if (fragP->tc_frag_data.is_literal)
    prop_flags->is_literal = TRUE;
  if (fragP->tc_frag_data.is_unreachable)
    prop_flags->is_unreachable = TRUE;
  else if (fragP->tc_frag_data.is_insn)
    {
      prop_flags->is_insn = TRUE;
      if (fragP->tc_frag_data.is_loop_target)
	prop_flags->insn.is_loop_target = TRUE;
      if (fragP->tc_frag_data.is_branch_target)
	prop_flags->insn.is_branch_target = TRUE;
      if (fragP->tc_frag_data.is_specific_opcode
	  || fragP->tc_frag_data.is_no_transform)
	prop_flags->insn.is_no_transform = TRUE;
      if (fragP->tc_frag_data.is_no_density)
	prop_flags->insn.is_no_density = TRUE;
      if (fragP->tc_frag_data.use_absolute_literals)
	prop_flags->insn.is_abslit = TRUE;
    }
  if (fragP->tc_frag_data.is_align)
    {
      prop_flags->is_align = TRUE;
      prop_flags->alignment = fragP->tc_frag_data.alignment;
      if (xtensa_frag_flags_is_empty (prop_flags))
	prop_flags->is_data = TRUE;
    }
}


static bfd_vma
frag_flags_to_number (const frag_flags *prop_flags)
{
  bfd_vma num = 0;
  if (prop_flags->is_literal)
    num |= XTENSA_PROP_LITERAL;
  if (prop_flags->is_insn)
    num |= XTENSA_PROP_INSN;
  if (prop_flags->is_data)
    num |= XTENSA_PROP_DATA;
  if (prop_flags->is_unreachable)
    num |= XTENSA_PROP_UNREACHABLE;
  if (prop_flags->insn.is_loop_target)
    num |= XTENSA_PROP_INSN_LOOP_TARGET;
  if (prop_flags->insn.is_branch_target)
    {
      num |= XTENSA_PROP_INSN_BRANCH_TARGET;
      num = SET_XTENSA_PROP_BT_ALIGN (num, prop_flags->insn.bt_align_priority);
    }

  if (prop_flags->insn.is_no_density)
    num |= XTENSA_PROP_INSN_NO_DENSITY;
  if (prop_flags->insn.is_no_transform)
    num |= XTENSA_PROP_INSN_NO_TRANSFORM;
  if (prop_flags->insn.is_no_reorder)
    num |= XTENSA_PROP_INSN_NO_REORDER;
  if (prop_flags->insn.is_abslit)
    num |= XTENSA_PROP_INSN_ABSLIT;

  if (prop_flags->is_align)
    {
      num |= XTENSA_PROP_ALIGN;
      num = SET_XTENSA_PROP_ALIGNMENT (num, prop_flags->alignment);
    }

  return num;
}


static bfd_boolean
xtensa_frag_flags_combinable (const frag_flags *prop_flags_1,
			      const frag_flags *prop_flags_2)
{
  /* Cannot combine with an end marker.  */

  if (prop_flags_1->is_literal != prop_flags_2->is_literal)
    return FALSE;
  if (prop_flags_1->is_insn != prop_flags_2->is_insn)
    return FALSE;
  if (prop_flags_1->is_data != prop_flags_2->is_data)
    return FALSE;

  if (prop_flags_1->is_insn)
    {
      /* Properties of the beginning of the frag.  */
      if (prop_flags_2->insn.is_loop_target)
	return FALSE;
      if (prop_flags_2->insn.is_branch_target)
	return FALSE;
      if (prop_flags_1->insn.is_no_density !=
	  prop_flags_2->insn.is_no_density)
	return FALSE;
      if (prop_flags_1->insn.is_no_transform !=
	  prop_flags_2->insn.is_no_transform)
	return FALSE;
      if (prop_flags_1->insn.is_no_reorder !=
	  prop_flags_2->insn.is_no_reorder)
	return FALSE;
      if (prop_flags_1->insn.is_abslit !=
	  prop_flags_2->insn.is_abslit)
	return FALSE;
    }

  if (prop_flags_1->is_align)
    return FALSE;

  return TRUE;
}


static bfd_vma
xt_block_aligned_size (const xtensa_block_info *xt_block)
{
  bfd_vma end_addr;
  size_t align_bits;

  if (!xt_block->flags.is_align)
    return xt_block->size;

  end_addr = xt_block->offset + xt_block->size;
  align_bits = xt_block->flags.alignment;
  end_addr = ((end_addr + ((1 << align_bits) -1)) >> align_bits) << align_bits;
  return end_addr - xt_block->offset;
}


static bfd_boolean
xtensa_xt_block_combine (xtensa_block_info *xt_block,
			 const xtensa_block_info *xt_block_2)
{
  if (xt_block->sec != xt_block_2->sec)
    return FALSE;
  if (xt_block->offset + xt_block_aligned_size (xt_block)
      != xt_block_2->offset)
    return FALSE;

  if (xt_block_2->size == 0
      && (!xt_block_2->flags.is_unreachable
	  || xt_block->flags.is_unreachable))
    {
      if (xt_block_2->flags.is_align
	  && xt_block->flags.is_align)
	{
	  /* Nothing needed.  */
	  if (xt_block->flags.alignment >= xt_block_2->flags.alignment)
	    return TRUE;
	}
      else
	{
	  if (xt_block_2->flags.is_align)
	    {
	      /* Push alignment to previous entry.  */
	      xt_block->flags.is_align = xt_block_2->flags.is_align;
	      xt_block->flags.alignment = xt_block_2->flags.alignment;
	    }
	  return TRUE;
	}
    }
  if (!xtensa_frag_flags_combinable (&xt_block->flags,
				     &xt_block_2->flags))
    return FALSE;

  xt_block->size += xt_block_2->size;

  if (xt_block_2->flags.is_align)
    {
      xt_block->flags.is_align = TRUE;
      xt_block->flags.alignment = xt_block_2->flags.alignment;
    }

  return TRUE;
}


static void
add_xt_prop_frags (segT sec,
		   segT xt_block_sec,
		   xtensa_block_info **xt_block,
		   frag_flags_fn property_function)
{
  segment_info_type *seg_info;
  segment_info_type *xt_seg_info;
  bfd_vma seg_offset;
  fragS *fragP;

  xt_seg_info = retrieve_segment_info (xt_block_sec);
  seg_info = retrieve_segment_info (sec);
  /* Build it if needed.  */
  while (*xt_block != NULL)
    {
      xt_block = &(*xt_block)->next;
    }
  /* We are either at NULL at the beginning or at the end.  */

  /* Walk through the frags.  */
  seg_offset = 0;

  if (seg_info->frchainP)
    {
      for (fragP = seg_info->frchainP->frch_root; fragP;
	   fragP = fragP->fr_next)
	{
	  xtensa_block_info tmp_block;
	  tmp_block.sec = sec;
	  tmp_block.offset = fragP->fr_address;
	  tmp_block.size = fragP->fr_fix;
	  tmp_block.next = NULL;
	  property_function (fragP, &tmp_block.flags);

	  if (!xtensa_frag_flags_is_empty (&tmp_block.flags))
	    /* && fragP->fr_fix != 0) */
	    {
	      if ((*xt_block) == NULL
		  || !xtensa_xt_block_combine (*xt_block, &tmp_block))
		{
		  xtensa_block_info *new_block;
		  if ((*xt_block) != NULL)
		    xt_block = &(*xt_block)->next;
		  new_block = (xtensa_block_info *)
		    xmalloc (sizeof (xtensa_block_info));
		  *new_block = tmp_block;
		  *xt_block = new_block;
		}
	    }
	}
    }
}


/* op_placement_info_table */

/* op_placement_info makes it easier to determine which
   ops can go in which slots.  */

static void
init_op_placement_info_table (void)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_insnbuf ibuf = xtensa_insnbuf_alloc (isa);
  xtensa_opcode opcode;
  xtensa_format fmt;
  int slot;
  int num_opcodes = xtensa_isa_num_opcodes (isa);

  op_placement_table = (op_placement_info_table)
    xmalloc (sizeof (op_placement_info) * num_opcodes);
  assert (xtensa_isa_num_formats (isa) < MAX_FORMATS);

  for (opcode = 0; opcode < num_opcodes; opcode++)
    {
      op_placement_info *opi = &op_placement_table[opcode];
      /* FIXME: Make tinsn allocation dynamic.  */
      if (xtensa_opcode_num_operands (isa, opcode) >= MAX_INSN_ARGS)
	as_fatal (_("too many operands in instruction"));
      opi->single = XTENSA_UNDEFINED;
      opi->single_size = 0;
      opi->widest = XTENSA_UNDEFINED;
      opi->widest_size = 0;
      opi->narrowest = XTENSA_UNDEFINED;
      opi->narrowest_size = 0x7F;
      opi->formats = 0;
      opi->num_formats = 0;
      opi->issuef = 0;
      for (fmt = 0; fmt < xtensa_isa_num_formats (isa); fmt++)
	{
	  opi->slots[fmt] = 0;
	  for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
	    {
	      if (xtensa_opcode_encode (isa, fmt, slot, ibuf, opcode) == 0)
		{
		  int fmt_length = xtensa_format_length (isa, fmt);
		  opi->issuef++;
		  set_bit (fmt, opi->formats);
		  set_bit (slot, opi->slots[fmt]);
		  /* opi->slot_count[fmt]++; */
		  if (fmt_length < opi->narrowest_size)
		    {
		      opi->narrowest = fmt;
		      opi->narrowest_size = fmt_length;
		    }
		  if (fmt_length > opi->widest_size)
		    {
		      opi->widest = fmt;
		      opi->widest_size = fmt_length;
		    }
		  if (xtensa_format_num_slots (isa, fmt) == 1)
		    {
		      if (opi->single_size == 0
			  || fmt_length < opi->single_size)
			{
			  opi->single = fmt;
			  opi->single_size = fmt_length;
			}
		    }
		}
	    }
	  if (opi->formats)
	    opi->num_formats++;
	}
    }
  xtensa_insnbuf_free (isa, ibuf);
}


bfd_boolean
opcode_fits_format_slot (xtensa_opcode opcode, xtensa_format fmt, int slot)
{
  return bit_is_set (slot, op_placement_table[opcode].slots[fmt]);
}


/* If the opcode is available in a single slot format, return its size.  */

static int
xg_get_single_size (xtensa_opcode opcode)
{
  assert (op_placement_table[opcode].single != XTENSA_UNDEFINED);
  return op_placement_table[opcode].single_size;
}


static xtensa_format
xg_get_single_format (xtensa_opcode opcode)
{
  return op_placement_table[opcode].single;
}


/* Instruction Stack Functions (from "xtensa-istack.h").  */

void
istack_init (IStack *stack)
{
  memset (stack, 0, sizeof (IStack));
  stack->ninsn = 0;
}


bfd_boolean
istack_empty (IStack *stack)
{
  return (stack->ninsn == 0);
}


bfd_boolean
istack_full (IStack *stack)
{
  return (stack->ninsn == MAX_ISTACK);
}


/* Return a pointer to the top IStack entry.
   It is an error to call this if istack_empty () is TRUE. */

TInsn *
istack_top (IStack *stack)
{
  int rec = stack->ninsn - 1;
  assert (!istack_empty (stack));
  return &stack->insn[rec];
}


/* Add a new TInsn to an IStack.
   It is an error to call this if istack_full () is TRUE.  */

void
istack_push (IStack *stack, TInsn *insn)
{
  int rec = stack->ninsn;
  assert (!istack_full (stack));
  stack->insn[rec] = *insn;
  stack->ninsn++;
}


/* Clear space for the next TInsn on the IStack and return a pointer
   to it.  It is an error to call this if istack_full () is TRUE.  */

TInsn *
istack_push_space (IStack *stack)
{
  int rec = stack->ninsn;
  TInsn *insn;
  assert (!istack_full (stack));
  insn = &stack->insn[rec];
  memset (insn, 0, sizeof (TInsn));
  stack->ninsn++;
  return insn;
}


/* Remove the last pushed instruction.  It is an error to call this if
   istack_empty () returns TRUE.  */

void
istack_pop (IStack *stack)
{
  int rec = stack->ninsn - 1;
  assert (!istack_empty (stack));
  stack->ninsn--;
  memset (&stack->insn[rec], 0, sizeof (TInsn));
}


/* TInsn functions.  */

void
tinsn_init (TInsn *dst)
{
  memset (dst, 0, sizeof (TInsn));
}


/* Get the ``num''th token of the TInsn.
   It is illegal to call this if num > insn->ntoks.  */

expressionS *
tinsn_get_tok (TInsn *insn, int num)
{
  assert (num < insn->ntok);
  return &insn->tok[num];
}


/* Return TRUE if ANY of the operands in the insn are symbolic.  */

static bfd_boolean
tinsn_has_symbolic_operands (const TInsn *insn)
{
  int i;
  int n = insn->ntok;

  assert (insn->insn_type == ITYPE_INSN);

  for (i = 0; i < n; ++i)
    {
      switch (insn->tok[i].X_op)
	{
	case O_register:
	case O_constant:
	  break;
	default:
	  return TRUE;
	}
    }
  return FALSE;
}


bfd_boolean
tinsn_has_invalid_symbolic_operands (const TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  int i;
  int n = insn->ntok;

  assert (insn->insn_type == ITYPE_INSN);

  for (i = 0; i < n; ++i)
    {
      switch (insn->tok[i].X_op)
	{
	case O_register:
	case O_constant:
	  break;
	case O_big:
	case O_illegal:
	case O_absent:
	  /* Errors for these types are caught later.  */
	  break;
	case O_hi16:
	case O_lo16:
	default:
	  /* Symbolic immediates are only allowed on the last immediate
	     operand.  At this time, CONST16 is the only opcode where we
	     support non-PC-relative relocations.  (It isn't necessary
	     to complain about non-PC-relative relocations here, but
	     otherwise, no error is reported until the relocations are
	     generated, and the assembler won't get that far if there
	     are any other errors.  It's nice to see all the problems
	     at once.)  */
	  if (i != get_relaxable_immed (insn->opcode)
	      || (xtensa_operand_is_PCrelative (isa, insn->opcode, i) != 1
		  && insn->opcode != xtensa_const16_opcode))
	    {
	      as_bad (_("invalid symbolic operand %d on '%s'"),
		      i, xtensa_opcode_name (isa, insn->opcode));
	      return TRUE;
	    }
	}
    }
  return FALSE;
}


/* For assembly code with complex expressions (e.g. subtraction),
   we have to build them in the literal pool so that
   their results are calculated correctly after relaxation.
   The relaxation only handles expressions that
   boil down to SYMBOL + OFFSET.  */

static bfd_boolean
tinsn_has_complex_operands (const TInsn *insn)
{
  int i;
  int n = insn->ntok;
  assert (insn->insn_type == ITYPE_INSN);
  for (i = 0; i < n; ++i)
    {
      switch (insn->tok[i].X_op)
	{
	case O_register:
	case O_constant:
	case O_symbol:
	case O_lo16:
	case O_hi16:
	  break;
	default:
	  return TRUE;
	}
    }
  return FALSE;
}


/* Convert the constant operands in the tinsn to insnbuf.
   Return TRUE if there is a symbol in the immediate field.

   Before this is called,
   1) the number of operands are correct
   2) the tinsn is a ITYPE_INSN
   3) ONLY the relaxable_ is built
   4) All operands are O_constant, O_symbol.  All constants fit
   The return value tells whether there are any remaining O_symbols.  */

static bfd_boolean
tinsn_to_insnbuf (TInsn *tinsn, xtensa_insnbuf insnbuf)
{
  static xtensa_insnbuf slotbuf = 0;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode = tinsn->opcode;
  xtensa_format fmt = xg_get_single_format (opcode);
  bfd_boolean has_fixup = FALSE;
  int noperands = xtensa_opcode_num_operands (isa, opcode);
  int i;
  uint32 opnd_value;
  char *file_name;
  int line;

  if (!slotbuf)
    slotbuf = xtensa_insnbuf_alloc (isa);

  assert (tinsn->insn_type == ITYPE_INSN);
  if (noperands != tinsn->ntok)
    as_fatal (_("operand number mismatch"));

  if (xtensa_opcode_encode (isa, fmt, 0, slotbuf, opcode))
    as_fatal (_("cannot encode opcode"));

  for (i = 0; i < noperands; ++i)
    {
      expressionS *expr = &tinsn->tok[i];
      switch (expr->X_op)
	{
	case O_register:
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
	  /* The register number has already been checked in
	     expression_maybe_register, so we don't need to check here.  */
	  opnd_value = expr->X_add_number;
	  (void) xtensa_operand_encode (isa, opcode, i, &opnd_value);
	  xtensa_operand_set_field (isa, opcode, i, fmt, 0,
				    slotbuf, opnd_value);
	  break;

	case O_constant:
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
	  as_where (&file_name, &line);
	  /* It is a constant and we called this function,
	     then we have to try to fit it.  */
	  xtensa_insnbuf_set_operand (slotbuf, fmt, 0, opcode, i,
				      expr->X_add_number, file_name, line);
	  break;

	default:
	  has_fixup = TRUE;
	  break;
	}
    }

  xtensa_format_encode (isa, fmt, insnbuf);
  xtensa_format_set_slot (isa, fmt, 0, insnbuf, slotbuf);

  return has_fixup;
}


/* Convert the constant operands in the tinsn to slotbuf.
   Return TRUE if there is a symbol in the immediate field.
   (Eventually this should replace tinsn_to_insnbuf.)  */

/* Before this is called,
   1) the number of operands are correct
   2) the tinsn is a ITYPE_INSN
   3) ONLY the relaxable_ is built
   4) All operands are
       O_constant, O_symbol
      All constants fit

   The return value tells whether there are any remaining O_symbols.  */

static bfd_boolean
tinsn_to_slotbuf (xtensa_format fmt,
		  int slot,
		  TInsn *tinsn,
		  xtensa_insnbuf slotbuf)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode = tinsn->opcode;
  bfd_boolean has_fixup = FALSE;
  int noperands = xtensa_opcode_num_operands (isa, opcode);
  int i;

  *((int *) &slotbuf[0]) = 0;
  *((int *) &slotbuf[1]) = 0;
  assert (tinsn->insn_type == ITYPE_INSN);
  if (noperands != tinsn->ntok)
    as_fatal (_("operand number mismatch"));

  if (xtensa_opcode_encode (isa, fmt, slot, slotbuf, opcode))
    {
      as_bad (_("cannot encode opcode \"%s\" in the given format \"%s\""),
	      xtensa_opcode_name (isa, opcode), xtensa_format_name (isa, fmt));
      return FALSE;
    }

  for (i = 0; i < noperands; i++)
    {
      expressionS *expr = &tinsn->tok[i];
      int rc, line;
      char *file_name;
      uint32 opnd_value;

      switch (expr->X_op)
	{
	case O_register:
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
	  /* The register number has already been checked in
	     expression_maybe_register, so we don't need to check here.  */
	  opnd_value = expr->X_add_number;
	  (void) xtensa_operand_encode (isa, opcode, i, &opnd_value);
	  rc = xtensa_operand_set_field (isa, opcode, i, fmt, slot, slotbuf,
					 opnd_value);
	  if (rc != 0)
	    as_warn (_("xtensa-isa failure: %s"), xtensa_isa_error_msg (isa));
	  break;

	case O_constant:
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
	  as_where (&file_name, &line);
	  /* It is a constant and we called this function
	     then we have to try to fit it.  */
	  xtensa_insnbuf_set_operand (slotbuf, fmt, slot, opcode, i,
				      expr->X_add_number, file_name, line);
	  break;

	default:
	  has_fixup = TRUE;
	  break;
	}
    }

  return has_fixup;
}


/* Check the instruction arguments.  Return TRUE on failure.  */

static bfd_boolean
tinsn_check_arguments (const TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode = insn->opcode;

  if (opcode == XTENSA_UNDEFINED)
    {
      as_bad (_("invalid opcode"));
      return TRUE;
    }

  if (xtensa_opcode_num_operands (isa, opcode) > insn->ntok)
    {
      as_bad (_("too few operands"));
      return TRUE;
    }

  if (xtensa_opcode_num_operands (isa, opcode) < insn->ntok)
    {
      as_bad (_("too many operands"));
      return TRUE;
    }
  return FALSE;
}


/* Load an instruction from its encoded form.  */

static void
tinsn_from_chars (TInsn *tinsn, char *f, int slot)
{
  vliw_insn vinsn;

  xg_init_vinsn (&vinsn);
  vinsn_from_chars (&vinsn, f);

  *tinsn = vinsn.slots[slot];
  xg_free_vinsn (&vinsn);
}


static void
tinsn_from_insnbuf (TInsn *tinsn,
		    xtensa_insnbuf slotbuf,
		    xtensa_format fmt,
		    int slot)
{
  int i;
  xtensa_isa isa = xtensa_default_isa;

  /* Find the immed.  */
  tinsn_init (tinsn);
  tinsn->insn_type = ITYPE_INSN;
  tinsn->is_specific_opcode = FALSE;	/* must not be specific */
  tinsn->opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);
  tinsn->ntok = xtensa_opcode_num_operands (isa, tinsn->opcode);
  for (i = 0; i < tinsn->ntok; i++)
    {
      set_expr_const (&tinsn->tok[i],
		      xtensa_insnbuf_get_operand (slotbuf, fmt, slot,
						  tinsn->opcode, i));
    }
}


/* Read the value of the relaxable immed from the fr_symbol and fr_offset.  */

static void
tinsn_immed_from_frag (TInsn *tinsn, fragS *fragP, int slot)
{
  xtensa_opcode opcode = tinsn->opcode;
  int opnum;

  if (fragP->tc_frag_data.slot_symbols[slot])
    {
      opnum = get_relaxable_immed (opcode);
      assert (opnum >= 0);
      if (fragP->tc_frag_data.slot_sub_symbols[slot])
	{
	  set_expr_symbol_offset_diff
	    (&tinsn->tok[opnum],
	     fragP->tc_frag_data.slot_symbols[slot],
	     fragP->tc_frag_data.slot_sub_symbols[slot],
	     fragP->tc_frag_data.slot_offsets[slot]);
	}
      else
	{
	  set_expr_symbol_offset
	    (&tinsn->tok[opnum],
	     fragP->tc_frag_data.slot_symbols[slot],
	     fragP->tc_frag_data.slot_offsets[slot]);
	}
    }
}


static int
get_num_stack_text_bytes (IStack *istack)
{
  int i;
  int text_bytes = 0;

  for (i = 0; i < istack->ninsn; i++)
    {
      TInsn *tinsn = &istack->insn[i];
      if (tinsn->insn_type == ITYPE_INSN)
	text_bytes += xg_get_single_size (tinsn->opcode);
    }
  return text_bytes;
}


static int
get_num_stack_literal_bytes (IStack *istack)
{
  int i;
  int lit_bytes = 0;

  for (i = 0; i < istack->ninsn; i++)
    {
      TInsn *tinsn = &istack->insn[i];
      if (tinsn->insn_type == ITYPE_LITERAL && tinsn->ntok == 1)
	lit_bytes += 4;
    }
  return lit_bytes;
}


/* vliw_insn functions.  */

static void
xg_init_vinsn (vliw_insn *v)
{
  int i;
  xtensa_isa isa = xtensa_default_isa;

  xg_clear_vinsn (v);

  v->insnbuf = xtensa_insnbuf_alloc (isa);
  if (v->insnbuf == NULL)
    as_fatal (_("out of memory"));

  for (i = 0; i < MAX_SLOTS; i++)
    {
      tinsn_init (&v->slots[i]);
      v->slots[i].opcode = XTENSA_UNDEFINED;
      v->slotbuf[i] = xtensa_insnbuf_alloc (isa);
      if (v->slotbuf[i] == NULL)
	as_fatal (_("out of memory"));
    }
}


static void
xg_clear_vinsn (vliw_insn *v)
{
  int i;
  v->format = XTENSA_UNDEFINED;
  v->num_slots = 0;
  v->inside_bundle = FALSE;

  if (xt_saved_debug_type != DEBUG_NONE)
    debug_type = xt_saved_debug_type;

  for (i = 0; i < MAX_SLOTS; i++)
    {
      memset (&v->slots[i], 0, sizeof (TInsn));
      v->slots[i].opcode = XTENSA_UNDEFINED;
    }
}


static bfd_boolean
vinsn_has_specific_opcodes (vliw_insn *v)
{
  int i;
  
  for (i = 0; i < v->num_slots; i++)
    {
      if (v->slots[i].is_specific_opcode)
	return TRUE;
    }
  return FALSE;
}


static void
xg_free_vinsn (vliw_insn *v)
{
  int i;
  xtensa_insnbuf_free (xtensa_default_isa, v->insnbuf);
  for (i = 0; i < MAX_SLOTS; i++)
    xtensa_insnbuf_free (xtensa_default_isa, v->slotbuf[i]);
}


/* Before this is called, we should have
   filled out the following fields:

   1) the number of operands for each opcode are correct
   2) the tinsn in the slots are ITYPE_INSN
   3) ONLY the relaxable_ is built
   4) All operands are
       O_constant, O_symbol
      All constants fit

   The return value tells whether there are any remaining O_symbols.  */

static bfd_boolean
vinsn_to_insnbuf (vliw_insn *vinsn,
		  char *frag_offset,
		  fragS *fragP,
		  bfd_boolean record_fixup)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt = vinsn->format;
  xtensa_insnbuf insnbuf = vinsn->insnbuf;
  int slot;
  bfd_boolean has_fixup = FALSE;

  xtensa_format_encode (isa, fmt, insnbuf);

  for (slot = 0; slot < vinsn->num_slots; slot++)
    {
      TInsn *tinsn = &vinsn->slots[slot];
      bfd_boolean tinsn_has_fixup =
	tinsn_to_slotbuf (vinsn->format, slot, tinsn,
			  vinsn->slotbuf[slot]);

      xtensa_format_set_slot (isa, fmt, slot,
			      insnbuf, vinsn->slotbuf[slot]);
      /* tinsn_has_fixup tracks if there is a fixup at all.
	 record_fixup controls globally.  I.E., we use this
	 function from several places, some of which are after
	 fixups have already been recorded.  Finally,
	 tinsn->record_fixup controls based on the individual ops,
	 which may or may not need it based on the relaxation
	 requirements.  */
      if (tinsn_has_fixup && record_fixup)
	{
	  int i;
	  xtensa_opcode opcode = tinsn->opcode;
	  int noperands = xtensa_opcode_num_operands (isa, opcode);
	  has_fixup = TRUE;

	  for (i = 0; i < noperands; i++)
	    {
	      expressionS* expr = &tinsn->tok[i];
	      switch (expr->X_op)
		{
		case O_symbol:
		case O_lo16:
		case O_hi16:
		  if (get_relaxable_immed (opcode) == i)
		    {
		      if (tinsn->record_fix || expr->X_op != O_symbol)
			{
			  if (!xg_add_opcode_fix
			      (tinsn, i, fmt, slot, expr, fragP,
			       frag_offset - fragP->fr_literal))
			    as_bad (_("instruction with constant operands does not fit"));
			}
		      else
			{
			  tinsn->symbol = expr->X_add_symbol;
			  tinsn->offset = expr->X_add_number;
			}
		    }
		  else
		    as_bad (_("invalid operand %d on '%s'"),
			    i, xtensa_opcode_name (isa, opcode));
		  break;

		case O_constant:
		case O_register:
		  break;

		case O_subtract:
		  if (get_relaxable_immed (opcode) == i)
		    {
		      if (tinsn->record_fix)
			  as_bad (_("invalid subtract operand"));
		      else
			{
			  tinsn->symbol = expr->X_add_symbol;
			  tinsn->sub_symbol = expr->X_op_symbol;
			  tinsn->offset = expr->X_add_number;
			}
		    }
		  else
		    as_bad (_("invalid operand %d on '%s'"),
			    i, xtensa_opcode_name (isa, opcode));
		  break;

		default:
		  as_bad (_("invalid expression for operand %d on '%s'"),
			  i, xtensa_opcode_name (isa, opcode));
		  break;
		}
	    }
	}
    }

  return has_fixup;
}


static void
vinsn_from_chars (vliw_insn *vinsn, char *f)
{
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  int i;
  xtensa_format fmt;
  xtensa_isa isa = xtensa_default_isa;

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  xtensa_insnbuf_from_chars (isa, insnbuf, f, 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    as_fatal (_("cannot decode instruction format"));
  vinsn->format = fmt;
  vinsn->num_slots = xtensa_format_num_slots (isa, fmt);

  for (i = 0; i < vinsn->num_slots; i++)
    {
      TInsn *tinsn = &vinsn->slots[i];
      xtensa_format_get_slot (isa, fmt, i, insnbuf, slotbuf);
      tinsn_from_insnbuf (tinsn, slotbuf, fmt, i);
    }
}


/* Expression utilities.  */

/* Return TRUE if the expression is an integer constant.  */

bfd_boolean
expr_is_const (const expressionS *s)
{
  return (s->X_op == O_constant);
}


/* Get the expression constant.
   Calling this is illegal if expr_is_const () returns TRUE.  */

offsetT
get_expr_const (const expressionS *s)
{
  assert (expr_is_const (s));
  return s->X_add_number;
}


/* Set the expression to a constant value.  */

void
set_expr_const (expressionS *s, offsetT val)
{
  s->X_op = O_constant;
  s->X_add_number = val;
  s->X_add_symbol = NULL;
  s->X_op_symbol = NULL;
}


bfd_boolean
expr_is_register (const expressionS *s)
{
  return (s->X_op == O_register);
}


/* Get the expression constant.
   Calling this is illegal if expr_is_const () returns TRUE.  */

offsetT
get_expr_register (const expressionS *s)
{
  assert (expr_is_register (s));
  return s->X_add_number;
}


/* Set the expression to a symbol + constant offset.  */

void
set_expr_symbol_offset (expressionS *s, symbolS *sym, offsetT offset)
{
  s->X_op = O_symbol;
  s->X_add_symbol = sym;
  s->X_op_symbol = NULL;	/* unused */
  s->X_add_number = offset;
}


/* Set the expression to symbol - minus_sym + offset.  */

static void
set_expr_symbol_offset_diff (expressionS *s,
			     symbolS *sym,
			     symbolS *minus_sym,
			     offsetT offset)
{
  s->X_op = O_subtract;
  s->X_add_symbol = sym;
  s->X_op_symbol = minus_sym;	/* unused */
  s->X_add_number = offset;
}


/* Return TRUE if the two expressions are equal.  */

bfd_boolean
expr_is_equal (expressionS *s1, expressionS *s2)
{
  if (s1->X_op != s2->X_op)
    return FALSE;
  if (s1->X_add_symbol != s2->X_add_symbol)
    return FALSE;
  if (s1->X_op_symbol != s2->X_op_symbol)
    return FALSE;
  if (s1->X_add_number != s2->X_add_number)
    return FALSE;
  return TRUE;
}


static void
copy_expr (expressionS *dst, const expressionS *src)
{
  memcpy (dst, src, sizeof (expressionS));
}


/* Support for the "--rename-section" option.  */

struct rename_section_struct
{
  char *old_name;
  char *new_name;
  struct rename_section_struct *next;
};

static struct rename_section_struct *section_rename;


/* Parse the string "oldname=new_name(:oldname2=new_name2)*" and add
   entries to the section_rename list.  Note: Specifying multiple
   renamings separated by colons is not documented and is retained only
   for backward compatibility.  */

static void
build_section_rename (const char *arg)
{
  struct rename_section_struct *r;
  char *this_arg = NULL;
  char *next_arg = NULL;

  for (this_arg = xstrdup (arg); this_arg != NULL; this_arg = next_arg)
    {
      char *old_name, *new_name;

      if (this_arg)
	{
	  next_arg = strchr (this_arg, ':');
	  if (next_arg)
	    {
	      *next_arg = '\0';
	      next_arg++;
	    }
	}

      old_name = this_arg;
      new_name = strchr (this_arg, '=');

      if (*old_name == '\0')
	{
	  as_warn (_("ignoring extra '-rename-section' delimiter ':'"));
	  continue;
	}
      if (!new_name || new_name[1] == '\0')
	{
	  as_warn (_("ignoring invalid '-rename-section' specification: '%s'"),
		   old_name);
	  continue;
	}
      *new_name = '\0';
      new_name++;

      /* Check for invalid section renaming.  */
      for (r = section_rename; r != NULL; r = r->next)
	{
	  if (strcmp (r->old_name, old_name) == 0)
	    as_bad (_("section %s renamed multiple times"), old_name);
	  if (strcmp (r->new_name, new_name) == 0)
	    as_bad (_("multiple sections remapped to output section %s"),
		    new_name);
	}

      /* Now add it.  */
      r = (struct rename_section_struct *)
	xmalloc (sizeof (struct rename_section_struct));
      r->old_name = xstrdup (old_name);
      r->new_name = xstrdup (new_name);
      r->next = section_rename;
      section_rename = r;
    }
}


char *
xtensa_section_rename (char *name)
{
  struct rename_section_struct *r = section_rename;

  for (r = section_rename; r != NULL; r = r->next)
    {
      if (strcmp (r->old_name, name) == 0)
	return r->new_name;
    }

  return name;
}
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 2003 Free Software Foundation, Inc.
d18 1
a18 1
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, 
d22 1
a43 7
   There are 3 forms for instructions,
   1) the MEMORY format -- this is the encoding 2 or 3 byte instruction
   2) the TInsn -- handles instructions/labels and literals;
      all operands are assumed to be expressions
   3) the IStack -- a stack of TInsn.  this allows us to 
      reason about the generated expansion instructions
  
d68 2
a69 3
/* Flag to indicate whether the hardware supports the density option.
   If not, enabling density instructions (via directives or --density flag)
   is illegal.  */
a70 1
#if STATIC_LIBISA
d72 10
a81 3
#else
bfd_boolean density_supported = TRUE;
#endif
d83 4
a86 1
#define XTENSA_FETCH_WIDTH 4
d99 1
d106 1
a106 1
/* This type is used for the directive_stack to keep track of the 
d112 1
d116 1
d161 5
d169 131
d311 53
d371 1
a371 2
  directive_generics,
  directive_relax,
d374 4
a377 1
  directive_literal_prefix
d388 9
a396 8
  {"none",	FALSE},
  {"literal",	FALSE},
  {"density",	TRUE},
  {"generics",	TRUE},
  {"relax",	TRUE},
  {"freeregs",	FALSE},
  {"longcalls",	TRUE},
  {"literal_prefix", FALSE}
d403 1
a403 1
#if STATIC_LIBISA && !XCHAL_HAVE_DENSITY
d408 1
a408 2
  TRUE,				/* generics */
  TRUE,				/* relax */
d411 7
a417 95
  FALSE				/* literal_prefix */
};


enum xtensa_relax_statesE
{
  RELAX_ALIGN_NEXT_OPCODE,
  /* Use the first opcode of the next fragment to determine the
     alignment requirements.  This is ONLY used for LOOPS
     currently.  */

  RELAX_DESIRE_ALIGN_IF_TARGET,
  /* These are placed in front of labels.  They will all be converted
     to RELAX_DESIRE_ALIGN / RELAX_LOOP_END or rs_fill of 0 before
     relaxation begins.  */

  RELAX_ADD_NOP_IF_A0_B_RETW,
  /* These are placed in front of conditional branches.  It will be
     turned into a NOP (using a1) if the branch is immediately
     followed by a RETW or RETW.N.  Otherwise it will be turned into
     an rs_fill of 0 before relaxation begins.  */

  RELAX_ADD_NOP_IF_PRE_LOOP_END,
  /* These are placed after JX instructions.  It will be turned into a
     NOP if there is one instruction before a loop end label.
     Otherwise it will be turned into an rs_fill of 0 before
     relaxation begins.  This is used to avoid a hardware TIE
     interlock issue prior to T1040.  */

  RELAX_ADD_NOP_IF_SHORT_LOOP,
  /* These are placed after LOOP instructions.  It will be turned into
     a NOP when: (1) there are less than 3 instructions in the loop;
     we place 2 of these in a row to add up to 2 NOPS in short loops;
     or (2) The instructions in the loop do not include a branch or
     jump.  Otherwise it will be turned into an rs_fill of 0 before
     relaxation begins.  This is used to avoid hardware bug
     PR3830.  */

  RELAX_ADD_NOP_IF_CLOSE_LOOP_END,
  /* These are placed after LOOP instructions.  It will be turned into
     a NOP if there are less than 12 bytes to the end of some other
     loop's end.  Otherwise it will be turned into an rs_fill of 0
     before relaxation begins.  This is used to avoid hardware bug
     PR3830.  */

  RELAX_DESIRE_ALIGN,
  /* The next fragment like its first instruction to NOT cross a
     4-byte boundary.  */

  RELAX_LOOP_END,
  /* This will be turned into a NOP or NOP.N if the previous
     instruction is expanded to negate a loop.  */

  RELAX_LOOP_END_ADD_NOP,
  /* When the code density option is available, this will generate a
     NOP.N marked RELAX_NARROW.  Otherwise, it will create an rs_fill
     fragment with a NOP in it.  */

  RELAX_LITERAL,
  /* Another fragment could generate an expansion here but has not yet.  */

  RELAX_LITERAL_NR,
  /* Expansion has been generated by an instruction that generates a
     literal.  However, the stretch has NOT been reported yet in this
     fragment.  */

  RELAX_LITERAL_FINAL,
  /* Expansion has been generated by an instruction that generates a
     literal.  */

  RELAX_LITERAL_POOL_BEGIN,
  RELAX_LITERAL_POOL_END,
  /* Technically these are not relaxations at all, but mark a location
     to store literals later.  Note that fr_var stores the frchain for
     BEGIN frags and fr_var stores now_seg for END frags.  */

  RELAX_NARROW,
  /* The last instruction in this fragment (at->fr_opcode) can be
     freely replaced with a single wider instruction if a future
     alignment desires or needs it.  */

  RELAX_IMMED,
  /* The last instruction in this fragment (at->fr_opcode) contains
     the value defined by fr_symbol (fr_offset = 0).  If the value
     does not fit, use the specified expansion.  This is similar to
     "NARROW", except that these may not be expanded in order to align
     code.  */
  
  RELAX_IMMED_STEP1,
  /* The last instruction in this fragment (at->fr_opcode) contains a
     literal.  It has already been expanded at least 1 step.  */

  RELAX_IMMED_STEP2
  /* The last instruction in this fragment (at->fr_opcode) contains a
     literal.  It has already been expanded at least 2 steps.  */
a419 7
/* This is used as a stopper to bound the number of steps that
   can be taken.  */
#define RELAX_IMMED_MAXSTEPS (RELAX_IMMED_STEP2 - RELAX_IMMED)


typedef bfd_boolean (*frag_predicate) (const fragS *);

d423 8
a430 54
static bfd_boolean use_generics
  PARAMS ((void));
static bfd_boolean use_longcalls
  PARAMS ((void));
static bfd_boolean code_density_available
  PARAMS ((void));
static bfd_boolean can_relax
  PARAMS ((void));
static void directive_push
  PARAMS ((directiveE, bfd_boolean, const void *));
static void directive_pop
  PARAMS ((directiveE *, bfd_boolean *, const char **,
	   unsigned int *, const void **));
static void directive_balance
  PARAMS ((void));
static bfd_boolean inside_directive
  PARAMS ((directiveE));
static void get_directive
  PARAMS ((directiveE *, bfd_boolean *));
static void xtensa_begin_directive
  PARAMS ((int));
static void xtensa_end_directive
  PARAMS ((int));
static void xtensa_literal_prefix
  PARAMS ((char const *, int));
static void xtensa_literal_position
  PARAMS ((int));
static void xtensa_literal_pseudo
  PARAMS ((int));

/* Parsing and Idiom Translation Functions.  */

static const char *expression_end
  PARAMS ((const char *));
static unsigned tc_get_register
  PARAMS ((const char *));
static void expression_maybe_register
  PARAMS ((xtensa_operand, expressionS *));
static int tokenize_arguments
  PARAMS ((char **, char *));
static bfd_boolean parse_arguments
  PARAMS ((TInsn *, int, char **));
static int xg_translate_idioms
  PARAMS ((char **, int *, char **));
static int xg_translate_sysreg_op
  PARAMS ((char **, int *, char **));
static void xg_reverse_shift_count
  PARAMS ((char **));
static int xg_arg_is_constant
  PARAMS ((char *, offsetT *));
static void xg_replace_opname
  PARAMS ((char **, char *));
static int xg_check_num_args
  PARAMS ((int *, int, char *, char **));
d432 1
a432 1
/* Functions for dealing with the Xtensa ISA.  */
d434 1
a434 40
static bfd_boolean operand_is_immed
  PARAMS ((xtensa_operand));
static bfd_boolean operand_is_pcrel_label
  PARAMS ((xtensa_operand));
static int get_relaxable_immed
  PARAMS ((xtensa_opcode));
static xtensa_opcode get_opcode_from_buf
  PARAMS ((const char *));
static bfd_boolean is_direct_call_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_call_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_entry_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_loop_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_the_loop_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_jx_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_windowed_return_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_conditional_branch_opcode
  PARAMS ((xtensa_opcode));
static bfd_boolean is_branch_or_jump_opcode
  PARAMS ((xtensa_opcode));
static bfd_reloc_code_real_type opnum_to_reloc
  PARAMS ((int));
static int reloc_to_opnum
  PARAMS ((bfd_reloc_code_real_type));
static void xtensa_insnbuf_set_operand
  PARAMS ((xtensa_insnbuf, xtensa_opcode, xtensa_operand, int32,
	   const char *, unsigned int));
static uint32 xtensa_insnbuf_get_operand
  PARAMS ((xtensa_insnbuf, xtensa_opcode, int));
static void xtensa_insnbuf_set_immediate_field
  PARAMS ((xtensa_opcode, xtensa_insnbuf, int32, const char *,
	   unsigned int));
static bfd_boolean is_negatable_branch
  PARAMS ((TInsn *));
d438 8
a445 155
static bfd_boolean is_unique_insn_expansion
  PARAMS ((TransitionRule *));
static int xg_get_insn_size
  PARAMS ((TInsn *));
static int xg_get_build_instr_size
  PARAMS ((BuildInstr *));
static bfd_boolean xg_is_narrow_insn
  PARAMS ((TInsn *));
static bfd_boolean xg_is_single_relaxable_insn
  PARAMS ((TInsn *));
static int xg_get_max_narrow_insn_size
  PARAMS ((xtensa_opcode));
static int xg_get_max_insn_widen_size
  PARAMS ((xtensa_opcode));
static int xg_get_max_insn_widen_literal_size
  PARAMS ((xtensa_opcode));
static bfd_boolean xg_is_relaxable_insn
  PARAMS ((TInsn *, int));
static symbolS *get_special_literal_symbol
  PARAMS ((void));
static symbolS *get_special_label_symbol
  PARAMS ((void));
static bfd_boolean xg_build_to_insn
  PARAMS ((TInsn *, TInsn *, BuildInstr *));
static bfd_boolean xg_build_to_stack
  PARAMS ((IStack *, TInsn *, BuildInstr *));
static bfd_boolean xg_expand_to_stack
  PARAMS ((IStack *, TInsn *, int));
static bfd_boolean xg_expand_narrow
  PARAMS ((TInsn *, TInsn *));
static bfd_boolean xg_immeds_fit
  PARAMS ((const TInsn *));
static bfd_boolean xg_symbolic_immeds_fit
  PARAMS ((const TInsn *, segT, fragS *, offsetT, long));
static bfd_boolean xg_check_operand
  PARAMS ((int32, xtensa_operand));
static int is_dnrange
  PARAMS ((fragS *, symbolS *, long));
static int xg_assembly_relax
  PARAMS ((IStack *, TInsn *, segT, fragS *, offsetT, int, long));
static void xg_force_frag_space
  PARAMS ((int));
static void xg_finish_frag
  PARAMS ((char *, enum xtensa_relax_statesE, int, bfd_boolean));
static bfd_boolean is_branch_jmp_to_next
  PARAMS ((TInsn *, fragS *));
static void xg_add_branch_and_loop_targets
  PARAMS ((TInsn *));
static bfd_boolean xg_instruction_matches_rule
  PARAMS ((TInsn *, TransitionRule *));
static TransitionRule *xg_instruction_match
  PARAMS ((TInsn *));
static bfd_boolean xg_build_token_insn
  PARAMS ((BuildInstr *, TInsn *, TInsn *));
static bfd_boolean xg_simplify_insn
  PARAMS ((TInsn *, TInsn *));
static bfd_boolean xg_expand_assembly_insn
  PARAMS ((IStack *, TInsn *));
static symbolS *xg_assemble_literal
  PARAMS ((TInsn *));
static void xg_assemble_literal_space
  PARAMS ((int));
static symbolS *xtensa_create_literal_symbol
  PARAMS ((segT, fragS *));
static void xtensa_add_literal_sym
  PARAMS ((symbolS *));
static void xtensa_add_insn_label
  PARAMS ((symbolS *));
static void xtensa_clear_insn_labels
  PARAMS ((void));
static bfd_boolean get_is_linkonce_section
  PARAMS ((bfd *, segT));
static bfd_boolean xg_emit_insn
  PARAMS ((TInsn *, bfd_boolean));
static bfd_boolean xg_emit_insn_to_buf
  PARAMS ((TInsn *, char *, fragS *, offsetT, bfd_boolean));
static bfd_boolean xg_add_opcode_fix
  PARAMS ((xtensa_opcode, int, expressionS *, fragS *, offsetT));
static void xg_resolve_literals
  PARAMS ((TInsn *, symbolS *));
static void xg_resolve_labels
  PARAMS ((TInsn *, symbolS *));
static void xg_assemble_tokens
  PARAMS ((TInsn *));
static bfd_boolean is_register_writer
  PARAMS ((const TInsn *, const char *, int));
static bfd_boolean is_bad_loopend_opcode
  PARAMS ((const TInsn *));
static bfd_boolean is_unaligned_label
  PARAMS ((symbolS *));
static fragS *next_non_empty_frag
  PARAMS ((const fragS *));
static xtensa_opcode next_frag_opcode
  PARAMS ((const fragS *));
static void update_next_frag_nop_state
  PARAMS ((fragS *));
static bfd_boolean next_frag_is_branch_target
  PARAMS ((const fragS *));
static bfd_boolean next_frag_is_loop_target
  PARAMS ((const fragS *));
static addressT next_frag_pre_opcode_bytes
  PARAMS ((const fragS *));
static bfd_boolean is_next_frag_target
  PARAMS ((const fragS *, const fragS *));
static void xtensa_mark_literal_pool_location
  PARAMS ((void));
static void xtensa_move_labels
  PARAMS ((fragS *, valueT, bfd_boolean));
static void assemble_nop
  PARAMS ((size_t, char *));
static addressT get_expanded_loop_offset
  PARAMS ((xtensa_opcode));
static fragS *get_literal_pool_location
  PARAMS ((segT));
static void set_literal_pool_location
  PARAMS ((segT, fragS *));

/* Helpers for xtensa_end().  */

static void xtensa_cleanup_align_frags
  PARAMS ((void));
static void xtensa_fix_target_frags
  PARAMS ((void));
static bfd_boolean frag_can_negate_branch
  PARAMS ((fragS *));
static void xtensa_fix_a0_b_retw_frags
  PARAMS ((void));
static bfd_boolean next_instrs_are_b_retw
  PARAMS ((fragS *));
static void xtensa_fix_b_j_loop_end_frags
  PARAMS ((void));
static bfd_boolean next_instr_is_loop_end
  PARAMS ((fragS *));
static void xtensa_fix_close_loop_end_frags
  PARAMS ((void));
static size_t min_bytes_to_other_loop_end
  PARAMS ((fragS *, fragS *, offsetT, size_t));
static size_t unrelaxed_frag_min_size
  PARAMS ((fragS *));
static void xtensa_fix_short_loop_frags
  PARAMS ((void));
static size_t count_insns_to_loop_end
  PARAMS ((fragS *, bfd_boolean, size_t));
static size_t unrelaxed_frag_min_insn_count
  PARAMS ((fragS *));
static bfd_boolean branch_before_loop_end
  PARAMS ((fragS *));
static bfd_boolean unrelaxed_frag_has_b_j
  PARAMS ((fragS *));
static void xtensa_sanity_check
  PARAMS ((void));
static bfd_boolean is_empty_loop
  PARAMS ((const TInsn *, fragS *));
static bfd_boolean is_local_forward_loop
  PARAMS ((const TInsn *, fragS *));
d449 2
a450 14
static size_t get_text_align_power
  PARAMS ((int));
static addressT get_text_align_max_fill_size
  PARAMS ((int, bfd_boolean, bfd_boolean));
static addressT get_text_align_fill_size
  PARAMS ((addressT, int, int, bfd_boolean, bfd_boolean));
static size_t get_text_align_nop_count
  PARAMS ((size_t, bfd_boolean));
static size_t get_text_align_nth_nop_size
  PARAMS ((size_t, size_t, bfd_boolean));
static addressT get_noop_aligned_address
  PARAMS ((fragS *, addressT));
static addressT get_widen_aligned_address
  PARAMS ((fragS *, addressT));
d454 1
a454 10
static long relax_frag_text_align
  PARAMS ((fragS *, long));
static long relax_frag_add_nop
  PARAMS ((fragS *));
static long relax_frag_narrow
  PARAMS ((fragS *, long));
static bfd_boolean future_alignment_required
  PARAMS ((fragS *, long));
static long relax_frag_immed
  PARAMS ((segT, fragS *, long, int, int *));
d456 1
a456 1
/* Helpers for md_convert_frag().  */
d458 5
a462 20
static void convert_frag_align_next_opcode
  PARAMS ((fragS *));
static void convert_frag_narrow
  PARAMS ((fragS *));
static void convert_frag_immed
  PARAMS ((segT, fragS *, int));
static fixS *fix_new_exp_in_seg
  PARAMS ((segT, subsegT, fragS *, int, int, expressionS *, int,
	   bfd_reloc_code_real_type));
static void convert_frag_immed_finish_loop
  PARAMS ((segT, fragS *, TInsn *));
static offsetT get_expression_value
  PARAMS ((segT, expressionS *));

/* Flags for the Last Instruction in Each Subsegment.  */

static unsigned get_last_insn_flags
  PARAMS ((segT, subsegT));
static void set_last_insn_flags
  PARAMS ((segT, subsegT, unsigned, bfd_boolean));
d466 6
a471 22
static void xtensa_remove_section
  PARAMS ((segT));
static void xtensa_insert_section
  PARAMS ((segT, segT));
static void xtensa_move_seg_list_to_beginning
  PARAMS ((seg_list *));
static void xtensa_move_literals
  PARAMS ((void));
static void mark_literal_frags
  PARAMS ((seg_list *));
static void xtensa_reorder_seg_list
  PARAMS ((seg_list *, segT));
static void xtensa_reorder_segments
  PARAMS ((void));
static segT get_last_sec
  PARAMS ((void));
static void xtensa_switch_to_literal_fragment
  PARAMS ((emit_state *));
static void xtensa_switch_section_emit_state
  PARAMS ((emit_state *, segT, subsegT));
static void xtensa_restore_emit_state
  PARAMS ((emit_state *));
d473 1
a473 7
  PARAMS ((seg_list *, const char *, segT *));
static segT retrieve_literal_seg
  PARAMS ((seg_list *, const char *));
static segT seg_present
  PARAMS ((const char *));
static void add_seg_list
  PARAMS ((seg_list *, segT));
d475 3
a477 1
/* Property Table (e.g., ".xt.insn" and ".xt.lit") Functions.  */
d479 1
a479 14
static void xtensa_create_property_segments
  PARAMS ((frag_predicate, const char *, xt_section_type));
static segment_info_type *retrieve_segment_info
  PARAMS ((segT));
static segT retrieve_xtensa_section
  PARAMS ((char *));
static bfd_boolean section_has_property
  PARAMS ((segT sec, frag_predicate));
static void add_xt_block_frags
  PARAMS ((segT, segT, xtensa_block_info **, frag_predicate));
static bfd_boolean get_frag_is_literal
  PARAMS ((const fragS *));
static bfd_boolean get_frag_is_insn
  PARAMS ((const fragS *));
d481 4
a484 3
/* Import from elf32-xtensa.c in BFD library.  */
extern char *xtensa_get_property_section_name
  PARAMS ((asection *, const char *));
d487 20
a506 18
static bfd_boolean tinsn_has_symbolic_operands
  PARAMS ((const TInsn *));
static bfd_boolean tinsn_has_invalid_symbolic_operands
  PARAMS ((const TInsn *));
static bfd_boolean tinsn_has_complex_operands
  PARAMS ((const TInsn *));
static bfd_boolean tinsn_to_insnbuf
  PARAMS ((TInsn *, xtensa_insnbuf));
static bfd_boolean tinsn_check_arguments
  PARAMS ((const TInsn *));
static void tinsn_from_chars
  PARAMS ((TInsn *, char *));
static void tinsn_immed_from_frag
  PARAMS ((TInsn *, fragS *));
static int get_num_stack_text_bytes
  PARAMS ((IStack *));
static int get_num_stack_literal_bytes
  PARAMS ((IStack *));
d509 15
a523 19
bfd_boolean expr_is_const
  PARAMS ((const expressionS *));
offsetT get_expr_const
  PARAMS ((const expressionS *));
void set_expr_const
  PARAMS ((expressionS *, offsetT));
void set_expr_symbol_offset
  PARAMS ((expressionS *, symbolS *, offsetT));
bfd_boolean expr_is_equal
  PARAMS ((expressionS *, expressionS *));
static void copy_expr
  PARAMS ((expressionS *, const expressionS *));

#ifdef XTENSA_SECTION_RENAME
static void build_section_rename
  PARAMS ((const char *));
static void add_section_rename
  PARAMS ((char *, char *));
#endif
d541 1
d543 2
a545 1
static xtensa_opcode xtensa_j_opcode;
d547 1
d551 1
d558 1
a558 1
static xtensa_opcode xtensa_rsr_opcode;
d566 1
a566 2
static bfd_boolean align_only_targets = FALSE;
static bfd_boolean software_a0_b_retw_interlock = TRUE;
d568 6
a573 1
static bfd_boolean workaround_a0_b_retw = TRUE;
d575 5
a579 3
static bfd_boolean software_avoid_b_j_loop_end = TRUE;
static bfd_boolean workaround_b_j_loop_end = TRUE;
static bfd_boolean maybe_has_b_j_loop_end = FALSE;
d581 1
a581 3
static bfd_boolean software_avoid_short_loop = TRUE;
static bfd_boolean workaround_short_loop = TRUE;
static bfd_boolean maybe_has_short_loop = FALSE;
a582 3
static bfd_boolean software_avoid_close_loop_end = TRUE;
static bfd_boolean workaround_close_loop_end = TRUE;
static bfd_boolean maybe_has_close_loop_end = FALSE;
d584 5
a588 5
/* When avoid_short_loops is true, all loops with early exits must
   have at least 3 instructions.  avoid_all_short_loops is a modifier
   to the avoid_short_loop flag.  In addition to the avoid_short_loop
   actions, all straightline loopgtz and loopnez must have at least 3
   instructions.  */
d590 10
a599 2
static bfd_boolean software_avoid_all_short_loops = TRUE;
static bfd_boolean workaround_all_short_loops = TRUE;
a600 2
/* This is on a per-instruction basis.  */
static bfd_boolean specific_opcode = FALSE;
d610 3
d616 3
d622 3
d628 1
a628 2
  option_align_only_targets,
  option_no_align_only_targets,
a649 5
#ifdef XTENSA_SECTION_RENAME
  option_literal_section_name,
  option_text_section_name,
  option_data_section_name,
  option_bss_section_name,
a650 1
#endif
d652 4
a655 2
  option_eb,
  option_el
d662 17
a678 13
  {"density", no_argument, NULL, option_density},
  {"no-density", no_argument, NULL, option_no_density},
  /* At least as early as alameda, --[no-]relax didn't work as
     documented, so as of albany, --[no-]relax is equivalent to
     --[no-]generics.  Both of these will be deprecated in
     BearValley.  */
  {"relax", no_argument, NULL, option_generics},
  {"no-relax", no_argument, NULL, option_no_generics},
  {"generics", no_argument, NULL, option_generics},
  {"no-generics", no_argument, NULL, option_no_generics},
  {"text-section-literals", no_argument, NULL, option_text_section_literals},
  {"no-text-section-literals", no_argument, NULL,
   option_no_text_section_literals},
d681 42
a722 50
  {"target-align", no_argument, NULL, option_align_targets},
  {"no-target-align", no_argument, NULL,
   option_no_align_targets},
#if 0
  /* This option  should do a better job aligning targets because
     it will only attempt to align targets that are the target of a 
     branch.  */
   { "target-align-only", no_argument, NULL, option_align_only_targets },
   { "no-target-align-only", no_argument, NULL, option_no_align_only_targets },
#endif /* 0 */
  {"longcalls", no_argument, NULL, option_longcalls},
  {"no-longcalls", no_argument, NULL, option_no_longcalls},

  {"no-workaround-a0-b-retw", no_argument, NULL,
   option_no_workaround_a0_b_retw},
  {"workaround-a0-b-retw", no_argument, NULL, option_workaround_a0_b_retw},
  
  {"no-workaround-b-j-loop-end", no_argument, NULL,
   option_no_workaround_b_j_loop_end},
  {"workaround-b-j-loop-end", no_argument, NULL,
   option_workaround_b_j_loop_end},
  
  {"no-workaround-short-loops", no_argument, NULL,
   option_no_workaround_short_loop},
  {"workaround-short-loops", no_argument, NULL, option_workaround_short_loop},

  {"no-workaround-all-short-loops", no_argument, NULL,
   option_no_workaround_all_short_loops},
  {"workaround-all-short-loop", no_argument, NULL,
   option_workaround_all_short_loops},

  {"no-workaround-close-loop-end", no_argument, NULL,
   option_no_workaround_close_loop_end},
  {"workaround-close-loop-end", no_argument, NULL,
   option_workaround_close_loop_end},

  {"no-workarounds", no_argument, NULL, option_no_workarounds},

#ifdef XTENSA_SECTION_RENAME
  {"literal-section-name", required_argument, NULL,
   option_literal_section_name},
  {"text-section-name", required_argument, NULL,
   option_text_section_name},
  {"data-section-name", required_argument, NULL,
   option_data_section_name},
  {"rename-section", required_argument, NULL,
   option_rename_section_name},
  {"bss-section-name", required_argument, NULL,
   option_bss_section_name},
#endif /* XTENSA_SECTION_RENAME */
d724 1
a724 1
  {NULL, no_argument, NULL, 0}
d731 1
a731 3
md_parse_option (c, arg)
     int c;
     char *arg;
d736 1
a736 7
      if (!density_supported)
	{
	  as_bad (_("'--density' option not supported in this Xtensa "
		  "configuration"));
	  return 0;
	}
      directive_state[directive_density] = TRUE;
d739 7
a745 1
      directive_state[directive_density] = FALSE;
d748 2
a749 2
      directive_state[directive_generics] = TRUE;
      return 1;
d751 8
a758 2
      directive_state[directive_generics] = FALSE;
      return 1;
d771 12
a784 1
      software_a0_b_retw_interlock = TRUE;
a787 1
      software_a0_b_retw_interlock = FALSE;
a790 1
      software_avoid_b_j_loop_end = TRUE;
a793 1
      software_avoid_b_j_loop_end = FALSE;
a797 1
      software_avoid_short_loop = TRUE;
a800 1
      software_avoid_short_loop = FALSE;
a804 1
      software_avoid_all_short_loops = TRUE;
a807 1
      software_avoid_all_short_loops = FALSE;
a811 1
      software_avoid_close_loop_end = TRUE;
a814 1
      software_avoid_close_loop_end = FALSE;
a818 1
      software_a0_b_retw_interlock = FALSE;
a819 1
      software_avoid_b_j_loop_end = FALSE;
a820 1
      software_avoid_short_loop = FALSE;
a821 1
      software_avoid_all_short_loops = FALSE;
a822 1
      software_avoid_close_loop_end = FALSE;
d824 1
a824 1
      
d832 2
a833 2
    case option_align_only_targets:
      align_only_targets = TRUE;
d835 3
a837 2
    case option_no_align_only_targets:
      align_only_targets = FALSE;
d840 9
a848 5
#ifdef XTENSA_SECTION_RENAME
    case option_literal_section_name:
      add_section_rename (".literal", arg);
      as_warn (_("'--literal-section-name' is deprecated; "
		 "use '--rename-section .literal=NEWNAME'"));
d851 4
a854 4
    case option_text_section_name:
      add_section_rename (".text", arg);
      as_warn (_("'--text-section-name' is deprecated; "
		 "use '--rename-section .text=NEWNAME'"));
d857 22
a878 5
    case option_data_section_name:
      add_section_rename (".data", arg);
      as_warn (_("'--data-section-name' is deprecated; "
		 "use '--rename-section .data=NEWNAME'"));
      return 1;
d880 3
a882 4
    case option_bss_section_name:
      add_section_rename (".bss", arg);
      as_warn (_("'--bss-section-name' is deprecated; "
		 "use '--rename-section .bss=NEWNAME'"));
d885 8
a892 2
    case option_rename_section_name:
      build_section_rename (arg);
a893 1
#endif /* XTENSA_SECTION_RENAME */
a894 5
    case 'Q':
      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
         should be emitted or not.  FIXME: Not implemented.  */
      return 1;
      
d902 38
a939 2
md_show_usage (stream)
     FILE *stream;
d941 47
a987 19
  fputs ("\nXtensa options:\n"
	 "--[no-]density          [Do not] emit density instructions\n"
	 "--[no-]relax            [Do not] perform branch relaxation\n"
	 "--[no-]generics         [Do not] transform instructions\n"
	 "--[no-]longcalls        [Do not] emit 32-bit call sequences\n"
	 "--[no-]target-align     [Do not] try to align branch targets\n"
	 "--[no-]text-section-literals\n"
	 "                        [Do not] put literals in the text section\n"
	 "--no-workarounds        Do not use any Xtensa workarounds\n"
#ifdef XTENSA_SECTION_RENAME
	 "--rename-section old=new(:old1=new1)*\n"
	 "                        Rename section 'old' to 'new'\n"
	 "\nThe following Xtensa options are deprecated\n"
	 "--literal-section-name  Name of literal section (default .literal)\n"
	 "--text-section-name     Name of text section (default .text)\n"
	 "--data-section-name     Name of data section (default .data)\n"
	 "--bss-section-name      Name of bss section (default .bss)\n"
#endif
	 , stream);
d1008 12
a1019 8
  {"align", s_align_bytes, 0},	/* Defaulting is invalid (0) */
  {"literal_position", xtensa_literal_position, 0},
  {"frame", s_ignore, 0},	/* formerly used for STABS debugging */
  {"word", cons, 4},
  {"begin", xtensa_begin_directive, 0},
  {"end", xtensa_end_directive, 0},
  {"literal", xtensa_literal_pseudo, 0},
  {NULL, 0, 0},
d1023 2
a1024 2
bfd_boolean
use_generics ()
d1026 4
a1029 1
  return directive_state[directive_generics];
d1033 2
a1034 2
bfd_boolean
use_longcalls ()
d1036 4
a1039 1
  return directive_state[directive_longcalls];
d1043 2
a1044 9
bfd_boolean
code_density_available ()
{
  return directive_state[directive_density];
}


bfd_boolean
can_relax ()
d1046 4
a1049 1
  return use_generics ();
d1054 1
a1054 4
directive_push (directive, negated, datum)
     directiveE directive;
     bfd_boolean negated;
     const void *datum;
d1074 1
d1076 5
a1080 6
directive_pop (directive, negated, file, line, datum)
     directiveE *directive;
     bfd_boolean *negated;
     const char **file;
     unsigned int *line;
     const void **datum;
d1103 1
a1103 1
directive_balance ()
d1121 1
a1121 2
inside_directive (dir)
     directiveE dir;
d1133 1
a1133 3
get_directive (directive, negated)
     directiveE *directive;
     bfd_boolean *negated;
d1137 1
d1148 18
a1165 1
		"abcdefghijklmnopqrstuvwxyz_/0123456789.");
d1169 1
a1169 1
      if (strncmp (input_line_pointer, directive_info[i].name, len) == 0)
d1174 1
a1174 1
	    as_bad (_("directive %s can't be negated"),
d1186 1
a1186 2
xtensa_begin_directive (ignore)
     int ignore ATTRIBUTE_UNUSED;
a1193 2
  md_flush_pending_output ();

d1201 3
d1214 1
d1221 3
d1226 1
a1226 1
      if (frag_now->tc_frag_data.is_literal)
d1262 8
d1271 6
a1276 1
      if (!density_supported && !negated)
d1278 1
a1278 1
	  as_warn (_("Xtensa density option not supported; ignored"));
d1281 3
a1283 1
      /* fall through */
d1286 2
d1297 1
a1297 2
xtensa_end_directive (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1304 1
d1307 5
d1314 1
a1314 2
  get_directive (&end_directive, &end_negated);
  if (end_directive == (directiveE) XTENSA_UNDEFINED)
d1316 1
a1318 1
    }
d1320 2
a1321 3
  if (end_directive == directive_density && !density_supported && !end_negated)
    {
      as_warn (_("Xtensa density option not supported; ignored"));
d1323 13
a1335 1
      return;
d1338 1
d1340 1
a1340 1
		 (const void **) &state);
d1357 1
a1366 3
	    case directive_freeregs:
	      break;

d1379 4
d1384 1
d1394 22
d1419 1
a1419 2
xtensa_literal_position (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1421 2
d1425 1
a1425 2
  else if (!use_literal_section)
    xtensa_mark_literal_pool_location ();
d1432 1
a1432 1
/* Support .literal label, value@@plt + offset.  */
d1435 1
a1435 2
xtensa_literal_pseudo (ignored)
     int ignored ATTRIBUTE_UNUSED;
a1439 1
  expressionS expP;
d1449 2
d1463 1
a1463 1
  /* ...but if we aren't using text-section-literals, then we 
d1465 1
a1465 1
  if (use_literal_section)
d1468 3
a1470 3
  /* All literals are aligned to four-byte boundaries
     which is handled by switch to literal fragment.  */
  /* frag_align (2, 0, 0);  */
a1489 11
  do 
    {
      input_line_pointer++;		/* skip ',' or ':' */
      
      expr (0, &expP);

      /* We only support 4-byte literals with .literal.  */
      emit_expr (&expP, 4);
    }
  while (*input_line_pointer == ',');

d1491 1
d1493 1
a1493 1
  demand_empty_rest_of_line ();
d1504 5
a1508 15
xtensa_literal_prefix (start, len)
     char const *start;
     int len;
{
  segT s_now;			/* Storage for the current seg and subseg.  */
  subsegT ss_now;
  char *name;			/* Pointer to the name itself.  */
  char *newname;

  if (!use_literal_section)
    return;

  /* Store away the current section and subsection.  */
  s_now = now_seg;
  ss_now = now_subseg;
d1519 1
d1521 1
a1521 2
  strcpy (newname, name);
  strcpy (newname + len, ".literal");
d1523 27
a1549 1
  /* Note that retrieve_literal_seg does not create a segment if 
d1551 2
a1552 1
  default_lit_sections.lit_seg = NULL;	/* retrieved on demand */
d1556 2
a1557 2
  default_lit_sections.lit_seg_name =
    tc_canonicalize_symbol_name (newname);
d1560 86
d1647 2
a1648 3
  /* Restore the current section and subsection and set the 
     generation into the old segment.  */
  subseg_set (s_now, ss_now);
d1654 74
d1729 1
a1729 2
expression_end (name)
     const char *name;
d1735 1
d1739 1
d1755 1
a1755 2
tc_get_register (prefix)
     const char *prefix;
a1808 3
#define PLT_SUFFIX "@@PLT"
#define plt_suffix "@@plt"

d1810 1
a1810 3
expression_maybe_register (opnd, tok)
     xtensa_operand opnd;
     expressionS *tok;
d1812 1
a1812 1
  char *kind = xtensa_operand_kind (opnd);
d1814 2
a1815 2
  if ((strlen (kind) == 1)
      && (*kind == 'l' || *kind == 'L' || *kind == 'i' || *kind == 'r'))
d1817 1
d1819 2
a1820 1
      if (t == absolute_section && operand_is_pcrel_label (opnd))
d1826 4
a1829 5
      if (tok->X_op == O_symbol 
	  && (!strncmp (input_line_pointer, PLT_SUFFIX,
			strlen (PLT_SUFFIX) - 1)
	      || !strncmp (input_line_pointer, plt_suffix,
			   strlen (plt_suffix) - 1)))
d1831 25
a1855 2
	  symbol_get_tc (tok->X_add_symbol)->plt = 1;
	  input_line_pointer += strlen (plt_suffix);
d1860 2
a1861 1
      unsigned reg = tc_get_register (kind);
d1866 1
a1866 2
	  if ((xtensa_operand_encode (opnd, &buf) != xtensa_encode_result_ok)
	      || (reg != xtensa_operand_decode (opnd, buf)))
d1880 1
a1880 3
tokenize_arguments (args, str)
     char **args;
     char *str;
d1885 1
d1889 2
a1890 2
  
  /* Save and restore input_line_pointer around this function.  */ 
d1900 1
d1903 7
d1912 1
a1912 1
	  if (saw_comma || !saw_arg)
d1918 1
a1918 1
	  if (!saw_comma && saw_arg)
d1924 1
a1924 1
 
d1926 1
a1926 1
	  arg = (char *) xmalloc (arg_len + 1);
d1929 2
d1933 1
a1933 1
 
d1937 1
d1944 1
a1944 1
  if (saw_comma)
d1950 8
d1963 1
a1963 1
/* Parse the arguments to an opcode.  Return true on error.  */
d1966 1
a1966 4
parse_arguments (insn, num_args, arg_strings)
     TInsn *insn;
     int num_args;
     char **arg_strings;
d1968 1
a1968 1
  expressionS *tok = insn->tok;
d1971 2
a1972 2
  xtensa_isa isa = xtensa_default_isa; 
  int n;
d1974 2
a1975 2
  int actual_operand_count = 0;
  xtensa_operand opnd = NULL; 
d1981 1
a1981 1
    opcode_operand_count = xtensa_num_operands (isa, opcode);
d1983 1
d1987 12
a1998 1
  old_input_line_pointer = input_line_pointer; 
d2001 1
a2001 1
    { 
d2003 47
d2051 2
a2052 15
      if (actual_operand_count >= opcode_operand_count)
	{ 
	  as_warn (_("too many arguments")); 
	  goto err;
	} 
      assert (actual_operand_count < MAX_INSN_ARGS);

      opnd = xtensa_get_operand (isa, opcode, actual_operand_count); 
      expression_maybe_register (opnd, tok);

      if (tok->X_op == O_illegal || tok->X_op == O_absent) 
	goto err; 
      actual_operand_count++;
      tok++; 
    } 
d2058 1
a2058 1
  input_line_pointer = old_input_line_pointer; 
d2063 68
d2132 1
a2132 2
xg_reverse_shift_count (cnt_argp)
     char **cnt_argp;
d2150 1
a2150 3
xg_arg_is_constant (arg, valp)
     char *arg;
     offsetT *valp;
d2170 1
a2170 3
xg_replace_opname (popname, newop)
     char **popname;
     char *newop;
d2179 4
a2182 5
xg_check_num_args (pnum_args, expected_num, opname, arg_strings)
     int *pnum_args;
     int expected_num; 
     char *opname;
     char **arg_strings;
d2186 1
a2186 1
  if (num_args < expected_num) 
d2210 3
d2214 1
a2214 4
xg_translate_sysreg_op (popname, pnum_args, arg_strings)
     char **popname;
     int *pnum_args;
     char **arg_strings;
d2216 2
d2219 2
a2220 1
  offsetT val;
d2229 2
d2232 1
a2232 1
  /* Opname == [rw]ur... */
d2234 11
a2244 1
  if (opname[3] == '\0')
d2246 2
a2247 6
      /* If the register is not specified as part of the opcode,
	 then get it from the operand and move it to the opcode.  */

      if (xg_check_num_args (pnum_args, 2, opname, arg_strings))
	return -1;

d2250 9
a2258 1
	  as_bad (_("register number for `%s' is not a constant"), opname);
d2261 64
a2324 1
      if ((unsigned) val > 255)
d2326 1
a2326 1
	  as_bad (_("register number (%ld) for `%s' is out of range"),
d2330 29
d2360 5
a2364 1
      /* Remove the last argument, which is now part of the opcode.  */
d2366 3
a2368 9
      arg_strings[1] = 0;
      *pnum_args = 1;

      /* Translate the opcode.  */
      new_opname = (char *) xmalloc (8);
      sprintf (new_opname, "%s%cur%u", (has_underbar ? "_" : ""),
	       opname[0], (unsigned) val);
      free (*popname);
      *popname = new_opname;
d2379 1
a2379 4
xg_translate_idioms (popname, pnum_args, arg_strings)
     char **popname;
     int *pnum_args;
     char **arg_strings;
d2384 3
d2395 1
a2395 1
      if (!has_underbar && code_density_available ())
d2429 2
a2430 1
  if (strcmp (opname, "nop") == 0)
d2432 1
a2432 1
      if (!has_underbar && code_density_available ())
d2450 6
a2455 3
  if ((opname[0] == 'r' || opname[0] == 'w')
      && opname[1] == 'u'
      && opname[2] == 'r')
d2458 5
d2464 3
a2466 29
  /* WIDENING DENSITY OPCODES

     questionable relaxations (widening) from old "tai" idioms:

       ADD.N --> ADD
       BEQZ.N --> BEQZ
       RET.N --> RET
       RETW.N --> RETW
       MOVI.N --> MOVI
       MOV.N --> MOV
       NOP.N --> NOP

     Note: this incomplete list was imported to match the "tai"
     behavior; other density opcodes are not handled.

     The xtensa-relax code may know how to do these but it doesn't do
     anything when these density opcodes appear inside a no-density
     region.  Somehow GAS should either print an error when that happens
     or do the widening.  The old "tai" behavior was to do the widening.
     For now, I'll make it widen but print a warning.

     FIXME: GAS needs to detect density opcodes inside no-density
     regions and treat them as errors.  This code should be removed
     when that is done.  */

  if (use_generics ()
      && !has_underbar
      && density_supported
      && !code_density_available ())
d2468 3
a2470 2
      if (strcmp (opname, "add.n") == 0)
	xg_replace_opname (popname, "add");
d2472 3
a2474 2
      else if (strcmp (opname, "beqz.n") == 0)
	xg_replace_opname (popname, "beqz");
d2476 3
a2478 2
      else if (strcmp (opname, "ret.n") == 0)
	xg_replace_opname (popname, "ret");
d2480 3
a2482 29
      else if (strcmp (opname, "retw.n") == 0)
	xg_replace_opname (popname, "retw");

      else if (strcmp (opname, "movi.n") == 0)
	xg_replace_opname (popname, "movi");

      else if (strcmp (opname, "mov.n") == 0)
	{
	  if (xg_check_num_args (pnum_args, 2, opname, arg_strings))
	    return -1;
	  xg_replace_opname (popname, "or");
	  arg_strings[2] = (char *) xmalloc (strlen (arg_strings[1]) + 1);
	  strcpy (arg_strings[2], arg_strings[1]);
	  *pnum_args = 3;
	}

      else if (strcmp (opname, "nop.n") == 0)
	{
	  if (xg_check_num_args (pnum_args, 0, opname, arg_strings))
	    return -1;
	  xg_replace_opname (popname, "or");
	  arg_strings[0] = (char *) xmalloc (3);
	  arg_strings[1] = (char *) xmalloc (3);
	  arg_strings[2] = (char *) xmalloc (3);
	  strcpy (arg_strings[0], "a1");
	  strcpy (arg_strings[1], "a1");
	  strcpy (arg_strings[2], "a1");
	  *pnum_args = 3;
	}
d2491 6
a2496 3
/* Return true if the given operand is an immed or target instruction,
   i.e., has a reloc associated with it.  Currently, this is only true
   if the operand kind is "i, "l" or "L".  */
d2498 2
a2499 49
static bfd_boolean
operand_is_immed (opnd)
     xtensa_operand opnd;
{
  const char *opkind = xtensa_operand_kind (opnd);
  if (opkind[0] == '\0' || opkind[1] != '\0')
    return FALSE;
  switch (opkind[0])
    {
    case 'i':
    case 'l':
    case 'L':
      return TRUE;
    }
  return FALSE;
}


/* Return true if the given operand is a pc-relative label.  This is
   true for "l", "L", and "r" operand kinds.  */

bfd_boolean
operand_is_pcrel_label (opnd)
     xtensa_operand opnd;
{
  const char *opkind = xtensa_operand_kind (opnd);
  if (opkind[0] == '\0' || opkind[1] != '\0')
    return FALSE;
  switch (opkind[0])
    {
    case 'r':
    case 'l':
    case 'L':
      return TRUE;
    }
  return FALSE;
}


/* Currently the assembler only allows us to use a single target per
   fragment.  Because of this, only one operand for a given
   instruction may be symbolic.  If there is an operand of kind "lrL",
   the last one is chosen.  Otherwise, the result is the number of the
   last operand of type "i", and if there are none of those, we fail
   and return -1.  */

int
get_relaxable_immed (opcode)
     xtensa_opcode opcode;
a2502 1
  xtensa_operand operand;
d2507 1
a2507 1
  noperands = xtensa_num_operands (xtensa_default_isa, opcode);
d2510 3
a2512 2
      operand = xtensa_get_operand (xtensa_default_isa, opcode, opi);
      if (operand_is_pcrel_label (operand))
d2514 2
a2515 1
      if (last_immed == -1 && operand_is_immed (operand))
d2522 2
a2523 3
xtensa_opcode
get_opcode_from_buf (buf)
     const char *buf;
d2526 1
a2526 1
  xtensa_opcode opcode;
d2528 2
d2531 12
a2542 1
    insnbuf = xtensa_insnbuf_alloc (isa);
d2544 2
a2545 3
  xtensa_insnbuf_from_chars (isa, insnbuf, buf);
  opcode = xtensa_decode_insn (isa, insnbuf);
  return opcode;
d2549 6
a2554 3
static bfd_boolean
is_direct_call_opcode (opcode)
     xtensa_opcode opcode;
d2556 3
a2558 2
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;
d2560 23
a2582 4
  return (opcode == xtensa_call0_opcode
	  || opcode == xtensa_call4_opcode
	  || opcode == xtensa_call8_opcode
	  || opcode == xtensa_call12_opcode);
d2586 2
a2587 3
static bfd_boolean
is_call_opcode (opcode)
     xtensa_opcode opcode;
d2589 6
a2594 2
  if (is_direct_call_opcode (opcode))
    return TRUE;
d2596 5
a2600 2
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;
d2602 20
a2621 4
  return (opcode == xtensa_callx0_opcode
	  || opcode == xtensa_callx4_opcode
	  || opcode == xtensa_callx8_opcode
	  || opcode == xtensa_callx12_opcode);
d2624 1
a2625 3
/* Return true if the opcode is an entry opcode.  This is used because
   "entry" adds an implicit ".align 4" and also the entry instruction
   has an extra check for an operand value.  */
d2628 1
a2628 2
is_entry_opcode (opcode)
     xtensa_opcode opcode;
d2630 4
a2633 1
  if (opcode == XTENSA_UNDEFINED)
d2636 8
a2643 1
  return (opcode == xtensa_entry_opcode);
d2647 2
a2648 3
/* Return true if it is one of the loop opcodes.  Loops are special
   because they need automatic alignment and they have a relaxation so
   complex that we hard-coded it.  */
d2650 2
a2651 3
static bfd_boolean
is_loop_opcode (opcode)
     xtensa_opcode opcode;
d2653 14
a2666 2
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;
d2668 1
a2668 3
  return (opcode == xtensa_loop_opcode
	  || opcode == xtensa_loopnez_opcode
	  || opcode == xtensa_loopgtz_opcode);
d2672 6
a2677 3
static bfd_boolean
is_the_loop_opcode (opcode)
     xtensa_opcode opcode;
d2679 2
a2680 2
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;
d2682 1
a2682 1
  return (opcode == xtensa_loop_opcode);
d2686 5
a2690 3
static bfd_boolean
is_jx_opcode (opcode)
     xtensa_opcode opcode;
d2692 2
a2693 2
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;
d2695 1
a2695 1
  return (opcode == xtensa_jx_opcode);
d2699 29
a2727 2
/* Return true if the opcode is a retw or retw.n.
   Needed to add nops to avoid a hardware interlock issue.  */
a2728 6
static bfd_boolean
is_windowed_return_opcode (opcode)
     xtensa_opcode opcode;
{
  if (opcode == XTENSA_UNDEFINED)
    return FALSE;
d2730 12
a2741 1
  return (opcode == xtensa_retw_opcode || opcode == xtensa_retw_n_opcode);
d2744 2
d2747 5
a2751 1
/* Return true if the opcode type is "l" and the opcode is NOT a jump.  */
d2754 2
a2755 2
is_conditional_branch_opcode (opcode)
     xtensa_opcode opcode;
d2757 8
a2764 8
  xtensa_isa isa = xtensa_default_isa;
  int num_ops, i;

  if (opcode == xtensa_j_opcode && opcode != XTENSA_UNDEFINED)
    return FALSE;

  num_ops = xtensa_num_operands (isa, opcode);
  for (i = 0; i < num_ops; i++)
d2766 2
a2767 3
      xtensa_operand operand = xtensa_get_operand (isa, opcode, i);
      if (strcmp (xtensa_operand_kind (operand), "l") == 0)
	return TRUE;
a2768 1
  return FALSE;
d2772 3
a2774 7
/* Return true if the given opcode is a conditional branch
   instruction, i.e., currently this is true if the instruction 
   is a jx or has an operand with 'l' type and is not a loop.  */

bfd_boolean
is_branch_or_jump_opcode (opcode)
     xtensa_opcode opcode;
d2776 3
a2778 13
  int opn, op_count;

  if (opcode == XTENSA_UNDEFINED)
    return FALSE;

  if (is_loop_opcode (opcode))
    return FALSE;

  if (is_jx_opcode (opcode))
    return TRUE;

  op_count = xtensa_num_operands (xtensa_default_isa, opcode);
  for (opn = 0; opn < op_count; opn++)
d2780 1
a2780 4
      xtensa_operand opnd =
	xtensa_get_operand (xtensa_default_isa, opcode, opn);
      const char *opkind = xtensa_operand_kind (opnd);
      if (opkind && opkind[0] == 'l' && opkind[1] == '\0')
d2787 2
a2788 6
/* Convert from operand numbers to BFD relocation type code.
   Return BFD_RELOC_NONE on failure.  */

bfd_reloc_code_real_type
opnum_to_reloc (opnum)
     int opnum;
d2790 10
a2799 10
  switch (opnum)
    {
    case 0:
      return BFD_RELOC_XTENSA_OP0;
    case 1:
      return BFD_RELOC_XTENSA_OP1;
    case 2:
      return BFD_RELOC_XTENSA_OP2;
    default:
      break;
d2801 1
a2801 1
  return BFD_RELOC_NONE;
d2805 1
a2805 2
/* Convert from BFD relocation type code to operand number.
   Return -1 on failure.  */
d2807 2
a2808 3
int
reloc_to_opnum (reloc)
     bfd_reloc_code_real_type reloc;
d2810 8
a2817 1
  switch (reloc)
d2819 70
a2888 8
    case BFD_RELOC_XTENSA_OP0:
      return 0;
    case BFD_RELOC_XTENSA_OP1:
      return 1;
    case BFD_RELOC_XTENSA_OP2:
      return 2;
    default:
      break;
d2890 4
a2893 1
  return -1;
d2897 2
a2898 8
static void
xtensa_insnbuf_set_operand (insnbuf, opcode, operand, value, file, line)
     xtensa_insnbuf insnbuf;
     xtensa_opcode opcode;
     xtensa_operand operand;
     int32 value;
     const char *file;
     unsigned int line;
d2900 5
a2904 2
  xtensa_encode_result encode_result;
  uint32 valbuf = value;
d2906 2
a2907 1
  encode_result = xtensa_operand_encode (operand, &valbuf);
d2909 1
a2909 1
  switch (encode_result)
d2911 36
a2946 29
    case xtensa_encode_result_ok:
      break;
    case xtensa_encode_result_align:
      as_bad_where ((char *) file, line,
		    _("operand %d not properly aligned for '%s'"),
		    value, xtensa_opcode_name (xtensa_default_isa, opcode));
      break;
    case xtensa_encode_result_not_in_table:
      as_bad_where ((char *) file, line,
		    _("operand %d not in immediate table for '%s'"),
		    value, xtensa_opcode_name (xtensa_default_isa, opcode));
      break;
    case xtensa_encode_result_too_high:
      as_bad_where ((char *) file, line,
		    _("operand %d too large for '%s'"), value,
		    xtensa_opcode_name (xtensa_default_isa, opcode));
      break;
    case xtensa_encode_result_too_low:
      as_bad_where ((char *) file, line,
		    _("operand %d too small for '%s'"), value,
		    xtensa_opcode_name (xtensa_default_isa, opcode));
      break;
    case xtensa_encode_result_not_ok:
      as_bad_where ((char *) file, line,
		    _("operand %d is invalid for '%s'"), value,
		    xtensa_opcode_name (xtensa_default_isa, opcode));
      break;
    default:
      abort ();
d2948 2
d2951 3
a2953 2
  xtensa_operand_set_field (operand, insnbuf, valbuf);
}
d2955 4
d2960 1
a2960 8
static uint32
xtensa_insnbuf_get_operand (insnbuf, opcode, opnum)
     xtensa_insnbuf insnbuf;
     xtensa_opcode opcode;
     int opnum;
{
  xtensa_operand op = xtensa_get_operand (xtensa_default_isa, opcode, opnum);
  return xtensa_operand_decode (op, xtensa_operand_get_field (op, insnbuf));
d2964 2
a2965 7
static void
xtensa_insnbuf_set_immediate_field (opcode, insnbuf, value, file, line)
     xtensa_opcode opcode;
     xtensa_insnbuf insnbuf;
     int32 value;
     const char *file;
     unsigned int line;
d2967 3
a2969 5
  xtensa_isa isa = xtensa_default_isa;
  int last_opnd = xtensa_num_operands (isa, opcode) - 1;
  xtensa_operand operand = xtensa_get_operand (isa, opcode, last_opnd);
  xtensa_insnbuf_set_operand (insnbuf, opcode, operand, value, file, line);
}
d2971 2
a2972 10

static bfd_boolean
is_negatable_branch (insn)
     TInsn *insn;
{
  xtensa_isa isa = xtensa_default_isa;
  int i;
  int num_ops = xtensa_num_operands (isa, insn->opcode);

  for (i = 0; i < num_ops; i++)
d2974 3
a2976 4
      xtensa_operand opnd = xtensa_get_operand (isa, insn->opcode, i);
      char *kind = xtensa_operand_kind (opnd);
      if (strlen (kind) == 1 && *kind == 'l')
	return TRUE;
d2978 1
a2978 1
  return FALSE;
d2985 1
a2985 2
is_unique_insn_expansion (r)
     TransitionRule *r;
d2996 1
a2996 2
xg_get_insn_size (insn)
     TInsn *insn;
d2998 2
a2999 2
  assert (insn->insn_type == ITYPE_INSN);
  return xtensa_insn_length (xtensa_default_isa, insn->opcode);
d3003 2
a3004 12
static int
xg_get_build_instr_size (insn)
     BuildInstr *insn;
{
  assert (insn->typ == INSTR_INSTR);
  return xtensa_insn_length (xtensa_default_isa, insn->opcode);
}


bfd_boolean
xg_is_narrow_insn (insn)
     TInsn *insn;
d3006 1
a3006 1
  TransitionTable *table = xg_build_widen_table ();
d3022 1
a3022 1
	  if (xg_get_insn_size (insn)
d3035 2
a3036 3
bfd_boolean
xg_is_single_relaxable_insn (insn)
     TInsn *insn;
d3038 1
a3038 1
  TransitionTable *table = xg_build_widen_table ();
d3051 1
d3054 1
a3054 1
	  if (xg_get_insn_size (insn)
a3066 35
/* Return the largest size instruction that this instruction can
   expand to.  Currently, in all cases, this is 3 bytes.  Of course we
   could just calculate this once and generate a table.  */

int
xg_get_max_narrow_insn_size (opcode)
     xtensa_opcode opcode;
{
  /* Go ahead and compute it, but it better be 3.  */
  TransitionTable *table = xg_build_widen_table ();
  TransitionList *l;
  int old_size = xtensa_insn_length (xtensa_default_isa, opcode);
  assert (opcode < table->num_opcodes);

  /* Actually we can do better. Check to see of Only one applies.  */
  for (l = table->table[opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;

      /* If it only generates one instruction.  */
      if (is_unique_insn_expansion (rule))
	{
	  int new_size = xtensa_insn_length (xtensa_default_isa,
					     rule->to_instr->opcode);
	  if (new_size > old_size)
	    {
	      assert (new_size == 3);
	      return 3;
	    }
	}
    }
  return old_size;
}


d3069 2
a3070 3
int
xg_get_max_insn_widen_size (opcode)
     xtensa_opcode opcode;
d3072 1
a3072 1
  TransitionTable *table = xg_build_widen_table ();
d3074 1
a3074 1
  int max_size = xtensa_insn_length (xtensa_default_isa, opcode);
d3098 1
a3098 3
		this_size += xtensa_insn_length (xtensa_default_isa,
						 build_list->opcode);

d3115 2
a3116 3
int
xg_get_max_insn_widen_literal_size (opcode)
     xtensa_opcode opcode;
d3118 1
a3118 1
  TransitionTable *table = xg_build_widen_table ();
d3144 1
a3144 1
		/* hard coded 4-byte literal.  */
d3160 2
a3161 4
bfd_boolean
xg_is_relaxable_insn (insn, lateral_steps)
     TInsn *insn;
     int lateral_steps;
d3164 1
a3164 1
  TransitionTable *table = xg_build_widen_table ();
d3186 1
a3186 1
get_special_literal_symbol ()
d3197 1
a3197 1
get_special_label_symbol ()
d3207 161
a3367 1
/* Return true on success.  */
d3369 2
a3370 5
bfd_boolean
xg_build_to_insn (targ, insn, bi)
     TInsn *targ;
     TInsn *insn;
     BuildInstr *bi;
d3376 1
d3412 32
d3489 3
d3509 1
a3509 1
      /* Literal with no ops. is a label?  */
d3521 1
a3521 1
/* Return true on success.  */
d3523 2
a3524 5
bfd_boolean
xg_build_to_stack (istack, insn, bi)
     IStack *istack;
     TInsn *insn;
     BuildInstr *bi;
d3537 1
a3537 1
/* Return true on valid expansion.  */
d3539 2
a3540 5
bfd_boolean
xg_expand_to_stack (istack, insn, lateral_steps)
     IStack *istack;
     TInsn *insn;
     int lateral_steps;
d3544 1
a3544 1
  TransitionTable *table = xg_build_widen_table ();
d3586 2
a3587 4
bfd_boolean
xg_expand_narrow (targ, insn)
     TInsn *targ;
     TInsn *insn;
d3589 1
a3589 1
  TransitionTable *table = xg_build_widen_table ();
d3602 1
a3602 1
	  if (xg_get_insn_size (insn)
d3613 21
d3635 4
a3638 2
/* Assumes: All immeds are constants.  Check that all constants fit
   into their immeds; return false if not.  */
d3640 7
a3646 5
static bfd_boolean
xg_immeds_fit (insn)
     const TInsn *insn;
{
  int i;
d3648 2
a3649 3
  int n = insn->ntok;
  assert (insn->insn_type == ITYPE_INSN);
  for (i = 0; i < n; ++i)
d3651 3
a3653 5
      const expressionS *expr = &insn->tok[i];
      xtensa_operand opnd = xtensa_get_operand (xtensa_default_isa,
						insn->opcode, i);
      if (!operand_is_immed (opnd))
	continue;
d3655 2
a3656 1
      switch (expr->X_op)
d3658 6
a3663 11
	case O_register:
	case O_constant:
	  {
	    if (xg_check_operand (expr->X_add_number, opnd))
	      return FALSE;
	  }
	  break;
	default:
	  /* The symbol should have a fixup associated with it.  */
	  assert (FALSE);
	  break;
d3665 1
a3666 2
  return TRUE;
}
d3668 2
a3669 20

/* This should only be called after we have an initial
   estimate of the addresses.  */

static bfd_boolean
xg_symbolic_immeds_fit (insn, pc_seg, pc_frag, pc_offset, stretch)
     const TInsn *insn;
     segT pc_seg;
     fragS *pc_frag;
     offsetT pc_offset;
     long stretch;
{
  symbolS *symbolP;
  offsetT target, pc, new_offset;
  int i;
  int n = insn->ntok;

  assert (insn->insn_type == ITYPE_INSN);

  for (i = 0; i < n; ++i)
d3671 2
a3672 7
      const expressionS *expr = &insn->tok[i];
      xtensa_operand opnd = xtensa_get_operand (xtensa_default_isa,
						insn->opcode, i);
      if (!operand_is_immed (opnd))
	continue;

      switch (expr->X_op)
d3674 3
a3676 186
	case O_register:
	case O_constant:
	  if (xg_check_operand (expr->X_add_number, opnd))
	    return FALSE;
	  break;

	case O_symbol:
	  /* We only allow symbols for pc-relative stuff.
	     If pc_frag == 0, then we don't have frag locations yet.  */
	  if (pc_frag == 0)
	    return FALSE;

	  /* If it is PC-relative and the symbol is in the same segment as
	     the PC.... */
	  if (!xtensa_operand_isPCRelative (opnd)
	      || S_GET_SEGMENT (expr->X_add_symbol) != pc_seg)
	    return FALSE;

	  symbolP = expr->X_add_symbol;
	  target = S_GET_VALUE (symbolP) + expr->X_add_number;
	  pc = pc_frag->fr_address + pc_offset;

	  /* If frag has yet to be reached on this pass, assume it
	     will move by STRETCH just as we did.  If this is not so,
	     it will be because some frag between grows, and that will
	     force another pass.  Beware zero-length frags.  There
	     should be a faster way to do this.  */

	  if (stretch && is_dnrange (pc_frag, symbolP, stretch))
	    target += stretch;

	  new_offset = xtensa_operand_do_reloc (opnd, target, pc);
	  if (xg_check_operand (new_offset, opnd))
	    return FALSE;
	  break;

	default:
	  /* The symbol should have a fixup associated with it.  */
	  return FALSE;
	}
    }

  return TRUE;
}


/* This will check to see if the value can be converted into the
   operand type.  It will return true if it does not fit.  */

static bfd_boolean
xg_check_operand (value, operand)
     int32 value;
     xtensa_operand operand;
{
  uint32 valbuf = value;
  return (xtensa_operand_encode (operand, &valbuf) != xtensa_encode_result_ok);
}


/* Check if a symbol is pointing to somewhere after
   the start frag, given that the segment has stretched 
   by stretch during relaxation.

   This is more complicated than it might appear at first blush
   because of the stretching that goes on. Here is how the check
   works:

   If the symbol and the frag are in the same segment, then
   the symbol could be down range. Note that this function 
   assumes that start_frag is in now_seg.

   If the symbol is pointing to a frag with an address greater than 
   than the start_frag's address, then it _could_ be down range. 

   The problem comes because target_frag may or may not have had
   stretch bytes added to its address already, depending on if it is 
   before or after start frag. (And if we knew that, then we wouldn't
   need this function.) start_frag has definitely already had stretch
   bytes added to its address.
   
   If target_frag's address hasn't been adjusted yet, then to 
   determine if it comes after start_frag, we need to subtract
   stretch from start_frag's address.

   If target_frag's address has been adjusted, then it might have
   been adjusted such that it comes after start_frag's address minus
   stretch bytes.

   So, in that case, we scan for it down stream to within 
   stretch bytes. We could search to the end of the fr_chain, but
   that ends up taking too much time (over a minute on some gnu 
   tests).  */

int
is_dnrange (start_frag, sym, stretch)
     fragS *start_frag;
     symbolS *sym;
     long stretch;
{
  if (S_GET_SEGMENT (sym) == now_seg)
    {
      fragS *cur_frag = symbol_get_frag (sym);

      if (cur_frag->fr_address >= start_frag->fr_address - stretch)
	{
	  int distance = stretch;

	  while (cur_frag && distance >= 0) 
	    {
	      distance -= cur_frag->fr_fix;
	      if (cur_frag == start_frag)
		return 0;
	      cur_frag = cur_frag->fr_next;
	    }
	  return 1;
	}
    }
  return 0;
}


/* Relax the assembly instruction at least "min_steps".
   Return the number of steps taken.  */

int
xg_assembly_relax (istack, insn, pc_seg, pc_frag, pc_offset, min_steps,
		   stretch)
     IStack *istack;
     TInsn *insn;
     segT pc_seg;
     fragS *pc_frag;		/* If pc_frag == 0, then no pc-relative.  */
     offsetT pc_offset;		/* Offset in fragment.  */
     int min_steps;		/* Minimum number of conversion steps.  */
     long stretch;		/* Number of bytes stretched so far.  */
{
  int steps_taken = 0;

  /* assert (has no symbolic operands)
     Some of its immeds don't fit.
     Try to build a relaxed version.
     This may go through a couple of stages
     of single instruction transformations before
     we get there.  */

  TInsn single_target;
  TInsn current_insn;
  int lateral_steps = 0;
  int istack_size = istack->ninsn;

  if (xg_symbolic_immeds_fit (insn, pc_seg, pc_frag, pc_offset, stretch)
      && steps_taken >= min_steps)
    {
      istack_push (istack, insn);
      return steps_taken;
    }
  tinsn_copy (&current_insn, insn);

  /* Walk through all of the single instruction expansions. */
  while (xg_is_single_relaxable_insn (&current_insn))
    {
      int error_val = xg_expand_narrow (&single_target, &current_insn);

      assert (!error_val);

      if (xg_symbolic_immeds_fit (&single_target, pc_seg, pc_frag, pc_offset,
				  stretch))
	{
	  steps_taken++;
	  if (steps_taken >= min_steps)
	    {
	      istack_push (istack, &single_target);
	      return steps_taken;
	    }
	}
      tinsn_copy (&current_insn, &single_target);
    }

  /* Now check for a multi-instruction expansion.  */
  while (xg_is_relaxable_insn (&current_insn, lateral_steps))
    {
      if (xg_symbolic_immeds_fit (&current_insn, pc_seg, pc_frag, pc_offset,
				  stretch))
	{
	  if (steps_taken >= min_steps)
	    {
	      istack_push (istack, &current_insn);
d3697 1
a3697 2
xg_force_frag_space (size)
     int size;
d3706 6
a3711 6
void
xg_finish_frag (last_insn, state, max_growth, is_insn)
     char *last_insn;
     enum xtensa_relax_statesE state;
     int max_growth;
     bfd_boolean is_insn;
d3719 1
d3729 4
a3732 1
	    state, frag_now->fr_symbol, frag_now->fr_offset, last_insn);
d3739 26
d3766 1
a3766 3
is_branch_jmp_to_next (insn, fragP)
     TInsn *insn;
     fragS *fragP;
d3770 1
a3770 1
  int num_ops = xtensa_num_operands (isa, insn->opcode);
d3775 2
a3776 1
  if (is_loop_opcode (insn->opcode))
d3781 1
a3781 3
      xtensa_operand opnd = xtensa_get_operand (isa, insn->opcode, i);
      char *kind = xtensa_operand_kind (opnd);
      if (strlen (kind) == 1 && *kind == 'l')
d3816 1
a3816 2
xg_add_branch_and_loop_targets (insn)
     TInsn *insn;
d3819 1
a3819 1
  int num_ops = xtensa_num_operands (isa, insn->opcode);
d3821 1
a3821 1
  if (is_loop_opcode (insn->opcode))
d3824 3
a3826 5
      xtensa_operand opnd = xtensa_get_operand (isa, insn->opcode, i);
      char *kind = xtensa_operand_kind (opnd);
      if (strlen (kind) == 1 && *kind == 'l')
	if (insn->tok[i].X_op == O_symbol)
	  symbol_get_tc (insn->tok[i].X_add_symbol)->is_loop_target = TRUE;
d3830 2
a3831 5
  /* Currently, we do not add branch targets.  This is an optimization
     for later that tries to align only branch targets, not just any
     label in a text section.  */

  if (align_only_targets)
d3837 1
a3837 3
	  xtensa_operand opnd = xtensa_get_operand (isa, insn->opcode, i);
	  char *kind = xtensa_operand_kind (opnd);
	  if (strlen (kind) == 1 && *kind == 'l'
d3850 1
a3850 1
/* Return the transition rule that matches or NULL if none matches.  */
d3852 2
a3853 94
bfd_boolean
xg_instruction_matches_rule (insn, rule)
     TInsn *insn;
     TransitionRule *rule;
{
  PreconditionList *condition_l;

  if (rule->opcode != insn->opcode)
    return FALSE;

  for (condition_l = rule->conditions;
       condition_l != NULL;
       condition_l = condition_l->next)
    {
      expressionS *exp1;
      expressionS *exp2;
      Precondition *cond = condition_l->precond;

      switch (cond->typ)
	{
	case OP_CONSTANT:
	  /* The expression must be the constant.  */
	  assert (cond->op_num < insn->ntok);
	  exp1 = &insn->tok[cond->op_num];
	  if (!expr_is_const (exp1))
	    return FALSE;
	  switch (cond->cmp)
	    {
	    case OP_EQUAL:
	      if (get_expr_const (exp1) != cond->op_data)
		return FALSE;
	      break;
	    case OP_NOTEQUAL:
	      if (get_expr_const (exp1) == cond->op_data)
		return FALSE;
	      break;
	    }
	  break;

	case OP_OPERAND:
	  assert (cond->op_num < insn->ntok);
	  assert (cond->op_data < insn->ntok);
	  exp1 = &insn->tok[cond->op_num];
	  exp2 = &insn->tok[cond->op_data];

	  switch (cond->cmp)
	    {
	    case OP_EQUAL:
	      if (!expr_is_equal (exp1, exp2))
		return FALSE;
	      break;
	    case OP_NOTEQUAL:
	      if (expr_is_equal (exp1, exp2))
		return FALSE;
	      break;
	    }
	  break;

	case OP_LITERAL:
	case OP_LABEL:
	default:
	  return FALSE;
	}
    }
  return TRUE;
}


TransitionRule *
xg_instruction_match (insn)
     TInsn *insn;
{
  TransitionTable *table = xg_build_simplify_table ();
  TransitionList *l;
  assert (insn->opcode < table->num_opcodes);

  /* Walk through all of the possible transitions.  */
  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
    {
      TransitionRule *rule = l->rule;
      if (xg_instruction_matches_rule (insn, rule))
	return rule;
    }
  return NULL;
}


/* Return false if no error.  */

bfd_boolean
xg_build_token_insn (instr_spec, old_insn, new_insn)
     BuildInstr *instr_spec;
     TInsn *old_insn;
     TInsn *new_insn;
d3864 1
d3870 1
d3916 1
a3916 1
/* Return true if it was simplified.  */
d3918 2
a3919 4
bfd_boolean
xg_simplify_insn (old_insn, new_insn)
     TInsn *old_insn;
     TInsn *new_insn;
d3921 1
a3921 1
  TransitionRule *rule = xg_instruction_match (old_insn);
d3923 5
d3947 1
a3947 1
   multiple instructions/literals onto the stack.  Return false if no
d3951 1
a3951 3
xg_expand_assembly_insn (istack, orig_insn)
     IStack *istack;
     TInsn *orig_insn;
d3957 4
a3960 7
  /* On return, we will be using the "use_tokens" with "use_ntok".
     This will reduce things like addi to addi.n.  */
  if (code_density_available () && !orig_insn->is_specific_opcode)
    {
      if (xg_simplify_insn (orig_insn, &new_insn))
	orig_insn = &new_insn;
    }
d3962 2
a3963 1
  noperands = xtensa_num_operands (xtensa_default_isa, orig_insn->opcode);
d3978 1
a3978 1
  /* If there are not enough operands, we will assert above. If there
d3983 1
a3983 1
  /* Cases: 
d3991 2
a3992 2
     Also close out the fragment if the fixup may cause instruction expansion. 
     
d3997 2
a3998 2
        Multiple of these may be possible on the same fragment. 
	If so, make sure to satisfy the required alignment. 
d4004 1
a4004 1
  if (orig_insn->is_specific_opcode || !can_relax ())
a4024 8
#if 0
  for (i = 0; i < istack->ninsn; i++)
    {
      if (xg_simplify_insn (&new_insn, &istack->insn[i]))
	istack->insn[i] = new_insn;
    }
#endif

d4029 2
a4030 1
/* Currently all literals that are generated here are 32-bit L32R targets.  */
d4032 2
a4033 3
symbolS *
xg_assemble_literal (insn)
     /* const */ TInsn *insn;
d4035 1
a4035 2
  emit_state state;
  symbolS *lit_sym = NULL;
d4037 2
a4038 6
  /* size = 4 for L32R.  It could easily be larger when we move to
     larger constants.  Add a parameter later.  */
  offsetT litsize = 4;
  offsetT litalign = 2;		/* 2^2 = 4 */
  expressionS saved_loc;
  set_expr_symbol_offset (&saved_loc, frag_now->fr_symbol, frag_now_fix ());
d4040 4
a4043 2
  assert (insn->insn_type == ITYPE_LITERAL);
  assert (insn->ntok = 1);	/* must be only one token here */
d4045 4
a4048 18
  xtensa_switch_to_literal_fragment (&state);

  /* Force a 4-byte align here.  Note that this opens a new frag, so all
     literals done with this function have a frag to themselves.  That's
     important for the way text section literals work.  */
  frag_align (litalign, 0, 0);

  emit_expr (&insn->tok[0], litsize);

  assert (frag_now->tc_frag_data.literal_frag == NULL);
  frag_now->tc_frag_data.literal_frag = get_literal_pool_location (now_seg);
  frag_now->fr_symbol = xtensa_create_literal_symbol (now_seg, frag_now);
  lit_sym = frag_now->fr_symbol;
  frag_now->tc_frag_data.is_literal = TRUE;

  /* Go back.  */
  xtensa_restore_emit_state (&state);
  return lit_sym;
d4053 1
a4053 2
xg_assemble_literal_space (size)
     /* const */ int size;
d4055 1
a4055 5
  emit_state state;
  /* We might have to do something about this alignment.  It only  
     takes effect if something is placed here.  */
  offsetT litalign = 2;		/* 2^2 = 4 */
  fragS *lit_saved_frag;
d4057 4
a4060 21
  expressionS saved_loc;

  assert (size % 4 == 0);
  set_expr_symbol_offset (&saved_loc, frag_now->fr_symbol, frag_now_fix ());

  xtensa_switch_to_literal_fragment (&state);

  /* Force a 4-byte align here.  */
  frag_align (litalign, 0, 0);

  xg_force_frag_space (size);

  lit_saved_frag = frag_now;
  frag_now->tc_frag_data.literal_frag = get_literal_pool_location (now_seg);
  frag_now->tc_frag_data.is_literal = TRUE;
  frag_now->fr_symbol = xtensa_create_literal_symbol (now_seg, frag_now);
  xg_finish_frag (0, RELAX_LITERAL, size, FALSE);

  /* Go back.  */
  xtensa_restore_emit_state (&state);
  frag_now->tc_frag_data.literal_frag = lit_saved_frag;
d4064 2
a4065 4
symbolS *
xtensa_create_literal_symbol (sec, frag)
     segT sec;
     fragS *frag;
d4093 4
a4096 3
static void
xtensa_add_literal_sym (sym)
     symbolS *sym;
d4098 14
a4111 1
  sym_list *l;
d4113 1
a4113 5
  l = (sym_list *) xmalloc (sizeof (sym_list));
  l->sym = sym;
  l->next = literal_syms;
  literal_syms = l;
}
d4115 13
d4129 5
a4133 5
static void
xtensa_add_insn_label (sym)
     symbolS *sym;
{
  sym_list *l;
d4135 1
a4135 3
  if (!free_insn_labels)
    l = (sym_list *) xmalloc (sizeof (sym_list));
  else
d4137 8
a4144 2
      l = free_insn_labels;
      free_insn_labels = l->next;
d4146 8
d4155 3
a4157 3
  l->sym = sym;
  l->next = insn_labels;
  insn_labels = l;
d4162 1
a4162 1
xtensa_clear_insn_labels (void)
d4164 5
a4168 1
  sym_list **pl;
d4170 1
a4170 5
  for (pl = &free_insn_labels; *pl != NULL; pl = &(*pl)->next)
    ;
  *pl = insn_labels;
  insn_labels = NULL;
}
d4172 1
d4174 3
a4176 2
/* Return true if the section flags are marked linkonce
   or the name is .gnu.linkonce*.  */
d4178 1
a4178 6
bfd_boolean
get_is_linkonce_section (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec;
{
  flagword flags, link_once_flags;
d4180 5
a4184 2
  flags = bfd_get_section_flags (abfd, sec);
  link_once_flags = (flags & SEC_LINK_ONCE);
d4186 3
a4188 9
  /* Flags might not be set yet.  */
  if (!link_once_flags)
    {
      static size_t len = sizeof ".gnu.linkonce.t.";

      if (strncmp (segment_name (sec), ".gnu.linkonce.t.", len - 1) == 0)
	link_once_flags = SEC_LINK_ONCE;
    }
  return (link_once_flags != 0);
d4192 2
a4193 5
/* Emit an instruction to the current fragment.  If record_fix is true,
   then this instruction will not change and we can go ahead and record
   the fixup.  If record_fix is false, then the instruction may change
   and we are going to close out this fragment.  Go ahead and set the
   fr_symbol and fr_offset instead of adding a fixup.  */
d4196 7
a4202 3
xg_emit_insn (t_insn, record_fix)
     TInsn *t_insn;
     bfd_boolean record_fix;
d4204 5
a4208 15
  bfd_boolean ok = TRUE;
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode = t_insn->opcode;
  bfd_boolean has_fixup = FALSE;
  int noperands;
  int i, byte_count;
  fragS *oldfrag;
  size_t old_size;
  char *f;
  static xtensa_insnbuf insnbuf = NULL;
  
  /* Use a static pointer to the insn buffer so we don't have to call 
     malloc each time through.  */
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);
d4210 1
a4210 1
  has_fixup = tinsn_to_insnbuf (t_insn, insnbuf);
d4212 19
a4230 2
  noperands = xtensa_num_operands (isa, opcode);
  assert (noperands == t_insn->ntok);
d4232 5
a4236 17
  byte_count = xtensa_insn_length (isa, opcode);
  oldfrag = frag_now;
  /* This should NEVER cause us to jump into a new frag;
     we've already reserved space.  */
  old_size = frag_now_fix ();
  f = frag_more (byte_count);
  assert (oldfrag == frag_now);

  /* This needs to generate a record that lists the parts that are
     instructions.  */
  if (!frag_now->tc_frag_data.is_insn)
    {
      /* If we are at the beginning of a fragment, switch this
	 fragment to an instruction fragment.  */
      if (now_seg != absolute_section && old_size != 0)
	as_warn (_("instruction fragment may contain data"));
      frag_now->tc_frag_data.is_insn = TRUE;
d4239 9
a4247 1
  xtensa_insnbuf_to_chars (isa, insnbuf, f);
d4249 8
a4256 1
  dwarf2_emit_insn (byte_count);
d4258 2
a4259 5
  /* Now spit out the opcode fixup.... */
  if (!has_fixup)
    return !ok;

  for (i = 0; i < noperands; ++i)
d4261 4
a4264 26
      expressionS *expr = &t_insn->tok[i];
      switch (expr->X_op)
	{
	case O_symbol:
	  if (get_relaxable_immed (opcode) == i)
	    {
	      if (record_fix)
		{
		  if (!xg_add_opcode_fix (opcode, i, expr, frag_now,
					  f - frag_now->fr_literal))
		    ok = FALSE;
		}
	      else
		{
		  /* Write it to the fr_offset, fr_symbol.  */
		  frag_now->fr_symbol = expr->X_add_symbol;
		  frag_now->fr_offset = expr->X_add_number;
		}
	    }
	  else
	    {
	      as_bad (_("invalid operand %d on '%s'"),
		      i, xtensa_opcode_name (isa, opcode));
	      ok = FALSE;
	    }
	  break;
d4266 4
a4269 3
	case O_constant:
	case O_register:
	  break;
d4271 4
a4274 7
	default:
	  as_bad (_("invalid expression for operand %d on '%s'"),
		  i, xtensa_opcode_name (isa, opcode));
	  ok = FALSE;
	  break;
	}
    }
d4276 5
a4280 1
  return !ok;
d4285 6
a4290 6
xg_emit_insn_to_buf (t_insn, buf, fragP, offset, build_fix)
     TInsn *t_insn;
     char *buf;
     fragS *fragP;
     offsetT offset;
     bfd_boolean build_fix;
d4298 1
a4298 1
  has_symbolic_immed = tinsn_to_insnbuf (t_insn, insnbuf);
d4302 2
a4303 2
      int opnum = get_relaxable_immed (t_insn->opcode);
      expressionS *exp = &t_insn->tok[opnum];
d4305 1
a4305 2
      if (!xg_add_opcode_fix (t_insn->opcode, 
			      opnum, exp, fragP, offset))
d4309 1
a4309 1
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf);
d4314 2
a4315 49
/* Put in a fixup record based on the opcode.
   Return true on success.  */

bfd_boolean
xg_add_opcode_fix (opcode, opnum, expr, fragP, offset)
     xtensa_opcode opcode;
     int opnum;
     expressionS *expr;
     fragS *fragP;
     offsetT offset;
{ 
  bfd_reloc_code_real_type reloc; 
  reloc_howto_type *howto; 
  int insn_length;
  fixS *the_fix;

  reloc = opnum_to_reloc (opnum);
  if (reloc == BFD_RELOC_NONE)
    {
      as_bad (_("invalid relocation operand %i on '%s'"),
	      opnum, xtensa_opcode_name (xtensa_default_isa, opcode));
      return FALSE;
    }

  howto = bfd_reloc_type_lookup (stdoutput, reloc);

  if (!howto)
    {
      as_bad (_("undefined symbol for opcode \"%s\"."),
	      xtensa_opcode_name (xtensa_default_isa, opcode));
      return FALSE;
    }

  insn_length = xtensa_insn_length (xtensa_default_isa, opcode);
  the_fix = fix_new_exp (fragP, offset, insn_length, expr,
			 howto->pc_relative, reloc);

  if (expr->X_add_symbol && 
      (S_IS_EXTERNAL (expr->X_add_symbol) || S_IS_WEAK (expr->X_add_symbol)))
    the_fix->fx_plt = TRUE;
  
  return TRUE;
}


void
xg_resolve_literals (insn, lit_sym)
     TInsn *insn;
     symbolS *lit_sym;
d4329 2
a4330 4
void
xg_resolve_labels (insn, label_sym)
     TInsn *insn;
     symbolS *label_sym;
d4334 1
a4334 1
  /* assert(!insn->is_literal); */
d4342 5
a4346 3
static void
xg_assemble_tokens (insn)
     /*const */ TInsn *insn;
d4348 3
a4350 23
  /* By the time we get here, there's not too much left to do. 
     1) Check our assumptions. 
     2) Check if the current instruction is "narrow". 
        If so, then finish the frag, create another one.
        We could also go back to change some previous
        "narrow" frags into no-change ones if we have more than
        MAX_NARROW_ALIGNMENT of them without alignment restrictions
        between them.

     Cases:
        1) It has constant operands and doesn't fit.
           Go ahead and assemble it so it will fail.
        2) It has constant operands that fit.
           If narrow and !is_specific_opcode,
              assemble it and put in a relocation
           else
              assemble it.
        3) It has a symbolic immediate operand
           a) Find the worst-case relaxation required
           b) Find the worst-case literal pool space required.
              Insert appropriate alignment & space in the literal.
              Assemble it.
              Add the relocation.  */
d4352 1
a4352 1
  assert (insn->insn_type == ITYPE_INSN);
d4354 1
a4354 1
  if (!tinsn_has_symbolic_operands (insn))
d4356 13
a4368 146
      if (xg_is_narrow_insn (insn) && !insn->is_specific_opcode)
	{
	  /* assemble it but add max required space */
	  int max_size = xg_get_max_narrow_insn_size (insn->opcode);
	  int min_size = xg_get_insn_size (insn);
	  char *last_insn;
	  assert (max_size == 3);
	  /* make sure we have enough space to widen it */
	  xg_force_frag_space (max_size);
	  /* Output the instruction.  It may cause an error if some 
	     operands do not fit.  */
	  last_insn = frag_more (0);
	  if (xg_emit_insn (insn, TRUE))
	    as_warn (_("instruction with constant operands does not fit"));
	  xg_finish_frag (last_insn, RELAX_NARROW, max_size - min_size, TRUE);
	}
      else
	{
	  /* Assemble it.  No relocation needed.  */
	  int max_size = xg_get_insn_size (insn);
	  xg_force_frag_space (max_size);
	  if (xg_emit_insn (insn, FALSE))
	    as_warn (_("instruction with constant operands does not "
		       "fit without widening"));
	  /* frag_more (max_size); */

	  /* Special case for jx.  If the jx is the next to last
	     instruction in a loop, we will add a NOP after it.  This
	     avoids a hardware issue that could occur if the jx jumped
	     to the next instruction.  */
	  if (software_avoid_b_j_loop_end
	      && is_jx_opcode (insn->opcode))
	    {
	      maybe_has_b_j_loop_end = TRUE;
	      /* add 2 of these */
	      frag_now->tc_frag_data.is_insn = TRUE;
	      frag_var (rs_machine_dependent, 4, 4,
			RELAX_ADD_NOP_IF_PRE_LOOP_END,
			frag_now->fr_symbol, frag_now->fr_offset, NULL);
	    }
	}
    }
  else
    {
      /* Need to assemble it with space for the relocation.  */
      if (!insn->is_specific_opcode)
	{
	  /* Assemble it but add max required space.  */
	  char *last_insn;
	  int min_size = xg_get_insn_size (insn);
	  int max_size = xg_get_max_insn_widen_size (insn->opcode);
	  int max_literal_size =
	    xg_get_max_insn_widen_literal_size (insn->opcode);

#if 0
	  symbolS *immed_sym = xg_get_insn_immed_symbol (insn);
	  set_frag_segment (frag_now, now_seg);
#endif /* 0 */

	  /* Make sure we have enough space to widen the instruction. 
	     This may open a new fragment.  */
	  xg_force_frag_space (max_size);
	  if (max_literal_size != 0)
	    xg_assemble_literal_space (max_literal_size);

	  /* Output the instruction.  It may cause an error if some 
	     operands do not fit.  Emit the incomplete instruction.  */
	  last_insn = frag_more (0);
	  xg_emit_insn (insn, FALSE);

	  xg_finish_frag (last_insn, RELAX_IMMED, max_size - min_size, TRUE);

	  /* Special cases for loops:
	     close_loop_end should be inserted AFTER short_loop.
	     Make sure that CLOSE loops are processed BEFORE short_loops
	     when converting them.  */

	  /* "short_loop": add a NOP if the loop is < 4 bytes.  */
	  if (software_avoid_short_loop
	      && is_loop_opcode (insn->opcode))
	    {
	      maybe_has_short_loop = TRUE;
	      frag_now->tc_frag_data.is_insn = TRUE;
	      frag_var (rs_machine_dependent, 4, 4,
			RELAX_ADD_NOP_IF_SHORT_LOOP,
			frag_now->fr_symbol, frag_now->fr_offset, NULL);
	      frag_now->tc_frag_data.is_insn = TRUE;
	      frag_var (rs_machine_dependent, 4, 4,
			RELAX_ADD_NOP_IF_SHORT_LOOP,
			frag_now->fr_symbol, frag_now->fr_offset, NULL);
	    }

	  /* "close_loop_end": Add up to 12 bytes of NOPs to keep a
	     loop at least 12 bytes away from another loop's loop
	     end.  */
	  if (software_avoid_close_loop_end
	      && is_loop_opcode (insn->opcode))
	    {
	      maybe_has_close_loop_end = TRUE;
	      frag_now->tc_frag_data.is_insn = TRUE;
	      frag_var (rs_machine_dependent, 12, 12,
			RELAX_ADD_NOP_IF_CLOSE_LOOP_END,
			frag_now->fr_symbol, frag_now->fr_offset, NULL);
	    }
	}
      else
	{
	  /* Assemble it in place.  No expansion will be required, 
	     but we'll still need a relocation record.  */
	  int max_size = xg_get_insn_size (insn);
	  xg_force_frag_space (max_size);
	  if (xg_emit_insn (insn, TRUE))
	    as_warn (_("instruction's constant operands do not fit"));
	}
    }
}


/* Return true if the instruction can write to the specified
   integer register.  */

static bfd_boolean
is_register_writer (insn, regset, regnum)
     const TInsn *insn;
     const char *regset;
     int regnum;
{
  int i;
  int num_ops;
  xtensa_isa isa = xtensa_default_isa;

  num_ops = xtensa_num_operands (isa, insn->opcode);

  for (i = 0; i < num_ops; i++)
    {
      xtensa_operand operand = xtensa_get_operand (isa, insn->opcode, i);
      char inout = xtensa_operand_inout (operand);

      if (inout == '>' || inout == '=')
	{
	  if (strcmp (xtensa_operand_kind (operand), regset) == 0)
	    {
	      if ((insn->tok[i].X_op == O_register)
		  && (insn->tok[i].X_add_number == regnum))
		return TRUE;
	    }
d4376 1
a4376 2
is_bad_loopend_opcode (tinsn)
     const TInsn * tinsn;
d4396 2
a4397 1
      || opcode == xtensa_waiti_opcode)
a4399 7
  /* An RSR of LCOUNT is illegal as the last opcode in a loop.  */
  if (opcode == xtensa_rsr_opcode
      && tinsn->ntok >= 2
      && tinsn->tok[1].X_op == O_constant
      && tinsn->tok[1].X_add_number == 2)
    return TRUE;

d4409 2
a4410 3
bfd_boolean
is_unaligned_label (sym) 
     symbolS *sym; 
d4424 1
a4424 1
  if (name 
d4436 2
a4437 3
fragS *
next_non_empty_frag (fragP)
     const fragS *fragP;
d4453 2
a4454 3
xtensa_opcode
next_frag_opcode (fragP)
     const fragS * fragP;
d4456 1
d4458 17
d4477 2
d4483 7
a4489 1
  if (next_fragP == NULL)
d4491 31
d4523 1
a4523 2
  xtensa_insnbuf_from_chars (isa, insnbuf, next_fragP->fr_literal);
  return xtensa_decode_insn (isa, insnbuf);
d4527 2
a4528 6
/* Return true if the target frag is one of the next non-empty frags.  */

bfd_boolean
is_next_frag_target (fragP, target)
     const fragS *fragP;
     const fragS *target;
d4530 2
a4531 18
  if (fragP == NULL)
    return FALSE;

  for (; fragP; fragP = fragP->fr_next)
    {
      if (fragP == target)
	return TRUE;
      if (fragP->fr_fix != 0)
	return FALSE;
      if (fragP->fr_type == rs_fill && fragP->fr_offset != 0)
	return FALSE;
      if ((fragP->fr_type == rs_align || fragP->fr_type == rs_align_code)
	  && ((fragP->fr_address % (1 << fragP->fr_offset)) != 0))
	return FALSE;
      if (fragP->fr_type == rs_space)
	return FALSE;
    }
  return FALSE;
d4539 1
a4539 2
update_next_frag_nop_state (fragP)
     fragS *fragP;
d4542 25
d4576 1
d4583 1
a4583 2
next_frag_is_branch_target (fragP)
     const fragS *fragP;
d4585 1
a4585 1
  /* Sometimes an empty will end up here due storage allocation issues,
d4599 1
a4599 2
next_frag_is_loop_target (fragP)
     const fragS *fragP;
d4615 1
a4615 2
next_frag_pre_opcode_bytes (fragp)
     const fragS *fragp;
d4618 1
d4620 1
a4620 2
  xtensa_opcode next_opcode = next_frag_opcode (fragp);
  if (!is_loop_opcode (next_opcode))
d4623 2
a4624 2
  /* Sometimes an empty will end up here due storage allocation issues.
     So we have to skip until we find something legit.  */
d4633 3
a4635 2
     been relaxed.  */
  if (next_fragp->fr_subtype > RELAX_IMMED)
d4647 1
a4647 1
xtensa_mark_literal_pool_location ()
d4654 3
d4658 1
d4661 1
a4661 1
     so we can later move the literal's fixes into this 
d4665 1
a4665 1
  frag_variant (rs_machine_dependent, 0, (int) frchain_now, 
d4667 2
a4668 1
  frag_variant (rs_machine_dependent, 0, (int) now_seg, 
d4670 1
d4674 3
a4676 1
  xtensa_switch_to_literal_fragment (&s);
d4680 1
d4684 1
d4688 1
a4688 23
/* The "loops_ok" argument is provided to allow ignoring labels that 
   define loop ends.  This fixes a bug where the NOPs to align a 
   loop opcode were included in a previous zero-cost loop:

   loop a0, loopend
     <loop1 body>
   loopend:

   loop a2, loopend2
     <loop2 body>

   would become:

   loop a0, loopend
     <loop1 body>
     nop.n <===== bad!
   loopend:

   loop a2, loopend2
     <loop2 body>

   This argument is used to prevent moving the NOP to before the
   loop-end label, which is what you want in this special case.  */
d4691 1
a4691 4
xtensa_move_labels (new_frag, new_offset, loops_ok)
     fragS *new_frag;
     valueT new_offset;
     bfd_boolean loops_ok;
d4693 9
a4701 1
  sym_list *lit;
d4703 2
a4704 4
  for (lit = insn_labels; lit; lit = lit->next)
    {
      symbolS *lit_sym = lit->sym;
      if (loops_ok || symbol_get_tc (lit_sym)->is_loop_target == 0)
d4706 5
a4710 2
	  S_SET_VALUE (lit_sym, new_offset);
	  symbol_set_frag (lit_sym, new_frag);
d4712 4
d4723 2
a4724 4
void
assemble_nop (size, buf)
     size_t size;
     char *buf;
d4727 4
a4730 1
  TInsn t_insn;
d4734 2
a4735 28
  tinsn_init (&t_insn);
  switch (size)
    {
    case 2:
      t_insn.opcode = xtensa_nop_n_opcode;
      t_insn.ntok = 0;
      if (t_insn.opcode == XTENSA_UNDEFINED)
	as_fatal (_("opcode 'NOP.N' unavailable in this configuration"));
      tinsn_to_insnbuf (&t_insn, insnbuf);
      xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf);
      break;

    case 3:
      t_insn.opcode = xtensa_or_opcode;
      assert (t_insn.opcode != XTENSA_UNDEFINED);
      if (t_insn.opcode == XTENSA_UNDEFINED)
	as_fatal (_("opcode 'OR' unavailable in this configuration"));
      set_expr_const (&t_insn.tok[0], 1);
      set_expr_const (&t_insn.tok[1], 1);
      set_expr_const (&t_insn.tok[2], 1);
      t_insn.ntok = 3;
      tinsn_to_insnbuf (&t_insn, insnbuf);
      xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf);
      break;

    default:
      as_fatal (_("invalid %d-byte NOP requested"), size);
    }
d4747 1
a4747 2
get_expanded_loop_offset (opcode)
     xtensa_opcode opcode;
d4752 1
a4752 2
  if (opcode == XTENSA_UNDEFINED)
    as_fatal (_("get_expanded_loop_offset: undefined opcode"));
d4764 2
a4765 3
fragS *
get_literal_pool_location (seg)
     segT seg;
d4772 1
a4772 3
set_literal_pool_location (seg, literal_pool_loc)
     segT seg;
     fragS *literal_pool_loc;
d4777 207
d4988 1
a4988 1
xtensa_target_format ()
d4995 1
a4995 2
xtensa_file_arch_init (abfd)
     bfd *abfd;
d5002 1
a5002 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d5016 1
a5016 1
md_begin ()
d5022 1
a5022 4
#if STATIC_LIBISA
  isa = xtensa_isa_init ();
#else
  /* ISA was already initialized by xtensa_init().  */
a5023 1
#endif
d5025 3
a5027 1
  /* Set  up the .literal, .fini.literal and .init.literal sections.  */
d5032 1
d5036 2
d5048 1
d5050 2
a5052 1
  xtensa_j_opcode = xtensa_opcode_lookup (isa, "j");
d5054 1
d5058 1
d5065 1
a5065 1
  xtensa_rsr_opcode = xtensa_opcode_lookup (isa, "rsr");
d5067 17
d5090 1
a5090 2
xtensa_frob_label (sym)
     symbolS *sym;
d5092 5
d5109 1
a5109 1
      && align_targets
d5111 1
a5111 1
      && !frag_now->tc_frag_data.is_literal)
d5113 20
a5132 2
      /* frag_now->tc_frag_data.is_insn = TRUE; */
      frag_var (rs_machine_dependent, 4, 4,
d5135 1
d5137 43
d5181 12
a5192 9
      /* If the label is already known to be a branch target, i.e., a
	 forward branch, mark the frag accordingly.  Backward branches
	 are handled by xg_add_branch_and_loop_targets.  */
      if (symbol_get_tc (sym)->is_branch_target)
	symbol_get_frag (sym)->tc_frag_data.is_branch_target = TRUE;

      /* Loops only go forward, so they can be identified here.  */
      if (symbol_get_tc (sym)->is_loop_target)
	symbol_get_frag (sym)->tc_frag_data.is_loop_target = TRUE;
d5194 1
d5201 1
a5201 1
xtensa_flush_pending_output ()
d5203 3
d5211 1
d5219 19
d5239 1
a5239 2
md_assemble (str)
     char *str;
d5245 1
a5245 1
  char *arg_strings[MAX_INSN_ARGS]; 
a5246 1
  IStack istack;		/* Put instructions into here.  */
a5247 13
  int i;
  symbolS *lit_sym = NULL;

  if (frag_now->tc_frag_data.is_literal)
    {
      static bfd_boolean reported = 0;
      if (reported < 4)
	as_bad (_("cannot assemble '%s' into a literal fragment"), str);
      if (reported == 3)
	as_bad (_("..."));
      reported++;
      return;
    }
a5248 1
  istack_init (&istack);
d5276 1
a5276 2
  orig_insn.is_specific_opcode = (has_underbar || !use_generics ());
  specific_opcode = orig_insn.is_specific_opcode;
d5281 8
a5288 14
      as_bad (_("unknown opcode %s"), opname);
      return;
    }

  if (frag_now_fix () != 0 && !frag_now->tc_frag_data.is_insn)
    {
      frag_wane (frag_now);
      frag_new (0);
    }

  if (software_a0_b_retw_interlock)
    {
      if ((get_last_insn_flags (now_seg, now_subseg) & FLAG_IS_A0_WRITER) != 0
	  && is_conditional_branch_opcode (orig_insn.opcode))
d5290 3
a5292 13
	  has_a0_b_retw = TRUE;

	  /* Mark this fragment with the special RELAX_ADD_NOP_IF_A0_B_RETW.
	     After the first assembly pass we will check all of them and
	     add a nop if needed.  */
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 4, 4,
		    RELAX_ADD_NOP_IF_A0_B_RETW,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 4, 4,
		    RELAX_ADD_NOP_IF_A0_B_RETW,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
d5294 7
d5312 1
d5322 7
d5331 4
a5334 5
    return;

  /* See if the instruction implies an aligned section.  */
  if (is_entry_opcode (orig_insn.opcode) || is_loop_opcode (orig_insn.opcode))
    record_alignment (now_seg, 2);
d5336 2
a5339 17
  /* Special cases for instructions that force an alignment... */
  if (!orig_insn.is_specific_opcode && is_loop_opcode (orig_insn.opcode))
    {
      size_t max_fill;

      frag_now->tc_frag_data.is_insn = TRUE;
      frag_now->tc_frag_data.is_no_density = !code_density_available ();
      max_fill = get_text_align_max_fill_size
	(get_text_align_power (XTENSA_FETCH_WIDTH),
	 TRUE, frag_now->tc_frag_data.is_no_density);
      frag_var (rs_machine_dependent, max_fill, max_fill,
		RELAX_ALIGN_NEXT_OPCODE, frag_now->fr_symbol,
		frag_now->fr_offset, NULL);

      xtensa_move_labels (frag_now, 0, FALSE);
    }

d5341 1
a5341 1
  if (is_entry_opcode (orig_insn.opcode))
d5343 2
a5344 2
      /* Check that the second opcode (#1) is >= 16.  */
      if (orig_insn.ntok >= 2)
d5346 1
a5346 1
	  expressionS *exp = &orig_insn.tok[1];
a5357 9

      if (!orig_insn.is_specific_opcode)
	{
	  xtensa_mark_literal_pool_location ();

	  /* Automatically align ENTRY instructions.  */
	  xtensa_move_labels (frag_now, 0, TRUE);
	  frag_align (2, 0, 0);
	}
a5359 11
  /* Any extra alignment frags have been inserted now, and we're about to
     emit a new instruction so clear the list of labels.  */
  xtensa_clear_insn_labels ();

  if (software_a0_b_retw_interlock)
    set_last_insn_flags (now_seg, now_subseg, FLAG_IS_A0_WRITER,
			 is_register_writer (&orig_insn, "a", 0));

  set_last_insn_flags (now_seg, now_subseg, FLAG_IS_BAD_LOOPEND,
		       is_bad_loopend_opcode (&orig_insn));

d5361 3
a5363 3
     assemble_tokens (opcode, tok, ntok); 
     expand the tokens from the orig_insn into the 
     stack of instructions that will not expand 
a5364 2
  if (xg_expand_assembly_insn (&istack, &orig_insn))
    return;
d5366 10
a5375 14
  for (i = 0; i < istack.ninsn; i++)
    {
      TInsn *insn = &istack.insn[i];
      if (insn->insn_type == ITYPE_LITERAL)
	{
	  assert (lit_sym == NULL);
	  lit_sym = xg_assemble_literal (insn);
	}
      else
	{
	  if (lit_sym)
	    xg_resolve_literals (insn, lit_sym);
	  xg_assemble_tokens (insn);
	}
d5378 2
a5379 10
  /* Now, if the original opcode was a call... */
  if (align_targets && is_call_opcode (orig_insn.opcode))
    {
      frag_now->tc_frag_data.is_insn = TRUE;
      frag_var (rs_machine_dependent, 4, 4,
		RELAX_DESIRE_ALIGN,
		frag_now->fr_symbol,
		frag_now->fr_offset,
		NULL);
    }
d5383 1
a5383 3
/* TC_CONS_FIX_NEW hook: Check for "@@PLT" suffix on symbol references.
   If found, use an XTENSA_PLT reloc for 4-byte values.  Otherwise, this
   is the same as the standard code in read.c.  */
d5385 3
a5387 21
void 
xtensa_cons_fix_new (frag, where, size, exp)
     fragS *frag;
     int where; 
     int size;
     expressionS *exp;
{
  bfd_reloc_code_real_type r;
  bfd_boolean plt = FALSE;

  if (*input_line_pointer == '@@') 
    {
      if (!strncmp (input_line_pointer, PLT_SUFFIX, strlen (PLT_SUFFIX) - 1)
	  && !strncmp (input_line_pointer, plt_suffix,
		       strlen (plt_suffix) - 1))
	{
	  as_bad (_("undefined @@ suffix '%s', expected '%s'"), 
		  input_line_pointer, plt_suffix);
	  ignore_rest_of_line ();
	  return;
	}
d5389 22
a5410 2
      input_line_pointer += strlen (plt_suffix);
      plt = TRUE;
d5412 1
a5413 22
  switch (size)
    {
    case 1:
      r = BFD_RELOC_8;
      break;
    case 2:
      r = BFD_RELOC_16;
      break;
    case 4:
      r = plt ? BFD_RELOC_XTENSA_PLT : BFD_RELOC_32;
      break;
    case 8:
      r = BFD_RELOC_64;
      break;
    default:
      as_bad (_("unsupported BFD relocation size %u"), size);
      r = BFD_RELOC_32;
      break;
    }
  fix_new_exp (frag, where, size, exp, 0, r);
}
  
d5418 1
a5418 2
xtensa_frag_init (frag)
     fragS *frag;
d5420 1
a5420 1
  frag->tc_frag_data.is_no_density = !code_density_available ();
d5425 1
a5425 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d5434 1
a5434 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
d5441 1
a5441 2
md_pcrel_from (fixP)
     fixS *fixP;
d5445 1
d5447 1
a5447 1
  xtensa_operand operand;
d5449 2
d5453 1
d5462 4
a5465 1
    insnbuf = xtensa_insnbuf_alloc (isa);
d5468 5
a5472 2
  xtensa_insnbuf_from_chars (isa, insnbuf, insn_p);
  opcode = xtensa_decode_insn (isa, insnbuf);
d5474 2
a5475 1
  opnum = reloc_to_opnum (fixP->fx_r_type);
d5477 10
a5486 13
  if (opnum < 0)
    as_fatal (_("invalid operand relocation for '%s' instruction"),
	      xtensa_opcode_name (isa, opcode));
  if (opnum >= xtensa_num_operands (isa, opcode))
    as_fatal (_("invalid relocation for operand %d in '%s' instruction"),
	      opnum, xtensa_opcode_name (isa, opcode));
  operand = xtensa_get_operand (isa, opcode, opnum);
  if (!operand)
    {
      as_warn_where (fixP->fx_file,
		     fixP->fx_line,
		     _("invalid relocation type %d for %s instruction"),
		     fixP->fx_r_type, xtensa_opcode_name (isa, opcode));
d5490 4
a5493 1
  if (!operand_is_pcrel_label (operand))
d5501 31
a5531 8
  if (!xtensa_operand_isPCRelative (operand))
    {
      as_warn_where (fixP->fx_file,
		     fixP->fx_line,
		     _("non-PCREL relocation operand %d for '%s': %s"),
		     opnum, xtensa_opcode_name (isa, opcode),
		     bfd_get_reloc_code_name (fixP->fx_r_type));
      return addr;
d5534 5
a5538 1
  return 0 - xtensa_operand_do_reloc (operand, 0, addr);
d5542 19
a5560 1
/* tc_symbol_new_hook */
d5563 1
a5563 2
xtensa_symbol_new_hook (symbolP)
     symbolS *symbolP;
d5565 3
a5567 1
  symbol_get_tc (symbolP)->plt = 0;
d5574 1
a5574 2
xtensa_fix_adjustable (fixP)
     fixS *fixP;
d5576 8
d5589 13
d5603 1
d5608 1
a5608 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
a5611 4
      /* This happens when the relocation is within the current section. 
         It seems this implies a PCREL operation.  We'll catch it and error 
         if not.  */

a5612 3
      static xtensa_insnbuf insnbuf = NULL;
      xtensa_opcode opcode;
      xtensa_isa isa;
a5632 20
	case BFD_RELOC_XTENSA_OP0:
	case BFD_RELOC_XTENSA_OP1:
	case BFD_RELOC_XTENSA_OP2:
	  isa = xtensa_default_isa;
	  if (!insnbuf)
	    insnbuf = xtensa_insnbuf_alloc (isa);

	  xtensa_insnbuf_from_chars (isa, insnbuf, fixpos);
	  opcode = xtensa_decode_insn (isa, insnbuf);
	  if (opcode == XTENSA_UNDEFINED)
	    as_fatal (_("undecodable FIX"));

	  xtensa_insnbuf_set_immediate_field (opcode, insnbuf, *valP,
					      fixP->fx_file, fixP->fx_line);

	  fixP->fx_frag->tc_frag_data.is_insn = TRUE;
	  xtensa_insnbuf_to_chars (isa, insnbuf, fixpos);
	  fixP->fx_done = 1;
	  break;

d5647 1
a5647 4
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
d5690 1
a5690 3
md_estimate_size_before_relax (fragP, seg)
     fragS *fragP;
     segT seg ATTRIBUTE_UNUSED;
d5692 1
a5692 1
  return fragP->tc_frag_data.text_expansion;
d5700 1
a5700 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
d5703 1
d5714 123
d5843 2
d5848 1093
a6940 1
  if (!fixp->fx_pcrel != !reloc->howto->pc_relative)
d6942 4
a6945 2
      as_fatal (_("internal error? cannot generate `%s' relocation"),
		bfd_get_reloc_code_name (fixp->fx_r_type));
a6946 1
  assert (!fixp->fx_pcrel == !reloc->howto->pc_relative);
d6948 4
a6951 1
  reloc->addend = fixp->fx_offset;
d6953 3
a6955 1
  switch (fixp->fx_r_type)
d6957 24
a6980 9
    case BFD_RELOC_XTENSA_OP0:
    case BFD_RELOC_XTENSA_OP1:
    case BFD_RELOC_XTENSA_OP2:
    case BFD_RELOC_XTENSA_ASM_EXPAND:
    case BFD_RELOC_32: 
    case BFD_RELOC_XTENSA_PLT: 
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      break;
d6982 26
a7007 3
    case BFD_RELOC_XTENSA_ASM_SIMPLIFY:
      as_warn (_("emitting simplification relocation"));
      break;
d7009 9
a7017 2
    default:
      as_warn (_("emitting unknown relocation"));
d7020 6
a7025 1
  return reloc;
d7029 12
d7042 1
a7042 1
xtensa_end ()
d7045 4
d7054 1
a7054 1
  if (software_a0_b_retw_interlock && has_a0_b_retw)
d7056 1
a7056 1
  if (software_avoid_b_j_loop_end && maybe_has_b_j_loop_end)
d7060 1
a7060 1
  if (software_avoid_close_loop_end && maybe_has_close_loop_end)
d7063 1
a7063 1
  if (software_avoid_short_loop && maybe_has_short_loop)
d7065 2
d7073 1
a7073 1
xtensa_cleanup_align_frags ()
a7079 1

d7090 1
a7090 1
	      fragS * next = fragP->fr_next;
d7093 3
a7095 2
		     && next->fr_type == rs_machine_dependent 
		     && next->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET) 
d7101 11
d7124 2
d7127 1
a7127 1
xtensa_fix_target_frags ()
d7147 6
a7152 1
		    fragP->fr_subtype = RELAX_LOOP_END;
d7155 1
a7155 2
		      if (!align_only_targets ||
			  next_frag_is_branch_target (fragP))
d7161 1
a7161 2
	      else if (!align_only_targets
		       || next_frag_is_branch_target (fragP))
d7176 1
a7176 2
frag_can_negate_branch (fragP)
     fragS *fragP;
d7178 11
a7188 2
  if (fragP->fr_type == rs_machine_dependent
      && fragP->fr_subtype == RELAX_IMMED)
d7190 2
a7191 3
      TInsn t_insn;
      tinsn_from_chars (&t_insn, fragP->fr_opcode);
      if (is_negatable_branch (&t_insn))
d7194 87
d7285 34
d7324 2
d7327 1
a7327 1
xtensa_fix_a0_b_retw_frags ()
d7344 7
a7350 3
		relax_frag_add_nop (fragP);
	      else
		frag_wane (fragP);
d7357 2
a7358 3
bfd_boolean
next_instrs_are_b_retw (fragP)
     fragS * fragP;
d7361 1
d7364 1
d7367 2
d7371 4
a7374 1
    insnbuf = xtensa_insnbuf_alloc (isa);
d7380 13
a7392 2
  xtensa_insnbuf_from_chars (isa, insnbuf, &next_fragP->fr_literal[offset]);
  opcode = xtensa_decode_insn (isa, insnbuf);
d7394 1
a7394 1
  if (!is_conditional_branch_opcode (opcode))
d7397 1
a7397 1
  offset += xtensa_insn_length (isa, opcode);
d7403 1
d7408 2
a7409 2
  xtensa_insnbuf_from_chars (isa, insnbuf, &next_fragP->fr_literal[offset]);
  opcode = xtensa_decode_insn (isa, insnbuf);
d7411 10
a7420 1
  if (is_windowed_return_opcode (opcode))
d7422 1
d7432 2
d7435 1
a7435 1
xtensa_fix_b_j_loop_end_frags ()
d7452 7
a7458 3
		relax_frag_add_nop (fragP);
	      else
		frag_wane (fragP);
d7465 2
a7466 3
bfd_boolean
next_instr_is_loop_end (fragP)
     fragS * fragP;
d7495 2
d7498 1
a7498 1
xtensa_fix_close_loop_end_frags ()
d7515 4
a7518 1
	      && fragP->fr_subtype == RELAX_IMMED)
d7521 4
a7524 2
	      xtensa_opcode opcode = get_opcode_from_buf (fragP->fr_opcode);
	      if (is_loop_opcode (opcode))
a7525 5
		  TInsn t_insn;

		  tinsn_from_chars (&t_insn, fragP->fr_opcode);
		  tinsn_immed_from_frag (&t_insn, fragP);

d7527 1
a7527 1
		  if (fragP->fr_symbol)
d7529 2
a7530 1
		      current_target = symbol_get_frag (fragP->fr_symbol);
d7551 3
a7553 2
		  while (min_bytes + bytes_added
			 < REQUIRED_LOOP_DIVIDING_BYTES)
d7555 2
a7556 6
		      int length = 3;

		      if (fragP->fr_var < length)
			as_warn (_("fr_var %lu < length %d; ignoring"),
				 fragP->fr_var, length);
		      else
d7558 13
a7570 4
			  assemble_nop (length,
					fragP->fr_literal + fragP->fr_fix);
			  fragP->fr_fix += length;
			  fragP->fr_var -= length;
a7571 1
		      bytes_added += length;
d7576 2
d7583 7
a7589 6
size_t
min_bytes_to_other_loop_end (fragP, current_target, current_offset, max_size)
     fragS *fragP;
     fragS *current_target;
     offsetT current_offset;
     size_t max_size;
d7611 2
a7612 3
size_t
unrelaxed_frag_min_size (fragP)
     fragS * fragP;
d7624 37
d7670 1
a7670 1
     1) software_avoid_all_short_loops is true
d7677 3
d7681 1
a7681 1
xtensa_fix_short_loop_frags ()
d7697 1
a7697 1
	  /* check on the current loop */
d7699 4
a7702 1
	      && fragP->fr_subtype == RELAX_IMMED)
d7704 2
d7707 3
a7709 2
	      xtensa_opcode opcode = get_opcode_from_buf (fragP->fr_opcode);
	      if (is_loop_opcode (opcode))
a7710 5
		  TInsn t_insn;

		  tinsn_from_chars (&t_insn, fragP->fr_opcode);
		  tinsn_immed_from_frag (&t_insn, fragP);

d7712 1
a7712 1
		  if (fragP->fr_symbol)
d7714 2
a7715 1
		      current_target = symbol_get_frag (fragP->fr_symbol);
d7717 1
a7717 1
		      current_opcode = opcode;
d7729 1
a7729 1
		      || (software_avoid_all_short_loops
d7731 8
a7738 4
			  && !is_the_loop_opcode (current_opcode))))
		relax_frag_add_nop (fragP);
	      else
		frag_wane (fragP);
d7745 6
a7750 5
size_t
count_insns_to_loop_end (base_fragP, count_relax_add, max_count)
     fragS *base_fragP;
     bfd_boolean count_relax_add;
     size_t max_count;
d7781 2
a7782 3
size_t
unrelaxed_frag_min_insn_count (fragP)
     fragS *fragP;
d7784 2
d7792 3
d7798 6
a7803 2
      xtensa_opcode opcode = get_opcode_from_buf (fragP->fr_literal + offset);
      if (opcode == XTENSA_UNDEFINED)
d7808 1
a7808 1
      offset += xtensa_insn_length (xtensa_default_isa, opcode);
d7816 4
a7819 3
bfd_boolean
branch_before_loop_end (base_fragP)
     fragS *base_fragP;
d7834 2
a7835 3
bfd_boolean
unrelaxed_frag_has_b_j (fragP)
     fragS *fragP;
d7837 2
a7838 1
  size_t insn_count = 0;
d7844 3
d7850 9
a7858 2
      xtensa_opcode opcode = get_opcode_from_buf (fragP->fr_literal + offset);
      if (opcode == XTENSA_UNDEFINED)
d7860 5
a7864 2
	  as_fatal (_("undecodable instruction in instruction frag"));
	  return insn_count;
d7866 1
a7866 3
      if (is_branch_or_jump_opcode (opcode))
	return TRUE;
      offset += xtensa_insn_length (xtensa_default_isa, opcode);
d7874 3
d7878 1
a7878 1
xtensa_sanity_check ()
d7904 2
a7905 2
		  tinsn_from_chars (&t_insn, fragP->fr_opcode);
		  tinsn_immed_from_frag (&t_insn, fragP);
d7907 2
a7908 1
		  if (is_loop_opcode (t_insn.opcode))
d7932 1
a7932 1
/* Return true if the loop target is the next non-zero fragment.  */
d7934 2
a7935 4
bfd_boolean
is_empty_loop (insn, fragP)
     const TInsn *insn;
     fragS *fragP;
d7944 1
a7944 1
  if (!is_loop_opcode (insn->opcode))
d7967 1
d7981 2
a7982 4
bfd_boolean
is_local_forward_loop (insn, fragP)
     const TInsn *insn;
     fragS *fragP;
d7991 1
a7991 1
  if (!is_loop_opcode (insn->opcode))
d8011 1
d8015 4
a8018 2
    if (next_fragP == symbol_get_frag (symbolP))
      return TRUE;
d8026 2
a8027 3
size_t
get_text_align_power (target_size)
     int target_size;
d8035 1
a8035 1
  as_fatal (_("get_text_align_power: argument too large"));
d8040 4
a8043 5
addressT
get_text_align_max_fill_size (align_pow, use_nops, use_no_density)
     int align_pow;
     bfd_boolean use_nops;
     bfd_boolean use_no_density;
d8055 1
a8055 1
  
d8065 1
d8077 6
a8082 8
addressT
get_text_align_fill_size (address, align_pow, target_size,
			  use_nops, use_no_density)
     addressT address;
     int align_pow;
     int target_size;
     bfd_boolean use_nops;
     bfd_boolean use_no_density;
d8091 1
a8091 1
     use_nops: if true, then we can only use 2 or 3 byte nops.
d8096 14
a8109 3
     Usually, for non-zero target_size, the align_pow is the power of 2
     that is greater than or equal to the target_size.  This handles the
     2-byte, 3-byte and 8-byte instructions.  */
d8112 3
d8117 9
a8125 7
      /* This is the easy case.  */
      size_t mod;
      mod = address % alignment;
      if (mod != 0)
	mod = alignment - mod;
      assert ((address + mod) % alignment == 0);
      return mod;
d8138 2
a8139 2
	  if ((address + i) >> align_pow ==
	      (address + i + target_size - 1) >> align_pow)
d8150 2
a8151 2
	  if ((address + i) >> align_pow ==
	      (address + i + target_size - 1) >> align_pow)
d8162 2
a8163 4
size_t
get_text_align_nop_count (fill_size, use_no_density)
     size_t fill_size;
     bfd_boolean use_no_density;
d8187 4
a8190 5
size_t
get_text_align_nth_nop_size (fill_size, n, use_no_density)
     size_t fill_size;
     size_t n;
     bfd_boolean use_no_density;
d8218 1
a8218 3
get_noop_aligned_address (fragP, address)
     fragS *fragP;
     addressT address;
d8220 14
a8233 1
  static xtensa_insnbuf insnbuf = NULL;
d8235 7
d8243 2
a8244 15
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  switch (fragP->fr_type)
    {
    case rs_machine_dependent:
      if (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE)
	{
	  /* The rule is: get next fragment's FIRST instruction.  Find
	     the smallest number of bytes that need to be added to
	     ensure that the next fragment's FIRST instruction will fit
	     in a single word.

	     E.G.,   2 bytes : 0, 1, 2 mod 4 
		     3 bytes: 0, 1 mod 4 
d8246 4
a8249 2
	     If the FIRST instruction MIGHT be relaxed, 
	     assume that it will become a 3 byte instruction.  */
d8251 3
a8253 3
	  int target_insn_size;
	  xtensa_opcode opcode = next_frag_opcode (fragP);
	  addressT pre_opcode_bytes;
d8255 2
a8256 6
	  if (opcode == XTENSA_UNDEFINED)
	    {
	      as_bad_where (fragP->fr_file, fragP->fr_line,
			    _("invalid opcode for RELAX_ALIGN_NEXT_OPCODE"));
	      as_fatal (_("cannot continue"));
	    }
d8258 2
a8259 1
	  target_insn_size = xtensa_insn_length (xtensa_default_isa, opcode);
d8261 2
a8262 1
	  pre_opcode_bytes = next_frag_pre_opcode_bytes (fragP);
d8264 1
a8264 6
	  if (is_loop_opcode (opcode))
	    {
	      /* next_fragP should be the loop.  */
	      const fragS *next_fragP = next_non_empty_frag (fragP);
	      xtensa_opcode next_opcode = next_frag_opcode (next_fragP);
	      size_t alignment;
d8266 1
a8266 1
	      pre_opcode_bytes += target_insn_size;
d8268 2
a8269 8
	      /* For loops, the alignment depends on the size of the
		 instruction following the loop, not the loop instruction.  */
	      if (next_opcode == XTENSA_UNDEFINED)
		target_insn_size = 3;
	      else
		{
		  target_insn_size =
		    xtensa_insn_length (xtensa_default_isa, next_opcode);
d8271 2
a8272 3
		  if (target_insn_size == 2)
		    target_insn_size = 3;	/* ISA specifies this.  */
		}
d8274 7
a8280 27
	      /* If it was 8, then we'll need a larger alignment
	         for the section.  */
	      alignment = get_text_align_power (target_insn_size);

	      /* Is Now_seg valid */
	      record_alignment (now_seg, alignment);
	    }
	  else
	    as_fatal (_("expected loop opcode in relax align next target"));

	  fill_size = get_text_align_fill_size
	    (address + pre_opcode_bytes,
	     get_text_align_power (target_insn_size),
	     target_insn_size, TRUE, fragP->tc_frag_data.is_no_density);
	}
      break;
#if 0
    case rs_align:
    case rs_align_code:
      fill_size = get_text_align_fill_size
	(address, fragP->fr_offset, 1, TRUE,
	 fragP->tc_frag_data.is_no_density);
      break;
#endif
    default:
      as_fatal (_("expected align_code or RELAX_ALIGN_NEXT_OPCODE"));
    }
d8286 7
a8292 7
/* 3 mechanisms for relaxing an alignment: 
   
   Align to a power of 2. 
   Align so the next fragment's instruction does not cross a word boundary. 
   Align the current instruction so that if the next instruction 
       were 3 bytes, it would not cross a word boundary. 
   
d8295 6
a8300 6
   zeros    - This is easy; always insert zeros. 
   nops     - 3 and 2 byte instructions 
              2 - 2 byte nop 
              3 - 3 byte nop 
              4 - 2, 2-byte nops 
              >=5 : 3 byte instruction + fn(n-3) 
d8304 1
a8304 3
get_widen_aligned_address (fragP, address)
     fragS *fragP;
     addressT address;
d8306 6
a8311 5
  addressT align_pow, new_address, loop_insn_offset;
  fragS *next_frag;
  int insn_size;
  xtensa_opcode opcode, next_opcode;
  static xtensa_insnbuf insnbuf = NULL;
d8313 15
a8327 2
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);
d8329 30
a8358 76
  if (fragP->fr_type == rs_align || fragP->fr_type == rs_align_code)
    {
      align_pow = fragP->fr_offset;
      new_address = ((address + ((1 << align_pow) - 1))
		     << align_pow) >> align_pow;
      return new_address;
    }

  if (fragP->fr_type == rs_machine_dependent)
    {
      switch (fragP->fr_subtype)
	{
	case RELAX_DESIRE_ALIGN:

	  /* The rule is: get the next fragment's FIRST instruction. 
	     Find the smallest number of bytes needed to be added 
	     in order to ensure that the next fragment is FIRST 
	     instruction will fit in a single word. 
	     i.e.    2 bytes : 0, 1, 2.  mod 4 
	             3 bytes: 0, 1 mod 4 
	     If the FIRST instruction MIGHT be relaxed, 
	     assume that it will become a 3-byte instruction.  */

	  insn_size = 3;
	  /* Check to see if it might be 2 bytes.  */
	  next_opcode = next_frag_opcode (fragP);
	  if (next_opcode != XTENSA_UNDEFINED
	      && xtensa_insn_length (xtensa_default_isa, next_opcode) == 2)
	    insn_size = 2;

	  assert (insn_size <= 4);
	  for (new_address = address; new_address < address + 4; new_address++)
	    {
	      if (new_address >> 2 == (new_address + insn_size - 1) >> 2)
		return new_address;
	    }
	  as_bad (_("internal error aligning"));
	  return address;

	case RELAX_ALIGN_NEXT_OPCODE:
	  /* The rule is: get next fragment's FIRST instruction. 
	     Find the smallest number of bytes needed to be added 
	     in order to ensure that the next fragment's FIRST 
	     instruction will fit in a single word. 
	     i.e.    2 bytes : 0, 1, 2.  mod 4 
	             3 bytes: 0, 1 mod 4 
	     If the FIRST instruction MIGHT be relaxed, 
	     assume that it will become a 3 byte instruction.  */

	  opcode = next_frag_opcode (fragP);
	  if (opcode == XTENSA_UNDEFINED)
	    {
	      as_bad_where (fragP->fr_file, fragP->fr_line,
			    _("invalid opcode for RELAX_ALIGN_NEXT_OPCODE"));
	      as_fatal (_("cannot continue"));
	    }
	  insn_size = xtensa_insn_length (xtensa_default_isa, opcode);
	  assert (insn_size <= 4);
	  assert (is_loop_opcode (opcode));

	  loop_insn_offset = 0;
	  next_frag = next_non_empty_frag (fragP);

	  /* If the loop has been expanded then the loop
	     instruction could be at an offset from this fragment.  */
	  if (next_frag->fr_subtype != RELAX_IMMED)
	    loop_insn_offset = get_expanded_loop_offset (opcode);

	  for (new_address = address; new_address < address + 4; new_address++)
	    {
	      if ((new_address + loop_insn_offset + insn_size) >> 2 ==
		  (new_address + loop_insn_offset + insn_size + 2) >> 2)
		return new_address;
	    }
	  as_bad (_("internal error aligning"));
	  return address;
d8360 2
a8361 4
	default:
	  as_bad (_("internal error aligning"));
	  return address;
	}
d8363 2
a8364 2
  as_bad (_("internal error aligning"));
  return address;
d8370 6
d8380 1
a8380 4
xtensa_relax_frag (fragP, stretch, stretched_p)
     fragS *fragP;
     long stretch;
     int *stretched_p;
d8382 1
d8387 3
d8400 2
a8401 1
      new_stretch = relax_frag_text_align (fragP, stretch);
d8411 1
d8415 1
a8415 2
      /* We REALLY want to change the relaxation order here.  This
         should do NOTHING.  The narrowing before it will either align
d8433 26
a8458 3
    case RELAX_NARROW:
      new_stretch = relax_frag_narrow (fragP, stretch);
      break;
d8460 5
a8464 7
    case RELAX_IMMED:
    case RELAX_IMMED_STEP1:
    case RELAX_IMMED_STEP2:
      /* Place the immediate.  */
      new_stretch = relax_frag_immed (now_seg, fragP, stretch,
				      fragP->fr_subtype - RELAX_IMMED,
				      stretched_p);
d8469 2
d8474 6
d8484 7
d8497 1
a8497 3
relax_frag_text_align (fragP, stretch)
     fragS *fragP;
     long stretch;
d8503 3
a8505 7
  /* Overview of the relaxation procedure for alignment
     inside an executable section:
    
     The old size is stored in the tc_frag_data.text_expansion field.
    
     Calculate the new address, fix up the text_expansion and
     return the growth.  */
d8510 1
a8510 1
		      fragP->tc_frag_data.text_expansion);
d8522 1
a8522 1
  fragP->tc_frag_data.text_expansion += growth;
d8527 1
a8527 3
/* Add a NOP (i.e., "or a1, a1, a1").  Use the 3-byte one because we
   don't know about the availability of density yet.  TODO: When the
   flags are stored per fragment, use NOP.N when possible.  */
d8530 1
a8530 2
relax_frag_add_nop (fragP)
     fragS *fragP;
a8531 2
  static xtensa_insnbuf insnbuf = NULL;
  TInsn t_insn;
d8533 2
a8534 14
  int length;
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  tinsn_init (&t_insn);
  t_insn.opcode = xtensa_or_opcode;
  assert (t_insn.opcode != XTENSA_UNDEFINED);

  t_insn.ntok = 3;
  set_expr_const (&t_insn.tok[0], 1);
  set_expr_const (&t_insn.tok[1], 1);
  set_expr_const (&t_insn.tok[2], 1);

  tinsn_to_insnbuf (&t_insn, insnbuf);
a8535 1
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, nop_buf);
a8536 1
  length = xtensa_insn_length (xtensa_default_isa, t_insn.opcode);
d8539 1
a8539 3
      as_warn (_("fr_var (%ld) < length (%d); ignoring"),
	       fragP->fr_var, length);
      frag_wane (fragP);
a8544 1
  frag_wane (fragP);
d8549 2
d8552 25
a8576 21
relax_frag_narrow (fragP, stretch)
     fragS *fragP;
     long stretch;
{
  /* Overview of the relaxation procedure for alignment inside an
     executable section: Find the number of widenings required and the
     number of nop bytes required. Store the number of bytes ALREADY
     widened. If there are enough instructions to widen (must go back
     ONLY through NARROW fragments), mark each of the fragments as TO BE
     widened, recalculate the fragment addresses.  */

  assert (fragP->fr_type == rs_machine_dependent
	  && fragP->fr_subtype == RELAX_NARROW);

  if (!future_alignment_required (fragP, 0))
    {
      /* If already expanded but no longer needed because of a prior
         stretch, it is SAFE to unexpand because the next fragment will
         NEVER start at an address > the previous time through the
         relaxation.  */
      if (fragP->tc_frag_data.text_expansion)
d8578 2
a8579 7
	  if (stretch > 0)
	    {
	      fragP->tc_frag_data.text_expansion = 0;
	      return -1;
	    }
	  /* Otherwise we have to live with this bad choice.  */
	  return 0;
d8584 2
a8585 5
  if (fragP->tc_frag_data.text_expansion == 0)
    {
      fragP->tc_frag_data.text_expansion = 1;
      return 1;
    }
d8587 1
a8587 1
  return 0;
d8591 20
a8610 4
static bfd_boolean
future_alignment_required (fragP, stretch)
     fragS *fragP;
     long stretch;
d8612 4
a8615 4
  long address = fragP->fr_address + stretch;
  int num_widens = 0;
  addressT aligned_address;
  offsetT desired_diff;
d8620 5
a8624 2
      if (num_widens > 8)
	return FALSE;
d8627 3
a8629 1
      switch (fragP->fr_type)
a8630 5
	case rs_fill:
	  address += fragP->fr_offset * fragP->fr_var;
	  break;

	case rs_machine_dependent:
d8633 17
a8649 3
	    case RELAX_NARROW:
	      /* address += fragP->fr_fix; */
	      num_widens++;
d8653 1
a8653 2
	      address += (/* fragP->fr_fix + */
			  fragP->tc_frag_data.text_expansion);
d8658 6
a8663 10
	      /* address += fragP->fr_fix; */
	      aligned_address = get_widen_aligned_address (fragP, address);
	      desired_diff = aligned_address - address;
	      assert (desired_diff >= 0);
	      /* If there are enough wideners in between do it.  */
	      /* return (num_widens == desired_diff); */
	      if (num_widens == desired_diff)
		return TRUE;
	      if (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE)
		return FALSE;
d8667 110
a8776 1
	      return FALSE;
d8778 87
a8864 1
	  break;
d8866 71
d8938 1
a8938 1
	  return FALSE;
a8939 1
      fragP = fragP->fr_next;
d8941 4
d8946 36
a8981 1
  return FALSE;
d8986 8
a8993 6
relax_frag_immed (segP, fragP, stretch, min_steps, stretched_p)
     segT segP;
     fragS *fragP;
     long stretch;
     int min_steps;
     int *stretched_p;
d8995 2
a8996 2
  static xtensa_insnbuf insnbuf = NULL;
  TInsn t_insn;
d9000 2
d9007 1
a9007 1
  int literal_diff, text_diff;
d9011 7
a9017 2
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);
d9019 2
a9020 2
  tinsn_from_chars (&t_insn, fragP->fr_opcode);
  tinsn_immed_from_frag (&t_insn, fragP);
d9022 2
a9023 1
  negatable_branch = is_negatable_branch (&t_insn);
d9025 1
a9025 1
  old_size = xtensa_insn_length (xtensa_default_isa, t_insn.opcode);
d9027 1
a9027 2
  if (software_avoid_b_j_loop_end)
    branch_jmp_to_next = is_branch_jmp_to_next (&t_insn, fragP);
d9044 1
a9044 1
  num_steps = xg_assembly_relax (&istack, &t_insn, segP, fragP, frag_offset,
d9058 1
a9058 1
  fragP->fr_subtype = (int) RELAX_IMMED + num_steps;
a9061 1
  num_text_bytes = get_num_stack_text_bytes (&istack) - old_size;
d9063 14
a9076 2
  literal_diff = num_literal_bytes - fragP->tc_frag_data.literal_expansion;
  text_diff = num_text_bytes - fragP->tc_frag_data.text_expansion;
d9079 8
a9086 5
  know (num_text_bytes >= 0);
  know (literal_diff >= 0 && text_diff >= 0);

  fragP->tc_frag_data.text_expansion = num_text_bytes;
  fragP->tc_frag_data.literal_expansion = num_literal_bytes;
d9091 1
a9091 1
      lit_fragP = fragP->tc_frag_data.literal_frag;
d9109 2
a9110 8
  /* This implicitly uses the assumption that a branch is negated
     when the size of the output increases by at least 2 bytes.  */

  if (negatable_branch && num_text_bytes >= 2)
    {
      /* If next frag is a loop end, then switch it to add a NOP.  */
      update_next_frag_nop_state (fragP);
    }
d9112 1
a9112 1
  return text_diff;
d9118 5
d9124 1
a9124 4
md_convert_frag (abfd, sec, fragp)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec;
     fragS *fragp;
d9126 5
d9152 44
a9195 3
    case RELAX_NARROW:
      /* No conversion.  */
      convert_frag_narrow (fragp);
d9198 2
a9199 5
    case RELAX_IMMED:
    case RELAX_IMMED_STEP1:
    case RELAX_IMMED_STEP2:
      /* Place the immediate.  */
      convert_frag_immed (sec, fragp, fragp->fr_subtype - RELAX_IMMED);
d9237 2
a9238 3
void
convert_frag_align_next_opcode (fragp)
     fragS *fragp;
d9268 1
a9268 2
convert_frag_narrow (fragP)
     fragS *fragP;
d9270 2
a9271 2
  static xtensa_insnbuf insnbuf = NULL;
  TInsn t_insn, single_target;
d9275 13
a9287 1
  if (fragP->tc_frag_data.text_expansion == 0)
d9296 3
a9298 5
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);

  tinsn_from_chars (&t_insn, fragP->fr_opcode);
  tinsn_immed_from_frag (&t_insn, fragP);
d9302 1
a9302 1
  old_size = xtensa_insn_length (xtensa_default_isa, t_insn.opcode);
d9307 1
a9307 1
  error_val = xg_expand_narrow (&single_target, &t_insn);
d9309 7
a9315 1
    as_bad (_("unable to widen instruction"));
d9317 1
a9317 2
  size = xtensa_insn_length (xtensa_default_isa, single_target.opcode);
  xg_emit_insn_to_buf (&single_target, fragP->fr_opcode,
d9332 31
a9362 4
convert_frag_immed (segP, fragP, min_steps)
     segT segP;
     fragS *fragP;
     int min_steps;
d9365 1
a9365 2
  static xtensa_insnbuf insnbuf = NULL;
  TInsn orig_t_insn;
d9367 1
d9369 7
a9375 2
  bfd_boolean branch_jmp_to_next = FALSE;
  int size;
d9377 1
a9377 1
  assert (fragP->fr_opcode != NULL);
d9379 3
a9381 2
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);
d9383 2
a9384 2
  tinsn_from_chars (&orig_t_insn, fragP->fr_opcode);
  tinsn_immed_from_frag (&orig_t_insn, fragP);
d9386 1
a9386 3
  /* Here is the fun stuff:  Get the immediate field from this
     instruction.  If it fits, we're done.  If not, find the next
     instruction sequence that fits.  */
d9388 2
a9389 2
  if (software_avoid_b_j_loop_end)
    branch_jmp_to_next = is_branch_jmp_to_next (&orig_t_insn, fragP);
d9394 16
a9409 2
      size = xtensa_insn_length (xtensa_default_isa, orig_t_insn.opcode);
      assemble_nop (size, fragP->fr_opcode);
d9412 1
a9412 1
  else
d9414 4
d9422 1
d9427 2
d9430 1
a9430 1
      /* It does not fit.  Find something that does and 
d9432 1
a9432 1
      frag_offset = fragP->fr_opcode - fragP->fr_literal;
d9434 1
a9434 1
      xg_assembly_relax (&istack, &orig_t_insn,
d9437 1
a9437 1
      old_size = xtensa_insn_length (xtensa_default_isa, orig_t_insn.opcode);
d9442 1
a9442 1
      total_size = 0;
d9445 1
a9445 2
	  TInsn *t_insn = &istack.insn[i];
	  int size = 0;
d9448 1
a9448 1
	  switch (t_insn->insn_type)
d9454 1
a9454 1
	      lit_frag = fragP->tc_frag_data.literal_frag;
d9457 1
a9457 1
	      if (t_insn->ntok != 1)
d9465 16
d9483 2
a9484 2
				      fragP->fr_opcode - fragP->fr_literal +
				      total_size, fragP);
d9488 9
a9496 2
	      size = xtensa_insn_length (xtensa_default_isa, t_insn->opcode);
	      total_size += size;
d9502 2
d9506 1
a9506 1
	  TInsn *t_insn = &istack.insn[i];
d9510 1
d9512 1
a9512 1
	  switch (t_insn->insn_type)
d9515 2
a9516 2
	      lit_frag = fragP->tc_frag_data.literal_frag;
	      /* already checked */
d9519 2
a9520 2
	      assert (t_insn->ntok == 1);
	      /* add a fixup */
d9523 4
d9528 1
a9528 1
				  &t_insn->tok[0], FALSE, BFD_RELOC_32);
d9535 71
a9605 3
	      xg_resolve_labels (t_insn, gen_label);
	      xg_resolve_literals (t_insn, lit_sym);
	      size = xtensa_insn_length (xtensa_default_isa, t_insn->opcode);
a9606 3
	      xg_emit_insn_to_buf (t_insn, immed_instr, fragP,
				   immed_instr - fragP->fr_literal, TRUE);
	      immed_instr += size;
d9621 1
a9621 1
  fragP->fr_var = 0;
d9624 1
a9624 1
  if (is_loop_opcode (orig_t_insn.opcode))
d9627 1
a9627 1
      sym = orig_t_insn.tok[1].X_add_symbol;
d9633 1
a9633 1
      sym = orig_t_insn.tok[1].X_op_symbol;
d9641 2
a9642 2
  if (expanded && is_loop_opcode (orig_t_insn.opcode))
    convert_frag_immed_finish_loop (segP, fragP, &orig_t_insn);
d9644 1
a9644 1
  if (expanded && is_direct_call_opcode (orig_t_insn.opcode))
d9648 1
a9648 1
			  &orig_t_insn.tok[0], TRUE,
a9649 1

d9658 8
a9665 10
fix_new_exp_in_seg (new_seg, new_subseg,
		    frag, where, size, exp, pcrel, r_type)
     segT new_seg;
     subsegT new_subseg;
     fragS *frag;
     int where;
     int size;
     expressionS *exp;
     int pcrel;
     bfd_reloc_code_real_type r_type;
d9670 1
a9673 7
  if (r_type == BFD_RELOC_32
      && exp->X_add_symbol
      && symbol_get_tc (exp->X_add_symbol)->plt == 1)
    {
      r_type = BFD_RELOC_XTENSA_PLT;
    }

d9680 19
a9698 21
/* Relax a loop instruction so that it can span loop >256 bytes.  */
/* 
                  loop    as, .L1 
          .L0: 
                  rsr     as, LEND 
                  wsr     as, LBEG 
                  addi    as, as, lo8(label-.L1) 
                  addmi   as, as, mid8(label-.L1) 
                  wsr     as, LEND 
                  isync 
                  rsr     as, LCOUNT 
                  addi    as, as, 1 
          .L1: 
                  <<body>> 
          label:                                     */

static void
convert_frag_immed_finish_loop (segP, fragP, t_insn)
     segT segP;
     fragS *fragP;
     TInsn *t_insn;
d9710 2
d9717 7
a9723 3
  loop_offset = get_expanded_loop_offset (t_insn->opcode);
  /* Validate that there really is a LOOP at the loop_offset.  */
  tinsn_from_chars (&loop_insn, fragP->fr_opcode + loop_offset);
d9725 1
a9725 6
  if (!is_loop_opcode (loop_insn.opcode))
    {
      as_bad_where (fragP->fr_file, fragP->fr_line,
		    _("loop relaxation specification does not correspond"));
      assert (0);
    }
d9729 16
a9744 2
  assert (t_insn->ntok == 2);
  target = get_expression_value (segP, &t_insn->tok[1]);
d9760 1
a9760 1
  /* Because addmi sign-extends the immediate, 'loop_length_hi' can be at most 
d9766 1
a9766 1
  tinsn_from_chars (&addi_insn, fragP->fr_opcode + addi_offset);
d9769 1
a9769 1
  tinsn_from_chars (&addmi_insn, fragP->fr_opcode + addmi_offset);
d9774 1
a9774 1
  
d9776 1
a9776 1
  xtensa_insnbuf_to_chars (isa, insnbuf, fragP->fr_opcode + addi_offset);
d9780 1
a9780 2
  xtensa_insnbuf_to_chars (isa, insnbuf, fragP->fr_opcode + addmi_offset);
}
d9782 4
d9787 3
a9789 8
static offsetT
get_expression_value (segP, exp)
     segT segP;
     expressionS *exp;
{
  if (exp->X_op == O_constant)
    return exp->X_add_number;
  if (exp->X_op == O_symbol)
d9791 5
a9795 7
      /* Find the fragment.  */
      symbolS *sym = exp->X_add_symbol;

      assert (S_GET_SEGMENT (sym) == segP
	      || S_GET_SEGMENT (sym) == absolute_section);

      return (S_GET_VALUE (sym) + exp->X_add_number);
a9796 2
  as_bad (_("invalid expression evaluation type %d"), exp->X_op);
  return 0;
d9813 2
d9819 1
d9822 2
a9823 5

static unsigned
get_last_insn_flags (seg, subseg)
     segT seg;
     subsegT subseg;
d9827 8
a9834 3
  for (subseg_e = sseg_map; subseg_e != NULL; subseg_e = subseg_e->next)
    if (seg == subseg_e->seg && subseg == subseg_e->subseg)
      return subseg_e->flags;
d9836 14
a9849 1
  return 0;
d9853 2
a9854 6
static void
set_last_insn_flags (seg, subseg, fl, val)
     segT seg;
     subsegT subseg;
     unsigned fl;
     bfd_boolean val;
d9856 5
a9860 1
  subseg_map *subseg_e;
a9861 14
  for (subseg_e = sseg_map; subseg_e; subseg_e = subseg_e->next)
    if (seg == subseg_e->seg && subseg == subseg_e->subseg)
      break;

  if (!subseg_e)
    {
      subseg_e = (subseg_map *) xmalloc (sizeof (subseg_map));
      memset (subseg_e, 0, sizeof (subseg_map));
      subseg_e->seg = seg;
      subseg_e->subseg = subseg;
      subseg_e->flags = 0;
      subseg_e->next = sseg_map;
      sseg_map = subseg_e;
    }
d9863 9
d9878 31
d9915 1
a9915 2
xtensa_remove_section (sec)
     segT sec;
d9932 1
a9932 3
xtensa_insert_section (after_sec, sec)
     segT after_sec;
     segT sec;
d9945 1
a9945 2
xtensa_move_seg_list_to_beginning (head)
     seg_list *head;
d9962 4
a9965 2
void
xtensa_move_literals ()
d10008 1
d10011 1
d10013 1
a10013 1
      while (search_frag != frag_now) 
d10017 1
a10017 1
	  /* First, move the frag out of the literal section and 
d10023 1
a10023 1
	      /* Note that we set this fr_var to be a fix 
d10029 1
a10029 1
	  
d10034 1
a10034 1
	  
d10079 2
a10080 1
      S_SET_SEGMENT (lit_sym, dest_seg);
d10090 1
a10090 2
mark_literal_frags (segment)
     seg_list *segment;
d10110 1
a10110 3
xtensa_reorder_seg_list (head, after)
     seg_list *head;
     segT after;
d10135 2
a10136 2
void
xtensa_reorder_segments ()
d10139 1
a10139 1
  segT last_sec;
d10144 4
a10147 1
    old_count++;
a10150 1
  last_sec = get_last_sec ();
d10162 6
a10167 2
segT
get_last_sec ()
d10169 9
a10177 3
  segT last_sec = stdoutput->sections;
  while (last_sec->next != NULL)
    last_sec = last_sec->next;
d10179 3
a10181 1
  return last_sec;
d10185 2
a10186 7
/* Change the emit state (seg, subseg, and frag related stuff) to the
   correct location.  Return a emit_state which can be passed to
   xtensa_restore_emit_state to return to current fragment.  */

void
xtensa_switch_to_literal_fragment (result)
     emit_state *result;
a10200 1
  
d10202 2
a10203 2
  if (pool_location == NULL 
      && !use_literal_section 
d10207 1
a10207 2
      as_warn (_("inlining literal pool; "
		 "specify location with .literal_position."));
d10221 1
a10221 1
			     &default_lit_sections.init_lit_seg);
d10229 1
a10229 1
			     &default_lit_sections.fini_lit_seg);
d10233 1
a10233 1
  else 
d10237 1
a10237 1
			     &default_lit_sections.lit_seg);
d10242 3
a10244 3
  if (!use_literal_section &&
      !is_init && !is_fini &&
      get_literal_pool_location (now_seg) != pool_location)
d10248 1
d10251 1
a10252 3

  /* Do a 4 byte align here.  */
  frag_align (2, 0, 0);
d10260 4
a10263 5
void
xtensa_switch_section_emit_state (state, new_now_seg, new_now_subseg)
     emit_state *state;
     segT new_now_seg;
     subsegT new_now_subseg;
d10270 1
a10270 1
  subseg_new (segment_name (new_now_seg), new_now_subseg);
d10276 2
a10277 3
void
xtensa_restore_emit_state (state)
     emit_state *state;
d10280 1
a10280 1
  subseg_new (state->name, state->now_subseg);
d10288 4
a10291 4
cache_literal_section (head, name, seg)
     seg_list *head;
     const char *name;
     segT *seg;
d10295 1
d10297 1
a10297 1
  if (*seg != 0)
d10299 27
a10325 1
  *seg = retrieve_literal_seg (head, name);
d10329 27
d10357 1
a10357 2
/* Get a segment of a given name.  If the segment is already
   present, return it; otherwise, create a new one.  */
d10359 2
a10360 4
static segT
retrieve_literal_seg (head, name)
     seg_list *head;
     const char *name;
d10362 3
a10364 1
  segT ret = 0;
d10366 1
a10366 1
  assert (head);
d10368 8
a10375 9
  ret = seg_present (name);
  if (!ret)
    {
      ret = subseg_new (name, (subsegT) 0);
      add_seg_list (head, ret);
      bfd_set_section_flags (stdoutput, ret, SEC_HAS_CONTENTS |
			     SEC_READONLY | SEC_ALLOC | SEC_LOAD | SEC_CODE);
      bfd_set_section_alignment (stdoutput, ret, 2);
    }
d10377 3
a10379 1
  return ret;
d10383 9
a10391 1
/* Return a segment of a given name if it is present.  */
d10393 5
a10397 3
static segT
seg_present (name)
     const char *name;
d10399 6
a10404 2
  segT seg;
  seg = stdoutput->sections;
d10406 3
a10408 1
  while (seg)
d10410 21
a10430 3
      if (!strcmp (segment_name (seg), name))
	return seg;
      seg = seg->next;
d10433 19
a10451 2
  return 0;
}
d10453 2
d10456 2
a10457 1
/* Add a segment to a segment list.  */
d10459 4
a10462 8
static void
add_seg_list (head, seg)
     seg_list *head;
     segT seg;
{
  seg_list *n;
  n = (seg_list *) xmalloc (sizeof (seg_list));
  assert (n);
d10464 9
a10472 4
  n->seg = seg;
  n->next = head->next;
  head->next = n;
}
d10474 2
a10475 2

/* Set up Property Tables after Relaxation.  */
d10477 7
a10483 2
#define XTENSA_INSN_SEC_NAME ".xt.insn"
#define XTENSA_LIT_SEC_NAME ".xt.lit"
d10485 3
a10487 6
void
xtensa_post_relax_hook ()
{
  xtensa_move_seg_list_to_beginning (literal_head);
  xtensa_move_seg_list_to_beginning (init_literal_head);
  xtensa_move_seg_list_to_beginning (fini_literal_head);
d10489 2
a10490 7
  xtensa_create_property_segments (get_frag_is_insn,
				   XTENSA_INSN_SEC_NAME,
				   xt_insn_sec);
  xtensa_create_property_segments (get_frag_is_literal,
				   XTENSA_LIT_SEC_NAME,
				   xt_literal_sec);
}
d10492 8
d10501 14
a10514 8
static bfd_boolean
get_frag_is_literal (fragP)
     const fragS *fragP;
{
  assert (fragP != NULL);
  return (fragP->tc_frag_data.is_literal);
}
 
d10516 8
a10523 6
static bfd_boolean
get_frag_is_insn (fragP)
     const fragS *fragP;
{
  assert (fragP != NULL);
  return (fragP->tc_frag_data.is_insn);
d10528 3
a10530 5
xtensa_create_property_segments (property_function, section_name_base, 
				 sec_type)
     frag_predicate property_function;
     const char * section_name_base;
     xt_section_type sec_type;
d10535 3
a10537 3
     Walk over each fragment
      For each fragment that has instructions
      Build an instruction record (append where possible).  */
d10544 9
a10552 1
      if (section_has_property (sec, property_function))
d10558 1
a10558 1
	  xtensa_block_info **xt_blocks = 
d10561 1
a10561 1
	  add_xt_block_frags (sec, insn_sec, xt_blocks, property_function);
d10574 1
d10582 1
a10582 1
	  size_t num_recs = 0;
d10588 1
a10588 1
	  rec_size = num_recs * 8;
d10591 5
a10595 4
	  /* In order to make this work with the assembler, we have to
	     build some frags and then build the "fixups" for it.  It
	     would be easier to just set the contents then set the
	     arlents.  */
d10599 1
a10599 1
	      /* Allocate a fragment and leak it.  */
d10604 1
a10604 1
	      size_t i;
d10616 1
a10616 1
	      /* the rest are zeros */
d10642 1
a10642 1
		  fix->fx_where = i * 8;
d10650 1
a10650 1
		  md_number_to_chars (&frag_data[4 + 8 * i],
d10652 3
d10663 2
a10664 3
segment_info_type *
retrieve_segment_info (seg)
     segT seg;
d10673 1
a10673 1
      memset ((PTR) seginfo, 0, sizeof (*seginfo));
d10686 1
a10686 1
	bfd_set_section_userdata (stdoutput, seg, (PTR) seginfo);
d10712 2
a10713 3
segT
retrieve_xtensa_section (sec_name)
     char *sec_name;
d10735 2
a10736 4
bfd_boolean
section_has_property (sec, property_function)
     segT sec;
     frag_predicate property_function;
d10754 20
d10776 6
a10781 6
void
add_xt_block_frags (sec, xt_block_sec, xt_block, property_function)
     segT sec;
     segT xt_block_sec;
     xtensa_block_info **xt_block;
     frag_predicate property_function;
d10816 371
a11186 13
	      if (*xt_block == NULL)
		{
		  xtensa_block_info *new_block = (xtensa_block_info *)
		    xmalloc (sizeof (xtensa_block_info));
		  new_block->sec = sec;
		  new_block->offset = fragP->fr_address;
		  new_block->size = fragP->fr_fix;
		  new_block->next = NULL;
		  *xt_block = new_block;
		}
	    }
	}
    }
d11193 1
a11193 2
istack_init (stack)
     IStack *stack;
d11201 1
a11201 2
istack_empty (stack)
     IStack *stack;
d11208 1
a11208 2
istack_full (stack)
     IStack *stack;
d11215 1
a11215 1
   It is an error to call this if istack_empty () is true. */
d11218 1
a11218 2
istack_top (stack)
     IStack *stack;
d11227 1
a11227 1
   It is an error to call this if istack_full () is true.  */
d11230 1
a11230 3
istack_push (stack, insn)
     IStack *stack;
     TInsn *insn;
d11234 1
a11234 1
  tinsn_copy (&stack->insn[rec], insn);
d11240 1
a11240 1
   to it.  It is an error to call this if istack_full () is true.  */
d11243 1
a11243 2
istack_push_space (stack)
     IStack *stack;
d11256 1
a11256 1
   istack_empty () returns true.  */
d11259 1
a11259 2
istack_pop (stack)
     IStack *stack;
d11271 1
a11271 2
tinsn_init (dst)
     TInsn *dst;
a11276 10
void
tinsn_copy (dst, src)
     TInsn *dst;
     const TInsn *src;
{
  tinsn_init (dst);
  memcpy (dst, src, sizeof (TInsn));
}


d11281 1
a11281 3
tinsn_get_tok (insn, num)
     TInsn *insn;
     int num;
d11288 1
a11288 1
/* Return true if ANY of the operands in the insn are symbolic.  */
d11291 1
a11291 2
tinsn_has_symbolic_operands (insn)
     const TInsn *insn;
d11314 1
a11314 2
tinsn_has_invalid_symbolic_operands (insn)
     const TInsn *insn;
d11316 1
d11329 7
d11337 16
a11352 5
	  if (i == get_relaxable_immed (insn->opcode))
	    break;
	  as_bad (_("invalid symbolic operand %d on '%s'"),
		  i, xtensa_opcode_name (xtensa_default_isa, insn->opcode));
	  return TRUE;
d11366 1
a11366 2
tinsn_has_complex_operands (insn)
     const TInsn *insn;
d11378 2
d11389 2
a11390 2
/* Convert the constant operands in the t_insn to insnbuf.
   Return true if there is a symbol in the immediate field.
d11392 1
a11392 1
   Before this is called, 
d11394 1
a11394 1
   2) the t_insn is a ITYPE_INSN
d11400 1
a11400 3
tinsn_to_insnbuf (t_insn, insnbuf)
     TInsn *t_insn;
     xtensa_insnbuf insnbuf;
d11402 1
d11404 2
a11405 1
  xtensa_opcode opcode = t_insn->opcode;
d11407 1
a11407 1
  int noperands = xtensa_num_operands (isa, opcode);
d11413 5
a11417 2
  assert (t_insn->insn_type == ITYPE_INSN);
  if (noperands != t_insn->ntok)
d11420 2
a11421 1
  xtensa_encode_insn (isa, opcode, insnbuf);
d11425 1
a11425 2
      expressionS *expr = &t_insn->tok[i];
      xtensa_operand operand = xtensa_get_operand (isa, opcode, i);
d11429 3
a11431 1
	  /* The register number has already been checked in  
d11434 3
a11436 2
	  (void) xtensa_operand_encode (operand, &opnd_value);
	  xtensa_operand_set_field (operand, insnbuf, opnd_value);
d11440 2
d11445 85
a11529 1
	  xtensa_insnbuf_set_operand (insnbuf, opcode, operand,
a11532 1
	case O_symbol:
d11538 1
d11543 1
a11543 1
/* Check the instruction arguments.  Return true on failure.  */
d11545 2
a11546 3
bfd_boolean
tinsn_check_arguments (insn)
     const TInsn *insn;
d11557 1
a11557 1
  if (xtensa_num_operands (isa, opcode) > insn->ntok)
d11563 1
a11563 1
  if (xtensa_num_operands (isa, opcode) < insn->ntok)
d11575 17
a11591 3
tinsn_from_chars (t_insn, f)
     TInsn *t_insn;
     char *f;
a11592 1
  static xtensa_insnbuf insnbuf = NULL;
a11593 1
  xtensa_opcode opcode;
a11595 6
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

  xtensa_insnbuf_from_chars (isa, insnbuf, f);
  opcode = xtensa_decode_insn (isa, insnbuf);

d11597 10
a11606 9
  tinsn_init (t_insn);
  t_insn->insn_type = ITYPE_INSN;
  t_insn->is_specific_opcode = FALSE;	/* Must not be specific.  */
  t_insn->opcode = opcode;
  t_insn->ntok = xtensa_num_operands (isa, opcode);
  for (i = 0; i < t_insn->ntok; i++)
    {
      set_expr_const (&t_insn->tok[i],
		      xtensa_insnbuf_get_operand (insnbuf, opcode, i));
d11614 1
a11614 3
tinsn_immed_from_frag (t_insn, fragP)
     TInsn *t_insn;
     fragS *fragP;
d11616 1
a11616 1
  xtensa_opcode opcode = t_insn->opcode;
d11619 1
a11619 1
  if (fragP->fr_symbol)
d11622 16
a11637 2
      set_expr_symbol_offset (&t_insn->tok[opnum],
			      fragP->fr_symbol, fragP->fr_offset);
d11643 1
a11643 2
get_num_stack_text_bytes (istack)
     IStack *istack;
d11650 3
a11652 3
      TInsn *t_insn = &istack->insn[i];
      if (t_insn->insn_type == ITYPE_INSN)
	text_bytes += xg_get_insn_size (t_insn);
d11659 1
a11659 2
get_num_stack_literal_bytes (istack)
     IStack *istack;
d11666 2
a11667 3
      TInsn *t_insn = &istack->insn[i];

      if (t_insn->insn_type == ITYPE_LITERAL && t_insn->ntok == 1)
d11674 210
d11886 1
a11886 1
/* Return true if the expression is an integer constant.  */
d11889 1
a11889 2
expr_is_const (s)
     const expressionS *s;
d11896 1
a11896 1
   Calling this is illegal if expr_is_const () returns true.  */
d11899 1
a11899 2
get_expr_const (s)
     const expressionS *s;
d11909 1
a11909 3
set_expr_const (s, val)
     expressionS *s;
     offsetT val;
d11918 18
d11939 1
a11939 4
set_expr_symbol_offset (s, sym, offset)
     expressionS *s;
     symbolS *sym;
     offsetT offset;
d11948 17
d11966 1
a11966 3
expr_is_equal (s1, s2)
     expressionS *s1;
     expressionS *s2;
d11981 1
a11981 3
copy_expr (dst, src)
     expressionS *dst;
     const expressionS *src;
d11987 1
a11987 3
/* Support for Tensilica's "--rename-section" option.  */

#ifdef XTENSA_SECTION_RENAME
d11999 4
a12002 2
/* Parse the string oldname=new_name:oldname2=new_name2 
   and call add_section_rename.  */
d12004 2
a12005 3
void
build_section_rename (arg)
     const char *arg;
d12007 1
d12011 1
a12011 1
  for (this_arg = strdup (arg); this_arg != NULL; this_arg = next_arg)
d12013 2
a12023 3
      {
	char *old_name = this_arg;
	char *new_name = strchr (this_arg, '=');
d12025 34
a12058 15
	if (*old_name == '\0')
	  {
	    as_warn (_("ignoring extra '-rename-section' delimiter ':'"));
	    continue;
	  }
	if (!new_name || new_name[1] == '\0')
	  {
	    as_warn (_("ignoring invalid '-rename-section' "
		       "specification: '%s'"), old_name);
	    continue;
	  }
	*new_name = '\0';
	new_name++;
	add_section_rename (old_name, new_name);
      }
d12063 2
a12064 4
static void
add_section_rename (old_name, new_name)
     char *old_name;
     char *new_name;
a12067 1
  /* Check for invalid section renaming.  */
d12070 2
a12071 5
      if (strcmp (r->old_name, old_name) == 0)
	as_bad (_("section %s renamed multiple times"), old_name);
      if (strcmp (r->new_name, new_name) == 0)
	as_bad (_("multiple sections remapped to output section %s"),
		new_name);
a12073 20
  /* Now add it.  */
  r = (struct rename_section_struct *)
    xmalloc (sizeof (struct rename_section_struct));
  r->old_name = strdup (old_name);
  r->new_name = strdup (new_name);
  r->next = section_rename;
  section_rename = r;
}


const char *
xtensa_section_rename (name)
     const char *name;
{
  struct rename_section_struct *r = section_rename;

  for (r = section_rename; r != NULL; r = r->next)
    if (strcmp (r->old_name, name) == 0)
      return r->new_name;

a12075 2

#endif /* XTENSA_SECTION_RENAME */
@


1.1.2.1
log
@binutils-040916.tar.bz2 from sources.deadrat.com for src/ for later use
@
text
@d3724 1
a3724 1
  assert (insn->ntok == 1);	/* must be only one token here */
@


1.1.2.2
log
@binutils-050108.tar.bz2
@
text
@d2 1
a2 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d18 1
a18 1
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,
a21 1
#include <limits.h>
d43 7
d74 3
a76 2
/* Flags to indicate whether the hardware supports the density and
   absolute literals options.  */
d78 1
d80 3
a82 4
bfd_boolean absolute_literals_supported = XSHAL_USE_ABSOLUTE_LITERALS;

/* Maximum width we would pad an unreachable frag to get alignment.  */
#define UNREACHABLE_MAX_WIDTH  8
d84 1
a84 10
static vliw_insn cur_vinsn;

size_t xtensa_fetch_width = XCHAL_INST_FETCH_WIDTH;

static enum debug_info_type xt_saved_debug_type = DEBUG_NONE;

/* Some functions are only valid in the front end.  This variable
   allows us to assert that we haven't crossed over into the 
   back end.  */
static bfd_boolean past_xtensa_end = FALSE;
a96 1
#define LIT4_SECTION_NAME		xtensa_section_rename (".lit4")
d103 1
a103 1
/* This type is used for the directive_stack to keep track of the
a108 1
  const char *lit4_seg_name;
a111 1
  segT lit4_seg;
a155 5
/* Flags to determine whether to prefer const16 or l32r
   if both options are available.  */
int prefer_const16 = 0;
int prefer_l32r = 0;

a158 131
/* The following PROPERTY table definitions are copied from
   <elf/xtensa.h> and must be kept in sync with the code there.  */

/* Flags in the property tables to specify whether blocks of memory
   are literals, instructions, data, or unreachable.  For
   instructions, blocks that begin loop targets and branch targets are
   designated.  Blocks that do not allow density, instruction
   reordering or transformation are also specified.  Finally, for
   branch targets, branch target alignment priority is included.
   Alignment of the next block is specified in the current block
   and the size of the current block does not include any fill required
   to align to the next block.  */

#define XTENSA_PROP_LITERAL		0x00000001
#define XTENSA_PROP_INSN		0x00000002
#define XTENSA_PROP_DATA		0x00000004
#define XTENSA_PROP_UNREACHABLE		0x00000008
/* Instruction only properties at beginning of code.  */
#define XTENSA_PROP_INSN_LOOP_TARGET	0x00000010
#define XTENSA_PROP_INSN_BRANCH_TARGET	0x00000020
/* Instruction only properties about code.  */
#define XTENSA_PROP_INSN_NO_DENSITY	0x00000040
#define XTENSA_PROP_INSN_NO_REORDER	0x00000080
#define XTENSA_PROP_INSN_NO_TRANSFORM	0x00000100

/*  Branch target alignment information.  This transmits information
    to the linker optimization about the priority of aligning a
    particular block for branch target alignment: None, low priority,
    high priority, or required.  These only need to be checked in
    instruction blocks marked as XTENSA_PROP_INSN_BRANCH_TARGET.
    Common usage is

    switch (GET_XTENSA_PROP_BT_ALIGN (flags))
    case XTENSA_PROP_BT_ALIGN_NONE:
    case XTENSA_PROP_BT_ALIGN_LOW:
    case XTENSA_PROP_BT_ALIGN_HIGH:
    case XTENSA_PROP_BT_ALIGN_REQUIRE:
*/
#define XTENSA_PROP_BT_ALIGN_MASK       0x00000600

/* No branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_NONE       0x0
/* Low priority branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_LOW        0x1
/* High priority branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_HIGH       0x2
/* Required branch target alignment.  */
#define XTENSA_PROP_BT_ALIGN_REQUIRE    0x3

#define GET_XTENSA_PROP_BT_ALIGN(flag) \
  (((unsigned) ((flag) & (XTENSA_PROP_BT_ALIGN_MASK))) >> 9)
#define SET_XTENSA_PROP_BT_ALIGN(flag, align) \
  (((flag) & (~XTENSA_PROP_BT_ALIGN_MASK)) | \
    (((align) << 9) & XTENSA_PROP_BT_ALIGN_MASK))


/* Alignment is specified in the block BEFORE the one that needs
   alignment.  Up to 5 bits.  Use GET_XTENSA_PROP_ALIGNMENT(flags) to
   get the required alignment specified as a power of 2.  Use
   SET_XTENSA_PROP_ALIGNMENT(flags, pow2) to set the required
   alignment.  Be careful of side effects since the SET will evaluate
   flags twice.  Also, note that the SIZE of a block in the property
   table does not include the alignment size, so the alignment fill
   must be calculated to determine if two blocks are contiguous.
   TEXT_ALIGN is not currently implemented but is a placeholder for a
   possible future implementation.  */

#define XTENSA_PROP_ALIGN		0x00000800

#define XTENSA_PROP_ALIGNMENT_MASK      0x0001f000

#define GET_XTENSA_PROP_ALIGNMENT(flag) \
  (((unsigned) ((flag) & (XTENSA_PROP_ALIGNMENT_MASK))) >> 12)
#define SET_XTENSA_PROP_ALIGNMENT(flag, align) \
  (((flag) & (~XTENSA_PROP_ALIGNMENT_MASK)) | \
    (((align) << 12) & XTENSA_PROP_ALIGNMENT_MASK))

#define XTENSA_PROP_INSN_ABSLIT 0x00020000


/* Structure for saving instruction and alignment per-fragment data
   that will be written to the object file.  This structure is
   equivalent to the actual data that will be written out to the file
   but is easier to use.   We provide a conversion to file flags
   in frag_flags_to_number.  */

typedef struct frag_flags_struct frag_flags;

struct frag_flags_struct
{
  /* is_literal should only be used after xtensa_move_literals.
     If you need to check if you are generating a literal fragment,
     then use the generating_literals global.  */

  unsigned is_literal : 1;
  unsigned is_insn : 1;
  unsigned is_data : 1;
  unsigned is_unreachable : 1;

  struct
  {
    unsigned is_loop_target : 1;
    unsigned is_branch_target : 1; /* Branch targets have a priority.  */
    unsigned bt_align_priority : 2;

    unsigned is_no_density : 1;
    /* no_longcalls flag does not need to be placed in the object file.  */
    /* is_specific_opcode implies no_transform.  */
    unsigned is_no_transform : 1;

    unsigned is_no_reorder : 1;

    /* Uses absolute literal addressing for l32r.  */
    unsigned is_abslit : 1;
  } insn;
  unsigned is_align : 1;
  unsigned alignment : 5;
};


/* Structure for saving information about a block of property data
   for frags that have the same flags.  */
struct xtensa_block_info_struct
{
  segT sec;
  bfd_vma offset;
  size_t size;
  frag_flags flags;
  struct xtensa_block_info_struct *next;
};

a169 53
/* Opcode placement information */

typedef unsigned long long bitfield;
#define bit_is_set(bit, bf)	((bf) & (0x01ll << (bit)))
#define set_bit(bit, bf)	((bf) |= (0x01ll << (bit)))
#define clear_bit(bit, bf)	((bf) &= ~(0x01ll << (bit)))

#define MAX_FORMATS 32

typedef struct op_placement_info_struct
{
  int num_formats;
  /* A number describing how restrictive the issue is for this
     opcode.  For example, an opcode that fits lots of different
     formats has a high freedom, as does an opcode that fits 
     only one format but many slots in that format.  The most
     restrictive is the opcode that fits only one slot in one 
     format.  */
  int issuef;
  /* The single format (i.e., if the op can live in a bundle by itself),
     narrowest format, and widest format the op can be bundled in 
     and their sizes:  */
  xtensa_format single;
  xtensa_format narrowest;
  xtensa_format widest;
  char narrowest_size;
  char widest_size;
  char single_size;

  /* formats is a bitfield with the Nth bit set
     if the opcode fits in the Nth xtensa_format.  */
  bitfield formats;

  /* slots[N]'s Mth bit is set if the op fits in the
     Mth slot of the Nth xtensa_format.  */
  bitfield slots[MAX_FORMATS];

  /* A count of the number of slots in a given format
     an op can fit (i.e., the bitcount of the slot field above).  */
  char slots_in_format[MAX_FORMATS];

} op_placement_info, *op_placement_info_table;

op_placement_info_table op_placement_table;


/* Extra expression types.  */

#define O_pltrel	O_md1	/* like O_symbol but use a PLT reloc */
#define O_hi16		O_md2	/* use high 16 bits of symbolic value */
#define O_lo16		O_md3	/* use low 16 bits of symbolic value */


d177 2
a178 1
  directive_transform,
d181 1
a181 4
  directive_literal_prefix,
  directive_schedule,
  directive_absolute_literals,
  directive_last_directive
d192 8
a199 9
  { "none",		FALSE },
  { "literal",		FALSE },
  { "density",		TRUE },
  { "transform",	TRUE },
  { "freeregs",		FALSE },
  { "longcalls",	TRUE },
  { "literal_prefix",	FALSE },
  { "schedule",		TRUE },
  { "absolute-literals", TRUE }
d206 1
a206 1
#if !XCHAL_HAVE_DENSITY
d211 2
a212 1
  TRUE,				/* transform */
d215 95
a309 7
  FALSE,			/* literal_prefix */
  TRUE,				/* schedule */
#if XSHAL_USE_ABSOLUTE_LITERALS
  TRUE				/* absolute_literals */
#else
  FALSE				/* absolute_literals */
#endif
d312 7
d322 54
a375 8
static void xtensa_begin_directive (int);
static void xtensa_end_directive (int);
static void xtensa_dwarf2_directive_loc (int);
static void xtensa_literal_prefix (char const *, int);
static void xtensa_literal_position (int);
static void xtensa_literal_pseudo (int);
static void xtensa_frequency_pseudo (int);
static void xtensa_elf_cons (int);
d377 1
a377 1
/* Parsing and Idiom Translation.  */
d379 40
a418 1
static bfd_reloc_code_real_type xtensa_elf_suffix (char **, expressionS *);
d422 155
a576 8
static void xtensa_mark_literal_pool_location (void);
static addressT get_expanded_loop_offset (xtensa_opcode);
static fragS *get_literal_pool_location (segT);
static void set_literal_pool_location (segT, fragS *);
static void xtensa_set_frag_assembly_state (fragS *);
static void finish_vinsn (vliw_insn *);
static bfd_boolean emit_single_op (TInsn *);
static int total_frag_text_expansion (fragS *);
d580 14
a593 2
static size_t get_text_align_power (int);
static addressT get_text_align_max_fill_size (int, bfd_boolean, bfd_boolean);
d597 10
a606 1
static long relax_frag_add_nop (fragS *);
d608 1
a608 1
/* Accessors for additional per-subsegment information.  */
d610 20
a629 5
static unsigned get_last_insn_flags (segT, subsegT);
static void set_last_insn_flags (segT, subsegT, unsigned, bfd_boolean);
static float get_subseg_total_freq (segT, subsegT);
static float get_subseg_target_freq (segT, subsegT);
static void set_subseg_freq (segT, subsegT, float, float);
d633 22
a654 6
static void xtensa_move_literals (void);
static void xtensa_reorder_segments (void);
static void xtensa_switch_to_literal_fragment (emit_state *);
static void xtensa_switch_to_non_abs_literal_fragment (emit_state *);
static void xtensa_switch_section_emit_state (emit_state *, segT, subsegT);
static void xtensa_restore_emit_state (emit_state *);
d656 7
a662 1
  (seg_list *, const char *, segT *, bfd_boolean);
d664 1
a664 1
/* Import from elf32-xtensa.c in BFD library.  */
d666 14
a679 1
extern char *xtensa_get_property_section_name (asection *, const char *);
d681 3
a683 6
/* op_placement_info functions.  */

static void init_op_placement_info_table (void);
extern bfd_boolean opcode_fits_format_slot (xtensa_opcode, xtensa_format, int);
static int xg_get_single_size (xtensa_opcode);
static xtensa_format xg_get_single_format (xtensa_opcode);
d686 18
a703 20

static bfd_boolean tinsn_has_symbolic_operands (const TInsn *);
static bfd_boolean tinsn_has_invalid_symbolic_operands (const TInsn *);
static bfd_boolean tinsn_has_complex_operands (const TInsn *);
static bfd_boolean tinsn_to_insnbuf (TInsn *, xtensa_insnbuf);
static bfd_boolean tinsn_check_arguments (const TInsn *);
static void tinsn_from_chars (TInsn *, char *, int);
static void tinsn_immed_from_frag (TInsn *, fragS *, int);
static int get_num_stack_text_bytes (IStack *);
static int get_num_stack_literal_bytes (IStack *);

/* vliw_insn functions.  */

static void xg_init_vinsn (vliw_insn *);
static void xg_clear_vinsn (vliw_insn *);
static bfd_boolean vinsn_has_specific_opcodes (vliw_insn *);
static void xg_free_vinsn (vliw_insn *);
static bfd_boolean vinsn_to_insnbuf
  (vliw_insn *, char *, fragS *, bfd_boolean);
static void vinsn_from_chars (vliw_insn *, char *);
d706 19
a724 15

bfd_boolean expr_is_const (const expressionS *);
offsetT get_expr_const (const expressionS *);
void set_expr_const (expressionS *, offsetT);
bfd_boolean expr_is_register (const expressionS *);
offsetT get_expr_register (const expressionS *);
void set_expr_symbol_offset (expressionS *, symbolS *, offsetT);
static void set_expr_symbol_offset_diff
  (expressionS *, symbolS *, symbolS *, offsetT);
bfd_boolean expr_is_equal (expressionS *, expressionS *);
static void copy_expr (expressionS *, const expressionS *);

/* Section renaming.  */

static void build_section_rename (const char *);
a741 1
static xtensa_opcode xtensa_const16_opcode;
a742 2
static xtensa_opcode xtensa_movi_opcode;
static xtensa_opcode xtensa_movi_n_opcode;
d744 1
a745 1
static xtensa_opcode xtensa_l32r_opcode;
a748 1
static xtensa_opcode xtensa_nop_opcode;
d755 1
a755 1
static xtensa_opcode xtensa_rsr_lcount_opcode;
d763 2
a764 1
static bfd_boolean warn_unaligned_branch_targets = FALSE;
d766 1
a766 6
static bfd_boolean workaround_a0_b_retw = FALSE;
static bfd_boolean workaround_b_j_loop_end = FALSE;
static bfd_boolean workaround_short_loop = FALSE;
static bfd_boolean maybe_has_short_loop = FALSE;
static bfd_boolean workaround_close_loop_end = FALSE;
static bfd_boolean maybe_has_close_loop_end = FALSE;
d768 3
a770 5
/* When workaround_short_loops is TRUE, all loops with early exits must
   have at least 3 instructions.  workaround_all_short_loops is a modifier
   to the workaround_short_loop flag.  In addition to the
   workaround_short_loop actions, all straightline loopgtz and loopnez
   must have at least 3 instructions.  */
d772 3
a774 1
static bfd_boolean workaround_all_short_loops = FALSE;
d776 3
d780 5
a784 5
static void
xtensa_setup_hw_workarounds (int earliest, int latest)
{
  if (earliest > latest)
    as_fatal (_("illegal range of target hardware versions"));
d786 2
a787 10
  /* Enable all workarounds for pre-T1050.0 hardware.  */
  if (earliest < 105000 || latest < 105000)
    {
      workaround_a0_b_retw |= TRUE;
      workaround_b_j_loop_end |= TRUE;
      workaround_short_loop |= TRUE;
      workaround_close_loop_end |= TRUE;
      workaround_all_short_loops |= TRUE;
    }
}
d789 2
a799 3
  option_link_relax,
  option_no_link_relax,

a802 3
  option_transform,
  option_no_transform,

a805 3
  option_absolute_literals,
  option_no_absolute_literals,

d809 2
a810 1
  option_warn_unaligned_targets,
d832 5
d838 1
d840 2
a841 4
  option_prefer_l32r,
  option_prefer_const16,

  option_target_hardware
d848 13
a860 17
  { "density", no_argument, NULL, option_density },
  { "no-density", no_argument, NULL, option_no_density },

  /* Both "relax" and "generics" are deprecated and treated as equivalent
     to the "transform" option.  */
  { "relax", no_argument, NULL, option_relax },
  { "no-relax", no_argument, NULL, option_no_relax },
  { "generics", no_argument, NULL, option_generics },
  { "no-generics", no_argument, NULL, option_no_generics },

  { "transform", no_argument, NULL, option_transform },
  { "no-transform", no_argument, NULL, option_no_transform },
  { "text-section-literals", no_argument, NULL, option_text_section_literals },
  { "no-text-section-literals", no_argument, NULL,
    option_no_text_section_literals },
  { "absolute-literals", no_argument, NULL, option_absolute_literals },
  { "no-absolute-literals", no_argument, NULL, option_no_absolute_literals },
d863 50
a912 35
  { "target-align", no_argument, NULL, option_align_targets },
  { "no-target-align", no_argument, NULL, option_no_align_targets },
  { "warn-unaligned-targets", no_argument, NULL,
    option_warn_unaligned_targets },
  { "longcalls", no_argument, NULL, option_longcalls },
  { "no-longcalls", no_argument, NULL, option_no_longcalls },

  { "no-workaround-a0-b-retw", no_argument, NULL,
    option_no_workaround_a0_b_retw },
  { "workaround-a0-b-retw", no_argument, NULL, option_workaround_a0_b_retw },

  { "no-workaround-b-j-loop-end", no_argument, NULL,
    option_no_workaround_b_j_loop_end },
  { "workaround-b-j-loop-end", no_argument, NULL,
    option_workaround_b_j_loop_end },

  { "no-workaround-short-loops", no_argument, NULL,
    option_no_workaround_short_loop },
  { "workaround-short-loops", no_argument, NULL,
    option_workaround_short_loop },

  { "no-workaround-all-short-loops", no_argument, NULL,
    option_no_workaround_all_short_loops },
  { "workaround-all-short-loop", no_argument, NULL,
    option_workaround_all_short_loops },

  { "prefer-l32r", no_argument, NULL, option_prefer_l32r },
  { "prefer-const16", no_argument, NULL, option_prefer_const16 },

  { "no-workarounds", no_argument, NULL, option_no_workarounds },

  { "no-workaround-close-loop-end", no_argument, NULL,
    option_no_workaround_close_loop_end },
  { "workaround-close-loop-end", no_argument, NULL,
    option_workaround_close_loop_end },
d914 1
a914 8
  { "rename-section", required_argument, NULL, option_rename_section_name },

  { "link-relax", no_argument, NULL, option_link_relax },
  { "no-link-relax", no_argument, NULL, option_no_link_relax },

  { "target-hardware", required_argument, NULL, option_target_hardware },

  { NULL, no_argument, NULL, 0 }
d921 3
a923 1
md_parse_option (int c, char *arg)
d928 7
a934 1
      as_warn (_("--density option is ignored"));
d937 1
a937 1
      as_warn (_("--no-density option is ignored"));
d939 2
a940 2
    case option_link_relax:
      linkrelax = 1;
d942 2
a943 2
    case option_no_link_relax:
      linkrelax = 0;
a944 12
    case option_generics:
      as_warn (_("--generics is deprecated; use --transform instead"));
      return md_parse_option (option_transform, arg);
    case option_no_generics:
      as_warn (_("--no-generics is deprecated; use --no-transform instead"));
      return md_parse_option (option_no_transform, arg);
    case option_relax:
      as_warn (_("--relax is deprecated; use --transform instead"));
      return md_parse_option (option_transform, arg);
    case option_no_relax:
      as_warn (_("--no-relax is deprecated; use --no-transform instead"));
      return md_parse_option (option_no_transform, arg);
a956 12
    case option_absolute_literals:
      if (!absolute_literals_supported)
	{
	  as_fatal (_("--absolute-literals option not supported in this Xtensa configuration"));
	  return 0;
	}
      directive_state[directive_absolute_literals] = TRUE;
      return 1;
    case option_no_absolute_literals:
      directive_state[directive_absolute_literals] = FALSE;
      return 1;

d959 1
d963 1
d967 1
d971 1
d976 1
d980 1
d985 1
d989 1
d994 1
d998 1
d1003 1
d1005 1
d1007 1
d1009 1
d1011 1
d1013 1
a1013 1

d1021 5
a1025 2
    case option_warn_unaligned_targets:
      warn_unaligned_branch_targets = TRUE;
d1028 5
a1032 2
    case option_rename_section_name:
      build_section_rename (arg);
d1035 4
a1038 3
    case 'Q':
      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
         should be emitted or not.  FIXME: Not implemented.  */
d1040 5
a1044 5
      
    case option_prefer_l32r:
      if (prefer_const16)
	as_fatal (_("prefer-l32r conflicts with prefer-const16"));
      prefer_l32r = 1;
d1047 4
a1050 4
    case option_prefer_const16:
      if (prefer_l32r)
	as_fatal (_("prefer-const16 conflicts with prefer-l32r"));
      prefer_const16 = 1;
d1053 2
a1054 26
    case option_target_hardware: 
      {
	int earliest, latest = 0;
	if (*arg == 0 || *arg == '-')
	  as_fatal (_("invalid target hardware version"));

	earliest = strtol (arg, &arg, 0);

	if (*arg == 0)
	  latest = earliest;
	else if (*arg == '-')
	  {
	    if (*++arg == 0)
	      as_fatal (_("invalid target hardware version"));
	    latest = strtol (arg, &arg, 0);
	  }
	if (*arg != 0)
	  as_fatal (_("invalid target hardware version"));

	xtensa_setup_hw_workarounds (earliest, latest);
	return 1;
      }

    case option_transform:
      /* This option has no affect other than to use the defaults,
	 which are already set.  */
d1056 1
d1058 3
a1060 8
    case option_no_transform:
      /* This option turns off all transformations of any kind.
	 However, because we want to preserve the state of other
	 directives, we only change its own field.  Thus, before
	 you perform any transformation, always check if transform
	 is available.  If you use the functions we provide for this
	 purpose, you will be ok.  */
      directive_state[directive_transform] = FALSE;
d1062 1
a1062 1

d1070 2
a1071 1
md_show_usage (FILE *stream)
d1073 19
a1091 84
  fputs ("\n\
Xtensa options:\n\
  --[no-]text-section-literals\n\
                          [Do not] put literals in the text section\n\
  --[no-]absolute-literals\n\
                          [Do not] default to use non-PC-relative literals\n\
  --[no-]target-align     [Do not] try to align branch targets\n\
  --[no-]longcalls        [Do not] emit 32-bit call sequences\n\
  --[no-]transform        [Do not] transform instructions\n\
  --rename-section old=new Rename section 'old' to 'new'\n", stream);
}


/* Functions related to the list of current label symbols.  */

static void
xtensa_add_insn_label (symbolS *sym)
{
  sym_list *l;

  if (!free_insn_labels)
    l = (sym_list *) xmalloc (sizeof (sym_list));
  else
    {
      l = free_insn_labels;
      free_insn_labels = l->next;
    }

  l->sym = sym;
  l->next = insn_labels;
  insn_labels = l;
}


static void
xtensa_clear_insn_labels (void)
{
  sym_list **pl;

  for (pl = &free_insn_labels; *pl != NULL; pl = &(*pl)->next)
    ;
  *pl = insn_labels;
  insn_labels = NULL;
}


/* The "loops_ok" argument is provided to allow ignoring labels that 
   define loop ends.  This fixes a bug where the NOPs to align a 
   loop opcode were included in a previous zero-cost loop:

   loop a0, loopend
     <loop1 body>
   loopend:

   loop a2, loopend2
     <loop2 body>

   would become:

   loop a0, loopend
     <loop1 body>
     nop.n <===== bad!
   loopend:

   loop a2, loopend2
     <loop2 body>

   This argument is used to prevent moving the NOP to before the
   loop-end label, which is what you want in this special case.  */

static void
xtensa_move_labels (fragS *new_frag, valueT new_offset, bfd_boolean loops_ok)
{
  sym_list *lit;

  for (lit = insn_labels; lit; lit = lit->next)
    {
      symbolS *lit_sym = lit->sym;
      if (loops_ok || ! symbol_get_tc (lit_sym)->is_loop_target)
	{
	  S_SET_VALUE (lit_sym, new_offset);
	  symbol_set_frag (lit_sym, new_frag);
	}
    }
d1112 8
a1119 12
  { "align", s_align_bytes, 0 }, /* Defaulting is invalid (0).  */
  { "literal_position", xtensa_literal_position, 0 },
  { "frame", s_ignore, 0 },	/* Formerly used for STABS debugging.  */
  { "long", xtensa_elf_cons, 4 },
  { "word", xtensa_elf_cons, 4 },
  { "short", xtensa_elf_cons, 2 },
  { "begin", xtensa_begin_directive, 0 },
  { "end", xtensa_end_directive, 0 },
  { "loc", xtensa_dwarf2_directive_loc, 0 },
  { "literal", xtensa_literal_pseudo, 0 },
  { "frequency", xtensa_frequency_pseudo, 0 },
  { NULL, 0, 0 },
d1123 9
a1131 2
static bfd_boolean
use_transform (void)
d1133 1
a1133 4
  /* After md_end, you should be checking frag by frag, rather
     than state directives.  */
  assert (!past_xtensa_end);
  return directive_state[directive_transform];
d1137 2
a1138 2
static bfd_boolean
use_longcalls (void)
d1140 1
a1140 4
  /* After md_end, you should be checking frag by frag, rather
     than state directives.  */
  assert (!past_xtensa_end);
  return directive_state[directive_longcalls] && use_transform ();
d1144 2
a1145 2
static bfd_boolean
do_align_targets (void)
d1147 1
a1147 4
  /* After md_end, you should be checking frag by frag, rather
     than state directives.  */
  assert (!past_xtensa_end);
  return align_targets && use_transform ();
d1152 4
a1155 1
directive_push (directiveE directive, bfd_boolean negated, const void *datum)
a1174 1

d1176 6
a1181 5
directive_pop (directiveE *directive,
	       bfd_boolean *negated,
	       const char **file,
	       unsigned int *line,
	       const void **datum)
d1204 1
a1204 1
directive_balance (void)
d1222 2
a1223 1
inside_directive (directiveE dir)
d1235 3
a1237 1
get_directive (directiveE *directive, bfd_boolean *negated)
a1240 1
  char *directive_string;
d1251 1
a1251 18
		"abcdefghijklmnopqrstuvwxyz_-/0123456789.");

  /* This code is a hack to make .begin [no-][generics|relax] exactly
     equivalent to .begin [no-]transform.  We should remove it when
     we stop accepting those options.  */
     
  if (strncmp (input_line_pointer, "generics", strlen ("generics")) == 0)
    {
      as_warn (_("[no-]generics is deprecated; use [no-]transform instead"));
      directive_string = "transform";
    }
  else if (strncmp (input_line_pointer, "relax", strlen ("relax")) == 0)
    {
      as_warn (_("[no-]relax is deprecated; use [no-]transform instead"));
      directive_string = "transform";
    }    
  else
    directive_string = input_line_pointer;
d1255 1
a1255 1
      if (strncmp (directive_string, directive_info[i].name, len) == 0)
d1260 1
a1260 1
	    as_bad (_("directive %s cannot be negated"),
d1272 2
a1273 1
xtensa_begin_directive (int ignore ATTRIBUTE_UNUSED)
d1281 2
a1289 3
  if (cur_vinsn.inside_bundle)
    as_bad (_("directives are not valid inside bundles"));

a1299 1
      as_warn (_(".begin literal is deprecated; use .literal instead"));
a1305 3
      /* Have to flush pending output because a movi relaxed to an l32r 
	 might produce a literal.  */
      md_flush_pending_output ();
d1308 1
a1308 1
      if (generating_literals)
a1343 8
    case directive_schedule:
      md_flush_pending_output ();
      frag_var (rs_fill, 0, 0, frag_now->fr_subtype,
		frag_now->fr_symbol, frag_now->fr_offset, NULL);
      directive_push (directive_schedule, negated, 0);
      xtensa_set_frag_assembly_state (frag_now);
      break;

d1345 1
a1345 6
      as_warn (_(".begin [no-]density is ignored"));
      break;

    case directive_absolute_literals:
      md_flush_pending_output ();
      if (!absolute_literals_supported && !negated)
d1347 1
a1347 1
	  as_warn (_("Xtensa absolute literals option not supported; ignored"));
d1350 1
a1350 3
      xtensa_set_frag_assembly_state (frag_now);
      directive_push (directive, negated, 0);
      break;
a1352 2
      md_flush_pending_output ();
      xtensa_set_frag_assembly_state (frag_now);
d1362 2
a1363 1
xtensa_end_directive (int ignore ATTRIBUTE_UNUSED)
a1369 1
  emit_state **state_ptr;
d1372 1
a1372 2
  if (cur_vinsn.inside_bundle)
    as_bad (_("directives are not valid inside bundles"));
d1375 1
a1375 4

  md_flush_pending_output ();

  switch (end_directive)
a1376 1
    case (directiveE) XTENSA_UNDEFINED:
d1379 1
d1381 3
a1383 2
    case directive_density:
      as_warn (_(".end [no-]density is ignored"));
d1385 1
a1385 13
      break;

    case directive_absolute_literals:
      if (!absolute_literals_supported && !end_negated)
	{
	  as_warn (_("Xtensa absolute literals option not supported; ignored"));
	  demand_empty_rest_of_line ();
	  return;
	}
      break;

    default:
      break;
a1387 1
  state_ptr = &state; /* use state_ptr to avoid type-punning warning */
d1389 1
a1389 1
		 (const void **) state_ptr);
a1405 1
	      xtensa_set_frag_assembly_state (frag_now);
d1415 3
a1429 4
	    case directive_schedule:
	    case directive_freeregs:
	      break;

a1430 1
	      xtensa_set_frag_assembly_state (frag_now);
a1439 22
/* Wrap dwarf2 functions so that we correctly support the .loc directive.  */

static bfd_boolean xtensa_loc_directive_seen = FALSE;

static void
xtensa_dwarf2_directive_loc (int x)
{
  xtensa_loc_directive_seen = TRUE;
  dwarf2_directive_loc (x);
}


static void
xtensa_dwarf2_emit_insn (int size, struct dwarf2_line_info *loc)
{
  if (debug_type != DEBUG_DWARF2 && ! xtensa_loc_directive_seen)
    return;
  xtensa_loc_directive_seen = FALSE;
  dwarf2_gen_line_info (frag_now_fix () - size, loc);
}


d1443 2
a1444 1
xtensa_literal_position (int ignore ATTRIBUTE_UNUSED)
a1445 2
  md_flush_pending_output ();

d1448 2
a1449 1
  xtensa_mark_literal_pool_location ();
d1456 1
a1456 1
/* Support .literal label, expr, ...  */
d1459 2
a1460 1
xtensa_literal_pseudo (int ignored ATTRIBUTE_UNUSED)
d1465 1
a1474 2
  md_flush_pending_output ();

d1487 1
a1487 1
  /* ...but if we aren't using text-section-literals, then we
d1489 1
a1489 1
  if (use_literal_section || directive_state[directive_absolute_literals])
d1492 3
a1494 3
  /* All literals are aligned to four-byte boundaries.  */
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
d1514 11
a1525 1
  input_line_pointer++;		/* skip ',' or ':' */
d1527 1
a1527 1
  xtensa_elf_cons (4);
d1538 15
a1552 5
xtensa_literal_prefix (char const *start, int len)
{
  char *name, *linkonce_suffix;
  char *newname, *newname4;
  size_t linkonce_len;
a1562 1

d1564 2
a1565 1
  newname4 = xmalloc (len + strlen (".lit4") + 1);
d1567 3
a1569 30
  linkonce_len = sizeof (".gnu.linkonce.") - 1;
  if (strncmp (name, ".gnu.linkonce.", linkonce_len) == 0
      && (linkonce_suffix = strchr (name + linkonce_len, '.')) != 0)
    {
      strcpy (newname, ".gnu.linkonce.literal");
      strcpy (newname4, ".gnu.linkonce.lit4");

      strcat (newname, linkonce_suffix);
      strcat (newname4, linkonce_suffix);
    }
  else
    {
      int suffix_pos = len;

      /* If the section name ends with ".text", then replace that suffix
	 instead of appending an additional suffix.  */
      if (len >= 5 && strcmp (name + len - 5, ".text") == 0)
	suffix_pos -= 5;

      strcpy (newname, name);
      strcpy (newname4, name);

      strcpy (newname + suffix_pos, ".literal");
      strcpy (newname4 + suffix_pos, ".lit4");
    }

  /* Note that cache_literal_section does not create a segment if
     it already exists.  */
  default_lit_sections.lit_seg = NULL;
  default_lit_sections.lit4_seg = NULL;
d1573 2
a1574 2
  default_lit_sections.lit_seg_name = tc_canonicalize_symbol_name (newname);
  default_lit_sections.lit4_seg_name = tc_canonicalize_symbol_name (newname4);
a1576 31
}


/* Support ".frequency branch_target_frequency fall_through_frequency".  */

static void
xtensa_frequency_pseudo (int ignored ATTRIBUTE_UNUSED)
{
  float fall_through_f, target_f;

  fall_through_f = (float) strtod (input_line_pointer, &input_line_pointer);
  if (fall_through_f < 0)
    {
      as_bad (_("fall through frequency must be greater than 0"));
      ignore_rest_of_line ();
      return;
    }

  target_f = (float) strtod (input_line_pointer, &input_line_pointer);
  if (target_f < 0)
    {
      as_bad (_("branch target frequency must be greater than 0"));
      ignore_rest_of_line ();
      return;
    }

  set_subseg_freq (now_seg, now_subseg, target_f + fall_through_f, target_f);

  demand_empty_rest_of_line ();
}

d1578 3
a1580 57
/* Like normal .long/.short/.word, except support @@plt, etc.
   Clobbers input_line_pointer, checks end-of-line.  */

static void
xtensa_elf_cons (int nbytes)
{
  expressionS exp;
  bfd_reloc_code_real_type reloc;

  md_flush_pending_output ();

  if (cur_vinsn.inside_bundle)
    as_bad (_("directives are not valid inside bundles"));

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      expression (&exp);
      if (exp.X_op == O_symbol
	  && *input_line_pointer == '@@'
	  && ((reloc = xtensa_elf_suffix (&input_line_pointer, &exp))
	      != BFD_RELOC_NONE))
	{
	  reloc_howto_type *reloc_howto =
	    bfd_reloc_type_lookup (stdoutput, reloc);

	  if (reloc == BFD_RELOC_UNUSED || !reloc_howto)
	    as_bad (_("unsupported relocation"));
	  else if ((reloc >= BFD_RELOC_XTENSA_SLOT0_OP
		    && reloc <= BFD_RELOC_XTENSA_SLOT14_OP)
		   || (reloc >= BFD_RELOC_XTENSA_SLOT0_ALT
		       && reloc <= BFD_RELOC_XTENSA_SLOT14_ALT))
	    as_bad (_("opcode-specific %s relocation used outside "
		      "an instruction"), reloc_howto->name);
	  else if (nbytes != (int) bfd_get_reloc_size (reloc_howto))
	    as_bad (_("%s relocations do not fit in %d bytes"),
		    reloc_howto->name, nbytes);
	  else
	    {
	      char *p = frag_more ((int) nbytes);
	      xtensa_set_frag_assembly_state (frag_now);
	      fix_new_exp (frag_now, p - frag_now->fr_literal,
			   nbytes, &exp, 0, reloc);
	    }
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */
  demand_empty_rest_of_line ();
a1585 74
/* Parse @@plt, etc. and return the desired relocation.  */
static bfd_reloc_code_real_type
xtensa_elf_suffix (char **str_p, expressionS *exp_p)
{
  struct map_bfd
  {
    char *string;
    int length;
    bfd_reloc_code_real_type reloc;
  };

  char ident[20];
  char *str = *str_p;
  char *str2;
  int ch;
  int len;
  struct map_bfd *ptr;

#define MAP(str,reloc) { str, sizeof (str) - 1, reloc }

  static struct map_bfd mapping[] =
  {
    MAP ("l",		BFD_RELOC_LO16),
    MAP ("h",		BFD_RELOC_HI16),
    MAP ("plt",		BFD_RELOC_XTENSA_PLT),
    { (char *) 0, 0,	BFD_RELOC_UNUSED }
  };

  if (*str++ != '@@')
    return BFD_RELOC_NONE;

  for (ch = *str, str2 = ident;
       (str2 < ident + sizeof (ident) - 1
	&& (ISALNUM (ch) || ch == '@@'));
       ch = *++str)
    {
      *str2++ = (ISLOWER (ch)) ? ch : TOLOWER (ch);
    }

  *str2 = '\0';
  len = str2 - ident;

  ch = ident[0];
  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
    if (ch == ptr->string[0]
	&& len == ptr->length
	&& memcmp (ident, ptr->string, ptr->length) == 0)
      {
	/* Now check for "identifier@@suffix+constant".  */
	if (*str == '-' || *str == '+')
	  {
	    char *orig_line = input_line_pointer;
	    expressionS new_exp;

	    input_line_pointer = str;
	    expression (&new_exp);
	    if (new_exp.X_op == O_constant)
	      {
		exp_p->X_add_number += new_exp.X_add_number;
		str = input_line_pointer;
	      }

	    if (&input_line_pointer != str_p)
	      input_line_pointer = orig_line;
	  }

	*str_p = str;
	return ptr->reloc;
      }

  return BFD_RELOC_UNUSED;
}


d1587 2
a1588 1
expression_end (const char *name)
a1593 1
	case '}':
a1596 1
	case ':':
d1612 2
a1613 1
tc_get_register (const char *prefix)
d1667 3
d1671 3
a1673 1
expression_maybe_register (xtensa_opcode opc, int opnd, expressionS *tok)
d1675 1
a1675 1
  xtensa_isa isa = xtensa_default_isa;
d1677 2
a1678 2
  /* Check if this is an immediate operand.  */
  if (xtensa_operand_is_register (isa, opc, opnd) == 0)
a1679 1
      bfd_reloc_code_real_type reloc;
d1681 1
a1681 2
      if (t == absolute_section
	  && xtensa_operand_is_PCrelative (isa, opc, opnd) == 1)
d1687 5
a1691 4

      if ((tok->X_op == O_constant || tok->X_op == O_symbol)
	  && (reloc = xtensa_elf_suffix (&input_line_pointer, tok))
	  && (reloc != BFD_RELOC_NONE))
d1693 2
a1694 25
	  switch (reloc)
	    {
	      default:
	      case BFD_RELOC_UNUSED:
		as_bad (_("unsupported relocation"));
	        break;

	      case BFD_RELOC_XTENSA_PLT:
		tok->X_op = O_pltrel;
		break;

	      case BFD_RELOC_LO16:
		if (tok->X_op == O_constant)
		  tok->X_add_number &= 0xffff;
		else
		  tok->X_op = O_lo16;
		break;

	      case BFD_RELOC_HI16:
		if (tok->X_op == O_constant)
		  tok->X_add_number = ((unsigned) tok->X_add_number) >> 16;
		else
		  tok->X_op = O_hi16;
		break;
	    }
d1699 1
a1699 2
      xtensa_regfile opnd_rf = xtensa_operand_regfile (isa, opc, opnd);
      unsigned reg = tc_get_register (xtensa_regfile_shortname (isa, opnd_rf));
d1704 2
a1705 1
	  if (xtensa_operand_encode (isa, opc, opnd, &buf))
d1719 3
a1721 1
tokenize_arguments (char **args, char *str)
a1725 1
  bfd_boolean saw_colon = FALSE;
d1729 2
a1730 2

  /* Save and restore input_line_pointer around this function.  */
a1739 1
	case '}':
a1741 7
	case ':':
	  input_line_pointer++;
	  if (saw_comma || saw_colon || !saw_arg)
	    goto err;
	  saw_colon = TRUE;
	  break;

d1744 1
a1744 1
	  if (saw_comma || saw_colon || !saw_arg)
d1750 1
a1750 1
	  if (!saw_comma && !saw_colon && saw_arg)
d1756 1
a1756 1

d1758 1
a1758 1
	  arg = (char *) xmalloc ((saw_colon ? 1 : 0) + arg_len + 1);
a1760 2
	  if (saw_colon)
	    *arg++ = ':';
d1763 1
a1763 1

a1766 1
	  saw_colon = FALSE;
d1773 1
a1773 1
  if (saw_comma || saw_colon)
a1778 8
  if (saw_comma)
    as_bad (_("extra comma"));
  else if (saw_colon)
    as_bad (_("extra colon"));
  else if (!saw_arg)
    as_bad (_("missing argument"));  
  else
    as_bad (_("missing comma or colon"));
d1784 1
a1784 1
/* Parse the arguments to an opcode.  Return TRUE on error.  */
d1787 4
a1790 1
parse_arguments (TInsn *insn, int num_args, char **arg_strings)
d1792 1
a1792 1
  expressionS *tok, *last_tok;
d1795 2
a1796 2
  xtensa_isa isa = xtensa_default_isa;
  int n, num_regs = 0;
d1798 2
a1799 2
  int opnd_cnt, last_opnd_cnt;
  unsigned int next_reg = 0;
d1805 1
a1805 1
    opcode_operand_count = xtensa_opcode_num_operands (isa, opcode);
a1806 1
  tok = insn->tok;
d1810 1
a1810 12
  old_input_line_pointer = input_line_pointer;

  last_tok = 0;
  last_opnd_cnt = -1;
  opnd_cnt = 0;

  /* Skip invisible operands.  */
  while (xtensa_operand_is_visible (isa, opcode, opnd_cnt) == 0)
    {
      opnd_cnt += 1;
      tok++;
    }
d1813 1
a1813 1
    {
a1814 47
      if (*input_line_pointer == ':')
	{
	  xtensa_regfile opnd_rf;
	  input_line_pointer++;
	  if (num_regs == 0)
	    goto err;
	  assert (opnd_cnt > 0);
	  num_regs--;
	  opnd_rf = xtensa_operand_regfile (isa, opcode, last_opnd_cnt);
	  if (next_reg
	      != tc_get_register (xtensa_regfile_shortname (isa, opnd_rf)))
	    as_warn (_("incorrect register number, ignoring"));
	  next_reg++;
	}
      else
	{
	  if (opnd_cnt >= opcode_operand_count)
	    {
	      as_warn (_("too many arguments"));
	      goto err;
	    }
	  assert (opnd_cnt < MAX_INSN_ARGS);

	  expression_maybe_register (opcode, opnd_cnt, tok);
	  next_reg = tok->X_add_number + 1;

	  if (tok->X_op == O_illegal || tok->X_op == O_absent)
	    goto err;
	  if (xtensa_operand_is_register (isa, opcode, opnd_cnt) == 1)
	    {
	      num_regs = xtensa_operand_num_regs (isa, opcode, opnd_cnt) - 1;
	      /* minus 1 because we are seeing one right now */
	    }
	  else
	    num_regs = 0;

	  last_tok = tok;
	  last_opnd_cnt = opnd_cnt;

	  do
	    {
	      opnd_cnt += 1;
	      tok++;
	    }
	  while (xtensa_operand_is_visible (isa, opcode, opnd_cnt) == 0);
	}
    }
d1816 15
a1830 2
  if (num_regs > 0 && ((int) next_reg != last_tok->X_add_number + 1))
    goto err;
d1836 1
a1836 1
  input_line_pointer = old_input_line_pointer;
a1840 68
static int
get_invisible_operands (TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_format fmt;
  xtensa_opcode opc = insn->opcode;
  int slot, opnd, fmt_found;
  unsigned val;

  if (!slotbuf)
    slotbuf = xtensa_insnbuf_alloc (isa);

  /* Find format/slot where this can be encoded.  */
  fmt_found = 0;
  slot = 0;
  for (fmt = 0; fmt < xtensa_isa_num_formats (isa); fmt++)
    {
      for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
	{
	  if (xtensa_opcode_encode (isa, fmt, slot, slotbuf, opc) == 0)
	    {
	      fmt_found = 1;
	      break;
	    }
	}
      if (fmt_found) break;
    }

  if (!fmt_found)
    {
      as_bad (_("cannot encode opcode \"%s\""), xtensa_opcode_name (isa, opc));
      return -1;
    }

  /* First encode all the visible operands
     (to deal with shared field operands).  */
  for (opnd = 0; opnd < insn->ntok; opnd++)
    {
      if (xtensa_operand_is_visible (isa, opc, opnd) == 1
	  && (insn->tok[opnd].X_op == O_register
	      || insn->tok[opnd].X_op == O_constant))
	{
	  val = insn->tok[opnd].X_add_number;
	  xtensa_operand_encode (isa, opc, opnd, &val);
	  xtensa_operand_set_field (isa, opc, opnd, fmt, slot, slotbuf, val);
	}
    }

  /* Then pull out the values for the invisible ones.  */
  for (opnd = 0; opnd < insn->ntok; opnd++)
    {
      if (xtensa_operand_is_visible (isa, opc, opnd) == 0)
	{
	  xtensa_operand_get_field (isa, opc, opnd, fmt, slot, slotbuf, &val);
	  xtensa_operand_decode (isa, opc, opnd, &val);
	  insn->tok[opnd].X_add_number = val;
	  if (xtensa_operand_is_register (isa, opc, opnd) == 1)
	    insn->tok[opnd].X_op = O_register;
	  else
	    insn->tok[opnd].X_op = O_constant;
	}
    }

  return 0;
}


d1842 2
a1843 1
xg_reverse_shift_count (char **cnt_argp)
d1861 3
a1863 1
xg_arg_is_constant (char *arg, offsetT *valp)
d1883 3
a1885 1
xg_replace_opname (char **popname, char *newop)
d1894 5
a1898 4
xg_check_num_args (int *pnum_args,
		   int expected_num,
		   char *opname,
		   char **arg_strings)
d1902 1
a1902 1
  if (num_args < expected_num)
a1925 3
/* If the register is not specified as part of the opcode,
   then get it from the operand and move it to the opcode.  */

d1927 4
a1930 1
xg_translate_sysreg_op (char **popname, int *pnum_args, char **arg_strings)
a1931 2
  xtensa_isa isa = xtensa_default_isa;
  xtensa_sysreg sr;
d1933 1
a1933 2
  const char *sr_name;
  int is_user, is_write;
a1941 2
  is_user = (opname[1] == 'u');
  is_write = (opname[0] == 'w');
d1943 6
a1948 1
  /* Opname == [rw]ur or [rwx]sr... */
d1950 2
a1951 2
  if (xg_check_num_args (pnum_args, 2, opname, arg_strings))
    return -1;
a1952 11
  /* Check if the argument is a symbolic register name.  */
  sr = xtensa_sysreg_lookup_name (isa, arg_strings[1]);
  /* Handle WSR to "INTSET" as a special case.  */
  if (sr == XTENSA_UNDEFINED && is_write && !is_user
      && !strcasecmp (arg_strings[1], "intset"))
    sr = xtensa_sysreg_lookup_name (isa, "interrupt");
  if (sr == XTENSA_UNDEFINED
      || (xtensa_sysreg_is_user (isa, sr) == 1) != is_user)
    {
      /* Maybe it's a register number.... */
      offsetT val;
d1955 1
a1955 2
	  as_bad (_("invalid register '%s' for '%s' instruction"),
		  arg_strings[1], opname);
d1958 1
a1958 2
      sr = xtensa_sysreg_lookup (isa, val, is_user);
      if (sr == XTENSA_UNDEFINED)
d1960 1
a1960 1
	  as_bad (_("invalid register number (%ld) for '%s' instruction"),
a1963 81
    }

  /* Remove the last argument, which is now part of the opcode.  */
  free (arg_strings[1]);
  arg_strings[1] = 0;
  *pnum_args = 1;

  /* Translate the opcode.  */
  sr_name = xtensa_sysreg_name (isa, sr);
  /* Another special case for "WSR.INTSET"....  */
  if (is_write && !is_user && !strcasecmp ("interrupt", sr_name))
    sr_name = "intset";
  new_opname = (char *) xmalloc (strlen (sr_name) + 6);
  sprintf (new_opname, "%s%s.%s", (has_underbar ? "_" : ""),
	   *popname, sr_name);
  free (*popname);
  *popname = new_opname;

  return 0;
}


static int
xtensa_translate_old_userreg_ops (char **popname)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_sysreg sr;
  char *opname, *new_opname;
  const char *sr_name;
  bfd_boolean has_underbar = FALSE;

  opname = *popname;
  if (opname[0] == '_')
    {
      has_underbar = TRUE;
      opname += 1;
    }

  sr = xtensa_sysreg_lookup_name (isa, opname + 1);
  if (sr != XTENSA_UNDEFINED)
    {
      /* The new default name ("nnn") is different from the old default
	 name ("URnnn").  The old default is handled below, and we don't
	 want to recognize [RW]nnn, so do nothing if the name is the (new)
	 default.  */
      static char namebuf[10];
      sprintf (namebuf, "%d", xtensa_sysreg_number (isa, sr));
      if (strcmp (namebuf, opname + 1) == 0)
	return 0;
    }
  else
    {
      offsetT val;
      char *end;

      /* Only continue if the reg name is "URnnn".  */
      if (opname[1] != 'u' || opname[2] != 'r')
	return 0;
      val = strtoul (opname + 3, &end, 10);
      if (*end != '\0')
	return 0;

      sr = xtensa_sysreg_lookup (isa, val, 1);
      if (sr == XTENSA_UNDEFINED)
	{
	  as_bad (_("invalid register number (%ld) for '%s'"),
		  val, opname);
	  return -1;
	}
    }

  /* Translate the opcode.  */
  sr_name = xtensa_sysreg_name (isa, sr);
  new_opname = (char *) xmalloc (strlen (sr_name) + 6);
  sprintf (new_opname, "%s%cur.%s", (has_underbar ? "_" : ""),
	   opname[0], sr_name);
  free (*popname);
  *popname = new_opname;

  return 0;
}
d1965 4
d1970 6
a1975 25
static int
xtensa_translate_zero_immed (char *old_op,
			     char *new_op,
			     char **popname,
			     int *pnum_args,
			     char **arg_strings)
{
  char *opname;
  offsetT val;

  opname = *popname;
  assert (opname[0] != '_');

  if (strcmp (opname, old_op) != 0)
    return 0;

  if (xg_check_num_args (pnum_args, 3, opname, arg_strings))
    return -1;
  if (xg_arg_is_constant (arg_strings[1], &val) && val == 0)
    {
      xg_replace_opname (popname, new_op);
      free (arg_strings[1]);
      arg_strings[1] = arg_strings[2];
      arg_strings[2] = 0;
      *pnum_args = 2;
d1986 4
a1989 1
xg_translate_idioms (char **popname, int *pnum_args, char **arg_strings)
a1993 3
  if (cur_vinsn.inside_bundle)
    return 0;

d2002 1
a2002 1
      if (use_transform () && !has_underbar && density_supported)
d2036 1
a2036 2
  if (xtensa_nop_opcode == XTENSA_UNDEFINED
      && strcmp (opname, "nop") == 0)
d2038 1
a2038 1
      if (use_transform () && !has_underbar && density_supported)
d2056 3
a2058 6
  /* Recognize [RW]UR and [RWX]SR.  */
  if ((((opname[0] == 'r' || opname[0] == 'w')
	&& (opname[1] == 'u' || opname[1] == 's'))
       || (opname[0] == 'x' && opname[1] == 's'))
      && opname[2] == 'r'
      && opname[3] == '\0')
a2060 5
  /* Backward compatibility for RUR and WUR: Recognize [RW]UR<nnn> and
     [RW]<name> if <name> is the non-default name of a user register.  */
  if ((opname[0] == 'r' || opname[0] == 'w')
      && xtensa_opcode_lookup (xtensa_default_isa, opname) == XTENSA_UNDEFINED)
    return xtensa_translate_old_userreg_ops (popname);
d2062 29
a2090 3
  /* Relax branches that don't allow comparisons against an immediate value
     of zero to the corresponding branches with implicit zero immediates.  */
  if (!has_underbar && use_transform ())
d2092 11
a2102 3
      if (xtensa_translate_zero_immed ("bnei", "bnez", popname,
				       pnum_args, arg_strings))
	return -1;
d2104 2
a2105 3
      if (xtensa_translate_zero_immed ("beqi", "beqz", popname,
				       pnum_args, arg_strings))
	return -1;
d2107 9
a2115 3
      if (xtensa_translate_zero_immed ("bgei", "bgez", popname,
				       pnum_args, arg_strings))
	return -1;
d2117 13
a2129 3
      if (xtensa_translate_zero_immed ("blti", "bltz", popname,
				       pnum_args, arg_strings))
	return -1;
d2138 43
d2183 1
a2183 1
   instruction may be symbolic.  If there is a PC-relative operand,
d2185 2
a2186 2
   last immediate operand, and if there are none of those, we fail and
   return -1.  */
d2188 3
a2190 2
static int
get_relaxable_immed (xtensa_opcode opcode)
d2194 1
d2199 1
a2199 1
  noperands = xtensa_opcode_num_operands (xtensa_default_isa, opcode);
d2202 2
a2203 3
      if (xtensa_operand_is_visible (xtensa_default_isa, opcode, opi) == 0)
	continue;
      if (xtensa_operand_is_PCrelative (xtensa_default_isa, opcode, opi) == 1)
d2205 1
a2205 2
      if (last_immed == -1
	  && xtensa_operand_is_register (xtensa_default_isa, opcode, opi) == 0)
d2212 3
a2214 2
static xtensa_opcode
get_opcode_from_buf (const char *buf, int slot)
d2217 1
a2217 1
  static xtensa_insnbuf slotbuf = NULL;
a2218 2
  xtensa_format fmt;

d2220 1
a2220 12
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  xtensa_insnbuf_from_chars (isa, insnbuf, buf, 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;

  if (slot >= xtensa_format_num_slots (isa, fmt))
    return XTENSA_UNDEFINED;
d2222 3
a2224 2
  xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
  return xtensa_opcode_decode (isa, fmt, slot, slotbuf);
d2228 3
a2230 6
#ifdef TENSILICA_DEBUG

/* For debugging, print out the mapping of opcode numbers to opcodes.  */

static void
xtensa_print_insn_table (void)
d2232 2
a2233 3
  int num_opcodes, num_operands;
  xtensa_opcode opcode;
  xtensa_isa isa = xtensa_default_isa;
d2235 4
a2238 23
  num_opcodes = xtensa_isa_num_opcodes (xtensa_default_isa);
  for (opcode = 0; opcode < num_opcodes; opcode++)
    {
      int opn;
      fprintf (stderr, "%d: %s: ", opcode, xtensa_opcode_name (isa, opcode));
      num_operands = xtensa_opcode_num_operands (isa, opcode);
      for (opn = 0; opn < num_operands; opn++)
	{
	  if (xtensa_operand_is_visible (isa, opcode, opn) == 0)
	    continue;
	  if (xtensa_operand_is_register (isa, opcode, opn) == 1)
	    {
	      xtensa_regfile opnd_rf =
		xtensa_operand_regfile (isa, opcode, opn);
	      fprintf (stderr, "%s ", xtensa_regfile_shortname (isa, opnd_rf));
	    }
	  else if (xtensa_operand_is_PCrelative (isa, opcode, opn) == 1)
	    fputs ("[lLr] ", stderr);
	  else
	    fputs ("i ", stderr);
	}
      fprintf (stderr, "\n");
    }
d2242 3
a2244 2
static void
print_vliw_insn (xtensa_insnbuf vbuf)
d2246 2
a2247 4
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format f = xtensa_format_decode (isa, vbuf);
  xtensa_insnbuf sbuf = xtensa_insnbuf_alloc (isa);
  int op;
d2249 2
a2250 7
  fprintf (stderr, "format = %d\n", f);

  for (op = 0; op < xtensa_format_num_slots (isa, f); op++)
    {
      xtensa_opcode opcode;
      const char *opname;
      int operands;
d2252 4
a2255 20
      xtensa_format_get_slot (isa, f, op, vbuf, sbuf);
      opcode = xtensa_opcode_decode (isa, f, op, sbuf);
      opname = xtensa_opcode_name (isa, opcode);

      fprintf (stderr, "op in slot %i is %s;\n", op, opname);
      fprintf (stderr, "   operands = ");
      for (operands = 0;
	   operands < xtensa_opcode_num_operands (isa, opcode);
	   operands++)
	{
	  unsigned int val;
	  if (xtensa_operand_is_visible (isa, opcode, operands) == 0)
	    continue;
	  xtensa_operand_get_field (isa, opcode, operands, f, op, sbuf, &val);
	  xtensa_operand_decode (isa, opcode, operands, &val);
	  fprintf (stderr, "%d ", val);
	}
      fprintf (stderr, "\n");
    }
  xtensa_insnbuf_free (isa, sbuf);
a2257 1
#endif /* TENSILICA_DEBUG */
d2259 3
d2264 2
a2265 1
is_direct_call_opcode (xtensa_opcode opcode)
d2267 1
a2267 4
  xtensa_isa isa = xtensa_default_isa;
  int n, num_operands;

  if (xtensa_opcode_is_call (isa, opcode) == 0)
d2270 1
a2270 8
  num_operands = xtensa_opcode_num_operands (isa, opcode);
  for (n = 0; n < num_operands; n++)
    {
      if (xtensa_operand_is_register (isa, opcode, n) == 0
	  && xtensa_operand_is_PCrelative (isa, opcode, n) == 1)
	return TRUE;
    }
  return FALSE;
d2274 3
a2276 2
/* Convert from BFD relocation type code to slot and operand number.
   Returns non-zero on failure.  */
d2278 3
a2280 2
static int
decode_reloc (bfd_reloc_code_real_type reloc, int *slot, bfd_boolean *is_alt)
d2282 2
a2283 14
  if (reloc >= BFD_RELOC_XTENSA_SLOT0_OP
      && reloc <= BFD_RELOC_XTENSA_SLOT14_OP)
    {
      *slot = reloc - BFD_RELOC_XTENSA_SLOT0_OP;
      *is_alt = FALSE;
    }
  else if (reloc >= BFD_RELOC_XTENSA_SLOT0_ALT
      && reloc <= BFD_RELOC_XTENSA_SLOT14_ALT)
    {
      *slot = reloc - BFD_RELOC_XTENSA_SLOT0_ALT;
      *is_alt = TRUE;
    }
  else
    return -1;
d2285 3
a2287 1
  return 0;
d2291 6
a2296 3
/* Convert from slot number to BFD relocation type code for the
   standard PC-relative relocations.  Return BFD_RELOC_NONE on
   failure.  */
d2298 7
a2304 2
static bfd_reloc_code_real_type
encode_reloc (int slot)
d2306 2
a2307 2
  if (slot < 0 || slot > 14)
    return BFD_RELOC_NONE;
d2309 1
a2309 1
  return BFD_RELOC_XTENSA_SLOT0_OP + slot;
d2313 2
a2314 2
/* Convert from slot numbers to BFD relocation type code for the
   "alternate" relocations.  Return BFD_RELOC_NONE on failure.  */
d2316 3
a2318 2
static bfd_reloc_code_real_type
encode_alt_reloc (int slot)
d2320 2
a2321 2
  if (slot < 0 || slot > 14)
    return BFD_RELOC_NONE;
d2323 1
a2323 1
  return BFD_RELOC_XTENSA_SLOT0_ALT + slot;
d2327 5
a2331 9
static void
xtensa_insnbuf_set_operand (xtensa_insnbuf slotbuf,
			    xtensa_format fmt,
			    int slot,
			    xtensa_opcode opcode,
			    int operand,
			    uint32 value,
			    const char *file,
			    unsigned int line)
d2333 5
a2337 1
  uint32 valbuf = value;
d2339 2
a2340 1
  if (xtensa_operand_encode (xtensa_default_isa, opcode, operand, &valbuf))
d2342 3
a2344 10
      if (xtensa_operand_is_PCrelative (xtensa_default_isa, opcode, operand)
	  == 1)
	as_bad_where ((char *) file, line,
		      _("operand %u is out of range for '%s'"), value,
		      xtensa_opcode_name (xtensa_default_isa, opcode));
      else
	as_bad_where ((char *) file, line,
		      _("operand %u is invalid for '%s'"), value,
		      xtensa_opcode_name (xtensa_default_isa, opcode));
      return;
d2346 1
a2346 3

  xtensa_operand_set_field (xtensa_default_isa, opcode, operand, fmt, slot,
			    slotbuf, valbuf);
d2350 3
a2352 13
static uint32
xtensa_insnbuf_get_operand (xtensa_insnbuf slotbuf,
			    xtensa_format fmt,
			    int slot,
			    xtensa_opcode opcode,
			    int opnum)
{
  uint32 val = 0;
  (void) xtensa_operand_get_field (xtensa_default_isa, opcode, opnum,
				   fmt, slot, slotbuf, &val);
  (void) xtensa_operand_decode (xtensa_default_isa, opcode, opnum, &val);
  return val;
}
d2354 5
a2358 2

/* Checks for rules from xtensa-relax tables.  */
d2360 2
a2361 5
/* The routine xg_instruction_matches_option_term must return TRUE
   when a given option term is true.  The meaning of all of the option
   terms is given interpretation by this function.  This is needed when
   an option depends on the state of a directive, but there are no such
   options in use right now.  */
d2363 2
a2364 17
static bfd_boolean
xg_instruction_matches_option_term (TInsn *insn ATTRIBUTE_UNUSED,
				    const ReqOrOption *option)
{
  if (strcmp (option->option_name, "realnop") == 0
      || strncmp (option->option_name, "IsaUse", 6) == 0)
    {
      /* These conditions were evaluated statically when building the
	 relaxation table.  There's no need to reevaluate them now.  */
      return TRUE;
    }
  else
    {
      as_fatal (_("internal error: unknown option name '%s'"),
		option->option_name);
    }
}
d2366 2
d2369 2
a2370 7
static bfd_boolean
xg_instruction_matches_or_options (TInsn *insn,
				   const ReqOrOptionList *or_option)
{
  const ReqOrOption *option;
  /* Must match each of the AND terms.  */
  for (option = or_option; option != NULL; option = option->next)
d2372 4
a2375 1
      if (xg_instruction_matches_option_term (insn, option))
d2382 6
a2387 2
static bfd_boolean
xg_instruction_matches_options (TInsn *insn, const ReqOptionList *options)
d2389 10
a2398 10
  const ReqOption *req_options;
  /* Must match each of the AND terms.  */
  for (req_options = options;
       req_options != NULL;
       req_options = req_options->next)
    {
      /* Must match one of the OR clauses.  */
      if (!xg_instruction_matches_or_options (insn,
					      req_options->or_option_terms))
	return FALSE;
d2400 1
a2400 1
  return TRUE;
d2404 2
a2405 1
/* Return the transition rule that matches or NULL if none matches.  */
d2407 3
a2409 2
static bfd_boolean
xg_instruction_matches_rule (TInsn *insn, TransitionRule *rule)
d2411 1
a2411 8
  PreconditionList *condition_l;

  if (rule->opcode != insn->opcode)
    return FALSE;

  for (condition_l = rule->conditions;
       condition_l != NULL;
       condition_l = condition_l->next)
d2413 11
a2423 3
      expressionS *exp1;
      expressionS *exp2;
      Precondition *cond = condition_l->precond;
a2424 41
      switch (cond->typ)
	{
	case OP_CONSTANT:
	  /* The expression must be the constant.  */
	  assert (cond->op_num < insn->ntok);
	  exp1 = &insn->tok[cond->op_num];
	  if (expr_is_const (exp1))
	    {
	      switch (cond->cmp)
		{
		case OP_EQUAL:
		  if (get_expr_const (exp1) != cond->op_data)
		    return FALSE;
		  break;
		case OP_NOTEQUAL:
		  if (get_expr_const (exp1) == cond->op_data)
		    return FALSE;
		  break;
		default:
		  return FALSE;
		}
	    }
	  else if (expr_is_register (exp1))
	    {
	      switch (cond->cmp)
		{
		case OP_EQUAL:
		  if (get_expr_register (exp1) != cond->op_data)
		    return FALSE;
		  break;
		case OP_NOTEQUAL:
		  if (get_expr_register (exp1) == cond->op_data)
		    return FALSE;
		  break;
		default:
		  return FALSE;
		}
	    }
	  else
	    return FALSE;
	  break;
d2426 11
a2436 5
	case OP_OPERAND:
	  assert (cond->op_num < insn->ntok);
	  assert (cond->op_data < insn->ntok);
	  exp1 = &insn->tok[cond->op_num];
	  exp2 = &insn->tok[cond->op_data];
d2438 1
a2438 12
	  switch (cond->cmp)
	    {
	    case OP_EQUAL:
	      if (!expr_is_equal (exp1, exp2))
		return FALSE;
	      break;
	    case OP_NOTEQUAL:
	      if (expr_is_equal (exp1, exp2))
		return FALSE;
	      break;
	    }
	  break;
d2440 31
a2470 5
	case OP_LITERAL:
	case OP_LABEL:
	default:
	  return FALSE;
	}
a2471 2
  if (!xg_instruction_matches_options (insn, rule->options))
    return FALSE;
d2473 1
a2473 1
  return TRUE;
d2477 5
a2481 2
static int
transition_rule_cmp (const TransitionRule *a, const TransitionRule *b)
d2483 3
a2485 2
  bfd_boolean a_greater = FALSE;
  bfd_boolean b_greater = FALSE;
a2486 2
  ReqOptionList *l_a = a->options;
  ReqOptionList *l_b = b->options;
d2488 12
a2499 55
  /* We only care if they both are the same except for
     a const16 vs. an l32r.  */

  while (l_a && l_b && ((l_a->next == NULL) == (l_b->next == NULL)))
    {
      ReqOrOptionList *l_or_a = l_a->or_option_terms;
      ReqOrOptionList *l_or_b = l_b->or_option_terms;
      while (l_or_a && l_or_b && ((l_a->next == NULL) == (l_b->next == NULL)))
	{
	  if (l_or_a->is_true != l_or_b->is_true)
	    return 0;
	  if (strcmp (l_or_a->option_name, l_or_b->option_name) != 0)
	    {
	      /* This is the case we care about.  */
	      if (strcmp (l_or_a->option_name, "IsaUseConst16") == 0
		  && strcmp (l_or_b->option_name, "IsaUseL32R") == 0)
		{
		  if (prefer_const16)
		    a_greater = TRUE;
		  else
		    b_greater = TRUE;
		}
	      else if (strcmp (l_or_a->option_name, "IsaUseL32R") == 0
		       && strcmp (l_or_b->option_name, "IsaUseConst16") == 0)
		{
		  if (prefer_const16)
		    b_greater = TRUE;
		  else
		    a_greater = TRUE;
		}
	      else
		return 0;
	    }
	  l_or_a = l_or_a->next;
	  l_or_b = l_or_b->next;
	}
      if (l_or_a || l_or_b)
	return 0;

      l_a = l_a->next;
      l_b = l_b->next;
    }
  if (l_a || l_b)
    return 0;

  /* Incomparable if the substitution was used differently in two cases.  */
  if (a_greater && b_greater)
    return 0;

  if (b_greater)
    return 1;
  if (a_greater)
    return -1;

  return 0;
d2503 3
a2505 2
static TransitionRule *
xg_instruction_match (TInsn *insn)
d2507 3
a2509 3
  TransitionTable *table = xg_build_simplify_table (&transition_rule_cmp);
  TransitionList *l;
  assert (insn->opcode < table->num_opcodes);
d2511 1
a2511 2
  /* Walk through all of the possible transitions.  */
  for (l = table->table[insn->opcode]; l != NULL; l = l->next)
d2513 4
a2516 3
      TransitionRule *rule = l->rule;
      if (xg_instruction_matches_rule (insn, rule))
	return rule;
d2518 1
a2518 1
  return NULL;
d2525 2
a2526 1
is_unique_insn_expansion (TransitionRule *r)
d2537 2
a2538 1
xg_get_build_instr_size (BuildInstr *insn)
d2540 2
a2541 2
  assert (insn->typ == INSTR_INSTR);
  return xg_get_single_size (insn->opcode);
d2545 3
a2547 2
static bfd_boolean
xg_is_narrow_insn (TInsn *insn)
d2549 10
a2558 1
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
d2574 1
a2574 1
	  if (xg_get_single_size (insn->opcode)
d2587 3
a2589 2
static bfd_boolean
xg_is_single_relaxable_insn (TInsn *insn)
d2591 1
a2591 1
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
a2603 1
	  /* It only generates one instruction... */
d2606 1
a2606 1
	  if (xg_get_single_size (insn->opcode)
d2619 35
d2656 3
a2658 2
static int
xg_get_max_insn_widen_size (xtensa_opcode opcode)
d2660 1
a2660 1
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
d2662 1
a2662 1
  int max_size = xg_get_single_size (opcode);
d2686 3
a2688 1
		this_size += xg_get_single_size (build_list->opcode);
d2705 3
a2707 2
static int
xg_get_max_insn_widen_literal_size (xtensa_opcode opcode)
d2709 1
a2709 1
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
d2735 1
a2735 1
		/* Hard-coded 4-byte literal.  */
d2751 4
a2754 2
static bfd_boolean
xg_is_relaxable_insn (TInsn *insn, int lateral_steps)
d2757 1
a2757 1
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
d2779 1
a2779 1
get_special_literal_symbol (void)
d2790 1
a2790 1
get_special_label_symbol (void)
d2800 1
a2800 20
static bfd_boolean
xg_valid_literal_expression (const expressionS *exp)
{
  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_big:
    case O_uminus:
    case O_subtract:
    case O_pltrel:
      return TRUE;
    default:
      return FALSE;
    }
}


/* This will check to see if the value can be converted into the
   operand type.  It will return TRUE if it does not fit.  */
d2802 5
a2806 143
static bfd_boolean
xg_check_operand (int32 value, xtensa_opcode opcode, int operand)
{
  uint32 valbuf = value;
  if (xtensa_operand_encode (xtensa_default_isa, opcode, operand, &valbuf))
    return TRUE;
  return FALSE;
}


/* Assumes: All immeds are constants.  Check that all constants fit
   into their immeds; return FALSE if not.  */

static bfd_boolean
xg_immeds_fit (const TInsn *insn)
{
  xtensa_isa isa = xtensa_default_isa;
  int i;

  int n = insn->ntok;
  assert (insn->insn_type == ITYPE_INSN);
  for (i = 0; i < n; ++i)
    {
      const expressionS *expr = &insn->tok[i];
      if (xtensa_operand_is_register (isa, insn->opcode, i) == 1)
	continue;

      switch (expr->X_op)
	{
	case O_register:
	case O_constant:
	  if (xg_check_operand (expr->X_add_number, insn->opcode, i))
	    return FALSE;
	  break;

	default:
	  /* The symbol should have a fixup associated with it.  */
	  assert (FALSE);
	  break;
	}
    }
  return TRUE;
}


/* This should only be called after we have an initial
   estimate of the addresses.  */

static bfd_boolean
xg_symbolic_immeds_fit (const TInsn *insn,
			segT pc_seg,
			fragS *pc_frag,
			offsetT pc_offset,
			long stretch)
{
  xtensa_isa isa = xtensa_default_isa;
  symbolS *symbolP;
  fragS *sym_frag;
  offsetT target, pc;
  uint32 new_offset;
  int i;
  int n = insn->ntok;

  assert (insn->insn_type == ITYPE_INSN);

  for (i = 0; i < n; ++i)
    {
      const expressionS *expr = &insn->tok[i];
      if (xtensa_operand_is_register (isa, insn->opcode, i) == 1)
	continue;

      switch (expr->X_op)
	{
	case O_register:
	case O_constant:
	  if (xg_check_operand (expr->X_add_number, insn->opcode, i))
	    return FALSE;
	  break;

	case O_lo16:
	case O_hi16:
	  /* Check for the worst case.  */
	  if (xg_check_operand (0xffff, insn->opcode, i))
	    return FALSE;
	  break;

	case O_symbol:
	  /* We only allow symbols for pc-relative stuff.
	     If pc_frag == 0, then we don't have frag locations yet.  */
	  if (pc_frag == 0)
	    return FALSE;

	  /* If it is PC-relative and the symbol is not in the same 
	     segment as the PC.... */
	  if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 0
	      || S_GET_SEGMENT (expr->X_add_symbol) != pc_seg)
	    return FALSE;

	  /* If it is a weak symbol, then assume it won't reach.  This will
	     only affect calls when longcalls are enabled, because if
	     longcalls are disabled, then the call is marked as a specific
	     opcode.  */
	  if (S_IS_WEAK (expr->X_add_symbol))
	    return FALSE;

	  symbolP = expr->X_add_symbol;
	  sym_frag = symbol_get_frag (symbolP);
	  target = S_GET_VALUE (symbolP) + expr->X_add_number;
	  pc = pc_frag->fr_address + pc_offset;

	  /* If frag has yet to be reached on this pass, assume it
	     will move by STRETCH just as we did.  If this is not so,
	     it will be because some frag between grows, and that will
	     force another pass.  Beware zero-length frags.  There
	     should be a faster way to do this.  */

	  if (stretch != 0
	      && sym_frag->relax_marker != pc_frag->relax_marker
	      && S_GET_SEGMENT (symbolP) == pc_seg)
	    {
	      target += stretch;
	    }
 
	  new_offset = target;
	  xtensa_operand_do_reloc (isa, insn->opcode, i, &new_offset, pc);
	  if (xg_check_operand (new_offset, insn->opcode, i))
	    return FALSE;
	  break;

	default:
	  /* The symbol should have a fixup associated with it.  */
	  return FALSE;
	}
    }

  return TRUE;
}


/* Return TRUE on success.  */

static bfd_boolean
xg_build_to_insn (TInsn *targ, TInsn *insn, BuildInstr *bi)
a2811 1
  targ->loc = insn->loc;
a2846 32
	    case OP_OPERAND_HI16U:
	    case OP_OPERAND_LOW16U:
	      assert (op_data < insn->ntok);
	      if (expr_is_const (&insn->tok[op_data]))
		{
		  long val;
		  copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
		  val = xg_apply_userdef_op_fn (op->typ,
						targ->tok[op_num].
						X_add_number);
		  targ->tok[op_num].X_add_number = val;
		}
	      else
		{
		  /* For const16 we can create relocations for these.  */
		  if (targ->opcode == XTENSA_UNDEFINED
		      || (targ->opcode != xtensa_const16_opcode))
		    return FALSE;
		  assert (op_data < insn->ntok);
		  /* Need to build a O_lo16 or O_hi16.  */
		  copy_expr (&targ->tok[op_num], &insn->tok[op_data]);
		  if (targ->tok[op_num].X_op == O_symbol)
		    {
		      if (op->typ == OP_OPERAND_HI16U)
			targ->tok[op_num].X_op = O_hi16;
		      else if (op->typ == OP_OPERAND_LOW16U)
			targ->tok[op_num].X_op = O_lo16;
		      else
			return FALSE;
		    }
		}
	      break;
a2891 3
	      /* We can only pass resolvable literals through.  */
	      if (!xg_valid_literal_expression (&insn->tok[op_data]))
		return FALSE;
d2909 1
a2909 1
      /* Literal with no ops is a label?  */
d2921 1
a2921 1
/* Return TRUE on success.  */
d2923 5
a2927 2
static bfd_boolean
xg_build_to_stack (IStack *istack, TInsn *insn, BuildInstr *bi)
d2940 1
a2940 1
/* Return TRUE on valid expansion.  */
d2942 5
a2946 2
static bfd_boolean
xg_expand_to_stack (IStack *istack, TInsn *insn, int lateral_steps)
d2950 1
a2950 1
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
d2992 4
a2995 2
static bfd_boolean
xg_expand_narrow (TInsn *targ, TInsn *insn)
d2997 1
a2997 1
  TransitionTable *table = xg_build_widen_table (&transition_rule_cmp);
d3010 1
a3010 1
	  if (xg_get_single_size (insn->opcode)
a3020 3

/* Relax the assembly instruction at least "min_steps".
   Return the number of steps taken.  */
d3022 6
a3027 8
static int
xg_assembly_relax (IStack *istack,
		   TInsn *insn,
		   segT pc_seg,
		   fragS *pc_frag,	/* if pc_frag == 0, not pc-relative */
		   offsetT pc_offset,	/* offset in fragment */
		   int min_steps,	/* minimum conversion steps */
		   long stretch)	/* number of bytes stretched so far */
d3029 1
a3029 1
  int steps_taken = 0;
d3031 9
a3039 6
  /* assert (has no symbolic operands)
     Some of its immeds don't fit.
     Try to build a relaxed version.
     This may go through a couple of stages
     of single instruction transformations before
     we get there.  */
d3041 17
a3057 4
  TInsn single_target;
  TInsn current_insn;
  int lateral_steps = 0;
  int istack_size = istack->ninsn;
a3058 7
  if (xg_symbolic_immeds_fit (insn, pc_seg, pc_frag, pc_offset, stretch)
      && steps_taken >= min_steps)
    {
      istack_push (istack, insn);
      return steps_taken;
    }
  current_insn = *insn;
d3060 2
a3061 4
  /* Walk through all of the single instruction expansions. */
  while (xg_is_single_relaxable_insn (&current_insn))
    {
      int error_val = xg_expand_narrow (&single_target, &current_insn);
d3063 12
a3074 1
      assert (!error_val);
d3076 1
a3076 12
      if (xg_symbolic_immeds_fit (&single_target, pc_seg, pc_frag, pc_offset,
				  stretch))
	{
	  steps_taken++;
	  if (steps_taken >= min_steps)
	    {
	      istack_push (istack, &single_target);
	      return steps_taken;
	    }
	}
      current_insn = single_target;
    }
d3078 1
a3078 2
  /* Now check for a multi-instruction expansion.  */
  while (xg_is_relaxable_insn (&current_insn, lateral_steps))
d3080 190
a3269 2
      if (xg_symbolic_immeds_fit (&current_insn, pc_seg, pc_frag, pc_offset,
				  stretch))
d3294 2
a3295 1
xg_force_frag_space (int size)
d3304 6
a3309 6
static void
xg_finish_frag (char *last_insn,
		enum xtensa_relax_statesE frag_state,
		enum xtensa_relax_statesE slot0_state,
		int max_growth,
		bfd_boolean is_insn)
a3316 1

d3326 1
a3326 4
	    frag_state, frag_now->fr_symbol, frag_now->fr_offset, last_insn);

  old_frag->tc_frag_data.slot_subtypes[0] = slot0_state;
  xtensa_set_frag_assembly_state (frag_now);
a3332 26
/* Return TRUE if the target frag is one of the next non-empty frags.  */

static bfd_boolean
is_next_frag_target (const fragS *fragP, const fragS *target)
{
  if (fragP == NULL)
    return FALSE;

  for (; fragP; fragP = fragP->fr_next)
    {
      if (fragP == target)
	return TRUE;
      if (fragP->fr_fix != 0)
	return FALSE;
      if (fragP->fr_type == rs_fill && fragP->fr_offset != 0)
	return FALSE;
      if ((fragP->fr_type == rs_align || fragP->fr_type == rs_align_code)
	  && ((fragP->fr_address % (1 << fragP->fr_offset)) != 0))
	return FALSE;
      if (fragP->fr_type == rs_space)
	return FALSE;
    }
  return FALSE;
}


d3334 3
a3336 1
is_branch_jmp_to_next (TInsn *insn, fragS *fragP)
d3340 1
a3340 1
  int num_ops = xtensa_opcode_num_operands (isa, insn->opcode);
d3345 1
a3345 2
  if (xtensa_opcode_is_branch (isa, insn->opcode) == 0
      && xtensa_opcode_is_jump (isa, insn->opcode) == 0)
d3350 3
a3352 1
      if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 1)
d3387 2
a3388 1
xg_add_branch_and_loop_targets (TInsn *insn)
d3391 1
a3391 1
  int num_ops = xtensa_opcode_num_operands (isa, insn->opcode);
d3393 1
a3393 1
  if (xtensa_opcode_is_loop (isa, insn->opcode) == 1)
d3396 5
a3400 3
      if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 1
	  && insn->tok[i].X_op == O_symbol)
	symbol_get_tc (insn->tok[i].X_add_symbol)->is_loop_target = TRUE;
d3404 5
a3408 2
  if (xtensa_opcode_is_branch (isa, insn->opcode) == 1
      || xtensa_opcode_is_loop (isa, insn->opcode) == 1)
d3414 3
a3416 1
	  if (xtensa_operand_is_PCrelative (isa, insn->opcode, i) == 1
d3429 90
a3518 1
/* Return FALSE if no error.  */
d3520 5
a3524 2
static bfd_boolean
xg_build_token_insn (BuildInstr *instr_spec, TInsn *old_insn, TInsn *new_insn)
a3534 1
      new_insn->loc = old_insn->loc;
a3539 1
      new_insn->loc = old_insn->loc;
d3585 1
a3585 1
/* Return TRUE if it was simplified.  */
d3587 4
a3590 2
static bfd_boolean
xg_simplify_insn (TInsn *old_insn, TInsn *new_insn)
d3592 1
a3592 1
  TransitionRule *rule;
a3593 5

  if (old_insn->is_specific_opcode || !density_supported)
    return FALSE;

  rule = xg_instruction_match (old_insn);
d3613 1
a3613 1
   multiple instructions/literals onto the stack.  Return FALSE if no
d3617 3
a3619 1
xg_expand_assembly_insn (IStack *istack, TInsn *orig_insn)
d3625 7
a3631 4
  /* Narrow it if we can.  xg_simplify_insn now does all the
     appropriate checking (e.g., for the density option).  */
  if (xg_simplify_insn (orig_insn, &new_insn))
    orig_insn = &new_insn;
d3633 1
a3633 2
  noperands = xtensa_opcode_num_operands (xtensa_default_isa,
					  orig_insn->opcode);
d3648 1
a3648 1
  /* If there are not enough operands, we will assert above.  If there
d3653 1
a3653 1
  /* Cases:
d3661 2
a3662 2
     Also close out the fragment if the fixup may cause instruction expansion.

d3667 2
a3668 2
        Multiple of these may be possible on the same fragment.
	If so, make sure to satisfy the required alignment.
d3674 1
a3674 1
  if (orig_insn->is_specific_opcode || !use_transform ())
d3695 8
d3707 1
a3707 2
/* Return TRUE if the section flags are marked linkonce
   or the name is .gnu.linkonce*.  */
d3709 3
a3711 2
static bfd_boolean
get_is_linkonce_section (bfd *abfd ATTRIBUTE_UNUSED, segT sec)
d3713 9
a3721 1
  flagword flags, link_once_flags;
d3723 2
a3724 2
  flags = bfd_get_section_flags (abfd, sec);
  link_once_flags = (flags & SEC_LINK_ONCE);
d3726 1
a3726 4
  /* Flags might not be set yet.  */
  if (!link_once_flags)
    {
      static size_t len = sizeof ".gnu.linkonce.t.";
d3728 16
a3743 4
      if (strncmp (segment_name (sec), ".gnu.linkonce.t.", len - 1) == 0)
	link_once_flags = SEC_LINK_ONCE;
    }
  return (link_once_flags != 0);
d3748 2
a3749 1
xtensa_add_literal_sym (symbolS *sym)
d3751 23
a3773 1
  sym_list *l;
d3775 3
a3777 4
  l = (sym_list *) xmalloc (sizeof (sym_list));
  l->sym = sym;
  l->next = literal_syms;
  literal_syms = l;
d3781 4
a3784 2
static symbolS *
xtensa_create_literal_symbol (segT sec, fragS *frag)
d3812 3
a3814 4
/* Currently all literals that are generated here are 32-bit L32R targets.  */

static symbolS *
xg_assemble_literal (/* const */ TInsn *insn)
d3816 1
a3816 2
  emit_state state;
  symbolS *lit_sym = NULL;
d3818 5
a3822 6
  /* size = 4 for L32R.  It could easily be larger when we move to
     larger constants.  Add a parameter later.  */
  offsetT litsize = 4;
  offsetT litalign = 2;		/* 2^2 = 4 */
  expressionS saved_loc;
  expressionS * emit_val;
a3823 1
  set_expr_symbol_offset (&saved_loc, frag_now->fr_symbol, frag_now_fix ());
d3825 5
a3829 2
  assert (insn->insn_type == ITYPE_LITERAL);
  assert (insn->ntok == 1);	/* must be only one token here */
d3831 3
a3833 4
  xtensa_switch_to_literal_fragment (&state);

  emit_val = &insn->tok[0];
  if (emit_val->X_op == O_big)
d3835 2
a3836 9
      int size = emit_val->X_add_number * CHARS_PER_LITTLENUM;
      if (size > litsize)
	{
	  /* This happens when someone writes a "movi a2, big_number".  */
	  as_bad_where (frag_now->fr_file, frag_now->fr_line, 
			_("invalid immediate"));
	  xtensa_restore_emit_state (&state);
	  return NULL;
	}
d3839 3
a3841 29
  /* Force a 4-byte align here.  Note that this opens a new frag, so all
     literals done with this function have a frag to themselves.  That's
     important for the way text section literals work.  */
  frag_align (litalign, 0, 0);
  record_alignment (now_seg, litalign);

  if (emit_val->X_op == O_pltrel)
    {
      char *p = frag_more (litsize);
      xtensa_set_frag_assembly_state (frag_now);
      if (emit_val->X_add_symbol)
	emit_val->X_op = O_symbol;
      else
	emit_val->X_op = O_constant;
      fix_new_exp (frag_now, p - frag_now->fr_literal,
		   litsize, emit_val, 0, BFD_RELOC_XTENSA_PLT);
    }
  else
    emit_expr (emit_val, litsize);

  assert (frag_now->tc_frag_data.literal_frag == NULL);
  frag_now->tc_frag_data.literal_frag = get_literal_pool_location (now_seg);
  frag_now->fr_symbol = xtensa_create_literal_symbol (now_seg, frag_now);
  lit_sym = frag_now->fr_symbol;
  frag_now->tc_frag_data.is_literal = TRUE;

  /* Go back.  */
  xtensa_restore_emit_state (&state);
  return lit_sym;
d3846 1
a3846 1
xg_assemble_literal_space (/* const */ int size, int slot)
d3848 7
a3854 5
  emit_state state;
  /* We might have to do something about this alignment.  It only
     takes effect if something is placed here.  */
  offsetT litalign = 2;		/* 2^2 = 4 */
  fragS *lit_saved_frag;
a3855 1
  assert (size % 4 == 0);
d3857 2
a3858 1
  xtensa_switch_to_literal_fragment (&state);
d3860 6
a3865 3
  /* Force a 4-byte align here.  */
  frag_align (litalign, 0, 0);
  record_alignment (now_seg, litalign);
d3867 2
a3868 1
  xg_force_frag_space (size);
d3870 4
a3873 5
  lit_saved_frag = frag_now;
  frag_now->tc_frag_data.literal_frag = get_literal_pool_location (now_seg);
  frag_now->tc_frag_data.is_literal = TRUE;
  frag_now->fr_symbol = xtensa_create_literal_symbol (now_seg, frag_now);
  xg_finish_frag (0, RELAX_LITERAL, 0, size, FALSE);
d3875 4
a3878 3
  /* Go back.  */
  xtensa_restore_emit_state (&state);
  frag_now->tc_frag_data.literal_frags[slot] = lit_saved_frag;
d3882 5
a3886 2
/* Put in a fixup record based on the opcode.
   Return TRUE on success.  */
d3889 3
a3891 7
xg_add_opcode_fix (TInsn *tinsn,
		   int opnum,
		   xtensa_format fmt,
		   int slot,
		   expressionS *expr,
		   fragS *fragP,
		   offsetT offset)
d3893 17
a3909 5
  xtensa_opcode opcode = tinsn->opcode;
  bfd_reloc_code_real_type reloc;
  reloc_howto_type *howto;
  int fmt_length;
  fixS *the_fix;
d3911 2
a3912 1
  reloc = BFD_RELOC_NONE;
d3914 17
a3930 18
  /* First try the special cases for "alternate" relocs.  */
  if (opcode == xtensa_l32r_opcode)
    {
      if (fragP->tc_frag_data.use_absolute_literals)
	reloc = encode_alt_reloc (slot);
    }
  else if (opcode == xtensa_const16_opcode)
    {
      if (expr->X_op == O_lo16)
	{
	  reloc = encode_reloc (slot);
	  expr->X_op = O_symbol;
	}
      else if (expr->X_op == O_hi16)
	{
	  reloc = encode_alt_reloc (slot);
	  expr->X_op = O_symbol;
	}
d3933 1
a3933 6
  if (opnum != get_relaxable_immed (opcode))
    {
      as_bad (_("invalid relocation for operand %i of '%s'"),
	      opnum, xtensa_opcode_name (xtensa_default_isa, opcode));
      return FALSE;
    }
d3935 1
a3935 9
  /* Handle erroneous "@@h" and "@@l" expressions here before they propagate
     into the symbol table where the generic portions of the assembler
     won't know what to do with them.  */
  if (expr->X_op == O_lo16 || expr->X_op == O_hi16)
    {
      as_bad (_("invalid expression for operand %i of '%s'"),
	      opnum, xtensa_opcode_name (xtensa_default_isa, opcode));
      return FALSE;
    }
d3937 3
a3939 8
  /* Next try the generic relocs.  */
  if (reloc == BFD_RELOC_NONE)
    reloc = encode_reloc (slot);
  if (reloc == BFD_RELOC_NONE)
    {
      as_bad (_("invalid relocation in instruction slot %i"), slot);
      return FALSE;
    }
d3941 1
a3941 2
  howto = bfd_reloc_type_lookup (stdoutput, reloc);
  if (!howto)
d3943 26
a3968 4
      as_bad (_("undefined symbol for opcode \"%s\""),
	      xtensa_opcode_name (xtensa_default_isa, opcode));
      return FALSE;
    }
d3970 3
a3972 4
  fmt_length = xtensa_format_length (xtensa_default_isa, fmt);
  the_fix = fix_new_exp (fragP, offset, fmt_length, expr,
			 howto->pc_relative, reloc);
  the_fix->fx_no_overflow = 1;
d3974 7
a3980 4
  if (expr->X_add_symbol
      && (S_IS_EXTERNAL (expr->X_add_symbol)
	  || S_IS_WEAK (expr->X_add_symbol)))
    the_fix->fx_plt = TRUE;
d3982 1
a3982 5
  the_fix->tc_fix_data.X_add_symbol = expr->X_add_symbol;
  the_fix->tc_fix_data.X_add_number = expr->X_add_number;
  the_fix->tc_fix_data.slot = slot;
  
  return TRUE;
d3987 6
a3992 6
xg_emit_insn_to_buf (TInsn *tinsn,
		     xtensa_format fmt,
		     char *buf,
		     fragS *fragP,
		     offsetT offset,
		     bfd_boolean build_fix)
d4000 1
a4000 1
  has_symbolic_immed = tinsn_to_insnbuf (tinsn, insnbuf);
d4004 2
a4005 2
      int opnum = get_relaxable_immed (tinsn->opcode);
      expressionS *exp = &tinsn->tok[opnum];
d4007 2
a4008 1
      if (!xg_add_opcode_fix (tinsn, opnum, fmt, 0, exp, fragP, offset))
d4012 1
a4012 1
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf, 0);
d4017 49
a4065 2
static void
xg_resolve_literals (TInsn *insn, symbolS *lit_sym)
d4079 4
a4082 2
static void
xg_resolve_labels (TInsn *insn, symbolS *label_sym)
d4086 1
a4086 1
  /* assert (!insn->is_literal); */
d4094 3
a4096 5
/* Return TRUE if the instruction can write to the specified
   integer register.  */

static bfd_boolean
is_register_writer (const TInsn *insn, const char *regset, int regnum)
d4098 23
a4120 3
  int i;
  int num_ops;
  xtensa_isa isa = xtensa_default_isa;
d4122 1
a4122 1
  num_ops = xtensa_opcode_num_operands (isa, insn->opcode);
d4124 1
a4124 1
  for (i = 0; i < num_ops; i++)
d4126 39
a4164 12
      char inout;
      inout = xtensa_operand_inout (isa, insn->opcode, i);
      if ((inout == 'o' || inout == 'm')
	  && xtensa_operand_is_register (isa, insn->opcode, i) == 1)
	{
	  xtensa_regfile opnd_rf =
	    xtensa_operand_regfile (isa, insn->opcode, i);
	  if (!strcmp (xtensa_regfile_shortname (isa, opnd_rf), regset))
	    {
	      if ((insn->tok[i].X_op == O_register)
		  && (insn->tok[i].X_add_number == regnum))
		return TRUE;
d4168 108
a4275 2
  return FALSE;
}
d4279 2
a4280 1
is_bad_loopend_opcode (const TInsn *tinsn)
d4300 1
a4300 2
      || opcode == xtensa_waiti_opcode
      || opcode == xtensa_rsr_lcount_opcode)
d4303 7
d4319 3
a4321 2
static bfd_boolean
is_unaligned_label (symbolS *sym)
d4335 1
a4335 1
  if (name
d4347 3
a4349 2
static fragS *
next_non_empty_frag (const fragS *fragP)
d4365 3
a4367 2
static bfd_boolean
next_frag_opcode_is_loop (const fragS *fragP, xtensa_opcode *opcode)
a4368 1
  xtensa_opcode out_opcode;
a4369 17

  if (next_fragP == NULL)
    return FALSE;

  out_opcode = get_opcode_from_buf (next_fragP->fr_literal, 0);
  if (xtensa_opcode_is_loop (xtensa_default_isa, out_opcode) == 1)
    {
      *opcode = out_opcode;
      return TRUE;
    }
  return FALSE;
}


static int
frag_format_size (const fragS *fragP)
{
a4371 2
  xtensa_format fmt;
  int fmt_size; 
d4376 1
a4376 1
  if (fragP == NULL)
d4379 3
a4381 1
  xtensa_insnbuf_from_chars (isa, insnbuf, fragP->fr_literal, 0);
a4382 4
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    return XTENSA_UNDEFINED;
  fmt_size = xtensa_format_length (isa, fmt);
d4384 1
a4384 29
  /* If the next format won't be changing due to relaxation, just
     return the length of the first format.  */
  if (fragP->fr_opcode != fragP->fr_literal)
    return fmt_size;

  /* If during relaxation we have to pull an instruction out of a 
     multi-slot instruction, we will return the more conservative
     number.  This works because alignment on bigger instructions
     is more restrictive than alignment on smaller instructions.
     This is more conservative than we would like, but it happens
     infrequently.  */

  if (xtensa_format_num_slots (xtensa_default_isa, fmt) > 1)
    return fmt_size;

  /* If we aren't doing one of our own relaxations or it isn't
     slot-based, then the insn size won't change.  */
  if (fragP->fr_type != rs_machine_dependent)
    return fmt_size;
  if (fragP->fr_subtype != RELAX_SLOTS)
    return fmt_size;

  /* If an instruction is about to grow, return the longer size.  */
  if (fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED_STEP1
      || fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED_STEP2)
    return 3;
  
  if (fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
    return 2 + fragP->tc_frag_data.text_expansion[0];
d4386 7
a4392 2
  return fmt_size;
}
d4394 15
a4408 6

static int
next_frag_format_size (const fragS *fragP)
{
  const fragS *next_fragP = next_non_empty_frag (fragP);
  return frag_format_size (next_fragP);
d4416 2
a4417 1
update_next_frag_state (fragS *fragP)
a4419 25
  fragS *new_target = NULL;

  if (align_targets) 
    {
      /* We are guaranteed there will be one of these...   */
      while (!(next_fragP->fr_type == rs_machine_dependent
	       && (next_fragP->fr_subtype == RELAX_MAYBE_UNREACHABLE
		   || next_fragP->fr_subtype == RELAX_UNREACHABLE)))
	next_fragP = next_fragP->fr_next;

      assert (next_fragP->fr_type == rs_machine_dependent
	      && (next_fragP->fr_subtype == RELAX_MAYBE_UNREACHABLE
		  || next_fragP->fr_subtype == RELAX_UNREACHABLE));

      /* ...and one of these.  */
      new_target = next_fragP->fr_next;
      while (!(new_target->fr_type == rs_machine_dependent
	       && (new_target->fr_subtype == RELAX_MAYBE_DESIRE_ALIGN
		   || new_target->fr_subtype == RELAX_DESIRE_ALIGN)))
	new_target = new_target->fr_next;

      assert (new_target->fr_type == rs_machine_dependent
	      && (new_target->fr_subtype == RELAX_MAYBE_DESIRE_ALIGN
		  || new_target->fr_subtype == RELAX_DESIRE_ALIGN));
    }
a4428 1

d4435 2
a4436 1
next_frag_is_branch_target (const fragS *fragP)
d4438 1
a4438 1
  /* Sometimes an empty will end up here due to storage allocation issues,
d4452 2
a4453 1
next_frag_is_loop_target (const fragS *fragP)
d4469 2
a4470 1
next_frag_pre_opcode_bytes (const fragS *fragp)
a4472 1
  xtensa_opcode next_opcode;
d4474 2
a4475 1
  if (!next_frag_opcode_is_loop (fragp, &next_opcode))
d4478 2
a4479 2
  /* Sometimes an empty will end up here due to storage allocation issues,
     so we have to skip until we find something legit.  */
d4488 2
a4489 3
     been relaxed.  Note that we can assume that the LOOP
     instruction is in slot 0 because loops aren't bundleable.  */
  if (next_fragp->tc_frag_data.slot_subtypes[0] > RELAX_IMMED)
d4501 1
a4501 1
xtensa_mark_literal_pool_location (void)
a4507 3
  if (use_literal_section && !directive_state[directive_absolute_literals])
    return;

a4508 1
  record_alignment (now_seg, 2);
d4511 1
a4511 1
     so we can later move the literal's fixes into this
d4515 1
a4515 1
  frag_variant (rs_machine_dependent, 0, (int) frchain_now,
d4517 1
a4517 2
  xtensa_set_frag_assembly_state (frag_now);
  frag_variant (rs_machine_dependent, 0, (int) now_seg,
a4518 1
  xtensa_set_frag_assembly_state (frag_now);
d4522 1
a4522 3
  xtensa_switch_to_non_abs_literal_fragment (&s);
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
a4525 1
  xtensa_set_frag_assembly_state (frag_now);
a4528 1
  xtensa_set_frag_assembly_state (frag_now);
d4532 23
a4554 1
/* Build a nop of the correct size into tinsn.  */
d4557 4
a4560 1
build_nop (TInsn *tinsn, int size)
d4562 3
a4564 2
  tinsn_init (tinsn);
  switch (size)
d4566 2
a4567 9
    case 2:
      tinsn->opcode = xtensa_nop_n_opcode;
      tinsn->ntok = 0;
      if (tinsn->opcode == XTENSA_UNDEFINED)
	as_fatal (_("opcode 'NOP.N' unavailable in this configuration"));
      break;

    case 3:
      if (xtensa_nop_opcode == XTENSA_UNDEFINED)
d4569 2
a4570 5
	  tinsn->opcode = xtensa_or_opcode;
	  set_expr_const (&tinsn->tok[0], 1);
	  set_expr_const (&tinsn->tok[1], 1);
	  set_expr_const (&tinsn->tok[2], 1);
	  tinsn->ntok = 3;
a4571 4
      else
	tinsn->opcode = xtensa_nop_opcode;

      assert (tinsn->opcode != XTENSA_UNDEFINED);
d4579 4
a4582 2
static void
assemble_nop (size_t size, char *buf)
d4585 3
a4587 1
  TInsn tinsn;
d4589 11
a4599 1
  build_nop (&tinsn, size);
d4601 12
a4612 2
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (xtensa_default_isa);
d4614 3
a4616 2
  tinsn_to_insnbuf (&tinsn, insnbuf);
  xtensa_insnbuf_to_chars (xtensa_default_isa, insnbuf, buf, 0);
d4628 2
a4629 1
get_expanded_loop_offset (xtensa_opcode opcode)
d4634 2
a4635 1
  assert (opcode != XTENSA_UNDEFINED);
d4647 3
a4649 2
static fragS *
get_literal_pool_location (segT seg)
d4656 3
a4658 1
set_literal_pool_location (segT seg, fragS *literal_pool_loc)
a4662 207

/* Set frag assembly state should be called when a new frag is
   opened and after a frag has been closed.  */

static void
xtensa_set_frag_assembly_state (fragS *fragP)
{
  if (!density_supported)
    fragP->tc_frag_data.is_no_density = TRUE;

  /* This function is called from subsegs_finish, which is called
     after xtensa_end, so we can't use "use_transform" or 
     "use_schedule" here.  */
  if (!directive_state[directive_transform])
    fragP->tc_frag_data.is_no_transform = TRUE;
  fragP->tc_frag_data.use_absolute_literals =
    directive_state[directive_absolute_literals];
  fragP->tc_frag_data.is_assembly_state_set = TRUE;
}


static bfd_boolean
relaxable_section (asection *sec)
{
  return (sec->flags & SEC_DEBUGGING) == 0;
}


static void
xtensa_find_unmarked_state_frags (void)
{
  segT *seclist;

  /* Walk over each fragment of all of the current segments.  For each
     unmarked fragment, mark it with the same info as the previous
     fragment.  */
  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segT sec = *seclist;
      segment_info_type *seginfo;
      fragS *fragP;
      flagword flags;
      flags = bfd_get_section_flags (stdoutput, sec);
      if (flags & SEC_DEBUGGING)
	continue;
      if (!(flags & SEC_ALLOC))
	continue;

      seginfo = seg_info (sec);
      if (seginfo && seginfo->frchainP)
	{
	  fragS *last_fragP = 0;
	  for (fragP = seginfo->frchainP->frch_root; fragP;
	       fragP = fragP->fr_next)
	    {
	      if (fragP->fr_fix != 0
		  && !fragP->tc_frag_data.is_assembly_state_set)
		{
		  if (last_fragP == 0)
		    {
		      as_warn_where (fragP->fr_file, fragP->fr_line,
				     _("assembly state not set for first frag in section %s"),
				     sec->name);
		    }
		  else
		    {
		      fragP->tc_frag_data.is_assembly_state_set = TRUE;
		      fragP->tc_frag_data.is_no_density =
			last_fragP->tc_frag_data.is_no_density;
		      fragP->tc_frag_data.is_no_transform =
			last_fragP->tc_frag_data.is_no_transform;
		      fragP->tc_frag_data.use_absolute_literals =
			last_fragP->tc_frag_data.use_absolute_literals;
		    }
		}
	      if (fragP->tc_frag_data.is_assembly_state_set)
		last_fragP = fragP;
	    }
	}
    }
}


static void
xtensa_find_unaligned_branch_targets (bfd *abfd ATTRIBUTE_UNUSED,
				      asection *sec,
				      void *unused ATTRIBUTE_UNUSED)
{
  flagword flags = bfd_get_section_flags (abfd, sec);
  segment_info_type *seginfo = seg_info (sec);
  fragS *frag = seginfo->frchainP->frch_root;
  
  if (flags & SEC_CODE)
    {  
      xtensa_isa isa = xtensa_default_isa;
      xtensa_insnbuf insnbuf = xtensa_insnbuf_alloc (isa);
      while (frag != NULL)
	{
	  if (frag->tc_frag_data.is_branch_target)
	    {
	      int op_size;
	      int frag_addr;
	      xtensa_format fmt;

	      xtensa_insnbuf_from_chars (isa, insnbuf, frag->fr_literal, 0);
	      fmt = xtensa_format_decode (isa, insnbuf);
	      op_size = xtensa_format_length (isa, fmt);
	      frag_addr = frag->fr_address % xtensa_fetch_width;
	      if (frag_addr + op_size > (int) xtensa_fetch_width)
		as_warn_where (frag->fr_file, frag->fr_line,
			       _("unaligned branch target: %d bytes at 0x%lx"),
			       op_size, frag->fr_address);
	    }
	  frag = frag->fr_next;
	}
      xtensa_insnbuf_free (isa, insnbuf);
    }
}


static void
xtensa_find_unaligned_loops (bfd *abfd ATTRIBUTE_UNUSED,
			     asection *sec,
			     void *unused ATTRIBUTE_UNUSED)
{
  flagword flags = bfd_get_section_flags (abfd, sec);
  segment_info_type *seginfo = seg_info (sec);
  fragS *frag = seginfo->frchainP->frch_root;
  xtensa_isa isa = xtensa_default_isa;
  
  if (flags & SEC_CODE)
    {  
      xtensa_insnbuf insnbuf = xtensa_insnbuf_alloc (isa);
      while (frag != NULL)
	{
	  if (frag->tc_frag_data.is_first_loop_insn)
	    {
	      int op_size;
	      int frag_addr;
	      xtensa_format fmt;

	      xtensa_insnbuf_from_chars (isa, insnbuf, frag->fr_literal, 0);
	      fmt = xtensa_format_decode (isa, insnbuf);
	      op_size = xtensa_format_length (isa, fmt);
	      frag_addr = frag->fr_address % xtensa_fetch_width;

	      if (frag_addr + op_size > (signed) xtensa_fetch_width)
		as_warn_where (frag->fr_file, frag->fr_line,
			       _("unaligned loop: %d bytes at 0x%lx"),
			       op_size, frag->fr_address);
	    }
	  frag = frag->fr_next;
	}
      xtensa_insnbuf_free (isa, insnbuf);
    }
}


static void
xg_apply_tentative_value (fixS *fixP, valueT val)
{
  xtensa_isa isa = xtensa_default_isa;
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  xtensa_format fmt;
  int slot;
  bfd_boolean alt_reloc;
  xtensa_opcode opcode;
  char *const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;

  (void) decode_reloc (fixP->fx_r_type, &slot, &alt_reloc);
  if (alt_reloc)
    as_fatal (_("unexpected fix"));

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  xtensa_insnbuf_from_chars (isa, insnbuf, fixpos, 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    as_fatal (_("undecodable fix"));
  xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
  opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);
  if (opcode == XTENSA_UNDEFINED)
    as_fatal (_("undecodable fix"));

  /* CONST16 immediates are not PC-relative, despite the fact that we
     reuse the normal PC-relative operand relocations for the low part
     of a CONST16 operand.  The code in tc_gen_reloc does not decode
     the opcodes so it is more convenient to detect this special case
     here.  */
  if (opcode == xtensa_const16_opcode)
    return;

  xtensa_insnbuf_set_operand (slotbuf, fmt, slot, opcode,
			      get_relaxable_immed (opcode), val,
			      fixP->fx_file, fixP->fx_line);

  xtensa_format_set_slot (isa, fmt, slot, insnbuf, slotbuf);
  xtensa_insnbuf_to_chars (isa, insnbuf, fixpos, 0);
}

d4667 1
a4667 1
xtensa_target_format (void)
d4674 2
a4675 1
xtensa_file_arch_init (bfd *abfd)
d4682 4
a4685 1
md_number_to_chars (char *buf, valueT val, int n)
d4699 1
a4699 1
md_begin (void)
d4705 4
a4708 1
  xtensa_default_isa = xtensa_isa_init (0, 0);
d4710 1
d4712 1
a4712 3
  linkrelax = 1;

  /* Set up the .literal, .fini.literal and .init.literal sections.  */
a4716 1
  default_lit_sections.lit4_seg_name = LIT4_SECTION_NAME;
a4719 2
  xg_init_vinsn (&cur_vinsn);

a4729 1
  xtensa_const16_opcode = xtensa_opcode_lookup (isa, "const16");
a4730 2
  xtensa_movi_opcode = xtensa_opcode_lookup (isa, "movi");
  xtensa_movi_n_opcode = xtensa_opcode_lookup (isa, "movi.n");
d4732 1
a4733 1
  xtensa_l32r_opcode = xtensa_opcode_lookup (isa, "l32r");
a4736 1
  xtensa_nop_opcode = xtensa_opcode_lookup (isa, "nop");
d4743 1
a4743 1
  xtensa_rsr_lcount_opcode = xtensa_opcode_lookup (isa, "rsr.lcount");
a4744 17

  init_op_placement_info_table ();

  /* Set up the assembly state.  */
  if (!frag_now->tc_frag_data.is_assembly_state_set)
    xtensa_set_frag_assembly_state (frag_now);
}


/* TC_INIT_FIX_DATA hook */

void
xtensa_init_fix_data (fixS *x)
{
  x->tc_fix_data.slot = 0;
  x->tc_fix_data.X_add_symbol = NULL;
  x->tc_fix_data.X_add_number = 0;
d4751 2
a4752 1
xtensa_frob_label (symbolS *sym)
a4753 5
  /* Since the label was already attached to a frag associated with the
     previous basic block, it now needs to be reset to the current frag.  */
  symbol_set_frag (sym, frag_now);
  S_SET_VALUE (sym, (valueT) frag_now_fix ());

d4766 1
a4766 1
      && do_align_targets ()
d4768 1
a4768 1
      && !generating_literals)
d4770 2
a4771 20
      float freq = get_subseg_target_freq (now_seg, now_subseg);
      xtensa_set_frag_assembly_state (frag_now);

      /* The only time this type of frag grows is when there is a
	 negatable branch that needs to be relaxed as the last
	 instruction in a zero-overhead loop.  Because alignment frags
	 are so common, marking them all as possibly growing four
	 bytes makes any worst-case analysis appear much worse than it
	 is.  So, we make fr_var not actually reflect the amount of
	 memory allocated at the end of this frag, but rather the
	 amount of memory this frag might grow.  The "4, 0" below
	 allocates four bytes at the end of the frag for room to grow
	 if we need to relax a loop end with a NOP.  Frags prior to
	 this one might grow to align this one, but the frag itself
	 won't grow unless it meets the condition above.  */

#define RELAX_LOOP_END_BYTES 4

      frag_var (rs_machine_dependent,
		RELAX_LOOP_END_BYTES, (int) freq,
a4773 1
      xtensa_set_frag_assembly_state (frag_now);
d4775 10
a4785 12

  /* We need to mark the following properties even if we aren't aligning.  */

  /* If the label is already known to be a branch target, i.e., a
     forward branch, mark the frag accordingly.  Backward branches
     are handled by xg_add_branch_and_loop_targets.  */
  if (symbol_get_tc (sym)->is_branch_target)
    symbol_get_frag (sym)->tc_frag_data.is_branch_target = TRUE;

  /* Loops only go forward, so they can be identified here.  */
  if (symbol_get_tc (sym)->is_loop_target)
    symbol_get_frag (sym)->tc_frag_data.is_loop_target = TRUE;
d4789 1
a4789 1
/* tc_unrecognized_line hook */
d4791 2
a4792 47
int
xtensa_unrecognized_line (int ch)
{
  switch (ch)
    {
    case '{' :
      if (cur_vinsn.inside_bundle == 0)
	{
	  /* PR8110: Cannot emit line number info inside a FLIX bundle
	     when using --gstabs.  Temporarily disable debug info.  */
	  generate_lineno_debug ();
	  if (debug_type == DEBUG_STABS)
	    {
	      xt_saved_debug_type = debug_type;
	      debug_type = DEBUG_NONE;
	    }

	  cur_vinsn.inside_bundle = 1;
	}
      else
	{
	  as_bad (_("extra opening brace"));
	  return 0;
	}
      break;

    case '}' :
      if (cur_vinsn.inside_bundle)
	finish_vinsn (&cur_vinsn);
      else
	{
	  as_bad (_("extra closing brace"));
	  return 0;
	}
      break;
    default:
      as_bad (_("syntax error"));
      return 0;
    }
  return 1;
}


/* md_flush_pending_output hook */

void
xtensa_flush_pending_output (void)
a4793 3
  if (cur_vinsn.inside_bundle)
    as_bad (_("missing closing brace"));

a4798 1
      xtensa_set_frag_assembly_state (frag_now);
a4805 19
/* We had an error while parsing an instruction.  The string might look
   like this: "insn arg1, arg2 }".  If so, we need to see the closing
   brace and reset some fields.  Otherwise, the vinsn never gets closed
   and the num_slots field will grow past the end of the array of slots,
   and bad things happen.  */

static void
error_reset_cur_vinsn (void)
{
  if (cur_vinsn.inside_bundle)
    {
      if (*input_line_pointer == '}'
	  || *(input_line_pointer - 1) == '}'
	  || *(input_line_pointer - 2) == '}')
	xg_clear_vinsn (&cur_vinsn);
    }
}


d4807 2
a4808 1
md_assemble (char *str)
d4814 1
a4814 1
  char *arg_strings[MAX_INSN_ARGS];
d4816 1
d4818 13
d4832 1
d4860 2
a4861 1
  orig_insn.is_specific_opcode = (has_underbar || !use_transform ());
d4866 14
a4879 2
      xtensa_format fmt = xtensa_format_lookup (isa, opname);
      if (fmt == XTENSA_UNDEFINED)
d4881 13
a4893 9
	  as_bad (_("unknown opcode or format name '%s'"), opname);
	  error_reset_cur_vinsn ();
	  return;
	}
      if (!cur_vinsn.inside_bundle)
	{
	  as_bad (_("format names only valid inside bundles"));
	  error_reset_cur_vinsn ();
	  return;
a4894 7
      if (cur_vinsn.format != XTENSA_UNDEFINED)
	as_warn (_("multiple formats specified for one bundle; using '%s'"),
		 opname);
      cur_vinsn.format = fmt;
      free (has_underbar ? opname - 1 : opname);
      error_reset_cur_vinsn ();
      return;
a4905 1
      error_reset_cur_vinsn ();
a4914 7
  /* Get expressions for invisible operands.  */
  if (get_invisible_operands (&orig_insn))
    {
      error_reset_cur_vinsn ();
      return;
    }

d4917 10
d4928 12
a4939 2
      error_reset_cur_vinsn ();
      return;
a4941 4
  dwarf2_where (&orig_insn.loc);
  
  xg_add_branch_and_loop_targets (&orig_insn);

d4943 1
a4943 1
  if (orig_insn.opcode == xtensa_entry_opcode)
d4945 2
a4946 2
      /* Check that the third opcode (#2) is >= 16.  */
      if (orig_insn.ntok >= 3)
d4948 1
a4948 1
	  expressionS *exp = &orig_insn.tok[2];
d4960 9
d4971 11
d4983 3
a4985 3
     assemble_tokens (opcode, tok, ntok);
     expand the tokens from the orig_insn into the
     stack of instructions that will not expand
d4987 2
d4990 14
a5003 10
  if (!cur_vinsn.inside_bundle)
    emit_single_op (&orig_insn);
  else /* We are inside a bundle.  */
    {
      cur_vinsn.slots[cur_vinsn.num_slots] = orig_insn;
      cur_vinsn.num_slots++;
      if (*input_line_pointer == '}'
	  || *(input_line_pointer - 1) == '}'
	  || *(input_line_pointer - 2) == '}')
	finish_vinsn (&cur_vinsn);
d5006 10
a5015 2
  /* We've just emitted a new instruction so clear the list of labels.  */
  xtensa_clear_insn_labels ();
d5019 25
a5043 1
/* HANDLE_ALIGN hook */
d5045 3
a5047 3
/* For a .align directive, we mark the previous block with the alignment
   information.  This will be placed in the object file in the
   property section corresponding to this section.  */
d5049 18
a5066 22
void
xtensa_handle_align (fragS *fragP)
{
  if (linkrelax
      && ! fragP->tc_frag_data.is_literal
      && (fragP->fr_type == rs_align
	  || fragP->fr_type == rs_align_code)
      && fragP->fr_address + fragP->fr_fix > 0
      && fragP->fr_offset > 0
      && now_seg != bss_section)
    {
      fragP->tc_frag_data.is_align = TRUE;
      fragP->tc_frag_data.alignment = fragP->fr_offset;
    }

  if (fragP->fr_type == rs_align_test)
    {
      int count;
      count = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
      if (count != 0)
	as_bad_where (fragP->fr_file, fragP->fr_line, 
		      _("unaligned entry instruction"));
d5068 1
d5070 1
a5070 1

d5075 2
a5076 1
xtensa_frag_init (fragS *frag)
d5078 1
a5078 1
  xtensa_set_frag_assembly_state (frag);
d5083 2
a5084 1
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
d5093 3
a5095 1
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
d5102 2
a5103 1
md_pcrel_from (fixS *fixP)
a5106 1
  static xtensa_insnbuf slotbuf = NULL;
d5108 1
a5108 1
  uint32 opnd_value;
a5109 2
  xtensa_format fmt;
  int slot;
a5111 1
  bfd_boolean alt_reloc;
d5120 1
a5120 4
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }
d5123 2
a5124 5
  xtensa_insnbuf_from_chars (isa, insnbuf, insn_p, 0);
  fmt = xtensa_format_decode (isa, insnbuf);

  if (fmt == XTENSA_UNDEFINED)
    as_fatal (_("bad instruction format"));
d5126 1
a5126 2
  if (decode_reloc (fixP->fx_r_type, &slot, &alt_reloc) != 0)
    as_fatal (_("invalid relocation"));
d5128 13
a5140 10
  xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
  opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);

  /* Check for "alternate" relocation (operand not specified).  */
  if (alt_reloc || opcode == xtensa_const16_opcode)
    {
      if (opcode != xtensa_l32r_opcode
	  && opcode != xtensa_const16_opcode)
	as_fatal (_("invalid relocation for '%s' instruction"),
		  xtensa_opcode_name (isa, opcode));
d5144 1
a5144 4
  opnum = get_relaxable_immed (opcode);
  opnd_value = 0;
  if (xtensa_operand_is_PCrelative (isa, opcode, opnum) != 1
      || xtensa_operand_do_reloc (isa, opcode, opnum, &opnd_value, addr))
d5152 8
a5159 31
  return 0 - opnd_value;
}


/* TC_FORCE_RELOCATION hook */

int
xtensa_force_relocation (fixS *fix)
{
  switch (fix->fx_r_type)
   {
    case BFD_RELOC_XTENSA_SLOT0_ALT:
    case BFD_RELOC_XTENSA_SLOT1_ALT:
    case BFD_RELOC_XTENSA_SLOT2_ALT:
    case BFD_RELOC_XTENSA_SLOT3_ALT:
    case BFD_RELOC_XTENSA_SLOT4_ALT:
    case BFD_RELOC_XTENSA_SLOT5_ALT:
    case BFD_RELOC_XTENSA_SLOT6_ALT:
    case BFD_RELOC_XTENSA_SLOT7_ALT:
    case BFD_RELOC_XTENSA_SLOT8_ALT:
    case BFD_RELOC_XTENSA_SLOT9_ALT:
    case BFD_RELOC_XTENSA_SLOT10_ALT:
    case BFD_RELOC_XTENSA_SLOT11_ALT:
    case BFD_RELOC_XTENSA_SLOT12_ALT:
    case BFD_RELOC_XTENSA_SLOT13_ALT:
    case BFD_RELOC_XTENSA_SLOT14_ALT:
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      return 1;
    default:
      break;
d5162 1
a5162 5
  if (linkrelax && fix->fx_addsy
      && relaxable_section (S_GET_SEGMENT (fix->fx_addsy)))
    return 1;

  return generic_force_reloc (fix);
d5166 1
a5166 19
/* NO_PSEUDO_DOT hook */

/* This function has nothing to do with pseudo dots, but this is the
   nearest macro to where the check needs to take place.  FIXME: This
   seems wrong.  */

bfd_boolean
xtensa_check_inside_bundle (void)
{
  if (cur_vinsn.inside_bundle && input_line_pointer[-1] == '.')
    as_bad (_("directives are not valid inside bundles"));

  /* This function must always return FALSE because it is called via a
     macro that has nothing to do with bundling.  */
  return FALSE;
}


/* md_elf_section_change_hook */
d5169 2
a5170 1
xtensa_elf_section_change_hook (void)
d5172 1
a5172 3
  /* Set up the assembly state.  */
  if (!frag_now->tc_frag_data.is_assembly_state_set)
    xtensa_set_frag_assembly_state (frag_now);
d5179 2
a5180 1
xtensa_fix_adjustable (fixS *fixP)
a5181 8
  /* An offset is not allowed in combination with the difference of two
     symbols, but that cannot be easily detected after a local symbol
     has been adjusted to a (section+offset) form.  Return 0 so that such
     an fix will not be adjusted.  */
  if (fixP->fx_subsy && fixP->fx_addsy && fixP->fx_offset
      && relaxable_section (S_GET_SEGMENT (fixP->fx_subsy)))
    return 0;

a5186 13
  if (fixP->fx_addsy
      && (S_IS_EXTERNAL (fixP->fx_addsy) || S_IS_WEAK (fixP->fx_addsy)))
    return 0;

#if 0
  /* We may someday want to enable this code to preserve relocations for
     non-PC-relative fixes, possibly under control of a PIC flag.  */
  return (fixP->fx_pcrel
	  || (fixP->fx_subsy != NULL
	      && (S_GET_SEGMENT (fixP->fx_subsy)
		  == S_GET_SEGMENT (fixP->fx_addsy)))
	  || S_IS_LOCAL (fixP->fx_addsy));
#else
a5187 1
#endif
d5192 4
a5195 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
d5199 4
d5204 3
d5227 20
d5261 4
a5264 1
md_atof (int type, char *litP, int *sizeP)
d5307 3
a5309 1
md_estimate_size_before_relax (fragS *fragP, segT seg ATTRIBUTE_UNUSED)
d5311 1
a5311 1
  return total_frag_text_expansion (fragP);
d5319 3
a5321 1
tc_gen_reloc (asection *section, fixS *fixp)
a5323 1
  bfd_boolean apply_tentative_value = FALSE;
d5334 2
a5335 1201
  if (linkrelax && fixp->fx_subsy
      && (fixp->fx_r_type == BFD_RELOC_8
	  || fixp->fx_r_type == BFD_RELOC_16
	  || fixp->fx_r_type == BFD_RELOC_32))
    {
      int diff_size = 0;
      bfd_vma diff_value, diff_mask = 0;

      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_8:
	  fixp->fx_r_type = BFD_RELOC_XTENSA_DIFF8;
	  diff_size = 1;
	  diff_mask = 0xff;
	  break;
	case BFD_RELOC_16:
	  fixp->fx_r_type = BFD_RELOC_XTENSA_DIFF16;
	  diff_size = 2;
	  diff_mask = 0xffff;
	  break;
	case BFD_RELOC_32:
	  fixp->fx_r_type = BFD_RELOC_XTENSA_DIFF32;
	  diff_size = 4;
	  diff_mask = 0xffffffff;
	  break;
	default:
	  break;
	}

      /* An offset is only allowed when it results from adjusting a local
	 symbol into a section-relative offset.  If the offset came from the
	 original expression, tc_fix_adjustable will have prevented the fix
	 from being converted to a section-relative form so that we can flag
	 the error here.  */
      if (fixp->fx_offset != 0 && !symbol_section_p (fixp->fx_addsy))
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("cannot represent subtraction with an offset"));
	  free (reloc->sym_ptr_ptr);
	  free (reloc);
	  return NULL;
	}

      assert (S_GET_SEGMENT (fixp->fx_addsy)
	      == S_GET_SEGMENT (fixp->fx_subsy));

      diff_value = (S_GET_VALUE (fixp->fx_addsy) + fixp->fx_offset
		    - S_GET_VALUE (fixp->fx_subsy));

      /* Check for overflow.  */
      if ((diff_value & ~diff_mask) != 0)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("value of %ld too large"), diff_value);
	  free (reloc->sym_ptr_ptr);
	  free (reloc);
	  return NULL;
	}

      md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
			  diff_value, diff_size);
      reloc->addend = fixp->fx_offset - diff_value;
    }
  else
    {
      reloc->addend = fixp->fx_offset;

      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_XTENSA_SLOT0_OP:
	case BFD_RELOC_XTENSA_SLOT1_OP:
	case BFD_RELOC_XTENSA_SLOT2_OP:
	case BFD_RELOC_XTENSA_SLOT3_OP:
	case BFD_RELOC_XTENSA_SLOT4_OP:
	case BFD_RELOC_XTENSA_SLOT5_OP:
	case BFD_RELOC_XTENSA_SLOT6_OP:
	case BFD_RELOC_XTENSA_SLOT7_OP:
	case BFD_RELOC_XTENSA_SLOT8_OP:
	case BFD_RELOC_XTENSA_SLOT9_OP:
	case BFD_RELOC_XTENSA_SLOT10_OP:
	case BFD_RELOC_XTENSA_SLOT11_OP:
	case BFD_RELOC_XTENSA_SLOT12_OP:
	case BFD_RELOC_XTENSA_SLOT13_OP:
	case BFD_RELOC_XTENSA_SLOT14_OP:
	  /* As a special case, the immediate value for a CONST16 opcode
	     should not be applied, since this kind of relocation is
	     handled specially for CONST16 and is not really PC-relative.
	     Rather than decode the opcode here, just wait and handle it
	     in xg_apply_tentative_value.  */
	  apply_tentative_value = TRUE;
	  break;

	case BFD_RELOC_XTENSA_SLOT0_ALT:
	case BFD_RELOC_XTENSA_SLOT1_ALT:
	case BFD_RELOC_XTENSA_SLOT2_ALT:
	case BFD_RELOC_XTENSA_SLOT3_ALT:
	case BFD_RELOC_XTENSA_SLOT4_ALT:
	case BFD_RELOC_XTENSA_SLOT5_ALT:
	case BFD_RELOC_XTENSA_SLOT6_ALT:
	case BFD_RELOC_XTENSA_SLOT7_ALT:
	case BFD_RELOC_XTENSA_SLOT8_ALT:
	case BFD_RELOC_XTENSA_SLOT9_ALT:
	case BFD_RELOC_XTENSA_SLOT10_ALT:
	case BFD_RELOC_XTENSA_SLOT11_ALT:
	case BFD_RELOC_XTENSA_SLOT12_ALT:
	case BFD_RELOC_XTENSA_SLOT13_ALT:
	case BFD_RELOC_XTENSA_SLOT14_ALT:
	case BFD_RELOC_XTENSA_ASM_EXPAND:
	case BFD_RELOC_32:
	case BFD_RELOC_XTENSA_PLT:
	case BFD_RELOC_VTABLE_INHERIT:
	case BFD_RELOC_VTABLE_ENTRY:
	  break;

	case BFD_RELOC_XTENSA_ASM_SIMPLIFY:
	  as_warn (_("emitting simplification relocation"));
	  break;

	default:
	  as_warn (_("emitting unknown relocation"));
	}
    }

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent `%s' relocation in object file"),
		    bfd_get_reloc_code_name (fixp->fx_r_type));
      free (reloc->sym_ptr_ptr);
      free (reloc);
      return NULL;
    }

  if (!fixp->fx_pcrel != !reloc->howto->pc_relative)
    as_fatal (_("internal error? cannot generate `%s' relocation"),
	      bfd_get_reloc_code_name (fixp->fx_r_type));

  /* Write the tentative value of a PC-relative relocation to a local symbol
     into the instruction.  The value will be ignored by the linker, and it
     makes the object file disassembly readable when the linkrelax flag is
     set and all branch targets are encoded in relocations.  */

  if (linkrelax && apply_tentative_value && fixp->fx_pcrel)
    {
      valueT val;
      assert (fixp->fx_addsy);
      if (S_GET_SEGMENT (fixp->fx_addsy) == section && !fixp->fx_plt
	  && !S_FORCE_RELOC (fixp->fx_addsy, 1))
	{
	  val = (S_GET_VALUE (fixp->fx_addsy) + fixp->fx_offset
		 - md_pcrel_from (fixp));
	  xg_apply_tentative_value (fixp, val);
	}
    }

  return reloc;
}


/* Checks for resource conflicts between instructions.  */

/* The func unit stuff could be implemented as bit-vectors rather 
   than the iterative approach here.  If it ends up being too 
   slow, we will switch it.  */

resource_table * 
new_resource_table (void *data,
		    int cycles,
		    int nu,
		    unit_num_copies_func uncf,
		    opcode_num_units_func onuf,
		    opcode_funcUnit_use_unit_func ouuf,
		    opcode_funcUnit_use_stage_func ousf)
{
  int i;
  resource_table *rt = (resource_table *) xmalloc (sizeof (resource_table));
  rt->data = data;
  rt->cycles = cycles;
  rt->allocated_cycles = cycles;
  rt->num_units = nu;
  rt->unit_num_copies = uncf;
  rt->opcode_num_units = onuf;
  rt->opcode_unit_use = ouuf;
  rt->opcode_unit_stage = ousf;

  rt->units = (char **) xcalloc (cycles, sizeof (char *));
  for (i = 0; i < cycles; i++)
    rt->units[i] = (char *) xcalloc (nu, sizeof (char));

  return rt;
}


void 
clear_resource_table (resource_table *rt)
{
  int i, j;
  for (i = 0; i < rt->allocated_cycles; i++)
    for (j = 0; j < rt->num_units; j++)
      rt->units[i][j] = 0;
}


/* We never shrink it, just fake it into thinking so.  */

void 
resize_resource_table (resource_table *rt, int cycles)
{
  int i, old_cycles;

  rt->cycles = cycles;
  if (cycles <= rt->allocated_cycles)
    return;

  old_cycles = rt->allocated_cycles;
  rt->allocated_cycles = cycles;

  rt->units = xrealloc (rt->units, sizeof (char *) * rt->allocated_cycles);
  for (i = 0; i < old_cycles; i++)
    rt->units[i] = xrealloc (rt->units[i], sizeof (char) * rt->num_units);
  for (i = old_cycles; i < cycles; i++)
    rt->units[i] = xcalloc (rt->num_units, sizeof (char));
}


bfd_boolean 
resources_available (resource_table *rt, xtensa_opcode opcode, int cycle)
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++) 
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      int copies_in_use = rt->units[stage + cycle][unit];
      int copies = (rt->unit_num_copies) (rt->data, unit);
      if (copies_in_use >= copies)
	return FALSE;
    }
  return TRUE;
}
     

void 
reserve_resources (resource_table *rt, xtensa_opcode opcode, int cycle)
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++) 
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      /* Note that this allows resources to be oversubscribed.  That's 
	 essential to the way the optional scheduler works. 
	 resources_available reports when a resource is over-subscribed,
	 so it's easy to tell.  */
      rt->units[stage + cycle][unit]++;
    }
}


void 
release_resources (resource_table *rt, xtensa_opcode opcode, int cycle)
{
  int i;
  int uses = (rt->opcode_num_units) (rt->data, opcode);

  for (i = 0; i < uses; i++) 
    {
      xtensa_funcUnit unit = (rt->opcode_unit_use) (rt->data, opcode, i);
      int stage = (rt->opcode_unit_stage) (rt->data, opcode, i);
      rt->units[stage + cycle][unit]--;
      assert (rt->units[stage + cycle][unit] >= 0);
    }
}
     

/* Wrapper functions make parameterized resource reservation
   more convenient.  */

int 
opcode_funcUnit_use_unit (void *data, xtensa_opcode opcode, int idx)
{
  xtensa_funcUnit_use *use = xtensa_opcode_funcUnit_use (data, opcode, idx);
  return use->unit;  
}


int 
opcode_funcUnit_use_stage (void *data, xtensa_opcode opcode, int idx)
{
  xtensa_funcUnit_use *use = xtensa_opcode_funcUnit_use (data, opcode, idx);
  return use->stage;
}


/* Note that this function does not check issue constraints, but
   solely whether the hardware is available to execute the given
   instructions together.  It also doesn't check if the tinsns 
   write the same state, or access the same tieports.  That is
   checked by check_t1_t2_reads_and_writes.  */

static bfd_boolean
resources_conflict (vliw_insn *vinsn)
{
  int i;
  static resource_table *rt = NULL;

  /* This is the most common case by far.  Optimize it.  */
  if (vinsn->num_slots == 1)
    return FALSE;

  if (rt == NULL) 
    {
      xtensa_isa isa = xtensa_default_isa;
      rt = new_resource_table
	(isa, xtensa_isa_num_pipe_stages (isa),
	 xtensa_isa_num_funcUnits (isa),
	 (unit_num_copies_func) xtensa_funcUnit_num_copies,
	 (opcode_num_units_func) xtensa_opcode_num_funcUnit_uses,
	 opcode_funcUnit_use_unit,
	 opcode_funcUnit_use_stage);
    }

  clear_resource_table (rt);

  for (i = 0; i < vinsn->num_slots; i++)
    {
      if (!resources_available (rt, vinsn->slots[i].opcode, 0))
	return TRUE;
      reserve_resources (rt, vinsn->slots[i].opcode, 0);
    }

  return FALSE;
}


/* finish_vinsn, emit_single_op and helper functions.  */

static bfd_boolean find_vinsn_conflicts (vliw_insn *);
static xtensa_format xg_find_narrowest_format (vliw_insn *);
static void bundle_single_op (TInsn *);
static void xg_assemble_vliw_tokens (vliw_insn *);


/* We have reached the end of a bundle; emit into the frag.  */

static void
finish_vinsn (vliw_insn *vinsn)
{
  IStack slotstack;
  int i;
  char *file_name;
  int line;

  if (find_vinsn_conflicts (vinsn))
    {
      xg_clear_vinsn (vinsn);
      return;
    }

  /* First, find a format that works.  */
  if (vinsn->format == XTENSA_UNDEFINED)
    vinsn->format = xg_find_narrowest_format (vinsn);

  if (vinsn->format == XTENSA_UNDEFINED)
    {
      as_where (&file_name, &line);
      as_bad_where (file_name, line,
		    _("couldn't find a valid instruction format"));
      fprintf (stderr, _("    ops were: "));
      for (i = 0; i < vinsn->num_slots; i++)
	fprintf (stderr, _(" %s;"),
		 xtensa_opcode_name (xtensa_default_isa,
				     vinsn->slots[i].opcode));
      fprintf (stderr, _("\n"));
      xg_clear_vinsn (vinsn);
      return;
    }

  if (vinsn->num_slots
      != xtensa_format_num_slots (xtensa_default_isa, vinsn->format))
    {
      as_bad (_("format '%s' allows %d slots, but there are %d opcodes"),
	      xtensa_format_name (xtensa_default_isa, vinsn->format),
	      xtensa_format_num_slots (xtensa_default_isa, vinsn->format),
	      vinsn->num_slots);
      xg_clear_vinsn (vinsn);
      return;
    }

  if (resources_conflict (vinsn)) 
    {
      as_where (&file_name, &line);
      as_bad_where (file_name, line, _("illegal resource usage in bundle"));
      fprintf (stderr, "    ops were: ");
      for (i = 0; i < vinsn->num_slots; i++)
	fprintf (stderr, " %s;",
		 xtensa_opcode_name (xtensa_default_isa,
				     vinsn->slots[i].opcode));
      fprintf (stderr, "\n");
      xg_clear_vinsn (vinsn);
      return;
    }

  for (i = 0; i < vinsn->num_slots; i++)
    {
      if (vinsn->slots[i].opcode != XTENSA_UNDEFINED)
	{
	  symbolS *lit_sym = NULL;
	  int j;
	  bfd_boolean e = FALSE;
	  bfd_boolean saved_density = density_supported;

	  /* We don't want to narrow ops inside multi-slot bundles.  */
	  if (vinsn->num_slots > 1)
	    density_supported = FALSE;

	  istack_init (&slotstack);
	  if (vinsn->slots[i].opcode == xtensa_nop_opcode)
	    {
	      vinsn->slots[i].opcode =
		xtensa_format_slot_nop_opcode (xtensa_default_isa,
					       vinsn->format, i);
	      vinsn->slots[i].ntok = 0;
	    }

	  if (xg_expand_assembly_insn (&slotstack, &vinsn->slots[i]))
	    {
	      e = TRUE;
	      continue;
	    }

	  density_supported = saved_density;

	  if (e)
	    {
	      xg_clear_vinsn (vinsn);
	      return;
	    }

	  for (j = 0; j < slotstack.ninsn - 1; j++)
	    {
	      TInsn *insn = &slotstack.insn[j];
	      if (insn->insn_type == ITYPE_LITERAL)
		{
		  assert (lit_sym == NULL);
		  lit_sym = xg_assemble_literal (insn);
		}
	      else
		{
		  if (lit_sym)
		    xg_resolve_literals (insn, lit_sym);
		  emit_single_op (insn);
		}
	    }

	  if (vinsn->num_slots > 1)
	    {
	      if (opcode_fits_format_slot
		  (slotstack.insn[slotstack.ninsn - 1].opcode,
		   vinsn->format, i))
		{
		  vinsn->slots[i] = slotstack.insn[slotstack.ninsn - 1];
		}
	      else
		{
		  bundle_single_op (&slotstack.insn[slotstack.ninsn - 1]);
		  if (vinsn->format == XTENSA_UNDEFINED)
		    vinsn->slots[i].opcode = xtensa_nop_opcode;
		  else
		    vinsn->slots[i].opcode 
		      = xtensa_format_slot_nop_opcode (xtensa_default_isa,
						       vinsn->format, i);

		  vinsn->slots[i].ntok = 0;
		}
	    }
	  else
	    {
	      vinsn->slots[0] = slotstack.insn[slotstack.ninsn - 1];
	      vinsn->format = XTENSA_UNDEFINED;
	    }
	}
    }

  /* Now check resource conflicts on the modified bundle.  */
  if (resources_conflict (vinsn)) 
    {
      as_where (&file_name, &line);
      as_bad_where (file_name, line, _("illegal resource usage in bundle"));
      fprintf (stderr, "    ops were: ");
      for (i = 0; i < vinsn->num_slots; i++)
	fprintf (stderr, " %s;",
		 xtensa_opcode_name (xtensa_default_isa,
				     vinsn->slots[i].opcode));
      fprintf (stderr, "\n");
      xg_clear_vinsn (vinsn);
      return;
    }

  /* First, find a format that works.  */
  if (vinsn->format == XTENSA_UNDEFINED)
      vinsn->format = xg_find_narrowest_format (vinsn);

  xg_assemble_vliw_tokens (vinsn);

  xg_clear_vinsn (vinsn);
}


/* Given an vliw instruction, what conflicts are there in register
   usage and in writes to states and queues?

   This function does two things:
   1. Reports an error when a vinsn contains illegal combinations
      of writes to registers states or queues.
   2. Marks individual tinsns as not relaxable if the combination
      contains antidependencies.

   Job 2 handles things like swap semantics in instructions that need
   to be relaxed.  For example,

	addi a0, a1, 100000

   normally would be relaxed to

	l32r a0, some_label
	add a0, a1, a0

   _but_, if the above instruction is bundled with an a0 reader, e.g.,

	{ addi a0, a1, 10000 ; add a2, a0, a4 ; }

   then we can't relax it into

	l32r a0, some_label
	{ add a0, a1, a0 ; add a2, a0, a4 ; }

   because the value of a0 is trashed before the second add can read it.  */

static char check_t1_t2_reads_and_writes (TInsn *, TInsn *);

static bfd_boolean
find_vinsn_conflicts (vliw_insn *vinsn)
{
  int i, j;
  int branches = 0;
  xtensa_isa isa = xtensa_default_isa;

  assert (!past_xtensa_end);

  for (i = 0 ; i < vinsn->num_slots; i++)
    {
      TInsn *op1 = &vinsn->slots[i];
      if (op1->is_specific_opcode)
	op1->keep_wide = TRUE;
      else
	op1->keep_wide = FALSE;
    }

  for (i = 0 ; i < vinsn->num_slots; i++)
    {
      TInsn *op1 = &vinsn->slots[i];

      if (xtensa_opcode_is_branch (isa, op1->opcode) == 1)
	branches++;

      for (j = 0; j < vinsn->num_slots; j++)
	{
	  if (i != j)
	    {
	      TInsn *op2 = &vinsn->slots[j];
	      char conflict_type = check_t1_t2_reads_and_writes (op1, op2);
	      switch (conflict_type)
		{
		case 'c':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) write the same register"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		case 'd':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) write the same state"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		case 'e':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) write the same queue"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		case 'f':
		  as_bad (_("opcodes '%s' (slot %d) and '%s' (slot %d) both have volatile queue accesses"),
			  xtensa_opcode_name (isa, op1->opcode), i,
			  xtensa_opcode_name (isa, op2->opcode), j);
		  return TRUE;
		default:
		  /* Everything is OK.  */
		  break;
		}
	      op2->is_specific_opcode = (op2->is_specific_opcode
					 || conflict_type == 'a');
	    }
	}
    }

  if (branches > 1)
    {
      as_bad (_("multiple branches or jumps in the same bundle"));
      return TRUE;
    }

  return FALSE;
}


/* Check how the state used by t1 and t2 relate.
   Cases found are:

   case A: t1 reads a register t2 writes (an antidependency within a bundle)
   case B: no relationship between what is read and written (both could
           read the same reg though)
   case C: t1 writes a register t2 writes (a register conflict within a 
           bundle)
   case D: t1 writes a state that t2 also writes
   case E: t1 writes a tie queue that t2 also writes
   case F: two volatile queue accesses
*/

static char
check_t1_t2_reads_and_writes (TInsn *t1, TInsn *t2)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_regfile t1_regfile, t2_regfile;
  int t1_reg, t2_reg;
  int t1_base_reg, t1_last_reg;
  int t2_base_reg, t2_last_reg;
  char t1_inout, t2_inout;
  int i, j;
  char conflict = 'b';
  int t1_states;
  int t2_states;
  int t1_interfaces;
  int t2_interfaces;
  bfd_boolean t1_volatile = FALSE;
  bfd_boolean t2_volatile = FALSE;

  /* Check registers.  */
  for (j = 0; j < t2->ntok; j++)
    {
      if (xtensa_operand_is_register (isa, t2->opcode, j) != 1)
	continue;

      t2_regfile = xtensa_operand_regfile (isa, t2->opcode, j);
      t2_base_reg = t2->tok[j].X_add_number;
      t2_last_reg = t2_base_reg + xtensa_operand_num_regs (isa, t2->opcode, j);

      for (i = 0; i < t1->ntok; i++)
	{
	  if (xtensa_operand_is_register (isa, t1->opcode, i) != 1)
	    continue;

	  t1_regfile = xtensa_operand_regfile (isa, t1->opcode, i);

	  if (t1_regfile != t2_regfile)
	    continue;

	  t1_inout = xtensa_operand_inout (isa, t1->opcode, i);
	  t2_inout = xtensa_operand_inout (isa, t2->opcode, j);

	  if (xtensa_operand_is_known_reg (isa, t1->opcode, i) == 0
	      || xtensa_operand_is_known_reg (isa, t2->opcode, j) == 0)
	    {
	      if (t1_inout == 'm' || t1_inout == 'o'
		  || t2_inout == 'm' || t2_inout == 'o')
		{
		  conflict = 'a';
		  continue;
		}
	    }

	  t1_base_reg = t1->tok[i].X_add_number;
	  t1_last_reg = (t1_base_reg
			 + xtensa_operand_num_regs (isa, t1->opcode, i));

	  for (t1_reg = t1_base_reg; t1_reg < t1_last_reg; t1_reg++)
	    {
	      for (t2_reg = t2_base_reg; t2_reg < t2_last_reg; t2_reg++)
		{
		  if (t1_reg != t2_reg)
		    continue;

		  if (t2_inout == 'i' && (t1_inout == 'm' || t1_inout == 'o'))
		    {
		      conflict = 'a';
		      continue;
		    }

		  if (t1_inout == 'i' && (t2_inout == 'm' || t2_inout == 'o'))
		    {
		      conflict = 'a';
		      continue;
		    }

		  if (t1_inout != 'i' && t2_inout != 'i')
		    return 'c';
		}
	    }
	}
    }

  /* Check states.  */
  t1_states = xtensa_opcode_num_stateOperands (isa, t1->opcode);
  t2_states = xtensa_opcode_num_stateOperands (isa, t2->opcode);
  for (j = 0; j < t2_states; j++)
    {
      xtensa_state t2_so = xtensa_stateOperand_state (isa, t2->opcode, j);
      t2_inout = xtensa_stateOperand_inout (isa, t2->opcode, j);
      for (i = 0; i < t1_states; i++)
	{
	  xtensa_state t1_so = xtensa_stateOperand_state (isa, t1->opcode, i);
	  t1_inout = xtensa_stateOperand_inout (isa, t1->opcode, i);
	  if (t1_so != t2_so) 
	    continue;

	  if (t2_inout == 'i' && (t1_inout == 'm' || t1_inout == 'o'))
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout == 'i' && (t2_inout == 'm' || t2_inout == 'o'))
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout != 'i' && t2_inout != 'i')
	    return 'd';
	}      
    }

  /* Check tieports.  */
  t1_interfaces = xtensa_opcode_num_interfaceOperands (isa, t1->opcode);
  t2_interfaces = xtensa_opcode_num_interfaceOperands (isa, t2->opcode);
  for (j = 0; j < t2_interfaces; j++) 
    {
      xtensa_interface t2_int
	= xtensa_interfaceOperand_interface (isa, t2->opcode, j);
      int t2_class = xtensa_interface_class_id (isa, t2_int);

      t2_inout = xtensa_interface_inout (isa, j);
      if (xtensa_interface_has_side_effect (isa, t2_int) == 1)
	t2_volatile = TRUE;

      for (i = 0; i < t1_interfaces; i++)
	{
	  xtensa_interface t1_int
	    = xtensa_interfaceOperand_interface (isa, t1->opcode, j);
	  int t1_class = xtensa_interface_class_id (isa, t2_int);

	  t1_inout = xtensa_interface_inout (isa, i);
	  if (xtensa_interface_has_side_effect (isa, t1_int) == 1)
	    t1_volatile = TRUE;

	  if (t1_volatile && t2_volatile && (t1_class == t2_class))
	    return 'f';
	  
	  if (t1_int != t2_int)
	    continue;
	  
	  if (t2_inout == 'i' && t1_inout == 'o')
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout == 'i' && t2_inout == 'o')
	    {
	      conflict = 'a';
	      continue;
	    }
	  
	  if (t1_inout != 'i' && t2_inout != 'i')
	    return 'e';
	}
    }
  
  return conflict;
}


static xtensa_format
xg_find_narrowest_format (vliw_insn *vinsn)
{
  /* Right now we assume that the ops within the vinsn are properly
     ordered for the slots that the programmer wanted them in.  In
     other words, we don't rearrange the ops in hopes of finding a
     better format.  The scheduler handles that.  */

  xtensa_isa isa = xtensa_default_isa;
  xtensa_format format;
  vliw_insn v_copy = *vinsn;
  xtensa_opcode nop_opcode = xtensa_nop_opcode;

  for (format = 0; format < xtensa_isa_num_formats (isa); format++)
    {
      v_copy = *vinsn;
      if (xtensa_format_num_slots (isa, format) == v_copy.num_slots)
	{
	  int slot;
	  int fit = 0;
	  for (slot = 0; slot < v_copy.num_slots; slot++)
	    {
	      if (v_copy.slots[slot].opcode == nop_opcode)
		{
		  v_copy.slots[slot].opcode =
		    xtensa_format_slot_nop_opcode (isa, format, slot);
		  v_copy.slots[slot].ntok = 0;
		}

	      if (opcode_fits_format_slot (v_copy.slots[slot].opcode,
					   format, slot))
		fit++;
	      else if (v_copy.num_slots > 1)
		{
		  TInsn widened;
		  /* Try the widened version.  */
		  if (!v_copy.slots[slot].keep_wide
		      && !v_copy.slots[slot].is_specific_opcode
		      && xg_is_narrow_insn (&v_copy.slots[slot])
		      && !xg_expand_narrow (&widened, &v_copy.slots[slot])
		      && opcode_fits_format_slot (widened.opcode,
						  format, slot))
		    {
		      /* The xg_is_narrow clause requires some explanation:

			 addi can be "widened" to an addmi, which is then
			 expanded to an addmi/addi pair if the immediate
			 requires it, but here we must have a single widen
			 only.

			 xg_is_narrow tells us that addi isn't really
			 narrow.  The widen_spec_list says that there are
			 other cases.  */

		      v_copy.slots[slot] = widened;
		      fit++;
		    }
		}
	    }
	  if (fit == v_copy.num_slots)
	    {
	      *vinsn = v_copy;
	      xtensa_format_encode (isa, format, vinsn->insnbuf);
	      vinsn->format = format;
	      break;
	    }
	}
    }

  if (format == xtensa_isa_num_formats (isa))
    return XTENSA_UNDEFINED;

  return format;
}


/* Return the additional space needed in a frag
   for possible relaxations of any ops in a VLIW insn.
   Also fill out the relaxations that might be required of
   each tinsn in the vinsn.  */

static int
relaxation_requirements (vliw_insn *vinsn)
{
  int extra_space = 0;
  int slot;

  for (slot = 0; slot < vinsn->num_slots; slot++)
    {
      TInsn *tinsn = &vinsn->slots[slot];
      if (!tinsn_has_symbolic_operands (tinsn))
	{
	  /* A narrow instruction could be widened later to help
	     alignment issues.  */
	  if (xg_is_narrow_insn (tinsn)
	      && !tinsn->is_specific_opcode
	      && vinsn->num_slots == 1)
	    {
	      /* Difference in bytes between narrow and wide insns...  */
	      extra_space += 1;
	      tinsn->subtype = RELAX_NARROW;
	      tinsn->record_fix = TRUE;
	      break;
	    }
	  else
	    {
	      tinsn->record_fix = FALSE;
	      /* No extra_space needed.  */
	    }
	}
      else
	{
	  if (workaround_b_j_loop_end
	      && tinsn->opcode == xtensa_jx_opcode
	      && use_transform ())
	    {
	      /* Add 2 of these.  */
	      extra_space += 3; /* for the nop size */
	      tinsn->subtype = RELAX_ADD_NOP_IF_PRE_LOOP_END;
	    }
	  
	  /* Need to assemble it with space for the relocation.  */
	  if (xg_is_relaxable_insn (tinsn, 0)
	      && !tinsn->is_specific_opcode)
	    {
	      int max_size = xg_get_max_insn_widen_size (tinsn->opcode);
	      int max_literal_size =
		xg_get_max_insn_widen_literal_size (tinsn->opcode);
	      
	      tinsn->literal_space = max_literal_size;
	      
	      tinsn->subtype = RELAX_IMMED;
	      tinsn->record_fix = FALSE;
	      extra_space += max_size;
	    }
	  else
	    {
	      tinsn->record_fix = TRUE;
	      /* No extra space needed.  */
	    }
	}
    }
  return extra_space;
}


static void
bundle_single_op (TInsn *orig_insn)
{
  xtensa_isa isa = xtensa_default_isa;
  vliw_insn v;
  int slot;

  xg_init_vinsn (&v);
  v.format = op_placement_table[orig_insn->opcode].narrowest;
  assert (v.format != XTENSA_UNDEFINED);
  v.num_slots = xtensa_format_num_slots (isa, v.format);

  for (slot = 0;
       !opcode_fits_format_slot (orig_insn->opcode, v.format, slot);
       slot++)
    {
      v.slots[slot].opcode =
	xtensa_format_slot_nop_opcode (isa, v.format, slot);
      v.slots[slot].ntok = 0;
      v.slots[slot].insn_type = ITYPE_INSN;
    }

  v.slots[slot] = *orig_insn;
  slot++;

  for ( ; slot < v.num_slots; slot++)
    {
      v.slots[slot].opcode =
	xtensa_format_slot_nop_opcode (isa, v.format, slot);
      v.slots[slot].ntok = 0;
      v.slots[slot].insn_type = ITYPE_INSN;
    }

  finish_vinsn (&v);
  xg_free_vinsn (&v);
}


static bfd_boolean
emit_single_op (TInsn *orig_insn)
{
  int i;
  IStack istack;		/* put instructions into here */
  symbolS *lit_sym = NULL;
  symbolS *label_sym = NULL;

  istack_init (&istack);

  /* Special-case for "movi aX, foo" which is guaranteed to need relaxing.
     Because the scheduling and bundling characteristics of movi and 
     l32r or const16 are so different, we can do much better if we relax 
     it prior to scheduling and bundling, rather than after.  */
  if ((orig_insn->opcode == xtensa_movi_opcode 
       || orig_insn->opcode == xtensa_movi_n_opcode)
      && !cur_vinsn.inside_bundle
      && (orig_insn->tok[1].X_op == O_symbol
	  || orig_insn->tok[1].X_op == O_pltrel))
    xg_assembly_relax (&istack, orig_insn, now_seg, frag_now, 0, 1, 0);
  else
    if (xg_expand_assembly_insn (&istack, orig_insn))
      return TRUE;

  for (i = 0; i < istack.ninsn; i++)
    {
      TInsn *insn = &istack.insn[i];
      switch (insn->insn_type) 
	{
	case ITYPE_LITERAL:
	  assert (lit_sym == NULL);
	  lit_sym = xg_assemble_literal (insn);
	  break;
	case ITYPE_LABEL:
	  {
	    static int relaxed_sym_idx = 0;
	    char *label = xmalloc (strlen (FAKE_LABEL_NAME) + 12);
	    sprintf (label, "%s_rl_%x", FAKE_LABEL_NAME, relaxed_sym_idx++);
	    colon (label);
	    assert (label_sym == NULL);
	    label_sym = symbol_find_or_make (label);
	    assert (label_sym);
	    free (label);
	  }
	  break;
	case ITYPE_INSN:
	  if (lit_sym)
	    xg_resolve_literals (insn, lit_sym);
	  if (label_sym)
	    xg_resolve_labels (insn, label_sym);
	  bundle_single_op (insn);
	  break;
	default:
	  assert (0);
	  break;
	}
    }
  return FALSE;
}


static int
total_frag_text_expansion (fragS *fragP)
{
  int slot;
  int total_expansion = 0;

  for (slot = 0; slot < MAX_SLOTS; slot++)
    total_expansion += fragP->tc_frag_data.text_expansion[slot];

  return total_expansion;
}


/* Emit a vliw instruction to the current fragment.  */

static void
xg_assemble_vliw_tokens (vliw_insn *vinsn)
{
  bfd_boolean finish_frag = FALSE;
  bfd_boolean is_jump = FALSE;
  bfd_boolean is_branch = FALSE;
  xtensa_isa isa = xtensa_default_isa;
  int i;
  int insn_size;
  int extra_space;
  char *f = NULL;
  int slot;
  struct dwarf2_line_info best_loc;

  best_loc.line = INT_MAX;

  if (generating_literals)
    {
      static int reported = 0;
      if (reported < 4)
	as_bad_where (frag_now->fr_file, frag_now->fr_line,
		      _("cannot assemble into a literal fragment"));
      if (reported == 3)
	as_bad (_("..."));
      reported++;
      return;
    }

  if (frag_now_fix () != 0
      && (! frag_now->tc_frag_data.is_insn
 	  || (vinsn_has_specific_opcodes (vinsn) && use_transform ())
 	  || !use_transform () != frag_now->tc_frag_data.is_no_transform
 	  || (directive_state[directive_absolute_literals]
	      != frag_now->tc_frag_data.use_absolute_literals)))
    {
      frag_wane (frag_now);
      frag_new (0);
      xtensa_set_frag_assembly_state (frag_now);
    }

  if (workaround_a0_b_retw
      && vinsn->num_slots == 1
      && (get_last_insn_flags (now_seg, now_subseg) & FLAG_IS_A0_WRITER) != 0
      && xtensa_opcode_is_branch (isa, vinsn->slots[0].opcode) == 1
      && use_transform ())
    {
      has_a0_b_retw = TRUE;

      /* Mark this fragment with the special RELAX_ADD_NOP_IF_A0_B_RETW.
	 After the first assembly pass we will check all of them and
	 add a nop if needed.  */
      frag_now->tc_frag_data.is_insn = TRUE;
      frag_var (rs_machine_dependent, 4, 4,
		RELAX_ADD_NOP_IF_A0_B_RETW,
		frag_now->fr_symbol,
		frag_now->fr_offset,
		NULL);
      xtensa_set_frag_assembly_state (frag_now);
      frag_now->tc_frag_data.is_insn = TRUE;
      frag_var (rs_machine_dependent, 4, 4,
		RELAX_ADD_NOP_IF_A0_B_RETW,
		frag_now->fr_symbol,
		frag_now->fr_offset,
		NULL);
      xtensa_set_frag_assembly_state (frag_now);
    }

  for (i = 0; i < vinsn->num_slots; i++)
    {
      /* See if the instruction implies an aligned section.  */
      if (xtensa_opcode_is_loop (isa, vinsn->slots[i].opcode) == 1)
	record_alignment (now_seg, 2);
      
      /* Also determine the best line number for debug info.  */
      best_loc = vinsn->slots[i].loc.line < best_loc.line 
	? vinsn->slots[i].loc : best_loc;
    }

  /* Special cases for instructions that force an alignment... */
  /* None of these opcodes are bundle-able.  */
  if (xtensa_opcode_is_loop (isa, vinsn->slots[0].opcode) == 1)
    {
      size_t max_fill;
      
      xtensa_set_frag_assembly_state (frag_now);
      frag_now->tc_frag_data.is_insn = TRUE;
      
      max_fill = get_text_align_max_fill_size
	(get_text_align_power (xtensa_fetch_width),
	 TRUE, frag_now->tc_frag_data.is_no_density);

      if (use_transform ())
	frag_var (rs_machine_dependent, max_fill, max_fill,
		  RELAX_ALIGN_NEXT_OPCODE,
		  frag_now->fr_symbol,
		  frag_now->fr_offset,
		  NULL);
      else
	frag_var (rs_machine_dependent, 0, 0, 
		  RELAX_CHECK_ALIGN_NEXT_OPCODE, 0, 0, NULL);
      xtensa_set_frag_assembly_state (frag_now);
      
      xtensa_move_labels (frag_now, 0, FALSE);
    }

  if (vinsn->slots[0].opcode == xtensa_entry_opcode
      && !vinsn->slots[0].is_specific_opcode)
    {
      xtensa_mark_literal_pool_location ();
      xtensa_move_labels (frag_now, 0, TRUE);
      frag_var (rs_align_test, 1, 1, 0, NULL, 2, NULL);
    }

  if (vinsn->num_slots == 1)
    {
      if (workaround_a0_b_retw && use_transform ())
	set_last_insn_flags (now_seg, now_subseg, FLAG_IS_A0_WRITER,
			     is_register_writer (&vinsn->slots[0], "a", 0));

      set_last_insn_flags (now_seg, now_subseg, FLAG_IS_BAD_LOOPEND,
			   is_bad_loopend_opcode (&vinsn->slots[0]));
    }
  else
    set_last_insn_flags (now_seg, now_subseg, FLAG_IS_BAD_LOOPEND, FALSE);

  insn_size = xtensa_format_length (isa, vinsn->format);

  extra_space = relaxation_requirements (vinsn);

  /* vinsn_to_insnbuf will produce the error.  */
  if (vinsn->format != XTENSA_UNDEFINED)
    {
      f = (char *) frag_more (insn_size + extra_space);
      xtensa_set_frag_assembly_state (frag_now);
      frag_now->tc_frag_data.is_insn = TRUE;
    }

  vinsn_to_insnbuf (vinsn, f, frag_now, TRUE);
  if (vinsn->format == XTENSA_UNDEFINED)
    return;

  xtensa_insnbuf_to_chars (isa, vinsn->insnbuf, f, 0);
  
  xtensa_dwarf2_emit_insn (insn_size - extra_space, &best_loc);

  for (slot = 0; slot < vinsn->num_slots; slot++)
d5337 4
a5340 19
      TInsn *tinsn = &vinsn->slots[slot];
      frag_now->tc_frag_data.slot_subtypes[slot] = tinsn->subtype;
      frag_now->tc_frag_data.slot_symbols[slot] =  tinsn->symbol;
      frag_now->tc_frag_data.slot_sub_symbols[slot] =  tinsn->sub_symbol;
      frag_now->tc_frag_data.slot_offsets[slot] =  tinsn->offset;
      frag_now->tc_frag_data.literal_frags[slot] = tinsn->literal_frag;
      if (tinsn->literal_space != 0)
	xg_assemble_literal_space (tinsn->literal_space, slot);

      if (tinsn->subtype == RELAX_NARROW)
	assert (vinsn->num_slots == 1);
      if (xtensa_opcode_is_jump (isa, tinsn->opcode) == 1)
	is_jump = TRUE;
      if (xtensa_opcode_is_branch (isa, tinsn->opcode) == 1)
	is_branch = TRUE;

      if (tinsn->subtype || tinsn->symbol || tinsn->record_fix 
	  || tinsn->offset || tinsn->literal_frag || is_jump || is_branch)
	finish_frag = TRUE;
d5343 1
a5343 4
  if (vinsn_has_specific_opcodes (vinsn) && use_transform ())
    frag_now->tc_frag_data.is_specific_opcode = TRUE;

  if (finish_frag)
d5345 2
a5346 4
      frag_variant (rs_machine_dependent,
		    extra_space, extra_space, RELAX_SLOTS,
		    frag_now->fr_symbol, frag_now->fr_offset, f);
      xtensa_set_frag_assembly_state (frag_now);
d5348 1
d5350 1
a5350 4
  /* Special cases for loops:
     close_loop_end should be inserted AFTER short_loop.
     Make sure that CLOSE loops are processed BEFORE short_loops
     when converting them.  */
d5352 1
a5352 3
  /* "short_loop": Add a NOP if the loop is < 4 bytes.  */
  if (xtensa_opcode_is_loop (isa, vinsn->slots[0].opcode)
      && !vinsn->slots[0].is_specific_opcode)
d5354 9
a5362 12
      if (workaround_short_loop && use_transform ())
	{
	  maybe_has_short_loop = TRUE;
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 4, 4,
		    RELAX_ADD_NOP_IF_SHORT_LOOP,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 4, 4,
		    RELAX_ADD_NOP_IF_SHORT_LOOP,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	}
d5364 3
a5366 11
      /* "close_loop_end": Add up to 12 bytes of NOPs to keep a
	 loop at least 12 bytes away from another loop's end.  */
      if (workaround_close_loop_end && use_transform ())
	{
	  maybe_has_close_loop_end = TRUE;
	  frag_now->tc_frag_data.is_insn = TRUE;
	  frag_var (rs_machine_dependent, 12, 12,
		    RELAX_ADD_NOP_IF_CLOSE_LOOP_END,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	}
    }
d5368 2
a5369 25
  if (use_transform ())
    {
      if (is_jump)
	{
	  assert (finish_frag);
	  frag_var (rs_machine_dependent,
		    UNREACHABLE_MAX_WIDTH, UNREACHABLE_MAX_WIDTH,
		    RELAX_UNREACHABLE,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  xtensa_set_frag_assembly_state (frag_now);
	}
      else if (is_branch && align_targets)
	{
	  assert (finish_frag);
	  frag_var (rs_machine_dependent,
		    UNREACHABLE_MAX_WIDTH, UNREACHABLE_MAX_WIDTH,
		    RELAX_MAYBE_UNREACHABLE,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  xtensa_set_frag_assembly_state (frag_now);
	  frag_var (rs_machine_dependent,
		    0, 0,
		    RELAX_MAYBE_DESIRE_ALIGN,
		    frag_now->fr_symbol, frag_now->fr_offset, NULL);
	  xtensa_set_frag_assembly_state (frag_now);
	}
d5372 1
a5372 17
  /* Now, if the original opcode was a call...  */
  if (do_align_targets ()
      && xtensa_opcode_is_call (isa, vinsn->slots[0].opcode) == 1)
    {
      float freq = get_subseg_total_freq (now_seg, now_subseg);
      frag_now->tc_frag_data.is_insn = TRUE;
      frag_var (rs_machine_dependent, 4, (int) freq, RELAX_DESIRE_ALIGN,
		frag_now->fr_symbol, frag_now->fr_offset, NULL);
      xtensa_set_frag_assembly_state (frag_now);
    }

  if (vinsn_has_specific_opcodes (vinsn) && use_transform ())
    {
      frag_wane (frag_now);
      frag_new (0);
      xtensa_set_frag_assembly_state (frag_now);
    }
a5375 12
/* xtensa_end and helper functions.  */

static void xtensa_cleanup_align_frags (void);
static void xtensa_fix_target_frags (void);
static void xtensa_mark_narrow_branches (void);
static void xtensa_mark_zcl_first_insns (void);
static void xtensa_fix_a0_b_retw_frags (void);
static void xtensa_fix_b_j_loop_end_frags (void);
static void xtensa_fix_close_loop_end_frags (void);
static void xtensa_fix_short_loop_frags (void);
static void xtensa_sanity_check (void);

d5377 1
a5377 1
xtensa_end (void)
a5379 4
  xtensa_flush_pending_output ();

  past_xtensa_end = TRUE;

d5385 1
a5385 1
  if (workaround_a0_b_retw && has_a0_b_retw)
d5387 1
a5387 1
  if (workaround_b_j_loop_end)
d5391 1
a5391 1
  if (workaround_close_loop_end && maybe_has_close_loop_end)
d5394 1
a5394 1
  if (workaround_short_loop && maybe_has_short_loop)
a5395 2
  xtensa_mark_narrow_branches ();
  xtensa_mark_zcl_first_insns ();
d5402 1
a5402 1
xtensa_cleanup_align_frags (void)
d5409 1
d5420 1
a5420 1
	      fragS *next = fragP->fr_next;
d5423 2
a5424 3
		     && next->fr_fix == 0
		     && next->fr_type == rs_machine_dependent
		     && next->fr_subtype == RELAX_DESIRE_ALIGN_IF_TARGET)
a5429 11
	  /* If we don't widen branch targets, then they
	     will be easier to align.  */
	  if (fragP->tc_frag_data.is_branch_target
	      && fragP->fr_opcode == fragP->fr_literal
	      && fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_SLOTS
	      && fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
	    frag_wane (fragP);
	  if (fragP->fr_type == rs_machine_dependent 
	      && fragP->fr_subtype == RELAX_UNREACHABLE)
	    fragP->tc_frag_data.is_unreachable = TRUE;
a5441 2
static bfd_boolean frag_can_negate_branch (fragS *);

d5443 1
a5443 1
xtensa_fix_target_frags (void)
d5463 1
a5463 6
		    {
		      fragP->fr_subtype = RELAX_LOOP_END;
		      /* See the comment near the frag_var with a
			 RELAX_DESIRE_ALIGN to see why we do this.  */
		      fragP->fr_var = RELAX_LOOP_END_BYTES;
		    }
d5466 2
a5467 1
		      if (next_frag_is_branch_target (fragP))
d5473 2
a5474 1
	      else if (next_frag_is_branch_target (fragP))
d5489 2
a5490 1
frag_can_negate_branch (fragS *fragP)
d5492 2
a5493 11
  xtensa_isa isa = xtensa_default_isa;
  vliw_insn vinsn;
  int slot;

  if (fragP->fr_type != rs_machine_dependent
      || fragP->fr_subtype != RELAX_SLOTS)
    return FALSE;

  vinsn_from_chars (&vinsn, fragP->fr_opcode);

  for (slot = 0; slot < xtensa_format_num_slots (isa, vinsn.format); slot++)
d5495 3
a5497 2
      if ((fragP->tc_frag_data.slot_subtypes[slot] == RELAX_IMMED)
	  && xtensa_opcode_is_branch (isa, vinsn.slots[slot].opcode) == 1)
a5499 87

  return FALSE;
}


static bfd_boolean is_narrow_branch_guaranteed_in_range (fragS *, TInsn *);

static void
xtensa_mark_narrow_branches (void)
{
  frchainS *frchP;

  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;
      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && fragP->fr_subtype == RELAX_SLOTS
	      && fragP->tc_frag_data.slot_subtypes[0] == RELAX_IMMED)
	    {
	      vliw_insn vinsn;
	      const expressionS *expr;
	      symbolS *symbolP;

	      vinsn_from_chars (&vinsn, fragP->fr_opcode);
	      tinsn_immed_from_frag (&vinsn.slots[0], fragP, 0);

	      expr = &vinsn.slots[0].tok[1];
	      symbolP = expr->X_add_symbol;

	      if (vinsn.num_slots == 1
		  && xtensa_opcode_is_branch (xtensa_default_isa,
					      vinsn.slots[0].opcode)
		  && xg_get_single_size (vinsn.slots[0].opcode) == 2
		  && is_narrow_branch_guaranteed_in_range (fragP,
							   &vinsn.slots[0]))
		{
		  fragP->fr_subtype = RELAX_SLOTS;
		  fragP->tc_frag_data.slot_subtypes[0] = RELAX_NARROW;
		}
	    }
	}
    }
}


/* A branch is typically widened only when its target is out of
   range.  However, we would like to widen them to align a subsequent
   branch target when possible.

   Because the branch relaxation code is so convoluted, the optimal solution
   (combining the two cases) is difficult to get right in all circumstances.
   We therefore go with an "almost as good" solution, where we only
   use for alignment narrow branches that definitely will not expand to a
   jump and a branch.  These functions find and mark these cases.  */

/* The range in bytes of BNEZ.N and BEQZ.N.  The target operand is encoded
   as PC + 4 + imm6, where imm6 is a 6-bit immediate ranging from 0 to 63.
   We start counting beginning with the frag after the 2-byte branch, so the
   maximum offset is (4 - 2) + 63 = 65.  */
#define MAX_IMMED6 65

static size_t unrelaxed_frag_max_size (fragS *);

static bfd_boolean
is_narrow_branch_guaranteed_in_range (fragS *fragP, TInsn *tinsn)
{
  const expressionS *expr = &tinsn->tok[1];
  symbolS *symbolP = expr->X_add_symbol;
  fragS *target_frag = symbol_get_frag (symbolP);
  size_t max_distance = expr->X_add_number;
  max_distance += (S_GET_VALUE (symbolP) - target_frag->fr_address);
  if (is_branch_jmp_to_next (tinsn, fragP))
    return FALSE;

  /* The branch doesn't branch over it's own frag,
     but over the subsequent ones.  */
  fragP = fragP->fr_next;
  while (fragP != NULL && fragP != target_frag && max_distance <= MAX_IMMED6)
    {
      max_distance += unrelaxed_frag_max_size (fragP);
      fragP = fragP->fr_next;
    }
  if (max_distance <= MAX_IMMED6 && fragP == target_frag)
    return TRUE;
a5503 34
static void
xtensa_mark_zcl_first_insns (void)
{
  frchainS *frchP;

  for (frchP = frchain_root; frchP; frchP = frchP->frch_next)
    {
      fragS *fragP;
      /* Walk over all of the fragments in a subsection.  */
      for (fragP = frchP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  if (fragP->fr_type == rs_machine_dependent
	      && (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE
		  || fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE))
	    {
	      /* Find the loop frag.  */
	      fragS *targ_frag = next_non_empty_frag (fragP);
	      /* Find the first insn frag.  */
	      targ_frag = next_non_empty_frag (targ_frag);

	      /* Of course, sometimes (mostly for toy test cases) a
		 zero-cost loop instruction is the last in a section.  */
	      if (targ_frag) 
		{
		  targ_frag->tc_frag_data.is_first_loop_insn = TRUE;
		  if (fragP->fr_subtype == RELAX_CHECK_ALIGN_NEXT_OPCODE)
		    frag_wane (fragP);
		}
	    }
	}
    }
}


a5508 2
static bfd_boolean next_instrs_are_b_retw (fragS *);

d5510 1
a5510 1
xtensa_fix_a0_b_retw_frags (void)
d5527 3
a5529 7
		{
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("instruction sequence (write a0, branch, retw) may trigger hardware errata"));
		  else
		    relax_frag_add_nop (fragP);
		}
	      frag_wane (fragP);
d5536 3
a5538 2
static bfd_boolean
next_instrs_are_b_retw (fragS *fragP)
a5540 1
  xtensa_format fmt;
a5542 1
  static xtensa_insnbuf slotbuf = NULL;
a5544 2
  int slot;
  bfd_boolean branch_seen = FALSE;
d5547 1
a5547 4
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }
d5553 2
a5554 13
  xtensa_insnbuf_from_chars (isa, insnbuf, &next_fragP->fr_literal[offset], 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    return FALSE;

  for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
    {
      xtensa_format_get_slot (isa, fmt, slot, insnbuf, slotbuf);
      opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);

      branch_seen = (branch_seen
		     || xtensa_opcode_is_branch (isa, opcode) == 1);
    }
d5556 1
a5556 1
  if (!branch_seen)
d5559 1
a5559 1
  offset += xtensa_format_length (isa, fmt);
a5564 1

d5569 2
a5570 8
  xtensa_insnbuf_from_chars (isa, insnbuf, &next_fragP->fr_literal[offset], 0);
  fmt = xtensa_format_decode (isa, insnbuf);

  /* Because RETW[.N] is not bundleable, a VLIW bundle here means that we
     have no problems.  */
  if (fmt == XTENSA_UNDEFINED
      || xtensa_format_num_slots (isa, fmt) != 1)
    return FALSE;
d5572 1
a5572 4
  xtensa_format_get_slot (isa, fmt, 0, insnbuf, slotbuf);
  opcode = xtensa_opcode_decode (isa, fmt, 0, slotbuf);

  if (opcode == xtensa_retw_opcode || opcode == xtensa_retw_n_opcode)
a5573 1

a5582 2
static bfd_boolean next_instr_is_loop_end (fragS *);

d5584 1
a5584 1
xtensa_fix_b_j_loop_end_frags (void)
d5601 3
a5603 7
		{
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("branching or jumping to a loop end may trigger hardware errata"));
		  else
		    relax_frag_add_nop (fragP);
		}
	      frag_wane (fragP);
d5610 3
a5612 2
static bfd_boolean
next_instr_is_loop_end (fragS *fragP)
a5640 2
static size_t min_bytes_to_other_loop_end (fragS *, fragS *, offsetT, size_t);

d5642 1
a5642 1
xtensa_fix_close_loop_end_frags (void)
d5659 1
a5659 4
	      && ((fragP->fr_subtype == RELAX_IMMED)
		  || ((fragP->fr_subtype == RELAX_SLOTS)
		      && (fragP->tc_frag_data.slot_subtypes[0]
			  == RELAX_IMMED))))
d5662 2
a5663 4
	      TInsn t_insn;
	      tinsn_from_chars (&t_insn, fragP->fr_opcode, 0);
	      if (xtensa_opcode_is_loop (xtensa_default_isa,
					 t_insn.opcode) == 1)
d5665 5
d5671 1
a5671 1
		  if (fragP->tc_frag_data.slot_symbols[0])
d5673 1
a5673 2
		      symbolS *sym = fragP->tc_frag_data.slot_symbols[0];
		      current_target = symbol_get_frag (sym);
d5694 2
a5695 3
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("loop end too close to another loop end may trigger hardware errata"));
		  else
d5697 6
a5702 2
		      while (min_bytes + bytes_added
			     < REQUIRED_LOOP_DIVIDING_BYTES)
d5704 4
a5707 13
			  int length = 3;
			  
			  if (fragP->fr_var < length)
			    as_fatal (_("fr_var %lu < length %d"),
				      fragP->fr_var, length);
			  else
			    {
			      assemble_nop (length,
					    fragP->fr_literal + fragP->fr_fix);
			      fragP->fr_fix += length;
			      fragP->fr_var -= length;
			    }
			  bytes_added += length;
d5709 1
a5713 2
	  assert (fragP->fr_type != rs_machine_dependent
		  || fragP->fr_subtype != RELAX_ADD_NOP_IF_CLOSE_LOOP_END);
d5719 6
a5724 7
static size_t unrelaxed_frag_min_size (fragS *);

static size_t
min_bytes_to_other_loop_end (fragS *fragP,
			     fragS *current_target,
			     offsetT current_offset,
			     size_t max_size)
d5746 3
a5748 2
static size_t
unrelaxed_frag_min_size (fragS *fragP)
a5759 37
static size_t
unrelaxed_frag_max_size (fragS *fragP)
{
  size_t size = fragP->fr_fix;
  switch (fragP->fr_type)
    {
    case 0:
      /* Empty frags created by the obstack allocation scheme 
	 end up with type 0.  */
      break;
    case rs_fill:
    case rs_org:
    case rs_space:
      size += fragP->fr_offset;
      break;
    case rs_align:
    case rs_align_code:
    case rs_align_test:
    case rs_leb128:
    case rs_cfa:
    case rs_dwarf2dbg:
      /* No further adjustments needed.  */
      break;
    case rs_machine_dependent:
      if (fragP->fr_subtype != RELAX_DESIRE_ALIGN)
	size += fragP->fr_var;
      break;
    default:
      /* We had darn well better know how big it is.  */
      assert (0);
      break;
    }

  return size;
}


d5769 1
a5769 1
     1) workaround_all_short_loops is TRUE
a5775 3
static size_t count_insns_to_loop_end (fragS *, bfd_boolean, size_t);
static bfd_boolean branch_before_loop_end (fragS *);

d5777 1
a5777 1
xtensa_fix_short_loop_frags (void)
d5793 1
a5793 1
	  /* Check on the current loop.  */
d5795 1
a5795 4
	      && ((fragP->fr_subtype == RELAX_IMMED)
		  || ((fragP->fr_subtype == RELAX_SLOTS)
		      && (fragP->tc_frag_data.slot_subtypes[0]
			  == RELAX_IMMED))))
a5796 2
	      TInsn t_insn;

d5798 2
a5799 3
	      tinsn_from_chars (&t_insn, fragP->fr_opcode, 0);
	      if (xtensa_opcode_is_loop (xtensa_default_isa,
					 t_insn.opcode) == 1)
d5801 5
d5807 1
a5807 1
		  if (fragP->tc_frag_data.slot_symbols[0])
d5809 1
a5809 2
		      symbolS *sym = fragP->tc_frag_data.slot_symbols[0];
		      current_target = symbol_get_frag (sym);
d5811 1
a5811 1
		      current_opcode = t_insn.opcode;
d5823 1
a5823 1
		      || (workaround_all_short_loops
d5825 4
a5828 8
			  && current_opcode != xtensa_loop_opcode)))
		{
		  if (fragP->tc_frag_data.is_no_transform)
		    as_bad (_("loop containing less than three instructions may trigger hardware errata"));
		  else
		    relax_frag_add_nop (fragP);
		}
	      frag_wane (fragP);
d5835 5
a5839 6
static size_t unrelaxed_frag_min_insn_count (fragS *);

static size_t
count_insns_to_loop_end (fragS *base_fragP,
			 bfd_boolean count_relax_add,
			 size_t max_count)
d5870 3
a5872 2
static size_t
unrelaxed_frag_min_insn_count (fragS *fragP)
a5873 2
  xtensa_isa isa = xtensa_default_isa;
  static xtensa_insnbuf insnbuf = NULL;
a5879 3
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

d5883 2
a5884 6
      xtensa_format fmt;

      xtensa_insnbuf_from_chars (isa, insnbuf, fragP->fr_literal + offset, 0);
      fmt = xtensa_format_decode (isa, insnbuf);

      if (fmt == XTENSA_UNDEFINED)
d5889 1
a5889 1
      offset += xtensa_format_length (isa, fmt);
d5897 3
a5899 4
static bfd_boolean unrelaxed_frag_has_b_j (fragS *);

static bfd_boolean
branch_before_loop_end (fragS *base_fragP)
d5914 3
a5916 2
static bfd_boolean
unrelaxed_frag_has_b_j (fragS *fragP)
d5918 1
a5918 2
  static xtensa_insnbuf insnbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
a5923 3
  if (!insnbuf)
    insnbuf = xtensa_insnbuf_alloc (isa);

d5927 2
a5928 9
      xtensa_format fmt;
      int slot;

      xtensa_insnbuf_from_chars (isa, insnbuf, fragP->fr_literal + offset, 0);
      fmt = xtensa_format_decode (isa, insnbuf);
      if (fmt == XTENSA_UNDEFINED)
	return FALSE;

      for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
d5930 2
a5931 5
	  xtensa_opcode opcode =
	    get_opcode_from_buf (fragP->fr_literal + offset, slot);
	  if (xtensa_opcode_is_branch (isa, opcode) == 1
	      || xtensa_opcode_is_jump (isa, opcode) == 1)
	    return TRUE;
d5933 3
a5935 1
      offset += xtensa_format_length (isa, fmt);
a5942 3
static bfd_boolean is_empty_loop (const TInsn *, fragS *);
static bfd_boolean is_local_forward_loop (const TInsn *, fragS *);

d5944 1
a5944 1
xtensa_sanity_check (void)
d5970 2
a5971 2
		  tinsn_from_chars (&t_insn, fragP->fr_opcode, 0);
		  tinsn_immed_from_frag (&t_insn, fragP, 0);
d5973 1
a5973 2
		  if (xtensa_opcode_is_loop (xtensa_default_isa,
					     t_insn.opcode) == 1)
d5997 1
a5997 1
/* Return TRUE if the loop target is the next non-zero fragment.  */
d5999 4
a6002 2
static bfd_boolean
is_empty_loop (const TInsn *insn, fragS *fragP)
d6011 1
a6011 1
  if (xtensa_opcode_is_loop (xtensa_default_isa, insn->opcode) != 1)
a6033 1

d6047 4
a6050 2
static bfd_boolean
is_local_forward_loop (const TInsn *insn, fragS *fragP)
d6059 1
a6059 1
  if (xtensa_opcode_is_loop (xtensa_default_isa, insn->opcode) == 0)
a6078 1

d6082 2
a6083 4
    {
      if (next_fragP == symbol_get_frag (symbolP))
	return TRUE;
    }
d6091 3
a6093 2
static size_t
get_text_align_power (int target_size)
d6101 1
a6101 1
  assert (0);
d6106 5
a6110 4
static addressT
get_text_align_max_fill_size (int align_pow,
			      bfd_boolean use_nops,
			      bfd_boolean use_no_density)
d6122 1
a6122 1

a6131 1
                  = 4 (for 4 byte target)
d6143 8
a6150 6
static addressT
get_text_align_fill_size (addressT address,
			  int align_pow,
			  int target_size,
			  bfd_boolean use_nops,
			  bfd_boolean use_no_density)
d6159 1
a6159 1
     use_nops: if TRUE, then we can only use 2- or 3-byte nops.
d6164 3
a6166 14
     Usually the align_pow is the power of 2 that is greater than 
     or equal to the target_size.  This handles the 2-byte, 3-byte 
     and 8-byte instructions.

     Two cases:

     (1) aligning an instruction properly, but without using NOPs.
       E.G.: a 3-byte instruction can go on any address where address mod 4
       is zero or one.  The aligner uses this case to find the optimal
       number of fill bytes for relax_frag_for_align.

     (2) aligning an instruction properly, but where we might need to use
       extra NOPs.  E.G.: when the aligner couldn't find enough widenings
       or similar to get the optimal location.  */
a6168 3

  assert (target_size != 0);
  
d6171 7
a6177 9
      unsigned fill_bytes;
      for (fill_bytes = 0; fill_bytes < alignment; fill_bytes++)
	{
	  addressT end_address = address + target_size - 1 + fill_bytes;
	  addressT start_address = address + fill_bytes;
	  if ((end_address >> align_pow) == (start_address >> align_pow))
	    return fill_bytes;
	}
      assert (0);
d6190 2
a6191 2
	  if ((address + i) >> align_pow
	      == (address + i + target_size - 1) >> align_pow)
d6202 2
a6203 2
	  if ((address + i) >> align_pow
	      == (address + i + target_size - 1) >> align_pow)
d6214 4
a6217 2
static size_t
get_text_align_nop_count (size_t fill_size, bfd_boolean use_no_density)
d6241 5
a6245 4
static size_t
get_text_align_nth_nop_size (size_t fill_size,
			     size_t n,
			     bfd_boolean use_no_density)
d6265 27
a6291 2
  return 0;
}
d6293 2
d6296 2
a6297 2
/* For the given fragment, find the appropriate address
   for it to begin at if we are using NOPs to align it.  */
d6299 3
a6301 25
static addressT
get_noop_aligned_address (fragS *fragP, addressT address)
{
  /* The rule is: get next fragment's FIRST instruction.  Find
     the smallest number of bytes that need to be added to
     ensure that the next fragment's FIRST instruction will fit
     in a single word.
     
     E.G.,   2 bytes : 0, 1, 2 mod 4
	     3 bytes: 0, 1 mod 4
     
     If the FIRST instruction MIGHT be relaxed,
     assume that it will become a 3-byte instruction.
     
     Note again here that LOOP instructions are not bundleable,
     and this relaxation only applies to LOOP opcodes.  */
  
  size_t fill_size = 0;
  int first_insn_size;
  int loop_insn_size;
  addressT pre_opcode_bytes;
  size_t alignment;
  fragS *first_insn;
  xtensa_opcode opcode;
  bfd_boolean is_loop;
d6303 6
a6308 2
  assert (fragP->fr_type == rs_machine_dependent);
  assert (fragP->fr_subtype == RELAX_ALIGN_NEXT_OPCODE);
d6310 1
a6310 4
  /* Find the loop frag.  */
  first_insn = next_non_empty_frag (fragP);
  /* Now find the first insn frag.  */
  first_insn = next_non_empty_frag (first_insn);
d6312 1
a6312 3
  is_loop = next_frag_opcode_is_loop (fragP, &opcode);
  assert (is_loop);
  loop_insn_size = xg_get_single_size (opcode);
d6314 6
a6319 2
  pre_opcode_bytes = next_frag_pre_opcode_bytes (fragP);
  pre_opcode_bytes += loop_insn_size;
d6321 1
a6321 2
  /* For loops, the alignment depends on the size of the
     instruction following the loop, not the LOOP instruction.  */
d6323 8
a6330 2
  if (first_insn == NULL)
    return address;
d6332 3
a6334 1
  assert (first_insn->tc_frag_data.is_first_loop_insn);
d6336 3
a6338 1
  first_insn_size = frag_format_size (first_insn);
d6340 5
a6344 2
  if (first_insn_size == 2 || first_insn_size == XTENSA_UNDEFINED)
    first_insn_size = 3;	/* ISA specifies this */
d6346 17
a6362 10
  /* If it was 8, then we'll need a larger alignment for the section.  */
  alignment = get_text_align_power (first_insn_size);

  /* Is now_seg valid?  */
  record_alignment (now_seg, alignment);
  
  fill_size = get_text_align_fill_size
    (address + pre_opcode_bytes,
     get_text_align_power (first_insn_size),
     first_insn_size, TRUE, fragP->tc_frag_data.is_no_density);
d6368 7
a6374 7
/* 3 mechanisms for relaxing an alignment:

   Align to a power of 2.
   Align so the next fragment's instruction does not cross a word boundary.
   Align the current instruction so that if the next instruction
       were 3 bytes, it would not cross a word boundary.

d6377 6
a6382 6
   zeros    - This is easy; always insert zeros.
   nops     - 3-byte and 2-byte instructions
              2 - 2-byte nop
              3 - 3-byte nop
              4 - 2 2-byte nops
              >=5 : 3-byte instruction + fn (n-3)
d6386 3
a6388 1
get_aligned_diff (fragS *fragP, addressT address, addressT *max_diff)
d6390 8
a6397 6
  addressT target_address, loop_insn_offset;
  int target_size;
  xtensa_opcode loop_opcode;
  bfd_boolean is_loop;
  int text_align_power;
  addressT opt_diff;
d6399 1
a6399 2
  assert (fragP->fr_type == rs_machine_dependent);
  switch (fragP->fr_subtype)
d6401 74
a6474 12
    case RELAX_DESIRE_ALIGN:
      target_size = next_frag_format_size (fragP);
      if (target_size == XTENSA_UNDEFINED)
	target_size = 3;
      text_align_power = get_text_align_power (xtensa_fetch_width);
      opt_diff = get_text_align_fill_size (address, text_align_power,
					   target_size, FALSE, FALSE);

      *max_diff = opt_diff + xtensa_fetch_width
	- (target_size + ((address + opt_diff) % xtensa_fetch_width));
      assert (*max_diff >= opt_diff);
      return opt_diff;
d6476 4
a6479 33
    case RELAX_ALIGN_NEXT_OPCODE:
      target_size = next_frag_format_size (fragP);
      loop_insn_offset = 0;
      is_loop = next_frag_opcode_is_loop (fragP, &loop_opcode);
      assert (is_loop);

      /* If the loop has been expanded then the LOOP instruction
	 could be at an offset from this fragment.  */
      if (next_non_empty_frag(fragP)->tc_frag_data.slot_subtypes[0]
	  != RELAX_IMMED)
	loop_insn_offset = get_expanded_loop_offset (loop_opcode);

      if (target_size == 2)
	target_size = 3; /* ISA specifies this */

      /* In an ideal world, which is what we are shooting for here,
	 we wouldn't need to use any NOPs immediately prior to the
	 LOOP instruction.  If this approach fails, relax_frag_loop_align
	 will call get_noop_aligned_address.  */
      target_address =
	address + loop_insn_offset + xg_get_single_size (loop_opcode);
      text_align_power = get_text_align_power (target_size),
      opt_diff = get_text_align_fill_size (target_address, text_align_power,
					   target_size, FALSE, FALSE);

      *max_diff = xtensa_fetch_width
	- ((target_address + opt_diff) % xtensa_fetch_width)
	- target_size + opt_diff;
      assert (*max_diff >= opt_diff);
      return opt_diff;

    default:
      break;
d6481 2
a6482 2
  assert (0);
  return 0;
a6487 6
static long relax_frag_loop_align (fragS *, long);
static long relax_frag_for_align (fragS *, long);
static long relax_frag_immed
  (segT, fragS *, long, int, xtensa_format, int, int *, bfd_boolean);


d6492 4
a6495 1
xtensa_relax_frag (fragS *fragP, long stretch, int *stretched_p)
a6496 1
  xtensa_isa isa = xtensa_default_isa;
a6500 3
  static xtensa_insnbuf vbuf = NULL;
  int slot, num_slots;
  xtensa_format fmt;
d6511 1
a6511 2
      if (fragP->tc_frag_data.relax_seen)
	new_stretch = relax_frag_loop_align (fragP, stretch);
a6520 1
      frag_wane (fragP);
d6524 2
a6525 1
      /* Do nothing. The narrowing before this frag will either align
d6543 3
a6545 26
    case RELAX_SLOTS:
      if (vbuf == NULL)
	vbuf = xtensa_insnbuf_alloc (isa);

      xtensa_insnbuf_from_chars (isa, vbuf, fragP->fr_opcode, 0);
      fmt = xtensa_format_decode (isa, vbuf);
      num_slots = xtensa_format_num_slots (isa, fmt);

      for (slot = 0; slot < num_slots; slot++)
	{
	  switch (fragP->tc_frag_data.slot_subtypes[slot])
	    {
	    case RELAX_NARROW:
	      if (fragP->tc_frag_data.relax_seen)
		new_stretch += relax_frag_for_align (fragP, stretch);
	      break;

	    case RELAX_IMMED:
	    case RELAX_IMMED_STEP1:
	    case RELAX_IMMED_STEP2:
	      /* Place the immediate.  */
	      new_stretch += relax_frag_immed
		(now_seg, fragP, stretch,
		 fragP->tc_frag_data.slot_subtypes[slot] - RELAX_IMMED,
		 fmt, slot, stretched_p, FALSE);
	      break;
d6547 7
a6553 5
	    default:
	      /* This is OK; see the note in xg_assemble_vliw_tokens.  */
	      break;
	    }
	}
a6557 2
    case RELAX_MAYBE_UNREACHABLE:
    case RELAX_MAYBE_DESIRE_ALIGN:
a6560 6
    case RELAX_FILL_NOP:
    case RELAX_UNREACHABLE:
      if (fragP->tc_frag_data.relax_seen)
	new_stretch += relax_frag_for_align (fragP, stretch);
      break;

a6564 7
  /* Tell gas we need another relaxation pass.  */
  if (! fragP->tc_frag_data.relax_seen) 
    {
      fragP->tc_frag_data.relax_seen = TRUE;
      *stretched_p = 1;
    }

d6571 3
a6573 1
relax_frag_loop_align (fragS *fragP, long stretch)
d6579 7
a6585 3
  /* All the frags with relax_frag_for_alignment prior to this one in the
     section have been done, hopefully eliminating the need for a NOP here.
     But, this will put it in if necessary.  */
d6590 1
a6590 1
		      fragP->tc_frag_data.text_expansion[0]);
d6602 1
a6602 1
  fragP->tc_frag_data.text_expansion[0] += growth;
d6607 3
a6609 1
/* Add a NOP instruction.  */
d6612 2
a6613 1
relax_frag_add_nop (fragS *fragP)
d6615 2
d6618 14
a6631 2
  int length = fragP->tc_frag_data.is_no_density ? 3 : 2;
  assemble_nop (length, nop_buf);
d6633 1
d6635 1
d6638 3
a6640 1
      as_fatal (_("fr_var (%ld) < length (%d)"), fragP->fr_var, length);
d6646 1
a6650 2
static long future_alignment_required (fragS *, long);

d6652 21
a6672 25
relax_frag_for_align (fragS *fragP, long stretch)
{
  /* Overview of the relaxation procedure for alignment:
     We can widen with NOPs or by widening instructions or by filling
     bytes after jump instructions.  Find the opportune places and widen
     them if necessary.  */

  long stretch_me;
  long diff;

  assert (fragP->fr_subtype == RELAX_FILL_NOP
	  || fragP->fr_subtype == RELAX_UNREACHABLE
	  || (fragP->fr_subtype == RELAX_SLOTS
	      && fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW));

  stretch_me = future_alignment_required (fragP, stretch);
  diff = stretch_me - fragP->tc_frag_data.text_expansion[0];
  if (diff == 0)
    return 0;

  if (diff < 0)
    {
      /* We expanded on a previous pass.  Can we shrink now?  */
      long shrink = fragP->tc_frag_data.text_expansion[0] - stretch_me;
      if (shrink <= stretch && stretch > 0)
d6674 7
a6680 2
	  fragP->tc_frag_data.text_expansion[0] = stretch_me;
	  return -shrink;
d6685 5
a6689 2
  /* Below here, diff > 0.  */
  fragP->tc_frag_data.text_expansion[0] = stretch_me;
d6691 1
a6691 1
  return diff;
d6695 4
a6698 20
/* Return the address of the next frag that should be aligned.

   By "address" we mean the address it _would_ be at if there
   is no action taken to align it between here and the target frag.
   In other words, if no narrows and no fill nops are used between
   here and the frag to align, _even_if_ some of the frags we use
   to align targets have already expanded on a previous relaxation
   pass.

   Also, count each frag that may be used to help align the target.

   Return 0 if there are no frags left in the chain that need to be
   aligned.  */

static addressT
find_address_of_next_align_frag (fragS **fragPP,
				 int *wide_nops,
				 int *narrow_nops,
				 int *widens,
				 bfd_boolean *paddable)
d6700 4
a6703 4
  fragS *fragP = *fragPP;
  addressT address = fragP->fr_address;

  /* Do not reset the counts to 0.  */
d6708 2
a6709 5
      if (*widens > 8)
	{
	  *fragPP = fragP;
	  return 0;
	}
d6712 1
a6712 3
      if (fragP->fr_type == rs_fill)
	address += fragP->fr_offset * fragP->fr_var;
      else if (fragP->fr_type == rs_machine_dependent)
d6714 5
d6721 3
a6723 17
	    case RELAX_UNREACHABLE:
	      *paddable = TRUE;
	      break;

	    case RELAX_FILL_NOP:
	      (*wide_nops)++;
	      if (!fragP->tc_frag_data.is_no_density)
		(*narrow_nops)++;
	      break;

	    case RELAX_SLOTS:
	      if (fragP->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
		{
		  (*widens)++;
		  break;
		}
	      address += total_frag_text_expansion (fragP);;
d6727 2
a6728 1
	      address += fragP->tc_frag_data.text_expansion[0];
d6733 10
a6742 6
	      *fragPP = fragP;
	      return address;

	    case RELAX_MAYBE_UNREACHABLE:
	    case RELAX_MAYBE_DESIRE_ALIGN:
	      /* Do nothing.  */
d6746 1
a6746 3
	      /* Just punt if we don't know the type.  */
	      *fragPP = fragP;
	      return 0;
d6748 1
a6748 179
	}
      else 
	{
	  /* Just punt if we don't know the type.  */
	  *fragPP = fragP;
	  return 0;
	}
      fragP = fragP->fr_next;
    }

  *fragPP = fragP;
  return 0;
}


static long bytes_to_stretch (fragS *, int, int, int, int);

/* Undefine LOOKAHEAD_ALIGNER to get the older behavior.
   I'll leave this in until I am more confident this works.  */

#define LOOKAHEAD_ALIGNER 1

static long
future_alignment_required (fragS *fragP, long stretch ATTRIBUTE_UNUSED)
{
  fragS *this_frag = fragP;
  long address;
  int num_widens = 0;
  int wide_nops = 0;
  int narrow_nops = 0;
  bfd_boolean paddable = FALSE;
  offsetT local_opt_diff;
  offsetT opt_diff;
  offsetT max_diff;
  int stretch_amount = 0;
  int local_stretch_amount;
  int global_stretch_amount;

  address = find_address_of_next_align_frag
    (&fragP, &wide_nops, &narrow_nops, &num_widens, &paddable);

  if (address)
    {
      local_opt_diff = get_aligned_diff (fragP, address, &max_diff);
      opt_diff = local_opt_diff;
      assert (opt_diff >= 0);
      assert (max_diff >= opt_diff);
      if (max_diff == 0) 
	return 0;
#ifdef LOOKAHEAD_ALIGNER
      if (fragP)
	fragP = fragP->fr_next;

      while (fragP && opt_diff < max_diff && address)
	{
	  /* We only use these to determine if we can exit early
	     because there will be plenty of ways to align future 
	     align frags.  */
	  unsigned int glob_widens = 0;
	  int dnn = 0;
	  int dw = 0;
	  bfd_boolean glob_pad = 0;
	  address = find_address_of_next_align_frag
	    (&fragP, &glob_widens, &dnn, &dw, &glob_pad);
	  /* If there is a padable portion, then skip.  */
	  if (glob_pad || (glob_widens >= xtensa_fetch_width))
	    break;

	  if (address) 
	    {
	      offsetT next_m_diff;
	      offsetT next_o_diff;

	      /* Downrange frags haven't had stretch added to them yet.  */
	      address += stretch;

	      /* The address also includes any text expansion from this
		 frag in a previous pass, but we don't want that.  */
	      address -= this_frag->tc_frag_data.text_expansion[0];

	      /* Assume we are going to move at least opt_diff.  In
		 reality, we might not be able to, but assuming that
		 we will helps catch cases where moving opt_diff pushes
		 the next target from aligned to unaligned.  */
	      address += opt_diff;

	      next_o_diff = get_aligned_diff (fragP, address, &next_m_diff);

	      /* Now cleanup for the adjustments to address.  */
	      next_o_diff += opt_diff;
	      next_m_diff += opt_diff;
	      if (next_o_diff <= max_diff && next_o_diff > opt_diff)
		opt_diff = next_o_diff;
	      if (next_m_diff < max_diff)
		max_diff = next_m_diff;
	      fragP = fragP->fr_next;
	    }
	}
#endif /* LOOKAHEAD_ALIGNER */
      /* If there are enough wideners in between, do it.  */
      if (paddable)
	{
	  if (this_frag->fr_subtype == RELAX_UNREACHABLE)
	    {
	      assert (opt_diff <= UNREACHABLE_MAX_WIDTH);
	      return opt_diff;
	    }
	  return 0;
	}
      local_stretch_amount 
	= bytes_to_stretch (this_frag, wide_nops, narrow_nops,
			    num_widens, local_opt_diff);
#ifdef LOOKAHEAD_ALIGNER
      global_stretch_amount 
	= bytes_to_stretch (this_frag, wide_nops, narrow_nops, 
			    num_widens, opt_diff);
      /* If the condition below is true, then the frag couldn't 
	 stretch the correct amount for the global case, so we just 
	 optimize locally.  We'll rely on the subsequent frags to get 
	 the correct alignment in the global case.  */
      if (global_stretch_amount < local_stretch_amount)
	stretch_amount = local_stretch_amount;
      else
	stretch_amount = global_stretch_amount;
#else /* ! LOOKAHEAD_ALIGNER */
      stretch_amount = local_stretch_amount;
#endif /* ! LOOKAHEAD_ALIGNER */
      if (this_frag->fr_subtype == RELAX_SLOTS
	  && this_frag->tc_frag_data.slot_subtypes[0] == RELAX_NARROW)
	assert (stretch_amount <= 1);
      else if (this_frag->fr_subtype == RELAX_FILL_NOP)
	{
	  if (this_frag->tc_frag_data.is_no_density)
	    assert (stretch_amount == 3 || stretch_amount == 0);
	  else
	    assert (stretch_amount <= 3);
	}
    }
  return stretch_amount;
}


/* The idea: widen everything you can to get a target or loop aligned,
   then start using NOPs.

   When we must have a NOP, here is a table of how we decide
   (so you don't have to fight through the control flow below):

   wide_nops   = the number of wide NOPs available for aligning
   narrow_nops = the number of narrow NOPs available for aligning
		 (a subset of wide_nops)
   widens      = the number of narrow instructions that should be widened

   Desired   wide   narrow
   Diff      nop    nop      widens
   1           0      0         1
   2           0      1         0
   3a          1      0         0
    b          0      1         1 (case 3a makes this case unnecessary)
   4a          1      0         1
    b          0      2         0
    c          0      1         2 (case 4a makes this case unnecessary)
   5a          1      0         2
    b          1      1         0
    c          0      2         1 (case 5b makes this case unnecessary)
   6a          2      0         0
    b          1      0         3
    c          0      1         4 (case 6b makes this case unneccesary)
    d          1      1         1 (case 6a makes this case unnecessary)
    e          0      2         2 (case 6a makes this case unnecessary)
    f          0      3         0 (case 6a makes this case unnecessary)
   7a          1      0         4
    b          2      0         1
    c          1      1         2 (case 7b makes this case unnecessary)
    d          0      1         5 (case 7a makes this case unnecessary)
    e          0      2         3 (case 7b makes this case unnecessary)
    f          0      3         1 (case 7b makes this case unnecessary)
    g          1      2         1 (case 7b makes this case unnecessary)
*/
a6749 86
static long
bytes_to_stretch (fragS *this_frag,
		  int wide_nops,
		  int narrow_nops,
		  int num_widens,
		  int desired_diff)
{
  int bytes_short = desired_diff - num_widens;

  assert (desired_diff >= 0 && desired_diff < 8);
  if (desired_diff == 0)
    return 0;
  
  assert (wide_nops > 0 || num_widens > 0);

  /* Always prefer widening to NOP-filling.  */
  if (bytes_short < 0)
    {
      /* There are enough RELAX_NARROW frags after this one
	 to align the target without widening this frag in any way.  */
      return 0;
    }
  
  if (bytes_short == 0)
    {
      /* Widen every narrow between here and the align target
	 and the align target will be properly aligned.  */
      if (this_frag->fr_subtype == RELAX_FILL_NOP)
	return 0;
      else
	return 1;
    }
  
  /* From here we will need at least one NOP to get an alignment.
     However, we may not be able to align at all, in which case,
     don't widen.  */
  if (this_frag->fr_subtype == RELAX_FILL_NOP)
    {
      switch (desired_diff)
	{
	case 1:
	  return 0;
	case 2:
	  if (!this_frag->tc_frag_data.is_no_density && narrow_nops == 1)
	    return 2; /* case 2 */
	  return 0;
	case 3: 
	  if (wide_nops > 1)
	    return 0;
	  else
	    return 3; /* case 3a */
	case 4:
	  if (num_widens >= 1 && wide_nops == 1)
	    return 3; /* case 4a */
	  if (!this_frag->tc_frag_data.is_no_density && narrow_nops == 2)
	    return 2; /* case 4b */
	  return 0;
	case 5:
	  if (num_widens >= 2 && wide_nops == 1)
	    return 3; /* case 5a */
	  /* We will need two nops.  Are there enough nops 
	     between here and the align target?  */
	  if (wide_nops < 2 || narrow_nops == 0)
	    return 0;
	  /* Are there other nops closer that can serve instead?  */
	  if (wide_nops > 2 && narrow_nops > 1)
	    return 0;
	  /* Take the density one first, because there might not be
	     another density one available.  */
	  if (!this_frag->tc_frag_data.is_no_density)
	    return 2; /* case 5b narrow */
	  else
	    return 3; /* case 5b wide */
	  return 0;
	case 6:
	  if (wide_nops == 2)
	    return 3; /* case 6a */
	  else if (num_widens >= 3 && wide_nops == 1)
	    return 3; /* case 6b */
	  return 0;
	case 7:
	  if (wide_nops == 1 && num_widens >= 4)
	    return 3; /* case 7a */
	  else if (wide_nops == 2 && num_widens >= 1)
	    return 3; /* case 7b */
	  return 0;
d6751 1
a6751 1
	  assert (0);
d6753 1
a6754 4
  else
    {
      /* We will need a NOP no matter what, but should we widen 
	 this instruction to help?
d6756 1
a6756 36
	 This is a RELAX_FRAG_NARROW frag.  */
      switch (desired_diff)
	{
	case 1:
	  assert (0);
	  return 0;
	case 2:
	case 3:
	  return 0;
	case 4:
	  if (wide_nops >= 1 && num_widens == 1)
	    return 1; /* case 4a */
	  return 0;
	case 5:
	  if (wide_nops >= 1 && num_widens == 2)
	    return 1; /* case 5a */
	  return 0;
	case 6:
	  if (wide_nops >= 2)
	    return 0; /* case 6a */
	  else if (wide_nops >= 1 && num_widens == 3)
	    return 1; /* case 6b */
	  return 0;
	case 7:
	  if (wide_nops >= 1 && num_widens == 4)
	    return 1; /* case 7a */
	  else if (wide_nops >= 2 && num_widens == 1)
	    return 1; /* case 7b */
	  return 0;
	default:
	  assert (0);
	  return 0;
	}
    }
  assert (0);
  return 0;
d6761 6
a6766 8
relax_frag_immed (segT segP,
		  fragS *fragP,
		  long stretch,
		  int min_steps,
		  xtensa_format fmt,
		  int slot,
		  int *stretched_p,
		  bfd_boolean estimate_only)
d6768 2
a6769 2
  TInsn tinsn;
  vliw_insn orig_vinsn;
a6772 2
  bfd_boolean wide_insn = FALSE;
  xtensa_isa isa = xtensa_default_isa;
d6778 1
a6778 1
  int literal_diff, total_text_diff, this_text_diff, first;
d6782 2
a6783 7
  xg_init_vinsn (&orig_vinsn);
  vinsn_from_chars (&orig_vinsn, fragP->fr_opcode);
  if (xtensa_format_num_slots (isa, fmt) > 1)
    wide_insn = TRUE;

  tinsn = orig_vinsn.slots[slot];
  tinsn_immed_from_frag (&tinsn, fragP, slot);
d6785 2
a6786 2
  if (estimate_only && xtensa_opcode_is_loop (isa, tinsn.opcode))
    return 0;
d6788 1
a6788 2
  if (workaround_b_j_loop_end && ! fragP->tc_frag_data.is_no_transform)
    branch_jmp_to_next = is_branch_jmp_to_next (&tinsn, fragP);
d6790 1
a6790 1
  negatable_branch = (xtensa_opcode_is_branch (isa, tinsn.opcode) == 1);
d6792 2
a6793 1
  old_size = xtensa_format_length (isa, fmt);
d6810 1
a6810 1
  num_steps = xg_assembly_relax (&istack, &tinsn, segP, fragP, frag_offset,
d6824 1
a6824 1
  fragP->tc_frag_data.slot_subtypes[slot] = (int) RELAX_IMMED + num_steps;
d6828 1
d6830 2
a6831 14
  literal_diff =
    num_literal_bytes - fragP->tc_frag_data.literal_expansion[slot];
  first = 0;
  while (istack.insn[first].opcode == XTENSA_UNDEFINED)
    first++;
  num_text_bytes = get_num_stack_text_bytes (&istack);
  if (wide_insn)
    {
      num_text_bytes += old_size;
      if (opcode_fits_format_slot (istack.insn[first].opcode, fmt, slot))
	num_text_bytes -= xg_get_single_size (istack.insn[first].opcode);
    }
  total_text_diff = num_text_bytes - old_size;
  this_text_diff = total_text_diff - fragP->tc_frag_data.text_expansion[slot];
d6834 5
a6838 8
  assert (num_text_bytes >= 0);
  assert (literal_diff >= 0);
  assert (total_text_diff >= 0);

  fragP->tc_frag_data.text_expansion[slot] = total_text_diff;
  fragP->tc_frag_data.literal_expansion[slot] = num_literal_bytes;
  assert (fragP->tc_frag_data.text_expansion[slot] >= 0);
  assert (fragP->tc_frag_data.literal_expansion[slot] >= 0);
d6843 1
a6843 1
      lit_fragP = fragP->tc_frag_data.literal_frags[slot];
d6861 8
a6868 2
  if (negatable_branch && istack.ninsn > 1)
    update_next_frag_state (fragP);
d6870 1
a6870 1
  return this_text_diff;
a6875 5
static void convert_frag_align_next_opcode (fragS *);
static void convert_frag_narrow (segT, fragS *, xtensa_format, int);
static void convert_frag_fill_nop (fragS *);
static void convert_frag_immed (segT, fragS *, int, xtensa_format, int);

d6877 4
a6880 1
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec, fragS *fragp)
a6881 5
  static xtensa_insnbuf vbuf = NULL;
  xtensa_isa isa = xtensa_default_isa;
  int slot;
  int num_slots;
  xtensa_format fmt;
d6903 3
a6905 44
    case RELAX_SLOTS:
      if (vbuf == NULL)
	vbuf = xtensa_insnbuf_alloc (isa);

      xtensa_insnbuf_from_chars (isa, vbuf, fragp->fr_opcode, 0);
      fmt = xtensa_format_decode (isa, vbuf);
      num_slots = xtensa_format_num_slots (isa, fmt);

      for (slot = 0; slot < num_slots; slot++)
	{
	  switch (fragp->tc_frag_data.slot_subtypes[slot])
	    {
	    case RELAX_NARROW:
	      convert_frag_narrow (sec, fragp, fmt, slot);
	      break;

	    case RELAX_IMMED:
	    case RELAX_IMMED_STEP1:
	    case RELAX_IMMED_STEP2:
	      /* Place the immediate.  */
	      convert_frag_immed
		(sec, fragp,
		 fragp->tc_frag_data.slot_subtypes[slot] - RELAX_IMMED,
		 fmt, slot);
	      break;

	    default:
	      /* This is OK because some slots could have
		 relaxations and others have none.  */
	      break;
	    }
	}
      break;

    case RELAX_UNREACHABLE:
      memset (&fragp->fr_literal[fragp->fr_fix], 0, fragp->fr_var);
      fragp->fr_fix += fragp->tc_frag_data.text_expansion[0];
      fragp->fr_var -= fragp->tc_frag_data.text_expansion[0];
      frag_wane (fragp);
      break;

    case RELAX_MAYBE_UNREACHABLE:
    case RELAX_MAYBE_DESIRE_ALIGN:
      frag_wane (fragp);
d6908 5
a6912 2
    case RELAX_FILL_NOP:
      convert_frag_fill_nop (fragp);
d6950 3
a6952 2
static void
convert_frag_align_next_opcode (fragS *fragp)
d6982 2
a6983 1
convert_frag_narrow (segT segP, fragS *fragP, xtensa_format fmt, int slot)
d6985 2
a6986 2
  TInsn tinsn, single_target;
  xtensa_format single_fmt;
d6990 1
a6990 13
  assert (slot == 0);
  tinsn_from_chars (&tinsn, fragP->fr_opcode, 0);

  if (xtensa_opcode_is_branch (xtensa_default_isa, tinsn.opcode) == 1)
    {
      assert (fragP->tc_frag_data.text_expansion[0] == 1
	      || fragP->tc_frag_data.text_expansion[0] == 0);
      convert_frag_immed (segP, fragP, fragP->tc_frag_data.text_expansion[0],
			  fmt, slot);
      return;
    }

  if (fragP->tc_frag_data.text_expansion[0] == 0)
d6999 5
a7003 3
  /* Frags in this relaxation state should only contain
     single instruction bundles.  */
  tinsn_immed_from_frag (&tinsn, fragP, 0);
d7007 1
a7007 1
  old_size = xg_get_single_size (tinsn.opcode);
d7012 1
a7012 1
  error_val = xg_expand_narrow (&single_target, &tinsn);
d7014 1
a7014 7
    {
      as_bad (_("unable to widen instruction"));
      return;
    }

  size = xg_get_single_size (single_target.opcode);
  single_fmt = xg_get_single_format (single_target.opcode);
d7016 2
a7017 1
  xg_emit_insn_to_buf (&single_target, single_fmt, fragP->fr_opcode,
d7032 4
a7035 31
convert_frag_fill_nop (fragS *fragP)
{
  char *loc = &fragP->fr_literal[fragP->fr_fix];
  int size = fragP->tc_frag_data.text_expansion[0];
  assert ((unsigned) size == (fragP->fr_next->fr_address
			      - fragP->fr_address - fragP->fr_fix));
  if (size == 0)
    {
      /* No conversion.  */
      fragP->fr_var = 0;
      return;
    }
  assemble_nop (size, loc);
  fragP->tc_frag_data.is_insn = TRUE;
  fragP->fr_var -= size;
  fragP->fr_fix += size;
  frag_wane (fragP);
}


static fixS *fix_new_exp_in_seg
  (segT, subsegT, fragS *, int, int, expressionS *, int,
   bfd_reloc_code_real_type);
static void convert_frag_immed_finish_loop (segT, fragS *, TInsn *);

static void
convert_frag_immed (segT segP,
		    fragS *fragP,
		    int min_steps,
		    xtensa_format fmt,
		    int slot)
d7038 2
a7039 1
  TInsn orig_tinsn;
d7041 1
d7043 1
a7043 6
  char *fr_opcode = fragP->fr_opcode;
  vliw_insn orig_vinsn;
  xtensa_isa isa = xtensa_default_isa;
  bfd_boolean wide_insn = FALSE;
  int bytes;
  bfd_boolean is_loop;
d7045 1
a7045 1
  assert (fr_opcode != NULL);
d7047 2
a7048 1
  xg_init_vinsn (&orig_vinsn);
d7050 2
a7051 3
  vinsn_from_chars (&orig_vinsn, fr_opcode);
  if (xtensa_format_num_slots (isa, fmt) > 1)
    wide_insn = TRUE;
d7053 3
a7055 2
  orig_tinsn = orig_vinsn.slots[slot];
  tinsn_immed_from_frag (&orig_tinsn, fragP, slot);
d7057 2
a7058 4
  is_loop = xtensa_opcode_is_loop (xtensa_default_isa, orig_tinsn.opcode) == 1;

  if (workaround_b_j_loop_end && ! fragP->tc_frag_data.is_no_transform)
    branch_jmp_to_next = is_branch_jmp_to_next (&orig_tinsn, fragP);
d7063 2
a7064 16
      bytes = xtensa_format_length (isa, fmt);
      if (bytes >= 4)
	{
	  orig_vinsn.slots[slot].opcode =
	    xtensa_format_slot_nop_opcode (isa, orig_vinsn.format, slot);
	  orig_vinsn.slots[slot].ntok = 0;
	}
      else
	{
	  bytes += fragP->tc_frag_data.text_expansion[0];
	  assert (bytes == 2 || bytes == 3);
	  build_nop (&orig_vinsn.slots[0], bytes);
	  fragP->fr_fix += fragP->tc_frag_data.text_expansion[0];
	}
      vinsn_to_insnbuf (&orig_vinsn, fr_opcode, frag_now, FALSE);
      xtensa_insnbuf_to_chars (isa, orig_vinsn.insnbuf, fr_opcode, 0);
d7067 1
a7067 1
  else if (!orig_tinsn.is_specific_opcode)
a7068 4
      /* Here is the fun stuff:  Get the immediate field from this
	 instruction.  If it fits, we're done.  If not, find the next
	 instruction sequence that fits.  */

a7072 1
      int target_offset = 0;
a7076 2
      bfd_boolean first = TRUE;
      bfd_boolean last_is_jump;
d7078 1
a7078 1
      /* It does not fit.  Find something that does and
d7080 1
a7080 1
      frag_offset = fr_opcode - fragP->fr_literal;
d7082 1
a7082 1
      xg_assembly_relax (&istack, &orig_tinsn,
d7085 1
a7085 1
      old_size = xtensa_format_length (isa, fmt);
d7090 1
a7090 1
      target_offset = 0;
d7093 2
a7094 1
	  TInsn *tinsn = &istack.insn[i];
d7097 1
a7097 1
	  switch (tinsn->insn_type)
d7103 1
a7103 1
	      lit_frag = fragP->tc_frag_data.literal_frags[slot];
d7106 1
a7106 1
	      if (tinsn->ntok != 1)
a7113 16
	      if (align_targets && !is_loop)
		{
		  fragS *unreach = fragP->fr_next;
		  while (!(unreach->fr_type == rs_machine_dependent
			   && (unreach->fr_subtype == RELAX_MAYBE_UNREACHABLE
			       || unreach->fr_subtype == RELAX_UNREACHABLE)))
		    {
		      unreach = unreach->fr_next;
		    }

		  assert (unreach->fr_type == rs_machine_dependent
			  && (unreach->fr_subtype == RELAX_MAYBE_UNREACHABLE
			      || unreach->fr_subtype == RELAX_UNREACHABLE));

		  target_offset += unreach->tc_frag_data.text_expansion[0];
		}
d7116 2
a7117 2
				      fr_opcode - fragP->fr_literal
				      + target_offset, fragP);
d7121 2
a7122 9
	      if (first && wide_insn)
		{
		  target_offset += xtensa_format_length (isa, fmt);
		  first = FALSE;
		  if (!opcode_fits_format_slot (tinsn->opcode, fmt, slot))
		    target_offset += xg_get_single_size (tinsn->opcode);
		}
	      else
		target_offset += xg_get_single_size (tinsn->opcode);
a7127 2
      first = TRUE;
      last_is_jump = FALSE;
d7130 1
a7130 1
	  TInsn *tinsn = &istack.insn[i];
a7133 1
	  bfd_reloc_code_real_type reloc_type;
d7135 1
a7135 1
	  switch (tinsn->insn_type)
d7138 2
a7139 2
	      lit_frag = fragP->tc_frag_data.literal_frags[slot];
	      /* Already checked.  */
d7142 2
a7143 2
	      assert (tinsn->ntok == 1);
	      /* Add a fixup.  */
a7145 4
	      if (tinsn->tok[0].X_op == O_pltrel)
		reloc_type = BFD_RELOC_XTENSA_PLT;
	      else
		reloc_type = BFD_RELOC_32;
d7147 1
a7147 1
				  &tinsn->tok[0], FALSE, reloc_type);
d7154 6
a7159 70
	      xg_resolve_labels (tinsn, gen_label);
	      xg_resolve_literals (tinsn, lit_sym);
	      if (wide_insn && first)
		{
		  first = FALSE;
		  if (opcode_fits_format_slot (tinsn->opcode, fmt, slot))
		    {
		      tinsn->record_fix = TRUE;
		      orig_vinsn.slots[slot] = *tinsn;
		    }
		  else
		    {
		      orig_vinsn.slots[slot].opcode =
			xtensa_format_slot_nop_opcode (isa, fmt, slot);
		      orig_vinsn.slots[slot].ntok = 0;
		      orig_vinsn.slots[slot].record_fix = FALSE;
		    }
		  vinsn_to_insnbuf (&orig_vinsn, immed_instr, fragP, TRUE);
		  xtensa_insnbuf_to_chars (isa, orig_vinsn.insnbuf,
					   immed_instr, 0);
		  fragP->tc_frag_data.is_insn = TRUE;
		  size = xtensa_format_length (isa, fmt);
		  if (!opcode_fits_format_slot (tinsn->opcode, fmt, slot))
		    {
		      xtensa_format single_fmt =
			xg_get_single_format (tinsn->opcode);

		      xg_emit_insn_to_buf
			(tinsn, single_fmt, immed_instr + size, fragP,
			 immed_instr - fragP->fr_literal + size, TRUE);
		      size += xg_get_single_size (tinsn->opcode);
		    }
		}
	      else
		{
		  xtensa_format single_format;
		  size = xg_get_single_size (tinsn->opcode);
		  single_format = xg_get_single_format (tinsn->opcode);
		  xg_emit_insn_to_buf (tinsn, single_format, immed_instr,
				       fragP,
				       immed_instr - fragP->fr_literal, TRUE);
#if 0
		  /* Code to recognize branch-around expansion
		     so the fragment is properly marked as ending in a
		     jump. */
		  if ((((i == istack.ninsn - 2)
			&& (istack.insn[istack.ninsn-1].insn_type
			    == ITYPE_LABEL))
		       || i == istack.ninsn -1)
		      && xtensa_opcode_is_jump (xtensa_default_isa,
						tinsn->opcode) == 1
		      && fragP->fr_next != NULL
		      && ! fragP->fr_next->tc_frag_data.is_unreachable)
		    {
		      /* Create a new unreachable frag of zero size.  */
		      size_t frag_size = sizeof (fragS);
		      fragS *new_fragP = (fragS *) xmalloc (frag_size);
		      memset (new_fragP, 0, frag_size);
		      new_fragP->fr_address = fragP->fr_next->fr_address;
		      new_fragP->fr_next = fragP->fr_next;
		      new_fragP->fr_fix = 0;
		      new_fragP->fr_var = 0;
		      new_fragP->fr_type = rs_fill;
		      new_fragP->tc_frag_data.is_unreachable = TRUE;
		      /* The rest are zeros....  */
		      /* Link it in to the chain.  */
		      fragP->fr_next = new_fragP;
		    }
#endif
		}
a7160 1
	      total_size += size;
d7175 1
a7175 1
  xg_free_vinsn (&orig_vinsn);
d7178 1
a7178 1
  if (is_loop)
d7181 1
a7181 1
      sym = orig_tinsn.tok[1].X_add_symbol;
d7187 1
a7187 1
      sym = orig_tinsn.tok[1].X_op_symbol;
d7195 2
a7196 2
  if (expanded && xtensa_opcode_is_loop (isa, orig_tinsn.opcode) == 1)
    convert_frag_immed_finish_loop (segP, fragP, &orig_tinsn);
d7198 1
a7198 1
  if (expanded && is_direct_call_opcode (orig_tinsn.opcode))
d7202 1
a7202 1
			  &orig_tinsn.tok[0], TRUE,
d7204 1
d7213 10
a7222 8
fix_new_exp_in_seg (segT new_seg,
		    subsegT new_subseg,
		    fragS *frag,
		    int where,
		    int size,
		    expressionS *exp,
		    int pcrel,
		    bfd_reloc_code_real_type r_type)
a7226 1

d7230 7
d7243 21
a7263 19
/* Relax a loop instruction so that it can span loop >256 bytes.

                  loop    as, .L1
          .L0:
                  rsr     as, LEND
                  wsr     as, LBEG
                  addi    as, as, lo8 (label-.L1)
                  addmi   as, as, mid8 (label-.L1)
                  wsr     as, LEND
                  isync
                  rsr     as, LCOUNT
                  addi    as, as, 1
          .L1:
                  <<body>>
          label:
*/

static void
convert_frag_immed_finish_loop (segT segP, fragS *fragP, TInsn *tinsn)
a7274 2
  fragS *next_fragP;
  size_t target_count;
d7280 3
a7282 1
  loop_offset = get_expanded_loop_offset (tinsn->opcode);
d7284 6
a7289 7
  /* Validate that there really is a LOOP at the loop_offset.  Because
     loops are not bundleable, we can assume that the instruction will be
     in slot 0.  */
  tinsn_from_chars (&loop_insn, fragP->fr_opcode + loop_offset, 0);
  tinsn_immed_from_frag (&loop_insn, fragP, 0);

  assert (xtensa_opcode_is_loop (isa, loop_insn.opcode) == 1);
d7293 2
a7294 16
  assert (tinsn->ntok == 2);
  if (tinsn->tok[1].X_op == O_constant)
    target = tinsn->tok[1].X_add_number;
  else if (tinsn->tok[1].X_op == O_symbol)
    {
      /* Find the fragment.  */
      symbolS *sym = tinsn->tok[1].X_add_symbol;
      assert (S_GET_SEGMENT (sym) == segP
	      || S_GET_SEGMENT (sym) == absolute_section);
      target = (S_GET_VALUE (sym) + tinsn->tok[1].X_add_number);
    }
  else
    {
      as_bad (_("invalid expression evaluation type %d"), tinsn->tok[1].X_op);
      target = 0;
    }
d7310 1
a7310 1
  /* Because addmi sign-extends the immediate, 'loop_length_hi' can be at most
d7316 1
a7316 1
  tinsn_from_chars (&addi_insn, fragP->fr_opcode + addi_offset, 0);
d7319 1
a7319 1
  tinsn_from_chars (&addmi_insn, fragP->fr_opcode + addmi_offset, 0);
d7324 1
a7324 1

d7326 1
a7326 1
  xtensa_insnbuf_to_chars (isa, insnbuf, fragP->fr_opcode + addi_offset, 0);
d7330 2
a7331 1
  xtensa_insnbuf_to_chars (isa, insnbuf, fragP->fr_opcode + addmi_offset, 0);
a7332 4
  /* Walk through all of the frags from here to the loop end
     and mark them as no_transform to keep them from being modified
     by the linker.  If we ever have a relocation for the
     addi/addmi of the difference of two symbols we can remove this.  */
d7334 8
a7341 3
  target_count = 0;
  for (next_fragP = fragP; next_fragP != NULL;
       next_fragP = next_fragP->fr_next)
d7343 7
a7349 5
      next_fragP->tc_frag_data.is_no_transform = TRUE;
      if (next_fragP->tc_frag_data.is_loop_target)
	target_count++;
      if (target_count == 2)
	break;
d7351 2
a7368 2
  float total_freq;	/* fall-through + branch target frequency */
  float target_freq;	/* branch target frequency alone */
d7373 1
a7374 1
static subseg_map *sseg_map = NULL;
d7376 4
a7379 2
static subseg_map *
get_subseg_info (segT seg, subsegT subseg)
d7383 5
a7387 6
  for (subseg_e = sseg_map; subseg_e; subseg_e = subseg_e->next)
    {
      if (seg == subseg_e->seg && subseg == subseg_e->subseg)
	break;
    }
  return subseg_e;
d7391 6
a7396 2
static subseg_map *
add_subseg_info (segT seg, subsegT subseg)
d7398 1
a7398 12
  subseg_map *subseg_e = (subseg_map *) xmalloc (sizeof (subseg_map));
  memset (subseg_e, 0, sizeof (subseg_map));
  subseg_e->seg = seg;
  subseg_e->subseg = subseg;
  subseg_e->flags = 0;
  /* Start off considering every branch target very important.  */
  subseg_e->target_freq = 1.0;
  subseg_e->total_freq = 1.0;
  subseg_e->next = sseg_map;
  sseg_map = subseg_e;
  return subseg_e;
}
d7400 3
d7404 10
a7413 9
static unsigned
get_last_insn_flags (segT seg, subsegT subseg)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (subseg_e)
    return subseg_e->flags;
  return 0;
}

a7414 9
static void
set_last_insn_flags (segT seg,
		     subsegT subseg,
		     unsigned fl,
		     bfd_boolean val)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (! subseg_e)
    subseg_e = add_subseg_info (seg, subseg);
a7420 31

static float
get_subseg_total_freq (segT seg, subsegT subseg)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (subseg_e)
    return subseg_e->total_freq;
  return 1.0;
}


static float
get_subseg_target_freq (segT seg, subsegT subseg)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (subseg_e)
    return subseg_e->target_freq;
  return 1.0;
}


static void
set_subseg_freq (segT seg, subsegT subseg, float total_f, float target_f)
{
  subseg_map *subseg_e = get_subseg_info (seg, subseg);
  if (! subseg_e)
    subseg_e = add_subseg_info (seg, subseg);
  subseg_e->total_freq = total_f;
  subseg_e->target_freq = target_f;
}

d7427 2
a7428 1
xtensa_remove_section (segT sec)
d7445 3
a7447 1
xtensa_insert_section (segT after_sec, segT sec)
d7460 2
a7461 1
xtensa_move_seg_list_to_beginning (seg_list *head)
d7478 2
a7479 4
static void mark_literal_frags (seg_list *);

static void
xtensa_move_literals (void)
a7521 1
      xtensa_set_frag_assembly_state (frag_now);
a7523 1
      xtensa_set_frag_assembly_state (frag_now);
d7525 1
a7525 1
      while (search_frag != frag_now)
d7529 1
a7529 1
	  /* First, move the frag out of the literal section and
d7535 1
a7535 1
	      /* Note that we set this fr_var to be a fix
d7541 1
a7541 1

d7546 1
a7546 1

d7591 1
a7591 2
      if (dest_seg)
	S_SET_SEGMENT (lit_sym, dest_seg);
d7601 2
a7602 1
mark_literal_frags (seg_list *segment)
d7622 3
a7624 1
xtensa_reorder_seg_list (seg_list *head, segT after)
d7649 2
a7650 2
static void
xtensa_reorder_segments (void)
d7653 1
a7653 1
  segT last_sec = 0;
d7658 1
a7658 4
    {
      last_sec = sec;
      old_count++;
    }
d7662 1
d7674 2
a7675 6
/* Change the emit state (seg, subseg, and frag related stuff) to the
   correct location.  Return a emit_state which can be passed to
   xtensa_restore_emit_state to return to current fragment.  */

static void
xtensa_switch_to_literal_fragment (emit_state *result)
d7677 3
a7679 9
  if (directive_state[directive_absolute_literals])
    {
      cache_literal_section (0, default_lit_sections.lit4_seg_name,
			     &default_lit_sections.lit4_seg, FALSE);
      xtensa_switch_section_emit_state (result,
					default_lit_sections.lit4_seg, 0);
    }
  else
    xtensa_switch_to_non_abs_literal_fragment (result);
d7681 1
a7681 3
  /* Do a 4-byte align here.  */
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
d7685 7
a7691 2
static void
xtensa_switch_to_non_abs_literal_fragment (emit_state *result)
d7706 1
d7708 2
a7709 2
  if (pool_location == NULL
      && !use_literal_section
d7713 2
a7714 1
      as_bad (_("literal pool location required for text-section-literals; specify with .literal_position"));
d7728 1
a7728 1
			     &default_lit_sections.init_lit_seg, TRUE);
d7736 1
a7736 1
			     &default_lit_sections.fini_lit_seg, TRUE);
d7740 1
a7740 1
  else
d7744 1
a7744 1
			     &default_lit_sections.lit_seg, TRUE);
d7749 3
a7751 3
  if (!use_literal_section
      && !is_init && !is_fini
      && get_literal_pool_location (now_seg) != pool_location)
a7754 1
      xtensa_set_frag_assembly_state (frag_now);
a7756 1
      xtensa_set_frag_assembly_state (frag_now);
d7758 3
d7768 5
a7772 4
static void
xtensa_switch_section_emit_state (emit_state *state,
				  segT new_now_seg,
				  subsegT new_now_subseg)
d7779 1
a7779 1
  subseg_set (new_now_seg, new_now_subseg);
d7785 3
a7787 2
static void
xtensa_restore_emit_state (emit_state *state)
d7790 1
a7790 1
  subseg_set (state->now_seg, state->now_subseg);
d7798 4
a7801 4
cache_literal_section (seg_list *head,
		       const char *name,
		       segT *pseg,
		       bfd_boolean is_code)
a7804 1
  segT seg;
d7806 1
a7806 1
  if (*pseg != 0)
d7808 1
a7808 27

  /* Check if the named section exists.  */
  for (seg = stdoutput->sections; seg; seg = seg->next)
    {
      if (!strcmp (segment_name (seg), name))
	break;
    }

  if (!seg)
    {
      /* Create a new literal section.  */
      seg = subseg_new (name, (subsegT) 0);
      if (head)
	{
	  /* Add the newly created literal segment to the specified list.  */
	  seg_list *n = (seg_list *) xmalloc (sizeof (seg_list));
	  n->seg = seg;
	  n->next = head->next;
	  head->next = n;
	}
      bfd_set_section_flags (stdoutput, seg, SEC_HAS_CONTENTS |
			     SEC_READONLY | SEC_ALLOC | SEC_LOAD
			     | (is_code ? SEC_CODE : SEC_DATA));
      bfd_set_section_alignment (stdoutput, seg, 2);
    }

  *pseg = seg;
a7811 2

/* Property Tables Stuff.  */
d7813 2
a7814 3
#define XTENSA_INSN_SEC_NAME ".xt.insn"
#define XTENSA_LIT_SEC_NAME ".xt.lit"
#define XTENSA_PROP_SEC_NAME ".xt.prop"
d7816 4
a7819 25
typedef bfd_boolean (*frag_predicate) (const fragS *);
typedef void (*frag_flags_fn) (const fragS *, frag_flags *);

static bfd_boolean get_frag_is_literal (const fragS *);
static void xtensa_create_property_segments
  (frag_predicate, frag_predicate, const char *, xt_section_type);
static void xtensa_create_xproperty_segments
  (frag_flags_fn, const char *, xt_section_type);
static segment_info_type *retrieve_segment_info (segT);
static segT retrieve_xtensa_section (char *);
static bfd_boolean section_has_property (segT, frag_predicate);
static bfd_boolean section_has_xproperty (segT, frag_flags_fn);
static void add_xt_block_frags
  (segT, segT, xtensa_block_info **, frag_predicate, frag_predicate);
static bfd_boolean xtensa_frag_flags_is_empty (const frag_flags *);
static void xtensa_frag_flags_init (frag_flags *);
static void get_frag_property_flags (const fragS *, frag_flags *);
static bfd_vma frag_flags_to_number (const frag_flags *);
static void add_xt_prop_frags
  (segT, segT, xtensa_block_info **, frag_flags_fn);

/* Set up property tables after relaxation.  */

void
xtensa_post_relax_hook (void)
d7821 1
a7821 3
  xtensa_move_seg_list_to_beginning (literal_head);
  xtensa_move_seg_list_to_beginning (init_literal_head);
  xtensa_move_seg_list_to_beginning (fini_literal_head);
d7823 1
a7823 1
  xtensa_find_unmarked_state_frags ();
d7825 9
a7833 8
  if (use_literal_section)
    xtensa_create_property_segments (get_frag_is_literal,
				     NULL,
				     XTENSA_LIT_SEC_NAME,
				     xt_literal_sec);
  xtensa_create_xproperty_segments (get_frag_property_flags,
				    XTENSA_PROP_SEC_NAME,
				    xt_prop_sec);
d7835 1
a7835 3
  if (warn_unaligned_branch_targets)
    bfd_map_over_sections (stdoutput, xtensa_find_unaligned_branch_targets, 0);
  bfd_map_over_sections (stdoutput, xtensa_find_unaligned_loops, 0);
d7839 1
a7839 1
/* This function is only meaningful after xtensa_move_literals.  */
d7841 3
a7843 2
static bfd_boolean
get_frag_is_literal (const fragS *fragP)
d7845 2
a7846 17
  assert (fragP != NULL);
  return fragP->tc_frag_data.is_literal;
}


static void
xtensa_create_property_segments (frag_predicate property_function,
				 frag_predicate end_property_function,
				 const char *section_name_base,
				 xt_section_type sec_type)
{
  segT *seclist;

  /* Walk over all of the current segments.
     Walk over each fragment
     For each non-empty fragment,
     Build a property record (append where possible).  */
d7848 1
a7848 3
  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
d7850 3
a7852 21
      segT sec = *seclist;
      flagword flags;

      flags = bfd_get_section_flags (stdoutput, sec);
      if (flags & SEC_DEBUGGING)
	continue;
      if (!(flags & SEC_ALLOC))
	continue;

      if (section_has_property (sec, property_function))
	{
	  char *property_section_name =
	    xtensa_get_property_section_name (sec, section_name_base);
	  segT insn_sec = retrieve_xtensa_section (property_section_name);
	  segment_info_type *xt_seg_info = retrieve_segment_info (insn_sec);
	  xtensa_block_info **xt_blocks =
	    &xt_seg_info->tc_segment_info_data.blocks[sec_type];
	  /* Walk over all of the frchains here and add new sections.  */
	  add_xt_block_frags (sec, insn_sec, xt_blocks, property_function,
			      end_property_function);
	}
d7855 2
a7856 1
  /* Now we fill them out....  */
a7857 7
  for (seclist = &stdoutput->sections;
       seclist && *seclist;
       seclist = &(*seclist)->next)
    {
      segment_info_type *seginfo;
      xtensa_block_info *block;
      segT sec = *seclist;
d7859 1
a7859 2
      seginfo = seg_info (sec);
      block = seginfo->tc_segment_info_data.blocks[sec_type];
d7861 8
a7868 6
      if (block)
	{
	  xtensa_block_info *cur_block;
	  /* This is a section with some data.  */
	  int num_recs = 0;
	  size_t rec_size;
d7870 4
a7873 20
	  for (cur_block = block; cur_block; cur_block = cur_block->next)
	    num_recs++;

	  rec_size = num_recs * 8;
	  bfd_set_section_size (stdoutput, sec, rec_size);

	  /* In order to make this work with the assembler, we have to
	     build some frags and then build the "fixups" for it.  It
	     would be easier to just set the contents then set the
	     arlents.  */

	  if (num_recs)
	    {
	      /* Allocate a fragment and leak it.  */
	      fragS *fragP;
	      size_t frag_size;
	      fixS *fixes;
	      frchainS *frchainP;
	      int i;
	      char *frag_data;
d7875 2
a7876 2
	      frag_size = sizeof (fragS) + rec_size;
	      fragP = (fragS *) xmalloc (frag_size);
d7878 2
a7879 7
	      memset (fragP, 0, frag_size);
	      fragP->fr_address = 0;
	      fragP->fr_next = NULL;
	      fragP->fr_fix = rec_size;
	      fragP->fr_var = 0;
	      fragP->fr_type = rs_fill;
	      /* The rest are zeros.  */
d7881 6
a7886 3
	      frchainP = seginfo->frchainP;
	      frchainP->frch_root = fragP;
	      frchainP->frch_last = fragP;
d7888 7
a7894 2
	      fixes = (fixS *) xmalloc (sizeof (fixS) * num_recs);
	      memset (fixes, 0, sizeof (fixS) * num_recs);
a7895 8
	      seginfo->fix_root = fixes;
	      seginfo->fix_tail = &fixes[num_recs - 1];
	      cur_block = block;
	      frag_data = &fragP->fr_literal[0];
	      for (i = 0; i < num_recs; i++)
		{
		  fixS *fix = &fixes[i];
		  assert (cur_block);
d7897 8
a7904 14
		  /* Write the fixup.  */
		  if (i != num_recs - 1)
		    fix->fx_next = &fixes[i + 1];
		  else
		    fix->fx_next = NULL;
		  fix->fx_size = 4;
		  fix->fx_done = 0;
		  fix->fx_frag = fragP;
		  fix->fx_where = i * 8;
		  fix->fx_addsy = section_symbol (cur_block->sec);
		  fix->fx_offset = cur_block->offset;
		  fix->fx_r_type = BFD_RELOC_32;
		  fix->fx_file = "Internal Assembly";
		  fix->fx_line = 0;
d7906 6
a7911 8
		  /* Write the length.  */
		  md_number_to_chars (&frag_data[4 + 8 * i],
				      cur_block->size, 4);
		  cur_block = cur_block->next;
		}
	    }
	}
    }
d7916 5
a7920 3
xtensa_create_xproperty_segments (frag_flags_fn flag_fn,
				  const char *section_name_base,
				  xt_section_type sec_type)
d7925 3
a7927 3
     Walk over each fragment.
     For each fragment that has instructions,
     build an instruction record (append where possible).  */
d7934 1
a7934 9
      flagword flags;

      flags = bfd_get_section_flags (stdoutput, sec);
      if (flags & SEC_DEBUGGING)
	continue;
      if (!(flags & SEC_ALLOC))
	continue;

      if (section_has_xproperty (sec, flag_fn))
d7940 1
a7940 1
	  xtensa_block_info **xt_blocks =
d7943 1
a7943 1
	  add_xt_prop_frags (sec, insn_sec, xt_blocks, flag_fn);
a7955 1

d7963 1
a7963 1
	  int num_recs = 0;
d7969 1
a7969 1
	  rec_size = num_recs * (8 + 4);
d7972 4
a7975 5
	  /* elf_section_data (sec)->this_hdr.sh_entsize = 12; */

	  /* In order to make this work with the assembler, we have to build
	     some frags then build the "fixups" for it.  It would be easier to
	     just set the contents then set the arlents.  */
d7979 1
a7979 1
	      /* Allocate a fragment and (unfortunately) leak it.  */
d7984 1
a7984 1
	      int i;
d7996 1
a7996 1
	      /* The rest are zeros.  */
d8022 1
a8022 1
		  fix->fx_where = i * (8 + 4);
d8030 1
a8030 1
		  md_number_to_chars (&frag_data[4 + (8+4) * i],
a8031 3
		  md_number_to_chars (&frag_data[8 + (8+4) * i],
				      frag_flags_to_number (&cur_block->flags),
				      4);
d8040 3
a8042 2
static segment_info_type *
retrieve_segment_info (segT seg)
d8051 1
a8051 1
      memset ((void *) seginfo, 0, sizeof (*seginfo));
d8064 1
a8064 1
	bfd_set_section_userdata (stdoutput, seg, (void *) seginfo);
d8090 3
a8092 2
static segT
retrieve_xtensa_section (char *sec_name)
d8114 4
a8117 2
static bfd_boolean
section_has_property (segT sec, frag_predicate property_function)
a8134 20
static bfd_boolean
section_has_xproperty (segT sec, frag_flags_fn property_function)
{
  segment_info_type *seginfo = seg_info (sec);
  fragS *fragP;

  if (seginfo && seginfo->frchainP)
    {
      for (fragP = seginfo->frchainP->frch_root; fragP; fragP = fragP->fr_next)
	{
	  frag_flags prop_flags;
	  property_function (fragP, &prop_flags);
	  if (!xtensa_frag_flags_is_empty (&prop_flags))
	    return TRUE;
	}
    }
  return FALSE;
}


d8137 6
a8142 6
static void
add_xt_block_frags (segT sec,
		    segT xt_block_sec,
		    xtensa_block_info **xt_block,
		    frag_predicate property_function,
		    frag_predicate end_property_function)
a8184 259
		  xtensa_frag_flags_init (&new_block->flags);
		  *xt_block = new_block;
		}
	      if (end_property_function
		  && end_property_function (fragP))
		{
		  xt_block = &((*xt_block)->next);
		}
	    }
	}
    }
}


/* Break the encapsulation of add_xt_prop_frags here.  */

static bfd_boolean
xtensa_frag_flags_is_empty (const frag_flags *prop_flags)
{
  if (prop_flags->is_literal
      || prop_flags->is_insn
      || prop_flags->is_data
      || prop_flags->is_unreachable)
    return FALSE;
  return TRUE;
}


static void
xtensa_frag_flags_init (frag_flags *prop_flags)
{
  memset (prop_flags, 0, sizeof (frag_flags));
}


static void
get_frag_property_flags (const fragS *fragP, frag_flags *prop_flags)
{
  xtensa_frag_flags_init (prop_flags);
  if (fragP->tc_frag_data.is_literal)
    prop_flags->is_literal = TRUE;
  if (fragP->tc_frag_data.is_unreachable)
    prop_flags->is_unreachable = TRUE;
  else if (fragP->tc_frag_data.is_insn)
    {
      prop_flags->is_insn = TRUE;
      if (fragP->tc_frag_data.is_loop_target)
	prop_flags->insn.is_loop_target = TRUE;
      if (fragP->tc_frag_data.is_branch_target)
	prop_flags->insn.is_branch_target = TRUE;
      if (fragP->tc_frag_data.is_specific_opcode
	  || fragP->tc_frag_data.is_no_transform)
	prop_flags->insn.is_no_transform = TRUE;
      if (fragP->tc_frag_data.is_no_density)
	prop_flags->insn.is_no_density = TRUE;
      if (fragP->tc_frag_data.use_absolute_literals)
	prop_flags->insn.is_abslit = TRUE;
    }
  if (fragP->tc_frag_data.is_align)
    {
      prop_flags->is_align = TRUE;
      prop_flags->alignment = fragP->tc_frag_data.alignment;
      if (xtensa_frag_flags_is_empty (prop_flags))
	prop_flags->is_data = TRUE;
    }
}


static bfd_vma
frag_flags_to_number (const frag_flags *prop_flags)
{
  bfd_vma num = 0;
  if (prop_flags->is_literal)
    num |= XTENSA_PROP_LITERAL;
  if (prop_flags->is_insn)
    num |= XTENSA_PROP_INSN;
  if (prop_flags->is_data)
    num |= XTENSA_PROP_DATA;
  if (prop_flags->is_unreachable)
    num |= XTENSA_PROP_UNREACHABLE;
  if (prop_flags->insn.is_loop_target)
    num |= XTENSA_PROP_INSN_LOOP_TARGET;
  if (prop_flags->insn.is_branch_target)
    {
      num |= XTENSA_PROP_INSN_BRANCH_TARGET;
      num = SET_XTENSA_PROP_BT_ALIGN (num, prop_flags->insn.bt_align_priority);
    }

  if (prop_flags->insn.is_no_density)
    num |= XTENSA_PROP_INSN_NO_DENSITY;
  if (prop_flags->insn.is_no_transform)
    num |= XTENSA_PROP_INSN_NO_TRANSFORM;
  if (prop_flags->insn.is_no_reorder)
    num |= XTENSA_PROP_INSN_NO_REORDER;
  if (prop_flags->insn.is_abslit)
    num |= XTENSA_PROP_INSN_ABSLIT;

  if (prop_flags->is_align)
    {
      num |= XTENSA_PROP_ALIGN;
      num = SET_XTENSA_PROP_ALIGNMENT (num, prop_flags->alignment);
    }

  return num;
}


static bfd_boolean
xtensa_frag_flags_combinable (const frag_flags *prop_flags_1,
			      const frag_flags *prop_flags_2)
{
  /* Cannot combine with an end marker.  */

  if (prop_flags_1->is_literal != prop_flags_2->is_literal)
    return FALSE;
  if (prop_flags_1->is_insn != prop_flags_2->is_insn)
    return FALSE;
  if (prop_flags_1->is_data != prop_flags_2->is_data)
    return FALSE;

  if (prop_flags_1->is_insn)
    {
      /* Properties of the beginning of the frag.  */
      if (prop_flags_2->insn.is_loop_target)
	return FALSE;
      if (prop_flags_2->insn.is_branch_target)
	return FALSE;
      if (prop_flags_1->insn.is_no_density !=
	  prop_flags_2->insn.is_no_density)
	return FALSE;
      if (prop_flags_1->insn.is_no_transform !=
	  prop_flags_2->insn.is_no_transform)
	return FALSE;
      if (prop_flags_1->insn.is_no_reorder !=
	  prop_flags_2->insn.is_no_reorder)
	return FALSE;
      if (prop_flags_1->insn.is_abslit !=
	  prop_flags_2->insn.is_abslit)
	return FALSE;
    }

  if (prop_flags_1->is_align)
    return FALSE;

  return TRUE;
}


static bfd_vma
xt_block_aligned_size (const xtensa_block_info *xt_block)
{
  bfd_vma end_addr;
  size_t align_bits;

  if (!xt_block->flags.is_align)
    return xt_block->size;

  end_addr = xt_block->offset + xt_block->size;
  align_bits = xt_block->flags.alignment;
  end_addr = ((end_addr + ((1 << align_bits) -1)) >> align_bits) << align_bits;
  return end_addr - xt_block->offset;
}


static bfd_boolean
xtensa_xt_block_combine (xtensa_block_info *xt_block,
			 const xtensa_block_info *xt_block_2)
{
  if (xt_block->sec != xt_block_2->sec)
    return FALSE;
  if (xt_block->offset + xt_block_aligned_size (xt_block)
      != xt_block_2->offset)
    return FALSE;

  if (xt_block_2->size == 0
      && (!xt_block_2->flags.is_unreachable
	  || xt_block->flags.is_unreachable))
    {
      if (xt_block_2->flags.is_align
	  && xt_block->flags.is_align)
	{
	  /* Nothing needed.  */
	  if (xt_block->flags.alignment >= xt_block_2->flags.alignment)
	    return TRUE;
	}
      else
	{
	  if (xt_block_2->flags.is_align)
	    {
	      /* Push alignment to previous entry.  */
	      xt_block->flags.is_align = xt_block_2->flags.is_align;
	      xt_block->flags.alignment = xt_block_2->flags.alignment;
	    }
	  return TRUE;
	}
    }
  if (!xtensa_frag_flags_combinable (&xt_block->flags,
				     &xt_block_2->flags))
    return FALSE;

  xt_block->size += xt_block_2->size;

  if (xt_block_2->flags.is_align)
    {
      xt_block->flags.is_align = TRUE;
      xt_block->flags.alignment = xt_block_2->flags.alignment;
    }

  return TRUE;
}


static void
add_xt_prop_frags (segT sec,
		   segT xt_block_sec,
		   xtensa_block_info **xt_block,
		   frag_flags_fn property_function)
{
  segment_info_type *seg_info;
  segment_info_type *xt_seg_info;
  bfd_vma seg_offset;
  fragS *fragP;

  xt_seg_info = retrieve_segment_info (xt_block_sec);
  seg_info = retrieve_segment_info (sec);
  /* Build it if needed.  */
  while (*xt_block != NULL)
    {
      xt_block = &(*xt_block)->next;
    }
  /* We are either at NULL at the beginning or at the end.  */

  /* Walk through the frags.  */
  seg_offset = 0;

  if (seg_info->frchainP)
    {
      for (fragP = seg_info->frchainP->frch_root; fragP;
	   fragP = fragP->fr_next)
	{
	  xtensa_block_info tmp_block;
	  tmp_block.sec = sec;
	  tmp_block.offset = fragP->fr_address;
	  tmp_block.size = fragP->fr_fix;
	  tmp_block.next = NULL;
	  property_function (fragP, &tmp_block.flags);

	  if (!xtensa_frag_flags_is_empty (&tmp_block.flags))
	    /* && fragP->fr_fix != 0) */
	    {
	      if ((*xt_block) == NULL
		  || !xtensa_xt_block_combine (*xt_block, &tmp_block))
		{
		  xtensa_block_info *new_block;
		  if ((*xt_block) != NULL)
		    xt_block = &(*xt_block)->next;
		  new_block = (xtensa_block_info *)
		    xmalloc (sizeof (xtensa_block_info));
		  *new_block = tmp_block;
a8192 99
/* op_placement_info_table */

/* op_placement_info makes it easier to determine which
   ops can go in which slots.  */

static void
init_op_placement_info_table (void)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_insnbuf ibuf = xtensa_insnbuf_alloc (isa);
  xtensa_opcode opcode;
  xtensa_format fmt;
  int slot;
  int num_opcodes = xtensa_isa_num_opcodes (isa);

  op_placement_table = (op_placement_info_table)
    xmalloc (sizeof (op_placement_info) * num_opcodes);
  assert (xtensa_isa_num_formats (isa) < MAX_FORMATS);

  for (opcode = 0; opcode < num_opcodes; opcode++)
    {
      op_placement_info *opi = &op_placement_table[opcode];
      /* FIXME: Make tinsn allocation dynamic.  */
      if (xtensa_opcode_num_operands (isa, opcode) >= MAX_INSN_ARGS)
	as_fatal (_("too many operands in instruction"));
      opi->single = XTENSA_UNDEFINED;
      opi->single_size = 0;
      opi->widest = XTENSA_UNDEFINED;
      opi->widest_size = 0;
      opi->narrowest = XTENSA_UNDEFINED;
      opi->narrowest_size = 0x7F;
      opi->formats = 0;
      opi->num_formats = 0;
      opi->issuef = 0;
      for (fmt = 0; fmt < xtensa_isa_num_formats (isa); fmt++)
	{
	  opi->slots[fmt] = 0;
	  for (slot = 0; slot < xtensa_format_num_slots (isa, fmt); slot++)
	    {
	      if (xtensa_opcode_encode (isa, fmt, slot, ibuf, opcode) == 0)
		{
		  int fmt_length = xtensa_format_length (isa, fmt);
		  opi->issuef++;
		  set_bit (fmt, opi->formats);
		  set_bit (slot, opi->slots[fmt]);
		  /* opi->slot_count[fmt]++; */
		  if (fmt_length < opi->narrowest_size)
		    {
		      opi->narrowest = fmt;
		      opi->narrowest_size = fmt_length;
		    }
		  if (fmt_length > opi->widest_size)
		    {
		      opi->widest = fmt;
		      opi->widest_size = fmt_length;
		    }
		  if (xtensa_format_num_slots (isa, fmt) == 1)
		    {
		      if (opi->single_size == 0
			  || fmt_length < opi->single_size)
			{
			  opi->single = fmt;
			  opi->single_size = fmt_length;
			}
		    }
		}
	    }
	  if (opi->formats)
	    opi->num_formats++;
	}
    }
  xtensa_insnbuf_free (isa, ibuf);
}


bfd_boolean
opcode_fits_format_slot (xtensa_opcode opcode, xtensa_format fmt, int slot)
{
  return bit_is_set (slot, op_placement_table[opcode].slots[fmt]);
}


/* If the opcode is available in a single slot format, return its size.  */

static int
xg_get_single_size (xtensa_opcode opcode)
{
  assert (op_placement_table[opcode].single != XTENSA_UNDEFINED);
  return op_placement_table[opcode].single_size;
}


static xtensa_format
xg_get_single_format (xtensa_opcode opcode)
{
  return op_placement_table[opcode].single;
}


d8196 2
a8197 1
istack_init (IStack *stack)
d8205 2
a8206 1
istack_empty (IStack *stack)
d8213 2
a8214 1
istack_full (IStack *stack)
d8221 1
a8221 1
   It is an error to call this if istack_empty () is TRUE. */
d8224 2
a8225 1
istack_top (IStack *stack)
d8234 1
a8234 1
   It is an error to call this if istack_full () is TRUE.  */
d8237 3
a8239 1
istack_push (IStack *stack, TInsn *insn)
d8243 1
a8243 1
  stack->insn[rec] = *insn;
d8249 1
a8249 1
   to it.  It is an error to call this if istack_full () is TRUE.  */
d8252 2
a8253 1
istack_push_space (IStack *stack)
d8266 1
a8266 1
   istack_empty () returns TRUE.  */
d8269 2
a8270 1
istack_pop (IStack *stack)
d8282 2
a8283 1
tinsn_init (TInsn *dst)
d8289 10
d8303 3
a8305 1
tinsn_get_tok (TInsn *insn, int num)
d8312 1
a8312 1
/* Return TRUE if ANY of the operands in the insn are symbolic.  */
d8315 2
a8316 1
tinsn_has_symbolic_operands (const TInsn *insn)
d8339 2
a8340 1
tinsn_has_invalid_symbolic_operands (const TInsn *insn)
a8341 1
  xtensa_isa isa = xtensa_default_isa;
a8353 7
	case O_big:
	case O_illegal:
	case O_absent:
	  /* Errors for these types are caught later.  */
	  break;
	case O_hi16:
	case O_lo16:
d8355 5
a8359 16
	  /* Symbolic immediates are only allowed on the last immediate
	     operand.  At this time, CONST16 is the only opcode where we
	     support non-PC-relative relocations.  (It isn't necessary
	     to complain about non-PC-relative relocations here, but
	     otherwise, no error is reported until the relocations are
	     generated, and the assembler won't get that far if there
	     are any other errors.  It's nice to see all the problems
	     at once.)  */
	  if (i != get_relaxable_immed (insn->opcode)
	      || (xtensa_operand_is_PCrelative (isa, insn->opcode, i) != 1
		  && insn->opcode != xtensa_const16_opcode))
	    {
	      as_bad (_("invalid symbolic operand %d on '%s'"),
		      i, xtensa_opcode_name (isa, insn->opcode));
	      return TRUE;
	    }
d8373 2
a8374 1
tinsn_has_complex_operands (const TInsn *insn)
a8385 2
	case O_lo16:
	case O_hi16:
d8395 2
a8396 2
/* Convert the constant operands in the tinsn to insnbuf.
   Return TRUE if there is a symbol in the immediate field.
d8398 1
a8398 1
   Before this is called,
d8400 1
a8400 1
   2) the tinsn is a ITYPE_INSN
d8406 3
a8408 1
tinsn_to_insnbuf (TInsn *tinsn, xtensa_insnbuf insnbuf)
a8409 1
  static xtensa_insnbuf slotbuf = 0;
d8411 1
a8411 2
  xtensa_opcode opcode = tinsn->opcode;
  xtensa_format fmt = xg_get_single_format (opcode);
d8413 1
a8413 1
  int noperands = xtensa_opcode_num_operands (isa, opcode);
d8419 2
a8420 5
  if (!slotbuf)
    slotbuf = xtensa_insnbuf_alloc (isa);

  assert (tinsn->insn_type == ITYPE_INSN);
  if (noperands != tinsn->ntok)
d8423 1
a8423 2
  if (xtensa_opcode_encode (isa, fmt, 0, slotbuf, opcode))
    as_fatal (_("cannot encode opcode"));
d8427 2
a8428 1
      expressionS *expr = &tinsn->tok[i];
d8432 1
a8432 3
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
	  /* The register number has already been checked in
d8435 2
a8436 3
	  (void) xtensa_operand_encode (isa, opcode, i, &opnd_value);
	  xtensa_operand_set_field (isa, opcode, i, fmt, 0,
				    slotbuf, opnd_value);
a8439 2
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
d8443 1
a8443 1
	  xtensa_insnbuf_set_operand (slotbuf, fmt, 0, opcode, i,
d8447 1
a8452 4

  xtensa_format_encode (isa, fmt, insnbuf);
  xtensa_format_set_slot (isa, fmt, 0, insnbuf, slotbuf);

d8457 1
a8457 3
/* Convert the constant operands in the tinsn to slotbuf.
   Return TRUE if there is a symbol in the immediate field.
   (Eventually this should replace tinsn_to_insnbuf.)  */
d8459 3
a8461 81
/* Before this is called,
   1) the number of operands are correct
   2) the tinsn is a ITYPE_INSN
   3) ONLY the relaxable_ is built
   4) All operands are
       O_constant, O_symbol
      All constants fit

   The return value tells whether there are any remaining O_symbols.  */

static bfd_boolean
tinsn_to_slotbuf (xtensa_format fmt,
		  int slot,
		  TInsn *tinsn,
		  xtensa_insnbuf slotbuf)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode = tinsn->opcode;
  bfd_boolean has_fixup = FALSE;
  int noperands = xtensa_opcode_num_operands (isa, opcode);
  int i;

  *((int *) &slotbuf[0]) = 0;
  *((int *) &slotbuf[1]) = 0;
  assert (tinsn->insn_type == ITYPE_INSN);
  if (noperands != tinsn->ntok)
    as_fatal (_("operand number mismatch"));

  if (xtensa_opcode_encode (isa, fmt, slot, slotbuf, opcode))
    {
      as_bad (_("cannot encode opcode \"%s\" in the given format \"%s\""),
	      xtensa_opcode_name (isa, opcode), xtensa_format_name (isa, fmt));
      return FALSE;
    }

  for (i = 0; i < noperands; i++)
    {
      expressionS *expr = &tinsn->tok[i];
      int rc, line;
      char *file_name;
      uint32 opnd_value;

      switch (expr->X_op)
	{
	case O_register:
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
	  /* The register number has already been checked in
	     expression_maybe_register, so we don't need to check here.  */
	  opnd_value = expr->X_add_number;
	  (void) xtensa_operand_encode (isa, opcode, i, &opnd_value);
	  rc = xtensa_operand_set_field (isa, opcode, i, fmt, slot, slotbuf,
					 opnd_value);
	  if (rc != 0)
	    as_warn (_("xtensa-isa failure: %s"), xtensa_isa_error_msg (isa));
	  break;

	case O_constant:
	  if (xtensa_operand_is_visible (isa, opcode, i) == 0)
	    break;
	  as_where (&file_name, &line);
	  /* It is a constant and we called this function
	     then we have to try to fit it.  */
	  xtensa_insnbuf_set_operand (slotbuf, fmt, slot, opcode, i,
				      expr->X_add_number, file_name, line);
	  break;

	default:
	  has_fixup = TRUE;
	  break;
	}
    }

  return has_fixup;
}


/* Check the instruction arguments.  Return TRUE on failure.  */

static bfd_boolean
tinsn_check_arguments (const TInsn *insn)
d8472 1
a8472 1
  if (xtensa_opcode_num_operands (isa, opcode) > insn->ntok)
d8478 1
a8478 1
  if (xtensa_opcode_num_operands (isa, opcode) < insn->ntok)
d8490 3
a8492 1
tinsn_from_chars (TInsn *tinsn, char *f, int slot)
d8494 4
a8497 1
  vliw_insn vinsn;
d8499 2
a8500 6
  xg_init_vinsn (&vinsn);
  vinsn_from_chars (&vinsn, f);

  *tinsn = vinsn.slots[slot];
  xg_free_vinsn (&vinsn);
}
d8502 2
a8503 9

static void
tinsn_from_insnbuf (TInsn *tinsn,
		    xtensa_insnbuf slotbuf,
		    xtensa_format fmt,
		    int slot)
{
  int i;
  xtensa_isa isa = xtensa_default_isa;
d8506 9
a8514 10
  tinsn_init (tinsn);
  tinsn->insn_type = ITYPE_INSN;
  tinsn->is_specific_opcode = FALSE;	/* must not be specific */
  tinsn->opcode = xtensa_opcode_decode (isa, fmt, slot, slotbuf);
  tinsn->ntok = xtensa_opcode_num_operands (isa, tinsn->opcode);
  for (i = 0; i < tinsn->ntok; i++)
    {
      set_expr_const (&tinsn->tok[i],
		      xtensa_insnbuf_get_operand (slotbuf, fmt, slot,
						  tinsn->opcode, i));
d8522 3
a8524 1
tinsn_immed_from_frag (TInsn *tinsn, fragS *fragP, int slot)
d8526 1
a8526 1
  xtensa_opcode opcode = tinsn->opcode;
d8529 1
a8529 1
  if (fragP->tc_frag_data.slot_symbols[slot])
d8532 2
a8533 16
      assert (opnum >= 0);
      if (fragP->tc_frag_data.slot_sub_symbols[slot])
	{
	  set_expr_symbol_offset_diff
	    (&tinsn->tok[opnum],
	     fragP->tc_frag_data.slot_symbols[slot],
	     fragP->tc_frag_data.slot_sub_symbols[slot],
	     fragP->tc_frag_data.slot_offsets[slot]);
	}
      else
	{
	  set_expr_symbol_offset
	    (&tinsn->tok[opnum],
	     fragP->tc_frag_data.slot_symbols[slot],
	     fragP->tc_frag_data.slot_offsets[slot]);
	}
d8539 2
a8540 1
get_num_stack_text_bytes (IStack *istack)
d8547 3
a8549 3
      TInsn *tinsn = &istack->insn[i];
      if (tinsn->insn_type == ITYPE_INSN)
	text_bytes += xg_get_single_size (tinsn->opcode);
d8556 2
a8557 1
get_num_stack_literal_bytes (IStack *istack)
d8564 3
a8566 2
      TInsn *tinsn = &istack->insn[i];
      if (tinsn->insn_type == ITYPE_LITERAL && tinsn->ntok == 1)
a8572 210
/* vliw_insn functions.  */

static void
xg_init_vinsn (vliw_insn *v)
{
  int i;
  xtensa_isa isa = xtensa_default_isa;

  xg_clear_vinsn (v);

  v->insnbuf = xtensa_insnbuf_alloc (isa);
  if (v->insnbuf == NULL)
    as_fatal (_("out of memory"));

  for (i = 0; i < MAX_SLOTS; i++)
    {
      tinsn_init (&v->slots[i]);
      v->slots[i].opcode = XTENSA_UNDEFINED;
      v->slotbuf[i] = xtensa_insnbuf_alloc (isa);
      if (v->slotbuf[i] == NULL)
	as_fatal (_("out of memory"));
    }
}


static void
xg_clear_vinsn (vliw_insn *v)
{
  int i;
  v->format = XTENSA_UNDEFINED;
  v->num_slots = 0;
  v->inside_bundle = FALSE;

  if (xt_saved_debug_type != DEBUG_NONE)
    debug_type = xt_saved_debug_type;

  for (i = 0; i < MAX_SLOTS; i++)
    {
      memset (&v->slots[i], 0, sizeof (TInsn));
      v->slots[i].opcode = XTENSA_UNDEFINED;
    }
}


static bfd_boolean
vinsn_has_specific_opcodes (vliw_insn *v)
{
  int i;
  
  for (i = 0; i < v->num_slots; i++)
    {
      if (v->slots[i].is_specific_opcode)
	return TRUE;
    }
  return FALSE;
}


static void
xg_free_vinsn (vliw_insn *v)
{
  int i;
  xtensa_insnbuf_free (xtensa_default_isa, v->insnbuf);
  for (i = 0; i < MAX_SLOTS; i++)
    xtensa_insnbuf_free (xtensa_default_isa, v->slotbuf[i]);
}


/* Before this is called, we should have
   filled out the following fields:

   1) the number of operands for each opcode are correct
   2) the tinsn in the slots are ITYPE_INSN
   3) ONLY the relaxable_ is built
   4) All operands are
       O_constant, O_symbol
      All constants fit

   The return value tells whether there are any remaining O_symbols.  */

static bfd_boolean
vinsn_to_insnbuf (vliw_insn *vinsn,
		  char *frag_offset,
		  fragS *fragP,
		  bfd_boolean record_fixup)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_format fmt = vinsn->format;
  xtensa_insnbuf insnbuf = vinsn->insnbuf;
  int slot;
  bfd_boolean has_fixup = FALSE;

  xtensa_format_encode (isa, fmt, insnbuf);

  for (slot = 0; slot < vinsn->num_slots; slot++)
    {
      TInsn *tinsn = &vinsn->slots[slot];
      bfd_boolean tinsn_has_fixup =
	tinsn_to_slotbuf (vinsn->format, slot, tinsn,
			  vinsn->slotbuf[slot]);

      xtensa_format_set_slot (isa, fmt, slot,
			      insnbuf, vinsn->slotbuf[slot]);
      /* tinsn_has_fixup tracks if there is a fixup at all.
	 record_fixup controls globally.  I.E., we use this
	 function from several places, some of which are after
	 fixups have already been recorded.  Finally,
	 tinsn->record_fixup controls based on the individual ops,
	 which may or may not need it based on the relaxation
	 requirements.  */
      if (tinsn_has_fixup && record_fixup)
	{
	  int i;
	  xtensa_opcode opcode = tinsn->opcode;
	  int noperands = xtensa_opcode_num_operands (isa, opcode);
	  has_fixup = TRUE;

	  for (i = 0; i < noperands; i++)
	    {
	      expressionS* expr = &tinsn->tok[i];
	      switch (expr->X_op)
		{
		case O_symbol:
		case O_lo16:
		case O_hi16:
		  if (get_relaxable_immed (opcode) == i)
		    {
		      if (tinsn->record_fix || expr->X_op != O_symbol)
			{
			  if (!xg_add_opcode_fix
			      (tinsn, i, fmt, slot, expr, fragP,
			       frag_offset - fragP->fr_literal))
			    as_bad (_("instruction with constant operands does not fit"));
			}
		      else
			{
			  tinsn->symbol = expr->X_add_symbol;
			  tinsn->offset = expr->X_add_number;
			}
		    }
		  else
		    as_bad (_("invalid operand %d on '%s'"),
			    i, xtensa_opcode_name (isa, opcode));
		  break;

		case O_constant:
		case O_register:
		  break;

		case O_subtract:
		  if (get_relaxable_immed (opcode) == i)
		    {
		      if (tinsn->record_fix)
			  as_bad (_("invalid subtract operand"));
		      else
			{
			  tinsn->symbol = expr->X_add_symbol;
			  tinsn->sub_symbol = expr->X_op_symbol;
			  tinsn->offset = expr->X_add_number;
			}
		    }
		  else
		    as_bad (_("invalid operand %d on '%s'"),
			    i, xtensa_opcode_name (isa, opcode));
		  break;

		default:
		  as_bad (_("invalid expression for operand %d on '%s'"),
			  i, xtensa_opcode_name (isa, opcode));
		  break;
		}
	    }
	}
    }

  return has_fixup;
}


static void
vinsn_from_chars (vliw_insn *vinsn, char *f)
{
  static xtensa_insnbuf insnbuf = NULL;
  static xtensa_insnbuf slotbuf = NULL;
  int i;
  xtensa_format fmt;
  xtensa_isa isa = xtensa_default_isa;

  if (!insnbuf)
    {
      insnbuf = xtensa_insnbuf_alloc (isa);
      slotbuf = xtensa_insnbuf_alloc (isa);
    }

  xtensa_insnbuf_from_chars (isa, insnbuf, f, 0);
  fmt = xtensa_format_decode (isa, insnbuf);
  if (fmt == XTENSA_UNDEFINED)
    as_fatal (_("cannot decode instruction format"));
  vinsn->format = fmt;
  vinsn->num_slots = xtensa_format_num_slots (isa, fmt);

  for (i = 0; i < vinsn->num_slots; i++)
    {
      TInsn *tinsn = &vinsn->slots[i];
      xtensa_format_get_slot (isa, fmt, i, insnbuf, slotbuf);
      tinsn_from_insnbuf (tinsn, slotbuf, fmt, i);
    }
}


d8575 1
a8575 1
/* Return TRUE if the expression is an integer constant.  */
d8578 2
a8579 1
expr_is_const (const expressionS *s)
d8586 1
a8586 1
   Calling this is illegal if expr_is_const () returns TRUE.  */
d8589 2
a8590 1
get_expr_const (const expressionS *s)
d8600 3
a8602 1
set_expr_const (expressionS *s, offsetT val)
a8610 18
bfd_boolean
expr_is_register (const expressionS *s)
{
  return (s->X_op == O_register);
}


/* Get the expression constant.
   Calling this is illegal if expr_is_const () returns TRUE.  */

offsetT
get_expr_register (const expressionS *s)
{
  assert (expr_is_register (s));
  return s->X_add_number;
}


d8614 4
a8617 1
set_expr_symbol_offset (expressionS *s, symbolS *sym, offsetT offset)
a8625 17
/* Set the expression to symbol - minus_sym + offset.  */

static void
set_expr_symbol_offset_diff (expressionS *s,
			     symbolS *sym,
			     symbolS *minus_sym,
			     offsetT offset)
{
  s->X_op = O_subtract;
  s->X_add_symbol = sym;
  s->X_op_symbol = minus_sym;	/* unused */
  s->X_add_number = offset;
}


/* Return TRUE if the two expressions are equal.  */

d8627 3
a8629 1
expr_is_equal (expressionS *s1, expressionS *s2)
d8644 3
a8646 1
copy_expr (expressionS *dst, const expressionS *src)
d8652 3
a8654 1
/* Support for the "--rename-section" option.  */
d8666 2
a8667 4
/* Parse the string "oldname=new_name(:oldname2=new_name2)*" and add
   entries to the section_rename list.  Note: Specifying multiple
   renamings separated by colons is not documented and is retained only
   for backward compatibility.  */
d8669 3
a8671 2
static void
build_section_rename (const char *arg)
a8672 1
  struct rename_section_struct *r;
d8676 1
a8676 1
  for (this_arg = xstrdup (arg); this_arg != NULL; this_arg = next_arg)
a8677 2
      char *old_name, *new_name;

d8687 21
a8708 2
      old_name = this_arg;
      new_name = strchr (this_arg, '=');
d8710 6
a8715 13
      if (*old_name == '\0')
	{
	  as_warn (_("ignoring extra '-rename-section' delimiter ':'"));
	  continue;
	}
      if (!new_name || new_name[1] == '\0')
	{
	  as_warn (_("ignoring invalid '-rename-section' specification: '%s'"),
		   old_name);
	  continue;
	}
      *new_name = '\0';
      new_name++;
d8717 8
a8724 17
      /* Check for invalid section renaming.  */
      for (r = section_rename; r != NULL; r = r->next)
	{
	  if (strcmp (r->old_name, old_name) == 0)
	    as_bad (_("section %s renamed multiple times"), old_name);
	  if (strcmp (r->new_name, new_name) == 0)
	    as_bad (_("multiple sections remapped to output section %s"),
		    new_name);
	}

      /* Now add it.  */
      r = (struct rename_section_struct *)
	xmalloc (sizeof (struct rename_section_struct));
      r->old_name = xstrdup (old_name);
      r->new_name = xstrdup (new_name);
      r->next = section_rename;
      section_rename = r;
d8726 8
d8737 3
a8739 2
char *
xtensa_section_rename (char *name)
d8744 2
a8745 4
    {
      if (strcmp (r->old_name, name) == 0)
	return r->new_name;
    }
d8749 2
@


1.1.3.1
log
@Import testing binutils source into main tree
@
text
@@


1.1.3.2
log
@sync with testing_SYNC_C from testing/binutils, which apparently works
@
text
@d3724 1
a3724 1
  assert (insn->ntok == 1);	/* must be only one token here */
@

