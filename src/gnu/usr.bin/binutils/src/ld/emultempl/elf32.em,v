head	1.9;
access;
symbols
	cvs-200501080000:1.1.2.2
	tg-mergetmp-mirosx-1:1.8
	tg-mergefixes-1-branch:1.8.0.4
	tg-mergefixes-1-base:1.8
	MIROS_X:1.8.0.2
	MIROS_X_BASE:1.8
	MIRBSD_XP_MIRPPC:1.6.0.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	cvs-200409160000:1.1.2.1
	FSF:1.1.2
	testing_SYNC_D:1.3
	testing_SYNC_C:1.1.3.2
	testing_SYNC_B:1.2
	testing_SYNC_A:1.1.3.1
	tg:1.1.3;
locks; strict;
comment	@# @;


1.9
date	2005.01.13.19.44.21;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.14.18.37.16;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.14.17.31.45;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.29.23.10.28;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.26.22.11.32;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.16.22.28.12;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.12.20.28.58;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.08.12.01.00.53;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.11.20.40.43;	author tg;	state Exp;
branches
	1.1.2.1
	1.1.3.1;
next	;

1.1.2.1
date	2004.09.16.21.30.59;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.01.08.22.53.32;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.08.11.20.40.43;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.08.12.20.09.54;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@merge binutils update (quick)
@
text
@# $MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.8 2004/10/14 18:37:16 tg Exp $

# This shell script emits a C file. -*- C -*-
# It does some substitutions.
# This file is now misnamed, because it supports both 32 bit and 64 bit
# ELF emulations.
test -z "${ELFSIZE}" && ELFSIZE=32
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
cat >e${EMULATION_NAME}.c <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* ${ELFSIZE} bit ELF emulation code for ${EMULATION_NAME}
   Copyright (c) 2004 The MirOS Project.
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.
   Written by Steve Chamberlain <sac@@cygnus.com>
   ELF support by Ian Lance Taylor <ian@@cygnus.com>

This file is part of GLD, the Gnu Linker.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define TARGET_IS_${EMULATION_NAME}

#include "bfd.h"
#include "sysdep.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "getopt.h"

#include "bfdlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"
#include <ldgram.h>
#include "elf/common.h"

__RCSID("$MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.8 2004/10/14 18:37:16 tg Exp $");

/* Declare functions used by various EXTRA_EM_FILEs.  */
static void gld${EMULATION_NAME}_before_parse (void);
static void gld${EMULATION_NAME}_after_open (void);
static void gld${EMULATION_NAME}_before_allocation (void);
static bfd_boolean gld${EMULATION_NAME}_place_orphan
  (lang_input_statement_type *file, asection *s);
static void gld${EMULATION_NAME}_finish (void);

EOF
case ${target} in
  *-*-openbsd* | *-*-mirbsd*)
    cat >>e${EMULATION_NAME}.c <<EOF
#include <sys/types.h>
#include <dirent.h>

/* Search a directory for a .so file.  */

static char *gld${EMULATION_NAME}_search_dir (const char *, const char *);

static char *gld${EMULATION_NAME}_search_dir_mm (const char *dirname,
  const char *filename, int req_maj, int req_min);

static char *gld${EMULATION_NAME}_split_lib_name (char *name, int *pmaj,
  int *pmin);

/* THIS FUNCTION MODIFIES THE name ARGUMENT string */
static char *
gld${EMULATION_NAME}_split_lib_name (name, pmaj, pmin)
  char *name;
  int *pmaj, *pmin;
{
  char*eptr, *lib = name;
  char *s;
  int found_so = 0;

  *pmaj = -1;
  *pmin = -1;
  
  if (strncmp(lib, "lib", 3) == 0)   
    lib += 3;

  s = lib;
  while (found_so == 0)
    {
      s = strstr(s, ".so");

      /* if .so not found, return not found, invalid lib name */
      if (s == NULL)
	{
	  return NULL;
	}

      /* if .so is at end of string, fine return with pmaj/pmin -1 */
      if (s[3] == '\0')
	{
	  *s = '\0';
	  return lib;
	}

      if (s[3] == '.')
	{
	  *s = '\0';
	  found_so = 1;
	}
      /* skip over the ".so" */
      s += 3;
    }

  
  /* lib[name].so.[M].[N] */
  /*  s          ^        */
  s += 1;

  /* lib[name].so.[M].[N] */
  /*  s           ^       */
  *pmaj = strtoul (s, &eptr, 10);

  /* lib[name].so.[M]X... */
  /*  eptr           ^    */
  if (*eptr != '.' || s == eptr)
    return NULL; /* invalid, must have minor */

  s = eptr+1;

  /* lib[name].so.[M].[N]  */
  /*  s               ^    */
  *pmin = strtoul (s, &eptr, 10);

  /* lib[name].so.[M].[N]  */
  /*  eptr               ^ */
  if (*eptr != '\0' || s == eptr)
    return NULL;  /* minor must be last field of library */

  return lib;
}

static char *
gld${EMULATION_NAME}_search_dir (dirlist, filename)
    const char *dirlist;
    const char *filename;
{
  char *dlist, *dlist_alloc, *dir;
  char *fnam, *fnam_alloc, *lib;
  char *found = NULL;
  int maj = -1, min = -1;
  
  dlist_alloc = dlist = xstrdup(dirlist);
  fnam_alloc = fnam = xstrdup(filename);
  
  lib = gld${EMULATION_NAME}_split_lib_name(fnam, &maj, &min);
  
  while (lib != NULL && found == NULL)
    {
      dir = strsep(&dlist, ":");
      if (dir == NULL)
	break;
      if (*dir == '\0')
	continue; /* skip dirlist of ...::... */
      found = gld${EMULATION_NAME}_search_dir_mm(dir, lib, maj, min);
    }
  
  free(dlist_alloc);
  free(fnam_alloc);
  return found;
}


static char *
gld${EMULATION_NAME}_search_dir_mm (dirname, filename, req_maj, req_min)
     const char *dirname;
     const char *filename;
     int req_maj, req_min;
{
  const char *dot;
  unsigned int len;
  char *found;
  int max_maj, max_min;
  DIR *dir;
  struct dirent *entry;
  unsigned int dirnamelen;
  char *full_path;
  int statval;
  struct stat st;

  dot = strchr (filename, '.');
  len = strlen (filename);
  found = NULL;
  max_maj = max_min = 0;

  dir = opendir (dirname);
  if (dir == NULL)
    return NULL;
  dirnamelen = strlen (dirname);

  while ((entry = readdir (dir)) != NULL)
    {
      const char *s;
      char *eptr, *eptr1;
      int found_maj, found_min;

      if (strncmp (entry->d_name, "lib", 3) != 0
	  || strncmp (entry->d_name + 3, filename, len) != 0)
	continue;

      /* We accept libfoo.so without a version number, even though the
         native linker does not.  This is more convenient for packages
         which just generate .so files for shared libraries, as on ELF
         systems.  */
      if (strncmp (entry->d_name + 3 + len, ".so", 3) != 0)
	continue;

      if (entry->d_name[6 + len] == '\0')
	;
      else if (entry->d_name[6 + len] == '.'
	       && ISDIGIT ((unsigned char) entry->d_name[7 + len]))
	;
      else
	continue;

      for (s = entry->d_name + 6 + len; *s != '\0'; s++)
	if (*s != '.' && ! ISDIGIT ((unsigned char) *s))
	  break;
      if (*s != '\0')
	continue;

      /* We've found a .so file.  Work out the major and minor
	 version numbers.  */
      found_maj = -1;
      found_min = -1;

      /* do allow libN.so */
      if (entry->d_name[6 + len] == '.') {
	found_maj = strtoul (entry->d_name + 7 + len, &eptr, 10);

	/* do not support libN.so. or libN.so.X */
	if (*eptr != '.' || ((entry->d_name + 3 + len) == eptr))
	  continue;

	found_min = strtoul (eptr+1, &eptr1, 10);

	/* do not support libN.so.X. or libN.so.X.Y.[anything] */
	if (*eptr1 != '\0' || (eptr+1 == eptr1))
	  continue;
      }

      /* Make sure the file really exists (ignore broken symlinks).  */
      full_path = xmalloc (dirnamelen + 1 + strlen (entry->d_name) + 1);
      sprintf (full_path, "%s/%s", dirname, entry->d_name);
      statval = stat (full_path, &st);
      free (full_path);
      if (statval != 0)
	continue;

      /* We've found a match for the name we are searching for.  See
	 if this is the version we should use.  */
      if (((req_maj == -1) && (found == NULL
	    || (found_maj > max_maj)
	    || (found_maj == max_maj && (found_min > max_min))))
	  || ((found_maj == req_maj) && (found_min >= req_min)
	    && (found_min > max_min)))
	{
	  if (found != NULL)
	    free (found);
	  found = (char *) xmalloc (dirnamelen + strlen (entry->d_name) + 2);
	  sprintf (found, "%s/%s", dirname, entry->d_name);
	  max_maj = found_maj;
	  max_min = found_min;
	}
    }

  closedir (dir);

  return found;
}

EOF
    ;;
esac
cat >>e${EMULATION_NAME}.c <<EOF
EOF

if [ "x${USE_LIBPATH}" = xyes ] ; then
  case ${target} in
    *-*-linux-gnu*)
  cat >>e${EMULATION_NAME}.c <<EOF
#include <glob.h>
EOF
    ;;
  esac
fi

# Import any needed special functions and/or overrides.
#
if test -n "$EXTRA_EM_FILE" ; then
. ${srcdir}/emultempl/${EXTRA_EM_FILE}.em
fi

# Functions in this file can be overridden by setting the LDEMUL_* shell
# variables.  If the name of the overriding function is the same as is
# defined in this file, then don't output this file's version.
# If a different overriding name is given then output the standard function
# as presumably it is called from the overriding function.
#
if test x"$LDEMUL_BEFORE_PARSE" != xgld"$EMULATION_NAME"_before_parse; then
cat >>e${EMULATION_NAME}.c <<EOF

static void
gld${EMULATION_NAME}_before_parse (void)
{
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
  config.dynamic_link = ${DYNAMIC_LINK-TRUE};
  config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo TRUE ; else echo FALSE ; fi`;
}

EOF
fi

if test x"$LDEMUL_RECOGNIZED_FILE" != xgld"${EMULATION_NAME}"_load_symbols; then
cat >>e${EMULATION_NAME}.c <<EOF
/* Handle as_needed DT_NEEDED.  */

static bfd_boolean
gld${EMULATION_NAME}_load_symbols (lang_input_statement_type *entry)
{
  int class = 0;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file, unless it is used to resolve
     references in a regular object.  */
  if (entry->as_needed)
    class = DYN_AS_NEEDED;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for any dynamic library in DT_NEEDED tags from
     this file at all.  */
  if (!entry->add_needed)
    class |= DYN_NO_ADD_NEEDED;

  if (!class
      || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)
    return FALSE;

  bfd_elf_set_dyn_lib_class (entry->the_bfd, class);

  /* Continue on with normal load_symbols processing.  */
  return FALSE;
}
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF

/* These variables are required to pass information back and forth
   between after_open and check_needed and stat_needed and vercheck.  */

static struct bfd_link_needed_list *global_needed;
static struct stat global_stat;
static bfd_boolean global_found;
static struct bfd_link_needed_list *global_vercheck_needed;
static bfd_boolean global_vercheck_failed;


/* On Linux, it's possible to have different versions of the same
   shared library linked against different versions of libc.  The
   dynamic linker somehow tags which libc version to use in
   /etc/ld.so.cache, and, based on the libc that it sees in the
   executable, chooses which version of the shared library to use.

   We try to do a similar check here by checking whether this shared
   library needs any other shared libraries which may conflict with
   libraries we have already included in the link.  If it does, we
   skip it, and try to find another shared library farther on down the
   link path.

   This is called via lang_for_each_input_file.
   GLOBAL_VERCHECK_NEEDED is the list of objects needed by the object
   which we are checking.  This sets GLOBAL_VERCHECK_FAILED if we find
   a conflicting version.  */

static void
gld${EMULATION_NAME}_vercheck (lang_input_statement_type *s)
{
  const char *soname;
  struct bfd_link_needed_list *l;

  if (global_vercheck_failed)
    return;
  if (s->the_bfd == NULL
      || (bfd_get_file_flags (s->the_bfd) & DYNAMIC) == 0)
    return;

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = lbasename (bfd_get_filename (s->the_bfd));

  for (l = global_vercheck_needed; l != NULL; l = l->next)
    {
      const char *suffix;

      if (strcmp (soname, l->name) == 0)
	{
	  /* Probably can't happen, but it's an easy check.  */
	  continue;
	}

      if (strchr (l->name, '/') != NULL)
	continue;

      suffix = strstr (l->name, ".so.");
      if (suffix == NULL)
	continue;

      suffix += sizeof ".so." - 1;

      if (strncmp (soname, l->name, suffix - l->name) == 0)
	{
	  /* Here we know that S is a dynamic object FOO.SO.VER1, and
	     the object we are considering needs a dynamic object
	     FOO.SO.VER2, and VER1 and VER2 are different.  This
	     appears to be a version mismatch, so we tell the caller
	     to try a different version of this library.  */
	  global_vercheck_failed = TRUE;
	  return;
	}
    }
}


/* See if an input file matches a DT_NEEDED entry by running stat on
   the file.  */

static void
gld${EMULATION_NAME}_stat_needed (lang_input_statement_type *s)
{
  struct stat st;
  const char *suffix;
  const char *soname;

  if (global_found)
    return;
  if (s->the_bfd == NULL)
    return;

  if (bfd_stat (s->the_bfd, &st) != 0)
    {
      einfo ("%P:%B: bfd_stat failed: %E\n", s->the_bfd);
      return;
    }

  if (st.st_dev == global_stat.st_dev
      && st.st_ino == global_stat.st_ino)
    {
      global_found = TRUE;
      return;
    }

  /* We issue a warning if it looks like we are including two
     different versions of the same shared library.  For example,
     there may be a problem if -lc picks up libc.so.6 but some other
     shared library has a DT_NEEDED entry of libc.so.5.  This is a
     heuristic test, and it will only work if the name looks like
     NAME.so.VERSION.  FIXME: Depending on file names is error-prone.
     If we really want to issue warnings about mixing version numbers
     of shared libraries, we need to find a better way.  */

  if (strchr (global_needed->name, '/') != NULL)
    return;
  suffix = strstr (global_needed->name, ".so.");
  if (suffix == NULL)
    return;
  suffix += sizeof ".so." - 1;

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = lbasename (s->filename);

  if (strncmp (soname, global_needed->name, suffix - global_needed->name) == 0)
    einfo ("%P: warning: %s, needed by %B, may conflict with %s\n",
	   global_needed->name, global_needed->by, soname);
}

struct dt_needed
{
  bfd *by;
  const char *name;
};

/* This function is called for each possible name for a dynamic object
   named by a DT_NEEDED entry.  The FORCE parameter indicates whether
   to skip the check for a conflicting version.  */

static bfd_boolean
gld${EMULATION_NAME}_try_needed (struct dt_needed *needed,
				 int force)
{
  bfd *abfd;
  const char *name = needed->name;
  const char *soname;
  int class;

  abfd = bfd_openr (name, bfd_get_target (output_bfd));
  if (abfd == NULL)
    return FALSE;
  if (! bfd_check_format (abfd, bfd_object))
    {
      bfd_close (abfd);
      return FALSE;
    }
  if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)
    {
      bfd_close (abfd);
      return FALSE;
    }

  /* For DT_NEEDED, they have to match.  */
  if (abfd->xvec != output_bfd->xvec)
    {
      bfd_close (abfd);
      return FALSE;
    }

  /* Check whether this object would include any conflicting library
     versions.  If FORCE is set, then we skip this check; we use this
     the second time around, if we couldn't find any compatible
     instance of the shared library.  */

  if (! force)
    {
      struct bfd_link_needed_list *needed;

      if (! bfd_elf_get_bfd_needed_list (abfd, &needed))
	einfo ("%F%P:%B: bfd_elf_get_bfd_needed_list failed: %E\n", abfd);

      if (needed != NULL)
	{
	  global_vercheck_needed = needed;
	  global_vercheck_failed = FALSE;
	  lang_for_each_input_file (gld${EMULATION_NAME}_vercheck);
	  if (global_vercheck_failed)
	    {
	      bfd_close (abfd);
	      /* Return FALSE to force the caller to move on to try
		 another file on the search path.  */
	      return FALSE;
	    }

	  /* But wait!  It gets much worse.  On Linux, if a shared
	     library does not use libc at all, we are supposed to skip
	     it the first time around in case we encounter a shared
	     library later on with the same name which does use the
	     version of libc that we want.  This is much too horrible
	     to use on any system other than Linux.  */

EOF
case ${target} in
  *-*-linux-gnu*)
    cat >>e${EMULATION_NAME}.c <<EOF
	  {
	    struct bfd_link_needed_list *l;

	    for (l = needed; l != NULL; l = l->next)
	      if (strncmp (l->name, "libc.so", 7) == 0)
		break;
	    if (l == NULL)
	      {
		bfd_close (abfd);
		return FALSE;
	      }
	  }

EOF
    ;;
esac
cat >>e${EMULATION_NAME}.c <<EOF
	}
    }

  /* We've found a dynamic object matching the DT_NEEDED entry.  */

  /* We have already checked that there is no other input file of the
     same name.  We must now check again that we are not including the
     same file twice.  We need to do this because on many systems
     libc.so is a symlink to, e.g., libc.so.1.  The SONAME entry will
     reference libc.so.1.  If we have already included libc.so, we
     don't want to include libc.so.1 if they are the same file, and we
     can only check that using stat.  */

  if (bfd_stat (abfd, &global_stat) != 0)
    einfo ("%F%P:%B: bfd_stat failed: %E\n", abfd);

  /* First strip off everything before the last '/'.  */
  soname = xstrdup (lbasename (abfd->filename));

  if (trace_file_tries)
    info_msg (_("found %s at %s\n"), soname, name);

  global_found = FALSE;
  lang_for_each_input_file (gld${EMULATION_NAME}_stat_needed);
  if (global_found)
    {
      /* Return TRUE to indicate that we found the file, even though
	 we aren't going to do anything with it.  */
      free((void *)soname);
      return TRUE;
    }

  /* Specify the soname to use.  */
  bfd_elf_set_dt_needed_name (abfd, soname);

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file, unless it is used to resolve
     references in a regular object.  */
  class = DYN_DT_NEEDED;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file at all if the entry is from a file
     with DYN_NO_ADD_NEEDED.  */
  if (needed->by
      && (bfd_elf_get_dyn_lib_class (needed->by)
	  & DYN_NO_ADD_NEEDED) != 0)
    class |= DYN_NO_NEEDED | DYN_NO_ADD_NEEDED;

  bfd_elf_set_dyn_lib_class (abfd, class);

  /* Add this file into the symbol table.  */
  if (! bfd_link_add_symbols (abfd, &link_info))
    einfo ("%F%B: could not read symbols: %E\n", abfd);

  return TRUE;
}


/* Search for a needed file in a path.  */

static bfd_boolean
gld${EMULATION_NAME}_search_needed (const char *path,
				    struct dt_needed *n, int force)
{
  const char *s;
  const char *name = n->name;
  size_t len;
  struct dt_needed needed;

  if (name[0] == '/')
    return gld${EMULATION_NAME}_try_needed (n, force);

  if (path == NULL || *path == '\0')
    return FALSE;

EOF
case ${target} in
  *-*-openbsd* | *-*-mirbsd*)
    cat >>e${EMULATION_NAME}.c <<EOF
  {
    char *found;
    if ((found = gld${EMULATION_NAME}_search_dir(path, name)) != NULL) {
      needed.name = found;
      if (gld${EMULATION_NAME}_try_needed (&needed, force)) {
	free(found);
	return TRUE;
      }
      free(found);
    }
  }

EOF
esac
cat >>e${EMULATION_NAME}.c <<EOF
  needed.by = n->by;
  needed.name = n->name;

  len = strlen (name);
  while (1)
    {
      char *filename, *sset;

      s = strchr (path, ':');
      if (s == NULL)
	s = path + strlen (path);

      filename = (char *) xmalloc (s - path + len + 2);
      if (s == path)
	sset = filename;
      else
	{
	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);

      needed.name = filename;
      if (gld${EMULATION_NAME}_try_needed (&needed, force))
	return TRUE;

      free (filename);

      if (*s == '\0')
	break;
      path = s + 1;
    }

  return FALSE;
}

EOF
if [ "x${USE_LIBPATH}" = xyes ] ; then
  cat >>e${EMULATION_NAME}.c <<EOF

/* Add the sysroot to every entry in a colon-separated path.  */

static char *
gld${EMULATION_NAME}_add_sysroot (const char *path)
{
  int len, colons, i;
  char *ret, *p;

  len = strlen (path);
  colons = 0;
  i = 0;
  while (path[i])
    if (path[i++] == ':')
      colons++;

  if (path[i])
    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
  p = ret + strlen (ret);
  i = 0;
  while (path[i])
    if (path[i] == ':')
      {
	*p++ = path[i++];
	strcpy (p, ld_sysroot);
	p = p + strlen (p);
      }
    else
      *p++ = path[i++];

  *p = 0;
  return ret;
}

EOF
  case ${target} in
    *-*-linux-gnu*)
      cat >>e${EMULATION_NAME}.c <<EOF
/* For a native linker, check the file /etc/ld.so.conf for directories
   in which we may find shared libraries.  /etc/ld.so.conf is really
   only meaningful on Linux.  */

struct gld${EMULATION_NAME}_ld_so_conf
{
  char *path;
  size_t len, alloc;
};

static void
gld${EMULATION_NAME}_parse_ld_so_conf
     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename);

static void
gld${EMULATION_NAME}_parse_ld_so_conf_include
     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename,
      const char *pattern)
{
  char *newp = NULL;
  glob_t gl;

  if (pattern[0] != '/')
    {
      char *p = strrchr (filename, '/');
      size_t patlen = strlen (pattern) + 1;

      newp = xmalloc (p - filename + 1 + patlen);
      memcpy (newp, filename, p - filename + 1);
      memcpy (newp + (p - filename + 1), pattern, patlen);
      pattern = newp;
    }

  if (glob (pattern, 0, NULL, &gl) == 0)
    {
      size_t i;

      for (i = 0; i < gl.gl_pathc; ++i)
	gld${EMULATION_NAME}_parse_ld_so_conf (info, gl.gl_pathv[i]);
      globfree (&gl);
    }

  if (newp)
    free (newp);
}

static void
gld${EMULATION_NAME}_parse_ld_so_conf
     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename)
{
  FILE *f = fopen (filename, FOPEN_RT);
  char *line;
  size_t linelen;

  if (f == NULL)
    return;

  linelen = 256;
  line = xmalloc (linelen);
  do
    {
      char *p = line, *q;

      /* Normally this would use getline(3), but we need to be portable.  */
      while ((q = fgets (p, linelen - (p - line), f)) != NULL
	     && strlen (q) == linelen - (p - line) - 1
	     && line[linelen - 2] != '\n')
	{
	  line = xrealloc (line, 2 * linelen);
	  p = line + linelen - 1;
	  linelen += linelen;
	}

      if (q == NULL && p == line)
	break;

      p = strchr (line, '\n');
      if (p)
	*p = '\0';

      /* Because the file format does not know any form of quoting we
	 can search forward for the next '#' character and if found
	 make it terminating the line.  */
      p = strchr (line, '#');
      if (p)
	*p = '\0';

      /* Remove leading whitespace.  NUL is no whitespace character.  */
      p = line;
      while (*p == ' ' || *p == '\f' || *p == '\r' || *p == '\t' || *p == '\v')
	++p;

      /* If the line is blank it is ignored.  */
      if (p[0] == '\0')
	continue;

      if (!strncmp (p, "include", 7) && (p[7] == ' ' || p[7] == '\t'))
	{
	  char *dir, c;
	  p += 8;
	  do
	    {
	      while (*p == ' ' || *p == '\t')
		++p;

	      if (*p == '\0')
		break;

	      dir = p;

	      while (*p != ' ' && *p != '\t' && *p)
		++p;

	      c = *p;
	      *p++ = '\0';
	      if (dir[0] != '\0')
		gld${EMULATION_NAME}_parse_ld_so_conf_include (info, filename,
							       dir);
	    }
	  while (c != '\0');
	}
      else
	{
	  char *dir = p;
	  while (*p && *p != '=' && *p != ' ' && *p != '\t' && *p != '\f'
		 && *p != '\r' && *p != '\v')
	    ++p;

	  while (p != dir && p[-1] == '/')
	    --p;
	  if (info->path == NULL)
	    {
	      info->alloc = p - dir + 1 + 256;
	      info->path = xmalloc (info->alloc);
	      info->len = 0;
	    }
	  else
	    {
	      if (info->len + 1 + (p - dir) >= info->alloc)
		{
		  info->alloc += p - dir + 256;
		  info->path = xrealloc (info->path, info->alloc);
		}
	      info->path[info->len++] = ':';
	    }
	  memcpy (info->path + info->len, dir, p - dir);
	  info->len += p - dir;
	  info->path[info->len] = '\0';
	}
    }
  while (! feof (f));
  free (line);
  fclose (f);
}

static bfd_boolean
gld${EMULATION_NAME}_check_ld_so_conf (const char *name, int force)
{
  static bfd_boolean initialized;
  static char *ld_so_conf;
  struct dt_needed needed;

  if (! initialized)
    {
      char *tmppath;
      struct gld${EMULATION_NAME}_ld_so_conf info;

      tmppath = concat (ld_sysroot, "/etc/ld.so.conf", NULL);
      info.path = NULL;
      info.len = info.alloc = 0;
      gld${EMULATION_NAME}_parse_ld_so_conf (&info, tmppath);
      free (tmppath);
      if (info.path)
	{
	  char *d = gld${EMULATION_NAME}_add_sysroot (info.path);
	  free (info.path);
	  ld_so_conf = d;
	}
      initialized = TRUE;
    }

  if (ld_so_conf == NULL)
    return FALSE;


  needed.by = NULL;
  needed.name = name;
  return gld${EMULATION_NAME}_search_needed (ld_so_conf, &needed, force);
}

EOF
    # Linux
    ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF

/* See if an input file matches a DT_NEEDED entry by name.  */

static void
gld${EMULATION_NAME}_check_needed (lang_input_statement_type *s)
{
  if (global_found)
    return;

  if (s->filename != NULL)
    {
      const char *f;

      if (strcmp (s->filename, global_needed->name) == 0)
	{
	  global_found = TRUE;
	  return;
	}

      if (s->search_dirs_flag)
	{
	  f = strrchr (s->filename, '/');
	  if (f != NULL
	      && strcmp (f + 1, global_needed->name) == 0)
	    {
	      global_found = TRUE;
	      return;
	    }
	}
    }

  if (s->the_bfd != NULL)
    {
      const char *soname;

      soname = bfd_elf_get_dt_soname (s->the_bfd);
      if (soname != NULL
	  && strcmp (soname, global_needed->name) == 0)
	{
	  global_found = TRUE;
	  return;
	}
    }
}

EOF

if test x"$LDEMUL_AFTER_OPEN" != xgld"$EMULATION_NAME"_after_open; then
cat >>e${EMULATION_NAME}.c <<EOF

/* This is called after all the input files have been opened.  */

static void
gld${EMULATION_NAME}_after_open (void)
{
  struct bfd_link_needed_list *needed, *l;

  /* We only need to worry about this when doing a final link.  */
  if (link_info.relocatable || !link_info.executable)
    return;

  /* Get the list of files which appear in DT_NEEDED entries in
     dynamic objects included in the link (often there will be none).
     For each such file, we want to track down the corresponding
     library, and include the symbol table in the link.  This is what
     the runtime dynamic linker will do.  Tracking the files down here
     permits one dynamic object to include another without requiring
     special action by the person doing the link.  Note that the
     needed list can actually grow while we are stepping through this
     loop.  */
  needed = bfd_elf_get_needed_list (output_bfd, &link_info);
  for (l = needed; l != NULL; l = l->next)
    {
      struct bfd_link_needed_list *ll;
      struct dt_needed n, nn;
      int force;

      /* If we've already seen this file, skip it.  */
      for (ll = needed; ll != l; ll = ll->next)
	if (strcmp (ll->name, l->name) == 0)
	  break;
      if (ll != l)
	continue;

      /* See if this file was included in the link explicitly.  */
      global_needed = l;
      global_found = FALSE;
      lang_for_each_input_file (gld${EMULATION_NAME}_check_needed);
      if (global_found)
	continue;

      n.by = l->by;
      n.name = l->name;
      nn.by = l->by;
      if (trace_file_tries)
	info_msg (_("%s needed by %B\n"), l->name, l->by);

      /* We need to find this file and include the symbol table.  We
	 want to search for the file in the same way that the dynamic
	 linker will search.  That means that we want to use
	 rpath_link, rpath, then the environment variable
	 LD_LIBRARY_PATH (native only), then the DT_RPATH/DT_RUNPATH
	 entries (native only), then the linker script LIB_SEARCH_DIRS.
	 We look at the -L arguments to build search path.

	 We search twice.  The first time, we skip objects which may
	 introduce version mismatches.  The second time, we force
	 their use.  See gld${EMULATION_NAME}_vercheck comment.  */
      for (force = 0; force < 2; force++)
	{
	  size_t len;
	  search_dirs_type *search;
EOF
if [ "x${USE_LIBPATH}" = xyes ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
	  char *lib_path;
	  struct bfd_link_needed_list *rp;
	  int found;
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF

	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath_link,
						  &n, force))
	    break;
EOF
if [ "x${USE_LIBPATH}" = xyes ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath,
						  &n, force))
	    break;
EOF
fi
if [ "x${NATIVE}" = xyes ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
	  if (getenv("LD_RUN_PATH") != NULL
	      && command_line.rpath_link == NULL
	      && command_line.rpath == NULL)
	    {
	      lib_path = (char *) getenv ("LD_RUN_PATH");
	      if (gld${EMULATION_NAME}_search_needed (lib_path, &n,
						      force))
		break;
	    }
	  lib_path = (char *) getenv ("LD_LIBRARY_PATH");
	  if (gld${EMULATION_NAME}_search_needed (lib_path, &n, force))
	    break;
EOF
fi
if [ "x${USE_LIBPATH}" = xyes ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
	  found = 0;
	  rp = bfd_elf_get_runpath_list (output_bfd, &link_info);
	  for (; !found && rp != NULL; rp = rp->next)
	    {
	      char *tmpname = gld${EMULATION_NAME}_add_sysroot (rp->name);
	      found = (rp->by == l->by
		       && gld${EMULATION_NAME}_search_needed (tmpname,
							      &n,
							      force));
	      free (tmpname);
	    }
	  if (found)
	    break;

EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
	  len = strlen (l->name);
	  for (search = search_head; search != NULL; search = search->next)
	    {
	      char *filename;

	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, "%s/%s", search->name, l->name);
	      nn.name = filename;
	      if (gld${EMULATION_NAME}_try_needed (&nn, force))
		break;
	      free (filename);
	    }
	  if (search != NULL)
	    break;
EOF
if [ "x${USE_LIBPATH}" = xyes ] ; then
  case ${target} in
    *-*-linux-gnu*)
      cat >>e${EMULATION_NAME}.c <<EOF
	  if (gld${EMULATION_NAME}_check_ld_so_conf (l->name, force))
	    break;
EOF
    # Linux
    ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
	}

      if (force < 2)
	continue;

      einfo ("%P: warning: %s, needed by %B, not found (try using -rpath or -rpath-link)\n",
	     l->name, l->by);
    }
}

EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF

/* Look through an expression for an assignment statement.  */

static void
gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
{
  struct bfd_link_hash_entry *h;

  switch (exp->type.node_class)
    {
    case etree_provide:
      h = bfd_link_hash_lookup (link_info.hash, exp->assign.dst,
				FALSE, FALSE, FALSE);
      if (h == NULL)
	break;

      /* We call record_link_assignment even if the symbol is defined.
	 This is because if it is defined by a dynamic object, we
	 actually want to use the value defined by the linker script,
	 not the value from the dynamic object (because we are setting
	 symbols like etext).  If the symbol is defined by a regular
	 object, then, as it happens, calling record_link_assignment
	 will do no harm.  */

      /* Fall through.  */
    case etree_assign:
      if (strcmp (exp->assign.dst, ".") != 0)
	{
	  if (! (bfd_elf_record_link_assignment
		 (output_bfd, &link_info, exp->assign.dst,
		  exp->type.node_class == etree_provide ? TRUE : FALSE)))
	    einfo ("%P%F: failed to record assignment to %s: %E\n",
		   exp->assign.dst);
	}
      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
      break;

    case etree_binary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);
      break;

    case etree_trinary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);
      break;

    case etree_unary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);
      break;

    default:
      break;
    }
}


/* This is called by the before_allocation routine via
   lang_for_each_statement.  It locates any assignment statements, and
   tells the ELF backend about them, in case they are assignments to
   symbols which are referred to by dynamic objects.  */

static void
gld${EMULATION_NAME}_find_statement_assignment (lang_statement_union_type *s)
{
  if (s->header.type == lang_assignment_statement_enum)
    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);
}

EOF

if test x"$LDEMUL_BEFORE_ALLOCATION" != xgld"$EMULATION_NAME"_before_allocation; then
  if test x"${ELF_INTERPRETER_NAME+set}" = xset; then
    ELF_INTERPRETER_SET_DEFAULT="
  if (sinterp != NULL)
    {
      sinterp->contents = ${ELF_INTERPRETER_NAME};
      sinterp->size = strlen (sinterp->contents) + 1;
    }

"
  else
    ELF_INTERPRETER_SET_DEFAULT=
  fi
cat >>e${EMULATION_NAME}.c <<EOF

/* This is called after the sections have been attached to output
   sections, but before any sizes or addresses have been set.  */

static void
gld${EMULATION_NAME}_before_allocation (void)
{
  const char *rpath;
  asection *sinterp;

  if (link_info.hash->type == bfd_link_elf_hash_table)
    _bfd_elf_tls_setup (output_bfd, &link_info);

  /* If we are going to make any variable assignments, we need to let
     the ELF backend know about them in case the variables are
     referred to by dynamic objects.  */
  lang_for_each_statement (gld${EMULATION_NAME}_find_statement_assignment);

  /* Let the ELF backend work out the sizes of any sections required
     by dynamic linking.  */
  rpath = command_line.rpath;
  if (rpath == NULL)
    rpath = (const char *) getenv ("LD_RUN_PATH");
  if (! (bfd_elf_size_dynamic_sections
	 (output_bfd, command_line.soname, rpath,
	  command_line.filter_shlib,
	  (const char * const *) command_line.auxiliary_filters,
	  &link_info, &sinterp, lang_elf_version_info)))
    einfo ("%P%F: failed to set dynamic section sizes: %E\n");
${ELF_INTERPRETER_SET_DEFAULT}
  /* Let the user override the dynamic linker we are using.  */
  if (command_line.interpreter != NULL
      && sinterp != NULL)
    {
      sinterp->contents = (bfd_byte *) command_line.interpreter;
      sinterp->size = strlen (command_line.interpreter) + 1;
    }

  /* Look for any sections named .gnu.warning.  As a GNU extensions,
     we treat such sections as containing warning messages.  We print
     out the warning message, and then zero out the section size so
     that it does not get copied into the output file.  */

  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	asection *s;
	bfd_size_type sz;
	bfd_size_type prefix_len;
	char *msg;
	bfd_boolean ret;
	const char * gnu_warning_prefix = _("warning: ");

	if (is->just_syms_flag)
	  continue;

	s = bfd_get_section_by_name (is->the_bfd, ".gnu.warning");
	if (s == NULL)
	  continue;

	sz = s->size;
	prefix_len = strlen (gnu_warning_prefix);
	msg = xmalloc ((size_t) (prefix_len + sz + 1));
	strcpy (msg, gnu_warning_prefix);
	if (! bfd_get_section_contents (is->the_bfd, s,	msg + prefix_len,
					(file_ptr) 0, sz))
	  einfo ("%F%B: Can't read contents of section .gnu.warning: %E\n",
		 is->the_bfd);
	msg[prefix_len + sz] = '\0';
	ret = link_info.callbacks->warning (&link_info, msg,
					    (const char *) NULL,
					    is->the_bfd, (asection *) NULL,
					    (bfd_vma) 0);
	ASSERT (ret);
	free (msg);

	/* Clobber the section size, so that we don't waste copying the
	   warning into the output file.  */
	s->size = 0;
      }
  }
}

EOF
fi

if test x"$LDEMUL_OPEN_DYNAMIC_ARCHIVE" != xgld"$EMULATION_NAME"_open_dynamic_archive; then
cat >>e${EMULATION_NAME}.c <<EOF

/* Try to open a dynamic archive.  This is where we know that ELF
   dynamic libraries have an extension of .so (or .sl on oddball systems
   like hpux).  */

/* ARGSUSED */
static bfd_boolean
gld${EMULATION_NAME}_open_dynamic_archive
  (const char *arch __attribute__ ((__unused__)),
   search_dirs_type *search, lang_input_statement_type *entry)
{
  const char *filename;
  char *string;

  if (! entry->is_archive)
    return FALSE;

  filename = entry->filename;
EOF
case ${target} in
  *-*-openbsd* | *-*-mirbsd*)
    cat >>e${EMULATION_NAME}.c <<EOF
  string = gld${EMULATION_NAME}_search_dir_mm(search->name, filename, -1, -1);
  if (string == NULL)
    return FALSE;
EOF
   ;;
  *)
    cat >>e${EMULATION_NAME}.c <<EOF
  /* This allocates a few bytes too many when EXTRA_SHLIB_EXTENSION
     is defined, but it does not seem worth the headache to optimize
     away those two bytes of space.  */
  string = (char *) xmalloc (strlen (search->name)
			     + strlen (filename)
			     + strlen (arch)
#ifdef EXTRA_SHLIB_EXTENSION
			     + strlen (EXTRA_SHLIB_EXTENSION)
#endif
			     + sizeof "/lib.so");

  sprintf (string, "%s/lib%s%s.so", search->name, filename, arch);

EOF
    ;;
esac
cat >>e${EMULATION_NAME}.c <<EOF
#ifdef EXTRA_SHLIB_EXTENSION
  /* Try the .so extension first.  If that fails build a new filename
     using EXTRA_SHLIB_EXTENSION.  */
  if (! ldfile_try_open_bfd (string, entry))
    sprintf (string, "%s/lib%s%s%s", search->name,
	     filename, arch, EXTRA_SHLIB_EXTENSION);
#endif

  if (! ldfile_try_open_bfd (string, entry))
    {
      free (string);
      return FALSE;
    }

  entry->filename = string;

  /* We have found a dynamic object to include in the link.  The ELF
     backend linker will create a DT_NEEDED entry in the .dynamic
     section naming this file.  If this file includes a DT_SONAME
     entry, it will be used.  Otherwise, the ELF linker will just use
     the name of the file.  For an archive found by searching, like
     this one, the DT_NEEDED entry should consist of just the name of
     the file, without the path information used to find it.  Note
     that we only need to do this if we have a dynamic object; an
     archive will never be referenced by a DT_NEEDED entry.

     FIXME: This approach--using bfd_elf_set_dt_needed_name--is not
     very pretty.  I haven't been able to think of anything that is
     pretty, though.  */
  if (bfd_check_format (entry->the_bfd, bfd_object)
      && (entry->the_bfd->flags & DYNAMIC) != 0)
    {
      ASSERT (entry->is_archive && entry->search_dirs_flag);

      /* Rather than duplicating the logic above.  Just use the
	 filename we recorded earlier.  */

      filename = lbasename (entry->filename);
      bfd_elf_set_dt_needed_name (entry->the_bfd, filename);
    }

  return TRUE;
}

EOF
fi

if test x"$LDEMUL_PLACE_ORPHAN" != xgld"$EMULATION_NAME"_place_orphan; then
cat >>e${EMULATION_NAME}.c <<EOF

/* A variant of lang_output_section_find used by place_orphan.  */

static lang_output_section_statement_type *
output_rel_find (asection *sec, int isdyn)
{
  lang_output_section_statement_type *lookup;
  lang_output_section_statement_type *last = NULL;
  lang_output_section_statement_type *last_alloc = NULL;
  lang_output_section_statement_type *last_rel = NULL;
  lang_output_section_statement_type *last_rel_alloc = NULL;
  int rela = sec->name[4] == 'a';

  for (lookup = &lang_output_section_statement.head->output_section_statement;
       lookup != NULL;
       lookup = lookup->next)
    {
      if (lookup->constraint != -1
	  && strncmp (".rel", lookup->name, 4) == 0)
	{
	  int lookrela = lookup->name[4] == 'a';

	  /* .rel.dyn must come before all other reloc sections, to suit
	     GNU ld.so.  */
	  if (isdyn)
	    break;

	  /* Don't place after .rel.plt as doing so results in wrong
	     dynamic tags.  */
	  if (strcmp (".plt", lookup->name + 4 + lookrela) == 0)
	    break;

	  if (rela == lookrela || last_rel == NULL)
	    last_rel = lookup;
	  if ((rela == lookrela || last_rel_alloc == NULL)
	      && lookup->bfd_section != NULL
	      && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	    last_rel_alloc = lookup;
	}

      last = lookup;
      if (lookup->bfd_section != NULL
	  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	last_alloc = lookup;
    }

  if (last_rel_alloc)
    return last_rel_alloc;

  if (last_rel)
    return last_rel;

  if (last_alloc)
    return last_alloc;

  return last;
}

/* Place an orphan section.  We use this to put random SHF_ALLOC
   sections in the right segment.  */

static bfd_boolean
gld${EMULATION_NAME}_place_orphan (lang_input_statement_type *file, asection *s)
{
  static struct orphan_save hold[] =
    {
      { ".text",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE,
	0, 0, 0, 0 },
      { ".rodata",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
	0, 0, 0, 0 },
      { ".data",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA,
	0, 0, 0, 0 },
      { ".bss",
	SEC_ALLOC,
	0, 0, 0, 0 },
      { 0,
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
	0, 0, 0, 0 },
      { ".interp",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
	0, 0, 0, 0 },
      { ".sdata",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_SMALL_DATA,
	0, 0, 0, 0 }
    };
  enum orphan_save_index
    {
      orphan_text = 0,
      orphan_rodata,
      orphan_data,
      orphan_bss,
      orphan_rel,
      orphan_interp,
      orphan_sdata
    };
  static int orphan_init_done = 0;
  struct orphan_save *place;
  const char *secname;
  lang_output_section_statement_type *after;
  lang_output_section_statement_type *os;
  int isdyn = 0;

  secname = bfd_get_section_name (s->owner, s);

  if (! link_info.relocatable
      && link_info.combreloc
      && (s->flags & SEC_ALLOC)
      && strncmp (secname, ".rel", 4) == 0)
    {
      if (secname[4] == 'a')
	secname = ".rela.dyn";
      else
	secname = ".rel.dyn";
      isdyn = 1;
    }

  if (isdyn || (!config.unique_orphan_sections && !unique_section_p (s)))
    {
      /* Look through the script to see where to place this section.  */
      os = lang_output_section_find (secname);

      if (os != NULL
	  && (os->bfd_section == NULL
	      || os->bfd_section->flags == 0
	      || ((s->flags ^ os->bfd_section->flags)
		  & (SEC_LOAD | SEC_ALLOC)) == 0))
	{
	  /* We already have an output section statement with this
	     name, and its bfd section, if any, has compatible flags.
	     If the section already exists but does not have any flags
	     set, then it has been created by the linker, probably as a
	     result of a --section-start command line switch.  */
	  lang_add_section (&os->children, s, os, file);
	  return TRUE;
	}
    }

  if (!orphan_init_done)
    {
      struct orphan_save *ho;
      for (ho = hold; ho < hold + sizeof (hold) / sizeof (hold[0]); ++ho)
	if (ho->name != NULL)
	  {
	    ho->os = lang_output_section_find (ho->name);
	    if (ho->os != NULL && ho->os->flags == 0)
	      ho->os->flags = ho->flags;
	  }
      orphan_init_done = 1;
    }

  /* If this is a final link, then always put .gnu.warning.SYMBOL
     sections into the .text section to get them out of the way.  */
  if (link_info.executable
      && ! link_info.relocatable
      && strncmp (secname, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0
      && hold[orphan_text].os != NULL)
    {
      lang_add_section (&hold[orphan_text].os->children, s,
			hold[orphan_text].os, file);
      return TRUE;
    }

  /* Decide which segment the section should go in based on the
     section name and section flags.  We put loadable .note sections
     right after the .interp section, so that the PT_NOTE segment is
     stored right after the program headers where the OS can read it
     in the first page.  */

  place = NULL;
  if ((s->flags & SEC_ALLOC) == 0)
    ;
  else if ((s->flags & SEC_LOAD) != 0
	   && strncmp (secname, ".note", 5) == 0)
    place = &hold[orphan_interp];
  else if ((s->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
    place = &hold[orphan_bss];
  else if ((s->flags & SEC_SMALL_DATA) != 0)
    place = &hold[orphan_sdata];
  else if ((s->flags & SEC_READONLY) == 0)
    place = &hold[orphan_data];
  else if (strncmp (secname, ".rel", 4) == 0
	   && (s->flags & SEC_LOAD) != 0)
    place = &hold[orphan_rel];
  else if ((s->flags & SEC_CODE) == 0)
    place = &hold[orphan_rodata];
  else
    place = &hold[orphan_text];

  after = NULL;
  if (place != NULL)
    {
      if (place->os == NULL)
	{
	  if (place->name != NULL)
	    place->os = lang_output_section_find (place->name);
	  else
	    place->os = output_rel_find (s, isdyn);
	}
      after = place->os;
      if (after == NULL)
	after = lang_output_section_find_by_flags (s, &place->os);
      if (after == NULL)
	/* *ABS* is always the first output section statement.  */
	after = &lang_output_section_statement.head->output_section_statement;
    }

  /* Choose a unique name for the section.  This will be needed if the
     same section name appears in the input file with different
     loadable or allocatable characteristics.  */
  if (bfd_get_section_by_name (output_bfd, secname) != NULL)
    {
      static int count = 1;
      secname = bfd_get_unique_section_name (output_bfd, secname, &count);
      if (secname == NULL)
	einfo ("%F%P: place_orphan failed: %E\n");
    }

  lang_insert_orphan (file, s, secname, after, place, NULL, NULL);

  return TRUE;
}
EOF
fi

if test x"$LDEMUL_FINISH" != xgld"$EMULATION_NAME"_finish; then
cat >>e${EMULATION_NAME}.c <<EOF

static void
gld${EMULATION_NAME}_finish (void)
{
  if (bfd_elf_discard_info (output_bfd, &link_info))
    {
      lang_reset_memory_regions ();

      /* Resize the sections.  */
      lang_size_sections (stat_ptr->head, abs_output_section,
			  &stat_ptr->head, 0, (bfd_vma) 0, NULL, TRUE);

      /* Redo special stuff.  */
      ldemul_after_allocation ();

      /* Do the assignments again.  */
      lang_do_assignments (stat_ptr->head, abs_output_section,
			   (fill_type *) 0, (bfd_vma) 0);
    }
}
EOF
fi

if test x"$LDEMUL_GET_SCRIPT" != xgld"$EMULATION_NAME"_get_script; then
cat >>e${EMULATION_NAME}.c <<EOF

static char *
gld${EMULATION_NAME}_get_script (int *isfile)
EOF

if test -n "$COMPILE_IN"
then
# Scripts compiled in.

# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 0;

  if (link_info.relocatable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu			>> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr			>> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn			>> e${EMULATION_NAME}.c
if cmp -s ldscripts/${EMULATION_NAME}.x ldscripts/${EMULATION_NAME}.xn; then : ; else
echo '  ; else if (!config.magic_demand_paged) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn			>> e${EMULATION_NAME}.c
fi
if test -n "$GENERATE_PIE_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.pie && link_info.combreloc' >> e${EMULATION_NAME}.c
echo '             && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xdw			>> e${EMULATION_NAME}.c
echo '  ; else if (link_info.pie && link_info.combreloc) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xdc			>> e${EMULATION_NAME}.c
fi
echo '  ; else if (link_info.pie) return'		>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xd			>> e${EMULATION_NAME}.c
fi
if test -n "$GENERATE_SHLIB_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.shared && link_info.combreloc' >> e${EMULATION_NAME}.c
echo '             && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xsw			>> e${EMULATION_NAME}.c
echo '  ; else if (link_info.shared && link_info.combreloc) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xsc			>> e${EMULATION_NAME}.c
fi
echo '  ; else if (link_info.shared) return'		>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xs			>> e${EMULATION_NAME}.c
fi
if test -n "$GENERATE_Z_SCRIPT" ; then
echo '  ; else if (config.data_bss_contig == TRUE) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xz                 >> e${EMULATION_NAME}.c
fi
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.combreloc && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xw			>> e${EMULATION_NAME}.c
echo '  ; else if (link_info.combreloc) return'		>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xc			>> e${EMULATION_NAME}.c
fi
echo '  ; else return'					>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x			>> e${EMULATION_NAME}.c
echo '; }'						>> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 1;

  if (link_info.relocatable && config.build_constructors)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocatable)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
EOF
if cmp -s ldscripts/${EMULATION_NAME}.x ldscripts/${EMULATION_NAME}.xn; then :
else
cat >>e${EMULATION_NAME}.c <<EOF
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
EOF
fi
if test -n "$GENERATE_PIE_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.pie && link_info.combreloc
	   && link_info.relro && (link_info.flags & DT_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xdw";
  else if (link_info.pie && link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xdc";
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.pie)
    return "ldscripts/${EMULATION_NAME}.xd";
EOF
fi
if test -n "$GENERATE_SHLIB_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.shared && link_info.combreloc
	   && link_info.relro && (link_info.flags & DT_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xsw";
  else if (link_info.shared && link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xsc";
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.shared)
    return "ldscripts/${EMULATION_NAME}.xs";
EOF
fi
if test -n "$GENERATE_Z_SCRIPT" ; then
cat >>e${EMULATION_NAME}.c <<EOF
  else if (config.data_bss_contig == TRUE)
    return "ldscripts/${EMULATION_NAME}.xz";
EOF
fi
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.combreloc && link_info.relro
	   && (link_info.flags & DT_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xw";
  else if (link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xc";
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
  else
    return "ldscripts/${EMULATION_NAME}.x";
}

EOF
fi
fi

if test -n "$PARSE_AND_LIST_ARGS_CASES" -o x"$GENERATE_SHLIB_SCRIPT" = xyes; then

if test -n "$PARSE_AND_LIST_PROLOGUE" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_PROLOGUE
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF

#define OPTION_DISABLE_NEW_DTAGS	(400)
#define OPTION_ENABLE_NEW_DTAGS		(OPTION_DISABLE_NEW_DTAGS + 1)
#define OPTION_GROUP			(OPTION_ENABLE_NEW_DTAGS + 1)
#define OPTION_EH_FRAME_HDR		(OPTION_GROUP + 1)
#define OPTION_EXCLUDE_LIBS		(OPTION_EH_FRAME_HDR + 1)
  
static void
gld${EMULATION_NAME}_add_options
  (int ns, char **shortopts, int nl, struct option **longopts,
   int nrl ATTRIBUTE_UNUSED, struct option **really_longopts ATTRIBUTE_UNUSED)
{
  static const char xtra_short[] = "${PARSE_AND_LIST_SHORTOPTS}z:";
  static const struct option xtra_long[] = {
EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
cat >>e${EMULATION_NAME}.c <<EOF
    {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
    {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
    {"eh-frame-hdr", no_argument, NULL, OPTION_EH_FRAME_HDR},
    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
    {"Bgroup", no_argument, NULL, OPTION_GROUP},
EOF
fi

if test -n "$PARSE_AND_LIST_LONGOPTS" ; then
cat >>e${EMULATION_NAME}.c <<EOF
    $PARSE_AND_LIST_LONGOPTS
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF
    {NULL, no_argument, NULL, 0}
  };

  *shortopts = (char *) xrealloc (*shortopts, ns + sizeof (xtra_short));
  memcpy (*shortopts + ns, &xtra_short, sizeof (xtra_short));
  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

static bfd_boolean
gld${EMULATION_NAME}_handle_option (int optc)
{
  switch (optc)
    {
    default:
      return FALSE;

EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
cat >>e${EMULATION_NAME}.c <<EOF
    case OPTION_DISABLE_NEW_DTAGS:
      link_info.new_dtags = FALSE;
      break;

    case OPTION_ENABLE_NEW_DTAGS:
      link_info.new_dtags = TRUE;
      break;

    case OPTION_EH_FRAME_HDR:
      link_info.eh_frame_hdr = TRUE;
      break;

    case OPTION_GROUP:
      link_info.flags_1 |= (bfd_vma) DF_1_GROUP;
      /* Groups must be self-contained.  */
      link_info.unresolved_syms_in_objects = RM_GENERATE_ERROR;
      link_info.unresolved_syms_in_shared_libs = RM_GENERATE_ERROR;
      break;

    case OPTION_EXCLUDE_LIBS:
      add_excluded_libs (optarg);
      break;

    case 'z':
      if (strcmp (optarg, "initfirst") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INITFIRST;
      else if (strcmp (optarg, "interpose") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INTERPOSE;
      else if (strcmp (optarg, "loadfltr") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_LOADFLTR;
      else if (strcmp (optarg, "nodefaultlib") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODEFLIB;
      else if (strcmp (optarg, "nodelete") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODELETE;
      else if (strcmp (optarg, "nodlopen") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NOOPEN;
      else if (strcmp (optarg, "nodump") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODUMP;
      else if (strcmp (optarg, "now") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_BIND_NOW;
	  link_info.flags_1 |= (bfd_vma) DF_1_NOW;
	}
      else if (strcmp (optarg, "origin") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_ORIGIN;
	  link_info.flags_1 |= (bfd_vma) DF_1_ORIGIN;
	}
      else if (strcmp (optarg, "defs") == 0)
	link_info.unresolved_syms_in_objects = RM_GENERATE_ERROR;
      else if (strcmp (optarg, "muldefs") == 0)
	link_info.allow_multiple_definition = TRUE;
      else if (strcmp (optarg, "combreloc") == 0)
	link_info.combreloc = TRUE;
      else if (strcmp (optarg, "nocombreloc") == 0)
	link_info.combreloc = FALSE;
      else if (strcmp (optarg, "nocopyreloc") == 0)
	link_info.nocopyreloc = TRUE;
      else if (strcmp (optarg, "execstack") == 0)
	{
	  link_info.execstack = TRUE;
	  link_info.noexecstack = FALSE;
	}
      else if (strcmp (optarg, "noexecstack") == 0)
	{
	  link_info.noexecstack = TRUE;
	  link_info.execstack = FALSE;
	}
      else if (strcmp (optarg, "relro") == 0)
	link_info.relro = TRUE;
      else if (strcmp (optarg, "norelro") == 0)
	link_info.relro = FALSE;
      /* What about the other Solaris -z options? FIXME.  */
      break;
EOF
fi

if test -n "$PARSE_AND_LIST_ARGS_CASES" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_ARGS_CASES
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF
    }

  return TRUE;
}

EOF

if test x"$LDEMUL_LIST_OPTIONS" != xgld"$EMULATION_NAME"_list_options; then
cat >>e${EMULATION_NAME}.c <<EOF

static void
gld${EMULATION_NAME}_list_options (FILE * file)
{
EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
cat >>e${EMULATION_NAME}.c <<EOF
  fprintf (file, _("  -Bgroup\t\tSelects group name lookup rules for DSO\n"));
  fprintf (file, _("  --disable-new-dtags\tDisable new dynamic tags\n"));
  fprintf (file, _("  --enable-new-dtags\tEnable new dynamic tags\n"));
  fprintf (file, _("  --eh-frame-hdr\tCreate .eh_frame_hdr section\n"));
  fprintf (file, _("  -z combreloc\t\tMerge dynamic relocs into one section and sort\n"));
  fprintf (file, _("  -z defs\t\tReport unresolved symbols in object files.\n"));
  fprintf (file, _("  -z execstack\t\tMark executable as requiring executable stack\n"));
  fprintf (file, _("  -z initfirst\t\tMark DSO to be initialized first at runtime\n"));
  fprintf (file, _("  -z interpose\t\tMark object to interpose all DSOs but executable\n"));
  fprintf (file, _("  -z loadfltr\t\tMark object requiring immediate process\n"));
  fprintf (file, _("  -z muldefs\t\tAllow multiple definitions\n"));
  fprintf (file, _("  -z nocombreloc\tDon't merge dynamic relocs into one section\n"));
  fprintf (file, _("  -z nocopyreloc\tDon't create copy relocs\n"));
  fprintf (file, _("  -z nodefaultlib\tMark object not to use default search paths\n"));
  fprintf (file, _("  -z nodelete\t\tMark DSO non-deletable at runtime\n"));
  fprintf (file, _("  -z nodlopen\t\tMark DSO not available to dlopen\n"));
  fprintf (file, _("  -z nodump\t\tMark DSO not available to dldump\n"));
  fprintf (file, _("  -z noexecstack\tMark executable as not requiring executable stack\n"));
  fprintf (file, _("  -z norelro\t\tDon't create RELRO program header\n"));
  fprintf (file, _("  -z now\t\tMark object non-lazy runtime binding\n"));
  fprintf (file, _("  -z origin\t\tMark object requiring immediate \$ORIGIN processing\n\t\t\t  at runtime\n"));
  fprintf (file, _("  -z relro\t\tCreate RELRO program header\n"));
  fprintf (file, _("  -z KEYWORD\t\tIgnored for Solaris compatibility\n"));
EOF
fi

if test -n "$PARSE_AND_LIST_OPTIONS" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_OPTIONS
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF
}
EOF

if test -n "$PARSE_AND_LIST_EPILOGUE" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_EPILOGUE
EOF
fi
fi
else
cat >>e${EMULATION_NAME}.c <<EOF
#define gld${EMULATION_NAME}_add_options NULL
#define gld${EMULATION_NAME}_handle_option NULL
EOF
if test x"$LDEMUL_LIST_OPTIONS" != xgld"$EMULATION_NAME"_list_options; then
cat >>e${EMULATION_NAME}.c <<EOF
#define gld${EMULATION_NAME}_list_options NULL
EOF
fi
fi

cat >>e${EMULATION_NAME}.c <<EOF

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
  ${LDEMUL_BEFORE_PARSE-gld${EMULATION_NAME}_before_parse},
  ${LDEMUL_SYSLIB-syslib_default},
  ${LDEMUL_HLL-hll_default},
  ${LDEMUL_AFTER_PARSE-after_parse_default},
  ${LDEMUL_AFTER_OPEN-gld${EMULATION_NAME}_after_open},
  ${LDEMUL_AFTER_ALLOCATION-after_allocation_default},
  ${LDEMUL_SET_OUTPUT_ARCH-set_output_arch_default},
  ${LDEMUL_CHOOSE_TARGET-ldemul_default_target},
  ${LDEMUL_BEFORE_ALLOCATION-gld${EMULATION_NAME}_before_allocation},
  ${LDEMUL_GET_SCRIPT-gld${EMULATION_NAME}_get_script},
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  ${LDEMUL_FINISH-gld${EMULATION_NAME}_finish},
  ${LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS-NULL},
  ${LDEMUL_OPEN_DYNAMIC_ARCHIVE-gld${EMULATION_NAME}_open_dynamic_archive},
  ${LDEMUL_PLACE_ORPHAN-gld${EMULATION_NAME}_place_orphan},
  ${LDEMUL_SET_SYMBOLS-NULL},
  ${LDEMUL_PARSE_ARGS-NULL},
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
  ${LDEMUL_UNRECOGNIZED_FILE-NULL},
  ${LDEMUL_LIST_OPTIONS-gld${EMULATION_NAME}_list_options},
  ${LDEMUL_RECOGNIZED_FILE-gld${EMULATION_NAME}_load_symbols},
  ${LDEMUL_FIND_POTENTIAL_LIBRARIES-NULL},
  ${LDEMUL_NEW_VERS_PATTERN-NULL}
};
EOF
@


1.8
log
@fix build
@
text
@d1 1
a1 1
# $MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.7 2004/10/14 17:31:45 tg Exp $
d58 1
a58 1
__RCSID("$MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.7 2004/10/14 17:31:45 tg Exp $");
d301 10
d774 14
a787 2
static bfd_boolean
gld${EMULATION_NAME}_check_ld_so_conf (const char *name, int force)
d789 13
a801 3
  static bfd_boolean initialized;
  static char *ld_so_conf;
  struct dt_needed needed;
d803 1
a803 1
  if (! initialized)
d805 21
a825 2
      FILE *f;
      char *tmppath;
d827 10
a836 4
      tmppath = concat (ld_sysroot, "/etc/ld.so.conf", NULL);
      f = fopen (tmppath, FOPEN_RT);
      free (tmppath);
      if (f != NULL)
d838 23
a860 7
	  char *b;
	  size_t len, alloc;
	  int c;

	  len = 0;
	  alloc = 100;
	  b = (char *) xmalloc (alloc);
d862 9
a870 1
	  while ((c = getc (f)) != EOF)
d872 7
a878 23
	      if (len + 1 >= alloc)
		{
		  alloc *= 2;
		  b = (char *) xrealloc (b, alloc);
		}
	      if (c != ':'
		  && c != ' '
		  && c != '\t'
		  && c != '\n'
		  && c != ',')
		{
		  b[len] = c;
		  ++len;
		}
	      else
		{
		  if (len > 0 && b[len - 1] != ':')
		    {
		      b[len] = ':';
		      ++len;
		    }
		}
	    }
d880 2
a881 2
	  if (len > 0 && b[len - 1] == ':')
	    --len;
d883 23
a905 2
	  if (len > 0)
	    b[len] = '\0';
d908 6
a913 2
	      free (b);
	      b = NULL;
d915 9
d925 6
a930 1
	  fclose (f);
d932 4
a935 6
	  if (b)
	    {
	      char *d = gld${EMULATION_NAME}_add_sysroot (b);
	      free (b);
	      b = d;
	    }
d937 10
a946 1
	  ld_so_conf = b;
a947 1

d1447 1
a1447 1
/* A variant of lang_output_section_find.  Used by place_orphan.  */
a1451 1
  lang_statement_union_type *u;
d1459 3
a1461 1
  for (u = lang_output_section_statement.head; u; u = lookup->next)
a1462 1
      lookup = &u->output_section_statement;
a1503 25
/* Find the last output section before given output statement.
   Used by place_orphan.  */

static asection *
output_prev_sec_find (lang_output_section_statement_type *os)
{
  asection *s = (asection *) NULL;
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (lookup == os)
	return s;

      if (lookup->bfd_section != NULL && lookup->bfd_section->owner != NULL)
	s = lookup->bfd_section;
    }

  return NULL;
}

a1506 7
struct orphan_save {
  lang_output_section_statement_type *os;
  asection **section;
  lang_statement_union_type **stmt;
  lang_statement_union_type **os_tail;
};

d1510 35
a1544 8
  static struct orphan_save hold_text;
  static struct orphan_save hold_rodata;
  static struct orphan_save hold_data;
  static struct orphan_save hold_bss;
  static struct orphan_save hold_rel;
  static struct orphan_save hold_interp;
  static struct orphan_save hold_sdata;
  static int count = 1;
a1545 3
  lang_statement_list_type *old;
  lang_statement_list_type add;
  etree_type *address;
d1547 1
a1547 1
  const char *ps = NULL;
a1548 2
  lang_statement_union_type **os_tail;
  etree_type *load_base;
a1549 1
  asection *sec;
d1572 1
d1577 4
a1580 1
	     name, and its bfd section, if any, has compatible flags.  */
d1586 12
a1597 2
  if (hold_text.os == NULL)
    hold_text.os = lang_output_section_find (".text");
d1604 1
a1604 1
      && hold_text.os != NULL)
d1606 2
a1607 1
      lang_add_section (&hold_text.os->children, s, hold_text.os, file);
a1615 2
#define HAVE_SECTION(hold, name) \
(hold.os != NULL || (hold.os = lang_output_section_find (name)) != NULL)
d1621 8
a1628 12
	   && strncmp (secname, ".note", 5) == 0
	   && HAVE_SECTION (hold_interp, ".interp"))
    place = &hold_interp;
  else if ((s->flags & SEC_HAS_CONTENTS) == 0
	   && HAVE_SECTION (hold_bss, ".bss"))
    place = &hold_bss;
  else if ((s->flags & SEC_SMALL_DATA) != 0
	   && HAVE_SECTION (hold_sdata, ".sdata"))
    place = &hold_sdata;
  else if ((s->flags & SEC_READONLY) == 0
	   && HAVE_SECTION (hold_data, ".data"))
    place = &hold_data;
d1630 6
a1635 10
	   && (s->flags & SEC_LOAD) != 0
	   && (hold_rel.os != NULL
	       || (hold_rel.os = output_rel_find (s, isdyn)) != NULL))
    place = &hold_rel;
  else if ((s->flags & (SEC_CODE | SEC_READONLY)) == SEC_READONLY
	   && HAVE_SECTION (hold_rodata, ".rodata"))
    place = &hold_rodata;
  else if ((s->flags & (SEC_CODE | SEC_READONLY)) == (SEC_CODE | SEC_READONLY)
	   && hold_text.os != NULL)
    place = &hold_text;
d1637 17
a1653 1
#undef HAVE_SECTION
d1657 2
a1658 6
     loadable or allocatable characteristics.  But if the section
     already exists but does not have any flags set, then it has been
     created by the linker, probably as a result of a --section-start
     command line switch.  */
  if ((sec = bfd_get_section_by_name (output_bfd, secname)) != NULL
      && bfd_get_section_flags (output_bfd, sec) != 0)
d1660 1
d1666 1
a1666 167
  /* Start building a list of statements for this section.
     First save the current statement pointer.  */
  old = stat_ptr;

  /* If we have found an appropriate place for the output section
     statements for this orphan, add them to our own private list,
     inserting them later into the global statement list.  */
  if (place != NULL)
    {
      stat_ptr = &add;
      lang_list_init (stat_ptr);
    }

  if (config.build_constructors)
    {
      /* If the name of the section is representable in C, then create
	 symbols to mark the start and the end of the section.  */
      for (ps = secname; *ps != '\0'; ps++)
	if (! ISALNUM (*ps) && *ps != '_')
	  break;
      if (*ps == '\0')
	{
	  char *symname;
	  etree_type *e_align;

	  symname = (char *) xmalloc (ps - secname + sizeof "__start_");
	  sprintf (symname, "__start_%s", secname);
	  e_align = exp_unop (ALIGN_K,
			      exp_intop ((bfd_vma) 1 << s->alignment_power));
	  lang_add_assignment (exp_assop ('=', symname, e_align));
	}
    }

  address = NULL;
  if (link_info.relocatable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
    address = exp_intop ((bfd_vma) 0);

  load_base = NULL;
  if (place != NULL && place->os->load_base != NULL)
    {
      etree_type *lma_from_vma;
      lma_from_vma = exp_binop ('-', place->os->load_base,
				exp_nameop (ADDR, place->os->name));
      load_base = exp_binop ('+', lma_from_vma,
			     exp_nameop (ADDR, secname));
    }

  os_tail = lang_output_section_statement.tail;
  os = lang_enter_output_section_statement (secname, address, 0,
					    (etree_type *) NULL,
					    (etree_type *) NULL,
					    load_base, 0);

  lang_add_section (&os->children, s, os, file);

  lang_leave_output_section_statement
    ((bfd_vma) 0, "*default*",
     (struct lang_output_section_phdr_list *) NULL, NULL);

  if (config.build_constructors && *ps == '\0')
    {
      char *symname;

      /* lang_leave_ouput_section_statement resets stat_ptr.  Put
	 stat_ptr back where we want it.  */
      if (place != NULL)
	stat_ptr = &add;

      symname = (char *) xmalloc (ps - secname + sizeof "__stop_");
      sprintf (symname, "__stop_%s", secname);
      lang_add_assignment (exp_assop ('=', symname,
				      exp_nameop (NAME, ".")));
    }

  /* Restore the global list pointer.  */
  stat_ptr = old;

  if (place != NULL && os->bfd_section != NULL)
    {
      asection *snew, **pps;

      snew = os->bfd_section;

      /* Shuffle the bfd section list to make the output file look
	 neater.  This is really only cosmetic.  */
      if (place->section == NULL)
	{
	  asection *bfd_section = place->os->bfd_section;

	  /* If the output statement hasn't been used to place
	     any input sections (and thus doesn't have an output
	     bfd_section), look for the closest prior output statement
	     having an output section.  */
	  if (bfd_section == NULL)
	    bfd_section = output_prev_sec_find (place->os);

	  if (bfd_section != NULL && bfd_section != snew)
	    place->section = &bfd_section->next;
	}

      if (place->section != NULL)
	{
	  /* Unlink the section.  */
	  for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	    ;
	  bfd_section_list_remove (output_bfd, pps);

	  /* Now tack it on to the "place->os" section list.  */
	  bfd_section_list_insert (output_bfd, place->section, snew);
	}

      /* Save the end of this list.  Further ophans of this type will
	 follow the one we've just added.  */
      place->section = &snew->next;

      /* The following is non-cosmetic.  We try to put the output
	 statements in some sort of reasonable order here, because
	 they determine the final load addresses of the orphan
	 sections.  In addition, placing output statements in the
	 wrong order may require extra segments.  For instance,
	 given a typical situation of all read-only sections placed
	 in one segment and following that a segment containing all
	 the read-write sections, we wouldn't want to place an orphan
	 read/write section before or amongst the read-only ones.  */
      if (add.head != NULL)
	{
	  lang_statement_union_type *newly_added_os;

	  if (place->stmt == NULL)
	    {
	      /* Put the new statement list right at the head.  */
	      *add.tail = place->os->header.next;
	      place->os->header.next = add.head;

	      place->os_tail = &place->os->next;
	    }
	  else
	    {
	      /* Put it after the last orphan statement we added.  */
	      *add.tail = *place->stmt;
	      *place->stmt = add.head;
	    }

	  /* Fix the global list pointer if we happened to tack our
	     new list at the tail.  */
	  if (*old->tail == add.head)
	    old->tail = add.tail;

	  /* Save the end of this list.  */
	  place->stmt = add.tail;

	  /* Do the same for the list of output section statements.  */
	  newly_added_os = *os_tail;
	  *os_tail = NULL;
	  newly_added_os->output_section_statement.next = *place->os_tail;
	  *place->os_tail = newly_added_os;
	  place->os_tail = &newly_added_os->output_section_statement.next;

	  /* Fixing the global list pointer here is a little different.
	     We added to the list in lang_enter_output_section_statement,
	     trimmed off the new output_section_statment above when
	     assigning *os_tail = NULL, but possibly added it back in
	     the same place when assigning *place->os_tail.  */
	  if (*os_tail == NULL)
	    lang_output_section_statement.tail = os_tail;
	}
    }
d1719 5
a1723 5
sed $sc ldscripts/${EMULATION_NAME}.xu                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                 >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                >> e${EMULATION_NAME}.c
d1725 2
a1726 2
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                 >> e${EMULATION_NAME}.c
d1733 1
a1733 1
sed $sc ldscripts/${EMULATION_NAME}.xdw                >> e${EMULATION_NAME}.c
d1735 1
a1735 1
sed $sc ldscripts/${EMULATION_NAME}.xdc                >> e${EMULATION_NAME}.c
d1737 2
a1738 2
echo '  ; else if (link_info.pie) return'	       >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xd                 >> e${EMULATION_NAME}.c
d1745 1
a1745 1
sed $sc ldscripts/${EMULATION_NAME}.xsw                >> e${EMULATION_NAME}.c
d1747 1
a1747 1
sed $sc ldscripts/${EMULATION_NAME}.xsc                >> e${EMULATION_NAME}.c
d1749 2
a1750 2
echo '  ; else if (link_info.shared) return'	       >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xs                 >> e${EMULATION_NAME}.c
d1759 7
a1765 7
sed $sc ldscripts/${EMULATION_NAME}.xw                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.combreloc) return'        >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xc                 >> e${EMULATION_NAME}.c
fi
echo '  ; else return'                                 >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
echo '; }'                                             >> e${EMULATION_NAME}.c
d1856 2
a1857 1

d1872 1
d1923 4
@


1.7
log
@linkpath mods by openbsd
@
text
@d1 1
a1 1
# $MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.6 2004/09/29 23:10:28 tg Exp $
d58 1
a58 1
__RCSID("$MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.6 2004/09/29 23:10:28 tg Exp $");
a74 2
static char *gld${EMULATION_NAME}_search_dir (const char *, const char *);

d77 1
a77 1
static char * gld${EMULATION_NAME}_search_dir_needed (const char *dirlist, const char *filename);
d79 1
a79 1
static char * gld${EMULATION_NAME}_search_dir (const char *dirname,
d82 1
a82 1
static char * gld${EMULATION_NAME}_split_lib_name (char *name, int *pmaj,
d157 1
a157 1
gld${EMULATION_NAME}_search_dir_needed (dirlist, filename)
d178 1
a178 1
      found = gld${EMULATION_NAME}_search_dir(dir, lib, maj, min);
d188 1
a188 1
gld${EMULATION_NAME}_search_dir (dirname, filename, req_maj, req_min)
a658 3
  needed.by = n->by;
  needed.name = n->name;

d665 3
a667 2
    if ((found = gld${EMULATION_NAME}_search_dir_needed(path, name)) != NULL) {
      if (gld${EMULATION_NAME}_try_needed (found, force)) {
d678 3
d1263 1
a1263 1
  string = gld${EMULATION_NAME}_search_dir(search->name, filename, -1, -1);
@


1.6
log
@this time I really removed the *.xz ldscripts for non-miros arches.
also, sync the lists, and bump the patchlevel (libcdk, etc.)
@
text
@d1 1
a1 1
# $MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.5 2004/09/26 22:11:32 tg Exp $
d58 1
a58 1
__RCSID("$MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.5 2004/09/26 22:11:32 tg Exp $");
d79 79
d159 32
a190 1
gld${EMULATION_NAME}_search_dir (dirname, filename)
d193 1
d277 5
a281 4
      if (found == NULL
	  || (found_maj > max_maj)
	  || (found_maj == max_maj
	      && (found_min > max_min)))
d664 18
d1264 1
a1264 1
  string = gld${EMULATION_NAME}_search_dir(search->name, filename);
@


1.5
log
@produce *.xz only on open/mir (I hope)
@
text
@d1 1
a1 1
# $MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.4 2004/09/16 22:28:12 tg Exp $
d58 1
a58 1
__RCSID("$MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.4 2004/09/16 22:28:12 tg Exp $");
d1672 1
a1672 2
case ${target} in
  *-*-openbsd* | *-*-mirbsd*)
d1675 1
a1675 2
  ;;
esac
d1738 1
a1738 2
case ${target} in
  *-*-openbsd* | *-*-mirbsd*)
d1743 1
a1743 2
  ;;
esac
@


1.4
log
@update to most recent copy of binutils, based upon the vendor import branch cvs-200409160000 and our binutils port
@
text
@d1 1
a1 1
# $MirBSD: testing/binutils/ld/emultempl/elf32.em,v 1.6 2004/09/16 21:19:33 tg Exp $
d58 1
a58 1
__RCSID("$MirBSD: testing/binutils/ld/emultempl/elf32.em,v 1.6 2004/09/16 21:19:33 tg Exp $");
d1672 2
d1676 2
d1740 2
d1746 2
@


1.3
log
@merge testing/binutils into source, hope it works better
@
text
@d1 1
a1 1
# $MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.1.3.2 2004/08/12 20:09:54 tg Exp $
d58 1
a58 1
__RCSID("$MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.1.3.2 2004/08/12 20:09:54 tg Exp $");
@


1.2
log
@I never thought I had to backport fixes from binutils-current (HEAD),
but my libbfd, inherited from gdb-6.2, is simply too new. d'oh
@
text
@d1 1
a1 1
# $MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.1.3.1 2004/08/11 20:40:43 tg Exp $
d58 1
a58 1
__RCSID("$MirBSD: src/gnu/usr.bin/binutils/src/ld/emultempl/elf32.em,v 1.1.3.1 2004/08/11 20:40:43 tg Exp $");
d224 1
a224 3
  if (!entry->as_needed
      || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)
    return FALSE;
d229 14
a242 1
  bfd_elf_set_dyn_lib_class (entry->the_bfd, DYN_AS_NEEDED);
d381 5
d392 2
a393 1
gld${EMULATION_NAME}_try_needed (const char *name, int force)
d396 3
a398 1
  char *soname;
d502 1
a502 1
      free(soname);
d512 11
a522 1
  bfd_elf_set_dyn_lib_class (abfd, DYN_DT_NEEDED);
d535 2
a536 1
gld${EMULATION_NAME}_search_needed (const char *path, const char *name, int force)
d539 1
d541 1
d544 1
a544 1
    return gld${EMULATION_NAME}_try_needed (name, force);
d548 4
d572 2
a573 1
      if (gld${EMULATION_NAME}_try_needed (filename, force))
d640 1
d715 4
a718 1
  return gld${EMULATION_NAME}_search_needed (ld_so_conf, name, force);
d801 1
d818 3
d850 1
a850 1
						  l->name, force))
d856 1
a856 1
						  l->name, force))
d866 2
a867 2
	      lib_path = getenv ("LD_RUN_PATH");
	      if (gld${EMULATION_NAME}_search_needed (lib_path, l->name,
d871 2
a872 24

	  len = strlen(search_head->name);
	  lib_path = xstrdup(search_head->name);
	  for (search = search_head->next; search != NULL;
	       search = search->next)
	    {
	      size_t nlen;

	      nlen = strlen(search->name);
	      lib_path = xrealloc(lib_path, len + nlen + 2);
	      lib_path[len] = ':';
	      strcpy(lib_path + len + 1, search->name);
	      len += nlen + 1;
	    }

	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
	    {
	      free(lib_path);
	    break;
	    }
	  free(lib_path);

	  lib_path = getenv ("LD_LIBRARY_PATH");
	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
d885 1
a885 1
							      l->name,
d904 2
a905 1
	      if (gld${EMULATION_NAME}_try_needed (filename, force))
d1224 2
a1225 1
      if (strncmp (".rel", lookup->name, 4) == 0)
d1321 1
d1324 1
d1337 1
a1337 1
  if (isdyn || (!config.unique_orphan_sections && !unique_section_p (secname)))
a1375 7
  if ((s->flags & SEC_EXCLUDE) != 0 && !link_info.relocatable)
    {
      if (s->output_section == NULL)
	s->output_section = bfd_abs_section_ptr;
      return TRUE;
    }

d1408 6
a1413 2
     loadable or allocatable characteristics.  */
  if (bfd_get_section_by_name (output_bfd, secname) != NULL)
d1471 1
a1471 1
					    load_base);
d1650 4
d1662 4
d1675 3
d1709 3
d1724 3
d1742 3
d1884 4
d1935 1
d1938 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $MirBSD: testing/binutils/ld/emultempl/elf32.em,v 1.2 2004/08/11 19:58:58 tg Exp $
d58 1
a58 1
__RCSID("$MirBSD: testing/binutils/ld/emultempl/elf32.em,v 1.2 2004/08/11 19:58:58 tg Exp $");
d75 2
d992 1
a992 1
      sinterp->_raw_size = strlen (sinterp->contents) + 1;
d1035 1
a1035 1
      sinterp->_raw_size = strlen (command_line.interpreter) + 1;
d1060 1
a1060 1
	sz = bfd_section_size (is->the_bfd, s);
d1078 1
a1078 1
	s->_raw_size = 0;
d1093 1
d1096 2
a1097 1
  (const char *arch, search_dirs_type *search, lang_input_statement_type *entry)
@


1.1.2.1
log
@binutils-040916.tar.bz2 from sources.deadrat.com for src/ for later use
@
text
@d1 2
d17 1
d27 1
a27 2
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
d58 2
d69 119
d222 3
a224 1
  int class = 0;
d229 1
a229 14
  if (entry->as_needed)
    class = DYN_AS_NEEDED;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for any dynamic library in DT_NEEDED tags from
     this file at all.  */
  if (!entry->add_needed)
    class |= DYN_NO_ADD_NEEDED;

  if (!class
      || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)
    return FALSE;

  bfd_elf_set_dyn_lib_class (entry->the_bfd, class);
a367 5
struct dt_needed
{
  bfd *by;
  const char *name;
};
d374 1
a374 2
gld${EMULATION_NAME}_try_needed (struct dt_needed *needed,
				 int force)
d377 1
a377 3
  const char *name = needed->name;
  const char *soname;
  int class;
d470 1
a470 1
  soname = lbasename (abfd->filename);
d481 1
d491 1
a491 11
  class = DYN_DT_NEEDED;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file at all if the entry is from a file
     with DYN_NO_ADD_NEEDED.  */
  if (needed->by
      && (bfd_elf_get_dyn_lib_class (needed->by)
	  & DYN_NO_ADD_NEEDED) != 0)
    class |= DYN_NO_NEEDED | DYN_NO_ADD_NEEDED;

  bfd_elf_set_dyn_lib_class (abfd, class);
d504 1
a504 2
gld${EMULATION_NAME}_search_needed (const char *path,
				    struct dt_needed *n, int force)
a506 1
  const char *name = n->name;
a507 1
  struct dt_needed needed;
d510 1
a510 1
    return gld${EMULATION_NAME}_try_needed (n, force);
a513 4

  needed.by = n->by;
  needed.name = n->name;

d534 1
a534 2
      needed.name = filename;
      if (gld${EMULATION_NAME}_try_needed (&needed, force))
a600 1
  struct dt_needed needed;
d675 1
a675 4

  needed.by = NULL;
  needed.name = name;
  return gld${EMULATION_NAME}_search_needed (ld_so_conf, &needed, force);
a757 1
      struct dt_needed n, nn;
a773 3
      n.by = l->by;
      n.name = l->name;
      nn.by = l->by;
d783 1
a783 1
	 We do not search using the -L arguments.
d795 1
a795 1
	  const char *lib_path;
d803 1
a803 1
						  &n, force))
d809 1
a809 1
						  &n, force))
d815 2
a816 1
	  if (command_line.rpath_link == NULL
d819 2
a820 2
	      lib_path = (const char *) getenv ("LD_RUN_PATH");
	      if (gld${EMULATION_NAME}_search_needed (lib_path, &n,
d824 24
a847 2
	  lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
	  if (gld${EMULATION_NAME}_search_needed (lib_path, &n, force))
d860 1
a860 1
							      &n,
d879 1
a879 2
	      nn.name = filename;
	      if (gld${EMULATION_NAME}_try_needed (&nn, force))
d990 1
a990 1
      sinterp->size = strlen (sinterp->contents) + 1;
d1033 1
a1033 1
      sinterp->size = strlen (command_line.interpreter) + 1;
d1058 1
a1058 1
	sz = s->size;
d1076 1
a1076 1
	s->size = 0;
d1102 11
a1112 1

d1126 4
d1196 1
a1196 2
      if (lookup->constraint != -1
	  && strncmp (".rel", lookup->name, 4) == 0)
a1291 1
  asection *sec;
a1293 1

d1306 1
a1306 1
  if (isdyn || (!config.unique_orphan_sections && !unique_section_p (s)))
d1345 7
d1384 2
a1385 6
     loadable or allocatable characteristics.  But if the section
     already exists but does not have any flags set, then it has been
     created by the linker, probably as a result of a --section-start
     command line switch.  */
  if ((sec = bfd_get_section_by_name (output_bfd, secname)) != NULL
      && bfd_get_section_flags (output_bfd, sec) != 0)
d1443 1
a1443 1
					    load_base, 0);
a1621 4
echo '  ; else if (link_info.pie && link_info.combreloc' >> e${EMULATION_NAME}.c
echo '             && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xdw                >> e${EMULATION_NAME}.c
a1629 4
echo '  ; else if (link_info.shared && link_info.combreloc' >> e${EMULATION_NAME}.c
echo '             && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xsw                >> e${EMULATION_NAME}.c
d1636 2
a1638 3
echo '  ; else if (link_info.combreloc && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xw                 >> e${EMULATION_NAME}.c
a1669 3
  else if (link_info.pie && link_info.combreloc
	   && link_info.relro && (link_info.flags & DT_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xdw";
a1681 3
  else if (link_info.shared && link_info.combreloc
	   && link_info.relro && (link_info.flags & DT_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xsw";
d1691 4
a1696 3
  else if (link_info.combreloc && link_info.relro
	   && (link_info.flags & DT_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xw";
a1835 4
      else if (strcmp (optarg, "relro") == 0)
	link_info.relro = TRUE;
      else if (strcmp (optarg, "norelro") == 0)
	link_info.relro = FALSE;
a1882 1
  fprintf (file, _("  -z norelro\t\tDon't create RELRO program header\n"));
a1884 1
  fprintf (file, _("  -z relro\t\tCreate RELRO program header\n"));
@


1.1.2.2
log
@binutils-050108.tar.bz2
@
text
@a65 10
if [ "x${USE_LIBPATH}" = xyes ] ; then
  case ${target} in
    *-*-linux-gnu*)
  cat >>e${EMULATION_NAME}.c <<EOF
#include <glob.h>
EOF
    ;;
  esac
fi

d509 2
a510 1
struct gld${EMULATION_NAME}_ld_so_conf
d512 3
a514 3
  char *path;
  size_t len, alloc;
};
d516 1
a516 13
static void
gld${EMULATION_NAME}_parse_ld_so_conf
     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename);

static void
gld${EMULATION_NAME}_parse_ld_so_conf_include
     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename,
      const char *pattern)
{
  char *newp = NULL;
  glob_t gl;

  if (pattern[0] != '/')
d518 2
a519 2
      char *p = strrchr (filename, '/');
      size_t patlen = strlen (pattern) + 1;
d521 4
a524 40
      newp = xmalloc (p - filename + 1 + patlen);
      memcpy (newp, filename, p - filename + 1);
      memcpy (newp + (p - filename + 1), pattern, patlen);
      pattern = newp;
    }

  if (glob (pattern, 0, NULL, &gl) == 0)
    {
      size_t i;

      for (i = 0; i < gl.gl_pathc; ++i)
	gld${EMULATION_NAME}_parse_ld_so_conf (info, gl.gl_pathv[i]);
      globfree (&gl);
    }

  if (newp)
    free (newp);
}

static void
gld${EMULATION_NAME}_parse_ld_so_conf
     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename)
{
  FILE *f = fopen (filename, FOPEN_RT);
  char *line;
  size_t linelen;

  if (f == NULL)
    return;

  linelen = 256;
  line = xmalloc (linelen);
  do
    {
      char *p = line, *q;

      /* Normally this would use getline(3), but we need to be portable.  */
      while ((q = fgets (p, linelen - (p - line), f)) != NULL
	     && strlen (q) == linelen - (p - line) - 1
	     && line[linelen - 2] != '\n')
d526 7
a532 23
	  line = xrealloc (line, 2 * linelen);
	  p = line + linelen - 1;
	  linelen += linelen;
	}

      if (q == NULL && p == line)
	break;

      p = strchr (line, '\n');
      if (p)
	*p = '\0';

      /* Because the file format does not know any form of quoting we
	 can search forward for the next '#' character and if found
	 make it terminating the line.  */
      p = strchr (line, '#');
      if (p)
	*p = '\0';

      /* Remove leading whitespace.  NUL is no whitespace character.  */
      p = line;
      while (*p == ' ' || *p == '\f' || *p == '\r' || *p == '\t' || *p == '\v')
	++p;
d534 1
a534 9
      /* If the line is blank it is ignored.  */
      if (p[0] == '\0')
	continue;

      if (!strncmp (p, "include", 7) && (p[7] == ' ' || p[7] == '\t'))
	{
	  char *dir, c;
	  p += 8;
	  do
d536 23
a558 7
	      while (*p == ' ' || *p == '\t')
		++p;

	      if (*p == '\0')
		break;

	      dir = p;
d560 2
a561 2
	      while (*p != ' ' && *p != '\t' && *p)
		++p;
d563 2
a564 23
	      c = *p;
	      *p++ = '\0';
	      if (dir[0] != '\0')
		gld${EMULATION_NAME}_parse_ld_so_conf_include (info, filename,
							       dir);
	    }
	  while (c != '\0');
	}
      else
	{
	  char *dir = p;
	  while (*p && *p != '=' && *p != ' ' && *p != '\t' && *p != '\f'
		 && *p != '\r' && *p != '\v')
	    ++p;

	  while (p != dir && p[-1] == '/')
	    --p;
	  if (info->path == NULL)
	    {
	      info->alloc = p - dir + 1 + 256;
	      info->path = xmalloc (info->alloc);
	      info->len = 0;
	    }
d567 2
a568 6
	      if (info->len + 1 + (p - dir) >= info->alloc)
		{
		  info->alloc += p - dir + 256;
		  info->path = xrealloc (info->path, info->alloc);
		}
	      info->path[info->len++] = ':';
a569 9
	  memcpy (info->path + info->len, dir, p - dir);
	  info->len += p - dir;
	  info->path[info->len] = '\0';
	}
    }
  while (! feof (f));
  free (line);
  fclose (f);
}
d571 1
a571 6
static bfd_boolean
gld${EMULATION_NAME}_check_ld_so_conf (const char *name, int force)
{
  static bfd_boolean initialized;
  static char *ld_so_conf;
  struct dt_needed needed;
d573 6
a578 4
  if (! initialized)
    {
      char *tmppath;
      struct gld${EMULATION_NAME}_ld_so_conf info;
d580 1
a580 10
      tmppath = concat (ld_sysroot, "/etc/ld.so.conf", NULL);
      info.path = NULL;
      info.len = info.alloc = 0;
      gld${EMULATION_NAME}_parse_ld_so_conf (&info, tmppath);
      free (tmppath);
      if (info.path)
	{
	  char *d = gld${EMULATION_NAME}_add_sysroot (info.path);
	  free (info.path);
	  ld_so_conf = d;
d582 1
d1065 1
a1065 1
/* A variant of lang_output_section_find used by place_orphan.  */
d1070 1
d1078 1
a1078 3
  for (lookup = &lang_output_section_statement.head->output_section_statement;
       lookup != NULL;
       lookup = lookup->next)
d1080 1
d1122 25
d1150 7
d1160 8
a1167 35
  static struct orphan_save hold[] =
    {
      { ".text",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE,
	0, 0, 0, 0 },
      { ".rodata",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
	0, 0, 0, 0 },
      { ".data",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA,
	0, 0, 0, 0 },
      { ".bss",
	SEC_ALLOC,
	0, 0, 0, 0 },
      { 0,
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
	0, 0, 0, 0 },
      { ".interp",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
	0, 0, 0, 0 },
      { ".sdata",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_SMALL_DATA,
	0, 0, 0, 0 }
    };
  enum orphan_save_index
    {
      orphan_text = 0,
      orphan_rodata,
      orphan_data,
      orphan_bss,
      orphan_rel,
      orphan_interp,
      orphan_sdata
    };
  static int orphan_init_done = 0;
d1169 3
d1173 1
a1173 1
  lang_output_section_statement_type *after;
d1175 2
d1178 1
a1200 1
	      || os->bfd_section->flags == 0
d1205 1
a1205 4
	     name, and its bfd section, if any, has compatible flags.
	     If the section already exists but does not have any flags
	     set, then it has been created by the linker, probably as a
	     result of a --section-start command line switch.  */
d1211 2
a1212 12
  if (!orphan_init_done)
    {
      struct orphan_save *ho;
      for (ho = hold; ho < hold + sizeof (hold) / sizeof (hold[0]); ++ho)
	if (ho->name != NULL)
	  {
	    ho->os = lang_output_section_find (ho->name);
	    if (ho->os != NULL && ho->os->flags == 0)
	      ho->os->flags = ho->flags;
	  }
      orphan_init_done = 1;
    }
d1219 1
a1219 1
      && hold[orphan_text].os != NULL)
d1221 1
a1221 2
      lang_add_section (&hold[orphan_text].os->children, s,
			hold[orphan_text].os, file);
d1230 2
d1237 12
a1248 8
	   && strncmp (secname, ".note", 5) == 0)
    place = &hold[orphan_interp];
  else if ((s->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
    place = &hold[orphan_bss];
  else if ((s->flags & SEC_SMALL_DATA) != 0)
    place = &hold[orphan_sdata];
  else if ((s->flags & SEC_READONLY) == 0)
    place = &hold[orphan_data];
d1250 26
a1275 6
	   && (s->flags & SEC_LOAD) != 0)
    place = &hold[orphan_rel];
  else if ((s->flags & SEC_CODE) == 0)
    place = &hold[orphan_rodata];
  else
    place = &hold[orphan_text];
d1277 7
a1283 1
  after = NULL;
d1286 12
a1297 1
      if (place->os == NULL)
d1299 8
a1306 4
	  if (place->name != NULL)
	    place->os = lang_output_section_find (place->name);
	  else
	    place->os = output_rel_find (s, isdyn);
a1307 6
      after = place->os;
      if (after == NULL)
	after = lang_output_section_find_by_flags (s, &place->os);
      if (after == NULL)
	/* *ABS* is always the first output section statement.  */
	after = &lang_output_section_statement.head->output_section_statement;
d1310 27
a1336 4
  /* Choose a unique name for the section.  This will be needed if the
     same section name appears in the input file with different
     loadable or allocatable characteristics.  */
  if (bfd_get_section_by_name (output_bfd, secname) != NULL)
d1338 11
a1348 4
      static int count = 1;
      secname = bfd_get_unique_section_name (output_bfd, secname, &count);
      if (secname == NULL)
	einfo ("%F%P: place_orphan failed: %E\n");
d1351 93
a1443 1
  lang_insert_orphan (file, s, secname, after, place, NULL, NULL);
d1496 5
a1500 5
sed $sc ldscripts/${EMULATION_NAME}.xu			>> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr			>> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn			>> e${EMULATION_NAME}.c
d1502 2
a1503 2
echo '  ; else if (!config.magic_demand_paged) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn			>> e${EMULATION_NAME}.c
d1510 1
a1510 1
sed $sc ldscripts/${EMULATION_NAME}.xdw			>> e${EMULATION_NAME}.c
d1512 1
a1512 1
sed $sc ldscripts/${EMULATION_NAME}.xdc			>> e${EMULATION_NAME}.c
d1514 2
a1515 2
echo '  ; else if (link_info.pie) return'		>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xd			>> e${EMULATION_NAME}.c
d1522 1
a1522 1
sed $sc ldscripts/${EMULATION_NAME}.xsw			>> e${EMULATION_NAME}.c
d1524 1
a1524 1
sed $sc ldscripts/${EMULATION_NAME}.xsc			>> e${EMULATION_NAME}.c
d1526 2
a1527 2
echo '  ; else if (link_info.shared) return'		>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xs			>> e${EMULATION_NAME}.c
d1532 7
a1538 7
sed $sc ldscripts/${EMULATION_NAME}.xw			>> e${EMULATION_NAME}.c
echo '  ; else if (link_info.combreloc) return'		>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xc			>> e${EMULATION_NAME}.c
fi
echo '  ; else return'					>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x			>> e${EMULATION_NAME}.c
echo '; }'						>> e${EMULATION_NAME}.c
d1623 1
a1623 2
#define OPTION_EXCLUDE_LIBS		(OPTION_EH_FRAME_HDR + 1)
  
a1637 1
    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
a1687 4
      break;

    case OPTION_EXCLUDE_LIBS:
      add_excluded_libs (optarg);
@


1.1.3.1
log
@Import testing binutils source into main tree
@
text
@@


1.1.3.2
log
@sync with testing_SYNC_C from testing/binutils, which apparently works
@
text
@d1 1
a1 1
# $MirBSD: testing/binutils/ld/emultempl/elf32.em,v 1.5 2004/08/12 19:56:53 tg Exp $
d58 1
a58 1
__RCSID("$MirBSD: testing/binutils/ld/emultempl/elf32.em,v 1.5 2004/08/12 19:56:53 tg Exp $");
a74 2
static char *gld${EMULATION_NAME}_search_dir (const char *, const char *);

d222 3
a224 1
  int class = 0;
d229 1
a229 14
  if (entry->as_needed)
    class = DYN_AS_NEEDED;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for any dynamic library in DT_NEEDED tags from
     this file at all.  */
  if (!entry->add_needed)
    class |= DYN_NO_ADD_NEEDED;

  if (!class
      || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)
    return FALSE;

  bfd_elf_set_dyn_lib_class (entry->the_bfd, class);
a367 5
struct dt_needed
{
  bfd *by;
  const char *name;
};
d374 1
a374 2
gld${EMULATION_NAME}_try_needed (struct dt_needed *needed,
				 int force)
d377 1
a377 3
  const char *name = needed->name;
  const char *soname;
  int class;
d481 1
a481 1
      free((void *)soname);
d491 1
a491 11
  class = DYN_DT_NEEDED;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file at all if the entry is from a file
     with DYN_NO_ADD_NEEDED.  */
  if (needed->by
      && (bfd_elf_get_dyn_lib_class (needed->by)
	  & DYN_NO_ADD_NEEDED) != 0)
    class |= DYN_NO_NEEDED | DYN_NO_ADD_NEEDED;

  bfd_elf_set_dyn_lib_class (abfd, class);
d504 1
a504 2
gld${EMULATION_NAME}_search_needed (const char *path,
				    struct dt_needed *n, int force)
a506 1
  const char *name = n->name;
a507 1
  struct dt_needed needed;
d510 1
a510 1
    return gld${EMULATION_NAME}_try_needed (n, force);
a513 4

  needed.by = n->by;
  needed.name = n->name;

d534 1
a534 2
      needed.name = filename;
      if (gld${EMULATION_NAME}_try_needed (&needed, force))
a600 1
  struct dt_needed needed;
d675 1
a675 4

  needed.by = NULL;
  needed.name = name;
  return gld${EMULATION_NAME}_search_needed (ld_so_conf, &needed, force);
a757 1
      struct dt_needed n, nn;
a773 3
      n.by = l->by;
      n.name = l->name;
      nn.by = l->by;
d803 1
a803 1
						  &n, force))
d809 1
a809 1
						  &n, force))
d819 2
a820 2
	      lib_path = (char *) getenv ("LD_RUN_PATH");
	      if (gld${EMULATION_NAME}_search_needed (lib_path, &n,
d824 24
a847 2
	  lib_path = (char *) getenv ("LD_LIBRARY_PATH");
	  if (gld${EMULATION_NAME}_search_needed (lib_path, &n, force))
d860 1
a860 1
							      &n,
d879 1
a879 2
	      nn.name = filename;
	      if (gld${EMULATION_NAME}_try_needed (&nn, force))
d990 1
a990 1
      sinterp->size = strlen (sinterp->contents) + 1;
d1033 1
a1033 1
      sinterp->size = strlen (command_line.interpreter) + 1;
d1058 1
a1058 1
	sz = s->size;
d1076 1
a1076 1
	s->size = 0;
a1090 1
/* ARGSUSED */
d1093 1
a1093 2
  (const char *arch __attribute__ ((__unused__)),
   search_dirs_type *search, lang_input_statement_type *entry)
d1196 1
a1196 2
      if (lookup->constraint != -1
	  && strncmp (".rel", lookup->name, 4) == 0)
a1291 1
  asection *sec;
a1293 1

d1306 1
a1306 1
  if (isdyn || (!config.unique_orphan_sections && !unique_section_p (s)))
d1345 7
d1384 2
a1385 6
     loadable or allocatable characteristics.  But if the section
     already exists but does not have any flags set, then it has been
     created by the linker, probably as a result of a --section-start
     command line switch.  */
  if ((sec = bfd_get_section_by_name (output_bfd, secname)) != NULL
      && bfd_get_section_flags (output_bfd, sec) != 0)
d1443 1
a1443 1
					    load_base, 0);
a1621 4
echo '  ; else if (link_info.pie && link_info.combreloc' >> e${EMULATION_NAME}.c
echo '             && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xdw                >> e${EMULATION_NAME}.c
a1629 4
echo '  ; else if (link_info.shared && link_info.combreloc' >> e${EMULATION_NAME}.c
echo '             && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xsw                >> e${EMULATION_NAME}.c
a1638 3
echo '  ; else if (link_info.combreloc && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xw                 >> e${EMULATION_NAME}.c
a1669 3
  else if (link_info.pie && link_info.combreloc
	   && link_info.relro && (link_info.flags & DT_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xdw";
a1681 3
  else if (link_info.shared && link_info.combreloc
	   && link_info.relro && (link_info.flags & DT_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xsw";
a1696 3
  else if (link_info.combreloc && link_info.relro
	   && (link_info.flags & DT_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xw";
a1835 4
      else if (strcmp (optarg, "relro") == 0)
	link_info.relro = TRUE;
      else if (strcmp (optarg, "norelro") == 0)
	link_info.relro = FALSE;
a1882 1
  fprintf (file, _("  -z norelro\t\tDon't create RELRO program header\n"));
a1884 1
  fprintf (file, _("  -z relro\t\tCreate RELRO program header\n"));
@

