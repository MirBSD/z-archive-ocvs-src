head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2004.08.11.21.22.49;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.05.55;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.05;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.41.05;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.25.32;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.43.26;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.08.51;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.18.57;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@# This shell script emits a C file. -*- C -*-
# It does some substitutions.
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
rm -f e${EMULATION_NAME}.c
(echo;echo;echo;echo;echo)>e${EMULATION_NAME}.c # there, now line numbers match ;-)
cat >>e${EMULATION_NAME}.c <<EOF
/* This file is part of GLD, the Gnu Linker.
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* For WINDOWS_NT */
/* The original file generated returned different default scripts depending
   on whether certain switches were set, but these switches pertain to the
   Linux system and that particular version of coff.  In the NT case, we
   only determine if the subsystem is console or windows in order to select
   the correct entry point by default. */

#define TARGET_IS_${EMULATION_NAME}

/* Do this before including bfd.h, so we prototype the right functions.  */
#ifdef TARGET_IS_arm_epoc_pe
#define bfd_arm_pe_allocate_interworking_sections \
	bfd_arm_epoc_pe_allocate_interworking_sections
#define bfd_arm_pe_get_bfd_for_interworking \
	bfd_arm_epoc_pe_get_bfd_for_interworking
#define bfd_arm_pe_process_before_allocation \
	bfd_arm_epoc_pe_process_before_allocation
#endif

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"
#include "getopt.h"
#include "libiberty.h"
#include "ld.h"
#include "ldmain.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"
#include <ldgram.h>
#include "ldlex.h"
#include "ldmisc.h"
#include "ldctor.h"
#include "coff/internal.h"

/* FIXME: This is a BFD internal header file, and we should not be
   using it here.  */
#include "../bfd/libcoff.h"

#include "deffile.h"
#include "pe-dll.h"

#include <ctype.h>

/* Permit the emulation parameters to override the default section
   alignment by setting OVERRIDE_SECTION_ALIGNMENT.  FIXME: This makes
   it seem that include/coff/internal.h should not define
   PE_DEF_SECTION_ALIGNMENT.  */
#if PE_DEF_SECTION_ALIGNMENT != ${OVERRIDE_SECTION_ALIGNMENT:-PE_DEF_SECTION_ALIGNMENT}
#undef PE_DEF_SECTION_ALIGNMENT
#define PE_DEF_SECTION_ALIGNMENT ${OVERRIDE_SECTION_ALIGNMENT}
#endif

#if defined(TARGET_IS_i386pe)
#define DLL_SUPPORT
#endif
#if defined(TARGET_IS_shpe) || defined(TARGET_IS_mipspe) || defined(TARGET_IS_armpe)
#define DLL_SUPPORT
#endif

#if defined(TARGET_IS_i386pe) || ! defined(DLL_SUPPORT)
#define	PE_DEF_SUBSYSTEM		3
#else
#undef NT_EXE_IMAGE_BASE
#undef PE_DEF_SECTION_ALIGNMENT
#undef PE_DEF_FILE_ALIGNMENT
#define NT_EXE_IMAGE_BASE		0x00010000
#ifdef TARGET_IS_armpe
#define PE_DEF_SECTION_ALIGNMENT	0x00001000
#define	PE_DEF_SUBSYSTEM		9
#else
#define PE_DEF_SECTION_ALIGNMENT	0x00000400
#define	PE_DEF_SUBSYSTEM		2
#endif
#define PE_DEF_FILE_ALIGNMENT		0x00000200
#endif

static void gld_${EMULATION_NAME}_set_symbols PARAMS ((void));
static void gld_${EMULATION_NAME}_after_open PARAMS ((void));
static void gld_${EMULATION_NAME}_before_parse PARAMS ((void));
static void gld_${EMULATION_NAME}_after_parse PARAMS ((void));
static void gld_${EMULATION_NAME}_before_allocation PARAMS ((void));
static asection *output_prev_sec_find
  PARAMS ((lang_output_section_statement_type *));
static bfd_boolean gld_${EMULATION_NAME}_place_orphan
  PARAMS ((lang_input_statement_type *, asection *));
static char *gld_${EMULATION_NAME}_get_script PARAMS ((int *));
static void gld_${EMULATION_NAME}_finish PARAMS ((void));
static bfd_boolean gld_${EMULATION_NAME}_open_dynamic_archive
  PARAMS ((const char *, search_dirs_type *, lang_input_statement_type *));
static void gld${EMULATION_NAME}_add_options
  PARAMS ((int, char **, int, struct option **, int, struct option **));
static bfd_boolean gld${EMULATION_NAME}_handle_option PARAMS ((int));
static void gld_${EMULATION_NAME}_list_options PARAMS ((FILE *));
static void set_pe_name PARAMS ((char *, long));
static void set_pe_subsystem PARAMS ((void));
static void set_pe_value PARAMS ((char *));
static void set_pe_stack_heap PARAMS ((char *, char *));

#ifdef DLL_SUPPORT
static bfd_boolean pe_undef_cdecl_match
  PARAMS ((struct bfd_link_hash_entry *, PTR));
static void pe_fixup_stdcalls PARAMS ((void));
static int make_import_fixup PARAMS ((arelent *, asection *));
static void pe_find_data_imports PARAMS ((void));
#endif

static bfd_boolean pr_sym PARAMS ((struct bfd_hash_entry *, PTR));
static bfd_boolean gld_${EMULATION_NAME}_unrecognized_file
  PARAMS ((lang_input_statement_type *));
static bfd_boolean gld_${EMULATION_NAME}_recognized_file
  PARAMS ((lang_input_statement_type *));
static int gld_${EMULATION_NAME}_find_potential_libraries
  PARAMS ((char *, lang_input_statement_type *));


static struct internal_extra_pe_aouthdr pe;
static int dll;
static int support_old_code = 0;
static char * thumb_entry_symbol = NULL;
static lang_assignment_statement_type *image_base_statement = 0;

#ifdef DLL_SUPPORT
static int pe_enable_stdcall_fixup = -1; /* 0=disable 1=enable.  */
static char *pe_out_def_filename = NULL;
static char *pe_implib_filename = NULL;
static int pe_enable_auto_image_base = 0;
static char *pe_dll_search_prefix = NULL;
#endif

extern const char *output_filename;

static void
gld_${EMULATION_NAME}_before_parse()
{
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_${ARCH};
  output_filename = "${EXECUTABLE_NAME:-a.exe}";
#ifdef DLL_SUPPORT
  config.dynamic_link = TRUE;
  config.has_shared = 1;
  link_info.pei386_auto_import = -1;
  link_info.pei386_runtime_pseudo_reloc = FALSE;

#if (PE_DEF_SUBSYSTEM == 9) || (PE_DEF_SUBSYSTEM == 2)
#if defined TARGET_IS_mipspe || defined TARGET_IS_armpe
  lang_add_entry ("WinMainCRTStartup", 1);
#else
  lang_add_entry ("_WinMainCRTStartup", 1);
#endif
#endif
#endif
}

/* PE format extra command line options.  */

/* Used for setting flags in the PE header.  */
#define OPTION_BASE_FILE		(300  + 1)
#define OPTION_DLL			(OPTION_BASE_FILE + 1)
#define OPTION_FILE_ALIGNMENT		(OPTION_DLL + 1)
#define OPTION_IMAGE_BASE		(OPTION_FILE_ALIGNMENT + 1)
#define OPTION_MAJOR_IMAGE_VERSION	(OPTION_IMAGE_BASE + 1)
#define OPTION_MAJOR_OS_VERSION		(OPTION_MAJOR_IMAGE_VERSION + 1)
#define OPTION_MAJOR_SUBSYSTEM_VERSION	(OPTION_MAJOR_OS_VERSION + 1)
#define OPTION_MINOR_IMAGE_VERSION	(OPTION_MAJOR_SUBSYSTEM_VERSION + 1)
#define OPTION_MINOR_OS_VERSION		(OPTION_MINOR_IMAGE_VERSION + 1)
#define OPTION_MINOR_SUBSYSTEM_VERSION	(OPTION_MINOR_OS_VERSION + 1)
#define OPTION_SECTION_ALIGNMENT	(OPTION_MINOR_SUBSYSTEM_VERSION + 1)
#define OPTION_STACK                    (OPTION_SECTION_ALIGNMENT + 1)
#define OPTION_SUBSYSTEM                (OPTION_STACK + 1)
#define OPTION_HEAP			(OPTION_SUBSYSTEM + 1)
#define OPTION_SUPPORT_OLD_CODE		(OPTION_HEAP + 1)
#define OPTION_OUT_DEF			(OPTION_SUPPORT_OLD_CODE + 1)
#define OPTION_EXPORT_ALL		(OPTION_OUT_DEF + 1)
#define OPTION_EXCLUDE_SYMBOLS		(OPTION_EXPORT_ALL + 1)
#define OPTION_KILL_ATS			(OPTION_EXCLUDE_SYMBOLS + 1)
#define OPTION_STDCALL_ALIASES		(OPTION_KILL_ATS + 1)
#define OPTION_ENABLE_STDCALL_FIXUP	(OPTION_STDCALL_ALIASES + 1)
#define OPTION_DISABLE_STDCALL_FIXUP	(OPTION_ENABLE_STDCALL_FIXUP + 1)
#define OPTION_IMPLIB_FILENAME		(OPTION_DISABLE_STDCALL_FIXUP + 1)
#define OPTION_THUMB_ENTRY		(OPTION_IMPLIB_FILENAME + 1)
#define OPTION_WARN_DUPLICATE_EXPORTS	(OPTION_THUMB_ENTRY + 1)
#define OPTION_IMP_COMPAT		(OPTION_WARN_DUPLICATE_EXPORTS + 1)
#define OPTION_ENABLE_AUTO_IMAGE_BASE	(OPTION_IMP_COMPAT + 1)
#define OPTION_DISABLE_AUTO_IMAGE_BASE	(OPTION_ENABLE_AUTO_IMAGE_BASE + 1)
#define OPTION_DLL_SEARCH_PREFIX	(OPTION_DISABLE_AUTO_IMAGE_BASE + 1)
#define OPTION_NO_DEFAULT_EXCLUDES	(OPTION_DLL_SEARCH_PREFIX + 1)
#define OPTION_DLL_ENABLE_AUTO_IMPORT	(OPTION_NO_DEFAULT_EXCLUDES + 1)
#define OPTION_DLL_DISABLE_AUTO_IMPORT	(OPTION_DLL_ENABLE_AUTO_IMPORT + 1)
#define OPTION_ENABLE_EXTRA_PE_DEBUG	(OPTION_DLL_DISABLE_AUTO_IMPORT + 1)
#define OPTION_EXCLUDE_LIBS		(OPTION_ENABLE_EXTRA_PE_DEBUG + 1)
#define OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC	\
					(OPTION_EXCLUDE_LIBS + 1)
#define OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC	\
					(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC + 1)

static void
gld${EMULATION_NAME}_add_options (ns, shortopts, nl, longopts, nrl, really_longopts)
     int ns ATTRIBUTE_UNUSED;
     char **shortopts ATTRIBUTE_UNUSED;
     int nl;
     struct option **longopts;
     int nrl ATTRIBUTE_UNUSED;
     struct option **really_longopts ATTRIBUTE_UNUSED;
{
  static const struct option xtra_long[] = {
    /* PE options */
    {"base-file", required_argument, NULL, OPTION_BASE_FILE},
    {"dll", no_argument, NULL, OPTION_DLL},
    {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
    {"heap", required_argument, NULL, OPTION_HEAP},
    {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
    {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
    {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
    {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
    {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
    {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
    {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
    {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
    {"stack", required_argument, NULL, OPTION_STACK},
    {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
    {"support-old-code", no_argument, NULL, OPTION_SUPPORT_OLD_CODE},
    {"thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
#ifdef DLL_SUPPORT
    /* getopt allows abbreviations, so we do this to stop it from treating -o
       as an abbreviation for this option */
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL},
    {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMBOLS},
    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
    {"kill-at", no_argument, NULL, OPTION_KILL_ATS},
    {"add-stdcall-alias", no_argument, NULL, OPTION_STDCALL_ALIASES},
    {"enable-stdcall-fixup", no_argument, NULL, OPTION_ENABLE_STDCALL_FIXUP},
    {"disable-stdcall-fixup", no_argument, NULL, OPTION_DISABLE_STDCALL_FIXUP},
    {"out-implib", required_argument, NULL, OPTION_IMPLIB_FILENAME},
    {"warn-duplicate-exports", no_argument, NULL, OPTION_WARN_DUPLICATE_EXPORTS},
    /* getopt() allows abbreviations, so we do this to stop it from
       treating -c as an abbreviation for these --compat-implib.  */
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"enable-auto-image-base", no_argument, NULL, OPTION_ENABLE_AUTO_IMAGE_BASE},
    {"disable-auto-image-base", no_argument, NULL, OPTION_DISABLE_AUTO_IMAGE_BASE},
    {"dll-search-prefix", required_argument, NULL, OPTION_DLL_SEARCH_PREFIX},
    {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
    {"enable-auto-import", no_argument, NULL, OPTION_DLL_ENABLE_AUTO_IMPORT},
    {"disable-auto-import", no_argument, NULL, OPTION_DLL_DISABLE_AUTO_IMPORT},
    {"enable-extra-pe-debug", no_argument, NULL, OPTION_ENABLE_EXTRA_PE_DEBUG},
    {"enable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC},
    {"disable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC},
#endif
    {NULL, no_argument, NULL, 0}
  };

  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

/* PE/WIN32; added routines to get the subsystem type, heap and/or stack
   parameters which may be input from the command line.  */

typedef struct
{
  void *ptr;
  int size;
  int value;
  char *symbol;
  int inited;
} definfo;

#define D(field,symbol,def)  {&pe.field,sizeof(pe.field), def, symbol,0}

static definfo init[] =
{
  /* imagebase must be first */
#define IMAGEBASEOFF 0
  D(ImageBase,"__image_base__", NT_EXE_IMAGE_BASE),
#define DLLOFF 1
  {&dll, sizeof(dll), 0, "__dll__", 0},
  D(SectionAlignment,"__section_alignment__", PE_DEF_SECTION_ALIGNMENT),
  D(FileAlignment,"__file_alignment__", PE_DEF_FILE_ALIGNMENT),
  D(MajorOperatingSystemVersion,"__major_os_version__", 4),
  D(MinorOperatingSystemVersion,"__minor_os_version__", 0),
  D(MajorImageVersion,"__major_image_version__", 1),
  D(MinorImageVersion,"__minor_image_version__", 0),
#ifdef TARGET_IS_armpe
  D(MajorSubsystemVersion,"__major_subsystem_version__", 2),
#else
  D(MajorSubsystemVersion,"__major_subsystem_version__", 4),
#endif
  D(MinorSubsystemVersion,"__minor_subsystem_version__", 0),
  D(Subsystem,"__subsystem__", ${SUBSYSTEM}),
  D(SizeOfStackReserve,"__size_of_stack_reserve__", 0x200000),
  D(SizeOfStackCommit,"__size_of_stack_commit__", 0x1000),
  D(SizeOfHeapReserve,"__size_of_heap_reserve__", 0x100000),
  D(SizeOfHeapCommit,"__size_of_heap_commit__", 0x1000),
  D(LoaderFlags,"__loader_flags__", 0x0),
  { NULL, 0, 0, NULL, 0 }
};


static void
gld_${EMULATION_NAME}_list_options (file)
     FILE * file;
{
  fprintf (file, _("  --base_file <basefile>             Generate a base file for relocatable DLLs\n"));
  fprintf (file, _("  --dll                              Set image base to the default for DLLs\n"));
  fprintf (file, _("  --file-alignment <size>            Set file alignment\n"));
  fprintf (file, _("  --heap <size>                      Set initial size of the heap\n"));
  fprintf (file, _("  --image-base <address>             Set start address of the executable\n"));
  fprintf (file, _("  --major-image-version <number>     Set version number of the executable\n"));
  fprintf (file, _("  --major-os-version <number>        Set minimum required OS version\n"));
  fprintf (file, _("  --major-subsystem-version <number> Set minimum required OS subsystem version\n"));
  fprintf (file, _("  --minor-image-version <number>     Set revision number of the executable\n"));
  fprintf (file, _("  --minor-os-version <number>        Set minimum required OS revision\n"));
  fprintf (file, _("  --minor-subsystem-version <number> Set minimum required OS subsystem revision\n"));
  fprintf (file, _("  --section-alignment <size>         Set section alignment\n"));
  fprintf (file, _("  --stack <size>                     Set size of the initial stack\n"));
  fprintf (file, _("  --subsystem <name>[:<version>]     Set required OS subsystem [& version]\n"));
  fprintf (file, _("  --support-old-code                 Support interworking with old code\n"));
  fprintf (file, _("  --thumb-entry=<symbol>             Set the entry point to be Thumb <symbol>\n"));
#ifdef DLL_SUPPORT
  fprintf (file, _("  --add-stdcall-alias                Export symbols with and without @@nn\n"));
  fprintf (file, _("  --disable-stdcall-fixup            Don't link _sym to _sym@@nn\n"));
  fprintf (file, _("  --enable-stdcall-fixup             Link _sym to _sym@@nn without warnings\n"));
  fprintf (file, _("  --exclude-symbols sym,sym,...      Exclude symbols from automatic export\n"));
  fprintf (file, _("  --exclude-libs lib,lib,...         Exclude libraries from automatic export\n"));
  fprintf (file, _("  --export-all-symbols               Automatically export all globals to DLL\n"));
  fprintf (file, _("  --kill-at                          Remove @@nn from exported symbols\n"));
  fprintf (file, _("  --out-implib <file>                Generate import library\n"));
  fprintf (file, _("  --output-def <file>                Generate a .DEF file for the built DLL\n"));
  fprintf (file, _("  --warn-duplicate-exports           Warn about duplicate exports.\n"));
  fprintf (file, _("  --compat-implib                    Create backward compatible import libs;\n\
                                       create __imp_<SYMBOL> as well.\n"));
  fprintf (file, _("  --enable-auto-image-base           Automatically choose image base for DLLs\n\
                                       unless user specifies one\n"));
  fprintf (file, _("  --disable-auto-image-base          Do not auto-choose image base. (default)\n"));
  fprintf (file, _("  --dll-search-prefix=<string>       When linking dynamically to a dll without\n\
                                       an importlib, use <string><basename>.dll\n\
                                       in preference to lib<basename>.dll \n"));
  fprintf (file, _("  --enable-auto-import               Do sophistcated linking of _sym to\n\
                                       __imp_sym for DATA references\n"));
  fprintf (file, _("  --disable-auto-import              Do not auto-import DATA items from DLLs\n"));
  fprintf (file, _("  --enable-runtime-pseudo-reloc      Work around auto-import limitations by\n\
                                       adding pseudo-relocations resolved at\n\
                                       runtime.\n"));
  fprintf (file, _("  --disable-runtime-pseudo-reloc     Do not add runtime pseudo-relocations for\n\
                                       auto-imported DATA.\n"));
  fprintf (file, _("  --enable-extra-pe-debug            Enable verbose debug output when building\n\
                                       or linking to DLLs (esp. auto-import)\n"));
#endif
}


static void
set_pe_name (name, val)
     char *name;
     long val;
{
  int i;

  /* Find the name and set it.  */
  for (i = 0; init[i].ptr; i++)
    {
      if (strcmp (name, init[i].symbol) == 0)
	{
	  init[i].value = val;
	  init[i].inited = 1;
	  return;
	}
    }
  abort ();
}


static void
set_pe_subsystem ()
{
  const char *sver;
  int len;
  int i;
  static const struct
    {
      const char *name;
      const int value;
      const char *entry;
    }
  v[] =
    {
      { "native", 1, "NtProcessStartup" },
#if defined TARGET_IS_mipspe || defined TARGET_IS_armpe
      { "windows", 2, "WinMainCRTStartup" },
#else
      { "windows", 2, "WinMainCRTStartup" },
#endif
      { "console", 3, "mainCRTStartup" },
#if 0
      /* The Microsoft linker does not recognize this.  */
      { "os2", 5, "" },
#endif
      { "posix", 7, "__PosixProcessStartup"},
      { "wince", 9, "_WinMainCRTStartup" },
      { 0, 0, 0 }
    };

  sver = strchr (optarg, ':');
  if (sver == NULL)
    len = strlen (optarg);
  else
    {
      char *end;

      len = sver - optarg;
      set_pe_name ("__major_subsystem_version__",
		   strtoul (sver + 1, &end, 0));
      if (*end == '.')
	set_pe_name ("__minor_subsystem_version__",
		     strtoul (end + 1, &end, 0));
      if (*end != '\0')
	einfo (_("%P: warning: bad version number in -subsystem option\n"));
    }

  for (i = 0; v[i].name; i++)
    {
      if (strncmp (optarg, v[i].name, len) == 0
	  && v[i].name[len] == '\0')
	{
	  const char *initial_symbol_char;
	  const char *entry;

	  set_pe_name ("__subsystem__", v[i].value);

	  initial_symbol_char = ${INITIAL_SYMBOL_CHAR};
	  if (*initial_symbol_char == '\0')
	    entry = v[i].entry;
	  else
	    {
	      char *alc_entry;

	      /* lang_add_entry expects its argument to be permanently
		 allocated, so we don't free this string.  */
	      alc_entry = xmalloc (strlen (initial_symbol_char)
				   + strlen (v[i].entry)
				   + 1);
	      strcpy (alc_entry, initial_symbol_char);
	      strcat (alc_entry, v[i].entry);
	      entry = alc_entry;
	    }

	  lang_add_entry (entry, 0);

	  return;
	}
    }

  einfo (_("%P%F: invalid subsystem type %s\n"), optarg);
}


static void
set_pe_value (name)
     char *name;

{
  char *end;

  set_pe_name (name,  strtoul (optarg, &end, 0));

  if (end == optarg)
    einfo (_("%P%F: invalid hex number for PE parameter '%s'\n"), optarg);

  optarg = end;
}


static void
set_pe_stack_heap (resname, comname)
     char *resname;
     char *comname;
{
  set_pe_value (resname);

  if (*optarg == ',')
    {
      optarg++;
      set_pe_value (comname);
    }
  else if (*optarg)
    einfo (_("%P%F: strange hex info for PE parameter '%s'\n"), optarg);
}


static bfd_boolean
gld${EMULATION_NAME}_handle_option (optc)
     int optc;
{
  switch (optc)
    {
    default:
      return FALSE;

    case OPTION_BASE_FILE:
      link_info.base_file = (PTR) fopen (optarg, FOPEN_WB);
      if (link_info.base_file == NULL)
	{
	  /* xgettext:c-format */
	  fprintf (stderr, _("%s: Can't open base file %s\n"),
		   program_name, optarg);
	  xexit (1);
	}
      break;

      /* PE options.  */
    case OPTION_HEAP:
      set_pe_stack_heap ("__size_of_heap_reserve__", "__size_of_heap_commit__");
      break;
    case OPTION_STACK:
      set_pe_stack_heap ("__size_of_stack_reserve__", "__size_of_stack_commit__");
      break;
    case OPTION_SUBSYSTEM:
      set_pe_subsystem ();
      break;
    case OPTION_MAJOR_OS_VERSION:
      set_pe_value ("__major_os_version__");
      break;
    case OPTION_MINOR_OS_VERSION:
      set_pe_value ("__minor_os_version__");
      break;
    case OPTION_MAJOR_SUBSYSTEM_VERSION:
      set_pe_value ("__major_subsystem_version__");
      break;
    case OPTION_MINOR_SUBSYSTEM_VERSION:
      set_pe_value ("__minor_subsystem_version__");
      break;
    case OPTION_MAJOR_IMAGE_VERSION:
      set_pe_value ("__major_image_version__");
      break;
    case OPTION_MINOR_IMAGE_VERSION:
      set_pe_value ("__minor_image_version__");
      break;
    case OPTION_FILE_ALIGNMENT:
      set_pe_value ("__file_alignment__");
      break;
    case OPTION_SECTION_ALIGNMENT:
      set_pe_value ("__section_alignment__");
      break;
    case OPTION_DLL:
      set_pe_name ("__dll__", 1);
      break;
    case OPTION_IMAGE_BASE:
      set_pe_value ("__image_base__");
      break;
    case OPTION_SUPPORT_OLD_CODE:
      support_old_code = 1;
      break;
    case OPTION_THUMB_ENTRY:
      thumb_entry_symbol = optarg;
      break;
#ifdef DLL_SUPPORT
    case OPTION_OUT_DEF:
      pe_out_def_filename = xstrdup (optarg);
      break;
    case OPTION_EXPORT_ALL:
      pe_dll_export_everything = 1;
      break;
    case OPTION_EXCLUDE_SYMBOLS:
      pe_dll_add_excludes (optarg, 0);
      break;
    case OPTION_EXCLUDE_LIBS:
      pe_dll_add_excludes (optarg, 1);
      break;
    case OPTION_KILL_ATS:
      pe_dll_kill_ats = 1;
      break;
    case OPTION_STDCALL_ALIASES:
      pe_dll_stdcall_aliases = 1;
      break;
    case OPTION_ENABLE_STDCALL_FIXUP:
      pe_enable_stdcall_fixup = 1;
      break;
    case OPTION_DISABLE_STDCALL_FIXUP:
      pe_enable_stdcall_fixup = 0;
      break;
    case OPTION_IMPLIB_FILENAME:
      pe_implib_filename = xstrdup (optarg);
      break;
    case OPTION_WARN_DUPLICATE_EXPORTS:
      pe_dll_warn_dup_exports = 1;
      break;
    case OPTION_IMP_COMPAT:
      pe_dll_compat_implib = 1;
      break;
    case OPTION_ENABLE_AUTO_IMAGE_BASE:
      pe_enable_auto_image_base = 1;
      break;
    case OPTION_DISABLE_AUTO_IMAGE_BASE:
      pe_enable_auto_image_base = 0;
      break;
    case OPTION_DLL_SEARCH_PREFIX:
      pe_dll_search_prefix = xstrdup (optarg);
      break;
    case OPTION_NO_DEFAULT_EXCLUDES:
      pe_dll_do_default_excludes = 0;
      break;
    case OPTION_DLL_ENABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 1;
      break;
    case OPTION_DLL_DISABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 0;
      break;
    case OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 1;
      break;
    case OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 0;
      break;
    case OPTION_ENABLE_EXTRA_PE_DEBUG:
      pe_dll_extra_pe_debug = 1;
      break;
#endif
    }
  return TRUE;
}


#ifdef DLL_SUPPORT
static unsigned long
strhash (const char *str)
{
  const unsigned char *s;
  unsigned long hash;
  unsigned int c;
  unsigned int len;

  hash = 0;
  len = 0;
  s = (const unsigned char *) str;
  while ((c = *s++) != '\0')
    {
      hash += c + (c << 17);
      hash ^= hash >> 2;
      ++len;
    }
  hash += len + (len << 17);
  hash ^= hash >> 2;

  return hash;
}

/* Use the output file to create a image base for relocatable DLLs.  */

static unsigned long
compute_dll_image_base (const char *ofile)
{
  unsigned long hash = strhash (ofile);
  return 0x60000000 | ((hash << 16) & 0x0FFC0000);
}
#endif

/* Assign values to the special symbols before the linker script is
   read.  */

static void
gld_${EMULATION_NAME}_set_symbols ()
{
  /* Run through and invent symbols for all the
     names and insert the defaults.  */
  int j;
  lang_statement_list_type *save;

  if (!init[IMAGEBASEOFF].inited)
    {
      if (link_info.relocateable)
	init[IMAGEBASEOFF].value = 0;
      else if (init[DLLOFF].value || link_info.shared)
#ifdef DLL_SUPPORT
	init[IMAGEBASEOFF].value = (pe_enable_auto_image_base) ?
	  compute_dll_image_base (output_filename) : NT_DLL_IMAGE_BASE;
#else
	init[IMAGEBASEOFF].value = NT_DLL_IMAGE_BASE;
#endif
      else
	init[IMAGEBASEOFF].value = NT_EXE_IMAGE_BASE;
    }

  /* Don't do any symbol assignments if this is a relocateable link.  */
  if (link_info.relocateable)
    return;

  /* Glue the assignments into the abs section.  */
  save = stat_ptr;

  stat_ptr = &(abs_output_section->children);

  for (j = 0; init[j].ptr; j++)
    {
      long val = init[j].value;
      lang_assignment_statement_type *rv;
      rv = lang_add_assignment (exp_assop ('=', init[j].symbol,
					   exp_intop (val)));
      if (init[j].size == sizeof (short))
	*(short *) init[j].ptr = val;
      else if (init[j].size == sizeof (int))
	*(int *) init[j].ptr = val;
      else if (init[j].size == sizeof (long))
	*(long *) init[j].ptr = val;
      /* This might be a long long or other special type.  */
      else if (init[j].size == sizeof (bfd_vma))
	*(bfd_vma *) init[j].ptr = val;
      else	abort ();
      if (j == IMAGEBASEOFF)
	image_base_statement = rv;
    }
  /* Restore the pointer.  */
  stat_ptr = save;

  if (pe.FileAlignment >
      pe.SectionAlignment)
    {
      einfo (_("%P: warning, file alignment > section alignment.\n"));
    }
}

/* This is called after the linker script and the command line options
   have been read.  */

static void
gld_${EMULATION_NAME}_after_parse ()
{
  /* The Windows libraries are designed for the linker to treat the
     entry point as an undefined symbol.  Otherwise, the .obj that
     defines mainCRTStartup is brought in because it is the first
     encountered in libc.lib and it has other symbols in it which will
     be pulled in by the link process.  To avoid this, we act as
     though the user specified -u with the entry point symbol.

     This function is called after the linker script and command line
     options have been read, so at this point we know the right entry
     point.  This function is called before the input files are
     opened, so registering the symbol as undefined will make a
     difference.  */

  if (! link_info.relocateable && entry_symbol.name != NULL)
    ldlang_add_undef (entry_symbol.name);
}

/* pe-dll.c directly accesses pe_data_import_dll,
   so it must be defined outside of #ifdef DLL_SUPPORT.
   Note - this variable is deliberately not initialised.
   This allows it to be treated as a common varaible, and only
   exist in one incarnation in a multiple target enabled linker.  */
char * pe_data_import_dll;

#ifdef DLL_SUPPORT
static struct bfd_link_hash_entry *pe_undef_found_sym;

static bfd_boolean
pe_undef_cdecl_match (h, string)
  struct bfd_link_hash_entry *h;
  PTR string;
{
  int sl;

  sl = strlen (string); /* Silence compiler warning.  */
  if (h->type == bfd_link_hash_defined
      && strncmp (h->root.string, string, sl) == 0
      && h->root.string[sl] == '@@')
    {
      pe_undef_found_sym = h;
      return FALSE;
    }
  return TRUE;
}

static void
pe_fixup_stdcalls ()
{
  static int gave_warning_message = 0;
  struct bfd_link_hash_entry *undef, *sym;

  if (pe_dll_extra_pe_debug)
    printf ("%s\n", __FUNCTION__);

  for (undef = link_info.hash->undefs; undef; undef=undef->next)
    if (undef->type == bfd_link_hash_undefined)
      {
	char* at = strchr (undef->root.string, '@@');
	int lead_at = (*undef->root.string == '@@');
	/* For now, don't try to fixup fastcall symbols.  */

	if (at && !lead_at)
	  {
	    /* The symbol is a stdcall symbol, so let's look for a
	       cdecl symbol with the same name and resolve to that.  */
	    char *cname = xstrdup (undef->root.string /* + lead_at */);
	    at = strchr (cname, '@@');
	    *at = 0;
	    sym = bfd_link_hash_lookup (link_info.hash, cname, 0, 0, 1);

	    if (sym && sym->type == bfd_link_hash_defined)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pe_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, cname);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
	else
	  {
	    /* The symbol is a cdecl symbol, so we look for stdcall
	       symbols - which means scanning the whole symbol table.  */
	    pe_undef_found_sym = 0;
	    bfd_link_hash_traverse (link_info.hash, pe_undef_cdecl_match,
				    (PTR) undef->root.string);
	    sym = pe_undef_found_sym;
	    if (sym)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pe_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, sym->root.string);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
      }
}

static int
make_import_fixup (rel, s)
  arelent *rel;
  asection *s;
{
  struct symbol_cache_entry *sym = *rel->sym_ptr_ptr;
  int addend = 0;

  if (pe_dll_extra_pe_debug)
    printf ("arelent: %s@@%#lx: add=%li\n", sym->name,
	    (long) rel->address, (long) rel->addend);

  if (! bfd_get_section_contents (s->owner, s, &addend, rel->address, sizeof (addend)))
    einfo (_("%C: Cannot get section contents - auto-import exception\n"),
	   s->owner, s, rel->address);

  pe_create_import_fixup (rel, s, addend);

  return 1;
}

static void
pe_find_data_imports ()
{
  struct bfd_link_hash_entry *undef, *sym;

  if (link_info.pei386_auto_import == 0)
    return;

  for (undef = link_info.hash->undefs; undef; undef=undef->next)
    {
      if (undef->type == bfd_link_hash_undefined)
        {
          /* C++ symbols are *long*.  */
          char buf[4096];

	  if (pe_dll_extra_pe_debug)
	    printf ("%s:%s\n", __FUNCTION__, undef->root.string);

          sprintf (buf, "__imp_%s", undef->root.string);

          sym = bfd_link_hash_lookup (link_info.hash, buf, 0, 0, 1);

          if (sym && sym->type == bfd_link_hash_defined)
            {
	      bfd *b = sym->u.def.section->owner;
	      asymbol **symbols;
	      int nsyms, symsize, i;

	      if (link_info.pei386_auto_import == -1)
		info_msg (_("Info: resolving %s by linking to %s (auto-import)\n"),
			  undef->root.string, buf);

	      symsize = bfd_get_symtab_upper_bound (b);
	      symbols = (asymbol **) xmalloc (symsize);
	      nsyms = bfd_canonicalize_symtab (b, symbols);

	      for (i = 0; i < nsyms; i++)
		{
		  if (memcmp (symbols[i]->name, "__head_",
			      sizeof ("__head_") - 1))
		    continue;

		  if (pe_dll_extra_pe_debug)
		    printf ("->%s\n", symbols[i]->name);

		  pe_data_import_dll = (char*) (symbols[i]->name +
						sizeof ("__head_") - 1);
		  break;
		}

	      pe_walk_relocs_of_symbol (&link_info, undef->root.string,
					make_import_fixup);

	      /* Let's differentiate it somehow from defined.  */
	      undef->type = bfd_link_hash_defweak;
	      /* We replace original name with __imp_ prefixed, this
		 1) may trash memory 2) leads to duplicate symbol generation.
		 Still, IMHO it's better than having name poluted.  */
	      undef->root.string = sym->root.string;
	      undef->u.def.value = sym->u.def.value;
	      undef->u.def.section = sym->u.def.section;
            }
        }
    }
}
#endif /* DLL_SUPPORT */

static bfd_boolean
pr_sym (h, string)
  struct bfd_hash_entry *h;
  PTR string ATTRIBUTE_UNUSED;
{
  if (pe_dll_extra_pe_debug)
    printf ("+%s\n",h->string);

  return TRUE;
}


static void
gld_${EMULATION_NAME}_after_open ()
{
  if (pe_dll_extra_pe_debug)
    {
      bfd *a;
      struct bfd_link_hash_entry *sym;

      printf ("%s()\n", __FUNCTION__);

      for (sym = link_info.hash->undefs; sym; sym=sym->next)
        printf ("-%s\n", sym->root.string);
      bfd_hash_traverse (&link_info.hash->table, pr_sym,NULL);

      for (a = link_info.input_bfds; a; a = a->link_next)
	printf ("*%s\n",a->filename);
    }

  /* Pass the wacky PE command line options into the output bfd.
     FIXME: This should be done via a function, rather than by
     including an internal BFD header.  */

  if (coff_data (output_bfd) == NULL || coff_data (output_bfd)->pe == 0)
    einfo (_("%F%P: PE operations on non PE file.\n"));

  pe_data (output_bfd)->pe_opthdr = pe;
  pe_data (output_bfd)->dll = init[DLLOFF].value;

#ifdef DLL_SUPPORT
  if (pe_enable_stdcall_fixup) /* -1=warn or 1=disable */
    pe_fixup_stdcalls ();

  pe_process_import_defs (output_bfd, & link_info);

  pe_find_data_imports ();

#if ! (defined (TARGET_IS_i386pe) || defined (TARGET_IS_armpe))
  if (link_info.shared)
#else
  if (!link_info.relocateable)
#endif
    pe_dll_build_sections (output_bfd, &link_info);

#ifndef TARGET_IS_i386pe
#ifndef TARGET_IS_armpe
  else
    pe_exe_build_sections (output_bfd, &link_info);
#endif
#endif
#endif

#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe)
  if (strstr (bfd_get_target (output_bfd), "arm") == NULL)
    {
      /* The arm backend needs special fields in the output hash structure.
	 These will only be created if the output format is an arm format,
	 hence we do not support linking and changing output formats at the
	 same time.  Use a link followed by objcopy to change output formats.  */
      einfo ("%F%X%P: error: cannot change output format whilst linking ARM binaries\n");
      return;
    }
  {
    /* Find a BFD that can hold the interworking stubs.  */
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (bfd_arm_pe_get_bfd_for_interworking (is->the_bfd, & link_info))
	  break;
      }
  }
#endif

  {
    /* This next chunk of code tries to detect the case where you have
       two import libraries for the same DLL (specifically,
       symbolically linking libm.a and libc.a in cygwin to
       libcygwin.a).  In those cases, it's possible for function
       thunks from the second implib to be used but without the
       head/tail objects, causing an improper import table.  We detect
       those cases and rename the "other" import libraries to match
       the one the head/tail come from, so that the linker will sort
       things nicely and produce a valid import table.  */

    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (is->the_bfd->my_archive)
	  {
	    int idata2 = 0, reloc_count=0, is_imp = 0;
	    asection *sec;

	    /* See if this is an import library thunk.  */
	    for (sec = is->the_bfd->sections; sec; sec = sec->next)
	      {
		if (strcmp (sec->name, ".idata\$2") == 0)
		  idata2 = 1;
		if (strncmp (sec->name, ".idata\$", 7) == 0)
		  is_imp = 1;
		reloc_count += sec->reloc_count;
	      }

	    if (is_imp && !idata2 && reloc_count)
	      {
		/* It is, look for the reference to head and see if it's
		   from our own library.  */
		for (sec = is->the_bfd->sections; sec; sec = sec->next)
		  {
		    int i;
		    long symsize;
		    long relsize;
		    asymbol **symbols;
		    arelent **relocs;
		    int nrelocs;

		    symsize = bfd_get_symtab_upper_bound (is->the_bfd);
		    if (symsize < 1)
		      break;
		    relsize = bfd_get_reloc_upper_bound (is->the_bfd, sec);
		    if (relsize < 1)
		      break;

		    symbols = (asymbol **) xmalloc (symsize);
		    symsize = bfd_canonicalize_symtab (is->the_bfd, symbols);
		    if (symsize < 0)
		      {
			einfo ("%X%P: unable to process symbols: %E");
			return;
		      }

		    relocs = (arelent **) xmalloc ((size_t) relsize);
		    nrelocs = bfd_canonicalize_reloc (is->the_bfd, sec,
							  relocs, symbols);
		    if (nrelocs < 0)
		      {
			free (relocs);
			einfo ("%X%P: unable to process relocs: %E");
			return;
		      }

		    for (i = 0; i < nrelocs; i++)
		      {
			struct symbol_cache_entry *s;
			struct bfd_link_hash_entry * blhe;
			bfd *other_bfd;
			char *n;

			s = (relocs[i]->sym_ptr_ptr)[0];

			if (s->flags & BSF_LOCAL)
			  continue;

			/* Thunk section with reloc to another bfd.  */
			blhe = bfd_link_hash_lookup (link_info.hash,
						     s->name,
						     FALSE, FALSE, TRUE);

			if (blhe == NULL
			    || blhe->type != bfd_link_hash_defined)
			  continue;

			other_bfd = blhe->u.def.section->owner;

			if (strcmp (is->the_bfd->my_archive->filename,
				    other_bfd->my_archive->filename) == 0)
			  continue;

			/* Rename this implib to match the other.  */
			n = (char *) xmalloc (strlen (other_bfd->my_archive->filename) + 1);

			strcpy (n, other_bfd->my_archive->filename);

			is->the_bfd->my_archive->filename = n;
		      }

		    free (relocs);
		    /* Note - we do not free the symbols,
		       they are now cached in the BFD.  */
		  }
	      }
	  }
      }
  }

  {
    int is_ms_arch = 0;
    bfd *cur_arch = 0;
    lang_input_statement_type *is2;

    /* Careful - this is a shell script.  Watch those dollar signs! */
    /* Microsoft import libraries have every member named the same,
       and not in the right order for us to link them correctly.  We
       must detect these and rename the members so that they'll link
       correctly.  There are three types of objects: the head, the
       thunks, and the sentinel(s).  The head is easy; it's the one
       with idata2.  We assume that the sentinels won't have relocs,
       and the thunks will.  It's easier than checking the symbol
       table for external references.  */
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (is->the_bfd->my_archive)
	  {
	    bfd *arch = is->the_bfd->my_archive;
	    if (cur_arch != arch)
	      {
		cur_arch = arch;
		is_ms_arch = 1;
		for (is2 = is;
		     is2 && is2->the_bfd->my_archive == arch;
		     is2 = (lang_input_statement_type *)is2->next)
		  {
		    if (strcmp (is->the_bfd->filename, is2->the_bfd->filename))
		      is_ms_arch = 0;
		  }
	      }

	    if (is_ms_arch)
	      {
		int idata2 = 0, reloc_count=0;
		asection *sec;
		char *new_name, seq;

		for (sec = is->the_bfd->sections; sec; sec = sec->next)
		  {
		    if (strcmp (sec->name, ".idata\$2") == 0)
		      idata2 = 1;
		    reloc_count += sec->reloc_count;
		  }

		if (idata2) /* .idata2 is the TOC */
		  seq = 'a';
		else if (reloc_count > 0) /* thunks */
		  seq = 'b';
		else /* sentinel */
		  seq = 'c';

		new_name = xmalloc (strlen (is->the_bfd->filename) + 3);
		sprintf (new_name, "%s.%c", is->the_bfd->filename, seq);
		is->the_bfd->filename = new_name;

		new_name = xmalloc (strlen (is->filename) + 3);
		sprintf (new_name, "%s.%c", is->filename, seq);
		is->filename = new_name;
	      }
	  }
      }
  }
}

static void
gld_${EMULATION_NAME}_before_allocation ()
{
#ifdef TARGET_IS_ppcpe
  /* Here we rummage through the found bfds to collect toc information.  */
  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (!ppc_process_before_allocation (is->the_bfd, &link_info))
	  {
	    /* xgettext:c-format */
	    einfo (_("Errors encountered processing file %s\n"), is->filename);
	  }
      }
  }

  /* We have seen it all. Allocate it, and carry on.  */
  ppc_allocate_toc_section (&link_info);
#endif /* TARGET_IS_ppcpe */

#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe)
  /* FIXME: we should be able to set the size of the interworking stub
     section.

     Here we rummage through the found bfds to collect glue
     information.  FIXME: should this be based on a command line
     option?  krk@@cygnus.com.  */
  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (! bfd_arm_pe_process_before_allocation
	    (is->the_bfd, & link_info, support_old_code))
	  {
	    /* xgettext:c-format */
	    einfo (_("Errors encountered processing file %s for interworking"),
		   is->filename);
	  }
      }
  }

  /* We have seen it all. Allocate it, and carry on.  */
  bfd_arm_pe_allocate_interworking_sections (& link_info);
#endif /* TARGET_IS_armpe */
}

#ifdef DLL_SUPPORT
/* This is called when an input file isn't recognized as a BFD.  We
   check here for .DEF files and pull them in automatically.  */

static int
saw_option (char * option)
{
  int i;

  for (i = 0; init[i].ptr; i++)
    if (strcmp (init[i].symbol, option) == 0)
      return init[i].inited;
  return 0;
}
#endif /* DLL_SUPPORT */

static bfd_boolean
gld_${EMULATION_NAME}_unrecognized_file (entry)
     lang_input_statement_type *entry ATTRIBUTE_UNUSED;
{
#ifdef DLL_SUPPORT
  const char *ext = entry->filename + strlen (entry->filename) - 4;

  if (strcmp (ext, ".def") == 0 || strcmp (ext, ".DEF") == 0)
    {
      if (pe_def_file == 0)
	pe_def_file = def_file_empty ();

      def_file_parse (entry->filename, pe_def_file);

      if (pe_def_file)
	{
	  int i, buflen=0, len;
	  char *buf;

	  for (i = 0; i < pe_def_file->num_exports; i++)
	    {
	      len = strlen (pe_def_file->exports[i].internal_name);
	      if (buflen < len + 2)
		buflen = len + 2;
	    }

	  buf = (char *) xmalloc (buflen);

	  for (i = 0; i < pe_def_file->num_exports; i++)
	    {
	      struct bfd_link_hash_entry *h;

	      sprintf (buf, "_%s", pe_def_file->exports[i].internal_name);

	      h = bfd_link_hash_lookup (link_info.hash, buf, TRUE, TRUE, TRUE);
	      if (h == (struct bfd_link_hash_entry *) NULL)
		einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	      if (h->type == bfd_link_hash_new)
		{
		  h->type = bfd_link_hash_undefined;
		  h->u.undef.abfd = NULL;
		  bfd_link_add_undef (link_info.hash, h);
		}
	    }
	  free (buf);

	  /* def_file_print (stdout, pe_def_file); */
	  if (pe_def_file->is_dll == 1)
	    link_info.shared = 1;

	  if (pe_def_file->base_address != (bfd_vma)(-1))
	    {
	      pe.ImageBase =
		pe_data (output_bfd)->pe_opthdr.ImageBase =
		init[IMAGEBASEOFF].value = pe_def_file->base_address;
	      init[IMAGEBASEOFF].inited = 1;
	      if (image_base_statement)
		image_base_statement->exp =
		  exp_assop ('=', "__image_base__", exp_intop (pe.ImageBase));
	    }

#if 0
	  /* Not sure if these *should* be set.  */
	  if (pe_def_file->version_major != -1)
	    {
	      pe.MajorImageVersion = pe_def_file->version_major;
	      pe.MinorImageVersion = pe_def_file->version_minor;
	    }
#endif
	  if (pe_def_file->stack_reserve != -1
	      && ! saw_option ("__size_of_stack_reserve__"))
	    {
	      pe.SizeOfStackReserve = pe_def_file->stack_reserve;
	      if (pe_def_file->stack_commit != -1)
		pe.SizeOfStackCommit = pe_def_file->stack_commit;
	    }
	  if (pe_def_file->heap_reserve != -1
	      && ! saw_option ("__size_of_heap_reserve__"))
	    {
	      pe.SizeOfHeapReserve = pe_def_file->heap_reserve;
	      if (pe_def_file->heap_commit != -1)
		pe.SizeOfHeapCommit = pe_def_file->heap_commit;
	    }
	  return TRUE;
	}
    }
#endif
  return FALSE;
}

static bfd_boolean
gld_${EMULATION_NAME}_recognized_file (entry)
  lang_input_statement_type *entry ATTRIBUTE_UNUSED;
{
#ifdef DLL_SUPPORT
#ifdef TARGET_IS_i386pe
  pe_dll_id_target ("pei-i386");
#endif
#ifdef TARGET_IS_shpe
  pe_dll_id_target ("pei-shl");
#endif
#ifdef TARGET_IS_mipspe
  pe_dll_id_target ("pei-mips");
#endif
#ifdef TARGET_IS_armpe
  pe_dll_id_target ("pei-arm-little");
#endif
  if (bfd_get_format (entry->the_bfd) == bfd_object)
    {
      char fbuf[LD_PATHMAX + 1];
      const char *ext;

      if (REALPATH (entry->filename, fbuf) == NULL)
	strncpy (fbuf, entry->filename, sizeof (fbuf));

      ext = fbuf + strlen (fbuf) - 4;

      if (strcmp (ext, ".dll") == 0 || strcmp (ext, ".DLL") == 0)
	return pe_implied_import_dll (fbuf);
    }
#endif
  return FALSE;
}

static void
gld_${EMULATION_NAME}_finish ()
{
#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe)
  struct bfd_link_hash_entry * h;

  if (thumb_entry_symbol != NULL)
    {
      h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,
				FALSE, FALSE, TRUE);

      if (h != (struct bfd_link_hash_entry *) NULL
	  && (h->type == bfd_link_hash_defined
	      || h->type == bfd_link_hash_defweak)
	  && h->u.def.section->output_section != NULL)
	{
	  static char buffer[32];
	  bfd_vma val;

	  /* Special procesing is required for a Thumb entry symbol.  The
	     bottom bit of its address must be set.  */
	  val = (h->u.def.value
		 + bfd_get_section_vma (output_bfd,
					h->u.def.section->output_section)
		 + h->u.def.section->output_offset);

	  val |= 1;

	  /* Now convert this value into a string and store it in entry_symbol
	     where the lang_finish() function will pick it up.  */
	  buffer[0] = '0';
	  buffer[1] = 'x';

	  sprintf_vma (buffer + 2, val);

	  if (entry_symbol.name != NULL && entry_from_cmdline)
	    einfo (_("%P: warning: '--thumb-entry %s' is overriding '-e %s'\n"),
		   thumb_entry_symbol, entry_symbol.name);
	  entry_symbol.name = buffer;
	}
      else
	einfo (_("%P: warning: connot find thumb start symbol %s\n"), thumb_entry_symbol);
    }
#endif /* defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) */

#ifdef DLL_SUPPORT
  if (link_info.shared
#if !defined(TARGET_IS_shpe) && !defined(TARGET_IS_mipspe)
    || (!link_info.relocateable && pe_def_file->num_exports != 0)
#endif
    )
    {
      pe_dll_fill_sections (output_bfd, &link_info);
      if (pe_implib_filename)
	pe_dll_generate_implib (pe_def_file, pe_implib_filename);
    }
#if defined(TARGET_IS_shpe) || defined(TARGET_IS_mipspe)
  /* ARM doesn't need relocs.  */
  else
    {
      pe_exe_fill_sections (output_bfd, &link_info);
    }
#endif

  if (pe_out_def_filename)
    pe_dll_generate_def_file (pe_out_def_filename);
#endif /* DLL_SUPPORT */

  /* I don't know where .idata gets set as code, but it shouldn't be.  */
  {
    asection *asec = bfd_get_section_by_name (output_bfd, ".idata");

    if (asec)
      {
        asec->flags &= ~SEC_CODE;
        asec->flags |= SEC_DATA;
      }
  }
}


/* Find the last output section before given output statement.
   Used by place_orphan.  */

static asection *
output_prev_sec_find (os)
     lang_output_section_statement_type *os;
{
  asection *s = (asection *) NULL;
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (lookup == os)
	return s;

      if (lookup->bfd_section != NULL && lookup->bfd_section->owner != NULL)
	s = lookup->bfd_section;
    }

  return NULL;
}

/* Place an orphan section.

   We use this to put sections in a reasonable place in the file, and
   to ensure that they are aligned as required.

   We handle grouped sections here as well.  A section named .foo$nn
   goes into the output section .foo.  All grouped sections are sorted
   by name.

   Grouped sections for the default sections are handled by the
   default linker script using wildcards, and are sorted by
   sort_sections.  */

struct orphan_save
{
  lang_output_section_statement_type *os;
  asection **section;
  lang_statement_union_type **stmt;
};

static bfd_boolean
gld_${EMULATION_NAME}_place_orphan (file, s)
     lang_input_statement_type *file;
     asection *s;
{
  const char *secname;
  char *hold_section_name;
  char *dollar = NULL;
  const char *ps = NULL;
  lang_output_section_statement_type *os;
  lang_statement_list_type add_child;

  secname = bfd_get_section_name (s->owner, s);

  /* Look through the script to see where to place this section.  */
  hold_section_name = xstrdup (secname);
  if (!link_info.relocateable)
    {
      dollar = strchr (hold_section_name, '$');
      if (dollar != NULL)
	*dollar = '\0';
    }

  os = lang_output_section_find (hold_section_name);

  lang_list_init (&add_child);

  if (os != NULL
      && (os->bfd_section == NULL
	  || ((s->flags ^ os->bfd_section->flags)
	      & (SEC_LOAD | SEC_ALLOC)) == 0))
    {
      /* We already have an output section statement with this
	 name, and its bfd section, if any, has compatible flags.  */
      lang_add_section (&add_child, s, os, file);
    }
  else
    {
      struct orphan_save *place;
      static struct orphan_save hold_text;
      static struct orphan_save hold_rdata;
      static struct orphan_save hold_data;
      static struct orphan_save hold_bss;
      char *outsecname;
      lang_statement_list_type *old;
      lang_statement_list_type add;
      etree_type *address;

      /* Try to put the new output section in a reasonable place based
	 on the section name and section flags.  */
#define HAVE_SECTION(hold, name) \
(hold.os != NULL || (hold.os = lang_output_section_find (name)) != NULL)

      place = NULL;
      if ((s->flags & SEC_ALLOC) == 0)
	;
      else if ((s->flags & SEC_HAS_CONTENTS) == 0
	       && HAVE_SECTION (hold_bss, ".bss"))
	place = &hold_bss;
      else if ((s->flags & SEC_READONLY) == 0
	       && HAVE_SECTION (hold_data, ".data"))
	place = &hold_data;
      else if ((s->flags & SEC_CODE) == 0
	       && (s->flags & SEC_READONLY) != 0
	       && HAVE_SECTION (hold_rdata, ".rdata"))
	place = &hold_rdata;
      else if ((s->flags & SEC_READONLY) != 0
	       && HAVE_SECTION (hold_text, ".text"))
	place = &hold_text;

#undef HAVE_SECTION

      /* Choose a unique name for the section.  This will be needed if
	 the same section name appears in the input file with
	 different loadable or allocatable characteristics.  */
      outsecname = xstrdup (hold_section_name);
      if (bfd_get_section_by_name (output_bfd, outsecname) != NULL)
	{
	  unsigned int len;
	  char *newname;
	  unsigned int i;

	  len = strlen (outsecname);
	  newname = xmalloc (len + 5);
	  strcpy (newname, outsecname);
	  i = 0;
	  do
	    {
	      sprintf (newname + len, "%d", i);
	      ++i;
	    }
	  while (bfd_get_section_by_name (output_bfd, newname) != NULL);

	  free (outsecname);
	  outsecname = newname;
	}

      /* Start building a list of statements for this section.  */
      old = stat_ptr;
      stat_ptr = &add;
      lang_list_init (stat_ptr);

      if (config.build_constructors)
	{
	  /* If the name of the section is representable in C, then create
	     symbols to mark the start and the end of the section.  */
	  for (ps = outsecname; *ps != '\0'; ps++)
	    if (! isalnum ((unsigned char) *ps) && *ps != '_')
	      break;
	  if (*ps == '\0')
	    {
	      char *symname;
	      etree_type *e_align;

	      symname = (char *) xmalloc (ps - outsecname + sizeof "___start_");
	      sprintf (symname, "___start_%s", outsecname);
	      e_align = exp_unop (ALIGN_K,
				  exp_intop ((bfd_vma) 1 << s->alignment_power));
	      lang_add_assignment (exp_assop ('=', symname, e_align));
	    }
	}

      if (link_info.relocateable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
	address = exp_intop ((bfd_vma) 0);
      else
	{
	  /* All sections in an executable must be aligned to a page
	     boundary.  */
	  address = exp_unop (ALIGN_K,
			      exp_nameop (NAME, "__section_alignment__"));
	}

      os = lang_enter_output_section_statement (outsecname, address, 0,
						(bfd_vma) 0,
						(etree_type *) NULL,
						(etree_type *) NULL,
						(etree_type *) NULL);

      lang_add_section (&add_child, s, os, file);

      lang_leave_output_section_statement
	((bfd_vma) 0, "*default*",
	 (struct lang_output_section_phdr_list *) NULL, NULL);

      if (config.build_constructors && *ps == '\0')
        {
	  char *symname;

	  /* lang_leave_ouput_section_statement resets stat_ptr.
	     Put stat_ptr back where we want it.  */
	  if (place != NULL)
	    stat_ptr = &add;

	  symname = (char *) xmalloc (ps - outsecname + sizeof "___stop_");
	  sprintf (symname, "___stop_%s", outsecname);
	  lang_add_assignment (exp_assop ('=', symname,
					  exp_nameop (NAME, ".")));
	}

      stat_ptr = old;

      if (place != NULL && os->bfd_section != NULL)
	{
	  asection *snew, **pps;

	  snew = os->bfd_section;

	  /* Shuffle the bfd section list to make the output file look
	     neater.  This is really only cosmetic.  */
	  if (place->section == NULL)
	    {
	      asection *bfd_section = place->os->bfd_section;

	      /* If the output statement hasn't been used to place
		 any input sections (and thus doesn't have an output
		 bfd_section), look for the closest prior output statement
		 having an output section.  */
	      if (bfd_section == NULL)
		bfd_section = output_prev_sec_find (place->os);

	      if (bfd_section != NULL && bfd_section != snew)
		place->section = &bfd_section->next;
	    }

	  if (place->section != NULL)
	    {
	      /* Unlink the section.  */
	      for (pps = &output_bfd->sections;
		   *pps != snew;
		   pps = &(*pps)->next)
		;
	      bfd_section_list_remove (output_bfd, pps);

	      /* Now tack it on to the "place->os" section list.  */
	      bfd_section_list_insert (output_bfd, place->section, snew);
	    }

	  /* Save the end of this list.  Further ophans of this type will
	     follow the one we've just added.  */
	  place->section = &snew->next;

	  /* The following is non-cosmetic.  We try to put the output
	     statements in some sort of reasonable order here, because
	     they determine the final load addresses of the orphan
	     sections.  In addition, placing output statements in the
	     wrong order may require extra segments.  For instance,
	     given a typical situation of all read-only sections placed
	     in one segment and following that a segment containing all
	     the read-write sections, we wouldn't want to place an orphan
	     read/write section before or amongst the read-only ones.  */
	  if (add.head != NULL)
	    {
	      if (place->stmt == NULL)
		{
		  /* Put the new statement list right at the head.  */
		  *add.tail = place->os->header.next;
		  place->os->header.next = add.head;
		}
	      else
		{
		  /* Put it after the last orphan statement we added.  */
		  *add.tail = *place->stmt;
		  *place->stmt = add.head;
		}

	      /* Fix the global list pointer if we happened to tack our
		 new list at the tail.  */
	      if (*old->tail == add.head)
		old->tail = add.tail;

	      /* Save the end of this list.  */
	      place->stmt = add.tail;
	    }
	}
    }

  {
    lang_statement_union_type **pl = &os->children.head;

    if (dollar != NULL)
      {
	bfd_boolean found_dollar;

	/* The section name has a '$'.  Sort it with the other '$'
	   sections.  */
	found_dollar = FALSE;
	for ( ; *pl != NULL; pl = &(*pl)->header.next)
	  {
	    lang_input_section_type *ls;
	    const char *lname;

	    if ((*pl)->header.type != lang_input_section_enum)
	      continue;

	    ls = &(*pl)->input_section;

	    lname = bfd_get_section_name (ls->ifile->the_bfd, ls->section);
	    if (strchr (lname, '$') == NULL)
	      {
		if (found_dollar)
		  break;
	      }
	    else
	      {
		found_dollar = TRUE;
		if (strcmp (secname, lname) < 0)
		  break;
	      }
	  }
      }

    if (add_child.head != NULL)
      {
	add_child.head->header.next = *pl;
	*pl = add_child.head;
      }
  }

  free (hold_section_name);

  return TRUE;
}

static bfd_boolean
gld_${EMULATION_NAME}_open_dynamic_archive (arch, search, entry)
     const char * arch ATTRIBUTE_UNUSED;
     search_dirs_type * search;
     lang_input_statement_type * entry;
{
  const char * filename;
  char * string;

  if (! entry->is_archive)
    return FALSE;

  filename = entry->filename;

  string = (char *) xmalloc (strlen (search->name)
                             + strlen (filename)
                             + sizeof "/lib.a.dll"
#ifdef DLL_SUPPORT
                             + (pe_dll_search_prefix ? strlen (pe_dll_search_prefix) : 0)
#endif
                             + 1);

  /* Try "libfoo.dll.a" first (preferred explicit import library for dll's.  */
  sprintf (string, "%s/lib%s.dll.a", search->name, filename);

  if (! ldfile_try_open_bfd (string, entry))
    {
      /* Try "foo.dll.a" next (alternate explicit import library for dll's.  */
      sprintf (string, "%s/%s.dll.a", search->name, filename);
      if (! ldfile_try_open_bfd (string, entry))
        {
	  /* Try libfoo.a next. Normally, this would be interpreted as a static
	     library, but it *could* be an import library. For backwards compatibility,
	     libfoo.a needs to ==precede== libfoo.dll and foo.dll in the search,
	     or sometimes errors occur when building legacy packages.

	     Putting libfoo.a here means that in a failure case (i.e. the library
	     -lfoo is not found) we will search for libfoo.a twice before
	     giving up -- once here, and once when searching for a "static" lib.
	     for a "static" lib.  */
          /* Try "libfoo.a" (import lib, or static lib, but must
             take precedence over dll's).  */
          sprintf (string, "%s/lib%s.a", search->name, filename);
          if (! ldfile_try_open_bfd (string, entry))
            {
#ifdef DLL_SUPPORT
              if (pe_dll_search_prefix)
                {
                  /* Try "<prefix>foo.dll" (preferred dll name, if specified).  */
                  sprintf (string, "%s/%s%s.dll", search->name, pe_dll_search_prefix, filename);
                  if (! ldfile_try_open_bfd (string, entry))
                    {
                      /* Try "libfoo.dll" (default preferred dll name).  */
                      sprintf (string, "%s/lib%s.dll", search->name, filename);
                      if (! ldfile_try_open_bfd (string, entry))
                        {
                          /* Finally, try "foo.dll" (alternate dll name).  */
                          sprintf (string, "%s/%s.dll", search->name, filename);
                          if (! ldfile_try_open_bfd (string, entry))
                            {
                              free (string);
                              return FALSE;
                            }
                        }
                    }
                }
              else /* pe_dll_search_prefix not specified.  */
#endif
                {
                  /* Try "libfoo.dll" (preferred dll name).  */
                  sprintf (string, "%s/lib%s.dll", search->name, filename);
                  if (! ldfile_try_open_bfd (string, entry))
                    {
                      /* Finally, try "foo.dll" (alternate dll name).  */
                      sprintf (string, "%s/%s.dll", search->name, filename);
                      if (! ldfile_try_open_bfd (string, entry))
                        {
                          free (string);
                          return FALSE;
                        }
                    }
                }
            }
        }
    }

  entry->filename = string;

  return TRUE;
}

static int
gld_${EMULATION_NAME}_find_potential_libraries (name, entry)
     char * name;
     lang_input_statement_type * entry;
{
  return ldfile_open_file_search (name, entry, "", ".lib");
}

static char *
gld_${EMULATION_NAME}_get_script (isfile)
     int *isfile;
EOF
# Scripts compiled in.
# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 0;

  if (link_info.relocateable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                 >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                 >> e${EMULATION_NAME}.c
echo '  ; else return'                                 >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
echo '; }'                                             >> e${EMULATION_NAME}.c

cat >>e${EMULATION_NAME}.c <<EOF


struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
  gld_${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  gld_${EMULATION_NAME}_after_parse,
  gld_${EMULATION_NAME}_after_open,
  after_allocation_default,
  set_output_arch_default,
  ldemul_default_target,
  gld_${EMULATION_NAME}_before_allocation,
  gld_${EMULATION_NAME}_get_script,
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  gld_${EMULATION_NAME}_finish,
  NULL, /* Create output section statements.  */
  gld_${EMULATION_NAME}_open_dynamic_archive,
  gld_${EMULATION_NAME}_place_orphan,
  gld_${EMULATION_NAME}_set_symbols,
  NULL, /* parse_args */
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
  gld_${EMULATION_NAME}_unrecognized_file,
  gld_${EMULATION_NAME}_list_options,
  gld_${EMULATION_NAME}_recognized_file,
  gld_${EMULATION_NAME}_find_potential_libraries,
  NULL	/* new_vers_pattern.  */
};
EOF
@


1.2
log
@looks as if some sour wine (Federweier <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d3 5
d12 1
a12 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
d15 13
a27 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d34 14
a47 2
   the correct entry point by default. */ 
  
a54 1
#include "ldgram.h"
d59 1
d72 1
a72 1
#define TARGET_IS_${EMULATION_NAME}
a106 9
#ifdef TARGET_IS_arm_epoc_pe
#define bfd_arm_pe_allocate_interworking_sections \
	bfd_arm_epoc_pe_allocate_interworking_sections
#define bfd_arm_pe_get_bfd_for_interworking \
	bfd_arm_epoc_pe_get_bfd_for_interworking
#define bfd_arm_pe_process_before_allocation \
	bfd_arm_epoc_pe_process_before_allocation
#endif

d112 3
a114 1
static boolean gld_${EMULATION_NAME}_place_orphan
a116 1
static int gld_${EMULATION_NAME}_parse_args PARAMS ((int, char **));
d118 1
a118 1
static boolean gld_${EMULATION_NAME}_open_dynamic_archive 
d120 25
d153 1
a153 1
static int pe_enable_stdcall_fixup = -1; /* 0=disable 1=enable */
d165 9
a174 1
  ldfile_output_architecture = bfd_arch_${ARCH};
d176 1
d178 2
d193 1
a193 1
/* Used for setting flags in the PE header. */
d224 8
d233 27
a259 18
static struct option longopts[] = {
  /* PE options */
  {"base-file", required_argument, NULL, OPTION_BASE_FILE},
  {"dll", no_argument, NULL, OPTION_DLL},
  {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
  {"heap", required_argument, NULL, OPTION_HEAP}, 
  {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
  {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
  {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
  {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
  {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
  {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
  {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
  {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
  {"stack", required_argument, NULL, OPTION_STACK},
  {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
  {"support-old-code", no_argument, NULL, OPTION_SUPPORT_OLD_CODE},
  {"thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
d261 34
a294 21
  /* getopt allows abbreviations, so we do this to stop it from treating -o
     as an abbreviation for this option */
  {"output-def", required_argument, NULL, OPTION_OUT_DEF},
  {"output-def", required_argument, NULL, OPTION_OUT_DEF},
  {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL},
  {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMBOLS},
  {"kill-at", no_argument, NULL, OPTION_KILL_ATS},
  {"add-stdcall-alias", no_argument, NULL, OPTION_STDCALL_ALIASES},
  {"enable-stdcall-fixup", no_argument, NULL, OPTION_ENABLE_STDCALL_FIXUP},
  {"disable-stdcall-fixup", no_argument, NULL, OPTION_DISABLE_STDCALL_FIXUP},
  {"out-implib", required_argument, NULL, OPTION_IMPLIB_FILENAME},
  {"warn-duplicate-exports", no_argument, NULL, OPTION_WARN_DUPLICATE_EXPORTS},
  {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
  {"enable-auto-image-base", no_argument, NULL, OPTION_ENABLE_AUTO_IMAGE_BASE},
  {"disable-auto-image-base", no_argument, NULL, OPTION_DISABLE_AUTO_IMAGE_BASE},
  {"dll-search-prefix", required_argument, NULL, OPTION_DLL_SEARCH_PREFIX},
  {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
#endif
  {NULL, no_argument, NULL, 0}
};

d297 1
a297 1
   parameters which may be input from the command line */
d338 1
d364 1
d370 4
a373 4
  fprintf (file, _("  --compat-implib                    Create backward compatible import libs;\n"));
  fprintf (file, _("                                       create __imp_<SYMBOL> as well.\n"));
  fprintf (file, _("  --enable-auto-image-base           Automatically choose image base for DLLs\n"));
  fprintf (file, _("                                       unless user specifies one\n"));
d375 13
a387 3
  fprintf (file, _("  --dll-search-prefix=<string>       When linking dynamically to a dll witout an\n"));
  fprintf (file, _("                                       importlib, use <string><basename>.dll \n"));
  fprintf (file, _("                                       in preference to lib<basename>.dll \n"));
d391 1
d398 2
a399 1
  /* Find the name and set it. */
d409 1
a409 1
  abort();
d419 1
a419 1
  static const struct 
d487 1
a487 1
	  lang_add_entry (entry, 1);
d492 1
a492 1
  
a496 1

d500 1
a500 1
     
d503 1
a503 1
  
d505 1
a505 1
  
d512 1
d519 1
a519 1
  
d530 4
a533 22

static int
gld_${EMULATION_NAME}_parse_args(argc, argv)
     int argc;
     char **argv;
{
  int longind;
  int optc;
  int prevoptind = optind;
  int prevopterr = opterr;
  int wanterror;
  static int lastoptind = -1;

  if (lastoptind != optind)
    opterr = 0;
  wanterror = opterr;

  lastoptind = optind;

  optc = getopt_long_only (argc, argv, "-", longopts, &longind);
  opterr = prevopterr;

d537 1
a537 4
      if (wanterror)
	xexit (1);
      optind =  prevoptind;
      return 0;
d550 2
a551 2
      /* PE options */
    case OPTION_HEAP: 
d554 1
a554 1
    case OPTION_STACK: 
d604 4
a607 1
      pe_dll_add_excludes (optarg);
d637 1
a637 1
      pe_dll_search_prefix = xstrdup( optarg );
d642 15
d659 1
a659 1
  return 1;
d664 1
a664 1
static unsigned long 
d687 2
a688 1
/* Use the output file to create a image base for relocatable DLLs. */
d704 1
a704 1
     names and insert the defaults. */
d727 1
a727 1
  /* Glue the assignments into the abs section */
d736 8
a743 7
      rv = lang_add_assignment (exp_assop ('=' ,init[j].symbol, exp_intop (val)));
      if (init[j].size == sizeof(short))
	*(short *)init[j].ptr = val;
      else if (init[j].size == sizeof(int))
	*(int *)init[j].ptr = val;
      else if (init[j].size == sizeof(long))
	*(long *)init[j].ptr = val;
d745 3
a747 3
      else if (init[j].size == sizeof(bfd_vma))
	*(bfd_vma *)init[j].ptr = val;
      else	abort();
d751 1
a751 1
  /* Restore the pointer. */
d753 1
a753 1
  
d780 2
a781 2
  if (! link_info.relocateable && entry_symbol != NULL)
    ldlang_add_undef (entry_symbol);
d784 7
d794 1
a794 1
static boolean
d799 3
a801 1
  int sl = strlen (string);
d805 5
a809 5
  {
    pe_undef_found_sym = h;
    return false;
  }
  return true;
d817 4
a820 1
  char *at;
a822 3
    {
      at = strchr (undef->root.string, '@@');
      if (at)
d824 59
a882 23
	/* The symbol is a stdcall symbol, so let's look for a cdecl
	   symbol with the same name and resolve to that */
	char *cname = xstrdup (undef->root.string);
	at = strchr (cname, '@@');
	*at = 0;
	sym = bfd_link_hash_lookup (link_info.hash, cname, 0, 0, 1);
	if (sym && sym->type == bfd_link_hash_defined)
	{
	  undef->type = bfd_link_hash_defined;
	  undef->u.def.value = sym->u.def.value;
	  undef->u.def.section = sym->u.def.section;
	  if (pe_enable_stdcall_fixup == -1)
	    {
	      einfo (_("Warning: resolving %s by linking to %s\n"),
		     undef->root.string, cname);
	      if (! gave_warning_message)
		{
		  gave_warning_message = 1;
		  einfo(_("Use --enable-stdcall-fixup to disable these warnings\n"));
		  einfo(_("Use --disable-stdcall-fixup to disable these fixups\n"));
		}
	    }
	}
d884 60
a943 18
      else
      {
	/* The symbol is a cdecl symbol, so we look for stdcall
	   symbols - which means scanning the whole symbol table */
	pe_undef_found_sym = 0;
	bfd_link_hash_traverse (link_info.hash, pe_undef_cdecl_match,
				(PTR) undef->root.string);
	sym = pe_undef_found_sym;
	if (sym)
	{
	  undef->type = bfd_link_hash_defined;
	  undef->u.def.value = sym->u.def.value;
	  undef->u.def.section = sym->u.def.section;
	  if (pe_enable_stdcall_fixup == -1)
	    {
	      einfo (_("Warning: resolving %s by linking to %s\n"),
		     undef->root.string, sym->root.string);
	      if (! gave_warning_message)
d945 10
a954 3
		  gave_warning_message = 1;
		  einfo(_("Use --enable-stdcall-fixup to disable these warnings\n"));
		  einfo(_("Use --disable-stdcall-fixup to disable these fixups\n"));
d956 14
a969 3
	    }
	}
      }
d974 12
d989 15
d1007 2
a1008 2
  
  if (!coff_data (output_bfd)->pe)
d1018 5
a1022 1
  pe_process_import_defs(output_bfd, &link_info);
d1024 3
d1066 1
a1066 1
       things nicely and produce a valid import table. */
d1074 1
a1074 1
	    
d1084 1
a1084 1
	    
d1097 1
a1097 1
		    
d1104 1
a1104 1
		    
d1106 1
a1106 1
 		    symsize = bfd_canonicalize_symtab (is->the_bfd, symbols);
d1112 1
a1112 1
		    
d1122 1
a1122 1
		    
d1129 1
a1129 1
			
d1131 1
a1131 1
			
d1134 1
a1134 1
			
d1138 2
a1139 2
						     false, false, true);
			    
d1143 1
a1143 1
			
d1145 1
a1145 1
			    
d1149 1
a1149 1
			
d1152 1
a1152 1
			    
d1154 1
a1154 1
			    
d1232 2
a1233 2
static void  
gld_${EMULATION_NAME}_before_allocation()
d1236 1
a1236 1
  /* Here we rummage through the found bfds to collect toc information */
d1248 1
a1248 1
  /* We have seen it all. Allocate it, and carry on */
d1258 1
a1258 1
     option?  krk@@cygnus.com */
d1272 1
a1272 1
  /* We have seen it all. Allocate it, and carry on */
d1279 1
a1279 1
   check here for .DEF files and pull them in automatically. */
d1282 1
a1282 1
saw_option(char *option)
d1285 2
a1286 1
  for (i=0; init[i].ptr; i++)
d1293 2
a1294 2
static boolean
gld_${EMULATION_NAME}_unrecognized_file(entry)
d1301 7
a1307 9
  {
    if (pe_def_file == 0)
      pe_def_file = def_file_empty ();
    def_file_parse (entry->filename, pe_def_file);
    if (pe_def_file)
    {
      int i, buflen=0, len;
      char *buf;
      for (i=0; i<pe_def_file->num_exports; i++)
d1309 11
a1319 9
	  len = strlen(pe_def_file->exports[i].internal_name);
	  if (buflen < len+2)
	    buflen = len+2;
	}
      buf = (char *) xmalloc (buflen);
      for (i=0; i<pe_def_file->num_exports; i++)
	{
	  struct bfd_link_hash_entry *h;
	  sprintf(buf, "_%s", pe_def_file->exports[i].internal_name);
d1321 1
a1321 4
	  h = bfd_link_hash_lookup (link_info.hash, buf, true, true, true);
	  if (h == (struct bfd_link_hash_entry *) NULL)
	    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	  if (h->type == bfd_link_hash_new)
d1323 13
a1335 3
	      h->type = bfd_link_hash_undefined;
	      h->u.undef.abfd = NULL;
	      bfd_link_add_undef (link_info.hash, h);
d1337 1
a1337 2
	}
      free (buf);
d1339 3
a1341 3
      /* def_file_print (stdout, pe_def_file); */
      if (pe_def_file->is_dll == 1)
	link_info.shared = 1;
d1343 10
a1352 10
      if (pe_def_file->base_address != (bfd_vma)(-1))
      {
	pe.ImageBase =
	pe_data (output_bfd)->pe_opthdr.ImageBase =
	init[IMAGEBASEOFF].value = pe_def_file->base_address;
	init[IMAGEBASEOFF].inited = 1;
	if (image_base_statement)
	  image_base_statement->exp =
	    exp_assop ('=', "__image_base__", exp_intop (pe.ImageBase));
      }
d1355 6
a1360 6
      /* Not sure if these *should* be set */
      if (pe_def_file->version_major != -1)
      {
	pe.MajorImageVersion = pe_def_file->version_major;
	pe.MinorImageVersion = pe_def_file->version_minor;
      }
d1362 16
a1377 15
      if (pe_def_file->stack_reserve != -1
	  && ! saw_option ("__size_of_stack_reserve__"))
      {
	pe.SizeOfStackReserve = pe_def_file->stack_reserve;
	if (pe_def_file->stack_commit != -1)
	  pe.SizeOfStackCommit = pe_def_file->stack_commit;
      }
      if (pe_def_file->heap_reserve != -1
	  && ! saw_option ("__size_of_heap_reserve__"))
      {
	pe.SizeOfHeapReserve = pe_def_file->heap_reserve;
	if (pe_def_file->heap_commit != -1)
	  pe.SizeOfHeapCommit = pe_def_file->heap_commit;
      }
      return true;
a1378 1
  }
d1380 1
a1380 2
  return false;
  
d1383 2
a1384 2
static boolean
gld_${EMULATION_NAME}_recognized_file(entry)
d1402 8
a1409 1
      const char *ext = entry->filename + strlen (entry->filename) - 4;
d1411 1
a1411 1
	return pe_implied_import_dll (entry->filename);
d1414 1
a1414 1
  return false;
d1425 3
a1427 2
      h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol, false, false, true);
      
d1435 1
a1435 1
	  
d1442 1
a1442 1
	  
d1444 1
a1444 1
	  
d1449 1
a1449 1
	  
d1451 2
a1452 2
	  
	  if (entry_symbol != NULL && entry_from_cmdline)
d1454 2
a1455 2
		   thumb_entry_symbol, entry_symbol);
	  entry_symbol = buffer;
d1463 5
a1467 1
  if (link_info.shared)
d1480 1
a1480 1
  
d1484 11
d1498 26
d1544 1
a1544 2
/*ARGSUSED*/
static boolean
a1558 1

d1572 7
a1578 4
      && os->bfd_section != NULL
      && ((s->flags ^ os->bfd_section->flags) & (SEC_LOAD | SEC_ALLOC)) == 0)
    {
      wild_doit (&add_child, s, os, file);
d1618 1
a1618 1
	 different loadable or allocateable characteristics.  */
d1657 1
a1657 1
	      
d1665 1
a1665 1
      
d1682 1
a1682 1
      wild_doit (&add_child, s, os, file);
d1686 1
a1686 1
	 (struct lang_output_section_phdr_list *) NULL, "*default*");
d1692 2
a1693 2
	  /* lang_leave_ouput_section_statement resets stat_ptr.  Put
	     stat_ptr back where we want it.  */
d1696 1
a1696 1
	  
d1705 1
a1705 1
      if (place != NULL)
d1710 4
a1713 1
	  if (place->os->bfd_section != NULL || place->section != NULL)
d1715 12
a1726 17
	      /* Shuffle the section to make the output file look neater.  */
	      if (place->section == NULL)
		{
#if 0
		  /* Finding the end of the list is a little tricky.  We
		     make a wild stab at it by comparing section flags.  */
		  flagword first_flags = place->os->bfd_section->flags;
		  for (pps = &place->os->bfd_section->next;
		       *pps != NULL && (*pps)->flags == first_flags;
		       pps = &(*pps)->next)
		    ;
		  place->section = pps;
#else
		  /* Put orphans after the first section on the list.  */
		  place->section = &place->os->bfd_section->next;
#endif
		}
d1728 6
a1733 2
	      /*  Unlink the section.  */
	      for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
d1735 1
a1735 1
	      *pps = snew->next;
d1738 1
a1738 2
	      snew->next = *place->section;
	      *place->section = snew;
a1739 1
	  place->section = &snew->next;	/* Save the end of this list.  */
d1741 14
a1754 1
	  if (place->stmt == NULL)
d1756 20
a1775 9
	      /* Put the new statement list right at the head.  */
	      *add.tail = place->os->header.next;
	      place->os->header.next = add.head;
	    }
	  else
	    {
	      /* Put it after the last orphan statement we added.  */
	      *add.tail = *place->stmt;
	      *place->stmt = add.head;
a1776 1
	  place->stmt = add.tail;	/* Save the end of this list.  */
d1785 1
a1785 1
	boolean found_dollar;
d1789 2
a1790 3

	found_dollar = false;
	for ( ; *pl != NULL; pl = &(*pl)->next)
d1808 1
a1808 1
		found_dollar = true;
d1817 1
a1817 1
	add_child.head->next = *pl;
d1824 1
a1824 1
  return true;
d1827 1
a1827 1
static boolean
d1837 1
a1837 1
    return false;
d1842 1
a1842 1
                             + strlen (filename) 
d1849 1
a1849 1
  /* Try "libfoo.dll.a" first (preferred explicit import library for dll's */
d1854 1
a1854 1
      /* Try "foo.dll.a" next (alternate explicit import library for dll's */
d1858 9
a1866 11
/*
   Try libfoo.a next. Normally, this would be interpreted as a static
   library, but it *could* be an import library. For backwards compatibility,
   libfoo.a needs to ==precede== libfoo.dll and foo.dll in the search,
   or sometimes errors occur when building legacy packages.

   Putting libfoo.a here means that in a failure case (i.e. the library
   -lfoo is not found) we will search for libfoo.a twice before
   giving up -- once here, and once when searching for a "static" lib.
   for a "static" lib.
*/
d1868 1
a1868 1
             take precedence over dll's) */
d1874 2
a1875 2
                {  
                  /* Try "<prefix>foo.dll" (preferred dll name, if specified) */
d1879 1
a1879 1
                      /* Try "libfoo.dll" (default preferred dll name) */
d1883 1
a1883 1
                          /* Finally, try "foo.dll" (alternate dll name) */
d1888 1
a1888 1
                              return false;
d1893 2
a1894 2
              else /* pe_dll_search_prefix not specified */
#endif		
d1896 1
a1896 1
                  /* Try "libfoo.dll" (preferred dll name) */
d1900 1
a1900 1
                      /* Finally, try "foo.dll" (alternate dll name) */
d1905 1
a1905 1
                          return false;
d1915 1
a1915 1
  return true;
d1927 1
a1927 1
gld_${EMULATION_NAME}_get_script(isfile)
d1935 1
a1935 1
{			     
d1938 1
a1938 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1941 10
a1950 10
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c
d1955 1
a1955 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = 
d1969 2
a1970 2
  gld_${EMULATION_NAME}_finish, /* finish */
  NULL, /* create output section statements */
d1974 3
a1976 1
  gld_${EMULATION_NAME}_parse_args,
d1980 2
a1981 1
  gld_${EMULATION_NAME}_find_potential_libraries
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@a2 5
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
d7 1
a7 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d10 13
a22 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 2
a30 14
   the correct entry point by default. */

#define TARGET_IS_${EMULATION_NAME}

/* Do this before including bfd.h, so we prototype the right functions.  */
#ifdef TARGET_IS_arm_epoc_pe
#define bfd_arm_pe_allocate_interworking_sections \
	bfd_arm_epoc_pe_allocate_interworking_sections
#define bfd_arm_pe_get_bfd_for_interworking \
	bfd_arm_epoc_pe_get_bfd_for_interworking
#define bfd_arm_pe_process_before_allocation \
	bfd_arm_epoc_pe_process_before_allocation
#endif

d38 1
a42 1
#include <ldgram.h>
d55 1
a55 1
#include <ctype.h>
d90 9
d104 1
a104 3
static asection *output_prev_sec_find
  PARAMS ((lang_output_section_statement_type *));
static bfd_boolean gld_${EMULATION_NAME}_place_orphan
d107 1
d109 1
a109 1
static bfd_boolean gld_${EMULATION_NAME}_open_dynamic_archive
a110 25
static void gld${EMULATION_NAME}_add_options
  PARAMS ((int, char **, int, struct option **, int, struct option **));
static bfd_boolean gld${EMULATION_NAME}_handle_option PARAMS ((int));
static void gld_${EMULATION_NAME}_list_options PARAMS ((FILE *));
static void set_pe_name PARAMS ((char *, long));
static void set_pe_subsystem PARAMS ((void));
static void set_pe_value PARAMS ((char *));
static void set_pe_stack_heap PARAMS ((char *, char *));

#ifdef DLL_SUPPORT
static bfd_boolean pe_undef_cdecl_match
  PARAMS ((struct bfd_link_hash_entry *, PTR));
static void pe_fixup_stdcalls PARAMS ((void));
static int make_import_fixup PARAMS ((arelent *, asection *));
static void pe_find_data_imports PARAMS ((void));
#endif

static bfd_boolean pr_sym PARAMS ((struct bfd_hash_entry *, PTR));
static bfd_boolean gld_${EMULATION_NAME}_unrecognized_file
  PARAMS ((lang_input_statement_type *));
static bfd_boolean gld_${EMULATION_NAME}_recognized_file
  PARAMS ((lang_input_statement_type *));
static int gld_${EMULATION_NAME}_find_potential_libraries
  PARAMS ((char *, lang_input_statement_type *));

d119 1
a119 1
static int pe_enable_stdcall_fixup = -1; /* 0=disable 1=enable.  */
a130 9
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_${ARCH};
d132 1
a133 1
  config.dynamic_link = TRUE;
a134 2
  link_info.pei386_auto_import = -1;
  link_info.pei386_runtime_pseudo_reloc = FALSE;
d148 1
a148 1
/* Used for setting flags in the PE header.  */
a178 8
#define OPTION_DLL_ENABLE_AUTO_IMPORT	(OPTION_NO_DEFAULT_EXCLUDES + 1)
#define OPTION_DLL_DISABLE_AUTO_IMPORT	(OPTION_DLL_ENABLE_AUTO_IMPORT + 1)
#define OPTION_ENABLE_EXTRA_PE_DEBUG	(OPTION_DLL_DISABLE_AUTO_IMPORT + 1)
#define OPTION_EXCLUDE_LIBS		(OPTION_ENABLE_EXTRA_PE_DEBUG + 1)
#define OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC	\
					(OPTION_EXCLUDE_LIBS + 1)
#define OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC	\
					(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC + 1)
d180 18
a197 27
static void
gld${EMULATION_NAME}_add_options (ns, shortopts, nl, longopts, nrl, really_longopts)
     int ns ATTRIBUTE_UNUSED;
     char **shortopts ATTRIBUTE_UNUSED;
     int nl;
     struct option **longopts;
     int nrl ATTRIBUTE_UNUSED;
     struct option **really_longopts ATTRIBUTE_UNUSED;
{
  static const struct option xtra_long[] = {
    /* PE options */
    {"base-file", required_argument, NULL, OPTION_BASE_FILE},
    {"dll", no_argument, NULL, OPTION_DLL},
    {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
    {"heap", required_argument, NULL, OPTION_HEAP},
    {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
    {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
    {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
    {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
    {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
    {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
    {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
    {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
    {"stack", required_argument, NULL, OPTION_STACK},
    {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
    {"support-old-code", no_argument, NULL, OPTION_SUPPORT_OLD_CODE},
    {"thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
d199 21
a219 34
    /* getopt allows abbreviations, so we do this to stop it from treating -o
       as an abbreviation for this option */
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL},
    {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMBOLS},
    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
    {"kill-at", no_argument, NULL, OPTION_KILL_ATS},
    {"add-stdcall-alias", no_argument, NULL, OPTION_STDCALL_ALIASES},
    {"enable-stdcall-fixup", no_argument, NULL, OPTION_ENABLE_STDCALL_FIXUP},
    {"disable-stdcall-fixup", no_argument, NULL, OPTION_DISABLE_STDCALL_FIXUP},
    {"out-implib", required_argument, NULL, OPTION_IMPLIB_FILENAME},
    {"warn-duplicate-exports", no_argument, NULL, OPTION_WARN_DUPLICATE_EXPORTS},
    /* getopt() allows abbreviations, so we do this to stop it from
       treating -c as an abbreviation for these --compat-implib.  */
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"enable-auto-image-base", no_argument, NULL, OPTION_ENABLE_AUTO_IMAGE_BASE},
    {"disable-auto-image-base", no_argument, NULL, OPTION_DISABLE_AUTO_IMAGE_BASE},
    {"dll-search-prefix", required_argument, NULL, OPTION_DLL_SEARCH_PREFIX},
    {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
    {"enable-auto-import", no_argument, NULL, OPTION_DLL_ENABLE_AUTO_IMPORT},
    {"disable-auto-import", no_argument, NULL, OPTION_DLL_DISABLE_AUTO_IMPORT},
    {"enable-extra-pe-debug", no_argument, NULL, OPTION_ENABLE_EXTRA_PE_DEBUG},
    {"enable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC},
    {"disable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC},
#endif
    {NULL, no_argument, NULL, 0}
  };

  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}
d222 1
a222 1
   parameters which may be input from the command line.  */
a262 1

a287 1
  fprintf (file, _("  --exclude-libs lib,lib,...         Exclude libraries from automatic export\n"));
d293 4
a296 4
  fprintf (file, _("  --compat-implib                    Create backward compatible import libs;\n\
                                       create __imp_<SYMBOL> as well.\n"));
  fprintf (file, _("  --enable-auto-image-base           Automatically choose image base for DLLs\n\
                                       unless user specifies one\n"));
d298 3
a300 13
  fprintf (file, _("  --dll-search-prefix=<string>       When linking dynamically to a dll without\n\
                                       an importlib, use <string><basename>.dll\n\
                                       in preference to lib<basename>.dll \n"));
  fprintf (file, _("  --enable-auto-import               Do sophistcated linking of _sym to\n\
                                       __imp_sym for DATA references\n"));
  fprintf (file, _("  --disable-auto-import              Do not auto-import DATA items from DLLs\n"));
  fprintf (file, _("  --enable-runtime-pseudo-reloc      Work around auto-import limitations by\n\
                                       adding pseudo-relocations resolved at\n\
                                       runtime.\n"));
  fprintf (file, _("  --disable-runtime-pseudo-reloc     Do not add runtime pseudo-relocations for\n\
                                       auto-imported DATA.\n"));
  fprintf (file, _("  --enable-extra-pe-debug            Enable verbose debug output when building\n\
                                       or linking to DLLs (esp. auto-import)\n"));
a303 1

d310 1
a310 2

  /* Find the name and set it.  */
d320 1
a320 1
  abort ();
d330 1
a330 1
  static const struct
d398 1
a398 1
	  lang_add_entry (entry, 0);
d403 1
a403 1

d408 1
d412 1
a412 1

d415 1
a415 1

d417 1
a417 1

a423 1

d430 1
a430 1

d441 22
a462 4
static bfd_boolean
gld${EMULATION_NAME}_handle_option (optc)
     int optc;
{
d466 4
a469 1
      return FALSE;
d482 2
a483 2
      /* PE options.  */
    case OPTION_HEAP:
d486 1
a486 1
    case OPTION_STACK:
d536 1
a536 4
      pe_dll_add_excludes (optarg, 0);
      break;
    case OPTION_EXCLUDE_LIBS:
      pe_dll_add_excludes (optarg, 1);
d566 1
a566 1
      pe_dll_search_prefix = xstrdup (optarg);
a570 15
    case OPTION_DLL_ENABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 1;
      break;
    case OPTION_DLL_DISABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 0;
      break;
    case OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 1;
      break;
    case OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 0;
      break;
    case OPTION_ENABLE_EXTRA_PE_DEBUG:
      pe_dll_extra_pe_debug = 1;
      break;
d573 1
a573 1
  return TRUE;
d578 1
a578 1
static unsigned long
d601 1
a601 2
/* Use the output file to create a image base for relocatable DLLs.  */

d617 1
a617 1
     names and insert the defaults.  */
d640 1
a640 1
  /* Glue the assignments into the abs section.  */
d649 7
a655 8
      rv = lang_add_assignment (exp_assop ('=', init[j].symbol,
					   exp_intop (val)));
      if (init[j].size == sizeof (short))
	*(short *) init[j].ptr = val;
      else if (init[j].size == sizeof (int))
	*(int *) init[j].ptr = val;
      else if (init[j].size == sizeof (long))
	*(long *) init[j].ptr = val;
d657 3
a659 3
      else if (init[j].size == sizeof (bfd_vma))
	*(bfd_vma *) init[j].ptr = val;
      else	abort ();
d663 1
a663 1
  /* Restore the pointer.  */
d665 1
a665 1

d692 2
a693 2
  if (! link_info.relocateable && entry_symbol.name != NULL)
    ldlang_add_undef (entry_symbol.name);
a695 7
/* pe-dll.c directly accesses pe_data_import_dll,
   so it must be defined outside of #ifdef DLL_SUPPORT.
   Note - this variable is deliberately not initialised.
   This allows it to be treated as a common varaible, and only
   exist in one incarnation in a multiple target enabled linker.  */
char * pe_data_import_dll;

d699 1
a699 1
static bfd_boolean
d704 1
a704 3
  int sl;

  sl = strlen (string); /* Silence compiler warning.  */
d708 5
a712 5
    {
      pe_undef_found_sym = h;
      return FALSE;
    }
  return TRUE;
d720 1
a720 4

  if (pe_dll_extra_pe_debug)
    printf ("%s\n", __FUNCTION__);

d723 3
d727 23
a749 59
	char* at = strchr (undef->root.string, '@@');
	int lead_at = (*undef->root.string == '@@');
	/* For now, don't try to fixup fastcall symbols.  */

	if (at && !lead_at)
	  {
	    /* The symbol is a stdcall symbol, so let's look for a
	       cdecl symbol with the same name and resolve to that.  */
	    char *cname = xstrdup (undef->root.string /* + lead_at */);
	    at = strchr (cname, '@@');
	    *at = 0;
	    sym = bfd_link_hash_lookup (link_info.hash, cname, 0, 0, 1);

	    if (sym && sym->type == bfd_link_hash_defined)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pe_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, cname);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
	else
	  {
	    /* The symbol is a cdecl symbol, so we look for stdcall
	       symbols - which means scanning the whole symbol table.  */
	    pe_undef_found_sym = 0;
	    bfd_link_hash_traverse (link_info.hash, pe_undef_cdecl_match,
				    (PTR) undef->root.string);
	    sym = pe_undef_found_sym;
	    if (sym)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pe_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, sym->root.string);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
d751 18
a768 60
}

static int
make_import_fixup (rel, s)
  arelent *rel;
  asection *s;
{
  struct symbol_cache_entry *sym = *rel->sym_ptr_ptr;
  int addend = 0;

  if (pe_dll_extra_pe_debug)
    printf ("arelent: %s@@%#lx: add=%li\n", sym->name,
	    (long) rel->address, (long) rel->addend);

  if (! bfd_get_section_contents (s->owner, s, &addend, rel->address, sizeof (addend)))
    einfo (_("%C: Cannot get section contents - auto-import exception\n"),
	   s->owner, s, rel->address);

  pe_create_import_fixup (rel, s, addend);

  return 1;
}

static void
pe_find_data_imports ()
{
  struct bfd_link_hash_entry *undef, *sym;

  if (link_info.pei386_auto_import == 0)
    return;

  for (undef = link_info.hash->undefs; undef; undef=undef->next)
    {
      if (undef->type == bfd_link_hash_undefined)
        {
          /* C++ symbols are *long*.  */
          char buf[4096];

	  if (pe_dll_extra_pe_debug)
	    printf ("%s:%s\n", __FUNCTION__, undef->root.string);

          sprintf (buf, "__imp_%s", undef->root.string);

          sym = bfd_link_hash_lookup (link_info.hash, buf, 0, 0, 1);

          if (sym && sym->type == bfd_link_hash_defined)
            {
	      bfd *b = sym->u.def.section->owner;
	      asymbol **symbols;
	      int nsyms, symsize, i;

	      if (link_info.pei386_auto_import == -1)
		info_msg (_("Info: resolving %s by linking to %s (auto-import)\n"),
			  undef->root.string, buf);

	      symsize = bfd_get_symtab_upper_bound (b);
	      symbols = (asymbol **) xmalloc (symsize);
	      nsyms = bfd_canonicalize_symtab (b, symbols);

	      for (i = 0; i < nsyms; i++)
d770 3
a772 10
		  if (memcmp (symbols[i]->name, "__head_",
			      sizeof ("__head_") - 1))
		    continue;

		  if (pe_dll_extra_pe_debug)
		    printf ("->%s\n", symbols[i]->name);

		  pe_data_import_dll = (char*) (symbols[i]->name +
						sizeof ("__head_") - 1);
		  break;
d774 3
a776 14

	      pe_walk_relocs_of_symbol (&link_info, undef->root.string,
					make_import_fixup);

	      /* Let's differentiate it somehow from defined.  */
	      undef->type = bfd_link_hash_defweak;
	      /* We replace original name with __imp_ prefixed, this
		 1) may trash memory 2) leads to duplicate symbol generation.
		 Still, IMHO it's better than having name poluted.  */
	      undef->root.string = sym->root.string;
	      undef->u.def.value = sym->u.def.value;
	      undef->u.def.section = sym->u.def.section;
            }
        }
a780 12
static bfd_boolean
pr_sym (h, string)
  struct bfd_hash_entry *h;
  PTR string ATTRIBUTE_UNUSED;
{
  if (pe_dll_extra_pe_debug)
    printf ("+%s\n",h->string);

  return TRUE;
}


a783 15
  if (pe_dll_extra_pe_debug)
    {
      bfd *a;
      struct bfd_link_hash_entry *sym;

      printf ("%s()\n", __FUNCTION__);

      for (sym = link_info.hash->undefs; sym; sym=sym->next)
        printf ("-%s\n", sym->root.string);
      bfd_hash_traverse (&link_info.hash->table, pr_sym,NULL);

      for (a = link_info.input_bfds; a; a = a->link_next)
	printf ("*%s\n",a->filename);
    }

d787 2
a788 2

  if (coff_data (output_bfd) == NULL || coff_data (output_bfd)->pe == 0)
d798 1
a798 5
  pe_process_import_defs (output_bfd, & link_info);

  pe_find_data_imports ();

#if ! (defined (TARGET_IS_i386pe) || defined (TARGET_IS_armpe))
a799 3
#else
  if (!link_info.relocateable)
#endif
d839 1
a839 1
       things nicely and produce a valid import table.  */
d847 1
a847 1

d857 1
a857 1

d870 1
a870 1

d877 1
a877 1

d879 1
a879 1
		    symsize = bfd_canonicalize_symtab (is->the_bfd, symbols);
d885 1
a885 1

d895 1
a895 1

d902 1
a902 1

d904 1
a904 1

d907 1
a907 1

d911 2
a912 2
						     FALSE, FALSE, TRUE);

d916 1
a916 1

d918 1
a918 1

d922 1
a922 1

d925 1
a925 1

d927 1
a927 1

d1005 2
a1006 2
static void
gld_${EMULATION_NAME}_before_allocation ()
d1009 1
a1009 1
  /* Here we rummage through the found bfds to collect toc information.  */
d1021 1
a1021 1
  /* We have seen it all. Allocate it, and carry on.  */
d1031 1
a1031 1
     option?  krk@@cygnus.com.  */
d1045 1
a1045 1
  /* We have seen it all. Allocate it, and carry on.  */
d1052 1
a1052 1
   check here for .DEF files and pull them in automatically.  */
d1055 1
a1055 1
saw_option (char * option)
d1058 1
a1058 2

  for (i = 0; init[i].ptr; i++)
d1065 2
a1066 2
static bfd_boolean
gld_${EMULATION_NAME}_unrecognized_file (entry)
d1073 16
a1088 7
    {
      if (pe_def_file == 0)
	pe_def_file = def_file_empty ();

      def_file_parse (entry->filename, pe_def_file);

      if (pe_def_file)
d1090 2
a1091 2
	  int i, buflen=0, len;
	  char *buf;
d1093 4
a1096 1
	  for (i = 0; i < pe_def_file->num_exports; i++)
d1098 3
a1100 3
	      len = strlen (pe_def_file->exports[i].internal_name);
	      if (buflen < len + 2)
		buflen = len + 2;
d1102 2
d1105 3
a1107 1
	  buf = (char *) xmalloc (buflen);
d1109 10
a1118 32
	  for (i = 0; i < pe_def_file->num_exports; i++)
	    {
	      struct bfd_link_hash_entry *h;

	      sprintf (buf, "_%s", pe_def_file->exports[i].internal_name);

	      h = bfd_link_hash_lookup (link_info.hash, buf, TRUE, TRUE, TRUE);
	      if (h == (struct bfd_link_hash_entry *) NULL)
		einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	      if (h->type == bfd_link_hash_new)
		{
		  h->type = bfd_link_hash_undefined;
		  h->u.undef.abfd = NULL;
		  bfd_link_add_undef (link_info.hash, h);
		}
	    }
	  free (buf);

	  /* def_file_print (stdout, pe_def_file); */
	  if (pe_def_file->is_dll == 1)
	    link_info.shared = 1;

	  if (pe_def_file->base_address != (bfd_vma)(-1))
	    {
	      pe.ImageBase =
		pe_data (output_bfd)->pe_opthdr.ImageBase =
		init[IMAGEBASEOFF].value = pe_def_file->base_address;
	      init[IMAGEBASEOFF].inited = 1;
	      if (image_base_statement)
		image_base_statement->exp =
		  exp_assop ('=', "__image_base__", exp_intop (pe.ImageBase));
	    }
d1121 6
a1126 6
	  /* Not sure if these *should* be set.  */
	  if (pe_def_file->version_major != -1)
	    {
	      pe.MajorImageVersion = pe_def_file->version_major;
	      pe.MinorImageVersion = pe_def_file->version_minor;
	    }
d1128 15
a1142 16
	  if (pe_def_file->stack_reserve != -1
	      && ! saw_option ("__size_of_stack_reserve__"))
	    {
	      pe.SizeOfStackReserve = pe_def_file->stack_reserve;
	      if (pe_def_file->stack_commit != -1)
		pe.SizeOfStackCommit = pe_def_file->stack_commit;
	    }
	  if (pe_def_file->heap_reserve != -1
	      && ! saw_option ("__size_of_heap_reserve__"))
	    {
	      pe.SizeOfHeapReserve = pe_def_file->heap_reserve;
	      if (pe_def_file->heap_commit != -1)
		pe.SizeOfHeapCommit = pe_def_file->heap_commit;
	    }
	  return TRUE;
	}
d1144 1
d1146 2
a1147 1
  return FALSE;
d1150 2
a1151 2
static bfd_boolean
gld_${EMULATION_NAME}_recognized_file (entry)
d1169 1
a1169 8
      char fbuf[LD_PATHMAX + 1];
      const char *ext;

      if (REALPATH (entry->filename, fbuf) == NULL)
	strncpy (fbuf, entry->filename, sizeof (fbuf));

      ext = fbuf + strlen (fbuf) - 4;

d1171 1
a1171 1
	return pe_implied_import_dll (fbuf);
d1174 1
a1174 1
  return FALSE;
d1185 2
a1186 3
      h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,
				FALSE, FALSE, TRUE);

d1194 1
a1194 1

d1201 1
a1201 1

d1203 1
a1203 1

d1208 1
a1208 1

d1210 2
a1211 2

	  if (entry_symbol.name != NULL && entry_from_cmdline)
d1213 2
a1214 2
		   thumb_entry_symbol, entry_symbol.name);
	  entry_symbol.name = buffer;
d1222 1
a1222 5
  if (link_info.shared
#if !defined(TARGET_IS_shpe) && !defined(TARGET_IS_mipspe)
    || (!link_info.relocateable && pe_def_file->num_exports != 0)
#endif
    )
d1235 1
a1235 1

a1238 11

  /* I don't know where .idata gets set as code, but it shouldn't be.  */
  {
    asection *asec = bfd_get_section_by_name (output_bfd, ".idata");

    if (asec)
      {
        asec->flags &= ~SEC_CODE;
        asec->flags |= SEC_DATA;
      }
  }
a1241 26
/* Find the last output section before given output statement.
   Used by place_orphan.  */

static asection *
output_prev_sec_find (os)
     lang_output_section_statement_type *os;
{
  asection *s = (asection *) NULL;
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (lookup == os)
	return s;

      if (lookup->bfd_section != NULL && lookup->bfd_section->owner != NULL)
	s = lookup->bfd_section;
    }

  return NULL;
}

d1262 2
a1263 1
static bfd_boolean
d1278 1
d1292 4
a1295 7
      && (os->bfd_section == NULL
	  || ((s->flags ^ os->bfd_section->flags)
	      & (SEC_LOAD | SEC_ALLOC)) == 0))
    {
      /* We already have an output section statement with this
	 name, and its bfd section, if any, has compatible flags.  */
      lang_add_section (&add_child, s, os, file);
d1335 1
a1335 1
	 different loadable or allocatable characteristics.  */
d1374 1
a1374 1

d1382 1
a1382 1

d1399 1
a1399 1
      lang_add_section (&add_child, s, os, file);
d1403 1
a1403 1
	 (struct lang_output_section_phdr_list *) NULL, NULL);
d1409 2
a1410 2
	  /* lang_leave_ouput_section_statement resets stat_ptr.
	     Put stat_ptr back where we want it.  */
d1413 1
a1413 1

d1422 1
a1422 1
      if (place != NULL && os->bfd_section != NULL)
d1427 1
a1427 4

	  /* Shuffle the bfd section list to make the output file look
	     neater.  This is really only cosmetic.  */
	  if (place->section == NULL)
d1429 17
a1445 1
	      asection *bfd_section = place->os->bfd_section;
d1447 4
a1450 6
	      /* If the output statement hasn't been used to place
		 any input sections (and thus doesn't have an output
		 bfd_section), look for the closest prior output statement
		 having an output section.  */
	      if (bfd_section == NULL)
		bfd_section = output_prev_sec_find (place->os);
d1452 3
a1454 2
	      if (bfd_section != NULL && bfd_section != snew)
		place->section = &bfd_section->next;
d1456 1
d1458 1
a1458 1
	  if (place->section != NULL)
d1460 3
a1462 9
	      /* Unlink the section.  */
	      for (pps = &output_bfd->sections;
		   *pps != snew;
		   pps = &(*pps)->next)
		;
	      bfd_section_list_remove (output_bfd, pps);

	      /* Now tack it on to the "place->os" section list.  */
	      bfd_section_list_insert (output_bfd, place->section, snew);
d1464 1
a1464 15

	  /* Save the end of this list.  Further ophans of this type will
	     follow the one we've just added.  */
	  place->section = &snew->next;

	  /* The following is non-cosmetic.  We try to put the output
	     statements in some sort of reasonable order here, because
	     they determine the final load addresses of the orphan
	     sections.  In addition, placing output statements in the
	     wrong order may require extra segments.  For instance,
	     given a typical situation of all read-only sections placed
	     in one segment and following that a segment containing all
	     the read-write sections, we wouldn't want to place an orphan
	     read/write section before or amongst the read-only ones.  */
	  if (add.head != NULL)
d1466 3
a1468 20
	      if (place->stmt == NULL)
		{
		  /* Put the new statement list right at the head.  */
		  *add.tail = place->os->header.next;
		  place->os->header.next = add.head;
		}
	      else
		{
		  /* Put it after the last orphan statement we added.  */
		  *add.tail = *place->stmt;
		  *place->stmt = add.head;
		}

	      /* Fix the global list pointer if we happened to tack our
		 new list at the tail.  */
	      if (*old->tail == add.head)
		old->tail = add.tail;

	      /* Save the end of this list.  */
	      place->stmt = add.tail;
d1470 1
d1479 1
a1479 1
	bfd_boolean found_dollar;
d1483 3
a1485 2
	found_dollar = FALSE;
	for ( ; *pl != NULL; pl = &(*pl)->header.next)
d1503 1
a1503 1
		found_dollar = TRUE;
d1512 1
a1512 1
	add_child.head->header.next = *pl;
d1519 1
a1519 1
  return TRUE;
d1522 1
a1522 1
static bfd_boolean
d1532 1
a1532 1
    return FALSE;
d1537 1
a1537 1
                             + strlen (filename)
d1544 1
a1544 1
  /* Try "libfoo.dll.a" first (preferred explicit import library for dll's.  */
d1549 1
a1549 1
      /* Try "foo.dll.a" next (alternate explicit import library for dll's.  */
d1553 11
a1563 9
	  /* Try libfoo.a next. Normally, this would be interpreted as a static
	     library, but it *could* be an import library. For backwards compatibility,
	     libfoo.a needs to ==precede== libfoo.dll and foo.dll in the search,
	     or sometimes errors occur when building legacy packages.

	     Putting libfoo.a here means that in a failure case (i.e. the library
	     -lfoo is not found) we will search for libfoo.a twice before
	     giving up -- once here, and once when searching for a "static" lib.
	     for a "static" lib.  */
d1565 1
a1565 1
             take precedence over dll's).  */
d1571 2
a1572 2
                {
                  /* Try "<prefix>foo.dll" (preferred dll name, if specified).  */
d1576 1
a1576 1
                      /* Try "libfoo.dll" (default preferred dll name).  */
d1580 1
a1580 1
                          /* Finally, try "foo.dll" (alternate dll name).  */
d1585 1
a1585 1
                              return FALSE;
d1590 2
a1591 2
              else /* pe_dll_search_prefix not specified.  */
#endif
d1593 1
a1593 1
                  /* Try "libfoo.dll" (preferred dll name).  */
d1597 1
a1597 1
                      /* Finally, try "foo.dll" (alternate dll name).  */
d1602 1
a1602 1
                          return FALSE;
d1612 1
a1612 1
  return TRUE;
d1624 1
a1624 1
gld_${EMULATION_NAME}_get_script (isfile)
d1632 1
a1632 1
{
d1635 1
a1635 1
  if (link_info.relocateable && config.build_constructors)
d1638 10
a1647 10
sed $sc ldscripts/${EMULATION_NAME}.xu                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                 >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                 >> e${EMULATION_NAME}.c
echo '  ; else return'                                 >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
echo '; }'                                             >> e${EMULATION_NAME}.c
d1652 1
a1652 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
d1666 2
a1667 2
  gld_${EMULATION_NAME}_finish,
  NULL, /* Create output section statements.  */
d1671 1
a1671 3
  NULL, /* parse_args */
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
d1675 1
a1675 2
  gld_${EMULATION_NAME}_find_potential_libraries,
  NULL	/* new_vers_pattern.  */
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d12 1
a12 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d71 2
a72 1
#include "safe-ctype.h"
d107 38
d163 1
a163 1
gld_${EMULATION_NAME}_before_parse (void)
d165 9
a173 1
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
d183 1
a183 1
  lang_add_entry ("WinMainCRTStartup", FALSE);
d185 1
a185 1
  lang_add_entry ("_WinMainCRTStartup", FALSE);
d205 2
a206 2
#define OPTION_STACK			(OPTION_SECTION_ALIGNMENT + 1)
#define OPTION_SUBSYSTEM		(OPTION_STACK + 1)
d234 7
a240 4
gld${EMULATION_NAME}_add_options
  (int ns ATTRIBUTE_UNUSED, char **shortopts ATTRIBUTE_UNUSED, int nl,
    struct option **longopts, int nrl ATTRIBUTE_UNUSED,
    struct option **really_longopts ATTRIBUTE_UNUSED)
d340 2
a341 1
gld_${EMULATION_NAME}_list_options (FILE *file)
d393 3
a395 1
set_pe_name (char *name, long val)
d414 1
a414 1
set_pe_subsystem (void)
d487 1
a487 1
	  lang_add_entry (entry, TRUE);
d498 3
a500 1
set_pe_value (char *name)
d514 3
a516 1
set_pe_stack_heap (char *resname, char *comname)
d531 2
a532 1
gld${EMULATION_NAME}_handle_option (int optc)
d540 1
a540 1
      link_info.base_file = fopen (optarg, FOPEN_WB);
d701 1
a701 1
gld_${EMULATION_NAME}_set_symbols (void)
d710 1
a710 1
      if (link_info.relocatable)
d723 2
a724 2
  /* Don't do any symbol assignments if this is a relocatable link.  */
  if (link_info.relocatable)
d765 1
a765 1
gld_${EMULATION_NAME}_after_parse (void)
d780 1
a780 1
  if (! link_info.relocatable && entry_symbol.name != NULL)
d795 3
a797 1
pe_undef_cdecl_match (struct bfd_link_hash_entry *h, void *inf)
a799 1
  char *string = inf;
d801 1
a801 1
  sl = strlen (string);
d813 1
a813 1
pe_fixup_stdcalls (void)
d821 1
a821 1
  for (undef = link_info.hash->undefs; undef; undef=undef->und_next)
d862 1
a862 1
				    (char *) undef->root.string);
d887 3
a889 1
make_import_fixup (arelent *rel, asection *s)
d891 1
a891 1
  struct bfd_symbol *sym = *rel->sym_ptr_ptr;
d908 1
a908 1
pe_find_data_imports (void)
d915 1
a915 1
  for (undef = link_info.hash->undefs; undef; undef=undef->und_next)
d972 1
d975 3
a977 1
pr_sym (struct bfd_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
d980 1
a980 1
    printf ("+%s\n", h->string);
a983 1
#endif /* DLL_SUPPORT */
d987 1
a987 1
gld_${EMULATION_NAME}_after_open (void)
a988 1
#ifdef DLL_SUPPORT
d996 1
a996 1
      for (sym = link_info.hash->undefs; sym; sym=sym->und_next)
d998 1
a998 1
      bfd_hash_traverse (&link_info.hash->table, pr_sym, NULL);
a1002 1
#endif
d1025 1
a1025 1
  if (!link_info.relocatable)
d1125 1
a1125 1
			struct bfd_symbol *s;
a1170 1
    lang_input_statement_type *is3;
a1184 1
	    char *pnt;
a1185 1

d1190 3
a1192 17

		for (is3 = is;
		     is3 && is3->the_bfd->my_archive == arch;
		     is3 = (lang_input_statement_type *) is3->next)
		  {
                    /* A MS dynamic import library can also contain static
		       members, so look for the first element with a .dll
		       extension, and use that for the remainder of the
		       comparisons.  */
		    pnt = strrchr (is3->the_bfd->filename, '.');
		    if (pnt != NULL && strcmp (pnt, ".dll") == 0)
		      break;
		  }

		if (is3 == NULL)
		  is_ms_arch = 0;
		else
d1194 2
a1195 19
		    /* OK, found one.  Now look to see if the remaining
		       (dynamic import) members use the same name.  */
		    for (is2 = is;
			 is2 && is2->the_bfd->my_archive == arch;
			 is2 = (lang_input_statement_type *) is2->next)
		      {
			/* Skip static members, ie anything with a .obj
			   extension.  */
			pnt = strrchr (is2->the_bfd->filename, '.');
			if (pnt != NULL && strcmp (pnt, ".obj") == 0)
			  continue;

			if (strcmp (is3->the_bfd->filename,
				    is2->the_bfd->filename))
			  {
			    is_ms_arch = 0;
			    break;
			  }
		      }
d1199 1
a1199 6
	    /* This fragment might have come from an .obj file in a Microsoft
	       import, and not an actual import record. If this is the case,
	       then leave the filename alone.  */
	    pnt = strrchr (is->the_bfd->filename, '.');

	    if (is_ms_arch && (strcmp (pnt, ".dll") == 0))
d1233 1
a1233 1
gld_${EMULATION_NAME}_before_allocation (void)
d1282 1
a1282 1
saw_option (char *option)
d1294 2
a1295 1
gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)
d1384 2
a1385 1
gld_${EMULATION_NAME}_recognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)
d1418 1
a1418 1
gld_${EMULATION_NAME}_finish (void)
d1465 1
a1465 1
    || (!link_info.relocatable && pe_def_file->num_exports != 0)
d1502 2
a1503 1
output_prev_sec_find (lang_output_section_statement_type *os)
d1545 3
a1547 1
gld_${EMULATION_NAME}_place_orphan (lang_input_statement_type *file, asection *s)
d1560 1
a1560 1
  if (!link_info.relocatable)
d1651 1
a1651 1
	    if (! ISALNUM ((unsigned char) *ps) && *ps != '_')
d1666 1
a1666 1
      if (link_info.relocatable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
d1677 1
d1828 4
a1831 3
gld_${EMULATION_NAME}_open_dynamic_archive
  (const char *arch ATTRIBUTE_UNUSED, search_dirs_type *search,
   lang_input_statement_type *entry)
d1919 3
a1921 2
gld_${EMULATION_NAME}_find_potential_libraries
  (char *name, lang_input_statement_type *entry)
d1927 2
a1928 1
gld_${EMULATION_NAME}_get_script (int *isfile)
d1938 1
a1938 1
  if (link_info.relocatable && config.build_constructors)
d1942 1
a1942 1
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@a2 5
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
d7 1
a7 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d10 13
a22 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 2
a30 14
   the correct entry point by default. */

#define TARGET_IS_${EMULATION_NAME}

/* Do this before including bfd.h, so we prototype the right functions.  */
#ifdef TARGET_IS_arm_epoc_pe
#define bfd_arm_pe_allocate_interworking_sections \
	bfd_arm_epoc_pe_allocate_interworking_sections
#define bfd_arm_pe_get_bfd_for_interworking \
	bfd_arm_epoc_pe_get_bfd_for_interworking
#define bfd_arm_pe_process_before_allocation \
	bfd_arm_epoc_pe_process_before_allocation
#endif

d38 1
a42 1
#include <ldgram.h>
d55 1
a55 1
#include <ctype.h>
d90 9
d104 1
a104 3
static asection *output_prev_sec_find
  PARAMS ((lang_output_section_statement_type *));
static bfd_boolean gld_${EMULATION_NAME}_place_orphan
d107 1
d109 1
a109 1
static bfd_boolean gld_${EMULATION_NAME}_open_dynamic_archive
a110 25
static void gld${EMULATION_NAME}_add_options
  PARAMS ((int, char **, int, struct option **, int, struct option **));
static bfd_boolean gld${EMULATION_NAME}_handle_option PARAMS ((int));
static void gld_${EMULATION_NAME}_list_options PARAMS ((FILE *));
static void set_pe_name PARAMS ((char *, long));
static void set_pe_subsystem PARAMS ((void));
static void set_pe_value PARAMS ((char *));
static void set_pe_stack_heap PARAMS ((char *, char *));

#ifdef DLL_SUPPORT
static bfd_boolean pe_undef_cdecl_match
  PARAMS ((struct bfd_link_hash_entry *, PTR));
static void pe_fixup_stdcalls PARAMS ((void));
static int make_import_fixup PARAMS ((arelent *, asection *));
static void pe_find_data_imports PARAMS ((void));
#endif

static bfd_boolean pr_sym PARAMS ((struct bfd_hash_entry *, PTR));
static bfd_boolean gld_${EMULATION_NAME}_unrecognized_file
  PARAMS ((lang_input_statement_type *));
static bfd_boolean gld_${EMULATION_NAME}_recognized_file
  PARAMS ((lang_input_statement_type *));
static int gld_${EMULATION_NAME}_find_potential_libraries
  PARAMS ((char *, lang_input_statement_type *));

d119 1
a119 1
static int pe_enable_stdcall_fixup = -1; /* 0=disable 1=enable.  */
a130 9
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_${ARCH};
d132 1
a133 1
  config.dynamic_link = TRUE;
a134 2
  link_info.pei386_auto_import = -1;
  link_info.pei386_runtime_pseudo_reloc = FALSE;
d148 1
a148 1
/* Used for setting flags in the PE header.  */
a178 8
#define OPTION_DLL_ENABLE_AUTO_IMPORT	(OPTION_NO_DEFAULT_EXCLUDES + 1)
#define OPTION_DLL_DISABLE_AUTO_IMPORT	(OPTION_DLL_ENABLE_AUTO_IMPORT + 1)
#define OPTION_ENABLE_EXTRA_PE_DEBUG	(OPTION_DLL_DISABLE_AUTO_IMPORT + 1)
#define OPTION_EXCLUDE_LIBS		(OPTION_ENABLE_EXTRA_PE_DEBUG + 1)
#define OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC	\
					(OPTION_EXCLUDE_LIBS + 1)
#define OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC	\
					(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC + 1)
d180 18
a197 27
static void
gld${EMULATION_NAME}_add_options (ns, shortopts, nl, longopts, nrl, really_longopts)
     int ns ATTRIBUTE_UNUSED;
     char **shortopts ATTRIBUTE_UNUSED;
     int nl;
     struct option **longopts;
     int nrl ATTRIBUTE_UNUSED;
     struct option **really_longopts ATTRIBUTE_UNUSED;
{
  static const struct option xtra_long[] = {
    /* PE options */
    {"base-file", required_argument, NULL, OPTION_BASE_FILE},
    {"dll", no_argument, NULL, OPTION_DLL},
    {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
    {"heap", required_argument, NULL, OPTION_HEAP},
    {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
    {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
    {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
    {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
    {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
    {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
    {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
    {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
    {"stack", required_argument, NULL, OPTION_STACK},
    {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
    {"support-old-code", no_argument, NULL, OPTION_SUPPORT_OLD_CODE},
    {"thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
d199 21
a219 34
    /* getopt allows abbreviations, so we do this to stop it from treating -o
       as an abbreviation for this option */
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL},
    {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMBOLS},
    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
    {"kill-at", no_argument, NULL, OPTION_KILL_ATS},
    {"add-stdcall-alias", no_argument, NULL, OPTION_STDCALL_ALIASES},
    {"enable-stdcall-fixup", no_argument, NULL, OPTION_ENABLE_STDCALL_FIXUP},
    {"disable-stdcall-fixup", no_argument, NULL, OPTION_DISABLE_STDCALL_FIXUP},
    {"out-implib", required_argument, NULL, OPTION_IMPLIB_FILENAME},
    {"warn-duplicate-exports", no_argument, NULL, OPTION_WARN_DUPLICATE_EXPORTS},
    /* getopt() allows abbreviations, so we do this to stop it from
       treating -c as an abbreviation for these --compat-implib.  */
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"enable-auto-image-base", no_argument, NULL, OPTION_ENABLE_AUTO_IMAGE_BASE},
    {"disable-auto-image-base", no_argument, NULL, OPTION_DISABLE_AUTO_IMAGE_BASE},
    {"dll-search-prefix", required_argument, NULL, OPTION_DLL_SEARCH_PREFIX},
    {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
    {"enable-auto-import", no_argument, NULL, OPTION_DLL_ENABLE_AUTO_IMPORT},
    {"disable-auto-import", no_argument, NULL, OPTION_DLL_DISABLE_AUTO_IMPORT},
    {"enable-extra-pe-debug", no_argument, NULL, OPTION_ENABLE_EXTRA_PE_DEBUG},
    {"enable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC},
    {"disable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC},
#endif
    {NULL, no_argument, NULL, 0}
  };

  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}
d222 1
a222 1
   parameters which may be input from the command line.  */
a262 1

a287 1
  fprintf (file, _("  --exclude-libs lib,lib,...         Exclude libraries from automatic export\n"));
d293 4
a296 4
  fprintf (file, _("  --compat-implib                    Create backward compatible import libs;\n\
                                       create __imp_<SYMBOL> as well.\n"));
  fprintf (file, _("  --enable-auto-image-base           Automatically choose image base for DLLs\n\
                                       unless user specifies one\n"));
d298 3
a300 13
  fprintf (file, _("  --dll-search-prefix=<string>       When linking dynamically to a dll without\n\
                                       an importlib, use <string><basename>.dll\n\
                                       in preference to lib<basename>.dll \n"));
  fprintf (file, _("  --enable-auto-import               Do sophistcated linking of _sym to\n\
                                       __imp_sym for DATA references\n"));
  fprintf (file, _("  --disable-auto-import              Do not auto-import DATA items from DLLs\n"));
  fprintf (file, _("  --enable-runtime-pseudo-reloc      Work around auto-import limitations by\n\
                                       adding pseudo-relocations resolved at\n\
                                       runtime.\n"));
  fprintf (file, _("  --disable-runtime-pseudo-reloc     Do not add runtime pseudo-relocations for\n\
                                       auto-imported DATA.\n"));
  fprintf (file, _("  --enable-extra-pe-debug            Enable verbose debug output when building\n\
                                       or linking to DLLs (esp. auto-import)\n"));
a303 1

d310 1
a310 2

  /* Find the name and set it.  */
d320 1
a320 1
  abort ();
d330 1
a330 1
  static const struct
d398 1
a398 1
	  lang_add_entry (entry, 0);
d403 1
a403 1

d408 1
d412 1
a412 1

d415 1
a415 1

d417 1
a417 1

a423 1

d430 1
a430 1

d441 22
a462 4
static bfd_boolean
gld${EMULATION_NAME}_handle_option (optc)
     int optc;
{
d466 4
a469 1
      return FALSE;
d482 2
a483 2
      /* PE options.  */
    case OPTION_HEAP:
d486 1
a486 1
    case OPTION_STACK:
d536 1
a536 4
      pe_dll_add_excludes (optarg, 0);
      break;
    case OPTION_EXCLUDE_LIBS:
      pe_dll_add_excludes (optarg, 1);
d566 1
a566 1
      pe_dll_search_prefix = xstrdup (optarg);
a570 15
    case OPTION_DLL_ENABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 1;
      break;
    case OPTION_DLL_DISABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 0;
      break;
    case OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 1;
      break;
    case OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 0;
      break;
    case OPTION_ENABLE_EXTRA_PE_DEBUG:
      pe_dll_extra_pe_debug = 1;
      break;
d573 1
a573 1
  return TRUE;
d578 1
a578 1
static unsigned long
d601 1
a601 2
/* Use the output file to create a image base for relocatable DLLs.  */

d617 1
a617 1
     names and insert the defaults.  */
d640 1
a640 1
  /* Glue the assignments into the abs section.  */
d649 7
a655 8
      rv = lang_add_assignment (exp_assop ('=', init[j].symbol,
					   exp_intop (val)));
      if (init[j].size == sizeof (short))
	*(short *) init[j].ptr = val;
      else if (init[j].size == sizeof (int))
	*(int *) init[j].ptr = val;
      else if (init[j].size == sizeof (long))
	*(long *) init[j].ptr = val;
d657 3
a659 3
      else if (init[j].size == sizeof (bfd_vma))
	*(bfd_vma *) init[j].ptr = val;
      else	abort ();
d663 1
a663 1
  /* Restore the pointer.  */
d665 1
a665 1

d692 2
a693 2
  if (! link_info.relocateable && entry_symbol.name != NULL)
    ldlang_add_undef (entry_symbol.name);
a695 7
/* pe-dll.c directly accesses pe_data_import_dll,
   so it must be defined outside of #ifdef DLL_SUPPORT.
   Note - this variable is deliberately not initialised.
   This allows it to be treated as a common varaible, and only
   exist in one incarnation in a multiple target enabled linker.  */
char * pe_data_import_dll;

d699 1
a699 1
static bfd_boolean
d704 1
a704 3
  int sl;

  sl = strlen (string); /* Silence compiler warning.  */
d708 5
a712 5
    {
      pe_undef_found_sym = h;
      return FALSE;
    }
  return TRUE;
d720 1
a720 4

  if (pe_dll_extra_pe_debug)
    printf ("%s\n", __FUNCTION__);

d723 3
d727 23
a749 59
	char* at = strchr (undef->root.string, '@@');
	int lead_at = (*undef->root.string == '@@');
	/* For now, don't try to fixup fastcall symbols.  */

	if (at && !lead_at)
	  {
	    /* The symbol is a stdcall symbol, so let's look for a
	       cdecl symbol with the same name and resolve to that.  */
	    char *cname = xstrdup (undef->root.string /* + lead_at */);
	    at = strchr (cname, '@@');
	    *at = 0;
	    sym = bfd_link_hash_lookup (link_info.hash, cname, 0, 0, 1);

	    if (sym && sym->type == bfd_link_hash_defined)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pe_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, cname);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
	else
	  {
	    /* The symbol is a cdecl symbol, so we look for stdcall
	       symbols - which means scanning the whole symbol table.  */
	    pe_undef_found_sym = 0;
	    bfd_link_hash_traverse (link_info.hash, pe_undef_cdecl_match,
				    (PTR) undef->root.string);
	    sym = pe_undef_found_sym;
	    if (sym)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pe_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, sym->root.string);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
d751 18
a768 60
}

static int
make_import_fixup (rel, s)
  arelent *rel;
  asection *s;
{
  struct symbol_cache_entry *sym = *rel->sym_ptr_ptr;
  int addend = 0;

  if (pe_dll_extra_pe_debug)
    printf ("arelent: %s@@%#lx: add=%li\n", sym->name,
	    (long) rel->address, (long) rel->addend);

  if (! bfd_get_section_contents (s->owner, s, &addend, rel->address, sizeof (addend)))
    einfo (_("%C: Cannot get section contents - auto-import exception\n"),
	   s->owner, s, rel->address);

  pe_create_import_fixup (rel, s, addend);

  return 1;
}

static void
pe_find_data_imports ()
{
  struct bfd_link_hash_entry *undef, *sym;

  if (link_info.pei386_auto_import == 0)
    return;

  for (undef = link_info.hash->undefs; undef; undef=undef->next)
    {
      if (undef->type == bfd_link_hash_undefined)
        {
          /* C++ symbols are *long*.  */
          char buf[4096];

	  if (pe_dll_extra_pe_debug)
	    printf ("%s:%s\n", __FUNCTION__, undef->root.string);

          sprintf (buf, "__imp_%s", undef->root.string);

          sym = bfd_link_hash_lookup (link_info.hash, buf, 0, 0, 1);

          if (sym && sym->type == bfd_link_hash_defined)
            {
	      bfd *b = sym->u.def.section->owner;
	      asymbol **symbols;
	      int nsyms, symsize, i;

	      if (link_info.pei386_auto_import == -1)
		info_msg (_("Info: resolving %s by linking to %s (auto-import)\n"),
			  undef->root.string, buf);

	      symsize = bfd_get_symtab_upper_bound (b);
	      symbols = (asymbol **) xmalloc (symsize);
	      nsyms = bfd_canonicalize_symtab (b, symbols);

	      for (i = 0; i < nsyms; i++)
d770 3
a772 10
		  if (memcmp (symbols[i]->name, "__head_",
			      sizeof ("__head_") - 1))
		    continue;

		  if (pe_dll_extra_pe_debug)
		    printf ("->%s\n", symbols[i]->name);

		  pe_data_import_dll = (char*) (symbols[i]->name +
						sizeof ("__head_") - 1);
		  break;
d774 3
a776 14

	      pe_walk_relocs_of_symbol (&link_info, undef->root.string,
					make_import_fixup);

	      /* Let's differentiate it somehow from defined.  */
	      undef->type = bfd_link_hash_defweak;
	      /* We replace original name with __imp_ prefixed, this
		 1) may trash memory 2) leads to duplicate symbol generation.
		 Still, IMHO it's better than having name poluted.  */
	      undef->root.string = sym->root.string;
	      undef->u.def.value = sym->u.def.value;
	      undef->u.def.section = sym->u.def.section;
            }
        }
a780 12
static bfd_boolean
pr_sym (h, string)
  struct bfd_hash_entry *h;
  PTR string ATTRIBUTE_UNUSED;
{
  if (pe_dll_extra_pe_debug)
    printf ("+%s\n",h->string);

  return TRUE;
}


a783 15
  if (pe_dll_extra_pe_debug)
    {
      bfd *a;
      struct bfd_link_hash_entry *sym;

      printf ("%s()\n", __FUNCTION__);

      for (sym = link_info.hash->undefs; sym; sym=sym->next)
        printf ("-%s\n", sym->root.string);
      bfd_hash_traverse (&link_info.hash->table, pr_sym,NULL);

      for (a = link_info.input_bfds; a; a = a->link_next)
	printf ("*%s\n",a->filename);
    }

d787 2
a788 2

  if (coff_data (output_bfd) == NULL || coff_data (output_bfd)->pe == 0)
d798 1
a798 5
  pe_process_import_defs (output_bfd, & link_info);

  pe_find_data_imports ();

#if ! (defined (TARGET_IS_i386pe) || defined (TARGET_IS_armpe))
a799 3
#else
  if (!link_info.relocateable)
#endif
d839 1
a839 1
       things nicely and produce a valid import table.  */
d847 1
a847 1

d857 1
a857 1

d870 1
a870 1

d877 1
a877 1

d879 1
a879 1
		    symsize = bfd_canonicalize_symtab (is->the_bfd, symbols);
d885 1
a885 1

d895 1
a895 1

d902 1
a902 1

d904 1
a904 1

d907 1
a907 1

d911 2
a912 2
						     FALSE, FALSE, TRUE);

d916 1
a916 1

d918 1
a918 1

d922 1
a922 1

d925 1
a925 1

d927 1
a927 1

d1005 2
a1006 2
static void
gld_${EMULATION_NAME}_before_allocation ()
d1009 1
a1009 1
  /* Here we rummage through the found bfds to collect toc information.  */
d1021 1
a1021 1
  /* We have seen it all. Allocate it, and carry on.  */
d1031 1
a1031 1
     option?  krk@@cygnus.com.  */
d1045 1
a1045 1
  /* We have seen it all. Allocate it, and carry on.  */
d1052 1
a1052 1
   check here for .DEF files and pull them in automatically.  */
d1055 1
a1055 1
saw_option (char * option)
d1058 1
a1058 2

  for (i = 0; init[i].ptr; i++)
d1065 2
a1066 2
static bfd_boolean
gld_${EMULATION_NAME}_unrecognized_file (entry)
d1073 16
a1088 7
    {
      if (pe_def_file == 0)
	pe_def_file = def_file_empty ();

      def_file_parse (entry->filename, pe_def_file);

      if (pe_def_file)
d1090 2
a1091 2
	  int i, buflen=0, len;
	  char *buf;
d1093 4
a1096 1
	  for (i = 0; i < pe_def_file->num_exports; i++)
d1098 3
a1100 3
	      len = strlen (pe_def_file->exports[i].internal_name);
	      if (buflen < len + 2)
		buflen = len + 2;
d1102 2
d1105 3
a1107 1
	  buf = (char *) xmalloc (buflen);
d1109 10
a1118 32
	  for (i = 0; i < pe_def_file->num_exports; i++)
	    {
	      struct bfd_link_hash_entry *h;

	      sprintf (buf, "_%s", pe_def_file->exports[i].internal_name);

	      h = bfd_link_hash_lookup (link_info.hash, buf, TRUE, TRUE, TRUE);
	      if (h == (struct bfd_link_hash_entry *) NULL)
		einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	      if (h->type == bfd_link_hash_new)
		{
		  h->type = bfd_link_hash_undefined;
		  h->u.undef.abfd = NULL;
		  bfd_link_add_undef (link_info.hash, h);
		}
	    }
	  free (buf);

	  /* def_file_print (stdout, pe_def_file); */
	  if (pe_def_file->is_dll == 1)
	    link_info.shared = 1;

	  if (pe_def_file->base_address != (bfd_vma)(-1))
	    {
	      pe.ImageBase =
		pe_data (output_bfd)->pe_opthdr.ImageBase =
		init[IMAGEBASEOFF].value = pe_def_file->base_address;
	      init[IMAGEBASEOFF].inited = 1;
	      if (image_base_statement)
		image_base_statement->exp =
		  exp_assop ('=', "__image_base__", exp_intop (pe.ImageBase));
	    }
d1121 6
a1126 6
	  /* Not sure if these *should* be set.  */
	  if (pe_def_file->version_major != -1)
	    {
	      pe.MajorImageVersion = pe_def_file->version_major;
	      pe.MinorImageVersion = pe_def_file->version_minor;
	    }
d1128 15
a1142 16
	  if (pe_def_file->stack_reserve != -1
	      && ! saw_option ("__size_of_stack_reserve__"))
	    {
	      pe.SizeOfStackReserve = pe_def_file->stack_reserve;
	      if (pe_def_file->stack_commit != -1)
		pe.SizeOfStackCommit = pe_def_file->stack_commit;
	    }
	  if (pe_def_file->heap_reserve != -1
	      && ! saw_option ("__size_of_heap_reserve__"))
	    {
	      pe.SizeOfHeapReserve = pe_def_file->heap_reserve;
	      if (pe_def_file->heap_commit != -1)
		pe.SizeOfHeapCommit = pe_def_file->heap_commit;
	    }
	  return TRUE;
	}
d1144 1
d1146 2
a1147 1
  return FALSE;
d1150 2
a1151 2
static bfd_boolean
gld_${EMULATION_NAME}_recognized_file (entry)
d1169 1
a1169 8
      char fbuf[LD_PATHMAX + 1];
      const char *ext;

      if (REALPATH (entry->filename, fbuf) == NULL)
	strncpy (fbuf, entry->filename, sizeof (fbuf));

      ext = fbuf + strlen (fbuf) - 4;

d1171 1
a1171 1
	return pe_implied_import_dll (fbuf);
d1174 1
a1174 1
  return FALSE;
d1185 2
a1186 3
      h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,
				FALSE, FALSE, TRUE);

d1194 1
a1194 1

d1201 1
a1201 1

d1203 1
a1203 1

d1208 1
a1208 1

d1210 2
a1211 2

	  if (entry_symbol.name != NULL && entry_from_cmdline)
d1213 2
a1214 2
		   thumb_entry_symbol, entry_symbol.name);
	  entry_symbol.name = buffer;
d1222 1
a1222 5
  if (link_info.shared
#if !defined(TARGET_IS_shpe) && !defined(TARGET_IS_mipspe)
    || (!link_info.relocateable && pe_def_file->num_exports != 0)
#endif
    )
d1235 1
a1235 1

a1238 11

  /* I don't know where .idata gets set as code, but it shouldn't be.  */
  {
    asection *asec = bfd_get_section_by_name (output_bfd, ".idata");

    if (asec)
      {
        asec->flags &= ~SEC_CODE;
        asec->flags |= SEC_DATA;
      }
  }
a1241 26
/* Find the last output section before given output statement.
   Used by place_orphan.  */

static asection *
output_prev_sec_find (os)
     lang_output_section_statement_type *os;
{
  asection *s = (asection *) NULL;
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (lookup == os)
	return s;

      if (lookup->bfd_section != NULL && lookup->bfd_section->owner != NULL)
	s = lookup->bfd_section;
    }

  return NULL;
}

d1262 2
a1263 1
static bfd_boolean
d1278 1
d1292 4
a1295 7
      && (os->bfd_section == NULL
	  || ((s->flags ^ os->bfd_section->flags)
	      & (SEC_LOAD | SEC_ALLOC)) == 0))
    {
      /* We already have an output section statement with this
	 name, and its bfd section, if any, has compatible flags.  */
      lang_add_section (&add_child, s, os, file);
d1335 1
a1335 1
	 different loadable or allocatable characteristics.  */
d1374 1
a1374 1

d1382 1
a1382 1

d1399 1
a1399 1
      lang_add_section (&add_child, s, os, file);
d1403 1
a1403 1
	 (struct lang_output_section_phdr_list *) NULL, NULL);
d1409 2
a1410 2
	  /* lang_leave_ouput_section_statement resets stat_ptr.
	     Put stat_ptr back where we want it.  */
d1413 1
a1413 1

d1422 1
a1422 1
      if (place != NULL && os->bfd_section != NULL)
d1427 1
a1427 4

	  /* Shuffle the bfd section list to make the output file look
	     neater.  This is really only cosmetic.  */
	  if (place->section == NULL)
d1429 17
a1445 1
	      asection *bfd_section = place->os->bfd_section;
d1447 4
a1450 6
	      /* If the output statement hasn't been used to place
		 any input sections (and thus doesn't have an output
		 bfd_section), look for the closest prior output statement
		 having an output section.  */
	      if (bfd_section == NULL)
		bfd_section = output_prev_sec_find (place->os);
d1452 3
a1454 2
	      if (bfd_section != NULL && bfd_section != snew)
		place->section = &bfd_section->next;
d1456 1
d1458 1
a1458 1
	  if (place->section != NULL)
d1460 3
a1462 9
	      /* Unlink the section.  */
	      for (pps = &output_bfd->sections;
		   *pps != snew;
		   pps = &(*pps)->next)
		;
	      bfd_section_list_remove (output_bfd, pps);

	      /* Now tack it on to the "place->os" section list.  */
	      bfd_section_list_insert (output_bfd, place->section, snew);
d1464 1
a1464 15

	  /* Save the end of this list.  Further ophans of this type will
	     follow the one we've just added.  */
	  place->section = &snew->next;

	  /* The following is non-cosmetic.  We try to put the output
	     statements in some sort of reasonable order here, because
	     they determine the final load addresses of the orphan
	     sections.  In addition, placing output statements in the
	     wrong order may require extra segments.  For instance,
	     given a typical situation of all read-only sections placed
	     in one segment and following that a segment containing all
	     the read-write sections, we wouldn't want to place an orphan
	     read/write section before or amongst the read-only ones.  */
	  if (add.head != NULL)
d1466 3
a1468 20
	      if (place->stmt == NULL)
		{
		  /* Put the new statement list right at the head.  */
		  *add.tail = place->os->header.next;
		  place->os->header.next = add.head;
		}
	      else
		{
		  /* Put it after the last orphan statement we added.  */
		  *add.tail = *place->stmt;
		  *place->stmt = add.head;
		}

	      /* Fix the global list pointer if we happened to tack our
		 new list at the tail.  */
	      if (*old->tail == add.head)
		old->tail = add.tail;

	      /* Save the end of this list.  */
	      place->stmt = add.tail;
d1470 1
d1479 1
a1479 1
	bfd_boolean found_dollar;
d1483 3
a1485 2
	found_dollar = FALSE;
	for ( ; *pl != NULL; pl = &(*pl)->header.next)
d1503 1
a1503 1
		found_dollar = TRUE;
d1512 1
a1512 1
	add_child.head->header.next = *pl;
d1519 1
a1519 1
  return TRUE;
d1522 1
a1522 1
static bfd_boolean
d1532 1
a1532 1
    return FALSE;
d1537 1
a1537 1
                             + strlen (filename)
d1544 1
a1544 1
  /* Try "libfoo.dll.a" first (preferred explicit import library for dll's.  */
d1549 1
a1549 1
      /* Try "foo.dll.a" next (alternate explicit import library for dll's.  */
d1553 11
a1563 9
	  /* Try libfoo.a next. Normally, this would be interpreted as a static
	     library, but it *could* be an import library. For backwards compatibility,
	     libfoo.a needs to ==precede== libfoo.dll and foo.dll in the search,
	     or sometimes errors occur when building legacy packages.

	     Putting libfoo.a here means that in a failure case (i.e. the library
	     -lfoo is not found) we will search for libfoo.a twice before
	     giving up -- once here, and once when searching for a "static" lib.
	     for a "static" lib.  */
d1565 1
a1565 1
             take precedence over dll's).  */
d1571 2
a1572 2
                {
                  /* Try "<prefix>foo.dll" (preferred dll name, if specified).  */
d1576 1
a1576 1
                      /* Try "libfoo.dll" (default preferred dll name).  */
d1580 1
a1580 1
                          /* Finally, try "foo.dll" (alternate dll name).  */
d1585 1
a1585 1
                              return FALSE;
d1590 2
a1591 2
              else /* pe_dll_search_prefix not specified.  */
#endif
d1593 1
a1593 1
                  /* Try "libfoo.dll" (preferred dll name).  */
d1597 1
a1597 1
                      /* Finally, try "foo.dll" (alternate dll name).  */
d1602 1
a1602 1
                          return FALSE;
d1612 1
a1612 1
  return TRUE;
d1624 1
a1624 1
gld_${EMULATION_NAME}_get_script (isfile)
d1632 1
a1632 1
{
d1635 1
a1635 1
  if (link_info.relocateable && config.build_constructors)
d1638 10
a1647 10
sed $sc ldscripts/${EMULATION_NAME}.xu                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                 >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                 >> e${EMULATION_NAME}.c
echo '  ; else return'                                 >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
echo '; }'                                             >> e${EMULATION_NAME}.c
d1652 1
a1652 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
d1666 2
a1667 2
  gld_${EMULATION_NAME}_finish,
  NULL, /* Create output section statements.  */
d1671 1
a1671 3
  NULL, /* parse_args */
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
d1675 1
a1675 2
  gld_${EMULATION_NAME}_find_potential_libraries,
  NULL	/* new_vers_pattern.  */
@

