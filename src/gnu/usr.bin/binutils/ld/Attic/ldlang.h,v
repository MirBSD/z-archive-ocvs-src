head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.21.20.24;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.05.36;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.01;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.41.01;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.25.10;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.43.22;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.08.44;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.18.22;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* ldlang.h - linker command language support
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GLD, the Gnu Linker.

   GLD is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GLD is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#ifndef LDLANG_H
#define LDLANG_H

typedef enum {
  lang_input_file_is_l_enum,
  lang_input_file_is_symbols_only_enum,
  lang_input_file_is_marker_enum,
  lang_input_file_is_fake_enum,
  lang_input_file_is_search_file_enum,
  lang_input_file_is_file_enum
} lang_input_file_enum_type;

struct _fill_type {
  size_t size;
  unsigned char data[1];
};

typedef struct statement_list {
  union lang_statement_union *head;
  union lang_statement_union **tail;
} lang_statement_list_type;

typedef struct memory_region_struct {
  char *name;
  struct memory_region_struct *next;
  bfd_vma origin;
  bfd_size_type length;
  bfd_vma current;
  bfd_size_type old_length;
  flagword flags;
  flagword not_flags;
  bfd_boolean had_full_message;
} lang_memory_region_type;

typedef struct lang_statement_header_struct {
  union lang_statement_union *next;
  enum statement_enum {
    lang_output_section_statement_enum,
    lang_assignment_statement_enum,
    lang_input_statement_enum,
    lang_address_statement_enum,
    lang_wild_statement_enum,
    lang_input_section_enum,
    lang_object_symbols_statement_enum,
    lang_fill_statement_enum,
    lang_data_statement_enum,
    lang_reloc_statement_enum,
    lang_target_statement_enum,
    lang_output_statement_enum,
    lang_padding_statement_enum,
    lang_group_statement_enum,

    lang_afile_asection_pair_statement_enum,
    lang_constructors_statement_enum
  } type;
} lang_statement_header_type;

typedef struct {
  lang_statement_header_type header;
  union etree_union *exp;
} lang_assignment_statement_type;

typedef struct lang_target_statement_struct {
  lang_statement_header_type header;
  const char *target;
} lang_target_statement_type;

typedef struct lang_output_statement_struct {
  lang_statement_header_type header;
  const char *name;
} lang_output_statement_type;

/* Section types specified in a linker script.  */

enum section_type {
  normal_section,
  dsect_section,
  copy_section,
  noload_section,
  info_section,
  overlay_section
};

/* This structure holds a list of program headers describing segments
   in which this section should be placed.  */

struct lang_output_section_phdr_list {
  struct lang_output_section_phdr_list *next;
  const char *name;
  bfd_boolean used;
};

typedef struct lang_output_section_statement_struct {
  lang_statement_header_type header;
  union etree_union *addr_tree;
  lang_statement_list_type children;
  const char *memspec;
  union lang_statement_union *next;
  const char *name;

  bfd_boolean processed;

  asection *bfd_section;
  flagword flags;		/* Or together of all input sections */
  enum section_type sectype;
  struct memory_region_struct *region;
  struct memory_region_struct *lma_region;
  size_t block_value;
  fill_type *fill;

  int subsection_alignment;	/* alignment of components */
  int section_alignment;	/* alignment of start of section */

  union etree_union *load_base;

  /* If non-null, an expression to evaluate after setting the section's
     size.  The expression is evaluated inside REGION (above) with '.'
     set to the end of the section.  Used in the last overlay section
     to move '.' past all the overlaid sections.  */
  union etree_union *update_dot_tree;

  struct lang_output_section_phdr_list *phdrs;
} lang_output_section_statement_type;

typedef struct {
  lang_statement_header_type header;
} lang_common_statement_type;

typedef struct {
  lang_statement_header_type header;
} lang_object_symbols_statement_type;

typedef struct {
  lang_statement_header_type header;
  fill_type *fill;
  int size;
  asection *output_section;
} lang_fill_statement_type;

typedef struct {
  lang_statement_header_type header;
  unsigned int type;
  union etree_union *exp;
  bfd_vma value;
  asection *output_section;
  bfd_vma output_vma;
} lang_data_statement_type;

/* Generate a reloc in the output file.  */

typedef struct {
  lang_statement_header_type header;

  /* Reloc to generate.  */
  bfd_reloc_code_real_type reloc;

  /* Reloc howto structure.  */
  reloc_howto_type *howto;

  /* Section to generate reloc against.  Exactly one of section and
     name must be NULL.  */
  asection *section;

  /* Name of symbol to generate reloc against.  Exactly one of section
     and name must be NULL.  */
  const char *name;

  /* Expression for addend.  */
  union etree_union *addend_exp;

  /* Resolved addend.  */
  bfd_vma addend_value;

  /* Output section where reloc should be performed.  */
  asection *output_section;

  /* VMA within output section.  */
  bfd_vma output_vma;
} lang_reloc_statement_type;

typedef struct lang_input_statement_struct {
  lang_statement_header_type header;
  /* Name of this file.  */
  const char *filename;
  /* Name to use for the symbol giving address of text start */
  /* Usually the same as filename, but for a file spec'd with -l
     this is the -l switch itself rather than the filename.  */
  const char *local_sym_name;

  bfd *the_bfd;

  bfd_boolean closed;
  file_ptr passive_position;

  /* Symbol table of the file.  */
  asymbol **asymbols;
  unsigned int symbol_count;

  /* Point to the next file - whatever it is, wanders up and down
     archives */

  union lang_statement_union *next;
  /* Point to the next file, but skips archive contents */
  union lang_statement_union *next_real_file;

  bfd_boolean is_archive;

  /* 1 means search a set of directories for this file.  */
  bfd_boolean search_dirs_flag;

  /* 1 means this was found in a search directory marked as sysrooted,
     if search_dirs_flag is false, otherwise, that it should be
     searched in ld_sysroot before any other location, as long as it
     starts with a slash.  */
  bfd_boolean sysrooted;

  /* 1 means this is base file of incremental load.
     Do not load this file's text or data.
     Also default text_start to after this file's bss.  */

  bfd_boolean just_syms_flag;

  /* Whether to search for this entry as a dynamic archive.  */
  bfd_boolean dynamic;

  /* Whether to include the entire contents of an archive.  */
  bfd_boolean whole_archive;

  bfd_boolean loaded;

#if 0
  unsigned int globals_in_this_file;
#endif
  const char *target;
  bfd_boolean real;
} lang_input_statement_type;

typedef struct {
  lang_statement_header_type header;
  asection *section;
  lang_input_statement_type *ifile;

} lang_input_section_type;

typedef struct {
  lang_statement_header_type header;
  asection *section;
  union lang_statement_union *file;
} lang_afile_asection_pair_statement_type;

typedef struct lang_wild_statement_struct {
  lang_statement_header_type header;
  const char *filename;
  bfd_boolean filenames_sorted;
  struct wildcard_list *section_list;
  bfd_boolean keep_sections;
  lang_statement_list_type children;
} lang_wild_statement_type;

typedef struct lang_address_statement_struct {
  lang_statement_header_type header;
  const char *section_name;
  union etree_union *address;
} lang_address_statement_type;

typedef struct {
  lang_statement_header_type header;
  bfd_vma output_offset;
  size_t size;
  asection *output_section;
  fill_type *fill;
} lang_padding_statement_type;

/* A group statement collects a set of libraries together.  The
   libraries are searched multiple times, until no new undefined
   symbols are found.  The effect is to search a group of libraries as
   though they were a single library.  */

typedef struct {
  lang_statement_header_type header;
  lang_statement_list_type children;
} lang_group_statement_type;

typedef union lang_statement_union {
  lang_statement_header_type header;
  lang_wild_statement_type wild_statement;
  lang_data_statement_type data_statement;
  lang_reloc_statement_type reloc_statement;
  lang_address_statement_type address_statement;
  lang_output_section_statement_type output_section_statement;
  lang_afile_asection_pair_statement_type afile_asection_pair_statement;
  lang_assignment_statement_type assignment_statement;
  lang_input_statement_type input_statement;
  lang_target_statement_type target_statement;
  lang_output_statement_type output_statement;
  lang_input_section_type input_section;
  lang_common_statement_type common_statement;
  lang_object_symbols_statement_type object_symbols_statement;
  lang_fill_statement_type fill_statement;
  lang_padding_statement_type padding_statement;
  lang_group_statement_type group_statement;
} lang_statement_union_type;

/* This structure holds information about a program header, from the
   PHDRS command in the linker script.  */

struct lang_phdr {
  struct lang_phdr *next;
  const char *name;
  unsigned long type;
  bfd_boolean filehdr;
  bfd_boolean phdrs;
  etree_type *at;
  etree_type *flags;
};

/* This structure is used to hold a list of sections which may not
   cross reference each other.  */

struct lang_nocrossref {
  struct lang_nocrossref *next;
  const char *name;
};

/* The list of nocrossref lists.  */

struct lang_nocrossrefs {
  struct lang_nocrossrefs *next;
  struct lang_nocrossref *list;
};

extern struct lang_nocrossrefs *nocrossref_list;

/* This structure is used to hold a list of input section names which
   will not match an output section in the linker script.  */

struct unique_sections {
  struct unique_sections *next;
  const char *name;
};

extern struct unique_sections *unique_section_list;

extern lang_output_section_statement_type *abs_output_section;
extern lang_statement_list_type lang_output_section_statement;
extern bfd_boolean lang_has_input_file;
extern etree_type *base;
extern lang_statement_list_type *stat_ptr;
extern bfd_boolean delete_output_file_on_failure;

extern struct bfd_sym_chain entry_symbol;
extern const char *entry_section;
extern bfd_boolean entry_from_cmdline;
extern lang_statement_list_type file_chain;

extern void lang_init
  PARAMS ((void));
extern struct memory_region_struct *lang_memory_region_lookup
  PARAMS ((const char *const));
extern struct memory_region_struct *lang_memory_region_default
  PARAMS ((asection *));
extern void lang_map
  PARAMS ((void));
extern void lang_set_flags
  PARAMS ((lang_memory_region_type *, const char *, int));
extern void lang_add_output
  PARAMS ((const char *, int from_script));
extern lang_output_section_statement_type *lang_enter_output_section_statement
  PARAMS ((const char *output_section_statement_name,
	   etree_type *address_exp,
	   enum section_type sectype,
	   bfd_vma block_value,
	   etree_type *align,
	   etree_type *subalign,
	   etree_type *));
extern void lang_final
  PARAMS ((void));
extern void lang_process
  PARAMS ((void));
extern void lang_section_start
  PARAMS ((const char *, union etree_union *));
extern void lang_add_entry
  PARAMS ((const char *, bfd_boolean));
extern void lang_add_target
  PARAMS ((const char *));
extern void lang_add_wild
  PARAMS ((struct wildcard_spec *, struct wildcard_list *, bfd_boolean));
extern void lang_add_map
  PARAMS ((const char *));
extern void lang_add_fill
  PARAMS ((fill_type *));
extern lang_assignment_statement_type * lang_add_assignment
  PARAMS ((union etree_union *));
extern void lang_add_attribute
  PARAMS ((enum statement_enum));
extern void lang_startup
  PARAMS ((const char *));
extern void lang_float
  PARAMS ((bfd_boolean));
extern void lang_leave_output_section_statement
  PARAMS ((fill_type *, const char *, struct lang_output_section_phdr_list *,
           const char *));
extern void lang_abs_symbol_at_end_of
  PARAMS ((const char *, const char *));
extern void lang_abs_symbol_at_beginning_of
  PARAMS ((const char *, const char *));
extern void lang_statement_append
  PARAMS ((struct statement_list *, union lang_statement_union *,
	   union lang_statement_union **));
extern void lang_for_each_input_file
  PARAMS ((void (*dothis) (lang_input_statement_type *)));
extern void lang_for_each_file
  PARAMS ((void (*dothis) (lang_input_statement_type *)));
extern void lang_reset_memory_regions
  PARAMS ((void));
extern bfd_vma lang_do_assignments
  PARAMS ((lang_statement_union_type * s,
	   lang_output_section_statement_type *output_section_statement,
	   fill_type *fill,
	   bfd_vma dot));

#define LANG_FOR_EACH_INPUT_STATEMENT(statement)			\
  lang_input_statement_type *statement;					\
  for (statement = (lang_input_statement_type *) file_chain.head;	\
       statement != (lang_input_statement_type *) NULL;			\
       statement = (lang_input_statement_type *) statement->next)	\

extern void lang_process
  PARAMS ((void));
extern void ldlang_add_file
  PARAMS ((lang_input_statement_type *));
extern lang_output_section_statement_type *lang_output_section_find
  PARAMS ((const char * const));
extern lang_input_statement_type *lang_add_input_file
  PARAMS ((const char *name, lang_input_file_enum_type file_type,
	   const char *target));
extern void lang_add_keepsyms_file
  PARAMS ((const char *filename));
extern lang_output_section_statement_type *
  lang_output_section_statement_lookup
  PARAMS ((const char * const name));
extern void ldlang_add_undef
  PARAMS ((const char *const name));
extern void lang_add_output_format
  PARAMS ((const char *, const char *, const char *, int from_script));
extern void lang_list_init
  PARAMS ((lang_statement_list_type*));
extern void lang_add_data
  PARAMS ((int type, union etree_union *));
extern void lang_add_reloc
  PARAMS ((bfd_reloc_code_real_type reloc, reloc_howto_type *howto,
	   asection *section, const char *name, union etree_union *addend));
extern void lang_for_each_statement
  PARAMS ((void (*func) (lang_statement_union_type *)));
extern PTR stat_alloc
  PARAMS ((size_t size));
extern void dprint_statement
  PARAMS ((lang_statement_union_type *, int));
extern bfd_vma lang_size_sections
  PARAMS ((lang_statement_union_type *s,
	   lang_output_section_statement_type *output_section_statement,
	   lang_statement_union_type **prev, fill_type *fill,
	   bfd_vma dot, bfd_boolean *relax, bfd_boolean check_regions));
extern void lang_enter_group
  PARAMS ((void));
extern void lang_leave_group
  PARAMS ((void));
extern void lang_add_section
  PARAMS ((lang_statement_list_type *ptr, asection *section,
	   lang_output_section_statement_type *output,
	   lang_input_statement_type *file));
extern void lang_new_phdr
  PARAMS ((const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,
	   etree_type *));
extern void lang_add_nocrossref
  PARAMS ((struct lang_nocrossref *));
extern void lang_enter_overlay
  PARAMS ((etree_type *));
extern void lang_enter_overlay_section
  PARAMS ((const char *));
extern void lang_leave_overlay_section
  PARAMS ((fill_type *, struct lang_output_section_phdr_list *));
extern void lang_leave_overlay
  PARAMS ((etree_type *, int, fill_type *, const char *,
	   struct lang_output_section_phdr_list *, const char *));

extern struct bfd_elf_version_tree *lang_elf_version_info;

extern struct bfd_elf_version_expr *lang_new_vers_pattern
  PARAMS ((struct bfd_elf_version_expr *, const char *, const char *));
extern struct bfd_elf_version_tree *lang_new_vers_node
  PARAMS ((struct bfd_elf_version_expr *, struct bfd_elf_version_expr *));
extern struct bfd_elf_version_deps *lang_add_vers_depend
  PARAMS ((struct bfd_elf_version_deps *, const char *));
extern void lang_register_vers_node
  PARAMS ((const char *, struct bfd_elf_version_tree *,
	   struct bfd_elf_version_deps *));
bfd_boolean unique_section_p
  PARAMS ((const char *));
extern void lang_add_unique
  PARAMS ((const char *));
extern const char *lang_get_output_target
  PARAMS ((void));

#endif
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   2001
d10 1
a10 1
   the Free Software Foundation; either version 1, or (at your option)
d35 4
a38 1
typedef unsigned int fill_type;
d54 1
a54 1
  boolean had_full_message;
d112 1
a112 1
  boolean used;
d123 1
a123 1
  boolean processed;
d131 1
a131 1
  fill_type fill;
d138 6
d157 1
a157 1
  fill_type fill;
d214 1
a214 1
  boolean closed;
d228 1
a228 1
  boolean is_archive;
d231 7
a237 1
  boolean search_dirs_flag;
d243 1
a243 1
  boolean just_syms_flag;
d246 1
a246 1
  boolean dynamic;
d249 1
a249 1
  boolean whole_archive;
d251 1
a251 1
  boolean loaded;
d257 1
a257 1
  boolean real;
a274 2
  const char *section_name;
  boolean sections_sorted;
d276 3
a278 3
  boolean filenames_sorted;
  boolean keep_sections;
  struct name_list *exclude_filename_list;
d293 1
a293 1
  fill_type fill;
a307 1
  union lang_statement_union *next;
d333 2
a334 2
  boolean filehdr;
  boolean phdrs;
d368 1
a368 1
extern boolean lang_has_input_file;
d371 1
a371 1
extern boolean delete_output_file_on_failure;
d373 3
a375 2
extern const char *entry_symbol;
extern boolean entry_from_cmdline;
d378 2
a379 1
extern void lang_init PARAMS ((void));
d384 6
a389 4
extern void lang_map PARAMS ((void));
extern void lang_set_flags PARAMS ((lang_memory_region_type *, const char *,
				    int));
extern void lang_add_output PARAMS ((const char *, int from_script));
d392 1
a392 1
	   etree_type * address_exp,
d398 10
a407 5
extern void lang_final PARAMS ((void));
extern void lang_process PARAMS ((void));
extern void lang_section_start PARAMS ((const char *, union etree_union *));
extern void lang_add_entry PARAMS ((const char *, boolean));
extern void lang_add_target PARAMS ((const char *));
d409 13
a421 7
  PARAMS ((const char *, boolean, const char *, boolean, boolean, name_list *));
extern void lang_add_map PARAMS ((const char *));
extern void lang_add_fill PARAMS ((int));
extern lang_assignment_statement_type * lang_add_assignment PARAMS ((union etree_union *));
extern void lang_add_attribute PARAMS ((enum statement_enum));
extern void lang_startup PARAMS ((const char *));
extern void lang_float PARAMS ((enum bfd_boolean));
d423 1
a423 1
  PARAMS ((bfd_vma, const char *, struct lang_output_section_phdr_list *,
d425 7
a431 6
extern void lang_abs_symbol_at_end_of PARAMS ((const char *, const char *));
extern void lang_abs_symbol_at_beginning_of PARAMS ((const char *,
						     const char *));
extern void lang_statement_append PARAMS ((struct statement_list *,
					   union lang_statement_union *,
					   union lang_statement_union **));
d436 2
d441 1
a441 1
	   fill_type fill,
d444 10
a453 8
#define LANG_FOR_EACH_INPUT_STATEMENT(statement)		\
  lang_input_statement_type *statement;				\
  for (statement = (lang_input_statement_type *)file_chain.head;\
       statement != (lang_input_statement_type *)NULL;		\
       statement = (lang_input_statement_type *)statement->next)\

extern void lang_process PARAMS ((void));
extern void ldlang_add_file PARAMS ((lang_input_statement_type *));
d459 2
a460 1
extern void lang_add_keepsyms_file PARAMS ((const char *filename));
d462 10
a471 6
  lang_output_section_statement_lookup PARAMS ((const char * const name));
extern void ldlang_add_undef PARAMS ((const char *const name));
extern void lang_add_output_format PARAMS ((const char *, const char *,
					    const char *, int from_script));
extern void lang_list_init PARAMS ((lang_statement_list_type*));
extern void lang_add_data PARAMS ((int type, union etree_union *));
d477 4
a480 2
extern PTR stat_alloc PARAMS ((size_t size));
extern void dprint_statement PARAMS ((lang_statement_union_type *, int));
d484 7
a490 5
	   lang_statement_union_type **prev, fill_type fill,
	   bfd_vma dot, boolean relax));
extern void lang_enter_group PARAMS ((void));
extern void lang_leave_group PARAMS ((void));
extern void wild_doit
d495 1
a495 1
  PARAMS ((const char *, etree_type *, boolean, boolean, etree_type *,
d497 6
a502 3
extern void lang_add_nocrossref PARAMS ((struct lang_nocrossref *));
extern void lang_enter_overlay PARAMS ((etree_type *, etree_type *, int));
extern void lang_enter_overlay_section PARAMS ((const char *));
d504 1
a504 1
  PARAMS ((bfd_vma, struct lang_output_section_phdr_list *));
d506 2
a507 2
  PARAMS ((bfd_vma, const char *, struct lang_output_section_phdr_list *,
           const char *));
d511 1
a511 1
extern struct bfd_elf_version_expr *lang_new_vers_regex
d520 6
a525 2
boolean unique_section_p PARAMS ((const char *));
extern void lang_add_unique PARAMS ((const char *));
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d3 1
a3 1
   2001, 2002, 2003
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
d35 1
a35 4
struct _fill_type {
  size_t size;
  unsigned char data[1];
};
d51 1
a51 1
  bfd_boolean had_full_message;
d109 1
a109 1
  bfd_boolean used;
d120 1
a120 1
  bfd_boolean processed;
d128 1
a128 1
  fill_type *fill;
a134 6
  /* If non-null, an expression to evaluate after setting the section's
     size.  The expression is evaluated inside REGION (above) with '.'
     set to the end of the section.  Used in the last overlay section
     to move '.' past all the overlaid sections.  */
  union etree_union *update_dot_tree;

d148 1
a148 1
  fill_type *fill;
d205 1
a205 1
  bfd_boolean closed;
d219 1
a219 1
  bfd_boolean is_archive;
d222 1
a222 7
  bfd_boolean search_dirs_flag;

  /* 1 means this was found in a search directory marked as sysrooted,
     if search_dirs_flag is false, otherwise, that it should be
     searched in ld_sysroot before any other location, as long as it
     starts with a slash.  */
  bfd_boolean sysrooted;
d228 1
a228 1
  bfd_boolean just_syms_flag;
d231 1
a231 1
  bfd_boolean dynamic;
d234 1
a234 1
  bfd_boolean whole_archive;
d236 1
a236 1
  bfd_boolean loaded;
d242 1
a242 1
  bfd_boolean real;
d260 2
d263 3
a265 3
  bfd_boolean filenames_sorted;
  struct wildcard_list *section_list;
  bfd_boolean keep_sections;
d280 1
a280 1
  fill_type *fill;
d295 1
d321 2
a322 2
  bfd_boolean filehdr;
  bfd_boolean phdrs;
d356 1
a356 1
extern bfd_boolean lang_has_input_file;
d359 1
a359 1
extern bfd_boolean delete_output_file_on_failure;
d361 2
a362 3
extern struct bfd_sym_chain entry_symbol;
extern const char *entry_section;
extern bfd_boolean entry_from_cmdline;
d365 1
a365 2
extern void lang_init
  PARAMS ((void));
d370 4
a373 6
extern void lang_map
  PARAMS ((void));
extern void lang_set_flags
  PARAMS ((lang_memory_region_type *, const char *, int));
extern void lang_add_output
  PARAMS ((const char *, int from_script));
d376 1
a376 1
	   etree_type *address_exp,
d382 5
a386 10
extern void lang_final
  PARAMS ((void));
extern void lang_process
  PARAMS ((void));
extern void lang_section_start
  PARAMS ((const char *, union etree_union *));
extern void lang_add_entry
  PARAMS ((const char *, bfd_boolean));
extern void lang_add_target
  PARAMS ((const char *));
d388 7
a394 13
  PARAMS ((struct wildcard_spec *, struct wildcard_list *, bfd_boolean));
extern void lang_add_map
  PARAMS ((const char *));
extern void lang_add_fill
  PARAMS ((fill_type *));
extern lang_assignment_statement_type * lang_add_assignment
  PARAMS ((union etree_union *));
extern void lang_add_attribute
  PARAMS ((enum statement_enum));
extern void lang_startup
  PARAMS ((const char *));
extern void lang_float
  PARAMS ((bfd_boolean));
d396 1
a396 1
  PARAMS ((fill_type *, const char *, struct lang_output_section_phdr_list *,
d398 6
a403 7
extern void lang_abs_symbol_at_end_of
  PARAMS ((const char *, const char *));
extern void lang_abs_symbol_at_beginning_of
  PARAMS ((const char *, const char *));
extern void lang_statement_append
  PARAMS ((struct statement_list *, union lang_statement_union *,
	   union lang_statement_union **));
a407 2
extern void lang_reset_memory_regions
  PARAMS ((void));
d411 1
a411 1
	   fill_type *fill,
d414 8
a421 10
#define LANG_FOR_EACH_INPUT_STATEMENT(statement)			\
  lang_input_statement_type *statement;					\
  for (statement = (lang_input_statement_type *) file_chain.head;	\
       statement != (lang_input_statement_type *) NULL;			\
       statement = (lang_input_statement_type *) statement->next)	\

extern void lang_process
  PARAMS ((void));
extern void ldlang_add_file
  PARAMS ((lang_input_statement_type *));
d427 1
a427 2
extern void lang_add_keepsyms_file
  PARAMS ((const char *filename));
d429 6
a434 10
  lang_output_section_statement_lookup
  PARAMS ((const char * const name));
extern void ldlang_add_undef
  PARAMS ((const char *const name));
extern void lang_add_output_format
  PARAMS ((const char *, const char *, const char *, int from_script));
extern void lang_list_init
  PARAMS ((lang_statement_list_type*));
extern void lang_add_data
  PARAMS ((int type, union etree_union *));
d440 2
a441 4
extern PTR stat_alloc
  PARAMS ((size_t size));
extern void dprint_statement
  PARAMS ((lang_statement_union_type *, int));
d445 5
a449 7
	   lang_statement_union_type **prev, fill_type *fill,
	   bfd_vma dot, bfd_boolean *relax, bfd_boolean check_regions));
extern void lang_enter_group
  PARAMS ((void));
extern void lang_leave_group
  PARAMS ((void));
extern void lang_add_section
d454 1
a454 1
  PARAMS ((const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,
d456 3
a458 6
extern void lang_add_nocrossref
  PARAMS ((struct lang_nocrossref *));
extern void lang_enter_overlay
  PARAMS ((etree_type *));
extern void lang_enter_overlay_section
  PARAMS ((const char *));
d460 1
a460 1
  PARAMS ((fill_type *, struct lang_output_section_phdr_list *));
d462 2
a463 2
  PARAMS ((etree_type *, int, fill_type *, const char *,
	   struct lang_output_section_phdr_list *, const char *));
d467 1
a467 1
extern struct bfd_elf_version_expr *lang_new_vers_pattern
d476 2
a477 6
bfd_boolean unique_section_p
  PARAMS ((const char *));
extern void lang_add_unique
  PARAMS ((const char *));
extern const char *lang_get_output_target
  PARAMS ((void));
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
d26 1
a26 4
#define DEFAULT_MEMORY_REGION   "*default*"

typedef enum
{
d35 1
a35 2
struct _fill_type
{
d40 1
a40 2
typedef struct statement_list
{
d45 1
a45 2
typedef struct memory_region_struct
{
d57 1
a57 2
typedef struct lang_statement_header_struct
{
d59 1
a59 2
  enum statement_enum
  {
d80 1
a80 2
typedef struct
{
d85 1
a85 2
typedef struct lang_target_statement_struct
{
d90 1
a90 2
typedef struct lang_output_statement_struct
{
d97 1
a97 2
enum section_type
{
d106 2
a107 2
/* This structure holds a list of program headers describing
   segments in which this section should be placed.  */
d109 1
a109 2
typedef struct lang_output_section_phdr_list
{
d113 1
a113 1
} lang_output_section_phdr_list;
d115 1
a115 2
typedef struct lang_output_section_statement_struct
{
d123 1
a123 1
  int processed;
d126 1
a126 1
  flagword flags;		/* Or together of all input sections.  */
d128 2
a129 2
  lang_memory_region_type *region;
  lang_memory_region_type *lma_region;
d133 2
a134 2
  int subsection_alignment;	/* Alignment of components.  */
  int section_alignment;	/* Alignment of start of section.  */
d144 1
a144 1
  lang_output_section_phdr_list *phdrs;
d147 1
a147 2
typedef struct
{
d151 1
a151 2
typedef struct
{
d155 1
a155 2
typedef struct
{
d162 1
a162 2
typedef struct
{
d173 1
a173 2
typedef struct
{
d182 2
a183 2
  /* Section to generate reloc against.
     Exactly one of section and name must be NULL.  */
d186 2
a187 2
  /* Name of symbol to generate reloc against.
     Exactly one of section and name must be NULL.  */
d203 1
a203 2
typedef struct lang_input_statement_struct
{
d207 3
a209 3
  /* Name to use for the symbol giving address of text start.
     Usually the same as filename, but for a file spec'd with
     -l this is the -l switch itself rather than the filename.  */
d223 1
d225 1
a225 2

  /* Point to the next file, but skips archive contents.  */
d242 1
a247 4
  /* Whether this entry should cause a DT_NEEDED tag only when
     satisfying references from regular files, or always.  */
  bfd_boolean as_needed;

d260 1
a260 2
typedef struct
{
d267 1
a267 2
typedef struct
{
d273 1
a273 2
typedef struct lang_wild_statement_struct
{
d282 1
a282 2
typedef struct lang_address_statement_struct
{
d288 1
a288 2
typedef struct
{
d301 1
a301 2
typedef struct
{
d306 1
a306 2
typedef union lang_statement_union
{
d329 1
a329 2
struct lang_phdr
{
d342 1
a342 2
typedef struct lang_nocrossref
{
d345 1
a345 1
} lang_nocrossref_type;
d349 1
a349 2
struct lang_nocrossrefs
{
d351 1
a351 1
  lang_nocrossref_type *list;
d359 1
a359 2
struct unique_sections
{
a363 9
/* This structure records symbols for which we need to keep track of
   definedness for use in the DEFINED () test.  */

struct lang_definedness_hash_entry
{
  struct bfd_hash_entry root;
  int iteration;
};

a377 2
extern int lang_statement_iteration;

d379 5
a383 5
  (void);
extern lang_memory_region_type *lang_memory_region_lookup
  (const char *const, bfd_boolean);
extern lang_memory_region_type *lang_memory_region_default
  (asection *);
d385 1
a385 1
  (void);
d387 1
a387 1
  (lang_memory_region_type *, const char *, int);
d389 1
a389 1
  (const char *, int from_script);
d391 7
a397 6
  (const char *output_section_statement_name,
   etree_type *address_exp,
   enum section_type sectype,
   etree_type *align,
   etree_type *subalign,
   etree_type *);
d399 1
a399 1
  (void);
d401 1
a401 1
  (void);
d403 1
a403 1
  (const char *, union etree_union *);
d405 1
a405 1
  (const char *, bfd_boolean);
d407 1
a407 1
  (const char *);
d409 1
a409 1
  (struct wildcard_spec *, struct wildcard_list *, bfd_boolean);
d411 1
a411 1
  (const char *);
d413 3
a415 3
  (fill_type *);
extern lang_assignment_statement_type *lang_add_assignment
  (union etree_union *);
d417 1
a417 1
  (enum statement_enum);
d419 1
a419 1
  (const char *);
d421 1
a421 1
  (bfd_boolean);
d423 2
a424 2
  (fill_type *, const char *, lang_output_section_phdr_list *,
   const char *);
d426 1
a426 1
  (const char *, const char *);
d428 1
a428 1
  (const char *, const char *);
d430 2
a431 2
  (lang_statement_list_type *, lang_statement_union_type *,
   lang_statement_union_type **);
d433 1
a433 1
  (void (*dothis) (lang_input_statement_type *));
d435 1
a435 1
  (void (*dothis) (lang_input_statement_type *));
d437 6
a442 4
  (void);
extern void lang_do_assignments
  (lang_statement_union_type *, lang_output_section_statement_type *,
   fill_type *, bfd_vma);
d451 1
a451 1
  (void);
d453 1
a453 1
  (lang_input_statement_type *);
d455 1
a455 1
  (const char * const);
d457 2
a458 1
  (const char *, lang_input_file_enum_type, const char *);
d460 1
a460 1
  (const char *);
d463 1
a463 1
  (const char *const);
d465 1
a465 1
  (const char *const);
d467 1
a467 1
  (const char *, const char *, const char *, int);
d469 1
a469 1
  (lang_statement_list_type *);
d471 1
a471 1
  (int type, union etree_union *);
d473 2
a474 2
  (bfd_reloc_code_real_type, reloc_howto_type *, asection *, const char *,
   union etree_union *);
d476 3
a478 3
  (void (*) (lang_statement_union_type *));
extern void *stat_alloc
  (size_t);
d480 1
a480 1
  (lang_statement_union_type *, int);
d482 4
a485 3
  (lang_statement_union_type *, lang_output_section_statement_type *,
   lang_statement_union_type **, fill_type *, bfd_vma, bfd_boolean *,
   bfd_boolean);
d487 1
a487 1
  (void);
d489 1
a489 1
  (void);
d491 3
a493 2
  (lang_statement_list_type *, asection *,
   lang_output_section_statement_type *, lang_input_statement_type *);
d495 2
a496 2
  (const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,
   etree_type *);
d498 1
a498 1
  (lang_nocrossref_type *);
d500 1
a500 1
  (etree_type *, etree_type *);
d502 1
a502 1
  (const char *);
d504 1
a504 1
  (fill_type *, lang_output_section_phdr_list *);
d506 2
a507 2
  (etree_type *, int, fill_type *, const char *,
   lang_output_section_phdr_list *, const char *);
d512 1
a512 1
  (struct bfd_elf_version_expr *, const char *, const char *);
d514 1
a514 1
  (struct bfd_elf_version_expr *, struct bfd_elf_version_expr *);
d516 1
a516 1
  (struct bfd_elf_version_deps *, const char *);
d518 2
a519 1
  (const char *, struct bfd_elf_version_tree *, struct bfd_elf_version_deps *);
d521 1
a521 1
  (const char *);
d523 1
a523 1
  (const char *);
d525 1
a525 5
  (void);
extern void lang_track_definedness (const char *);
extern int lang_symbol_definition_iteration (const char *);
extern void lang_update_definedness
  (const char *, struct bfd_link_hash_entry *);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d3 1
a3 1
   2001, 2002, 2003
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
d35 1
a35 4
struct _fill_type {
  size_t size;
  unsigned char data[1];
};
d51 1
a51 1
  bfd_boolean had_full_message;
d109 1
a109 1
  bfd_boolean used;
d120 1
a120 1
  bfd_boolean processed;
d128 1
a128 1
  fill_type *fill;
a134 6
  /* If non-null, an expression to evaluate after setting the section's
     size.  The expression is evaluated inside REGION (above) with '.'
     set to the end of the section.  Used in the last overlay section
     to move '.' past all the overlaid sections.  */
  union etree_union *update_dot_tree;

d148 1
a148 1
  fill_type *fill;
d205 1
a205 1
  bfd_boolean closed;
d219 1
a219 1
  bfd_boolean is_archive;
d222 1
a222 7
  bfd_boolean search_dirs_flag;

  /* 1 means this was found in a search directory marked as sysrooted,
     if search_dirs_flag is false, otherwise, that it should be
     searched in ld_sysroot before any other location, as long as it
     starts with a slash.  */
  bfd_boolean sysrooted;
d228 1
a228 1
  bfd_boolean just_syms_flag;
d231 1
a231 1
  bfd_boolean dynamic;
d234 1
a234 1
  bfd_boolean whole_archive;
d236 1
a236 1
  bfd_boolean loaded;
d242 1
a242 1
  bfd_boolean real;
d260 2
d263 3
a265 3
  bfd_boolean filenames_sorted;
  struct wildcard_list *section_list;
  bfd_boolean keep_sections;
d280 1
a280 1
  fill_type *fill;
d295 1
d321 2
a322 2
  bfd_boolean filehdr;
  bfd_boolean phdrs;
d356 1
a356 1
extern bfd_boolean lang_has_input_file;
d359 1
a359 1
extern bfd_boolean delete_output_file_on_failure;
d361 2
a362 3
extern struct bfd_sym_chain entry_symbol;
extern const char *entry_section;
extern bfd_boolean entry_from_cmdline;
d365 1
a365 2
extern void lang_init
  PARAMS ((void));
d370 4
a373 6
extern void lang_map
  PARAMS ((void));
extern void lang_set_flags
  PARAMS ((lang_memory_region_type *, const char *, int));
extern void lang_add_output
  PARAMS ((const char *, int from_script));
d376 1
a376 1
	   etree_type *address_exp,
d382 5
a386 10
extern void lang_final
  PARAMS ((void));
extern void lang_process
  PARAMS ((void));
extern void lang_section_start
  PARAMS ((const char *, union etree_union *));
extern void lang_add_entry
  PARAMS ((const char *, bfd_boolean));
extern void lang_add_target
  PARAMS ((const char *));
d388 7
a394 13
  PARAMS ((struct wildcard_spec *, struct wildcard_list *, bfd_boolean));
extern void lang_add_map
  PARAMS ((const char *));
extern void lang_add_fill
  PARAMS ((fill_type *));
extern lang_assignment_statement_type * lang_add_assignment
  PARAMS ((union etree_union *));
extern void lang_add_attribute
  PARAMS ((enum statement_enum));
extern void lang_startup
  PARAMS ((const char *));
extern void lang_float
  PARAMS ((bfd_boolean));
d396 1
a396 1
  PARAMS ((fill_type *, const char *, struct lang_output_section_phdr_list *,
d398 6
a403 7
extern void lang_abs_symbol_at_end_of
  PARAMS ((const char *, const char *));
extern void lang_abs_symbol_at_beginning_of
  PARAMS ((const char *, const char *));
extern void lang_statement_append
  PARAMS ((struct statement_list *, union lang_statement_union *,
	   union lang_statement_union **));
a407 2
extern void lang_reset_memory_regions
  PARAMS ((void));
d411 1
a411 1
	   fill_type *fill,
d414 8
a421 10
#define LANG_FOR_EACH_INPUT_STATEMENT(statement)			\
  lang_input_statement_type *statement;					\
  for (statement = (lang_input_statement_type *) file_chain.head;	\
       statement != (lang_input_statement_type *) NULL;			\
       statement = (lang_input_statement_type *) statement->next)	\

extern void lang_process
  PARAMS ((void));
extern void ldlang_add_file
  PARAMS ((lang_input_statement_type *));
d427 1
a427 2
extern void lang_add_keepsyms_file
  PARAMS ((const char *filename));
d429 6
a434 10
  lang_output_section_statement_lookup
  PARAMS ((const char * const name));
extern void ldlang_add_undef
  PARAMS ((const char *const name));
extern void lang_add_output_format
  PARAMS ((const char *, const char *, const char *, int from_script));
extern void lang_list_init
  PARAMS ((lang_statement_list_type*));
extern void lang_add_data
  PARAMS ((int type, union etree_union *));
d440 2
a441 4
extern PTR stat_alloc
  PARAMS ((size_t size));
extern void dprint_statement
  PARAMS ((lang_statement_union_type *, int));
d445 5
a449 7
	   lang_statement_union_type **prev, fill_type *fill,
	   bfd_vma dot, bfd_boolean *relax, bfd_boolean check_regions));
extern void lang_enter_group
  PARAMS ((void));
extern void lang_leave_group
  PARAMS ((void));
extern void lang_add_section
d454 1
a454 1
  PARAMS ((const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,
d456 3
a458 6
extern void lang_add_nocrossref
  PARAMS ((struct lang_nocrossref *));
extern void lang_enter_overlay
  PARAMS ((etree_type *));
extern void lang_enter_overlay_section
  PARAMS ((const char *));
d460 1
a460 1
  PARAMS ((fill_type *, struct lang_output_section_phdr_list *));
d462 2
a463 2
  PARAMS ((etree_type *, int, fill_type *, const char *,
	   struct lang_output_section_phdr_list *, const char *));
d467 1
a467 1
extern struct bfd_elf_version_expr *lang_new_vers_pattern
d476 2
a477 6
bfd_boolean unique_section_p
  PARAMS ((const char *));
extern void lang_add_unique
  PARAMS ((const char *));
extern const char *lang_get_output_target
  PARAMS ((void));
@

