head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	ctm-3255:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.21.20.03;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.05.32;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.00;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.41.00;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.25.04;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.43.18;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.08.40;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.18.09;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@%{ /* deffilep.y - parser for .def files */

/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003
     Free Software Foundation, Inc.

     This file is part of GNU Binutils.

     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include <stdio.h>
#include "libiberty.h"
#include "safe-ctype.h"
#include "bfd.h"
#include "sysdep.h"
#include "ld.h"
#include "ldmisc.h"
#include "deffile.h"

#define TRACE 0

#define ROUND_UP(a, b) (((a)+((b)-1))&~((b)-1))

/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
   as well as gratuitiously global symbol names, so we can have multiple
   yacc generated parsers in ld.  Note that these are only the variables
   produced by yacc.  If other parser generators (bison, byacc, etc) produce
   additional global names that conflict at link time, then those parser
   generators need to be fixed instead of adding those names to this list.  */

#define	yymaxdepth def_maxdepth
#define	yyparse	def_parse
#define	yylex	def_lex
#define	yyerror	def_error
#define	yylval	def_lval
#define	yychar	def_char
#define	yydebug	def_debug
#define	yypact	def_pact	
#define	yyr1	def_r1			
#define	yyr2	def_r2			
#define	yydef	def_def		
#define	yychk	def_chk		
#define	yypgo	def_pgo		
#define	yyact	def_act		
#define	yyexca	def_exca
#define yyerrflag def_errflag
#define yynerrs	def_nerrs
#define	yyps	def_ps
#define	yypv	def_pv
#define	yys	def_s
#define	yy_yys	def_yys
#define	yystate	def_state
#define	yytmp	def_tmp
#define	yyv	def_v
#define	yy_yyv	def_yyv
#define	yyval	def_val
#define	yylloc	def_lloc
#define yyreds	def_reds		/* With YYDEBUG defined.  */
#define yytoks	def_toks		/* With YYDEBUG defined.  */
#define yylhs	def_yylhs
#define yylen	def_yylen
#define yydefred def_yydefred
#define yydgoto	def_yydgoto
#define yysindex def_yysindex
#define yyrindex def_yyrindex
#define yygindex def_yygindex
#define yytable	 def_yytable
#define yycheck	 def_yycheck

static void def_description PARAMS ((const char *));
static void def_exports PARAMS ((const char *, const char *, int, int));
static void def_heapsize PARAMS ((int, int));
static void def_import PARAMS ((const char *, const char *, const char *, const char *, int));
static void def_library PARAMS ((const char *, int));
static def_file_module *def_stash_module PARAMS ((def_file *, const char *));
static void def_name PARAMS ((const char *, int));
static void def_section PARAMS ((const char *, int));
static void def_section_alt PARAMS ((const char *, const char *));
static void def_stacksize PARAMS ((int, int));
static void def_version PARAMS ((int, int));
static void def_directive PARAMS ((char *));
static int def_parse PARAMS ((void));
static int def_error PARAMS ((const char *));
static void put_buf PARAMS ((char));
static int def_getc PARAMS ((void));
static int def_ungetc PARAMS ((int));
static int def_lex PARAMS ((void));

static int lex_forced_token = 0;
static const char *lex_parse_string = 0;
static const char *lex_parse_string_end = 0;

%}

%union {
  char *id;
  int number;
};

%token NAME, LIBRARY, DESCRIPTION, STACKSIZE, HEAPSIZE, CODE, DATAU, DATAL
%token SECTIONS, EXPORTS, IMPORTS, VERSIONK, BASE, CONSTANTU, CONSTANTL
%token PRIVATEU, PRIVATEL
%token READ WRITE EXECUTE SHARED NONAMEU NONAMEL DIRECTIVE
%token <id> ID
%token <number> NUMBER
%type  <number> opt_base opt_ordinal
%type  <number> attr attr_list opt_number exp_opt_list exp_opt
%type  <id> opt_name opt_equal_name dot_name 

%%

start: start command
	| command
	;

command: 
		NAME opt_name opt_base { def_name ($2, $3); }
	|	LIBRARY opt_name opt_base { def_library ($2, $3); }
	|	DESCRIPTION ID { def_description ($2);}
	|	STACKSIZE NUMBER opt_number { def_stacksize ($2, $3);}
	|	HEAPSIZE NUMBER opt_number { def_heapsize ($2, $3);}
	|	CODE attr_list { def_section ("CODE", $2);}
	|	DATAU attr_list  { def_section ("DATA", $2);}
	|	SECTIONS seclist
	|	EXPORTS explist 
	|	IMPORTS implist
	|	VERSIONK NUMBER { def_version ($2, 0);}
	|	VERSIONK NUMBER '.' NUMBER { def_version ($2, $4);}
	|	DIRECTIVE ID { def_directive ($2);}
	;


explist:
		/* EMPTY */
	|	expline
	|	explist expline
	;

expline:
		/* The opt_comma is necessary to support both the usual
		  DEF file syntax as well as .drectve syntax which
		  mandates <expsym>,<expoptlist>.  */
		dot_name opt_equal_name opt_ordinal opt_comma exp_opt_list
			{ def_exports ($1, $2, $3, $5); }
	;
exp_opt_list:
		/* The opt_comma is necessary to support both the usual
		   DEF file syntax as well as .drectve syntax which
		   allows for comma separated opt list.  */
		exp_opt opt_comma exp_opt_list { $$ = $1 | $3; }
	|	{ $$ = 0; }
	;
exp_opt:
		NONAMEU		{ $$ = 1; }
	|	NONAMEL		{ $$ = 1; }
	|	CONSTANTU	{ $$ = 2; }
	|	CONSTANTL	{ $$ = 2; }
	|	DATAU		{ $$ = 4; }
	|	DATAL		{ $$ = 4; }
	|	PRIVATEU	{ $$ = 8; }
	|	PRIVATEL	{ $$ = 8; }
	;
implist:	
		implist impline
	|	impline
	;

impline:
               ID '=' ID '.' ID '.' ID     { def_import ($1, $3, $5, $7, -1); }
       |       ID '=' ID '.' ID '.' NUMBER { def_import ($1, $3, $5,  0, $7); }
       |       ID '=' ID '.' ID            { def_import ($1, $3,  0, $5, -1); }
       |       ID '=' ID '.' NUMBER        { def_import ($1, $3,  0,  0, $5); }
       |       ID '.' ID '.' ID            { def_import ( 0, $1, $3, $5, -1); }
       |       ID '.' ID                   { def_import ( 0, $1,  0, $3, -1); }
;

seclist:
		seclist secline
	|	secline
	;

secline:
	ID attr_list { def_section ($1, $2);}
	| ID ID { def_section_alt ($1, $2);}
	;

attr_list:
	attr_list opt_comma attr { $$ = $1 | $3; }
	| attr { $$ = $1; }
	;

opt_comma:
	','
	| 
	;
opt_number: ',' NUMBER { $$=$2;}
	|	   { $$=-1;}
	;
	
attr:
		READ	{ $$ = 1;}
	|	WRITE	{ $$ = 2;}	
	|	EXECUTE	{ $$=4;}
	|	SHARED	{ $$=8;}
	;

opt_name: ID		{ $$ = $1; }
	| ID '.' ID	
	  { 
	    char * name = xmalloc (strlen ($1) + 1 + strlen ($3) + 1);
	    sprintf (name, "%s.%s", $1, $3);
	    $$ = name;
	  }
	|		{ $$ = ""; }
	;

opt_ordinal: 
	  '@@' NUMBER     { $$ = $2;}
	|                { $$ = -1;}
	;

opt_equal_name:
          '=' dot_name	{ $$ = $2; }
        | 		{ $$ =  0; }			 
	;

opt_base: BASE	'=' NUMBER	{ $$ = $3;}
	|	{ $$ = -1;}
	;

dot_name: ID		{ $$ = $1; }
	| dot_name '.' ID	
	  { 
	    char * name = xmalloc (strlen ($1) + 1 + strlen ($3) + 1);
	    sprintf (name, "%s.%s", $1, $3);
	    $$ = name;
	  }
	;
	

%%

/*****************************************************************************
 API
 *****************************************************************************/

static FILE *the_file;
static const char *def_filename;
static int linenumber;
static def_file *def;
static int saw_newline;

struct directive
  {
    struct directive *next;
    char *name;
    int len;
  };

static struct directive *directives = 0;

def_file *
def_file_empty ()
{
  def_file *rv = (def_file *) xmalloc (sizeof (def_file));
  memset (rv, 0, sizeof (def_file));
  rv->is_dll = -1;
  rv->base_address = (bfd_vma) (-1);
  rv->stack_reserve = rv->stack_commit = -1;
  rv->heap_reserve = rv->heap_commit = -1;
  rv->version_major = rv->version_minor = -1;
  return rv;
}

def_file *
def_file_parse (filename, add_to)
     const char *filename;
     def_file *add_to;
{
  struct directive *d;

  the_file = fopen (filename, "r");
  def_filename = filename;
  linenumber = 1;
  if (!the_file)
    {
      perror (filename);
      return 0;
    }
  if (add_to)
    {
      def = add_to;
    }
  else
    {
      def = def_file_empty ();
    }

  saw_newline = 1;
  if (def_parse ())
    {
      def_file_free (def);
      fclose (the_file);
      return 0;
    }

  fclose (the_file);

  for (d = directives; d; d = d->next)
    {
#if TRACE
      printf ("Adding directive %08x `%s'\n", d->name, d->name);
#endif
      def_file_add_directive (def, d->name, d->len);
    }

  return def;
}

void
def_file_free (def)
     def_file *def;
{
  int i;

  if (!def)
    return;
  if (def->name)
    free (def->name);
  if (def->description)
    free (def->description);

  if (def->section_defs)
    {
      for (i = 0; i < def->num_section_defs; i++)
	{
	  if (def->section_defs[i].name)
	    free (def->section_defs[i].name);
	  if (def->section_defs[i].class)
	    free (def->section_defs[i].class);
	}
      free (def->section_defs);
    }

  if (def->exports)
    {
      for (i = 0; i < def->num_exports; i++)
	{
	  if (def->exports[i].internal_name
	      && def->exports[i].internal_name != def->exports[i].name)
	    free (def->exports[i].internal_name);
	  if (def->exports[i].name)
	    free (def->exports[i].name);
	}
      free (def->exports);
    }

  if (def->imports)
    {
      for (i = 0; i < def->num_imports; i++)
	{
	  if (def->imports[i].internal_name
	      && def->imports[i].internal_name != def->imports[i].name)
	    free (def->imports[i].internal_name);
	  if (def->imports[i].name)
	    free (def->imports[i].name);
	}
      free (def->imports);
    }

  while (def->modules)
    {
      def_file_module *m = def->modules;
      def->modules = def->modules->next;
      free (m);
    }

  free (def);
}

#ifdef DEF_FILE_PRINT
void
def_file_print (file, def)
     FILE *file;
     def_file *def;
{
  int i;

  fprintf (file, ">>>> def_file at 0x%08x\n", def);
  if (def->name)
    fprintf (file, "  name: %s\n", def->name ? def->name : "(unspecified)");
  if (def->is_dll != -1)
    fprintf (file, "  is dll: %s\n", def->is_dll ? "yes" : "no");
  if (def->base_address != (bfd_vma) (-1))
    fprintf (file, "  base address: 0x%08x\n", def->base_address);
  if (def->description)
    fprintf (file, "  description: `%s'\n", def->description);
  if (def->stack_reserve != -1)
    fprintf (file, "  stack reserve: 0x%08x\n", def->stack_reserve);
  if (def->stack_commit != -1)
    fprintf (file, "  stack commit: 0x%08x\n", def->stack_commit);
  if (def->heap_reserve != -1)
    fprintf (file, "  heap reserve: 0x%08x\n", def->heap_reserve);
  if (def->heap_commit != -1)
    fprintf (file, "  heap commit: 0x%08x\n", def->heap_commit);

  if (def->num_section_defs > 0)
    {
      fprintf (file, "  section defs:\n");

      for (i = 0; i < def->num_section_defs; i++)
	{
	  fprintf (file, "    name: `%s', class: `%s', flags:",
		   def->section_defs[i].name, def->section_defs[i].class);
	  if (def->section_defs[i].flag_read)
	    fprintf (file, " R");
	  if (def->section_defs[i].flag_write)
	    fprintf (file, " W");
	  if (def->section_defs[i].flag_execute)
	    fprintf (file, " X");
	  if (def->section_defs[i].flag_shared)
	    fprintf (file, " S");
	  fprintf (file, "\n");
	}
    }

  if (def->num_exports > 0)
    {
      fprintf (file, "  exports:\n");

      for (i = 0; i < def->num_exports; i++)
	{
	  fprintf (file, "    name: `%s', int: `%s', ordinal: %d, flags:",
		   def->exports[i].name, def->exports[i].internal_name,
		   def->exports[i].ordinal);
	  if (def->exports[i].flag_private)
	    fprintf (file, " P");
	  if (def->exports[i].flag_constant)
	    fprintf (file, " C");
	  if (def->exports[i].flag_noname)
	    fprintf (file, " N");
	  if (def->exports[i].flag_data)
	    fprintf (file, " D");
	  fprintf (file, "\n");
	}
    }

  if (def->num_imports > 0)
    {
      fprintf (file, "  imports:\n");

      for (i = 0; i < def->num_imports; i++)
	{
	  fprintf (file, "    int: %s, from: `%s', name: `%s', ordinal: %d\n",
		   def->imports[i].internal_name,
		   def->imports[i].module,
		   def->imports[i].name,
		   def->imports[i].ordinal);
	}
    }

  if (def->version_major != -1)
    fprintf (file, "  version: %d.%d\n", def->version_major, def->version_minor);

  fprintf (file, "<<<< def_file at 0x%08x\n", def);
}
#endif

def_file_export *
def_file_add_export (def, external_name, internal_name, ordinal)
     def_file *def;
     const char *external_name;
     const char *internal_name;
     int ordinal;
{
  def_file_export *e;
  int max_exports = ROUND_UP(def->num_exports, 32);

  if (def->num_exports >= max_exports)
    {
      max_exports = ROUND_UP(def->num_exports + 1, 32);
      if (def->exports)
	def->exports = (def_file_export *)
	  xrealloc (def->exports, max_exports * sizeof (def_file_export));
      else
	def->exports = (def_file_export *)
	  xmalloc (max_exports * sizeof (def_file_export));
    }
  e = def->exports + def->num_exports;
  memset (e, 0, sizeof (def_file_export));
  if (internal_name && !external_name)
    external_name = internal_name;
  if (external_name && !internal_name)
    internal_name = external_name;
  e->name = xstrdup (external_name);
  e->internal_name = xstrdup (internal_name);
  e->ordinal = ordinal;
  def->num_exports++;
  return e;
}

def_file_module *
def_get_module (def, name)
     def_file *def;
     const char *name;
{
  def_file_module *s;

  for (s = def->modules; s; s = s->next)
    if (strcmp (s->name, name) == 0)
      return s;

  return (def_file_module *) 0;
}

static def_file_module *
def_stash_module (def, name)
     def_file *def;
     const char *name;
{
  def_file_module *s;

  if ((s = def_get_module (def, name)) != (def_file_module *) 0)
      return s;
  s = (def_file_module *) xmalloc (sizeof (def_file_module) + strlen (name));
  s->next = def->modules;
  def->modules = s;
  s->user_data = 0;
  strcpy (s->name, name);
  return s;
}

def_file_import *
def_file_add_import (def, name, module, ordinal, internal_name)
     def_file *def;
     const char *name;
     const char *module;
     int ordinal;
     const char *internal_name;
{
  def_file_import *i;
  int max_imports = ROUND_UP(def->num_imports, 16);

  if (def->num_imports >= max_imports)
    {
      max_imports = ROUND_UP(def->num_imports+1, 16);

      if (def->imports)
	def->imports = (def_file_import *)
	  xrealloc (def->imports, max_imports * sizeof (def_file_import));
      else
	def->imports = (def_file_import *)
	  xmalloc (max_imports * sizeof (def_file_import));
    }
  i = def->imports + def->num_imports;
  memset (i, 0, sizeof (def_file_import));
  if (name)
    i->name = xstrdup (name);
  if (module)
    i->module = def_stash_module (def, module);
  i->ordinal = ordinal;
  if (internal_name)
    i->internal_name = xstrdup (internal_name);
  else
    i->internal_name = i->name;
  def->num_imports++;

  return i;
}

struct
{
  char *param;
  int token;
}
diropts[] =
{
  { "-heap", HEAPSIZE },
  { "-stack", STACKSIZE },
  { "-attr", SECTIONS },
  { "-export", EXPORTS },
  { 0, 0 }
};

void
def_file_add_directive (my_def, param, len)
     def_file *my_def;
     const char *param;
     int len;
{
  def_file *save_def = def;
  const char *pend = param + len;
  const char *tend = param;
  int i;

  def = my_def;

  while (param < pend)
    {
      while (param < pend && ISSPACE (*param))
	param++;

      for (tend = param + 1;
	   tend < pend && !(ISSPACE (tend[-1]) && *tend == '-');
	   tend++)
	;

      for (i = 0; diropts[i].param; i++)
	{
	  int len = strlen (diropts[i].param);

	  if (tend - param >= len
	      && strncmp (param, diropts[i].param, len) == 0
	      && (param[len] == ':' || param[len] == ' '))
	    {
	      lex_parse_string_end = tend;
	      lex_parse_string = param + len + 1;
	      lex_forced_token = diropts[i].token;
	      saw_newline = 0;
	      def_parse ();
	      break;
	    }
	}

      if (!diropts[i].param)
	/* xgettext:c-format */
	einfo (_("Warning: .drectve `%.*s' unrecognized\n"),
	       tend - param, param);

      lex_parse_string = 0;
      param = tend;
    }

  def = save_def;
}

/* Parser Callbacks.  */

static void
def_name (name, base)
     const char *name;
     int base;
{
  if (def->name)
    free (def->name);
  def->name = xstrdup (name);
  def->base_address = base;
  def->is_dll = 0;
}

static void
def_library (name, base)
     const char *name;
     int base;
{
  if (def->name)
    free (def->name);
  def->name = xstrdup (name);
  def->base_address = base;
  def->is_dll = 1;
}

static void
def_description (text)
     const char *text;
{
  int len = def->description ? strlen (def->description) : 0;

  len += strlen (text) + 1;
  if (def->description)
    {
      def->description = (char *) xrealloc (def->description, len);
      strcat (def->description, text);
    }
  else
    {
      def->description = (char *) xmalloc (len);
      strcpy (def->description, text);
    }
}

static void
def_stacksize (reserve, commit)
     int reserve;
     int commit;
{
  def->stack_reserve = reserve;
  def->stack_commit = commit;
}

static void
def_heapsize (reserve, commit)
     int reserve;
     int commit;
{
  def->heap_reserve = reserve;
  def->heap_commit = commit;
}

static void
def_section (name, attr)
     const char *name;
     int attr;
{
  def_file_section *s;
  int max_sections = ROUND_UP(def->num_section_defs, 4);

  if (def->num_section_defs >= max_sections)
    {
      max_sections = ROUND_UP(def->num_section_defs+1, 4);

      if (def->section_defs)
	def->section_defs = (def_file_section *) xrealloc (def->section_defs, max_sections * sizeof (def_file_import));
      else
	def->section_defs = (def_file_section *) xmalloc (max_sections * sizeof (def_file_import));
    }
  s = def->section_defs + def->num_section_defs;
  memset (s, 0, sizeof (def_file_section));
  s->name = xstrdup (name);
  if (attr & 1)
    s->flag_read = 1;
  if (attr & 2)
    s->flag_write = 1;
  if (attr & 4)
    s->flag_execute = 1;
  if (attr & 8)
    s->flag_shared = 1;

  def->num_section_defs++;
}

static void
def_section_alt (name, attr)
     const char *name;
     const char *attr;
{
  int aval = 0;

  for (; *attr; attr++)
    {
      switch (*attr)
	{
	case 'R':
	case 'r':
	  aval |= 1;
	  break;
	case 'W':
	case 'w':
	  aval |= 2;
	  break;
	case 'X':
	case 'x':
	  aval |= 4;
	  break;
	case 'S':
	case 's':
	  aval |= 8;
	  break;
	}
    }
  def_section (name, aval);
}

static void
def_exports (external_name, internal_name, ordinal, flags)
     const char *external_name;
     const char *internal_name;
     int ordinal;
     int flags;
{
  def_file_export *dfe;

  if (!internal_name && external_name)
    internal_name = external_name;
#if TRACE
  printf ("def_exports, ext=%s int=%s\n", external_name, internal_name);
#endif

  dfe = def_file_add_export (def, external_name, internal_name, ordinal);
  if (flags & 1)
    dfe->flag_noname = 1;
  if (flags & 2)
    dfe->flag_constant = 1;
  if (flags & 4)
    dfe->flag_data = 1;
  if (flags & 8)
    dfe->flag_private = 1;
}

static void
def_import (internal_name, module, dllext, name, ordinal)
     const char *internal_name;
     const char *module;
     const char *dllext;
     const char *name;
     int ordinal;
{
  char *buf = 0;
  const char *ext = dllext ? dllext : "dll";    
   
  buf = (char *) xmalloc (strlen (module) + strlen (ext) + 2);
  sprintf (buf, "%s.%s", module, ext);
  module = buf;

  def_file_add_import (def, name, module, ordinal, internal_name);
  if (buf)
    free (buf);
}

static void
def_version (major, minor)
     int major;
     int minor;
{
  def->version_major = major;
  def->version_minor = minor;
}

static void
def_directive (str)
     char *str;
{
  struct directive *d = (struct directive *) xmalloc (sizeof (struct directive));

  d->next = directives;
  directives = d;
  d->name = xstrdup (str);
  d->len = strlen (str);
}

static int
def_error (err)
     const char *err;
{
  einfo ("%P: %s:%d: %s\n", def_filename, linenumber, err);

  return 0;
}


/* Lexical Scanner.  */

#undef TRACE
#define TRACE 0

/* Never freed, but always reused as needed, so no real leak.  */
static char *buffer = 0;
static int buflen = 0;
static int bufptr = 0;

static void
put_buf (c)
     char c;
{
  if (bufptr == buflen)
    {
      buflen += 50;		/* overly reasonable, eh?  */
      if (buffer)
	buffer = (char *) xrealloc (buffer, buflen + 1);
      else
	buffer = (char *) xmalloc (buflen + 1);
    }
  buffer[bufptr++] = c;
  buffer[bufptr] = 0;		/* not optimal, but very convenient.  */
}

static struct
{
  char *name;
  int token;
}
tokens[] =
{
  { "BASE", BASE },
  { "CODE", CODE },
  { "CONSTANT", CONSTANTU },
  { "constant", CONSTANTL },
  { "DATA", DATAU },
  { "data", DATAL },
  { "DESCRIPTION", DESCRIPTION },
  { "DIRECTIVE", DIRECTIVE },
  { "EXECUTE", EXECUTE },
  { "EXPORTS", EXPORTS },
  { "HEAPSIZE", HEAPSIZE },
  { "IMPORTS", IMPORTS },
  { "LIBRARY", LIBRARY },
  { "NAME", NAME },
  { "NONAME", NONAMEU },
  { "noname", NONAMEL },
  { "PRIVATE", PRIVATEU },
  { "private", PRIVATEL },
  { "READ", READ },
  { "SECTIONS", SECTIONS },
  { "SEGMENTS", SECTIONS },
  { "SHARED", SHARED },
  { "STACKSIZE", STACKSIZE },
  { "VERSION", VERSIONK },
  { "WRITE", WRITE },
  { 0, 0 }
};

static int
def_getc ()
{
  int rv;

  if (lex_parse_string)
    {
      if (lex_parse_string >= lex_parse_string_end)
	rv = EOF;
      else
	rv = *lex_parse_string++;
    }
  else
    {
      rv = fgetc (the_file);
    }
  if (rv == '\n')
    saw_newline = 1;
  return rv;
}

static int
def_ungetc (c)
     int c;
{
  if (lex_parse_string)
    {
      lex_parse_string--;
      return c;
    }
  else
    return ungetc (c, the_file);
}

static int
def_lex ()
{
  int c, i, q;

  if (lex_forced_token)
    {
      i = lex_forced_token;
      lex_forced_token = 0;
#if TRACE
      printf ("lex: forcing token %d\n", i);
#endif
      return i;
    }

  c = def_getc ();

  /* Trim leading whitespace.  */
  while (c != EOF && (c == ' ' || c == '\t') && saw_newline)
    c = def_getc ();

  if (c == EOF)
    {
#if TRACE
      printf ("lex: EOF\n");
#endif
      return 0;
    }

  if (saw_newline && c == ';')
    {
      do
	{
	  c = def_getc ();
	}
      while (c != EOF && c != '\n');
      if (c == '\n')
	return def_lex ();
      return 0;
    }

  /* Must be something else.  */
  saw_newline = 0;

  if (ISDIGIT (c))
    {
      bufptr = 0;
      while (c != EOF && (ISXDIGIT (c) || (c == 'x')))
	{
	  put_buf (c);
	  c = def_getc ();
	}
      if (c != EOF)
	def_ungetc (c);
      yylval.number = strtoul (buffer, 0, 0);
#if TRACE
      printf ("lex: `%s' returns NUMBER %d\n", buffer, yylval.number);
#endif
      return NUMBER;
    }

  if (ISALPHA (c) || strchr ("$:-_?@@", c))
    {
      bufptr = 0;
      q = c;
      put_buf (c);
      c = def_getc ();

      if (q == '@@')
	{
          if (ISBLANK (c) ) /* '@@' followed by whitespace.  */
	    return (q);
          else if (ISDIGIT (c)) /* '@@' followed by digit.  */
            {
	      def_ungetc (c);
              return (q);
	    }
#if TRACE
	  printf ("lex: @@ returns itself\n");
#endif
	}

      while (c != EOF && (ISALNUM (c) || strchr ("$:-_?/@@", c)))
	{
	  put_buf (c);
	  c = def_getc ();
	}
      if (c != EOF)
	def_ungetc (c);
      if (ISALPHA (q)) /* Check for tokens.  */
	{
          for (i = 0; tokens[i].name; i++)
	    if (strcmp (tokens[i].name, buffer) == 0)
	      {
#if TRACE
	        printf ("lex: `%s' is a string token\n", buffer);
#endif
	        return tokens[i].token;
	      }
	}
#if TRACE
      printf ("lex: `%s' returns ID\n", buffer);
#endif
      yylval.id = xstrdup (buffer);
      return ID;
    }

  if (c == '\'' || c == '"')
    {
      q = c;
      c = def_getc ();
      bufptr = 0;

      while (c != EOF && c != q)
	{
	  put_buf (c);
	  c = def_getc ();
	}
      yylval.id = xstrdup (buffer);
#if TRACE
      printf ("lex: `%s' returns ID\n", buffer);
#endif
      return ID;
    }

  if (c == '=' || c == '.' || c == ',')
    {
#if TRACE
      printf ("lex: `%c' returns itself\n", c);
#endif
      return c;
    }

  if (c == '\n')
    {
      linenumber++;
      saw_newline = 1;
    }

  /*printf ("lex: 0x%02x ignored\n", c); */
  return def_lex ();
}
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
/*   Copyright 1995, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d6 1
a6 1
This file is part of GNU Binutils.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a22 1
#include <ctype.h>
d24 1
d40 1
a40 1
   generators need to be fixed instead of adding those names to this list. */
d69 2
a70 2
#define yyreds	def_reds		/* With YYDEBUG defined */
#define yytoks	def_toks		/* With YYDEBUG defined */
a80 2
static int def_lex ();

d84 1
a84 2
static void def_import
  PARAMS ((const char *, const char *, const char *, const char *, int));
d86 1
d95 3
d119 1
a119 1
%type  <id> opt_name opt_equal_name 
d154 1
a154 1
		ID opt_equal_name opt_ordinal opt_comma exp_opt_list
d234 1
a234 1
          '=' ID	{ $$ = $2; }
d239 1
a239 1
	|	{ $$ = 0;}
d242 8
d336 1
d399 1
d421 1
d441 1
d462 1
d472 1
d475 1
d489 1
d492 1
a492 1
      max_exports = ROUND_UP(def->num_exports+1, 32);
d494 2
a495 1
	def->exports = (def_file_export *) xrealloc (def->exports, max_exports * sizeof (def_file_export));
d497 2
a498 1
	def->exports = (def_file_export *) xmalloc (max_exports * sizeof (def_file_export));
d513 14
d530 1
a530 1
     char *name;
d533 2
a534 2
  for (s=def->modules; s; s=s->next)
    if (strcmp (s->name, name) == 0)
d554 1
d558 1
d560 2
a561 1
	def->imports = (def_file_import *) xrealloc (def->imports, max_imports * sizeof (def_file_import));
d563 2
a564 1
	def->imports = (def_file_import *) xmalloc (max_imports * sizeof (def_file_import));
d571 1
a571 1
    i->module = def_stash_module(def, module);
d578 1
d611 1
a611 1
      while (param < pend && isspace (*param))
d613 1
d615 3
a617 2
	   tend < pend && !(isspace (tend[-1]) && *tend == '-');
	   tend++);
d622 1
d637 4
a640 5
	{
	  /* xgettext:c-format */
	  einfo (_("Warning: .drectve `%.*s' unrecognized\n"),
		 tend - param, param);
	}
d648 1
a648 3
/*****************************************************************************
 Parser Callbacks
 *****************************************************************************/
d679 1
d718 1
d722 1
d749 1
d810 5
a814 7

  if (dllext != NULL)
    {
      buf = (char *) xmalloc (strlen (module) + strlen (dllext) + 2);
      sprintf (buf, "%s.%s", module, dllext);
      module = buf;
    }
d835 1
d852 1
a852 3
/*****************************************************************************
 Lexical Scanner
 *****************************************************************************/
d857 1
a857 1
/* Never freed, but always reused as needed, so no real leak */
d868 1
a868 1
      buflen += 50;		/* overly reasonable, eh? */
d875 1
a875 1
  buffer[bufptr] = 0;		/* not optimal, but very convenient */
d917 1
d964 1
a964 1
  /* trim leading whitespace */
d987 2
a988 1
  /* must be something else */
d991 1
a991 1
  if (isdigit (c))
d994 1
a994 1
      while (c != EOF && (isxdigit (c) || (c == 'x')))
d1008 1
a1008 1
  if (isalpha (c) || strchr ("$:-_?", c))
d1011 19
a1029 1
      while (c != EOF && (isalnum (c) || strchr ("$:-_?/@@", c)))
d1036 5
a1040 3
      for (i = 0; tokens[i].name; i++)
	if (strcmp (tokens[i].name, buffer) == 0)
	  {
d1042 1
a1042 1
	    printf ("lex: `%s' is a string token\n", buffer);
d1044 3
a1046 2
	    return tokens[i].token;
	  }
d1059 1
d1072 1
a1072 1
  if (c == '=' || c == '.' || c == '@@' || c == ',')
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d3 1
a3 2
/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003
     Free Software Foundation, Inc.
d5 1
a5 1
     This file is part of GNU Binutils.
d7 13
a19 13
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 1
a23 1
#include "safe-ctype.h"
d39 1
a39 1
   generators need to be fixed instead of adding those names to this list.  */
d68 2
a69 2
#define yyreds	def_reds		/* With YYDEBUG defined.  */
#define yytoks	def_toks		/* With YYDEBUG defined.  */
d80 2
d85 2
a86 1
static void def_import PARAMS ((const char *, const char *, const char *, const char *, int));
a87 1
static def_file_module *def_stash_module PARAMS ((def_file *, const char *));
a95 3
static void put_buf PARAMS ((char));
static int def_getc PARAMS ((void));
static int def_ungetc PARAMS ((int));
d117 1
a117 1
%type  <id> opt_name opt_equal_name dot_name 
d152 1
a152 1
		dot_name opt_equal_name opt_ordinal opt_comma exp_opt_list
d232 1
a232 1
          '=' dot_name	{ $$ = $2; }
d237 1
a237 1
	|	{ $$ = -1;}
a239 8
dot_name: ID		{ $$ = $1; }
	| dot_name '.' ID	
	  { 
	    char * name = xmalloc (strlen ($1) + 1 + strlen ($3) + 1);
	    sprintf (name, "%s.%s", $1, $3);
	    $$ = name;
	  }
	;
a325 1

a387 1

a408 1

a427 1

a447 1

a456 1

a458 1

a471 1

d474 1
a474 1
      max_exports = ROUND_UP(def->num_exports + 1, 32);
d476 1
a476 2
	def->exports = (def_file_export *)
	  xrealloc (def->exports, max_exports * sizeof (def_file_export));
d478 1
a478 2
	def->exports = (def_file_export *)
	  xmalloc (max_exports * sizeof (def_file_export));
a492 14
def_file_module *
def_get_module (def, name)
     def_file *def;
     const char *name;
{
  def_file_module *s;

  for (s = def->modules; s; s = s->next)
    if (strcmp (s->name, name) == 0)
      return s;

  return (def_file_module *) 0;
}

d496 1
a496 1
     const char *name;
d499 2
a500 2

  if ((s = def_get_module (def, name)) != (def_file_module *) 0)
a519 1

a522 1

d524 1
a524 2
	def->imports = (def_file_import *)
	  xrealloc (def->imports, max_imports * sizeof (def_file_import));
d526 1
a526 2
	def->imports = (def_file_import *)
	  xmalloc (max_imports * sizeof (def_file_import));
d533 1
a533 1
    i->module = def_stash_module (def, module);
a539 1

d572 1
a572 1
      while (param < pend && ISSPACE (*param))
a573 1

d575 2
a576 3
	   tend < pend && !(ISSPACE (tend[-1]) && *tend == '-');
	   tend++)
	;
a580 1

d595 5
a599 4
	/* xgettext:c-format */
	einfo (_("Warning: .drectve `%.*s' unrecognized\n"),
	       tend - param, param);

d607 3
a609 1
/* Parser Callbacks.  */
a639 1

a677 1

a680 1

a706 1

d767 7
a773 5
  const char *ext = dllext ? dllext : "dll";    
   
  buf = (char *) xmalloc (strlen (module) + strlen (ext) + 2);
  sprintf (buf, "%s.%s", module, ext);
  module = buf;
a793 1

d810 3
a812 1
/* Lexical Scanner.  */
d817 1
a817 1
/* Never freed, but always reused as needed, so no real leak.  */
d828 1
a828 1
      buflen += 50;		/* overly reasonable, eh?  */
d835 1
a835 1
  buffer[bufptr] = 0;		/* not optimal, but very convenient.  */
a876 1

d923 1
a923 1
  /* Trim leading whitespace.  */
d946 1
a946 2

  /* Must be something else.  */
d949 1
a949 1
  if (ISDIGIT (c))
d952 1
a952 1
      while (c != EOF && (ISXDIGIT (c) || (c == 'x')))
d966 1
a966 1
  if (ISALPHA (c) || strchr ("$:-_?@@", c))
d969 1
a969 19
      q = c;
      put_buf (c);
      c = def_getc ();

      if (q == '@@')
	{
          if (ISBLANK (c) ) /* '@@' followed by whitespace.  */
	    return (q);
          else if (ISDIGIT (c)) /* '@@' followed by digit.  */
            {
	      def_ungetc (c);
              return (q);
	    }
#if TRACE
	  printf ("lex: @@ returns itself\n");
#endif
	}

      while (c != EOF && (ISALNUM (c) || strchr ("$:-_?/@@", c)))
d976 3
a978 5
      if (ISALPHA (q)) /* Check for tokens.  */
	{
          for (i = 0; tokens[i].name; i++)
	    if (strcmp (tokens[i].name, buffer) == 0)
	      {
d980 1
a980 1
	        printf ("lex: `%s' is a string token\n", buffer);
d982 2
a983 3
	        return tokens[i].token;
	      }
	}
a995 1

d1008 1
a1008 1
  if (c == '=' || c == '.' || c == ',')
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d81 18
a98 15
static void def_description (const char *);
static void def_exports (const char *, const char *, int, int);
static void def_heapsize (int, int);
static void def_import (const char *, const char *, const char *, const char *,
			int);
static void def_library (const char *, int);
static void def_name (const char *, int);
static void def_section (const char *, int);
static void def_section_alt (const char *, const char *);
static void def_stacksize (int, int);
static void def_version (int, int);
static void def_directive (char *);
static int def_parse (void);
static int def_error (const char *);
static int def_lex (void);
d111 3
a113 3
%token NAME LIBRARY DESCRIPTION STACKSIZE HEAPSIZE CODE DATAU DATAL
%token SECTIONS EXPORTS IMPORTS VERSIONK BASE CONSTANTU CONSTANTL
%token PRIVATEU PRIVATEL
d221 1
a221 1
	    char *name = xmalloc (strlen ($1) + 1 + strlen ($3) + 1);
d245 1
a245 1
	    char *name = xmalloc (strlen ($1) + 1 + strlen ($3) + 1);
d274 1
a274 1
def_file_empty (void)
d276 1
a276 1
  def_file *rv = xmalloc (sizeof (def_file));
d279 1
a279 1
  rv->base_address = (bfd_vma) -1;
d287 3
a289 1
def_file_parse (const char *filename, def_file *add_to)
d332 2
a333 1
def_file_free (def_file *def)
d394 3
a396 1
def_file_print (FILE *file, def_file *def)
d405 1
a405 1
  if (def->base_address != (bfd_vma) -1)
d481 5
a485 4
def_file_add_export (def_file *def,
		     const char *external_name,
		     const char *internal_name,
		     int ordinal)
d494 2
a495 2
	def->exports = xrealloc (def->exports,
				 max_exports * sizeof (def_file_export));
d497 2
a498 1
	def->exports = xmalloc (max_exports * sizeof (def_file_export));
d514 3
a516 1
def_get_module (def_file *def, const char *name)
d524 1
a524 1
  return NULL;
d528 3
a530 1
def_stash_module (def_file *def, const char *name)
d534 1
a534 1
  if ((s = def_get_module (def, name)) != NULL)
d536 1
a536 1
  s = xmalloc (sizeof (def_file_module) + strlen (name));
d545 6
a550 5
def_file_add_import (def_file *def,
		     const char *name,
		     const char *module,
		     int ordinal,
		     const char *internal_name)
d553 1
a553 1
  int max_imports = ROUND_UP (def->num_imports, 16);
d557 1
a557 1
      max_imports = ROUND_UP (def->num_imports+1, 16);
d560 2
a561 2
	def->imports = xrealloc (def->imports,
				 max_imports * sizeof (def_file_import));
d563 2
a564 1
	def->imports = xmalloc (max_imports * sizeof (def_file_import));
d597 4
a600 1
def_file_add_directive (def_file *my_def, const char *param, int len)
d604 1
a604 1
  char * tend = (char *) param;
d611 1
a611 2
      while (param < pend
	     && (ISSPACE (*param) || *param == '\n' || *param == 0))
d614 2
a615 12
      if (param == pend)
	break;

      /* Scan forward until we encounter any of:
          - the end of the buffer
	  - the start of a new option
	  - a newline seperating options
          - a NUL seperating options.  */
      for (tend = (char *) (param + 1);
	   (tend < pend
	    && !(ISSPACE (tend[-1]) && *tend == '-')
	    && *tend != '\n' && *tend != 0);
d631 1
a631 2
	      if (def_parse ())
		continue;
d637 3
a639 9
	{
	  char saved;

	  saved = * tend;
	  * tend = 0;
	  /* xgettext:c-format */
	  einfo (_("Warning: .drectve `%s' unrecognized\n"), param);
	  * tend = saved;
	}
d651 3
a653 1
def_name (const char *name, int base)
d663 3
a665 1
def_library (const char *name, int base)
d675 2
a676 1
def_description (const char *text)
d683 1
a683 1
      def->description = xrealloc (def->description, len);
d688 1
a688 1
      def->description = xmalloc (len);
d694 3
a696 1
def_stacksize (int reserve, int commit)
d703 3
a705 1
def_heapsize (int reserve, int commit)
d712 3
a714 1
def_section (const char *name, int attr)
d717 1
a717 1
  int max_sections = ROUND_UP (def->num_section_defs, 4);
d721 1
a721 1
      max_sections = ROUND_UP (def->num_section_defs+1, 4);
d724 1
a724 2
	def->section_defs = xrealloc (def->section_defs,
				      max_sections * sizeof (def_file_import));
d726 1
a726 1
	def->section_defs = xmalloc (max_sections * sizeof (def_file_import));
d744 3
a746 1
def_section_alt (const char *name, const char *attr)
d776 5
a780 4
def_exports (const char *external_name,
	     const char *internal_name,
	     int ordinal,
	     int flags)
d802 6
a807 5
def_import (const char *internal_name,
	    const char *module,
	    const char *dllext,
	    const char *name,
	    int ordinal)
d812 1
a812 1
  buf = xmalloc (strlen (module) + strlen (ext) + 2);
d822 3
a824 1
def_version (int major, int minor)
d831 2
a832 1
def_directive (char *str)
d834 1
a834 1
  struct directive *d = xmalloc (sizeof (struct directive));
d843 2
a844 1
def_error (const char *err)
d846 2
a847 2
  einfo ("%P: %s:%d: %s\n",
	 def_filename ? def_filename : "<unknown-file>", linenumber, err);
d863 2
a864 1
put_buf (char c)
d870 1
a870 1
	buffer = xrealloc (buffer, buflen + 1);
d872 1
a872 1
	buffer = xmalloc (buflen + 1);
d914 1
a914 1
def_getc (void)
d935 2
a936 1
def_ungetc (int c)
d948 1
a948 1
def_lex (void)
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d3 1
a3 2
/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003
     Free Software Foundation, Inc.
d5 1
a5 1
     This file is part of GNU Binutils.
d7 13
a19 13
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 1
a23 1
#include "safe-ctype.h"
d39 1
a39 1
   generators need to be fixed instead of adding those names to this list.  */
d68 2
a69 2
#define yyreds	def_reds		/* With YYDEBUG defined.  */
#define yytoks	def_toks		/* With YYDEBUG defined.  */
d80 2
d85 2
a86 1
static void def_import PARAMS ((const char *, const char *, const char *, const char *, int));
a87 1
static def_file_module *def_stash_module PARAMS ((def_file *, const char *));
a95 3
static void put_buf PARAMS ((char));
static int def_getc PARAMS ((void));
static int def_ungetc PARAMS ((int));
d117 1
a117 1
%type  <id> opt_name opt_equal_name dot_name 
d152 1
a152 1
		dot_name opt_equal_name opt_ordinal opt_comma exp_opt_list
d232 1
a232 1
          '=' dot_name	{ $$ = $2; }
d237 1
a237 1
	|	{ $$ = -1;}
a239 8
dot_name: ID		{ $$ = $1; }
	| dot_name '.' ID	
	  { 
	    char * name = xmalloc (strlen ($1) + 1 + strlen ($3) + 1);
	    sprintf (name, "%s.%s", $1, $3);
	    $$ = name;
	  }
	;
a325 1

a387 1

a408 1

a427 1

a447 1

a456 1

a458 1

a471 1

d474 1
a474 1
      max_exports = ROUND_UP(def->num_exports + 1, 32);
d476 1
a476 2
	def->exports = (def_file_export *)
	  xrealloc (def->exports, max_exports * sizeof (def_file_export));
d478 1
a478 2
	def->exports = (def_file_export *)
	  xmalloc (max_exports * sizeof (def_file_export));
a492 14
def_file_module *
def_get_module (def, name)
     def_file *def;
     const char *name;
{
  def_file_module *s;

  for (s = def->modules; s; s = s->next)
    if (strcmp (s->name, name) == 0)
      return s;

  return (def_file_module *) 0;
}

d496 1
a496 1
     const char *name;
d499 2
a500 2

  if ((s = def_get_module (def, name)) != (def_file_module *) 0)
a519 1

a522 1

d524 1
a524 2
	def->imports = (def_file_import *)
	  xrealloc (def->imports, max_imports * sizeof (def_file_import));
d526 1
a526 2
	def->imports = (def_file_import *)
	  xmalloc (max_imports * sizeof (def_file_import));
d533 1
a533 1
    i->module = def_stash_module (def, module);
a539 1

d572 1
a572 1
      while (param < pend && ISSPACE (*param))
a573 1

d575 2
a576 3
	   tend < pend && !(ISSPACE (tend[-1]) && *tend == '-');
	   tend++)
	;
a580 1

d595 5
a599 4
	/* xgettext:c-format */
	einfo (_("Warning: .drectve `%.*s' unrecognized\n"),
	       tend - param, param);

d607 3
a609 1
/* Parser Callbacks.  */
a639 1

a677 1

a680 1

a706 1

d767 7
a773 5
  const char *ext = dllext ? dllext : "dll";    
   
  buf = (char *) xmalloc (strlen (module) + strlen (ext) + 2);
  sprintf (buf, "%s.%s", module, ext);
  module = buf;
a793 1

d810 3
a812 1
/* Lexical Scanner.  */
d817 1
a817 1
/* Never freed, but always reused as needed, so no real leak.  */
d828 1
a828 1
      buflen += 50;		/* overly reasonable, eh?  */
d835 1
a835 1
  buffer[bufptr] = 0;		/* not optimal, but very convenient.  */
a876 1

d923 1
a923 1
  /* Trim leading whitespace.  */
d946 1
a946 2

  /* Must be something else.  */
d949 1
a949 1
  if (ISDIGIT (c))
d952 1
a952 1
      while (c != EOF && (ISXDIGIT (c) || (c == 'x')))
d966 1
a966 1
  if (ISALPHA (c) || strchr ("$:-_?@@", c))
d969 1
a969 19
      q = c;
      put_buf (c);
      c = def_getc ();

      if (q == '@@')
	{
          if (ISBLANK (c) ) /* '@@' followed by whitespace.  */
	    return (q);
          else if (ISDIGIT (c)) /* '@@' followed by digit.  */
            {
	      def_ungetc (c);
              return (q);
	    }
#if TRACE
	  printf ("lex: @@ returns itself\n");
#endif
	}

      while (c != EOF && (ISALNUM (c) || strchr ("$:-_?/@@", c)))
d976 3
a978 5
      if (ISALPHA (q)) /* Check for tokens.  */
	{
          for (i = 0; tokens[i].name; i++)
	    if (strcmp (tokens[i].name, buffer) == 0)
	      {
d980 1
a980 1
	        printf ("lex: `%s' is a string token\n", buffer);
d982 2
a983 3
	        return tokens[i].token;
	      }
	}
a995 1

d1008 1
a1008 1
  if (c == '=' || c == '.' || c == ',')
@

