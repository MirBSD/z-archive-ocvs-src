head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.20.53.15;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.00.40;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.39.07;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.39.07;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.26.58;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.40.53;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.04.35;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.08.31;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* Support for 32-bit PowerPC NLM (NetWare Loadable Module)
   Copyright 1994, 1995, 2000, 2001, 2002 Free Software Foundation, Inc.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"

/* The format of a PowerPC NLM changed.  Define OLDFORMAT to get the
   old format.  */

#define ARCH_SIZE 32

#include "nlm/ppc-ext.h"
#define Nlm_External_Fixed_Header	Nlm32_powerpc_External_Fixed_Header

#include "libnlm.h"

#ifdef OLDFORMAT
static bfd_boolean nlm_powerpc_backend_object_p
  PARAMS ((bfd *));
static bfd_boolean nlm_powerpc_write_prefix
  PARAMS ((bfd *));
#endif

static bfd_boolean nlm_powerpc_read_reloc
  PARAMS ((bfd *, nlmNAME(symbol_type) *, asection **, arelent *));
static bfd_boolean nlm_powerpc_mangle_relocs
  PARAMS ((bfd *, asection *, PTR, bfd_vma, bfd_size_type));
static bfd_boolean nlm_powerpc_read_import
  PARAMS ((bfd *, nlmNAME(symbol_type) *));

#ifdef OLDFORMAT
static bfd_boolean nlm_powerpc_write_reloc
  PARAMS ((bfd *, asection *, arelent *, int));
#endif

static bfd_boolean nlm_powerpc_write_import
  PARAMS ((bfd *, asection *, arelent *));
static bfd_boolean nlm_powerpc_write_external
  PARAMS ((bfd *, bfd_size_type, asymbol *, struct reloc_and_sec *));

#ifndef OLDFORMAT
static bfd_boolean nlm_powerpc_set_public_section
  PARAMS ((bfd *, nlmNAME(symbol_type) *));
static bfd_vma nlm_powerpc_get_public_offset
  PARAMS ((bfd *, asymbol *));
#endif

#ifdef OLDFORMAT

/* The prefix header is only used in the old format.  */

/* PowerPC NLM's have a prefix header before the standard NLM.  This
   function reads it in, verifies the version, and seeks the bfd to
   the location before the regular NLM header.  */

static bfd_boolean
nlm_powerpc_backend_object_p (abfd)
     bfd *abfd;
{
  struct nlm32_powerpc_external_prefix_header s;

  if (bfd_bread ((PTR) &s, (bfd_size_type) sizeof s, abfd) != sizeof s)
    return FALSE;

  if (memcmp (s.signature, NLM32_POWERPC_SIGNATURE, sizeof s.signature) != 0
      || H_GET_32 (abfd, s.headerVersion) != NLM32_POWERPC_HEADER_VERSION)
    return FALSE;

  return TRUE;
}

/* Write out the prefix.  */

static bfd_boolean
nlm_powerpc_write_prefix (abfd)
     bfd *abfd;
{
  struct nlm32_powerpc_external_prefix_header s;

  memset (&s, 0, sizeof s);
  memcpy (s.signature, NLM32_POWERPC_SIGNATURE, sizeof s.signature);
  H_PUT_32 (abfd, NLM32_POWERPC_HEADER_VERSION, s.headerVersion);
  H_PUT_32 (abfd, 0, s.origins);

  /* FIXME: What should we do about the date?  */

  if (bfd_bwrite ((PTR) &s, (bfd_size_type) sizeof s, abfd) != sizeof s)
    return FALSE;

  return TRUE;
}

#endif /* OLDFORMAT */

#ifndef OLDFORMAT

/* There is only one type of reloc in a PowerPC NLM.  */

static reloc_howto_type nlm_powerpc_howto =
  HOWTO (0,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "32",			/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Read a PowerPC NLM reloc.  */

static bfd_boolean
nlm_powerpc_read_reloc (abfd, sym, secp, rel)
     bfd *abfd;
     nlmNAME(symbol_type) *sym;
     asection **secp;
     arelent *rel;
{
  bfd_byte temp[4];
  bfd_vma val;
  const char *name;

  if (bfd_bread (temp, (bfd_size_type) sizeof (temp), abfd) != sizeof (temp))
    return FALSE;

  val = bfd_get_32 (abfd, temp);

  /* The value is a word offset into either the code or data segment.
     This is the location which needs to be adjusted.

     The high bit is 0 if the value is an offset into the data
     segment, or 1 if the value is an offset into the text segment.

     If this is a relocation fixup rather than an imported symbol (the
     sym argument is NULL), then the second most significant bit is 0
     if the address of the data segment should be added to the
     location addressed by the value, or 1 if the address of the text
     segment should be added.

     If this is an imported symbol, the second most significant bit is
     not used and must be 0.  */

  if ((val & NLM_HIBIT) == 0)
    name = NLM_INITIALIZED_DATA_NAME;
  else
    {
      name = NLM_CODE_NAME;
      val &=~ NLM_HIBIT;
    }
  *secp = bfd_get_section_by_name (abfd, name);

  if (sym == NULL)
    {
      if ((val & (NLM_HIBIT >> 1)) == 0)
	name = NLM_INITIALIZED_DATA_NAME;
      else
	{
	  name = NLM_CODE_NAME;
	  val &=~ (NLM_HIBIT >> 1);
	}
      rel->sym_ptr_ptr = bfd_get_section_by_name (abfd, name)->symbol_ptr_ptr;
    }

  rel->howto = &nlm_powerpc_howto;

  rel->address = val << 2;
  rel->addend = 0;

  return TRUE;
}

#else /* OLDFORMAT */

/* This reloc handling is only applicable to the old format.  */

/* How to process the various reloc types.  PowerPC NLMs use XCOFF
   reloc types, and I have just copied the XCOFF reloc table here.  */

static reloc_howto_type nlm_powerpc_howto_table[] =
{
  /* Standard 32 bit relocation.  */
  HOWTO (0,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_POS",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* 32 bit relocation, but store negative value.  */
  HOWTO (1,	                /* type */
	 0,	                /* rightshift */
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_NEG",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* 32 bit PC relative relocation.  */
  HOWTO (2,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 TRUE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_REL",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* 16 bit TOC relative relocation.  */
  HOWTO (3,	                /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_TOC",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* I don't really know what this is.  */
  HOWTO (4,	                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RTB",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* External TOC relative symbol.  */
  HOWTO (5,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_GL",                /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* Local TOC relative symbol.  */
  HOWTO (6,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_TCL",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  { 7 },

  /* Non modifiable absolute branch.  */
  HOWTO (8,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_BA",                /* name */
	 TRUE,	                /* partial_inplace */
	 0x3fffffc,	        /* src_mask */
	 0x3fffffc,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  { 9 },

  /* Non modifiable relative branch.  */
  HOWTO (0xa,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 TRUE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_BR",                /* name */
	 TRUE,	                /* partial_inplace */
	 0x3fffffc,	        /* src_mask */
	 0x3fffffc,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  { 0xb },

  /* Indirect load.  */
  HOWTO (0xc,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RL",                /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* Load address.  */
  HOWTO (0xd,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RLA",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  { 0xe },

  /* Non-relocating reference.  */
  HOWTO (0xf,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_REF",               /* name */
	 FALSE,	                /* partial_inplace */
	 0,		        /* src_mask */
	 0,     	   	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  { 0x10 },
  { 0x11 },

  /* TOC relative indirect load.  */
  HOWTO (0x12,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_TRL",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* TOC relative load address.  */
  HOWTO (0x13,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_TRLA",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* Modifiable relative branch.  */
  HOWTO (0x14,	                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RRTBI",             /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* Modifiable absolute branch.  */
  HOWTO (0x15,	                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RRTBA",             /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* Modifiable call absolute indirect.  */
  HOWTO (0x16,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_CAI",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* Modifiable call relative.  */
  HOWTO (0x17,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_REL",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* Modifiable branch absolute.  */
  HOWTO (0x18,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RBA",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* Modifiable branch absolute.  */
  HOWTO (0x19,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RBAC",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* Modifiable branch relative.  */
  HOWTO (0x1a,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_REL",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* Modifiable branch absolute.  */
  HOWTO (0x1b,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_REL",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE)                 /* pcrel_offset */
};

#define HOWTO_COUNT (sizeof nlm_powerpc_howto_table		\
		     / sizeof nlm_powerpc_howto_table[0])

/* Read a PowerPC NLM reloc.  */

static bfd_boolean
nlm_powerpc_read_reloc (abfd, sym, secp, rel)
     bfd *abfd;
     nlmNAME(symbol_type) *sym;
     asection **secp;
     arelent *rel;
{
  struct nlm32_powerpc_external_reloc ext;
  bfd_vma l_vaddr;
  unsigned long l_symndx;
  int l_rtype;
  int l_rsecnm;
  asection *code_sec, *data_sec, *bss_sec;

  /* Read the reloc from the file.  */
  if (bfd_bread (&ext, (bfd_size_type) sizeof ext, abfd) != sizeof ext)
    return FALSE;

  /* Swap in the fields.  */
  l_vaddr = H_GET_32 (abfd, ext.l_vaddr);
  l_symndx = H_GET_32 (abfd, ext.l_symndx);
  l_rtype = H_GET_16 (abfd, ext.l_rtype);
  l_rsecnm = H_GET_16 (abfd, ext.l_rsecnm);

  /* Get the sections now, for convenience.  */
  code_sec = bfd_get_section_by_name (abfd, NLM_CODE_NAME);
  data_sec = bfd_get_section_by_name (abfd, NLM_INITIALIZED_DATA_NAME);
  bss_sec = bfd_get_section_by_name (abfd, NLM_UNINITIALIZED_DATA_NAME);

  /* Work out the arelent fields.  */
  if (sym != NULL)
    {
      /* This is an import.  sym_ptr_ptr is filled in by
	 nlm_canonicalize_reloc.  */
      rel->sym_ptr_ptr = NULL;
    }
  else
    {
      asection *sec;

      if (l_symndx == 0)
	sec = code_sec;
      else if (l_symndx == 1)
	sec = data_sec;
      else if (l_symndx == 2)
	sec = bss_sec;
      else
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      rel->sym_ptr_ptr = sec->symbol_ptr_ptr;
    }

  rel->addend = 0;

  BFD_ASSERT ((l_rtype & 0xff) < HOWTO_COUNT);

  rel->howto = nlm_powerpc_howto_table + (l_rtype & 0xff);

  BFD_ASSERT (rel->howto->name != NULL
	      && ((l_rtype & 0x8000) != 0
		  ? (rel->howto->complain_on_overflow
		     == complain_overflow_signed)
		  : (rel->howto->complain_on_overflow
		     == complain_overflow_bitfield))
	      && ((l_rtype >> 8) & 0x1f) == rel->howto->bitsize - 1);

  if (l_rsecnm == 0)
    *secp = code_sec;
  else if (l_rsecnm == 1)
    {
      *secp = data_sec;
      l_vaddr -= bfd_section_size (abfd, code_sec);
    }
  else
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  rel->address = l_vaddr;

  return TRUE;
}

#endif /* OLDFORMAT */

/* Mangle PowerPC NLM relocs for output.  */

static bfd_boolean
nlm_powerpc_mangle_relocs (abfd, sec, data, offset, count)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     bfd_vma offset ATTRIBUTE_UNUSED;
     bfd_size_type count ATTRIBUTE_UNUSED;
{
  return TRUE;
}

/* Read a PowerPC NLM import record */

static bfd_boolean
nlm_powerpc_read_import (abfd, sym)
     bfd *abfd;
     nlmNAME(symbol_type) *sym;
{
  struct nlm_relent *nlm_relocs;	/* relocation records for symbol */
  bfd_size_type rcount;			/* number of relocs */
  bfd_byte temp[NLM_TARGET_LONG_SIZE];	/* temporary 32-bit value */
  unsigned char symlength;		/* length of symbol name */
  char *name;

  if (bfd_bread ((PTR) &symlength, (bfd_size_type) sizeof (symlength), abfd)
      != sizeof (symlength))
    return FALSE;
  sym -> symbol.the_bfd = abfd;
  name = bfd_alloc (abfd, (bfd_size_type) symlength + 1);
  if (name == NULL)
    return FALSE;
  if (bfd_bread (name, (bfd_size_type) symlength, abfd) != symlength)
    return FALSE;
  name[symlength] = '\0';
  sym -> symbol.name = name;
  sym -> symbol.flags = 0;
  sym -> symbol.value = 0;
  sym -> symbol.section = bfd_und_section_ptr;
  if (bfd_bread ((PTR) temp, (bfd_size_type) sizeof (temp), abfd)
      != sizeof (temp))
    return FALSE;
  rcount = H_GET_32 (abfd, temp);
  nlm_relocs = ((struct nlm_relent *)
		bfd_alloc (abfd, rcount * sizeof (struct nlm_relent)));
  if (nlm_relocs == (struct nlm_relent *) NULL)
    return FALSE;
  sym -> relocs = nlm_relocs;
  sym -> rcnt = 0;
  while (sym -> rcnt < rcount)
    {
      asection *section;

      if (! nlm_powerpc_read_reloc (abfd, sym, &section, &nlm_relocs -> reloc))
	return FALSE;
      nlm_relocs -> section = section;
      nlm_relocs++;
      sym -> rcnt++;
    }
  return TRUE;
}

#ifndef OLDFORMAT

/* Write a PowerPC NLM reloc.  */

static bfd_boolean
nlm_powerpc_write_import (abfd, sec, rel)
     bfd *abfd;
     asection *sec;
     arelent *rel;
{
  asymbol *sym;
  bfd_vma val;
  bfd_byte temp[4];

  /* PowerPC NetWare only supports one kind of reloc.  */
  if (rel->addend != 0
      || rel->howto == NULL
      || rel->howto->rightshift != 0
      || rel->howto->size != 2
      || rel->howto->bitsize != 32
      || rel->howto->bitpos != 0
      || rel->howto->pc_relative
      || (rel->howto->src_mask != 0xffffffff && rel->addend != 0)
      || rel->howto->dst_mask != 0xffffffff)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  sym = *rel->sym_ptr_ptr;

  /* The value we write out is the offset into the appropriate
     segment, rightshifted by two.  This offset is the section vma,
     adjusted by the vma of the lowest section in that segment, plus
     the address of the relocation.  */
  val = bfd_get_section_vma (abfd, sec) + rel->address;
  if ((val & 3) != 0)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }
  val >>= 2;

  /* The high bit is 0 if the reloc is in the data section, or 1 if
     the reloc is in the code section.  */
  if (bfd_get_section_flags (abfd, sec) & SEC_DATA)
    val -= nlm_get_data_low (abfd);
  else
    {
      val -= nlm_get_text_low (abfd);
      val |= NLM_HIBIT;
    }

  if (! bfd_is_und_section (bfd_get_section (sym)))
    {
      /* This is an internal relocation fixup.  The second most
	 significant bit is 0 if this is a reloc against the data
	 segment, or 1 if it is a reloc against the text segment.  */
      if (bfd_get_section_flags (abfd, bfd_get_section (sym)) & SEC_CODE)
	val |= NLM_HIBIT >> 1;
    }

  bfd_put_32 (abfd, val, temp);
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), abfd) != sizeof (temp))
    return FALSE;

  return TRUE;
}

#else /* OLDFORMAT */

/* This is used for the reloc handling in the old format.  */

/* Write a PowerPC NLM reloc.  */

static bfd_boolean
nlm_powerpc_write_reloc (abfd, sec, rel, indx)
     bfd *abfd;
     asection *sec;
     arelent *rel;
     int indx;
{
  struct nlm32_powerpc_external_reloc ext;
  asection *code_sec, *data_sec, *bss_sec;
  asymbol *sym;
  asection *symsec;
  unsigned long l_symndx;
  int l_rtype;
  int l_rsecnm;
  reloc_howto_type *howto;
  bfd_size_type address;

  /* Get the sections now, for convenience.  */
  code_sec = bfd_get_section_by_name (abfd, NLM_CODE_NAME);
  data_sec = bfd_get_section_by_name (abfd, NLM_INITIALIZED_DATA_NAME);
  bss_sec = bfd_get_section_by_name (abfd, NLM_UNINITIALIZED_DATA_NAME);

  sym = *rel->sym_ptr_ptr;
  symsec = bfd_get_section (sym);
  if (indx != -1)
    {
      BFD_ASSERT (bfd_is_und_section (symsec));
      l_symndx = indx + 3;
    }
  else
    {
      if (symsec == code_sec)
	l_symndx = 0;
      else if (symsec == data_sec)
	l_symndx = 1;
      else if (symsec == bss_sec)
	l_symndx = 2;
      else
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
    }

  H_PUT_32 (abfd, l_symndx, ext.l_symndx);

  for (howto = nlm_powerpc_howto_table;
       howto < nlm_powerpc_howto_table + HOWTO_COUNT;
       howto++)
    {
      if (howto->rightshift == rel->howto->rightshift
	  && howto->size == rel->howto->size
	  && howto->bitsize == rel->howto->bitsize
	  && howto->pc_relative == rel->howto->pc_relative
	  && howto->bitpos == rel->howto->bitpos
	  && (howto->partial_inplace == rel->howto->partial_inplace
	      || (! rel->howto->partial_inplace
		  && rel->addend == 0))
	  && (howto->src_mask == rel->howto->src_mask
	      || (rel->howto->src_mask == 0
		  && rel->addend == 0))
	  && howto->dst_mask == rel->howto->dst_mask
	  && howto->pcrel_offset == rel->howto->pcrel_offset)
	break;
    }
  if (howto >= nlm_powerpc_howto_table + HOWTO_COUNT)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  l_rtype = howto->type;
  if (howto->complain_on_overflow == complain_overflow_signed)
    l_rtype |= 0x8000;
  l_rtype |= (howto->bitsize - 1) << 8;
  H_PUT_16 (abfd, l_rtype, ext.l_rtype);

  address = rel->address;

  if (sec == code_sec)
    l_rsecnm = 0;
  else if (sec == data_sec)
    {
      l_rsecnm = 1;
      address += bfd_section_size (abfd, code_sec);
    }
  else
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  H_PUT_16 (abfd, l_rsecnm, ext.l_rsecnm);
  H_PUT_32 (abfd, address, ext.l_vaddr);

  if (bfd_bwrite (&ext, (bfd_size_type) sizeof ext, abfd) != sizeof ext)
    return FALSE;

  return TRUE;
}

/* Write a PowerPC NLM import.  */

static bfd_boolean
nlm_powerpc_write_import (abfd, sec, rel)
     bfd *abfd;
     asection *sec;
     arelent *rel;
{
  return nlm_powerpc_write_reloc (abfd, sec, rel, -1);
}

#endif /* OLDFORMAT */

/* Write a PowerPC NLM external symbol.  This routine keeps a static
   count of the symbol index.  FIXME: I don't know if this is
   necessary, and the index never gets reset.  */

static bfd_boolean
nlm_powerpc_write_external (abfd, count, sym, relocs)
     bfd *abfd;
     bfd_size_type count;
     asymbol *sym;
     struct reloc_and_sec *relocs;
{
  unsigned int i;
  bfd_byte len;
  unsigned char temp[NLM_TARGET_LONG_SIZE];
#ifdef OLDFORMAT
  static int indx;
#endif

  len = strlen (sym->name);
  if ((bfd_bwrite (&len, (bfd_size_type) sizeof (bfd_byte), abfd)
       != sizeof (bfd_byte))
      || bfd_bwrite (sym->name, (bfd_size_type) len, abfd) != len)
    return FALSE;

  bfd_put_32 (abfd, count, temp);
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), abfd) != sizeof (temp))
    return FALSE;

  for (i = 0; i < count; i++)
    {
#ifndef OLDFORMAT
      if (! nlm_powerpc_write_import (abfd, relocs[i].sec, relocs[i].rel))
	return FALSE;
#else
      if (! nlm_powerpc_write_reloc (abfd, relocs[i].sec,
				     relocs[i].rel, indx))
	return FALSE;
#endif
    }

#ifdef OLDFORMAT
  ++indx;
#endif

  return TRUE;
}

#ifndef OLDFORMAT

/* PowerPC Netware uses a word offset, not a byte offset, for public
   symbols.  */

/* Set the section for a public symbol.  */

static bfd_boolean
nlm_powerpc_set_public_section (abfd, sym)
     bfd *abfd;
     nlmNAME(symbol_type) *sym;
{
  if (sym->symbol.value & NLM_HIBIT)
    {
      sym->symbol.value &= ~NLM_HIBIT;
      sym->symbol.flags |= BSF_FUNCTION;
      sym->symbol.section =
	bfd_get_section_by_name (abfd, NLM_CODE_NAME);
    }
  else
    {
      sym->symbol.section =
	bfd_get_section_by_name (abfd, NLM_INITIALIZED_DATA_NAME);
    }

  sym->symbol.value <<= 2;

  return TRUE;
}

/* Get the offset to write out for a public symbol.  */

static bfd_vma
nlm_powerpc_get_public_offset (abfd, sym)
     bfd *abfd;
     asymbol *sym;
{
  bfd_vma offset;
  asection *sec;

  offset = bfd_asymbol_value (sym);
  sec = bfd_get_section (sym);
  if (sec->flags & SEC_CODE)
    {
      offset -= nlm_get_text_low (abfd);
      offset |= NLM_HIBIT;
    }
  else if (sec->flags & (SEC_DATA | SEC_ALLOC))
    {
      /* SEC_ALLOC is for the .bss section.  */
      offset -= nlm_get_data_low (abfd);
    }
  else
    {
      /* We can't handle an exported symbol that is not in the code or
	 data segment.  */
      bfd_set_error (bfd_error_invalid_operation);
      /* FIXME: No way to return error.  */
      abort ();
    }

  return offset;
}

#endif /* ! defined (OLDFORMAT) */

#include "nlmswap.h"

static const struct nlm_backend_data nlm32_powerpc_backend =
{
  "NetWare PowerPC Module \032",
  sizeof (Nlm32_powerpc_External_Fixed_Header),
#ifndef OLDFORMAT
  0,	/* optional_prefix_size */
#else
  sizeof (struct nlm32_powerpc_external_prefix_header),
#endif
  bfd_arch_powerpc,
  0,
  FALSE,
#ifndef OLDFORMAT
  0,	/* backend_object_p */
  0,	/* write_prefix */
#else
  nlm_powerpc_backend_object_p,
  nlm_powerpc_write_prefix,
#endif
  nlm_powerpc_read_reloc,
  nlm_powerpc_mangle_relocs,
  nlm_powerpc_read_import,
  nlm_powerpc_write_import,
#ifndef OLDFORMAT
  nlm_powerpc_set_public_section,
  nlm_powerpc_get_public_offset,
#else
  0,	/* set_public_section */
  0,	/* get_public_offset */
#endif
  nlm_swap_fixed_header_in,
  nlm_swap_fixed_header_out,
  nlm_powerpc_write_external,
  0,	/* write_export */
};

#define TARGET_BIG_NAME			"nlm32-powerpc"
#define TARGET_BIG_SYM			nlmNAME(powerpc_vec)
#define TARGET_BACKEND_DATA		&nlm32_powerpc_backend

#include "nlm-target.h"
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 2000 Free Software Foundation, Inc.
d35 1
a35 1
static boolean nlm_powerpc_backend_object_p
d37 1
a37 1
static boolean nlm_powerpc_write_prefix
d41 1
a41 1
static boolean nlm_powerpc_read_reloc
d43 1
a43 1
static boolean nlm_powerpc_mangle_relocs
d45 1
a45 1
static boolean nlm_powerpc_read_import
d49 1
a49 1
static boolean nlm_powerpc_write_reloc
d53 1
a53 1
static boolean nlm_powerpc_write_import
d55 1
a55 1
static boolean nlm_powerpc_write_external
d59 1
a59 1
static boolean nlm_powerpc_set_public_section
d73 1
a73 1
static boolean
d79 2
a80 2
  if (bfd_read ((PTR) &s, sizeof s, 1, abfd) != sizeof s)
    return false;
d83 2
a84 2
      || bfd_h_get_32 (abfd, s.headerVersion) != NLM32_POWERPC_HEADER_VERSION)
    return false;
d86 1
a86 1
  return true;
d91 1
a91 1
static boolean
d99 2
a100 2
  bfd_h_put_32 (abfd, (bfd_vma) NLM32_POWERPC_HEADER_VERSION, s.headerVersion);
  bfd_h_put_32 (abfd, (bfd_vma) 0, s.origins);
d104 2
a105 2
  if (bfd_write ((PTR) &s, sizeof s, 1, abfd) != sizeof s)
    return false;
d107 1
a107 1
  return true;
d121 1
a121 1
	 false,			/* pc_relative */
d126 1
a126 1
	 true,			/* partial_inplace */
d129 1
a129 1
	 false);		/* pcrel_offset */
d133 1
a133 1
static boolean
d144 2
a145 2
  if (bfd_read (temp, sizeof (temp), 1, abfd) != sizeof (temp))
    return false;
d190 1
a190 1
  return true;
d207 1
a207 1
	 false,	                /* pc_relative */
d212 1
a212 1
	 true,	                /* partial_inplace */
d215 1
a215 1
	 false),                /* pcrel_offset */
d222 1
a222 1
	 false,	                /* pc_relative */
d227 1
a227 1
	 true,	                /* partial_inplace */
d230 1
a230 1
	 false),                /* pcrel_offset */
d237 1
a237 1
	 true,	                /* pc_relative */
d242 1
a242 1
	 true,	                /* partial_inplace */
d245 1
a245 1
	 false),                /* pcrel_offset */
d252 1
a252 1
	 false,	                /* pc_relative */
d257 1
a257 1
	 true,	                /* partial_inplace */
d260 1
a260 1
	 false),                /* pcrel_offset */
d267 1
a267 1
	 false,	                /* pc_relative */
d272 1
a272 1
	 true,	                /* partial_inplace */
d275 1
a275 1
	 false),                /* pcrel_offset */
d282 1
a282 1
	 false,	                /* pc_relative */
d287 1
a287 1
	 true,	                /* partial_inplace */
d290 1
a290 1
	 false),                /* pcrel_offset */
d297 1
a297 1
	 false,	                /* pc_relative */
d302 1
a302 1
	 true,	                /* partial_inplace */
d305 1
a305 1
	 false),                /* pcrel_offset */
d314 1
a314 1
	 false,	                /* pc_relative */
d319 1
a319 1
	 true,	                /* partial_inplace */
d322 1
a322 1
	 false),                /* pcrel_offset */
d331 1
a331 1
	 true,	                /* pc_relative */
d336 1
a336 1
	 true,	                /* partial_inplace */
d339 1
a339 1
	 false),                /* pcrel_offset */
d348 1
a348 1
	 false,	                /* pc_relative */
d353 1
a353 1
	 true,	                /* partial_inplace */
d356 1
a356 1
	 false),                /* pcrel_offset */
d363 1
a363 1
	 false,	                /* pc_relative */
d368 1
a368 1
	 true,	                /* partial_inplace */
d371 1
a371 1
	 false),                /* pcrel_offset */
d380 1
a380 1
	 false,	                /* pc_relative */
d385 1
a385 1
	 false,	                /* partial_inplace */
d388 1
a388 1
	 false),                /* pcrel_offset */
d398 1
a398 1
	 false,	                /* pc_relative */
d403 1
a403 1
	 true,	                /* partial_inplace */
d406 1
a406 1
	 false),                /* pcrel_offset */
d413 1
a413 1
	 false,	                /* pc_relative */
d418 1
a418 1
	 true,	                /* partial_inplace */
d421 1
a421 1
	 false),                /* pcrel_offset */
d428 1
a428 1
	 false,	                /* pc_relative */
d433 1
a433 1
	 true,	                /* partial_inplace */
d436 1
a436 1
	 false),                /* pcrel_offset */
d443 1
a443 1
	 false,	                /* pc_relative */
d448 1
a448 1
	 true,	                /* partial_inplace */
d451 1
a451 1
	 false),                /* pcrel_offset */
d458 1
a458 1
	 false,	                /* pc_relative */
d463 1
a463 1
	 true,	                /* partial_inplace */
d466 1
a466 1
	 false),                /* pcrel_offset */
d473 1
a473 1
	 false,	                /* pc_relative */
d478 1
a478 1
	 true,	                /* partial_inplace */
d481 1
a481 1
	 false),                /* pcrel_offset */
d488 1
a488 1
	 false,	                /* pc_relative */
d493 1
a493 1
	 true,	                /* partial_inplace */
d496 1
a496 1
	 false),                /* pcrel_offset */
d503 1
a503 1
	 false,	                /* pc_relative */
d508 1
a508 1
	 true,	                /* partial_inplace */
d511 1
a511 1
	 false),                /* pcrel_offset */
d518 1
a518 1
	 false,	                /* pc_relative */
d523 1
a523 1
	 true,	                /* partial_inplace */
d526 1
a526 1
	 false),                /* pcrel_offset */
d533 1
a533 1
	 false,	                /* pc_relative */
d538 1
a538 1
	 true,	                /* partial_inplace */
d541 1
a541 1
	 false)                 /* pcrel_offset */
d549 1
a549 1
static boolean
d564 2
a565 2
  if (bfd_read (&ext, sizeof ext, 1, abfd) != sizeof ext)
    return false;
d568 4
a571 4
  l_vaddr = bfd_h_get_32 (abfd, ext.l_vaddr);
  l_symndx = bfd_h_get_32 (abfd, ext.l_symndx);
  l_rtype = bfd_h_get_16 (abfd, ext.l_rtype);
  l_rsecnm = bfd_h_get_16 (abfd, ext.l_rsecnm);
d598 1
a598 1
	  return false;
d628 1
a628 1
      return false;
d633 1
a633 1
  return true;
d640 1
a640 1
static boolean
d648 1
a648 1
  return true;
d653 1
a653 1
static boolean
d664 1
a664 1
  if (bfd_read ((PTR) &symlength, sizeof (symlength), 1, abfd)
d666 1
a666 1
    return (false);
d668 1
a668 1
  name = bfd_alloc (abfd, symlength + 1);
d670 3
a672 3
    return false;
  if (bfd_read (name, symlength, 1, abfd) != symlength)
    return (false);
d678 4
a681 3
  if (bfd_read ((PTR) temp, sizeof (temp), 1, abfd) != sizeof (temp))
    return (false);
  rcount = bfd_h_get_32 (abfd, temp);
d685 1
a685 1
    return false;
d692 2
a693 4
      if (nlm_powerpc_read_reloc (abfd, sym, &section,
				  &nlm_relocs -> reloc)
	  == false)
	return false;
d698 1
a698 1
  return true;
d705 1
a705 1
static boolean
d727 1
a727 1
      return false;
d740 1
a740 1
      return false;
d764 2
a765 2
  if (bfd_write (temp, sizeof (temp), 1, abfd) != sizeof (temp))
    return false;
d767 1
a767 1
  return true;
d776 1
a776 1
static boolean
d816 1
a816 1
	  return false;
d820 1
a820 1
  bfd_h_put_32 (abfd, (bfd_vma) l_symndx, ext.l_symndx);
d844 1
a844 1
      return false;
d851 1
a851 1
  bfd_h_put_16 (abfd, (bfd_vma) l_rtype, ext.l_rtype);
d865 1
a865 1
      return false;
d868 2
a869 2
  bfd_h_put_16 (abfd, (bfd_vma) l_rsecnm, ext.l_rsecnm);
  bfd_h_put_32 (abfd, (bfd_vma) address, ext.l_vaddr);
d871 2
a872 2
  if (bfd_write (&ext, sizeof ext, 1, abfd) != sizeof ext)
    return false;
d874 1
a874 1
  return true;
d879 1
a879 1
static boolean
d894 1
a894 1
static boolean
d909 4
a912 3
  if ((bfd_write (&len, sizeof (bfd_byte), 1, abfd) != sizeof (bfd_byte))
      || bfd_write (sym->name, len, 1, abfd) != len)
    return false;
d915 2
a916 2
  if (bfd_write (temp, sizeof (temp), 1, abfd) != sizeof (temp))
    return false;
d922 1
a922 1
	return false;
d926 1
a926 1
	return false;
d934 1
a934 1
  return true;
d944 1
a944 1
static boolean
d964 1
a964 1
  return true;
d1016 1
a1016 1
  false,
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 2000, 2001, 2002 Free Software Foundation, Inc.
d35 1
a35 1
static bfd_boolean nlm_powerpc_backend_object_p
d37 1
a37 1
static bfd_boolean nlm_powerpc_write_prefix
d41 1
a41 1
static bfd_boolean nlm_powerpc_read_reloc
d43 1
a43 1
static bfd_boolean nlm_powerpc_mangle_relocs
d45 1
a45 1
static bfd_boolean nlm_powerpc_read_import
d49 1
a49 1
static bfd_boolean nlm_powerpc_write_reloc
d53 1
a53 1
static bfd_boolean nlm_powerpc_write_import
d55 1
a55 1
static bfd_boolean nlm_powerpc_write_external
d59 1
a59 1
static bfd_boolean nlm_powerpc_set_public_section
d73 1
a73 1
static bfd_boolean
d79 2
a80 2
  if (bfd_bread ((PTR) &s, (bfd_size_type) sizeof s, abfd) != sizeof s)
    return FALSE;
d83 2
a84 2
      || H_GET_32 (abfd, s.headerVersion) != NLM32_POWERPC_HEADER_VERSION)
    return FALSE;
d86 1
a86 1
  return TRUE;
d91 1
a91 1
static bfd_boolean
d99 2
a100 2
  H_PUT_32 (abfd, NLM32_POWERPC_HEADER_VERSION, s.headerVersion);
  H_PUT_32 (abfd, 0, s.origins);
d104 2
a105 2
  if (bfd_bwrite ((PTR) &s, (bfd_size_type) sizeof s, abfd) != sizeof s)
    return FALSE;
d107 1
a107 1
  return TRUE;
d121 1
a121 1
	 FALSE,			/* pc_relative */
d126 1
a126 1
	 TRUE,			/* partial_inplace */
d129 1
a129 1
	 FALSE);		/* pcrel_offset */
d133 1
a133 1
static bfd_boolean
d144 2
a145 2
  if (bfd_bread (temp, (bfd_size_type) sizeof (temp), abfd) != sizeof (temp))
    return FALSE;
d190 1
a190 1
  return TRUE;
d207 1
a207 1
	 FALSE,	                /* pc_relative */
d212 1
a212 1
	 TRUE,	                /* partial_inplace */
d215 1
a215 1
	 FALSE),                /* pcrel_offset */
d222 1
a222 1
	 FALSE,	                /* pc_relative */
d227 1
a227 1
	 TRUE,	                /* partial_inplace */
d230 1
a230 1
	 FALSE),                /* pcrel_offset */
d237 1
a237 1
	 TRUE,	                /* pc_relative */
d242 1
a242 1
	 TRUE,	                /* partial_inplace */
d245 1
a245 1
	 FALSE),                /* pcrel_offset */
d252 1
a252 1
	 FALSE,	                /* pc_relative */
d257 1
a257 1
	 TRUE,	                /* partial_inplace */
d260 1
a260 1
	 FALSE),                /* pcrel_offset */
d267 1
a267 1
	 FALSE,	                /* pc_relative */
d272 1
a272 1
	 TRUE,	                /* partial_inplace */
d275 1
a275 1
	 FALSE),                /* pcrel_offset */
d282 1
a282 1
	 FALSE,	                /* pc_relative */
d287 1
a287 1
	 TRUE,	                /* partial_inplace */
d290 1
a290 1
	 FALSE),                /* pcrel_offset */
d297 1
a297 1
	 FALSE,	                /* pc_relative */
d302 1
a302 1
	 TRUE,	                /* partial_inplace */
d305 1
a305 1
	 FALSE),                /* pcrel_offset */
d314 1
a314 1
	 FALSE,	                /* pc_relative */
d319 1
a319 1
	 TRUE,	                /* partial_inplace */
d322 1
a322 1
	 FALSE),                /* pcrel_offset */
d331 1
a331 1
	 TRUE,	                /* pc_relative */
d336 1
a336 1
	 TRUE,	                /* partial_inplace */
d339 1
a339 1
	 FALSE),                /* pcrel_offset */
d348 1
a348 1
	 FALSE,	                /* pc_relative */
d353 1
a353 1
	 TRUE,	                /* partial_inplace */
d356 1
a356 1
	 FALSE),                /* pcrel_offset */
d363 1
a363 1
	 FALSE,	                /* pc_relative */
d368 1
a368 1
	 TRUE,	                /* partial_inplace */
d371 1
a371 1
	 FALSE),                /* pcrel_offset */
d380 1
a380 1
	 FALSE,	                /* pc_relative */
d385 1
a385 1
	 FALSE,	                /* partial_inplace */
d388 1
a388 1
	 FALSE),                /* pcrel_offset */
d398 1
a398 1
	 FALSE,	                /* pc_relative */
d403 1
a403 1
	 TRUE,	                /* partial_inplace */
d406 1
a406 1
	 FALSE),                /* pcrel_offset */
d413 1
a413 1
	 FALSE,	                /* pc_relative */
d418 1
a418 1
	 TRUE,	                /* partial_inplace */
d421 1
a421 1
	 FALSE),                /* pcrel_offset */
d428 1
a428 1
	 FALSE,	                /* pc_relative */
d433 1
a433 1
	 TRUE,	                /* partial_inplace */
d436 1
a436 1
	 FALSE),                /* pcrel_offset */
d443 1
a443 1
	 FALSE,	                /* pc_relative */
d448 1
a448 1
	 TRUE,	                /* partial_inplace */
d451 1
a451 1
	 FALSE),                /* pcrel_offset */
d458 1
a458 1
	 FALSE,	                /* pc_relative */
d463 1
a463 1
	 TRUE,	                /* partial_inplace */
d466 1
a466 1
	 FALSE),                /* pcrel_offset */
d473 1
a473 1
	 FALSE,	                /* pc_relative */
d478 1
a478 1
	 TRUE,	                /* partial_inplace */
d481 1
a481 1
	 FALSE),                /* pcrel_offset */
d488 1
a488 1
	 FALSE,	                /* pc_relative */
d493 1
a493 1
	 TRUE,	                /* partial_inplace */
d496 1
a496 1
	 FALSE),                /* pcrel_offset */
d503 1
a503 1
	 FALSE,	                /* pc_relative */
d508 1
a508 1
	 TRUE,	                /* partial_inplace */
d511 1
a511 1
	 FALSE),                /* pcrel_offset */
d518 1
a518 1
	 FALSE,	                /* pc_relative */
d523 1
a523 1
	 TRUE,	                /* partial_inplace */
d526 1
a526 1
	 FALSE),                /* pcrel_offset */
d533 1
a533 1
	 FALSE,	                /* pc_relative */
d538 1
a538 1
	 TRUE,	                /* partial_inplace */
d541 1
a541 1
	 FALSE)                 /* pcrel_offset */
d549 1
a549 1
static bfd_boolean
d564 2
a565 2
  if (bfd_bread (&ext, (bfd_size_type) sizeof ext, abfd) != sizeof ext)
    return FALSE;
d568 4
a571 4
  l_vaddr = H_GET_32 (abfd, ext.l_vaddr);
  l_symndx = H_GET_32 (abfd, ext.l_symndx);
  l_rtype = H_GET_16 (abfd, ext.l_rtype);
  l_rsecnm = H_GET_16 (abfd, ext.l_rsecnm);
d598 1
a598 1
	  return FALSE;
d628 1
a628 1
      return FALSE;
d633 1
a633 1
  return TRUE;
d640 1
a640 1
static bfd_boolean
d648 1
a648 1
  return TRUE;
d653 1
a653 1
static bfd_boolean
d664 1
a664 1
  if (bfd_bread ((PTR) &symlength, (bfd_size_type) sizeof (symlength), abfd)
d666 1
a666 1
    return FALSE;
d668 1
a668 1
  name = bfd_alloc (abfd, (bfd_size_type) symlength + 1);
d670 3
a672 3
    return FALSE;
  if (bfd_bread (name, (bfd_size_type) symlength, abfd) != symlength)
    return FALSE;
d678 3
a680 4
  if (bfd_bread ((PTR) temp, (bfd_size_type) sizeof (temp), abfd)
      != sizeof (temp))
    return FALSE;
  rcount = H_GET_32 (abfd, temp);
d684 1
a684 1
    return FALSE;
d691 4
a694 2
      if (! nlm_powerpc_read_reloc (abfd, sym, &section, &nlm_relocs -> reloc))
	return FALSE;
d699 1
a699 1
  return TRUE;
d706 1
a706 1
static bfd_boolean
d728 1
a728 1
      return FALSE;
d741 1
a741 1
      return FALSE;
d765 2
a766 2
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), abfd) != sizeof (temp))
    return FALSE;
d768 1
a768 1
  return TRUE;
d777 1
a777 1
static bfd_boolean
d817 1
a817 1
	  return FALSE;
d821 1
a821 1
  H_PUT_32 (abfd, l_symndx, ext.l_symndx);
d845 1
a845 1
      return FALSE;
d852 1
a852 1
  H_PUT_16 (abfd, l_rtype, ext.l_rtype);
d866 1
a866 1
      return FALSE;
d869 2
a870 2
  H_PUT_16 (abfd, l_rsecnm, ext.l_rsecnm);
  H_PUT_32 (abfd, address, ext.l_vaddr);
d872 2
a873 2
  if (bfd_bwrite (&ext, (bfd_size_type) sizeof ext, abfd) != sizeof ext)
    return FALSE;
d875 1
a875 1
  return TRUE;
d880 1
a880 1
static bfd_boolean
d895 1
a895 1
static bfd_boolean
d910 3
a912 4
  if ((bfd_bwrite (&len, (bfd_size_type) sizeof (bfd_byte), abfd)
       != sizeof (bfd_byte))
      || bfd_bwrite (sym->name, (bfd_size_type) len, abfd) != len)
    return FALSE;
d915 2
a916 2
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), abfd) != sizeof (temp))
    return FALSE;
d922 1
a922 1
	return FALSE;
d926 1
a926 1
	return FALSE;
d934 1
a934 1
  return TRUE;
d944 1
a944 1
static bfd_boolean
d964 1
a964 1
  return TRUE;
d1016 1
a1016 1
  FALSE,
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d44 1
a44 1
  PARAMS ((bfd *, asection *, const PTR, bfd_vma, bfd_size_type));
d644 1
a644 1
     const PTR data ATTRIBUTE_UNUSED;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 2000, 2001, 2002 Free Software Foundation, Inc.
d35 1
a35 1
static bfd_boolean nlm_powerpc_backend_object_p
d37 1
a37 1
static bfd_boolean nlm_powerpc_write_prefix
d41 1
a41 1
static bfd_boolean nlm_powerpc_read_reloc
d43 1
a43 1
static bfd_boolean nlm_powerpc_mangle_relocs
d45 1
a45 1
static bfd_boolean nlm_powerpc_read_import
d49 1
a49 1
static bfd_boolean nlm_powerpc_write_reloc
d53 1
a53 1
static bfd_boolean nlm_powerpc_write_import
d55 1
a55 1
static bfd_boolean nlm_powerpc_write_external
d59 1
a59 1
static bfd_boolean nlm_powerpc_set_public_section
d73 1
a73 1
static bfd_boolean
d79 2
a80 2
  if (bfd_bread ((PTR) &s, (bfd_size_type) sizeof s, abfd) != sizeof s)
    return FALSE;
d83 2
a84 2
      || H_GET_32 (abfd, s.headerVersion) != NLM32_POWERPC_HEADER_VERSION)
    return FALSE;
d86 1
a86 1
  return TRUE;
d91 1
a91 1
static bfd_boolean
d99 2
a100 2
  H_PUT_32 (abfd, NLM32_POWERPC_HEADER_VERSION, s.headerVersion);
  H_PUT_32 (abfd, 0, s.origins);
d104 2
a105 2
  if (bfd_bwrite ((PTR) &s, (bfd_size_type) sizeof s, abfd) != sizeof s)
    return FALSE;
d107 1
a107 1
  return TRUE;
d121 1
a121 1
	 FALSE,			/* pc_relative */
d126 1
a126 1
	 TRUE,			/* partial_inplace */
d129 1
a129 1
	 FALSE);		/* pcrel_offset */
d133 1
a133 1
static bfd_boolean
d144 2
a145 2
  if (bfd_bread (temp, (bfd_size_type) sizeof (temp), abfd) != sizeof (temp))
    return FALSE;
d190 1
a190 1
  return TRUE;
d207 1
a207 1
	 FALSE,	                /* pc_relative */
d212 1
a212 1
	 TRUE,	                /* partial_inplace */
d215 1
a215 1
	 FALSE),                /* pcrel_offset */
d222 1
a222 1
	 FALSE,	                /* pc_relative */
d227 1
a227 1
	 TRUE,	                /* partial_inplace */
d230 1
a230 1
	 FALSE),                /* pcrel_offset */
d237 1
a237 1
	 TRUE,	                /* pc_relative */
d242 1
a242 1
	 TRUE,	                /* partial_inplace */
d245 1
a245 1
	 FALSE),                /* pcrel_offset */
d252 1
a252 1
	 FALSE,	                /* pc_relative */
d257 1
a257 1
	 TRUE,	                /* partial_inplace */
d260 1
a260 1
	 FALSE),                /* pcrel_offset */
d267 1
a267 1
	 FALSE,	                /* pc_relative */
d272 1
a272 1
	 TRUE,	                /* partial_inplace */
d275 1
a275 1
	 FALSE),                /* pcrel_offset */
d282 1
a282 1
	 FALSE,	                /* pc_relative */
d287 1
a287 1
	 TRUE,	                /* partial_inplace */
d290 1
a290 1
	 FALSE),                /* pcrel_offset */
d297 1
a297 1
	 FALSE,	                /* pc_relative */
d302 1
a302 1
	 TRUE,	                /* partial_inplace */
d305 1
a305 1
	 FALSE),                /* pcrel_offset */
d314 1
a314 1
	 FALSE,	                /* pc_relative */
d319 1
a319 1
	 TRUE,	                /* partial_inplace */
d322 1
a322 1
	 FALSE),                /* pcrel_offset */
d331 1
a331 1
	 TRUE,	                /* pc_relative */
d336 1
a336 1
	 TRUE,	                /* partial_inplace */
d339 1
a339 1
	 FALSE),                /* pcrel_offset */
d348 1
a348 1
	 FALSE,	                /* pc_relative */
d353 1
a353 1
	 TRUE,	                /* partial_inplace */
d356 1
a356 1
	 FALSE),                /* pcrel_offset */
d363 1
a363 1
	 FALSE,	                /* pc_relative */
d368 1
a368 1
	 TRUE,	                /* partial_inplace */
d371 1
a371 1
	 FALSE),                /* pcrel_offset */
d380 1
a380 1
	 FALSE,	                /* pc_relative */
d385 1
a385 1
	 FALSE,	                /* partial_inplace */
d388 1
a388 1
	 FALSE),                /* pcrel_offset */
d398 1
a398 1
	 FALSE,	                /* pc_relative */
d403 1
a403 1
	 TRUE,	                /* partial_inplace */
d406 1
a406 1
	 FALSE),                /* pcrel_offset */
d413 1
a413 1
	 FALSE,	                /* pc_relative */
d418 1
a418 1
	 TRUE,	                /* partial_inplace */
d421 1
a421 1
	 FALSE),                /* pcrel_offset */
d428 1
a428 1
	 FALSE,	                /* pc_relative */
d433 1
a433 1
	 TRUE,	                /* partial_inplace */
d436 1
a436 1
	 FALSE),                /* pcrel_offset */
d443 1
a443 1
	 FALSE,	                /* pc_relative */
d448 1
a448 1
	 TRUE,	                /* partial_inplace */
d451 1
a451 1
	 FALSE),                /* pcrel_offset */
d458 1
a458 1
	 FALSE,	                /* pc_relative */
d463 1
a463 1
	 TRUE,	                /* partial_inplace */
d466 1
a466 1
	 FALSE),                /* pcrel_offset */
d473 1
a473 1
	 FALSE,	                /* pc_relative */
d478 1
a478 1
	 TRUE,	                /* partial_inplace */
d481 1
a481 1
	 FALSE),                /* pcrel_offset */
d488 1
a488 1
	 FALSE,	                /* pc_relative */
d493 1
a493 1
	 TRUE,	                /* partial_inplace */
d496 1
a496 1
	 FALSE),                /* pcrel_offset */
d503 1
a503 1
	 FALSE,	                /* pc_relative */
d508 1
a508 1
	 TRUE,	                /* partial_inplace */
d511 1
a511 1
	 FALSE),                /* pcrel_offset */
d518 1
a518 1
	 FALSE,	                /* pc_relative */
d523 1
a523 1
	 TRUE,	                /* partial_inplace */
d526 1
a526 1
	 FALSE),                /* pcrel_offset */
d533 1
a533 1
	 FALSE,	                /* pc_relative */
d538 1
a538 1
	 TRUE,	                /* partial_inplace */
d541 1
a541 1
	 FALSE)                 /* pcrel_offset */
d549 1
a549 1
static bfd_boolean
d564 2
a565 2
  if (bfd_bread (&ext, (bfd_size_type) sizeof ext, abfd) != sizeof ext)
    return FALSE;
d568 4
a571 4
  l_vaddr = H_GET_32 (abfd, ext.l_vaddr);
  l_symndx = H_GET_32 (abfd, ext.l_symndx);
  l_rtype = H_GET_16 (abfd, ext.l_rtype);
  l_rsecnm = H_GET_16 (abfd, ext.l_rsecnm);
d598 1
a598 1
	  return FALSE;
d628 1
a628 1
      return FALSE;
d633 1
a633 1
  return TRUE;
d640 1
a640 1
static bfd_boolean
d648 1
a648 1
  return TRUE;
d653 1
a653 1
static bfd_boolean
d664 1
a664 1
  if (bfd_bread ((PTR) &symlength, (bfd_size_type) sizeof (symlength), abfd)
d666 1
a666 1
    return FALSE;
d668 1
a668 1
  name = bfd_alloc (abfd, (bfd_size_type) symlength + 1);
d670 3
a672 3
    return FALSE;
  if (bfd_bread (name, (bfd_size_type) symlength, abfd) != symlength)
    return FALSE;
d678 3
a680 4
  if (bfd_bread ((PTR) temp, (bfd_size_type) sizeof (temp), abfd)
      != sizeof (temp))
    return FALSE;
  rcount = H_GET_32 (abfd, temp);
d684 1
a684 1
    return FALSE;
d691 4
a694 2
      if (! nlm_powerpc_read_reloc (abfd, sym, &section, &nlm_relocs -> reloc))
	return FALSE;
d699 1
a699 1
  return TRUE;
d706 1
a706 1
static bfd_boolean
d728 1
a728 1
      return FALSE;
d741 1
a741 1
      return FALSE;
d765 2
a766 2
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), abfd) != sizeof (temp))
    return FALSE;
d768 1
a768 1
  return TRUE;
d777 1
a777 1
static bfd_boolean
d817 1
a817 1
	  return FALSE;
d821 1
a821 1
  H_PUT_32 (abfd, l_symndx, ext.l_symndx);
d845 1
a845 1
      return FALSE;
d852 1
a852 1
  H_PUT_16 (abfd, l_rtype, ext.l_rtype);
d866 1
a866 1
      return FALSE;
d869 2
a870 2
  H_PUT_16 (abfd, l_rsecnm, ext.l_rsecnm);
  H_PUT_32 (abfd, address, ext.l_vaddr);
d872 2
a873 2
  if (bfd_bwrite (&ext, (bfd_size_type) sizeof ext, abfd) != sizeof ext)
    return FALSE;
d875 1
a875 1
  return TRUE;
d880 1
a880 1
static bfd_boolean
d895 1
a895 1
static bfd_boolean
d910 3
a912 4
  if ((bfd_bwrite (&len, (bfd_size_type) sizeof (bfd_byte), abfd)
       != sizeof (bfd_byte))
      || bfd_bwrite (sym->name, (bfd_size_type) len, abfd) != len)
    return FALSE;
d915 2
a916 2
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), abfd) != sizeof (temp))
    return FALSE;
d922 1
a922 1
	return FALSE;
d926 1
a926 1
	return FALSE;
d934 1
a934 1
  return TRUE;
d944 1
a944 1
static bfd_boolean
d964 1
a964 1
  return TRUE;
d1016 1
a1016 1
  FALSE,
@

