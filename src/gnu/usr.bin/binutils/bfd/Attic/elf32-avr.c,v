head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.20.50.00;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.00.18;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.38.59;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.38.59;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.26.22;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.40.37;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.04.09;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.07.09;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* AVR-specific support for 32-bit ELF
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
   Contributed by Denis Chertykov <denisc@@overta.ru>

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/avr.h"

static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
static void avr_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static asection *elf32_avr_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf32_avr_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf32_avr_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_reloc_status_type avr_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
static bfd_boolean elf32_avr_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static void bfd_elf_avr_final_write_processing PARAMS ((bfd *, bfd_boolean));
static bfd_boolean elf32_avr_object_p PARAMS ((bfd *));

static reloc_howto_type elf_avr_howto_table[] =
{
  HOWTO (R_AVR_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_AVR_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 7 bit PC relative relocation.  */
  HOWTO (R_AVR_7_PCREL,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 TRUE,			/* pc_relative */
	 3,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_AVR_7_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 13 bit PC relative relocation.  */
  HOWTO (R_AVR_13_PCREL,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_AVR_13_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 16 bit absolute relocation.  */
  HOWTO (R_AVR_16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit absolute relocation for command address.  */
  HOWTO (R_AVR_16_PM,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_16_PM",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A low 8 bit absolute relocation of 16 bit address.
     For LDI command.  */
  HOWTO (R_AVR_LO8_LDI,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_LO8_LDI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A high 8 bit absolute relocation of 16 bit address.
     For LDI command.  */
  HOWTO (R_AVR_HI8_LDI,		/* type */
	 8,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HI8_LDI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A high 6 bit absolute relocation of 22 bit address.
     For LDI command.  */
  HOWTO (R_AVR_HH8_LDI,		/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HH8_LDI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A negative low 8 bit absolute relocation of 16 bit address.
     For LDI command.  */
  HOWTO (R_AVR_LO8_LDI_NEG,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_LO8_LDI_NEG",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A hegative high 8 bit absolute relocation of 16 bit address.
     For LDI command.  */
  HOWTO (R_AVR_HI8_LDI_NEG,	/* type */
	 8,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HI8_LDI_NEG",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A hegative high 6 bit absolute relocation of 22 bit address.
     For LDI command.  */
  HOWTO (R_AVR_HH8_LDI_NEG,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HH8_LDI_NEG",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A low 8 bit absolute relocation of 24 bit program memory address.
     For LDI command.  */
  HOWTO (R_AVR_LO8_LDI_PM,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_LO8_LDI_PM",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A high 8 bit absolute relocation of 16 bit program memory address.
     For LDI command.  */
  HOWTO (R_AVR_HI8_LDI_PM,	/* type */
	 9,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HI8_LDI_PM",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A high 8 bit absolute relocation of 24 bit program memory address.
     For LDI command.  */
  HOWTO (R_AVR_HH8_LDI_PM,	/* type */
	 17,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HH8_LDI_PM",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A low 8 bit absolute relocation of a negative 24 bit
     program memory address.  For LDI command.  */
  HOWTO (R_AVR_LO8_LDI_PM_NEG,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_LO8_LDI_PM_NEG", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A high 8 bit absolute relocation of a negative 16 bit
     program memory address.  For LDI command.  */
  HOWTO (R_AVR_HI8_LDI_PM_NEG,	/* type */
	 9,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HI8_LDI_PM_NEG", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A high 8 bit absolute relocation of a negative 24 bit
     program memory address.  For LDI command.  */
  HOWTO (R_AVR_HH8_LDI_PM_NEG,	/* type */
	 17,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HH8_LDI_PM_NEG", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* Relocation for CALL command in ATmega.  */
  HOWTO (R_AVR_CALL,		/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 23,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_CALL",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE)			/* pcrel_offset */
};

/* Map BFD reloc types to AVR ELF reloc types.  */

struct avr_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned int elf_reloc_val;
};

 static const struct avr_reloc_map avr_reloc_map[] =
{
  { BFD_RELOC_NONE,                 R_AVR_NONE },
  { BFD_RELOC_32,                   R_AVR_32 },
  { BFD_RELOC_AVR_7_PCREL,          R_AVR_7_PCREL },
  { BFD_RELOC_AVR_13_PCREL,         R_AVR_13_PCREL },
  { BFD_RELOC_16,                   R_AVR_16 },
  { BFD_RELOC_AVR_16_PM,            R_AVR_16_PM },
  { BFD_RELOC_AVR_LO8_LDI,          R_AVR_LO8_LDI},
  { BFD_RELOC_AVR_HI8_LDI,          R_AVR_HI8_LDI },
  { BFD_RELOC_AVR_HH8_LDI,          R_AVR_HH8_LDI },
  { BFD_RELOC_AVR_LO8_LDI_NEG,      R_AVR_LO8_LDI_NEG },
  { BFD_RELOC_AVR_HI8_LDI_NEG,      R_AVR_HI8_LDI_NEG },
  { BFD_RELOC_AVR_HH8_LDI_NEG,      R_AVR_HH8_LDI_NEG },
  { BFD_RELOC_AVR_LO8_LDI_PM,       R_AVR_LO8_LDI_PM },
  { BFD_RELOC_AVR_HI8_LDI_PM,       R_AVR_HI8_LDI_PM },
  { BFD_RELOC_AVR_HH8_LDI_PM,       R_AVR_HH8_LDI_PM },
  { BFD_RELOC_AVR_LO8_LDI_PM_NEG,   R_AVR_LO8_LDI_PM_NEG },
  { BFD_RELOC_AVR_HI8_LDI_PM_NEG,   R_AVR_HI8_LDI_PM_NEG },
  { BFD_RELOC_AVR_HH8_LDI_PM_NEG,   R_AVR_HH8_LDI_PM_NEG },
  { BFD_RELOC_AVR_CALL,             R_AVR_CALL }
};

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  unsigned int i;

  for (i = 0;
       i < sizeof (avr_reloc_map) / sizeof (struct avr_reloc_map);
       i++)
    {
      if (avr_reloc_map[i].bfd_reloc_val == code)
	return &elf_avr_howto_table[avr_reloc_map[i].elf_reloc_val];
    }

  return NULL;
}

/* Set the howto pointer for an AVR ELF reloc.  */

static void
avr_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_AVR_max);
  cache_ptr->howto = &elf_avr_howto_table[r_type];
}

static asection *
elf32_avr_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

static bfd_boolean
elf32_avr_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
  /* We don't use got and plt entries for avr.  */
  return TRUE;
}

/* Look through the relocs for a section during the first phase.
   Since we don't do .gots or .plts, we just need to consider the
   virtual table relocs for gc.  */

static bfd_boolean
elf32_avr_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;

  if (info->relocateable)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof (Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];
    }

  return TRUE;
}

/* Perform a single relocation.  By default we use the standard BFD
   routines, but a few relocs, we have to do them ourselves.  */

static bfd_reloc_status_type
avr_final_link_relocate (howto, input_bfd, input_section,
			 contents, rel, relocation)
     reloc_howto_type *  howto;
     bfd *               input_bfd;
     asection *          input_section;
     bfd_byte *          contents;
     Elf_Internal_Rela * rel;
     bfd_vma             relocation;
{
  bfd_reloc_status_type r = bfd_reloc_ok;
  bfd_vma               x;
  bfd_signed_vma	srel;

  switch (howto->type)
    {
    case R_AVR_7_PCREL:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      srel -= rel->r_offset;
      srel -= 2;	/* Branch instructions add 2 to the PC...  */
      srel -= (input_section->output_section->vma +
	       input_section->output_offset);

      if (srel & 1)
	return bfd_reloc_outofrange;
      if (srel > ((1 << 7) - 1) || (srel < - (1 << 7)))
	return bfd_reloc_overflow;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xfc07) | (((srel >> 1) << 3) & 0x3f8);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_13_PCREL:
      contents   += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      srel -= rel->r_offset;
      srel -= 2;	/* Branch instructions add 2 to the PC...  */
      srel -= (input_section->output_section->vma +
	       input_section->output_offset);

      if (srel & 1)
	return bfd_reloc_outofrange;

      /* AVR addresses commands as words.  */
      srel >>= 1;

      /* Check for overflow.  */
      if (srel < -2048 || srel > 2047)
	{
	  /* Apply WRAPAROUND if possible.  */
	  switch (bfd_get_mach (input_bfd))
	    {
	    case bfd_mach_avr2:
	    case bfd_mach_avr4:
	      break;

	    default:
	      return bfd_reloc_overflow;
	    }
	}

      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf000) | (srel & 0xfff);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_LO8_LDI:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HI8_LDI:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = (srel >> 8) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HH8_LDI:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = (srel >> 16) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_LO8_LDI_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HI8_LDI_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      srel = (srel >> 8) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HH8_LDI_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      srel = (srel >> 16) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_LO8_LDI_PM:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HI8_LDI_PM:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      srel = (srel >> 8) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HH8_LDI_PM:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      srel = (srel >> 16) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_LO8_LDI_PM_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HI8_LDI_PM_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      srel = (srel >> 8) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HH8_LDI_PM_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      srel = (srel >> 16) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_CALL:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      x = bfd_get_16 (input_bfd, contents);
      x |= ((srel & 0x10000) | ((srel << 3) & 0x1f00000)) >> 16;
      bfd_put_16 (input_bfd, x, contents);
      bfd_put_16 (input_bfd, (bfd_vma) srel & 0xffff, contents+2);
      break;

    default:
      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, rel->r_addend);
    }

  return r;
}

/* Relocate an AVR ELF section.  */
static bfd_boolean
elf32_avr_relocate_section (output_bfd, info, input_bfd, input_section,
			    contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  Elf_Internal_Rela *           rel;
  Elf_Internal_Rela *           relend;

  if (info->relocateable)
    return TRUE;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend     = relocs + input_section->reloc_count;

  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
      const char *                 name = NULL;
      int                          r_type;

      /* This is a final link.  */
      r_type = ELF32_R_TYPE (rel->r_info);
      r_symndx = ELF32_R_SYM (rel->r_info);
      howto  = elf_avr_howto_table + ELF32_R_TYPE (rel->r_info);
      h      = NULL;
      sym    = NULL;
      sec    = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
	}
      else
	{
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  name = h->root.root.string;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
	      relocation = 0;
	    }
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
	      relocation = 0;
	    }
	}

      r = avr_final_link_relocate (howto, input_bfd, input_section,
				   contents, rel, relocation);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

/* The final processing done just before writing out a AVR ELF object
   file.  This gets the AVR architecture right based on the machine
   number.  */

static void
bfd_elf_avr_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
{
  unsigned long val;

  switch (bfd_get_mach (abfd))
    {
    default:
    case bfd_mach_avr2:
      val = E_AVR_MACH_AVR2;
      break;

    case bfd_mach_avr1:
      val = E_AVR_MACH_AVR1;
      break;

    case bfd_mach_avr3:
      val = E_AVR_MACH_AVR3;
      break;

    case bfd_mach_avr4:
      val = E_AVR_MACH_AVR4;
      break;

    case bfd_mach_avr5:
      val = E_AVR_MACH_AVR5;
      break;
    }

  elf_elfheader (abfd)->e_machine = EM_AVR;
  elf_elfheader (abfd)->e_flags &= ~ EF_AVR_MACH;
  elf_elfheader (abfd)->e_flags |= val;
}

/* Set the right machine number.  */

static bfd_boolean
elf32_avr_object_p (abfd)
     bfd *abfd;
{
  unsigned int e_set = bfd_mach_avr2;
  if (elf_elfheader (abfd)->e_machine == EM_AVR
      || elf_elfheader (abfd)->e_machine == EM_AVR_OLD)
    {
      int e_mach = elf_elfheader (abfd)->e_flags & EF_AVR_MACH;
      switch (e_mach)
	{
	default:
	case E_AVR_MACH_AVR2:
	  e_set = bfd_mach_avr2;
	  break;

	case E_AVR_MACH_AVR1:
	  e_set = bfd_mach_avr1;
	  break;

	case E_AVR_MACH_AVR3:
	  e_set = bfd_mach_avr3;
	  break;

	case E_AVR_MACH_AVR4:
	  e_set = bfd_mach_avr4;
	  break;

	case E_AVR_MACH_AVR5:
	  e_set = bfd_mach_avr5;
	  break;
	}
    }
  return bfd_default_set_arch_mach (abfd, bfd_arch_avr,
				    e_set);
}

#define ELF_ARCH		bfd_arch_avr
#define ELF_MACHINE_CODE	EM_AVR
#define ELF_MACHINE_ALT1	EM_AVR_OLD
#define ELF_MAXPAGESIZE		1

#define TARGET_LITTLE_SYM       bfd_elf32_avr_vec
#define TARGET_LITTLE_NAME	"elf32-avr"

#define elf_info_to_howto	             avr_info_to_howto_rela
#define elf_info_to_howto_rel	             NULL
#define elf_backend_relocate_section         elf32_avr_relocate_section
#define elf_backend_gc_mark_hook             elf32_avr_gc_mark_hook
#define elf_backend_gc_sweep_hook            elf32_avr_gc_sweep_hook
#define elf_backend_check_relocs             elf32_avr_check_relocs
#define elf_backend_can_gc_sections          1
#define elf_backend_rela_normal		     1
#define elf_backend_final_write_processing \
					bfd_elf_avr_final_write_processing
#define elf_backend_object_p		elf32_avr_object_p

#include "elf32-target.h"
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d30 1
a30 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
d32 1
a32 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d34 1
a34 1
static boolean elf32_avr_gc_sweep_hook
d37 1
a37 1
static boolean elf32_avr_check_relocs
d43 1
a43 1
static boolean elf32_avr_relocate_section
d46 2
a47 5
static void bfd_elf_avr_final_write_processing PARAMS ((bfd *, boolean));
static boolean elf32_avr_object_p PARAMS ((bfd *));

/* Use RELA instead of REL */
#undef USE_REL
d55 1
a55 1
	 false,			/* pc_relative */
d60 1
a60 1
	 false,			/* partial_inplace */
d63 1
a63 1
	 false),		/* pcrel_offset */
d69 1
a69 1
	 false,			/* pc_relative */
d74 1
a74 1
	 false,			/* partial_inplace */
d77 1
a77 1
	 false),		/* pcrel_offset */
d84 1
a84 1
	 true,			/* pc_relative */
d89 1
a89 1
	 false,			/* partial_inplace */
d92 1
a92 1
	 true),			/* pcrel_offset */
d99 1
a99 1
	 true,			/* pc_relative */
d104 1
a104 1
	 false,			/* partial_inplace */
d107 1
a107 1
	 true),			/* pcrel_offset */
d114 1
a114 1
	 false,			/* pc_relative */
d119 1
a119 1
	 false,			/* partial_inplace */
d122 1
a122 1
	 false),		/* pcrel_offset */
d129 1
a129 1
	 false,			/* pc_relative */
d134 1
a134 1
	 false,			/* partial_inplace */
d137 1
a137 1
	 false),		/* pcrel_offset */
d144 1
a144 1
	 false,			/* pc_relative */
d149 1
a149 1
	 false,			/* partial_inplace */
d152 1
a152 1
	 false),		/* pcrel_offset */
d159 1
a159 1
	 false,			/* pc_relative */
d164 1
a164 1
	 false,			/* partial_inplace */
d167 1
a167 1
	 false),		/* pcrel_offset */
d174 1
a174 1
	 false,			/* pc_relative */
d179 1
a179 1
	 false,			/* partial_inplace */
d182 1
a182 1
	 false),		/* pcrel_offset */
d189 1
a189 1
	 false,			/* pc_relative */
d194 1
a194 1
	 false,			/* partial_inplace */
d197 1
a197 1
	 false),		/* pcrel_offset */
d204 1
a204 1
	 false,			/* pc_relative */
d209 1
a209 1
	 false,			/* partial_inplace */
d212 1
a212 1
	 false),		/* pcrel_offset */
d219 1
a219 1
	 false,			/* pc_relative */
d224 1
a224 1
	 false,			/* partial_inplace */
d227 1
a227 1
	 false),		/* pcrel_offset */
d234 1
a234 1
	 false,			/* pc_relative */
d239 1
a239 1
	 false,			/* partial_inplace */
d242 1
a242 1
	 false),		/* pcrel_offset */
d249 1
a249 1
	 false,			/* pc_relative */
d254 1
a254 1
	 false,			/* partial_inplace */
d257 1
a257 1
	 false),		/* pcrel_offset */
d264 1
a264 1
	 false,			/* pc_relative */
d269 1
a269 1
	 false,			/* partial_inplace */
d272 1
a272 1
	 false),		/* pcrel_offset */
d279 1
a279 1
	 false,			/* pc_relative */
d284 1
a284 1
	 false,			/* partial_inplace */
d287 1
a287 1
	 false),		/* pcrel_offset */
d294 1
a294 1
	 false,			/* pc_relative */
d299 1
a299 1
	 false,			/* partial_inplace */
d302 1
a302 1
	 false),		/* pcrel_offset */
d309 1
a309 1
	 false,			/* pc_relative */
d314 1
a314 1
	 false,			/* partial_inplace */
d317 1
a317 1
	 false),		/* pcrel_offset */
d323 1
a323 1
	 false,			/* pc_relative */
d328 1
a328 1
	 false,			/* partial_inplace */
d331 1
a331 1
	 false)			/* pcrel_offset */
d389 1
a389 1
     Elf32_Internal_Rela *dst;
d399 2
a400 2
elf32_avr_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d426 2
a427 9
    {
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && !((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
	       && sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
    }
d431 1
a431 1
static boolean
d439 1
a439 1
  return true;
d446 1
a446 1
static boolean
d459 1
a459 1
    return true;
d480 1
a480 1
  return true;
d692 1
a692 1
      bfd_put_16 (input_bfd, srel & 0xffff, contents+2);
d705 1
a705 1
static boolean
d722 3
d741 1
a743 22

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;

	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections [r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d753 1
a753 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
d785 2
a786 2
		      input_section, rel->r_offset, true)))
		return false;
d808 1
a808 1
		(info, name, input_bfd, input_section, rel->r_offset, true);
d833 1
a833 1
	    return false;
d837 1
a837 1
  return true;
d847 1
a847 1
     boolean linker ATTRIBUTE_UNUSED;
d882 1
a882 1
static boolean
d886 3
a888 2
  int e_set = bfd_mach_avr2;
  if (elf_elfheader (abfd)->e_machine == EM_AVR)
d921 1
d934 1
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d30 1
a30 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d32 1
a32 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d34 1
a34 1
static bfd_boolean elf32_avr_gc_sweep_hook
d37 1
a37 1
static bfd_boolean elf32_avr_check_relocs
d43 1
a43 1
static bfd_boolean elf32_avr_relocate_section
d46 5
a50 2
static void bfd_elf_avr_final_write_processing PARAMS ((bfd *, bfd_boolean));
static bfd_boolean elf32_avr_object_p PARAMS ((bfd *));
d58 1
a58 1
	 FALSE,			/* pc_relative */
d63 1
a63 1
	 FALSE,			/* partial_inplace */
d66 1
a66 1
	 FALSE),		/* pcrel_offset */
d72 1
a72 1
	 FALSE,			/* pc_relative */
d77 1
a77 1
	 FALSE,			/* partial_inplace */
d80 1
a80 1
	 FALSE),		/* pcrel_offset */
d87 1
a87 1
	 TRUE,			/* pc_relative */
d92 1
a92 1
	 FALSE,			/* partial_inplace */
d95 1
a95 1
	 TRUE),			/* pcrel_offset */
d102 1
a102 1
	 TRUE,			/* pc_relative */
d107 1
a107 1
	 FALSE,			/* partial_inplace */
d110 1
a110 1
	 TRUE),			/* pcrel_offset */
d117 1
a117 1
	 FALSE,			/* pc_relative */
d122 1
a122 1
	 FALSE,			/* partial_inplace */
d125 1
a125 1
	 FALSE),		/* pcrel_offset */
d132 1
a132 1
	 FALSE,			/* pc_relative */
d137 1
a137 1
	 FALSE,			/* partial_inplace */
d140 1
a140 1
	 FALSE),		/* pcrel_offset */
d147 1
a147 1
	 FALSE,			/* pc_relative */
d152 1
a152 1
	 FALSE,			/* partial_inplace */
d155 1
a155 1
	 FALSE),		/* pcrel_offset */
d162 1
a162 1
	 FALSE,			/* pc_relative */
d167 1
a167 1
	 FALSE,			/* partial_inplace */
d170 1
a170 1
	 FALSE),		/* pcrel_offset */
d177 1
a177 1
	 FALSE,			/* pc_relative */
d182 1
a182 1
	 FALSE,			/* partial_inplace */
d185 1
a185 1
	 FALSE),		/* pcrel_offset */
d192 1
a192 1
	 FALSE,			/* pc_relative */
d197 1
a197 1
	 FALSE,			/* partial_inplace */
d200 1
a200 1
	 FALSE),		/* pcrel_offset */
d207 1
a207 1
	 FALSE,			/* pc_relative */
d212 1
a212 1
	 FALSE,			/* partial_inplace */
d215 1
a215 1
	 FALSE),		/* pcrel_offset */
d222 1
a222 1
	 FALSE,			/* pc_relative */
d227 1
a227 1
	 FALSE,			/* partial_inplace */
d230 1
a230 1
	 FALSE),		/* pcrel_offset */
d237 1
a237 1
	 FALSE,			/* pc_relative */
d242 1
a242 1
	 FALSE,			/* partial_inplace */
d245 1
a245 1
	 FALSE),		/* pcrel_offset */
d252 1
a252 1
	 FALSE,			/* pc_relative */
d257 1
a257 1
	 FALSE,			/* partial_inplace */
d260 1
a260 1
	 FALSE),		/* pcrel_offset */
d267 1
a267 1
	 FALSE,			/* pc_relative */
d272 1
a272 1
	 FALSE,			/* partial_inplace */
d275 1
a275 1
	 FALSE),		/* pcrel_offset */
d282 1
a282 1
	 FALSE,			/* pc_relative */
d287 1
a287 1
	 FALSE,			/* partial_inplace */
d290 1
a290 1
	 FALSE),		/* pcrel_offset */
d297 1
a297 1
	 FALSE,			/* pc_relative */
d302 1
a302 1
	 FALSE,			/* partial_inplace */
d305 1
a305 1
	 FALSE),		/* pcrel_offset */
d312 1
a312 1
	 FALSE,			/* pc_relative */
d317 1
a317 1
	 FALSE,			/* partial_inplace */
d320 1
a320 1
	 FALSE),		/* pcrel_offset */
d326 1
a326 1
	 FALSE,			/* pc_relative */
d331 1
a331 1
	 FALSE,			/* partial_inplace */
d334 1
a334 1
	 FALSE)			/* pcrel_offset */
d392 1
a392 1
     Elf_Internal_Rela *dst;
d402 2
a403 2
elf32_avr_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d429 9
a437 2
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

d441 1
a441 1
static bfd_boolean
d449 1
a449 1
  return TRUE;
d456 1
a456 1
static bfd_boolean
d469 1
a469 1
    return TRUE;
d490 1
a490 1
  return TRUE;
d702 1
a702 1
      bfd_put_16 (input_bfd, (bfd_vma) srel & 0xffff, contents+2);
d715 1
a715 1
static bfd_boolean
a731 3
  if (info->relocateable)
    return TRUE;

a747 1
      /* This is a final link.  */
d750 22
d781 3
a783 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d815 2
a816 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d838 1
a838 1
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
d863 1
a863 1
	    return FALSE;
d867 1
a867 1
  return TRUE;
d877 1
a877 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d912 1
a912 1
static bfd_boolean
d916 2
a917 3
  unsigned int e_set = bfd_mach_avr2;
  if (elf_elfheader (abfd)->e_machine == EM_AVR
      || elf_elfheader (abfd)->e_machine == EM_AVR_OLD)
a949 1
#define ELF_MACHINE_ALT1	EM_AVR_OLD
a961 1
#define elf_backend_rela_normal		     1
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d458 1
a458 1
  if (info->relocatable)
d722 1
a722 1
  if (info->relocatable)
d753 1
a753 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d761 1
a761 1
	  bfd_boolean unresolved_reloc, warned;
d763 26
a788 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d30 1
a30 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d32 1
a32 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d34 1
a34 1
static bfd_boolean elf32_avr_gc_sweep_hook
d37 1
a37 1
static bfd_boolean elf32_avr_check_relocs
d43 1
a43 1
static bfd_boolean elf32_avr_relocate_section
d46 5
a50 2
static void bfd_elf_avr_final_write_processing PARAMS ((bfd *, bfd_boolean));
static bfd_boolean elf32_avr_object_p PARAMS ((bfd *));
d58 1
a58 1
	 FALSE,			/* pc_relative */
d63 1
a63 1
	 FALSE,			/* partial_inplace */
d66 1
a66 1
	 FALSE),		/* pcrel_offset */
d72 1
a72 1
	 FALSE,			/* pc_relative */
d77 1
a77 1
	 FALSE,			/* partial_inplace */
d80 1
a80 1
	 FALSE),		/* pcrel_offset */
d87 1
a87 1
	 TRUE,			/* pc_relative */
d92 1
a92 1
	 FALSE,			/* partial_inplace */
d95 1
a95 1
	 TRUE),			/* pcrel_offset */
d102 1
a102 1
	 TRUE,			/* pc_relative */
d107 1
a107 1
	 FALSE,			/* partial_inplace */
d110 1
a110 1
	 TRUE),			/* pcrel_offset */
d117 1
a117 1
	 FALSE,			/* pc_relative */
d122 1
a122 1
	 FALSE,			/* partial_inplace */
d125 1
a125 1
	 FALSE),		/* pcrel_offset */
d132 1
a132 1
	 FALSE,			/* pc_relative */
d137 1
a137 1
	 FALSE,			/* partial_inplace */
d140 1
a140 1
	 FALSE),		/* pcrel_offset */
d147 1
a147 1
	 FALSE,			/* pc_relative */
d152 1
a152 1
	 FALSE,			/* partial_inplace */
d155 1
a155 1
	 FALSE),		/* pcrel_offset */
d162 1
a162 1
	 FALSE,			/* pc_relative */
d167 1
a167 1
	 FALSE,			/* partial_inplace */
d170 1
a170 1
	 FALSE),		/* pcrel_offset */
d177 1
a177 1
	 FALSE,			/* pc_relative */
d182 1
a182 1
	 FALSE,			/* partial_inplace */
d185 1
a185 1
	 FALSE),		/* pcrel_offset */
d192 1
a192 1
	 FALSE,			/* pc_relative */
d197 1
a197 1
	 FALSE,			/* partial_inplace */
d200 1
a200 1
	 FALSE),		/* pcrel_offset */
d207 1
a207 1
	 FALSE,			/* pc_relative */
d212 1
a212 1
	 FALSE,			/* partial_inplace */
d215 1
a215 1
	 FALSE),		/* pcrel_offset */
d222 1
a222 1
	 FALSE,			/* pc_relative */
d227 1
a227 1
	 FALSE,			/* partial_inplace */
d230 1
a230 1
	 FALSE),		/* pcrel_offset */
d237 1
a237 1
	 FALSE,			/* pc_relative */
d242 1
a242 1
	 FALSE,			/* partial_inplace */
d245 1
a245 1
	 FALSE),		/* pcrel_offset */
d252 1
a252 1
	 FALSE,			/* pc_relative */
d257 1
a257 1
	 FALSE,			/* partial_inplace */
d260 1
a260 1
	 FALSE),		/* pcrel_offset */
d267 1
a267 1
	 FALSE,			/* pc_relative */
d272 1
a272 1
	 FALSE,			/* partial_inplace */
d275 1
a275 1
	 FALSE),		/* pcrel_offset */
d282 1
a282 1
	 FALSE,			/* pc_relative */
d287 1
a287 1
	 FALSE,			/* partial_inplace */
d290 1
a290 1
	 FALSE),		/* pcrel_offset */
d297 1
a297 1
	 FALSE,			/* pc_relative */
d302 1
a302 1
	 FALSE,			/* partial_inplace */
d305 1
a305 1
	 FALSE),		/* pcrel_offset */
d312 1
a312 1
	 FALSE,			/* pc_relative */
d317 1
a317 1
	 FALSE,			/* partial_inplace */
d320 1
a320 1
	 FALSE),		/* pcrel_offset */
d326 1
a326 1
	 FALSE,			/* pc_relative */
d331 1
a331 1
	 FALSE,			/* partial_inplace */
d334 1
a334 1
	 FALSE)			/* pcrel_offset */
d392 1
a392 1
     Elf_Internal_Rela *dst;
d402 2
a403 2
elf32_avr_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d429 9
a437 2
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

d441 1
a441 1
static bfd_boolean
d449 1
a449 1
  return TRUE;
d456 1
a456 1
static bfd_boolean
d469 1
a469 1
    return TRUE;
d490 1
a490 1
  return TRUE;
d702 1
a702 1
      bfd_put_16 (input_bfd, (bfd_vma) srel & 0xffff, contents+2);
d715 1
a715 1
static bfd_boolean
a731 3
  if (info->relocateable)
    return TRUE;

a747 1
      /* This is a final link.  */
d750 22
d781 3
a783 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d815 2
a816 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d838 1
a838 1
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
d863 1
a863 1
	    return FALSE;
d867 1
a867 1
  return TRUE;
d877 1
a877 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d912 1
a912 1
static bfd_boolean
d916 2
a917 3
  unsigned int e_set = bfd_mach_avr2;
  if (elf_elfheader (abfd)->e_machine == EM_AVR
      || elf_elfheader (abfd)->e_machine == EM_AVR_OLD)
a949 1
#define ELF_MACHINE_ALT1	EM_AVR_OLD
a961 1
#define elf_backend_rela_normal		     1
@

