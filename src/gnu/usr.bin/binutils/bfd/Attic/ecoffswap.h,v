head	1.3;
access;
symbols
	binutils-2_15:1.1.2.2
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.20.49.26;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.00.14;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.38.58;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.38.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.26.17;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.40.34;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.04.07;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* Generic ECOFF swapping routines, for BFD.
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* NOTE: This is a header file, but it contains executable routines.
   This is done this way because these routines are substantially
   similar, but are not identical, for all ECOFF targets.

   These are routines to swap the ECOFF symbolic information in and
   out.  The routines are defined statically.  You can set breakpoints
   on them in gdb by naming the including source file; e.g.,
   'coff-mips.c':ecoff_swap_hdr_in.

   Before including this header file, one of ECOFF_32, ECOFF_64,
   ECOFF_SIGNED_32 or ECOFF_SIGNED_64 must be defined.  These are
   checked when swapping information that depends upon the target
   size.  This code works for 32 bit and 64 bit ECOFF, but may need to
   be generalized in the future.

   Some header file which defines the external forms of these
   structures must also be included before including this header file.
   Currently this is either coff/mips.h or coff/alpha.h.

   If the symbol TEST is defined when this file is compiled, a
   comparison is made to ensure that, in fact, the output is
   bit-for-bit the same as the input.  Of course, this symbol should
   only be defined when deliberately testing the code on a machine
   with the proper byte sex and such.  */

#ifdef ECOFF_32
#define ECOFF_GET_OFF H_GET_32
#define ECOFF_PUT_OFF H_PUT_32
#endif
#ifdef ECOFF_64
#define ECOFF_GET_OFF H_GET_64
#define ECOFF_PUT_OFF H_PUT_64
#endif
#ifdef ECOFF_SIGNED_32
#define ECOFF_GET_OFF H_GET_S32
#define ECOFF_PUT_OFF H_PUT_S32
#endif
#ifdef ECOFF_SIGNED_64
#define ECOFF_GET_OFF H_GET_S64
#define ECOFF_PUT_OFF H_PUT_S64
#endif

/* ECOFF auxiliary information swapping routines.  These are the same
   for all ECOFF targets, so they are defined in ecofflink.c.  */

extern void _bfd_ecoff_swap_tir_in
  PARAMS ((int, const struct tir_ext *, TIR *));
extern void _bfd_ecoff_swap_tir_out
  PARAMS ((int, const TIR *, struct tir_ext *));
extern void _bfd_ecoff_swap_rndx_in
  PARAMS ((int, const struct rndx_ext *, RNDXR *));
extern void _bfd_ecoff_swap_rndx_out
  PARAMS ((int, const RNDXR *, struct rndx_ext *));

/* Prototypes for functions defined in this file.  */

static void ecoff_swap_hdr_in PARAMS ((bfd *, PTR, HDRR *));
static void ecoff_swap_hdr_out PARAMS ((bfd *, const HDRR *, PTR));
static void ecoff_swap_fdr_in PARAMS ((bfd *, PTR, FDR *));
static void ecoff_swap_fdr_out PARAMS ((bfd *, const FDR *, PTR));
static void ecoff_swap_pdr_in PARAMS ((bfd *, PTR, PDR *));
static void ecoff_swap_pdr_out PARAMS ((bfd *, const PDR *, PTR));
static void ecoff_swap_sym_in PARAMS ((bfd *, PTR, SYMR *));
static void ecoff_swap_sym_out PARAMS ((bfd *, const SYMR *, PTR));
static void ecoff_swap_ext_in PARAMS ((bfd *, PTR, EXTR *));
static void ecoff_swap_ext_out PARAMS ((bfd *, const EXTR *, PTR));
static void ecoff_swap_rfd_in PARAMS ((bfd *, PTR, RFDT *));
static void ecoff_swap_rfd_out PARAMS ((bfd *, const RFDT *, PTR));
static void ecoff_swap_opt_in PARAMS ((bfd *, PTR, OPTR *));
static void ecoff_swap_opt_out PARAMS ((bfd *, const OPTR *, PTR));
static void ecoff_swap_dnr_in PARAMS ((bfd *, PTR, DNR *));
static void ecoff_swap_dnr_out PARAMS ((bfd *, const DNR *, PTR));

/* Swap in the symbolic header.  */

static void
ecoff_swap_hdr_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     HDRR *intern;
{
  struct hdr_ext ext[1];

  *ext = *(struct hdr_ext *) ext_copy;

  intern->magic         = H_GET_S16     (abfd, ext->h_magic);
  intern->vstamp        = H_GET_S16     (abfd, ext->h_vstamp);
  intern->ilineMax      = H_GET_32      (abfd, ext->h_ilineMax);
  intern->cbLine        = ECOFF_GET_OFF (abfd, ext->h_cbLine);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->h_cbLineOffset);
  intern->idnMax        = H_GET_32      (abfd, ext->h_idnMax);
  intern->cbDnOffset    = ECOFF_GET_OFF (abfd, ext->h_cbDnOffset);
  intern->ipdMax        = H_GET_32      (abfd, ext->h_ipdMax);
  intern->cbPdOffset    = ECOFF_GET_OFF (abfd, ext->h_cbPdOffset);
  intern->isymMax       = H_GET_32      (abfd, ext->h_isymMax);
  intern->cbSymOffset   = ECOFF_GET_OFF (abfd, ext->h_cbSymOffset);
  intern->ioptMax       = H_GET_32      (abfd, ext->h_ioptMax);
  intern->cbOptOffset   = ECOFF_GET_OFF (abfd, ext->h_cbOptOffset);
  intern->iauxMax       = H_GET_32      (abfd, ext->h_iauxMax);
  intern->cbAuxOffset   = ECOFF_GET_OFF (abfd, ext->h_cbAuxOffset);
  intern->issMax        = H_GET_32      (abfd, ext->h_issMax);
  intern->cbSsOffset    = ECOFF_GET_OFF (abfd, ext->h_cbSsOffset);
  intern->issExtMax     = H_GET_32      (abfd, ext->h_issExtMax);
  intern->cbSsExtOffset = ECOFF_GET_OFF (abfd, ext->h_cbSsExtOffset);
  intern->ifdMax        = H_GET_32      (abfd, ext->h_ifdMax);
  intern->cbFdOffset    = ECOFF_GET_OFF (abfd, ext->h_cbFdOffset);
  intern->crfd          = H_GET_32      (abfd, ext->h_crfd);
  intern->cbRfdOffset   = ECOFF_GET_OFF (abfd, ext->h_cbRfdOffset);
  intern->iextMax       = H_GET_32      (abfd, ext->h_iextMax);
  intern->cbExtOffset   = ECOFF_GET_OFF (abfd, ext->h_cbExtOffset);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out the symbolic header.  */

static void
ecoff_swap_hdr_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const HDRR *intern_copy;
     PTR ext_ptr;
{
  struct hdr_ext *ext = (struct hdr_ext *) ext_ptr;
  HDRR intern[1];

  *intern = *intern_copy;

  H_PUT_S16     (abfd, intern->magic,         ext->h_magic);
  H_PUT_S16     (abfd, intern->vstamp,        ext->h_vstamp);
  H_PUT_32      (abfd, intern->ilineMax,      ext->h_ilineMax);
  ECOFF_PUT_OFF (abfd, intern->cbLine,        ext->h_cbLine);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset,  ext->h_cbLineOffset);
  H_PUT_32      (abfd, intern->idnMax,        ext->h_idnMax);
  ECOFF_PUT_OFF (abfd, intern->cbDnOffset,    ext->h_cbDnOffset);
  H_PUT_32      (abfd, intern->ipdMax,        ext->h_ipdMax);
  ECOFF_PUT_OFF (abfd, intern->cbPdOffset,    ext->h_cbPdOffset);
  H_PUT_32      (abfd, intern->isymMax,       ext->h_isymMax);
  ECOFF_PUT_OFF (abfd, intern->cbSymOffset,   ext->h_cbSymOffset);
  H_PUT_32      (abfd, intern->ioptMax,       ext->h_ioptMax);
  ECOFF_PUT_OFF (abfd, intern->cbOptOffset,   ext->h_cbOptOffset);
  H_PUT_32      (abfd, intern->iauxMax,       ext->h_iauxMax);
  ECOFF_PUT_OFF (abfd, intern->cbAuxOffset,   ext->h_cbAuxOffset);
  H_PUT_32      (abfd, intern->issMax,        ext->h_issMax);
  ECOFF_PUT_OFF (abfd, intern->cbSsOffset,    ext->h_cbSsOffset);
  H_PUT_32      (abfd, intern->issExtMax,     ext->h_issExtMax);
  ECOFF_PUT_OFF (abfd, intern->cbSsExtOffset, ext->h_cbSsExtOffset);
  H_PUT_32      (abfd, intern->ifdMax,        ext->h_ifdMax);
  ECOFF_PUT_OFF (abfd, intern->cbFdOffset,    ext->h_cbFdOffset);
  H_PUT_32      (abfd, intern->crfd,          ext->h_crfd);
  ECOFF_PUT_OFF (abfd, intern->cbRfdOffset,   ext->h_cbRfdOffset);
  H_PUT_32      (abfd, intern->iextMax,       ext->h_iextMax);
  ECOFF_PUT_OFF (abfd, intern->cbExtOffset,   ext->h_cbExtOffset);

#ifdef TEST
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in the file descriptor record.  */

static void
ecoff_swap_fdr_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     FDR *intern;
{
  struct fdr_ext ext[1];

  *ext = *(struct fdr_ext *) ext_copy;

  intern->adr           = ECOFF_GET_OFF (abfd, ext->f_adr);
  intern->rss           = H_GET_32 (abfd, ext->f_rss);
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  if (intern->rss == (signed long) 0xffffffff)
    intern->rss = -1;
#endif
  intern->issBase       = H_GET_32 (abfd, ext->f_issBase);
  intern->cbSs          = ECOFF_GET_OFF (abfd, ext->f_cbSs);
  intern->isymBase      = H_GET_32 (abfd, ext->f_isymBase);
  intern->csym          = H_GET_32 (abfd, ext->f_csym);
  intern->ilineBase     = H_GET_32 (abfd, ext->f_ilineBase);
  intern->cline         = H_GET_32 (abfd, ext->f_cline);
  intern->ioptBase      = H_GET_32 (abfd, ext->f_ioptBase);
  intern->copt          = H_GET_32 (abfd, ext->f_copt);
#if defined (ECOFF_32) || defined (ECOFF_SIGNED_32)
  intern->ipdFirst      = H_GET_16 (abfd, ext->f_ipdFirst);
  intern->cpd           = H_GET_16 (abfd, ext->f_cpd);
#endif
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  intern->ipdFirst      = H_GET_32 (abfd, ext->f_ipdFirst);
  intern->cpd           = H_GET_32 (abfd, ext->f_cpd);
#endif
  intern->iauxBase      = H_GET_32 (abfd, ext->f_iauxBase);
  intern->caux          = H_GET_32 (abfd, ext->f_caux);
  intern->rfdBase       = H_GET_32 (abfd, ext->f_rfdBase);
  intern->crfd          = H_GET_32 (abfd, ext->f_crfd);

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->lang       = ((ext->f_bits1[0] & FDR_BITS1_LANG_BIG)
			    >> FDR_BITS1_LANG_SH_BIG);
      intern->fMerge     = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_BIG);
      intern->fReadin    = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_BIG);
      intern->fBigendian = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_BIG);
      intern->glevel     = ((ext->f_bits2[0] & FDR_BITS2_GLEVEL_BIG)
			    >> FDR_BITS2_GLEVEL_SH_BIG);
    }
  else
    {
      intern->lang       = ((ext->f_bits1[0] & FDR_BITS1_LANG_LITTLE)
			    >> FDR_BITS1_LANG_SH_LITTLE);
      intern->fMerge     = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_LITTLE);
      intern->fReadin    = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_LITTLE);
      intern->fBigendian = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_LITTLE);
      intern->glevel     = ((ext->f_bits2[0] & FDR_BITS2_GLEVEL_LITTLE)
			    >> FDR_BITS2_GLEVEL_SH_LITTLE);
    }
  intern->reserved = 0;

  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->f_cbLineOffset);
  intern->cbLine        = ECOFF_GET_OFF (abfd, ext->f_cbLine);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out the file descriptor record.  */

static void
ecoff_swap_fdr_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const FDR *intern_copy;
     PTR ext_ptr;
{
  struct fdr_ext *ext = (struct fdr_ext *) ext_ptr;
  FDR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  ECOFF_PUT_OFF (abfd, intern->adr,       ext->f_adr);
  H_PUT_32      (abfd, intern->rss,       ext->f_rss);
  H_PUT_32      (abfd, intern->issBase,   ext->f_issBase);
  ECOFF_PUT_OFF (abfd, intern->cbSs,      ext->f_cbSs);
  H_PUT_32      (abfd, intern->isymBase,  ext->f_isymBase);
  H_PUT_32      (abfd, intern->csym,      ext->f_csym);
  H_PUT_32      (abfd, intern->ilineBase, ext->f_ilineBase);
  H_PUT_32      (abfd, intern->cline,     ext->f_cline);
  H_PUT_32      (abfd, intern->ioptBase,  ext->f_ioptBase);
  H_PUT_32      (abfd, intern->copt,      ext->f_copt);
#if defined (ECOFF_32) || defined (ECOFF_SIGNED_32)
  H_PUT_16      (abfd, intern->ipdFirst,  ext->f_ipdFirst);
  H_PUT_16      (abfd, intern->cpd,       ext->f_cpd);
#endif
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  H_PUT_32      (abfd, intern->ipdFirst,  ext->f_ipdFirst);
  H_PUT_32      (abfd, intern->cpd,       ext->f_cpd);
#endif
  H_PUT_32      (abfd, intern->iauxBase,  ext->f_iauxBase);
  H_PUT_32      (abfd, intern->caux,      ext->f_caux);
  H_PUT_32      (abfd, intern->rfdBase,   ext->f_rfdBase);
  H_PUT_32      (abfd, intern->crfd,      ext->f_crfd);

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_BIG)
			  & FDR_BITS1_LANG_BIG)
			 | (intern->fMerge ? FDR_BITS1_FMERGE_BIG : 0)
			 | (intern->fReadin ? FDR_BITS1_FREADIN_BIG : 0)
			 | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_BIG : 0));
      ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_BIG)
			 & FDR_BITS2_GLEVEL_BIG);
      ext->f_bits2[1] = 0;
      ext->f_bits2[2] = 0;
    }
  else
    {
      ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_LITTLE)
			  & FDR_BITS1_LANG_LITTLE)
			 | (intern->fMerge ? FDR_BITS1_FMERGE_LITTLE : 0)
			 | (intern->fReadin ? FDR_BITS1_FREADIN_LITTLE : 0)
			 | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_LITTLE : 0));
      ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_LITTLE)
			 & FDR_BITS2_GLEVEL_LITTLE);
      ext->f_bits2[1] = 0;
      ext->f_bits2[2] = 0;
    }

  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->f_cbLineOffset);
  ECOFF_PUT_OFF (abfd, intern->cbLine, ext->f_cbLine);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

#ifndef MPW_C

/* Swap in the procedure descriptor record.  */

static void
ecoff_swap_pdr_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     PDR *intern;
{
  struct pdr_ext ext[1];

  *ext = *(struct pdr_ext *) ext_copy;

  memset ((PTR) intern, 0, sizeof (*intern));

  intern->adr           = ECOFF_GET_OFF (abfd, ext->p_adr);
  intern->isym          = H_GET_32 (abfd, ext->p_isym);
  intern->iline         = H_GET_32 (abfd, ext->p_iline);
  intern->regmask       = H_GET_32 (abfd, ext->p_regmask);
  intern->regoffset     = H_GET_S32 (abfd, ext->p_regoffset);
  intern->iopt          = H_GET_S32 (abfd, ext->p_iopt);
  intern->fregmask      = H_GET_32 (abfd, ext->p_fregmask);
  intern->fregoffset    = H_GET_S32 (abfd, ext->p_fregoffset);
  intern->frameoffset   = H_GET_S32 (abfd, ext->p_frameoffset);
  intern->framereg      = H_GET_16 (abfd, ext->p_framereg);
  intern->pcreg         = H_GET_16 (abfd, ext->p_pcreg);
  intern->lnLow         = H_GET_32 (abfd, ext->p_lnLow);
  intern->lnHigh        = H_GET_32 (abfd, ext->p_lnHigh);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->p_cbLineOffset);

#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  if (intern->isym == (signed long) 0xffffffff)
    intern->isym = -1;
  if (intern->iline == (signed long) 0xffffffff)
    intern->iline = -1;

  intern->gp_prologue = H_GET_8 (abfd, ext->p_gp_prologue);
  if (bfd_header_big_endian (abfd))
    {
      intern->gp_used = 0 != (ext->p_bits1[0] & PDR_BITS1_GP_USED_BIG);
      intern->reg_frame = 0 != (ext->p_bits1[0] & PDR_BITS1_REG_FRAME_BIG);
      intern->prof = 0 != (ext->p_bits1[0] & PDR_BITS1_PROF_BIG);
      intern->reserved = (((ext->p_bits1[0] & PDR_BITS1_RESERVED_BIG)
			   << PDR_BITS1_RESERVED_SH_LEFT_BIG)
			  | ((ext->p_bits2[0] & PDR_BITS2_RESERVED_BIG)
			     >> PDR_BITS2_RESERVED_SH_BIG));
    }
  else
    {
      intern->gp_used = 0 != (ext->p_bits1[0] & PDR_BITS1_GP_USED_LITTLE);
      intern->reg_frame = 0 != (ext->p_bits1[0] & PDR_BITS1_REG_FRAME_LITTLE);
      intern->prof = 0 != (ext->p_bits1[0] & PDR_BITS1_PROF_LITTLE);
      intern->reserved = (((ext->p_bits1[0] & PDR_BITS1_RESERVED_LITTLE)
			   >> PDR_BITS1_RESERVED_SH_LITTLE)
			  | ((ext->p_bits2[0] & PDR_BITS2_RESERVED_LITTLE)
			     << PDR_BITS2_RESERVED_SH_LEFT_LITTLE));
    }
  intern->localoff = H_GET_8 (abfd, ext->p_localoff);
#endif

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out the procedure descriptor record.  */

static void
ecoff_swap_pdr_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const PDR *intern_copy;
     PTR ext_ptr;
{
  struct pdr_ext *ext = (struct pdr_ext *) ext_ptr;
  PDR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  ECOFF_PUT_OFF (abfd, intern->adr,          ext->p_adr);
  H_PUT_32      (abfd, intern->isym,         ext->p_isym);
  H_PUT_32      (abfd, intern->iline,        ext->p_iline);
  H_PUT_32      (abfd, intern->regmask,      ext->p_regmask);
  H_PUT_32      (abfd, intern->regoffset,    ext->p_regoffset);
  H_PUT_32      (abfd, intern->iopt,         ext->p_iopt);
  H_PUT_32      (abfd, intern->fregmask,     ext->p_fregmask);
  H_PUT_32      (abfd, intern->fregoffset,   ext->p_fregoffset);
  H_PUT_32      (abfd, intern->frameoffset,  ext->p_frameoffset);
  H_PUT_16      (abfd, intern->framereg,     ext->p_framereg);
  H_PUT_16      (abfd, intern->pcreg,        ext->p_pcreg);
  H_PUT_32      (abfd, intern->lnLow,        ext->p_lnLow);
  H_PUT_32      (abfd, intern->lnHigh,       ext->p_lnHigh);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->p_cbLineOffset);

#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  H_PUT_8       (abfd, intern->gp_prologue,  ext->p_gp_prologue);

  if (bfd_header_big_endian (abfd))
    {
      ext->p_bits1[0] = ((intern->gp_used ? PDR_BITS1_GP_USED_BIG : 0)
			 | (intern->reg_frame ? PDR_BITS1_REG_FRAME_BIG : 0)
			 | (intern->prof ? PDR_BITS1_PROF_BIG : 0)
			 | ((intern->reserved
			     >> PDR_BITS1_RESERVED_SH_LEFT_BIG)
			    & PDR_BITS1_RESERVED_BIG));
      ext->p_bits2[0] = ((intern->reserved << PDR_BITS2_RESERVED_SH_BIG)
			 & PDR_BITS2_RESERVED_BIG);
    }
  else
    {
      ext->p_bits1[0] = ((intern->gp_used ? PDR_BITS1_GP_USED_LITTLE : 0)
			 | (intern->reg_frame ? PDR_BITS1_REG_FRAME_LITTLE : 0)
			 | (intern->prof ? PDR_BITS1_PROF_LITTLE : 0)
			 | ((intern->reserved << PDR_BITS1_RESERVED_SH_LITTLE)
			    & PDR_BITS1_RESERVED_LITTLE));
      ext->p_bits2[0] = ((intern->reserved >>
			  PDR_BITS2_RESERVED_SH_LEFT_LITTLE)
			 & PDR_BITS2_RESERVED_LITTLE);
    }
  H_PUT_8 (abfd, intern->localoff, ext->p_localoff);
#endif

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

#else /* MPW_C */
/* Same routines, but with ECOFF_64 code removed, so ^&%$#&! MPW C doesn't
   corrupt itself and then freak out.  */
/* Swap in the procedure descriptor record.  */

static void
ecoff_swap_pdr_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     PDR *intern;
{
  struct pdr_ext ext[1];

  *ext = *(struct pdr_ext *) ext_copy;

  intern->adr           = ECOFF_GET_OFF (abfd, ext->p_adr);
  intern->isym          = H_GET_32 (abfd, ext->p_isym);
  intern->iline         = H_GET_32 (abfd, ext->p_iline);
  intern->regmask       = H_GET_32 (abfd, ext->p_regmask);
  intern->regoffset     = H_GET_S32 (abfd, ext->p_regoffset);
  intern->iopt          = H_GET_S32 (abfd, ext->p_iopt);
  intern->fregmask      = H_GET_32 (abfd, ext->p_fregmask);
  intern->fregoffset    = H_GET_S32 (abfd, ext->p_fregoffset);
  intern->frameoffset   = H_GET_S32 (abfd, ext->p_frameoffset);
  intern->framereg      = H_GET_16 (abfd, ext->p_framereg);
  intern->pcreg         = H_GET_16 (abfd, ext->p_pcreg);
  intern->lnLow         = H_GET_32 (abfd, ext->p_lnLow);
  intern->lnHigh        = H_GET_32 (abfd, ext->p_lnHigh);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->p_cbLineOffset);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out the procedure descriptor record.  */

static void
ecoff_swap_pdr_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const PDR *intern_copy;
     PTR ext_ptr;
{
  struct pdr_ext *ext = (struct pdr_ext *) ext_ptr;
  PDR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  ECOFF_PUT_OFF (abfd, intern->adr,          ext->p_adr);
  H_PUT_32      (abfd, intern->isym,         ext->p_isym);
  H_PUT_32      (abfd, intern->iline,        ext->p_iline);
  H_PUT_32      (abfd, intern->regmask,      ext->p_regmask);
  H_PUT_32      (abfd, intern->regoffset,    ext->p_regoffset);
  H_PUT_32      (abfd, intern->iopt,         ext->p_iopt);
  H_PUT_32      (abfd, intern->fregmask,     ext->p_fregmask);
  H_PUT_32      (abfd, intern->fregoffset,   ext->p_fregoffset);
  H_PUT_32      (abfd, intern->frameoffset,  ext->p_frameoffset);
  H_PUT_16      (abfd, intern->framereg,     ext->p_framereg);
  H_PUT_16      (abfd, intern->pcreg,        ext->p_pcreg);
  H_PUT_32      (abfd, intern->lnLow,        ext->p_lnLow);
  H_PUT_32      (abfd, intern->lnHigh,       ext->p_lnHigh);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->p_cbLineOffset);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}
#endif /* MPW_C */

/* Swap in a symbol record.  */

static void
ecoff_swap_sym_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     SYMR *intern;
{
  struct sym_ext ext[1];

  *ext = *(struct sym_ext *) ext_copy;

  intern->iss           = H_GET_32 (abfd, ext->s_iss);
  intern->value         = ECOFF_GET_OFF (abfd, ext->s_value);

#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  if (intern->iss == (signed long) 0xffffffff)
    intern->iss = -1;
#endif  

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_BIG)
					     >> SYM_BITS1_ST_SH_BIG;
      intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_BIG)
					     << SYM_BITS1_SC_SH_LEFT_BIG)
			  | ((ext->s_bits2[0] & SYM_BITS2_SC_BIG)
					     >> SYM_BITS2_SC_SH_BIG);
      intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_BIG);
      intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_BIG)
					     << SYM_BITS2_INDEX_SH_LEFT_BIG)
			  | (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_BIG)
			  | (ext->s_bits4[0] << SYM_BITS4_INDEX_SH_LEFT_BIG);
    }
  else
    {
      intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_LITTLE)
					     >> SYM_BITS1_ST_SH_LITTLE;
      intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_LITTLE)
					     >> SYM_BITS1_SC_SH_LITTLE)
			  | ((ext->s_bits2[0] & SYM_BITS2_SC_LITTLE)
					     << SYM_BITS2_SC_SH_LEFT_LITTLE);
      intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_LITTLE);
      intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_LITTLE)
					     >> SYM_BITS2_INDEX_SH_LITTLE)
			  | (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_LITTLE)
			  | ((unsigned int) ext->s_bits4[0]
			     << SYM_BITS4_INDEX_SH_LEFT_LITTLE);
    }

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out a symbol record.  */

static void
ecoff_swap_sym_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const SYMR *intern_copy;
     PTR ext_ptr;
{
  struct sym_ext *ext = (struct sym_ext *) ext_ptr;
  SYMR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  H_PUT_32 (abfd, intern->iss, ext->s_iss);
  ECOFF_PUT_OFF (abfd, intern->value, ext->s_value);

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_BIG)
			  & SYM_BITS1_ST_BIG)
			 | ((intern->sc >> SYM_BITS1_SC_SH_LEFT_BIG)
			    & SYM_BITS1_SC_BIG));
      ext->s_bits2[0] = (((intern->sc << SYM_BITS2_SC_SH_BIG)
			  & SYM_BITS2_SC_BIG)
			 | (intern->reserved ? SYM_BITS2_RESERVED_BIG : 0)
			 | ((intern->index >> SYM_BITS2_INDEX_SH_LEFT_BIG)
			    & SYM_BITS2_INDEX_BIG));
      ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_BIG) & 0xff;
      ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_BIG) & 0xff;
    }
  else
    {
      ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_LITTLE)
			  & SYM_BITS1_ST_LITTLE)
			 | ((intern->sc << SYM_BITS1_SC_SH_LITTLE)
			    & SYM_BITS1_SC_LITTLE));
      ext->s_bits2[0] = (((intern->sc >> SYM_BITS2_SC_SH_LEFT_LITTLE)
			  & SYM_BITS2_SC_LITTLE)
			 | (intern->reserved ? SYM_BITS2_RESERVED_LITTLE : 0)
			 | ((intern->index << SYM_BITS2_INDEX_SH_LITTLE)
			    & SYM_BITS2_INDEX_LITTLE));
      ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_LITTLE) & 0xff;
      ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_LITTLE) & 0xff;
    }

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in an external symbol record.  */

static void
ecoff_swap_ext_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     EXTR *intern;
{
  struct ext_ext ext[1];

  *ext = *(struct ext_ext *) ext_copy;

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_BIG);
      intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_BIG);
      intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_BIG);
    }
  else
    {
      intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_LITTLE);
      intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_LITTLE);
      intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_LITTLE);
    }
  intern->reserved = 0;

#if defined (ECOFF_32) || defined (ECOFF_SIGNED_32)
  intern->ifd = H_GET_S16 (abfd, ext->es_ifd);
#endif
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  intern->ifd = H_GET_S32 (abfd, ext->es_ifd);
#endif

  ecoff_swap_sym_in (abfd, &ext->es_asym, &intern->asym);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out an external symbol record.  */

static void
ecoff_swap_ext_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const EXTR *intern_copy;
     PTR ext_ptr;
{
  struct ext_ext *ext = (struct ext_ext *) ext_ptr;
  EXTR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_BIG : 0)
			  | (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_BIG : 0)
			  | (intern->weakext ? EXT_BITS1_WEAKEXT_BIG : 0));
      ext->es_bits2[0] = 0;
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
      ext->es_bits2[1] = 0;
      ext->es_bits2[2] = 0;
#endif
    }
  else
    {
      ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_LITTLE : 0)
			  | (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_LITTLE : 0)
			  | (intern->weakext ? EXT_BITS1_WEAKEXT_LITTLE : 0));
      ext->es_bits2[0] = 0;
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
      ext->es_bits2[1] = 0;
      ext->es_bits2[2] = 0;
#endif
    }

#if defined (ECOFF_32) || defined (ECOFF_SIGNED_32)
  H_PUT_S16 (abfd, intern->ifd, ext->es_ifd);
#endif
#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  H_PUT_S32 (abfd, intern->ifd, ext->es_ifd);
#endif

  ecoff_swap_sym_out (abfd, &intern->asym, &ext->es_asym);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in a relative file descriptor.  */

static void
ecoff_swap_rfd_in (abfd, ext_ptr, intern)
     bfd *abfd;
     PTR ext_ptr;
     RFDT *intern;
{
  struct rfd_ext *ext = (struct rfd_ext *) ext_ptr;

  *intern = H_GET_32 (abfd, ext->rfd);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out a relative file descriptor.  */

static void
ecoff_swap_rfd_out (abfd, intern, ext_ptr)
     bfd *abfd;
     const RFDT *intern;
     PTR ext_ptr;
{
  struct rfd_ext *ext = (struct rfd_ext *) ext_ptr;

  H_PUT_32 (abfd, *intern, ext->rfd);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in an optimization symbol.  */

static void
ecoff_swap_opt_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     OPTR *intern;
{
  struct opt_ext ext[1];

  *ext = *(struct opt_ext *) ext_copy;

  if (bfd_header_big_endian (abfd))
    {
      intern->ot = ext->o_bits1[0];
      intern->value = (((unsigned int) ext->o_bits2[0]
			<< OPT_BITS2_VALUE_SH_LEFT_BIG)
		       | ((unsigned int) ext->o_bits3[0]
			  << OPT_BITS2_VALUE_SH_LEFT_BIG)
		       | ((unsigned int) ext->o_bits4[0]
			  << OPT_BITS2_VALUE_SH_LEFT_BIG));
    }
  else
    {
      intern->ot = ext->o_bits1[0];
      intern->value = ((ext->o_bits2[0] << OPT_BITS2_VALUE_SH_LEFT_LITTLE)
		       | (ext->o_bits3[0] << OPT_BITS2_VALUE_SH_LEFT_LITTLE)
		       | (ext->o_bits4[0] << OPT_BITS2_VALUE_SH_LEFT_LITTLE));
    }

  _bfd_ecoff_swap_rndx_in (bfd_header_big_endian (abfd),
			   &ext->o_rndx, &intern->rndx);

  intern->offset = H_GET_32 (abfd, ext->o_offset);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out an optimization symbol.  */

static void
ecoff_swap_opt_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const OPTR *intern_copy;
     PTR ext_ptr;
{
  struct opt_ext *ext = (struct opt_ext *) ext_ptr;
  OPTR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  if (bfd_header_big_endian (abfd))
    {
      ext->o_bits1[0] = intern->ot;
      ext->o_bits2[0] = intern->value >> OPT_BITS2_VALUE_SH_LEFT_BIG;
      ext->o_bits3[0] = intern->value >> OPT_BITS3_VALUE_SH_LEFT_BIG;
      ext->o_bits4[0] = intern->value >> OPT_BITS4_VALUE_SH_LEFT_BIG;
    }
  else
    {
      ext->o_bits1[0] = intern->ot;
      ext->o_bits2[0] = intern->value >> OPT_BITS2_VALUE_SH_LEFT_LITTLE;
      ext->o_bits3[0] = intern->value >> OPT_BITS3_VALUE_SH_LEFT_LITTLE;
      ext->o_bits4[0] = intern->value >> OPT_BITS4_VALUE_SH_LEFT_LITTLE;
    }

  _bfd_ecoff_swap_rndx_out (bfd_header_big_endian (abfd),
			    &intern->rndx, &ext->o_rndx);

  H_PUT_32 (abfd, intern->value, ext->o_offset);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in a dense number.  */

static void
ecoff_swap_dnr_in (abfd, ext_copy, intern)
     bfd *abfd;
     PTR ext_copy;
     DNR *intern;
{
  struct dnr_ext ext[1];

  *ext = *(struct dnr_ext *) ext_copy;

  intern->rfd = H_GET_32 (abfd, ext->d_rfd);
  intern->index = H_GET_32 (abfd, ext->d_index);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out a dense number.  */

static void
ecoff_swap_dnr_out (abfd, intern_copy, ext_ptr)
     bfd *abfd;
     const DNR *intern_copy;
     PTR ext_ptr;
{
  struct dnr_ext *ext = (struct dnr_ext *) ext_ptr;
  DNR intern[1];

  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;

  H_PUT_32 (abfd, intern->rfd, ext->d_rfd);
  H_PUT_32 (abfd, intern->index, ext->d_index);

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d48 2
a49 2
#define ecoff_get_off bfd_h_get_32
#define ecoff_put_off bfd_h_put_32
d52 2
a53 2
#define ecoff_get_off bfd_h_get_64
#define ecoff_put_off bfd_h_put_64
d56 2
a57 2
#define ecoff_get_off bfd_h_get_signed_32
#define ecoff_put_off bfd_h_put_signed_32
d60 2
a61 2
#define ecoff_get_off bfd_h_get_signed_64
#define ecoff_put_off bfd_h_put_signed_64
d107 25
a131 25
  intern->magic         = bfd_h_get_signed_16 (abfd, (bfd_byte *)ext->h_magic);
  intern->vstamp        = bfd_h_get_signed_16 (abfd, (bfd_byte *)ext->h_vstamp);
  intern->ilineMax      = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_ilineMax);
  intern->cbLine        = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbLine);
  intern->cbLineOffset  = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbLineOffset);
  intern->idnMax        = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_idnMax);
  intern->cbDnOffset    = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbDnOffset);
  intern->ipdMax        = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_ipdMax);
  intern->cbPdOffset    = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbPdOffset);
  intern->isymMax       = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_isymMax);
  intern->cbSymOffset   = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbSymOffset);
  intern->ioptMax       = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_ioptMax);
  intern->cbOptOffset   = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbOptOffset);
  intern->iauxMax       = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_iauxMax);
  intern->cbAuxOffset   = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbAuxOffset);
  intern->issMax        = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_issMax);
  intern->cbSsOffset    = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbSsOffset);
  intern->issExtMax     = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_issExtMax);
  intern->cbSsExtOffset = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbSsExtOffset);
  intern->ifdMax        = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_ifdMax);
  intern->cbFdOffset    = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbFdOffset);
  intern->crfd          = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_crfd);
  intern->cbRfdOffset   = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbRfdOffset);
  intern->iextMax       = bfd_h_get_32 (abfd, (bfd_byte *)ext->h_iextMax);
  intern->cbExtOffset   = ecoff_get_off (abfd, (bfd_byte *)ext->h_cbExtOffset);
d152 25
a176 25
  bfd_h_put_signed_16 (abfd, intern->magic, (bfd_byte *)ext->h_magic);
  bfd_h_put_signed_16 (abfd, intern->vstamp, (bfd_byte *)ext->h_vstamp);
  bfd_h_put_32 (abfd, intern->ilineMax, (bfd_byte *)ext->h_ilineMax);
  ecoff_put_off (abfd, intern->cbLine, (bfd_byte *)ext->h_cbLine);
  ecoff_put_off (abfd, intern->cbLineOffset, (bfd_byte *)ext->h_cbLineOffset);
  bfd_h_put_32 (abfd, intern->idnMax, (bfd_byte *)ext->h_idnMax);
  ecoff_put_off (abfd, intern->cbDnOffset, (bfd_byte *)ext->h_cbDnOffset);
  bfd_h_put_32 (abfd, intern->ipdMax, (bfd_byte *)ext->h_ipdMax);
  ecoff_put_off (abfd, intern->cbPdOffset, (bfd_byte *)ext->h_cbPdOffset);
  bfd_h_put_32 (abfd, intern->isymMax, (bfd_byte *)ext->h_isymMax);
  ecoff_put_off (abfd, intern->cbSymOffset, (bfd_byte *)ext->h_cbSymOffset);
  bfd_h_put_32 (abfd, intern->ioptMax, (bfd_byte *)ext->h_ioptMax);
  ecoff_put_off (abfd, intern->cbOptOffset, (bfd_byte *)ext->h_cbOptOffset);
  bfd_h_put_32 (abfd, intern->iauxMax, (bfd_byte *)ext->h_iauxMax);
  ecoff_put_off (abfd, intern->cbAuxOffset, (bfd_byte *)ext->h_cbAuxOffset);
  bfd_h_put_32 (abfd, intern->issMax, (bfd_byte *)ext->h_issMax);
  ecoff_put_off (abfd, intern->cbSsOffset, (bfd_byte *)ext->h_cbSsOffset);
  bfd_h_put_32 (abfd, intern->issExtMax, (bfd_byte *)ext->h_issExtMax);
  ecoff_put_off (abfd, intern->cbSsExtOffset, (bfd_byte *)ext->h_cbSsExtOffset);
  bfd_h_put_32 (abfd, intern->ifdMax, (bfd_byte *)ext->h_ifdMax);
  ecoff_put_off (abfd, intern->cbFdOffset, (bfd_byte *)ext->h_cbFdOffset);
  bfd_h_put_32 (abfd, intern->crfd, (bfd_byte *)ext->h_crfd);
  ecoff_put_off (abfd, intern->cbRfdOffset, (bfd_byte *)ext->h_cbRfdOffset);
  bfd_h_put_32 (abfd, intern->iextMax, (bfd_byte *)ext->h_iextMax);
  ecoff_put_off (abfd, intern->cbExtOffset, (bfd_byte *)ext->h_cbExtOffset);
d179 1
a179 1
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
d196 2
a197 2
  intern->adr           = ecoff_get_off (abfd, (bfd_byte *)ext->f_adr);
  intern->rss           = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_rss);
d202 8
a209 8
  intern->issBase       = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_issBase);
  intern->cbSs          = ecoff_get_off (abfd, (bfd_byte *)ext->f_cbSs);
  intern->isymBase      = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_isymBase);
  intern->csym          = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_csym);
  intern->ilineBase     = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_ilineBase);
  intern->cline         = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_cline);
  intern->ioptBase      = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_ioptBase);
  intern->copt          = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_copt);
d211 2
a212 2
  intern->ipdFirst      = bfd_h_get_16 (abfd, (bfd_byte *)ext->f_ipdFirst);
  intern->cpd           = bfd_h_get_16 (abfd, (bfd_byte *)ext->f_cpd);
d215 2
a216 2
  intern->ipdFirst      = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_ipdFirst);
  intern->cpd           = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_cpd);
d218 26
a243 23
  intern->iauxBase      = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_iauxBase);
  intern->caux          = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_caux);
  intern->rfdBase       = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_rfdBase);
  intern->crfd          = bfd_h_get_32 (abfd, (bfd_byte *)ext->f_crfd);

  /* now the fun stuff...  */
  if (bfd_header_big_endian (abfd)) {
    intern->lang        = (ext->f_bits1[0] & FDR_BITS1_LANG_BIG)
					>> FDR_BITS1_LANG_SH_BIG;
    intern->fMerge      = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_BIG);
    intern->fReadin     = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_BIG);
    intern->fBigendian  = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_BIG);
    intern->glevel      = (ext->f_bits2[0] & FDR_BITS2_GLEVEL_BIG)
					>> FDR_BITS2_GLEVEL_SH_BIG;
  } else {
    intern->lang        = (ext->f_bits1[0] & FDR_BITS1_LANG_LITTLE)
					>> FDR_BITS1_LANG_SH_LITTLE;
    intern->fMerge      = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_LITTLE);
    intern->fReadin     = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_LITTLE);
    intern->fBigendian  = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_LITTLE);
    intern->glevel      = (ext->f_bits2[0] & FDR_BITS2_GLEVEL_LITTLE)
					>> FDR_BITS2_GLEVEL_SH_LITTLE;
  }
d246 2
a247 2
  intern->cbLineOffset  = ecoff_get_off (abfd, (bfd_byte *)ext->f_cbLineOffset);
  intern->cbLine        = ecoff_get_off (abfd, (bfd_byte *)ext->f_cbLine);
d266 2
a267 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d269 10
a278 10
  ecoff_put_off (abfd, intern->adr, (bfd_byte *)ext->f_adr);
  bfd_h_put_32 (abfd, intern->rss, (bfd_byte *)ext->f_rss);
  bfd_h_put_32 (abfd, intern->issBase, (bfd_byte *)ext->f_issBase);
  ecoff_put_off (abfd, intern->cbSs, (bfd_byte *)ext->f_cbSs);
  bfd_h_put_32 (abfd, intern->isymBase, (bfd_byte *)ext->f_isymBase);
  bfd_h_put_32 (abfd, intern->csym, (bfd_byte *)ext->f_csym);
  bfd_h_put_32 (abfd, intern->ilineBase, (bfd_byte *)ext->f_ilineBase);
  bfd_h_put_32 (abfd, intern->cline, (bfd_byte *)ext->f_cline);
  bfd_h_put_32 (abfd, intern->ioptBase, (bfd_byte *)ext->f_ioptBase);
  bfd_h_put_32 (abfd, intern->copt, (bfd_byte *)ext->f_copt);
d280 2
a281 2
  bfd_h_put_16 (abfd, intern->ipdFirst, (bfd_byte *)ext->f_ipdFirst);
  bfd_h_put_16 (abfd, intern->cpd, (bfd_byte *)ext->f_cpd);
d284 2
a285 2
  bfd_h_put_32 (abfd, intern->ipdFirst, (bfd_byte *)ext->f_ipdFirst);
  bfd_h_put_32 (abfd, intern->cpd, (bfd_byte *)ext->f_cpd);
d287 4
a290 27
  bfd_h_put_32 (abfd, intern->iauxBase, (bfd_byte *)ext->f_iauxBase);
  bfd_h_put_32 (abfd, intern->caux, (bfd_byte *)ext->f_caux);
  bfd_h_put_32 (abfd, intern->rfdBase, (bfd_byte *)ext->f_rfdBase);
  bfd_h_put_32 (abfd, intern->crfd, (bfd_byte *)ext->f_crfd);

  /* now the fun stuff...  */
  if (bfd_header_big_endian (abfd)) {
    ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_BIG)
			& FDR_BITS1_LANG_BIG)
		       | (intern->fMerge ? FDR_BITS1_FMERGE_BIG : 0)
		       | (intern->fReadin ? FDR_BITS1_FREADIN_BIG : 0)
		       | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_BIG : 0));
    ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_BIG)
		       & FDR_BITS2_GLEVEL_BIG);
    ext->f_bits2[1] = 0;
    ext->f_bits2[2] = 0;
  } else {
    ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_LITTLE)
			& FDR_BITS1_LANG_LITTLE)
		       | (intern->fMerge ? FDR_BITS1_FMERGE_LITTLE : 0)
		       | (intern->fReadin ? FDR_BITS1_FREADIN_LITTLE : 0)
		       | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_LITTLE : 0));
    ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_LITTLE)
		       & FDR_BITS2_GLEVEL_LITTLE);
    ext->f_bits2[1] = 0;
    ext->f_bits2[2] = 0;
  }
d292 28
a319 2
  ecoff_put_off (abfd, intern->cbLineOffset, (bfd_byte *)ext->f_cbLineOffset);
  ecoff_put_off (abfd, intern->cbLine, (bfd_byte *)ext->f_cbLine);
d343 14
a356 17
  intern->adr           = ecoff_get_off (abfd, (bfd_byte *)ext->p_adr);
  intern->isym          = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_isym);
  intern->iline         = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_iline);
  intern->regmask       = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_regmask);
  intern->regoffset     = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_regoffset);
  intern->iopt          = bfd_h_get_signed_32 (abfd, (bfd_byte *)ext->p_iopt);
  intern->fregmask      = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_fregmask);
  intern->fregoffset    = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_fregoffset);
  intern->frameoffset   = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_frameoffset);
  intern->framereg      = bfd_h_get_16 (abfd, (bfd_byte *)ext->p_framereg);
  intern->pcreg         = bfd_h_get_16 (abfd, (bfd_byte *)ext->p_pcreg);
  intern->lnLow         = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_lnLow);
  intern->lnHigh        = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_lnHigh);
  intern->cbLineOffset  = ecoff_get_off (abfd, (bfd_byte *)ext->p_cbLineOffset);
d359 6
a364 1
  intern->gp_prologue = bfd_h_get_8 (abfd, (bfd_byte *) ext->p_gp_prologue);
d385 1
a385 1
  intern->localoff = bfd_h_get_8 (abfd, (bfd_byte *) ext->p_localoff);
d405 2
a406 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d408 14
a421 14
  ecoff_put_off (abfd, intern->adr, (bfd_byte *)ext->p_adr);
  bfd_h_put_32 (abfd, intern->isym, (bfd_byte *)ext->p_isym);
  bfd_h_put_32 (abfd, intern->iline, (bfd_byte *)ext->p_iline);
  bfd_h_put_32 (abfd, intern->regmask, (bfd_byte *)ext->p_regmask);
  bfd_h_put_32 (abfd, intern->regoffset, (bfd_byte *)ext->p_regoffset);
  bfd_h_put_32 (abfd, intern->iopt, (bfd_byte *)ext->p_iopt);
  bfd_h_put_32 (abfd, intern->fregmask, (bfd_byte *)ext->p_fregmask);
  bfd_h_put_32 (abfd, intern->fregoffset, (bfd_byte *)ext->p_fregoffset);
  bfd_h_put_32 (abfd, intern->frameoffset, (bfd_byte *)ext->p_frameoffset);
  bfd_h_put_16 (abfd, intern->framereg, (bfd_byte *)ext->p_framereg);
  bfd_h_put_16 (abfd, intern->pcreg, (bfd_byte *)ext->p_pcreg);
  bfd_h_put_32 (abfd, intern->lnLow, (bfd_byte *)ext->p_lnLow);
  bfd_h_put_32 (abfd, intern->lnHigh, (bfd_byte *)ext->p_lnHigh);
  ecoff_put_off (abfd, intern->cbLineOffset, (bfd_byte *)ext->p_cbLineOffset);
d424 2
a425 1
  bfd_h_put_8 (abfd, intern->gp_prologue, (bfd_byte *) ext->p_gp_prologue);
d448 1
a448 1
  bfd_h_put_8 (abfd, intern->localoff, (bfd_byte *) ext->p_localoff);
d472 14
a485 17
  intern->adr           = ecoff_get_off (abfd, (bfd_byte *)ext->p_adr);
  intern->isym          = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_isym);
  intern->iline         = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_iline);
  intern->regmask       = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_regmask);
  intern->regoffset     = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_regoffset);
  intern->iopt          = bfd_h_get_signed_32 (abfd, (bfd_byte *)ext->p_iopt);
  intern->fregmask      = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_fregmask);
  intern->fregoffset    = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_fregoffset);
  intern->frameoffset   = bfd_h_get_signed_32 (abfd,
					       (bfd_byte *)ext->p_frameoffset);
  intern->framereg      = bfd_h_get_16 (abfd, (bfd_byte *)ext->p_framereg);
  intern->pcreg         = bfd_h_get_16 (abfd, (bfd_byte *)ext->p_pcreg);
  intern->lnLow         = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_lnLow);
  intern->lnHigh        = bfd_h_get_32 (abfd, (bfd_byte *)ext->p_lnHigh);
  intern->cbLineOffset  = ecoff_get_off (abfd, (bfd_byte *)ext->p_cbLineOffset);
d504 2
a505 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d507 14
a520 14
  ecoff_put_off (abfd, intern->adr, (bfd_byte *)ext->p_adr);
  bfd_h_put_32 (abfd, intern->isym, (bfd_byte *)ext->p_isym);
  bfd_h_put_32 (abfd, intern->iline, (bfd_byte *)ext->p_iline);
  bfd_h_put_32 (abfd, intern->regmask, (bfd_byte *)ext->p_regmask);
  bfd_h_put_32 (abfd, intern->regoffset, (bfd_byte *)ext->p_regoffset);
  bfd_h_put_32 (abfd, intern->iopt, (bfd_byte *)ext->p_iopt);
  bfd_h_put_32 (abfd, intern->fregmask, (bfd_byte *)ext->p_fregmask);
  bfd_h_put_32 (abfd, intern->fregoffset, (bfd_byte *)ext->p_fregoffset);
  bfd_h_put_32 (abfd, intern->frameoffset, (bfd_byte *)ext->p_frameoffset);
  bfd_h_put_16 (abfd, intern->framereg, (bfd_byte *)ext->p_framereg);
  bfd_h_put_16 (abfd, intern->pcreg, (bfd_byte *)ext->p_pcreg);
  bfd_h_put_32 (abfd, intern->lnLow, (bfd_byte *)ext->p_lnLow);
  bfd_h_put_32 (abfd, intern->lnHigh, (bfd_byte *)ext->p_lnHigh);
  ecoff_put_off (abfd, intern->cbLineOffset, (bfd_byte *)ext->p_cbLineOffset);
d541 7
a547 2
  intern->iss           = bfd_h_get_32 (abfd, (bfd_byte *)ext->s_iss);
  intern->value         = ecoff_get_off (abfd, (bfd_byte *)ext->s_value);
d549 30
a578 27
  /* now the fun stuff...  */
  if (bfd_header_big_endian (abfd)) {
    intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_BIG)
					   >> SYM_BITS1_ST_SH_BIG;
    intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_BIG)
					   << SYM_BITS1_SC_SH_LEFT_BIG)
			| ((ext->s_bits2[0] & SYM_BITS2_SC_BIG)
					   >> SYM_BITS2_SC_SH_BIG);
    intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_BIG);
    intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_BIG)
					   << SYM_BITS2_INDEX_SH_LEFT_BIG)
			| (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_BIG)
			| (ext->s_bits4[0] << SYM_BITS4_INDEX_SH_LEFT_BIG);
  } else {
    intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_LITTLE)
					   >> SYM_BITS1_ST_SH_LITTLE;
    intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_LITTLE)
					   >> SYM_BITS1_SC_SH_LITTLE)
			| ((ext->s_bits2[0] & SYM_BITS2_SC_LITTLE)
					   << SYM_BITS2_SC_SH_LEFT_LITTLE);
    intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_LITTLE);
    intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_LITTLE)
					   >> SYM_BITS2_INDEX_SH_LITTLE)
			| (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_LITTLE)
			| ((unsigned int) ext->s_bits4[0]
			   << SYM_BITS4_INDEX_SH_LEFT_LITTLE);
  }
d597 2
a598 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d600 2
a601 2
  bfd_h_put_32 (abfd, intern->iss, (bfd_byte *)ext->s_iss);
  ecoff_put_off (abfd, intern->value, (bfd_byte *)ext->s_value);
d603 29
a631 26
  /* now the fun stuff...  */
  if (bfd_header_big_endian (abfd)) {
    ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_BIG)
			& SYM_BITS1_ST_BIG)
		       | ((intern->sc >> SYM_BITS1_SC_SH_LEFT_BIG)
			  & SYM_BITS1_SC_BIG));
    ext->s_bits2[0] = (((intern->sc << SYM_BITS2_SC_SH_BIG)
			& SYM_BITS2_SC_BIG)
		       | (intern->reserved ? SYM_BITS2_RESERVED_BIG : 0)
		       | ((intern->index >> SYM_BITS2_INDEX_SH_LEFT_BIG)
			  & SYM_BITS2_INDEX_BIG));
    ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_BIG) & 0xff;
    ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_BIG) & 0xff;
  } else {
    ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_LITTLE)
			& SYM_BITS1_ST_LITTLE)
		       | ((intern->sc << SYM_BITS1_SC_SH_LITTLE)
			  & SYM_BITS1_SC_LITTLE));
    ext->s_bits2[0] = (((intern->sc >> SYM_BITS2_SC_SH_LEFT_LITTLE)
			& SYM_BITS2_SC_LITTLE)
		       | (intern->reserved ? SYM_BITS2_RESERVED_LITTLE : 0)
		       | ((intern->index << SYM_BITS2_INDEX_SH_LITTLE)
			  & SYM_BITS2_INDEX_LITTLE));
    ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_LITTLE) & 0xff;
    ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_LITTLE) & 0xff;
  }
d651 13
a663 10
  /* now the fun stuff...  */
  if (bfd_header_big_endian (abfd)) {
    intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_BIG);
    intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_BIG);
    intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_BIG);
  } else {
    intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_LITTLE);
    intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_LITTLE);
    intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_LITTLE);
  }
d667 1
a667 1
  intern->ifd           = bfd_h_get_signed_16 (abfd, (bfd_byte *)ext->es_ifd);
d670 1
a670 1
  intern->ifd           = bfd_h_get_signed_32 (abfd, (bfd_byte *)ext->es_ifd);
d692 2
a693 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d695 7
a701 6
  /* now the fun stuff...  */
  if (bfd_header_big_endian (abfd)) {
    ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_BIG : 0)
			| (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_BIG : 0)
			| (intern->weakext ? EXT_BITS1_WEAKEXT_BIG : 0));
    ext->es_bits2[0] = 0;
d703 2
a704 2
    ext->es_bits2[1] = 0;
    ext->es_bits2[2] = 0;
d706 7
a712 5
  } else {
    ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_LITTLE : 0)
			| (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_LITTLE : 0)
			| (intern->weakext ? EXT_BITS1_WEAKEXT_LITTLE : 0));
    ext->es_bits2[0] = 0;
d714 2
a715 2
    ext->es_bits2[1] = 0;
    ext->es_bits2[2] = 0;
d717 1
a717 1
  }
d720 1
a720 1
  bfd_h_put_signed_16 (abfd, intern->ifd, (bfd_byte *)ext->es_ifd);
d723 1
a723 1
  bfd_h_put_signed_32 (abfd, intern->ifd, (bfd_byte *)ext->es_ifd);
d744 1
a744 1
  *intern = bfd_h_get_32 (abfd, (bfd_byte *)ext->rfd);
d762 1
a762 1
  bfd_h_put_32 (abfd, *intern, (bfd_byte *)ext->rfd);
d803 1
a803 1
  intern->offset = bfd_h_get_32 (abfd, (bfd_byte *) ext->o_offset);
d822 2
a823 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d843 1
a843 1
  bfd_h_put_32 (abfd, intern->value, (bfd_byte *) ext->o_offset);
d863 2
a864 2
  intern->rfd = bfd_h_get_32 (abfd, (bfd_byte *) ext->d_rfd);
  intern->index = bfd_h_get_32 (abfd, (bfd_byte *) ext->d_index);
d883 2
a884 1
  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */
d886 2
a887 2
  bfd_h_put_32 (abfd, intern->rfd, (bfd_byte *) ext->d_rfd);
  bfd_h_put_32 (abfd, intern->index, (bfd_byte *) ext->d_index);
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d48 2
a49 2
#define ECOFF_GET_OFF H_GET_32
#define ECOFF_PUT_OFF H_PUT_32
d52 2
a53 2
#define ECOFF_GET_OFF H_GET_64
#define ECOFF_PUT_OFF H_PUT_64
d56 2
a57 2
#define ECOFF_GET_OFF H_GET_S32
#define ECOFF_PUT_OFF H_PUT_S32
d60 2
a61 2
#define ECOFF_GET_OFF H_GET_S64
#define ECOFF_PUT_OFF H_PUT_S64
d107 25
a131 25
  intern->magic         = H_GET_S16     (abfd, ext->h_magic);
  intern->vstamp        = H_GET_S16     (abfd, ext->h_vstamp);
  intern->ilineMax      = H_GET_32      (abfd, ext->h_ilineMax);
  intern->cbLine        = ECOFF_GET_OFF (abfd, ext->h_cbLine);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->h_cbLineOffset);
  intern->idnMax        = H_GET_32      (abfd, ext->h_idnMax);
  intern->cbDnOffset    = ECOFF_GET_OFF (abfd, ext->h_cbDnOffset);
  intern->ipdMax        = H_GET_32      (abfd, ext->h_ipdMax);
  intern->cbPdOffset    = ECOFF_GET_OFF (abfd, ext->h_cbPdOffset);
  intern->isymMax       = H_GET_32      (abfd, ext->h_isymMax);
  intern->cbSymOffset   = ECOFF_GET_OFF (abfd, ext->h_cbSymOffset);
  intern->ioptMax       = H_GET_32      (abfd, ext->h_ioptMax);
  intern->cbOptOffset   = ECOFF_GET_OFF (abfd, ext->h_cbOptOffset);
  intern->iauxMax       = H_GET_32      (abfd, ext->h_iauxMax);
  intern->cbAuxOffset   = ECOFF_GET_OFF (abfd, ext->h_cbAuxOffset);
  intern->issMax        = H_GET_32      (abfd, ext->h_issMax);
  intern->cbSsOffset    = ECOFF_GET_OFF (abfd, ext->h_cbSsOffset);
  intern->issExtMax     = H_GET_32      (abfd, ext->h_issExtMax);
  intern->cbSsExtOffset = ECOFF_GET_OFF (abfd, ext->h_cbSsExtOffset);
  intern->ifdMax        = H_GET_32      (abfd, ext->h_ifdMax);
  intern->cbFdOffset    = ECOFF_GET_OFF (abfd, ext->h_cbFdOffset);
  intern->crfd          = H_GET_32      (abfd, ext->h_crfd);
  intern->cbRfdOffset   = ECOFF_GET_OFF (abfd, ext->h_cbRfdOffset);
  intern->iextMax       = H_GET_32      (abfd, ext->h_iextMax);
  intern->cbExtOffset   = ECOFF_GET_OFF (abfd, ext->h_cbExtOffset);
d152 25
a176 25
  H_PUT_S16     (abfd, intern->magic,         ext->h_magic);
  H_PUT_S16     (abfd, intern->vstamp,        ext->h_vstamp);
  H_PUT_32      (abfd, intern->ilineMax,      ext->h_ilineMax);
  ECOFF_PUT_OFF (abfd, intern->cbLine,        ext->h_cbLine);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset,  ext->h_cbLineOffset);
  H_PUT_32      (abfd, intern->idnMax,        ext->h_idnMax);
  ECOFF_PUT_OFF (abfd, intern->cbDnOffset,    ext->h_cbDnOffset);
  H_PUT_32      (abfd, intern->ipdMax,        ext->h_ipdMax);
  ECOFF_PUT_OFF (abfd, intern->cbPdOffset,    ext->h_cbPdOffset);
  H_PUT_32      (abfd, intern->isymMax,       ext->h_isymMax);
  ECOFF_PUT_OFF (abfd, intern->cbSymOffset,   ext->h_cbSymOffset);
  H_PUT_32      (abfd, intern->ioptMax,       ext->h_ioptMax);
  ECOFF_PUT_OFF (abfd, intern->cbOptOffset,   ext->h_cbOptOffset);
  H_PUT_32      (abfd, intern->iauxMax,       ext->h_iauxMax);
  ECOFF_PUT_OFF (abfd, intern->cbAuxOffset,   ext->h_cbAuxOffset);
  H_PUT_32      (abfd, intern->issMax,        ext->h_issMax);
  ECOFF_PUT_OFF (abfd, intern->cbSsOffset,    ext->h_cbSsOffset);
  H_PUT_32      (abfd, intern->issExtMax,     ext->h_issExtMax);
  ECOFF_PUT_OFF (abfd, intern->cbSsExtOffset, ext->h_cbSsExtOffset);
  H_PUT_32      (abfd, intern->ifdMax,        ext->h_ifdMax);
  ECOFF_PUT_OFF (abfd, intern->cbFdOffset,    ext->h_cbFdOffset);
  H_PUT_32      (abfd, intern->crfd,          ext->h_crfd);
  ECOFF_PUT_OFF (abfd, intern->cbRfdOffset,   ext->h_cbRfdOffset);
  H_PUT_32      (abfd, intern->iextMax,       ext->h_iextMax);
  ECOFF_PUT_OFF (abfd, intern->cbExtOffset,   ext->h_cbExtOffset);
d179 1
a179 1
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
d196 2
a197 2
  intern->adr           = ECOFF_GET_OFF (abfd, ext->f_adr);
  intern->rss           = H_GET_32 (abfd, ext->f_rss);
d202 8
a209 8
  intern->issBase       = H_GET_32 (abfd, ext->f_issBase);
  intern->cbSs          = ECOFF_GET_OFF (abfd, ext->f_cbSs);
  intern->isymBase      = H_GET_32 (abfd, ext->f_isymBase);
  intern->csym          = H_GET_32 (abfd, ext->f_csym);
  intern->ilineBase     = H_GET_32 (abfd, ext->f_ilineBase);
  intern->cline         = H_GET_32 (abfd, ext->f_cline);
  intern->ioptBase      = H_GET_32 (abfd, ext->f_ioptBase);
  intern->copt          = H_GET_32 (abfd, ext->f_copt);
d211 2
a212 2
  intern->ipdFirst      = H_GET_16 (abfd, ext->f_ipdFirst);
  intern->cpd           = H_GET_16 (abfd, ext->f_cpd);
d215 2
a216 2
  intern->ipdFirst      = H_GET_32 (abfd, ext->f_ipdFirst);
  intern->cpd           = H_GET_32 (abfd, ext->f_cpd);
d218 23
a240 26
  intern->iauxBase      = H_GET_32 (abfd, ext->f_iauxBase);
  intern->caux          = H_GET_32 (abfd, ext->f_caux);
  intern->rfdBase       = H_GET_32 (abfd, ext->f_rfdBase);
  intern->crfd          = H_GET_32 (abfd, ext->f_crfd);

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->lang       = ((ext->f_bits1[0] & FDR_BITS1_LANG_BIG)
			    >> FDR_BITS1_LANG_SH_BIG);
      intern->fMerge     = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_BIG);
      intern->fReadin    = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_BIG);
      intern->fBigendian = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_BIG);
      intern->glevel     = ((ext->f_bits2[0] & FDR_BITS2_GLEVEL_BIG)
			    >> FDR_BITS2_GLEVEL_SH_BIG);
    }
  else
    {
      intern->lang       = ((ext->f_bits1[0] & FDR_BITS1_LANG_LITTLE)
			    >> FDR_BITS1_LANG_SH_LITTLE);
      intern->fMerge     = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_LITTLE);
      intern->fReadin    = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_LITTLE);
      intern->fBigendian = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_LITTLE);
      intern->glevel     = ((ext->f_bits2[0] & FDR_BITS2_GLEVEL_LITTLE)
			    >> FDR_BITS2_GLEVEL_SH_LITTLE);
    }
d243 2
a244 2
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->f_cbLineOffset);
  intern->cbLine        = ECOFF_GET_OFF (abfd, ext->f_cbLine);
d263 1
a263 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d265 10
a274 10
  ECOFF_PUT_OFF (abfd, intern->adr,       ext->f_adr);
  H_PUT_32      (abfd, intern->rss,       ext->f_rss);
  H_PUT_32      (abfd, intern->issBase,   ext->f_issBase);
  ECOFF_PUT_OFF (abfd, intern->cbSs,      ext->f_cbSs);
  H_PUT_32      (abfd, intern->isymBase,  ext->f_isymBase);
  H_PUT_32      (abfd, intern->csym,      ext->f_csym);
  H_PUT_32      (abfd, intern->ilineBase, ext->f_ilineBase);
  H_PUT_32      (abfd, intern->cline,     ext->f_cline);
  H_PUT_32      (abfd, intern->ioptBase,  ext->f_ioptBase);
  H_PUT_32      (abfd, intern->copt,      ext->f_copt);
d276 2
a277 2
  H_PUT_16      (abfd, intern->ipdFirst,  ext->f_ipdFirst);
  H_PUT_16      (abfd, intern->cpd,       ext->f_cpd);
d280 2
a281 2
  H_PUT_32      (abfd, intern->ipdFirst,  ext->f_ipdFirst);
  H_PUT_32      (abfd, intern->cpd,       ext->f_cpd);
d283 27
a309 4
  H_PUT_32      (abfd, intern->iauxBase,  ext->f_iauxBase);
  H_PUT_32      (abfd, intern->caux,      ext->f_caux);
  H_PUT_32      (abfd, intern->rfdBase,   ext->f_rfdBase);
  H_PUT_32      (abfd, intern->crfd,      ext->f_crfd);
d311 2
a312 28
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_BIG)
			  & FDR_BITS1_LANG_BIG)
			 | (intern->fMerge ? FDR_BITS1_FMERGE_BIG : 0)
			 | (intern->fReadin ? FDR_BITS1_FREADIN_BIG : 0)
			 | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_BIG : 0));
      ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_BIG)
			 & FDR_BITS2_GLEVEL_BIG);
      ext->f_bits2[1] = 0;
      ext->f_bits2[2] = 0;
    }
  else
    {
      ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_LITTLE)
			  & FDR_BITS1_LANG_LITTLE)
			 | (intern->fMerge ? FDR_BITS1_FMERGE_LITTLE : 0)
			 | (intern->fReadin ? FDR_BITS1_FREADIN_LITTLE : 0)
			 | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_LITTLE : 0));
      ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_LITTLE)
			 & FDR_BITS2_GLEVEL_LITTLE);
      ext->f_bits2[1] = 0;
      ext->f_bits2[2] = 0;
    }

  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->f_cbLineOffset);
  ECOFF_PUT_OFF (abfd, intern->cbLine, ext->f_cbLine);
d336 17
a352 14
  intern->adr           = ECOFF_GET_OFF (abfd, ext->p_adr);
  intern->isym          = H_GET_32 (abfd, ext->p_isym);
  intern->iline         = H_GET_32 (abfd, ext->p_iline);
  intern->regmask       = H_GET_32 (abfd, ext->p_regmask);
  intern->regoffset     = H_GET_S32 (abfd, ext->p_regoffset);
  intern->iopt          = H_GET_S32 (abfd, ext->p_iopt);
  intern->fregmask      = H_GET_32 (abfd, ext->p_fregmask);
  intern->fregoffset    = H_GET_S32 (abfd, ext->p_fregoffset);
  intern->frameoffset   = H_GET_S32 (abfd, ext->p_frameoffset);
  intern->framereg      = H_GET_16 (abfd, ext->p_framereg);
  intern->pcreg         = H_GET_16 (abfd, ext->p_pcreg);
  intern->lnLow         = H_GET_32 (abfd, ext->p_lnLow);
  intern->lnHigh        = H_GET_32 (abfd, ext->p_lnHigh);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->p_cbLineOffset);
d355 1
a355 6
  if (intern->isym == (signed long) 0xffffffff)
    intern->isym = -1;
  if (intern->iline == (signed long) 0xffffffff)
    intern->iline = -1;

  intern->gp_prologue = H_GET_8 (abfd, ext->p_gp_prologue);
d376 1
a376 1
  intern->localoff = H_GET_8 (abfd, ext->p_localoff);
d396 1
a396 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d398 14
a411 14
  ECOFF_PUT_OFF (abfd, intern->adr,          ext->p_adr);
  H_PUT_32      (abfd, intern->isym,         ext->p_isym);
  H_PUT_32      (abfd, intern->iline,        ext->p_iline);
  H_PUT_32      (abfd, intern->regmask,      ext->p_regmask);
  H_PUT_32      (abfd, intern->regoffset,    ext->p_regoffset);
  H_PUT_32      (abfd, intern->iopt,         ext->p_iopt);
  H_PUT_32      (abfd, intern->fregmask,     ext->p_fregmask);
  H_PUT_32      (abfd, intern->fregoffset,   ext->p_fregoffset);
  H_PUT_32      (abfd, intern->frameoffset,  ext->p_frameoffset);
  H_PUT_16      (abfd, intern->framereg,     ext->p_framereg);
  H_PUT_16      (abfd, intern->pcreg,        ext->p_pcreg);
  H_PUT_32      (abfd, intern->lnLow,        ext->p_lnLow);
  H_PUT_32      (abfd, intern->lnHigh,       ext->p_lnHigh);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->p_cbLineOffset);
d414 1
a414 2
  H_PUT_8       (abfd, intern->gp_prologue,  ext->p_gp_prologue);

d437 1
a437 1
  H_PUT_8 (abfd, intern->localoff, ext->p_localoff);
d461 17
a477 14
  intern->adr           = ECOFF_GET_OFF (abfd, ext->p_adr);
  intern->isym          = H_GET_32 (abfd, ext->p_isym);
  intern->iline         = H_GET_32 (abfd, ext->p_iline);
  intern->regmask       = H_GET_32 (abfd, ext->p_regmask);
  intern->regoffset     = H_GET_S32 (abfd, ext->p_regoffset);
  intern->iopt          = H_GET_S32 (abfd, ext->p_iopt);
  intern->fregmask      = H_GET_32 (abfd, ext->p_fregmask);
  intern->fregoffset    = H_GET_S32 (abfd, ext->p_fregoffset);
  intern->frameoffset   = H_GET_S32 (abfd, ext->p_frameoffset);
  intern->framereg      = H_GET_16 (abfd, ext->p_framereg);
  intern->pcreg         = H_GET_16 (abfd, ext->p_pcreg);
  intern->lnLow         = H_GET_32 (abfd, ext->p_lnLow);
  intern->lnHigh        = H_GET_32 (abfd, ext->p_lnHigh);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->p_cbLineOffset);
d496 1
a496 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d498 14
a511 14
  ECOFF_PUT_OFF (abfd, intern->adr,          ext->p_adr);
  H_PUT_32      (abfd, intern->isym,         ext->p_isym);
  H_PUT_32      (abfd, intern->iline,        ext->p_iline);
  H_PUT_32      (abfd, intern->regmask,      ext->p_regmask);
  H_PUT_32      (abfd, intern->regoffset,    ext->p_regoffset);
  H_PUT_32      (abfd, intern->iopt,         ext->p_iopt);
  H_PUT_32      (abfd, intern->fregmask,     ext->p_fregmask);
  H_PUT_32      (abfd, intern->fregoffset,   ext->p_fregoffset);
  H_PUT_32      (abfd, intern->frameoffset,  ext->p_frameoffset);
  H_PUT_16      (abfd, intern->framereg,     ext->p_framereg);
  H_PUT_16      (abfd, intern->pcreg,        ext->p_pcreg);
  H_PUT_32      (abfd, intern->lnLow,        ext->p_lnLow);
  H_PUT_32      (abfd, intern->lnHigh,       ext->p_lnHigh);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->p_cbLineOffset);
d532 2
a533 7
  intern->iss           = H_GET_32 (abfd, ext->s_iss);
  intern->value         = ECOFF_GET_OFF (abfd, ext->s_value);

#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  if (intern->iss == (signed long) 0xffffffff)
    intern->iss = -1;
#endif  
d535 27
a561 30
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_BIG)
					     >> SYM_BITS1_ST_SH_BIG;
      intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_BIG)
					     << SYM_BITS1_SC_SH_LEFT_BIG)
			  | ((ext->s_bits2[0] & SYM_BITS2_SC_BIG)
					     >> SYM_BITS2_SC_SH_BIG);
      intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_BIG);
      intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_BIG)
					     << SYM_BITS2_INDEX_SH_LEFT_BIG)
			  | (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_BIG)
			  | (ext->s_bits4[0] << SYM_BITS4_INDEX_SH_LEFT_BIG);
    }
  else
    {
      intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_LITTLE)
					     >> SYM_BITS1_ST_SH_LITTLE;
      intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_LITTLE)
					     >> SYM_BITS1_SC_SH_LITTLE)
			  | ((ext->s_bits2[0] & SYM_BITS2_SC_LITTLE)
					     << SYM_BITS2_SC_SH_LEFT_LITTLE);
      intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_LITTLE);
      intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_LITTLE)
					     >> SYM_BITS2_INDEX_SH_LITTLE)
			  | (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_LITTLE)
			  | ((unsigned int) ext->s_bits4[0]
			     << SYM_BITS4_INDEX_SH_LEFT_LITTLE);
    }
d580 1
a580 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d582 2
a583 2
  H_PUT_32 (abfd, intern->iss, ext->s_iss);
  ECOFF_PUT_OFF (abfd, intern->value, ext->s_value);
d585 26
a610 29
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_BIG)
			  & SYM_BITS1_ST_BIG)
			 | ((intern->sc >> SYM_BITS1_SC_SH_LEFT_BIG)
			    & SYM_BITS1_SC_BIG));
      ext->s_bits2[0] = (((intern->sc << SYM_BITS2_SC_SH_BIG)
			  & SYM_BITS2_SC_BIG)
			 | (intern->reserved ? SYM_BITS2_RESERVED_BIG : 0)
			 | ((intern->index >> SYM_BITS2_INDEX_SH_LEFT_BIG)
			    & SYM_BITS2_INDEX_BIG));
      ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_BIG) & 0xff;
      ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_BIG) & 0xff;
    }
  else
    {
      ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_LITTLE)
			  & SYM_BITS1_ST_LITTLE)
			 | ((intern->sc << SYM_BITS1_SC_SH_LITTLE)
			    & SYM_BITS1_SC_LITTLE));
      ext->s_bits2[0] = (((intern->sc >> SYM_BITS2_SC_SH_LEFT_LITTLE)
			  & SYM_BITS2_SC_LITTLE)
			 | (intern->reserved ? SYM_BITS2_RESERVED_LITTLE : 0)
			 | ((intern->index << SYM_BITS2_INDEX_SH_LITTLE)
			    & SYM_BITS2_INDEX_LITTLE));
      ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_LITTLE) & 0xff;
      ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_LITTLE) & 0xff;
    }
d630 10
a639 13
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_BIG);
      intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_BIG);
      intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_BIG);
    }
  else
    {
      intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_LITTLE);
      intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_LITTLE);
      intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_LITTLE);
    }
d643 1
a643 1
  intern->ifd = H_GET_S16 (abfd, ext->es_ifd);
d646 1
a646 1
  intern->ifd = H_GET_S32 (abfd, ext->es_ifd);
d668 1
a668 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d670 6
a675 7
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_BIG : 0)
			  | (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_BIG : 0)
			  | (intern->weakext ? EXT_BITS1_WEAKEXT_BIG : 0));
      ext->es_bits2[0] = 0;
d677 2
a678 2
      ext->es_bits2[1] = 0;
      ext->es_bits2[2] = 0;
d680 5
a684 7
    }
  else
    {
      ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_LITTLE : 0)
			  | (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_LITTLE : 0)
			  | (intern->weakext ? EXT_BITS1_WEAKEXT_LITTLE : 0));
      ext->es_bits2[0] = 0;
d686 2
a687 2
      ext->es_bits2[1] = 0;
      ext->es_bits2[2] = 0;
d689 1
a689 1
    }
d692 1
a692 1
  H_PUT_S16 (abfd, intern->ifd, ext->es_ifd);
d695 1
a695 1
  H_PUT_S32 (abfd, intern->ifd, ext->es_ifd);
d716 1
a716 1
  *intern = H_GET_32 (abfd, ext->rfd);
d734 1
a734 1
  H_PUT_32 (abfd, *intern, ext->rfd);
d775 1
a775 1
  intern->offset = H_GET_32 (abfd, ext->o_offset);
d794 1
a794 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d814 1
a814 1
  H_PUT_32 (abfd, intern->value, ext->o_offset);
d834 2
a835 2
  intern->rfd = H_GET_32 (abfd, ext->d_rfd);
  intern->index = H_GET_32 (abfd, ext->d_index);
d854 1
a854 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d856 2
a857 2
  H_PUT_32 (abfd, intern->rfd, ext->d_rfd);
  H_PUT_32 (abfd, intern->index, ext->d_index);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d48 2
a49 2
#define ECOFF_GET_OFF H_GET_32
#define ECOFF_PUT_OFF H_PUT_32
d52 2
a53 2
#define ECOFF_GET_OFF H_GET_64
#define ECOFF_PUT_OFF H_PUT_64
d56 2
a57 2
#define ECOFF_GET_OFF H_GET_S32
#define ECOFF_PUT_OFF H_PUT_S32
d60 2
a61 2
#define ECOFF_GET_OFF H_GET_S64
#define ECOFF_PUT_OFF H_PUT_S64
d107 25
a131 25
  intern->magic         = H_GET_S16     (abfd, ext->h_magic);
  intern->vstamp        = H_GET_S16     (abfd, ext->h_vstamp);
  intern->ilineMax      = H_GET_32      (abfd, ext->h_ilineMax);
  intern->cbLine        = ECOFF_GET_OFF (abfd, ext->h_cbLine);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->h_cbLineOffset);
  intern->idnMax        = H_GET_32      (abfd, ext->h_idnMax);
  intern->cbDnOffset    = ECOFF_GET_OFF (abfd, ext->h_cbDnOffset);
  intern->ipdMax        = H_GET_32      (abfd, ext->h_ipdMax);
  intern->cbPdOffset    = ECOFF_GET_OFF (abfd, ext->h_cbPdOffset);
  intern->isymMax       = H_GET_32      (abfd, ext->h_isymMax);
  intern->cbSymOffset   = ECOFF_GET_OFF (abfd, ext->h_cbSymOffset);
  intern->ioptMax       = H_GET_32      (abfd, ext->h_ioptMax);
  intern->cbOptOffset   = ECOFF_GET_OFF (abfd, ext->h_cbOptOffset);
  intern->iauxMax       = H_GET_32      (abfd, ext->h_iauxMax);
  intern->cbAuxOffset   = ECOFF_GET_OFF (abfd, ext->h_cbAuxOffset);
  intern->issMax        = H_GET_32      (abfd, ext->h_issMax);
  intern->cbSsOffset    = ECOFF_GET_OFF (abfd, ext->h_cbSsOffset);
  intern->issExtMax     = H_GET_32      (abfd, ext->h_issExtMax);
  intern->cbSsExtOffset = ECOFF_GET_OFF (abfd, ext->h_cbSsExtOffset);
  intern->ifdMax        = H_GET_32      (abfd, ext->h_ifdMax);
  intern->cbFdOffset    = ECOFF_GET_OFF (abfd, ext->h_cbFdOffset);
  intern->crfd          = H_GET_32      (abfd, ext->h_crfd);
  intern->cbRfdOffset   = ECOFF_GET_OFF (abfd, ext->h_cbRfdOffset);
  intern->iextMax       = H_GET_32      (abfd, ext->h_iextMax);
  intern->cbExtOffset   = ECOFF_GET_OFF (abfd, ext->h_cbExtOffset);
d152 25
a176 25
  H_PUT_S16     (abfd, intern->magic,         ext->h_magic);
  H_PUT_S16     (abfd, intern->vstamp,        ext->h_vstamp);
  H_PUT_32      (abfd, intern->ilineMax,      ext->h_ilineMax);
  ECOFF_PUT_OFF (abfd, intern->cbLine,        ext->h_cbLine);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset,  ext->h_cbLineOffset);
  H_PUT_32      (abfd, intern->idnMax,        ext->h_idnMax);
  ECOFF_PUT_OFF (abfd, intern->cbDnOffset,    ext->h_cbDnOffset);
  H_PUT_32      (abfd, intern->ipdMax,        ext->h_ipdMax);
  ECOFF_PUT_OFF (abfd, intern->cbPdOffset,    ext->h_cbPdOffset);
  H_PUT_32      (abfd, intern->isymMax,       ext->h_isymMax);
  ECOFF_PUT_OFF (abfd, intern->cbSymOffset,   ext->h_cbSymOffset);
  H_PUT_32      (abfd, intern->ioptMax,       ext->h_ioptMax);
  ECOFF_PUT_OFF (abfd, intern->cbOptOffset,   ext->h_cbOptOffset);
  H_PUT_32      (abfd, intern->iauxMax,       ext->h_iauxMax);
  ECOFF_PUT_OFF (abfd, intern->cbAuxOffset,   ext->h_cbAuxOffset);
  H_PUT_32      (abfd, intern->issMax,        ext->h_issMax);
  ECOFF_PUT_OFF (abfd, intern->cbSsOffset,    ext->h_cbSsOffset);
  H_PUT_32      (abfd, intern->issExtMax,     ext->h_issExtMax);
  ECOFF_PUT_OFF (abfd, intern->cbSsExtOffset, ext->h_cbSsExtOffset);
  H_PUT_32      (abfd, intern->ifdMax,        ext->h_ifdMax);
  ECOFF_PUT_OFF (abfd, intern->cbFdOffset,    ext->h_cbFdOffset);
  H_PUT_32      (abfd, intern->crfd,          ext->h_crfd);
  ECOFF_PUT_OFF (abfd, intern->cbRfdOffset,   ext->h_cbRfdOffset);
  H_PUT_32      (abfd, intern->iextMax,       ext->h_iextMax);
  ECOFF_PUT_OFF (abfd, intern->cbExtOffset,   ext->h_cbExtOffset);
d179 1
a179 1
  if (memcmp ((char *) ext, (char *) intern, sizeof (*intern)) != 0)
d196 2
a197 2
  intern->adr           = ECOFF_GET_OFF (abfd, ext->f_adr);
  intern->rss           = H_GET_32 (abfd, ext->f_rss);
d202 8
a209 8
  intern->issBase       = H_GET_32 (abfd, ext->f_issBase);
  intern->cbSs          = ECOFF_GET_OFF (abfd, ext->f_cbSs);
  intern->isymBase      = H_GET_32 (abfd, ext->f_isymBase);
  intern->csym          = H_GET_32 (abfd, ext->f_csym);
  intern->ilineBase     = H_GET_32 (abfd, ext->f_ilineBase);
  intern->cline         = H_GET_32 (abfd, ext->f_cline);
  intern->ioptBase      = H_GET_32 (abfd, ext->f_ioptBase);
  intern->copt          = H_GET_32 (abfd, ext->f_copt);
d211 2
a212 2
  intern->ipdFirst      = H_GET_16 (abfd, ext->f_ipdFirst);
  intern->cpd           = H_GET_16 (abfd, ext->f_cpd);
d215 2
a216 2
  intern->ipdFirst      = H_GET_32 (abfd, ext->f_ipdFirst);
  intern->cpd           = H_GET_32 (abfd, ext->f_cpd);
d218 23
a240 26
  intern->iauxBase      = H_GET_32 (abfd, ext->f_iauxBase);
  intern->caux          = H_GET_32 (abfd, ext->f_caux);
  intern->rfdBase       = H_GET_32 (abfd, ext->f_rfdBase);
  intern->crfd          = H_GET_32 (abfd, ext->f_crfd);

  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->lang       = ((ext->f_bits1[0] & FDR_BITS1_LANG_BIG)
			    >> FDR_BITS1_LANG_SH_BIG);
      intern->fMerge     = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_BIG);
      intern->fReadin    = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_BIG);
      intern->fBigendian = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_BIG);
      intern->glevel     = ((ext->f_bits2[0] & FDR_BITS2_GLEVEL_BIG)
			    >> FDR_BITS2_GLEVEL_SH_BIG);
    }
  else
    {
      intern->lang       = ((ext->f_bits1[0] & FDR_BITS1_LANG_LITTLE)
			    >> FDR_BITS1_LANG_SH_LITTLE);
      intern->fMerge     = 0 != (ext->f_bits1[0] & FDR_BITS1_FMERGE_LITTLE);
      intern->fReadin    = 0 != (ext->f_bits1[0] & FDR_BITS1_FREADIN_LITTLE);
      intern->fBigendian = 0 != (ext->f_bits1[0] & FDR_BITS1_FBIGENDIAN_LITTLE);
      intern->glevel     = ((ext->f_bits2[0] & FDR_BITS2_GLEVEL_LITTLE)
			    >> FDR_BITS2_GLEVEL_SH_LITTLE);
    }
d243 2
a244 2
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->f_cbLineOffset);
  intern->cbLine        = ECOFF_GET_OFF (abfd, ext->f_cbLine);
d263 1
a263 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d265 10
a274 10
  ECOFF_PUT_OFF (abfd, intern->adr,       ext->f_adr);
  H_PUT_32      (abfd, intern->rss,       ext->f_rss);
  H_PUT_32      (abfd, intern->issBase,   ext->f_issBase);
  ECOFF_PUT_OFF (abfd, intern->cbSs,      ext->f_cbSs);
  H_PUT_32      (abfd, intern->isymBase,  ext->f_isymBase);
  H_PUT_32      (abfd, intern->csym,      ext->f_csym);
  H_PUT_32      (abfd, intern->ilineBase, ext->f_ilineBase);
  H_PUT_32      (abfd, intern->cline,     ext->f_cline);
  H_PUT_32      (abfd, intern->ioptBase,  ext->f_ioptBase);
  H_PUT_32      (abfd, intern->copt,      ext->f_copt);
d276 2
a277 2
  H_PUT_16      (abfd, intern->ipdFirst,  ext->f_ipdFirst);
  H_PUT_16      (abfd, intern->cpd,       ext->f_cpd);
d280 2
a281 2
  H_PUT_32      (abfd, intern->ipdFirst,  ext->f_ipdFirst);
  H_PUT_32      (abfd, intern->cpd,       ext->f_cpd);
d283 27
a309 4
  H_PUT_32      (abfd, intern->iauxBase,  ext->f_iauxBase);
  H_PUT_32      (abfd, intern->caux,      ext->f_caux);
  H_PUT_32      (abfd, intern->rfdBase,   ext->f_rfdBase);
  H_PUT_32      (abfd, intern->crfd,      ext->f_crfd);
d311 2
a312 28
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_BIG)
			  & FDR_BITS1_LANG_BIG)
			 | (intern->fMerge ? FDR_BITS1_FMERGE_BIG : 0)
			 | (intern->fReadin ? FDR_BITS1_FREADIN_BIG : 0)
			 | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_BIG : 0));
      ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_BIG)
			 & FDR_BITS2_GLEVEL_BIG);
      ext->f_bits2[1] = 0;
      ext->f_bits2[2] = 0;
    }
  else
    {
      ext->f_bits1[0] = (((intern->lang << FDR_BITS1_LANG_SH_LITTLE)
			  & FDR_BITS1_LANG_LITTLE)
			 | (intern->fMerge ? FDR_BITS1_FMERGE_LITTLE : 0)
			 | (intern->fReadin ? FDR_BITS1_FREADIN_LITTLE : 0)
			 | (intern->fBigendian ? FDR_BITS1_FBIGENDIAN_LITTLE : 0));
      ext->f_bits2[0] = ((intern->glevel << FDR_BITS2_GLEVEL_SH_LITTLE)
			 & FDR_BITS2_GLEVEL_LITTLE);
      ext->f_bits2[1] = 0;
      ext->f_bits2[2] = 0;
    }

  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->f_cbLineOffset);
  ECOFF_PUT_OFF (abfd, intern->cbLine, ext->f_cbLine);
d336 17
a352 14
  intern->adr           = ECOFF_GET_OFF (abfd, ext->p_adr);
  intern->isym          = H_GET_32 (abfd, ext->p_isym);
  intern->iline         = H_GET_32 (abfd, ext->p_iline);
  intern->regmask       = H_GET_32 (abfd, ext->p_regmask);
  intern->regoffset     = H_GET_S32 (abfd, ext->p_regoffset);
  intern->iopt          = H_GET_S32 (abfd, ext->p_iopt);
  intern->fregmask      = H_GET_32 (abfd, ext->p_fregmask);
  intern->fregoffset    = H_GET_S32 (abfd, ext->p_fregoffset);
  intern->frameoffset   = H_GET_S32 (abfd, ext->p_frameoffset);
  intern->framereg      = H_GET_16 (abfd, ext->p_framereg);
  intern->pcreg         = H_GET_16 (abfd, ext->p_pcreg);
  intern->lnLow         = H_GET_32 (abfd, ext->p_lnLow);
  intern->lnHigh        = H_GET_32 (abfd, ext->p_lnHigh);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->p_cbLineOffset);
d355 1
a355 6
  if (intern->isym == (signed long) 0xffffffff)
    intern->isym = -1;
  if (intern->iline == (signed long) 0xffffffff)
    intern->iline = -1;

  intern->gp_prologue = H_GET_8 (abfd, ext->p_gp_prologue);
d376 1
a376 1
  intern->localoff = H_GET_8 (abfd, ext->p_localoff);
d396 1
a396 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d398 14
a411 14
  ECOFF_PUT_OFF (abfd, intern->adr,          ext->p_adr);
  H_PUT_32      (abfd, intern->isym,         ext->p_isym);
  H_PUT_32      (abfd, intern->iline,        ext->p_iline);
  H_PUT_32      (abfd, intern->regmask,      ext->p_regmask);
  H_PUT_32      (abfd, intern->regoffset,    ext->p_regoffset);
  H_PUT_32      (abfd, intern->iopt,         ext->p_iopt);
  H_PUT_32      (abfd, intern->fregmask,     ext->p_fregmask);
  H_PUT_32      (abfd, intern->fregoffset,   ext->p_fregoffset);
  H_PUT_32      (abfd, intern->frameoffset,  ext->p_frameoffset);
  H_PUT_16      (abfd, intern->framereg,     ext->p_framereg);
  H_PUT_16      (abfd, intern->pcreg,        ext->p_pcreg);
  H_PUT_32      (abfd, intern->lnLow,        ext->p_lnLow);
  H_PUT_32      (abfd, intern->lnHigh,       ext->p_lnHigh);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->p_cbLineOffset);
d414 1
a414 2
  H_PUT_8       (abfd, intern->gp_prologue,  ext->p_gp_prologue);

d437 1
a437 1
  H_PUT_8 (abfd, intern->localoff, ext->p_localoff);
d461 17
a477 14
  intern->adr           = ECOFF_GET_OFF (abfd, ext->p_adr);
  intern->isym          = H_GET_32 (abfd, ext->p_isym);
  intern->iline         = H_GET_32 (abfd, ext->p_iline);
  intern->regmask       = H_GET_32 (abfd, ext->p_regmask);
  intern->regoffset     = H_GET_S32 (abfd, ext->p_regoffset);
  intern->iopt          = H_GET_S32 (abfd, ext->p_iopt);
  intern->fregmask      = H_GET_32 (abfd, ext->p_fregmask);
  intern->fregoffset    = H_GET_S32 (abfd, ext->p_fregoffset);
  intern->frameoffset   = H_GET_S32 (abfd, ext->p_frameoffset);
  intern->framereg      = H_GET_16 (abfd, ext->p_framereg);
  intern->pcreg         = H_GET_16 (abfd, ext->p_pcreg);
  intern->lnLow         = H_GET_32 (abfd, ext->p_lnLow);
  intern->lnHigh        = H_GET_32 (abfd, ext->p_lnHigh);
  intern->cbLineOffset  = ECOFF_GET_OFF (abfd, ext->p_cbLineOffset);
d496 1
a496 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d498 14
a511 14
  ECOFF_PUT_OFF (abfd, intern->adr,          ext->p_adr);
  H_PUT_32      (abfd, intern->isym,         ext->p_isym);
  H_PUT_32      (abfd, intern->iline,        ext->p_iline);
  H_PUT_32      (abfd, intern->regmask,      ext->p_regmask);
  H_PUT_32      (abfd, intern->regoffset,    ext->p_regoffset);
  H_PUT_32      (abfd, intern->iopt,         ext->p_iopt);
  H_PUT_32      (abfd, intern->fregmask,     ext->p_fregmask);
  H_PUT_32      (abfd, intern->fregoffset,   ext->p_fregoffset);
  H_PUT_32      (abfd, intern->frameoffset,  ext->p_frameoffset);
  H_PUT_16      (abfd, intern->framereg,     ext->p_framereg);
  H_PUT_16      (abfd, intern->pcreg,        ext->p_pcreg);
  H_PUT_32      (abfd, intern->lnLow,        ext->p_lnLow);
  H_PUT_32      (abfd, intern->lnHigh,       ext->p_lnHigh);
  ECOFF_PUT_OFF (abfd, intern->cbLineOffset, ext->p_cbLineOffset);
d532 2
a533 7
  intern->iss           = H_GET_32 (abfd, ext->s_iss);
  intern->value         = ECOFF_GET_OFF (abfd, ext->s_value);

#if defined (ECOFF_64) || defined (ECOFF_SIGNED_64)
  if (intern->iss == (signed long) 0xffffffff)
    intern->iss = -1;
#endif  
d535 27
a561 30
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_BIG)
					     >> SYM_BITS1_ST_SH_BIG;
      intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_BIG)
					     << SYM_BITS1_SC_SH_LEFT_BIG)
			  | ((ext->s_bits2[0] & SYM_BITS2_SC_BIG)
					     >> SYM_BITS2_SC_SH_BIG);
      intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_BIG);
      intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_BIG)
					     << SYM_BITS2_INDEX_SH_LEFT_BIG)
			  | (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_BIG)
			  | (ext->s_bits4[0] << SYM_BITS4_INDEX_SH_LEFT_BIG);
    }
  else
    {
      intern->st          =  (ext->s_bits1[0] & SYM_BITS1_ST_LITTLE)
					     >> SYM_BITS1_ST_SH_LITTLE;
      intern->sc          = ((ext->s_bits1[0] & SYM_BITS1_SC_LITTLE)
					     >> SYM_BITS1_SC_SH_LITTLE)
			  | ((ext->s_bits2[0] & SYM_BITS2_SC_LITTLE)
					     << SYM_BITS2_SC_SH_LEFT_LITTLE);
      intern->reserved    = 0 != (ext->s_bits2[0] & SYM_BITS2_RESERVED_LITTLE);
      intern->index       = ((ext->s_bits2[0] & SYM_BITS2_INDEX_LITTLE)
					     >> SYM_BITS2_INDEX_SH_LITTLE)
			  | (ext->s_bits3[0] << SYM_BITS3_INDEX_SH_LEFT_LITTLE)
			  | ((unsigned int) ext->s_bits4[0]
			     << SYM_BITS4_INDEX_SH_LEFT_LITTLE);
    }
d580 1
a580 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d582 2
a583 2
  H_PUT_32 (abfd, intern->iss, ext->s_iss);
  ECOFF_PUT_OFF (abfd, intern->value, ext->s_value);
d585 26
a610 29
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_BIG)
			  & SYM_BITS1_ST_BIG)
			 | ((intern->sc >> SYM_BITS1_SC_SH_LEFT_BIG)
			    & SYM_BITS1_SC_BIG));
      ext->s_bits2[0] = (((intern->sc << SYM_BITS2_SC_SH_BIG)
			  & SYM_BITS2_SC_BIG)
			 | (intern->reserved ? SYM_BITS2_RESERVED_BIG : 0)
			 | ((intern->index >> SYM_BITS2_INDEX_SH_LEFT_BIG)
			    & SYM_BITS2_INDEX_BIG));
      ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_BIG) & 0xff;
      ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_BIG) & 0xff;
    }
  else
    {
      ext->s_bits1[0] = (((intern->st << SYM_BITS1_ST_SH_LITTLE)
			  & SYM_BITS1_ST_LITTLE)
			 | ((intern->sc << SYM_BITS1_SC_SH_LITTLE)
			    & SYM_BITS1_SC_LITTLE));
      ext->s_bits2[0] = (((intern->sc >> SYM_BITS2_SC_SH_LEFT_LITTLE)
			  & SYM_BITS2_SC_LITTLE)
			 | (intern->reserved ? SYM_BITS2_RESERVED_LITTLE : 0)
			 | ((intern->index << SYM_BITS2_INDEX_SH_LITTLE)
			    & SYM_BITS2_INDEX_LITTLE));
      ext->s_bits3[0] = (intern->index >> SYM_BITS3_INDEX_SH_LEFT_LITTLE) & 0xff;
      ext->s_bits4[0] = (intern->index >> SYM_BITS4_INDEX_SH_LEFT_LITTLE) & 0xff;
    }
d630 10
a639 13
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_BIG);
      intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_BIG);
      intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_BIG);
    }
  else
    {
      intern->jmptbl      = 0 != (ext->es_bits1[0] & EXT_BITS1_JMPTBL_LITTLE);
      intern->cobol_main  = 0 != (ext->es_bits1[0] & EXT_BITS1_COBOL_MAIN_LITTLE);
      intern->weakext     = 0 != (ext->es_bits1[0] & EXT_BITS1_WEAKEXT_LITTLE);
    }
d643 1
a643 1
  intern->ifd = H_GET_S16 (abfd, ext->es_ifd);
d646 1
a646 1
  intern->ifd = H_GET_S32 (abfd, ext->es_ifd);
d668 1
a668 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d670 6
a675 7
  /* Now the fun stuff...  */
  if (bfd_header_big_endian (abfd))
    {
      ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_BIG : 0)
			  | (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_BIG : 0)
			  | (intern->weakext ? EXT_BITS1_WEAKEXT_BIG : 0));
      ext->es_bits2[0] = 0;
d677 2
a678 2
      ext->es_bits2[1] = 0;
      ext->es_bits2[2] = 0;
d680 5
a684 7
    }
  else
    {
      ext->es_bits1[0] = ((intern->jmptbl ? EXT_BITS1_JMPTBL_LITTLE : 0)
			  | (intern->cobol_main ? EXT_BITS1_COBOL_MAIN_LITTLE : 0)
			  | (intern->weakext ? EXT_BITS1_WEAKEXT_LITTLE : 0));
      ext->es_bits2[0] = 0;
d686 2
a687 2
      ext->es_bits2[1] = 0;
      ext->es_bits2[2] = 0;
d689 1
a689 1
    }
d692 1
a692 1
  H_PUT_S16 (abfd, intern->ifd, ext->es_ifd);
d695 1
a695 1
  H_PUT_S32 (abfd, intern->ifd, ext->es_ifd);
d716 1
a716 1
  *intern = H_GET_32 (abfd, ext->rfd);
d734 1
a734 1
  H_PUT_32 (abfd, *intern, ext->rfd);
d775 1
a775 1
  intern->offset = H_GET_32 (abfd, ext->o_offset);
d794 1
a794 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d814 1
a814 1
  H_PUT_32 (abfd, intern->value, ext->o_offset);
d834 2
a835 2
  intern->rfd = H_GET_32 (abfd, ext->d_rfd);
  intern->index = H_GET_32 (abfd, ext->d_index);
d854 1
a854 2
  /* Make it reasonable to do in-place.  */
  *intern = *intern_copy;
d856 2
a857 2
  H_PUT_32 (abfd, intern->rfd, ext->d_rfd);
  H_PUT_32 (abfd, intern->index, ext->d_index);
@

