head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.20.46.25;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.20.59.56;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.38.52;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.38.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.25.47;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.40.22;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.03.48;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.05.37;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* BFD back-end for raw ARM a.out binaries.
   Copyright 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
   Contributed by Richard Earnshaw (rwe@@pegasus.esprit.ec.org)

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"

/* Avoid multiple defininitions from aoutx if supporting standarad a.out
   as well as our own.  */
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define NAME(x,y) CONCAT3 (aoutarm,_32_,y)

#define N_TXTADDR(x)						\
  ((N_MAGIC (x) == NMAGIC)					\
   ? (bfd_vma) 0x8000						\
   : ((N_MAGIC (x) != ZMAGIC)					\
      ? (bfd_vma) 0						\
      : ((N_SHARED_LIB (x))					\
	 ? ((x).a_entry & ~(bfd_vma) (TARGET_PAGE_SIZE - 1))	\
	 : (bfd_vma) TEXT_START_ADDR)))

#define TEXT_START_ADDR 0x8000
#define TARGET_PAGE_SIZE 0x8000
#define SEGMENT_SIZE TARGET_PAGE_SIZE
#define DEFAULT_ARCH bfd_arch_arm

#define MY(OP) CONCAT2 (aoutarm_,OP)
#define N_BADMAG(x) ((((x).a_info & ~007200) != ZMAGIC) && \
                     (((x).a_info & ~006000) != OMAGIC) && \
                     ((x).a_info != NMAGIC))
#define N_MAGIC(x) ((x).a_info & ~07200)

#define MY_bfd_reloc_type_lookup aoutarm_bfd_reloc_type_lookup

#include "libaout.h"
#include "aout/aout64.h"

static bfd_boolean MY(write_object_contents)
  PARAMS ((bfd *));
static bfd_reloc_status_type MY(fix_pcrel_26_done)
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type MY(fix_pcrel_26)
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void MY(swap_std_reloc_in)
  PARAMS ((bfd *, struct reloc_std_external *, arelent *, asymbol **,
	   bfd_size_type));
reloc_howto_type *MY(bfd_reloc_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));
reloc_howto_type * MY(reloc_howto)
  PARAMS ((bfd *, struct reloc_std_external *, int *, int *, int *));
void MY(put_reloc)
  PARAMS ((bfd *, int, int, bfd_vma, reloc_howto_type *,
	   struct reloc_std_external *));
void MY(relocatable_reloc)
  PARAMS ((reloc_howto_type *, bfd *, struct reloc_std_external *, bfd_vma *,
	   bfd_vma));
void MY(swap_std_reloc_out)
  PARAMS ((bfd *, arelent *, struct reloc_std_external *));

reloc_howto_type MY(howto_table)[] =
  {
    /* Type rs size bsz pcrel bitpos ovrf sf name part_inpl
       readmask setmask pcdone.  */
    HOWTO (0, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, 0, "8", TRUE,
	   0x000000ff, 0x000000ff, FALSE),
    HOWTO (1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, 0, "16", TRUE,
	   0x0000ffff, 0x0000ffff, FALSE),
    HOWTO (2, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "32", TRUE,
	   0xffffffff, 0xffffffff, FALSE),
    HOWTO (3, 2, 2, 26, TRUE, 0, complain_overflow_signed, MY(fix_pcrel_26),
	   "ARM26", TRUE, 0x00ffffff, 0x00ffffff, TRUE),
    HOWTO (4, 0, 0, 8, TRUE, 0, complain_overflow_signed, 0, "DISP8", TRUE,
	   0x000000ff, 0x000000ff, TRUE),
    HOWTO (5, 0, 1, 16, TRUE, 0, complain_overflow_signed, 0, "DISP16", TRUE,
	   0x0000ffff, 0x0000ffff, TRUE),
    HOWTO (6, 0, 2, 32, TRUE, 0, complain_overflow_signed, 0, "DISP32", TRUE,
	   0xffffffff, 0xffffffff, TRUE),
    HOWTO (7, 2, 2, 26, FALSE, 0, complain_overflow_signed,
	   MY(fix_pcrel_26_done), "ARM26D", TRUE, 0x0, 0x0,
	   FALSE),
    EMPTY_HOWTO (-1),
    HOWTO (9, 0, -1, 16, FALSE, 0, complain_overflow_bitfield, 0, "NEG16", TRUE,
	   0x0000ffff, 0x0000ffff, FALSE),
    HOWTO (10, 0, -2, 32, FALSE, 0, complain_overflow_bitfield, 0, "NEG32", TRUE,
	   0xffffffff, 0xffffffff, FALSE)
  };

#define RELOC_ARM_BITS_NEG_BIG      ((unsigned int) 0x08)
#define RELOC_ARM_BITS_NEG_LITTLE   ((unsigned int) 0x10)

reloc_howto_type *
MY(reloc_howto) (abfd, rel, r_index, r_extern, r_pcrel)
     bfd *abfd;
     struct reloc_std_external *rel;
     int *r_index;
     int *r_extern;
     int *r_pcrel;
{
  unsigned int r_length;
  unsigned int r_pcrel_done;
  unsigned int r_neg;
  int index;

  *r_pcrel = 0;
  if (bfd_header_big_endian (abfd))
    {
      *r_index     =  ((rel->r_index[0] << 16)
		       | (rel->r_index[1] << 8)
		       | rel->r_index[2]);
      *r_extern    = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
      r_pcrel_done = (0 != (rel->r_type[0] & RELOC_STD_BITS_PCREL_BIG));
      r_neg 	   = (0 != (rel->r_type[0] & RELOC_ARM_BITS_NEG_BIG));
      r_length     = ((rel->r_type[0] & RELOC_STD_BITS_LENGTH_BIG)
		      >> RELOC_STD_BITS_LENGTH_SH_BIG);
    }
  else
    {
      *r_index     = ((rel->r_index[2] << 16)
		      | (rel->r_index[1] << 8)
		      | rel->r_index[0]);
      *r_extern    = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_LITTLE));
      r_pcrel_done = (0 != (rel->r_type[0] & RELOC_STD_BITS_PCREL_LITTLE));
      r_neg 	   = (0 != (rel->r_type[0] & RELOC_ARM_BITS_NEG_LITTLE));
      r_length     = ((rel->r_type[0] & RELOC_STD_BITS_LENGTH_LITTLE)
		      >> RELOC_STD_BITS_LENGTH_SH_LITTLE);
    }
  index = r_length + 4 * r_pcrel_done + 8 * r_neg;
  if (index == 3)
    *r_pcrel = 1;

  return MY(howto_table) + index;
}

#define MY_reloc_howto(BFD, REL, IN, EX, PC) \
	MY(reloc_howto) (BFD, REL, &IN, &EX, &PC)

void
MY(put_reloc) (abfd, r_extern, r_index, value, howto, reloc)
     bfd *abfd;
     int r_extern;
     int r_index;
     bfd_vma value;
     reloc_howto_type *howto;
     struct reloc_std_external *reloc;
{
  unsigned int r_length;
  int r_pcrel;
  int r_neg;

  PUT_WORD (abfd, value, reloc->r_address);
  /* Size as a power of two.  */
  r_length = howto->size;

  /* Special case for branch relocations.  */
  if (howto->type == 3 || howto->type == 7)
    r_length = 3;

  r_pcrel  = howto->type & 4; 	/* PC Relative done?  */
  r_neg = howto->type & 8;	/* Negative relocation.  */

  if (bfd_header_big_endian (abfd))
    {
      reloc->r_index[0] = r_index >> 16;
      reloc->r_index[1] = r_index >> 8;
      reloc->r_index[2] = r_index;
      reloc->r_type[0] =
	((r_extern ?     RELOC_STD_BITS_EXTERN_BIG : 0)
	 | (r_pcrel ?    RELOC_STD_BITS_PCREL_BIG : 0)
	 | (r_neg ?	 RELOC_ARM_BITS_NEG_BIG : 0)
	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_BIG));
    }
  else
    {
      reloc->r_index[2] = r_index >> 16;
      reloc->r_index[1] = r_index >> 8;
      reloc->r_index[0] = r_index;
      reloc->r_type[0] =
	((r_extern ?     RELOC_STD_BITS_EXTERN_LITTLE : 0)
	 | (r_pcrel ?    RELOC_STD_BITS_PCREL_LITTLE : 0)
	 | (r_neg ?	 RELOC_ARM_BITS_NEG_LITTLE : 0)
	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_LITTLE));
    }
}

#define MY_put_reloc(BFD, EXT, IDX, VAL, HOWTO, RELOC) \
  MY(put_reloc) (BFD, EXT, IDX, VAL, HOWTO, RELOC)

void
MY(relocatable_reloc) (howto, abfd, reloc, amount, r_addr)
     reloc_howto_type *howto;
     bfd *abfd;
     struct reloc_std_external *reloc;
     bfd_vma *amount;
     bfd_vma r_addr;
{
  if (howto->type == 3)
    {
      if (reloc->r_type[0]
	  & (bfd_header_big_endian (abfd)
	     ? RELOC_STD_BITS_EXTERN_BIG : RELOC_STD_BITS_EXTERN_LITTLE))
	{
	  /* The reloc is still external, so don't modify anything.  */
	  *amount = 0;
	}
      else
	{
	  *amount -= r_addr;
	  /* Change the r_pcrel value -- on the ARM, this bit is set once the
	     relocation is done.  */
	  if (bfd_header_big_endian (abfd))
	    reloc->r_type[0] |= RELOC_STD_BITS_PCREL_BIG;
	  else
	    reloc->r_type[0] |= RELOC_STD_BITS_PCREL_LITTLE;
	}
    }
  else if (howto->type == 7)
    *amount = 0;
}

#define MY_relocatable_reloc(HOW, BFD, REL, AMOUNT, ADDR) \
  MY(relocatable_reloc) (HOW, BFD, REL, &(AMOUNT), ADDR)

static bfd_reloc_status_type
MY(fix_pcrel_26_done) (abfd, reloc_entry, symbol, data, input_section,
		       output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     char **error_message ATTRIBUTE_UNUSED;
{
  /* This is dead simple at present.  */
  return bfd_reloc_ok;
}

static bfd_reloc_status_type
MY(fix_pcrel_26) (abfd, reloc_entry, symbol, data, input_section,
		  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_vma relocation;
  bfd_size_type addr = reloc_entry->address;
  bfd_vma target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
  bfd_reloc_status_type flag = bfd_reloc_ok;

  /* If this is an undefined symbol, return error.  */
  if (symbol->section == &bfd_und_section
      && (symbol->flags & BSF_WEAK) == 0)
    return output_bfd ? bfd_reloc_ok : bfd_reloc_undefined;

  /* If the sections are different, and we are doing a partial relocation,
     just ignore it for now.  */
  if (symbol->section->name != input_section->name
      && output_bfd != (bfd *)NULL)
    return bfd_reloc_ok;

  relocation = (target & 0x00ffffff) << 2;
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend.  */
  relocation += symbol->value;
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
  relocation -= input_section->output_section->vma;
  relocation -= input_section->output_offset;
  relocation -= addr;
  if (relocation & 3)
    return bfd_reloc_overflow;

  /* Check for overflow.  */
  if (relocation & 0x02000000)
    {
      if ((relocation & ~ (bfd_vma) 0x03ffffff) != ~ (bfd_vma) 0x03ffffff)
	flag = bfd_reloc_overflow;
    }
  else if (relocation & ~ (bfd_vma) 0x03ffffff)
    flag = bfd_reloc_overflow;

  target &= ~ (bfd_vma) 0x00ffffff;
  target |= (relocation >> 2) & 0x00ffffff;
  bfd_put_32 (abfd, target, (bfd_byte *) data + addr);

  /* Now the ARM magic... Change the reloc type so that it is marked as done.
     Strictly this is only necessary if we are doing a partial relocation.  */
  reloc_entry->howto = &MY(howto_table)[7];

  return flag;
}

reloc_howto_type *
MY(bfd_reloc_type_lookup) (abfd,code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
{
#define ASTD(i,j)       case i: return &MY(howto_table)[j]
  if (code == BFD_RELOC_CTOR)
    switch (bfd_get_arch_info (abfd)->bits_per_address)
      {
      case 32:
        code = BFD_RELOC_32;
        break;
      default:
	return (const struct reloc_howto_struct *) 0;
      }

  switch (code)
    {
      ASTD (BFD_RELOC_16, 1);
      ASTD (BFD_RELOC_32, 2);
      ASTD (BFD_RELOC_ARM_PCREL_BRANCH, 3);
      ASTD (BFD_RELOC_8_PCREL, 4);
      ASTD (BFD_RELOC_16_PCREL, 5);
      ASTD (BFD_RELOC_32_PCREL, 6);
    default:
      return (const struct reloc_howto_struct *) 0;
    }
}

#define MY_swap_std_reloc_in MY(swap_std_reloc_in)
#define MY_swap_std_reloc_out MY(swap_std_reloc_out)
#define MY_get_section_contents _bfd_generic_get_section_contents
/* #define MY_bfd_link_hash_table_create _bfd_generic_link_hash_table_create */
/* #define MY_bfd_link_add_symbols _bfd_generic_link_add_symbols */
/* #define MY_bfd_final_link _bfd_generic_final_link */

#include "aoutx.h"

static void
MY_swap_std_reloc_in (abfd, bytes, cache_ptr, symbols, symcount)
     bfd *abfd;
     struct reloc_std_external *bytes;
     arelent *cache_ptr;
     asymbol **symbols;
     bfd_size_type symcount ATTRIBUTE_UNUSED;
{
  int r_index;
  int r_extern;
  int r_pcrel;
  struct aoutdata *su = &(abfd->tdata.aout_data->a);

  cache_ptr->address = H_GET_32 (abfd, bytes->r_address);

  cache_ptr->howto = MY_reloc_howto (abfd, bytes, r_index, r_extern, r_pcrel);

  MOVE_ADDRESS (0);
}

void
MY_swap_std_reloc_out (abfd, g, natptr)
     bfd *abfd;
     arelent *g;
     struct reloc_std_external *natptr;
{
  int r_index;
  asymbol *sym = *(g->sym_ptr_ptr);
  int r_extern;
  int r_length;
  int r_pcrel;
  int r_neg = 0;	/* Negative relocs use the BASEREL bit.  */
  asection *output_section = sym->section->output_section;

  PUT_WORD(abfd, g->address, natptr->r_address);

  r_length = g->howto->size ;   /* Size as a power of two */
  if (r_length < 0)
    {
      r_length = -r_length;
      r_neg = 1;
    }

  r_pcrel  = (int) g->howto->pc_relative; /* Relative to PC? */

  /* For RISC iX, in pc-relative relocs the r_pcrel bit means that the
     relocation has been done already (Only for the 26-bit one I think)???!!!
     */

  if (g->howto->type == 3)
    {
      r_length = 3;
      r_pcrel = 0;
    }
  else if (g->howto->type == 7)
    {
      r_length = 3;
      r_pcrel = 1;
    }

#if 0
  /* For a standard reloc, the addend is in the object file.  */
  r_addend = g->addend + (*(g->sym_ptr_ptr))->section->output_section->vma;
#endif

  /* name was clobbered by aout_write_syms to be symbol index */

  /* If this relocation is relative to a symbol then set the
     r_index to the symbols index, and the r_extern bit.

     Absolute symbols can come in in two ways, either as an offset
     from the abs section, or as a symbol which has an abs value.
     check for that here
     */

  if (bfd_is_com_section (output_section)
      || output_section == &bfd_abs_section
      || output_section == &bfd_und_section)
    {
      if (bfd_abs_section.symbol == sym)
	{
	  /* Whoops, looked like an abs symbol, but is really an offset
	     from the abs section.  */
	  r_index = 0;
	  r_extern = 0;
	}
      else
	{
	  /* Fill in symbol.  */
	  r_extern = 1;
	  r_index = (*(g->sym_ptr_ptr))->KEEPIT;
	}
    }
  else
    {
      /* Just an ordinary section.  */
      r_extern = 0;
      r_index  = output_section->target_index;
    }

  /* Now the fun stuff.  */
  if (bfd_header_big_endian (abfd))
    {
      natptr->r_index[0] = r_index >> 16;
      natptr->r_index[1] = r_index >> 8;
      natptr->r_index[2] = r_index;
      natptr->r_type[0] =
	(  (r_extern ?   RELOC_STD_BITS_EXTERN_BIG: 0)
	 | (r_pcrel  ?   RELOC_STD_BITS_PCREL_BIG: 0)
	 | (r_neg    ?   RELOC_ARM_BITS_NEG_BIG: 0)
	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_BIG));
    }
  else
    {
      natptr->r_index[2] = r_index >> 16;
      natptr->r_index[1] = r_index >> 8;
      natptr->r_index[0] = r_index;
      natptr->r_type[0] =
	(  (r_extern ?   RELOC_STD_BITS_EXTERN_LITTLE: 0)
	 | (r_pcrel  ?   RELOC_STD_BITS_PCREL_LITTLE: 0)
	 | (r_neg    ?   RELOC_ARM_BITS_NEG_LITTLE: 0)
	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_LITTLE));
    }
}

#define MY_BFD_TARGET

#include "aout-target.h"

extern const bfd_target aout_arm_big_vec;

const bfd_target aout_arm_little_vec =
  {
    "a.out-arm-little",           /* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_LITTLE,            /* target byte order (little) */
    BFD_ENDIAN_LITTLE,            /* target headers byte order (little) */
    (HAS_RELOC | EXEC_P |         /* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    AR_PAD_CHAR,                  /* ar_pad_char */
    15,                           /* ar_max_namelen */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16,	/* data */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16,	/* hdrs */
    {_bfd_dummy_target, MY_object_p,		/* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,			/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (MY),

    & aout_arm_big_vec,

    (PTR) MY_backend_data,
  };

const bfd_target aout_arm_big_vec =
  {
    "a.out-arm-big",              /* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_BIG,               /* target byte order (big) */
    BFD_ENDIAN_BIG,               /* target headers byte order (big) */
    (HAS_RELOC | EXEC_P |         /* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    AR_PAD_CHAR,                  		/* ar_pad_char */
    15,                           		/* ar_max_namelen */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
    {_bfd_dummy_target, MY_object_p,		/* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,			/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (MY),

    & aout_arm_little_vec,

    (PTR) MY_backend_data,
  };
@


1.2
log
@looks as if some sour wine (Federweißer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 1999, 2000
d22 18
a39 5
#define N_TXTADDR(x) \
  ((N_MAGIC(x) == NMAGIC) ? 0x8000 : \
   (N_MAGIC(x) != ZMAGIC) ? 0 : \
   (N_SHARED_LIB(x)) ? ((x).a_entry & ~(TARGET_PAGE_SIZE - 1)) : \
   TEXT_START_ADDR)
d46 1
a46 1
#define MY(OP) CAT(aoutarm_,OP)
a51 12
#include "bfd.h"
#include "sysdep.h"

#define MYARM(OP) CAT(aoutarm_,OP)
reloc_howto_type 	*MYARM(bfd_reloc_type_lookup)
				PARAMS((bfd *, bfd_reloc_code_real_type));
static boolean 		MYARM(write_object_contents)	PARAMS((bfd *));

/* Avoid multiple defininitions from aoutx if supporting standarad a.out
   as well as our own.  */
#define NAME(x,y) CAT3(aoutarm,_32_,y)

d57 22
a78 13
static bfd_reloc_status_type
MY(fix_pcrel_26_done)	PARAMS ((bfd *, arelent *, asymbol *, PTR,
				 asection *, bfd *, char **));

static bfd_reloc_status_type
MY(fix_pcrel_26)	 PARAMS ((bfd *, arelent *, asymbol *, PTR,
				  asection *, bfd *, char **));
static void MY(swap_std_reloc_in) PARAMS ((bfd *, struct reloc_std_external *,
					   arelent *, asymbol **,
					   bfd_size_type));
void MY(swap_std_reloc_out) PARAMS ((bfd *, arelent *,
				     struct reloc_std_external *));

d80 26
a105 26
{
  /* type rs size bsz pcrel bitpos ovrf sf name part_inpl readmask setmask
     pcdone */
  HOWTO (0, 0, 0, 8, false, 0, complain_overflow_bitfield, 0, "8", true,
	 0x000000ff, 0x000000ff, false),
  HOWTO (1, 0, 1, 16, false, 0, complain_overflow_bitfield, 0, "16", true,
	 0x0000ffff, 0x0000ffff, false),
  HOWTO (2, 0, 2, 32, false, 0, complain_overflow_bitfield, 0, "32", true,
	 0xffffffff, 0xffffffff, false),
  HOWTO (3, 2, 2, 26, true, 0, complain_overflow_signed, MY(fix_pcrel_26),
	 "ARM26", true, 0x00ffffff, 0x00ffffff, true),
  HOWTO (4, 0, 0, 8, true, 0, complain_overflow_signed, 0, "DISP8", true,
	 0x000000ff, 0x000000ff, true),
  HOWTO (5, 0, 1, 16, true, 0, complain_overflow_signed, 0, "DISP16", true,
	 0x0000ffff, 0x0000ffff, true),
  HOWTO (6, 0, 2, 32, true, 0, complain_overflow_signed, 0, "DISP32", true,
	 0xffffffff, 0xffffffff, true),
  HOWTO (7, 2, 2, 26, false, 0, complain_overflow_signed,
	 MY(fix_pcrel_26_done), "ARM26D", true, 0x0, 0x0,
	 false),
  EMPTY_HOWTO (-1),
  HOWTO (9, 0, -1, 16, false, 0, complain_overflow_bitfield, 0, "NEG16", true,
	 0x0000ffff, 0x0000ffff, false),
  HOWTO (10, 0, -2, 32, false, 0, complain_overflow_bitfield, 0, "NEG32", true,
	 0xffffffff, 0xffffffff, false)
};
d161 1
a161 1
     long value;
d170 2
a171 1
  r_length = howto->size ;	/* Size as a power of two */
d177 3
a179 2
  r_pcrel  = howto->type & 4; 	/* PC Relative done? */
  r_neg = howto->type & 8;	/* Negative relocation */
d270 1
a270 1
  long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
d273 1
a273 1
  /* If this is an undefined symbol, return error */
d285 1
a285 1
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend */
d296 1
a296 1
  /* Check for overflow */
d302 1
a302 1
  else if (relocation & ~0x03ffffff)
d305 1
a305 1
  target &= ~0x00ffffff;
d328 2
a329 1
      default: return (CONST struct reloc_howto_struct *) 0;
d340 2
a341 1
    default: return (CONST struct reloc_howto_struct *) 0;
d367 1
a367 1
  cache_ptr->address = bfd_h_get_32 (abfd, bytes->r_address);
d436 1
a436 1
	     from the abs section */
d442 1
a442 1
	  /* Fill in symbol */
d449 1
a449 1
      /* Just an ordinary section */
d454 1
a454 1
  /* now the fun stuff */
d486 34
a519 34
{
  "a.out-arm-little",           /* name */
  bfd_target_aout_flavour,
  BFD_ENDIAN_LITTLE,            /* target byte order (little) */
  BFD_ENDIAN_LITTLE,            /* target headers byte order (little) */
  (HAS_RELOC | EXEC_P |         /* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
  MY_symbol_leading_char,
  AR_PAD_CHAR,                  /* ar_pad_char */
  15,                           /* ar_max_namelen */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */
    {_bfd_dummy_target, MY_object_p, /* bfd_check_format */
       bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,    /* bfd_set_format */
       _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents, /* bfd_write_contents */
       _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (MY),
     BFD_JUMP_TABLE_COPY (MY),
     BFD_JUMP_TABLE_CORE (MY),
     BFD_JUMP_TABLE_ARCHIVE (MY),
     BFD_JUMP_TABLE_SYMBOLS (MY),
     BFD_JUMP_TABLE_RELOCS (MY),
     BFD_JUMP_TABLE_WRITE (MY),
     BFD_JUMP_TABLE_LINK (MY),
     BFD_JUMP_TABLE_DYNAMIC (MY),
d521 1
a521 1
  & aout_arm_big_vec,
d523 2
a524 2
  (PTR) MY_backend_data,
};
d527 34
a560 34
{
  "a.out-arm-big",           /* name */
  bfd_target_aout_flavour,
  BFD_ENDIAN_BIG,               /* target byte order (big) */
  BFD_ENDIAN_BIG,               /* target headers byte order (big) */
  (HAS_RELOC | EXEC_P |         /* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
  MY_symbol_leading_char,
  AR_PAD_CHAR,                  /* ar_pad_char */
  15,                           /* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */
    {_bfd_dummy_target, MY_object_p, /* bfd_check_format */
       bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,    /* bfd_set_format */
       _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents, /* bfd_write_contents */
       _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (MY),
     BFD_JUMP_TABLE_COPY (MY),
     BFD_JUMP_TABLE_CORE (MY),
     BFD_JUMP_TABLE_ARCHIVE (MY),
     BFD_JUMP_TABLE_SYMBOLS (MY),
     BFD_JUMP_TABLE_RELOCS (MY),
     BFD_JUMP_TABLE_WRITE (MY),
     BFD_JUMP_TABLE_LINK (MY),
     BFD_JUMP_TABLE_DYNAMIC (MY),
d562 1
a562 1
  & aout_arm_little_vec,
d564 2
a565 2
  (PTR) MY_backend_data,
};
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002
d22 5
a26 18
#include "bfd.h"
#include "sysdep.h"

/* Avoid multiple defininitions from aoutx if supporting standarad a.out
   as well as our own.  */
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define NAME(x,y) CONCAT3 (aoutarm,_32_,y)

#define N_TXTADDR(x)						\
  ((N_MAGIC (x) == NMAGIC)					\
   ? (bfd_vma) 0x8000						\
   : ((N_MAGIC (x) != ZMAGIC)					\
      ? (bfd_vma) 0						\
      : ((N_SHARED_LIB (x))					\
	 ? ((x).a_entry & ~(bfd_vma) (TARGET_PAGE_SIZE - 1))	\
	 : (bfd_vma) TEXT_START_ADDR)))
d33 1
a33 1
#define MY(OP) CONCAT2 (aoutarm_,OP)
d39 12
d56 13
a68 22
static bfd_boolean MY(write_object_contents)
  PARAMS ((bfd *));
static bfd_reloc_status_type MY(fix_pcrel_26_done)
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type MY(fix_pcrel_26)
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void MY(swap_std_reloc_in)
  PARAMS ((bfd *, struct reloc_std_external *, arelent *, asymbol **,
	   bfd_size_type));
reloc_howto_type *MY(bfd_reloc_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));
reloc_howto_type * MY(reloc_howto)
  PARAMS ((bfd *, struct reloc_std_external *, int *, int *, int *));
void MY(put_reloc)
  PARAMS ((bfd *, int, int, bfd_vma, reloc_howto_type *,
	   struct reloc_std_external *));
void MY(relocatable_reloc)
  PARAMS ((reloc_howto_type *, bfd *, struct reloc_std_external *, bfd_vma *,
	   bfd_vma));
void MY(swap_std_reloc_out)
  PARAMS ((bfd *, arelent *, struct reloc_std_external *));

d70 26
a95 26
  {
    /* Type rs size bsz pcrel bitpos ovrf sf name part_inpl
       readmask setmask pcdone.  */
    HOWTO (0, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, 0, "8", TRUE,
	   0x000000ff, 0x000000ff, FALSE),
    HOWTO (1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, 0, "16", TRUE,
	   0x0000ffff, 0x0000ffff, FALSE),
    HOWTO (2, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "32", TRUE,
	   0xffffffff, 0xffffffff, FALSE),
    HOWTO (3, 2, 2, 26, TRUE, 0, complain_overflow_signed, MY(fix_pcrel_26),
	   "ARM26", TRUE, 0x00ffffff, 0x00ffffff, TRUE),
    HOWTO (4, 0, 0, 8, TRUE, 0, complain_overflow_signed, 0, "DISP8", TRUE,
	   0x000000ff, 0x000000ff, TRUE),
    HOWTO (5, 0, 1, 16, TRUE, 0, complain_overflow_signed, 0, "DISP16", TRUE,
	   0x0000ffff, 0x0000ffff, TRUE),
    HOWTO (6, 0, 2, 32, TRUE, 0, complain_overflow_signed, 0, "DISP32", TRUE,
	   0xffffffff, 0xffffffff, TRUE),
    HOWTO (7, 2, 2, 26, FALSE, 0, complain_overflow_signed,
	   MY(fix_pcrel_26_done), "ARM26D", TRUE, 0x0, 0x0,
	   FALSE),
    EMPTY_HOWTO (-1),
    HOWTO (9, 0, -1, 16, FALSE, 0, complain_overflow_bitfield, 0, "NEG16", TRUE,
	   0x0000ffff, 0x0000ffff, FALSE),
    HOWTO (10, 0, -2, 32, FALSE, 0, complain_overflow_bitfield, 0, "NEG32", TRUE,
	   0xffffffff, 0xffffffff, FALSE)
  };
d151 1
a151 1
     bfd_vma value;
d160 1
a160 2
  /* Size as a power of two.  */
  r_length = howto->size;
d166 2
a167 3
  r_pcrel  = howto->type & 4; 	/* PC Relative done?  */
  r_neg = howto->type & 8;	/* Negative relocation.  */

d258 1
a258 1
  bfd_vma target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
d261 1
a261 1
  /* If this is an undefined symbol, return error.  */
d273 1
a273 1
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend.  */
d284 1
a284 1
  /* Check for overflow.  */
d290 1
a290 1
  else if (relocation & ~ (bfd_vma) 0x03ffffff)
d293 1
a293 1
  target &= ~ (bfd_vma) 0x00ffffff;
d316 1
a316 2
      default:
	return (const struct reloc_howto_struct *) 0;
d327 1
a327 2
    default:
      return (const struct reloc_howto_struct *) 0;
d353 1
a353 1
  cache_ptr->address = H_GET_32 (abfd, bytes->r_address);
d422 1
a422 1
	     from the abs section.  */
d428 1
a428 1
	  /* Fill in symbol.  */
d435 1
a435 1
      /* Just an ordinary section.  */
d440 1
a440 1
  /* Now the fun stuff.  */
d472 34
a505 34
  {
    "a.out-arm-little",           /* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_LITTLE,            /* target byte order (little) */
    BFD_ENDIAN_LITTLE,            /* target headers byte order (little) */
    (HAS_RELOC | EXEC_P |         /* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    AR_PAD_CHAR,                  /* ar_pad_char */
    15,                           /* ar_max_namelen */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16,	/* data */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16,	/* hdrs */
    {_bfd_dummy_target, MY_object_p,		/* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,			/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (MY),
d507 1
a507 1
    & aout_arm_big_vec,
d509 2
a510 2
    (PTR) MY_backend_data,
  };
d513 34
a546 34
  {
    "a.out-arm-big",              /* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_BIG,               /* target byte order (big) */
    BFD_ENDIAN_BIG,               /* target headers byte order (big) */
    (HAS_RELOC | EXEC_P |         /* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    AR_PAD_CHAR,                  		/* ar_pad_char */
    15,                           		/* ar_max_namelen */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
    {_bfd_dummy_target, MY_object_p,		/* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,			/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (MY),
d548 1
a548 1
    & aout_arm_little_vec,
d550 2
a551 2
    (PTR) MY_backend_data,
  };
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d25 1
a25 1
/* Avoid multiple definitions from aoutx if supporting standard a.out
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002
d22 5
a26 18
#include "bfd.h"
#include "sysdep.h"

/* Avoid multiple defininitions from aoutx if supporting standarad a.out
   as well as our own.  */
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define NAME(x,y) CONCAT3 (aoutarm,_32_,y)

#define N_TXTADDR(x)						\
  ((N_MAGIC (x) == NMAGIC)					\
   ? (bfd_vma) 0x8000						\
   : ((N_MAGIC (x) != ZMAGIC)					\
      ? (bfd_vma) 0						\
      : ((N_SHARED_LIB (x))					\
	 ? ((x).a_entry & ~(bfd_vma) (TARGET_PAGE_SIZE - 1))	\
	 : (bfd_vma) TEXT_START_ADDR)))
d33 1
a33 1
#define MY(OP) CONCAT2 (aoutarm_,OP)
d39 12
d56 13
a68 22
static bfd_boolean MY(write_object_contents)
  PARAMS ((bfd *));
static bfd_reloc_status_type MY(fix_pcrel_26_done)
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type MY(fix_pcrel_26)
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void MY(swap_std_reloc_in)
  PARAMS ((bfd *, struct reloc_std_external *, arelent *, asymbol **,
	   bfd_size_type));
reloc_howto_type *MY(bfd_reloc_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));
reloc_howto_type * MY(reloc_howto)
  PARAMS ((bfd *, struct reloc_std_external *, int *, int *, int *));
void MY(put_reloc)
  PARAMS ((bfd *, int, int, bfd_vma, reloc_howto_type *,
	   struct reloc_std_external *));
void MY(relocatable_reloc)
  PARAMS ((reloc_howto_type *, bfd *, struct reloc_std_external *, bfd_vma *,
	   bfd_vma));
void MY(swap_std_reloc_out)
  PARAMS ((bfd *, arelent *, struct reloc_std_external *));

d70 26
a95 26
  {
    /* Type rs size bsz pcrel bitpos ovrf sf name part_inpl
       readmask setmask pcdone.  */
    HOWTO (0, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, 0, "8", TRUE,
	   0x000000ff, 0x000000ff, FALSE),
    HOWTO (1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, 0, "16", TRUE,
	   0x0000ffff, 0x0000ffff, FALSE),
    HOWTO (2, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "32", TRUE,
	   0xffffffff, 0xffffffff, FALSE),
    HOWTO (3, 2, 2, 26, TRUE, 0, complain_overflow_signed, MY(fix_pcrel_26),
	   "ARM26", TRUE, 0x00ffffff, 0x00ffffff, TRUE),
    HOWTO (4, 0, 0, 8, TRUE, 0, complain_overflow_signed, 0, "DISP8", TRUE,
	   0x000000ff, 0x000000ff, TRUE),
    HOWTO (5, 0, 1, 16, TRUE, 0, complain_overflow_signed, 0, "DISP16", TRUE,
	   0x0000ffff, 0x0000ffff, TRUE),
    HOWTO (6, 0, 2, 32, TRUE, 0, complain_overflow_signed, 0, "DISP32", TRUE,
	   0xffffffff, 0xffffffff, TRUE),
    HOWTO (7, 2, 2, 26, FALSE, 0, complain_overflow_signed,
	   MY(fix_pcrel_26_done), "ARM26D", TRUE, 0x0, 0x0,
	   FALSE),
    EMPTY_HOWTO (-1),
    HOWTO (9, 0, -1, 16, FALSE, 0, complain_overflow_bitfield, 0, "NEG16", TRUE,
	   0x0000ffff, 0x0000ffff, FALSE),
    HOWTO (10, 0, -2, 32, FALSE, 0, complain_overflow_bitfield, 0, "NEG32", TRUE,
	   0xffffffff, 0xffffffff, FALSE)
  };
d151 1
a151 1
     bfd_vma value;
d160 1
a160 2
  /* Size as a power of two.  */
  r_length = howto->size;
d166 2
a167 3
  r_pcrel  = howto->type & 4; 	/* PC Relative done?  */
  r_neg = howto->type & 8;	/* Negative relocation.  */

d258 1
a258 1
  bfd_vma target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
d261 1
a261 1
  /* If this is an undefined symbol, return error.  */
d273 1
a273 1
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend.  */
d284 1
a284 1
  /* Check for overflow.  */
d290 1
a290 1
  else if (relocation & ~ (bfd_vma) 0x03ffffff)
d293 1
a293 1
  target &= ~ (bfd_vma) 0x00ffffff;
d316 1
a316 2
      default:
	return (const struct reloc_howto_struct *) 0;
d327 1
a327 2
    default:
      return (const struct reloc_howto_struct *) 0;
d353 1
a353 1
  cache_ptr->address = H_GET_32 (abfd, bytes->r_address);
d422 1
a422 1
	     from the abs section.  */
d428 1
a428 1
	  /* Fill in symbol.  */
d435 1
a435 1
      /* Just an ordinary section.  */
d440 1
a440 1
  /* Now the fun stuff.  */
d472 34
a505 34
  {
    "a.out-arm-little",           /* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_LITTLE,            /* target byte order (little) */
    BFD_ENDIAN_LITTLE,            /* target headers byte order (little) */
    (HAS_RELOC | EXEC_P |         /* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    AR_PAD_CHAR,                  /* ar_pad_char */
    15,                           /* ar_max_namelen */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16,	/* data */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16,	/* hdrs */
    {_bfd_dummy_target, MY_object_p,		/* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,			/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (MY),
d507 1
a507 1
    & aout_arm_big_vec,
d509 2
a510 2
    (PTR) MY_backend_data,
  };
d513 34
a546 34
  {
    "a.out-arm-big",              /* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_BIG,               /* target byte order (big) */
    BFD_ENDIAN_BIG,               /* target headers byte order (big) */
    (HAS_RELOC | EXEC_P |         /* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    AR_PAD_CHAR,                  		/* ar_pad_char */
    15,                           		/* ar_max_namelen */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
    {_bfd_dummy_target, MY_object_p,		/* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,			/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (MY),
d548 1
a548 1
    & aout_arm_little_vec,
d550 2
a551 2
    (PTR) MY_backend_data,
  };
@

