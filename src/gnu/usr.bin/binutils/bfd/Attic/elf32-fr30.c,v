head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.20.50.10;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.00.18;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.39.00;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.39.00;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.26.24;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.40.37;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.04.10;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.07.12;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* FR30-specific support for 32-bit ELF.
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/fr30.h"

/* Forward declarations.  */
static bfd_reloc_status_type fr30_elf_i20_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type fr30_elf_i32_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static reloc_howto_type * fr30_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
static void fr30_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean fr30_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_reloc_status_type fr30_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
static bfd_boolean fr30_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static asection * fr30_elf_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean fr30_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));

static reloc_howto_type fr30_elf_howto_table [] =
{
  /* This reloc does nothing.  */
  HOWTO (R_FR30_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FR30_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An 8 bit absolute relocation.  */
  HOWTO (R_FR30_8,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 4,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FR30_8",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000,		/* src_mask */
	 0x0ff0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 20 bit absolute relocation.  */
  HOWTO (R_FR30_20,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 20,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 fr30_elf_i20_reloc,	/* special_function */
	 "R_FR30_20",		/* name */
	 TRUE,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0x00f0ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit absolute relocation.  */
  HOWTO (R_FR30_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FR30_32",		/* name */
	 TRUE,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit into 48 bits absolute relocation.  */
  HOWTO (R_FR30_48,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 fr30_elf_i32_reloc,	/* special_function */
	 "R_FR30_48",		/* name */
	 TRUE,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 6 bit absolute relocation.  */
  HOWTO (R_FR30_6_IN_4,		/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 4,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FR30_6_IN_4",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000,		/* src_mask */
	 0x00f0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An 8 bit absolute relocation.  */
  HOWTO (R_FR30_8_IN_8,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 4,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_FR30_8_IN_8",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000,		/* src_mask */
	 0x0ff0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 9 bit absolute relocation.  */
  HOWTO (R_FR30_9_IN_8,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 9,			/* bitsize */
	 FALSE,			/* pc_relative */
	 4,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_FR30_9_IN_8",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000,		/* src_mask */
	 0x0ff0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 10 bit absolute relocation.  */
  HOWTO (R_FR30_10_IN_8,	/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize */
	 FALSE,			/* pc_relative */
	 4,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,/* special_function */
	 "R_FR30_10_IN_8",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000,		/* src_mask */
	 0x0ff0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A PC relative 9 bit relocation, right shifted by 1.  */
  HOWTO (R_FR30_9_PCREL,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 9,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_FR30_9_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A PC relative 12 bit relocation, right shifted by 1.  */
  HOWTO (R_FR30_12_PCREL,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_FR30_12_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000,		/* src_mask */
	 0x07ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_FR30_GNU_VTINHERIT, /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_FR30_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_FR30_GNU_VTENTRY,     /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_FR30_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
};

/* Utility to actually perform an R_FR30_20 reloc.  */

static bfd_reloc_status_type
fr30_elf_i20_reloc (abfd, reloc_entry, symbol, data,
		    input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_vma relocation;
  unsigned long x;

  /* This part is from bfd_elf_generic_reloc.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    /* FIXME: See bfd_perform_relocation.  Is this right?  */
    return bfd_reloc_ok;

  relocation =
    symbol->value
    + symbol->section->output_section->vma
    + symbol->section->output_offset
    + reloc_entry->addend;

  if (relocation > (((bfd_vma) 1 << 20) - 1))
    return bfd_reloc_overflow;

  x = bfd_get_32 (abfd, (char *) data + reloc_entry->address);
  x = (x & 0xff0f0000) | (relocation & 0x0000ffff) | ((relocation & 0x000f0000) << 4);
  bfd_put_32 (abfd, (bfd_vma) x, (char *) data + reloc_entry->address);

  return bfd_reloc_ok;
}

/* Utility to actually perform a R_FR30_48 reloc.  */

static bfd_reloc_status_type
fr30_elf_i32_reloc (abfd, reloc_entry, symbol, data,
		    input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_vma relocation;

  /* This part is from bfd_elf_generic_reloc.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    /* FIXME: See bfd_perform_relocation.  Is this right?  */
    return bfd_reloc_ok;

  relocation =
    symbol->value
    + symbol->section->output_section->vma
    + symbol->section->output_offset
    + reloc_entry->addend;

  bfd_put_32 (abfd, relocation, (char *) data + reloc_entry->address + 2);

  return bfd_reloc_ok;
}

/* Map BFD reloc types to FR30 ELF reloc types.  */

struct fr30_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned int fr30_reloc_val;
};

static const struct fr30_reloc_map fr30_reloc_map [] =
{
  { BFD_RELOC_NONE,           R_FR30_NONE },
  { BFD_RELOC_8,              R_FR30_8 },
  { BFD_RELOC_FR30_20,        R_FR30_20 },
  { BFD_RELOC_32,             R_FR30_32 },
  { BFD_RELOC_FR30_48,        R_FR30_48 },
  { BFD_RELOC_FR30_6_IN_4,    R_FR30_6_IN_4 },
  { BFD_RELOC_FR30_8_IN_8,    R_FR30_8_IN_8 },
  { BFD_RELOC_FR30_9_IN_8,    R_FR30_9_IN_8 },
  { BFD_RELOC_FR30_10_IN_8,   R_FR30_10_IN_8 },
  { BFD_RELOC_FR30_9_PCREL,   R_FR30_9_PCREL },
  { BFD_RELOC_FR30_12_PCREL,  R_FR30_12_PCREL },
  { BFD_RELOC_VTABLE_INHERIT, R_FR30_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY,   R_FR30_GNU_VTENTRY },
};

static reloc_howto_type *
fr30_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  unsigned int i;

  for (i = sizeof (fr30_reloc_map) / sizeof (fr30_reloc_map[0]);
       --i;)
    if (fr30_reloc_map [i].bfd_reloc_val == code)
      return & fr30_elf_howto_table [fr30_reloc_map[i].fr30_reloc_val];

  return NULL;
}

/* Set the howto pointer for an FR30 ELF reloc.  */

static void
fr30_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_FR30_max);
  cache_ptr->howto = & fr30_elf_howto_table [r_type];
}

/* Perform a single relocation.  By default we use the standard BFD
   routines, but a few relocs, we have to do them ourselves.  */

static bfd_reloc_status_type
fr30_final_link_relocate (howto, input_bfd, input_section, contents, rel,
			  relocation)
     reloc_howto_type *howto;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *rel;
     bfd_vma relocation;
{
  bfd_reloc_status_type r = bfd_reloc_ok;
  bfd_vma x;
  bfd_signed_vma srel;

  switch (howto->type)
    {
    case R_FR30_20:
      contents   += rel->r_offset;
      relocation += rel->r_addend;

      if (relocation > ((1 << 20) - 1))
	return bfd_reloc_overflow;

      x = bfd_get_32 (input_bfd, contents);
      x = (x & 0xff0f0000) | (relocation & 0x0000ffff) | ((relocation & 0x000f0000) << 4);
      bfd_put_32 (input_bfd, x, contents);
      break;

    case R_FR30_48:
      contents   += rel->r_offset + 2;
      relocation += rel->r_addend;
      bfd_put_32 (input_bfd, relocation, contents);
      break;

    case R_FR30_9_PCREL:
      contents   += rel->r_offset + 1;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      srel -= rel->r_offset;
      srel -= 2;  /* Branch instructions add 2 to the PC...  */
      srel -= (input_section->output_section->vma +
		     input_section->output_offset);

      if (srel & 1)
	return bfd_reloc_outofrange;
      if (srel > ((1 << 8) - 1) || (srel < - (1 << 8)))
	return bfd_reloc_overflow;

      bfd_put_8 (input_bfd, srel >> 1, contents);
      break;

    case R_FR30_12_PCREL:
      contents   += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      srel -= rel->r_offset;
      srel -= 2; /* Branch instructions add 2 to the PC...  */
      srel -= (input_section->output_section->vma +
		     input_section->output_offset);

      if (srel & 1)
	return bfd_reloc_outofrange;
      if (srel > ((1 << 11) - 1) || (srel < - (1 << 11)))
	  return bfd_reloc_overflow;

      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf800) | ((srel >> 1) & 0x7ff);
      bfd_put_16 (input_bfd, x, contents);
      break;

    default:
      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, rel->r_addend);
    }

  return r;
}

/* Relocate an FR30 ELF section.

   The RELOCATE_SECTION function is called by the new ELF backend linker
   to handle the relocations for a section.

   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.

   This function is responsible for adjusting the section contents as
   necessary, and (if using Rela relocs and generating a relocateable
   output file) adjusting the reloc addend as necessary.

   This function does not have to worry about setting the reloc
   address or the reloc symbol index.

   LOCAL_SYMS is a pointer to the swapped in local symbols.

   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.

   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).

   When generating relocateable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */

static bfd_boolean
fr30_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  if (info->relocateable)
    return TRUE;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend     = relocs + input_section->reloc_count;

  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char *name = NULL;
      int r_type;

      r_type = ELF32_R_TYPE (rel->r_info);

      if (   r_type == R_FR30_GNU_VTINHERIT
	  || r_type == R_FR30_GNU_VTENTRY)
	continue;

      r_symndx = ELF32_R_SYM (rel->r_info);

      howto  = fr30_elf_howto_table + ELF32_R_TYPE (rel->r_info);
      h      = NULL;
      sym    = NULL;
      sec    = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
#if 0
	  fprintf (stderr, "local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n",
		   sec->name, name, sym->st_name,
		   sec->output_section->vma, sec->output_offset,
		   sym->st_value, rel->r_addend);
#endif
	}
      else
	{
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  name = h->root.root.string;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
#if 0
	      fprintf (stderr,
		       "defined: sec: %s, name: %s, value: %x + %x + %x gives: %x\n",
		       sec->name, name, h->root.u.def.value,
		       sec->output_section->vma, sec->output_offset, relocation);
#endif
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
#if 0
	      fprintf (stderr, "undefined: sec: %s, name: %s\n",
		       sec->name, name);
#endif
	      relocation = 0;
	    }
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
#if 0
	      fprintf (stderr, "unknown: name: %s\n", name);
#endif
	      relocation = 0;
	    }
	}

      r = fr30_final_link_relocate (howto, input_bfd, input_section,
				     contents, rel, relocation);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset,
		 TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
fr30_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym * sym;
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_FR30_GNU_VTINHERIT:
	case R_FR30_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
fr30_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
  return TRUE;
}

/* Look through the relocs for a section during the first phase.
   Since we don't do .gots or .plts, we just need to consider the
   virtual table relocs for gc.  */

static bfd_boolean
fr30_elf_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;

  if (info->relocateable)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof (Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];

      switch (ELF32_R_TYPE (rel->r_info))
        {
        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_FR30_GNU_VTINHERIT:
          if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
        case R_FR30_GNU_VTENTRY:
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;
        }
    }

  return TRUE;
}

#define ELF_ARCH		bfd_arch_fr30
#define ELF_MACHINE_CODE	EM_FR30
#define ELF_MACHINE_ALT1	EM_CYGNUS_FR30
#define ELF_MAXPAGESIZE		0x1000

#define TARGET_BIG_SYM          bfd_elf32_fr30_vec
#define TARGET_BIG_NAME		"elf32-fr30"

#define elf_info_to_howto_rel			NULL
#define elf_info_to_howto			fr30_info_to_howto_rela
#define elf_backend_relocate_section		fr30_elf_relocate_section
#define elf_backend_gc_mark_hook		fr30_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook		fr30_elf_gc_sweep_hook
#define elf_backend_check_relocs                fr30_elf_check_relocs

#define elf_backend_can_gc_sections		1
#define elf_backend_rela_normal			1

#define bfd_elf32_bfd_reloc_type_lookup		fr30_reloc_type_lookup

#include "elf32-target.h"
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d34 4
a37 3
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
static boolean fr30_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d39 5
a43 3
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, bfd_vma));
static boolean fr30_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *));
d45 5
a49 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *, struct elf_link_hash_entry *, Elf_Internal_Sym *));
d58 1
a58 1
	 false,			/* pc_relative */
d63 1
a63 1
	 false,			/* partial_inplace */
d66 1
a66 1
	 false),		/* pcrel_offset */
d73 1
a73 1
	 false,			/* pc_relative */
d78 1
a78 1
	 true,			/* partial_inplace */
d81 1
a81 1
	 false),		/* pcrel_offset */
d88 1
a88 1
	 false,			/* pc_relative */
d93 1
a93 1
	 true,			/* partial_inplace */
d96 1
a96 1
	 false),		/* pcrel_offset */
d103 1
a103 1
	 false,			/* pc_relative */
d108 1
a108 1
	 true,			/* partial_inplace */
d111 1
a111 1
	 false),		/* pcrel_offset */
d118 1
a118 1
	 false,			/* pc_relative */
d123 1
a123 1
	 true,			/* partial_inplace */
d126 1
a126 1
	 false),		/* pcrel_offset */
d133 1
a133 1
	 false,			/* pc_relative */
d138 1
a138 1
	 true,			/* partial_inplace */
d141 1
a141 1
	 false),		/* pcrel_offset */
d148 1
a148 1
	 false,			/* pc_relative */
d153 1
a153 1
	 true,			/* partial_inplace */
d156 1
a156 1
	 false),		/* pcrel_offset */
d163 1
a163 1
	 false,			/* pc_relative */
d168 1
a168 1
	 true,			/* partial_inplace */
d171 1
a171 1
	 false),		/* pcrel_offset */
d178 1
a178 1
	 false,			/* pc_relative */
d183 1
a183 1
	 true,			/* partial_inplace */
d186 1
a186 1
	 false),		/* pcrel_offset */
d193 1
a193 1
	 true,			/* pc_relative */
d198 1
a198 1
	 false,			/* partial_inplace */
d201 1
a201 1
	 false),		/* pcrel_offset */
d208 1
a208 1
	 true,			/* pc_relative */
d213 1
a213 1
	 false,			/* partial_inplace */
d216 1
a216 1
	 false),		/* pcrel_offset */
d222 1
a222 1
         false,                 /* pc_relative */
d227 1
a227 1
         false,                 /* partial_inplace */
d230 1
a230 1
         false),                /* pcrel_offset */
d237 1
a237 1
         false,                 /* pc_relative */
d242 1
a242 1
         false,                 /* partial_inplace */
d245 1
a245 1
         false),                /* pcrel_offset */
d253 7
a259 7
     bfd *      abfd;
     arelent *  reloc_entry;
     asymbol *  symbol;
     PTR        data;
     asection * input_section;
     bfd *      output_bfd;
     char **    error_message ATTRIBUTE_UNUSED;
d261 1
a261 1
  bfd_vma       relocation;
d289 1
a289 1
  bfd_put_32 (abfd, x, (char *) data + reloc_entry->address);
d299 7
a305 7
     bfd *      abfd;
     arelent *  reloc_entry;
     asymbol *  symbol;
     PTR        data;
     asection * input_section;
     bfd *      output_bfd;
     char **    error_message ATTRIBUTE_UNUSED;
d307 1
a307 1
  bfd_vma       relocation;
d361 1
a361 1
     bfd * abfd ATTRIBUTE_UNUSED;
d378 3
a380 3
     bfd * abfd ATTRIBUTE_UNUSED;
     arelent * cache_ptr;
     Elf32_Internal_Rela * dst;
d393 8
a400 7
fr30_final_link_relocate (howto, input_bfd, input_section, contents, rel, relocation)
     reloc_howto_type *  howto;
     bfd *               input_bfd;
     asection *          input_section;
     bfd_byte *          contents;
     Elf_Internal_Rela * rel;
     bfd_vma             relocation;
d403 2
a404 2
  bfd_vma               x;
  bfd_signed_vma	srel;
a471 3
   There is some attempt to make this function usable for many architectures,
   both USE_REL and USE_RELA ['twould be nice if such a critter existed],
   if only to serve as a learning tool.
d501 1
a501 1
static boolean
d504 16
a519 13
     bfd *                   output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *  info;
     bfd *                   input_bfd;
     asection *              input_section;
     bfd_byte *              contents;
     Elf_Internal_Rela *     relocs;
     Elf_Internal_Sym *      local_syms;
     asection **             local_sections;
{
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  Elf_Internal_Rela *           rel;
  Elf_Internal_Rela *           relend;
d527 9
a535 9
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
      const char *                 name = NULL;
      int                          r_type;
a544 21
      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;

	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections [r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d554 1
a554 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
d602 2
a603 2
		      input_section, rel->r_offset, true)))
		return false;
d629 1
a629 1
		 true);
d654 1
a654 1
	    return false;
d658 1
a658 1
  return true;
d665 6
a670 6
fr30_elf_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *                        abfd;
     struct bfd_link_info *       info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *          rel;
     struct elf_link_hash_entry * h;
     Elf_Internal_Sym *           sym;
d696 1
a696 9
    {
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
    }
d703 1
a703 1
static boolean
d705 4
a708 4
     bfd *                     abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *    info ATTRIBUTE_UNUSED;
     asection *                sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela * relocs ATTRIBUTE_UNUSED;
d710 1
a710 1
  return true;
d717 1
a717 1
static boolean
d730 1
a730 1
    return true;
d756 1
a756 1
            return false;
d763 1
a763 1
            return false;
d768 1
a768 1
  return true;
d772 2
a773 1
#define ELF_MACHINE_CODE	EM_CYGNUS_FR30
d787 1
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d34 3
a36 4
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean fr30_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d38 3
a40 5
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
static bfd_boolean fr30_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d42 1
a42 5
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean fr30_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d51 1
a51 1
	 FALSE,			/* pc_relative */
d56 1
a56 1
	 FALSE,			/* partial_inplace */
d59 1
a59 1
	 FALSE),		/* pcrel_offset */
d66 1
a66 1
	 FALSE,			/* pc_relative */
d71 1
a71 1
	 TRUE,			/* partial_inplace */
d74 1
a74 1
	 FALSE),		/* pcrel_offset */
d81 1
a81 1
	 FALSE,			/* pc_relative */
d86 1
a86 1
	 TRUE,			/* partial_inplace */
d89 1
a89 1
	 FALSE),		/* pcrel_offset */
d96 1
a96 1
	 FALSE,			/* pc_relative */
d101 1
a101 1
	 TRUE,			/* partial_inplace */
d104 1
a104 1
	 FALSE),		/* pcrel_offset */
d111 1
a111 1
	 FALSE,			/* pc_relative */
d116 1
a116 1
	 TRUE,			/* partial_inplace */
d119 1
a119 1
	 FALSE),		/* pcrel_offset */
d126 1
a126 1
	 FALSE,			/* pc_relative */
d131 1
a131 1
	 TRUE,			/* partial_inplace */
d134 1
a134 1
	 FALSE),		/* pcrel_offset */
d141 1
a141 1
	 FALSE,			/* pc_relative */
d146 1
a146 1
	 TRUE,			/* partial_inplace */
d149 1
a149 1
	 FALSE),		/* pcrel_offset */
d156 1
a156 1
	 FALSE,			/* pc_relative */
d161 1
a161 1
	 TRUE,			/* partial_inplace */
d164 1
a164 1
	 FALSE),		/* pcrel_offset */
d171 1
a171 1
	 FALSE,			/* pc_relative */
d176 1
a176 1
	 TRUE,			/* partial_inplace */
d179 1
a179 1
	 FALSE),		/* pcrel_offset */
d186 1
a186 1
	 TRUE,			/* pc_relative */
d191 1
a191 1
	 FALSE,			/* partial_inplace */
d194 1
a194 1
	 FALSE),		/* pcrel_offset */
d201 1
a201 1
	 TRUE,			/* pc_relative */
d206 1
a206 1
	 FALSE,			/* partial_inplace */
d209 1
a209 1
	 FALSE),		/* pcrel_offset */
d215 1
a215 1
         FALSE,                 /* pc_relative */
d220 1
a220 1
         FALSE,                 /* partial_inplace */
d223 1
a223 1
         FALSE),                /* pcrel_offset */
d230 1
a230 1
         FALSE,                 /* pc_relative */
d235 1
a235 1
         FALSE,                 /* partial_inplace */
d238 1
a238 1
         FALSE),                /* pcrel_offset */
d246 7
a252 7
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d254 1
a254 1
  bfd_vma relocation;
d282 1
a282 1
  bfd_put_32 (abfd, (bfd_vma) x, (char *) data + reloc_entry->address);
d292 7
a298 7
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d300 1
a300 1
  bfd_vma relocation;
d354 1
a354 1
     bfd *abfd ATTRIBUTE_UNUSED;
d371 3
a373 3
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d386 7
a392 8
fr30_final_link_relocate (howto, input_bfd, input_section, contents, rel,
			  relocation)
     reloc_howto_type *howto;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *rel;
     bfd_vma relocation;
d395 2
a396 2
  bfd_vma x;
  bfd_signed_vma srel;
d464 3
d496 1
a496 1
static bfd_boolean
d499 13
a511 16
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  if (info->relocateable)
    return TRUE;
d519 9
a527 9
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char *name = NULL;
      int r_type;
d537 21
d567 3
a569 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d617 2
a618 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d644 1
a644 1
		 TRUE);
d669 1
a669 1
	    return FALSE;
d673 1
a673 1
  return TRUE;
d680 6
a685 6
fr30_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym * sym;
d711 9
a719 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d726 1
a726 1
static bfd_boolean
d728 4
a731 4
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d733 1
a733 1
  return TRUE;
d740 1
a740 1
static bfd_boolean
d753 1
a753 1
    return TRUE;
d779 1
a779 1
            return FALSE;
d786 1
a786 1
            return FALSE;
d791 1
a791 1
  return TRUE;
d795 1
a795 2
#define ELF_MACHINE_CODE	EM_FR30
#define ELF_MACHINE_ALT1	EM_CYGNUS_FR30
a808 1
#define elf_backend_rela_normal			1
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d2 1
a2 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d481 1
a481 1
   necessary, and (if using Rela relocs and generating a relocatable
d495 1
a495 1
   When generating relocatable output, this function must handle
d518 1
a518 1
  if (info->relocatable)
d554 1
a554 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d568 1
a568 1
	  bfd_boolean unresolved_reloc, warned;
d570 39
a608 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d729 1
a729 1
  if (info->relocatable)
d755 1
a755 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d762 1
a762 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d34 3
a36 4
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean fr30_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d38 3
a40 5
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
static bfd_boolean fr30_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d42 1
a42 5
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean fr30_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d51 1
a51 1
	 FALSE,			/* pc_relative */
d56 1
a56 1
	 FALSE,			/* partial_inplace */
d59 1
a59 1
	 FALSE),		/* pcrel_offset */
d66 1
a66 1
	 FALSE,			/* pc_relative */
d71 1
a71 1
	 TRUE,			/* partial_inplace */
d74 1
a74 1
	 FALSE),		/* pcrel_offset */
d81 1
a81 1
	 FALSE,			/* pc_relative */
d86 1
a86 1
	 TRUE,			/* partial_inplace */
d89 1
a89 1
	 FALSE),		/* pcrel_offset */
d96 1
a96 1
	 FALSE,			/* pc_relative */
d101 1
a101 1
	 TRUE,			/* partial_inplace */
d104 1
a104 1
	 FALSE),		/* pcrel_offset */
d111 1
a111 1
	 FALSE,			/* pc_relative */
d116 1
a116 1
	 TRUE,			/* partial_inplace */
d119 1
a119 1
	 FALSE),		/* pcrel_offset */
d126 1
a126 1
	 FALSE,			/* pc_relative */
d131 1
a131 1
	 TRUE,			/* partial_inplace */
d134 1
a134 1
	 FALSE),		/* pcrel_offset */
d141 1
a141 1
	 FALSE,			/* pc_relative */
d146 1
a146 1
	 TRUE,			/* partial_inplace */
d149 1
a149 1
	 FALSE),		/* pcrel_offset */
d156 1
a156 1
	 FALSE,			/* pc_relative */
d161 1
a161 1
	 TRUE,			/* partial_inplace */
d164 1
a164 1
	 FALSE),		/* pcrel_offset */
d171 1
a171 1
	 FALSE,			/* pc_relative */
d176 1
a176 1
	 TRUE,			/* partial_inplace */
d179 1
a179 1
	 FALSE),		/* pcrel_offset */
d186 1
a186 1
	 TRUE,			/* pc_relative */
d191 1
a191 1
	 FALSE,			/* partial_inplace */
d194 1
a194 1
	 FALSE),		/* pcrel_offset */
d201 1
a201 1
	 TRUE,			/* pc_relative */
d206 1
a206 1
	 FALSE,			/* partial_inplace */
d209 1
a209 1
	 FALSE),		/* pcrel_offset */
d215 1
a215 1
         FALSE,                 /* pc_relative */
d220 1
a220 1
         FALSE,                 /* partial_inplace */
d223 1
a223 1
         FALSE),                /* pcrel_offset */
d230 1
a230 1
         FALSE,                 /* pc_relative */
d235 1
a235 1
         FALSE,                 /* partial_inplace */
d238 1
a238 1
         FALSE),                /* pcrel_offset */
d246 7
a252 7
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d254 1
a254 1
  bfd_vma relocation;
d282 1
a282 1
  bfd_put_32 (abfd, (bfd_vma) x, (char *) data + reloc_entry->address);
d292 7
a298 7
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d300 1
a300 1
  bfd_vma relocation;
d354 1
a354 1
     bfd *abfd ATTRIBUTE_UNUSED;
d371 3
a373 3
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d386 7
a392 8
fr30_final_link_relocate (howto, input_bfd, input_section, contents, rel,
			  relocation)
     reloc_howto_type *howto;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *rel;
     bfd_vma relocation;
d395 2
a396 2
  bfd_vma x;
  bfd_signed_vma srel;
d464 3
d496 1
a496 1
static bfd_boolean
d499 13
a511 16
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  if (info->relocateable)
    return TRUE;
d519 9
a527 9
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char *name = NULL;
      int r_type;
d537 21
d567 3
a569 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d617 2
a618 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d644 1
a644 1
		 TRUE);
d669 1
a669 1
	    return FALSE;
d673 1
a673 1
  return TRUE;
d680 6
a685 6
fr30_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym * sym;
d711 9
a719 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d726 1
a726 1
static bfd_boolean
d728 4
a731 4
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d733 1
a733 1
  return TRUE;
d740 1
a740 1
static bfd_boolean
d753 1
a753 1
    return TRUE;
d779 1
a779 1
            return FALSE;
d786 1
a786 1
            return FALSE;
d791 1
a791 1
  return TRUE;
d795 1
a795 2
#define ELF_MACHINE_CODE	EM_FR30
#define ELF_MACHINE_ALT1	EM_CYGNUS_FR30
a808 1
#define elf_backend_rela_normal			1
@

