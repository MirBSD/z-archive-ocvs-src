head	1.4;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.08.11.20.52.36;	author tg;	state dead;
branches;
next	1.3;

1.3
date	2004.06.10.19.00.25;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.23.21.00.35;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.39.07;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.39.07;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.26.53;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.40.51;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.04.31;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.08.21;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove old binutils
@
text
@/* BFD back-end data structures for a.out (and similar) files.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef LIBAOUT_H
#define LIBAOUT_H

/* We try to encapsulate the differences in the various a.out file
   variants in a few routines, and otherwise share large masses of code.
   This means we only have to fix bugs in one place, most of the time.  */

#include "bfdlink.h"

/* Macros for accessing components in an aout header.  Saves cluttering
   the source with (bfd_vma) and (bfd_byte *) casts.  */

#define H_PUT_64(abfd, val, where) \
  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_32(abfd, val, where) \
  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_16(abfd, val, where) \
  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_8 bfd_h_put_8

#define H_PUT_S64(abfd, val, where) \
  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S32(abfd, val, where) \
  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S16(abfd, val, where) \
  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S8 bfd_h_put_signed_8

#define H_GET_64(abfd, where) \
  bfd_h_get_64 ((abfd), (bfd_byte *) (where))

#define H_GET_32(abfd, where) \
  bfd_h_get_32 ((abfd), (bfd_byte *) (where))

#define H_GET_16(abfd, where) \
  bfd_h_get_16 ((abfd), (bfd_byte *) (where))

#define H_GET_8 bfd_h_get_8

#define H_GET_S64(abfd, where) \
  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))

#define H_GET_S32(abfd, where) \
  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))

#define H_GET_S16(abfd, where) \
  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))

#define H_GET_S8 bfd_h_get_signed_8

/* Parameterize the a.out code based on whether it is being built
   for a 32-bit architecture or a 64-bit architecture.  */
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#if ARCH_SIZE==64
#define GET_WORD H_GET_64
#define GET_SWORD H_GET_S64
#define GET_MAGIC H_GET_32
#define PUT_WORD H_PUT_64
#define PUT_MAGIC H_PUT_32
#ifndef NAME
#define NAME(x,y) CONCAT3 (x,_64_,y)
#endif
#define JNAME(x) CONCAT2 (x,_64)
#define BYTES_IN_WORD 8
#else
#if ARCH_SIZE==16
#define GET_WORD H_GET_16
#define GET_SWORD H_GET_S16
#define GET_MAGIC H_GET_16
#define PUT_WORD H_PUT_16
#define PUT_MAGIC H_PUT_16
#ifndef NAME
#define NAME(x,y) CONCAT3 (x,_16_,y)
#endif
#define JNAME(x) CONCAT2 (x,_16)
#define BYTES_IN_WORD 2
#else /* ARCH_SIZE == 32 */
#define GET_WORD H_GET_32
#define GET_SWORD H_GET_S32
#define GET_MAGIC H_GET_32
#define PUT_WORD H_PUT_32
#define PUT_MAGIC H_PUT_32
#ifndef NAME
#define NAME(x,y) CONCAT3 (x,_32_,y)
#endif
#define JNAME(x) CONCAT2 (x,_32)
#define BYTES_IN_WORD 4
#endif /* ARCH_SIZE==32 */
#endif /* ARCH_SIZE==64 */

/* Declare at file level, since used in parameter lists, which have
   weird scope.  */
struct external_exec;
struct external_nlist;
struct reloc_ext_external;
struct reloc_std_external;

/* a.out backend linker hash table entries.  */

struct aout_link_hash_entry
{
  struct bfd_link_hash_entry root;
  /* Whether this symbol has been written out.  */
  bfd_boolean written;
  /* Symbol index in output file.  */
  int indx;
};

/* a.out backend linker hash table.  */

struct aout_link_hash_table
{
  struct bfd_link_hash_table root;
};

/* Look up an entry in an a.out link hash table.  */

#define aout_link_hash_lookup(table, string, create, copy, follow) \
  ((struct aout_link_hash_entry *) \
   bfd_link_hash_lookup (&(table)->root, (string), (create), (copy), (follow)))

/* Traverse an a.out link hash table.  */

#define aout_link_hash_traverse(table, func, info)			\
  (bfd_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func), \
    (info)))

/* Get the a.out link hash table from the info structure.  This is
   just a cast.  */

#define aout_hash_table(p) ((struct aout_link_hash_table *) ((p)->hash))

/* Back-end information for various a.out targets.  */
struct aout_backend_data
{
  /* Are ZMAGIC files mapped contiguously?  If so, the text section may
     need more padding, if the segment size (granularity for memory access
     control) is larger than the page size.  */
  unsigned char zmagic_mapped_contiguous;
  /* If this flag is set, ZMAGIC/NMAGIC file headers get mapped in with the
     text section, which starts immediately after the file header.
     If not, the text section starts on the next page.  */
  unsigned char text_includes_header;

  /* If this flag is set, then if the entry address is not in the
     first SEGMENT_SIZE bytes of the text section, it is taken to be
     the address of the start of the text section.  This can be useful
     for kernels.  */
  unsigned char entry_is_text_address;

  /* The value to pass to N_SET_FLAGS.  */
  unsigned char exec_hdr_flags;

  /* If the text section VMA isn't specified, and we need an absolute
     address, use this as the default.  If we're producing a relocatable
     file, zero is always used.  */
  /* ?? Perhaps a callback would be a better choice?  Will this do anything
     reasonable for a format that handles multiple CPUs with different
     load addresses for each?  */
  bfd_vma default_text_vma;

  /* Callback for setting the page and segment sizes, if they can't be
     trivially determined from the architecture.  */
  bfd_boolean (*set_sizes)
    PARAMS ((bfd *));

  /* zmagic files only. For go32, the length of the exec header contributes
     to the size of the text section in the file for alignment purposes but
     does *not* get counted in the length of the text section. */
  unsigned char exec_header_not_counted;

  /* Callback from the add symbols phase of the linker code to handle
     a dynamic object.  */
  bfd_boolean (*add_dynamic_symbols)
    PARAMS ((bfd *, struct bfd_link_info *, struct external_nlist **,
	     bfd_size_type *, char **));

  /* Callback from the add symbols phase of the linker code to handle
     adding a single symbol to the global linker hash table.  */
  bfd_boolean (*add_one_symbol)
    PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword,
	     asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
	     struct bfd_link_hash_entry **));

  /* Called to handle linking a dynamic object.  */
  bfd_boolean (*link_dynamic_object)
    PARAMS ((struct bfd_link_info *, bfd *));

  /* Called for each global symbol being written out by the linker.
     This should write out the dynamic symbol information.  */
  bfd_boolean (*write_dynamic_symbol)
    PARAMS ((bfd *, struct bfd_link_info *, struct aout_link_hash_entry *));

  /* If this callback is not NULL, the linker calls it for each reloc.
     RELOC is a pointer to the unswapped reloc.  If *SKIP is set to
     TRUE, the reloc will be skipped.  *RELOCATION may be changed to
     change the effects of the relocation.  */
  bfd_boolean (*check_dynamic_reloc)
    PARAMS ((struct bfd_link_info *info, bfd *input_bfd,
	     asection *input_section, struct aout_link_hash_entry *h,
	     PTR reloc, bfd_byte *contents, bfd_boolean *skip,
	     bfd_vma *relocation));

  /* Called at the end of a link to finish up any dynamic linking
     information.  */
  bfd_boolean (*finish_dynamic_link)
    PARAMS ((bfd *, struct bfd_link_info *));
};
#define aout_backend_info(abfd) \
	((const struct aout_backend_data *)((abfd)->xvec->backend_data))

/* This is the layout in memory of a "struct exec" while we process it.
   All 'lengths' are given as a number of bytes.
   All 'alignments' are for relinkable files only;  an alignment of
	'n' indicates the corresponding segment must begin at an
	address that is a multiple of (2**n).  */

struct internal_exec
{
    long a_info;		/* Magic number and flags, packed */
    bfd_vma a_text;		/* length of text, in bytes  */
    bfd_vma a_data;		/* length of data, in bytes  */
    bfd_vma a_bss;		/* length of uninitialized data area in mem */
    bfd_vma a_syms;		/* length of symbol table data in file */
    bfd_vma a_entry;		/* start address */
    bfd_vma a_trsize;		/* length of text's relocation info, in bytes */
    bfd_vma a_drsize;		/* length of data's relocation info, in bytes */
    /* Added for i960 */
    bfd_vma a_tload;		/* Text runtime load address */
    bfd_vma a_dload;		/* Data runtime load address */
    unsigned char a_talign;	/* Alignment of text segment */
    unsigned char a_dalign;	/* Alignment of data segment */
    unsigned char a_balign;	/* Alignment of bss segment */
    char a_relaxable;           /* Enough info for linker relax */
};

/* Magic number is written
< MSB          >
3130292827262524232221201918171615141312111009080706050403020100
< FLAGS        >< MACHINE TYPE ><  MAGIC NUMBER                >
*/
/* Magic number for NetBSD is
<MSB           >
3130292827262524232221201918171615141312111009080706050403020100
< FLAGS    >< MACHINE TYPE     ><  MAGIC NUMBER                >
*/

enum machine_type {
  M_UNKNOWN = 0,
  M_68010 = 1,
  M_68020 = 2,
  M_SPARC = 3,
  /* Skip a bunch so we don't run into any of SUN's numbers.  */
  /* Make these up for the ns32k.  */
  M_NS32032 = (64),	/* ns32032 running ? */
  M_NS32532 = (64 + 5),	/* ns32532 running mach */

  M_386 = 100,
  M_29K = 101,          /* AMD 29000 */
  M_386_DYNIX = 102,	/* Sequent running dynix */
  M_ARM = 103,		/* Advanced Risc Machines ARM */
  M_SPARCLET = 131,	/* SPARClet = M_SPARC + 128 */
  M_386_NETBSD = 134,	/* NetBSD/i386 binary */
  M_68K_NETBSD = 135,	/* NetBSD/m68k binary */
  M_68K4K_NETBSD = 136,	/* NetBSD/m68k4k binary */
  M_532_NETBSD = 137,	/* NetBSD/ns32k binary */
  M_SPARC_NETBSD = 138,	/* NetBSD/sparc binary */
  M_PMAX_NETBSD = 139,	/* NetBSD/pmax (MIPS little-endian) binary */
  M_VAX_NETBSD = 140,	/* NetBSD/vax binary */
  M_ALPHA_NETBSD = 141,	/* NetBSD/alpha binary */
  M_ARM6_NETBSD = 143,	/* NetBSD/arm32 binary */
  M_SPARCLET_1 = 147,	/* 0x93, reserved */
  M_POWERPC_NETBSD = 149, /* NetBSD/powerpc (big-endian) binary */
  M_VAX4K_NETBSD = 150,	/* NetBSD/vax 4K pages binary */
  M_MIPS1 = 151,        /* MIPS R2000/R3000 binary */
  M_MIPS2 = 152,        /* MIPS R4000/R6000 binary */
  M_88K_OPENBSD = 153,	/* OpenBSD/m88k binary */
  M_HPPA_OPENBSD = 154,	/* OpenBSD/hppa binary */
  M_SPARC64_NETBSD = 156, /* NetBSD/sparc64 binary */
  M_X86_64_NETBSD = 157, /* NetBSD/amd64 binary */
  M_SPARCLET_2 = 163,	/* 0xa3, reserved */
  M_SPARCLET_3 = 179,	/* 0xb3, reserved */
  M_SPARCLET_4 = 195,	/* 0xc3, reserved */
  M_HP200 = 200,	/* HP 200 (68010) BSD binary */
  M_HP300 = (300 % 256), /* HP 300 (68020+68881) BSD binary */
  M_HPUX = (0x20c % 256), /* HP 200/300 HPUX binary */
  M_SPARCLET_5 = 211,	/* 0xd3, reserved */
  M_SPARCLET_6 = 227,	/* 0xe3, reserved */
  /*  M_SPARCLET_7 = 243	/ * 0xf3, reserved */
  M_SPARCLITE_LE = 243,
  M_CRIS = 255		/* Axis CRIS binary.  */
};

#define N_DYNAMIC(exec) ((exec).a_info & 0x80000000)

#ifndef N_MAGIC
# define N_MAGIC(exec) ((exec).a_info & 0xffff)
#endif

#ifndef N_MACHTYPE
# define N_MACHTYPE(exec) ((enum machine_type)(((exec).a_info >> 16) & 0xff))
#endif

#ifndef N_FLAGS
# define N_FLAGS(exec) (((exec).a_info >> 24) & 0xff)
#endif

#ifndef N_SET_INFO
# define N_SET_INFO(exec, magic, type, flags) \
((exec).a_info = ((magic) & 0xffff) \
 | (((int)(type) & 0xff) << 16) \
 | (((flags) & 0xff) << 24))
#endif

#ifndef N_SET_DYNAMIC
# define N_SET_DYNAMIC(exec, dynamic) \
((exec).a_info = (dynamic) ? (long) ((exec).a_info | 0x80000000) : \
((exec).a_info & 0x7fffffff))
#endif

#ifndef N_SET_MAGIC
# define N_SET_MAGIC(exec, magic) \
((exec).a_info = (((exec).a_info & 0xffff0000) | ((magic) & 0xffff)))
#endif

#ifndef N_SET_MACHTYPE
# define N_SET_MACHTYPE(exec, machtype) \
((exec).a_info = \
 ((exec).a_info&0xff00ffff) | ((((int)(machtype))&0xff) << 16))
#endif

#ifndef N_SET_FLAGS
# define N_SET_FLAGS(exec, flags) \
((exec).a_info = \
 ((exec).a_info&0x00ffffff) | (((flags) & 0xff) << 24))
#endif

typedef struct aout_symbol {
  asymbol symbol;
  short desc;
  char other;
  unsigned char type;
} aout_symbol_type;

/* The `tdata' struct for all a.out-like object file formats.
   Various things depend on this struct being around any time an a.out
   file is being handled.  An example is dbxread.c in GDB.  */

struct aoutdata {
  struct internal_exec *hdr;		/* exec file header */
  aout_symbol_type *symbols;		/* symtab for input bfd */

  /* For ease, we do this.  */
  asection *textsec;
  asection *datasec;
  asection *bsssec;

  /* We remember these offsets so that after check_file_format, we have
     no dependencies on the particular format of the exec_hdr.  */
  file_ptr sym_filepos;
  file_ptr str_filepos;

  /* Size of a relocation entry in external form.  */
  unsigned reloc_entry_size;

  /* Size of a symbol table entry in external form.  */
  unsigned symbol_entry_size;

  /* Page size - needed for alignment of demand paged files.  */
  unsigned long page_size;

  /* Segment size - needed for alignment of demand paged files.  */
  unsigned long segment_size;

  /* Zmagic disk block size - need to align the start of the text
     section in ZMAGIC binaries.  Normally the same as page_size.  */
  unsigned long zmagic_disk_block_size;

  unsigned exec_bytes_size;
  unsigned vma_adjusted : 1;

  /* Used when a bfd supports several highly similar formats.  */
  enum
    {
      default_format = 0,
      /* Used on HP 9000/300 running HP/UX.  See hp300hpux.c.  */
      gnu_encap_format,
      /* Used on Linux, 386BSD, etc.  See include/aout/aout64.h.  */
      q_magic_format
    } subformat;

  enum
    {
      undecided_magic = 0,
      z_magic,
      o_magic,
      n_magic
    } magic;

  /* A buffer for find_nearest_line.  */
  char *line_buf;

  /* The external symbol information.  */
  struct external_nlist *external_syms;
  bfd_size_type external_sym_count;
  bfd_window sym_window;
  char *external_strings;
  bfd_size_type external_string_size;
  bfd_window string_window;
  struct aout_link_hash_entry **sym_hashes;

  /* A pointer for shared library information.  */
  PTR dynamic_info;

  /* A mapping from local symbols to offsets into the global offset
     table, used when linking on SunOS.  This is indexed by the symbol
     index.  */
  bfd_vma *local_got_offsets;
};

struct  aout_data_struct {
    struct aoutdata a;
    struct internal_exec e;
};

#define	adata(bfd)		((bfd)->tdata.aout_data->a)
#define	exec_hdr(bfd)		(adata(bfd).hdr)
#define	obj_aout_symbols(bfd)	(adata(bfd).symbols)
#define	obj_textsec(bfd)	(adata(bfd).textsec)
#define	obj_datasec(bfd)	(adata(bfd).datasec)
#define	obj_bsssec(bfd)		(adata(bfd).bsssec)
#define	obj_sym_filepos(bfd)	(adata(bfd).sym_filepos)
#define	obj_str_filepos(bfd)	(adata(bfd).str_filepos)
#define	obj_reloc_entry_size(bfd) (adata(bfd).reloc_entry_size)
#define	obj_symbol_entry_size(bfd) (adata(bfd).symbol_entry_size)
#define obj_aout_subformat(bfd)	(adata(bfd).subformat)
#define obj_aout_external_syms(bfd) (adata(bfd).external_syms)
#define obj_aout_external_sym_count(bfd) (adata(bfd).external_sym_count)
#define obj_aout_sym_window(bfd) (adata(bfd).sym_window)
#define obj_aout_external_strings(bfd) (adata(bfd).external_strings)
#define obj_aout_external_string_size(bfd) (adata(bfd).external_string_size)
#define obj_aout_string_window(bfd) (adata(bfd).string_window)
#define obj_aout_sym_hashes(bfd) (adata(bfd).sym_hashes)
#define obj_aout_dynamic_info(bfd) (adata(bfd).dynamic_info)

/* We take the address of the first element of an asymbol to ensure that the
   macro is only ever applied to an asymbol.  */
#define aout_symbol(asymbol) ((aout_symbol_type *)(&(asymbol)->the_bfd))

/* Information we keep for each a.out section.  This is currently only
   used by the a.out backend linker.  */

struct aout_section_data_struct
{
  /* The unswapped relocation entries for this section.  */
  PTR relocs;
};

#define aout_section_data(s) \
  ((struct aout_section_data_struct *) (s)->used_by_bfd)

#define set_aout_section_data(s,v) \
  ((s)->used_by_bfd = (PTR)&(v)->relocs)

/* Prototype declarations for functions defined in aoutx.h.  */

extern bfd_boolean NAME(aout,squirt_out_relocs)
  PARAMS ((bfd *, asection *));

extern bfd_boolean NAME(aout,make_sections)
  PARAMS ((bfd *));

extern const bfd_target * NAME(aout,some_aout_object_p)
  PARAMS ((bfd *, struct internal_exec *, const bfd_target *(*) (bfd *)));

extern bfd_boolean NAME(aout,mkobject)
  PARAMS ((bfd *));

extern enum machine_type NAME(aout,machine_type)
  PARAMS ((enum bfd_architecture, unsigned long, bfd_boolean *));

extern bfd_boolean NAME(aout,set_arch_mach)
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));

extern bfd_boolean NAME(aout,new_section_hook)
  PARAMS ((bfd *, asection *));

extern bfd_boolean NAME(aout,set_section_contents)
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));

extern asymbol * NAME(aout,make_empty_symbol)
  PARAMS ((bfd *));

extern bfd_boolean NAME(aout,translate_symbol_table)
  PARAMS ((bfd *, aout_symbol_type *, struct external_nlist *, bfd_size_type,
	   char *, bfd_size_type, bfd_boolean));

extern bfd_boolean NAME(aout,slurp_symbol_table)
  PARAMS ((bfd *));

extern bfd_boolean NAME(aout,write_syms)
  PARAMS ((bfd *));

extern void NAME(aout,reclaim_symbol_table)
  PARAMS ((bfd *));

extern long NAME(aout,get_symtab_upper_bound)
  PARAMS ((bfd *));

extern long NAME(aout,get_symtab)
  PARAMS ((bfd *, asymbol **));

extern void NAME(aout,swap_ext_reloc_in)
  PARAMS ((bfd *, struct reloc_ext_external *, arelent *, asymbol **,
	   bfd_size_type));
extern void NAME(aout,swap_std_reloc_in)
  PARAMS ((bfd *, struct reloc_std_external *, arelent *, asymbol **,
	   bfd_size_type));

extern reloc_howto_type * NAME(aout,reloc_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));

extern bfd_boolean NAME(aout,slurp_reloc_table)
  PARAMS ((bfd *, sec_ptr, asymbol **));

extern long NAME(aout,canonicalize_reloc)
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));

extern long NAME(aout,get_reloc_upper_bound)
  PARAMS ((bfd *, sec_ptr));

extern void NAME(aout,reclaim_reloc)
  PARAMS ((bfd *, sec_ptr));

extern alent * NAME(aout,get_lineno)
  PARAMS ((bfd *, asymbol *));

extern void NAME(aout,print_symbol)
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));

extern void NAME(aout,get_symbol_info)
  PARAMS ((bfd *, asymbol *, symbol_info *));

extern bfd_boolean NAME(aout,find_nearest_line)
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));

extern long NAME(aout,read_minisymbols)
  PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));

extern asymbol * NAME(aout,minisymbol_to_symbol)
  PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));

extern int NAME(aout,sizeof_headers)
  PARAMS ((bfd *, bfd_boolean));

extern bfd_boolean NAME(aout,adjust_sizes_and_vmas)
  PARAMS ((bfd *, bfd_size_type *, file_ptr *));

extern void NAME(aout,swap_exec_header_in)
  PARAMS ((bfd *, struct external_exec *, struct internal_exec *));

extern void NAME(aout,swap_exec_header_out)
  PARAMS ((bfd *, struct internal_exec *, struct external_exec *));

extern struct bfd_hash_entry * NAME(aout,link_hash_newfunc)
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

extern bfd_boolean NAME(aout,link_hash_table_init)
  PARAMS ((struct aout_link_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));

extern struct bfd_link_hash_table * NAME(aout,link_hash_table_create)
  PARAMS ((bfd *));

extern bfd_boolean NAME(aout,link_add_symbols)
  PARAMS ((bfd *, struct bfd_link_info *));

extern bfd_boolean NAME(aout,final_link)
  PARAMS ((bfd *, struct bfd_link_info *,
	   void (*) (bfd *, file_ptr *, file_ptr *, file_ptr *)));

extern bfd_boolean NAME(aout,bfd_free_cached_info)
  PARAMS ((bfd *));

/* A.out uses the generic versions of these routines...  */

#define	aout_16_get_section_contents	_bfd_generic_get_section_contents

#define	aout_32_get_section_contents	_bfd_generic_get_section_contents

#define	aout_64_get_section_contents	_bfd_generic_get_section_contents
#ifndef NO_WRITE_HEADER_KLUDGE
#define NO_WRITE_HEADER_KLUDGE 0
#endif

#ifndef aout_32_bfd_is_local_label_name
#define aout_32_bfd_is_local_label_name bfd_generic_is_local_label_name
#endif

#ifndef WRITE_HEADERS
#define WRITE_HEADERS(abfd, execp)					      \
      {									      \
	bfd_size_type text_size; /* dummy vars */			      \
	file_ptr text_end;						      \
	if (adata(abfd).magic == undecided_magic)			      \
	  NAME(aout,adjust_sizes_and_vmas) (abfd, &text_size, &text_end);     \
    									      \
	execp->a_syms = bfd_get_symcount (abfd) * EXTERNAL_NLIST_SIZE;	      \
	execp->a_entry = bfd_get_start_address (abfd);			      \
    									      \
	execp->a_trsize = ((obj_textsec (abfd)->reloc_count) *		      \
			   obj_reloc_entry_size (abfd));		      \
	execp->a_drsize = ((obj_datasec (abfd)->reloc_count) *		      \
			   obj_reloc_entry_size (abfd));		      \
	NAME(aout,swap_exec_header_out) (abfd, execp, &exec_bytes);	      \
									      \
	if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0		      \
	    || bfd_bwrite ((PTR) &exec_bytes, (bfd_size_type) EXEC_BYTES_SIZE, \
			  abfd) != EXEC_BYTES_SIZE)			      \
	  return FALSE;							      \
	/* Now write out reloc info, followed by syms and strings.  */	      \
  									      \
	if (bfd_get_outsymbols (abfd) != (asymbol **) NULL		      \
	    && bfd_get_symcount (abfd) != 0) 				      \
	  {								      \
	    if (bfd_seek (abfd, (file_ptr) (N_SYMOFF(*execp)), SEEK_SET) != 0)\
	      return FALSE;						      \
									      \
	    if (! NAME(aout,write_syms) (abfd))				      \
	      return FALSE;						      \
	  }								      \
									      \
	if (bfd_seek (abfd, (file_ptr) (N_TRELOFF(*execp)), SEEK_SET) != 0)   \
	  return FALSE;						      	      \
	if (!NAME(aout,squirt_out_relocs) (abfd, obj_textsec (abfd)))         \
	  return FALSE;						      	      \
									      \
	if (bfd_seek (abfd, (file_ptr) (N_DRELOFF(*execp)), SEEK_SET) != 0)   \
	  return FALSE;						      	      \
	if (!NAME(aout,squirt_out_relocs) (abfd, obj_datasec (abfd)))         \
	  return FALSE;						      	      \
      }
#endif

/* Test if a read-only section can be merged with .text.  This is
   possible if:

   1. Section has file contents and is read-only.
   2. The VMA of the section is after the end of .text and before
      the start of .data.
   3. The image is demand-pageable (otherwise, a_text in the header
      will not reflect the gap between .text and .data).  */

#define aout_section_merge_with_text_p(abfd, sec)			\
  (((sec)->flags & (SEC_HAS_CONTENTS | SEC_READONLY)) ==		\
      (SEC_HAS_CONTENTS | SEC_READONLY)					\
   && obj_textsec (abfd) != NULL					\
   && obj_datasec (abfd) != NULL					\
   && (sec)->vma >= (obj_textsec (abfd)->vma +				\
		     obj_textsec (abfd)->_cooked_size)			\
   && ((sec)->vma + (sec)->_cooked_size) <= obj_datasec (abfd)->vma	\
   && ((abfd)->flags & D_PAGED) != 0)

#endif /* ! defined (LIBAOUT_H) */
@


1.3
log
@first foolish attempt to merge the last piece
won't probably work, but I want it backed up,
since there's a lot of work and time in it
@
text
@@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@d301 1
a301 1
  M_VAX1K_NETBSD = 140,	/* old NetBSD/vax binary */
d305 1
d309 4
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   2000, 2001
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 47
d81 3
d85 5
a89 3
#define GET_WORD bfd_h_get_64
#define GET_SWORD bfd_h_get_signed_64
#define PUT_WORD bfd_h_put_64
d91 1
a91 1
#define NAME(x,y) CAT3(x,_64_,y)
d93 1
a93 1
#define JNAME(x) CAT(x,_64)
d95 12
d108 5
a112 3
#define GET_WORD bfd_h_get_32
#define GET_SWORD bfd_h_get_signed_32
#define PUT_WORD bfd_h_put_32
d114 1
a114 1
#define NAME(x,y) CAT3(x,_32_,y)
d116 1
a116 1
#define JNAME(x) CAT(x,_32)
d119 1
d134 1
a134 1
  boolean written;
d157 1
a157 1
    (boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func),	\
d196 2
a197 1
  boolean (*set_sizes) PARAMS ((bfd *));
d206 3
a208 3
  boolean (*add_dynamic_symbols) PARAMS ((bfd *, struct bfd_link_info *,
					  struct external_nlist **,
					  bfd_size_type *, char **));
d212 4
a215 5
  boolean (*add_one_symbol) PARAMS ((struct bfd_link_info *, bfd *,
				     const char *, flagword, asection *,
				     bfd_vma, const char *, boolean,
				     boolean,
				     struct bfd_link_hash_entry **));
d218 2
a219 1
  boolean (*link_dynamic_object) PARAMS ((struct bfd_link_info *, bfd *));
d223 2
a224 2
  boolean (*write_dynamic_symbol) PARAMS ((bfd *, struct bfd_link_info *,
					   struct aout_link_hash_entry *));
d228 1
a228 1
     true, the reloc will be skipped.  *RELOCATION may be changed to
d230 5
a234 7
  boolean (*check_dynamic_reloc) PARAMS ((struct bfd_link_info *info,
					  bfd *input_bfd,
					  asection *input_section,
					  struct aout_link_hash_entry *h,
					  PTR reloc, bfd_byte *contents,
					  boolean *skip,
					  bfd_vma *relocation));
d238 2
a239 1
  boolean (*finish_dynamic_link) PARAMS ((bfd *, struct bfd_link_info *));
d242 1
a242 1
	((CONST struct aout_backend_data *)((abfd)->xvec->backend_data))
d269 1
a269 1
/* Magic number is written 
d285 4
a288 4
  /* skip a bunch so we don't run into any of suns numbers */
  /* make these up for the ns32k*/
  M_NS32032 = (64),		/* ns32032 running ? */
  M_NS32532 = (64 + 5),		/* ns32532 running mach */
d305 1
a305 1
  M_VAX_NETBSD = 150,	/* NetBSD/vax binary */
d344 1
a344 1
((exec).a_info = (dynamic) ? ((exec).a_info | 0x80000000) : \
d379 2
a380 2
  
  /* For ease, we do this */
d390 1
a390 1
  /* Size of a relocation entry in external form */
d393 1
a393 1
  /* Size of a symbol table entry in external form */
d396 1
a396 1
  /* Page size - needed for alignment of demand paged files. */
d399 1
a399 1
  /* Segment size - needed for alignment of demand paged files. */
d409 1
a409 1
  /* used when a bfd supports several highly similar formats */
d474 1
a474 1
   macro is only ever applied to an asymbol */
d492 1
a492 1
/* Prototype declarations for functions defined in aoutx.h  */
d494 2
a495 2
boolean
NAME(aout,squirt_out_relocs) PARAMS ((bfd *abfd, asection *section));
d497 2
a498 2
boolean
NAME(aout,make_sections) PARAMS ((bfd *));
d500 2
a501 4
const bfd_target *
NAME(aout,some_aout_object_p) PARAMS ((bfd *abfd,
				       struct internal_exec *execp,
				       const bfd_target *(*callback)(bfd *)));
d503 2
a504 2
boolean
NAME(aout,mkobject) PARAMS ((bfd *abfd));
d506 2
a507 4
enum machine_type
NAME(aout,machine_type) PARAMS ((enum bfd_architecture arch,
				 unsigned long machine,
				 boolean *unknown));
d509 2
a510 3
boolean
NAME(aout,set_arch_mach) PARAMS ((bfd *abfd, enum bfd_architecture arch,
		 		  unsigned long machine));
d512 2
a513 2
boolean
NAME(aout,new_section_hook) PARAMS ((bfd *abfd, asection *newsect));
d515 2
a516 3
boolean
NAME(aout,set_section_contents) PARAMS ((bfd *abfd, sec_ptr section,
			 PTR location, file_ptr offset, bfd_size_type count));
d518 2
a519 2
asymbol *
NAME(aout,make_empty_symbol) PARAMS ((bfd *abfd));
d521 3
a523 6
boolean
NAME(aout,translate_symbol_table) PARAMS ((bfd *, aout_symbol_type *,
					   struct external_nlist *,
					   bfd_size_type, char *,
					   bfd_size_type,
					   boolean dynamic));
d525 2
a526 2
boolean
NAME(aout,slurp_symbol_table) PARAMS ((bfd *abfd));
d528 2
a529 2
boolean
NAME(aout,write_syms) PARAMS ((bfd *abfd));
d531 2
a532 2
void
NAME(aout,reclaim_symbol_table) PARAMS ((bfd *abfd));
d534 2
a535 2
long
NAME(aout,get_symtab_upper_bound) PARAMS ((bfd *abfd));
d537 2
a538 2
long
NAME(aout,get_symtab) PARAMS ((bfd *abfd, asymbol **location));
d540 6
a545 6
void
NAME(aout,swap_ext_reloc_in) PARAMS ((bfd *, struct reloc_ext_external *,
				      arelent *, asymbol **, bfd_size_type));
void
NAME(aout,swap_std_reloc_in) PARAMS ((bfd *, struct reloc_std_external *,
				      arelent *, asymbol **, bfd_size_type));
d547 2
a548 3
reloc_howto_type *
NAME(aout,reloc_type_lookup) PARAMS ((bfd *abfd,
				      bfd_reloc_code_real_type code));
d550 2
a551 3
boolean
NAME(aout,slurp_reloc_table) PARAMS ((bfd *abfd, sec_ptr asect,
				      asymbol **symbols));
d553 2
a554 3
long
NAME(aout,canonicalize_reloc) PARAMS ((bfd *abfd, sec_ptr section,
				       arelent **relptr, asymbol **symbols));
d556 2
a557 2
long
NAME(aout,get_reloc_upper_bound) PARAMS ((bfd *abfd, sec_ptr asect));
d559 2
a560 2
void
NAME(aout,reclaim_reloc) PARAMS ((bfd *ignore_abfd, sec_ptr ignore));
d562 2
a563 2
alent *
NAME(aout,get_lineno) PARAMS ((bfd *ignore_abfd, asymbol *ignore_symbol));
d565 2
a566 3
void
NAME(aout,print_symbol) PARAMS ((bfd *ignore_abfd, PTR file,
			    asymbol *symbol, bfd_print_symbol_type how));
d568 2
a569 3
void
NAME(aout,get_symbol_info) PARAMS ((bfd *ignore_abfd,
                           asymbol *symbol, symbol_info *ret));
d571 3
a573 4
boolean
NAME(aout,find_nearest_line) PARAMS ((bfd *abfd, asection *section,
      asymbol **symbols, bfd_vma offset, CONST char **filename_ptr,
      CONST char **functionname_ptr, unsigned int *line_ptr));
d575 2
a576 2
long
NAME(aout,read_minisymbols) PARAMS ((bfd *, boolean, PTR *, unsigned int *));
d578 2
a579 3
asymbol *
NAME(aout,minisymbol_to_symbol) PARAMS ((bfd *, boolean, const PTR,
					 asymbol *));
d581 2
a582 2
int
NAME(aout,sizeof_headers) PARAMS ((bfd *abfd, boolean exec));
d584 2
a585 3
boolean
NAME(aout,adjust_sizes_and_vmas) PARAMS ((bfd *abfd,
       bfd_size_type *text_size, file_ptr *text_end));
d587 2
a588 3
void
NAME(aout,swap_exec_header_in) PARAMS ((bfd *abfd,
       struct external_exec *raw_bytes, struct internal_exec *execp));
d590 2
a591 3
void
NAME(aout,swap_exec_header_out) PARAMS ((bfd *abfd,
       struct internal_exec *execp, struct external_exec *raw_bytes));
d593 1
a593 2
struct bfd_hash_entry *
NAME(aout,link_hash_newfunc)
d596 11
a606 17
boolean
NAME(aout,link_hash_table_init)
     PARAMS ((struct aout_link_hash_table *, bfd *,
	      struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
					  struct bfd_hash_table *,
					  const char *)));

struct bfd_link_hash_table *
NAME(aout,link_hash_table_create) PARAMS ((bfd *));

boolean
NAME(aout,link_add_symbols) PARAMS ((bfd *, struct bfd_link_info *));

boolean
NAME(aout,final_link) PARAMS ((bfd *, struct bfd_link_info *,
			       void (*) (bfd *, file_ptr *, file_ptr *,
					 file_ptr *)));
d608 3
a610 2
boolean
NAME(aout,bfd_free_cached_info) PARAMS ((bfd *));
d612 6
a617 1
/* A.out uses the generic versions of these routines... */
d647 5
a651 5
	if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0) return false;	      \
	if (bfd_write ((PTR) &exec_bytes, 1, EXEC_BYTES_SIZE, abfd)	      \
	    != EXEC_BYTES_SIZE)						      \
	  return false;							      \
	/* Now write out reloc info, followed by syms and strings */	      \
d656 2
a657 2
	    if (bfd_seek (abfd, (file_ptr)(N_SYMOFF(*execp)), SEEK_SET) != 0) \
	      return false;						      \
d659 2
a660 1
	    if (! NAME(aout,write_syms)(abfd)) return false;		      \
d663 2
a664 2
	if (bfd_seek (abfd, (file_ptr)(N_TRELOFF(*execp)), SEEK_SET) != 0)    \
	  return false;						      	      \
d666 1
a666 1
	  return false;						      	      \
d668 25
a692 6
	if (bfd_seek (abfd, (file_ptr)(N_DRELOFF(*execp)), SEEK_SET) != 0)    \
	  return false;						      	      \
	if (!NAME(aout,squirt_out_relocs)(abfd, obj_datasec (abfd)))          \
	  return false;						      	      \
      }									      
#endif
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@d234 1
a234 1
  M_VAX_NETBSD = 140,	/* NetBSD/vax binary */
d238 1
@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d3 1
a3 1
   2000, 2001, 2002
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a31 47
/* Macros for accessing components in an aout header.  Saves cluttering
   the source with (bfd_vma) and (bfd_byte *) casts.  */

#define H_PUT_64(abfd, val, where) \
  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_32(abfd, val, where) \
  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_16(abfd, val, where) \
  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_8 bfd_h_put_8

#define H_PUT_S64(abfd, val, where) \
  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S32(abfd, val, where) \
  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S16(abfd, val, where) \
  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S8 bfd_h_put_signed_8

#define H_GET_64(abfd, where) \
  bfd_h_get_64 ((abfd), (bfd_byte *) (where))

#define H_GET_32(abfd, where) \
  bfd_h_get_32 ((abfd), (bfd_byte *) (where))

#define H_GET_16(abfd, where) \
  bfd_h_get_16 ((abfd), (bfd_byte *) (where))

#define H_GET_8 bfd_h_get_8

#define H_GET_S64(abfd, where) \
  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))

#define H_GET_S32(abfd, where) \
  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))

#define H_GET_S16(abfd, where) \
  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))

#define H_GET_S8 bfd_h_get_signed_8

a33 3
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
d35 3
a37 5
#define GET_WORD H_GET_64
#define GET_SWORD H_GET_S64
#define GET_MAGIC H_GET_32
#define PUT_WORD H_PUT_64
#define PUT_MAGIC H_PUT_32
d39 1
a39 1
#define NAME(x,y) CONCAT3 (x,_64_,y)
d41 1
a41 1
#define JNAME(x) CONCAT2 (x,_64)
a42 12
#else
#if ARCH_SIZE==16
#define GET_WORD H_GET_16
#define GET_SWORD H_GET_S16
#define GET_MAGIC H_GET_16
#define PUT_WORD H_PUT_16
#define PUT_MAGIC H_PUT_16
#ifndef NAME
#define NAME(x,y) CONCAT3 (x,_16_,y)
#endif
#define JNAME(x) CONCAT2 (x,_16)
#define BYTES_IN_WORD 2
d44 3
a46 5
#define GET_WORD H_GET_32
#define GET_SWORD H_GET_S32
#define GET_MAGIC H_GET_32
#define PUT_WORD H_PUT_32
#define PUT_MAGIC H_PUT_32
d48 1
a48 1
#define NAME(x,y) CONCAT3 (x,_32_,y)
d50 1
a50 1
#define JNAME(x) CONCAT2 (x,_32)
a52 1
#endif /* ARCH_SIZE==64 */
d67 1
a67 1
  bfd_boolean written;
d90 1
a90 1
    (bfd_boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func), \
d129 1
a129 2
  bfd_boolean (*set_sizes)
    PARAMS ((bfd *));
d138 3
a140 3
  bfd_boolean (*add_dynamic_symbols)
    PARAMS ((bfd *, struct bfd_link_info *, struct external_nlist **,
	     bfd_size_type *, char **));
d144 5
a148 4
  bfd_boolean (*add_one_symbol)
    PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword,
	     asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
	     struct bfd_link_hash_entry **));
d151 1
a151 2
  bfd_boolean (*link_dynamic_object)
    PARAMS ((struct bfd_link_info *, bfd *));
d155 2
a156 2
  bfd_boolean (*write_dynamic_symbol)
    PARAMS ((bfd *, struct bfd_link_info *, struct aout_link_hash_entry *));
d160 1
a160 1
     TRUE, the reloc will be skipped.  *RELOCATION may be changed to
d162 7
a168 5
  bfd_boolean (*check_dynamic_reloc)
    PARAMS ((struct bfd_link_info *info, bfd *input_bfd,
	     asection *input_section, struct aout_link_hash_entry *h,
	     PTR reloc, bfd_byte *contents, bfd_boolean *skip,
	     bfd_vma *relocation));
d172 1
a172 2
  bfd_boolean (*finish_dynamic_link)
    PARAMS ((bfd *, struct bfd_link_info *));
d175 1
a175 1
	((const struct aout_backend_data *)((abfd)->xvec->backend_data))
d202 1
a202 1
/* Magic number is written
d218 4
a221 4
  /* Skip a bunch so we don't run into any of SUN's numbers.  */
  /* Make these up for the ns32k.  */
  M_NS32032 = (64),	/* ns32032 running ? */
  M_NS32532 = (64 + 5),	/* ns32532 running mach */
a237 1
  M_VAX4K_NETBSD = 150,	/* NetBSD/vax 4K pages binary */
d276 1
a276 1
((exec).a_info = (dynamic) ? (long) ((exec).a_info | 0x80000000) : \
d311 2
a312 2

  /* For ease, we do this.  */
d322 1
a322 1
  /* Size of a relocation entry in external form.  */
d325 1
a325 1
  /* Size of a symbol table entry in external form.  */
d328 1
a328 1
  /* Page size - needed for alignment of demand paged files.  */
d331 1
a331 1
  /* Segment size - needed for alignment of demand paged files.  */
d341 1
a341 1
  /* Used when a bfd supports several highly similar formats.  */
d406 1
a406 1
   macro is only ever applied to an asymbol.  */
d424 1
a424 1
/* Prototype declarations for functions defined in aoutx.h.  */
d426 2
a427 2
extern bfd_boolean NAME(aout,squirt_out_relocs)
  PARAMS ((bfd *, asection *));
d429 2
a430 2
extern bfd_boolean NAME(aout,make_sections)
  PARAMS ((bfd *));
d432 4
a435 2
extern const bfd_target * NAME(aout,some_aout_object_p)
  PARAMS ((bfd *, struct internal_exec *, const bfd_target *(*) (bfd *)));
d437 2
a438 2
extern bfd_boolean NAME(aout,mkobject)
  PARAMS ((bfd *));
d440 4
a443 2
extern enum machine_type NAME(aout,machine_type)
  PARAMS ((enum bfd_architecture, unsigned long, bfd_boolean *));
d445 3
a447 2
extern bfd_boolean NAME(aout,set_arch_mach)
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
d449 2
a450 2
extern bfd_boolean NAME(aout,new_section_hook)
  PARAMS ((bfd *, asection *));
d452 3
a454 2
extern bfd_boolean NAME(aout,set_section_contents)
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d456 2
a457 2
extern asymbol * NAME(aout,make_empty_symbol)
  PARAMS ((bfd *));
d459 6
a464 3
extern bfd_boolean NAME(aout,translate_symbol_table)
  PARAMS ((bfd *, aout_symbol_type *, struct external_nlist *, bfd_size_type,
	   char *, bfd_size_type, bfd_boolean));
d466 2
a467 2
extern bfd_boolean NAME(aout,slurp_symbol_table)
  PARAMS ((bfd *));
d469 2
a470 2
extern bfd_boolean NAME(aout,write_syms)
  PARAMS ((bfd *));
d472 2
a473 2
extern void NAME(aout,reclaim_symbol_table)
  PARAMS ((bfd *));
d475 2
a476 2
extern long NAME(aout,get_symtab_upper_bound)
  PARAMS ((bfd *));
d478 2
a479 2
extern long NAME(aout,get_symtab)
  PARAMS ((bfd *, asymbol **));
d481 6
a486 6
extern void NAME(aout,swap_ext_reloc_in)
  PARAMS ((bfd *, struct reloc_ext_external *, arelent *, asymbol **,
	   bfd_size_type));
extern void NAME(aout,swap_std_reloc_in)
  PARAMS ((bfd *, struct reloc_std_external *, arelent *, asymbol **,
	   bfd_size_type));
d488 3
a490 2
extern reloc_howto_type * NAME(aout,reloc_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d492 3
a494 2
extern bfd_boolean NAME(aout,slurp_reloc_table)
  PARAMS ((bfd *, sec_ptr, asymbol **));
d496 3
a498 2
extern long NAME(aout,canonicalize_reloc)
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
d500 2
a501 2
extern long NAME(aout,get_reloc_upper_bound)
  PARAMS ((bfd *, sec_ptr));
d503 2
a504 2
extern void NAME(aout,reclaim_reloc)
  PARAMS ((bfd *, sec_ptr));
d506 2
a507 2
extern alent * NAME(aout,get_lineno)
  PARAMS ((bfd *, asymbol *));
d509 3
a511 2
extern void NAME(aout,print_symbol)
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
d513 3
a515 2
extern void NAME(aout,get_symbol_info)
  PARAMS ((bfd *, asymbol *, symbol_info *));
d517 4
a520 3
extern bfd_boolean NAME(aout,find_nearest_line)
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
d522 2
a523 2
extern long NAME(aout,read_minisymbols)
  PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));
d525 3
a527 2
extern asymbol * NAME(aout,minisymbol_to_symbol)
  PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));
d529 2
a530 2
extern int NAME(aout,sizeof_headers)
  PARAMS ((bfd *, bfd_boolean));
d532 3
a534 2
extern bfd_boolean NAME(aout,adjust_sizes_and_vmas)
  PARAMS ((bfd *, bfd_size_type *, file_ptr *));
d536 3
a538 2
extern void NAME(aout,swap_exec_header_in)
  PARAMS ((bfd *, struct external_exec *, struct internal_exec *));
d540 3
a542 2
extern void NAME(aout,swap_exec_header_out)
  PARAMS ((bfd *, struct internal_exec *, struct external_exec *));
d544 2
a545 1
extern struct bfd_hash_entry * NAME(aout,link_hash_newfunc)
d548 17
a564 11
extern bfd_boolean NAME(aout,link_hash_table_init)
  PARAMS ((struct aout_link_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));

extern struct bfd_link_hash_table * NAME(aout,link_hash_table_create)
  PARAMS ((bfd *));

extern bfd_boolean NAME(aout,link_add_symbols)
  PARAMS ((bfd *, struct bfd_link_info *));
d566 2
a567 3
extern bfd_boolean NAME(aout,final_link)
  PARAMS ((bfd *, struct bfd_link_info *,
	   void (*) (bfd *, file_ptr *, file_ptr *, file_ptr *)));
d569 1
a569 6
extern bfd_boolean NAME(aout,bfd_free_cached_info)
  PARAMS ((bfd *));

/* A.out uses the generic versions of these routines...  */

#define	aout_16_get_section_contents	_bfd_generic_get_section_contents
d599 5
a603 5
	if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0		      \
	    || bfd_bwrite ((PTR) &exec_bytes, (bfd_size_type) EXEC_BYTES_SIZE, \
			  abfd) != EXEC_BYTES_SIZE)			      \
	  return FALSE;							      \
	/* Now write out reloc info, followed by syms and strings.  */	      \
d608 2
a609 2
	    if (bfd_seek (abfd, (file_ptr) (N_SYMOFF(*execp)), SEEK_SET) != 0)\
	      return FALSE;						      \
d611 1
a611 2
	    if (! NAME(aout,write_syms) (abfd))				      \
	      return FALSE;						      \
d614 2
a615 2
	if (bfd_seek (abfd, (file_ptr) (N_TRELOFF(*execp)), SEEK_SET) != 0)   \
	  return FALSE;						      	      \
d617 1
a617 1
	  return FALSE;						      	      \
d619 6
a624 25
	if (bfd_seek (abfd, (file_ptr) (N_DRELOFF(*execp)), SEEK_SET) != 0)   \
	  return FALSE;						      	      \
	if (!NAME(aout,squirt_out_relocs) (abfd, obj_datasec (abfd)))         \
	  return FALSE;						      	      \
      }
#endif

/* Test if a read-only section can be merged with .text.  This is
   possible if:

   1. Section has file contents and is read-only.
   2. The VMA of the section is after the end of .text and before
      the start of .data.
   3. The image is demand-pageable (otherwise, a_text in the header
      will not reflect the gap between .text and .data).  */

#define aout_section_merge_with_text_p(abfd, sec)			\
  (((sec)->flags & (SEC_HAS_CONTENTS | SEC_READONLY)) ==		\
      (SEC_HAS_CONTENTS | SEC_READONLY)					\
   && obj_textsec (abfd) != NULL					\
   && obj_datasec (abfd) != NULL					\
   && (sec)->vma >= (obj_textsec (abfd)->vma +				\
		     obj_textsec (abfd)->_cooked_size)			\
   && ((sec)->vma + (sec)->_cooked_size) <= obj_datasec (abfd)->vma	\
   && ((abfd)->flags & D_PAGED) != 0)
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d32 11
a42 1
/* Macros for accessing components in an aout header.  */
a43 3
#define H_PUT_64 bfd_h_put_64
#define H_PUT_32 bfd_h_put_32
#define H_PUT_16 bfd_h_put_16
d45 10
a54 3
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
d56 10
a65 3
#define H_GET_64 bfd_h_get_64
#define H_GET_32 bfd_h_get_32
#define H_GET_16 bfd_h_get_16
d67 10
a76 3
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
d516 1
a516 1
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
d537 1
a537 1
extern long NAME(aout,canonicalize_symtab)
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d3 1
a3 1
   2000, 2001, 2002
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a31 47
/* Macros for accessing components in an aout header.  Saves cluttering
   the source with (bfd_vma) and (bfd_byte *) casts.  */

#define H_PUT_64(abfd, val, where) \
  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_32(abfd, val, where) \
  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_16(abfd, val, where) \
  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_8 bfd_h_put_8

#define H_PUT_S64(abfd, val, where) \
  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S32(abfd, val, where) \
  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S16(abfd, val, where) \
  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S8 bfd_h_put_signed_8

#define H_GET_64(abfd, where) \
  bfd_h_get_64 ((abfd), (bfd_byte *) (where))

#define H_GET_32(abfd, where) \
  bfd_h_get_32 ((abfd), (bfd_byte *) (where))

#define H_GET_16(abfd, where) \
  bfd_h_get_16 ((abfd), (bfd_byte *) (where))

#define H_GET_8 bfd_h_get_8

#define H_GET_S64(abfd, where) \
  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))

#define H_GET_S32(abfd, where) \
  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))

#define H_GET_S16(abfd, where) \
  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))

#define H_GET_S8 bfd_h_get_signed_8

a33 3
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
d35 3
a37 5
#define GET_WORD H_GET_64
#define GET_SWORD H_GET_S64
#define GET_MAGIC H_GET_32
#define PUT_WORD H_PUT_64
#define PUT_MAGIC H_PUT_32
d39 1
a39 1
#define NAME(x,y) CONCAT3 (x,_64_,y)
d41 1
a41 1
#define JNAME(x) CONCAT2 (x,_64)
a42 12
#else
#if ARCH_SIZE==16
#define GET_WORD H_GET_16
#define GET_SWORD H_GET_S16
#define GET_MAGIC H_GET_16
#define PUT_WORD H_PUT_16
#define PUT_MAGIC H_PUT_16
#ifndef NAME
#define NAME(x,y) CONCAT3 (x,_16_,y)
#endif
#define JNAME(x) CONCAT2 (x,_16)
#define BYTES_IN_WORD 2
d44 3
a46 5
#define GET_WORD H_GET_32
#define GET_SWORD H_GET_S32
#define GET_MAGIC H_GET_32
#define PUT_WORD H_PUT_32
#define PUT_MAGIC H_PUT_32
d48 1
a48 1
#define NAME(x,y) CONCAT3 (x,_32_,y)
d50 1
a50 1
#define JNAME(x) CONCAT2 (x,_32)
a52 1
#endif /* ARCH_SIZE==64 */
d67 1
a67 1
  bfd_boolean written;
d90 1
a90 1
    (bfd_boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func), \
d129 1
a129 2
  bfd_boolean (*set_sizes)
    PARAMS ((bfd *));
d138 3
a140 3
  bfd_boolean (*add_dynamic_symbols)
    PARAMS ((bfd *, struct bfd_link_info *, struct external_nlist **,
	     bfd_size_type *, char **));
d144 5
a148 4
  bfd_boolean (*add_one_symbol)
    PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword,
	     asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
	     struct bfd_link_hash_entry **));
d151 1
a151 2
  bfd_boolean (*link_dynamic_object)
    PARAMS ((struct bfd_link_info *, bfd *));
d155 2
a156 2
  bfd_boolean (*write_dynamic_symbol)
    PARAMS ((bfd *, struct bfd_link_info *, struct aout_link_hash_entry *));
d160 1
a160 1
     TRUE, the reloc will be skipped.  *RELOCATION may be changed to
d162 7
a168 5
  bfd_boolean (*check_dynamic_reloc)
    PARAMS ((struct bfd_link_info *info, bfd *input_bfd,
	     asection *input_section, struct aout_link_hash_entry *h,
	     PTR reloc, bfd_byte *contents, bfd_boolean *skip,
	     bfd_vma *relocation));
d172 1
a172 2
  bfd_boolean (*finish_dynamic_link)
    PARAMS ((bfd *, struct bfd_link_info *));
d175 1
a175 1
	((const struct aout_backend_data *)((abfd)->xvec->backend_data))
d202 1
a202 1
/* Magic number is written
d218 4
a221 4
  /* Skip a bunch so we don't run into any of SUN's numbers.  */
  /* Make these up for the ns32k.  */
  M_NS32032 = (64),	/* ns32032 running ? */
  M_NS32532 = (64 + 5),	/* ns32532 running mach */
d234 1
a234 1
  M_VAX_NETBSD = 140,	/* NetBSD/vax binary */
d238 1
a238 2
  M_POWERPC_NETBSD = 149, /* NetBSD/powerpc (big-endian) binary */
  M_VAX4K_NETBSD = 150,	/* NetBSD/vax 4K pages binary */
a240 4
  M_88K_OPENBSD = 153,	/* OpenBSD/m88k binary */
  M_HPPA_OPENBSD = 154,	/* OpenBSD/hppa binary */
  M_SPARC64_NETBSD = 156, /* NetBSD/sparc64 binary */
  M_X86_64_NETBSD = 157, /* NetBSD/amd64 binary */
d277 1
a277 1
((exec).a_info = (dynamic) ? (long) ((exec).a_info | 0x80000000) : \
d312 2
a313 2

  /* For ease, we do this.  */
d323 1
a323 1
  /* Size of a relocation entry in external form.  */
d326 1
a326 1
  /* Size of a symbol table entry in external form.  */
d329 1
a329 1
  /* Page size - needed for alignment of demand paged files.  */
d332 1
a332 1
  /* Segment size - needed for alignment of demand paged files.  */
d342 1
a342 1
  /* Used when a bfd supports several highly similar formats.  */
d407 1
a407 1
   macro is only ever applied to an asymbol.  */
d425 1
a425 1
/* Prototype declarations for functions defined in aoutx.h.  */
d427 2
a428 2
extern bfd_boolean NAME(aout,squirt_out_relocs)
  PARAMS ((bfd *, asection *));
d430 2
a431 2
extern bfd_boolean NAME(aout,make_sections)
  PARAMS ((bfd *));
d433 4
a436 2
extern const bfd_target * NAME(aout,some_aout_object_p)
  PARAMS ((bfd *, struct internal_exec *, const bfd_target *(*) (bfd *)));
d438 2
a439 2
extern bfd_boolean NAME(aout,mkobject)
  PARAMS ((bfd *));
d441 4
a444 2
extern enum machine_type NAME(aout,machine_type)
  PARAMS ((enum bfd_architecture, unsigned long, bfd_boolean *));
d446 3
a448 2
extern bfd_boolean NAME(aout,set_arch_mach)
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
d450 2
a451 2
extern bfd_boolean NAME(aout,new_section_hook)
  PARAMS ((bfd *, asection *));
d453 3
a455 2
extern bfd_boolean NAME(aout,set_section_contents)
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d457 2
a458 2
extern asymbol * NAME(aout,make_empty_symbol)
  PARAMS ((bfd *));
d460 6
a465 3
extern bfd_boolean NAME(aout,translate_symbol_table)
  PARAMS ((bfd *, aout_symbol_type *, struct external_nlist *, bfd_size_type,
	   char *, bfd_size_type, bfd_boolean));
d467 2
a468 2
extern bfd_boolean NAME(aout,slurp_symbol_table)
  PARAMS ((bfd *));
d470 2
a471 2
extern bfd_boolean NAME(aout,write_syms)
  PARAMS ((bfd *));
d473 2
a474 2
extern void NAME(aout,reclaim_symbol_table)
  PARAMS ((bfd *));
d476 2
a477 2
extern long NAME(aout,get_symtab_upper_bound)
  PARAMS ((bfd *));
d479 2
a480 2
extern long NAME(aout,get_symtab)
  PARAMS ((bfd *, asymbol **));
d482 6
a487 6
extern void NAME(aout,swap_ext_reloc_in)
  PARAMS ((bfd *, struct reloc_ext_external *, arelent *, asymbol **,
	   bfd_size_type));
extern void NAME(aout,swap_std_reloc_in)
  PARAMS ((bfd *, struct reloc_std_external *, arelent *, asymbol **,
	   bfd_size_type));
d489 3
a491 2
extern reloc_howto_type * NAME(aout,reloc_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d493 3
a495 2
extern bfd_boolean NAME(aout,slurp_reloc_table)
  PARAMS ((bfd *, sec_ptr, asymbol **));
d497 3
a499 2
extern long NAME(aout,canonicalize_reloc)
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
d501 2
a502 2
extern long NAME(aout,get_reloc_upper_bound)
  PARAMS ((bfd *, sec_ptr));
d504 2
a505 2
extern void NAME(aout,reclaim_reloc)
  PARAMS ((bfd *, sec_ptr));
d507 2
a508 2
extern alent * NAME(aout,get_lineno)
  PARAMS ((bfd *, asymbol *));
d510 3
a512 2
extern void NAME(aout,print_symbol)
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
d514 3
a516 2
extern void NAME(aout,get_symbol_info)
  PARAMS ((bfd *, asymbol *, symbol_info *));
d518 4
a521 3
extern bfd_boolean NAME(aout,find_nearest_line)
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
d523 2
a524 2
extern long NAME(aout,read_minisymbols)
  PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));
d526 3
a528 2
extern asymbol * NAME(aout,minisymbol_to_symbol)
  PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));
d530 2
a531 2
extern int NAME(aout,sizeof_headers)
  PARAMS ((bfd *, bfd_boolean));
d533 3
a535 2
extern bfd_boolean NAME(aout,adjust_sizes_and_vmas)
  PARAMS ((bfd *, bfd_size_type *, file_ptr *));
d537 3
a539 2
extern void NAME(aout,swap_exec_header_in)
  PARAMS ((bfd *, struct external_exec *, struct internal_exec *));
d541 3
a543 2
extern void NAME(aout,swap_exec_header_out)
  PARAMS ((bfd *, struct internal_exec *, struct external_exec *));
d545 2
a546 1
extern struct bfd_hash_entry * NAME(aout,link_hash_newfunc)
d549 17
a565 11
extern bfd_boolean NAME(aout,link_hash_table_init)
  PARAMS ((struct aout_link_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));

extern struct bfd_link_hash_table * NAME(aout,link_hash_table_create)
  PARAMS ((bfd *));

extern bfd_boolean NAME(aout,link_add_symbols)
  PARAMS ((bfd *, struct bfd_link_info *));
d567 2
a568 3
extern bfd_boolean NAME(aout,final_link)
  PARAMS ((bfd *, struct bfd_link_info *,
	   void (*) (bfd *, file_ptr *, file_ptr *, file_ptr *)));
d570 1
a570 6
extern bfd_boolean NAME(aout,bfd_free_cached_info)
  PARAMS ((bfd *));

/* A.out uses the generic versions of these routines...  */

#define	aout_16_get_section_contents	_bfd_generic_get_section_contents
d600 5
a604 5
	if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0		      \
	    || bfd_bwrite ((PTR) &exec_bytes, (bfd_size_type) EXEC_BYTES_SIZE, \
			  abfd) != EXEC_BYTES_SIZE)			      \
	  return FALSE;							      \
	/* Now write out reloc info, followed by syms and strings.  */	      \
d609 2
a610 2
	    if (bfd_seek (abfd, (file_ptr) (N_SYMOFF(*execp)), SEEK_SET) != 0)\
	      return FALSE;						      \
d612 1
a612 2
	    if (! NAME(aout,write_syms) (abfd))				      \
	      return FALSE;						      \
d615 2
a616 2
	if (bfd_seek (abfd, (file_ptr) (N_TRELOFF(*execp)), SEEK_SET) != 0)   \
	  return FALSE;						      	      \
d618 1
a618 1
	  return FALSE;						      	      \
d620 6
a625 25
	if (bfd_seek (abfd, (file_ptr) (N_DRELOFF(*execp)), SEEK_SET) != 0)   \
	  return FALSE;						      	      \
	if (!NAME(aout,squirt_out_relocs) (abfd, obj_datasec (abfd)))         \
	  return FALSE;						      	      \
      }
#endif

/* Test if a read-only section can be merged with .text.  This is
   possible if:

   1. Section has file contents and is read-only.
   2. The VMA of the section is after the end of .text and before
      the start of .data.
   3. The image is demand-pageable (otherwise, a_text in the header
      will not reflect the gap between .text and .data).  */

#define aout_section_merge_with_text_p(abfd, sec)			\
  (((sec)->flags & (SEC_HAS_CONTENTS | SEC_READONLY)) ==		\
      (SEC_HAS_CONTENTS | SEC_READONLY)					\
   && obj_textsec (abfd) != NULL					\
   && obj_datasec (abfd) != NULL					\
   && (sec)->vma >= (obj_textsec (abfd)->vma +				\
		     obj_textsec (abfd)->_cooked_size)			\
   && ((sec)->vma + (sec)->_cooked_size) <= obj_datasec (abfd)->vma	\
   && ((abfd)->flags & D_PAGED) != 0)
@

