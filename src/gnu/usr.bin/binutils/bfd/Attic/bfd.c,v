head	1.4;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.08.11.20.46.58;	author tg;	state dead;
branches;
next	1.3;

1.3
date	2004.04.08.23.55.57;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.23.20.59.59;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.38.52;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.38.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.25.53;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.40.25;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.03.52;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.06.02;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove old binutils
@
text
@/* $MirBSD: src/gnu/usr.bin/binutils/bfd/bfd.c,v 1.3 2004/04/08 23:55:57 tg Exp $ */

/* Generic BFD library interface and support routines.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/*
SECTION
	<<typedef bfd>>

	A BFD has type <<bfd>>; objects of this type are the
	cornerstone of any application using BFD. Using BFD
	consists of making references though the BFD and to data in the BFD.

	Here is the structure that defines the type <<bfd>>.  It
	contains the major data about the file and pointers
	to the rest of the data.

CODE_FRAGMENT
.
.struct bfd
.{
.  {* A unique identifier of the BFD  *}
.  unsigned int id;
.
.  {* The filename the application opened the BFD with.  *}
.  const char *filename;
.
.  {* A pointer to the target jump table.  *}
.  const struct bfd_target *xvec;
.
.  {* To avoid dragging too many header files into every file that
.     includes `<<bfd.h>>', IOSTREAM has been declared as a "char *",
.     and MTIME as a "long".  Their correct types, to which they
.     are cast when used, are "FILE *" and "time_t".    The iostream
.     is the result of an fopen on the filename.  However, if the
.     BFD_IN_MEMORY flag is set, then iostream is actually a pointer
.     to a bfd_in_memory struct.  *}
.  PTR iostream;
.
.  {* Is the file descriptor being cached?  That is, can it be closed as
.     needed, and re-opened when accessed later?  *}
.  bfd_boolean cacheable;
.
.  {* Marks whether there was a default target specified when the
.     BFD was opened. This is used to select which matching algorithm
.     to use to choose the back end.  *}
.  bfd_boolean target_defaulted;
.
.  {* The caching routines use these to maintain a
.     least-recently-used list of BFDs.  *}
.  struct bfd *lru_prev, *lru_next;
.
.  {* When a file is closed by the caching routines, BFD retains
.     state information on the file here...  *}
.  ufile_ptr where;
.
.  {* ... and here: (``once'' means at least once).  *}
.  bfd_boolean opened_once;
.
.  {* Set if we have a locally maintained mtime value, rather than
.     getting it from the file each time.  *}
.  bfd_boolean mtime_set;
.
.  {* File modified time, if mtime_set is TRUE.  *}
.  long mtime;
.
.  {* Reserved for an unimplemented file locking extension.  *}
.  int ifd;
.
.  {* The format which belongs to the BFD. (object, core, etc.)  *}
.  bfd_format format;
.
.  {* The direction with which the BFD was opened.  *}
.  enum bfd_direction
.    {
.      no_direction = 0,
.      read_direction = 1,
.      write_direction = 2,
.      both_direction = 3
.    }
.  direction;
.
.  {* Format_specific flags.  *}
.  flagword flags;
.
.  {* Currently my_archive is tested before adding origin to
.     anything. I believe that this can become always an add of
.     origin, with origin set to 0 for non archive files.  *}
.  ufile_ptr origin;
.
.  {* Remember when output has begun, to stop strange things
.     from happening.  *}
.  bfd_boolean output_has_begun;
.
.  {* A hash table for section names.  *}
.  struct bfd_hash_table section_htab;
.
.  {* Pointer to linked list of sections.  *}
.  struct sec *sections;
.
.  {* The place where we add to the section list.  *}
.  struct sec **section_tail;
.
.  {* The number of sections.  *}
.  unsigned int section_count;
.
.  {* Stuff only useful for object files:
.     The start address.  *}
.  bfd_vma start_address;
.
.  {* Used for input and output.  *}
.  unsigned int symcount;
.
.  {* Symbol table for output BFD (with symcount entries).  *}
.  struct symbol_cache_entry  **outsymbols;
.
.  {* Used for slurped dynamic symbol tables.  *}
.  unsigned int dynsymcount;
.
.  {* Pointer to structure which contains architecture information.  *}
.  const struct bfd_arch_info *arch_info;
.
.  {* Stuff only useful for archives.  *}
.  PTR arelt_data;
.  struct bfd *my_archive;      {* The containing archive BFD.  *}
.  struct bfd *next;            {* The next BFD in the archive.  *}
.  struct bfd *archive_head;    {* The first BFD in the archive.  *}
.  bfd_boolean has_armap;
.
.  {* A chain of BFD structures involved in a link.  *}
.  struct bfd *link_next;
.
.  {* A field used by _bfd_generic_link_add_archive_symbols.  This will
.     be used only for archive elements.  *}
.  int archive_pass;
.
.  {* Used by the back end to hold private data.  *}
.  union
.    {
.      struct aout_data_struct *aout_data;
.      struct artdata *aout_ar_data;
.      struct _oasys_data *oasys_obj_data;
.      struct _oasys_ar_data *oasys_ar_data;
.      struct coff_tdata *coff_obj_data;
.      struct pe_tdata *pe_obj_data;
.      struct xcoff_tdata *xcoff_obj_data;
.      struct ecoff_tdata *ecoff_obj_data;
.      struct ieee_data_struct *ieee_data;
.      struct ieee_ar_data_struct *ieee_ar_data;
.      struct srec_data_struct *srec_data;
.      struct ihex_data_struct *ihex_data;
.      struct tekhex_data_struct *tekhex_data;
.      struct elf_obj_tdata *elf_obj_data;
.      struct nlm_obj_tdata *nlm_obj_data;
.      struct bout_data_struct *bout_data;
.      struct mmo_data_struct *mmo_data;
.      struct sun_core_struct *sun_core_data;
.      struct sco5_core_struct *sco5_core_data;
.      struct trad_core_struct *trad_core_data;
.      struct som_data_struct *som_data;
.      struct hpux_core_struct *hpux_core_data;
.      struct hppabsd_core_struct *hppabsd_core_data;
.      struct sgi_core_struct *sgi_core_data;
.      struct lynx_core_struct *lynx_core_data;
.      struct osf_core_struct *osf_core_data;
.      struct cisco_core_struct *cisco_core_data;
.      struct versados_data_struct *versados_data;
.      struct netbsd_core_struct *netbsd_core_data;
.      struct mach_o_data_struct *mach_o_data;
.      struct mach_o_fat_data_struct *mach_o_fat_data;
.      struct bfd_pef_data_struct *pef_data;
.      struct bfd_pef_xlib_data_struct *pef_xlib_data;
.      struct bfd_sym_data_struct *sym_data;
.      PTR any;
.    }
.  tdata;
.
.  {* Used by the application to hold private data.  *}
.  PTR usrdata;
.
.  {* Where all the allocated stuff under this BFD goes.  This is a
.     struct objalloc *, but we use PTR to avoid requiring the inclusion of
.     objalloc.h.  *}
.  PTR memory;
.};
.
*/

#include "bfd.h"
#include "bfdver.h"
#include "sysdep.h"

#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#include "libiberty.h"
#include "safe-ctype.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "coff/sym.h"
#include "libcoff.h"
#include "libecoff.h"
#undef obj_symbols
#include "elf-bfd.h"

/* provide storage for subsystem, stack and heap data which may have been
   passed in on the command line.  Ld puts this data into a bfd_link_info
   struct which ultimately gets passed in to the bfd.  When it arrives, copy
   it to the following struct so that the data will be available in coffcode.h
   where it is needed.  The typedef's used are defined in bfd.h */

/*
SECTION
	Error reporting

	Most BFD functions return nonzero on success (check their
	individual documentation for precise semantics).  On an error,
	they call <<bfd_set_error>> to set an error condition that callers
	can check by calling <<bfd_get_error>>.
        If that returns <<bfd_error_system_call>>, then check
	<<errno>>.

	The easiest way to report a BFD error to the user is to
	use <<bfd_perror>>.

SUBSECTION
	Type <<bfd_error_type>>

	The values returned by <<bfd_get_error>> are defined by the
	enumerated type <<bfd_error_type>>.

CODE_FRAGMENT
.
.typedef enum bfd_error
.{
.  bfd_error_no_error = 0,
.  bfd_error_system_call,
.  bfd_error_invalid_target,
.  bfd_error_wrong_format,
.  bfd_error_wrong_object_format,
.  bfd_error_invalid_operation,
.  bfd_error_no_memory,
.  bfd_error_no_symbols,
.  bfd_error_no_armap,
.  bfd_error_no_more_archived_files,
.  bfd_error_malformed_archive,
.  bfd_error_file_not_recognized,
.  bfd_error_file_ambiguously_recognized,
.  bfd_error_no_contents,
.  bfd_error_nonrepresentable_section,
.  bfd_error_no_debug_section,
.  bfd_error_bad_value,
.  bfd_error_file_truncated,
.  bfd_error_file_too_big,
.  bfd_error_invalid_error_code
.}
.bfd_error_type;
.
*/

static bfd_error_type bfd_error = bfd_error_no_error;

const char *const bfd_errmsgs[] =
{
  N_("No error"),
  N_("System call error"),
  N_("Invalid bfd target"),
  N_("File in wrong format"),
  N_("Archive object file in wrong format"),
  N_("Invalid operation"),
  N_("Memory exhausted"),
  N_("No symbols"),
  N_("Archive has no index; run ranlib to add one"),
  N_("No more archived files"),
  N_("Malformed archive"),
  N_("File format not recognized"),
  N_("File format is ambiguous"),
  N_("Section has no contents"),
  N_("Nonrepresentable section on output"),
  N_("Symbol needs debug section which does not exist"),
  N_("Bad value"),
  N_("File truncated"),
  N_("File too big"),
  N_("#<Invalid error code>")
};

/*
FUNCTION
	bfd_get_error

SYNOPSIS
	bfd_error_type bfd_get_error (void);

DESCRIPTION
	Return the current BFD error condition.
*/

bfd_error_type
bfd_get_error ()
{
  return bfd_error;
}

/*
FUNCTION
	bfd_set_error

SYNOPSIS
	void bfd_set_error (bfd_error_type error_tag);

DESCRIPTION
	Set the BFD error condition to be @@var{error_tag}.
*/

void
bfd_set_error (error_tag)
     bfd_error_type error_tag;
{
  bfd_error = error_tag;
}

/*
FUNCTION
	bfd_errmsg

SYNOPSIS
	const char *bfd_errmsg (bfd_error_type error_tag);

DESCRIPTION
	Return a string describing the error @@var{error_tag}, or
	the system error if @@var{error_tag} is <<bfd_error_system_call>>.
*/

const char *
bfd_errmsg (error_tag)
     bfd_error_type error_tag;
{
#ifndef errno
  extern int errno;
#endif
  if (error_tag == bfd_error_system_call)
    return xstrerror (errno);

  if ((((int) error_tag < (int) bfd_error_no_error) ||
       ((int) error_tag > (int) bfd_error_invalid_error_code)))
    error_tag = bfd_error_invalid_error_code;/* sanity check */

  return _(bfd_errmsgs [(int)error_tag]);
}

/*
FUNCTION
	bfd_perror

SYNOPSIS
	void bfd_perror (const char *message);

DESCRIPTION
	Print to the standard error stream a string describing the
	last BFD error that occurred, or the last system error if
	the last BFD error was a system call failure.  If @@var{message}
	is non-NULL and non-empty, the error string printed is preceded
	by @@var{message}, a colon, and a space.  It is followed by a newline.
*/

void
bfd_perror (message)
     const char *message;
{
  if (bfd_get_error () == bfd_error_system_call)
    /* Must be a system error then.  */
    perror ((char *)message);
  else
    {
      if (message == NULL || *message == '\0')
	fprintf (stderr, "%s\n", bfd_errmsg (bfd_get_error ()));
      else
	fprintf (stderr, "%s: %s\n", message, bfd_errmsg (bfd_get_error ()));
    }
}

/*
SUBSECTION
	BFD error handler

	Some BFD functions want to print messages describing the
	problem.  They call a BFD error handler function.  This
	function may be overriden by the program.

	The BFD error handler acts like printf.

CODE_FRAGMENT
.
.typedef void (*bfd_error_handler_type) PARAMS ((const char *, ...));
.
*/

/* The program name used when printing BFD error messages.  */

static const char *_bfd_error_program_name;

/* This is the default routine to handle BFD error messages.  */

static void _bfd_default_error_handler PARAMS ((const char *s, ...));

static void
_bfd_default_error_handler VPARAMS ((const char *s, ...))
{
  if (_bfd_error_program_name != NULL)
    fprintf (stderr, "%s: ", _bfd_error_program_name);
  else
    fprintf (stderr, "BFD: ");

  VA_OPEN (p, s);
  VA_FIXEDARG (p, const char *, s);
  vfprintf (stderr, s, p);
  VA_CLOSE (p);

  fprintf (stderr, "\n");
}

/* This is a function pointer to the routine which should handle BFD
   error messages.  It is called when a BFD routine encounters an
   error for which it wants to print a message.  Going through a
   function pointer permits a program linked against BFD to intercept
   the messages and deal with them itself.  */

bfd_error_handler_type _bfd_error_handler = _bfd_default_error_handler;

/*
FUNCTION
	bfd_set_error_handler

SYNOPSIS
	bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);

DESCRIPTION
	Set the BFD error handler function.  Returns the previous
	function.
*/

bfd_error_handler_type
bfd_set_error_handler (pnew)
     bfd_error_handler_type pnew;
{
  bfd_error_handler_type pold;

  pold = _bfd_error_handler;
  _bfd_error_handler = pnew;
  return pold;
}

/*
FUNCTION
	bfd_set_error_program_name

SYNOPSIS
	void bfd_set_error_program_name (const char *);

DESCRIPTION
	Set the program name to use when printing a BFD error.  This
	is printed before the error message followed by a colon and
	space.  The string must not be changed after it is passed to
	this function.
*/

void
bfd_set_error_program_name (name)
     const char *name;
{
  _bfd_error_program_name = name;
}

/*
FUNCTION
	bfd_get_error_handler

SYNOPSIS
	bfd_error_handler_type bfd_get_error_handler (void);

DESCRIPTION
	Return the BFD error handler function.
*/

bfd_error_handler_type
bfd_get_error_handler ()
{
  return _bfd_error_handler;
}

/*
FUNCTION
	bfd_archive_filename

SYNOPSIS
	const char *bfd_archive_filename (bfd *);

DESCRIPTION
	For a BFD that is a component of an archive, returns a string
	with both the archive name and file name.  For other BFDs, just
	returns the file name.
*/

const char *
bfd_archive_filename (abfd)
     bfd *abfd;
{
  if (abfd->my_archive)
    {
      static size_t curr = 0;
      static char *buf;
      size_t needed;

      needed = (strlen (bfd_get_filename (abfd->my_archive))
		+ strlen (bfd_get_filename (abfd)) + 3);
      if (needed > curr)
	{
	  if (curr)
	    free (buf);
	  curr = needed + (needed >> 1);
	  buf = bfd_malloc ((bfd_size_type) curr);
	  /* If we can't malloc, fail safe by returning just the file
	     name. This function is only used when building error
	     messages.  */
	  if (!buf)
	    {
	      curr = 0;
	      return bfd_get_filename (abfd);
	    }
	}
      sprintf (buf, "%s(%s)", bfd_get_filename (abfd->my_archive),
	       bfd_get_filename (abfd));
      return buf;
    }
  else
    return bfd_get_filename (abfd);
}

/*
SECTION
	Symbols
*/

/*
FUNCTION
	bfd_get_reloc_upper_bound

SYNOPSIS
	long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);

DESCRIPTION
	Return the number of bytes required to store the
	relocation information associated with section @@var{sect}
	attached to bfd @@var{abfd}.  If an error occurs, return -1.

*/

long
bfd_get_reloc_upper_bound (abfd, asect)
     bfd *abfd;
     sec_ptr asect;
{
  if (abfd->format != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  return BFD_SEND (abfd, _get_reloc_upper_bound, (abfd, asect));
}

/*
FUNCTION
	bfd_canonicalize_reloc

SYNOPSIS
	long bfd_canonicalize_reloc
        	(bfd *abfd,
		asection *sec,
		arelent **loc,
		asymbol	**syms);

DESCRIPTION
	Call the back end associated with the open BFD
	@@var{abfd} and translate the external form of the relocation
	information attached to @@var{sec} into the internal canonical
	form.  Place the table into memory at @@var{loc}, which has
	been preallocated, usually by a call to
	<<bfd_get_reloc_upper_bound>>.  Returns the number of relocs, or
	-1 on error.

	The @@var{syms} table is also needed for horrible internal magic
	reasons.

*/
long
bfd_canonicalize_reloc (abfd, asect, location, symbols)
     bfd *abfd;
     sec_ptr asect;
     arelent **location;
     asymbol **symbols;
{
  if (abfd->format != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  return BFD_SEND (abfd, _bfd_canonicalize_reloc,
		   (abfd, asect, location, symbols));
}

/*
FUNCTION
	bfd_set_reloc

SYNOPSIS
	void bfd_set_reloc
	  (bfd *abfd, asection *sec, arelent **rel, unsigned int count);

DESCRIPTION
	Set the relocation pointer and count within
	section @@var{sec} to the values @@var{rel} and @@var{count}.
	The argument @@var{abfd} is ignored.

*/

void
bfd_set_reloc (ignore_abfd, asect, location, count)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     sec_ptr asect;
     arelent **location;
     unsigned int count;
{
  asect->orelocation = location;
  asect->reloc_count = count;
}

/*
FUNCTION
	bfd_set_file_flags

SYNOPSIS
	bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);

DESCRIPTION
	Set the flag word in the BFD @@var{abfd} to the value @@var{flags}.

	Possible errors are:
	o <<bfd_error_wrong_format>> - The target bfd was not of object format.
	o <<bfd_error_invalid_operation>> - The target bfd was open for reading.
	o <<bfd_error_invalid_operation>> -
	The flag word contained a bit which was not applicable to the
	type of file.  E.g., an attempt was made to set the <<D_PAGED>> bit
	on a BFD format which does not support demand paging.

*/

bfd_boolean
bfd_set_file_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
{
  if (abfd->format != bfd_object)
    {
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  if (bfd_read_p (abfd))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  bfd_get_file_flags (abfd) = flags;
  if ((flags & bfd_applicable_file_flags (abfd)) != flags)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  return TRUE;
}

void
bfd_assert (file, line)
     const char *file;
     int line;
{
  (*_bfd_error_handler) (_("BFD %s assertion fail %s:%d"),
			 BFD_VERSION_STRING, file, line);
}

/* A more or less friendly abort message.  In libbfd.h abort is
   defined to call this function.  */

#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif

void
_bfd_abort (file, line, fn)
     const char *file;
     int line;
     const char *fn;
{
  if (fn != NULL)
    (*_bfd_error_handler)
      (_("BFD %s internal error, aborting at %s line %d in %s\n"),
       BFD_VERSION_STRING, file, line, fn);
  else
    (*_bfd_error_handler)
      (_("BFD %s internal error, aborting at %s line %d\n"),
       BFD_VERSION_STRING, file, line);
  (*_bfd_error_handler) (_("Please report this bug.\n"));
  xexit (EXIT_FAILURE);
}

/*
FUNCTION
	bfd_get_arch_size

SYNOPSIS
 	int bfd_get_arch_size (bfd *abfd);

DESCRIPTION
	Returns the architecture address size, in bits, as determined
	by the object file's format.  For ELF, this information is
	included in the header.

RETURNS
	Returns the arch size in bits if known, <<-1>> otherwise.
*/

int
bfd_get_arch_size (abfd)
     bfd *abfd;
{
  if (abfd->xvec->flavour == bfd_target_elf_flavour)
    return (get_elf_backend_data (abfd))->s->arch_size;

  return -1;
}

/*
FUNCTION
	bfd_get_sign_extend_vma

SYNOPSIS
 	int bfd_get_sign_extend_vma (bfd *abfd);

DESCRIPTION
	Indicates if the target architecture "naturally" sign extends
	an address.  Some architectures implicitly sign extend address
	values when they are converted to types larger than the size
	of an address.  For instance, bfd_get_start_address() will
	return an address sign extended to fill a bfd_vma when this is
	the case.

RETURNS
	Returns <<1>> if the target architecture is known to sign
	extend addresses, <<0>> if the target architecture is known to
	not sign extend addresses, and <<-1>> otherwise.
*/

int
bfd_get_sign_extend_vma (abfd)
     bfd *abfd;
{
  char *name;

  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    return (get_elf_backend_data (abfd)->sign_extend_vma);

  name = bfd_get_target (abfd);

  /* Return a proper value for DJGPP COFF (an x86 COFF variant).
     This function is required for DWARF2 support, but there is
     no place to store this information in the COFF back end.
     Should enough other COFF targets add support for DWARF2,
     a place will have to be found.  Until then, this hack will do.  */
  if (strncmp (name, "coff-go32", sizeof ("coff-go32") - 1) == 0)
    return 1;

  bfd_set_error (bfd_error_wrong_format);
  return -1;
}

/*
FUNCTION
	bfd_set_start_address

SYNOPSIS
 	bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);

DESCRIPTION
	Make @@var{vma} the entry point of output BFD @@var{abfd}.

RETURNS
	Returns <<TRUE>> on success, <<FALSE>> otherwise.
*/

bfd_boolean
bfd_set_start_address (abfd, vma)
     bfd *abfd;
     bfd_vma vma;
{
  abfd->start_address = vma;
  return TRUE;
}

/*
FUNCTION
	bfd_get_gp_size

SYNOPSIS
	unsigned int bfd_get_gp_size (bfd *abfd);

DESCRIPTION
	Return the maximum size of objects to be optimized using the GP
	register under MIPS ECOFF.  This is typically set by the <<-G>>
	argument to the compiler, assembler or linker.
*/

unsigned int
bfd_get_gp_size (abfd)
     bfd *abfd;
{
  if (abfd->format == bfd_object)
    {
      if (abfd->xvec->flavour == bfd_target_ecoff_flavour)
	return ecoff_data (abfd)->gp_size;
      else if (abfd->xvec->flavour == bfd_target_elf_flavour)
	return elf_gp_size (abfd);
    }
  return 0;
}

/*
FUNCTION
	bfd_set_gp_size

SYNOPSIS
	void bfd_set_gp_size (bfd *abfd, unsigned int i);

DESCRIPTION
	Set the maximum size of objects to be optimized using the GP
	register under ECOFF or MIPS ELF.  This is typically set by
	the <<-G>> argument to the compiler, assembler or linker.
*/

void
bfd_set_gp_size (abfd, i)
     bfd *abfd;
     unsigned int i;
{
  /* Don't try to set GP size on an archive or core file!  */
  if (abfd->format != bfd_object)
    return;

  if (abfd->xvec->flavour == bfd_target_ecoff_flavour)
    ecoff_data (abfd)->gp_size = i;
  else if (abfd->xvec->flavour == bfd_target_elf_flavour)
    elf_gp_size (abfd) = i;
}

/* Get the GP value.  This is an internal function used by some of the
   relocation special_function routines on targets which support a GP
   register.  */

bfd_vma
_bfd_get_gp_value (abfd)
     bfd *abfd;
{
  if (abfd->format != bfd_object)
    return 0;

  if (abfd->xvec->flavour == bfd_target_ecoff_flavour)
    return ecoff_data (abfd)->gp;
  else if (abfd->xvec->flavour == bfd_target_elf_flavour)
    return elf_gp (abfd);

  return 0;
}

/* Set the GP value.  */

void
_bfd_set_gp_value (abfd, v)
     bfd *abfd;
     bfd_vma v;
{
  if (abfd->format != bfd_object)
    return;

  if (abfd->xvec->flavour == bfd_target_ecoff_flavour)
    ecoff_data (abfd)->gp = v;
  else if (abfd->xvec->flavour == bfd_target_elf_flavour)
    elf_gp (abfd) = v;
}

/*
FUNCTION
	bfd_scan_vma

SYNOPSIS
	bfd_vma bfd_scan_vma (const char *string, const char **end, int base);

DESCRIPTION
	Convert, like <<strtoul>>, a numerical expression
	@@var{string} into a <<bfd_vma>> integer, and return that integer.
	(Though without as many bells and whistles as <<strtoul>>.)
	The expression is assumed to be unsigned (i.e., positive).
	If given a @@var{base}, it is used as the base for conversion.
	A base of 0 causes the function to interpret the string
	in hex if a leading "0x" or "0X" is found, otherwise
	in octal if a leading zero is found, otherwise in decimal.

	If the value would overflow, the maximum <<bfd_vma>> value is
	returned.
*/

bfd_vma
bfd_scan_vma (string, end, base)
     const char *string;
     const char **end;
     int base;
{
  bfd_vma value;
  bfd_vma cutoff;
  unsigned int cutlim;
  int overflow;

  /* Let the host do it if possible.  */
  if (sizeof (bfd_vma) <= sizeof (unsigned long))
    return (bfd_vma) strtoul (string, (char **) end, base);

  if (base == 0)
    {
      if (string[0] == '0')
	{
	  if ((string[1] == 'x') || (string[1] == 'X'))
	    base = 16;
	  else
	    base = 8;
	}
    }

  if ((base < 2) || (base > 36))
    base = 10;

  if (base == 16
      && string[0] == '0'
      && (string[1] == 'x' || string[1] == 'X')
      && ISXDIGIT (string[2]))
    {
      string += 2;
    }

  cutoff = (~ (bfd_vma) 0) / (bfd_vma) base;
  cutlim = (~ (bfd_vma) 0) % (bfd_vma) base;
  value = 0;
  overflow = 0;
  while (1)
    {
      unsigned int digit;

      digit = *string;
      if (ISDIGIT (digit))
	digit = digit - '0';
      else if (ISALPHA (digit))
	digit = TOUPPER (digit) - 'A' + 10;
      else
	break;
      if (digit >= (unsigned int) base)
	break;
      if (value > cutoff || (value == cutoff && digit > cutlim))
	overflow = 1;
      value = value * base + digit;
      ++string;
    }

  if (overflow)
    value = ~ (bfd_vma) 0;

  if (end != NULL)
    *end = string;

  return value;
}

/*
FUNCTION
	bfd_copy_private_bfd_data

SYNOPSIS
	bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);

DESCRIPTION
	Copy private BFD information from the BFD @@var{ibfd} to the
	the BFD @@var{obfd}.  Return <<TRUE>> on success, <<FALSE>> on error.
	Possible error returns are:

	o <<bfd_error_no_memory>> -
	Not enough memory exists to create private data for @@var{obfd}.

.#define bfd_copy_private_bfd_data(ibfd, obfd) \
.     BFD_SEND (obfd, _bfd_copy_private_bfd_data, \
.		(ibfd, obfd))

*/

/*
FUNCTION
	bfd_merge_private_bfd_data

SYNOPSIS
	bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);

DESCRIPTION
	Merge private BFD information from the BFD @@var{ibfd} to the
	the output file BFD @@var{obfd} when linking.  Return <<TRUE>>
	on success, <<FALSE>> on error.  Possible error returns are:

	o <<bfd_error_no_memory>> -
	Not enough memory exists to create private data for @@var{obfd}.

.#define bfd_merge_private_bfd_data(ibfd, obfd) \
.     BFD_SEND (obfd, _bfd_merge_private_bfd_data, \
.		(ibfd, obfd))

*/

/*
FUNCTION
	bfd_set_private_flags

SYNOPSIS
	bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);

DESCRIPTION
	Set private BFD flag information in the BFD @@var{abfd}.
	Return <<TRUE>> on success, <<FALSE>> on error.  Possible error
	returns are:

	o <<bfd_error_no_memory>> -
	Not enough memory exists to create private data for @@var{obfd}.

.#define bfd_set_private_flags(abfd, flags) \
.     BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))

*/

/*
FUNCTION
	Other functions

DESCRIPTION
	The following functions exist but have not yet been documented.

.#define bfd_sizeof_headers(abfd, reloc) \
.       BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc))
.
.#define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \
.       BFD_SEND (abfd, _bfd_find_nearest_line, \
.                 (abfd, sec, syms, off, file, func, line))
.
.#define bfd_debug_info_start(abfd) \
.       BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
.
.#define bfd_debug_info_end(abfd) \
.       BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
.
.#define bfd_debug_info_accumulate(abfd, section) \
.       BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
.
.#define bfd_stat_arch_elt(abfd, stat) \
.       BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
.
.#define bfd_update_armap_timestamp(abfd) \
.       BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
.
.#define bfd_set_arch_mach(abfd, arch, mach)\
.       BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
.
.#define bfd_relax_section(abfd, section, link_info, again) \
.       BFD_SEND (abfd, _bfd_relax_section, (abfd, section, link_info, again))
.
.#define bfd_gc_sections(abfd, link_info) \
.	BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info))
.
.#define bfd_merge_sections(abfd, link_info) \
.	BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))
.
.#define bfd_discard_group(abfd, sec) \
.	BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))
.
.#define bfd_link_hash_table_create(abfd) \
.	BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))
.
.#define bfd_link_hash_table_free(abfd, hash) \
.	BFD_SEND (abfd, _bfd_link_hash_table_free, (hash))
.
.#define bfd_link_add_symbols(abfd, info) \
.	BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))
.
.#define bfd_link_just_syms(sec, info) \
.	BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))
.
.#define bfd_final_link(abfd, info) \
.	BFD_SEND (abfd, _bfd_final_link, (abfd, info))
.
.#define bfd_free_cached_info(abfd) \
.       BFD_SEND (abfd, _bfd_free_cached_info, (abfd))
.
.#define bfd_get_dynamic_symtab_upper_bound(abfd) \
.	BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))
.
.#define bfd_print_private_bfd_data(abfd, file)\
.	BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))
.
.#define bfd_canonicalize_dynamic_symtab(abfd, asymbols) \
.	BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))
.
.#define bfd_get_dynamic_reloc_upper_bound(abfd) \
.	BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))
.
.#define bfd_canonicalize_dynamic_reloc(abfd, arels, asyms) \
.	BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))
.
.extern bfd_byte *bfd_get_relocated_section_contents
.	PARAMS ((bfd *, struct bfd_link_info *,
.		  struct bfd_link_order *, bfd_byte *,
.		  bfd_boolean, asymbol **));
.

*/

bfd_byte *
bfd_get_relocated_section_contents (abfd, link_info, link_order, data,
				    relocateable, symbols)
     bfd *abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     bfd_boolean relocateable;
     asymbol **symbols;
{
  bfd *abfd2;
  bfd_byte *(*fn) PARAMS ((bfd *, struct bfd_link_info *,
			   struct bfd_link_order *, bfd_byte *, bfd_boolean,
			   asymbol **));

  if (link_order->type == bfd_indirect_link_order)
    {
      abfd2 = link_order->u.indirect.section->owner;
      if (abfd2 == NULL)
	abfd2 = abfd;
    }
  else
    abfd2 = abfd;

  fn = abfd2->xvec->_bfd_get_relocated_section_contents;

  return (*fn) (abfd, link_info, link_order, data, relocateable, symbols);
}

/* Record information about an ELF program header.  */

bfd_boolean
bfd_record_phdr (abfd, type, flags_valid, flags, at_valid, at,
		 includes_filehdr, includes_phdrs, count, secs)
     bfd *abfd;
     unsigned long type;
     bfd_boolean flags_valid;
     flagword flags;
     bfd_boolean at_valid;
     bfd_vma at;
     bfd_boolean includes_filehdr;
     bfd_boolean includes_phdrs;
     unsigned int count;
     asection **secs;
{
  struct elf_segment_map *m, **pm;
  bfd_size_type amt;

  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
    return TRUE;

  amt = sizeof (struct elf_segment_map);
  amt += ((bfd_size_type) count - 1) * sizeof (asection *);
  m = (struct elf_segment_map *) bfd_alloc (abfd, amt);
  if (m == NULL)
    return FALSE;

  m->next = NULL;
  m->p_type = type;
  m->p_flags = flags;
  m->p_paddr = at;
  m->p_flags_valid = (unsigned int) flags_valid;
  m->p_paddr_valid = (unsigned int) at_valid;
  m->includes_filehdr = (unsigned int) includes_filehdr;
  m->includes_phdrs = (unsigned int) includes_phdrs;
  m->count = count;
  if (count > 0)
    memcpy (m->sections, secs, count * sizeof (asection *));

  for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL; pm = &(*pm)->next)
    ;
  *pm = m;

  return TRUE;
}

void
bfd_sprintf_vma (abfd, buf, value)
     bfd *abfd;
     char *buf;
     bfd_vma value;
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    get_elf_backend_data (abfd)->elf_backend_sprintf_vma (abfd, buf, value);
  else
    sprintf_vma (buf, value);
}

void
bfd_fprintf_vma (abfd, stream, value)
     bfd *abfd;
     PTR stream;
     bfd_vma value;
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    get_elf_backend_data (abfd)->elf_backend_fprintf_vma (abfd, stream, value);
  else
    fprintf_vma ((FILE *) stream, value);
}

/*
FUNCTION
	bfd_alt_mach_code

SYNOPSIS
	bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);

DESCRIPTION

	When more than one machine code number is available for the
	same machine type, this function can be used to switch between
	the preferred one (alternative == 0) and any others.  Currently,
	only ELF supports this feature, with up to two alternate
	machine codes.
*/

bfd_boolean
bfd_alt_mach_code (abfd, alternative)
     bfd *abfd;
     int alternative;
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    {
      int code;

      switch (alternative)
	{
	case 0:
	  code = get_elf_backend_data (abfd)->elf_machine_code;
	  break;

	case 1:
	  code = get_elf_backend_data (abfd)->elf_machine_alt1;
	  if (code == 0)
	    return FALSE;
	  break;

	case 2:
	  code = get_elf_backend_data (abfd)->elf_machine_alt2;
	  if (code == 0)
	    return FALSE;
	  break;

	default:
	  return FALSE;
	}

      elf_elfheader (abfd)->e_machine = code;

      return TRUE;
    }

  return FALSE;
}

/*
CODE_FRAGMENT

.struct bfd_preserve
.{
.  PTR marker;
.  PTR tdata;
.  flagword flags;
.  const struct bfd_arch_info *arch_info;
.  struct sec *sections;
.  struct sec **section_tail;
.  unsigned int section_count;
.  struct bfd_hash_table section_htab;
.};
.
*/

/*
FUNCTION
	bfd_preserve_save

SYNOPSIS
	bfd_boolean bfd_preserve_save (bfd *, struct bfd_preserve *);

DESCRIPTION
	When testing an object for compatibility with a particular
	target back-end, the back-end object_p function needs to set
	up certain fields in the bfd on successfully recognizing the
	object.  This typically happens in a piecemeal fashion, with
	failures possible at many points.  On failure, the bfd is
	supposed to be restored to its initial state, which is
	virtually impossible.  However, restoring a subset of the bfd
	state works in practice.  This function stores the subset and
	reinitializes the bfd.

*/

bfd_boolean
bfd_preserve_save (abfd, preserve)
     bfd *abfd;
     struct bfd_preserve *preserve;
{
  preserve->tdata = abfd->tdata.any;
  preserve->arch_info = abfd->arch_info;
  preserve->flags = abfd->flags;
  preserve->sections = abfd->sections;
  preserve->section_tail = abfd->section_tail;
  preserve->section_count = abfd->section_count;
  preserve->section_htab = abfd->section_htab;

  if (! bfd_hash_table_init (&abfd->section_htab, bfd_section_hash_newfunc))
    return FALSE;

  abfd->tdata.any = NULL;
  abfd->arch_info = &bfd_default_arch_struct;
  abfd->flags &= BFD_IN_MEMORY;
  abfd->sections = NULL;
  abfd->section_tail = &abfd->sections;
  abfd->section_count = 0;

  return TRUE;
}

/*
FUNCTION
	bfd_preserve_restore

SYNOPSIS
	void bfd_preserve_restore (bfd *, struct bfd_preserve *);

DESCRIPTION
	This function restores bfd state saved by bfd_preserve_save.
	If MARKER is non-NULL in struct bfd_preserve then that block
	and all subsequently bfd_alloc'd memory is freed.

*/

void
bfd_preserve_restore (abfd, preserve)
     bfd *abfd;
     struct bfd_preserve *preserve;
{
  bfd_hash_table_free (&abfd->section_htab);

  abfd->tdata.any = preserve->tdata;
  abfd->arch_info = preserve->arch_info;
  abfd->flags = preserve->flags;
  abfd->section_htab = preserve->section_htab;
  abfd->sections = preserve->sections;
  abfd->section_tail = preserve->section_tail;
  abfd->section_count = preserve->section_count;

  /* bfd_release frees all memory more recently bfd_alloc'd than
     its arg, as well as its arg.  */
  if (preserve->marker != NULL)
    {
      bfd_release (abfd, preserve->marker);
      preserve->marker = NULL;
    }
}

/*
FUNCTION
	bfd_preserve_finish

SYNOPSIS
	void bfd_preserve_finish (bfd *, struct bfd_preserve *);

DESCRIPTION
	This function should be called when the bfd state saved by
	bfd_preserve_save is no longer needed.  ie. when the back-end
	object_p function returns with success.

*/

void
bfd_preserve_finish (abfd, preserve)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_preserve *preserve;
{
  /* It would be nice to be able to free more memory here, eg. old
     tdata, but that's not possible since these blocks are sitting
     inside bfd_alloc'd memory.  The section hash is on a separate
     objalloc.  */
  bfd_hash_table_free (&preserve->section_htab);
}

#define	MYNAME	"libbfd"
#include "../../../egcs/_gplwarn.c"
@


1.3
log
@GPL poisoning warning here, too

I think I've identified all GPL viri in installed libraries now.
@
text
@d1 1
a1 1
/* $MirBSD$ */
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@d1 2
d1444 3
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   2000, 2001
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d37 1
a37 1
.struct _bfd
d39 2
a40 2
.    {* The filename the application opened the BFD with.  *}
.    CONST char *filename;
d42 2
a43 2
.    {* A pointer to the target jump table.             *}
.    const struct bfd_target *xvec;
d45 2
a46 8
.    {* To avoid dragging too many header files into every file that
.       includes `<<bfd.h>>', IOSTREAM has been declared as a "char
.       *", and MTIME as a "long".  Their correct types, to which they
.       are cast when used, are "FILE *" and "time_t".    The iostream
.       is the result of an fopen on the filename.  However, if the
.       BFD_IN_MEMORY flag is set, then iostream is actually a pointer
.       to a bfd_in_memory struct.  *}
.    PTR iostream;
d48 109
a156 100
.    {* Is the file descriptor being cached?  That is, can it be closed as
.       needed, and re-opened when accessed later?  *}
.
.    boolean cacheable;
.
.    {* Marks whether there was a default target specified when the
.       BFD was opened. This is used to select which matching algorithm
.       to use to choose the back end. *}
.
.    boolean target_defaulted;
.
.    {* The caching routines use these to maintain a
.       least-recently-used list of BFDs *}
.
.    struct _bfd *lru_prev, *lru_next;
.
.    {* When a file is closed by the caching routines, BFD retains
.       state information on the file here: *}
.
.    file_ptr where;
.
.    {* and here: (``once'' means at least once) *}
.
.    boolean opened_once;
.
.    {* Set if we have a locally maintained mtime value, rather than
.       getting it from the file each time: *}
.
.    boolean mtime_set;
.
.    {* File modified time, if mtime_set is true: *}
.
.    long mtime;
.
.    {* Reserved for an unimplemented file locking extension.*}
.
.    int ifd;
.
.    {* The format which belongs to the BFD. (object, core, etc.) *}
.
.    bfd_format format;
.
.    {* The direction the BFD was opened with*}
.
.    enum bfd_direction {no_direction = 0,
.                        read_direction = 1,
.                        write_direction = 2,
.                        both_direction = 3} direction;
.
.    {* Format_specific flags*}
.
.    flagword flags;
.
.    {* Currently my_archive is tested before adding origin to
.       anything. I believe that this can become always an add of
.       origin, with origin set to 0 for non archive files.   *}
.
.    file_ptr origin;
.
.    {* Remember when output has begun, to stop strange things
.       from happening. *}
.    boolean output_has_begun;
.
.    {* Pointer to linked list of sections*}
.    struct sec  *sections;
.
.    {* The number of sections *}
.    unsigned int section_count;
.
.    {* Stuff only useful for object files:
.       The start address. *}
.    bfd_vma start_address;
.
.    {* Used for input and output*}
.    unsigned int symcount;
.
.    {* Symbol table for output BFD (with symcount entries) *}
.    struct symbol_cache_entry  **outsymbols;
.
.    {* Pointer to structure which contains architecture information*}
.    const struct bfd_arch_info *arch_info;
.
.    {* Stuff only useful for archives:*}
.    PTR arelt_data;
.    struct _bfd *my_archive;     {* The containing archive BFD.  *}
.    struct _bfd *next;           {* The next BFD in the archive.  *}
.    struct _bfd *archive_head;   {* The first BFD in the archive.  *}
.    boolean has_armap;
.
.    {* A chain of BFD structures involved in a link.  *}
.    struct _bfd *link_next;
.
.    {* A field used by _bfd_generic_link_add_archive_symbols.  This will
.       be used only for archive elements.  *}
.    int archive_pass;
.
.    {* Used by the back end to hold private data. *}
.
.    union
.      {
d173 1
d186 5
d192 2
a193 1
.      } tdata;
d195 2
a196 2
.    {* Used by the application to hold private data*}
.    PTR usrdata;
d201 1
a201 1
.    PTR memory;
d207 1
d217 1
a225 2

#include <ctype.h>
d261 1
d277 2
a278 1
.} bfd_error_type;
d284 23
a306 21
CONST char *CONST bfd_errmsgs[] = {
                        N_("No error"),
                        N_("System call error"),
                        N_("Invalid bfd target"),
                        N_("File in wrong format"),
                        N_("Invalid operation"),
                        N_("Memory exhausted"),
                        N_("No symbols"),
			N_("Archive has no index; run ranlib to add one"),
                        N_("No more archived files"),
                        N_("Malformed archive"),
                        N_("File format not recognized"),
                        N_("File format is ambiguous"),
                        N_("Section has no contents"),
                        N_("Nonrepresentable section on output"),
			N_("Symbol needs debug section which does not exist"),
			N_("Bad value"),
			N_("File truncated"),
			N_("File too big"),
                        N_("#<Invalid error code>")
                       };
d348 1
a348 1
	CONST char *bfd_errmsg (bfd_error_type error_tag);
d355 1
a355 1
CONST char *
d365 2
a366 2
  if ((((int)error_tag <(int) bfd_error_no_error) ||
       ((int)error_tag > (int)bfd_error_invalid_error_code)))
d377 1
a377 1
	void bfd_perror (CONST char *message);
d389 1
a389 1
     CONST char *message;
d392 9
a400 7
    perror((char *)message);            /* must be system error then...  */
  else {
    if (message == NULL || *message == '\0')
      fprintf (stderr, "%s\n", bfd_errmsg (bfd_get_error ()));
    else
      fprintf (stderr, "%s: %s\n", message, bfd_errmsg (bfd_get_error ()));
  }
a424 2
#ifdef ANSI_PROTOTYPES

d428 1
a428 25
_bfd_default_error_handler (const char *s, ...)
{
  va_list p;

  if (_bfd_error_program_name != NULL)
    fprintf (stderr, "%s: ", _bfd_error_program_name);
  else
    fprintf (stderr, "BFD: ");

  va_start (p, s);

  vfprintf (stderr, s, p);

  va_end (p);

  fprintf (stderr, "\n");
}

#else /* ! defined (ANSI_PROTOTYPES) */

static void _bfd_default_error_handler ();

static void
_bfd_default_error_handler (va_alist)
     va_dcl
a429 3
  va_list p;
  const char *s;

d435 2
a436 3
  va_start (p);

  s = va_arg (p, const char *);
d438 1
a438 2

  va_end (p);
a442 2
#endif /* ! defined (ANSI_PROTOTYPES) */

d511 48
d570 1
a570 1
	long bfd_get_reloc_upper_bound(bfd *abfd, asection *sect);
d584 5
a588 4
  if (abfd->format != bfd_object) {
    bfd_set_error (bfd_error_invalid_operation);
    return -1;
  }
d624 6
a629 4
  if (abfd->format != bfd_object) {
    bfd_set_error (bfd_error_invalid_operation);
    return -1;
  }
d640 1
a640 1
	  (bfd *abfd, asection *sec, arelent **rel, unsigned int count)
d665 1
a665 1
	boolean bfd_set_file_flags(bfd *abfd, flagword flags);
d680 1
a680 1
boolean
d685 11
a695 9
  if (abfd->format != bfd_object) {
    bfd_set_error (bfd_error_wrong_format);
    return false;
  }

  if (bfd_read_p (abfd)) {
    bfd_set_error (bfd_error_invalid_operation);
    return false;
  }
d698 5
a702 4
  if ((flags & bfd_applicable_file_flags (abfd)) != flags) {
    bfd_set_error (bfd_error_invalid_operation);
    return false;
  }
d704 1
a704 1
return true;
d712 2
a713 1
  (*_bfd_error_handler) (_("bfd assertion fail %s:%d"), file, line);
d731 2
a732 2
      (_("BFD internal error, aborting at %s line %d in %s\n"),
       file, line, fn);
d735 2
a736 2
      (_("BFD internal error, aborting at %s line %d\n"),
       file, line);
a763 1
  bfd_set_error (bfd_error_wrong_format);
d792 2
d797 10
d816 1
a816 1
 	boolean bfd_set_start_address(bfd *abfd, bfd_vma vma);
d822 1
a822 1
	Returns <<true>> on success, <<false>> otherwise.
d825 4
a828 4
boolean
bfd_set_start_address(abfd, vma)
bfd *abfd;
bfd_vma vma;
d831 1
a831 82
  return true;
}

/*
FUNCTION
	bfd_get_mtime

SYNOPSIS
	long bfd_get_mtime(bfd *abfd);

DESCRIPTION
	Return the file modification time (as read from the file system, or
	from the archive header for archive members).

*/

long
bfd_get_mtime (abfd)
     bfd *abfd;
{
  FILE *fp;
  struct stat buf;

  if (abfd->mtime_set)
    return abfd->mtime;

  fp = bfd_cache_lookup (abfd);
  if (0 != fstat (fileno (fp), &buf))
    return 0;

  abfd->mtime = buf.st_mtime;		/* Save value in case anyone wants it */
  return buf.st_mtime;
}

/*
FUNCTION
	bfd_get_size

SYNOPSIS
	long bfd_get_size(bfd *abfd);

DESCRIPTION
	Return the file size (as read from file system) for the file
	associated with BFD @@var{abfd}.

	The initial motivation for, and use of, this routine is not
	so we can get the exact size of the object the BFD applies to, since
	that might not be generally possible (archive members for example).
	It would be ideal if someone could eventually modify
	it so that such results were guaranteed.

	Instead, we want to ask questions like "is this NNN byte sized
	object I'm about to try read from file offset YYY reasonable?"
	As as example of where we might do this, some object formats
	use string tables for which the first <<sizeof (long)>> bytes of the
	table contain the size of the table itself, including the size bytes.
	If an application tries to read what it thinks is one of these
	string tables, without some way to validate the size, and for
	some reason the size is wrong (byte swapping error, wrong location
	for the string table, etc.), the only clue is likely to be a read
	error when it tries to read the table, or a "virtual memory
	exhausted" error when it tries to allocate 15 bazillon bytes
	of space for the 15 bazillon byte table it is about to read.
	This function at least allows us to answer the quesion, "is the
	size reasonable?".
*/

long
bfd_get_size (abfd)
     bfd *abfd;
{
  FILE *fp;
  struct stat buf;

  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    return ((struct bfd_in_memory *) abfd->iostream)->size;

  fp = bfd_cache_lookup (abfd);
  if (0 != fstat (fileno (fp), &buf))
    return 0;

  return buf.st_size;
d839 1
a839 1
	int bfd_get_gp_size(bfd *abfd);
d847 1
a847 1
int
d866 1
a866 1
	void bfd_set_gp_size(bfd *abfd, int i);
d877 1
a877 1
     int i;
d879 1
a879 1
  /* Don't try to set GP size on an archive or core file! */
d882 1
d897 8
a904 7
  if (abfd->format == bfd_object)
    {
      if (abfd->xvec->flavour == bfd_target_ecoff_flavour)
	return ecoff_data (abfd)->gp;
      else if (abfd->xvec->flavour == bfd_target_elf_flavour)
	return elf_gp (abfd);
    }
d917 1
d929 1
a929 1
	bfd_vma bfd_scan_vma(CONST char *string, CONST char **end, int base);
d941 2
a942 1
	Overflow is not detected.
d947 2
a948 2
     CONST char *string;
     CONST char **end;
d952 3
a954 1
  int digit;
a959 4
  /* A negative base makes no sense, and we only need to go as high as hex.  */
  if ((base < 0) || (base > 16))
    return (bfd_vma) 0;

a965 1
	  /* XXX should we also allow "0b" or "0B" to set base to 2? */
a968 2
      else
	base = 10;
a969 12
  if ((base == 16) &&
      (string[0] == '0') && ((string[1] == 'x') || (string[1] == 'X')))
    string += 2;
  /* XXX should we also skip over "0b" or "0B" if base is 2? */

/* Speed could be improved with a table like hex_value[] in gas.  */
#define HEX_VALUE(c) \
  (isxdigit ((unsigned char) c)					\
   ? (isdigit ((unsigned char) c)				\
      ? (c - '0')						\
      : (10 + c - (islower ((unsigned char) c) ? 'a' : 'A')))	\
   : 42)
d971 16
a986 1
  for (value = 0; (digit = HEX_VALUE(*string)) < base; string++)
d988 13
d1002 1
d1005 4
a1008 1
  if (end)
d1019 1
a1019 1
	boolean bfd_copy_private_bfd_data(bfd *ibfd, bfd *obfd);
d1023 1
a1023 1
	the BFD @@var{obfd}.  Return <<true>> on success, <<false>> on error.
d1040 1
a1040 1
	boolean bfd_merge_private_bfd_data(bfd *ibfd, bfd *obfd);
d1044 2
a1045 2
	the output file BFD @@var{obfd} when linking.  Return <<true>>
	on success, <<false>> on error.  Possible error returns are:
d1061 1
a1061 1
	boolean bfd_set_private_flags(bfd *abfd, flagword flags);
d1065 1
a1065 1
	Return <<true>> on success, <<false>> on error.  Possible error
d1072 1
a1072 2
.     BFD_SEND (abfd, _bfd_set_private_flags, \
.		(abfd, flags))
d1078 1
a1078 1
	stuff
d1081 1
a1081 1
	Stuff which should be documented:
d1084 1
a1084 1
.     BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc))
d1087 2
a1088 1
.     BFD_SEND (abfd, _bfd_find_nearest_line,  (abfd, sec, syms, off, file, func, line))
a1089 1
.       {* Do these three do anything useful at all, for any back end?  *}
d1091 1
a1091 1
.        BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
d1094 1
a1094 1
.        BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
d1097 1
a1097 2
.        BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
.
d1100 1
a1100 1
.        BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
d1103 1
a1103 1
.        BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
d1106 1
a1106 1
.        BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
d1114 6
d1123 3
d1129 3
d1156 1
a1156 1
.		  boolean, asymbol **));
d1168 1
a1168 1
     boolean relocateable;
d1173 1
a1173 1
			   struct bfd_link_order *, bfd_byte *, boolean,
d1179 1
a1179 1
      if (abfd2 == 0)
d1184 1
d1192 1
a1192 1
boolean
d1197 1
a1197 1
     boolean flags_valid;
d1199 1
a1199 1
     boolean at_valid;
d1201 2
a1202 2
     boolean includes_filehdr;
     boolean includes_phdrs;
d1207 1
d1210 1
a1210 1
    return true;
d1212 3
a1214 4
  m = ((struct elf_segment_map *)
       bfd_alloc (abfd,
		  (sizeof (struct elf_segment_map)
		   + ((size_t) count - 1) * sizeof (asection *))));
d1216 1
a1216 1
    return false;
d1222 4
a1225 4
  m->p_flags_valid = flags_valid;
  m->p_paddr_valid = at_valid;
  m->includes_filehdr = includes_filehdr;
  m->includes_phdrs = includes_phdrs;
d1234 207
a1440 1
  return true;
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d37 1
a37 1
.struct bfd
d39 2
a40 2
.  {* A unique identifier of the BFD  *}
.  unsigned int id;
d42 2
a43 2
.  {* The filename the application opened the BFD with.  *}
.  const char *filename;
d45 8
a52 2
.  {* A pointer to the target jump table.  *}
.  const struct bfd_target *xvec;
d54 100
a153 109
.  {* To avoid dragging too many header files into every file that
.     includes `<<bfd.h>>', IOSTREAM has been declared as a "char *",
.     and MTIME as a "long".  Their correct types, to which they
.     are cast when used, are "FILE *" and "time_t".    The iostream
.     is the result of an fopen on the filename.  However, if the
.     BFD_IN_MEMORY flag is set, then iostream is actually a pointer
.     to a bfd_in_memory struct.  *}
.  PTR iostream;
.
.  {* Is the file descriptor being cached?  That is, can it be closed as
.     needed, and re-opened when accessed later?  *}
.  bfd_boolean cacheable;
.
.  {* Marks whether there was a default target specified when the
.     BFD was opened. This is used to select which matching algorithm
.     to use to choose the back end.  *}
.  bfd_boolean target_defaulted;
.
.  {* The caching routines use these to maintain a
.     least-recently-used list of BFDs.  *}
.  struct bfd *lru_prev, *lru_next;
.
.  {* When a file is closed by the caching routines, BFD retains
.     state information on the file here...  *}
.  ufile_ptr where;
.
.  {* ... and here: (``once'' means at least once).  *}
.  bfd_boolean opened_once;
.
.  {* Set if we have a locally maintained mtime value, rather than
.     getting it from the file each time.  *}
.  bfd_boolean mtime_set;
.
.  {* File modified time, if mtime_set is TRUE.  *}
.  long mtime;
.
.  {* Reserved for an unimplemented file locking extension.  *}
.  int ifd;
.
.  {* The format which belongs to the BFD. (object, core, etc.)  *}
.  bfd_format format;
.
.  {* The direction with which the BFD was opened.  *}
.  enum bfd_direction
.    {
.      no_direction = 0,
.      read_direction = 1,
.      write_direction = 2,
.      both_direction = 3
.    }
.  direction;
.
.  {* Format_specific flags.  *}
.  flagword flags;
.
.  {* Currently my_archive is tested before adding origin to
.     anything. I believe that this can become always an add of
.     origin, with origin set to 0 for non archive files.  *}
.  ufile_ptr origin;
.
.  {* Remember when output has begun, to stop strange things
.     from happening.  *}
.  bfd_boolean output_has_begun;
.
.  {* A hash table for section names.  *}
.  struct bfd_hash_table section_htab;
.
.  {* Pointer to linked list of sections.  *}
.  struct sec *sections;
.
.  {* The place where we add to the section list.  *}
.  struct sec **section_tail;
.
.  {* The number of sections.  *}
.  unsigned int section_count;
.
.  {* Stuff only useful for object files:
.     The start address.  *}
.  bfd_vma start_address;
.
.  {* Used for input and output.  *}
.  unsigned int symcount;
.
.  {* Symbol table for output BFD (with symcount entries).  *}
.  struct symbol_cache_entry  **outsymbols;
.
.  {* Used for slurped dynamic symbol tables.  *}
.  unsigned int dynsymcount;
.
.  {* Pointer to structure which contains architecture information.  *}
.  const struct bfd_arch_info *arch_info;
.
.  {* Stuff only useful for archives.  *}
.  PTR arelt_data;
.  struct bfd *my_archive;      {* The containing archive BFD.  *}
.  struct bfd *next;            {* The next BFD in the archive.  *}
.  struct bfd *archive_head;    {* The first BFD in the archive.  *}
.  bfd_boolean has_armap;
.
.  {* A chain of BFD structures involved in a link.  *}
.  struct bfd *link_next;
.
.  {* A field used by _bfd_generic_link_add_archive_symbols.  This will
.     be used only for archive elements.  *}
.  int archive_pass;
.
.  {* Used by the back end to hold private data.  *}
.  union
.    {
a169 1
.      struct mmo_data_struct *mmo_data;
a181 5
.      struct mach_o_data_struct *mach_o_data;
.      struct mach_o_fat_data_struct *mach_o_fat_data;
.      struct bfd_pef_data_struct *pef_data;
.      struct bfd_pef_xlib_data_struct *pef_xlib_data;
.      struct bfd_sym_data_struct *sym_data;
d183 1
a183 2
.    }
.  tdata;
d185 2
a186 2
.  {* Used by the application to hold private data.  *}
.  PTR usrdata;
d191 1
a191 1
.  PTR memory;
a196 1
#include "bfdver.h"
a205 1
#include "safe-ctype.h"
d214 2
a250 1
.  bfd_error_wrong_object_format,
d266 1
a266 2
.}
.bfd_error_type;
d272 21
a292 23
const char *const bfd_errmsgs[] =
{
  N_("No error"),
  N_("System call error"),
  N_("Invalid bfd target"),
  N_("File in wrong format"),
  N_("Archive object file in wrong format"),
  N_("Invalid operation"),
  N_("Memory exhausted"),
  N_("No symbols"),
  N_("Archive has no index; run ranlib to add one"),
  N_("No more archived files"),
  N_("Malformed archive"),
  N_("File format not recognized"),
  N_("File format is ambiguous"),
  N_("Section has no contents"),
  N_("Nonrepresentable section on output"),
  N_("Symbol needs debug section which does not exist"),
  N_("Bad value"),
  N_("File truncated"),
  N_("File too big"),
  N_("#<Invalid error code>")
};
d334 1
a334 1
	const char *bfd_errmsg (bfd_error_type error_tag);
d341 1
a341 1
const char *
d351 2
a352 2
  if ((((int) error_tag < (int) bfd_error_no_error) ||
       ((int) error_tag > (int) bfd_error_invalid_error_code)))
d363 1
a363 1
	void bfd_perror (const char *message);
d375 1
a375 1
     const char *message;
d378 7
a384 9
    /* Must be a system error then.  */
    perror ((char *)message);
  else
    {
      if (message == NULL || *message == '\0')
	fprintf (stderr, "%s\n", bfd_errmsg (bfd_get_error ()));
      else
	fprintf (stderr, "%s: %s\n", message, bfd_errmsg (bfd_get_error ()));
    }
d409 2
d414 25
a438 1
_bfd_default_error_handler VPARAMS ((const char *s, ...))
d440 3
d448 3
a450 2
  VA_OPEN (p, s);
  VA_FIXEDARG (p, const char *, s);
d452 2
a453 1
  VA_CLOSE (p);
d458 2
a527 48

/*
FUNCTION
	bfd_archive_filename

SYNOPSIS
	const char *bfd_archive_filename (bfd *);

DESCRIPTION
	For a BFD that is a component of an archive, returns a string
	with both the archive name and file name.  For other BFDs, just
	returns the file name.
*/

const char *
bfd_archive_filename (abfd)
     bfd *abfd;
{
  if (abfd->my_archive)
    {
      static size_t curr = 0;
      static char *buf;
      size_t needed;

      needed = (strlen (bfd_get_filename (abfd->my_archive))
		+ strlen (bfd_get_filename (abfd)) + 3);
      if (needed > curr)
	{
	  if (curr)
	    free (buf);
	  curr = needed + (needed >> 1);
	  buf = bfd_malloc ((bfd_size_type) curr);
	  /* If we can't malloc, fail safe by returning just the file
	     name. This function is only used when building error
	     messages.  */
	  if (!buf)
	    {
	      curr = 0;
	      return bfd_get_filename (abfd);
	    }
	}
      sprintf (buf, "%s(%s)", bfd_get_filename (abfd->my_archive),
	       bfd_get_filename (abfd));
      return buf;
    }
  else
    return bfd_get_filename (abfd);
}
d539 1
a539 1
	long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
d553 4
a556 5
  if (abfd->format != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }
d592 4
a595 6
  if (abfd->format != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

d606 1
a606 1
	  (bfd *abfd, asection *sec, arelent **rel, unsigned int count);
d631 1
a631 1
	bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);
d646 1
a646 1
bfd_boolean
d651 9
a659 11
  if (abfd->format != bfd_object)
    {
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  if (bfd_read_p (abfd))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }
d662 4
a665 5
  if ((flags & bfd_applicable_file_flags (abfd)) != flags)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }
d667 1
a667 1
  return TRUE;
d675 1
a675 2
  (*_bfd_error_handler) (_("BFD %s assertion fail %s:%d"),
			 BFD_VERSION_STRING, file, line);
d693 2
a694 2
      (_("BFD %s internal error, aborting at %s line %d in %s\n"),
       BFD_VERSION_STRING, file, line, fn);
d697 2
a698 2
      (_("BFD %s internal error, aborting at %s line %d\n"),
       BFD_VERSION_STRING, file, line);
d726 1
a754 2
  char *name;

a757 10
  name = bfd_get_target (abfd);

  /* Return a proper value for DJGPP COFF (an x86 COFF variant).
     This function is required for DWARF2 support, but there is
     no place to store this information in the COFF back end.
     Should enough other COFF targets add support for DWARF2,
     a place will have to be found.  Until then, this hack will do.  */
  if (strncmp (name, "coff-go32", sizeof ("coff-go32") - 1) == 0)
    return 1;

d767 1
a767 1
 	bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);
d773 23
a795 1
	Returns <<TRUE>> on success, <<FALSE>> otherwise.
d798 2
a799 2
bfd_boolean
bfd_set_start_address (abfd, vma)
a800 1
     bfd_vma vma;
d802 62
a863 2
  abfd->start_address = vma;
  return TRUE;
d871 1
a871 1
	unsigned int bfd_get_gp_size (bfd *abfd);
d879 1
a879 1
unsigned int
d898 1
a898 1
	void bfd_set_gp_size (bfd *abfd, unsigned int i);
d909 1
a909 1
     unsigned int i;
d911 1
a911 1
  /* Don't try to set GP size on an archive or core file!  */
a913 1

d928 7
a934 8
  if (abfd->format != bfd_object)
    return 0;

  if (abfd->xvec->flavour == bfd_target_ecoff_flavour)
    return ecoff_data (abfd)->gp;
  else if (abfd->xvec->flavour == bfd_target_elf_flavour)
    return elf_gp (abfd);

a946 1

d958 1
a958 1
	bfd_vma bfd_scan_vma (const char *string, const char **end, int base);
d970 1
a970 2
	If the value would overflow, the maximum <<bfd_vma>> value is
	returned.
d975 2
a976 2
     const char *string;
     const char **end;
d980 1
a980 3
  bfd_vma cutoff;
  unsigned int cutlim;
  int overflow;
d986 4
d996 1
d1000 2
d1003 12
d1016 1
a1016 16
  if ((base < 2) || (base > 36))
    base = 10;

  if (base == 16
      && string[0] == '0'
      && (string[1] == 'x' || string[1] == 'X')
      && ISXDIGIT (string[2]))
    {
      string += 2;
    }

  cutoff = (~ (bfd_vma) 0) / (bfd_vma) base;
  cutlim = (~ (bfd_vma) 0) % (bfd_vma) base;
  value = 0;
  overflow = 0;
  while (1)
a1017 13
      unsigned int digit;

      digit = *string;
      if (ISDIGIT (digit))
	digit = digit - '0';
      else if (ISALPHA (digit))
	digit = TOUPPER (digit) - 'A' + 10;
      else
	break;
      if (digit >= (unsigned int) base)
	break;
      if (value > cutoff || (value == cutoff && digit > cutlim))
	overflow = 1;
a1018 1
      ++string;
d1021 1
a1021 4
  if (overflow)
    value = ~ (bfd_vma) 0;

  if (end != NULL)
d1032 1
a1032 1
	bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);
d1036 1
a1036 1
	the BFD @@var{obfd}.  Return <<TRUE>> on success, <<FALSE>> on error.
d1053 1
a1053 1
	bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
d1057 2
a1058 2
	the output file BFD @@var{obfd} when linking.  Return <<TRUE>>
	on success, <<FALSE>> on error.  Possible error returns are:
d1074 1
a1074 1
	bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
d1078 1
a1078 1
	Return <<TRUE>> on success, <<FALSE>> on error.  Possible error
d1085 2
a1086 1
.     BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))
d1092 1
a1092 1
	Other functions
d1095 1
a1095 1
	The following functions exist but have not yet been documented.
d1098 1
a1098 1
.       BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc))
d1101 1
a1101 2
.       BFD_SEND (abfd, _bfd_find_nearest_line, \
.                 (abfd, sec, syms, off, file, func, line))
d1103 1
d1105 1
a1105 1
.       BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
d1108 1
a1108 1
.       BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
d1111 2
a1112 1
.       BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
d1115 1
a1115 1
.       BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
d1118 1
a1118 1
.       BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
d1121 1
a1121 1
.       BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
a1128 6
.#define bfd_merge_sections(abfd, link_info) \
.	BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))
.
.#define bfd_discard_group(abfd, sec) \
.	BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))
.
a1131 3
.#define bfd_link_hash_table_free(abfd, hash) \
.	BFD_SEND (abfd, _bfd_link_hash_table_free, (hash))
.
a1134 3
.#define bfd_link_just_syms(sec, info) \
.	BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))
.
d1159 1
a1159 1
.		  bfd_boolean, asymbol **));
d1171 1
a1171 1
     bfd_boolean relocateable;
d1176 1
a1176 1
			   struct bfd_link_order *, bfd_byte *, bfd_boolean,
d1182 1
a1182 1
      if (abfd2 == NULL)
a1186 1

d1194 1
a1194 1
bfd_boolean
d1199 1
a1199 1
     bfd_boolean flags_valid;
d1201 1
a1201 1
     bfd_boolean at_valid;
d1203 2
a1204 2
     bfd_boolean includes_filehdr;
     bfd_boolean includes_phdrs;
a1208 1
  bfd_size_type amt;
d1211 1
a1211 1
    return TRUE;
d1213 4
a1216 3
  amt = sizeof (struct elf_segment_map);
  amt += ((bfd_size_type) count - 1) * sizeof (asection *);
  m = (struct elf_segment_map *) bfd_alloc (abfd, amt);
d1218 1
a1218 1
    return FALSE;
d1224 4
a1227 4
  m->p_flags_valid = (unsigned int) flags_valid;
  m->p_paddr_valid = (unsigned int) at_valid;
  m->includes_filehdr = (unsigned int) includes_filehdr;
  m->includes_phdrs = (unsigned int) includes_phdrs;
d1236 1
a1236 207
  return TRUE;
}

void
bfd_sprintf_vma (abfd, buf, value)
     bfd *abfd;
     char *buf;
     bfd_vma value;
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    get_elf_backend_data (abfd)->elf_backend_sprintf_vma (abfd, buf, value);
  else
    sprintf_vma (buf, value);
}

void
bfd_fprintf_vma (abfd, stream, value)
     bfd *abfd;
     PTR stream;
     bfd_vma value;
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    get_elf_backend_data (abfd)->elf_backend_fprintf_vma (abfd, stream, value);
  else
    fprintf_vma ((FILE *) stream, value);
}

/*
FUNCTION
	bfd_alt_mach_code

SYNOPSIS
	bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);

DESCRIPTION

	When more than one machine code number is available for the
	same machine type, this function can be used to switch between
	the preferred one (alternative == 0) and any others.  Currently,
	only ELF supports this feature, with up to two alternate
	machine codes.
*/

bfd_boolean
bfd_alt_mach_code (abfd, alternative)
     bfd *abfd;
     int alternative;
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    {
      int code;

      switch (alternative)
	{
	case 0:
	  code = get_elf_backend_data (abfd)->elf_machine_code;
	  break;

	case 1:
	  code = get_elf_backend_data (abfd)->elf_machine_alt1;
	  if (code == 0)
	    return FALSE;
	  break;

	case 2:
	  code = get_elf_backend_data (abfd)->elf_machine_alt2;
	  if (code == 0)
	    return FALSE;
	  break;

	default:
	  return FALSE;
	}

      elf_elfheader (abfd)->e_machine = code;

      return TRUE;
    }

  return FALSE;
}

/*
CODE_FRAGMENT

.struct bfd_preserve
.{
.  PTR marker;
.  PTR tdata;
.  flagword flags;
.  const struct bfd_arch_info *arch_info;
.  struct sec *sections;
.  struct sec **section_tail;
.  unsigned int section_count;
.  struct bfd_hash_table section_htab;
.};
.
*/

/*
FUNCTION
	bfd_preserve_save

SYNOPSIS
	bfd_boolean bfd_preserve_save (bfd *, struct bfd_preserve *);

DESCRIPTION
	When testing an object for compatibility with a particular
	target back-end, the back-end object_p function needs to set
	up certain fields in the bfd on successfully recognizing the
	object.  This typically happens in a piecemeal fashion, with
	failures possible at many points.  On failure, the bfd is
	supposed to be restored to its initial state, which is
	virtually impossible.  However, restoring a subset of the bfd
	state works in practice.  This function stores the subset and
	reinitializes the bfd.

*/

bfd_boolean
bfd_preserve_save (abfd, preserve)
     bfd *abfd;
     struct bfd_preserve *preserve;
{
  preserve->tdata = abfd->tdata.any;
  preserve->arch_info = abfd->arch_info;
  preserve->flags = abfd->flags;
  preserve->sections = abfd->sections;
  preserve->section_tail = abfd->section_tail;
  preserve->section_count = abfd->section_count;
  preserve->section_htab = abfd->section_htab;

  if (! bfd_hash_table_init (&abfd->section_htab, bfd_section_hash_newfunc))
    return FALSE;

  abfd->tdata.any = NULL;
  abfd->arch_info = &bfd_default_arch_struct;
  abfd->flags &= BFD_IN_MEMORY;
  abfd->sections = NULL;
  abfd->section_tail = &abfd->sections;
  abfd->section_count = 0;

  return TRUE;
}

/*
FUNCTION
	bfd_preserve_restore

SYNOPSIS
	void bfd_preserve_restore (bfd *, struct bfd_preserve *);

DESCRIPTION
	This function restores bfd state saved by bfd_preserve_save.
	If MARKER is non-NULL in struct bfd_preserve then that block
	and all subsequently bfd_alloc'd memory is freed.

*/

void
bfd_preserve_restore (abfd, preserve)
     bfd *abfd;
     struct bfd_preserve *preserve;
{
  bfd_hash_table_free (&abfd->section_htab);

  abfd->tdata.any = preserve->tdata;
  abfd->arch_info = preserve->arch_info;
  abfd->flags = preserve->flags;
  abfd->section_htab = preserve->section_htab;
  abfd->sections = preserve->sections;
  abfd->section_tail = preserve->section_tail;
  abfd->section_count = preserve->section_count;

  /* bfd_release frees all memory more recently bfd_alloc'd than
     its arg, as well as its arg.  */
  if (preserve->marker != NULL)
    {
      bfd_release (abfd, preserve->marker);
      preserve->marker = NULL;
    }
}

/*
FUNCTION
	bfd_preserve_finish

SYNOPSIS
	void bfd_preserve_finish (bfd *, struct bfd_preserve *);

DESCRIPTION
	This function should be called when the bfd state saved by
	bfd_preserve_save is no longer needed.  ie. when the back-end
	object_p function returns with success.

*/

void
bfd_preserve_finish (abfd, preserve)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_preserve *preserve;
{
  /* It would be nice to be able to free more memory here, eg. old
     tdata, but that's not possible since these blocks are sitting
     inside bfd_alloc'd memory.  The section hash is on a separate
     objalloc.  */
  bfd_hash_table_free (&preserve->section_htab);
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d55 1
a55 1
.  void *iostream;
d116 1
a116 1
.  struct bfd_section *sections;
d119 1
a119 1
.  struct bfd_section **section_tail;
d132 1
a132 1
.  struct bfd_symbol  **outsymbols;
d141 1
a141 1
.  void *arelt_data;
d191 1
a191 1
.      void *any;
d196 1
a196 1
.  void *usrdata;
d199 3
a201 3
.     struct objalloc *, but we use void * to avoid requiring the inclusion
.     of objalloc.h.  *}
.  void *memory;
d209 2
d212 4
d320 1
a320 1
bfd_get_error (void)
d337 2
a338 1
bfd_set_error (bfd_error_type error_tag)
d356 2
a357 1
bfd_errmsg (bfd_error_type error_tag)
d365 3
a367 2
  if (error_tag > bfd_error_invalid_error_code)
    error_tag = bfd_error_invalid_error_code;	/* sanity check */
d369 1
a369 1
  return _(bfd_errmsgs [error_tag]);
d388 2
a389 1
bfd_perror (const char *message)
d393 1
a393 1
    perror ((char *) message);
d409 1
a409 1
	function may be overridden by the program.
d415 1
a415 1
.typedef void (*bfd_error_handler_type) (const char *, ...);
d425 2
d428 1
a428 1
_bfd_default_error_handler (const char *s, ...)
a429 2
  va_list p;

d435 2
a436 1
  va_start (p, s);
d438 1
a438 1
  va_end (p);
d464 2
a465 1
bfd_set_error_handler (bfd_error_handler_type pnew)
d489 2
a490 1
bfd_set_error_program_name (const char *name)
d507 1
a507 1
bfd_get_error_handler (void)
d526 2
a527 1
bfd_archive_filename (bfd *abfd)
a528 3
  if (abfd == NULL)
    return _("<unknown>");
  
d542 1
a542 1
	  buf = bfd_malloc (curr);
d580 3
a582 1
bfd_get_reloc_upper_bound (bfd *abfd, sec_ptr asect)
d599 4
a602 1
	  (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);
d618 5
a622 4
bfd_canonicalize_reloc (bfd *abfd,
			sec_ptr asect,
			arelent **location,
			asymbol **symbols)
d650 5
a654 4
bfd_set_reloc (bfd *ignore_abfd ATTRIBUTE_UNUSED,
	       sec_ptr asect,
	       arelent **location,
	       unsigned int count)
d681 3
a683 1
bfd_set_file_flags (bfd *abfd, flagword flags)
d708 3
a710 1
bfd_assert (const char *file, int line)
d724 4
a727 1
_bfd_abort (const char *file, int line, const char *fn)
d758 2
a759 1
bfd_get_arch_size (bfd *abfd)
d762 1
a762 1
    return get_elf_backend_data (abfd)->s->arch_size;
d789 2
a790 1
bfd_get_sign_extend_vma (bfd *abfd)
d795 1
a795 1
    return get_elf_backend_data (abfd)->sign_extend_vma;
d826 3
a828 1
bfd_set_start_address (bfd *abfd, bfd_vma vma)
d848 2
a849 1
bfd_get_gp_size (bfd *abfd)
d875 3
a877 1
bfd_set_gp_size (bfd *abfd, unsigned int i)
d894 2
a895 1
_bfd_get_gp_value (bfd *abfd)
a896 2
  if (! abfd)
    return 0;
d911 3
a913 1
_bfd_set_gp_value (bfd *abfd, bfd_vma v)
a914 2
  if (! abfd)
    BFD_FAIL ();
d946 4
a949 1
bfd_scan_vma (const char *string, const char **end, int base)
d958 1
a958 6
    return strtoul (string, (char **) end, base);

#ifdef HAVE_STRTOULL
  if (sizeof (bfd_vma) <= sizeof (unsigned long long))
    return strtoull (string, (char **) end, base);
#endif
d1154 3
a1156 2
.  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
.   bfd_boolean, asymbol **);
d1162 8
a1169 6
bfd_get_relocated_section_contents (bfd *abfd,
				    struct bfd_link_info *link_info,
				    struct bfd_link_order *link_order,
				    bfd_byte *data,
				    bfd_boolean relocatable,
				    asymbol **symbols)
d1172 3
a1174 2
  bfd_byte *(*fn) (bfd *, struct bfd_link_info *, struct bfd_link_order *,
		   bfd_byte *, bfd_boolean, asymbol **);
d1187 1
a1187 1
  return (*fn) (abfd, link_info, link_order, data, relocatable, symbols);
d1193 12
a1204 10
bfd_record_phdr (bfd *abfd,
		 unsigned long type,
		 bfd_boolean flags_valid,
		 flagword flags,
		 bfd_boolean at_valid,
		 bfd_vma at,
		 bfd_boolean includes_filehdr,
		 bfd_boolean includes_phdrs,
		 unsigned int count,
		 asection **secs)
d1214 1
a1214 1
  m = bfd_alloc (abfd, amt);
d1222 4
a1225 4
  m->p_flags_valid = flags_valid;
  m->p_paddr_valid = at_valid;
  m->includes_filehdr = includes_filehdr;
  m->includes_phdrs = includes_phdrs;
d1238 4
a1241 1
bfd_sprintf_vma (bfd *abfd, char *buf, bfd_vma value)
d1250 4
a1253 1
bfd_fprintf_vma (bfd *abfd, void *stream, bfd_vma value)
d1278 3
a1280 1
bfd_alt_mach_code (bfd *abfd, int alternative)
d1321 2
a1322 2
.  void *marker;
.  void *tdata;
d1325 2
a1326 2
.  struct bfd_section *sections;
.  struct bfd_section **section_tail;
d1354 3
a1356 1
bfd_preserve_save (bfd *abfd, struct bfd_preserve *preserve)
d1394 3
a1396 1
bfd_preserve_restore (bfd *abfd, struct bfd_preserve *preserve)
d1432 3
a1434 1
bfd_preserve_finish (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_preserve *preserve)
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d37 1
a37 1
.struct bfd
d39 2
a40 2
.  {* A unique identifier of the BFD  *}
.  unsigned int id;
d42 2
a43 2
.  {* The filename the application opened the BFD with.  *}
.  const char *filename;
d45 8
a52 2
.  {* A pointer to the target jump table.  *}
.  const struct bfd_target *xvec;
d54 100
a153 109
.  {* To avoid dragging too many header files into every file that
.     includes `<<bfd.h>>', IOSTREAM has been declared as a "char *",
.     and MTIME as a "long".  Their correct types, to which they
.     are cast when used, are "FILE *" and "time_t".    The iostream
.     is the result of an fopen on the filename.  However, if the
.     BFD_IN_MEMORY flag is set, then iostream is actually a pointer
.     to a bfd_in_memory struct.  *}
.  PTR iostream;
.
.  {* Is the file descriptor being cached?  That is, can it be closed as
.     needed, and re-opened when accessed later?  *}
.  bfd_boolean cacheable;
.
.  {* Marks whether there was a default target specified when the
.     BFD was opened. This is used to select which matching algorithm
.     to use to choose the back end.  *}
.  bfd_boolean target_defaulted;
.
.  {* The caching routines use these to maintain a
.     least-recently-used list of BFDs.  *}
.  struct bfd *lru_prev, *lru_next;
.
.  {* When a file is closed by the caching routines, BFD retains
.     state information on the file here...  *}
.  ufile_ptr where;
.
.  {* ... and here: (``once'' means at least once).  *}
.  bfd_boolean opened_once;
.
.  {* Set if we have a locally maintained mtime value, rather than
.     getting it from the file each time.  *}
.  bfd_boolean mtime_set;
.
.  {* File modified time, if mtime_set is TRUE.  *}
.  long mtime;
.
.  {* Reserved for an unimplemented file locking extension.  *}
.  int ifd;
.
.  {* The format which belongs to the BFD. (object, core, etc.)  *}
.  bfd_format format;
.
.  {* The direction with which the BFD was opened.  *}
.  enum bfd_direction
.    {
.      no_direction = 0,
.      read_direction = 1,
.      write_direction = 2,
.      both_direction = 3
.    }
.  direction;
.
.  {* Format_specific flags.  *}
.  flagword flags;
.
.  {* Currently my_archive is tested before adding origin to
.     anything. I believe that this can become always an add of
.     origin, with origin set to 0 for non archive files.  *}
.  ufile_ptr origin;
.
.  {* Remember when output has begun, to stop strange things
.     from happening.  *}
.  bfd_boolean output_has_begun;
.
.  {* A hash table for section names.  *}
.  struct bfd_hash_table section_htab;
.
.  {* Pointer to linked list of sections.  *}
.  struct sec *sections;
.
.  {* The place where we add to the section list.  *}
.  struct sec **section_tail;
.
.  {* The number of sections.  *}
.  unsigned int section_count;
.
.  {* Stuff only useful for object files:
.     The start address.  *}
.  bfd_vma start_address;
.
.  {* Used for input and output.  *}
.  unsigned int symcount;
.
.  {* Symbol table for output BFD (with symcount entries).  *}
.  struct symbol_cache_entry  **outsymbols;
.
.  {* Used for slurped dynamic symbol tables.  *}
.  unsigned int dynsymcount;
.
.  {* Pointer to structure which contains architecture information.  *}
.  const struct bfd_arch_info *arch_info;
.
.  {* Stuff only useful for archives.  *}
.  PTR arelt_data;
.  struct bfd *my_archive;      {* The containing archive BFD.  *}
.  struct bfd *next;            {* The next BFD in the archive.  *}
.  struct bfd *archive_head;    {* The first BFD in the archive.  *}
.  bfd_boolean has_armap;
.
.  {* A chain of BFD structures involved in a link.  *}
.  struct bfd *link_next;
.
.  {* A field used by _bfd_generic_link_add_archive_symbols.  This will
.     be used only for archive elements.  *}
.  int archive_pass;
.
.  {* Used by the back end to hold private data.  *}
.  union
.    {
a169 1
.      struct mmo_data_struct *mmo_data;
a181 5
.      struct mach_o_data_struct *mach_o_data;
.      struct mach_o_fat_data_struct *mach_o_fat_data;
.      struct bfd_pef_data_struct *pef_data;
.      struct bfd_pef_xlib_data_struct *pef_xlib_data;
.      struct bfd_sym_data_struct *sym_data;
d183 1
a183 2
.    }
.  tdata;
d185 2
a186 2
.  {* Used by the application to hold private data.  *}
.  PTR usrdata;
d191 1
a191 1
.  PTR memory;
a196 1
#include "bfdver.h"
a205 1
#include "safe-ctype.h"
d214 2
a250 1
.  bfd_error_wrong_object_format,
d266 1
a266 2
.}
.bfd_error_type;
d272 21
a292 23
const char *const bfd_errmsgs[] =
{
  N_("No error"),
  N_("System call error"),
  N_("Invalid bfd target"),
  N_("File in wrong format"),
  N_("Archive object file in wrong format"),
  N_("Invalid operation"),
  N_("Memory exhausted"),
  N_("No symbols"),
  N_("Archive has no index; run ranlib to add one"),
  N_("No more archived files"),
  N_("Malformed archive"),
  N_("File format not recognized"),
  N_("File format is ambiguous"),
  N_("Section has no contents"),
  N_("Nonrepresentable section on output"),
  N_("Symbol needs debug section which does not exist"),
  N_("Bad value"),
  N_("File truncated"),
  N_("File too big"),
  N_("#<Invalid error code>")
};
d334 1
a334 1
	const char *bfd_errmsg (bfd_error_type error_tag);
d341 1
a341 1
const char *
d351 2
a352 2
  if ((((int) error_tag < (int) bfd_error_no_error) ||
       ((int) error_tag > (int) bfd_error_invalid_error_code)))
d363 1
a363 1
	void bfd_perror (const char *message);
d375 1
a375 1
     const char *message;
d378 7
a384 9
    /* Must be a system error then.  */
    perror ((char *)message);
  else
    {
      if (message == NULL || *message == '\0')
	fprintf (stderr, "%s\n", bfd_errmsg (bfd_get_error ()));
      else
	fprintf (stderr, "%s: %s\n", message, bfd_errmsg (bfd_get_error ()));
    }
d409 2
d414 25
a438 1
_bfd_default_error_handler VPARAMS ((const char *s, ...))
d440 3
d448 3
a450 2
  VA_OPEN (p, s);
  VA_FIXEDARG (p, const char *, s);
d452 2
a453 1
  VA_CLOSE (p);
d458 2
a527 48

/*
FUNCTION
	bfd_archive_filename

SYNOPSIS
	const char *bfd_archive_filename (bfd *);

DESCRIPTION
	For a BFD that is a component of an archive, returns a string
	with both the archive name and file name.  For other BFDs, just
	returns the file name.
*/

const char *
bfd_archive_filename (abfd)
     bfd *abfd;
{
  if (abfd->my_archive)
    {
      static size_t curr = 0;
      static char *buf;
      size_t needed;

      needed = (strlen (bfd_get_filename (abfd->my_archive))
		+ strlen (bfd_get_filename (abfd)) + 3);
      if (needed > curr)
	{
	  if (curr)
	    free (buf);
	  curr = needed + (needed >> 1);
	  buf = bfd_malloc ((bfd_size_type) curr);
	  /* If we can't malloc, fail safe by returning just the file
	     name. This function is only used when building error
	     messages.  */
	  if (!buf)
	    {
	      curr = 0;
	      return bfd_get_filename (abfd);
	    }
	}
      sprintf (buf, "%s(%s)", bfd_get_filename (abfd->my_archive),
	       bfd_get_filename (abfd));
      return buf;
    }
  else
    return bfd_get_filename (abfd);
}
d539 1
a539 1
	long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
d553 4
a556 5
  if (abfd->format != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }
d592 4
a595 6
  if (abfd->format != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

d606 1
a606 1
	  (bfd *abfd, asection *sec, arelent **rel, unsigned int count);
d631 1
a631 1
	bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);
d646 1
a646 1
bfd_boolean
d651 9
a659 11
  if (abfd->format != bfd_object)
    {
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  if (bfd_read_p (abfd))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }
d662 4
a665 5
  if ((flags & bfd_applicable_file_flags (abfd)) != flags)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }
d667 1
a667 1
  return TRUE;
d675 1
a675 2
  (*_bfd_error_handler) (_("BFD %s assertion fail %s:%d"),
			 BFD_VERSION_STRING, file, line);
d693 2
a694 2
      (_("BFD %s internal error, aborting at %s line %d in %s\n"),
       BFD_VERSION_STRING, file, line, fn);
d697 2
a698 2
      (_("BFD %s internal error, aborting at %s line %d\n"),
       BFD_VERSION_STRING, file, line);
d726 1
a754 2
  char *name;

a757 10
  name = bfd_get_target (abfd);

  /* Return a proper value for DJGPP COFF (an x86 COFF variant).
     This function is required for DWARF2 support, but there is
     no place to store this information in the COFF back end.
     Should enough other COFF targets add support for DWARF2,
     a place will have to be found.  Until then, this hack will do.  */
  if (strncmp (name, "coff-go32", sizeof ("coff-go32") - 1) == 0)
    return 1;

d767 1
a767 1
 	bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);
d773 23
a795 1
	Returns <<TRUE>> on success, <<FALSE>> otherwise.
d798 2
a799 2
bfd_boolean
bfd_set_start_address (abfd, vma)
a800 1
     bfd_vma vma;
d802 62
a863 2
  abfd->start_address = vma;
  return TRUE;
d871 1
a871 1
	unsigned int bfd_get_gp_size (bfd *abfd);
d879 1
a879 1
unsigned int
d898 1
a898 1
	void bfd_set_gp_size (bfd *abfd, unsigned int i);
d909 1
a909 1
     unsigned int i;
d911 1
a911 1
  /* Don't try to set GP size on an archive or core file!  */
a913 1

d928 7
a934 8
  if (abfd->format != bfd_object)
    return 0;

  if (abfd->xvec->flavour == bfd_target_ecoff_flavour)
    return ecoff_data (abfd)->gp;
  else if (abfd->xvec->flavour == bfd_target_elf_flavour)
    return elf_gp (abfd);

a946 1

d958 1
a958 1
	bfd_vma bfd_scan_vma (const char *string, const char **end, int base);
d970 1
a970 2
	If the value would overflow, the maximum <<bfd_vma>> value is
	returned.
d975 2
a976 2
     const char *string;
     const char **end;
d980 1
a980 3
  bfd_vma cutoff;
  unsigned int cutlim;
  int overflow;
d986 4
d996 1
d1000 2
d1003 12
d1016 1
a1016 16
  if ((base < 2) || (base > 36))
    base = 10;

  if (base == 16
      && string[0] == '0'
      && (string[1] == 'x' || string[1] == 'X')
      && ISXDIGIT (string[2]))
    {
      string += 2;
    }

  cutoff = (~ (bfd_vma) 0) / (bfd_vma) base;
  cutlim = (~ (bfd_vma) 0) % (bfd_vma) base;
  value = 0;
  overflow = 0;
  while (1)
a1017 13
      unsigned int digit;

      digit = *string;
      if (ISDIGIT (digit))
	digit = digit - '0';
      else if (ISALPHA (digit))
	digit = TOUPPER (digit) - 'A' + 10;
      else
	break;
      if (digit >= (unsigned int) base)
	break;
      if (value > cutoff || (value == cutoff && digit > cutlim))
	overflow = 1;
a1018 1
      ++string;
d1021 1
a1021 4
  if (overflow)
    value = ~ (bfd_vma) 0;

  if (end != NULL)
d1032 1
a1032 1
	bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);
d1036 1
a1036 1
	the BFD @@var{obfd}.  Return <<TRUE>> on success, <<FALSE>> on error.
d1053 1
a1053 1
	bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
d1057 2
a1058 2
	the output file BFD @@var{obfd} when linking.  Return <<TRUE>>
	on success, <<FALSE>> on error.  Possible error returns are:
d1074 1
a1074 1
	bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
d1078 1
a1078 1
	Return <<TRUE>> on success, <<FALSE>> on error.  Possible error
d1085 2
a1086 1
.     BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))
d1092 1
a1092 1
	Other functions
d1095 1
a1095 1
	The following functions exist but have not yet been documented.
d1098 1
a1098 1
.       BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc))
d1101 1
a1101 2
.       BFD_SEND (abfd, _bfd_find_nearest_line, \
.                 (abfd, sec, syms, off, file, func, line))
d1103 1
d1105 1
a1105 1
.       BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
d1108 1
a1108 1
.       BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
d1111 2
a1112 1
.       BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
d1115 1
a1115 1
.       BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
d1118 1
a1118 1
.       BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
d1121 1
a1121 1
.       BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
a1128 6
.#define bfd_merge_sections(abfd, link_info) \
.	BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))
.
.#define bfd_discard_group(abfd, sec) \
.	BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))
.
a1131 3
.#define bfd_link_hash_table_free(abfd, hash) \
.	BFD_SEND (abfd, _bfd_link_hash_table_free, (hash))
.
a1134 3
.#define bfd_link_just_syms(sec, info) \
.	BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))
.
d1159 1
a1159 1
.		  bfd_boolean, asymbol **));
d1171 1
a1171 1
     bfd_boolean relocateable;
d1176 1
a1176 1
			   struct bfd_link_order *, bfd_byte *, bfd_boolean,
d1182 1
a1182 1
      if (abfd2 == NULL)
a1186 1

d1194 1
a1194 1
bfd_boolean
d1199 1
a1199 1
     bfd_boolean flags_valid;
d1201 1
a1201 1
     bfd_boolean at_valid;
d1203 2
a1204 2
     bfd_boolean includes_filehdr;
     bfd_boolean includes_phdrs;
a1208 1
  bfd_size_type amt;
d1211 1
a1211 1
    return TRUE;
d1213 4
a1216 3
  amt = sizeof (struct elf_segment_map);
  amt += ((bfd_size_type) count - 1) * sizeof (asection *);
  m = (struct elf_segment_map *) bfd_alloc (abfd, amt);
d1218 1
a1218 1
    return FALSE;
d1224 4
a1227 4
  m->p_flags_valid = (unsigned int) flags_valid;
  m->p_paddr_valid = (unsigned int) at_valid;
  m->includes_filehdr = (unsigned int) includes_filehdr;
  m->includes_phdrs = (unsigned int) includes_phdrs;
d1236 1
a1236 207
  return TRUE;
}

void
bfd_sprintf_vma (abfd, buf, value)
     bfd *abfd;
     char *buf;
     bfd_vma value;
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    get_elf_backend_data (abfd)->elf_backend_sprintf_vma (abfd, buf, value);
  else
    sprintf_vma (buf, value);
}

void
bfd_fprintf_vma (abfd, stream, value)
     bfd *abfd;
     PTR stream;
     bfd_vma value;
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    get_elf_backend_data (abfd)->elf_backend_fprintf_vma (abfd, stream, value);
  else
    fprintf_vma ((FILE *) stream, value);
}

/*
FUNCTION
	bfd_alt_mach_code

SYNOPSIS
	bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);

DESCRIPTION

	When more than one machine code number is available for the
	same machine type, this function can be used to switch between
	the preferred one (alternative == 0) and any others.  Currently,
	only ELF supports this feature, with up to two alternate
	machine codes.
*/

bfd_boolean
bfd_alt_mach_code (abfd, alternative)
     bfd *abfd;
     int alternative;
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    {
      int code;

      switch (alternative)
	{
	case 0:
	  code = get_elf_backend_data (abfd)->elf_machine_code;
	  break;

	case 1:
	  code = get_elf_backend_data (abfd)->elf_machine_alt1;
	  if (code == 0)
	    return FALSE;
	  break;

	case 2:
	  code = get_elf_backend_data (abfd)->elf_machine_alt2;
	  if (code == 0)
	    return FALSE;
	  break;

	default:
	  return FALSE;
	}

      elf_elfheader (abfd)->e_machine = code;

      return TRUE;
    }

  return FALSE;
}

/*
CODE_FRAGMENT

.struct bfd_preserve
.{
.  PTR marker;
.  PTR tdata;
.  flagword flags;
.  const struct bfd_arch_info *arch_info;
.  struct sec *sections;
.  struct sec **section_tail;
.  unsigned int section_count;
.  struct bfd_hash_table section_htab;
.};
.
*/

/*
FUNCTION
	bfd_preserve_save

SYNOPSIS
	bfd_boolean bfd_preserve_save (bfd *, struct bfd_preserve *);

DESCRIPTION
	When testing an object for compatibility with a particular
	target back-end, the back-end object_p function needs to set
	up certain fields in the bfd on successfully recognizing the
	object.  This typically happens in a piecemeal fashion, with
	failures possible at many points.  On failure, the bfd is
	supposed to be restored to its initial state, which is
	virtually impossible.  However, restoring a subset of the bfd
	state works in practice.  This function stores the subset and
	reinitializes the bfd.

*/

bfd_boolean
bfd_preserve_save (abfd, preserve)
     bfd *abfd;
     struct bfd_preserve *preserve;
{
  preserve->tdata = abfd->tdata.any;
  preserve->arch_info = abfd->arch_info;
  preserve->flags = abfd->flags;
  preserve->sections = abfd->sections;
  preserve->section_tail = abfd->section_tail;
  preserve->section_count = abfd->section_count;
  preserve->section_htab = abfd->section_htab;

  if (! bfd_hash_table_init (&abfd->section_htab, bfd_section_hash_newfunc))
    return FALSE;

  abfd->tdata.any = NULL;
  abfd->arch_info = &bfd_default_arch_struct;
  abfd->flags &= BFD_IN_MEMORY;
  abfd->sections = NULL;
  abfd->section_tail = &abfd->sections;
  abfd->section_count = 0;

  return TRUE;
}

/*
FUNCTION
	bfd_preserve_restore

SYNOPSIS
	void bfd_preserve_restore (bfd *, struct bfd_preserve *);

DESCRIPTION
	This function restores bfd state saved by bfd_preserve_save.
	If MARKER is non-NULL in struct bfd_preserve then that block
	and all subsequently bfd_alloc'd memory is freed.

*/

void
bfd_preserve_restore (abfd, preserve)
     bfd *abfd;
     struct bfd_preserve *preserve;
{
  bfd_hash_table_free (&abfd->section_htab);

  abfd->tdata.any = preserve->tdata;
  abfd->arch_info = preserve->arch_info;
  abfd->flags = preserve->flags;
  abfd->section_htab = preserve->section_htab;
  abfd->sections = preserve->sections;
  abfd->section_tail = preserve->section_tail;
  abfd->section_count = preserve->section_count;

  /* bfd_release frees all memory more recently bfd_alloc'd than
     its arg, as well as its arg.  */
  if (preserve->marker != NULL)
    {
      bfd_release (abfd, preserve->marker);
      preserve->marker = NULL;
    }
}

/*
FUNCTION
	bfd_preserve_finish

SYNOPSIS
	void bfd_preserve_finish (bfd *, struct bfd_preserve *);

DESCRIPTION
	This function should be called when the bfd state saved by
	bfd_preserve_save is no longer needed.  ie. when the back-end
	object_p function returns with success.

*/

void
bfd_preserve_finish (abfd, preserve)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_preserve *preserve;
{
  /* It would be nice to be able to free more memory here, eg. old
     tdata, but that's not possible since these blocks are sitting
     inside bfd_alloc'd memory.  The section hash is on a separate
     objalloc.  */
  bfd_hash_table_free (&preserve->section_htab);
@
