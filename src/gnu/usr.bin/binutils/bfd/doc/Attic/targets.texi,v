head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2004.08.11.20.55.26;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.00.56;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.39.12;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.39.12;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.27.32;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.41.03;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.04.48;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.09.06;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@@@section Targets


@@strong{Description}@@*
Each port of BFD to a different machine requries the creation
of a target back end. All the back end provides to the root
part of BFD is a structure containing pointers to functions
which perform certain low level operations on files. BFD
translates the applications's requests through a pointer into
calls to the back end routines.

When a file is opened with @@code{bfd_openr}, its format and
target are unknown. BFD uses various mechanisms to determine
how to interpret the file. The operations performed are:

@@itemize @@bullet

@@item
Create a BFD by calling the internal routine
@@code{_bfd_new_bfd}, then call @@code{bfd_find_target} with the
target string supplied to @@code{bfd_openr} and the new BFD pointer.

@@item
If a null target string was provided to @@code{bfd_find_target},
look up the environment variable @@code{GNUTARGET} and use
that as the target string.

@@item
If the target string is still @@code{NULL}, or the target string is
@@code{default}, then use the first item in the target vector
as the target type, and set @@code{target_defaulted} in the BFD to
cause @@code{bfd_check_format} to loop through all the targets.
@@xref{bfd_target}.  @@xref{Formats}.

@@item
Otherwise, inspect the elements in the target vector
one by one, until a match on target name is found. When found,
use it.

@@item
Otherwise return the error @@code{bfd_error_invalid_target} to
@@code{bfd_openr}.

@@item
@@code{bfd_openr} attempts to open the file using
@@code{bfd_open_file}, and returns the BFD.
@@end itemize
Once the BFD has been opened and the target selected, the file
format may be determined. This is done by calling
@@code{bfd_check_format} on the BFD with a suggested format.
If @@code{target_defaulted} has been set, each possible target
type is tried to see if it recognizes the specified format.
@@code{bfd_check_format} returns @@code{TRUE} when the caller guesses right.
@@menu
* bfd_target::
@@end menu

@@node bfd_target,  , Targets, Targets

@@subsection bfd_target


@@strong{Description}@@*
This structure contains everything that BFD knows about a
target. It includes things like its byte order, name, and which
routines to call to do various operations.

Every BFD points to a target structure with its @@code{xvec}
member.

The macros below are used to dispatch to functions through the
@@code{bfd_target} vector. They are used in a number of macros further
down in @@file{bfd.h}, and are also used when calling various
routines by hand inside the BFD implementation.  The @@var{arglist}
argument must be parenthesized; it contains all the arguments
to the called function.

They make the documentation (more) unpleasant to read, so if
someone wants to fix this and not break the above, please do.
@@example
#define BFD_SEND(bfd, message, arglist) \
               ((*((bfd)->xvec->message)) arglist)

#ifdef DEBUG_BFD_SEND
#undef BFD_SEND
#define BFD_SEND(bfd, message, arglist) \
  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
    ((*((bfd)->xvec->message)) arglist) : \
    (bfd_assert (__FILE__,__LINE__), NULL))
#endif
@@end example
For operations which index on the BFD format:
@@example
#define BFD_SEND_FMT(bfd, message, arglist) \
            (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)

#ifdef DEBUG_BFD_SEND
#undef BFD_SEND_FMT
#define BFD_SEND_FMT(bfd, message, arglist) \
  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
   (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
   (bfd_assert (__FILE__,__LINE__), NULL))
#endif

@@end example
This is the structure which defines the type of BFD this is.  The
@@code{xvec} member of the struct @@code{bfd} itself points here.  Each
module that implements access to a different target under BFD,
defines one of these.

FIXME, these names should be rationalised with the names of
the entry points which call them. Too bad we can't have one
macro to define them both!
@@example
enum bfd_flavour
@@{
  bfd_target_unknown_flavour,
  bfd_target_aout_flavour,
  bfd_target_coff_flavour,
  bfd_target_ecoff_flavour,
  bfd_target_xcoff_flavour,
  bfd_target_elf_flavour,
  bfd_target_ieee_flavour,
  bfd_target_nlm_flavour,
  bfd_target_oasys_flavour,
  bfd_target_tekhex_flavour,
  bfd_target_srec_flavour,
  bfd_target_ihex_flavour,
  bfd_target_som_flavour,
  bfd_target_os9k_flavour,
  bfd_target_versados_flavour,
  bfd_target_msdos_flavour,
  bfd_target_ovax_flavour,
  bfd_target_evax_flavour,
  bfd_target_mmo_flavour,
  bfd_target_mach_o_flavour,
  bfd_target_pef_flavour,
  bfd_target_pef_xlib_flavour,
  bfd_target_sym_flavour
@@};

enum bfd_endian @@{ BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN @@};

/* Forward declaration.  */
typedef struct bfd_link_info _bfd_link_info;

typedef struct bfd_target
@@{
  /* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  */
  char *name;

 /* The "flavour" of a back end is a general indication about
    the contents of a file.  */
  enum bfd_flavour flavour;

  /* The order of bytes within the data area of a file.  */
  enum bfd_endian byteorder;

 /* The order of bytes within the header parts of a file.  */
  enum bfd_endian header_byteorder;

  /* A mask of all the flags which an executable may have set -
     from the set @@code{BFD_NO_FLAGS}, @@code{HAS_RELOC}, ...@@code{D_PAGED}.  */
  flagword object_flags;

 /* A mask of all the flags which a section may have set - from
    the set @@code{SEC_NO_FLAGS}, @@code{SEC_ALLOC}, ...@@code{SET_NEVER_LOAD}.  */
  flagword section_flags;

 /* The character normally found at the front of a symbol.
    (if any), perhaps `_'.  */
  char symbol_leading_char;

 /* The pad character for file names within an archive header.  */
  char ar_pad_char;

  /* The maximum number of characters in an archive header.  */
  unsigned short ar_max_namelen;

  /* Entries for byte swapping for data. These are different from the
     other entry points, since they don't take a BFD asthe first argument.
     Certain other handlers could do the same.  */
  bfd_vma        (*bfd_getx64) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_getx_signed_64) PARAMS ((const bfd_byte *));
  void           (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_getx32) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_getx_signed_32) PARAMS ((const bfd_byte *));
  void           (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_getx16) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_getx_signed_16) PARAMS ((const bfd_byte *));
  void           (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));

  /* Byte swapping for the headers.  */
  bfd_vma        (*bfd_h_getx64) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_h_getx_signed_64) PARAMS ((const bfd_byte *));
  void           (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_h_getx32) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_h_getx_signed_32) PARAMS ((const bfd_byte *));
  void           (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_h_getx16) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_h_getx_signed_16) PARAMS ((const bfd_byte *));
  void           (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));

  /* Format dependent routines: these are vectors of entry points
     within the target vector structure, one for each format to check.  */

  /* Check the format of a file being read.  Return a @@code{bfd_target *} or zero.  */
  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) PARAMS ((bfd *));

  /* Set the format of a file being written.  */
  bfd_boolean (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));

  /* Write cached information into a file being written, at @@code{bfd_close}.  */
  bfd_boolean (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));

@@end example
The general target vector.  These vectors are initialized using the
BFD_JUMP_TABLE macros.
@@example

  /* Generic entry points.  */
@@end example
Do not "beautify" the CONCAT* macro args.  Traditional C will not
remove whitespace added here, and thus will fail to concatenate
the tokens.
@@example
#define BFD_JUMP_TABLE_GENERIC(NAME) \
CONCAT2 (NAME,_close_and_cleanup), \
CONCAT2 (NAME,_bfd_free_cached_info), \
CONCAT2 (NAME,_new_section_hook), \
CONCAT2 (NAME,_get_section_contents), \
CONCAT2 (NAME,_get_section_contents_in_window)

  /* Called when the BFD is being closed to do any necessary cleanup.  */
  bfd_boolean (*_close_and_cleanup) PARAMS ((bfd *));
  /* Ask the BFD to free all cached information.  */
  bfd_boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
  /* Called when a new section is created.  */
  bfd_boolean (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
  /* Read the contents of a section.  */
  bfd_boolean (*_bfd_get_section_contents)
    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
  bfd_boolean (*_bfd_get_section_contents_in_window)
    PARAMS ((bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type));

  /* Entry points to copy private data.  */
#define BFD_JUMP_TABLE_COPY(NAME) \
CONCAT2 (NAME,_bfd_copy_private_bfd_data), \
CONCAT2 (NAME,_bfd_merge_private_bfd_data), \
CONCAT2 (NAME,_bfd_copy_private_section_data), \
CONCAT2 (NAME,_bfd_copy_private_symbol_data), \
CONCAT2 (NAME,_bfd_set_private_flags), \
CONCAT2 (NAME,_bfd_print_private_bfd_data) \
  /* Called to copy BFD general private data from one object file
     to another.  */
  bfd_boolean (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
  /* Called to merge BFD general private data from one object file
     to a common output file when linking.  */
  bfd_boolean (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
  /* Called to copy BFD private section data from one object file
     to another.  */
  bfd_boolean (*_bfd_copy_private_section_data)
    PARAMS ((bfd *, sec_ptr, bfd *, sec_ptr));
  /* Called to copy BFD private symbol data from one symbol
     to another.  */
  bfd_boolean (*_bfd_copy_private_symbol_data)
    PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
  /* Called to set private backend flags.  */
  bfd_boolean (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));

  /* Called to print private BFD data.  */
  bfd_boolean (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));

  /* Core file entry points.  */
#define BFD_JUMP_TABLE_CORE(NAME) \
CONCAT2 (NAME,_core_file_failing_command), \
CONCAT2 (NAME,_core_file_failing_signal), \
CONCAT2 (NAME,_core_file_matches_executable_p)
  char *      (*_core_file_failing_command) PARAMS ((bfd *));
  int         (*_core_file_failing_signal) PARAMS ((bfd *));
  bfd_boolean (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));

  /* Archive entry points.  */
#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
CONCAT2 (NAME,_slurp_armap), \
CONCAT2 (NAME,_slurp_extended_name_table), \
CONCAT2 (NAME,_construct_extended_name_table), \
CONCAT2 (NAME,_truncate_arname), \
CONCAT2 (NAME,_write_armap), \
CONCAT2 (NAME,_read_ar_hdr), \
CONCAT2 (NAME,_openr_next_archived_file), \
CONCAT2 (NAME,_get_elt_at_index), \
CONCAT2 (NAME,_generic_stat_arch_elt), \
CONCAT2 (NAME,_update_armap_timestamp)
  bfd_boolean (*_bfd_slurp_armap) PARAMS ((bfd *));
  bfd_boolean (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
  bfd_boolean (*_bfd_construct_extended_name_table)
    PARAMS ((bfd *, char **, bfd_size_type *, const char **));
  void        (*_bfd_truncate_arname) PARAMS ((bfd *, const char *, char *));
  bfd_boolean (*write_armap)
    PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
  PTR         (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
  bfd *       (*openr_next_archived_file) PARAMS ((bfd *, bfd *));
#define bfd_get_elt_at_index(b,i) BFD_SEND(b, _bfd_get_elt_at_index, (b,i))
  bfd *       (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
  int         (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
  bfd_boolean (*_bfd_update_armap_timestamp) PARAMS ((bfd *));

  /* Entry points used for symbols.  */
#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
CONCAT2 (NAME,_get_symtab_upper_bound), \
CONCAT2 (NAME,_get_symtab), \
CONCAT2 (NAME,_make_empty_symbol), \
CONCAT2 (NAME,_print_symbol), \
CONCAT2 (NAME,_get_symbol_info), \
CONCAT2 (NAME,_bfd_is_local_label_name), \
CONCAT2 (NAME,_get_lineno), \
CONCAT2 (NAME,_find_nearest_line), \
CONCAT2 (NAME,_bfd_make_debug_symbol), \
CONCAT2 (NAME,_read_minisymbols), \
CONCAT2 (NAME,_minisymbol_to_symbol)
  long        (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
  long        (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
                                                struct symbol_cache_entry **));
  struct symbol_cache_entry *
              (*_bfd_make_empty_symbol) PARAMS ((bfd *));
  void        (*_bfd_print_symbol)
    PARAMS ((bfd *, PTR, struct symbol_cache_entry *, bfd_print_symbol_type));
#define bfd_print_symbol(b,p,s,e) BFD_SEND(b, _bfd_print_symbol, (b,p,s,e))
  void        (*_bfd_get_symbol_info)
    PARAMS ((bfd *, struct symbol_cache_entry *, symbol_info *));
#define bfd_get_symbol_info(b,p,e) BFD_SEND(b, _bfd_get_symbol_info, (b,p,e))
  bfd_boolean (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));

  alent *     (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
  bfd_boolean (*_bfd_find_nearest_line)
    PARAMS ((bfd *, struct sec *, struct symbol_cache_entry **, bfd_vma,
             const char **, const char **, unsigned int *));
 /* Back-door to allow format-aware applications to create debug symbols
    while using BFD for everything else.  Currently used by the assembler
    when creating COFF files.  */
  asymbol *   (*_bfd_make_debug_symbol)
    PARAMS ((bfd *, void *, unsigned long size));
#define bfd_read_minisymbols(b, d, m, s) \
  BFD_SEND (b, _read_minisymbols, (b, d, m, s))
  long        (*_read_minisymbols)
    PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));
#define bfd_minisymbol_to_symbol(b, d, m, f) \
  BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
  asymbol *   (*_minisymbol_to_symbol)
    PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));

  /* Routines for relocs.  */
#define BFD_JUMP_TABLE_RELOCS(NAME) \
CONCAT2 (NAME,_get_reloc_upper_bound), \
CONCAT2 (NAME,_canonicalize_reloc), \
CONCAT2 (NAME,_bfd_reloc_type_lookup)
  long        (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
  long        (*_bfd_canonicalize_reloc)
    PARAMS ((bfd *, sec_ptr, arelent **, struct symbol_cache_entry **));
  /* See documentation on reloc types.  */
  reloc_howto_type *
              (*reloc_type_lookup) PARAMS ((bfd *, bfd_reloc_code_real_type));

  /* Routines used when writing an object file.  */
#define BFD_JUMP_TABLE_WRITE(NAME) \
CONCAT2 (NAME,_set_arch_mach), \
CONCAT2 (NAME,_set_section_contents)
  bfd_boolean (*_bfd_set_arch_mach)
    PARAMS ((bfd *, enum bfd_architecture, unsigned long));
  bfd_boolean (*_bfd_set_section_contents)
    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));

  /* Routines used by the linker.  */
#define BFD_JUMP_TABLE_LINK(NAME) \
CONCAT2 (NAME,_sizeof_headers), \
CONCAT2 (NAME,_bfd_get_relocated_section_contents), \
CONCAT2 (NAME,_bfd_relax_section), \
CONCAT2 (NAME,_bfd_link_hash_table_create), \
CONCAT2 (NAME,_bfd_link_hash_table_free), \
CONCAT2 (NAME,_bfd_link_add_symbols), \
CONCAT2 (NAME,_bfd_link_just_syms), \
CONCAT2 (NAME,_bfd_final_link), \
CONCAT2 (NAME,_bfd_link_split_section), \
CONCAT2 (NAME,_bfd_gc_sections), \
CONCAT2 (NAME,_bfd_merge_sections), \
CONCAT2 (NAME,_bfd_discard_group)
  int         (*_bfd_sizeof_headers) PARAMS ((bfd *, bfd_boolean));
  bfd_byte *  (*_bfd_get_relocated_section_contents)
    PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
             bfd_byte *, bfd_boolean, struct symbol_cache_entry **));

  bfd_boolean (*_bfd_relax_section)
    PARAMS ((bfd *, struct sec *, struct bfd_link_info *, bfd_boolean *));

  /* Create a hash table for the linker.  Different backends store
     different information in this table.  */
  struct bfd_link_hash_table *
              (*_bfd_link_hash_table_create) PARAMS ((bfd *));

  /* Release the memory associated with the linker hash table.  */
  void        (*_bfd_link_hash_table_free)
    PARAMS ((struct bfd_link_hash_table *));

  /* Add symbols from this object file into the hash table.  */
  bfd_boolean (*_bfd_link_add_symbols)
    PARAMS ((bfd *, struct bfd_link_info *));

  /* Indicate that we are only retrieving symbol values from this section.  */
  void        (*_bfd_link_just_syms)
    PARAMS ((asection *, struct bfd_link_info *));

  /* Do a link based on the link_order structures attached to each
     section of the BFD.  */
  bfd_boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));

  /* Should this section be split up into smaller pieces during linking.  */
  bfd_boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));

  /* Remove sections that are not referenced from the output.  */
  bfd_boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));

  /* Attempt to merge SEC_MERGE sections.  */
  bfd_boolean (*_bfd_merge_sections) PARAMS ((bfd *, struct bfd_link_info *));

  /* Discard members of a group.  */
  bfd_boolean (*_bfd_discard_group) PARAMS ((bfd *, struct sec *));

  /* Routines to handle dynamic symbols and relocs.  */
#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
CONCAT2 (NAME,_get_dynamic_symtab_upper_bound), \
CONCAT2 (NAME,_canonicalize_dynamic_symtab), \
CONCAT2 (NAME,_get_dynamic_reloc_upper_bound), \
CONCAT2 (NAME,_canonicalize_dynamic_reloc)
  /* Get the amount of memory required to hold the dynamic symbols.  */
  long        (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
  /* Read in the dynamic symbols.  */
  long        (*_bfd_canonicalize_dynamic_symtab)
    PARAMS ((bfd *, struct symbol_cache_entry **));
  /* Get the amount of memory required to hold the dynamic relocs.  */
  long        (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
  /* Read in the dynamic relocs.  */
  long        (*_bfd_canonicalize_dynamic_reloc)
    PARAMS ((bfd *, arelent **, struct symbol_cache_entry **));

@@end example
A pointer to an alternative bfd_target in case the current one is not
satisfactory.  This can happen when the target cpu supports both big
and little endian code, and target chosen by the linker has the wrong
endianness.  The function open_output() in ld/ldlang.c uses this field
to find an alternative output format that is suitable.
@@example
  /* Opposite endian version of this target.  */
  const struct bfd_target * alternative_target;

  /* Data for use by back-end routines, which isn't
     generic enough to belong in this structure.  */
  PTR backend_data;

@@} bfd_target;

@@end example

@@findex bfd_set_default_target
@@subsubsection @@code{bfd_set_default_target}
@@strong{Synopsis}
@@example
bfd_boolean bfd_set_default_target (const char *name);
@@end example
@@strong{Description}@@*
Set the default target vector to use when recognizing a BFD.
This takes the name of the target, which may be a BFD target
name or a configuration triplet.

@@findex bfd_find_target
@@subsubsection @@code{bfd_find_target}
@@strong{Synopsis}
@@example
const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
@@end example
@@strong{Description}@@*
Return a pointer to the transfer vector for the object target
named @@var{target_name}.  If @@var{target_name} is @@code{NULL}, choose the
one in the environment variable @@code{GNUTARGET}; if that is null or not
defined, then choose the first entry in the target list.
Passing in the string "default" or setting the environment
variable to "default" will cause the first entry in the target
list to be returned, and "target_defaulted" will be set in the
BFD.  This causes @@code{bfd_check_format} to loop over all the
targets to find the one that matches the file being read.

@@findex bfd_target_list
@@subsubsection @@code{bfd_target_list}
@@strong{Synopsis}
@@example
const char ** bfd_target_list (void);
@@end example
@@strong{Description}@@*
Return a freshly malloced NULL-terminated
vector of the names of all the valid BFD targets. Do not
modify the names.

@@findex bfd_seach_for_target
@@subsubsection @@code{bfd_seach_for_target}
@@strong{Synopsis}
@@example
const bfd_target * bfd_search_for_target (int (* search_func)
       (const bfd_target *, void *),
    void *);
@@end example
@@strong{Description}@@*
Return a pointer to the first transfer vector in the list of
transfer vectors maintained by BFD that produces a non-zero
result when passed to the function @@var{search_func}.  The
parameter @@var{data} is passed, unexamined, to the search
function.

@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d53 1
a53 1
@@code{bfd_check_format} returns @@code{true} when the caller guesses right.
d104 1
d115 2
a116 1
enum bfd_flavour @@{
d134 6
a139 1
  bfd_target_evax_flavour
d149 1
a149 3
@@end example
Identifies the kind of target, e.g., SunOS4, Ultrix, etc.
@@example
d151 3
a153 4
@@end example
The "flavour" of a back end is a general indication about the contents
of a file.
@@example
d155 2
a156 3
@@end example
The order of bytes within the data area of a file.
@@example
d158 2
a159 3
@@end example
The order of bytes within the header parts of a file.
@@example
d161 3
a163 4
@@end example
A mask of all the flags which an executable may have set -
from the set @@code{BFD_NO_FLAGS}, @@code{HAS_RELOC}, ...@@code{D_PAGED}.
@@example
d165 3
a167 4
@@end example
A mask of all the flags which a section may have set - from
the set @@code{SEC_NO_FLAGS}, @@code{SEC_ALLOC}, ...@@code{SET_NEVER_LOAD}.
@@example
d169 3
a171 4
@@end example
The character normally found at the front of a symbol
(if any), perhaps `_'.
@@example
d173 2
a174 3
@@end example
The pad character for file names within an archive header.
@@example
d176 2
a177 3
@@end example
The maximum number of characters in an archive header.
@@example
d179 5
a183 6
@@end example
Entries for byte swapping for data. These are different from the other
entry points, since they don't take a BFD asthe first argument.
Certain other handlers could do the same.
@@example
  bfd_vma      (*bfd_getx64) PARAMS ((const bfd_byte *));
d185 2
a186 2
  void         (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma      (*bfd_getx32) PARAMS ((const bfd_byte *));
d188 2
a189 2
  void         (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma      (*bfd_getx16) PARAMS ((const bfd_byte *));
d191 4
a194 5
  void         (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));
@@end example
Byte swapping for the headers
@@example
  bfd_vma      (*bfd_h_getx64) PARAMS ((const bfd_byte *));
d196 2
a197 2
  void         (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma      (*bfd_h_getx32) PARAMS ((const bfd_byte *));
d199 2
a200 2
  void         (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma      (*bfd_h_getx16) PARAMS ((const bfd_byte *));
d202 4
a205 4
  void         (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));
@@end example
Format dependent routines: these are vectors of entry points
within the target vector structure, one for each format to check.
d207 1
a207 2
Check the format of a file being read.  Return a @@code{bfd_target *} or zero.
@@example
d209 7
a215 8
@@end example
Set the format of a file being written.
@@example
  boolean             (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));
@@end example
Write cached information into a file being written, at @@code{bfd_close}.
@@example
  boolean             (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));
d222 11
a232 6
#define BFD_JUMP_TABLE_GENERIC(NAME)\
CAT(NAME,_close_and_cleanup),\
CAT(NAME,_bfd_free_cached_info),\
CAT(NAME,_new_section_hook),\
CAT(NAME,_get_section_contents),\
CAT(NAME,_get_section_contents_in_window)
d235 1
a235 1
  boolean       (*_close_and_cleanup) PARAMS ((bfd *));
d237 1
a237 1
  boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
d239 1
a239 1
  boolean       (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
d241 4
a244 5
  boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
                                            file_ptr, bfd_size_type));
  boolean       (*_bfd_get_section_contents_in_window)
                          PARAMS ((bfd *, sec_ptr, bfd_window *,
                                   file_ptr, bfd_size_type));
d247 7
a253 7
#define BFD_JUMP_TABLE_COPY(NAME)\
CAT(NAME,_bfd_copy_private_bfd_data),\
CAT(NAME,_bfd_merge_private_bfd_data),\
CAT(NAME,_bfd_copy_private_section_data),\
CAT(NAME,_bfd_copy_private_symbol_data),\
CAT(NAME,_bfd_set_private_flags),\
CAT(NAME,_bfd_print_private_bfd_data)\
d256 1
a256 1
  boolean       (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
d259 1
a259 1
  boolean       (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
d262 2
a263 2
  boolean       (*_bfd_copy_private_section_data) PARAMS ((bfd *, sec_ptr,
                                                       bfd *, sec_ptr));
d266 4
a269 4
  boolean       (*_bfd_copy_private_symbol_data) PARAMS ((bfd *, asymbol *,
                                                          bfd *, asymbol *));
  /* Called to set private backend flags */
  boolean       (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
d271 2
a272 2
  /* Called to print private BFD data */
  boolean       (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
d275 7
a281 7
#define BFD_JUMP_TABLE_CORE(NAME)\
CAT(NAME,_core_file_failing_command),\
CAT(NAME,_core_file_failing_signal),\
CAT(NAME,_core_file_matches_executable_p)
  char *   (*_core_file_failing_command) PARAMS ((bfd *));
  int      (*_core_file_failing_signal) PARAMS ((bfd *));
  boolean  (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
d284 20
a303 23
#define BFD_JUMP_TABLE_ARCHIVE(NAME)\
CAT(NAME,_slurp_armap),\
CAT(NAME,_slurp_extended_name_table),\
CAT(NAME,_construct_extended_name_table),\
CAT(NAME,_truncate_arname),\
CAT(NAME,_write_armap),\
CAT(NAME,_read_ar_hdr),\
CAT(NAME,_openr_next_archived_file),\
CAT(NAME,_get_elt_at_index),\
CAT(NAME,_generic_stat_arch_elt),\
CAT(NAME,_update_armap_timestamp)
  boolean  (*_bfd_slurp_armap) PARAMS ((bfd *));
  boolean  (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
  boolean  (*_bfd_construct_extended_name_table)
             PARAMS ((bfd *, char **, bfd_size_type *, const char **));
  void     (*_bfd_truncate_arname) PARAMS ((bfd *, CONST char *, char *));
  boolean  (*write_armap) PARAMS ((bfd *arch,
                              unsigned int elength,
                              struct orl *map,
                              unsigned int orl_count,
                              int stridx));
  PTR (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
  bfd *    (*openr_next_archived_file) PARAMS ((bfd *arch, bfd *prev));
d305 3
a307 3
  bfd *    (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
  int      (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
  boolean  (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
d310 19
a328 20
#define BFD_JUMP_TABLE_SYMBOLS(NAME)\
CAT(NAME,_get_symtab_upper_bound),\
CAT(NAME,_get_symtab),\
CAT(NAME,_make_empty_symbol),\
CAT(NAME,_print_symbol),\
CAT(NAME,_get_symbol_info),\
CAT(NAME,_bfd_is_local_label_name),\
CAT(NAME,_get_lineno),\
CAT(NAME,_find_nearest_line),\
CAT(NAME,_bfd_make_debug_symbol),\
CAT(NAME,_read_minisymbols),\
CAT(NAME,_minisymbol_to_symbol)
  long  (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
  long  (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
                                             struct symbol_cache_entry **));
  struct symbol_cache_entry  *
                (*_bfd_make_empty_symbol) PARAMS ((bfd *));
  void          (*_bfd_print_symbol) PARAMS ((bfd *, PTR,
                                      struct symbol_cache_entry *,
                                      bfd_print_symbol_type));
d330 2
a331 3
  void          (*_bfd_get_symbol_info) PARAMS ((bfd *,
                                      struct symbol_cache_entry *,
                                      symbol_info *));
d333 1
a333 1
  boolean       (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
d335 4
a338 5
  alent *    (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
  boolean    (*_bfd_find_nearest_line) PARAMS ((bfd *abfd,
                    struct sec *section, struct symbol_cache_entry **symbols,
                    bfd_vma offset, CONST char **file, CONST char **func,
                    unsigned int *line));
d342 2
a343 4
  asymbol *  (*_bfd_make_debug_symbol) PARAMS ((
       bfd *abfd,
       void *ptr,
       unsigned long size));
d346 2
a347 2
  long  (*_read_minisymbols) PARAMS ((bfd *, boolean, PTR *,
                                      unsigned int *));
d350 2
a351 2
  asymbol *(*_minisymbol_to_symbol) PARAMS ((bfd *, boolean, const PTR,
                                             asymbol *));
d354 7
a360 7
#define BFD_JUMP_TABLE_RELOCS(NAME)\
CAT(NAME,_get_reloc_upper_bound),\
CAT(NAME,_canonicalize_reloc),\
CAT(NAME,_bfd_reloc_type_lookup)
  long  (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
  long  (*_bfd_canonicalize_reloc) PARAMS ((bfd *, sec_ptr, arelent **,
                                            struct symbol_cache_entry **));
d363 1
a363 2
       (*reloc_type_lookup) PARAMS ((bfd *abfd,
                                     bfd_reloc_code_real_type code));
d366 7
a372 7
#define BFD_JUMP_TABLE_WRITE(NAME)\
CAT(NAME,_set_arch_mach),\
CAT(NAME,_set_section_contents)
  boolean    (*_bfd_set_arch_mach) PARAMS ((bfd *, enum bfd_architecture,
                    unsigned long));
  boolean       (*_bfd_set_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
                                            file_ptr, bfd_size_type));
d375 17
a391 14
#define BFD_JUMP_TABLE_LINK(NAME)\
CAT(NAME,_sizeof_headers),\
CAT(NAME,_bfd_get_relocated_section_contents),\
CAT(NAME,_bfd_relax_section),\
CAT(NAME,_bfd_link_hash_table_create),\
CAT(NAME,_bfd_link_add_symbols),\
CAT(NAME,_bfd_final_link),\
CAT(NAME,_bfd_link_split_section),\
CAT(NAME,_bfd_gc_sections)
  int        (*_bfd_sizeof_headers) PARAMS ((bfd *, boolean));
  bfd_byte * (*_bfd_get_relocated_section_contents) PARAMS ((bfd *,
                    struct bfd_link_info *, struct bfd_link_order *,
                    bfd_byte *data, boolean relocateable,
                    struct symbol_cache_entry **));
d393 2
a394 2
  boolean    (*_bfd_relax_section) PARAMS ((bfd *, struct sec *,
                    struct bfd_link_info *, boolean *again));
d398 6
a403 1
  struct bfd_link_hash_table *(*_bfd_link_hash_table_create) PARAMS ((bfd *));
d406 6
a411 1
  boolean (*_bfd_link_add_symbols) PARAMS ((bfd *, struct bfd_link_info *));
d415 1
a415 1
  boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
d418 1
a418 1
  boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
d421 7
a427 1
  boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));
d430 7
a436 7
#define BFD_JUMP_TABLE_DYNAMIC(NAME)\
CAT(NAME,_get_dynamic_symtab_upper_bound),\
CAT(NAME,_canonicalize_dynamic_symtab),\
CAT(NAME,_get_dynamic_reloc_upper_bound),\
CAT(NAME,_canonicalize_dynamic_reloc)
  /* Get the amount of memory required to hold the dynamic symbols. */
  long  (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
d438 1
a438 1
  long  (*_bfd_canonicalize_dynamic_symtab)
d441 1
a441 1
  long  (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
d443 1
a443 1
  long  (*_bfd_canonicalize_dynamic_reloc)
d453 2
a454 2
 /* Opposite endian version of this target.  */
 const struct bfd_target * alternative_target;
d456 3
a458 5
@@end example
Data for use by back-end routines, which isn't generic enough to belong
in this structure.
@@example
 PTR backend_data;
d461 1
d468 1
a468 1
boolean bfd_set_default_target (const char *name);
d479 1
a479 1
const bfd_target *bfd_find_target(CONST char *target_name, bfd *abfd);
d496 1
a496 1
const char **bfd_target_list(void);
d507 3
a509 1
const bfd_target * bfd_search_for_target (int (* search_func) (const bfd_target *, void *), void *);
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d53 1
a53 1
@@code{bfd_check_format} returns @@code{TRUE} when the caller guesses right.
a103 1

d114 1
a114 2
enum bfd_flavour
@@{
d132 1
a132 6
  bfd_target_evax_flavour,
  bfd_target_mmo_flavour,
  bfd_target_mach_o_flavour,
  bfd_target_pef_flavour,
  bfd_target_pef_xlib_flavour,
  bfd_target_sym_flavour
d142 3
a144 1
  /* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  */
d146 4
a149 3

 /* The "flavour" of a back end is a general indication about
    the contents of a file.  */
d151 3
a153 2

  /* The order of bytes within the data area of a file.  */
d155 3
a157 2

 /* The order of bytes within the header parts of a file.  */
d159 4
a162 3

  /* A mask of all the flags which an executable may have set -
     from the set @@code{BFD_NO_FLAGS}, @@code{HAS_RELOC}, ...@@code{D_PAGED}.  */
d164 4
a167 3

 /* A mask of all the flags which a section may have set - from
    the set @@code{SEC_NO_FLAGS}, @@code{SEC_ALLOC}, ...@@code{SET_NEVER_LOAD}.  */
d169 4
a172 3

 /* The character normally found at the front of a symbol.
    (if any), perhaps `_'.  */
d174 3
a176 2

 /* The pad character for file names within an archive header.  */
d178 3
a180 2

  /* The maximum number of characters in an archive header.  */
d182 6
a187 5

  /* Entries for byte swapping for data. These are different from the
     other entry points, since they don't take a BFD asthe first argument.
     Certain other handlers could do the same.  */
  bfd_vma        (*bfd_getx64) PARAMS ((const bfd_byte *));
d189 2
a190 2
  void           (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_getx32) PARAMS ((const bfd_byte *));
d192 2
a193 2
  void           (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_getx16) PARAMS ((const bfd_byte *));
d195 5
a199 4
  void           (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));

  /* Byte swapping for the headers.  */
  bfd_vma        (*bfd_h_getx64) PARAMS ((const bfd_byte *));
d201 2
a202 2
  void           (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_h_getx32) PARAMS ((const bfd_byte *));
d204 2
a205 2
  void           (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_h_getx16) PARAMS ((const bfd_byte *));
d207 4
a210 1
  void           (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));
d212 2
a213 4
  /* Format dependent routines: these are vectors of entry points
     within the target vector structure, one for each format to check.  */

  /* Check the format of a file being read.  Return a @@code{bfd_target *} or zero.  */
d215 8
a222 7

  /* Set the format of a file being written.  */
  bfd_boolean (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));

  /* Write cached information into a file being written, at @@code{bfd_close}.  */
  bfd_boolean (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));

d229 6
a234 11
@@end example
Do not "beautify" the CONCAT* macro args.  Traditional C will not
remove whitespace added here, and thus will fail to concatenate
the tokens.
@@example
#define BFD_JUMP_TABLE_GENERIC(NAME) \
CONCAT2 (NAME,_close_and_cleanup), \
CONCAT2 (NAME,_bfd_free_cached_info), \
CONCAT2 (NAME,_new_section_hook), \
CONCAT2 (NAME,_get_section_contents), \
CONCAT2 (NAME,_get_section_contents_in_window)
d237 1
a237 1
  bfd_boolean (*_close_and_cleanup) PARAMS ((bfd *));
d239 1
a239 1
  bfd_boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
d241 1
a241 1
  bfd_boolean (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
d243 5
a247 4
  bfd_boolean (*_bfd_get_section_contents)
    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
  bfd_boolean (*_bfd_get_section_contents_in_window)
    PARAMS ((bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type));
d250 7
a256 7
#define BFD_JUMP_TABLE_COPY(NAME) \
CONCAT2 (NAME,_bfd_copy_private_bfd_data), \
CONCAT2 (NAME,_bfd_merge_private_bfd_data), \
CONCAT2 (NAME,_bfd_copy_private_section_data), \
CONCAT2 (NAME,_bfd_copy_private_symbol_data), \
CONCAT2 (NAME,_bfd_set_private_flags), \
CONCAT2 (NAME,_bfd_print_private_bfd_data) \
d259 1
a259 1
  bfd_boolean (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
d262 1
a262 1
  bfd_boolean (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
d265 2
a266 2
  bfd_boolean (*_bfd_copy_private_section_data)
    PARAMS ((bfd *, sec_ptr, bfd *, sec_ptr));
d269 4
a272 4
  bfd_boolean (*_bfd_copy_private_symbol_data)
    PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
  /* Called to set private backend flags.  */
  bfd_boolean (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
d274 2
a275 2
  /* Called to print private BFD data.  */
  bfd_boolean (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
d278 7
a284 7
#define BFD_JUMP_TABLE_CORE(NAME) \
CONCAT2 (NAME,_core_file_failing_command), \
CONCAT2 (NAME,_core_file_failing_signal), \
CONCAT2 (NAME,_core_file_matches_executable_p)
  char *      (*_core_file_failing_command) PARAMS ((bfd *));
  int         (*_core_file_failing_signal) PARAMS ((bfd *));
  bfd_boolean (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
d287 23
a309 20
#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
CONCAT2 (NAME,_slurp_armap), \
CONCAT2 (NAME,_slurp_extended_name_table), \
CONCAT2 (NAME,_construct_extended_name_table), \
CONCAT2 (NAME,_truncate_arname), \
CONCAT2 (NAME,_write_armap), \
CONCAT2 (NAME,_read_ar_hdr), \
CONCAT2 (NAME,_openr_next_archived_file), \
CONCAT2 (NAME,_get_elt_at_index), \
CONCAT2 (NAME,_generic_stat_arch_elt), \
CONCAT2 (NAME,_update_armap_timestamp)
  bfd_boolean (*_bfd_slurp_armap) PARAMS ((bfd *));
  bfd_boolean (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
  bfd_boolean (*_bfd_construct_extended_name_table)
    PARAMS ((bfd *, char **, bfd_size_type *, const char **));
  void        (*_bfd_truncate_arname) PARAMS ((bfd *, const char *, char *));
  bfd_boolean (*write_armap)
    PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
  PTR         (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
  bfd *       (*openr_next_archived_file) PARAMS ((bfd *, bfd *));
d311 3
a313 3
  bfd *       (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
  int         (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
  bfd_boolean (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
d316 20
a335 19
#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
CONCAT2 (NAME,_get_symtab_upper_bound), \
CONCAT2 (NAME,_get_symtab), \
CONCAT2 (NAME,_make_empty_symbol), \
CONCAT2 (NAME,_print_symbol), \
CONCAT2 (NAME,_get_symbol_info), \
CONCAT2 (NAME,_bfd_is_local_label_name), \
CONCAT2 (NAME,_get_lineno), \
CONCAT2 (NAME,_find_nearest_line), \
CONCAT2 (NAME,_bfd_make_debug_symbol), \
CONCAT2 (NAME,_read_minisymbols), \
CONCAT2 (NAME,_minisymbol_to_symbol)
  long        (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
  long        (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
                                                struct symbol_cache_entry **));
  struct symbol_cache_entry *
              (*_bfd_make_empty_symbol) PARAMS ((bfd *));
  void        (*_bfd_print_symbol)
    PARAMS ((bfd *, PTR, struct symbol_cache_entry *, bfd_print_symbol_type));
d337 3
a339 2
  void        (*_bfd_get_symbol_info)
    PARAMS ((bfd *, struct symbol_cache_entry *, symbol_info *));
d341 1
a341 1
  bfd_boolean (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
d343 5
a347 4
  alent *     (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
  bfd_boolean (*_bfd_find_nearest_line)
    PARAMS ((bfd *, struct sec *, struct symbol_cache_entry **, bfd_vma,
             const char **, const char **, unsigned int *));
d351 4
a354 2
  asymbol *   (*_bfd_make_debug_symbol)
    PARAMS ((bfd *, void *, unsigned long size));
d357 2
a358 2
  long        (*_read_minisymbols)
    PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));
d361 2
a362 2
  asymbol *   (*_minisymbol_to_symbol)
    PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));
d365 7
a371 7
#define BFD_JUMP_TABLE_RELOCS(NAME) \
CONCAT2 (NAME,_get_reloc_upper_bound), \
CONCAT2 (NAME,_canonicalize_reloc), \
CONCAT2 (NAME,_bfd_reloc_type_lookup)
  long        (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
  long        (*_bfd_canonicalize_reloc)
    PARAMS ((bfd *, sec_ptr, arelent **, struct symbol_cache_entry **));
d374 2
a375 1
              (*reloc_type_lookup) PARAMS ((bfd *, bfd_reloc_code_real_type));
d378 7
a384 7
#define BFD_JUMP_TABLE_WRITE(NAME) \
CONCAT2 (NAME,_set_arch_mach), \
CONCAT2 (NAME,_set_section_contents)
  bfd_boolean (*_bfd_set_arch_mach)
    PARAMS ((bfd *, enum bfd_architecture, unsigned long));
  bfd_boolean (*_bfd_set_section_contents)
    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d387 14
a400 17
#define BFD_JUMP_TABLE_LINK(NAME) \
CONCAT2 (NAME,_sizeof_headers), \
CONCAT2 (NAME,_bfd_get_relocated_section_contents), \
CONCAT2 (NAME,_bfd_relax_section), \
CONCAT2 (NAME,_bfd_link_hash_table_create), \
CONCAT2 (NAME,_bfd_link_hash_table_free), \
CONCAT2 (NAME,_bfd_link_add_symbols), \
CONCAT2 (NAME,_bfd_link_just_syms), \
CONCAT2 (NAME,_bfd_final_link), \
CONCAT2 (NAME,_bfd_link_split_section), \
CONCAT2 (NAME,_bfd_gc_sections), \
CONCAT2 (NAME,_bfd_merge_sections), \
CONCAT2 (NAME,_bfd_discard_group)
  int         (*_bfd_sizeof_headers) PARAMS ((bfd *, bfd_boolean));
  bfd_byte *  (*_bfd_get_relocated_section_contents)
    PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
             bfd_byte *, bfd_boolean, struct symbol_cache_entry **));
d402 2
a403 2
  bfd_boolean (*_bfd_relax_section)
    PARAMS ((bfd *, struct sec *, struct bfd_link_info *, bfd_boolean *));
d407 1
a407 6
  struct bfd_link_hash_table *
              (*_bfd_link_hash_table_create) PARAMS ((bfd *));

  /* Release the memory associated with the linker hash table.  */
  void        (*_bfd_link_hash_table_free)
    PARAMS ((struct bfd_link_hash_table *));
d410 1
a410 6
  bfd_boolean (*_bfd_link_add_symbols)
    PARAMS ((bfd *, struct bfd_link_info *));

  /* Indicate that we are only retrieving symbol values from this section.  */
  void        (*_bfd_link_just_syms)
    PARAMS ((asection *, struct bfd_link_info *));
d414 1
a414 1
  bfd_boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
d417 1
a417 1
  bfd_boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
d420 1
a420 7
  bfd_boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));

  /* Attempt to merge SEC_MERGE sections.  */
  bfd_boolean (*_bfd_merge_sections) PARAMS ((bfd *, struct bfd_link_info *));

  /* Discard members of a group.  */
  bfd_boolean (*_bfd_discard_group) PARAMS ((bfd *, struct sec *));
d423 7
a429 7
#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
CONCAT2 (NAME,_get_dynamic_symtab_upper_bound), \
CONCAT2 (NAME,_canonicalize_dynamic_symtab), \
CONCAT2 (NAME,_get_dynamic_reloc_upper_bound), \
CONCAT2 (NAME,_canonicalize_dynamic_reloc)
  /* Get the amount of memory required to hold the dynamic symbols.  */
  long        (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
d431 1
a431 1
  long        (*_bfd_canonicalize_dynamic_symtab)
d434 1
a434 1
  long        (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
d436 1
a436 1
  long        (*_bfd_canonicalize_dynamic_reloc)
d446 2
a447 2
  /* Opposite endian version of this target.  */
  const struct bfd_target * alternative_target;
d449 5
a453 3
  /* Data for use by back-end routines, which isn't
     generic enough to belong in this structure.  */
  PTR backend_data;
a455 1

d462 1
a462 1
bfd_boolean bfd_set_default_target (const char *name);
d473 1
a473 1
const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
d490 1
a490 1
const char ** bfd_target_list (void);
d501 1
a501 3
const bfd_target * bfd_search_for_target (int (* search_func)
       (const bfd_target *, void *),
    void *);
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d5 1
a5 1
Each port of BFD to a different machine requires the creation
d82 1
a82 1
  ((*((bfd)->xvec->message)) arglist)
d95 1
a95 1
  (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
d183 9
a191 9
  bfd_uint64_t   (*bfd_getx64) (const void *);
  bfd_int64_t    (*bfd_getx_signed_64) (const void *);
  void           (*bfd_putx64) (bfd_uint64_t, void *);
  bfd_vma        (*bfd_getx32) (const void *);
  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
  void           (*bfd_putx32) (bfd_vma, void *);
  bfd_vma        (*bfd_getx16) (const void *);
  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
  void           (*bfd_putx16) (bfd_vma, void *);
d194 9
a202 9
  bfd_uint64_t   (*bfd_h_getx64) (const void *);
  bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
  void           (*bfd_h_putx64) (bfd_uint64_t, void *);
  bfd_vma        (*bfd_h_getx32) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
  void           (*bfd_h_putx32) (bfd_vma, void *);
  bfd_vma        (*bfd_h_getx16) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
  void           (*bfd_h_putx16) (bfd_vma, void *);
d208 1
a208 1
  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);
d211 1
a211 1
  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);
d214 1
a214 1
  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
d222 5
d228 5
a232 5
  NAME##_close_and_cleanup, \
  NAME##_bfd_free_cached_info, \
  NAME##_new_section_hook, \
  NAME##_get_section_contents, \
  NAME##_get_section_contents_in_window
d235 1
a235 1
  bfd_boolean (*_close_and_cleanup) (bfd *);
d237 1
a237 1
  bfd_boolean (*_bfd_free_cached_info) (bfd *);
d239 1
a239 1
  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
d242 1
a242 1
    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
d244 1
a244 1
    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
d248 6
a253 7
  NAME##_bfd_copy_private_bfd_data, \
  NAME##_bfd_merge_private_bfd_data, \
  NAME##_bfd_copy_private_section_data, \
  NAME##_bfd_copy_private_symbol_data, \
  NAME##_bfd_set_private_flags, \
  NAME##_bfd_print_private_bfd_data

d256 1
a256 1
  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
d259 1
a259 1
  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, bfd *);
d263 1
a263 1
    (bfd *, sec_ptr, bfd *, sec_ptr);
d267 1
a267 1
    (bfd *, asymbol *, bfd *, asymbol *);
d269 1
a269 1
  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);
d272 1
a272 1
  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
d276 6
a281 7
  NAME##_core_file_failing_command, \
  NAME##_core_file_failing_signal, \
  NAME##_core_file_matches_executable_p

  char *      (*_core_file_failing_command) (bfd *);
  int         (*_core_file_failing_signal) (bfd *);
  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
d285 12
a296 13
  NAME##_slurp_armap, \
  NAME##_slurp_extended_name_table, \
  NAME##_construct_extended_name_table, \
  NAME##_truncate_arname, \
  NAME##_write_armap, \
  NAME##_read_ar_hdr, \
  NAME##_openr_next_archived_file, \
  NAME##_get_elt_at_index, \
  NAME##_generic_stat_arch_elt, \
  NAME##_update_armap_timestamp

  bfd_boolean (*_bfd_slurp_armap) (bfd *);
  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
d298 2
a299 2
    (bfd *, char **, bfd_size_type *, const char **);
  void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
d301 7
a307 7
    (bfd *, unsigned int, struct orl *, unsigned int, int);
  void *      (*_bfd_read_ar_hdr_fn) (bfd *);
  bfd *       (*openr_next_archived_file) (bfd *, bfd *);
#define bfd_get_elt_at_index(b,i) BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
  bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
  int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
d311 16
a326 17
  NAME##_get_symtab_upper_bound, \
  NAME##_canonicalize_symtab, \
  NAME##_make_empty_symbol, \
  NAME##_print_symbol, \
  NAME##_get_symbol_info, \
  NAME##_bfd_is_local_label_name, \
  NAME##_get_lineno, \
  NAME##_find_nearest_line, \
  NAME##_bfd_make_debug_symbol, \
  NAME##_read_minisymbols, \
  NAME##_minisymbol_to_symbol

  long        (*_bfd_get_symtab_upper_bound) (bfd *);
  long        (*_bfd_canonicalize_symtab)
    (bfd *, struct bfd_symbol **);
  struct bfd_symbol *
              (*_bfd_make_empty_symbol) (bfd *);
d328 2
a329 2
    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
d331 3
a333 3
    (bfd *, struct bfd_symbol *, symbol_info *);
#define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
d335 1
a335 1
  alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
d337 2
a338 2
    (bfd *, struct bfd_section *, struct bfd_symbol **, bfd_vma,
     const char **, const char **, unsigned int *);
d343 1
a343 1
    (bfd *, void *, unsigned long size);
d347 1
a347 1
    (bfd *, bfd_boolean, void **, unsigned int *);
d351 1
a351 1
    (bfd *, bfd_boolean, const void *, asymbol *);
d355 4
a358 5
  NAME##_get_reloc_upper_bound, \
  NAME##_canonicalize_reloc, \
  NAME##_bfd_reloc_type_lookup

  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
d360 1
a360 1
    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
d363 1
a363 1
              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
d367 2
a368 3
  NAME##_set_arch_mach, \
  NAME##_set_section_contents

d370 1
a370 1
    (bfd *, enum bfd_architecture, unsigned long);
d372 1
a372 1
    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
d376 13
a388 14
  NAME##_sizeof_headers, \
  NAME##_bfd_get_relocated_section_contents, \
  NAME##_bfd_relax_section, \
  NAME##_bfd_link_hash_table_create, \
  NAME##_bfd_link_hash_table_free, \
  NAME##_bfd_link_add_symbols, \
  NAME##_bfd_link_just_syms, \
  NAME##_bfd_final_link, \
  NAME##_bfd_link_split_section, \
  NAME##_bfd_gc_sections, \
  NAME##_bfd_merge_sections, \
  NAME##_bfd_discard_group

  int         (*_bfd_sizeof_headers) (bfd *, bfd_boolean);
d390 2
a391 2
    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
     bfd_byte *, bfd_boolean, struct bfd_symbol **);
d394 1
a394 1
    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);
d399 1
a399 1
              (*_bfd_link_hash_table_create) (bfd *);
d402 2
a403 1
  void        (*_bfd_link_hash_table_free) (struct bfd_link_hash_table *);
d406 2
a407 1
  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);
d410 2
a411 1
  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
d415 1
a415 1
  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
d418 1
a418 1
  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);
d421 1
a421 1
  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);
d424 1
a424 1
  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);
d427 1
a427 1
  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);
d431 4
a434 5
  NAME##_get_dynamic_symtab_upper_bound, \
  NAME##_canonicalize_dynamic_symtab, \
  NAME##_get_dynamic_reloc_upper_bound, \
  NAME##_canonicalize_dynamic_reloc

d436 1
a436 1
  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
d439 1
a439 1
    (bfd *, struct bfd_symbol **);
d441 1
a441 1
  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
d444 1
a444 1
    (bfd *, arelent **, struct bfd_symbol **);
d458 1
a458 1
  const void *backend_data;
d507 2
a508 2
const bfd_target *bfd_search_for_target
   (int (*search_func) (const bfd_target *, void *),
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d53 1
a53 1
@@code{bfd_check_format} returns @@code{TRUE} when the caller guesses right.
a103 1

d114 1
a114 2
enum bfd_flavour
@@{
d132 1
a132 6
  bfd_target_evax_flavour,
  bfd_target_mmo_flavour,
  bfd_target_mach_o_flavour,
  bfd_target_pef_flavour,
  bfd_target_pef_xlib_flavour,
  bfd_target_sym_flavour
d142 3
a144 1
  /* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  */
d146 4
a149 3

 /* The "flavour" of a back end is a general indication about
    the contents of a file.  */
d151 3
a153 2

  /* The order of bytes within the data area of a file.  */
d155 3
a157 2

 /* The order of bytes within the header parts of a file.  */
d159 4
a162 3

  /* A mask of all the flags which an executable may have set -
     from the set @@code{BFD_NO_FLAGS}, @@code{HAS_RELOC}, ...@@code{D_PAGED}.  */
d164 4
a167 3

 /* A mask of all the flags which a section may have set - from
    the set @@code{SEC_NO_FLAGS}, @@code{SEC_ALLOC}, ...@@code{SET_NEVER_LOAD}.  */
d169 4
a172 3

 /* The character normally found at the front of a symbol.
    (if any), perhaps `_'.  */
d174 3
a176 2

 /* The pad character for file names within an archive header.  */
d178 3
a180 2

  /* The maximum number of characters in an archive header.  */
d182 6
a187 5

  /* Entries for byte swapping for data. These are different from the
     other entry points, since they don't take a BFD asthe first argument.
     Certain other handlers could do the same.  */
  bfd_vma        (*bfd_getx64) PARAMS ((const bfd_byte *));
d189 2
a190 2
  void           (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_getx32) PARAMS ((const bfd_byte *));
d192 2
a193 2
  void           (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_getx16) PARAMS ((const bfd_byte *));
d195 5
a199 4
  void           (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));

  /* Byte swapping for the headers.  */
  bfd_vma        (*bfd_h_getx64) PARAMS ((const bfd_byte *));
d201 2
a202 2
  void           (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_h_getx32) PARAMS ((const bfd_byte *));
d204 2
a205 2
  void           (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_h_getx16) PARAMS ((const bfd_byte *));
d207 4
a210 1
  void           (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));
d212 2
a213 4
  /* Format dependent routines: these are vectors of entry points
     within the target vector structure, one for each format to check.  */

  /* Check the format of a file being read.  Return a @@code{bfd_target *} or zero.  */
d215 8
a222 7

  /* Set the format of a file being written.  */
  bfd_boolean (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));

  /* Write cached information into a file being written, at @@code{bfd_close}.  */
  bfd_boolean (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));

d229 6
a234 11
@@end example
Do not "beautify" the CONCAT* macro args.  Traditional C will not
remove whitespace added here, and thus will fail to concatenate
the tokens.
@@example
#define BFD_JUMP_TABLE_GENERIC(NAME) \
CONCAT2 (NAME,_close_and_cleanup), \
CONCAT2 (NAME,_bfd_free_cached_info), \
CONCAT2 (NAME,_new_section_hook), \
CONCAT2 (NAME,_get_section_contents), \
CONCAT2 (NAME,_get_section_contents_in_window)
d237 1
a237 1
  bfd_boolean (*_close_and_cleanup) PARAMS ((bfd *));
d239 1
a239 1
  bfd_boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
d241 1
a241 1
  bfd_boolean (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
d243 5
a247 4
  bfd_boolean (*_bfd_get_section_contents)
    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
  bfd_boolean (*_bfd_get_section_contents_in_window)
    PARAMS ((bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type));
d250 7
a256 7
#define BFD_JUMP_TABLE_COPY(NAME) \
CONCAT2 (NAME,_bfd_copy_private_bfd_data), \
CONCAT2 (NAME,_bfd_merge_private_bfd_data), \
CONCAT2 (NAME,_bfd_copy_private_section_data), \
CONCAT2 (NAME,_bfd_copy_private_symbol_data), \
CONCAT2 (NAME,_bfd_set_private_flags), \
CONCAT2 (NAME,_bfd_print_private_bfd_data) \
d259 1
a259 1
  bfd_boolean (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
d262 1
a262 1
  bfd_boolean (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
d265 2
a266 2
  bfd_boolean (*_bfd_copy_private_section_data)
    PARAMS ((bfd *, sec_ptr, bfd *, sec_ptr));
d269 4
a272 4
  bfd_boolean (*_bfd_copy_private_symbol_data)
    PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
  /* Called to set private backend flags.  */
  bfd_boolean (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
d274 2
a275 2
  /* Called to print private BFD data.  */
  bfd_boolean (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
d278 7
a284 7
#define BFD_JUMP_TABLE_CORE(NAME) \
CONCAT2 (NAME,_core_file_failing_command), \
CONCAT2 (NAME,_core_file_failing_signal), \
CONCAT2 (NAME,_core_file_matches_executable_p)
  char *      (*_core_file_failing_command) PARAMS ((bfd *));
  int         (*_core_file_failing_signal) PARAMS ((bfd *));
  bfd_boolean (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
d287 23
a309 20
#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
CONCAT2 (NAME,_slurp_armap), \
CONCAT2 (NAME,_slurp_extended_name_table), \
CONCAT2 (NAME,_construct_extended_name_table), \
CONCAT2 (NAME,_truncate_arname), \
CONCAT2 (NAME,_write_armap), \
CONCAT2 (NAME,_read_ar_hdr), \
CONCAT2 (NAME,_openr_next_archived_file), \
CONCAT2 (NAME,_get_elt_at_index), \
CONCAT2 (NAME,_generic_stat_arch_elt), \
CONCAT2 (NAME,_update_armap_timestamp)
  bfd_boolean (*_bfd_slurp_armap) PARAMS ((bfd *));
  bfd_boolean (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
  bfd_boolean (*_bfd_construct_extended_name_table)
    PARAMS ((bfd *, char **, bfd_size_type *, const char **));
  void        (*_bfd_truncate_arname) PARAMS ((bfd *, const char *, char *));
  bfd_boolean (*write_armap)
    PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
  PTR         (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
  bfd *       (*openr_next_archived_file) PARAMS ((bfd *, bfd *));
d311 3
a313 3
  bfd *       (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
  int         (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
  bfd_boolean (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
d316 20
a335 19
#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
CONCAT2 (NAME,_get_symtab_upper_bound), \
CONCAT2 (NAME,_get_symtab), \
CONCAT2 (NAME,_make_empty_symbol), \
CONCAT2 (NAME,_print_symbol), \
CONCAT2 (NAME,_get_symbol_info), \
CONCAT2 (NAME,_bfd_is_local_label_name), \
CONCAT2 (NAME,_get_lineno), \
CONCAT2 (NAME,_find_nearest_line), \
CONCAT2 (NAME,_bfd_make_debug_symbol), \
CONCAT2 (NAME,_read_minisymbols), \
CONCAT2 (NAME,_minisymbol_to_symbol)
  long        (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
  long        (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
                                                struct symbol_cache_entry **));
  struct symbol_cache_entry *
              (*_bfd_make_empty_symbol) PARAMS ((bfd *));
  void        (*_bfd_print_symbol)
    PARAMS ((bfd *, PTR, struct symbol_cache_entry *, bfd_print_symbol_type));
d337 3
a339 2
  void        (*_bfd_get_symbol_info)
    PARAMS ((bfd *, struct symbol_cache_entry *, symbol_info *));
d341 1
a341 1
  bfd_boolean (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
d343 5
a347 4
  alent *     (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
  bfd_boolean (*_bfd_find_nearest_line)
    PARAMS ((bfd *, struct sec *, struct symbol_cache_entry **, bfd_vma,
             const char **, const char **, unsigned int *));
d351 4
a354 2
  asymbol *   (*_bfd_make_debug_symbol)
    PARAMS ((bfd *, void *, unsigned long size));
d357 2
a358 2
  long        (*_read_minisymbols)
    PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));
d361 2
a362 2
  asymbol *   (*_minisymbol_to_symbol)
    PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));
d365 7
a371 7
#define BFD_JUMP_TABLE_RELOCS(NAME) \
CONCAT2 (NAME,_get_reloc_upper_bound), \
CONCAT2 (NAME,_canonicalize_reloc), \
CONCAT2 (NAME,_bfd_reloc_type_lookup)
  long        (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
  long        (*_bfd_canonicalize_reloc)
    PARAMS ((bfd *, sec_ptr, arelent **, struct symbol_cache_entry **));
d374 2
a375 1
              (*reloc_type_lookup) PARAMS ((bfd *, bfd_reloc_code_real_type));
d378 7
a384 7
#define BFD_JUMP_TABLE_WRITE(NAME) \
CONCAT2 (NAME,_set_arch_mach), \
CONCAT2 (NAME,_set_section_contents)
  bfd_boolean (*_bfd_set_arch_mach)
    PARAMS ((bfd *, enum bfd_architecture, unsigned long));
  bfd_boolean (*_bfd_set_section_contents)
    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d387 14
a400 17
#define BFD_JUMP_TABLE_LINK(NAME) \
CONCAT2 (NAME,_sizeof_headers), \
CONCAT2 (NAME,_bfd_get_relocated_section_contents), \
CONCAT2 (NAME,_bfd_relax_section), \
CONCAT2 (NAME,_bfd_link_hash_table_create), \
CONCAT2 (NAME,_bfd_link_hash_table_free), \
CONCAT2 (NAME,_bfd_link_add_symbols), \
CONCAT2 (NAME,_bfd_link_just_syms), \
CONCAT2 (NAME,_bfd_final_link), \
CONCAT2 (NAME,_bfd_link_split_section), \
CONCAT2 (NAME,_bfd_gc_sections), \
CONCAT2 (NAME,_bfd_merge_sections), \
CONCAT2 (NAME,_bfd_discard_group)
  int         (*_bfd_sizeof_headers) PARAMS ((bfd *, bfd_boolean));
  bfd_byte *  (*_bfd_get_relocated_section_contents)
    PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
             bfd_byte *, bfd_boolean, struct symbol_cache_entry **));
d402 2
a403 2
  bfd_boolean (*_bfd_relax_section)
    PARAMS ((bfd *, struct sec *, struct bfd_link_info *, bfd_boolean *));
d407 1
a407 6
  struct bfd_link_hash_table *
              (*_bfd_link_hash_table_create) PARAMS ((bfd *));

  /* Release the memory associated with the linker hash table.  */
  void        (*_bfd_link_hash_table_free)
    PARAMS ((struct bfd_link_hash_table *));
d410 1
a410 6
  bfd_boolean (*_bfd_link_add_symbols)
    PARAMS ((bfd *, struct bfd_link_info *));

  /* Indicate that we are only retrieving symbol values from this section.  */
  void        (*_bfd_link_just_syms)
    PARAMS ((asection *, struct bfd_link_info *));
d414 1
a414 1
  bfd_boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
d417 1
a417 1
  bfd_boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
d420 1
a420 7
  bfd_boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));

  /* Attempt to merge SEC_MERGE sections.  */
  bfd_boolean (*_bfd_merge_sections) PARAMS ((bfd *, struct bfd_link_info *));

  /* Discard members of a group.  */
  bfd_boolean (*_bfd_discard_group) PARAMS ((bfd *, struct sec *));
d423 7
a429 7
#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
CONCAT2 (NAME,_get_dynamic_symtab_upper_bound), \
CONCAT2 (NAME,_canonicalize_dynamic_symtab), \
CONCAT2 (NAME,_get_dynamic_reloc_upper_bound), \
CONCAT2 (NAME,_canonicalize_dynamic_reloc)
  /* Get the amount of memory required to hold the dynamic symbols.  */
  long        (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
d431 1
a431 1
  long        (*_bfd_canonicalize_dynamic_symtab)
d434 1
a434 1
  long        (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
d436 1
a436 1
  long        (*_bfd_canonicalize_dynamic_reloc)
d446 2
a447 2
  /* Opposite endian version of this target.  */
  const struct bfd_target * alternative_target;
d449 5
a453 3
  /* Data for use by back-end routines, which isn't
     generic enough to belong in this structure.  */
  PTR backend_data;
a455 1

d462 1
a462 1
bfd_boolean bfd_set_default_target (const char *name);
d473 1
a473 1
const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
d490 1
a490 1
const char ** bfd_target_list (void);
d501 1
a501 3
const bfd_target * bfd_search_for_target (int (* search_func)
       (const bfd_target *, void *),
    void *);
@

