head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.21.26.16;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.07.59;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.13;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.41.13;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.31.54;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.43.00;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.08.12;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.16.50;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* Instruction printing code for the ARM
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Contributed by Richard Earnshaw (rwe@@pegasus.esprit.ec.org)
   Modification by James G. Smith (jsmith@@cygnus.co.uk)

   This file is part of libopcodes.

   This program is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#define DEFINE_TABLE
#include "arm-opc.h"
#include "coff/internal.h"
#include "libcoff.h"
#include "opintl.h"

/* FIXME: This shouldn't be done here.  */
#include "elf-bfd.h"
#include "elf/internal.h"
#include "elf/arm.h"

#ifndef streq
#define streq(a,b)	(strcmp ((a), (b)) == 0)
#endif

#ifndef strneq
#define strneq(a,b,n)	(strncmp ((a), (b), (n)) == 0)
#endif

#ifndef NUM_ELEM
#define NUM_ELEM(a)     (sizeof (a) / sizeof (a)[0])
#endif

static char * arm_conditional[] =
{"eq", "ne", "cs", "cc", "mi", "pl", "vs", "vc",
 "hi", "ls", "ge", "lt", "gt", "le", "", "nv"};

typedef struct
{
  const char * name;
  const char * description;
  const char * reg_names[16];
}
arm_regname;

static arm_regname regnames[] =
{
  { "raw" , "Select raw register names",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"}},
  { "gcc",  "Select register names used by GCC",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
  { "std",  "Select register names used in ARM's ISA documentation",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "sp",  "lr",  "pc" }},
  { "apcs", "Select register names used in the APCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
  { "atpcs", "Select register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "v7",  "v8",  "IP",  "SP",  "LR",  "PC" }},
  { "special-atpcs", "Select special register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }},
  { "iwmmxt_regnames", "Select register names used on the Intel Wireless MMX technology coprocessor",
    { "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7", "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15"}},
  { "iwmmxt_Cregnames", "Select control register names used on the Intel Wireless MMX technology coprocessor",
    {"wcid", "wcon", "wcssf", "wcasf", "reserved", "reserved", "reserved", "reserved", "wcgr0", "wcgr1", "wcgr2", "wcgr3", "reserved", "reserved", "reserved", "reserved"}}
};

static char * iwmmxt_wwnames[] =
{"b", "h", "w", "d"};

static char * iwmmxt_wwssnames[] =
{"b", "bus", "b", "bss",
 "h", "hus", "h", "hss",
 "w", "wus", "w", "wss",
 "d", "dus", "d", "dss"
};

/* Default to GCC register name set.  */
static unsigned int regname_selected = 1;

#define NUM_ARM_REGNAMES  NUM_ELEM (regnames)
#define arm_regnames      regnames[regname_selected].reg_names

static bfd_boolean force_thumb = FALSE;

static char * arm_fp_const[] =
{"0.0", "1.0", "2.0", "3.0", "4.0", "5.0", "0.5", "10.0"};

static char * arm_shift[] =
{"lsl", "lsr", "asr", "ror"};

/* Forward declarations.  */
static void arm_decode_shift
  PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options
  PARAMS ((char *));
static int  print_insn
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
static int set_iwmmxt_regnames
  PARAMS ((void));

int get_arm_regname_num_options
  PARAMS ((void));
int set_arm_regname_option
  PARAMS ((int));
int get_arm_regnames
  PARAMS ((int, const char **, const char **, const char ***));

/* Functions.  */
int
get_arm_regname_num_options ()
{
  return NUM_ARM_REGNAMES;
}

int
set_arm_regname_option (option)
     int option;
{
  int old = regname_selected;
  regname_selected = option;
  return old;
}

int
get_arm_regnames (option, setname, setdescription, register_names)
     int option;
     const char **setname;
     const char **setdescription;
     const char ***register_names;
{
  *setname = regnames[option].name;
  *setdescription = regnames[option].description;
  *register_names = regnames[option].reg_names;
  return 16;
}

static void
arm_decode_shift (given, func, stream)
     long given;
     fprintf_ftype func;
     void * stream;
{
  func (stream, "%s", arm_regnames[given & 0xf]);

  if ((given & 0xff0) != 0)
    {
      if ((given & 0x10) == 0)
	{
	  int amount = (given & 0xf80) >> 7;
	  int shift = (given & 0x60) >> 5;

	  if (amount == 0)
	    {
	      if (shift == 3)
		{
		  func (stream, ", rrx");
		  return;
		}

	      amount = 32;
	    }

	  func (stream, ", %s #%d", arm_shift[shift], amount);
	}
      else
	func (stream, ", %s %s", arm_shift[(given & 0x60) >> 5],
	      arm_regnames[(given & 0xf00) >> 8]);
    }
}

static int
set_iwmmxt_regnames ()
{
  const char * setname;
  const char * setdesc;
  const char ** regnames;
  int iwmmxt_regnames = 0;
  int num_regnames = get_arm_regname_num_options ();

  get_arm_regnames (iwmmxt_regnames, &setname,
		    &setdesc, &regnames);
  while ((strcmp ("iwmmxt_regnames", setname))
	 && (iwmmxt_regnames < num_regnames))
    get_arm_regnames (++iwmmxt_regnames, &setname, &setdesc, &regnames);

  return iwmmxt_regnames;
}
			  
/* Print one instruction from PC on INFO->STREAM.
   Return the size of the instruction (always 4 on ARM). */

static int
print_insn_arm (pc, info, given)
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
{
  const struct arm_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func   = info->fprintf_func;
  static int iwmmxt_regnames = 0;

  for (insn = arm_opcodes; insn->assembler; insn++)
    {
      if (insn->value == FIRST_IWMMXT_INSN
	  && info->mach != bfd_mach_arm_XScale
	  && info->mach != bfd_mach_arm_iWMMXt)
	insn = insn + IWMMXT_INSN_COUNT;

      if ((given & insn->mask) == insn->value)
	{
	  char * c;

	  for (c = insn->assembler; *c; c++)
	    {
	      if (*c == '%')
		{
		  switch (*++c)
		    {
		    case '%':
		      func (stream, "%%");
		      break;

		    case 'a':
		      if (((given & 0x000f0000) == 0x000f0000)
			  && ((given & 0x02000000) == 0))
			{
			  int offset = given & 0xfff;

			  func (stream, "[pc");

			  if (given & 0x01000000)
			    {
			      if ((given & 0x00800000) == 0)
				offset = - offset;

			      /* Pre-indexed.  */
			      func (stream, ", #%d]", offset);

			      offset += pc + 8;

			      /* Cope with the possibility of write-back
				 being used.  Probably a very dangerous thing
				 for the programmer to do, but who are we to
				 argue ?  */
			      if (given & 0x00200000)
				func (stream, "!");
			    }
			  else
			    {
			      /* Post indexed.  */
			      func (stream, "], #%d", offset);

			      /* ie ignore the offset.  */
			      offset = pc + 8;
			    }

			  func (stream, "\t; ");
			  info->print_address_func (offset, info);
			}
		      else
			{
			  func (stream, "[%s",
				arm_regnames[(given >> 16) & 0xf]);
			  if ((given & 0x01000000) != 0)
			    {
			      if ((given & 0x02000000) == 0)
				{
				  int offset = given & 0xfff;
				  if (offset)
				    func (stream, ", %s#%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				}
			      else
				{
				  func (stream, ", %s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""));
				  arm_decode_shift (given, func, stream);
				}

			      func (stream, "]%s",
				    ((given & 0x00200000) != 0) ? "!" : "");
			    }
			  else
			    {
			      if ((given & 0x02000000) == 0)
				{
				  int offset = given & 0xfff;
				  if (offset)
				    func (stream, "], %s#%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				  else
				    func (stream, "]");
				}
			      else
				{
				  func (stream, "], %s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""));
				  arm_decode_shift (given, func, stream);
				}
			    }
			}
		      break;

		    case 's':
                      if ((given & 0x004f0000) == 0x004f0000)
			{
                          /* PC relative with immediate offset.  */
			  int offset = ((given & 0xf00) >> 4) | (given & 0xf);

			  if ((given & 0x00800000) == 0)
			    offset = -offset;

			  func (stream, "[pc, #%d]\t; ", offset);

			  (*info->print_address_func)
			    (offset + pc + 8, info);
			}
		      else
			{
			  func (stream, "[%s",
				arm_regnames[(given >> 16) & 0xf]);
			  if ((given & 0x01000000) != 0)
			    {
                              /* Pre-indexed.  */
			      if ((given & 0x00400000) == 0x00400000)
				{
                                  /* Immediate.  */
                                  int offset = ((given & 0xf00) >> 4) | (given & 0xf);
				  if (offset)
				    func (stream, ", %s#%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				}
			      else
				{
                                  /* Register.  */
				  func (stream, ", %s%s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""),
                                        arm_regnames[given & 0xf]);
				}

			      func (stream, "]%s",
				    ((given & 0x00200000) != 0) ? "!" : "");
			    }
			  else
			    {
                              /* Post-indexed.  */
			      if ((given & 0x00400000) == 0x00400000)
				{
                                  /* Immediate.  */
                                  int offset = ((given & 0xf00) >> 4) | (given & 0xf);
				  if (offset)
				    func (stream, "], %s#%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				  else
				    func (stream, "]");
				}
			      else
				{
                                  /* Register.  */
				  func (stream, "], %s%s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""),
                                        arm_regnames[given & 0xf]);
				}
			    }
			}
		      break;

		    case 'b':
		      (*info->print_address_func)
			(BDISP (given) * 4 + pc + 8, info);
		      break;

		    case 'c':
		      func (stream, "%s",
			    arm_conditional [(given >> 28) & 0xf]);
		      break;

		    case 'm':
		      {
			int started = 0;
			int reg;

			func (stream, "{");
			for (reg = 0; reg < 16; reg++)
			  if ((given & (1 << reg)) != 0)
			    {
			      if (started)
				func (stream, ", ");
			      started = 1;
			      func (stream, "%s", arm_regnames[reg]);
			    }
			func (stream, "}");
		      }
		      break;

		    case 'o':
		      if ((given & 0x02000000) != 0)
			{
			  int rotate = (given & 0xf00) >> 7;
			  int immed = (given & 0xff);
			  immed = (((immed << (32 - rotate))
				    | (immed >> rotate)) & 0xffffffff);
			  func (stream, "#%d\t; 0x%x", immed, immed);
			}
		      else
			arm_decode_shift (given, func, stream);
		      break;

		    case 'p':
		      if ((given & 0x0000f000) == 0x0000f000)
			func (stream, "p");
		      break;

		    case 't':
		      if ((given & 0x01200000) == 0x00200000)
			func (stream, "t");
		      break;

		    case 'A':
		      func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);
		      if ((given & 0x01000000) != 0)
			{
			  int offset = given & 0xff;
			  if (offset)
			    func (stream, ", %s#%d]%s",
				  ((given & 0x00800000) == 0 ? "-" : ""),
				  offset * 4,
				  ((given & 0x00200000) != 0 ? "!" : ""));
			  else
			    func (stream, "]");
			}
		      else
			{
			  int offset = given & 0xff;
			  if (offset)
			    func (stream, "], %s#%d",
				  ((given & 0x00800000) == 0 ? "-" : ""),
				  offset * 4);
			  else
			    func (stream, "]");
			}
		      break;

		    case 'B':
		      /* Print ARM V5 BLX(1) address: pc+25 bits.  */
		      {
			bfd_vma address;
			bfd_vma offset = 0;

			if (given & 0x00800000)
			  /* Is signed, hi bits should be ones.  */
			  offset = (-1) ^ 0x00ffffff;

			/* Offset is (SignExtend(offset field)<<2).  */
			offset += given & 0x00ffffff;
			offset <<= 2;
			address = offset + pc + 8;

			if (given & 0x01000000)
			  /* H bit allows addressing to 2-byte boundaries.  */
			  address += 2;

		        info->print_address_func (address, info);
		      }
		      break;

		    case 'I':
		      /* Print a Cirrus/DSP shift immediate.  */
		      /* Immediates are 7bit signed ints with bits 0..3 in
			 bits 0..3 of opcode and bits 4..6 in bits 5..7
			 of opcode.  */
		      {
			int imm;

			imm = (given & 0xf) | ((given & 0xe0) >> 1);

			/* Is ``imm'' a negative number?  */
			if (imm & 0x40)
			  imm |= (-1 << 7);

			func (stream, "%d", imm);
		      }

		      break;

		    case 'C':
		      func (stream, "_");
		      if (given & 0x80000)
			func (stream, "f");
		      if (given & 0x40000)
			func (stream, "s");
		      if (given & 0x20000)
			func (stream, "x");
		      if (given & 0x10000)
			func (stream, "c");
		      break;

		    case 'F':
		      switch (given & 0x00408000)
			{
			case 0:
			  func (stream, "4");
			  break;
			case 0x8000:
			  func (stream, "1");
			  break;
			case 0x00400000:
			  func (stream, "2");
			  break;
			default:
			  func (stream, "3");
			}
		      break;

		    case 'P':
		      switch (given & 0x00080080)
			{
			case 0:
			  func (stream, "s");
			  break;
			case 0x80:
			  func (stream, "d");
			  break;
			case 0x00080000:
			  func (stream, "e");
			  break;
			default:
			  func (stream, _("<illegal precision>"));
			  break;
			}
		      break;
		    case 'Q':
		      switch (given & 0x00408000)
			{
			case 0:
			  func (stream, "s");
			  break;
			case 0x8000:
			  func (stream, "d");
			  break;
			case 0x00400000:
			  func (stream, "e");
			  break;
			default:
			  func (stream, "p");
			  break;
			}
		      break;
		    case 'R':
		      switch (given & 0x60)
			{
			case 0:
			  break;
			case 0x20:
			  func (stream, "p");
			  break;
			case 0x40:
			  func (stream, "m");
			  break;
			default:
			  func (stream, "z");
			  break;
			}
		      break;

		    case '0': case '1': case '2': case '3': case '4':
		    case '5': case '6': case '7': case '8': case '9':
		      {
			int bitstart = *c++ - '0';
			int bitend = 0;
			while (*c >= '0' && *c <= '9')
			  bitstart = (bitstart * 10) + *c++ - '0';

			switch (*c)
			  {
			  case '-':
			    c++;

			    while (*c >= '0' && *c <= '9')
			      bitend = (bitend * 10) + *c++ - '0';

			    if (!bitend)
			      abort ();

			    switch (*c)
			      {
			      case 'r':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "%s", arm_regnames[reg]);
				}
				break;
			      case 'd':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "%d", reg);
				}
				break;
			      case 'x':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "0x%08x", reg);

				  /* Some SWI instructions have special
				     meanings.  */
				  if ((given & 0x0fffffff) == 0x0FF00000)
				    func (stream, "\t; IMB");
				  else if ((given & 0x0fffffff) == 0x0FF00001)
				    func (stream, "\t; IMBRange");
				}
				break;
			      case 'X':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "%01x", reg & 0xf);
				}
				break;
			      case 'f':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  if (reg > 7)
				    func (stream, "#%s",
					  arm_fp_const[reg & 7]);
				  else
				    func (stream, "f%d", reg);
				}
				break;

			      case 'w':
				{
				  long reg;

				  if (bitstart != bitend)
				    {
				      reg = given >> bitstart;
				      reg &= (2 << (bitend - bitstart)) - 1;
				      if (bitend - bitstart == 1)
					func (stream, "%s", iwmmxt_wwnames[reg]);
				      else
					func (stream, "%s", iwmmxt_wwssnames[reg]);
				    }
				  else
				    {
				      reg = (((given >> 8)  & 0x1) |
					     ((given >> 22) & 0x1));
				      func (stream, "%s", iwmmxt_wwnames[reg]);
				    }
				}
				break;

			      case 'g':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

			      case 'G':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames + 1);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

			      default:
				abort ();
			      }
			    break;

			  case 'y':
			  case 'z':
			    {
			      int single = *c == 'y';
			      int regno;

			      switch (bitstart)
				{
				case 4: /* Sm pair */
				  func (stream, "{");
				  /* Fall through.  */
				case 0: /* Sm, Dm */
				  regno = given & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 5) & 1;
				    }
				  break;

				case 1: /* Sd, Dd */
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;

				case 2: /* Sn, Dn */
				  regno = (given >> 16) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 7) & 1;
				    }
				  break;

				case 3: /* List */
				  func (stream, "{");
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;


				default:
				  abort ();
				}

			      func (stream, "%c%d", single ? 's' : 'd', regno);

			      if (bitstart == 3)
				{
				  int count = given & 0xff;

				  if (single == 0)
				    count >>= 1;

				  if (--count)
				    {
				      func (stream, "-%c%d",
					    single ? 's' : 'd',
					    regno + count);
				    }

				  func (stream, "}");
				}
			      else if (bitstart == 4)
				func (stream, ", %c%d}", single ? 's' : 'd',
				      regno + 1);

			      break;
			    }

			  case '`':
			    c++;
			    if ((given & (1 << bitstart)) == 0)
			      func (stream, "%c", *c);
			    break;
			  case '\'':
			    c++;
			    if ((given & (1 << bitstart)) != 0)
			      func (stream, "%c", *c);
			    break;
			  case '?':
			    ++c;
			    if ((given & (1 << bitstart)) != 0)
			      func (stream, "%c", *c++);
			    else
			      func (stream, "%c", *++c);
			    break;
			  default:
			    abort ();
			  }
			break;

		      case 'L':
			switch (given & 0x00400100)
			  {
			  case 0x00000000: func (stream, "b"); break;
			  case 0x00400000: func (stream, "h"); break;
			  case 0x00000100: func (stream, "w"); break;
			  case 0x00400100: func (stream, "d"); break;
			  default:
			    break;
			  }
			break;

		      case 'Z':
			{
			  int value;
			  /* given (20, 23) | given (0, 3) */
			  value = ((given >> 16) & 0xf0) | (given & 0xf);
			  func (stream, "%d", value);
			}
			break;

		      case 'l':
			/* This is like the 'A' operator, except that if
			   the width field "M" is zero, then the offset is
			   *not* multiplied by four.  */
			{
			  int offset = given & 0xff;
			  int multiplier = (given & 0x00000100) ? 4 : 1;

			  func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

			  if (offset)
			    {
			      if ((given & 0x01000000) != 0)
				func (stream, ", %s#%d]%s",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier,
				      ((given & 0x00200000) != 0 ? "!" : ""));
			      else
				func (stream, "], %s#%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier);
			    }
			  else
			    func (stream, "]");
			}
			break;

		      default:
			abort ();
		      }
		    }
		}
	      else
		func (stream, "%c", *c);
	    }
	  return 4;
	}
    }
  abort ();
}

/* Print one instruction from PC on INFO->STREAM.
   Return the size of the instruction. */

static int
print_insn_thumb (pc, info, given)
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
{
  const struct thumb_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  for (insn = thumb_opcodes; insn->assembler; insn++)
    {
      if ((given & insn->mask) == insn->value)
        {
          char * c = insn->assembler;

          /* Special processing for Thumb 2 instruction BL sequence:  */
          if (!*c) /* Check for empty (not NULL) assembler string.  */
            {
	      long offset;

	      info->bytes_per_chunk = 4;
	      info->bytes_per_line  = 4;

	      offset = BDISP23 (given);
	      offset = offset * 2 + pc + 4;

	      if ((given & 0x10000000) == 0)
		{
		  func (stream, "blx\t");
		  offset &= 0xfffffffc;
		}
	      else
		func (stream, "bl\t");

	      info->print_address_func (offset, info);
              return 4;
            }
          else
            {
	      info->bytes_per_chunk = 2;
	      info->bytes_per_line  = 4;

              given &= 0xffff;

              for (; *c; c++)
                {
                  if (*c == '%')
                    {
                      int domaskpc = 0;
                      int domasklr = 0;

                      switch (*++c)
                        {
                        case '%':
                          func (stream, "%%");
                          break;

                        case 'S':
                          {
                            long reg;

                            reg = (given >> 3) & 0x7;
                            if (given & (1 << 6))
                              reg += 8;

                            func (stream, "%s", arm_regnames[reg]);
                          }
                          break;

                        case 'D':
                          {
                            long reg;

                            reg = given & 0x7;
                            if (given & (1 << 7))
                             reg += 8;

                            func (stream, "%s", arm_regnames[reg]);
                          }
                          break;

                        case 'T':
                          func (stream, "%s",
                                arm_conditional [(given >> 8) & 0xf]);
                          break;

                        case 'N':
                          if (given & (1 << 8))
                            domasklr = 1;
                          /* Fall through.  */
                        case 'O':
                          if (*c == 'O' && (given & (1 << 8)))
                            domaskpc = 1;
                          /* Fall through.  */
                        case 'M':
                          {
                            int started = 0;
                            int reg;

                            func (stream, "{");

                            /* It would be nice if we could spot
                               ranges, and generate the rS-rE format: */
                            for (reg = 0; (reg < 8); reg++)
                              if ((given & (1 << reg)) != 0)
                                {
                                  if (started)
                                    func (stream, ", ");
                                  started = 1;
                                  func (stream, "%s", arm_regnames[reg]);
                                }

                            if (domasklr)
                              {
                                if (started)
                                  func (stream, ", ");
                                started = 1;
                                func (stream, arm_regnames[14] /* "lr" */);
                              }

                            if (domaskpc)
                              {
                                if (started)
                                  func (stream, ", ");
                                func (stream, arm_regnames[15] /* "pc" */);
                              }

                            func (stream, "}");
                          }
                          break;


                        case '0': case '1': case '2': case '3': case '4':
                        case '5': case '6': case '7': case '8': case '9':
                          {
                            int bitstart = *c++ - '0';
                            int bitend = 0;

                            while (*c >= '0' && *c <= '9')
                              bitstart = (bitstart * 10) + *c++ - '0';

                            switch (*c)
                              {
                              case '-':
                                {
                                  long reg;

                                  c++;
                                  while (*c >= '0' && *c <= '9')
                                    bitend = (bitend * 10) + *c++ - '0';
                                  if (!bitend)
                                    abort ();
                                  reg = given >> bitstart;
                                  reg &= (2 << (bitend - bitstart)) - 1;
                                  switch (*c)
                                    {
                                    case 'r':
                                      func (stream, "%s", arm_regnames[reg]);
                                      break;

                                    case 'd':
                                      func (stream, "%d", reg);
                                      break;

                                    case 'H':
                                      func (stream, "%d", reg << 1);
                                      break;

                                    case 'W':
                                      func (stream, "%d", reg << 2);
                                      break;

                                    case 'a':
				      /* PC-relative address -- the bottom two
					 bits of the address are dropped
					 before the calculation.  */
                                      info->print_address_func
					(((pc + 4) & ~3) + (reg << 2), info);
                                      break;

                                    case 'x':
                                      func (stream, "0x%04x", reg);
                                      break;

                                    case 'I':
                                      reg = ((reg ^ (1 << bitend)) - (1 << bitend));
                                      func (stream, "%d", reg);
                                      break;

                                    case 'B':
                                      reg = ((reg ^ (1 << bitend)) - (1 << bitend));
                                      (*info->print_address_func)
                                        (reg * 2 + pc + 4, info);
                                      break;

                                    default:
                                      abort ();
                                    }
                                }
                                break;

                              case '\'':
                                c++;
                                if ((given & (1 << bitstart)) != 0)
                                  func (stream, "%c", *c);
                                break;

                              case '?':
                                ++c;
                                if ((given & (1 << bitstart)) != 0)
                                  func (stream, "%c", *c++);
                                else
                                  func (stream, "%c", *++c);
                                break;

                              default:
                                 abort ();
                              }
                          }
                          break;

                        default:
                          abort ();
                        }
                    }
                  else
                    func (stream, "%c", *c);
                }
             }
          return 2;
       }
    }

  /* No match.  */
  abort ();
}

/* Parse an individual disassembler option.  */

void
parse_arm_disassembler_option (option)
     char * option;
{
  if (option == NULL)
    return;

  if (strneq (option, "reg-names-", 10))
    {
      int i;

      option += 10;

      for (i = NUM_ARM_REGNAMES; i--;)
	if (streq (option, regnames[i].name))
	  {
	    regname_selected = i;
	    break;
	  }

      if (i < 0)
	fprintf (stderr, _("Unrecognised register name set: %s\n"), option);
    }
  else if (streq (option, "force-thumb"))
    force_thumb = 1;
  else if (streq (option, "no-force-thumb"))
    force_thumb = 0;
  else
    fprintf (stderr, _("Unrecognised disassembler option: %s\n"), option);

  return;
}

/* Parse the string of disassembler options, spliting it at whitespaces.  */

static void
parse_disassembler_options (options)
     char * options;
{
  char * space;

  if (options == NULL)
    return;

  do
    {
      space = strchr (options, ' ');

      if (space)
	{
	  * space = '\0';
	  parse_arm_disassembler_option (options);
	  * space = ' ';
	  options = space + 1;
	}
      else
	parse_arm_disassembler_option (options);
    }
  while (space);
}

/* NOTE: There are no checks in these routines that
   the relevant number of data bytes exist.  */

static int
print_insn (pc, info, little)
     bfd_vma pc;
     struct disassemble_info * info;
     bfd_boolean little;
{
  unsigned char      b[4];
  long               given;
  int                status;
  int                is_thumb;

  if (info->disassembler_options)
    {
      parse_disassembler_options (info->disassembler_options);

      /* To avoid repeated parsing of these options, we remove them here.  */
      info->disassembler_options = NULL;
    }

  is_thumb = force_thumb;

  if (!is_thumb && info->symbols != NULL)
    {
      if (bfd_asymbol_flavour (*info->symbols) == bfd_target_coff_flavour)
	{
	  coff_symbol_type * cs;

	  cs = coffsymbol (*info->symbols);
	  is_thumb = (   cs->native->u.syment.n_sclass == C_THUMBEXT
		      || cs->native->u.syment.n_sclass == C_THUMBSTAT
		      || cs->native->u.syment.n_sclass == C_THUMBLABEL
		      || cs->native->u.syment.n_sclass == C_THUMBEXTFUNC
		      || cs->native->u.syment.n_sclass == C_THUMBSTATFUNC);
	}
      else if (bfd_asymbol_flavour (*info->symbols) == bfd_target_elf_flavour)
	{
	  elf_symbol_type *  es;
	  unsigned int       type;

	  es = *(elf_symbol_type **)(info->symbols);
	  type = ELF_ST_TYPE (es->internal_elf_sym.st_info);

	  is_thumb = (type == STT_ARM_TFUNC) || (type == STT_ARM_16BIT);
	}
    }

  info->bytes_per_chunk = 4;
  info->display_endian  = little ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;

  if (little)
    {
      status = info->read_memory_func (pc, (bfd_byte *) &b[0], 4, info);
      if (status != 0 && is_thumb)
	{
	  info->bytes_per_chunk = 2;

	  status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);
	  b[3] = b[2] = 0;
	}

      if (status != 0)
	{
	  info->memory_error_func (status, pc, info);
	  return -1;
	}

      given = (b[0]) | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
    }
  else
    {
      status = info->read_memory_func
	(pc & ~ 0x3, (bfd_byte *) &b[0], 4, info);
      if (status != 0)
	{
	  info->memory_error_func (status, pc, info);
	  return -1;
	}

      if (is_thumb)
	{
	  if (pc & 0x2)
	    {
	      given = (b[2] << 8) | b[3];

	      status = info->read_memory_func
		((pc + 4) & ~ 0x3, (bfd_byte *) b, 4, info);
	      if (status != 0)
		{
		  info->memory_error_func (status, pc + 4, info);
		  return -1;
		}

	      given |= (b[0] << 24) | (b[1] << 16);
	    }
	  else
	    given = (b[0] << 8) | b[1] | (b[2] << 24) | (b[3] << 16);
	}
      else
	given = (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | (b[3]);
    }

  if (info->flags & INSN_HAS_RELOC)
    /* If the instruction has a reloc associated with it, then
       the offset field in the instruction will actually be the
       addend for the reloc.  (We are using REL type relocs).
       In such cases, we can ignore the pc when computing
       addresses, since the addend is not currently pc-relative.  */
    pc = 0;

  if (is_thumb)
    status = print_insn_thumb (pc, info, given);
  else
    status = print_insn_arm (pc, info, given);

  return status;
}

int
print_insn_big_arm (pc, info)
     bfd_vma pc;
     struct disassemble_info * info;
{
  return print_insn (pc, info, FALSE);
}

int
print_insn_little_arm (pc, info)
     bfd_vma pc;
     struct disassemble_info * info;
{
  return print_insn (pc, info, TRUE);
}

void
print_arm_disassembler_options (FILE * stream)
{
  int i;

  fprintf (stream, _("\n\
The following ARM specific disassembler options are supported for use with\n\
the -M switch:\n"));

  for (i = NUM_ARM_REGNAMES; i--;)
    fprintf (stream, "  reg-names-%s %*c%s\n",
	     regnames[i].name,
	     (int)(14 - strlen (regnames[i].name)), ' ',
	     regnames[i].description);

  fprintf (stream, "  force-thumb              Assume all insns are Thumb insns\n");
  fprintf (stream, "  no-force-thumb           Examine preceeding label to determine an insn's type\n\n");
}
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d7 1
a7 1
This file is part of libopcodes. 
d9 13
a21 13
This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version. 

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details. 

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
a31 1
/* FIXME: This shouldn't be done here */
d73 15
a87 1
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }}
d96 1
a96 1
static boolean force_thumb = false;
d101 1
a101 1
static char * arm_shift[] = 
d105 19
a123 10
static void arm_decode_shift PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm   PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options PARAMS ((char *));
static int  print_insn       PARAMS ((bfd_vma, struct disassemble_info *, boolean));
int get_arm_regname_num_options (void);
int set_arm_regname_option (int option);
int get_arm_regnames (int option, const char **setname,
		      const char **setdescription,
		      const char ***register_names);
d125 1
a125 1
/* Functions. */
d127 1
a127 1
get_arm_regname_num_options (void)
d133 2
a134 1
set_arm_regname_option (int option)
d142 5
a146 3
get_arm_regnames (int option, const char **setname,
		  const char **setdescription,
                  const char ***register_names)
d161 1
a161 1
  
d168 1
a168 1
	  
d176 1
a176 1
	      
d179 1
a179 1
	  
d188 18
d208 1
d211 3
a213 3
     bfd_vma                   pc;
     struct disassemble_info * info;
     long                      given;
d215 4
a218 3
  struct arm_opcode *  insn;
  void *               stream = info->stream;
  fprintf_ftype        func   = info->fprintf_func;
d222 5
d230 1
a230 1
	  
d246 1
a246 1
			  
d248 1
a248 1
 
d253 3
a255 3
			  
			      /* pre-indexed */
			      func (stream, ", #%x]", offset);
d269 1
a269 1
			      func (stream, "], #%x", offset);
d271 2
a272 1
			      offset = pc + 8;  /* ie ignore the offset.  */
d274 1
a274 1
			  
d280 1
a280 1
			  func (stream, "[%s", 
d300 1
a300 1
			      func (stream, "]%s", 
d312 1
a312 1
				  else 
d318 1
a318 1
					(((given & 0x00800000) == 0) 
d331 1
a331 1
			  
d334 3
a336 3
			  
			  func (stream, "[pc, #%x]\t; ", offset);
			  
d342 1
a342 1
			  func (stream, "[%s", 
d365 1
a365 1
			      func (stream, "]%s", 
d379 1
a379 1
				  else 
d393 1
a393 1
			  
a444 7
		    case 'h':
		      if ((given & 0x00000020) == 0x00000020)
			func (stream, "h");
                      else
                        func (stream, "b");
		      break;

d475 1
a475 1
			
d484 1
a484 1
			
d493 19
d540 1
a540 1
			
d592 1
a592 1
		    case '0': case '1': case '2': case '3': case '4': 
d604 1
a604 1
			    
d607 1
a607 1
			    
d610 1
a610 1
			    
d616 1
a616 1
				  
d619 1
a619 1
				  
d626 1
a626 1
				  
d629 1
a629 1
				  
d636 1
a636 1
				  
d639 1
a639 1
				  
d641 1
a641 1
				  
d653 1
a653 1
				  
d656 1
a656 1
				  
d663 1
a663 1
				  
d666 1
a666 1
				  
d674 57
d735 79
a813 1
			    
d836 48
d900 1
d903 3
a905 3
     bfd_vma                   pc;
     struct disassemble_info * info;
     long                      given;
d907 3
a909 3
  struct thumb_opcode * insn;
  void *                stream = info->stream;
  fprintf_ftype         func = info->fprintf_func;
d920 2
d924 4
a927 1
	      
d929 4
a932 1
                 func (stream, "blx\t");
d934 3
a936 3
                func (stream, "bl\t");
		
              info->print_address_func (BDISP23 (given) * 2 + pc + 4, info);
d943 1
a943 1
	  	      
d945 1
a945 1
	      
d952 1
a952 1
		      
d962 1
a962 1
			    
d966 1
a966 1
			    
d974 1
a974 1
			    
d978 1
a978 1
			    
d1000 1
a1000 1
			    
d1002 1
a1002 1
			    
d1034 1
a1034 1
                        case '0': case '1': case '2': case '3': case '4': 
d1039 1
a1039 1
			    
d1048 1
a1048 1
				  
d1140 1
d1147 1
a1147 1
      
d1151 1
a1151 1
	
d1160 1
a1160 1
      
d1170 1
a1170 1
  
d1175 1
d1181 1
a1181 1
  
d1204 1
d1209 1
a1209 1
     boolean little;
d1219 1
a1219 1
      
d1223 1
a1223 1
  
d1225 1
a1225 1
  
d1231 1
a1231 1
	  
d1243 1
a1243 1
	  
d1246 1
a1246 1
	  
d1250 1
a1250 1
  
d1260 1
a1260 1
	  
d1264 1
a1264 1
      
d1270 1
a1270 1
      
d1282 1
a1282 1
      
d1288 1
a1288 1
	      
d1296 1
a1296 1
	      
d1305 1
a1305 1
  
d1313 1
a1313 1
  
d1327 1
a1327 1
  return print_insn (pc, info, false);
d1335 1
a1335 1
  return print_insn (pc, info, true);
d1346 1
a1346 1
  
d1350 1
a1350 1
	     14 - strlen (regnames[i].name), ' ',
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of libopcodes.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
a31 1
/* FIXME: This shouldn't be done here.  */
d73 1
a73 15
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }},
  { "iwmmxt_regnames", "Select register names used on the Intel Wireless MMX technology coprocessor",
    { "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7", "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15"}},
  { "iwmmxt_Cregnames", "Select control register names used on the Intel Wireless MMX technology coprocessor",
    {"wcid", "wcon", "wcssf", "wcasf", "reserved", "reserved", "reserved", "reserved", "wcgr0", "wcgr1", "wcgr2", "wcgr3", "reserved", "reserved", "reserved", "reserved"}}
};

static char * iwmmxt_wwnames[] =
{"b", "h", "w", "d"};

static char * iwmmxt_wwssnames[] =
{"b", "bus", "b", "bss",
 "h", "hus", "h", "hss",
 "w", "wus", "w", "wss",
 "d", "dus", "d", "dss"
d82 1
a82 1
static bfd_boolean force_thumb = FALSE;
d87 1
a87 1
static char * arm_shift[] =
d91 10
a100 19
static void arm_decode_shift
  PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options
  PARAMS ((char *));
static int  print_insn
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
static int set_iwmmxt_regnames
  PARAMS ((void));

int get_arm_regname_num_options
  PARAMS ((void));
int set_arm_regname_option
  PARAMS ((int));
int get_arm_regnames
  PARAMS ((int, const char **, const char **, const char ***));
d102 1
a102 1
/* Functions.  */
d104 1
a104 1
get_arm_regname_num_options ()
d110 1
a110 2
set_arm_regname_option (option)
     int option;
d118 3
a120 5
get_arm_regnames (option, setname, setdescription, register_names)
     int option;
     const char **setname;
     const char **setdescription;
     const char ***register_names;
d135 1
a135 1

d142 1
a142 1

d150 1
a150 1

d153 1
a153 1

a161 18
static int
set_iwmmxt_regnames ()
{
  const char * setname;
  const char * setdesc;
  const char ** regnames;
  int iwmmxt_regnames = 0;
  int num_regnames = get_arm_regname_num_options ();

  get_arm_regnames (iwmmxt_regnames, &setname,
		    &setdesc, &regnames);
  while ((strcmp ("iwmmxt_regnames", setname))
	 && (iwmmxt_regnames < num_regnames))
    get_arm_regnames (++iwmmxt_regnames, &setname, &setdesc, &regnames);

  return iwmmxt_regnames;
}
			  
a163 1

d166 3
a168 3
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d170 3
a172 4
  const struct arm_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func   = info->fprintf_func;
  static int iwmmxt_regnames = 0;
a175 5
      if (insn->value == FIRST_IWMMXT_INSN
	  && info->mach != bfd_mach_arm_XScale
	  && info->mach != bfd_mach_arm_iWMMXt)
	insn = insn + IWMMXT_INSN_COUNT;

d179 1
a179 1

d195 1
a195 1

d197 1
a197 1

d202 3
a204 3

			      /* Pre-indexed.  */
			      func (stream, ", #%d]", offset);
d218 1
a218 1
			      func (stream, "], #%d", offset);
d220 1
a220 2
			      /* ie ignore the offset.  */
			      offset = pc + 8;
d222 1
a222 1

d228 1
a228 1
			  func (stream, "[%s",
d248 1
a248 1
			      func (stream, "]%s",
d260 1
a260 1
				  else
d266 1
a266 1
					(((given & 0x00800000) == 0)
d279 1
a279 1

d282 3
a284 3

			  func (stream, "[pc, #%d]\t; ", offset);

d290 1
a290 1
			  func (stream, "[%s",
d313 1
a313 1
			      func (stream, "]%s",
d327 1
a327 1
				  else
d341 1
a341 1

d393 7
d430 1
a430 1

d439 1
a439 1

a447 19
		    case 'I':
		      /* Print a Cirrus/DSP shift immediate.  */
		      /* Immediates are 7bit signed ints with bits 0..3 in
			 bits 0..3 of opcode and bits 4..6 in bits 5..7
			 of opcode.  */
		      {
			int imm;

			imm = (given & 0xf) | ((given & 0xe0) >> 1);

			/* Is ``imm'' a negative number?  */
			if (imm & 0x40)
			  imm |= (-1 << 7);

			func (stream, "%d", imm);
		      }

		      break;

d476 1
a476 1

d528 1
a528 1
		    case '0': case '1': case '2': case '3': case '4':
d540 1
a540 1

d543 1
a543 1

d546 1
a546 1

d552 1
a552 1

d555 1
a555 1

d562 1
a562 1

d565 1
a565 1

d572 1
a572 1

d575 1
a575 1

d577 1
a577 1

d589 1
a589 1

d592 1
a592 1

d599 1
a599 1

d602 1
a602 1

a609 57

			      case 'w':
				{
				  long reg;

				  if (bitstart != bitend)
				    {
				      reg = given >> bitstart;
				      reg &= (2 << (bitend - bitstart)) - 1;
				      if (bitend - bitstart == 1)
					func (stream, "%s", iwmmxt_wwnames[reg]);
				      else
					func (stream, "%s", iwmmxt_wwssnames[reg]);
				    }
				  else
				    {
				      reg = (((given >> 8)  & 0x1) |
					     ((given >> 22) & 0x1));
				      func (stream, "%s", iwmmxt_wwnames[reg]);
				    }
				}
				break;

			      case 'g':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

			      case 'G':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames + 1);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

d614 1
a614 79

			  case 'y':
			  case 'z':
			    {
			      int single = *c == 'y';
			      int regno;

			      switch (bitstart)
				{
				case 4: /* Sm pair */
				  func (stream, "{");
				  /* Fall through.  */
				case 0: /* Sm, Dm */
				  regno = given & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 5) & 1;
				    }
				  break;

				case 1: /* Sd, Dd */
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;

				case 2: /* Sn, Dn */
				  regno = (given >> 16) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 7) & 1;
				    }
				  break;

				case 3: /* List */
				  func (stream, "{");
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;


				default:
				  abort ();
				}

			      func (stream, "%c%d", single ? 's' : 'd', regno);

			      if (bitstart == 3)
				{
				  int count = given & 0xff;

				  if (single == 0)
				    count >>= 1;

				  if (--count)
				    {
				      func (stream, "-%c%d",
					    single ? 's' : 'd',
					    regno + count);
				    }

				  func (stream, "}");
				}
			      else if (bitstart == 4)
				func (stream, ", %c%d}", single ? 's' : 'd',
				      regno + 1);

			      break;
			    }

a636 48
		      case 'L':
			switch (given & 0x00400100)
			  {
			  case 0x00000000: func (stream, "b"); break;
			  case 0x00400000: func (stream, "h"); break;
			  case 0x00000100: func (stream, "w"); break;
			  case 0x00400100: func (stream, "d"); break;
			  default:
			    break;
			  }
			break;

		      case 'Z':
			{
			  int value;
			  /* given (20, 23) | given (0, 3) */
			  value = ((given >> 16) & 0xf0) | (given & 0xf);
			  func (stream, "%d", value);
			}
			break;

		      case 'l':
			/* This is like the 'A' operator, except that if
			   the width field "M" is zero, then the offset is
			   *not* multiplied by four.  */
			{
			  int offset = given & 0xff;
			  int multiplier = (given & 0x00000100) ? 4 : 1;

			  func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

			  if (offset)
			    {
			      if ((given & 0x01000000) != 0)
				func (stream, ", %s#%d]%s",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier,
				      ((given & 0x00200000) != 0 ? "!" : ""));
			      else
				func (stream, "], %s#%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier);
			    }
			  else
			    func (stream, "]");
			}
			break;

a652 1

d655 3
a657 3
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d659 3
a661 3
  const struct thumb_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
a671 2
	      long offset;

d674 1
a674 4

	      offset = BDISP23 (given);
	      offset = offset * 2 + pc + 4;

d676 1
a676 4
		{
		  func (stream, "blx\t");
		  offset &= 0xfffffffc;
		}
d678 3
a680 3
		func (stream, "bl\t");

	      info->print_address_func (offset, info);
d687 1
a687 1

d689 1
a689 1

d696 1
a696 1

d706 1
a706 1

d710 1
a710 1

d718 1
a718 1

d722 1
a722 1

d744 1
a744 1

d746 1
a746 1

d778 1
a778 1
                        case '0': case '1': case '2': case '3': case '4':
d783 1
a783 1

d792 1
a792 1

a883 1

d890 1
a890 1

d894 1
a894 1

d903 1
a903 1

d913 1
a913 1

a917 1

d923 1
a923 1

a945 1

d950 1
a950 1
     bfd_boolean little;
d960 1
a960 1

d964 1
a964 1

d966 1
a966 1

d972 1
a972 1

d984 1
a984 1

d987 1
a987 1

d991 1
a991 1

d1001 1
a1001 1

d1005 1
a1005 1

d1011 1
a1011 1

d1023 1
a1023 1

d1029 1
a1029 1

d1037 1
a1037 1

d1046 1
a1046 1

d1054 1
a1054 1

d1068 1
a1068 1
  return print_insn (pc, info, FALSE);
d1076 1
a1076 1
  return print_insn (pc, info, TRUE);
d1087 1
a1087 1

d1091 1
a1091 1
	     (int)(14 - strlen (regnames[i].name)), ' ',
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@a29 1
#include "safe-ctype.h"
d288 1
a288 1
				    func (stream, ", #%s%d",
d309 1
a309 1
				    func (stream, "], #%s%d",
d352 1
a352 1
				    func (stream, ", #%s%d",
d376 1
a376 1
				    func (stream, "], #%s%d",
d447 1
a447 2

		      if ((given & (1 << 24)) != 0)
a449 1

d451 1
a451 1
			    func (stream, ", #%s%d]%s",
d461 4
a464 10

			  func (stream, "]");

			  if (given & (1 << 21))
			    {
			      if (offset)
				func (stream, ", #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * 4);
			    }
d466 1
a466 1
			    func (stream, ", {%d}", offset);
a632 10
			      case 'W':
				{
				  long reg;
				  
				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  
				  func (stream, "%d", reg + 1);
				}
				break;
d870 1
a870 1
				func (stream, ", #%s%d]%s",
d875 1
a875 1
				func (stream, "], #%s%d",
a1138 17
/* Disallow mapping symbols ($a, $b, $d, $t etc) from
   being displayed in symbol relative addresses.  */

bfd_boolean
arm_symbol_is_valid (asymbol * sym,
		     struct disassemble_info * info ATTRIBUTE_UNUSED)
{
  const char * name;
  
  if (sym == NULL)
    return FALSE;

  name = bfd_asymbol_name (sym);

  return (name && *name != '$');
}

d1155 1
a1155 1
	if (strneq (option, regnames[i].name, strlen (regnames[i].name)))
a1161 1
	/* XXX - should break 'option' at following delimiter.  */
d1164 1
a1164 1
  else if (strneq (option, "force-thumb", 11))
d1166 1
a1166 1
  else if (strneq (option, "no-force-thumb", 14))
a1168 1
    /* XXX - should break 'option' at following delimiter.  */
d1174 1
a1174 2
/* Parse the string of disassembler options, spliting it at whitespaces
   or commas.  (Whitespace separators supported for backwards compatibility).  */
d1180 2
d1185 1
a1185 1
  while (*options)
d1187 1
a1187 1
      parse_arm_disassembler_option (options);
d1189 9
a1197 6
      /* Skip forward to next seperator.  */
      while ((*options) && (! ISSPACE (*options)) && (*options != ','))
	++ options;
      /* Skip forward past seperators.  */
      while (ISSPACE (*options) || (*options == ','))
	++ options;      
d1199 1
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of libopcodes.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
a31 1
/* FIXME: This shouldn't be done here.  */
d73 1
a73 15
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }},
  { "iwmmxt_regnames", "Select register names used on the Intel Wireless MMX technology coprocessor",
    { "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7", "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15"}},
  { "iwmmxt_Cregnames", "Select control register names used on the Intel Wireless MMX technology coprocessor",
    {"wcid", "wcon", "wcssf", "wcasf", "reserved", "reserved", "reserved", "reserved", "wcgr0", "wcgr1", "wcgr2", "wcgr3", "reserved", "reserved", "reserved", "reserved"}}
};

static char * iwmmxt_wwnames[] =
{"b", "h", "w", "d"};

static char * iwmmxt_wwssnames[] =
{"b", "bus", "b", "bss",
 "h", "hus", "h", "hss",
 "w", "wus", "w", "wss",
 "d", "dus", "d", "dss"
d82 1
a82 1
static bfd_boolean force_thumb = FALSE;
d87 1
a87 1
static char * arm_shift[] =
d91 10
a100 19
static void arm_decode_shift
  PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options
  PARAMS ((char *));
static int  print_insn
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
static int set_iwmmxt_regnames
  PARAMS ((void));

int get_arm_regname_num_options
  PARAMS ((void));
int set_arm_regname_option
  PARAMS ((int));
int get_arm_regnames
  PARAMS ((int, const char **, const char **, const char ***));
d102 1
a102 1
/* Functions.  */
d104 1
a104 1
get_arm_regname_num_options ()
d110 1
a110 2
set_arm_regname_option (option)
     int option;
d118 3
a120 5
get_arm_regnames (option, setname, setdescription, register_names)
     int option;
     const char **setname;
     const char **setdescription;
     const char ***register_names;
d135 1
a135 1

d142 1
a142 1

d150 1
a150 1

d153 1
a153 1

a161 18
static int
set_iwmmxt_regnames ()
{
  const char * setname;
  const char * setdesc;
  const char ** regnames;
  int iwmmxt_regnames = 0;
  int num_regnames = get_arm_regname_num_options ();

  get_arm_regnames (iwmmxt_regnames, &setname,
		    &setdesc, &regnames);
  while ((strcmp ("iwmmxt_regnames", setname))
	 && (iwmmxt_regnames < num_regnames))
    get_arm_regnames (++iwmmxt_regnames, &setname, &setdesc, &regnames);

  return iwmmxt_regnames;
}
			  
a163 1

d166 3
a168 3
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d170 3
a172 4
  const struct arm_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func   = info->fprintf_func;
  static int iwmmxt_regnames = 0;
a175 5
      if (insn->value == FIRST_IWMMXT_INSN
	  && info->mach != bfd_mach_arm_XScale
	  && info->mach != bfd_mach_arm_iWMMXt)
	insn = insn + IWMMXT_INSN_COUNT;

d179 1
a179 1

d195 1
a195 1

d197 1
a197 1

d202 3
a204 3

			      /* Pre-indexed.  */
			      func (stream, ", #%d]", offset);
d218 1
a218 1
			      func (stream, "], #%d", offset);
d220 1
a220 2
			      /* ie ignore the offset.  */
			      offset = pc + 8;
d222 1
a222 1

d228 1
a228 1
			  func (stream, "[%s",
d248 1
a248 1
			      func (stream, "]%s",
d260 1
a260 1
				  else
d266 1
a266 1
					(((given & 0x00800000) == 0)
d279 1
a279 1

d282 3
a284 3

			  func (stream, "[pc, #%d]\t; ", offset);

d290 1
a290 1
			  func (stream, "[%s",
d313 1
a313 1
			      func (stream, "]%s",
d327 1
a327 1
				  else
d341 1
a341 1

d393 7
d430 1
a430 1

d439 1
a439 1

a447 19
		    case 'I':
		      /* Print a Cirrus/DSP shift immediate.  */
		      /* Immediates are 7bit signed ints with bits 0..3 in
			 bits 0..3 of opcode and bits 4..6 in bits 5..7
			 of opcode.  */
		      {
			int imm;

			imm = (given & 0xf) | ((given & 0xe0) >> 1);

			/* Is ``imm'' a negative number?  */
			if (imm & 0x40)
			  imm |= (-1 << 7);

			func (stream, "%d", imm);
		      }

		      break;

d476 1
a476 1

d528 1
a528 1
		    case '0': case '1': case '2': case '3': case '4':
d540 1
a540 1

d543 1
a543 1

d546 1
a546 1

d552 1
a552 1

d555 1
a555 1

d562 1
a562 1

d565 1
a565 1

d572 1
a572 1

d575 1
a575 1

d577 1
a577 1

d589 1
a589 1

d592 1
a592 1

d599 1
a599 1

d602 1
a602 1

a609 57

			      case 'w':
				{
				  long reg;

				  if (bitstart != bitend)
				    {
				      reg = given >> bitstart;
				      reg &= (2 << (bitend - bitstart)) - 1;
				      if (bitend - bitstart == 1)
					func (stream, "%s", iwmmxt_wwnames[reg]);
				      else
					func (stream, "%s", iwmmxt_wwssnames[reg]);
				    }
				  else
				    {
				      reg = (((given >> 8)  & 0x1) |
					     ((given >> 22) & 0x1));
				      func (stream, "%s", iwmmxt_wwnames[reg]);
				    }
				}
				break;

			      case 'g':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

			      case 'G':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames + 1);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

d614 1
a614 79

			  case 'y':
			  case 'z':
			    {
			      int single = *c == 'y';
			      int regno;

			      switch (bitstart)
				{
				case 4: /* Sm pair */
				  func (stream, "{");
				  /* Fall through.  */
				case 0: /* Sm, Dm */
				  regno = given & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 5) & 1;
				    }
				  break;

				case 1: /* Sd, Dd */
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;

				case 2: /* Sn, Dn */
				  regno = (given >> 16) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 7) & 1;
				    }
				  break;

				case 3: /* List */
				  func (stream, "{");
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;


				default:
				  abort ();
				}

			      func (stream, "%c%d", single ? 's' : 'd', regno);

			      if (bitstart == 3)
				{
				  int count = given & 0xff;

				  if (single == 0)
				    count >>= 1;

				  if (--count)
				    {
				      func (stream, "-%c%d",
					    single ? 's' : 'd',
					    regno + count);
				    }

				  func (stream, "}");
				}
			      else if (bitstart == 4)
				func (stream, ", %c%d}", single ? 's' : 'd',
				      regno + 1);

			      break;
			    }

a636 48
		      case 'L':
			switch (given & 0x00400100)
			  {
			  case 0x00000000: func (stream, "b"); break;
			  case 0x00400000: func (stream, "h"); break;
			  case 0x00000100: func (stream, "w"); break;
			  case 0x00400100: func (stream, "d"); break;
			  default:
			    break;
			  }
			break;

		      case 'Z':
			{
			  int value;
			  /* given (20, 23) | given (0, 3) */
			  value = ((given >> 16) & 0xf0) | (given & 0xf);
			  func (stream, "%d", value);
			}
			break;

		      case 'l':
			/* This is like the 'A' operator, except that if
			   the width field "M" is zero, then the offset is
			   *not* multiplied by four.  */
			{
			  int offset = given & 0xff;
			  int multiplier = (given & 0x00000100) ? 4 : 1;

			  func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

			  if (offset)
			    {
			      if ((given & 0x01000000) != 0)
				func (stream, ", %s#%d]%s",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier,
				      ((given & 0x00200000) != 0 ? "!" : ""));
			      else
				func (stream, "], %s#%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier);
			    }
			  else
			    func (stream, "]");
			}
			break;

a652 1

d655 3
a657 3
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d659 3
a661 3
  const struct thumb_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
a671 2
	      long offset;

d674 1
a674 4

	      offset = BDISP23 (given);
	      offset = offset * 2 + pc + 4;

d676 1
a676 4
		{
		  func (stream, "blx\t");
		  offset &= 0xfffffffc;
		}
d678 3
a680 3
		func (stream, "bl\t");

	      info->print_address_func (offset, info);
d687 1
a687 1

d689 1
a689 1

d696 1
a696 1

d706 1
a706 1

d710 1
a710 1

d718 1
a718 1

d722 1
a722 1

d744 1
a744 1

d746 1
a746 1

d778 1
a778 1
                        case '0': case '1': case '2': case '3': case '4':
d783 1
a783 1

d792 1
a792 1

a883 1

d890 1
a890 1

d894 1
a894 1

d903 1
a903 1

d913 1
a913 1

a917 1

d923 1
a923 1

a945 1

d950 1
a950 1
     bfd_boolean little;
d960 1
a960 1

d964 1
a964 1

d966 1
a966 1

d972 1
a972 1

d984 1
a984 1

d987 1
a987 1

d991 1
a991 1

d1001 1
a1001 1

d1005 1
a1005 1

d1011 1
a1011 1

d1023 1
a1023 1

d1029 1
a1029 1

d1037 1
a1037 1

d1046 1
a1046 1

d1054 1
a1054 1

d1068 1
a1068 1
  return print_insn (pc, info, FALSE);
d1076 1
a1076 1
  return print_insn (pc, info, TRUE);
d1087 1
a1087 1

d1091 1
a1091 1
	     (int)(14 - strlen (regnames[i].name)), ' ',
@

