head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.20.57.19;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.01.20;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.39.20;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.39.20;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.27.58;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.40.10;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.03.08;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.04.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* strings -- print the strings of printable characters in files
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Usage: strings [options] file...

   Options:
   --all
   -a
   -		Do not scan only the initialized data section of object files.

   --print-file-name
   -f		Print the name of the file before each string.

   --bytes=min-len
   -n min-len
   -min-len	Print graphic char sequences, MIN-LEN or more bytes long,
		that are followed by a NUL or a newline.  Default is 4.

   --radix={o,x,d}
   -t {o,x,d}	Print the offset within the file before each string,
		in octal/hex/decimal.

   -o		Like -to.  (Some other implementations have -o like -to,
		others like -td.  We chose one arbitrarily.)

   --encoding={s,S,b,l,B,L}
   -e {s,S,b,l,B,L}
		Select character encoding: 7-bit-character, 8-bit-character,
		bigendian 16-bit, littleendian 16-bit, bigendian 32-bit,
		littleendian 32-bit.

   --target=BFDNAME
		Specify a non-default object file format.

   --help
   -h		Print the usage message on the standard output.

   --version
   -v		Print the program version number.

   Written by Richard Stallman <rms@@gnu.ai.mit.edu>
   and David MacKenzie <djm@@gnu.ai.mit.edu>.  */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include "bfd.h"
#include <stdio.h>
#include "getopt.h"
#include <errno.h>
#include "bucomm.h"
#include "libiberty.h"
#include "safe-ctype.h"

/* Some platforms need to put stdin into binary mode, to read
    binary files.  */
#ifdef HAVE_SETMODE
#ifndef O_BINARY
#ifdef _O_BINARY
#define O_BINARY _O_BINARY
#define setmode _setmode
#else
#define O_BINARY 0
#endif
#endif
#if O_BINARY
#include <io.h>
#define SET_BINARY(f) do { if (!isatty (f)) setmode (f,O_BINARY); } while (0)
#endif
#endif

#define STRING_ISGRAPHIC(c) \
      (   (c) >= 0 \
       && (c) <= 255 \
       && ((c) == '\t' || ISPRINT (c) || (encoding == 'S' && (c) > 127)))

#ifndef errno
extern int errno;
#endif

/* The BFD section flags that identify an initialized data section.  */
#define DATA_FLAGS (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS)

#ifdef HAVE_FOPEN64
typedef off64_t file_off;
#define file_open(s,m) fopen64(s, m)
#else
typedef off_t file_off;
#define file_open(s,m) fopen(s, m)
#endif

/* Radix for printing addresses (must be 8, 10 or 16).  */
static int address_radix;

/* Minimum length of sequence of graphic chars to trigger output.  */
static int string_min;

/* TRUE means print address within file for each string.  */
static bfd_boolean print_addresses;

/* TRUE means print filename for each string.  */
static bfd_boolean print_filenames;

/* TRUE means for object files scan only the data section.  */
static bfd_boolean datasection_only;

/* TRUE if we found an initialized data section in the current file.  */
static bfd_boolean got_a_section;

/* The BFD object file format.  */
static char *target;

/* The character encoding format.  */
static char encoding;
static int encoding_bytes;

static struct option long_options[] =
{
  {"all", no_argument, NULL, 'a'},
  {"print-file-name", no_argument, NULL, 'f'},
  {"bytes", required_argument, NULL, 'n'},
  {"radix", required_argument, NULL, 't'},
  {"encoding", required_argument, NULL, 'e'},
  {"target", required_argument, NULL, 'T'},
  {"help", no_argument, NULL, 'h'},
  {"version", no_argument, NULL, 'v'},
  {NULL, 0, NULL, 0}
};

static void strings_a_section
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean strings_object_file
  PARAMS ((const char *));
static bfd_boolean strings_file
  PARAMS ((char *file));
static int integer_arg
  PARAMS ((char *s));
static void print_strings
  PARAMS ((const char *, FILE *, file_off, int, int, char *));
static void usage
  PARAMS ((FILE *, int));
static long get_char
  PARAMS ((FILE *, file_off *, int *, char **));

int main
  PARAMS ((int, char **));

int
main (argc, argv)
     int argc;
     char **argv;
{
  int optc;
  int exit_status = 0;
  bfd_boolean files_given = FALSE;

#if defined (HAVE_SETLOCALE)
  setlocale (LC_ALL, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = argv[0];
  xmalloc_set_program_name (program_name);
  string_min = -1;
  print_addresses = FALSE;
  print_filenames = FALSE;
  datasection_only = TRUE;
  target = NULL;
  encoding = 's';

  while ((optc = getopt_long (argc, argv, "afhHn:ot:e:Vv0123456789",
			      long_options, (int *) 0)) != EOF)
    {
      switch (optc)
	{
	case 'a':
	  datasection_only = FALSE;
	  break;

	case 'f':
	  print_filenames = TRUE;
	  break;

	case 'H':
	case 'h':
	  usage (stdout, 0);

	case 'n':
	  string_min = integer_arg (optarg);
	  if (string_min < 1)
	    fatal (_("invalid number %s"), optarg);
	  break;

	case 'o':
	  print_addresses = TRUE;
	  address_radix = 8;
	  break;

	case 't':
	  print_addresses = TRUE;
	  if (optarg[1] != '\0')
	    usage (stderr, 1);
	  switch (optarg[0])
	    {
	    case 'o':
	      address_radix = 8;
	      break;

	    case 'd':
	      address_radix = 10;
	      break;

	    case 'x':
	      address_radix = 16;
	      break;

	    default:
	      usage (stderr, 1);
	    }
	  break;

	case 'T':
	  target = optarg;
	  break;

	case 'e':
	  if (optarg[1] != '\0')
	    usage (stderr, 1);
	  encoding = optarg[0];
	  break;

	case 'V':
	case 'v':
	  print_version ("strings");
	  break;

	case '?':
	  usage (stderr, 1);

	default:
	  if (string_min < 0)
	    string_min = optc - '0';
	  else
	    string_min = string_min * 10 + optc - '0';
	  break;
	}
    }

  if (string_min < 0)
    string_min = 4;

  switch (encoding)
    {
    case 'S':
    case 's':
      encoding_bytes = 1;
      break;
    case 'b':
    case 'l':
      encoding_bytes = 2;
      break;
    case 'B':
    case 'L':
      encoding_bytes = 4;
      break;
    default:
      usage (stderr, 1);
    }

  bfd_init ();
  set_default_bfd_target ();

  if (optind >= argc)
    {
      datasection_only = FALSE;
#ifdef SET_BINARY
      SET_BINARY (fileno (stdin));
#endif
      print_strings ("{standard input}", stdin, 0, 0, 0, (char *) NULL);
      files_given = TRUE;
    }
  else
    {
      for (; optind < argc; ++optind)
	{
	  if (strcmp (argv[optind], "-") == 0)
	    datasection_only = FALSE;
	  else
	    {
	      files_given = TRUE;
	      exit_status |= strings_file (argv[optind]) == FALSE;
	    }
	}
    }

  if (!files_given)
    usage (stderr, 1);

  return (exit_status);
}

/* Scan section SECT of the file ABFD, whose printable name is FILE.
   If it contains initialized data,
   set `got_a_section' and print the strings in it.  */

static void
strings_a_section (abfd, sect, filearg)
     bfd *abfd;
     asection *sect;
     PTR filearg;
{
  const char *file = (const char *) filearg;

  if ((sect->flags & DATA_FLAGS) == DATA_FLAGS)
    {
      bfd_size_type sz = bfd_get_section_size_before_reloc (sect);
      PTR mem = xmalloc (sz);

      if (bfd_get_section_contents (abfd, sect, mem, (file_ptr) 0, sz))
	{
	  got_a_section = TRUE;
	  print_strings (file, (FILE *) NULL, sect->filepos, 0, sz, mem);
	}
      free (mem);
    }
}

/* Scan all of the sections in FILE, and print the strings
   in the initialized data section(s).

   Return TRUE if successful,
   FALSE if not (such as if FILE is not an object file).  */

static bfd_boolean
strings_object_file (file)
     const char *file;
{
  bfd *abfd = bfd_openr (file, target);

  if (abfd == NULL)
    /* Treat the file as a non-object file.  */
    return FALSE;

  /* This call is mainly for its side effect of reading in the sections.
     We follow the traditional behavior of `strings' in that we don't
     complain if we don't recognize a file to be an object file.  */
  if (!bfd_check_format (abfd, bfd_object))
    {
      bfd_close (abfd);
      return FALSE;
    }

  got_a_section = FALSE;
  bfd_map_over_sections (abfd, strings_a_section, (PTR) file);

  if (!bfd_close (abfd))
    {
      bfd_nonfatal (file);
      return FALSE;
    }

  return got_a_section;
}

/* Print the strings in FILE.  Return TRUE if ok, FALSE if an error occurs.  */

static bfd_boolean
strings_file (file)
     char *file;
{
  /* If we weren't told to scan the whole file,
     try to open it as an object file and only look at
     initialized data sections.  If that fails, fall back to the
     whole file.  */
  if (!datasection_only || !strings_object_file (file))
    {
      FILE *stream;

      stream = file_open (file, FOPEN_RB);
      if (stream == NULL)
	{
	  fprintf (stderr, "%s: ", program_name);
	  perror (file);
	  return FALSE;
	}

      print_strings (file, stream, (file_off) 0, 0, 0, (char *) 0);

      if (fclose (stream) == EOF)
	{
	  fprintf (stderr, "%s: ", program_name);
	  perror (file);
	  return FALSE;
	}
    }

  return TRUE;
}

/* Read the next character, return EOF if none available.
   Assume that STREAM is positioned so that the next byte read
   is at address ADDRESS in the file.

   If STREAM is NULL, do not read from it.
   The caller can supply a buffer of characters
   to be processed before the data in STREAM.
   MAGIC is the address of the buffer and
   MAGICCOUNT is how many characters are in it.  */

static long
get_char (stream, address, magiccount, magic)
     FILE *stream;
     file_off *address;
     int *magiccount;
     char **magic;
{
  int c, i;
  long r = EOF;
  unsigned char buf[4];

  for (i = 0; i < encoding_bytes; i++)
    {
      if (*magiccount)
	{
	  (*magiccount)--;
	  c = *(*magic)++;
	}
      else
	{
	  if (stream == NULL)
	    return EOF;
#ifdef HAVE_GETC_UNLOCKED
	  c = getc_unlocked (stream);
#else
	  c = getc (stream);
#endif
	  if (c == EOF)
	    return EOF;
	}

      (*address)++;
      buf[i] = c;
    }

  switch (encoding)
    {
    case 'S':
    case 's':
      r = buf[0];
      break;
    case 'b':
      r = (buf[0] << 8) | buf[1];
      break;
    case 'l':
      r = buf[0] | (buf[1] << 8);
      break;
    case 'B':
      r = ((long) buf[0] << 24) | ((long) buf[1] << 16) |
	((long) buf[2] << 8) | buf[3];
      break;
    case 'L':
      r = buf[0] | ((long) buf[1] << 8) | ((long) buf[2] << 16) |
	((long) buf[3] << 24);
      break;
    }

  if (r == EOF)
    return 0;

  return r;
}

/* Find the strings in file FILENAME, read from STREAM.
   Assume that STREAM is positioned so that the next byte read
   is at address ADDRESS in the file.
   Stop reading at address STOP_POINT in the file, if nonzero.

   If STREAM is NULL, do not read from it.
   The caller can supply a buffer of characters
   to be processed before the data in STREAM.
   MAGIC is the address of the buffer and
   MAGICCOUNT is how many characters are in it.
   Those characters come at address ADDRESS and the data in STREAM follow.  */

static void
print_strings (filename, stream, address, stop_point, magiccount, magic)
     const char *filename;
     FILE *stream;
     file_off address;
     int stop_point;
     int magiccount;
     char *magic;
{
  char *buf = (char *) xmalloc (sizeof (char) * (string_min + 1));

  while (1)
    {
      file_off start;
      int i;
      long c;

      /* See if the next `string_min' chars are all graphic chars.  */
    tryline:
      if (stop_point && address >= stop_point)
	break;
      start = address;
      for (i = 0; i < string_min; i++)
	{
	  c = get_char (stream, &address, &magiccount, &magic);
	  if (c == EOF)
	    return;
	  if (! STRING_ISGRAPHIC (c))
	    /* Found a non-graphic.  Try again starting with next char.  */
	    goto tryline;
	  buf[i] = c;
	}

      /* We found a run of `string_min' graphic characters.  Print up
         to the next non-graphic character.  */

      if (print_filenames)
	printf ("%s: ", filename);
      if (print_addresses)
	switch (address_radix)
	  {
	  case 8:
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Lo ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("++%7lo ", (unsigned long) start);
	    else
# endif
#endif
	      printf ("%7lo ", (unsigned long) start);
	    break;

	  case 10:
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Ld ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("++%7ld ", (unsigned long) start);
	    else
# endif
#endif
	      printf ("%7ld ", (long) start);
	    break;

	  case 16:
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Lx ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("%lx%8.8lx ", start >> 32, start & 0xffffffff);
	    else
# endif
#endif
	      printf ("%7lx ", (unsigned long) start);
	    break;
	  }

      buf[i] = '\0';
      fputs (buf, stdout);

      while (1)
	{
	  c = get_char (stream, &address, &magiccount, &magic);
	  if (c == EOF)
	    break;
	  if (! STRING_ISGRAPHIC (c))
	    break;
	  putchar (c);
	}

      putchar ('\n');
    }
}

/* Parse string S as an integer, using decimal radix by default,
   but allowing octal and hex numbers as in C.  */

static int
integer_arg (s)
     char *s;
{
  int value;
  int radix = 10;
  char *p = s;
  int c;

  if (*p != '0')
    radix = 10;
  else if (*++p == 'x')
    {
      radix = 16;
      p++;
    }
  else
    radix = 8;

  value = 0;
  while (((c = *p++) >= '0' && c <= '9')
	 || (radix == 16 && (c & ~40) >= 'A' && (c & ~40) <= 'Z'))
    {
      value *= radix;
      if (c >= '0' && c <= '9')
	value += c - '0';
      else
	value += (c & ~40) - 'A';
    }

  if (c == 'b')
    value *= 512;
  else if (c == 'B')
    value *= 1024;
  else
    p--;

  if (*p)
    fatal (_("invalid integer argument %s"), s);

  return value;
}

static void
usage (stream, status)
     FILE *stream;
     int status;
{
  fprintf (stream, _("Usage: %s [option(s)] [file(s)]\n"), program_name);
  fprintf (stream, _(" Display printable strings in [file(s)] (stdin by default)\n"));
  fprintf (stream, _(" The options are:\n\
  -a - --all                Scan the entire file, not just the data section\n\
  -f --print-file-name      Print the name of the file before each string\n\
  -n --bytes=[number]       Locate & print any NUL-terminated sequence of at\n\
  -<number>                 least [number] characters (default 4).\n\
  -t --radix={o,x,d}        Print the location of the string in base 8, 10 or 16\n\
  -o                        An alias for --radix=o\n\
  -T --target=<BFDNAME>     Specify the binary file format\n\
  -e --encoding={s,S,b,l,B,L} Select character size and endianness:\n\
                            s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit\n\
  -h --help                 Display this information\n\
  -v --version              Print the program's version number\n"));
  list_supported_targets (program_name, stream);
  if (status == 0)
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (status);
}
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d42 6
d60 3
d65 1
a65 2
#include <getopt.h>
#include <ctype.h>
d69 1
d84 1
a84 1
#define SET_BINARY(f) do { if (!isatty(f)) setmode(f,O_BINARY); } while (0)
d88 4
a91 8
/* Not all printable characters have ASCII codes (depending upon the
   LOCALE set) but on some older systems it is not safe to test isprint
   without first testing isascii...  */
#if defined isascii && !defined HAVE_LOCALE_H
#define isgraphic(c) (isascii (c) && (isprint (c) || (c) == '\t'))
#else
#define isgraphic(c) (isprint (c) || (c) == '\t')
#endif
d100 8
d114 2
a115 2
/* true means print address within file for each string.  */
static boolean print_addresses;
d117 2
a118 2
/* true means print filename for each string.  */
static boolean print_filenames;
d120 2
a121 2
/* true means for object files scan only the data section.  */
static boolean datasection_only;
d123 2
a124 2
/* true if we found an initialized data section in the current file.  */
static boolean got_a_section;
d129 4
d139 1
d146 14
a159 8
static void strings_a_section PARAMS ((bfd *, asection *, PTR));
static boolean strings_object_file PARAMS ((const char *));
static boolean strings_file PARAMS ((char *file));
static int integer_arg PARAMS ((char *s));
static void print_strings PARAMS ((const char *filename, FILE *stream,
				  file_ptr address, int stop_point,
				  int magiccount, char *magic));
static void usage PARAMS ((FILE *stream, int status));
d161 3
d171 1
a171 1
  boolean files_given = false;
d173 1
a173 1
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
d182 3
a184 3
  print_addresses = false;
  print_filenames = false;
  datasection_only = true;
d186 1
d188 1
a188 1
  while ((optc = getopt_long (argc, argv, "afn:ot:v0123456789",
d194 1
a194 1
	  datasection_only = false;
d198 1
a198 1
	  print_filenames = true;
d201 1
d208 1
a208 3
	    {
	      fatal (_("invalid number %s"), optarg);
	    }
d212 1
a212 1
	  print_addresses = true;
d217 1
a217 1
	  print_addresses = true;
d243 7
d269 18
d292 1
a292 1
      datasection_only = false;
d297 1
a297 1
      files_given = true;
d304 1
a304 1
	    datasection_only = false;
d307 2
a308 2
	      files_given = true;
	      exit_status |= (strings_file (argv[optind]) == false);
d313 1
a313 1
  if (files_given == false)
d335 1
d338 1
a338 1
	  got_a_section = true;
d348 2
a349 2
   Return true if successful,
   false if not (such as if FILE is not an object file).  */
d351 1
a351 1
static boolean
d358 2
a359 4
    {
      /* Treat the file as a non-object file.  */
      return false;
    }
d364 1
a364 1
  if (bfd_check_format (abfd, bfd_object) == false)
d367 1
a367 1
      return false;
d370 1
a370 1
  got_a_section = false;
d376 1
a376 1
      return false;
d382 1
a382 1
/* Print the strings in FILE.  Return true if ok, false if an error occurs.  */
d384 1
a384 1
static boolean
d396 1
a396 4
      stream = fopen (file, "rb");
      /* Not all systems permit "rb", so try "r" if it failed.  */
      if (stream == NULL)
	stream = fopen (file, "r");
d401 1
a401 1
	  return false;
d404 1
a404 1
      print_strings (file, stream, (file_ptr) 0, 0, 0, (char *) 0);
d410 46
a455 1
	  return false;
d457 25
d484 4
a487 1
  return true;
d506 1
a506 1
     file_ptr address;
d511 1
a511 1
  char *buf = (char *) xmalloc (string_min + 1);
d515 1
a515 1
      file_ptr start;
d517 1
a517 1
      int c;
d526 4
a529 15
	  if (magiccount)
	    {
	      magiccount--;
	      c = *magic++;
	    }
	  else
	    {
	      if (stream == NULL)
		return;
	      c = getc (stream);
	      if (c == EOF)
		return;
	    }
	  address++;
	  if (!isgraphic (c))
d544 12
a555 1
	    printf ("%7lo ", (unsigned long) start);
d559 12
a570 1
	    printf ("%7ld ", (long) start);
d574 12
a585 1
	    printf ("%7lx ", (unsigned long) start);
d594 4
a597 15
	  if (magiccount)
	    {
	      magiccount--;
	      c = *magic++;
	    }
	  else
	    {
	      if (stream == NULL)
		break;
	      c = getc (stream);
	      if (c == EOF)
		break;
	    }
	  address++;
	  if (! isgraphic (c))
d647 2
a648 3
    {
      fatal (_("invalid integer argument %s"), s);
    }
d657 14
a670 5
  fprintf (stream, _("\
Usage: %s [-afov] [-n min-len] [-min-len] [-t {o,x,d}] [-]\n\
       [--all] [--print-file-name] [--bytes=min-len] [--radix={o,x,d}]\n\
       [--target=bfdname] [--help] [--version] file...\n"),
	   program_name);
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002 Free Software Foundation, Inc.
a41 6
   --encoding={s,S,b,l,B,L}
   -e {s,S,b,l,B,L}
		Select character encoding: 7-bit-character, 8-bit-character,
		bigendian 16-bit, littleendian 16-bit, bigendian 32-bit,
		littleendian 32-bit.

a53 3
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
d56 2
a57 1
#include "getopt.h"
a60 1
#include "safe-ctype.h"
d75 1
a75 1
#define SET_BINARY(f) do { if (!isatty (f)) setmode (f,O_BINARY); } while (0)
d79 8
a86 4
#define STRING_ISGRAPHIC(c) \
      (   (c) >= 0 \
       && (c) <= 255 \
       && ((c) == '\t' || ISPRINT (c) || (encoding == 'S' && (c) > 127)))
a94 8
#ifdef HAVE_FOPEN64
typedef off64_t file_off;
#define file_open(s,m) fopen64(s, m)
#else
typedef off_t file_off;
#define file_open(s,m) fopen(s, m)
#endif

d101 2
a102 2
/* TRUE means print address within file for each string.  */
static bfd_boolean print_addresses;
d104 2
a105 2
/* TRUE means print filename for each string.  */
static bfd_boolean print_filenames;
d107 2
a108 2
/* TRUE means for object files scan only the data section.  */
static bfd_boolean datasection_only;
d110 2
a111 2
/* TRUE if we found an initialized data section in the current file.  */
static bfd_boolean got_a_section;
a115 4
/* The character encoding format.  */
static char encoding;
static int encoding_bytes;

a121 1
  {"encoding", required_argument, NULL, 'e'},
d128 8
a135 14
static void strings_a_section
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean strings_object_file
  PARAMS ((const char *));
static bfd_boolean strings_file
  PARAMS ((char *file));
static int integer_arg
  PARAMS ((char *s));
static void print_strings
  PARAMS ((const char *, FILE *, file_off, int, int, char *));
static void usage
  PARAMS ((FILE *, int));
static long get_char
  PARAMS ((FILE *, file_off *, int *, char **));
a136 3
int main
  PARAMS ((int, char **));

d144 1
a144 1
  bfd_boolean files_given = FALSE;
d146 1
a146 1
#if defined (HAVE_SETLOCALE)
d155 3
a157 3
  print_addresses = FALSE;
  print_filenames = FALSE;
  datasection_only = TRUE;
a158 1
  encoding = 's';
d160 1
a160 1
  while ((optc = getopt_long (argc, argv, "afhHn:ot:e:Vv0123456789",
d166 1
a166 1
	  datasection_only = FALSE;
d170 1
a170 1
	  print_filenames = TRUE;
a172 1
	case 'H':
d179 3
a181 1
	    fatal (_("invalid number %s"), optarg);
d185 1
a185 1
	  print_addresses = TRUE;
d190 1
a190 1
	  print_addresses = TRUE;
a215 7
	case 'e':
	  if (optarg[1] != '\0')
	    usage (stderr, 1);
	  encoding = optarg[0];
	  break;

	case 'V':
a234 18
  switch (encoding)
    {
    case 'S':
    case 's':
      encoding_bytes = 1;
      break;
    case 'b':
    case 'l':
      encoding_bytes = 2;
      break;
    case 'B':
    case 'L':
      encoding_bytes = 4;
      break;
    default:
      usage (stderr, 1);
    }

d240 1
a240 1
      datasection_only = FALSE;
d245 1
a245 1
      files_given = TRUE;
d252 1
a252 1
	    datasection_only = FALSE;
d255 2
a256 2
	      files_given = TRUE;
	      exit_status |= strings_file (argv[optind]) == FALSE;
d261 1
a261 1
  if (!files_given)
a282 1

d285 1
a285 1
	  got_a_section = TRUE;
d295 2
a296 2
   Return TRUE if successful,
   FALSE if not (such as if FILE is not an object file).  */
d298 1
a298 1
static bfd_boolean
d305 4
a308 2
    /* Treat the file as a non-object file.  */
    return FALSE;
d313 1
a313 1
  if (!bfd_check_format (abfd, bfd_object))
d316 1
a316 1
      return FALSE;
d319 1
a319 1
  got_a_section = FALSE;
d325 1
a325 1
      return FALSE;
d331 1
a331 1
/* Print the strings in FILE.  Return TRUE if ok, FALSE if an error occurs.  */
d333 1
a333 1
static bfd_boolean
d345 4
a348 1
      stream = file_open (file, FOPEN_RB);
d353 1
a353 1
	  return FALSE;
d356 1
a356 1
      print_strings (file, stream, (file_off) 0, 0, 0, (char *) 0);
d362 1
a362 46
	  return FALSE;
	}
    }

  return TRUE;
}

/* Read the next character, return EOF if none available.
   Assume that STREAM is positioned so that the next byte read
   is at address ADDRESS in the file.

   If STREAM is NULL, do not read from it.
   The caller can supply a buffer of characters
   to be processed before the data in STREAM.
   MAGIC is the address of the buffer and
   MAGICCOUNT is how many characters are in it.  */

static long
get_char (stream, address, magiccount, magic)
     FILE *stream;
     file_off *address;
     int *magiccount;
     char **magic;
{
  int c, i;
  long r = EOF;
  unsigned char buf[4];

  for (i = 0; i < encoding_bytes; i++)
    {
      if (*magiccount)
	{
	  (*magiccount)--;
	  c = *(*magic)++;
	}
      else
	{
	  if (stream == NULL)
	    return EOF;
#ifdef HAVE_GETC_UNLOCKED
	  c = getc_unlocked (stream);
#else
	  c = getc (stream);
#endif
	  if (c == EOF)
	    return EOF;
a363 25

      (*address)++;
      buf[i] = c;
    }

  switch (encoding)
    {
    case 'S':
    case 's':
      r = buf[0];
      break;
    case 'b':
      r = (buf[0] << 8) | buf[1];
      break;
    case 'l':
      r = buf[0] | (buf[1] << 8);
      break;
    case 'B':
      r = ((long) buf[0] << 24) | ((long) buf[1] << 16) |
	((long) buf[2] << 8) | buf[3];
      break;
    case 'L':
      r = buf[0] | ((long) buf[1] << 8) | ((long) buf[2] << 16) |
	((long) buf[3] << 24);
      break;
d366 1
a366 4
  if (r == EOF)
    return 0;

  return r;
d385 1
a385 1
     file_off address;
d390 1
a390 1
  char *buf = (char *) xmalloc (sizeof (char) * (string_min + 1));
d394 1
a394 1
      file_off start;
d396 1
a396 1
      long c;
d405 15
a419 4
	  c = get_char (stream, &address, &magiccount, &magic);
	  if (c == EOF)
	    return;
	  if (! STRING_ISGRAPHIC (c))
d434 1
a434 12
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Lo ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("++%7lo ", (unsigned long) start);
	    else
# endif
#endif
	      printf ("%7lo ", (unsigned long) start);
d438 1
a438 12
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Ld ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("++%7ld ", (unsigned long) start);
	    else
# endif
#endif
	      printf ("%7ld ", (long) start);
d442 1
a442 12
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Lx ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("%lx%8.8lx ", start >> 32, start & 0xffffffff);
	    else
# endif
#endif
	      printf ("%7lx ", (unsigned long) start);
d451 15
a465 4
	  c = get_char (stream, &address, &magiccount, &magic);
	  if (c == EOF)
	    break;
	  if (! STRING_ISGRAPHIC (c))
d515 3
a517 2
    fatal (_("invalid integer argument %s"), s);

d526 5
a530 14
  fprintf (stream, _("Usage: %s [option(s)] [file(s)]\n"), program_name);
  fprintf (stream, _(" Display printable strings in [file(s)] (stdin by default)\n"));
  fprintf (stream, _(" The options are:\n\
  -a - --all                Scan the entire file, not just the data section\n\
  -f --print-file-name      Print the name of the file before each string\n\
  -n --bytes=[number]       Locate & print any NUL-terminated sequence of at\n\
  -<number>                 least [number] characters (default 4).\n\
  -t --radix={o,x,d}        Print the location of the string in base 8, 10 or 16\n\
  -o                        An alias for --radix=o\n\
  -T --target=<BFDNAME>     Specify the binary file format\n\
  -e --encoding={s,S,b,l,B,L} Select character size and endianness:\n\
                            s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit\n\
  -h --help                 Display this information\n\
  -v --version              Print the program's version number\n"));
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d146 14
a159 7
static void strings_a_section (bfd *, asection *, void *);
static bfd_boolean strings_object_file (const char *);
static bfd_boolean strings_file (char *file);
static int integer_arg (char *s);
static void print_strings (const char *, FILE *, file_off, int, int, char *);
static void usage (FILE *, int);
static long get_char (FILE *, file_off *, int *, char **);
d161 2
a162 1
int main (int, char **);
d165 3
a167 1
main (int argc, char **argv)
d324 4
a327 1
strings_a_section (bfd *abfd, asection *sect, void *filearg)
d334 1
a334 1
      void *mem = xmalloc (sz);
d352 2
a353 1
strings_object_file (const char *file)
d371 1
a371 1
  bfd_map_over_sections (abfd, strings_a_section, (void *) file);
d385 2
a386 1
strings_file (char *file)
a387 3
  if (get_file_size (file) < 1)
    return FALSE;

d428 5
a432 1
get_char (FILE *stream, file_off *address, int *magiccount, char **magic)
d503 7
a509 2
print_strings (const char *filename, FILE *stream, file_off address,
	       int stop_point, int magiccount, char *magic)
d610 2
a611 1
integer_arg (char *s)
d653 3
a655 1
usage (FILE *stream, int status)
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002 Free Software Foundation, Inc.
a41 6
   --encoding={s,S,b,l,B,L}
   -e {s,S,b,l,B,L}
		Select character encoding: 7-bit-character, 8-bit-character,
		bigendian 16-bit, littleendian 16-bit, bigendian 32-bit,
		littleendian 32-bit.

a53 3
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
d56 2
a57 1
#include "getopt.h"
a60 1
#include "safe-ctype.h"
d75 1
a75 1
#define SET_BINARY(f) do { if (!isatty (f)) setmode (f,O_BINARY); } while (0)
d79 8
a86 4
#define STRING_ISGRAPHIC(c) \
      (   (c) >= 0 \
       && (c) <= 255 \
       && ((c) == '\t' || ISPRINT (c) || (encoding == 'S' && (c) > 127)))
a94 8
#ifdef HAVE_FOPEN64
typedef off64_t file_off;
#define file_open(s,m) fopen64(s, m)
#else
typedef off_t file_off;
#define file_open(s,m) fopen(s, m)
#endif

d101 2
a102 2
/* TRUE means print address within file for each string.  */
static bfd_boolean print_addresses;
d104 2
a105 2
/* TRUE means print filename for each string.  */
static bfd_boolean print_filenames;
d107 2
a108 2
/* TRUE means for object files scan only the data section.  */
static bfd_boolean datasection_only;
d110 2
a111 2
/* TRUE if we found an initialized data section in the current file.  */
static bfd_boolean got_a_section;
a115 4
/* The character encoding format.  */
static char encoding;
static int encoding_bytes;

a121 1
  {"encoding", required_argument, NULL, 'e'},
d128 8
a135 14
static void strings_a_section
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean strings_object_file
  PARAMS ((const char *));
static bfd_boolean strings_file
  PARAMS ((char *file));
static int integer_arg
  PARAMS ((char *s));
static void print_strings
  PARAMS ((const char *, FILE *, file_off, int, int, char *));
static void usage
  PARAMS ((FILE *, int));
static long get_char
  PARAMS ((FILE *, file_off *, int *, char **));
a136 3
int main
  PARAMS ((int, char **));

d144 1
a144 1
  bfd_boolean files_given = FALSE;
d146 1
a146 1
#if defined (HAVE_SETLOCALE)
d155 3
a157 3
  print_addresses = FALSE;
  print_filenames = FALSE;
  datasection_only = TRUE;
a158 1
  encoding = 's';
d160 1
a160 1
  while ((optc = getopt_long (argc, argv, "afhHn:ot:e:Vv0123456789",
d166 1
a166 1
	  datasection_only = FALSE;
d170 1
a170 1
	  print_filenames = TRUE;
a172 1
	case 'H':
d179 3
a181 1
	    fatal (_("invalid number %s"), optarg);
d185 1
a185 1
	  print_addresses = TRUE;
d190 1
a190 1
	  print_addresses = TRUE;
a215 7
	case 'e':
	  if (optarg[1] != '\0')
	    usage (stderr, 1);
	  encoding = optarg[0];
	  break;

	case 'V':
a234 18
  switch (encoding)
    {
    case 'S':
    case 's':
      encoding_bytes = 1;
      break;
    case 'b':
    case 'l':
      encoding_bytes = 2;
      break;
    case 'B':
    case 'L':
      encoding_bytes = 4;
      break;
    default:
      usage (stderr, 1);
    }

d240 1
a240 1
      datasection_only = FALSE;
d245 1
a245 1
      files_given = TRUE;
d252 1
a252 1
	    datasection_only = FALSE;
d255 2
a256 2
	      files_given = TRUE;
	      exit_status |= strings_file (argv[optind]) == FALSE;
d261 1
a261 1
  if (!files_given)
a282 1

d285 1
a285 1
	  got_a_section = TRUE;
d295 2
a296 2
   Return TRUE if successful,
   FALSE if not (such as if FILE is not an object file).  */
d298 1
a298 1
static bfd_boolean
d305 4
a308 2
    /* Treat the file as a non-object file.  */
    return FALSE;
d313 1
a313 1
  if (!bfd_check_format (abfd, bfd_object))
d316 1
a316 1
      return FALSE;
d319 1
a319 1
  got_a_section = FALSE;
d325 1
a325 1
      return FALSE;
d331 1
a331 1
/* Print the strings in FILE.  Return TRUE if ok, FALSE if an error occurs.  */
d333 1
a333 1
static bfd_boolean
d345 4
a348 1
      stream = file_open (file, FOPEN_RB);
d353 1
a353 1
	  return FALSE;
d356 1
a356 1
      print_strings (file, stream, (file_off) 0, 0, 0, (char *) 0);
d362 1
a362 46
	  return FALSE;
	}
    }

  return TRUE;
}

/* Read the next character, return EOF if none available.
   Assume that STREAM is positioned so that the next byte read
   is at address ADDRESS in the file.

   If STREAM is NULL, do not read from it.
   The caller can supply a buffer of characters
   to be processed before the data in STREAM.
   MAGIC is the address of the buffer and
   MAGICCOUNT is how many characters are in it.  */

static long
get_char (stream, address, magiccount, magic)
     FILE *stream;
     file_off *address;
     int *magiccount;
     char **magic;
{
  int c, i;
  long r = EOF;
  unsigned char buf[4];

  for (i = 0; i < encoding_bytes; i++)
    {
      if (*magiccount)
	{
	  (*magiccount)--;
	  c = *(*magic)++;
	}
      else
	{
	  if (stream == NULL)
	    return EOF;
#ifdef HAVE_GETC_UNLOCKED
	  c = getc_unlocked (stream);
#else
	  c = getc (stream);
#endif
	  if (c == EOF)
	    return EOF;
a363 25

      (*address)++;
      buf[i] = c;
    }

  switch (encoding)
    {
    case 'S':
    case 's':
      r = buf[0];
      break;
    case 'b':
      r = (buf[0] << 8) | buf[1];
      break;
    case 'l':
      r = buf[0] | (buf[1] << 8);
      break;
    case 'B':
      r = ((long) buf[0] << 24) | ((long) buf[1] << 16) |
	((long) buf[2] << 8) | buf[3];
      break;
    case 'L':
      r = buf[0] | ((long) buf[1] << 8) | ((long) buf[2] << 16) |
	((long) buf[3] << 24);
      break;
d366 1
a366 4
  if (r == EOF)
    return 0;

  return r;
d385 1
a385 1
     file_off address;
d390 1
a390 1
  char *buf = (char *) xmalloc (sizeof (char) * (string_min + 1));
d394 1
a394 1
      file_off start;
d396 1
a396 1
      long c;
d405 15
a419 4
	  c = get_char (stream, &address, &magiccount, &magic);
	  if (c == EOF)
	    return;
	  if (! STRING_ISGRAPHIC (c))
d434 1
a434 12
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Lo ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("++%7lo ", (unsigned long) start);
	    else
# endif
#endif
	      printf ("%7lo ", (unsigned long) start);
d438 1
a438 12
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Ld ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("++%7ld ", (unsigned long) start);
	    else
# endif
#endif
	      printf ("%7ld ", (long) start);
d442 1
a442 12
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Lx ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("%lx%8.8lx ", start >> 32, start & 0xffffffff);
	    else
# endif
#endif
	      printf ("%7lx ", (unsigned long) start);
d451 15
a465 4
	  c = get_char (stream, &address, &magiccount, &magic);
	  if (c == EOF)
	    break;
	  if (! STRING_ISGRAPHIC (c))
d515 3
a517 2
    fatal (_("invalid integer argument %s"), s);

d526 5
a530 14
  fprintf (stream, _("Usage: %s [option(s)] [file(s)]\n"), program_name);
  fprintf (stream, _(" Display printable strings in [file(s)] (stdin by default)\n"));
  fprintf (stream, _(" The options are:\n\
  -a - --all                Scan the entire file, not just the data section\n\
  -f --print-file-name      Print the name of the file before each string\n\
  -n --bytes=[number]       Locate & print any NUL-terminated sequence of at\n\
  -<number>                 least [number] characters (default 4).\n\
  -t --radix={o,x,d}        Print the location of the string in base 8, 10 or 16\n\
  -o                        An alias for --radix=o\n\
  -T --target=<BFDNAME>     Specify the binary file format\n\
  -e --encoding={s,S,b,l,B,L} Select character size and endianness:\n\
                            s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit\n\
  -h --help                 Display this information\n\
  -v --version              Print the program's version number\n"));
@

