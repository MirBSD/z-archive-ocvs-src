head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.20.56.01;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.01.04;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.39.15;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.39.15;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.27.36;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.39.59;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.02.58;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.03.20;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* Coff file dumper.
   Copyright 1994, 1995, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Written by Steve Chamberlain <sac@@cygnus.com>

   This module reads a type tree generated by coffgrok and prints
   it out so we can test the grokker.  */

#include "bfd.h"
#include "libiberty.h"

#include "coffgrok.h"
#include "bucomm.h"
#include "getopt.h"

static int atnl;

static void tab PARAMS ((int));
static void nl PARAMS ((void));
static void dump_coff_lines PARAMS ((struct coff_line *));
static void dump_coff_type PARAMS ((struct coff_type *));
static void dump_coff_where PARAMS ((struct coff_where *));
static void dump_coff_visible PARAMS ((struct coff_visible *));
extern void dump_coff_symbol PARAMS ((struct coff_symbol *));
static void dump_coff_scope PARAMS ((struct coff_scope *));
static void dump_coff_sfile PARAMS ((struct coff_sfile *));
static void dump_coff_section PARAMS ((struct coff_section *));
extern void coff_dump PARAMS ((struct coff_ofile *));
static void show_usage PARAMS ((FILE *, int));
extern int main PARAMS ((int, char **));

static void
tab (x)
     int x;
{
  static int indent;
  int i;

  if (atnl)
    {
      if (x < 0)
	{
	  printf (")");
	  indent += x;

	  return;
	}
      else
	{
	  printf ("\n");
	  atnl = 0;
	}
    }

  if (x == -1)
    {
      for (i = 0; i < indent; i++)
	printf ("   ");

      indent += x;
      printf (")");
      return;
    }

  indent += x;

  for (i = 0; i < indent; i++)
    printf ("   ");

  if (x)
    {
      printf ("(");
    }
}

static void
nl ()
{
  atnl = 1;
}

static void
dump_coff_lines (p)
     struct coff_line *p;
{
  int i;
  int online = 0;

  tab (1);
  printf (_("#lines %d "),p->nlines);

  for (i = 0; i < p->nlines; i++)
    {
      printf ("(%d 0x%x)", p->lines[i], p->addresses[i]);

      online++;

      if (online > 6)
	{
	  nl ();
	  tab (0);
	  online = 0;
	}
    }
  nl ();
  tab (-1);
}

static void
dump_coff_type (p)
     struct coff_type *p;
{
  tab (1);
  printf ("size %d ", p->size);

  switch (p->type)
    {
    case coff_secdef_type:
      printf ("section definition at %x size %x\n",
	      p->u.asecdef.address,
	      p->u.asecdef.size);
      nl ();
      break;
    case coff_pointer_type:
      printf ("pointer to");
      nl ();
      dump_coff_type (p->u.pointer.points_to);
      break;
    case coff_array_type:
      printf ("array [%d] of", p->u.array.dim);
      nl ();
      dump_coff_type (p->u.array.array_of);
      break;
    case coff_function_type:
      printf ("function returning");
      nl ();
      dump_coff_type (p->u.function.function_returns);
      dump_coff_lines (p->u.function.lines);
      printf ("arguments");
      nl ();
      dump_coff_scope (p->u.function.parameters);
      tab (0);
      printf ("code");
      nl ();
      dump_coff_scope (p->u.function.code);
      tab(0);
      break;
    case coff_structdef_type:
      printf ("structure definition");
      nl ();
      dump_coff_scope (p->u.astructdef.elements);
      break;
    case coff_structref_type:
      if (!p->u.aenumref.ref)
	printf ("structure ref to UNKNOWN struct");
      else
	printf ("structure ref to %s", p->u.aenumref.ref->name);
      break;
    case coff_enumref_type:
      printf ("enum ref to %s", p->u.astructref.ref->name);
      break;
    case coff_enumdef_type:
      printf ("enum definition");
      nl ();
      dump_coff_scope (p->u.aenumdef.elements);
      break;
    case coff_basic_type:
      switch (p->u.basic)
	{
	case T_NULL:
	  printf ("NULL");
	  break;
	case T_VOID:
	  printf ("VOID");
	  break;
	case T_CHAR:
	  printf ("CHAR");
	  break;
	case T_SHORT:
	  printf ("SHORT");
	  break;
	case T_INT:
	  printf ("INT ");
	  break;
	case T_LONG:
	  printf ("LONG");
	  break;
	case T_FLOAT:
	  printf ("FLOAT");
	  break;
	case T_DOUBLE:
	  printf ("DOUBLE");
	  break;
	case T_STRUCT:
	  printf ("STRUCT");
	  break;
	case T_UNION:
	  printf ("UNION");
	  break;
	case T_ENUM:
	  printf ("ENUM");
	  break;
	case T_MOE:
	  printf ("MOE ");
	  break;
	case T_UCHAR:
	  printf ("UCHAR");
	  break;
	case T_USHORT:
	  printf ("USHORT");
	  break;
	case T_UINT:
	  printf ("UINT");
	  break;
	case T_ULONG:
	  printf ("ULONG");
	  break;
	case T_LNGDBL:
	  printf ("LNGDBL");
	  break;
	default:
	  abort ();
	}
    }
  nl ();
  tab (-1);
}

static void
dump_coff_where (p)
     struct coff_where *p;
{
  tab (1);
  switch (p->where)
    {
    case coff_where_stack:
      printf ("Stack offset %x", p->offset);
      break;
    case coff_where_memory:
      printf ("Memory section %s+%x", p->section->name, p->offset);
      break;
    case coff_where_register:
      printf ("Register %d", p->offset);
      break;
    case coff_where_member_of_struct:
      printf ("Struct Member offset %x", p->offset);
      break;
    case coff_where_member_of_enum:
      printf ("Enum Member offset %x", p->offset);
      break;
    case coff_where_unknown:
      printf ("Undefined symbol");
      break;
    case coff_where_strtag:
      printf ("STRTAG");
    case coff_where_entag:
      printf ("ENTAG");
      break;
    case coff_where_typedef:
      printf ("TYPEDEF");
      break;
    default:
      abort ();
    }
  nl ();
  tab (-1);
}

static void
dump_coff_visible (p)
     struct coff_visible *p;
{
  tab (1);
  switch (p->type)
    {
    case coff_vis_ext_def:
      printf ("coff_vis_ext_def");
      break;
    case coff_vis_ext_ref:
      printf ("coff_vis_ext_ref");
      break;
    case coff_vis_int_def:
      printf ("coff_vis_int_def");
      break;
    case coff_vis_common:
      printf ("coff_vis_common");
      break;
    case coff_vis_auto:
      printf ("coff_vis_auto");
      break;
    case coff_vis_autoparam:
      printf ("coff_vis_autoparam");
      break;
    case coff_vis_regparam:
      printf ("coff_vis_regparam");
      break;
    case coff_vis_register:
      printf ("coff_vis_register");
      break;
    case coff_vis_tag:
      printf ("coff_vis_tag");
      break;
    case coff_vis_member_of_struct:
      printf ("coff_vis_member_of_struct");
      break;
    case coff_vis_member_of_enum:
      printf ("coff_vis_member_of_enum");
      break;
    default:
      abort ();
    }
  nl ();
  tab (-1);
}

void
dump_coff_symbol (p)
     struct coff_symbol *p;
{
  tab (1);
  printf ("List of symbols");
  nl ();

  while (p)
    {
      tab (1);
      tab (1);
      printf ("Symbol  %s, tag %d, number %d", p->name, p->tag, p->number);
      nl ();
      tab (-1);
      tab (1);
      printf ("Type");
      nl ();
      dump_coff_type (p->type);
      tab (-1);
      tab (1);
      printf ("Where");
      dump_coff_where (p->where);
      tab (-1);
      tab (1);
      printf ("Visible");
      dump_coff_visible (p->visible);
      tab (-1);
      p = p->next;
      tab (-1);
    }
  tab (-1);
}

static void
dump_coff_scope (p)
     struct coff_scope *p;
{
  if (p)
    {
      tab (1);
      printf ("List of blocks %lx ",(unsigned long) p);

      if (p->sec)
	printf( "  %s %x..%x",  p->sec->name,p->offset, p->offset + p->size -1);

      nl ();
      tab (0);
      printf ("*****************");
      nl ();

      while (p)
	{
	  tab (0);
	  printf ("vars %d", p->nvars);
	  nl ();
	  dump_coff_symbol (p->vars_head);
	  printf ("blocks");
	  nl ();
	  dump_coff_scope (p->list_head);
	  nl ();
	  p = p->next;
	}

      tab (0);
      printf ("*****************");
      nl ();
      tab (-1);
    }
}

static void
dump_coff_sfile (p)
     struct coff_sfile *p;
{
  tab (1);
  printf ("List of source files");
  nl ();

  while (p)
    {
      tab (0);
      printf ("Source file %s", p->name);
      nl ();
      dump_coff_scope (p->scope);
      p = p->next;
    }
  tab (-1);
}

static void
dump_coff_section(ptr)
     struct coff_section *ptr;
{
  int i;

  tab (1);
  printf ("section %s %d %d address %x size %x number %d nrelocs %d",
	  ptr->name, ptr->code, ptr->data, ptr->address,ptr->size,
	  ptr->number, ptr->nrelocs);
  nl ();

  for (i = 0; i < ptr->nrelocs; i++)
    {
      tab (0);
      printf ("(%x %s %x)",
	      ptr->relocs[i].offset,
	      ptr->relocs[i].symbol->name,
	      ptr->relocs[i].addend);
      nl ();
    }

  tab (-1);
}

void
coff_dump (ptr)
     struct coff_ofile *ptr;
{
  int i;

  printf ("Coff dump");
  nl ();
  printf ("#souces %d", ptr->nsources);
  nl ();
  dump_coff_sfile (ptr->source_head);

  for (i = 0; i < ptr->nsections; i++)
    dump_coff_section (ptr->sections + i);
}

char * program_name;

static void
show_usage (file, status)
     FILE *file;
     int status;
{
  fprintf (file, _("Usage: %s [option(s)] in-file\n"), program_name);
  fprintf (file, _(" Print a human readable interpretation of a SYSROFF object file\n"));
  fprintf (file, _(" The options are:\n\
  -h --help              Display this information\n\
  -v --version           Display the program's version\n\
\n"));

  if (status == 0)
    fprintf (file, _("Report bugs to %s\n"), REPORT_BUGS_TO);

  exit (status);
}

int
main (ac, av)
     int ac;
     char *av[];
{
  bfd *abfd;
  struct coff_ofile *tree;
  char **matching;
  char *input_file = NULL;
  int opt;
  static struct option long_options[] =
    {
      { "help", no_argument, 0, 'h' },
      { "version", no_argument, 0, 'V' },
      { NULL, no_argument, 0, 0 }
    };

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = av[0];
  xmalloc_set_program_name (program_name);

  while ((opt = getopt_long (ac, av, "HhVv", long_options,
			     (int *) NULL))
	 != EOF)
    {
      switch (opt)
	{
	case 'H':
	case 'h':
	  show_usage (stdout, 0);
	  break;
	case 'v':
	case 'V':
	  print_version ("coffdump");
	  exit (0);
	case 0:
	  break;
	default:
	  show_usage (stderr, 1);
	  break;
	}
    }

  if (optind < ac)
    {
      input_file = av[optind];
    }

  if (!input_file)
    fatal (_("no input file specified"));

  abfd = bfd_openr (input_file, 0);

  if (!abfd)
    bfd_fatal (input_file);

  if (! bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      bfd_nonfatal (input_file);

      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      exit (1);
    }

  tree = coff_grok (abfd);

  coff_dump (tree);
  printf ("\n");

  return 0;
}
@


1.2
log
@looks as if some sour wine (Federweißer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 1998, 1999, 2000 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GNU Binutils.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d24 1
a24 2
   it out so we can test the grokker.
*/
d26 2
a27 3
#include <bfd.h>
#include <getopt.h>
#include <libiberty.h>
d31 1
d33 1
a33 1
#define PROGRAM_VERSION "1.0"
d35 13
a47 2
static int atnl;
static void dump_coff_scope ();
d51 1
a51 1
int x;
d93 2
a94 1
static void nl ()
d105 5
a109 3
  tab(1);
  printf(_("#lines %d "),p->nlines);
  for (i = 0; i < p->nlines; i++) 
d111 2
a112 1
      printf("(%d 0x%x)", p->lines[i], p->addresses[i]);
d114 1
d117 2
a118 2
	  nl();
	  tab(0);
d122 2
a123 2
  nl();
  tab(-1);
d132 1
d136 1
a136 1
      printf ("section definition at %x size %x\n", 
d139 1
a139 1
      nl();
a332 1

d340 1
d371 7
a377 3
if (p) {
  tab (1);
  printf ("List of blocks %lx ",(unsigned long) p);
d379 1
a379 9
  if (p->sec) {
    printf( "  %s %x..%x",  p->sec->name,p->offset, p->offset + p->size -1);
  }
  nl ();
  tab (0);
  printf ("*****************");
  nl ();
  while (p)
    {
d381 1
a381 1
      printf ("vars %d", p->nvars);
d383 16
a398 2
      dump_coff_symbol (p->vars_head);
      printf ("blocks");
d400 1
a400 3
      dump_coff_scope (p->list_head);
      nl ();
      p = p->next;
a401 6

  tab (0);
  printf ("*****************");
  nl ();
  tab (-1);
}
d411 1
d425 1
a425 1
struct coff_section *ptr;
d428 15
a442 13
  tab(1);
  printf("section %s %d %d address %x size %x number %d nrelocs %d", 
	 ptr->name, ptr->code, ptr->data, ptr->address,ptr->size, ptr->number, ptr->nrelocs);
  nl();

  for (i = 0; i < ptr->nrelocs; i++) 
    {
      tab(0);    
      printf("(%x %s %x)",
	     ptr->relocs[i].offset,
	     ptr->relocs[i].symbol->name,
	     ptr->relocs[i].addend);
      nl();
a443 1
  tab(-1);
d445 1
d453 1
d459 1
d461 1
a461 1
    dump_coff_section(ptr->sections + i);
a463 2


d471 10
a480 1
  fprintf (file, "Usage: %s [-hV] in-file\n",   program_name);
a483 9
static void
show_help ()
{
  printf (_("%s: Print a human readable interpretation of a SYSROFF object file\n"),
	  program_name);
  show_usage (stdout, 0);
}


d504 3
d513 1
a513 1
  while ((opt = getopt_long (ac, av, "hV", long_options,
d519 1
d521 3
a523 2
	  show_help ();
	  /*NOTREACHED*/
d525 1
a525 1
	  printf (_("GNU %s version %s\n"), program_name, PROGRAM_VERSION);
a526 1
	  /*NOTREACHED*/
d531 1
a531 1
	  /*NOTREACHED*/
d541 2
a542 3
    {
      fatal (_("no input file specified"));
    }
d551 1
d562 3
a564 2
  coff_dump(tree);
  printf("\n");
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d4 1
a4 1
   This file is part of GNU Binutils.
d6 13
a18 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 2
a24 1
   it out so we can test the grokker.  */
d26 3
a28 2
#include "bfd.h"
#include "libiberty.h"
d32 2
a33 1
#include "getopt.h"
d36 1
a36 14

static void tab PARAMS ((int));
static void nl PARAMS ((void));
static void dump_coff_lines PARAMS ((struct coff_line *));
static void dump_coff_type PARAMS ((struct coff_type *));
static void dump_coff_where PARAMS ((struct coff_where *));
static void dump_coff_visible PARAMS ((struct coff_visible *));
extern void dump_coff_symbol PARAMS ((struct coff_symbol *));
static void dump_coff_scope PARAMS ((struct coff_scope *));
static void dump_coff_sfile PARAMS ((struct coff_sfile *));
static void dump_coff_section PARAMS ((struct coff_section *));
extern void coff_dump PARAMS ((struct coff_ofile *));
static void show_usage PARAMS ((FILE *, int));
extern int main PARAMS ((int, char **));
d40 1
a40 1
     int x;
d82 1
a82 2
static void
nl ()
d93 3
a95 5

  tab (1);
  printf (_("#lines %d "),p->nlines);

  for (i = 0; i < p->nlines; i++)
d97 1
a97 2
      printf ("(%d 0x%x)", p->lines[i], p->addresses[i]);

a98 1

d101 2
a102 2
	  nl ();
	  tab (0);
d106 2
a107 2
  nl ();
  tab (-1);
a115 1

d119 1
a119 1
      printf ("section definition at %x size %x\n",
d122 1
a122 1
      nl ();
d316 1
a323 1

d354 12
a365 1
  if (p)
d367 2
a368 6
      tab (1);
      printf ("List of blocks %lx ",(unsigned long) p);

      if (p->sec)
	printf( "  %s %x..%x",  p->sec->name,p->offset, p->offset + p->size -1);

d370 2
a371 2
      tab (0);
      printf ("*****************");
d373 1
a373 16

      while (p)
	{
	  tab (0);
	  printf ("vars %d", p->nvars);
	  nl ();
	  dump_coff_symbol (p->vars_head);
	  printf ("blocks");
	  nl ();
	  dump_coff_scope (p->list_head);
	  nl ();
	  p = p->next;
	}

      tab (0);
      printf ("*****************");
d375 1
a375 1
      tab (-1);
d377 6
a391 1

d405 1
a405 1
     struct coff_section *ptr;
d408 13
a420 15

  tab (1);
  printf ("section %s %d %d address %x size %x number %d nrelocs %d",
	  ptr->name, ptr->code, ptr->data, ptr->address,ptr->size,
	  ptr->number, ptr->nrelocs);
  nl ();

  for (i = 0; i < ptr->nrelocs; i++)
    {
      tab (0);
      printf ("(%x %s %x)",
	      ptr->relocs[i].offset,
	      ptr->relocs[i].symbol->name,
	      ptr->relocs[i].addend);
      nl ();
d422 1
a423 1
  tab (-1);
a430 1

a435 1

d437 1
a437 1
    dump_coff_section (ptr->sections + i);
d440 2
d449 3
a451 6
  fprintf (file, _("Usage: %s [option(s)] in-file\n"), program_name);
  fprintf (file, _(" Print a human readable interpretation of a SYSROFF object file\n"));
  fprintf (file, _(" The options are:\n\
  -h --help              Display this information\n\
  -v --version           Display the program's version\n\
\n"));
d453 7
a459 2
  if (status == 0)
    fprintf (file, _("Report bugs to %s\n"), REPORT_BUGS_TO);
a460 2
  exit (status);
}
a481 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
d488 1
a488 1
  while ((opt = getopt_long (ac, av, "HhVv", long_options,
a493 1
	case 'H':
d495 2
a496 3
	  show_usage (stdout, 0);
	  break;
	case 'v':
d498 1
a498 1
	  print_version ("coffdump");
d500 1
d505 1
a505 1
	  break;
d515 3
a517 2
    fatal (_("no input file specified"));

a525 1

d536 2
a537 3
  coff_dump (tree);
  printf ("\n");

@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003
d35 13
a47 13
static void tab (int);
static void nl (void);
static void dump_coff_lines (struct coff_line *);
static void dump_coff_type (struct coff_type *);
static void dump_coff_where (struct coff_where *);
static void dump_coff_visible (struct coff_visible *);
extern void dump_coff_symbol (struct coff_symbol *);
static void dump_coff_scope (struct coff_scope *);
static void dump_coff_sfile (struct coff_sfile *);
static void dump_coff_section (struct coff_section *);
extern void coff_dump (struct coff_ofile *);
static void show_usage (FILE *, int);
extern int main (int, char **);
d50 2
a51 1
tab (int x)
d94 1
a94 1
nl (void)
d100 2
a101 1
dump_coff_lines (struct coff_line *p)
d127 2
a128 1
dump_coff_type (struct coff_type *p)
d247 2
a248 1
dump_coff_where (struct coff_where *p)
d287 2
a288 1
dump_coff_visible (struct coff_visible *p)
d334 2
a335 1
dump_coff_symbol (struct coff_symbol *p)
d368 2
a369 1
dump_coff_scope (struct coff_scope *p)
d405 2
a406 1
dump_coff_sfile (struct coff_sfile *p)
d424 2
a425 1
dump_coff_section (struct coff_section *ptr)
d449 2
a450 1
coff_dump (struct coff_ofile *ptr)
d467 3
a469 1
show_usage (FILE *file, int status)
d485 3
a487 1
main (int ac, char **av)
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d4 1
a4 1
   This file is part of GNU Binutils.
d6 13
a18 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 2
a24 1
   it out so we can test the grokker.  */
d26 3
a28 2
#include "bfd.h"
#include "libiberty.h"
d32 2
a33 1
#include "getopt.h"
d36 1
a36 14

static void tab PARAMS ((int));
static void nl PARAMS ((void));
static void dump_coff_lines PARAMS ((struct coff_line *));
static void dump_coff_type PARAMS ((struct coff_type *));
static void dump_coff_where PARAMS ((struct coff_where *));
static void dump_coff_visible PARAMS ((struct coff_visible *));
extern void dump_coff_symbol PARAMS ((struct coff_symbol *));
static void dump_coff_scope PARAMS ((struct coff_scope *));
static void dump_coff_sfile PARAMS ((struct coff_sfile *));
static void dump_coff_section PARAMS ((struct coff_section *));
extern void coff_dump PARAMS ((struct coff_ofile *));
static void show_usage PARAMS ((FILE *, int));
extern int main PARAMS ((int, char **));
d40 1
a40 1
     int x;
d82 1
a82 2
static void
nl ()
d93 3
a95 5

  tab (1);
  printf (_("#lines %d "),p->nlines);

  for (i = 0; i < p->nlines; i++)
d97 1
a97 2
      printf ("(%d 0x%x)", p->lines[i], p->addresses[i]);

a98 1

d101 2
a102 2
	  nl ();
	  tab (0);
d106 2
a107 2
  nl ();
  tab (-1);
a115 1

d119 1
a119 1
      printf ("section definition at %x size %x\n",
d122 1
a122 1
      nl ();
d316 1
a323 1

d354 12
a365 1
  if (p)
d367 2
a368 6
      tab (1);
      printf ("List of blocks %lx ",(unsigned long) p);

      if (p->sec)
	printf( "  %s %x..%x",  p->sec->name,p->offset, p->offset + p->size -1);

d370 2
a371 2
      tab (0);
      printf ("*****************");
d373 1
a373 16

      while (p)
	{
	  tab (0);
	  printf ("vars %d", p->nvars);
	  nl ();
	  dump_coff_symbol (p->vars_head);
	  printf ("blocks");
	  nl ();
	  dump_coff_scope (p->list_head);
	  nl ();
	  p = p->next;
	}

      tab (0);
      printf ("*****************");
d375 1
a375 1
      tab (-1);
d377 6
a391 1

d405 1
a405 1
     struct coff_section *ptr;
d408 13
a420 15

  tab (1);
  printf ("section %s %d %d address %x size %x number %d nrelocs %d",
	  ptr->name, ptr->code, ptr->data, ptr->address,ptr->size,
	  ptr->number, ptr->nrelocs);
  nl ();

  for (i = 0; i < ptr->nrelocs; i++)
    {
      tab (0);
      printf ("(%x %s %x)",
	      ptr->relocs[i].offset,
	      ptr->relocs[i].symbol->name,
	      ptr->relocs[i].addend);
      nl ();
d422 1
a423 1
  tab (-1);
a430 1

a435 1

d437 1
a437 1
    dump_coff_section (ptr->sections + i);
d440 2
d449 3
a451 6
  fprintf (file, _("Usage: %s [option(s)] in-file\n"), program_name);
  fprintf (file, _(" Print a human readable interpretation of a SYSROFF object file\n"));
  fprintf (file, _(" The options are:\n\
  -h --help              Display this information\n\
  -v --version           Display the program's version\n\
\n"));
d453 7
a459 2
  if (status == 0)
    fprintf (file, _("Report bugs to %s\n"), REPORT_BUGS_TO);
a460 2
  exit (status);
}
a481 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
d488 1
a488 1
  while ((opt = getopt_long (ac, av, "HhVv", long_options,
a493 1
	case 'H':
d495 2
a496 3
	  show_usage (stdout, 0);
	  break;
	case 'v':
d498 1
a498 1
	  print_version ("coffdump");
d500 1
d505 1
a505 1
	  break;
d515 3
a517 2
    fatal (_("no input file specified"));

a525 1

d536 2
a537 3
  coff_dump (tree);
  printf ("\n");

@

