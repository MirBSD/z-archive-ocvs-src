head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.20.56.22;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.01.10;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.39.15;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.39.15;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.27.41;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.40.02;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.03.00;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.03.38;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* dlltool.c -- tool to generate stuff for PE style DLLs
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */


/* This program allows you to build the files necessary to create
   DLLs to run on a system which understands PE format image files.
   (eg, Windows NT)

   See "Peering Inside the PE: A Tour of the Win32 Portable Executable
   File Format", MSJ 1994, Volume 9 for more information.
   Also see "Microsoft Portable Executable and Common Object File Format,
   Specification 4.1" for more information.

   A DLL contains an export table which contains the information
   which the runtime loader needs to tie up references from a
   referencing program.

   The export table is generated by this program by reading
   in a .DEF file or scanning the .a and .o files which will be in the
   DLL.  A .o file can contain information in special  ".drectve" sections
   with export information.

   A DEF file contains any number of the following commands:


   NAME <name> [ , <base> ]
   The result is going to be <name>.EXE

   LIBRARY <name> [ , <base> ]
   The result is going to be <name>.DLL

   EXPORTS  ( (  ( <name1> [ = <name2> ] )
               | ( <name1> = <module-name> . <external-name>))
            [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] ) *
   Declares name1 as an exported symbol from the
   DLL, with optional ordinal number <integer>.
   Or declares name1 as an alias (forward) of the function <external-name>
   in the DLL <module-name>.

   IMPORTS  (  (   <internal-name> =   <module-name> . <integer> )
             | ( [ <internal-name> = ] <module-name> . <external-name> )) *
   Declares that <external-name> or the exported function whoes ordinal number
   is <integer> is to be imported from the file <module-name>.  If
   <internal-name> is specified then this is the name that the imported
   function will be refered to in the body of the DLL.

   DESCRIPTION <string>
   Puts <string> into output .exp file in the .rdata section

   [STACKSIZE|HEAPSIZE] <number-reserve> [ , <number-commit> ]
   Generates --stack|--heap <number-reserve>,<number-commit>
   in the output .drectve section.  The linker will
   see this and act upon it.

   [CODE|DATA] <attr>+
   SECTIONS ( <sectionname> <attr>+ )*
   <attr> = READ | WRITE | EXECUTE | SHARED
   Generates --attr <sectionname> <attr> in the output
   .drectve section.  The linker will see this and act
   upon it.


   A -export:<name> in a .drectve section in an input .o or .a
   file to this program is equivalent to a EXPORTS <name>
   in a .DEF file.



   The program generates output files with the prefix supplied
   on the command line, or in the def file, or taken from the first
   supplied argument.

   The .exp.s file contains the information necessary to export
   the routines in the DLL.  The .lib.s file contains the information
   necessary to use the DLL's routines from a referencing program.



   Example:

 file1.c:
   asm (".section .drectve");
   asm (".ascii \"-export:adef\"");

   void adef (char * s)
   {
     printf ("hello from the dll %s\n", s);
   }

   void bdef (char * s)
   {
     printf ("hello from the dll and the other entry point %s\n", s);
   }

 file2.c:
   asm (".section .drectve");
   asm (".ascii \"-export:cdef\"");
   asm (".ascii \"-export:ddef\"");

   void cdef (char * s)
   {
     printf ("hello from the dll %s\n", s);
   }

   void ddef (char * s)
   {
     printf ("hello from the dll and the other entry point %s\n", s);
   }

   int printf (void)
   {
     return 9;
   }

 themain.c:
   int main (void)
   {
     cdef ();
     return 0;
   }

 thedll.def

   LIBRARY thedll
   HEAPSIZE 0x40000, 0x2000
   EXPORTS bdef @@ 20
           cdef @@ 30 NONAME

   SECTIONS donkey READ WRITE
   aardvark EXECUTE

 # Compile up the parts of the dll and the program

   gcc -c file1.c file2.c themain.c

 # Optional: put the dll objects into a library
 # (you don't have to, you could name all the object
 # files on the dlltool line)

   ar  qcv thedll.in file1.o file2.o
   ranlib thedll.in

 # Run this tool over the DLL's .def file and generate an exports
 # file (thedll.o) and an imports file (thedll.a).
 # (You may have to use -S to tell dlltool where to find the assembler).

   dlltool --def thedll.def --output-exp thedll.o --output-lib thedll.a

 # Build the dll with the library and the export table

   ld -o thedll.dll thedll.o thedll.in

 # Link the executable with the import library

   gcc -o themain.exe themain.o thedll.a

 This example can be extended if relocations are needed in the DLL:

 # Compile up the parts of the dll and the program

   gcc -c file1.c file2.c themain.c

 # Run this tool over the DLL's .def file and generate an imports file.

   dlltool --def thedll.def --output-lib thedll.lib

 # Link the executable with the import library and generate a base file
 # at the same time

   gcc -o themain.exe themain.o thedll.lib -Wl,--base-file -Wl,themain.base

 # Run this tool over the DLL's .def file and generate an exports file
 # which includes the relocations from the base file.

   dlltool --def thedll.def --base-file themain.base --output-exp thedll.exp

 # Build the dll with file1.o, file2.o and the export table

   ld -o thedll.dll thedll.exp file1.o file2.o  */

/* .idata section description

   The .idata section is the import table.  It is a collection of several
   subsections used to keep the pieces for each dll together: .idata$[234567].
   IE: Each dll's .idata$2's are catenated together, each .idata$3's, etc.

   .idata$2 = Import Directory Table
   = array of IMAGE_IMPORT_DESCRIPTOR's.

	DWORD   Import Lookup Table;  - pointer to .idata$4
	DWORD   TimeDateStamp;        - currently always 0
	DWORD   ForwarderChain;       - currently always 0
	DWORD   Name;                 - pointer to dll's name
	PIMAGE_THUNK_DATA FirstThunk; - pointer to .idata$5

   .idata$3 = null terminating entry for .idata$2.

   .idata$4 = Import Lookup Table
   = array of array of pointers to hint name table.
   There is one for each dll being imported from, and each dll's set is
   terminated by a trailing NULL.

   .idata$5 = Import Address Table
   = array of array of pointers to hint name table.
   There is one for each dll being imported from, and each dll's set is
   terminated by a trailing NULL.
   Initially, this table is identical to the Import Lookup Table.  However,
   at load time, the loader overwrites the entries with the address of the
   function.

   .idata$6 = Hint Name Table
   = Array of { short, asciz } entries, one for each imported function.
   The `short' is the function's ordinal number.

   .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc).  */

/* AIX requires this to be the first thing in the file.  */
#ifndef __GNUC__
# ifdef _AIX
 #pragma alloca
#endif
#endif

#define show_allnames 0

#define PAGE_SIZE 4096
#define PAGE_MASK (-PAGE_SIZE)
#include "bfd.h"
#include "libiberty.h"
#include "bucomm.h"
#include "getopt.h"
#include "demangle.h"
#include "dyn-string.h"
#include "dlltool.h"
#include "safe-ctype.h"

#include <time.h>
#include <sys/stat.h>

#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#ifdef DLLTOOL_ARM
#include "coff/arm.h"
#include "coff/internal.h"
#endif

/* Forward references.  */
static char *look_for_prog
  PARAMS ((const char *, const char *, int));
static char *deduce_name
  PARAMS ((const char *));

#ifdef DLLTOOL_MCORE_ELF
static void mcore_elf_cache_filename
  PARAMS ((char *));
static void mcore_elf_gen_out_file
  PARAMS ((void));
#endif

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#else /* ! HAVE_SYS_WAIT_H */
#if ! defined (_WIN32) || defined (__CYGWIN32__)
#ifndef WIFEXITED
#define WIFEXITED(w)	(((w) & 0377) == 0)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)	(((w) & 0377) != 0177 && ((w) & ~0377) == 0)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w)	((w) & 0177)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)	(((w) >> 8) & 0377)
#endif
#else /* defined (_WIN32) && ! defined (__CYGWIN32__) */
#ifndef WIFEXITED
#define WIFEXITED(w)	(((w) & 0xff) == 0)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)	(((w) & 0xff) != 0 && ((w) & 0xff) != 0x7f)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w)	((w) & 0x7f)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)	(((w) & 0xff00) >> 8)
#endif
#endif /* defined (_WIN32) && ! defined (__CYGWIN32__) */
#endif /* ! HAVE_SYS_WAIT_H */

/* ifunc and ihead data structures: ttk@@cygnus.com 1997

   When IMPORT declarations are encountered in a .def file the
   function import information is stored in a structure referenced by
   the global variable IMPORT_LIST.  The structure is a linked list
   containing the names of the dll files each function is imported
   from and a linked list of functions being imported from that dll
   file.  This roughly parallels the structure of the .idata section
   in the PE object file.

   The contents of .def file are interpreted from within the
   process_def_file function.  Every time an IMPORT declaration is
   encountered, it is broken up into its component parts and passed to
   def_import.  IMPORT_LIST is initialized to NULL in function main.  */

typedef struct ifunct
{
  char *         name;   /* Name of function being imported.  */
  int            ord;    /* Two-byte ordinal value associated with function.  */
  struct ifunct *next;
} ifunctype;

typedef struct iheadt
{
  char          *dllname;  /* Name of dll file imported from.  */
  long           nfuncs;   /* Number of functions in list.  */
  struct ifunct *funchead; /* First function in list.  */
  struct ifunct *functail; /* Last  function in list.  */
  struct iheadt *next;     /* Next dll file in list.  */
} iheadtype;

/* Structure containing all import information as defined in .def file
   (qv "ihead structure").  */

static iheadtype *import_list = NULL;

static char *as_name = NULL;
static char * as_flags = "";

static char *tmp_prefix = "d";

static int no_idata4;
static int no_idata5;
static char *exp_name;
static char *imp_name;
static char *head_label;
static char *imp_name_lab;
static char *dll_name;

static int add_indirect = 0;
static int add_underscore = 0;
static int dontdeltemps = 0;

/* TRUE if we should export all symbols.  Otherwise, we only export
   symbols listed in .drectve sections or in the def file.  */
static bfd_boolean export_all_symbols;

/* TRUE if we should exclude the symbols in DEFAULT_EXCLUDES when
   exporting all symbols.  */
static bfd_boolean do_default_excludes = TRUE;

/* Default symbols to exclude when exporting all the symbols.  */
static const char *default_excludes = "DllMain@@12,DllEntryPoint@@0,impure_ptr";

/* TRUE if we should add __imp_<SYMBOL> to import libraries for backward
   compatibility to old Cygwin releases.  */
static bfd_boolean create_compat_implib;

static char *def_file;

extern char * program_name;

static int machine;
static int killat;
static int add_stdcall_alias;
static int verbose;
static FILE *output_def;
static FILE *base_file;

#ifdef DLLTOOL_ARM
#ifdef DLLTOOL_ARM_EPOC
static const char *mname = "arm-epoc";
#else
static const char *mname = "arm";
#endif
#endif

#ifdef DLLTOOL_I386
static const char *mname = "i386";
#endif

#ifdef DLLTOOL_PPC
static const char *mname = "ppc";
#endif

#ifdef DLLTOOL_SH
static const char *mname = "sh";
#endif

#ifdef DLLTOOL_MIPS
static const char *mname = "mips";
#endif

#ifdef DLLTOOL_MCORE
static const char * mname = "mcore-le";
#endif

#ifdef DLLTOOL_MCORE_ELF
static const char * mname = "mcore-elf";
static char * mcore_elf_out_file = NULL;
static char * mcore_elf_linker   = NULL;
static char * mcore_elf_linker_flags = NULL;

#define DRECTVE_SECTION_NAME ((machine == MMCORE_ELF || machine == MMCORE_ELF_LE) ? ".exports" : ".drectve")
#endif

#ifndef DRECTVE_SECTION_NAME
#define DRECTVE_SECTION_NAME ".drectve"
#endif

#define PATHMAX 250		/* What's the right name for this ?  */

char *tmp_asm_buf;
char *tmp_head_s_buf;
char *tmp_head_o_buf;
char *tmp_tail_s_buf;
char *tmp_tail_o_buf;
char *tmp_stub_buf;

#define TMP_ASM		dlltmp (tmp_asm_buf, "%sc.s")
#define TMP_HEAD_S	dlltmp (tmp_head_s_buf, "%sh.s")
#define TMP_HEAD_O	dlltmp (tmp_head_o_buf, "%sh.o")
#define TMP_TAIL_S	dlltmp (tmp_tail_s_buf, "%st.s")
#define TMP_TAIL_O	dlltmp (tmp_tail_o_buf, "%st.o")
#define TMP_STUB	dlltmp (tmp_stub_buf, "%ss")

/* This bit of assemly does jmp * ....  */
static const unsigned char i386_jtab[] =
{
  0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90
};

static const unsigned char arm_jtab[] =
{
  0x00, 0xc0, 0x9f, 0xe5,	/* ldr  ip, [pc] */
  0x00, 0xf0, 0x9c, 0xe5,	/* ldr  pc, [ip] */
  0,    0,    0,    0
};

static const unsigned char arm_interwork_jtab[] =
{
  0x04, 0xc0, 0x9f, 0xe5,	/* ldr  ip, [pc] */
  0x00, 0xc0, 0x9c, 0xe5,	/* ldr  ip, [ip] */
  0x1c, 0xff, 0x2f, 0xe1,	/* bx   ip       */
  0,    0,    0,    0
};

static const unsigned char thumb_jtab[] =
{
  0x40, 0xb4,           /* push {r6}         */
  0x02, 0x4e,           /* ldr  r6, [pc, #8] */
  0x36, 0x68,           /* ldr  r6, [r6]     */
  0xb4, 0x46,           /* mov  ip, r6       */
  0x40, 0xbc,           /* pop  {r6}         */
  0x60, 0x47,           /* bx   ip           */
  0,    0,    0,    0
};

static const unsigned char mcore_be_jtab[] =
{
  0x71, 0x02,            /* lrw r1,2       */
  0x81, 0x01,            /* ld.w r1,(r1,0) */
  0x00, 0xC1,            /* jmp r1         */
  0x12, 0x00,            /* nop            */
  0x00, 0x00, 0x00, 0x00 /* <address>      */
};

static const unsigned char mcore_le_jtab[] =
{
  0x02, 0x71,            /* lrw r1,2       */
  0x01, 0x81,            /* ld.w r1,(r1,0) */
  0xC1, 0x00,            /* jmp r1         */
  0x00, 0x12,            /* nop            */
  0x00, 0x00, 0x00, 0x00 /* <address>      */
};

/* This is the glue sequence for PowerPC PE. There is a
   tocrel16-tocdefn reloc against the first instruction.
   We also need a IMGLUE reloc against the glue function
   to restore the toc saved by the third instruction in
   the glue.  */
static const unsigned char ppc_jtab[] =
{
  0x00, 0x00, 0x62, 0x81, /* lwz r11,0(r2)               */
                          /*   Reloc TOCREL16 __imp_xxx  */
  0x00, 0x00, 0x8B, 0x81, /* lwz r12,0(r11)              */
  0x04, 0x00, 0x41, 0x90, /* stw r2,4(r1)                */
  0xA6, 0x03, 0x89, 0x7D, /* mtctr r12                   */
  0x04, 0x00, 0x4B, 0x80, /* lwz r2,4(r11)               */
  0x20, 0x04, 0x80, 0x4E  /* bctr                        */
};

#ifdef DLLTOOL_PPC
/* The glue instruction, picks up the toc from the stw in
   the above code: "lwz r2,4(r1)".  */
static bfd_vma ppc_glue_insn = 0x80410004;
#endif

struct mac
  {
    const char *type;
    const char *how_byte;
    const char *how_short;
    const char *how_long;
    const char *how_asciz;
    const char *how_comment;
    const char *how_jump;
    const char *how_global;
    const char *how_space;
    const char *how_align_short;
    const char *how_align_long;
    const char *how_default_as_switches;
    const char *how_bfd_target;
    enum bfd_architecture how_bfd_arch;
    const unsigned char *how_jtab;
    int how_jtab_size; /* Size of the jtab entry.  */
    int how_jtab_roff; /* Offset into it for the ind 32 reloc into idata 5.  */
  };

static const struct mac
mtable[] =
{
  {
#define MARM 0
    "arm", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tpc,[ip]\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "-mapcs-32",
    "pe-arm-little", bfd_arch_arm,
    arm_jtab, sizeof (arm_jtab), 8
  }
  ,
  {
#define M386 1
    "i386", ".byte", ".short", ".long", ".asciz", "#",
    "jmp *", ".global", ".space", ".align\t2",".align\t4", "",
    "pe-i386",bfd_arch_i386,
    i386_jtab, sizeof (i386_jtab), 2
  }
  ,
  {
#define MPPC 2
    "ppc", ".byte", ".short", ".long", ".asciz", "#",
    "jmp *", ".global", ".space", ".align\t2",".align\t4", "",
    "pe-powerpcle",bfd_arch_powerpc,
    ppc_jtab, sizeof (ppc_jtab), 0
  }
  ,
  {
#define MTHUMB 3
    "thumb", ".byte", ".short", ".long", ".asciz", "@@",
    "push\t{r6}\n\tldr\tr6, [pc, #8]\n\tldr\tr6, [r6]\n\tmov\tip, r6\n\tpop\t{r6}\n\tbx\tip",
    ".global", ".space", ".align\t2",".align\t4", "-mthumb-interwork",
    "pe-arm-little", bfd_arch_arm,
    thumb_jtab, sizeof (thumb_jtab), 12
  }
  ,
#define MARM_INTERWORK 4
  {
    "arm_interwork", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tip,[ip]\n\tbx\tip\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "-mthumb-interwork",
    "pe-arm-little", bfd_arch_arm,
    arm_interwork_jtab, sizeof (arm_interwork_jtab), 12
  }
  ,
  {
#define MMCORE_BE 5
    "mcore-be", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "pe-mcore-big", bfd_arch_mcore,
    mcore_be_jtab, sizeof (mcore_be_jtab), 8
  }
  ,
  {
#define MMCORE_LE 6
    "mcore-le", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "-EL",
    "pe-mcore-little", bfd_arch_mcore,
    mcore_le_jtab, sizeof (mcore_le_jtab), 8
  }
  ,
  {
#define MMCORE_ELF 7
    "mcore-elf-be", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "elf32-mcore-big", bfd_arch_mcore,
    mcore_be_jtab, sizeof (mcore_be_jtab), 8
  }
  ,
  {
#define MMCORE_ELF_LE 8
    "mcore-elf-le", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "-EL",
    "elf32-mcore-little", bfd_arch_mcore,
    mcore_le_jtab, sizeof (mcore_le_jtab), 8
  }
  ,
  {
#define MARM_EPOC 9
    "arm-epoc", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tpc,[ip]\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "epoc-pe-arm-little", bfd_arch_arm,
    arm_jtab, sizeof (arm_jtab), 8
  }
  ,
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
};

typedef struct dlist
{
  char *text;
  struct dlist *next;
}
dlist_type;

typedef struct export
  {
    const char *name;
    const char *internal_name;
    int ordinal;
    int constant;
    int noname;
    int data;
    int hint;
    int forward;	/* Number of forward label, 0 means no forward.  */
    struct export *next;
  }
export_type;

/* A list of symbols which we should not export.  */

struct string_list
{
  struct string_list *next;
  char *string;
};

static struct string_list *excludes;

static const char *rvaafter
  PARAMS ((int));
static const char *rvabefore
  PARAMS ((int));
static const char *asm_prefix
  PARAMS ((int));
static void process_def_file
  PARAMS ((const char *));
static void new_directive
  PARAMS ((char *));
static void append_import
  PARAMS ((const char *, const char *, int));
static void run
  PARAMS ((const char *, char *));
static void scan_drectve_symbols
  PARAMS ((bfd *));
static void scan_filtered_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void add_excludes
  PARAMS ((const char *));
static bfd_boolean match_exclude
  PARAMS ((const char *));
static void set_default_excludes
  PARAMS ((void));
static long filter_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void scan_all_symbols
  PARAMS ((bfd *));
static void scan_open_obj_file
  PARAMS ((bfd *));
static void scan_obj_file
  PARAMS ((const char *));
static void dump_def_info
  PARAMS ((FILE *));
static int sfunc
  PARAMS ((const void *, const void *));
static void flush_page
  PARAMS ((FILE *, long *, int, int));
static void gen_def_file
  PARAMS ((void));
static void generate_idata_ofile
  PARAMS ((FILE *));
static void assemble_file
  PARAMS ((const char *, const char *));
static void gen_exp_file
  PARAMS ((void));
static const char *xlate
  PARAMS ((const char *));
#if 0
static void dump_iat
  PARAMS ((FILE *, export_type *));
#endif
static char *make_label
  PARAMS ((const char *, const char *));
static char *make_imp_label
  PARAMS ((const char *, const char *));
static bfd *make_one_lib_file
  PARAMS ((export_type *, int));
static bfd *make_head
  PARAMS ((void));
static bfd *make_tail
  PARAMS ((void));
static void gen_lib_file
  PARAMS ((void));
static int pfunc
  PARAMS ((const void *, const void *));
static int nfunc
  PARAMS ((const void *, const void *));
static void remove_null_names
  PARAMS ((export_type **));
static void dtab
  PARAMS ((export_type **));
static void process_duplicates
  PARAMS ((export_type **));
static void fill_ordinals
  PARAMS ((export_type **));
static int alphafunc
  PARAMS ((const void *, const void *));
static void mangle_defs
  PARAMS ((void));
static void usage
  PARAMS ((FILE *, int));
static void inform
  PARAMS ((const char *, ...));

static char *
dlltmp PARAMS ((char *buf, const char *fmt))
{
  if (!buf)
    buf = malloc (strlen (tmp_prefix) + 17);
  sprintf (buf, fmt, tmp_prefix);
  return buf;
}

static void
inform VPARAMS ((const char * message, ...))
{
  VA_OPEN (args, message);
  VA_FIXEDARG (args, const char *, message);

  if (!verbose)
    return;

  report (message, args);

  VA_CLOSE (args);
}

static const char *
rvaafter (machine)
     int machine;
{
  switch (machine)
    {
    case MARM:
    case M386:
    case MPPC:
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
    case MARM_EPOC:
      break;
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), machine);
      break;
    }
  return "";
}

static const char *
rvabefore (machine)
     int machine;
{
  switch (machine)
    {
    case MARM:
    case M386:
    case MPPC:
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
    case MARM_EPOC:
      return ".rva\t";
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), machine);
      break;
    }
  return "";
}

static const char *
asm_prefix (machine)
     int machine;
{
  switch (machine)
    {
    case MARM:
    case MPPC:
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
    case MARM_EPOC:
      break;
    case M386:
      return "_";
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), machine);
      break;
    }
  return "";
}

#define ASM_BYTE 	mtable[machine].how_byte
#define ASM_SHORT 	mtable[machine].how_short
#define ASM_LONG	mtable[machine].how_long
#define ASM_TEXT	mtable[machine].how_asciz
#define ASM_C 		mtable[machine].how_comment
#define ASM_JUMP 	mtable[machine].how_jump
#define ASM_GLOBAL	mtable[machine].how_global
#define ASM_SPACE	mtable[machine].how_space
#define ASM_ALIGN_SHORT mtable[machine].how_align_short
#define ASM_RVA_BEFORE 	rvabefore(machine)
#define ASM_RVA_AFTER  	rvaafter(machine)
#define ASM_PREFIX	asm_prefix(machine)
#define ASM_ALIGN_LONG  mtable[machine].how_align_long
#define HOW_BFD_READ_TARGET  0  /* always default*/
#define HOW_BFD_WRITE_TARGET mtable[machine].how_bfd_target
#define HOW_BFD_ARCH    mtable[machine].how_bfd_arch
#define HOW_JTAB        mtable[machine].how_jtab
#define HOW_JTAB_SIZE   mtable[machine].how_jtab_size
#define HOW_JTAB_ROFF   mtable[machine].how_jtab_roff
#define ASM_SWITCHES    mtable[machine].how_default_as_switches

static char **oav;

static void
process_def_file (name)
     const char *name;
{
  FILE *f = fopen (name, FOPEN_RT);

  if (!f)
    /* xgettext:c-format */
    fatal (_("Can't open def file: %s"), name);

  yyin = f;

  /* xgettext:c-format */
  inform (_("Processing def file: %s"), name);

  yyparse ();

  inform (_("Processed def file"));
}

/**********************************************************************/

/* Communications with the parser.  */

static const char *d_name;	/* Arg to NAME or LIBRARY.  */
static int d_nfuncs;		/* Number of functions exported.  */
static int d_named_nfuncs;	/* Number of named functions exported.  */
static int d_low_ord;		/* Lowest ordinal index.  */
static int d_high_ord;		/* Highest ordinal index.  */
static export_type *d_exports;	/* List of exported functions.  */
static export_type **d_exports_lexically;  /* Vector of exported functions in alpha order.  */
static dlist_type *d_list;	/* Descriptions.  */
static dlist_type *a_list;	/* Stuff to go in directives.  */
static int d_nforwards = 0;	/* Number of forwarded exports.  */

static int d_is_dll;
static int d_is_exe;

int
yyerror (err)
     const char * err ATTRIBUTE_UNUSED;
{
  /* xgettext:c-format */
  non_fatal (_("Syntax error in def file %s:%d"), def_file, linenumber);

  return 0;
}

void
def_exports (name, internal_name, ordinal, noname, constant, data)
     const char *name;
     const char *internal_name;
     int ordinal;
     int noname;
     int constant;
     int data;
{
  struct export *p = (struct export *) xmalloc (sizeof (*p));

  p->name = name;
  p->internal_name = internal_name ? internal_name : name;
  p->ordinal = ordinal;
  p->constant = constant;
  p->noname = noname;
  p->data = data;
  p->next = d_exports;
  d_exports = p;
  d_nfuncs++;

  if ((internal_name != NULL)
      && (strchr (internal_name, '.') != NULL))
    p->forward = ++d_nforwards;
  else
    p->forward = 0; /* no forward */
}

void
def_name (name, base)
     const char *name;
     int base;
{
  /* xgettext:c-format */
  inform (_("NAME: %s base: %x"), name, base);

  if (d_is_dll)
    non_fatal (_("Can't have LIBRARY and NAME"));

  d_name = name;
  /* If --dllname not provided, use the one in the DEF file.
     FIXME: Is this appropriate for executables?  */
  if (! dll_name)
    dll_name = xstrdup (name);
  d_is_exe = 1;
}

void
def_library (name, base)
     const char *name;
     int base;
{
  /* xgettext:c-format */
  inform (_("LIBRARY: %s base: %x"), name, base);

  if (d_is_exe)
    non_fatal (_("Can't have LIBRARY and NAME"));

  d_name = name;
  /* If --dllname not provided, use the one in the DEF file.  */
  if (! dll_name)
    dll_name = xstrdup (name);
  d_is_dll = 1;
}

void
def_description (desc)
     const char *desc;
{
  dlist_type *d = (dlist_type *) xmalloc (sizeof (dlist_type));
  d->text = xstrdup (desc);
  d->next = d_list;
  d_list = d;
}

static void
new_directive (dir)
     char *dir;
{
  dlist_type *d = (dlist_type *) xmalloc (sizeof (dlist_type));
  d->text = xstrdup (dir);
  d->next = a_list;
  a_list = d;
}

void
def_heapsize (reserve, commit)
     int reserve;
     int commit;
{
  char b[200];
  if (commit > 0)
    sprintf (b, "-heap 0x%x,0x%x ", reserve, commit);
  else
    sprintf (b, "-heap 0x%x ", reserve);
  new_directive (xstrdup (b));
}

void
def_stacksize (reserve, commit)
     int reserve;
     int commit;
{
  char b[200];
  if (commit > 0)
    sprintf (b, "-stack 0x%x,0x%x ", reserve, commit);
  else
    sprintf (b, "-stack 0x%x ", reserve);
  new_directive (xstrdup (b));
}

/* append_import simply adds the given import definition to the global
   import_list.  It is used by def_import.  */

static void
append_import (symbol_name, dll_name, func_ordinal)
     const char *symbol_name;
     const char *dll_name;
     int func_ordinal;
{
  iheadtype **pq;
  iheadtype *q;

  for (pq = &import_list; *pq != NULL; pq = &(*pq)->next)
    {
      if (strcmp ((*pq)->dllname, dll_name) == 0)
	{
	  q = *pq;
	  q->functail->next = xmalloc (sizeof (ifunctype));
	  q->functail = q->functail->next;
	  q->functail->ord  = func_ordinal;
	  q->functail->name = xstrdup (symbol_name);
	  q->functail->next = NULL;
	  q->nfuncs++;
	  return;
	}
    }

  q = xmalloc (sizeof (iheadtype));
  q->dllname = xstrdup (dll_name);
  q->nfuncs = 1;
  q->funchead = xmalloc (sizeof (ifunctype));
  q->functail = q->funchead;
  q->next = NULL;
  q->functail->name = xstrdup (symbol_name);
  q->functail->ord  = func_ordinal;
  q->functail->next = NULL;

  *pq = q;
}

/* def_import is called from within defparse.y when an IMPORT
   declaration is encountered.  Depending on the form of the
   declaration, the module name may or may not need ".dll" to be
   appended to it, the name of the function may be stored in internal
   or entry, and there may or may not be an ordinal value associated
   with it.  */

/* A note regarding the parse modes:
   In defparse.y we have to accept import declarations which follow
   any one of the following forms:
     <func_name_in_app> = <dll_name>.<func_name_in_dll>
     <func_name_in_app> = <dll_name>.<number>
     <dll_name>.<func_name_in_dll>
     <dll_name>.<number>
   Furthermore, the dll's name may or may not end with ".dll", which
   complicates the parsing a little.  Normally the dll's name is
   passed to def_import() in the "module" parameter, but when it ends
   with ".dll" it gets passed in "module" sans ".dll" and that needs
   to be reappended.

  def_import gets five parameters:
  APP_NAME - the name of the function in the application, if
             present, or NULL if not present.
  MODULE   - the name of the dll, possibly sans extension (ie, '.dll').
  DLLEXT   - the extension of the dll, if present, NULL if not present.
  ENTRY    - the name of the function in the dll, if present, or NULL.
  ORD_VAL  - the numerical tag of the function in the dll, if present,
             or NULL.  Exactly one of <entry> or <ord_val> must be
             present (i.e., not NULL).  */

void
def_import (app_name, module, dllext, entry, ord_val)
     const char *app_name;
     const char *module;
     const char *dllext;
     const char *entry;
     int ord_val;
{
  const char *application_name;
  char *buf;

  if (entry != NULL)
    application_name = entry;
  else
    {
      if (app_name != NULL)
	application_name = app_name;
      else
	application_name = "";
    }

  if (dllext != NULL)
    {
      buf = (char *) alloca (strlen (module) + strlen (dllext) + 2);
      sprintf (buf, "%s.%s", module, dllext);
      module = buf;
    }

  append_import (application_name, module, ord_val);
}

void
def_version (major, minor)
     int major;
     int minor;
{
  printf ("VERSION %d.%d\n", major, minor);
}

void
def_section (name, attr)
     const char *name;
     int attr;
{
  char buf[200];
  char atts[5];
  char *d = atts;
  if (attr & 1)
    *d++ = 'R';

  if (attr & 2)
    *d++ = 'W';
  if (attr & 4)
    *d++ = 'X';
  if (attr & 8)
    *d++ = 'S';
  *d++ = 0;
  sprintf (buf, "-attr %s %s", name, atts);
  new_directive (xstrdup (buf));
}

void
def_code (attr)
     int attr;
{

  def_section ("CODE", attr);
}

void
def_data (attr)
     int attr;
{
  def_section ("DATA", attr);
}

/**********************************************************************/

static void
run (what, args)
     const char *what;
     char *args;
{
  char *s;
  int pid, wait_status;
  int i;
  const char **argv;
  char *errmsg_fmt, *errmsg_arg;
#if defined(__MSDOS__) && !defined(__GO32__)
  char *temp_base = choose_temp_base ();
#else
  char *temp_base = NULL;
#endif

  inform ("run: %s %s", what, args);

  /* Count the args */
  i = 0;
  for (s = args; *s; s++)
    if (*s == ' ')
      i++;
  i++;
  argv = alloca (sizeof (char *) * (i + 3));
  i = 0;
  argv[i++] = what;
  s = args;
  while (1)
    {
      while (*s == ' ')
	++s;
      argv[i++] = s;
      while (*s != ' ' && *s != 0)
	s++;
      if (*s == 0)
	break;
      *s++ = 0;
    }
  argv[i++] = NULL;

  pid = pexecute (argv[0], (char * const *) argv, program_name, temp_base,
		  &errmsg_fmt, &errmsg_arg, PEXECUTE_ONE | PEXECUTE_SEARCH);

  if (pid == -1)
    {
      inform (strerror (errno));

      fatal (errmsg_fmt, errmsg_arg);
    }

  pid = pwait (pid, & wait_status, 0);

  if (pid == -1)
    {
      /* xgettext:c-format */
      fatal (_("wait: %s"), strerror (errno));
    }
  else if (WIFSIGNALED (wait_status))
    {
      /* xgettext:c-format */
      fatal (_("subprocess got fatal signal %d"), WTERMSIG (wait_status));
    }
  else if (WIFEXITED (wait_status))
    {
      if (WEXITSTATUS (wait_status) != 0)
	/* xgettext:c-format */
	non_fatal (_("%s exited with status %d"),
		   what, WEXITSTATUS (wait_status));
    }
  else
    abort ();
}

/* Look for a list of symbols to export in the .drectve section of
   ABFD.  Pass each one to def_exports.  */

static void
scan_drectve_symbols (abfd)
     bfd *abfd;
{
  asection * s;
  int        size;
  char *     buf;
  char *     p;
  char *     e;

  /* Look for .drectve's */
  s = bfd_get_section_by_name (abfd, DRECTVE_SECTION_NAME);

  if (s == NULL)
    return;

  size = bfd_get_section_size_before_reloc (s);
  buf  = xmalloc (size);

  bfd_get_section_contents (abfd, s, buf, 0, size);

  /* xgettext:c-format */
  inform (_("Sucking in info from %s section in %s"),
	  DRECTVE_SECTION_NAME, bfd_get_filename (abfd));

  /* Search for -export: strings. The exported symbols can optionally
     have type tags (eg., -export:foo,data), so handle those as well.
     Currently only data tag is supported.  */
  p = buf;
  e = buf + size;
  while (p < e)
    {
      if (p[0] == '-'
	  && strncmp (p, "-export:", 8) == 0)
	{
	  char * name;
	  char * c;
	  flagword flags = BSF_FUNCTION;

	  p += 8;
	  name = p;
	  while (p < e && *p != ',' && *p != ' ' && *p != '-')
	    p++;
	  c = xmalloc (p - name + 1);
	  memcpy (c, name, p - name);
	  c[p - name] = 0;
	  if (p < e && *p == ',')       /* found type tag.  */
	    {
	      char *tag_start = ++p;
	      while (p < e && *p != ' ' && *p != '-')
		p++;
	      if (strncmp (tag_start, "data", 4) == 0)
		flags &= ~BSF_FUNCTION;
	    }

	  /* FIXME: The 5th arg is for the `constant' field.
	     What should it be?  Not that it matters since it's not
	     currently useful.  */
	  def_exports (c, 0, -1, 0, 0, ! (flags & BSF_FUNCTION));

	  if (add_stdcall_alias && strchr (c, '@@'))
	    {
	      int lead_at = (*c == '@@') ;
	      char *exported_name = xstrdup (c + lead_at);
	      char *atsym = strchr (exported_name, '@@');
	      *atsym = '\0';
	      /* Note: stdcall alias symbols can never be data.  */
	      def_exports (exported_name, xstrdup (c), -1, 0, 0, 0);
	    }
	}
      else
	p++;
    }
  free (buf);
}

/* Look through the symbols in MINISYMS, and add each one to list of
   symbols to export.  */

static void
scan_filtered_symbols (abfd, minisyms, symcount, size)
     bfd *abfd;
     PTR minisyms;
     long symcount;
     unsigned int size;
{
  asymbol *store;
  bfd_byte *from, *fromend;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  for (; from < fromend; from += size)
    {
      asymbol *sym;
      const char *symbol_name;

      sym = bfd_minisymbol_to_symbol (abfd, FALSE, from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      symbol_name = bfd_asymbol_name (sym);
      if (bfd_get_symbol_leading_char (abfd) == symbol_name[0])
	++symbol_name;

      def_exports (xstrdup (symbol_name) , 0, -1, 0, 0,
		   ! (sym->flags & BSF_FUNCTION));

      if (add_stdcall_alias && strchr (symbol_name, '@@'))
        {
	  int lead_at = (*symbol_name == '@@');
	  char *exported_name = xstrdup (symbol_name + lead_at);
	  char *atsym = strchr (exported_name, '@@');
	  *atsym = '\0';
	  /* Note: stdcall alias symbols can never be data.  */
	  def_exports (exported_name, xstrdup (symbol_name), -1, 0, 0, 0);
	}
    }
}

/* Add a list of symbols to exclude.  */

static void
add_excludes (new_excludes)
     const char *new_excludes;
{
  char *local_copy;
  char *exclude_string;

  local_copy = xstrdup (new_excludes);

  exclude_string = strtok (local_copy, ",:");
  for (; exclude_string; exclude_string = strtok (NULL, ",:"))
    {
      struct string_list *new_exclude;

      new_exclude = ((struct string_list *)
		     xmalloc (sizeof (struct string_list)));
      new_exclude->string = (char *) xmalloc (strlen (exclude_string) + 2);
      /* Don't add a leading underscore for fastcall symbols.  */
      if (*exclude_string == '@@')
	sprintf (new_exclude->string, "%s", exclude_string);
      else
	sprintf (new_exclude->string, "_%s", exclude_string);
      new_exclude->next = excludes;
      excludes = new_exclude;

      /* xgettext:c-format */
      inform (_("Excluding symbol: %s"), exclude_string);
    }

  free (local_copy);
}

/* See if STRING is on the list of symbols to exclude.  */

static bfd_boolean
match_exclude (string)
     const char *string;
{
  struct string_list *excl_item;

  for (excl_item = excludes; excl_item; excl_item = excl_item->next)
    if (strcmp (string, excl_item->string) == 0)
      return TRUE;
  return FALSE;
}

/* Add the default list of symbols to exclude.  */

static void
set_default_excludes (void)
{
  add_excludes (default_excludes);
}

/* Choose which symbols to export.  */

static long
filter_symbols (abfd, minisyms, symcount, size)
     bfd *abfd;
     PTR minisyms;
     long symcount;
     unsigned int size;
{
  bfd_byte *from, *fromend, *to;
  asymbol *store;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  to = (bfd_byte *) minisyms;

  for (; from < fromend; from += size)
    {
      int keep = 0;
      asymbol *sym;

      sym = bfd_minisymbol_to_symbol (abfd, FALSE, (const PTR) from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      /* Check for external and defined only symbols.  */
      keep = (((sym->flags & BSF_GLOBAL) != 0
	       || (sym->flags & BSF_WEAK) != 0
	       || bfd_is_com_section (sym->section))
	      && ! bfd_is_und_section (sym->section));

      keep = keep && ! match_exclude (sym->name);

      if (keep)
	{
	  memcpy (to, from, size);
	  to += size;
	}
    }

  return (to - (bfd_byte *) minisyms) / size;
}

/* Export all symbols in ABFD, except for ones we were told not to
   export.  */

static void
scan_all_symbols (abfd)
     bfd *abfd;
{
  long symcount;
  PTR minisyms;
  unsigned int size;

  /* Ignore bfds with an import descriptor table.  We assume that any
     such BFD contains symbols which are exported from another DLL,
     and we don't want to reexport them from here.  */
  if (bfd_get_section_by_name (abfd, ".idata$4"))
    return;

  if (! (bfd_get_file_flags (abfd) & HAS_SYMS))
    {
      /* xgettext:c-format */
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
    }

  symcount = bfd_read_minisymbols (abfd, FALSE, &minisyms, &size);
  if (symcount < 0)
    bfd_fatal (bfd_get_filename (abfd));

  if (symcount == 0)
    {
      /* xgettext:c-format */
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
    }

  /* Discard the symbols we don't want to export.  It's OK to do this
     in place; we'll free the storage anyway.  */

  symcount = filter_symbols (abfd, minisyms, symcount, size);
  scan_filtered_symbols (abfd, minisyms, symcount, size);

  free (minisyms);
}

/* Look at the object file to decide which symbols to export.  */

static void
scan_open_obj_file (abfd)
     bfd *abfd;
{
  if (export_all_symbols)
    scan_all_symbols (abfd);
  else
    scan_drectve_symbols (abfd);

  /* FIXME: we ought to read in and block out the base relocations.  */

  /* xgettext:c-format */
  inform (_("Done reading %s"), bfd_get_filename (abfd));
}

static void
scan_obj_file (filename)
     const char *filename;
{
  bfd * f = bfd_openr (filename, 0);

  if (!f)
    /* xgettext:c-format */
    fatal (_("Unable to open object file: %s"), filename);

  /* xgettext:c-format */
  inform (_("Scanning object file %s"), filename);

  if (bfd_check_format (f, bfd_archive))
    {
      bfd *arfile = bfd_openr_next_archived_file (f, 0);
      while (arfile)
	{
	  if (bfd_check_format (arfile, bfd_object))
	    scan_open_obj_file (arfile);
	  bfd_close (arfile);
	  arfile = bfd_openr_next_archived_file (f, arfile);
	}

#ifdef DLLTOOL_MCORE_ELF
      if (mcore_elf_out_file)
	inform (_("Cannot produce mcore-elf dll from archive file: %s"), filename);
#endif
    }
  else if (bfd_check_format (f, bfd_object))
    {
      scan_open_obj_file (f);

#ifdef DLLTOOL_MCORE_ELF
      if (mcore_elf_out_file)
	mcore_elf_cache_filename ((char *) filename);
#endif
    }

  bfd_close (f);
}

/**********************************************************************/

static void
dump_def_info (f)
     FILE *f;
{
  int i;
  export_type *exp;
  fprintf (f, "%s ", ASM_C);
  for (i = 0; oav[i]; i++)
    fprintf (f, "%s ", oav[i]);
  fprintf (f, "\n");
  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    {
      fprintf (f, "%s  %d = %s %s @@ %d %s%s%s\n",
	       ASM_C,
	       i,
	       exp->name,
	       exp->internal_name,
	       exp->ordinal,
	       exp->noname ? "NONAME " : "",
	       exp->constant ? "CONSTANT" : "",
	       exp->data ? "DATA" : "");
    }
}

/* Generate the .exp file.  */

static int
sfunc (a, b)
     const void *a;
     const void *b;
{
  return *(const long *) a - *(const long *) b;
}

static void
flush_page (f, need, page_addr, on_page)
     FILE *f;
     long *need;
     int page_addr;
     int on_page;
{
  int i;

  /* Flush this page.  */
  fprintf (f, "\t%s\t0x%08x\t%s Starting RVA for chunk\n",
	   ASM_LONG,
	   page_addr,
	   ASM_C);
  fprintf (f, "\t%s\t0x%x\t%s Size of block\n",
	   ASM_LONG,
	   (on_page * 2) + (on_page & 1) * 2 + 8,
	   ASM_C);

  for (i = 0; i < on_page; i++)
    {
      long needed = need[i];

      if (needed)
	needed = ((needed - page_addr) | 0x3000) & 0xffff;

      fprintf (f, "\t%s\t0x%lx\n", ASM_SHORT, needed);
    }

  /* And padding */
  if (on_page & 1)
    fprintf (f, "\t%s\t0x%x\n", ASM_SHORT, 0 | 0x0000);
}

static void
gen_def_file ()
{
  int i;
  export_type *exp;

  inform (_("Adding exports to output file"));

  fprintf (output_def, ";");
  for (i = 0; oav[i]; i++)
    fprintf (output_def, " %s", oav[i]);

  fprintf (output_def, "\nEXPORTS\n");

  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    {
      char *quote = strchr (exp->name, '.') ? "\"" : "";
      char *res = cplus_demangle (exp->internal_name, DMGL_ANSI | DMGL_PARAMS);

      if (res)
	{
 	  fprintf (output_def,";\t%s\n", res);
	  free (res);
	}

      if (strcmp (exp->name, exp->internal_name) == 0)
	{

	  fprintf (output_def, "\t%s%s%s @@ %d%s%s\n",
		   quote,
		   exp->name,
		   quote,
		   exp->ordinal,
		   exp->noname ? " NONAME" : "",
		   exp->data ? " DATA" : "");
	}
      else
	{
	  char *quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
	  /* char *alias =  */
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s\n",
		   quote,
		   exp->name,
		   quote,
		   quote1,
		   exp->internal_name,
		   quote1,
		   exp->ordinal,
		   exp->noname ? " NONAME" : "",
		   exp->data ? " DATA" : "");
	}
    }

  inform (_("Added exports to output file"));
}

/* generate_idata_ofile generates the portable assembly source code
   for the idata sections.  It appends the source code to the end of
   the file.  */

static void
generate_idata_ofile (filvar)
     FILE *filvar;
{
  iheadtype *headptr;
  ifunctype *funcptr;
  int        headindex;
  int        funcindex;
  int	     nheads;

  if (import_list == NULL)
    return;

  fprintf (filvar, "%s Import data sections\n", ASM_C);
  fprintf (filvar, "\n\t.section\t.idata$2\n");
  fprintf (filvar, "\t%s\tdoi_idata\n", ASM_GLOBAL);
  fprintf (filvar, "doi_idata:\n");

  nheads = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "\t%slistone%d%s\t%s %s\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER,
	       ASM_C, headptr->dllname);
      fprintf (filvar, "\t%s\t0\n", ASM_LONG);
      fprintf (filvar, "\t%s\t0\n", ASM_LONG);
      fprintf (filvar, "\t%sdllname%d%s\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER);
      fprintf (filvar, "\t%slisttwo%d%s\n\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER);
      nheads++;
    }

  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL record at */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* end of idata$2 */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* section        */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG);
  fprintf (filvar, "\t%s\t0\n", ASM_LONG);

  fprintf (filvar, "\n\t.section\t.idata$4\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "listone%d:\n", headindex);
      for ( funcindex = 0; funcindex < headptr->nfuncs; funcindex++ )
	fprintf (filvar, "\t%sfuncptr%d_%d%s\n",
		 ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER);
      fprintf (filvar,"\t%s\t0\n", ASM_LONG); /* NULL terminating list */
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$5\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "listtwo%d:\n", headindex);
      for ( funcindex = 0; funcindex < headptr->nfuncs; funcindex++ )
	fprintf (filvar, "\t%sfuncptr%d_%d%s\n",
		 ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER);
      fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL terminating list */
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$6\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      funcindex = 0;
      for (funcptr = headptr->funchead; funcptr != NULL;
	   funcptr = funcptr->next)
	{
	  fprintf (filvar,"funcptr%d_%d:\n", headindex, funcindex);
	  fprintf (filvar,"\t%s\t%d\n", ASM_SHORT,
		   ((funcptr->ord) & 0xFFFF));
	  fprintf (filvar,"\t%s\t\"%s\"\n", ASM_TEXT, funcptr->name);
	  fprintf (filvar,"\t%s\t0\n", ASM_BYTE);
	  funcindex++;
	}
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$7\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar,"dllname%d:\n", headindex);
      fprintf (filvar,"\t%s\t\"%s\"\n", ASM_TEXT, headptr->dllname);
      fprintf (filvar,"\t%s\t0\n", ASM_BYTE);
      headindex++;
    }
}

/* Assemble the specified file.  */
static void
assemble_file (source, dest)
     const char * source;
     const char * dest;
{
  char * cmd;

  cmd = (char *) alloca (strlen (ASM_SWITCHES) + strlen (as_flags)
			 + strlen (source) + strlen (dest) + 50);

  sprintf (cmd, "%s %s -o %s %s", ASM_SWITCHES, as_flags, dest, source);

  run (as_name, cmd);
}

static void
gen_exp_file ()
{
  FILE *f;
  int i;
  export_type *exp;
  dlist_type *dl;

  /* xgettext:c-format */
  inform (_("Generating export file: %s"), exp_name);

  f = fopen (TMP_ASM, FOPEN_WT);
  if (!f)
    /* xgettext:c-format */
    fatal (_("Unable to open temporary assembler file: %s"), TMP_ASM);

  /* xgettext:c-format */
  inform (_("Opened temporary file: %s"), TMP_ASM);

  dump_def_info (f);

  if (d_exports)
    {
      fprintf (f, "\t.section	.edata\n\n");
      fprintf (f, "\t%s	0	%s Allways 0\n", ASM_LONG, ASM_C);
      fprintf (f, "\t%s	0x%lx	%s Time and date\n", ASM_LONG, (long) time(0),
	       ASM_C);
      fprintf (f, "\t%s	0	%s Major and Minor version\n", ASM_LONG, ASM_C);
      fprintf (f, "\t%sname%s	%s Ptr to name of dll\n", ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);
      fprintf (f, "\t%s	%d	%s Starting ordinal of exports\n", ASM_LONG, d_low_ord, ASM_C);


      fprintf (f, "\t%s	%d	%s Number of functions\n", ASM_LONG, d_high_ord - d_low_ord + 1, ASM_C);
      fprintf(f,"\t%s named funcs %d, low ord %d, high ord %d\n",
	      ASM_C,
	      d_named_nfuncs, d_low_ord, d_high_ord);
      fprintf (f, "\t%s	%d	%s Number of names\n", ASM_LONG,
	       show_allnames ? d_high_ord - d_low_ord + 1 : d_named_nfuncs, ASM_C);
      fprintf (f, "\t%safuncs%s  %s Address of functions\n", ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

      fprintf (f, "\t%sanames%s	%s Address of Name Pointer Table\n",
	       ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

      fprintf (f, "\t%sanords%s	%s Address of ordinals\n", ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

      fprintf (f, "name:	%s	\"%s\"\n", ASM_TEXT, dll_name);


      fprintf(f,"%s Export address Table\n", ASM_C);
      fprintf(f,"\t%s\n", ASM_ALIGN_LONG);
      fprintf (f, "afuncs:\n");
      i = d_low_ord;

      for (exp = d_exports; exp; exp = exp->next)
	{
	  if (exp->ordinal != i)
	    {
#if 0
	      fprintf (f, "\t%s\t%d\t%s %d..%d missing\n",
		       ASM_SPACE,
		       (exp->ordinal - i) * 4,
		       ASM_C,
		       i, exp->ordinal - 1);
	      i = exp->ordinal;
#endif
	      while (i < exp->ordinal)
		{
		  fprintf(f,"\t%s\t0\n", ASM_LONG);
		  i++;
		}
	    }

	  if (exp->forward == 0)
	    {
	      if (exp->internal_name[0] == '@@')
		fprintf (f, "\t%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	      else
		fprintf (f, "\t%s%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 ASM_PREFIX,
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	    }
	  else
	    fprintf (f, "\t%sf%d%s\t%s %d\n", ASM_RVA_BEFORE,
		     exp->forward, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	  i++;
	}

      fprintf (f,"%s Export Name Pointer Table\n", ASM_C);
      fprintf (f, "anames:\n");

      for (i = 0; (exp = d_exports_lexically[i]); i++)
	{
	  if (!exp->noname || show_allnames)
	    fprintf (f, "\t%sn%d%s\n",
		     ASM_RVA_BEFORE, exp->ordinal, ASM_RVA_AFTER);
	}

      fprintf (f,"%s Export Oridinal Table\n", ASM_C);
      fprintf (f, "anords:\n");
      for (i = 0; (exp = d_exports_lexically[i]); i++)
	{
	  if (!exp->noname || show_allnames)
	    fprintf (f, "\t%s	%d\n", ASM_SHORT, exp->ordinal - d_low_ord);
	}

      fprintf(f,"%s Export Name Table\n", ASM_C);
      for (i = 0; (exp = d_exports_lexically[i]); i++)
	if (!exp->noname || show_allnames)
	  {
	    fprintf (f, "n%d:	%s	\"%s\"\n",
		     exp->ordinal, ASM_TEXT, xlate (exp->name));
	    if (exp->forward != 0)
	      fprintf (f, "f%d:	%s	\"%s\"\n",
		       exp->forward, ASM_TEXT, exp->internal_name);
	  }

      if (a_list)
	{
	  fprintf (f, "\t.section %s\n", DRECTVE_SECTION_NAME);
	  for (dl = a_list; dl; dl = dl->next)
	    {
	      fprintf (f, "\t%s\t\"%s\"\n", ASM_TEXT, dl->text);
	    }
	}

      if (d_list)
	{
	  fprintf (f, "\t.section .rdata\n");
	  for (dl = d_list; dl; dl = dl->next)
	    {
	      char *p;
	      int l;

	      /* We don't output as ascii because there can
	         be quote characters in the string.  */
	      l = 0;
	      for (p = dl->text; *p; p++)
		{
		  if (l == 0)
		    fprintf (f, "\t%s\t", ASM_BYTE);
		  else
		    fprintf (f, ",");
		  fprintf (f, "%d", *p);
		  if (p[1] == 0)
		    {
		      fprintf (f, ",0\n");
		      break;
		    }
		  if (++l == 10)
		    {
		      fprintf (f, "\n");
		      l = 0;
		    }
		}
	    }
	}
    }


  /* Add to the output file a way of getting to the exported names
     without using the import library.  */
  if (add_indirect)
    {
      fprintf (f, "\t.section\t.rdata\n");
      for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
	if (!exp->noname || show_allnames)
	  {
	    /* We use a single underscore for MS compatibility, and a
               double underscore for backward compatibility with old
               cygwin releases.  */
	    if (create_compat_implib)
	      fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
	    fprintf (f, "\t%s\t_imp__%s\n", ASM_GLOBAL, exp->name);
	    if (create_compat_implib)
	      fprintf (f, "__imp_%s:\n", exp->name);
	    fprintf (f, "_imp__%s:\n", exp->name);
	    fprintf (f, "\t%s\t%s\n", ASM_LONG, exp->name);
	  }
    }

  /* Dump the reloc section if a base file is provided.  */
  if (base_file)
    {
      int addr;
      long need[PAGE_SIZE];
      long page_addr;
      int numbytes;
      int num_entries;
      long *copy;
      int j;
      int on_page;
      fprintf (f, "\t.section\t.init\n");
      fprintf (f, "lab:\n");

      fseek (base_file, 0, SEEK_END);
      numbytes = ftell (base_file);
      fseek (base_file, 0, SEEK_SET);
      copy = xmalloc (numbytes);
      fread (copy, 1, numbytes, base_file);
      num_entries = numbytes / sizeof (long);


      fprintf (f, "\t.section\t.reloc\n");
      if (num_entries)
	{
	  int src;
	  int dst = 0;
	  int last = -1;
	  qsort (copy, num_entries, sizeof (long), sfunc);
	  /* Delete duplcates */
	  for (src = 0; src < num_entries; src++)
	    {
	      if (last != copy[src])
		last = copy[dst++] = copy[src];
	    }
	  num_entries = dst;
	  addr = copy[0];
	  page_addr = addr & PAGE_MASK;		/* work out the page addr */
	  on_page = 0;
	  for (j = 0; j < num_entries; j++)
	    {
	      addr = copy[j];
	      if ((addr & PAGE_MASK) != page_addr)
		{
		  flush_page (f, need, page_addr, on_page);
		  on_page = 0;
		  page_addr = addr & PAGE_MASK;
		}
	      need[on_page++] = addr;
	    }
	  flush_page (f, need, page_addr, on_page);

/*	  fprintf (f, "\t%s\t0,0\t%s End\n", ASM_LONG, ASM_C);*/
	}
    }

  generate_idata_ofile (f);

  fclose (f);

  /* Assemble the file.  */
  assemble_file (TMP_ASM, exp_name);

  if (dontdeltemps == 0)
    unlink (TMP_ASM);

  inform (_("Generated exports file"));
}

static const char *
xlate (name)
     const char *name;
{
  int lead_at = (*name == '@@');

  if (add_underscore &&  !lead_at)
    {
      char *copy = xmalloc (strlen (name) + 2);

      copy[0] = '_';
      strcpy (copy + 1, name);
      name = copy;
    }

  if (killat)
    {
      char *p;

      name += lead_at;
      p = strchr (name, '@@');
      if (p)
	*p = 0;
    }
  return name;
}

/**********************************************************************/

#if 0

static void
dump_iat (f, exp)
     FILE *f;
     export_type *exp;
{
  if (exp->noname && !show_allnames )
    {
      fprintf (f, "\t%s\t0x%08x\n",
	       ASM_LONG,
	       exp->ordinal | 0x80000000); /* hint or orindal ?? */
    }
  else
    {
      fprintf (f, "\t%sID%d%s\n", ASM_RVA_BEFORE,
	       exp->ordinal,
	       ASM_RVA_AFTER);
    }
}

#endif

typedef struct
{
  int id;
  const char *name;
  int flags;
  int align;
  asection *sec;
  asymbol *sym;
  asymbol **sympp;
  int size;
  unsigned char *data;
} sinfo;

#ifndef DLLTOOL_PPC

#define TEXT 0
#define DATA 1
#define BSS 2
#define IDATA7 3
#define IDATA5 4
#define IDATA4 5
#define IDATA6 6

#define NSECS 7

#define TEXT_SEC_FLAGS   \
        (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY | SEC_HAS_CONTENTS)
#define DATA_SEC_FLAGS   (SEC_ALLOC | SEC_LOAD | SEC_DATA)
#define BSS_SEC_FLAGS     SEC_ALLOC

#define INIT_SEC_DATA(id, name, flags, align) \
        { id, name, flags, align, NULL, NULL, NULL, 0, NULL }
static sinfo secdata[NSECS] =
{
  INIT_SEC_DATA (TEXT,   ".text",    TEXT_SEC_FLAGS,   2),
  INIT_SEC_DATA (DATA,   ".data",    DATA_SEC_FLAGS,   2),
  INIT_SEC_DATA (BSS,    ".bss",     BSS_SEC_FLAGS,    2),
  INIT_SEC_DATA (IDATA7, ".idata$7", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA5, ".idata$5", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA4, ".idata$4", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA6, ".idata$6", SEC_HAS_CONTENTS, 1)
};

#else

/* Sections numbered to make the order the same as other PowerPC NT
   compilers. This also keeps funny alignment thingies from happening.  */
#define TEXT   0
#define PDATA  1
#define RDATA  2
#define IDATA5 3
#define IDATA4 4
#define IDATA6 5
#define IDATA7 6
#define DATA   7
#define BSS    8

#define NSECS 9

static sinfo secdata[NSECS] =
{
  { TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 3},
  { PDATA,  ".pdata",   SEC_HAS_CONTENTS,            2},
  { RDATA,  ".reldata", SEC_HAS_CONTENTS,            2},
  { IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2},
  { IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2},
  { IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1},
  { IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2},
  { DATA,   ".data",    SEC_DATA,                    2},
  { BSS,    ".bss",     0,                           2}
};

#endif

/* This is what we're trying to make.  We generate the imp symbols with
   both single and double underscores, for compatibility.

	.text
	.global	_GetFileVersionInfoSizeW@@8
	.global	__imp_GetFileVersionInfoSizeW@@8
_GetFileVersionInfoSizeW@@8:
	jmp *	__imp_GetFileVersionInfoSizeW@@8
	.section	.idata$7	# To force loading of head
	.long	__version_a_head
# Import Address Table
	.section	.idata$5
__imp_GetFileVersionInfoSizeW@@8:
	.rva	ID2

# Import Lookup Table
	.section	.idata$4
	.rva	ID2
# Hint/Name table
	.section	.idata$6
ID2:	.short	2
	.asciz	"GetFileVersionInfoSizeW"


   For the PowerPC, here's the variation on the above scheme:

# Rather than a simple "jmp *", the code to get to the dll function
# looks like:
         .text
         lwz	r11,[tocv]__imp_function_name(r2)
#		   RELOC: 00000000 TOCREL16,TOCDEFN __imp_function_name
         lwz	r12,0(r11)
	 stw	r2,4(r1)
	 mtctr	r12
	 lwz	r2,4(r11)
	 bctr  */

static char *
make_label (prefix, name)
     const char *prefix;
     const char *name;
{
  int len = strlen (ASM_PREFIX) + strlen (prefix) + strlen (name);
  char *copy = xmalloc (len +1 );

  strcpy (copy, ASM_PREFIX);
  strcat (copy, prefix);
  strcat (copy, name);
  return copy;
}

static char *
make_imp_label (prefix, name)
     const char *prefix;
     const char *name;
{
  int len;
  char *copy;

  if (name[0] == '@@')
    {
      len = strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, name);
    }
  else
    {
      len = strlen (ASM_PREFIX) + strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, ASM_PREFIX);
      strcat (copy, name);
    }
  return copy;
}

static bfd *
make_one_lib_file (exp, i)
     export_type *exp;
     int i;
{
#if 0
    {
      char *name;
      FILE *f;
      const char *prefix = "d";
      char *dest;

      name = (char *) alloca (strlen (prefix) + 10);
      sprintf (name, "%ss%05d.s", prefix, i);
      f = fopen (name, FOPEN_WT);
      fprintf (f, "\t.text\n");
      fprintf (f, "\t%s\t%s%s\n", ASM_GLOBAL, ASM_PREFIX, exp->name);
      if (create_compat_implib)
	fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
      fprintf (f, "\t%s\t_imp__%s\n", ASM_GLOBAL, exp->name);
      if (create_compat_implib)
	fprintf (f, "%s%s:\n\t%s\t__imp_%s\n", ASM_PREFIX,
		 exp->name, ASM_JUMP, exp->name);

      fprintf (f, "\t.section\t.idata$7\t%s To force loading of head\n", ASM_C);
      fprintf (f, "\t%s\t%s\n", ASM_LONG, head_label);


      fprintf (f,"%s Import Address Table\n", ASM_C);

      fprintf (f, "\t.section	.idata$5\n");
      if (create_compat_implib)
	fprintf (f, "__imp_%s:\n", exp->name);
      fprintf (f, "_imp__%s:\n", exp->name);

      dump_iat (f, exp);

      fprintf (f, "\n%s Import Lookup Table\n", ASM_C);
      fprintf (f, "\t.section	.idata$4\n");

      dump_iat (f, exp);

      if(!exp->noname || show_allnames)
	{
	  fprintf (f, "%s Hint/Name table\n", ASM_C);
	  fprintf (f, "\t.section	.idata$6\n");
	  fprintf (f, "ID%d:\t%s\t%d\n", exp->ordinal, ASM_SHORT, exp->hint);
	  fprintf (f, "\t%s\t\"%s\"\n", ASM_TEXT, xlate (exp->name));
	}

      fclose (f);

      dest = (char *) alloca (strlen (prefix) + 10);
      sprintf (dest, "%ss%05d.o", prefix, i);
      assemble_file (name, dest);
    }
#else /* if 0 */
    {
      bfd *      abfd;
      asymbol *  exp_label;
      asymbol *  iname = 0;
      asymbol *  iname2;
      asymbol *  iname_lab;
      asymbol ** iname_lab_pp;
      asymbol ** iname_pp;
#ifdef DLLTOOL_PPC
      asymbol ** fn_pp;
      asymbol ** toc_pp;
#define EXTRA	 2
#endif
#ifndef EXTRA
#define EXTRA    0
#endif
      asymbol *  ptrs[NSECS + 4 + EXTRA + 1];
      flagword   applicable;

      char *     outname = xmalloc (10);
      int        oidx = 0;


      sprintf (outname, "%s%05d.o", TMP_STUB, i);

      abfd = bfd_openw (outname, HOW_BFD_WRITE_TARGET);

      if (!abfd)
	/* xgettext:c-format */
	fatal (_("bfd_open failed open stub file: %s"), outname);

      /* xgettext:c-format */
      inform (_("Creating stub file: %s"), outname);

      bfd_set_format (abfd, bfd_object);
      bfd_set_arch_mach (abfd, HOW_BFD_ARCH, 0);

#ifdef DLLTOOL_ARM
      if (machine == MARM_INTERWORK || machine == MTHUMB)
	bfd_set_private_flags (abfd, F_INTERWORK);
#endif

      applicable = bfd_applicable_section_flags (abfd);

      /* First make symbols for the sections.  */
      for (i = 0; i < NSECS; i++)
	{
	  sinfo *si = secdata + i;
	  if (si->id != i)
	    abort();
	  si->sec = bfd_make_section_old_way (abfd, si->name);
	  bfd_set_section_flags (abfd,
				 si->sec,
				 si->flags & applicable);

	  bfd_set_section_alignment(abfd, si->sec, si->align);
	  si->sec->output_section = si->sec;
	  si->sym = bfd_make_empty_symbol(abfd);
	  si->sym->name = si->sec->name;
	  si->sym->section = si->sec;
	  si->sym->flags = BSF_LOCAL;
	  si->sym->value = 0;
	  ptrs[oidx] = si->sym;
	  si->sympp = ptrs + oidx;
	  si->size = 0;
	  si->data = NULL;

	  oidx++;
	}

      if (! exp->data)
	{
	  exp_label = bfd_make_empty_symbol (abfd);
	  exp_label->name = make_imp_label ("", exp->name);

	  /* On PowerPC, the function name points to a descriptor in
	     the rdata section, the first element of which is a
	     pointer to the code (..function_name), and the second
	     points to the .toc.  */
#ifdef DLLTOOL_PPC
	  if (machine == MPPC)
	    exp_label->section = secdata[RDATA].sec;
	  else
#endif
	    exp_label->section = secdata[TEXT].sec;

	  exp_label->flags = BSF_GLOBAL;
	  exp_label->value = 0;

#ifdef DLLTOOL_ARM
	  if (machine == MTHUMB)
	    bfd_coff_set_symbol_class (abfd, exp_label, C_THUMBEXTFUNC);
#endif
	  ptrs[oidx++] = exp_label;
	}

      /* Generate imp symbols with one underscore for Microsoft
         compatibility, and with two underscores for backward
         compatibility with old versions of cygwin.  */
      if (create_compat_implib)
	{
	  iname = bfd_make_empty_symbol (abfd);
	  iname->name = make_imp_label ("___imp", exp->name);
	  iname->section = secdata[IDATA5].sec;
	  iname->flags = BSF_GLOBAL;
	  iname->value = 0;
	}

      iname2 = bfd_make_empty_symbol (abfd);
      iname2->name = make_imp_label ("__imp_", exp->name);
      iname2->section = secdata[IDATA5].sec;
      iname2->flags = BSF_GLOBAL;
      iname2->value = 0;

      iname_lab = bfd_make_empty_symbol(abfd);

      iname_lab->name = head_label;
      iname_lab->section = (asection *)&bfd_und_section;
      iname_lab->flags = 0;
      iname_lab->value = 0;

      iname_pp = ptrs + oidx;
      if (create_compat_implib)
	ptrs[oidx++] = iname;
      ptrs[oidx++] = iname2;

      iname_lab_pp = ptrs + oidx;
      ptrs[oidx++] = iname_lab;

#ifdef DLLTOOL_PPC
      /* The symbol refering to the code (.text).  */
      {
	asymbol *function_name;

	function_name = bfd_make_empty_symbol(abfd);
	function_name->name = make_label ("..", exp->name);
	function_name->section = secdata[TEXT].sec;
	function_name->flags = BSF_GLOBAL;
	function_name->value = 0;

	fn_pp = ptrs + oidx;
	ptrs[oidx++] = function_name;
      }

      /* The .toc symbol.  */
      {
	asymbol *toc_symbol;

	toc_symbol = bfd_make_empty_symbol (abfd);
	toc_symbol->name = make_label (".", "toc");
	toc_symbol->section = (asection *)&bfd_und_section;
	toc_symbol->flags = BSF_GLOBAL;
	toc_symbol->value = 0;

	toc_pp = ptrs + oidx;
	ptrs[oidx++] = toc_symbol;
      }
#endif

      ptrs[oidx] = 0;

      for (i = 0; i < NSECS; i++)
	{
	  sinfo *si = secdata + i;
	  asection *sec = si->sec;
	  arelent *rel;
	  arelent **rpp;

	  switch (i)
	    {
	    case TEXT:
	      if (! exp->data)
		{
		  si->size = HOW_JTAB_SIZE;
		  si->data = xmalloc (HOW_JTAB_SIZE);
		  memcpy (si->data, HOW_JTAB, HOW_JTAB_SIZE);

		  /* add the reloc into idata$5 */
		  rel = xmalloc (sizeof (arelent));

		  rpp = xmalloc (sizeof (arelent *) * 2);
		  rpp[0] = rel;
		  rpp[1] = 0;

		  rel->address = HOW_JTAB_ROFF;
		  rel->addend = 0;

		  if (machine == MPPC)
		    {
		      rel->howto = bfd_reloc_type_lookup (abfd,
							  BFD_RELOC_16_GOTOFF);
		      rel->sym_ptr_ptr = iname_pp;
		    }
		  else
		    {
		      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		      rel->sym_ptr_ptr = secdata[IDATA5].sympp;
		    }
		  sec->orelocation = rpp;
		  sec->reloc_count = 1;
		}
	      break;
	    case IDATA4:
	    case IDATA5:
	      /* An idata$4 or idata$5 is one word long, and has an
		 rva to idata$6.  */

	      si->data = xmalloc (4);
	      si->size = 4;

	      if (exp->noname)
		{
		  si->data[0] = exp->ordinal ;
		  si->data[1] = exp->ordinal >> 8;
		  si->data[2] = exp->ordinal >> 16;
		  si->data[3] = 0x80;
		}
	      else
		{
		  sec->reloc_count = 1;
		  memset (si->data, 0, si->size);
		  rel = xmalloc (sizeof (arelent));
		  rpp = xmalloc (sizeof (arelent *) * 2);
		  rpp[0] = rel;
		  rpp[1] = 0;
		  rel->address = 0;
		  rel->addend = 0;
		  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_RVA);
		  rel->sym_ptr_ptr = secdata[IDATA6].sympp;
		  sec->orelocation = rpp;
		}

	      break;

	    case IDATA6:
	      if (!exp->noname)
		{
		  /* This used to add 1 to exp->hint.  I don't know
                     why it did that, and it does not match what I see
                     in programs compiled with the MS tools.  */
		  int idx = exp->hint;
		  si->size = strlen (xlate (exp->name)) + 3;
		  si->data = xmalloc (si->size);
		  si->data[0] = idx & 0xff;
		  si->data[1] = idx >> 8;
		  strcpy (si->data + 2, xlate (exp->name));
		}
	      break;
	    case IDATA7:
	      si->size = 4;
	      si->data =xmalloc (4);
	      memset (si->data, 0, si->size);
	      rel = xmalloc (sizeof (arelent));
	      rpp = xmalloc (sizeof (arelent *) * 2);
	      rpp[0] = rel;
	      rel->address = 0;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_RVA);
	      rel->sym_ptr_ptr = iname_lab_pp;
	      sec->orelocation = rpp;
	      sec->reloc_count = 1;
	      break;

#ifdef DLLTOOL_PPC
	    case PDATA:
	      {
		/* The .pdata section is 5 words long.
		   Think of it as:
		   struct
		   {
		     bfd_vma BeginAddress,     [0x00]
		             EndAddress,       [0x04]
			     ExceptionHandler, [0x08]
			     HandlerData,      [0x0c]
			     PrologEndAddress; [0x10]
		   };  */

		/* So this pdata section setups up this as a glue linkage to
		   a dll routine. There are a number of house keeping things
		   we need to do:

		   1. In the name of glue trickery, the ADDR32 relocs for 0,
		      4, and 0x10 are set to point to the same place:
		      "..function_name".
		   2. There is one more reloc needed in the pdata section.
		      The actual glue instruction to restore the toc on
		      return is saved as the offset in an IMGLUE reloc.
		      So we need a total of four relocs for this section.

		   3. Lastly, the HandlerData field is set to 0x03, to indicate
		      that this is a glue routine.  */
		arelent *imglue, *ba_rel, *ea_rel, *pea_rel;

		/* Alignment must be set to 2**2 or you get extra stuff.  */
		bfd_set_section_alignment(abfd, sec, 2);

		si->size = 4 * 5;
		si->data = xmalloc (si->size);
		memset (si->data, 0, si->size);
		rpp = xmalloc (sizeof (arelent *) * 5);
		rpp[0] = imglue  = xmalloc (sizeof (arelent));
		rpp[1] = ba_rel  = xmalloc (sizeof (arelent));
		rpp[2] = ea_rel  = xmalloc (sizeof (arelent));
		rpp[3] = pea_rel = xmalloc (sizeof (arelent));
		rpp[4] = 0;

		/* Stick the toc reload instruction in the glue reloc.  */
		bfd_put_32(abfd, ppc_glue_insn, (char *) &imglue->address);

		imglue->addend = 0;
		imglue->howto = bfd_reloc_type_lookup (abfd,
						       BFD_RELOC_32_GOTOFF);
		imglue->sym_ptr_ptr = fn_pp;

		ba_rel->address = 0;
		ba_rel->addend = 0;
		ba_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		ba_rel->sym_ptr_ptr = fn_pp;

		bfd_put_32 (abfd, 0x18, si->data + 0x04);
		ea_rel->address = 4;
		ea_rel->addend = 0;
		ea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		ea_rel->sym_ptr_ptr = fn_pp;

		/* Mark it as glue.  */
		bfd_put_32 (abfd, 0x03, si->data + 0x0c);

		/* Mark the prolog end address.  */
		bfd_put_32 (abfd, 0x0D, si->data + 0x10);
		pea_rel->address = 0x10;
		pea_rel->addend = 0;
		pea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		pea_rel->sym_ptr_ptr = fn_pp;

		sec->orelocation = rpp;
		sec->reloc_count = 4;
		break;
	      }
	    case RDATA:
	      /* Each external function in a PowerPC PE file has a two word
		 descriptor consisting of:
		 1. The address of the code.
		 2. The address of the appropriate .toc
	         We use relocs to build this.  */
	      si->size = 8;
	      si->data = xmalloc (8);
	      memset (si->data, 0, si->size);

	      rpp = xmalloc (sizeof (arelent *) * 3);
	      rpp[0] = rel = xmalloc (sizeof (arelent));
	      rpp[1] = xmalloc (sizeof (arelent));
	      rpp[2] = 0;

	      rel->address = 0;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	      rel->sym_ptr_ptr = fn_pp;

	      rel = rpp[1];

	      rel->address = 4;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	      rel->sym_ptr_ptr = toc_pp;

	      sec->orelocation = rpp;
	      sec->reloc_count = 2;
	      break;
#endif /* DLLTOOL_PPC */
	    }
	}

      {
	bfd_vma vma = 0;
	/* Size up all the sections.  */
	for (i = 0; i < NSECS; i++)
	  {
	    sinfo *si = secdata + i;

	    bfd_set_section_size (abfd, si->sec, si->size);
	    bfd_set_section_vma (abfd, si->sec, vma);

/*	    vma += si->size;*/
	  }
      }
      /* Write them out.  */
      for (i = 0; i < NSECS; i++)
	{
	  sinfo *si = secdata + i;

	  if (i == IDATA5 && no_idata5)
	    continue;

	  if (i == IDATA4 && no_idata4)
	    continue;

	  bfd_set_section_contents (abfd, si->sec,
				    si->data, 0,
				    si->size);
	}

      bfd_set_symtab (abfd, ptrs, oidx);
      bfd_close (abfd);
      abfd = bfd_openr (outname, HOW_BFD_READ_TARGET);
      return abfd;
    }
#endif
}

static bfd *
make_head ()
{
  FILE *f = fopen (TMP_HEAD_S, FOPEN_WT);

  if (f == NULL)
    {
      fatal (_("failed to open temporary head file: %s"), TMP_HEAD_S);
      return NULL;
    }

  fprintf (f, "%s IMAGE_IMPORT_DESCRIPTOR\n", ASM_C);
  fprintf (f, "\t.section	.idata$2\n");

  fprintf(f,"\t%s\t%s\n", ASM_GLOBAL,head_label);

  fprintf (f, "%s:\n", head_label);

  fprintf (f, "\t%shname%s\t%sPtr to image import by name list\n",
	   ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

  fprintf (f, "\t%sthis should be the timestamp, but NT sometimes\n", ASM_C);
  fprintf (f, "\t%sdoesn't load DLLs when this is set.\n", ASM_C);
  fprintf (f, "\t%s\t0\t%s loaded time\n", ASM_LONG, ASM_C);
  fprintf (f, "\t%s\t0\t%s Forwarder chain\n", ASM_LONG, ASM_C);
  fprintf (f, "\t%s__%s_iname%s\t%s imported dll's name\n",
	   ASM_RVA_BEFORE,
	   imp_name_lab,
	   ASM_RVA_AFTER,
	   ASM_C);
  fprintf (f, "\t%sfthunk%s\t%s pointer to firstthunk\n",
	   ASM_RVA_BEFORE,
	   ASM_RVA_AFTER, ASM_C);

  fprintf (f, "%sStuff for compatibility\n", ASM_C);

  if (!no_idata5)
    {
      fprintf (f, "\t.section\t.idata$5\n");
      fprintf (f, "\t%s\t0\n", ASM_LONG);
      fprintf (f, "fthunk:\n");
    }

  if (!no_idata4)
    {
      fprintf (f, "\t.section\t.idata$4\n");

      fprintf (f, "\t%s\t0\n", ASM_LONG);
      fprintf (f, "\t.section	.idata$4\n");
      fprintf (f, "hname:\n");
    }

  fclose (f);

  assemble_file (TMP_HEAD_S, TMP_HEAD_O);

  return bfd_openr (TMP_HEAD_O, HOW_BFD_READ_TARGET);
}

static bfd *
make_tail ()
{
  FILE *f = fopen (TMP_TAIL_S, FOPEN_WT);

  if (f == NULL)
    {
      fatal (_("failed to open temporary tail file: %s"), TMP_TAIL_S);
      return NULL;
    }

  if (!no_idata4)
    {
      fprintf (f, "\t.section	.idata$4\n");
      fprintf (f, "\t%s\t0\n", ASM_LONG);
    }

  if (!no_idata5)
    {
      fprintf (f, "\t.section	.idata$5\n");
      fprintf (f, "\t%s\t0\n", ASM_LONG);
    }

#ifdef DLLTOOL_PPC
  /* Normally, we need to see a null descriptor built in idata$3 to
     act as the terminator for the list. The ideal way, I suppose,
     would be to mark this section as a comdat type 2 section, so
     only one would appear in the final .exe (if our linker supported
     comdat, that is) or cause it to be inserted by something else (say
     crt0).  */

  fprintf (f, "\t.section	.idata$3\n");
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
#endif

#ifdef DLLTOOL_PPC
  /* Other PowerPC NT compilers use idata$6 for the dllname, so I
     do too. Original, huh?  */
  fprintf (f, "\t.section	.idata$6\n");
#else
  fprintf (f, "\t.section	.idata$7\n");
#endif

  fprintf (f, "\t%s\t__%s_iname\n", ASM_GLOBAL, imp_name_lab);
  fprintf (f, "__%s_iname:\t%s\t\"%s\"\n",
	   imp_name_lab, ASM_TEXT, dll_name);

  fclose (f);

  assemble_file (TMP_TAIL_S, TMP_TAIL_O);

  return bfd_openr (TMP_TAIL_O, HOW_BFD_READ_TARGET);
}

static void
gen_lib_file ()
{
  int i;
  export_type *exp;
  bfd *ar_head;
  bfd *ar_tail;
  bfd *outarch;
  bfd * head  = 0;

  unlink (imp_name);

  outarch = bfd_openw (imp_name, HOW_BFD_WRITE_TARGET);

  if (!outarch)
    /* xgettext:c-format */
    fatal (_("Can't open .lib file: %s"), imp_name);

  /* xgettext:c-format */
  inform (_("Creating library file: %s"), imp_name);

  bfd_set_format (outarch, bfd_archive);
  outarch->has_armap = 1;

  /* Work out a reasonable size of things to put onto one line.  */
  ar_head = make_head ();
  ar_tail = make_tail();

  if (ar_head == NULL || ar_tail == NULL)
    return;

  for (i = 0; (exp = d_exports_lexically[i]); i++)
    {
      bfd *n = make_one_lib_file (exp, i);
      n->next = head;
      head = n;
    }

  /* Now stick them all into the archive.  */
  ar_head->next = head;
  ar_tail->next = ar_head;
  head = ar_tail;

  if (! bfd_set_archive_head (outarch, head))
    bfd_fatal ("bfd_set_archive_head");

  if (! bfd_close (outarch))
    bfd_fatal (imp_name);

  while (head != NULL)
    {
      bfd *n = head->next;
      bfd_close (head);
      head = n;
    }

  /* Delete all the temp files.  */
  if (dontdeltemps == 0)
    {
      unlink (TMP_HEAD_O);
      unlink (TMP_HEAD_S);
      unlink (TMP_TAIL_O);
      unlink (TMP_TAIL_S);
    }

  if (dontdeltemps < 2)
    {
      char *name;

      name = (char *) alloca (sizeof TMP_STUB + 10);
      for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
	{
	  sprintf (name, "%s%05d.o", TMP_STUB, i);
	  if (unlink (name) < 0)
	    /* xgettext:c-format */
	    non_fatal (_("cannot delete %s: %s"), name, strerror (errno));
	}
    }

  inform (_("Created lib file"));
}

/**********************************************************************/

/* Run through the information gathered from the .o files and the
   .def file and work out the best stuff.  */
static int
pfunc (a, b)
     const void *a;
     const void *b;
{
  export_type *ap = *(export_type **) a;
  export_type *bp = *(export_type **) b;
  if (ap->ordinal == bp->ordinal)
    return 0;

  /* Unset ordinals go to the bottom.  */
  if (ap->ordinal == -1)
    return 1;
  if (bp->ordinal == -1)
    return -1;
  return (ap->ordinal - bp->ordinal);
}

static int
nfunc (a, b)
     const void *a;
     const void *b;
{
  export_type *ap = *(export_type **) a;
  export_type *bp = *(export_type **) b;

  return (strcmp (ap->name, bp->name));
}

static void
remove_null_names (ptr)
     export_type **ptr;
{
  int src;
  int dst;

  for (dst = src = 0; src < d_nfuncs; src++)
    {
      if (ptr[src])
	{
	  ptr[dst] = ptr[src];
	  dst++;
	}
    }
  d_nfuncs = dst;
}

static void
dtab (ptr)
     export_type ** ptr
#ifndef SACDEBUG
ATTRIBUTE_UNUSED
#endif
     ;
{
#ifdef SACDEBUG
  int i;
  for (i = 0; i < d_nfuncs; i++)
    {
      if (ptr[i])
	{
	  printf ("%d %s @@ %d %s%s%s\n",
		  i, ptr[i]->name, ptr[i]->ordinal,
		  ptr[i]->noname ? "NONAME " : "",
		  ptr[i]->constant ? "CONSTANT" : "",
		  ptr[i]->data ? "DATA" : "");
	}
      else
	printf ("empty\n");
    }
#endif
}

static void
process_duplicates (d_export_vec)
     export_type **d_export_vec;
{
  int more = 1;
  int i;

  while (more)
    {

      more = 0;
      /* Remove duplicates.  */
      qsort (d_export_vec, d_nfuncs, sizeof (export_type *), nfunc);

      dtab (d_export_vec);
      for (i = 0; i < d_nfuncs - 1; i++)
	{
	  if (strcmp (d_export_vec[i]->name,
		      d_export_vec[i + 1]->name) == 0)
	    {

	      export_type *a = d_export_vec[i];
	      export_type *b = d_export_vec[i + 1];

	      more = 1;

	      /* xgettext:c-format */
	      inform (_("Warning, ignoring duplicate EXPORT %s %d,%d"),
		      a->name, a->ordinal, b->ordinal);

	      if (a->ordinal != -1
		  && b->ordinal != -1)
		/* xgettext:c-format */
		fatal (_("Error, duplicate EXPORT with oridinals: %s"),
		      a->name);

	      /* Merge attributes.  */
	      b->ordinal = a->ordinal > 0 ? a->ordinal : b->ordinal;
	      b->constant |= a->constant;
	      b->noname |= a->noname;
	      b->data |= a->data;
	      d_export_vec[i] = 0;
	    }

	  dtab (d_export_vec);
	  remove_null_names (d_export_vec);
	  dtab (d_export_vec);
	}
    }


  /* Count the names.  */
  for (i = 0; i < d_nfuncs; i++)
    {
      if (!d_export_vec[i]->noname)
	d_named_nfuncs++;
    }
}

static void
fill_ordinals (d_export_vec)
     export_type **d_export_vec;
{
  int lowest = -1;
  int i;
  char *ptr;
  int size = 65536;

  qsort (d_export_vec, d_nfuncs, sizeof (export_type *), pfunc);

  /* Fill in the unset ordinals with ones from our range.  */
  ptr = (char *) xmalloc (size);

  memset (ptr, 0, size);

  /* Mark in our large vector all the numbers that are taken.  */
  for (i = 0; i < d_nfuncs; i++)
    {
      if (d_export_vec[i]->ordinal != -1)
	{
	  ptr[d_export_vec[i]->ordinal] = 1;

	  if (lowest == -1 || d_export_vec[i]->ordinal < lowest)
	    lowest = d_export_vec[i]->ordinal;
	}
    }

  /* Start at 1 for compatibility with MS toolchain.  */
  if (lowest == -1)
    lowest = 1;

  /* Now fill in ordinals where the user wants us to choose.  */
  for (i = 0; i < d_nfuncs; i++)
    {
      if (d_export_vec[i]->ordinal == -1)
	{
	  register int j;

	  /* First try within or after any user supplied range.  */
	  for (j = lowest; j < size; j++)
	    if (ptr[j] == 0)
	      {
		ptr[j] = 1;
		d_export_vec[i]->ordinal = j;
		goto done;
	      }

	  /* Then try before the range.  */
	  for (j = lowest; j >0; j--)
	    if (ptr[j] == 0)
	      {
		ptr[j] = 1;
		d_export_vec[i]->ordinal = j;
		goto done;
	      }
	done:;
	}
    }

  free (ptr);

  /* And resort.  */
  qsort (d_export_vec, d_nfuncs, sizeof (export_type *), pfunc);

  /* Work out the lowest and highest ordinal numbers.  */
  if (d_nfuncs)
    {
      if (d_export_vec[0])
	d_low_ord = d_export_vec[0]->ordinal;
      if (d_export_vec[d_nfuncs-1])
	d_high_ord = d_export_vec[d_nfuncs-1]->ordinal;
    }
}

static int
alphafunc (av,bv)
     const void *av;
     const void *bv;
{
  const export_type **a = (const export_type **) av;
  const export_type **b = (const export_type **) bv;

  return strcmp ((*a)->name, (*b)->name);
}

static void
mangle_defs ()
{
  /* First work out the minimum ordinal chosen.  */
  export_type *exp;

  int i;
  int hint = 0;
  export_type **d_export_vec
  = (export_type **) xmalloc (sizeof (export_type *) * d_nfuncs);

  inform (_("Processing definitions"));

  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    d_export_vec[i] = exp;

  process_duplicates (d_export_vec);
  fill_ordinals (d_export_vec);

  /* Put back the list in the new order.  */
  d_exports = 0;
  for (i = d_nfuncs - 1; i >= 0; i--)
    {
      d_export_vec[i]->next = d_exports;
      d_exports = d_export_vec[i];
    }

  /* Build list in alpha order.  */
  d_exports_lexically = (export_type **)
    xmalloc (sizeof (export_type *) * (d_nfuncs + 1));

  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    d_exports_lexically[i] = exp;

  d_exports_lexically[i] = 0;

  qsort (d_exports_lexically, i, sizeof (export_type *), alphafunc);

  /* Fill exp entries with their hint values.  */
  for (i = 0; i < d_nfuncs; i++)
    if (!d_exports_lexically[i]->noname || show_allnames)
      d_exports_lexically[i]->hint = hint++;

  inform (_("Processed definitions"));
}

/**********************************************************************/

static void
usage (file, status)
     FILE *file;
     int status;
{
  /* xgetext:c-format */
  fprintf (file, _("Usage %s <option(s)> <object-file(s)>\n"), program_name);
  /* xgetext:c-format */
  fprintf (file, _("   -m --machine <machine>    Create as DLL for <machine>.  [default: %s]\n"), mname);
  fprintf (file, _("        possible <machine>: arm[_interwork], i386, mcore[-elf]{-le|-be}, ppc, thumb\n"));
  fprintf (file, _("   -e --output-exp <outname> Generate an export file.\n"));
  fprintf (file, _("   -l --output-lib <outname> Generate an interface library.\n"));
  fprintf (file, _("   -a --add-indirect         Add dll indirects to export file.\n"));
  fprintf (file, _("   -D --dllname <name>       Name of input dll to put into interface lib.\n"));
  fprintf (file, _("   -d --input-def <deffile>  Name of .def file to be read in.\n"));
  fprintf (file, _("   -z --output-def <deffile> Name of .def file to be created.\n"));
  fprintf (file, _("      --export-all-symbols   Export all symbols to .def\n"));
  fprintf (file, _("      --no-export-all-symbols  Only export listed symbols\n"));
  fprintf (file, _("      --exclude-symbols <list> Don't export <list>\n"));
  fprintf (file, _("      --no-default-excludes  Clear default exclude symbols\n"));
  fprintf (file, _("   -b --base-file <basefile> Read linker generated base file.\n"));
  fprintf (file, _("   -x --no-idata4            Don't generate idata$4 section.\n"));
  fprintf (file, _("   -c --no-idata5            Don't generate idata$5 section.\n"));
  fprintf (file, _("   -U --add-underscore       Add underscores to symbols in interface library.\n"));
  fprintf (file, _("   -k --kill-at              Kill @@<n> from exported names.\n"));
  fprintf (file, _("   -A --add-stdcall-alias    Add aliases without @@<n>.\n"));
  fprintf (file, _("   -S --as <name>            Use <name> for assembler.\n"));
  fprintf (file, _("   -f --as-flags <flags>     Pass <flags> to the assembler.\n"));
  fprintf (file, _("   -C --compat-implib        Create backward compatible import library.\n"));
  fprintf (file, _("   -n --no-delete            Keep temp files (repeat for extra preservation).\n"));
  fprintf (file, _("   -v --verbose              Be verbose.\n"));
  fprintf (file, _("   -V --version              Display the program version.\n"));
  fprintf (file, _("   -h --help                 Display this information.\n"));
#ifdef DLLTOOL_MCORE_ELF
  fprintf (file, _("   -M --mcore-elf <outname>  Process mcore-elf object files into <outname>.\n"));
  fprintf (file, _("   -L --linker <name>        Use <name> as the linker.\n"));
  fprintf (file, _("   -F --linker-flags <flags> Pass <flags> to the linker.\n"));
#endif
  exit (status);
}

#define OPTION_EXPORT_ALL_SYMS		150
#define OPTION_NO_EXPORT_ALL_SYMS	(OPTION_EXPORT_ALL_SYMS + 1)
#define OPTION_EXCLUDE_SYMS		(OPTION_NO_EXPORT_ALL_SYMS + 1)
#define OPTION_NO_DEFAULT_EXCLUDES	(OPTION_EXCLUDE_SYMS + 1)

static const struct option long_options[] =
{
  {"no-delete", no_argument, NULL, 'n'},
  {"dllname", required_argument, NULL, 'D'},
  {"no-idata4", no_argument, NULL, 'x'},
  {"no-idata5", no_argument, NULL, 'c'},
  {"output-exp", required_argument, NULL, 'e'},
  {"output-def", required_argument, NULL, 'z'},
  {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL_SYMS},
  {"no-export-all-symbols", no_argument, NULL, OPTION_NO_EXPORT_ALL_SYMS},
  {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMS},
  {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
  {"output-lib", required_argument, NULL, 'l'},
  {"def", required_argument, NULL, 'd'}, /* for compatiblity with older versions */
  {"input-def", required_argument, NULL, 'd'},
  {"add-underscore", no_argument, NULL, 'U'},
  {"kill-at", no_argument, NULL, 'k'},
  {"add-stdcall-alias", no_argument, NULL, 'A'},
  {"verbose", no_argument, NULL, 'v'},
  {"version", no_argument, NULL, 'V'},
  {"help", no_argument, NULL, 'h'},
  {"machine", required_argument, NULL, 'm'},
  {"add-indirect", no_argument, NULL, 'a'},
  {"base-file", required_argument, NULL, 'b'},
  {"as", required_argument, NULL, 'S'},
  {"as-flags", required_argument, NULL, 'f'},
  {"mcore-elf", required_argument, NULL, 'M'},
  {"compat-implib", no_argument, NULL, 'C'},
  {"temp-prefix", required_argument, NULL, 't'},
  {NULL,0,NULL,0}
};

int main PARAMS ((int, char **));

int
main (ac, av)
     int ac;
     char **av;
{
  int c;
  int i;
  char *firstarg = 0;
  program_name = av[0];
  oav = av;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  while ((c = getopt_long (ac, av,
#ifdef DLLTOOL_MCORE_ELF
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHhM:L:F:",
#else
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHh",
#endif
			   long_options, 0))
	 != EOF)
    {
      switch (c)
	{
	case OPTION_EXPORT_ALL_SYMS:
	  export_all_symbols = TRUE;
	  break;
	case OPTION_NO_EXPORT_ALL_SYMS:
	  export_all_symbols = FALSE;
	  break;
	case OPTION_EXCLUDE_SYMS:
	  add_excludes (optarg);
	  break;
	case OPTION_NO_DEFAULT_EXCLUDES:
	  do_default_excludes = FALSE;
	  break;
	case 'x':
	  no_idata4 = 1;
	  break;
	case 'c':
	  no_idata5 = 1;
	  break;
	case 'S':
	  as_name = optarg;
	  break;
	case 't':
	  tmp_prefix = optarg;
	  break;
	case 'f':
	  as_flags = optarg;
	  break;

	  /* ignored for compatibility */
	case 'u':
	  break;
	case 'a':
	  add_indirect = 1;
	  break;
	case 'z':
	  output_def = fopen (optarg, FOPEN_WT);
	  break;
	case 'D':
	  dll_name = optarg;
	  break;
	case 'l':
	  imp_name = optarg;
	  break;
	case 'e':
	  exp_name = optarg;
	  break;
	case 'H':
	case 'h':
	  usage (stdout, 0);
	  break;
	case 'm':
	  mname = optarg;
	  break;
	case 'v':
	  verbose = 1;
	  break;
	case 'V':
	  print_version (program_name);
	  break;
	case 'U':
	  add_underscore = 1;
	  break;
	case 'k':
	  killat = 1;
	  break;
	case 'A':
	  add_stdcall_alias = 1;
	  break;
	case 'd':
	  def_file = optarg;
	  break;
	case 'n':
	  dontdeltemps++;
	  break;
	case 'b':
	  base_file = fopen (optarg, FOPEN_RB);

	  if (!base_file)
	    /* xgettext:c-format */
	    fatal (_("Unable to open base-file: %s"), optarg);

	  break;
#ifdef DLLTOOL_MCORE_ELF
	case 'M':
	  mcore_elf_out_file = optarg;
	  break;
	case 'L':
	  mcore_elf_linker = optarg;
	  break;
	case 'F':
	  mcore_elf_linker_flags = optarg;
	  break;
#endif
	case 'C':
	  create_compat_implib = 1;
	  break;
	default:
	  usage (stderr, 1);
	  break;
	}
    }

  for (i = 0; mtable[i].type; i++)
    if (strcmp (mtable[i].type, mname) == 0)
      break;

  if (!mtable[i].type)
    /* xgettext:c-format */
    fatal (_("Machine '%s' not supported"), mname);

  machine = i;

  if (!dll_name && exp_name)
    {
      int len = strlen (exp_name) + 5;
      dll_name = xmalloc (len);
      strcpy (dll_name, exp_name);
      strcat (dll_name, ".dll");
    }

  if (as_name == NULL)
    as_name = deduce_name ("as");

  /* Don't use the default exclude list if we're reading only the
     symbols in the .drectve section.  The default excludes are meant
     to avoid exporting DLL entry point and Cygwin32 impure_ptr.  */
  if (! export_all_symbols)
    do_default_excludes = FALSE;

  if (do_default_excludes)
    set_default_excludes ();

  if (def_file)
    process_def_file (def_file);

  while (optind < ac)
    {
      if (!firstarg)
	firstarg = av[optind];
      scan_obj_file (av[optind]);
      optind++;
    }

  mangle_defs ();

  if (exp_name)
    gen_exp_file ();

  if (imp_name)
    {
      /* Make imp_name safe for use as a label.  */
      char *p;

      imp_name_lab = xstrdup (imp_name);
      for (p = imp_name_lab; *p; p++)
	{
	  if (!ISALNUM (*p))
	    *p = '_';
	}
      head_label = make_label("_head_", imp_name_lab);
      gen_lib_file ();
    }

  if (output_def)
    gen_def_file ();

#ifdef DLLTOOL_MCORE_ELF
  if (mcore_elf_out_file)
    mcore_elf_gen_out_file ();
#endif

  return 0;
}

/* Look for the program formed by concatenating PROG_NAME and the
   string running from PREFIX to END_PREFIX.  If the concatenated
   string contains a '/', try appending EXECUTABLE_SUFFIX if it is
   appropriate.  */

static char *
look_for_prog (prog_name, prefix, end_prefix)
     const char *prog_name;
     const char *prefix;
     int end_prefix;
{
  struct stat s;
  char *cmd;

  cmd = xmalloc (strlen (prefix)
		 + strlen (prog_name)
#ifdef HAVE_EXECUTABLE_SUFFIX
		 + strlen (EXECUTABLE_SUFFIX)
#endif
		 + 10);
  strcpy (cmd, prefix);

  sprintf (cmd + end_prefix, "%s", prog_name);

  if (strchr (cmd, '/') != NULL)
    {
      int found;

      found = (stat (cmd, &s) == 0
#ifdef HAVE_EXECUTABLE_SUFFIX
	       || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
#endif
	       );

      if (! found)
	{
	  /* xgettext:c-format */
	  inform (_("Tried file: %s"), cmd);
	  free (cmd);
	  return NULL;
	}
    }

  /* xgettext:c-format */
  inform (_("Using file: %s"), cmd);

  return cmd;
}

/* Deduce the name of the program we are want to invoke.
   PROG_NAME is the basic name of the program we want to run,
   eg "as" or "ld".  The catch is that we might want actually
   run "i386-pe-as" or "ppc-pe-ld".

   If argv[0] contains the full path, then try to find the program
   in the same place, with and then without a target-like prefix.

   Given, argv[0] = /usr/local/bin/i586-cygwin32-dlltool,
   deduce_name("as") uses the following search order:

     /usr/local/bin/i586-cygwin32-as
     /usr/local/bin/as
     as

   If there's an EXECUTABLE_SUFFIX, it'll use that as well; for each
   name, it'll try without and then with EXECUTABLE_SUFFIX.

   Given, argv[0] = i586-cygwin32-dlltool, it will not even try "as"
   as the fallback, but rather return i586-cygwin32-as.

   Oh, and given, argv[0] = dlltool, it'll return "as".

   Returns a dynamically allocated string.  */

static char *
deduce_name (prog_name)
     const char *prog_name;
{
  char *cmd;
  char *dash, *slash, *cp;

  dash = NULL;
  slash = NULL;
  for (cp = program_name; *cp != '\0'; ++cp)
    {
      if (*cp == '-')
	dash = cp;
      if (
#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__)
	  *cp == ':' || *cp == '\\' ||
#endif
	  *cp == '/')
	{
	  slash = cp;
	  dash = NULL;
	}
    }

  cmd = NULL;

  if (dash != NULL)
    {
      /* First, try looking for a prefixed PROG_NAME in the
         PROGRAM_NAME directory, with the same prefix as PROGRAM_NAME.  */
      cmd = look_for_prog (prog_name, program_name, dash - program_name + 1);
    }

  if (slash != NULL && cmd == NULL)
    {
      /* Next, try looking for a PROG_NAME in the same directory as
         that of this program.  */
      cmd = look_for_prog (prog_name, program_name, slash - program_name + 1);
    }

  if (cmd == NULL)
    {
      /* Just return PROG_NAME as is.  */
      cmd = xstrdup (prog_name);
    }

  return cmd;
}

#ifdef DLLTOOL_MCORE_ELF
typedef struct fname_cache
{
  char *               filename;
  struct fname_cache * next;
}
fname_cache;

static fname_cache fnames;

static void
mcore_elf_cache_filename (char * filename)
{
  fname_cache * ptr;

  ptr = & fnames;

  while (ptr->next != NULL)
    ptr = ptr->next;

  ptr->filename = filename;
  ptr->next     = (fname_cache *) malloc (sizeof (fname_cache));
  if (ptr->next != NULL)
    ptr->next->next = NULL;
}

#define MCORE_ELF_TMP_OBJ "mcoreelf.o"
#define MCORE_ELF_TMP_EXP "mcoreelf.exp"
#define MCORE_ELF_TMP_LIB "mcoreelf.lib"

static void
mcore_elf_gen_out_file (void)
{
  fname_cache * ptr;
  dyn_string_t ds;

  /* Step one.  Run 'ld -r' on the input object files in order to resolve
     any internal references and to generate a single .exports section.  */
  ptr = & fnames;

  ds = dyn_string_new (100);
  dyn_string_append_cstr (ds, "-r ");

  if (mcore_elf_linker_flags != NULL)
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);

  while (ptr->next != NULL)
    {
      dyn_string_append_cstr (ds, ptr->filename);
      dyn_string_append_cstr (ds, " ");

      ptr = ptr->next;
    }

  dyn_string_append_cstr (ds, "-o ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);

  if (mcore_elf_linker == NULL)
    mcore_elf_linker = deduce_name ("ld");

  run (mcore_elf_linker, ds->s);

  dyn_string_delete (ds);

  /* Step two. Create a .exp file and a .lib file from the temporary file.
     Do this by recursively invoking dlltool...  */
  ds = dyn_string_new (100);

  dyn_string_append_cstr (ds, "-S ");
  dyn_string_append_cstr (ds, as_name);

  dyn_string_append_cstr (ds, " -e ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " -l ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_LIB);
  dyn_string_append_cstr (ds, " " );
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);

  if (verbose)
    dyn_string_append_cstr (ds, " -v");

  if (dontdeltemps)
    {
      dyn_string_append_cstr (ds, " -n");

      if (dontdeltemps > 1)
	dyn_string_append_cstr (ds, " -n");
    }

  /* XXX - FIME: ought to check/copy other command line options as well.  */
  run (program_name, ds->s);

  dyn_string_delete (ds);

  /* Step four. Feed the .exp and object files to ld -shared to create the dll.  */
  ds = dyn_string_new (100);

  dyn_string_append_cstr (ds, "-shared ");

  if (mcore_elf_linker_flags)
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);

  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
  dyn_string_append_cstr (ds, " -o ");
  dyn_string_append_cstr (ds, mcore_elf_out_file);

  run (mcore_elf_linker, ds->s);

  dyn_string_delete (ds);

  if (dontdeltemps == 0)
    unlink (MCORE_ELF_TMP_EXP);

  if (dontdeltemps < 2)
    unlink (MCORE_ELF_TMP_OBJ);
}
#endif /* DLLTOOL_MCORE_ELF */
@


1.2
log
@looks as if some sour wine (Federweier <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
d23 1
a23 2
/*
   This program allows you to build the files necessary to create
d50 3
a52 1
   EXPORTS  ( <name1> [ = <name2> ] [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] ) *
d54 3
a56 1
   DLL, with optional ordinal number <integer>
d117 1
a117 1
   
d164 1
a164 1
 
d168 1
a168 1
 
d172 1
a172 1
 
d182 1
a182 1
 
d187 1
a187 1
 
d192 1
a192 1
 
d196 2
a197 3
 
   ld -o thedll.dll thedll.exp file1.o file2.o
 */
d233 1
a233 2
   .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc)
*/
d253 1
a254 1
#include <ctype.h>
d270 4
a273 2
static char *look_for_prog PARAMS ((const char *, const char *, int));
static char *deduce_name PARAMS ((const char *));
d276 4
a279 2
static void mcore_elf_cache_filename (char *);
static void mcore_elf_gen_out_file (void);
d281 1
a281 1
     
d287 1
a287 1
#define WIFEXITED(w)	(((w)&0377) == 0)
d290 1
a290 1
#define WIFSIGNALED(w)	(((w)&0377) != 0177 && ((w)&~0377) == 0)
d331 2
a332 2
  char          *name;   /* name of function being imported */
  int            ord;    /* two-byte ordinal value associated with function */
d338 5
a342 5
  char          *dllname;  /* name of dll file imported from */
  long           nfuncs;   /* number of functions in list */
  struct ifunct *funchead; /* first function in list */
  struct ifunct *functail; /* last  function in list */
  struct iheadt *next;     /* next dll file in list */
d353 2
d367 1
a367 1
/* True if we should export all symbols.  Otherwise, we only export
d369 1
a369 1
static boolean export_all_symbols;
d371 1
a371 1
/* True if we should exclude the symbols in DEFAULT_EXCLUDES when
d373 1
a373 1
static boolean do_default_excludes;
d378 1
a378 1
/* True if we should add __imp_<SYMBOL> to import libraries for backward 
d380 1
a380 1
static boolean create_compat_implib;
d434 1
a434 1
#define PATHMAX 250		/* What's the right name for this ? */
d436 13
a448 6
#define TMP_ASM		"dc.s"
#define TMP_HEAD_S	"dh.s"
#define TMP_HEAD_O	"dh.o"
#define TMP_TAIL_S	"dt.s"
#define TMP_TAIL_O	"dt.o"
#define TMP_STUB	"ds"
d450 1
a450 1
/* This bit of assemly does jmp * .... */
d485 1
a485 1
  0x81, 0x01,            /* ld.w r1,(r1,0) */  
d488 1
a488 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */  
d494 1
a494 1
  0x01, 0x81,            /* ld.w r1,(r1,0) */  
d497 1
a497 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */  
d500 5
a504 5
/* This is the glue sequence for PowerPC PE. There is a  */
/* tocrel16-tocdefn reloc against the first instruction. */
/* We also need a IMGLUE reloc against the glue function */
/* to restore the toc saved by the third instruction in  */
/* the glue. */
d517 2
a518 2
/* the glue instruction, picks up the toc from the stw in */
/* the above code: "lwz r2,4(r1)"                         */
d539 2
a540 2
    int how_jtab_size; /* size of the jtab entry */
    int how_jtab_roff; /* offset into it for the ind 32 reloc into idata 5 */
d653 1
d659 1
a659 1
 
d668 48
a715 21
static const char *rvaafter PARAMS ((int));
static const char *rvabefore PARAMS ((int));
static const char *asm_prefix PARAMS ((int));
static void append_import PARAMS ((const char *, const char *, int));
static void run PARAMS ((const char *, char *));
static void scan_drectve_symbols PARAMS ((bfd *));
static void scan_filtered_symbols PARAMS ((bfd *, PTR, long, unsigned int));
static void add_excludes PARAMS ((const char *));
static boolean match_exclude PARAMS ((const char *));
static void set_default_excludes PARAMS ((void));
static long filter_symbols PARAMS ((bfd *, PTR, long, unsigned int));
static void scan_all_symbols PARAMS ((bfd *));
static void scan_open_obj_file PARAMS ((bfd *));
static void scan_obj_file PARAMS ((const char *));
static void dump_def_info PARAMS ((FILE *));
static int sfunc PARAMS ((const void *, const void *));
static void flush_page PARAMS ((FILE *, long *, int, int));
static void gen_def_file PARAMS ((void));
static void generate_idata_ofile PARAMS ((FILE *));
static void gen_exp_file PARAMS ((void));
static const char *xlate PARAMS ((const char *));
d717 2
a718 1
static void dump_iat PARAMS ((FILE *, export_type *));
d720 32
a751 15
static char *make_label PARAMS ((const char *, const char *));
static bfd *make_one_lib_file PARAMS ((export_type *, int));
static bfd *make_head PARAMS ((void));
static bfd *make_tail PARAMS ((void));
static void gen_lib_file PARAMS ((void));
static int pfunc PARAMS ((const void *, const void *));
static int nfunc PARAMS ((const void *, const void *));
static void remove_null_names PARAMS ((export_type **));
static void dtab PARAMS ((export_type **));
static void process_duplicates PARAMS ((export_type **));
static void fill_ordinals PARAMS ((export_type **));
static int alphafunc PARAMS ((const void *, const void *));
static void mangle_defs PARAMS ((void));
static void usage PARAMS ((FILE *, int));
static void inform PARAMS ((const char *, ...));
d753 8
d763 1
a763 7
#ifdef __STDC__
inform (const char * message, ...)
#else
inform (message, va_alist)
     const char * message;
     va_dcl
#endif
d765 3
a767 2
  va_list args;
  
d771 1
a771 5
#ifdef __STDC__
  va_start (args, message);
#else
  va_start (args);
#endif
d773 1
a773 3
  report (message, args);
  
  va_end (args);
d875 1
a875 1
void
d880 1
a880 1
  
d889 1
a889 1
  
d897 1
a897 1
/* Communications with the parser */
d899 10
a908 9
static const char *d_name;	/* Arg to NAME or LIBRARY */
static int d_nfuncs;		/* Number of functions exported */
static int d_named_nfuncs;	/* Number of named functions exported */
static int d_low_ord;		/* Lowest ordinal index */
static int d_high_ord;		/* Highest ordinal index */
static export_type *d_exports;	/*list of exported functions */
static export_type **d_exports_lexically;	/* vector of exported functions in alpha order */
static dlist_type *d_list;	/* Descriptions */
static dlist_type *a_list;	/* Stuff to go in directives */
d919 1
a919 1
  
d943 6
d958 1
a958 1
  
d961 1
a961 1
  
d963 2
a964 2
  /* if --dllname not provided, use the one in the DEF file.
     FIXME: Is this appropriate for executables? */
d977 1
a977 1
  
d980 1
a980 1
  
d982 1
a982 1
  /* if --dllname not provided, use the one in the DEF file. */
d998 1
a998 1
void
d1124 1
a1124 1
  
d1229 1
a1229 1
      
d1234 1
a1234 1
  
d1271 1
a1271 1
  
d1274 1
a1274 1
      
d1279 1
a1279 1
      
d1297 1
a1297 1
	  
d1305 1
a1305 1
	  if (p < e && *p == ',')       /* found type tag. */
d1321 2
a1322 1
	      char *exported_name = xstrdup (c);
d1359 1
a1359 1
      sym = bfd_minisymbol_to_symbol (abfd, false, from, store);
d1372 2
a1373 1
	  char *exported_name = xstrdup (symbol_name);
d1376 1
a1376 1
	  /* Note: stdcall alias symbols can never be data. */
d1397 1
a1397 1
      
d1401 5
a1405 2
      /* FIXME: Is it always right to add a leading underscore?  */
      sprintf (new_exclude->string, "_%s", exclude_string);
d1418 1
a1418 1
static boolean
d1426 2
a1427 2
      return true;
  return false;
d1463 1
a1463 1
      sym = bfd_minisymbol_to_symbol (abfd, false, (const PTR) from, store);
d1472 1
a1472 1
      
d1509 1
a1509 1
  symcount = bfd_read_minisymbols (abfd, false, &minisyms, &size);
d1539 2
a1540 2
 
  /* FIXME: we ought to read in and block out the base relocations */
d1558 1
a1558 1
  
d1569 1
a1569 1
      
d1614 1
a1614 1
/* Generate the .exp file */
d1633 1
a1633 1
  /* Flush this page */
d1642 1
a1642 1
  
d1646 1
a1646 1
      
d1649 1
a1649 1
  
d1652 1
a1652 1
  
d1665 1
a1665 1
  
d1677 6
d1684 1
a1684 1
        {
d1686 1
a1686 1
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s ; %s\n",
d1692 1
a1692 2
		   exp->data ? " DATA" : "",
		   res ? res : "");
d1694 3
a1696 3
      else 
        {
          char *quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
d1698 1
a1698 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s ; %s\n",
d1707 1
a1707 2
		   exp->data ? " DATA" : "",
		   res ? res : "");
a1708 2
      if (res)
        free (res);
d1710 1
a1710 1
  
d1810 1
a1810 1
/* Assemble the specified file. */
d1817 1
a1817 1
  
d1836 1
a1836 1
  
d1841 1
a1841 1
  
d1846 1
a1846 1
  
d1897 14
a1910 3
	  fprintf (f, "\t%s%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
                   ASM_PREFIX,
                   exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
d1935 7
a1941 2
	  fprintf (f, "n%d:	%s	\"%s\"\n",
		   exp->ordinal, ASM_TEXT, exp->name);
d1951 1
a1951 1
      
d1959 1
a1959 1
	      
d2007 1
a2007 1
  /* Dump the reloc section if a base file is provided */
d2067 1
a2067 1
  /* assemble the file */
d2072 1
a2072 1
  
d2080 3
a2082 1
  if (add_underscore)
d2085 1
d2094 2
d2138 1
a2138 1
  unsigned   char *data;
d2153 7
a2159 1
#define INIT_SEC_DATA(id, name, flags, align) { id, name, flags, align, NULL, NULL, NULL, 0, NULL }
d2162 7
a2168 7
  INIT_SEC_DATA (TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (DATA,   ".data",    SEC_DATA,                    2),
  INIT_SEC_DATA (BSS,    ".bss",     0,                           2),
  INIT_SEC_DATA (IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1)
d2173 2
a2174 2
/* Sections numbered to make the order the same as other PowerPC NT    */
/* compilers. This also keeps funny alignment thingies from happening. */
d2202 2
a2203 3
/*
This is what we're trying to make.  We generate the imp symbols with
both single and double underscores, for compatibility.
d2226 1
a2226 1
For the PowerPC, here's the variation on the above scheme:
d2237 1
a2237 2
	 bctr
*/
d2246 1
d2253 26
d2339 1
a2339 1
      asymbol *  iname;
d2353 1
d2358 1
a2358 1
      
d2360 1
a2360 1
      
d2362 1
a2362 1
      
d2369 1
a2369 1
      
d2377 4
a2380 2
      
      /* First make symbols for the sections */
d2389 1
a2389 1
				 si->flags);
d2409 1
a2409 1
	  exp_label->name = make_label ("", exp->name);
d2414 1
a2414 1
	     points to the .toc */
d2438 1
a2438 1
	  iname->name = make_label ("__imp_", exp->name);
d2445 1
a2445 1
      iname2->name = make_label ("_imp__", exp->name);
a2456 1

d2466 1
a2466 1
      /* The symbol refering to the code (.text) */
d2480 1
a2480 1
      /* The .toc symbol */
d2482 1
a2482 1
	asymbol *toc_symbol;    /* The .toc symbol */
d2494 1
a2494 1
      
d2515 1
a2515 1
		  
d2519 1
a2519 1
		  
d2541 1
a2541 1
		 rva to idata$6 */
d2586 1
a2586 1
	      si->data =xmalloc(4);
d2602 10
a2611 10
		/* The .pdata section is 5 words long. */
		/* Think of it as:                     */
		/* struct                              */
		/* {                                   */
		/*   bfd_vma BeginAddress,     [0x00]  */
		/*           EndAddress,       [0x04]  */
		/*	     ExceptionHandler, [0x08]  */
		/*	     HandlerData,      [0x0c]  */
		/*	     PrologEndAddress; [0x10]  */
		/* };                                  */
d2626 1
a2626 2
		      that this is a glue routine.
		*/
d2629 1
a2629 1
		/* alignment must be set to 2**2 or you get extra stuff */
d2633 1
a2633 1
		si->data =xmalloc(4 * 5);
d2642 1
a2642 1
		/* stick the toc reload instruction in the glue reloc */
d2655 1
a2655 1
		bfd_put_32(abfd, 0x18, si->data + 0x04);
d2661 2
a2662 2
		/* mark it as glue */
		bfd_put_32(abfd, 0x03, si->data + 0x0c);
d2664 2
a2665 2
		/* mark the prolog end address */
		bfd_put_32(abfd, 0x0D, si->data + 0x10);
d2680 1
a2680 3
	         We use relocs to build this.
	      */

d2711 1
a2711 1
	/* Size up all the sections */
d2722 1
a2722 1
      /* Write them out */
d2756 1
a2756 1
  
d2788 1
a2788 1
  
d2797 1
a2797 1
  
d2815 1
a2815 1
  
d2821 1
a2821 1
  
d2834 1
a2834 2
     crt0)
  */
d2846 1
a2846 1
     do too. Original, huh? */
d2859 2
a2860 2
  
  return  bfd_openr (TMP_TAIL_O, HOW_BFD_READ_TARGET);
d2883 1
a2883 1
  
d2887 1
a2887 2
  /* Work out a reasonable size of things to put onto one line. */

d2893 1
a2893 1
  
d2901 1
a2901 2
  /* Now stick them all into the archive */

d2908 1
a2908 1
  
d2919 1
a2919 2
  /* Delete all the temp files */

d2941 1
a2941 1
  
d2948 1
a2948 1
   .def file and work out the best stuff */
d2959 1
a2959 1
  /* unset ordinals go to the bottom */
d2984 1
d3028 1
d3033 1
a3033 1
      /* Remove duplicates */
d3047 1
a3047 1
	      
d3051 1
a3051 1
	      
d3058 1
a3058 1
	      /* Merge attributes */
d3073 1
a3073 1
  /* Count the names */
d3092 1
a3092 2
  /* fill in the unset ordinals with ones from our range */

d3097 1
a3097 1
  /* Mark in our large vector all the numbers that are taken */
d3103 1
d3105 1
a3105 3
	    {
	      lowest = d_export_vec[i]->ordinal;
	    }
d3113 1
a3113 1
  /* Now fill in ordinals where the user wants us to choose. */
d3120 1
a3120 1
	  /* First try within or after any user supplied range. */
d3129 1
a3129 1
	  /* Then try before the range. */
d3143 1
a3143 2
  /* And resort */

d3170 1
a3170 2
  /* First work out the minimum ordinal chosen */

d3179 1
a3179 1
  
d3181 1
a3181 3
    {
      d_export_vec[i] = exp;
    }
d3186 1
a3186 1
  /* Put back the list in the new order */
d3194 1
a3194 1
  /* Build list in alpha order */
d3199 2
a3200 3
    {
      d_exports_lexically[i] = exp;
    }
d3205 4
a3208 1
  /* Fill exp entries with their hint values */
a3209 6
  for (i = 0; i < d_nfuncs; i++)
    {
      if (!d_exports_lexically[i]->noname || show_allnames)
	d_exports_lexically[i]->hint = hint++;
    }
  
d3221 1
a3221 1
  fprintf (file, _("Usage %s <options> <object-files>\n"), program_name);
d3289 1
d3293 2
d3309 3
d3316 2
a3317 2
#ifdef DLLTOOL_MCORE_ELF			   
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVhM:L:F:",
d3319 1
a3319 1
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVh",
d3327 1
a3327 1
	  export_all_symbols = true;
d3330 1
a3330 1
	  export_all_symbols = false;
d3336 1
a3336 1
	  do_default_excludes = false;
d3347 3
d3372 1
d3402 1
a3402 1
	  
d3448 1
a3448 1
  
d3453 2
a3454 2
    do_default_excludes = false;
  
d3473 1
a3473 1
  
d3476 1
a3476 1
      /* Make imp_name safe for use as a label. */
d3482 1
a3482 1
	  if (!isalpha ((unsigned char) *p) && !isdigit ((unsigned char) *p))
d3488 1
a3488 1
  
d3491 1
a3491 1
  
d3496 1
a3496 1
  
d3514 2
a3515 2
  cmd = xmalloc (strlen (prefix) 
                 + strlen (prog_name) 
d3517 1
a3517 1
                 + strlen (EXECUTABLE_SUFFIX) 
d3530 1
a3530 1
               || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
d3535 1
a3535 1
        {
d3552 1
a3552 1
   run "i386-pe-as" or "ppc-pe-ld".  
d3558 1
a3558 1
   deduce_name("as") uses the following search order: 
d3563 1
a3563 1
   
d3569 1
a3569 1
     
d3664 1
a3664 1
  dyn_string_append (ds, "-r ");
d3667 2
a3668 2
    dyn_string_append (ds, mcore_elf_linker_flags);
  
d3671 2
a3672 2
      dyn_string_append (ds, ptr->filename);
      dyn_string_append (ds, " ");
d3677 2
a3678 2
  dyn_string_append (ds, "-o ");
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);
d3682 1
a3682 1
  
d3687 2
a3688 2
  /* Step two. Create a .exp file and a .lib file from the temporary file. 
     Do this by recursively invoking dlltool....*/
d3691 9
a3699 9
  dyn_string_append (ds, "-S ");
  dyn_string_append (ds, as_name);
  
  dyn_string_append (ds, " -e ");
  dyn_string_append (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append (ds, " -l ");
  dyn_string_append (ds, MCORE_ELF_TMP_LIB);
  dyn_string_append (ds, " " );
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);
d3702 2
a3703 2
    dyn_string_append (ds, " -v");
  
d3706 2
a3707 2
      dyn_string_append (ds, " -n");
  
d3709 1
a3709 1
	dyn_string_append (ds, " -n");
a3712 1
  
d3720 1
a3720 1
  dyn_string_append (ds, "-shared ");
d3723 1
a3723 1
    dyn_string_append (ds, mcore_elf_linker_flags);
d3725 6
a3730 6
  dyn_string_append (ds, " ");
  dyn_string_append (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append (ds, " ");
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);
  dyn_string_append (ds, " -o ");
  dyn_string_append (ds, mcore_elf_out_file);
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@d1128 1
d1130 3
@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d23 2
a24 1
/* This program allows you to build the files necessary to create
d51 1
a51 3
   EXPORTS  ( (  ( <name1> [ = <name2> ] )
               | ( <name1> = <module-name> . <external-name>))
            [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] ) *
d53 1
a53 3
   DLL, with optional ordinal number <integer>.
   Or declares name1 as an alias (forward) of the function <external-name>
   in the DLL <module-name>.
d114 1
a114 1

d161 1
a161 1

d165 1
a165 1

d169 1
a169 1

d179 1
a179 1

d184 1
a184 1

d189 1
a189 1

d193 3
a195 2

   ld -o thedll.dll thedll.exp file1.o file2.o  */
d231 2
a232 1
   .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc).  */
a251 1
#include "safe-ctype.h"
d253 1
d269 2
a270 4
static char *look_for_prog
  PARAMS ((const char *, const char *, int));
static char *deduce_name
  PARAMS ((const char *));
d273 2
a274 4
static void mcore_elf_cache_filename
  PARAMS ((char *));
static void mcore_elf_gen_out_file
  PARAMS ((void));
d276 1
a276 1

d282 1
a282 1
#define WIFEXITED(w)	(((w) & 0377) == 0)
d285 1
a285 1
#define WIFSIGNALED(w)	(((w) & 0377) != 0177 && ((w) & ~0377) == 0)
d326 2
a327 2
  char *         name;   /* Name of function being imported.  */
  int            ord;    /* Two-byte ordinal value associated with function.  */
d333 5
a337 5
  char          *dllname;  /* Name of dll file imported from.  */
  long           nfuncs;   /* Number of functions in list.  */
  struct ifunct *funchead; /* First function in list.  */
  struct ifunct *functail; /* Last  function in list.  */
  struct iheadt *next;     /* Next dll file in list.  */
a347 2
static char *tmp_prefix = "d";

d360 1
a360 1
/* TRUE if we should export all symbols.  Otherwise, we only export
d362 1
a362 1
static bfd_boolean export_all_symbols;
d364 1
a364 1
/* TRUE if we should exclude the symbols in DEFAULT_EXCLUDES when
d366 1
a366 1
static bfd_boolean do_default_excludes = TRUE;
d371 1
a371 1
/* TRUE if we should add __imp_<SYMBOL> to import libraries for backward
d373 1
a373 1
static bfd_boolean create_compat_implib;
d427 1
a427 1
#define PATHMAX 250		/* What's the right name for this ?  */
d429 6
a434 13
char *tmp_asm_buf;
char *tmp_head_s_buf;
char *tmp_head_o_buf;
char *tmp_tail_s_buf;
char *tmp_tail_o_buf;
char *tmp_stub_buf;

#define TMP_ASM		dlltmp (tmp_asm_buf, "%sc.s")
#define TMP_HEAD_S	dlltmp (tmp_head_s_buf, "%sh.s")
#define TMP_HEAD_O	dlltmp (tmp_head_o_buf, "%sh.o")
#define TMP_TAIL_S	dlltmp (tmp_tail_s_buf, "%st.s")
#define TMP_TAIL_O	dlltmp (tmp_tail_o_buf, "%st.o")
#define TMP_STUB	dlltmp (tmp_stub_buf, "%ss")
d436 1
a436 1
/* This bit of assemly does jmp * ....  */
d471 1
a471 1
  0x81, 0x01,            /* ld.w r1,(r1,0) */
d474 1
a474 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */
d480 1
a480 1
  0x01, 0x81,            /* ld.w r1,(r1,0) */
d483 1
a483 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */
d486 5
a490 5
/* This is the glue sequence for PowerPC PE. There is a
   tocrel16-tocdefn reloc against the first instruction.
   We also need a IMGLUE reloc against the glue function
   to restore the toc saved by the third instruction in
   the glue.  */
d503 2
a504 2
/* The glue instruction, picks up the toc from the stw in
   the above code: "lwz r2,4(r1)".  */
d525 2
a526 2
    int how_jtab_size; /* Size of the jtab entry.  */
    int how_jtab_roff; /* Offset into it for the ind 32 reloc into idata 5.  */
a638 1
    int forward;	/* Number of forward label, 0 means no forward.  */
d644 1
a644 1

d653 21
a673 48
static const char *rvaafter
  PARAMS ((int));
static const char *rvabefore
  PARAMS ((int));
static const char *asm_prefix
  PARAMS ((int));
static void process_def_file
  PARAMS ((const char *));
static void new_directive
  PARAMS ((char *));
static void append_import
  PARAMS ((const char *, const char *, int));
static void run
  PARAMS ((const char *, char *));
static void scan_drectve_symbols
  PARAMS ((bfd *));
static void scan_filtered_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void add_excludes
  PARAMS ((const char *));
static bfd_boolean match_exclude
  PARAMS ((const char *));
static void set_default_excludes
  PARAMS ((void));
static long filter_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void scan_all_symbols
  PARAMS ((bfd *));
static void scan_open_obj_file
  PARAMS ((bfd *));
static void scan_obj_file
  PARAMS ((const char *));
static void dump_def_info
  PARAMS ((FILE *));
static int sfunc
  PARAMS ((const void *, const void *));
static void flush_page
  PARAMS ((FILE *, long *, int, int));
static void gen_def_file
  PARAMS ((void));
static void generate_idata_ofile
  PARAMS ((FILE *));
static void assemble_file
  PARAMS ((const char *, const char *));
static void gen_exp_file
  PARAMS ((void));
static const char *xlate
  PARAMS ((const char *));
d675 1
a675 2
static void dump_iat
  PARAMS ((FILE *, export_type *));
d677 15
a691 32
static char *make_label
  PARAMS ((const char *, const char *));
static char *make_imp_label
  PARAMS ((const char *, const char *));
static bfd *make_one_lib_file
  PARAMS ((export_type *, int));
static bfd *make_head
  PARAMS ((void));
static bfd *make_tail
  PARAMS ((void));
static void gen_lib_file
  PARAMS ((void));
static int pfunc
  PARAMS ((const void *, const void *));
static int nfunc
  PARAMS ((const void *, const void *));
static void remove_null_names
  PARAMS ((export_type **));
static void dtab
  PARAMS ((export_type **));
static void process_duplicates
  PARAMS ((export_type **));
static void fill_ordinals
  PARAMS ((export_type **));
static int alphafunc
  PARAMS ((const void *, const void *));
static void mangle_defs
  PARAMS ((void));
static void usage
  PARAMS ((FILE *, int));
static void inform
  PARAMS ((const char *, ...));
a692 8
static char *
dlltmp PARAMS ((char *buf, const char *fmt))
{
  if (!buf)
    buf = malloc (strlen (tmp_prefix) + 17);
  sprintf (buf, fmt, tmp_prefix);
  return buf;
}
d695 7
a701 1
inform VPARAMS ((const char * message, ...))
d703 2
a704 3
  VA_OPEN (args, message);
  VA_FIXEDARG (args, const char *, message);

d708 6
d715 2
a716 2

  VA_CLOSE (args);
d818 1
a818 1
static void
d823 1
a823 1

d832 1
a832 1

d840 1
a840 1
/* Communications with the parser.  */
d842 9
a850 10
static const char *d_name;	/* Arg to NAME or LIBRARY.  */
static int d_nfuncs;		/* Number of functions exported.  */
static int d_named_nfuncs;	/* Number of named functions exported.  */
static int d_low_ord;		/* Lowest ordinal index.  */
static int d_high_ord;		/* Highest ordinal index.  */
static export_type *d_exports;	/* List of exported functions.  */
static export_type **d_exports_lexically;  /* Vector of exported functions in alpha order.  */
static dlist_type *d_list;	/* Descriptions.  */
static dlist_type *a_list;	/* Stuff to go in directives.  */
static int d_nforwards = 0;	/* Number of forwarded exports.  */
d861 1
a861 1

a884 6

  if ((internal_name != NULL)
      && (strchr (internal_name, '.') != NULL))
    p->forward = ++d_nforwards;
  else
    p->forward = 0; /* no forward */
d894 1
a894 1

d897 1
a897 1

d899 2
a900 2
  /* If --dllname not provided, use the one in the DEF file.
     FIXME: Is this appropriate for executables?  */
d913 1
a913 1

d916 1
a916 1

d918 1
a918 1
  /* If --dllname not provided, use the one in the DEF file.  */
d934 1
a934 1
static void
d1060 1
a1060 1

d1161 1
a1161 1

d1166 1
a1166 1

d1203 1
a1203 1

d1206 1
a1206 1

d1211 1
a1211 1

d1229 1
a1229 1

d1237 1
a1237 1
	  if (p < e && *p == ',')       /* found type tag.  */
d1253 1
a1253 2
	      int lead_at = (*c == '@@') ;
	      char *exported_name = xstrdup (c + lead_at);
d1290 1
a1290 1
      sym = bfd_minisymbol_to_symbol (abfd, FALSE, from, store);
d1303 1
a1303 2
	  int lead_at = (*symbol_name == '@@');
	  char *exported_name = xstrdup (symbol_name + lead_at);
d1306 1
a1306 1
	  /* Note: stdcall alias symbols can never be data.  */
d1327 1
a1327 1

d1331 2
a1332 5
      /* Don't add a leading underscore for fastcall symbols.  */
      if (*exclude_string == '@@')
	sprintf (new_exclude->string, "%s", exclude_string);
      else
	sprintf (new_exclude->string, "_%s", exclude_string);
d1345 1
a1345 1
static bfd_boolean
d1353 2
a1354 2
      return TRUE;
  return FALSE;
d1390 1
a1390 1
      sym = bfd_minisymbol_to_symbol (abfd, FALSE, (const PTR) from, store);
d1399 1
a1399 1

d1436 1
a1436 1
  symcount = bfd_read_minisymbols (abfd, FALSE, &minisyms, &size);
d1466 2
a1467 2

  /* FIXME: we ought to read in and block out the base relocations.  */
d1485 1
a1485 1

d1496 1
a1496 1

d1541 1
a1541 1
/* Generate the .exp file.  */
d1560 1
a1560 1
  /* Flush this page.  */
d1569 1
a1569 1

d1573 1
a1573 1

d1576 1
a1576 1

d1579 1
a1579 1

d1592 1
a1592 1

a1603 6
      if (res)
	{
 	  fprintf (output_def,";\t%s\n", res);
	  free (res);
	}

d1605 1
a1605 1
	{
d1607 1
a1607 1
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s\n",
d1613 2
a1614 1
		   exp->data ? " DATA" : "");
d1616 3
a1618 3
      else
	{
	  char *quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
d1620 1
a1620 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s\n",
d1629 2
a1630 1
		   exp->data ? " DATA" : "");
d1632 2
d1635 1
a1635 1

d1735 1
a1735 1
/* Assemble the specified file.  */
d1742 1
a1742 1

d1761 1
a1761 1

d1766 1
a1766 1

d1771 1
a1771 1

d1822 3
a1824 14

	  if (exp->forward == 0)
	    {
	      if (exp->internal_name[0] == '@@')
		fprintf (f, "\t%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	      else
		fprintf (f, "\t%s%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 ASM_PREFIX,
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	    }
	  else
	    fprintf (f, "\t%sf%d%s\t%s %d\n", ASM_RVA_BEFORE,
		     exp->forward, ASM_RVA_AFTER, ASM_C, exp->ordinal);
d1849 2
a1850 7
	  {
	    fprintf (f, "n%d:	%s	\"%s\"\n",
		     exp->ordinal, ASM_TEXT, xlate (exp->name));
	    if (exp->forward != 0)
	      fprintf (f, "f%d:	%s	\"%s\"\n",
		       exp->forward, ASM_TEXT, exp->internal_name);
	  }
d1860 1
a1860 1

d1868 1
a1868 1

d1916 1
a1916 1
  /* Dump the reloc section if a base file is provided.  */
d1976 1
a1976 1
  /* Assemble the file.  */
d1981 1
a1981 1

d1989 1
a1989 3
  int lead_at = (*name == '@@');

  if (add_underscore &&  !lead_at)
a1991 1

a1999 2

      name += lead_at;
d2042 1
a2042 1
  unsigned char *data;
d2057 1
a2057 7
#define TEXT_SEC_FLAGS   \
        (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY | SEC_HAS_CONTENTS)
#define DATA_SEC_FLAGS   (SEC_ALLOC | SEC_LOAD | SEC_DATA)
#define BSS_SEC_FLAGS     SEC_ALLOC

#define INIT_SEC_DATA(id, name, flags, align) \
        { id, name, flags, align, NULL, NULL, NULL, 0, NULL }
d2060 7
a2066 7
  INIT_SEC_DATA (TEXT,   ".text",    TEXT_SEC_FLAGS,   2),
  INIT_SEC_DATA (DATA,   ".data",    DATA_SEC_FLAGS,   2),
  INIT_SEC_DATA (BSS,    ".bss",     BSS_SEC_FLAGS,    2),
  INIT_SEC_DATA (IDATA7, ".idata$7", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA5, ".idata$5", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA4, ".idata$4", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA6, ".idata$6", SEC_HAS_CONTENTS, 1)
d2071 2
a2072 2
/* Sections numbered to make the order the same as other PowerPC NT
   compilers. This also keeps funny alignment thingies from happening.  */
d2100 3
a2102 2
/* This is what we're trying to make.  We generate the imp symbols with
   both single and double underscores, for compatibility.
d2125 1
a2125 1
   For the PowerPC, here's the variation on the above scheme:
d2136 2
a2137 1
	 bctr  */
a2145 1

a2151 26
static char *
make_imp_label (prefix, name)
     const char *prefix;
     const char *name;
{
  int len;
  char *copy;

  if (name[0] == '@@')
    {
      len = strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, name);
    }
  else
    {
      len = strlen (ASM_PREFIX) + strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, ASM_PREFIX);
      strcat (copy, name);
    }
  return copy;
}

d2212 1
a2212 1
      asymbol *  iname = 0;
a2225 1
      flagword   applicable;
d2230 1
a2230 1

d2232 1
a2232 1

d2234 1
a2234 1

d2241 1
a2241 1

d2249 2
a2250 4

      applicable = bfd_applicable_section_flags (abfd);

      /* First make symbols for the sections.  */
d2259 1
a2259 1
				 si->flags & applicable);
d2279 1
a2279 1
	  exp_label->name = make_imp_label ("", exp->name);
d2284 1
a2284 1
	     points to the .toc.  */
d2308 1
a2308 1
	  iname->name = make_imp_label ("___imp", exp->name);
d2315 1
a2315 1
      iname2->name = make_imp_label ("__imp_", exp->name);
d2327 1
d2337 1
a2337 1
      /* The symbol refering to the code (.text).  */
d2351 1
a2351 1
      /* The .toc symbol.  */
d2353 1
a2353 1
	asymbol *toc_symbol;
d2365 1
a2365 1

d2386 1
a2386 1

d2390 1
a2390 1

d2412 1
a2412 1
		 rva to idata$6.  */
d2457 1
a2457 1
	      si->data =xmalloc (4);
d2473 10
a2482 10
		/* The .pdata section is 5 words long.
		   Think of it as:
		   struct
		   {
		     bfd_vma BeginAddress,     [0x00]
		             EndAddress,       [0x04]
			     ExceptionHandler, [0x08]
			     HandlerData,      [0x0c]
			     PrologEndAddress; [0x10]
		   };  */
d2497 2
a2498 1
		      that this is a glue routine.  */
d2501 1
a2501 1
		/* Alignment must be set to 2**2 or you get extra stuff.  */
d2505 1
a2505 1
		si->data = xmalloc (si->size);
d2514 1
a2514 1
		/* Stick the toc reload instruction in the glue reloc.  */
d2527 1
a2527 1
		bfd_put_32 (abfd, 0x18, si->data + 0x04);
d2533 2
a2534 2
		/* Mark it as glue.  */
		bfd_put_32 (abfd, 0x03, si->data + 0x0c);
d2536 2
a2537 2
		/* Mark the prolog end address.  */
		bfd_put_32 (abfd, 0x0D, si->data + 0x10);
d2552 3
a2554 1
	         We use relocs to build this.  */
d2585 1
a2585 1
	/* Size up all the sections.  */
d2596 1
a2596 1
      /* Write them out.  */
d2630 1
a2630 1

d2662 1
a2662 1

d2671 1
a2671 1

d2689 1
a2689 1

d2695 1
a2695 1

d2708 2
a2709 1
     crt0).  */
d2721 1
a2721 1
     do too. Original, huh?  */
d2734 2
a2735 2

  return bfd_openr (TMP_TAIL_O, HOW_BFD_READ_TARGET);
d2758 1
a2758 1

d2762 2
a2763 1
  /* Work out a reasonable size of things to put onto one line.  */
d2769 1
a2769 1

d2777 2
a2778 1
  /* Now stick them all into the archive.  */
d2785 1
a2785 1

d2796 2
a2797 1
  /* Delete all the temp files.  */
d2819 1
a2819 1

d2826 1
a2826 1
   .def file and work out the best stuff.  */
d2837 1
a2837 1
  /* Unset ordinals go to the bottom.  */
a2861 1

a2904 1

d2909 1
a2909 1
      /* Remove duplicates.  */
d2923 1
a2923 1

d2927 1
a2927 1

d2934 1
a2934 1
	      /* Merge attributes.  */
d2949 1
a2949 1
  /* Count the names.  */
d2968 2
a2969 1
  /* Fill in the unset ordinals with ones from our range.  */
d2974 1
a2974 1
  /* Mark in our large vector all the numbers that are taken.  */
a2979 1

d2981 3
a2983 1
	    lowest = d_export_vec[i]->ordinal;
d2991 1
a2991 1
  /* Now fill in ordinals where the user wants us to choose.  */
d2998 1
a2998 1
	  /* First try within or after any user supplied range.  */
d3007 1
a3007 1
	  /* Then try before the range.  */
d3021 2
a3022 1
  /* And resort.  */
d3049 2
a3050 1
  /* First work out the minimum ordinal chosen.  */
d3059 1
a3059 1

d3061 3
a3063 1
    d_export_vec[i] = exp;
d3068 1
a3068 1
  /* Put back the list in the new order.  */
d3076 1
a3076 1
  /* Build list in alpha order.  */
d3081 3
a3083 2
    d_exports_lexically[i] = exp;

d3088 2
a3089 1
  /* Fill exp entries with their hint values.  */
d3091 5
a3095 3
    if (!d_exports_lexically[i]->noname || show_allnames)
      d_exports_lexically[i]->hint = hint++;

d3107 1
a3107 1
  fprintf (file, _("Usage %s <option(s)> <object-file(s)>\n"), program_name);
a3174 1
  {"temp-prefix", required_argument, NULL, 't'},
a3177 2
int main PARAMS ((int, char **));

a3191 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
d3196 2
a3197 2
#ifdef DLLTOOL_MCORE_ELF
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHhM:L:F:",
d3199 1
a3199 1
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHh",
d3207 1
a3207 1
	  export_all_symbols = TRUE;
d3210 1
a3210 1
	  export_all_symbols = FALSE;
d3216 1
a3216 1
	  do_default_excludes = FALSE;
a3226 3
	case 't':
	  tmp_prefix = optarg;
	  break;
a3248 1
	case 'H':
d3278 1
a3278 1

d3324 1
a3324 1

d3329 2
a3330 2
    do_default_excludes = FALSE;

d3349 1
a3349 1

d3352 1
a3352 1
      /* Make imp_name safe for use as a label.  */
d3358 1
a3358 1
	  if (!ISALNUM (*p))
d3364 1
a3364 1

d3367 1
a3367 1

d3372 1
a3372 1

d3390 2
a3391 2
  cmd = xmalloc (strlen (prefix)
		 + strlen (prog_name)
d3393 1
a3393 1
		 + strlen (EXECUTABLE_SUFFIX)
d3406 1
a3406 1
	       || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
d3411 1
a3411 1
	{
d3428 1
a3428 1
   run "i386-pe-as" or "ppc-pe-ld".
d3434 1
a3434 1
   deduce_name("as") uses the following search order:
d3439 1
a3439 1

d3445 1
a3445 1

d3540 1
a3540 1
  dyn_string_append_cstr (ds, "-r ");
d3543 2
a3544 2
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);

d3547 2
a3548 2
      dyn_string_append_cstr (ds, ptr->filename);
      dyn_string_append_cstr (ds, " ");
d3553 2
a3554 2
  dyn_string_append_cstr (ds, "-o ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
d3558 1
a3558 1

d3563 2
a3564 2
  /* Step two. Create a .exp file and a .lib file from the temporary file.
     Do this by recursively invoking dlltool...  */
d3567 9
a3575 9
  dyn_string_append_cstr (ds, "-S ");
  dyn_string_append_cstr (ds, as_name);

  dyn_string_append_cstr (ds, " -e ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " -l ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_LIB);
  dyn_string_append_cstr (ds, " " );
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
d3578 2
a3579 2
    dyn_string_append_cstr (ds, " -v");

d3582 2
a3583 2
      dyn_string_append_cstr (ds, " -n");

d3585 1
a3585 1
	dyn_string_append_cstr (ds, " -n");
d3589 1
d3597 1
a3597 1
  dyn_string_append_cstr (ds, "-shared ");
d3600 1
a3600 1
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);
d3602 6
a3607 6
  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
  dyn_string_append_cstr (ds, " -o ");
  dyn_string_append_cstr (ds, mcore_elf_out_file);
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d52 1
a52 1
            [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] [PRIVATE] ) *
d63 1
a63 1
   function will be refereed to in the body of the DLL.
d270 4
a273 2
static char *look_for_prog (const char *, const char *, int);
static char *deduce_name (const char *);
d276 4
a279 2
static void mcore_elf_cache_filename (char *);
static void mcore_elf_gen_out_file (void);
d353 1
a353 1
static char *tmp_prefix;
d443 6
a448 6
#define TMP_ASM		dlltmp (&tmp_asm_buf, "%sc.s")
#define TMP_HEAD_S	dlltmp (&tmp_head_s_buf, "%sh.s")
#define TMP_HEAD_O	dlltmp (&tmp_head_o_buf, "%sh.o")
#define TMP_TAIL_S	dlltmp (&tmp_tail_s_buf, "%st.s")
#define TMP_TAIL_O	dlltmp (&tmp_tail_o_buf, "%st.o")
#define TMP_STUB	dlltmp (&tmp_stub_buf, "%ss")
d450 1
a450 1
/* This bit of assembly does jmp * ....  */
d650 1
a650 2
    int noname;		/* Don't put name in image file.  */
    int private;	/* Don't put reference in import lib.  */
d668 48
a715 24
static const char *rvaafter (int);
static const char *rvabefore (int);
static const char *asm_prefix (int);
static void process_def_file (const char *);
static void new_directive (char *);
static void append_import (const char *, const char *, int);
static void run (const char *, char *);
static void scan_drectve_symbols (bfd *);
static void scan_filtered_symbols (bfd *, void *, long, unsigned int);
static void add_excludes (const char *);
static bfd_boolean match_exclude (const char *);
static void set_default_excludes (void);
static long filter_symbols (bfd *, void *, long, unsigned int);
static void scan_all_symbols (bfd *);
static void scan_open_obj_file (bfd *);
static void scan_obj_file (const char *);
static void dump_def_info (FILE *);
static int sfunc (const void *, const void *);
static void flush_page (FILE *, long *, int, int);
static void gen_def_file (void);
static void generate_idata_ofile (FILE *);
static void assemble_file (const char *, const char *);
static void gen_exp_file (void);
static const char *xlate (const char *);
d717 2
a718 1
static void dump_iat (FILE *, export_type *);
d720 32
a751 16
static char *make_label (const char *, const char *);
static char *make_imp_label (const char *, const char *);
static bfd *make_one_lib_file (export_type *, int);
static bfd *make_head (void);
static bfd *make_tail (void);
static void gen_lib_file (void);
static int pfunc (const void *, const void *);
static int nfunc (const void *, const void *);
static void remove_null_names (export_type **);
static void dtab (export_type **);
static void process_duplicates (export_type **);
static void fill_ordinals (export_type **);
static int alphafunc (const void *, const void *);
static void mangle_defs (void);
static void usage (FILE *, int);
static void inform (const char *, ...);
d754 1
a754 1
prefix_encode (char *start, unsigned code)
d756 3
a758 9
  static char alpha[26] = "abcdefghijklmnopqrstuvwxyz";
  static char buf[32];
  char *p;
  strcpy (buf, start);
  p = strchr (buf, '\0');
  do
    *p++ = alpha[code % sizeof (alpha)];
  while ((code /= sizeof (alpha)) != 0);
  *p = '\0';
a761 11
static char *
dlltmp (char **buf, const char *fmt)
{
  if (!*buf)
    {
      *buf = malloc (strlen (tmp_prefix) + 64);
      sprintf (*buf, fmt, tmp_prefix);
    }
  return *buf;
}

d777 2
a778 1
rvaafter (int machine)
d802 2
a803 1
rvabefore (int machine)
d827 2
a828 1
asm_prefix (int machine)
d852 2
a853 2
#define ASM_BYTE	mtable[machine].how_byte
#define ASM_SHORT	mtable[machine].how_short
d856 2
a857 2
#define ASM_C		mtable[machine].how_comment
#define ASM_JUMP	mtable[machine].how_jump
d861 2
a862 2
#define ASM_RVA_BEFORE	rvabefore(machine)
#define ASM_RVA_AFTER	rvaafter(machine)
d876 2
a877 1
process_def_file (const char *name)
d914 2
a915 1
yyerror (const char * err ATTRIBUTE_UNUSED)
d924 7
a930 2
def_exports (const char *name, const char *internal_name, int ordinal,
	     int noname, int constant, int data, int private)
a938 1
  p->private = private;
d952 3
a954 1
def_name (const char *name, int base)
d971 3
a973 1
def_library (const char *name, int base)
d989 2
a990 1
def_description (const char *desc)
d999 2
a1000 1
new_directive (char *dir)
d1009 3
a1011 1
def_heapsize (int reserve, int commit)
d1022 3
a1024 1
def_stacksize (int reserve, int commit)
d1038 4
a1041 1
append_import (const char *symbol_name, const char *dll_name, int func_ordinal)
d1105 6
a1110 2
def_import (const char *app_name, const char *module, const char *dllext,
	    const char *entry, int ord_val)
d1136 3
a1138 1
def_version (int major, int minor)
d1144 3
a1146 1
def_section (const char *name, int attr)
d1166 2
a1167 1
def_code (int attr)
d1174 2
a1175 1
def_data (int attr)
d1183 3
a1185 1
run (const char *what, char *args)
d1256 2
a1257 1
scan_drectve_symbols (bfd *abfd)
d1313 1
a1313 1
	  def_exports (c, 0, -1, 0, 0, ! (flags & BSF_FUNCTION), 0);
d1322 1
a1322 1
	      def_exports (exported_name, xstrdup (c), -1, 0, 0, 0, 0);
d1335 5
a1339 2
scan_filtered_symbols (bfd *abfd, void *minisyms, long symcount,
		       unsigned int size)
d1364 1
a1364 1
		   ! (sym->flags & BSF_FUNCTION), 0);
d1373 1
a1373 1
	  def_exports (exported_name, xstrdup (symbol_name), -1, 0, 0, 0, 0);
d1381 2
a1382 1
add_excludes (const char *new_excludes)
d1415 2
a1416 1
match_exclude (const char *string)
d1437 5
a1441 1
filter_symbols (bfd *abfd, void *minisyms, long symcount, unsigned int size)
d1459 1
a1459 1
      sym = bfd_minisymbol_to_symbol (abfd, FALSE, (const void *) from, store);
d1485 2
a1486 1
scan_all_symbols (bfd *abfd)
d1489 1
a1489 1
  void *minisyms;
d1528 2
a1529 1
scan_open_obj_file (bfd *abfd)
d1543 2
a1544 1
scan_obj_file (const char *filename)
d1587 2
a1588 1
dump_def_info (FILE *f)
d1598 1
a1598 1
      fprintf (f, "%s  %d = %s %s @@ %d %s%s%s%s\n",
a1604 1
	       exp->private ? "PRIVATE " : "",
d1613 3
a1615 1
sfunc (const void *a, const void *b)
d1621 5
a1625 1
flush_page (FILE *f, long *need, int page_addr, int on_page)
d1655 1
a1655 1
gen_def_file (void)
d1675 1
a1675 1
	  fprintf (output_def,";\t%s\n", res);
d1681 2
a1682 1
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s%s\n",
a1687 1
		   exp->private ? "PRIVATE " : "",
d1692 1
a1692 1
	  char * quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
d1694 1
a1694 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s%s\n",
a1702 1
		   exp->private ? "PRIVATE " : "",
d1715 2
a1716 1
generate_idata_ofile (FILE *filvar)
d1808 3
a1810 1
assemble_file (const char * source, const char * dest)
d1823 1
a1823 1
gen_exp_file (void)
d1930 2
a1931 2
	{
	  if (!exp->noname || show_allnames)
d1934 4
a1937 4
	  if (exp->forward != 0)
	    fprintf (f, "f%d:	%s	\"%s\"\n",
		     exp->forward, ASM_TEXT, exp->internal_name);
	}
d2032 1
a2032 1
	  /* Delete duplicates */
d2073 2
a2074 1
xlate (const char *name)
d2104 3
a2106 1
dump_iat (FILE *f, export_type *exp)
d2236 3
a2238 1
make_label (const char *prefix, const char *name)
d2250 3
a2252 1
make_imp_label (const char *prefix, const char *name)
d2276 3
a2278 1
make_one_lib_file (export_type *exp, int i)
d2351 1
a2351 1
      char *     outname = xmalloc (strlen (TMP_STUB) + 10);
d2462 1
a2462 1
      /* The symbol referring to the code (.text).  */
d2743 1
a2743 1
make_head (void)
d2802 1
a2802 1
make_tail (void)
d2860 1
a2860 1
gen_lib_file (void)
d2892 1
a2892 5
      bfd *n;
      /* Don't add PRIVATE entries to import lib.  */
      if (exp->private)
	continue;
      n = make_one_lib_file (exp, i);
d2928 2
a2929 2
      name = (char *) alloca (strlen (TMP_STUB) + 10);
      for (i = 0; (exp = d_exports_lexically[i]); i++)
a2930 3
	  /* Don't delete non-existent stubs for PRIVATE entries.  */
          if (exp->private)
	    continue;
d2941 2
a2944 1

d2946 3
a2948 1
pfunc (const void *a, const void *b)
d2964 3
a2966 1
nfunc (const void *a, const void *b)
d2975 2
a2976 1
remove_null_names (export_type **ptr)
d2993 6
a2998 1
dtab (export_type **ptr ATTRIBUTE_UNUSED)
d3019 2
a3020 1
process_duplicates (export_type **d_export_vec)
d3027 1
d3038 1
d3068 1
d3071 4
a3074 2
    if (!d_export_vec[i]->noname)
      d_named_nfuncs++;
d3078 2
a3079 1
fill_ordinals (export_type **d_export_vec)
d3114 1
a3114 1
	  int j;
d3153 3
a3155 1
alphafunc (const void *av, const void *bv)
d3164 1
a3164 1
mangle_defs (void)
d3171 2
a3172 1
  export_type **d_export_vec = xmalloc (sizeof (export_type *) * d_nfuncs);
d3209 2
d3212 3
a3214 1
usage (FILE *file, int status)
a3240 1
  fprintf (file, _("   -t --temp-prefix <prefix> Use <prefix> to construct temp file names.\n"));
d3270 1
a3270 1
  {"def", required_argument, NULL, 'd'}, /* for compatibility with older versions */
d3289 1
a3289 1
int main (int, char **);
d3292 3
a3294 1
main (int ac, char **av)
d3350 1
a3350 1
	  /* Ignored for compatibility.  */
a3423 3
  if (!tmp_prefix)
    tmp_prefix = prefix_encode ("d", getpid ());

d3502 4
a3505 1
look_for_prog (const char *prog_name, const char *prefix, int end_prefix)
d3571 2
a3572 1
deduce_name (const char *prog_name)
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d23 2
a24 1
/* This program allows you to build the files necessary to create
d51 1
a51 3
   EXPORTS  ( (  ( <name1> [ = <name2> ] )
               | ( <name1> = <module-name> . <external-name>))
            [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] ) *
d53 1
a53 3
   DLL, with optional ordinal number <integer>.
   Or declares name1 as an alias (forward) of the function <external-name>
   in the DLL <module-name>.
d114 1
a114 1

d161 1
a161 1

d165 1
a165 1

d169 1
a169 1

d179 1
a179 1

d184 1
a184 1

d189 1
a189 1

d193 3
a195 2

   ld -o thedll.dll thedll.exp file1.o file2.o  */
d231 2
a232 1
   .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc).  */
a251 1
#include "safe-ctype.h"
d253 1
d269 2
a270 4
static char *look_for_prog
  PARAMS ((const char *, const char *, int));
static char *deduce_name
  PARAMS ((const char *));
d273 2
a274 4
static void mcore_elf_cache_filename
  PARAMS ((char *));
static void mcore_elf_gen_out_file
  PARAMS ((void));
d276 1
a276 1

d282 1
a282 1
#define WIFEXITED(w)	(((w) & 0377) == 0)
d285 1
a285 1
#define WIFSIGNALED(w)	(((w) & 0377) != 0177 && ((w) & ~0377) == 0)
d326 2
a327 2
  char *         name;   /* Name of function being imported.  */
  int            ord;    /* Two-byte ordinal value associated with function.  */
d333 5
a337 5
  char          *dllname;  /* Name of dll file imported from.  */
  long           nfuncs;   /* Number of functions in list.  */
  struct ifunct *funchead; /* First function in list.  */
  struct ifunct *functail; /* Last  function in list.  */
  struct iheadt *next;     /* Next dll file in list.  */
a347 2
static char *tmp_prefix = "d";

d360 1
a360 1
/* TRUE if we should export all symbols.  Otherwise, we only export
d362 1
a362 1
static bfd_boolean export_all_symbols;
d364 1
a364 1
/* TRUE if we should exclude the symbols in DEFAULT_EXCLUDES when
d366 1
a366 1
static bfd_boolean do_default_excludes = TRUE;
d371 1
a371 1
/* TRUE if we should add __imp_<SYMBOL> to import libraries for backward
d373 1
a373 1
static bfd_boolean create_compat_implib;
d427 1
a427 1
#define PATHMAX 250		/* What's the right name for this ?  */
d429 6
a434 13
char *tmp_asm_buf;
char *tmp_head_s_buf;
char *tmp_head_o_buf;
char *tmp_tail_s_buf;
char *tmp_tail_o_buf;
char *tmp_stub_buf;

#define TMP_ASM		dlltmp (tmp_asm_buf, "%sc.s")
#define TMP_HEAD_S	dlltmp (tmp_head_s_buf, "%sh.s")
#define TMP_HEAD_O	dlltmp (tmp_head_o_buf, "%sh.o")
#define TMP_TAIL_S	dlltmp (tmp_tail_s_buf, "%st.s")
#define TMP_TAIL_O	dlltmp (tmp_tail_o_buf, "%st.o")
#define TMP_STUB	dlltmp (tmp_stub_buf, "%ss")
d436 1
a436 1
/* This bit of assemly does jmp * ....  */
d471 1
a471 1
  0x81, 0x01,            /* ld.w r1,(r1,0) */
d474 1
a474 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */
d480 1
a480 1
  0x01, 0x81,            /* ld.w r1,(r1,0) */
d483 1
a483 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */
d486 5
a490 5
/* This is the glue sequence for PowerPC PE. There is a
   tocrel16-tocdefn reloc against the first instruction.
   We also need a IMGLUE reloc against the glue function
   to restore the toc saved by the third instruction in
   the glue.  */
d503 2
a504 2
/* The glue instruction, picks up the toc from the stw in
   the above code: "lwz r2,4(r1)".  */
d525 2
a526 2
    int how_jtab_size; /* Size of the jtab entry.  */
    int how_jtab_roff; /* Offset into it for the ind 32 reloc into idata 5.  */
a638 1
    int forward;	/* Number of forward label, 0 means no forward.  */
d644 1
a644 1

d653 21
a673 48
static const char *rvaafter
  PARAMS ((int));
static const char *rvabefore
  PARAMS ((int));
static const char *asm_prefix
  PARAMS ((int));
static void process_def_file
  PARAMS ((const char *));
static void new_directive
  PARAMS ((char *));
static void append_import
  PARAMS ((const char *, const char *, int));
static void run
  PARAMS ((const char *, char *));
static void scan_drectve_symbols
  PARAMS ((bfd *));
static void scan_filtered_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void add_excludes
  PARAMS ((const char *));
static bfd_boolean match_exclude
  PARAMS ((const char *));
static void set_default_excludes
  PARAMS ((void));
static long filter_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void scan_all_symbols
  PARAMS ((bfd *));
static void scan_open_obj_file
  PARAMS ((bfd *));
static void scan_obj_file
  PARAMS ((const char *));
static void dump_def_info
  PARAMS ((FILE *));
static int sfunc
  PARAMS ((const void *, const void *));
static void flush_page
  PARAMS ((FILE *, long *, int, int));
static void gen_def_file
  PARAMS ((void));
static void generate_idata_ofile
  PARAMS ((FILE *));
static void assemble_file
  PARAMS ((const char *, const char *));
static void gen_exp_file
  PARAMS ((void));
static const char *xlate
  PARAMS ((const char *));
d675 1
a675 2
static void dump_iat
  PARAMS ((FILE *, export_type *));
d677 15
a691 32
static char *make_label
  PARAMS ((const char *, const char *));
static char *make_imp_label
  PARAMS ((const char *, const char *));
static bfd *make_one_lib_file
  PARAMS ((export_type *, int));
static bfd *make_head
  PARAMS ((void));
static bfd *make_tail
  PARAMS ((void));
static void gen_lib_file
  PARAMS ((void));
static int pfunc
  PARAMS ((const void *, const void *));
static int nfunc
  PARAMS ((const void *, const void *));
static void remove_null_names
  PARAMS ((export_type **));
static void dtab
  PARAMS ((export_type **));
static void process_duplicates
  PARAMS ((export_type **));
static void fill_ordinals
  PARAMS ((export_type **));
static int alphafunc
  PARAMS ((const void *, const void *));
static void mangle_defs
  PARAMS ((void));
static void usage
  PARAMS ((FILE *, int));
static void inform
  PARAMS ((const char *, ...));
a692 8
static char *
dlltmp PARAMS ((char *buf, const char *fmt))
{
  if (!buf)
    buf = malloc (strlen (tmp_prefix) + 17);
  sprintf (buf, fmt, tmp_prefix);
  return buf;
}
d695 7
a701 1
inform VPARAMS ((const char * message, ...))
d703 2
a704 3
  VA_OPEN (args, message);
  VA_FIXEDARG (args, const char *, message);

d708 6
d715 2
a716 2

  VA_CLOSE (args);
d818 1
a818 1
static void
d823 1
a823 1

d832 1
a832 1

d840 1
a840 1
/* Communications with the parser.  */
d842 9
a850 10
static const char *d_name;	/* Arg to NAME or LIBRARY.  */
static int d_nfuncs;		/* Number of functions exported.  */
static int d_named_nfuncs;	/* Number of named functions exported.  */
static int d_low_ord;		/* Lowest ordinal index.  */
static int d_high_ord;		/* Highest ordinal index.  */
static export_type *d_exports;	/* List of exported functions.  */
static export_type **d_exports_lexically;  /* Vector of exported functions in alpha order.  */
static dlist_type *d_list;	/* Descriptions.  */
static dlist_type *a_list;	/* Stuff to go in directives.  */
static int d_nforwards = 0;	/* Number of forwarded exports.  */
d861 1
a861 1

a884 6

  if ((internal_name != NULL)
      && (strchr (internal_name, '.') != NULL))
    p->forward = ++d_nforwards;
  else
    p->forward = 0; /* no forward */
d894 1
a894 1

d897 1
a897 1

d899 2
a900 2
  /* If --dllname not provided, use the one in the DEF file.
     FIXME: Is this appropriate for executables?  */
d913 1
a913 1

d916 1
a916 1

d918 1
a918 1
  /* If --dllname not provided, use the one in the DEF file.  */
d934 1
a934 1
static void
d1060 1
a1060 1

d1165 1
a1165 1

d1170 1
a1170 1

d1207 1
a1207 1

d1210 1
a1210 1

d1215 1
a1215 1

d1233 1
a1233 1

d1241 1
a1241 1
	  if (p < e && *p == ',')       /* found type tag.  */
d1257 1
a1257 2
	      int lead_at = (*c == '@@') ;
	      char *exported_name = xstrdup (c + lead_at);
d1294 1
a1294 1
      sym = bfd_minisymbol_to_symbol (abfd, FALSE, from, store);
d1307 1
a1307 2
	  int lead_at = (*symbol_name == '@@');
	  char *exported_name = xstrdup (symbol_name + lead_at);
d1310 1
a1310 1
	  /* Note: stdcall alias symbols can never be data.  */
d1331 1
a1331 1

d1335 2
a1336 5
      /* Don't add a leading underscore for fastcall symbols.  */
      if (*exclude_string == '@@')
	sprintf (new_exclude->string, "%s", exclude_string);
      else
	sprintf (new_exclude->string, "_%s", exclude_string);
d1349 1
a1349 1
static bfd_boolean
d1357 2
a1358 2
      return TRUE;
  return FALSE;
d1394 1
a1394 1
      sym = bfd_minisymbol_to_symbol (abfd, FALSE, (const PTR) from, store);
d1403 1
a1403 1

d1440 1
a1440 1
  symcount = bfd_read_minisymbols (abfd, FALSE, &minisyms, &size);
d1470 2
a1471 2

  /* FIXME: we ought to read in and block out the base relocations.  */
d1489 1
a1489 1

d1500 1
a1500 1

d1545 1
a1545 1
/* Generate the .exp file.  */
d1564 1
a1564 1
  /* Flush this page.  */
d1573 1
a1573 1

d1577 1
a1577 1

d1580 1
a1580 1

d1583 1
a1583 1

d1596 1
a1596 1

a1607 6
      if (res)
	{
 	  fprintf (output_def,";\t%s\n", res);
	  free (res);
	}

d1609 1
a1609 1
	{
d1611 1
a1611 1
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s\n",
d1617 2
a1618 1
		   exp->data ? " DATA" : "");
d1620 3
a1622 3
      else
	{
	  char *quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
d1624 1
a1624 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s\n",
d1633 2
a1634 1
		   exp->data ? " DATA" : "");
d1636 2
d1639 1
a1639 1

d1739 1
a1739 1
/* Assemble the specified file.  */
d1746 1
a1746 1

d1765 1
a1765 1

d1770 1
a1770 1

d1775 1
a1775 1

d1826 3
a1828 14

	  if (exp->forward == 0)
	    {
	      if (exp->internal_name[0] == '@@')
		fprintf (f, "\t%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	      else
		fprintf (f, "\t%s%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 ASM_PREFIX,
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	    }
	  else
	    fprintf (f, "\t%sf%d%s\t%s %d\n", ASM_RVA_BEFORE,
		     exp->forward, ASM_RVA_AFTER, ASM_C, exp->ordinal);
d1853 2
a1854 7
	  {
	    fprintf (f, "n%d:	%s	\"%s\"\n",
		     exp->ordinal, ASM_TEXT, xlate (exp->name));
	    if (exp->forward != 0)
	      fprintf (f, "f%d:	%s	\"%s\"\n",
		       exp->forward, ASM_TEXT, exp->internal_name);
	  }
d1864 1
a1864 1

d1872 1
a1872 1

d1920 1
a1920 1
  /* Dump the reloc section if a base file is provided.  */
d1980 1
a1980 1
  /* Assemble the file.  */
d1985 1
a1985 1

d1993 1
a1993 3
  int lead_at = (*name == '@@');

  if (add_underscore &&  !lead_at)
a1995 1

a2003 2

      name += lead_at;
d2046 1
a2046 1
  unsigned char *data;
d2061 1
a2061 7
#define TEXT_SEC_FLAGS   \
        (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY | SEC_HAS_CONTENTS)
#define DATA_SEC_FLAGS   (SEC_ALLOC | SEC_LOAD | SEC_DATA)
#define BSS_SEC_FLAGS     SEC_ALLOC

#define INIT_SEC_DATA(id, name, flags, align) \
        { id, name, flags, align, NULL, NULL, NULL, 0, NULL }
d2064 7
a2070 7
  INIT_SEC_DATA (TEXT,   ".text",    TEXT_SEC_FLAGS,   2),
  INIT_SEC_DATA (DATA,   ".data",    DATA_SEC_FLAGS,   2),
  INIT_SEC_DATA (BSS,    ".bss",     BSS_SEC_FLAGS,    2),
  INIT_SEC_DATA (IDATA7, ".idata$7", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA5, ".idata$5", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA4, ".idata$4", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA6, ".idata$6", SEC_HAS_CONTENTS, 1)
d2075 2
a2076 2
/* Sections numbered to make the order the same as other PowerPC NT
   compilers. This also keeps funny alignment thingies from happening.  */
d2104 3
a2106 2
/* This is what we're trying to make.  We generate the imp symbols with
   both single and double underscores, for compatibility.
d2129 1
a2129 1
   For the PowerPC, here's the variation on the above scheme:
d2140 2
a2141 1
	 bctr  */
a2149 1

a2155 26
static char *
make_imp_label (prefix, name)
     const char *prefix;
     const char *name;
{
  int len;
  char *copy;

  if (name[0] == '@@')
    {
      len = strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, name);
    }
  else
    {
      len = strlen (ASM_PREFIX) + strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, ASM_PREFIX);
      strcat (copy, name);
    }
  return copy;
}

d2216 1
a2216 1
      asymbol *  iname = 0;
a2229 1
      flagword   applicable;
d2234 1
a2234 1

d2236 1
a2236 1

d2238 1
a2238 1

d2245 1
a2245 1

d2253 2
a2254 4

      applicable = bfd_applicable_section_flags (abfd);

      /* First make symbols for the sections.  */
d2263 1
a2263 1
				 si->flags & applicable);
d2283 1
a2283 1
	  exp_label->name = make_imp_label ("", exp->name);
d2288 1
a2288 1
	     points to the .toc.  */
d2312 1
a2312 1
	  iname->name = make_imp_label ("___imp", exp->name);
d2319 1
a2319 1
      iname2->name = make_imp_label ("__imp_", exp->name);
d2331 1
d2341 1
a2341 1
      /* The symbol refering to the code (.text).  */
d2355 1
a2355 1
      /* The .toc symbol.  */
d2357 1
a2357 1
	asymbol *toc_symbol;
d2369 1
a2369 1

d2390 1
a2390 1

d2394 1
a2394 1

d2416 1
a2416 1
		 rva to idata$6.  */
d2461 1
a2461 1
	      si->data =xmalloc (4);
d2477 10
a2486 10
		/* The .pdata section is 5 words long.
		   Think of it as:
		   struct
		   {
		     bfd_vma BeginAddress,     [0x00]
		             EndAddress,       [0x04]
			     ExceptionHandler, [0x08]
			     HandlerData,      [0x0c]
			     PrologEndAddress; [0x10]
		   };  */
d2501 2
a2502 1
		      that this is a glue routine.  */
d2505 1
a2505 1
		/* Alignment must be set to 2**2 or you get extra stuff.  */
d2509 1
a2509 1
		si->data = xmalloc (si->size);
d2518 1
a2518 1
		/* Stick the toc reload instruction in the glue reloc.  */
d2531 1
a2531 1
		bfd_put_32 (abfd, 0x18, si->data + 0x04);
d2537 2
a2538 2
		/* Mark it as glue.  */
		bfd_put_32 (abfd, 0x03, si->data + 0x0c);
d2540 2
a2541 2
		/* Mark the prolog end address.  */
		bfd_put_32 (abfd, 0x0D, si->data + 0x10);
d2556 3
a2558 1
	         We use relocs to build this.  */
d2589 1
a2589 1
	/* Size up all the sections.  */
d2600 1
a2600 1
      /* Write them out.  */
d2634 1
a2634 1

d2666 1
a2666 1

d2675 1
a2675 1

d2693 1
a2693 1

d2699 1
a2699 1

d2712 2
a2713 1
     crt0).  */
d2725 1
a2725 1
     do too. Original, huh?  */
d2738 2
a2739 2

  return bfd_openr (TMP_TAIL_O, HOW_BFD_READ_TARGET);
d2762 1
a2762 1

d2766 2
a2767 1
  /* Work out a reasonable size of things to put onto one line.  */
d2773 1
a2773 1

d2781 2
a2782 1
  /* Now stick them all into the archive.  */
d2789 1
a2789 1

d2800 2
a2801 1
  /* Delete all the temp files.  */
d2823 1
a2823 1

d2830 1
a2830 1
   .def file and work out the best stuff.  */
d2841 1
a2841 1
  /* Unset ordinals go to the bottom.  */
a2865 1

a2908 1

d2913 1
a2913 1
      /* Remove duplicates.  */
d2927 1
a2927 1

d2931 1
a2931 1

d2938 1
a2938 1
	      /* Merge attributes.  */
d2953 1
a2953 1
  /* Count the names.  */
d2972 2
a2973 1
  /* Fill in the unset ordinals with ones from our range.  */
d2978 1
a2978 1
  /* Mark in our large vector all the numbers that are taken.  */
a2983 1

d2985 3
a2987 1
	    lowest = d_export_vec[i]->ordinal;
d2995 1
a2995 1
  /* Now fill in ordinals where the user wants us to choose.  */
d3002 1
a3002 1
	  /* First try within or after any user supplied range.  */
d3011 1
a3011 1
	  /* Then try before the range.  */
d3025 2
a3026 1
  /* And resort.  */
d3053 2
a3054 1
  /* First work out the minimum ordinal chosen.  */
d3063 1
a3063 1

d3065 3
a3067 1
    d_export_vec[i] = exp;
d3072 1
a3072 1
  /* Put back the list in the new order.  */
d3080 1
a3080 1
  /* Build list in alpha order.  */
d3085 3
a3087 2
    d_exports_lexically[i] = exp;

d3092 2
a3093 1
  /* Fill exp entries with their hint values.  */
d3095 5
a3099 3
    if (!d_exports_lexically[i]->noname || show_allnames)
      d_exports_lexically[i]->hint = hint++;

d3111 1
a3111 1
  fprintf (file, _("Usage %s <option(s)> <object-file(s)>\n"), program_name);
a3178 1
  {"temp-prefix", required_argument, NULL, 't'},
a3181 2
int main PARAMS ((int, char **));

a3195 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
d3200 2
a3201 2
#ifdef DLLTOOL_MCORE_ELF
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHhM:L:F:",
d3203 1
a3203 1
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHh",
d3211 1
a3211 1
	  export_all_symbols = TRUE;
d3214 1
a3214 1
	  export_all_symbols = FALSE;
d3220 1
a3220 1
	  do_default_excludes = FALSE;
a3230 3
	case 't':
	  tmp_prefix = optarg;
	  break;
a3252 1
	case 'H':
d3282 1
a3282 1

d3328 1
a3328 1

d3333 2
a3334 2
    do_default_excludes = FALSE;

d3353 1
a3353 1

d3356 1
a3356 1
      /* Make imp_name safe for use as a label.  */
d3362 1
a3362 1
	  if (!ISALNUM (*p))
d3368 1
a3368 1

d3371 1
a3371 1

d3376 1
a3376 1

d3394 2
a3395 2
  cmd = xmalloc (strlen (prefix)
		 + strlen (prog_name)
d3397 1
a3397 1
		 + strlen (EXECUTABLE_SUFFIX)
d3410 1
a3410 1
	       || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
d3415 1
a3415 1
	{
d3432 1
a3432 1
   run "i386-pe-as" or "ppc-pe-ld".
d3438 1
a3438 1
   deduce_name("as") uses the following search order:
d3443 1
a3443 1

d3449 1
a3449 1

d3544 1
a3544 1
  dyn_string_append_cstr (ds, "-r ");
d3547 2
a3548 2
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);

d3551 2
a3552 2
      dyn_string_append_cstr (ds, ptr->filename);
      dyn_string_append_cstr (ds, " ");
d3557 2
a3558 2
  dyn_string_append_cstr (ds, "-o ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
d3562 1
a3562 1

d3567 2
a3568 2
  /* Step two. Create a .exp file and a .lib file from the temporary file.
     Do this by recursively invoking dlltool...  */
d3571 9
a3579 9
  dyn_string_append_cstr (ds, "-S ");
  dyn_string_append_cstr (ds, as_name);

  dyn_string_append_cstr (ds, " -e ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " -l ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_LIB);
  dyn_string_append_cstr (ds, " " );
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
d3582 2
a3583 2
    dyn_string_append_cstr (ds, " -v");

d3586 2
a3587 2
      dyn_string_append_cstr (ds, " -n");

d3589 1
a3589 1
	dyn_string_append_cstr (ds, " -n");
d3593 1
d3601 1
a3601 1
  dyn_string_append_cstr (ds, "-shared ");
d3604 1
a3604 1
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);
d3606 6
a3611 6
  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
  dyn_string_append_cstr (ds, " -o ");
  dyn_string_append_cstr (ds, mcore_elf_out_file);
@

