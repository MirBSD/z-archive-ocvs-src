head	1.6;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.3
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.08.11.20.56.41;	author tg;	state dead;
branches;
next	1.5;

1.5
date	2004.06.10.19.00.28;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.29.21.32.45;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.27.17.41.43;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.23.21.01.14;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.39.16;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.39.16;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.01.26.17.50.11;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.06.09.20.27.47;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.40.05;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.03.03;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.03.51;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@remove old binutils
@
text
@/* $MirBSD: src/gnu/usr.bin/binutils/binutils/objcopy.c,v 1.5 2004/06/10 19:00:28 tg Exp $ */

/* objcopy.c -- copy object file from input to output, optionally massaging it.
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "bfd.h"
#include "progress.h"
#include "bucomm.h"
#include "getopt.h"
#include "libiberty.h"
#include "budbg.h"
#include "filenames.h"
#include <sys/stat.h>

/* A list of symbols to explicitly strip out, or to keep.  A linked
   list is good enough for a small number from the command line, but
   this will slow things down a lot if many symbols are being
   deleted.  */

struct symlist
{
  const char *name;
  struct symlist *next;
};

/* A list to support redefine_sym.  */
struct redefine_node
{
  char *source;
  char *target;
  struct redefine_node *next;
};

typedef struct section_rename
{
  const char *            old_name;
  const char *            new_name;
  flagword                flags;
  struct section_rename * next;
}
section_rename;

/* List of sections to be renamed.  */
static section_rename * section_rename_list;

static void copy_usage
  PARAMS ((FILE *, int));
static void strip_usage
  PARAMS ((FILE *, int));
static flagword parse_flags
  PARAMS ((const char *));
static struct section_list *find_section_list
  PARAMS ((const char *, bfd_boolean));
static void setup_section
  PARAMS ((bfd *, asection *, PTR));
static void copy_section
  PARAMS ((bfd *, asection *, PTR));
static void get_sections
  PARAMS ((bfd *, asection *, PTR));
static int compare_section_lma
  PARAMS ((const PTR, const PTR));
static void add_specific_symbol
  PARAMS ((const char *, struct symlist **));
static void add_specific_symbols
  PARAMS ((const char *, struct symlist **));
static bfd_boolean is_specified_symbol
  PARAMS ((const char *, struct symlist *));
static bfd_boolean is_strip_section
  PARAMS ((bfd *, asection *));
static unsigned int filter_symbols
  PARAMS ((bfd *, bfd *, asymbol **, asymbol **, long));
static void mark_symbols_used_in_relocations
  PARAMS ((bfd *, asection *, PTR));
static void filter_bytes
  PARAMS ((char *, bfd_size_type *));
static bfd_boolean write_debugging_info
  PARAMS ((bfd *, PTR, long *, asymbol ***));
static void copy_object
  PARAMS ((bfd *, bfd *));
static void copy_archive
  PARAMS ((bfd *, bfd *, const char *));
static void copy_file
  PARAMS ((const char *, const char *, const char *, const char *));
static int strip_main
  PARAMS ((int, char **));
static int copy_main
  PARAMS ((int, char **));
static const char *lookup_sym_redefinition
  PARAMS((const char *));
static void redefine_list_append
  PARAMS ((const char *, const char *));
static const char * find_section_rename
  PARAMS ((bfd *, sec_ptr, flagword *));
static void add_section_rename
  PARAMS ((const char *, const char *, flagword));

#define RETURN_NONFATAL(s) {bfd_nonfatal (s); status = 1; return;}

static asymbol **isympp = NULL;	/* Input symbols */
static asymbol **osympp = NULL;	/* Output symbols that survive stripping */

/* If `copy_byte' >= 0, copy only that byte of every `interleave' bytes.  */
static int copy_byte = -1;
static int interleave = 4;

static bfd_boolean verbose;		/* Print file and target names.  */
static bfd_boolean preserve_dates;	/* Preserve input file timestamp.  */
static int status = 0;		/* Exit status.  */

enum strip_action
  {
    STRIP_UNDEF,
    STRIP_NONE,			/* don't strip */
    STRIP_DEBUG,		/* strip all debugger symbols */
    STRIP_UNNEEDED,		/* strip unnecessary symbols */
    STRIP_ALL			/* strip all symbols */
  };

/* Which symbols to remove.  */
static enum strip_action strip_symbols;

enum locals_action
  {
    LOCALS_UNDEF,
    LOCALS_START_L,		/* discard locals starting with L */
    LOCALS_ALL			/* discard all locals */
  };

/* Which local symbols to remove.  Overrides STRIP_ALL.  */
static enum locals_action discard_locals;

/* What kind of change to perform.  */
enum change_action
{
  CHANGE_IGNORE,
  CHANGE_MODIFY,
  CHANGE_SET
};

/* Structure used to hold lists of sections and actions to take.  */
struct section_list
{
  struct section_list * next;	   /* Next section to change.  */
  const char *		name;	   /* Section name.  */
  bfd_boolean		used;	   /* Whether this entry was used.  */
  bfd_boolean		remove;	   /* Whether to remove this section.  */
  bfd_boolean		copy;	   /* Whether to copy this section.  */
  enum change_action	change_vma;/* Whether to change or set VMA.  */
  bfd_vma		vma_val;   /* Amount to change by or set to.  */
  enum change_action	change_lma;/* Whether to change or set LMA.  */
  bfd_vma		lma_val;   /* Amount to change by or set to.  */
  bfd_boolean		set_flags; /* Whether to set the section flags.	 */
  flagword		flags;	   /* What to set the section flags to.	 */
};

static struct section_list *change_sections;

/* TRUE if some sections are to be removed.  */
static bfd_boolean sections_removed;

/* TRUE if only some sections are to be copied.  */
static bfd_boolean sections_copied;

/* Changes to the start address.  */
static bfd_vma change_start = 0;
static bfd_boolean set_start_set = FALSE;
static bfd_vma set_start;

/* Changes to section addresses.  */
static bfd_vma change_section_address = 0;

/* Filling gaps between sections.  */
static bfd_boolean gap_fill_set = FALSE;
static bfd_byte gap_fill = 0;

/* Pad to a given address.  */
static bfd_boolean pad_to_set = FALSE;
static bfd_vma pad_to;

/* Use alternate machine code?  */
static int use_alt_mach_code = 0;

/* List of sections to add.  */
struct section_add
{
  /* Next section to add.  */
  struct section_add *next;
  /* Name of section to add.  */
  const char *name;
  /* Name of file holding section contents.  */
  const char *filename;
  /* Size of file.  */
  size_t size;
  /* Contents of file.  */
  bfd_byte *contents;
  /* BFD section, after it has been added.  */
  asection *section;
};

/* List of sections to add to the output BFD.  */
static struct section_add *add_sections;

/* Whether to convert debugging information.  */
static bfd_boolean convert_debugging = FALSE;

/* Whether to change the leading character in symbol names.  */
static bfd_boolean change_leading_char = FALSE;

/* Whether to remove the leading character from global symbol names.  */
static bfd_boolean remove_leading_char = FALSE;

/* List of symbols to strip, keep, localize, keep-global, weaken,
   or redefine.  */
static struct symlist *strip_specific_list = NULL;
static struct symlist *keep_specific_list = NULL;
static struct symlist *localize_specific_list = NULL;
static struct symlist *keepglobal_specific_list = NULL;
static struct symlist *weaken_specific_list = NULL;
static struct redefine_node *redefine_sym_list = NULL;

/* If this is TRUE, we weaken global symbols (set BSF_WEAK).  */
static bfd_boolean weaken = FALSE;

/* Prefix symbols/sections.  */
static char *prefix_symbols_string = 0;
static char *prefix_sections_string = 0;
static char *prefix_alloc_sections_string = 0;

/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */

#define OPTION_ADD_SECTION 150
#define OPTION_CHANGE_ADDRESSES (OPTION_ADD_SECTION + 1)
#define OPTION_CHANGE_LEADING_CHAR (OPTION_CHANGE_ADDRESSES + 1)
#define OPTION_CHANGE_START (OPTION_CHANGE_LEADING_CHAR + 1)
#define OPTION_CHANGE_SECTION_ADDRESS (OPTION_CHANGE_START + 1)
#define OPTION_CHANGE_SECTION_LMA (OPTION_CHANGE_SECTION_ADDRESS + 1)
#define OPTION_CHANGE_SECTION_VMA (OPTION_CHANGE_SECTION_LMA + 1)
#define OPTION_CHANGE_WARNINGS (OPTION_CHANGE_SECTION_VMA + 1)
#define OPTION_DEBUGGING (OPTION_CHANGE_WARNINGS + 1)
#define OPTION_GAP_FILL (OPTION_DEBUGGING + 1)
#define OPTION_NO_CHANGE_WARNINGS (OPTION_GAP_FILL + 1)
#define OPTION_PAD_TO (OPTION_NO_CHANGE_WARNINGS + 1)
#define OPTION_REMOVE_LEADING_CHAR (OPTION_PAD_TO + 1)
#define OPTION_SET_SECTION_FLAGS (OPTION_REMOVE_LEADING_CHAR + 1)
#define OPTION_SET_START (OPTION_SET_SECTION_FLAGS + 1)
#define OPTION_STRIP_UNNEEDED (OPTION_SET_START + 1)
#define OPTION_WEAKEN (OPTION_STRIP_UNNEEDED + 1)
#define OPTION_REDEFINE_SYM (OPTION_WEAKEN + 1)
#define OPTION_SREC_LEN (OPTION_REDEFINE_SYM + 1)
#define OPTION_SREC_FORCES3 (OPTION_SREC_LEN + 1)
#define OPTION_STRIP_SYMBOLS (OPTION_SREC_FORCES3 + 1)
#define OPTION_KEEP_SYMBOLS (OPTION_STRIP_SYMBOLS + 1)
#define OPTION_LOCALIZE_SYMBOLS (OPTION_KEEP_SYMBOLS + 1)
#define OPTION_KEEPGLOBAL_SYMBOLS (OPTION_LOCALIZE_SYMBOLS + 1)
#define OPTION_WEAKEN_SYMBOLS (OPTION_KEEPGLOBAL_SYMBOLS + 1)
#define OPTION_RENAME_SECTION (OPTION_WEAKEN_SYMBOLS + 1)
#define OPTION_ALT_MACH_CODE (OPTION_RENAME_SECTION + 1)
#define OPTION_PREFIX_SYMBOLS (OPTION_ALT_MACH_CODE + 1)
#define OPTION_PREFIX_SECTIONS (OPTION_PREFIX_SYMBOLS + 1)
#define OPTION_PREFIX_ALLOC_SECTIONS (OPTION_PREFIX_SECTIONS + 1)
#define OPTION_FORMATS_INFO (OPTION_PREFIX_ALLOC_SECTIONS + 1)

/* Options to handle if running as "strip".  */

static struct option strip_options[] =
{
  {"discard-all", no_argument, 0, 'x'},
  {"discard-locals", no_argument, 0, 'X'},
  {"format", required_argument, 0, 'F'}, /* Obsolete */
  {"help", no_argument, 0, 'h'},
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
  {"input-format", required_argument, 0, 'I'}, /* Obsolete */
  {"input-target", required_argument, 0, 'I'},
  {"keep-symbol", required_argument, 0, 'K'},
  {"output-format", required_argument, 0, 'O'},	/* Obsolete */
  {"output-target", required_argument, 0, 'O'},
  {"output-file", required_argument, 0, 'o'},
  {"preserve-dates", no_argument, 0, 'p'},
  {"remove-section", required_argument, 0, 'R'},
  {"strip-all", no_argument, 0, 's'},
  {"strip-debug", no_argument, 0, 'S'},
  {"strip-unneeded", no_argument, 0, OPTION_STRIP_UNNEEDED},
  {"strip-symbol", required_argument, 0, 'N'},
  {"target", required_argument, 0, 'F'},
  {"verbose", no_argument, 0, 'v'},
  {"version", no_argument, 0, 'V'},
  {0, no_argument, 0, 0}
};

/* Options to handle if running as "objcopy".  */

static struct option copy_options[] =
{
  {"add-section", required_argument, 0, OPTION_ADD_SECTION},
  {"adjust-start", required_argument, 0, OPTION_CHANGE_START},
  {"adjust-vma", required_argument, 0, OPTION_CHANGE_ADDRESSES},
  {"adjust-section-vma", required_argument, 0, OPTION_CHANGE_SECTION_ADDRESS},
  {"adjust-warnings", no_argument, 0, OPTION_CHANGE_WARNINGS},
  {"alt-machine-code", required_argument, 0, OPTION_ALT_MACH_CODE},
  {"binary-architecture", required_argument, 0, 'B'},
  {"byte", required_argument, 0, 'b'},
  {"change-addresses", required_argument, 0, OPTION_CHANGE_ADDRESSES},
  {"change-leading-char", no_argument, 0, OPTION_CHANGE_LEADING_CHAR},
  {"change-section-address", required_argument, 0, OPTION_CHANGE_SECTION_ADDRESS},
  {"change-section-lma", required_argument, 0, OPTION_CHANGE_SECTION_LMA},
  {"change-section-vma", required_argument, 0, OPTION_CHANGE_SECTION_VMA},
  {"change-start", required_argument, 0, OPTION_CHANGE_START},
  {"change-warnings", no_argument, 0, OPTION_CHANGE_WARNINGS},
  {"debugging", no_argument, 0, OPTION_DEBUGGING},
  {"discard-all", no_argument, 0, 'x'},
  {"discard-locals", no_argument, 0, 'X'},
  {"format", required_argument, 0, 'F'}, /* Obsolete */
  {"gap-fill", required_argument, 0, OPTION_GAP_FILL},
  {"help", no_argument, 0, 'h'},
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
  {"input-format", required_argument, 0, 'I'}, /* Obsolete */
  {"input-target", required_argument, 0, 'I'},
  {"interleave", required_argument, 0, 'i'},
  {"keep-global-symbol", required_argument, 0, 'G'},
  {"keep-global-symbols", required_argument, 0, OPTION_KEEPGLOBAL_SYMBOLS},
  {"keep-symbol", required_argument, 0, 'K'},
  {"keep-symbols", required_argument, 0, OPTION_KEEP_SYMBOLS},
  {"localize-symbol", required_argument, 0, 'L'},
  {"localize-symbols", required_argument, 0, OPTION_LOCALIZE_SYMBOLS},
  {"no-adjust-warnings", no_argument, 0, OPTION_NO_CHANGE_WARNINGS},
  {"no-change-warnings", no_argument, 0, OPTION_NO_CHANGE_WARNINGS},
  {"only-section", required_argument, 0, 'j'},
  {"output-format", required_argument, 0, 'O'},	/* Obsolete */
  {"output-target", required_argument, 0, 'O'},
  {"pad-to", required_argument, 0, OPTION_PAD_TO},
  {"prefix-symbols", required_argument, 0, OPTION_PREFIX_SYMBOLS},
  {"prefix-sections", required_argument, 0, OPTION_PREFIX_SECTIONS},
  {"prefix-alloc-sections", required_argument, 0, OPTION_PREFIX_ALLOC_SECTIONS},
  {"preserve-dates", no_argument, 0, 'p'},
  {"redefine-sym", required_argument, 0, OPTION_REDEFINE_SYM},
  {"remove-leading-char", no_argument, 0, OPTION_REMOVE_LEADING_CHAR},
  {"remove-section", required_argument, 0, 'R'},
  {"rename-section", required_argument, 0, OPTION_RENAME_SECTION},
  {"set-section-flags", required_argument, 0, OPTION_SET_SECTION_FLAGS},
  {"set-start", required_argument, 0, OPTION_SET_START},
  {"srec-len", required_argument, 0, OPTION_SREC_LEN},
  {"srec-forceS3", no_argument, 0, OPTION_SREC_FORCES3},
  {"strip-all", no_argument, 0, 'S'},
  {"strip-debug", no_argument, 0, 'g'},
  {"strip-unneeded", no_argument, 0, OPTION_STRIP_UNNEEDED},
  {"strip-symbol", required_argument, 0, 'N'},
  {"strip-symbols", required_argument, 0, OPTION_STRIP_SYMBOLS},
  {"target", required_argument, 0, 'F'},
  {"verbose", no_argument, 0, 'v'},
  {"version", no_argument, 0, 'V'},
  {"weaken", no_argument, 0, OPTION_WEAKEN},
  {"weaken-symbol", required_argument, 0, 'W'},
  {"weaken-symbols", required_argument, 0, OPTION_WEAKEN_SYMBOLS},
  {0, no_argument, 0, 0}
};

/* IMPORTS */
extern char *program_name;

/* This flag distinguishes between strip and objcopy:
   1 means this is 'strip'; 0 means this is 'objcopy'.
   -1 means if we should use argv[0] to decide.  */
extern int is_strip;

/* The maximum length of an S record.  This variable is declared in srec.c
   and can be modified by the --srec-len parameter.  */
extern unsigned int Chunk;

/* Restrict the generation of Srecords to type S3 only.
   This variable is declare in bfd/srec.c and can be toggled
   on by the --srec-forceS3 command line switch.  */
extern bfd_boolean S3Forced;

/* Defined in bfd/binary.c.  Used to set architecture of input binary files.  */
extern enum bfd_architecture bfd_external_binary_architecture;


static void
copy_usage (stream, exit_status)
     FILE *stream;
     int exit_status;
{
  fprintf (stream, _("Usage: %s [option(s)] in-file [out-file]\n"), program_name);
  fprintf (stream, _(" Copies a binary file, possibly transforming it in the process\n"));
  fprintf (stream, _(" The options are:\n"));
  fprintf (stream, _("\
  -I --input-target <bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target <bfdname>     Create an output file in format <bfdname>\n\
  -B --binary-architecture <arch>  Set arch of output file, when input is binary\n\
  -F --target <bfdname>            Set both input and output format to <bfdname>\n\
     --debugging                   Convert debugging information, if possible\n\
  -p --preserve-dates              Copy modified/access timestamps to the output\n\
  -j --only-section <name>         Only copy section <name> into the output\n\
  -R --remove-section <name>       Remove section <name> from the output\n\
  -S --strip-all                   Remove all symbol and relocation information\n\
  -g --strip-debug                 Remove all debugging symbols\n\
     --strip-unneeded              Remove all symbols not needed by relocations\n\
  -N --strip-symbol <name>         Do not copy symbol <name>\n\
  -K --keep-symbol <name>          Only copy symbol <name>\n\
  -L --localize-symbol <name>      Force symbol <name> to be marked as a local\n\
  -G --keep-global-symbol <name>   Localize all symbols except <name>\n\
  -W --weaken-symbol <name>        Force symbol <name> to be marked as a weak\n\
     --weaken                      Force all global symbols to be marked as weak\n\
  -x --discard-all                 Remove all non-global symbols\n\
  -X --discard-locals              Remove any compiler-generated symbols\n\
  -i --interleave <number>         Only copy one out of every <number> bytes\n\
  -b --byte <num>                  Select byte <num> in every interleaved block\n\
     --gap-fill <val>              Fill gaps between sections with <val>\n\
     --pad-to <addr>               Pad the last section up to address <addr>\n\
     --set-start <addr>            Set the start address to <addr>\n\
    {--change-start|--adjust-start} <incr>\n\
                                   Add <incr> to the start address\n\
    {--change-addresses|--adjust-vma} <incr>\n\
                                   Add <incr> to LMA, VMA and start addresses\n\
    {--change-section-address|--adjust-section-vma} <name>{=|+|-}<val>\n\
                                   Change LMA and VMA of section <name> by <val>\n\
     --change-section-lma <name>{=|+|-}<val>\n\
                                   Change the LMA of section <name> by <val>\n\
     --change-section-vma <name>{=|+|-}<val>\n\
                                   Change the VMA of section <name> by <val>\n\
    {--[no-]change-warnings|--[no-]adjust-warnings}\n\
                                   Warn if a named section does not exist\n\
     --set-section-flags <name>=<flags>\n\
                                   Set section <name>'s properties to <flags>\n\
     --add-section <name>=<file>   Add section <name> found in <file> to output\n\
     --rename-section <old>=<new>[,<flags>] Rename section <old> to <new>\n\
     --change-leading-char         Force output format's leading character style\n\
     --remove-leading-char         Remove leading character from global symbols\n\
     --redefine-sym <old>=<new>    Redefine symbol name <old> to <new>\n\
     --srec-len <number>           Restrict the length of generated Srecords\n\
     --srec-forceS3                Restrict the type of generated Srecords to S3\n\
     --strip-symbols <file>        -N for all symbols listed in <file>\n\
     --keep-symbols <file>         -K for all symbols listed in <file>\n\
     --localize-symbols <file>     -L for all symbols listed in <file>\n\
     --keep-global-symbols <file>  -G for all symbols listed in <file>\n\
     --weaken-symbols <file>       -W for all symbols listed in <file>\n\
     --alt-machine-code <index>    Use alternate machine code for output\n\
     --prefix-symbols <prefix>     Add <prefix> to start of every symbol name\n\
     --prefix-sections <prefix>    Add <prefix> to start of every section name\n\
     --prefix-alloc-sections <prefix>\n\
                                   Add <prefix> to start of every allocatable\n\
                                     section name\n\
  -v --verbose                     List all object files modified\n\
  -V --version                     Display this program's version number\n\
  -h --help                        Display this output\n\
     --info                        List object formats & architectures supported\n\
"));
  list_supported_targets (program_name, stream);
  if (exit_status == 0)
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (exit_status);
}

static void
strip_usage (stream, exit_status)
     FILE *stream;
     int exit_status;
{
  fprintf (stream, _("Usage: %s <option(s)> in-file(s)\n"), program_name);
  fprintf (stream, _(" Removes symbols and sections from files\n"));
  fprintf (stream, _(" The options are:\n"));
  fprintf (stream, _("\
  -I --input-target=<bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target=<bfdname>     Create an output file in format <bfdname>\n\
  -F --target=<bfdname>            Set both input and output format to <bfdname>\n\
  -p --preserve-dates              Copy modified/access timestamps to the output\n\
  -R --remove-section=<name>       Remove section <name> from the output\n\
  -s --strip-all                   Remove all symbol and relocation information\n\
  -g -S -d --strip-debug           Remove all debugging symbols\n\
     --strip-unneeded              Remove all symbols not needed by relocations\n\
  -N --strip-symbol=<name>         Do not copy symbol <name>\n\
  -K --keep-symbol=<name>          Only copy symbol <name>\n\
  -x --discard-all                 Remove all non-global symbols\n\
  -X --discard-locals              Remove any compiler-generated symbols\n\
  -v --verbose                     List all object files modified\n\
  -V --version                     Display this program's version number\n\
  -h --help                        Display this output\n\
     --info                        List object formats & architectures supported\n\
  -o <file>                        Place stripped output into <file>\n\
"));

  list_supported_targets (program_name, stream);
  if (exit_status == 0)
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (exit_status);
}

/* Parse section flags into a flagword, with a fatal error if the
   string can't be parsed.  */

static flagword
parse_flags (s)
     const char *s;
{
  flagword ret;
  const char *snext;
  int len;

  ret = SEC_NO_FLAGS;

  do
    {
      snext = strchr (s, ',');
      if (snext == NULL)
	len = strlen (s);
      else
	{
	  len = snext - s;
	  ++snext;
	}

      if (0) ;
#define PARSE_FLAG(fname,fval) \
  else if (strncasecmp (fname, s, len) == 0) ret |= fval
      PARSE_FLAG ("alloc", SEC_ALLOC);
      PARSE_FLAG ("load", SEC_LOAD);
      PARSE_FLAG ("noload", SEC_NEVER_LOAD);
      PARSE_FLAG ("readonly", SEC_READONLY);
      PARSE_FLAG ("debug", SEC_DEBUGGING);
      PARSE_FLAG ("code", SEC_CODE);
      PARSE_FLAG ("data", SEC_DATA);
      PARSE_FLAG ("rom", SEC_ROM);
      PARSE_FLAG ("share", SEC_SHARED);
      PARSE_FLAG ("contents", SEC_HAS_CONTENTS);
#undef PARSE_FLAG
      else
	{
	  char *copy;

	  copy = xmalloc (len + 1);
	  strncpy (copy, s, len);
	  copy[len] = '\0';
	  non_fatal (_("unrecognized section flag `%s'"), copy);
	  fatal (_("supported flags: %s"),
		 "alloc, load, noload, readonly, debug, code, data, rom, share, contents");
	}

      s = snext;
    }
  while (s != NULL);

  return ret;
}

/* Find and optionally add an entry in the change_sections list.  */

static struct section_list *
find_section_list (name, add)
     const char *name;
     bfd_boolean add;
{
  register struct section_list *p;

  for (p = change_sections; p != NULL; p = p->next)
    if (strcmp (p->name, name) == 0)
      return p;

  if (! add)
    return NULL;

  p = (struct section_list *) xmalloc (sizeof (struct section_list));
  p->name = name;
  p->used = FALSE;
  p->remove = FALSE;
  p->copy = FALSE;
  p->change_vma = CHANGE_IGNORE;
  p->change_lma = CHANGE_IGNORE;
  p->vma_val = 0;
  p->lma_val = 0;
  p->set_flags = FALSE;
  p->flags = 0;

  p->next = change_sections;
  change_sections = p;

  return p;
}

/* Add a symbol to strip_specific_list.  */

static void
add_specific_symbol (name, list)
     const char *name;
     struct symlist **list;
{
  struct symlist *tmp_list;

  tmp_list = (struct symlist *) xmalloc (sizeof (struct symlist));
  tmp_list->name = name;
  tmp_list->next = *list;
  *list = tmp_list;
}

/* Add symbols listed in `filename' to strip_specific_list.  */

#define IS_WHITESPACE(c)      ((c) == ' ' || (c) == '\t')
#define IS_LINE_TERMINATOR(c) ((c) == '\n' || (c) == '\r' || (c) == '\0')

static void
add_specific_symbols (filename, list)
     const char *filename;
     struct symlist **list;
{
  struct stat st;
  FILE * f;
  char * line;
  char * buffer;
  unsigned int line_count;

  if (stat (filename, & st) < 0)
    fatal (_("cannot stat: %s: %s"), filename, strerror (errno));
  if (st.st_size == 0)
    return;

  buffer = (char *) xmalloc (st.st_size + 2);
  f = fopen (filename, FOPEN_RT);
  if (f == NULL)
    fatal (_("cannot open: %s: %s"), filename, strerror (errno));

  if (fread (buffer, 1, st.st_size, f) == 0 || ferror (f))
    fatal (_("%s: fread failed"), filename);

  fclose (f);
  buffer [st.st_size] = '\n';
  buffer [st.st_size + 1] = '\0';

  line_count = 1;

  for (line = buffer; * line != '\0'; line ++)
    {
      char * eol;
      char * name;
      char * name_end;
      int finished = FALSE;

      for (eol = line;; eol ++)
	{
	  switch (* eol)
	    {
	    case '\n':
	      * eol = '\0';
	      /* Cope with \n\r.  */
	      if (eol[1] == '\r')
		++ eol;
	      finished = TRUE;
	      break;

	    case '\r':
	      * eol = '\0';
	      /* Cope with \r\n.  */
	      if (eol[1] == '\n')
		++ eol;
	      finished = TRUE;
	      break;

	    case 0:
	      finished = TRUE;
	      break;

	    case '#':
	      /* Line comment, Terminate the line here, in case a
		 name is present and then allow the rest of the
		 loop to find the real end of the line.  */
	      * eol = '\0';
	      break;

	    default:
	      break;
	    }

	  if (finished)
	    break;
	}

      /* A name may now exist somewhere between 'line' and 'eol'.
	 Strip off leading whitespace and trailing whitespace,
	 then add it to the list.  */
      for (name = line; IS_WHITESPACE (* name); name ++)
	;
      for (name_end = name;
	   (! IS_WHITESPACE (* name_end))
	   && (! IS_LINE_TERMINATOR (* name_end));
	   name_end ++)
	;

      if (! IS_LINE_TERMINATOR (* name_end))
	{
	  char * extra;

	  for (extra = name_end + 1; IS_WHITESPACE (* extra); extra ++)
	    ;

	  if (! IS_LINE_TERMINATOR (* extra))
	    non_fatal (_("Ignoring rubbish found on line %d of %s"),
		       line_count, filename);
	}

      * name_end = '\0';

      if (name_end > name)
	add_specific_symbol (name, list);

      /* Advance line pointer to end of line.  The 'eol ++' in the for
	 loop above will then advance us to the start of the next line.  */
      line = eol;
      line_count ++;
    }
}

/* See whether a symbol should be stripped or kept based on
   strip_specific_list and keep_symbols.  */

static bfd_boolean
is_specified_symbol (name, list)
     const char *name;
     struct symlist *list;
{
  struct symlist *tmp_list;

  for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
    if (strcmp (name, tmp_list->name) == 0)
      return TRUE;

  return FALSE;
}

/* See if a section is being removed.  */

static bfd_boolean
is_strip_section (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
{
  struct section_list *p;

  if ((bfd_get_section_flags (abfd, sec) & SEC_DEBUGGING) != 0
      && (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
	  || convert_debugging))
    return TRUE;

  if (! sections_removed && ! sections_copied)
    return FALSE;

  p = find_section_list (bfd_get_section_name (abfd, sec), FALSE);
  if (sections_removed && p != NULL && p->remove)
    return TRUE;
  if (sections_copied && (p == NULL || ! p->copy))
    return TRUE;
  return FALSE;
}

/* Choose which symbol entries to copy; put the result in OSYMS.
   We don't copy in place, because that confuses the relocs.
   Return the number of symbols to print.  */

static unsigned int
filter_symbols (abfd, obfd, osyms, isyms, symcount)
     bfd *abfd;
     bfd *obfd;
     asymbol **osyms, **isyms;
     long symcount;
{
  register asymbol **from = isyms, **to = osyms;
  long src_count = 0, dst_count = 0;
  int relocatable = (abfd->flags & (HAS_RELOC | EXEC_P | DYNAMIC))
		    == HAS_RELOC;

  for (; src_count < symcount; src_count++)
    {
      asymbol *sym = from[src_count];
      flagword flags = sym->flags;
      char *name = (char *) bfd_asymbol_name (sym);
      int keep;
      bfd_boolean undefined;
      bfd_boolean rem_leading_char;
      bfd_boolean add_leading_char;

      undefined = bfd_is_und_section (bfd_get_section (sym));

      if (redefine_sym_list)
	{
	  char *old_name, *new_name;

	  old_name = (char *) bfd_asymbol_name (sym);
	  new_name = (char *) lookup_sym_redefinition (old_name);
	  bfd_asymbol_name (sym) = new_name;
	  name = new_name;
	}

      /* Check if we will remove the current leading character.  */
      rem_leading_char =
	(name[0] == bfd_get_symbol_leading_char (abfd))
	&& (change_leading_char
	    || (remove_leading_char
		&& ((flags & (BSF_GLOBAL | BSF_WEAK)) != 0
		    || undefined
		    || bfd_is_com_section (bfd_get_section (sym)))));

      /* Check if we will add a new leading character.  */
      add_leading_char =
	change_leading_char
	&& (bfd_get_symbol_leading_char (obfd) != '\0')
	&& (bfd_get_symbol_leading_char (abfd) == '\0'
	    || (name[0] == bfd_get_symbol_leading_char (abfd)));

      /* Short circuit for change_leading_char if we can do it in-place.  */
      if (rem_leading_char && add_leading_char && !prefix_symbols_string)
        {
	  name[0] = bfd_get_symbol_leading_char (obfd);
	  bfd_asymbol_name (sym) = name;
	  rem_leading_char = FALSE;
	  add_leading_char = FALSE;
        }

      /* Remove leading char.  */
      if (rem_leading_char)
	bfd_asymbol_name (sym) = ++name;

      /* Add new leading char and/or prefix.  */
      if (add_leading_char || prefix_symbols_string)
        {
          char *n, *ptr;

          ptr = n = xmalloc (1 + strlen (prefix_symbols_string) + strlen (name) + 1);
          if (add_leading_char)
	    *ptr++ = bfd_get_symbol_leading_char (obfd);

          if (prefix_symbols_string)
            {
              strcpy (ptr, prefix_symbols_string);
              ptr += strlen (prefix_symbols_string);
           }

          strcpy (ptr, name);
          bfd_asymbol_name (sym) = n;
          name = n;
	}

      if (strip_symbols == STRIP_ALL)
	keep = 0;
      else if ((flags & BSF_KEEP) != 0		/* Used in relocation.  */
	       || ((flags & BSF_SECTION_SYM) != 0
		   && ((*bfd_get_section (sym)->symbol_ptr_ptr)->flags
		       & BSF_KEEP) != 0))
	keep = 1;
      else if (relocatable			/* Relocatable file.  */
	       && (flags & (BSF_GLOBAL | BSF_WEAK)) != 0)
	keep = 1;
      else if (bfd_decode_symclass (sym) == 'I')
	/* Global symbols in $idata sections need to be retained
	   even if relocatable is FALSE.  External users of the
	   library containing the $idata section may reference these
	   symbols.  */
	keep = 1;
      else if ((flags & BSF_GLOBAL) != 0	/* Global symbol.  */
	       || (flags & BSF_WEAK) != 0
	       || undefined
	       || bfd_is_com_section (bfd_get_section (sym)))
	keep = strip_symbols != STRIP_UNNEEDED;
      else if ((flags & BSF_DEBUGGING) != 0)	/* Debugging symbol.  */
	keep = (strip_symbols != STRIP_DEBUG
		&& strip_symbols != STRIP_UNNEEDED
		&& ! convert_debugging);
      else if (bfd_get_section (sym)->comdat)
	/* COMDAT sections store special information in local
	   symbols, so we cannot risk stripping any of them.  */
	keep = 1;
      else			/* Local symbol.  */
	keep = (strip_symbols != STRIP_UNNEEDED
		&& (discard_locals != LOCALS_ALL
		    && (discard_locals != LOCALS_START_L
			|| ! bfd_is_local_label (abfd, sym))));

      if (keep && is_specified_symbol (name, strip_specific_list))
	keep = 0;
      if (!keep && is_specified_symbol (name, keep_specific_list))
	keep = 1;
      if (keep && is_strip_section (abfd, bfd_get_section (sym)))
	keep = 0;

      if (keep && (flags & BSF_GLOBAL) != 0
	  && (weaken || is_specified_symbol (name, weaken_specific_list)))
	{
	  sym->flags &=~ BSF_GLOBAL;
	  sym->flags |= BSF_WEAK;
	}
      if (keep && !undefined && (flags & (BSF_GLOBAL | BSF_WEAK))
	  && (is_specified_symbol (name, localize_specific_list)
	      || (keepglobal_specific_list != NULL
		  && ! is_specified_symbol (name, keepglobal_specific_list))))
	{
	  sym->flags &= ~(BSF_GLOBAL | BSF_WEAK);
	  sym->flags |= BSF_LOCAL;
	}

      if (keep)
	to[dst_count++] = sym;
    }

  to[dst_count] = NULL;

  return dst_count;
}

/* Find the redefined name of symbol SOURCE.  */

static const char *
lookup_sym_redefinition (source)
     const char *source;
{
  struct redefine_node *list;

  for (list = redefine_sym_list; list != NULL; list = list->next)
    if (strcmp (source, list->source) == 0)
      return list->target;

  return source;
}

/* Add a node to a symbol redefine list.  */

static void
redefine_list_append (source, target)
     const char *source;
     const char *target;
{
  struct redefine_node **p;
  struct redefine_node *list;
  struct redefine_node *new_node;

  for (p = &redefine_sym_list; (list = *p) != NULL; p = &list->next)
    {
      if (strcmp (source, list->source) == 0)
	fatal (_("%s: Multiple redefinition of symbol \"%s\""),
	       "--redefine-sym",
	       source);

      if (strcmp (target, list->target) == 0)
	fatal (_("%s: Symbol \"%s\" is target of more than one redefinition"),
	       "--redefine-sym",
	       target);
    }

  new_node = (struct redefine_node *) xmalloc (sizeof (struct redefine_node));

  new_node->source = strdup (source);
  new_node->target = strdup (target);
  new_node->next = NULL;

  *p = new_node;
}

/* Keep only every `copy_byte'th byte in MEMHUNK, which is *SIZE bytes long.
   Adjust *SIZE.  */

static void
filter_bytes (memhunk, size)
     char *memhunk;
     bfd_size_type *size;
{
  char *from = memhunk + copy_byte, *to = memhunk, *end = memhunk + *size;

  for (; from < end; from += interleave)
    *to++ = *from;

  if (*size % interleave > (bfd_size_type) copy_byte)
    *size = (*size / interleave) + 1;
  else
    *size /= interleave;
}

/* Copy object file IBFD onto OBFD.  */

static void
copy_object (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  bfd_vma start;
  long symcount;
  asection **osections = NULL;
  bfd_size_type *gaps = NULL;
  bfd_size_type max_gap = 0;
  long symsize;
  PTR dhandle;
  enum bfd_architecture iarch;
  unsigned int imach;

  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      fatal (_("Unable to change endianness of input file(s)"));
      return;
    }

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    RETURN_NONFATAL (bfd_get_filename (obfd));

  if (verbose)
    printf (_("copy from %s(%s) to %s(%s)\n"),
	    bfd_get_filename (ibfd), bfd_get_target (ibfd),
	    bfd_get_filename (obfd), bfd_get_target (obfd));

  if (set_start_set)
    start = set_start;
  else
    start = bfd_get_start_address (ibfd);
  start += change_start;

  /* Neither the start address nor the flags
     need to be set for a core file.  */
  if (bfd_get_format (obfd) != bfd_core)
    {
      if (!bfd_set_start_address (obfd, start)
	  || !bfd_set_file_flags (obfd,
				  (bfd_get_file_flags (ibfd)
				   & bfd_applicable_file_flags (obfd))))
	RETURN_NONFATAL (bfd_get_filename (ibfd));
    }

  /* Copy architecture of input file to output file.  */
  iarch = bfd_get_arch (ibfd);
  imach = bfd_get_mach (ibfd);
  if (!bfd_set_arch_mach (obfd, iarch, imach)
      && (ibfd->target_defaulted
	  || bfd_get_arch (ibfd) != bfd_get_arch (obfd)))
    non_fatal (_("Warning: Output file cannot represent architecture %s"),
	       bfd_printable_arch_mach (bfd_get_arch (ibfd),
					bfd_get_mach (ibfd)));

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    RETURN_NONFATAL (bfd_get_filename (ibfd));

  if (isympp)
    free (isympp);

  if (osympp != isympp)
    free (osympp);

  /* BFD mandates that all output sections be created and sizes set before
     any output is done.  Thus, we traverse all sections multiple times.  */
  bfd_map_over_sections (ibfd, setup_section, (void *) obfd);

  if (add_sections != NULL)
    {
      struct section_add *padd;
      struct section_list *pset;

      for (padd = add_sections; padd != NULL; padd = padd->next)
	{
	  padd->section = bfd_make_section (obfd, padd->name);
	  if (padd->section == NULL)
	    {
	      non_fatal (_("can't create section `%s': %s"),
		       padd->name, bfd_errmsg (bfd_get_error ()));
	      status = 1;
	      return;
	    }
	  else
	    {
	      flagword flags;

	      if (! bfd_set_section_size (obfd, padd->section, padd->size))
		RETURN_NONFATAL (bfd_get_filename (obfd));

	      pset = find_section_list (padd->name, FALSE);
	      if (pset != NULL)
		pset->used = TRUE;

	      if (pset != NULL && pset->set_flags)
		flags = pset->flags | SEC_HAS_CONTENTS;
	      else
		flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DATA;

	      if (! bfd_set_section_flags (obfd, padd->section, flags))
		RETURN_NONFATAL (bfd_get_filename (obfd));

	      if (pset != NULL)
		{
		  if (pset->change_vma != CHANGE_IGNORE)
		    if (! bfd_set_section_vma (obfd, padd->section, pset->vma_val))
		      RETURN_NONFATAL (bfd_get_filename (obfd));

		  if (pset->change_lma != CHANGE_IGNORE)
		    {
		      padd->section->lma = pset->lma_val;

		      if (! bfd_set_section_alignment
			  (obfd, padd->section,
			   bfd_section_alignment (obfd, padd->section)))
			RETURN_NONFATAL (bfd_get_filename (obfd));
		    }
		}
	    }
	}
    }

  if (gap_fill_set || pad_to_set)
    {
      asection **set;
      unsigned int c, i;

      /* We must fill in gaps between the sections and/or we must pad
	 the last section to a specified address.  We do this by
	 grabbing a list of the sections, sorting them by VMA, and
	 increasing the section sizes as required to fill the gaps.
	 We write out the gap contents below.  */

      c = bfd_count_sections (obfd);
      osections = (asection **) xmalloc (c * sizeof (asection *));
      set = osections;
      bfd_map_over_sections (obfd, get_sections, (void *) &set);

      qsort (osections, c, sizeof (asection *), compare_section_lma);

      gaps = (bfd_size_type *) xmalloc (c * sizeof (bfd_size_type));
      memset (gaps, 0, c * sizeof (bfd_size_type));

      if (gap_fill_set)
	{
	  for (i = 0; i < c - 1; i++)
	    {
	      flagword flags;
	      bfd_size_type size;
	      bfd_vma gap_start, gap_stop;

	      flags = bfd_get_section_flags (obfd, osections[i]);
	      if ((flags & SEC_HAS_CONTENTS) == 0
		  || (flags & SEC_LOAD) == 0)
		continue;

	      size = bfd_section_size (obfd, osections[i]);
	      gap_start = bfd_section_lma (obfd, osections[i]) + size;
	      gap_stop = bfd_section_lma (obfd, osections[i + 1]);
	      if (gap_start < gap_stop)
		{
		  if (! bfd_set_section_size (obfd, osections[i],
					      size + (gap_stop - gap_start)))
		    {
		      non_fatal (_("Can't fill gap after %s: %s"),
				 bfd_get_section_name (obfd, osections[i]),
				 bfd_errmsg (bfd_get_error ()));
		      status = 1;
		      break;
		    }
		  gaps[i] = gap_stop - gap_start;
		  if (max_gap < gap_stop - gap_start)
		    max_gap = gap_stop - gap_start;
		}
	    }
	}

      if (pad_to_set)
	{
	  bfd_vma lma;
	  bfd_size_type size;

	  lma = bfd_section_lma (obfd, osections[c - 1]);
	  size = bfd_section_size (obfd, osections[c - 1]);
	  if (lma + size < pad_to)
	    {
	      if (! bfd_set_section_size (obfd, osections[c - 1],
					  pad_to - lma))
		{
		  non_fatal (_("Can't add padding to %s: %s"),
			     bfd_get_section_name (obfd, osections[c - 1]),
			     bfd_errmsg (bfd_get_error ()));
		  status = 1;
		}
	      else
		{
		  gaps[c - 1] = pad_to - (lma + size);
		  if (max_gap < pad_to - (lma + size))
		    max_gap = pad_to - (lma + size);
		}
	    }
	}
    }

  /* Symbol filtering must happen after the output sections
     have been created, but before their contents are set.  */
  dhandle = NULL;
  symsize = bfd_get_symtab_upper_bound (ibfd);
  if (symsize < 0)
    RETURN_NONFATAL (bfd_get_filename (ibfd));

  osympp = isympp = (asymbol **) xmalloc (symsize);
  symcount = bfd_canonicalize_symtab (ibfd, isympp);
  if (symcount < 0)
    RETURN_NONFATAL (bfd_get_filename (ibfd));

  if (convert_debugging)
    dhandle = read_debugging_info (ibfd, isympp, symcount);

  if (strip_symbols == STRIP_DEBUG
      || strip_symbols == STRIP_ALL
      || strip_symbols == STRIP_UNNEEDED
      || discard_locals != LOCALS_UNDEF
      || strip_specific_list != NULL
      || keep_specific_list != NULL
      || localize_specific_list != NULL
      || keepglobal_specific_list != NULL
      || weaken_specific_list != NULL
      || prefix_symbols_string
      || sections_removed
      || sections_copied
      || convert_debugging
      || change_leading_char
      || remove_leading_char
      || redefine_sym_list
      || weaken)
    {
      /* Mark symbols used in output relocations so that they
	 are kept, even if they are local labels or static symbols.

	 Note we iterate over the input sections examining their
	 relocations since the relocations for the output sections
	 haven't been set yet.  mark_symbols_used_in_relocations will
	 ignore input sections which have no corresponding output
	 section.  */
      if (strip_symbols != STRIP_ALL)
	bfd_map_over_sections (ibfd,
			       mark_symbols_used_in_relocations,
			       (PTR)isympp);
      osympp = (asymbol **) xmalloc ((symcount + 1) * sizeof (asymbol *));
      symcount = filter_symbols (ibfd, obfd, osympp, isympp, symcount);
    }

  if (convert_debugging && dhandle != NULL)
    {
      if (! write_debugging_info (obfd, dhandle, &symcount, &osympp))
	{
	  status = 1;
	  return;
	}
    }

  bfd_set_symtab (obfd, osympp, symcount);

  /* This has to happen after the symbol table has been set.  */
  bfd_map_over_sections (ibfd, copy_section, (void *) obfd);

  if (add_sections != NULL)
    {
      struct section_add *padd;

      for (padd = add_sections; padd != NULL; padd = padd->next)
	{
	  if (! bfd_set_section_contents (obfd, padd->section,
					  (PTR) padd->contents,
					  (file_ptr) 0,
					  (bfd_size_type) padd->size))
	    RETURN_NONFATAL (bfd_get_filename (obfd));
	}
    }

  if (gap_fill_set || pad_to_set)
    {
      bfd_byte *buf;
      int c, i;

      /* Fill in the gaps.  */
      if (max_gap > 8192)
	max_gap = 8192;
      buf = (bfd_byte *) xmalloc (max_gap);
      memset (buf, gap_fill, (size_t) max_gap);

      c = bfd_count_sections (obfd);
      for (i = 0; i < c; i++)
	{
	  if (gaps[i] != 0)
	    {
	      bfd_size_type left;
	      file_ptr off;

	      left = gaps[i];
	      off = bfd_section_size (obfd, osections[i]) - left;

	      while (left > 0)
		{
		  bfd_size_type now;

		  if (left > 8192)
		    now = 8192;
		  else
		    now = left;

		  if (! bfd_set_section_contents (obfd, osections[i], buf,
						  off, now))
		    RETURN_NONFATAL (bfd_get_filename (obfd));

		  left -= now;
		  off += now;
		}
	    }
	}
    }

  /* Allow the BFD backend to copy any private data it understands
     from the input BFD to the output BFD.  This is done last to
     permit the routine to look at the filtered symbol table, which is
     important for the ECOFF code at least.  */
  if (! bfd_copy_private_bfd_data (ibfd, obfd))
    {
      non_fatal (_("%s: error copying private BFD data: %s"),
		 bfd_get_filename (obfd),
		 bfd_errmsg (bfd_get_error ()));
      status = 1;
      return;
    }

  /* Switch to the alternate machine code.  We have to do this at the
     very end, because we only initialize the header when we create
     the first section.  */
  if (use_alt_mach_code != 0)
    {
      if (!bfd_alt_mach_code (obfd, use_alt_mach_code))
	non_fatal (_("unknown alternate machine code, ignored"));
    }
}

#undef MKDIR
#if defined (_WIN32) && !defined (__CYGWIN32__)
#define MKDIR(DIR, MODE) mkdir (DIR)
#else
#define MKDIR(DIR, MODE) mkdir (DIR, MODE)
#endif

/* Read each archive element in turn from IBFD, copy the
   contents to temp file, and keep the temp file handle.  */

static void
copy_archive (ibfd, obfd, output_target)
     bfd *ibfd;
     bfd *obfd;
     const char *output_target;
{
  struct name_list
    {
      struct name_list *next;
      const char *name;
      bfd *obfd;
    } *list, *l;
  bfd **ptr = &obfd->archive_head;
  bfd *this_element;
  char *dir = make_tempname (bfd_get_filename (obfd), 1);

  obfd->has_armap = ibfd->has_armap;

  list = NULL;

  this_element = bfd_openr_next_archived_file (ibfd, NULL);

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    RETURN_NONFATAL (bfd_get_filename (obfd));

  while (!status && this_element != (bfd *) NULL)
    {
      char *output_name;
      bfd *output_bfd;
      bfd *last_element;
      struct stat buf;
      int stat_status = 0;

      /* Create an output file for this member.  */
      output_name = concat (dir, "/",
			    bfd_get_filename (this_element), (char *) 0);

      /* If the file already exists, make another temp dir.  */
      if (stat (output_name, &buf) >= 0)
	{
	  output_name = make_tempname (output_name, 1);
	  if (output_name == (char *) NULL)
	    {
	      fatal (_("cannot make temp directory for archive copying (error: %s)"),
		     strerror (errno));
	    }
	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
	  l->name = output_name;
	  l->next = list;
	  l->obfd = NULL;
	  list = l;
	  output_name = concat (output_name, "/",
				bfd_get_filename (this_element), (char *) 0);
	}

      output_bfd = bfd_openw (output_name, output_target);
      if (preserve_dates)
	{
	  stat_status = bfd_stat_arch_elt (this_element, &buf);

	  if (stat_status != 0)
	    non_fatal (_("internal stat error on %s"),
		       bfd_get_filename (this_element));
	}

      l = (struct name_list *) xmalloc (sizeof (struct name_list));
      l->name = output_name;
      l->next = list;
      list = l;

      if (output_bfd == (bfd *) NULL)
	RETURN_NONFATAL (output_name);

      if (bfd_check_format (this_element, bfd_object))
	copy_object (this_element, output_bfd);

      if (!bfd_close (output_bfd))
	{
	  bfd_nonfatal (bfd_get_filename (output_bfd));
	  /* Error in new object file. Don't change archive.  */
	  status = 1;
	}

      if (preserve_dates && stat_status == 0)
	set_times (output_name, &buf);

      /* Open the newly output file and attach to our list.  */
      output_bfd = bfd_openr (output_name, output_target);

      l->obfd = output_bfd;

      *ptr = output_bfd;
      ptr = &output_bfd->next;

      last_element = this_element;

      this_element = bfd_openr_next_archived_file (ibfd, last_element);

      bfd_close (last_element);
    }
  *ptr = (bfd *) NULL;

  if (!bfd_close (obfd))
    RETURN_NONFATAL (bfd_get_filename (obfd));

  if (!bfd_close (ibfd))
    RETURN_NONFATAL (bfd_get_filename (ibfd));

  /* Delete all the files that we opened.  */
  for (l = list; l != NULL; l = l->next)
    {
      if (l->obfd == NULL)
	rmdir (l->name);
      else
	{
	  bfd_close (l->obfd);
	  unlink (l->name);
	}
    }
  rmdir (dir);
}

/* The top-level control.  */

static void
copy_file (input_filename, output_filename, input_target, output_target)
     const char *input_filename;
     const char *output_filename;
     const char *input_target;
     const char *output_target;
{
  bfd *ibfd;
  char **obj_matching;
  char **core_matching;

  /* To allow us to do "strip *" without dying on the first
     non-object file, failures are nonfatal.  */
  ibfd = bfd_openr (input_filename, input_target);
  if (ibfd == NULL)
    RETURN_NONFATAL (input_filename);

  if (bfd_check_format (ibfd, bfd_archive))
    {
      bfd *obfd;

      /* bfd_get_target does not return the correct value until
         bfd_check_format succeeds.  */
      if (output_target == NULL)
	output_target = bfd_get_target (ibfd);

      obfd = bfd_openw (output_filename, output_target);
      if (obfd == NULL)
	RETURN_NONFATAL (output_filename);

      copy_archive (ibfd, obfd, output_target);
    }
  else if (bfd_check_format_matches (ibfd, bfd_object, &obj_matching))
    {
      bfd *obfd;
    do_copy:
      /* bfd_get_target does not return the correct value until
         bfd_check_format succeeds.  */
      if (output_target == NULL)
	output_target = bfd_get_target (ibfd);

      obfd = bfd_openw (output_filename, output_target);
      if (obfd == NULL)
	RETURN_NONFATAL (output_filename);

      copy_object (ibfd, obfd);

      if (!bfd_close (obfd))
	RETURN_NONFATAL (output_filename);

      if (!bfd_close (ibfd))
	RETURN_NONFATAL (input_filename);
    }
  else
    {
      bfd_error_type obj_error = bfd_get_error ();
      bfd_error_type core_error;

      if (bfd_check_format_matches (ibfd, bfd_core, &core_matching))
	{
	  /* This probably can't happen..  */
	  if (obj_error == bfd_error_file_ambiguously_recognized)
	    free (obj_matching);
	  goto do_copy;
	}

      core_error = bfd_get_error ();
      /* Report the object error in preference to the core error.  */
      if (obj_error != core_error)
	bfd_set_error (obj_error);

      bfd_nonfatal (input_filename);

      if (obj_error == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (obj_matching);
	  free (obj_matching);
	}
      if (core_error == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (core_matching);
	  free (core_matching);
	}

      status = 1;
    }
}

/* Add a name to the section renaming list.  */

static void
add_section_rename (old_name, new_name, flags)
     const char * old_name;
     const char * new_name;
     flagword flags;
{
  section_rename * rename;

  /* Check for conflicts first.  */
  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
      {
	/* Silently ignore duplicate definitions.  */
	if (strcmp (rename->new_name, new_name) == 0
	    && rename->flags == flags)
	  return;

	fatal (_("Multiple renames of section %s"), old_name);
      }

  rename = (section_rename *) xmalloc (sizeof (* rename));

  rename->old_name = old_name;
  rename->new_name = new_name;
  rename->flags    = flags;
  rename->next     = section_rename_list;

  section_rename_list = rename;
}

/* Check the section rename list for a new name of the input section
   ISECTION.  Return the new name if one is found.
   Also set RETURNED_FLAGS to the flags to be used for this section.  */

static const char *
find_section_rename (ibfd, isection, returned_flags)
     bfd * ibfd ATTRIBUTE_UNUSED;
     sec_ptr isection;
     flagword * returned_flags;
{
  const char * old_name = bfd_section_name (ibfd, isection);
  section_rename * rename;

  /* Default to using the flags of the input section.  */
  * returned_flags = bfd_get_section_flags (ibfd, isection);

  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
      {
	if (rename->flags != (flagword) -1)
	  * returned_flags = rename->flags;

	return rename->new_name;
      }

  return old_name;
}

/* Create a section in OBFD with the same
   name and attributes as ISECTION in IBFD.  */

static void
setup_section (ibfd, isection, obfdarg)
     bfd *ibfd;
     sec_ptr isection;
     PTR obfdarg;
{
  bfd *obfd = (bfd *) obfdarg;
  struct section_list *p;
  sec_ptr osection;
  bfd_size_type size;
  bfd_vma vma;
  bfd_vma lma;
  flagword flags;
  const char *err;
  const char * name;
  char *prefix = NULL;

  if ((bfd_get_section_flags (ibfd, isection) & SEC_DEBUGGING) != 0
      && (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
	  || convert_debugging))
    return;

  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);
  if (p != NULL)
    p->used = TRUE;

  if (sections_removed && p != NULL && p->remove)
    return;
  if (sections_copied && (p == NULL || ! p->copy))
    return;

  /* Get the, possibly new, name of the output section.  */
  name = find_section_rename (ibfd, isection, & flags);

  /* Prefix sections.  */
  if ((prefix_alloc_sections_string) && (bfd_get_section_flags (ibfd, isection) & SEC_ALLOC))
    prefix = prefix_alloc_sections_string;
  else if (prefix_sections_string)
    prefix = prefix_sections_string;

  if (prefix)
    {
      char *n;

      n = xmalloc (strlen (prefix) + strlen (name) + 1);
      strcpy (n, prefix);
      strcat (n, name);
      name = n;
    }

  osection = bfd_make_section_anyway (obfd, name);

  if (osection == NULL)
    {
      err = _("making");
      goto loser;
    }

  size = bfd_section_size (ibfd, isection);
  if (copy_byte >= 0)
    size = (size + interleave - 1) / interleave;
  if (! bfd_set_section_size (obfd, osection, size))
    {
      err = _("size");
      goto loser;
    }

  vma = bfd_section_vma (ibfd, isection);
  if (p != NULL && p->change_vma == CHANGE_MODIFY)
    vma += p->vma_val;
  else if (p != NULL && p->change_vma == CHANGE_SET)
    vma = p->vma_val;
  else
    vma += change_section_address;

  if (! bfd_set_section_vma (obfd, osection, vma))
    {
      err = _("vma");
      goto loser;
    }

  lma = isection->lma;
  if ((p != NULL) && p->change_lma != CHANGE_IGNORE)
    {
      if (p->change_lma == CHANGE_MODIFY)
	lma += p->lma_val;
      else if (p->change_lma == CHANGE_SET)
	lma = p->lma_val;
      else
	abort ();
    }
  else
    lma += change_section_address;

  osection->lma = lma;

  /* FIXME: This is probably not enough.  If we change the LMA we
     may have to recompute the header for the file as well.  */
  if (!bfd_set_section_alignment (obfd,
				  osection,
				  bfd_section_alignment (ibfd, isection)))
    {
      err = _("alignment");
      goto loser;
    }

  if (p != NULL && p->set_flags)
    flags = p->flags | (flags & (SEC_HAS_CONTENTS | SEC_RELOC));
  if (!bfd_set_section_flags (obfd, osection, flags))
    {
      err = _("flags");
      goto loser;
    }

  /* Copy merge entity size.  */
  osection->entsize = isection->entsize;

  /* This used to be mangle_section; we do here to avoid using
     bfd_get_section_by_name since some formats allow multiple
     sections with the same name.  */
  isection->output_section = osection;
  isection->output_offset = 0;

  /* Allow the BFD backend to copy any private data it understands
     from the input section to the output section.  */
  if (!bfd_copy_private_section_data (ibfd, isection, obfd, osection))
    {
      err = _("private data");
      goto loser;
    }

  /* All went well.  */
  return;

loser:
  non_fatal (_("%s: section `%s': error in %s: %s"),
	     bfd_get_filename (ibfd),
	     bfd_section_name (ibfd, isection),
	     err, bfd_errmsg (bfd_get_error ()));
  status = 1;
}

/* Copy the data of input section ISECTION of IBFD
   to an output section with the same name in OBFD.
   If stripping then don't copy any relocation info.  */

static void
copy_section (ibfd, isection, obfdarg)
     bfd *ibfd;
     sec_ptr isection;
     PTR obfdarg;
{
  bfd *obfd = (bfd *) obfdarg;
  struct section_list *p;
  arelent **relpp;
  long relcount;
  sec_ptr osection;
  bfd_size_type size;
  long relsize;
  flagword flags;

  /* If we have already failed earlier on,
     do not keep on generating complaints now.  */
  if (status != 0)
    return;

  flags = bfd_get_section_flags (ibfd, isection);
  if ((flags & SEC_DEBUGGING) != 0
      && (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
	  || convert_debugging))
    return;

  if ((flags & SEC_GROUP) != 0)
    return;

  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);

  if (sections_removed && p != NULL && p->remove)
    return;
  if (sections_copied && (p == NULL || ! p->copy))
    return;

  osection = isection->output_section;
  size = bfd_get_section_size_before_reloc (isection);

  if (size == 0 || osection == 0)
    return;

  /* Core files do not need to be relocated.  */
  if (bfd_get_format (obfd) == bfd_core)
    relsize = 0;
  else
    relsize = bfd_get_reloc_upper_bound (ibfd, isection);

  if (relsize < 0)
    RETURN_NONFATAL (bfd_get_filename (ibfd));

  if (relsize == 0)
    bfd_set_reloc (obfd, osection, (arelent **) NULL, 0);
  else
    {
      relpp = (arelent **) xmalloc (relsize);
      relcount = bfd_canonicalize_reloc (ibfd, isection, relpp, isympp);
      if (relcount < 0)
	RETURN_NONFATAL (bfd_get_filename (ibfd));

      if (strip_symbols == STRIP_ALL)
	{
	  /* Remove relocations which are not in
	     keep_strip_specific_list.  */
	  arelent **temp_relpp;
	  long temp_relcount = 0;
	  long i;

	  temp_relpp = (arelent **) xmalloc (relsize);
	  for (i = 0; i < relcount; i++)
	    if (is_specified_symbol
		(bfd_asymbol_name (*relpp [i]->sym_ptr_ptr),
		 keep_specific_list))
	      temp_relpp [temp_relcount++] = relpp [i];
	  relcount = temp_relcount;
	  free (relpp);
	  relpp = temp_relpp;
	}

      bfd_set_reloc (obfd, osection,
		     (relcount == 0 ? (arelent **) NULL : relpp), relcount);
    }

  isection->_cooked_size = isection->_raw_size;
  isection->reloc_done = TRUE;

  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS
      && bfd_get_section_flags (obfd, osection) & SEC_HAS_CONTENTS)
    {
      PTR memhunk = (PTR) xmalloc ((unsigned) size);

      if (!bfd_get_section_contents (ibfd, isection, memhunk, (file_ptr) 0,
				     size))
	RETURN_NONFATAL (bfd_get_filename (ibfd));

      if (copy_byte >= 0)
	filter_bytes (memhunk, &size);

      if (!bfd_set_section_contents (obfd, osection, memhunk, (file_ptr) 0,
				     size))
	RETURN_NONFATAL (bfd_get_filename (obfd));

      free (memhunk);
    }
  else if (p != NULL && p->set_flags && (p->flags & SEC_HAS_CONTENTS) != 0)
    {
      PTR memhunk = (PTR) xmalloc ((unsigned) size);

      /* We don't permit the user to turn off the SEC_HAS_CONTENTS
	 flag--they can just remove the section entirely and add it
	 back again.  However, we do permit them to turn on the
	 SEC_HAS_CONTENTS flag, and take it to mean that the section
	 contents should be zeroed out.  */

      memset (memhunk, 0, size);
      if (! bfd_set_section_contents (obfd, osection, memhunk, (file_ptr) 0,
				      size))
	RETURN_NONFATAL (bfd_get_filename (obfd));
      free (memhunk);
    }
}

/* Get all the sections.  This is used when --gap-fill or --pad-to is
   used.  */

static void
get_sections (obfd, osection, secppparg)
     bfd *obfd ATTRIBUTE_UNUSED;
     asection *osection;
     PTR secppparg;
{
  asection ***secppp = (asection ***) secppparg;

  **secppp = osection;
  ++(*secppp);
}

/* Sort sections by VMA.  This is called via qsort, and is used when
   --gap-fill or --pad-to is used.  We force non loadable or empty
   sections to the front, where they are easier to ignore.  */

static int
compare_section_lma (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
{
  const asection **sec1 = (const asection **) arg1;
  const asection **sec2 = (const asection **) arg2;
  flagword flags1, flags2;

  /* Sort non loadable sections to the front.  */
  flags1 = (*sec1)->flags;
  flags2 = (*sec2)->flags;
  if ((flags1 & SEC_HAS_CONTENTS) == 0
      || (flags1 & SEC_LOAD) == 0)
    {
      if ((flags2 & SEC_HAS_CONTENTS) != 0
	  && (flags2 & SEC_LOAD) != 0)
	return -1;
    }
  else
    {
      if ((flags2 & SEC_HAS_CONTENTS) == 0
	  || (flags2 & SEC_LOAD) == 0)
	return 1;
    }

  /* Sort sections by LMA.  */
  if ((*sec1)->lma > (*sec2)->lma)
    return 1;
  else if ((*sec1)->lma < (*sec2)->lma)
    return -1;

  /* Sort sections with the same LMA by size.  */
  if ((*sec1)->_raw_size > (*sec2)->_raw_size)
    return 1;
  else if ((*sec1)->_raw_size < (*sec2)->_raw_size)
    return -1;

  return 0;
}

/* Mark all the symbols which will be used in output relocations with
   the BSF_KEEP flag so that those symbols will not be stripped.

   Ignore relocations which will not appear in the output file.  */

static void
mark_symbols_used_in_relocations (ibfd, isection, symbolsarg)
     bfd *ibfd;
     sec_ptr isection;
     PTR symbolsarg;
{
  asymbol **symbols = (asymbol **) symbolsarg;
  long relsize;
  arelent **relpp;
  long relcount, i;

  /* Ignore an input section with no corresponding output section.  */
  if (isection->output_section == NULL)
    return;

  relsize = bfd_get_reloc_upper_bound (ibfd, isection);
  if (relsize < 0)
    bfd_fatal (bfd_get_filename (ibfd));

  if (relsize == 0)
    return;

  relpp = (arelent **) xmalloc (relsize);
  relcount = bfd_canonicalize_reloc (ibfd, isection, relpp, symbols);
  if (relcount < 0)
    bfd_fatal (bfd_get_filename (ibfd));

  /* Examine each symbol used in a relocation.  If it's not one of the
     special bfd section symbols, then mark it with BSF_KEEP.  */
  for (i = 0; i < relcount; i++)
    {
      if (*relpp[i]->sym_ptr_ptr != bfd_com_section_ptr->symbol
	  && *relpp[i]->sym_ptr_ptr != bfd_abs_section_ptr->symbol
	  && *relpp[i]->sym_ptr_ptr != bfd_und_section_ptr->symbol)
	(*relpp[i]->sym_ptr_ptr)->flags |= BSF_KEEP;
    }

  if (relpp != NULL)
    free (relpp);
}

/* Write out debugging information.  */

static bfd_boolean
write_debugging_info (obfd, dhandle, symcountp, symppp)
     bfd *obfd;
     PTR dhandle;
     long *symcountp ATTRIBUTE_UNUSED;
     asymbol ***symppp ATTRIBUTE_UNUSED;
{
  if (bfd_get_flavour (obfd) == bfd_target_ieee_flavour)
    return write_ieee_debugging_info (obfd, dhandle);

  if (bfd_get_flavour (obfd) == bfd_target_coff_flavour
      || bfd_get_flavour (obfd) == bfd_target_elf_flavour)
    {
      bfd_byte *syms, *strings;
      bfd_size_type symsize, stringsize;
      asection *stabsec, *stabstrsec;

      if (! write_stabs_in_sections_debugging_info (obfd, dhandle, &syms,
						    &symsize, &strings,
						    &stringsize))
	return FALSE;

      stabsec = bfd_make_section (obfd, ".stab");
      stabstrsec = bfd_make_section (obfd, ".stabstr");
      if (stabsec == NULL
	  || stabstrsec == NULL
	  || ! bfd_set_section_size (obfd, stabsec, symsize)
	  || ! bfd_set_section_size (obfd, stabstrsec, stringsize)
	  || ! bfd_set_section_alignment (obfd, stabsec, 2)
	  || ! bfd_set_section_alignment (obfd, stabstrsec, 0)
	  || ! bfd_set_section_flags (obfd, stabsec,
				   (SEC_HAS_CONTENTS
				    | SEC_READONLY
				    | SEC_DEBUGGING))
	  || ! bfd_set_section_flags (obfd, stabstrsec,
				      (SEC_HAS_CONTENTS
				       | SEC_READONLY
				       | SEC_DEBUGGING)))
	{
	  non_fatal (_("%s: can't create debugging section: %s"),
		     bfd_get_filename (obfd),
		     bfd_errmsg (bfd_get_error ()));
	  return FALSE;
	}

      /* We can get away with setting the section contents now because
         the next thing the caller is going to do is copy over the
         real sections.  We may someday have to split the contents
         setting out of this function.  */
      if (! bfd_set_section_contents (obfd, stabsec, syms, (file_ptr) 0,
				      symsize)
	  || ! bfd_set_section_contents (obfd, stabstrsec, strings,
					 (file_ptr) 0, stringsize))
	{
	  non_fatal (_("%s: can't set debugging section contents: %s"),
		     bfd_get_filename (obfd),
		     bfd_errmsg (bfd_get_error ()));
	  return FALSE;
	}

      return TRUE;
    }

  non_fatal (_("%s: don't know how to write debugging information for %s"),
	     bfd_get_filename (obfd), bfd_get_target (obfd));
  return FALSE;
}

static int
strip_main (argc, argv)
     int argc;
     char *argv[];
{
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean formats_info = FALSE;
  int c;
  int i;
  struct section_list *p;
  char *output_file = NULL;

  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXHhVv",
			   strip_options, (int *) 0)) != EOF)
    {
      switch (c)
	{
	case 'I':
	  input_target = optarg;
	  break;
	case 'O':
	  output_target = optarg;
	  break;
	case 'F':
	  input_target = output_target = optarg;
	  break;
	case 'R':
	  p = find_section_list (optarg, TRUE);
	  p->remove = TRUE;
	  sections_removed = TRUE;
	  break;
	case 's':
	  strip_symbols = STRIP_ALL;
	  break;
	case 'S':
	case 'g':
	case 'd':	/* Historic BSD alias for -g.  Used by early NetBSD.  */
	  strip_symbols = STRIP_DEBUG;
	  break;
	case OPTION_STRIP_UNNEEDED:
	  strip_symbols = STRIP_UNNEEDED;
	  break;
	case 'K':
	  add_specific_symbol (optarg, &keep_specific_list);
	  break;
	case 'N':
	  add_specific_symbol (optarg, &strip_specific_list);
	  break;
	case 'o':
	  output_file = optarg;
	  break;
	case 'p':
	  preserve_dates = TRUE;
	  break;
	case 'x':
	  discard_locals = LOCALS_ALL;
	  break;
	case 'X':
	  discard_locals = LOCALS_START_L;
	  break;
	case 'v':
	  verbose = TRUE;
	  break;
	case 'V':
	  show_version = TRUE;
	  break;
	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
	  break;
	case 0:
	  /* We've been given a long option.  */
	  break;
	case 'H':
	case 'h':
	  strip_usage (stdout, 0);
	default:
	  strip_usage (stderr, 1);
	}
    }

 if (formats_info)
   {
     display_info ();
     return 0;
   }
 
  if (show_version)
    print_version ("strip");

  /* Default is to strip all symbols.  */
  if (strip_symbols == STRIP_UNDEF
      && discard_locals == LOCALS_UNDEF
      && strip_specific_list == NULL)
    strip_symbols = STRIP_ALL;

  if (output_target == (char *) NULL)
    output_target = input_target;

  i = optind;
  if (i == argc
      || (output_file != NULL && (i + 1) < argc))
    strip_usage (stderr, 1);

  for (; i < argc; i++)
    {
      int hold_status = status;
      struct stat statbuf;
      char *tmpname;

      if (preserve_dates)
	{
	  if (stat (argv[i], &statbuf) < 0)
	    {
	      non_fatal (_("%s: cannot stat: %s"), argv[i], strerror (errno));
	      continue;
	    }
	}

      if (output_file != NULL)
	tmpname = output_file;
      else
	tmpname = make_tempname (argv[i], 0);
      status = 0;

      copy_file (argv[i], tmpname, input_target, output_target);
      if (status == 0)
	{
	  if (preserve_dates)
	    set_times (tmpname, &statbuf);
	  if (output_file == NULL)
	    smart_rename (tmpname, argv[i], preserve_dates);
	  status = hold_status;
	}
      else
	unlink (tmpname);
      if (output_file == NULL)
	free (tmpname);
    }

  return 0;
}

static int
copy_main (argc, argv)
     int argc;
     char *argv[];
{
  char * binary_architecture = NULL;
  char *input_filename = NULL;
  char *output_filename = NULL;
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean change_warn = TRUE;
  bfd_boolean formats_info = FALSE;
  int c;
  struct section_list *p;
  struct stat statbuf;

  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:",
			   copy_options, (int *) 0)) != EOF)
    {
      switch (c)
	{
	case 'b':
	  copy_byte = atoi (optarg);
	  if (copy_byte < 0)
	    fatal (_("byte number must be non-negative"));
	  break;

	case 'B':
	  binary_architecture = optarg;
	  break;

	case 'i':
	  interleave = atoi (optarg);
	  if (interleave < 1)
	    fatal (_("interleave must be positive"));
	  break;

	case 'I':
	case 's':		/* "source" - 'I' is preferred */
	  input_target = optarg;
	  break;

	case 'O':
	case 'd':		/* "destination" - 'O' is preferred */
	  output_target = optarg;
	  break;

	case 'F':
	  input_target = output_target = optarg;
	  break;

	case 'j':
	  p = find_section_list (optarg, TRUE);
	  if (p->remove)
	    fatal (_("%s both copied and removed"), optarg);
	  p->copy = TRUE;
	  sections_copied = TRUE;
	  break;

	case 'R':
	  p = find_section_list (optarg, TRUE);
	  if (p->copy)
	    fatal (_("%s both copied and removed"), optarg);
	  p->remove = TRUE;
	  sections_removed = TRUE;
	  break;

	case 'S':
	  strip_symbols = STRIP_ALL;
	  break;

	case 'g':
	  strip_symbols = STRIP_DEBUG;
	  break;

	case OPTION_STRIP_UNNEEDED:
	  strip_symbols = STRIP_UNNEEDED;
	  break;

	case 'K':
	  add_specific_symbol (optarg, &keep_specific_list);
	  break;

	case 'N':
	  add_specific_symbol (optarg, &strip_specific_list);
	  break;

	case 'L':
	  add_specific_symbol (optarg, &localize_specific_list);
	  break;

	case 'G':
	  add_specific_symbol (optarg, &keepglobal_specific_list);
	  break;

	case 'W':
	  add_specific_symbol (optarg, &weaken_specific_list);
	  break;

	case 'p':
	  preserve_dates = TRUE;
	  break;

	case 'x':
	  discard_locals = LOCALS_ALL;
	  break;

	case 'X':
	  discard_locals = LOCALS_START_L;
	  break;

	case 'v':
	  verbose = TRUE;
	  break;

	case 'V':
	  show_version = TRUE;
	  break;

	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
	  break;

	case OPTION_WEAKEN:
	  weaken = TRUE;
	  break;

	case OPTION_ADD_SECTION:
	  {
	    const char *s;
	    struct stat st;
	    struct section_add *pa;
	    int len;
	    char *name;
	    FILE *f;

	    s = strchr (optarg, '=');

	    if (s == NULL)
	      fatal (_("bad format for %s"), "--add-section");

	    if (stat (s + 1, & st) < 0)
	      fatal (_("cannot stat: %s: %s"), s + 1, strerror (errno));

	    pa = (struct section_add *) xmalloc (sizeof (struct section_add));

	    len = s - optarg;
	    name = (char *) xmalloc (len + 1);
	    strncpy (name, optarg, len);
	    name[len] = '\0';
	    pa->name = name;

	    pa->filename = s + 1;

	    pa->size = st.st_size;

	    pa->contents = (bfd_byte *) xmalloc (pa->size);
	    f = fopen (pa->filename, FOPEN_RB);

	    if (f == NULL)
	      fatal (_("cannot open: %s: %s"), pa->filename, strerror (errno));

	    if (fread (pa->contents, 1, pa->size, f) == 0
		|| ferror (f))
	      fatal (_("%s: fread failed"), pa->filename);

	    fclose (f);

	    pa->next = add_sections;
	    add_sections = pa;
	  }
	  break;

	case OPTION_CHANGE_START:
	  change_start = parse_vma (optarg, "--change-start");
	  break;

	case OPTION_CHANGE_SECTION_ADDRESS:
	case OPTION_CHANGE_SECTION_LMA:
	case OPTION_CHANGE_SECTION_VMA:
	  {
	    const char *s;
	    int len;
	    char *name;
	    char *option = NULL;
	    bfd_vma val;
	    enum change_action what = CHANGE_IGNORE;

	    switch (c)
	      {
	      case OPTION_CHANGE_SECTION_ADDRESS:
		option = "--change-section-address";
		break;
	      case OPTION_CHANGE_SECTION_LMA:
		option = "--change-section-lma";
		break;
	      case OPTION_CHANGE_SECTION_VMA:
		option = "--change-section-vma";
		break;
	      }

	    s = strchr (optarg, '=');
	    if (s == NULL)
	      {
		s = strchr (optarg, '+');
		if (s == NULL)
		  {
		    s = strchr (optarg, '-');
		    if (s == NULL)
		      fatal (_("bad format for %s"), option);
		  }
	      }

	    len = s - optarg;
	    name = (char *) xmalloc (len + 1);
	    strncpy (name, optarg, len);
	    name[len] = '\0';

	    p = find_section_list (name, TRUE);

	    val = parse_vma (s + 1, option);

	    switch (*s)
	      {
	      case '=': what = CHANGE_SET; break;
	      case '-': val  = - val; /* Drop through.  */
	      case '+': what = CHANGE_MODIFY; break;
	      }

	    switch (c)
	      {
	      case OPTION_CHANGE_SECTION_ADDRESS:
		p->change_vma = what;
		p->vma_val    = val;
		/* Drop through.  */

	      case OPTION_CHANGE_SECTION_LMA:
		p->change_lma = what;
		p->lma_val    = val;
		break;

	      case OPTION_CHANGE_SECTION_VMA:
		p->change_vma = what;
		p->vma_val    = val;
		break;
	      }
	  }
	  break;

	case OPTION_CHANGE_ADDRESSES:
	  change_section_address = parse_vma (optarg, "--change-addresses");
	  change_start = change_section_address;
	  break;

	case OPTION_CHANGE_WARNINGS:
	  change_warn = TRUE;
	  break;

	case OPTION_CHANGE_LEADING_CHAR:
	  change_leading_char = TRUE;
	  break;

	case OPTION_DEBUGGING:
	  convert_debugging = TRUE;
	  break;

	case OPTION_GAP_FILL:
	  {
	    bfd_vma gap_fill_vma;

	    gap_fill_vma = parse_vma (optarg, "--gap-fill");
	    gap_fill = (bfd_byte) gap_fill_vma;
	    if ((bfd_vma) gap_fill != gap_fill_vma)
	      {
		char buff[20];

		sprintf_vma (buff, gap_fill_vma);

		non_fatal (_("Warning: truncating gap-fill from 0x%s to 0x%x"),
			   buff, gap_fill);
	      }
	    gap_fill_set = TRUE;
	  }
	  break;

	case OPTION_NO_CHANGE_WARNINGS:
	  change_warn = FALSE;
	  break;

	case OPTION_PAD_TO:
	  pad_to = parse_vma (optarg, "--pad-to");
	  pad_to_set = TRUE;
	  break;

	case OPTION_REMOVE_LEADING_CHAR:
	  remove_leading_char = TRUE;
	  break;

	case OPTION_REDEFINE_SYM:
	  {
	    /* Push this redefinition onto redefine_symbol_list.  */

	    int len;
	    const char *s;
	    const char *nextarg;
	    char *source, *target;

	    s = strchr (optarg, '=');
	    if (s == NULL)
	      fatal (_("bad format for %s"), "--redefine-sym");

	    len = s - optarg;
	    source = (char *) xmalloc (len + 1);
	    strncpy (source, optarg, len);
	    source[len] = '\0';

	    nextarg = s + 1;
	    len = strlen (nextarg);
	    target = (char *) xmalloc (len + 1);
	    strcpy (target, nextarg);

	    redefine_list_append (source, target);

	    free (source);
	    free (target);
	  }
	  break;

	case OPTION_SET_SECTION_FLAGS:
	  {
	    const char *s;
	    int len;
	    char *name;

	    s = strchr (optarg, '=');
	    if (s == NULL)
	      fatal (_("bad format for %s"), "--set-section-flags");

	    len = s - optarg;
	    name = (char *) xmalloc (len + 1);
	    strncpy (name, optarg, len);
	    name[len] = '\0';

	    p = find_section_list (name, TRUE);

	    p->set_flags = TRUE;
	    p->flags = parse_flags (s + 1);
	  }
	  break;

	case OPTION_RENAME_SECTION:
	  {
	    flagword flags;
	    const char *eq, *fl;
	    char *old_name;
	    char *new_name;
	    unsigned int len;

	    eq = strchr (optarg, '=');
	    if (eq == NULL)
	      fatal (_("bad format for %s"), "--rename-section");

	    len = eq - optarg;
	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    old_name = (char *) xmalloc (len + 1);
	    strncpy (old_name, optarg, len);
	    old_name[len] = 0;

	    eq++;
	    fl = strchr (eq, ',');
	    if (fl)
	      {
		flags = parse_flags (fl + 1);
		len = fl - eq;
	      }
	    else
	      {
		flags = -1;
		len = strlen (eq);
	      }

	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    new_name = (char *) xmalloc (len + 1);
	    strncpy (new_name, eq, len);
	    new_name[len] = 0;

	    add_section_rename (old_name, new_name, flags);
	  }
	  break;

	case OPTION_SET_START:
	  set_start = parse_vma (optarg, "--set-start");
	  set_start_set = TRUE;
	  break;

	case OPTION_SREC_LEN:
	  Chunk = parse_vma (optarg, "--srec-len");
	  break;

	case OPTION_SREC_FORCES3:
	  S3Forced = TRUE;
	  break;

	case OPTION_STRIP_SYMBOLS:
	  add_specific_symbols (optarg, &strip_specific_list);
	  break;

	case OPTION_KEEP_SYMBOLS:
	  add_specific_symbols (optarg, &keep_specific_list);
	  break;

	case OPTION_LOCALIZE_SYMBOLS:
	  add_specific_symbols (optarg, &localize_specific_list);
	  break;

	case OPTION_KEEPGLOBAL_SYMBOLS:
	  add_specific_symbols (optarg, &keepglobal_specific_list);
	  break;

	case OPTION_WEAKEN_SYMBOLS:
	  add_specific_symbols (optarg, &weaken_specific_list);
	  break;

	case OPTION_ALT_MACH_CODE:
	  use_alt_mach_code = atoi (optarg);
	  if (use_alt_mach_code <= 0)
	    fatal (_("alternate machine code index must be positive"));
	  break;

	case OPTION_PREFIX_SYMBOLS:
	  prefix_symbols_string = optarg;
	  break;

	case OPTION_PREFIX_SECTIONS:
	  prefix_sections_string = optarg;
	  break;

	case OPTION_PREFIX_ALLOC_SECTIONS:
	  prefix_alloc_sections_string = optarg;
	  break;

	case 0:
	  break;		/* we've been given a long option */

	case 'H':
	case 'h':
	  copy_usage (stdout, 0);

	default:
	  copy_usage (stderr, 1);
	}
    }

  if (formats_info)
    {
      display_info ();
      return 0;
    }

  if (show_version)
    print_version ("objcopy");

  if (copy_byte >= interleave)
    fatal (_("byte number must be less than interleave"));

  if (optind == argc || optind + 2 < argc)
    copy_usage (stderr, 1);

  input_filename = argv[optind];
  if (optind + 1 < argc)
    output_filename = argv[optind + 1];

  /* Default is to strip no symbols.  */
  if (strip_symbols == STRIP_UNDEF && discard_locals == LOCALS_UNDEF)
    strip_symbols = STRIP_NONE;

  if (output_target == (char *) NULL)
    output_target = input_target;

  if (binary_architecture != (char *) NULL)
    {
      if (input_target && strcmp (input_target, "binary") == 0)
	{
	  const bfd_arch_info_type * temp_arch_info;

	  temp_arch_info = bfd_scan_arch (binary_architecture);

	  if (temp_arch_info != NULL)
	    bfd_external_binary_architecture = temp_arch_info->arch;
	  else
	    fatal (_("architecture %s unknown"), binary_architecture);
	}
      else
	{
	  non_fatal (_("Warning: input target 'binary' required for binary architecture parameter."));
	  non_fatal (_(" Argument %s ignored"), binary_architecture);
	}
    }

  if (preserve_dates)
    if (stat (input_filename, & statbuf) < 0)
      fatal (_("Cannot stat: %s: %s"), input_filename, strerror (errno));

  /* If there is no destination file, or the source and destination files
     are the same,  then create a temp and rename the result into the input.  */
  if ((output_filename == (char *) NULL) ||
      (strcmp (input_filename, output_filename) == 0))
    {
      char *tmpname = make_tempname (input_filename, 0);

      copy_file (input_filename, tmpname, input_target, output_target);
      if (status == 0)
	{
	  if (preserve_dates)
	    set_times (tmpname, &statbuf);
	  smart_rename (tmpname, input_filename, preserve_dates);
	}
      else
	unlink (tmpname);
    }
  else
    {
      copy_file (input_filename, output_filename, input_target, output_target);

      if (status == 0 && preserve_dates)
	set_times (output_filename, &statbuf);
    }

  if (change_warn)
    {
      for (p = change_sections; p != NULL; p = p->next)
	{
	  if (! p->used)
	    {
	      if (p->change_vma != CHANGE_IGNORE)
		{
		  char buff [20];

		  sprintf_vma (buff, p->vma_val);

		  /* xgettext:c-format */
		  non_fatal (_("%s %s%c0x%s never used"),
			     "--change-section-vma",
			     p->name,
			     p->change_vma == CHANGE_SET ? '=' : '+',
			     buff);
		}

	      if (p->change_lma != CHANGE_IGNORE)
		{
		  char buff [20];

		  sprintf_vma (buff, p->lma_val);

		  /* xgettext:c-format */
		  non_fatal (_("%s %s%c0x%s never used"),
			     "--change-section-lma",
			     p->name,
			     p->change_lma == CHANGE_SET ? '=' : '+',
			     buff);
		}
	    }
	}
    }

  return 0;
}

int main PARAMS ((int, char **));

int
main (argc, argv)
     int argc;
     char *argv[];
{
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = argv[0];
  xmalloc_set_program_name (program_name);

  START_PROGRESS (program_name, 0);

  strip_symbols = STRIP_UNDEF;
  discard_locals = LOCALS_UNDEF;

  bfd_init ();
  set_default_bfd_target ();

  if (is_strip < 0)
    {
      int i = strlen (program_name);
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      /* Drop the .exe suffix, if any.  */
      if (i > 4 && FILENAME_CMP (program_name + i - 4, ".exe") == 0)
	{
	  i -= 4;
	  program_name[i] = '\0';
	}
#endif
      is_strip = (i >= 5 && FILENAME_CMP (program_name + i - 5, "strip") == 0);
    }

  if (is_strip)
    strip_main (argc, argv);
  else
    copy_main (argc, argv);

  END_PROGRESS (program_name);

  return status;
}
@


1.5
log
@first foolish attempt to merge the last piece
won't probably work, but I want it backed up,
since there's a lot of work and time in it
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/binutils/binutils/objcopy.c,v 1.4 2004/01/29 21:32:45 tg Exp $ */
@


1.4
log
@the first part of making a release (non-X)
* sync sets (for now)
* mention set sizes in INSTALL.i386
* install all files, but not more than wanted
* fix build time warnings
  (the mktemp in lpd is said to be safe)
* update docs a bit
* the eqn -> neqn move
* improved man page generation
* anoncvsbin removes tmp before making new symlink
* sendmail generated files are now in sendmail, and
  SKIPDIRS is checked before (asked for by Waldemar Brodkorb)
* more SKIPDIR checks, mostly for GNU stuff
@
text
@d1 1
a1 1
/* $MirBSD$ */
d1396 5
d2094 1
a2094 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXhVv",
d2154 1
d2167 1
a2167 1

d2241 1
a2241 1
  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXhVvW:",
@


1.3
log
@first part of mergeing OpenBSD and fixing whitespace and RCS IDs
@
text
@d1 2
d1369 1
a1369 1
  char *dir = make_tempname (bfd_get_filename (obfd));
a1370 6
  /* Make a temp directory to hold the contents.  */
  if (MKDIR (dir, 0700) != 0)
    {
      fatal (_("cannot mkdir %s for archive copying (error: %s)"),
	     dir, strerror (errno));
    }
d1395 1
a1395 6
	  output_name = make_tempname (output_name);
	  if (MKDIR (output_name, 0700) != 0)
	    {
	      fatal (_("cannot mkdir %s for archive copying (error: %s)"),
		     output_name, strerror (errno));
	    }
d2161 1
a2161 1
 
d2197 1
a2197 1
	tmpname = make_tempname (argv[i]);
d2681 1
a2681 1
 
d2731 1
a2731 1
      char *tmpname = make_tempname (input_filename);
@


1.2
log
@looks as if some sour wine (Federweier <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@d2098 1
a2098 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXHhVv",
a2157 1
	case 'H':
d2244 1
a2244 1
  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:",
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   2001
d35 1
a35 1
   deleted. */
d51 36
a86 12
static void copy_usage PARAMS ((FILE *, int));
static void strip_usage PARAMS ((FILE *, int));
static flagword parse_flags PARAMS ((const char *));
static struct section_list *find_section_list PARAMS ((const char *, boolean));
static void setup_section PARAMS ((bfd *, asection *, PTR));
static void copy_section PARAMS ((bfd *, asection *, PTR));
static void get_sections PARAMS ((bfd *, asection *, PTR));
static int compare_section_lma PARAMS ((const PTR, const PTR));
static void add_specific_symbol PARAMS ((const char *, struct symlist **));
static void add_specific_symbols PARAMS ((const char *, struct symlist **));
static boolean is_specified_symbol PARAMS ((const char *, struct symlist *));
static boolean is_strip_section PARAMS ((bfd *, asection *));
d89 10
a98 5
static void mark_symbols_used_in_relocations PARAMS ((bfd *, asection *, PTR));
static void filter_bytes PARAMS ((char *, bfd_size_type *));
static boolean write_debugging_info PARAMS ((bfd *, PTR, long *, asymbol ***));
static void copy_object PARAMS ((bfd *, bfd *));
static void copy_archive PARAMS ((bfd *, bfd *, const char *));
d101 12
a112 4
static int strip_main PARAMS ((int, char **));
static int copy_main PARAMS ((int, char **));
static const char *lookup_sym_redefinition PARAMS((const char *));
static void redefine_list_append PARAMS ((const char *, const char *));
d123 2
a124 2
static boolean verbose;		/* Print file and target names. */
static boolean preserve_dates;	/* Preserve input file timestamp.  */
d136 1
a136 1
/* Which symbols to remove. */
d160 11
a170 11
  struct section_list * next;      /* Next section to change.  */
  const char *          name;      /* Section name.  */
  boolean               used;      /* Whether this entry was used.  */
  boolean               remove;    /* Whether to remove this section.  */
  boolean		copy;      /* Whether to copy this section.  */
  enum change_action    change_vma;/* Whether to change or set VMA.  */
  bfd_vma 		vma_val;   /* Amount to change by or set to.  */
  enum change_action    change_lma;/* Whether to change or set LMA.  */
  bfd_vma 		lma_val;   /* Amount to change by or set to.  */
  boolean 		set_flags; /* Whether to set the section flags.  */
  flagword 		flags;     /* What to set the section flags to.  */
d174 6
a179 2
static boolean sections_removed;
static boolean sections_copied;
d183 1
a183 1
static boolean set_start_set = false;
d190 1
a190 1
static boolean gap_fill_set = false;
d194 1
a194 1
static boolean pad_to_set = false;
d197 3
a200 1

d217 1
d221 1
a221 2

static boolean convert_debugging = false;
d224 1
a224 2

static boolean change_leading_char = false;
d227 1
a227 2

static boolean remove_leading_char = false;
a230 1

d238 2
a239 1
/* If this is true, we weaken global symbols (set BSF_WEAK).  */
d241 4
a244 1
static boolean weaken = false;
d273 6
d288 1
d294 1
d316 2
a328 1
  {"only-section", required_argument, 0, 'j'},
d332 1
d336 2
d339 3
d344 1
d348 3
d352 1
a352 2
  {"localize-symbol", required_argument, 0, 'L'},
  {"keep-global-symbol", required_argument, 0, 'G'},
d355 1
d358 2
d364 1
a369 7
  {"redefine-sym", required_argument, 0, OPTION_REDEFINE_SYM},
  {"srec-len", required_argument, 0, OPTION_SREC_LEN},
  {"srec-forceS3", no_argument, 0, OPTION_SREC_FORCES3},
  {"keep-symbols", required_argument, 0, OPTION_KEEP_SYMBOLS},
  {"strip-symbols", required_argument, 0, OPTION_STRIP_SYMBOLS},
  {"keep-global-symbols", required_argument, 0, OPTION_KEEPGLOBAL_SYMBOLS},
  {"localize-symbols", required_argument, 0, OPTION_LOCALIZE_SYMBOLS},
d379 1
a379 1
   -1 means if we should use argv[0] to decide. */
d389 4
a392 1
extern boolean S3Forced;
d394 1
d400 3
a402 2
  fprintf (stream, _("Usage: %s <switches> in-file [out-file]\n"), program_name);
  fprintf (stream, _(" The switches are:\n"));
d406 1
d443 1
d454 6
d463 1
d476 3
a478 2
  fprintf (stream, _("Usage: %s <switches> in-file(s)\n"), program_name);
  fprintf (stream, _(" The switches are:\n"));
d480 3
a482 3
  -I --input-target <bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target <bfdname>     Create an output file in format <bfdname>\n\
  -F --target <bfdname>            Set both input and output format to <bfdname>\n\
d484 1
a484 1
  -R --remove-section <name>       Remove section <name> from the output\n\
d486 1
a486 1
  -g -S --strip-debug              Remove all debugging symbols\n\
d488 2
a489 2
  -N --strip-symbol <name>         Do not copy symbol <name>\n\
  -K --keep-symbol <name>          Only copy symbol <name>\n\
d495 1
d567 1
a567 1
     boolean add;
d580 3
a582 3
  p->used = false;
  p->remove = false;
  p->copy = false;
d587 1
a587 1
  p->set_flags = false;
d611 1
a611 1
/* Add symbols listed in `filename' to strip_specific_list. */
d626 1
a626 1
  
d645 1
a645 1
  
d651 1
a651 1
      int finished = false;
d662 1
a662 1
	      finished = true;
d664 1
a664 1
	      
d670 1
a670 1
	      finished = true;
d672 1
a672 1
	      
d674 1
a674 1
	      finished = true;
d676 1
a676 1
	      
d683 1
a683 1
	      
d700 2
a701 2
           name_end ++)
        ;
d714 1
a714 1
  
d730 1
a730 1
static boolean
d738 4
a741 5
    {
      if (strcmp (name, tmp_list->name) == 0)
	return true;
    }
  return false;
d746 1
a746 1
static boolean
d759 1
a759 1
    return true;
d762 1
a762 1
    return false;
d764 1
a764 1
  p = find_section_list (bfd_get_section_name (abfd, sec), false);
d766 1
a766 1
    return true;
d768 2
a769 2
    return true;
  return false;
d792 1
a792 1
      const char *name = bfd_asymbol_name (sym);
d794 5
d802 1
a802 1
	  const char *old_name, *new_name;
d804 53
a856 3
	  old_name = bfd_asymbol_name (sym);
	  new_name = lookup_sym_redefinition (old_name);
	  name = bfd_asymbol_name (sym) = new_name;
a858 30
      if (change_leading_char
	  && (bfd_get_symbol_leading_char (abfd)
	      != bfd_get_symbol_leading_char (obfd))
	  && (bfd_get_symbol_leading_char (abfd) == '\0'
	      || (name[0] == bfd_get_symbol_leading_char (abfd))))
	{
	  if (bfd_get_symbol_leading_char (obfd) == '\0')
	    name = bfd_asymbol_name (sym) = name + 1;
	  else
	    {
	      char *n;

	      n = xmalloc (strlen (name) + 2);
	      n[0] = bfd_get_symbol_leading_char (obfd);
	      if (bfd_get_symbol_leading_char (abfd) == '\0')
		strcpy (n + 1, name);
	      else
		strcpy (n + 1, name + 1);
	      name = bfd_asymbol_name (sym) = n;
	    }
	}

      if (remove_leading_char
	  && ((flags & BSF_GLOBAL) != 0
	      || (flags & BSF_WEAK) != 0
	      || bfd_is_und_section (bfd_get_section (sym))
	      || bfd_is_com_section (bfd_get_section (sym)))
	  && name[0] == bfd_get_symbol_leading_char (abfd))
	name = bfd_asymbol_name (sym) = name + 1;

d866 1
a866 1
      else if (relocatable			/* Relocatable file. */
d871 1
a871 1
	   even if relocatable is false.  External users of the
d874 1
a874 1
	  keep = 1;
d877 1
a877 1
	       || bfd_is_und_section (bfd_get_section (sym))
d884 4
d907 1
a907 1
      if (keep && (flags & (BSF_GLOBAL | BSF_WEAK))
d925 2
a930 1
  const char *result;
d933 3
a935 1
  result = source;
d937 1
a937 9
  for (list = redefine_sym_list; list != NULL; list = list->next)
    {
      if (strcmp (source, list->source) == 0)
	{
	  result = list->target;
	  break;
	}
    }
  return result;
d940 1
a940 1
/* Add a node to a symbol redefine list */
d954 3
a956 5
	{
	  fatal (_("%s: Multiple redefinition of symbol \"%s\""),
		 "--redefine-sym",
		  source);
	}
d959 3
a961 5
	{
	  fatal (_("%s: Symbol \"%s\" is target of more than one redefinition"),
		 "--redefine-sym",
		  target);
	}
a972 1

d985 1
d1006 2
d1031 10
a1040 5
  if (!bfd_set_start_address (obfd, start)
      || !bfd_set_file_flags (obfd,
			      (bfd_get_file_flags (ibfd)
			       & bfd_applicable_file_flags (obfd))))
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d1042 6
a1047 3
  /* Copy architecture of input file to output file */
  if (!bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
			  bfd_get_mach (ibfd)))
d1087 1
a1087 1
	      pset = find_section_list (padd->name, false);
d1089 1
a1089 1
		pset->used = true;
d1162 2
a1163 2
			       bfd_get_section_name (obfd, osections[i]),
			       bfd_errmsg (bfd_get_error ()));
d1187 2
a1188 2
			   bfd_get_section_name (obfd, osections[c - 1]),
			   bfd_errmsg (bfd_get_error ()));
d1201 2
a1202 2
  /* Symbol filtering must happen after the output sections have
     been created, but before their contents are set.  */
d1225 1
a1283 1

d1299 1
d1324 1
a1324 1
  if (!bfd_copy_private_bfd_data (ibfd, obfd))
d1332 9
d1343 7
d1362 1
a1362 1
      char *name;
d1367 1
a1367 1
  char *dir = make_tempname (bfd_get_filename (obfd), 1);
d1370 1
a1370 1
  if (dir == (char *) NULL)
d1372 2
a1373 2
      fatal (_("cannot make temp directory for archive copying (error: %s)"),
	     strerror (errno));
d1380 4
d1386 2
a1387 4
      /* Create an output file for this member.  */
      char *output_name = concat (dir, "/", bfd_get_filename (this_element),
				  (char *) NULL);
      bfd *output_bfd = bfd_openw (output_name, output_target);
d1392 23
d1418 1
d1432 1
a1432 4
      if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
	RETURN_NONFATAL (bfd_get_filename (obfd));

      if (bfd_check_format (this_element, bfd_object) == true)
d1438 1
a1438 1
	  /* Error in new object file. Don't change archive. */
d1470 7
a1476 2
      bfd_close (l->obfd);
      unlink (l->name);
d1491 2
a1492 1
  char **matching;
a1495 1

d1515 1
a1515 1
  else if (bfd_check_format_matches (ibfd, bfd_object, &matching))
d1518 1
a1518 1

d1538 16
d1556 6
a1561 1
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
d1563 2
a1564 2
	  list_matching_formats (matching);
	  free (matching);
d1571 62
a1632 2
/* Create a section in OBFD with the same name and attributes
   as ISECTION in IBFD.  */
d1648 2
d1659 1
a1659 1
  p = find_section_list (bfd_section_name (ibfd, isection), false);
d1661 1
a1661 1
    p->used = true;
d1668 20
a1687 1
  osection = bfd_make_section_anyway (obfd, bfd_section_name (ibfd, isection));
d1735 3
a1737 4
  if (bfd_set_section_alignment (obfd,
				 osection,
				 bfd_section_alignment (ibfd, isection))
      == false)
a1742 1
  flags = bfd_get_section_flags (ibfd, isection);
d1744 1
a1744 1
    flags = p->flags | (flags & SEC_HAS_CONTENTS);
d1751 3
d1768 1
a1768 1
  /* All went well */
d1796 1
d1798 2
a1799 2
  /* If we have already failed earlier on, do not keep on generating
     complaints now.  */
d1803 2
a1804 1
  if ((bfd_get_section_flags (ibfd, isection) & SEC_DEBUGGING) != 0
d1810 4
a1813 3
    {
      return;
    }
d1815 1
a1815 1
  p = find_section_list (bfd_section_name (ibfd, isection), false);
d1828 5
a1833 1
  relsize = bfd_get_reloc_upper_bound (ibfd, isection);
d1849 1
a1849 1
	     keep_strip_specific_list. */
d1864 1
d1870 1
a1870 1
  isection->reloc_done = true;
d1872 2
a1873 1
  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS)
d2016 1
a2016 1
static boolean
d2036 1
a2036 1
	return false;
d2058 1
a2058 1
	  return false;
d2073 1
a2073 1
	  return false;
d2076 1
a2076 1
      return true;
d2081 1
a2081 1
  return false;
d2089 6
a2094 3
  char *input_target = NULL, *output_target = NULL;
  boolean show_version = false;
  int c, i;
d2098 1
a2098 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXVvW:",
d2113 3
a2115 3
	  p = find_section_list (optarg, true);
	  p->remove = true;
	  sections_removed = true;
d2138 1
a2138 1
	  preserve_dates = true;
d2147 1
a2147 1
	  verbose = true;
d2150 4
a2153 1
	  show_version = true;
d2156 3
a2158 1
	  break;		/* we've been given a long option */
d2166 6
d2207 1
a2207 1
	tmpname = make_tempname (argv[i], 0);
d2233 8
a2240 4
  char *input_filename = NULL, *output_filename = NULL;
  char *input_target = NULL, *output_target = NULL;
  boolean show_version = false;
  boolean change_warn = true;
d2245 1
a2245 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:R:SpgxXVvW:",
d2256 4
d2281 1
a2281 1
	  p = find_section_list (optarg, true);
d2284 2
a2285 2
	  p->copy = true;
	  sections_copied = true;
d2289 1
a2289 1
	  p = find_section_list (optarg, true);
d2292 2
a2293 2
	  p->remove = true;
	  sections_removed = true;
d2329 1
a2329 1
	  preserve_dates = true;
d2341 1
a2341 1
	  verbose = true;
d2345 5
a2349 1
	  show_version = true;
d2353 1
a2353 1
	  weaken = true;
d2447 1
a2447 1
	    p = find_section_list (name, true);
d2484 1
a2484 1
	  change_warn = true;
d2488 1
a2488 1
	  change_leading_char = true;
d2492 1
a2492 1
	  convert_debugging = true;
d2510 1
a2510 1
	    gap_fill_set = true;
d2515 1
a2515 1
	  change_warn = false;
d2520 1
a2520 1
	  pad_to_set = true;
d2524 1
a2524 1
	  remove_leading_char = true;
d2538 1
a2538 3
	      {
		fatal (_("bad format for %s"), "--redefine-sym");
	      }
d2572 1
a2572 1
	    p = find_section_list (name, true);
d2574 1
a2574 1
	    p->set_flags = true;
d2579 44
d2625 1
a2625 1
	  set_start_set = true;
d2628 3
a2630 3
        case OPTION_SREC_LEN:
          Chunk = parse_vma (optarg, "--srec-len");
          break;
d2632 3
a2634 3
        case OPTION_SREC_FORCES3:
	  S3Forced = true;
          break;
d2656 18
d2677 1
d2686 6
d2712 1
a2712 1
  if (preserve_dates)
d2714 16
a2729 2
      if (stat (input_filename, &statbuf) < 0)
	fatal (_("Cannot stat: %s: %s"), input_filename, strerror (errno));
d2732 3
a2734 2
  /* If there is no destination file then create a temp and rename
     the result into the input.  */
d2736 4
a2739 1
  if (output_filename == (char *) NULL)
d2741 1
a2741 1
      char *tmpname = make_tempname (input_filename, 0);
d2756 1
d2801 2
d2810 3
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@d1246 1
a1246 1
  char *dir = make_tempname (bfd_get_filename (obfd));
d1249 1
a1249 5
#if defined (_WIN32) && !defined (__CYGWIN32__)
  if (mkdir (dir) != 0)
#else
  if (mkdir (dir, 0700) != 0)
#endif
d1251 2
a1252 2
      fatal (_("cannot mkdir %s for archive copying (error: %s)"),
	     dir, strerror (errno));
d1932 1
a1932 1
	tmpname = make_tempname (argv[i]);
d2369 1
a2369 1
      char *tmpname = make_tempname (input_filename);
@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d3 1
a3 1
   2001, 2002, 2003
d35 1
a35 1
   deleted.  */
d51 12
a62 36
typedef struct section_rename
{
  const char *            old_name;
  const char *            new_name;
  flagword                flags;
  struct section_rename * next;
}
section_rename;

/* List of sections to be renamed.  */
static section_rename * section_rename_list;

static void copy_usage
  PARAMS ((FILE *, int));
static void strip_usage
  PARAMS ((FILE *, int));
static flagword parse_flags
  PARAMS ((const char *));
static struct section_list *find_section_list
  PARAMS ((const char *, bfd_boolean));
static void setup_section
  PARAMS ((bfd *, asection *, PTR));
static void copy_section
  PARAMS ((bfd *, asection *, PTR));
static void get_sections
  PARAMS ((bfd *, asection *, PTR));
static int compare_section_lma
  PARAMS ((const PTR, const PTR));
static void add_specific_symbol
  PARAMS ((const char *, struct symlist **));
static void add_specific_symbols
  PARAMS ((const char *, struct symlist **));
static bfd_boolean is_specified_symbol
  PARAMS ((const char *, struct symlist *));
static bfd_boolean is_strip_section
  PARAMS ((bfd *, asection *));
d65 5
a69 10
static void mark_symbols_used_in_relocations
  PARAMS ((bfd *, asection *, PTR));
static void filter_bytes
  PARAMS ((char *, bfd_size_type *));
static bfd_boolean write_debugging_info
  PARAMS ((bfd *, PTR, long *, asymbol ***));
static void copy_object
  PARAMS ((bfd *, bfd *));
static void copy_archive
  PARAMS ((bfd *, bfd *, const char *));
d72 4
a75 12
static int strip_main
  PARAMS ((int, char **));
static int copy_main
  PARAMS ((int, char **));
static const char *lookup_sym_redefinition
  PARAMS((const char *));
static void redefine_list_append
  PARAMS ((const char *, const char *));
static const char * find_section_rename
  PARAMS ((bfd *, sec_ptr, flagword *));
static void add_section_rename
  PARAMS ((const char *, const char *, flagword));
d86 2
a87 2
static bfd_boolean verbose;		/* Print file and target names.  */
static bfd_boolean preserve_dates;	/* Preserve input file timestamp.  */
d99 1
a99 1
/* Which symbols to remove.  */
d123 11
a133 11
  struct section_list * next;	   /* Next section to change.  */
  const char *		name;	   /* Section name.  */
  bfd_boolean		used;	   /* Whether this entry was used.  */
  bfd_boolean		remove;	   /* Whether to remove this section.  */
  bfd_boolean		copy;	   /* Whether to copy this section.  */
  enum change_action	change_vma;/* Whether to change or set VMA.  */
  bfd_vma		vma_val;   /* Amount to change by or set to.  */
  enum change_action	change_lma;/* Whether to change or set LMA.  */
  bfd_vma		lma_val;   /* Amount to change by or set to.  */
  bfd_boolean		set_flags; /* Whether to set the section flags.	 */
  flagword		flags;	   /* What to set the section flags to.	 */
d137 2
a138 6

/* TRUE if some sections are to be removed.  */
static bfd_boolean sections_removed;

/* TRUE if only some sections are to be copied.  */
static bfd_boolean sections_copied;
d142 1
a142 1
static bfd_boolean set_start_set = FALSE;
d149 1
a149 1
static bfd_boolean gap_fill_set = FALSE;
d153 1
a153 1
static bfd_boolean pad_to_set = FALSE;
d156 1
a156 2
/* Use alternate machine code?  */
static int use_alt_mach_code = 0;
a157 1
/* List of sections to add.  */
a173 1
/* List of sections to add to the output BFD.  */
d177 2
a178 1
static bfd_boolean convert_debugging = FALSE;
d181 2
a182 1
static bfd_boolean change_leading_char = FALSE;
d185 2
a186 1
static bfd_boolean remove_leading_char = FALSE;
d190 1
d198 1
a198 2
/* If this is TRUE, we weaken global symbols (set BSF_WEAK).  */
static bfd_boolean weaken = FALSE;
d200 1
a200 4
/* Prefix symbols/sections.  */
static char *prefix_symbols_string = 0;
static char *prefix_sections_string = 0;
static char *prefix_alloc_sections_string = 0;
a228 6
#define OPTION_RENAME_SECTION (OPTION_WEAKEN_SYMBOLS + 1)
#define OPTION_ALT_MACH_CODE (OPTION_RENAME_SECTION + 1)
#define OPTION_PREFIX_SYMBOLS (OPTION_ALT_MACH_CODE + 1)
#define OPTION_PREFIX_SECTIONS (OPTION_PREFIX_SYMBOLS + 1)
#define OPTION_PREFIX_ALLOC_SECTIONS (OPTION_PREFIX_SECTIONS + 1)
#define OPTION_FORMATS_INFO (OPTION_PREFIX_ALLOC_SECTIONS + 1)
a237 1
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
a242 1
  {"output-file", required_argument, 0, 'o'},
a263 2
  {"alt-machine-code", required_argument, 0, OPTION_ALT_MACH_CODE},
  {"binary-architecture", required_argument, 0, 'B'},
d275 1
a278 1
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
a281 2
  {"keep-global-symbol", required_argument, 0, 'G'},
  {"keep-global-symbols", required_argument, 0, OPTION_KEEPGLOBAL_SYMBOLS},
a282 3
  {"keep-symbols", required_argument, 0, OPTION_KEEP_SYMBOLS},
  {"localize-symbol", required_argument, 0, 'L'},
  {"localize-symbols", required_argument, 0, OPTION_LOCALIZE_SYMBOLS},
a284 1
  {"only-section", required_argument, 0, 'j'},
a287 3
  {"prefix-symbols", required_argument, 0, OPTION_PREFIX_SYMBOLS},
  {"prefix-sections", required_argument, 0, OPTION_PREFIX_SECTIONS},
  {"prefix-alloc-sections", required_argument, 0, OPTION_PREFIX_ALLOC_SECTIONS},
d289 2
a290 1
  {"redefine-sym", required_argument, 0, OPTION_REDEFINE_SYM},
a292 1
  {"rename-section", required_argument, 0, OPTION_RENAME_SECTION},
a294 2
  {"srec-len", required_argument, 0, OPTION_SREC_LEN},
  {"srec-forceS3", no_argument, 0, OPTION_SREC_FORCES3},
a298 1
  {"strip-symbols", required_argument, 0, OPTION_STRIP_SYMBOLS},
d304 7
d320 1
a320 1
   -1 means if we should use argv[0] to decide.  */
d330 1
a330 4
extern bfd_boolean S3Forced;

/* Defined in bfd/binary.c.  Used to set architecture of input binary files.  */
extern enum bfd_architecture bfd_external_binary_architecture;
a331 1

d337 2
a338 3
  fprintf (stream, _("Usage: %s [option(s)] in-file [out-file]\n"), program_name);
  fprintf (stream, _(" Copies a binary file, possibly transforming it in the process\n"));
  fprintf (stream, _(" The options are:\n"));
a341 1
  -B --binary-architecture <arch>  Set arch of output file, when input is binary\n\
a377 1
     --rename-section <old>=<new>[,<flags>] Rename section <old> to <new>\n\
a387 6
     --alt-machine-code <index>    Use alternate machine code for output\n\
     --prefix-symbols <prefix>     Add <prefix> to start of every symbol name\n\
     --prefix-sections <prefix>    Add <prefix> to start of every section name\n\
     --prefix-alloc-sections <prefix>\n\
                                   Add <prefix> to start of every allocatable\n\
                                     section name\n\
a390 1
     --info                        List object formats & architectures supported\n\
d403 2
a404 3
  fprintf (stream, _("Usage: %s <option(s)> in-file(s)\n"), program_name);
  fprintf (stream, _(" Removes symbols and sections from files\n"));
  fprintf (stream, _(" The options are:\n"));
d406 3
a408 3
  -I --input-target=<bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target=<bfdname>     Create an output file in format <bfdname>\n\
  -F --target=<bfdname>            Set both input and output format to <bfdname>\n\
d410 1
a410 1
  -R --remove-section=<name>       Remove section <name> from the output\n\
d412 1
a412 1
  -g -S -d --strip-debug           Remove all debugging symbols\n\
d414 2
a415 2
  -N --strip-symbol=<name>         Do not copy symbol <name>\n\
  -K --keep-symbol=<name>          Only copy symbol <name>\n\
a420 1
     --info                        List object formats & architectures supported\n\
d492 1
a492 1
     bfd_boolean add;
d505 3
a507 3
  p->used = FALSE;
  p->remove = FALSE;
  p->copy = FALSE;
d512 1
a512 1
  p->set_flags = FALSE;
d536 1
a536 1
/* Add symbols listed in `filename' to strip_specific_list.  */
d551 1
a551 1

d570 1
a570 1

d576 1
a576 1
      int finished = FALSE;
d587 1
a587 1
	      finished = TRUE;
d589 1
a589 1

d595 1
a595 1
	      finished = TRUE;
d597 1
a597 1

d599 1
a599 1
	      finished = TRUE;
d601 1
a601 1

d608 1
a608 1

d625 2
a626 2
	   name_end ++)
	;
d639 1
a639 1

d655 1
a655 1
static bfd_boolean
d663 5
a667 4
    if (strcmp (name, tmp_list->name) == 0)
      return TRUE;

  return FALSE;
d672 1
a672 1
static bfd_boolean
d685 1
a685 1
    return TRUE;
d688 1
a688 1
    return FALSE;
d690 1
a690 1
  p = find_section_list (bfd_get_section_name (abfd, sec), FALSE);
d692 1
a692 1
    return TRUE;
d694 2
a695 2
    return TRUE;
  return FALSE;
d718 1
a718 1
      char *name = (char *) bfd_asymbol_name (sym);
a719 3
      bfd_boolean undefined;
      bfd_boolean rem_leading_char;
      bfd_boolean add_leading_char;
d721 3
a723 1
      undefined = bfd_is_und_section (bfd_get_section (sym));
d725 10
a734 1
      if (redefine_sym_list)
d736 5
a740 1
	  char *old_name, *new_name;
d742 8
a749 53
	  old_name = (char *) bfd_asymbol_name (sym);
	  new_name = (char *) lookup_sym_redefinition (old_name);
	  bfd_asymbol_name (sym) = new_name;
	  name = new_name;
	}

      /* Check if we will remove the current leading character.  */
      rem_leading_char =
	(name[0] == bfd_get_symbol_leading_char (abfd))
	&& (change_leading_char
	    || (remove_leading_char
		&& ((flags & (BSF_GLOBAL | BSF_WEAK)) != 0
		    || undefined
		    || bfd_is_com_section (bfd_get_section (sym)))));

      /* Check if we will add a new leading character.  */
      add_leading_char =
	change_leading_char
	&& (bfd_get_symbol_leading_char (obfd) != '\0')
	&& (bfd_get_symbol_leading_char (abfd) == '\0'
	    || (name[0] == bfd_get_symbol_leading_char (abfd)));

      /* Short circuit for change_leading_char if we can do it in-place.  */
      if (rem_leading_char && add_leading_char && !prefix_symbols_string)
        {
	  name[0] = bfd_get_symbol_leading_char (obfd);
	  bfd_asymbol_name (sym) = name;
	  rem_leading_char = FALSE;
	  add_leading_char = FALSE;
        }

      /* Remove leading char.  */
      if (rem_leading_char)
	bfd_asymbol_name (sym) = ++name;

      /* Add new leading char and/or prefix.  */
      if (add_leading_char || prefix_symbols_string)
        {
          char *n, *ptr;

          ptr = n = xmalloc (1 + strlen (prefix_symbols_string) + strlen (name) + 1);
          if (add_leading_char)
	    *ptr++ = bfd_get_symbol_leading_char (obfd);

          if (prefix_symbols_string)
            {
              strcpy (ptr, prefix_symbols_string);
              ptr += strlen (prefix_symbols_string);
           }

          strcpy (ptr, name);
          bfd_asymbol_name (sym) = n;
          name = n;
d752 8
d767 1
a767 1
      else if (relocatable			/* Relocatable file.  */
d772 1
a772 1
	   even if relocatable is FALSE.  External users of the
d775 1
a775 1
	keep = 1;
d778 1
a778 1
	       || undefined
a784 4
      else if (bfd_get_section (sym)->comdat)
	/* COMDAT sections store special information in local
	   symbols, so we cannot risk stripping any of them.  */
	keep = 1;
d804 1
a804 1
      if (keep && !undefined && (flags & (BSF_GLOBAL | BSF_WEAK))
a821 2
/* Find the redefined name of symbol SOURCE.  */

d826 1
d829 2
d832 8
a839 4
    if (strcmp (source, list->source) == 0)
      return list->target;

  return source;
d842 1
a842 1
/* Add a node to a symbol redefine list.  */
d856 5
a860 3
	fatal (_("%s: Multiple redefinition of symbol \"%s\""),
	       "--redefine-sym",
	       source);
d863 5
a867 3
	fatal (_("%s: Symbol \"%s\" is target of more than one redefinition"),
	       "--redefine-sym",
	       target);
d879 1
a891 1

a911 2
  enum bfd_architecture iarch;
  unsigned int imach;
d935 5
a939 10
  /* Neither the start address nor the flags
     need to be set for a core file.  */
  if (bfd_get_format (obfd) != bfd_core)
    {
      if (!bfd_set_start_address (obfd, start)
	  || !bfd_set_file_flags (obfd,
				  (bfd_get_file_flags (ibfd)
				   & bfd_applicable_file_flags (obfd))))
	RETURN_NONFATAL (bfd_get_filename (ibfd));
    }
d941 3
a943 6
  /* Copy architecture of input file to output file.  */
  iarch = bfd_get_arch (ibfd);
  imach = bfd_get_mach (ibfd);
  if (!bfd_set_arch_mach (obfd, iarch, imach)
      && (ibfd->target_defaulted
	  || bfd_get_arch (ibfd) != bfd_get_arch (obfd)))
d983 1
a983 1
	      pset = find_section_list (padd->name, FALSE);
d985 1
a985 1
		pset->used = TRUE;
d1058 2
a1059 2
				 bfd_get_section_name (obfd, osections[i]),
				 bfd_errmsg (bfd_get_error ()));
d1083 2
a1084 2
			     bfd_get_section_name (obfd, osections[c - 1]),
			     bfd_errmsg (bfd_get_error ()));
d1097 2
a1098 2
  /* Symbol filtering must happen after the output sections
     have been created, but before their contents are set.  */
a1120 1
      || prefix_symbols_string
d1179 1
a1194 1

d1219 1
a1219 1
  if (! bfd_copy_private_bfd_data (ibfd, obfd))
a1226 9

  /* Switch to the alternate machine code.  We have to do this at the
     very end, because we only initialize the header when we create
     the first section.  */
  if (use_alt_mach_code != 0)
    {
      if (!bfd_alt_mach_code (obfd, use_alt_mach_code))
	non_fatal (_("unknown alternate machine code, ignored"));
    }
a1228 7
#undef MKDIR
#if defined (_WIN32) && !defined (__CYGWIN32__)
#define MKDIR(DIR, MODE) mkdir (DIR)
#else
#define MKDIR(DIR, MODE) mkdir (DIR, MODE)
#endif

d1241 1
a1241 1
      const char *name;
d1249 5
a1253 1
  if (MKDIR (dir, 0700) != 0)
a1262 4

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    RETURN_NONFATAL (bfd_get_filename (obfd));

d1265 4
a1268 2
      char *output_name;
      bfd *output_bfd;
a1272 23
      /* Create an output file for this member.  */
      output_name = concat (dir, "/",
			    bfd_get_filename (this_element), (char *) 0);

      /* If the file already exists, make another temp dir.  */
      if (stat (output_name, &buf) >= 0)
	{
	  output_name = make_tempname (output_name);
	  if (MKDIR (output_name, 0700) != 0)
	    {
	      fatal (_("cannot mkdir %s for archive copying (error: %s)"),
		     output_name, strerror (errno));
	    }
	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
	  l->name = output_name;
	  l->next = list;
	  l->obfd = NULL;
	  list = l;
	  output_name = concat (output_name, "/",
				bfd_get_filename (this_element), (char *) 0);
	}

      output_bfd = bfd_openw (output_name, output_target);
a1275 1

d1289 4
a1292 1
      if (bfd_check_format (this_element, bfd_object))
d1298 1
a1298 1
	  /* Error in new object file. Don't change archive.  */
d1330 2
a1331 7
      if (l->obfd == NULL)
	rmdir (l->name);
      else
	{
	  bfd_close (l->obfd);
	  unlink (l->name);
	}
d1346 1
a1346 2
  char **obj_matching;
  char **core_matching;
d1350 1
d1370 1
a1370 1
  else if (bfd_check_format_matches (ibfd, bfd_object, &obj_matching))
d1373 1
a1373 1
    do_copy:
a1392 16
      bfd_error_type obj_error = bfd_get_error ();
      bfd_error_type core_error;

      if (bfd_check_format_matches (ibfd, bfd_core, &core_matching))
	{
	  /* This probably can't happen..  */
	  if (obj_error == bfd_error_file_ambiguously_recognized)
	    free (obj_matching);
	  goto do_copy;
	}

      core_error = bfd_get_error ();
      /* Report the object error in preference to the core error.  */
      if (obj_error != core_error)
	bfd_set_error (obj_error);

d1395 1
a1395 6
      if (obj_error == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (obj_matching);
	  free (obj_matching);
	}
      if (core_error == bfd_error_file_ambiguously_recognized)
d1397 2
a1398 2
	  list_matching_formats (core_matching);
	  free (core_matching);
d1405 2
a1406 62
/* Add a name to the section renaming list.  */

static void
add_section_rename (old_name, new_name, flags)
     const char * old_name;
     const char * new_name;
     flagword flags;
{
  section_rename * rename;

  /* Check for conflicts first.  */
  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
      {
	/* Silently ignore duplicate definitions.  */
	if (strcmp (rename->new_name, new_name) == 0
	    && rename->flags == flags)
	  return;

	fatal (_("Multiple renames of section %s"), old_name);
      }

  rename = (section_rename *) xmalloc (sizeof (* rename));

  rename->old_name = old_name;
  rename->new_name = new_name;
  rename->flags    = flags;
  rename->next     = section_rename_list;

  section_rename_list = rename;
}

/* Check the section rename list for a new name of the input section
   ISECTION.  Return the new name if one is found.
   Also set RETURNED_FLAGS to the flags to be used for this section.  */

static const char *
find_section_rename (ibfd, isection, returned_flags)
     bfd * ibfd ATTRIBUTE_UNUSED;
     sec_ptr isection;
     flagword * returned_flags;
{
  const char * old_name = bfd_section_name (ibfd, isection);
  section_rename * rename;

  /* Default to using the flags of the input section.  */
  * returned_flags = bfd_get_section_flags (ibfd, isection);

  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
      {
	if (rename->flags != (flagword) -1)
	  * returned_flags = rename->flags;

	return rename->new_name;
      }

  return old_name;
}

/* Create a section in OBFD with the same
   name and attributes as ISECTION in IBFD.  */
a1421 2
  const char * name;
  char *prefix = NULL;
d1431 1
a1431 1
  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);
d1433 1
a1433 1
    p->used = TRUE;
d1440 1
a1440 20
  /* Get the, possibly new, name of the output section.  */
  name = find_section_rename (ibfd, isection, & flags);

  /* Prefix sections.  */
  if ((prefix_alloc_sections_string) && (bfd_get_section_flags (ibfd, isection) & SEC_ALLOC))
    prefix = prefix_alloc_sections_string;
  else if (prefix_sections_string)
    prefix = prefix_sections_string;

  if (prefix)
    {
      char *n;

      n = xmalloc (strlen (prefix) + strlen (name) + 1);
      strcpy (n, prefix);
      strcat (n, name);
      name = n;
    }

  osection = bfd_make_section_anyway (obfd, name);
d1488 4
a1491 3
  if (!bfd_set_section_alignment (obfd,
				  osection,
				  bfd_section_alignment (ibfd, isection)))
d1497 1
d1499 1
a1499 1
    flags = p->flags | (flags & (SEC_HAS_CONTENTS | SEC_RELOC));
a1505 3
  /* Copy merge entity size.  */
  osection->entsize = isection->entsize;

d1520 1
a1520 1
  /* All went well.  */
a1547 1
  flagword flags;
d1549 2
a1550 2
  /* If we have already failed earlier on,
     do not keep on generating complaints now.  */
d1554 1
a1554 2
  flags = bfd_get_section_flags (ibfd, isection);
  if ((flags & SEC_DEBUGGING) != 0
d1560 3
a1562 1
    return;
d1564 1
a1564 4
  if ((flags & SEC_GROUP) != 0)
    return;

  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);
a1576 5
  /* Core files do not need to be relocated.  */
  if (bfd_get_format (obfd) == bfd_core)
    relsize = 0;
  else
    relsize = bfd_get_reloc_upper_bound (ibfd, isection);
d1578 1
d1594 1
a1594 1
	     keep_strip_specific_list.  */
a1608 1

d1614 1
a1614 1
  isection->reloc_done = TRUE;
d1616 1
a1616 2
  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS
      && bfd_get_section_flags (obfd, osection) & SEC_HAS_CONTENTS)
d1759 1
a1759 1
static bfd_boolean
d1779 1
a1779 1
	return FALSE;
d1801 1
a1801 1
	  return FALSE;
d1816 1
a1816 1
	  return FALSE;
d1819 1
a1819 1
      return TRUE;
d1824 1
a1824 1
  return FALSE;
d1832 3
a1834 6
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean formats_info = FALSE;
  int c;
  int i;
d1838 1
a1838 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXHhVv",
d1853 3
a1855 3
	  p = find_section_list (optarg, TRUE);
	  p->remove = TRUE;
	  sections_removed = TRUE;
d1878 1
a1878 1
	  preserve_dates = TRUE;
d1887 1
a1887 1
	  verbose = TRUE;
d1890 1
a1890 4
	  show_version = TRUE;
	  break;
	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
d1893 1
a1893 3
	  /* We've been given a long option.  */
	  break;
	case 'H':
a1900 6
 if (formats_info)
   {
     display_info ();
     return 0;
   }
 
d1962 4
a1965 8
  char * binary_architecture = NULL;
  char *input_filename = NULL;
  char *output_filename = NULL;
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean change_warn = TRUE;
  bfd_boolean formats_info = FALSE;
d1970 1
a1970 1
  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:",
a1980 4
	case 'B':
	  binary_architecture = optarg;
	  break;

d2002 1
a2002 1
	  p = find_section_list (optarg, TRUE);
d2005 2
a2006 2
	  p->copy = TRUE;
	  sections_copied = TRUE;
d2010 1
a2010 1
	  p = find_section_list (optarg, TRUE);
d2013 2
a2014 2
	  p->remove = TRUE;
	  sections_removed = TRUE;
d2050 1
a2050 1
	  preserve_dates = TRUE;
d2062 1
a2062 1
	  verbose = TRUE;
d2066 1
a2066 5
	  show_version = TRUE;
	  break;

	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
d2070 1
a2070 1
	  weaken = TRUE;
d2164 1
a2164 1
	    p = find_section_list (name, TRUE);
d2201 1
a2201 1
	  change_warn = TRUE;
d2205 1
a2205 1
	  change_leading_char = TRUE;
d2209 1
a2209 1
	  convert_debugging = TRUE;
d2227 1
a2227 1
	    gap_fill_set = TRUE;
d2232 1
a2232 1
	  change_warn = FALSE;
d2237 1
a2237 1
	  pad_to_set = TRUE;
d2241 1
a2241 1
	  remove_leading_char = TRUE;
d2255 3
a2257 1
	      fatal (_("bad format for %s"), "--redefine-sym");
d2291 1
a2291 1
	    p = find_section_list (name, TRUE);
d2293 1
a2293 1
	    p->set_flags = TRUE;
a2297 44
	case OPTION_RENAME_SECTION:
	  {
	    flagword flags;
	    const char *eq, *fl;
	    char *old_name;
	    char *new_name;
	    unsigned int len;

	    eq = strchr (optarg, '=');
	    if (eq == NULL)
	      fatal (_("bad format for %s"), "--rename-section");

	    len = eq - optarg;
	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    old_name = (char *) xmalloc (len + 1);
	    strncpy (old_name, optarg, len);
	    old_name[len] = 0;

	    eq++;
	    fl = strchr (eq, ',');
	    if (fl)
	      {
		flags = parse_flags (fl + 1);
		len = fl - eq;
	      }
	    else
	      {
		flags = -1;
		len = strlen (eq);
	      }

	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    new_name = (char *) xmalloc (len + 1);
	    strncpy (new_name, eq, len);
	    new_name[len] = 0;

	    add_section_rename (old_name, new_name, flags);
	  }
	  break;

d2300 1
a2300 1
	  set_start_set = TRUE;
d2303 3
a2305 3
	case OPTION_SREC_LEN:
	  Chunk = parse_vma (optarg, "--srec-len");
	  break;
d2307 3
a2309 3
	case OPTION_SREC_FORCES3:
	  S3Forced = TRUE;
	  break;
a2330 18
	case OPTION_ALT_MACH_CODE:
	  use_alt_mach_code = atoi (optarg);
	  if (use_alt_mach_code <= 0)
	    fatal (_("alternate machine code index must be positive"));
	  break;

	case OPTION_PREFIX_SYMBOLS:
	  prefix_symbols_string = optarg;
	  break;

	case OPTION_PREFIX_SECTIONS:
	  prefix_sections_string = optarg;
	  break;

	case OPTION_PREFIX_ALLOC_SECTIONS:
	  prefix_alloc_sections_string = optarg;
	  break;

a2333 1
	case 'H':
a2341 6
  if (formats_info)
    {
      display_info ();
      return 0;
    }
 
d2362 1
a2362 1
  if (binary_architecture != (char *) NULL)
d2364 2
a2365 16
      if (input_target && strcmp (input_target, "binary") == 0)
	{
	  const bfd_arch_info_type * temp_arch_info;

	  temp_arch_info = bfd_scan_arch (binary_architecture);

	  if (temp_arch_info != NULL)
	    bfd_external_binary_architecture = temp_arch_info->arch;
	  else
	    fatal (_("architecture %s unknown"), binary_architecture);
	}
      else
	{
	  non_fatal (_("Warning: input target 'binary' required for binary architecture parameter."));
	  non_fatal (_(" Argument %s ignored"), binary_architecture);
	}
d2368 2
a2369 3
  if (preserve_dates)
    if (stat (input_filename, & statbuf) < 0)
      fatal (_("Cannot stat: %s: %s"), input_filename, strerror (errno));
d2371 1
a2371 4
  /* If there is no destination file, or the source and destination files
     are the same,  then create a temp and rename the result into the input.  */
  if ((output_filename == (char *) NULL) ||
      (strcmp (input_filename, output_filename) == 0))
a2387 1

a2431 2
int main PARAMS ((int, char **));

a2438 3
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
a29 2
#include "fnmatch.h"
#include "elf-bfd.h"
d61 52
a112 1
static section_rename *section_rename_list;
d116 2
a117 2
static asymbol **isympp = NULL;	/* Input symbols.  */
static asymbol **osympp = NULL;	/* Output symbols that survive stripping.  */
d130 4
a133 5
    STRIP_NONE,			/* Don't strip.  */
    STRIP_DEBUG,		/* Strip all debugger symbols.  */
    STRIP_UNNEEDED,		/* Strip unnecessary symbols.  */
    STRIP_NONDEBUG,		/* Strip everything but debug info.  */
    STRIP_ALL			/* Strip all symbols.  */
d142 2
a143 2
    LOCALS_START_L,		/* Discard locals starting with L.  */
    LOCALS_ALL			/* Discard all locals.  */
a199 4
/* Output BFD flags user wants to set or clear */
static flagword bfd_flags_to_set;
static flagword bfd_flags_to_clear;

a219 4
/* If non-NULL the argument to --add-gnu-debuglink.
   This should be the filename to store in the .gnu_debuglink section.  */
static const char * gnu_debuglink_filename = NULL;

a228 3
/* Whether to permit wildcard in symbol comparison.  */
static bfd_boolean wildcard = FALSE;

d247 32
a278 41
enum command_line_switch
  {
    OPTION_ADD_SECTION=150,
    OPTION_CHANGE_ADDRESSES,
    OPTION_CHANGE_LEADING_CHAR,
    OPTION_CHANGE_START,
    OPTION_CHANGE_SECTION_ADDRESS,
    OPTION_CHANGE_SECTION_LMA,
    OPTION_CHANGE_SECTION_VMA,
    OPTION_CHANGE_WARNINGS,
    OPTION_DEBUGGING,
    OPTION_GAP_FILL,
    OPTION_NO_CHANGE_WARNINGS,
    OPTION_PAD_TO,
    OPTION_REMOVE_LEADING_CHAR,
    OPTION_SET_SECTION_FLAGS,
    OPTION_SET_START,
    OPTION_STRIP_UNNEEDED,
    OPTION_WEAKEN,
    OPTION_REDEFINE_SYM,
    OPTION_REDEFINE_SYMS,
    OPTION_SREC_LEN,
    OPTION_SREC_FORCES3,
    OPTION_STRIP_SYMBOLS,
    OPTION_KEEP_SYMBOLS,
    OPTION_LOCALIZE_SYMBOLS,
    OPTION_KEEPGLOBAL_SYMBOLS,
    OPTION_WEAKEN_SYMBOLS,
    OPTION_RENAME_SECTION,
    OPTION_ALT_MACH_CODE,
    OPTION_PREFIX_SYMBOLS,
    OPTION_PREFIX_SECTIONS,
    OPTION_PREFIX_ALLOC_SECTIONS,
    OPTION_FORMATS_INFO,
    OPTION_ADD_GNU_DEBUGLINK,
    OPTION_ONLY_KEEP_DEBUG,
    OPTION_READONLY_TEXT,
    OPTION_WRITABLE_TEXT,
    OPTION_PURE,
    OPTION_IMPURE
  };
a291 1
  {"only-keep-debug", no_argument, 0, OPTION_ONLY_KEEP_DEBUG},
a303 1
  {"wildcard", no_argument, 0, 'w'},
a310 1
  {"add-gnu-debuglink", required_argument, 0, OPTION_ADD_GNU_DEBUGLINK},
a331 1
  {"impure", no_argument, 0, OPTION_IMPURE},
a343 1
  {"only-keep-debug", no_argument, 0, OPTION_ONLY_KEEP_DEBUG},
a351 2
  {"pure", no_argument, 0, OPTION_PURE},
  {"readonly-text", no_argument, 0, OPTION_READONLY_TEXT},
a352 1
  {"redefine-syms", required_argument, 0, OPTION_REDEFINE_SYMS},
a370 2
  {"wildcard", no_argument, 0, 'w'},
  {"writable-text", no_argument, 0, OPTION_WRITABLE_TEXT},
d391 3
a393 13
/* Defined in bfd/binary.c.  Used to set architecture and machine of input
   binary files.  */
extern enum bfd_architecture  bfd_external_binary_architecture;
extern unsigned long          bfd_external_machine;

/* Forward declarations.  */
static void setup_section (bfd *, asection *, void *);
static void copy_section (bfd *, asection *, void *);
static void get_sections (bfd *, asection *, void *);
static int compare_section_lma (const void *, const void *);
static void mark_symbols_used_in_relocations (bfd *, asection *, void *);
static bfd_boolean write_debugging_info (bfd *, void *, long *, asymbol ***);
static const char *lookup_sym_redefinition (const char *);
d396 3
a398 1
copy_usage (FILE *stream, int exit_status)
a410 1
     --add-gnu-debuglink=<file>    Add section .gnu_debuglink linking to <file>\n\
d413 1
a413 1
  -g --strip-debug                 Remove all debugging symbols & sections\n\
a415 1
     --only-keep-debug             Strip everything but the debug information\n\
a420 1
  -w --wildcard                    Permit wildcard in symbol comparasion\n\
a446 2
     --redefine-syms <file>        --redefine-sym for all symbol pairs \n\
                                     listed in <file>\n\
a454 4
     --writable-text               Mark the output text as writable\n\
     --readonly-text               Make the output text write protected\n\
     --pure                        Mark the output file as demand paged\n\
     --impure                      Mark the output file as impure\n\
d472 3
a474 1
strip_usage (FILE *stream, int exit_status)
d486 1
a486 1
  -g -S -d --strip-debug           Remove all debugging symbols & sections\n\
a487 1
     --only-keep-debug             Strip everything but the debug information\n\
a489 1
  -w --wildcard                    Permit wildcard in symbol comparasion\n\
d509 2
a510 1
parse_flags (const char *s)
d565 3
a567 1
find_section_list (const char *name, bfd_boolean add)
d569 1
a569 1
  struct section_list *p;
d578 1
a578 1
  p = xmalloc (sizeof (struct section_list));
d599 3
a601 1
add_specific_symbol (const char *name, struct symlist **list)
d605 1
a605 1
  tmp_list = xmalloc (sizeof (struct symlist));
d617 3
a619 1
add_specific_symbols (const char *filename, struct symlist **list)
d621 1
a621 1
  off_t  size;
d627 3
a629 2
  size = get_file_size (filename);
  if (size == 0)
d632 1
a632 1
  buffer = xmalloc (size + 2);
d635 1
a635 1
    fatal (_("cannot open '%s': %s"), filename, strerror (errno));
d637 1
a637 1
  if (fread (buffer, 1, size, f) == 0 || ferror (f))
d641 2
a642 2
  buffer [size] = '\n';
  buffer [size + 1] = '\0';
d731 3
a733 1
is_specified_symbol (const char *name, struct symlist *list)
d737 3
a739 20
  if (wildcard)
    {
      for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
	if (*(tmp_list->name) != '!')
	  {
	    if (!fnmatch (tmp_list->name, name, 0))
	      return TRUE;
	  }
	else
	  {
	    if (fnmatch (tmp_list->name + 1, name, 0))
	      return TRUE;
	  }
    }
  else
    {
      for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
	if (strcmp (name, tmp_list->name) == 0)
	  return TRUE;
    }
d747 3
a749 1
is_strip_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
d751 1
a751 5
  if (sections_removed || sections_copied)
    {
      struct section_list *p;

      p = find_section_list (bfd_get_section_name (abfd, sec), FALSE);
d753 2
a754 9
      if (sections_removed && p != NULL && p->remove)
	return TRUE;
      if (sections_copied && (p == NULL || ! p->copy))
	return TRUE;
    }

  if ((bfd_get_section_flags (abfd, sec) & SEC_DEBUGGING) != 0)
    {
      if (strip_symbols == STRIP_DEBUG
d758 2
a759 2
	  || convert_debugging)
	return TRUE;
d761 2
a762 3
      if (strip_symbols == STRIP_NONDEBUG)
	return FALSE;
    }
d764 5
d777 5
a781 2
filter_symbols (bfd *abfd, bfd *obfd, asymbol **osyms,
		asymbol **isyms, long symcount)
d783 1
a783 1
  asymbol **from = isyms, **to = osyms;
d844 1
a844 2
          ptr = n = xmalloc (1 + strlen (prefix_symbols_string)
			     + strlen (name) + 1);
d928 2
a929 1
lookup_sym_redefinition (const char *source)
d943 3
a945 1
redefine_list_append (const char *cause, const char *source, const char *target)
d955 2
a956 1
	       cause, source);
d960 2
a961 1
	       cause, target);
d964 1
a964 1
  new_node = xmalloc (sizeof (struct redefine_node));
d973 2
a974 2
/* Handle the --redefine-syms option.  Read lines containing "old new"
   from the file, and add them to the symbol redefine list.  */
d977 3
a979 1
add_redefine_syms_file (const char *filename)
d981 1
a981 92
  FILE *file;
  char *buf;
  size_t bufsize;
  size_t len;
  size_t outsym_off;
  int c, lineno;

  file = fopen (filename, "r");
  if (file == NULL)
    fatal (_("couldn't open symbol redefinition file %s (error: %s)"),
	   filename, strerror (errno));

  bufsize = 100;
  buf = xmalloc (bufsize);

  lineno = 1;
  c = getc (file);
  len = 0;
  outsym_off = 0;
  while (c != EOF)
    {
      /* Collect the input symbol name.  */
      while (! IS_WHITESPACE (c) && ! IS_LINE_TERMINATOR (c) && c != EOF)
	{
	  if (c == '#')
	    goto comment;
	  buf[len++] = c;
	  if (len >= bufsize)
	    {
	      bufsize *= 2;
	      buf = xrealloc (buf, bufsize);
	    }
	  c = getc (file);
	}
      buf[len++] = '\0';
      if (c == EOF)
	break;

      /* Eat white space between the symbol names.  */
      while (IS_WHITESPACE (c))
	c = getc (file);
      if (c == '#' || IS_LINE_TERMINATOR (c))
	goto comment;
      if (c == EOF)
	break;

      /* Collect the output symbol name.  */
      outsym_off = len;
      while (! IS_WHITESPACE (c) && ! IS_LINE_TERMINATOR (c) && c != EOF)
	{
	  if (c == '#')
	    goto comment;
	  buf[len++] = c;
	  if (len >= bufsize)
	    {
	      bufsize *= 2;
	      buf = xrealloc (buf, bufsize);
	    }
	  c = getc (file);
	}
      buf[len++] = '\0';
      if (c == EOF)
	break;

      /* Eat white space at end of line.  */
      while (! IS_LINE_TERMINATOR(c) && c != EOF && IS_WHITESPACE (c))
	c = getc (file);
      if (c == '#')
	goto comment;
      /* Handle \r\n.  */
      if ((c == '\r' && (c = getc (file)) == '\n')
	  || c == '\n' || c == EOF)
	{
 end_of_line:
	  /* Append the redefinition to the list.  */
	  if (buf[0] != '\0')
	    redefine_list_append (filename, &buf[0], &buf[outsym_off]);

	  lineno++;	
	  len = 0;
	  outsym_off = 0;
	  if (c == EOF)
	    break;
	  c = getc (file);
	  continue;
	}
      else
	fatal (_("%s: garbage at end of line %d"), filename, lineno);
 comment:
      if (len != 0 && (outsym_off == 0 || outsym_off == len))
	fatal (_("%s: missing new symbol name at line %d"), filename, lineno);
      buf[len++] = '\0';
d983 2
a984 5
      /* Eat the rest of the line and finish it.  */
      while (c != '\n' && c != EOF)
	c = getc (file);
      goto end_of_line;
    }
d986 4
a989 4
  if (len != 0)
    fatal (_("%s: premature end of file at line %d"), filename, lineno);

  free (buf);
d992 1
a992 2
/* Copy object file IBFD onto OBFD.
   Returns TRUE upon success, FALSE otherwise.  */
d994 4
a997 2
static bfd_boolean
copy_object (bfd *ibfd, bfd *obfd)
a1001 1
  asection *gnu_debuglink_section = NULL;
d1005 1
a1005 1
  void *dhandle;
d1012 4
a1015 1
    fatal (_("Unable to change endianness of input file(s)"));
d1018 1
a1018 4
    {
      bfd_nonfatal (bfd_get_filename (obfd));
      return FALSE;
    }
a1034 7
      flagword flags;

      flags = bfd_get_file_flags (ibfd);
      flags |= bfd_flags_to_set;
      flags &= ~bfd_flags_to_clear;
      flags &= bfd_applicable_file_flags (obfd);

d1036 4
a1039 5
	  || !bfd_set_file_flags (obfd, flags))
	{
	  bfd_nonfatal (bfd_get_filename (ibfd));
	  return FALSE;
	}
d1048 3
a1050 12
    {
      if (bfd_get_arch (ibfd) == bfd_arch_unknown)
	fatal (_("Unable to recognise the format of the input file %s"),
	       bfd_get_filename (ibfd));
      else
	{
	  non_fatal (_("Warning: Output file cannot represent architecture %s"),
		     bfd_printable_arch_mach (bfd_get_arch (ibfd),
					      bfd_get_mach (ibfd)));
	  return FALSE;
	}
    }
d1053 1
a1053 4
    {
      bfd_nonfatal (bfd_get_filename (ibfd));
      return FALSE;
    }
d1063 1
a1063 1
  bfd_map_over_sections (ibfd, setup_section, obfd);
a1071 2
	  flagword flags;

d1077 2
a1078 1
	      return FALSE;
d1080 1
a1080 2

	  if (! bfd_set_section_size (obfd, padd->section, padd->size))
d1082 1
a1082 3
	      bfd_nonfatal (bfd_get_filename (obfd));
	      return FALSE;
	    }
d1084 2
a1085 3
	  pset = find_section_list (padd->name, FALSE);
	  if (pset != NULL)
	    pset->used = TRUE;
d1087 3
a1089 4
	  if (pset != NULL && pset->set_flags)
	    flags = pset->flags | SEC_HAS_CONTENTS;
	  else
	    flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DATA;
d1091 4
a1094 5
	  if (! bfd_set_section_flags (obfd, padd->section, flags))
	    {
	      bfd_nonfatal (bfd_get_filename (obfd));
	      return FALSE;
	    }
d1096 2
a1097 9
	  if (pset != NULL)
	    {
	      if (pset->change_vma != CHANGE_IGNORE)
		if (! bfd_set_section_vma (obfd, padd->section,
					   pset->vma_val))
		  {
		    bfd_nonfatal (bfd_get_filename (obfd));
		    return FALSE;
		  }
d1099 1
a1099 1
	      if (pset->change_lma != CHANGE_IGNORE)
d1101 3
a1103 1
		  padd->section->lma = pset->lma_val;
d1105 1
a1105 3
		  if (! bfd_set_section_alignment
		      (obfd, padd->section,
		       bfd_section_alignment (obfd, padd->section)))
d1107 6
a1112 2
		      bfd_nonfatal (bfd_get_filename (obfd));
		      return FALSE;
a1118 18
  if (gnu_debuglink_filename != NULL)
    {
      gnu_debuglink_section = bfd_create_gnu_debuglink_section
	(obfd, gnu_debuglink_filename);

      if (gnu_debuglink_section == NULL)
	{
	  bfd_nonfatal (gnu_debuglink_filename);
	  return FALSE;
	}
    }

  if (bfd_count_sections (obfd) == 0)
    {
      non_fatal (_("there are no sections to be copied!"));
      return FALSE;
    }

d1131 1
a1131 1
      osections = xmalloc (c * sizeof (asection *));
d1133 1
a1133 1
      bfd_map_over_sections (obfd, get_sections, &set);
d1137 1
a1137 1
      gaps = xmalloc (c * sizeof (bfd_size_type));
d1206 1
a1206 4
    {
      bfd_nonfatal (bfd_get_filename (ibfd));
      return FALSE;
    }
d1208 1
a1208 1
  osympp = isympp = xmalloc (symsize);
d1211 1
a1211 4
    {
      bfd_nonfatal (bfd_get_filename (ibfd));
      return FALSE;
    }
a1218 1
      || strip_symbols == STRIP_NONDEBUG
d1245 2
a1246 2
			       isympp);
      osympp = xmalloc ((symcount + 1) * sizeof (asymbol *));
d1255 1
a1255 1
	  return FALSE;
d1262 1
a1262 1
  bfd_map_over_sections (ibfd, copy_section, obfd);
d1270 5
a1274 16
	  if (! bfd_set_section_contents (obfd, padd->section, padd->contents,
					  0, padd->size))
	    {
	      bfd_nonfatal (bfd_get_filename (obfd));
	      return FALSE;
	    }
	}
    }

  if (gnu_debuglink_filename != NULL)
    {
      if (! bfd_fill_in_gnu_debuglink_section
	  (obfd, gnu_debuglink_section, gnu_debuglink_filename))
	{
	  bfd_nonfatal (gnu_debuglink_filename);
	  return FALSE;
d1286 2
a1287 2
      buf = xmalloc (max_gap);
      memset (buf, gap_fill, max_gap);
d1311 1
a1311 4
		    {
		      bfd_nonfatal (bfd_get_filename (obfd));
		      return FALSE;
		    }
d1324 1
a1324 6
  if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour
      && strip_symbols == STRIP_NONDEBUG)
    /* Do not copy the private data when creating an ELF format
       debug info file.  We do not want the program headers.  */
    ;
  else if (! bfd_copy_private_bfd_data (ibfd, obfd))
d1329 2
a1330 1
      return FALSE;
d1336 5
a1340 5
  if (use_alt_mach_code != 0
      && ! bfd_alt_mach_code (obfd, use_alt_mach_code))
    non_fatal (_("unknown alternate machine code, ignored"));

  return TRUE;
d1354 4
a1357 1
copy_archive (bfd *ibfd, bfd *obfd, const char *output_target)
d1371 4
a1374 3
    fatal (_("cannot mkdir %s for archive copying (error: %s)"),
	   dir, strerror (errno));

d1384 1
a1384 1
  while (!status && this_element != NULL)
a1390 1
      bfd_boolean delete = TRUE;
d1401 5
a1405 4
	    fatal (_("cannot mkdir %s for archive copying (error: %s)"),
		   output_name, strerror (errno));

	  l = xmalloc (sizeof (struct name_list));
d1424 1
a1424 1
      l = xmalloc (sizeof (struct name_list));
d1429 1
a1429 1
      if (output_bfd == NULL)
d1433 1
a1433 1
	delete = ! copy_object (this_element, output_bfd);
d1442 2
a1443 9
      if (delete)
	{
	  unlink (output_name);
	  status = 1;
	}
      else
	{
	  if (preserve_dates && stat_status == 0)
	    set_times (output_name, &buf);
d1445 2
a1446 2
	  /* Open the newly output file and attach to our list.  */
	  output_bfd = bfd_openr (output_name, output_target);
d1448 1
a1448 1
	  l->obfd = output_bfd;
d1450 2
a1451 2
	  *ptr = output_bfd;
	  ptr = &output_bfd->next;
d1453 1
a1453 1
	  last_element = this_element;
d1455 1
a1455 1
	  this_element = bfd_openr_next_archived_file (ibfd, last_element);
d1457 1
a1457 2
	  bfd_close (last_element);
	}
d1459 1
a1459 1
  *ptr = NULL;
d1484 5
a1488 2
copy_file (const char *input_filename, const char *output_filename,
	   const char *input_target,   const char *output_target)
a1493 6
  if (get_file_size (input_filename) < 1)
    {
      status = 1;
      return;
    }

a1517 1
      bfd_boolean delete;
a1518 1

d1528 1
a1528 1
      delete = ! copy_object (ibfd, obfd);
a1534 6

      if (delete)
	{
	  unlink (output_filename);
	  status = 1;
	}
d1574 4
a1577 2
add_section_rename (const char * old_name, const char * new_name,
		    flagword flags)
d1593 1
a1593 1
  rename = xmalloc (sizeof (* rename));
d1608 4
a1611 2
find_section_rename (bfd * ibfd ATTRIBUTE_UNUSED, sec_ptr isection,
		     flagword * returned_flags)
d1635 4
a1638 1
setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)
d1640 1
a1640 1
  bfd *obfd = obfdarg;
d1651 6
a1656 1
  if (is_strip_section (ibfd, isection))
d1663 5
d1672 1
a1672 2
  if ((prefix_alloc_sections_string)
      && (bfd_get_section_flags (ibfd, isection) & SEC_ALLOC))
a1744 7
  else if (strip_symbols == STRIP_NONDEBUG && (flags & SEC_ALLOC) != 0)
    {
      flags &= ~(SEC_HAS_CONTENTS | SEC_LOAD);
      if (obfd->xvec->flavour == bfd_target_elf_flavour)
	elf_section_type (osection) = SHT_NOBITS;
    }

d1762 1
a1762 6
  if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour
      && strip_symbols == STRIP_NONDEBUG)
    /* Do not copy the private data when creating an ELF format
       debug info file.  We do not want the program headers.  */
    ;
  else if (!bfd_copy_private_section_data (ibfd, isection, obfd, osection))
d1784 4
a1787 1
copy_section (bfd *ibfd, sec_ptr isection, void *obfdarg)
d1789 1
a1789 1
  bfd *obfd = obfdarg;
d1803 7
a1809 1
  if (is_strip_section (ibfd, isection))
a1811 1
  flags = bfd_get_section_flags (ibfd, isection);
d1815 7
a1827 2
  p = find_section_list (bfd_get_section_name (ibfd, isection), FALSE);

d1832 1
a1832 2
    {
      relsize = bfd_get_reloc_upper_bound (ibfd, isection);
d1834 2
a1835 9
      if (relsize < 0)
	{
	  /* Do not complain if the target does not support relocations.  */
	  if (relsize == -1 && bfd_get_error () == bfd_error_invalid_operation)
	    relsize = 0;
	  else
	    RETURN_NONFATAL (bfd_get_filename (ibfd));
	}
    }
d1838 1
a1838 1
    bfd_set_reloc (obfd, osection, NULL, 0);
d1841 1
a1841 1
      relpp = xmalloc (relsize);
d1854 1
a1854 1
	  temp_relpp = xmalloc (relsize);
d1856 3
a1858 2
	    if (is_specified_symbol (bfd_asymbol_name (*relpp[i]->sym_ptr_ptr),
				     keep_specific_list))
d1865 2
a1866 3
      bfd_set_reloc (obfd, osection, relcount == 0 ? NULL : relpp, relcount);
      if (relcount == 0)
	free (relpp);
d1875 1
a1875 1
      void *memhunk = xmalloc (size);
d1877 2
a1878 1
      if (!bfd_get_section_contents (ibfd, isection, memhunk, 0, size))
d1882 1
a1882 12
	{
	  /* Keep only every `copy_byte'th byte in MEMHUNK.  */
	  char *from = (char *) memhunk + copy_byte;
	  char *to = memhunk;
	  char *end = (char *) memhunk + size;

	  for (; from < end; from += interleave)
	    *to++ = *from;

	  size = (size + interleave - 1 - copy_byte) / interleave;
	  osection->lma /= interleave;
	}
d1884 2
a1885 1
      if (!bfd_set_section_contents (obfd, osection, memhunk, 0, size))
d1892 1
a1892 1
      void *memhunk = xmalloc (size);
d1901 2
a1902 1
      if (! bfd_set_section_contents (obfd, osection, memhunk, 0, size))
d1912 4
a1915 1
get_sections (bfd *obfd ATTRIBUTE_UNUSED, asection *osection, void *secppparg)
d1917 1
a1917 1
  asection ***secppp = secppparg;
d1928 3
a1930 1
compare_section_lma (const void *arg1, const void *arg2)
d1932 2
a1933 2
  const asection *const *sec1 = arg1;
  const asection *const *sec2 = arg2;
d1974 4
a1977 1
mark_symbols_used_in_relocations (bfd *ibfd, sec_ptr isection, void *symbolsarg)
d1979 1
a1979 1
  asymbol **symbols = symbolsarg;
d1990 1
a1990 6
    {
      /* Do not complain if the target does not support relocations.  */
      if (relsize == -1 && bfd_get_error () == bfd_error_invalid_operation)
	return;
      bfd_fatal (bfd_get_filename (ibfd));
    }
d1995 1
a1995 1
  relpp = xmalloc (relsize);
d2017 5
a2021 3
write_debugging_info (bfd *obfd, void *dhandle,
		      long *symcountp ATTRIBUTE_UNUSED,
		      asymbol ***symppp ATTRIBUTE_UNUSED)
d2065 4
a2068 3
      if (! bfd_set_section_contents (obfd, stabsec, syms, 0, symsize)
	  || ! bfd_set_section_contents (obfd, stabstrsec, strings, 0,
					 stringsize))
d2085 3
a2087 1
strip_main (int argc, char *argv[])
d2098 1
a2098 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXHhVvw",
a2154 3
	case OPTION_ONLY_KEEP_DEBUG:
	  strip_symbols = STRIP_NONDEBUG;
	  break;
a2157 3
	case 'w':
	  wildcard = TRUE;
	  break;
d2166 5
a2170 5
  if (formats_info)
    {
      display_info ();
      return 0;
    }
d2181 1
a2181 1
  if (output_target == NULL)
a2194 3
      if (get_file_size (argv[i]) < 1)
	continue;

d2196 7
a2202 3
	/* No need to check the return value of stat().
	   It has already been checked in get_file_size().  */
	stat (argv[i], &statbuf);
d2229 3
a2231 1
copy_main (int argc, char *argv[])
d2245 1
a2245 1
  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:w",
a2307 8
	case OPTION_ONLY_KEEP_DEBUG:
	  strip_symbols = STRIP_NONDEBUG;
	  break;

	case OPTION_ADD_GNU_DEBUGLINK:
	  gnu_debuglink_filename = optarg;
	  break;

a2331 4
	case 'w':
	  wildcard = TRUE;
	  break;

d2359 1
a2359 1
	    off_t size;
d2370 2
a2371 3
	    size = get_file_size (s + 1);
	    if (size < 1)
	      break;
d2373 1
a2373 1
	    pa = xmalloc (sizeof (struct section_add));
d2376 1
a2376 1
	    name = xmalloc (len + 1);
a2381 2
	    pa->size = size;
	    pa->contents = xmalloc (size);
d2383 3
d2389 1
a2389 2
	      fatal (_("cannot open: %s: %s"),
		     pa->filename, strerror (errno));
d2443 1
a2443 1
	    name = xmalloc (len + 1);
d2541 1
a2541 1
	    source = xmalloc (len + 1);
d2547 1
a2547 1
	    target = xmalloc (len + 1);
d2550 1
a2550 1
	    redefine_list_append ("--redefine-sym", source, target);
a2556 4
	case OPTION_REDEFINE_SYMS:
	  add_redefine_syms_file (optarg);
	  break;

d2568 1
a2568 1
	    name = xmalloc (len + 1);
d2595 1
a2595 1
	    old_name = xmalloc (len + 1);
d2615 1
a2615 1
	    new_name = xmalloc (len + 1);
a2673 20
	case OPTION_READONLY_TEXT:
	  bfd_flags_to_set |= WP_TEXT;
	  bfd_flags_to_clear &= ~WP_TEXT;
	  break;

	case OPTION_WRITABLE_TEXT:
	  bfd_flags_to_clear |= WP_TEXT;
	  bfd_flags_to_set &= ~WP_TEXT;
	  break;

	case OPTION_PURE:
	  bfd_flags_to_set |= D_PAGED;
	  bfd_flags_to_clear &= ~D_PAGED;
	  break;

	case OPTION_IMPURE:
	  bfd_flags_to_clear |= D_PAGED;
	  bfd_flags_to_set &= ~D_PAGED;
	  break;

d2675 1
a2675 2
	  /* We've been given a long option.  */
	  break;
d2709 1
a2709 1
  if (output_target == NULL)
d2712 1
a2712 1
  if (binary_architecture != NULL)
d2721 1
a2721 4
	    {
	      bfd_external_binary_architecture = temp_arch_info->arch;
	      bfd_external_machine             = temp_arch_info->mach;
	    }
d2734 1
a2734 2
      fatal (_("warning: could not locate '%s'.  System error message: %s"),
	     input_filename, strerror (errno));
d2737 3
a2739 2
     are the same, then create a temp and rename the result into the input.  */
  if (output_filename == NULL || strcmp (input_filename, output_filename) == 0)
d2801 2
d2804 3
a2806 1
main (int argc, char *argv[])
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d1834 1
a1834 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXhVv",
d1966 1
a1966 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXhVvW:",
@


1.1.1.3
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d3 1
a3 1
   2001, 2002, 2003
d35 1
a35 1
   deleted.  */
d51 12
a62 36
typedef struct section_rename
{
  const char *            old_name;
  const char *            new_name;
  flagword                flags;
  struct section_rename * next;
}
section_rename;

/* List of sections to be renamed.  */
static section_rename * section_rename_list;

static void copy_usage
  PARAMS ((FILE *, int));
static void strip_usage
  PARAMS ((FILE *, int));
static flagword parse_flags
  PARAMS ((const char *));
static struct section_list *find_section_list
  PARAMS ((const char *, bfd_boolean));
static void setup_section
  PARAMS ((bfd *, asection *, PTR));
static void copy_section
  PARAMS ((bfd *, asection *, PTR));
static void get_sections
  PARAMS ((bfd *, asection *, PTR));
static int compare_section_lma
  PARAMS ((const PTR, const PTR));
static void add_specific_symbol
  PARAMS ((const char *, struct symlist **));
static void add_specific_symbols
  PARAMS ((const char *, struct symlist **));
static bfd_boolean is_specified_symbol
  PARAMS ((const char *, struct symlist *));
static bfd_boolean is_strip_section
  PARAMS ((bfd *, asection *));
d65 5
a69 10
static void mark_symbols_used_in_relocations
  PARAMS ((bfd *, asection *, PTR));
static void filter_bytes
  PARAMS ((char *, bfd_size_type *));
static bfd_boolean write_debugging_info
  PARAMS ((bfd *, PTR, long *, asymbol ***));
static void copy_object
  PARAMS ((bfd *, bfd *));
static void copy_archive
  PARAMS ((bfd *, bfd *, const char *));
d72 4
a75 12
static int strip_main
  PARAMS ((int, char **));
static int copy_main
  PARAMS ((int, char **));
static const char *lookup_sym_redefinition
  PARAMS((const char *));
static void redefine_list_append
  PARAMS ((const char *, const char *));
static const char * find_section_rename
  PARAMS ((bfd *, sec_ptr, flagword *));
static void add_section_rename
  PARAMS ((const char *, const char *, flagword));
d86 2
a87 2
static bfd_boolean verbose;		/* Print file and target names.  */
static bfd_boolean preserve_dates;	/* Preserve input file timestamp.  */
d99 1
a99 1
/* Which symbols to remove.  */
d123 11
a133 11
  struct section_list * next;	   /* Next section to change.  */
  const char *		name;	   /* Section name.  */
  bfd_boolean		used;	   /* Whether this entry was used.  */
  bfd_boolean		remove;	   /* Whether to remove this section.  */
  bfd_boolean		copy;	   /* Whether to copy this section.  */
  enum change_action	change_vma;/* Whether to change or set VMA.  */
  bfd_vma		vma_val;   /* Amount to change by or set to.  */
  enum change_action	change_lma;/* Whether to change or set LMA.  */
  bfd_vma		lma_val;   /* Amount to change by or set to.  */
  bfd_boolean		set_flags; /* Whether to set the section flags.	 */
  flagword		flags;	   /* What to set the section flags to.	 */
d137 2
a138 6

/* TRUE if some sections are to be removed.  */
static bfd_boolean sections_removed;

/* TRUE if only some sections are to be copied.  */
static bfd_boolean sections_copied;
d142 1
a142 1
static bfd_boolean set_start_set = FALSE;
d149 1
a149 1
static bfd_boolean gap_fill_set = FALSE;
d153 1
a153 1
static bfd_boolean pad_to_set = FALSE;
d156 1
a156 2
/* Use alternate machine code?  */
static int use_alt_mach_code = 0;
a157 1
/* List of sections to add.  */
a173 1
/* List of sections to add to the output BFD.  */
d177 2
a178 1
static bfd_boolean convert_debugging = FALSE;
d181 2
a182 1
static bfd_boolean change_leading_char = FALSE;
d185 2
a186 1
static bfd_boolean remove_leading_char = FALSE;
d190 1
d198 1
a198 2
/* If this is TRUE, we weaken global symbols (set BSF_WEAK).  */
static bfd_boolean weaken = FALSE;
d200 1
a200 4
/* Prefix symbols/sections.  */
static char *prefix_symbols_string = 0;
static char *prefix_sections_string = 0;
static char *prefix_alloc_sections_string = 0;
a228 6
#define OPTION_RENAME_SECTION (OPTION_WEAKEN_SYMBOLS + 1)
#define OPTION_ALT_MACH_CODE (OPTION_RENAME_SECTION + 1)
#define OPTION_PREFIX_SYMBOLS (OPTION_ALT_MACH_CODE + 1)
#define OPTION_PREFIX_SECTIONS (OPTION_PREFIX_SYMBOLS + 1)
#define OPTION_PREFIX_ALLOC_SECTIONS (OPTION_PREFIX_SECTIONS + 1)
#define OPTION_FORMATS_INFO (OPTION_PREFIX_ALLOC_SECTIONS + 1)
a237 1
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
a242 1
  {"output-file", required_argument, 0, 'o'},
a263 2
  {"alt-machine-code", required_argument, 0, OPTION_ALT_MACH_CODE},
  {"binary-architecture", required_argument, 0, 'B'},
d275 1
a278 1
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
a281 2
  {"keep-global-symbol", required_argument, 0, 'G'},
  {"keep-global-symbols", required_argument, 0, OPTION_KEEPGLOBAL_SYMBOLS},
a282 3
  {"keep-symbols", required_argument, 0, OPTION_KEEP_SYMBOLS},
  {"localize-symbol", required_argument, 0, 'L'},
  {"localize-symbols", required_argument, 0, OPTION_LOCALIZE_SYMBOLS},
a284 1
  {"only-section", required_argument, 0, 'j'},
a287 3
  {"prefix-symbols", required_argument, 0, OPTION_PREFIX_SYMBOLS},
  {"prefix-sections", required_argument, 0, OPTION_PREFIX_SECTIONS},
  {"prefix-alloc-sections", required_argument, 0, OPTION_PREFIX_ALLOC_SECTIONS},
d289 2
a290 1
  {"redefine-sym", required_argument, 0, OPTION_REDEFINE_SYM},
a292 1
  {"rename-section", required_argument, 0, OPTION_RENAME_SECTION},
a294 2
  {"srec-len", required_argument, 0, OPTION_SREC_LEN},
  {"srec-forceS3", no_argument, 0, OPTION_SREC_FORCES3},
a298 1
  {"strip-symbols", required_argument, 0, OPTION_STRIP_SYMBOLS},
d304 7
d320 1
a320 1
   -1 means if we should use argv[0] to decide.  */
d330 1
a330 4
extern bfd_boolean S3Forced;

/* Defined in bfd/binary.c.  Used to set architecture of input binary files.  */
extern enum bfd_architecture bfd_external_binary_architecture;
a331 1

d337 2
a338 3
  fprintf (stream, _("Usage: %s [option(s)] in-file [out-file]\n"), program_name);
  fprintf (stream, _(" Copies a binary file, possibly transforming it in the process\n"));
  fprintf (stream, _(" The options are:\n"));
a341 1
  -B --binary-architecture <arch>  Set arch of output file, when input is binary\n\
a377 1
     --rename-section <old>=<new>[,<flags>] Rename section <old> to <new>\n\
a387 6
     --alt-machine-code <index>    Use alternate machine code for output\n\
     --prefix-symbols <prefix>     Add <prefix> to start of every symbol name\n\
     --prefix-sections <prefix>    Add <prefix> to start of every section name\n\
     --prefix-alloc-sections <prefix>\n\
                                   Add <prefix> to start of every allocatable\n\
                                     section name\n\
a390 1
     --info                        List object formats & architectures supported\n\
d403 2
a404 3
  fprintf (stream, _("Usage: %s <option(s)> in-file(s)\n"), program_name);
  fprintf (stream, _(" Removes symbols and sections from files\n"));
  fprintf (stream, _(" The options are:\n"));
d406 3
a408 3
  -I --input-target=<bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target=<bfdname>     Create an output file in format <bfdname>\n\
  -F --target=<bfdname>            Set both input and output format to <bfdname>\n\
d410 1
a410 1
  -R --remove-section=<name>       Remove section <name> from the output\n\
d412 1
a412 1
  -g -S -d --strip-debug           Remove all debugging symbols\n\
d414 2
a415 2
  -N --strip-symbol=<name>         Do not copy symbol <name>\n\
  -K --keep-symbol=<name>          Only copy symbol <name>\n\
a420 1
     --info                        List object formats & architectures supported\n\
d492 1
a492 1
     bfd_boolean add;
d505 3
a507 3
  p->used = FALSE;
  p->remove = FALSE;
  p->copy = FALSE;
d512 1
a512 1
  p->set_flags = FALSE;
d536 1
a536 1
/* Add symbols listed in `filename' to strip_specific_list.  */
d551 1
a551 1

d570 1
a570 1

d576 1
a576 1
      int finished = FALSE;
d587 1
a587 1
	      finished = TRUE;
d589 1
a589 1

d595 1
a595 1
	      finished = TRUE;
d597 1
a597 1

d599 1
a599 1
	      finished = TRUE;
d601 1
a601 1

d608 1
a608 1

d625 2
a626 2
	   name_end ++)
	;
d639 1
a639 1

d655 1
a655 1
static bfd_boolean
d663 5
a667 4
    if (strcmp (name, tmp_list->name) == 0)
      return TRUE;

  return FALSE;
d672 1
a672 1
static bfd_boolean
d685 1
a685 1
    return TRUE;
d688 1
a688 1
    return FALSE;
d690 1
a690 1
  p = find_section_list (bfd_get_section_name (abfd, sec), FALSE);
d692 1
a692 1
    return TRUE;
d694 2
a695 2
    return TRUE;
  return FALSE;
d718 1
a718 1
      char *name = (char *) bfd_asymbol_name (sym);
a719 3
      bfd_boolean undefined;
      bfd_boolean rem_leading_char;
      bfd_boolean add_leading_char;
d721 8
a728 1
      undefined = bfd_is_und_section (bfd_get_section (sym));
d730 5
a734 1
      if (redefine_sym_list)
d736 5
a740 1
	  char *old_name, *new_name;
d742 8
a749 53
	  old_name = (char *) bfd_asymbol_name (sym);
	  new_name = (char *) lookup_sym_redefinition (old_name);
	  bfd_asymbol_name (sym) = new_name;
	  name = new_name;
	}

      /* Check if we will remove the current leading character.  */
      rem_leading_char =
	(name[0] == bfd_get_symbol_leading_char (abfd))
	&& (change_leading_char
	    || (remove_leading_char
		&& ((flags & (BSF_GLOBAL | BSF_WEAK)) != 0
		    || undefined
		    || bfd_is_com_section (bfd_get_section (sym)))));

      /* Check if we will add a new leading character.  */
      add_leading_char =
	change_leading_char
	&& (bfd_get_symbol_leading_char (obfd) != '\0')
	&& (bfd_get_symbol_leading_char (abfd) == '\0'
	    || (name[0] == bfd_get_symbol_leading_char (abfd)));

      /* Short circuit for change_leading_char if we can do it in-place.  */
      if (rem_leading_char && add_leading_char && !prefix_symbols_string)
        {
	  name[0] = bfd_get_symbol_leading_char (obfd);
	  bfd_asymbol_name (sym) = name;
	  rem_leading_char = FALSE;
	  add_leading_char = FALSE;
        }

      /* Remove leading char.  */
      if (rem_leading_char)
	bfd_asymbol_name (sym) = ++name;

      /* Add new leading char and/or prefix.  */
      if (add_leading_char || prefix_symbols_string)
        {
          char *n, *ptr;

          ptr = n = xmalloc (1 + strlen (prefix_symbols_string) + strlen (name) + 1);
          if (add_leading_char)
	    *ptr++ = bfd_get_symbol_leading_char (obfd);

          if (prefix_symbols_string)
            {
              strcpy (ptr, prefix_symbols_string);
              ptr += strlen (prefix_symbols_string);
           }

          strcpy (ptr, name);
          bfd_asymbol_name (sym) = n;
          name = n;
d752 8
d767 1
a767 1
      else if (relocatable			/* Relocatable file.  */
d772 1
a772 1
	   even if relocatable is FALSE.  External users of the
d775 1
a775 1
	keep = 1;
d778 1
a778 1
	       || undefined
a784 4
      else if (bfd_get_section (sym)->comdat)
	/* COMDAT sections store special information in local
	   symbols, so we cannot risk stripping any of them.  */
	keep = 1;
d804 1
a804 1
      if (keep && !undefined && (flags & (BSF_GLOBAL | BSF_WEAK))
a821 2
/* Find the redefined name of symbol SOURCE.  */

d826 1
d829 2
d832 8
a839 4
    if (strcmp (source, list->source) == 0)
      return list->target;

  return source;
d842 1
a842 1
/* Add a node to a symbol redefine list.  */
d856 5
a860 3
	fatal (_("%s: Multiple redefinition of symbol \"%s\""),
	       "--redefine-sym",
	       source);
d863 5
a867 3
	fatal (_("%s: Symbol \"%s\" is target of more than one redefinition"),
	       "--redefine-sym",
	       target);
d879 1
a891 1

a911 2
  enum bfd_architecture iarch;
  unsigned int imach;
d935 5
a939 10
  /* Neither the start address nor the flags
     need to be set for a core file.  */
  if (bfd_get_format (obfd) != bfd_core)
    {
      if (!bfd_set_start_address (obfd, start)
	  || !bfd_set_file_flags (obfd,
				  (bfd_get_file_flags (ibfd)
				   & bfd_applicable_file_flags (obfd))))
	RETURN_NONFATAL (bfd_get_filename (ibfd));
    }
d941 3
a943 6
  /* Copy architecture of input file to output file.  */
  iarch = bfd_get_arch (ibfd);
  imach = bfd_get_mach (ibfd);
  if (!bfd_set_arch_mach (obfd, iarch, imach)
      && (ibfd->target_defaulted
	  || bfd_get_arch (ibfd) != bfd_get_arch (obfd)))
d983 1
a983 1
	      pset = find_section_list (padd->name, FALSE);
d985 1
a985 1
		pset->used = TRUE;
d1058 2
a1059 2
				 bfd_get_section_name (obfd, osections[i]),
				 bfd_errmsg (bfd_get_error ()));
d1083 2
a1084 2
			     bfd_get_section_name (obfd, osections[c - 1]),
			     bfd_errmsg (bfd_get_error ()));
d1097 2
a1098 2
  /* Symbol filtering must happen after the output sections
     have been created, but before their contents are set.  */
a1120 1
      || prefix_symbols_string
d1179 1
a1194 1

d1219 1
a1219 1
  if (! bfd_copy_private_bfd_data (ibfd, obfd))
a1226 9

  /* Switch to the alternate machine code.  We have to do this at the
     very end, because we only initialize the header when we create
     the first section.  */
  if (use_alt_mach_code != 0)
    {
      if (!bfd_alt_mach_code (obfd, use_alt_mach_code))
	non_fatal (_("unknown alternate machine code, ignored"));
    }
d1241 1
a1241 1
      const char *name;
a1258 4

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    RETURN_NONFATAL (bfd_get_filename (obfd));

d1261 4
a1264 2
      char *output_name;
      bfd *output_bfd;
a1268 23
      /* Create an output file for this member.  */
      output_name = concat (dir, "/",
			    bfd_get_filename (this_element), (char *) 0);

      /* If the file already exists, make another temp dir.  */
      if (stat (output_name, &buf) >= 0)
	{
	  output_name = make_tempname (output_name, 1);
	  if (output_name == (char *) NULL)
	    {
	      fatal (_("cannot make temp directory for archive copying (error: %s)"),
		     strerror (errno));
	    }
	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
	  l->name = output_name;
	  l->next = list;
	  l->obfd = NULL;
	  list = l;
	  output_name = concat (output_name, "/",
				bfd_get_filename (this_element), (char *) 0);
	}

      output_bfd = bfd_openw (output_name, output_target);
a1271 1

d1285 4
a1288 1
      if (bfd_check_format (this_element, bfd_object))
d1294 1
a1294 1
	  /* Error in new object file. Don't change archive.  */
d1326 2
a1327 7
      if (l->obfd == NULL)
	rmdir (l->name);
      else
	{
	  bfd_close (l->obfd);
	  unlink (l->name);
	}
d1342 1
a1342 2
  char **obj_matching;
  char **core_matching;
d1346 1
d1366 1
a1366 1
  else if (bfd_check_format_matches (ibfd, bfd_object, &obj_matching))
d1369 1
a1369 1
    do_copy:
a1388 16
      bfd_error_type obj_error = bfd_get_error ();
      bfd_error_type core_error;

      if (bfd_check_format_matches (ibfd, bfd_core, &core_matching))
	{
	  /* This probably can't happen..  */
	  if (obj_error == bfd_error_file_ambiguously_recognized)
	    free (obj_matching);
	  goto do_copy;
	}

      core_error = bfd_get_error ();
      /* Report the object error in preference to the core error.  */
      if (obj_error != core_error)
	bfd_set_error (obj_error);

d1391 1
a1391 6
      if (obj_error == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (obj_matching);
	  free (obj_matching);
	}
      if (core_error == bfd_error_file_ambiguously_recognized)
d1393 2
a1394 2
	  list_matching_formats (core_matching);
	  free (core_matching);
d1401 2
a1402 62
/* Add a name to the section renaming list.  */

static void
add_section_rename (old_name, new_name, flags)
     const char * old_name;
     const char * new_name;
     flagword flags;
{
  section_rename * rename;

  /* Check for conflicts first.  */
  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
      {
	/* Silently ignore duplicate definitions.  */
	if (strcmp (rename->new_name, new_name) == 0
	    && rename->flags == flags)
	  return;

	fatal (_("Multiple renames of section %s"), old_name);
      }

  rename = (section_rename *) xmalloc (sizeof (* rename));

  rename->old_name = old_name;
  rename->new_name = new_name;
  rename->flags    = flags;
  rename->next     = section_rename_list;

  section_rename_list = rename;
}

/* Check the section rename list for a new name of the input section
   ISECTION.  Return the new name if one is found.
   Also set RETURNED_FLAGS to the flags to be used for this section.  */

static const char *
find_section_rename (ibfd, isection, returned_flags)
     bfd * ibfd ATTRIBUTE_UNUSED;
     sec_ptr isection;
     flagword * returned_flags;
{
  const char * old_name = bfd_section_name (ibfd, isection);
  section_rename * rename;

  /* Default to using the flags of the input section.  */
  * returned_flags = bfd_get_section_flags (ibfd, isection);

  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
      {
	if (rename->flags != (flagword) -1)
	  * returned_flags = rename->flags;

	return rename->new_name;
      }

  return old_name;
}

/* Create a section in OBFD with the same
   name and attributes as ISECTION in IBFD.  */
a1417 2
  const char * name;
  char *prefix = NULL;
d1427 1
a1427 1
  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);
d1429 1
a1429 1
    p->used = TRUE;
d1436 1
a1436 20
  /* Get the, possibly new, name of the output section.  */
  name = find_section_rename (ibfd, isection, & flags);

  /* Prefix sections.  */
  if ((prefix_alloc_sections_string) && (bfd_get_section_flags (ibfd, isection) & SEC_ALLOC))
    prefix = prefix_alloc_sections_string;
  else if (prefix_sections_string)
    prefix = prefix_sections_string;

  if (prefix)
    {
      char *n;

      n = xmalloc (strlen (prefix) + strlen (name) + 1);
      strcpy (n, prefix);
      strcat (n, name);
      name = n;
    }

  osection = bfd_make_section_anyway (obfd, name);
d1484 4
a1487 3
  if (!bfd_set_section_alignment (obfd,
				  osection,
				  bfd_section_alignment (ibfd, isection)))
d1493 1
d1495 1
a1495 1
    flags = p->flags | (flags & (SEC_HAS_CONTENTS | SEC_RELOC));
a1501 3
  /* Copy merge entity size.  */
  osection->entsize = isection->entsize;

d1516 1
a1516 1
  /* All went well.  */
a1543 1
  flagword flags;
d1545 2
a1546 2
  /* If we have already failed earlier on,
     do not keep on generating complaints now.  */
d1550 1
a1550 2
  flags = bfd_get_section_flags (ibfd, isection);
  if ((flags & SEC_DEBUGGING) != 0
d1556 3
a1558 4
    return;

  if ((flags & SEC_GROUP) != 0)
    return;
d1560 1
a1560 1
  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);
a1572 5
  /* Core files do not need to be relocated.  */
  if (bfd_get_format (obfd) == bfd_core)
    relsize = 0;
  else
    relsize = bfd_get_reloc_upper_bound (ibfd, isection);
d1574 1
d1590 1
a1590 1
	     keep_strip_specific_list.  */
a1604 1

d1610 1
a1610 1
  isection->reloc_done = TRUE;
d1612 1
a1612 2
  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS
      && bfd_get_section_flags (obfd, osection) & SEC_HAS_CONTENTS)
d1755 1
a1755 1
static bfd_boolean
d1775 1
a1775 1
	return FALSE;
d1797 1
a1797 1
	  return FALSE;
d1812 1
a1812 1
	  return FALSE;
d1815 1
a1815 1
      return TRUE;
d1820 1
a1820 1
  return FALSE;
d1828 3
a1830 6
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean formats_info = FALSE;
  int c;
  int i;
d1834 1
a1834 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXHhVv",
d1849 3
a1851 3
	  p = find_section_list (optarg, TRUE);
	  p->remove = TRUE;
	  sections_removed = TRUE;
d1874 1
a1874 1
	  preserve_dates = TRUE;
d1883 1
a1883 1
	  verbose = TRUE;
d1886 1
a1886 4
	  show_version = TRUE;
	  break;
	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
d1889 1
a1889 3
	  /* We've been given a long option.  */
	  break;
	case 'H':
a1896 6
 if (formats_info)
   {
     display_info ();
     return 0;
   }
 
d1958 4
a1961 8
  char * binary_architecture = NULL;
  char *input_filename = NULL;
  char *output_filename = NULL;
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean change_warn = TRUE;
  bfd_boolean formats_info = FALSE;
d1966 1
a1966 1
  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:",
a1976 4
	case 'B':
	  binary_architecture = optarg;
	  break;

d1998 1
a1998 1
	  p = find_section_list (optarg, TRUE);
d2001 2
a2002 2
	  p->copy = TRUE;
	  sections_copied = TRUE;
d2006 1
a2006 1
	  p = find_section_list (optarg, TRUE);
d2009 2
a2010 2
	  p->remove = TRUE;
	  sections_removed = TRUE;
d2046 1
a2046 1
	  preserve_dates = TRUE;
d2058 1
a2058 1
	  verbose = TRUE;
d2062 1
a2062 5
	  show_version = TRUE;
	  break;

	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
d2066 1
a2066 1
	  weaken = TRUE;
d2160 1
a2160 1
	    p = find_section_list (name, TRUE);
d2197 1
a2197 1
	  change_warn = TRUE;
d2201 1
a2201 1
	  change_leading_char = TRUE;
d2205 1
a2205 1
	  convert_debugging = TRUE;
d2223 1
a2223 1
	    gap_fill_set = TRUE;
d2228 1
a2228 1
	  change_warn = FALSE;
d2233 1
a2233 1
	  pad_to_set = TRUE;
d2237 1
a2237 1
	  remove_leading_char = TRUE;
d2251 3
a2253 1
	      fatal (_("bad format for %s"), "--redefine-sym");
d2287 1
a2287 1
	    p = find_section_list (name, TRUE);
d2289 1
a2289 1
	    p->set_flags = TRUE;
a2293 44
	case OPTION_RENAME_SECTION:
	  {
	    flagword flags;
	    const char *eq, *fl;
	    char *old_name;
	    char *new_name;
	    unsigned int len;

	    eq = strchr (optarg, '=');
	    if (eq == NULL)
	      fatal (_("bad format for %s"), "--rename-section");

	    len = eq - optarg;
	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    old_name = (char *) xmalloc (len + 1);
	    strncpy (old_name, optarg, len);
	    old_name[len] = 0;

	    eq++;
	    fl = strchr (eq, ',');
	    if (fl)
	      {
		flags = parse_flags (fl + 1);
		len = fl - eq;
	      }
	    else
	      {
		flags = -1;
		len = strlen (eq);
	      }

	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    new_name = (char *) xmalloc (len + 1);
	    strncpy (new_name, eq, len);
	    new_name[len] = 0;

	    add_section_rename (old_name, new_name, flags);
	  }
	  break;

d2296 1
a2296 1
	  set_start_set = TRUE;
d2299 3
a2301 3
	case OPTION_SREC_LEN:
	  Chunk = parse_vma (optarg, "--srec-len");
	  break;
d2303 3
a2305 3
	case OPTION_SREC_FORCES3:
	  S3Forced = TRUE;
	  break;
a2326 18
	case OPTION_ALT_MACH_CODE:
	  use_alt_mach_code = atoi (optarg);
	  if (use_alt_mach_code <= 0)
	    fatal (_("alternate machine code index must be positive"));
	  break;

	case OPTION_PREFIX_SYMBOLS:
	  prefix_symbols_string = optarg;
	  break;

	case OPTION_PREFIX_SECTIONS:
	  prefix_sections_string = optarg;
	  break;

	case OPTION_PREFIX_ALLOC_SECTIONS:
	  prefix_alloc_sections_string = optarg;
	  break;

a2329 1
	case 'H':
a2337 6
  if (formats_info)
    {
      display_info ();
      return 0;
    }
 
d2358 1
a2358 1
  if (binary_architecture != (char *) NULL)
d2360 2
a2361 16
      if (input_target && strcmp (input_target, "binary") == 0)
	{
	  const bfd_arch_info_type * temp_arch_info;

	  temp_arch_info = bfd_scan_arch (binary_architecture);

	  if (temp_arch_info != NULL)
	    bfd_external_binary_architecture = temp_arch_info->arch;
	  else
	    fatal (_("architecture %s unknown"), binary_architecture);
	}
      else
	{
	  non_fatal (_("Warning: input target 'binary' required for binary architecture parameter."));
	  non_fatal (_(" Argument %s ignored"), binary_architecture);
	}
d2364 2
a2365 3
  if (preserve_dates)
    if (stat (input_filename, & statbuf) < 0)
      fatal (_("Cannot stat: %s: %s"), input_filename, strerror (errno));
d2367 1
a2367 4
  /* If there is no destination file, or the source and destination files
     are the same,  then create a temp and rename the result into the input.  */
  if ((output_filename == (char *) NULL) ||
      (strcmp (input_filename, output_filename) == 0))
a2383 1

a2427 2
int main PARAMS ((int, char **));

a2434 3
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
@


