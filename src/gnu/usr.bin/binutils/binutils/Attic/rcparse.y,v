head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.20.56.57;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.01.16;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.39.16;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.39.16;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.27.51;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.40.06;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.03.04;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.04.00;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@%{ /* rcparse.y -- parser for Windows rc files
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* This is a parser for Windows rc files.  It is based on the parser
   by Gunther Ebert <gunther.ebert@@ixos-leipzig.de>.  */

#include "bfd.h"
#include "bucomm.h"
#include "libiberty.h"
#include "windres.h"
#include "safe-ctype.h"

/* The current language.  */

static unsigned short language;

/* The resource information during a sub statement.  */

static struct res_res_info sub_res_info;

/* Dialog information.  This is built by the nonterminals styles and
   controls.  */

static struct dialog dialog;

/* This is used when building a style.  It is modified by the
   nonterminal styleexpr.  */

static unsigned long style;

/* These are used when building a control.  They are set before using
   control_params.  */

static unsigned long base_style;
static unsigned long default_style;
static unsigned long class;

%}

%union
{
  struct accelerator acc;
  struct accelerator *pacc;
  struct dialog_control *dialog_control;
  struct menuitem *menuitem;
  struct
  {
    struct rcdata_item *first;
    struct rcdata_item *last;
  } rcdata;
  struct rcdata_item *rcdata_item;
  struct stringtable_data *stringtable;
  struct fixed_versioninfo *fixver;
  struct ver_info *verinfo;
  struct ver_stringinfo *verstring;
  struct ver_varinfo *vervar;
  struct res_id id;
  struct res_res_info res_info;
  struct
  {
    unsigned short on;
    unsigned short off;
  } memflags;
  struct
  {
    unsigned long val;
    /* Nonzero if this number was explicitly specified as long.  */
    int dword;
  } i;
  unsigned long il;
  unsigned short is;
  const char *s;
  struct
  {
    unsigned long length;
    const char *s;
  } ss;
};

%token BEG END
%token ACCELERATORS VIRTKEY ASCII NOINVERT SHIFT CONTROL ALT
%token BITMAP
%token CURSOR
%token DIALOG DIALOGEX EXSTYLE CAPTION CLASS STYLE
%token AUTO3STATE AUTOCHECKBOX AUTORADIOBUTTON CHECKBOX COMBOBOX CTEXT
%token DEFPUSHBUTTON EDITTEXT GROUPBOX LISTBOX LTEXT PUSHBOX PUSHBUTTON
%token RADIOBUTTON RTEXT SCROLLBAR STATE3 USERBUTTON
%token BEDIT HEDIT IEDIT
%token FONT
%token ICON
%token LANGUAGE CHARACTERISTICS VERSIONK
%token MENU MENUEX MENUITEM SEPARATOR POPUP CHECKED GRAYED HELP INACTIVE
%token MENUBARBREAK MENUBREAK
%token MESSAGETABLE
%token RCDATA
%token STRINGTABLE
%token VERSIONINFO FILEVERSION PRODUCTVERSION FILEFLAGSMASK FILEFLAGS
%token FILEOS FILETYPE FILESUBTYPE BLOCKSTRINGFILEINFO BLOCKVARFILEINFO
%token VALUE
%token <s> BLOCK
%token MOVEABLE FIXED PURE IMPURE PRELOAD LOADONCALL DISCARDABLE
%token NOT
%token <s> QUOTEDSTRING STRING
%token <i> NUMBER
%token <ss> SIZEDSTRING
%token IGNORED_TOKEN

%type <pacc> acc_entries
%type <acc> acc_entry acc_event
%type <dialog_control> control control_params
%type <menuitem> menuitems menuitem menuexitems menuexitem
%type <rcdata> optrcdata_data optrcdata_data_int rcdata_data
%type <rcdata_item> opt_control_data
%type <fixver> fixedverinfo
%type <verinfo> verblocks
%type <verstring> vervals
%type <vervar> vertrans
%type <res_info> suboptions memflags_move_discard memflags_move
%type <memflags> memflag
%type <id> id optresidc resref
%type <il> exstyle parennumber
%type <il> numexpr posnumexpr cnumexpr optcnumexpr cposnumexpr
%type <is> acc_options acc_option menuitem_flags menuitem_flag
%type <s> file_name resname
%type <i> sizednumexpr sizedposnumexpr

%left '|'
%left '^'
%left '&'
%left '+' '-'
%left '*' '/' '%'
%right '~' NEG

%%

input:
	  /* empty */
	| input accelerator
	| input bitmap
	| input cursor
	| input dialog
	| input font
	| input icon
	| input language
	| input menu
	| input menuex
	| input messagetable
	| input rcdata
	| input stringtable
	| input user
	| input versioninfo
	| input IGNORED_TOKEN
	;

/* Accelerator resources.  */

accelerator:
	  id ACCELERATORS suboptions BEG acc_entries END
	  {
	    define_accelerator ($1, &$3, $5);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

acc_entries:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| acc_entries acc_entry
	  {
	    struct accelerator *a;

	    a = (struct accelerator *) res_alloc (sizeof *a);
	    *a = $2;
	    if ($1 == NULL)
	      $$ = a;
	    else
	      {
		struct accelerator **pp;

		for (pp = &$1->next; *pp != NULL; pp = &(*pp)->next)
		  ;
		*pp = a;
		$$ = $1;
	      }
	  }
	;

acc_entry:
	  acc_event cposnumexpr
	  {
	    $$ = $1;
	    $$.id = $2;
	  }
	| acc_event cposnumexpr ',' acc_options
	  {
	    $$ = $1;
	    $$.id = $2;
	    $$.flags |= $4;
	    if (($$.flags & ACC_VIRTKEY) == 0
		&& ($$.flags & (ACC_SHIFT | ACC_CONTROL)) != 0)
	      rcparse_warning (_("inappropriate modifiers for non-VIRTKEY"));
	  }
	;

acc_event:
	  QUOTEDSTRING
	  {
	    const char *s = $1;
	    char ch;

	    $$.next = NULL;
	    $$.id = 0;
	    ch = *s;
	    if (ch != '^')
	      $$.flags = 0;
	    else
	      {
		$$.flags = ACC_CONTROL | ACC_VIRTKEY;
		++s;
		ch = *s;
		ch = TOUPPER (ch);
	      }
	    $$.key = ch;
	    if (s[1] != '\0')
	      rcparse_warning (_("accelerator should only be one character"));
	  }
	| posnumexpr
	  {
	    $$.next = NULL;
	    $$.flags = 0;
	    $$.id = 0;
	    $$.key = $1;
	  }
	;

acc_options:
	  acc_option
	  {
	    $$ = $1;
	  }
	| acc_options ',' acc_option
	  {
	    $$ = $1 | $3;
	  }
	/* I've had one report that the comma is optional.  */
	| acc_options acc_option
	  {
	    $$ = $1 | $2;
	  }
	;

acc_option:
	  VIRTKEY
	  {
	    $$ = ACC_VIRTKEY;
	  }
	| ASCII
	  {
	    /* This is just the absence of VIRTKEY.  */
	    $$ = 0;
	  }
	| NOINVERT
	  {
	    $$ = ACC_NOINVERT;
	  }
	| SHIFT
	  {
	    $$ = ACC_SHIFT;
	  }
	| CONTROL
	  {
	    $$ = ACC_CONTROL;
	  }
	| ALT
	  {
	    $$ = ACC_ALT;
	  }
	;

/* Bitmap resources.  */

bitmap:
	  id BITMAP memflags_move file_name
	  {
	    define_bitmap ($1, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* Cursor resources.  */

cursor:
	  id CURSOR memflags_move_discard file_name
	  {
	    define_cursor ($1, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* Dialog resources.  */

dialog:
	  id DIALOG memflags_move exstyle posnumexpr cnumexpr cnumexpr
	    cnumexpr
	    {
	      memset (&dialog, 0, sizeof dialog);
	      dialog.x = $5;
	      dialog.y = $6;
	      dialog.width = $7;
	      dialog.height = $8;
	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
	      dialog.exstyle = $4;
	      dialog.menu.named = 1;
	      dialog.class.named = 1;
	      dialog.font = NULL;
	      dialog.ex = NULL;
	      dialog.controls = NULL;
	      sub_res_info = $3;
	      style = 0;
	    }
	    styles BEG controls END
	  {
	    define_dialog ($1, &sub_res_info, &dialog);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	| id DIALOGEX memflags_move exstyle posnumexpr cnumexpr cnumexpr
	    cnumexpr
	    {
	      memset (&dialog, 0, sizeof dialog);
	      dialog.x = $5;
	      dialog.y = $6;
	      dialog.width = $7;
	      dialog.height = $8;
	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
	      dialog.exstyle = $4;
	      dialog.menu.named = 1;
	      dialog.class.named = 1;
	      dialog.font = NULL;
	      dialog.ex = ((struct dialog_ex *)
			   res_alloc (sizeof (struct dialog_ex)));
	      memset (dialog.ex, 0, sizeof (struct dialog_ex));
	      dialog.controls = NULL;
	      sub_res_info = $3;
	      style = 0;
	    }
	    styles BEG controls END
	  {
	    define_dialog ($1, &sub_res_info, &dialog);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	| id DIALOGEX memflags_move exstyle posnumexpr cnumexpr cnumexpr
	    cnumexpr cnumexpr
	    {
	      memset (&dialog, 0, sizeof dialog);
	      dialog.x = $5;
	      dialog.y = $6;
	      dialog.width = $7;
	      dialog.height = $8;
	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
	      dialog.exstyle = $4;
	      dialog.menu.named = 1;
	      dialog.class.named = 1;
	      dialog.font = NULL;
	      dialog.ex = ((struct dialog_ex *)
			   res_alloc (sizeof (struct dialog_ex)));
	      memset (dialog.ex, 0, sizeof (struct dialog_ex));
	      dialog.ex->help = $9;
	      dialog.controls = NULL;
	      sub_res_info = $3;
	      style = 0;
	    }
	    styles BEG controls END
	  {
	    define_dialog ($1, &sub_res_info, &dialog);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

exstyle:
	  /* empty */
	  {
	    $$ = 0;
	  }
	| EXSTYLE '=' numexpr
	  {
	    $$ = $3;
	  }
	;

styles:
	  /* empty */
	| styles CAPTION QUOTEDSTRING
	  {
	    dialog.style |= WS_CAPTION;
	    style |= WS_CAPTION;
	    unicode_from_ascii ((int *) NULL, &dialog.caption, $3);
	  }
	| styles CLASS id
	  {
	    dialog.class = $3;
	  }
	| styles STYLE
	    styleexpr
	  {
	    dialog.style = style;
	  }
	| styles EXSTYLE numexpr
	  {
	    dialog.exstyle = $3;
	  }
	| styles CLASS QUOTEDSTRING
	  {
	    res_string_to_id (& dialog.class, $3);
	  }
	| styles FONT numexpr ',' QUOTEDSTRING
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
	    if (dialog.ex != NULL)
	      {
		dialog.ex->weight = 0;
		dialog.ex->italic = 0;
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = 0;
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = $7;
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr cnumexpr cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = $7;
		dialog.ex->charset = $8;
	      }
	  }
	| styles MENU id
	  {
	    dialog.menu = $3;
	  }
	| styles CHARACTERISTICS numexpr
	  {
	    sub_res_info.characteristics = $3;
	  }
	| styles LANGUAGE numexpr cnumexpr
	  {
	    sub_res_info.language = $3 | ($4 << SUBLANG_SHIFT);
	  }
	| styles VERSIONK numexpr
	  {
	    sub_res_info.version = $3;
	  }
	;

controls:
	  /* empty */
	| controls control
	  {
	    struct dialog_control **pp;

	    for (pp = &dialog.controls; *pp != NULL; pp = &(*pp)->next)
	      ;
	    *pp = $2;
	  }
	;

control:
	  AUTO3STATE
	    {
	      default_style = BS_AUTO3STATE | WS_TABSTOP;
	      base_style = BS_AUTO3STATE;
	      class = CTL_BUTTON;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| AUTOCHECKBOX
	    {
	      default_style = BS_AUTOCHECKBOX | WS_TABSTOP;
	      base_style = BS_AUTOCHECKBOX;
	      class = CTL_BUTTON;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| AUTORADIOBUTTON
	    {
	      default_style = BS_AUTORADIOBUTTON | WS_TABSTOP;
	      base_style = BS_AUTORADIOBUTTON;
	      class = CTL_BUTTON;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| BEDIT
	    {
	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      class = CTL_EDIT;
	    }
	    control_params
	  {
	    $$ = $3;
	    if (dialog.ex == NULL)
	      rcparse_warning (_("BEDIT requires DIALOGEX"));
	    res_string_to_id (&$$->class, "BEDIT");
	  }
	| CHECKBOX
	    {
	      default_style = BS_CHECKBOX | WS_TABSTOP;
	      base_style = BS_CHECKBOX | WS_TABSTOP;
	      class = CTL_BUTTON;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| COMBOBOX
	    {
	      default_style = CBS_SIMPLE | WS_TABSTOP;
	      base_style = 0;
	      class = CTL_COMBOBOX;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| CONTROL optresidc numexpr cnumexpr control_styleexpr cnumexpr
	    cnumexpr cnumexpr cnumexpr optcnumexpr opt_control_data
	  {
	    $$ = define_control ($2, $3, $6, $7, $8, $9, $4, style, $10);
	    if ($11 != NULL)
	      {
		if (dialog.ex == NULL)
		  rcparse_warning (_("control data requires DIALOGEX"));
		$$->data = $11;
	      }
	  }
	| CONTROL optresidc numexpr cnumexpr control_styleexpr cnumexpr
	    cnumexpr cnumexpr cnumexpr cnumexpr cnumexpr opt_control_data
	  {
	    $$ = define_control ($2, $3, $6, $7, $8, $9, $4, style, $10);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("help ID requires DIALOGEX"));
	    $$->help = $11;
	    $$->data = $12;
	  }
	| CONTROL optresidc numexpr ',' QUOTEDSTRING control_styleexpr
	    cnumexpr cnumexpr cnumexpr cnumexpr optcnumexpr opt_control_data
	  {
	    $$ = define_control ($2, $3, $7, $8, $9, $10, 0, style, $11);
	    if ($12 != NULL)
	      {
		if (dialog.ex == NULL)
		  rcparse_warning ("control data requires DIALOGEX");
		$$->data = $12;
	      }
	    $$->class.named = 1;
  	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
	  }
	| CONTROL optresidc numexpr ',' QUOTEDSTRING control_styleexpr
	    cnumexpr cnumexpr cnumexpr cnumexpr cnumexpr cnumexpr opt_control_data
	  {
	    $$ = define_control ($2, $3, $7, $8, $9, $10, 0, style, $11);
	    if (dialog.ex == NULL)
	      rcparse_warning ("help ID requires DIALOGEX");
	    $$->help = $12;
	    $$->data = $13;
	    $$->class.named = 1;
  	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
	  }
	| CTEXT
	    {
	      default_style = SS_CENTER | WS_GROUP;
	      base_style = SS_CENTER;
	      class = CTL_STATIC;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| DEFPUSHBUTTON
	    {
	      default_style = BS_DEFPUSHBUTTON | WS_TABSTOP;
	      base_style = BS_DEFPUSHBUTTON | WS_TABSTOP;
	      class = CTL_BUTTON;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| EDITTEXT
	    {
	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      class = CTL_EDIT;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| GROUPBOX
	    {
	      default_style = BS_GROUPBOX;
	      base_style = BS_GROUPBOX;
	      class = CTL_BUTTON;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| HEDIT
	    {
	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      class = CTL_EDIT;
	    }
	    control_params
	  {
	    $$ = $3;
	    if (dialog.ex == NULL)
	      rcparse_warning (_("IEDIT requires DIALOGEX"));
	    res_string_to_id (&$$->class, "HEDIT");
	  }
	| ICON resref numexpr cnumexpr cnumexpr opt_control_data
          {
	    $$ = define_icon_control ($2, $3, $4, $5, 0, 0, 0, $6,
				      dialog.ex);
          }
	| ICON resref numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    opt_control_data
          {
	    $$ = define_icon_control ($2, $3, $4, $5, 0, 0, 0, $8,
				      dialog.ex);
          }
	| ICON resref numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    icon_styleexpr optcnumexpr opt_control_data
          {
	    $$ = define_icon_control ($2, $3, $4, $5, style, $9, 0, $10,
				      dialog.ex);
          }
	| ICON resref numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    icon_styleexpr cnumexpr cnumexpr opt_control_data
          {
	    $$ = define_icon_control ($2, $3, $4, $5, style, $9, $10, $11,
				      dialog.ex);
          }
	| IEDIT
	    {
	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      class = CTL_EDIT;
	    }
	    control_params
	  {
	    $$ = $3;
	    if (dialog.ex == NULL)
	      rcparse_warning (_("IEDIT requires DIALOGEX"));
	    res_string_to_id (&$$->class, "IEDIT");
	  }
	| LISTBOX
	    {
	      default_style = LBS_NOTIFY | WS_BORDER;
	      base_style = LBS_NOTIFY | WS_BORDER;
	      class = CTL_LISTBOX;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| LTEXT
	    {
	      default_style = SS_LEFT | WS_GROUP;
	      base_style = SS_LEFT;
	      class = CTL_STATIC;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| PUSHBOX
	    {
	      default_style = BS_PUSHBOX | WS_TABSTOP;
	      base_style = BS_PUSHBOX;
	      class = CTL_BUTTON;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| PUSHBUTTON
	    {
	      default_style = BS_PUSHBUTTON | WS_TABSTOP;
	      base_style = BS_PUSHBUTTON | WS_TABSTOP;
	      class = CTL_BUTTON;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| RADIOBUTTON
	    {
	      default_style = BS_RADIOBUTTON | WS_TABSTOP;
	      base_style = BS_RADIOBUTTON;
	      class = CTL_BUTTON;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| RTEXT
	    {
	      default_style = SS_RIGHT | WS_GROUP;
	      base_style = SS_RIGHT;
	      class = CTL_STATIC;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| SCROLLBAR
	    {
	      default_style = SBS_HORZ;
	      base_style = 0;
	      class = CTL_SCROLLBAR;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| STATE3
	    {
	      default_style = BS_3STATE | WS_TABSTOP;
	      base_style = BS_3STATE;
	      class = CTL_BUTTON;
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| USERBUTTON resref numexpr ',' numexpr ',' numexpr ','
	    numexpr ',' numexpr ',' 
	    { style = WS_CHILD | WS_VISIBLE; }
	    styleexpr optcnumexpr
	  {
	    $$ = define_control ($2, $3, $5, $7, $9, $11, CTL_BUTTON,
				 style, $15);
	  }
	;

/* Parameters for a control.  The static variables DEFAULT_STYLE,
   BASE_STYLE, and CLASS must be initialized before this nonterminal
   is used.  DEFAULT_STYLE is the style to use if no style expression
   is specified.  BASE_STYLE is the base style to use if a style
   expression is specified; the style expression modifies the base
   style.  CLASS is the class of the control.  */

control_params:
	  optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    opt_control_data
	  {
	    $$ = define_control ($1, $2, $3, $4, $5, $6, class,
				 default_style | WS_CHILD | WS_VISIBLE, 0);
	    if ($7 != NULL)
	      {
		if (dialog.ex == NULL)
		  rcparse_warning (_("control data requires DIALOGEX"));
		$$->data = $7;
	      }
	  }
	| optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    control_params_styleexpr optcnumexpr opt_control_data
	  {
	    $$ = define_control ($1, $2, $3, $4, $5, $6, class, style, $8);
	    if ($9 != NULL)
	      {
		if (dialog.ex == NULL)
		  rcparse_warning (_("control data requires DIALOGEX"));
		$$->data = $9;
	      }
	  }
	| optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    control_params_styleexpr cnumexpr cnumexpr opt_control_data
	  {
	    $$ = define_control ($1, $2, $3, $4, $5, $6, class, style, $8);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("help ID requires DIALOGEX"));
	    $$->help = $9;
	    $$->data = $10;
	  }
	;

optresidc:
	  /* empty */
	  {
	    res_string_to_id (&$$, "");
	  }
	| posnumexpr ','
	  {
	    $$.named = 0;
	    $$.u.id = $1;
	  }
	| QUOTEDSTRING
	  {
	    res_string_to_id (&$$, $1);
	  }
	| QUOTEDSTRING ','
	  {
	    res_string_to_id (&$$, $1);
	  }
	;

opt_control_data:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| BEG optrcdata_data END
	  {
	    $$ = $2.first;
	  }
	;

/* These only exist to parse a reduction out of a common case.  */

control_styleexpr:
	  ','
	  { style = WS_CHILD | WS_VISIBLE; }
	  styleexpr
	;

icon_styleexpr:
	  ','
	  { style = SS_ICON | WS_CHILD | WS_VISIBLE; }
	  styleexpr
	;

control_params_styleexpr:
	  ','
	  { style = base_style | WS_CHILD | WS_VISIBLE; }
	  styleexpr
	;

/* Font resources.  */

font:
	  id FONT memflags_move_discard file_name
	  {
	    define_font ($1, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* Icon resources.  */

icon:
	  id ICON memflags_move_discard file_name
	  {
	    define_icon ($1, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* Language command.  This changes the static variable language, which
   affects all subsequent resources.  */

language:
	  LANGUAGE numexpr cnumexpr
	  {
	    language = $2 | ($3 << SUBLANG_SHIFT);
	  }
	;

/* Menu resources.  */

menu:
	  id MENU suboptions BEG menuitems END
	  {
	    define_menu ($1, &$3, $5);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

menuitems:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| menuitems menuitem
	  {
	    if ($1 == NULL)
	      $$ = $2;
	    else
	      {
		struct menuitem **pp;

		for (pp = &$1->next; *pp != NULL; pp = &(*pp)->next)
		  ;
		*pp = $2;
		$$ = $1;
	      }
	  }
	;

menuitem:
	  MENUITEM QUOTEDSTRING cnumexpr menuitem_flags
	  {
	    $$ = define_menuitem ($2, $3, $4, 0, 0, NULL);
	  }
	| MENUITEM SEPARATOR
	  {
	    $$ = define_menuitem (NULL, 0, 0, 0, 0, NULL);
	  }
	| POPUP QUOTEDSTRING menuitem_flags BEG menuitems END
	  {
	    $$ = define_menuitem ($2, 0, $3, 0, 0, $5);
	  }
	;

menuitem_flags:
	  /* empty */
	  {
	    $$ = 0;
	  }
	| menuitem_flags ',' menuitem_flag
	  {
	    $$ = $1 | $3;
	  }
	| menuitem_flags menuitem_flag
	  {
	    $$ = $1 | $2;
	  }
	;

menuitem_flag:
	  CHECKED
	  {
	    $$ = MENUITEM_CHECKED;
	  }
	| GRAYED
	  {
	    $$ = MENUITEM_GRAYED;
	  }
	| HELP
	  {
	    $$ = MENUITEM_HELP;
	  }
	| INACTIVE
	  {
	    $$ = MENUITEM_INACTIVE;
	  }
	| MENUBARBREAK
	  {
	    $$ = MENUITEM_MENUBARBREAK;
	  }
	| MENUBREAK
	  {
	    $$ = MENUITEM_MENUBREAK;
	  }
	;

/* Menuex resources.  */

menuex:
	  id MENUEX suboptions BEG menuexitems END
	  {
	    define_menu ($1, &$3, $5);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

menuexitems:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| menuexitems menuexitem
	  {
	    if ($1 == NULL)
	      $$ = $2;
	    else
	      {
		struct menuitem **pp;

		for (pp = &$1->next; *pp != NULL; pp = &(*pp)->next)
		  ;
		*pp = $2;
		$$ = $1;
	      }
	  }
	;

menuexitem:
	  MENUITEM QUOTEDSTRING
	  {
	    $$ = define_menuitem ($2, 0, 0, 0, 0, NULL);
	  }
	| MENUITEM QUOTEDSTRING cnumexpr
	  {
	    $$ = define_menuitem ($2, $3, 0, 0, 0, NULL);
	  }
	| MENUITEM QUOTEDSTRING cnumexpr cnumexpr optcnumexpr
	  {
	    $$ = define_menuitem ($2, $3, $4, $5, 0, NULL);
	  }
 	| MENUITEM SEPARATOR
 	  {
 	    $$ = define_menuitem (NULL, 0, 0, 0, 0, NULL);
 	  }
	| POPUP QUOTEDSTRING BEG menuexitems END
	  {
	    $$ = define_menuitem ($2, 0, 0, 0, 0, $4);
	  }
	| POPUP QUOTEDSTRING cnumexpr BEG menuexitems END
	  {
	    $$ = define_menuitem ($2, $3, 0, 0, 0, $5);
	  }
	| POPUP QUOTEDSTRING cnumexpr cnumexpr BEG menuexitems END
	  {
	    $$ = define_menuitem ($2, $3, $4, 0, 0, $6);
	  }
	| POPUP QUOTEDSTRING cnumexpr cnumexpr cnumexpr optcnumexpr
	    BEG menuexitems END
	  {
	    $$ = define_menuitem ($2, $3, $4, $5, $6, $8);
	  }
	;

/* Messagetable resources.  */

messagetable:
	  id MESSAGETABLE memflags_move file_name
	  {
	    define_messagetable ($1, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* Rcdata resources.  */

rcdata:
	  id RCDATA suboptions BEG optrcdata_data END
	  {
	    define_rcdata ($1, &$3, $5.first);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* We use a different lexing algorithm, because rcdata strings may
   contain embedded null bytes, and we need to know the length to use.  */

optrcdata_data:
	  {
	    rcparse_rcdata ();
	  }
	  optrcdata_data_int
	  {
	    rcparse_normal ();
	    $$ = $2;
	  }
	;

optrcdata_data_int:
	  /* empty */
	  {
	    $$.first = NULL;
	    $$.last = NULL;
	  }
	| rcdata_data
	  {
	    $$ = $1;
	  }
	;

rcdata_data:
	  SIZEDSTRING
	  {
	    struct rcdata_item *ri;

	    ri = define_rcdata_string ($1.s, $1.length);
	    $$.first = ri;
	    $$.last = ri;
	  }
	| sizednumexpr
	  {
	    struct rcdata_item *ri;

	    ri = define_rcdata_number ($1.val, $1.dword);
	    $$.first = ri;
	    $$.last = ri;
	  }
	| rcdata_data ',' SIZEDSTRING
	  {
	    struct rcdata_item *ri;

	    ri = define_rcdata_string ($3.s, $3.length);
	    $$.first = $1.first;
	    $1.last->next = ri;
	    $$.last = ri;
	  }
	| rcdata_data ',' sizednumexpr
	  {
	    struct rcdata_item *ri;

	    ri = define_rcdata_number ($3.val, $3.dword);
	    $$.first = $1.first;
	    $1.last->next = ri;
	    $$.last = ri;
	  }
	;

/* Stringtable resources.  */

stringtable:
	  STRINGTABLE suboptions BEG 
	    { sub_res_info = $2; }
	    string_data END
	;

string_data:
	  /* empty */
	| string_data numexpr QUOTEDSTRING
	  {
	    define_stringtable (&sub_res_info, $2, $3);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	| string_data numexpr ',' QUOTEDSTRING
	  {
	    define_stringtable (&sub_res_info, $2, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* User defined resources.  We accept general suboptions in the
   file_name case to keep the parser happy.  */

user:
	  id id suboptions BEG optrcdata_data END
	  {
	    define_user_data ($1, $2, &$3, $5.first);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	| id id suboptions file_name
	  {
	    define_user_file ($1, $2, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* Versioninfo resources.  */

versioninfo:
	  id VERSIONINFO fixedverinfo BEG verblocks END
	  {
	    define_versioninfo ($1, language, $3, $5);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

fixedverinfo:
	  /* empty */
	  {
	    $$ = ((struct fixed_versioninfo *)
		  res_alloc (sizeof (struct fixed_versioninfo)));
	    memset ($$, 0, sizeof (struct fixed_versioninfo));
	  }
	| fixedverinfo FILEVERSION numexpr cnumexpr cnumexpr cnumexpr
	  {
	    $1->file_version_ms = ($3 << 16) | $4;
	    $1->file_version_ls = ($5 << 16) | $6;
	    $$ = $1;
	  }
	| fixedverinfo PRODUCTVERSION numexpr cnumexpr cnumexpr cnumexpr
	  {
	    $1->product_version_ms = ($3 << 16) | $4;
	    $1->product_version_ls = ($5 << 16) | $6;
	    $$ = $1;
	  }
	| fixedverinfo FILEFLAGSMASK numexpr
	  {
	    $1->file_flags_mask = $3;
	    $$ = $1;
	  }
	| fixedverinfo FILEFLAGS numexpr
	  {
	    $1->file_flags = $3;
	    $$ = $1;
	  }
	| fixedverinfo FILEOS numexpr
	  {
	    $1->file_os = $3;
	    $$ = $1;
	  }
	| fixedverinfo FILETYPE numexpr
	  {
	    $1->file_type = $3;
	    $$ = $1;
	  }
	| fixedverinfo FILESUBTYPE numexpr
	  {
	    $1->file_subtype = $3;
	    $$ = $1;
	  }
	;

/* To handle verblocks successfully, the lexer handles BLOCK
   specially.  A BLOCK "StringFileInfo" is returned as
   BLOCKSTRINGFILEINFO.  A BLOCK "VarFileInfo" is returned as
   BLOCKVARFILEINFO.  A BLOCK with some other string returns BLOCK
   with the string as the value.  */

verblocks:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| verblocks BLOCKSTRINGFILEINFO BEG BLOCK BEG vervals END END
	  {
	    $$ = append_ver_stringfileinfo ($1, $4, $6);
	  }
	| verblocks BLOCKVARFILEINFO BEG VALUE QUOTEDSTRING vertrans END
	  {
	    $$ = append_ver_varfileinfo ($1, $5, $6);
	  }
	;

vervals:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| vervals VALUE QUOTEDSTRING ',' QUOTEDSTRING
	  {
	    $$ = append_verval ($1, $3, $5);
	  }
	;

vertrans:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| vertrans cnumexpr cnumexpr
	  {
	    $$ = append_vertrans ($1, $2, $3);
	  }
	;

/* A resource ID.  */

id:
	  posnumexpr
	  {
	    $$.named = 0;
	    $$.u.id = $1;
	  }
	| STRING
	  {
	    char *copy, *s;

	    /* It seems that resource ID's are forced to upper case.  */
	    copy = xstrdup ($1);
	    for (s = copy; *s != '\0'; s++)
	      *s = TOUPPER (*s);
	    res_string_to_id (&$$, copy);
	    free (copy);
	  }
	;

/* A resource reference.  */

resname:
	  QUOTEDSTRING
	  {
	    $$ = $1;
	  }
	| QUOTEDSTRING ','
	  {
	    $$ = $1;
	  }
	| STRING ','
	  {
	    $$ = $1;
	  }
	;


resref:
	  posnumexpr ','
	  {
	    $$.named = 0;
	    $$.u.id = $1;
	  }
	| resname
	  {
	    char *copy, *s;

	    /* It seems that resource ID's are forced to upper case.  */
	    copy = xstrdup ($1);
	    for (s = copy; *s != '\0'; s++)
	      *s = TOUPPER (*s);
	    res_string_to_id (&$$, copy);
	    free (copy);
	  }
	;

/* Generic suboptions.  These may appear before the BEGIN in any
   multiline statement.  */

suboptions:
	  /* empty */
	  {
	    memset (&$$, 0, sizeof (struct res_res_info));
	    $$.language = language;
	    /* FIXME: Is this the right default?  */
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
	  }
	| suboptions memflag
	  {
	    $$ = $1;
	    $$.memflags |= $2.on;
	    $$.memflags &=~ $2.off;
	  }
	| suboptions CHARACTERISTICS numexpr
	  {
	    $$ = $1;
	    $$.characteristics = $3;
	  }
	| suboptions LANGUAGE numexpr cnumexpr
	  {
	    $$ = $1;
	    $$.language = $3 | ($4 << SUBLANG_SHIFT);
	  }
	| suboptions VERSIONK numexpr
	  {
	    $$ = $1;
	    $$.version = $3;
	  }
	;

/* Memory flags which default to MOVEABLE and DISCARDABLE.  */

memflags_move_discard:
	  /* empty */
	  {
	    memset (&$$, 0, sizeof (struct res_res_info));
	    $$.language = language;
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_DISCARDABLE;
	  }
	| memflags_move_discard memflag
	  {
	    $$ = $1;
	    $$.memflags |= $2.on;
	    $$.memflags &=~ $2.off;
	  }
	;

/* Memory flags which default to MOVEABLE.  */

memflags_move:
	  /* empty */
	  {
	    memset (&$$, 0, sizeof (struct res_res_info));
	    $$.language = language;
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
	  }
	| memflags_move memflag
	  {
	    $$ = $1;
	    $$.memflags |= $2.on;
	    $$.memflags &=~ $2.off;
	  }
	;

/* Memory flags.  This returns a struct with two integers, because we
   sometimes want to set bits and we sometimes want to clear them.  */

memflag:
	  MOVEABLE
	  {
	    $$.on = MEMFLAG_MOVEABLE;
	    $$.off = 0;
	  }
	| FIXED
	  {
	    $$.on = 0;
	    $$.off = MEMFLAG_MOVEABLE;
	  }
	| PURE
	  {
	    $$.on = MEMFLAG_PURE;
	    $$.off = 0;
	  }
	| IMPURE
	  {
	    $$.on = 0;
	    $$.off = MEMFLAG_PURE;
	  }
	| PRELOAD
	  {
	    $$.on = MEMFLAG_PRELOAD;
	    $$.off = 0;
	  }
	| LOADONCALL
	  {
	    $$.on = 0;
	    $$.off = MEMFLAG_PRELOAD;
	  }
	| DISCARDABLE
	  {
	    $$.on = MEMFLAG_DISCARDABLE;
	    $$.off = 0;
	  }
	;

/* A file name.  */

file_name:
	  QUOTEDSTRING
	  {
	    $$ = $1;
	  }
	| STRING
	  {
	    $$ = $1;
	  }
	;

/* A style expression.  This changes the static variable STYLE.  We do
   it this way because rc appears to permit a style to be set to
   something like
       WS_GROUP | NOT WS_TABSTOP
   to mean that a default of WS_TABSTOP should be removed.  Anything
   which wants to accept a style must first set STYLE to the default
   value.  The styleexpr nonterminal will change STYLE as specified by
   the user.  Note that we do not accept arbitrary expressions here,
   just numbers separated by '|'.  */

styleexpr:
	  parennumber
	  {
	    style |= $1;
	  }
	| NOT parennumber
	  {
	    style &=~ $2;
	  }
	| styleexpr '|' parennumber
	  {
	    style |= $3;
	  }
	| styleexpr '|' NOT parennumber
	  {
	    style &=~ $4;
	  }
	;

parennumber:
	  NUMBER
	  {
	    $$ = $1.val;
	  }
	| '(' numexpr ')'
	  {
	    $$ = $2;
	  }
	;

/* An optional expression with a leading comma.  */

optcnumexpr:
	  /* empty */
	  {
	    $$ = 0;
	  }
	| cnumexpr
	  {
	    $$ = $1;
	  }
	;

/* An expression with a leading comma.  */

cnumexpr:
	  ',' numexpr
	  {
	    $$ = $2;
	  }
	;

/* A possibly negated numeric expression.  */

numexpr:
	  sizednumexpr
	  {
	    $$ = $1.val;
	  }
	;

/* A possibly negated expression with a size.  */

sizednumexpr:
	  NUMBER
	  {
	    $$ = $1;
	  }
	| '(' sizednumexpr ')'
	  {
	    $$ = $2;
	  }
	| '~' sizednumexpr %prec '~'
	  {
	    $$.val = ~ $2.val;
	    $$.dword = $2.dword;
	  }
	| '-' sizednumexpr %prec NEG
	  {
	    $$.val = - $2.val;
	    $$.dword = $2.dword;
	  }
	| sizednumexpr '*' sizednumexpr
	  {
	    $$.val = $1.val * $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '/' sizednumexpr
	  {
	    $$.val = $1.val / $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '%' sizednumexpr
	  {
	    $$.val = $1.val % $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '+' sizednumexpr
	  {
	    $$.val = $1.val + $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '-' sizednumexpr
	  {
	    $$.val = $1.val - $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '&' sizednumexpr
	  {
	    $$.val = $1.val & $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '^' sizednumexpr
	  {
	    $$.val = $1.val ^ $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '|' sizednumexpr
	  {
	    $$.val = $1.val | $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	;

/* An expression with a leading comma which does not use unary
   negation.  */

cposnumexpr:
	  ',' posnumexpr
	  {
	    $$ = $2;
	  }
	;

/* An expression which does not use unary negation.  */

posnumexpr:
	  sizedposnumexpr
	  {
	    $$ = $1.val;
	  }
	;

/* An expression which does not use unary negation.  We separate unary
   negation to avoid parsing conflicts when two numeric expressions
   appear consecutively.  */

sizedposnumexpr:
	  NUMBER
	  {
	    $$ = $1;
	  }
	| '(' sizednumexpr ')'
	  {
	    $$ = $2;
	  }
	| '~' sizednumexpr %prec '~'
	  {
	    $$.val = ~ $2.val;
	    $$.dword = $2.dword;
	  }
	| sizedposnumexpr '*' sizednumexpr
	  {
	    $$.val = $1.val * $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '/' sizednumexpr
	  {
	    $$.val = $1.val / $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '%' sizednumexpr
	  {
	    $$.val = $1.val % $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '+' sizednumexpr
	  {
	    $$.val = $1.val + $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '-' sizednumexpr
	  {
	    $$.val = $1.val - $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '&' sizednumexpr
	  {
	    $$.val = $1.val & $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '^' sizednumexpr
	  {
	    $$.val = $1.val ^ $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '|' sizednumexpr
	  {
	    $$.val = $1.val | $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	;

%%

/* Set the language from the command line.  */

void
rcparse_set_language (lang)
     int lang;
{
  language = lang;
}
@


1.2
log
@looks as if some sour wine (Federweißer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d29 1
a29 2

#include <ctype.h>
d138 1
a138 1
%type <id> id resref
d142 1
a142 1
%type <s> optstringc file_name resname
d156 15
a170 22
	| input newcmd accelerator
	| input newcmd bitmap
	| input newcmd cursor
	| input newcmd dialog
	| input newcmd font
	| input newcmd icon
	| input newcmd language
	| input newcmd menu
	| input newcmd menuex
	| input newcmd messagetable
	| input newcmd rcdata
	| input newcmd stringtable
	| input newcmd user
	| input newcmd versioninfo
	| input newcmd IGNORED_TOKEN
	;

newcmd:
	  /* empty */
	  {
	    rcparse_discard_strings ();
	  }
d179 3
d222 1
a222 1
		&& ($$.flags & (ACC_SHIFT | ACC_CONTROL | ACC_ALT)) != 0)
d243 1
a243 1
		ch = toupper ((unsigned char) ch);
d308 3
d320 3
d345 1
d350 3
d372 1
d377 3
d400 1
d405 3
d426 2
a434 1
	    { style = dialog.style; }
d443 4
d450 1
d453 21
d478 1
d487 16
d515 1
a515 1
	    sub_res_info.language = $3 | ($4 << 8);
d576 1
a576 1
	      rcparse_warning (_("IEDIT requires DIALOGEX"));
d599 1
a599 1
	| CONTROL optstringc numexpr cnumexpr control_styleexpr cnumexpr
d610 1
a610 1
	| CONTROL optstringc numexpr cnumexpr control_styleexpr cnumexpr
d619 1
a619 1
	| CONTROL optstringc numexpr ',' QUOTEDSTRING control_styleexpr
d630 1
a630 1
  	    unicode_from_ascii(&$$->class.u.n.length, &$$->class.u.n.name, $5);
d632 1
a632 1
	| CONTROL optstringc numexpr ',' QUOTEDSTRING control_styleexpr
d641 1
a641 1
  	    unicode_from_ascii(&$$->class.u.n.length, &$$->class.u.n.name, $5);
d812 1
a812 1
	| USERBUTTON QUOTEDSTRING ',' numexpr ',' numexpr ',' numexpr ','
d817 2
a818 2
	    $$ = define_control ($2, $4, $6, $8, $10, $12, CTL_BUTTON,
				 style, $16);
d830 1
a830 1
	  optstringc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d842 1
a842 1
	| optstringc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d853 1
a853 1
	| optstringc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d864 1
a864 1
optstringc:
d867 6
a872 1
	    $$ = NULL;
d876 1
a876 1
	    $$ = $1;
d880 1
a880 1
	    $$ = $1;
d921 3
d933 3
d945 1
a945 1
	    language = $2 | ($3 << 8);
d955 3
d1045 3
d1114 3
d1126 3
d1208 3
d1215 3
d1228 3
d1235 3
d1247 3
d1357 1
a1357 2
	      if (islower ((unsigned char) *s))
		*s = toupper ((unsigned char) *s);
d1394 1
a1394 2
	      if (islower ((unsigned char) *s))
	        *s = toupper ((unsigned char) *s);
d1409 1
a1409 1
	    $$.memflags = MEMFLAG_MOVEABLE;
d1425 1
a1425 1
	    $$.language = $3 | ($4 << 8);
d1458 1
a1458 1
	    $$.memflags = MEMFLAG_MOVEABLE;
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d29 2
a30 1
#include "safe-ctype.h"
d139 1
a139 1
%type <id> id optresidc resref
d143 1
a143 1
%type <s> file_name resname
d157 22
a178 15
	| input accelerator
	| input bitmap
	| input cursor
	| input dialog
	| input font
	| input icon
	| input language
	| input menu
	| input menuex
	| input messagetable
	| input rcdata
	| input stringtable
	| input user
	| input versioninfo
	| input IGNORED_TOKEN
a186 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
d227 1
a227 1
		&& ($$.flags & (ACC_SHIFT | ACC_CONTROL)) != 0)
d248 1
a248 1
		ch = TOUPPER (ch);
a312 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a321 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a343 1
	      style = 0;
a347 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a366 1
	      style = 0;
a370 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a390 1
	      style = 0;
a394 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a412 2
	    dialog.style |= WS_CAPTION;
	    style |= WS_CAPTION;
d420 1
a428 4
	| styles CLASS QUOTEDSTRING
	  {
	    res_string_to_id (& dialog.class, $3);
	  }
a431 1
	    style |= DS_SETFONT;
a433 21
	    if (dialog.ex != NULL)
	      {
		dialog.ex->weight = 0;
		dialog.ex->italic = 0;
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = 0;
		dialog.ex->charset = 1;
	      }
a437 1
	    style |= DS_SETFONT;
a445 16
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr cnumexpr cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = $7;
		dialog.ex->charset = $8;
d458 1
a458 1
	    sub_res_info.language = $3 | ($4 << SUBLANG_SHIFT);
d519 1
a519 1
	      rcparse_warning (_("BEDIT requires DIALOGEX"));
d542 1
a542 1
	| CONTROL optresidc numexpr cnumexpr control_styleexpr cnumexpr
d553 1
a553 1
	| CONTROL optresidc numexpr cnumexpr control_styleexpr cnumexpr
d562 1
a562 1
	| CONTROL optresidc numexpr ',' QUOTEDSTRING control_styleexpr
d573 1
a573 1
  	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
d575 1
a575 1
	| CONTROL optresidc numexpr ',' QUOTEDSTRING control_styleexpr
d584 1
a584 1
  	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
d755 1
a755 1
	| USERBUTTON resref numexpr ',' numexpr ',' numexpr ','
d760 2
a761 2
	    $$ = define_control ($2, $3, $5, $7, $9, $11, CTL_BUTTON,
				 style, $15);
d773 1
a773 1
	  optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d785 1
a785 1
	| optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d796 1
a796 1
	| optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d807 1
a807 1
optresidc:
d810 1
a810 6
	    res_string_to_id (&$$, "");
	  }
	| posnumexpr ','
	  {
	    $$.named = 0;
	    $$.u.id = $1;
d814 1
a814 1
	    res_string_to_id (&$$, $1);
d818 1
a818 1
	    res_string_to_id (&$$, $1);
a858 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a867 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
d877 1
a877 1
	    language = $2 | ($3 << SUBLANG_SHIFT);
a886 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a973 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1039 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1048 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1127 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1131 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1141 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1145 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1154 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
d1262 2
a1263 1
	      *s = TOUPPER (*s);
d1300 2
a1301 1
	      *s = TOUPPER (*s);
d1316 1
a1316 1
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
d1332 1
a1332 1
	    $$.language = $3 | ($4 << SUBLANG_SHIFT);
d1365 1
a1365 1
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@a54 5
static struct res_id res_text_field;

/* This is used for COMBOBOX, LISTBOX and EDITTEXT which
   do not allow resource 'text' field in control definition. */
static const struct res_id res_null_text = { 1, {{0, L""}}};
d536 1
a536 1
	  AUTO3STATE optresidc
a540 1
	      res_text_field = $2;	
d544 1
a544 1
	    $$ = $4;
d546 1
a546 1
	| AUTOCHECKBOX optresidc
a550 1
	      res_text_field = $2;	
d554 1
a554 1
	    $$ = $4;
d556 1
a556 1
	| AUTORADIOBUTTON optresidc
a560 1
	      res_text_field = $2;	
d564 1
a564 1
	    $$ = $4;
d566 1
a566 1
	| BEDIT optresidc
a570 1
	      res_text_field = $2;	
d574 1
a574 1
	    $$ = $4;
d579 1
a579 1
	| CHECKBOX optresidc
a583 1
	      res_text_field = $2;	
d587 1
a587 1
	    $$ = $4;
a590 2
	      /* This is as per MSDN documentation.  With some (???)
		 versions of MS rc.exe their is no default style.  */
a593 1
	      res_text_field = res_null_text;	
d643 1
a643 1
	| CTEXT optresidc
a647 1
	      res_text_field = $2;	
d651 1
a651 1
	    $$ = $4;
d653 1
a653 1
	| DEFPUSHBUTTON optresidc
a657 1
	      res_text_field = $2;	
d661 1
a661 1
	    $$ = $4;
a667 1
	      res_text_field = res_null_text;	
d673 1
a673 1
	| GROUPBOX optresidc
a677 1
	      res_text_field = $2;	
d681 1
a681 1
	    $$ = $4;
d683 1
a683 1
	| HEDIT optresidc
a687 1
	      res_text_field = $2;	
d691 1
a691 1
	    $$ = $4;
d719 1
a719 1
	| IEDIT optresidc
a723 1
	      res_text_field = $2;	
d727 1
a727 1
	    $$ = $4;
a736 1
	      res_text_field = res_null_text;	
d742 1
a742 1
	| LTEXT optresidc
a746 1
	      res_text_field = $2;	
d750 1
a750 1
	    $$ = $4;
d752 1
a752 1
	| PUSHBOX optresidc
d760 1
a760 1
	    $$ = $4;
d762 1
a762 1
	| PUSHBUTTON optresidc
a766 1
	      res_text_field = $2;	
d770 1
a770 1
	    $$ = $4;
d772 1
a772 1
	| RADIOBUTTON optresidc
a776 1
	      res_text_field = $2;	
d780 1
a780 1
	    $$ = $4;
d782 1
a782 1
	| RTEXT optresidc
a786 1
	      res_text_field = $2;	
d790 1
a790 1
	    $$ = $4;
a796 1
	      res_text_field = res_null_text;	
d802 1
a802 1
	| STATE3 optresidc
a806 1
	      res_text_field = $2;	
d810 1
a810 1
	    $$ = $4;
d830 2
a831 1
	  numexpr cnumexpr cnumexpr cnumexpr cnumexpr opt_control_data
d833 1
a833 1
	    $$ = define_control (res_text_field, $1, $2, $3, $4, $5, class,
d835 1
a835 1
	    if ($6 != NULL)
d839 1
a839 1
		$$->data = $6;
d842 1
a842 1
	| numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d845 2
a846 2
	    $$ = define_control (res_text_field, $1, $2, $3, $4, $5, class, style, $7);
	    if ($8 != NULL)
d850 1
a850 1
		$$->data = $8;
d853 1
a853 1
	| numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d856 1
a856 1
	    $$ = define_control (res_text_field, $1, $2, $3, $4, $5, class, style, $7);
d859 2
a860 2
	    $$->help = $8;
	    $$->data = $9;
d1740 2
a1741 1
rcparse_set_language (int lang)
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d29 2
a30 1
#include "safe-ctype.h"
d139 1
a139 1
%type <id> id optresidc resref
d143 1
a143 1
%type <s> file_name resname
d157 22
a178 15
	| input accelerator
	| input bitmap
	| input cursor
	| input dialog
	| input font
	| input icon
	| input language
	| input menu
	| input menuex
	| input messagetable
	| input rcdata
	| input stringtable
	| input user
	| input versioninfo
	| input IGNORED_TOKEN
a186 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
d227 1
a227 1
		&& ($$.flags & (ACC_SHIFT | ACC_CONTROL)) != 0)
d248 1
a248 1
		ch = TOUPPER (ch);
a312 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a321 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a343 1
	      style = 0;
a347 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a366 1
	      style = 0;
a370 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a390 1
	      style = 0;
a394 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a412 2
	    dialog.style |= WS_CAPTION;
	    style |= WS_CAPTION;
d420 1
a428 4
	| styles CLASS QUOTEDSTRING
	  {
	    res_string_to_id (& dialog.class, $3);
	  }
a431 1
	    style |= DS_SETFONT;
a433 21
	    if (dialog.ex != NULL)
	      {
		dialog.ex->weight = 0;
		dialog.ex->italic = 0;
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = 0;
		dialog.ex->charset = 1;
	      }
a437 1
	    style |= DS_SETFONT;
a445 16
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr cnumexpr cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = $7;
		dialog.ex->charset = $8;
d458 1
a458 1
	    sub_res_info.language = $3 | ($4 << SUBLANG_SHIFT);
d519 1
a519 1
	      rcparse_warning (_("BEDIT requires DIALOGEX"));
d542 1
a542 1
	| CONTROL optresidc numexpr cnumexpr control_styleexpr cnumexpr
d553 1
a553 1
	| CONTROL optresidc numexpr cnumexpr control_styleexpr cnumexpr
d562 1
a562 1
	| CONTROL optresidc numexpr ',' QUOTEDSTRING control_styleexpr
d573 1
a573 1
  	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
d575 1
a575 1
	| CONTROL optresidc numexpr ',' QUOTEDSTRING control_styleexpr
d584 1
a584 1
  	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
d755 1
a755 1
	| USERBUTTON resref numexpr ',' numexpr ',' numexpr ','
d760 2
a761 2
	    $$ = define_control ($2, $3, $5, $7, $9, $11, CTL_BUTTON,
				 style, $15);
d773 1
a773 1
	  optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d785 1
a785 1
	| optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d796 1
a796 1
	| optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d807 1
a807 1
optresidc:
d810 1
a810 6
	    res_string_to_id (&$$, "");
	  }
	| posnumexpr ','
	  {
	    $$.named = 0;
	    $$.u.id = $1;
d814 1
a814 1
	    res_string_to_id (&$$, $1);
d818 1
a818 1
	    res_string_to_id (&$$, $1);
a858 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a867 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
d877 1
a877 1
	    language = $2 | ($3 << SUBLANG_SHIFT);
a886 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a973 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1039 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1048 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1127 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1131 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1141 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1145 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1154 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
d1262 2
a1263 1
	      *s = TOUPPER (*s);
d1300 2
a1301 1
	      *s = TOUPPER (*s);
d1316 1
a1316 1
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
d1332 1
a1332 1
	    $$.language = $3 | ($4 << SUBLANG_SHIFT);
d1365 1
a1365 1
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
@

