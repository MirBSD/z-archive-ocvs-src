head	1.2;
access;
symbols
	cvs-200406091940:1.1.1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2003.05.16.17.43.01;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.40.44;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.40.44;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.29.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove the FSF changelog files and other unused files; use cvsweb or anoncvs to retrieve them
@
text
@# Copyright (C) 1992, 1994, 1995 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@@cygnus.com)

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile "funcargs"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
execute_anywhere "rm -f ${binfile}.ci"
if  { [compile "-E ${srcdir}/${subdir}/compiler.c > ${binfile}.ci"] != "" } {
    perror "Couldn't make ${binfile}.ci file"
    return -1
}
source ${binfile}.ci

#
# Locate actual args; integral types.
#

proc integral_args {} {
    global prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call0a\n" ; expect -re ".*$prompt $"
    send "break call0b\n" ; expect -re ".*$prompt $"
    send "break call0c\n" ; expect -re ".*$prompt $"
    send "break call0d\n" ; expect -re ".*$prompt $"
    send "break call0e\n" ; expect -re ".*$prompt $"

    # Run; should stop at call0a and print actual arguments.
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    expect {
	-re ".* call0a \\(c=97 'a', s=1, i=2, l=3\\) .*$prompt $" {
	    pass "run to call0a"
	}
	-re "$prompt $"  { fail "run to call0a" ; return }
	timeout { fail "(timeout) run to call0a" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print c" ".* = 97 'a'" "print c after run to call0a" 
    gdb_test "print s" ".* = 1" "print s after run to call0a"
    gdb_test "print i" ".* = 2" "print i after run to call0a"
    gdb_test "print l " ".* = 3" "print l after run to call0a"

    # Continue; should stop at call0b and print actual arguments.
    if [gdb_test "cont" ".* call0b \\(s=1, i=2, l=3, c=97 'a'\\) .*" "continue to call0b"] {
	return 
    }

    # Continue; should stop at call0c and print actual arguments.
    if [gdb_test "cont" ".* call0c \\(i=2, l=3, c=97 'a', s=1\\) .*" "continue to call0c"] {
	return
    }

    # Continue; should stop at call0d and print actual arguments.
    if [gdb_test "cont" ".* call0d \\(l=3, c=97 'a', s=1, i=2\\) .*" "continue to call0d";] {
	return
    }

    # Continue; should stop at call0e and print actual arguments.
    if [gdb_test "cont" ".* call0e \\(c1=97 'a', l=3, c2=97 'a', i=2, c3=97 'a', s=1, c4=97 'a', c5=97 'a'\\) .*" "continue to call0e" ] {
	return
    }
}

#
# Locate actual args; unsigned integral types.
#

proc unsigned_integral_args {} {
    global prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call1a\n" ; expect -re ".*$prompt $"
    send "break call1b\n" ; expect -re ".*$prompt $"
    send "break call1c\n" ; expect -re ".*$prompt $"
    send "break call1d\n" ; expect -re ".*$prompt $"
    send "break call1e\n" ; expect -re ".*$prompt $"

    # Run; should stop at call1a and print actual arguments.
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    expect {
	-re ".* call1a \\(uc=98 'b', us=6, ui=7, ul=8\\) .*$prompt $" {
	    pass "run to call1a"
	}
	-re "$prompt $" { fail "run to call1a" ; return }
	timeout { fail "(timeout) run to call1a" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print uc" ".* = 98 'b'"
    gdb_test "print us" ".* = 6"
    gdb_test "print ui" ".* = 7"
    gdb_test "print ul" ".* = 8"
    
    # Continue; should stop at call1b and print actual arguments.
    if [gdb_test "cont" ".* call1b \\(us=6, ui=7, ul=8, uc=98 'b'\\) .*" "continue to call1b"] {
	return 
    }

    # Continue; should stop at call1c and print actual arguments.
    if [gdb_test "cont" ".* call1c \\(ui=7, ul=8, uc=98 'b', us=6\\) .*" "continue to call1c"] {
	return 
    }

    # Continue; should stop at call1d and print actual arguments.
    if [gdb_test "cont" ".* call1d \\(ul=8, uc=98 'b', us=6, ui=7\\) .*" "continue to call1d"] {
	return
    }

    # Continue; should stop at call1e and print actual arguments.
    if [gdb_test "cont" ".* call1e \\(uc1=98 'b', ul=8, uc2=98 'b', ui=7, uc3=98 'b', us=6, uc4=98 'b', uc5=98 'b'\\) .*" "continue to call1e"] {
	return
    }
}

#
# Locate actual args; integrals mixed with floating point.
#

proc float_and_integral_args {} {
    global prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call2a\n" ; expect -re ".*$prompt $"
    send "break call2b\n" ; expect -re ".*$prompt $"
    send "break call2c\n" ; expect -re ".*$prompt $"
    send "break call2d\n" ; expect -re ".*$prompt $"
    send "break call2e\n" ; expect -re ".*$prompt $"
    send "break call2f\n" ; expect -re ".*$prompt $"
    send "break call2g\n" ; expect -re ".*$prompt $"
    send "break call2h\n" ; expect -re ".*$prompt $"

    # Run; should stop at call2a and print actual arguments.

    setup_xfail "i960-*-*" 1813
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "mips-sgi-irix5*" }
    gdb_run_cmd
    expect {
	-re ".* call2a \\(c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$prompt $" { pass "run to call2a" }
	-re "$prompt $" { fail "run to call2a" ; return }
	timeout { fail "(timeout) run to call2a" ; return }
    }

    # Print each arg as a double check to see if we can print
    gdb_test "print c" ".* = 97 'a'" "print c after run to call2a"
    gdb_test "print f1" ".* = 4" "print f1 after run to call2a"
    gdb_test "print s" ".* = 1" "print s after run to call2a"
    gdb_test "print d1" ".* = 5" "print d1 after run to call2a"
    gdb_test "print i" ".* = 2" "print i after run to call2a"
    gdb_test "print f2" ".* = 4" "print f2 after run to call2a"
    gdb_test "print l" ".* = 3" "print l after run to call2a"
    gdb_test "print d2" ".* = 5" "print d2 after run to call2a"

    setup_xfail "rs6000-*-*"
    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix*" }
    # Continue; should stop at call2b and print actual arguments.
    if [gdb_test "cont" ".* call2b \\(f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a'\\) .*" "continue to call2b"] {
	return
    }

    # Continue; should stop at call2c and print actual arguments.
    if [gdb_test "cont" ".* call2c \\(s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4\\) .*" "continue to call2c"] {
	return
    }

    # Continue; should stop at call2d and print actual arguments.
    if [gdb_test "cont" ".* call2d \\(d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1\\) .*" "continue to call2d"] {
	return
    }

    # Continue; should stop at call2e and print actual arguments.
    if [gdb_test "cont" ".* call2e \\(i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5\\) .*" "continue to call2e"] {
	return
    }

    # Continue; should stop at call2f and print actual arguments.
    if [gdb_test "cont" ".* call2f \\(f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2\\) .*" "continue to call2f"] {
	return
    }

    # Continue; should stop at call2g and print actual arguments.
    if [gdb_test "cont" ".* call2g \\(l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4\\) .*" "continue to call2g"] {
	return
    }

    # Continue; should stop at call2h and print actual arguments.
    if [gdb_test "cont" ".* call2h \\(d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3\\) .*" "continue to call2h"] {
	return
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    send "break call2i\n" ; expect -re ".*$prompt $"

    # Continue; should stop at call2i and print actual arguments.
    if [gdb_test "cont" ".* call2i \\(c1=97 'a', f1=4, c2=97 'a', c3=97 'a', d1=5, c4=97 'a', c5=97 'a', c6=97 'a', f2=4, s=1, c7=97 'a', d2=5\\) .*" "continue to call2i"] {
	return
    }
}

#
# Locate actual args; dereference pointers to ints and floats.
#

proc pointer_args {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call3a\n" ; expect -re ".*$prompt $"
    send "break call3b\n" ; expect -re ".*$prompt $"
    send "break call3c\n" ; expect -re ".*$prompt $"

    # Run; should stop at call3a and print actual arguments.
    # Try dereferencing the arguments.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".* call3a \\(cp=$hex \"a\", sp=$hex, ip=$hex, lp=$hex\\) .*$prompt $" { pass "run to call3a" }
	-re "$prompt $" { fail "run to call3a" ; return }
	timeout { fail "(timeout) run to call3a" ; return }
    }

    gdb_test "print *cp" ".* = 97 'a'"
    gdb_test "print *sp" ".* = 1"
    gdb_test "print *ip" ".* = 2"
    gdb_test "print *lp" ".* = 3"

    # Continue; should stop at call3b and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3b \\(ucp=$hex \"b\", usp=$hex, uip=$hex, ulp=$hex\\) .*" "continue to call3b"] {
	return
    }

    gdb_test "print *ucp" ".* = 98 'b'"
    gdb_test "print *usp" ".* = 6"
    gdb_test "print *uip" ".* = 7"
    gdb_test "print *ulp" ".* = 8"

    # Continue; should stop at call3c and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3c \\(fp=$hex, dp=$hex\\) .*" "continue to call3c"] {
	return
    }

    gdb_test "print *fp" ".* = 4"
    gdb_test "print *dp" ".* = 5"

    pass "locate actual args, pointer types"
}

#
# Locate actual args; structures and unions passed by reference.
#

proc structs_by_reference {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call4a\n" ; expect -re ".*$prompt $"
    send "break call4b\n" ; expect -re ".*$prompt $"

    # Run; should stop at call4a and print actual arguments.
    # Try dereferencing the arguments.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".* call4a \\(stp=$hex\\) .*$prompt $" {
	    pass "run to call4a"
	}
	-re "$prompt $" { fail "run to call4a" ; return }
	timeout { fail "(timeout) run to call4a" ; return }
    }

    gdb_test "print *stp" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call4b and print actual arguments.
    # Try dereferencing the arguments.

    gdb_test "cont" ".* call4b \\(unp=$hex\\) .*" "continue to call4b"

    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}"

    pass "locate actual args, structs/unions passed by reference"
}

#
# Locate actual args; structures and unions passed by value.
#

proc structs_by_value {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call5a\n" ; expect -re ".*$prompt $"
    send "break call5b\n" ; expect -re ".*$prompt $"

    # Run; should stop at call5a and print actual arguments.
    # Try dereferencing the arguments.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".* call5a \\(st=\{s1 = 101, s2 = 102\}\\) .*$prompt $" {
	    pass "run to call5a"
	}
	-re "$prompt $" { fail "run to call5a" ; return }
	timeout { fail "(timeout) run to call5a" ; return }
    }

    gdb_test "print st" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call5b and print actual arguments.
    # Try dereferencing the arguments.
    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
	"continue to call5b"

    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}"
}

#
# Locate actual args; discard, shuffle, and call
#

proc discard_and_shuffle {} {
    global prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call6a\n" ; expect -re ".*$prompt $"
    send "break call6b\n" ; expect -re ".*$prompt $"
    send "break call6c\n" ; expect -re ".*$prompt $"
    send "break call6d\n" ; expect -re ".*$prompt $"
    send "break call6e\n" ; expect -re ".*$prompt $"
    send "break call6f\n" ; expect -re ".*$prompt $"
    send "break call6g\n" ; expect -re ".*$prompt $"
    send "break call6h\n" ; expect -re ".*$prompt $"

    # Run; should stop at call6a and print actual arguments.
    # Print backtrace.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".*Breakpoint $decimal, call6a .*$prompt $" { pass "run to call6a" }
	-re "$prompt $" { fail "run to call6a" ; return }
	timeout { fail "(timeout) run to call6a" ; return }
    }

    setup_xfail "rs6000-*-*"
    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix5*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6a" }
	-re "$prompt $" { fail "backtrace from call6a" ; return }
	timeout { fail "(timeout) backtrace from call6a" ; return }
    }

    # Continue; should stop at call6b and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6b .*$prompt $" { pass "continue to call6b" }
	-re "$prompt $" { fail "continue to call6b" ; return }
	timeout { fail "(timeout) continue to call6b" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n]+
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6b" }
	-re "$prompt $" { fail "backtrace from call6b" ; return }
	timeout { fail "(timeout) backtrace from call6b" ; return }
    }

    # Continue; should stop at call6c and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6c .*$prompt $" { pass "continue to call6c" }
	-re "$prompt $" { fail "continue to call6c" ; return }
	timeout { fail "(timeout) continue to call6c" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6c" }
	-re "$prompt $" { fail "backtrace from call6c" ; return }
	timeout { fail "(timeout) backtrace from call6c" ; return }
    }

    # Continue; should stop at call6d and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6d .*$prompt $" { pass "continue to call6d" }
	-re "$prompt $" { fail "continue to call6d" ; return }
	timeout { fail "(timeout) continue to call6d" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6d" }
	-re "$prompt $" { fail "backtrace from call6d" ; return }
	timeout { fail "(timeout) backtrace from call6d" ; return }
    }

    # Continue; should stop at call6e and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6e .*$prompt $" { pass "continue to call6e" }
	-re "$prompt $" { fail "continue to call6e" ; return }
	timeout { fail "(timeout) continue to call6e" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6e" }
	-re "$prompt $" { fail "backtrace from call6e" ; return }
	timeout { fail "(timeout) backtrace from call6e" ; return }
    }

    # Continue; should stop at call6f and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6f .*$prompt $" { pass "continue to call6f" }
	-re "$prompt $" { fail "continue to call6f" ; return }
	timeout { fail "(timeout) continue to call6f" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6f" }
	-re "$prompt $" { fail "backtrace from call6f" ; return }
	timeout { fail "(timeout) backtrace from call6f" ; return }
    }

    # Continue; should stop at call6g and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6g .*$prompt $" { pass "continue to call6g" }
	-re "$prompt $" { fail "continue to call6g" ; return }
	timeout { fail "(timeout) continue to call6g" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6g" }
	-re "$prompt $" { fail "backtrace from call6g" ; return }
	timeout { fail "(timeout) backtrace from call6g" ; return }
    }

    # Continue; should stop at call6h and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6h .*$prompt $" { pass "continue to call6h" }
	-re "$prompt $" { fail "continue to call6h" ; return }
	timeout { fail "(timeout) continue to call6h" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6h" }
	-re "$prompt $" { fail "backtrace from call6h" ; return }
	timeout { fail "(timeout) backtrace from call6h" ; return }
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    send "break call6i\n" ; expect -re ".*$prompt $"
    send "break call6j\n" ; expect -re ".*$prompt $"
    send "break call6k\n" ; expect -re ".*$prompt $"

    # Continue; should stop at call6i and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6i .*$prompt $" { pass "continue to call6i" }
	-re "$prompt $" { fail "continue to call6i" ; return }
	timeout { fail "(timeout) continue to call6i" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6i" }
	-re "$prompt $" { fail "backtrace from call6i" ; return }
	timeout { fail "(timeout) backtrace from call6i" ; return }
    }

    # Continue; should stop at call6j and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6j .*$prompt $" { pass "continue to call6j" }
	-re "$prompt $" { fail "continue to call6j" ; return }
	timeout { fail "(timeout) continue to call6j" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6j \\(ul=8\\) .*\r
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6j" }
	-re "$prompt $" { fail "backtrace from call6j" ; return }
	timeout { fail "(timeout) backtrace from call6j" ; return }
    }

    # Continue; should stop at call6k and print actual arguments.
    # Print backtrace.
    # This fails on i960-*-vxworks because gdb gets confused by
    # breakpoints on adjacent instructions.
    setup_xfail "i960-*-vxworks" 1786
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6k .*$prompt $" {
	    pass "continue to call6k"
	}
	-re "$prompt $" { fail "continue to call6k"; return }
	timeout { fail "(timeout) continue to call6k"; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6k \\(\\) .*\r
.* call6j \\(ul=8\\) .*\r
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6k" }
	-re "$prompt $" { fail "backtrace from call6k" ; return }
	timeout { fail "(timeout) backtrace from call6k" ; return }
    }
}

#
# Locate actual args; shuffle round robin and call
#

proc shuffle_round_robin {} {
    global prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call7a\n" ; expect -re ".*$prompt $"
    send "break call7b\n" ; expect -re ".*$prompt $"
    send "break call7c\n" ; expect -re ".*$prompt $"
    send "break call7d\n" ; expect -re ".*$prompt $"
    send "break call7e\n" ; expect -re ".*$prompt $"
    send "break call7f\n" ; expect -re ".*$prompt $"
    send "break call7g\n" ; expect -re ".*$prompt $"
    send "break call7h\n" ; expect -re ".*$prompt $"

    # Run; should stop at call7a and print actual arguments.
    # Print backtrace.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".*Breakpoint $decimal, call7a .*$prompt $" {
	    pass "run to call7a"
	}
	-re "$prompt $" { fail "run to call7a" ; return }
	timeout { fail "(timeout) run to call7a" ; return }
    }

    setup_xfail "i960-*-*" 1813
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "mips-sgi-irix5*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7a" }
	-re "$prompt $" { fail "backtrace from call7a" ; return }
	timeout { fail "(timeout) backtrace from call7a" ; return }
    }

    # Continue; should stop at call7b and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7b .*$prompt $" { pass "continue to call7b" }
	-re "$prompt $" { fail "continue to call7b" ; return }
	timeout { fail "(timeout) continue to call7b" ; return }
    }

    if {$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7b" }
	-re "$prompt $" { fail "backtrace from call7b" ; return }
	timeout { fail "(timeout) backtrace from call7b" ; return }
    }

    # Continue; should stop at call7c and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7c .*$prompt $" { pass "continue to call7c" }
	-re "$prompt $" { fail "continue to call7c" ; return }
	timeout { fail "(timeout) continue to call7c" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7c" }
	-re "$prompt $" { fail "backtrace from call7c" ; return }
	timeout { fail "(timeout) backtrace from call7c" ; return }
    }

    # Continue; should stop at call7d and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7d .*$prompt $" { pass "continue to call7d" }
	-re "$prompt $" { fail "continue to call7d" ; return }
	timeout { fail "(timeout) continue to call7d" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7d" }
	-re "$prompt $" { fail "backtrace from call7d" ; return }
	timeout { fail "(timeout) backtrace from call7d" ; return }
    }

    # Continue; should stop at call7e and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re "Breakpoint $decimal, call7e .*$prompt $" { pass "continue to call7e" }
	-re "$prompt $" { fail "continue to call7e" ; return }
	timeout { fail "(timeout) continue to call7e" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7e" }
	-re "$prompt $" { fail "backtrace from call7e" ; return }
	timeout { fail "(timeout) backtrace from call7e" ; return }
    }

    # Continue; should stop at call7f and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7f .*$prompt $" { pass "continue to call7f" }
	-re "$prompt $" { fail "continue to call7f" ; return }
	timeout { fail "(timeout) continue to call7f" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7f" }
	-re "$prompt $" { fail "backtrace from call7f" ; return }
	timeout { fail "(timeout) backtrace from call7f" ; return }
    }

    # Continue; should stop at call7g and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7g .*$prompt $" { pass "continue to call7g" }
	-re "$prompt $" { fail "continue to call7g" ; return }
	timeout { fail "(timeout) continue to call7g" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7g" }
	-re "$prompt $" { fail "backtrace from call7g" ; return }
	timeout { fail "(timeout) backtrace from call7g" ; return }
    }

    # Continue; should stop at call7h and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7h .*$prompt $" { pass "continue to call7h" }
	-re "$prompt $" { fail "continue to call7h" ; return }
	timeout { fail "(timeout) continue to call7h" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7h" }
	-re "$prompt $" { fail "backtrace from call7h" ; return }
	timeout { fail "(timeout) backtrace from call7h" ; return }
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    send "break call7i\n" ; expect -re ".*$prompt $"
    send "break call7j\n" ; expect -re ".*$prompt $"
    send "break call7k\n" ; expect -re ".*$prompt $"

    # Continue; should stop at call7i and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7i .*$prompt $" { pass "continue to call7i" }
	-re "$prompt $" { fail "continue to call7i" ; return }
	timeout { fail "(timeout) continue to call7i" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7i" }
	-re "$prompt $" { fail "backtrace from call7i" ; return }
	timeout { fail "(timeout) backtrace from call7i" ; return }
    }

    # Continue; should stop at call7j and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7j .*$prompt $" { pass "continue to call7j" }
	-re "$prompt $" { fail "continue to call7j" ; return }
	timeout { fail "(timeout) continue to call7j" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) .*\r
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7j" }
	-re "$prompt $" { fail "backtrace from call7j" ; return }
	timeout { fail "(timeout) backtrace from call7j" ; return }
    }

    # Continue; should stop at call7k and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7k .*$prompt $" { pass "continue to call7k" }
	-re "$prompt $" { fail "continue to call7k" ; return }
	timeout { fail "(timeout) continue to call7k" ; return }
    }

    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7k \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) .*\r
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7k" }
	-re "$prompt $" { fail "backtrace from call7k" ; return }
	timeout { fail "(timeout) backtrace from call7k" ; return }
    }
}

#
# Locate actual args; recursive passing of structs by value
#

proc recursive_structs_by_value {} {
    global prompt
    global hex
    global decimal
    global det_file

    delete_breakpoints

    send "break hitbottom\n" ; expect -re ".*$prompt $"

    # Run; should stop at hitbottom and print actual arguments.
    # Print backtrace.
    gdb_run_cmd
    expect {
	-re ".*Breakpoint $decimal, hitbottom .*$prompt $" { pass "run to hitbottom" }
	-re "$prompt $" { fail "run to hitbottom" ; return }
	timeout { fail "(timeout) run to hitbottom" ; return }
    }

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* hitbottom \\(\\) .*\r
.* recurse \\(a=\{s = 0, i = 0, l = 0\}, depth=0\\) .*\r
.* recurse \\(a=\{s = 1, i = 1, l = 1\}, depth=1\\) .*\r
.* recurse \\(a=\{s = 2, i = 2, l = 2\}, depth=2\\) .*\r
.* recurse \\(a=\{s = 3, i = 3, l = 3\}, depth=3\\) .*\r
.* recurse \\(a=\{s = 4, i = 4, l = 4\}, depth=4\\) .*\r
.* test_struct_args \\(\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "recursive passing of structs by value" }
	-re "$prompt $" { fail "recursive passing of structs by value" ; return }
	timeout { fail "(timeout) recursive passing of structs by value" ; return }
    }
}

proc funcargs_reload { } {
    global objdir
    global subdir
    global binfile
    global srcdir

    if [istarget "mips-idt-*"] then {
	# Restart because IDT/SIM runs out of file descriptors.
	gdb_exit
	gdb_start
	gdb_reinitialize_dir $srcdir/$subdir
	gdb_load ${binfile}
    }
}

#
# Test for accessing local stack variables in functions which call alloca
#
proc localvars_after_alloca { } {
    global prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto localvars_after_alloca ] } then { return 0 }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c after runto localvars_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s after runto localvars_after_alloca"
    gdb_test "print i" " = 2" "print i after runto localvars_after_alloca"
    gdb_test "print l" " = 3" "print l after runto localvars_after_alloca"

    send "next\n"
    expect {
	-re ".*$prompt $" { pass "next in localvars_after_alloca()" }
	timeout { fail "(timeout) next in localvars_after_alloca()" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    gdb_test "print c" " = 97 'a'" "print c in localvars_after_alloca"
    gdb_test "print s" " = 1" "print s in localvars_after_alloca"
    gdb_test "print i" " = 2" "print i in localvars_after_alloca"
    gdb_test "print l" " = 3" "print l in localvars_after_alloca"

    gdb_test "backtrace 8" "#0.*localvars_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" "backtrace after alloca"
}

proc call_after_alloca { } {
    global prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto call_after_alloca_subr ] } then { return 0 }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in call_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in call_after_alloca"
    gdb_test "print i" " = 2" "print i in call_after_alloca"
    gdb_test "print l" " = 3" "print l in call_after_alloca"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" "#0.*call_after_alloca_subr \\(c=97 'a', s=1, i=2, l=3, uc=98 'b', us=11, ui=12, ul=13\\).*#1.*call_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#2.*main.*" "backtrace from call_after_alloca_subr"
}

#
# Test for accessing local stack variables, backtraces, finish,
# and finally stepping into indirect calls.  The point is that on the PA
# these use a funky `dyncall' mechanism which GDB needs to know about.
#
proc localvars_in_indirect_call { } {
    global prompt
    global hex
    global decimal
    global gcc_compiled

    # Can not use "runto call0a" as call0a is called several times
    # during single run.  Instead stop in a marker function and
    # take control from there.
    if { ! [ runto marker_indirect_call ] } then { return 0 }

    # break on the next call to call0a, then delete all the breakpoints
    # and start testing.
    gdb_test "break call0a" "Breakpoint .*" \
	"break call0a in localvars_in_indirect_call"
    gdb_test "continue" "call0a .*" "continue in localvars_in_indirect_call"
    delete_breakpoints
    
    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in localvars_in_indirect_call"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in localvars_in_indirect_call"
    gdb_test "print i" " = 2" "print i in localvars_in_indirect_call"
    gdb_test "print l" " = 3" "print l in localvars_in_indirect_call"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" \
	"#0.*call0a \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" \
	"backtrace in indirectly called function"

    # 
    # "finish" brings us back to main.  We then will try to step through
    # the second indirect call.  
    # On some targets (e.g. m68k) gdb will stop from the finish in midline
    # of the first indirect call. This is due to stack adjustment instructions
    # after the indirect call. In these cases we will step till we hit the
    # second indirect call.
    #

    send "finish\n"
    expect {
	-re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*First.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*Second.*$prompt $" {
	    pass "finish from indirectly called function"
	}
	-re ".*$prompt $" {
	    fail "finish from indirectly called function"
	    return
	}
	default { fail "finish from indirectly called function" ; return }
    }

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "step" "call0a \\(c=97 'a', s=1, i=2, l=3\\).*" \
	"stepping into indirectly called function"
}

# Start with a fresh gdb.
#
# Test for stepping into indirect calls which may have trampolines (possibly
# cascaded) on both the call path and the return path.
# to handle trampolines.
#
proc test_stepping_over_trampolines { } {
    global prompt
    global hex
    global decimal

    # Stop in a marker function and take control from there.
    if { ! [ runto marker_call_with_trampolines ] } then { return 0 }

    # Cater for gdb stopping in midline, see comment for finish above.
    send "finish\n"
    expect {
	-re "marker_call_with_trampolines ..;.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re "pointer_to_call_with_trampolines.*$prompt $" {
	    pass "finish from marker_call_with_trampolines"
	}
	-re ".*$prompt $" {
	    fail "finish from marker_call_with_trampolines"
	}
	default { fail "finish from marker_call_with_trampolines" ; return 0 }
    }

    # Try to step into the target function.
    gdb_test "step" "call_with_trampolines \\(d1=5\\).*" \
	"stepping into function called with trampolines"

    # Make we can backtrace and the argument looks correct.  */
    gdb_test "backtrace 8" "#0.*call_with_trampolines \\(d1=5\\).*1.*main.*" \
	"backtrace through call with trampolines"

    # Make sure we can get back to main.
    # Stepping back to main might stop again after the return statement
    # or immediately transfer control back to main if optimizations
    # are performed.
    send "step\n"
    expect {
	-re "main .* at.*$prompt $" {
	    pass "stepping back to main from function called with trampolines" ;
	    return 1
	}
	-re "\}.*End of call_with_trampolines.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re ".*$prompt $" {
	    fail "stepping back to main from function called with trampolines"
	}
	default { fail "stepping back to main from function called with trampolines" ; return 0 }
    }
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

integral_args
funcargs_reload
unsigned_integral_args
funcargs_reload
float_and_integral_args
funcargs_reload
pointer_args
funcargs_reload
structs_by_reference
funcargs_reload
structs_by_value
funcargs_reload
discard_and_shuffle
funcargs_reload
shuffle_round_robin
funcargs_reload
recursive_structs_by_value
funcargs_reload
localvars_after_alloca
funcargs_reload
call_after_alloca
funcargs_reload
localvars_in_indirect_call
funcargs_reload
test_stepping_over_trampolines
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d1 1
a1 2
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003,
# 2004 Free Software Foundation, Inc.
d15 1
a15 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
d22 2
a23 2
if $tracelevel {
    strace $tracelevel
d32 3
a34 2
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
d39 4
a42 2
if [get_compiler_info ${binfile}] {
    return -1;
d44 1
d51 1
a51 1
    global gdb_prompt
d57 5
a61 5
    gdb_breakpoint call0a
    gdb_breakpoint call0b
    gdb_breakpoint call0c
    gdb_breakpoint call0d
    gdb_breakpoint call0e
d64 3
d69 2
a70 2
    gdb_expect {
	 -re ".* call0a \\(c=97 'a', s=1, i=2, l=3\\) .*$gdb_prompt $" {
d73 2
a74 2
	 -re "$gdb_prompt $"  { fail "run to call0a" ; gdb_suppress_tests }
	 timeout { fail "(timeout) run to call0a" ; gdb_suppress_tests }
d86 1
a86 1
	gdb_suppress_tests;
d91 1
a91 1
	gdb_suppress_tests;
d96 1
a96 1
	gdb_suppress_tests;
d101 1
a101 1
	gdb_suppress_tests;
a102 1
    gdb_stop_suppressing_tests;
d110 1
a110 1
    global gdb_prompt
d116 5
a120 5
    gdb_breakpoint call1a;
    gdb_breakpoint call1b;
    gdb_breakpoint call1c;
    gdb_breakpoint call1d;
    gdb_breakpoint call1e;
d123 3
d128 2
a129 2
    gdb_expect {
	 -re ".* call1a \\(uc=98 'b', us=6, ui=7, ul=8\\) .*$gdb_prompt $" {
d132 2
a133 2
	 -re "$gdb_prompt $" { fail "run to call1a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call1a" ; gdb_suppress_tests; }
d145 1
a145 1
	gdb_suppress_tests; 
d150 1
a150 1
	gdb_suppress_tests; 
d155 1
a155 1
	gdb_suppress_tests;
d160 1
a160 1
	gdb_suppress_tests;
a161 1
    gdb_stop_suppressing_tests;
d169 1
a169 1
    global gdb_prompt
d175 8
a182 8
    gdb_breakpoint call2a
    gdb_breakpoint call2b
    gdb_breakpoint call2c
    gdb_breakpoint call2d
    gdb_breakpoint call2e
    gdb_breakpoint call2f
    gdb_breakpoint call2g
    gdb_breakpoint call2h
d186 4
d192 4
a195 5
    gdb_expect {
	 -re ".* call2a \\(c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$gdb_prompt $" { pass "run to call2a" }
	 -re ".* call2a \\(c=97 'a', f1=.*, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$gdb_prompt $" { xfail "run to call2a" }
	 -re "$gdb_prompt $" { fail "run to call2a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call2a" ; gdb_suppress_tests; }
d212 1
a212 1
	gdb_suppress_tests;
d217 1
a217 1
	gdb_suppress_tests;
d222 1
a222 1
	gdb_suppress_tests;
d227 1
a227 1
	gdb_suppress_tests;
d232 1
a232 1
	gdb_suppress_tests;
d237 1
a237 1
	gdb_suppress_tests;
d242 1
a242 1
	gdb_suppress_tests;
d248 1
a248 1
    gdb_breakpoint call2i
d252 1
a252 1
	gdb_suppress_tests;
a253 1
    gdb_stop_suppressing_tests;
d261 1
a261 1
    global gdb_prompt
d267 3
a269 3
    gdb_breakpoint call3a
    gdb_breakpoint call3b
    gdb_breakpoint call3c
d274 3
d278 4
a281 4
    gdb_expect {
	 -re ".* call3a \\(cp=$hex \"a.*\", sp=$hex, ip=$hex, lp=$hex\\) .*$gdb_prompt $" { pass "run to call3a" }
	 -re "$gdb_prompt $" { fail "run to call3a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call3a" ; gdb_suppress_tests; }
d291 2
a292 2
    if [gdb_test "cont" ".* call3b \\(ucp=$hex \"b.*\", usp=$hex, uip=$hex, ulp=$hex\\) .*" "continue to call3b"] {
	gdb_suppress_tests;
d303 1
a303 1
	gdb_suppress_tests;
d309 1
a309 2
#    pass "locate actual args, pointer types"
    gdb_stop_suppressing_tests;
d317 1
a317 1
    global gdb_prompt
a319 3
    global target_sizeof_int
    global target_sizeof_long
    global target_bigendian_p
d323 2
a324 2
    gdb_breakpoint call4a
    gdb_breakpoint call4b
d329 3
d333 2
a334 2
    gdb_expect {
	 -re ".* call4a \\(stp=$hex\\) .*$gdb_prompt $" {
d337 2
a338 2
	 -re "$gdb_prompt $" { fail "run to call4a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call4a" ; gdb_suppress_tests; }
d344 1
d348 3
a350 16
    # Try dereferencing the arguments.
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}" \
		"print *unp (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}" \
		"print *unp (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 4294967296\}" \
		"print *unp (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 65536\}" \
		"print *unp (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "print *unp (unknown case)"
    }
a352 1
    gdb_stop_suppressing_tests;
d360 1
a360 1
    global gdb_prompt
a362 3
    global target_sizeof_int
    global target_sizeof_long
    global target_bigendian_p
d366 2
a367 2
    gdb_breakpoint call5a
    gdb_breakpoint call5b
d372 3
d376 2
a377 2
    gdb_expect {
	 -re ".* call5a \\(st=\{s1 = 101, s2 = 102\}\\) .*$gdb_prompt $" {
d380 2
a381 2
	 -re "$gdb_prompt $" { fail "run to call5a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call5a" ; gdb_suppress_tests; }
a386 16
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
		"continue to call5b (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
		"continue to call5b (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 8589934592\}\\) .*" \
		"continue to call5b (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 131072\}\\) .*" \
		"continue to call5b (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "continue to call5b (unknown case)"
    }

d388 8
a395 17
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}" \
		"print un (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}" \
		"print un (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 8589934592\}" \
		"print un (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 131072\}" \
		"print un (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "print un (unknown case)"
    }

    gdb_stop_suppressing_tests;
d403 1
a403 1
    global gdb_prompt
d411 8
a418 8
    gdb_breakpoint call6a
    gdb_breakpoint call6b
    gdb_breakpoint call6c
    gdb_breakpoint call6d
    gdb_breakpoint call6e
    gdb_breakpoint call6f
    gdb_breakpoint call6g
    gdb_breakpoint call6h
d423 3
d427 4
a430 4
    gdb_expect {
	 -re ".*Breakpoint $decimal, call6a .*$gdb_prompt $" { pass "run to call6a" }
	 -re "$gdb_prompt $" { fail "run to call6a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call6a" ; gdb_suppress_tests; }
d434 3
a436 7

    if {!$gcc_compiled} {
	setup_xfail "mips-sgi-irix5*"
    }

    send_gdb "backtrace 100\n"
    gdb_expect {
d440 3
a442 17
$gdb_prompt $" {
	    pass "backtrace from call6a"
	}
	-re "backtrace 100\[\r\n\]+
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=.*, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$gdb_prompt $" {
	    xfail "backtrace from call6a"
	}
	-re "$gdb_prompt $" {
	    fail "backtrace from call6a"
	    gdb_suppress_tests
	}
	timeout {
	    fail "(timeout) backtrace from call6a"
	    gdb_suppress_tests
	}
d448 6
a453 1
    gdb_continue call6b
d455 9
a463 7
    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6b" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* main \\(.*\\) " 
    } ] {
	gdb_suppress_tests;
d469 6
a474 1
    gdb_continue call6c
d476 10
a485 8
    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6c" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
d487 1
d491 6
a496 1
    gdb_continue call6d
d498 11
a508 9
    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6d" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
d514 6
a519 1
    gdb_continue call6e
d521 12
a532 10
    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6e" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
d538 6
a543 1
    gdb_continue call6f
d545 13
a557 11
    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6f" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
d563 6
a568 1
    gdb_continue call6g
d570 14
a583 12
    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6g" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
d589 6
a594 1
    gdb_continue call6h
d596 15
a610 13
    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6h" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
d616 3
a618 3
    gdb_breakpoint call6i
    gdb_breakpoint call6j
    gdb_breakpoint call6k
d623 6
a628 1
    gdb_continue call6i
d630 16
a645 14
    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6i" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6i \\(ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#9 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
d651 6
a656 1
    gdb_continue call6j
d658 17
a674 15
    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6j" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6j \\(ul=8\\) "
	".*\[\r\n\]#1 .* call6i \\(ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#9 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#10 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
d679 11
a689 1
    gdb_continue call6k
d691 18
a708 16
    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6k" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6k \\(\\) "
	".*\[\r\n\]#1 .* call6j \\(ul=8\\) "
	".*\[\r\n\]#2 .* call6i \\(ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#9 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#10 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#11 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
a709 1
    gdb_stop_suppressing_tests;
a711 1

d717 1
a717 1
    global gdb_prompt
d725 8
a732 8
    gdb_breakpoint call7a
    gdb_breakpoint call7b
    gdb_breakpoint call7c
    gdb_breakpoint call7d
    gdb_breakpoint call7e
    gdb_breakpoint call7f
    gdb_breakpoint call7g
    gdb_breakpoint call7h
d737 3
d741 2
a742 2
    gdb_expect {
	 -re ".*Breakpoint $decimal, call7a .*$gdb_prompt $" {
d745 2
a746 2
	 -re "$gdb_prompt $" { fail "run to call7a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call7a" ; gdb_suppress_tests; }
d749 1
d751 2
a752 2
    send_gdb "backtrace 100\n"
    gdb_expect {
d756 2
a757 10
$gdb_prompt $" {
	    pass "backtrace from call7a"
	}
	-re "backtrace 100\[\r\n\]+
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=.*, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$gdb_prompt $" {
	    xfail "backtrace from call7a"
	}
	-re "$gdb_prompt $" { fail "backtrace from call7a" ; return }
d764 6
a769 1
    gdb_continue call7b
d772 9
a780 6

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7b" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#1 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#2 .* main \\(.*\\) "
d786 6
a791 1
    gdb_continue call7c
d793 10
a802 6
    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7c" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#1 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#2 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#3 .* main \\(.*\\) "
d808 6
a813 1
    gdb_continue call7d
d815 35
a849 19
    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7d" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#1 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#2 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#3 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#4 .* main \\(.*\\) "
    }

    gdb_continue call7e

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7e" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#1 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#2 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#3 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#4 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#5 .* main \\(.*\\) "
d855 6
a860 1
    gdb_continue call7f
d862 13
a874 9
    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7f" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#1 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#2 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#3 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#4 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#5 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#6 .* main \\(.*\\) "
d880 6
a885 1
    gdb_continue call7g
d887 41
a927 25
    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7g" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#1 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#2 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#3 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#4 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#5 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#6 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#7 .* main \\(.*\\) "
    }

    gdb_continue call7h

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7h" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#1 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#2 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#3 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#4 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#5 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#6 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#7 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#8 .* main \\(.*\\) "
d933 3
a935 3
    gdb_breakpoint call7i
    gdb_breakpoint call7j
    gdb_breakpoint call7k
d940 6
a945 1
    gdb_continue call7i
d947 16
a962 12
    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7i" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	".*\[\r\n\]#1 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#2 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#3 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#4 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#5 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#6 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#7 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#8 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#9 .* main \\(.*\\) "
d968 6
a973 1
    gdb_continue call7j
d975 17
a991 13
    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7j" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) "
	".*\[\r\n\]#1 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	".*\[\r\n\]#2 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#3 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#4 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#5 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#6 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#7 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#8 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#9 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#10 .* main \\(.*\\) "
d997 6
a1002 1
    gdb_continue call7k
d1005 18
a1022 14
    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7k" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7k \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#1 .* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) "
	".*\[\r\n\]#2 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	".*\[\r\n\]#3 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#4 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#5 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#6 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#7 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#8 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#9 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#10 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#11 .* main \\(.*\\) "
a1023 1
    gdb_stop_suppressing_tests;
d1031 1
a1031 1
    global gdb_prompt
d1038 1
a1038 1
    gdb_breakpoint hitbottom
d1043 23
a1065 20
    gdb_expect {
	 -re ".*Breakpoint $decimal, hitbottom .*$gdb_prompt $" { pass "run to hitbottom" }
	 -re "$gdb_prompt $" { fail "run to hitbottom" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to hitbottom" ; gdb_suppress_tests; }
    }

    if ![istarget sparclet-*-*] {
	send_gdb "backtrace 100\n"
	gdb_expect_list "recursive passing of structs by value" ".*$gdb_prompt $" {
	    ".*\[\r\n\]#0 .* hitbottom \\(\\) "
	    ".*\[\r\n\]#1 .* recurse \\(a=\{s = 0, i = 0, l = 0\}, depth=0\\) "
	    ".*\[\r\n\]#2 .* recurse \\(a=\{s = 1, i = 1, l = 1\}, depth=1\\) "
	    ".*\[\r\n\]#3 .* recurse \\(a=\{s = 2, i = 2, l = 2\}, depth=2\\) "
	    ".*\[\r\n\]#4 .* recurse \\(a=\{s = 3, i = 3, l = 3\}, depth=3\\) "
	    ".*\[\r\n\]#5 .* recurse \\(a=\{s = 4, i = 4, l = 4\}, depth=4\\) "
	    ".*\[\r\n\]#6 .* test_struct_args \\(\\) "
	    ".*\[\r\n\]#7 .* main \\(.*\\) "
	}
    } else {
	fail "recursive passing of structs by value (sparclet)"
a1066 1
    gdb_stop_suppressing_tests;
d1075 1
a1075 1
    if [istarget "mips-idt-*"] {
d1088 1
a1088 1
    global gdb_prompt
d1093 1
a1093 1
    if { ! [ runto localvars_after_alloca ] } then { gdb_suppress_tests; }
d1105 5
a1109 2
    # Lame regexp.
    gdb_test "next" ".*" "next in localvars_after_alloca()"
a1119 1
    gdb_stop_suppressing_tests;
d1123 1
a1123 1
    global gdb_prompt
d1128 1
a1128 1
    if { ! [ runto call_after_alloca_subr ] } then { gdb_suppress_tests; }
a1141 1
    gdb_stop_suppressing_tests;
d1150 1
a1150 1
    global gdb_prompt
d1158 1
a1158 1
    if { ! [ runto marker_indirect_call ] } then { gdb_suppress_tests; }
d1162 3
a1164 2
    gdb_breakpoint call0a
    gdb_continue call0a
d1191 4
a1194 6
    send_gdb "finish\n"
    gdb_expect {
	 -re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*First.*$gdb_prompt $" {
#On hppa2.0w-hp-hpux11.00, gdb finishes at one line earlier than 
#hppa1.1-hp-hpux11.00. Therefore, an extra "step" is necessary to continue the test.
	    send_gdb "step\n"
d1197 1
a1197 1
	 -re ".*\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*Second.*$gdb_prompt $" {
d1200 1
a1200 1
	 -re ".*$gdb_prompt $" {
d1202 1
a1202 1
	    gdb_suppress_tests;
d1204 1
a1204 1
	 default { fail "finish from indirectly called function" ; gdb_suppress_tests; }
a1209 1
    gdb_stop_suppressing_tests;
d1212 1
d1215 1
a1215 1
# cascaded) on both the call path and the gdb_suppress_tests; path.
d1219 1
a1219 1
    global gdb_prompt
d1224 1
a1224 1
    if { ! [ runto marker_call_with_trampolines ] } then { gdb_suppress_tests; }
d1227 4
a1230 4
    send_gdb "finish\n"
    gdb_expect {
	 -re "marker_call_with_trampolines ..;.*$gdb_prompt $" {
	    send_gdb "step\n"
d1233 1
a1233 1
	 -re "pointer_to_call_with_trampolines.*$gdb_prompt $" {
d1236 1
a1236 1
	 -re ".*$gdb_prompt $" {
d1239 1
a1239 1
	 default { fail "finish from marker_call_with_trampolines" ; gdb_suppress_tests; }
d1251 1
a1251 1
    # Stepping back to main might stop again after the gdb_suppress_tests; statement
d1254 5
a1258 5
    send_gdb "step\n"
    gdb_expect {
	 -re "main .* at.*$gdb_prompt $" {
	     pass "stepping back to main from function called with trampolines" ;
	     gdb_suppress_tests
d1260 2
a1261 2
	 -re "\}.*End of call_with_trampolines.*$gdb_prompt $" {
	    send_gdb "step\n"
d1264 1
a1264 1
	 -re ".*$gdb_prompt $" {
d1267 1
a1267 1
	 default { fail "stepping back to main from function called with trampolines" ; gdb_suppress_tests; }
a1268 1
    gdb_stop_suppressing_tests;
a1277 45
if [istarget "mips*tx39-*"] {
    set timeout 300
} else {
    set timeout 60
}

# Determine expected output for unsigned long variables,
# the output varies with sizeof (unsigned long).

set target_sizeof_long 4
send_gdb "print sizeof (long)\n"
gdb_expect {
    -re ".\[0-9\]* = 4.*$gdb_prompt $" { }
    -re ".\[0-9\]* = 8.*$gdb_prompt $" { set target_sizeof_long 8 } 
    -re ".*$gdb_prompt $" {
	 fail "getting sizeof long"
    }
    default	{ fail "(timeout) getting sizeof long" }
}

set target_sizeof_int 4
send_gdb "print sizeof (int)\n"
gdb_expect {
    -re ".\[0-9\]* = 2.*$gdb_prompt $" { set target_sizeof_int 2 }
    -re ".\[0-9\]* = 4.*$gdb_prompt $" { }
    -re ".\[0-9\]* = 8.*$gdb_prompt $" { set target_sizeof_int 8 } 
    -re ".*$gdb_prompt $" {
	 fail "getting sizeof unsigned long"
    }
    default	{ fail "(timeout) getting sizeof int" }
}

set target_bigendian_p 1
send_gdb "show endian\n"
gdb_expect {
    -re ".*little endian.*$gdb_prompt $" { set target_bigendian_p 0 }
    -re ".*big endian.*$gdb_prompt $" { }
    -re ".*$gdb_prompt $" {
	 fail "getting target endian"
    }
    default	{ fail "(timeout) getting target endian" }
}

# Perform tests

d1282 1
a1282 3
if {![target_info exists gdb,skip_float_tests]} {
  float_and_integral_args
}
@

