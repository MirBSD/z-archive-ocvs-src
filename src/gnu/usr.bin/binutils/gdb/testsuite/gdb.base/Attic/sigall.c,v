head	1.2;
access;
symbols
	cvs-200406091940:1.1.1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.17.43.06;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.40.48;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.40.48;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.29.49;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove the FSF changelog files and other unused files; use cvsweb or anoncvs to retrieve them
@
text
@#include <signal.h>

#ifdef __sh__
#define signal(a,b)	/* Signals not supported on this target - make them go away */
#endif

/* Signal handlers, we set breakpoints in them to make sure that the
   signals really get delivered.  */

void
handle_ABRT (sig)
     int sig;
{
}

void
handle_HUP (sig)
     int sig;
{
}

void
handle_QUIT (sig)
     int sig;
{
}

void
handle_ILL (sig)
     int sig;
{
}

void
handle_EMT (sig)
     int sig;
{
}

void
handle_FPE (sig)
     int sig;
{
}

void
handle_BUS (sig)
     int sig;
{
}

void
handle_SEGV (sig)
     int sig;
{
}

void
handle_SYS (sig)
     int sig;
{
}

void
handle_PIPE (sig)
     int sig;
{
}

void
handle_ALRM (sig)
     int sig;
{
}

void
handle_URG (sig)
     int sig;
{
}

void
handle_TSTP (sig)
     int sig;
{
}

void
handle_CONT (sig)
     int sig;
{
}

void
handle_CHLD (sig)
     int sig;
{
}

void
handle_TTIN (sig)
     int sig;
{
}

void
handle_TTOU (sig)
     int sig;
{
}

void
handle_IO (sig)
     int sig;
{
}

void
handle_XCPU (sig)
     int sig;
{
}

void
handle_XFSZ (sig)
     int sig;
{
}

void
handle_VTALRM (sig)
     int sig;
{
}

void
handle_PROF (sig)
     int sig;
{
}

void
handle_WINCH (sig)
     int sig;
{
}

void
handle_LOST (sig)
     int sig;
{
}

void
handle_USR1 (sig)
     int sig;
{
}

void
handle_USR2 (sig)
     int sig;
{
}

void
handle_PWR (sig)
     int sig;
{
}

void
handle_POLL (sig)
     int sig;
{
}

void
handle_WIND (sig)
     int sig;
{
}

void
handle_PHONE (sig)
     int sig;
{
}

void
handle_WAITING (sig)
     int sig;
{
}

void
handle_LWP (sig)
     int sig;
{
}

void
handle_DANGER (sig)
     int sig;
{
}

void
handle_GRANT (sig)
     int sig;
{
}

void
handle_RETRACT (sig)
     int sig;
{
}

void
handle_MSG (sig)
     int sig;
{
}

void
handle_SOUND (sig)
     int sig;
{
}

void
handle_SAK (sig)
     int sig;
{
}

void
handle_PRIO (sig)
     int sig;
{
}

void
handle_33 (sig)
     int sig;
{
}

void
handle_34 (sig)
     int sig;
{
}

void
handle_35 (sig)
     int sig;
{
}

void
handle_36 (sig)
     int sig;
{
}

void
handle_37 (sig)
     int sig;
{
}

void
handle_38 (sig)
     int sig;
{
}

void
handle_39 (sig)
     int sig;
{
}

void
handle_40 (sig)
     int sig;
{
}

void
handle_41 (sig)
     int sig;
{
}

void
handle_42 (sig)
     int sig;
{
}

void
handle_43 (sig)
     int sig;
{
}

void
handle_44 (sig)
     int sig;
{
}

void
handle_45 (sig)
     int sig;
{
}

void
handle_46 (sig)
     int sig;
{
}

void
handle_47 (sig)
     int sig;
{
}

void
handle_48 (sig)
     int sig;
{
}

void
handle_49 (sig)
     int sig;
{
}

void
handle_50 (sig)
     int sig;
{
}

void
handle_51 (sig)
     int sig;
{
}

void
handle_52 (sig)
     int sig;
{
}

void
handle_53 (sig)
     int sig;
{
}

void
handle_54 (sig)
     int sig;
{
}

void
handle_55 (sig)
     int sig;
{
}

void
handle_56 (sig)
     int sig;
{
}

void
handle_57 (sig)
     int sig;
{
}

void
handle_58 (sig)
     int sig;
{
}

void
handle_59 (sig)
     int sig;
{
}

void
handle_60 (sig)
     int sig;
{
}

void
handle_61 (sig)
     int sig;
{
}

void
handle_62 (sig)
     int sig;
{
}

void
handle_63 (sig)
     int sig;
{
}

void
handle_TERM (sig)
     int sig;
{
}

/* Functions to send signals.  These also serve as markers.  */
int
gen_ABRT ()
{
  kill (getpid (), SIGABRT);
}  

int
gen_HUP ()
{
#ifdef SIGHUP
  kill (getpid (), SIGHUP);
#else
  handle_HUP (0);
#endif
}  

int
gen_QUIT ()
{
#ifdef SIGQUIT
  kill (getpid (), SIGQUIT);
#else
  handle_QUIT (0);
#endif
}

int
gen_ILL ()
{
#ifdef SIGILL
  kill (getpid (), SIGILL);
#else
  handle_ILL (0);
#endif
}

int
gen_EMT ()
{
#ifdef SIGEMT
  kill (getpid (), SIGEMT);
#else
  handle_EMT (0);
#endif
}

int x;

int
gen_FPE ()
{
  /* The intent behind generating SIGFPE this way is to check the mapping
     from the CPU exception itself to the signals.  It would be nice to
     do the same for SIGBUS, SIGSEGV, etc., but I suspect that even this
     test might turn out to be insufficiently portable.  */

#if 0
  /* Loses on the PA because after the signal handler executes we try to
     re-execute the failing instruction again.  Perhaps we could siglongjmp
     out of the signal handler?  */
  /* The expect script looks for the word "kill"; don't delete it.  */
  return 5 / x; /* and we both started jumping up and down yelling kill */
#else
  kill (getpid (), SIGFPE);
#endif
}

int
gen_BUS ()
{
#ifdef SIGBUS
  kill (getpid (), SIGBUS);
#else
  handle_BUS (0);
#endif
}

int
gen_SEGV ()
{
#ifdef SIGSEGV
  kill (getpid (), SIGSEGV);
#else
  handle_SEGV (0);
#endif
}

int
gen_SYS ()
{
#ifdef SIGSYS
  kill (getpid (), SIGSYS);
#else
  handle_SYS (0);
#endif
}

int
gen_PIPE ()
{
#ifdef SIGPIPE
  kill (getpid (), SIGPIPE);
#else
  handle_PIPE (0);
#endif
}

int
gen_ALRM ()
{
#ifdef SIGALRM
  kill (getpid (), SIGALRM);
#else
  handle_ALRM (0);
#endif
}

int
gen_URG ()
{
#ifdef SIGURG
  kill (getpid (), SIGURG);
#else
  handle_URG (0);
#endif
}

int
gen_TSTP ()
{
#ifdef SIGTSTP
  kill (getpid (), SIGTSTP);
#else
  handle_TSTP (0);
#endif
}

int
gen_CONT ()
{
#ifdef SIGCONT
  kill (getpid (), SIGCONT);
#else
  handle_CONT (0);
#endif
}

int
gen_CHLD ()
{
#ifdef SIGCHLD
  kill (getpid (), SIGCHLD);
#else
  handle_CHLD (0);
#endif
}

int
gen_TTIN ()
{
#ifdef SIGTTIN
  kill (getpid (), SIGTTIN);
#else
  handle_TTIN (0);
#endif
}

int
gen_TTOU ()
{
#ifdef SIGTTOU
  kill (getpid (), SIGTTOU);
#else
  handle_TTOU (0);
#endif
}

int
gen_IO ()
{
#ifdef SIGIO
  kill (getpid (), SIGIO);
#else
  handle_IO (0);
#endif
}

int
gen_XCPU ()
{
#ifdef SIGXCPU
  kill (getpid (), SIGXCPU);
#else
  handle_XCPU (0);
#endif
}

int
gen_XFSZ ()
{
#ifdef SIGXFSZ
  kill (getpid (), SIGXFSZ);
#else
  handle_XFSZ (0);
#endif
}

int
gen_VTALRM ()
{
#ifdef SIGVTALRM
  kill (getpid (), SIGVTALRM);
#else
  handle_VTALRM (0);
#endif
}

int
gen_PROF ()
{
#ifdef SIGPROF
  kill (getpid (), SIGPROF);
#else
  handle_PROF (0);
#endif
}

int
gen_WINCH ()
{
#ifdef SIGWINCH
  kill (getpid (), SIGWINCH);
#else
  handle_WINCH (0);
#endif
}

int
gen_LOST ()
{
#if defined(SIGLOST) && (!defined(SIGABRT) || SIGLOST != SIGABRT)
  kill (getpid (), SIGLOST);
#else
  handle_LOST (0);
#endif
}

int
gen_USR1 ()
{
#ifdef SIGUSR1
  kill (getpid (), SIGUSR1);
#else
  handle_USR1 (0);
#endif
}

int
gen_USR2 ()
{
#ifdef SIGUSR2
  kill (getpid (), SIGUSR2);
#else
  handle_USR2 (0);
#endif
}  

int
gen_PWR ()
{
#ifdef SIGPWR
  kill (getpid (), SIGPWR);
#else
  handle_PWR (0);
#endif
}

int
gen_POLL ()
{
#if defined (SIGPOLL) && (!defined (SIGIO) || SIGPOLL != SIGIO)
  kill (getpid (), SIGPOLL);
#else
  handle_POLL (0);
#endif
}

int
gen_WIND ()
{
#ifdef SIGWIND
  kill (getpid (), SIGWIND);
#else
  handle_WIND (0);
#endif
}

int
gen_PHONE ()
{
#ifdef SIGPHONE
  kill (getpid (), SIGPHONE);
#else
  handle_PHONE (0);
#endif
}

int
gen_WAITING ()
{
#ifdef SIGWAITING
  kill (getpid (), SIGWAITING);
#else
  handle_WAITING (0);
#endif
}

int
gen_LWP ()
{
#ifdef SIGLWP
  kill (getpid (), SIGLWP);
#else
  handle_LWP (0);
#endif
}

int
gen_DANGER ()
{
#ifdef SIGDANGER
  kill (getpid (), SIGDANGER);
#else
  handle_DANGER (0);
#endif
}

int
gen_GRANT ()
{
#ifdef SIGGRANT
  kill (getpid (), SIGGRANT);
#else
  handle_GRANT (0);
#endif
}

int
gen_RETRACT ()
{
#ifdef SIGRETRACT
  kill (getpid (), SIGRETRACT);
#else
  handle_RETRACT (0);
#endif
}

int
gen_MSG ()
{
#ifdef SIGMSG
  kill (getpid (), SIGMSG);
#else
  handle_MSG (0);
#endif
}

int
gen_SOUND ()
{
#ifdef SIGSOUND
  kill (getpid (), SIGSOUND);
#else
  handle_SOUND (0);
#endif
}

int
gen_SAK ()
{
#ifdef SIGSAK
  kill (getpid (), SIGSAK);
#else
  handle_SAK (0);
#endif
}

int
gen_PRIO ()
{
#ifdef SIGPRIO
  kill (getpid (), SIGPRIO);
#else
  handle_PRIO (0);
#endif
}

int
gen_33 ()
{
#ifdef SIG33
  kill (getpid (), 33);
#else
  handle_33 (0);
#endif
}

int
gen_34 ()
{
#ifdef SIG34
  kill (getpid (), 34);
#else
  handle_34 (0);
#endif
}

int
gen_35 ()
{
#ifdef SIG35
  kill (getpid (), 35);
#else
  handle_35 (0);
#endif
}

int
gen_36 ()
{
#ifdef SIG36
  kill (getpid (), 36);
#else
  handle_36 (0);
#endif
}

int
gen_37 ()
{
#ifdef SIG37
  kill (getpid (), 37);
#else
  handle_37 (0);
#endif
}

int
gen_38 ()
{
#ifdef SIG38
  kill (getpid (), 38);
#else
  handle_38 (0);
#endif
}

int
gen_39 ()
{
#ifdef SIG39
  kill (getpid (), 39);
#else
  handle_39 (0);
#endif
}

int
gen_40 ()
{
#ifdef SIG40
  kill (getpid (), 40);
#else
  handle_40 (0);
#endif
}

int
gen_41 ()
{
#ifdef SIG41
  kill (getpid (), 41);
#else
  handle_41 (0);
#endif
}

int
gen_42 ()
{
#ifdef SIG42
  kill (getpid (), 42);
#else
  handle_42 (0);
#endif
}

int
gen_43 ()
{
#ifdef SIG43
  kill (getpid (), 43);
#else
  handle_43 (0);
#endif
}

int
gen_44 ()
{
#ifdef SIG44
  kill (getpid (), 44);
#else
  handle_44 (0);
#endif
}

int
gen_45 ()
{
#ifdef SIG45
  kill (getpid (), 45);
#else
  handle_45 (0);
#endif
}

int
gen_46 ()
{
#ifdef SIG46
  kill (getpid (), 46);
#else
  handle_46 (0);
#endif
}

int
gen_47 ()
{
#ifdef SIG47
  kill (getpid (), 47);
#else
  handle_47 (0);
#endif
}

int
gen_48 ()
{
#ifdef SIG48
  kill (getpid (), 48);
#else
  handle_48 (0);
#endif
}

int
gen_49 ()
{
#ifdef SIG49
  kill (getpid (), 49);
#else
  handle_49 (0);
#endif
}

int
gen_50 ()
{
#ifdef SIG50
  kill (getpid (), 50);
#else
  handle_50 (0);
#endif
}

int
gen_51 ()
{
#ifdef SIG51
  kill (getpid (), 51);
#else
  handle_51 (0);
#endif
}

int
gen_52 ()
{
#ifdef SIG52
  kill (getpid (), 52);
#else
  handle_52 (0);
#endif
}

int
gen_53 ()
{
#ifdef SIG53
  kill (getpid (), 53);
#else
  handle_53 (0);
#endif
}

int
gen_54 ()
{
#ifdef SIG54
  kill (getpid (), 54);
#else
  handle_54 (0);
#endif
}

int
gen_55 ()
{
#ifdef SIG55
  kill (getpid (), 55);
#else
  handle_55 (0);
#endif
}

int
gen_56 ()
{
#ifdef SIG56
  kill (getpid (), 56);
#else
  handle_56 (0);
#endif
}

int
gen_57 ()
{
#ifdef SIG57
  kill (getpid (), 57);
#else
  handle_57 (0);
#endif
}

int
gen_58 ()
{
#ifdef SIG58
  kill (getpid (), 58);
#else
  handle_58 (0);
#endif
}

int
gen_59 ()
{
#ifdef SIG59
  kill (getpid (), 59);
#else
  handle_59 (0);
#endif
}

int
gen_60 ()
{
#ifdef SIG60
  kill (getpid (), 60);
#else
  handle_60 (0);
#endif
}

int
gen_61 ()
{
#ifdef SIG61
  kill (getpid (), 61);
#else
  handle_61 (0);
#endif
}

int
gen_62 ()
{
#ifdef SIG62
  kill (getpid (), 62);
#else
  handle_62 (0);
#endif
}

int
gen_63 ()
{
#ifdef SIG63
  kill (getpid (), 63);
#else
  handle_63 (0);
#endif
}

int
gen_TERM ()
{
  kill (getpid (), SIGTERM);
}  

int
main ()
{
  signal (SIGABRT, handle_ABRT);
#ifdef SIGHUP
  signal (SIGHUP, handle_HUP);
#endif
#ifdef SIGQUIT
  signal (SIGQUIT, handle_QUIT);
#endif
#ifdef SIGILL
  signal (SIGILL, handle_ILL);
#endif
#ifdef SIGEMT
  signal (SIGEMT, handle_EMT);
#endif
#ifdef SIGFPE
  signal (SIGFPE, handle_FPE);
#endif
#ifdef SIGBUS
  signal (SIGBUS, handle_BUS);
#endif
#ifdef SIGSEGV
  signal (SIGSEGV, handle_SEGV);
#endif
#ifdef SIGSYS
  signal (SIGSYS, handle_SYS);
#endif
#ifdef SIGPIPE
  signal (SIGPIPE, handle_PIPE);
#endif
#ifdef SIGALRM
  signal (SIGALRM, handle_ALRM);
#endif
#ifdef SIGURG
  signal (SIGURG, handle_URG);
#endif
#ifdef SIGTSTP
  signal (SIGTSTP, handle_TSTP);
#endif
#ifdef SIGCONT
  signal (SIGCONT, handle_CONT);
#endif
#ifdef SIGCHLD
  signal (SIGCHLD, handle_CHLD);
#endif
#ifdef SIGTTIN
  signal (SIGTTIN, handle_TTIN);
#endif
#ifdef SIGTTOU
  signal (SIGTTOU, handle_TTOU);
#endif
#ifdef SIGIO
  signal (SIGIO, handle_IO);
#endif
#ifdef SIGXCPU
  signal (SIGXCPU, handle_XCPU);
#endif
#ifdef SIGXFSZ
  signal (SIGXFSZ, handle_XFSZ);
#endif
#ifdef SIGVTALRM
  signal (SIGVTALRM, handle_VTALRM);
#endif
#ifdef SIGPROF
  signal (SIGPROF, handle_PROF);
#endif
#ifdef SIGWINCH
  signal (SIGWINCH, handle_WINCH);
#endif
#if defined(SIGLOST) && (!defined(SIGABRT) || SIGLOST != SIGABRT)
  signal (SIGLOST, handle_LOST);
#endif
#ifdef SIGUSR1
  signal (SIGUSR1, handle_USR1);
#endif
#ifdef SIGUSR2
  signal (SIGUSR2, handle_USR2);
#endif
#ifdef SIGPWR
  signal (SIGPWR, handle_PWR);
#endif
#if defined (SIGPOLL) && (!defined (SIGIO) || SIGPOLL != SIGIO)
  signal (SIGPOLL, handle_POLL);
#endif
#ifdef SIGWIND
  signal (SIGWIND, handle_WIND);
#endif
#ifdef SIGPHONE
  signal (SIGPHONE, handle_PHONE);
#endif
#ifdef SIGWAITING
  signal (SIGWAITING, handle_WAITING);
#endif
#ifdef SIGLWP
  signal (SIGLWP, handle_LWP);
#endif
#ifdef SIGDANGER
  signal (SIGDANGER, handle_DANGER);
#endif
#ifdef SIGGRANT
  signal (SIGGRANT, handle_GRANT);
#endif
#ifdef SIGRETRACT
  signal (SIGRETRACT, handle_RETRACT);
#endif
#ifdef SIGMSG
  signal (SIGMSG, handle_MSG);
#endif
#ifdef SIGSOUND
  signal (SIGSOUND, handle_SOUND);
#endif
#ifdef SIGSAK
  signal (SIGSAK, handle_SAK);
#endif
#ifdef SIGPRIO
  signal (SIGPRIO, handle_PRIO);
#endif
#ifdef __Lynx__
  /* Lynx doesn't seem to have anything in signal.h for this.  */
  signal (33, handle_33);
  signal (34, handle_34);
  signal (35, handle_35);
  signal (36, handle_36);
  signal (37, handle_37);
  signal (38, handle_38);
  signal (39, handle_39);
  signal (40, handle_40);
  signal (41, handle_41);
  signal (42, handle_42);
  signal (43, handle_43);
  signal (44, handle_44);
  signal (45, handle_45);
  signal (46, handle_46);
  signal (47, handle_47);
  signal (48, handle_48);
  signal (49, handle_49);
  signal (50, handle_50);
  signal (51, handle_51);
  signal (52, handle_52);
  signal (53, handle_53);
  signal (54, handle_54);
  signal (55, handle_55);
  signal (56, handle_56);
  signal (57, handle_57);
  signal (58, handle_58);
  signal (59, handle_59);
  signal (60, handle_60);
  signal (61, handle_61);
  signal (62, handle_62);
  signal (63, handle_63);
#endif /* lynx */
  signal (SIGTERM, handle_TERM);

  x = 0;

  gen_ABRT ();
  gen_HUP ();
  gen_QUIT ();
  gen_ILL ();
  gen_EMT ();
  gen_FPE ();
  gen_BUS ();
  gen_SEGV ();
  gen_SYS ();
  gen_PIPE ();
  gen_ALRM ();
  gen_URG ();
  gen_TSTP ();
  gen_CONT ();
  gen_CHLD ();
  gen_TTIN ();
  gen_TTOU ();
  gen_IO ();
  gen_XCPU ();
  gen_XFSZ ();
  gen_VTALRM ();
  gen_PROF ();
  gen_WINCH ();
  gen_LOST ();
  gen_USR1 ();
  gen_USR2 ();
  gen_PWR ();
  gen_POLL ();
  gen_WIND ();
  gen_PHONE ();
  gen_WAITING ();
  gen_LWP ();
  gen_DANGER ();
  gen_GRANT ();
  gen_RETRACT ();
  gen_MSG ();
  gen_SOUND ();
  gen_SAK ();
  gen_PRIO ();
  gen_33 ();
  gen_34 ();
  gen_35 ();
  gen_36 ();
  gen_37 ();
  gen_38 ();
  gen_39 ();
  gen_40 ();
  gen_41 ();
  gen_42 ();
  gen_43 ();
  gen_44 ();
  gen_45 ();
  gen_46 ();
  gen_47 ();
  gen_48 ();
  gen_49 ();
  gen_50 ();
  gen_51 ();
  gen_52 ();
  gen_53 ();
  gen_54 ();
  gen_55 ();
  gen_56 ();
  gen_57 ();
  gen_58 ();
  gen_59 ();
  gen_60 ();
  gen_61 ();
  gen_62 ();
  gen_63 ();
  gen_TERM ();

  return 0;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@a1 1
#include <unistd.h>
a9 4
#ifdef PROTOTYPES
void
handle_ABRT (int sig)
#else
a12 1
#endif
a15 4
#ifdef PROTOTYPES
void
handle_HUP (int sig)
#else
a18 1
#endif
a21 4
#ifdef PROTOTYPES
void
handle_QUIT (int sig)
#else
a24 1
#endif
a27 4
#ifdef PROTOTYPES
void
handle_ILL (int sig)
#else
a30 1
#endif
a33 4
#ifdef PROTOTYPES
void
handle_EMT (int sig)
#else
a36 1
#endif
a39 4
#ifdef PROTOTYPES
void
handle_FPE (int sig)
#else
a42 1
#endif
a45 4
#ifdef PROTOTYPES
void
handle_BUS (int sig)
#else
a48 1
#endif
a51 4
#ifdef PROTOTYPES
void
handle_SEGV (int sig)
#else
a54 1
#endif
a57 4
#ifdef PROTOTYPES
void
handle_SYS (int sig)
#else
a60 1
#endif
a63 4
#ifdef PROTOTYPES
void
handle_PIPE (int sig)
#else
a66 1
#endif
a69 4
#ifdef PROTOTYPES
void
handle_ALRM (int sig)
#else
a72 1
#endif
a75 4
#ifdef PROTOTYPES
void
handle_URG (int sig)
#else
a78 1
#endif
a81 4
#ifdef PROTOTYPES
void
handle_TSTP (int sig)
#else
a84 1
#endif
a87 4
#ifdef PROTOTYPES
void
handle_CONT (int sig)
#else
a90 1
#endif
a93 4
#ifdef PROTOTYPES
void
handle_CHLD (int sig)
#else
a96 1
#endif
a99 4
#ifdef PROTOTYPES
void
handle_TTIN (int sig)
#else
a102 1
#endif
a105 4
#ifdef PROTOTYPES
void
handle_TTOU (int sig)
#else
a108 1
#endif
a111 4
#ifdef PROTOTYPES
void
handle_IO (int sig)
#else
a114 1
#endif
a117 4
#ifdef PROTOTYPES
void
handle_XCPU (int sig)
#else
a120 1
#endif
a123 4
#ifdef PROTOTYPES
void
handle_XFSZ (int sig)
#else
a126 1
#endif
a129 4
#ifdef PROTOTYPES
void
handle_VTALRM (int sig)
#else
a132 1
#endif
a135 4
#ifdef PROTOTYPES
void
handle_PROF (int sig)
#else
a138 1
#endif
a141 4
#ifdef PROTOTYPES
void
handle_WINCH (int sig)
#else
a144 1
#endif
a147 4
#ifdef PROTOTYPES
void
handle_LOST (int sig)
#else
a150 1
#endif
a153 4
#ifdef PROTOTYPES
void
handle_USR1 (int sig)
#else
a156 1
#endif
a159 4
#ifdef PROTOTYPES
void
handle_USR2 (int sig)
#else
a162 1
#endif
a165 4
#ifdef PROTOTYPES
void
handle_PWR (int sig)
#else
a168 1
#endif
a171 4
#ifdef PROTOTYPES
void
handle_POLL (int sig)
#else
a174 1
#endif
a177 4
#ifdef PROTOTYPES
void
handle_WIND (int sig)
#else
a180 1
#endif
a183 4
#ifdef PROTOTYPES
void
handle_PHONE (int sig)
#else
a186 1
#endif
a189 4
#ifdef PROTOTYPES
void
handle_WAITING (int sig)
#else
a192 1
#endif
a195 4
#ifdef PROTOTYPES
void
handle_LWP (int sig)
#else
a198 1
#endif
a201 4
#ifdef PROTOTYPES
void
handle_DANGER (int sig)
#else
a204 1
#endif
a207 4
#ifdef PROTOTYPES
void
handle_GRANT (int sig)
#else
a210 1
#endif
a213 4
#ifdef PROTOTYPES
void
handle_RETRACT (int sig)
#else
a216 1
#endif
a219 4
#ifdef PROTOTYPES
void
handle_MSG (int sig)
#else
a222 1
#endif
a225 4
#ifdef PROTOTYPES
void
handle_SOUND (int sig)
#else
a228 1
#endif
a231 4
#ifdef PROTOTYPES
void
handle_SAK (int sig)
#else
a234 1
#endif
a237 4
#ifdef PROTOTYPES
void
handle_PRIO (int sig)
#else
a240 1
#endif
a243 4
#ifdef PROTOTYPES
void
handle_33 (int sig)
#else
a246 1
#endif
a249 4
#ifdef PROTOTYPES
void
handle_34 (int sig)
#else
a252 1
#endif
a255 4
#ifdef PROTOTYPES
void
handle_35 (int sig)
#else
a258 1
#endif
a261 4
#ifdef PROTOTYPES
void
handle_36 (int sig)
#else
a264 1
#endif
a267 4
#ifdef PROTOTYPES
void
handle_37 (int sig)
#else
a270 1
#endif
a273 4
#ifdef PROTOTYPES
void
handle_38 (int sig)
#else
a276 1
#endif
a279 4
#ifdef PROTOTYPES
void
handle_39 (int sig)
#else
a282 1
#endif
a285 4
#ifdef PROTOTYPES
void
handle_40 (int sig)
#else
a288 1
#endif
a291 4
#ifdef PROTOTYPES
void
handle_41 (int sig)
#else
a294 1
#endif
a297 4
#ifdef PROTOTYPES
void
handle_42 (int sig)
#else
a300 1
#endif
a303 4
#ifdef PROTOTYPES
void
handle_43 (int sig)
#else
a306 1
#endif
a309 4
#ifdef PROTOTYPES
void
handle_44 (int sig)
#else
a312 1
#endif
a315 4
#ifdef PROTOTYPES
void
handle_45 (int sig)
#else
a318 1
#endif
a321 4
#ifdef PROTOTYPES
void
handle_46 (int sig)
#else
a324 1
#endif
a327 4
#ifdef PROTOTYPES
void
handle_47 (int sig)
#else
a330 1
#endif
a333 4
#ifdef PROTOTYPES
void
handle_48 (int sig)
#else
a336 1
#endif
a339 4
#ifdef PROTOTYPES
void
handle_49 (int sig)
#else
a342 1
#endif
a345 4
#ifdef PROTOTYPES
void
handle_50 (int sig)
#else
a348 1
#endif
a351 4
#ifdef PROTOTYPES
void
handle_51 (int sig)
#else
a354 1
#endif
a357 4
#ifdef PROTOTYPES
void
handle_52 (int sig)
#else
a360 1
#endif
a363 4
#ifdef PROTOTYPES
void
handle_53 (int sig)
#else
a366 1
#endif
a369 4
#ifdef PROTOTYPES
void
handle_54 (int sig)
#else
a372 1
#endif
a375 4
#ifdef PROTOTYPES
void
handle_55 (int sig)
#else
a378 1
#endif
a381 4
#ifdef PROTOTYPES
void
handle_56 (int sig)
#else
a384 1
#endif
a387 4
#ifdef PROTOTYPES
void
handle_57 (int sig)
#else
a390 1
#endif
a393 4
#ifdef PROTOTYPES
void
handle_58 (int sig)
#else
a396 1
#endif
a399 4
#ifdef PROTOTYPES
void
handle_59 (int sig)
#else
a402 1
#endif
a405 4
#ifdef PROTOTYPES
void
handle_60 (int sig)
#else
a408 1
#endif
a411 4
#ifdef PROTOTYPES
void
handle_61 (int sig)
#else
a414 1
#endif
a417 4
#ifdef PROTOTYPES
void
handle_62 (int sig)
#else
a420 1
#endif
a423 4
#ifdef PROTOTYPES
void
handle_63 (int sig)
#else
a426 1
#endif
a429 4
#ifdef PROTOTYPES
void
handle_TERM (int sig)
#else
a432 1
#endif
a440 1
  return 0;
a450 1
return 0;
a460 1
return 0;
a470 1
return 0;
a480 1
return 0;
a501 1
return 0;
a511 1
return 0;
a521 1
return 0;
a531 1
return 0;
a541 1
return 0;
a551 1
return 0;
a561 1
return 0;
a571 1
return 0;
a581 1
return 0;
a591 1
return 0;
a601 1
return 0;
a611 1
return 0;
a621 1
return 0;
a631 1
return 0;
a641 1
return 0;
a651 1
return 0;
a661 1
return 0;
a671 1
return 0;
a681 1
return 0;
a691 1
return 0;
a701 1
return 0;
a711 1
return 0;
a721 1
return 0;
a731 1
return 0;
a741 1
return 0;
a751 1
return 0;
a761 1
return 0;
a771 1
return 0;
a781 1
return 0;
a791 1
return 0;
a801 1
return 0;
a811 1
return 0;
a821 1
return 0;
a831 1
return 0;
a841 1
return 0;
a851 1
return 0;
a861 1
return 0;
a871 1
return 0;
a881 1
return 0;
a891 1
return 0;
a901 1
return 0;
a911 1
return 0;
a921 1
return 0;
a931 1
return 0;
a941 1
return 0;
a951 1
return 0;
a961 1
return 0;
a971 1
return 0;
a981 1
return 0;
a991 1
return 0;
a1001 1
return 0;
a1011 1
return 0;
a1021 1
return 0;
a1031 1
return 0;
a1041 1
return 0;
a1051 1
return 0;
a1061 1
return 0;
a1071 1
return 0;
a1081 1
return 0;
a1091 1
return 0;
a1101 1
return 0;
a1111 1
return 0;
a1121 1
return 0;
a1131 1
return 0;
a1141 1
return 0;
a1147 1
return 0;
a1152 4
#ifdef usestubs
  set_debug_traps ();
  breakpoint ();
#endif
@

