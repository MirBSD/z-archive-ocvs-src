head	1.2;
access;
symbols
	cvs-200406091940:1.1.1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.17.43.06;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.40.48;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.40.48;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.29.50;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove the FSF changelog files and other unused files; use cvsweb or anoncvs to retrieve them
@
text
@#include <stdio.h>
/*
 *	Since using watchpoints can be very slow, we have to take some pains to
 *	ensure that we don't run too long with them enabled or we run the risk
 *	of having the test timeout.  To help avoid this, we insert some marker
 *	functions in the execution stream so we can set breakpoints at known
 *	locations, without worrying about invalidating line numbers by changing
 *	this file.  We use null bodied functions are markers since gdb does
 *	not support breakpoints at labeled text points at this time.
 *
 *	One place we need is a marker for when we start executing our tests
 *	instructions rather than any process startup code, so we insert one
 *	right after entering main().  Another is right before we finish, before
 *	we start executing any process termination code.
 *
 *	Another problem we have to guard against, at least for the test
 *	suite, is that we need to ensure that the line that causes the
 *	watchpoint to be hit is still the current line when gdb notices
 *	the hit.  Depending upon the specific code generated by the compiler,
 *	the instruction after the one that triggers the hit may be part of
 *	the same line or part of the next line.  Thus we ensure that there
 *	are always some instructions to execute on the same line after the
 *	code that should trigger the hit.
 */

int count = -1;
int ival1 = -1;
int ival2 = -1;
int ival3 = -1;
int ival4 = -1;
char buf[10];
struct foo
{
  int val;
};
struct foo struct1, struct2, *ptr1, *ptr2;

int doread = 0;

void marker1 ()
{
}

void marker2 ()
{
}

void marker4 ()
{
}

void marker5 ()
{
}

void
func2 ()
{
}

int
func1 ()
{
  /* The point of this is that we will set a breakpoint at this call.

     Then, if DECR_PC_AFTER_BREAK equals the size of a function call
     instruction (true on a sun3 if this is gcc-compiled--FIXME we
     should use asm() to make it work for any compiler, present or
     future), then we will end up branching to the location just after
     the breakpoint.  And we better not confuse that with hitting the
     breakpoint.  */
  func2 ();
  return 73;
}

int main ()
{
  struct1.val = 1;
  struct2.val = 2;
  ptr1 = &struct1;
  ptr2 = &struct2;
  marker1 ();
  func1 ();
  for (count = 0; count < 4; count++) {
    ival1 = count;
    ival3 = count; ival4 = count;
  }
  ival1 = count; /* Outside loop */
  ival2 = count;
  ival3 = count; ival4 = count;
  marker2 ();
  if (doread)
    {
      static char msg[] = "type stuff for buf now:";
      write (1, msg, sizeof (msg) - 1);
      read (0, &buf[0], 5);
    }
  marker4 ();

  /* We have a watchpoint on ptr1->val.  It should be triggered if
     ptr1's value changes.  */
  ptr1 = ptr2;

  /* This should not trigger the watchpoint.  If it does, then we
     used the wrong value chain to re-insert the watchpoints or we
     are not evaluating the watchpoint expression correctly.  */
  struct1.val = 5;
  marker5 ();

  /* We have a watchpoint on ptr1->val.  It should be triggered if
     ptr1's value changes.  */
  ptr1 = ptr2;

  /* This should not trigger the watchpoint.  If it does, then we
     used the wrong value chain to re-insert the watchpoints or we
     are not evaluating the watchpoint expression correctly.  */
  struct1.val = 5;
  marker5 ();
  return 0;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@a1 1
#include <unistd.h>
a30 1
int ival5 = -1;
a55 17
void marker6 ()
{
}

#ifdef PROTOTYPES
void recurser (int  x)
#else
void recurser (x) int  x;
#endif
{
  int  local_x;

  if (x > 0)
    recurser (x-1);
  local_x = x;
}

a58 18
  int  local_a;
  static int  static_b;

  ival5++;
  local_a = ival5;
  static_b = local_a;
}

void
func3 ()
{
  int x;
  int y;

  x = 0;
  x = 1;				/* second x assignment */
  y = 1;
  y = 2;
a77 4
#ifdef usestubs
  set_debug_traps();
  breakpoint();
#endif
a118 28

  /* We're going to watch locals of func2, to see that out-of-scope
     watchpoints are detected and properly deleted.
     */
  marker6 ();

  /* This invocation is used for watches of a single
     local variable. */
  func2 ();

  /* This invocation is used for watches of an expression
     involving a local variable. */
  func2 ();

  /* This invocation is used for watches of a static
     (non-stack-based) local variable. */
  func2 ();

  /* This invocation is used for watches of a local variable
     when recursion happens.
     */
  marker6 ();
  recurser (2);

  marker6 ();

  func3 ();

@

