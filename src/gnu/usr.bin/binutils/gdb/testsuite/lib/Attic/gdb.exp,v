head	1.2;
access;
symbols
	cvs-200406091940:1.1.1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2003.05.16.17.43.11;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.40.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.40.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.29.55;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove the FSF changelog files and other unused files; use cvsweb or anoncvs to retrieve them
@
text
@# Copyright (C) 1992, 1994, 1995 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@@cygnus.com)

# Generic gdb subroutines that should work for any target.  If these
# need to be modified for any target, it can be done with a variable
# or by passing arguments.

load_lib libgloss.exp

global GDB
global CC
global CXX
global CFLAGS
global CXXFLAGS
global CHILL_LIB
global CHILL_RT0

if ![info exists CC] {
    set CC [findfile $base_dir/../../gcc/xgcc "$base_dir/../../gcc/xgcc -B$base_dir/../../gcc/" [transform gcc]]
}
verbose "using CC = $CC" 2
if ![info exists CXX] {
    set CXX [findfile $base_dir/../../gcc/xgcc "$base_dir/../../gcc/xgcc -B$base_dir/../../gcc/" [transform g++]]
}
verbose "using CXX = $CXX" 2
if ![info exists CHILL_LIB] {
    set CHILL_LIB [findfile $base_dir/../../gcc/ch/runtime/libchill.a "$base_dir/../../gcc/ch/runtime/libchill.a" [transform -lchill]]
}
verbose "using CHILL_LIB = $CHILL_LIB" 2
if ![info exists CHILL_RT0] {
    set CHILL_RT0 [findfile $base_dir/../../gcc/ch/runtime/chillrt0.o "$base_dir/../../gcc/ch/runtime/chillrt0.o" ""]
}
verbose "using CHILL_RT0 = $CHILL_RT0" 2

if ![info exists LDFLAGS] {
    if [is3way] {
	append LDFLAGS " [libgloss_flags] [newlib_flags]"
    }
    set LDFLAGS ""
}
verbose "using LDFLAGS = $LDFLAGS" 2

if ![info exists GDB] then {
    set GDB [findfile $base_dir/../../gdb/gdb "$base_dir/../../gdb/gdb" [transform gdb]]
}
verbose "using GDB = $GDB" 2

global GDBFLAGS
if ![info exists GDBFLAGS] then {
    set GDBFLAGS "-nx"
}
verbose "using GDBFLAGS = $GDBFLAGS" 2

# The variable prompt is a regexp which matches the gdb prompt.  Set it if it
# is not already set.
global prompt
if ![info exists prompt] then {
    set prompt "\\(gdb\\)"
}

global usestubs
if [istarget "sparclite-*-*"] then {
    set usestubs 1
} else {
    set usestubs 0
}

if ![info exists noargs] then {
    set noargs 0
}

if ![info exists nosignals] then {
    set nosignals 0
}

if ![info exists noinferiorio] then {
    set noinferiorio 0
}

if ![info exists noresults] then {
    set noresults 0
}

#
# gdb_version -- extract and print the version number of GDB
#
proc default_gdb_version {} {
    global GDB
    global GDBFLAGS
    if {[which $GDB] != 0} then {
	set tmp [exec echo "q" | $GDB -nw $GDBFLAGS]
	regexp " \[0-9\]\[^ \t\n\]+" $tmp version
	clone_output "[which $GDB] version$version -nw $GDBFLAGS \n"
    } else {
	warning "$GDB does not exist"
    }
}

#
# gdb_unload -- unload a file if one is loaded
#

proc gdb_unload {} {
    global verbose
    global GDB
    global prompt
    send "file\n"
    expect {
	-re "No exec file now.*\r" { exp_continue }
	-re "No symbol file now.*\r" { exp_continue }
	-re "A program is being debugged already..*Kill it.*y or n. $"\
	    { send "y\n"
		verbose "\t\tKilling previous program being debugged"
	    exp_continue
	}
	-re "Discard symbol table from .*y or n. $" {
	    send "y\n"
	    exp_continue
	}
	-re "$prompt $" {}
	timeout {
	    perror "couldn't unload file in $GDB (timed out)."
	    return -1
	}
    }
}

# Many of the tests depend on setting breakpoints at various places and
# running until that breakpoint is reached.  At times, we want to start
# with a clean-slate with respect to breakpoints, so this utility proc 
# lets us do this without duplicating this code everywhere.
#

proc delete_breakpoints {} {
    global prompt

    send "delete breakpoints\n"
    expect {
	-re "Delete all breakpoints.*y or n. $" {
	    send "y\n"
	    exp_continue
	}
	-re "y\r\n$prompt $" {}
	-re ".*$prompt $" { # This happens if there were no breakpoints
	    }
	timeout { perror "Delete all breakpoints (timeout)" ; return }
    }
    send "info breakpoints\n"
    expect {
	-re "No breakpoints or watchpoints..*$prompt $" {}
	-re ".*$prompt $" { perror "breakpoints not deleted" ; return }
	timeout { perror "info breakpoints (timeout)" ; return }
    }
}


#
# Generic run command.
#
# The second pattern below matches up to the first newline *only*.
# Using ``.*$'' could swallow up output that we attempt to match
# elsewhere.
#
proc gdb_run_cmd {} {
    global usestubs
    global prompt

    if $usestubs!=0 {
	send "jump *start\n"
	expect {
	    -re "Line.* Jump anyway.*y or n. $" {
		send "y\n"
		expect {
		    -re "Continuing.*$prompt $" {}
		    timeout { perror "Jump to start() failed (timeout)"; return }
		}
            }
	    timeout { perror "Jump to start() failed (timeout)"; return }
	}
	send "continue\n"
	return
    }
    send "run\n"
    expect {
	-re "The program .* has been started already.*y or n. $" {
	    send "y\n"
	    exp_continue
	}
	-re "Starting program: \[^\n\]*" {}
    }
}


# Set breakpoint at function and run gdb until it breaks there.
# Since this is the only breakpoint that will be set, if it stops
# at a breakpoint, we will assume it is the one we want.  We can't
# just compare to "function" because it might be a fully qualified,
# single quoted C++ function specifier.

proc runto { function } {
    global prompt
    global decimal

    send "delete\n"
    expect {
	-re "delete.*Delete all breakpoints.*y or n. $" {
	    send "y\n"
	    expect {
		-re "$prompt $" {}
		timeout { fail "deleting breakpoints (timeout)" ; return 0 }
	    }
	}
	-re ".*$prompt $" {}
	timeout { fail "deleting breakpoints (timeout)" ; return 0 }
    }

    send "break $function\n"
    # The first two regexps are what we get with -g, the third is without -g.
    expect {
	-re "Breakpoint \[0-9\]* at .*: file .*, line $decimal.\r\n$prompt $" {}
	-re "Breakpoint \[0-9\]*: file .*, line $decimal.\r\n$prompt $" {}
	-re "Breakpoint \[0-9\]* at .*$prompt $" {}
	-re "$prompt $" { fail "setting breakpoint at $function" ; return 0 }
	timeout { fail "setting breakpoint at $function (timeout)" ; return 0 }
    }

    gdb_run_cmd
    
    # the "at foo.c:36" output we get with -g.
    # the "in func" output we get without -g.
    expect {
	-re "Break.* at .*:$decimal.*$prompt $" {
	    return 1
	}
	-re "Breakpoint \[0-9\]*, \[0-9xa-f\]* in $function.*$prompt $" { 
	    return 1
	}
	-re "$prompt $" { 
	    fail "running to $function"
	    return 0
	}
	timeout { 
	    fail "running to $function (timeout)"
	    return 0
	}
    }
}

#
# runto_main -- ask gdb to run and untill hit break point at main.
#		if it uses stubs, assuming we hit breakpoint() and just
#		step out of the function.
#
proc runto_main {} {
    global prompt
    global decimal
    global usestubs

    if $usestubs==0 {
	return [runto main]
    }			

    send "delete\n"
    expect {
	-re "delete.*Delete all breakpoints.*y or n. $" {
	    send "y\n"
	    expect {
		-re "$prompt $" {}
		timeout { fail "deleting breakpoints (timeout)" ; return 0 }
	    }
	}
	-re ".*$prompt $" {}
	timeout { fail "deleting breakpoints (timeout)" ; return 0 }
    }

    send "step\n"
    # if use stubs step out of the breakpoint() function.
    expect {
	-re "main.* at .*$prompt $" {}
	timeout { fail "single step at breakpoint() (timeout)" ; return 0 }
    }
    return 1
}

#
# gdb_test -- send a command to gdb and test the result.
#             Takes three parameters.
#             Parameters:
#                First one is the command to execute.  If this is the null string
#		   then no command is sent.
#                Second one is the pattern to match for a PASS, and must NOT include
#		   the \r\n sequence immediately before the gdb prompt.
#                Third one is an optional message to be printed. If this
#                  a null string "", then the pass/fail messages use the command
#		   string as the message.
#             Returns:
#                1 if the test failed,
#                0 if the test passes,
#               -1 if there was an internal error.
#
proc gdb_test { args } {
    global verbose
    global prompt
    global GDB
    global spawn_id
    global expect_out
    upvar timeout timeout

    if [llength $args]==3 then {
	set message [lindex $args 2]
    } else {
	set message [lindex $args 0]
    }
    set command [lindex $args 0]
    set pattern [lindex $args 1]

    if $verbose>2 then {
	send_user "Sending \"$command\" to gdb\n"
	send_user "Looking to match \"$pattern\"\n"
	send_user "Message is \"$message\"\n"
    }

    set result -1
    if ![string match $command ""] {
	send "$command\n"
    }

    expect {
	-re ".*Ending remote debugging.*$prompt$" {
	    if ![isnative] then {
		warning "Can`t communicate to remote target."
	    }
	    gdb_exit
	    gdb_start
	    set result -1
	}
	-re "$pattern\r\n$prompt $" {
	    if ![string match "" $message] then {
		pass "$message"
	    }
	    set result 0
	}
	-re "Undefined command:.*$prompt" {
	    perror "Undefined command \"$command\"."
	    set result 1
	}
	-re "Ambiguous command.*$prompt $" {
	    perror "\"$command\" is not a unique command name."
	    set result 1
	}
	-re "(.*)(Program exited with code \[0-9\]+)(.*$prompt $)" {
	    if ![string match "" $message] then {
		set errmsg "$message: $expect_out(2,string)"
	    } else {
		set errmsg "$command: $expect_out(2,string)"
	    }
	    fail "$errmsg"
	    return -1
	}
	-re "The program is not being run.*$prompt $" {
	    if ![string match "" $message] then {
		set errmsg "$message: the program is no longer running"
	    } else {
		set errmsg "$command: the program is no longer running"
	    }
	    fail "$errmsg"
	    return -1
	}
	-re ".*$prompt $" {
	    if ![string match "" $message] then {
		fail "$message"
	    }
	    set result 1
	}
	"<return>" {
	    send "\n"
	    perror "Window too small."
	}
	-re "\\(y or n\\) " {
	    send "n\n"
	    perror "Got interactive prompt."
	}
	eof {
	    perror "Process no longer exists"
	    return -1
	}
	full_buffer {
	    perror "internal buffer is full."
	}
	timeout	{
	    if ![string match "" $message] then {
		fail "(timeout) $message"
	    }
	    set result 1
	}
    }
    return $result
}

# Test that a command gives an error.  For pass or fail, return
# a 1 to indicate that more tests can proceed.  However a timeout
# is a serious error, generates a special fail message, and causes
# a 0 to be returned to indicate that more tests are likely to fail
# as well.

proc test_print_reject { args } {
    global prompt
    global verbose

    if [llength $args]==2 then {
	set expectthis [lindex $args 1]
    } else {
	set expectthis "should never match this bogus string"
    }
    set sendthis [lindex $args 0]
    if $verbose>2 then {
	send_user "Sending \"$sendthis\" to gdb\n"
	send_user "Looking to match \"$expectthis\"\n"
    }
    send "$sendthis\n"
    expect {
	-re ".*A .* in expression.*\\.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*Invalid syntax in expression.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*Junk after end of expression.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*Invalid number.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*Invalid character constant.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*No symbol table is loaded.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*No symbol .* in current context.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*$expectthis.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*$prompt $" {
	    fail "reject $sendthis"
	    return 1
	}
	default {
	    fail "reject $sendthis (eof or timeout)"
	    return 0
	}
    }
}

# Given an input string, adds backslashes as needed to create a
# regexp that will match the string.

proc string_to_regexp {str} {
    set result $str
    regsub -all {[]*+.|()^$\[]} $str {\\&} result
    return $result
}

# Same as gdb_test, but the second parameter is not a regexp,
# but a string that must match exactly.

proc gdb_test_exact { args } {
    upvar timeout timeout

    set command [lindex $args 0]

    # This applies a special meaning to a null string pattern.  Without
    # this, "$pattern\r\n$prompt $" will match anything, including error
    # messages from commands that should have no output except a new
    # prompt.  With this, only results of a null string will match a null
    # string pattern.

    set pattern [lindex $args 1]
    if [string match $pattern ""] {
	set pattern [string_to_regexp [lindex $args 0]]
    } else {
	set pattern [string_to_regexp [lindex $args 1]]
    }

    # It is most natural to write the pattern argument with only
    # embedded \n's, especially if you are trying to avoid Tcl quoting
    # problems.  But expect really wants to see \r\n in patterns.  So
    # transform the pattern here.  First transform \r\n back to \n, in
    # case some users of gdb_test_exact already do the right thing.
    regsub -all "\r\n" $pattern "\n" pattern
    regsub -all "\n" $pattern "\r\n" pattern
    if [llength $args]==3 then {
	set message [lindex $args 2]
    } else {
	set message $command
    }

    return [gdb_test $command $pattern $message]
}

proc gdb_reinitialize_dir { subdir } {
    global prompt

   send "dir\n"
    expect {
	-re "Reinitialize source path to empty.*y or n. " {
	    send "y\n"
	    expect {
		-re "Source directories searched.*$prompt $" {
		    send "dir $subdir\n"
		    expect {
			-re "Source directories searched.*$prompt $" {
			    verbose "Dir set to $subdir"
			}
			-re ".*$prompt $" {
			    perror "Dir \"$subdir\" failed."
			}
		    }
		}
		-re ".*$prompt $" {
		    perror "Dir \"$subdir\" failed."
		}
	    }
	}
	-re ".*$prompt $" {
	    perror "Dir \"$subdir\" failed."
	}
    }
}

#
# gdb_exit -- exit the GDB, killing the target program if necessary
#
proc default_gdb_exit {} {
    global GDB
    global GDBFLAGS
    global verbose

    verbose "Quitting $GDB $GDBFLAGS"

    # This used to be 1 for unix-gdb.exp
    set timeout 5
    verbose "Timeout is now $timeout seconds" 2

    # We used to try to send "quit" to GDB, and wait for it to die.
    # Dealing with all the cases and errors got pretty hairy.  Just close it, 
    # that is simpler.
    close

    # Omitting this probably would cause strange timing-dependent failures.
    wait
}

#
# load a file into the debugger.
# return a -1 if anything goes wrong.
#
proc gdb_file_cmd { arg } {
    global verbose
    global loadpath
    global loadfile
    global GDB
    global prompt
    global spawn_id
    upvar timeout timeout

    send "file $arg\n"
    expect {
        -re "Reading symbols from.*done.*$prompt $" {
            verbose "\t\tLoaded $arg into the $GDB"
            return 0
        }
        -re "has no symbol-table.*$prompt $" {
            perror "$arg wasn't compiled with \"-g\""
            return -1
        }
        -re "A program is being debugged already.*Kill it.*y or n. $" {
            send "y\n"
                verbose "\t\tKilling previous program being debugged"
            exp_continue
        }
        -re "Load new symbol table from \".*\".*y or n. $" {
            send "y\n"
            expect {
                -re "Reading symbols from.*done.*$prompt $" {
                    verbose "\t\tLoaded $arg with new symbol table into $GDB"
                    return 0
                }
                timeout {
                    perror "(timeout) Couldn't load $arg, other program already l
oaded."
                    return -1
                }
            }
	}
        -re ".*No such file or directory.*$prompt $" {
            perror "($arg) No such file or directory\n"
            return -1
        }
        -re "$prompt $" {
            perror "couldn't load $arg into $GDB."
            return -1
            }
        timeout {
            perror "couldn't load $arg into $GDB (timed out)."
            return -1
        }
        eof {
            # This is an attempt to detect a core dump, but seems not to
            # work.  Perhaps we need to match .* followed by eof, in which
            # expect does not seem to have a way to do that.
            perror "couldn't load $arg into $GDB (end of file)."
            return -1
        }
    }
}

#
# start gdb -- start gdb running, default procedure
#
# When running over NFS, particularly if running many simultaneous
# tests on different hosts all using the same server, things can
# get really slow.  Give gdb at least 3 minutes to start up.
#
proc default_gdb_start { } {
    global verbose
    global GDB
    global GDBFLAGS
    global prompt
    global spawn_id
    global timeout
    verbose "Spawning $GDB -nw $GDBFLAGS"

    if { [which $GDB] == 0 } then {
	perror "$GDB does not exist."
	exit 1
    }
    
    set oldtimeout $timeout
    set timeout [expr "$timeout + 180"]
    verbose "Timeout increased to $timeout seconds" 2
    eval "spawn $GDB -nw $GDBFLAGS"
    expect {
	-re ".*\r\n$prompt $" {
	    verbose "GDB initialized."
	}
	-re "$prompt $"	{
	    perror "GDB never initialized."
	    set timeout $oldtimeout
	    verbose "Timeout restored to $timeout seconds" 2
	    return -1
	}
	timeout		{
	    perror "(timeout) GDB never initialized after $timeout seconds."
	    set timeout $oldtimeout
	    verbose "Timeout restored to $timeout seconds" 2
	    return -1
	}
    }
    set timeout $oldtimeout
    verbose "Timeout restored to $timeout seconds" 2
    # force the height to "unlimited", so no pagers get used
    send "set height 0\n"
    expect {
	-re ".*$prompt $" { 
	    verbose "Setting height to 0." 2
	}
	timeout {
	    warning "Couldn't set the height to 0."
	}
    }
    # force the width to "unlimited", so no wraparound occurs
    send "set width 0\n"
    expect {
	-re ".*$prompt $" {
	    verbose "Setting width to 0." 2
	}
	timeout {
	    warning "Couldn't set the width to 0."
	}
    }
}

#
# FIXME: this is a copy of the new library procedure, but it's here too
# till the new dejagnu gets installed everywhere. I'd hate to break the
# gdb tests suite.
#
global argv0
if ![info exists argv0] then {
    proc exp_continue { } {
	continue -expect
    }
}

# * For crosses, the CHILL runtime doesn't build because it can't find
# setjmp.h, stdio.h, etc.
# * For AIX (as of 16 Mar 95), (a) there is no language code for
# CHILL in output_epilog in gcc/config/rs6000/rs6000.c, (b) collect2
# does not get along with AIX's too-clever linker.
# * On Irix5, there is a bug whereby set of bool, etc., don't get
# TYPE_LOW_BOUND for the bool right because force_to_range_type doesn't
# work with stub types.
# Lots of things seem to fail on the PA, and since it's not a supported
# chill target at the moment, don't run the chill tests.

proc skip_chill_tests {} {
    eval set skip_chill [expr ![isnative] || [istarget "*-*-aix*"] || [istarget "*-*-irix5*"] || [istarget "alpha-*-osf*"] || [istarget "hppa*-*-*"]]
    verbose "Skip chill tests is $skip_chill"
    return $skip_chill
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d1 1
a1 3
# Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
# 2002, 2003, 2004
# Free Software Foundation, Inc.
d15 1
a15 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
d29 6
d36 2
a37 2
if [info exists TOOL_EXECUTABLE] {
    set GDB $TOOL_EXECUTABLE;
d39 17
a55 5
if ![info exists GDB] {
    if ![is_remote host] {
	set GDB [findfile $base_dir/../../gdb/gdb "$base_dir/../../gdb/gdb" [transform gdb]]
    } else {
	set GDB [transform gdb];
d57 6
d67 1
a67 1
if ![info exists GDBFLAGS] {
d72 5
a76 5
# The variable gdb_prompt is a regexp which matches the gdb prompt.
# Set it if it is not already set.
global gdb_prompt
if ![info exists gdb_prompt] then {
    set gdb_prompt "\[(\]gdb\[)\]"
d79 10
a88 3
# Needed for some tests under Cygwin.
global EXEEXT
global env
d90 2
a91 4
if ![info exists env(EXEEXT)] {
    set EXEEXT ""
} else {
    set EXEEXT $env(EXEEXT)
d94 7
a100 1
### Only procedures should come after this point.
d108 4
a111 13
    global gdb_prompt
    set fileid [open "gdb_cmd" w];
    puts $fileid "q";
    close $fileid;
    set cmdfile [remote_download host "gdb_cmd"];
    set output [remote_exec host "$GDB -nw --command $cmdfile"]
    remote_file build delete "gdb_cmd";
    remote_file host delete "$cmdfile";
    set tmp [lindex $output 1];
    set version ""
    regexp " \[0-9\]\[^ \t\n\r\]+" "$tmp" version
    if ![is_remote host] {
	clone_output "[which $GDB] version $version $GDBFLAGS\n"
d113 1
a113 1
	clone_output "$GDB on remote host version $version $GDBFLAGS\n"
a116 4
proc gdb_version { } {
    return [default_gdb_version];
}

d124 5
a128 5
    global gdb_prompt
    send_gdb "file\n"
    gdb_expect 60 {
	-re "No executable file now\[^\r\n\]*\[\r\n\]" { exp_continue }
	-re "No symbol file now\[^\r\n\]*\[\r\n\]" { exp_continue }
d130 1
a130 1
	    { send_gdb "y\n"
d134 2
a135 2
	-re "Discard symbol table from .*y or n.*$" {
	    send_gdb "y\n"
d138 1
a138 1
	-re "$gdb_prompt $" {}
d153 1
a153 1
    global gdb_prompt
d155 4
a158 7
    # we need a larger timeout value here or this thing just confuses
    # itself.  May need a better implementation if possible. - guo
    #
    send_gdb "delete breakpoints\n"
    gdb_expect 100 {
	 -re "Delete all breakpoints.*y or n.*$" {
	    send_gdb "y\n";
d161 2
a162 1
	 -re "$gdb_prompt $" { # This happens if there were no breakpoints
d164 1
a164 1
	 timeout { perror "Delete all breakpoints in delete_breakpoints (timeout)" ; return }
d166 5
a170 9
    send_gdb "info breakpoints\n"
    gdb_expect 100 {
	 -re "No breakpoints or watchpoints..*$gdb_prompt $" {}
	 -re "$gdb_prompt $" { perror "breakpoints not deleted" ; return }
	 -re "Delete all breakpoints.*or n.*$" {
	    send_gdb "y\n";
	    exp_continue
	}
	 timeout { perror "info breakpoints (timeout)" ; return }
d182 12
a193 48
proc gdb_run_cmd {args} {
    global gdb_prompt

    if [target_info exists gdb_init_command] {
	send_gdb "[target_info gdb_init_command]\n";
	gdb_expect 30 {
	    -re "$gdb_prompt $" { }
	    default {
		perror "gdb_init_command for target failed";
		return;
	    }
	}
    }

    if [target_info exists use_gdb_stub] {
	if [target_info exists gdb,do_reload_on_run] {
	    # Specifying no file, defaults to the executable
	    # currently being debugged.
	    if { [gdb_load ""] < 0 } {
		return;
	    }
	    send_gdb "continue\n";
	    gdb_expect 60 {
		-re "Continu\[^\r\n\]*\[\r\n\]" {}
		default {}
	    }
	    return;
	}

	if [target_info exists gdb,start_symbol] {
	    set start [target_info gdb,start_symbol];
	} else {
	    set start "start";
	}
	send_gdb  "jump *$start\n"
	set start_attempt 1;
	while { $start_attempt } {
	    # Cap (re)start attempts at three to ensure that this loop
	    # always eventually fails.  Don't worry about trying to be
	    # clever and not send a command when it has failed.
	    if [expr $start_attempt > 3] {
		perror "Jump to start() failed (retry count exceeded)";
		return;
	    }
	    set start_attempt [expr $start_attempt + 1];
	    gdb_expect 30 {
		-re "Continuing at \[^\r\n\]*\[\r\n\]" {
		    set start_attempt 0;
d195 2
a196 31
		-re "No symbol \"_start\" in current.*$gdb_prompt $" {
		    perror "Can't find start symbol to run in gdb_run";
		    return;
		}
		-re "No symbol \"start\" in current.*$gdb_prompt $" {
		    send_gdb "jump *_start\n";
		}
		-re "No symbol.*context.*$gdb_prompt $" {
		    set start_attempt 0;
		}
		-re "Line.* Jump anyway.*y or n. $" {
		    send_gdb "y\n"
		}
		-re "The program is not being run.*$gdb_prompt $" {
		    if { [gdb_load ""] < 0 } {
			return;
		    }
		    send_gdb "jump *$start\n";
		}
		timeout {
		    perror "Jump to start() failed (timeout)"; 
		    return
		}
	    }
	}
	if [target_info exists gdb_stub] {
	    gdb_expect 60 {
		-re "$gdb_prompt $" {
		    send_gdb "continue\n"
		}
	    }
d198 1
d201 2
a202 9

    if [target_info exists gdb,do_reload_on_run] {
	if { [gdb_load ""] < 0 } {
	    return;
	}
    }
    send_gdb "run $args\n"
# This doesn't work quite right yet.
    gdb_expect 60 {
d204 1
a204 1
	    send_gdb "y\n"
d207 1
a207 1
	-re "Starting program: \[^\r\n\]*" {}
a210 33
# Set a breakpoint at FUNCTION.  If there is an additional argument it is
# a list of options; the only currently supported option is allow-pending.

proc gdb_breakpoint { function args } {
    global gdb_prompt
    global decimal

    set pending_response n
    if {[lsearch -exact [lindex $args 0] allow-pending] != -1} {
	set pending_response y
    }

    send_gdb "break $function\n"
    # The first two regexps are what we get with -g, the third is without -g.
    gdb_expect 30 {
	-re "Breakpoint \[0-9\]* at .*: file .*, line $decimal.\r\n$gdb_prompt $" {}
	-re "Breakpoint \[0-9\]*: file .*, line $decimal.\r\n$gdb_prompt $" {}
	-re "Breakpoint \[0-9\]* at .*$gdb_prompt $" {}
	-re "Breakpoint \[0-9\]* \\(.*\\) pending.*$gdb_prompt $" {
		if {$pending_response == "n"} {
			fail "setting breakpoint at $function"
			return 0
		}
	}
	-re "Make breakpoint pending.*y or \\\[n\\\]. $" { 
		send_gdb "$pending_response\n"
		exp_continue
	}
	-re "$gdb_prompt $" { fail "setting breakpoint at $function" ; return 0 }
	timeout { fail "setting breakpoint at $function (timeout)" ; return 0 }
    }
    return 1;
}    
d216 1
a216 2
# single quoted C++ function specifier.  If there's an additional argument,
# pass it to gdb_breakpoint.
d218 2
a219 2
proc runto { function args } {
    global gdb_prompt
d222 12
a233 1
    delete_breakpoints
d235 8
a242 2
    if ![gdb_breakpoint $function [lindex $args 0]] {
	return 0;
d249 2
a250 2
    gdb_expect 30 {
	-re "Break.* at .*:$decimal.*$gdb_prompt $" {
d253 1
a253 1
	-re "Breakpoint \[0-9\]*, \[0-9xa-f\]* in .*$gdb_prompt $" { 
d256 2
a257 2
	-re "$gdb_prompt $" { 
	    fail "running to $function in runto"
d261 1
a261 1
	    fail "running to $function in runto (timeout)"
a264 1
    return 1
d268 3
a270 4
# runto_main -- ask gdb to run until we hit a breakpoint at main.
#		The case where the target uses stubs has to be handled
#		specially--if it uses stubs, assuming we hit
#		breakpoint() and just step out of the function.
d272 2
a273 2
proc runto_main { } {
    global gdb_prompt
d275 1
d277 1
a277 1
    if ![target_info exists gdb_stub] {
d281 19
a299 4
    delete_breakpoints

    gdb_step_for_stub;

a302 26

### Continue, and expect to hit a breakpoint.
### Report a pass or fail, depending on whether it seems to have
### worked.  Use NAME as part of the test name; each call to
### continue_to_breakpoint should use a NAME which is unique within
### that test file.
proc gdb_continue_to_breakpoint {name} {
    global gdb_prompt
    set full_name "continue to breakpoint: $name"

    send_gdb "continue\n"
    gdb_expect {
	-re "Breakpoint .* at .*\r\n$gdb_prompt $" {
	    pass $full_name
	}
	-re ".*$gdb_prompt $" {
	    fail $full_name
	}
	timeout { 
	    fail "$full_name (timeout)"
	}
    }
}


# gdb_internal_error_resync:
d304 14
a317 4
# Answer the questions GDB asks after it reports an internal error
# until we get back to a GDB prompt.  Decline to quit the debugging
# session, and decline to create a core file.  Return non-zero if the
# resync succeeds.
d319 1
a319 78
# This procedure just answers whatever questions come up until it sees
# a GDB prompt; it doesn't require you to have matched the input up to
# any specific point.  However, it only answers questions it sees in
# the output itself, so if you've matched a question, you had better
# answer it yourself before calling this.
#
# You can use this function thus:
#
# gdb_expect {
#     ...
#     -re ".*A problem internal to GDB has been detected" {
#         gdb_internal_error_resync
#     }
#     ...
# }
#
proc gdb_internal_error_resync {} {
    global gdb_prompt

    set count 0
    while {$count < 10} {
	gdb_expect {
	    -re "Quit this debugging session\\? \\(y or n\\) $" {
		send_gdb "n\n"
		incr count
	    }
	    -re "Create a core file of GDB\\? \\(y or n\\) $" {
		send_gdb "n\n"
		incr count
	    }
	    -re "$gdb_prompt $" {
		# We're resynchronized.
		return 1
	    }
	    timeout {
		perror "Could not resync from internal error (timeout)"
		return 0
	    }
	}
    }
    perror "Could not resync from internal error (resync count exceeded)"
    return 0
}


# gdb_test_multiple COMMAND MESSAGE EXPECT_ARGUMENTS
# Send a command to gdb; test the result.
#
# COMMAND is the command to execute, send to GDB with send_gdb.  If
#   this is the null string no command is sent.
# MESSAGE is a message to be printed with the built-in failure patterns
#   if one of them matches.  If MESSAGE is empty COMMAND will be used.
# EXPECT_ARGUMENTS will be fed to expect in addition to the standard
#   patterns.  Pattern elements will be evaluated in the caller's
#   context; action elements will be executed in the caller's context.
#   Unlike patterns for gdb_test, these patterns should generally include
#   the final newline and prompt.
#
# Returns:
#    1 if the test failed, according to a built-in failure pattern
#    0 if only user-supplied patterns matched
#   -1 if there was an internal error.
#  
# You can use this function thus:
#
# gdb_test_multiple "print foo" "test foo" {
#    -re "expected output 1" {
#        pass "print foo"
#    }
#    -re "expected output 2" {
#        fail "print foo"
#    }
# }
#
# The standard patterns, such as "Program exited..." and "A problem
# ...", all being implicitly appended to that list.
#
proc gdb_test_multiple { command message user_code } {
d321 1
a321 1
    global gdb_prompt
d323 2
a325 1
    upvar expect_out expect_out
d327 4
a330 2
    if { $message == "" } {
	set message $command
d332 2
a333 56

    # TCL/EXPECT WART ALERT
    # Expect does something very strange when it receives a single braced
    # argument.  It splits it along word separators and performs substitutions.
    # This means that { "[ab]" } is evaluated as "[ab]", but { "\[ab\]" } is
    # evaluated as "\[ab\]".  But that's not how TCL normally works; inside a
    # double-quoted list item, "\[ab\]" is just a long way of representing
    # "[ab]", because the backslashes will be removed by lindex.

    # Unfortunately, there appears to be no easy way to duplicate the splitting
    # that expect will do from within TCL.  And many places make use of the
    # "\[0-9\]" construct, so we need to support that; and some places make use
    # of the "[func]" construct, so we need to support that too.  In order to
    # get this right we have to substitute quoted list elements differently
    # from braced list elements.

    # We do this roughly the same way that Expect does it.  We have to use two
    # lists, because if we leave unquoted newlines in the argument to uplevel
    # they'll be treated as command separators, and if we escape newlines
    # we mangle newlines inside of command blocks.  This assumes that the
    # input doesn't contain a pattern which contains actual embedded newlines
    # at this point!

    regsub -all {\n} ${user_code} { } subst_code
    set subst_code [uplevel list $subst_code]

    set processed_code ""
    set patterns ""
    set expecting_action 0
    foreach item $user_code subst_item $subst_code {
	if { $item == "-n" || $item == "-notransfer" || $item == "-nocase" } {
	    lappend processed_code $item
	    continue
	}
	if {$item == "-indices" || $item == "-re" || $item == "-ex"} {
	    lappend processed_code $item
	    continue
	}
	if { $expecting_action } {
	    lappend processed_code "uplevel [list $item]"
	    set expecting_action 0
	    # Cosmetic, no effect on the list.
	    append processed_code "\n"
	    continue
	}
	set expecting_action 1
	lappend processed_code $subst_item
	if {$patterns != ""} {
	    append patterns "; "
	}
	append patterns "\"$subst_item\""
    }

    # Also purely cosmetic.
    regsub -all {\r} $patterns {\\r} patterns
    regsub -all {\n} $patterns {\\n} patterns
d337 1
a337 1
	send_user "Looking to match \"$patterns\"\n"
d342 2
a343 56
    set string "${command}\n";
    if { $command != "" } {
	while { "$string" != "" } {
	    set foo [string first "\n" "$string"];
	    set len [string length "$string"];
	    if { $foo < [expr $len - 1] } {
		set str [string range "$string" 0 $foo];
		if { [send_gdb "$str"] != "" } {
		    global suppress_flag;

		    if { ! $suppress_flag } {
			perror "Couldn't send $command to GDB.";
		    }
		    fail "$message";
		    return $result;
		}
		# since we're checking if each line of the multi-line
		# command are 'accepted' by GDB here,
		# we need to set -notransfer expect option so that
		# command output is not lost for pattern matching
		# - guo
		gdb_expect 2 {
		    -notransfer -re "\[\r\n\]" { verbose "partial: match" 3 }
		    timeout { verbose "partial: timeout" 3 }
		}
		set string [string range "$string" [expr $foo + 1] end];
	    } else {
		break;
	    }
	}
	if { "$string" != "" } {
	    if { [send_gdb "$string"] != "" } {
		global suppress_flag;

		if { ! $suppress_flag } {
		    perror "Couldn't send $command to GDB.";
		}
		fail "$message";
		return $result;
	    }
	}
    }

    if [target_info exists gdb,timeout] {
	set tmt [target_info gdb,timeout];
    } else {
	if [info exists timeout] {
	    set tmt $timeout;
	} else {
	    global timeout;
	    if [info exists timeout] {
		set tmt $timeout;
	    } else {
		set tmt 60;
	    }
	}
d346 2
a347 13
    set code {
         -re ".*A problem internal to GDB has been detected" {
             fail "$message (GDB internal error)"
             gdb_internal_error_resync
         }
	 -re "\\*\\*\\* DOSEXIT code.*" {
	     if { $message != "" } {
		 fail "$message";
	     }
	     gdb_suppress_entire_file "GDB died";
	     set result -1;
	 }
	 -re "Ending remote debugging.*$gdb_prompt $" {
d355 7
a361 4
    }
    append code $processed_code
    append code {
	 -re "Undefined\[a-z\]* command:.*$gdb_prompt $" {
a362 1
            fail "$message"
d365 1
a365 1
	 -re "Ambiguous command.*$gdb_prompt $" {
a366 1
            fail "$message"
d369 1
a369 1
	 -re "Program exited with code \[0-9\]+.*$gdb_prompt $" {
d371 1
a371 1
		set errmsg "$message (the program exited)"
d373 1
a373 1
		set errmsg "$command (the program exited)"
d376 1
a376 1
	    set result -1
d378 1
a378 1
	 -re "EXIT code \[0-9\r\n\]+Program exited normally.*$gdb_prompt $" {
d380 1
a380 1
		set errmsg "$message (the program exited)"
d382 1
a382 1
		set errmsg "$command (the program exited)"
d385 1
a385 1
	    set result -1
d387 1
a387 10
	 -re "The program is not being run.*$gdb_prompt $" {
	    if ![string match "" $message] then {
		set errmsg "$message (the program is no longer running)"
	    } else {
		set errmsg "$command (the program is no longer running)"
	    }
	    fail "$errmsg"
	    set result -1
	}
	 -re ".*$gdb_prompt $" {
d393 2
a394 2
	 "<return>" {
	    send_gdb "\n"
a395 2
            fail "$message"
	    set result -1
d397 2
a398 2
	 -re "\\(y or n\\) " {
	    send_gdb "n\n"
a399 2
            fail "$message"
	    set result -1
d401 3
a403 6
	 eof {
	     perror "Process no longer exists"
	     if { $message != "" } {
		 fail "$message"
	     }
	     return -1
d405 1
a405 1
	 full_buffer {
a406 2
            fail "$message"
	    set result -1
d410 1
a410 1
		fail "$message (timeout)"
a414 3

    set result 0
    gdb_expect $tmt $code
a416 54

# gdb_test COMMAND PATTERN MESSAGE QUESTION RESPONSE
# Send a command to gdb; test the result.
#
# COMMAND is the command to execute, send to GDB with send_gdb.  If
#   this is the null string no command is sent.
# PATTERN is the pattern to match for a PASS, and must NOT include
#   the \r\n sequence immediately before the gdb prompt.
# MESSAGE is an optional message to be printed.  If this is
#   omitted, then the pass/fail messages use the command string as the
#   message.  (If this is the empty string, then sometimes we don't
#   call pass or fail at all; I don't understand this at all.)
# QUESTION is a question GDB may ask in response to COMMAND, like
#   "are you sure?"
# RESPONSE is the response to send if QUESTION appears.
#
# Returns:
#    1 if the test failed,
#    0 if the test passes,
#   -1 if there was an internal error.
#  
proc gdb_test { args } {
    global verbose
    global gdb_prompt
    global GDB
    upvar timeout timeout

    if [llength $args]>2 then {
	set message [lindex $args 2]
    } else {
	set message [lindex $args 0]
    }
    set command [lindex $args 0]
    set pattern [lindex $args 1]

    if [llength $args]==5 {
	set question_string [lindex $args 3];
	set response_string [lindex $args 4];
    } else {
	set question_string "^FOOBAR$"
    }

    return [gdb_test_multiple $command $message {
	-re "\[\r\n\]*($pattern)\[\r\n\]+$gdb_prompt $" {
	    if ![string match "" $message] then {
		pass "$message"
            }
        }
	-re "(${question_string})$" {
	    send_gdb "$response_string\n";
	    exp_continue;
	}
     }]
}
d425 1
a425 1
    global gdb_prompt
d438 3
a440 4
    send_gdb "$sendthis\n"
    #FIXME: Should add timeout as parameter.
    gdb_expect {
	-re "A .* in expression.*\\.*$gdb_prompt $" {
d444 1
a444 1
	-re "Invalid syntax in expression.*$gdb_prompt $" {
d448 1
a448 1
	-re "Junk after end of expression.*$gdb_prompt $" {
d452 1
a452 1
	-re "Invalid number.*$gdb_prompt $" {
d456 1
a456 1
	-re "Invalid character constant.*$gdb_prompt $" {
d460 1
a460 1
	-re "No symbol table is loaded.*$gdb_prompt $" {
d464 1
a464 1
	-re "No symbol .* in current context.*$gdb_prompt $" {
d468 1
a468 9
        -re "Unmatched single quote.*$gdb_prompt $" {
            pass "reject $sendthis"
            return 1
        }
        -re "A character constant must contain at least one character.*$gdb_prompt $" {
            pass "reject $sendthis"
            return 1
        }
	-re "$expectthis.*$gdb_prompt $" {
d472 1
a472 1
	-re ".*$gdb_prompt $" {
d501 1
a501 1
    # this, "$pattern\r\n$gdb_prompt $" will match anything, including error
d515 1
a515 1
    # problems.  But gdb_expect really wants to see \r\n in patterns.  So
d530 1
a530 1
    global gdb_prompt
d532 2
a533 5
    if [is_remote host] {
	return "";
    }
    send_gdb "dir\n"
    gdb_expect 60 {
d535 6
a540 6
	    send_gdb "y\n"
	    gdb_expect 60 {
		-re "Source directories searched.*$gdb_prompt $" {
		    send_gdb "dir $subdir\n"
		    gdb_expect 60 {
			-re "Source directories searched.*$gdb_prompt $" {
d543 1
a543 1
			-re "$gdb_prompt $" {
d548 1
a548 1
		-re "$gdb_prompt $" {
d553 1
a553 1
	-re "$gdb_prompt $" {
a565 7
    global gdb_spawn_id;

    gdb_stop_suppressing_tests;

    if ![info exists gdb_spawn_id] {
	return;
    }
d569 8
a576 11
    if { [is_remote host] && [board_info host exists fileid] } {
	send_gdb "quit\n";
	gdb_expect 10 {
	    -re "y or n" {
		send_gdb "y\n";
		exp_continue;
	    }
	    -re "DOSEXIT code" { }
	    default { }
	}
    }
d578 2
a579 4
    if ![is_remote host] {
	remote_close host;
    }
    unset gdb_spawn_id
d591 2
a592 1
    global gdb_prompt
d595 3
a597 11
    if [is_remote host] {
	set arg [remote_download host $arg];
	if { $arg == "" } {
	    error "download failed"
	    return -1;
	}
    }

    send_gdb "file $arg\n"
    gdb_expect 120 {
        -re "Reading symbols from.*done.*$gdb_prompt $" {
d601 1
a601 1
        -re "has no symbol-table.*$gdb_prompt $" {
d606 1
a606 1
            send_gdb "y\n"
d611 3
a613 3
            send_gdb "y\n"
            gdb_expect 120 {
                -re "Reading symbols from.*done.*$gdb_prompt $" {
d618 2
a619 1
                    perror "(timeout) Couldn't load $arg, other program already loaded."
d624 1
a624 1
        -re "No such file or directory.*$gdb_prompt $" {
d628 1
a628 1
        -re "$gdb_prompt $" {
d639 1
a639 1
            # gdb_expect does not seem to have a way to do that.
d657 2
a658 1
    global gdb_prompt
a659 4
    global gdb_spawn_id;

    gdb_stop_suppressing_tests;

d662 3
a664 2
    if [info exists gdb_spawn_id] {
	return 0;
d666 7
a672 14

    if ![is_remote host] {
	if { [which $GDB] == 0 } then {
	    perror "$GDB does not exist."
	    exit 1
	}
    }
    set res [remote_spawn host "$GDB -nw $GDBFLAGS [host_info gdb_opts]"];
    if { $res < 0 || $res == "" } {
	perror "Spawning $GDB failed."
	return 1;
    }
    gdb_expect 360 {
	-re "\[\r\n\]$gdb_prompt $" {
d675 1
a675 1
	-re "$gdb_prompt $"	{
d677 2
d681 4
a684 3
	timeout	{
	    perror "(timeout) GDB never initialized after 10 seconds."
	    remote_close host;
d688 2
a689 1
    set gdb_spawn_id -1;
d691 3
a693 4

    send_gdb "set height 0\n"
    gdb_expect 10 {
	-re "$gdb_prompt $" { 
d697 1
a697 1
	    warning "Couldn't set the height to 0"
d701 3
a703 3
    send_gdb "set width 0\n"
    gdb_expect 10 {
	-re "$gdb_prompt $" {
a709 362
    return 0;
}

# Return a 1 for configurations for which we don't even want to try to
# test C++.

proc skip_cplus_tests {} {
    if { [istarget "d10v-*-*"] } {
	return 1
    }
    if { [istarget "h8300-*-*"] } {
	return 1
    }

    # The C++ IO streams are too large for HC11/HC12 and are thus not
    # available.  The gdb C++ tests use them and don't compile.
    if { [istarget "m6811-*-*"] } {
	return 1
    }
    if { [istarget "m6812-*-*"] } {
	return 1
    }
    return 0
}

# Skip all the tests in the file if you are not on an hppa running
# hpux target.

proc skip_hp_tests {} {
    eval set skip_hp [ expr ![isnative] || ![istarget "hppa*-*-hpux*"] ]
    verbose "Skip hp tests is $skip_hp"
    return $skip_hp
}

set compiler_info		"unknown"
set gcc_compiled		0
set hp_cc_compiler		0
set hp_aCC_compiler		0
set signed_keyword_not_used	0

# Figure out what compiler I am using.
#
# BINFILE is a "compiler information" output file.  This implementation
# does not use BINFILE.
#
# ARGS can be empty or "C++".  If empty, "C" is assumed.
#
# There are several ways to do this, with various problems.
#
# [ gdb_compile -E $ifile -o $binfile.ci ]
# source $binfile.ci
#
#   Single Unix Spec v3 says that "-E -o ..." together are not
#   specified.  And in fact, the native compiler on hp-ux 11 (among
#   others) does not work with "-E -o ...".  Most targets used to do
#   this, and it mostly worked, because it works with gcc.
#
# [ catch "exec $compiler -E $ifile > $binfile.ci" exec_output ]
# source $binfile.ci
# 
#   This avoids the problem with -E and -o together.  This almost works
#   if the build machine is the same as the host machine, which is
#   usually true of the targets which are not gcc.  But this code does
#   not figure which compiler to call, and it always ends up using the C
#   compiler.  Not good for setting hp_aCC_compiler.  Targets
#   hppa*-*-hpux* and mips*-*-irix* used to do this.
#
# [ gdb_compile -E $ifile > $binfile.ci ]
# source $binfile.ci
#
#   dejagnu target_compile says that it supports output redirection,
#   but the code is completely different from the normal path and I
#   don't want to sweep the mines from that path.  So I didn't even try
#   this.
#
# set cppout [ gdb_compile $ifile "" preprocess $args quiet ]
# eval $cppout
#
#   I actually do this for all targets now.  gdb_compile runs the right
#   compiler, and TCL captures the output, and I eval the output.
#
#   Unfortunately, expect logs the output of the command as it goes by,
#   and dejagnu helpfully prints a second copy of it right afterwards.
#   So I turn off expect logging for a moment.
#   
# [ gdb_compile $ifile $ciexe_file executable $args ]
# [ remote_exec $ciexe_file ]
# [ source $ci_file.out ]
#
#   I could give up on -E and just do this.
#   I didn't get desperate enough to try this.
#
# -- chastain 2004-01-06

proc get_compiler_info {binfile args} {
    # For compiler.c and compiler.cc
    global srcdir

    # I am going to play with the log to keep noise out.
    global outdir
    global tool

    # These come from compiler.c or compiler.cc
    global compiler_info
    global gcc_compiled
    global hp_cc_compiler
    global hp_aCC_compiler
    global signed_keyword_not_used

    # Choose which file to preprocess.
    set ifile "${srcdir}/lib/compiler.c"
    if { [llength $args] > 0 && [lindex $args 0] == "c++" } {
	set ifile "${srcdir}/lib/compiler.cc"
    }

    # Run $ifile through the right preprocessor.
    # Toggle gdb.log to keep the compiler output out of the log.
    log_file
    set cppout [ gdb_compile "${ifile}" "" preprocess [list "$args" quiet] ]
    log_file -a "$outdir/$tool.log" 

    # Source the output.
    foreach cppline [ split "$cppout" "\n" ] {
	if { ! [ regexp "^#" "$cppline" ] } {
	    if { ! [ regexp "^\[\n\r\t \]*$" "$cppline" ] } {
		verbose "get_compiler_info: $cppline" 2
		eval "$cppline"
	    }
	}
    }
    verbose -log "get_compiler_info: $compiler_info"

    # Most compilers will evaluate comparisons and other boolean
    # operations to 0 or 1.
    uplevel \#0 { set true 1 }
    uplevel \#0 { set false 0 }

    # Use of aCC results in boolean results being displayed as
    # "true" or "false"
    if { $hp_aCC_compiler } {
      uplevel \#0 { set true true }
      uplevel \#0 { set false false }
    }

    return 0;
}

proc test_compiler_info { compiler } {
    global compiler_info
    return [string match $compiler $compiler_info]
}

set gdb_wrapper_initialized 0

proc gdb_wrapper_init { args } {
    global gdb_wrapper_initialized;
    global gdb_wrapper_file;
    global gdb_wrapper_flags;

    if { $gdb_wrapper_initialized == 1 } { return; }

    if {[target_info exists needs_status_wrapper] && \
	    [target_info needs_status_wrapper] != "0"} {
	set result [build_wrapper "testglue.o"];
	if { $result != "" } {
	    set gdb_wrapper_file [lindex $result 0];
	    set gdb_wrapper_flags [lindex $result 1];
	} else {
	    warning "Status wrapper failed to build."
	}
    }
    set gdb_wrapper_initialized 1
}

proc gdb_compile {source dest type options} {
    global GDB_TESTCASE_OPTIONS;
    global gdb_wrapper_file;
    global gdb_wrapper_flags;
    global gdb_wrapper_initialized;

    if [target_info exists gdb_stub] {
	set options2 { "additional_flags=-Dusestubs" }
	lappend options "libs=[target_info gdb_stub]";
	set options [concat $options2 $options]
    }
    if [target_info exists is_vxworks] {
	set options2 { "additional_flags=-Dvxworks" }
	lappend options "libs=[target_info gdb_stub]";
	set options [concat $options2 $options]
    }
    if [info exists GDB_TESTCASE_OPTIONS] {
	lappend options "additional_flags=$GDB_TESTCASE_OPTIONS";
    }
    verbose "options are $options"
    verbose "source is $source $dest $type $options"

    if { $gdb_wrapper_initialized == 0 } { gdb_wrapper_init }

    if {[target_info exists needs_status_wrapper] && \
	    [target_info needs_status_wrapper] != "0" && \
	    [info exists gdb_wrapper_file]} {
	lappend options "libs=${gdb_wrapper_file}"
	lappend options "ldflags=${gdb_wrapper_flags}"
    }

    set result [target_compile $source $dest $type $options];
    regsub "\[\r\n\]*$" "$result" "" result;
    regsub "^\[\r\n\]*" "$result" "" result;
    if { $result != "" && [lsearch $options quiet] == -1} {
	clone_output "gdb compile failed, $result"
    }
    return $result;
}


# This is just like gdb_compile, above, except that it tries compiling
# against several different thread libraries, to see which one this
# system has.
proc gdb_compile_pthreads {source dest type options} {
    set built_binfile 0
    set why_msg "unrecognized error"
    foreach lib {-lpthreads -lpthread -lthread} {
        # This kind of wipes out whatever libs the caller may have
        # set.  Or maybe theirs will override ours.  How infelicitous.
        set options_with_lib [concat $options [list libs=$lib quiet]]
        set ccout [gdb_compile $source $dest $type $options_with_lib]
        switch -regexp -- $ccout {
            ".*no posix threads support.*" {
                set why_msg "missing threads include file"
                break
            }
            ".*cannot open -lpthread.*" {
                set why_msg "missing runtime threads library"
            }
            ".*Can't find library for -lpthread.*" {
                set why_msg "missing runtime threads library"
            }
            {^$} {
                pass "successfully compiled posix threads test case"
                set built_binfile 1
                break
            }
        }
    }
    if {!$built_binfile} {
        unsupported "Couldn't compile $source: ${why_msg}"
        return -1
    }
}

# This is just like gdb_compile_pthreads, above, except that we always add the
# objc library for compiling Objective-C programs
proc gdb_compile_objc {source dest type options} {
    set built_binfile 0
    set why_msg "unrecognized error"
    foreach lib {-lobjc -lpthreads -lpthread -lthread solaris} {
        # This kind of wipes out whatever libs the caller may have
        # set.  Or maybe theirs will override ours.  How infelicitous.
        if { $lib == "solaris" } {
            set lib "-lpthread -lposix4"
	}
        if { $lib != "-lobjc" } {
	  set lib "-lobjc $lib"
	}
        set options_with_lib [concat $options [list libs=$lib quiet]]
        set ccout [gdb_compile $source $dest $type $options_with_lib]
        switch -regexp -- $ccout {
            ".*no posix threads support.*" {
                set why_msg "missing threads include file"
                break
            }
            ".*cannot open -lpthread.*" {
                set why_msg "missing runtime threads library"
            }
            ".*Can't find library for -lpthread.*" {
                set why_msg "missing runtime threads library"
            }
            {^$} {
                pass "successfully compiled objc with posix threads test case"
                set built_binfile 1
                break
            }
        }
    }
    if {!$built_binfile} {
        unsupported "Couldn't compile $source: ${why_msg}"
        return -1
    }
}

proc send_gdb { string } {
    global suppress_flag;
    if { $suppress_flag } {
	return "suppressed";
    }
    return [remote_send host "$string"];
}

#
#

proc gdb_expect { args } {
    if { [llength $args] == 2  && [lindex $args 0] != "-re" } {
	set gtimeout [lindex $args 0];
	set expcode [list [lindex $args 1]];
    } else {
	upvar timeout timeout;

	set expcode $args;
	if [target_info exists gdb,timeout] {
	    if [info exists timeout] {
		if { $timeout < [target_info gdb,timeout] } {
		    set gtimeout [target_info gdb,timeout];
		} else {
		    set gtimeout $timeout;
		}
	    } else {
		set gtimeout [target_info gdb,timeout];
	    }
	}

	if ![info exists gtimeout] {
	    global timeout;
	    if [info exists timeout] {
		set gtimeout $timeout;
	    } else {
		# Eeeeew.
		set gtimeout 60;
	    }
	}
    }
    global suppress_flag;
    global remote_suppress_flag;
    if [info exists remote_suppress_flag] {
	set old_val $remote_suppress_flag;
    }
    if [info exists suppress_flag] {
	if { $suppress_flag } {
	    set remote_suppress_flag 1;
	}
    }
    set code [catch \
	{uplevel remote_expect host $gtimeout $expcode} string];
    if [info exists old_val] {
	set remote_suppress_flag $old_val;
    } else {
	if [info exists remote_suppress_flag] {
	    unset remote_suppress_flag;
	}
    }

    if {$code == 1} {
        global errorInfo errorCode;

	return -code error -errorinfo $errorInfo -errorcode $errorCode $string
    } elseif {$code == 2} {
	return -code return $string
    } elseif {$code == 3} {
	return
    } elseif {$code > 4} {
	return -code $code $string
    }
a711 1
# gdb_expect_list MESSAGE SENTINEL LIST -- expect a sequence of outputs
d713 8
a720 70
# Check for long sequence of output by parts.
# MESSAGE: is the test message to be printed with the test success/fail.
# SENTINEL: Is the terminal pattern indicating that output has finished.
# LIST: is the sequence of outputs to match.
# If the sentinel is recognized early, it is considered an error.
#
# Returns:
#    1 if the test failed,
#    0 if the test passes,
#   -1 if there was an internal error.
#
proc gdb_expect_list {test sentinel list} {
    global gdb_prompt
    global suppress_flag
    set index 0
    set ok 1
    if { $suppress_flag } {
	set ok 0
	unresolved "${test}"
    }
    while { ${index} < [llength ${list}] } {
	set pattern [lindex ${list} ${index}]
        set index [expr ${index} + 1]
	if { ${index} == [llength ${list}] } {
	    if { ${ok} } {
		gdb_expect {
		    -re "${pattern}${sentinel}" {
			# pass "${test}, pattern ${index} + sentinel"
		    }
		    -re "${sentinel}" {
			fail "${test} (pattern ${index} + sentinel)"
			set ok 0
		    }
		    -re ".*A problem internal to GDB has been detected" {
			fail "${test} (GDB internal error)"
			set ok 0
			gdb_internal_error_resync
		    }
		    timeout {
			fail "${test} (pattern ${index} + sentinel) (timeout)"
			set ok 0
		    }
		}
	    } else {
		# unresolved "${test}, pattern ${index} + sentinel"
	    }
	} else {
	    if { ${ok} } {
		gdb_expect {
		    -re "${pattern}" {
			# pass "${test}, pattern ${index}"
		    }
		    -re "${sentinel}" {
			fail "${test} (pattern ${index})"
			set ok 0
		    }
		    -re ".*A problem internal to GDB has been detected" {
			fail "${test} (GDB internal error)"
			set ok 0
			gdb_internal_error_resync
		    }
		    timeout {
			fail "${test} (pattern ${index}) (timeout)"
			set ok 0
		    }
		}
	    } else {
		# unresolved "${test}, pattern ${index}"
	    }
	}
a721 58
    if { ${ok} } {
	pass "${test}"
	return 0
    } else {
	return 1
    }
}

#
#
proc gdb_suppress_entire_file { reason } {
    global suppress_flag;

    warning "$reason\n";
    set suppress_flag -1;
}

#
# Set suppress_flag, which will cause all subsequent calls to send_gdb and
# gdb_expect to fail immediately (until the next call to 
# gdb_stop_suppressing_tests).
#
proc gdb_suppress_tests { args } {
    global suppress_flag;

    return;  # fnf - disable pending review of results where
             # testsuite ran better without this
    incr suppress_flag;

    if { $suppress_flag == 1 } {
	if { [llength $args] > 0 } {
	    warning "[lindex $args 0]\n";
	} else {
	    warning "Because of previous failure, all subsequent tests in this group will automatically fail.\n";
	}
    }
}

#
# Clear suppress_flag.
#
proc gdb_stop_suppressing_tests { } {
    global suppress_flag;

    if [info exists suppress_flag] {
	if { $suppress_flag > 0 } {
	    set suppress_flag 0;
	    clone_output "Tests restarted.\n";
	}
    } else {
	set suppress_flag 0;
    }
}

proc gdb_clear_suppressed { } {
    global suppress_flag;

    set suppress_flag 0;
d724 15
a738 2
proc gdb_start { } {
    default_gdb_start
a739 401

proc gdb_exit { } {
    catch default_gdb_exit
}

#
# gdb_load -- load a file into the debugger.
#             return a -1 if anything goes wrong.
#
proc gdb_load { arg } {
    return [gdb_file_cmd $arg]
}

proc gdb_continue { function } {
    global decimal

    return [gdb_test "continue" ".*Breakpoint $decimal, $function .*" "continue to $function"];
}

proc default_gdb_init { args } {
    global gdb_wrapper_initialized
    
    gdb_clear_suppressed;

    # Make sure that the wrapper is rebuilt
    # with the appropriate multilib option.
    set gdb_wrapper_initialized 0
    
    # Uh, this is lame. Really, really, really lame. But there's this *one*
    # testcase that will fail in random places if we don't increase this.
    match_max -d 20000

    # We want to add the name of the TCL testcase to the PASS/FAIL messages.
    if { [llength $args] > 0 } {
	global pf_prefix

	set file [lindex $args 0];

	set pf_prefix "[file tail [file dirname $file]]/[file tail $file]:";
    }
    global gdb_prompt;
    if [target_info exists gdb_prompt] {
	set gdb_prompt [target_info gdb_prompt];
    } else {
	set gdb_prompt "\\(gdb\\)"
    }
}

proc gdb_init { args } {
    return [eval default_gdb_init $args];
}

proc gdb_finish { } {
    gdb_exit;
}

global debug_format
set debug_format "unknown"

# Run the gdb command "info source" and extract the debugging format
# information from the output and save it in debug_format.

proc get_debug_format { } {
    global gdb_prompt
    global verbose
    global expect_out
    global debug_format

    set debug_format "unknown"
    send_gdb "info source\n"
    gdb_expect 10 {
	-re "Compiled with (.*) debugging format.\r\n.*$gdb_prompt $" {
	    set debug_format $expect_out(1,string)
	    verbose "debug format is $debug_format"
	    return 1;
	}
	-re "No current source file.\r\n$gdb_prompt $" {
	    perror "get_debug_format used when no current source file"
	    return 0;
	}
	-re "$gdb_prompt $" {
	    warning "couldn't check debug format (no valid response)."
	    return 1;
	}
	timeout {
	    warning "couldn't check debug format (timed out)."
	    return 1;
	}
    }
}

# Return true if FORMAT matches the debug format the current test was
# compiled with.  FORMAT is a shell-style globbing pattern; it can use
# `*', `[...]', and so on.
#
# This function depends on variables set by `get_debug_format', above.

proc test_debug_format {format} {
    global debug_format

    return [expr [string match $format $debug_format] != 0]
}

# Like setup_xfail, but takes the name of a debug format (DWARF 1,
# COFF, stabs, etc).  If that format matches the format that the
# current test was compiled with, then the next test is expected to
# fail for any target.  Returns 1 if the next test or set of tests is
# expected to fail, 0 otherwise (or if it is unknown).  Must have
# previously called get_debug_format.
proc setup_xfail_format { format } {
    set ret [test_debug_format $format];

    if {$ret} then {
	setup_xfail "*-*-*"
    }
    return $ret;
}

proc gdb_step_for_stub { } {
    global gdb_prompt;

    if ![target_info exists gdb,use_breakpoint_for_stub] {
	if [target_info exists gdb_stub_step_command] {
	    set command [target_info gdb_stub_step_command];
	} else {
	    set command "step";
	}
	send_gdb "${command}\n";
	set tries 0;
	gdb_expect 60 {
	    -re "(main.* at |.*in .*start).*$gdb_prompt" {
		return;
	    }
	    -re ".*$gdb_prompt" {
		incr tries;
		if { $tries == 5 } {
		    fail "stepping out of breakpoint function";
		    return;
		}
		send_gdb "${command}\n";
		exp_continue;
	    }
	    default {
		fail "stepping out of breakpoint function";
		return;
	    }
	}
    }
    send_gdb "where\n";
    gdb_expect {
	-re "main\[^\r\n\]*at \(\[^:]+\):\(\[0-9\]+\)" {
	    set file $expect_out(1,string);
	    set linenum [expr $expect_out(2,string) + 1];
	    set breakplace "${file}:${linenum}";
	}
	default {}
    }
    send_gdb "break ${breakplace}\n";
    gdb_expect 60 {
	-re "Breakpoint (\[0-9\]+) at.*$gdb_prompt" {
	    set breakpoint $expect_out(1,string);
	}
	-re "Breakpoint (\[0-9\]+): file.*$gdb_prompt" {
	    set breakpoint $expect_out(1,string);
	}
	default {}
    }
    send_gdb "continue\n";
    gdb_expect 60 {
	-re "Breakpoint ${breakpoint},.*$gdb_prompt" {
	    gdb_test "delete $breakpoint" ".*" "";
	    return;
	}
	default {}
    }
}

### gdb_get_line_number TEXT [FILE]
###
### Search the source file FILE, and return the line number of a line
### containing TEXT.  Use this function instead of hard-coding line
### numbers into your test script.
###
### Specifically, this function uses GDB's "search" command to search
### FILE for the first line containing TEXT, and returns its line
### number.  Thus, FILE must be a source file, compiled into the
### executable you are running.  If omitted, FILE defaults to the
### value of the global variable `srcfile'; most test scripts set
### `srcfile' appropriately at the top anyway.
###
### Use this function to keep your test scripts independent of the
### exact line numbering of the source file.  Don't write:
### 
###   send_gdb "break 20"
### 
### This means that if anyone ever edits your test's source file, 
### your test could break.  Instead, put a comment like this on the
### source file line you want to break at:
### 
###   /* breakpoint spot: frotz.exp: test name */
### 
### and then write, in your test script (which we assume is named
### frotz.exp):
### 
###   send_gdb "break [gdb_get_line_number "frotz.exp: test name"]\n"
###
### (Yes, Tcl knows how to handle the nested quotes and brackets.
### Try this:
### 	$ tclsh
### 	% puts "foo [lindex "bar baz" 1]"
### 	foo baz
### 	% 
### Tcl is quite clever, for a little stringy language.)

proc gdb_get_line_number {text {file /omitted/}} {
    global gdb_prompt;
    global srcfile;

    if {! [string compare $file /omitted/]} {
	set file $srcfile
    }

    set result -1;
    gdb_test "list ${file}:1,1" ".*" ""
    send_gdb "search ${text}\n"
    gdb_expect {
        -re "\[\r\n\]+(\[0-9\]+)\[ \t\].*${text}.*$gdb_prompt $" {
            set result $expect_out(1,string)
        }
        -re ".*$gdb_prompt $" {
            fail "find line number containing \"${text}\""
        }
        timeout {
            fail "find line number containing \"${text}\" (timeout)"
        }
    }
    return $result;
}

# gdb_continue_to_end:
#	The case where the target uses stubs has to be handled specially. If a
#       stub is used, we set a breakpoint at exit because we cannot rely on
#       exit() behavior of a remote target.
# 
# mssg is the error message that gets printed.

proc gdb_continue_to_end {mssg} {
  if [target_info exists use_gdb_stub] {
    if {![gdb_breakpoint "exit"]} {
      return 0
    }
    gdb_test "continue" "Continuing..*Breakpoint .*exit.*" \
      "continue until exit at $mssg"
  } else {
    # Continue until we exit.  Should not stop again.
    # Don't bother to check the output of the program, that may be
    # extremely tough for some remote systems.
    gdb_test "continue"\
      "Continuing.\[\r\n0-9\]+(... EXIT code 0\[\r\n\]+|Program exited normally\\.).*"\
      "continue until exit at $mssg"
  }
}

proc rerun_to_main {} {
  global gdb_prompt

  if [target_info exists use_gdb_stub] {
    gdb_run_cmd
    gdb_expect {
      -re ".*Breakpoint .*main .*$gdb_prompt $"\
	      {pass "rerun to main" ; return 0}
      -re "$gdb_prompt $"\
	      {fail "rerun to main" ; return 0}
      timeout {fail "(timeout) rerun to main" ; return 0}
    }
  } else {
    send_gdb "run\n"
    gdb_expect {
      -re "The program .* has been started already.*y or n. $" {
	  send_gdb "y\n"
	  exp_continue
      }
      -re "Starting program.*$gdb_prompt $"\
	      {pass "rerun to main" ; return 0}
      -re "$gdb_prompt $"\
	      {fail "rerun to main" ; return 0}
      timeout {fail "(timeout) rerun to main" ; return 0}
    }
  }
}

# Print a message and return true if a test should be skipped
# due to lack of floating point suport.

proc gdb_skip_float_test { msg } {
    if [target_info exists gdb,skip_float_tests] {
	verbose "Skipping test '$msg': no float tests.";
	return 1;
    }
    return 0;
}

# Print a message and return true if a test should be skipped
# due to lack of stdio support.

proc gdb_skip_stdio_test { msg } {
    if [target_info exists gdb,noinferiorio] {
	verbose "Skipping test '$msg': no inferior i/o.";
	return 1;
    }
    return 0;
}

proc gdb_skip_bogus_test { msg } {
    return 0;
}


# Note: the procedure gdb_gnu_strip_debug will produce an executable called
# ${binfile}.dbglnk, which is just like the executable ($binfile) but without
# the debuginfo. Instead $binfile has a .gnu_debuglink section which contains
# the name of a idebuginfo only file. This file will be stored in the 
# gdb.base/.debug subdirectory.

# Functions for separate debug info testing

# starting with an executable:
# foo --> original executable

# at the end of the process we have:
# foo.stripped --> foo w/o debug info
# .debug/foo.debug --> foo's debug info
# foo --> like foo, but with a new .gnu_debuglink section pointing to foo.debug.

# Return the name of the file in which we should stor EXEC's separated
# debug info. EXEC contains the full path.
proc separate_debug_filename { exec } {

    # In a .debug subdirectory off the same directory where the testcase
    # executable is going to be. Something like:
    # <your-path>/gdb/testsuite/gdb.base/.debug/blah.debug.
    # This is the default location where gdb expects to findi
    # the debug info file.

    set exec_dir [file dirname $exec]
    set exec_file [file tail $exec]
    set debug_dir [file join $exec_dir ".debug"]
    set debug_file [file join $debug_dir "${exec_file}.debug"]

    return $debug_file
}


proc gdb_gnu_strip_debug { dest } {

    set debug_file [separate_debug_filename $dest]
    set strip_to_file_program strip
    set objcopy_program objcopy

    # Make sure the directory that will hold the separated debug
    # info actually exists.
    set debug_dir [file dirname $debug_file]
    if {! [file isdirectory $debug_dir]} {
	file mkdir $debug_dir
    }

    set debug_link [file tail $debug_file]
    set stripped_file "${dest}.stripped"

    # Get rid of the debug info, and store result in stripped_file
    # something like gdb/testsuite/gdb.base/blah.stripped.
    set result [catch "exec $strip_to_file_program --strip-debug ${dest} -o ${stripped_file}" output]
    verbose "result is $result"
    verbose "output is $output"
    if {$result == 1} {
      return 1
    }

    # Get rid of everything but the debug info, and store result in debug_file
    # This will be in the .debug subdirectory, see above.
    set result [catch "exec $strip_to_file_program --only-keep-debug ${dest} -o ${debug_file}" output]
    verbose "result is $result"
    verbose "output is $output"
    if {$result == 1} {
      return 1
    }

    # Link the two previous output files together, adding the .gnu_debuglink
    # section to the stripped_file, containing a pointer to the debug_file,
    # save the new file in dest.
    # This will be the regular executable filename, in the usual location.
    set result [catch "exec $objcopy_program --add-gnu-debuglink=${debug_file} ${stripped_file} ${dest}" output]
    verbose "result is $result"
    verbose "output is $output"
    if {$result == 1} {
      return 1
    }

   return 0
}

@

