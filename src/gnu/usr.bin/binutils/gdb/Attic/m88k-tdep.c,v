head	1.2;
access;
symbols
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.08.11.21.10.22;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.40.14;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.03.22.17.40.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.28.33;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove old binutils
@
text
@/* Target-machine dependent code for Motorola 88000 series, for GDB.
   Copyright 1988, 1990, 1991, 1994, 1995 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "value.h"
#include "gdbcore.h"
#include "symtab.h"
#include "setjmp.h"
#include "value.h"

/* Size of an instruction */
#define	BYTES_PER_88K_INSN	4

void frame_find_saved_regs ();

/* Is this target an m88110?  Otherwise assume m88100.  This has
   relevance for the ways in which we screw with instruction pointers.  */

int target_is_m88110 = 0;

/* Given a GDB frame, determine the address of the calling function's frame.
   This will be used to create a new GDB frame struct, and then
   INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.

   For us, the frame address is its stack pointer value, so we look up
   the function prologue to determine the caller's sp value, and return it.  */

CORE_ADDR
frame_chain (thisframe)
     struct frame_info *thisframe;
{

  frame_find_saved_regs (thisframe, (struct frame_saved_regs *) 0);
  /* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not
 	    the ADDRESS, of SP_REGNUM.  It also depends on the cache of
	    frame_find_saved_regs results.  */
  if (thisframe->fsr->regs[SP_REGNUM])
    return thisframe->fsr->regs[SP_REGNUM];
  else
    return thisframe->frame;	/* Leaf fn -- next frame up has same SP. */
}

int
frameless_function_invocation (frame)
     struct frame_info *frame;
{

  frame_find_saved_regs (frame, (struct frame_saved_regs *) 0);
  /* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not
 	    the ADDRESS, of SP_REGNUM.  It also depends on the cache of
	    frame_find_saved_regs results.  */
  if (frame->fsr->regs[SP_REGNUM])
    return 0;			/* Frameful -- return addr saved somewhere */
  else
    return 1;			/* Frameless -- no saved return address */
}

void
init_extra_frame_info (fromleaf, frame)
     int fromleaf;
     struct frame_info *frame;
{
  frame->fsr = 0;			/* Not yet allocated */
  frame->args_pointer = 0;		/* Unknown */
  frame->locals_pointer = 0;	/* Unknown */
}

/* Examine an m88k function prologue, recording the addresses at which
   registers are saved explicitly by the prologue code, and returning
   the address of the first instruction after the prologue (but not
   after the instruction at address LIMIT, as explained below).

   LIMIT places an upper bound on addresses of the instructions to be
   examined.  If the prologue code scan reaches LIMIT, the scan is
   aborted and LIMIT is returned.  This is used, when examining the
   prologue for the current frame, to keep examine_prologue () from
   claiming that a given register has been saved when in fact the
   instruction that saves it has not yet been executed.  LIMIT is used
   at other times to stop the scan when we hit code after the true
   function prologue (e.g. for the first source line) which might
   otherwise be mistaken for function prologue.

   The format of the function prologue matched by this routine is
   derived from examination of the source to gcc 1.95, particularly
   the routine output_prologue () in config/out-m88k.c.

   subu r31,r31,n			# stack pointer update

   (st rn,r31,offset)?			# save incoming regs
   (st.d rn,r31,offset)?

   (addu r30,r31,n)?			# frame pointer update

   (pic sequence)?			# PIC code prologue

   (or   rn,rm,0)?			# Move parameters to other regs
*/

/* Macros for extracting fields from instructions.  */

#define BITMASK(pos, width) (((0x1 << (width)) - 1) << (pos))
#define EXTRACT_FIELD(val, pos, width) ((val) >> (pos) & BITMASK (0, width))
#define	SUBU_OFFSET(x)	((unsigned)(x & 0xFFFF))
#define	ST_OFFSET(x)	((unsigned)((x) & 0xFFFF))
#define	ST_SRC(x)	EXTRACT_FIELD ((x), 21, 5)
#define	ADDU_OFFSET(x)	((unsigned)(x & 0xFFFF))

/*
 * prologue_insn_tbl is a table of instructions which may comprise a
 * function prologue.  Associated with each table entry (corresponding
 * to a single instruction or group of instructions), is an action.
 * This action is used by examine_prologue (below) to determine
 * the state of certain machine registers and where the stack frame lives.
 */

enum prologue_insn_action {
  PIA_SKIP,			/* don't care what the instruction does */
  PIA_NOTE_ST,			/* note register stored and where */
  PIA_NOTE_STD,			/* note pair of registers stored and where */
  PIA_NOTE_SP_ADJUSTMENT,	/* note stack pointer adjustment */
  PIA_NOTE_FP_ASSIGNMENT,	/* note frame pointer assignment */
  PIA_NOTE_PROLOGUE_END,	/* no more prologue */
};

struct prologue_insns {
    unsigned long insn;
    unsigned long mask;
    enum prologue_insn_action action;
};

struct prologue_insns prologue_insn_tbl[] = {
  /* Various register move instructions */
  { 0x58000000, 0xf800ffff, PIA_SKIP },		/* or/or.u with immed of 0 */
  { 0xf4005800, 0xfc1fffe0, PIA_SKIP },		/* or rd, r0, rs */
  { 0xf4005800, 0xfc00ffff, PIA_SKIP },		/* or rd, rs, r0 */

  /* Stack pointer setup: "subu sp, sp, n" where n is a multiple of 8 */
  { 0x67ff0000, 0xffff0007, PIA_NOTE_SP_ADJUSTMENT },

  /* Frame pointer assignment: "addu r30, r31, n" */
  { 0x63df0000, 0xffff0000, PIA_NOTE_FP_ASSIGNMENT },

  /* Store to stack instructions; either "st rx, sp, n" or "st.d rx, sp, n" */
  { 0x241f0000, 0xfc1f0000, PIA_NOTE_ST },	/* st rx, sp, n */
  { 0x201f0000, 0xfc1f0000, PIA_NOTE_STD },	/* st.d rs, sp, n */

  /* Instructions needed for setting up r25 for pic code. */
  { 0x5f200000, 0xffff0000, PIA_SKIP },		/* or.u r25, r0, offset_high */
  { 0xcc000002, 0xffffffff, PIA_SKIP },		/* bsr.n Lab */
  { 0x5b390000, 0xffff0000, PIA_SKIP },		/* or r25, r25, offset_low */
  { 0xf7396001, 0xffffffff, PIA_SKIP },		/* Lab: addu r25, r25, r1 */

  /* Various branch or jump instructions which have a delay slot -- these
     do not form part of the prologue, but the instruction in the delay
     slot might be a store instruction which should be noted. */
  { 0xc4000000, 0xe4000000, PIA_NOTE_PROLOGUE_END }, 
  					/* br.n, bsr.n, bb0.n, or bb1.n */
  { 0xec000000, 0xfc000000, PIA_NOTE_PROLOGUE_END }, /* bcnd.n */
  { 0xf400c400, 0xfffff7e0, PIA_NOTE_PROLOGUE_END } /* jmp.n or jsr.n */

};


/* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
   is not the address of a valid instruction, the address of the next
   instruction beyond ADDR otherwise.  *PWORD1 receives the first word
   of the instruction. */

#define NEXT_PROLOGUE_INSN(addr, lim, pword1) \
  (((addr) < (lim)) ? next_insn (addr, pword1) : 0)

/* Read the m88k instruction at 'memaddr' and return the address of 
   the next instruction after that, or 0 if 'memaddr' is not the
   address of a valid instruction.  The instruction
   is stored at 'pword1'.  */

CORE_ADDR
next_insn (memaddr, pword1)
     unsigned long *pword1;
     CORE_ADDR memaddr;
{
  *pword1 = read_memory_integer (memaddr, BYTES_PER_88K_INSN);
  return memaddr + BYTES_PER_88K_INSN;
}

/* Read a register from frames called by us (or from the hardware regs).  */

static int
read_next_frame_reg(frame, regno)
     struct frame_info *frame;
     int regno;
{
  for (; frame; frame = frame->next) {
      if (regno == SP_REGNUM)
	return FRAME_FP (frame);
      else if (frame->fsr->regs[regno])
	return read_memory_integer(frame->fsr->regs[regno], 4);
  }
  return read_register(regno);
}

/* Examine the prologue of a function.  `ip' points to the first instruction.
   `limit' is the limit of the prologue (e.g. the addr of the first 
   linenumber, or perhaps the program counter if we're stepping through).
   `frame_sp' is the stack pointer value in use in this frame.  
   `fsr' is a pointer to a frame_saved_regs structure into which we put
   info about the registers saved by this frame.  
   `fi' is a struct frame_info pointer; we fill in various fields in it
   to reflect the offsets of the arg pointer and the locals pointer.  */

static CORE_ADDR
examine_prologue (ip, limit, frame_sp, fsr, fi)
     register CORE_ADDR ip;
     register CORE_ADDR limit;
     CORE_ADDR frame_sp;
     struct frame_saved_regs *fsr;
     struct frame_info *fi;
{
  register CORE_ADDR next_ip;
  register int src;
  unsigned int insn;
  int size, offset;
  char must_adjust[32];		/* If set, must adjust offsets in fsr */
  int sp_offset = -1;		/* -1 means not set (valid must be mult of 8) */
  int fp_offset = -1;		/* -1 means not set */
  CORE_ADDR frame_fp;
  CORE_ADDR prologue_end = 0;

  memset (must_adjust, '\0', sizeof (must_adjust));
  next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn);

  while (next_ip)
    {
      struct prologue_insns *pip; 

      for (pip=prologue_insn_tbl; (insn & pip->mask) != pip->insn; )
	  if (++pip >= prologue_insn_tbl + sizeof prologue_insn_tbl)
	      goto end_of_prologue_found;	/* not a prologue insn */

      switch (pip->action)
	{
	  case PIA_NOTE_ST:
	  case PIA_NOTE_STD:
	    if (sp_offset != -1) {
		src = ST_SRC (insn);
		offset = ST_OFFSET (insn);
		must_adjust[src] = 1;
		fsr->regs[src++] = offset;	/* Will be adjusted later */
		if (pip->action == PIA_NOTE_STD && src < 32)
		  {
		    offset += 4;
		    must_adjust[src] = 1;
		    fsr->regs[src++] = offset;
		  }
	    }
	    else
		goto end_of_prologue_found;
	    break;
	  case PIA_NOTE_SP_ADJUSTMENT:
	    if (sp_offset == -1)
		sp_offset = -SUBU_OFFSET (insn);
	    else
		goto end_of_prologue_found;
	    break;
	  case PIA_NOTE_FP_ASSIGNMENT:
	    if (fp_offset == -1)
		fp_offset = ADDU_OFFSET (insn);
	    else
		goto end_of_prologue_found;
	    break;
	  case PIA_NOTE_PROLOGUE_END:
	    if (!prologue_end)
		prologue_end = ip;
	    break;
	  case PIA_SKIP:
	  default :
	    /* Do nothing */
	    break;
	}

      ip = next_ip;
      next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn);
    }

end_of_prologue_found:

    if (prologue_end)
	ip = prologue_end;

  /* We're done with the prologue.  If we don't care about the stack
     frame itself, just return.  (Note that fsr->regs has been trashed,
     but the one caller who calls with fi==0 passes a dummy there.)  */

  if (fi == 0)
    return ip;

  /*
     OK, now we have:

     	sp_offset	original (before any alloca calls) displacement of SP
			(will be negative).

	fp_offset	displacement from original SP to the FP for this frame
			or -1.

	fsr->regs[0..31]	displacement from original SP to the stack
				location where reg[0..31] is stored.

	must_adjust[0..31]	set if corresponding offset was set.

     If alloca has been called between the function prologue and the current
     IP, then the current SP (frame_sp) will not be the original SP as set by
     the function prologue.  If the current SP is not the original SP, then the
     compiler will have allocated an FP for this frame, fp_offset will be set,
     and we can use it to calculate the original SP.

     Then, we figure out where the arguments and locals are, and relocate the
     offsets in fsr->regs to absolute addresses.  */

  if (fp_offset != -1) {
    /* We have a frame pointer, so get it, and base our calc's on it.  */
    frame_fp = (CORE_ADDR) read_next_frame_reg (fi->next, ACTUAL_FP_REGNUM);
    frame_sp = frame_fp - fp_offset;
  } else {
    /* We have no frame pointer, therefore frame_sp is still the same value
       as set by prologue.  But where is the frame itself?  */
    if (must_adjust[SRP_REGNUM]) {
      /* Function header saved SRP (r1), the return address.  Frame starts
	 4 bytes down from where it was saved.  */
      frame_fp = frame_sp + fsr->regs[SRP_REGNUM] - 4;
      fi->locals_pointer = frame_fp;
    } else {
      /* Function header didn't save SRP (r1), so we are in a leaf fn or
	 are otherwise confused.  */
      frame_fp = -1;
    }
  }

  /* The locals are relative to the FP (whether it exists as an allocated
     register, or just as an assumed offset from the SP) */
  fi->locals_pointer = frame_fp;

  /* The arguments are just above the SP as it was before we adjusted it
     on entry.  */
  fi->args_pointer = frame_sp - sp_offset;

  /* Now that we know the SP value used by the prologue, we know where
     it saved all the registers.  */
  for (src = 0; src < 32; src++)
    if (must_adjust[src])
      fsr->regs[src] += frame_sp;
 
  /* The saved value of the SP is always known.  */
  /* (we hope...) */
  if (fsr->regs[SP_REGNUM] != 0 
   && fsr->regs[SP_REGNUM] != frame_sp - sp_offset)
    fprintf_unfiltered(gdb_stderr, "Bad saved SP value %x != %x, offset %x!\n",
        fsr->regs[SP_REGNUM],
	frame_sp - sp_offset, sp_offset);

  fsr->regs[SP_REGNUM] = frame_sp - sp_offset;

  return (ip);
}

/* Given an ip value corresponding to the start of a function,
   return the ip of the first instruction after the function 
   prologue.  */

CORE_ADDR
skip_prologue (ip)
     CORE_ADDR (ip);
{
  struct frame_saved_regs saved_regs_dummy;
  struct symtab_and_line sal;
  CORE_ADDR limit;

  sal = find_pc_line (ip, 0);
  limit = (sal.end) ? sal.end : 0xffffffff;

  return (examine_prologue (ip, limit, (CORE_ADDR) 0, &saved_regs_dummy,
			    (struct frame_info *)0 ));
}

/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.

   We cache the result of doing this in the frame_cache_obstack, since
   it is fairly expensive.  */

void
frame_find_saved_regs (fi, fsr)
     struct frame_info *fi;
     struct frame_saved_regs *fsr;
{
  register struct frame_saved_regs *cache_fsr;
  extern struct obstack frame_cache_obstack;
  CORE_ADDR ip;
  struct symtab_and_line sal;
  CORE_ADDR limit;

  if (!fi->fsr)
    {
      cache_fsr = (struct frame_saved_regs *)
		  obstack_alloc (&frame_cache_obstack,
				 sizeof (struct frame_saved_regs));
      memset (cache_fsr, '\0', sizeof (struct frame_saved_regs));
      fi->fsr = cache_fsr;

      /* Find the start and end of the function prologue.  If the PC
	 is in the function prologue, we only consider the part that
	 has executed already.  In the case where the PC is not in
	 the function prologue, we set limit to two instructions beyond
	 where the prologue ends in case if any of the prologue instructions
	 were moved into a delay slot of a branch instruction. */
         
      ip = get_pc_function_start (fi->pc);
      sal = find_pc_line (ip, 0);
      limit = (sal.end && sal.end < fi->pc) ? sal.end + 2 * BYTES_PER_88K_INSN 
					    : fi->pc;

      /* This will fill in fields in *fi as well as in cache_fsr.  */
#ifdef SIGTRAMP_FRAME_FIXUP
      if (fi->signal_handler_caller)
	SIGTRAMP_FRAME_FIXUP(fi->frame);
#endif
      examine_prologue (ip, limit, fi->frame, cache_fsr, fi);
#ifdef SIGTRAMP_SP_FIXUP
      if (fi->signal_handler_caller && fi->fsr->regs[SP_REGNUM])
	SIGTRAMP_SP_FIXUP(fi->fsr->regs[SP_REGNUM]);
#endif
    }

  if (fsr)
    *fsr = *fi->fsr;
}

/* Return the address of the locals block for the frame
   described by FI.  Returns 0 if the address is unknown.
   NOTE!  Frame locals are referred to by negative offsets from the
   argument pointer, so this is the same as frame_args_address().  */

CORE_ADDR
frame_locals_address (fi)
     struct frame_info *fi;
{
  struct frame_saved_regs fsr;

  if (fi->args_pointer)	/* Cached value is likely there.  */
    return fi->args_pointer;

  /* Nope, generate it.  */

  get_frame_saved_regs (fi, &fsr);

  return fi->args_pointer;
}

/* Return the address of the argument block for the frame
   described by FI.  Returns 0 if the address is unknown.  */

CORE_ADDR
frame_args_address (fi)
     struct frame_info *fi;
{
  struct frame_saved_regs fsr;

  if (fi->args_pointer)		/* Cached value is likely there.  */
    return fi->args_pointer;

  /* Nope, generate it.  */

  get_frame_saved_regs (fi, &fsr);

  return fi->args_pointer;
}

/* Return the saved PC from this frame.

   If the frame has a memory copy of SRP_REGNUM, use that.  If not,
   just use the register SRP_REGNUM itself.  */

CORE_ADDR
frame_saved_pc (frame)
     struct frame_info *frame;
{
  return read_next_frame_reg(frame, SRP_REGNUM);
}


#define DUMMY_FRAME_SIZE 192

static void
write_word (sp, word)
     CORE_ADDR sp;
     unsigned LONGEST word;
{
  register int len = REGISTER_SIZE;
  char buffer[MAX_REGISTER_RAW_SIZE];

  store_unsigned_integer (buffer, len, word);
  write_memory (sp, buffer, len);
}

void
m88k_push_dummy_frame()
{
  register CORE_ADDR sp = read_register (SP_REGNUM);
  register int rn;
  int offset;

  sp -= DUMMY_FRAME_SIZE;	/* allocate a bunch of space */

  for (rn = 0, offset = 0; rn <= SP_REGNUM; rn++, offset+=4)
    write_word (sp+offset, read_register(rn));
  
  write_word (sp+offset, read_register (SXIP_REGNUM));
  offset += 4;

  write_word (sp+offset, read_register (SNIP_REGNUM));
  offset += 4;

  write_word (sp+offset, read_register (SFIP_REGNUM));
  offset += 4;

  write_word (sp+offset, read_register (PSR_REGNUM));
  offset += 4;

  write_word (sp+offset, read_register (FPSR_REGNUM));
  offset += 4;

  write_word (sp+offset, read_register (FPCR_REGNUM));
  offset += 4;

  write_register (SP_REGNUM, sp);
  write_register (ACTUAL_FP_REGNUM, sp);
}

void
pop_frame ()
{
  register struct frame_info *frame = get_current_frame ();
  register CORE_ADDR fp;
  register int regnum;
  struct frame_saved_regs fsr;

  fp = FRAME_FP (frame);
  get_frame_saved_regs (frame, &fsr);

  if (PC_IN_CALL_DUMMY (read_pc (), read_register (SP_REGNUM), FRAME_FP (fi)))
    {
      /* FIXME: I think get_frame_saved_regs should be handling this so
	 that we can deal with the saved registers properly (e.g. frame
	 1 is a call dummy, the user types "frame 2" and then "print $ps").  */
      register CORE_ADDR sp = read_register (ACTUAL_FP_REGNUM);
      int offset;

      for (regnum = 0, offset = 0; regnum <= SP_REGNUM; regnum++, offset+=4)
	(void) write_register (regnum, read_memory_integer (sp+offset, 4));
  
      write_register (SXIP_REGNUM, read_memory_integer (sp+offset, 4));
      offset += 4;

      write_register (SNIP_REGNUM, read_memory_integer (sp+offset, 4));
      offset += 4;

      write_register (SFIP_REGNUM, read_memory_integer (sp+offset, 4));
      offset += 4;

      write_register (PSR_REGNUM, read_memory_integer (sp+offset, 4));
      offset += 4;

      write_register (FPSR_REGNUM, read_memory_integer (sp+offset, 4));
      offset += 4;

      write_register (FPCR_REGNUM, read_memory_integer (sp+offset, 4));
      offset += 4;

    }
  else 
    {
      for (regnum = FP_REGNUM ; regnum > 0 ; regnum--)
	  if (fsr.regs[regnum])
	      write_register (regnum,
			      read_memory_integer (fsr.regs[regnum], 4));
      write_pc (frame_saved_pc (frame));
    }
  reinit_frame_cache ();
}

void
_initialize_m88k_tdep ()
{
  tm_print_insn = print_insn_m88k;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d1 2
a2 1
/* Target-dependent code for the Motorola 88000 series.
d4 1
a4 1
   Copyright 2004 Free Software Foundation, Inc.
d6 13
a18 16
   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
a20 2
#include "arch-utils.h"
#include "dis-asm.h"
d22 2
a23 2
#include "frame-base.h"
#include "frame-unwind.h"
a24 3
#include "gdbtypes.h"
#include "regcache.h"
#include "regset.h"
d26 1
a26 1
#include "trad-frame.h"
d29 2
a30 2
#include "gdb_assert.h"
#include "gdb_string.h"
d32 1
a32 1
#include "m88k-tdep.h"
d34 2
a35 1
/* Fetch the instruction at PC.  */
d37 1
a37 5
static unsigned long
m88k_fetch_instruction (CORE_ADDR pc)
{
  return read_memory_unsigned_integer (pc, 4);
}
d39 3
a41 1
/* Register information.  */
d43 2
a44 1
/* Return the name of register REGNUM.  */
d46 3
a48 2
static const char *
m88k_register_name (int regnum)
a49 8
  static char *register_names[] =
  {
    "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",
    "epsr", "fpsr", "fpcr", "sxip", "snip", "sfip"
  };
d51 8
a58 4
  if (regnum >= 0 && regnum < ARRAY_SIZE (register_names))
    return register_names[regnum];

  return NULL;
d61 3
a63 5
/* Return the GDB type object for the "standard" data type of data in
   register REGNUM. */

static struct type *
m88k_register_type (struct gdbarch *gdbarch, int regnum)
a64 4
  /* SXIP, SNIP, SFIP and R1 contain code addresses.  */
  if ((regnum >= M88K_SXIP_REGNUM && regnum <= M88K_SFIP_REGNUM)
      || regnum == M88K_R1_REGNUM)
    return builtin_type_void_func_ptr;
d66 9
a74 3
  /* R30 and R31 typically contains data addresses.  */
  if (regnum == M88K_R30_REGNUM || regnum == M88K_R31_REGNUM)
    return builtin_type_void_data_ptr;
d76 8
a83 1
  return builtin_type_int32;
d86 23
d110 1
a110 20
static CORE_ADDR
m88k_addr_bits_remove (CORE_ADDR addr)
{
  /* All instructures are 4-byte aligned.  The lower 2 bits of SXIP,
     SNIP and SFIP are used for special purposes: bit 0 is the
     exception bit and bit 1 is the valid bit.  */
  return addr & ~0x3;
}

/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.  */
   
static const unsigned char *
m88k_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  /* tb 0,r0,511 */
  static unsigned char break_insn[] = { 0xf0, 0x00, 0xd1, 0xff };
d112 1
a112 3
  *len = sizeof (break_insn);
  return break_insn;
}
d114 2
a115 4
static CORE_ADDR
m88k_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  CORE_ADDR pc;
d117 1
a117 3
  pc = frame_unwind_register_unsigned (next_frame, M88K_SXIP_REGNUM);
  return m88k_addr_bits_remove (pc);
}
d119 6
a124 5
static void
m88k_write_pc (CORE_ADDR pc, ptid_t ptid)
{
  /* According to the MC88100 RISC Microprocessor User's Manual,
     section 6.4.3.1.2:
d126 16
a141 18
     "... can be made to return to a particular instruction by placing
     a valid instruction address in the SNIP and the next sequential
     instruction address in the SFIP (with V bits set and E bits
     clear).  The rte resumes execution at the instruction pointed to
     by the SNIP, then the SFIP."

     The E bit is the least significant bit (bit 0).  The V (valid)
     bit is bit 1.  This is why we logical or 2 into the values we are
     writing below.  It turns out that SXIP plays no role when
     returning from an exception so nothing special has to be done
     with it.  We could even (presumably) give it a totally bogus
     value.  */

  write_register_pid (M88K_SXIP_REGNUM, pc, ptid);
  write_register_pid (M88K_SNIP_REGNUM, pc | 2, ptid);
  write_register_pid (M88K_SFIP_REGNUM, (pc + 4) | 2, ptid);
}

d143 5
a147 2
/* The functions on this page are intended to be used to classify
   function arguments.  */
d149 29
a177 1
/* Check whether TYPE is "Integral or Pointer".  */
d179 1
a179 27
static int
m88k_integral_or_pointer_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_RANGE:
      {
	/* We have byte, half-word, word and extended-word/doubleword
           integral types.  */
	int len = TYPE_LENGTH (type);
	return (len == 1 || len == 2 || len == 4 || len == 8);
      }
      return 1;
    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      {
	/* Allow only 32-bit pointers.  */
	return (TYPE_LENGTH (type) == 4);
      }
      return 1;
    default:
      break;
    }
a180 2
  return 0;
}
d182 4
a185 1
/* Check whether TYPE is "Floating".  */
d187 2
a188 13
static int
m88k_floating_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_FLT:
      {
	int len = TYPE_LENGTH (type);
	return (len == 4 || len == 8);
      }
    default:
      break;
    }
d190 4
a193 2
  return 0;
}
d195 4
a198 4
/* Check whether TYPE is "Structure or Union".  */

static int
m88k_structure_or_union_p (const struct type *type)
d200 2
a201 10
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      return 1;
    default:
      break;
    }

  return 0;
d204 1
a204 1
/* Check whether TYPE has 8-byte alignment.  */
d207 11
a217 19
m88k_8_byte_align_p (struct type *type)
{
  if (m88k_structure_or_union_p (type))
    {
      int i;

      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));

	  if (m88k_8_byte_align_p (subtype))
	    return 1;
	}
    }

  if (m88k_integral_or_pointer_p (type) || m88k_floating_p (type))
    return (TYPE_LENGTH (type) == 8);

  return 0;
d220 8
a227 13
/* Check whether TYPE can be passed in a register.  */

static int
m88k_in_register_p (struct type *type)
{
  if (m88k_integral_or_pointer_p (type) || m88k_floating_p (type))
    return 1;

  if (m88k_structure_or_union_p (type) && TYPE_LENGTH (type) == 4)
    return 1;

  return 0;
}
d230 27
a256 18
m88k_store_arguments (struct regcache *regcache, int nargs,
		      struct value **args, CORE_ADDR sp)
{
  int num_register_words = 0;
  int num_stack_words = 0;
  int i;

  for (i = 0; i < nargs; i++)
    {
      struct type *type = VALUE_TYPE (args[i]);
      int len = TYPE_LENGTH (type);

      if (m88k_integral_or_pointer_p (type) && len < 4)
	{
	  args[i] = value_cast (builtin_type_int32, args[i]);
	  type = VALUE_TYPE (args[i]);
	  len = TYPE_LENGTH (type);
	}
d258 1
a258 1
      if (m88k_in_register_p (type))
d260 13
a272 10
	  int num_words = 0;

	  if (num_register_words % 2 == 1 && m88k_8_byte_align_p (type))
	    num_words++;

	  num_words += ((len + 3) / 4);
	  if (num_register_words + num_words <= 8)
	    {
	      num_register_words += num_words;
	      continue;
d274 23
a296 3

	  /* We've run out of available registers.  Pass the argument
             on the stack.  */
d299 2
a300 4
      if (num_stack_words % 2 == 1 && m88k_8_byte_align_p (type))
	num_stack_words++;

      num_stack_words += ((len + 3) / 4);
d303 1
a303 3
  /* Allocate stack space.  */
  sp = align_down (sp - 32 - num_stack_words * 4, 16);
  num_stack_words = num_register_words = 0;
d305 2
a306 10
  for (i = 0; i < nargs; i++)
    {
      char *valbuf = VALUE_CONTENTS (args[i]);
      struct type *type = VALUE_TYPE (args[i]);
      int len = TYPE_LENGTH (type);
      int stack_word = num_stack_words;

      if (m88k_in_register_p (type))
	{
	  int register_word = num_register_words;
d308 46
a353 23
	  if (register_word % 2 == 1 && m88k_8_byte_align_p (type))
	    register_word++;

	  gdb_assert (len == 4 || len == 8);

	  if (register_word + len / 8 < 8)
	    {
	      int regnum = M88K_R2_REGNUM + register_word;

	      regcache_raw_write (regcache, regnum, valbuf);
	      if (len > 4)
		regcache_raw_write (regcache, regnum + 1, valbuf + 4);

	      num_register_words = (register_word + len / 4);
	      continue;
	    }
	}

      if (stack_word % 2 == -1 && m88k_8_byte_align_p (type))
	stack_word++;

      write_memory (sp + stack_word * 4, valbuf, len);
      num_stack_words = (stack_word + (len + 3) / 4);
d355 1
d357 21
a377 12
  return sp;
}

static CORE_ADDR
m88k_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
{
  /* Set up the function arguments.  */
  sp = m88k_store_arguments (regcache, nargs, args, sp);
  gdb_assert (sp % 16 == 0);
d379 1
a379 3
  /* Store return value address.  */
  if (struct_return)
    regcache_raw_write_unsigned (regcache, M88K_R12_REGNUM, struct_addr);
d381 1
a381 7
  /* Store the stack pointer and return address in the appropriate
     registers.  */
  regcache_raw_write_unsigned (regcache, M88K_R31_REGNUM, sp);
  regcache_raw_write_unsigned (regcache, M88K_R1_REGNUM, bp_addr);

  /* Return the stack pointer.  */
  return sp;
d384 3
a386 9
static struct frame_id
m88k_unwind_dummy_id (struct gdbarch *arch, struct frame_info *next_frame)
{
  CORE_ADDR sp;

  sp = frame_unwind_register_unsigned (next_frame, M88K_R31_REGNUM);
  return frame_id_build (sp, frame_pc_unwind (next_frame));
}

d388 3
a390 10
/* Determine, for architecture GDBARCH, how a return value of TYPE
   should be returned.  If it is supposed to be returned in registers,
   and READBUF is non-zero, read the appropriate value from REGCACHE,
   and copy it into READBUF.  If WRITEBUF is non-zero, write the value
   from WRITEBUF into REGCACHE.  */

static enum return_value_convention
m88k_return_value (struct gdbarch *gdbarch, struct type *type,
		   struct regcache *regcache, void *readbuf,
		   const void *writebuf)
d392 3
a394 5
  int len = TYPE_LENGTH (type);
  char buf[8];

  if (!m88k_integral_or_pointer_p (type) && !m88k_floating_p (type))
    return RETURN_VALUE_STRUCT_CONVENTION;
d396 2
a397 34
  if (readbuf)
    {
      /* Read the contents of R2 and (if necessary) R3.  */
      regcache_cooked_read (regcache, M88K_R2_REGNUM, buf);
      if (len > 4)
	{
	  regcache_cooked_read (regcache, M88K_R3_REGNUM, buf + 4);
	  gdb_assert (len == 8);
	  memcpy (readbuf, buf, len);
	}
      else
	{
	  /* Just stripping off any unused bytes should preserve the
             signed-ness just fine.  */
	  memcpy (readbuf, buf + 4 - len, len);
	}
    }

  if (writebuf)
    {
      /* Read the contents to R2 and (if necessary) R3.  */
      if (len > 4)
	{
	  gdb_assert (len == 8);
	  memcpy (buf, writebuf, 8);
	  regcache_cooked_write (regcache, M88K_R3_REGNUM, buf + 4);
	}
      else
	{
	  /* ??? Do we need to do any sign-extension here?  */
	  memcpy (buf + 4 - len, writebuf, len);
	}
      regcache_cooked_write (regcache, M88K_R2_REGNUM, buf);
    }
d399 2
a400 1
  return RETURN_VALUE_REGISTER_CONVENTION;
a401 2

/* Default frame unwinder.  */
d403 5
a407 5
struct m88k_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR pc;
d409 2
a410 2
  int sp_offset;
  int fp_offset;
d412 10
a421 72
  /* Table of saved registers.  */
  struct trad_frame_saved_reg *saved_regs;
};

/* Prologue analysis.  */

/* Macros for extracting fields from instructions.  */

#define BITMASK(pos, width) (((0x1 << (width)) - 1) << (pos))
#define EXTRACT_FIELD(val, pos, width) ((val) >> (pos) & BITMASK (0, width))
#define	SUBU_OFFSET(x)	((unsigned)(x & 0xFFFF))
#define	ST_OFFSET(x)	((unsigned)((x) & 0xFFFF))
#define	ST_SRC(x)	EXTRACT_FIELD ((x), 21, 5)
#define	ADDU_OFFSET(x)	((unsigned)(x & 0xFFFF))

/* Possible actions to be taken by the prologue analyzer for the
   instructions it encounters.  */

enum m88k_prologue_insn_action
{
  M88K_PIA_SKIP,		/* Ignore.  */
  M88K_PIA_NOTE_ST,		/* Note register store.  */
  M88K_PIA_NOTE_STD,		/* Note register pair store.  */
  M88K_PIA_NOTE_SP_ADJUSTMENT,	/* Note stack pointer adjustment.  */
  M88K_PIA_NOTE_FP_ASSIGNMENT,	/* Note frame pointer assignment.  */
  M88K_PIA_NOTE_BRANCH,		/* Note branch.  */
  M88K_PIA_NOTE_PROLOGUE_END	/* Note end of prologue.  */
};

/* Table of instructions that may comprise a function prologue.  */

struct m88k_prologue_insn
{
  unsigned long insn;
  unsigned long mask;
  enum m88k_prologue_insn_action action;
};

struct m88k_prologue_insn m88k_prologue_insn_table[] =
{
  /* Various register move instructions.  */
  { 0x58000000, 0xf800ffff, M88K_PIA_SKIP },     /* or/or.u with immed of 0 */
  { 0xf4005800, 0xfc1fffe0, M88K_PIA_SKIP },     /* or rd,r0,rs */
  { 0xf4005800, 0xfc00ffff, M88K_PIA_SKIP },     /* or rd,rs,r0 */

  /* Various other instructions.  */
  { 0x58000000, 0xf8000000, M88K_PIA_SKIP },     /* or/or.u */

  /* Stack pointer setup: "subu sp,sp,n" where n is a multiple of 8.  */
  { 0x67ff0000, 0xffff0007, M88K_PIA_NOTE_SP_ADJUSTMENT },

  /* Frame pointer assignment: "addu r30,r31,n".  */
  { 0x63df0000, 0xffff0000, M88K_PIA_NOTE_FP_ASSIGNMENT },

  /* Store to stack instructions; either "st rx,sp,n" or "st.d rx,sp,n".  */
  { 0x241f0000, 0xfc1f0000, M88K_PIA_NOTE_ST },  /* st rx,sp,n */
  { 0x201f0000, 0xfc1f0000, M88K_PIA_NOTE_STD }, /* st.d rs,sp,n */

  /* Instructions needed for setting up r25 for pic code.  */
  { 0x5f200000, 0xffff0000, M88K_PIA_SKIP },     /* or.u r25,r0,offset_high */
  { 0xcc000002, 0xffffffff, M88K_PIA_SKIP },     /* bsr.n Lab */
  { 0x5b390000, 0xffff0000, M88K_PIA_SKIP },     /* or r25,r25,offset_low */
  { 0xf7396001, 0xffffffff, M88K_PIA_SKIP },     /* Lab: addu r25,r25,r1 */

  /* Various branch or jump instructions which have a delay slot --
     these do not form part of the prologue, but the instruction in
     the delay slot might be a store instruction which should be
     noted.  */
  { 0xc4000000, 0xe4000000, M88K_PIA_NOTE_BRANCH },
                                      /* br.n, bsr.n, bb0.n, or bb1.n */
  { 0xec000000, 0xfc000000, M88K_PIA_NOTE_BRANCH }, /* bcnd.n */
  { 0xf400c400, 0xfffff7e0, M88K_PIA_NOTE_BRANCH }, /* jmp.n or jsr.n */
d423 1
a423 18
  /* Catch all.  Ends prologue analysis.  */
  { 0x00000000, 0x00000000, M88K_PIA_NOTE_PROLOGUE_END }
};

/* Do a full analysis of the function prologue at PC and update CACHE
   accordingly.  Bail out early if LIMIT is reached.  Return the
   address where the analysis stopped.  If LIMIT points beyond the
   function prologue, the return address should be the end of the
   prologue.  */

static CORE_ADDR
m88k_analyze_prologue (CORE_ADDR pc, CORE_ADDR limit,
		       struct m88k_frame_cache *cache)
{
  CORE_ADDR end = limit;

  /* Provide a dummy cache if necessary.  */
  if (cache == NULL)
d425 5
a429 2
      size_t sizeof_saved_regs =
	(M88K_R31_REGNUM + 1) * sizeof (struct trad_frame_saved_reg);
d431 11
a441 2
      cache = alloca (sizeof (struct m88k_frame_cache));
      cache->saved_regs = alloca (sizeof_saved_regs);
d443 10
a452 3
      /* We only initialize the members we care about.  */
      cache->saved_regs[M88K_R1_REGNUM].addr = -1;
      cache->fp_offset = -1;
d455 2
a456 74
  while (pc < limit)
    {
      struct m88k_prologue_insn *pi = m88k_prologue_insn_table;
      unsigned long insn = m88k_fetch_instruction (pc);

      while ((insn & pi->mask) != pi->insn)
	pi++;

      switch (pi->action)
	{
	case M88K_PIA_SKIP:
	  /* If we have a frame pointer, and R1 has been saved,
             consider this instruction as not being part of the
             prologue.  */
	  if (cache->fp_offset != -1
	      && cache->saved_regs[M88K_R1_REGNUM].addr != -1)
	    return min (pc, end);
	  break;

	case M88K_PIA_NOTE_ST:
	case M88K_PIA_NOTE_STD:
	  /* If no frame has been allocated, the stores aren't part of
             the prologue.  */
	  if (cache->sp_offset == 0)
	    return min (pc, end);

	  /* Record location of saved registers.  */
	  {
	    int regnum = ST_SRC (insn) + M88K_R0_REGNUM;
	    ULONGEST offset = ST_OFFSET (insn);

	    cache->saved_regs[regnum].addr = offset;
	    if (pi->action == M88K_PIA_NOTE_STD && regnum < M88K_R31_REGNUM)
	      cache->saved_regs[regnum + 1].addr = offset + 4;
	  }
	  break;

	case M88K_PIA_NOTE_SP_ADJUSTMENT:
	  /* A second stack pointer adjustment isn't part of the
             prologue.  */
	  if (cache->sp_offset != 0)
	    return min (pc, end);

	  /* Store stack pointer adjustment.  */
	  cache->sp_offset = -SUBU_OFFSET (insn);
	  break;

	case M88K_PIA_NOTE_FP_ASSIGNMENT:
	  /* A second frame pointer assignment isn't part of the
             prologue.  */
	  if (cache->fp_offset != -1)
	    return min (pc, end);

	  /* Record frame pointer assignment.  */
	  cache->fp_offset = ADDU_OFFSET (insn);
	  break;

	case M88K_PIA_NOTE_BRANCH:
	  /* The branch instruction isn't part of the prologue, but
             the instruction in the delay slot might be.  Limit the
             prologue analysis to the delay slot and record the branch
             instruction as the end of the prologue.  */
	  limit = min (limit, pc + 2 * M88K_INSN_SIZE);
	  end = pc;
	  break;

	case M88K_PIA_NOTE_PROLOGUE_END:
	  return min (pc, end);
	}

      pc += M88K_INSN_SIZE;
    }

  return end;
d459 4
a462 2
/* An upper limit to the size of the prologue.  */
const int m88k_max_prologue_size = 128 * M88K_INSN_SIZE;
d464 3
a466 5
/* Return the address of first real instruction of the function
   starting at PC.  */

static CORE_ADDR
m88k_skip_prologue (CORE_ADDR pc)
d468 1
a468 2
  struct symtab_and_line sal;
  CORE_ADDR func_start, func_end;
d470 2
a471 5
  /* This is the preferred method, find the end of the prologue by
     using the debugging information.  */
  if (find_pc_partial_function (pc, NULL, &func_start, &func_end))
    {
      sal = find_pc_line (func_start, 0);
d473 1
a473 3
      if (sal.end < func_end && pc <= sal.end)
	return sal.end;
    }
d475 1
a475 8
  return m88k_analyze_prologue (pc, pc + m88k_max_prologue_size, NULL);
}

struct m88k_frame_cache *
m88k_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct m88k_frame_cache *cache;
  CORE_ADDR frame_sp;
d477 1
a477 50
  if (*this_cache)
    return *this_cache;

  cache = FRAME_OBSTACK_ZALLOC (struct m88k_frame_cache);
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
  cache->fp_offset = -1;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    {
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (next_frame);
      m88k_analyze_prologue (cache->pc, addr_in_block, cache);
    }

  /* Calculate the stack pointer used in the prologue.  */
  if (cache->fp_offset != -1)
    {
      CORE_ADDR fp;

      fp = frame_unwind_register_unsigned (next_frame, M88K_R30_REGNUM);
      frame_sp = fp - cache->fp_offset;
    }
  else
    {
      /* If we know where the return address is saved, we can take a
         solid guess at what the frame pointer should be.  */
      if (cache->saved_regs[M88K_R1_REGNUM].addr != -1)
	cache->fp_offset = cache->saved_regs[M88K_R1_REGNUM].addr - 4;
      frame_sp = frame_unwind_register_unsigned (next_frame, M88K_R31_REGNUM);
    }

  /* Now that we know the stack pointer, adjust the location of the
     saved registers.  */
  {
    int regnum;

    for (regnum = M88K_R0_REGNUM; regnum < M88K_R31_REGNUM; regnum ++)
      if (cache->saved_regs[regnum].addr != -1)
	cache->saved_regs[regnum].addr += frame_sp;
  }

  /* Calculate the frame's base.  */
  cache->base = frame_sp - cache->sp_offset;
  trad_frame_set_value (cache->saved_regs, M88K_R31_REGNUM, cache->base);

  /* Identify SXIP with the return address in R1.  */
  cache->saved_regs[M88K_SXIP_REGNUM] = cache->saved_regs[M88K_R1_REGNUM];

  *this_cache = cache;
  return cache;
d480 2
a481 12
static void
m88k_frame_this_id (struct frame_info *next_frame, void **this_cache,
		    struct frame_id *this_id)
{
  struct m88k_frame_cache *cache = m88k_frame_cache (next_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  (*this_id) = frame_id_build (cache->base, cache->pc);
}
d483 3
a485 5
static void
m88k_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
d487 1
a487 1
  struct m88k_frame_cache *cache = m88k_frame_cache (next_frame, this_cache);
d489 2
a490 5
  if (regnum == M88K_SNIP_REGNUM || regnum == M88K_SFIP_REGNUM)
    {
      if (valuep)
	{
	  CORE_ADDR pc;
d492 1
a492 9
	  trad_frame_prev_register (next_frame, cache->saved_regs,
				    M88K_SXIP_REGNUM, optimizedp,
				    lvalp, addrp, realnump, valuep);

	  pc = extract_unsigned_integer (valuep, 4);
	  if (regnum == M88K_SFIP_REGNUM)
	    pc += 4;
	  store_unsigned_integer (valuep, 4, pc + 4);
	}
d494 1
a494 7
      /* It's a computed value.  */
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      return;
    }
d496 1
a496 2
  trad_frame_prev_register (next_frame, cache->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
d499 1
a499 6
static const struct frame_unwind m88k_frame_unwind =
{
  NORMAL_FRAME,
  m88k_frame_this_id,
  m88k_frame_prev_register
};
d501 2
a502 6
static const struct frame_unwind *
m88k_frame_sniffer (struct frame_info *next_frame)
{
  return &m88k_frame_unwind;
}

d504 3
a506 2
static CORE_ADDR
m88k_frame_base_address (struct frame_info *next_frame, void **this_cache)
d508 1
a508 6
  struct m88k_frame_cache *cache = m88k_frame_cache (next_frame, this_cache);

  if (cache->fp_offset != -1)
    return cache->base + cache->sp_offset + cache->fp_offset;

  return 0;
a510 8
static const struct frame_base m88k_frame_base =
{
  &m88k_frame_unwind,
  m88k_frame_base_address,
  m88k_frame_base_address,
  m88k_frame_base_address
};

d512 1
a512 5
/* Core file support.  */

/* Supply register REGNUM from the buffer specified by GREGS and LEN
   in the general-purpose register set REGSET to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
d515 3
a517 3
m88k_supply_gregset (const struct regset *regset,
		     struct regcache *regcache,
		     int regnum, const void *gregs, size_t len)
d519 2
a520 2
  const char *regs = gregs;
  int i;
d522 2
a523 5
  for (i = 0; i < M88K_NUM_REGS; i++)
    {
      if (regnum == i || regnum == -1)
	regcache_raw_supply (regcache, i, regs + i * 4);
    }
d526 2
a527 3
/* Motorola 88000 register set.  */

static struct regset m88k_gregset =
d529 3
a531 3
  NULL,
  m88k_supply_gregset
};
d533 1
a533 2
/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */
d535 5
a539 6
static const struct regset *
m88k_regset_from_core_section (struct gdbarch *gdbarch,
			       const char *sect_name, size_t sect_size)
{
  if (strcmp (sect_name, ".reg") == 0 && sect_size >= M88K_NUM_REGS * 4)
    return &m88k_gregset;
d541 2
a542 3
  return NULL;
}

d544 2
a545 4
static struct gdbarch *
m88k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
d547 2
a548 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d550 2
a551 2
  /* Allocate space for the new architecture.  */
  gdbarch = gdbarch_alloc (&info, NULL);
d553 2
a554 3
  /* There is no real `long double'.  */
  set_gdbarch_long_double_bit (gdbarch, 64);
  set_gdbarch_long_double_format (gdbarch, &floatformat_ieee_double_big);
d556 3
a558 3
  set_gdbarch_num_regs (gdbarch, M88K_NUM_REGS);
  set_gdbarch_register_name (gdbarch, m88k_register_name);
  set_gdbarch_register_type (gdbarch, m88k_register_type);
d560 7
a566 3
  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, M88K_R31_REGNUM);
  set_gdbarch_pc_regnum (gdbarch, M88K_SXIP_REGNUM);
d568 2
a569 3
  /* Core file support.  */
  set_gdbarch_regset_from_core_section
    (gdbarch, m88k_regset_from_core_section);
d571 7
a577 1
  set_gdbarch_print_insn (gdbarch, print_insn_m88k);
d579 5
a583 1
  set_gdbarch_skip_prologue (gdbarch, m88k_skip_prologue);
d585 2
a586 2
  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
d588 2
a589 3
  /* Call dummy code.  */
  set_gdbarch_push_dummy_call (gdbarch, m88k_push_dummy_call);
  set_gdbarch_unwind_dummy_id (gdbarch, m88k_unwind_dummy_id);
d591 2
a592 2
  /* Return value info */
  set_gdbarch_return_value (gdbarch, m88k_return_value);
d594 2
a595 4
  set_gdbarch_addr_bits_remove (gdbarch, m88k_addr_bits_remove);
  set_gdbarch_breakpoint_from_pc (gdbarch, m88k_breakpoint_from_pc);
  set_gdbarch_unwind_pc (gdbarch, m88k_unwind_pc);
  set_gdbarch_write_pc (gdbarch, m88k_write_pc);
d597 2
a598 2
  frame_base_set_default (gdbarch, &m88k_frame_base);
  frame_unwind_append_sniffer (gdbarch, m88k_frame_sniffer);
d600 10
a609 1
  return gdbarch;
a610 4


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_m88k_tdep (void);
d613 1
a613 1
_initialize_m88k_tdep (void)
d615 1
a615 1
  gdbarch_register (bfd_arch_m88k, m88k_gdbarch_init, NULL);
@

