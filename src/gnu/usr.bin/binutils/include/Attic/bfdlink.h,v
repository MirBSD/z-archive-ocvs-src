head	1.3;
access;
symbols
	binutils-2_15:1.1.2.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.2
	cvs-200405160640:1.1.1.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.2.0.6
	MIRBSD_7:1.2.0.4
	cvs-200312222040:1.1.1.1
	cvs-200312031730:1.1.1.1
	MIRBSD_7ter:1.2
	MIRBSD_7_DEV:1.2.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	binutils_2_14:1.1.2.2
	binutils_2_11_2:1.1.2.1
	FSF:1.1.2
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.08.11.21.18.08;	author tg;	state dead;
branches;
next	1.2;

1.2
date	2003.09.23.21.05.14;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.40.52;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2003.03.22.17.40.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.30.16;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2003.09.23.15.42.45;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.09.23.16.07.52;	author tg;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.07.15.17.16.10;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove old binutils
@
text
@/* bfdlink.h -- header file for BFD link routines
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002
   Free Software Foundation, Inc.
   Written by Steve Chamberlain and Ian Lance Taylor, Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef BFDLINK_H
#define BFDLINK_H

/* Which symbols to strip during a link.  */
enum bfd_link_strip
{
  strip_none,		/* Don't strip any symbols.  */
  strip_debugger,	/* Strip debugging symbols.  */
  strip_some,		/* keep_hash is the list of symbols to keep.  */
  strip_all		/* Strip all symbols.  */
};

/* Which local symbols to discard during a link.  This is irrelevant
   if strip_all is used.  */
enum bfd_link_discard
{
  discard_sec_merge,	/* Discard local temporary symbols in SEC_MERGE
			   sections.  */
  discard_none,		/* Don't discard any locals.  */
  discard_l,		/* Discard local temporary symbols.  */
  discard_all		/* Discard all locals.  */
};

/* Describes the type of hash table entry structure being used.
   Different hash table structure have different fields and so
   support different linking features.  */
enum bfd_link_hash_table_type
  {
    bfd_link_generic_hash_table,
    bfd_link_elf_hash_table
  };

/* These are the possible types of an entry in the BFD link hash
   table.  */

enum bfd_link_hash_type
{
  bfd_link_hash_new,		/* Symbol is new.  */
  bfd_link_hash_undefined,	/* Symbol seen before, but undefined.  */
  bfd_link_hash_undefweak,	/* Symbol is weak and undefined.  */
  bfd_link_hash_defined,	/* Symbol is defined.  */
  bfd_link_hash_defweak,	/* Symbol is weak and defined.  */
  bfd_link_hash_common,		/* Symbol is common.  */
  bfd_link_hash_indirect,	/* Symbol is an indirect link.  */
  bfd_link_hash_warning		/* Like indirect, but warn if referenced.  */
};

enum bfd_link_common_skip_ar_aymbols
{
  bfd_link_common_skip_none,
  bfd_link_common_skip_text,
  bfd_link_common_skip_data,
  bfd_link_common_skip_all
};

/* The linking routines use a hash table which uses this structure for
   its elements.  */

struct bfd_link_hash_entry
{
  /* Base hash table entry structure.  */
  struct bfd_hash_entry root;
  /* Type of this entry.  */
  enum bfd_link_hash_type type;

  /* Undefined and common symbols are kept in a linked list through
     this field.  This field is not in the union because that would
     force us to remove entries from the list when we changed their
     type, which would force the list to be doubly linked, which would
     waste more memory.  When an undefined or common symbol is
     created, it should be added to this list, the head of which is in
     the link hash table itself.  As symbols are defined, they need
     not be removed from the list; anything which reads the list must
     doublecheck the symbol type.

     Weak symbols are not kept on this list.

     Defined and defweak symbols use this field as a reference marker.
     If the field is not NULL, or this structure is the tail of the
     undefined symbol list, the symbol has been referenced.  If the
     symbol is undefined and becomes defined, this field will
     automatically be non-NULL since the symbol will have been on the
     undefined symbol list.  */
  struct bfd_link_hash_entry *next;
  /* A union of information depending upon the type.  */
  union
    {
      /* Nothing is kept for bfd_hash_new.  */
      /* bfd_link_hash_undefined, bfd_link_hash_undefweak.  */
      struct
	{
	  bfd *abfd;		/* BFD symbol was found in.  */
	} undef;
      /* bfd_link_hash_defined, bfd_link_hash_defweak.  */
      struct
	{
	  bfd_vma value;	/* Symbol value.  */
	  asection *section;	/* Symbol section.  */
	} def;
      /* bfd_link_hash_indirect, bfd_link_hash_warning.  */
      struct
	{
	  struct bfd_link_hash_entry *link;	/* Real symbol.  */
	  const char *warning;	/* Warning (bfd_link_hash_warning only).  */
	} i;
      /* bfd_link_hash_common.  */
      struct
	{
	  /* The linker needs to know three things about common
	     symbols: the size, the alignment, and the section in
	     which the symbol should be placed.  We store the size
	     here, and we allocate a small structure to hold the
	     section and the alignment.  The alignment is stored as a
	     power of two.  We don't store all the information
	     directly because we don't want to increase the size of
	     the union; this structure is a major space user in the
	     linker.  */
	  bfd_size_type size;	/* Common symbol size.  */
	  struct bfd_link_hash_common_entry
	    {
	      unsigned int alignment_power;	/* Alignment.  */
	      asection *section;		/* Symbol section.  */
	    } *p;
	} c;
    } u;
};

/* This is the link hash table.  It is a derived class of
   bfd_hash_table.  */

struct bfd_link_hash_table
{
  /* The hash table itself.  */
  struct bfd_hash_table table;
  /* The back end which created this hash table.  This indicates the
     type of the entries in the hash table, which is sometimes
     important information when linking object files of different
     types together.  */
  const bfd_target *creator;
  /* A linked list of undefined and common symbols, linked through the
     next field in the bfd_link_hash_entry structure.  */
  struct bfd_link_hash_entry *undefs;
  /* Entries are added to the tail of the undefs list.  */
  struct bfd_link_hash_entry *undefs_tail;
  /* The type of the link hash table.  */
  enum bfd_link_hash_table_type type;
};

/* Look up an entry in a link hash table.  If FOLLOW is TRUE, this
   follows bfd_link_hash_indirect and bfd_link_hash_warning links to
   the real symbol.  */
extern struct bfd_link_hash_entry *bfd_link_hash_lookup
  PARAMS ((struct bfd_link_hash_table *, const char *, bfd_boolean create,
	   bfd_boolean copy, bfd_boolean follow));

/* Look up an entry in the main linker hash table if the symbol might
   be wrapped.  This should only be used for references to an
   undefined symbol, not for definitions of a symbol.  */

extern struct bfd_link_hash_entry *bfd_wrapped_link_hash_lookup
  PARAMS ((bfd *, struct bfd_link_info *, const char *, bfd_boolean,
	   bfd_boolean, bfd_boolean));

/* Traverse a link hash table.  */
extern void bfd_link_hash_traverse
  PARAMS ((struct bfd_link_hash_table *,
	   bfd_boolean (*) (struct bfd_link_hash_entry *, PTR),
	   PTR));

/* Add an entry to the undefs list.  */
extern void bfd_link_add_undef
  PARAMS ((struct bfd_link_hash_table *, struct bfd_link_hash_entry *));

struct bfd_sym_chain
{
  struct bfd_sym_chain *next;
  const char *name;
};

/* This structure holds all the information needed to communicate
   between BFD and the linker when doing a link.  */

struct bfd_link_info
{
  /* TRUE if BFD should generate a relocatable object file.  */
  unsigned int relocateable: 1;

  /* TRUE if BFD should generate relocation information in the final
     executable.  */
  unsigned int emitrelocations: 1;

  /* TRUE if BFD should generate a "task linked" object file,
     similar to relocatable but also with globals converted to
     statics.  */
  unsigned int task_link: 1;

  /* TRUE if BFD should generate a shared object.  */
  unsigned int shared: 1;

  /* TRUE if BFD should pre-bind symbols in a shared object.  */
  unsigned int symbolic: 1;

  /* TRUE if BFD should export all symbols in the dynamic symbol table
     of an executable, rather than only those used.  */
  unsigned int export_dynamic: 1;

  /* TRUE if shared objects should be linked directly, not shared.  */
  unsigned int static_link: 1;

  /* TRUE if the output file should be in a traditional format.  This
     is equivalent to the setting of the BFD_TRADITIONAL_FORMAT flag
     on the output file, but may be checked when reading the input
     files.  */
  unsigned int traditional_format: 1;

  /* TRUE if we want to produced optimized output files.  This might
     need much more time and therefore must be explicitly selected.  */
  unsigned int optimize: 1;

  /* TRUE if BFD should generate errors for undefined symbols
     even if generating a shared object.  */
  unsigned int no_undefined: 1;

  /* TRUE if BFD should allow undefined symbols in shared objects even
     when no_undefined is set to disallow undefined symbols.  The net
     result will be that undefined symbols in regular objects will
     still trigger an error, but undefined symbols in shared objects
     will be ignored.  The implementation of no_undefined makes the
     assumption that the runtime linker will choke on undefined
     symbols.  However there is at least one system (BeOS) where
     undefined symbols in shared libraries is normal since the kernel
     patches them at load time to select which function is most
     appropriate for the current architecture.  I.E. dynamically
     select an appropriate memset function.  Apparently it is also
     normal for HPPA shared libraries to have undefined symbols.  */
  unsigned int allow_shlib_undefined: 1;

  /* TRUE if ok to have multiple definition.  */
  unsigned int allow_multiple_definition: 1;

  /* TRUE if ok to have version with no definition.  */
  unsigned int allow_undefined_version: 1;

  /* TRUE if symbols should be retained in memory, FALSE if they
     should be freed and reread.  */
  unsigned int keep_memory: 1;

  /* TRUE if every symbol should be reported back via the notice
     callback.  */
  unsigned int notice_all: 1;

  /* TRUE if executable should not contain copy relocs.
     Setting this true may result in a non-sharable text segment.  */
  unsigned int nocopyreloc: 1;

  /* TRUE if the new ELF dynamic tags are enabled. */
  unsigned int new_dtags: 1;

  /* TRUE if non-PLT relocs should be merged into one reloc section
     and sorted so that relocs against the same symbol come together.  */
  unsigned int combreloc: 1;

  /* TRUE if .eh_frame_hdr section and PT_GNU_EH_FRAME ELF segment
     should be created.  */
  unsigned int eh_frame_hdr: 1;

  /* TRUE if global symbols in discarded sections should be stripped.  */
  unsigned int strip_discarded: 1;

  /* TRUE if relaxation is being finalized.  */
  unsigned int relax_finalizing: 1;

  /* Which symbols to strip.  */
  enum bfd_link_strip strip;

  /* Which local symbols to discard.  */
  enum bfd_link_discard discard;

  /* Criteria for skipping symbols when detemining
     whether to include an object from an archive. */
  enum bfd_link_common_skip_ar_aymbols common_skip_ar_aymbols;

  /* Function callbacks.  */
  const struct bfd_link_callbacks *callbacks;

  /* Hash table handled by BFD.  */
  struct bfd_link_hash_table *hash;

  /* Hash table of symbols to keep.  This is NULL unless strip is
     strip_some.  */
  struct bfd_hash_table *keep_hash;

  /* Hash table of symbols to report back via the notice callback.  If
     this is NULL, and notice_all is FALSE, then no symbols are
     reported back.  */
  struct bfd_hash_table *notice_hash;

  /* Hash table of symbols which are being wrapped (the --wrap linker
     option).  If this is NULL, no symbols are being wrapped.  */
  struct bfd_hash_table *wrap_hash;

  /* The list of input BFD's involved in the link.  These are chained
     together via the link_next field.  */
  bfd *input_bfds;

  /* If a symbol should be created for each input BFD, this is section
     where those symbols should be placed.  It must be a section in
     the output BFD.  It may be NULL, in which case no such symbols
     will be created.  This is to support CREATE_OBJECT_SYMBOLS in the
     linker command language.  */
  asection *create_object_symbols_section;

  /* List of global symbol names that are starting points for marking
     sections against garbage collection.  */
  struct bfd_sym_chain *gc_sym_list;

  /* If a base output file is wanted, then this points to it */
  PTR base_file;

  /* The function to call when the executable or shared object is
     loaded.  */
  const char *init_function;

  /* The function to call when the executable or shared object is
     unloaded.  */
  const char *fini_function;

  /* If non-zero, specifies that branches which are problematic for the
     MPC860 C0 (or earlier) should be checked for and modified.  It gives the
     number of bytes that should be checked at the end of each text page.  */
  int mpc860c0;

  /* Non-zero if auto-import thunks for DATA items in pei386 DLLs
     should be generated/linked against.  Set to 1 if this feature
     is explicitly requested by the user, -1 if enabled by default.  */
  int pei386_auto_import;

  /* Non-zero if runtime relocs for DATA items with non-zero addends
     in pei386 DLLs should be generated.  Set to 1 if this feature
     is explicitly requested by the user, -1 if enabled by default.  */
  int pei386_runtime_pseudo_reloc;

  /* How many spare .dynamic DT_NULL entries should be added?  */
  unsigned int spare_dynamic_tags;

  /* May be used to set DT_FLAGS for ELF. */
  bfd_vma flags;

  /* May be used to set DT_FLAGS_1 for ELF. */
  bfd_vma flags_1;
};

/* This structures holds a set of callback functions.  These are
   called by the BFD linker routines.  The first argument to each
   callback function is the bfd_link_info structure being used.  Each
   function returns a boolean value.  If the function returns FALSE,
   then the BFD function which called it will return with a failure
   indication.  */

struct bfd_link_callbacks
{
  /* A function which is called when an object is added from an
     archive.  ABFD is the archive element being added.  NAME is the
     name of the symbol which caused the archive element to be pulled
     in.  */
  bfd_boolean (*add_archive_element)
    PARAMS ((struct bfd_link_info *, bfd *abfd, const char *name));
  /* A function which is called when a symbol is found with multiple
     definitions.  NAME is the symbol which is defined multiple times.
     OBFD is the old BFD, OSEC is the old section, OVAL is the old
     value, NBFD is the new BFD, NSEC is the new section, and NVAL is
     the new value.  OBFD may be NULL.  OSEC and NSEC may be
     bfd_com_section or bfd_ind_section.  */
  bfd_boolean (*multiple_definition)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *obfd, asection *osec, bfd_vma oval,
	     bfd *nbfd, asection *nsec, bfd_vma nval));
  /* A function which is called when a common symbol is defined
     multiple times.  NAME is the symbol appearing multiple times.
     OBFD is the BFD of the existing symbol; it may be NULL if this is
     not known.  OTYPE is the type of the existing symbol, which may
     be bfd_link_hash_defined, bfd_link_hash_defweak,
     bfd_link_hash_common, or bfd_link_hash_indirect.  If OTYPE is
     bfd_link_hash_common, OSIZE is the size of the existing symbol.
     NBFD is the BFD of the new symbol.  NTYPE is the type of the new
     symbol, one of bfd_link_hash_defined, bfd_link_hash_common, or
     bfd_link_hash_indirect.  If NTYPE is bfd_link_hash_common, NSIZE
     is the size of the new symbol.  */
  bfd_boolean (*multiple_common)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *obfd, enum bfd_link_hash_type otype, bfd_vma osize,
	     bfd *nbfd, enum bfd_link_hash_type ntype, bfd_vma nsize));
  /* A function which is called to add a symbol to a set.  ENTRY is
     the link hash table entry for the set itself (e.g.,
     __CTOR_LIST__).  RELOC is the relocation to use for an entry in
     the set when generating a relocateable file, and is also used to
     get the size of the entry when generating an executable file.
     ABFD, SEC and VALUE identify the value to add to the set.  */
  bfd_boolean (*add_to_set)
    PARAMS ((struct bfd_link_info *, struct bfd_link_hash_entry *entry,
	     bfd_reloc_code_real_type reloc, bfd *abfd, asection *sec,
	     bfd_vma value));
  /* A function which is called when the name of a g++ constructor or
     destructor is found.  This is only called by some object file
     formats.  CONSTRUCTOR is TRUE for a constructor, FALSE for a
     destructor.  This will use BFD_RELOC_CTOR when generating a
     relocateable file.  NAME is the name of the symbol found.  ABFD,
     SECTION and VALUE are the value of the symbol.  */
  bfd_boolean (*constructor)
    PARAMS ((struct bfd_link_info *, bfd_boolean constructor,
	     const char *name, bfd *abfd, asection *sec, bfd_vma value));
  /* A function which is called to issue a linker warning.  For
     example, this is called when there is a reference to a warning
     symbol.  WARNING is the warning to be issued.  SYMBOL is the name
     of the symbol which triggered the warning; it may be NULL if
     there is none.  ABFD, SECTION and ADDRESS identify the location
     which trigerred the warning; either ABFD or SECTION or both may
     be NULL if the location is not known.  */
  bfd_boolean (*warning)
    PARAMS ((struct bfd_link_info *, const char *warning, const char *symbol,
	     bfd *abfd, asection *section, bfd_vma address));
  /* A function which is called when a relocation is attempted against
     an undefined symbol.  NAME is the symbol which is undefined.
     ABFD, SECTION and ADDRESS identify the location from which the
     reference is made. FATAL indicates whether an undefined symbol is
     a fatal error or not. In some cases SECTION may be NULL.  */
  bfd_boolean (*undefined_symbol)
    PARAMS ((struct bfd_link_info *, const char *name, bfd *abfd,
	     asection *section, bfd_vma address, bfd_boolean fatal));
  /* A function which is called when a reloc overflow occurs.  NAME is
     the name of the symbol or section the reloc is against,
     RELOC_NAME is the name of the relocation, and ADDEND is any
     addend that is used.  ABFD, SECTION and ADDRESS identify the
     location at which the overflow occurs; if this is the result of a
     bfd_section_reloc_link_order or bfd_symbol_reloc_link_order, then
     ABFD will be NULL.  */
  bfd_boolean (*reloc_overflow)
    PARAMS ((struct bfd_link_info *, const char *name, const char *reloc_name,
	     bfd_vma addend, bfd *abfd, asection *section, bfd_vma address));
  /* A function which is called when a dangerous reloc is performed.
     The canonical example is an a29k IHCONST reloc which does not
     follow an IHIHALF reloc.  MESSAGE is an appropriate message.
     ABFD, SECTION and ADDRESS identify the location at which the
     problem occurred; if this is the result of a
     bfd_section_reloc_link_order or bfd_symbol_reloc_link_order, then
     ABFD will be NULL.  */
  bfd_boolean (*reloc_dangerous)
    PARAMS ((struct bfd_link_info *, const char *message,
	     bfd *abfd, asection *section, bfd_vma address));
  /* A function which is called when a reloc is found to be attached
     to a symbol which is not being written out.  NAME is the name of
     the symbol.  ABFD, SECTION and ADDRESS identify the location of
     the reloc; if this is the result of a
     bfd_section_reloc_link_order or bfd_symbol_reloc_link_order, then
     ABFD will be NULL.  */
  bfd_boolean (*unattached_reloc)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *abfd, asection *section, bfd_vma address));
  /* A function which is called when a symbol in notice_hash is
     defined or referenced.  NAME is the symbol.  ABFD, SECTION and
     ADDRESS are the value of the symbol.  If SECTION is
     bfd_und_section, this is a reference.  */
  bfd_boolean (*notice)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *abfd, asection *section, bfd_vma address));
  /* A function which is called for reporting a linker error. ID is the
     error identifier. The remaining input is the same as einfo () in
     ld.  */
  bfd_boolean (*error_handler)
    PARAMS ((int id, const char * fmt, ...));
};

/* The linker builds link_order structures which tell the code how to
   include input data in the output file.  */

/* These are the types of link_order structures.  */

enum bfd_link_order_type
{
  bfd_undefined_link_order,	/* Undefined.  */
  bfd_indirect_link_order,	/* Built from a section.  */
  bfd_data_link_order,		/* Set to explicit data.  */
  bfd_section_reloc_link_order,	/* Relocate against a section.  */
  bfd_symbol_reloc_link_order	/* Relocate against a symbol.  */
};

/* This is the link_order structure itself.  These form a chain
   attached to the section whose contents they are describing.  */

struct bfd_link_order
{
  /* Next link_order in chain.  */
  struct bfd_link_order *next;
  /* Type of link_order.  */
  enum bfd_link_order_type type;
  /* Offset within output section.  */
  bfd_vma offset;
  /* Size within output section.  */
  bfd_size_type size;
  /* Type specific information.  */
  union
    {
      struct
	{
	  /* Section to include.  If this is used, then
	     section->output_section must be the section the
	     link_order is attached to, section->output_offset must
	     equal the link_order offset field, and section->_raw_size
	     must equal the link_order size field.  Maybe these
	     restrictions should be relaxed someday.  */
	  asection *section;
	} indirect;
      struct
	{
	  /* Size of contents, or zero when contents size == size
	     within output section.
	     A non-zero value allows filling of the output section
	     with an arbitrary repeated pattern.  */
	  unsigned int size;
	  /* Data to put into file.  */
	  bfd_byte *contents;
	} data;
      struct
	{
	  /* Description of reloc to generate.  Used for
	     bfd_section_reloc_link_order and
	     bfd_symbol_reloc_link_order.  */
	  struct bfd_link_order_reloc *p;
	} reloc;
    } u;
};

/* A linker order of type bfd_section_reloc_link_order or
   bfd_symbol_reloc_link_order means to create a reloc against a
   section or symbol, respectively.  This is used to implement -Ur to
   generate relocs for the constructor tables.  The
   bfd_link_order_reloc structure describes the reloc that BFD should
   create.  It is similar to a arelent, but I didn't use arelent
   because the linker does not know anything about most symbols, and
   any asymbol structure it creates will be partially meaningless.
   This information could logically be in the bfd_link_order struct,
   but I didn't want to waste the space since these types of relocs
   are relatively rare.  */

struct bfd_link_order_reloc
{
  /* Reloc type.  */
  bfd_reloc_code_real_type reloc;

  union
    {
      /* For type bfd_section_reloc_link_order, this is the section
	 the reloc should be against.  This must be a section in the
	 output BFD, not any of the input BFDs.  */
      asection *section;
      /* For type bfd_symbol_reloc_link_order, this is the name of the
	 symbol the reloc should be against.  */
      const char *name;
    } u;

  /* Addend to use.  The object file should contain zero.  The BFD
     backend is responsible for filling in the contents of the object
     file correctly.  For some object file formats (e.g., COFF) the
     addend must be stored into in the object file, and for some
     (e.g., SPARC a.out) it is kept in the reloc.  */
  bfd_vma addend;
};

/* Allocate a new link_order for a section.  */
extern struct bfd_link_order *bfd_new_link_order PARAMS ((bfd *, asection *));

/* These structures are used to describe version information for the
   ELF linker.  These structures could be manipulated entirely inside
   BFD, but it would be a pain.  Instead, the regular linker sets up
   these structures, and then passes them into BFD.  */

/* Regular expressions for a version.  */

struct bfd_elf_version_expr
{
  /* Next regular expression for this version.  */
  struct bfd_elf_version_expr *next;
  /* Regular expression.  */
  const char *pattern;
  /* Matching function.  */
  int (*match) PARAMS ((struct bfd_elf_version_expr *, const char *));
  /* Defined by ".symver".  */
  unsigned int symver: 1;
  /* Defined by version script.  */
  unsigned int script : 1;
};

/* Version dependencies.  */

struct bfd_elf_version_deps
{
  /* Next dependency for this version.  */
  struct bfd_elf_version_deps *next;
  /* The version which this version depends upon.  */
  struct bfd_elf_version_tree *version_needed;
};

/* A node in the version tree.  */

struct bfd_elf_version_tree
{
  /* Next version.  */
  struct bfd_elf_version_tree *next;
  /* Name of this version.  */
  const char *name;
  /* Version number.  */
  unsigned int vernum;
  /* Regular expressions for global symbols in this version.  */
  struct bfd_elf_version_expr *globals;
  /* Regular expressions for local symbols in this version.  */
  struct bfd_elf_version_expr *locals;
  /* List of versions which this version depends upon.  */
  struct bfd_elf_version_deps *deps;
  /* Index of the version name.  This is used within BFD.  */
  unsigned int name_indx;
  /* Whether this version tree was used.  This is used within BFD.  */
  int used;
};

#endif
@


1.2
log
@looks as if some sour wine (Federweiﬂer <german>, for an English
description see http://forum.leo.org/archiv/2002_11/04/20021104125717e_en.html)
could help me to bear the pain upgrading binutils to 2.14

todo:
 - test if this works at all
 - test if this works
 - test if nothing breaks
 - nuke all occurences of "false" and "true" in binutils (including gdb),
   see bfd.h "Poison" for reference
 - talk to the OpenBSD people, ask them if they could improve this
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d38 2
d44 9
d69 8
d131 8
a138 8
             symbols: the size, the alignment, and the section in
             which the symbol should be placed.  We store the size
             here, and we allocate a small structure to hold the
             section and the alignment.  The alignment is stored as a
             power of two.  We don't store all the information
             directly because we don't want to increase the size of
             the union; this structure is a major space user in the
             linker.  */
d166 2
d170 1
a170 1
/* Look up an entry in a link hash table.  If FOLLOW is true, this
d174 2
a175 2
  PARAMS ((struct bfd_link_hash_table *, const char *, boolean create,
	   boolean copy, boolean follow));
d182 2
a183 2
  PARAMS ((bfd *, struct bfd_link_info *, const char *, boolean, boolean,
	   boolean));
d188 1
a188 1
	   boolean (*) (struct bfd_link_hash_entry *, PTR),
d194 6
d206 26
a231 16
  /* Function callbacks.  */
  const struct bfd_link_callbacks *callbacks;
  /* true if BFD should generate a relocateable object file.  */
  boolean relocateable;
  /* true if BFD should generate relocation information in the final executable.  */
  boolean emitrelocations;
  /* true if BFD should generate a "task linked" object file,
     similar to relocatable but also with globals converted to statics. */
  boolean task_link;
  /* true if BFD should generate a shared object.  */
  boolean shared;
  /* true if BFD should pre-bind symbols in a shared object.  */
  boolean symbolic;
  /* true if shared objects should be linked directly, not shared.  */
  boolean static_link;
  /* true if the output file should be in a traditional format.  This
d235 3
a237 2
  boolean traditional_format;
  /* true if we want to produced optimized output files.  This might
d239 3
a241 2
  boolean optimize;
  /* true if BFD should generate errors for undefined symbols
d243 3
a245 2
  boolean no_undefined;
  /* true if BFD should allow undefined symbols in shared objects even
d257 37
a293 1
  boolean allow_shlib_undefined;
d296 1
d299 8
a306 12
  /* true if symbols should be retained in memory, false if they
     should be freed and reread.  */
  boolean keep_memory;
  /* The list of input BFD's involved in the link.  These are chained
     together via the link_next field.  */
  bfd *input_bfds;
  /* If a symbol should be created for each input BFD, this is section
     where those symbols should be placed.  It must be a section in
     the output BFD.  It may be NULL, in which case no such symbols
     will be created.  This is to support CREATE_OBJECT_SYMBOLS in the
     linker command language.  */
  asection *create_object_symbols_section;
d309 1
d313 1
a313 3
  /* true if every symbol should be reported back via the notice
     callback.  */
  boolean notice_all;
d315 1
a315 1
     this is NULL, and notice_all is false, then no symbols are
d318 1
d322 16
a340 5
  /* If non-zero, specifies that branches which are problematic for the
  MPC860 C0 (or earlier) should be checked for and modified.  It gives the
  number of bytes that should be checked at the end of each text page. */
  int mpc860c0;

d344 1
d349 17
a365 2
  /* true if the new ELF dynamic tags are enabled. */ 
  boolean new_dtags;
d377 1
a377 1
   function returns a boolean value.  If the function returns false,
d387 2
a388 3
  boolean (*add_archive_element) PARAMS ((struct bfd_link_info *,
					  bfd *abfd,
					  const char *name));
d395 4
a398 8
  boolean (*multiple_definition) PARAMS ((struct bfd_link_info *,
					  const char *name,
					  bfd *obfd,
					  asection *osec,
					  bfd_vma oval,
					  bfd *nbfd,
					  asection *nsec,
					  bfd_vma nval));
d410 4
a413 8
  boolean (*multiple_common) PARAMS ((struct bfd_link_info *,
				      const char *name,
				      bfd *obfd,
				      enum bfd_link_hash_type otype,
				      bfd_vma osize,
				      bfd *nbfd,
				      enum bfd_link_hash_type ntype,
				      bfd_vma nsize));
d420 4
a423 4
  boolean (*add_to_set) PARAMS ((struct bfd_link_info *,
				 struct bfd_link_hash_entry *entry,
				 bfd_reloc_code_real_type reloc,
				 bfd *abfd, asection *sec, bfd_vma value));
d426 1
a426 1
     formats.  CONSTRUCTOR is true for a constructor, false for a
d430 3
a432 4
  boolean (*constructor) PARAMS ((struct bfd_link_info *,
				  boolean constructor,
				  const char *name, bfd *abfd, asection *sec,
				  bfd_vma value));
d440 3
a442 4
  boolean (*warning) PARAMS ((struct bfd_link_info *,
			      const char *warning, const char *symbol,
			      bfd *abfd, asection *section,
			      bfd_vma address));
d448 3
a450 5
  boolean (*undefined_symbol) PARAMS ((struct bfd_link_info *,
				       const char *name, bfd *abfd,
				       asection *section,
				       bfd_vma address,
				       boolean fatal));
d458 3
a460 5
  boolean (*reloc_overflow) PARAMS ((struct bfd_link_info *,
				     const char *name,
				     const char *reloc_name, bfd_vma addend,
				     bfd *abfd, asection *section,
				     bfd_vma address));
d468 3
a470 4
  boolean (*reloc_dangerous) PARAMS ((struct bfd_link_info *,
				      const char *message,
				      bfd *abfd, asection *section,
				      bfd_vma address));
d477 3
a479 4
  boolean (*unattached_reloc) PARAMS ((struct bfd_link_info *,
				       const char *name,
				       bfd *abfd, asection *section,
				       bfd_vma address));
d484 8
a491 2
  boolean (*notice) PARAMS ((struct bfd_link_info *, const char *name,
			     bfd *abfd, asection *section, bfd_vma address));
a502 1
  bfd_fill_link_order,		/* Fill with a 16 bit constant.  */
d511 1
a511 1
struct bfd_link_order 
d518 1
a518 1
  bfd_vma offset;  
d522 1
a522 1
  union 
d524 1
a524 1
      struct 
d536 6
a541 7
	  /* Value to fill with.  */
	  unsigned int value;
	} fill;
      struct
	{
	  /* Data to put into file.  The size field gives the number
	     of bytes which this field points to.  */
d607 5
a611 1
  int (*match) PARAMS((struct bfd_elf_version_expr *, const char *));
@


1.1.2.1
log
@vendor-branch-i-fy GNU binutils (2.11.2) to facilitate an update
@
text
@@


1.1.2.2
log
@Import GNU binutils 2.14 from the Free Software Foundation
(in case the update goes FUBAR, it can be easily backed off)
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a37 2
  discard_sec_merge,	/* Discard local temporary symbols in SEC_MERGE
			   sections.  */
a41 9

/* Describes the type of hash table entry structure being used.
   Different hash table structure have different fields and so
   support different linking features.  */
enum bfd_link_hash_table_type
  {
    bfd_link_generic_hash_table,
    bfd_link_elf_hash_table
  };
a57 8
enum bfd_link_common_skip_ar_aymbols
{
  bfd_link_common_skip_none,
  bfd_link_common_skip_text,
  bfd_link_common_skip_data,
  bfd_link_common_skip_all
};

d112 8
a119 8
	     symbols: the size, the alignment, and the section in
	     which the symbol should be placed.  We store the size
	     here, and we allocate a small structure to hold the
	     section and the alignment.  The alignment is stored as a
	     power of two.  We don't store all the information
	     directly because we don't want to increase the size of
	     the union; this structure is a major space user in the
	     linker.  */
a146 2
  /* The type of the link hash table.  */
  enum bfd_link_hash_table_type type;
d149 1
a149 1
/* Look up an entry in a link hash table.  If FOLLOW is TRUE, this
d153 2
a154 2
  PARAMS ((struct bfd_link_hash_table *, const char *, bfd_boolean create,
	   bfd_boolean copy, bfd_boolean follow));
d161 2
a162 2
  PARAMS ((bfd *, struct bfd_link_info *, const char *, bfd_boolean,
	   bfd_boolean, bfd_boolean));
d167 1
a167 1
	   bfd_boolean (*) (struct bfd_link_hash_entry *, PTR),
a172 6

struct bfd_sym_chain
{
  struct bfd_sym_chain *next;
  const char *name;
};
d179 16
a194 26
  /* TRUE if BFD should generate a relocatable object file.  */
  unsigned int relocateable: 1;

  /* TRUE if BFD should generate relocation information in the final
     executable.  */
  unsigned int emitrelocations: 1;

  /* TRUE if BFD should generate a "task linked" object file,
     similar to relocatable but also with globals converted to
     statics.  */
  unsigned int task_link: 1;

  /* TRUE if BFD should generate a shared object.  */
  unsigned int shared: 1;

  /* TRUE if BFD should pre-bind symbols in a shared object.  */
  unsigned int symbolic: 1;

  /* TRUE if BFD should export all symbols in the dynamic symbol table
     of an executable, rather than only those used.  */
  unsigned int export_dynamic: 1;

  /* TRUE if shared objects should be linked directly, not shared.  */
  unsigned int static_link: 1;

  /* TRUE if the output file should be in a traditional format.  This
d198 2
a199 3
  unsigned int traditional_format: 1;

  /* TRUE if we want to produced optimized output files.  This might
d201 2
a202 3
  unsigned int optimize: 1;

  /* TRUE if BFD should generate errors for undefined symbols
d204 2
a205 3
  unsigned int no_undefined: 1;

  /* TRUE if BFD should allow undefined symbols in shared objects even
d217 1
a217 37
  unsigned int allow_shlib_undefined: 1;

  /* TRUE if ok to have multiple definition.  */
  unsigned int allow_multiple_definition: 1;

  /* TRUE if ok to have version with no definition.  */
  unsigned int allow_undefined_version: 1;

  /* TRUE if symbols should be retained in memory, FALSE if they
     should be freed and reread.  */
  unsigned int keep_memory: 1;

  /* TRUE if every symbol should be reported back via the notice
     callback.  */
  unsigned int notice_all: 1;

  /* TRUE if executable should not contain copy relocs.
     Setting this true may result in a non-sharable text segment.  */
  unsigned int nocopyreloc: 1;

  /* TRUE if the new ELF dynamic tags are enabled. */
  unsigned int new_dtags: 1;

  /* TRUE if non-PLT relocs should be merged into one reloc section
     and sorted so that relocs against the same symbol come together.  */
  unsigned int combreloc: 1;

  /* TRUE if .eh_frame_hdr section and PT_GNU_EH_FRAME ELF segment
     should be created.  */
  unsigned int eh_frame_hdr: 1;

  /* TRUE if global symbols in discarded sections should be stripped.  */
  unsigned int strip_discarded: 1;

  /* TRUE if relaxation is being finalized.  */
  unsigned int relax_finalizing: 1;

a219 1

d222 12
a233 8

  /* Criteria for skipping symbols when detemining
     whether to include an object from an archive. */
  enum bfd_link_common_skip_ar_aymbols common_skip_ar_aymbols;

  /* Function callbacks.  */
  const struct bfd_link_callbacks *callbacks;

a235 1

d239 3
a241 1

d243 1
a243 1
     this is NULL, and notice_all is FALSE, then no symbols are
a245 1

a248 16

  /* The list of input BFD's involved in the link.  These are chained
     together via the link_next field.  */
  bfd *input_bfds;

  /* If a symbol should be created for each input BFD, this is section
     where those symbols should be placed.  It must be a section in
     the output BFD.  It may be NULL, in which case no such symbols
     will be created.  This is to support CREATE_OBJECT_SYMBOLS in the
     linker command language.  */
  asection *create_object_symbols_section;

  /* List of global symbol names that are starting points for marking
     sections against garbage collection.  */
  struct bfd_sym_chain *gc_sym_list;

d252 5
a259 1

d264 2
a265 17
  /* If non-zero, specifies that branches which are problematic for the
     MPC860 C0 (or earlier) should be checked for and modified.  It gives the
     number of bytes that should be checked at the end of each text page.  */
  int mpc860c0;

  /* Non-zero if auto-import thunks for DATA items in pei386 DLLs
     should be generated/linked against.  Set to 1 if this feature
     is explicitly requested by the user, -1 if enabled by default.  */
  int pei386_auto_import;

  /* Non-zero if runtime relocs for DATA items with non-zero addends
     in pei386 DLLs should be generated.  Set to 1 if this feature
     is explicitly requested by the user, -1 if enabled by default.  */
  int pei386_runtime_pseudo_reloc;

  /* How many spare .dynamic DT_NULL entries should be added?  */
  unsigned int spare_dynamic_tags;
d277 1
a277 1
   function returns a boolean value.  If the function returns FALSE,
d287 3
a289 2
  bfd_boolean (*add_archive_element)
    PARAMS ((struct bfd_link_info *, bfd *abfd, const char *name));
d296 8
a303 4
  bfd_boolean (*multiple_definition)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *obfd, asection *osec, bfd_vma oval,
	     bfd *nbfd, asection *nsec, bfd_vma nval));
d315 8
a322 4
  bfd_boolean (*multiple_common)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *obfd, enum bfd_link_hash_type otype, bfd_vma osize,
	     bfd *nbfd, enum bfd_link_hash_type ntype, bfd_vma nsize));
d329 4
a332 4
  bfd_boolean (*add_to_set)
    PARAMS ((struct bfd_link_info *, struct bfd_link_hash_entry *entry,
	     bfd_reloc_code_real_type reloc, bfd *abfd, asection *sec,
	     bfd_vma value));
d335 1
a335 1
     formats.  CONSTRUCTOR is TRUE for a constructor, FALSE for a
d339 4
a342 3
  bfd_boolean (*constructor)
    PARAMS ((struct bfd_link_info *, bfd_boolean constructor,
	     const char *name, bfd *abfd, asection *sec, bfd_vma value));
d350 4
a353 3
  bfd_boolean (*warning)
    PARAMS ((struct bfd_link_info *, const char *warning, const char *symbol,
	     bfd *abfd, asection *section, bfd_vma address));
d359 5
a363 3
  bfd_boolean (*undefined_symbol)
    PARAMS ((struct bfd_link_info *, const char *name, bfd *abfd,
	     asection *section, bfd_vma address, bfd_boolean fatal));
d371 5
a375 3
  bfd_boolean (*reloc_overflow)
    PARAMS ((struct bfd_link_info *, const char *name, const char *reloc_name,
	     bfd_vma addend, bfd *abfd, asection *section, bfd_vma address));
d383 4
a386 3
  bfd_boolean (*reloc_dangerous)
    PARAMS ((struct bfd_link_info *, const char *message,
	     bfd *abfd, asection *section, bfd_vma address));
d393 4
a396 3
  bfd_boolean (*unattached_reloc)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *abfd, asection *section, bfd_vma address));
d401 2
a402 8
  bfd_boolean (*notice)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *abfd, asection *section, bfd_vma address));
  /* A function which is called for reporting a linker error. ID is the
     error identifier. The remaining input is the same as einfo () in
     ld.  */
  bfd_boolean (*error_handler)
    PARAMS ((int id, const char * fmt, ...));
d414 1
d423 1
a423 1
struct bfd_link_order
d430 1
a430 1
  bfd_vma offset;
d434 1
a434 1
  union
d436 1
a436 1
      struct
d448 7
a454 6
	  /* Size of contents, or zero when contents size == size
	     within output section.
	     A non-zero value allows filling of the output section
	     with an arbitrary repeated pattern.  */
	  unsigned int size;
	  /* Data to put into file.  */
d520 1
a520 5
  int (*match) PARAMS ((struct bfd_elf_version_expr *, const char *));
  /* Defined by ".symver".  */
  unsigned int symver: 1;
  /* Defined by version script.  */
  unsigned int script : 1;
@


1.1.2.3
log
@GNU Binutils, version 2.15
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003,
   2004 Free Software Foundation, Inc.
a83 1

d105 1
a105 2
  struct bfd_link_hash_entry *und_next;

d174 2
a175 2
  (struct bfd_link_hash_table *, const char *, bfd_boolean create,
   bfd_boolean copy, bfd_boolean follow);
d182 2
a183 2
  (bfd *, struct bfd_link_info *, const char *, bfd_boolean,
   bfd_boolean, bfd_boolean);
d187 3
a189 3
  (struct bfd_link_hash_table *,
    bfd_boolean (*) (struct bfd_link_hash_entry *, void *),
    void *);
d193 1
a193 1
  (struct bfd_link_hash_table *, struct bfd_link_hash_entry *);
a200 13
/* How to handle unresolved symbols.
   There are four possibilities which are enumerated below:  */
enum report_method
{
  /* This is the initial value when then link_info structure is created.
     It allows the various stages of the linker to determine whether they
     allowed to set the value.  */
  RM_NOT_YET_SET = 0,
  RM_IGNORE,
  RM_GENERATE_WARNING,
  RM_GENERATE_ERROR
};

d207 1
a207 1
  unsigned int relocatable: 1;
d241 18
d291 2
a292 27
  /* TRUE if the final relax pass is needed.  */
  unsigned int need_relax_finalize: 1;

  /* TRUE if generating a position independent executable.  */
  unsigned int pie: 1;

  /* TRUE if generating an executable, position independent or not.  */
  unsigned int executable : 1;

  /* TRUE if PT_GNU_STACK segment should be created with PF_R|PF_W|PF_X
     flags.  */
  unsigned int execstack: 1;

  /* TRUE if PT_GNU_STACK segment should be created with PF_R|PF_W
     flags.  */
  unsigned int noexecstack: 1;

  /* What to do with unresolved symbols in an object file.
     When producing executables the default is GENERATE_ERROR.
     When producing shared libraries the default is IGNORE.  The
     assumption with shared libraries is that the reference will be
     resolved at load/execution time.  */
  enum report_method unresolved_syms_in_objects;

  /* What to do with unresolved symbols in a shared library.
     The same defaults apply.  */
  enum report_method unresolved_syms_in_shared_libs;
a303 5
  /* Char that may appear as the first char of a symbol, but should be
     skipped (like symbol_leading_char) when looking up symbols in
     wrap_hash.  Used by PowerPC Linux for 'dot' symbols.  */
  char wrap_char;

d339 1
a339 1
  void *base_file;
d349 5
d388 1
a388 1
    (struct bfd_link_info *, bfd *abfd, const char *name);
d396 3
a398 3
    (struct bfd_link_info *, const char *name,
     bfd *obfd, asection *osec, bfd_vma oval,
     bfd *nbfd, asection *nsec, bfd_vma nval);
d411 3
a413 3
    (struct bfd_link_info *, const char *name,
     bfd *obfd, enum bfd_link_hash_type otype, bfd_vma osize,
     bfd *nbfd, enum bfd_link_hash_type ntype, bfd_vma nsize);
d417 1
a417 1
     the set when generating a relocatable file, and is also used to
d421 3
a423 2
    (struct bfd_link_info *, struct bfd_link_hash_entry *entry,
     bfd_reloc_code_real_type reloc, bfd *abfd, asection *sec, bfd_vma value);
d428 1
a428 1
     relocatable file.  NAME is the name of the symbol found.  ABFD,
d431 2
a432 2
    (struct bfd_link_info *, bfd_boolean constructor, const char *name,
     bfd *abfd, asection *sec, bfd_vma value);
d441 2
a442 2
    (struct bfd_link_info *, const char *warning, const char *symbol,
     bfd *abfd, asection *section, bfd_vma address);
d449 2
a450 2
    (struct bfd_link_info *, const char *name, bfd *abfd,
     asection *section, bfd_vma address, bfd_boolean fatal);
d459 2
a460 2
    (struct bfd_link_info *, const char *name, const char *reloc_name,
     bfd_vma addend, bfd *abfd, asection *section, bfd_vma address);
d469 2
a470 2
    (struct bfd_link_info *, const char *message,
     bfd *abfd, asection *section, bfd_vma address);
d478 2
a479 2
    (struct bfd_link_info *, const char *name,
     bfd *abfd, asection *section, bfd_vma address);
d485 2
a486 2
    (struct bfd_link_info *, const char *name,
     bfd *abfd, asection *section, bfd_vma address);
d491 1
a491 4
    (int id, const char *fmt, ...);

/* Identifiers of linker error messages used by error_handler.  */
#define LD_DEFINITION_IN_DISCARDED_SECTION	1
d591 1
a591 1
extern struct bfd_link_order *bfd_new_link_order (bfd *, asection *);
d598 1
a598 1
/* Glob pattern for a version.  */
d602 1
a602 1
  /* Next glob pattern for this version.  */
d604 1
a604 1
  /* Glob pattern.  */
d606 2
a607 2
  /* NULL for a glob pattern, otherwise a straight symbol.  */
  const char *symbol;
d609 1
a609 1
  unsigned int symver : 1;
a611 17
  /* Pattern type.  */
#define BFD_ELF_VERSION_C_TYPE		1
#define BFD_ELF_VERSION_CXX_TYPE	2
#define BFD_ELF_VERSION_JAVA_TYPE	4
  unsigned int mask : 3;
};

struct bfd_elf_version_expr_head
{
  /* List of all patterns, both wildcards and non-wildcards.  */
  struct bfd_elf_version_expr *list;
  /* Hash table for non-wildcards.  */
  void *htab;
  /* Remaining patterns.  */
  struct bfd_elf_version_expr *remaining;
  /* What kind of pattern types are present in list (bitmask).  */
  unsigned int mask;
d635 1
a635 1
  struct bfd_elf_version_expr_head globals;
d637 1
a637 1
  struct bfd_elf_version_expr_head locals;
a643 4
  /* Matching hook.  */
  struct bfd_elf_version_expr *(*match)
    (struct bfd_elf_version_expr_head *head,
     struct bfd_elf_version_expr *prev, const char *sym);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIXÆ, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a37 2
  discard_sec_merge,	/* Discard local temporary symbols in SEC_MERGE
			   sections.  */
a41 9

/* Describes the type of hash table entry structure being used.
   Different hash table structure have different fields and so
   support different linking features.  */
enum bfd_link_hash_table_type
  {
    bfd_link_generic_hash_table,
    bfd_link_elf_hash_table
  };
a57 8
enum bfd_link_common_skip_ar_aymbols
{
  bfd_link_common_skip_none,
  bfd_link_common_skip_text,
  bfd_link_common_skip_data,
  bfd_link_common_skip_all
};

d112 8
a119 8
	     symbols: the size, the alignment, and the section in
	     which the symbol should be placed.  We store the size
	     here, and we allocate a small structure to hold the
	     section and the alignment.  The alignment is stored as a
	     power of two.  We don't store all the information
	     directly because we don't want to increase the size of
	     the union; this structure is a major space user in the
	     linker.  */
a146 2
  /* The type of the link hash table.  */
  enum bfd_link_hash_table_type type;
d149 1
a149 1
/* Look up an entry in a link hash table.  If FOLLOW is TRUE, this
d153 2
a154 2
  PARAMS ((struct bfd_link_hash_table *, const char *, bfd_boolean create,
	   bfd_boolean copy, bfd_boolean follow));
d161 2
a162 2
  PARAMS ((bfd *, struct bfd_link_info *, const char *, bfd_boolean,
	   bfd_boolean, bfd_boolean));
d167 1
a167 1
	   bfd_boolean (*) (struct bfd_link_hash_entry *, PTR),
a172 6

struct bfd_sym_chain
{
  struct bfd_sym_chain *next;
  const char *name;
};
d179 16
a194 26
  /* TRUE if BFD should generate a relocatable object file.  */
  unsigned int relocateable: 1;

  /* TRUE if BFD should generate relocation information in the final
     executable.  */
  unsigned int emitrelocations: 1;

  /* TRUE if BFD should generate a "task linked" object file,
     similar to relocatable but also with globals converted to
     statics.  */
  unsigned int task_link: 1;

  /* TRUE if BFD should generate a shared object.  */
  unsigned int shared: 1;

  /* TRUE if BFD should pre-bind symbols in a shared object.  */
  unsigned int symbolic: 1;

  /* TRUE if BFD should export all symbols in the dynamic symbol table
     of an executable, rather than only those used.  */
  unsigned int export_dynamic: 1;

  /* TRUE if shared objects should be linked directly, not shared.  */
  unsigned int static_link: 1;

  /* TRUE if the output file should be in a traditional format.  This
d198 2
a199 3
  unsigned int traditional_format: 1;

  /* TRUE if we want to produced optimized output files.  This might
d201 2
a202 3
  unsigned int optimize: 1;

  /* TRUE if BFD should generate errors for undefined symbols
d204 2
a205 3
  unsigned int no_undefined: 1;

  /* TRUE if BFD should allow undefined symbols in shared objects even
d217 1
a217 37
  unsigned int allow_shlib_undefined: 1;

  /* TRUE if ok to have multiple definition.  */
  unsigned int allow_multiple_definition: 1;

  /* TRUE if ok to have version with no definition.  */
  unsigned int allow_undefined_version: 1;

  /* TRUE if symbols should be retained in memory, FALSE if they
     should be freed and reread.  */
  unsigned int keep_memory: 1;

  /* TRUE if every symbol should be reported back via the notice
     callback.  */
  unsigned int notice_all: 1;

  /* TRUE if executable should not contain copy relocs.
     Setting this true may result in a non-sharable text segment.  */
  unsigned int nocopyreloc: 1;

  /* TRUE if the new ELF dynamic tags are enabled. */
  unsigned int new_dtags: 1;

  /* TRUE if non-PLT relocs should be merged into one reloc section
     and sorted so that relocs against the same symbol come together.  */
  unsigned int combreloc: 1;

  /* TRUE if .eh_frame_hdr section and PT_GNU_EH_FRAME ELF segment
     should be created.  */
  unsigned int eh_frame_hdr: 1;

  /* TRUE if global symbols in discarded sections should be stripped.  */
  unsigned int strip_discarded: 1;

  /* TRUE if relaxation is being finalized.  */
  unsigned int relax_finalizing: 1;

a219 1

d222 12
a233 8

  /* Criteria for skipping symbols when detemining
     whether to include an object from an archive. */
  enum bfd_link_common_skip_ar_aymbols common_skip_ar_aymbols;

  /* Function callbacks.  */
  const struct bfd_link_callbacks *callbacks;

a235 1

d239 3
a241 1

d243 1
a243 1
     this is NULL, and notice_all is FALSE, then no symbols are
a245 1

a248 16

  /* The list of input BFD's involved in the link.  These are chained
     together via the link_next field.  */
  bfd *input_bfds;

  /* If a symbol should be created for each input BFD, this is section
     where those symbols should be placed.  It must be a section in
     the output BFD.  It may be NULL, in which case no such symbols
     will be created.  This is to support CREATE_OBJECT_SYMBOLS in the
     linker command language.  */
  asection *create_object_symbols_section;

  /* List of global symbol names that are starting points for marking
     sections against garbage collection.  */
  struct bfd_sym_chain *gc_sym_list;

d252 5
a259 1

d264 2
a265 17
  /* If non-zero, specifies that branches which are problematic for the
     MPC860 C0 (or earlier) should be checked for and modified.  It gives the
     number of bytes that should be checked at the end of each text page.  */
  int mpc860c0;

  /* Non-zero if auto-import thunks for DATA items in pei386 DLLs
     should be generated/linked against.  Set to 1 if this feature
     is explicitly requested by the user, -1 if enabled by default.  */
  int pei386_auto_import;

  /* Non-zero if runtime relocs for DATA items with non-zero addends
     in pei386 DLLs should be generated.  Set to 1 if this feature
     is explicitly requested by the user, -1 if enabled by default.  */
  int pei386_runtime_pseudo_reloc;

  /* How many spare .dynamic DT_NULL entries should be added?  */
  unsigned int spare_dynamic_tags;
d277 1
a277 1
   function returns a boolean value.  If the function returns FALSE,
d287 3
a289 2
  bfd_boolean (*add_archive_element)
    PARAMS ((struct bfd_link_info *, bfd *abfd, const char *name));
d296 8
a303 4
  bfd_boolean (*multiple_definition)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *obfd, asection *osec, bfd_vma oval,
	     bfd *nbfd, asection *nsec, bfd_vma nval));
d315 8
a322 4
  bfd_boolean (*multiple_common)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *obfd, enum bfd_link_hash_type otype, bfd_vma osize,
	     bfd *nbfd, enum bfd_link_hash_type ntype, bfd_vma nsize));
d329 4
a332 4
  bfd_boolean (*add_to_set)
    PARAMS ((struct bfd_link_info *, struct bfd_link_hash_entry *entry,
	     bfd_reloc_code_real_type reloc, bfd *abfd, asection *sec,
	     bfd_vma value));
d335 1
a335 1
     formats.  CONSTRUCTOR is TRUE for a constructor, FALSE for a
d339 4
a342 3
  bfd_boolean (*constructor)
    PARAMS ((struct bfd_link_info *, bfd_boolean constructor,
	     const char *name, bfd *abfd, asection *sec, bfd_vma value));
d350 4
a353 3
  bfd_boolean (*warning)
    PARAMS ((struct bfd_link_info *, const char *warning, const char *symbol,
	     bfd *abfd, asection *section, bfd_vma address));
d359 5
a363 3
  bfd_boolean (*undefined_symbol)
    PARAMS ((struct bfd_link_info *, const char *name, bfd *abfd,
	     asection *section, bfd_vma address, bfd_boolean fatal));
d371 5
a375 3
  bfd_boolean (*reloc_overflow)
    PARAMS ((struct bfd_link_info *, const char *name, const char *reloc_name,
	     bfd_vma addend, bfd *abfd, asection *section, bfd_vma address));
d383 4
a386 3
  bfd_boolean (*reloc_dangerous)
    PARAMS ((struct bfd_link_info *, const char *message,
	     bfd *abfd, asection *section, bfd_vma address));
d393 4
a396 3
  bfd_boolean (*unattached_reloc)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *abfd, asection *section, bfd_vma address));
d401 2
a402 8
  bfd_boolean (*notice)
    PARAMS ((struct bfd_link_info *, const char *name,
	     bfd *abfd, asection *section, bfd_vma address));
  /* A function which is called for reporting a linker error. ID is the
     error identifier. The remaining input is the same as einfo () in
     ld.  */
  bfd_boolean (*error_handler)
    PARAMS ((int id, const char * fmt, ...));
d414 1
d423 1
a423 1
struct bfd_link_order
d430 1
a430 1
  bfd_vma offset;
d434 1
a434 1
  union
d436 1
a436 1
      struct
d448 7
a454 6
	  /* Size of contents, or zero when contents size == size
	     within output section.
	     A non-zero value allows filling of the output section
	     with an arbitrary repeated pattern.  */
	  unsigned int size;
	  /* Data to put into file.  */
d520 1
a520 5
  int (*match) PARAMS ((struct bfd_elf_version_expr *, const char *));
  /* Defined by ".symver".  */
  unsigned int symver: 1;
  /* Defined by version script.  */
  unsigned int script : 1;
@

