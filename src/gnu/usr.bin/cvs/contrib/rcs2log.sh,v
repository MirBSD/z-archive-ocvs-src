head	1.4;
access;
symbols
	cvs-1_12_11:1.1.2.2
	tg-mergetmp-mirosx-1:1.3
	tg-mergefixes-1-branch:1.3.0.4
	tg-mergefixes-1-base:1.3
	MIROS_X:1.3.0.2
	MIROS_X_BASE:1.3
	cvs-1_12_10:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_MIRPPC:1.2.0.4
	MIRBSD_XP_SPARC_BASE:1.2
	MIRBSD_XP_SPARC:1.2.0.2
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200404170130:1.1.1.1
	cvs-1_11_12:1.1.3.2
	cvs-1_11_1p1:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2005.01.08.21.31.29;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.02.12.39.46;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.22.13.49.11;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.41.23;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2004.12.02.11.58.17;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.01.08.21.13.55;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.02.12.19.17.20;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.12.19.37.34;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@fastmerge
@
text
@#! /bin/sh

# RCS to ChangeLog generator

# Generate a change log prefix from RCS files (perhaps in the CVS repository)
# and the ChangeLog (if any).
# Output the new prefix to standard output.
# You can edit this prefix by hand, and then prepend it to ChangeLog.

# Ignore log entries that start with `#'.
# Clump together log entries that start with `{topic} ',
# where `topic' contains neither white space nor `}'.

Help='The default FILEs are the files registered under the working directory.
Options:

  -c CHANGELOG  Output a change log prefix to CHANGELOG (default ChangeLog).
  -h HOSTNAME  Use HOSTNAME in change log entries (default current host).
  -i INDENT  Indent change log lines by INDENT spaces (default 8).
  -l LENGTH  Try to limit log lines to LENGTH characters (default 79).
  -L FILE  Use rlog-format FILE for source of logs.
  -R  If no FILEs are given and RCS is used, recurse through working directory.
  -r OPTION  Pass OPTION to subsidiary log command.
  -t TABWIDTH  Tab stops are every TABWIDTH characters (default 8).
  -u "LOGIN<tab>FULLNAME<tab>MAILADDR"  Assume LOGIN has FULLNAME and MAILADDR.
  -v  Append RCS revision to file names in log lines.
  --help  Output help.
  --version  Output version number.

Report bugs to <bug-gnu-emacs@@gnu.org>.'

Id='$Id: rcs2log.sh,v 1.1.2.2 2005/01/08 21:13:55 tg Exp $'

# Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2001, 2003
#  Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.  If not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

Copyright='Copyright 1992-2003 Free Software Foundation, Inc.
This program comes with NO WARRANTY, to the extent permitted by law.
You may redistribute copies of this program
under the terms of the GNU General Public License.
For more information about these matters, see the files named COPYING.
Author: Paul Eggert <eggert@@twinsun.com>'

# Use the traditional C locale.
LANG=C
LANGUAGE=C
LC_ALL=C
LC_COLLATE=C
LC_CTYPE=C
LC_MESSAGES=C
LC_NUMERIC=C
LC_TIME=C
export LANG LANGUAGE LC_ALL LC_COLLATE LC_CTYPE LC_MESSAGES LC_NUMERIC LC_TIME

# These variables each contain a single ASCII character.
# Unfortunately, there's no portable way of writing these characters
# in older Unix implementations, other than putting them directly into
# this text file.
SOH='' # SOH, octal code 001
tab='	'
nl='
'

# Parse options.

# defaults
: ${AWK=awk}
: ${TMPDIR=/tmp}

changelog=ChangeLog # change log file name
datearg= # rlog date option
hostname= # name of local host (if empty, will deduce it later)
indent=8 # indent of log line
length=79 # suggested max width of log line
logins= # login names for people we know fullnames and mailaddrs of
loginFullnameMailaddrs= # login<tab>fullname<tab>mailaddr triplets
logTZ= # time zone for log dates (if empty, use local time)
recursive= # t if we want recursive rlog
revision= # t if we want revision numbers
rlog_options= # options to pass to rlog
rlogfile= # log file to read from
tabwidth=8 # width of horizontal tab

while :
do
	case $1 in
	-c)	changelog=${2?}; shift;;
	-i)	indent=${2?}; shift;;
	-h)	hostname=${2?}; shift;;
	-l)	length=${2?}; shift;;
	-L)	rlogfile=${2?}; shift;;
	-[nu])	# -n is obsolescent; it is replaced by -u.
		case $1 in
		-n)	case ${2?}${3?}${4?} in
			*"$tab"* | *"$nl"*)
				echo >&2 "$0: -n '$2' '$3' '$4': tabs, newlines not allowed"
				exit 1;;
			esac
			login=$2
			lfm=$2$tab$3$tab$4
			shift; shift; shift;;
		-u)
			# If $2 is not tab-separated, use colon for separator.
			case ${2?} in
			*"$nl"*)
				echo >&2 "$0: -u '$2': newlines not allowed"
				exit 1;;
			*"$tab"*)
				t=$tab;;
			*)
				t=':';;
			esac
			case $2 in
			*"$t"*"$t"*"$t"*)
				echo >&2 "$0: -u '$2': too many fields"
				exit 1;;
			*"$t"*"$t"*)
				uf="[^$t]*$t" # An unselected field, followed by a separator.
				sf="\\([^$t]*\\)" # The selected field.
				login=`expr "X$2" : "X$sf"`
				lfm="$login$tab"`
					expr "X$2" : "$uf$sf"
				  `"$tab"`
					expr "X$2" : "$uf$uf$sf"
				`;;
			*)
				echo >&2 "$0: -u '$2': not enough fields"
				exit 1;;
			esac
			shift;;
		esac
		case $logins in
		'') logins=$login;;
		?*) logins=$logins$nl$login;;
		esac
		case $loginFullnameMailaddrs in
		'') loginFullnameMailaddrs=$lfm;;
		?*) loginFullnameMailaddrs=$loginFullnameMailaddrs$nl$lfm;;
		esac;;
	-r)
		case $rlog_options in
		'') rlog_options=${2?};;
		?*) rlog_options=$rlog_options$nl${2?};;
		esac
		shift;;
	-R)	recursive=t;;
	-t)	tabwidth=${2?}; shift;;
	-v)	revision=t;;
	--version)
		set $Id
		rcs2logVersion=$3
		echo >&2 "rcs2log (GNU Emacs) $rcs2logVersion$nl$Copyright"
		exit 0;;
	-*)	echo >&2 "Usage: $0 [OPTION]... [FILE ...]$nl$Help"
		case $1 in
		--help) exit 0;;
		*) exit 1;;
		esac;;
	*)	break;;
	esac
	shift
done

month_data='
	m[0]="Jan"; m[1]="Feb"; m[2]="Mar"
	m[3]="Apr"; m[4]="May"; m[5]="Jun"
	m[6]="Jul"; m[7]="Aug"; m[8]="Sep"
	m[9]="Oct"; m[10]="Nov"; m[11]="Dec"
'

logdir=`/usr/bin/mktemp -d $TMPDIR/rcs2log.XXXXXXXXXX`
test -n "$logdir" || exit
llogout=$logdir/l
trap exit 1 2 13 15
trap "rm -fr $logdir 2>/dev/null" 0

# If no rlog-format log file is given, generate one into $rlogfile.
case $rlogfile in
'')
	rlogfile=$logdir/r

	# If no rlog options are given,
	# log the revisions checked in since the first ChangeLog entry.
	# Since ChangeLog is only by date, some of these revisions may be duplicates of
	# what's already in ChangeLog; it's the user's responsibility to remove them.
	case $rlog_options in
	'')
		if test -s "$changelog"
		then
			e='
				/^[0-9]+-[0-9][0-9]-[0-9][0-9]/{
					# ISO 8601 date
					print $1
					exit
				}
				/^... ... [ 0-9][0-9] [ 0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9]+ /{
					# old-fashioned date and time (Emacs 19.31 and earlier)
					'"$month_data"'
					year = $5
					for (i=0; i<=11; i++) if (m[i] == $2) break
					dd = $3
					printf "%d-%02d-%02d\n", year, i+1, dd
					exit
				}
			'
			d=`$AWK "$e" <"$changelog"` || exit
			case $d in
			?*) datearg="-d>$d";;
			esac
		fi;;
	esac

	# Use TZ specified by ChangeLog local variable, if any.
	if test -s "$changelog"
	then
		extractTZ='
			/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*"\([^"]*\)".*/{
				s//\1/; p; q
			}
			/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*t.*/{
				s//UTC0/; p; q
			}
		'
		logTZ=`tail "$changelog" | sed -n "$extractTZ"`
		case $logTZ in
		?*) TZ=$logTZ; export TZ;;
		esac
	fi

	# If CVS is in use, examine its repository, not the normal RCS files.
	if test ! -f CVS/Repository
	then
		rlog=rlog
		repository=
	else
		rlog='cvs -q log'
		repository=`sed 1q <CVS/Repository` || exit
		test ! -f CVS/Root || CVSROOT=`cat <CVS/Root` || exit
		case $CVSROOT in
		*:/*:/*)
			echo >&2 "$0: $CVSROOT: CVSROOT has multiple ':/'s"
			exit 1;;
		*:/*)
			# remote repository
			pository=`expr "X$repository" : '.*:\(/.*\)'`;;
		*)
			# local repository
			case $repository in
			/*) ;;
			*) repository=${CVSROOT?}/$repository;;
			esac
			if test ! -d "$repository"
			then
				echo >&2 "$0: $repository: bad repository (see CVS/Repository)"
				exit 1
			fi
			pository=$repository;;
		esac

		# Ensure that $pository ends in exactly one slash.
		while :
		do
			case $pository in
			*//) pository=`expr "X$pository" : 'X\(.*\)/'`;;
			*/) break;;
			*) pository=$pository/; break;;
			esac
		done

	fi

	# Use $rlog's -zLT option, if $rlog supports it.
	case `$rlog -zLT 2>&1` in
	*' option'*) ;;
	*)
		case $rlog_options in
		'') rlog_options=-zLT;;
		?*) rlog_options=-zLT$nl$rlog_options;;
		esac;;
	esac

	# With no arguments, examine all files under the RCS directory.
	case $# in
	0)
		case $repository in
		'')
			oldIFS=$IFS
			IFS=$nl
			case $recursive in
			t)
				RCSdirs=`find . -name RCS -type d -print`
				filesFromRCSfiles='s|,v$||; s|/RCS/|/|; s|^\./||'
				files=`
					{
						case $RCSdirs in
						?*) find $RCSdirs \
								-type f \
								! -name '*_' \
								! -name ',*,' \
								! -name '.*_' \
								! -name .rcsfreeze.log \
								! -name .rcsfreeze.ver \
								-print;;
						esac
						find . -name '*,v' -print
					} |
					sort -u |
					sed "$filesFromRCSfiles"
				`;;
			*)
				files=
				for file in RCS/.* RCS/* .*,v *,v
				do
					case $file in
					RCS/. | RCS/.. | RCS/,*, | RCS/*_) continue;;
					RCS/.rcsfreeze.log | RCS/.rcsfreeze.ver) continue;;
					RCS/.\* | RCS/\* | .\*,v | \*,v) test -f "$file" || continue;;
					RCS/*,v | RCS/.*,v) ;;
					RCS/* | RCS/.*) test -f "$file" || continue;;
					esac
					case $files in
					'') files=$file;;
					?*) files=$files$nl$file;;
					esac
				done
				case $files in
				'') exit 0;;
				esac;;
			esac
			set x $files
			shift
			IFS=$oldIFS;;
		esac;;
	esac

	case $datearg in
	?*) $rlog $rlog_options "$datearg" ${1+"$@@"} >$rlogfile;;
	'') $rlog $rlog_options ${1+"$@@"} >$rlogfile;;
	esac || exit;;
esac


# Get the full name of each author the logs mention, and set initialize_fullname
# to awk code that initializes the `fullname' awk associative array.
# Warning: foreign authors (i.e. not known in the passwd file) are mishandled;
# you have to fix the resulting output by hand.

initialize_fullname=
initialize_mailaddr=

case $loginFullnameMailaddrs in
?*)
	case $loginFullnameMailaddrs in
	*\"* | *\\*)
		sed 's/["\\]/\\&/g' >$llogout <<EOF || exit
$loginFullnameMailaddrs
EOF
		loginFullnameMailaddrs=`cat $llogout`;;
	esac

	oldIFS=$IFS
	IFS=$nl
	for loginFullnameMailaddr in $loginFullnameMailaddrs
	do
		IFS=$tab
		set x $loginFullnameMailaddr
		login=$2
		fullname=$3
		mailaddr=$4
		initialize_fullname="$initialize_fullname
			fullname[\"$login\"] = \"$fullname\""
		initialize_mailaddr="$initialize_mailaddr
			mailaddr[\"$login\"] = \"$mailaddr\""
	done
	IFS=$oldIFS;;
esac

case $logins in
?*)
	sort -u -o $llogout <<EOF
$logins
EOF
	;;
'')
	: ;;
esac >$llogout || exit

output_authors='/^date: / {
	if ($2 ~ /^[0-9]*[-\/][0-9][0-9][-\/][0-9][0-9]$/ && $3 ~ /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9][-+0-9:]*;$/ && $4 == "author:" && $5 ~ /^[^;]*;$/) {
		print substr($5, 1, length($5)-1)
	}
}'
authors=`
	$AWK "$output_authors" <"$rlogfile" | sort -u | comm -23 - $llogout
`
case $authors in
?*)
	cat >$llogout <<EOF || exit
$authors
EOF
	initialize_author_script='s/["\\]/\\&/g; s/.*/author[\"&\"] = 1/'
	initialize_author=`sed -e "$initialize_author_script" <$llogout`
	awkscript='
		BEGIN {
			alphabet = "abcdefghijklmnopqrstuvwxyz"
			ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
			'"$initialize_author"'
		}
		{
			if (author[$1]) {
				fullname = $5
				if (fullname ~ /[0-9]+-[^(]*\([0-9]+\)$/) {
					# Remove the junk from fullnames like "0000-Admin(0000)".
					fullname = substr(fullname, index(fullname, "-") + 1)
					fullname = substr(fullname, 1, index(fullname, "(") - 1)
				}
				if (fullname ~ /,[^ ]/) {
					# Some sites put comma-separated junk after the fullname.
					# Remove it, but leave "Bill Gates, Jr" alone.
					fullname = substr(fullname, 1, index(fullname, ",") - 1)
				}
				abbr = index(fullname, "&")
				if (abbr) {
					a = substr($1, 1, 1)
					A = a
					i = index(alphabet, a)
					if (i) A = substr(ALPHABET, i, 1)
					fullname = substr(fullname, 1, abbr-1) A substr($1, 2) substr(fullname, abbr+1)
				}

				# Quote quotes and backslashes properly in full names.
				# Do not use gsub; traditional awk lacks it.
				quoted = ""
				rest = fullname
				for (;;) {
					p = index(rest, "\\")
					q = index(rest, "\"")
					if (p) {
						if (q && q<p) p = q
					} else {
						if (!q) break
						p = q
					}
					quoted = quoted substr(rest, 1, p-1) "\\" substr(rest, p, 1)
					rest = substr(rest, p+1)
				}

				printf "fullname[\"%s\"] = \"%s%s\"\n", $1, quoted, rest
				author[$1] = 0
			}
		}
	'

	initialize_fullname=`
		{
			(getent passwd $authors) ||
			(
				cat /etc/passwd
				for author in $authors
				do NIS_PATH= nismatch $author passwd.org_dir
				done
				ypmatch $authors passwd
			)
		} 2>/dev/null |
		$AWK -F: "$awkscript"
	`$initialize_fullname;;
esac


# Function to print a single log line.
# We don't use awk functions, to stay compatible with old awk versions.
# `Log' is the log message.
# `files' contains the affected files.
printlogline='{

	# Following the GNU coding standards, rewrite
	#	* file: (function): comment
	# to
	#	* file (function): comment
	if (Log ~ /^\([^)]*\): /) {
		i = index(Log, ")")
		filefunc = substr(Log, 1, i)
		while ((j = index(filefunc, "\n"))) {
			files = files " " substr(filefunc, 1, j-1)
			filefunc = substr(filefunc, j+1)
		}
		files = files " " filefunc
		Log = substr(Log, i+3)
	}

	# If "label: comment" is too long, break the line after the ":".
	sep = " "
	i = index(Log, "\n")
	if ('"$length"' <= '"$indent"' + 1 + length(files) + i) sep = "\n" indent_string

	# Print the label.
	printf "%s*%s:", indent_string, files

	# Print each line of the log.
	while (i) {
		logline = substr(Log, 1, i-1)
		if (logline ~ /[^'"$tab"' ]/) {
			printf "%s%s\n", sep, logline
		} else {
			print ""
		}
		sep = indent_string
		Log = substr(Log, i+1)
		i = index(Log, "\n")
	}
}'

# Pattern to match the `revision' line of rlog output.
rlog_revision_pattern='^revision [0-9]+\.[0-9]+(\.[0-9]+\.[0-9]+)*(['"$tab"' ]+locked by: [^'"$tab"' $,.0-9:;@@]*[^'"$tab"' $,:;@@][^'"$tab"' $,.0-9:;@@]*;)?['"$tab"' ]*$'

case $hostname in
'')
	hostname=`(
		hostname || uname -n || uuname -l || cat /etc/whoami
	) 2>/dev/null` || {
		echo >&2 "$0: cannot deduce hostname"
		exit 1
	}

	case $hostname in
	*.*) ;;
	*)
		domainname=`(domainname) 2>/dev/null` &&
		case $domainname in
		*.*) hostname=$hostname.$domainname;;
		esac;;
	esac;;
esac


# Process the rlog output, generating ChangeLog style entries.

# First, reformat the rlog output so that each line contains one log entry.
# Transliterate \n to SOH so that multiline entries fit on a single line.
# Discard irrelevant rlog output.
$AWK '
	BEGIN {
		pository = "'"$pository"'"
		SOH="'"$SOH"'"
	}
	/^RCS file: / {
		if (pository != "") {
			filename = substr($0, 11)
			if (substr(filename, 1, length(pository)) == pository) {
				filename = substr(filename, length(pository) + 1)
			}
			if (filename ~ /,v$/) {
				filename = substr(filename, 1, length(filename) - 2)
			}
			if (filename ~ /(^|\/)Attic\/[^\/]*$/) {
				i = length(filename)
				while (substr(filename, i, 1) != "/") i--
				filename = substr(filename, 1, i - 6) substr(filename, i + 1)
			}
		}
		rev = "?"
	}
	/^Working file: / { if (repository == "") filename = substr($0, 15) }
	/'"$rlog_revision_pattern"'/, /^(-----------*|===========*)$/ {
		line = $0
		if (line ~ /'"$rlog_revision_pattern"'/) {
			rev = $2
			next
		}
		if (line ~ /^date: [0-9][- +\/0-9:]*;/) {
			date = $2
			if (date ~ /\//) {
				# This is a traditional RCS format date YYYY/MM/DD.
				# Replace "/"s with "-"s to get ISO format.
				newdate = ""
				while ((i = index(date, "/")) != 0) {
					newdate = newdate substr(date, 1, i-1) "-"
					date = substr(date, i+1)
				}
				date = newdate date
			}
			time = substr($3, 1, length($3) - 1)
			author = substr($5, 1, length($5)-1)
			printf "%s%s%s%s%s%s%s%s%s%s", filename, SOH, rev, SOH, date, SOH, time, SOH, author, SOH
			rev = "?"
			next
		}
		if (line ~ /^branches: /) { next }
		if (line ~ /^(-----------*|===========*)$/) { print ""; next }
		if (line == "Initial revision" || line ~ /^file .+ was initially added on branch .+\.$/) {
			line = "New file."
		}
		printf "%s%s", line, SOH
	}
' <"$rlogfile" |

# Now each line is of the form
# FILENAME@@REVISION@@YYYY-MM-DD@@HH:MM:SS[+-TIMEZONE]@@AUTHOR@@LOG
#	where @@ stands for an SOH (octal code 001),
#	and each line of LOG is terminated by SOH instead of \n.
# Sort the log entries, first by date+time (in reverse order),
# then by author, then by log entry, and finally by file name and revision
# (just in case).
sort -t"$SOH" +2 -4r +4 +0 |

# Finally, reformat the sorted log entries.
$AWK -F"$SOH" '
	BEGIN {
		logTZ = "'"$logTZ"'"
		revision = "'"$revision"'"

		# Initialize the fullname and mailaddr associative arrays.
		'"$initialize_fullname"'
		'"$initialize_mailaddr"'

		# Initialize indent string.
		indent_string = ""
		i = '"$indent"'
		if (0 < '"$tabwidth"')
			for (;  '"$tabwidth"' <= i;  i -= '"$tabwidth"')
				indent_string = indent_string "\t"
		while (1 <= i--)
			indent_string = indent_string " "
	}

	{
		newlog = ""
		for (i = 6; i < NF; i++) newlog = newlog $i "\n"

		# Ignore log entries prefixed by "#".
		if (newlog ~ /^#/) { next }

		if (Log != newlog || date != $3 || author != $5) {

			# The previous log and this log differ.

			# Print the old log.
			if (date != "") '"$printlogline"'

			# Logs that begin with "{clumpname} " should be grouped together,
			# and the clumpname should be removed.
			# Extract the new clumpname from the log header,
			# and use it to decide whether to output a blank line.
			newclumpname = ""
			sep = "\n"
			if (date == "") sep = ""
			if (newlog ~ /^\{[^'"$tab"' }]*}['"$tab"' ]/) {
				i = index(newlog, "}")
				newclumpname = substr(newlog, 1, i)
				while (substr(newlog, i+1) ~ /^['"$tab"' ]/) i++
				newlog = substr(newlog, i+1)
				if (clumpname == newclumpname) sep = ""
			}
			printf sep
			clumpname = newclumpname

			# Get ready for the next log.
			Log = newlog
			if (files != "")
				for (i in filesknown)
					filesknown[i] = 0
			files = ""
		}
		if (date != $3  ||  author != $5) {
			# The previous date+author and this date+author differ.
			# Print the new one.
			date = $3
			time = $4
			author = $5

			zone = ""
			if (logTZ && ((i = index(time, "-")) || (i = index(time, "+"))))
				zone = " " substr(time, i)

			# Print "date[ timezone]  fullname  <email address>".
			# Get fullname and email address from associative arrays;
			# default to author and author@@hostname if not in arrays.
			if (fullname[author])
				auth = fullname[author]
			else
				auth = author
			printf "%s%s  %s  ", date, zone, auth
			if (mailaddr[author])
				printf "<%s>\n\n", mailaddr[author]
			else
				printf "<%s@@%s>\n\n", author, "'"$hostname"'"
		}
		if (! filesknown[$1]) {
			filesknown[$1] = 1
			if (files == "") files = " " $1
			else files = files ", " $1
			if (revision && $2 != "?") files = files " " $2
		}
	}
	END {
		# Print the last log.
		if (date != "") {
			'"$printlogline"'
			printf "\n"
		}
	}
' &&


# Exit successfully.

exec rm -fr $logdir

# Local Variables:
# tab-width:4
# End:
@


1.3
log
@update to cvs 1.12.10-MirOS except automatically
generated files
XXX this installs as /usr/bin/ncvs yet, so no
XXX conflicts during the test phase.
XXX I suggest to _not_ update.

XXX *** IMPORTANT *** DO NOT ACCESS CVS 1.11 REPOSITORIES
XXX *** IMPORTANT *** WITH CVS 1.12 OR VICE VERSA!
@
text
@d32 1
a32 1
Id='$Id: rcs2log.sh,v 1.2 2004/11/21 20:52:16 tg Exp $'
@


1.2
log
@cvs-1.11.12 doesn't do the joints correctly (what were the
FSF people smoking?), it memory faults.
thusly revert to 1.11.1p1

tested.
agreed bsiegert@@
@
text
@d21 1
d32 1
a32 1
Id='$Id: rcs2log.sh,v 1.1 2003/03/22 17:41:23 tg Exp $'
d34 2
a35 1
# Copyright 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
d52 1
a52 1
Copyright='Copyright 1998 Free Software Foundation, Inc.
d59 16
d84 1
d96 1
d106 1
d112 1
a112 5
				exit 1
			esac
			case $loginFullnameMailaddrs in
			'') loginFullnameMailaddrs=$2$tab$3$tab$4;;
			?*) loginFullnameMailaddrs=$loginFullnameMailaddrs$nl$2$tab$3$tab$4
d114 2
d126 1
a126 1
				t=:
d133 8
a140 1
				;;
d143 1
a143 5
				exit 1
			esac
			case $loginFullnameMailaddrs in
			'') loginFullnameMailaddrs=$2;;
			?*) loginFullnameMailaddrs=$loginFullnameMailaddrs$nl$2
d145 1
a145 1
			shift
d149 1
a149 1
		?*) logins=$logins$nl$login
d151 4
a154 1
		;;
d158 1
a158 1
		?*) rlog_options=$rlog_options$nl${2?}
d172 1
a172 1
		*) exit 1
d174 1
a174 1
	*)	break
d186 10
d197 30
a226 1
# Put rlog output into $rlogout.
d228 1
a228 6
# If no rlog options are given,
# log the revisions checked in since the first ChangeLog entry.
# Since ChangeLog is only by date, some of these revisions may be duplicates of
# what's already in ChangeLog; it's the user's responsibility to remove them.
case $rlog_options in
'')
d231 3
a233 5
		e='
			/^[0-9]+-[0-9][0-9]-[0-9][0-9]/{
				# ISO 8601 date
				print $1
				exit
d235 2
a236 8
			/^... ... [ 0-9][0-9] [ 0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9]+ /{
				# old-fashioned date and time (Emacs 19.31 and earlier)
				'"$month_data"'
				year = $5
				for (i=0; i<=11; i++) if (m[i] == $2) break
				dd = $3
				printf "%d-%02d-%02d\n", year, i+1, dd
				exit
d239 3
a241 3
		d=`$AWK "$e" <"$changelog"` || exit
		case $d in
		?*) datearg="-d>$d"
a243 1
esac
d245 41
a285 16
# Use TZ specified by ChangeLog local variable, if any.
if test -s "$changelog"
then
	extractTZ='
		/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*"\([^"]*\)".*/{
			s//\1/; p; q
		}
		/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*t.*/{
			s//UTC0/; p; q
		}
	'
	logTZ=`tail "$changelog" | sed -n "$extractTZ"`
	case $logTZ in
	?*) TZ=$logTZ; export TZ
	esac
fi
d287 3
a289 13
# If CVS is in use, examine its repository, not the normal RCS files.
if test ! -f CVS/Repository
then
	rlog=rlog
	repository=
else
	rlog='cvs -q log'
	repository=`sed 1q <CVS/Repository` || exit
	test ! -f CVS/Root || CVSROOT=`cat <CVS/Root` || exit
	case $CVSROOT in
	*:/*)
		# remote repository
		;;
d291 4
a294 10
		# local repository
		case $repository in
		/*) ;;
		*) repository=${CVSROOT?}/$repository
		esac
		if test ! -d "$repository"
		then
			echo >&2 "$0: $repository: bad repository (see CVS/Repository)"
			exit 1
		fi
a295 1
fi
d297 42
a338 32
# Use $rlog's -zLT option, if $rlog supports it.
case `$rlog -zLT 2>&1` in
*' option'*) ;;
*)
	case $rlog_options in
	'') rlog_options=-zLT;;
	?*) rlog_options=-zLT$nl$rlog_options
	esac
esac

# With no arguments, examine all files under the RCS directory.
case $# in
0)
	case $repository in
	'')
		oldIFS=$IFS
		IFS=$nl
		case $recursive in
		t)
			RCSdirs=`find . -name RCS -type d -print`
			filesFromRCSfiles='s|,v$||; s|/RCS/|/|; s|^\./||'
			files=`
				{
					case $RCSdirs in
					?*) find $RCSdirs \
							-type f \
							! -name '*_' \
							! -name ',*,' \
							! -name '.*_' \
							! -name .rcsfreeze.log \
							! -name .rcsfreeze.ver \
							-print
d340 1
a340 16
					find . -name '*,v' -print
				} |
				sort -u |
				sed "$filesFromRCSfiles"
			`;;
		*)
			files=
			for file in RCS/.* RCS/* .*,v *,v
			do
				case $file in
				RCS/. | RCS/.. | RCS/,*, | RCS/*_) continue;;
				RCS/.rcsfreeze.log | RCS/.rcsfreeze.ver) continue;;
				RCS/.\* | RCS/\* | .\*,v | \*,v) test -f "$file" || continue;;
				RCS/*,v | RCS/.*,v) ;;
				RCS/* | RCS/.*) test -f "$file" || continue
				esac
d342 2
a343 6
				'') files=$file;;
				?*) files=$files$nl$file
				esac
			done
			case $files in
			'') exit 0
d345 4
a348 4
		esac
		set x $files
		shift
		IFS=$oldIFS
d350 5
a356 13
llogout=`mktemp $TMPDIR/rcs2log_l.XXXXXXXXXX` || exit 1
rlogout=`mktemp $TMPDIR/rcs2log_r.XXXXXXXXXX` || {
	rm -f $llogout
	exit 1
}
trap exit 1 2 13 15
trap "rm -f $llogout $rlogout; exit 1" 0

case $datearg in
?*) $rlog $rlog_options "$datearg" ${1+"$@@"} >$rlogout;;
'') $rlog $rlog_options ${1+"$@@"} >$rlogout
esac || exit

d373 1
a373 1
		loginFullnameMailaddrs=`cat $llogout`
d380 1
a380 4
		case $loginFullnameMailaddr in
		*"$tab"*) IFS=$tab;;
		*) IFS=:
		esac
d390 1
a390 1
	IFS=$oldIFS
d393 3
a395 2
case $llogout in
?*) sort -u -o $llogout <<EOF || exit
d398 5
a402 1
esac
d409 1
a409 5
	$AWK "$output_authors" <$rlogout |
	case $llogout in
	'') sort -u;;
	?*) sort -u | comm -23 - $llogout
	esac
d481 1
a481 1
	`$initialize_fullname
d487 1
a487 1
# `Log' is the log message (with \n replaced by \001).
d497 6
a502 1
		files = files " " substr(Log, 1, i)
d508 2
a509 1
	if ('"$length"' <= '"$indent"' + 1 + length(files) + index(Log, SOH)) sep = "\n" indent_string
d514 2
a515 2
	# Print each line of the log, transliterating \001 to \n.
	while ((i = index(Log, SOH)) != 0) {
d524 1
d545 3
a547 3
		*.*) hostname=$hostname.$domainname
		esac
	esac
d554 1
a554 1
# Transliterate \n to \001 so that multiline entries fit on a single line.
d556 10
a565 7
$AWK <$rlogout '
	BEGIN { repository = "'"$repository"'" }
	/^RCS file:/ {
		if (repository != "") {
			filename = $3
			if (substr(filename, 1, length(repository) + 1) == repository "/") {
				filename = substr(filename, length(repository) + 2)
d578 1
a578 1
	/^Working file:/ { if (repository == "") filename = $3 }
d599 1
a599 1
			printf "%s %s %s %s %s %c", filename, rev, date, time, author, 1
d608 1
a608 1
		printf "%s%c", line, 1
d610 1
a610 1
' |
d613 3
a615 3
# FILENAME REVISION YYYY-MM-DD HH:MM:SS[+-TIMEZONE] AUTHOR \001LOG
#	where \001 stands for a carriage return,
#	and each line of the log is terminated by \001 instead of \n.
d619 1
a619 1
sort +2 -4r +4 +0 |
d622 1
a622 1
$AWK '
a626 4
		# Some awk variants do not understand "\001", so we have to
		# put the char directly in the file.
		SOH="" # <-- There is a single SOH (octal code 001) here.

d642 2
a643 1
		newlog = substr($0, 1 + index($0, SOH))
d722 1
a722 1
exec rm -f $llogout $rlogout
@


1.1
log
@Initial revision
@
text
@d31 1
a31 1
Id='$Id: rcs2log.sh,v 1.2 2001/08/07 22:00:56 millert Exp $'
@


1.1.2.1
log
@vendor-branch-ify new cvs 1.12
@
text
@a20 1
  -L FILE  Use rlog-format FILE for source of logs.
d31 1
a31 1
Id='$Id: rcs2log.sh,v 1.1.2.1 2004/11/20 23:59:51 tg Exp $'
d33 1
a33 2
# Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2001, 2003
#  Free Software Foundation, Inc.
d50 1
a50 1
Copyright='Copyright 1992-2003 Free Software Foundation, Inc.
a56 19
# functions
@@MKTEMP_SH_FUNCTION@@

# Use the traditional C locale.
LANG=C
LANGUAGE=C
LC_ALL=C
LC_COLLATE=C
LC_CTYPE=C
LC_MESSAGES=C
LC_NUMERIC=C
LC_TIME=C
export LANG LANGUAGE LC_ALL LC_COLLATE LC_CTYPE LC_MESSAGES LC_NUMERIC LC_TIME

# These variables each contain a single ASCII character.
# Unfortunately, there's no portable way of writing these characters
# in older Unix implementations, other than putting them directly into
# this text file.
SOH='' # SOH, octal code 001
a63 1
: ${MKTEMP="@@MKTEMP@@"}
a65 1

a76 1
rlogfile= # log file to read from
a85 1
	-L)	rlogfile=${2?}; shift;;
d91 5
a95 1
				exit 1;;
a96 2
			login=$2
			lfm=$2$tab$3$tab$4
d107 1
a107 1
				t=':';;
d114 1
a114 8
				uf="[^$t]*$t" # An unselected field, followed by a separator.
				sf="\\([^$t]*\\)" # The selected field.
				login=`expr "X$2" : "X$sf"`
				lfm="$login$tab"`
					expr "X$2" : "$uf$sf"
				  `"$tab"`
					expr "X$2" : "$uf$uf$sf"
				`;;
d117 5
a121 1
				exit 1;;
d123 1
a123 1
			shift;;
d127 1
a127 1
		?*) logins=$logins$nl$login;;
d129 1
a129 4
		case $loginFullnameMailaddrs in
		'') loginFullnameMailaddrs=$lfm;;
		?*) loginFullnameMailaddrs=$loginFullnameMailaddrs$nl$lfm;;
		esac;;
d133 1
a133 1
		?*) rlog_options=$rlog_options$nl${2?};;
d147 1
a147 1
		*) exit 1;;
d149 1
a149 1
	*)	break;;
a160 5
logdir=`$MKTEMP -d $TMPDIR/rcs2log.XXXXXX`
test -n "$logdir" || exit
llogout=$logdir/l
trap exit 1 2 13 15
trap "rm -fr $logdir 2>/dev/null" 0
d162 7
a168 2
# If no rlog-format log file is given, generate one into $rlogfile.
case $rlogfile in
a169 34
	rlogfile=$logdir/r

	# If no rlog options are given,
	# log the revisions checked in since the first ChangeLog entry.
	# Since ChangeLog is only by date, some of these revisions may be duplicates of
	# what's already in ChangeLog; it's the user's responsibility to remove them.
	case $rlog_options in
	'')
		if test -s "$changelog"
		then
			e='
				/^[0-9]+-[0-9][0-9]-[0-9][0-9]/{
					# ISO 8601 date
					print $1
					exit
				}
				/^... ... [ 0-9][0-9] [ 0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9]+ /{
					# old-fashioned date and time (Emacs 19.31 and earlier)
					'"$month_data"'
					year = $5
					for (i=0; i<=11; i++) if (m[i] == $2) break
					dd = $3
					printf "%d-%02d-%02d\n", year, i+1, dd
					exit
				}
			'
			d=`$AWK "$e" <"$changelog"` || exit
			case $d in
			?*) datearg="-d>$d";;
			esac
		fi;;
	esac

	# Use TZ specified by ChangeLog local variable, if any.
d172 5
a176 3
		extractTZ='
			/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*"\([^"]*\)".*/{
				s//\1/; p; q
d178 8
a185 2
			/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*t.*/{
				s//UTC0/; p; q
d188 3
a190 3
		logTZ=`tail "$changelog" | sed -n "$extractTZ"`
		case $logTZ in
		?*) TZ=$logTZ; export TZ;;
d193 18
d212 18
a229 28
	# If CVS is in use, examine its repository, not the normal RCS files.
	if test ! -f CVS/Repository
	then
		rlog=rlog
		repository=
	else
		rlog='cvs -q log'
		repository=`sed 1q <CVS/Repository` || exit
		test ! -f CVS/Root || CVSROOT=`cat <CVS/Root` || exit
		case $CVSROOT in
		*:/*:/*)
			echo >&2 "$0: $CVSROOT: CVSROOT has multiple ':/'s"
			exit 1;;
		*:/*)
			# remote repository
			pository=`expr "X$repository" : '.*:\(/.*\)'`;;
		*)
			# local repository
			case $repository in
			/*) ;;
			*) repository=${CVSROOT?}/$repository;;
			esac
			if test ! -d "$repository"
			then
				echo >&2 "$0: $repository: bad repository (see CVS/Repository)"
				exit 1
			fi
			pository=$repository;;
d231 7
d239 7
a245 20
		# Ensure that $pository ends in exactly one slash.
		while :
		do
			case $pository in
			*//) pository=`expr "X$pository" : 'X\(.*\)/'`;;
			*/) break;;
			*) pository=$pository/; break;;
			esac
		done

	fi

	# Use $rlog's -zLT option, if $rlog supports it.
	case `$rlog -zLT 2>&1` in
	*' option'*) ;;
	*)
		case $rlog_options in
		'') rlog_options=-zLT;;
		?*) rlog_options=-zLT$nl$rlog_options;;
		esac;;
d247 1
d249 22
a270 38
	# With no arguments, examine all files under the RCS directory.
	case $# in
	0)
		case $repository in
		'')
			oldIFS=$IFS
			IFS=$nl
			case $recursive in
			t)
				RCSdirs=`find . -name RCS -type d -print`
				filesFromRCSfiles='s|,v$||; s|/RCS/|/|; s|^\./||'
				files=`
					{
						case $RCSdirs in
						?*) find $RCSdirs \
								-type f \
								! -name '*_' \
								! -name ',*,' \
								! -name '.*_' \
								! -name .rcsfreeze.log \
								! -name .rcsfreeze.ver \
								-print;;
						esac
						find . -name '*,v' -print
					} |
					sort -u |
					sed "$filesFromRCSfiles"
				`;;
			*)
				files=
				for file in RCS/.* RCS/* .*,v *,v
				do
					case $file in
					RCS/. | RCS/.. | RCS/,*, | RCS/*_) continue;;
					RCS/.rcsfreeze.log | RCS/.rcsfreeze.ver) continue;;
					RCS/.\* | RCS/\* | .\*,v | \*,v) test -f "$file" || continue;;
					RCS/*,v | RCS/.*,v) ;;
					RCS/* | RCS/.*) test -f "$file" || continue;;
d272 16
a287 5
					case $files in
					'') files=$file;;
					?*) files=$files$nl$file;;
					esac
				done
d289 6
a294 2
				'') exit 0;;
				esac;;
d296 4
a299 4
			set x $files
			shift
			IFS=$oldIFS;;
		esac;;
d301 1
d303 12
a314 5
	case $datearg in
	?*) $rlog $rlog_options "$datearg" ${1+"$@@"} >$rlogfile;;
	'') $rlog $rlog_options ${1+"$@@"} >$rlogfile;;
	esac || exit;;
esac
d332 1
a332 1
		loginFullnameMailaddrs=`cat $llogout`;;
d339 4
a342 1
		IFS=$tab
d352 1
a352 1
	IFS=$oldIFS;;
d355 2
a356 3
case $logins in
?*)
	sort -u -o $llogout <<EOF
d359 1
a359 5
	;;
'')
	: ;;
esac >$llogout || exit

d366 5
a370 1
	$AWK "$output_authors" <"$rlogfile" | sort -u | comm -23 - $llogout
d442 1
a442 1
	`$initialize_fullname;;
d448 1
a448 1
# `Log' is the log message.
d458 1
a458 6
		filefunc = substr(Log, 1, i)
		while ((j = index(filefunc, "\n"))) {
			files = files " " substr(filefunc, 1, j-1)
			filefunc = substr(filefunc, j+1)
		}
		files = files " " filefunc
d464 1
a464 2
	i = index(Log, "\n")
	if ('"$length"' <= '"$indent"' + 1 + length(files) + i) sep = "\n" indent_string
d469 2
a470 2
	# Print each line of the log.
	while (i) {
a478 1
		i = index(Log, "\n")
d499 3
a501 3
		*.*) hostname=$hostname.$domainname;;
		esac;;
	esac;;
d508 1
a508 1
# Transliterate \n to SOH so that multiline entries fit on a single line.
d510 7
a516 10
$AWK '
	BEGIN {
		pository = "'"$pository"'"
		SOH="'"$SOH"'"
	}
	/^RCS file: / {
		if (pository != "") {
			filename = substr($0, 11)
			if (substr(filename, 1, length(pository)) == pository) {
				filename = substr(filename, length(pository) + 1)
d529 1
a529 1
	/^Working file: / { if (repository == "") filename = substr($0, 15) }
d550 1
a550 1
			printf "%s%s%s%s%s%s%s%s%s%s", filename, SOH, rev, SOH, date, SOH, time, SOH, author, SOH
d559 1
a559 1
		printf "%s%s", line, SOH
d561 1
a561 1
' <"$rlogfile" |
d564 3
a566 3
# FILENAME@@REVISION@@YYYY-MM-DD@@HH:MM:SS[+-TIMEZONE]@@AUTHOR@@LOG
#	where @@ stands for an SOH (octal code 001),
#	and each line of LOG is terminated by SOH instead of \n.
d570 1
a570 1
sort -t"$SOH" +2 -4r +4 +0 |
d573 1
a573 1
$AWK -F"$SOH" '
d578 4
d597 1
a597 2
		newlog = ""
		for (i = 6; i < NF; i++) newlog = newlog $i "\n"
d676 1
a676 1
exec rm -fr $logdir
@


1.1.2.2
log
@GNU CVS 1.12.11
@
text
@d32 1
a32 1
Id='$Id: rcs2log,v 1.48 2001/09/05 23:07:46 eggert Exp $'
@


1.1.3.1
log
@our CVS is currently at 1.11.1p1, thus import that version into vendor branch
@
text
@d31 1
a31 1
Id='$Id: rcs2log,v 1.45 1998/08/12 22:33:01 eggert Exp $'
d303 5
a307 2
llogout=$TMPDIR/rcs2log$$l
rlogout=$TMPDIR/rcs2log$$r
@


1.1.3.2
log
@CVS 1.11.12 is the latest stable version of CVS,
released 06.02.2004, with a huge lot of bug fixes.

/me hopes this will pay off...
@
text
@a20 1
  -L FILE  Use rlog-format FILE for source of logs.
d31 1
a31 1
Id='$Id: rcs2log,v 1.48 2001/09/05 23:07:46 eggert Exp $'
d33 1
a33 2
# Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2001, 2003
#  Free Software Foundation, Inc.
d50 1
a50 1
Copyright='Copyright 1992-2003 Free Software Foundation, Inc.
a56 19
# functions
@@MKTEMP_SH_FUNCTION@@

# Use the traditional C locale.
LANG=C
LANGUAGE=C
LC_ALL=C
LC_COLLATE=C
LC_CTYPE=C
LC_MESSAGES=C
LC_NUMERIC=C
LC_TIME=C
export LANG LANGUAGE LC_ALL LC_COLLATE LC_CTYPE LC_MESSAGES LC_NUMERIC LC_TIME

# These variables each contain a single ASCII character.
# Unfortunately, there's no portable way of writing these characters
# in older Unix implementations, other than putting them directly into
# this text file.
SOH='' # SOH, octal code 001
a63 1
: ${MKTEMP="@@MKTEMP@@"}
a65 1

a76 1
rlogfile= # log file to read from
a85 1
	-L)	rlogfile=${2?}; shift;;
d91 5
a95 1
				exit 1;;
a96 2
			login=$2
			lfm=$2$tab$3$tab$4
d107 1
a107 1
				t=':';;
d114 1
a114 8
				uf="[^$t]*$t" # An unselected field, followed by a separator.
				sf="\\([^$t]*\\)" # The selected field.
				login=`expr "X$2" : "X$sf"`
				lfm="$login$tab"`
					expr "X$2" : "$uf$sf"
				  `"$tab"`
					expr "X$2" : "$uf$uf$sf"
				`;;
d117 5
a121 1
				exit 1;;
d123 1
a123 1
			shift;;
d127 1
a127 1
		?*) logins=$logins$nl$login;;
d129 1
a129 4
		case $loginFullnameMailaddrs in
		'') loginFullnameMailaddrs=$lfm;;
		?*) loginFullnameMailaddrs=$loginFullnameMailaddrs$nl$lfm;;
		esac;;
d133 1
a133 1
		?*) rlog_options=$rlog_options$nl${2?};;
d147 1
a147 1
		*) exit 1;;
d149 1
a149 1
	*)	break;;
a160 5
logdir=`$MKTEMP -d $TMPDIR/rcs2log.XXXXXX`
test -n "$logdir" || exit
llogout=$logdir/l
trap exit 1 2 13 15
trap "rm -fr $logdir 2>/dev/null" 0
d162 7
a168 2
# If no rlog-format log file is given, generate one into $rlogfile.
case $rlogfile in
a169 34
	rlogfile=$logdir/r

	# If no rlog options are given,
	# log the revisions checked in since the first ChangeLog entry.
	# Since ChangeLog is only by date, some of these revisions may be duplicates of
	# what's already in ChangeLog; it's the user's responsibility to remove them.
	case $rlog_options in
	'')
		if test -s "$changelog"
		then
			e='
				/^[0-9]+-[0-9][0-9]-[0-9][0-9]/{
					# ISO 8601 date
					print $1
					exit
				}
				/^... ... [ 0-9][0-9] [ 0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9]+ /{
					# old-fashioned date and time (Emacs 19.31 and earlier)
					'"$month_data"'
					year = $5
					for (i=0; i<=11; i++) if (m[i] == $2) break
					dd = $3
					printf "%d-%02d-%02d\n", year, i+1, dd
					exit
				}
			'
			d=`$AWK "$e" <"$changelog"` || exit
			case $d in
			?*) datearg="-d>$d";;
			esac
		fi;;
	esac

	# Use TZ specified by ChangeLog local variable, if any.
d172 5
a176 3
		extractTZ='
			/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*"\([^"]*\)".*/{
				s//\1/; p; q
d178 8
a185 2
			/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*t.*/{
				s//UTC0/; p; q
d188 3
a190 3
		logTZ=`tail "$changelog" | sed -n "$extractTZ"`
		case $logTZ in
		?*) TZ=$logTZ; export TZ;;
d193 18
d212 18
a229 28
	# If CVS is in use, examine its repository, not the normal RCS files.
	if test ! -f CVS/Repository
	then
		rlog=rlog
		repository=
	else
		rlog='cvs -q log'
		repository=`sed 1q <CVS/Repository` || exit
		test ! -f CVS/Root || CVSROOT=`cat <CVS/Root` || exit
		case $CVSROOT in
		*:/*:/*)
			echo >&2 "$0: $CVSROOT: CVSROOT has multiple ':/'s"
			exit 1;;
		*:/*)
			# remote repository
			pository=`expr "X$repository" : '.*:\(/.*\)'`;;
		*)
			# local repository
			case $repository in
			/*) ;;
			*) repository=${CVSROOT?}/$repository;;
			esac
			if test ! -d "$repository"
			then
				echo >&2 "$0: $repository: bad repository (see CVS/Repository)"
				exit 1
			fi
			pository=$repository;;
d231 7
d239 7
a245 20
		# Ensure that $pository ends in exactly one slash.
		while :
		do
			case $pository in
			*//) pository=`expr "X$pository" : 'X\(.*\)/'`;;
			*/) break;;
			*) pository=$pository/; break;;
			esac
		done

	fi

	# Use $rlog's -zLT option, if $rlog supports it.
	case `$rlog -zLT 2>&1` in
	*' option'*) ;;
	*)
		case $rlog_options in
		'') rlog_options=-zLT;;
		?*) rlog_options=-zLT$nl$rlog_options;;
		esac;;
d247 1
d249 22
a270 38
	# With no arguments, examine all files under the RCS directory.
	case $# in
	0)
		case $repository in
		'')
			oldIFS=$IFS
			IFS=$nl
			case $recursive in
			t)
				RCSdirs=`find . -name RCS -type d -print`
				filesFromRCSfiles='s|,v$||; s|/RCS/|/|; s|^\./||'
				files=`
					{
						case $RCSdirs in
						?*) find $RCSdirs \
								-type f \
								! -name '*_' \
								! -name ',*,' \
								! -name '.*_' \
								! -name .rcsfreeze.log \
								! -name .rcsfreeze.ver \
								-print;;
						esac
						find . -name '*,v' -print
					} |
					sort -u |
					sed "$filesFromRCSfiles"
				`;;
			*)
				files=
				for file in RCS/.* RCS/* .*,v *,v
				do
					case $file in
					RCS/. | RCS/.. | RCS/,*, | RCS/*_) continue;;
					RCS/.rcsfreeze.log | RCS/.rcsfreeze.ver) continue;;
					RCS/.\* | RCS/\* | .\*,v | \*,v) test -f "$file" || continue;;
					RCS/*,v | RCS/.*,v) ;;
					RCS/* | RCS/.*) test -f "$file" || continue;;
d272 16
a287 5
					case $files in
					'') files=$file;;
					?*) files=$files$nl$file;;
					esac
				done
d289 6
a294 2
				'') exit 0;;
				esac;;
d296 4
a299 4
			set x $files
			shift
			IFS=$oldIFS;;
		esac;;
d301 1
d303 9
a311 5
	case $datearg in
	?*) $rlog $rlog_options "$datearg" ${1+"$@@"} >$rlogfile;;
	'') $rlog $rlog_options ${1+"$@@"} >$rlogfile;;
	esac || exit;;
esac
d329 1
a329 1
		loginFullnameMailaddrs=`cat $llogout`;;
d336 4
a339 1
		IFS=$tab
d349 1
a349 1
	IFS=$oldIFS;;
d352 2
a353 3
case $logins in
?*)
	sort -u -o $llogout <<EOF
d356 1
a356 5
	;;
'')
	: ;;
esac >$llogout || exit

d363 5
a367 1
	$AWK "$output_authors" <"$rlogfile" | sort -u | comm -23 - $llogout
d439 1
a439 1
	`$initialize_fullname;;
d445 1
a445 1
# `Log' is the log message.
d455 1
a455 6
		filefunc = substr(Log, 1, i)
		while ((j = index(filefunc, "\n"))) {
			files = files " " substr(filefunc, 1, j-1)
			filefunc = substr(filefunc, j+1)
		}
		files = files " " filefunc
d461 1
a461 2
	i = index(Log, "\n")
	if ('"$length"' <= '"$indent"' + 1 + length(files) + i) sep = "\n" indent_string
d466 2
a467 2
	# Print each line of the log.
	while (i) {
a475 1
		i = index(Log, "\n")
d496 3
a498 3
		*.*) hostname=$hostname.$domainname;;
		esac;;
	esac;;
d505 1
a505 1
# Transliterate \n to SOH so that multiline entries fit on a single line.
d507 7
a513 10
$AWK '
	BEGIN {
		pository = "'"$pository"'"
		SOH="'"$SOH"'"
	}
	/^RCS file: / {
		if (pository != "") {
			filename = substr($0, 11)
			if (substr(filename, 1, length(pository)) == pository) {
				filename = substr(filename, length(pository) + 1)
d526 1
a526 1
	/^Working file: / { if (repository == "") filename = substr($0, 15) }
d547 1
a547 1
			printf "%s%s%s%s%s%s%s%s%s%s", filename, SOH, rev, SOH, date, SOH, time, SOH, author, SOH
d556 1
a556 1
		printf "%s%s", line, SOH
d558 1
a558 1
' <"$rlogfile" |
d561 3
a563 3
# FILENAME@@REVISION@@YYYY-MM-DD@@HH:MM:SS[+-TIMEZONE]@@AUTHOR@@LOG
#	where @@ stands for an SOH (octal code 001),
#	and each line of LOG is terminated by SOH instead of \n.
d567 1
a567 1
sort -t"$SOH" +2 -4r +4 +0 |
d570 1
a570 1
$AWK -F"$SOH" '
d575 4
d594 1
a594 2
		newlog = ""
		for (i = 6; i < NF; i++) newlog = newlog $i "\n"
d673 1
a673 1
exec rm -fr $logdir
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
