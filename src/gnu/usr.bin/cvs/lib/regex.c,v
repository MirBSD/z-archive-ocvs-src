head	1.4;
access;
symbols
	cvs-1_12_11:1.1.2.1
	tg-mergetmp-mirosx-1:1.4
	tg-mergefixes-1-branch:1.4.0.4
	tg-mergefixes-1-base:1.4
	MIROS_X:1.4.0.2
	MIROS_X_BASE:1.4
	cvs-1_12_10:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_MIRPPC:1.3.0.4
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200404170130:1.1.1.1
	cvs-1_11_12:1.1.3.2
	cvs-1_11_1p1:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.12.02.12.40.00;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.22.13.49.12;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.02.12.21.16.00;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.24;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.41.24;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2004.12.02.11.58.33;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.02.12.19.24.23;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.12.19.44.07;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@update to cvs 1.12.10-MirOS except automatically
generated files
XXX this installs as /usr/bin/ncvs yet, so no
XXX conflicts during the test phase.
XXX I suggest to _not_ update.

XXX *** IMPORTANT *** DO NOT ACCESS CVS 1.11 REPOSITORIES
XXX *** IMPORTANT *** WITH CVS 1.12 OR VICE VERSA!
@
text
@/* Extended regular expression matching and search library,
   version 0.12.
   (Implements POSIX draft P1003.2/D11.2, except for some of the
   internationalization features.)

   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* AIX requires this to be the first thing in the file. */
#if defined _AIX && !defined REGEX_MALLOC
  #pragma alloca
#endif

#undef	_GNU_SOURCE
#define _GNU_SOURCE

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#ifndef INSIDE_RECURSION

# include <stddef.h>

# define WIDE_CHAR_SUPPORT (HAVE_WCTYPE_H && HAVE_WCHAR_H && HAVE_BTOWC)

/* For platform which support the ISO C amendement 1 functionality we
   support user defined character classes.  */
# if defined _LIBC || WIDE_CHAR_SUPPORT
/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
#  include <wchar.h>
#  include <wctype.h>
# endif

# ifdef _LIBC
/* We have to keep the namespace clean.  */
#  define regfree(preg) __regfree (preg)
#  define regexec(pr, st, nm, pm, ef) __regexec (pr, st, nm, pm, ef)
#  define regcomp(preg, pattern, cflags) __regcomp (preg, pattern, cflags)
#  define regerror(errcode, preg, errbuf, errbuf_size) \
	__regerror(errcode, preg, errbuf, errbuf_size)
#  define re_set_registers(bu, re, nu, st, en) \
	__re_set_registers (bu, re, nu, st, en)
#  define re_match_2(bufp, string1, size1, string2, size2, pos, regs, stop) \
	__re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
#  define re_match(bufp, string, size, pos, regs) \
	__re_match (bufp, string, size, pos, regs)
#  define re_search(bufp, string, size, startpos, range, regs) \
	__re_search (bufp, string, size, startpos, range, regs)
#  define re_compile_pattern(pattern, length, bufp) \
	__re_compile_pattern (pattern, length, bufp)
#  define re_set_syntax(syntax) __re_set_syntax (syntax)
#  define re_search_2(bufp, st1, s1, st2, s2, startpos, range, regs, stop) \
	__re_search_2 (bufp, st1, s1, st2, s2, startpos, range, regs, stop)
#  define re_compile_fastmap(bufp) __re_compile_fastmap (bufp)

#  define btowc __btowc
#  define iswctype __iswctype
#  define mbrtowc __mbrtowc
#  define wcslen __wcslen
#  define wcscoll __wcscoll
#  define wcrtomb __wcrtomb

/* We are also using some library internals.  */
#  include <locale/localeinfo.h>
#  include <locale/elem-hash.h>
#  include <langinfo.h>
#  include <locale/coll-lookup.h>
# endif

# ifdef _LIBC
#  include <libintl.h>
#  undef gettext
#  define gettext(msgid) __dcgettext ("libc", msgid, LC_MESSAGES)
   /* This define is so xgettext can find the internationalizable strings.  */
#  define gettext_noop(msgid) msgid
# else
/* This is for other GNU distributions with internationalized messages.  */
#  include "gettext.h"
# endif

/* Support for bounded pointers.  */
# if !defined _LIBC && !defined __BOUNDED_POINTERS__
#  define __bounded	/* nothing */
#  define __unbounded	/* nothing */
#  define __ptrvalue	/* nothing */
# endif

/* The `emacs' switch turns on certain matching commands
   that make sense only in Emacs. */
# ifdef emacs

#  include "lisp.h"
#  include "buffer.h"
#  include "syntax.h"

# else  /* not emacs */

/* If we are not linking with Emacs proper,
   we can't use the relocating allocator
   even if config.h says that we can.  */
#  undef REL_ALLOC

#  include <stdlib.h>

/* When used in Emacs's lib-src, we need to get bzero and bcopy somehow.
   If nothing else has been done, use the method below.  */
#  ifdef INHIBIT_STRING_HEADER
#   if !(defined HAVE_BZERO && defined HAVE_BCOPY)
#    if !defined bzero && !defined bcopy
#     undef INHIBIT_STRING_HEADER
#    endif
#   endif
#  endif

/* This is the normal way of making sure we have a bcopy and a bzero.
   This is used in most programs--a few other programs avoid this
   by defining INHIBIT_STRING_HEADER.  */
#  ifndef INHIBIT_STRING_HEADER
#   include <string.h>
#   ifndef bzero
#    ifndef _LIBC
#     define bzero(s, n)	(memset (s, '\0', n), (s))
#    else
#     define bzero(s, n)	__bzero (s, n)
#    endif
#   endif
#  endif

/* Define the syntax stuff for \<, \>, etc.  */

/* This must be nonzero for the wordchar and notwordchar pattern
   commands in re_match_2.  */
#  ifndef Sword
#   define Sword 1
#  endif

#  ifdef SWITCH_ENUM_BUG
#   define SWITCH_ENUM_CAST(x) ((int)(x))
#  else
#   define SWITCH_ENUM_CAST(x) (x)
#  endif

# endif /* not emacs */

# include <limits.h>

# ifndef MB_LEN_MAX
#  define MB_LEN_MAX 1
# endif

/* Get the interface, including the syntax bits.  */
# include <regex.h>

/* isalpha etc. are used for the character classes.  */
# include <ctype.h>

/* Jim Meyering writes:

   "... Some ctype macros are valid only for character codes that
   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
   using /bin/cc or gcc but without giving an ansi option).  So, all
   ctype uses should be through macros like ISPRINT...  If
   STDC_HEADERS is defined, then autoconf has verified that the ctype
   macros don't need to be guarded with references to isascii. ...
   Defining isascii to 1 should let any compiler worth its salt
   eliminate the && through constant folding."
   Solaris defines some of these symbols so we must undefine them first.  */

# if defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
#  define IN_CTYPE_DOMAIN(c) 1
# else
#  define IN_CTYPE_DOMAIN(c) isascii(c)
# endif

# ifdef isblank
#  define ISBLANK(c) (IN_CTYPE_DOMAIN (c) && isblank (c))
# else
#  define ISBLANK(c) ((c) == ' ' || (c) == '\t')
# endif
# ifdef isgraph
#  define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isgraph (c))
# else
#  define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isprint (c) && !isspace (c))
# endif

# undef ISPRINT
# define ISPRINT(c) (IN_CTYPE_DOMAIN (c) && isprint (c))
# define ISDIGIT(c) (IN_CTYPE_DOMAIN (c) && isdigit (c))
# define ISALNUM(c) (IN_CTYPE_DOMAIN (c) && isalnum (c))
# define ISALPHA(c) (IN_CTYPE_DOMAIN (c) && isalpha (c))
# define ISCNTRL(c) (IN_CTYPE_DOMAIN (c) && iscntrl (c))
# define ISLOWER(c) (IN_CTYPE_DOMAIN (c) && islower (c))
# define ISPUNCT(c) (IN_CTYPE_DOMAIN (c) && ispunct (c))
# define ISSPACE(c) (IN_CTYPE_DOMAIN (c) && isspace (c))
# define ISUPPER(c) (IN_CTYPE_DOMAIN (c) && isupper (c))
# define ISXDIGIT(c) (IN_CTYPE_DOMAIN (c) && isxdigit (c))

# ifdef _tolower
#  define TOLOWER(c) _tolower(c)
# else
#  define TOLOWER(c) tolower(c)
# endif

# ifndef emacs
/* How many characters in the character set.  */
#  define CHAR_SET_SIZE 256

#  ifdef SYNTAX_TABLE

extern char *re_syntax_table;

#  else /* not SYNTAX_TABLE */

static char re_syntax_table[CHAR_SET_SIZE];

static void
init_syntax_once (void)
{
   register int c;
   static int done = 0;

   if (done)
     return;
   bzero (re_syntax_table, sizeof re_syntax_table);

   for (c = 0; c < CHAR_SET_SIZE; ++c)
     if (ISALNUM (c))
	re_syntax_table[c] = Sword;

   re_syntax_table['_'] = Sword;

   done = 1;
}

#  endif /* not SYNTAX_TABLE */

#  define SYNTAX(c) re_syntax_table[(unsigned char) (c)]

# endif /* emacs */

/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
   use `alloca' instead of `malloc'.  This is because using malloc in
   re_search* or re_match* could cause memory leaks when C-g is used in
   Emacs; also, malloc is slower and causes storage fragmentation.  On
   the other hand, malloc is more portable, and easier to debug.

   Because we sometimes use alloca, some routines have to be macros,
   not functions -- `alloca'-allocated space disappears at the end of the
   function it is called in.  */

# ifdef REGEX_MALLOC

#  define REGEX_ALLOCATE malloc
#  define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
#  define REGEX_FREE free

# else /* not REGEX_MALLOC  */

/* Emacs already defines alloca, sometimes.  */
#  ifndef alloca

/* Make alloca work the best possible way.  */
#   include <alloca.h>

#  endif /* not alloca */

#  define REGEX_ALLOCATE alloca

/* Assumes a `char *destination' variable.  */
#  define REGEX_REALLOCATE(source, osize, nsize)			\
  (destination = (char *) alloca (nsize),				\
   memcpy (destination, source, osize))

/* No need to do anything to free, after alloca.  */
#  define REGEX_FREE(arg) ((void)0) /* Do nothing!  But inhibit gcc warning.  */

# endif /* not REGEX_MALLOC */

/* Define how to allocate the failure stack.  */

# if defined REL_ALLOC && defined REGEX_MALLOC

#  define REGEX_ALLOCATE_STACK(size)				\
  r_alloc (&failure_stack_ptr, (size))
#  define REGEX_REALLOCATE_STACK(source, osize, nsize)		\
  r_re_alloc (&failure_stack_ptr, (nsize))
#  define REGEX_FREE_STACK(ptr)					\
  r_alloc_free (&failure_stack_ptr)

# else /* not using relocating allocator */

#  ifdef REGEX_MALLOC

#   define REGEX_ALLOCATE_STACK malloc
#   define REGEX_REALLOCATE_STACK(source, osize, nsize) realloc (source, nsize)
#   define REGEX_FREE_STACK free

#  else /* not REGEX_MALLOC */

#   define REGEX_ALLOCATE_STACK alloca

#   define REGEX_REALLOCATE_STACK(source, osize, nsize)			\
   REGEX_REALLOCATE (source, osize, nsize)
/* No need to explicitly free anything.  */
#   define REGEX_FREE_STACK(arg)

#  endif /* not REGEX_MALLOC */
# endif /* not using relocating allocator */


/* True if `size1' is non-NULL and PTR is pointing anywhere inside
   `string1' or just past its end.  This works if PTR is NULL, which is
   a good thing.  */
# define FIRST_STRING_P(ptr) 					\
  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)

/* (Re)Allocate N items of type T using malloc, or fail.  */
# define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
# define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
# define RETALLOC_IF(addr, n, t) \
  if (addr) RETALLOC((addr), (n), t); else (addr) = TALLOC ((n), t)
# define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))

# define BYTEWIDTH 8 /* In bits.  */

# define STREQ(s1, s2) ((strcmp (s1, s2) == 0))

# undef MAX
# undef MIN
# define MAX(a, b) ((a) > (b) ? (a) : (b))
# define MIN(a, b) ((a) < (b) ? (a) : (b))

typedef char boolean;
# define false 0
# define true 1

static reg_errcode_t byte_regex_compile (const char *pattern, size_t size,
					 reg_syntax_t syntax,
					 struct re_pattern_buffer *bufp);

static int byte_re_match_2_internal (struct re_pattern_buffer *bufp,
				     const char *string1, int size1,
				     const char *string2, int size2,
				     int pos,
				     struct re_registers *regs,
				     int stop);
static int byte_re_search_2 (struct re_pattern_buffer *bufp,
			     const char *string1, int size1,
			     const char *string2, int size2,
			     int startpos, int range,
			     struct re_registers *regs, int stop);
static int byte_re_compile_fastmap (struct re_pattern_buffer *bufp);

#ifdef MBS_SUPPORT
static reg_errcode_t wcs_regex_compile (const char *pattern, size_t size,
					reg_syntax_t syntax,
					struct re_pattern_buffer *bufp);


static int wcs_re_match_2_internal (struct re_pattern_buffer *bufp,
				    const char *cstring1, int csize1,
				    const char *cstring2, int csize2,
				    int pos,
				    struct re_registers *regs,
				    int stop,
				    wchar_t *string1, int size1,
				    wchar_t *string2, int size2,
				    int *mbs_offset1, int *mbs_offset2);
static int wcs_re_search_2 (struct re_pattern_buffer *bufp,
			    const char *string1, int size1,
			    const char *string2, int size2,
			    int startpos, int range,
			    struct re_registers *regs, int stop);
static int wcs_re_compile_fastmap (struct re_pattern_buffer *bufp);
#endif

/* These are the command codes that appear in compiled regular
   expressions.  Some opcodes are followed by argument bytes.  A
   command code can specify any interpretation whatsoever for its
   arguments.  Zero bytes may appear in the compiled regular expression.  */

typedef enum
{
  no_op = 0,

  /* Succeed right away--no more backtracking.  */
  succeed,

        /* Followed by one byte giving n, then by n literal bytes.  */
  exactn,

# ifdef MBS_SUPPORT
	/* Same as exactn, but contains binary data.  */
  exactn_bin,
# endif

        /* Matches any (more or less) character.  */
  anychar,

        /* Matches any one char belonging to specified set.  First
           following byte is number of bitmap bytes.  Then come bytes
           for a bitmap saying which chars are in.  Bits in each byte
           are ordered low-bit-first.  A character is in the set if its
           bit is 1.  A character too large to have a bit in the map is
           automatically not in the set.  */
        /* ifdef MBS_SUPPORT, following element is length of character
	   classes, length of collating symbols, length of equivalence
	   classes, length of character ranges, and length of characters.
	   Next, character class element, collating symbols elements,
	   equivalence class elements, range elements, and character
	   elements follow.
	   See regex_compile function.  */
  charset,

        /* Same parameters as charset, but match any character that is
           not one of those specified.  */
  charset_not,

        /* Start remembering the text that is matched, for storing in a
           register.  Followed by one byte with the register number, in
           the range 0 to one less than the pattern buffer's re_nsub
           field.  Then followed by one byte with the number of groups
           inner to this one.  (This last has to be part of the
           start_memory only because we need it in the on_failure_jump
           of re_match_2.)  */
  start_memory,

        /* Stop remembering the text that is matched and store it in a
           memory register.  Followed by one byte with the register
           number, in the range 0 to one less than `re_nsub' in the
           pattern buffer, and one byte with the number of inner groups,
           just like `start_memory'.  (We need the number of inner
           groups here because we don't have any easy way of finding the
           corresponding start_memory when we're at a stop_memory.)  */
  stop_memory,

        /* Match a duplicate of something remembered. Followed by one
           byte containing the register number.  */
  duplicate,

        /* Fail unless at beginning of line.  */
  begline,

        /* Fail unless at end of line.  */
  endline,

        /* Succeeds if at beginning of buffer (if emacs) or at beginning
           of string to be matched (if not).  */
  begbuf,

        /* Analogously, for end of buffer/string.  */
  endbuf,

        /* Followed by two byte relative address to which to jump.  */
  jump,

	/* Same as jump, but marks the end of an alternative.  */
  jump_past_alt,

        /* Followed by two-byte relative address of place to resume at
           in case of failure.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
  on_failure_jump,

        /* Like on_failure_jump, but pushes a placeholder instead of the
           current string position when executed.  */
  on_failure_keep_string_jump,

        /* Throw away latest failure point and then jump to following
           two-byte relative address.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
  pop_failure_jump,

        /* Change to pop_failure_jump if know won't have to backtrack to
           match; otherwise change to jump.  This is used to jump
           back to the beginning of a repeat.  If what follows this jump
           clearly won't match what the repeat does, such that we can be
           sure that there is no use backtracking out of repetitions
           already matched, then we change it to a pop_failure_jump.
           Followed by two-byte address.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
  maybe_pop_jump,

        /* Jump to following two-byte address, and push a dummy failure
           point. This failure point will be thrown away if an attempt
           is made to use it for a failure.  A `+' construct makes this
           before the first repeat.  Also used as an intermediary kind
           of jump when compiling an alternative.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
  dummy_failure_jump,

	/* Push a dummy failure point and continue.  Used at the end of
	   alternatives.  */
  push_dummy_failure,

        /* Followed by two-byte relative address and two-byte number n.
           After matching N times, jump to the address upon failure.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
  succeed_n,

        /* Followed by two-byte relative address, and two-byte number n.
           Jump to the address N times, then fail.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
  jump_n,

        /* Set the following two-byte relative address to the
           subsequent two-byte number.  The address *includes* the two
           bytes of number.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
  set_number_at,

  wordchar,	/* Matches any word-constituent character.  */
  notwordchar,	/* Matches any char that is not a word-constituent.  */

  wordbeg,	/* Succeeds if at word beginning.  */
  wordend,	/* Succeeds if at word end.  */

  wordbound,	/* Succeeds if at a word boundary.  */
  notwordbound	/* Succeeds if not at a word boundary.  */

# ifdef emacs
  ,before_dot,	/* Succeeds if before point.  */
  at_dot,	/* Succeeds if at point.  */
  after_dot,	/* Succeeds if after point.  */

	/* Matches any character whose syntax is specified.  Followed by
           a byte which contains a syntax code, e.g., Sword.  */
  syntaxspec,

	/* Matches any character whose syntax is not that specified.  */
  notsyntaxspec
# endif /* emacs */
} re_opcode_t;
#endif /* not INSIDE_RECURSION */


#ifdef BYTE
# define CHAR_T char
# define UCHAR_T unsigned char
# define COMPILED_BUFFER_VAR bufp->buffer
# define OFFSET_ADDRESS_SIZE 2
# define PREFIX(name) byte_##name
# define ARG_PREFIX(name) name
# define PUT_CHAR(c) putchar (c)
#else
# ifdef WCHAR
#  define CHAR_T wchar_t
#  define UCHAR_T wchar_t
#  define COMPILED_BUFFER_VAR wc_buffer
#  define OFFSET_ADDRESS_SIZE 1 /* the size which STORE_NUMBER macro use */
#  define CHAR_CLASS_SIZE ((__alignof__(wctype_t)+sizeof(wctype_t))/sizeof(CHAR_T)+1)
#  define PREFIX(name) wcs_##name
#  define ARG_PREFIX(name) c##name
/* Should we use wide stream??  */
#  define PUT_CHAR(c) printf ("%C", c);
#  define TRUE 1
#  define FALSE 0
# else
#  ifdef MBS_SUPPORT
#   define WCHAR
#   define INSIDE_RECURSION
#   include "regex.c"
#   undef INSIDE_RECURSION
#  endif
#  define BYTE
#  define INSIDE_RECURSION
#  include "regex.c"
#  undef INSIDE_RECURSION
# endif
#endif

#if USE_UNLOCKED_IO
# include "unlocked-io.h"
#endif

#ifdef INSIDE_RECURSION
/* Common operations on the compiled pattern.  */

/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */

# ifdef WCHAR
#  define STORE_NUMBER(destination, number)				\
  do {									\
    *(destination) = (UCHAR_T)(number);				\
  } while (0)
# else /* BYTE */
#  define STORE_NUMBER(destination, number)				\
  do {									\
    (destination)[0] = (number) & 0377;					\
    (destination)[1] = (number) >> 8;					\
  } while (0)
# endif /* WCHAR */

/* Same as STORE_NUMBER, except increment DESTINATION to
   the byte after where the number is stored.  Therefore, DESTINATION
   must be an lvalue.  */
/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */

# define STORE_NUMBER_AND_INCR(destination, number)			\
  do {									\
    STORE_NUMBER (destination, number);					\
    (destination) += OFFSET_ADDRESS_SIZE;				\
  } while (0)

/* Put into DESTINATION a number stored in two contiguous bytes starting
   at SOURCE.  */
/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */

# ifdef WCHAR
#  define EXTRACT_NUMBER(destination, source)				\
  do {									\
    (destination) = *(source);						\
  } while (0)
# else /* BYTE */
#  define EXTRACT_NUMBER(destination, source)				\
  do {									\
    (destination) = *(source) & 0377;					\
    (destination) += (signed char) (*((source) + 1)) << 8;		\
  } while (0)
# endif

# ifdef DEBUG
static void
PREFIX(extract_number) (int *dest, UCHAR_T *source)
{
#  ifdef WCHAR
  *dest = *source;
#  else /* BYTE */
  signed char temp = source[1];
  *dest = *source & 0377;
  *dest += temp << 8;
#  endif
}

#  ifndef EXTRACT_MACROS /* To debug the macros.  */
#   undef EXTRACT_NUMBER
#   define EXTRACT_NUMBER(dest, src) PREFIX(extract_number) (&dest, src)
#  endif /* not EXTRACT_MACROS */

# endif /* DEBUG */

/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
   SOURCE must be an lvalue.  */

# define EXTRACT_NUMBER_AND_INCR(destination, source)			\
  do {									\
    EXTRACT_NUMBER (destination, source);				\
    (source) += OFFSET_ADDRESS_SIZE; 					\
  } while (0)

# ifdef DEBUG
static void
PREFIX(extract_number_and_incr) (int *destination, UCHAR_T **source)
{
  PREFIX(extract_number) (destination, *source);
  *source += OFFSET_ADDRESS_SIZE;
}

#  ifndef EXTRACT_MACROS
#   undef EXTRACT_NUMBER_AND_INCR
#   define EXTRACT_NUMBER_AND_INCR(dest, src) \
  PREFIX(extract_number_and_incr) (&dest, &src)
#  endif /* not EXTRACT_MACROS */

# endif /* DEBUG */



/* If DEBUG is defined, Regex prints many voluminous messages about what
   it is doing (if the variable `debug' is nonzero).  If linked with the
   main program in `iregex.c', you can enter patterns and strings
   interactively.  And if linked with the main program in `main.c' and
   the other test files, you can run the already-written tests.  */

# ifdef DEBUG

#  ifndef DEFINED_ONCE

/* We use standard I/O for debugging.  */
#   include <stdio.h>

/* It is useful to test things that ``must'' be true when debugging.  */
#   include <assert.h>

static int debug;

#   define DEBUG_STATEMENT(e) e
#   define DEBUG_PRINT1(x) if (debug) printf (x)
#   define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
#   define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
#   define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
#  endif /* not DEFINED_ONCE */

#  define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 			\
  if (debug) PREFIX(print_partial_compiled_pattern) (s, e)
#  define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)		\
  if (debug) PREFIX(print_double_string) (w, s1, sz1, s2, sz2)


/* Print the fastmap in human-readable form.  */

#  ifndef DEFINED_ONCE
void
print_fastmap (char *fastmap)
{
  unsigned was_a_range = 0;
  unsigned i = 0;

  while (i < (1 << BYTEWIDTH))
    {
      if (fastmap[i++])
	{
	  was_a_range = 0;
          putchar (i - 1);
          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
            {
              was_a_range = 1;
              i++;
            }
	  if (was_a_range)
            {
              printf ("-");
              putchar (i - 1);
            }
        }
    }
  putchar ('\n');
}
#  endif /* not DEFINED_ONCE */


/* Print a compiled pattern string in human-readable form, starting at
   the START pointer into it and ending just before the pointer END.  */

void
PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
{
  int mcnt, mcnt2;
  UCHAR_T *p1;
  UCHAR_T *p = start;
  UCHAR_T *pend = end;

  if (start == NULL)
    {
      printf ("(null)\n");
      return;
    }

  /* Loop over pattern commands.  */
  while (p < pend)
    {
#  ifdef _LIBC
      printf ("%td:\t", p - start);
#  else
      printf ("%ld:\t", (long int) (p - start));
#  endif

      switch ((re_opcode_t) *p++)
	{
        case no_op:
          printf ("/no_op");
          break;

	case exactn:
	  mcnt = *p++;
          printf ("/exactn/%d", mcnt);
          do
	    {
              putchar ('/');
	      PUT_CHAR (*p++);
            }
          while (--mcnt);
          break;

#  ifdef MBS_SUPPORT
	case exactn_bin:
	  mcnt = *p++;
	  printf ("/exactn_bin/%d", mcnt);
          do
	    {
	      printf("/%lx", (long int) *p++);
            }
          while (--mcnt);
          break;
#  endif /* MBS_SUPPORT */

	case start_memory:
          mcnt = *p++;
          printf ("/start_memory/%d/%ld", mcnt, (long int) *p++);
          break;

	case stop_memory:
          mcnt = *p++;
	  printf ("/stop_memory/%d/%ld", mcnt, (long int) *p++);
          break;

	case duplicate:
	  printf ("/duplicate/%ld", (long int) *p++);
	  break;

	case anychar:
	  printf ("/anychar");
	  break;

	case charset:
        case charset_not:
          {
#  ifdef WCHAR
	    int i, length;
	    wchar_t *workp = p;
	    printf ("/charset [%s",
	            (re_opcode_t) *(workp - 1) == charset_not ? "^" : "");
	    p += 5;
	    length = *workp++; /* the length of char_classes */
	    for (i=0 ; i<length ; i++)
	      printf("[:%lx:]", (long int) *p++);
	    length = *workp++; /* the length of collating_symbol */
	    for (i=0 ; i<length ;)
	      {
		printf("[.");
		while(*p != 0)
		  PUT_CHAR((i++,*p++));
		i++,p++;
		printf(".]");
	      }
	    length = *workp++; /* the length of equivalence_class */
	    for (i=0 ; i<length ;)
	      {
		printf("[=");
		while(*p != 0)
		  PUT_CHAR((i++,*p++));
		i++,p++;
		printf("=]");
	      }
	    length = *workp++; /* the length of char_range */
	    for (i=0 ; i<length ; i++)
	      {
		wchar_t range_start = *p++;
		wchar_t range_end = *p++;
		printf("%C-%C", range_start, range_end);
	      }
	    length = *workp++; /* the length of char */
	    for (i=0 ; i<length ; i++)
	      printf("%C", *p++);
	    putchar (']');
#  else
            register int c, last = -100;
	    register int in_range = 0;

	    printf ("/charset [%s",
	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");

            assert (p + *p < pend);

            for (c = 0; c < 256; c++)
	      if (c / 8 < *p
		  && (p[1 + (c/8)] & (1 << (c % 8))))
		{
		  /* Are we starting a range?  */
		  if (last + 1 == c && ! in_range)
		    {
		      putchar ('-');
		      in_range = 1;
		    }
		  /* Have we broken a range?  */
		  else if (last + 1 != c && in_range)
              {
		      putchar (last);
		      in_range = 0;
		    }

		  if (! in_range)
		    putchar (c);

		  last = c;
              }

	    if (in_range)
	      putchar (last);

	    putchar (']');

	    p += 1 + *p;
#  endif /* WCHAR */
	  }
	  break;

	case begline:
	  printf ("/begline");
          break;

	case endline:
          printf ("/endline");
          break;

	case on_failure_jump:
          PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/on_failure_jump to %td", p + mcnt - start);
#  else
  	  printf ("/on_failure_jump to %ld", (long int) (p + mcnt - start));
#  endif
          break;

	case on_failure_keep_string_jump:
          PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/on_failure_keep_string_jump to %td", p + mcnt - start);
#  else
  	  printf ("/on_failure_keep_string_jump to %ld",
		  (long int) (p + mcnt - start));
#  endif
          break;

	case dummy_failure_jump:
          PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/dummy_failure_jump to %td", p + mcnt - start);
#  else
  	  printf ("/dummy_failure_jump to %ld", (long int) (p + mcnt - start));
#  endif
          break;

	case push_dummy_failure:
          printf ("/push_dummy_failure");
          break;

        case maybe_pop_jump:
          PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/maybe_pop_jump to %td", p + mcnt - start);
#  else
  	  printf ("/maybe_pop_jump to %ld", (long int) (p + mcnt - start));
#  endif
	  break;

        case pop_failure_jump:
	  PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/pop_failure_jump to %td", p + mcnt - start);
#  else
  	  printf ("/pop_failure_jump to %ld", (long int) (p + mcnt - start));
#  endif
	  break;

        case jump_past_alt:
	  PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/jump_past_alt to %td", p + mcnt - start);
#  else
  	  printf ("/jump_past_alt to %ld", (long int) (p + mcnt - start));
#  endif
	  break;

        case jump:
	  PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/jump to %td", p + mcnt - start);
#  else
  	  printf ("/jump to %ld", (long int) (p + mcnt - start));
#  endif
	  break;

        case succeed_n:
          PREFIX(extract_number_and_incr) (&mcnt, &p);
	  p1 = p + mcnt;
          PREFIX(extract_number_and_incr) (&mcnt2, &p);
#  ifdef _LIBC
	  printf ("/succeed_n to %td, %d times", p1 - start, mcnt2);
#  else
	  printf ("/succeed_n to %ld, %d times",
		  (long int) (p1 - start), mcnt2);
#  endif
          break;

        case jump_n:
          PREFIX(extract_number_and_incr) (&mcnt, &p);
	  p1 = p + mcnt;
          PREFIX(extract_number_and_incr) (&mcnt2, &p);
	  printf ("/jump_n to %d, %d times", p1 - start, mcnt2);
          break;

        case set_number_at:
          PREFIX(extract_number_and_incr) (&mcnt, &p);
	  p1 = p + mcnt;
          PREFIX(extract_number_and_incr) (&mcnt2, &p);
#  ifdef _LIBC
	  printf ("/set_number_at location %td to %d", p1 - start, mcnt2);
#  else
	  printf ("/set_number_at location %ld to %d",
		  (long int) (p1 - start), mcnt2);
#  endif
          break;

        case wordbound:
	  printf ("/wordbound");
	  break;

	case notwordbound:
	  printf ("/notwordbound");
          break;

	case wordbeg:
	  printf ("/wordbeg");
	  break;

	case wordend:
	  printf ("/wordend");
	  break;

#  ifdef emacs
	case before_dot:
	  printf ("/before_dot");
          break;

	case at_dot:
	  printf ("/at_dot");
          break;

	case after_dot:
	  printf ("/after_dot");
          break;

	case syntaxspec:
          printf ("/syntaxspec");
	  mcnt = *p++;
	  printf ("/%d", mcnt);
          break;

	case notsyntaxspec:
          printf ("/notsyntaxspec");
	  mcnt = *p++;
	  printf ("/%d", mcnt);
	  break;
#  endif /* emacs */

	case wordchar:
	  printf ("/wordchar");
          break;

	case notwordchar:
	  printf ("/notwordchar");
          break;

	case begbuf:
	  printf ("/begbuf");
          break;

	case endbuf:
	  printf ("/endbuf");
          break;

        default:
          printf ("?%ld", (long int) *(p-1));
	}

      putchar ('\n');
    }

#  ifdef _LIBC
  printf ("%td:\tend of pattern.\n", p - start);
#  else
  printf ("%ld:\tend of pattern.\n", (long int) (p - start));
#  endif
}


void
PREFIX(print_compiled_pattern) (struct re_pattern_buffer *bufp)
{
  UCHAR_T *buffer = (UCHAR_T*) bufp->buffer;

  PREFIX(print_partial_compiled_pattern) (buffer, buffer
				  + bufp->used / sizeof(UCHAR_T));
  printf ("%ld bytes used/%ld bytes allocated.\n",
	  bufp->used, bufp->allocated);

  if (bufp->fastmap_accurate && bufp->fastmap)
    {
      printf ("fastmap: ");
      print_fastmap (bufp->fastmap);
    }

#  ifdef _LIBC
  printf ("re_nsub: %Zd\t", bufp->re_nsub);
#  else
  printf ("re_nsub: %ld\t", (long int) bufp->re_nsub);
#  endif
  printf ("regs_alloc: %d\t", bufp->regs_allocated);
  printf ("can_be_null: %d\t", bufp->can_be_null);
  printf ("newline_anchor: %d\n", bufp->newline_anchor);
  printf ("no_sub: %d\t", bufp->no_sub);
  printf ("not_bol: %d\t", bufp->not_bol);
  printf ("not_eol: %d\t", bufp->not_eol);
  printf ("syntax: %lx\n", bufp->syntax);
  /* Perhaps we should print the translate table?  */
}


void
PREFIX(print_double_string) (const CHAR_T *where,
			     const CHAR_T *string1,
			     const CHAR_T *string2,
			     int size1,
			     int size2)
{
  int this_char;

  if (where == NULL)
    printf ("(null)");
  else
    {
      int cnt;

      if (FIRST_STRING_P (where))
        {
          for (this_char = where - string1; this_char < size1; this_char++)
	    PUT_CHAR (string1[this_char]);

          where = string2;
        }

      cnt = 0;
      for (this_char = where - string2; this_char < size2; this_char++)
	{
	  PUT_CHAR (string2[this_char]);
	  if (++cnt > 100)
	    {
	      fputs ("...", stdout);
	      break;
	    }
	}
    }
}

#  ifndef DEFINED_ONCE
void
printchar (c)
     int c;
{
  putc (c, stderr);
}
#  endif

# else /* not DEBUG */

#  ifndef DEFINED_ONCE
#   undef assert
#   define assert(e)

#   define DEBUG_STATEMENT(e)
#   define DEBUG_PRINT1(x)
#   define DEBUG_PRINT2(x1, x2)
#   define DEBUG_PRINT3(x1, x2, x3)
#   define DEBUG_PRINT4(x1, x2, x3, x4)
#  endif /* not DEFINED_ONCE */
#  define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
#  define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)

# endif /* not DEBUG */



# ifdef WCHAR
/* This  convert a multibyte string to a wide character string.
   And write their correspondances to offset_buffer(see below)
   and write whether each wchar_t is binary data to is_binary.
   This assume invalid multibyte sequences as binary data.
   We assume offset_buffer and is_binary is already allocated
   enough space.  */

static size_t
convert_mbs_to_wcs (CHAR_T *dest,
		    const unsigned char* src,

		    /* The length of multibyte string.  */
		    size_t len,

		    /* Correspondences between src(char string) and
		       dest(wchar_t string) for optimization.  E.g.:
		       src  = "xxxyzz"
		       dest = {'X', 'Y', 'Z'}
			 (each "xxx", "y" and "zz" represent one
			  multibyte character corresponding to 'X',
			  'Y' and 'Z'.)
		       offset_buffer = {0, 0+3("xxx"), 0+3+1("y"),
					0+3+1+2("zz")}
				     = {0, 3, 4, 6} */
		    int *offset_buffer,

		    char *is_binary)
{
  wchar_t *pdest = dest;
  const unsigned char *psrc = src;
  size_t wc_count = 0;

  mbstate_t mbs;
  int i, consumed;
  size_t mb_remain = len;
  size_t mb_count = 0;

  /* Initialize the conversion state.  */
  memset (&mbs, 0, sizeof (mbstate_t));

  offset_buffer[0] = 0;
  for( ; mb_remain > 0 ; ++wc_count, ++pdest, mb_remain -= consumed,
	 psrc += consumed)
    {
      consumed = mbrtowc (pdest, psrc, mb_remain, &mbs);

      if (consumed <= 0)
	/* failed to convert. maybe src contains binary data.
	   So we consume 1 byte manualy.  */
	{
	  *pdest = *psrc;
	  consumed = 1;
	  is_binary[wc_count] = TRUE;
	}
      else
	is_binary[wc_count] = FALSE;
      /* In sjis encoding, we use yen sign as escape character in
	 place of reverse solidus. So we convert 0x5c(yen sign in
	 sjis) to not 0xa5(yen sign in UCS2) but 0x5c(reverse
	 solidus in UCS2).  */
      if (consumed == 1 && (int) *psrc == 0x5c && (int) *pdest == 0xa5)
	*pdest = (wchar_t) *psrc;

      offset_buffer[wc_count + 1] = mb_count += consumed;
    }

  /* Fill remain of the buffer with sentinel.  */
  for (i = wc_count + 1 ; i <= len ; i++)
    offset_buffer[i] = mb_count + 1;

  return wc_count;
}

# endif /* WCHAR */

#else /* not INSIDE_RECURSION */

/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
   also be assigned to arbitrarily: each pattern buffer stores its own
   syntax, so it can be changed between regex compilations.  */
/* This has no initializer because initialized variables in Emacs
   become read-only after dumping.  */
reg_syntax_t re_syntax_options;


/* Specify the precise syntax of regexps for compilation.  This provides
   for compatibility for various utilities which historically have
   different, incompatible syntaxes.

   The argument SYNTAX is a bit mask comprised of the various bits
   defined in regex.h.  We return the old syntax.  */

reg_syntax_t
re_set_syntax (reg_syntax_t syntax)
{
  reg_syntax_t ret = re_syntax_options;

  re_syntax_options = syntax;
# ifdef DEBUG
  if (syntax & RE_DEBUG)
    debug = 1;
  else if (debug) /* was on but now is not */
    debug = 0;
# endif /* DEBUG */
  return ret;
}
# ifdef _LIBC
weak_alias (__re_set_syntax, re_set_syntax)
# endif

/* This table gives an error message for each of the error codes listed
   in regex.h.  Obviously the order here has to be same as there.
   POSIX doesn't require that we do anything for REG_NOERROR,
   but why not be nice?  */

static const char re_error_msgid[] =
  {
# define REG_NOERROR_IDX	0
    gettext_noop ("Success")	/* REG_NOERROR */
    "\0"
# define REG_NOMATCH_IDX (REG_NOERROR_IDX + sizeof "Success")
    gettext_noop ("No match")	/* REG_NOMATCH */
    "\0"
# define REG_BADPAT_IDX	(REG_NOMATCH_IDX + sizeof "No match")
    gettext_noop ("Invalid regular expression") /* REG_BADPAT */
    "\0"
# define REG_ECOLLATE_IDX (REG_BADPAT_IDX + sizeof "Invalid regular expression")
    gettext_noop ("Invalid collation character") /* REG_ECOLLATE */
    "\0"
# define REG_ECTYPE_IDX	(REG_ECOLLATE_IDX + sizeof "Invalid collation character")
    gettext_noop ("Invalid character class name") /* REG_ECTYPE */
    "\0"
# define REG_EESCAPE_IDX	(REG_ECTYPE_IDX + sizeof "Invalid character class name")
    gettext_noop ("Trailing backslash") /* REG_EESCAPE */
    "\0"
# define REG_ESUBREG_IDX	(REG_EESCAPE_IDX + sizeof "Trailing backslash")
    gettext_noop ("Invalid back reference") /* REG_ESUBREG */
    "\0"
# define REG_EBRACK_IDX	(REG_ESUBREG_IDX + sizeof "Invalid back reference")
    gettext_noop ("Unmatched [ or [^")	/* REG_EBRACK */
    "\0"
# define REG_EPAREN_IDX	(REG_EBRACK_IDX + sizeof "Unmatched [ or [^")
    gettext_noop ("Unmatched ( or \\(") /* REG_EPAREN */
    "\0"
# define REG_EBRACE_IDX	(REG_EPAREN_IDX + sizeof "Unmatched ( or \\(")
    gettext_noop ("Unmatched \\{") /* REG_EBRACE */
    "\0"
# define REG_BADBR_IDX	(REG_EBRACE_IDX + sizeof "Unmatched \\{")
    gettext_noop ("Invalid content of \\{\\}") /* REG_BADBR */
    "\0"
# define REG_ERANGE_IDX	(REG_BADBR_IDX + sizeof "Invalid content of \\{\\}")
    gettext_noop ("Invalid range end")	/* REG_ERANGE */
    "\0"
# define REG_ESPACE_IDX	(REG_ERANGE_IDX + sizeof "Invalid range end")
    gettext_noop ("Memory exhausted") /* REG_ESPACE */
    "\0"
# define REG_BADRPT_IDX	(REG_ESPACE_IDX + sizeof "Memory exhausted")
    gettext_noop ("Invalid preceding regular expression") /* REG_BADRPT */
    "\0"
# define REG_EEND_IDX	(REG_BADRPT_IDX + sizeof "Invalid preceding regular expression")
    gettext_noop ("Premature end of regular expression") /* REG_EEND */
    "\0"
# define REG_ESIZE_IDX	(REG_EEND_IDX + sizeof "Premature end of regular expression")
    gettext_noop ("Regular expression too big") /* REG_ESIZE */
    "\0"
# define REG_ERPAREN_IDX	(REG_ESIZE_IDX + sizeof "Regular expression too big")
    gettext_noop ("Unmatched ) or \\)") /* REG_ERPAREN */
  };

static const size_t re_error_msgid_idx[] =
  {
    REG_NOERROR_IDX,
    REG_NOMATCH_IDX,
    REG_BADPAT_IDX,
    REG_ECOLLATE_IDX,
    REG_ECTYPE_IDX,
    REG_EESCAPE_IDX,
    REG_ESUBREG_IDX,
    REG_EBRACK_IDX,
    REG_EPAREN_IDX,
    REG_EBRACE_IDX,
    REG_BADBR_IDX,
    REG_ERANGE_IDX,
    REG_ESPACE_IDX,
    REG_BADRPT_IDX,
    REG_EEND_IDX,
    REG_ESIZE_IDX,
    REG_ERPAREN_IDX
  };

#endif /* INSIDE_RECURSION */

#ifndef DEFINED_ONCE
/* Avoiding alloca during matching, to placate r_alloc.  */

/* Define MATCH_MAY_ALLOCATE unless we need to make sure that the
   searching and matching functions should not call alloca.  On some
   systems, alloca is implemented in terms of malloc, and if we're
   using the relocating allocator routines, then malloc could cause a
   relocation, which might (if the strings being searched are in the
   ralloc heap) shift the data out from underneath the regexp
   routines.

   Here's another reason to avoid allocation: Emacs
   processes input from X in a signal handler; processing X input may
   call malloc; if input arrives while a matching routine is calling
   malloc, then we're scrod.  But Emacs can't just block input while
   calling matching routines; then we don't notice interrupts when
   they come in.  So, Emacs blocks input around all regexp calls
   except the matching calls, which it leaves unprotected, in the
   faith that they will not malloc.  */

/* Normally, this is fine.  */
# define MATCH_MAY_ALLOCATE

/* When using GNU C, we are not REALLY using the C alloca, no matter
   what config.h may say.  So don't take precautions for it.  */
# ifdef __GNUC__
#  undef C_ALLOCA
# endif

/* The match routines may not allocate if (1) they would do it with malloc
   and (2) it's not safe for them to use malloc.
   Note that if REL_ALLOC is defined, matching would not use malloc for the
   failure stack, but we would still use it for the register vectors;
   so REL_ALLOC should not affect this.  */
# if (defined C_ALLOCA || defined REGEX_MALLOC) && defined emacs
#  undef MATCH_MAY_ALLOCATE
# endif
#endif /* not DEFINED_ONCE */

#ifdef INSIDE_RECURSION
/* Failure stack declarations and macros; both re_compile_fastmap and
   re_match_2 use a failure stack.  These have to be macros because of
   REGEX_ALLOCATE_STACK.  */


/* Number of failure points for which to initially allocate space
   when matching.  If this number is exceeded, we allocate more
   space, so it is not a hard limit.  */
# ifndef INIT_FAILURE_ALLOC
#  define INIT_FAILURE_ALLOC 5
# endif

/* Roughly the maximum number of failure points on the stack.  Would be
   exactly that if always used MAX_FAILURE_ITEMS items each time we failed.
   This is a variable only so users of regex can assign to it; we never
   change it ourselves.  */

# ifdef INT_IS_16BIT

#  ifndef DEFINED_ONCE
#   if defined MATCH_MAY_ALLOCATE
/* 4400 was enough to cause a crash on Alpha OSF/1,
   whose default stack limit is 2mb.  */
long int re_max_failures = 4000;
#   else
long int re_max_failures = 2000;
#   endif
#  endif

union PREFIX(fail_stack_elt)
{
  UCHAR_T *pointer;
  long int integer;
};

typedef union PREFIX(fail_stack_elt) PREFIX(fail_stack_elt_t);

typedef struct
{
  PREFIX(fail_stack_elt_t) *stack;
  unsigned long int size;
  unsigned long int avail;		/* Offset of next open position.  */
} PREFIX(fail_stack_type);

# else /* not INT_IS_16BIT */

#  ifndef DEFINED_ONCE
#   if defined MATCH_MAY_ALLOCATE
/* 4400 was enough to cause a crash on Alpha OSF/1,
   whose default stack limit is 2mb.  */
int re_max_failures = 4000;
#   else
int re_max_failures = 2000;
#   endif
#  endif

union PREFIX(fail_stack_elt)
{
  UCHAR_T *pointer;
  int integer;
};

typedef union PREFIX(fail_stack_elt) PREFIX(fail_stack_elt_t);

typedef struct
{
  PREFIX(fail_stack_elt_t) *stack;
  unsigned size;
  unsigned avail;			/* Offset of next open position.  */
} PREFIX(fail_stack_type);

# endif /* INT_IS_16BIT */

# ifndef DEFINED_ONCE
#  define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
#  define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
#  define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
# endif


/* Define macros to initialize and free the failure stack.
   Do `return -2' if the alloc fails.  */

# ifdef MATCH_MAY_ALLOCATE
#  define INIT_FAIL_STACK()						\
  do {									\
    fail_stack.stack = (PREFIX(fail_stack_elt_t) *)		\
      REGEX_ALLOCATE_STACK (INIT_FAILURE_ALLOC * sizeof (PREFIX(fail_stack_elt_t))); \
									\
    if (fail_stack.stack == NULL)				\
      return -2;							\
									\
    fail_stack.size = INIT_FAILURE_ALLOC;			\
    fail_stack.avail = 0;					\
  } while (0)

#  define RESET_FAIL_STACK()  REGEX_FREE_STACK (fail_stack.stack)
# else
#  define INIT_FAIL_STACK()						\
  do {									\
    fail_stack.avail = 0;					\
  } while (0)

#  define RESET_FAIL_STACK()
# endif


/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.

   Return 1 if succeeds, and 0 if either ran out of memory
   allocating space for it or it was already too large.

   REGEX_REALLOCATE_STACK requires `destination' be declared.   */

# define DOUBLE_FAIL_STACK(fail_stack)					\
  ((fail_stack).size > (unsigned) (re_max_failures * MAX_FAILURE_ITEMS)	\
   ? 0									\
   : ((fail_stack).stack = (PREFIX(fail_stack_elt_t) *)			\
        REGEX_REALLOCATE_STACK ((fail_stack).stack, 			\
          (fail_stack).size * sizeof (PREFIX(fail_stack_elt_t)),	\
          ((fail_stack).size << 1) * sizeof (PREFIX(fail_stack_elt_t))),\
									\
      (fail_stack).stack == NULL					\
      ? 0								\
      : ((fail_stack).size <<= 1, 					\
         1)))


/* Push pointer POINTER on FAIL_STACK.
   Return 1 if was able to do so and 0 if ran out of memory allocating
   space to do so.  */
# define PUSH_PATTERN_OP(POINTER, FAIL_STACK)				\
  ((FAIL_STACK_FULL ()							\
    && !DOUBLE_FAIL_STACK (FAIL_STACK))					\
   ? 0									\
   : ((FAIL_STACK).stack[(FAIL_STACK).avail++].pointer = POINTER,	\
      1))

/* Push a pointer value onto the failure stack.
   Assumes the variable `fail_stack'.  Probably should only
   be called from within `PUSH_FAILURE_POINT'.  */
# define PUSH_FAILURE_POINTER(item)					\
  fail_stack.stack[fail_stack.avail++].pointer = (UCHAR_T *) (item)

/* This pushes an integer-valued item onto the failure stack.
   Assumes the variable `fail_stack'.  Probably should only
   be called from within `PUSH_FAILURE_POINT'.  */
# define PUSH_FAILURE_INT(item)					\
  fail_stack.stack[fail_stack.avail++].integer = (item)

/* Push a fail_stack_elt_t value onto the failure stack.
   Assumes the variable `fail_stack'.  Probably should only
   be called from within `PUSH_FAILURE_POINT'.  */
# define PUSH_FAILURE_ELT(item)					\
  fail_stack.stack[fail_stack.avail++] =  (item)

/* These three POP... operations complement the three PUSH... operations.
   All assume that `fail_stack' is nonempty.  */
# define POP_FAILURE_POINTER() fail_stack.stack[--fail_stack.avail].pointer
# define POP_FAILURE_INT() fail_stack.stack[--fail_stack.avail].integer
# define POP_FAILURE_ELT() fail_stack.stack[--fail_stack.avail]

/* Used to omit pushing failure point id's when we're not debugging.  */
# ifdef DEBUG
#  define DEBUG_PUSH PUSH_FAILURE_INT
#  define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_INT ()
# else
#  define DEBUG_PUSH(item)
#  define DEBUG_POP(item_addr)
# endif


/* Push the information about the state we will need
   if we ever fail back to it.

   Requires variables fail_stack, regstart, regend, reg_info, and
   num_regs_pushed be declared.  DOUBLE_FAIL_STACK requires `destination'
   be declared.

   Does `return FAILURE_CODE' if runs out of memory.  */

# define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
  do {									\
    char *destination;							\
    /* Must be int, so when we don't save any registers, the arithmetic	\
       of 0 + -1 isn't done as unsigned.  */				\
    /* Can't be int, since there is not a shred of a guarantee that int	\
       is wide enough to hold a value of something to which pointer can	\
       be assigned */							\
    active_reg_t this_reg;						\
    									\
    DEBUG_STATEMENT (failure_id++);					\
    DEBUG_STATEMENT (nfailure_points_pushed++);				\
    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
									\
    DEBUG_PRINT2 ("  slots needed: %ld\n", NUM_FAILURE_ITEMS);		\
    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
									\
    /* Ensure we have enough space allocated for what we will push.  */	\
    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
      {									\
        if (!DOUBLE_FAIL_STACK (fail_stack))				\
          return failure_code;						\
									\
        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
		       (fail_stack).size);				\
        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
      }									\
									\
    /* Push the info, starting with the registers.  */			\
    DEBUG_PRINT1 ("\n");						\
									\
    if (1)								\
      for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; \
	   this_reg++)							\
	{								\
	  DEBUG_PRINT2 ("  Pushing reg: %lu\n", this_reg);		\
	  DEBUG_STATEMENT (num_regs_pushed++);				\
									\
	  DEBUG_PRINT2 ("    start: %p\n", regstart[this_reg]);		\
	  PUSH_FAILURE_POINTER (regstart[this_reg]);			\
									\
	  DEBUG_PRINT2 ("    end: %p\n", regend[this_reg]);		\
	  PUSH_FAILURE_POINTER (regend[this_reg]);			\
									\
	  DEBUG_PRINT2 ("    info: %p\n      ",				\
			reg_info[this_reg].word.pointer);		\
	  DEBUG_PRINT2 (" match_null=%d",				\
			REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
	  DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
	  DEBUG_PRINT2 (" matched_something=%d",			\
			MATCHED_SOMETHING (reg_info[this_reg]));	\
	  DEBUG_PRINT2 (" ever_matched=%d",				\
			EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
	  DEBUG_PRINT1 ("\n");						\
	  PUSH_FAILURE_ELT (reg_info[this_reg].word);			\
	}								\
									\
    DEBUG_PRINT2 ("  Pushing  low active reg: %ld\n", lowest_active_reg);\
    PUSH_FAILURE_INT (lowest_active_reg);				\
									\
    DEBUG_PRINT2 ("  Pushing high active reg: %ld\n", highest_active_reg);\
    PUSH_FAILURE_INT (highest_active_reg);				\
									\
    DEBUG_PRINT2 ("  Pushing pattern %p:\n", pattern_place);		\
    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
    PUSH_FAILURE_POINTER (pattern_place);				\
									\
    DEBUG_PRINT2 ("  Pushing string %p: `", string_place);		\
    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
				 size2);				\
    DEBUG_PRINT1 ("'\n");						\
    PUSH_FAILURE_POINTER (string_place);				\
									\
    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
    DEBUG_PUSH (failure_id);						\
  } while (0)

# ifndef DEFINED_ONCE
/* This is the number of items that are pushed and popped on the stack
   for each register.  */
#  define NUM_REG_ITEMS  3

/* Individual items aside from the registers.  */
#  ifdef DEBUG
#   define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
#  else
#   define NUM_NONREG_ITEMS 4
#  endif

/* We push at most this many items on the stack.  */
/* We used to use (num_regs - 1), which is the number of registers
   this regexp will save; but that was changed to 5
   to avoid stack overflow for a regexp with lots of parens.  */
#  define MAX_FAILURE_ITEMS (5 * NUM_REG_ITEMS + NUM_NONREG_ITEMS)

/* We actually push this many items.  */
#  define NUM_FAILURE_ITEMS				\
  (((0							\
     ? 0 : highest_active_reg - lowest_active_reg + 1)	\
    * NUM_REG_ITEMS)					\
   + NUM_NONREG_ITEMS)

/* How many items can still be added to the stack without overflowing it.  */
#  define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
# endif /* not DEFINED_ONCE */


/* Pops what PUSH_FAIL_STACK pushes.

   We restore into the parameters, all of which should be lvalues:
     STR -- the saved data position.
     PAT -- the saved pattern position.
     LOW_REG, HIGH_REG -- the highest and lowest active registers.
     REGSTART, REGEND -- arrays of string positions.
     REG_INFO -- array of information about each subexpression.

   Also assumes the variables `fail_stack' and (if debugging), `bufp',
   `pend', `string1', `size1', `string2', and `size2'.  */
# define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
{									\
  DEBUG_STATEMENT (unsigned failure_id;)				\
  active_reg_t this_reg;						\
  const UCHAR_T *string_temp;						\
									\
  assert (!FAIL_STACK_EMPTY ());					\
									\
  /* Remove failure points and point to how many regs pushed.  */	\
  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
									\
  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
									\
  DEBUG_POP (&failure_id);						\
  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
									\
  /* If the saved string location is NULL, it came from an		\
     on_failure_keep_string_jump opcode, and we want to throw away the	\
     saved NULL, thus retaining our current position in the string.  */	\
  string_temp = POP_FAILURE_POINTER ();					\
  if (string_temp != NULL)						\
    str = (const CHAR_T *) string_temp;					\
									\
  DEBUG_PRINT2 ("  Popping string %p: `", str);				\
  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
  DEBUG_PRINT1 ("'\n");							\
									\
  pat = (UCHAR_T *) POP_FAILURE_POINTER ();				\
  DEBUG_PRINT2 ("  Popping pattern %p:\n", pat);			\
  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
									\
  /* Restore register info.  */						\
  high_reg = (active_reg_t) POP_FAILURE_INT ();				\
  DEBUG_PRINT2 ("  Popping high active reg: %ld\n", high_reg);		\
									\
  low_reg = (active_reg_t) POP_FAILURE_INT ();				\
  DEBUG_PRINT2 ("  Popping  low active reg: %ld\n", low_reg);		\
									\
  if (1)								\
    for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
      {									\
	DEBUG_PRINT2 ("    Popping reg: %ld\n", this_reg);		\
									\
	reg_info[this_reg].word = POP_FAILURE_ELT ();			\
	DEBUG_PRINT2 ("      info: %p\n",				\
		      reg_info[this_reg].word.pointer);			\
									\
	regend[this_reg] = (const CHAR_T *) POP_FAILURE_POINTER ();	\
	DEBUG_PRINT2 ("      end: %p\n", regend[this_reg]);		\
									\
	regstart[this_reg] = (const CHAR_T *) POP_FAILURE_POINTER ();	\
	DEBUG_PRINT2 ("      start: %p\n", regstart[this_reg]);		\
      }									\
  else									\
    {									\
      for (this_reg = highest_active_reg; this_reg > high_reg; this_reg--) \
	{								\
	  reg_info[this_reg].word.integer = 0;				\
	  regend[this_reg] = 0;						\
	  regstart[this_reg] = 0;					\
	}								\
      highest_active_reg = high_reg;					\
    }									\
									\
  set_regs_matched_done = 0;						\
  DEBUG_STATEMENT (nfailure_points_popped++);				\
} /* POP_FAILURE_POINT */

/* Structure for per-register (a.k.a. per-group) information.
   Other register information, such as the
   starting and ending positions (which are addresses), and the list of
   inner groups (which is a bits list) are maintained in separate
   variables.

   We are making a (strictly speaking) nonportable assumption here: that
   the compiler will pack our bit fields into something that fits into
   the type of `word', i.e., is something that fits into one item on the
   failure stack.  */


/* Declarations and macros for re_match_2.  */

typedef union
{
  PREFIX(fail_stack_elt_t) word;
  struct
  {
      /* This field is one if this group can match the empty string,
         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
# define MATCH_NULL_UNSET_VALUE 3
    unsigned match_null_string_p : 2;
    unsigned is_active : 1;
    unsigned matched_something : 1;
    unsigned ever_matched_something : 1;
  } bits;
} PREFIX(register_info_type);

# ifndef DEFINED_ONCE
#  define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
#  define IS_ACTIVE(R)  ((R).bits.is_active)
#  define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
#  define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)


/* Call this when have matched a real character; it sets `matched' flags
   for the subexpressions which we are currently inside.  Also records
   that those subexprs have matched.  */
#  define SET_REGS_MATCHED()						\
  do									\
    {									\
      if (!set_regs_matched_done)					\
	{								\
	  active_reg_t r;						\
	  set_regs_matched_done = 1;					\
	  for (r = lowest_active_reg; r <= highest_active_reg; r++)	\
	    {								\
	      MATCHED_SOMETHING (reg_info[r])				\
		= EVER_MATCHED_SOMETHING (reg_info[r])			\
		= 1;							\
	    }								\
	}								\
    }									\
  while (0)
# endif /* not DEFINED_ONCE */

/* Registers are set to a sentinel when they haven't yet matched.  */
static CHAR_T PREFIX(reg_unset_dummy);
# define REG_UNSET_VALUE (&PREFIX(reg_unset_dummy))
# define REG_UNSET(e) ((e) == REG_UNSET_VALUE)

/* Subroutine declarations and macros for regex_compile.  */
static void PREFIX(store_op1) (re_opcode_t op, UCHAR_T *loc, int arg);
static void PREFIX(store_op2) (re_opcode_t op, UCHAR_T *loc,
			       int arg1, int arg2);
static void PREFIX(insert_op1) (re_opcode_t op, UCHAR_T *loc,
				int arg, UCHAR_T *end);
static void PREFIX(insert_op2) (re_opcode_t op, UCHAR_T *loc,
				int arg1, int arg2, UCHAR_T *end);
static boolean PREFIX(at_begline_loc_p) (const CHAR_T *pattern,
					 const CHAR_T *p,
					 reg_syntax_t syntax);
static boolean PREFIX(at_endline_loc_p) (const CHAR_T *p,
					 const CHAR_T *pend,
					 reg_syntax_t syntax);
# ifdef WCHAR
static reg_errcode_t wcs_compile_range (CHAR_T range_start,
					const CHAR_T **p_ptr,
					const CHAR_T *pend,
					char *translate,
					reg_syntax_t syntax,
					UCHAR_T *b,
					CHAR_T *char_set);
static void insert_space (int num, CHAR_T *loc, CHAR_T *end);
# else /* BYTE */
static reg_errcode_t byte_compile_range (unsigned int range_start,
					 const char **p_ptr,
					 const char *pend,
					 char *translate,
					 reg_syntax_t syntax,
					 unsigned char *b);
# endif /* WCHAR */

/* Fetch the next character in the uncompiled pattern---translating it
   if necessary.  Also cast from a signed character in the constant
   string passed to us by the user to an unsigned char that we can use
   as an array index (in, e.g., `translate').  */
/* ifdef MBS_SUPPORT, we translate only if character <= 0xff,
   because it is impossible to allocate 4GB array for some encodings
   which have 4 byte character_set like UCS4.  */
# ifndef PATFETCH
#  ifdef WCHAR
#   define PATFETCH(c)							\
  do {if (p == pend) return REG_EEND;					\
    c = (UCHAR_T) *p++;							\
    if (translate && (c <= 0xff)) c = (UCHAR_T) translate[c];		\
  } while (0)
#  else /* BYTE */
#   define PATFETCH(c)							\
  do {if (p == pend) return REG_EEND;					\
    c = (unsigned char) *p++;						\
    if (translate) c = (unsigned char) translate[c];			\
  } while (0)
#  endif /* WCHAR */
# endif

/* Fetch the next character in the uncompiled pattern, with no
   translation.  */
# define PATFETCH_RAW(c)						\
  do {if (p == pend) return REG_EEND;					\
    c = (UCHAR_T) *p++; 	       					\
  } while (0)

/* Go backwards one character in the pattern.  */
# define PATUNFETCH p--


/* If `translate' is non-null, return translate[D], else just D.  We
   cast the subscript to translate because some data is declared as
   `char *', to avoid warnings when a string constant is passed.  But
   when we use a character as a subscript we must make it unsigned.  */
/* ifdef MBS_SUPPORT, we translate only if character <= 0xff,
   because it is impossible to allocate 4GB array for some encodings
   which have 4 byte character_set like UCS4.  */

# ifndef TRANSLATE
#  ifdef WCHAR
#   define TRANSLATE(d) \
  ((translate && ((UCHAR_T) (d)) <= 0xff) \
   ? (char) translate[(unsigned char) (d)] : (d))
# else /* BYTE */
#   define TRANSLATE(d) \
  (translate ? (char) translate[(unsigned char) (d)] : (d))
#  endif /* WCHAR */
# endif


/* Macros for outputting the compiled pattern into `buffer'.  */

/* If the buffer isn't allocated when it comes in, use this.  */
# define INIT_BUF_SIZE  (32 * sizeof(UCHAR_T))

/* Make sure we have at least N more bytes of space in buffer.  */
# ifdef WCHAR
#  define GET_BUFFER_SPACE(n)						\
    while (((unsigned long)b - (unsigned long)COMPILED_BUFFER_VAR	\
            + (n)*sizeof(CHAR_T)) > bufp->allocated)			\
      EXTEND_BUFFER ()
# else /* BYTE */
#  define GET_BUFFER_SPACE(n)						\
    while ((unsigned long) (b - bufp->buffer + (n)) > bufp->allocated)	\
      EXTEND_BUFFER ()
# endif /* WCHAR */

/* Make sure we have one more byte of buffer space and then add C to it.  */
# define BUF_PUSH(c)							\
  do {									\
    GET_BUFFER_SPACE (1);						\
    *b++ = (UCHAR_T) (c);						\
  } while (0)


/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
# define BUF_PUSH_2(c1, c2)						\
  do {									\
    GET_BUFFER_SPACE (2);						\
    *b++ = (UCHAR_T) (c1);						\
    *b++ = (UCHAR_T) (c2);						\
  } while (0)


/* As with BUF_PUSH_2, except for three bytes.  */
# define BUF_PUSH_3(c1, c2, c3)						\
  do {									\
    GET_BUFFER_SPACE (3);						\
    *b++ = (UCHAR_T) (c1);						\
    *b++ = (UCHAR_T) (c2);						\
    *b++ = (UCHAR_T) (c3);						\
  } while (0)

/* Store a jump with opcode OP at LOC to location TO.  We store a
   relative address offset by the three bytes the jump itself occupies.  */
# define STORE_JUMP(op, loc, to) \
 PREFIX(store_op1) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)))

/* Likewise, for a two-argument jump.  */
# define STORE_JUMP2(op, loc, to, arg) \
  PREFIX(store_op2) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)), arg)

/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
# define INSERT_JUMP(op, loc, to) \
  PREFIX(insert_op1) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)), b)

/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
# define INSERT_JUMP2(op, loc, to, arg) \
  PREFIX(insert_op2) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)),\
	      arg, b)

/* This is not an arbitrary limit: the arguments which represent offsets
   into the pattern are two bytes long.  So if 2^16 bytes turns out to
   be too small, many things would have to change.  */
/* Any other compiler which, like MSC, has allocation limit below 2^16
   bytes will have to use approach similar to what was done below for
   MSC and drop MAX_BUF_SIZE a bit.  Otherwise you may end up
   reallocating to 0 bytes.  Such thing is not going to work too well.
   You have been warned!!  */
# ifndef DEFINED_ONCE
#  if defined _MSC_VER  && !defined WIN32
/* Microsoft C 16-bit versions limit malloc to approx 65512 bytes.
   The REALLOC define eliminates a flurry of conversion warnings,
   but is not required. */
#   define MAX_BUF_SIZE  65500L
#   define REALLOC(p,s) realloc ((p), (size_t) (s))
#  else
#   define MAX_BUF_SIZE (1L << 16)
#   define REALLOC(p,s) realloc ((p), (s))
#  endif

/* Extend the buffer by twice its current size via realloc and
   reset the pointers that pointed into the old block to point to the
   correct places in the new one.  If extending the buffer results in it
   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
#  if __BOUNDED_POINTERS__
#   define SET_HIGH_BOUND(P) (__ptrhigh (P) = __ptrlow (P) + bufp->allocated)
#   define MOVE_BUFFER_POINTER(P) \
  (__ptrlow (P) += incr, SET_HIGH_BOUND (P), __ptrvalue (P) += incr)
#   define ELSE_EXTEND_BUFFER_HIGH_BOUND	\
  else						\
    {						\
      SET_HIGH_BOUND (b);			\
      SET_HIGH_BOUND (begalt);			\
      if (fixup_alt_jump)			\
	SET_HIGH_BOUND (fixup_alt_jump);	\
      if (laststart)				\
	SET_HIGH_BOUND (laststart);		\
      if (pending_exact)			\
	SET_HIGH_BOUND (pending_exact);		\
    }
#  else
#   define MOVE_BUFFER_POINTER(P) (P) += incr
#   define ELSE_EXTEND_BUFFER_HIGH_BOUND
#  endif
# endif /* not DEFINED_ONCE */

# ifdef WCHAR
#  define EXTEND_BUFFER()						\
  do {									\
    UCHAR_T *old_buffer = COMPILED_BUFFER_VAR;				\
    int wchar_count;							\
    if (bufp->allocated + sizeof(UCHAR_T) > MAX_BUF_SIZE)		\
      return REG_ESIZE;							\
    bufp->allocated <<= 1;						\
    if (bufp->allocated > MAX_BUF_SIZE)					\
      bufp->allocated = MAX_BUF_SIZE;					\
    /* How many characters the new buffer can have?  */			\
    wchar_count = bufp->allocated / sizeof(UCHAR_T);			\
    if (wchar_count == 0) wchar_count = 1;				\
    /* Truncate the buffer to CHAR_T align.  */			\
    bufp->allocated = wchar_count * sizeof(UCHAR_T);			\
    RETALLOC (COMPILED_BUFFER_VAR, wchar_count, UCHAR_T);		\
    bufp->buffer = (char*)COMPILED_BUFFER_VAR;				\
    if (COMPILED_BUFFER_VAR == NULL)					\
      return REG_ESPACE;						\
    /* If the buffer moved, move all the pointers into it.  */		\
    if (old_buffer != COMPILED_BUFFER_VAR)				\
      {									\
	int incr = COMPILED_BUFFER_VAR - old_buffer;			\
	MOVE_BUFFER_POINTER (b);					\
	MOVE_BUFFER_POINTER (begalt);					\
	if (fixup_alt_jump)						\
	  MOVE_BUFFER_POINTER (fixup_alt_jump);				\
	if (laststart)							\
	  MOVE_BUFFER_POINTER (laststart);				\
	if (pending_exact)						\
	  MOVE_BUFFER_POINTER (pending_exact);				\
      }									\
    ELSE_EXTEND_BUFFER_HIGH_BOUND					\
  } while (0)
# else /* BYTE */
#  define EXTEND_BUFFER()						\
  do {									\
    UCHAR_T *old_buffer = COMPILED_BUFFER_VAR;				\
    if (bufp->allocated == MAX_BUF_SIZE)				\
      return REG_ESIZE;							\
    bufp->allocated <<= 1;						\
    if (bufp->allocated > MAX_BUF_SIZE)					\
      bufp->allocated = MAX_BUF_SIZE;					\
    bufp->buffer = REALLOC (COMPILED_BUFFER_VAR, bufp->allocated);	\
    if (COMPILED_BUFFER_VAR == NULL)					\
      return REG_ESPACE;						\
    /* If the buffer moved, move all the pointers into it.  */		\
    if (old_buffer != COMPILED_BUFFER_VAR)				\
      {									\
	int incr = COMPILED_BUFFER_VAR - old_buffer;			\
	MOVE_BUFFER_POINTER (b);					\
	MOVE_BUFFER_POINTER (begalt);					\
	if (fixup_alt_jump)						\
	  MOVE_BUFFER_POINTER (fixup_alt_jump);				\
	if (laststart)							\
	  MOVE_BUFFER_POINTER (laststart);				\
	if (pending_exact)						\
	  MOVE_BUFFER_POINTER (pending_exact);				\
      }									\
    ELSE_EXTEND_BUFFER_HIGH_BOUND					\
  } while (0)
# endif /* WCHAR */

# ifndef DEFINED_ONCE
/* Since we have one byte reserved for the register number argument to
   {start,stop}_memory, the maximum number of groups we can report
   things about is what fits in that byte.  */
#  define MAX_REGNUM 255

/* But patterns can have more than `MAX_REGNUM' registers.  We just
   ignore the excess.  */
typedef unsigned regnum_t;


/* Macros for the compile stack.  */

/* Since offsets can go either forwards or backwards, this type needs to
   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
/* int may be not enough when sizeof(int) == 2.  */
typedef long pattern_offset_t;

typedef struct
{
  pattern_offset_t begalt_offset;
  pattern_offset_t fixup_alt_jump;
  pattern_offset_t inner_group_offset;
  pattern_offset_t laststart_offset;
  regnum_t regnum;
} compile_stack_elt_t;


typedef struct
{
  compile_stack_elt_t *stack;
  unsigned size;
  unsigned avail;			/* Offset of next open position.  */
} compile_stack_type;


#  define INIT_COMPILE_STACK_SIZE 32

#  define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
#  define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)

/* The next available element.  */
#  define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])

# endif /* not DEFINED_ONCE */

/* Set the bit for character C in a list.  */
# ifndef DEFINED_ONCE
#  define SET_LIST_BIT(c)                               \
  (b[((unsigned char) (c)) / BYTEWIDTH]               \
   |= 1 << (((unsigned char) c) % BYTEWIDTH))
# endif /* DEFINED_ONCE */

/* Get the next unsigned number in the uncompiled pattern.  */
# define GET_UNSIGNED_NUMBER(num) \
  {									\
    while (p != pend)							\
      {									\
	PATFETCH (c);							\
	if (c < '0' || c > '9')						\
	  break;							\
	if (num <= RE_DUP_MAX)						\
	  {								\
	    if (num < 0)						\
	      num = 0;							\
	    num = num * 10 + c - '0';					\
	  }								\
      }									\
  }

# ifndef DEFINED_ONCE
#  if defined _LIBC || WIDE_CHAR_SUPPORT
/* The GNU C library provides support for user-defined character classes
   and the functions from ISO C amendement 1.  */
#   ifdef CHARCLASS_NAME_MAX
#    define CHAR_CLASS_MAX_LENGTH CHARCLASS_NAME_MAX
#   else
/* This shouldn't happen but some implementation might still have this
   problem.  Use a reasonable default value.  */
#    define CHAR_CLASS_MAX_LENGTH 256
#   endif

#   ifdef _LIBC
#    define IS_CHAR_CLASS(string) __wctype (string)
#   else
#    define IS_CHAR_CLASS(string) wctype (string)
#   endif
#  else
#   define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */

#   define IS_CHAR_CLASS(string)					\
   (STREQ (string, "alpha") || STREQ (string, "upper")			\
    || STREQ (string, "lower") || STREQ (string, "digit")		\
    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
    || STREQ (string, "space") || STREQ (string, "print")		\
    || STREQ (string, "punct") || STREQ (string, "graph")		\
    || STREQ (string, "cntrl") || STREQ (string, "blank"))
#  endif
# endif /* DEFINED_ONCE */

# ifndef MATCH_MAY_ALLOCATE

/* If we cannot allocate large objects within re_match_2_internal,
   we make the fail stack and register vectors global.
   The fail stack, we grow to the maximum size when a regexp
   is compiled.
   The register vectors, we adjust in size each time we
   compile a regexp, according to the number of registers it needs.  */

static PREFIX(fail_stack_type) fail_stack;

/* Size with which the following vectors are currently allocated.
   That is so we can make them bigger as needed,
   but never make them smaller.  */
#  ifdef DEFINED_ONCE
static int regs_allocated_size;

static const char **     regstart, **     regend;
static const char ** old_regstart, ** old_regend;
static const char **best_regstart, **best_regend;
static const char **reg_dummy;
#  endif /* DEFINED_ONCE */

static PREFIX(register_info_type) *PREFIX(reg_info);
static PREFIX(register_info_type) *PREFIX(reg_info_dummy);

/* Make the register vectors big enough for NUM_REGS registers,
   but don't make them smaller.  */

static void
PREFIX(regex_grow_registers) (int num_regs)
{
  if (num_regs > regs_allocated_size)
    {
      RETALLOC_IF (regstart,	 num_regs, const char *);
      RETALLOC_IF (regend,	 num_regs, const char *);
      RETALLOC_IF (old_regstart, num_regs, const char *);
      RETALLOC_IF (old_regend,	 num_regs, const char *);
      RETALLOC_IF (best_regstart, num_regs, const char *);
      RETALLOC_IF (best_regend,	 num_regs, const char *);
      RETALLOC_IF (PREFIX(reg_info), num_regs, PREFIX(register_info_type));
      RETALLOC_IF (reg_dummy,	 num_regs, const char *);
      RETALLOC_IF (PREFIX(reg_info_dummy), num_regs, PREFIX(register_info_type));

      regs_allocated_size = num_regs;
    }
}

# endif /* not MATCH_MAY_ALLOCATE */

# ifndef DEFINED_ONCE
static boolean group_in_compile_stack (compile_stack_type
				       compile_stack,
				       regnum_t regnum);
# endif /* not DEFINED_ONCE */

/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
   Returns one of error codes defined in `regex.h', or zero for success.

   Assumes the `allocated' (and perhaps `buffer') and `translate'
   fields are set in BUFP on entry.

   If it succeeds, results are put in BUFP (if it returns an error, the
   contents of BUFP are undefined):
     `buffer' is the compiled pattern;
     `syntax' is set to SYNTAX;
     `used' is set to the length of the compiled pattern;
     `fastmap_accurate' is zero;
     `re_nsub' is the number of subexpressions in PATTERN;
     `not_bol' and `not_eol' are zero;

   The `fastmap' and `newline_anchor' fields are neither
   examined nor set.  */

/* Return, freeing storage we allocated.  */
# ifdef WCHAR
#  define FREE_STACK_RETURN(value)		\
  return (free(pattern), free(mbs_offset), free(is_binary), free (compile_stack.stack), value)
# else
#  define FREE_STACK_RETURN(value)		\
  return (free (compile_stack.stack), value)
# endif /* WCHAR */

static reg_errcode_t
PREFIX(regex_compile) (const char *ARG_PREFIX(pattern),
		       size_t ARG_PREFIX(size),
		       reg_syntax_t syntax,
		       struct re_pattern_buffer *bufp)
{
  /* We fetch characters from PATTERN here.  Even though PATTERN is
     `char *' (i.e., signed), we declare these variables as unsigned, so
     they can be reliably used as array indices.  */
  register UCHAR_T c, c1;

#ifdef WCHAR
  /* A temporary space to keep wchar_t pattern and compiled pattern.  */
  CHAR_T *pattern, *COMPILED_BUFFER_VAR;
  size_t size;
  /* offset buffer for optimization. See convert_mbs_to_wc.  */
  int *mbs_offset = NULL;
  /* It hold whether each wchar_t is binary data or not.  */
  char *is_binary = NULL;
  /* A flag whether exactn is handling binary data or not.  */
  char is_exactn_bin = FALSE;
#endif /* WCHAR */

  /* A random temporary spot in PATTERN.  */
  const CHAR_T *p1;

  /* Points to the end of the buffer, where we should append.  */
  register UCHAR_T *b;

  /* Keeps track of unclosed groups.  */
  compile_stack_type compile_stack;

  /* Points to the current (ending) position in the pattern.  */
#ifdef WCHAR
  const CHAR_T *p;
  const CHAR_T *pend;
#else /* BYTE */
  const CHAR_T *p = pattern;
  const CHAR_T *pend = pattern + size;
#endif /* WCHAR */

  /* How to translate the characters in the pattern.  */
  RE_TRANSLATE_TYPE translate = bufp->translate;

  /* Address of the count-byte of the most recently inserted `exactn'
     command.  This makes it possible to tell if a new exact-match
     character can be added to that command or if the character requires
     a new `exactn' command.  */
  UCHAR_T *pending_exact = 0;

  /* Address of start of the most recently finished expression.
     This tells, e.g., postfix * where to find the start of its
     operand.  Reset at the beginning of groups and alternatives.  */
  UCHAR_T *laststart = 0;

  /* Address of beginning of regexp, or inside of last group.  */
  UCHAR_T *begalt;

  /* Address of the place where a forward jump should go to the end of
     the containing expression.  Each alternative of an `or' -- except the
     last -- ends with a forward jump of this sort.  */
  UCHAR_T *fixup_alt_jump = 0;

  /* Counts open-groups as they are encountered.  Remembered for the
     matching close-group on the compile stack, so the same register
     number is put in the stop_memory as the start_memory.  */
  regnum_t regnum = 0;

#ifdef WCHAR
  /* Initialize the wchar_t PATTERN and offset_buffer.  */
  p = pend = pattern = TALLOC(csize + 1, CHAR_T);
  mbs_offset = TALLOC(csize + 1, int);
  is_binary = TALLOC(csize + 1, char);
  if (pattern == NULL || mbs_offset == NULL || is_binary == NULL)
    {
      free(pattern);
      free(mbs_offset);
      free(is_binary);
      return REG_ESPACE;
    }
  pattern[csize] = L'\0';	/* sentinel */
  size = convert_mbs_to_wcs(pattern, cpattern, csize, mbs_offset, is_binary);
  pend = p + size;
  if (size < 0)
    {
      free(pattern);
      free(mbs_offset);
      free(is_binary);
      return REG_BADPAT;
    }
#endif

#ifdef DEBUG
  DEBUG_PRINT1 ("\nCompiling pattern: ");
  if (debug)
    {
      unsigned debug_count;

      for (debug_count = 0; debug_count < size; debug_count++)
        PUT_CHAR (pattern[debug_count]);
      putchar ('\n');
    }
#endif /* DEBUG */

  /* Initialize the compile stack.  */
  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
  if (compile_stack.stack == NULL)
    {
#ifdef WCHAR
      free(pattern);
      free(mbs_offset);
      free(is_binary);
#endif
      return REG_ESPACE;
    }

  compile_stack.size = INIT_COMPILE_STACK_SIZE;
  compile_stack.avail = 0;

  /* Initialize the pattern buffer.  */
  bufp->syntax = syntax;
  bufp->fastmap_accurate = 0;
  bufp->not_bol = bufp->not_eol = 0;

  /* Set `used' to zero, so that if we return an error, the pattern
     printer (for debugging) will think there's no pattern.  We reset it
     at the end.  */
  bufp->used = 0;

  /* Always count groups, whether or not bufp->no_sub is set.  */
  bufp->re_nsub = 0;

#if !defined emacs && !defined SYNTAX_TABLE
  /* Initialize the syntax table.  */
   init_syntax_once ();
#endif

  if (bufp->allocated == 0)
    {
      if (bufp->buffer)
	{ /* If zero allocated, but buffer is non-null, try to realloc
             enough space.  This loses if buffer's address is bogus, but
             that is the user's responsibility.  */
#ifdef WCHAR
	  /* Free bufp->buffer and allocate an array for wchar_t pattern
	     buffer.  */
          free(bufp->buffer);
          COMPILED_BUFFER_VAR = TALLOC (INIT_BUF_SIZE/sizeof(UCHAR_T),
					UCHAR_T);
#else
          RETALLOC (COMPILED_BUFFER_VAR, INIT_BUF_SIZE, UCHAR_T);
#endif /* WCHAR */
        }
      else
        { /* Caller did not allocate a buffer.  Do it for them.  */
          COMPILED_BUFFER_VAR = TALLOC (INIT_BUF_SIZE / sizeof(UCHAR_T),
					UCHAR_T);
        }

      if (!COMPILED_BUFFER_VAR) FREE_STACK_RETURN (REG_ESPACE);
#ifdef WCHAR
      bufp->buffer = (char*)COMPILED_BUFFER_VAR;
#endif /* WCHAR */
      bufp->allocated = INIT_BUF_SIZE;
    }
#ifdef WCHAR
  else
    COMPILED_BUFFER_VAR = (UCHAR_T*) bufp->buffer;
#endif

  begalt = b = COMPILED_BUFFER_VAR;

  /* Loop through the uncompiled pattern until we're at the end.  */
  while (p != pend)
    {
      PATFETCH (c);

      switch (c)
        {
        case '^':
          {
            if (   /* If at start of pattern, it's an operator.  */
                   p == pattern + 1
                   /* If context independent, it's an operator.  */
                || syntax & RE_CONTEXT_INDEP_ANCHORS
                   /* Otherwise, depends on what's come before.  */
                || PREFIX(at_begline_loc_p) (pattern, p, syntax))
              BUF_PUSH (begline);
            else
              goto normal_char;
          }
          break;


        case '$':
          {
            if (   /* If at end of pattern, it's an operator.  */
                   p == pend
                   /* If context independent, it's an operator.  */
                || syntax & RE_CONTEXT_INDEP_ANCHORS
                   /* Otherwise, depends on what's next.  */
                || PREFIX(at_endline_loc_p) (p, pend, syntax))
               BUF_PUSH (endline);
             else
               goto normal_char;
           }
           break;


	case '+':
        case '?':
          if ((syntax & RE_BK_PLUS_QM)
              || (syntax & RE_LIMITED_OPS))
            goto normal_char;
        handle_plus:
        case '*':
          /* If there is no previous pattern... */
          if (!laststart)
            {
              if (syntax & RE_CONTEXT_INVALID_OPS)
                FREE_STACK_RETURN (REG_BADRPT);
              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
                goto normal_char;
            }

          {
            /* Are we optimizing this jump?  */
            boolean keep_string_p = false;

            /* 1 means zero (many) matches is allowed.  */
            char zero_times_ok = 0, many_times_ok = 0;

            /* If there is a sequence of repetition chars, collapse it
               down to just one (the right one).  We can't combine
               interval operators with these because of, e.g., `a{2}*',
               which should only match an even number of `a's.  */

            for (;;)
              {
                zero_times_ok |= c != '+';
                many_times_ok |= c != '?';

                if (p == pend)
                  break;

                PATFETCH (c);

                if (c == '*'
                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
                  ;

                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
                  {
                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);

                    PATFETCH (c1);
                    if (!(c1 == '+' || c1 == '?'))
                      {
                        PATUNFETCH;
                        PATUNFETCH;
                        break;
                      }

                    c = c1;
                  }
                else
                  {
                    PATUNFETCH;
                    break;
                  }

                /* If we get here, we found another repeat character.  */
               }

            /* Star, etc. applied to an empty pattern is equivalent
               to an empty pattern.  */
            if (!laststart)
              break;

            /* Now we know whether or not zero matches is allowed
               and also whether or not two or more matches is allowed.  */
            if (many_times_ok)
              { /* More than one repetition is allowed, so put in at the
                   end a backward relative jump from `b' to before the next
                   jump we're going to put in below (which jumps from
                   laststart to after this jump).

                   But if we are at the `*' in the exact sequence `.*\n',
                   insert an unconditional jump backwards to the .,
                   instead of the beginning of the loop.  This way we only
                   push a failure point once, instead of every time
                   through the loop.  */
                assert (p - 1 > pattern);

                /* Allocate the space for the jump.  */
                GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);

                /* We know we are not at the first character of the pattern,
                   because laststart was nonzero.  And we've already
                   incremented `p', by the way, to be the character after
                   the `*'.  Do we have to do something analogous here
                   for null bytes, because of RE_DOT_NOT_NULL?  */
                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
		    && zero_times_ok
                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
                    && !(syntax & RE_DOT_NEWLINE))
                  { /* We have .*\n.  */
                    STORE_JUMP (jump, b, laststart);
                    keep_string_p = true;
                  }
                else
                  /* Anything else.  */
                  STORE_JUMP (maybe_pop_jump, b, laststart -
			      (1 + OFFSET_ADDRESS_SIZE));

                /* We've added more stuff to the buffer.  */
                b += 1 + OFFSET_ADDRESS_SIZE;
              }

            /* On failure, jump from laststart to b + 3, which will be the
               end of the buffer after this jump is inserted.  */
	    /* ifdef WCHAR, 'b + 1 + OFFSET_ADDRESS_SIZE' instead of
	       'b + 3'.  */
            GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);
            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
                                       : on_failure_jump,
                         laststart, b + 1 + OFFSET_ADDRESS_SIZE);
            pending_exact = 0;
            b += 1 + OFFSET_ADDRESS_SIZE;

            if (!zero_times_ok)
              {
                /* At least one repetition is required, so insert a
                   `dummy_failure_jump' before the initial
                   `on_failure_jump' instruction of the loop. This
                   effects a skip over that instruction the first time
                   we hit that loop.  */
                GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);
                INSERT_JUMP (dummy_failure_jump, laststart, laststart +
			     2 + 2 * OFFSET_ADDRESS_SIZE);
                b += 1 + OFFSET_ADDRESS_SIZE;
              }
            }
	  break;


	case '.':
          laststart = b;
          BUF_PUSH (anychar);
          break;


        case '[':
          {
            boolean had_char_class = false;
#ifdef WCHAR
	    CHAR_T range_start = 0xffffffff;
#else
	    unsigned int range_start = 0xffffffff;
#endif
            if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

#ifdef WCHAR
	    /* We assume a charset(_not) structure as a wchar_t array.
	       charset[0] = (re_opcode_t) charset(_not)
               charset[1] = l (= length of char_classes)
               charset[2] = m (= length of collating_symbols)
               charset[3] = n (= length of equivalence_classes)
	       charset[4] = o (= length of char_ranges)
	       charset[5] = p (= length of chars)

               charset[6] = char_class (wctype_t)
               charset[6+CHAR_CLASS_SIZE] = char_class (wctype_t)
                         ...
               charset[l+5]  = char_class (wctype_t)

               charset[l+6]  = collating_symbol (wchar_t)
                            ...
               charset[l+m+5]  = collating_symbol (wchar_t)
					ifdef _LIBC we use the index if
					_NL_COLLATE_SYMB_EXTRAMB instead of
					wchar_t string.

               charset[l+m+6]  = equivalence_classes (wchar_t)
                              ...
               charset[l+m+n+5]  = equivalence_classes (wchar_t)
					ifdef _LIBC we use the index in
					_NL_COLLATE_WEIGHT instead of
					wchar_t string.

	       charset[l+m+n+6] = range_start
	       charset[l+m+n+7] = range_end
	                       ...
	       charset[l+m+n+2o+4] = range_start
	       charset[l+m+n+2o+5] = range_end
					ifdef _LIBC we use the value looked up
					in _NL_COLLATE_COLLSEQ instead of
					wchar_t character.

	       charset[l+m+n+2o+6] = char
	                          ...
	       charset[l+m+n+2o+p+5] = char

	     */

	    /* We need at least 6 spaces: the opcode, the length of
               char_classes, the length of collating_symbols, the length of
               equivalence_classes, the length of char_ranges, the length of
               chars.  */
	    GET_BUFFER_SPACE (6);

	    /* Save b as laststart. And We use laststart as the pointer
	       to the first element of the charset here.
	       In other words, laststart[i] indicates charset[i].  */
            laststart = b;

            /* We test `*p == '^' twice, instead of using an if
               statement, so we only need one BUF_PUSH.  */
            BUF_PUSH (*p == '^' ? charset_not : charset);
            if (*p == '^')
              p++;

            /* Push the length of char_classes, the length of
               collating_symbols, the length of equivalence_classes, the
               length of char_ranges and the length of chars.  */
            BUF_PUSH_3 (0, 0, 0);
            BUF_PUSH_2 (0, 0);

            /* Remember the first position in the bracket expression.  */
            p1 = p;

            /* charset_not matches newline according to a syntax bit.  */
            if ((re_opcode_t) b[-6] == charset_not
                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
	      {
		BUF_PUSH('\n');
		laststart[5]++; /* Update the length of characters  */
	      }

            /* Read in characters and ranges, setting map bits.  */
            for (;;)
              {
                if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                PATFETCH (c);

                /* \ might escape characters inside [...] and [^...].  */
                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
                  {
                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);

                    PATFETCH (c1);
		    BUF_PUSH(c1);
		    laststart[5]++; /* Update the length of chars  */
		    range_start = c1;
                    continue;
                  }

                /* Could be the end of the bracket expression.  If it's
                   not (i.e., when the bracket expression is `[]' so
                   far), the ']' character bit gets set way below.  */
                if (c == ']' && p != p1 + 1)
                  break;

                /* Look ahead to see if it's a range when the last thing
                   was a character class.  */
                if (had_char_class && c == '-' && *p != ']')
                  FREE_STACK_RETURN (REG_ERANGE);

                /* Look ahead to see if it's a range when the last thing
                   was a character: if this is a hyphen not at the
                   beginning or the end of a list, then it's the range
                   operator.  */
                if (c == '-'
                    && !(p - 2 >= pattern && p[-2] == '[')
                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
                    && *p != ']')
                  {
                    reg_errcode_t ret;
		    /* Allocate the space for range_start and range_end.  */
		    GET_BUFFER_SPACE (2);
		    /* Update the pointer to indicate end of buffer.  */
                    b += 2;
                    ret = wcs_compile_range (range_start, &p, pend, translate,
                                         syntax, b, laststart);
                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
                    range_start = 0xffffffff;
                  }
                else if (p[0] == '-' && p[1] != ']')
                  { /* This handles ranges made up of characters only.  */
                    reg_errcode_t ret;

		    /* Move past the `-'.  */
                    PATFETCH (c1);
		    /* Allocate the space for range_start and range_end.  */
		    GET_BUFFER_SPACE (2);
		    /* Update the pointer to indicate end of buffer.  */
                    b += 2;
                    ret = wcs_compile_range (c, &p, pend, translate, syntax, b,
                                         laststart);
                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
		    range_start = 0xffffffff;
                  }

                /* See if we're at the beginning of a possible character
                   class.  */
                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
                  { /* Leave room for the null.  */
                    char str[CHAR_CLASS_MAX_LENGTH + 1];

                    PATFETCH (c);
                    c1 = 0;

                    /* If pattern is `[[:'.  */
                    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                    for (;;)
                      {
                        PATFETCH (c);
                        if ((c == ':' && *p == ']') || p == pend)
                          break;
			if (c1 < CHAR_CLASS_MAX_LENGTH)
			  str[c1++] = c;
			else
			  /* This is in any case an invalid class name.  */
			  str[0] = '\0';
                      }
                    str[c1] = '\0';

                    /* If isn't a word bracketed by `[:' and `:]':
                       undo the ending character, the letters, and leave
                       the leading `:' and `[' (but store them as character).  */
                    if (c == ':' && *p == ']')
                      {
			wctype_t wt;
			uintptr_t alignedp;

			/* Query the character class as wctype_t.  */
			wt = IS_CHAR_CLASS (str);
			if (wt == 0)
			  FREE_STACK_RETURN (REG_ECTYPE);

                        /* Throw away the ] at the end of the character
                           class.  */
                        PATFETCH (c);

                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

			/* Allocate the space for character class.  */
                        GET_BUFFER_SPACE(CHAR_CLASS_SIZE);
			/* Update the pointer to indicate end of buffer.  */
                        b += CHAR_CLASS_SIZE;
			/* Move data which follow character classes
			    not to violate the data.  */
                        insert_space(CHAR_CLASS_SIZE,
				     laststart + 6 + laststart[1],
				     b - 1);
			alignedp = ((uintptr_t)(laststart + 6 + laststart[1])
				    + __alignof__(wctype_t) - 1)
			  	    & ~(uintptr_t)(__alignof__(wctype_t) - 1);
			/* Store the character class.  */
                        *((wctype_t*)alignedp) = wt;
                        /* Update length of char_classes */
                        laststart[1] += CHAR_CLASS_SIZE;

                        had_char_class = true;
                      }
                    else
                      {
                        c1++;
                        while (c1--)
                          PATUNFETCH;
                        BUF_PUSH ('[');
                        BUF_PUSH (':');
                        laststart[5] += 2; /* Update the length of characters  */
			range_start = ':';
                        had_char_class = false;
                      }
                  }
                else if (syntax & RE_CHAR_CLASSES && c == '[' && (*p == '='
							  || *p == '.'))
		  {
		    CHAR_T str[128];	/* Should be large enough.  */
		    CHAR_T delim = *p; /* '=' or '.'  */
# ifdef _LIBC
		    uint32_t nrules =
		      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
# endif
		    PATFETCH (c);
		    c1 = 0;

		    /* If pattern is `[[=' or '[[.'.  */
		    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

		    for (;;)
		      {
			PATFETCH (c);
			if ((c == delim && *p == ']') || p == pend)
			  break;
			if (c1 < sizeof (str) - 1)
			  str[c1++] = c;
			else
			  /* This is in any case an invalid class name.  */
			  str[0] = '\0';
                      }
		    str[c1] = '\0';

		    if (c == delim && *p == ']' && str[0] != '\0')
		      {
                        unsigned int i, offset;
			/* If we have no collation data we use the default
			   collation in which each character is in a class
			   by itself.  It also means that ASCII is the
			   character set and therefore we cannot have character
			   with more than one byte in the multibyte
			   representation.  */

                        /* If not defined _LIBC, we push the name and
			   `\0' for the sake of matching performance.  */
			int datasize = c1 + 1;

# ifdef _LIBC
			int32_t idx = 0;
			if (nrules == 0)
# endif
			  {
			    if (c1 != 1)
			      FREE_STACK_RETURN (REG_ECOLLATE);
			  }
# ifdef _LIBC
			else
			  {
			    const int32_t *table;
			    const int32_t *weights;
			    const int32_t *extra;
			    const int32_t *indirect;
			    wint_t *cp;

			    /* This #include defines a local function!  */
#  include <locale/weightwc.h>

			    if(delim == '=')
			      {
				/* We push the index for equivalence class.  */
				cp = (wint_t*)str;

				table = (const int32_t *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_TABLEWC);
				weights = (const int32_t *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_WEIGHTWC);
				extra = (const int32_t *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_EXTRAWC);
				indirect = (const int32_t *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_INDIRECTWC);

				idx = findidx ((const wint_t**)&cp);
				if (idx == 0 || cp < (wint_t*) str + c1)
				  /* This is no valid character.  */
				  FREE_STACK_RETURN (REG_ECOLLATE);

				str[0] = (wchar_t)idx;
			      }
			    else /* delim == '.' */
			      {
				/* We push collation sequence value
				   for collating symbol.  */
				int32_t table_size;
				const int32_t *symb_table;
				const unsigned char *extra;
				int32_t idx;
				int32_t elem;
				int32_t second;
				int32_t hash;
				char char_str[c1];

				/* We have to convert the name to a single-byte
				   string.  This is possible since the names
				   consist of ASCII characters and the internal
				   representation is UCS4.  */
				for (i = 0; i < c1; ++i)
				  char_str[i] = str[i];

				table_size =
				  _NL_CURRENT_WORD (LC_COLLATE,
						    _NL_COLLATE_SYMB_HASH_SIZEMB);
				symb_table = (const int32_t *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_SYMB_TABLEMB);
				extra = (const unsigned char *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_SYMB_EXTRAMB);

				/* Locate the character in the hashing table.  */
				hash = elem_hash (char_str, c1);

				idx = 0;
				elem = hash % table_size;
				second = hash % (table_size - 2);
				while (symb_table[2 * elem] != 0)
				  {
				    /* First compare the hashing value.  */
				    if (symb_table[2 * elem] == hash
					&& c1 == extra[symb_table[2 * elem + 1]]
					&& memcmp (char_str,
						   &extra[symb_table[2 * elem + 1]
							 + 1], c1) == 0)
				      {
					/* Yep, this is the entry.  */
					idx = symb_table[2 * elem + 1];
					idx += 1 + extra[idx];
					break;
				      }

				    /* Next entry.  */
				    elem += second;
				  }

				if (symb_table[2 * elem] != 0)
				  {
				    /* Compute the index of the byte sequence
				       in the table.  */
				    idx += 1 + extra[idx];
				    /* Adjust for the alignment.  */
				    idx = (idx + 3) & ~3;

				    str[0] = (wchar_t) idx + 4;
				  }
				else if (symb_table[2 * elem] == 0 && c1 == 1)
				  {
				    /* No valid character.  Match it as a
				       single byte character.  */
				    had_char_class = false;
				    BUF_PUSH(str[0]);
				    /* Update the length of characters  */
				    laststart[5]++;
				    range_start = str[0];

				    /* Throw away the ] at the end of the
				       collating symbol.  */
				    PATFETCH (c);
				    /* exit from the switch block.  */
				    continue;
				  }
				else
				  FREE_STACK_RETURN (REG_ECOLLATE);
			      }
			    datasize = 1;
			  }
# endif
                        /* Throw away the ] at the end of the equivalence
                           class (or collating symbol).  */
                        PATFETCH (c);

			/* Allocate the space for the equivalence class
			   (or collating symbol) (and '\0' if needed).  */
                        GET_BUFFER_SPACE(datasize);
			/* Update the pointer to indicate end of buffer.  */
                        b += datasize;

			if (delim == '=')
			  { /* equivalence class  */
			    /* Calculate the offset of char_ranges,
			       which is next to equivalence_classes.  */
			    offset = laststart[1] + laststart[2]
			      + laststart[3] +6;
			    /* Insert space.  */
			    insert_space(datasize, laststart + offset, b - 1);

			    /* Write the equivalence_class and \0.  */
			    for (i = 0 ; i < datasize ; i++)
			      laststart[offset + i] = str[i];

			    /* Update the length of equivalence_classes.  */
			    laststart[3] += datasize;
			    had_char_class = true;
			  }
			else /* delim == '.' */
			  { /* collating symbol  */
			    /* Calculate the offset of the equivalence_classes,
			       which is next to collating_symbols.  */
			    offset = laststart[1] + laststart[2] + 6;
			    /* Insert space and write the collationg_symbol
			       and \0.  */
			    insert_space(datasize, laststart + offset, b-1);
			    for (i = 0 ; i < datasize ; i++)
			      laststart[offset + i] = str[i];

			    /* In re_match_2_internal if range_start < -1, we
			       assume -range_start is the offset of the
			       collating symbol which is specified as
			       the character of the range start.  So we assign
			       -(laststart[1] + laststart[2] + 6) to
			       range_start.  */
			    range_start = -(laststart[1] + laststart[2] + 6);
			    /* Update the length of collating_symbol.  */
			    laststart[2] += datasize;
			    had_char_class = false;
			  }
		      }
                    else
                      {
                        c1++;
                        while (c1--)
                          PATUNFETCH;
                        BUF_PUSH ('[');
                        BUF_PUSH (delim);
                        laststart[5] += 2; /* Update the length of characters  */
			range_start = delim;
                        had_char_class = false;
                      }
		  }
                else
                  {
                    had_char_class = false;
		    BUF_PUSH(c);
		    laststart[5]++;  /* Update the length of characters  */
		    range_start = c;
                  }
	      }

#else /* BYTE */
            /* Ensure that we have enough space to push a charset: the
               opcode, the length count, and the bitset; 34 bytes in all.  */
	    GET_BUFFER_SPACE (34);

            laststart = b;

            /* We test `*p == '^' twice, instead of using an if
               statement, so we only need one BUF_PUSH.  */
            BUF_PUSH (*p == '^' ? charset_not : charset);
            if (*p == '^')
              p++;

            /* Remember the first position in the bracket expression.  */
            p1 = p;

            /* Push the number of bytes in the bitmap.  */
            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);

            /* Clear the whole map.  */
            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);

            /* charset_not matches newline according to a syntax bit.  */
            if ((re_opcode_t) b[-2] == charset_not
                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
              SET_LIST_BIT ('\n');

            /* Read in characters and ranges, setting map bits.  */
            for (;;)
              {
                if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                PATFETCH (c);

                /* \ might escape characters inside [...] and [^...].  */
                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
                  {
                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);

                    PATFETCH (c1);
                    SET_LIST_BIT (c1);
		    range_start = c1;
                    continue;
                  }

                /* Could be the end of the bracket expression.  If it's
                   not (i.e., when the bracket expression is `[]' so
                   far), the ']' character bit gets set way below.  */
                if (c == ']' && p != p1 + 1)
                  break;

                /* Look ahead to see if it's a range when the last thing
                   was a character class.  */
                if (had_char_class && c == '-' && *p != ']')
                  FREE_STACK_RETURN (REG_ERANGE);

                /* Look ahead to see if it's a range when the last thing
                   was a character: if this is a hyphen not at the
                   beginning or the end of a list, then it's the range
                   operator.  */
                if (c == '-'
                    && !(p - 2 >= pattern && p[-2] == '[')
                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
                    && *p != ']')
                  {
                    reg_errcode_t ret
                      = byte_compile_range (range_start, &p, pend, translate,
					    syntax, b);
                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
		    range_start = 0xffffffff;
                  }

                else if (p[0] == '-' && p[1] != ']')
                  { /* This handles ranges made up of characters only.  */
                    reg_errcode_t ret;

		    /* Move past the `-'.  */
                    PATFETCH (c1);

                    ret = byte_compile_range (c, &p, pend, translate, syntax, b);
                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
		    range_start = 0xffffffff;
                  }

                /* See if we're at the beginning of a possible character
                   class.  */

                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
                  { /* Leave room for the null.  */
                    char str[CHAR_CLASS_MAX_LENGTH + 1];

                    PATFETCH (c);
                    c1 = 0;

                    /* If pattern is `[[:'.  */
                    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                    for (;;)
                      {
                        PATFETCH (c);
                        if ((c == ':' && *p == ']') || p == pend)
                          break;
			if (c1 < CHAR_CLASS_MAX_LENGTH)
			  str[c1++] = c;
			else
			  /* This is in any case an invalid class name.  */
			  str[0] = '\0';
                      }
                    str[c1] = '\0';

                    /* If isn't a word bracketed by `[:' and `:]':
                       undo the ending character, the letters, and leave
                       the leading `:' and `[' (but set bits for them).  */
                    if (c == ':' && *p == ']')
                      {
# if defined _LIBC || WIDE_CHAR_SUPPORT
                        boolean is_lower = STREQ (str, "lower");
                        boolean is_upper = STREQ (str, "upper");
			wctype_t wt;
                        int ch;

			wt = IS_CHAR_CLASS (str);
			if (wt == 0)
			  FREE_STACK_RETURN (REG_ECTYPE);

                        /* Throw away the ] at the end of the character
                           class.  */
                        PATFETCH (c);

                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                        for (ch = 0; ch < 1 << BYTEWIDTH; ++ch)
			  {
			    if (iswctype (btowc (ch), wt))
			      SET_LIST_BIT (ch);

			    if (translate && (is_upper || is_lower)
				&& (ISUPPER (ch) || ISLOWER (ch)))
			      SET_LIST_BIT (ch);
			  }

                        had_char_class = true;
# else
                        int ch;
                        boolean is_alnum = STREQ (str, "alnum");
                        boolean is_alpha = STREQ (str, "alpha");
                        boolean is_blank = STREQ (str, "blank");
                        boolean is_cntrl = STREQ (str, "cntrl");
                        boolean is_digit = STREQ (str, "digit");
                        boolean is_graph = STREQ (str, "graph");
                        boolean is_lower = STREQ (str, "lower");
                        boolean is_print = STREQ (str, "print");
                        boolean is_punct = STREQ (str, "punct");
                        boolean is_space = STREQ (str, "space");
                        boolean is_upper = STREQ (str, "upper");
                        boolean is_xdigit = STREQ (str, "xdigit");

                        if (!IS_CHAR_CLASS (str))
			  FREE_STACK_RETURN (REG_ECTYPE);

                        /* Throw away the ] at the end of the character
                           class.  */
                        PATFETCH (c);

                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
                          {
			    /* This was split into 3 if's to
			       avoid an arbitrary limit in some compiler.  */
                            if (   (is_alnum  && ISALNUM (ch))
                                || (is_alpha  && ISALPHA (ch))
                                || (is_blank  && ISBLANK (ch))
                                || (is_cntrl  && ISCNTRL (ch)))
			      SET_LIST_BIT (ch);
			    if (   (is_digit  && ISDIGIT (ch))
                                || (is_graph  && ISGRAPH (ch))
                                || (is_lower  && ISLOWER (ch))
                                || (is_print  && ISPRINT (ch)))
			      SET_LIST_BIT (ch);
			    if (   (is_punct  && ISPUNCT (ch))
                                || (is_space  && ISSPACE (ch))
                                || (is_upper  && ISUPPER (ch))
                                || (is_xdigit && ISXDIGIT (ch)))
			      SET_LIST_BIT (ch);
			    if (   translate && (is_upper || is_lower)
				&& (ISUPPER (ch) || ISLOWER (ch)))
			      SET_LIST_BIT (ch);
                          }
                        had_char_class = true;
# endif	/* libc || wctype.h */
                      }
                    else
                      {
                        c1++;
                        while (c1--)
                          PATUNFETCH;
                        SET_LIST_BIT ('[');
                        SET_LIST_BIT (':');
			range_start = ':';
                        had_char_class = false;
                      }
                  }
                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == '=')
		  {
		    unsigned char str[MB_LEN_MAX + 1];
# ifdef _LIBC
		    uint32_t nrules =
		      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
# endif

		    PATFETCH (c);
		    c1 = 0;

		    /* If pattern is `[[='.  */
		    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

		    for (;;)
		      {
			PATFETCH (c);
			if ((c == '=' && *p == ']') || p == pend)
			  break;
			if (c1 < MB_LEN_MAX)
			  str[c1++] = c;
			else
			  /* This is in any case an invalid class name.  */
			  str[0] = '\0';
                      }
		    str[c1] = '\0';

		    if (c == '=' && *p == ']' && str[0] != '\0')
		      {
			/* If we have no collation data we use the default
			   collation in which each character is in a class
			   by itself.  It also means that ASCII is the
			   character set and therefore we cannot have character
			   with more than one byte in the multibyte
			   representation.  */
# ifdef _LIBC
			if (nrules == 0)
# endif
			  {
			    if (c1 != 1)
			      FREE_STACK_RETURN (REG_ECOLLATE);

			    /* Throw away the ] at the end of the equivalence
			       class.  */
			    PATFETCH (c);

			    /* Set the bit for the character.  */
			    SET_LIST_BIT (str[0]);
			  }
# ifdef _LIBC
			else
			  {
			    /* Try to match the byte sequence in `str' against
			       those known to the collate implementation.
			       First find out whether the bytes in `str' are
			       actually from exactly one character.  */
			    const int32_t *table;
			    const unsigned char *weights;
			    const unsigned char *extra;
			    const int32_t *indirect;
			    int32_t idx;
			    const unsigned char *cp = str;
			    int ch;

			    /* This #include defines a local function!  */
#  include <locale/weight.h>

			    table = (const int32_t *)
			      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);
			    weights = (const unsigned char *)
			      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);
			    extra = (const unsigned char *)
			      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);
			    indirect = (const int32_t *)
			      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);

			    idx = findidx (&cp);
			    if (idx == 0 || cp < str + c1)
			      /* This is no valid character.  */
			      FREE_STACK_RETURN (REG_ECOLLATE);

			    /* Throw away the ] at the end of the equivalence
			       class.  */
			    PATFETCH (c);

			    /* Now we have to go throught the whole table
			       and find all characters which have the same
			       first level weight.

			       XXX Note that this is not entirely correct.
			       we would have to match multibyte sequences
			       but this is not possible with the current
			       implementation.  */
			    for (ch = 1; ch < 256; ++ch)
			      /* XXX This test would have to be changed if we
				 would allow matching multibyte sequences.  */
			      if (table[ch] > 0)
				{
				  int32_t idx2 = table[ch];
				  size_t len = weights[idx2];

				  /* Test whether the lenghts match.  */
				  if (weights[idx] == len)
				    {
				      /* They do.  New compare the bytes of
					 the weight.  */
				      size_t cnt = 0;

				      while (cnt < len
					     && (weights[idx + 1 + cnt]
						 == weights[idx2 + 1 + cnt]))
					++cnt;

				      if (cnt == len)
					/* They match.  Mark the character as
					   acceptable.  */
					SET_LIST_BIT (ch);
				    }
				}
			  }
# endif
			had_char_class = true;
		      }
                    else
                      {
                        c1++;
                        while (c1--)
                          PATUNFETCH;
                        SET_LIST_BIT ('[');
                        SET_LIST_BIT ('=');
			range_start = '=';
                        had_char_class = false;
                      }
		  }
                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == '.')
		  {
		    unsigned char str[128];	/* Should be large enough.  */
# ifdef _LIBC
		    uint32_t nrules =
		      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
# endif

		    PATFETCH (c);
		    c1 = 0;

		    /* If pattern is `[[.'.  */
		    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

		    for (;;)
		      {
			PATFETCH (c);
			if ((c == '.' && *p == ']') || p == pend)
			  break;
			if (c1 < sizeof (str))
			  str[c1++] = c;
			else
			  /* This is in any case an invalid class name.  */
			  str[0] = '\0';
                      }
		    str[c1] = '\0';

		    if (c == '.' && *p == ']' && str[0] != '\0')
		      {
			/* If we have no collation data we use the default
			   collation in which each character is the name
			   for its own class which contains only the one
			   character.  It also means that ASCII is the
			   character set and therefore we cannot have character
			   with more than one byte in the multibyte
			   representation.  */
# ifdef _LIBC
			if (nrules == 0)
# endif
			  {
			    if (c1 != 1)
			      FREE_STACK_RETURN (REG_ECOLLATE);

			    /* Throw away the ] at the end of the equivalence
			       class.  */
			    PATFETCH (c);

			    /* Set the bit for the character.  */
			    SET_LIST_BIT (str[0]);
			    range_start = ((const unsigned char *) str)[0];
			  }
# ifdef _LIBC
			else
			  {
			    /* Try to match the byte sequence in `str' against
			       those known to the collate implementation.
			       First find out whether the bytes in `str' are
			       actually from exactly one character.  */
			    int32_t table_size;
			    const int32_t *symb_table;
			    const unsigned char *extra;
			    int32_t idx;
			    int32_t elem;
			    int32_t second;
			    int32_t hash;

			    table_size =
			      _NL_CURRENT_WORD (LC_COLLATE,
						_NL_COLLATE_SYMB_HASH_SIZEMB);
			    symb_table = (const int32_t *)
			      _NL_CURRENT (LC_COLLATE,
					   _NL_COLLATE_SYMB_TABLEMB);
			    extra = (const unsigned char *)
			      _NL_CURRENT (LC_COLLATE,
					   _NL_COLLATE_SYMB_EXTRAMB);

			    /* Locate the character in the hashing table.  */
			    hash = elem_hash (str, c1);

			    idx = 0;
			    elem = hash % table_size;
			    second = hash % (table_size - 2);
			    while (symb_table[2 * elem] != 0)
			      {
				/* First compare the hashing value.  */
				if (symb_table[2 * elem] == hash
				    && c1 == extra[symb_table[2 * elem + 1]]
				    && memcmp (str,
					       &extra[symb_table[2 * elem + 1]
						     + 1],
					       c1) == 0)
				  {
				    /* Yep, this is the entry.  */
				    idx = symb_table[2 * elem + 1];
				    idx += 1 + extra[idx];
				    break;
				  }

				/* Next entry.  */
				elem += second;
			      }

			    if (symb_table[2 * elem] == 0)
			      /* This is no valid character.  */
			      FREE_STACK_RETURN (REG_ECOLLATE);

			    /* Throw away the ] at the end of the equivalence
			       class.  */
			    PATFETCH (c);

			    /* Now add the multibyte character(s) we found
			       to the accept list.

			       XXX Note that this is not entirely correct.
			       we would have to match multibyte sequences
			       but this is not possible with the current
			       implementation.  Also, we have to match
			       collating symbols, which expand to more than
			       one file, as a whole and not allow the
			       individual bytes.  */
			    c1 = extra[idx++];
			    if (c1 == 1)
			      range_start = extra[idx];
			    while (c1-- > 0)
			      {
				SET_LIST_BIT (extra[idx]);
				++idx;
			      }
			  }
# endif
			had_char_class = false;
		      }
                    else
                      {
                        c1++;
                        while (c1--)
                          PATUNFETCH;
                        SET_LIST_BIT ('[');
                        SET_LIST_BIT ('.');
			range_start = '.';
                        had_char_class = false;
                      }
		  }
                else
                  {
                    had_char_class = false;
                    SET_LIST_BIT (c);
		    range_start = c;
                  }
              }

            /* Discard any (non)matching list bytes that are all 0 at the
               end of the map.  Decrease the map-length byte too.  */
            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0)
              b[-1]--;
            b += b[-1];
#endif /* WCHAR */
          }
          break;


	case '(':
          if (syntax & RE_NO_BK_PARENS)
            goto handle_open;
          else
            goto normal_char;


        case ')':
          if (syntax & RE_NO_BK_PARENS)
            goto handle_close;
          else
            goto normal_char;


        case '\n':
          if (syntax & RE_NEWLINE_ALT)
            goto handle_alt;
          else
            goto normal_char;


	case '|':
          if (syntax & RE_NO_BK_VBAR)
            goto handle_alt;
          else
            goto normal_char;


        case '{':
           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
             goto handle_interval;
           else
             goto normal_char;


        case '\\':
          if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);

          /* Do not translate the character after the \, so that we can
             distinguish, e.g., \B from \b, even if we normally would
             translate, e.g., B to b.  */
          PATFETCH_RAW (c);

          switch (c)
            {
            case '(':
              if (syntax & RE_NO_BK_PARENS)
                goto normal_backslash;

            handle_open:
              bufp->re_nsub++;
              regnum++;

              if (COMPILE_STACK_FULL)
                {
                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
                            compile_stack_elt_t);
                  if (compile_stack.stack == NULL) return REG_ESPACE;

                  compile_stack.size <<= 1;
                }

              /* These are the values to restore when we hit end of this
                 group.  They are all relative offsets, so that if the
                 whole pattern moves because of realloc, they will still
                 be valid.  */
              COMPILE_STACK_TOP.begalt_offset = begalt - COMPILED_BUFFER_VAR;
              COMPILE_STACK_TOP.fixup_alt_jump
                = fixup_alt_jump ? fixup_alt_jump - COMPILED_BUFFER_VAR + 1 : 0;
              COMPILE_STACK_TOP.laststart_offset = b - COMPILED_BUFFER_VAR;
              COMPILE_STACK_TOP.regnum = regnum;

              /* We will eventually replace the 0 with the number of
                 groups inner to this one.  But do not push a
                 start_memory for groups beyond the last one we can
                 represent in the compiled pattern.  */
              if (regnum <= MAX_REGNUM)
                {
                  COMPILE_STACK_TOP.inner_group_offset = b
		    - COMPILED_BUFFER_VAR + 2;
                  BUF_PUSH_3 (start_memory, regnum, 0);
                }

              compile_stack.avail++;

              fixup_alt_jump = 0;
              laststart = 0;
              begalt = b;
	      /* If we've reached MAX_REGNUM groups, then this open
		 won't actually generate any code, so we'll have to
		 clear pending_exact explicitly.  */
	      pending_exact = 0;
              break;


            case ')':
              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;

              if (COMPILE_STACK_EMPTY)
		{
		  if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
		    goto normal_backslash;
		  else
		    FREE_STACK_RETURN (REG_ERPAREN);
		}

            handle_close:
              if (fixup_alt_jump)
                { /* Push a dummy failure point at the end of the
                     alternative for a possible future
                     `pop_failure_jump' to pop.  See comments at
                     `push_dummy_failure' in `re_match_2'.  */
                  BUF_PUSH (push_dummy_failure);

                  /* We allocated space for this jump when we assigned
                     to `fixup_alt_jump', in the `handle_alt' case below.  */
                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
                }

              /* See similar code for backslashed left paren above.  */
              if (COMPILE_STACK_EMPTY)
		{
		  if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
		    goto normal_char;
		  else
		    FREE_STACK_RETURN (REG_ERPAREN);
		}

              /* Since we just checked for an empty stack above, this
                 ``can't happen''.  */
              assert (compile_stack.avail != 0);
              {
                /* We don't just want to restore into `regnum', because
                   later groups should continue to be numbered higher,
                   as in `(ab)c(de)' -- the second group is #2.  */
                regnum_t this_group_regnum;

                compile_stack.avail--;
                begalt = COMPILED_BUFFER_VAR + COMPILE_STACK_TOP.begalt_offset;
                fixup_alt_jump
                  = COMPILE_STACK_TOP.fixup_alt_jump
                    ? COMPILED_BUFFER_VAR + COMPILE_STACK_TOP.fixup_alt_jump - 1
                    : 0;
                laststart = COMPILED_BUFFER_VAR + COMPILE_STACK_TOP.laststart_offset;
                this_group_regnum = COMPILE_STACK_TOP.regnum;
		/* If we've reached MAX_REGNUM groups, then this open
		   won't actually generate any code, so we'll have to
		   clear pending_exact explicitly.  */
		pending_exact = 0;

                /* We're at the end of the group, so now we know how many
                   groups were inside this one.  */
                if (this_group_regnum <= MAX_REGNUM)
                  {
		    UCHAR_T *inner_group_loc
                      = COMPILED_BUFFER_VAR + COMPILE_STACK_TOP.inner_group_offset;

                    *inner_group_loc = regnum - this_group_regnum;
                    BUF_PUSH_3 (stop_memory, this_group_regnum,
                                regnum - this_group_regnum);
                  }
              }
              break;


            case '|':					/* `\|'.  */
              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
                goto normal_backslash;
            handle_alt:
              if (syntax & RE_LIMITED_OPS)
                goto normal_char;

              /* Insert before the previous alternative a jump which
                 jumps to this alternative if the former fails.  */
              GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);
              INSERT_JUMP (on_failure_jump, begalt,
			   b + 2 + 2 * OFFSET_ADDRESS_SIZE);
              pending_exact = 0;
              b += 1 + OFFSET_ADDRESS_SIZE;

              /* The alternative before this one has a jump after it
                 which gets executed if it gets matched.  Adjust that
                 jump so it will jump to this alternative's analogous
                 jump (put in below, which in turn will jump to the next
                 (if any) alternative's such jump, etc.).  The last such
                 jump jumps to the correct final destination.  A picture:
                          _____ _____
                          |   | |   |
                          |   v |   v
                         a | b   | c

                 If we are at `b', then fixup_alt_jump right now points to a
                 three-byte space after `a'.  We'll put in the jump, set
                 fixup_alt_jump to right after `b', and leave behind three
                 bytes which we'll fill in when we get to after `c'.  */

              if (fixup_alt_jump)
                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);

              /* Mark and leave space for a jump after this alternative,
                 to be filled in later either by next alternative or
                 when know we're at the end of a series of alternatives.  */
              fixup_alt_jump = b;
              GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);
              b += 1 + OFFSET_ADDRESS_SIZE;

              laststart = 0;
              begalt = b;
              break;


            case '{':
              /* If \{ is a literal.  */
              if (!(syntax & RE_INTERVALS)
                     /* If we're at `\{' and it's not the open-interval
                        operator.  */
		  || (syntax & RE_NO_BK_BRACES))
                goto normal_backslash;

            handle_interval:
              {
                /* If got here, then the syntax allows intervals.  */

                /* At least (most) this many matches must be made.  */
                int lower_bound = -1, upper_bound = -1;

		/* Place in the uncompiled pattern (i.e., just after
		   the '{') to go back to if the interval is invalid.  */
		const CHAR_T *beg_interval = p;

                if (p == pend)
		  goto invalid_interval;

                GET_UNSIGNED_NUMBER (lower_bound);

                if (c == ',')
                  {
                    GET_UNSIGNED_NUMBER (upper_bound);
		    if (upper_bound < 0)
		      upper_bound = RE_DUP_MAX;
                  }
                else
                  /* Interval such as `{1}' => match exactly once. */
                  upper_bound = lower_bound;

                if (! (0 <= lower_bound && lower_bound <= upper_bound))
		  goto invalid_interval;

                if (!(syntax & RE_NO_BK_BRACES))
                  {
		    if (c != '\\' || p == pend)
		      goto invalid_interval;
                    PATFETCH (c);
                  }

                if (c != '}')
		  goto invalid_interval;

                /* If it's invalid to have no preceding re.  */
                if (!laststart)
                  {
		    if (syntax & RE_CONTEXT_INVALID_OPS
			&& !(syntax & RE_INVALID_INTERVAL_ORD))
                      FREE_STACK_RETURN (REG_BADRPT);
                    else if (syntax & RE_CONTEXT_INDEP_OPS)
                      laststart = b;
                    else
                      goto unfetch_interval;
                  }

                /* We just parsed a valid interval.  */

                if (RE_DUP_MAX < upper_bound)
		  FREE_STACK_RETURN (REG_BADBR);

                /* If the upper bound is zero, don't want to succeed at
                   all; jump from `laststart' to `b + 3', which will be
		   the end of the buffer after we insert the jump.  */
		/* ifdef WCHAR, 'b + 1 + OFFSET_ADDRESS_SIZE'
		   instead of 'b + 3'.  */
                 if (upper_bound == 0)
                   {
                     GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);
                     INSERT_JUMP (jump, laststart, b + 1
				  + OFFSET_ADDRESS_SIZE);
                     b += 1 + OFFSET_ADDRESS_SIZE;
                   }

                 /* Otherwise, we have a nontrivial interval.  When
                    we're all done, the pattern will look like:
                      set_number_at <jump count> <upper bound>
                      set_number_at <succeed_n count> <lower bound>
                      succeed_n <after jump addr> <succeed_n count>
                      <body of loop>
                      jump_n <succeed_n addr> <jump count>
                    (The upper bound and `jump_n' are omitted if
                    `upper_bound' is 1, though.)  */
                 else
                   { /* If the upper bound is > 1, we need to insert
                        more at the end of the loop.  */
                     unsigned nbytes = 2 + 4 * OFFSET_ADDRESS_SIZE +
		       (upper_bound > 1) * (2 + 4 * OFFSET_ADDRESS_SIZE);

                     GET_BUFFER_SPACE (nbytes);

                     /* Initialize lower bound of the `succeed_n', even
                        though it will be set during matching by its
                        attendant `set_number_at' (inserted next),
                        because `re_compile_fastmap' needs to know.
                        Jump to the `jump_n' we might insert below.  */
                     INSERT_JUMP2 (succeed_n, laststart,
                                   b + 1 + 2 * OFFSET_ADDRESS_SIZE
				   + (upper_bound > 1) * (1 + 2 * OFFSET_ADDRESS_SIZE)
				   , lower_bound);
                     b += 1 + 2 * OFFSET_ADDRESS_SIZE;

                     /* Code to initialize the lower bound.  Insert
                        before the `succeed_n'.  The `5' is the last two
                        bytes of this `set_number_at', plus 3 bytes of
                        the following `succeed_n'.  */
		     /* ifdef WCHAR, The '1+2*OFFSET_ADDRESS_SIZE'
			is the 'set_number_at', plus '1+OFFSET_ADDRESS_SIZE'
			of the following `succeed_n'.  */
                     PREFIX(insert_op2) (set_number_at, laststart, 1
				 + 2 * OFFSET_ADDRESS_SIZE, lower_bound, b);
                     b += 1 + 2 * OFFSET_ADDRESS_SIZE;

                     if (upper_bound > 1)
                       { /* More than one repetition is allowed, so
                            append a backward jump to the `succeed_n'
                            that starts this interval.

                            When we've reached this during matching,
                            we'll have matched the interval once, so
                            jump back only `upper_bound - 1' times.  */
                         STORE_JUMP2 (jump_n, b, laststart
				      + 2 * OFFSET_ADDRESS_SIZE + 1,
                                      upper_bound - 1);
                         b += 1 + 2 * OFFSET_ADDRESS_SIZE;

                         /* The location we want to set is the second
                            parameter of the `jump_n'; that is `b-2' as
                            an absolute address.  `laststart' will be
                            the `set_number_at' we're about to insert;
                            `laststart+3' the number to set, the source
                            for the relative address.  But we are
                            inserting into the middle of the pattern --
                            so everything is getting moved up by 5.
                            Conclusion: (b - 2) - (laststart + 3) + 5,
                            i.e., b - laststart.

                            We insert this at the beginning of the loop
                            so that if we fail during matching, we'll
                            reinitialize the bounds.  */
                         PREFIX(insert_op2) (set_number_at, laststart,
					     b - laststart,
					     upper_bound - 1, b);
                         b += 1 + 2 * OFFSET_ADDRESS_SIZE;
                       }
                   }
                pending_exact = 0;
		break;

	      invalid_interval:
		if (!(syntax & RE_INVALID_INTERVAL_ORD))
		  FREE_STACK_RETURN (p == pend ? REG_EBRACE : REG_BADBR);
	      unfetch_interval:
		/* Match the characters as literals.  */
		p = beg_interval;
		c = '{';
		if (syntax & RE_NO_BK_BRACES)
		  goto normal_char;
		else
		  goto normal_backslash;
	      }

#ifdef emacs
            /* There is no way to specify the before_dot and after_dot
               operators.  rms says this is ok.  --karl  */
            case '=':
              BUF_PUSH (at_dot);
              break;

            case 's':
              laststart = b;
              PATFETCH (c);
              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
              break;

            case 'S':
              laststart = b;
              PATFETCH (c);
              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
              break;
#endif /* emacs */


            case 'w':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              laststart = b;
              BUF_PUSH (wordchar);
              break;


            case 'W':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              laststart = b;
              BUF_PUSH (notwordchar);
              break;


            case '<':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              BUF_PUSH (wordbeg);
              break;

            case '>':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              BUF_PUSH (wordend);
              break;

            case 'b':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              BUF_PUSH (wordbound);
              break;

            case 'B':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              BUF_PUSH (notwordbound);
              break;

            case '`':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              BUF_PUSH (begbuf);
              break;

            case '\'':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              BUF_PUSH (endbuf);
              break;

            case '1': case '2': case '3': case '4': case '5':
            case '6': case '7': case '8': case '9':
              if (syntax & RE_NO_BK_REFS)
                goto normal_char;

              c1 = c - '0';

              if (c1 > regnum)
                FREE_STACK_RETURN (REG_ESUBREG);

              /* Can't back reference to a subexpression if inside of it.  */
              if (group_in_compile_stack (compile_stack, (regnum_t) c1))
                goto normal_char;

              laststart = b;
              BUF_PUSH_2 (duplicate, c1);
              break;


            case '+':
            case '?':
              if (syntax & RE_BK_PLUS_QM)
                goto handle_plus;
              else
                goto normal_backslash;

            default:
            normal_backslash:
              /* You might think it would be useful for \ to mean
                 not to translate; but if we don't translate it
                 it will never match anything.  */
              c = TRANSLATE (c);
              goto normal_char;
            }
          break;


	default:
        /* Expects the character in `c'.  */
	normal_char:
	      /* If no exactn currently being built.  */
          if (!pending_exact
#ifdef WCHAR
	      /* If last exactn handle binary(or character) and
		 new exactn handle character(or binary).  */
	      || is_exactn_bin != is_binary[p - 1 - pattern]
#endif /* WCHAR */

              /* If last exactn not at current position.  */
              || pending_exact + *pending_exact + 1 != b

              /* We have only one byte following the exactn for the count.  */
	      || *pending_exact == (1 << BYTEWIDTH) - 1

              /* If followed by a repetition operator.  */
              || *p == '*' || *p == '^'
	      || ((syntax & RE_BK_PLUS_QM)
		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
		  : (*p == '+' || *p == '?'))
	      || ((syntax & RE_INTERVALS)
                  && ((syntax & RE_NO_BK_BRACES)
		      ? *p == '{'
                      : (p[0] == '\\' && p[1] == '{'))))
	    {
	      /* Start building a new exactn.  */

              laststart = b;

#ifdef WCHAR
	      /* Is this exactn binary data or character? */
	      is_exactn_bin = is_binary[p - 1 - pattern];
	      if (is_exactn_bin)
		  BUF_PUSH_2 (exactn_bin, 0);
	      else
		  BUF_PUSH_2 (exactn, 0);
#else
	      BUF_PUSH_2 (exactn, 0);
#endif /* WCHAR */
	      pending_exact = b - 1;
            }

	  BUF_PUSH (c);
          (*pending_exact)++;
	  break;
        } /* switch (c) */
    } /* while p != pend */


  /* Through the pattern now.  */

  if (fixup_alt_jump)
    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);

  if (!COMPILE_STACK_EMPTY)
    FREE_STACK_RETURN (REG_EPAREN);

  /* If we don't want backtracking, force success
     the first time we reach the end of the compiled pattern.  */
  if (syntax & RE_NO_POSIX_BACKTRACKING)
    BUF_PUSH (succeed);

#ifdef WCHAR
  free (pattern);
  free (mbs_offset);
  free (is_binary);
#endif
  free (compile_stack.stack);

  /* We have succeeded; set the length of the buffer.  */
#ifdef WCHAR
  bufp->used = (uintptr_t) b - (uintptr_t) COMPILED_BUFFER_VAR;
#else
  bufp->used = b - bufp->buffer;
#endif

#ifdef DEBUG
  if (debug)
    {
      DEBUG_PRINT1 ("\nCompiled pattern: \n");
      PREFIX(print_compiled_pattern) (bufp);
    }
#endif /* DEBUG */

#ifndef MATCH_MAY_ALLOCATE
  /* Initialize the failure stack to the largest possible stack.  This
     isn't necessary unless we're trying to avoid calling alloca in
     the search and match routines.  */
  {
    int num_regs = bufp->re_nsub + 1;

    /* Since DOUBLE_FAIL_STACK refuses to double only if the current size
       is strictly greater than re_max_failures, the largest possible stack
       is 2 * re_max_failures failure points.  */
    if (fail_stack.size < (2 * re_max_failures * MAX_FAILURE_ITEMS))
      {
	fail_stack.size = (2 * re_max_failures * MAX_FAILURE_ITEMS);

# ifdef emacs
	if (! fail_stack.stack)
	  fail_stack.stack
	    = (PREFIX(fail_stack_elt_t) *) xmalloc (fail_stack.size
				    * sizeof (PREFIX(fail_stack_elt_t)));
	else
	  fail_stack.stack
	    = (PREFIX(fail_stack_elt_t) *) xrealloc (fail_stack.stack,
				     (fail_stack.size
				      * sizeof (PREFIX(fail_stack_elt_t))));
# else /* not emacs */
	if (! fail_stack.stack)
	  fail_stack.stack
	    = malloc (fail_stack.size * sizeof (PREFIX(fail_stack_elt_t)));
	else
	  fail_stack.stack
	    = realloc (fail_stack.stack,
		       fail_stack.size * sizeof (PREFIX(fail_stack_elt_t)));
# endif /* not emacs */
      }

   PREFIX(regex_grow_registers) (num_regs);
  }
#endif /* not MATCH_MAY_ALLOCATE */

  return REG_NOERROR;
} /* regex_compile */

/* Subroutines for `regex_compile'.  */

/* Store OP at LOC followed by two-byte integer parameter ARG.  */
/* ifdef WCHAR, integer parameter is 1 wchar_t.  */

static void
PREFIX(store_op1) (re_opcode_t op, UCHAR_T *loc, int arg)
{
  *loc = (UCHAR_T) op;
  STORE_NUMBER (loc + 1, arg);
}


/* Like `store_op1', but for two two-byte parameters ARG1 and ARG2.  */
/* ifdef WCHAR, integer parameter is 1 wchar_t.  */

static void
PREFIX(store_op2) (re_opcode_t op, UCHAR_T *loc, int arg1, int arg2)
{
  *loc = (UCHAR_T) op;
  STORE_NUMBER (loc + 1, arg1);
  STORE_NUMBER (loc + 1 + OFFSET_ADDRESS_SIZE, arg2);
}


/* Copy the bytes from LOC to END to open up three bytes of space at LOC
   for OP followed by two-byte integer parameter ARG.  */
/* ifdef WCHAR, integer parameter is 1 wchar_t.  */

static void
PREFIX(insert_op1) (re_opcode_t op, UCHAR_T *loc, int arg, UCHAR_T *end)
{
  register UCHAR_T *pfrom = end;
  register UCHAR_T *pto = end + 1 + OFFSET_ADDRESS_SIZE;

  while (pfrom != loc)
    *--pto = *--pfrom;

  PREFIX(store_op1) (op, loc, arg);
}


/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
/* ifdef WCHAR, integer parameter is 1 wchar_t.  */

static void
PREFIX(insert_op2) (re_opcode_t op, UCHAR_T *loc, int arg1, int arg2,
		    UCHAR_T *end)
{
  register UCHAR_T *pfrom = end;
  register UCHAR_T *pto = end + 1 + 2 * OFFSET_ADDRESS_SIZE;

  while (pfrom != loc)
    *--pto = *--pfrom;

  PREFIX(store_op2) (op, loc, arg1, arg2);
}


/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
   after an alternative or a begin-subexpression.  We assume there is at
   least one character before the ^.  */

static boolean
PREFIX(at_begline_loc_p) (const CHAR_T *pattern, const CHAR_T *p,
			  reg_syntax_t syntax)
{
  const CHAR_T *prev = p - 2;
  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';

  return
       /* After a subexpression?  */
       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
       /* After an alternative?  */
    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
}


/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
   at least one character after the $, i.e., `P < PEND'.  */

static boolean
PREFIX(at_endline_loc_p) (const CHAR_T *p, const CHAR_T *pend,
			  reg_syntax_t syntax)
{
  const CHAR_T *next = p;
  boolean next_backslash = *next == '\\';
  const CHAR_T *next_next = p + 1 < pend ? p + 1 : 0;

  return
       /* Before a subexpression?  */
       (syntax & RE_NO_BK_PARENS ? *next == ')'
        : next_backslash && next_next && *next_next == ')')
       /* Before an alternative?  */
    || (syntax & RE_NO_BK_VBAR ? *next == '|'
        : next_backslash && next_next && *next_next == '|');
}

#else /* not INSIDE_RECURSION */

/* Returns true if REGNUM is in one of COMPILE_STACK's elements and
   false if it's not.  */

static boolean
group_in_compile_stack (compile_stack_type compile_stack,
			regnum_t regnum)
{
  int this_element;

  for (this_element = compile_stack.avail - 1;
       this_element >= 0;
       this_element--)
    if (compile_stack.stack[this_element].regnum == regnum)
      return true;

  return false;
}
#endif /* not INSIDE_RECURSION */

#ifdef INSIDE_RECURSION

#ifdef WCHAR
/* This insert space, which size is "num", into the pattern at "loc".
   "end" must point the end of the allocated buffer.  */
static void
insert_space (int num, CHAR_T *loc, CHAR_T *end)
{
  register CHAR_T *pto = end;
  register CHAR_T *pfrom = end - num;

  while (pfrom >= loc)
    *pto-- = *pfrom--;
}
#endif /* WCHAR */

#ifdef WCHAR
static reg_errcode_t
wcs_compile_range (CHAR_T range_start_char,
		   const CHAR_T **p_ptr, const CHAR_T *pend,
		   RE_TRANSLATE_TYPE translate, reg_syntax_t syntax,
		   CHAR_T *b, CHAR_T *char_set)
{
  const CHAR_T *p = *p_ptr;
  CHAR_T range_start, range_end;
  reg_errcode_t ret;
# ifdef _LIBC
  uint32_t nrules;
  uint32_t start_val, end_val;
# endif
  if (p == pend)
    return REG_ERANGE;

# ifdef _LIBC
  nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
  if (nrules != 0)
    {
      const char *collseq = (const char *) _NL_CURRENT(LC_COLLATE,
						       _NL_COLLATE_COLLSEQWC);
      const unsigned char *extra = (const unsigned char *)
	_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);

      if (range_start_char < -1)
	{
	  /* range_start is a collating symbol.  */
	  int32_t *wextra;
	  /* Retreive the index and get collation sequence value.  */
	  wextra = (int32_t*)(extra + char_set[-range_start_char]);
	  start_val = wextra[1 + *wextra];
	}
      else
	start_val = collseq_table_lookup(collseq, TRANSLATE(range_start_char));

      end_val = collseq_table_lookup (collseq, TRANSLATE (p[0]));

      /* Report an error if the range is empty and the syntax prohibits
	 this.  */
      ret = ((syntax & RE_NO_EMPTY_RANGES)
	     && (start_val > end_val))? REG_ERANGE : REG_NOERROR;

      /* Insert space to the end of the char_ranges.  */
      insert_space(2, b - char_set[5] - 2, b - 1);
      *(b - char_set[5] - 2) = (wchar_t)start_val;
      *(b - char_set[5] - 1) = (wchar_t)end_val;
      char_set[4]++; /* ranges_index */
    }
  else
# endif
    {
      range_start = (range_start_char >= 0)? TRANSLATE (range_start_char):
	range_start_char;
      range_end = TRANSLATE (p[0]);
      /* Report an error if the range is empty and the syntax prohibits
	 this.  */
      ret = ((syntax & RE_NO_EMPTY_RANGES)
	     && (range_start > range_end))? REG_ERANGE : REG_NOERROR;

      /* Insert space to the end of the char_ranges.  */
      insert_space(2, b - char_set[5] - 2, b - 1);
      *(b - char_set[5] - 2) = range_start;
      *(b - char_set[5] - 1) = range_end;
      char_set[4]++; /* ranges_index */
    }
  /* Have to increment the pointer into the pattern string, so the
     caller isn't still at the ending character.  */
  (*p_ptr)++;

  return ret;
}
#else /* BYTE */
/* Read the ending character of a range (in a bracket expression) from the
   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
   Then we set the translation of all bits between the starting and
   ending characters (inclusive) in the compiled pattern B.

   Return an error code.

   We use these short variable names so we can use the same macros as
   `regex_compile' itself.  */

static reg_errcode_t
byte_compile_range (unsigned int range_start_char,
		    const char **p_ptr, const char *pend,
		    RE_TRANSLATE_TYPE translate, reg_syntax_t syntax,
		    unsigned char *b)
{
  unsigned this_char;
  const char *p = *p_ptr;
  reg_errcode_t ret;
# if _LIBC
  const unsigned char *collseq;
  unsigned int start_colseq;
  unsigned int end_colseq;
# else
  unsigned end_char;
# endif

  if (p == pend)
    return REG_ERANGE;

  /* Have to increment the pointer into the pattern string, so the
     caller isn't still at the ending character.  */
  (*p_ptr)++;

  /* Report an error if the range is empty and the syntax prohibits this.  */
  ret = syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;

# if _LIBC
  collseq = (const unsigned char *) _NL_CURRENT (LC_COLLATE,
						 _NL_COLLATE_COLLSEQMB);

  start_colseq = collseq[(unsigned char) TRANSLATE (range_start_char)];
  end_colseq = collseq[(unsigned char) TRANSLATE (p[0])];
  for (this_char = 0; this_char <= (unsigned char) -1; ++this_char)
    {
      unsigned int this_colseq = collseq[(unsigned char) TRANSLATE (this_char)];

      if (start_colseq <= this_colseq && this_colseq <= end_colseq)
	{
	  SET_LIST_BIT (TRANSLATE (this_char));
	  ret = REG_NOERROR;
	}
    }
# else
  /* Here we see why `this_char' has to be larger than an `unsigned
     char' -- we would otherwise go into an infinite loop, since all
     characters <= 0xff.  */
  range_start_char = TRANSLATE (range_start_char);
  /* TRANSLATE(p[0]) is casted to char (not unsigned char) in TRANSLATE,
     and some compilers cast it to int implicitly, so following for_loop
     may fall to (almost) infinite loop.
     e.g. If translate[p[0]] = 0xff, end_char may equals to 0xffffffff.
     To avoid this, we cast p[0] to unsigned int and truncate it.  */
  end_char = ((unsigned)TRANSLATE(p[0]) & ((1 << BYTEWIDTH) - 1));

  for (this_char = range_start_char; this_char <= end_char; ++this_char)
    {
      SET_LIST_BIT (TRANSLATE (this_char));
      ret = REG_NOERROR;
    }
# endif

  return ret;
}
#endif /* WCHAR */

/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
   characters can start a string that matches the pattern.  This fastmap
   is used by re_search to skip quickly over impossible starting points.

   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
   area as BUFP->fastmap.

   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
   the pattern buffer.

   Returns 0 if we succeed, -2 if an internal error.   */

#ifdef WCHAR
/* local function for re_compile_fastmap.
   truncate wchar_t character to char.  */

static unsigned char
truncate_wchar (CHAR_T c)
{
  unsigned char buf[MB_CUR_MAX];
  mbstate_t state;
  int retval;
  memset (&state, '\0', sizeof (state));
  retval = wcrtomb (buf, c, &state);
  return retval > 0 ? buf[0] : (unsigned char) c;
}
#endif /* WCHAR */

static int
PREFIX(re_compile_fastmap) (struct re_pattern_buffer *bufp)
{
  int j, k;
#ifdef MATCH_MAY_ALLOCATE
  PREFIX(fail_stack_type) fail_stack;
#endif
#ifndef REGEX_MALLOC
  char *destination;
#endif

  register char *fastmap = bufp->fastmap;

#ifdef WCHAR
  /* We need to cast pattern to (wchar_t*), because we casted this compiled
     pattern to (char*) in regex_compile.  */
  UCHAR_T *pattern = (UCHAR_T*)bufp->buffer;
  register UCHAR_T *pend = (UCHAR_T*) (bufp->buffer + bufp->used);
#else /* BYTE */
  UCHAR_T *pattern = bufp->buffer;
  register UCHAR_T *pend = pattern + bufp->used;
#endif /* WCHAR */
  UCHAR_T *p = pattern;

#ifdef REL_ALLOC
  /* This holds the pointer to the failure stack, when
     it is allocated relocatably.  */
  fail_stack_elt_t *failure_stack_ptr;
#endif

  /* Assume that each path through the pattern can be null until
     proven otherwise.  We set this false at the bottom of switch
     statement, to which we get only if a particular path doesn't
     match the empty string.  */
  boolean path_can_be_null = true;

  /* We aren't doing a `succeed_n' to begin with.  */
  boolean succeed_n_p = false;

  assert (fastmap != NULL && p != NULL);

  INIT_FAIL_STACK ();
  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
  bufp->can_be_null = 0;

  while (1)
    {
      if (p == pend || *p == succeed)
	{
	  /* We have reached the (effective) end of pattern.  */
	  if (!FAIL_STACK_EMPTY ())
	    {
	      bufp->can_be_null |= path_can_be_null;

	      /* Reset for next path.  */
	      path_can_be_null = true;

	      p = fail_stack.stack[--fail_stack.avail].pointer;

	      continue;
	    }
	  else
	    break;
	}

      /* We should never be about to go beyond the end of the pattern.  */
      assert (p < pend);

      switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))
	{

        /* I guess the idea here is to simply not bother with a fastmap
           if a backreference is used, since it's too hard to figure out
           the fastmap for the corresponding group.  Setting
           `can_be_null' stops `re_search_2' from using the fastmap, so
           that is all we do.  */
	case duplicate:
	  bufp->can_be_null = 1;
          goto done;


      /* Following are the cases which match a character.  These end
         with `break'.  */

#ifdef WCHAR
	case exactn:
          fastmap[truncate_wchar(p[1])] = 1;
	  break;
#else /* BYTE */
	case exactn:
          fastmap[p[1]] = 1;
	  break;
#endif /* WCHAR */
#ifdef MBS_SUPPORT
	case exactn_bin:
	  fastmap[p[1]] = 1;
	  break;
#endif

#ifdef WCHAR
        /* It is hard to distinguish fastmap from (multi byte) characters
           which depends on current locale.  */
        case charset:
	case charset_not:
	case wordchar:
	case notwordchar:
          bufp->can_be_null = 1;
          goto done;
#else /* BYTE */
        case charset:
          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
              fastmap[j] = 1;
	  break;


	case charset_not:
	  /* Chars beyond end of map must be allowed.  */
	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
            fastmap[j] = 1;

	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
              fastmap[j] = 1;
          break;


	case wordchar:
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	    if (SYNTAX (j) == Sword)
	      fastmap[j] = 1;
	  break;


	case notwordchar:
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	    if (SYNTAX (j) != Sword)
	      fastmap[j] = 1;
	  break;
#endif /* WCHAR */

        case anychar:
	  {
	    int fastmap_newline = fastmap['\n'];

	    /* `.' matches anything ...  */
	    for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;

	    /* ... except perhaps newline.  */
	    if (!(bufp->syntax & RE_DOT_NEWLINE))
	      fastmap['\n'] = fastmap_newline;

	    /* Return if we have already set `can_be_null'; if we have,
	       then the fastmap is irrelevant.  Something's wrong here.  */
	    else if (bufp->can_be_null)
	      goto done;

	    /* Otherwise, have to check alternative paths.  */
	    break;
	  }

#ifdef emacs
        case syntaxspec:
	  k = *p++;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	    if (SYNTAX (j) == (enum syntaxcode) k)
	      fastmap[j] = 1;
	  break;


	case notsyntaxspec:
	  k = *p++;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	    if (SYNTAX (j) != (enum syntaxcode) k)
	      fastmap[j] = 1;
	  break;


      /* All cases after this match the empty string.  These end with
         `continue'.  */


	case before_dot:
	case at_dot:
	case after_dot:
          continue;
#endif /* emacs */


        case no_op:
        case begline:
        case endline:
	case begbuf:
	case endbuf:
	case wordbound:
	case notwordbound:
	case wordbeg:
	case wordend:
        case push_dummy_failure:
          continue;


	case jump_n:
        case pop_failure_jump:
	case maybe_pop_jump:
	case jump:
        case jump_past_alt:
	case dummy_failure_jump:
          EXTRACT_NUMBER_AND_INCR (j, p);
	  p += j;
	  if (j > 0)
	    continue;

          /* Jump backward implies we just went through the body of a
             loop and matched nothing.  Opcode jumped to should be
             `on_failure_jump' or `succeed_n'.  Just treat it like an
             ordinary jump.  For a * loop, it has pushed its failure
             point already; if so, discard that as redundant.  */
          if ((re_opcode_t) *p != on_failure_jump
	      && (re_opcode_t) *p != succeed_n)
	    continue;

          p++;
          EXTRACT_NUMBER_AND_INCR (j, p);
          p += j;

          /* If what's on the stack is where we are now, pop it.  */
          if (!FAIL_STACK_EMPTY ()
	      && fail_stack.stack[fail_stack.avail - 1].pointer == p)
            fail_stack.avail--;

          continue;


        case on_failure_jump:
        case on_failure_keep_string_jump:
	handle_on_failure_jump:
          EXTRACT_NUMBER_AND_INCR (j, p);

          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
             end of the pattern.  We don't want to push such a point,
             since when we restore it above, entering the switch will
             increment `p' past the end of the pattern.  We don't need
             to push such a point since we obviously won't find any more
             fastmap entries beyond `pend'.  Such a pattern can match
             the null string, though.  */
          if (p + j < pend)
            {
              if (!PUSH_PATTERN_OP (p + j, fail_stack))
		{
		  RESET_FAIL_STACK ();
		  return -2;
		}
            }
          else
            bufp->can_be_null = 1;

          if (succeed_n_p)
            {
              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
              succeed_n_p = false;
	    }

          continue;


	case succeed_n:
          /* Get to the number of times to succeed.  */
          p += OFFSET_ADDRESS_SIZE;

          /* Increment p past the n for when k != 0.  */
          EXTRACT_NUMBER_AND_INCR (k, p);
          if (k == 0)
	    {
              p -= 2 * OFFSET_ADDRESS_SIZE;
  	      succeed_n_p = true;  /* Spaghetti code alert.  */
              goto handle_on_failure_jump;
            }
          continue;


	case set_number_at:
          p += 2 * OFFSET_ADDRESS_SIZE;
          continue;


	case start_memory:
        case stop_memory:
	  p += 2;
	  continue;


	default:
          abort (); /* We have listed all the cases.  */
        } /* switch *p++ */

      /* Getting here means we have found the possible starting
         characters for one path of the pattern -- and that the empty
         string does not match.  We need not follow this path further.
         Instead, look at the next alternative (remembered on the
         stack), or quit if no more.  The test at the top of the loop
         does these things.  */
      path_can_be_null = false;
      p = pend;
    } /* while p */

  /* Set `can_be_null' for the last path (also the first path, if the
     pattern is empty).  */
  bufp->can_be_null |= path_can_be_null;

 done:
  RESET_FAIL_STACK ();
  return 0;
}

#else /* not INSIDE_RECURSION */

int
re_compile_fastmap (struct re_pattern_buffer *bufp)
{
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    return wcs_re_compile_fastmap(bufp);
  else
# endif
    return byte_re_compile_fastmap(bufp);
} /* re_compile_fastmap */
#ifdef _LIBC
weak_alias (__re_compile_fastmap, re_compile_fastmap)
#endif


/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
   this memory for recording register information.  STARTS and ENDS
   must be allocated using the malloc library routine, and must each
   be at least NUM_REGS * sizeof (regoff_t) bytes long.

   If NUM_REGS == 0, then subsequent matches should allocate their own
   register data.

   Unless this function is called, the first search or match using
   PATTERN_BUFFER will allocate its own register data, without
   freeing the old data.  */

void
re_set_registers (struct re_pattern_buffer *bufp,
		  struct re_registers *regs,
		  unsigned int num_regs,
		  regoff_t *starts, regoff_t *ends)
{
  if (num_regs)
    {
      bufp->regs_allocated = REGS_REALLOCATE;
      regs->num_regs = num_regs;
      regs->start = starts;
      regs->end = ends;
    }
  else
    {
      bufp->regs_allocated = REGS_UNALLOCATED;
      regs->num_regs = 0;
      regs->start = regs->end = (regoff_t *) 0;
    }
}
#ifdef _LIBC
weak_alias (__re_set_registers, re_set_registers)
#endif

/* Searching routines.  */

/* Like re_search_2, below, but only one string is specified, and
   doesn't let you say where to stop matching.  */

int
re_search (struct re_pattern_buffer *bufp,
	   const char *string,
	   int size, int startpos, int range,
	   struct re_registers *regs)
{
  return re_search_2 (bufp, NULL, 0, string, size, startpos, range,
		      regs, size);
}
#ifdef _LIBC
weak_alias (__re_search, re_search)
#endif


/* Using the compiled pattern in BUFP->buffer, first tries to match the
   virtual concatenation of STRING1 and STRING2, starting first at index
   STARTPOS, then at STARTPOS + 1, and so on.

   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.

   RANGE is how far to scan while trying to match.  RANGE = 0 means try
   only at STARTPOS; in general, the last start tried is STARTPOS +
   RANGE.

   In REGS, return the indices of the virtual concatenation of STRING1
   and STRING2 that matched the entire BUFP->buffer and its contained
   subexpressions.

   Do not consider matching one past the index STOP in the virtual
   concatenation of STRING1 and STRING2.

   We return either the position in the strings at which the match was
   found, -1 if no match, or -2 if error (such as failure
   stack overflow).  */

int
re_search_2 (struct re_pattern_buffer *bufp,
	     const char *string1, int size1,
	     const char *string2, int size2,
	     int startpos, int range,
	     struct re_registers *regs,
	     int stop)
{
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    return wcs_re_search_2 (bufp, string1, size1, string2, size2, startpos,
			    range, regs, stop);
  else
# endif
    return byte_re_search_2 (bufp, string1, size1, string2, size2, startpos,
			     range, regs, stop);
} /* re_search_2 */
#ifdef _LIBC
weak_alias (__re_search_2, re_search_2)
#endif

#endif /* not INSIDE_RECURSION */

#ifdef INSIDE_RECURSION

#ifdef MATCH_MAY_ALLOCATE
# define FREE_VAR(var) if (var) REGEX_FREE (var); var = NULL
#else
# define FREE_VAR(var) if (var) free (var); var = NULL
#endif

#ifdef WCHAR
# define MAX_ALLOCA_SIZE	2000

# define FREE_WCS_BUFFERS() \
  do {									      \
    if (size1 > MAX_ALLOCA_SIZE)					      \
      {									      \
	free (wcs_string1);						      \
	free (mbs_offset1);						      \
      }									      \
    else								      \
      {									      \
	FREE_VAR (wcs_string1);						      \
	FREE_VAR (mbs_offset1);						      \
      }									      \
    if (size2 > MAX_ALLOCA_SIZE) 					      \
      {									      \
	free (wcs_string2);						      \
	free (mbs_offset2);						      \
      }									      \
    else								      \
      {									      \
	FREE_VAR (wcs_string2);						      \
	FREE_VAR (mbs_offset2);						      \
      }									      \
  } while (0)

#endif


static int
PREFIX(re_search_2) (struct re_pattern_buffer *bufp,
		     const char *string1, int size1,
		     const char *string2, int size2,
		     int startpos, int range,
		     struct re_registers *regs,
		     int stop)
{
  int val;
  register char *fastmap = bufp->fastmap;
  register RE_TRANSLATE_TYPE translate = bufp->translate;
  int total_size = size1 + size2;
  int endpos = startpos + range;
#ifdef WCHAR
  /* We need wchar_t* buffers correspond to cstring1, cstring2.  */
  wchar_t *wcs_string1 = NULL, *wcs_string2 = NULL;
  /* We need the size of wchar_t buffers correspond to csize1, csize2.  */
  int wcs_size1 = 0, wcs_size2 = 0;
  /* offset buffer for optimizatoin. See convert_mbs_to_wc.  */
  int *mbs_offset1 = NULL, *mbs_offset2 = NULL;
  /* They hold whether each wchar_t is binary data or not.  */
  char *is_binary = NULL;
#endif /* WCHAR */

  /* Check for out-of-range STARTPOS.  */
  if (startpos < 0 || startpos > total_size)
    return -1;

  /* Fix up RANGE if it might eventually take us outside
     the virtual concatenation of STRING1 and STRING2.
     Make sure we won't move STARTPOS below 0 or above TOTAL_SIZE.  */
  if (endpos < 0)
    range = 0 - startpos;
  else if (endpos > total_size)
    range = total_size - startpos;

  /* If the search isn't to be a backwards one, don't waste time in a
     search for a pattern that must be anchored.  */
  if (bufp->used > 0 && range > 0
      && ((re_opcode_t) bufp->buffer[0] == begbuf
	  /* `begline' is like `begbuf' if it cannot match at newlines.  */
	  || ((re_opcode_t) bufp->buffer[0] == begline
	      && !bufp->newline_anchor)))
    {
      if (startpos > 0)
	return -1;
      else
	range = 1;
    }

#ifdef emacs
  /* In a forward search for something that starts with \=.
     don't keep searching past point.  */
  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == at_dot && range > 0)
    {
      range = PT - startpos;
      if (range <= 0)
	return -1;
    }
#endif /* emacs */

  /* Update the fastmap now if not correct already.  */
  if (fastmap && !bufp->fastmap_accurate)
    if (re_compile_fastmap (bufp) == -2)
      return -2;

#ifdef WCHAR
  /* Allocate wchar_t array for wcs_string1 and wcs_string2 and
     fill them with converted string.  */
  if (size1 != 0)
    {
      if (size1 > MAX_ALLOCA_SIZE)
	{
	  wcs_string1 = TALLOC (size1 + 1, CHAR_T);
	  mbs_offset1 = TALLOC (size1 + 1, int);
	  is_binary = TALLOC (size1 + 1, char);
	}
      else
	{
	  wcs_string1 = REGEX_TALLOC (size1 + 1, CHAR_T);
	  mbs_offset1 = REGEX_TALLOC (size1 + 1, int);
	  is_binary = REGEX_TALLOC (size1 + 1, char);
	}
      if (!wcs_string1 || !mbs_offset1 || !is_binary)
	{
	  if (size1 > MAX_ALLOCA_SIZE)
	    {
	      free (wcs_string1);
	      free (mbs_offset1);
	      free (is_binary);
	    }
	  else
	    {
	      FREE_VAR (wcs_string1);
	      FREE_VAR (mbs_offset1);
	      FREE_VAR (is_binary);
	    }
	  return -2;
	}
      wcs_size1 = convert_mbs_to_wcs(wcs_string1, string1, size1,
				     mbs_offset1, is_binary);
      wcs_string1[wcs_size1] = L'\0'; /* for a sentinel  */
      if (size1 > MAX_ALLOCA_SIZE)
	free (is_binary);
      else
	FREE_VAR (is_binary);
    }
  if (size2 != 0)
    {
      if (size2 > MAX_ALLOCA_SIZE)
	{
	  wcs_string2 = TALLOC (size2 + 1, CHAR_T);
	  mbs_offset2 = TALLOC (size2 + 1, int);
	  is_binary = TALLOC (size2 + 1, char);
	}
      else
	{
	  wcs_string2 = REGEX_TALLOC (size2 + 1, CHAR_T);
	  mbs_offset2 = REGEX_TALLOC (size2 + 1, int);
	  is_binary = REGEX_TALLOC (size2 + 1, char);
	}
      if (!wcs_string2 || !mbs_offset2 || !is_binary)
	{
	  FREE_WCS_BUFFERS ();
	  if (size2 > MAX_ALLOCA_SIZE)
	    free (is_binary);
	  else
	    FREE_VAR (is_binary);
	  return -2;
	}
      wcs_size2 = convert_mbs_to_wcs(wcs_string2, string2, size2,
				     mbs_offset2, is_binary);
      wcs_string2[wcs_size2] = L'\0'; /* for a sentinel  */
      if (size2 > MAX_ALLOCA_SIZE)
	free (is_binary);
      else
	FREE_VAR (is_binary);
    }
#endif /* WCHAR */


  /* Loop through the string, looking for a place to start matching.  */
  for (;;)
    {
      /* If a fastmap is supplied, skip quickly over characters that
         cannot be the start of a match.  If the pattern can match the
         null string, however, we don't need to skip characters; we want
         the first null string.  */
      if (fastmap && startpos < total_size && !bufp->can_be_null)
	{
	  if (range > 0)	/* Searching forwards.  */
	    {
	      register const char *d;
	      register int lim = 0;
	      int irange = range;

              if (startpos < size1 && startpos + range >= size1)
                lim = range - (size1 - startpos);

	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;

              /* Written out as an if-else to avoid testing `translate'
                 inside the loop.  */
	      if (translate)
                while (range > lim
                       && !fastmap[(unsigned char)
				   translate[(unsigned char) *d++]])
                  range--;
	      else
                while (range > lim && !fastmap[(unsigned char) *d++])
                  range--;

	      startpos += irange - range;
	    }
	  else				/* Searching backwards.  */
	    {
	      register CHAR_T c = (size1 == 0 || startpos >= size1
				      ? string2[startpos - size1]
				      : string1[startpos]);

	      if (!fastmap[(unsigned char) TRANSLATE (c)])
		goto advance;
	    }
	}

      /* If can't match the null string, and that's all we have left, fail.  */
      if (range >= 0 && startpos == total_size && fastmap
          && !bufp->can_be_null)
       {
#ifdef WCHAR
         FREE_WCS_BUFFERS ();
#endif
         return -1;
       }

#ifdef WCHAR
      val = wcs_re_match_2_internal (bufp, string1, size1, string2,
				     size2, startpos, regs, stop,
				     wcs_string1, wcs_size1,
				     wcs_string2, wcs_size2,
				     mbs_offset1, mbs_offset2);
#else /* BYTE */
      val = byte_re_match_2_internal (bufp, string1, size1, string2,
				      size2, startpos, regs, stop);
#endif /* BYTE */

#ifndef REGEX_MALLOC
# ifdef C_ALLOCA
      alloca (0);
# endif
#endif

      if (val >= 0)
	{
#ifdef WCHAR
	  FREE_WCS_BUFFERS ();
#endif
	  return startpos;
	}

      if (val == -2)
	{
#ifdef WCHAR
	  FREE_WCS_BUFFERS ();
#endif
	  return -2;
	}

    advance:
      if (!range)
        break;
      else if (range > 0)
        {
          range--;
          startpos++;
        }
      else
        {
          range++;
          startpos--;
        }
    }
#ifdef WCHAR
  FREE_WCS_BUFFERS ();
#endif
  return -1;
}

#ifdef WCHAR
/* This converts PTR, a pointer into one of the search wchar_t strings
   `string1' and `string2' into an multibyte string offset from the
   beginning of that string. We use mbs_offset to optimize.
   See convert_mbs_to_wcs.  */
# define POINTER_TO_OFFSET(ptr)						\
  (FIRST_STRING_P (ptr)							\
   ? ((regoff_t)(mbs_offset1 != NULL? mbs_offset1[(ptr)-string1] : 0))	\
   : ((regoff_t)((mbs_offset2 != NULL? mbs_offset2[(ptr)-string2] : 0)	\
		 + csize1)))
#else /* BYTE */
/* This converts PTR, a pointer into one of the search strings `string1'
   and `string2' into an offset from the beginning of that string.  */
# define POINTER_TO_OFFSET(ptr)			\
  (FIRST_STRING_P (ptr)				\
   ? ((regoff_t) ((ptr) - string1))		\
   : ((regoff_t) ((ptr) - string2 + size1)))
#endif /* WCHAR */

/* Macros for dealing with the split strings in re_match_2.  */

#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)

/* Call before fetching a character with *d.  This switches over to
   string2 if necessary.  */
#define PREFETCH()							\
  while (d == dend)						    	\
    {									\
      /* End of string2 => fail.  */					\
      if (dend == end_match_2) 						\
        goto fail;							\
      /* End of string1 => advance to string2.  */ 			\
      d = string2;						        \
      dend = end_match_2;						\
    }

/* Test if at very beginning or at very end of the virtual concatenation
   of `string1' and `string2'.  If only one string, it's `string2'.  */
#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
#define AT_STRINGS_END(d) ((d) == end2)


/* Test if D points to a character which is word-constituent.  We have
   two special cases to check for: if past the end of string1, look at
   the first character in string2; and if before the beginning of
   string2, look at the last character in string1.  */
#ifdef WCHAR
/* Use internationalized API instead of SYNTAX.  */
# define WORDCHAR_P(d)							\
  (iswalnum ((wint_t)((d) == end1 ? *string2				\
           : (d) == string2 - 1 ? *(end1 - 1) : *(d))) != 0		\
   || ((d) == end1 ? *string2						\
       : (d) == string2 - 1 ? *(end1 - 1) : *(d)) == L'_')
#else /* BYTE */
# define WORDCHAR_P(d)							\
  (SYNTAX ((d) == end1 ? *string2					\
           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
   == Sword)
#endif /* WCHAR */

/* Disabled due to a compiler bug -- see comment at case wordbound */
#if 0
/* Test if the character before D and the one at D differ with respect
   to being word-constituent.  */
#define AT_WORD_BOUNDARY(d)						\
  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
#endif

/* Free everything we malloc.  */
#ifdef MATCH_MAY_ALLOCATE
# ifdef WCHAR
#  define FREE_VARIABLES()						\
  do {									\
    REGEX_FREE_STACK (fail_stack.stack);				\
    FREE_VAR (regstart);						\
    FREE_VAR (regend);							\
    FREE_VAR (old_regstart);						\
    FREE_VAR (old_regend);						\
    FREE_VAR (best_regstart);						\
    FREE_VAR (best_regend);						\
    FREE_VAR (reg_info);						\
    FREE_VAR (reg_dummy);						\
    FREE_VAR (reg_info_dummy);						\
    if (!cant_free_wcs_buf)						\
      {									\
        FREE_VAR (string1);						\
        FREE_VAR (string2);						\
        FREE_VAR (mbs_offset1);						\
        FREE_VAR (mbs_offset2);						\
      }									\
  } while (0)
# else /* BYTE */
#  define FREE_VARIABLES()						\
  do {									\
    REGEX_FREE_STACK (fail_stack.stack);				\
    FREE_VAR (regstart);						\
    FREE_VAR (regend);							\
    FREE_VAR (old_regstart);						\
    FREE_VAR (old_regend);						\
    FREE_VAR (best_regstart);						\
    FREE_VAR (best_regend);						\
    FREE_VAR (reg_info);						\
    FREE_VAR (reg_dummy);						\
    FREE_VAR (reg_info_dummy);						\
  } while (0)
# endif /* WCHAR */
#else
# ifdef WCHAR
#  define FREE_VARIABLES()						\
  do {									\
    if (!cant_free_wcs_buf)						\
      {									\
        FREE_VAR (string1);						\
        FREE_VAR (string2);						\
        FREE_VAR (mbs_offset1);						\
        FREE_VAR (mbs_offset2);						\
      }									\
  } while (0)
# else /* BYTE */
#  define FREE_VARIABLES() ((void)0) /* Do nothing!  But inhibit gcc warning. */
# endif /* WCHAR */
#endif /* not MATCH_MAY_ALLOCATE */

/* These values must meet several constraints.  They must not be valid
   register values; since we have a limit of 255 registers (because
   we use only one byte in the pattern for the register number), we can
   use numbers larger than 255.  They must differ by 1, because of
   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
   be larger than the value for the highest register, so we do not try
   to actually save any registers when none are active.  */
#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)

#else /* not INSIDE_RECURSION */
/* Matching routines.  */

#ifndef emacs   /* Emacs never uses this.  */
/* re_match is like re_match_2 except it takes only a single string.  */

int
re_match (struct re_pattern_buffer *bufp,
	  const char *string,
	  int size, int pos,
	  struct re_registers *regs)
{
  int result;
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    result = wcs_re_match_2_internal (bufp, NULL, 0, string, size,
				      pos, regs, size,
				      NULL, 0, NULL, 0, NULL, NULL);
  else
# endif
    result = byte_re_match_2_internal (bufp, NULL, 0, string, size,
				  pos, regs, size);
# ifndef REGEX_MALLOC
#  ifdef C_ALLOCA
  alloca (0);
#  endif
# endif
  return result;
}
# ifdef _LIBC
weak_alias (__re_match, re_match)
# endif
#endif /* not emacs */

#endif /* not INSIDE_RECURSION */

#ifdef INSIDE_RECURSION
static boolean PREFIX(group_match_null_string_p) (UCHAR_T **p,
						  UCHAR_T *end,
					PREFIX(register_info_type) *reg_info);
static boolean PREFIX(alt_match_null_string_p) (UCHAR_T *p,
						UCHAR_T *end,
					PREFIX(register_info_type) *reg_info);
static boolean PREFIX(common_op_match_null_string_p) (UCHAR_T **p,
						      UCHAR_T *end,
					PREFIX(register_info_type) *reg_info);
static int PREFIX(bcmp_translate) (const CHAR_T *s1, const CHAR_T *s2,
				   int len, char *translate);
#else /* not INSIDE_RECURSION */

/* re_match_2 matches the compiled pattern in BUFP against the
   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
   and SIZE2, respectively).  We start matching at POS, and stop
   matching at STOP.

   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
   store offsets for the substring each group matched in REGS.  See the
   documentation for exactly how many groups we fill.

   We return -1 if no match, -2 if an internal error (such as the
   failure stack overflowing).  Otherwise, we return the length of the
   matched substring.  */

int
re_match_2 (struct re_pattern_buffer *bufp,
	    const char *string1, int size1,
	    const char *string2, int size2,
	    int pos, struct re_registers *regs,
	    int stop)
{
  int result;
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    result = wcs_re_match_2_internal (bufp, string1, size1, string2, size2,
				      pos, regs, stop,
				      NULL, 0, NULL, 0, NULL, NULL);
  else
# endif
    result = byte_re_match_2_internal (bufp, string1, size1, string2, size2,
				  pos, regs, stop);

#ifndef REGEX_MALLOC
# ifdef C_ALLOCA
  alloca (0);
# endif
#endif
  return result;
}
#ifdef _LIBC
weak_alias (__re_match_2, re_match_2)
#endif

#endif /* not INSIDE_RECURSION */

#ifdef INSIDE_RECURSION

#ifdef WCHAR

/* This check the substring (from 0, to length) of the multibyte string,
   to which offset_buffer correspond. And count how many wchar_t_characters
   the substring occupy. We use offset_buffer to optimization.
   See convert_mbs_to_wcs.  */

static int
count_mbs_length (int *offset_buffer, int length)
{
  int upper, lower;

  /* Check whether the size is valid.  */
  if (length < 0)
    return -1;

  if (offset_buffer == NULL)
    return 0;

  /* If there are no multibyte character, offset_buffer[i] == i.
   Optmize for this case.  */
  if (offset_buffer[length] == length)
    return length;

  /* Set up upper with length. (because for all i, offset_buffer[i] >= i)  */
  upper = length;
  lower = 0;

  while (true)
    {
      int middle = (lower + upper) / 2;
      if (middle == lower || middle == upper)
	break;
      if (offset_buffer[middle] > length)
	upper = middle;
      else if (offset_buffer[middle] < length)
	lower = middle;
      else
	return middle;
    }

  return -1;
}
#endif /* WCHAR */

/* This is a separate function so that we can force an alloca cleanup
   afterwards.  */
#ifdef WCHAR
static int
wcs_re_match_2_internal (struct re_pattern_buffer *bufp,
			 const char *cstring1, int csize1,
			 const char *cstring2, int csize2,
			 int pos,
			 struct re_registers *regs,
			 int stop,
			 /* string1 == string2 == NULL means
			    string1/2, size1/2 and mbs_offset1/2 need
			    setting up in this function.  */
			 /* We need wchar_t * buffers corresponding to
			    cstring1, cstring2.  */
			 wchar_t *string1, int size1,
			 wchar_t *string2, int size2,
			 /* Offset buffer for optimization.  See
			    convert_mbs_to_wc.  */
			 int *mbs_offset1,
			 int *mbs_offset2)
#else /* BYTE */
static int
byte_re_match_2_internal (struct re_pattern_buffer *bufp,
			  const char *string1, int size1,
			  const char *string2, int size2,
			  int pos,
			  struct re_registers *regs,
			  int stop)
#endif /* BYTE */
{
  /* General temporaries.  */
  int mcnt;
  UCHAR_T *p1;
#ifdef WCHAR
  /* They hold whether each wchar_t is binary data or not.  */
  char *is_binary = NULL;
  /* If true, we can't free string1/2, mbs_offset1/2.  */
  int cant_free_wcs_buf = 1;
#endif /* WCHAR */

  /* Just past the end of the corresponding string.  */
  const CHAR_T *end1, *end2;

  /* Pointers into string1 and string2, just past the last characters in
     each to consider matching.  */
  const CHAR_T *end_match_1, *end_match_2;

  /* Where we are in the data, and the end of the current string.  */
  const CHAR_T *d, *dend;

  /* Where we are in the pattern, and the end of the pattern.  */
#ifdef WCHAR
  UCHAR_T *pattern, *p;
  register UCHAR_T *pend;
#else /* BYTE */
  UCHAR_T *p = bufp->buffer;
  register UCHAR_T *pend = p + bufp->used;
#endif /* WCHAR */

  /* Mark the opcode just after a start_memory, so we can test for an
     empty subpattern when we get to the stop_memory.  */
  UCHAR_T *just_past_start_mem = 0;

  /* We use this to map every character in the string.  */
  RE_TRANSLATE_TYPE translate = bufp->translate;

  /* Failure point stack.  Each place that can handle a failure further
     down the line pushes a failure point on this stack.  It consists of
     restart, regend, and reg_info for all registers corresponding to
     the subexpressions we're currently inside, plus the number of such
     registers, and, finally, two char *'s.  The first char * is where
     to resume scanning the pattern; the second one is where to resume
     scanning the strings.  If the latter is zero, the failure point is
     a ``dummy''; if a failure happens and the failure point is a dummy,
     it gets discarded and the next next one is tried.  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
  PREFIX(fail_stack_type) fail_stack;
#endif
#ifdef DEBUG
  static unsigned failure_id;
  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
#endif

#ifdef REL_ALLOC
  /* This holds the pointer to the failure stack, when
     it is allocated relocatably.  */
  fail_stack_elt_t *failure_stack_ptr;
#endif

  /* We fill all the registers internally, independent of what we
     return, for use in backreferences.  The number here includes
     an element for register zero.  */
  size_t num_regs = bufp->re_nsub + 1;

  /* The currently active registers.  */
  active_reg_t lowest_active_reg = NO_LOWEST_ACTIVE_REG;
  active_reg_t highest_active_reg = NO_HIGHEST_ACTIVE_REG;

  /* Information on the contents of registers. These are pointers into
     the input strings; they record just what was matched (on this
     attempt) by a subexpression part of the pattern, that is, the
     regnum-th regstart pointer points to where in the pattern we began
     matching and the regnum-th regend points to right after where we
     stopped matching the regnum-th subexpression.  (The zeroth register
     keeps track of what the whole pattern matches.)  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
  const CHAR_T **regstart, **regend;
#endif

  /* If a group that's operated upon by a repetition operator fails to
     match anything, then the register for its start will need to be
     restored because it will have been set to wherever in the string we
     are when we last see its open-group operator.  Similarly for a
     register's end.  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
  const CHAR_T **old_regstart, **old_regend;
#endif

  /* The is_active field of reg_info helps us keep track of which (possibly
     nested) subexpressions we are currently in. The matched_something
     field of reg_info[reg_num] helps us tell whether or not we have
     matched any of the pattern so far this time through the reg_num-th
     subexpression.  These two fields get reset each time through any
     loop their register is in.  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
  PREFIX(register_info_type) *reg_info;
#endif

  /* The following record the register info as found in the above
     variables when we find a match better than any we've seen before.
     This happens as we backtrack through the failure points, which in
     turn happens only if we have not yet matched the entire string. */
  unsigned best_regs_set = false;
#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
  const CHAR_T **best_regstart, **best_regend;
#endif

  /* Logically, this is `best_regend[0]'.  But we don't want to have to
     allocate space for that if we're not allocating space for anything
     else (see below).  Also, we never need info about register 0 for
     any of the other register vectors, and it seems rather a kludge to
     treat `best_regend' differently than the rest.  So we keep track of
     the end of the best match so far in a separate variable.  We
     initialize this to NULL so that when we backtrack the first time
     and need to test it, it's not garbage.  */
  const CHAR_T *match_end = NULL;

  /* This helps SET_REGS_MATCHED avoid doing redundant work.  */
  int set_regs_matched_done = 0;

  /* Used when we pop values we don't care about.  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
  const CHAR_T **reg_dummy;
  PREFIX(register_info_type) *reg_info_dummy;
#endif

#ifdef DEBUG
  /* Counts the total number of registers pushed.  */
  unsigned num_regs_pushed = 0;
#endif

  /* Definitions for state transitions.  More efficiently for gcc.  */
#ifdef __GNUC__
# if defined HAVE_SUBTRACT_LOCAL_LABELS && defined SHARED
#  define NEXT \
      do								      \
	{								      \
	  int offset;							      \
	  const void *__unbounded ptr;					      \
	  offset = (p == pend						      \
		    ? 0 : jmptable[SWITCH_ENUM_CAST ((re_opcode_t) *p++)]);   \
	  ptr = &&end_of_pattern + offset;				      \
	  goto *ptr;							      \
	}								      \
      while (0)
#  define REF(x) \
  &&label_##x - &&end_of_pattern
#  define JUMP_TABLE_TYPE const int
# else
#  define NEXT \
      do								      \
	{								      \
	  const void *__unbounded ptr;					      \
	  ptr = (p == pend ? &&end_of_pattern				      \
		 : jmptable[SWITCH_ENUM_CAST ((re_opcode_t) *p++)]);	      \
	  goto *ptr;							      \
	}								      \
      while (0)
#  define REF(x) \
  &&label_##x
#  define JUMP_TABLE_TYPE const void *const
# endif
# define CASE(x) label_##x
  static JUMP_TABLE_TYPE jmptable[] =
    {
    REF (no_op),
    REF (succeed),
    REF (exactn),
# ifdef MBS_SUPPORT
    REF (exactn_bin),
# endif
    REF (anychar),
    REF (charset),
    REF (charset_not),
    REF (start_memory),
    REF (stop_memory),
    REF (duplicate),
    REF (begline),
    REF (endline),
    REF (begbuf),
    REF (endbuf),
    REF (jump),
    REF (jump_past_alt),
    REF (on_failure_jump),
    REF (on_failure_keep_string_jump),
    REF (pop_failure_jump),
    REF (maybe_pop_jump),
    REF (dummy_failure_jump),
    REF (push_dummy_failure),
    REF (succeed_n),
    REF (jump_n),
    REF (set_number_at),
    REF (wordchar),
    REF (notwordchar),
    REF (wordbeg),
    REF (wordend),
    REF (wordbound),
    REF (notwordbound)
# ifdef emacs
    ,REF (before_dot),
    REF (at_dot),
    REF (after_dot),
    REF (syntaxspec),
    REF (notsyntaxspec)
# endif
    };
#else
# define NEXT \
  break
# define CASE(x) \
  case x
#endif

  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");

  INIT_FAIL_STACK ();

#ifdef MATCH_MAY_ALLOCATE
  /* Do not bother to initialize all the register variables if there are
     no groups in the pattern, as it takes a fair amount of time.  If
     there are groups, we include space for register 0 (the whole
     pattern), even though we never use it, since it simplifies the
     array indexing.  We should fix this.  */
  if (bufp->re_nsub)
    {
      regstart = REGEX_TALLOC (num_regs, const CHAR_T *);
      regend = REGEX_TALLOC (num_regs, const CHAR_T *);
      old_regstart = REGEX_TALLOC (num_regs, const CHAR_T *);
      old_regend = REGEX_TALLOC (num_regs, const CHAR_T *);
      best_regstart = REGEX_TALLOC (num_regs, const CHAR_T *);
      best_regend = REGEX_TALLOC (num_regs, const CHAR_T *);
      reg_info = REGEX_TALLOC (num_regs, PREFIX(register_info_type));
      reg_dummy = REGEX_TALLOC (num_regs, const CHAR_T *);
      reg_info_dummy = REGEX_TALLOC (num_regs, PREFIX(register_info_type));

      if (!(regstart && regend && old_regstart && old_regend && reg_info
            && best_regstart && best_regend && reg_dummy && reg_info_dummy))
        {
          FREE_VARIABLES ();
          return -2;
        }
    }
  else
    {
      /* We must initialize all our variables to NULL, so that
         `FREE_VARIABLES' doesn't try to free them.  */
      regstart = regend = old_regstart = old_regend = best_regstart
        = best_regend = reg_dummy = NULL;
      reg_info = reg_info_dummy = (PREFIX(register_info_type) *) NULL;
    }
#endif /* MATCH_MAY_ALLOCATE */

  /* The starting position is bogus.  */
#ifdef WCHAR
  if (pos < 0 || pos > csize1 + csize2)
#else /* BYTE */
  if (pos < 0 || pos > size1 + size2)
#endif
    {
      FREE_VARIABLES ();
      return -1;
    }

#ifdef WCHAR
  /* Allocate wchar_t array for string1 and string2 and
     fill them with converted string.  */
  if (string1 == NULL && string2 == NULL)
    {
      /* We need seting up buffers here.  */

      /* We must free wcs buffers in this function.  */
      cant_free_wcs_buf = 0;

      if (csize1 != 0)
	{
	  string1 = REGEX_TALLOC (csize1 + 1, CHAR_T);
	  mbs_offset1 = REGEX_TALLOC (csize1 + 1, int);
	  is_binary = REGEX_TALLOC (csize1 + 1, char);
	  if (!string1 || !mbs_offset1 || !is_binary)
	    {
	      FREE_VAR (string1);
	      FREE_VAR (mbs_offset1);
	      FREE_VAR (is_binary);
	      return -2;
	    }
	}
      if (csize2 != 0)
	{
	  string2 = REGEX_TALLOC (csize2 + 1, CHAR_T);
	  mbs_offset2 = REGEX_TALLOC (csize2 + 1, int);
	  is_binary = REGEX_TALLOC (csize2 + 1, char);
	  if (!string2 || !mbs_offset2 || !is_binary)
	    {
	      FREE_VAR (string1);
	      FREE_VAR (mbs_offset1);
	      FREE_VAR (string2);
	      FREE_VAR (mbs_offset2);
	      FREE_VAR (is_binary);
	      return -2;
	    }
	  size2 = convert_mbs_to_wcs(string2, cstring2, csize2,
				     mbs_offset2, is_binary);
	  string2[size2] = L'\0'; /* for a sentinel  */
	  FREE_VAR (is_binary);
	}
    }

  /* We need to cast pattern to (wchar_t*), because we casted this compiled
     pattern to (char*) in regex_compile.  */
  p = pattern = (CHAR_T*)bufp->buffer;
  pend = (CHAR_T*)(bufp->buffer + bufp->used);

#endif /* WCHAR */

  /* Initialize subexpression text positions to -1 to mark ones that no
     start_memory/stop_memory has been seen for. Also initialize the
     register information struct.  */
  for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
    {
      regstart[mcnt] = regend[mcnt]
        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;

      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
      IS_ACTIVE (reg_info[mcnt]) = 0;
      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
    }

  /* We move `string1' into `string2' if the latter's empty -- but not if
     `string1' is null.  */
  if (size2 == 0 && string1 != NULL)
    {
      string2 = string1;
      size2 = size1;
      string1 = 0;
      size1 = 0;
#ifdef WCHAR
      mbs_offset2 = mbs_offset1;
      csize2 = csize1;
      mbs_offset1 = NULL;
      csize1 = 0;
#endif
    }
  end1 = string1 + size1;
  end2 = string2 + size2;

  /* Compute where to stop matching, within the two strings.  */
#ifdef WCHAR
  if (stop <= csize1)
    {
      mcnt = count_mbs_length(mbs_offset1, stop);
      end_match_1 = string1 + mcnt;
      end_match_2 = string2;
    }
  else
    {
      if (stop > csize1 + csize2)
	stop = csize1 + csize2;
      end_match_1 = end1;
      mcnt = count_mbs_length(mbs_offset2, stop-csize1);
      end_match_2 = string2 + mcnt;
    }
  if (mcnt < 0)
    { /* count_mbs_length return error.  */
      FREE_VARIABLES ();
      return -1;
    }
#else
  if (stop <= size1)
    {
      end_match_1 = string1 + stop;
      end_match_2 = string2;
    }
  else
    {
      end_match_1 = end1;
      end_match_2 = string2 + stop - size1;
    }
#endif /* WCHAR */

  /* `p' scans through the pattern as `d' scans through the data.
     `dend' is the end of the input string that `d' points within.  `d'
     is advanced into the following input string whenever necessary, but
     this happens before fetching; therefore, at the beginning of the
     loop, `d' can be pointing at the end of a string, but it cannot
     equal `string2'.  */
#ifdef WCHAR
  if (size1 > 0 && pos <= csize1)
    {
      mcnt = count_mbs_length(mbs_offset1, pos);
      d = string1 + mcnt;
      dend = end_match_1;
    }
  else
    {
      mcnt = count_mbs_length(mbs_offset2, pos-csize1);
      d = string2 + mcnt;
      dend = end_match_2;
    }

  if (mcnt < 0)
    { /* count_mbs_length return error.  */
      FREE_VARIABLES ();
      return -1;
    }
#else
  if (size1 > 0 && pos <= size1)
    {
      d = string1 + pos;
      dend = end_match_1;
    }
  else
    {
      d = string2 + pos - size1;
      dend = end_match_2;
    }
#endif /* WCHAR */

  DEBUG_PRINT1 ("The compiled pattern is:\n");
  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
  DEBUG_PRINT1 ("The string to match is: `");
  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
  DEBUG_PRINT1 ("'\n");

  /* This loops over pattern commands.  It exits by returning from the
     function if the match is complete, or it drops through if the match
     fails at this starting point in the input data.  */
  for (;;)
    {
#ifdef _LIBC
      DEBUG_PRINT2 ("\n%p: ", p);
#else
      DEBUG_PRINT2 ("\n0x%x: ", p);
#endif

#ifdef __GNUC__
      NEXT;
#else
      if (p == pend)
#endif
	{
#ifdef __GNUC__
	end_of_pattern:
#endif
	  /* End of pattern means we might have succeeded.  */
	  DEBUG_PRINT1 ("end of pattern ... ");

	  /* If we haven't matched the entire string, and we want the
	     longest match, try backtracking.  */
	  if (d != end_match_2)
	    {
	      /* 1 if this match ends in the same string (string1 or string2)
		 as the best previous match.  */
	      boolean same_str_p = (FIRST_STRING_P (match_end)
				    == MATCHING_IN_FIRST_STRING);
	      /* 1 if this match is the best seen so far.  */
	      boolean best_match_p;

	      /* AIX compiler got confused when this was combined
		 with the previous declaration.  */
	      if (same_str_p)
		best_match_p = d > match_end;
	      else
		best_match_p = !MATCHING_IN_FIRST_STRING;

	      DEBUG_PRINT1 ("backtracking.\n");

	      if (!FAIL_STACK_EMPTY ())
		{ /* More failure points to try.  */

		  /* If exceeds best match so far, save it.  */
		  if (!best_regs_set || best_match_p)
		    {
		      best_regs_set = true;
		      match_end = d;

		      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");

		      for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
			{
			  best_regstart[mcnt] = regstart[mcnt];
			  best_regend[mcnt] = regend[mcnt];
			}
		    }
		  goto fail;
		}

	      /* If no failure points, don't restore garbage.  And if
		 last match is real best match, don't restore second
		 best one. */
	      else if (best_regs_set && !best_match_p)
		{
		restore_best_regs:
		  /* Restore best match.  It may happen that `dend ==
		     end_match_1' while the restored d is in string2.
		     For example, the pattern `x.*y.*z' against the
		     strings `x-' and `y-z-', if the two strings are
		     not consecutive in memory.  */
		  DEBUG_PRINT1 ("Restoring best registers.\n");

		  d = match_end;
		  dend = ((d >= string1 && d <= end1)
			  ? end_match_1 : end_match_2);

		  for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
		    {
		      regstart[mcnt] = best_regstart[mcnt];
		      regend[mcnt] = best_regend[mcnt];
		    }
		}
	    } /* d != end_match_2 */

	succeed_label:
	  DEBUG_PRINT1 ("Accepting match.\n");
	  /* If caller wants register contents data back, do it.  */
	  if (regs && !bufp->no_sub)
	    {
	      /* Have the register data arrays been allocated?  */
	      if (bufp->regs_allocated == REGS_UNALLOCATED)
		{ /* No.  So allocate them with malloc.  We need one
		     extra element beyond `num_regs' for the `-1' marker
		     GNU code uses.  */
		  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
		  regs->start = TALLOC (regs->num_regs, regoff_t);
		  regs->end = TALLOC (regs->num_regs, regoff_t);
		  if (regs->start == NULL || regs->end == NULL)
		    {
		      FREE_VARIABLES ();
		      return -2;
		    }
		  bufp->regs_allocated = REGS_REALLOCATE;
		}
	      else if (bufp->regs_allocated == REGS_REALLOCATE)
		{ /* Yes.  If we need more elements than were already
		     allocated, reallocate them.  If we need fewer, just
		     leave it alone.  */
		  if (regs->num_regs < num_regs + 1)
		    {
		      regs->num_regs = num_regs + 1;
		      RETALLOC (regs->start, regs->num_regs, regoff_t);
		      RETALLOC (regs->end, regs->num_regs, regoff_t);
		      if (regs->start == NULL || regs->end == NULL)
			{
			  FREE_VARIABLES ();
			  return -2;
			}
		    }
		}
	      else
		{
		  /* These braces fend off a "empty body in an else-statement"
		     warning under GCC when assert expands to nothing.  */
		  assert (bufp->regs_allocated == REGS_FIXED);
		}

	      /* Convert the pointer data in `regstart' and `regend' to
		 indices.  Register zero has to be set differently,
		 since we haven't kept track of any info for it.  */
	      if (regs->num_regs > 0)
		{
		  regs->start[0] = pos;
#ifdef WCHAR
		  if (MATCHING_IN_FIRST_STRING)
		    regs->end[0] = (mbs_offset1 != NULL ?
				    mbs_offset1[d-string1] : 0);
		  else
		    regs->end[0] = csize1 + (mbs_offset2 != NULL
					     ? mbs_offset2[d-string2] : 0);
#else
		  regs->end[0] = (MATCHING_IN_FIRST_STRING
				  ? ((regoff_t) (d - string1))
				  : ((regoff_t) (d - string2 + size1)));
#endif /* WCHAR */
		}

	      /* Go through the first `min (num_regs, regs->num_regs)'
		 registers, since that is all we initialized.  */
	      for (mcnt = 1; (unsigned) mcnt < MIN (num_regs, regs->num_regs);
		   mcnt++)
		{
		  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))
		    regs->start[mcnt] = regs->end[mcnt] = -1;
		  else
		    {
		      regs->start[mcnt]
			= (regoff_t) POINTER_TO_OFFSET (regstart[mcnt]);
		      regs->end[mcnt]
			= (regoff_t) POINTER_TO_OFFSET (regend[mcnt]);
		    }
		}

	      /* If the regs structure we return has more elements than
		 were in the pattern, set the extra elements to -1.  If
		 we (re)allocated the registers, this is the case,
		 because we always allocate enough to have at least one
		 -1 at the end.  */
	      for (mcnt = num_regs; (unsigned) mcnt < regs->num_regs; mcnt++)
		regs->start[mcnt] = regs->end[mcnt] = -1;
	    } /* regs && !bufp->no_sub */

	  DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
			nfailure_points_pushed, nfailure_points_popped,
			nfailure_points_pushed - nfailure_points_popped);
	  DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);

#ifdef WCHAR
	  if (MATCHING_IN_FIRST_STRING)
	    mcnt = mbs_offset1 != NULL ? mbs_offset1[d-string1] : 0;
	  else
	    mcnt = (mbs_offset2 != NULL ? mbs_offset2[d-string2] : 0) +
	      csize1;
	  mcnt -= pos;
#else
	  mcnt = d - pos - (MATCHING_IN_FIRST_STRING
			    ? string1 : string2 - size1);
#endif /* WCHAR */

	  DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);

	  FREE_VARIABLES ();
	  return mcnt;
	}

#ifndef __GNUC__
      /* Otherwise match next pattern command.  */
      switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))
	{
#endif
        /* Ignore these.  Used to ignore the n of succeed_n's which
           currently have n == 0.  */
        CASE (no_op):
          DEBUG_PRINT1 ("EXECUTING no_op.\n");
          NEXT;

	CASE (succeed):
          DEBUG_PRINT1 ("EXECUTING succeed.\n");
	  goto succeed_label;

        /* Match the next n pattern characters exactly.  The following
           byte in the pattern defines n, and the n bytes after that
           are the characters to match.  */
	CASE (exactn):
#ifdef MBS_SUPPORT
	CASE (exactn_bin):
#endif
	  mcnt = *p++;
          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);

          /* This is written out as an if-else so we don't waste time
             testing `translate' inside the loop.  */
          if (translate)
	    {
	      do
		{
		  PREFETCH ();
#ifdef WCHAR
		  if (*d <= 0xff)
		    {
		      if ((UCHAR_T) translate[(unsigned char) *d++]
			  != (UCHAR_T) *p++)
			goto fail;
		    }
		  else
		    {
		      if (*d++ != (CHAR_T) *p++)
			goto fail;
		    }
#else
		  if ((UCHAR_T) translate[(unsigned char) *d++]
		      != (UCHAR_T) *p++)
                    goto fail;
#endif /* WCHAR */
		}
	      while (--mcnt);
	    }
	  else
	    {
	      do
		{
		  PREFETCH ();
		  if (*d++ != (CHAR_T) *p++) goto fail;
		}
	      while (--mcnt);
	    }
	  SET_REGS_MATCHED ();
          NEXT;


        /* Match any character except possibly a newline or a null.  */
	CASE (anychar):
          DEBUG_PRINT1 ("EXECUTING anychar.\n");

          PREFETCH ();

          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
	    goto fail;

          SET_REGS_MATCHED ();
          DEBUG_PRINT2 ("  Matched `%ld'.\n", (long int) *d);
          d++;
	  NEXT;


	CASE (charset):
	CASE (charset_not):
	  {
	    register UCHAR_T c;
#ifdef WCHAR
	    unsigned int i, char_class_length, coll_symbol_length,
              equiv_class_length, ranges_length, chars_length, length;
	    CHAR_T *workp, *workp2, *charset_top;
#define WORK_BUFFER_SIZE 128
            CHAR_T str_buf[WORK_BUFFER_SIZE];
# ifdef _LIBC
	    uint32_t nrules;
# endif /* _LIBC */
#endif /* WCHAR */
	    boolean not = (re_opcode_t) *(p - 1) == charset_not;

            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
	    PREFETCH ();
	    c = TRANSLATE (*d); /* The character to match.  */
#ifdef WCHAR
# ifdef _LIBC
	    nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
# endif /* _LIBC */
	    charset_top = p - 1;
	    char_class_length = *p++;
	    coll_symbol_length = *p++;
	    equiv_class_length = *p++;
	    ranges_length = *p++;
	    chars_length = *p++;
	    /* p points charset[6], so the address of the next instruction
	       (charset[l+m+n+2o+k+p']) equals p[l+m+n+2*o+p'],
	       where l=length of char_classes, m=length of collating_symbol,
	       n=equivalence_class, o=length of char_range,
	       p'=length of character.  */
	    workp = p;
	    /* Update p to indicate the next instruction.  */
	    p += char_class_length + coll_symbol_length+ equiv_class_length +
              2*ranges_length + chars_length;

            /* match with char_class?  */
	    for (i = 0; i < char_class_length ; i += CHAR_CLASS_SIZE)
	      {
		wctype_t wctype;
		uintptr_t alignedp = ((uintptr_t)workp
				      + __alignof__(wctype_t) - 1)
		  		      & ~(uintptr_t)(__alignof__(wctype_t) - 1);
		wctype = *((wctype_t*)alignedp);
		workp += CHAR_CLASS_SIZE;
		if (iswctype((wint_t)c, wctype))
		  goto char_set_matched;
	      }

            /* match with collating_symbol?  */
# ifdef _LIBC
	    if (nrules != 0)
	      {
		const unsigned char *extra = (const unsigned char *)
		  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);

		for (workp2 = workp + coll_symbol_length ; workp < workp2 ;
		     workp++)
		  {
		    int32_t *wextra;
		    wextra = (int32_t*)(extra + *workp++);
		    for (i = 0; i < *wextra; ++i)
		      if (TRANSLATE(d[i]) != wextra[1 + i])
			break;

		    if (i == *wextra)
		      {
			/* Update d, however d will be incremented at
			   char_set_matched:, we decrement d here.  */
			d += i - 1;
			goto char_set_matched;
		      }
		  }
	      }
	    else /* (nrules == 0) */
# endif
	      /* If we can't look up collation data, we use wcscoll
		 instead.  */
	      {
		for (workp2 = workp + coll_symbol_length ; workp < workp2 ;)
		  {
		    const CHAR_T *backup_d = d, *backup_dend = dend;
		    length = wcslen (workp);

		    /* If wcscoll(the collating symbol, whole string) > 0,
		       any substring of the string never match with the
		       collating symbol.  */
		    if (wcscoll (workp, d) > 0)
		      {
			workp += length + 1;
			continue;
		      }

		    /* First, we compare the collating symbol with
		       the first character of the string.
		       If it don't match, we add the next character to
		       the compare buffer in turn.  */
		    for (i = 0 ; i < WORK_BUFFER_SIZE-1 ; i++, d++)
		      {
			int match;
			if (d == dend)
			  {
			    if (dend == end_match_2)
			      break;
			    d = string2;
			    dend = end_match_2;
			  }

			/* add next character to the compare buffer.  */
			str_buf[i] = TRANSLATE(*d);
			str_buf[i+1] = '\0';

			match = wcscoll (workp, str_buf);
			if (match == 0)
			  goto char_set_matched;

			if (match < 0)
			  /* (str_buf > workp) indicate (str_buf + X > workp),
			     because for all X (str_buf + X > str_buf).
			     So we don't need continue this loop.  */
			  break;

			/* Otherwise(str_buf < workp),
			   (str_buf+next_character) may equals (workp).
			   So we continue this loop.  */
		      }
		    /* not matched */
		    d = backup_d;
		    dend = backup_dend;
		    workp += length + 1;
		  }
              }
            /* match with equivalence_class?  */
# ifdef _LIBC
	    if (nrules != 0)
	      {
                const CHAR_T *backup_d = d, *backup_dend = dend;
		/* Try to match the equivalence class against
		   those known to the collate implementation.  */
		const int32_t *table;
		const int32_t *weights;
		const int32_t *extra;
		const int32_t *indirect;
		int32_t idx, idx2;
		wint_t *cp;
		size_t len;

		/* This #include defines a local function!  */
#  include <locale/weightwc.h>

		table = (const int32_t *)
		  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEWC);
		weights = (const wint_t *)
		  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTWC);
		extra = (const wint_t *)
		  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAWC);
		indirect = (const int32_t *)
		  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTWC);

		/* Write 1 collating element to str_buf, and
		   get its index.  */
		idx2 = 0;

		for (i = 0 ; idx2 == 0 && i < WORK_BUFFER_SIZE - 1; i++)
		  {
		    cp = (wint_t*)str_buf;
		    if (d == dend)
		      {
			if (dend == end_match_2)
			  break;
			d = string2;
			dend = end_match_2;
		      }
		    str_buf[i] = TRANSLATE(*(d+i));
		    str_buf[i+1] = '\0'; /* sentinel */
		    idx2 = findidx ((const wint_t**)&cp);
		  }

		/* Update d, however d will be incremented at
		   char_set_matched:, we decrement d here.  */
		d = backup_d + ((wchar_t*)cp - (wchar_t*)str_buf - 1);
		if (d >= dend)
		  {
		    if (dend == end_match_2)
			d = dend;
		    else
		      {
			d = string2;
			dend = end_match_2;
		      }
		  }

		len = weights[idx2];

		for (workp2 = workp + equiv_class_length ; workp < workp2 ;
		     workp++)
		  {
		    idx = (int32_t)*workp;
		    /* We already checked idx != 0 in regex_compile. */

		    if (idx2 != 0 && len == weights[idx])
		      {
			int cnt = 0;
			while (cnt < len && (weights[idx + 1 + cnt]
					     == weights[idx2 + 1 + cnt]))
			  ++cnt;

			if (cnt == len)
			  goto char_set_matched;
		      }
		  }
		/* not matched */
                d = backup_d;
                dend = backup_dend;
	      }
	    else /* (nrules == 0) */
# endif
	      /* If we can't look up collation data, we use wcscoll
		 instead.  */
	      {
		for (workp2 = workp + equiv_class_length ; workp < workp2 ;)
		  {
		    const CHAR_T *backup_d = d, *backup_dend = dend;
		    length = wcslen (workp);

		    /* If wcscoll(the collating symbol, whole string) > 0,
		       any substring of the string never match with the
		       collating symbol.  */
		    if (wcscoll (workp, d) > 0)
		      {
			workp += length + 1;
			break;
		      }

		    /* First, we compare the equivalence class with
		       the first character of the string.
		       If it don't match, we add the next character to
		       the compare buffer in turn.  */
		    for (i = 0 ; i < WORK_BUFFER_SIZE - 1 ; i++, d++)
		      {
			int match;
			if (d == dend)
			  {
			    if (dend == end_match_2)
			      break;
			    d = string2;
			    dend = end_match_2;
			  }

			/* add next character to the compare buffer.  */
			str_buf[i] = TRANSLATE(*d);
			str_buf[i+1] = '\0';

			match = wcscoll (workp, str_buf);

			if (match == 0)
			  goto char_set_matched;

			if (match < 0)
			/* (str_buf > workp) indicate (str_buf + X > workp),
			   because for all X (str_buf + X > str_buf).
			   So we don't need continue this loop.  */
			  break;

			/* Otherwise(str_buf < workp),
			   (str_buf+next_character) may equals (workp).
			   So we continue this loop.  */
		      }
		    /* not matched */
		    d = backup_d;
		    dend = backup_dend;
		    workp += length + 1;
		  }
	      }

            /* match with char_range?  */
# ifdef _LIBC
	    if (nrules != 0)
	      {
		uint32_t collseqval;
		const char *collseq = (const char *)
		  _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQWC);

		collseqval = collseq_table_lookup (collseq, c);

		for (; workp < p - chars_length ;)
		  {
		    uint32_t start_val, end_val;

		    /* We already compute the collation sequence value
		       of the characters (or collating symbols).  */
		    start_val = (uint32_t) *workp++; /* range_start */
		    end_val = (uint32_t) *workp++; /* range_end */

		    if (start_val <= collseqval && collseqval <= end_val)
		      goto char_set_matched;
		  }
	      }
	    else
# endif
	      {
		/* We set range_start_char at str_buf[0], range_end_char
		   at str_buf[4], and compared char at str_buf[2].  */
		str_buf[1] = 0;
		str_buf[2] = c;
		str_buf[3] = 0;
		str_buf[5] = 0;
		for (; workp < p - chars_length ;)
		  {
		    wchar_t *range_start_char, *range_end_char;

		    /* match if (range_start_char <= c <= range_end_char).  */

		    /* If range_start(or end) < 0, we assume -range_start(end)
		       is the offset of the collating symbol which is specified
		       as the character of the range start(end).  */

		    /* range_start */
		    if (*workp < 0)
		      range_start_char = charset_top - (*workp++);
		    else
		      {
			str_buf[0] = *workp++;
			range_start_char = str_buf;
		      }

		    /* range_end */
		    if (*workp < 0)
		      range_end_char = charset_top - (*workp++);
		    else
		      {
			str_buf[4] = *workp++;
			range_end_char = str_buf + 4;
		      }

		    if (wcscoll (range_start_char, str_buf+2) <= 0
			&& wcscoll (str_buf+2, range_end_char) <= 0)
		      goto char_set_matched;
		  }
	      }

            /* match with char?  */
	    for (; workp < p ; workp++)
	      if (c == *workp)
		goto char_set_matched;

	    not = !not;

	  char_set_matched:
	    if (not) goto fail;
#else
            /* Cast to `unsigned' instead of `unsigned char' in case the
               bit list is a full 32 bytes long.  */
	    if (c < (unsigned) (*p * BYTEWIDTH)
		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
	      not = !not;

	    p += 1 + *p;

	    if (!not) goto fail;
#undef WORK_BUFFER_SIZE
#endif /* WCHAR */
	    SET_REGS_MATCHED ();
            d++;
	    NEXT;
	  }


        /* The beginning of a group is represented by start_memory.
           The arguments are the register number in the next byte, and the
           number of groups inner to this one in the next.  The text
           matched within the group is recorded (in the internal
           registers data structure) under the register number.  */
        CASE (start_memory):
	  DEBUG_PRINT3 ("EXECUTING start_memory %ld (%ld):\n",
			(long int) *p, (long int) p[1]);

          /* Find out if this group can match the empty string.  */
	  p1 = p;		/* To send to group_match_null_string_p.  */

          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
            REG_MATCH_NULL_STRING_P (reg_info[*p])
              = PREFIX(group_match_null_string_p) (&p1, pend, reg_info);

          /* Save the position in the string where we were the last time
             we were at this open-group operator in case the group is
             operated upon by a repetition operator, e.g., with `(a*)*b'
             against `ab'; then we want to ignore where we are now in
             the string in case this attempt to match fails.  */
          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
                             : regstart[*p];
	  DEBUG_PRINT2 ("  old_regstart: %d\n",
			 POINTER_TO_OFFSET (old_regstart[*p]));

          regstart[*p] = d;
	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));

          IS_ACTIVE (reg_info[*p]) = 1;
          MATCHED_SOMETHING (reg_info[*p]) = 0;

	  /* Clear this whenever we change the register activity status.  */
	  set_regs_matched_done = 0;

          /* This is the new highest active register.  */
          highest_active_reg = *p;

          /* If nothing was active before, this is the new lowest active
             register.  */
          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
            lowest_active_reg = *p;

          /* Move past the register number and inner group count.  */
          p += 2;
	  just_past_start_mem = p;

          NEXT;


        /* The stop_memory opcode represents the end of a group.  Its
           arguments are the same as start_memory's: the register
           number, and the number of inner groups.  */
	CASE (stop_memory):
	  DEBUG_PRINT3 ("EXECUTING stop_memory %ld (%ld):\n",
			(long int) *p, (long int) p[1]);

          /* We need to save the string position the last time we were at
             this close-group operator in case the group is operated
             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
             against `aba'; then we want to ignore where we are now in
             the string in case this attempt to match fails.  */
          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
			   : regend[*p];
	  DEBUG_PRINT2 ("      old_regend: %d\n",
			 POINTER_TO_OFFSET (old_regend[*p]));

          regend[*p] = d;
	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));

          /* This register isn't active anymore.  */
          IS_ACTIVE (reg_info[*p]) = 0;

	  /* Clear this whenever we change the register activity status.  */
	  set_regs_matched_done = 0;

          /* If this was the only register active, nothing is active
             anymore.  */
          if (lowest_active_reg == highest_active_reg)
            {
              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
            }
          else
            { /* We must scan for the new highest active register, since
                 it isn't necessarily one less than now: consider
                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
                 new highest active register is 1.  */
              UCHAR_T r = *p - 1;
              while (r > 0 && !IS_ACTIVE (reg_info[r]))
                r--;

              /* If we end up at register zero, that means that we saved
                 the registers as the result of an `on_failure_jump', not
                 a `start_memory', and we jumped to past the innermost
                 `stop_memory'.  For example, in ((.)*) we save
                 registers 1 and 2 as a result of the *, but when we pop
                 back to the second ), we are at the stop_memory 1.
                 Thus, nothing is active.  */
	      if (r == 0)
                {
                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
                }
              else
                highest_active_reg = r;
            }

          /* If just failed to match something this time around with a
             group that's operated on by a repetition operator, try to
             force exit from the ``loop'', and restore the register
             information for this group that we had before trying this
             last match.  */
          if ((!MATCHED_SOMETHING (reg_info[*p])
               || just_past_start_mem == p - 1)
	      && (p + 2) < pend)
            {
              boolean is_a_jump_n = false;

              p1 = p + 2;
              mcnt = 0;
              switch ((re_opcode_t) *p1++)
                {
                  case jump_n:
		    is_a_jump_n = true;
                  case pop_failure_jump:
		  case maybe_pop_jump:
		  case jump:
		  case dummy_failure_jump:
                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
		    if (is_a_jump_n)
		      p1 += OFFSET_ADDRESS_SIZE;
                    break;

                  default:
                    /* do nothing */ ;
                }
	      p1 += mcnt;

              /* If the next operation is a jump backwards in the pattern
	         to an on_failure_jump right before the start_memory
                 corresponding to this stop_memory, exit from the loop
                 by forcing a failure after pushing on the stack the
                 on_failure_jump's jump in the pattern, and d.  */
              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
                  && (re_opcode_t) p1[1+OFFSET_ADDRESS_SIZE] == start_memory
		  && p1[2+OFFSET_ADDRESS_SIZE] == *p)
		{
                  /* If this group ever matched anything, then restore
                     what its registers were before trying this last
                     failed match, e.g., with `(a*)*b' against `ab' for
                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
                     against `aba' for regend[3].

                     Also restore the registers for inner groups for,
                     e.g., `((a*)(b*))*' against `aba' (register 3 would
                     otherwise get trashed).  */

                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
		    {
		      unsigned r;

                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;

		      /* Restore this and inner groups' (if any) registers.  */
                      for (r = *p; r < (unsigned) *p + (unsigned) *(p + 1);
			   r++)
                        {
                          regstart[r] = old_regstart[r];

                          /* xx why this test?  */
                          if (old_regend[r] >= regstart[r])
                            regend[r] = old_regend[r];
                        }
                    }
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);

                  goto fail;
                }
            }

          /* Move past the register number and the inner group count.  */
          p += 2;
          NEXT;


	/* \<digit> has been turned into a `duplicate' command which is
           followed by the numeric value of <digit> as the register number.  */
        CASE (duplicate):
	  {
	    register const CHAR_T *d2, *dend2;
	    int regno = *p++;   /* Get which register to match against.  */
	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);

	    /* Can't back reference a group which we've never matched.  */
            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
              goto fail;

            /* Where in input to try to start matching.  */
            d2 = regstart[regno];

            /* Where to stop matching; if both the place to start and
               the place to stop matching are in the same string, then
               set to the place to stop, otherwise, for now have to use
               the end of the first string.  */

            dend2 = ((FIRST_STRING_P (regstart[regno])
		      == FIRST_STRING_P (regend[regno]))
		     ? regend[regno] : end_match_1);
	    for (;;)
	      {
		/* If necessary, advance to next segment in register
                   contents.  */
		while (d2 == dend2)
		  {
		    if (dend2 == end_match_2) break;
		    if (dend2 == regend[regno]) break;

                    /* End of string1 => advance to string2. */
                    d2 = string2;
                    dend2 = regend[regno];
		  }
		/* At end of register contents => success */
		if (d2 == dend2) break;

		/* If necessary, advance to next segment in data.  */
		PREFETCH ();

		/* How many characters left in this segment to match.  */
		mcnt = dend - d;

		/* Want how many consecutive characters we can match in
                   one shot, so, if necessary, adjust the count.  */
                if (mcnt > dend2 - d2)
		  mcnt = dend2 - d2;

		/* Compare that many; failure if mismatch, else move
                   past them.  */
		if (translate
                    ? PREFIX(bcmp_translate) (d, d2, mcnt, translate)
                    : memcmp (d, d2, mcnt*sizeof(UCHAR_T)))
		  goto fail;
		d += mcnt, d2 += mcnt;

		/* Do this because we've match some characters.  */
		SET_REGS_MATCHED ();
	      }
	  }
	  NEXT;


        /* begline matches the empty string at the beginning of the string
           (unless `not_bol' is set in `bufp'), and, if
           `newline_anchor' is set, after newlines.  */
	CASE (begline):
          DEBUG_PRINT1 ("EXECUTING begline.\n");

          if (AT_STRINGS_BEG (d))
            {
              if (!bufp->not_bol)
		{
		  NEXT;
		}
            }
          else if (d[-1] == '\n' && bufp->newline_anchor)
            {
              NEXT;
            }
          /* In all other cases, we fail.  */
          goto fail;


        /* endline is the dual of begline.  */
	CASE (endline):
          DEBUG_PRINT1 ("EXECUTING endline.\n");

          if (AT_STRINGS_END (d))
            {
              if (!bufp->not_eol)
		{
		  NEXT;
		}
            }

          /* We have to ``prefetch'' the next character.  */
          else if ((d == end1 ? *string2 : *d) == '\n'
                   && bufp->newline_anchor)
            {
              NEXT;
            }
          goto fail;


	/* Match at the very beginning of the data.  */
        CASE (begbuf):
          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
          if (AT_STRINGS_BEG (d))
	    {
	      NEXT;
	    }
          goto fail;


	/* Match at the very end of the data.  */
        CASE (endbuf):
          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
	  if (AT_STRINGS_END (d))
	    {
	      NEXT;
	    }
          goto fail;


        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
           pushes NULL as the value for the string on the stack.  Then
           `pop_failure_point' will keep the current value for the
           string, instead of restoring it.  To see why, consider
           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
           then the . fails against the \n.  But the next thing we want
           to do is match the \n against the \n; if we restored the
           string value, we would be back at the foo.

           Because this is used only in specific cases, we don't need to
           check all the things that `on_failure_jump' does, to make
           sure the right things get saved on the stack.  Hence we don't
           share its code.  The only reason to push anything on the
           stack at all is that otherwise we would have to change
           `anychar's code to do something besides goto fail in this
           case; that seems worse than this.  */
        CASE (on_failure_keep_string_jump):
          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");

          EXTRACT_NUMBER_AND_INCR (mcnt, p);
#ifdef _LIBC
          DEBUG_PRINT3 (" %d (to %p):\n", mcnt, p + mcnt);
#else
          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
#endif

          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
          NEXT;


	/* Uses of on_failure_jump:

           Each alternative starts with an on_failure_jump that points
           to the beginning of the next alternative.  Each alternative
           except the last ends with a jump that in effect jumps past
           the rest of the alternatives.  (They really jump to the
           ending jump of the following alternative, because tensioning
           these jumps is a hassle.)

           Repeats start with an on_failure_jump that points past both
           the repetition text and either the following jump or
           pop_failure_jump back to this on_failure_jump.  */
	CASE (on_failure_jump):
        on_failure:
          DEBUG_PRINT1 ("EXECUTING on_failure_jump");

          EXTRACT_NUMBER_AND_INCR (mcnt, p);
#ifdef _LIBC
          DEBUG_PRINT3 (" %d (to %p)", mcnt, p + mcnt);
#else
          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
#endif

          /* If this on_failure_jump comes right before a group (i.e.,
             the original * applied to a group), save the information
             for that group and all inner ones, so that if we fail back
             to this point, the group's information will be correct.
             For example, in \(a*\)*\1, we need the preceding group,
             and in \(zz\(a*\)b*\)\2, we need the inner group.  */

          /* We can't use `p' to check ahead because we push
             a failure point to `p + mcnt' after we do this.  */
          p1 = p;

          /* We need to skip no_op's before we look for the
             start_memory in case this on_failure_jump is happening as
             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
             against aba.  */
          while (p1 < pend && (re_opcode_t) *p1 == no_op)
            p1++;

          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
            {
              /* We have a new highest active register now.  This will
                 get reset at the start_memory we are about to get to,
                 but we will have saved all the registers relevant to
                 this repetition op, as described above.  */
              highest_active_reg = *(p1 + 1) + *(p1 + 2);
              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
                lowest_active_reg = *(p1 + 1);
            }

          DEBUG_PRINT1 (":\n");
          PUSH_FAILURE_POINT (p + mcnt, d, -2);
          NEXT;


        /* A smart repeat ends with `maybe_pop_jump'.
	   We change it to either `pop_failure_jump' or `jump'.  */
        CASE (maybe_pop_jump):
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
          {
	    register UCHAR_T *p2 = p;

            /* Compare the beginning of the repeat with what in the
               pattern follows its end. If we can establish that there
               is nothing that they would both match, i.e., that we
               would have to backtrack because of (as in, e.g., `a*a')
               then we can change to pop_failure_jump, because we'll
               never have to backtrack.

               This is not true in the case of alternatives: in
               `(a|ab)*' we do need to backtrack to the `ab' alternative
               (e.g., if the string was `ab').  But instead of trying to
               detect that here, the alternative has put on a dummy
               failure point which is what we will end up popping.  */

	    /* Skip over open/close-group commands.
	       If what follows this loop is a ...+ construct,
	       look at what begins its body, since we will have to
	       match at least one of that.  */
	    while (1)
	      {
		if (p2 + 2 < pend
		    && ((re_opcode_t) *p2 == stop_memory
			|| (re_opcode_t) *p2 == start_memory))
		  p2 += 3;
		else if (p2 + 2 + 2 * OFFSET_ADDRESS_SIZE < pend
			 && (re_opcode_t) *p2 == dummy_failure_jump)
		  p2 += 2 + 2 * OFFSET_ADDRESS_SIZE;
		else
		  break;
	      }

	    p1 = p + mcnt;
	    /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
	       to the `maybe_finalize_jump' of this case.  Examine what
	       follows.  */

            /* If we're at the end of the pattern, we can change.  */
            if (p2 == pend)
	      {
		/* Consider what happens when matching ":\(.*\)"
		   against ":/".  I don't really understand this code
		   yet.  */
  	        p[-(1+OFFSET_ADDRESS_SIZE)] = (UCHAR_T)
		  pop_failure_jump;
                DEBUG_PRINT1
                  ("  End of pattern: change to `pop_failure_jump'.\n");
              }

            else if ((re_opcode_t) *p2 == exactn
#ifdef MBS_SUPPORT
		     || (re_opcode_t) *p2 == exactn_bin
#endif
		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
	      {
		register UCHAR_T c
                  = *p2 == (UCHAR_T) endline ? '\n' : p2[2];

                if (((re_opcode_t) p1[1+OFFSET_ADDRESS_SIZE] == exactn
#ifdef MBS_SUPPORT
		     || (re_opcode_t) p1[1+OFFSET_ADDRESS_SIZE] == exactn_bin
#endif
		    ) && p1[3+OFFSET_ADDRESS_SIZE] != c)
                  {
  		    p[-(1+OFFSET_ADDRESS_SIZE)] = (UCHAR_T)
		      pop_failure_jump;
#ifdef WCHAR
		      DEBUG_PRINT3 ("  %C != %C => pop_failure_jump.\n",
				    (wint_t) c,
				    (wint_t) p1[3+OFFSET_ADDRESS_SIZE]);
#else
		      DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
				    (char) c,
				    (char) p1[3+OFFSET_ADDRESS_SIZE]);
#endif
                  }

#ifndef WCHAR
		else if ((re_opcode_t) p1[3] == charset
			 || (re_opcode_t) p1[3] == charset_not)
		  {
		    int not = (re_opcode_t) p1[3] == charset_not;

		    if (c < (unsigned) (p1[4] * BYTEWIDTH)
			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
		      not = !not;

                    /* `not' is equal to 1 if c would match, which means
                        that we can't change to pop_failure_jump.  */
		    if (!not)
                      {
  		        p[-3] = (unsigned char) pop_failure_jump;
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
                      }
		  }
#endif /* not WCHAR */
	      }
#ifndef WCHAR
            else if ((re_opcode_t) *p2 == charset)
	      {
		/* We win if the first character of the loop is not part
                   of the charset.  */
                if ((re_opcode_t) p1[3] == exactn
 		    && ! ((int) p2[1] * BYTEWIDTH > (int) p1[5]
 			  && (p2[2 + p1[5] / BYTEWIDTH]
 			      & (1 << (p1[5] % BYTEWIDTH)))))
		  {
		    p[-3] = (unsigned char) pop_failure_jump;
		    DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
                  }

		else if ((re_opcode_t) p1[3] == charset_not)
		  {
		    int idx;
		    /* We win if the charset_not inside the loop
		       lists every character listed in the charset after.  */
		    for (idx = 0; idx < (int) p2[1]; idx++)
		      if (! (p2[2 + idx] == 0
			     || (idx < (int) p1[4]
				 && ((p2[2 + idx] & ~ p1[5 + idx]) == 0))))
			break;

		    if (idx == p2[1])
                      {
  		        p[-3] = (unsigned char) pop_failure_jump;
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
                      }
		  }
		else if ((re_opcode_t) p1[3] == charset)
		  {
		    int idx;
		    /* We win if the charset inside the loop
		       has no overlap with the one after the loop.  */
		    for (idx = 0;
			 idx < (int) p2[1] && idx < (int) p1[4];
			 idx++)
		      if ((p2[2 + idx] & p1[5 + idx]) != 0)
			break;

		    if (idx == p2[1] || idx == p1[4])
                      {
  		        p[-3] = (unsigned char) pop_failure_jump;
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
                      }
		  }
	      }
#endif /* not WCHAR */
	  }
	  p -= OFFSET_ADDRESS_SIZE;	/* Point at relative address again.  */
	  if ((re_opcode_t) p[-1] != pop_failure_jump)
	    {
	      p[-1] = (UCHAR_T) jump;
              DEBUG_PRINT1 ("  Match => jump.\n");
	      goto unconditional_jump;
	    }
        /* Note fall through.  */


	/* The end of a simple repeat has a pop_failure_jump back to
           its matching on_failure_jump, where the latter will push a
           failure point.  The pop_failure_jump takes off failure
           points put on by this pop_failure_jump's matching
           on_failure_jump; we got through the pattern to here from the
           matching on_failure_jump, so didn't fail.  */
        CASE (pop_failure_jump):
          {
            /* We need to pass separate storage for the lowest and
               highest registers, even though we don't care about the
               actual values.  Otherwise, we will restore only one
               register from the stack, since lowest will == highest in
               `pop_failure_point'.  */
            active_reg_t dummy_low_reg, dummy_high_reg;
            UCHAR_T *pdummy = NULL;
            const CHAR_T *sdummy = NULL;

            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
            POP_FAILURE_POINT (sdummy, pdummy,
                               dummy_low_reg, dummy_high_reg,
                               reg_dummy, reg_dummy, reg_info_dummy);
          }
	  /* Note fall through.  */

	unconditional_jump:
#ifdef _LIBC
	  DEBUG_PRINT2 ("\n%p: ", p);
#else
	  DEBUG_PRINT2 ("\n0x%x: ", p);
#endif
          /* Note fall through.  */

        /* Unconditionally jump (without popping any failure points).  */
        CASE (jump):
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
	  p += mcnt;				/* Do the jump.  */
#ifdef _LIBC
          DEBUG_PRINT2 ("(to %p).\n", p);
#else
          DEBUG_PRINT2 ("(to 0x%x).\n", p);
#endif
	  NEXT;


        /* We need this opcode so we can detect where alternatives end
           in `group_match_null_string_p' et al.  */
        CASE (jump_past_alt):
          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
          goto unconditional_jump;


        /* Normally, the on_failure_jump pushes a failure point, which
           then gets popped at pop_failure_jump.  We will end up at
           pop_failure_jump, also, and with a pattern of, say, `a+', we
           are skipping over the on_failure_jump, so we have to push
           something meaningless for pop_failure_jump to pop.  */
        CASE (dummy_failure_jump):
          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
          /* It doesn't matter what we push for the string here.  What
             the code at `fail' tests is the value for the pattern.  */
          PUSH_FAILURE_POINT (NULL, NULL, -2);
          goto unconditional_jump;


        /* At the end of an alternative, we need to push a dummy failure
           point in case we are followed by a `pop_failure_jump', because
           we don't want the failure point for the alternative to be
           popped.  For example, matching `(a|ab)*' against `aab'
           requires that we match the `ab' alternative.  */
        CASE (push_dummy_failure):
          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
          /* See comments just above at `dummy_failure_jump' about the
             two zeroes.  */
          PUSH_FAILURE_POINT (NULL, NULL, -2);
          NEXT;

        /* Have to succeed matching what follows at least n times.
           After that, handle like `on_failure_jump'.  */
        CASE (succeed_n):
          EXTRACT_NUMBER (mcnt, p + OFFSET_ADDRESS_SIZE);
          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);

          assert (mcnt >= 0);
          /* Originally, this is how many times we HAVE to succeed.  */
          if (mcnt > 0)
            {
               mcnt--;
	       p += OFFSET_ADDRESS_SIZE;
               STORE_NUMBER_AND_INCR (p, mcnt);
#ifdef _LIBC
               DEBUG_PRINT3 ("  Setting %p to %d.\n", p - OFFSET_ADDRESS_SIZE
			     , mcnt);
#else
               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p - OFFSET_ADDRESS_SIZE
			     , mcnt);
#endif
            }
	  else if (mcnt == 0)
            {
#ifdef _LIBC
              DEBUG_PRINT2 ("  Setting two bytes from %p to no_op.\n",
			    p + OFFSET_ADDRESS_SIZE);
#else
              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n",
			    p + OFFSET_ADDRESS_SIZE);
#endif /* _LIBC */

#ifdef WCHAR
	      p[1] = (UCHAR_T) no_op;
#else
	      p[2] = (UCHAR_T) no_op;
              p[3] = (UCHAR_T) no_op;
#endif /* WCHAR */
              goto on_failure;
            }
          NEXT;

        CASE (jump_n):
          EXTRACT_NUMBER (mcnt, p + OFFSET_ADDRESS_SIZE);
          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);

          /* Originally, this is how many times we CAN jump.  */
          if (mcnt)
            {
               mcnt--;
               STORE_NUMBER (p + OFFSET_ADDRESS_SIZE, mcnt);

#ifdef _LIBC
               DEBUG_PRINT3 ("  Setting %p to %d.\n", p + OFFSET_ADDRESS_SIZE,
			     mcnt);
#else
               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p + OFFSET_ADDRESS_SIZE,
			     mcnt);
#endif /* _LIBC */
	       goto unconditional_jump;
            }
          /* If don't have to jump any more, skip over the rest of command.  */
	  else
	    p += 2 * OFFSET_ADDRESS_SIZE;
          NEXT;

	CASE (set_number_at):
	  {
            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");

            EXTRACT_NUMBER_AND_INCR (mcnt, p);
            p1 = p + mcnt;
            EXTRACT_NUMBER_AND_INCR (mcnt, p);
#ifdef _LIBC
            DEBUG_PRINT3 ("  Setting %p to %d.\n", p1, mcnt);
#else
            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
#endif
	    STORE_NUMBER (p1, mcnt);
            NEXT;
          }

#if 0
	/* The DEC Alpha C compiler 3.x generates incorrect code for the
	   test  WORDCHAR_P (d - 1) != WORDCHAR_P (d)  in the expansion of
	   AT_WORD_BOUNDARY, so this code is disabled.  Expanding the
	   macro and introducing temporary variables works around the bug.  */

	CASE (wordbound):
	  DEBUG_PRINT1 ("EXECUTING wordbound.\n");
	  if (AT_WORD_BOUNDARY (d))
	    {
	      NEXT;
	    }
	  goto fail;

	CASE (notwordbound):
	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
	  if (AT_WORD_BOUNDARY (d))
	    goto fail;
	  NEXT;
#else
	CASE (wordbound):
	{
	  boolean prevchar, thischar;

	  DEBUG_PRINT1 ("EXECUTING wordbound.\n");
	  if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))
	    {
	      NEXT;
	    }

	  prevchar = WORDCHAR_P (d - 1);
	  thischar = WORDCHAR_P (d);
	  if (prevchar != thischar)
	    {
	      NEXT;
	    }
	  goto fail;
	}

      CASE (notwordbound):
	{
	  boolean prevchar, thischar;

	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
	  if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))
	    goto fail;

	  prevchar = WORDCHAR_P (d - 1);
	  thischar = WORDCHAR_P (d);
	  if (prevchar != thischar)
	    goto fail;
	  NEXT;
	}
#endif

	CASE (wordbeg):
          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
	  if (!AT_STRINGS_END (d) && WORDCHAR_P (d)
	      && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
	    {
	      NEXT;
	    }
          goto fail;

	CASE (wordend):
          DEBUG_PRINT1 ("EXECUTING wordend.\n");
	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
              && (AT_STRINGS_END (d) || !WORDCHAR_P (d)))
	    {
	      NEXT;
	    }
          goto fail;

#ifdef emacs
  	CASE (before_dot):
          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
  	    goto fail;
  	  NEXT;

  	CASE (at_dot):
          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
  	    goto fail;
  	  NEXT;

  	CASE (after_dot):
          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
  	    goto fail;
  	  NEXT;

	CASE (syntaxspec):
          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
	  mcnt = *p++;
	  goto matchsyntax;

        CASE (wordchar):
          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
	  mcnt = (int) Sword;
        matchsyntax:
	  PREFETCH ();
	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
	  d++;
	  if (SYNTAX (d[-1]) != (enum syntaxcode) mcnt)
	    goto fail;
          SET_REGS_MATCHED ();
	  NEXT;

	CASE (notsyntaxspec):
          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
	  mcnt = *p++;
	  goto matchnotsyntax;

        CASE (notwordchar):
          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
	  mcnt = (int) Sword;
        matchnotsyntax:
	  PREFETCH ();
	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
	  d++;
	  if (SYNTAX (d[-1]) == (enum syntaxcode) mcnt)
	    goto fail;
	  SET_REGS_MATCHED ();
          NEXT;

#else /* not emacs */
	CASE (wordchar):
          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
	  PREFETCH ();
          if (!WORDCHAR_P (d))
            goto fail;
	  SET_REGS_MATCHED ();
          d++;
	  NEXT;

	CASE (notwordchar):
          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
	  PREFETCH ();
	  if (WORDCHAR_P (d))
            goto fail;
          SET_REGS_MATCHED ();
          d++;
	  NEXT;
#endif /* not emacs */

#ifndef __GNUC__
        default:
          abort ();
	}
      continue;  /* Successfully executed one pattern command; keep going.  */
#endif


    /* We goto here if a matching operation fails. */
    fail:
      if (!FAIL_STACK_EMPTY ())
	{ /* A restart point is known.  Restore to that state.  */
          DEBUG_PRINT1 ("\nFAIL:\n");
          POP_FAILURE_POINT (d, p,
                             lowest_active_reg, highest_active_reg,
                             regstart, regend, reg_info);

          /* If this failure point is a dummy, try the next one.  */
          if (!p)
	    goto fail;

          /* If we failed to the end of the pattern, don't examine *p.  */
	  assert (p <= pend);
          if (p < pend)
            {
              boolean is_a_jump_n = false;

              /* If failed to a backwards jump that's part of a repetition
                 loop, need to pop this failure point and use the next one.  */
              switch ((re_opcode_t) *p)
                {
                case jump_n:
                  is_a_jump_n = true;
                case maybe_pop_jump:
                case pop_failure_jump:
                case jump:
                  p1 = p + 1;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  p1 += mcnt;

                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
                      || (!is_a_jump_n
                          && (re_opcode_t) *p1 == on_failure_jump))
                    goto fail;
                  break;
                default:
                  /* do nothing */ ;
                }
            }

          if (d >= string1 && d <= end1)
	    dend = end_match_1;
        }
      else
        break;   /* Matching at this starting point really fails.  */
    } /* for (;;) */

  if (best_regs_set)
    goto restore_best_regs;

  FREE_VARIABLES ();

  return -1;         			/* Failure to match.  */
} /* re_match_2 */

/* Subroutine definitions for re_match_2.  */


/* We are passed P pointing to a register number after a start_memory.

   Return true if the pattern up to the corresponding stop_memory can
   match the empty string, and false otherwise.

   If we find the matching stop_memory, sets P to point to one past its number.
   Otherwise, sets P to an undefined byte less than or equal to END.

   We don't handle duplicates properly (yet).  */

static boolean
PREFIX(group_match_null_string_p) (UCHAR_T **p, UCHAR_T *end,
				   PREFIX(register_info_type) *reg_info)
{
  int mcnt;
  /* Point to after the args to the start_memory.  */
  UCHAR_T *p1 = *p + 2;

  while (p1 < end)
    {
      /* Skip over opcodes that can match nothing, and return true or
	 false, as appropriate, when we get to one that can't, or to the
         matching stop_memory.  */

      switch ((re_opcode_t) *p1)
        {
        /* Could be either a loop or a series of alternatives.  */
        case on_failure_jump:
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);

          /* If the next operation is not a jump backwards in the
	     pattern.  */

	  if (mcnt >= 0)
	    {
              /* Go through the on_failure_jumps of the alternatives,
                 seeing if any of the alternatives cannot match nothing.
                 The last alternative starts with only a jump,
                 whereas the rest start with on_failure_jump and end
                 with a jump, e.g., here is the pattern for `a|b|c':

                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
                 /exactn/1/c

                 So, we have to first go through the first (n-1)
                 alternatives and then deal with the last one separately.  */


              /* Deal with the first (n-1) alternatives, which start
                 with an on_failure_jump (see above) that jumps to right
                 past a jump_past_alt.  */

              while ((re_opcode_t) p1[mcnt-(1+OFFSET_ADDRESS_SIZE)] ==
		     jump_past_alt)
                {
                  /* `mcnt' holds how many bytes long the alternative
                     is, including the ending `jump_past_alt' and
                     its number.  */

                  if (!PREFIX(alt_match_null_string_p) (p1, p1 + mcnt -
						(1 + OFFSET_ADDRESS_SIZE),
						reg_info))
                    return false;

                  /* Move to right after this alternative, including the
		     jump_past_alt.  */
                  p1 += mcnt;

                  /* Break if it's the beginning of an n-th alternative
                     that doesn't begin with an on_failure_jump.  */
                  if ((re_opcode_t) *p1 != on_failure_jump)
                    break;

		  /* Still have to check that it's not an n-th
		     alternative that starts with an on_failure_jump.  */
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  if ((re_opcode_t) p1[mcnt-(1+OFFSET_ADDRESS_SIZE)] !=
		      jump_past_alt)
                    {
		      /* Get to the beginning of the n-th alternative.  */
                      p1 -= 1 + OFFSET_ADDRESS_SIZE;
                      break;
                    }
                }

              /* Deal with the last alternative: go back and get number
                 of the `jump_past_alt' just before it.  `mcnt' contains
                 the length of the alternative.  */
              EXTRACT_NUMBER (mcnt, p1 - OFFSET_ADDRESS_SIZE);

              if (!PREFIX(alt_match_null_string_p) (p1, p1 + mcnt, reg_info))
                return false;

              p1 += mcnt;	/* Get past the n-th alternative.  */
            } /* if mcnt > 0 */
          break;


        case stop_memory:
	  assert (p1[1] == **p);
          *p = p1 + 2;
          return true;


        default:
          if (!PREFIX(common_op_match_null_string_p) (&p1, end, reg_info))
            return false;
        }
    } /* while p1 < end */

  return false;
} /* group_match_null_string_p */


/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
   It expects P to be the first byte of a single alternative and END one
   byte past the last. The alternative can contain groups.  */

static boolean
PREFIX(alt_match_null_string_p) (UCHAR_T *p, UCHAR_T *end,
				 PREFIX(register_info_type) *reg_info)
{
  int mcnt;
  UCHAR_T *p1 = p;

  while (p1 < end)
    {
      /* Skip over opcodes that can match nothing, and break when we get
         to one that can't.  */

      switch ((re_opcode_t) *p1)
        {
	/* It's a loop.  */
        case on_failure_jump:
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
          break;

	default:
          if (!PREFIX(common_op_match_null_string_p) (&p1, end, reg_info))
            return false;
        }
    }  /* while p1 < end */

  return true;
} /* alt_match_null_string_p */


/* Deals with the ops common to group_match_null_string_p and
   alt_match_null_string_p.

   Sets P to one after the op and its arguments, if any.  */

static boolean
PREFIX(common_op_match_null_string_p) (UCHAR_T **p, UCHAR_T *end,
				       PREFIX(register_info_type) *reg_info)
{
  int mcnt;
  boolean ret;
  int reg_no;
  UCHAR_T *p1 = *p;

  switch ((re_opcode_t) *p1++)
    {
    case no_op:
    case begline:
    case endline:
    case begbuf:
    case endbuf:
    case wordbeg:
    case wordend:
    case wordbound:
    case notwordbound:
#ifdef emacs
    case before_dot:
    case at_dot:
    case after_dot:
#endif
      break;

    case start_memory:
      reg_no = *p1;
      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
      ret = PREFIX(group_match_null_string_p) (&p1, end, reg_info);

      /* Have to set this here in case we're checking a group which
         contains a group and a back reference to it.  */

      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;

      if (!ret)
        return false;
      break;

    /* If this is an optimized succeed_n for zero times, make the jump.  */
    case jump:
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
      if (mcnt >= 0)
        p1 += mcnt;
      else
        return false;
      break;

    case succeed_n:
      /* Get to the number of times to succeed.  */
      p1 += OFFSET_ADDRESS_SIZE;
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);

      if (mcnt == 0)
        {
          p1 -= 2 * OFFSET_ADDRESS_SIZE;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
        }
      else
        return false;
      break;

    case duplicate:
      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
        return false;
      break;

    case set_number_at:
      p1 += 2 * OFFSET_ADDRESS_SIZE;

    default:
      /* All other opcodes mean we cannot match the empty string.  */
      return false;
  }

  *p = p1;
  return true;
} /* common_op_match_null_string_p */


/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
   bytes; nonzero otherwise.  */

static int
PREFIX(bcmp_translate) (const CHAR_T *s1, const CHAR_T *s2,
			register int len,
			RE_TRANSLATE_TYPE translate)
{
  register const UCHAR_T *p1 = (const UCHAR_T *) s1;
  register const UCHAR_T *p2 = (const UCHAR_T *) s2;
  while (len)
    {
#ifdef WCHAR
      if (((*p1<=0xff)?translate[*p1++]:*p1++)
	  != ((*p2<=0xff)?translate[*p2++]:*p2++))
	return 1;
#else /* BYTE */
      if (translate[*p1++] != translate[*p2++]) return 1;
#endif /* WCHAR */
      len--;
    }
  return 0;
}


#else /* not INSIDE_RECURSION */

/* Entry points for GNU code.  */

/* re_compile_pattern is the GNU regular expression compiler: it
   compiles PATTERN (of length SIZE) and puts the result in BUFP.
   Returns 0 if the pattern was valid, otherwise an error string.

   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
   are set in BUFP on entry.

   We call regex_compile to do the actual compilation.  */

const char *
re_compile_pattern (const char *pattern,
		    size_t length,
		    struct re_pattern_buffer *bufp)
{
  reg_errcode_t ret;

  /* GNU code is written to assume at least RE_NREGS registers will be set
     (and at least one extra will be -1).  */
  bufp->regs_allocated = REGS_UNALLOCATED;

  /* And GNU code determines whether or not to get register information
     by passing null for the REGS argument to re_match, etc., not by
     setting no_sub.  */
  bufp->no_sub = 0;

  /* Match anchors at newline.  */
  bufp->newline_anchor = 1;

# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    ret = wcs_regex_compile (pattern, length, re_syntax_options, bufp);
  else
# endif
    ret = byte_regex_compile (pattern, length, re_syntax_options, bufp);

  if (!ret)
    return NULL;
  return gettext (re_error_msgid + re_error_msgid_idx[(int) ret]);
}
#ifdef _LIBC
weak_alias (__re_compile_pattern, re_compile_pattern)
#endif

/* Entry points compatible with 4.2 BSD regex library.  We don't define
   them unless specifically requested.  */

#if defined _REGEX_RE_COMP || defined _LIBC

/* BSD has one and only one pattern buffer.  */
static struct re_pattern_buffer re_comp_buf;

char *
#ifdef _LIBC
/* Make these definitions weak in libc, so POSIX programs can redefine
   these names if they don't use our functions, and still use
   regcomp/regexec below without link errors.  */
weak_function
#endif
re_comp (const char *s)
{
  reg_errcode_t ret;

  if (!s)
    {
      if (!re_comp_buf.buffer)
	return (char *) gettext ("No previous regular expression");
      return 0;
    }

  if (!re_comp_buf.buffer)
    {
      re_comp_buf.buffer = malloc (200);
      if (re_comp_buf.buffer == NULL)
        return (char *) gettext (re_error_msgid
				 + re_error_msgid_idx[(int) REG_ESPACE]);
      re_comp_buf.allocated = 200;

      re_comp_buf.fastmap = malloc (1 << BYTEWIDTH);
      if (re_comp_buf.fastmap == NULL)
	return (char *) gettext (re_error_msgid
				 + re_error_msgid_idx[(int) REG_ESPACE]);
    }

  /* Since `re_exec' always passes NULL for the `regs' argument, we
     don't need to initialize the pattern buffer fields which affect it.  */

  /* Match anchors at newlines.  */
  re_comp_buf.newline_anchor = 1;

# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    ret = wcs_regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
  else
# endif
    ret = byte_regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);

  if (!ret)
    return NULL;

  /* Yes, we're discarding `const' here if !HAVE_LIBINTL.  */
  return (char *) gettext (re_error_msgid + re_error_msgid_idx[(int) ret]);
}


int
#ifdef _LIBC
weak_function
#endif
re_exec (const char *s)
{
  const int len = strlen (s);
  return
    0 <= re_search (&re_comp_buf, s, len, 0, len, 0);
}

#endif /* _REGEX_RE_COMP */

/* POSIX.2 functions.  Don't define these for Emacs.  */

#ifndef emacs

/* regcomp takes a regular expression as a string and compiles it.

   PREG is a regex_t *.  We do not expect any fields to be initialized,
   since POSIX says we shouldn't.  Thus, we set

     `buffer' to the compiled pattern;
     `used' to the length of the compiled pattern;
     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
       REG_EXTENDED bit in CFLAGS is set; otherwise, to
       RE_SYNTAX_POSIX_BASIC;
     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
     `fastmap' to an allocated space for the fastmap;
     `fastmap_accurate' to zero;
     `re_nsub' to the number of subexpressions in PATTERN.

   PATTERN is the address of the pattern string.

   CFLAGS is a series of bits which affect compilation.

     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
     use POSIX basic syntax.

     If REG_NEWLINE is set, then . and [^...] don't match newline.
     Also, regexec will try a match beginning after every newline.

     If REG_ICASE is set, then we considers upper- and lowercase
     versions of letters to be equivalent when matching.

     If REG_NOSUB is set, then when PREG is passed to regexec, that
     routine will report only success or failure, and nothing about the
     registers.

   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
   the return codes and their meanings.)  */

int
regcomp (regex_t *preg, const char *pattern, int cflags)
{
  reg_errcode_t ret;
  reg_syntax_t syntax
    = (cflags & REG_EXTENDED) ?
      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;

  /* regex_compile will allocate the space for the compiled pattern.  */
  preg->buffer = 0;
  preg->allocated = 0;
  preg->used = 0;

  /* Try to allocate space for the fastmap.  */
  preg->fastmap = malloc (1 << BYTEWIDTH);

  if (cflags & REG_ICASE)
    {
      unsigned i;

      preg->translate = malloc (CHAR_SET_SIZE
				* sizeof (*(RE_TRANSLATE_TYPE)0));
      if (preg->translate == NULL)
        return (int) REG_ESPACE;

      /* Map uppercase characters to corresponding lowercase ones.  */
      for (i = 0; i < CHAR_SET_SIZE; i++)
        preg->translate[i] = ISUPPER (i) ? TOLOWER (i) : i;
    }
  else
    preg->translate = NULL;

  /* If REG_NEWLINE is set, newlines are treated differently.  */
  if (cflags & REG_NEWLINE)
    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
      syntax &= ~RE_DOT_NEWLINE;
      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
      /* It also changes the matching behavior.  */
      preg->newline_anchor = 1;
    }
  else
    preg->newline_anchor = 0;

  preg->no_sub = !!(cflags & REG_NOSUB);

  /* POSIX says a null character in the pattern terminates it, so we
     can use strlen here in compiling the pattern.  */
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    ret = wcs_regex_compile (pattern, strlen (pattern), syntax, preg);
  else
# endif
    ret = byte_regex_compile (pattern, strlen (pattern), syntax, preg);

  /* POSIX doesn't distinguish between an unmatched open-group and an
     unmatched close-group: both are REG_EPAREN.  */
  if (ret == REG_ERPAREN) ret = REG_EPAREN;

  if (ret == REG_NOERROR && preg->fastmap)
    {
      /* Compute the fastmap now, since regexec cannot modify the pattern
	 buffer.  */
      if (re_compile_fastmap (preg) == -2)
	{
	  /* Some error occurred while computing the fastmap, just forget
	     about it.  */
	  free (preg->fastmap);
	  preg->fastmap = NULL;
	}
    }

  return (int) ret;
}
#ifdef _LIBC
weak_alias (__regcomp, regcomp)
#endif


/* regexec searches for a given pattern, specified by PREG, in the
   string STRING.

   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
   least NMATCH elements, and we set them to the offsets of the
   corresponding matched substrings.

   EFLAGS specifies `execution flags' which affect matching: if
   REG_NOTBOL is set, then ^ does not match at the beginning of the
   string; if REG_NOTEOL is set, then $ does not match at the end.

   We return 0 if we find a match and REG_NOMATCH if not.  */

int
regexec (const regex_t *preg, const char *string,
	 size_t nmatch, regmatch_t pmatch[], int eflags)
{
  int ret;
  struct re_registers regs;
  regex_t private_preg;
  int len = strlen (string);
  boolean want_reg_info = !preg->no_sub && nmatch > 0;

  private_preg = *preg;

  private_preg.not_bol = !!(eflags & REG_NOTBOL);
  private_preg.not_eol = !!(eflags & REG_NOTEOL);

  /* The user has told us exactly how many registers to return
     information about, via `nmatch'.  We have to pass that on to the
     matching routines.  */
  private_preg.regs_allocated = REGS_FIXED;

  if (want_reg_info)
    {
      regs.num_regs = nmatch;
      regs.start = TALLOC (nmatch * 2, regoff_t);
      if (regs.start == NULL)
        return (int) REG_NOMATCH;
      regs.end = regs.start + nmatch;
    }

  /* Perform the searching operation.  */
  ret = re_search (&private_preg, string, len,
                   /* start: */ 0, /* range: */ len,
                   want_reg_info ? &regs : 0);

  /* Copy the register information to the POSIX structure.  */
  if (want_reg_info)
    {
      if (ret >= 0)
        {
          unsigned r;

          for (r = 0; r < nmatch; r++)
            {
              pmatch[r].rm_so = regs.start[r];
              pmatch[r].rm_eo = regs.end[r];
            }
        }

      /* If we needed the temporary register info, free the space now.  */
      free (regs.start);
    }

  /* We want zero return to mean success, unlike `re_search'.  */
  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
}
#ifdef _LIBC
weak_alias (__regexec, regexec)
#endif


/* Returns a message corresponding to an error code, ERRCODE, returned
   from either regcomp or regexec.   We don't use PREG here.  */

size_t
regerror (int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size)
{
  const char *msg;
  size_t msg_size;

  if (errcode < 0
      || errcode >= (int) (sizeof (re_error_msgid_idx)
			   / sizeof (re_error_msgid_idx[0])))
    /* Only error codes returned by the rest of the code should be passed
       to this routine.  If we are given anything else, or if other regex
       code generates an invalid error code, then the program has a bug.
       Dump core so we can fix it.  */
    abort ();

  msg = gettext (re_error_msgid + re_error_msgid_idx[errcode]);

  msg_size = strlen (msg) + 1; /* Includes the null.  */

  if (errbuf_size != 0)
    {
      if (msg_size > errbuf_size)
        {
#if defined HAVE_MEMPCPY || defined _LIBC
	  *((char *) __mempcpy (errbuf, msg, errbuf_size - 1)) = '\0';
#else
          memcpy (errbuf, msg, errbuf_size - 1);
          errbuf[errbuf_size - 1] = 0;
#endif
        }
      else
        memcpy (errbuf, msg, msg_size);
    }

  return msg_size;
}
#ifdef _LIBC
weak_alias (__regerror, regerror)
#endif


/* Free dynamically allocated space used by PREG.  */

void
regfree (regex_t *preg)
{
  if (preg->buffer != NULL)
    free (preg->buffer);
  preg->buffer = NULL;

  preg->allocated = 0;
  preg->used = 0;

  if (preg->fastmap != NULL)
    free (preg->fastmap);
  preg->fastmap = NULL;
  preg->fastmap_accurate = 0;

  if (preg->translate != NULL)
    free (preg->translate);
  preg->translate = NULL;
}
#ifdef _LIBC
weak_alias (__regfree, regfree)
#endif

#endif /* not emacs  */

#endif /* not INSIDE_RECURSION */


#undef STORE_NUMBER
#undef STORE_NUMBER_AND_INCR
#undef EXTRACT_NUMBER
#undef EXTRACT_NUMBER_AND_INCR

#undef DEBUG_PRINT_COMPILED_PATTERN
#undef DEBUG_PRINT_DOUBLE_STRING

#undef INIT_FAIL_STACK
#undef RESET_FAIL_STACK
#undef DOUBLE_FAIL_STACK
#undef PUSH_PATTERN_OP
#undef PUSH_FAILURE_POINTER
#undef PUSH_FAILURE_INT
#undef PUSH_FAILURE_ELT
#undef POP_FAILURE_POINTER
#undef POP_FAILURE_INT
#undef POP_FAILURE_ELT
#undef DEBUG_PUSH
#undef DEBUG_POP
#undef PUSH_FAILURE_POINT
#undef POP_FAILURE_POINT

#undef REG_UNSET_VALUE
#undef REG_UNSET

#undef PATFETCH
#undef PATFETCH_RAW
#undef PATUNFETCH
#undef TRANSLATE

#undef INIT_BUF_SIZE
#undef GET_BUFFER_SPACE
#undef BUF_PUSH
#undef BUF_PUSH_2
#undef BUF_PUSH_3
#undef STORE_JUMP
#undef STORE_JUMP2
#undef INSERT_JUMP
#undef INSERT_JUMP2
#undef EXTEND_BUFFER
#undef GET_UNSIGNED_NUMBER
#undef FREE_STACK_RETURN

# undef POINTER_TO_OFFSET
# undef MATCHING_IN_FRST_STRING
# undef PREFETCH
# undef AT_STRINGS_BEG
# undef AT_STRINGS_END
# undef WORDCHAR_P
# undef FREE_VAR
# undef FREE_VARIABLES
# undef NO_HIGHEST_ACTIVE_REG
# undef NO_LOWEST_ACTIVE_REG

# undef CHAR_T
# undef UCHAR_T
# undef COMPILED_BUFFER_VAR
# undef OFFSET_ADDRESS_SIZE
# undef CHAR_CLASS_SIZE
# undef PREFIX
# undef ARG_PREFIX
# undef PUT_CHAR
# undef BYTE
# undef WCHAR

# define DEFINED_ONCE
@


1.3
log
@cvs-1.11.12 doesn't do the joints correctly (what were the
FSF people smoking?), it memory faults.
thusly revert to 1.11.1p1

tested.
agreed bsiegert@@
@
text
@d1 3
a3 2
/* Extended regular expression matching and search library, version
   0.12.  (Implements POSIX draft P10003.2/D11.2, except for
d6 2
a7 1
   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
d16 1
a16 1
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
d19 3
a21 4
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
   USA.	 */
d24 1
a24 1
#if defined (_AIX) && !defined (REGEX_MALLOC)
d31 2
a32 8
#ifdef emacs
/* Converts the pointer to the char to BEG-based offset from the start.	 */
#define PTR_TO_OFFSET(d)						\
	POS_AS_IN_BUFFER (MATCHING_IN_FIRST_STRING			\
			  ? (d) - string1 : (d) - (string2 - size1))
#define POS_AS_IN_BUFFER(p) ((p) + (NILP (re_match_object) || BUFFERP (re_match_object)))
#else
#define PTR_TO_OFFSET(d) 0
d35 1
a35 3
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
d37 1
a37 2
/* We need this for `regex.h', and perhaps for the Emacs include files.	 */
#include <sys/types.h>
d39 1
a39 6
/* This is for other GNU distributions with internationalized messages.	 */
#if HAVE_LIBINTL_H || defined (_LIBC)
# include <libintl.h>
#else
# define gettext(msgid) (msgid)
#endif
d41 61
a101 5
#ifndef gettext_noop
/* This define is so xgettext can find the internationalizable
   strings.  */
#define gettext_noop(String) String
#endif
d105 1
a105 11
#ifdef emacs

#include "lisp.h"
#include "buffer.h"

/* Make syntax table lookup grant data in gl_state.  */
#define SYNTAX_ENTRY_VIA_PROPERTY

#include "syntax.h"
#include "charset.h"
#include "category.h"
d107 3
a109 3
#define malloc xmalloc
#define realloc xrealloc
#define free xfree
d111 1
a111 1
#else  /* not emacs */
d116 1
a116 1
#undef REL_ALLOC
d118 1
a118 6
#if defined (STDC_HEADERS) || defined (_LIBC)
#include <stdlib.h>
#else
char *malloc ();
char *realloc ();
#endif
d121 8
a128 8
   If nothing else has been done, use the method below.	 */
#ifdef INHIBIT_STRING_HEADER
#if !(defined (HAVE_BZERO) && defined (HAVE_BCOPY))
#if !defined (bzero) && !defined (bcopy)
#undef INHIBIT_STRING_HEADER
#endif
#endif
#endif
d133 10
a142 16
#ifndef INHIBIT_STRING_HEADER
#if defined (HAVE_STRING_H) || defined (STDC_HEADERS) || defined (_LIBC)
#include <string.h>
#ifndef bcmp
#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
#endif
#ifndef bcopy
#define bcopy(s, d, n)	memcpy ((d), (s), (n))
#endif
#ifndef bzero
#define bzero(s, n)	memset ((s), 0, (n))
#endif
#else
#include <strings.h>
#endif
#endif
d148 35
a182 3
#ifndef Sword
#define Sword 1
#endif
d184 38
a221 5
#ifdef SWITCH_ENUM_BUG
#define SWITCH_ENUM_CAST(x) ((int)(x))
#else
#define SWITCH_ENUM_CAST(x) (x)
#endif
d223 1
a223 1
#ifdef SYNTAX_TABLE
d227 1
a227 4
#else /* not SYNTAX_TABLE */

/* How many characters in the character set.  */
#define CHAR_SET_SIZE 256
d232 1
a232 1
init_syntax_once ()
a238 1

d241 3
a243 8
   for (c = 'a'; c <= 'z'; c++)
     re_syntax_table[c] = Sword;

   for (c = 'A'; c <= 'Z'; c++)
     re_syntax_table[c] = Sword;

   for (c = '0'; c <= '9'; c++)
     re_syntax_table[c] = Sword;
d250 1
a250 41
#endif /* not SYNTAX_TABLE */

#define SYNTAX(c) re_syntax_table[c]

/* Dummy macros for non-Emacs environments.  */
#define BASE_LEADING_CODE_P(c) (0)
#define WORD_BOUNDARY_P(c1, c2) (0)
#define CHAR_HEAD_P(p) (1)
#define SINGLE_BYTE_CHAR_P(c) (1)
#define SAME_CHARSET_P(c1, c2) (1)
#define MULTIBYTE_FORM_LENGTH(p, s) (1)
#define STRING_CHAR(p, s) (*(p))
#define STRING_CHAR_AND_LENGTH(p, s, actual_len) ((actual_len) = 1, *(p))
#define GET_CHAR_AFTER_2(c, p, str1, end1, str2, end2) \
  (c = ((p) == (end1) ? *(str2) : *(p)))
#define GET_CHAR_BEFORE_2(c, p, str1, end1, str2, end2) \
  (c = ((p) == (str2) ? *((end1) - 1) : *((p) - 1)))
#endif /* not emacs */

/* Get the interface, including the syntax bits.  */
#include "regex.h"

/* isalpha etc. are used for the character classes.  */
#include <ctype.h>

/* Jim Meyering writes:

   "... Some ctype macros are valid only for character codes that
   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
   using /bin/cc or gcc but without giving an ansi option).  So, all
   ctype uses should be through macros like ISPRINT...	If
   STDC_HEADERS is defined, then autoconf has verified that the ctype
   macros don't need to be guarded with references to isascii. ...
   Defining isascii to 1 should let any compiler worth its salt
   eliminate the && through constant folding."	*/

#if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
#define ISASCII(c) 1
#else
#define ISASCII(c) isascii(c)
#endif
d252 1
a252 10
#ifdef isblank
#define ISBLANK(c) (ISASCII (c) && isblank (c))
#else
#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
#endif
#ifdef isgraph
#define ISGRAPH(c) (ISASCII (c) && isgraph (c))
#else
#define ISGRAPH(c) (ISASCII (c) && isprint (c) && !isspace (c))
#endif
d254 1
a254 26
#define ISPRINT(c) (ISASCII (c) && isprint (c))
#define ISDIGIT(c) (ISASCII (c) && isdigit (c))
#define ISALNUM(c) (ISASCII (c) && isalnum (c))
#define ISALPHA(c) (ISASCII (c) && isalpha (c))
#define ISCNTRL(c) (ISASCII (c) && iscntrl (c))
#define ISLOWER(c) (ISASCII (c) && islower (c))
#define ISPUNCT(c) (ISASCII (c) && ispunct (c))
#define ISSPACE(c) (ISASCII (c) && isspace (c))
#define ISUPPER(c) (ISASCII (c) && isupper (c))
#define ISXDIGIT(c) (ISASCII (c) && isxdigit (c))

#ifndef NULL
#define NULL (void *)0
#endif

/* We remove any previous definition of `SIGN_EXTEND_CHAR',
   since ours (we hope) works properly with all combinations of
   machines, compilers, `char' and `unsigned char' argument types.
   (Per Bothner suggested the basic approach.)	*/
#undef SIGN_EXTEND_CHAR
#if __STDC__
#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
#else  /* not __STDC__ */
/* As in Harbison and Steele.  */
#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
#endif
d266 1
a266 1
#ifdef REGEX_MALLOC
d268 3
a270 3
#define REGEX_ALLOCATE malloc
#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
#define REGEX_FREE free
d272 1
a272 1
#else /* not REGEX_MALLOC  */
d275 1
a275 1
#ifndef alloca
d278 1
a278 13
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not __GNUC__ */
#if HAVE_ALLOCA_H
#include <alloca.h>
#else /* not __GNUC__ or HAVE_ALLOCA_H */
#if 0 /* It is a bad idea to declare alloca.  We always cast the result.  */
#ifndef _AIX /* Already did AIX, up at the top.	 */
char *alloca ();
#endif /* not _AIX */
#endif
#endif /* not HAVE_ALLOCA_H */
#endif /* not __GNUC__ */
d280 1
a280 1
#endif /* not alloca */
d282 1
a282 1
#define REGEX_ALLOCATE alloca
d285 1
a285 1
#define REGEX_REALLOCATE(source, osize, nsize)				\
d287 1
a287 2
   bcopy (source, destination, osize),					\
   destination)
d290 1
a290 1
#define REGEX_FREE(arg) ((void)0) /* Do nothing!  But inhibit gcc warning.  */
d292 1
a292 1
#endif /* not REGEX_MALLOC */
d296 1
a296 1
#if defined (REL_ALLOC) && defined (REGEX_MALLOC)
d298 1
a298 1
#define REGEX_ALLOCATE_STACK(size)				\
d300 1
a300 1
#define REGEX_REALLOCATE_STACK(source, osize, nsize)		\
d302 1
a302 1
#define REGEX_FREE_STACK(ptr)					\
d305 1
a305 1
#else /* not using relocating allocator */
d307 1
a307 1
#ifdef REGEX_MALLOC
d309 3
a311 3
#define REGEX_ALLOCATE_STACK malloc
#define REGEX_REALLOCATE_STACK(source, osize, nsize) realloc (source, nsize)
#define REGEX_FREE_STACK free
d313 1
a313 1
#else /* not REGEX_MALLOC */
d315 1
a315 1
#define REGEX_ALLOCATE_STACK alloca
d317 1
a317 1
#define REGEX_REALLOCATE_STACK(source, osize, nsize)			\
d319 2
a320 2
/* No need to explicitly free anything.	 */
#define REGEX_FREE_STACK(arg)
d322 2
a323 2
#endif /* not REGEX_MALLOC */
#endif /* not using relocating allocator */
d329 1
a329 1
#define FIRST_STRING_P(ptr)					\
d333 3
a335 3
#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
#define RETALLOC_IF(addr, n, t) \
d337 1
a337 1
#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
d339 1
a339 1
#define BYTEWIDTH 8 /* In bits.	 */
d341 1
a341 1
#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
d343 4
a346 4
#undef MAX
#undef MIN
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
d349 2
a350 2
#define false 0
#define true 1
d352 39
a390 1
static int re_match_2_internal ();
d393 1
a393 1
   expressions.	 Some opcodes are followed by argument bytes.  A
d401 1
a401 1
  /* Succeed right away--no more backtracking.	*/
d404 1
a404 1
	/* Followed by one byte giving n, then by n literal bytes.  */
d407 6
a412 1
	/* Matches any (more or less) character.  */
d415 13
a427 6
	/* Matches any one char belonging to specified set.  First
	   following byte is number of bitmap bytes.  Then come bytes
	   for a bitmap saying which chars are in.  Bits in each byte
	   are ordered low-bit-first.  A character is in the set if its
	   bit is 1.  A character too large to have a bit in the map is
	   automatically not in the set.  */
d430 2
a431 2
	/* Same parameters as charset, but match any character that is
	   not one of those specified.	*/
d434 7
a440 7
	/* Start remembering the text that is matched, for storing in a
	   register.  Followed by one byte with the register number, in
	   the range 0 to one less than the pattern buffer's re_nsub
	   field.  Then followed by one byte with the number of groups
	   inner to this one.  (This last has to be part of the
	   start_memory only because we need it in the on_failure_jump
	   of re_match_2.)  */
d443 7
a449 7
	/* Stop remembering the text that is matched and store it in a
	   memory register.  Followed by one byte with the register
	   number, in the range 0 to one less than `re_nsub' in the
	   pattern buffer, and one byte with the number of inner groups,
	   just like `start_memory'.  (We need the number of inner
	   groups here because we don't have any easy way of finding the
	   corresponding start_memory when we're at a stop_memory.)  */
d452 2
a453 2
	/* Match a duplicate of something remembered. Followed by one
	   byte containing the register number.	 */
d456 1
a456 1
	/* Fail unless at beginning of line.  */
d459 1
a459 1
	/* Fail unless at end of line.	*/
d462 2
a463 2
	/* Succeeds if at beginning of buffer (if emacs) or at beginning
	   of string to be matched (if not).  */
d466 1
a466 1
	/* Analogously, for end of buffer/string.  */
d469 1
a469 1
	/* Followed by two byte relative address to which to jump.  */
d475 3
a477 2
	/* Followed by two-byte relative address of place to resume at
	   in case of failure.	*/
d480 2
a481 2
	/* Like on_failure_jump, but pushes a placeholder instead of the
	   current string position when executed.  */
d484 3
a486 2
	/* Throw away latest failure point and then jump to following
	   two-byte relative address.  */
d489 8
a496 7
	/* Change to pop_failure_jump if know won't have to backtrack to
	   match; otherwise change to jump.  This is used to jump
	   back to the beginning of a repeat.  If what follows this jump
	   clearly won't match what the repeat does, such that we can be
	   sure that there is no use backtracking out of repetitions
	   already matched, then we change it to a pop_failure_jump.
	   Followed by two-byte address.  */
d499 6
a504 5
	/* Jump to following two-byte address, and push a dummy failure
	   point. This failure point will be thrown away if an attempt
	   is made to use it for a failure.  A `+' construct makes this
	   before the first repeat.  Also used as an intermediary kind
	   of jump when compiling an alternative.  */
d511 3
a513 2
	/* Followed by two-byte relative address and two-byte number n.
	   After matching N times, jump to the address upon failure.  */
d516 3
a518 2
	/* Followed by two-byte relative address, and two-byte number n.
	   Jump to the address N times, then fail.  */
d521 4
a524 3
	/* Set the following two-byte relative address to the
	   subsequent two-byte number.	The address *includes* the two
	   bytes of number.  */
d534 1
a534 1
  notwordbound	/* Succeeds if not at a word boundary.	*/
d536 1
a536 1
#ifdef emacs
d542 1
a542 1
	   a byte which contains a syntax code, e.g., Sword.  */
d546 2
a547 12
  notsyntaxspec,

  /* Matches any character whose category-set contains the specified
     category.	The operator is followed by a byte which contains a
     category code (mnemonic ASCII character).	*/
  categoryspec,

  /* Matches any character whose category-set does not contain the
     specified category.  The operator is followed by a byte which
     contains the category code (mnemonic ASCII character).  */
  notcategoryspec
#endif /* emacs */
d549 1
d551 41
d595 1
d597 7
a603 1
#define STORE_NUMBER(destination, number)				\
d608 1
d613 1
d615 1
a615 1
#define STORE_NUMBER_AND_INCR(destination, number)			\
d618 1
a618 1
    (destination) += 2;							\
d623 1
d625 7
a631 1
#define EXTRACT_NUMBER(destination, source)				\
d634 1
a634 1
    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
d636 1
d638 1
a638 1
#ifdef DEBUG
d640 1
a640 3
extract_number (dest, source)
    int *dest;
    unsigned char *source;
d642 4
a645 1
  int temp = SIGN_EXTEND_CHAR (*(source + 1));
d648 1
d651 4
a654 4
#ifndef EXTRACT_MACROS /* To debug the macros.	*/
#undef EXTRACT_NUMBER
#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
#endif /* not EXTRACT_MACROS */
d656 1
a656 1
#endif /* DEBUG */
d661 1
a661 1
#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
d664 1
a664 1
    (source) += 2;							\
d667 1
a667 1
#ifdef DEBUG
d669 1
a669 3
extract_number_and_incr (destination, source)
    int *destination;
    unsigned char **source;
d671 2
a672 2
  extract_number (destination, *source);
  *source += 2;
d675 7
a681 5
#ifndef EXTRACT_MACROS
#undef EXTRACT_NUMBER_AND_INCR
#define EXTRACT_NUMBER_AND_INCR(dest, src) \
  extract_number_and_incr (&dest, &src)
#endif /* not EXTRACT_MACROS */
a682 1
#endif /* DEBUG */
a683 14
/* Store a multibyte character in three contiguous bytes starting
   DESTINATION, and increment DESTINATION to the byte after where the
   character is stored.	 Therefore, DESTINATION must be an lvalue.  */

#define STORE_CHARACTER_AND_INCR(destination, character)	\
  do {								\
    (destination)[0] = (character) & 0377;			\
    (destination)[1] = ((character) >> 8) & 0377;		\
    (destination)[2] = (character) >> 16;			\
    (destination) += 3;						\
  } while (0)

/* Put into DESTINATION a character stored in three contiguous bytes
   starting at SOURCE.	*/
a684 72
#define EXTRACT_CHARACTER(destination, source)	\
  do {						\
    (destination) = ((source)[0]		\
		     | ((source)[1] << 8)	\
		     | ((source)[2] << 16));	\
  } while (0)


/* Macros for charset. */

/* Size of bitmap of charset P in bytes.  P is a start of charset,
   i.e. *P is (re_opcode_t) charset or (re_opcode_t) charset_not.  */
#define CHARSET_BITMAP_SIZE(p) ((p)[1] & 0x7F)

/* Nonzero if charset P has range table.  */
#define CHARSET_RANGE_TABLE_EXISTS_P(p)	 ((p)[1] & 0x80)

/* Return the address of range table of charset P.  But not the start
   of table itself, but the before where the number of ranges is
   stored.  `2 +' means to skip re_opcode_t and size of bitmap.	 */
#define CHARSET_RANGE_TABLE(p) (&(p)[2 + CHARSET_BITMAP_SIZE (p)])

/* Test if C is listed in the bitmap of charset P.  */
#define CHARSET_LOOKUP_BITMAP(p, c)				\
  ((c) < CHARSET_BITMAP_SIZE (p) * BYTEWIDTH			\
   && (p)[2 + (c) / BYTEWIDTH] & (1 << ((c) % BYTEWIDTH)))

/* Return the address of end of RANGE_TABLE.  COUNT is number of
   ranges (which is a pair of (start, end)) in the RANGE_TABLE.	 `* 2'
   is start of range and end of range.	`* 3' is size of each start
   and end.  */
#define CHARSET_RANGE_TABLE_END(range_table, count)	\
  ((range_table) + (count) * 2 * 3)

/* Test if C is in RANGE_TABLE.	 A flag NOT is negated if C is in.
   COUNT is number of ranges in RANGE_TABLE.  */
#define CHARSET_LOOKUP_RANGE_TABLE_RAW(not, c, range_table, count)	\
  do									\
    {									\
      int range_start, range_end;					\
      unsigned char *p;							\
      unsigned char *range_table_end					\
	= CHARSET_RANGE_TABLE_END ((range_table), (count));		\
									\
      for (p = (range_table); p < range_table_end; p += 2 * 3)		\
	{								\
	  EXTRACT_CHARACTER (range_start, p);				\
	  EXTRACT_CHARACTER (range_end, p + 3);				\
									\
	  if (range_start <= (c) && (c) <= range_end)			\
	    {								\
	      (not) = !(not);						\
	      break;							\
	    }								\
	}								\
    }									\
  while (0)

/* Test if C is in range table of CHARSET.  The flag NOT is negated if
   C is listed in it.  */
#define CHARSET_LOOKUP_RANGE_TABLE(not, c, charset)			\
  do									\
    {									\
      /* Number of ranges in range table. */				\
      int count;							\
      unsigned char *range_table = CHARSET_RANGE_TABLE (charset);	\
									\
      EXTRACT_NUMBER_AND_INCR (count, range_table);			\
      CHARSET_LOOKUP_RANGE_TABLE_RAW ((not), (c), range_table, count);	\
    }									\
  while (0)

d689 3
a691 1
   the other test files, you can run the already-written tests.	 */
d693 1
a693 1
#ifdef DEBUG
d696 1
a696 1
#include <stdio.h>
d699 1
a699 1
#include <assert.h>
d701 1
a701 1
static int debug = 0;
d703 11
a713 9
#define DEBUG_STATEMENT(e) e
#define DEBUG_PRINT1(x) if (debug) printf (x)
#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)				\
  if (debug) print_partial_compiled_pattern (s, e)
#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
  if (debug) print_double_string (w, s1, sz1, s2, sz2)
d718 1
d720 1
a720 2
print_fastmap (fastmap)
    char *fastmap;
d730 6
a735 6
	  putchar (i - 1);
	  while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
	    {
	      was_a_range = 1;
	      i++;
	    }
d737 5
a741 5
	    {
	      printf ("-");
	      putchar (i - 1);
	    }
	}
d745 1
d752 1
a752 3
print_partial_compiled_pattern (start, end)
    unsigned char *start;
    unsigned char *end;
d755 3
a757 2
  unsigned char *p = start;
  unsigned char *pend = end;
d768 5
a772 1
      printf ("%d:\t", p - start);
d776 3
a778 3
	case no_op:
	  printf ("/no_op");
	  break;
d782 14
a795 2
	  printf ("/exactn/%d", mcnt);
	  do
d797 5
a801 5
	      putchar ('/');
	      putchar (*p++);
	    }
	  while (--mcnt);
	  break;
d804 3
a806 3
	  mcnt = *p++;
	  printf ("/start_memory/%d/%d", mcnt, *p++);
	  break;
d809 3
a811 3
	  mcnt = *p++;
	  printf ("/stop_memory/%d/%d", mcnt, *p++);
	  break;
d814 1
a814 1
	  printf ("/duplicate/%d", *p++);
d822 42
a863 3
	case charset_not:
	  {
	    register int c, last = -100;
d867 1
a867 1
		    (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
d869 1
a869 1
	    assert (p + *p < pend);
d871 1
a871 1
	    for (c = 0; c < 256; c++)
d883 1
a883 1
	      {
d892 1
a892 1
	      }
d900 1
d906 1
a906 1
	  break;
d909 2
a910 2
	  printf ("/endline");
	  break;
d913 7
a919 3
	  extract_number_and_incr (&mcnt, &p);
	  printf ("/on_failure_jump to %d", p + mcnt - start);
	  break;
d922 8
a929 3
	  extract_number_and_incr (&mcnt, &p);
	  printf ("/on_failure_keep_string_jump to %d", p + mcnt - start);
	  break;
d932 7
a938 3
	  extract_number_and_incr (&mcnt, &p);
	  printf ("/dummy_failure_jump to %d", p + mcnt - start);
	  break;
d941 2
a942 2
	  printf ("/push_dummy_failure");
	  break;
d944 47
a990 4
	case maybe_pop_jump:
	  extract_number_and_incr (&mcnt, &p);
	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
	  break;
d992 6
a997 4
	case pop_failure_jump:
	  extract_number_and_incr (&mcnt, &p);
	  printf ("/pop_failure_jump to %d", p + mcnt - start);
	  break;
d999 11
a1009 27
	case jump_past_alt:
	  extract_number_and_incr (&mcnt, &p);
	  printf ("/jump_past_alt to %d", p + mcnt - start);
	  break;

	case jump:
	  extract_number_and_incr (&mcnt, &p);
	  printf ("/jump to %d", p + mcnt - start);
	  break;

	case succeed_n:
	  extract_number_and_incr (&mcnt, &p);
	  extract_number_and_incr (&mcnt2, &p);
	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
	  break;

	case jump_n:
	  extract_number_and_incr (&mcnt, &p);
	  extract_number_and_incr (&mcnt2, &p);
	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
	  break;

	case set_number_at:
	  extract_number_and_incr (&mcnt, &p);
	  extract_number_and_incr (&mcnt2, &p);
	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
	  break;
d1011 1
a1011 1
	case wordbound:
d1017 1
a1017 1
	  break;
d1025 1
d1027 1
a1027 1
#ifdef emacs
d1030 1
a1030 1
	  break;
d1034 1
a1034 1
	  break;
d1038 1
a1038 1
	  break;
d1041 1
a1041 1
	  printf ("/syntaxspec");
d1044 1
a1044 1
	  break;
d1047 1
a1047 1
	  printf ("/notsyntaxspec");
d1051 1
a1051 1
#endif /* emacs */
d1055 1
a1055 1
	  break;
d1059 1
a1059 1
	  break;
d1063 1
a1063 1
	  break;
d1067 1
a1067 1
	  break;
d1069 2
a1070 2
	default:
	  printf ("?%d", *(p-1));
d1076 5
a1080 1
  printf ("%d:\tend of pattern.\n", p - start);
d1085 1
a1085 2
print_compiled_pattern (bufp)
    struct re_pattern_buffer *bufp;
d1087 1
a1087 1
  unsigned char *buffer = bufp->buffer;
d1089 4
a1092 2
  print_partial_compiled_pattern (buffer, buffer + bufp->used);
  printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
d1100 5
a1104 1
  printf ("re_nsub: %d\t", bufp->re_nsub);
d1111 1
a1111 1
  printf ("syntax: %d\n", bufp->syntax);
d1117 5
a1121 6
print_double_string (where, string1, size1, string2, size2)
    const char *where;
    const char *string1;
    const char *string2;
    int size1;
    int size2;
d1123 1
a1123 1
  unsigned this_char;
d1129 2
d1132 3
a1134 3
	{
	  for (this_char = where - string1; this_char < size1; this_char++)
	    putchar (string1[this_char]);
d1136 2
a1137 2
	  where = string2;
	}
d1139 1
d1141 8
a1148 1
	putchar (string2[this_char]);
d1152 10
a1161 1
#else /* not DEBUG */
d1163 12
a1174 2
#undef assert
#define assert(e)
d1176 1
a1176 7
#define DEBUG_STATEMENT(e)
#define DEBUG_PRINT1(x)
#define DEBUG_PRINT2(x1, x2)
#define DEBUG_PRINT3(x1, x2, x3)
#define DEBUG_PRINT4(x1, x2, x3, x4)
#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
a1177 1
#endif /* not DEBUG */
d1179 79
d1271 1
a1271 1
   defined in regex.h.	We return the old syntax.  */
d1274 1
a1274 2
re_set_syntax (syntax)
    reg_syntax_t syntax;
d1279 6
d1287 3
d1292 1
a1292 1
   in regex.h.	Obviously the order here has to be same as there.
d1294 55
a1348 1
   but why not be nice?	 */
d1350 1
a1350 1
static const char *re_error_msgid[] =
d1352 17
a1368 17
    gettext_noop ("Success"),	/* REG_NOERROR */
    gettext_noop ("No match"),	/* REG_NOMATCH */
    gettext_noop ("Invalid regular expression"), /* REG_BADPAT */
    gettext_noop ("Invalid collation character"), /* REG_ECOLLATE */
    gettext_noop ("Invalid character class name"), /* REG_ECTYPE */
    gettext_noop ("Trailing backslash"), /* REG_EESCAPE */
    gettext_noop ("Invalid back reference"), /* REG_ESUBREG */
    gettext_noop ("Unmatched [ or [^"),	/* REG_EBRACK */
    gettext_noop ("Unmatched ( or \\("), /* REG_EPAREN */
    gettext_noop ("Unmatched \\{"), /* REG_EBRACE */
    gettext_noop ("Invalid content of \\{\\}"), /* REG_BADBR */
    gettext_noop ("Invalid range end"),	/* REG_ERANGE */
    gettext_noop ("Memory exhausted"), /* REG_ESPACE */
    gettext_noop ("Invalid preceding regular expression"), /* REG_BADRPT */
    gettext_noop ("Premature end of regular expression"), /* REG_EEND */
    gettext_noop ("Regular expression too big"), /* REG_ESIZE */
    gettext_noop ("Unmatched ) or \\)"), /* REG_ERPAREN */
d1371 4
a1374 1
/* Avoiding alloca during matching, to placate r_alloc.	 */
d1394 1
a1394 1
#define MATCH_MAY_ALLOCATE
d1398 3
a1400 3
#ifdef __GNUC__
#undef C_ALLOCA
#endif
d1406 5
a1410 5
   so REL_ALLOC should not affect this.	 */
#if (defined (C_ALLOCA) || defined (REGEX_MALLOC)) && defined (emacs)
#undef MATCH_MAY_ALLOCATE
#endif

d1412 1
d1418 1
a1418 1
/* Approximate number of failure points for which to initially allocate space
d1421 3
a1423 3
#ifndef INIT_FAILURE_ALLOC
#define INIT_FAILURE_ALLOC 20
#endif
d1426 1
a1426 1
   exactly that if always used TYPICAL_FAILURE_SIZE items each time we failed.
d1428 13
a1440 10
   change it ourselves.	 */
#if defined (MATCH_MAY_ALLOCATE)
/* Note that 4400 is enough to cause a crash on Alpha OSF/1,
   whose default stack limit is 2mb.  In order for a larger
   value to work reliably, you have to try to make it accord
   with the process stack limit.  */
int re_max_failures = 40000;
#else
int re_max_failures = 4000;
#endif
d1442 1
a1442 1
union fail_stack_elt
d1444 28
a1471 1
  unsigned char *pointer;
d1475 1
a1475 1
typedef union fail_stack_elt fail_stack_elt_t;
d1479 1
a1479 1
  fail_stack_elt_t *stack;
d1482 1
a1482 1
} fail_stack_type;
d1484 7
a1490 3
#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
d1496 2
a1497 2
#ifdef MATCH_MAY_ALLOCATE
#define INIT_FAIL_STACK()						\
d1499 2
a1500 3
    fail_stack.stack = (fail_stack_elt_t *)				\
      REGEX_ALLOCATE_STACK (INIT_FAILURE_ALLOC * TYPICAL_FAILURE_SIZE	\
			    * sizeof (fail_stack_elt_t));		\
d1502 1
a1502 1
    if (fail_stack.stack == NULL)					\
d1505 2
a1506 2
    fail_stack.size = INIT_FAILURE_ALLOC;				\
    fail_stack.avail = 0;						\
d1509 3
a1511 3
#define RESET_FAIL_STACK()  REGEX_FREE_STACK (fail_stack.stack)
#else
#define INIT_FAIL_STACK()						\
d1513 1
a1513 1
    fail_stack.avail = 0;						\
d1516 2
a1517 2
#define RESET_FAIL_STACK()
#endif
d1520 1
a1520 2
/* Double the size of FAIL_STACK, up to a limit
   which allows approximately `re_max_failures' items.
d1525 1
a1525 1
   REGEX_REALLOCATE_STACK requires `destination' be declared.	*/
d1527 2
a1528 10
/* Factor to increase the failure stack size by
   when we increase it.
   This used to be 2, but 2 was too wasteful
   because the old discarded stacks added up to as much space
   were as ultimate, maximum-size stack.  */
#define FAIL_STACK_GROWTH_FACTOR 4

#define GROW_FAIL_STACK(fail_stack)					\
  (((fail_stack).size * sizeof (fail_stack_elt_t)			\
    >= re_max_failures * TYPICAL_FAILURE_SIZE)				\
d1530 4
a1533 7
   : ((fail_stack).stack						\
      = (fail_stack_elt_t *)						\
	REGEX_REALLOCATE_STACK ((fail_stack).stack,			\
	  (fail_stack).size * sizeof (fail_stack_elt_t),		\
	  MIN (re_max_failures * TYPICAL_FAILURE_SIZE,			\
	       ((fail_stack).size * sizeof (fail_stack_elt_t)		\
		* FAIL_STACK_GROWTH_FACTOR))),				\
d1537 2
a1538 6
      : ((fail_stack).size						\
	 = (MIN (re_max_failures * TYPICAL_FAILURE_SIZE,		\
		 ((fail_stack).size * sizeof (fail_stack_elt_t)		\
		  * FAIL_STACK_GROWTH_FACTOR))				\
	    / sizeof (fail_stack_elt_t)),				\
	 1)))
d1544 1
a1544 1
#define PUSH_PATTERN_OP(POINTER, FAIL_STACK)				\
d1546 1
a1546 1
    && !GROW_FAIL_STACK (FAIL_STACK))					\
d1553 3
a1555 3
   be called from within `PUSH_FAILURE_POINT'.	*/
#define PUSH_FAILURE_POINTER(item)					\
  fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (item)
d1559 2
a1560 2
   be called from within `PUSH_FAILURE_POINT'.	*/
#define PUSH_FAILURE_INT(item)					\
d1565 2
a1566 2
   be called from within `PUSH_FAILURE_POINT'.	*/
#define PUSH_FAILURE_ELT(item)					\
d1571 3
a1573 3
#define POP_FAILURE_POINTER() fail_stack.stack[--fail_stack.avail].pointer
#define POP_FAILURE_INT() fail_stack.stack[--fail_stack.avail].integer
#define POP_FAILURE_ELT() fail_stack.stack[--fail_stack.avail]
d1576 7
a1582 7
#ifdef DEBUG
#define DEBUG_PUSH PUSH_FAILURE_INT
#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_INT ()
#else
#define DEBUG_PUSH(item)
#define DEBUG_POP(item_addr)
#endif
d1589 2
a1590 2
   num_regs be declared.  GROW_FAIL_STACK requires `destination' be
   declared.
d1594 1
a1594 1
#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
d1599 5
a1603 2
    int this_reg;							\
									\
d1608 1
a1608 1
    DEBUG_PRINT2 ("			size: %d\n", (fail_stack).size);\
d1610 2
a1611 2
    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
    DEBUG_PRINT2 ("	available: %d\n", REMAINING_AVAIL_SLOTS);	\
d1616 2
a1617 2
	if (!GROW_FAIL_STACK (fail_stack))				\
	  return failure_code;						\
d1619 1
a1619 1
	DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
d1621 1
a1621 1
	DEBUG_PRINT2 ("	 slots available: %d\n", REMAINING_AVAIL_SLOTS);\
d1631 1
a1631 1
	  DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);		\
d1634 1
a1634 1
	  DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);	\
d1637 1
a1637 1
	  DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
d1640 2
a1641 1
	  DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
d1653 1
a1653 1
    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
d1656 1
a1656 1
    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
d1659 1
a1659 1
    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
d1663 2
a1664 2
    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,	\
d1673 1
d1676 1
a1676 1
#define NUM_REG_ITEMS  3
d1679 11
a1689 9
#ifdef DEBUG
#define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
#else
#define NUM_NONREG_ITEMS 4
#endif

/* Estimate the size of data pushed by a typical failure stack entry.
   An estimate is all we need, because all we use this for
   is to choose a limit for how big to make the failure stack.  */
d1691 2
a1692 5
#define TYPICAL_FAILURE_SIZE 20

/* This is how many items we actually use for a failure point.
   It depends on the regexp.  */
#define NUM_FAILURE_ITEMS				\
d1699 2
a1700 1
#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
d1713 2
a1714 3
   `pend', `string1', `size1', `string2', and `size2'.	*/

#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
d1716 3
a1718 3
  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
  int this_reg;								\
  const unsigned char *string_temp;					\
d1725 1
a1725 1
  DEBUG_PRINT2 ("		     size: %d\n", fail_stack.size);	\
d1737 1
a1737 1
    str = (const char *) string_temp;					\
d1739 1
a1739 1
  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
d1743 2
a1744 2
  pat = (unsigned char *) POP_FAILURE_POINTER ();			\
  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
d1748 2
a1749 2
  high_reg = (unsigned) POP_FAILURE_INT ();				\
  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
d1751 2
a1752 2
  low_reg = (unsigned) POP_FAILURE_INT ();				\
  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
d1757 1
a1757 1
	DEBUG_PRINT2 ("	   Popping reg: %d\n", this_reg);		\
d1760 2
a1761 1
	DEBUG_PRINT2 ("	     info: 0x%x\n", reg_info[this_reg]);	\
d1763 2
a1764 2
	regend[this_reg] = (const char *) POP_FAILURE_POINTER ();	\
	DEBUG_PRINT2 ("	     end: 0x%x\n", regend[this_reg]);		\
d1766 2
a1767 2
	regstart[this_reg] = (const char *) POP_FAILURE_POINTER ();	\
	DEBUG_PRINT2 ("	     start: 0x%x\n", regstart[this_reg]);	\
a1782 2


d1795 3
d1800 1
a1800 1
  fail_stack_elt_t word;
d1804 2
a1805 2
	 zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
#define MATCH_NULL_UNSET_VALUE 3
d1811 1
a1811 1
} register_info_type;
d1813 5
a1817 4
#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
#define IS_ACTIVE(R)  ((R).bits.is_active)
#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
d1823 1
a1823 1
#define SET_REGS_MATCHED()						\
d1828 1
a1828 1
	  unsigned r;							\
d1839 1
d1842 4
a1845 4
static char reg_unset_dummy;
#define REG_UNSET_VALUE (&reg_unset_dummy)
#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)

d1847 30
a1876 6

static void store_op1 (), store_op2 ();
static void insert_op1 (), insert_op2 ();
static boolean at_begline_loc_p (), at_endline_loc_p ();
static boolean group_in_compile_stack ();
static reg_errcode_t compile_range ();
d1882 12
a1893 2
#ifndef PATFETCH
#define PATFETCH(c)							\
d1896 1
a1896 1
    if (RE_TRANSLATE_P (translate)) c = RE_TRANSLATE (translate, c);	\
d1898 2
a1899 1
#endif
d1902 2
a1903 2
   translation.	 */
#define PATFETCH_RAW(c)							\
d1905 1
a1905 1
    c = (unsigned char) *p++;						\
d1909 1
a1909 1
#define PATUNFETCH p--
d1916 14
a1929 5
#ifndef TRANSLATE
#define TRANSLATE(d) \
  (RE_TRANSLATE_P (translate) \
   ? (unsigned) RE_TRANSLATE (translate, (unsigned) (d)) : (d))
#endif
d1935 1
a1935 1
#define INIT_BUF_SIZE  32
d1937 9
a1945 3
/* Make sure we have at least N more bytes of space in buffer.	*/
#define GET_BUFFER_SPACE(n)						\
    while (b - bufp->buffer + (n) > bufp->allocated)			\
d1947 1
d1950 1
a1950 1
#define BUF_PUSH(c)							\
d1953 1
a1953 1
    *b++ = (unsigned char) (c);						\
d1958 1
a1958 1
#define BUF_PUSH_2(c1, c2)						\
d1961 2
a1962 2
    *b++ = (unsigned char) (c1);					\
    *b++ = (unsigned char) (c2);					\
d1966 2
a1967 2
/* As with BUF_PUSH_2, except for three bytes.	*/
#define BUF_PUSH_3(c1, c2, c3)						\
d1970 3
a1972 3
    *b++ = (unsigned char) (c1);					\
    *b++ = (unsigned char) (c2);					\
    *b++ = (unsigned char) (c3);					\
a1974 1

d1976 3
a1978 3
   relative address offset by the three bytes the jump itself occupies.	 */
#define STORE_JUMP(op, loc, to) \
  store_op1 (op, loc, (to) - (loc) - 3)
d1981 2
a1982 2
#define STORE_JUMP2(op, loc, to, arg) \
  store_op2 (op, loc, (to) - (loc) - 3, arg)
d1984 3
a1986 3
/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.	 */
#define INSERT_JUMP(op, loc, to) \
  insert_op1 (op, loc, (to) - (loc) - 3, b)
d1989 3
a1991 3
#define INSERT_JUMP2(op, loc, to, arg) \
  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)

d1994 1
a1994 1
   into the pattern are two bytes long.	 So if 2^16 bytes turns out to
d1996 16
a2011 2
#define MAX_BUF_SIZE (1L << 16)

d2016 59
a2074 2
   being larger than MAX_BUF_SIZE, then flag memory exhausted.	*/
#define EXTEND_BUFFER()							\
d2076 1
a2076 1
    unsigned char *old_buffer = bufp->buffer;				\
d2082 2
a2083 2
    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
    if (bufp->buffer == NULL)						\
d2086 1
a2086 1
    if (old_buffer != bufp->buffer)					\
d2088 3
a2090 2
	b = (b - old_buffer) + bufp->buffer;				\
	begalt = (begalt - old_buffer) + bufp->buffer;			\
d2092 1
a2092 1
	  fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
d2094 1
a2094 1
	  laststart = (laststart - old_buffer) + bufp->buffer;		\
d2096 1
a2096 1
	  pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
d2098 1
d2100 1
d2102 1
a2102 1

d2106 1
a2106 1
#define MAX_REGNUM 255
d2116 3
a2118 2
   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.	 */
typedef int pattern_offset_t;
d2138 1
a2138 41
#define INIT_COMPILE_STACK_SIZE 32

#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)

/* The next available element.	*/
#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])


/* Structure to manage work area for range table.  */
struct range_table_work_area
{
  int *table;			/* actual work area.  */
  int allocated;		/* allocated size for work area in bytes.  */
  int used;			/* actually used size in words.	 */
};

/* Make sure that WORK_AREA can hold more N multibyte characters.  */
#define EXTEND_RANGE_TABLE_WORK_AREA(work_area, n)			  \
  do {									  \
    if (((work_area).used + (n)) * sizeof (int) > (work_area).allocated)  \
      {									  \
	(work_area).allocated += 16 * sizeof (int);			  \
	if ((work_area).table)						  \
	  (work_area).table						  \
	    = (int *) realloc ((work_area).table, (work_area).allocated); \
	else								  \
	  (work_area).table						  \
	    = (int *) malloc ((work_area).allocated);			  \
	if ((work_area).table == 0)					  \
	  FREE_STACK_RETURN (REG_ESPACE);				  \
      }									  \
  } while (0)

/* Set a range (RANGE_START, RANGE_END) to WORK_AREA.  */
#define SET_RANGE_TABLE_WORK_AREA(work_area, range_start, range_end)	\
  do {									\
    EXTEND_RANGE_TABLE_WORK_AREA ((work_area), 2);			\
    (work_area).table[(work_area).used++] = (range_start);		\
    (work_area).table[(work_area).used++] = (range_end);		\
  } while (0)
d2140 2
a2141 6
/* Free allocated memory for WORK_AREA.	 */
#define FREE_RANGE_TABLE_WORK_AREA(work_area)	\
  do {						\
    if ((work_area).table)			\
      free ((work_area).table);			\
  } while (0)
d2143 2
a2144 3
#define CLEAR_RANGE_TABLE_WORK_USED(work_area) ((work_area).used = 0)
#define RANGE_TABLE_WORK_USED(work_area) ((work_area).used)
#define RANGE_TABLE_WORK_ELT(work_area, i) ((work_area).table[i])
d2146 1
d2149 3
a2151 2
#define SET_LIST_BIT(c)				      \
  (b[((unsigned char) (c)) / BYTEWIDTH]		      \
d2153 1
a2153 1

d2156 10
a2165 7
#define GET_UNSIGNED_NUMBER(num)					\
  { if (p != pend)							\
     {									\
       PATFETCH (c);							\
       while (ISDIGIT (c))						\
	 {								\
	   if (num < 0)							\
d2167 4
a2170 7
	   num = num * 10 + c - '0';					\
	   if (p == pend)						\
	      break;							\
	   PATFETCH (c);						\
	 }								\
       }								\
    }
d2172 19
a2190 1
#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
d2192 1
a2192 1
#define IS_CHAR_CLASS(string)						\
d2199 2
d2202 1
a2202 1
#ifndef MATCH_MAY_ALLOCATE
d2211 1
a2211 1
static fail_stack_type fail_stack;
d2215 2
a2216 1
   but never make them smaller.	 */
d2219 1
a2219 1
static const char **	 regstart, **	  regend;
a2221 1
static register_info_type *reg_info;
d2223 4
a2226 1
static register_info_type *reg_info_dummy;
d2229 1
a2229 1
   but don't make them smaller.	 */
d2231 2
a2232 3
static
regex_grow_registers (num_regs)
     int num_regs;
d2242 1
a2242 1
      RETALLOC_IF (reg_info,	 num_regs, register_info_type);
d2244 1
a2244 1
      RETALLOC_IF (reg_info_dummy, num_regs, register_info_type);
d2250 1
a2250 1
#endif /* not MATCH_MAY_ALLOCATE */
d2252 6
d2277 7
a2283 6
#define FREE_STACK_RETURN(value)		\
  do {							\
    FREE_RANGE_TABLE_WORK_AREA (range_table_work);	\
    free (compile_stack.stack);				\
    return value;					\
  } while (0)
d2286 4
a2289 5
regex_compile (pattern, size, syntax, bufp)
     const char *pattern;
     int size;
     reg_syntax_t syntax;
     struct re_pattern_buffer *bufp;
d2294 13
a2306 1
  register unsigned int c, c1;
d2309 1
a2309 1
  const char *p1;
d2312 1
a2312 1
  register unsigned char *b;
d2318 7
a2324 7
#ifdef AIX
  /* `const' makes AIX compiler fail.  */
  char *p = pattern;
#else
  const char *p = pattern;
#endif
  const char *pend = pattern + size;
d2333 1
a2333 1
  unsigned char *pending_exact = 0;
d2338 1
a2338 1
  unsigned char *laststart = 0;
d2341 1
a2341 5
  unsigned char *begalt;

  /* Place in the uncompiled pattern (i.e., the {) to
     which to go back if the interval is invalid.  */
  const char *beg_interval;
d2344 1
a2344 1
     the containing expression.	 Each alternative of an `or' -- except the
d2346 1
a2346 1
  unsigned char *fixup_alt_jump = 0;
d2353 23
a2375 2
  /* Work area for range table of charset.  */
  struct range_table_work_area range_table_work;
d2384 1
a2384 1
	putchar (pattern[debug_count]);
d2392 8
a2399 1
    return REG_ESPACE;
a2403 3
  range_table_work.table = 0;
  range_table_work.allocated = 0;

d2417 1
a2417 9
#ifdef emacs
  /* bufp->multibyte is set before regex_compile is called, so don't alter
     it. */
#else  /* not emacs */
  /* Nothing is recognized as a multibyte character.  */
  bufp->multibyte = 0;
#endif

#if !defined (emacs) && !defined (SYNTAX_TABLE)
d2426 12
a2437 4
	     enough space.  This loses if buffer's address is bogus, but
	     that is the user's responsibility.	 */
	  RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
	}
d2439 4
a2442 4
	{ /* Caller did not allocate a buffer.	Do it for them.	 */
	  bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
	}
      if (!bufp->buffer) FREE_STACK_RETURN (REG_ESPACE);
d2444 4
d2450 4
d2455 1
a2455 1
  begalt = b = bufp->buffer;
d2463 14
a2476 14
	{
	case '^':
	  {
	    if (   /* If at start of pattern, it's an operator.	 */
		   p == pattern + 1
		   /* If context independent, it's an operator.	 */
		|| syntax & RE_CONTEXT_INDEP_ANCHORS
		   /* Otherwise, depends on what's come before.	 */
		|| at_begline_loc_p (pattern, p, syntax))
	      BUF_PUSH (begline);
	    else
	      goto normal_char;
	  }
	  break;
d2479 13
a2491 13
	case '$':
	  {
	    if (   /* If at end of pattern, it's an operator.  */
		   p == pend
		   /* If context independent, it's an operator.	 */
		|| syntax & RE_CONTEXT_INDEP_ANCHORS
		   /* Otherwise, depends on what's next.  */
		|| at_endline_loc_p (p, pend, syntax))
	       BUF_PUSH (endline);
	     else
	       goto normal_char;
	   }
	   break;
d2495 14
a2508 14
	case '?':
	  if ((syntax & RE_BK_PLUS_QM)
	      || (syntax & RE_LIMITED_OPS))
	    goto normal_char;
	handle_plus:
	case '*':
	  /* If there is no previous pattern... */
	  if (!laststart)
	    {
	      if (syntax & RE_CONTEXT_INVALID_OPS)
		FREE_STACK_RETURN (REG_BADRPT);
	      else if (!(syntax & RE_CONTEXT_INDEP_OPS))
		goto normal_char;
	    }
d2510 16
a2525 3
	  {
	    /* Are we optimizing this jump?  */
	    boolean keep_string_p = false;
d2527 2
a2528 2
	    /* 1 means zero (many) matches is allowed.	*/
	    char zero_times_ok = 0, many_times_ok = 0;
d2530 1
a2530 4
	    /* If there is a sequence of repetition chars, collapse it
	       down to just one (the right one).  We can't combine
	       interval operators with these because of, e.g., `a{2}*',
	       which should only match an even number of `a's.	*/
d2532 23
a2554 7
	    for (;;)
	      {
		zero_times_ok |= c != '+';
		many_times_ok |= c != '?';

		if (p == pend)
		  break;
d2556 2
a2557 1
		PATFETCH (c);
d2559 70
a2628 3
		if (c == '*'
		    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
		  ;
a2629 3
		else if (syntax & RE_BK_PLUS_QM	 &&  c == '\\')
		  {
		    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
d2631 4
a2634 7
		    PATFETCH (c1);
		    if (!(c1 == '+' || c1 == '?'))
		      {
			PATUNFETCH;
			PATUNFETCH;
			break;
		      }
a2635 7
		    c = c1;
		  }
		else
		  {
		    PATUNFETCH;
		    break;
		  }
d2637 9
a2645 2
		/* If we get here, we found another repeat character.  */
	       }
d2647 75
a2721 43
	    /* Star, etc. applied to an empty pattern is equivalent
	       to an empty pattern.  */
	    if (!laststart)
	      break;

	    /* Now we know whether or not zero matches is allowed
	       and also whether or not two or more matches is allowed.	*/
	    if (many_times_ok)
	      { /* More than one repetition is allowed, so put in at the
		   end a backward relative jump from `b' to before the next
		   jump we're going to put in below (which jumps from
		   laststart to after this jump).

		   But if we are at the `*' in the exact sequence `.*\n',
		   insert an unconditional jump backwards to the .,
		   instead of the beginning of the loop.  This way we only
		   push a failure point once, instead of every time
		   through the loop.  */
		assert (p - 1 > pattern);

		/* Allocate the space for the jump.  */
		GET_BUFFER_SPACE (3);

		/* We know we are not at the first character of the pattern,
		   because laststart was nonzero.  And we've already
		   incremented `p', by the way, to be the character after
		   the `*'.  Do we have to do something analogous here
		   for null bytes, because of RE_DOT_NOT_NULL?	*/
		if (TRANSLATE ((unsigned char)*(p - 2)) == TRANSLATE ('.')
		    && zero_times_ok
		    && p < pend
		    && TRANSLATE ((unsigned char)*p) == TRANSLATE ('\n')
		    && !(syntax & RE_DOT_NEWLINE))
		  { /* We have .*\n.  */
		    STORE_JUMP (jump, b, laststart);
		    keep_string_p = true;
		  }
		else
		  /* Anything else.  */
		  STORE_JUMP (maybe_pop_jump, b, laststart - 3);

		/* We've added more stuff to the buffer.  */
		b += 3;
d2724 24
a2747 8
	    /* On failure, jump from laststart to b + 3, which will be the
	       end of the buffer after this jump is inserted.  */
	    GET_BUFFER_SPACE (3);
	    INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
				       : on_failure_jump,
			 laststart, b + 3);
	    pending_exact = 0;
	    b += 3;
d2749 77
a2825 13
	    if (!zero_times_ok)
	      {
		/* At least one repetition is required, so insert a
		   `dummy_failure_jump' before the initial
		   `on_failure_jump' instruction of the loop. This
		   effects a skip over that instruction the first time
		   we hit that loop.  */
		GET_BUFFER_SPACE (3);
		INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
		b += 3;
	      }
	    }
	  break;
d2827 48
d2876 2
a2877 4
	case '.':
	  laststart = b;
	  BUF_PUSH (anychar);
	  break;
d2879 12
d2892 216
a3107 5
	case '[':
	  {
	    CLEAR_RANGE_TABLE_WORK_USED (range_table_work);

	    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
d3109 3
a3111 2
	    /* Ensure that we have enough space to push a charset: the
	       opcode, the length count, and the bitset; 34 bytes in all.  */
d3114 1
a3114 1
	    laststart = b;
d3116 43
a3158 5
	    /* We test `*p == '^' twice, instead of using an if
	       statement, so we only need one BUF_PUSH.	 */
	    BUF_PUSH (*p == '^' ? charset_not : charset);
	    if (*p == '^')
	      p++;
d3160 69
a3228 2
	    /* Remember the first position in the bracket expression.  */
	    p1 = p;
d3230 3
a3232 2
	    /* Push the number of bytes in the bitmap.	*/
	    BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
d3234 3
a3236 2
	    /* Clear the whole map.  */
	    bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
d3238 1
a3238 4
	    /* charset_not matches newline according to a syntax bit.  */
	    if ((re_opcode_t) b[-2] == charset_not
		&& (syntax & RE_HAT_LISTS_NOT_NEWLINE))
	      SET_LIST_BIT ('\n');
d3240 4
a3243 5
	    /* Read in characters and ranges, setting map bits.	 */
	    for (;;)
	      {
		int len;
		boolean escaped_char = false;
d3245 4
a3248 1
		if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
d3250 15
a3264 1
		PATFETCH (c);
d3266 2
a3267 16
		/* \ might escape characters inside [...] and [^...].  */
		if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
		  {
		    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);

		    PATFETCH (c);
		    escaped_char = true;
		  }
		else
		  {
		    /* Could be the end of the bracket expression.	If it's
		       not (i.e., when the bracket expression is `[]' so
		       far), the ']' character bit gets set way below.  */
		    if (c == ']' && p != p1 + 1)
		      break;
		  }
d3269 3
a3271 12
		/* If C indicates start of multibyte char, get the
		   actual character code in C, and set the pattern
		   pointer P to the next character boundary.  */
		if (bufp->multibyte && BASE_LEADING_CODE_P (c))
		  {
		    PATUNFETCH;
		    c = STRING_CHAR_AND_LENGTH (p, pend - p, len);
		    p += len;
		  }
		/* What should we do for the character which is
		   greater than 0x7F, but not BASE_LEADING_CODE_P?
		   XXX */
d3273 1
a3273 2
		/* See if we're at the beginning of a possible character
		   class.  */
d3275 38
a3312 2
		else if (!escaped_char &&
			 syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
d3314 5
a3318 2
		    /* Leave room for the null.	 */
		    char str[CHAR_CLASS_MAX_LENGTH + 1];
d3323 1
a3323 1
		    /* If pattern is `[[:'.  */
d3329 1
a3329 2
			if (c == ':' || c == ']' || p == pend
			    || c1 == CHAR_CLASS_MAX_LENGTH)
d3331 6
a3336 2
			str[c1++] = c;
		      }
d3339 1
a3339 5
		    /* If isn't a word bracketed by `[:' and `:]':
		       undo the ending character, the letters, and
		       leave the leading `:' and `[' (but set bits for
		       them).  */
		    if (c == ':' && *p == ']')
d3341 12
a3352 13
			int ch;
			boolean is_alnum = STREQ (str, "alnum");
			boolean is_alpha = STREQ (str, "alpha");
			boolean is_blank = STREQ (str, "blank");
			boolean is_cntrl = STREQ (str, "cntrl");
			boolean is_digit = STREQ (str, "digit");
			boolean is_graph = STREQ (str, "graph");
			boolean is_lower = STREQ (str, "lower");
			boolean is_print = STREQ (str, "print");
			boolean is_punct = STREQ (str, "punct");
			boolean is_space = STREQ (str, "space");
			boolean is_upper = STREQ (str, "upper");
			boolean is_xdigit = STREQ (str, "xdigit");
d3354 3
a3356 2
			if (!IS_CHAR_CLASS (str))
			  FREE_STACK_RETURN (REG_ECTYPE);
d3358 5
a3362 7
			/* Throw away the ] at the end of the character
			   class.  */
			PATFETCH (c);

			if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

			for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
d3364 67
a3430 18
			    int translated = TRANSLATE (ch);
			    /* This was split into 3 if's to
			       avoid an arbitrary limit in some compiler.  */
			    if (   (is_alnum  && ISALNUM (ch))
				|| (is_alpha  && ISALPHA (ch))
				|| (is_blank  && ISBLANK (ch))
				|| (is_cntrl  && ISCNTRL (ch)))
			      SET_LIST_BIT (translated);
			    if (   (is_digit  && ISDIGIT (ch))
				|| (is_graph  && ISGRAPH (ch))
				|| (is_lower  && ISLOWER (ch))
				|| (is_print  && ISPRINT (ch)))
			      SET_LIST_BIT (translated);
			    if (   (is_punct  && ISPUNCT (ch))
				|| (is_space  && ISSPACE (ch))
				|| (is_upper  && ISUPPER (ch))
				|| (is_xdigit && ISXDIGIT (ch)))
			      SET_LIST_BIT (translated);
d3432 2
a3433 15

			/* Repeat the loop. */
			continue;
		      }
		    else
		      {
			c1++;
			while (c1--)
			  PATUNFETCH;
			SET_LIST_BIT ('[');

			/* Because the `:' may starts the range, we
			   can't simply set bit and repeat the loop.
			   Instead, just set it to C and handle below.	*/
			c = ':';
d3435 10
d3446 7
d3454 2
a3455 2
		if (p < pend && p[0] == '-' && p[1] != ']')
		  {
d3457 2
a3458 2
		    /* Discard the `-'. */
		    PATFETCH (c1);
d3460 1
a3460 3
		    /* Fetch the character which ends the range. */
		    PATFETCH (c1);
		    if (bufp->multibyte && BASE_LEADING_CODE_P (c1))
d3462 10
a3471 4
			PATUNFETCH;
			c1 = STRING_CHAR_AND_LENGTH (p, pend - p, len);
			p += len;
		      }
d3473 1
a3473 2
		    if (SINGLE_BYTE_CHAR_P (c)
			&& ! SINGLE_BYTE_CHAR_P (c1))
d3475 13
a3487 14
			/* Handle a range such as \177-\377 in multibyte mode.
			   Split that into two ranges,,
			   the low one ending at 0237, and the high one
			   starting at ...040.  */
			int c1_base = (c1 & ~0177) | 040;
			SET_RANGE_TABLE_WORK_AREA (range_table_work, c, c1);
			c1 = 0237;
		      }
		    else if (!SAME_CHARSET_P (c, c1))
		      FREE_STACK_RETURN (REG_ERANGE);
		  }
		else
		  /* Range from C to C. */
		  c1 = c;
d3489 88
a3576 19
		/* Set the range ... */
		if (SINGLE_BYTE_CHAR_P (c))
		  /* ... into bitmap.  */
		  {
		    unsigned this_char;
		    int range_start = c, range_end = c1;

		    /* If the start is after the end, the range is empty.  */
		    if (range_start > range_end)
		      {
			if (syntax & RE_NO_EMPTY_RANGES)
			  FREE_STACK_RETURN (REG_ERANGE);
			/* Else, repeat the loop.  */
		      }
		    else
		      {
			for (this_char = range_start; this_char <= range_end;
			     this_char++)
			  SET_LIST_BIT (TRANSLATE (this_char));
d3578 10
d3589 16
a3604 4
		else
		  /* ... into range table.  */
		  SET_RANGE_TABLE_WORK_AREA (range_table_work, c, c1);
	      }
a3605 5
	    /* Discard any (non)matching list bytes that are all 0 at the
	       end of the map.	Decrease the map-length byte too.  */
	    while ((int) b[-1] > 0 && b[b[-1] - 1] == 0)
	      b[-1]--;
	    b += b[-1];
d3607 19
a3625 5
	    /* Build real range table from work area. */
	    if (RANGE_TABLE_WORK_USED (range_table_work))
	      {
		int i;
		int used = RANGE_TABLE_WORK_USED (range_table_work);
a3626 14
		/* Allocate space for COUNT + RANGE_TABLE.  Needs two
		   bytes for COUNT and three bytes for each character.	*/
		GET_BUFFER_SPACE (2 + used * 3);

		/* Indicate the existence of range table.  */
		laststart[1] |= 0x80;

		STORE_NUMBER_AND_INCR (b, used / 2);
		for (i = 0; i < used; i++)
		  STORE_CHARACTER_AND_INCR
		    (b, RANGE_TABLE_WORK_ELT (range_table_work, i));
	      }
	  }
	  break;
d3628 5
a3633 5
	case '(':
	  if (syntax & RE_NO_BK_PARENS)
	    goto handle_open;
	  else
	    goto normal_char;
d3635 5
a3640 5
	case ')':
	  if (syntax & RE_NO_BK_PARENS)
	    goto handle_close;
	  else
	    goto normal_char;
d3642 2
d3645 4
a3648 5
	case '\n':
	  if (syntax & RE_NEWLINE_ALT)
	    goto handle_alt;
	  else
	    goto normal_char;
d3650 9
d3660 5
a3664 5
	case '|':
	  if (syntax & RE_NO_BK_VBAR)
	    goto handle_alt;
	  else
	    goto normal_char;
d3666 2
d3669 20
a3688 5
	case '{':
	   if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
	     goto handle_interval;
	   else
	     goto normal_char;
d3690 1
d3692 8
a3699 2
	case '\\':
	  if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
a3700 4
	  /* Do not translate the character after the \, so that we can
	     distinguish, e.g., \B from \b, even if we normally would
	     translate, e.g., B to b.  */
	  PATFETCH_RAW (c);
d3702 2
a3703 9
	  switch (c)
	    {
	    case '(':
	      if (syntax & RE_NO_BK_PARENS)
		goto normal_backslash;

	    handle_open:
	      bufp->re_nsub++;
	      regnum++;
d3705 1
a3705 1
	      if (COMPILE_STACK_FULL)
d3707 5
a3711 3
		  RETALLOC (compile_stack.stack, compile_stack.size << 1,
			    compile_stack_elt_t);
		  if (compile_stack.stack == NULL) return REG_ESPACE;
d3713 12
a3724 2
		  compile_stack.size <<= 1;
		}
d3726 2
a3727 15
	      /* These are the values to restore when we hit end of this
		 group.	 They are all relative offsets, so that if the
		 whole pattern moves because of realloc, they will still
		 be valid.  */
	      COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
	      COMPILE_STACK_TOP.fixup_alt_jump
		= fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
	      COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
	      COMPILE_STACK_TOP.regnum = regnum;

	      /* We will eventually replace the 0 with the number of
		 groups inner to this one.  But do not push a
		 start_memory for groups beyond the last one we can
		 represent in the compiled pattern.  */
	      if (regnum <= MAX_REGNUM)
d3729 4
a3732 2
		  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
		  BUF_PUSH_3 (start_memory, regnum, 0);
d3735 17
a3751 58
	      compile_stack.avail++;

	      fixup_alt_jump = 0;
	      laststart = 0;
	      begalt = b;
	      /* If we've reached MAX_REGNUM groups, then this open
		 won't actually generate any code, so we'll have to
		 clear pending_exact explicitly.  */
	      pending_exact = 0;
	      break;


	    case ')':
	      if (syntax & RE_NO_BK_PARENS) goto normal_backslash;

	      if (COMPILE_STACK_EMPTY)
		if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
		  goto normal_backslash;
		else
		  FREE_STACK_RETURN (REG_ERPAREN);

	    handle_close:
	      if (fixup_alt_jump)
		{ /* Push a dummy failure point at the end of the
		     alternative for a possible future
		     `pop_failure_jump' to pop.	 See comments at
		     `push_dummy_failure' in `re_match_2'.  */
		  BUF_PUSH (push_dummy_failure);

		  /* We allocated space for this jump when we assigned
		     to `fixup_alt_jump', in the `handle_alt' case below.  */
		  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
		}

	      /* See similar code for backslashed left paren above.  */
	      if (COMPILE_STACK_EMPTY)
		if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
		  goto normal_char;
		else
		  FREE_STACK_RETURN (REG_ERPAREN);

	      /* Since we just checked for an empty stack above, this
		 ``can't happen''.  */
	      assert (compile_stack.avail != 0);
	      {
		/* We don't just want to restore into `regnum', because
		   later groups should continue to be numbered higher,
		   as in `(ab)c(de)' -- the second group is #2.	 */
		regnum_t this_group_regnum;

		compile_stack.avail--;
		begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
		fixup_alt_jump
		  = COMPILE_STACK_TOP.fixup_alt_jump
		    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1
		    : 0;
		laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
		this_group_regnum = COMPILE_STACK_TOP.regnum;
d3757 119
a3875 13
		/* We're at the end of the group, so now we know how many
		   groups were inside this one.	 */
		if (this_group_regnum <= MAX_REGNUM)
		  {
		    unsigned char *inner_group_loc
		      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;

		    *inner_group_loc = regnum - this_group_regnum;
		    BUF_PUSH_3 (stop_memory, this_group_regnum,
				regnum - this_group_regnum);
		  }
	      }
	      break;
d3877 1
d3879 2
a3880 6
	    case '|':					/* `\|'.  */
	      if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
		goto normal_backslash;
	    handle_alt:
	      if (syntax & RE_LIMITED_OPS)
		goto normal_char;
d3882 87
a3968 6
	      /* Insert before the previous alternative a jump which
		 jumps to this alternative if the former fails.	 */
	      GET_BUFFER_SPACE (3);
	      INSERT_JUMP (on_failure_jump, begalt, b + 6);
	      pending_exact = 0;
	      b += 3;
d3970 9
a3978 64
	      /* The alternative before this one has a jump after it
		 which gets executed if it gets matched.  Adjust that
		 jump so it will jump to this alternative's analogous
		 jump (put in below, which in turn will jump to the next
		 (if any) alternative's such jump, etc.).  The last such
		 jump jumps to the correct final destination.  A picture:
			  _____ _____
			  |   | |   |
			  |   v |   v
			 a | b	 | c

		 If we are at `b', then fixup_alt_jump right now points to a
		 three-byte space after `a'.  We'll put in the jump, set
		 fixup_alt_jump to right after `b', and leave behind three
		 bytes which we'll fill in when we get to after `c'.  */

	      if (fixup_alt_jump)
		STORE_JUMP (jump_past_alt, fixup_alt_jump, b);

	      /* Mark and leave space for a jump after this alternative,
		 to be filled in later either by next alternative or
		 when know we're at the end of a series of alternatives.  */
	      fixup_alt_jump = b;
	      GET_BUFFER_SPACE (3);
	      b += 3;

	      laststart = 0;
	      begalt = b;
	      break;


	    case '{':
	      /* If \{ is a literal.  */
	      if (!(syntax & RE_INTERVALS)
		     /* If we're at `\{' and it's not the open-interval
			operator.  */
		  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
		  || (p - 2 == pattern	&&  p == pend))
		goto normal_backslash;

	    handle_interval:
	      {
		/* If got here, then the syntax allows intervals.  */

		/* At least (most) this many matches must be made.  */
		int lower_bound = -1, upper_bound = -1;

		beg_interval = p - 1;

		if (p == pend)
		  {
		    if (syntax & RE_NO_BK_BRACES)
		      goto unfetch_interval;
		    else
		      FREE_STACK_RETURN (REG_EBRACE);
		  }

		GET_UNSIGNED_NUMBER (lower_bound);

		if (c == ',')
		  {
		    GET_UNSIGNED_NUMBER (upper_bound);
		    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
		  }
d3980 1
a3980 116
		  /* Interval such as `{1}' => match exactly once. */
		  upper_bound = lower_bound;

		if (lower_bound < 0 || upper_bound > RE_DUP_MAX
		    || lower_bound > upper_bound)
		  {
		    if (syntax & RE_NO_BK_BRACES)
		      goto unfetch_interval;
		    else
		      FREE_STACK_RETURN (REG_BADBR);
		  }

		if (!(syntax & RE_NO_BK_BRACES))
		  {
		    if (c != '\\') FREE_STACK_RETURN (REG_EBRACE);

		    PATFETCH (c);
		  }

		if (c != '}')
		  {
		    if (syntax & RE_NO_BK_BRACES)
		      goto unfetch_interval;
		    else
		      FREE_STACK_RETURN (REG_BADBR);
		  }

		/* We just parsed a valid interval.  */

		/* If it's invalid to have no preceding re.  */
		if (!laststart)
		  {
		    if (syntax & RE_CONTEXT_INVALID_OPS)
		      FREE_STACK_RETURN (REG_BADRPT);
		    else if (syntax & RE_CONTEXT_INDEP_OPS)
		      laststart = b;
		    else
		      goto unfetch_interval;
		  }

		/* If the upper bound is zero, don't want to succeed at
		   all; jump from `laststart' to `b + 3', which will be
		   the end of the buffer after we insert the jump.  */
		 if (upper_bound == 0)
		   {
		     GET_BUFFER_SPACE (3);
		     INSERT_JUMP (jump, laststart, b + 3);
		     b += 3;
		   }

		 /* Otherwise, we have a nontrivial interval.  When
		    we're all done, the pattern will look like:
		      set_number_at <jump count> <upper bound>
		      set_number_at <succeed_n count> <lower bound>
		      succeed_n <after jump addr> <succeed_n count>
		      <body of loop>
		      jump_n <succeed_n addr> <jump count>
		    (The upper bound and `jump_n' are omitted if
		    `upper_bound' is 1, though.)  */
		 else
		   { /* If the upper bound is > 1, we need to insert
			more at the end of the loop.  */
		     unsigned nbytes = 10 + (upper_bound > 1) * 10;

		     GET_BUFFER_SPACE (nbytes);

		     /* Initialize lower bound of the `succeed_n', even
			though it will be set during matching by its
			attendant `set_number_at' (inserted next),
			because `re_compile_fastmap' needs to know.
			Jump to the `jump_n' we might insert below.  */
		     INSERT_JUMP2 (succeed_n, laststart,
				   b + 5 + (upper_bound > 1) * 5,
				   lower_bound);
		     b += 5;

		     /* Code to initialize the lower bound.  Insert
			before the `succeed_n'.	 The `5' is the last two
			bytes of this `set_number_at', plus 3 bytes of
			the following `succeed_n'.  */
		     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
		     b += 5;

		     if (upper_bound > 1)
		       { /* More than one repetition is allowed, so
			    append a backward jump to the `succeed_n'
			    that starts this interval.

			    When we've reached this during matching,
			    we'll have matched the interval once, so
			    jump back only `upper_bound - 1' times.  */
			 STORE_JUMP2 (jump_n, b, laststart + 5,
				      upper_bound - 1);
			 b += 5;

			 /* The location we want to set is the second
			    parameter of the `jump_n'; that is `b-2' as
			    an absolute address.  `laststart' will be
			    the `set_number_at' we're about to insert;
			    `laststart+3' the number to set, the source
			    for the relative address.  But we are
			    inserting into the middle of the pattern --
			    so everything is getting moved up by 5.
			    Conclusion: (b - 2) - (laststart + 3) + 5,
			    i.e., b - laststart.

			    We insert this at the beginning of the loop
			    so that if we fail during matching, we'll
			    reinitialize the bounds.  */
			 insert_op2 (set_number_at, laststart, b - laststart,
				     upper_bound - 1, b);
			 b += 5;
		       }
		   }
		pending_exact = 0;
		beg_interval = NULL;
a3981 17
	      break;

	    unfetch_interval:
	      /* If an invalid interval, match the characters as literals.  */
	       assert (beg_interval);
	       p = beg_interval;
	       beg_interval = NULL;

	       /* normal_char and normal_backslash need `c'.  */
	       PATFETCH (c);

	       if (!(syntax & RE_NO_BK_BRACES))
		 {
		   if (p > pattern  &&	p[-1] == '\\')
		     goto normal_backslash;
		 }
	       goto normal_char;
d3984 17
a4000 29
	    /* There is no way to specify the before_dot and after_dot
	       operators.  rms says this is ok.	 --karl	 */
	    case '=':
	      BUF_PUSH (at_dot);
	      break;

	    case 's':
	      laststart = b;
	      PATFETCH (c);
	      BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
	      break;

	    case 'S':
	      laststart = b;
	      PATFETCH (c);
	      BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
	      break;

	    case 'c':
	      laststart = b;
	      PATFETCH_RAW (c);
	      BUF_PUSH_2 (categoryspec, c);
	      break;

	    case 'C':
	      laststart = b;
	      PATFETCH_RAW (c);
	      BUF_PUSH_2 (notcategoryspec, c);
	      break;
d4004 6
a4009 4
	    case 'w':
	      laststart = b;
	      BUF_PUSH (wordchar);
	      break;
d4012 6
a4017 4
	    case 'W':
	      laststart = b;
	      BUF_PUSH (notwordchar);
	      break;
d4020 5
a4024 3
	    case '<':
	      BUF_PUSH (wordbeg);
	      break;
d4026 5
a4030 3
	    case '>':
	      BUF_PUSH (wordend);
	      break;
d4032 5
a4036 3
	    case 'b':
	      BUF_PUSH (wordbound);
	      break;
d4038 5
a4042 11
	    case 'B':
	      BUF_PUSH (notwordbound);
	      break;

	    case '`':
	      BUF_PUSH (begbuf);
	      break;

	    case '\'':
	      BUF_PUSH (endbuf);
	      break;
d4044 2
a4045 3
	    case '1': case '2': case '3': case '4': case '5':
	    case '6': case '7': case '8': case '9':
	      if (syntax & RE_NO_BK_REFS)
d4047 2
d4050 2
a4051 7
	      c1 = c - '0';

	      if (c1 > regnum)
		FREE_STACK_RETURN (REG_ESUBREG);

	      /* Can't back reference to a subexpression if inside of it.  */
	      if (group_in_compile_stack (compile_stack, c1))
d4053 2
d4056 35
a4090 21
	      laststart = b;
	      BUF_PUSH_2 (duplicate, c1);
	      break;


	    case '+':
	    case '?':
	      if (syntax & RE_BK_PLUS_QM)
		goto handle_plus;
	      else
		goto normal_backslash;

	    default:
	    normal_backslash:
	      /* You might think it would be useful for \ to mean
		 not to translate; but if we don't translate it
		 it will never match anything.	*/
	      c = TRANSLATE (c);
	      goto normal_char;
	    }
	  break;
d4094 1
a4094 1
	/* Expects the character in `c'.  */
a4095 10
	  p1 = p - 1;		/* P1 points the head of C.  */
#ifdef emacs
	  if (bufp->multibyte)
	    {
	      c = STRING_CHAR (p1, pend - p1);
	      c = TRANSLATE (c);
	      /* Set P to the next character boundary.  */
	      p += MULTIBYTE_FORM_LENGTH (p1, pend - p1) - 1;
	    }
#endif
d4097 6
a4102 1
	  if (!pending_exact
d4104 2
a4105 2
	      /* If last exactn not at current position.  */
	      || pending_exact + *pending_exact + 1 != b
d4107 2
a4108 2
	      /* We have only one byte following the exactn for the count.  */
	      || *pending_exact >= (1 << BYTEWIDTH) - (p - p1)
d4110 2
a4111 2
	      /* If followed by a repetition operator.	*/
	      || (p != pend && (*p == '*' || *p == '^'))
d4113 2
a4114 2
		  ? p + 1 < pend && *p == '\\' && (p[1] == '+' || p[1] == '?')
		  : p != pend && (*p == '+' || *p == '?'))
d4116 3
a4118 3
		  && ((syntax & RE_NO_BK_BRACES)
		      ? p != pend && *p == '{'
		      : p + 1 < pend && p[0] == '\\' && p[1] == '{')))
d4122 1
a4122 1
	      laststart = b;
d4124 8
d4133 1
d4135 1
a4135 1
	    }
d4137 2
a4138 18
#ifdef emacs
	  if (! SINGLE_BYTE_CHAR_P (c))
	    {
	      unsigned char work[4], *str;
	      int i = CHAR_STRING (c, work, str);
	      int j;
	      for (j = 0; j < i; j++)
		{
		  BUF_PUSH (str[j]);
		  (*pending_exact)++;
		}
	    }
	  else
#endif
	    {
	      BUF_PUSH (c);
	      (*pending_exact)++;
	    }
d4140 1
a4140 1
	} /* switch (c) */
d4157 5
d4165 3
d4169 1
d4175 1
a4175 1
      print_compiled_pattern (bufp);
d4186 4
a4189 1
    if (fail_stack.size < re_max_failures * TYPICAL_FAILURE_SIZE)
d4191 1
a4191 1
	fail_stack.size = re_max_failures * TYPICAL_FAILURE_SIZE;
d4193 1
a4193 1
#ifdef emacs
d4196 2
a4197 2
	    = (fail_stack_elt_t *) xmalloc (fail_stack.size
					    * sizeof (fail_stack_elt_t));
d4200 4
a4203 4
	    = (fail_stack_elt_t *) xrealloc (fail_stack.stack,
					     (fail_stack.size
					      * sizeof (fail_stack_elt_t)));
#else /* not emacs */
d4206 1
a4206 2
	    = (fail_stack_elt_t *) malloc (fail_stack.size
					   * sizeof (fail_stack_elt_t));
d4209 3
a4211 4
	    = (fail_stack_elt_t *) realloc (fail_stack.stack,
					    (fail_stack.size
					     * sizeof (fail_stack_elt_t)));
#endif /* not emacs */
d4214 1
a4214 1
    regex_grow_registers (num_regs);
d4220 1
a4220 1

d4223 2
a4224 1
/* Store OP at LOC followed by two-byte integer parameter ARG.	*/
d4227 1
a4227 4
store_op1 (op, loc, arg)
    re_opcode_t op;
    unsigned char *loc;
    int arg;
d4229 1
a4229 1
  *loc = (unsigned char) op;
d4235 1
d4238 1
a4238 4
store_op2 (op, loc, arg1, arg2)
    re_opcode_t op;
    unsigned char *loc;
    int arg1, arg2;
d4240 1
a4240 1
  *loc = (unsigned char) op;
d4242 1
a4242 1
  STORE_NUMBER (loc + 3, arg2);
d4248 1
d4251 1
a4251 5
insert_op1 (op, loc, arg, end)
    re_opcode_t op;
    unsigned char *loc;
    int arg;
    unsigned char *end;
d4253 2
a4254 2
  register unsigned char *pfrom = end;
  register unsigned char *pto = end + 3;
d4259 1
a4259 1
  store_op1 (op, loc, arg);
d4264 1
d4267 2
a4268 5
insert_op2 (op, loc, arg1, arg2, end)
    re_opcode_t op;
    unsigned char *loc;
    int arg1, arg2;
    unsigned char *end;
d4270 2
a4271 2
  register unsigned char *pfrom = end;
  register unsigned char *pto = end + 5;
d4276 1
a4276 1
  store_op2 (op, loc, arg1, arg2);
d4285 2
a4286 3
at_begline_loc_p (pattern, p, syntax)
    const char *pattern, *p;
    reg_syntax_t syntax;
d4288 1
a4288 1
  const char *prev = p - 2;
d4294 1
a4294 1
       /* After an alternative?	 */
d4303 2
a4304 3
at_endline_loc_p (p, pend, syntax)
    const char *p, *pend;
    int syntax;
d4306 1
a4306 1
  const char *next = p;
d4308 1
a4308 1
  const char *next_next = p + 1 < pend ? p + 1 : 0;
d4313 1
a4313 1
	: next_backslash && next_next && *next_next == ')')
d4316 1
a4316 1
	: next_backslash && next_next && *next_next == '|');
d4319 1
d4325 2
a4326 3
group_in_compile_stack (compile_stack, regnum)
    compile_stack_type compile_stack;
    regnum_t regnum;
d4338 168
d4520 18
a4537 3
int
re_compile_fastmap (bufp)
     struct re_pattern_buffer *bufp;
d4539 1
a4539 1
  int i, j, k;
d4541 1
a4541 1
  fail_stack_type fail_stack;
a4545 2
  /* We don't push any register information onto the failure stack.  */
  unsigned num_regs = 0;
a4547 4
  unsigned char *pattern = bufp->buffer;
  unsigned long size = bufp->used;
  unsigned char *p = pattern;
  register unsigned char *pend = pattern + size;
d4549 12
d4564 1
d4567 1
a4567 1
     proven otherwise.	We set this false at the bottom of switch
a4574 7
  /* If all elements for base leading-codes in fastmap is set, this
     flag is set true.	*/
  boolean match_any_multibyte_characters = false;

  /* Maximum code of simple (single byte) character. */
  int simple_char_max;

d4578 1
a4578 1
  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.	*/
d4602 1
a4602 1
      /* We should never be about to go beyond the end of the pattern.	*/
d4608 5
a4612 5
	/* I guess the idea here is to simply not bother with a fastmap
	   if a backreference is used, since it's too hard to figure out
	   the fastmap for the corresponding group.  Setting
	   `can_be_null' stops `re_search_2' from using the fastmap, so
	   that is all we do.  */
d4615 1
a4615 1
	  goto done;
d4619 1
a4619 1
	 with `break'.	*/
d4621 5
d4627 5
d4634 1
d4636 12
a4647 4

#ifndef emacs
	case charset:
	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
d4649 1
a4649 1
	      fastmap[j] = 1;
d4656 1
a4656 1
	    fastmap[j] = 1;
d4660 2
a4661 2
	      fastmap[j] = 1;
	  break;
d4676 1
a4676 45
#else  /* emacs */
	case charset:
	  for (j = CHARSET_BITMAP_SIZE (&p[-1]) * BYTEWIDTH - 1, p++;
	       j >= 0; j--)
	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
	      fastmap[j] = 1;

	  if (CHARSET_RANGE_TABLE_EXISTS_P (&p[-2])
	      && match_any_multibyte_characters == false)
	    {
	      /* Set fastmap[I] 1 where I is a base leading code of each
		 multibyte character in the range table. */
	      int c, count;

	      /* Make P points the range table. */
	      p += CHARSET_BITMAP_SIZE (&p[-2]);

	      /* Extract the number of ranges in range table into
		 COUNT.	 */
	      EXTRACT_NUMBER_AND_INCR (count, p);
	      for (; count > 0; count--, p += 2 * 3) /* XXX */
		{
		  /* Extract the start of each range.  */
		  EXTRACT_CHARACTER (c, p);
		  j = CHAR_CHARSET (c);
		  fastmap[CHARSET_LEADING_CODE_BASE (j)] = 1;
		}
	    }
	  break;


	case charset_not:
	  /* Chars beyond end of bitmap are possible matches.
	     All the single-byte codes can occur in multibyte buffers.
	     So any that are not listed in the charset
	     are possible matches, even in multibyte buffers.  */
	  simple_char_max = (1 << BYTEWIDTH);
	  for (j = CHARSET_BITMAP_SIZE (&p[-1]) * BYTEWIDTH;
	       j < simple_char_max; j++)
	    fastmap[j] = 1;

	  for (j = CHARSET_BITMAP_SIZE (&p[-1]) * BYTEWIDTH - 1, p++;
	       j >= 0; j--)
	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
	      fastmap[j] = 1;
d4678 1
a4678 47
	  if (bufp->multibyte)
	    /* Any character set can possibly contain a character
	       which doesn't match the specified set of characters.  */
	    {
	    set_fastmap_for_multibyte_characters:
	      if (match_any_multibyte_characters == false)
		{
		  for (j = 0x80; j < 0xA0; j++)	/* XXX */
		    if (BASE_LEADING_CODE_P (j))
		      fastmap[j] = 1;
		  match_any_multibyte_characters = true;
		}
	    }
	  break;


	case wordchar:
	  /* All the single-byte codes can occur in multibyte buffers,
	     and they may have word syntax.  So do consider them.  */
	  simple_char_max = (1 << BYTEWIDTH);
	  for (j = 0; j < simple_char_max; j++)
	    if (SYNTAX (j) == Sword)
	      fastmap[j] = 1;

	  if (bufp->multibyte)
	    /* Any character set can possibly contain a character
	       whose syntax is `Sword'.	 */
	    goto set_fastmap_for_multibyte_characters;
	  break;


	case notwordchar:
	  /* All the single-byte codes can occur in multibyte buffers,
	     and they may not have word syntax.  So do consider them.  */
	  simple_char_max = (1 << BYTEWIDTH);
	  for (j = 0; j < simple_char_max; j++)
	    if (SYNTAX (j) != Sword)
	      fastmap[j] = 1;

	  if (bufp->multibyte)
	    /* Any character set can possibly contain a character
	       whose syntax is not `Sword'.  */
	    goto set_fastmap_for_multibyte_characters;
	  break;
#endif

	case anychar:
d4682 2
a4683 8
	    /* `.' matches anything, except perhaps newline.
	       Even in a multibyte buffer, it should match any
	       conceivable byte value for the fastmap.  */
	    if (bufp->multibyte)
	      match_any_multibyte_characters = true;

	    simple_char_max = (1 << BYTEWIDTH);
	    for (j = 0; j < simple_char_max; j++)
d4691 1
a4691 1
	       then the fastmap is irrelevant.	Something's wrong here.	 */
d4700 1
a4700 11
	case wordbound:
	case notwordbound:
	case wordbeg:
	case wordend:
	case notsyntaxspec:
	case syntaxspec:
	  /* This match depends on text properties.  These end with
	     aborting optimizations.  */
	  bufp->can_be_null = 1;
	  goto done;
#if 0
d4702 1
a4702 2
	  simple_char_max = bufp->multibyte ? 0x80 : (1 << BYTEWIDTH);
	  for (j = 0; j < simple_char_max; j++)
d4705 1
a4706 5
	  if (bufp->multibyte)
	    /* Any character set can possibly contain a character
	       whose syntax is K.  */
	    goto set_fastmap_for_multibyte_characters;
	  break;
d4710 2
a4711 32
	  simple_char_max = bufp->multibyte ? 0x80 : (1 << BYTEWIDTH);
	  for (j = 0; j < simple_char_max; j++)
	    if (SYNTAX (j) != (enum syntaxcode) k)
	      fastmap[j] = 1;

	  if (bufp->multibyte)
	    /* Any character set can possibly contain a character
	       whose syntax is not K.  */
	    goto set_fastmap_for_multibyte_characters;
	  break;
#endif


	case categoryspec:
	  k = *p++;
	  simple_char_max = (1 << BYTEWIDTH);
	  for (j = 0; j < simple_char_max; j++)
	    if (CHAR_HAS_CATEGORY (j, k))
	      fastmap[j] = 1;

	  if (bufp->multibyte)
	    /* Any character set can possibly contain a character
	       whose category is K.  */
	    goto set_fastmap_for_multibyte_characters;
	  break;


	case notcategoryspec:
	  k = *p++;
	  simple_char_max = (1 << BYTEWIDTH);
	  for (j = 0; j < simple_char_max; j++)
	    if (!CHAR_HAS_CATEGORY (j, k))
d4713 1
a4714 5
	  if (bufp->multibyte)
	    /* Any character set can possibly contain a character
	       whose category is not K.	 */
	    goto set_fastmap_for_multibyte_characters;
	  break;
d4717 1
a4717 1
	 `continue'.  */
d4723 1
a4723 1
	  continue;
d4727 3
a4729 3
	case no_op:
	case begline:
	case endline:
a4731 1
#ifndef emacs
d4736 2
a4737 3
#endif
	case push_dummy_failure:
	  continue;
d4741 1
a4741 1
	case pop_failure_jump:
d4744 1
a4744 1
	case jump_past_alt:
d4746 1
a4746 1
	  EXTRACT_NUMBER_AND_INCR (j, p);
d4751 6
a4756 6
	  /* Jump backward implies we just went through the body of a
	     loop and matched nothing.	Opcode jumped to should be
	     `on_failure_jump' or `succeed_n'.	Just treat it like an
	     ordinary jump.  For a * loop, it has pushed its failure
	     point already; if so, discard that as redundant.  */
	  if ((re_opcode_t) *p != on_failure_jump
d4760 3
a4762 3
	  p++;
	  EXTRACT_NUMBER_AND_INCR (j, p);
	  p += j;
d4764 2
a4765 2
	  /* If what's on the stack is where we are now, pop it.  */
	  if (!FAIL_STACK_EMPTY ()
d4767 1
a4767 1
	    fail_stack.avail--;
d4769 1
a4769 1
	  continue;
d4772 2
a4773 2
	case on_failure_jump:
	case on_failure_keep_string_jump:
d4775 1
a4775 1
	  EXTRACT_NUMBER_AND_INCR (j, p);
d4777 10
a4786 10
	  /* For some patterns, e.g., `(a?)?', `p+j' here points to the
	     end of the pattern.  We don't want to push such a point,
	     since when we restore it above, entering the switch will
	     increment `p' past the end of the pattern.	 We don't need
	     to push such a point since we obviously won't find any more
	     fastmap entries beyond `pend'.  Such a pattern can match
	     the null string, though.  */
	  if (p + j < pend)
	    {
	      if (!PUSH_PATTERN_OP (p + j, fail_stack))
d4791 3
a4793 3
	    }
	  else
	    bufp->can_be_null = 1;
d4795 4
a4798 4
	  if (succeed_n_p)
	    {
	      EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.	*/
	      succeed_n_p = false;
d4801 1
a4801 1
	  continue;
d4805 2
a4806 2
	  /* Get to the number of times to succeed.  */
	  p += 2;
d4808 3
a4810 3
	  /* Increment p past the n for when k != 0.  */
	  EXTRACT_NUMBER_AND_INCR (k, p);
	  if (k == 0)
d4812 5
a4816 5
	      p -= 4;
	      succeed_n_p = true;  /* Spaghetti code alert.  */
	      goto handle_on_failure_jump;
	    }
	  continue;
d4820 2
a4821 2
	  p += 4;
	  continue;
d4825 1
a4825 1
	case stop_memory:
d4831 2
a4832 2
	  abort (); /* We have listed all the cases.  */
	} /* switch *p++ */
d4835 5
a4839 5
	 characters for one path of the pattern -- and that the empty
	 string does not match.	 We need not follow this path further.
	 Instead, look at the next alternative (remembered on the
	 stack), or quit if no more.  The test at the top of the loop
	 does these things.  */
d4845 1
a4845 1
     pattern is empty).	 */
d4851 13
d4865 3
d4869 1
d4884 4
a4887 5
re_set_registers (bufp, regs, num_regs, starts, ends)
    struct re_pattern_buffer *bufp;
    struct re_registers *regs;
    unsigned num_regs;
    regoff_t *starts, *ends;
d4903 3
d4907 1
a4907 1
/* Searching routines.	*/
d4910 1
a4910 1
   doesn't let you say where to stop matching. */
d4913 4
a4916 5
re_search (bufp, string, size, startpos, range, regs)
     struct re_pattern_buffer *bufp;
     const char *string;
     int size, startpos, range;
     struct re_registers *regs;
d4921 3
a4924 7
/* End address of virtual concatenation of string.  */
#define STOP_ADDR_VSTRING(P)				\
  (((P) >= size1 ? string2 + size2 : string1 + size1))

/* Address of POS in the concatenation of virtual string. */
#define POS_ADDR_VSTRING(POS)					\
  (((POS) >= size1 ? string2 - size1 : string1) + (POS))
d4948 67
a5014 8
re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     int size1, size2;
     int startpos;
     int range;
     struct re_registers *regs;
     int stop;
d5021 10
a5030 4
  int anchored_start = 0;

  /* Nonzero if we have to concern multibyte character.	 */
  int multibyte = bufp->multibyte;
d5045 6
a5050 2
     search for a pattern anchored at beginning of buffer.  */
  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
d5055 1
a5055 1
	range = 0;
d5063 2
a5064 2
      range = PT_BYTE - BEGV_BYTE - startpos;
      if (range < 0)
d5074 73
a5146 9
  /* See whether the pattern is anchored.  */
  if (bufp->buffer[0] == begline)
    anchored_start = 1;

#ifdef emacs
  gl_state.object = re_match_object;
  {
    int adjpos = NILP (re_match_object) || BUFFERP (re_match_object);
    int charpos = SYNTAX_TABLE_BYTE_TO_CHAR (startpos + adjpos);
a5147 3
    SETUP_SYNTAX_TABLE_FOR_OBJECT (re_match_object, charpos, 1);
  }
#endif
a5151 13
      /* If the pattern is anchored,
	 skip quickly past places we cannot match.
	 We don't bother to treat startpos == 0 specially
	 because that case doesn't repeat.  */
      if (anchored_start && startpos > 0)
	{
	  if (! (bufp->newline_anchor
		 && ((startpos <= size1 ? string1[startpos - 1]
		      : string2[startpos - size1 - 1])
		     == '\n')))
	    goto advance;
	}

d5153 3
a5155 3
	 cannot be the start of a match.  If the pattern can match the
	 null string, however, we don't need to skip characters; we want
	 the first null string.	 */
d5158 1
a5158 6
	  register const char *d;
	  register unsigned int buf_ch;

	  d = POS_ADDR_VSTRING (startpos);

	  if (range > 0)	/* Searching forwards.	*/
d5160 1
d5164 2
a5165 14
	      if (startpos < size1 && startpos + range >= size1)
		lim = range - (size1 - startpos);

	      /* Written out as an if-else to avoid testing `translate'
		 inside the loop.  */
	      if (RE_TRANSLATE_P (translate))
		{
		  if (multibyte)
		    while (range > lim)
		      {
			int buf_charlen;

			buf_ch = STRING_CHAR_AND_LENGTH (d, range - lim,
							 buf_charlen);
d5167 1
a5167 4
			buf_ch = RE_TRANSLATE (translate, buf_ch);
			if (buf_ch >= 0400
			    || fastmap[buf_ch])
			  break;
d5169 7
a5175 12
			range -= buf_charlen;
			d += buf_charlen;
		      }
		  else
		    while (range > lim
			   && !fastmap[(unsigned char)
				       RE_TRANSLATE (translate, (unsigned char) *d)])
		      {
			d++;
			range--;
		      }
		}
d5177 2
a5178 5
		while (range > lim && !fastmap[(unsigned char) *d])
		  {
		    d++;
		    range--;
		  }
d5182 1
a5182 1
	  else				/* Searching backwards.	 */
d5184 3
a5186 7
	      int room = (size1 == 0 || startpos >= size1
			  ? size2 + size1 - startpos
			  : size1 - startpos);

	      buf_ch = STRING_CHAR (d, room);
	      if (RE_TRANSLATE_P (translate))
		buf_ch = RE_TRANSLATE (translate, buf_ch);
d5188 1
a5188 2
	      if (! (buf_ch >= 0400
		     || fastmap[buf_ch]))
d5195 18
a5212 2
	  && !bufp->can_be_null)
	return -1;
a5213 2
      val = re_match_2_internal (bufp, string1, size1, string2, size2,
				 startpos, regs, stop);
d5215 1
a5215 1
#ifdef C_ALLOCA
d5217 1
a5217 1
#endif
d5221 6
a5226 1
	return startpos;
d5229 6
a5234 1
	return -2;
d5238 1
a5238 1
	break;
d5240 4
a5243 21
	{
	  /* Update STARTPOS to the next character boundary.  */
	  if (multibyte)
	    {
	      const unsigned char *p
		= (const unsigned char *) POS_ADDR_VSTRING (startpos);
	      const unsigned char *pend
		= (const unsigned char *) STOP_ADDR_VSTRING (startpos);
	      int len = MULTIBYTE_FORM_LENGTH (p, pend - p);

	      range -= len;
	      if (range < 0)
		break;
	      startpos += len;
	    }
	  else
	    {
	      range--;
	      startpos++;
	    }
	}
d5245 7
a5251 20
	{
	  range++;
	  startpos--;

	  /* Update STARTPOS to the previous character boundary.  */
	  if (multibyte)
	    {
	      const unsigned char *p
		= (const unsigned char *) POS_ADDR_VSTRING (startpos);
	      int len = 0;

	      /* Find the head of multibyte form.  */
	      while (!CHAR_HEAD_P (*p))
		p--, len++;

	      /* Adjust it. */
#if 0				/* XXX */
	      if (MULTIBYTE_FORM_LENGTH (p, len + 1) != (len + 1))
		;
	      else
a5252 10
		{
		  range += len;
		  if (range > 0)
		    break;

		  startpos -= len;
		}
	    }
	}
    }
d5254 1
a5254 8
} /* re_search_2 */

/* Declarations and macros for re_match_2.  */

static int bcmp_translate ();
static boolean alt_match_null_string_p (),
	       common_op_match_null_string_p (),
	       group_match_null_string_p ();
d5256 11
d5269 1
a5269 1
#define POINTER_TO_OFFSET(ptr)			\
d5273 1
d5282 1
a5282 1
  while (d == dend)							\
d5285 4
a5288 4
      if (dend == end_match_2)						\
	goto fail;							\
      /* End of string1 => advance to string2.	*/			\
      d = string2;							\
a5291 1

d5293 1
a5293 1
   of `string1' and `string2'.	If only one string, it's `string2'.  */
d5302 9
a5310 1
#define WORDCHAR_P(d)							\
d5312 1
a5312 1
	   : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
d5314 1
a5316 9

/* The comment at case wordbound is following one, but we don't use
   AT_WORD_BOUNDARY anymore to support multibyte form.

   The DEC Alpha C compiler 3.x generates incorrect code for the
   test	 WORDCHAR_P (d - 1) != WORDCHAR_P (d)  in the expansion of
   AT_WORD_BOUNDARY, so this code is disabled.	Expanding the
   macro and introducing temporary variables works around the bug.  */

d5327 23
a5349 2
#define FREE_VAR(var) if (var) { REGEX_FREE (var); var = NULL; } else
#define FREE_VARIABLES()						\
d5362 1
d5364 14
a5377 1
#define FREE_VARIABLES() ((void)0) /* Do nothing!  But inhibit gcc warning.  */
d5380 1
a5380 1
/* These values must meet several constraints.	They must not be valid
d5383 1
a5383 1
   use numbers larger than 255.	 They must differ by 1, because of
d5386 1
a5386 1
   to actually save any registers when none are active.	 */
d5390 1
d5393 1
a5393 1
#ifndef emacs	/* Emacs never uses this.  */
d5397 17
a5413 10
re_match (bufp, string, size, pos, regs)
     struct re_pattern_buffer *bufp;
     const char *string;
     int size, pos;
     struct re_registers *regs;
{
  int result = re_match_2_internal (bufp, NULL, 0, string, size,
				    pos, regs, size);
#ifndef REGEX_MALLOC	/* CVS */
#ifdef C_ALLOCA		/* CVS */
d5415 2
a5416 2
#endif			/* CVS */
#endif			/* CVS */
d5419 3
d5424 15
a5438 5
#ifdef emacs
/* In Emacs, this is the string or buffer in which we
   are matching.  It is used for looking up syntax properties.	*/
Lisp_Object re_match_object;
#endif
d5446 1
a5446 1
   store offsets for the substring each group matched in REGS.	See the
d5450 1
a5450 1
   failure stack overflowing).	Otherwise, we return the length of the
d5454 5
a5458 7
re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     int size1, size2;
     int pos;
     struct re_registers *regs;
     int stop;
d5461 9
d5471 9
a5479 6
#ifdef emacs
  int charpos;
  int adjpos = NILP (re_match_object) || BUFFERP (re_match_object);
  gl_state.object = re_match_object;
  charpos = SYNTAX_TABLE_BYTE_TO_CHAR (pos + adjpos);
  SETUP_SYNTAX_TABLE_FOR_OBJECT (re_match_object, charpos, 1);
d5482 46
a5527 8
  result = re_match_2_internal (bufp, string1, size1, string2, size2,
				pos, regs, stop);
#ifndef REGEX_MALLOC	/* CVS */
#ifdef C_ALLOCA		/* CVS */
  alloca (0);
#endif			/* CVS */
#endif			/* CVS */
  return result;
d5529 1
d5532 21
a5552 1
   afterwards.	*/
d5554 7
a5560 7
re_match_2_internal (bufp, string1, size1, string2, size2, pos, regs, stop)
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     int size1, size2;
     int pos;
     struct re_registers *regs;
     int stop;
d5564 7
a5570 1
  unsigned char *p1;
d5573 1
a5573 1
  const char *end1, *end2;
d5576 2
a5577 2
     each to consider matching.	 */
  const char *end_match_1, *end_match_2;
d5580 1
a5580 1
  const char *d, *dend;
d5583 7
a5589 2
  unsigned char *p = bufp->buffer;
  register unsigned char *pend = p + bufp->used;
d5593 1
a5593 1
  unsigned char *just_past_start_mem = 0;
d5595 1
a5595 1
  /* We use this to map every character in the string.	*/
a5597 3
  /* Nonzero if we have to concern multibyte character.	 */
  int multibyte = bufp->multibyte;

d5606 3
a5608 3
     it gets discarded and the next next one is tried.	*/
#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.	 */
  fail_stack_type fail_stack;
d5611 1
a5611 1
  static unsigned failure_id = 0;
d5615 1
d5619 1
d5622 1
a5622 1
     return, for use in backreferences.	 The number here includes
d5624 1
a5624 1
  unsigned num_regs = bufp->re_nsub + 1;
d5627 2
a5628 2
  unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;
  unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;
d5638 1
a5638 1
  const char **regstart, **regend;
d5647 1
a5647 1
  const char **old_regstart, **old_regend;
d5655 3
a5657 3
     loop their register is in.	 */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.	 */
  register_info_type *reg_info;
d5666 1
a5666 1
  const char **best_regstart, **best_regend;
d5671 1
a5671 1
     else (see below).	Also, we never need info about register 0 for
d5677 1
a5677 1
  const char *match_end = NULL;
d5684 2
a5685 2
  const char **reg_dummy;
  register_info_type *reg_info_dummy;
d5693 82
d5787 9
a5795 9
      regstart = REGEX_TALLOC (num_regs, const char *);
      regend = REGEX_TALLOC (num_regs, const char *);
      old_regstart = REGEX_TALLOC (num_regs, const char *);
      old_regend = REGEX_TALLOC (num_regs, const char *);
      best_regstart = REGEX_TALLOC (num_regs, const char *);
      best_regend = REGEX_TALLOC (num_regs, const char *);
      reg_info = REGEX_TALLOC (num_regs, register_info_type);
      reg_dummy = REGEX_TALLOC (num_regs, const char *);
      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
d5798 5
a5802 5
	    && best_regstart && best_regend && reg_dummy && reg_info_dummy))
	{
	  FREE_VARIABLES ();
	  return -2;
	}
d5807 1
a5807 1
	 `FREE_VARIABLES' doesn't try to free them.  */
d5809 2
a5810 2
	= best_regend = reg_dummy = NULL;
      reg_info = reg_info_dummy = (register_info_type *) NULL;
d5815 3
d5819 1
d5825 51
d5879 1
a5879 1
  for (mcnt = 1; mcnt < num_regs; mcnt++)
d5882 1
a5882 1
	= old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
d5891 1
a5891 1
     `string1' is null.	 */
d5894 34
a5927 4
      string2 = string1;
      size2 = size1;
      string1 = 0;
      size1 = 0;
d5929 1
a5929 4
  end1 = string1 + size1;
  end2 = string2 + size2;

  /* Compute where to stop matching, within the two strings.  */
d5940 1
d5948 20
d5978 1
d5980 1
a5980 1
  DEBUG_PRINT1 ("The compiled pattern is: ");
d5986 1
a5986 1
  /* This loops over pattern commands.	It exits by returning from the
d5991 3
d5995 1
d5997 3
d6001 6
a6006 1
	{ /* End of pattern means we might have succeeded.  */
d6021 1
a6021 1
		 with the previous declaration.	 */
d6040 1
a6040 1
		      for (mcnt = 1; mcnt < num_regs; mcnt++)
d6059 1
a6059 1
		     not consecutive in memory.	 */
d6064 1
a6064 1
			   ? end_match_1 : end_match_2);
d6066 1
a6066 1
		  for (mcnt = 1; mcnt < num_regs; mcnt++)
a6075 1

d6079 1
a6079 1
	      /* Have the register data arrays been allocated?	*/
d6081 1
a6081 1
		{ /* No.  So allocate them with malloc.	 We need one
d6113 1
a6113 1
		     warning under GCC when assert expands to nothing.	*/
d6123 8
d6134 1
d6139 2
a6140 1
	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
d6157 2
a6158 2
		 -1 at the end.	 */
	      for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
d6167 8
d6176 2
a6177 2
			    ? string1
			    : string2 - size1);
d6185 2
a6186 1
      /* Otherwise match next pattern command.	*/
d6189 6
a6194 5
	/* Ignore these.  Used to ignore the n of succeed_n's which
	   currently have n == 0.  */
	case no_op:
	  DEBUG_PRINT1 ("EXECUTING no_op.\n");
	  break;
d6196 2
a6197 2
	case succeed:
	  DEBUG_PRINT1 ("EXECUTING succeed.\n");
d6200 7
a6206 4
	/* Match the next n pattern characters exactly.	 The following
	   byte in the pattern defines n, and the n bytes after that
	   are the characters to match.	 */
	case exactn:
d6208 1
a6208 1
	  DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
d6210 3
a6212 3
	  /* This is written out as an if-else so we don't waste time
	     testing `translate' inside the loop.  */
	  if (RE_TRANSLATE_P (translate))
d6214 22
a6235 31
#ifdef emacs
	      if (multibyte)
		do
		  {
		    int pat_charlen, buf_charlen;
		    unsigned int pat_ch, buf_ch;

		    PREFETCH ();
		    pat_ch = STRING_CHAR_AND_LENGTH (p, pend - p, pat_charlen);
		    buf_ch = STRING_CHAR_AND_LENGTH (d, dend - d, buf_charlen);

		    if (RE_TRANSLATE (translate, buf_ch)
			!= pat_ch)
		      goto fail;

		    p += pat_charlen;
		    d += buf_charlen;
		    mcnt -= pat_charlen;
		  }
		while (mcnt > 0);
	      else
#endif /* not emacs */
		do
		  {
		    PREFETCH ();
		    if ((unsigned char) RE_TRANSLATE (translate, (unsigned char) *d)
			!= (unsigned char) *p++)
		      goto fail;
		    d++;
		  }
		while (--mcnt);
d6242 1
a6242 1
		  if (*d++ != (char) *p++) goto fail;
d6247 17
a6263 1
	  break;
d6266 2
a6267 2
	/* Match any character except possibly a newline or a null.  */
	case anychar:
d6269 12
a6280 2
	    int buf_charlen;
	    unsigned int buf_ch;
d6282 22
a6303 1
	    DEBUG_PRINT1 ("EXECUTING anychar.\n");
d6305 12
a6316 1
	    PREFETCH ();
d6318 3
a6320 5
#ifdef emacs
	    if (multibyte)
	      buf_ch = STRING_CHAR_AND_LENGTH (d, dend - d, buf_charlen);
	    else
#endif /* not emacs */
d6322 20
a6341 2
		buf_ch = (unsigned char) *d;
		buf_charlen = 1;
d6343 47
d6391 71
a6461 1
	    buf_ch = TRANSLATE (buf_ch);
d6463 30
a6492 5
	    if ((!(bufp->syntax & RE_DOT_NEWLINE)
		 && buf_ch == '\n')
		|| ((bufp->syntax & RE_DOT_NOT_NULL)
		    && buf_ch == '\000'))
	      goto fail;
d6494 8
a6501 5
	    SET_REGS_MATCHED ();
	    DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
	    d += buf_charlen;
	  }
	  break;
d6503 14
d6518 14
a6531 6
	case charset:
	case charset_not:
	  {
	    register unsigned int c;
	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
	    int len;
d6533 10
a6542 3
	    /* Start of actual range_table, or end of bitmap if there is no
	       range table.  */
	    unsigned char *range_table;
d6544 7
a6550 2
	    /* Nonzero if there is range table.	 */
	    int range_table_exists;
d6552 1
a6552 2
	    /* Number of ranges of range table.	 Not in bytes.	*/
	    int count;
d6554 3
a6556 1
	    DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
d6558 4
a6561 2
	    PREFETCH ();
	    c = (unsigned char) *d;
d6563 4
a6566 4
	    range_table = CHARSET_RANGE_TABLE (&p[-1]); /* Past the bitmap.  */
	    range_table_exists = CHARSET_RANGE_TABLE_EXISTS_P (&p[-1]);
	    if (range_table_exists)
	      EXTRACT_NUMBER_AND_INCR (count, range_table);
d6568 41
a6608 1
	      count = 0;
d6610 4
a6613 2
	    if (multibyte && BASE_LEADING_CODE_P (c))
	      c = STRING_CHAR_AND_LENGTH (d, dend - d, len);
d6615 8
a6622 8
	    if (SINGLE_BYTE_CHAR_P (c))
	      {			/* Lookup bitmap.  */
		c = TRANSLATE (c); /* The character to match.  */
		len = 1;

		/* Cast to `unsigned' instead of `unsigned char' in
		   case the bit list is a full 32 bytes long.  */
		if (c < (unsigned) (CHARSET_BITMAP_SIZE (&p[-1]) * BYTEWIDTH)
a6624 3
	      }
	    else if (range_table_exists)
	      CHARSET_LOOKUP_RANGE_TABLE_RAW (not, c, range_table, count);
d6626 1
a6626 1
	    p = CHARSET_RANGE_TABLE_END (range_table, count);
d6629 2
a6630 1

d6632 2
a6633 2
	    d += len;
	    break;
d6637 8
a6644 7
	/* The beginning of a group is represented by start_memory.
	   The arguments are the register number in the next byte, and the
	   number of groups inner to this one in the next.  The text
	   matched within the group is recorded (in the internal
	   registers data structure) under the register number.	 */
	case start_memory:
	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
d6646 1
a6646 1
	  /* Find out if this group can match the empty string.	 */
d6649 12
a6660 12
	  if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
	    REG_MATCH_NULL_STRING_P (reg_info[*p])
	      = group_match_null_string_p (&p1, pend, reg_info);

	  /* Save the position in the string where we were the last time
	     we were at this open-group operator in case the group is
	     operated upon by a repetition operator, e.g., with `(a*)*b'
	     against `ab'; then we want to ignore where we are now in
	     the string in case this attempt to match fails.  */
	  old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
			     ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
			     : regstart[*p];
d6664 1
a6664 1
	  regstart[*p] = d;
d6667 2
a6668 2
	  IS_ACTIVE (reg_info[*p]) = 1;
	  MATCHED_SOMETHING (reg_info[*p]) = 0;
d6673 2
a6674 2
	  /* This is the new highest active register.  */
	  highest_active_reg = *p;
d6676 4
a6679 4
	  /* If nothing was active before, this is the new lowest active
	     register.	*/
	  if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
	    lowest_active_reg = *p;
d6681 2
a6682 2
	  /* Move past the register number and inner group count.  */
	  p += 2;
d6685 1
a6685 2
	  break;

a6686 5
	/* The stop_memory opcode represents the end of a group.  Its
	   arguments are the same as start_memory's: the register
	   number, and the number of inner groups.  */
	case stop_memory:
	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
d6688 14
a6701 7
	  /* We need to save the string position the last time we were at
	     this close-group operator in case the group is operated
	     upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
	     against `aba'; then we want to ignore where we are now in
	     the string in case this attempt to match fails.  */
	  old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
			   ? REG_UNSET (regend[*p]) ? d : regend[*p]
d6706 1
a6706 1
	  regend[*p] = d;
d6709 2
a6710 2
	  /* This register isn't active anymore.  */
	  IS_ACTIVE (reg_info[*p]) = 0;
d6715 23
a6737 23
	  /* If this was the only register active, nothing is active
	     anymore.  */
	  if (lowest_active_reg == highest_active_reg)
	    {
	      lowest_active_reg = NO_LOWEST_ACTIVE_REG;
	      highest_active_reg = NO_HIGHEST_ACTIVE_REG;
	    }
	  else
	    { /* We must scan for the new highest active register, since
		 it isn't necessarily one less than now: consider
		 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
		 new highest active register is 1.  */
	      unsigned char r = *p - 1;
	      while (r > 0 && !IS_ACTIVE (reg_info[r]))
		r--;

	      /* If we end up at register zero, that means that we saved
		 the registers as the result of an `on_failure_jump', not
		 a `start_memory', and we jumped to past the innermost
		 `stop_memory'.	 For example, in ((.)*) we save
		 registers 1 and 2 as a result of the *, but when we pop
		 back to the second ), we are at the stop_memory 1.
		 Thus, nothing is active.  */
d6739 7
a6745 7
		{
		  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
		  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
		}
	      else
		highest_active_reg = r;
	    }
d6747 7
a6753 7
	  /* If just failed to match something this time around with a
	     group that's operated on by a repetition operator, try to
	     force exit from the ``loop'', and restore the register
	     information for this group that we had before trying this
	     last match.  */
	  if ((!MATCHED_SOMETHING (reg_info[*p])
	       || just_past_start_mem == p - 1)
d6755 2
a6756 2
	    {
	      boolean is_a_jump_n = false;
d6758 5
a6762 5
	      p1 = p + 2;
	      mcnt = 0;
	      switch ((re_opcode_t) *p1++)
		{
		  case jump_n:
d6764 1
a6764 1
		  case pop_failure_jump:
d6768 1
a6768 1
		    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
d6770 2
a6771 2
		      p1 += 2;
		    break;
d6773 3
a6775 3
		  default:
		    /* do nothing */ ;
		}
d6778 8
a6785 7
	      /* If the next operation is a jump backwards in the pattern
		 to an on_failure_jump right before the start_memory
		 corresponding to this stop_memory, exit from the loop
		 by forcing a failure after pushing on the stack the
		 on_failure_jump's jump in the pattern, and d.	*/
	      if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
		  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
d6787 9
a6795 9
		  /* If this group ever matched anything, then restore
		     what its registers were before trying this last
		     failed match, e.g., with `(a*)*b' against `ab' for
		     regstart[1], and, e.g., with `((a*)*(b*)*)*'
		     against `aba' for regend[3].

		     Also restore the registers for inner groups for,
		     e.g., `((a*)(b*))*' against `aba' (register 3 would
		     otherwise get trashed).  */
d6797 1
a6797 1
		  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
d6801 1
a6801 1
		      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
d6804 10
a6813 9
		      for (r = *p; r < *p + *(p + 1); r++)
			{
			  regstart[r] = old_regstart[r];

			  /* xx why this test?	*/
			  if (old_regend[r] >= regstart[r])
			    regend[r] = old_regend[r];
			}
		    }
d6815 2
a6816 2
		  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
		  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
d6818 3
a6820 3
		  goto fail;
		}
	    }
d6822 3
a6824 3
	  /* Move past the register number and the inner group count.  */
	  p += 2;
	  break;
d6828 2
a6829 2
	   followed by the numeric value of <digit> as the register number.  */
	case duplicate:
d6831 2
a6832 2
	    register const char *d2, *dend2;
	    int regno = *p++;	/* Get which register to match against.	 */
d6835 11
a6845 11
	    /* Can't back reference a group which we've never matched.	*/
	    if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
	      goto fail;

	    /* Where in input to try to start matching.	 */
	    d2 = regstart[regno];

	    /* Where to stop matching; if both the place to start and
	       the place to stop matching are in the same string, then
	       set to the place to stop, otherwise, for now have to use
	       the end of the first string.  */
d6847 1
a6847 1
	    dend2 = ((FIRST_STRING_P (regstart[regno])
d6853 1
a6853 1
		   contents.  */
d6859 3
a6861 3
		    /* End of string1 => advance to string2. */
		    d2 = string2;
		    dend2 = regend[regno];
d6873 2
a6874 2
		   one shot, so, if necessary, adjust the count.  */
		if (mcnt > dend2 - d2)
d6878 4
a6881 4
		   past them.  */
		if (RE_TRANSLATE_P (translate)
		    ? bcmp_translate (d, d2, mcnt, translate)
		    : bcmp (d, d2, mcnt))
d6885 1
a6885 1
		/* Do this because we've match some characters.	 */
d6889 1
a6889 1
	  break;
d6892 5
a6896 5
	/* begline matches the empty string at the beginning of the string
	   (unless `not_bol' is set in `bufp'), and, if
	   `newline_anchor' is set, after newlines.  */
	case begline:
	  DEBUG_PRINT1 ("EXECUTING begline.\n");
d6898 13
a6910 10
	  if (AT_STRINGS_BEG (d))
	    {
	      if (!bufp->not_bol) break;
	    }
	  else if (d[-1] == '\n' && bufp->newline_anchor)
	    {
	      break;
	    }
	  /* In all other cases, we fail.  */
	  goto fail;
d6913 3
a6915 3
	/* endline is the dual of begline.  */
	case endline:
	  DEBUG_PRINT1 ("EXECUTING endline.\n");
d6917 7
a6923 4
	  if (AT_STRINGS_END (d))
	    {
	      if (!bufp->not_eol) break;
	    }
d6925 7
a6931 7
	  /* We have to ``prefetch'' the next character.  */
	  else if ((d == end1 ? *string2 : *d) == '\n'
		   && bufp->newline_anchor)
	    {
	      break;
	    }
	  goto fail;
d6935 7
a6941 5
	case begbuf:
	  DEBUG_PRINT1 ("EXECUTING begbuf.\n");
	  if (AT_STRINGS_BEG (d))
	    break;
	  goto fail;
d6945 2
a6946 2
	case endbuf:
	  DEBUG_PRINT1 ("EXECUTING endbuf.\n");
d6948 4
a6951 2
	    break;
	  goto fail;
d6954 18
a6971 18
	/* on_failure_keep_string_jump is used to optimize `.*\n'.  It
	   pushes NULL as the value for the string on the stack.  Then
	   `pop_failure_point' will keep the current value for the
	   string, instead of restoring it.  To see why, consider
	   matching `foo\nbar' against `.*\n'.	The .* matches the foo;
	   then the . fails against the \n.  But the next thing we want
	   to do is match the \n against the \n; if we restored the
	   string value, we would be back at the foo.

	   Because this is used only in specific cases, we don't need to
	   check all the things that `on_failure_jump' does, to make
	   sure the right things get saved on the stack.  Hence we don't
	   share its code.  The only reason to push anything on the
	   stack at all is that otherwise we would have to change
	   `anychar's code to do something besides goto fail in this
	   case; that seems worse than this.  */
	case on_failure_keep_string_jump:
	  DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
d6973 6
a6978 2
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);
	  DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
d6980 2
a6981 2
	  PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
	  break;
d6986 13
a6998 13
	   Each alternative starts with an on_failure_jump that points
	   to the beginning of the next alternative.  Each alternative
	   except the last ends with a jump that in effect jumps past
	   the rest of the alternatives.  (They really jump to the
	   ending jump of the following alternative, because tensioning
	   these jumps is a hassle.)

	   Repeats start with an on_failure_jump that points past both
	   the repetition text and either the following jump or
	   pop_failure_jump back to this on_failure_jump.  */
	case on_failure_jump:
	on_failure:
	  DEBUG_PRINT1 ("EXECUTING on_failure_jump");
d7000 5
a7004 2
#if defined (WINDOWSNT) && defined (emacs)
	  QUIT;
d7007 17
a7023 35
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);
	  DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);

	  /* If this on_failure_jump comes right before a group (i.e.,
	     the original * applied to a group), save the information
	     for that group and all inner ones, so that if we fail back
	     to this point, the group's information will be correct.
	     For example, in \(a*\)*\1, we need the preceding group,
	     and in \(zz\(a*\)b*\)\2, we need the inner group.	*/

	  /* We can't use `p' to check ahead because we push
	     a failure point to `p + mcnt' after we do this.  */
	  p1 = p;

	  /* We need to skip no_op's before we look for the
	     start_memory in case this on_failure_jump is happening as
	     the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
	     against aba.  */
	  while (p1 < pend && (re_opcode_t) *p1 == no_op)
	    p1++;

	  if (p1 < pend && (re_opcode_t) *p1 == start_memory)
	    {
	      /* We have a new highest active register now.  This will
		 get reset at the start_memory we are about to get to,
		 but we will have saved all the registers relevant to
		 this repetition op, as described above.  */
	      highest_active_reg = *(p1 + 1) + *(p1 + 2);
	      if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
		lowest_active_reg = *(p1 + 1);
	    }

	  DEBUG_PRINT1 (":\n");
	  PUSH_FAILURE_POINT (p + mcnt, d, -2);
	  break;
d7025 10
d7036 25
a7060 23
	/* A smart repeat ends with `maybe_pop_jump'.
	   We change it to either `pop_failure_jump' or `jump'.	 */
	case maybe_pop_jump:
#if defined (WINDOWSNT) && defined (emacs)
	  QUIT;
#endif
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);
	  DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
	  {
	    register unsigned char *p2 = p;

	    /* Compare the beginning of the repeat with what in the
	       pattern follows its end. If we can establish that there
	       is nothing that they would both match, i.e., that we
	       would have to backtrack because of (as in, e.g., `a*a')
	       then we can change to pop_failure_jump, because we'll
	       never have to backtrack.

	       This is not true in the case of alternatives: in
	       `(a|ab)*' we do need to backtrack to the `ab' alternative
	       (e.g., if the string was `ab').	But instead of trying to
	       detect that here, the alternative has put on a dummy
	       failure point which is what we will end up popping.  */
d7072 1
a7072 1
		else if (p2 + 6 < pend
d7074 1
a7074 1
		  p2 += 6;
d7082 1
a7082 1
	       follows.	 */
d7084 2
a7085 2
	    /* If we're at the end of the pattern, we can change.  */
	    if (p2 == pend)
d7089 11
a7099 7
		   yet.	 */
		p[-3] = (unsigned char) pop_failure_jump;
		DEBUG_PRINT1
		  ("  End of pattern: change to `pop_failure_jump'.\n");
	      }

	    else if ((re_opcode_t) *p2 == exactn
d7102 2
a7103 2
		register unsigned int c
		  = *p2 == (unsigned char) endline ? '\n' : p2[2];
d7105 18
a7122 13
		if ((re_opcode_t) p1[3] == exactn)
		  {
		    if (!(multibyte /* && (c != '\n') */
			  && BASE_LEADING_CODE_P (c))
			? c != p1[5]
			: (STRING_CHAR (&p2[2], pend - &p2[2])
			   != STRING_CHAR (&p1[5], pend - &p1[5])))
		  {
		    p[-3] = (unsigned char) pop_failure_jump;
		    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
				  c, p1[5]);
		  }
		  }
d7124 1
d7130 1
a7130 9
		    if (multibyte /* && (c != '\n') */
			&& BASE_LEADING_CODE_P (c))
		      c = STRING_CHAR (&p2[2], pend - &p2[2]);

		    /* Test if C is listed in charset (or charset_not)
		       at `&p1[3]'.  */
		    if (SINGLE_BYTE_CHAR_P (c))
		      {
			if (c < CHARSET_BITMAP_SIZE (&p1[3]) * BYTEWIDTH
a7132 3
		      }
		    else if (CHARSET_RANGE_TABLE_EXISTS_P (&p1[3]))
		      CHARSET_LOOKUP_RANGE_TABLE (not, c, &p1[3]);
d7134 2
a7135 2
		    /* `not' is equal to 1 if c would match, which means
			that we can't change to pop_failure_jump.  */
d7137 4
a7140 4
		      {
			p[-3] = (unsigned char) pop_failure_jump;
			DEBUG_PRINT1 ("	 No match => pop_failure_jump.\n");
		      }
d7142 1
d7144 2
a7145 1
	    else if ((re_opcode_t) *p2 == charset)
d7147 6
a7152 20
		if ((re_opcode_t) p1[3] == exactn)
		  {
		    register unsigned int c = p1[5];
		    int not = 0;

		    if (multibyte && BASE_LEADING_CODE_P (c))
		      c = STRING_CHAR (&p1[5], pend - &p1[5]);

		    /* Test if C is listed in charset at `p2'.	*/
		    if (SINGLE_BYTE_CHAR_P (c))
		      {
			if (c < CHARSET_BITMAP_SIZE (p2) * BYTEWIDTH
			    && (p2[2 + c / BYTEWIDTH]
				& (1 << (c % BYTEWIDTH))))
			  not = !not;
		      }
		    else if (CHARSET_RANGE_TABLE_EXISTS_P (p2))
		      CHARSET_LOOKUP_RANGE_TABLE (not, c, p2);

		    if (!not)
d7155 2
a7156 18
			DEBUG_PRINT1 ("	 No match => pop_failure_jump.\n");
		      }
		  }

		/* It is hard to list up all the character in charset
		   P2 if it includes multibyte character.  Give up in
		   such case.  */
		else if (!multibyte || !CHARSET_RANGE_TABLE_EXISTS_P (p2))
		  {
		    /* Now, we are sure that P2 has no range table.
		       So, for the size of bitmap in P2, `p2[1]' is
		       enough.	But P1 may have range table, so the
		       size of bitmap table of P1 is extracted by
		       using macro `CHARSET_BITMAP_SIZE'.

		       Since we know that all the character listed in
		       P2 is ASCII, it is enough to test only bitmap
		       table of P1.  */
d7158 1
a7158 1
		    if ((re_opcode_t) p1[3] == charset_not)
d7161 2
a7162 2
			/* We win if the charset_not inside the loop lists
			   every character listed in the charset after.	 */
d7165 1
a7165 1
				 || (idx < CHARSET_BITMAP_SIZE (&p1[3])
d7170 4
a7173 4
		      {
			p[-3] = (unsigned char) pop_failure_jump;
			DEBUG_PRINT1 ("	 No match => pop_failure_jump.\n");
		      }
d7181 1
a7181 2
			     (idx < (int) p2[1]
			      && idx < CHARSET_BITMAP_SIZE (&p1[3]));
d7186 5
a7190 6
			if (idx == p2[1]
			    || idx == CHARSET_BITMAP_SIZE (&p1[3]))
		      {
			p[-3] = (unsigned char) pop_failure_jump;
			DEBUG_PRINT1 ("	 No match => pop_failure_jump.\n");
		      }
d7193 1
d7195 1
a7195 2
	  }
	  p -= 2;		/* Point at relative address again.  */
d7198 2
a7199 2
	      p[-1] = (unsigned char) jump;
	      DEBUG_PRINT1 ("  Match => jump.\n");
d7202 1
a7202 1
	/* Note fall through.  */
d7206 22
a7227 22
	   its matching on_failure_jump, where the latter will push a
	   failure point.  The pop_failure_jump takes off failure
	   points put on by this pop_failure_jump's matching
	   on_failure_jump; we got through the pattern to here from the
	   matching on_failure_jump, so didn't fail.  */
	case pop_failure_jump:
	  {
	    /* We need to pass separate storage for the lowest and
	       highest registers, even though we don't care about the
	       actual values.  Otherwise, we will restore only one
	       register from the stack, since lowest will == highest in
	       `pop_failure_point'.  */
	    unsigned dummy_low_reg, dummy_high_reg;
	    unsigned char *pdummy;
	    const char *sdummy;

	    DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
	    POP_FAILURE_POINT (sdummy, pdummy,
			       dummy_low_reg, dummy_high_reg,
			       reg_dummy, reg_dummy, reg_info_dummy);
	  }
	  /* Note fall through.	 */
a7228 3

	/* Unconditionally jump (without popping any failure points).  */
	case jump:
d7230 4
a7233 2
#if defined (WINDOWSNT) && defined (emacs)
	  QUIT;
d7235 4
d7240 8
a7247 4
	  DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
	  p += mcnt;				/* Do the jump.	 */
	  DEBUG_PRINT2 ("(to 0x%x).\n", p);
	  break;
d7250 62
a7311 5
	/* We need this opcode so we can detect where alternatives end
	   in `group_match_null_string_p' et al.  */
	case jump_past_alt:
	  DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
	  goto unconditional_jump;
d7313 9
d7323 3
a7325 11
	/* Normally, the on_failure_jump pushes a failure point, which
	   then gets popped at pop_failure_jump.  We will end up at
	   pop_failure_jump, also, and with a pattern of, say, `a+', we
	   are skipping over the on_failure_jump, so we have to push
	   something meaningless for pop_failure_jump to pop.  */
	case dummy_failure_jump:
	  DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
	  /* It doesn't matter what we push for the string here.  What
	     the code at `fail' tests is the value for the pattern.  */
	  PUSH_FAILURE_POINT (0, 0, -2);
	  goto unconditional_jump;
d7327 5
d7333 7
a7339 45
	/* At the end of an alternative, we need to push a dummy failure
	   point in case we are followed by a `pop_failure_jump', because
	   we don't want the failure point for the alternative to be
	   popped.  For example, matching `(a|ab)*' against `aab'
	   requires that we match the `ab' alternative.	 */
	case push_dummy_failure:
	  DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
	  /* See comments just above at `dummy_failure_jump' about the
	     two zeroes.  */
	  PUSH_FAILURE_POINT (0, 0, -2);
	  break;

	/* Have to succeed matching what follows at least n times.
	   After that, handle like `on_failure_jump'.  */
	case succeed_n:
	  EXTRACT_NUMBER (mcnt, p + 2);
	  DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);

	  assert (mcnt >= 0);
	  /* Originally, this is how many times we HAVE to succeed.  */
	  if (mcnt > 0)
	    {
	       mcnt--;
	       p += 2;
	       STORE_NUMBER_AND_INCR (p, mcnt);
	       DEBUG_PRINT3 ("	Setting 0x%x to %d.\n", p, mcnt);
	    }
	  else if (mcnt == 0)
	    {
	      DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
	      p[2] = (unsigned char) no_op;
	      p[3] = (unsigned char) no_op;
	      goto on_failure;
	    }
	  break;

	case jump_n:
	  EXTRACT_NUMBER (mcnt, p + 2);
	  DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);

	  /* Originally, this is how many times we CAN jump.  */
	  if (mcnt)
	    {
	       mcnt--;
	       STORE_NUMBER (p + 2, mcnt);
d7341 2
a7342 2
	    }
	  /* If don't have to jump any more, skip over the rest of command.  */
d7344 2
a7345 2
	    p += 4;
	  break;
d7347 1
a7347 1
	case set_number_at:
d7349 1
a7349 1
	    DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
d7351 8
a7358 4
	    EXTRACT_NUMBER_AND_INCR (mcnt, p);
	    p1 = p + mcnt;
	    EXTRACT_NUMBER_AND_INCR (mcnt, p);
	    DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
d7360 8
a7367 2
	    break;
	  }
d7369 1
a7369 1
	case wordbound:
d7371 5
d7377 9
a7385 1
	  /* We SUCCEED in one of the following cases: */
d7387 1
a7387 1
	  /* Case 1: D is at the beginning or the end of string.  */
a7388 2
	    break;
	  else
d7390 2
a7391 5
	      /* C1 is the character before D, S1 is the syntax of C1, C2
		 is the character at D, and S2 is the syntax of C2.  */
	      int c1, c2, s1, s2;
	      int pos1 = PTR_TO_OFFSET (d - 1);
	      int charpos;
d7393 8
a7400 11
	      GET_CHAR_BEFORE_2 (c1, d, string1, end1, string2, end2);
	      GET_CHAR_AFTER_2 (c2, d, string1, end1, string2, end2);
#ifdef emacs
	      charpos = SYNTAX_TABLE_BYTE_TO_CHAR (pos1);
	      UPDATE_SYNTAX_TABLE (charpos);
#endif
	      s1 = SYNTAX (c1);
#ifdef emacs
	      UPDATE_SYNTAX_TABLE_FORWARD (charpos + 1);
#endif
	      s2 = SYNTAX (c2);
d7402 3
a7404 8
	      if (/* Case 2: Only one of S1 and S2 is Sword.  */
		  ((s1 == Sword) != (s2 == Sword))
		  /* Case 3: Both of S1 and S2 are Sword, and macro
		     WORD_BOUNDARY_P (C1, C2) returns nonzero.	*/
		  || ((s1 == Sword) && WORD_BOUNDARY_P (c1, c2)))
	    break;
	}
	  goto fail;
a7405 1
      case notwordbound:
a7406 4

	  /* We FAIL in one of the following cases: */

	  /* Case 1: D is at the beginning or the end of string.  */
a7408 19
	  else
	    {
	      /* C1 is the character before D, S1 is the syntax of C1, C2
		 is the character at D, and S2 is the syntax of C2.  */
	      int c1, c2, s1, s2;
	      int pos1 = PTR_TO_OFFSET (d - 1);
	      int charpos;

	      GET_CHAR_BEFORE_2 (c1, d, string1, end1, string2, end2);
	      GET_CHAR_AFTER_2 (c2, d, string1, end1, string2, end2);
#ifdef emacs
	      charpos = SYNTAX_TABLE_BYTE_TO_CHAR (pos1);
	      UPDATE_SYNTAX_TABLE (charpos);
#endif
	      s1 = SYNTAX (c1);
#ifdef emacs
	      UPDATE_SYNTAX_TABLE_FORWARD (charpos + 1);
#endif
	      s2 = SYNTAX (c2);
d7410 3
a7412 5
	      if (/* Case 2: Only one of S1 and S2 is Sword.  */
		  ((s1 == Sword) != (s2 == Sword))
		  /* Case 3: Both of S1 and S2 are Sword, and macro
		     WORD_BOUNDARY_P (C1, C2) returns nonzero.	*/
		  || ((s1 == Sword) && WORD_BOUNDARY_P (c1, c2)))
d7414 1
d7416 1
a7416 4
	  break;

	case wordbeg:
	  DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
d7418 4
a7421 6
	  /* We FAIL in one of the following cases: */

	  /* Case 1: D is at the end of string.	 */
	  if (AT_STRINGS_END (d))
	  goto fail;
	  else
d7423 1
a7423 31
	      /* C1 is the character before D, S1 is the syntax of C1, C2
		 is the character at D, and S2 is the syntax of C2.  */
	      int c1, c2, s1, s2;
	      int pos1 = PTR_TO_OFFSET (d);
	      int charpos;

	      GET_CHAR_AFTER_2 (c2, d, string1, end1, string2, end2);
#ifdef emacs
	      charpos = SYNTAX_TABLE_BYTE_TO_CHAR (pos1);
	      UPDATE_SYNTAX_TABLE (charpos);
#endif
	      s2 = SYNTAX (c2);
	
	      /* Case 2: S2 is not Sword. */
	      if (s2 != Sword)
		goto fail;

	      /* Case 3: D is not at the beginning of string ... */
	      if (!AT_STRINGS_BEG (d))
		{
		  GET_CHAR_BEFORE_2 (c1, d, string1, end1, string2, end2);
#ifdef emacs
		  UPDATE_SYNTAX_TABLE_BACKWARD (charpos - 1);
#endif
		  s1 = SYNTAX (c1);

		  /* ... and S1 is Sword, and WORD_BOUNDARY_P (C1, C2)
		     returns 0.	 */
		  if ((s1 == Sword) && !WORD_BOUNDARY_P (c1, c2))
		    goto fail;
		}
d7425 1
a7425 4
	  break;

	case wordend:
	  DEBUG_PRINT1 ("EXECUTING wordend.\n");
d7427 4
a7430 6
	  /* We FAIL in one of the following cases: */

	  /* Case 1: D is at the beginning of string.  */
	  if (AT_STRINGS_BEG (d))
	    goto fail;
	  else
d7432 1
a7432 31
	      /* C1 is the character before D, S1 is the syntax of C1, C2
		 is the character at D, and S2 is the syntax of C2.  */
	      int c1, c2, s1, s2;
	      int pos1 = PTR_TO_OFFSET (d);
	      int charpos;

	      GET_CHAR_BEFORE_2 (c1, d, string1, end1, string2, end2);
#ifdef emacs
	      charpos = SYNTAX_TABLE_BYTE_TO_CHAR (pos1 - 1);
	      UPDATE_SYNTAX_TABLE (charpos);
#endif
	      s1 = SYNTAX (c1);

	      /* Case 2: S1 is not Sword.  */
	      if (s1 != Sword)
		goto fail;

	      /* Case 3: D is not at the end of string ... */
	      if (!AT_STRINGS_END (d))
		{
		  GET_CHAR_AFTER_2 (c2, d, string1, end1, string2, end2);
#ifdef emacs
		  UPDATE_SYNTAX_TABLE_FORWARD (charpos);
#endif
		  s2 = SYNTAX (c2);

		  /* ... and S2 is Sword, and WORD_BOUNDARY_P (C1, C2)
		     returns 0.	 */
		  if ((s2 == Sword) && !WORD_BOUNDARY_P (c1, c2))
	  goto fail;
		}
d7434 1
a7434 1
	  break;
d7437 17
a7453 17
	case before_dot:
	  DEBUG_PRINT1 ("EXECUTING before_dot.\n");
	  if (PTR_BYTE_POS ((unsigned char *) d) >= PT_BYTE)
	    goto fail;
	  break;

	case at_dot:
	  DEBUG_PRINT1 ("EXECUTING at_dot.\n");
	  if (PTR_BYTE_POS ((unsigned char *) d) != PT_BYTE)
	    goto fail;
	  break;

	case after_dot:
	  DEBUG_PRINT1 ("EXECUTING after_dot.\n");
	  if (PTR_BYTE_POS ((unsigned char *) d) <= PT_BYTE)
	    goto fail;
	  break;
d7455 2
a7456 2
	case syntaxspec:
	  DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
d7460 2
a7461 2
	case wordchar:
	  DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
d7463 1
a7463 1
	matchsyntax:
d7465 3
a7467 18
#ifdef emacs
	  {
	    int pos1 = SYNTAX_TABLE_BYTE_TO_CHAR (PTR_TO_OFFSET (d));
	    UPDATE_SYNTAX_TABLE (pos1);
	  }
#endif
	  {
	    int c, len;

	    if (multibyte)
	      /* we must concern about multibyte form, ... */
	      c = STRING_CHAR_AND_LENGTH (d, dend - d, len);
	    else
	      /* everything should be handled as ASCII, even though it
		 looks like multibyte form.  */
	      c = *d, len = 1;

	    if (SYNTAX (c) != (enum syntaxcode) mcnt)
d7469 2
a7470 4
	    d += len;
	  }
	  SET_REGS_MATCHED ();
	  break;
d7472 2
a7473 2
	case notsyntaxspec:
	  DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
d7477 2
a7478 2
	case notwordchar:
	  DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
d7480 1
a7480 1
	matchnotsyntax:
d7482 3
a7484 15
#ifdef emacs
	  {
	    int pos1 = SYNTAX_TABLE_BYTE_TO_CHAR (PTR_TO_OFFSET (d));
	    UPDATE_SYNTAX_TABLE (pos1);
	  }
#endif
	  {
	    int c, len;

	    if (multibyte)
	      c = STRING_CHAR_AND_LENGTH (d, dend - d, len);
	    else
	      c = *d, len = 1;

	    if (SYNTAX (c) == (enum syntaxcode) mcnt)
a7485 40
	    d += len;
	  }
	  SET_REGS_MATCHED ();
	  break;

	case categoryspec:
	  DEBUG_PRINT2 ("EXECUTING categoryspec %d.\n", *p);
	  mcnt = *p++;
	  PREFETCH ();
	  {
	    int c, len;

	    if (multibyte)
	      c = STRING_CHAR_AND_LENGTH (d, dend - d, len);
	    else
	      c = *d, len = 1;

	    if (!CHAR_HAS_CATEGORY (c, mcnt))
	      goto fail;
	    d += len;
	  }
	  SET_REGS_MATCHED ();
	  break;

	case notcategoryspec:
	  DEBUG_PRINT2 ("EXECUTING notcategoryspec %d.\n", *p);
	  mcnt = *p++;
	  PREFETCH ();
	  {
	    int c, len;

	    if (multibyte)
	      c = STRING_CHAR_AND_LENGTH (d, dend - d, len);
	    else
	      c = *d, len = 1;

	    if (CHAR_HAS_CATEGORY (c, mcnt))
	      goto fail;
	    d += len;
	  }
d7487 1
a7487 1
          break;
d7490 1
a7490 1
	case wordchar:
d7497 1
a7497 1
	  break;
d7499 1
a7499 1
	case notwordchar:
d7506 1
a7506 1
	  break;
d7509 1
d7514 1
a7518 3
#if defined (WINDOWSNT) && defined (emacs)
      QUIT;
#endif
d7588 2
a7589 3
group_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
d7593 1
a7593 1
  unsigned char *p1 = *p + 2;
d7631 2
a7632 1
              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
d7638 3
a7640 2
                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3,
				                      reg_info))
d7656 2
a7657 1
                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
d7660 1
a7660 1
                      p1 -= 3;
d7668 1
a7668 1
              EXTRACT_NUMBER (mcnt, p1 - 2);
d7670 1
a7670 1
              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
d7685 1
a7685 1
          if (!common_op_match_null_string_p (&p1, end, reg_info))
d7699 2
a7700 3
alt_match_null_string_p (p, end, reg_info)
    unsigned char *p, *end;
    register_info_type *reg_info;
d7703 1
a7703 1
  unsigned char *p1 = p;
d7720 1
a7720 1
          if (!common_op_match_null_string_p (&p1, end, reg_info))
d7735 2
a7736 3
common_op_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
d7741 1
a7741 1
  unsigned char *p1 = *p;
d7764 1
a7764 1
      ret = group_match_null_string_p (&p1, end, reg_info);
d7787 1
a7787 1
      p1 += 2;
d7792 1
a7792 1
          p1 -= 4;
d7806 1
a7806 1
      p1 += 4;
d7822 7
a7828 10
bcmp_translate (s1, s2, len, translate)
     unsigned char *s1, *s2;
     register int len;
     RE_TRANSLATE_TYPE translate;
{
  register unsigned char *p1 = s1, *p2 = s2;
  unsigned char *p1_end = s1 + len;
  unsigned char *p2_end = s2 + len;

  while (p1 != p1_end && p2 != p2_end)
d7830 3
a7832 8
      int p1_charlen, p2_charlen;
      int p1_ch, p2_ch;

      p1_ch = STRING_CHAR_AND_LENGTH (p1, p1_end - p1, p1_charlen);
      p2_ch = STRING_CHAR_AND_LENGTH (p2, p2_end - p2, p2_charlen);

      if (RE_TRANSLATE (translate, p1_ch)
	  != RE_TRANSLATE (translate, p2_ch))
d7834 4
a7837 2

      p1 += p1_charlen, p2 += p2_charlen;
a7838 4

  if (p1 != p1_end || p2 != p2_end)
    return 1;

d7842 3
d7857 3
a7859 4
re_compile_pattern (pattern, length, bufp)
     const char *pattern;
     int length;
     struct re_pattern_buffer *bufp;
d7875 6
a7880 1
  ret = regex_compile (pattern, length, re_syntax_options, bufp);
d7884 1
a7884 1
  return gettext (re_error_msgid[(int) ret]);
d7886 3
d7893 1
a7893 1
#if defined (_REGEX_RE_COMP) || defined (_LIBC)
d7905 1
a7905 2
re_comp (s)
    const char *s;
d7912 1
a7912 1
	return gettext ("No previous regular expression");
d7918 1
a7918 1
      re_comp_buf.buffer = (unsigned char *) malloc (200);
d7920 2
a7921 2
        /* CVS: Yes, we're discarding `const' here if !HAVE_LIBINTL.  */
        return (char *) gettext (re_error_msgid[(int) REG_ESPACE]);
d7924 1
a7924 1
      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
d7926 2
a7927 2
	/* CVS: Yes, we're discarding `const' here if !HAVE_LIBINTL.  */
	return (char *) gettext (re_error_msgid[(int) REG_ESPACE]);
d7936 6
a7941 1
  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
d7947 1
a7947 1
  return (char *) gettext (re_error_msgid[(int) ret]);
d7955 1
a7955 2
re_exec (s)
    const char *s;
d7959 1
a7959 1
    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
d7961 1
d7979 2
a7980 1
     `fastmap' and `fastmap_accurate' to zero;
d8004 1
a8004 4
regcomp (preg, pattern, cflags)
    regex_t *preg;
    const char *pattern;
    int cflags;
d8007 1
a8007 1
  unsigned syntax
d8016 2
a8017 5
  /* Don't bother to use a fastmap when searching.  This simplifies the
     REG_NEWLINE case: if we used a fastmap, we'd have to put all the
     characters after newlines into the fastmap.  This way, we just try
     every character.  */
  preg->fastmap = 0;
d8023 2
a8024 3
      preg->translate
	= (RE_TRANSLATE_TYPE) malloc (CHAR_SET_SIZE
				      * sizeof (*(RE_TRANSLATE_TYPE)0));
d8030 1
a8030 1
        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
d8050 6
a8055 1
  ret = regex_compile (pattern, strlen (pattern), syntax, preg);
d8061 13
d8076 3
d8096 2
a8097 6
regexec (preg, string, nmatch, pmatch, eflags)
    const regex_t *preg;
    const char *string;
    size_t nmatch;
    regmatch_t pmatch[];
    int eflags;
d8118 2
a8119 3
      regs.start = TALLOC (nmatch, regoff_t);
      regs.end = TALLOC (nmatch, regoff_t);
      if (regs.start == NULL || regs.end == NULL)
d8121 1
d8127 1
a8127 1
                   want_reg_info ? &regs : (struct re_registers *) 0);
a8144 1
      free (regs.end);
d8150 3
d8159 1
a8159 5
regerror (errcode, preg, errbuf, errbuf_size)
    int errcode;
    const regex_t *preg;
    char *errbuf;
    size_t errbuf_size;
d8165 2
a8166 1
      || errcode >= (sizeof (re_error_msgid) / sizeof (re_error_msgid[0])))
d8173 1
a8173 1
  msg = gettext (re_error_msgid[errcode]);
d8181 4
a8184 1
          strncpy (errbuf, msg, errbuf_size - 1);
d8186 1
d8189 1
a8189 1
        strcpy (errbuf, msg);
d8194 3
d8202 1
a8202 2
regfree (preg)
    regex_t *preg;
d8220 3
d8225 71
@


1.2
log
@first step of merging new cvs
XXX might not compile
XXX might not work
XXX might contain bugs
XXX definitively needs autoconf 2.58 first
@
text
@d1537 1
d5475 1
a5475 1

@


1.1
log
@Initial revision
@
text
@a1536 1
static reg_errcode_t compile_range ();
d5474 1
a5474 1
	
@


1.1.2.1
log
@vendor-branch-ify new cvs 1.12
@
text
@d1 2
a2 3
/* Extended regular expression matching and search library,
   version 0.12.
   (Implements POSIX draft P1003.2/D11.2, except for some of the
d5 1
a5 2
   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.
d14 1
a14 1
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d17 4
a20 3
   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 1
a23 1
#if defined _AIX && !defined REGEX_MALLOC
d30 10
d41 1
a41 1
# include <config.h>
d44 2
a45 1
#ifndef INSIDE_RECURSION
d47 6
a52 1
# include <stddef.h>
d54 5
a58 63
# define WIDE_CHAR_SUPPORT (HAVE_WCTYPE_H && HAVE_WCHAR_H && HAVE_BTOWC)

/* For platform which support the ISO C amendement 1 functionality we
   support user defined character classes.  */
# if defined _LIBC || WIDE_CHAR_SUPPORT
/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
#  include <wchar.h>
#  include <wctype.h>
# endif

# ifdef _LIBC
/* We have to keep the namespace clean.  */
#  define regfree(preg) __regfree (preg)
#  define regexec(pr, st, nm, pm, ef) __regexec (pr, st, nm, pm, ef)
#  define regcomp(preg, pattern, cflags) __regcomp (preg, pattern, cflags)
#  define regerror(errcode, preg, errbuf, errbuf_size) \
	__regerror(errcode, preg, errbuf, errbuf_size)
#  define re_set_registers(bu, re, nu, st, en) \
	__re_set_registers (bu, re, nu, st, en)
#  define re_match_2(bufp, string1, size1, string2, size2, pos, regs, stop) \
	__re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
#  define re_match(bufp, string, size, pos, regs) \
	__re_match (bufp, string, size, pos, regs)
#  define re_search(bufp, string, size, startpos, range, regs) \
	__re_search (bufp, string, size, startpos, range, regs)
#  define re_compile_pattern(pattern, length, bufp) \
	__re_compile_pattern (pattern, length, bufp)
#  define re_set_syntax(syntax) __re_set_syntax (syntax)
#  define re_search_2(bufp, st1, s1, st2, s2, startpos, range, regs, stop) \
	__re_search_2 (bufp, st1, s1, st2, s2, startpos, range, regs, stop)
#  define re_compile_fastmap(bufp) __re_compile_fastmap (bufp)

#  define btowc __btowc
#  define iswctype __iswctype
#  define mbrtowc __mbrtowc
#  define wcslen __wcslen
#  define wcscoll __wcscoll
#  define wcrtomb __wcrtomb

/* We are also using some library internals.  */
#  include <locale/localeinfo.h>
#  include <locale/elem-hash.h>
#  include <langinfo.h>
#  include <locale/coll-lookup.h>
# endif

# ifdef _LIBC
#  include <libintl.h>
#  undef gettext
#  define gettext(msgid) __dcgettext ("libc", msgid, LC_MESSAGES)
   /* This define is so xgettext can find the internationalizable strings.  */
#  define gettext_noop(msgid) msgid
# else
/* This is for other GNU distributions with internationalized messages.  */
#  include "gettext.h"
# endif

/* Support for bounded pointers.  */
# if !defined _LIBC && !defined __BOUNDED_POINTERS__
#  define __bounded	/* nothing */
#  define __unbounded	/* nothing */
#  define __ptrvalue	/* nothing */
# endif
d62 11
a72 1
# ifdef emacs
d74 3
a76 3
#  include "lisp.h"
#  include "buffer.h"
#  include "syntax.h"
d78 1
a78 1
# else  /* not emacs */
d83 1
a83 1
#  undef REL_ALLOC
d85 6
a90 1
#  include <stdlib.h>
d93 8
a100 8
   If nothing else has been done, use the method below.  */
#  ifdef INHIBIT_STRING_HEADER
#   if !(defined HAVE_BZERO && defined HAVE_BCOPY)
#    if !defined bzero && !defined bcopy
#     undef INHIBIT_STRING_HEADER
#    endif
#   endif
#  endif
d105 16
a120 10
#  ifndef INHIBIT_STRING_HEADER
#   include <string.h>
#   ifndef bzero
#    ifndef _LIBC
#     define bzero(s, n)	(memset (s, '\0', n), (s))
#    else
#     define bzero(s, n)	__bzero (s, n)
#    endif
#   endif
#  endif
d126 9
a134 20
#  ifndef Sword
#   define Sword 1
#  endif

#  ifdef SWITCH_ENUM_BUG
#   define SWITCH_ENUM_CAST(x) ((int)(x))
#  else
#   define SWITCH_ENUM_CAST(x) (x)
#  endif

# endif /* not emacs */

# include <limits.h>

# ifndef MB_LEN_MAX
#  define MB_LEN_MAX 1
# endif

/* Get the interface, including the syntax bits.  */
# include <regex.h>
d136 1
a136 2
/* isalpha etc. are used for the character classes.  */
# include <ctype.h>
d138 1
a138 1
/* Jim Meyering writes:
d140 1
a140 9
   "... Some ctype macros are valid only for character codes that
   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
   using /bin/cc or gcc but without giving an ansi option).  So, all
   ctype uses should be through macros like ISPRINT...  If
   STDC_HEADERS is defined, then autoconf has verified that the ctype
   macros don't need to be guarded with references to isascii. ...
   Defining isascii to 1 should let any compiler worth its salt
   eliminate the && through constant folding."
   Solaris defines some of these symbols so we must undefine them first.  */
a141 36
# if defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
#  define IN_CTYPE_DOMAIN(c) 1
# else
#  define IN_CTYPE_DOMAIN(c) isascii(c)
# endif

# ifdef isblank
#  define ISBLANK(c) (IN_CTYPE_DOMAIN (c) && isblank (c))
# else
#  define ISBLANK(c) ((c) == ' ' || (c) == '\t')
# endif
# ifdef isgraph
#  define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isgraph (c))
# else
#  define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isprint (c) && !isspace (c))
# endif

# undef ISPRINT
# define ISPRINT(c) (IN_CTYPE_DOMAIN (c) && isprint (c))
# define ISDIGIT(c) (IN_CTYPE_DOMAIN (c) && isdigit (c))
# define ISALNUM(c) (IN_CTYPE_DOMAIN (c) && isalnum (c))
# define ISALPHA(c) (IN_CTYPE_DOMAIN (c) && isalpha (c))
# define ISCNTRL(c) (IN_CTYPE_DOMAIN (c) && iscntrl (c))
# define ISLOWER(c) (IN_CTYPE_DOMAIN (c) && islower (c))
# define ISPUNCT(c) (IN_CTYPE_DOMAIN (c) && ispunct (c))
# define ISSPACE(c) (IN_CTYPE_DOMAIN (c) && isspace (c))
# define ISUPPER(c) (IN_CTYPE_DOMAIN (c) && isupper (c))
# define ISXDIGIT(c) (IN_CTYPE_DOMAIN (c) && isxdigit (c))

# ifdef _tolower
#  define TOLOWER(c) _tolower(c)
# else
#  define TOLOWER(c) tolower(c)
# endif

# ifndef emacs
d143 1
a143 7
#  define CHAR_SET_SIZE 256

#  ifdef SYNTAX_TABLE

extern char *re_syntax_table;

#  else /* not SYNTAX_TABLE */
d148 1
a148 1
init_syntax_once (void)
d155 1
d158 8
a165 3
   for (c = 0; c < CHAR_SET_SIZE; ++c)
     if (ISALNUM (c))
	re_syntax_table[c] = Sword;
d172 41
a212 1
#  endif /* not SYNTAX_TABLE */
d214 10
a223 1
#  define SYNTAX(c) re_syntax_table[(unsigned char) (c)]
d225 26
a250 1
# endif /* emacs */
d262 1
a262 1
# ifdef REGEX_MALLOC
d264 3
a266 3
#  define REGEX_ALLOCATE malloc
#  define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
#  define REGEX_FREE free
d268 1
a268 1
# else /* not REGEX_MALLOC  */
d271 1
a271 1
#  ifndef alloca
d274 13
a286 1
#   include <alloca.h>
d288 1
a288 1
#  endif /* not alloca */
d290 1
a290 1
#  define REGEX_ALLOCATE alloca
d293 1
a293 1
#  define REGEX_REALLOCATE(source, osize, nsize)			\
d295 2
a296 1
   memcpy (destination, source, osize))
d299 1
a299 1
#  define REGEX_FREE(arg) ((void)0) /* Do nothing!  But inhibit gcc warning.  */
d301 1
a301 1
# endif /* not REGEX_MALLOC */
d305 1
a305 1
# if defined REL_ALLOC && defined REGEX_MALLOC
d307 1
a307 1
#  define REGEX_ALLOCATE_STACK(size)				\
d309 1
a309 1
#  define REGEX_REALLOCATE_STACK(source, osize, nsize)		\
d311 1
a311 1
#  define REGEX_FREE_STACK(ptr)					\
d314 1
a314 1
# else /* not using relocating allocator */
d316 1
a316 1
#  ifdef REGEX_MALLOC
d318 3
a320 3
#   define REGEX_ALLOCATE_STACK malloc
#   define REGEX_REALLOCATE_STACK(source, osize, nsize) realloc (source, nsize)
#   define REGEX_FREE_STACK free
d322 1
a322 1
#  else /* not REGEX_MALLOC */
d324 1
a324 1
#   define REGEX_ALLOCATE_STACK alloca
d326 1
a326 1
#   define REGEX_REALLOCATE_STACK(source, osize, nsize)			\
d328 2
a329 2
/* No need to explicitly free anything.  */
#   define REGEX_FREE_STACK(arg)
d331 2
a332 2
#  endif /* not REGEX_MALLOC */
# endif /* not using relocating allocator */
d338 1
a338 1
# define FIRST_STRING_P(ptr) 					\
d342 3
a344 3
# define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
# define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
# define RETALLOC_IF(addr, n, t) \
d346 1
a346 1
# define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
d348 1
a348 1
# define BYTEWIDTH 8 /* In bits.  */
d350 1
a350 1
# define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
d352 4
a355 4
# undef MAX
# undef MIN
# define MAX(a, b) ((a) > (b) ? (a) : (b))
# define MIN(a, b) ((a) < (b) ? (a) : (b))
d358 2
a359 2
# define false 0
# define true 1
d361 1
a361 39
static reg_errcode_t byte_regex_compile (const char *pattern, size_t size,
					 reg_syntax_t syntax,
					 struct re_pattern_buffer *bufp);

static int byte_re_match_2_internal (struct re_pattern_buffer *bufp,
				     const char *string1, int size1,
				     const char *string2, int size2,
				     int pos,
				     struct re_registers *regs,
				     int stop);
static int byte_re_search_2 (struct re_pattern_buffer *bufp,
			     const char *string1, int size1,
			     const char *string2, int size2,
			     int startpos, int range,
			     struct re_registers *regs, int stop);
static int byte_re_compile_fastmap (struct re_pattern_buffer *bufp);

#ifdef MBS_SUPPORT
static reg_errcode_t wcs_regex_compile (const char *pattern, size_t size,
					reg_syntax_t syntax,
					struct re_pattern_buffer *bufp);


static int wcs_re_match_2_internal (struct re_pattern_buffer *bufp,
				    const char *cstring1, int csize1,
				    const char *cstring2, int csize2,
				    int pos,
				    struct re_registers *regs,
				    int stop,
				    wchar_t *string1, int size1,
				    wchar_t *string2, int size2,
				    int *mbs_offset1, int *mbs_offset2);
static int wcs_re_search_2 (struct re_pattern_buffer *bufp,
			    const char *string1, int size1,
			    const char *string2, int size2,
			    int startpos, int range,
			    struct re_registers *regs, int stop);
static int wcs_re_compile_fastmap (struct re_pattern_buffer *bufp);
#endif
d364 1
a364 1
   expressions.  Some opcodes are followed by argument bytes.  A
d372 1
a372 1
  /* Succeed right away--no more backtracking.  */
d375 1
a375 1
        /* Followed by one byte giving n, then by n literal bytes.  */
d378 1
a378 6
# ifdef MBS_SUPPORT
	/* Same as exactn, but contains binary data.  */
  exactn_bin,
# endif

        /* Matches any (more or less) character.  */
d381 6
a386 13
        /* Matches any one char belonging to specified set.  First
           following byte is number of bitmap bytes.  Then come bytes
           for a bitmap saying which chars are in.  Bits in each byte
           are ordered low-bit-first.  A character is in the set if its
           bit is 1.  A character too large to have a bit in the map is
           automatically not in the set.  */
        /* ifdef MBS_SUPPORT, following element is length of character
	   classes, length of collating symbols, length of equivalence
	   classes, length of character ranges, and length of characters.
	   Next, character class element, collating symbols elements,
	   equivalence class elements, range elements, and character
	   elements follow.
	   See regex_compile function.  */
d389 2
a390 2
        /* Same parameters as charset, but match any character that is
           not one of those specified.  */
d393 7
a399 7
        /* Start remembering the text that is matched, for storing in a
           register.  Followed by one byte with the register number, in
           the range 0 to one less than the pattern buffer's re_nsub
           field.  Then followed by one byte with the number of groups
           inner to this one.  (This last has to be part of the
           start_memory only because we need it in the on_failure_jump
           of re_match_2.)  */
d402 7
a408 7
        /* Stop remembering the text that is matched and store it in a
           memory register.  Followed by one byte with the register
           number, in the range 0 to one less than `re_nsub' in the
           pattern buffer, and one byte with the number of inner groups,
           just like `start_memory'.  (We need the number of inner
           groups here because we don't have any easy way of finding the
           corresponding start_memory when we're at a stop_memory.)  */
d411 2
a412 2
        /* Match a duplicate of something remembered. Followed by one
           byte containing the register number.  */
d415 1
a415 1
        /* Fail unless at beginning of line.  */
d418 1
a418 1
        /* Fail unless at end of line.  */
d421 2
a422 2
        /* Succeeds if at beginning of buffer (if emacs) or at beginning
           of string to be matched (if not).  */
d425 1
a425 1
        /* Analogously, for end of buffer/string.  */
d428 1
a428 1
        /* Followed by two byte relative address to which to jump.  */
d434 2
a435 3
        /* Followed by two-byte relative address of place to resume at
           in case of failure.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
d438 2
a439 2
        /* Like on_failure_jump, but pushes a placeholder instead of the
           current string position when executed.  */
d442 2
a443 3
        /* Throw away latest failure point and then jump to following
           two-byte relative address.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
d446 7
a452 8
        /* Change to pop_failure_jump if know won't have to backtrack to
           match; otherwise change to jump.  This is used to jump
           back to the beginning of a repeat.  If what follows this jump
           clearly won't match what the repeat does, such that we can be
           sure that there is no use backtracking out of repetitions
           already matched, then we change it to a pop_failure_jump.
           Followed by two-byte address.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
d455 5
a459 6
        /* Jump to following two-byte address, and push a dummy failure
           point. This failure point will be thrown away if an attempt
           is made to use it for a failure.  A `+' construct makes this
           before the first repeat.  Also used as an intermediary kind
           of jump when compiling an alternative.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
d466 2
a467 3
        /* Followed by two-byte relative address and two-byte number n.
           After matching N times, jump to the address upon failure.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
d470 2
a471 3
        /* Followed by two-byte relative address, and two-byte number n.
           Jump to the address N times, then fail.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
d474 3
a476 4
        /* Set the following two-byte relative address to the
           subsequent two-byte number.  The address *includes* the two
           bytes of number.  */
        /* ifdef MBS_SUPPORT, the size of address is 1.  */
d486 1
a486 1
  notwordbound	/* Succeeds if not at a word boundary.  */
d488 1
a488 1
# ifdef emacs
d494 1
a494 1
           a byte which contains a syntax code, e.g., Sword.  */
d498 12
a509 2
  notsyntaxspec
# endif /* emacs */
a510 1
#endif /* not INSIDE_RECURSION */
a511 41

#ifdef BYTE
# define CHAR_T char
# define UCHAR_T unsigned char
# define COMPILED_BUFFER_VAR bufp->buffer
# define OFFSET_ADDRESS_SIZE 2
# define PREFIX(name) byte_##name
# define ARG_PREFIX(name) name
# define PUT_CHAR(c) putchar (c)
#else
# ifdef WCHAR
#  define CHAR_T wchar_t
#  define UCHAR_T wchar_t
#  define COMPILED_BUFFER_VAR wc_buffer
#  define OFFSET_ADDRESS_SIZE 1 /* the size which STORE_NUMBER macro use */
#  define CHAR_CLASS_SIZE ((__alignof__(wctype_t)+sizeof(wctype_t))/sizeof(CHAR_T)+1)
#  define PREFIX(name) wcs_##name
#  define ARG_PREFIX(name) c##name
/* Should we use wide stream??  */
#  define PUT_CHAR(c) printf ("%C", c);
#  define TRUE 1
#  define FALSE 0
# else
#  ifdef MBS_SUPPORT
#   define WCHAR
#   define INSIDE_RECURSION
#   include "regex.c"
#   undef INSIDE_RECURSION
#  endif
#  define BYTE
#  define INSIDE_RECURSION
#  include "regex.c"
#  undef INSIDE_RECURSION
# endif
#endif

#if USE_UNLOCKED_IO
# include "unlocked-io.h"
#endif

#ifdef INSIDE_RECURSION
a514 1
/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */
d516 1
a516 7
# ifdef WCHAR
#  define STORE_NUMBER(destination, number)				\
  do {									\
    *(destination) = (UCHAR_T)(number);				\
  } while (0)
# else /* BYTE */
#  define STORE_NUMBER(destination, number)				\
a520 1
# endif /* WCHAR */
a524 1
/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */
d526 1
a526 1
# define STORE_NUMBER_AND_INCR(destination, number)			\
d529 1
a529 1
    (destination) += OFFSET_ADDRESS_SIZE;				\
a533 1
/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */
d535 1
a535 7
# ifdef WCHAR
#  define EXTRACT_NUMBER(destination, source)				\
  do {									\
    (destination) = *(source);						\
  } while (0)
# else /* BYTE */
#  define EXTRACT_NUMBER(destination, source)				\
d538 1
a538 1
    (destination) += (signed char) (*((source) + 1)) << 8;		\
a539 1
# endif
d541 1
a541 1
# ifdef DEBUG
d543 3
a545 1
PREFIX(extract_number) (int *dest, UCHAR_T *source)
d547 1
a547 4
#  ifdef WCHAR
  *dest = *source;
#  else /* BYTE */
  signed char temp = source[1];
a549 1
#  endif
d552 4
a555 4
#  ifndef EXTRACT_MACROS /* To debug the macros.  */
#   undef EXTRACT_NUMBER
#   define EXTRACT_NUMBER(dest, src) PREFIX(extract_number) (&dest, src)
#  endif /* not EXTRACT_MACROS */
d557 1
a557 1
# endif /* DEBUG */
d562 1
a562 1
# define EXTRACT_NUMBER_AND_INCR(destination, source)			\
d565 1
a565 1
    (source) += OFFSET_ADDRESS_SIZE; 					\
d568 1
a568 1
# ifdef DEBUG
d570 3
a572 1
PREFIX(extract_number_and_incr) (int *destination, UCHAR_T **source)
d574 2
a575 2
  PREFIX(extract_number) (destination, *source);
  *source += OFFSET_ADDRESS_SIZE;
d578 30
a607 5
#  ifndef EXTRACT_MACROS
#   undef EXTRACT_NUMBER_AND_INCR
#   define EXTRACT_NUMBER_AND_INCR(dest, src) \
  PREFIX(extract_number_and_incr) (&dest, &src)
#  endif /* not EXTRACT_MACROS */
d609 49
a657 1
# endif /* DEBUG */
d659 13
a672 1

d677 1
a677 1
   the other test files, you can run the already-written tests.  */
d679 1
a679 3
# ifdef DEBUG

#  ifndef DEFINED_ONCE
d682 1
a682 1
#   include <stdio.h>
d685 1
a685 1
#   include <assert.h>
d687 1
a687 1
static int debug;
d689 9
a697 11
#   define DEBUG_STATEMENT(e) e
#   define DEBUG_PRINT1(x) if (debug) printf (x)
#   define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
#   define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
#   define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
#  endif /* not DEFINED_ONCE */

#  define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 			\
  if (debug) PREFIX(print_partial_compiled_pattern) (s, e)
#  define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)		\
  if (debug) PREFIX(print_double_string) (w, s1, sz1, s2, sz2)
a701 1
#  ifndef DEFINED_ONCE
d703 2
a704 1
print_fastmap (char *fastmap)
d714 6
a719 6
          putchar (i - 1);
          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
            {
              was_a_range = 1;
              i++;
            }
d721 5
a725 5
            {
              printf ("-");
              putchar (i - 1);
            }
        }
a728 1
#  endif /* not DEFINED_ONCE */
d735 3
a737 1
PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)
d740 2
a741 3
  UCHAR_T *p1;
  UCHAR_T *p = start;
  UCHAR_T *pend = end;
d752 1
a752 5
#  ifdef _LIBC
      printf ("%td:\t", p - start);
#  else
      printf ("%ld:\t", (long int) (p - start));
#  endif
d756 3
a758 3
        case no_op:
          printf ("/no_op");
          break;
d762 2
a763 2
          printf ("/exactn/%d", mcnt);
          do
d765 5
a769 5
              putchar ('/');
	      PUT_CHAR (*p++);
            }
          while (--mcnt);
          break;
d771 1
a771 2
#  ifdef MBS_SUPPORT
	case exactn_bin:
d773 2
a774 13
	  printf ("/exactn_bin/%d", mcnt);
          do
	    {
	      printf("/%lx", (long int) *p++);
            }
          while (--mcnt);
          break;
#  endif /* MBS_SUPPORT */

	case start_memory:
          mcnt = *p++;
          printf ("/start_memory/%d/%ld", mcnt, (long int) *p++);
          break;
d777 3
a779 3
          mcnt = *p++;
	  printf ("/stop_memory/%d/%ld", mcnt, (long int) *p++);
          break;
d782 1
a782 1
	  printf ("/duplicate/%ld", (long int) *p++);
d790 3
a792 42
        case charset_not:
          {
#  ifdef WCHAR
	    int i, length;
	    wchar_t *workp = p;
	    printf ("/charset [%s",
	            (re_opcode_t) *(workp - 1) == charset_not ? "^" : "");
	    p += 5;
	    length = *workp++; /* the length of char_classes */
	    for (i=0 ; i<length ; i++)
	      printf("[:%lx:]", (long int) *p++);
	    length = *workp++; /* the length of collating_symbol */
	    for (i=0 ; i<length ;)
	      {
		printf("[.");
		while(*p != 0)
		  PUT_CHAR((i++,*p++));
		i++,p++;
		printf(".]");
	      }
	    length = *workp++; /* the length of equivalence_class */
	    for (i=0 ; i<length ;)
	      {
		printf("[=");
		while(*p != 0)
		  PUT_CHAR((i++,*p++));
		i++,p++;
		printf("=]");
	      }
	    length = *workp++; /* the length of char_range */
	    for (i=0 ; i<length ; i++)
	      {
		wchar_t range_start = *p++;
		wchar_t range_end = *p++;
		printf("%C-%C", range_start, range_end);
	      }
	    length = *workp++; /* the length of char */
	    for (i=0 ; i<length ; i++)
	      printf("%C", *p++);
	    putchar (']');
#  else
            register int c, last = -100;
d796 1
a796 1
	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
d798 1
a798 1
            assert (p + *p < pend);
d800 1
a800 1
            for (c = 0; c < 256; c++)
d812 1
a812 1
              {
d821 1
a821 1
              }
a828 1
#  endif /* WCHAR */
d834 1
a834 1
          break;
d837 2
a838 2
          printf ("/endline");
          break;
d841 3
a843 7
          PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/on_failure_jump to %td", p + mcnt - start);
#  else
  	  printf ("/on_failure_jump to %ld", (long int) (p + mcnt - start));
#  endif
          break;
d846 3
a848 8
          PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/on_failure_keep_string_jump to %td", p + mcnt - start);
#  else
  	  printf ("/on_failure_keep_string_jump to %ld",
		  (long int) (p + mcnt - start));
#  endif
          break;
d851 3
a853 7
          PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/dummy_failure_jump to %td", p + mcnt - start);
#  else
  	  printf ("/dummy_failure_jump to %ld", (long int) (p + mcnt - start));
#  endif
          break;
d856 22
a877 2
          printf ("/push_dummy_failure");
          break;
d879 5
a883 47
        case maybe_pop_jump:
          PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/maybe_pop_jump to %td", p + mcnt - start);
#  else
  	  printf ("/maybe_pop_jump to %ld", (long int) (p + mcnt - start));
#  endif
	  break;

        case pop_failure_jump:
	  PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/pop_failure_jump to %td", p + mcnt - start);
#  else
  	  printf ("/pop_failure_jump to %ld", (long int) (p + mcnt - start));
#  endif
	  break;

        case jump_past_alt:
	  PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/jump_past_alt to %td", p + mcnt - start);
#  else
  	  printf ("/jump_past_alt to %ld", (long int) (p + mcnt - start));
#  endif
	  break;

        case jump:
	  PREFIX(extract_number_and_incr) (&mcnt, &p);
#  ifdef _LIBC
  	  printf ("/jump to %td", p + mcnt - start);
#  else
  	  printf ("/jump to %ld", (long int) (p + mcnt - start));
#  endif
	  break;

        case succeed_n:
          PREFIX(extract_number_and_incr) (&mcnt, &p);
	  p1 = p + mcnt;
          PREFIX(extract_number_and_incr) (&mcnt2, &p);
#  ifdef _LIBC
	  printf ("/succeed_n to %td, %d times", p1 - start, mcnt2);
#  else
	  printf ("/succeed_n to %ld, %d times",
		  (long int) (p1 - start), mcnt2);
#  endif
          break;
d885 5
a889 6
        case jump_n:
          PREFIX(extract_number_and_incr) (&mcnt, &p);
	  p1 = p + mcnt;
          PREFIX(extract_number_and_incr) (&mcnt2, &p);
	  printf ("/jump_n to %d, %d times", p1 - start, mcnt2);
          break;
d891 5
a895 11
        case set_number_at:
          PREFIX(extract_number_and_incr) (&mcnt, &p);
	  p1 = p + mcnt;
          PREFIX(extract_number_and_incr) (&mcnt2, &p);
#  ifdef _LIBC
	  printf ("/set_number_at location %td to %d", p1 - start, mcnt2);
#  else
	  printf ("/set_number_at location %ld to %d",
		  (long int) (p1 - start), mcnt2);
#  endif
          break;
d897 1
a897 1
        case wordbound:
d903 1
a903 1
          break;
a910 1
	  break;
d912 1
a912 1
#  ifdef emacs
d915 1
a915 1
          break;
d919 1
a919 1
          break;
d923 1
a923 1
          break;
d926 1
a926 1
          printf ("/syntaxspec");
d929 1
a929 1
          break;
d932 1
a932 1
          printf ("/notsyntaxspec");
d936 1
a936 1
#  endif /* emacs */
d940 1
a940 1
          break;
d944 1
a944 1
          break;
d948 1
a948 1
          break;
d952 1
a952 1
          break;
d954 2
a955 2
        default:
          printf ("?%ld", (long int) *(p-1));
d961 1
a961 5
#  ifdef _LIBC
  printf ("%td:\tend of pattern.\n", p - start);
#  else
  printf ("%ld:\tend of pattern.\n", (long int) (p - start));
#  endif
d966 2
a967 1
PREFIX(print_compiled_pattern) (struct re_pattern_buffer *bufp)
d969 1
a969 1
  UCHAR_T *buffer = (UCHAR_T*) bufp->buffer;
d971 2
a972 4
  PREFIX(print_partial_compiled_pattern) (buffer, buffer
				  + bufp->used / sizeof(UCHAR_T));
  printf ("%ld bytes used/%ld bytes allocated.\n",
	  bufp->used, bufp->allocated);
d980 1
a980 5
#  ifdef _LIBC
  printf ("re_nsub: %Zd\t", bufp->re_nsub);
#  else
  printf ("re_nsub: %ld\t", (long int) bufp->re_nsub);
#  endif
d987 1
a987 1
  printf ("syntax: %lx\n", bufp->syntax);
d993 6
a998 5
PREFIX(print_double_string) (const CHAR_T *where,
			     const CHAR_T *string1,
			     const CHAR_T *string2,
			     int size1,
			     int size2)
d1000 1
a1000 1
  int this_char;
a1005 2
      int cnt;

d1007 3
a1009 3
        {
          for (this_char = where - string1; this_char < size1; this_char++)
	    PUT_CHAR (string1[this_char]);
d1011 2
a1012 2
          where = string2;
        }
a1013 1
      cnt = 0;
d1015 1
a1015 8
	{
	  PUT_CHAR (string2[this_char]);
	  if (++cnt > 100)
	    {
	      fputs ("...", stdout);
	      break;
	    }
	}
d1019 1
a1019 10
#  ifndef DEFINED_ONCE
void
printchar (c)
     int c;
{
  putc (c, stderr);
}
#  endif

# else /* not DEBUG */
d1021 2
a1022 12
#  ifndef DEFINED_ONCE
#   undef assert
#   define assert(e)

#   define DEBUG_STATEMENT(e)
#   define DEBUG_PRINT1(x)
#   define DEBUG_PRINT2(x1, x2)
#   define DEBUG_PRINT3(x1, x2, x3)
#   define DEBUG_PRINT4(x1, x2, x3, x4)
#  endif /* not DEFINED_ONCE */
#  define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
#  define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
d1024 7
a1030 1
# endif /* not DEBUG */
d1032 1
a1033 79

# ifdef WCHAR
/* This  convert a multibyte string to a wide character string.
   And write their correspondances to offset_buffer(see below)
   and write whether each wchar_t is binary data to is_binary.
   This assume invalid multibyte sequences as binary data.
   We assume offset_buffer and is_binary is already allocated
   enough space.  */

static size_t
convert_mbs_to_wcs (CHAR_T *dest,
		    const unsigned char* src,

		    /* The length of multibyte string.  */
		    size_t len,

		    /* Correspondences between src(char string) and
		       dest(wchar_t string) for optimization.  E.g.:
		       src  = "xxxyzz"
		       dest = {'X', 'Y', 'Z'}
			 (each "xxx", "y" and "zz" represent one
			  multibyte character corresponding to 'X',
			  'Y' and 'Z'.)
		       offset_buffer = {0, 0+3("xxx"), 0+3+1("y"),
					0+3+1+2("zz")}
				     = {0, 3, 4, 6} */
		    int *offset_buffer,

		    char *is_binary)
{
  wchar_t *pdest = dest;
  const unsigned char *psrc = src;
  size_t wc_count = 0;

  mbstate_t mbs;
  int i, consumed;
  size_t mb_remain = len;
  size_t mb_count = 0;

  /* Initialize the conversion state.  */
  memset (&mbs, 0, sizeof (mbstate_t));

  offset_buffer[0] = 0;
  for( ; mb_remain > 0 ; ++wc_count, ++pdest, mb_remain -= consumed,
	 psrc += consumed)
    {
      consumed = mbrtowc (pdest, psrc, mb_remain, &mbs);

      if (consumed <= 0)
	/* failed to convert. maybe src contains binary data.
	   So we consume 1 byte manualy.  */
	{
	  *pdest = *psrc;
	  consumed = 1;
	  is_binary[wc_count] = TRUE;
	}
      else
	is_binary[wc_count] = FALSE;
      /* In sjis encoding, we use yen sign as escape character in
	 place of reverse solidus. So we convert 0x5c(yen sign in
	 sjis) to not 0xa5(yen sign in UCS2) but 0x5c(reverse
	 solidus in UCS2).  */
      if (consumed == 1 && (int) *psrc == 0x5c && (int) *pdest == 0xa5)
	*pdest = (wchar_t) *psrc;

      offset_buffer[wc_count + 1] = mb_count += consumed;
    }

  /* Fill remain of the buffer with sentinel.  */
  for (i = wc_count + 1 ; i <= len ; i++)
    offset_buffer[i] = mb_count + 1;

  return wc_count;
}

# endif /* WCHAR */

#else /* not INSIDE_RECURSION */

d1047 1
a1047 1
   defined in regex.h.  We return the old syntax.  */
d1050 2
a1051 1
re_set_syntax (reg_syntax_t syntax)
a1055 6
# ifdef DEBUG
  if (syntax & RE_DEBUG)
    debug = 1;
  else if (debug) /* was on but now is not */
    debug = 0;
# endif /* DEBUG */
a1057 3
# ifdef _LIBC
weak_alias (__re_set_syntax, re_set_syntax)
# endif
d1060 1
a1060 1
   in regex.h.  Obviously the order here has to be same as there.
d1062 1
a1062 55
   but why not be nice?  */

static const char re_error_msgid[] =
  {
# define REG_NOERROR_IDX	0
    gettext_noop ("Success")	/* REG_NOERROR */
    "\0"
# define REG_NOMATCH_IDX (REG_NOERROR_IDX + sizeof "Success")
    gettext_noop ("No match")	/* REG_NOMATCH */
    "\0"
# define REG_BADPAT_IDX	(REG_NOMATCH_IDX + sizeof "No match")
    gettext_noop ("Invalid regular expression") /* REG_BADPAT */
    "\0"
# define REG_ECOLLATE_IDX (REG_BADPAT_IDX + sizeof "Invalid regular expression")
    gettext_noop ("Invalid collation character") /* REG_ECOLLATE */
    "\0"
# define REG_ECTYPE_IDX	(REG_ECOLLATE_IDX + sizeof "Invalid collation character")
    gettext_noop ("Invalid character class name") /* REG_ECTYPE */
    "\0"
# define REG_EESCAPE_IDX	(REG_ECTYPE_IDX + sizeof "Invalid character class name")
    gettext_noop ("Trailing backslash") /* REG_EESCAPE */
    "\0"
# define REG_ESUBREG_IDX	(REG_EESCAPE_IDX + sizeof "Trailing backslash")
    gettext_noop ("Invalid back reference") /* REG_ESUBREG */
    "\0"
# define REG_EBRACK_IDX	(REG_ESUBREG_IDX + sizeof "Invalid back reference")
    gettext_noop ("Unmatched [ or [^")	/* REG_EBRACK */
    "\0"
# define REG_EPAREN_IDX	(REG_EBRACK_IDX + sizeof "Unmatched [ or [^")
    gettext_noop ("Unmatched ( or \\(") /* REG_EPAREN */
    "\0"
# define REG_EBRACE_IDX	(REG_EPAREN_IDX + sizeof "Unmatched ( or \\(")
    gettext_noop ("Unmatched \\{") /* REG_EBRACE */
    "\0"
# define REG_BADBR_IDX	(REG_EBRACE_IDX + sizeof "Unmatched \\{")
    gettext_noop ("Invalid content of \\{\\}") /* REG_BADBR */
    "\0"
# define REG_ERANGE_IDX	(REG_BADBR_IDX + sizeof "Invalid content of \\{\\}")
    gettext_noop ("Invalid range end")	/* REG_ERANGE */
    "\0"
# define REG_ESPACE_IDX	(REG_ERANGE_IDX + sizeof "Invalid range end")
    gettext_noop ("Memory exhausted") /* REG_ESPACE */
    "\0"
# define REG_BADRPT_IDX	(REG_ESPACE_IDX + sizeof "Memory exhausted")
    gettext_noop ("Invalid preceding regular expression") /* REG_BADRPT */
    "\0"
# define REG_EEND_IDX	(REG_BADRPT_IDX + sizeof "Invalid preceding regular expression")
    gettext_noop ("Premature end of regular expression") /* REG_EEND */
    "\0"
# define REG_ESIZE_IDX	(REG_EEND_IDX + sizeof "Premature end of regular expression")
    gettext_noop ("Regular expression too big") /* REG_ESIZE */
    "\0"
# define REG_ERPAREN_IDX	(REG_ESIZE_IDX + sizeof "Regular expression too big")
    gettext_noop ("Unmatched ) or \\)") /* REG_ERPAREN */
  };
d1064 1
a1064 1
static const size_t re_error_msgid_idx[] =
d1066 17
a1082 17
    REG_NOERROR_IDX,
    REG_NOMATCH_IDX,
    REG_BADPAT_IDX,
    REG_ECOLLATE_IDX,
    REG_ECTYPE_IDX,
    REG_EESCAPE_IDX,
    REG_ESUBREG_IDX,
    REG_EBRACK_IDX,
    REG_EPAREN_IDX,
    REG_EBRACE_IDX,
    REG_BADBR_IDX,
    REG_ERANGE_IDX,
    REG_ESPACE_IDX,
    REG_BADRPT_IDX,
    REG_EEND_IDX,
    REG_ESIZE_IDX,
    REG_ERPAREN_IDX
d1085 1
a1085 4
#endif /* INSIDE_RECURSION */

#ifndef DEFINED_ONCE
/* Avoiding alloca during matching, to placate r_alloc.  */
d1105 1
a1105 1
# define MATCH_MAY_ALLOCATE
d1109 3
a1111 3
# ifdef __GNUC__
#  undef C_ALLOCA
# endif
d1117 5
a1121 5
   so REL_ALLOC should not affect this.  */
# if (defined C_ALLOCA || defined REGEX_MALLOC) && defined emacs
#  undef MATCH_MAY_ALLOCATE
# endif
#endif /* not DEFINED_ONCE */
a1122 1
#ifdef INSIDE_RECURSION
d1128 1
a1128 1
/* Number of failure points for which to initially allocate space
d1131 3
a1133 3
# ifndef INIT_FAILURE_ALLOC
#  define INIT_FAILURE_ALLOC 5
# endif
d1136 1
a1136 1
   exactly that if always used MAX_FAILURE_ITEMS items each time we failed.
d1138 10
a1147 13
   change it ourselves.  */

# ifdef INT_IS_16BIT

#  ifndef DEFINED_ONCE
#   if defined MATCH_MAY_ALLOCATE
/* 4400 was enough to cause a crash on Alpha OSF/1,
   whose default stack limit is 2mb.  */
long int re_max_failures = 4000;
#   else
long int re_max_failures = 2000;
#   endif
#  endif
d1149 1
a1149 1
union PREFIX(fail_stack_elt)
d1151 1
a1151 28
  UCHAR_T *pointer;
  long int integer;
};

typedef union PREFIX(fail_stack_elt) PREFIX(fail_stack_elt_t);

typedef struct
{
  PREFIX(fail_stack_elt_t) *stack;
  unsigned long int size;
  unsigned long int avail;		/* Offset of next open position.  */
} PREFIX(fail_stack_type);

# else /* not INT_IS_16BIT */

#  ifndef DEFINED_ONCE
#   if defined MATCH_MAY_ALLOCATE
/* 4400 was enough to cause a crash on Alpha OSF/1,
   whose default stack limit is 2mb.  */
int re_max_failures = 4000;
#   else
int re_max_failures = 2000;
#   endif
#  endif

union PREFIX(fail_stack_elt)
{
  UCHAR_T *pointer;
d1155 1
a1155 1
typedef union PREFIX(fail_stack_elt) PREFIX(fail_stack_elt_t);
d1159 1
a1159 1
  PREFIX(fail_stack_elt_t) *stack;
d1162 1
a1162 1
} PREFIX(fail_stack_type);
d1164 3
a1166 7
# endif /* INT_IS_16BIT */

# ifndef DEFINED_ONCE
#  define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
#  define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
#  define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
# endif
d1172 2
a1173 2
# ifdef MATCH_MAY_ALLOCATE
#  define INIT_FAIL_STACK()						\
d1175 3
a1177 2
    fail_stack.stack = (PREFIX(fail_stack_elt_t) *)		\
      REGEX_ALLOCATE_STACK (INIT_FAILURE_ALLOC * sizeof (PREFIX(fail_stack_elt_t))); \
d1179 1
a1179 1
    if (fail_stack.stack == NULL)				\
d1182 2
a1183 2
    fail_stack.size = INIT_FAILURE_ALLOC;			\
    fail_stack.avail = 0;					\
d1186 3
a1188 3
#  define RESET_FAIL_STACK()  REGEX_FREE_STACK (fail_stack.stack)
# else
#  define INIT_FAIL_STACK()						\
d1190 1
a1190 1
    fail_stack.avail = 0;					\
d1193 2
a1194 2
#  define RESET_FAIL_STACK()
# endif
d1197 2
a1198 1
/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
d1203 1
a1203 1
   REGEX_REALLOCATE_STACK requires `destination' be declared.   */
d1205 10
a1214 2
# define DOUBLE_FAIL_STACK(fail_stack)					\
  ((fail_stack).size > (unsigned) (re_max_failures * MAX_FAILURE_ITEMS)	\
d1216 7
a1222 4
   : ((fail_stack).stack = (PREFIX(fail_stack_elt_t) *)			\
        REGEX_REALLOCATE_STACK ((fail_stack).stack, 			\
          (fail_stack).size * sizeof (PREFIX(fail_stack_elt_t)),	\
          ((fail_stack).size << 1) * sizeof (PREFIX(fail_stack_elt_t))),\
d1226 6
a1231 2
      : ((fail_stack).size <<= 1, 					\
         1)))
d1237 1
a1237 1
# define PUSH_PATTERN_OP(POINTER, FAIL_STACK)				\
d1239 1
a1239 1
    && !DOUBLE_FAIL_STACK (FAIL_STACK))					\
d1246 3
a1248 3
   be called from within `PUSH_FAILURE_POINT'.  */
# define PUSH_FAILURE_POINTER(item)					\
  fail_stack.stack[fail_stack.avail++].pointer = (UCHAR_T *) (item)
d1252 2
a1253 2
   be called from within `PUSH_FAILURE_POINT'.  */
# define PUSH_FAILURE_INT(item)					\
d1258 2
a1259 2
   be called from within `PUSH_FAILURE_POINT'.  */
# define PUSH_FAILURE_ELT(item)					\
d1264 3
a1266 3
# define POP_FAILURE_POINTER() fail_stack.stack[--fail_stack.avail].pointer
# define POP_FAILURE_INT() fail_stack.stack[--fail_stack.avail].integer
# define POP_FAILURE_ELT() fail_stack.stack[--fail_stack.avail]
d1269 7
a1275 7
# ifdef DEBUG
#  define DEBUG_PUSH PUSH_FAILURE_INT
#  define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_INT ()
# else
#  define DEBUG_PUSH(item)
#  define DEBUG_POP(item_addr)
# endif
d1282 2
a1283 2
   num_regs_pushed be declared.  DOUBLE_FAIL_STACK requires `destination'
   be declared.
d1287 1
a1287 1
# define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
d1292 2
a1293 5
    /* Can't be int, since there is not a shred of a guarantee that int	\
       is wide enough to hold a value of something to which pointer can	\
       be assigned */							\
    active_reg_t this_reg;						\
    									\
d1298 1
a1298 1
    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
d1300 2
a1301 2
    DEBUG_PRINT2 ("  slots needed: %ld\n", NUM_FAILURE_ITEMS);		\
    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
d1306 2
a1307 2
        if (!DOUBLE_FAIL_STACK (fail_stack))				\
          return failure_code;						\
d1309 1
a1309 1
        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
d1311 1
a1311 1
        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
d1321 1
a1321 1
	  DEBUG_PRINT2 ("  Pushing reg: %lu\n", this_reg);		\
d1324 1
a1324 1
	  DEBUG_PRINT2 ("    start: %p\n", regstart[this_reg]);		\
d1327 1
a1327 1
	  DEBUG_PRINT2 ("    end: %p\n", regend[this_reg]);		\
d1330 1
a1330 2
	  DEBUG_PRINT2 ("    info: %p\n      ",				\
			reg_info[this_reg].word.pointer);		\
d1342 1
a1342 1
    DEBUG_PRINT2 ("  Pushing  low active reg: %ld\n", lowest_active_reg);\
d1345 1
a1345 1
    DEBUG_PRINT2 ("  Pushing high active reg: %ld\n", highest_active_reg);\
d1348 1
a1348 1
    DEBUG_PRINT2 ("  Pushing pattern %p:\n", pattern_place);		\
d1352 2
a1353 2
    DEBUG_PRINT2 ("  Pushing string %p: `", string_place);		\
    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
a1361 1
# ifndef DEFINED_ONCE
d1364 1
a1364 1
#  define NUM_REG_ITEMS  3
d1367 9
a1375 11
#  ifdef DEBUG
#   define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
#  else
#   define NUM_NONREG_ITEMS 4
#  endif

/* We push at most this many items on the stack.  */
/* We used to use (num_regs - 1), which is the number of registers
   this regexp will save; but that was changed to 5
   to avoid stack overflow for a regexp with lots of parens.  */
#  define MAX_FAILURE_ITEMS (5 * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
d1377 5
a1381 2
/* We actually push this many items.  */
#  define NUM_FAILURE_ITEMS				\
d1388 1
a1388 2
#  define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
# endif /* not DEFINED_ONCE */
d1401 3
a1403 2
   `pend', `string1', `size1', `string2', and `size2'.  */
# define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
d1405 3
a1407 3
  DEBUG_STATEMENT (unsigned failure_id;)				\
  active_reg_t this_reg;						\
  const UCHAR_T *string_temp;						\
d1414 1
a1414 1
  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
d1426 1
a1426 1
    str = (const CHAR_T *) string_temp;					\
d1428 1
a1428 1
  DEBUG_PRINT2 ("  Popping string %p: `", str);				\
d1432 2
a1433 2
  pat = (UCHAR_T *) POP_FAILURE_POINTER ();				\
  DEBUG_PRINT2 ("  Popping pattern %p:\n", pat);			\
d1437 2
a1438 2
  high_reg = (active_reg_t) POP_FAILURE_INT ();				\
  DEBUG_PRINT2 ("  Popping high active reg: %ld\n", high_reg);		\
d1440 2
a1441 2
  low_reg = (active_reg_t) POP_FAILURE_INT ();				\
  DEBUG_PRINT2 ("  Popping  low active reg: %ld\n", low_reg);		\
d1446 1
a1446 1
	DEBUG_PRINT2 ("    Popping reg: %ld\n", this_reg);		\
d1449 1
a1449 2
	DEBUG_PRINT2 ("      info: %p\n",				\
		      reg_info[this_reg].word.pointer);			\
d1451 2
a1452 2
	regend[this_reg] = (const CHAR_T *) POP_FAILURE_POINTER ();	\
	DEBUG_PRINT2 ("      end: %p\n", regend[this_reg]);		\
d1454 2
a1455 2
	regstart[this_reg] = (const CHAR_T *) POP_FAILURE_POINTER ();	\
	DEBUG_PRINT2 ("      start: %p\n", regstart[this_reg]);		\
d1471 2
a1484 3

/* Declarations and macros for re_match_2.  */

d1487 1
a1487 1
  PREFIX(fail_stack_elt_t) word;
d1491 2
a1492 2
         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
# define MATCH_NULL_UNSET_VALUE 3
d1498 1
a1498 1
} PREFIX(register_info_type);
d1500 4
a1503 5
# ifndef DEFINED_ONCE
#  define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
#  define IS_ACTIVE(R)  ((R).bits.is_active)
#  define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
#  define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
d1509 1
a1509 1
#  define SET_REGS_MATCHED()						\
d1514 1
a1514 1
	  active_reg_t r;						\
a1524 1
# endif /* not DEFINED_ONCE */
d1527 5
a1531 3
static CHAR_T PREFIX(reg_unset_dummy);
# define REG_UNSET_VALUE (&PREFIX(reg_unset_dummy))
# define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
d1533 5
a1537 31
/* Subroutine declarations and macros for regex_compile.  */
static void PREFIX(store_op1) (re_opcode_t op, UCHAR_T *loc, int arg);
static void PREFIX(store_op2) (re_opcode_t op, UCHAR_T *loc,
			       int arg1, int arg2);
static void PREFIX(insert_op1) (re_opcode_t op, UCHAR_T *loc,
				int arg, UCHAR_T *end);
static void PREFIX(insert_op2) (re_opcode_t op, UCHAR_T *loc,
				int arg1, int arg2, UCHAR_T *end);
static boolean PREFIX(at_begline_loc_p) (const CHAR_T *pattern,
					 const CHAR_T *p,
					 reg_syntax_t syntax);
static boolean PREFIX(at_endline_loc_p) (const CHAR_T *p,
					 const CHAR_T *pend,
					 reg_syntax_t syntax);
# ifdef WCHAR
static reg_errcode_t wcs_compile_range (CHAR_T range_start,
					const CHAR_T **p_ptr,
					const CHAR_T *pend,
					char *translate,
					reg_syntax_t syntax,
					UCHAR_T *b,
					CHAR_T *char_set);
static void insert_space (int num, CHAR_T *loc, CHAR_T *end);
# else /* BYTE */
static reg_errcode_t byte_compile_range (unsigned int range_start,
					 const char **p_ptr,
					 const char *pend,
					 char *translate,
					 reg_syntax_t syntax,
					 unsigned char *b);
# endif /* WCHAR */
d1543 2
a1544 12
/* ifdef MBS_SUPPORT, we translate only if character <= 0xff,
   because it is impossible to allocate 4GB array for some encodings
   which have 4 byte character_set like UCS4.  */
# ifndef PATFETCH
#  ifdef WCHAR
#   define PATFETCH(c)							\
  do {if (p == pend) return REG_EEND;					\
    c = (UCHAR_T) *p++;							\
    if (translate && (c <= 0xff)) c = (UCHAR_T) translate[c];		\
  } while (0)
#  else /* BYTE */
#   define PATFETCH(c)							\
d1547 1
a1547 1
    if (translate) c = (unsigned char) translate[c];			\
d1549 1
a1549 2
#  endif /* WCHAR */
# endif
d1552 2
a1553 2
   translation.  */
# define PATFETCH_RAW(c)						\
d1555 1
a1555 1
    c = (UCHAR_T) *p++; 	       					\
d1559 1
a1559 1
# define PATUNFETCH p--
d1566 5
a1570 14
/* ifdef MBS_SUPPORT, we translate only if character <= 0xff,
   because it is impossible to allocate 4GB array for some encodings
   which have 4 byte character_set like UCS4.  */

# ifndef TRANSLATE
#  ifdef WCHAR
#   define TRANSLATE(d) \
  ((translate && ((UCHAR_T) (d)) <= 0xff) \
   ? (char) translate[(unsigned char) (d)] : (d))
# else /* BYTE */
#   define TRANSLATE(d) \
  (translate ? (char) translate[(unsigned char) (d)] : (d))
#  endif /* WCHAR */
# endif
d1576 1
a1576 1
# define INIT_BUF_SIZE  (32 * sizeof(UCHAR_T))
d1578 3
a1580 9
/* Make sure we have at least N more bytes of space in buffer.  */
# ifdef WCHAR
#  define GET_BUFFER_SPACE(n)						\
    while (((unsigned long)b - (unsigned long)COMPILED_BUFFER_VAR	\
            + (n)*sizeof(CHAR_T)) > bufp->allocated)			\
      EXTEND_BUFFER ()
# else /* BYTE */
#  define GET_BUFFER_SPACE(n)						\
    while ((unsigned long) (b - bufp->buffer + (n)) > bufp->allocated)	\
a1581 1
# endif /* WCHAR */
d1584 1
a1584 1
# define BUF_PUSH(c)							\
d1587 1
a1587 1
    *b++ = (UCHAR_T) (c);						\
d1592 1
a1592 1
# define BUF_PUSH_2(c1, c2)						\
d1595 2
a1596 2
    *b++ = (UCHAR_T) (c1);						\
    *b++ = (UCHAR_T) (c2);						\
d1600 2
a1601 2
/* As with BUF_PUSH_2, except for three bytes.  */
# define BUF_PUSH_3(c1, c2, c3)						\
d1604 3
a1606 3
    *b++ = (UCHAR_T) (c1);						\
    *b++ = (UCHAR_T) (c2);						\
    *b++ = (UCHAR_T) (c3);						\
d1609 1
d1611 3
a1613 3
   relative address offset by the three bytes the jump itself occupies.  */
# define STORE_JUMP(op, loc, to) \
 PREFIX(store_op1) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)))
d1616 2
a1617 2
# define STORE_JUMP2(op, loc, to, arg) \
  PREFIX(store_op2) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)), arg)
d1619 3
a1621 3
/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
# define INSERT_JUMP(op, loc, to) \
  PREFIX(insert_op1) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)), b)
d1624 3
a1626 3
# define INSERT_JUMP2(op, loc, to, arg) \
  PREFIX(insert_op2) (op, loc, (int) ((to) - (loc) - (1 + OFFSET_ADDRESS_SIZE)),\
	      arg, b)
d1629 1
a1629 1
   into the pattern are two bytes long.  So if 2^16 bytes turns out to
d1631 2
a1632 16
/* Any other compiler which, like MSC, has allocation limit below 2^16
   bytes will have to use approach similar to what was done below for
   MSC and drop MAX_BUF_SIZE a bit.  Otherwise you may end up
   reallocating to 0 bytes.  Such thing is not going to work too well.
   You have been warned!!  */
# ifndef DEFINED_ONCE
#  if defined _MSC_VER  && !defined WIN32
/* Microsoft C 16-bit versions limit malloc to approx 65512 bytes.
   The REALLOC define eliminates a flurry of conversion warnings,
   but is not required. */
#   define MAX_BUF_SIZE  65500L
#   define REALLOC(p,s) realloc ((p), (size_t) (s))
#  else
#   define MAX_BUF_SIZE (1L << 16)
#   define REALLOC(p,s) realloc ((p), (s))
#  endif
d1637 2
a1638 59
   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
#  if __BOUNDED_POINTERS__
#   define SET_HIGH_BOUND(P) (__ptrhigh (P) = __ptrlow (P) + bufp->allocated)
#   define MOVE_BUFFER_POINTER(P) \
  (__ptrlow (P) += incr, SET_HIGH_BOUND (P), __ptrvalue (P) += incr)
#   define ELSE_EXTEND_BUFFER_HIGH_BOUND	\
  else						\
    {						\
      SET_HIGH_BOUND (b);			\
      SET_HIGH_BOUND (begalt);			\
      if (fixup_alt_jump)			\
	SET_HIGH_BOUND (fixup_alt_jump);	\
      if (laststart)				\
	SET_HIGH_BOUND (laststart);		\
      if (pending_exact)			\
	SET_HIGH_BOUND (pending_exact);		\
    }
#  else
#   define MOVE_BUFFER_POINTER(P) (P) += incr
#   define ELSE_EXTEND_BUFFER_HIGH_BOUND
#  endif
# endif /* not DEFINED_ONCE */

# ifdef WCHAR
#  define EXTEND_BUFFER()						\
  do {									\
    UCHAR_T *old_buffer = COMPILED_BUFFER_VAR;				\
    int wchar_count;							\
    if (bufp->allocated + sizeof(UCHAR_T) > MAX_BUF_SIZE)		\
      return REG_ESIZE;							\
    bufp->allocated <<= 1;						\
    if (bufp->allocated > MAX_BUF_SIZE)					\
      bufp->allocated = MAX_BUF_SIZE;					\
    /* How many characters the new buffer can have?  */			\
    wchar_count = bufp->allocated / sizeof(UCHAR_T);			\
    if (wchar_count == 0) wchar_count = 1;				\
    /* Truncate the buffer to CHAR_T align.  */			\
    bufp->allocated = wchar_count * sizeof(UCHAR_T);			\
    RETALLOC (COMPILED_BUFFER_VAR, wchar_count, UCHAR_T);		\
    bufp->buffer = (char*)COMPILED_BUFFER_VAR;				\
    if (COMPILED_BUFFER_VAR == NULL)					\
      return REG_ESPACE;						\
    /* If the buffer moved, move all the pointers into it.  */		\
    if (old_buffer != COMPILED_BUFFER_VAR)				\
      {									\
	int incr = COMPILED_BUFFER_VAR - old_buffer;			\
	MOVE_BUFFER_POINTER (b);					\
	MOVE_BUFFER_POINTER (begalt);					\
	if (fixup_alt_jump)						\
	  MOVE_BUFFER_POINTER (fixup_alt_jump);				\
	if (laststart)							\
	  MOVE_BUFFER_POINTER (laststart);				\
	if (pending_exact)						\
	  MOVE_BUFFER_POINTER (pending_exact);				\
      }									\
    ELSE_EXTEND_BUFFER_HIGH_BOUND					\
  } while (0)
# else /* BYTE */
#  define EXTEND_BUFFER()						\
d1640 1
a1640 1
    UCHAR_T *old_buffer = COMPILED_BUFFER_VAR;				\
d1646 2
a1647 2
    bufp->buffer = REALLOC (COMPILED_BUFFER_VAR, bufp->allocated);	\
    if (COMPILED_BUFFER_VAR == NULL)					\
d1650 1
a1650 1
    if (old_buffer != COMPILED_BUFFER_VAR)				\
d1652 2
a1653 3
	int incr = COMPILED_BUFFER_VAR - old_buffer;			\
	MOVE_BUFFER_POINTER (b);					\
	MOVE_BUFFER_POINTER (begalt);					\
d1655 1
a1655 1
	  MOVE_BUFFER_POINTER (fixup_alt_jump);				\
d1657 1
a1657 1
	  MOVE_BUFFER_POINTER (laststart);				\
d1659 1
a1659 1
	  MOVE_BUFFER_POINTER (pending_exact);				\
a1660 1
    ELSE_EXTEND_BUFFER_HIGH_BOUND					\
a1661 1
# endif /* WCHAR */
d1663 1
a1663 1
# ifndef DEFINED_ONCE
d1667 1
a1667 1
#  define MAX_REGNUM 255
d1677 2
a1678 3
   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
/* int may be not enough when sizeof(int) == 2.  */
typedef long pattern_offset_t;
d1698 41
a1738 1
#  define INIT_COMPILE_STACK_SIZE 32
d1740 6
a1745 2
#  define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
#  define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
d1747 3
a1749 2
/* The next available element.  */
#  define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
a1750 1
# endif /* not DEFINED_ONCE */
d1753 2
a1754 3
# ifndef DEFINED_ONCE
#  define SET_LIST_BIT(c)                               \
  (b[((unsigned char) (c)) / BYTEWIDTH]               \
d1756 1
a1756 1
# endif /* DEFINED_ONCE */
d1759 7
a1765 10
# define GET_UNSIGNED_NUMBER(num) \
  {									\
    while (p != pend)							\
      {									\
	PATFETCH (c);							\
	if (c < '0' || c > '9')						\
	  break;							\
	if (num <= RE_DUP_MAX)						\
	  {								\
	    if (num < 0)						\
d1767 7
a1773 4
	    num = num * 10 + c - '0';					\
	  }								\
      }									\
  }
d1775 1
a1775 19
# ifndef DEFINED_ONCE
#  if defined _LIBC || WIDE_CHAR_SUPPORT
/* The GNU C library provides support for user-defined character classes
   and the functions from ISO C amendement 1.  */
#   ifdef CHARCLASS_NAME_MAX
#    define CHAR_CLASS_MAX_LENGTH CHARCLASS_NAME_MAX
#   else
/* This shouldn't happen but some implementation might still have this
   problem.  Use a reasonable default value.  */
#    define CHAR_CLASS_MAX_LENGTH 256
#   endif

#   ifdef _LIBC
#    define IS_CHAR_CLASS(string) __wctype (string)
#   else
#    define IS_CHAR_CLASS(string) wctype (string)
#   endif
#  else
#   define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
d1777 1
a1777 1
#   define IS_CHAR_CLASS(string)					\
a1783 2
#  endif
# endif /* DEFINED_ONCE */
d1785 1
a1785 1
# ifndef MATCH_MAY_ALLOCATE
d1794 1
a1794 1
static PREFIX(fail_stack_type) fail_stack;
d1798 1
a1798 2
   but never make them smaller.  */
#  ifdef DEFINED_ONCE
d1801 1
a1801 1
static const char **     regstart, **     regend;
d1804 1
d1806 1
a1806 4
#  endif /* DEFINED_ONCE */

static PREFIX(register_info_type) *PREFIX(reg_info);
static PREFIX(register_info_type) *PREFIX(reg_info_dummy);
d1809 1
a1809 1
   but don't make them smaller.  */
d1811 3
a1813 2
static void
PREFIX(regex_grow_registers) (int num_regs)
d1823 1
a1823 1
      RETALLOC_IF (PREFIX(reg_info), num_regs, PREFIX(register_info_type));
d1825 1
a1825 1
      RETALLOC_IF (PREFIX(reg_info_dummy), num_regs, PREFIX(register_info_type));
d1831 1
a1831 1
# endif /* not MATCH_MAY_ALLOCATE */
a1832 6
# ifndef DEFINED_ONCE
static boolean group_in_compile_stack (compile_stack_type
				       compile_stack,
				       regnum_t regnum);
# endif /* not DEFINED_ONCE */

d1852 6
a1857 7
# ifdef WCHAR
#  define FREE_STACK_RETURN(value)		\
  return (free(pattern), free(mbs_offset), free(is_binary), free (compile_stack.stack), value)
# else
#  define FREE_STACK_RETURN(value)		\
  return (free (compile_stack.stack), value)
# endif /* WCHAR */
d1860 5
a1864 4
PREFIX(regex_compile) (const char *ARG_PREFIX(pattern),
		       size_t ARG_PREFIX(size),
		       reg_syntax_t syntax,
		       struct re_pattern_buffer *bufp)
d1869 1
a1869 13
  register UCHAR_T c, c1;

#ifdef WCHAR
  /* A temporary space to keep wchar_t pattern and compiled pattern.  */
  CHAR_T *pattern, *COMPILED_BUFFER_VAR;
  size_t size;
  /* offset buffer for optimization. See convert_mbs_to_wc.  */
  int *mbs_offset = NULL;
  /* It hold whether each wchar_t is binary data or not.  */
  char *is_binary = NULL;
  /* A flag whether exactn is handling binary data or not.  */
  char is_exactn_bin = FALSE;
#endif /* WCHAR */
d1872 1
a1872 1
  const CHAR_T *p1;
d1875 1
a1875 1
  register UCHAR_T *b;
d1881 7
a1887 7
#ifdef WCHAR
  const CHAR_T *p;
  const CHAR_T *pend;
#else /* BYTE */
  const CHAR_T *p = pattern;
  const CHAR_T *pend = pattern + size;
#endif /* WCHAR */
d1896 1
a1896 1
  UCHAR_T *pending_exact = 0;
d1901 1
a1901 1
  UCHAR_T *laststart = 0;
d1904 5
a1908 1
  UCHAR_T *begalt;
d1911 1
a1911 1
     the containing expression.  Each alternative of an `or' -- except the
d1913 1
a1913 1
  UCHAR_T *fixup_alt_jump = 0;
d1920 2
a1921 23
#ifdef WCHAR
  /* Initialize the wchar_t PATTERN and offset_buffer.  */
  p = pend = pattern = TALLOC(csize + 1, CHAR_T);
  mbs_offset = TALLOC(csize + 1, int);
  is_binary = TALLOC(csize + 1, char);
  if (pattern == NULL || mbs_offset == NULL || is_binary == NULL)
    {
      free(pattern);
      free(mbs_offset);
      free(is_binary);
      return REG_ESPACE;
    }
  pattern[csize] = L'\0';	/* sentinel */
  size = convert_mbs_to_wcs(pattern, cpattern, csize, mbs_offset, is_binary);
  pend = p + size;
  if (size < 0)
    {
      free(pattern);
      free(mbs_offset);
      free(is_binary);
      return REG_BADPAT;
    }
#endif
d1930 1
a1930 1
        PUT_CHAR (pattern[debug_count]);
d1938 1
a1938 8
    {
#ifdef WCHAR
      free(pattern);
      free(mbs_offset);
      free(is_binary);
#endif
      return REG_ESPACE;
    }
d1943 3
d1959 9
a1967 1
#if !defined emacs && !defined SYNTAX_TABLE
d1976 4
a1979 12
             enough space.  This loses if buffer's address is bogus, but
             that is the user's responsibility.  */
#ifdef WCHAR
	  /* Free bufp->buffer and allocate an array for wchar_t pattern
	     buffer.  */
          free(bufp->buffer);
          COMPILED_BUFFER_VAR = TALLOC (INIT_BUF_SIZE/sizeof(UCHAR_T),
					UCHAR_T);
#else
          RETALLOC (COMPILED_BUFFER_VAR, INIT_BUF_SIZE, UCHAR_T);
#endif /* WCHAR */
        }
d1981 4
a1984 4
        { /* Caller did not allocate a buffer.  Do it for them.  */
          COMPILED_BUFFER_VAR = TALLOC (INIT_BUF_SIZE / sizeof(UCHAR_T),
					UCHAR_T);
        }
a1985 4
      if (!COMPILED_BUFFER_VAR) FREE_STACK_RETURN (REG_ESPACE);
#ifdef WCHAR
      bufp->buffer = (char*)COMPILED_BUFFER_VAR;
#endif /* WCHAR */
a1987 4
#ifdef WCHAR
  else
    COMPILED_BUFFER_VAR = (UCHAR_T*) bufp->buffer;
#endif
d1989 1
a1989 1
  begalt = b = COMPILED_BUFFER_VAR;
d1997 14
a2010 14
        {
        case '^':
          {
            if (   /* If at start of pattern, it's an operator.  */
                   p == pattern + 1
                   /* If context independent, it's an operator.  */
                || syntax & RE_CONTEXT_INDEP_ANCHORS
                   /* Otherwise, depends on what's come before.  */
                || PREFIX(at_begline_loc_p) (pattern, p, syntax))
              BUF_PUSH (begline);
            else
              goto normal_char;
          }
          break;
d2013 13
a2025 13
        case '$':
          {
            if (   /* If at end of pattern, it's an operator.  */
                   p == pend
                   /* If context independent, it's an operator.  */
                || syntax & RE_CONTEXT_INDEP_ANCHORS
                   /* Otherwise, depends on what's next.  */
                || PREFIX(at_endline_loc_p) (p, pend, syntax))
               BUF_PUSH (endline);
             else
               goto normal_char;
           }
           break;
d2029 34
a2062 14
        case '?':
          if ((syntax & RE_BK_PLUS_QM)
              || (syntax & RE_LIMITED_OPS))
            goto normal_char;
        handle_plus:
        case '*':
          /* If there is no previous pattern... */
          if (!laststart)
            {
              if (syntax & RE_CONTEXT_INVALID_OPS)
                FREE_STACK_RETURN (REG_BADRPT);
              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
                goto normal_char;
            }
d2064 1
a2064 16
          {
            /* Are we optimizing this jump?  */
            boolean keep_string_p = false;

            /* 1 means zero (many) matches is allowed.  */
            char zero_times_ok = 0, many_times_ok = 0;

            /* If there is a sequence of repetition chars, collapse it
               down to just one (the right one).  We can't combine
               interval operators with these because of, e.g., `a{2}*',
               which should only match an even number of `a's.  */

            for (;;)
              {
                zero_times_ok |= c != '+';
                many_times_ok |= c != '?';
d2066 3
a2068 2
                if (p == pend)
                  break;
d2070 3
a2072 1
                PATFETCH (c);
d2074 7
a2080 23
                if (c == '*'
                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
                  ;

                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
                  {
                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);

                    PATFETCH (c1);
                    if (!(c1 == '+' || c1 == '?'))
                      {
                        PATUNFETCH;
                        PATUNFETCH;
                        break;
                      }

                    c = c1;
                  }
                else
                  {
                    PATUNFETCH;
                    break;
                  }
d2082 7
a2088 2
                /* If we get here, we found another repeat character.  */
               }
d2090 2
a2091 70
            /* Star, etc. applied to an empty pattern is equivalent
               to an empty pattern.  */
            if (!laststart)
              break;

            /* Now we know whether or not zero matches is allowed
               and also whether or not two or more matches is allowed.  */
            if (many_times_ok)
              { /* More than one repetition is allowed, so put in at the
                   end a backward relative jump from `b' to before the next
                   jump we're going to put in below (which jumps from
                   laststart to after this jump).

                   But if we are at the `*' in the exact sequence `.*\n',
                   insert an unconditional jump backwards to the .,
                   instead of the beginning of the loop.  This way we only
                   push a failure point once, instead of every time
                   through the loop.  */
                assert (p - 1 > pattern);

                /* Allocate the space for the jump.  */
                GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);

                /* We know we are not at the first character of the pattern,
                   because laststart was nonzero.  And we've already
                   incremented `p', by the way, to be the character after
                   the `*'.  Do we have to do something analogous here
                   for null bytes, because of RE_DOT_NOT_NULL?  */
                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
		    && zero_times_ok
                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
                    && !(syntax & RE_DOT_NEWLINE))
                  { /* We have .*\n.  */
                    STORE_JUMP (jump, b, laststart);
                    keep_string_p = true;
                  }
                else
                  /* Anything else.  */
                  STORE_JUMP (maybe_pop_jump, b, laststart -
			      (1 + OFFSET_ADDRESS_SIZE));

                /* We've added more stuff to the buffer.  */
                b += 1 + OFFSET_ADDRESS_SIZE;
              }

            /* On failure, jump from laststart to b + 3, which will be the
               end of the buffer after this jump is inserted.  */
	    /* ifdef WCHAR, 'b + 1 + OFFSET_ADDRESS_SIZE' instead of
	       'b + 3'.  */
            GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);
            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
                                       : on_failure_jump,
                         laststart, b + 1 + OFFSET_ADDRESS_SIZE);
            pending_exact = 0;
            b += 1 + OFFSET_ADDRESS_SIZE;

            if (!zero_times_ok)
              {
                /* At least one repetition is required, so insert a
                   `dummy_failure_jump' before the initial
                   `on_failure_jump' instruction of the loop. This
                   effects a skip over that instruction the first time
                   we hit that loop.  */
                GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);
                INSERT_JUMP (dummy_failure_jump, laststart, laststart +
			     2 + 2 * OFFSET_ADDRESS_SIZE);
                b += 1 + OFFSET_ADDRESS_SIZE;
              }
            }
	  break;
d2093 4
d2098 35
a2132 4
	case '.':
          laststart = b;
          BUF_PUSH (anychar);
          break;
d2134 3
d2138 8
a2145 9
        case '[':
          {
            boolean had_char_class = false;
#ifdef WCHAR
	    CHAR_T range_start = 0xffffffff;
#else
	    unsigned int range_start = 0xffffffff;
#endif
            if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
d2147 1
a2147 72
#ifdef WCHAR
	    /* We assume a charset(_not) structure as a wchar_t array.
	       charset[0] = (re_opcode_t) charset(_not)
               charset[1] = l (= length of char_classes)
               charset[2] = m (= length of collating_symbols)
               charset[3] = n (= length of equivalence_classes)
	       charset[4] = o (= length of char_ranges)
	       charset[5] = p (= length of chars)

               charset[6] = char_class (wctype_t)
               charset[6+CHAR_CLASS_SIZE] = char_class (wctype_t)
                         ...
               charset[l+5]  = char_class (wctype_t)

               charset[l+6]  = collating_symbol (wchar_t)
                            ...
               charset[l+m+5]  = collating_symbol (wchar_t)
					ifdef _LIBC we use the index if
					_NL_COLLATE_SYMB_EXTRAMB instead of
					wchar_t string.

               charset[l+m+6]  = equivalence_classes (wchar_t)
                              ...
               charset[l+m+n+5]  = equivalence_classes (wchar_t)
					ifdef _LIBC we use the index in
					_NL_COLLATE_WEIGHT instead of
					wchar_t string.

	       charset[l+m+n+6] = range_start
	       charset[l+m+n+7] = range_end
	                       ...
	       charset[l+m+n+2o+4] = range_start
	       charset[l+m+n+2o+5] = range_end
					ifdef _LIBC we use the value looked up
					in _NL_COLLATE_COLLSEQ instead of
					wchar_t character.

	       charset[l+m+n+2o+6] = char
	                          ...
	       charset[l+m+n+2o+p+5] = char

	     */

	    /* We need at least 6 spaces: the opcode, the length of
               char_classes, the length of collating_symbols, the length of
               equivalence_classes, the length of char_ranges, the length of
               chars.  */
	    GET_BUFFER_SPACE (6);

	    /* Save b as laststart. And We use laststart as the pointer
	       to the first element of the charset here.
	       In other words, laststart[i] indicates charset[i].  */
            laststart = b;

            /* We test `*p == '^' twice, instead of using an if
               statement, so we only need one BUF_PUSH.  */
            BUF_PUSH (*p == '^' ? charset_not : charset);
            if (*p == '^')
              p++;

            /* Push the length of char_classes, the length of
               collating_symbols, the length of equivalence_classes, the
               length of char_ranges and the length of chars.  */
            BUF_PUSH_3 (0, 0, 0);
            BUF_PUSH_2 (0, 0);

            /* Remember the first position in the bracket expression.  */
            p1 = p;

            /* charset_not matches newline according to a syntax bit.  */
            if ((re_opcode_t) b[-6] == charset_not
                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
d2149 8
a2156 2
		BUF_PUSH('\n');
		laststart[5]++; /* Update the length of characters  */
d2158 2
a2160 102
            /* Read in characters and ranges, setting map bits.  */
            for (;;)
              {
                if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                PATFETCH (c);

                /* \ might escape characters inside [...] and [^...].  */
                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
                  {
                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);

                    PATFETCH (c1);
		    BUF_PUSH(c1);
		    laststart[5]++; /* Update the length of chars  */
		    range_start = c1;
                    continue;
                  }

                /* Could be the end of the bracket expression.  If it's
                   not (i.e., when the bracket expression is `[]' so
                   far), the ']' character bit gets set way below.  */
                if (c == ']' && p != p1 + 1)
                  break;

                /* Look ahead to see if it's a range when the last thing
                   was a character class.  */
                if (had_char_class && c == '-' && *p != ']')
                  FREE_STACK_RETURN (REG_ERANGE);

                /* Look ahead to see if it's a range when the last thing
                   was a character: if this is a hyphen not at the
                   beginning or the end of a list, then it's the range
                   operator.  */
                if (c == '-'
                    && !(p - 2 >= pattern && p[-2] == '[')
                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
                    && *p != ']')
                  {
                    reg_errcode_t ret;
		    /* Allocate the space for range_start and range_end.  */
		    GET_BUFFER_SPACE (2);
		    /* Update the pointer to indicate end of buffer.  */
                    b += 2;
                    ret = wcs_compile_range (range_start, &p, pend, translate,
                                         syntax, b, laststart);
                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
                    range_start = 0xffffffff;
                  }
                else if (p[0] == '-' && p[1] != ']')
                  { /* This handles ranges made up of characters only.  */
                    reg_errcode_t ret;

		    /* Move past the `-'.  */
                    PATFETCH (c1);
		    /* Allocate the space for range_start and range_end.  */
		    GET_BUFFER_SPACE (2);
		    /* Update the pointer to indicate end of buffer.  */
                    b += 2;
                    ret = wcs_compile_range (c, &p, pend, translate, syntax, b,
                                         laststart);
                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
		    range_start = 0xffffffff;
                  }

                /* See if we're at the beginning of a possible character
                   class.  */
                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
                  { /* Leave room for the null.  */
                    char str[CHAR_CLASS_MAX_LENGTH + 1];

                    PATFETCH (c);
                    c1 = 0;

                    /* If pattern is `[[:'.  */
                    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                    for (;;)
                      {
                        PATFETCH (c);
                        if ((c == ':' && *p == ']') || p == pend)
                          break;
			if (c1 < CHAR_CLASS_MAX_LENGTH)
			  str[c1++] = c;
			else
			  /* This is in any case an invalid class name.  */
			  str[0] = '\0';
                      }
                    str[c1] = '\0';

                    /* If isn't a word bracketed by `[:' and `:]':
                       undo the ending character, the letters, and leave
                       the leading `:' and `[' (but store them as character).  */
                    if (c == ':' && *p == ']')
                      {
			wctype_t wt;
			uintptr_t alignedp;

			/* Query the character class as wctype_t.  */
			wt = IS_CHAR_CLASS (str);
			if (wt == 0)
			  FREE_STACK_RETURN (REG_ECTYPE);
d2162 4
a2165 48
                        /* Throw away the ] at the end of the character
                           class.  */
                        PATFETCH (c);

                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

			/* Allocate the space for character class.  */
                        GET_BUFFER_SPACE(CHAR_CLASS_SIZE);
			/* Update the pointer to indicate end of buffer.  */
                        b += CHAR_CLASS_SIZE;
			/* Move data which follow character classes
			    not to violate the data.  */
                        insert_space(CHAR_CLASS_SIZE,
				     laststart + 6 + laststart[1],
				     b - 1);
			alignedp = ((uintptr_t)(laststart + 6 + laststart[1])
				    + __alignof__(wctype_t) - 1)
			  	    & ~(uintptr_t)(__alignof__(wctype_t) - 1);
			/* Store the character class.  */
                        *((wctype_t*)alignedp) = wt;
                        /* Update length of char_classes */
                        laststart[1] += CHAR_CLASS_SIZE;

                        had_char_class = true;
                      }
                    else
                      {
                        c1++;
                        while (c1--)
                          PATUNFETCH;
                        BUF_PUSH ('[');
                        BUF_PUSH (':');
                        laststart[5] += 2; /* Update the length of characters  */
			range_start = ':';
                        had_char_class = false;
                      }
                  }
                else if (syntax & RE_CHAR_CLASSES && c == '[' && (*p == '='
							  || *p == '.'))
		  {
		    CHAR_T str[128];	/* Should be large enough.  */
		    CHAR_T delim = *p; /* '=' or '.'  */
# ifdef _LIBC
		    uint32_t nrules =
		      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
# endif
		    PATFETCH (c);
		    c1 = 0;
a2166 2
		    /* If pattern is `[[=' or '[[.'.  */
		    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
d2168 3
a2170 12
		    for (;;)
		      {
			PATFETCH (c);
			if ((c == delim && *p == ']') || p == pend)
			  break;
			if (c1 < sizeof (str) - 1)
			  str[c1++] = c;
			else
			  /* This is in any case an invalid class name.  */
			  str[0] = '\0';
                      }
		    str[c1] = '\0';
d2172 1
a2172 216
		    if (c == delim && *p == ']' && str[0] != '\0')
		      {
                        unsigned int i, offset;
			/* If we have no collation data we use the default
			   collation in which each character is in a class
			   by itself.  It also means that ASCII is the
			   character set and therefore we cannot have character
			   with more than one byte in the multibyte
			   representation.  */

                        /* If not defined _LIBC, we push the name and
			   `\0' for the sake of matching performance.  */
			int datasize = c1 + 1;

# ifdef _LIBC
			int32_t idx = 0;
			if (nrules == 0)
# endif
			  {
			    if (c1 != 1)
			      FREE_STACK_RETURN (REG_ECOLLATE);
			  }
# ifdef _LIBC
			else
			  {
			    const int32_t *table;
			    const int32_t *weights;
			    const int32_t *extra;
			    const int32_t *indirect;
			    wint_t *cp;

			    /* This #include defines a local function!  */
#  include <locale/weightwc.h>

			    if(delim == '=')
			      {
				/* We push the index for equivalence class.  */
				cp = (wint_t*)str;

				table = (const int32_t *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_TABLEWC);
				weights = (const int32_t *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_WEIGHTWC);
				extra = (const int32_t *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_EXTRAWC);
				indirect = (const int32_t *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_INDIRECTWC);

				idx = findidx ((const wint_t**)&cp);
				if (idx == 0 || cp < (wint_t*) str + c1)
				  /* This is no valid character.  */
				  FREE_STACK_RETURN (REG_ECOLLATE);

				str[0] = (wchar_t)idx;
			      }
			    else /* delim == '.' */
			      {
				/* We push collation sequence value
				   for collating symbol.  */
				int32_t table_size;
				const int32_t *symb_table;
				const unsigned char *extra;
				int32_t idx;
				int32_t elem;
				int32_t second;
				int32_t hash;
				char char_str[c1];

				/* We have to convert the name to a single-byte
				   string.  This is possible since the names
				   consist of ASCII characters and the internal
				   representation is UCS4.  */
				for (i = 0; i < c1; ++i)
				  char_str[i] = str[i];

				table_size =
				  _NL_CURRENT_WORD (LC_COLLATE,
						    _NL_COLLATE_SYMB_HASH_SIZEMB);
				symb_table = (const int32_t *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_SYMB_TABLEMB);
				extra = (const unsigned char *)
				  _NL_CURRENT (LC_COLLATE,
					       _NL_COLLATE_SYMB_EXTRAMB);

				/* Locate the character in the hashing table.  */
				hash = elem_hash (char_str, c1);

				idx = 0;
				elem = hash % table_size;
				second = hash % (table_size - 2);
				while (symb_table[2 * elem] != 0)
				  {
				    /* First compare the hashing value.  */
				    if (symb_table[2 * elem] == hash
					&& c1 == extra[symb_table[2 * elem + 1]]
					&& memcmp (char_str,
						   &extra[symb_table[2 * elem + 1]
							 + 1], c1) == 0)
				      {
					/* Yep, this is the entry.  */
					idx = symb_table[2 * elem + 1];
					idx += 1 + extra[idx];
					break;
				      }

				    /* Next entry.  */
				    elem += second;
				  }

				if (symb_table[2 * elem] != 0)
				  {
				    /* Compute the index of the byte sequence
				       in the table.  */
				    idx += 1 + extra[idx];
				    /* Adjust for the alignment.  */
				    idx = (idx + 3) & ~3;

				    str[0] = (wchar_t) idx + 4;
				  }
				else if (symb_table[2 * elem] == 0 && c1 == 1)
				  {
				    /* No valid character.  Match it as a
				       single byte character.  */
				    had_char_class = false;
				    BUF_PUSH(str[0]);
				    /* Update the length of characters  */
				    laststart[5]++;
				    range_start = str[0];

				    /* Throw away the ] at the end of the
				       collating symbol.  */
				    PATFETCH (c);
				    /* exit from the switch block.  */
				    continue;
				  }
				else
				  FREE_STACK_RETURN (REG_ECOLLATE);
			      }
			    datasize = 1;
			  }
# endif
                        /* Throw away the ] at the end of the equivalence
                           class (or collating symbol).  */
                        PATFETCH (c);

			/* Allocate the space for the equivalence class
			   (or collating symbol) (and '\0' if needed).  */
                        GET_BUFFER_SPACE(datasize);
			/* Update the pointer to indicate end of buffer.  */
                        b += datasize;

			if (delim == '=')
			  { /* equivalence class  */
			    /* Calculate the offset of char_ranges,
			       which is next to equivalence_classes.  */
			    offset = laststart[1] + laststart[2]
			      + laststart[3] +6;
			    /* Insert space.  */
			    insert_space(datasize, laststart + offset, b - 1);

			    /* Write the equivalence_class and \0.  */
			    for (i = 0 ; i < datasize ; i++)
			      laststart[offset + i] = str[i];

			    /* Update the length of equivalence_classes.  */
			    laststart[3] += datasize;
			    had_char_class = true;
			  }
			else /* delim == '.' */
			  { /* collating symbol  */
			    /* Calculate the offset of the equivalence_classes,
			       which is next to collating_symbols.  */
			    offset = laststart[1] + laststart[2] + 6;
			    /* Insert space and write the collationg_symbol
			       and \0.  */
			    insert_space(datasize, laststart + offset, b-1);
			    for (i = 0 ; i < datasize ; i++)
			      laststart[offset + i] = str[i];

			    /* In re_match_2_internal if range_start < -1, we
			       assume -range_start is the offset of the
			       collating symbol which is specified as
			       the character of the range start.  So we assign
			       -(laststart[1] + laststart[2] + 6) to
			       range_start.  */
			    range_start = -(laststart[1] + laststart[2] + 6);
			    /* Update the length of collating_symbol.  */
			    laststart[2] += datasize;
			    had_char_class = false;
			  }
		      }
                    else
                      {
                        c1++;
                        while (c1--)
                          PATUNFETCH;
                        BUF_PUSH ('[');
                        BUF_PUSH (delim);
                        laststart[5] += 2; /* Update the length of characters  */
			range_start = delim;
                        had_char_class = false;
                      }
		  }
                else
                  {
                    had_char_class = false;
		    BUF_PUSH(c);
		    laststart[5]++;  /* Update the length of characters  */
		    range_start = c;
                  }
	      }
d2174 2
a2175 3
#else /* BYTE */
            /* Ensure that we have enough space to push a charset: the
               opcode, the length count, and the bitset; 34 bytes in all.  */
d2178 1
a2178 1
            laststart = b;
d2180 8
a2187 43
            /* We test `*p == '^' twice, instead of using an if
               statement, so we only need one BUF_PUSH.  */
            BUF_PUSH (*p == '^' ? charset_not : charset);
            if (*p == '^')
              p++;

            /* Remember the first position in the bracket expression.  */
            p1 = p;

            /* Push the number of bytes in the bitmap.  */
            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);

            /* Clear the whole map.  */
            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);

            /* charset_not matches newline according to a syntax bit.  */
            if ((re_opcode_t) b[-2] == charset_not
                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
              SET_LIST_BIT ('\n');

            /* Read in characters and ranges, setting map bits.  */
            for (;;)
              {
                if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                PATFETCH (c);

                /* \ might escape characters inside [...] and [^...].  */
                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
                  {
                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);

                    PATFETCH (c1);
                    SET_LIST_BIT (c1);
		    range_start = c1;
                    continue;
                  }

                /* Could be the end of the bracket expression.  If it's
                   not (i.e., when the bracket expression is `[]' so
                   far), the ']' character bit gets set way below.  */
                if (c == ']' && p != p1 + 1)
                  break;
d2189 2
a2190 69
                /* Look ahead to see if it's a range when the last thing
                   was a character class.  */
                if (had_char_class && c == '-' && *p != ']')
                  FREE_STACK_RETURN (REG_ERANGE);

                /* Look ahead to see if it's a range when the last thing
                   was a character: if this is a hyphen not at the
                   beginning or the end of a list, then it's the range
                   operator.  */
                if (c == '-'
                    && !(p - 2 >= pattern && p[-2] == '[')
                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
                    && *p != ']')
                  {
                    reg_errcode_t ret
                      = byte_compile_range (range_start, &p, pend, translate,
					    syntax, b);
                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
		    range_start = 0xffffffff;
                  }

                else if (p[0] == '-' && p[1] != ']')
                  { /* This handles ranges made up of characters only.  */
                    reg_errcode_t ret;

		    /* Move past the `-'.  */
                    PATFETCH (c1);

                    ret = byte_compile_range (c, &p, pend, translate, syntax, b);
                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
		    range_start = 0xffffffff;
                  }

                /* See if we're at the beginning of a possible character
                   class.  */

                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
                  { /* Leave room for the null.  */
                    char str[CHAR_CLASS_MAX_LENGTH + 1];

                    PATFETCH (c);
                    c1 = 0;

                    /* If pattern is `[[:'.  */
                    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                    for (;;)
                      {
                        PATFETCH (c);
                        if ((c == ':' && *p == ']') || p == pend)
                          break;
			if (c1 < CHAR_CLASS_MAX_LENGTH)
			  str[c1++] = c;
			else
			  /* This is in any case an invalid class name.  */
			  str[0] = '\0';
                      }
                    str[c1] = '\0';

                    /* If isn't a word bracketed by `[:' and `:]':
                       undo the ending character, the letters, and leave
                       the leading `:' and `[' (but set bits for them).  */
                    if (c == ':' && *p == ']')
                      {
# if defined _LIBC || WIDE_CHAR_SUPPORT
                        boolean is_lower = STREQ (str, "lower");
                        boolean is_upper = STREQ (str, "upper");
			wctype_t wt;
                        int ch;
d2192 2
a2193 3
			wt = IS_CHAR_CLASS (str);
			if (wt == 0)
			  FREE_STACK_RETURN (REG_ECTYPE);
d2195 4
a2198 3
                        /* Throw away the ] at the end of the character
                           class.  */
                        PATFETCH (c);
d2200 5
a2204 1
                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
d2206 1
a2206 4
                        for (ch = 0; ch < 1 << BYTEWIDTH; ++ch)
			  {
			    if (iswctype (btowc (ch), wt))
			      SET_LIST_BIT (ch);
d2208 1
a2208 4
			    if (translate && (is_upper || is_lower)
				&& (ISUPPER (ch) || ISLOWER (ch)))
			      SET_LIST_BIT (ch);
			  }
d2210 4
a2213 15
                        had_char_class = true;
# else
                        int ch;
                        boolean is_alnum = STREQ (str, "alnum");
                        boolean is_alpha = STREQ (str, "alpha");
                        boolean is_blank = STREQ (str, "blank");
                        boolean is_cntrl = STREQ (str, "cntrl");
                        boolean is_digit = STREQ (str, "digit");
                        boolean is_graph = STREQ (str, "graph");
                        boolean is_lower = STREQ (str, "lower");
                        boolean is_print = STREQ (str, "print");
                        boolean is_punct = STREQ (str, "punct");
                        boolean is_space = STREQ (str, "space");
                        boolean is_upper = STREQ (str, "upper");
                        boolean is_xdigit = STREQ (str, "xdigit");
d2215 11
a2225 2
                        if (!IS_CHAR_CLASS (str))
			  FREE_STACK_RETURN (REG_ECTYPE);
d2227 12
a2238 3
                        /* Throw away the ] at the end of the character
                           class.  */
                        PATFETCH (c);
d2240 2
a2241 1
                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
d2243 2
a2244 38
                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
                          {
			    /* This was split into 3 if's to
			       avoid an arbitrary limit in some compiler.  */
                            if (   (is_alnum  && ISALNUM (ch))
                                || (is_alpha  && ISALPHA (ch))
                                || (is_blank  && ISBLANK (ch))
                                || (is_cntrl  && ISCNTRL (ch)))
			      SET_LIST_BIT (ch);
			    if (   (is_digit  && ISDIGIT (ch))
                                || (is_graph  && ISGRAPH (ch))
                                || (is_lower  && ISLOWER (ch))
                                || (is_print  && ISPRINT (ch)))
			      SET_LIST_BIT (ch);
			    if (   (is_punct  && ISPUNCT (ch))
                                || (is_space  && ISSPACE (ch))
                                || (is_upper  && ISUPPER (ch))
                                || (is_xdigit && ISXDIGIT (ch)))
			      SET_LIST_BIT (ch);
			    if (   translate && (is_upper || is_lower)
				&& (ISUPPER (ch) || ISLOWER (ch)))
			      SET_LIST_BIT (ch);
                          }
                        had_char_class = true;
# endif	/* libc || wctype.h */
                      }
                    else
                      {
                        c1++;
                        while (c1--)
                          PATUNFETCH;
                        SET_LIST_BIT ('[');
                        SET_LIST_BIT (':');
			range_start = ':';
                        had_char_class = false;
                      }
                  }
                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == '=')
d2246 2
a2247 5
		    unsigned char str[MB_LEN_MAX + 1];
# ifdef _LIBC
		    uint32_t nrules =
		      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
# endif
d2252 1
a2252 1
		    /* If pattern is `[[='.  */
d2258 2
a2259 1
			if ((c == '=' && *p == ']') || p == pend)
d2261 2
a2262 6
			if (c1 < MB_LEN_MAX)
			  str[c1++] = c;
			else
			  /* This is in any case an invalid class name.  */
			  str[0] = '\0';
                      }
d2265 5
a2269 1
		    if (c == '=' && *p == ']' && str[0] != '\0')
d2271 20
a2290 12
			/* If we have no collation data we use the default
			   collation in which each character is in a class
			   by itself.  It also means that ASCII is the
			   character set and therefore we cannot have character
			   with more than one byte in the multibyte
			   representation.  */
# ifdef _LIBC
			if (nrules == 0)
# endif
			  {
			    if (c1 != 1)
			      FREE_STACK_RETURN (REG_ECOLLATE);
d2292 1
a2292 3
			    /* Throw away the ] at the end of the equivalence
			       class.  */
			    PATFETCH (c);
d2294 1
a2294 5
			    /* Set the bit for the character.  */
			    SET_LIST_BIT (str[0]);
			  }
# ifdef _LIBC
			else
d2296 18
a2313 67
			    /* Try to match the byte sequence in `str' against
			       those known to the collate implementation.
			       First find out whether the bytes in `str' are
			       actually from exactly one character.  */
			    const int32_t *table;
			    const unsigned char *weights;
			    const unsigned char *extra;
			    const int32_t *indirect;
			    int32_t idx;
			    const unsigned char *cp = str;
			    int ch;

			    /* This #include defines a local function!  */
#  include <locale/weight.h>

			    table = (const int32_t *)
			      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);
			    weights = (const unsigned char *)
			      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);
			    extra = (const unsigned char *)
			      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);
			    indirect = (const int32_t *)
			      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);

			    idx = findidx (&cp);
			    if (idx == 0 || cp < str + c1)
			      /* This is no valid character.  */
			      FREE_STACK_RETURN (REG_ECOLLATE);

			    /* Throw away the ] at the end of the equivalence
			       class.  */
			    PATFETCH (c);

			    /* Now we have to go throught the whole table
			       and find all characters which have the same
			       first level weight.

			       XXX Note that this is not entirely correct.
			       we would have to match multibyte sequences
			       but this is not possible with the current
			       implementation.  */
			    for (ch = 1; ch < 256; ++ch)
			      /* XXX This test would have to be changed if we
				 would allow matching multibyte sequences.  */
			      if (table[ch] > 0)
				{
				  int32_t idx2 = table[ch];
				  size_t len = weights[idx2];

				  /* Test whether the lenghts match.  */
				  if (weights[idx] == len)
				    {
				      /* They do.  New compare the bytes of
					 the weight.  */
				      size_t cnt = 0;

				      while (cnt < len
					     && (weights[idx + 1 + cnt]
						 == weights[idx2 + 1 + cnt]))
					++cnt;

				      if (cnt == len)
					/* They match.  Mark the character as
					   acceptable.  */
					SET_LIST_BIT (ch);
				    }
				}
d2315 15
a2329 2
# endif
			had_char_class = true;
a2330 10
                    else
                      {
                        c1++;
                        while (c1--)
                          PATUNFETCH;
                        SET_LIST_BIT ('[');
                        SET_LIST_BIT ('=');
			range_start = '=';
                        had_char_class = false;
                      }
d2332 2
a2333 1
                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == '.')
a2334 5
		    unsigned char str[128];	/* Should be large enough.  */
# ifdef _LIBC
		    uint32_t nrules =
		      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
# endif
d2336 2
a2337 2
		    PATFETCH (c);
		    c1 = 0;
d2339 8
a2346 2
		    /* If pattern is `[[.'.  */
		    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
d2348 2
a2349 1
		    for (;;)
d2351 21
a2371 10
			PATFETCH (c);
			if ((c == '.' && *p == ']') || p == pend)
			  break;
			if (c1 < sizeof (str))
			  str[c1++] = c;
			else
			  /* This is in any case an invalid class name.  */
			  str[0] = '\0';
                      }
		    str[c1] = '\0';
d2373 8
a2380 1
		    if (c == '.' && *p == ']' && str[0] != '\0')
d2382 3
a2384 102
			/* If we have no collation data we use the default
			   collation in which each character is the name
			   for its own class which contains only the one
			   character.  It also means that ASCII is the
			   character set and therefore we cannot have character
			   with more than one byte in the multibyte
			   representation.  */
# ifdef _LIBC
			if (nrules == 0)
# endif
			  {
			    if (c1 != 1)
			      FREE_STACK_RETURN (REG_ECOLLATE);

			    /* Throw away the ] at the end of the equivalence
			       class.  */
			    PATFETCH (c);

			    /* Set the bit for the character.  */
			    SET_LIST_BIT (str[0]);
			    range_start = ((const unsigned char *) str)[0];
			  }
# ifdef _LIBC
			else
			  {
			    /* Try to match the byte sequence in `str' against
			       those known to the collate implementation.
			       First find out whether the bytes in `str' are
			       actually from exactly one character.  */
			    int32_t table_size;
			    const int32_t *symb_table;
			    const unsigned char *extra;
			    int32_t idx;
			    int32_t elem;
			    int32_t second;
			    int32_t hash;

			    table_size =
			      _NL_CURRENT_WORD (LC_COLLATE,
						_NL_COLLATE_SYMB_HASH_SIZEMB);
			    symb_table = (const int32_t *)
			      _NL_CURRENT (LC_COLLATE,
					   _NL_COLLATE_SYMB_TABLEMB);
			    extra = (const unsigned char *)
			      _NL_CURRENT (LC_COLLATE,
					   _NL_COLLATE_SYMB_EXTRAMB);

			    /* Locate the character in the hashing table.  */
			    hash = elem_hash (str, c1);

			    idx = 0;
			    elem = hash % table_size;
			    second = hash % (table_size - 2);
			    while (symb_table[2 * elem] != 0)
			      {
				/* First compare the hashing value.  */
				if (symb_table[2 * elem] == hash
				    && c1 == extra[symb_table[2 * elem + 1]]
				    && memcmp (str,
					       &extra[symb_table[2 * elem + 1]
						     + 1],
					       c1) == 0)
				  {
				    /* Yep, this is the entry.  */
				    idx = symb_table[2 * elem + 1];
				    idx += 1 + extra[idx];
				    break;
				  }

				/* Next entry.  */
				elem += second;
			      }

			    if (symb_table[2 * elem] == 0)
			      /* This is no valid character.  */
			      FREE_STACK_RETURN (REG_ECOLLATE);

			    /* Throw away the ] at the end of the equivalence
			       class.  */
			    PATFETCH (c);

			    /* Now add the multibyte character(s) we found
			       to the accept list.

			       XXX Note that this is not entirely correct.
			       we would have to match multibyte sequences
			       but this is not possible with the current
			       implementation.  Also, we have to match
			       collating symbols, which expand to more than
			       one file, as a whole and not allow the
			       individual bytes.  */
			    c1 = extra[idx++];
			    if (c1 == 1)
			      range_start = extra[idx];
			    while (c1-- > 0)
			      {
				SET_LIST_BIT (extra[idx]);
				++idx;
			      }
			  }
# endif
			had_char_class = false;
a2385 10
                    else
                      {
                        c1++;
                        while (c1--)
                          PATUNFETCH;
                        SET_LIST_BIT ('[');
                        SET_LIST_BIT ('.');
			range_start = '.';
                        had_char_class = false;
                      }
d2387 4
a2390 16
                else
                  {
                    had_char_class = false;
                    SET_LIST_BIT (c);
		    range_start = c;
                  }
              }

            /* Discard any (non)matching list bytes that are all 0 at the
               end of the map.  Decrease the map-length byte too.  */
            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0)
              b[-1]--;
            b += b[-1];
#endif /* WCHAR */
          }
          break;
d2392 5
d2398 5
a2402 19
	case '(':
          if (syntax & RE_NO_BK_PARENS)
            goto handle_open;
          else
            goto normal_char;


        case ')':
          if (syntax & RE_NO_BK_PARENS)
            goto handle_close;
          else
            goto normal_char;


        case '\n':
          if (syntax & RE_NEWLINE_ALT)
            goto handle_alt;
          else
            goto normal_char;
d2404 14
a2418 5
	case '|':
          if (syntax & RE_NO_BK_VBAR)
            goto handle_alt;
          else
            goto normal_char;
d2420 5
a2425 5
        case '{':
           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
             goto handle_interval;
           else
             goto normal_char;
d2427 5
a2432 2
        case '\\':
          if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
d2434 5
a2438 4
          /* Do not translate the character after the \, so that we can
             distinguish, e.g., \B from \b, even if we normally would
             translate, e.g., B to b.  */
          PATFETCH_RAW (c);
a2439 9
          switch (c)
            {
            case '(':
              if (syntax & RE_NO_BK_PARENS)
                goto normal_backslash;

            handle_open:
              bufp->re_nsub++;
              regnum++;
d2441 5
a2445 5
              if (COMPILE_STACK_FULL)
                {
                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
                            compile_stack_elt_t);
                  if (compile_stack.stack == NULL) return REG_ESPACE;
a2446 2
                  compile_stack.size <<= 1;
                }
d2448 5
a2452 20
              /* These are the values to restore when we hit end of this
                 group.  They are all relative offsets, so that if the
                 whole pattern moves because of realloc, they will still
                 be valid.  */
              COMPILE_STACK_TOP.begalt_offset = begalt - COMPILED_BUFFER_VAR;
              COMPILE_STACK_TOP.fixup_alt_jump
                = fixup_alt_jump ? fixup_alt_jump - COMPILED_BUFFER_VAR + 1 : 0;
              COMPILE_STACK_TOP.laststart_offset = b - COMPILED_BUFFER_VAR;
              COMPILE_STACK_TOP.regnum = regnum;

              /* We will eventually replace the 0 with the number of
                 groups inner to this one.  But do not push a
                 start_memory for groups beyond the last one we can
                 represent in the compiled pattern.  */
              if (regnum <= MAX_REGNUM)
                {
                  COMPILE_STACK_TOP.inner_group_offset = b
		    - COMPILED_BUFFER_VAR + 2;
                  BUF_PUSH_3 (start_memory, regnum, 0);
                }
a2453 1
              compile_stack.avail++;
d2455 2
a2456 8
              fixup_alt_jump = 0;
              laststart = 0;
              begalt = b;
	      /* If we've reached MAX_REGNUM groups, then this open
		 won't actually generate any code, so we'll have to
		 clear pending_exact explicitly.  */
	      pending_exact = 0;
              break;
d2458 4
d2463 9
a2471 2
            case ')':
              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
d2473 1
a2473 1
              if (COMPILE_STACK_EMPTY)
d2475 25
a2499 4
		  if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
		    goto normal_backslash;
		  else
		    FREE_STACK_RETURN (REG_ERPAREN);
d2502 20
a2521 12
            handle_close:
              if (fixup_alt_jump)
                { /* Push a dummy failure point at the end of the
                     alternative for a possible future
                     `pop_failure_jump' to pop.  See comments at
                     `push_dummy_failure' in `re_match_2'.  */
                  BUF_PUSH (push_dummy_failure);

                  /* We allocated space for this jump when we assigned
                     to `fixup_alt_jump', in the `handle_alt' case below.  */
                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
                }
d2523 11
a2533 7
              /* See similar code for backslashed left paren above.  */
              if (COMPILE_STACK_EMPTY)
		{
		  if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
		    goto normal_char;
		  else
		    FREE_STACK_RETURN (REG_ERPAREN);
d2536 24
a2559 17
              /* Since we just checked for an empty stack above, this
                 ``can't happen''.  */
              assert (compile_stack.avail != 0);
              {
                /* We don't just want to restore into `regnum', because
                   later groups should continue to be numbered higher,
                   as in `(ab)c(de)' -- the second group is #2.  */
                regnum_t this_group_regnum;

                compile_stack.avail--;
                begalt = COMPILED_BUFFER_VAR + COMPILE_STACK_TOP.begalt_offset;
                fixup_alt_jump
                  = COMPILE_STACK_TOP.fixup_alt_jump
                    ? COMPILED_BUFFER_VAR + COMPILE_STACK_TOP.fixup_alt_jump - 1
                    : 0;
                laststart = COMPILED_BUFFER_VAR + COMPILE_STACK_TOP.laststart_offset;
                this_group_regnum = COMPILE_STACK_TOP.regnum;
d2565 72
a2636 119
                /* We're at the end of the group, so now we know how many
                   groups were inside this one.  */
                if (this_group_regnum <= MAX_REGNUM)
                  {
		    UCHAR_T *inner_group_loc
                      = COMPILED_BUFFER_VAR + COMPILE_STACK_TOP.inner_group_offset;

                    *inner_group_loc = regnum - this_group_regnum;
                    BUF_PUSH_3 (stop_memory, this_group_regnum,
                                regnum - this_group_regnum);
                  }
              }
              break;


            case '|':					/* `\|'.  */
              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
                goto normal_backslash;
            handle_alt:
              if (syntax & RE_LIMITED_OPS)
                goto normal_char;

              /* Insert before the previous alternative a jump which
                 jumps to this alternative if the former fails.  */
              GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);
              INSERT_JUMP (on_failure_jump, begalt,
			   b + 2 + 2 * OFFSET_ADDRESS_SIZE);
              pending_exact = 0;
              b += 1 + OFFSET_ADDRESS_SIZE;

              /* The alternative before this one has a jump after it
                 which gets executed if it gets matched.  Adjust that
                 jump so it will jump to this alternative's analogous
                 jump (put in below, which in turn will jump to the next
                 (if any) alternative's such jump, etc.).  The last such
                 jump jumps to the correct final destination.  A picture:
                          _____ _____
                          |   | |   |
                          |   v |   v
                         a | b   | c

                 If we are at `b', then fixup_alt_jump right now points to a
                 three-byte space after `a'.  We'll put in the jump, set
                 fixup_alt_jump to right after `b', and leave behind three
                 bytes which we'll fill in when we get to after `c'.  */

              if (fixup_alt_jump)
                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);

              /* Mark and leave space for a jump after this alternative,
                 to be filled in later either by next alternative or
                 when know we're at the end of a series of alternatives.  */
              fixup_alt_jump = b;
              GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);
              b += 1 + OFFSET_ADDRESS_SIZE;

              laststart = 0;
              begalt = b;
              break;


            case '{':
              /* If \{ is a literal.  */
              if (!(syntax & RE_INTERVALS)
                     /* If we're at `\{' and it's not the open-interval
                        operator.  */
		  || (syntax & RE_NO_BK_BRACES))
                goto normal_backslash;

            handle_interval:
              {
                /* If got here, then the syntax allows intervals.  */

                /* At least (most) this many matches must be made.  */
                int lower_bound = -1, upper_bound = -1;

		/* Place in the uncompiled pattern (i.e., just after
		   the '{') to go back to if the interval is invalid.  */
		const CHAR_T *beg_interval = p;

                if (p == pend)
		  goto invalid_interval;

                GET_UNSIGNED_NUMBER (lower_bound);

                if (c == ',')
                  {
                    GET_UNSIGNED_NUMBER (upper_bound);
		    if (upper_bound < 0)
		      upper_bound = RE_DUP_MAX;
                  }
                else
                  /* Interval such as `{1}' => match exactly once. */
                  upper_bound = lower_bound;

                if (! (0 <= lower_bound && lower_bound <= upper_bound))
		  goto invalid_interval;

                if (!(syntax & RE_NO_BK_BRACES))
                  {
		    if (c != '\\' || p == pend)
		      goto invalid_interval;
                    PATFETCH (c);
                  }

                if (c != '}')
		  goto invalid_interval;

                /* If it's invalid to have no preceding re.  */
                if (!laststart)
                  {
		    if (syntax & RE_CONTEXT_INVALID_OPS
			&& !(syntax & RE_INVALID_INTERVAL_ORD))
                      FREE_STACK_RETURN (REG_BADRPT);
                    else if (syntax & RE_CONTEXT_INDEP_OPS)
                      laststart = b;
                    else
                      goto unfetch_interval;
                  }
d2638 2
a2639 1
                /* We just parsed a valid interval.  */
d2641 1
a2641 2
                if (RE_DUP_MAX < upper_bound)
		  FREE_STACK_RETURN (REG_BADBR);
d2643 9
a2651 87
                /* If the upper bound is zero, don't want to succeed at
                   all; jump from `laststart' to `b + 3', which will be
		   the end of the buffer after we insert the jump.  */
		/* ifdef WCHAR, 'b + 1 + OFFSET_ADDRESS_SIZE'
		   instead of 'b + 3'.  */
                 if (upper_bound == 0)
                   {
                     GET_BUFFER_SPACE (1 + OFFSET_ADDRESS_SIZE);
                     INSERT_JUMP (jump, laststart, b + 1
				  + OFFSET_ADDRESS_SIZE);
                     b += 1 + OFFSET_ADDRESS_SIZE;
                   }

                 /* Otherwise, we have a nontrivial interval.  When
                    we're all done, the pattern will look like:
                      set_number_at <jump count> <upper bound>
                      set_number_at <succeed_n count> <lower bound>
                      succeed_n <after jump addr> <succeed_n count>
                      <body of loop>
                      jump_n <succeed_n addr> <jump count>
                    (The upper bound and `jump_n' are omitted if
                    `upper_bound' is 1, though.)  */
                 else
                   { /* If the upper bound is > 1, we need to insert
                        more at the end of the loop.  */
                     unsigned nbytes = 2 + 4 * OFFSET_ADDRESS_SIZE +
		       (upper_bound > 1) * (2 + 4 * OFFSET_ADDRESS_SIZE);

                     GET_BUFFER_SPACE (nbytes);

                     /* Initialize lower bound of the `succeed_n', even
                        though it will be set during matching by its
                        attendant `set_number_at' (inserted next),
                        because `re_compile_fastmap' needs to know.
                        Jump to the `jump_n' we might insert below.  */
                     INSERT_JUMP2 (succeed_n, laststart,
                                   b + 1 + 2 * OFFSET_ADDRESS_SIZE
				   + (upper_bound > 1) * (1 + 2 * OFFSET_ADDRESS_SIZE)
				   , lower_bound);
                     b += 1 + 2 * OFFSET_ADDRESS_SIZE;

                     /* Code to initialize the lower bound.  Insert
                        before the `succeed_n'.  The `5' is the last two
                        bytes of this `set_number_at', plus 3 bytes of
                        the following `succeed_n'.  */
		     /* ifdef WCHAR, The '1+2*OFFSET_ADDRESS_SIZE'
			is the 'set_number_at', plus '1+OFFSET_ADDRESS_SIZE'
			of the following `succeed_n'.  */
                     PREFIX(insert_op2) (set_number_at, laststart, 1
				 + 2 * OFFSET_ADDRESS_SIZE, lower_bound, b);
                     b += 1 + 2 * OFFSET_ADDRESS_SIZE;

                     if (upper_bound > 1)
                       { /* More than one repetition is allowed, so
                            append a backward jump to the `succeed_n'
                            that starts this interval.

                            When we've reached this during matching,
                            we'll have matched the interval once, so
                            jump back only `upper_bound - 1' times.  */
                         STORE_JUMP2 (jump_n, b, laststart
				      + 2 * OFFSET_ADDRESS_SIZE + 1,
                                      upper_bound - 1);
                         b += 1 + 2 * OFFSET_ADDRESS_SIZE;

                         /* The location we want to set is the second
                            parameter of the `jump_n'; that is `b-2' as
                            an absolute address.  `laststart' will be
                            the `set_number_at' we're about to insert;
                            `laststart+3' the number to set, the source
                            for the relative address.  But we are
                            inserting into the middle of the pattern --
                            so everything is getting moved up by 5.
                            Conclusion: (b - 2) - (laststart + 3) + 5,
                            i.e., b - laststart.

                            We insert this at the beginning of the loop
                            so that if we fail during matching, we'll
                            reinitialize the bounds.  */
                         PREFIX(insert_op2) (set_number_at, laststart,
					     b - laststart,
					     upper_bound - 1, b);
                         b += 1 + 2 * OFFSET_ADDRESS_SIZE;
                       }
                   }
                pending_exact = 0;
		break;
d2653 5
a2657 9
	      invalid_interval:
		if (!(syntax & RE_INVALID_INTERVAL_ORD))
		  FREE_STACK_RETURN (p == pend ? REG_EBRACE : REG_BADBR);
	      unfetch_interval:
		/* Match the characters as literals.  */
		p = beg_interval;
		c = '{';
		if (syntax & RE_NO_BK_BRACES)
		  goto normal_char;
d2659 116
a2774 1
		  goto normal_backslash;
d2776 17
d2795 29
a2823 17
            /* There is no way to specify the before_dot and after_dot
               operators.  rms says this is ok.  --karl  */
            case '=':
              BUF_PUSH (at_dot);
              break;

            case 's':
              laststart = b;
              PATFETCH (c);
              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
              break;

            case 'S':
              laststart = b;
              PATFETCH (c);
              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
              break;
d2827 23
a2849 6
            case 'w':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              laststart = b;
              BUF_PUSH (wordchar);
              break;
d2851 3
d2855 3
a2857 6
            case 'W':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              laststart = b;
              BUF_PUSH (notwordchar);
              break;
d2859 3
d2863 3
a2865 2
            case '<':
	      if (syntax & RE_NO_GNU_OPS)
a2866 2
              BUF_PUSH (wordbeg);
              break;
d2868 4
a2871 5
            case '>':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              BUF_PUSH (wordend);
              break;
d2873 2
a2874 2
            case 'b':
	      if (syntax & RE_NO_GNU_OPS)
a2875 2
              BUF_PUSH (wordbound);
              break;
d2877 3
a2879 5
            case 'B':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              BUF_PUSH (notwordbound);
              break;
a2880 5
            case '`':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              BUF_PUSH (begbuf);
              break;
d2882 6
a2887 5
            case '\'':
	      if (syntax & RE_NO_GNU_OPS)
		goto normal_char;
              BUF_PUSH (endbuf);
              break;
d2889 9
a2897 35
            case '1': case '2': case '3': case '4': case '5':
            case '6': case '7': case '8': case '9':
              if (syntax & RE_NO_BK_REFS)
                goto normal_char;

              c1 = c - '0';

              if (c1 > regnum)
                FREE_STACK_RETURN (REG_ESUBREG);

              /* Can't back reference to a subexpression if inside of it.  */
              if (group_in_compile_stack (compile_stack, (regnum_t) c1))
                goto normal_char;

              laststart = b;
              BUF_PUSH_2 (duplicate, c1);
              break;


            case '+':
            case '?':
              if (syntax & RE_BK_PLUS_QM)
                goto handle_plus;
              else
                goto normal_backslash;

            default:
            normal_backslash:
              /* You might think it would be useful for \ to mean
                 not to translate; but if we don't translate it
                 it will never match anything.  */
              c = TRANSLATE (c);
              goto normal_char;
            }
          break;
d2901 1
a2901 1
        /* Expects the character in `c'.  */
d2903 10
d2914 1
a2914 6
          if (!pending_exact
#ifdef WCHAR
	      /* If last exactn handle binary(or character) and
		 new exactn handle character(or binary).  */
	      || is_exactn_bin != is_binary[p - 1 - pattern]
#endif /* WCHAR */
d2916 2
a2917 2
              /* If last exactn not at current position.  */
              || pending_exact + *pending_exact + 1 != b
d2919 2
a2920 2
              /* We have only one byte following the exactn for the count.  */
	      || *pending_exact == (1 << BYTEWIDTH) - 1
d2922 2
a2923 2
              /* If followed by a repetition operator.  */
              || *p == '*' || *p == '^'
d2925 2
a2926 2
		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
		  : (*p == '+' || *p == '?'))
d2928 3
a2930 3
                  && ((syntax & RE_NO_BK_BRACES)
		      ? *p == '{'
                      : (p[0] == '\\' && p[1] == '{'))))
d2934 1
a2934 1
              laststart = b;
a2935 8
#ifdef WCHAR
	      /* Is this exactn binary data or character? */
	      is_exactn_bin = is_binary[p - 1 - pattern];
	      if (is_exactn_bin)
		  BUF_PUSH_2 (exactn_bin, 0);
	      else
		  BUF_PUSH_2 (exactn, 0);
#else
a2936 1
#endif /* WCHAR */
d2938 1
a2938 1
            }
d2940 18
a2957 2
	  BUF_PUSH (c);
          (*pending_exact)++;
d2959 1
a2959 1
        } /* switch (c) */
a2975 5
#ifdef WCHAR
  free (pattern);
  free (mbs_offset);
  free (is_binary);
#endif
a2978 3
#ifdef WCHAR
  bufp->used = (uintptr_t) b - (uintptr_t) COMPILED_BUFFER_VAR;
#else
a2979 1
#endif
d2985 1
a2985 1
      PREFIX(print_compiled_pattern) (bufp);
d2996 1
a2996 4
    /* Since DOUBLE_FAIL_STACK refuses to double only if the current size
       is strictly greater than re_max_failures, the largest possible stack
       is 2 * re_max_failures failure points.  */
    if (fail_stack.size < (2 * re_max_failures * MAX_FAILURE_ITEMS))
d2998 1
a2998 1
	fail_stack.size = (2 * re_max_failures * MAX_FAILURE_ITEMS);
d3000 1
a3000 1
# ifdef emacs
d3003 2
a3004 2
	    = (PREFIX(fail_stack_elt_t) *) xmalloc (fail_stack.size
				    * sizeof (PREFIX(fail_stack_elt_t)));
d3007 4
a3010 4
	    = (PREFIX(fail_stack_elt_t) *) xrealloc (fail_stack.stack,
				     (fail_stack.size
				      * sizeof (PREFIX(fail_stack_elt_t))));
# else /* not emacs */
d3013 2
a3014 1
	    = malloc (fail_stack.size * sizeof (PREFIX(fail_stack_elt_t)));
d3017 4
a3020 3
	    = realloc (fail_stack.stack,
		       fail_stack.size * sizeof (PREFIX(fail_stack_elt_t)));
# endif /* not emacs */
d3023 1
a3023 1
   PREFIX(regex_grow_registers) (num_regs);
d3029 1
a3029 1

d3032 1
a3032 2
/* Store OP at LOC followed by two-byte integer parameter ARG.  */
/* ifdef WCHAR, integer parameter is 1 wchar_t.  */
d3035 4
a3038 1
PREFIX(store_op1) (re_opcode_t op, UCHAR_T *loc, int arg)
d3040 1
a3040 1
  *loc = (UCHAR_T) op;
a3045 1
/* ifdef WCHAR, integer parameter is 1 wchar_t.  */
d3048 4
a3051 1
PREFIX(store_op2) (re_opcode_t op, UCHAR_T *loc, int arg1, int arg2)
d3053 1
a3053 1
  *loc = (UCHAR_T) op;
d3055 1
a3055 1
  STORE_NUMBER (loc + 1 + OFFSET_ADDRESS_SIZE, arg2);
a3060 1
/* ifdef WCHAR, integer parameter is 1 wchar_t.  */
d3063 5
a3067 1
PREFIX(insert_op1) (re_opcode_t op, UCHAR_T *loc, int arg, UCHAR_T *end)
d3069 2
a3070 2
  register UCHAR_T *pfrom = end;
  register UCHAR_T *pto = end + 1 + OFFSET_ADDRESS_SIZE;
d3075 1
a3075 1
  PREFIX(store_op1) (op, loc, arg);
a3079 1
/* ifdef WCHAR, integer parameter is 1 wchar_t.  */
d3082 5
a3086 2
PREFIX(insert_op2) (re_opcode_t op, UCHAR_T *loc, int arg1, int arg2,
		    UCHAR_T *end)
d3088 2
a3089 2
  register UCHAR_T *pfrom = end;
  register UCHAR_T *pto = end + 1 + 2 * OFFSET_ADDRESS_SIZE;
d3094 1
a3094 1
  PREFIX(store_op2) (op, loc, arg1, arg2);
d3103 3
a3105 2
PREFIX(at_begline_loc_p) (const CHAR_T *pattern, const CHAR_T *p,
			  reg_syntax_t syntax)
d3107 1
a3107 1
  const CHAR_T *prev = p - 2;
d3113 1
a3113 1
       /* After an alternative?  */
d3122 3
a3124 2
PREFIX(at_endline_loc_p) (const CHAR_T *p, const CHAR_T *pend,
			  reg_syntax_t syntax)
d3126 1
a3126 1
  const CHAR_T *next = p;
d3128 1
a3128 1
  const CHAR_T *next_next = p + 1 < pend ? p + 1 : 0;
d3133 1
a3133 1
        : next_backslash && next_next && *next_next == ')')
d3136 1
a3136 1
        : next_backslash && next_next && *next_next == '|');
a3138 1
#else /* not INSIDE_RECURSION */
d3144 3
a3146 2
group_in_compile_stack (compile_stack_type compile_stack,
			regnum_t regnum)
a3157 168
#endif /* not INSIDE_RECURSION */

#ifdef INSIDE_RECURSION

#ifdef WCHAR
/* This insert space, which size is "num", into the pattern at "loc".
   "end" must point the end of the allocated buffer.  */
static void
insert_space (int num, CHAR_T *loc, CHAR_T *end)
{
  register CHAR_T *pto = end;
  register CHAR_T *pfrom = end - num;

  while (pfrom >= loc)
    *pto-- = *pfrom--;
}
#endif /* WCHAR */

#ifdef WCHAR
static reg_errcode_t
wcs_compile_range (CHAR_T range_start_char,
		   const CHAR_T **p_ptr, const CHAR_T *pend,
		   RE_TRANSLATE_TYPE translate, reg_syntax_t syntax,
		   CHAR_T *b, CHAR_T *char_set)
{
  const CHAR_T *p = *p_ptr;
  CHAR_T range_start, range_end;
  reg_errcode_t ret;
# ifdef _LIBC
  uint32_t nrules;
  uint32_t start_val, end_val;
# endif
  if (p == pend)
    return REG_ERANGE;

# ifdef _LIBC
  nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
  if (nrules != 0)
    {
      const char *collseq = (const char *) _NL_CURRENT(LC_COLLATE,
						       _NL_COLLATE_COLLSEQWC);
      const unsigned char *extra = (const unsigned char *)
	_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);

      if (range_start_char < -1)
	{
	  /* range_start is a collating symbol.  */
	  int32_t *wextra;
	  /* Retreive the index and get collation sequence value.  */
	  wextra = (int32_t*)(extra + char_set[-range_start_char]);
	  start_val = wextra[1 + *wextra];
	}
      else
	start_val = collseq_table_lookup(collseq, TRANSLATE(range_start_char));

      end_val = collseq_table_lookup (collseq, TRANSLATE (p[0]));

      /* Report an error if the range is empty and the syntax prohibits
	 this.  */
      ret = ((syntax & RE_NO_EMPTY_RANGES)
	     && (start_val > end_val))? REG_ERANGE : REG_NOERROR;

      /* Insert space to the end of the char_ranges.  */
      insert_space(2, b - char_set[5] - 2, b - 1);
      *(b - char_set[5] - 2) = (wchar_t)start_val;
      *(b - char_set[5] - 1) = (wchar_t)end_val;
      char_set[4]++; /* ranges_index */
    }
  else
# endif
    {
      range_start = (range_start_char >= 0)? TRANSLATE (range_start_char):
	range_start_char;
      range_end = TRANSLATE (p[0]);
      /* Report an error if the range is empty and the syntax prohibits
	 this.  */
      ret = ((syntax & RE_NO_EMPTY_RANGES)
	     && (range_start > range_end))? REG_ERANGE : REG_NOERROR;

      /* Insert space to the end of the char_ranges.  */
      insert_space(2, b - char_set[5] - 2, b - 1);
      *(b - char_set[5] - 2) = range_start;
      *(b - char_set[5] - 1) = range_end;
      char_set[4]++; /* ranges_index */
    }
  /* Have to increment the pointer into the pattern string, so the
     caller isn't still at the ending character.  */
  (*p_ptr)++;

  return ret;
}
#else /* BYTE */
/* Read the ending character of a range (in a bracket expression) from the
   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
   Then we set the translation of all bits between the starting and
   ending characters (inclusive) in the compiled pattern B.

   Return an error code.

   We use these short variable names so we can use the same macros as
   `regex_compile' itself.  */

static reg_errcode_t
byte_compile_range (unsigned int range_start_char,
		    const char **p_ptr, const char *pend,
		    RE_TRANSLATE_TYPE translate, reg_syntax_t syntax,
		    unsigned char *b)
{
  unsigned this_char;
  const char *p = *p_ptr;
  reg_errcode_t ret;
# if _LIBC
  const unsigned char *collseq;
  unsigned int start_colseq;
  unsigned int end_colseq;
# else
  unsigned end_char;
# endif

  if (p == pend)
    return REG_ERANGE;

  /* Have to increment the pointer into the pattern string, so the
     caller isn't still at the ending character.  */
  (*p_ptr)++;

  /* Report an error if the range is empty and the syntax prohibits this.  */
  ret = syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;

# if _LIBC
  collseq = (const unsigned char *) _NL_CURRENT (LC_COLLATE,
						 _NL_COLLATE_COLLSEQMB);

  start_colseq = collseq[(unsigned char) TRANSLATE (range_start_char)];
  end_colseq = collseq[(unsigned char) TRANSLATE (p[0])];
  for (this_char = 0; this_char <= (unsigned char) -1; ++this_char)
    {
      unsigned int this_colseq = collseq[(unsigned char) TRANSLATE (this_char)];

      if (start_colseq <= this_colseq && this_colseq <= end_colseq)
	{
	  SET_LIST_BIT (TRANSLATE (this_char));
	  ret = REG_NOERROR;
	}
    }
# else
  /* Here we see why `this_char' has to be larger than an `unsigned
     char' -- we would otherwise go into an infinite loop, since all
     characters <= 0xff.  */
  range_start_char = TRANSLATE (range_start_char);
  /* TRANSLATE(p[0]) is casted to char (not unsigned char) in TRANSLATE,
     and some compilers cast it to int implicitly, so following for_loop
     may fall to (almost) infinite loop.
     e.g. If translate[p[0]] = 0xff, end_char may equals to 0xffffffff.
     To avoid this, we cast p[0] to unsigned int and truncate it.  */
  end_char = ((unsigned)TRANSLATE(p[0]) & ((1 << BYTEWIDTH) - 1));

  for (this_char = range_start_char; this_char <= end_char; ++this_char)
    {
      SET_LIST_BIT (TRANSLATE (this_char));
      ret = REG_NOERROR;
    }
# endif

  return ret;
}
#endif /* WCHAR */
d3172 3
a3174 18
#ifdef WCHAR
/* local function for re_compile_fastmap.
   truncate wchar_t character to char.  */

static unsigned char
truncate_wchar (CHAR_T c)
{
  unsigned char buf[MB_CUR_MAX];
  mbstate_t state;
  int retval;
  memset (&state, '\0', sizeof (state));
  retval = wcrtomb (buf, c, &state);
  return retval > 0 ? buf[0] : (unsigned char) c;
}
#endif /* WCHAR */

static int
PREFIX(re_compile_fastmap) (struct re_pattern_buffer *bufp)
d3176 1
a3176 1
  int j, k;
d3178 1
a3178 1
  PREFIX(fail_stack_type) fail_stack;
d3183 2
d3187 4
a3191 12
#ifdef WCHAR
  /* We need to cast pattern to (wchar_t*), because we casted this compiled
     pattern to (char*) in regex_compile.  */
  UCHAR_T *pattern = (UCHAR_T*)bufp->buffer;
  register UCHAR_T *pend = (UCHAR_T*) (bufp->buffer + bufp->used);
#else /* BYTE */
  UCHAR_T *pattern = bufp->buffer;
  register UCHAR_T *pend = pattern + bufp->used;
#endif /* WCHAR */
  UCHAR_T *p = pattern;

#ifdef REL_ALLOC
a3194 1
#endif
d3197 1
a3197 1
     proven otherwise.  We set this false at the bottom of switch
d3205 7
d3215 1
a3215 1
  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
d3239 1
a3239 1
      /* We should never be about to go beyond the end of the pattern.  */
d3245 5
a3249 5
        /* I guess the idea here is to simply not bother with a fastmap
           if a backreference is used, since it's too hard to figure out
           the fastmap for the corresponding group.  Setting
           `can_be_null' stops `re_search_2' from using the fastmap, so
           that is all we do.  */
d3252 1
a3252 1
          goto done;
d3256 1
a3256 1
         with `break'.  */
a3257 1
#ifdef WCHAR
a3258 9
          fastmap[truncate_wchar(p[1])] = 1;
	  break;
#else /* BYTE */
	case exactn:
          fastmap[p[1]] = 1;
	  break;
#endif /* WCHAR */
#ifdef MBS_SUPPORT
	case exactn_bin:
a3260 1
#endif
d3262 4
a3265 12
#ifdef WCHAR
        /* It is hard to distinguish fastmap from (multi byte) characters
           which depends on current locale.  */
        case charset:
	case charset_not:
	case wordchar:
	case notwordchar:
          bufp->can_be_null = 1;
          goto done;
#else /* BYTE */
        case charset:
          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
d3267 1
a3267 1
              fastmap[j] = 1;
d3274 1
a3274 1
            fastmap[j] = 1;
d3278 2
a3279 2
              fastmap[j] = 1;
          break;
d3294 60
a3353 1
#endif /* WCHAR */
d3355 32
a3386 1
        case anychar:
d3390 8
a3397 2
	    /* `.' matches anything ...  */
	    for (j = 0; j < (1 << BYTEWIDTH); j++)
d3405 1
a3405 1
	       then the fastmap is irrelevant.  Something's wrong here.  */
d3414 11
a3424 1
        case syntaxspec:
d3426 2
a3427 1
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
d3430 5
a3436 1

d3439 2
a3440 1
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
d3443 20
d3466 13
d3480 1
a3480 1
         `continue'.  */
d3486 1
a3486 1
          continue;
d3490 3
a3492 3
        case no_op:
        case begline:
        case endline:
d3495 1
d3500 3
a3502 2
        case push_dummy_failure:
          continue;
d3506 1
a3506 1
        case pop_failure_jump:
d3509 1
a3509 1
        case jump_past_alt:
d3511 1
a3511 1
          EXTRACT_NUMBER_AND_INCR (j, p);
d3516 6
a3521 6
          /* Jump backward implies we just went through the body of a
             loop and matched nothing.  Opcode jumped to should be
             `on_failure_jump' or `succeed_n'.  Just treat it like an
             ordinary jump.  For a * loop, it has pushed its failure
             point already; if so, discard that as redundant.  */
          if ((re_opcode_t) *p != on_failure_jump
d3525 3
a3527 3
          p++;
          EXTRACT_NUMBER_AND_INCR (j, p);
          p += j;
d3529 2
a3530 2
          /* If what's on the stack is where we are now, pop it.  */
          if (!FAIL_STACK_EMPTY ()
d3532 1
a3532 1
            fail_stack.avail--;
d3534 1
a3534 1
          continue;
d3537 2
a3538 2
        case on_failure_jump:
        case on_failure_keep_string_jump:
d3540 1
a3540 1
          EXTRACT_NUMBER_AND_INCR (j, p);
d3542 10
a3551 10
          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
             end of the pattern.  We don't want to push such a point,
             since when we restore it above, entering the switch will
             increment `p' past the end of the pattern.  We don't need
             to push such a point since we obviously won't find any more
             fastmap entries beyond `pend'.  Such a pattern can match
             the null string, though.  */
          if (p + j < pend)
            {
              if (!PUSH_PATTERN_OP (p + j, fail_stack))
d3556 3
a3558 3
            }
          else
            bufp->can_be_null = 1;
d3560 4
a3563 4
          if (succeed_n_p)
            {
              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
              succeed_n_p = false;
d3566 1
a3566 1
          continue;
d3570 2
a3571 2
          /* Get to the number of times to succeed.  */
          p += OFFSET_ADDRESS_SIZE;
d3573 3
a3575 3
          /* Increment p past the n for when k != 0.  */
          EXTRACT_NUMBER_AND_INCR (k, p);
          if (k == 0)
d3577 5
a3581 5
              p -= 2 * OFFSET_ADDRESS_SIZE;
  	      succeed_n_p = true;  /* Spaghetti code alert.  */
              goto handle_on_failure_jump;
            }
          continue;
d3585 2
a3586 2
          p += 2 * OFFSET_ADDRESS_SIZE;
          continue;
d3590 1
a3590 1
        case stop_memory:
d3596 2
a3597 2
          abort (); /* We have listed all the cases.  */
        } /* switch *p++ */
d3600 5
a3604 5
         characters for one path of the pattern -- and that the empty
         string does not match.  We need not follow this path further.
         Instead, look at the next alternative (remembered on the
         stack), or quit if no more.  The test at the top of the loop
         does these things.  */
d3610 1
a3610 1
     pattern is empty).  */
a3615 13
}

#else /* not INSIDE_RECURSION */

int
re_compile_fastmap (struct re_pattern_buffer *bufp)
{
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    return wcs_re_compile_fastmap(bufp);
  else
# endif
    return byte_re_compile_fastmap(bufp);
a3616 3
#ifdef _LIBC
weak_alias (__re_compile_fastmap, re_compile_fastmap)
#endif
a3617 1

d3632 5
a3636 4
re_set_registers (struct re_pattern_buffer *bufp,
		  struct re_registers *regs,
		  unsigned int num_regs,
		  regoff_t *starts, regoff_t *ends)
a3651 3
#ifdef _LIBC
weak_alias (__re_set_registers, re_set_registers)
#endif
d3653 1
a3653 1
/* Searching routines.  */
d3656 1
a3656 1
   doesn't let you say where to stop matching.  */
d3659 5
a3663 4
re_search (struct re_pattern_buffer *bufp,
	   const char *string,
	   int size, int startpos, int range,
	   struct re_registers *regs)
a3667 3
#ifdef _LIBC
weak_alias (__re_search, re_search)
#endif
d3669 7
d3699 8
a3706 67
re_search_2 (struct re_pattern_buffer *bufp,
	     const char *string1, int size1,
	     const char *string2, int size2,
	     int startpos, int range,
	     struct re_registers *regs,
	     int stop)
{
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    return wcs_re_search_2 (bufp, string1, size1, string2, size2, startpos,
			    range, regs, stop);
  else
# endif
    return byte_re_search_2 (bufp, string1, size1, string2, size2, startpos,
			     range, regs, stop);
} /* re_search_2 */
#ifdef _LIBC
weak_alias (__re_search_2, re_search_2)
#endif

#endif /* not INSIDE_RECURSION */

#ifdef INSIDE_RECURSION

#ifdef MATCH_MAY_ALLOCATE
# define FREE_VAR(var) if (var) REGEX_FREE (var); var = NULL
#else
# define FREE_VAR(var) if (var) free (var); var = NULL
#endif

#ifdef WCHAR
# define MAX_ALLOCA_SIZE	2000

# define FREE_WCS_BUFFERS() \
  do {									      \
    if (size1 > MAX_ALLOCA_SIZE)					      \
      {									      \
	free (wcs_string1);						      \
	free (mbs_offset1);						      \
      }									      \
    else								      \
      {									      \
	FREE_VAR (wcs_string1);						      \
	FREE_VAR (mbs_offset1);						      \
      }									      \
    if (size2 > MAX_ALLOCA_SIZE) 					      \
      {									      \
	free (wcs_string2);						      \
	free (mbs_offset2);						      \
      }									      \
    else								      \
      {									      \
	FREE_VAR (wcs_string2);						      \
	FREE_VAR (mbs_offset2);						      \
      }									      \
  } while (0)

#endif


static int
PREFIX(re_search_2) (struct re_pattern_buffer *bufp,
		     const char *string1, int size1,
		     const char *string2, int size2,
		     int startpos, int range,
		     struct re_registers *regs,
		     int stop)
d3713 4
a3716 10
#ifdef WCHAR
  /* We need wchar_t* buffers correspond to cstring1, cstring2.  */
  wchar_t *wcs_string1 = NULL, *wcs_string2 = NULL;
  /* We need the size of wchar_t buffers correspond to csize1, csize2.  */
  int wcs_size1 = 0, wcs_size2 = 0;
  /* offset buffer for optimizatoin. See convert_mbs_to_wc.  */
  int *mbs_offset1 = NULL, *mbs_offset2 = NULL;
  /* They hold whether each wchar_t is binary data or not.  */
  char *is_binary = NULL;
#endif /* WCHAR */
d3731 2
a3732 6
     search for a pattern that must be anchored.  */
  if (bufp->used > 0 && range > 0
      && ((re_opcode_t) bufp->buffer[0] == begbuf
	  /* `begline' is like `begbuf' if it cannot match at newlines.  */
	  || ((re_opcode_t) bufp->buffer[0] == begline
	      && !bufp->newline_anchor)))
d3737 1
a3737 1
	range = 1;
d3745 2
a3746 2
      range = PT - startpos;
      if (range <= 0)
d3756 9
a3764 73
#ifdef WCHAR
  /* Allocate wchar_t array for wcs_string1 and wcs_string2 and
     fill them with converted string.  */
  if (size1 != 0)
    {
      if (size1 > MAX_ALLOCA_SIZE)
	{
	  wcs_string1 = TALLOC (size1 + 1, CHAR_T);
	  mbs_offset1 = TALLOC (size1 + 1, int);
	  is_binary = TALLOC (size1 + 1, char);
	}
      else
	{
	  wcs_string1 = REGEX_TALLOC (size1 + 1, CHAR_T);
	  mbs_offset1 = REGEX_TALLOC (size1 + 1, int);
	  is_binary = REGEX_TALLOC (size1 + 1, char);
	}
      if (!wcs_string1 || !mbs_offset1 || !is_binary)
	{
	  if (size1 > MAX_ALLOCA_SIZE)
	    {
	      free (wcs_string1);
	      free (mbs_offset1);
	      free (is_binary);
	    }
	  else
	    {
	      FREE_VAR (wcs_string1);
	      FREE_VAR (mbs_offset1);
	      FREE_VAR (is_binary);
	    }
	  return -2;
	}
      wcs_size1 = convert_mbs_to_wcs(wcs_string1, string1, size1,
				     mbs_offset1, is_binary);
      wcs_string1[wcs_size1] = L'\0'; /* for a sentinel  */
      if (size1 > MAX_ALLOCA_SIZE)
	free (is_binary);
      else
	FREE_VAR (is_binary);
    }
  if (size2 != 0)
    {
      if (size2 > MAX_ALLOCA_SIZE)
	{
	  wcs_string2 = TALLOC (size2 + 1, CHAR_T);
	  mbs_offset2 = TALLOC (size2 + 1, int);
	  is_binary = TALLOC (size2 + 1, char);
	}
      else
	{
	  wcs_string2 = REGEX_TALLOC (size2 + 1, CHAR_T);
	  mbs_offset2 = REGEX_TALLOC (size2 + 1, int);
	  is_binary = REGEX_TALLOC (size2 + 1, char);
	}
      if (!wcs_string2 || !mbs_offset2 || !is_binary)
	{
	  FREE_WCS_BUFFERS ();
	  if (size2 > MAX_ALLOCA_SIZE)
	    free (is_binary);
	  else
	    FREE_VAR (is_binary);
	  return -2;
	}
      wcs_size2 = convert_mbs_to_wcs(wcs_string2, string2, size2,
				     mbs_offset2, is_binary);
      wcs_string2[wcs_size2] = L'\0'; /* for a sentinel  */
      if (size2 > MAX_ALLOCA_SIZE)
	free (is_binary);
      else
	FREE_VAR (is_binary);
    }
#endif /* WCHAR */
d3766 3
d3773 13
d3787 3
a3789 3
         cannot be the start of a match.  If the pattern can match the
         null string, however, we don't need to skip characters; we want
         the first null string.  */
d3792 6
a3797 1
	  if (range > 0)	/* Searching forwards.  */
a3798 1
	      register const char *d;
d3802 2
a3803 2
              if (startpos < size1 && startpos + range >= size1)
                lim = range - (size1 - startpos);
d3805 16
a3820 1
	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
d3822 12
a3833 7
              /* Written out as an if-else to avoid testing `translate'
                 inside the loop.  */
	      if (translate)
                while (range > lim
                       && !fastmap[(unsigned char)
				   translate[(unsigned char) *d++]])
                  range--;
d3835 5
a3839 2
                while (range > lim && !fastmap[(unsigned char) *d++])
                  range--;
d3843 1
a3843 1
	  else				/* Searching backwards.  */
d3845 7
a3851 3
	      register CHAR_T c = (size1 == 0 || startpos >= size1
				      ? string2[startpos - size1]
				      : string1[startpos]);
d3853 2
a3854 1
	      if (!fastmap[(unsigned char) TRANSLATE (c)])
d3861 2
a3862 18
          && !bufp->can_be_null)
       {
#ifdef WCHAR
         FREE_WCS_BUFFERS ();
#endif
         return -1;
       }

#ifdef WCHAR
      val = wcs_re_match_2_internal (bufp, string1, size1, string2,
				     size2, startpos, regs, stop,
				     wcs_string1, wcs_size1,
				     wcs_string2, wcs_size2,
				     mbs_offset1, mbs_offset2);
#else /* BYTE */
      val = byte_re_match_2_internal (bufp, string1, size1, string2,
				      size2, startpos, regs, stop);
#endif /* BYTE */
d3864 2
d3867 1
a3867 1
# ifdef C_ALLOCA
d3869 1
a3869 1
# endif
d3873 1
a3873 6
	{
#ifdef WCHAR
	  FREE_WCS_BUFFERS ();
#endif
	  return startpos;
	}
d3876 1
a3876 6
	{
#ifdef WCHAR
	  FREE_WCS_BUFFERS ();
#endif
	  return -2;
	}
d3880 1
a3880 1
        break;
d3882 21
a3902 4
        {
          range--;
          startpos++;
        }
d3904 30
a3933 4
        {
          range++;
          startpos--;
        }
a3934 3
#ifdef WCHAR
  FREE_WCS_BUFFERS ();
#endif
d3936 8
a3943 1
}
a3944 11
#ifdef WCHAR
/* This converts PTR, a pointer into one of the search wchar_t strings
   `string1' and `string2' into an multibyte string offset from the
   beginning of that string. We use mbs_offset to optimize.
   See convert_mbs_to_wcs.  */
# define POINTER_TO_OFFSET(ptr)						\
  (FIRST_STRING_P (ptr)							\
   ? ((regoff_t)(mbs_offset1 != NULL? mbs_offset1[(ptr)-string1] : 0))	\
   : ((regoff_t)((mbs_offset2 != NULL? mbs_offset2[(ptr)-string2] : 0)	\
		 + csize1)))
#else /* BYTE */
d3947 1
a3947 1
# define POINTER_TO_OFFSET(ptr)			\
a3950 1
#endif /* WCHAR */
d3959 1
a3959 1
  while (d == dend)						    	\
d3962 4
a3965 4
      if (dend == end_match_2) 						\
        goto fail;							\
      /* End of string1 => advance to string2.  */ 			\
      d = string2;						        \
d3969 1
d3971 1
a3971 1
   of `string1' and `string2'.  If only one string, it's `string2'.  */
d3980 1
a3980 9
#ifdef WCHAR
/* Use internationalized API instead of SYNTAX.  */
# define WORDCHAR_P(d)							\
  (iswalnum ((wint_t)((d) == end1 ? *string2				\
           : (d) == string2 - 1 ? *(end1 - 1) : *(d))) != 0		\
   || ((d) == end1 ? *string2						\
       : (d) == string2 - 1 ? *(end1 - 1) : *(d)) == L'_')
#else /* BYTE */
# define WORDCHAR_P(d)							\
d3982 1
a3982 1
           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
a3983 1
#endif /* WCHAR */
d3986 9
d4005 2
a4006 23
# ifdef WCHAR
#  define FREE_VARIABLES()						\
  do {									\
    REGEX_FREE_STACK (fail_stack.stack);				\
    FREE_VAR (regstart);						\
    FREE_VAR (regend);							\
    FREE_VAR (old_regstart);						\
    FREE_VAR (old_regend);						\
    FREE_VAR (best_regstart);						\
    FREE_VAR (best_regend);						\
    FREE_VAR (reg_info);						\
    FREE_VAR (reg_dummy);						\
    FREE_VAR (reg_info_dummy);						\
    if (!cant_free_wcs_buf)						\
      {									\
        FREE_VAR (string1);						\
        FREE_VAR (string2);						\
        FREE_VAR (mbs_offset1);						\
        FREE_VAR (mbs_offset2);						\
      }									\
  } while (0)
# else /* BYTE */
#  define FREE_VARIABLES()						\
a4018 1
# endif /* WCHAR */
d4020 1
a4020 14
# ifdef WCHAR
#  define FREE_VARIABLES()						\
  do {									\
    if (!cant_free_wcs_buf)						\
      {									\
        FREE_VAR (string1);						\
        FREE_VAR (string2);						\
        FREE_VAR (mbs_offset1);						\
        FREE_VAR (mbs_offset2);						\
      }									\
  } while (0)
# else /* BYTE */
#  define FREE_VARIABLES() ((void)0) /* Do nothing!  But inhibit gcc warning. */
# endif /* WCHAR */
d4023 1
a4023 1
/* These values must meet several constraints.  They must not be valid
d4026 1
a4026 1
   use numbers larger than 255.  They must differ by 1, because of
d4029 1
a4029 1
   to actually save any registers when none are active.  */
a4032 1
#else /* not INSIDE_RECURSION */
d4035 1
a4035 1
#ifndef emacs   /* Emacs never uses this.  */
d4039 10
a4048 17
re_match (struct re_pattern_buffer *bufp,
	  const char *string,
	  int size, int pos,
	  struct re_registers *regs)
{
  int result;
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    result = wcs_re_match_2_internal (bufp, NULL, 0, string, size,
				      pos, regs, size,
				      NULL, 0, NULL, 0, NULL, NULL);
  else
# endif
    result = byte_re_match_2_internal (bufp, NULL, 0, string, size,
				  pos, regs, size);
# ifndef REGEX_MALLOC
#  ifdef C_ALLOCA
d4050 2
a4051 2
#  endif
# endif
a4053 3
# ifdef _LIBC
weak_alias (__re_match, re_match)
# endif
d4056 5
a4060 15
#endif /* not INSIDE_RECURSION */

#ifdef INSIDE_RECURSION
static boolean PREFIX(group_match_null_string_p) (UCHAR_T **p,
						  UCHAR_T *end,
					PREFIX(register_info_type) *reg_info);
static boolean PREFIX(alt_match_null_string_p) (UCHAR_T *p,
						UCHAR_T *end,
					PREFIX(register_info_type) *reg_info);
static boolean PREFIX(common_op_match_null_string_p) (UCHAR_T **p,
						      UCHAR_T *end,
					PREFIX(register_info_type) *reg_info);
static int PREFIX(bcmp_translate) (const CHAR_T *s1, const CHAR_T *s2,
				   int len, char *translate);
#else /* not INSIDE_RECURSION */
d4068 1
a4068 1
   store offsets for the substring each group matched in REGS.  See the
d4072 1
a4072 1
   failure stack overflowing).  Otherwise, we return the length of the
d4076 7
a4082 5
re_match_2 (struct re_pattern_buffer *bufp,
	    const char *string1, int size1,
	    const char *string2, int size2,
	    int pos, struct re_registers *regs,
	    int stop)
a4084 9
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    result = wcs_re_match_2_internal (bufp, string1, size1, string2, size2,
				      pos, regs, stop,
				      NULL, 0, NULL, 0, NULL, NULL);
  else
# endif
    result = byte_re_match_2_internal (bufp, string1, size1, string2, size2,
				  pos, regs, stop);
d4086 12
a4097 2
#ifndef REGEX_MALLOC
# ifdef C_ALLOCA
d4099 2
a4100 2
# endif
#endif
a4102 52
#ifdef _LIBC
weak_alias (__re_match_2, re_match_2)
#endif

#endif /* not INSIDE_RECURSION */

#ifdef INSIDE_RECURSION

#ifdef WCHAR

/* This check the substring (from 0, to length) of the multibyte string,
   to which offset_buffer correspond. And count how many wchar_t_characters
   the substring occupy. We use offset_buffer to optimization.
   See convert_mbs_to_wcs.  */

static int
count_mbs_length (int *offset_buffer, int length)
{
  int upper, lower;

  /* Check whether the size is valid.  */
  if (length < 0)
    return -1;

  if (offset_buffer == NULL)
    return 0;

  /* If there are no multibyte character, offset_buffer[i] == i.
   Optmize for this case.  */
  if (offset_buffer[length] == length)
    return length;

  /* Set up upper with length. (because for all i, offset_buffer[i] >= i)  */
  upper = length;
  lower = 0;

  while (true)
    {
      int middle = (lower + upper) / 2;
      if (middle == lower || middle == upper)
	break;
      if (offset_buffer[middle] > length)
	upper = middle;
      else if (offset_buffer[middle] < length)
	lower = middle;
      else
	return middle;
    }

  return -1;
}
#endif /* WCHAR */
d4105 1
a4105 2
   afterwards.  */
#ifdef WCHAR
d4107 7
a4113 26
wcs_re_match_2_internal (struct re_pattern_buffer *bufp,
			 const char *cstring1, int csize1,
			 const char *cstring2, int csize2,
			 int pos,
			 struct re_registers *regs,
			 int stop,
			 /* string1 == string2 == NULL means
			    string1/2, size1/2 and mbs_offset1/2 need
			    setting up in this function.  */
			 /* We need wchar_t * buffers corresponding to
			    cstring1, cstring2.  */
			 wchar_t *string1, int size1,
			 wchar_t *string2, int size2,
			 /* Offset buffer for optimization.  See
			    convert_mbs_to_wc.  */
			 int *mbs_offset1,
			 int *mbs_offset2)
#else /* BYTE */
static int
byte_re_match_2_internal (struct re_pattern_buffer *bufp,
			  const char *string1, int size1,
			  const char *string2, int size2,
			  int pos,
			  struct re_registers *regs,
			  int stop)
#endif /* BYTE */
d4117 1
a4117 7
  UCHAR_T *p1;
#ifdef WCHAR
  /* They hold whether each wchar_t is binary data or not.  */
  char *is_binary = NULL;
  /* If true, we can't free string1/2, mbs_offset1/2.  */
  int cant_free_wcs_buf = 1;
#endif /* WCHAR */
d4120 1
a4120 1
  const CHAR_T *end1, *end2;
d4123 2
a4124 2
     each to consider matching.  */
  const CHAR_T *end_match_1, *end_match_2;
d4127 1
a4127 1
  const CHAR_T *d, *dend;
d4130 2
a4131 7
#ifdef WCHAR
  UCHAR_T *pattern, *p;
  register UCHAR_T *pend;
#else /* BYTE */
  UCHAR_T *p = bufp->buffer;
  register UCHAR_T *pend = p + bufp->used;
#endif /* WCHAR */
d4135 1
a4135 1
  UCHAR_T *just_past_start_mem = 0;
d4137 1
a4137 1
  /* We use this to map every character in the string.  */
d4140 3
d4151 3
a4153 3
     it gets discarded and the next next one is tried.  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
  PREFIX(fail_stack_type) fail_stack;
d4156 1
a4156 1
  static unsigned failure_id;
a4159 1
#ifdef REL_ALLOC
a4162 1
#endif
d4165 1
a4165 1
     return, for use in backreferences.  The number here includes
d4167 1
a4167 1
  size_t num_regs = bufp->re_nsub + 1;
d4170 2
a4171 2
  active_reg_t lowest_active_reg = NO_LOWEST_ACTIVE_REG;
  active_reg_t highest_active_reg = NO_HIGHEST_ACTIVE_REG;
d4181 1
a4181 1
  const CHAR_T **regstart, **regend;
d4190 1
a4190 1
  const CHAR_T **old_regstart, **old_regend;
d4198 3
a4200 3
     loop their register is in.  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
  PREFIX(register_info_type) *reg_info;
d4209 1
a4209 1
  const CHAR_T **best_regstart, **best_regend;
d4214 1
a4214 1
     else (see below).  Also, we never need info about register 0 for
d4220 1
a4220 1
  const CHAR_T *match_end = NULL;
d4227 2
a4228 2
  const CHAR_T **reg_dummy;
  PREFIX(register_info_type) *reg_info_dummy;
a4235 82
  /* Definitions for state transitions.  More efficiently for gcc.  */
#ifdef __GNUC__
# if defined HAVE_SUBTRACT_LOCAL_LABELS && defined SHARED
#  define NEXT \
      do								      \
	{								      \
	  int offset;							      \
	  const void *__unbounded ptr;					      \
	  offset = (p == pend						      \
		    ? 0 : jmptable[SWITCH_ENUM_CAST ((re_opcode_t) *p++)]);   \
	  ptr = &&end_of_pattern + offset;				      \
	  goto *ptr;							      \
	}								      \
      while (0)
#  define REF(x) \
  &&label_##x - &&end_of_pattern
#  define JUMP_TABLE_TYPE const int
# else
#  define NEXT \
      do								      \
	{								      \
	  const void *__unbounded ptr;					      \
	  ptr = (p == pend ? &&end_of_pattern				      \
		 : jmptable[SWITCH_ENUM_CAST ((re_opcode_t) *p++)]);	      \
	  goto *ptr;							      \
	}								      \
      while (0)
#  define REF(x) \
  &&label_##x
#  define JUMP_TABLE_TYPE const void *const
# endif
# define CASE(x) label_##x
  static JUMP_TABLE_TYPE jmptable[] =
    {
    REF (no_op),
    REF (succeed),
    REF (exactn),
# ifdef MBS_SUPPORT
    REF (exactn_bin),
# endif
    REF (anychar),
    REF (charset),
    REF (charset_not),
    REF (start_memory),
    REF (stop_memory),
    REF (duplicate),
    REF (begline),
    REF (endline),
    REF (begbuf),
    REF (endbuf),
    REF (jump),
    REF (jump_past_alt),
    REF (on_failure_jump),
    REF (on_failure_keep_string_jump),
    REF (pop_failure_jump),
    REF (maybe_pop_jump),
    REF (dummy_failure_jump),
    REF (push_dummy_failure),
    REF (succeed_n),
    REF (jump_n),
    REF (set_number_at),
    REF (wordchar),
    REF (notwordchar),
    REF (wordbeg),
    REF (wordend),
    REF (wordbound),
    REF (notwordbound)
# ifdef emacs
    ,REF (before_dot),
    REF (at_dot),
    REF (after_dot),
    REF (syntaxspec),
    REF (notsyntaxspec)
# endif
    };
#else
# define NEXT \
  break
# define CASE(x) \
  case x
#endif

d4248 9
a4256 9
      regstart = REGEX_TALLOC (num_regs, const CHAR_T *);
      regend = REGEX_TALLOC (num_regs, const CHAR_T *);
      old_regstart = REGEX_TALLOC (num_regs, const CHAR_T *);
      old_regend = REGEX_TALLOC (num_regs, const CHAR_T *);
      best_regstart = REGEX_TALLOC (num_regs, const CHAR_T *);
      best_regend = REGEX_TALLOC (num_regs, const CHAR_T *);
      reg_info = REGEX_TALLOC (num_regs, PREFIX(register_info_type));
      reg_dummy = REGEX_TALLOC (num_regs, const CHAR_T *);
      reg_info_dummy = REGEX_TALLOC (num_regs, PREFIX(register_info_type));
d4259 5
a4263 5
            && best_regstart && best_regend && reg_dummy && reg_info_dummy))
        {
          FREE_VARIABLES ();
          return -2;
        }
d4268 1
a4268 1
         `FREE_VARIABLES' doesn't try to free them.  */
d4270 2
a4271 2
        = best_regend = reg_dummy = NULL;
      reg_info = reg_info_dummy = (PREFIX(register_info_type) *) NULL;
a4275 3
#ifdef WCHAR
  if (pos < 0 || pos > csize1 + csize2)
#else /* BYTE */
a4276 1
#endif
a4281 51
#ifdef WCHAR
  /* Allocate wchar_t array for string1 and string2 and
     fill them with converted string.  */
  if (string1 == NULL && string2 == NULL)
    {
      /* We need seting up buffers here.  */

      /* We must free wcs buffers in this function.  */
      cant_free_wcs_buf = 0;

      if (csize1 != 0)
	{
	  string1 = REGEX_TALLOC (csize1 + 1, CHAR_T);
	  mbs_offset1 = REGEX_TALLOC (csize1 + 1, int);
	  is_binary = REGEX_TALLOC (csize1 + 1, char);
	  if (!string1 || !mbs_offset1 || !is_binary)
	    {
	      FREE_VAR (string1);
	      FREE_VAR (mbs_offset1);
	      FREE_VAR (is_binary);
	      return -2;
	    }
	}
      if (csize2 != 0)
	{
	  string2 = REGEX_TALLOC (csize2 + 1, CHAR_T);
	  mbs_offset2 = REGEX_TALLOC (csize2 + 1, int);
	  is_binary = REGEX_TALLOC (csize2 + 1, char);
	  if (!string2 || !mbs_offset2 || !is_binary)
	    {
	      FREE_VAR (string1);
	      FREE_VAR (mbs_offset1);
	      FREE_VAR (string2);
	      FREE_VAR (mbs_offset2);
	      FREE_VAR (is_binary);
	      return -2;
	    }
	  size2 = convert_mbs_to_wcs(string2, cstring2, csize2,
				     mbs_offset2, is_binary);
	  string2[size2] = L'\0'; /* for a sentinel  */
	  FREE_VAR (is_binary);
	}
    }

  /* We need to cast pattern to (wchar_t*), because we casted this compiled
     pattern to (char*) in regex_compile.  */
  p = pattern = (CHAR_T*)bufp->buffer;
  pend = (CHAR_T*)(bufp->buffer + bufp->used);

#endif /* WCHAR */

d4285 1
a4285 1
  for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
d4288 1
a4288 1
        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
d4297 1
a4297 1
     `string1' is null.  */
a4303 30
#ifdef WCHAR
      mbs_offset2 = mbs_offset1;
      csize2 = csize1;
      mbs_offset1 = NULL;
      csize1 = 0;
#endif
    }
  end1 = string1 + size1;
  end2 = string2 + size2;

  /* Compute where to stop matching, within the two strings.  */
#ifdef WCHAR
  if (stop <= csize1)
    {
      mcnt = count_mbs_length(mbs_offset1, stop);
      end_match_1 = string1 + mcnt;
      end_match_2 = string2;
    }
  else
    {
      if (stop > csize1 + csize2)
	stop = csize1 + csize2;
      end_match_1 = end1;
      mcnt = count_mbs_length(mbs_offset2, stop-csize1);
      end_match_2 = string2 + mcnt;
    }
  if (mcnt < 0)
    { /* count_mbs_length return error.  */
      FREE_VARIABLES ();
      return -1;
d4305 4
a4308 1
#else
a4318 1
#endif /* WCHAR */
a4325 20
#ifdef WCHAR
  if (size1 > 0 && pos <= csize1)
    {
      mcnt = count_mbs_length(mbs_offset1, pos);
      d = string1 + mcnt;
      dend = end_match_1;
    }
  else
    {
      mcnt = count_mbs_length(mbs_offset2, pos-csize1);
      d = string2 + mcnt;
      dend = end_match_2;
    }

  if (mcnt < 0)
    { /* count_mbs_length return error.  */
      FREE_VARIABLES ();
      return -1;
    }
#else
a4335 1
#endif /* WCHAR */
d4337 1
a4337 1
  DEBUG_PRINT1 ("The compiled pattern is:\n");
d4343 1
a4343 1
  /* This loops over pattern commands.  It exits by returning from the
a4347 3
#ifdef _LIBC
      DEBUG_PRINT2 ("\n%p: ", p);
#else
a4348 1
#endif
a4349 3
#ifdef __GNUC__
      NEXT;
#else
d4351 1
a4351 6
#endif
	{
#ifdef __GNUC__
	end_of_pattern:
#endif
	  /* End of pattern means we might have succeeded.  */
d4366 1
a4366 1
		 with the previous declaration.  */
d4385 1
a4385 1
		      for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
d4404 1
a4404 1
		     not consecutive in memory.  */
d4409 1
a4409 1
			  ? end_match_1 : end_match_2);
d4411 1
a4411 1
		  for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
d4421 1
d4425 1
a4425 1
	      /* Have the register data arrays been allocated?  */
d4427 1
a4427 1
		{ /* No.  So allocate them with malloc.  We need one
d4459 1
a4459 1
		     warning under GCC when assert expands to nothing.  */
a4468 8
#ifdef WCHAR
		  if (MATCHING_IN_FIRST_STRING)
		    regs->end[0] = (mbs_offset1 != NULL ?
				    mbs_offset1[d-string1] : 0);
		  else
		    regs->end[0] = csize1 + (mbs_offset2 != NULL
					     ? mbs_offset2[d-string2] : 0);
#else
a4471 1
#endif /* WCHAR */
d4476 1
a4476 2
	      for (mcnt = 1; (unsigned) mcnt < MIN (num_regs, regs->num_regs);
		   mcnt++)
d4493 2
a4494 2
		 -1 at the end.  */
	      for (mcnt = num_regs; (unsigned) mcnt < regs->num_regs; mcnt++)
a4502 8
#ifdef WCHAR
	  if (MATCHING_IN_FIRST_STRING)
	    mcnt = mbs_offset1 != NULL ? mbs_offset1[d-string1] : 0;
	  else
	    mcnt = (mbs_offset2 != NULL ? mbs_offset2[d-string2] : 0) +
	      csize1;
	  mcnt -= pos;
#else
d4504 2
a4505 2
			    ? string1 : string2 - size1);
#endif /* WCHAR */
d4513 1
a4513 2
#ifndef __GNUC__
      /* Otherwise match next pattern command.  */
d4516 5
a4520 6
#endif
        /* Ignore these.  Used to ignore the n of succeed_n's which
           currently have n == 0.  */
        CASE (no_op):
          DEBUG_PRINT1 ("EXECUTING no_op.\n");
          NEXT;
d4522 2
a4523 2
	CASE (succeed):
          DEBUG_PRINT1 ("EXECUTING succeed.\n");
d4526 4
a4529 7
        /* Match the next n pattern characters exactly.  The following
           byte in the pattern defines n, and the n bytes after that
           are the characters to match.  */
	CASE (exactn):
#ifdef MBS_SUPPORT
	CASE (exactn_bin):
#endif
d4531 1
a4531 1
          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
d4533 3
a4535 3
          /* This is written out as an if-else so we don't waste time
             testing `translate' inside the loop.  */
          if (translate)
d4537 31
a4567 22
	      do
		{
		  PREFETCH ();
#ifdef WCHAR
		  if (*d <= 0xff)
		    {
		      if ((UCHAR_T) translate[(unsigned char) *d++]
			  != (UCHAR_T) *p++)
			goto fail;
		    }
		  else
		    {
		      if (*d++ != (CHAR_T) *p++)
			goto fail;
		    }
#else
		  if ((UCHAR_T) translate[(unsigned char) *d++]
		      != (UCHAR_T) *p++)
                    goto fail;
#endif /* WCHAR */
		}
	      while (--mcnt);
d4574 1
a4574 1
		  if (*d++ != (CHAR_T) *p++) goto fail;
d4579 1
a4579 1
          NEXT;
d4582 5
a4586 14
        /* Match any character except possibly a newline or a null.  */
	CASE (anychar):
          DEBUG_PRINT1 ("EXECUTING anychar.\n");

          PREFETCH ();

          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
	    goto fail;

          SET_REGS_MATCHED ();
          DEBUG_PRINT2 ("  Matched `%ld'.\n", (long int) *d);
          d++;
	  NEXT;
d4588 1
a4589 17
	CASE (charset):
	CASE (charset_not):
	  {
	    register UCHAR_T c;
#ifdef WCHAR
	    unsigned int i, char_class_length, coll_symbol_length,
              equiv_class_length, ranges_length, chars_length, length;
	    CHAR_T *workp, *workp2, *charset_top;
#define WORK_BUFFER_SIZE 128
            CHAR_T str_buf[WORK_BUFFER_SIZE];
# ifdef _LIBC
	    uint32_t nrules;
# endif /* _LIBC */
#endif /* WCHAR */
	    boolean not = (re_opcode_t) *(p - 1) == charset_not;

            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
a4590 20
	    c = TRANSLATE (*d); /* The character to match.  */
#ifdef WCHAR
# ifdef _LIBC
	    nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
# endif /* _LIBC */
	    charset_top = p - 1;
	    char_class_length = *p++;
	    coll_symbol_length = *p++;
	    equiv_class_length = *p++;
	    ranges_length = *p++;
	    chars_length = *p++;
	    /* p points charset[6], so the address of the next instruction
	       (charset[l+m+n+2o+k+p']) equals p[l+m+n+2*o+p'],
	       where l=length of char_classes, m=length of collating_symbol,
	       n=equivalence_class, o=length of char_range,
	       p'=length of character.  */
	    workp = p;
	    /* Update p to indicate the next instruction.  */
	    p += char_class_length + coll_symbol_length+ equiv_class_length +
              2*ranges_length + chars_length;
d4592 5
a4596 2
            /* match with char_class?  */
	    for (i = 0; i < char_class_length ; i += CHAR_CLASS_SIZE)
d4598 2
a4599 8
		wctype_t wctype;
		uintptr_t alignedp = ((uintptr_t)workp
				      + __alignof__(wctype_t) - 1)
		  		      & ~(uintptr_t)(__alignof__(wctype_t) - 1);
		wctype = *((wctype_t*)alignedp);
		workp += CHAR_CLASS_SIZE;
		if (iswctype((wint_t)c, wctype))
		  goto char_set_matched;
d4602 1
a4602 6
            /* match with collating_symbol?  */
# ifdef _LIBC
	    if (nrules != 0)
	      {
		const unsigned char *extra = (const unsigned char *)
		  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);
d4604 5
a4608 8
		for (workp2 = workp + coll_symbol_length ; workp < workp2 ;
		     workp++)
		  {
		    int32_t *wextra;
		    wextra = (int32_t*)(extra + *workp++);
		    for (i = 0; i < *wextra; ++i)
		      if (TRANSLATE(d[i]) != wextra[1 + i])
			break;
d4610 5
a4614 18
		    if (i == *wextra)
		      {
			/* Update d, however d will be incremented at
			   char_set_matched:, we decrement d here.  */
			d += i - 1;
			goto char_set_matched;
		      }
		  }
	      }
	    else /* (nrules == 0) */
# endif
	      /* If we can't look up collation data, we use wcscoll
		 instead.  */
	      {
		for (workp2 = workp + coll_symbol_length ; workp < workp2 ;)
		  {
		    const CHAR_T *backup_d = d, *backup_dend = dend;
		    length = wcslen (workp);
a4615 8
		    /* If wcscoll(the collating symbol, whole string) > 0,
		       any substring of the string never match with the
		       collating symbol.  */
		    if (wcscoll (workp, d) > 0)
		      {
			workp += length + 1;
			continue;
		      }
d4617 6
a4622 84
		    /* First, we compare the collating symbol with
		       the first character of the string.
		       If it don't match, we add the next character to
		       the compare buffer in turn.  */
		    for (i = 0 ; i < WORK_BUFFER_SIZE-1 ; i++, d++)
		      {
			int match;
			if (d == dend)
			  {
			    if (dend == end_match_2)
			      break;
			    d = string2;
			    dend = end_match_2;
			  }

			/* add next character to the compare buffer.  */
			str_buf[i] = TRANSLATE(*d);
			str_buf[i+1] = '\0';

			match = wcscoll (workp, str_buf);
			if (match == 0)
			  goto char_set_matched;

			if (match < 0)
			  /* (str_buf > workp) indicate (str_buf + X > workp),
			     because for all X (str_buf + X > str_buf).
			     So we don't need continue this loop.  */
			  break;

			/* Otherwise(str_buf < workp),
			   (str_buf+next_character) may equals (workp).
			   So we continue this loop.  */
		      }
		    /* not matched */
		    d = backup_d;
		    dend = backup_dend;
		    workp += length + 1;
		  }
              }
            /* match with equivalence_class?  */
# ifdef _LIBC
	    if (nrules != 0)
	      {
                const CHAR_T *backup_d = d, *backup_dend = dend;
		/* Try to match the equivalence class against
		   those known to the collate implementation.  */
		const int32_t *table;
		const int32_t *weights;
		const int32_t *extra;
		const int32_t *indirect;
		int32_t idx, idx2;
		wint_t *cp;
		size_t len;

		/* This #include defines a local function!  */
#  include <locale/weightwc.h>

		table = (const int32_t *)
		  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEWC);
		weights = (const wint_t *)
		  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTWC);
		extra = (const wint_t *)
		  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAWC);
		indirect = (const int32_t *)
		  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTWC);

		/* Write 1 collating element to str_buf, and
		   get its index.  */
		idx2 = 0;

		for (i = 0 ; idx2 == 0 && i < WORK_BUFFER_SIZE - 1; i++)
		  {
		    cp = (wint_t*)str_buf;
		    if (d == dend)
		      {
			if (dend == end_match_2)
			  break;
			d = string2;
			dend = end_match_2;
		      }
		    str_buf[i] = TRANSLATE(*(d+i));
		    str_buf[i+1] = '\0'; /* sentinel */
		    idx2 = findidx ((const wint_t**)&cp);
		  }
d4624 3
a4626 13
		/* Update d, however d will be incremented at
		   char_set_matched:, we decrement d here.  */
		d = backup_d + ((wchar_t*)cp - (wchar_t*)str_buf - 1);
		if (d >= dend)
		  {
		    if (dend == end_match_2)
			d = dend;
		    else
		      {
			d = string2;
			dend = end_match_2;
		      }
		  }
d4628 2
a4629 1
		len = weights[idx2];
d4631 2
a4632 5
		for (workp2 = workp + equiv_class_length ; workp < workp2 ;
		     workp++)
		  {
		    idx = (int32_t)*workp;
		    /* We already checked idx != 0 in regex_compile. */
d4634 1
a4634 6
		    if (idx2 != 0 && len == weights[idx])
		      {
			int cnt = 0;
			while (cnt < len && (weights[idx + 1 + cnt]
					     == weights[idx2 + 1 + cnt]))
			  ++cnt;
d4636 2
a4637 81
			if (cnt == len)
			  goto char_set_matched;
		      }
		  }
		/* not matched */
                d = backup_d;
                dend = backup_dend;
	      }
	    else /* (nrules == 0) */
# endif
	      /* If we can't look up collation data, we use wcscoll
		 instead.  */
	      {
		for (workp2 = workp + equiv_class_length ; workp < workp2 ;)
		  {
		    const CHAR_T *backup_d = d, *backup_dend = dend;
		    length = wcslen (workp);

		    /* If wcscoll(the collating symbol, whole string) > 0,
		       any substring of the string never match with the
		       collating symbol.  */
		    if (wcscoll (workp, d) > 0)
		      {
			workp += length + 1;
			break;
		      }

		    /* First, we compare the equivalence class with
		       the first character of the string.
		       If it don't match, we add the next character to
		       the compare buffer in turn.  */
		    for (i = 0 ; i < WORK_BUFFER_SIZE - 1 ; i++, d++)
		      {
			int match;
			if (d == dend)
			  {
			    if (dend == end_match_2)
			      break;
			    d = string2;
			    dend = end_match_2;
			  }

			/* add next character to the compare buffer.  */
			str_buf[i] = TRANSLATE(*d);
			str_buf[i+1] = '\0';

			match = wcscoll (workp, str_buf);

			if (match == 0)
			  goto char_set_matched;

			if (match < 0)
			/* (str_buf > workp) indicate (str_buf + X > workp),
			   because for all X (str_buf + X > str_buf).
			   So we don't need continue this loop.  */
			  break;

			/* Otherwise(str_buf < workp),
			   (str_buf+next_character) may equals (workp).
			   So we continue this loop.  */
		      }
		    /* not matched */
		    d = backup_d;
		    dend = backup_dend;
		    workp += length + 1;
		  }
	      }

            /* match with char_range?  */
# ifdef _LIBC
	    if (nrules != 0)
	      {
		uint32_t collseqval;
		const char *collseq = (const char *)
		  _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQWC);

		collseqval = collseq_table_lookup (collseq, c);

		for (; workp < p - chars_length ;)
		  {
		    uint32_t start_val, end_val;
d4639 4
a4642 9
		    /* We already compute the collation sequence value
		       of the characters (or collating symbols).  */
		    start_val = (uint32_t) *workp++; /* range_start */
		    end_val = (uint32_t) *workp++; /* range_end */

		    if (start_val <= collseqval && collseqval <= end_val)
		      goto char_set_matched;
		  }
	      }
d4644 1
a4644 41
# endif
	      {
		/* We set range_start_char at str_buf[0], range_end_char
		   at str_buf[4], and compared char at str_buf[2].  */
		str_buf[1] = 0;
		str_buf[2] = c;
		str_buf[3] = 0;
		str_buf[5] = 0;
		for (; workp < p - chars_length ;)
		  {
		    wchar_t *range_start_char, *range_end_char;

		    /* match if (range_start_char <= c <= range_end_char).  */

		    /* If range_start(or end) < 0, we assume -range_start(end)
		       is the offset of the collating symbol which is specified
		       as the character of the range start(end).  */

		    /* range_start */
		    if (*workp < 0)
		      range_start_char = charset_top - (*workp++);
		    else
		      {
			str_buf[0] = *workp++;
			range_start_char = str_buf;
		      }

		    /* range_end */
		    if (*workp < 0)
		      range_end_char = charset_top - (*workp++);
		    else
		      {
			str_buf[4] = *workp++;
			range_end_char = str_buf + 4;
		      }

		    if (wcscoll (range_start_char, str_buf+2) <= 0
			&& wcscoll (str_buf+2, range_end_char) <= 0)
		      goto char_set_matched;
		  }
	      }
d4646 2
a4647 4
            /* match with char?  */
	    for (; workp < p ; workp++)
	      if (c == *workp)
		goto char_set_matched;
d4649 8
a4656 8
	    not = !not;

	  char_set_matched:
	    if (not) goto fail;
#else
            /* Cast to `unsigned' instead of `unsigned char' in case the
               bit list is a full 32 bytes long.  */
	    if (c < (unsigned) (*p * BYTEWIDTH)
d4659 3
d4663 1
a4663 1
	    p += 1 + *p;
d4666 1
a4666 2
#undef WORK_BUFFER_SIZE
#endif /* WCHAR */
d4668 2
a4669 2
            d++;
	    NEXT;
d4673 7
a4679 8
        /* The beginning of a group is represented by start_memory.
           The arguments are the register number in the next byte, and the
           number of groups inner to this one in the next.  The text
           matched within the group is recorded (in the internal
           registers data structure) under the register number.  */
        CASE (start_memory):
	  DEBUG_PRINT3 ("EXECUTING start_memory %ld (%ld):\n",
			(long int) *p, (long int) p[1]);
d4681 1
a4681 1
          /* Find out if this group can match the empty string.  */
d4684 12
a4695 12
          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
            REG_MATCH_NULL_STRING_P (reg_info[*p])
              = PREFIX(group_match_null_string_p) (&p1, pend, reg_info);

          /* Save the position in the string where we were the last time
             we were at this open-group operator in case the group is
             operated upon by a repetition operator, e.g., with `(a*)*b'
             against `ab'; then we want to ignore where we are now in
             the string in case this attempt to match fails.  */
          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
                             : regstart[*p];
d4699 1
a4699 1
          regstart[*p] = d;
d4702 2
a4703 2
          IS_ACTIVE (reg_info[*p]) = 1;
          MATCHED_SOMETHING (reg_info[*p]) = 0;
d4708 2
a4709 2
          /* This is the new highest active register.  */
          highest_active_reg = *p;
d4711 4
a4714 4
          /* If nothing was active before, this is the new lowest active
             register.  */
          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
            lowest_active_reg = *p;
d4716 2
a4717 2
          /* Move past the register number and inner group count.  */
          p += 2;
d4720 2
a4721 1
          NEXT;
d4723 5
d4729 7
a4735 14
        /* The stop_memory opcode represents the end of a group.  Its
           arguments are the same as start_memory's: the register
           number, and the number of inner groups.  */
	CASE (stop_memory):
	  DEBUG_PRINT3 ("EXECUTING stop_memory %ld (%ld):\n",
			(long int) *p, (long int) p[1]);

          /* We need to save the string position the last time we were at
             this close-group operator in case the group is operated
             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
             against `aba'; then we want to ignore where we are now in
             the string in case this attempt to match fails.  */
          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
d4740 1
a4740 1
          regend[*p] = d;
d4743 2
a4744 2
          /* This register isn't active anymore.  */
          IS_ACTIVE (reg_info[*p]) = 0;
d4749 23
a4771 23
          /* If this was the only register active, nothing is active
             anymore.  */
          if (lowest_active_reg == highest_active_reg)
            {
              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
            }
          else
            { /* We must scan for the new highest active register, since
                 it isn't necessarily one less than now: consider
                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
                 new highest active register is 1.  */
              UCHAR_T r = *p - 1;
              while (r > 0 && !IS_ACTIVE (reg_info[r]))
                r--;

              /* If we end up at register zero, that means that we saved
                 the registers as the result of an `on_failure_jump', not
                 a `start_memory', and we jumped to past the innermost
                 `stop_memory'.  For example, in ((.)*) we save
                 registers 1 and 2 as a result of the *, but when we pop
                 back to the second ), we are at the stop_memory 1.
                 Thus, nothing is active.  */
d4773 7
a4779 7
                {
                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
                }
              else
                highest_active_reg = r;
            }
d4781 7
a4787 7
          /* If just failed to match something this time around with a
             group that's operated on by a repetition operator, try to
             force exit from the ``loop'', and restore the register
             information for this group that we had before trying this
             last match.  */
          if ((!MATCHED_SOMETHING (reg_info[*p])
               || just_past_start_mem == p - 1)
d4789 2
a4790 2
            {
              boolean is_a_jump_n = false;
d4792 5
a4796 5
              p1 = p + 2;
              mcnt = 0;
              switch ((re_opcode_t) *p1++)
                {
                  case jump_n:
d4798 1
a4798 1
                  case pop_failure_jump:
d4802 1
a4802 1
                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
d4804 2
a4805 2
		      p1 += OFFSET_ADDRESS_SIZE;
                    break;
d4807 3
a4809 3
                  default:
                    /* do nothing */ ;
                }
d4812 7
a4818 8
              /* If the next operation is a jump backwards in the pattern
	         to an on_failure_jump right before the start_memory
                 corresponding to this stop_memory, exit from the loop
                 by forcing a failure after pushing on the stack the
                 on_failure_jump's jump in the pattern, and d.  */
              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
                  && (re_opcode_t) p1[1+OFFSET_ADDRESS_SIZE] == start_memory
		  && p1[2+OFFSET_ADDRESS_SIZE] == *p)
d4820 9
a4828 9
                  /* If this group ever matched anything, then restore
                     what its registers were before trying this last
                     failed match, e.g., with `(a*)*b' against `ab' for
                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
                     against `aba' for regend[3].

                     Also restore the registers for inner groups for,
                     e.g., `((a*)(b*))*' against `aba' (register 3 would
                     otherwise get trashed).  */
d4830 1
a4830 1
                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
d4834 1
a4834 1
                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
d4837 9
a4845 10
                      for (r = *p; r < (unsigned) *p + (unsigned) *(p + 1);
			   r++)
                        {
                          regstart[r] = old_regstart[r];

                          /* xx why this test?  */
                          if (old_regend[r] >= regstart[r])
                            regend[r] = old_regend[r];
                        }
                    }
d4847 2
a4848 2
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
d4850 3
a4852 3
                  goto fail;
                }
            }
d4854 3
a4856 3
          /* Move past the register number and the inner group count.  */
          p += 2;
          NEXT;
d4860 2
a4861 2
           followed by the numeric value of <digit> as the register number.  */
        CASE (duplicate):
d4863 2
a4864 2
	    register const CHAR_T *d2, *dend2;
	    int regno = *p++;   /* Get which register to match against.  */
d4867 11
a4877 11
	    /* Can't back reference a group which we've never matched.  */
            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
              goto fail;

            /* Where in input to try to start matching.  */
            d2 = regstart[regno];

            /* Where to stop matching; if both the place to start and
               the place to stop matching are in the same string, then
               set to the place to stop, otherwise, for now have to use
               the end of the first string.  */
d4879 1
a4879 1
            dend2 = ((FIRST_STRING_P (regstart[regno])
d4885 1
a4885 1
                   contents.  */
d4891 3
a4893 3
                    /* End of string1 => advance to string2. */
                    d2 = string2;
                    dend2 = regend[regno];
d4905 2
a4906 2
                   one shot, so, if necessary, adjust the count.  */
                if (mcnt > dend2 - d2)
d4910 4
a4913 4
                   past them.  */
		if (translate
                    ? PREFIX(bcmp_translate) (d, d2, mcnt, translate)
                    : memcmp (d, d2, mcnt*sizeof(UCHAR_T)))
d4917 1
a4917 1
		/* Do this because we've match some characters.  */
d4921 1
a4921 1
	  NEXT;
d4924 5
a4928 5
        /* begline matches the empty string at the beginning of the string
           (unless `not_bol' is set in `bufp'), and, if
           `newline_anchor' is set, after newlines.  */
	CASE (begline):
          DEBUG_PRINT1 ("EXECUTING begline.\n");
d4930 10
a4939 13
          if (AT_STRINGS_BEG (d))
            {
              if (!bufp->not_bol)
		{
		  NEXT;
		}
            }
          else if (d[-1] == '\n' && bufp->newline_anchor)
            {
              NEXT;
            }
          /* In all other cases, we fail.  */
          goto fail;
d4942 3
a4944 3
        /* endline is the dual of begline.  */
	CASE (endline):
          DEBUG_PRINT1 ("EXECUTING endline.\n");
d4946 4
a4949 7
          if (AT_STRINGS_END (d))
            {
              if (!bufp->not_eol)
		{
		  NEXT;
		}
            }
d4951 7
a4957 7
          /* We have to ``prefetch'' the next character.  */
          else if ((d == end1 ? *string2 : *d) == '\n'
                   && bufp->newline_anchor)
            {
              NEXT;
            }
          goto fail;
d4961 5
a4965 7
        CASE (begbuf):
          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
          if (AT_STRINGS_BEG (d))
	    {
	      NEXT;
	    }
          goto fail;
d4969 2
a4970 2
        CASE (endbuf):
          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
d4972 29
a5000 4
	    {
	      NEXT;
	    }
          goto fail;
d5002 1
d5004 13
a5016 18
        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
           pushes NULL as the value for the string on the stack.  Then
           `pop_failure_point' will keep the current value for the
           string, instead of restoring it.  To see why, consider
           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
           then the . fails against the \n.  But the next thing we want
           to do is match the \n against the \n; if we restored the
           string value, we would be back at the foo.

           Because this is used only in specific cases, we don't need to
           check all the things that `on_failure_jump' does, to make
           sure the right things get saved on the stack.  Hence we don't
           share its code.  The only reason to push anything on the
           stack at all is that otherwise we would have to change
           `anychar's code to do something besides goto fail in this
           case; that seems worse than this.  */
        CASE (on_failure_keep_string_jump):
          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
d5018 2
a5019 5
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
#ifdef _LIBC
          DEBUG_PRINT3 (" %d (to %p):\n", mcnt, p + mcnt);
#else
          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
d5022 20
a5041 2
          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
          NEXT;
d5043 10
d5054 3
a5056 1
	/* Uses of on_failure_jump:
a5057 13
           Each alternative starts with an on_failure_jump that points
           to the beginning of the next alternative.  Each alternative
           except the last ends with a jump that in effect jumps past
           the rest of the alternatives.  (They really jump to the
           ending jump of the following alternative, because tensioning
           these jumps is a hassle.)

           Repeats start with an on_failure_jump that points past both
           the repetition text and either the following jump or
           pop_failure_jump back to this on_failure_jump.  */
	CASE (on_failure_jump):
        on_failure:
          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
d5059 5
a5063 5
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
#ifdef _LIBC
          DEBUG_PRINT3 (" %d (to %p)", mcnt, p + mcnt);
#else
          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
d5065 4
d5070 12
a5081 54
          /* If this on_failure_jump comes right before a group (i.e.,
             the original * applied to a group), save the information
             for that group and all inner ones, so that if we fail back
             to this point, the group's information will be correct.
             For example, in \(a*\)*\1, we need the preceding group,
             and in \(zz\(a*\)b*\)\2, we need the inner group.  */

          /* We can't use `p' to check ahead because we push
             a failure point to `p + mcnt' after we do this.  */
          p1 = p;

          /* We need to skip no_op's before we look for the
             start_memory in case this on_failure_jump is happening as
             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
             against aba.  */
          while (p1 < pend && (re_opcode_t) *p1 == no_op)
            p1++;

          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
            {
              /* We have a new highest active register now.  This will
                 get reset at the start_memory we are about to get to,
                 but we will have saved all the registers relevant to
                 this repetition op, as described above.  */
              highest_active_reg = *(p1 + 1) + *(p1 + 2);
              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
                lowest_active_reg = *(p1 + 1);
            }

          DEBUG_PRINT1 (":\n");
          PUSH_FAILURE_POINT (p + mcnt, d, -2);
          NEXT;


        /* A smart repeat ends with `maybe_pop_jump'.
	   We change it to either `pop_failure_jump' or `jump'.  */
        CASE (maybe_pop_jump):
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
          {
	    register UCHAR_T *p2 = p;

            /* Compare the beginning of the repeat with what in the
               pattern follows its end. If we can establish that there
               is nothing that they would both match, i.e., that we
               would have to backtrack because of (as in, e.g., `a*a')
               then we can change to pop_failure_jump, because we'll
               never have to backtrack.

               This is not true in the case of alternatives: in
               `(a|ab)*' we do need to backtrack to the `ab' alternative
               (e.g., if the string was `ab').  But instead of trying to
               detect that here, the alternative has put on a dummy
               failure point which is what we will end up popping.  */
d5093 1
a5093 1
		else if (p2 + 2 + 2 * OFFSET_ADDRESS_SIZE < pend
d5095 1
a5095 1
		  p2 += 2 + 2 * OFFSET_ADDRESS_SIZE;
d5103 1
a5103 1
	       follows.  */
d5105 2
a5106 2
            /* If we're at the end of the pattern, we can change.  */
            if (p2 == pend)
d5110 7
a5116 11
		   yet.  */
  	        p[-(1+OFFSET_ADDRESS_SIZE)] = (UCHAR_T)
		  pop_failure_jump;
                DEBUG_PRINT1
                  ("  End of pattern: change to `pop_failure_jump'.\n");
              }

            else if ((re_opcode_t) *p2 == exactn
#ifdef MBS_SUPPORT
		     || (re_opcode_t) *p2 == exactn_bin
#endif
d5119 2
a5120 2
		register UCHAR_T c
                  = *p2 == (UCHAR_T) endline ? '\n' : p2[2];
d5122 13
a5134 18
                if (((re_opcode_t) p1[1+OFFSET_ADDRESS_SIZE] == exactn
#ifdef MBS_SUPPORT
		     || (re_opcode_t) p1[1+OFFSET_ADDRESS_SIZE] == exactn_bin
#endif
		    ) && p1[3+OFFSET_ADDRESS_SIZE] != c)
                  {
  		    p[-(1+OFFSET_ADDRESS_SIZE)] = (UCHAR_T)
		      pop_failure_jump;
#ifdef WCHAR
		      DEBUG_PRINT3 ("  %C != %C => pop_failure_jump.\n",
				    (wint_t) c,
				    (wint_t) p1[3+OFFSET_ADDRESS_SIZE]);
#else
		      DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
				    (char) c,
				    (char) p1[3+OFFSET_ADDRESS_SIZE]);
#endif
                  }
a5135 1
#ifndef WCHAR
d5141 9
a5149 1
		    if (c < (unsigned) (p1[4] * BYTEWIDTH)
d5152 3
d5156 2
a5157 2
                    /* `not' is equal to 1 if c would match, which means
                        that we can't change to pop_failure_jump.  */
d5159 4
a5162 4
                      {
  		        p[-3] = (unsigned char) pop_failure_jump;
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
                      }
a5163 1
#endif /* not WCHAR */
d5165 1
a5165 2
#ifndef WCHAR
            else if ((re_opcode_t) *p2 == charset)
d5167 20
a5186 6
		/* We win if the first character of the loop is not part
                   of the charset.  */
                if ((re_opcode_t) p1[3] == exactn
 		    && ! ((int) p2[1] * BYTEWIDTH > (int) p1[5]
 			  && (p2[2 + p1[5] / BYTEWIDTH]
 			      & (1 << (p1[5] % BYTEWIDTH)))))
d5189 18
a5206 2
		    DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
                  }
d5208 1
a5208 1
		else if ((re_opcode_t) p1[3] == charset_not)
d5211 2
a5212 2
		    /* We win if the charset_not inside the loop
		       lists every character listed in the charset after.  */
d5215 1
a5215 1
			     || (idx < (int) p1[4]
d5220 4
a5223 4
                      {
  		        p[-3] = (unsigned char) pop_failure_jump;
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
                      }
d5231 2
a5232 1
			 idx < (int) p2[1] && idx < (int) p1[4];
d5237 6
a5242 5
		    if (idx == p2[1] || idx == p1[4])
                      {
  		        p[-3] = (unsigned char) pop_failure_jump;
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
                      }
a5244 1
#endif /* not WCHAR */
d5246 2
a5247 1
	  p -= OFFSET_ADDRESS_SIZE;	/* Point at relative address again.  */
d5250 2
a5251 2
	      p[-1] = (UCHAR_T) jump;
              DEBUG_PRINT1 ("  Match => jump.\n");
d5254 1
a5254 1
        /* Note fall through.  */
d5258 22
a5279 22
           its matching on_failure_jump, where the latter will push a
           failure point.  The pop_failure_jump takes off failure
           points put on by this pop_failure_jump's matching
           on_failure_jump; we got through the pattern to here from the
           matching on_failure_jump, so didn't fail.  */
        CASE (pop_failure_jump):
          {
            /* We need to pass separate storage for the lowest and
               highest registers, even though we don't care about the
               actual values.  Otherwise, we will restore only one
               register from the stack, since lowest will == highest in
               `pop_failure_point'.  */
            active_reg_t dummy_low_reg, dummy_high_reg;
            UCHAR_T *pdummy = NULL;
            const CHAR_T *sdummy = NULL;

            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
            POP_FAILURE_POINT (sdummy, pdummy,
                               dummy_low_reg, dummy_high_reg,
                               reg_dummy, reg_dummy, reg_info_dummy);
          }
	  /* Note fall through.  */
d5281 3
d5285 2
a5286 4
#ifdef _LIBC
	  DEBUG_PRINT2 ("\n%p: ", p);
#else
	  DEBUG_PRINT2 ("\n0x%x: ", p);
d5288 12
a5299 1
          /* Note fall through.  */
d5301 12
a5312 11
        /* Unconditionally jump (without popping any failure points).  */
        CASE (jump):
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
	  p += mcnt;				/* Do the jump.  */
#ifdef _LIBC
          DEBUG_PRINT2 ("(to %p).\n", p);
#else
          DEBUG_PRINT2 ("(to 0x%x).\n", p);
#endif
	  NEXT;
d5315 11
a5325 62
        /* We need this opcode so we can detect where alternatives end
           in `group_match_null_string_p' et al.  */
        CASE (jump_past_alt):
          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
          goto unconditional_jump;


        /* Normally, the on_failure_jump pushes a failure point, which
           then gets popped at pop_failure_jump.  We will end up at
           pop_failure_jump, also, and with a pattern of, say, `a+', we
           are skipping over the on_failure_jump, so we have to push
           something meaningless for pop_failure_jump to pop.  */
        CASE (dummy_failure_jump):
          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
          /* It doesn't matter what we push for the string here.  What
             the code at `fail' tests is the value for the pattern.  */
          PUSH_FAILURE_POINT (NULL, NULL, -2);
          goto unconditional_jump;


        /* At the end of an alternative, we need to push a dummy failure
           point in case we are followed by a `pop_failure_jump', because
           we don't want the failure point for the alternative to be
           popped.  For example, matching `(a|ab)*' against `aab'
           requires that we match the `ab' alternative.  */
        CASE (push_dummy_failure):
          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
          /* See comments just above at `dummy_failure_jump' about the
             two zeroes.  */
          PUSH_FAILURE_POINT (NULL, NULL, -2);
          NEXT;

        /* Have to succeed matching what follows at least n times.
           After that, handle like `on_failure_jump'.  */
        CASE (succeed_n):
          EXTRACT_NUMBER (mcnt, p + OFFSET_ADDRESS_SIZE);
          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);

          assert (mcnt >= 0);
          /* Originally, this is how many times we HAVE to succeed.  */
          if (mcnt > 0)
            {
               mcnt--;
	       p += OFFSET_ADDRESS_SIZE;
               STORE_NUMBER_AND_INCR (p, mcnt);
#ifdef _LIBC
               DEBUG_PRINT3 ("  Setting %p to %d.\n", p - OFFSET_ADDRESS_SIZE
			     , mcnt);
#else
               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p - OFFSET_ADDRESS_SIZE
			     , mcnt);
#endif
            }
	  else if (mcnt == 0)
            {
#ifdef _LIBC
              DEBUG_PRINT2 ("  Setting two bytes from %p to no_op.\n",
			    p + OFFSET_ADDRESS_SIZE);
#else
              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n",
			    p + OFFSET_ADDRESS_SIZE);
#endif /* _LIBC */
d5327 5
a5331 9
#ifdef WCHAR
	      p[1] = (UCHAR_T) no_op;
#else
	      p[2] = (UCHAR_T) no_op;
              p[3] = (UCHAR_T) no_op;
#endif /* WCHAR */
              goto on_failure;
            }
          NEXT;
d5333 17
a5349 3
        CASE (jump_n):
          EXTRACT_NUMBER (mcnt, p + OFFSET_ADDRESS_SIZE);
          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
d5351 3
a5353 5
          /* Originally, this is how many times we CAN jump.  */
          if (mcnt)
            {
               mcnt--;
               STORE_NUMBER (p + OFFSET_ADDRESS_SIZE, mcnt);
d5355 5
a5359 7
#ifdef _LIBC
               DEBUG_PRINT3 ("  Setting %p to %d.\n", p + OFFSET_ADDRESS_SIZE,
			     mcnt);
#else
               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p + OFFSET_ADDRESS_SIZE,
			     mcnt);
#endif /* _LIBC */
d5361 2
a5362 2
            }
          /* If don't have to jump any more, skip over the rest of command.  */
d5364 2
a5365 2
	    p += 2 * OFFSET_ADDRESS_SIZE;
          NEXT;
d5367 1
a5367 1
	CASE (set_number_at):
d5369 1
a5369 1
            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
d5371 4
a5374 8
            EXTRACT_NUMBER_AND_INCR (mcnt, p);
            p1 = p + mcnt;
            EXTRACT_NUMBER_AND_INCR (mcnt, p);
#ifdef _LIBC
            DEBUG_PRINT3 ("  Setting %p to %d.\n", p1, mcnt);
#else
            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
#endif
d5376 2
a5377 2
            NEXT;
          }
d5379 1
a5379 7
#if 0
	/* The DEC Alpha C compiler 3.x generates incorrect code for the
	   test  WORDCHAR_P (d - 1) != WORDCHAR_P (d)  in the expansion of
	   AT_WORD_BOUNDARY, so this code is disabled.  Expanding the
	   macro and introducing temporary variables works around the bug.  */

	CASE (wordbound):
a5380 5
	  if (AT_WORD_BOUNDARY (d))
	    {
	      NEXT;
	    }
	  goto fail;
d5382 1
a5382 9
	CASE (notwordbound):
	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
	  if (AT_WORD_BOUNDARY (d))
	    goto fail;
	  NEXT;
#else
	CASE (wordbound):
	{
	  boolean prevchar, thischar;
d5384 1
a5384 1
	  DEBUG_PRINT1 ("EXECUTING wordbound.\n");
d5386 2
d5389 17
a5405 2
	      NEXT;
	    }
d5407 7
a5413 6
	  prevchar = WORDCHAR_P (d - 1);
	  thischar = WORDCHAR_P (d);
	  if (prevchar != thischar)
	    {
	      NEXT;
	    }
a5414 1
	}
d5416 4
a5419 3
      CASE (notwordbound):
	{
	  boolean prevchar, thischar;
d5421 1
a5421 1
	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
d5424 19
d5444 5
a5448 3
	  prevchar = WORDCHAR_P (d - 1);
	  thischar = WORDCHAR_P (d);
	  if (prevchar != thischar)
a5449 1
	  NEXT;
d5451 35
d5487 1
d5489 5
a5493 6
	CASE (wordbeg):
          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
	  if (!AT_STRINGS_END (d) && WORDCHAR_P (d)
	      && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
	    {
	      NEXT;
d5495 4
a5498 1
          goto fail;
d5500 6
a5505 4
	CASE (wordend):
          DEBUG_PRINT1 ("EXECUTING wordend.\n");
	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
              && (AT_STRINGS_END (d) || !WORDCHAR_P (d)))
d5507 31
a5537 1
	      NEXT;
d5539 1
a5539 1
          goto fail;
d5542 17
a5558 17
  	CASE (before_dot):
          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
  	    goto fail;
  	  NEXT;

  	CASE (at_dot):
          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
  	    goto fail;
  	  NEXT;

  	CASE (after_dot):
          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
  	    goto fail;
  	  NEXT;
d5560 2
a5561 2
	CASE (syntaxspec):
          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
d5565 2
a5566 2
        CASE (wordchar):
          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
d5568 1
a5568 1
        matchsyntax:
d5570 18
a5587 3
	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
	  d++;
	  if (SYNTAX (d[-1]) != (enum syntaxcode) mcnt)
d5589 4
a5592 2
          SET_REGS_MATCHED ();
	  NEXT;
d5594 2
a5595 2
	CASE (notsyntaxspec):
          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
d5599 2
a5600 2
        CASE (notwordchar):
          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
d5602 1
a5602 1
        matchnotsyntax:
d5604 15
a5618 3
	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
	  d++;
	  if (SYNTAX (d[-1]) == (enum syntaxcode) mcnt)
d5620 40
d5661 1
a5661 1
          NEXT;
d5664 1
a5664 1
	CASE (wordchar):
d5671 1
a5671 1
	  NEXT;
d5673 1
a5673 1
	CASE (notwordchar):
d5680 1
a5680 1
	  NEXT;
a5682 1
#ifndef __GNUC__
a5686 1
#endif
d5691 3
d5763 3
a5765 2
PREFIX(group_match_null_string_p) (UCHAR_T **p, UCHAR_T *end,
				   PREFIX(register_info_type) *reg_info)
d5769 1
a5769 1
  UCHAR_T *p1 = *p + 2;
d5807 1
a5807 2
              while ((re_opcode_t) p1[mcnt-(1+OFFSET_ADDRESS_SIZE)] ==
		     jump_past_alt)
d5813 2
a5814 3
                  if (!PREFIX(alt_match_null_string_p) (p1, p1 + mcnt -
						(1 + OFFSET_ADDRESS_SIZE),
						reg_info))
d5830 1
a5830 2
                  if ((re_opcode_t) p1[mcnt-(1+OFFSET_ADDRESS_SIZE)] !=
		      jump_past_alt)
d5833 1
a5833 1
                      p1 -= 1 + OFFSET_ADDRESS_SIZE;
d5841 1
a5841 1
              EXTRACT_NUMBER (mcnt, p1 - OFFSET_ADDRESS_SIZE);
d5843 1
a5843 1
              if (!PREFIX(alt_match_null_string_p) (p1, p1 + mcnt, reg_info))
d5858 1
a5858 1
          if (!PREFIX(common_op_match_null_string_p) (&p1, end, reg_info))
d5872 3
a5874 2
PREFIX(alt_match_null_string_p) (UCHAR_T *p, UCHAR_T *end,
				 PREFIX(register_info_type) *reg_info)
d5877 1
a5877 1
  UCHAR_T *p1 = p;
d5894 1
a5894 1
          if (!PREFIX(common_op_match_null_string_p) (&p1, end, reg_info))
d5909 3
a5911 2
PREFIX(common_op_match_null_string_p) (UCHAR_T **p, UCHAR_T *end,
				       PREFIX(register_info_type) *reg_info)
d5916 1
a5916 1
  UCHAR_T *p1 = *p;
d5939 1
a5939 1
      ret = PREFIX(group_match_null_string_p) (&p1, end, reg_info);
d5962 1
a5962 1
      p1 += OFFSET_ADDRESS_SIZE;
d5967 1
a5967 1
          p1 -= 2 * OFFSET_ADDRESS_SIZE;
d5981 1
a5981 1
      p1 += 2 * OFFSET_ADDRESS_SIZE;
d5997 10
a6006 7
PREFIX(bcmp_translate) (const CHAR_T *s1, const CHAR_T *s2,
			register int len,
			RE_TRANSLATE_TYPE translate)
{
  register const UCHAR_T *p1 = (const UCHAR_T *) s1;
  register const UCHAR_T *p2 = (const UCHAR_T *) s2;
  while (len)
d6008 8
a6015 3
#ifdef WCHAR
      if (((*p1<=0xff)?translate[*p1++]:*p1++)
	  != ((*p2<=0xff)?translate[*p2++]:*p2++))
d6017 2
a6018 4
#else /* BYTE */
      if (translate[*p1++] != translate[*p2++]) return 1;
#endif /* WCHAR */
      len--;
d6020 4
a6026 3

#else /* not INSIDE_RECURSION */

d6039 4
a6042 3
re_compile_pattern (const char *pattern,
		    size_t length,
		    struct re_pattern_buffer *bufp)
d6058 1
a6058 6
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    ret = wcs_regex_compile (pattern, length, re_syntax_options, bufp);
  else
# endif
    ret = byte_regex_compile (pattern, length, re_syntax_options, bufp);
d6062 1
a6062 1
  return gettext (re_error_msgid + re_error_msgid_idx[(int) ret]);
a6063 3
#ifdef _LIBC
weak_alias (__re_compile_pattern, re_compile_pattern)
#endif
d6068 1
a6068 1
#if defined _REGEX_RE_COMP || defined _LIBC
d6080 2
a6081 1
re_comp (const char *s)
d6088 1
a6088 1
	return (char *) gettext ("No previous regular expression");
d6094 1
a6094 1
      re_comp_buf.buffer = malloc (200);
d6096 2
a6097 2
        return (char *) gettext (re_error_msgid
				 + re_error_msgid_idx[(int) REG_ESPACE]);
d6100 1
a6100 1
      re_comp_buf.fastmap = malloc (1 << BYTEWIDTH);
d6102 2
a6103 2
	return (char *) gettext (re_error_msgid
				 + re_error_msgid_idx[(int) REG_ESPACE]);
d6112 1
a6112 6
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    ret = wcs_regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
  else
# endif
    ret = byte_regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
d6118 1
a6118 1
  return (char *) gettext (re_error_msgid + re_error_msgid_idx[(int) ret]);
d6126 2
a6127 1
re_exec (const char *s)
d6131 1
a6131 1
    0 <= re_search (&re_comp_buf, s, len, 0, len, 0);
a6132 1

d6150 1
a6150 2
     `fastmap' to an allocated space for the fastmap;
     `fastmap_accurate' to zero;
d6174 4
a6177 1
regcomp (regex_t *preg, const char *pattern, int cflags)
d6180 1
a6180 1
  reg_syntax_t syntax
d6189 5
a6193 2
  /* Try to allocate space for the fastmap.  */
  preg->fastmap = malloc (1 << BYTEWIDTH);
d6199 3
a6201 2
      preg->translate = malloc (CHAR_SET_SIZE
				* sizeof (*(RE_TRANSLATE_TYPE)0));
d6207 1
a6207 1
        preg->translate[i] = ISUPPER (i) ? TOLOWER (i) : i;
d6227 1
a6227 6
# ifdef MBS_SUPPORT
  if (MB_CUR_MAX != 1)
    ret = wcs_regex_compile (pattern, strlen (pattern), syntax, preg);
  else
# endif
    ret = byte_regex_compile (pattern, strlen (pattern), syntax, preg);
a6232 13
  if (ret == REG_NOERROR && preg->fastmap)
    {
      /* Compute the fastmap now, since regexec cannot modify the pattern
	 buffer.  */
      if (re_compile_fastmap (preg) == -2)
	{
	  /* Some error occurred while computing the fastmap, just forget
	     about it.  */
	  free (preg->fastmap);
	  preg->fastmap = NULL;
	}
    }

a6234 3
#ifdef _LIBC
weak_alias (__regcomp, regcomp)
#endif
d6252 6
a6257 2
regexec (const regex_t *preg, const char *string,
	 size_t nmatch, regmatch_t pmatch[], int eflags)
d6278 3
a6280 2
      regs.start = TALLOC (nmatch * 2, regoff_t);
      if (regs.start == NULL)
a6281 1
      regs.end = regs.start + nmatch;
d6287 1
a6287 1
                   want_reg_info ? &regs : 0);
d6305 1
a6310 3
#ifdef _LIBC
weak_alias (__regexec, regexec)
#endif
d6317 5
a6321 1
regerror (int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size)
d6327 1
a6327 2
      || errcode >= (int) (sizeof (re_error_msgid_idx)
			   / sizeof (re_error_msgid_idx[0])))
d6334 1
a6334 1
  msg = gettext (re_error_msgid + re_error_msgid_idx[errcode]);
d6342 1
a6342 4
#if defined HAVE_MEMPCPY || defined _LIBC
	  *((char *) __mempcpy (errbuf, msg, errbuf_size - 1)) = '\0';
#else
          memcpy (errbuf, msg, errbuf_size - 1);
a6343 1
#endif
d6346 1
a6346 1
        memcpy (errbuf, msg, msg_size);
a6350 3
#ifdef _LIBC
weak_alias (__regerror, regerror)
#endif
d6356 2
a6357 1
regfree (regex_t *preg)
a6374 3
#ifdef _LIBC
weak_alias (__regfree, regfree)
#endif
a6376 71

#endif /* not INSIDE_RECURSION */


#undef STORE_NUMBER
#undef STORE_NUMBER_AND_INCR
#undef EXTRACT_NUMBER
#undef EXTRACT_NUMBER_AND_INCR

#undef DEBUG_PRINT_COMPILED_PATTERN
#undef DEBUG_PRINT_DOUBLE_STRING

#undef INIT_FAIL_STACK
#undef RESET_FAIL_STACK
#undef DOUBLE_FAIL_STACK
#undef PUSH_PATTERN_OP
#undef PUSH_FAILURE_POINTER
#undef PUSH_FAILURE_INT
#undef PUSH_FAILURE_ELT
#undef POP_FAILURE_POINTER
#undef POP_FAILURE_INT
#undef POP_FAILURE_ELT
#undef DEBUG_PUSH
#undef DEBUG_POP
#undef PUSH_FAILURE_POINT
#undef POP_FAILURE_POINT

#undef REG_UNSET_VALUE
#undef REG_UNSET

#undef PATFETCH
#undef PATFETCH_RAW
#undef PATUNFETCH
#undef TRANSLATE

#undef INIT_BUF_SIZE
#undef GET_BUFFER_SPACE
#undef BUF_PUSH
#undef BUF_PUSH_2
#undef BUF_PUSH_3
#undef STORE_JUMP
#undef STORE_JUMP2
#undef INSERT_JUMP
#undef INSERT_JUMP2
#undef EXTEND_BUFFER
#undef GET_UNSIGNED_NUMBER
#undef FREE_STACK_RETURN

# undef POINTER_TO_OFFSET
# undef MATCHING_IN_FRST_STRING
# undef PREFETCH
# undef AT_STRINGS_BEG
# undef AT_STRINGS_END
# undef WORDCHAR_P
# undef FREE_VAR
# undef FREE_VARIABLES
# undef NO_HIGHEST_ACTIVE_REG
# undef NO_LOWEST_ACTIVE_REG

# undef CHAR_T
# undef UCHAR_T
# undef COMPILED_BUFFER_VAR
# undef OFFSET_ADDRESS_SIZE
# undef CHAR_CLASS_SIZE
# undef PREFIX
# undef ARG_PREFIX
# undef PUT_CHAR
# undef BYTE
# undef WCHAR

# define DEFINED_ONCE
@


1.1.3.1
log
@our CVS is currently at 1.11.1p1, thus import that version into vendor branch
@
text
@@


1.1.3.2
log
@CVS 1.11.12 is the latest stable version of CVS,
released 06.02.2004, with a huge lot of bug fixes.

/me hopes this will pay off...
@
text
@d1537 1
d5475 1
a5475 1

@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
