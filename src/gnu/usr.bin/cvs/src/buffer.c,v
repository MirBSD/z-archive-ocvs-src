head	1.5;
access;
symbols
	cvs-1_12_11:1.1.2.2
	tg-mergetmp-mirosx-1:1.4
	tg-mergefixes-1-branch:1.4.0.4
	tg-mergefixes-1-base:1.4
	MIROS_X:1.4.0.2
	MIROS_X_BASE:1.4
	cvs-1_12_10:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_MIRPPC:1.3.0.4
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200404170130:1.1.1.1
	cvs-1_11_12:1.1.3.2
	cvs-1_11_1p1:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.08.21.31.31;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.02.12.40.10;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.22.13.49.13;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.02.12.21.16.08;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.28;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.41.28;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2004.12.02.11.58.48;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.01.08.21.14.01;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.02.12.19.18.11;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.12.19.38.35;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@fastmerge
@
text
@/* Code for the buffer data structure.  */

#include "cvs.h"
#include "buffer.h"

#if defined (SERVER_SUPPORT) || defined (CLIENT_SUPPORT)

# ifdef HAVE_WINSOCK_H
#   include <winsock.h>
# else
#  include <sys/socket.h>
# endif

/* OS/2 doesn't have EIO.  FIXME: this whole notion of turning
   a different error into EIO strikes me as pretty dubious.  */
# if !defined( EIO )
#   define EIO EBADPOS
# endif

/* Linked list of available buffer_data structures.  */
static struct buffer_data *free_buffer_data;

/* Local functions.  */
static void buf_default_memory_error (struct buffer *);
static void allocate_buffer_datas (void);
static struct buffer_data *get_buffer_data (void);



/* Initialize a buffer structure.  */
struct buffer *
buf_initialize (int (*input) (void *, char *, size_t, size_t, size_t *),
	        int (*output) (void *, const char *, size_t, size_t *),
                int (*flush) (void *),
                int (*block) (void *, bool),
                int (*get_fd) (void *),
                int (*shutdown) (struct buffer *),
                void (*memory) (struct buffer *),
                void *closure)
{
    struct buffer *buf;

    buf = xmalloc (sizeof (struct buffer));
    buf->data = NULL;
    buf->last = NULL;
    buf->nonblocking = false;
    buf->input = input;
    buf->output = output;
    buf->flush = flush;
    buf->block = block;
    buf->get_fd = get_fd;
    buf->shutdown = shutdown;
    buf->memory_error = memory ? memory : buf_default_memory_error;
    buf->closure = closure;
    return buf;
}



/* Free a buffer structure.  */
void
buf_free (struct buffer *buf)
{
    if (buf->closure != NULL)
    {
	free (buf->closure);
	buf->closure = NULL;
    }
    if (buf->data != NULL)
    {
	buf->last->next = free_buffer_data;
	free_buffer_data = buf->data;
    }
    free (buf);
}



/* Initialize a buffer structure which is not to be used for I/O.  */
struct buffer *
buf_nonio_initialize( void (*memory) (struct buffer *) )
{
    return buf_initialize (NULL, NULL, NULL, NULL, NULL, NULL, memory, NULL);
}



/* Default memory error handler.  */
static void
buf_default_memory_error (struct buffer *buf)
{
    error (1, 0, "out of memory");
}



/* Allocate more buffer_data structures.  */
static void
allocate_buffer_datas (void)
{
    struct buffer_data *alc;
    char *space;
    int i;

    /* Allocate buffer_data structures in blocks of 16.  */
# define ALLOC_COUNT (16)

    alc = xmalloc (ALLOC_COUNT * sizeof (struct buffer_data));
    space = valloc (ALLOC_COUNT * BUFFER_DATA_SIZE);
    if (alc == NULL || space == NULL)
	return;
    for (i = 0; i < ALLOC_COUNT; i++, alc++, space += BUFFER_DATA_SIZE)
    {
	alc->next = free_buffer_data;
	free_buffer_data = alc;
	alc->text = space;
    }	  
}



/* Get a new buffer_data structure.  */
static struct buffer_data *
get_buffer_data (void)
{
    struct buffer_data *ret;

    if (free_buffer_data == NULL)
    {
	allocate_buffer_datas ();
	if (free_buffer_data == NULL)
	    return NULL;
    }

    ret = free_buffer_data;
    free_buffer_data = ret->next;
    return ret;
}



/* See whether a buffer and its file descriptor is empty.  */
int
buf_empty (buf)
    struct buffer *buf;
{
	/* Try and read any data on the file descriptor first.
	 * We already know the descriptor is non-blocking.
	 */
	buf_input_data (buf, NULL);
	return buf_empty_p (buf);
}



/* See whether a buffer is empty.  */
int
buf_empty_p (struct buffer *buf)
{
    struct buffer_data *data;

    for (data = buf->data; data != NULL; data = data->next)
	if (data->size > 0)
	    return 0;
    return 1;
}



# if defined (SERVER_FLOWCONTROL) || defined (PROXY_SUPPORT)
/*
 * Count how much data is stored in the buffer..
 * Note that each buffer is a xmalloc'ed chunk BUFFER_DATA_SIZE.
 */
int
buf_count_mem (struct buffer *buf)
{
    struct buffer_data *data;
    int mem = 0;

    for (data = buf->data; data != NULL; data = data->next)
	mem += BUFFER_DATA_SIZE;

    return mem;
}
# endif /* SERVER_FLOWCONTROL || PROXY_SUPPORT */



/* Add data DATA of length LEN to BUF.  */
void
buf_output (struct buffer *buf, const char *data, size_t len)
{
    if (buf->data != NULL
	&& (((buf->last->text + BUFFER_DATA_SIZE)
	     - (buf->last->bufp + buf->last->size))
	    >= len))
    {
	memcpy (buf->last->bufp + buf->last->size, data, len);
	buf->last->size += len;
	return;
    }

    while (1)
    {
	struct buffer_data *newdata;

	newdata = get_buffer_data ();
	if (newdata == NULL)
	{
	    (*buf->memory_error) (buf);
	    return;
	}

	if (buf->data == NULL)
	    buf->data = newdata;
	else
	    buf->last->next = newdata;
	newdata->next = NULL;
	buf->last = newdata;

	newdata->bufp = newdata->text;

	if (len <= BUFFER_DATA_SIZE)
	{
	    newdata->size = len;
	    memcpy (newdata->text, data, len);
	    return;
	}

	newdata->size = BUFFER_DATA_SIZE;
	memcpy (newdata->text, data, BUFFER_DATA_SIZE);

	data += BUFFER_DATA_SIZE;
	len -= BUFFER_DATA_SIZE;
    }

    /*NOTREACHED*/
}



/* Add a '\0' terminated string to BUF.  */
void
buf_output0 (struct buffer *buf, const char *string)
{
    buf_output (buf, string, strlen (string));
}



/* Add a single character to BUF.  */
void
buf_append_char (struct buffer *buf, int ch)
{
    if (buf->data != NULL
	&& (buf->last->text + BUFFER_DATA_SIZE
	    != buf->last->bufp + buf->last->size))
    {
	*(buf->last->bufp + buf->last->size) = ch;
	++buf->last->size;
    }
    else
    {
	char b;

	b = ch;
	buf_output (buf, &b, 1);
    }
}



/*
 * Send all the output we've been saving up.  Returns 0 for success or
 * errno code.  If the buffer has been set to be nonblocking, this
 * will just write until the write would block.
 */
int
buf_send_output (struct buffer *buf)
{
    assert (buf->output != NULL);

    while (buf->data != NULL)
    {
	struct buffer_data *data;

	data = buf->data;

	if (data->size > 0)
	{
	    int status;
	    size_t nbytes;

	    status = (*buf->output) (buf->closure, data->bufp, data->size,
				     &nbytes);
	    if (status != 0)
	    {
		/* Some sort of error.  Discard the data, and return.  */

		buf->last->next = free_buffer_data;
		free_buffer_data = buf->data;
		buf->data = NULL;
		buf->last = NULL;

	        return status;
	    }

	    if (nbytes != data->size)
	    {
		/* Not all the data was written out.  This is only
                   permitted in nonblocking mode.  Adjust the buffer,
                   and return.  */

		assert (buf->nonblocking);

		data->size -= nbytes;
		data->bufp += nbytes;

		return 0;
	    }
	}

	buf->data = data->next;
	data->next = free_buffer_data;
	free_buffer_data = data;
    }

    buf->last = NULL;

    return 0;
}



/*
 * Flush any data queued up in the buffer.  If BLOCK is nonzero, then
 * if the buffer is in nonblocking mode, put it into blocking mode for
 * the duration of the flush.  This returns 0 on success, or an error
 * code.
 */
int
buf_flush (struct buffer *buf, bool block)
{
    int nonblocking;
    int status;

    assert (buf->flush != NULL);

    nonblocking = buf->nonblocking;
    if (nonblocking && block)
    {
        status = set_block (buf);
	if (status != 0)
	    return status;
    }

    status = buf_send_output (buf);
    if (status == 0)
        status = (*buf->flush) (buf->closure);

    if (nonblocking && block)
    {
        int blockstat;

        blockstat = set_nonblock (buf);
	if (status == 0)
	    status = blockstat;
    }

    return status;
}



/*
 * Set buffer BUF to nonblocking I/O.  Returns 0 for success or errno
 * code.
 */
int
set_nonblock (struct buffer *buf)
{
    int status;

    if (buf->nonblocking)
	return 0;
    assert (buf->block != NULL);
    status = (*buf->block) (buf->closure, 0);
    if (status != 0)
	return status;
    buf->nonblocking = true;
    return 0;
}



/*
 * Set buffer BUF to blocking I/O.  Returns 0 for success or errno
 * code.
 */
int
set_block (struct buffer *buf)
{
    int status;

    if (! buf->nonblocking)
	return 0;
    assert (buf->block != NULL);
    status = (*buf->block) (buf->closure, 1);
    if (status != 0)
	return status;
    buf->nonblocking = false;
    return 0;
}



/*
 * Send a character count and some output.  Returns errno code or 0 for
 * success.
 *
 * Sending the count in binary is OK since this is only used on a pipe
 * within the same system.
 */
int
buf_send_counted (struct buffer *buf)
{
    int size;
    struct buffer_data *data;

    size = 0;
    for (data = buf->data; data != NULL; data = data->next)
	size += data->size;

    data = get_buffer_data ();
    if (data == NULL)
    {
	(*buf->memory_error) (buf);
	return ENOMEM;
    }

    data->next = buf->data;
    buf->data = data;
    if (buf->last == NULL)
	buf->last = data;

    data->bufp = data->text;
    data->size = sizeof (int);

    *((int *) data->text) = size;

    return buf_send_output (buf);
}



/*
 * Send a special count.  COUNT should be negative.  It will be
 * handled specially by buf_copy_counted.  This function returns 0 or
 * an errno code.
 *
 * Sending the count in binary is OK since this is only used on a pipe
 * within the same system.
 */
int
buf_send_special_count (struct buffer *buf, int count)
{
    struct buffer_data *data;

    data = get_buffer_data ();
    if (data == NULL)
    {
	(*buf->memory_error) (buf);
	return ENOMEM;
    }

    data->next = buf->data;
    buf->data = data;
    if (buf->last == NULL)
	buf->last = data;

    data->bufp = data->text;
    data->size = sizeof (int);

    *((int *) data->text) = count;

    return buf_send_output (buf);
}



/* Append a list of buffer_data structures to an buffer.  */
void
buf_append_data (struct buffer *buf, struct buffer_data *data,
                 struct buffer_data *last)
{
    if (data != NULL)
    {
	if (buf->data == NULL)
	    buf->data = data;
	else
	    buf->last->next = data;
	buf->last = last;
    }
}



# ifdef PROXY_SUPPORT
/* Copy data structures and append them to a buffer.
 *
 * ERRORS
 *   Failure to allocate memory here is fatal.
 */
void
buf_copy_data (struct buffer *buf, struct buffer_data *data,
               struct buffer_data *last)
{
    struct buffer_data *first, *new, *cur, *prev;

    assert (buf);
    assert (data);

    prev = first = NULL;
    cur = data;
    while (1)
    {
	new = get_buffer_data ();
	if (!new) error (1, errno, "Failed to allocate buffer data.");

	if (!first) first = new;
	memcpy (new->text, cur->bufp, cur->size);
	new->bufp = new->text;
	new->size = cur->size;
	new->next = NULL;
	if (prev) prev->next = new;
	if (cur == last) break;
	prev = new;
	cur = cur->next;
    }

    buf_append_data (buf, first, new);
}



/* Dispose of any remaining data in the buffer.  */
void
buf_free_data (struct buffer *buffer)
{
    if (buf_empty_p (buffer)) return;
    buffer->last->next = free_buffer_data;
    free_buffer_data = buffer->data;
    buffer->data = buffer->last = NULL;
}
# endif /* PROXY_SUPPORT */



/* Append the data in one buffer to another.  This removes the data
 * from the source buffer.
 */
void
buf_append_buffer (struct buffer *to, struct buffer *from)
{
    struct buffer_data *n;

    /* Copy the data pointer to the new buf.  */
    buf_append_data (to, from->data, from->last);

    n = from->data;
    while (n)
    {
	if (n == from->last) break;
	n = n->next;
    }

    /* Remove from the original location.  */
    from->data = NULL;
    from->last = NULL;
}



/*
 * Copy the contents of file F into buffer_data structures.  We can't
 * copy directly into an buffer, because we want to handle failure and
 * success differently.  Returns 0 on success, or -2 if out of
 * memory, or a status code on error.  Since the caller happens to
 * know the size of the file, it is passed in as SIZE.  On success,
 * this function sets *RETP and *LASTP, which may be passed to
 * buf_append_data.
 */
int
buf_read_file (FILE *f, long int size, struct buffer_data **retp,
               struct buffer_data **lastp)
{
    int status;

    *retp = NULL;
    *lastp = NULL;

    while (size > 0)
    {
	struct buffer_data *data;
	int get;

	data = get_buffer_data ();
	if (data == NULL)
	{
	    status = -2;
	    goto error_return;
	}

	if (*retp == NULL)
	    *retp = data;
	else
	    (*lastp)->next = data;
	data->next = NULL;
	*lastp = data;

	data->bufp = data->text;
	data->size = 0;

	if (size > BUFFER_DATA_SIZE)
	    get = BUFFER_DATA_SIZE;
	else
	    get = size;

	errno = EIO;
	if (fread (data->text, get, 1, f) != 1)
	{
	    status = errno;
	    goto error_return;
	}

	data->size += get;
	size -= get;
    }

    return 0;

  error_return:
    if (*retp != NULL)
    {
	(*lastp)->next = free_buffer_data;
	free_buffer_data = *retp;
    }
    return status;
}



/*
 * Copy the contents of file F into buffer_data structures.  We can't
 * copy directly into an buffer, because we want to handle failure and
 * success differently.  Returns 0 on success, or -2 if out of
 * memory, or a status code on error.  On success, this function sets
 * *RETP and *LASTP, which may be passed to buf_append_data.
 */
int
buf_read_file_to_eof (FILE *f, struct buffer_data **retp,
                      struct buffer_data **lastp)
{
    int status;

    *retp = NULL;
    *lastp = NULL;

    while (!feof (f))
    {
	struct buffer_data *data;
	int get, nread;

	data = get_buffer_data ();
	if (data == NULL)
	{
	    status = -2;
	    goto error_return;
	}

	if (*retp == NULL)
	    *retp = data;
	else
	    (*lastp)->next = data;
	data->next = NULL;
	*lastp = data;

	data->bufp = data->text;
	data->size = 0;

	get = BUFFER_DATA_SIZE;

	errno = EIO;
	nread = fread (data->text, 1, get, f);
	if (nread == 0 && !feof (f))
	{
	    status = errno;
	    goto error_return;
	}

	data->size = nread;
    }

    return 0;

  error_return:
    if (*retp != NULL)
    {
	(*lastp)->next = free_buffer_data;
	free_buffer_data = *retp;
    }
    return status;
}



/* Return the number of bytes in a chain of buffer_data structures.  */
int
buf_chain_length (struct buffer_data *buf)
{
    int size = 0;
    while (buf)
    {
	size += buf->size;
	buf = buf->next;
    }
    return size;
}



/* Return the number of bytes in a buffer.  */
int
buf_length (struct buffer *buf)
{
    return buf_chain_length (buf->data);
}



/*
 * Read an arbitrary amount of data into an input buffer.  The buffer
 * will be in nonblocking mode, and we just grab what we can.  Return
 * 0 on success, or -1 on end of file, or -2 if out of memory, or an
 * error code.  If COUNTP is not NULL, *COUNTP is set to the number of
 * bytes read.
 */
int
buf_input_data (struct buffer *buf, size_t *countp)
{
    assert (buf->input != NULL);

    if (countp != NULL)
	*countp = 0;

    while (1)
    {
	int status;
	size_t get, nbytes;

	if (buf->data == NULL
	    || (buf->last->bufp + buf->last->size
		== buf->last->text + BUFFER_DATA_SIZE))
	{
	    struct buffer_data *data;

	    data = get_buffer_data ();
	    if (data == NULL)
	    {
		(*buf->memory_error) (buf);
		return -2;
	    }

	    if (buf->data == NULL)
		buf->data = data;
	    else
		buf->last->next = data;
	    data->next = NULL;
	    buf->last = data;

	    data->bufp = data->text;
	    data->size = 0;
	}

	get = ((buf->last->text + BUFFER_DATA_SIZE)
	       - (buf->last->bufp + buf->last->size));

	status = (*buf->input) (buf->closure,
				buf->last->bufp + buf->last->size,
				0, get, &nbytes);
	if (status != 0)
	    return status;

	buf->last->size += nbytes;
	if (countp != NULL)
	    *countp += nbytes;

	if (nbytes < get)
	{
	    /* If we did not fill the buffer, then presumably we read
               all the available data.  */
	    return 0;
	}
    }

    /*NOTREACHED*/
}



/*
 * Read a line (characters up to a \012) from an input buffer.  (We
 * use \012 rather than \n for the benefit of non Unix clients for
 * which \n means something else).  This returns 0 on success, or -1
 * on end of file, or -2 if out of memory, or an error code.  If it
 * succeeds, it sets *LINE to an allocated buffer holding the contents
 * of the line.  The trailing \012 is not included in the buffer.  If
 * LENP is not NULL, then *LENP is set to the number of bytes read;
 * strlen may not work, because there may be embedded null bytes.
 */
int
buf_read_line (struct buffer *buf, char **line, size_t *lenp)
{
    return buf_read_short_line (buf, line, lenp, SIZE_MAX);
}



/* Like buf_read_line, but return -2 if no newline is found in MAX characters.
 */
int
buf_read_short_line (struct buffer *buf, char **line, size_t *lenp,
                     size_t max)
{
    assert (buf->input != NULL);

    *line = NULL;

    while (1)
    {
	size_t len, finallen, predicted_len;
	struct buffer_data *data;
	char *nl;

	/* See if there is a newline in BUF.  */
	len = 0;
	for (data = buf->data; data != NULL; data = data->next)
	{
	    nl = memchr (data->bufp, '\012', data->size);
	    if (nl != NULL)
	    {
	        finallen = nl - data->bufp;
		if (xsum (len, finallen) >= max) return -2;
	        len += finallen;
		break;
	    }
	    else if (xsum (len, data->size) >= max) return -2;
	    len += data->size;
	}

	/* If we found a newline, copy the line into a memory buffer,
           and remove it from BUF.  */
	if (data != NULL)
	{
	    char *p;
	    struct buffer_data *nldata;

	    p = xmalloc (len + 1);
	    if (p == NULL)
		return -2;
	    *line = p;

	    nldata = data;
	    data = buf->data;
	    while (data != nldata)
	    {
		struct buffer_data *next;

		memcpy (p, data->bufp, data->size);
		p += data->size;
		next = data->next;
		data->next = free_buffer_data;
		free_buffer_data = data;
		data = next;
	    }

	    memcpy (p, data->bufp, finallen);
	    p[finallen] = '\0';

	    data->size -= finallen + 1;
	    data->bufp = nl + 1;
	    buf->data = data;

	    if (lenp != NULL)
	        *lenp = len;

	    return 0;
	}

	/* Read more data until we get a newline or MAX characters.  */
	predicted_len = 0;
	while (1)
	{
	    int status;
	    size_t size, nbytes;
	    char *mem;

	    if (buf->data == NULL
		|| (buf->last->bufp + buf->last->size
		    == buf->last->text + BUFFER_DATA_SIZE))
	    {
		data = get_buffer_data ();
		if (data == NULL)
		{
		    (*buf->memory_error) (buf);
		    return -2;
		}

		if (buf->data == NULL)
		    buf->data = data;
		else
		    buf->last->next = data;
		data->next = NULL;
		buf->last = data;

		data->bufp = data->text;
		data->size = 0;
	    }

	    mem = buf->last->bufp + buf->last->size;
	    size = (buf->last->text + BUFFER_DATA_SIZE) - mem;

	    /* We need to read at least 1 byte.  We can handle up to
               SIZE bytes.  This will only be efficient if the
               underlying communication stream does its own buffering,
               or is clever about getting more than 1 byte at a time.  */
	    status = (*buf->input) (buf->closure, mem, 1, size, &nbytes);
	    if (status != 0)
		return status;

	    predicted_len += nbytes;
	    buf->last->size += nbytes;

	    /* Optimize slightly to avoid an unnecessary call to memchr.  */
	    if (nbytes == 1)
	    {
		if (*mem == '\012')
		    break;
	    }
	    else
	    {
		if (memchr (mem, '\012', nbytes) != NULL)
		    break;
	    }
	    if (xsum (len, predicted_len) >= max) return -2;
	}
    }
}



/*
 * Extract data from the input buffer BUF.  This will read up to WANT
 * bytes from the buffer.  It will set *RETDATA to point at the bytes,
 * and set *GOT to the number of bytes to be found there.  Any buffer
 * call which uses BUF may change the contents of the buffer at *DATA,
 * so the data should be fully processed before any further calls are
 * made.  This returns 0 on success, or -1 on end of file, or -2 if
 * out of memory, or an error code.
 */
int
buf_read_data (struct buffer *buf, size_t want, char **retdata, size_t *got)
{
    assert (buf->input != NULL);

    while (buf->data != NULL && buf->data->size == 0)
    {
	struct buffer_data *next;

	next = buf->data->next;
	buf->data->next = free_buffer_data;
	free_buffer_data = buf->data;
	buf->data = next;
	if (next == NULL)
	    buf->last = NULL;
    }

    if (buf->data == NULL)
    {
	struct buffer_data *data;
	int status;
	size_t get, nbytes;

	data = get_buffer_data ();
	if (data == NULL)
	{
	    (*buf->memory_error) (buf);
	    return -2;
	}

	buf->data = data;
	buf->last = data;
	data->next = NULL;
	data->bufp = data->text;
	data->size = 0;

	if (want < BUFFER_DATA_SIZE)
	    get = want;
	else
	    get = BUFFER_DATA_SIZE;
	status = (*buf->input) (buf->closure, data->bufp, get,
				BUFFER_DATA_SIZE, &nbytes);
	if (status != 0)
	    return status;

	data->size = nbytes;
    }

    *retdata = buf->data->bufp;
    if (want < buf->data->size)
    {
        *got = want;
	buf->data->size -= want;
	buf->data->bufp += want;
    }
    else
    {
        *got = buf->data->size;
	buf->data->size = 0;
    }

    return 0;
}



/*
 * Copy lines from an input buffer to an output buffer.
 * This copies all complete lines (characters up to a
 * newline) from INBUF to OUTBUF.  Each line in OUTBUF is preceded by the
 * character COMMAND and a space.
 */
void
buf_copy_lines (struct buffer *outbuf, struct buffer *inbuf, int command)
{
    while (1)
    {
	struct buffer_data *data;
	struct buffer_data *nldata;
	char *nl;
	int len;

	/* See if there is a newline in INBUF.  */
	nldata = NULL;
	nl = NULL;
	for (data = inbuf->data; data != NULL; data = data->next)
	{
	    nl = memchr (data->bufp, '\n', data->size);
	    if (nl != NULL)
	    {
		nldata = data;
		break;
	    }
	}

	if (nldata == NULL)
	{
	    /* There are no more lines in INBUF.  */
	    return;
	}

	/* Put in the command.  */
	buf_append_char (outbuf, command);
	buf_append_char (outbuf, ' ');

	if (inbuf->data != nldata)
	{
	    /*
	     * Simply move over all the buffers up to the one containing
	     * the newline.
	     */
	    for (data = inbuf->data; data->next != nldata; data = data->next);
	    data->next = NULL;
	    buf_append_data (outbuf, inbuf->data, data);
	    inbuf->data = nldata;
	}

	/*
	 * If the newline is at the very end of the buffer, just move
	 * the buffer onto OUTBUF.  Otherwise we must copy the data.
	 */
	len = nl + 1 - nldata->bufp;
	if (len == nldata->size)
	{
	    inbuf->data = nldata->next;
	    if (inbuf->data == NULL)
		inbuf->last = NULL;

	    nldata->next = NULL;
	    buf_append_data (outbuf, nldata, nldata);
	}
	else
	{
	    buf_output (outbuf, nldata->bufp, len);
	    nldata->bufp += len;
	    nldata->size -= len;
	}
    }
}



/*
 * Copy counted data from one buffer to another.  The count is an
 * integer, host size, host byte order (it is only used across a
 * pipe).  If there is enough data, it should be moved over.  If there
 * is not enough data, it should remain on the original buffer.  A
 * negative count is a special case.  if one is seen, *SPECIAL is set
 * to the (negative) count value and no additional data is gathered
 * from the buffer; normally *SPECIAL is set to 0.  This function
 * returns the number of bytes it needs to see in order to actually
 * copy something over.
 */
int
buf_copy_counted (struct buffer *outbuf, struct buffer *inbuf, int *special)
{
    *special = 0;

    while (1)
    {
	struct buffer_data *data;
	int need;
	union
	{
	    char intbuf[sizeof (int)];
	    int i;
	} u;
	char *intp;
	int count;
	struct buffer_data *start;
	int startoff;
	struct buffer_data *stop;
	int stopwant;

	/* See if we have enough bytes to figure out the count.  */
	need = sizeof (int);
	intp = u.intbuf;
	for (data = inbuf->data; data != NULL; data = data->next)
	{
	    if (data->size >= need)
	    {
		memcpy (intp, data->bufp, need);
		break;
	    }
	    memcpy (intp, data->bufp, data->size);
	    intp += data->size;
	    need -= data->size;
	}
	if (data == NULL)
	{
	    /* We don't have enough bytes to form an integer.  */
	    return need;
	}

	count = u.i;
	start = data;
	startoff = need;

	if (count < 0)
	{
	    /* A negative COUNT is a special case meaning that we
               don't need any further information.  */
	    stop = start;
	    stopwant = 0;
	}
	else
	{
	    /*
	     * We have an integer in COUNT.  We have gotten all the
	     * data from INBUF in all buffers before START, and we
	     * have gotten STARTOFF bytes from START.  See if we have
	     * enough bytes remaining in INBUF.
	     */
	    need = count - (start->size - startoff);
	    if (need <= 0)
	    {
		stop = start;
		stopwant = count;
	    }
	    else
	    {
		for (data = start->next; data != NULL; data = data->next)
		{
		    if (need <= data->size)
			break;
		    need -= data->size;
		}
		if (data == NULL)
		{
		    /* We don't have enough bytes.  */
		    return need;
		}
		stop = data;
		stopwant = need;
	    }
	}

	/*
	 * We have enough bytes.  Free any buffers in INBUF before
	 * START, and remove STARTOFF bytes from START, so that we can
	 * forget about STARTOFF.
	 */
	start->bufp += startoff;
	start->size -= startoff;

	if (start->size == 0)
	    start = start->next;

	if (stop->size == stopwant)
	{
	    stop = stop->next;
	    stopwant = 0;
	}

	while (inbuf->data != start)
	{
	    data = inbuf->data;
	    inbuf->data = data->next;
	    data->next = free_buffer_data;
	    free_buffer_data = data;
	}

	/* If COUNT is negative, set *SPECIAL and get out now.  */
	if (count < 0)
	{
	    *special = count;
	    return 0;
	}

	/*
	 * We want to copy over the bytes from START through STOP.  We
	 * only want STOPWANT bytes from STOP.
	 */

	if (start != stop)
	{
	    /* Attach the buffers from START through STOP to OUTBUF.  */
	    for (data = start; data->next != stop; data = data->next);
	    inbuf->data = stop;
	    data->next = NULL;
	    buf_append_data (outbuf, start, data);
	}

	if (stopwant > 0)
	{
	    buf_output (outbuf, stop->bufp, stopwant);
	    stop->bufp += stopwant;
	    stop->size -= stopwant;
	}
    }

    /*NOTREACHED*/
}



int
buf_get_fd (struct buffer *buf)
{
    if (buf->get_fd)
	return (*buf->get_fd) (buf->closure);
    return -1;
}



/* Shut down a buffer.  This returns 0 on success, or an errno code.  */
int
buf_shutdown (struct buffer *buf)
{
    if (buf->shutdown) return (*buf->shutdown) (buf);
    return 0;
}



/* Certain types of communication input and output data in packets,
   where each packet is translated in some fashion.  The packetizing
   buffer type supports that, given a buffer which handles lower level
   I/O and a routine to translate the data in a packet.

   This code uses two bytes for the size of a packet, so packets are
   restricted to 65536 bytes in total.

   The translation functions should just translate; they may not
   significantly increase or decrease the amount of data.  The actual
   size of the initial data is part of the translated data.  The
   output translation routine may add up to PACKET_SLOP additional
   bytes, and the input translation routine should shrink the data
   correspondingly.  */

# define PACKET_SLOP (100)

/* This structure is the closure field of a packetizing buffer.  */

struct packetizing_buffer
{
    /* The underlying buffer.  */
    struct buffer *buf;
    /* The input translation function.  Exactly one of inpfn and outfn
       will be NULL.  The input translation function should
       untranslate the data in INPUT, storing the result in OUTPUT.
       SIZE is the amount of data in INPUT, and is also the size of
       OUTPUT.  This should return 0 on success, or an errno code.  */
    int (*inpfn) (void *fnclosure, const char *input, char *output,
			size_t size);
    /* The output translation function.  This should translate the
       data in INPUT, storing the result in OUTPUT.  The first two
       bytes in INPUT will be the size of the data, and so will SIZE.
       This should set *TRANSLATED to the amount of translated data in
       OUTPUT.  OUTPUT is large enough to hold SIZE + PACKET_SLOP
       bytes.  This should return 0 on success, or an errno code.  */
    int (*outfn) (void *fnclosure, const char *input, char *output,
			size_t size, size_t *translated);
    /* A closure for the translation function.  */
    void *fnclosure;
    /* For an input buffer, we may have to buffer up data here.  */
    /* This is non-zero if the buffered data has been translated.
       Otherwise, the buffered data has not been translated, and starts
       with the two byte packet size.  */
    bool translated;
    /* The amount of buffered data.  */
    size_t holdsize;
    /* The buffer allocated to hold the data.  */
    char *holdbuf;
    /* The size of holdbuf.  */
    size_t holdbufsize;
    /* If translated is set, we need another data pointer to track
       where we are in holdbuf.  If translated is clear, then this
       pointer is not used.  */
    char *holddata;
};



static int packetizing_buffer_input (void *, char *, size_t, size_t, size_t *);
static int packetizing_buffer_output (void *, const char *, size_t, size_t *);
static int packetizing_buffer_flush (void *);
static int packetizing_buffer_block (void *, bool);
static int packetizing_buffer_get_fd (void *);
static int packetizing_buffer_shutdown (struct buffer *);



/* Create a packetizing buffer.  */
struct buffer *
packetizing_buffer_initialize (struct buffer *buf,
                               int (*inpfn) (void *, const char *, char *,
                                             size_t),
                               int (*outfn) (void *, const char *, char *,
                                             size_t, size_t *),
                               void *fnclosure,
                               void (*memory) (struct buffer *))
{
    struct packetizing_buffer *pb;

    pb = xmalloc (sizeof *pb);
    memset (pb, 0, sizeof *pb);

    pb->buf = buf;
    pb->inpfn = inpfn;
    pb->outfn = outfn;
    pb->fnclosure = fnclosure;

    if (inpfn != NULL)
    {
	/* Add PACKET_SLOP to handle larger translated packets, and
           add 2 for the count.  This buffer is increased if
           necessary.  */
	pb->holdbufsize = BUFFER_DATA_SIZE + PACKET_SLOP + 2;
	pb->holdbuf = xmalloc (pb->holdbufsize);
    }

    return buf_initialize (inpfn != NULL ? packetizing_buffer_input : NULL,
			   inpfn != NULL ? NULL : packetizing_buffer_output,
			   inpfn != NULL ? NULL : packetizing_buffer_flush,
			   packetizing_buffer_block,
			   packetizing_buffer_get_fd,
			   packetizing_buffer_shutdown,
			   memory,
			   pb);
}



/* Input data from a packetizing buffer.  */
static int
packetizing_buffer_input (void *closure, char *data, size_t need, size_t size,
                          size_t *got)
{
    struct packetizing_buffer *pb = closure;

    *got = 0;

    if (pb->holdsize > 0 && pb->translated)
    {
	size_t copy;

	copy = pb->holdsize;

	if (copy > size)
	{
	    memcpy (data, pb->holddata, size);
	    pb->holdsize -= size;
	    pb->holddata += size;
	    *got = size;
	    return 0;
	}

	memcpy (data, pb->holddata, copy);
	pb->holdsize = 0;
	pb->translated = false;

	data += copy;
	need -= copy;
	size -= copy;
	*got = copy;
    }

    while (need > 0 || *got == 0)
    {
	int status;
	size_t get, nread, count, tcount;
	char *bytes;
	char stackoutbuf[BUFFER_DATA_SIZE + PACKET_SLOP];
	char *inbuf, *outbuf;

	/* If we don't already have the two byte count, get it.  */
	if (pb->holdsize < 2)
	{
	    get = 2 - pb->holdsize;
	    status = buf_read_data (pb->buf, get, &bytes, &nread);
	    if (status != 0)
	    {
		/* buf_read_data can return -2, but a buffer input
                   function is only supposed to return -1, 0, or an
                   error code.  */
		if (status == -2)
		    status = ENOMEM;
		return status;
	    }

	    if (nread == 0)
	    {
		/* The buffer is in nonblocking mode, and we didn't
                   manage to read anything.  */
		return 0;
	    }

	    if (get == 1)
		pb->holdbuf[1] = bytes[0];
	    else
	    {
		pb->holdbuf[0] = bytes[0];
		if (nread < 2)
		{
		    /* We only got one byte, but we needed two.  Stash
                       the byte we got, and try again.  */
		    pb->holdsize = 1;
		    continue;
		}
		pb->holdbuf[1] = bytes[1];
	    }
	    pb->holdsize = 2;
	}

	/* Read the packet.  */

	count = (((pb->holdbuf[0] & 0xff) << 8)
		 + (pb->holdbuf[1] & 0xff));

	if (count + 2 > pb->holdbufsize)
	{
	    char *n;

	    /* We didn't allocate enough space in the initialize
               function.  */

	    n = xrealloc (pb->holdbuf, count + 2);
	    if (n == NULL)
	    {
		(*pb->buf->memory_error) (pb->buf);
		return ENOMEM;
	    }
	    pb->holdbuf = n;
	    pb->holdbufsize = count + 2;
	}

	get = count - (pb->holdsize - 2);

	status = buf_read_data (pb->buf, get, &bytes, &nread);
	if (status != 0)
	{
	    /* buf_read_data can return -2, but a buffer input
               function is only supposed to return -1, 0, or an error
               code.  */
	    if (status == -2)
		status = ENOMEM;
	    return status;
	}

	if (nread == 0)
	{
	    /* We did not get any data.  Presumably the buffer is in
               nonblocking mode.  */
	    return 0;
	}

	if (nread < get)
	{
	    /* We did not get all the data we need to fill the packet.
               buf_read_data does not promise to return all the bytes
               requested, so we must try again.  */
	    memcpy (pb->holdbuf + pb->holdsize, bytes, nread);
	    pb->holdsize += nread;
	    continue;
	}

	/* We have a complete untranslated packet of COUNT bytes.  */

	if (pb->holdsize == 2)
	{
	    /* We just read the entire packet (the 2 bytes in
               PB->HOLDBUF are the size).  Save a memcpy by
               translating directly from BYTES.  */
	    inbuf = bytes;
	}
	else
	{
	    /* We already had a partial packet in PB->HOLDBUF.  We
               need to copy the new data over to make the input
               contiguous.  */
	    memcpy (pb->holdbuf + pb->holdsize, bytes, nread);
	    inbuf = pb->holdbuf + 2;
	}

	if (count <= sizeof stackoutbuf)
	    outbuf = stackoutbuf;
	else
	{
	    outbuf = xmalloc (count);
	    if (outbuf == NULL)
	    {
		(*pb->buf->memory_error) (pb->buf);
		return ENOMEM;
	    }
	}

	status = (*pb->inpfn) (pb->fnclosure, inbuf, outbuf, count);
	if (status != 0)
	    return status;

	/* The first two bytes in the translated buffer are the real
           length of the translated data.  */
	tcount = ((outbuf[0] & 0xff) << 8) + (outbuf[1] & 0xff);

	if (tcount > count)
	    error (1, 0, "Input translation failure");

	if (tcount > size)
	{
	    /* We have more data than the caller has provided space
               for.  We need to save some of it for the next call.  */

	    memcpy (data, outbuf + 2, size);
	    *got += size;

	    pb->holdsize = tcount - size;
	    memcpy (pb->holdbuf, outbuf + 2 + size, tcount - size);
	    pb->holddata = pb->holdbuf;
	    pb->translated = true;

	    if (outbuf != stackoutbuf)
		free (outbuf);

	    return 0;
	}

	memcpy (data, outbuf + 2, tcount);

	if (outbuf != stackoutbuf)
	    free (outbuf);

	pb->holdsize = 0;

	data += tcount;
	need -= tcount;
	size -= tcount;
	*got += tcount;
    }

    return 0;
}



/* Output data to a packetizing buffer.  */
static int
packetizing_buffer_output (void *closure, const char *data, size_t have,
                           size_t *wrote)
{
    struct packetizing_buffer *pb = closure;
    char inbuf[BUFFER_DATA_SIZE + 2];
    char stack_outbuf[BUFFER_DATA_SIZE + PACKET_SLOP + 4];
    struct buffer_data *outdata = NULL; /* Initialize to silence -Wall.  Dumb.
					 */
    char *outbuf;
    size_t size, translated;
    int status;

    /* It would be easy to xmalloc a buffer, but I don't think this
       case can ever arise.  */
    assert (have <= BUFFER_DATA_SIZE);

    inbuf[0] = (have >> 8) & 0xff;
    inbuf[1] = have & 0xff;
    memcpy (inbuf + 2, data, have);

    size = have + 2;

    /* The output function is permitted to add up to PACKET_SLOP
       bytes, and we need 2 bytes for the size of the translated data.
       If we can guarantee that the result will fit in a buffer_data,
       we translate directly into one to avoid a memcpy in buf_output.  */
    if (size + PACKET_SLOP + 2 > BUFFER_DATA_SIZE)
	outbuf = stack_outbuf;
    else
    {
	outdata = get_buffer_data ();
	if (outdata == NULL)
	{
	    (*pb->buf->memory_error) (pb->buf);
	    return ENOMEM;
	}

	outdata->next = NULL;
	outdata->bufp = outdata->text;

	outbuf = outdata->text;
    }

    status = (*pb->outfn) (pb->fnclosure, inbuf, outbuf + 2, size,
			   &translated);
    if (status != 0)
	return status;

    /* The output function is permitted to add up to PACKET_SLOP
       bytes.  */
    assert (translated <= size + PACKET_SLOP);

    outbuf[0] = (translated >> 8) & 0xff;
    outbuf[1] = translated & 0xff;

    if (outbuf == stack_outbuf)
	buf_output (pb->buf, outbuf, translated + 2);
    else
    {
	outdata->size = translated + 2;
	buf_append_data (pb->buf, outdata, outdata);
    }

    *wrote = have;

    /* We will only be here because buf_send_output was called on the
       packetizing buffer.  That means that we should now call
       buf_send_output on the underlying buffer.  */
    return buf_send_output (pb->buf);
}



/* Flush data to a packetizing buffer.  */
static int
packetizing_buffer_flush (void *closure)
{
    struct packetizing_buffer *pb = closure;

    /* Flush the underlying buffer.  Note that if the original call to
       buf_flush passed 1 for the BLOCK argument, then the buffer will
       already have been set into blocking mode, so we should always
       pass 0 here.  */
    return buf_flush (pb->buf, 0);
}



/* The block routine for a packetizing buffer.  */
static int
packetizing_buffer_block (void *closure, bool block)
{
    struct packetizing_buffer *pb = closure;

    if (block)
	return set_block (pb->buf);
    else
	return set_nonblock (pb->buf);
}



/* Return the file descriptor underlying any child buffers.  */
static int
packetizing_buffer_get_fd (void *closure)
{
    struct packetizing_buffer *cb = closure;
    return buf_get_fd (cb->buf);
}



/* Shut down a packetizing buffer.  */
static int
packetizing_buffer_shutdown (struct buffer *buf)
{
    struct packetizing_buffer *pb = buf->closure;

    return buf_shutdown (pb->buf);
}



/* All server communication goes through buffer structures.  Most of
   the buffers are built on top of a file descriptor.  This structure
   is used as the closure field in a buffer.  */

struct fd_buffer
{
    /* The file descriptor.  */
    int fd;
    /* Nonzero if the file descriptor is in blocking mode.  */
    int blocking;
    /* The child process id when fd is a pipe.  */
    pid_t child_pid;
    /* The connection info, when fd is a pipe to a server.  */
    cvsroot_t *root;
};

static int fd_buffer_input (void *, char *, size_t, size_t, size_t *);
static int fd_buffer_output (void *, const char *, size_t, size_t *);
static int fd_buffer_flush (void *);
static int fd_buffer_block (void *, bool);
static int fd_buffer_get_fd (void *);
static int fd_buffer_shutdown (struct buffer *);

/* Initialize a buffer built on a file descriptor.  FD is the file
   descriptor.  INPUT is nonzero if this is for input, zero if this is
   for output.  MEMORY is the function to call when a memory error
   occurs.  */

struct buffer *
fd_buffer_initialize (int fd, pid_t child_pid, cvsroot_t *root, bool input,
                      void (*memory) (struct buffer *))
{
    struct fd_buffer *n;

    n = xmalloc (sizeof *n);
    n->fd = fd;
    n->child_pid = child_pid;
    n->root = root;
    fd_buffer_block (n, true);
    return buf_initialize (input ? fd_buffer_input : NULL,
			   input ? NULL : fd_buffer_output,
			   input ? NULL : fd_buffer_flush,
			   fd_buffer_block, fd_buffer_get_fd,
			   fd_buffer_shutdown,
			   memory,
			   n);
}



/* The buffer input function for a buffer built on a file descriptor.
 *
 * In non-blocing mode, this function will read as many bytes as it can in a
 * single try, up to SIZE bytes, and return.
 *
 * In blocking mode with NEED > 0, this function will read as many bytes as it
 * can but will not return until it has read at least NEED bytes.
 *
 * In blocking mode with NEED == 0, this function will block until it can read
 * either at least one byte or EOF, then read as many bytes as are available
 * and return.  At the very least, compress_buffer_shutdown depends on this
 * behavior to read EOF and can loop indefinitely without it.
 *
 * ASSUMPTIONS
 *   NEED <= SIZE.
 *
 * INPUTS
 *   closure	Our FD_BUFFER struct.
 *   data	The start of our input buffer.
 *   need	How many bytes our caller needs.
 *   size	How many bytes are available in DATA.
 *   got	Where to store the number of bytes read.
 *
 * OUTPUTS
 *   data	Filled with bytes read.
 *   *got	Number of bytes actually read into DATA.
 *
 * RETURNS
 *   errno	On error.
 *   -1		On EOF.
 *   0		Otherwise.
 *
 * ERRORS
 *   This function can return an error if fd_buffer_block(), or the system
 *   read() or select() calls do.
 */
static int
fd_buffer_input (void *closure, char *data, size_t need, size_t size,
		 size_t *got)
{
    struct fd_buffer *fb = closure;
    int nbytes;

    assert (need <= size);

    *got = 0;

    if (fb->blocking)
    {
	int status;
	fd_set readfds;

	/* Set non-block.  */
        status = fd_buffer_block (fb, false);
	if (status != 0) return status;

	FD_ZERO (&readfds);
	FD_SET (fb->fd, &readfds);
	do
	{
	    int numfds;

	    do {
		/* This used to select on exceptions too, but as far
		   as I know there was never any reason to do that and
		   SCO doesn't let you select on exceptions on pipes.  */
		numfds = select (fb->fd + 1, &readfds, NULL, NULL, NULL);
		if (numfds < 0 && errno != EINTR)
		{
		    status = errno;
		    goto block_done;
		}
	    } while (numfds < 0);

	    nbytes = read (fb->fd, data + *got, size - *got);

	    if (nbytes == 0)
	    {
		/* End of file.  This assumes that we are using POSIX or BSD
		   style nonblocking I/O.  On System V we will get a zero
		   return if there is no data, even when not at EOF.  */
		if (*got)
		{
		    /* We already read some data, so return no error, counting
		     * on the fact that we will read EOF again next time.
		     */
		    status = 0;
		    break;
		}
		else
		{
		    /* Return EOF.  */
		    status = -1;
		    break;
		}
	    }

	    if (nbytes < 0)
	    {
		/* Some error occurred.  */
		if (!blocking_error (errno))
		{
		    status = errno;
		    break;
		}
		/* else Everything's fine, we just didn't get any data.  */
	    }

	    *got += nbytes;
	} while (*got < need);

block_done:
	if (status == 0 || status == -1)
	{
	    int newstatus;

	    /* OK or EOF - Reset block.  */
	    newstatus = fd_buffer_block (fb, true);
	    if (newstatus) status = newstatus;
	}
	return status;
    }

    /* The above will always return.  Handle non-blocking read.  */
    nbytes = read (fb->fd, data, size);

    if (nbytes > 0)
    {
	*got = nbytes;
	return 0;
    }

    if (nbytes == 0)
	/* End of file.  This assumes that we are using POSIX or BSD
	   style nonblocking I/O.  On System V we will get a zero
	   return if there is no data, even when not at EOF.  */
	return -1;

    /* Some error occurred.  */
    if (blocking_error (errno))
	/* Everything's fine, we just didn't get any data.  */
	return 0;

    return errno;
}



/* The buffer output function for a buffer built on a file descriptor.  */

static int
fd_buffer_output (void *closure, const char *data, size_t have, size_t *wrote)
{
    struct fd_buffer *fd = closure;

    *wrote = 0;

    while (have > 0)
    {
	int nbytes;

	nbytes = write (fd->fd, data, have);

	if (nbytes <= 0)
	{
	    if (! fd->blocking
		&& (nbytes == 0 || blocking_error (errno)))
	    {
		/* A nonblocking write failed to write any data.  Just
		   return.  */
		return 0;
	    }

	    /* Some sort of error occurred.  */

	    if (nbytes == 0)
		return EIO;

	    return errno;
	}

	*wrote += nbytes;
	data += nbytes;
	have -= nbytes;
    }

    return 0;
}



/* The buffer flush function for a buffer built on a file descriptor.  */
static int
fd_buffer_flush (void *closure)
{
    /* We don't need to do anything here.  Our fd doesn't have its own buffer
     * and syncing won't do anything but slow us down.
     *
     * struct fd_buffer *fb = closure;
     *
     * if (fsync (fb->fd) < 0 && errno != EROFS && errno != EINVAL)
     *     return errno;
     */
    return 0;
}



static struct stat devnull;
static int devnull_set = -1;

/* The buffer block function for a buffer built on a file descriptor.  */
static int
fd_buffer_block (void *closure, bool block)
{
    struct fd_buffer *fb = closure;
# if defined (F_GETFL) && defined (O_NONBLOCK) && defined (F_SETFL)
    int flags;

    flags = fcntl (fb->fd, F_GETFL, 0);
    if (flags < 0)
	return errno;

    if (block)
	flags &= ~O_NONBLOCK;
    else
	flags |= O_NONBLOCK;

    if (fcntl (fb->fd, F_SETFL, flags) < 0)
    {
	/*
	 * BSD returns ENODEV when we try to set block/nonblock on /dev/null.
	 * BSDI returns ENOTTY when we try to set block/nonblock on /dev/null.
	 */
	struct stat sb;
	int save_errno = errno;
	bool isdevnull = false;

	if (devnull_set == -1)
	    devnull_set = stat ("/dev/null", &devnull);

	if (devnull_set >= 0)
	    /* Equivalent to /dev/null ? */
	    isdevnull = (fstat (fb->fd, &sb) >= 0
			 && sb.st_dev == devnull.st_dev
			 && sb.st_ino == devnull.st_ino
			 && sb.st_mode == devnull.st_mode
			 && sb.st_uid == devnull.st_uid
			 && sb.st_gid == devnull.st_gid
			 && sb.st_size == devnull.st_size
			 && sb.st_blocks == devnull.st_blocks
			 && sb.st_blksize == devnull.st_blksize);
	if (isdevnull)
	    errno = 0;
	else
	{
	    errno = save_errno;
	    return errno;
	}
    }
# endif /* F_GETFL && O_NONBLOCK && F_SETFL */

    fb->blocking = block;

    return 0;
}



static int
fd_buffer_get_fd (void *closure)
{
    struct fd_buffer *fb = closure;
    return fb->fd;
}



/* The buffer shutdown function for a buffer built on a file descriptor.
 *
 * This function disposes of memory allocated for this buffer.
 */
static int
fd_buffer_shutdown (struct buffer *buf)
{
    struct fd_buffer *fb = buf->closure;
    struct stat s;
    bool closefd, statted;

    /* Must be an open pipe, socket, or file.  What could go wrong? */
    if (fstat (fb->fd, &s) == -1) statted = false;
    else statted = true;
    /* Don't bother to try closing the FD if we couldn't stat it.  This
     * probably won't work.
     *
     * (buf_shutdown() on some of the server/child communication pipes is
     * getting EBADF on both the fstat and the close.  I'm not sure why -
     * perhaps they were alredy closed somehow?
     */
    closefd = statted;

    /* Flush the buffer if possible.  */
    if (buf->flush)
    {
	buf_flush (buf, 1);
	buf->flush = NULL;
    }

    if (buf->input)
    {
	/* There used to be a check here for unread data in the buffer of
	 * the pipe, but it was deemed unnecessary and possibly dangerous.  In
	 * some sense it could be second-guessing the caller who requested it
	 * closed, as well.
	 */

/* FIXME:
 *
 * This mess of #ifdefs is hard to read.  There must be some relation between
 * the macros being checked which at least deserves comments - if
 * SHUTDOWN_SERVER, NO_SOCKET_TO_FD, & START_RSH_WITH_POPEN_RW were completely
 * independant, then the next few lines could easily refuse to compile.
 *
 * The note below about START_RSH_WITH_POPEN_RW never being set when
 * SHUTDOWN_SERVER is defined means that this code would always break on
 * systems with SHUTDOWN_SERVER defined and thus the comment must now be
 * incorrect or the code was broken since the comment was written.
 */
# ifdef SHUTDOWN_SERVER
	if (fb->root && fb->root->method != server_method)
# endif
# ifndef NO_SOCKET_TO_FD
	{
	    /* shutdown() sockets */
	    if (statted && S_ISSOCK (s.st_mode))
		shutdown (fb->fd, 0);
	}
# endif /* NO_SOCKET_TO_FD */
# ifdef START_RSH_WITH_POPEN_RW
/* Can't be set with SHUTDOWN_SERVER defined */
	/* FIXME: This is now certainly broken since pclose is defined by ANSI
	 * C to accept a FILE * argument.  The switch will need to happen at a
	 * higher abstraction level to switch between initializing stdio & fd
	 * buffers on systems that need this (or maybe an fd buffer that keeps
	 * track of the FILE * could be used - I think flushing the stream
	 * before beginning exclusive access via the FD is OK.
	 */
	else if (fb->root && pclose (fb->fd) == EOF)
	{
	    error (1, errno, "closing connection to %s",
		   fb->root->hostname);
	    closefd = false;
	}
# endif /* START_RSH_WITH_POPEN_RW */

	buf->input = NULL;
    }
    else if (buf->output)
    {
# ifdef SHUTDOWN_SERVER
	/* FIXME:  Should have a SHUTDOWN_SERVER_INPUT &
	 * SHUTDOWN_SERVER_OUTPUT
	 */
	if (fb->root && fb->root->method == server_method)
	    SHUTDOWN_SERVER (fb->fd);
	else
# endif
# ifndef NO_SOCKET_TO_FD
	/* shutdown() sockets */
	if (statted && S_ISSOCK (s.st_mode))
	    shutdown (fb->fd, 1);
# else
	{
	/* I'm not sure I like this empty block, but the alternative
	 * is another nested NO_SOCKET_TO_FD switch as above.
	 */
	}
# endif /* NO_SOCKET_TO_FD */

	buf->output = NULL;
    }

    if (statted && closefd && close (fb->fd) == -1)
    {
	if (0
# ifdef SERVER_SUPPORT
	    || server_active
# endif /* SERVER_SUPPORT */
           )
	{
            /* Syslog this? */
	}
# ifdef CLIENT_SUPPORT
	else if (fb->root)
            error (1, errno, "closing down connection to %s",
                   fb->root->hostname);
	    /* EXITS */
# endif /* CLIENT_SUPPORT */

	error (0, errno, "closing down buffer");
    }

    /* If we were talking to a process, make sure it exited */
    if (fb->child_pid)
    {
	int w;

	do
	    w = waitpid (fb->child_pid, (int *) 0, 0);
	while (w == -1 && errno == EINTR);
	if (w == -1)
	    error (1, errno, "waiting for process %d", fb->child_pid);
    }

    free (buf->closure);
    buf->closure = NULL;

    return 0;
}
#endif /* defined (SERVER_SUPPORT) || defined (CLIENT_SUPPORT) */
@


1.4
log
@update to cvs 1.12.10-MirOS except automatically
generated files
XXX this installs as /usr/bin/ncvs yet, so no
XXX conflicts during the test phase.
XXX I suggest to _not_ update.

XXX *** IMPORTANT *** DO NOT ACCESS CVS 1.11 REPOSITORIES
XXX *** IMPORTANT *** WITH CVS 1.12 OR VICE VERSA!
@
text
@d170 1
a170 1
# ifdef SERVER_FLOWCONTROL
d186 1
a186 1
# endif /* SERVER_FLOWCONTROL */
d509 1
a509 1
#ifdef PROXY_SUPPORT
d556 1
a556 1
#endif /* PROXY_SUPPORT */
d1991 3
d1999 1
a1999 1
#if defined (F_GETFL) && defined (O_NONBLOCK) && defined (F_SETFL)
d2011 5
a2015 2
    if (fcntl (fb->fd, F_SETFL, flags) < 0 && errno != ENODEV)
	/* BSD returns ENODEV when we try to set block/nonblock on /dev/null.
d2017 27
a2043 2
	return errno;
#endif /* F_GETFL && O_NONBLOCK && F_SETFL */
@


1.3
log
@cvs-1.11.12 doesn't do the joints correctly (what were the
FSF people smoking?), it memory faults.
thusly revert to 1.11.1p1

tested.
agreed bsiegert@@
@
text
@a2 1
#include <assert.h>
d8 6
d16 3
a18 3
#if !defined (EIO)
#define EIO EBADPOS
#endif
d24 5
a28 3
static void buf_default_memory_error PROTO ((struct buffer *));
static void allocate_buffer_datas PROTO((void));
static struct buffer_data *get_buffer_data PROTO((void));
a30 1

d32 8
a39 8
buf_initialize (input, output, flush, block, shutdown, memory, closure)
     int (*input) PROTO((void *, char *, int, int, int *));
     int (*output) PROTO((void *, const char *, int, int *));
     int (*flush) PROTO((void *));
     int (*block) PROTO((void *, int));
     int (*shutdown) PROTO((void *));
     void (*memory) PROTO((struct buffer *));
     void *closure;
d43 1
a43 1
    buf = (struct buffer *) xmalloc (sizeof (struct buffer));
d46 1
a46 1
    buf->nonblocking = 0;
d51 1
d58 2
a60 1

d62 1
a62 2
buf_free (buf)
     struct buffer *buf;
d64 5
d77 2
a79 1

d81 1
a81 2
buf_nonio_initialize (memory)
     void (*memory) PROTO((struct buffer *));
d83 1
a83 8
    return (buf_initialize
	    ((int (*) PROTO((void *, char *, int, int, int *))) NULL,
	     (int (*) PROTO((void *, const char *, int, int *))) NULL,
	     (int (*) PROTO((void *))) NULL,
	     (int (*) PROTO((void *, int))) NULL,
	     (int (*) PROTO((void *))) NULL,
	     memory,
	     (void *) NULL));
d86 2
a88 1

d90 1
a90 2
buf_default_memory_error (buf)
     struct buffer *buf;
d95 2
a97 1

d99 1
a99 1
allocate_buffer_datas ()
d106 1
a106 1
#define ALLOC_COUNT (16)
d108 2
a109 3
    alc = ((struct buffer_data *)
	   malloc (ALLOC_COUNT * sizeof (struct buffer_data)));
    space = (char *) valloc (ALLOC_COUNT * BUFFER_DATA_SIZE);
d120 2
a122 1

d124 1
a124 1
get_buffer_data ()
a139 1
/* See whether a buffer is empty.  */
d141 2
d144 1
a144 1
buf_empty_p (buf)
d147 13
d168 3
a170 1
#ifdef SERVER_FLOWCONTROL
d173 1
a173 1
 * Note that each buffer is a malloc'ed chunk BUFFER_DATA_SIZE.
a174 1

d176 1
a176 2
buf_count_mem (buf)
    struct buffer *buf;
d186 3
a188 1
#endif /* SERVER_FLOWCONTROL */
a190 1

d192 1
a192 4
buf_output (buf, data, len)
    struct buffer *buf;
    const char *data;
    int len;
d241 2
a243 1

d245 1
a245 3
buf_output0 (buf, string)
    struct buffer *buf;
    const char *string;
d250 2
a252 1

d254 1
a254 3
buf_append_char (buf, ch)
    struct buffer *buf;
    int ch;
d272 2
a278 1

d280 1
a280 2
buf_send_output (buf)
     struct buffer *buf;
d282 1
a282 2
    if (buf->output == NULL)
	abort ();
d292 2
a293 1
	    int status, nbytes;
d334 2
a341 1

d343 1
a343 3
buf_flush (buf, block)
     struct buffer *buf;
     int block;
d348 1
a348 2
    if (buf->flush == NULL)
        abort ();
d374 2
a379 1

d381 1
a381 2
set_nonblock (buf)
     struct buffer *buf;
d387 1
a387 2
    if (buf->block == NULL)
        abort ();
d391 1
a391 1
    buf->nonblocking = 1;
d395 2
a400 1

d402 1
a402 2
set_block (buf)
     struct buffer *buf;
d408 1
a408 2
    if (buf->block == NULL)
        abort ();
d412 1
a412 1
    buf->nonblocking = 0;
d416 2
a424 1

d426 1
a426 2
buf_send_counted (buf)
     struct buffer *buf;
d455 2
d459 1
a459 1
 * handled speciallyi by buf_copy_counted.  This function returns 0 or
a464 1

d466 1
a466 3
buf_send_special_count (buf, count)
     struct buffer *buf;
     int count;
d490 2
a492 1

d494 2
a495 4
buf_append_data (buf, data, last)
     struct buffer *buf;
     struct buffer_data *data;
     struct buffer_data *last;
a506 2
/* Append the data on one buffer to another.  This removes the data
   from the source buffer.  */
d508 7
d516 2
a517 3
buf_append_buffer (to, from)
     struct buffer *to;
     struct buffer *from;
d519 50
d570 9
d583 2
d588 1
a588 1
 * succeess differently.  Returns 0 on success, or -2 if out of
a593 1

d595 2
a596 5
buf_read_file (f, size, retp, lastp)
    FILE *f;
    long size;
    struct buffer_data **retp;
    struct buffer_data **lastp;
d652 2
d657 1
a657 1
 * succeess differently.  Returns 0 on success, or -2 if out of
a660 1

d662 2
a663 4
buf_read_file_to_eof (f, retp, lastp)
     FILE *f;
     struct buffer_data **retp;
     struct buffer_data **lastp;
d716 2
a718 1

d720 1
a720 2
buf_chain_length (buf)
     struct buffer_data *buf;
d731 2
a733 1

d735 1
a735 2
buf_length (buf)
    struct buffer *buf;
d740 2
a748 1

d750 1
a750 3
buf_input_data (buf, countp)
     struct buffer *buf;
     int *countp;
d752 1
a752 2
    if (buf->input == NULL)
	abort ();
d759 2
a760 2
	int get;
	int status, nbytes;
d810 2
d822 7
d830 2
d833 2
a834 4
buf_read_line (buf, line, lenp)
     struct buffer *buf;
     char **line;
     int *lenp;
d836 1
a836 2
    if (buf->input == NULL)
        abort ();
d842 1
a842 1
	int len, finallen = 0;
d854 1
d858 1
d869 1
a869 1
	    p = malloc (len + 1);
d901 2
a902 1
	/* Read more data until we get a newline.  */
d905 2
a906 1
	    int size, status, nbytes;
d942 1
d945 1
a945 2
	    /* Optimize slightly to avoid an unnecessary call to
               memchr.  */
d956 1
d961 2
a971 1

d973 1
a973 5
buf_read_data (buf, want, retdata, got)
     struct buffer *buf;
     int want;
     char **retdata;
     int *got;
d975 1
a975 2
    if (buf->input == NULL)
	abort ();
d992 2
a993 1
	int get, status, nbytes;
d1036 2
d1039 4
a1042 4
 * Copy lines from an input buffer to an output buffer.  This copies
 * all complete lines (characters up to a newline) from INBUF to
 * OUTBUF.  Each line in OUTBUF is preceded by the character COMMAND
 * and a space.
a1043 1

d1045 1
a1045 4
buf_copy_lines (outbuf, inbuf, command)
     struct buffer *outbuf;
     struct buffer *inbuf;
     int command;
d1083 1
a1083 2
	    for (data = inbuf->data; data->next != nldata; data = data->next)
		;
d1112 2
a1124 1

d1126 1
a1126 4
buf_copy_counted (outbuf, inbuf, special)
     struct buffer *outbuf;
     struct buffer *inbuf;
     int *special;
d1249 1
a1249 2
	    for (data = start; data->next != stop; data = data->next)
		;
d1266 1
a1266 1
/* Shut down a buffer.  This returns 0 on success, or an errno code.  */
d1269 1
a1269 2
buf_shutdown (buf)
     struct buffer *buf;
d1271 3
a1273 3
    if (buf->shutdown)
	return (*buf->shutdown) (buf->closure);
    return 0;
a1275 8
/* The simplest type of buffer is one built on top of a stdio FILE.
   For simplicity, and because it is all that is required, we do not
   implement setting this type of buffer into nonblocking mode.  The
   closure field is just a FILE *.  */

static int stdio_buffer_input PROTO((void *, char *, int, int, int *));
static int stdio_buffer_output PROTO((void *, const char *, int, int *));
static int stdio_buffer_flush PROTO((void *));
a1276 1
/* Initialize a buffer built on a stdio FILE.  */
d1278 3
a1280 78
struct buffer *
stdio_buffer_initialize (fp, input, memory)
     FILE *fp;
     int input;
     void (*memory) PROTO((struct buffer *));
{
    return buf_initialize (input ? stdio_buffer_input : NULL,
			   input ? NULL : stdio_buffer_output,
			   input ? NULL : stdio_buffer_flush,
			   (int (*) PROTO((void *, int))) NULL,
			   (int (*) PROTO((void *))) NULL,
			   memory,
			   (void *) fp);
}

/* The buffer input function for a buffer built on a stdio FILE.  */

static int
stdio_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
     int size;
     int *got;
{
    FILE *fp = (FILE *) closure;
    int nbytes;

    /* Since stdio does its own buffering, we don't worry about
       getting more bytes than we need.  */

    if (need == 0 || need == 1)
    {
        int ch;

	ch = getc (fp);

	if (ch == EOF)
	{
	    if (feof (fp))
		return -1;
	    else if (errno == 0)
		return EIO;
	    else
		return errno;
	}

	*data = ch;
	*got = 1;
	return 0;
    }

    nbytes = fread (data, 1, need, fp);

    if (nbytes == 0)
    {
	*got = 0;
	if (feof (fp))
	    return -1;
	else if (errno == 0)
	    return EIO;
	else
	    return errno;
    }

    *got = nbytes;

    return 0;
}

/* The buffer output function for a buffer built on a stdio FILE.  */

static int
stdio_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
d1282 1
a1282 23
    FILE *fp = (FILE *) closure;

    *wrote = 0;

    while (have > 0)
    {
	int nbytes;

	nbytes = fwrite (data, 1, have, fp);

	if (nbytes != have)
	{
	    if (errno == 0)
		return EIO;
	    else
		return errno;
	}

	*wrote += nbytes;
	have -= nbytes;
	data += nbytes;
    }

a1285 7
/* The buffer flush function for a buffer built on a stdio FILE.  */

static int
stdio_buffer_flush (closure)
     void *closure;
{
    FILE *fp = (FILE *) closure;
a1286 10
    if (fflush (fp) != 0)
    {
	if (errno == 0)
	    return EIO;
	else
	    return errno;
    }

    return 0;
}
d1303 1
a1303 1
#define PACKET_SLOP (100)
d1316 2
a1317 2
    int (*inpfn) PROTO((void *fnclosure, const char *input, char *output,
			int size));
d1324 2
a1325 2
    int (*outfn) PROTO((void *fnclosure, const char *input, char *output,
			int size, int *translated));
d1332 1
a1332 1
    int translated;
d1334 1
a1334 1
    int holdsize;
d1338 1
a1338 1
    int holdbufsize;
d1345 10
a1354 5
static int packetizing_buffer_input PROTO((void *, char *, int, int, int *));
static int packetizing_buffer_output PROTO((void *, const char *, int, int *));
static int packetizing_buffer_flush PROTO((void *));
static int packetizing_buffer_block PROTO((void *, int));
static int packetizing_buffer_shutdown PROTO((void *));
a1356 1

d1358 7
a1364 6
packetizing_buffer_initialize (buf, inpfn, outfn, fnclosure, memory)
     struct buffer *buf;
     int (*inpfn) PROTO ((void *, const char *, char *, int));
     int (*outfn) PROTO ((void *, const char *, char *, int, int *));
     void *fnclosure;
     void (*memory) PROTO((struct buffer *));
d1368 1
a1368 1
    pb = (struct packetizing_buffer *) xmalloc (sizeof *pb);
d1389 1
d1395 2
a1397 1

d1399 2
a1400 6
packetizing_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
     int size;
     int *got;
d1402 1
a1402 1
    struct packetizing_buffer *pb = (struct packetizing_buffer *) closure;
d1408 1
a1408 1
	int copy;
d1423 1
a1423 1
	pb->translated = 0;
d1433 2
a1434 1
	int get, status, nread, count, tcount;
d1490 1
a1490 1
	    n = realloc (pb->holdbuf, count + 2);
d1552 1
a1552 1
	    outbuf = malloc (count);
d1582 1
a1582 1
	    pb->translated = 1;
d1606 2
a1608 1

d1610 2
a1611 5
packetizing_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
d1613 1
a1613 1
    struct packetizing_buffer *pb = (struct packetizing_buffer *) closure;
d1616 2
a1617 1
    struct buffer_data *outdata;
d1619 2
a1620 1
    int size, status, translated;
d1622 3
a1624 6
    if (have > BUFFER_DATA_SIZE)
    {
	/* It would be easy to malloc a buffer, but I don't think this
           case can ever arise.  */
	abort ();
    }
d1660 1
a1660 2
    if (translated > size + PACKET_SLOP)
	abort ();
d1681 2
a1683 1

d1685 1
a1685 2
packetizing_buffer_flush (closure)
     void *closure;
d1687 1
a1687 1
    struct packetizing_buffer *pb = (struct packetizing_buffer *) closure;
d1696 2
a1698 1

d1700 1
a1700 3
packetizing_buffer_block (closure, block)
     void *closure;
     int block;
d1702 1
a1702 1
    struct packetizing_buffer *pb = (struct packetizing_buffer *) closure;
d1710 12
d1723 58
d1782 37
d1820 2
a1821 2
packetizing_buffer_shutdown (closure)
     void *closure;
d1823 11
a1833 1
    struct packetizing_buffer *pb = (struct packetizing_buffer *) closure;
d1835 191
a2025 1
    return buf_shutdown (pb->buf);
d2028 143
@


1.2
log
@first step of merging new cvs
XXX might not compile
XXX might not work
XXX might contain bugs
XXX definitively needs autoconf 2.58 first
@
text
@a8 6
#ifdef HAVE_WINSOCK_H
# include <winsock.h>
#else
# include <sys/socket.h>
#endif

d31 1
a31 1
     int (*shutdown) PROTO((struct buffer *));
d76 1
a76 1
	     (int (*) PROTO((struct buffer *))) NULL,
d103 1
a103 1
	   xmalloc (ALLOC_COUNT * sizeof (struct buffer_data)));
d151 1
a151 1
 * Note that each buffer is a xmalloc'ed chunk BUFFER_DATA_SIZE.
d791 1
a791 1
	    p = xmalloc (len + 1);
d1201 1
a1201 1
	return (*buf->shutdown) (buf);
a1212 1
static int stdio_buffer_shutdown PROTO((struct buffer *buf));
a1215 6
struct stdio_buffer_closure
{
    FILE *fp;
    int child_pid;
};

d1217 1
a1217 1
stdio_buffer_initialize (fp, child_pid, input, memory)
a1218 1
     int child_pid;
a1221 5
    struct stdio_buffer_closure *bc = xmalloc (sizeof (*bc));

    bc->fp = fp;
    bc->child_pid = child_pid;

d1226 1
a1226 1
			   stdio_buffer_shutdown,
d1228 1
a1228 15
			   (void *) bc);
}

/* Return the file associated with a stdio buffer. */
FILE *
stdio_buffer_get_file (buf)
    struct buffer *buf;
{
    struct stdio_buffer_closure *bc;

    assert(buf->shutdown == stdio_buffer_shutdown);

    bc = (struct stdio_buffer_closure *) buf->closure;

    return(bc->fp);
d1241 1
a1241 1
    struct stdio_buffer_closure *bc = (struct stdio_buffer_closure *) closure;
d1251 1
a1251 1
	ch = getc (bc->fp);
d1255 1
a1255 1
	    if (feof (bc->fp))
d1268 1
a1268 1
    nbytes = fread (data, 1, need, bc->fp);
d1273 1
a1273 1
	if (feof (bc->fp))
d1295 1
a1295 1
    struct stdio_buffer_closure *bc = (struct stdio_buffer_closure *) closure;
d1303 1
a1303 1
	nbytes = fwrite (data, 1, have, bc->fp);
d1327 1
a1327 1
    struct stdio_buffer_closure *bc = (struct stdio_buffer_closure *) closure;
d1329 1
a1329 1
    if (fflush (bc->fp) != 0)
a1339 115


static int
stdio_buffer_shutdown (buf)
    struct buffer *buf;
{
    struct stdio_buffer_closure *bc = (struct stdio_buffer_closure *) buf->closure;
    struct stat s;
    int closefp = 1;

    /* Must be a pipe or a socket.  What could go wrong? */
    assert (fstat ( fileno (bc->fp), &s ) != -1);

    /* Flush the buffer if we can */
    if (buf->flush)
    {
	buf_flush (buf, 1);
	buf->flush = NULL;
    }

    if (buf->input)
    {
	if ( !buf_empty_p (buf) )
	{
# ifdef SERVER_SUPPORT
	    if (server_active)
		/* FIXME: This should probably be sysloged since it doesn't
		 * have anywhere else to go at this point.
		 */
		error (0, 0, "dying gasps from client unexpected");
	    else
#endif
		error (0, 0, "dying gasps from %s unexpected", current_parsed_root->hostname);
	}
	else if (ferror (bc->fp))
	{
# ifdef SERVER_SUPPORT
	    if (server_active)
		/* FIXME: This should probably be sysloged since it doesn't
		 * have anywhere else to go at this point.
		 */
		error (0, errno, "reading from client");
	    else
#endif
		error (0, errno, "reading from %s", current_parsed_root->hostname);
	}

# ifdef SHUTDOWN_SERVER
	if (current_parsed_root->method != server_method)
# endif
# ifndef NO_SOCKET_TO_FD
	{
	    /* shutdown() sockets */
	    if (S_ISSOCK(s.st_mode))
		shutdown ( fileno (bc->fp), 0);
	}
# endif /* NO_SOCKET_TO_FD */
# ifdef START_RSH_WITH_POPEN_RW
	/* Can't be set with SHUTDOWN_SERVER defined */
	else if (pclose (bc->fp) == EOF)
	{
	    error (1, errno, "closing connection to %s",
		   current_parsed_root->hostname);
	    closefp = 0;
	}
# endif /* START_RSH_WITH_POPEN_RW */

	buf->input = NULL;
    }
    else if (buf->output)
    {
# ifdef SHUTDOWN_SERVER
	/* FIXME:  Should have a SHUTDOWN_SERVER_INPUT &
	 * SHUTDOWN_SERVER_OUTPUT
	 */
	if (current_parsed_root->method == server_method)
	    SHUTDOWN_SERVER ( fileno (bc->fp) );
	else
# endif
# ifndef NO_SOCKET_TO_FD
	/* shutdown() sockets */
	if (S_ISSOCK(s.st_mode))
	    shutdown ( fileno (bc->fp), 1);
# else
	{
	/* I'm not sure I like this empty block, but the alternative
	 * is a another nested NO_SOCKET_TO_FD switch above.
	 */
	}
# endif /* NO_SOCKET_TO_FD */

	buf->output = NULL;
    }

    if (closefp && fclose (bc->fp) == EOF)
	error (1, errno,
	       "closing down connection to %s",
	       current_parsed_root->hostname);

    /* If we were talking to a process, make sure it exited */
    if (bc->child_pid)
    {
	int w;

	do
	    w = waitpid (bc->child_pid, (int *) 0, 0);
	while (w == -1 && errno == EINTR);
	if (w == -1)
	    error (1, errno, "waiting for process %d", bc->child_pid);
    }
    return 0;
}



d1401 1
a1401 1
static int packetizing_buffer_shutdown PROTO((struct buffer *));
d1538 1
a1538 1
	    n = xrealloc (pb->holdbuf, count + 2);
d1600 1
a1600 1
	    outbuf = xmalloc (count);
d1672 1
a1672 1
	/* It would be easy to xmalloc a buffer, but I don't think this
d1766 2
a1767 2
packetizing_buffer_shutdown (buf)
    struct buffer *buf;
d1769 1
a1769 1
    struct packetizing_buffer *pb = (struct packetizing_buffer *) buf->closure;
@


1.1
log
@Initial revision
@
text
@d9 6
d37 1
a37 1
     int (*shutdown) PROTO((void *));
d82 1
a82 1
	     (int (*) PROTO((void *))) NULL,
d109 1
a109 1
	   malloc (ALLOC_COUNT * sizeof (struct buffer_data)));
d157 1
a157 1
 * Note that each buffer is a malloc'ed chunk BUFFER_DATA_SIZE.
d797 1
a797 1
	    p = malloc (len + 1);
d1207 1
a1207 1
	return (*buf->shutdown) (buf->closure);
d1219 1
d1223 6
d1230 1
a1230 1
stdio_buffer_initialize (fp, input, memory)
d1232 1
d1236 5
d1245 1
a1245 1
			   (int (*) PROTO((void *))) NULL,
d1247 15
a1261 1
			   (void *) fp);
d1274 1
a1274 1
    FILE *fp = (FILE *) closure;
d1284 1
a1284 1
	ch = getc (fp);
d1288 1
a1288 1
	    if (feof (fp))
d1301 1
a1301 1
    nbytes = fread (data, 1, need, fp);
d1306 1
a1306 1
	if (feof (fp))
d1328 1
a1328 1
    FILE *fp = (FILE *) closure;
d1336 1
a1336 1
	nbytes = fwrite (data, 1, have, fp);
d1360 1
a1360 1
    FILE *fp = (FILE *) closure;
d1362 1
a1362 1
    if (fflush (fp) != 0)
d1373 115
d1549 1
a1549 1
static int packetizing_buffer_shutdown PROTO((void *));
d1686 1
a1686 1
	    n = realloc (pb->holdbuf, count + 2);
d1748 1
a1748 1
	    outbuf = malloc (count);
d1820 1
a1820 1
	/* It would be easy to malloc a buffer, but I don't think this
d1914 2
a1915 2
packetizing_buffer_shutdown (closure)
     void *closure;
d1917 1
a1917 1
    struct packetizing_buffer *pb = (struct packetizing_buffer *) closure;
@


1.1.2.1
log
@vendor-branch-ify new cvs 1.12
@
text
@d3 1
a8 6
# ifdef HAVE_WINSOCK_H
#   include <winsock.h>
# else
#  include <sys/socket.h>
# endif

d11 3
a13 3
# if !defined( EIO )
#   define EIO EBADPOS
# endif
d19 3
a21 3
static void buf_default_memory_error (struct buffer *);
static void allocate_buffer_datas (void);
static struct buffer_data *get_buffer_data (void);
d23 1
a24 2

/* Initialize a buffer structure.  */
d26 8
a33 8
buf_initialize (int (*input) (void *, char *, size_t, size_t, size_t *),
	        int (*output) (void *, const char *, size_t, size_t *),
                int (*flush) (void *),
                int (*block) (void *, bool),
                int (*get_fd) (void *),
                int (*shutdown) (struct buffer *),
                void (*memory) (struct buffer *),
                void *closure)
d37 1
a37 1
    buf = xmalloc (sizeof (struct buffer));
d40 1
a40 1
    buf->nonblocking = false;
a44 1
    buf->get_fd = get_fd;
d51 1
a52 2

/* Free a buffer structure.  */
d54 2
a55 1
buf_free (struct buffer *buf)
a56 5
    if (buf->closure != NULL)
    {
	free (buf->closure);
	buf->closure = NULL;
    }
d65 1
a66 2

/* Initialize a buffer structure which is not to be used for I/O.  */
d68 2
a69 1
buf_nonio_initialize( void (*memory) (struct buffer *) )
d71 8
a78 1
    return buf_initialize (NULL, NULL, NULL, NULL, NULL, NULL, memory, NULL);
d81 1
a82 2

/* Default memory error handler.  */
d84 2
a85 1
buf_default_memory_error (struct buffer *buf)
d90 1
a91 2

/* Allocate more buffer_data structures.  */
d93 1
a93 1
allocate_buffer_datas (void)
d100 1
a100 1
# define ALLOC_COUNT (16)
d102 3
a104 2
    alc = xmalloc (ALLOC_COUNT * sizeof (struct buffer_data));
    space = valloc (ALLOC_COUNT * BUFFER_DATA_SIZE);
d115 1
a116 2

/* Get a new buffer_data structure.  */
d118 1
a118 1
get_buffer_data (void)
d134 1
a135 2

/* See whether a buffer and its file descriptor is empty.  */
d137 1
a137 1
buf_empty (buf)
a139 13
	/* Try and read any data on the file descriptor first.
	 * We already know the descriptor is non-blocking.
	 */
	buf_input_data (buf, NULL);
	return buf_empty_p (buf);
}



/* See whether a buffer is empty.  */
int
buf_empty_p (struct buffer *buf)
{
d148 1
a148 3


# ifdef SERVER_FLOWCONTROL
d151 1
a151 1
 * Note that each buffer is a xmalloc'ed chunk BUFFER_DATA_SIZE.
d153 1
d155 2
a156 1
buf_count_mem (struct buffer *buf)
d166 1
a166 2
# endif /* SERVER_FLOWCONTROL */

d168 1
a169 1
/* Add data DATA of length LEN to BUF.  */
d171 4
a174 1
buf_output (struct buffer *buf, const char *data, size_t len)
d223 1
a224 2

/* Add a '\0' terminated string to BUF.  */
d226 3
a228 1
buf_output0 (struct buffer *buf, const char *string)
d233 1
a234 2

/* Add a single character to BUF.  */
d236 3
a238 1
buf_append_char (struct buffer *buf, int ch)
a255 2


d261 1
d263 2
a264 1
buf_send_output (struct buffer *buf)
d266 2
a267 1
    assert (buf->output != NULL);
d277 1
a277 2
	    int status;
	    size_t nbytes;
a317 2


d324 1
d326 3
a328 1
buf_flush (struct buffer *buf, bool block)
d333 2
a334 1
    assert (buf->flush != NULL);
a359 2


d364 1
d366 2
a367 1
set_nonblock (struct buffer *buf)
d373 2
a374 1
    assert (buf->block != NULL);
d378 1
a378 1
    buf->nonblocking = true;
a381 2


d386 1
d388 2
a389 1
set_block (struct buffer *buf)
d395 2
a396 1
    assert (buf->block != NULL);
d400 1
a400 1
    buf->nonblocking = false;
a403 2


d411 1
d413 2
a414 1
buf_send_counted (struct buffer *buf)
a442 2


d445 1
a445 1
 * handled specially by buf_copy_counted.  This function returns 0 or
d451 1
d453 3
a455 1
buf_send_special_count (struct buffer *buf, int count)
d479 1
a480 2

/* Append a list of buffer_data structures to an buffer.  */
d482 4
a485 2
buf_append_data (struct buffer *buf, struct buffer_data *data,
                 struct buffer_data *last)
d497 2
a499 7

#ifdef PROXY_SUPPORT
/* Copy data structures and append them to a buffer.
 *
 * ERRORS
 *   Failure to allocate memory here is fatal.
 */
d501 3
a503 2
buf_copy_data (struct buffer *buf, struct buffer_data *data,
               struct buffer_data *last)
a504 50
    struct buffer_data *first, *new, *cur, *prev;

    assert (buf);
    assert (data);

    prev = first = NULL;
    cur = data;
    while (1)
    {
	new = get_buffer_data ();
	if (!new) error (1, errno, "Failed to allocate buffer data.");

	if (!first) first = new;
	memcpy (new->text, cur->bufp, cur->size);
	new->bufp = new->text;
	new->size = cur->size;
	new->next = NULL;
	if (prev) prev->next = new;
	if (cur == last) break;
	prev = new;
	cur = cur->next;
    }

    buf_append_data (buf, first, new);
}



/* Dispose of any remaining data in the buffer.  */
void
buf_free_data (struct buffer *buffer)
{
    if (buf_empty_p (buffer)) return;
    buffer->last->next = free_buffer_data;
    free_buffer_data = buffer->data;
    buffer->data = buffer->last = NULL;
}
#endif /* PROXY_SUPPORT */



/* Append the data in one buffer to another.  This removes the data
 * from the source buffer.
 */
void
buf_append_buffer (struct buffer *to, struct buffer *from)
{
    struct buffer_data *n;

    /* Copy the data pointer to the new buf.  */
a505 9

    n = from->data;
    while (n)
    {
	if (n == from->last) break;
	n = n->next;
    }

    /* Remove from the original location.  */
a509 2


d513 1
a513 1
 * success differently.  Returns 0 on success, or -2 if out of
d519 1
d521 5
a525 2
buf_read_file (FILE *f, long int size, struct buffer_data **retp,
               struct buffer_data **lastp)
a580 2


d584 1
a584 1
 * success differently.  Returns 0 on success, or -2 if out of
d588 1
d590 4
a593 2
buf_read_file_to_eof (FILE *f, struct buffer_data **retp,
                      struct buffer_data **lastp)
d646 1
a647 2

/* Return the number of bytes in a chain of buffer_data structures.  */
d649 2
a650 1
buf_chain_length (struct buffer_data *buf)
d661 1
a662 2

/* Return the number of bytes in a buffer.  */
d664 2
a665 1
buf_length (struct buffer *buf)
a669 2


d677 1
d679 3
a681 1
buf_input_data (struct buffer *buf, size_t *countp)
d683 2
a684 1
    assert (buf->input != NULL);
d691 2
a692 2
	int status;
	size_t get, nbytes;
a741 2


a751 7
int
buf_read_line (struct buffer *buf, char **line, size_t *lenp)
{
    return buf_read_short_line (buf, line, lenp, SIZE_MAX);
}


a752 2
/* Like buf_read_line, but return -2 if no newline is found in MAX characters.
 */
d754 4
a757 2
buf_read_short_line (struct buffer *buf, char **line, size_t *lenp,
                     size_t max)
d759 2
a760 1
    assert (buf->input != NULL);
d766 1
a766 1
	size_t len, finallen, predicted_len;
a777 1
		if (xsum (len, finallen) >= max) return -2;
a780 1
	    else if (xsum (len, data->size) >= max) return -2;
d791 1
a791 1
	    p = xmalloc (len + 1);
d823 1
a823 2
	/* Read more data until we get a newline or MAX characters.  */
	predicted_len = 0;
d826 1
a826 2
	    int status;
	    size_t size, nbytes;
a861 1
	    predicted_len += nbytes;
d864 2
a865 1
	    /* Optimize slightly to avoid an unnecessary call to memchr.  */
a875 1
	    if (xsum (len, predicted_len) >= max) return -2;
a879 2


d889 1
d891 5
a895 1
buf_read_data (struct buffer *buf, size_t want, char **retdata, size_t *got)
d897 2
a898 1
    assert (buf->input != NULL);
d915 1
a915 2
	int status;
	size_t get, nbytes;
a957 2


d959 4
a962 4
 * Copy lines from an input buffer to an output buffer.
 * This copies all complete lines (characters up to a
 * newline) from INBUF to OUTBUF.  Each line in OUTBUF is preceded by the
 * character COMMAND and a space.
d964 1
d966 4
a969 1
buf_copy_lines (struct buffer *outbuf, struct buffer *inbuf, int command)
d1007 2
a1008 1
	    for (data = inbuf->data; data->next != nldata; data = data->next);
a1036 2


d1048 1
d1050 4
a1053 1
buf_copy_counted (struct buffer *outbuf, struct buffer *inbuf, int *special)
d1176 2
a1177 1
	    for (data = start; data->next != stop; data = data->next);
d1194 1
a1194 1

d1197 2
a1198 1
buf_get_fd (struct buffer *buf)
d1200 29
a1228 3
    if (buf->get_fd)
	return (*buf->get_fd) (buf->closure);
    return -1;
d1231 21
d1253 14
d1268 26
a1293 3
/* Shut down a buffer.  This returns 0 on success, or an errno code.  */
int
buf_shutdown (struct buffer *buf)
d1295 23
a1317 1
    if (buf->shutdown) return (*buf->shutdown) (buf);
d1321 7
d1329 10
d1355 1
a1355 1
# define PACKET_SLOP (100)
d1368 2
a1369 2
    int (*inpfn) (void *fnclosure, const char *input, char *output,
			size_t size);
d1376 2
a1377 2
    int (*outfn) (void *fnclosure, const char *input, char *output,
			size_t size, size_t *translated);
d1384 1
a1384 1
    bool translated;
d1386 1
a1386 1
    size_t holdsize;
d1390 1
a1390 1
    size_t holdbufsize;
d1397 5
d1403 1
a1404 10
static int packetizing_buffer_input (void *, char *, size_t, size_t, size_t *);
static int packetizing_buffer_output (void *, const char *, size_t, size_t *);
static int packetizing_buffer_flush (void *);
static int packetizing_buffer_block (void *, bool);
static int packetizing_buffer_get_fd (void *);
static int packetizing_buffer_shutdown (struct buffer *);



/* Create a packetizing buffer.  */
d1406 6
a1411 7
packetizing_buffer_initialize (struct buffer *buf,
                               int (*inpfn) (void *, const char *, char *,
                                             size_t),
                               int (*outfn) (void *, const char *, char *,
                                             size_t, size_t *),
                               void *fnclosure,
                               void (*memory) (struct buffer *))
d1415 1
a1415 1
    pb = xmalloc (sizeof *pb);
a1435 1
			   packetizing_buffer_get_fd,
d1441 1
a1442 2

/* Input data from a packetizing buffer.  */
d1444 6
a1449 2
packetizing_buffer_input (void *closure, char *data, size_t need, size_t size,
                          size_t *got)
d1451 1
a1451 1
    struct packetizing_buffer *pb = closure;
d1457 1
a1457 1
	size_t copy;
d1472 1
a1472 1
	pb->translated = false;
d1482 1
a1482 2
	int status;
	size_t get, nread, count, tcount;
d1538 1
a1538 1
	    n = xrealloc (pb->holdbuf, count + 2);
d1600 1
a1600 1
	    outbuf = xmalloc (count);
d1630 1
a1630 1
	    pb->translated = true;
d1654 1
a1655 2

/* Output data to a packetizing buffer.  */
d1657 5
a1661 2
packetizing_buffer_output (void *closure, const char *data, size_t have,
                           size_t *wrote)
d1663 1
a1663 1
    struct packetizing_buffer *pb = closure;
d1666 1
a1666 2
    struct buffer_data *outdata = NULL; /* Initialize to silence -Wall.  Dumb.
					 */
d1668 1
a1668 2
    size_t size, translated;
    int status;
d1670 6
a1675 3
    /* It would be easy to xmalloc a buffer, but I don't think this
       case can ever arise.  */
    assert (have <= BUFFER_DATA_SIZE);
d1711 2
a1712 1
    assert (translated <= size + PACKET_SLOP);
d1733 1
a1734 2

/* Flush data to a packetizing buffer.  */
d1736 2
a1737 1
packetizing_buffer_flush (void *closure)
d1739 1
a1739 1
    struct packetizing_buffer *pb = closure;
d1748 1
a1749 2

/* The block routine for a packetizing buffer.  */
d1751 3
a1753 1
packetizing_buffer_block (void *closure, bool block)
d1755 1
a1755 1
    struct packetizing_buffer *pb = closure;
d1763 1
a1764 2

/* Return the file descriptor underlying any child buffers.  */
d1766 2
a1767 1
packetizing_buffer_get_fd (void *closure)
d1769 1
a1769 11
    struct packetizing_buffer *cb = closure;
    return buf_get_fd (cb->buf);
}



/* Shut down a packetizing buffer.  */
static int
packetizing_buffer_shutdown (struct buffer *buf)
{
    struct packetizing_buffer *pb = buf->closure;
a1773 440


/* All server communication goes through buffer structures.  Most of
   the buffers are built on top of a file descriptor.  This structure
   is used as the closure field in a buffer.  */

struct fd_buffer
{
    /* The file descriptor.  */
    int fd;
    /* Nonzero if the file descriptor is in blocking mode.  */
    int blocking;
    /* The child process id when fd is a pipe.  */
    pid_t child_pid;
    /* The connection info, when fd is a pipe to a server.  */
    cvsroot_t *root;
};

static int fd_buffer_input (void *, char *, size_t, size_t, size_t *);
static int fd_buffer_output (void *, const char *, size_t, size_t *);
static int fd_buffer_flush (void *);
static int fd_buffer_block (void *, bool);
static int fd_buffer_get_fd (void *);
static int fd_buffer_shutdown (struct buffer *);

/* Initialize a buffer built on a file descriptor.  FD is the file
   descriptor.  INPUT is nonzero if this is for input, zero if this is
   for output.  MEMORY is the function to call when a memory error
   occurs.  */

struct buffer *
fd_buffer_initialize (int fd, pid_t child_pid, cvsroot_t *root, bool input,
                      void (*memory) (struct buffer *))
{
    struct fd_buffer *n;

    n = xmalloc (sizeof *n);
    n->fd = fd;
    n->child_pid = child_pid;
    n->root = root;
    fd_buffer_block (n, true);
    return buf_initialize (input ? fd_buffer_input : NULL,
			   input ? NULL : fd_buffer_output,
			   input ? NULL : fd_buffer_flush,
			   fd_buffer_block, fd_buffer_get_fd,
			   fd_buffer_shutdown,
			   memory,
			   n);
}



/* The buffer input function for a buffer built on a file descriptor.
 *
 * In non-blocing mode, this function will read as many bytes as it can in a
 * single try, up to SIZE bytes, and return.
 *
 * In blocking mode with NEED > 0, this function will read as many bytes as it
 * can but will not return until it has read at least NEED bytes.
 *
 * In blocking mode with NEED == 0, this function will block until it can read
 * either at least one byte or EOF, then read as many bytes as are available
 * and return.  At the very least, compress_buffer_shutdown depends on this
 * behavior to read EOF and can loop indefinitely without it.
 *
 * ASSUMPTIONS
 *   NEED <= SIZE.
 *
 * INPUTS
 *   closure	Our FD_BUFFER struct.
 *   data	The start of our input buffer.
 *   need	How many bytes our caller needs.
 *   size	How many bytes are available in DATA.
 *   got	Where to store the number of bytes read.
 *
 * OUTPUTS
 *   data	Filled with bytes read.
 *   *got	Number of bytes actually read into DATA.
 *
 * RETURNS
 *   errno	On error.
 *   -1		On EOF.
 *   0		Otherwise.
 *
 * ERRORS
 *   This function can return an error if fd_buffer_block(), or the system
 *   read() or select() calls do.
 */
static int
fd_buffer_input (void *closure, char *data, size_t need, size_t size,
		 size_t *got)
{
    struct fd_buffer *fb = closure;
    int nbytes;

    assert (need <= size);

    *got = 0;

    if (fb->blocking)
    {
	int status;
	fd_set readfds;

	/* Set non-block.  */
        status = fd_buffer_block (fb, false);
	if (status != 0) return status;

	FD_ZERO (&readfds);
	FD_SET (fb->fd, &readfds);
	do
	{
	    int numfds;

	    do {
		/* This used to select on exceptions too, but as far
		   as I know there was never any reason to do that and
		   SCO doesn't let you select on exceptions on pipes.  */
		numfds = select (fb->fd + 1, &readfds, NULL, NULL, NULL);
		if (numfds < 0 && errno != EINTR)
		{
		    status = errno;
		    goto block_done;
		}
	    } while (numfds < 0);

	    nbytes = read (fb->fd, data + *got, size - *got);

	    if (nbytes == 0)
	    {
		/* End of file.  This assumes that we are using POSIX or BSD
		   style nonblocking I/O.  On System V we will get a zero
		   return if there is no data, even when not at EOF.  */
		if (*got)
		{
		    /* We already read some data, so return no error, counting
		     * on the fact that we will read EOF again next time.
		     */
		    status = 0;
		    break;
		}
		else
		{
		    /* Return EOF.  */
		    status = -1;
		    break;
		}
	    }

	    if (nbytes < 0)
	    {
		/* Some error occurred.  */
		if (!blocking_error (errno))
		{
		    status = errno;
		    break;
		}
		/* else Everything's fine, we just didn't get any data.  */
	    }

	    *got += nbytes;
	} while (*got < need);

block_done:
	if (status == 0 || status == -1)
	{
	    int newstatus;

	    /* OK or EOF - Reset block.  */
	    newstatus = fd_buffer_block (fb, true);
	    if (newstatus) status = newstatus;
	}
	return status;
    }

    /* The above will always return.  Handle non-blocking read.  */
    nbytes = read (fb->fd, data, size);

    if (nbytes > 0)
    {
	*got = nbytes;
	return 0;
    }

    if (nbytes == 0)
	/* End of file.  This assumes that we are using POSIX or BSD
	   style nonblocking I/O.  On System V we will get a zero
	   return if there is no data, even when not at EOF.  */
	return -1;

    /* Some error occurred.  */
    if (blocking_error (errno))
	/* Everything's fine, we just didn't get any data.  */
	return 0;

    return errno;
}



/* The buffer output function for a buffer built on a file descriptor.  */

static int
fd_buffer_output (void *closure, const char *data, size_t have, size_t *wrote)
{
    struct fd_buffer *fd = closure;

    *wrote = 0;

    while (have > 0)
    {
	int nbytes;

	nbytes = write (fd->fd, data, have);

	if (nbytes <= 0)
	{
	    if (! fd->blocking
		&& (nbytes == 0 || blocking_error (errno)))
	    {
		/* A nonblocking write failed to write any data.  Just
		   return.  */
		return 0;
	    }

	    /* Some sort of error occurred.  */

	    if (nbytes == 0)
		return EIO;

	    return errno;
	}

	*wrote += nbytes;
	data += nbytes;
	have -= nbytes;
    }

    return 0;
}



/* The buffer flush function for a buffer built on a file descriptor.  */
static int
fd_buffer_flush (void *closure)
{
    /* We don't need to do anything here.  Our fd doesn't have its own buffer
     * and syncing won't do anything but slow us down.
     *
     * struct fd_buffer *fb = closure;
     *
     * if (fsync (fb->fd) < 0 && errno != EROFS && errno != EINVAL)
     *     return errno;
     */
    return 0;
}



/* The buffer block function for a buffer built on a file descriptor.  */
static int
fd_buffer_block (void *closure, bool block)
{
    struct fd_buffer *fb = closure;
#if defined (F_GETFL) && defined (O_NONBLOCK) && defined (F_SETFL)
    int flags;

    flags = fcntl (fb->fd, F_GETFL, 0);
    if (flags < 0)
	return errno;

    if (block)
	flags &= ~O_NONBLOCK;
    else
	flags |= O_NONBLOCK;

    if (fcntl (fb->fd, F_SETFL, flags) < 0 && errno != ENODEV)
	/* BSD returns ENODEV when we try to set block/nonblock on /dev/null.
	 */
	return errno;
#endif /* F_GETFL && O_NONBLOCK && F_SETFL */

    fb->blocking = block;

    return 0;
}



static int
fd_buffer_get_fd (void *closure)
{
    struct fd_buffer *fb = closure;
    return fb->fd;
}



/* The buffer shutdown function for a buffer built on a file descriptor.
 *
 * This function disposes of memory allocated for this buffer.
 */
static int
fd_buffer_shutdown (struct buffer *buf)
{
    struct fd_buffer *fb = buf->closure;
    struct stat s;
    bool closefd, statted;

    /* Must be an open pipe, socket, or file.  What could go wrong? */
    if (fstat (fb->fd, &s) == -1) statted = false;
    else statted = true;
    /* Don't bother to try closing the FD if we couldn't stat it.  This
     * probably won't work.
     *
     * (buf_shutdown() on some of the server/child communication pipes is
     * getting EBADF on both the fstat and the close.  I'm not sure why -
     * perhaps they were alredy closed somehow?
     */
    closefd = statted;

    /* Flush the buffer if possible.  */
    if (buf->flush)
    {
	buf_flush (buf, 1);
	buf->flush = NULL;
    }

    if (buf->input)
    {
	/* There used to be a check here for unread data in the buffer of
	 * the pipe, but it was deemed unnecessary and possibly dangerous.  In
	 * some sense it could be second-guessing the caller who requested it
	 * closed, as well.
	 */

/* FIXME:
 *
 * This mess of #ifdefs is hard to read.  There must be some relation between
 * the macros being checked which at least deserves comments - if
 * SHUTDOWN_SERVER, NO_SOCKET_TO_FD, & START_RSH_WITH_POPEN_RW were completely
 * independant, then the next few lines could easily refuse to compile.
 *
 * The note below about START_RSH_WITH_POPEN_RW never being set when
 * SHUTDOWN_SERVER is defined means that this code would always break on
 * systems with SHUTDOWN_SERVER defined and thus the comment must now be
 * incorrect or the code was broken since the comment was written.
 */
# ifdef SHUTDOWN_SERVER
	if (fb->root && fb->root->method != server_method)
# endif
# ifndef NO_SOCKET_TO_FD
	{
	    /* shutdown() sockets */
	    if (statted && S_ISSOCK (s.st_mode))
		shutdown (fb->fd, 0);
	}
# endif /* NO_SOCKET_TO_FD */
# ifdef START_RSH_WITH_POPEN_RW
/* Can't be set with SHUTDOWN_SERVER defined */
	/* FIXME: This is now certainly broken since pclose is defined by ANSI
	 * C to accept a FILE * argument.  The switch will need to happen at a
	 * higher abstraction level to switch between initializing stdio & fd
	 * buffers on systems that need this (or maybe an fd buffer that keeps
	 * track of the FILE * could be used - I think flushing the stream
	 * before beginning exclusive access via the FD is OK.
	 */
	else if (fb->root && pclose (fb->fd) == EOF)
	{
	    error (1, errno, "closing connection to %s",
		   fb->root->hostname);
	    closefd = false;
	}
# endif /* START_RSH_WITH_POPEN_RW */

	buf->input = NULL;
    }
    else if (buf->output)
    {
# ifdef SHUTDOWN_SERVER
	/* FIXME:  Should have a SHUTDOWN_SERVER_INPUT &
	 * SHUTDOWN_SERVER_OUTPUT
	 */
	if (fb->root && fb->root->method == server_method)
	    SHUTDOWN_SERVER (fb->fd);
	else
# endif
# ifndef NO_SOCKET_TO_FD
	/* shutdown() sockets */
	if (statted && S_ISSOCK (s.st_mode))
	    shutdown (fb->fd, 1);
# else
	{
	/* I'm not sure I like this empty block, but the alternative
	 * is another nested NO_SOCKET_TO_FD switch as above.
	 */
	}
# endif /* NO_SOCKET_TO_FD */

	buf->output = NULL;
    }

    if (statted && closefd && close (fb->fd) == -1)
    {
	if (0
# ifdef SERVER_SUPPORT
	    || server_active
# endif /* SERVER_SUPPORT */
           )
	{
            /* Syslog this? */
	}
# ifdef CLIENT_SUPPORT
	else if (fb->root)
            error (1, errno, "closing down connection to %s",
                   fb->root->hostname);
	    /* EXITS */
# endif /* CLIENT_SUPPORT */

	error (0, errno, "closing down buffer");
    }

    /* If we were talking to a process, make sure it exited */
    if (fb->child_pid)
    {
	int w;

	do
	    w = waitpid (fb->child_pid, (int *) 0, 0);
	while (w == -1 && errno == EINTR);
	if (w == -1)
	    error (1, errno, "waiting for process %d", fb->child_pid);
    }

    free (buf->closure);
    buf->closure = NULL;

    return 0;
}
@


1.1.2.2
log
@GNU CVS 1.12.11
@
text
@d170 1
a170 1
# if defined (SERVER_FLOWCONTROL) || defined (PROXY_SUPPORT)
d186 1
a186 1
# endif /* SERVER_FLOWCONTROL || PROXY_SUPPORT */
d509 1
a509 1
# ifdef PROXY_SUPPORT
d556 1
a556 1
# endif /* PROXY_SUPPORT */
a1990 3
static struct stat devnull;
static int devnull_set = -1;

d1996 1
a1996 1
# if defined (F_GETFL) && defined (O_NONBLOCK) && defined (F_SETFL)
d2008 2
a2009 5
    if (fcntl (fb->fd, F_SETFL, flags) < 0)
    {
	/*
	 * BSD returns ENODEV when we try to set block/nonblock on /dev/null.
	 * BSDI returns ENOTTY when we try to set block/nonblock on /dev/null.
d2011 2
a2012 27
	struct stat sb;
	int save_errno = errno;
	bool isdevnull = false;

	if (devnull_set == -1)
	    devnull_set = stat ("/dev/null", &devnull);

	if (devnull_set >= 0)
	    /* Equivalent to /dev/null ? */
	    isdevnull = (fstat (fb->fd, &sb) >= 0
			 && sb.st_dev == devnull.st_dev
			 && sb.st_ino == devnull.st_ino
			 && sb.st_mode == devnull.st_mode
			 && sb.st_uid == devnull.st_uid
			 && sb.st_gid == devnull.st_gid
			 && sb.st_size == devnull.st_size
			 && sb.st_blocks == devnull.st_blocks
			 && sb.st_blksize == devnull.st_blksize);
	if (isdevnull)
	    errno = 0;
	else
	{
	    errno = save_errno;
	    return errno;
	}
    }
# endif /* F_GETFL && O_NONBLOCK && F_SETFL */
@


1.1.3.1
log
@our CVS is currently at 1.11.1p1, thus import that version into vendor branch
@
text
@@


1.1.3.2
log
@CVS 1.11.12 is the latest stable version of CVS,
released 06.02.2004, with a huge lot of bug fixes.

/me hopes this will pay off...
@
text
@a8 6
#ifdef HAVE_WINSOCK_H
# include <winsock.h>
#else
# include <sys/socket.h>
#endif

d31 1
a31 1
     int (*shutdown) PROTO((struct buffer *));
d76 1
a76 1
	     (int (*) PROTO((struct buffer *))) NULL,
d103 1
a103 1
	   xmalloc (ALLOC_COUNT * sizeof (struct buffer_data)));
d151 1
a151 1
 * Note that each buffer is a xmalloc'ed chunk BUFFER_DATA_SIZE.
d791 1
a791 1
	    p = xmalloc (len + 1);
d1201 1
a1201 1
	return (*buf->shutdown) (buf);
a1212 1
static int stdio_buffer_shutdown PROTO((struct buffer *buf));
a1215 6
struct stdio_buffer_closure
{
    FILE *fp;
    int child_pid;
};

d1217 1
a1217 1
stdio_buffer_initialize (fp, child_pid, input, memory)
a1218 1
     int child_pid;
a1221 5
    struct stdio_buffer_closure *bc = xmalloc (sizeof (*bc));

    bc->fp = fp;
    bc->child_pid = child_pid;

d1226 1
a1226 1
			   stdio_buffer_shutdown,
d1228 1
a1228 15
			   (void *) bc);
}

/* Return the file associated with a stdio buffer. */
FILE *
stdio_buffer_get_file (buf)
    struct buffer *buf;
{
    struct stdio_buffer_closure *bc;

    assert(buf->shutdown == stdio_buffer_shutdown);

    bc = (struct stdio_buffer_closure *) buf->closure;

    return(bc->fp);
d1241 1
a1241 1
    struct stdio_buffer_closure *bc = (struct stdio_buffer_closure *) closure;
d1251 1
a1251 1
	ch = getc (bc->fp);
d1255 1
a1255 1
	    if (feof (bc->fp))
d1268 1
a1268 1
    nbytes = fread (data, 1, need, bc->fp);
d1273 1
a1273 1
	if (feof (bc->fp))
d1295 1
a1295 1
    struct stdio_buffer_closure *bc = (struct stdio_buffer_closure *) closure;
d1303 1
a1303 1
	nbytes = fwrite (data, 1, have, bc->fp);
d1327 1
a1327 1
    struct stdio_buffer_closure *bc = (struct stdio_buffer_closure *) closure;
d1329 1
a1329 1
    if (fflush (bc->fp) != 0)
a1339 115


static int
stdio_buffer_shutdown (buf)
    struct buffer *buf;
{
    struct stdio_buffer_closure *bc = (struct stdio_buffer_closure *) buf->closure;
    struct stat s;
    int closefp = 1;

    /* Must be a pipe or a socket.  What could go wrong? */
    assert (fstat ( fileno (bc->fp), &s ) != -1);

    /* Flush the buffer if we can */
    if (buf->flush)
    {
	buf_flush (buf, 1);
	buf->flush = NULL;
    }

    if (buf->input)
    {
	if ( !buf_empty_p (buf) )
	{
# ifdef SERVER_SUPPORT
	    if (server_active)
		/* FIXME: This should probably be sysloged since it doesn't
		 * have anywhere else to go at this point.
		 */
		error (0, 0, "dying gasps from client unexpected");
	    else
#endif
		error (0, 0, "dying gasps from %s unexpected", current_parsed_root->hostname);
	}
	else if (ferror (bc->fp))
	{
# ifdef SERVER_SUPPORT
	    if (server_active)
		/* FIXME: This should probably be sysloged since it doesn't
		 * have anywhere else to go at this point.
		 */
		error (0, errno, "reading from client");
	    else
#endif
		error (0, errno, "reading from %s", current_parsed_root->hostname);
	}

# ifdef SHUTDOWN_SERVER
	if (current_parsed_root->method != server_method)
# endif
# ifndef NO_SOCKET_TO_FD
	{
	    /* shutdown() sockets */
	    if (S_ISSOCK(s.st_mode))
		shutdown ( fileno (bc->fp), 0);
	}
# endif /* NO_SOCKET_TO_FD */
# ifdef START_RSH_WITH_POPEN_RW
	/* Can't be set with SHUTDOWN_SERVER defined */
	else if (pclose (bc->fp) == EOF)
	{
	    error (1, errno, "closing connection to %s",
		   current_parsed_root->hostname);
	    closefp = 0;
	}
# endif /* START_RSH_WITH_POPEN_RW */

	buf->input = NULL;
    }
    else if (buf->output)
    {
# ifdef SHUTDOWN_SERVER
	/* FIXME:  Should have a SHUTDOWN_SERVER_INPUT &
	 * SHUTDOWN_SERVER_OUTPUT
	 */
	if (current_parsed_root->method == server_method)
	    SHUTDOWN_SERVER ( fileno (bc->fp) );
	else
# endif
# ifndef NO_SOCKET_TO_FD
	/* shutdown() sockets */
	if (S_ISSOCK(s.st_mode))
	    shutdown ( fileno (bc->fp), 1);
# else
	{
	/* I'm not sure I like this empty block, but the alternative
	 * is a another nested NO_SOCKET_TO_FD switch above.
	 */
	}
# endif /* NO_SOCKET_TO_FD */

	buf->output = NULL;
    }

    if (closefp && fclose (bc->fp) == EOF)
	error (1, errno,
	       "closing down connection to %s",
	       current_parsed_root->hostname);

    /* If we were talking to a process, make sure it exited */
    if (bc->child_pid)
    {
	int w;

	do
	    w = waitpid (bc->child_pid, (int *) 0, 0);
	while (w == -1 && errno == EINTR);
	if (w == -1)
	    error (1, errno, "waiting for process %d", bc->child_pid);
    }
    return 0;
}



d1401 1
a1401 1
static int packetizing_buffer_shutdown PROTO((struct buffer *));
d1538 1
a1538 1
	    n = xrealloc (pb->holdbuf, count + 2);
d1600 1
a1600 1
	    outbuf = xmalloc (count);
d1672 1
a1672 1
	/* It would be easy to xmalloc a buffer, but I don't think this
d1766 2
a1767 2
packetizing_buffer_shutdown (buf)
    struct buffer *buf;
d1769 1
a1769 1
    struct packetizing_buffer *pb = (struct packetizing_buffer *) buf->closure;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
