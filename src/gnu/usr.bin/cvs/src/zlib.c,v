head	1.4;
access;
symbols
	cvs-1_12_11:1.1.2.1
	tg-mergetmp-mirosx-1:1.4
	tg-mergefixes-1-branch:1.4.0.4
	tg-mergefixes-1-base:1.4
	MIROS_X:1.4.0.2
	MIROS_X_BASE:1.4
	cvs-1_12_10:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_MIRPPC:1.3.0.4
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.1.1.2
	cvs-200405160640:1.1.1.2
	cvs-200404170130:1.1.1.2
	cvs-1_11_12:1.1.3.2
	cvs-1_11_1p1:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.6
	MIRBSD_7:1.1.1.2.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.1.1.2
	MIRBSD_7_DEV:1.1.1.2.0.2
	cvs-200310020700:1.1.1.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.12.02.12.40.33;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.22.13.49.20;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.02.12.21.16.26;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.33;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.41.33;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.28.40;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2004.12.02.11.59.18;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.02.12.19.20.30;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.12.19.40.40;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@update to cvs 1.12.10-MirOS except automatically
generated files
XXX this installs as /usr/bin/ncvs yet, so no
XXX conflicts during the test phase.
XXX I suggest to _not_ update.

XXX *** IMPORTANT *** DO NOT ACCESS CVS 1.11 REPOSITORIES
XXX *** IMPORTANT *** WITH CVS 1.12 OR VICE VERSA!
@
text
@/* zlib.c --- interface to the zlib compression library
   Ian Lance Taylor <ian@@cygnus.com>

   This file is part of GNU CVS.

   GNU CVS is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

/* The routines in this file are the interface between the CVS
   client/server support and the zlib compression library.  */

#include "cvs.h"
#include "buffer.h"

#if defined (SERVER_SUPPORT) || defined (CLIENT_SUPPORT)

#if HAVE_ZLIB_H
# include <zlib.h>
#else
# include "zlib.h"
#endif

/* OS/2 doesn't have EIO.  FIXME: this whole notion of turning
   a different error into EIO strikes me as pretty dubious.  */
#if !defined (EIO)
#define EIO EBADPOS
#endif

/* The compression interface is built upon the buffer data structure.
   We provide a buffer type which compresses or decompresses the data
   which passes through it.  An input buffer decompresses the data
   read from an underlying buffer, and an output buffer compresses the
   data before writing it to an underlying buffer.  */

/* This structure is the closure field of the buffer.  */

struct compress_buffer
{
    /* The underlying buffer.  */
    struct buffer *buf;
    /* The compression information.  */
    z_stream zstr;
};

static void compress_error (int, int, z_stream *, const char *);
static int compress_buffer_input (void *, char *, size_t, size_t, size_t *);
static int compress_buffer_output (void *, const char *, size_t, size_t *);
static int compress_buffer_flush (void *);
static int compress_buffer_block (void *, bool);
static int compress_buffer_get_fd (void *);
static int compress_buffer_shutdown_input (struct buffer *);
static int compress_buffer_shutdown_output (struct buffer *);

/* Report an error from one of the zlib functions.  */

static void
compress_error (int status, int zstatus, z_stream *zstr, const char *msg)
{
    int hold_errno;
    const char *zmsg;
    char buf[100];

    hold_errno = errno;

    zmsg = zstr->msg;
    if (zmsg == NULL)
    {
        sprintf (buf, "error %d", zstatus);
	zmsg = buf;
    }

    error (status,
	   zstatus == Z_ERRNO ? hold_errno : 0,
	   "%s: %s", msg, zmsg);
}



/* Create a compression buffer.  */
struct buffer *
compress_buffer_initialize (struct buffer *buf, int input, int level,
                            void (*memory) (struct buffer *))
{
    struct compress_buffer *n;
    int zstatus;

    n = xmalloc (sizeof *n);
    memset (n, 0, sizeof *n);

    n->buf = buf;

    if (input)
	zstatus = inflateInit (&n->zstr);
    else
	zstatus = deflateInit (&n->zstr, level);
    if (zstatus != Z_OK)
	compress_error (1, zstatus, &n->zstr, "compression initialization");

    /* There may already be data buffered on BUF.  For an output
       buffer, this is OK, because these routines will just use the
       buffer routines to append data to the (uncompressed) data
       already on BUF.  An input buffer expects to handle a single
       buffer_data of buffered input to be uncompressed, so that is OK
       provided there is only one buffer.  At present that is all
       there ever will be; if this changes, compress_buffer_input must
       be modified to handle multiple input buffers.  */
    assert (! input || buf->data == NULL || buf->data->next == NULL);

    return buf_initialize (input ? compress_buffer_input : NULL,
			   input ? NULL : compress_buffer_output,
			   input ? NULL : compress_buffer_flush,
			   compress_buffer_block, compress_buffer_get_fd,
			   (input
			    ? compress_buffer_shutdown_input
			    : compress_buffer_shutdown_output),
			   memory,
			   n);
}



/* Input data from a compression buffer.  */
static int
compress_buffer_input (void *closure, char *data, size_t need, size_t size,
		       size_t *got)
{
    struct compress_buffer *cb = closure;
    struct buffer_data *bd;

    assert (cb->buf->input);

    /* We use a single buffer_data structure to buffer up data which
       the z_stream structure won't use yet.  We can safely store this
       on cb->buf->data, because we never call the buffer routines on
       cb->buf; we only call the buffer input routine, since that
       gives us the semantics we want.  As noted in
       compress_buffer_initialize, the buffer_data structure may
       already exist, and hold data which was already read and
       buffered before the decompression began.  */
    bd = cb->buf->data;
    if (bd == NULL)
    {
	bd = xmalloc (sizeof (struct buffer_data));
	if (bd == NULL)
	    return -2;
	bd->text = xmalloc (BUFFER_DATA_SIZE);
	if (bd->text == NULL)
	{
	    free (bd);
	    return -2;
	}
	bd->bufp = bd->text;
	bd->size = 0;
	cb->buf->data = bd;
    }

    cb->zstr.avail_out = size;
    cb->zstr.next_out = (Bytef *) data;

    while (1)
    {
	int zstatus, sofar, status;
	size_t nread;

	/* First try to inflate any data we already have buffered up.
	   This is useful even if we don't have any buffered data,
	   because there may be data buffered inside the z_stream
	   structure.  */

	cb->zstr.avail_in = bd->size;
	cb->zstr.next_in = (Bytef *) bd->bufp;

	do
	{
	    zstatus = inflate (&cb->zstr, Z_NO_FLUSH);
	    if (zstatus == Z_STREAM_END)
		break;
	    if (zstatus != Z_OK && zstatus != Z_BUF_ERROR)
	    {
		compress_error (0, zstatus, &cb->zstr, "inflate");
		return EIO;
	    }
	} while (cb->zstr.avail_in > 0
		 && cb->zstr.avail_out > 0);

	bd->size = cb->zstr.avail_in;
	bd->bufp = (char *) cb->zstr.next_in;

	if (zstatus == Z_STREAM_END)
	    return -1;

	/* If we have obtained NEED bytes, then return, unless NEED is
           zero and we haven't obtained anything at all.  If NEED is
           zero, we will keep reading from the underlying buffer until
           we either can't read anything, or we have managed to
           inflate at least one byte.  */
	sofar = size - cb->zstr.avail_out;
	if (sofar > 0 && sofar >= need)
	    break;

	/* All our buffered data should have been processed at this
           point.  */
	assert (bd->size == 0);

	/* This will work well in the server, because this call will
	   do an unblocked read and fetch all the available data.  In
	   the client, this will read a single byte from the stdio
	   stream, which will cause us to call inflate once per byte.
	   It would be more efficient if we could make a call which
	   would fetch all the available bytes, and at least one byte.  */

	status = (*cb->buf->input) (cb->buf->closure, bd->text,
				    need > 0 ? 1 : 0,
				    BUFFER_DATA_SIZE, &nread);
	if (status != 0)
	    return status;

	/* If we didn't read anything, then presumably the buffer is
           in nonblocking mode, and we should just get out now with
           whatever we've inflated.  */
	if (nread == 0)
	{
	    assert (need == 0);
	    break;
	}

	bd->bufp = bd->text;
	bd->size = nread;
    }

    *got = size - cb->zstr.avail_out;

    return 0;
}



/* Output data to a compression buffer.  */
static int
compress_buffer_output (void *closure, const char *data, size_t have,
			size_t *wrote)
{
    struct compress_buffer *cb = closure;

    cb->zstr.avail_in = have;
    cb->zstr.next_in = (unsigned char *) data;

    while (cb->zstr.avail_in > 0)
    {
	char buffer[BUFFER_DATA_SIZE];
	int zstatus;

	cb->zstr.avail_out = BUFFER_DATA_SIZE;
	cb->zstr.next_out = (unsigned char *) buffer;

	zstatus = deflate (&cb->zstr, Z_NO_FLUSH);
	if (zstatus != Z_OK)
	{
	    compress_error (0, zstatus, &cb->zstr, "deflate");
	    return EIO;
	}

	if (cb->zstr.avail_out != BUFFER_DATA_SIZE)
	    buf_output (cb->buf, buffer,
			BUFFER_DATA_SIZE - cb->zstr.avail_out);
    }

    *wrote = have;

    /* We will only be here because buf_send_output was called on the
       compression buffer.  That means that we should now call
       buf_send_output on the underlying buffer.  */
    return buf_send_output (cb->buf);
}



/* Flush a compression buffer.  */
static int
compress_buffer_flush (void *closure)
{
    struct compress_buffer *cb = closure;

    cb->zstr.avail_in = 0;
    cb->zstr.next_in = NULL;

    while (1)
    {
	char buffer[BUFFER_DATA_SIZE];
	int zstatus;

	cb->zstr.avail_out = BUFFER_DATA_SIZE;
	cb->zstr.next_out = (unsigned char *) buffer;

	zstatus = deflate (&cb->zstr, Z_SYNC_FLUSH);

	/* The deflate function will return Z_BUF_ERROR if it can't do
           anything, which in this case means that all data has been
           flushed.  */
	if (zstatus == Z_BUF_ERROR)
	    break;

	if (zstatus != Z_OK)
	{
	    compress_error (0, zstatus, &cb->zstr, "deflate flush");
	    return EIO;
	}

	if (cb->zstr.avail_out != BUFFER_DATA_SIZE)
	    buf_output (cb->buf, buffer,
			BUFFER_DATA_SIZE - cb->zstr.avail_out);

	/* If the deflate function did not fill the output buffer,
           then all data has been flushed.  */
	if (cb->zstr.avail_out > 0)
	    break;
    }

    /* Now flush the underlying buffer.  Note that if the original
       call to buf_flush passed 1 for the BLOCK argument, then the
       buffer will already have been set into blocking mode, so we
       should always pass 0 here.  */
    return buf_flush (cb->buf, 0);
}



/* The block routine for a compression buffer.  */
static int
compress_buffer_block (void *closure, bool block)
{
    struct compress_buffer *cb = closure;

    if (block)
	return set_block (cb->buf);
    else
	return set_nonblock (cb->buf);
}



/* Return the file descriptor underlying any child buffers.  */
static int
compress_buffer_get_fd (void *closure)
{
    struct compress_buffer *cb = closure;
    return buf_get_fd (cb->buf);
}



/* Shut down an input buffer.  */
static int
compress_buffer_shutdown_input (struct buffer *buf)
{
    struct compress_buffer *cb = buf->closure;
    int zstatus;

    /* Pick up any trailing data, such as the checksum.  */
    while (1)
    {
	int status;
	size_t nread;
	char buf[100];

	status = compress_buffer_input (cb, buf, 0, sizeof buf, &nread);
	if (status == -1)
	    break;
	if (status != 0)
	    return status;
    }

    zstatus = inflateEnd (&cb->zstr);
    if (zstatus != Z_OK)
    {
	compress_error (0, zstatus, &cb->zstr, "inflateEnd");
	return EIO;
    }

    return buf_shutdown (cb->buf);
}



/* Shut down an output buffer.  */
static int
compress_buffer_shutdown_output (struct buffer *buf)
{
    struct compress_buffer *cb = buf->closure;
    int zstatus, status;

    do
    {
	char buffer[BUFFER_DATA_SIZE];

	cb->zstr.avail_out = BUFFER_DATA_SIZE;
	cb->zstr.next_out = (unsigned char *) buffer;

	zstatus = deflate (&cb->zstr, Z_FINISH);
	if (zstatus != Z_OK && zstatus != Z_STREAM_END)
	{
	    compress_error (0, zstatus, &cb->zstr, "deflate finish");
	    return EIO;
	}

	if (cb->zstr.avail_out != BUFFER_DATA_SIZE)
	    buf_output (cb->buf, buffer,
			BUFFER_DATA_SIZE - cb->zstr.avail_out);
    } while (zstatus != Z_STREAM_END);

    zstatus = deflateEnd (&cb->zstr);
    if (zstatus != Z_OK)
    {
	compress_error (0, zstatus, &cb->zstr, "deflateEnd");
	return EIO;
    }

    status = buf_flush (cb->buf, 1);
    if (status != 0)
	return status;

    return buf_shutdown (cb->buf);
}



/* Here is our librarified gzip implementation.  It is very minimal
   but attempts to be RFC1952 compliant.  */

/* GZIP ID byte values */
#define GZIP_ID1	31
#define GZIP_ID2	139

/* Compression methods */
#define GZIP_CDEFLATE	8

/* Flags */
#define GZIP_FTEXT	1
#define GZIP_FHCRC	2
#define GZIP_FEXTRA	4
#define GZIP_FNAME	8
#define GZIP_FCOMMENT	16

/* BUF should contain SIZE bytes of gzipped data (RFC1952/RFC1951).
   We are to uncompress the data and write the result to the file
   descriptor FD.  If something goes wrong, give a nonfatal error message
   mentioning FULLNAME as the name of the file for FD.  Return 1 if
   it is an error we can't recover from.  */

int
gunzip_and_write (int fd, const char *fullname, unsigned char *buf,
		  size_t size)
{
    size_t pos;
    z_stream zstr;
    int zstatus;
    unsigned char outbuf[32768];
    unsigned long crc;

    if (size < 10)
    {
	error (0, 0, "gzipped data too small - lacks complete header");
	return 1;
    }
    if (buf[0] != GZIP_ID1 || buf[1] != GZIP_ID2)
    {
	error (0, 0, "gzipped data does not start with gzip identification");
	return 1;
    }
    if (buf[2] != GZIP_CDEFLATE)
    {
	error (0, 0, "only the deflate compression method is supported");
	return 1;
    }

    /* Skip over the fixed header, and then skip any of the variable-length
       fields.  As we skip each field, we keep pos <= size. The checks
       on positions and lengths are really checks for malformed or 
       incomplete gzip data.  */
    pos = 10;
    if (buf[3] & GZIP_FEXTRA)
    {
	if (pos + 2 >= size) 
	{
	    error (0, 0, "%s lacks proper gzip XLEN field", fullname);
	    return 1;
	}
	pos += buf[pos] + (buf[pos + 1] << 8) + 2;
	if (pos > size) 
	{
	    error (0, 0, "%s lacks proper gzip \"extra field\"", fullname);
	    return 1;
	}

    }
    if (buf[3] & GZIP_FNAME)
    {
	unsigned char *p = memchr(buf + pos, '\0', size - pos);
	if (p == NULL)
	{
	    error (0, 0, "%s has bad gzip filename field", fullname);
	    return 1;
	}
	pos = p - buf + 1;
    }
    if (buf[3] & GZIP_FCOMMENT)
    {
	unsigned char *p = memchr(buf + pos, '\0', size - pos);
	if (p == NULL)
	{
	    error (0, 0, "%s has bad gzip comment field", fullname);
	    return 1;
	}
	pos = p - buf + 1;
    }
    if (buf[3] & GZIP_FHCRC)
    {
	pos += 2;
	if (pos > size) 
	{
	    error (0, 0, "%s has bad gzip CRC16 field", fullname);
	    return 1;
	}
    }

    /* There could be no data to decompress - check and short circuit.  */
    if (pos >= size)
    {
	error (0, 0, "gzip data incomplete for %s (no data)", fullname);
	return 1;
    }

    memset (&zstr, 0, sizeof zstr);
    /* Passing a negative argument tells zlib not to look for a zlib
       (RFC1950) header.  This is an undocumented feature; I suppose if
       we wanted to be anal we could synthesize a header instead,
       but why bother?  */
    zstatus = inflateInit2 (&zstr, -15);

    if (zstatus != Z_OK)
	compress_error (1, zstatus, &zstr, fullname);

    /* I don't see why we should have to include the 8 byte trailer in
       avail_in.  But I see that zlib/gzio.c does, and it seemed to fix
       a fairly rare bug in which we'd get a Z_BUF_ERROR for no obvious
       reason.  */
    zstr.avail_in = size - pos;
    zstr.next_in = buf + pos;

    crc = crc32 (0, NULL, 0);

    do
    {
	zstr.avail_out = sizeof (outbuf);
	zstr.next_out = outbuf;
	zstatus = inflate (&zstr, Z_NO_FLUSH);
	if (zstatus != Z_STREAM_END && zstatus != Z_OK)
	{
	    compress_error (0, zstatus, &zstr, fullname);
	    return 1;
	}
	if (write (fd, outbuf, sizeof (outbuf) - zstr.avail_out) < 0)
	{
	    error (0, errno, "writing decompressed file %s", fullname);
	    return 1;
	}
	crc = crc32 (crc, outbuf, sizeof (outbuf) - zstr.avail_out);
    } while (zstatus != Z_STREAM_END);
    zstatus = inflateEnd (&zstr);
    if (zstatus != Z_OK)
	compress_error (0, zstatus, &zstr, fullname);

    /* Check that there is still 8 trailer bytes remaining (CRC32
       and ISIZE).  Check total decomp. data, plus header len (pos)
       against input buffer total size.  */
    pos += zstr.total_in;
    if (size - pos != 8)
    {
	error (0, 0, "gzip data incomplete for %s (no trailer)", fullname);
	return 1;
    }

    if (crc != ((unsigned long)buf[pos]
		+ ((unsigned long)buf[pos + 1] << 8)
		+ ((unsigned long)buf[pos + 2] << 16)
		+ ((unsigned long)buf[pos + 3] << 24)))
    {
	error (0, 0, "CRC error uncompressing %s", fullname);
	return 1;
    }

    if (zstr.total_out != ((unsigned long)buf[pos + 4]
			   + ((unsigned long)buf[pos + 5] << 8)
			   + ((unsigned long)buf[pos + 6] << 16)
			   + ((unsigned long)buf[pos + 7] << 24)))
    {
	error (0, 0, "invalid length uncompressing %s", fullname);
	return 1;
    }

    return 0;
}

/* Read all of FD and put the gzipped data (RFC1952/RFC1951) into *BUF,
   replacing previous contents of *BUF.  *BUF is xmalloc'd and *SIZE is
   its allocated size.  Put the actual number of bytes of data in
   *LEN.  If something goes wrong, give a nonfatal error mentioning
   FULLNAME as the name of the file for FD, and return 1 if we can't
   recover from it).  LEVEL is the compression level (1-9).  */

int
read_and_gzip (int fd, const char *fullname, unsigned char **buf, size_t *size,
               size_t *len, int level)
{
    z_stream zstr;
    int zstatus;
    unsigned char inbuf[8192];
    int nread;
    unsigned long crc;

    if (*size < 1024)
    {
	unsigned char *newbuf;

	*size = 1024;
	newbuf = xrealloc (*buf, *size);
	if (newbuf == NULL)
	{
	    error (0, 0, "out of memory");
	    return 1;
	}
	*buf = newbuf;
    }
    (*buf)[0] = GZIP_ID1;
    (*buf)[1] = GZIP_ID2;
    (*buf)[2] = GZIP_CDEFLATE;
    (*buf)[3] = 0;
    (*buf)[4] = (*buf)[5] = (*buf)[6] = (*buf)[7] = 0;
    /* Could set this based on level, but why bother?  */
    (*buf)[8] = 0;
    (*buf)[9] = 255;

    memset (&zstr, 0, sizeof zstr);
    zstatus = deflateInit2 (&zstr, level, Z_DEFLATED, -15, 8,
			    Z_DEFAULT_STRATEGY);
    crc = crc32 (0, NULL, 0);
    if (zstatus != Z_OK)
    {
	compress_error (0, zstatus, &zstr, fullname);
	return 1;
    }
    
    /* Adjust for 10-byte output header (filled in above) */
    zstr.total_out = 10;
    zstr.avail_out = *size - 10;
    zstr.next_out = *buf + 10;

    while (1)
    {
	int finish = 0;

	nread = read (fd, inbuf, sizeof inbuf);
	if (nread < 0)
	{
	    error (0, errno, "cannot read %s", fullname);
	    return 1;
	}
	else if (nread == 0)
	    /* End of file.  */
	    finish = 1;
	crc = crc32 (crc, inbuf, nread);
	zstr.next_in = inbuf;
	zstr.avail_in = nread;

	do
	{
	    /* I don't see this documented anywhere, but deflate seems
	       to tend to dump core sometimes if we pass it Z_FINISH and
	       a small (e.g. 2147 byte) avail_out.  So we insist on at
	       least 4096 bytes (that is what zlib/gzio.c uses).  */

	    if (zstr.avail_out < 4096)
	    {
		unsigned char *newbuf;

		assert(zstr.avail_out + zstr.total_out == *size);
		assert(zstr.next_out == *buf + zstr.total_out);
		*size *= 2;
		newbuf = xrealloc (*buf, *size);
		if (newbuf == NULL)
		{
		    error (0, 0, "out of memory");
		    return 1;
		}
		*buf = newbuf;
		zstr.next_out = *buf + zstr.total_out;
		zstr.avail_out = *size - zstr.total_out;
		assert(zstr.avail_out + zstr.total_out == *size);
		assert(zstr.next_out == *buf + zstr.total_out);
	    }

	    zstatus = deflate (&zstr, finish ? Z_FINISH : 0);
	    if (zstatus == Z_STREAM_END)
		goto done;
	    else if (zstatus != Z_OK)
		compress_error (0, zstatus, &zstr, fullname);
	} while (zstr.avail_out == 0);
    }
 done:
    /* Need to add the CRC information (8 bytes)
       to the end of the gzip'd output.
       Ensure there is enough space in the output buffer
       to do so.  */
    if (zstr.avail_out < 8)
    {
	unsigned char *newbuf;

	assert(zstr.avail_out + zstr.total_out == *size);
	assert(zstr.next_out == *buf + zstr.total_out);
	*size += 8 - zstr.avail_out;
	newbuf = realloc (*buf, *size);
	if (newbuf == NULL)
	{
	    error (0, 0, "out of memory");
	    return 1;
	}
	*buf = newbuf;
	zstr.next_out = *buf + zstr.total_out;
	zstr.avail_out = *size - zstr.total_out;
	assert(zstr.avail_out + zstr.total_out == *size);
	assert(zstr.next_out == *buf + zstr.total_out);
    } 
    *zstr.next_out++ = (unsigned char)(crc & 0xff);
    *zstr.next_out++ = (unsigned char)((crc >> 8) & 0xff);
    *zstr.next_out++ = (unsigned char)((crc >> 16) & 0xff);
    *zstr.next_out++ = (unsigned char)((crc >> 24) & 0xff);

    *zstr.next_out++ = (unsigned char)(zstr.total_in & 0xff);
    *zstr.next_out++ = (unsigned char)((zstr.total_in >> 8) & 0xff);
    *zstr.next_out++ = (unsigned char)((zstr.total_in >> 16) & 0xff);
    *zstr.next_out++ = (unsigned char)((zstr.total_in >> 24) & 0xff);

    zstr.total_out += 8;
    zstr.avail_out -= 8;
    assert(zstr.avail_out + zstr.total_out == *size);
    assert(zstr.next_out == *buf + zstr.total_out);

    *len = zstr.total_out;

    zstatus = deflateEnd (&zstr);
    if (zstatus != Z_OK)
	compress_error (0, zstatus, &zstr, fullname);

    return 0;
}
#endif /* defined (SERVER_SUPPORT) || defined (CLIENT_SUPPORT) */
@


1.3
log
@cvs-1.11.12 doesn't do the joints correctly (what were the
FSF people smoking?), it memory faults.
thusly revert to 1.11.1p1

tested.
agreed bsiegert@@
@
text
@a18 1
#include <assert.h>
d24 5
a28 1
#include "zlib.h"
d52 8
a59 7
static void compress_error PROTO((int, int, z_stream *, const char *));
static int compress_buffer_input PROTO((void *, char *, int, int, int *));
static int compress_buffer_output PROTO((void *, const char *, int, int *));
static int compress_buffer_flush PROTO((void *));
static int compress_buffer_block PROTO((void *, int));
static int compress_buffer_shutdown_input PROTO((void *));
static int compress_buffer_shutdown_output PROTO((void *));
d64 1
a64 5
compress_error (status, zstatus, zstr, msg)
     int status;
     int zstatus;
     z_stream *zstr;
     const char *msg;
d75 1
a75 1
        snprintf (buf, sizeof buf, "error %d", zstatus);
d84 2
a86 1

d88 2
a89 5
compress_buffer_initialize (buf, input, level, memory)
     struct buffer *buf;
     int input;
     int level;
     void (*memory) PROTO((struct buffer *));
d94 1
a94 1
    n = (struct compress_buffer *) xmalloc (sizeof *n);
d119 1
a119 1
			   compress_buffer_block,
d127 2
a129 1

d131 2
a132 6
compress_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
     int size;
     int *got;
d134 1
a134 1
    struct compress_buffer *cb = (struct compress_buffer *) closure;
d137 1
a137 2
    if (cb->buf->input == NULL)
	abort ();
d150 1
a150 1
	bd = ((struct buffer_data *) malloc (sizeof (struct buffer_data)));
d153 1
a153 1
	bd->text = (char *) malloc (BUFFER_DATA_SIZE);
d169 2
a170 1
	int zstatus, sofar, status, nread;
d243 2
a245 1

d247 2
a248 5
compress_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
d250 1
a250 1
    struct compress_buffer *cb = (struct compress_buffer *) closure;
d283 2
a285 1

d287 1
a287 2
compress_buffer_flush (closure)
     void *closure;
d289 1
a289 1
    struct compress_buffer *cb = (struct compress_buffer *) closure;
d333 2
a335 1

d337 1
a337 3
compress_buffer_block (closure, block)
     void *closure;
     int block;
d339 1
a339 1
    struct compress_buffer *cb = (struct compress_buffer *) closure;
d347 12
a359 1

d361 1
a361 2
compress_buffer_shutdown_input (closure)
     void *closure;
d363 1
a363 1
    struct compress_buffer *cb = (struct compress_buffer *) closure;
d369 2
a370 1
	int status, nread;
d390 2
a392 1

d394 1
a394 2
compress_buffer_shutdown_output (closure)
     void *closure;
d396 1
a396 1
    struct compress_buffer *cb = (struct compress_buffer *) closure;
d437 14
d458 2
a459 5
gunzip_and_write (fd, fullname, buf, size)
    int fd;
    char *fullname;
    unsigned char *buf;
    size_t size;
d467 6
a472 1
    if (buf[0] != 31 || buf[1] != 139)
d477 1
a477 1
    if (buf[2] != 8)
d484 3
a486 1
       fields.  */
d488 7
a494 1
    if (buf[3] & 4)
d496 29
a524 5
    if (buf[3] & 8)
	pos += strlen ((char *) buf + pos) + 1;
    if (buf[3] & 16)
	pos += strlen ((char *) buf + pos) + 1;
    if (buf[3] & 2)
d526 13
d580 14
a593 4
    if (crc != (buf[zstr.total_in + 10]
		+ (buf[zstr.total_in + 11] << 8)
		+ (buf[zstr.total_in + 12] << 16)
		+ (buf[zstr.total_in + 13] << 24)))
d599 4
a602 4
    if (zstr.total_out != (buf[zstr.total_in + 14]
			   + (buf[zstr.total_in + 15] << 8)
			   + (buf[zstr.total_in + 16] << 16)
			   + (buf[zstr.total_in + 17] << 24)))
d612 1
a612 1
   replacing previous contents of *BUF.  *BUF is malloc'd and *SIZE is
d619 2
a620 7
read_and_gzip (fd, fullname, buf, size, len, level)
    int fd;
    char *fullname;
    unsigned char **buf;
    size_t *size;
    size_t *len;
    int level;
d633 1
a633 1
	newbuf = realloc (*buf, *size);
d641 3
a643 3
    (*buf)[0] = 31;
    (*buf)[1] = 139;
    (*buf)[2] = 8;
d659 4
a662 1
    zstr.avail_out = *size;
a683 2
	    size_t offset;

d693 2
a694 1
		offset = zstr.next_out - *buf;
d696 1
a696 1
		newbuf = realloc (*buf, *size);
d703 4
a706 2
		zstr.next_out = *buf + offset;
		zstr.avail_out = *size - offset;
d717 37
a753 9
    *(*buf + zstr.total_out + 10) = crc & 0xff;
    *(*buf + zstr.total_out + 11) = (crc >> 8) & 0xff;
    *(*buf + zstr.total_out + 12) = (crc >> 16) & 0xff;
    *(*buf + zstr.total_out + 13) = (crc >> 24) & 0xff;

    *(*buf + zstr.total_out + 14) = zstr.total_in & 0xff;
    *(*buf + zstr.total_out + 15) = (zstr.total_in >> 8) & 0xff;
    *(*buf + zstr.total_out + 16) = (zstr.total_in >> 16) & 0xff;
    *(*buf + zstr.total_out + 17) = (zstr.total_in >> 24) & 0xff;
d755 1
a755 1
    *len = zstr.total_out + 18;
@


1.2
log
@first step of merging new cvs
XXX might not compile
XXX might not work
XXX might contain bugs
XXX definitively needs autoconf 2.58 first
@
text
@d54 2
a55 2
static int compress_buffer_shutdown_input PROTO((struct buffer *));
static int compress_buffer_shutdown_output PROTO((struct buffer *));
d156 1
a156 1
	bd = ((struct buffer_data *) xmalloc (sizeof (struct buffer_data)));
d159 1
a159 1
	bd->text = (char *) xmalloc (BUFFER_DATA_SIZE);
d358 2
a359 2
compress_buffer_shutdown_input (buf)
     struct buffer *buf;
d361 1
a361 1
    struct compress_buffer *cb = (struct compress_buffer *) buf->closure;
d390 2
a391 2
compress_buffer_shutdown_output (buf)
     struct buffer *buf;
d393 1
a393 1
    struct compress_buffer *cb = (struct compress_buffer *) buf->closure;
a433 14
/* GZIP ID byte values */
#define GZIP_ID1	31
#define GZIP_ID2	139

/* Compression methods */
#define GZIP_CDEFLATE	8

/* Flags */
#define GZIP_FTEXT	1
#define GZIP_FHCRC	2
#define GZIP_FEXTRA	4
#define GZIP_FNAME	8
#define GZIP_FCOMMENT	16

d453 1
a453 6
    if (size < 10)
    {
	error (0, 0, "gzipped data too small - lacks complete header");
	return 1;
    }
    if (buf[0] != GZIP_ID1 || buf[1] != GZIP_ID2)
d458 1
a458 1
    if (buf[2] != GZIP_CDEFLATE)
d465 1
a465 3
       fields.  As we skip each field, we keep pos <= size. The checks
       on positions and lengths are really checks for malformed or 
       incomplete gzip data.  */
d467 1
a467 7
    if (buf[3] & GZIP_FEXTRA)
    {
	if (pos + 2 >= size) 
	{
	    error (0, 0, "%s lacks proper gzip XLEN field", fullname);
	    return 1;
	}
d469 5
a473 29
	if (pos > size) 
	{
	    error (0, 0, "%s lacks proper gzip \"extra field\"", fullname);
	    return 1;
	}

    }
    if (buf[3] & GZIP_FNAME)
    {
	unsigned char *p = memchr(buf + pos, '\0', size - pos);
	if (p == NULL)
	{
	    error (0, 0, "%s has bad gzip filename field", fullname);
	    return 1;
	}
	pos = p - buf + 1;
    }
    if (buf[3] & GZIP_FCOMMENT)
    {
	unsigned char *p = memchr(buf + pos, '\0', size - pos);
	if (p == NULL)
	{
	    error (0, 0, "%s has bad gzip comment field", fullname);
	    return 1;
	}
	pos = p - buf + 1;
    }
    if (buf[3] & GZIP_FHCRC)
    {
a474 13
	if (pos > size) 
	{
	    error (0, 0, "%s has bad gzip CRC16 field", fullname);
	    return 1;
	}
    }

    /* There could be no data to decompress - check and short circuit.  */
    if (pos >= size)
    {
	error (0, 0, "gzip data incomplete for %s (no data)", fullname);
	return 1;
    }
d516 4
a519 14
    /* Check that there is still 8 trailer bytes remaining (CRC32
       and ISIZE).  Check total decomp. data, plus header len (pos)
       against input buffer total size.  */
    pos += zstr.total_in;
    if (size - pos != 8)
    {
	error (0, 0, "gzip data incomplete for %s (no trailer)", fullname);
	return 1;
    }

    if (crc != (buf[pos]
		+ (buf[pos + 1] << 8)
		+ (buf[pos + 2] << 16)
		+ (buf[pos + 3] << 24)))
d525 4
a528 4
    if (zstr.total_out != (buf[pos + 4]
			   + (buf[pos + 5] << 8)
			   + (buf[pos + 6] << 16)
			   + (buf[pos + 7] << 24)))
d538 1
a538 1
   replacing previous contents of *BUF.  *BUF is xmalloc'd and *SIZE is
d564 1
a564 1
	newbuf = xrealloc (*buf, *size);
d572 3
a574 3
    (*buf)[0] = GZIP_ID1;
    (*buf)[1] = GZIP_ID2;
    (*buf)[2] = GZIP_CDEFLATE;
d590 1
a590 4
    
    /* Adjust for 10-byte output header (filled in above) */
    zstr.total_out = 10;
    zstr.avail_out = *size - 10;
d612 2
d623 1
a623 2
		assert(zstr.avail_out + zstr.total_out == *size);
		assert(zstr.next_out == *buf + zstr.total_out);
d625 1
a625 1
		newbuf = xrealloc (*buf, *size);
d632 2
a633 4
		zstr.next_out = *buf + zstr.total_out;
		zstr.avail_out = *size - zstr.total_out;
		assert(zstr.avail_out + zstr.total_out == *size);
		assert(zstr.next_out == *buf + zstr.total_out);
d644 9
a652 37
    /* Need to add the CRC information (8 bytes)
       to the end of the gzip'd output.
       Ensure there is enough space in the output buffer
       to do so.  */
    if (zstr.avail_out < 8)
    {
	unsigned char *newbuf;

	assert(zstr.avail_out + zstr.total_out == *size);
	assert(zstr.next_out == *buf + zstr.total_out);
	*size += 8 - zstr.avail_out;
	newbuf = realloc (*buf, *size);
	if (newbuf == NULL)
	{
	    error (0, 0, "out of memory");
	    return 1;
	}
	*buf = newbuf;
	zstr.next_out = *buf + zstr.total_out;
	zstr.avail_out = *size - zstr.total_out;
	assert(zstr.avail_out + zstr.total_out == *size);
	assert(zstr.next_out == *buf + zstr.total_out);
    } 
    *zstr.next_out++ = crc & 0xff;
    *zstr.next_out++ = (crc >> 8) & 0xff;
    *zstr.next_out++ = (crc >> 16) & 0xff;
    *zstr.next_out++ = (crc >> 24) & 0xff;

    *zstr.next_out++ = zstr.total_in & 0xff;
    *zstr.next_out++ = (zstr.total_in >> 8) & 0xff;
    *zstr.next_out++ = (zstr.total_in >> 16) & 0xff;
    *zstr.next_out++ = (zstr.total_in >> 24) & 0xff;

    zstr.total_out += 8;
    zstr.avail_out -= 8;
    assert(zstr.avail_out + zstr.total_out == *size);
    assert(zstr.next_out == *buf + zstr.total_out);
d654 1
a654 1
    *len = zstr.total_out;
@


1.1
log
@Initial revision
@
text
@d54 2
a55 2
static int compress_buffer_shutdown_input PROTO((void *));
static int compress_buffer_shutdown_output PROTO((void *));
d75 1
a75 1
        sprintf (buf, "error %d", zstatus);
d156 1
a156 1
	bd = ((struct buffer_data *) malloc (sizeof (struct buffer_data)));
d159 1
a159 1
	bd->text = (char *) malloc (BUFFER_DATA_SIZE);
d358 2
a359 2
compress_buffer_shutdown_input (closure)
     void *closure;
d361 1
a361 1
    struct compress_buffer *cb = (struct compress_buffer *) closure;
d390 2
a391 2
compress_buffer_shutdown_output (closure)
     void *closure;
d393 1
a393 1
    struct compress_buffer *cb = (struct compress_buffer *) closure;
d434 14
d467 6
a472 1
    if (buf[0] != 31 || buf[1] != 139)
d477 1
a477 1
    if (buf[2] != 8)
d484 3
a486 1
       fields.  */
d488 7
a494 1
    if (buf[3] & 4)
d496 29
a524 5
    if (buf[3] & 8)
	pos += strlen ((char *) buf + pos) + 1;
    if (buf[3] & 16)
	pos += strlen ((char *) buf + pos) + 1;
    if (buf[3] & 2)
d526 13
d580 14
a593 4
    if (crc != (buf[zstr.total_in + 10]
		+ (buf[zstr.total_in + 11] << 8)
		+ (buf[zstr.total_in + 12] << 16)
		+ (buf[zstr.total_in + 13] << 24)))
d599 4
a602 4
    if (zstr.total_out != (buf[zstr.total_in + 14]
			   + (buf[zstr.total_in + 15] << 8)
			   + (buf[zstr.total_in + 16] << 16)
			   + (buf[zstr.total_in + 17] << 24)))
d612 1
a612 1
   replacing previous contents of *BUF.  *BUF is malloc'd and *SIZE is
d638 1
a638 1
	newbuf = realloc (*buf, *size);
d646 3
a648 3
    (*buf)[0] = 31;
    (*buf)[1] = 139;
    (*buf)[2] = 8;
d664 4
a667 1
    zstr.avail_out = *size;
a688 2
	    size_t offset;

d698 2
a699 1
		offset = zstr.next_out - *buf;
d701 1
a701 1
		newbuf = realloc (*buf, *size);
d708 4
a711 2
		zstr.next_out = *buf + offset;
		zstr.avail_out = *size - offset;
d722 37
a758 9
    *(*buf + zstr.total_out + 10) = crc & 0xff;
    *(*buf + zstr.total_out + 11) = (crc >> 8) & 0xff;
    *(*buf + zstr.total_out + 12) = (crc >> 16) & 0xff;
    *(*buf + zstr.total_out + 13) = (crc >> 24) & 0xff;

    *(*buf + zstr.total_out + 14) = zstr.total_in & 0xff;
    *(*buf + zstr.total_out + 15) = (zstr.total_in >> 8) & 0xff;
    *(*buf + zstr.total_out + 16) = (zstr.total_in >> 16) & 0xff;
    *(*buf + zstr.total_out + 17) = (zstr.total_in >> 24) & 0xff;
d760 1
a760 1
    *len = zstr.total_out + 18;
@


1.1.2.1
log
@vendor-branch-ify new cvs 1.12
@
text
@d19 1
d25 1
a25 5
#if HAVE_ZLIB_H
# include <zlib.h>
#else
# include "zlib.h"
#endif
d49 7
a55 8
static void compress_error (int, int, z_stream *, const char *);
static int compress_buffer_input (void *, char *, size_t, size_t, size_t *);
static int compress_buffer_output (void *, const char *, size_t, size_t *);
static int compress_buffer_flush (void *);
static int compress_buffer_block (void *, bool);
static int compress_buffer_get_fd (void *);
static int compress_buffer_shutdown_input (struct buffer *);
static int compress_buffer_shutdown_output (struct buffer *);
d60 5
a64 1
compress_error (int status, int zstatus, z_stream *zstr, const char *msg)
d84 1
a85 2

/* Create a compression buffer.  */
d87 5
a91 2
compress_buffer_initialize (struct buffer *buf, int input, int level,
                            void (*memory) (struct buffer *))
d96 1
a96 1
    n = xmalloc (sizeof *n);
d121 1
a121 1
			   compress_buffer_block, compress_buffer_get_fd,
d129 1
a130 2

/* Input data from a compression buffer.  */
d132 6
a137 2
compress_buffer_input (void *closure, char *data, size_t need, size_t size,
		       size_t *got)
d139 1
a139 1
    struct compress_buffer *cb = closure;
d142 2
a143 1
    assert (cb->buf->input);
d156 1
a156 1
	bd = xmalloc (sizeof (struct buffer_data));
d159 1
a159 1
	bd->text = xmalloc (BUFFER_DATA_SIZE);
d175 1
a175 2
	int zstatus, sofar, status;
	size_t nread;
d248 1
a249 2

/* Output data to a compression buffer.  */
d251 5
a255 2
compress_buffer_output (void *closure, const char *data, size_t have,
			size_t *wrote)
d257 1
a257 1
    struct compress_buffer *cb = closure;
d290 1
a291 2

/* Flush a compression buffer.  */
d293 2
a294 1
compress_buffer_flush (void *closure)
d296 1
a296 1
    struct compress_buffer *cb = closure;
d340 1
a341 2

/* The block routine for a compression buffer.  */
d343 3
a345 1
compress_buffer_block (void *closure, bool block)
d347 1
a347 1
    struct compress_buffer *cb = closure;
d355 1
a356 12

/* Return the file descriptor underlying any child buffers.  */
static int
compress_buffer_get_fd (void *closure)
{
    struct compress_buffer *cb = closure;
    return buf_get_fd (cb->buf);
}



/* Shut down an input buffer.  */
d358 2
a359 1
compress_buffer_shutdown_input (struct buffer *buf)
d361 1
a361 1
    struct compress_buffer *cb = buf->closure;
d367 1
a367 2
	int status;
	size_t nread;
d387 1
a388 2

/* Shut down an output buffer.  */
d390 2
a391 1
compress_buffer_shutdown_output (struct buffer *buf)
d393 1
a393 1
    struct compress_buffer *cb = buf->closure;
a433 14
/* GZIP ID byte values */
#define GZIP_ID1	31
#define GZIP_ID2	139

/* Compression methods */
#define GZIP_CDEFLATE	8

/* Flags */
#define GZIP_FTEXT	1
#define GZIP_FHCRC	2
#define GZIP_FEXTRA	4
#define GZIP_FNAME	8
#define GZIP_FCOMMENT	16

d441 5
a445 2
gunzip_and_write (int fd, const char *fullname, unsigned char *buf,
		  size_t size)
d453 1
a453 6
    if (size < 10)
    {
	error (0, 0, "gzipped data too small - lacks complete header");
	return 1;
    }
    if (buf[0] != GZIP_ID1 || buf[1] != GZIP_ID2)
d458 1
a458 1
    if (buf[2] != GZIP_CDEFLATE)
d465 1
a465 3
       fields.  As we skip each field, we keep pos <= size. The checks
       on positions and lengths are really checks for malformed or 
       incomplete gzip data.  */
d467 1
a467 7
    if (buf[3] & GZIP_FEXTRA)
    {
	if (pos + 2 >= size) 
	{
	    error (0, 0, "%s lacks proper gzip XLEN field", fullname);
	    return 1;
	}
d469 5
a473 29
	if (pos > size) 
	{
	    error (0, 0, "%s lacks proper gzip \"extra field\"", fullname);
	    return 1;
	}

    }
    if (buf[3] & GZIP_FNAME)
    {
	unsigned char *p = memchr(buf + pos, '\0', size - pos);
	if (p == NULL)
	{
	    error (0, 0, "%s has bad gzip filename field", fullname);
	    return 1;
	}
	pos = p - buf + 1;
    }
    if (buf[3] & GZIP_FCOMMENT)
    {
	unsigned char *p = memchr(buf + pos, '\0', size - pos);
	if (p == NULL)
	{
	    error (0, 0, "%s has bad gzip comment field", fullname);
	    return 1;
	}
	pos = p - buf + 1;
    }
    if (buf[3] & GZIP_FHCRC)
    {
a474 13
	if (pos > size) 
	{
	    error (0, 0, "%s has bad gzip CRC16 field", fullname);
	    return 1;
	}
    }

    /* There could be no data to decompress - check and short circuit.  */
    if (pos >= size)
    {
	error (0, 0, "gzip data incomplete for %s (no data)", fullname);
	return 1;
    }
d516 4
a519 14
    /* Check that there is still 8 trailer bytes remaining (CRC32
       and ISIZE).  Check total decomp. data, plus header len (pos)
       against input buffer total size.  */
    pos += zstr.total_in;
    if (size - pos != 8)
    {
	error (0, 0, "gzip data incomplete for %s (no trailer)", fullname);
	return 1;
    }

    if (crc != ((unsigned long)buf[pos]
		+ ((unsigned long)buf[pos + 1] << 8)
		+ ((unsigned long)buf[pos + 2] << 16)
		+ ((unsigned long)buf[pos + 3] << 24)))
d525 4
a528 4
    if (zstr.total_out != ((unsigned long)buf[pos + 4]
			   + ((unsigned long)buf[pos + 5] << 8)
			   + ((unsigned long)buf[pos + 6] << 16)
			   + ((unsigned long)buf[pos + 7] << 24)))
d538 1
a538 1
   replacing previous contents of *BUF.  *BUF is xmalloc'd and *SIZE is
d545 7
a551 2
read_and_gzip (int fd, const char *fullname, unsigned char **buf, size_t *size,
               size_t *len, int level)
d564 1
a564 1
	newbuf = xrealloc (*buf, *size);
d572 3
a574 3
    (*buf)[0] = GZIP_ID1;
    (*buf)[1] = GZIP_ID2;
    (*buf)[2] = GZIP_CDEFLATE;
d590 1
a590 4
    
    /* Adjust for 10-byte output header (filled in above) */
    zstr.total_out = 10;
    zstr.avail_out = *size - 10;
d612 2
d623 1
a623 2
		assert(zstr.avail_out + zstr.total_out == *size);
		assert(zstr.next_out == *buf + zstr.total_out);
d625 1
a625 1
		newbuf = xrealloc (*buf, *size);
d632 2
a633 4
		zstr.next_out = *buf + zstr.total_out;
		zstr.avail_out = *size - zstr.total_out;
		assert(zstr.avail_out + zstr.total_out == *size);
		assert(zstr.next_out == *buf + zstr.total_out);
d644 9
a652 37
    /* Need to add the CRC information (8 bytes)
       to the end of the gzip'd output.
       Ensure there is enough space in the output buffer
       to do so.  */
    if (zstr.avail_out < 8)
    {
	unsigned char *newbuf;

	assert(zstr.avail_out + zstr.total_out == *size);
	assert(zstr.next_out == *buf + zstr.total_out);
	*size += 8 - zstr.avail_out;
	newbuf = realloc (*buf, *size);
	if (newbuf == NULL)
	{
	    error (0, 0, "out of memory");
	    return 1;
	}
	*buf = newbuf;
	zstr.next_out = *buf + zstr.total_out;
	zstr.avail_out = *size - zstr.total_out;
	assert(zstr.avail_out + zstr.total_out == *size);
	assert(zstr.next_out == *buf + zstr.total_out);
    } 
    *zstr.next_out++ = (unsigned char)(crc & 0xff);
    *zstr.next_out++ = (unsigned char)((crc >> 8) & 0xff);
    *zstr.next_out++ = (unsigned char)((crc >> 16) & 0xff);
    *zstr.next_out++ = (unsigned char)((crc >> 24) & 0xff);

    *zstr.next_out++ = (unsigned char)(zstr.total_in & 0xff);
    *zstr.next_out++ = (unsigned char)((zstr.total_in >> 8) & 0xff);
    *zstr.next_out++ = (unsigned char)((zstr.total_in >> 16) & 0xff);
    *zstr.next_out++ = (unsigned char)((zstr.total_in >> 24) & 0xff);

    zstr.total_out += 8;
    zstr.avail_out -= 8;
    assert(zstr.avail_out + zstr.total_out == *size);
    assert(zstr.next_out == *buf + zstr.total_out);
d654 1
a654 1
    *len = zstr.total_out;
@


1.1.3.1
log
@our CVS is currently at 1.11.1p1, thus import that version into vendor branch
@
text
@@


1.1.3.2
log
@CVS 1.11.12 is the latest stable version of CVS,
released 06.02.2004, with a huge lot of bug fixes.

/me hopes this will pay off...
@
text
@d54 2
a55 2
static int compress_buffer_shutdown_input PROTO((struct buffer *));
static int compress_buffer_shutdown_output PROTO((struct buffer *));
d156 1
a156 1
	bd = ((struct buffer_data *) xmalloc (sizeof (struct buffer_data)));
d159 1
a159 1
	bd->text = (char *) xmalloc (BUFFER_DATA_SIZE);
d358 2
a359 2
compress_buffer_shutdown_input (buf)
     struct buffer *buf;
d361 1
a361 1
    struct compress_buffer *cb = (struct compress_buffer *) buf->closure;
d390 2
a391 2
compress_buffer_shutdown_output (buf)
     struct buffer *buf;
d393 1
a393 1
    struct compress_buffer *cb = (struct compress_buffer *) buf->closure;
a433 14
/* GZIP ID byte values */
#define GZIP_ID1	31
#define GZIP_ID2	139

/* Compression methods */
#define GZIP_CDEFLATE	8

/* Flags */
#define GZIP_FTEXT	1
#define GZIP_FHCRC	2
#define GZIP_FEXTRA	4
#define GZIP_FNAME	8
#define GZIP_FCOMMENT	16

d453 1
a453 6
    if (size < 10)
    {
	error (0, 0, "gzipped data too small - lacks complete header");
	return 1;
    }
    if (buf[0] != GZIP_ID1 || buf[1] != GZIP_ID2)
d458 1
a458 1
    if (buf[2] != GZIP_CDEFLATE)
d465 1
a465 3
       fields.  As we skip each field, we keep pos <= size. The checks
       on positions and lengths are really checks for malformed or 
       incomplete gzip data.  */
d467 1
a467 7
    if (buf[3] & GZIP_FEXTRA)
    {
	if (pos + 2 >= size) 
	{
	    error (0, 0, "%s lacks proper gzip XLEN field", fullname);
	    return 1;
	}
d469 5
a473 29
	if (pos > size) 
	{
	    error (0, 0, "%s lacks proper gzip \"extra field\"", fullname);
	    return 1;
	}

    }
    if (buf[3] & GZIP_FNAME)
    {
	unsigned char *p = memchr(buf + pos, '\0', size - pos);
	if (p == NULL)
	{
	    error (0, 0, "%s has bad gzip filename field", fullname);
	    return 1;
	}
	pos = p - buf + 1;
    }
    if (buf[3] & GZIP_FCOMMENT)
    {
	unsigned char *p = memchr(buf + pos, '\0', size - pos);
	if (p == NULL)
	{
	    error (0, 0, "%s has bad gzip comment field", fullname);
	    return 1;
	}
	pos = p - buf + 1;
    }
    if (buf[3] & GZIP_FHCRC)
    {
a474 13
	if (pos > size) 
	{
	    error (0, 0, "%s has bad gzip CRC16 field", fullname);
	    return 1;
	}
    }

    /* There could be no data to decompress - check and short circuit.  */
    if (pos >= size)
    {
	error (0, 0, "gzip data incomplete for %s (no data)", fullname);
	return 1;
    }
d516 4
a519 14
    /* Check that there is still 8 trailer bytes remaining (CRC32
       and ISIZE).  Check total decomp. data, plus header len (pos)
       against input buffer total size.  */
    pos += zstr.total_in;
    if (size - pos != 8)
    {
	error (0, 0, "gzip data incomplete for %s (no trailer)", fullname);
	return 1;
    }

    if (crc != (buf[pos]
		+ (buf[pos + 1] << 8)
		+ (buf[pos + 2] << 16)
		+ (buf[pos + 3] << 24)))
d525 4
a528 4
    if (zstr.total_out != (buf[pos + 4]
			   + (buf[pos + 5] << 8)
			   + (buf[pos + 6] << 16)
			   + (buf[pos + 7] << 24)))
d538 1
a538 1
   replacing previous contents of *BUF.  *BUF is xmalloc'd and *SIZE is
d564 1
a564 1
	newbuf = xrealloc (*buf, *size);
d572 3
a574 3
    (*buf)[0] = GZIP_ID1;
    (*buf)[1] = GZIP_ID2;
    (*buf)[2] = GZIP_CDEFLATE;
d590 1
a590 4
    
    /* Adjust for 10-byte output header (filled in above) */
    zstr.total_out = 10;
    zstr.avail_out = *size - 10;
d612 2
d623 1
a623 2
		assert(zstr.avail_out + zstr.total_out == *size);
		assert(zstr.next_out == *buf + zstr.total_out);
d625 1
a625 1
		newbuf = xrealloc (*buf, *size);
d632 2
a633 4
		zstr.next_out = *buf + zstr.total_out;
		zstr.avail_out = *size - zstr.total_out;
		assert(zstr.avail_out + zstr.total_out == *size);
		assert(zstr.next_out == *buf + zstr.total_out);
d644 9
a652 37
    /* Need to add the CRC information (8 bytes)
       to the end of the gzip'd output.
       Ensure there is enough space in the output buffer
       to do so.  */
    if (zstr.avail_out < 8)
    {
	unsigned char *newbuf;

	assert(zstr.avail_out + zstr.total_out == *size);
	assert(zstr.next_out == *buf + zstr.total_out);
	*size += 8 - zstr.avail_out;
	newbuf = realloc (*buf, *size);
	if (newbuf == NULL)
	{
	    error (0, 0, "out of memory");
	    return 1;
	}
	*buf = newbuf;
	zstr.next_out = *buf + zstr.total_out;
	zstr.avail_out = *size - zstr.total_out;
	assert(zstr.avail_out + zstr.total_out == *size);
	assert(zstr.next_out == *buf + zstr.total_out);
    } 
    *zstr.next_out++ = crc & 0xff;
    *zstr.next_out++ = (crc >> 8) & 0xff;
    *zstr.next_out++ = (crc >> 16) & 0xff;
    *zstr.next_out++ = (crc >> 24) & 0xff;

    *zstr.next_out++ = zstr.total_in & 0xff;
    *zstr.next_out++ = (zstr.total_in >> 8) & 0xff;
    *zstr.next_out++ = (zstr.total_in >> 16) & 0xff;
    *zstr.next_out++ = (zstr.total_in >> 24) & 0xff;

    zstr.total_out += 8;
    zstr.avail_out -= 8;
    assert(zstr.avail_out + zstr.total_out == *size);
    assert(zstr.next_out == *buf + zstr.total_out);
d654 1
a654 1
    *len = zstr.total_out;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d75 1
a75 1
        snprintf (buf, sizeof buf, "error %d", zstatus);
@

