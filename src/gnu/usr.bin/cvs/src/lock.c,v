head	1.4;
access;
symbols
	cvs-1_12_11:1.1.2.1
	tg-mergetmp-mirosx-1:1.4
	tg-mergefixes-1-branch:1.4.0.4
	tg-mergefixes-1-base:1.4
	MIROS_X:1.4.0.2
	MIROS_X_BASE:1.4
	cvs-1_12_10:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_MIRPPC:1.3.0.4
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200404170130:1.1.1.1
	cvs-1_11_12:1.1.3.2
	cvs-1_11_1p1:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.12.02.12.40.17;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.22.13.49.15;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.02.12.21.16.15;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.28;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.41.28;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2004.12.02.11.58.56;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.02.12.19.18.58;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.12.19.39.27;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@update to cvs 1.12.10-MirOS except automatically
generated files
XXX this installs as /usr/bin/ncvs yet, so no
XXX conflicts during the test phase.
XXX I suggest to _not_ update.

XXX *** IMPORTANT *** DO NOT ACCESS CVS 1.11 REPOSITORIES
XXX *** IMPORTANT *** WITH CVS 1.12 OR VICE VERSA!
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * Set Lock
 * 
 * Lock file support for CVS.
 */

/* The node Concurrency in doc/cvs.texinfo has a brief introduction to
   how CVS locks function, and some of the user-visible consequences of
   their existence.  Here is a summary of why they exist (and therefore,
   the consequences of hacking CVS to read a repository without creating
   locks):

   There are two uses.  One is the ability to prevent there from being
   two writers at the same time.  This is necessary for any number of
   reasons (fileattr code, probably others).  Commit needs to lock the
   whole tree so that nothing happens between the up-to-date check and
   the actual checkin.

   The second use is the ability to ensure that there is not a writer
   and a reader at the same time (several readers are allowed).  Reasons
   for this are:

   * Readlocks ensure that once CVS has found a collection of rcs
   files using Find_Names, the files will still exist when it reads
   them (they may have moved in or out of the attic).

   * Readlocks provide some modicum of consistency, although this is
   kind of limited--see the node Concurrency in cvs.texinfo.

   * Readlocks ensure that the RCS file does not change between
   RCS_parse and RCS_reparsercsfile time.  This one strikes me as
   important, although I haven't thought up what bad scenarios might
   be.

   * Readlocks ensure that we won't find the file in the state in
   which it is in between the calls to add_rcs_file and RCS_checkin in
   commit.c (when a file is being added).  This state is a state in
   which the RCS file parsing routines in rcs.c cannot parse the file.

   * Readlocks ensure that a reader won't try to look at a
   half-written fileattr file (fileattr is not updated atomically).

   (see also the description of anonymous read-only access in
   "Password authentication security" node in doc/cvs.texinfo).

   While I'm here, I'll try to summarize a few random suggestions
   which periodically get made about how locks might be different:

   1.  Check for EROFS.  Maybe useful, although in the presence of NFS
   EROFS does *not* mean that the file system is unchanging.

   2.  Provide an option to disable locks for operations which only
   read (see above for some of the consequences).

   3.  Have a server internally do the locking.  Probably a good
   long-term solution, and many people have been working hard on code
   changes which would eventually make it possible to have a server
   which can handle various connections in one process, but there is
   much, much work still to be done before this is feasible.  */

#include "cvs.h"



struct lock {
    /* This is the directory in which we may have a lock named by the
       readlock variable, a lock named by the writelock variable, and/or
       a lock named CVSLCK.  The storage is not allocated along with the
       struct lock; it is allocated by the Reader_Lock caller or in the
       case of promotablelocks, it is just a pointer to the storage allocated
       for the ->key field.  */
    const char *repository;

    /* The name of the lock files. */
    char *file1;
#ifdef LOCK_COMPATIBILITY
    char *file2;
#endif /* LOCK_COMPATIBILITY */

    /* Do we have a lock named CVSLCK?  */
    int have_lckdir;
    /* Note there is no way of knowing whether the readlock and writelock
       exist.  The code which sets the locks doesn't use SIG_beginCrSect
       to set a flag like we do for CVSLCK.  */
    int free_repository;
};

static void remove_locks (void);
static int set_lock (struct lock *lock, int will_wait);
static void clear_lock (struct lock *lock);
static void set_lockers_name (struct stat *statp);

/* Malloc'd array containing the username of the whoever has the lock.
   Will always be non-NULL in the cases where it is needed.  */
static char *lockers_name;
/* Malloc'd array specifying name of a readlock within a directory.
   Or NULL if none.  */
static char *readlock;
/* Malloc'd array specifying name of a writelock within a directory.
   Or NULL if none.  */
static char *writelock;
/* Malloc'd array specifying name of a promotablelock within a directory.
   Or NULL if none.  */
static char *promotablelock;
/* Malloc'd array specifying the name of a CVSLCK file (absolute pathname).
   Will always be non-NULL in the cases where it is used.  */
static char *masterlock;
static List *locklist;

#define L_OK		0		/* success */
#define L_ERROR		1		/* error condition */
#define L_LOCKED	2		/* lock owned by someone else */

/* This is the (single) readlock which is set by Reader_Lock.  The
   repository field is NULL if there is no such lock.  */
static struct lock global_readlock;
static struct lock global_writelock;

/* List of locks set by lock_tree_for_write.  This is redundant
   with locklist, sort of.  */
static List *lock_tree_list;



/* Return a newly malloc'd string containing the name of the lock for the
   repository REPOSITORY and the lock file name within that directory
   NAME.  Also create the directories in which to put the lock file
   if needed (if we need to, could save system call(s) by doing
   that only if the actual operation fails.  But for now we'll keep
   things simple).  */
static char *
lock_name (const char *repository, const char *name)
{
    char *retval;
    const char *p;
    char *q;
    const char *short_repos;
    mode_t save_umask = 0000;
    int saved_umask = 0;

    TRACE (TRACE_FLOW, "lock_name (%s, %s)",
	   repository  ? repository : "(null)", name ? name : "(null)");

    if (!config->lock_dir)
    {
	/* This is the easy case.  Because the lock files go directly
	   in the repository, no need to create directories or anything.  */
	assert (name != NULL);
	assert (repository != NULL);
	retval = xmalloc (strlen (repository) + strlen (name) + 10);
	(void) sprintf (retval, "%s/%s", repository, name);
    }
    else
    {
	struct stat sb;
	mode_t new_mode = 0;

	/* The interesting part of the repository is the part relative
	   to CVSROOT.  */
	assert (current_parsed_root != NULL);
	assert (current_parsed_root->directory != NULL);
	assert (strncmp (repository, current_parsed_root->directory,
			 strlen (current_parsed_root->directory)) == 0);
	short_repos = repository + strlen (current_parsed_root->directory) + 1;

	if (strcmp (repository, current_parsed_root->directory) == 0)
	    short_repos = ".";
	else
	    assert (short_repos[-1] == '/');

	retval = xmalloc (strlen (config->lock_dir)
			  + strlen (short_repos)
			  + strlen (name)
			  + 10);
	strcpy (retval, config->lock_dir);
	q = retval + strlen (retval);
	*q++ = '/';

	strcpy (q, short_repos);

	/* In the common case, where the directory already exists, let's
	   keep it to one system call.  */
	if (CVS_STAT (retval, &sb) < 0)
	{
	    /* If we need to be creating more than one directory, we'll
	       get the existence_error here.  */
	    if (!existence_error (errno))
		error (1, errno, "cannot stat directory %s", retval);
	}
	else
	{
	    if (S_ISDIR (sb.st_mode))
		goto created;
	    else
		error (1, 0, "%s is not a directory", retval);
	}

	/* Now add the directories one at a time, so we can create
	   them if needed.

	   The idea behind the new_mode stuff is that the directory we
	   end up creating will inherit permissions from its parent
	   directory (we re-set new_mode with each EEXIST).  CVSUMASK
	   isn't right, because typically the reason for LockDir is to
	   use a different set of permissions.  We probably want to
	   inherit group ownership also (but we don't try to deal with
	   that, some systems do it for us either always or when g+s is on).

	   We don't try to do anything about the permissions on the lock
	   files themselves.  The permissions don't really matter so much
	   because the locks will generally be removed by the process
	   which created them.  */

	if (CVS_STAT (config->lock_dir, &sb) < 0)
	    error (1, errno, "cannot stat %s", config->lock_dir);
	new_mode = sb.st_mode;
	save_umask = umask (0000);
	saved_umask = 1;

	p = short_repos;
	while (1)
	{
	    while (!ISSLASH (*p) && *p != '\0')
		++p;
	    if (ISSLASH (*p))
	    {
		strncpy (q, short_repos, p - short_repos);
		q[p - short_repos] = '\0';
		if (!ISSLASH (q[p - short_repos - 1])
		    && CVS_MKDIR (retval, new_mode) < 0)
		{
		    int saved_errno = errno;
		    if (saved_errno != EEXIST)
			error (1, errno, "cannot make directory %s", retval);
		    else
		    {
			if (CVS_STAT (retval, &sb) < 0)
			    error (1, errno, "cannot stat %s", retval);
			new_mode = sb.st_mode;
		    }
		}
		++p;
	    }
	    else
	    {
		strcpy (q, short_repos);
		if (CVS_MKDIR (retval, new_mode) < 0
		    && errno != EEXIST)
		    error (1, errno, "cannot make directory %s", retval);
		goto created;
	    }
	}
    created:;

	strcat (retval, "/");
	strcat (retval, name);

	if (saved_umask)
	{
	    assert (umask (save_umask) == 0000);
	    saved_umask = 0;
	}
    }
    return retval;
}



/* Remove the lock files.  For interrupt purposes, it can be assumed that the
 * first thing this function does is set lock->repository to NULL.
 *
 * INPUTS
 *   lock	The lock to remove.
 *   free	True if this lock directory will not5 be reused (free
 *		lock->repository if necessary).
 */
static void
remove_lock_files (struct lock *lock, int free_repository)
{
    TRACE (TRACE_FLOW, "remove_lock_files (%s)", lock->repository);

    /* If lock->file is set, the lock *might* have been created, but since
     * Reader_Lock & lock_dir_for_write don't use SIG_beginCrSect the way that
     * set_lock does, we don't know that.  That is why we need to check for
     * existence_error here.
     */
    if (lock->file1)
    {
	char *tmp = lock->file1;
	lock->file1 = NULL;
	if (CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
	    error (0, errno, "failed to remove lock %s", tmp);
	free (tmp);
    }
#ifdef LOCK_COMPATIBILITY
    if (lock->file2)
    {
	char *tmp = lock->file2;
	lock->file2 = NULL;
	if (CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
	    error (0, errno, "failed to remove lock %s", tmp);
	free (tmp);
    }
#endif /* LOCK_COMPATIBILITY */

    if (lock->have_lckdir)
    {
	char *tmp = lock_name (lock->repository, CVSLCK);
	SIG_beginCrSect ();
	if (CVS_RMDIR (tmp) < 0)
	    error (0, errno, "failed to remove lock dir %s", tmp);
	lock->have_lckdir = 0;
	SIG_endCrSect ();
	free (tmp);
    }

    /* And free the repository string.  We don't really have to set the
     * repository string to NULL first since there is no harm in running any of
     * the above code twice.
     *
     * Use SIG_beginCrSect since otherwise we might be interrupted between
     * checking whether free_repository is set and freeing stuff.
     */
    if (free_repository)
    {
	SIG_beginCrSect ();
	if (lock->free_repository)
	{
	    free ((char *)lock->repository);
	    lock->free_repository = 0;
	}
	lock->repository = NULL;
	SIG_endCrSect ();
    }
}



/*
 * Clean up outstanding read and write locks and free their storage.
 */
void
Simple_Lock_Cleanup (void)
{
    TRACE (TRACE_FUNCTION, "Simple_Lock_Cleanup()");

    /* Avoid interrupts while accessing globals the interrupt handlers might
     * make use of.
     */
    SIG_beginCrSect();

    /* clean up simple read locks (if any) */
    if (global_readlock.repository != NULL)
	remove_lock_files (&global_readlock, 1);
    /* See note in Lock_Cleanup() below.  */
    SIG_endCrSect();

    SIG_beginCrSect();

    /* clean up simple write locks (if any) */
    if (global_writelock.repository != NULL)
	remove_lock_files (&global_writelock, 1);
    /* See note in Lock_Cleanup() below.  */
    SIG_endCrSect();
}



/*
 * Clean up all outstanding locks and free their storage.
 *
 * NOTES
 *   This function needs to be reentrant since a call to exit() can cause a
 *   call to this function, which can then be interrupted by a signal, which
 *   can cause a second call to this function.
 *
 * RETURNS
 *   Nothing.
 */
void
Lock_Cleanup (void)
{
    TRACE (TRACE_FUNCTION, "Lock_Cleanup()");

    /* FIXME: Do not perform buffered I/O from an interrupt handler like
     * this (via error).  However, I'm leaving the error-calling code there
     * in the hope that on the rare occasion the error call is actually made
     * (e.g., a fluky I/O error or permissions problem prevents the deletion
     * of a just-created file) reentrancy won't be an issue.
     */

    remove_locks ();

    /* Avoid being interrupted during calls which set globals to NULL.  This
     * avoids having interrupt handlers attempt to use these global variables
     * in inconsistent states.
     *
     * This isn't always necessary, because sometimes we are called via exit()
     * or the interrupt handler, in which case signals will already be blocked,
     * but sometimes we might be called from elsewhere.
     */
    SIG_beginCrSect();
    dellist (&lock_tree_list);
    /*  Unblocking allows any signal to be processed as soon as possible.  This
     *  isn't really necessary, but since we know signals can cause us to be
     *  called, why not avoid having blocks of code run twice.
     */
    SIG_endCrSect();
}



/*
 * walklist proc for removing a list of locks
 */
static int
unlock_proc (Node *p, void *closure)
{
    remove_lock_files (p->data, 0);
    return 0;
}



/*
 * Remove locks without discarding the lock information.
 */
static void
remove_locks (void)
{
    TRACE (TRACE_FLOW, "remove_locks()");

    Simple_Lock_Cleanup ();

    /* clean up promotable locks (if any) */
    SIG_beginCrSect();
    if (locklist != NULL)
    {
	/* Use a tmp var since any of these functions could call exit, causing
	 * us to be called a second time.
	 */
	List *tmp = locklist;
	locklist = NULL;
	walklist (tmp, unlock_proc, NULL);
    }
    SIG_endCrSect();
}



/*
 * Set the global readlock variable if it isn't already.
 */
static void
set_readlock_name (void)
{
    if (readlock == NULL)
    {
	readlock = xmalloc (strlen (hostname) + sizeof (CVSRFL) + 40);
	(void) sprintf (readlock, 
#ifdef HAVE_LONG_FILE_NAMES
			"%s.%s.%ld", CVSRFL, hostname,
#else
			"%s.%ld", CVSRFL,
#endif
			(long) getpid ());
    }
}



/*
 * Create a lock file for readers
 */
int
Reader_Lock (char *xrepository)
{
    int err = 0;
    FILE *fp;

    TRACE (TRACE_FUNCTION, "Reader_Lock(%s)", xrepository);

    if (noexec || readonlyfs)
	return 0;

    /* we only do one directory at a time for read locks!  */
    if (global_readlock.repository != NULL)
    {
	error (0, 0, "Reader_Lock called while read locks set - Help!");
	return 1;
    }

    set_readlock_name ();

    /* remember what we're locking (for Lock_Cleanup) */
    global_readlock.repository = xstrdup (xrepository);
    global_readlock.free_repository = 1;

    /* get the lock dir for our own */
    if (set_lock (&global_readlock, 1) != L_OK)
    {
	error (0, 0, "failed to obtain dir lock in repository `%s'",
	       xrepository);
	if (readlock != NULL)
	    free (readlock);
	readlock = NULL;
	/* We don't set global_readlock.repository to NULL.  I think this
	   only works because recurse.c will give a fatal error if we return
	   a nonzero value.  */
	return 1;
    }

    /* write a read-lock */
    global_readlock.file1 = lock_name (xrepository, readlock);
    if ((fp = CVS_FOPEN (global_readlock.file1, "w+")) == NULL
	|| fclose (fp) == EOF)
    {
	error (0, errno, "cannot create read lock in repository `%s'",
	       xrepository);
	err = 1;
    }

    /* free the lock dir */
    clear_lock (&global_readlock);

    return err;
}



/*
 * lock_exists() returns 0 if there is no lock file matching FILEPAT in
 * the repository but not IGNORE; else 1 is returned, to indicate that the
 * caller should sleep a while and try again.
 *
 * INPUTS
 *   repository		The repository directory to search for locks.
 *   filepat		The file name pattern to search for.
 *   ignore		The name of a single file which can be ignored.
 *
 * GLOBALS
 *   lockdir		The lock dir external to the repository, if any.
 *
 * RETURNS
 *   0		No lock matching FILEPAT and not IGNORE exists.
 *   1		Otherwise and on error.
 *
 * ERRORS
 *  In the case where errors are encountered reading the directory, a warning
 *  message is printed, 1 is is returned and ERRNO is left set.
 */
static int
lock_exists (const char *repository, const char *filepat, const char *ignore)
{
    char *lockdir;
    char *line;
    DIR *dirp;
    struct dirent *dp;
    struct stat sb;
    int ret;
#ifdef CVS_FUDGELOCKS
    time_t now;
    (void)time (&now);
#endif

    TRACE (TRACE_FLOW, "lock_exists (%s, %s, %s)",
	   repository, filepat, ignore ? ignore : "(null)");

    lockdir = lock_name (repository, "");
    lockdir[strlen (lockdir) - 1] = '\0';   /* remove trailing slash */

    do {
	if ((dirp = CVS_OPENDIR (lockdir)) == NULL)
	    error (1, 0, "cannot open directory %s", lockdir);

	ret = 0;
	errno = 0;
	while ((dp = CVS_READDIR (dirp)) != NULL)
	{
	    if (CVS_FNMATCH (filepat, dp->d_name, 0) == 0)
	    {
		/* FIXME: the basename conversion below should be replaced with
		 * a call to the GNULIB basename function once it is imported.
		 */
		/* ignore our plock, if any */
		if (ignore && !fncmp (ignore, dp->d_name))
		    continue;

		line = xmalloc (strlen (lockdir) + 1 + strlen (dp->d_name) + 1);
		(void)sprintf (line, "%s/%s", lockdir, dp->d_name);
		if (CVS_STAT (line, &sb) != -1)
		{
#ifdef CVS_FUDGELOCKS
		    /*
		     * If the create time of the file is more than CVSLCKAGE 
		     * seconds ago, try to clean-up the lock file, and if
		     * successful, re-open the directory and try again.
		     */
		    if (now >= (sb.st_ctime + CVSLCKAGE) &&
                        CVS_UNLINK (line) != -1)
		    {
			free (line);
			ret = -1;
			break;
		    }
#endif
		    set_lockers_name (&sb);
		}
		else
		{
		    /* If the file doesn't exist, it just means that it
		     * disappeared between the time we did the readdir and the
		     * time we did the stat.
		     */
		    if (!existence_error (errno))
			error (0, errno, "cannot stat %s", line);
		}
		errno = 0;
		free (line);
		ret = 1;
		break;
	    }
	    errno = 0;
	}
	if (errno != 0)
	    error (0, errno, "error reading directory %s", repository);

	CVS_CLOSEDIR (dirp);
    } while (ret < 0);

    if (lockdir != NULL)
	free (lockdir);
    return ret;
}



/*
 * readers_exist() returns 0 if there are no reader lock files remaining in
 * the repository; else 1 is returned, to indicate that the caller should
 * sleep a while and try again.
 *
 * See lock_exists() for argument detail.
 */
static int
readers_exist (const char *repository)
{
    TRACE (TRACE_FLOW, "readers_exist (%s)", repository);

    /* It is only safe to ignore a readlock set by our process if it was set as
     * a safety measure to prevent older CVS processes from ignoring our
     * promotable locks.  The code to ignore these readlocks can be removed
     * once it is deemed unlikely that anyone will be using CVS servers earlier
     * than version 1.12.4.
     */
    return lock_exists (repository, CVSRFLPAT,
#ifdef LOCK_COMPATIBILITY
                         findnode (locklist, repository) ? readlock : 
#endif /* LOCK_COMPATIBILITY */
			 NULL);
}



/*
 * promotable_exists() returns 0 if there is no promotable lock file in
 * the repository; else 1 is returned, to indicate that the caller should
 * sleep a while and try again.
 *
 * See lock_exists() for argument detail.
 */
static int
promotable_exists (const char *repository)
{
    TRACE (TRACE_FLOW, "promotable_exists (%s)", repository);
    return lock_exists (repository, CVSPFLPAT, promotablelock);
}



/*
 * Lock a list of directories for writing
 */
static char *lock_error_repos;
static int lock_error;



/*
 * Create a lock file for potential writers returns L_OK if lock set ok,
 * L_LOCKED if lock held by someone else or L_ERROR if an error occurred.
 */
static int
set_promotable_lock (struct lock *lock)
{
    int status;
    FILE *fp;

    TRACE (TRACE_FUNCTION, "set_promotable_lock(%s)",
	   lock->repository ? lock->repository : "(null)");

    if (promotablelock == NULL)
    {
	promotablelock = xmalloc (strlen (hostname) + sizeof (CVSPFL) + 40);
	(void) sprintf (promotablelock,
#ifdef HAVE_LONG_FILE_NAMES
			"%s.%s.%ld", CVSPFL, hostname,
#else
			"%s.%ld", CVSPFL,
#endif
			(long) getpid());
    }

    /* make sure the lock dir is ours (not necessarily unique to us!) */
    status = set_lock (lock, 0);
    if (status == L_OK)
    {
	/* we now own a promotable lock - make sure there are no others */
	if (promotable_exists (lock->repository))
	{
	    /* clean up the lock dir */
	    clear_lock (lock);

	    /* indicate we failed due to read locks instead of error */
	    return L_LOCKED;
	}

	/* write the promotable-lock file */
	lock->file1 = lock_name (lock->repository, promotablelock);
	if ((fp = CVS_FOPEN (lock->file1, "w+")) == NULL || fclose (fp) == EOF)
	{
	    int xerrno = errno;

	    if (CVS_UNLINK (lock->file1) < 0 && ! existence_error (errno))
		error (0, errno, "failed to remove lock %s", lock->file1);

	    /* free the lock dir */
	    clear_lock (lock);

	    /* return the error */
	    error (0, xerrno,
		   "cannot create promotable lock in repository `%s'",
		   lock->repository);
	    return L_ERROR;
	}

#ifdef LOCK_COMPATIBILITY
	/* write the read-lock file.  We only do this so that older versions of
	 * CVS will not think it is okay to create a write lock.  When it is
	 * decided that versions of CVS earlier than 1.12.4 are not likely to
	 * be used, this code can be removed.
	 */
	set_readlock_name ();
	lock->file2 = lock_name (lock->repository, readlock);
	if ((fp = CVS_FOPEN (lock->file2, "w+")) == NULL || fclose (fp) == EOF)
	{
	    int xerrno = errno;

	    if ( CVS_UNLINK (lock->file2) < 0 && ! existence_error (errno))
		error (0, errno, "failed to remove lock %s", lock->file2);

	    /* free the lock dir */
	    clear_lock (lock);

	    /* Remove the promotable lock.  */
	    lock->file2 = NULL;
	    remove_lock_files (lock, 0);

	    /* return the error */
	    error (0, xerrno,
		   "cannot create read lock in repository `%s'",
		   lock->repository);
	    return L_ERROR;
	}
#endif /* LOCK_COMPATIBILITY */

	clear_lock (lock);

	return L_OK;
    }
    else
	return status;
}



/*
 * walklist proc for setting write locks.  Mostly just a wrapper for the
 * set_promotable_lock function, which has a prettier API, but no other good
 * reason for existing separately.
 *
 * INPUTS
 *   p		The current node, as determined by walklist().
 *   closure	Not used.
 *
 * GLOBAL INPUTS
 *   lock_error		Any previous error encountered while attempting to get
 *                      a lock.
 *
 * GLOBAL OUTPUTS
 *   lock_error		Set if we encounter an error attempting to get axi
 *			promotable lock.
 *   lock_error_repos	Set so that if we set lock_error later functions will
 *			be able to report where the other process's lock was
 *			encountered.
 *
 * RETURNS
 *   0 for no error.
 */
static int
set_promotablelock_proc (Node *p, void *closure)
{
    /* if some lock was not OK, just skip this one */
    if (lock_error != L_OK)
	return 0;

    /* apply the write lock */
    lock_error_repos = p->key;
    lock_error = set_promotable_lock ((struct lock *)p->data);
    return 0;
}



/*
 * Print out a message that the lock is still held, then sleep a while.
 */
static void
lock_wait (const char *repos)
{
    time_t now;
    char *msg;
    struct tm *tm_p;

    (void) time (&now);
    tm_p = gmtime (&now);
    msg = xmalloc (100 + strlen (lockers_name) + strlen (repos));
    sprintf (msg, "[%8.8s] waiting for %s's lock in %s",
	     (tm_p ? asctime (tm_p) : ctime (&now)) + 11,
	     lockers_name, repos);
    error (0, 0, "%s", msg);
    /* Call cvs_flusherr to ensure that the user sees this message as
       soon as possible.  */
    cvs_flusherr ();
    free (msg);
    (void)sleep (CVSLCKSLEEP);
}



/*
 * Print out a message when we obtain a lock.
 */
static void
lock_obtained (const char *repos)
{
    time_t now;
    char *msg;
    struct tm *tm_p;

    (void) time (&now);
    tm_p = gmtime (&now);
    msg = xmalloc (100 + strlen (repos));
    sprintf (msg, "[%8.8s] obtained lock in %s",
	     (tm_p ? asctime (tm_p) : ctime (&now)) + 11, repos);
    error (0, 0, "%s", msg);
    /* Call cvs_flusherr to ensure that the user sees this message as
       soon as possible.  */
    cvs_flusherr ();
    free (msg);
}



static int
lock_list_promotably (List *list)
{
    char *wait_repos;

    TRACE (TRACE_FLOW, "lock_list_promotably ()");

    if (noexec)
	return 0;

    if (readonlyfs) {
	error (0, 0,
	       "promotable lock failed.\n\
WARNING: Read-only repository access mode selected via `cvs -R'.\n\
Attempting to write to a read-only filesystem is not allowed.");
	return 1;
    }

    /* We only know how to do one list at a time */
    if (locklist != (List *) NULL)
    {
	error (0, 0,
	       "lock_list_promotably called while promotable locks set - Help!");
	return 1;
    }

    wait_repos = NULL;
    for (;;)
    {
	/* try to lock everything on the list */
	lock_error = L_OK;		/* init for set_promotablelock_proc */
	lock_error_repos = (char *) NULL; /* init for set_promotablelock_proc */
	locklist = list;		/* init for Lock_Cleanup */
	if (lockers_name != NULL)
	    free (lockers_name);
	lockers_name = xstrdup ("unknown");

	(void) walklist (list, set_promotablelock_proc, NULL);

	switch (lock_error)
	{
	    case L_ERROR:		/* Real Error */
		if (wait_repos != NULL)
		    free (wait_repos);
		Lock_Cleanup ();	/* clean up any locks we set */
		error (0, 0, "lock failed - giving up");
		return 1;

	    case L_LOCKED:		/* Someone already had a lock */
		remove_locks ();	/* clean up any locks we set */
		lock_wait (lock_error_repos); /* sleep a while and try again */
		wait_repos = xstrdup (lock_error_repos);
		continue;

	    case L_OK:			/* we got the locks set */
	        if (wait_repos != NULL)
		{
		    lock_obtained (wait_repos);
		    free (wait_repos);
		}
		return 0;

	    default:
		if (wait_repos != NULL)
		    free (wait_repos);
		error (0, 0, "unknown lock status %d in lock_list_promotably",
		       lock_error);
		return 1;
	}
    }
}



/*
 * Set the static variable lockers_name appropriately, based on the stat
 * structure passed in.
 */
static void
set_lockers_name (struct stat *statp)
{
    struct passwd *pw;

    if (lockers_name != NULL)
	free (lockers_name);
    if ((pw = (struct passwd *)getpwuid (statp->st_uid)) !=
	(struct passwd *)NULL)
    {
	lockers_name = xstrdup (pw->pw_name);
    }
    else
    {
	lockers_name = xmalloc (20);
	(void)sprintf (lockers_name, "uid%lu", (unsigned long) statp->st_uid);
    }
}



/*
 * Persistently tries to make the directory "lckdir", which serves as a
 * lock.
 *
 * #ifdef CVS_FUDGELOCKS
 * If the create time on the directory is greater than CVSLCKAGE
 * seconds old, just try to remove the directory.
 * #endif
 *
 */
static int
set_lock (struct lock *lock, int will_wait)
{
    int waited;
    long us;
    struct stat sb;
    mode_t omask;
#ifdef CVS_FUDGELOCKS
    time_t now;
#endif

    TRACE (TRACE_FLOW, "set_lock (%s, %d)",
	   lock->repository ? lock->repository : "(null)", will_wait);

    if (masterlock != NULL)
	free (masterlock);
    masterlock = lock_name (lock->repository, CVSLCK);

    /*
     * Note that it is up to the callers of set_lock() to arrange for signal
     * handlers that do the appropriate things, like remove the lock
     * directory before they exit.
     */
    waited = 0;
    us = 1;
    lock->have_lckdir = 0;
    for (;;)
    {
	int status = -1;
	omask = umask (cvsumask);
	SIG_beginCrSect ();
	if (CVS_MKDIR (masterlock, 0777) == 0)
	{
	    lock->have_lckdir = 1;
	    SIG_endCrSect ();
	    status = L_OK;
	    if (waited)
	        lock_obtained (lock->repository);
	    goto out;
	}
	SIG_endCrSect ();
      out:
	(void) umask (omask);
	if (status != -1)
	    return status;

	if (errno != EEXIST)
	{
	    error (0, errno,
		   "failed to create lock directory for `%s' (%s)",
		   lock->repository, masterlock);
	    return (L_ERROR);
	}

	/* Find out who owns the lock.  If the lock directory is
	   non-existent, re-try the loop since someone probably just
	   removed it (thus releasing the lock).  */
	if (CVS_STAT (masterlock, &sb) < 0)
	{
	    if (existence_error (errno))
		continue;

	    error (0, errno, "couldn't stat lock directory `%s'", masterlock);
	    return (L_ERROR);
	}

#ifdef CVS_FUDGELOCKS
	/*
	 * If the create time of the directory is more than CVSLCKAGE seconds
	 * ago, try to clean-up the lock directory, and if successful, just
	 * quietly retry to make it.
	 */
	(void) time (&now);
	if (now >= (sb.st_ctime + CVSLCKAGE))
	{
	    if (CVS_RMDIR (masterlock) >= 0)
		continue;
	}
#endif

	/* set the lockers name */
	set_lockers_name (&sb);

	/* if he wasn't willing to wait, return an error */
	if (!will_wait)
	    return (L_LOCKED);

	/* if possible, try a very short sleep without a message */
	if (!waited && us < 1000)
	{
	    us += us;
	    {
		struct timespec ts;
		ts.tv_sec = 0;
		ts.tv_nsec = us * 1000;
		(void)nanosleep (&ts, NULL);
		continue;
	    }
	}

	lock_wait (lock->repository);
	waited = 1;
    }
}



/*
 * Clear master lock.  We don't have to recompute the lock name since
 * clear_lock is never called except after a successful set_lock().
 */
static void
clear_lock (struct lock *lock)
{
    SIG_beginCrSect ();
    if (CVS_RMDIR (masterlock) < 0)
	error (0, errno, "failed to remove lock dir `%s'", masterlock);
    lock->have_lckdir = 0;
    SIG_endCrSect ();
}



/*
 * Create a list of repositories to lock
 */
/* ARGSUSED */
static int
lock_filesdoneproc (void *callerdat, int err, const char *repository,
                    const char *update_dir, List *entries)
{
    Node *p;

    p = getnode ();
    p->type = LOCK;
    p->key = xstrdup (repository);
    p->data = xmalloc (sizeof (struct lock));
    ((struct lock *)p->data)->repository = p->key;
    ((struct lock *)p->data)->file1 = NULL;
#ifdef LOCK_COMPATIBILITY
    ((struct lock *)p->data)->file2 = NULL;
#endif /* LOCK_COMPATIBILITY */
    ((struct lock *)p->data)->have_lckdir = 0;
    ((struct lock *)p->data)->free_repository = 0;

    /* FIXME-KRP: this error condition should not simply be passed by. */
    if (p->key == NULL || addnode (lock_tree_list, p) != 0)
	freenode (p);
    return err;
}



void
lock_tree_promotably (int argc, char **argv, int local, int which, int aflag)
{
    TRACE (TRACE_FUNCTION, "lock_tree_promotably (%d, argv, %d, %d, %d)",
	   argc, local, which, aflag);

    /*
     * Run the recursion processor to find all the dirs to lock and lock all
     * the dirs
     */
    lock_tree_list = getlist ();
    start_recursion
	(NULL, lock_filesdoneproc,
	 NULL, NULL, NULL, argc,
	 argv, local, which, aflag, CVS_LOCK_NONE,
	 NULL, 0, NULL );
    sortlist (lock_tree_list, fsortcmp);
    if (lock_list_promotably (lock_tree_list) != 0)
	error (1, 0, "lock failed - giving up");
}



/* Lock a single directory in REPOSITORY.  It is OK to call this if
 * a lock has been set with lock_dir_for_write; the new lock will replace
 * the old one.  If REPOSITORY is NULL, don't do anything.
 *
 * We do not clear the dir lock after writing the lock file name since write
 * locks are exclusive to all other locks.
 */
void
lock_dir_for_write (const char *repository)
{
    int waiting = 0;

    TRACE (TRACE_FLOW, "lock_dir_for_write (%s)", repository);

    if (repository != NULL
	&& (global_writelock.repository == NULL
	    || !strcmp (global_writelock.repository, repository)))
    {
	if (writelock == NULL)
	{
	    writelock = xmalloc (strlen (hostname) + sizeof (CVSWFL) + 40);
	    (void) sprintf (writelock,
#ifdef HAVE_LONG_FILE_NAMES
			    "%s.%s.%ld", CVSWFL, hostname,
#else
			    "%s.%ld", CVSWFL,
#endif
			    (long) getpid());
	}

	if (global_writelock.repository != NULL)
	    remove_lock_files (&global_writelock, 1);

	global_writelock.repository = xstrdup (repository);
	global_writelock.free_repository = 1;

	for (;;)
	{
	    FILE *fp;

	    if (set_lock (&global_writelock, 1) != L_OK)
		error (1, 0, "failed to obtain write lock in repository `%s'",
		       repository);

	    /* check if readers exist */
	    if (readers_exist (repository)
		|| promotable_exists (repository))
	    {
		clear_lock (&global_writelock);
		lock_wait (repository); /* sleep a while and try again */
		waiting = 1;
		continue;
	    }

	    if (waiting)
		lock_obtained (repository);

	    /* write the write-lock file */
	    global_writelock.file1 = lock_name (global_writelock.repository,
	                                        writelock);
	    if ((fp = CVS_FOPEN (global_writelock.file1, "w+")) == NULL
		|| fclose (fp) == EOF)
	    {
		int xerrno = errno;

		if (CVS_UNLINK (global_writelock.file1) < 0
		    && !existence_error (errno))
		{
		    error (0, errno, "failed to remove write lock %s",
			   global_writelock.file1);
		}

		/* free the lock dir */
		clear_lock (&global_writelock);

		/* return the error */
		error (1, xerrno,
		       "cannot create write lock in repository `%s'",
		       global_writelock.repository);
	    }

	    /* If we upgraded from a promotable lock, remove it. */
	    if (locklist)
	    {
		Node *p = findnode (locklist, repository);
		if (p)
		{
		    remove_lock_files (p->data, 1);
		    delnode (p);
		}
	    }

	    break;
	}
    }
}
@


1.3
log
@cvs-1.11.12 doesn't do the joints correctly (what were the
FSF people smoking?), it memory faults.
thusly revert to 1.11.1p1

tested.
agreed bsiegert@@
@
text
@d58 1
a58 4
   2.  Provide a means to put the cvs locks in some directory apart from
   the repository (CVSROOT/locks; a -l option in modules; etc.).

   3.  Provide an option to disable locks for operations which only
d61 1
a61 1
   4.  Have a server internally do the locking.  Probably a good
d65 3
a67 1
   much, much work still to be done before this is feasible.
a68 4
   5.  Like #4 but use shared memory or something so that the servers
   merely need to all be on the same machine.  This is a much smaller
   change to CVS (it functions much like #2; shared memory might be an
   unneeded complication although it presumably would be faster).  */
a69 2
#include "cvs.h"
#include <assert.h>
d76 1
a76 1
       case of writelocks, it is just a pointer to the storage allocated
d78 8
a85 1
    char *repository;
d91 1
d94 4
a97 11
static void remove_locks PROTO((void));
static int readers_exist PROTO((char *repository));
static int set_lock PROTO ((struct lock *lock, int will_wait));
static void clear_lock PROTO ((struct lock *lock));
static void set_lockers_name PROTO((struct stat *statp));
static int set_writelock_proc PROTO((Node * p, void *closure));
static int unlock_proc PROTO((Node * p, void *closure));
static int write_lock PROTO ((struct lock *lock));
static void lock_simple_remove PROTO ((struct lock *lock));
static void lock_wait PROTO((char *repository));
static void lock_obtained PROTO((char *repository));
d108 3
d123 1
a128 6
/* If we set locks with lock_dir_for_write, then locked_dir contains
   the malloc'd name of the repository directory which we have locked.
   locked_list is the same thing packaged into a list and is redundant
   with locklist the same way that lock_tree_list is.  */
static char *locked_dir;
static List *locked_list;
a129 4
/* LockDir from CVSROOT/config.  */
char *lock_dir;

static char *lock_name PROTO ((char *repository, char *name));
d138 1
a138 3
lock_name (repository, name)
    char *repository;
    char *name;
d141 1
a141 1
    char *p;
d143 2
a144 2
    char *short_repos;
    mode_t save_umask;
d147 4
a150 1
    if (lock_dir == NULL)
d154 2
d177 1
a177 1
	retval = xmalloc (strlen (lock_dir)
d181 1
a181 1
	strcpy (retval, lock_dir);
d220 2
a221 2
	if (CVS_STAT (lock_dir, &sb) < 0)
	    error (1, errno, "cannot stat %s", lock_dir);
d229 1
a229 1
	    while (!ISDIRSEP (*p) && *p != '\0')
d231 1
a231 1
	    if (ISDIRSEP (*p))
d235 1
a235 1
		if (!ISDIRSEP (q[p - short_repos - 1])
d273 9
a281 2
/*
 * Clean up all outstanding locks
d283 2
a284 2
void
Lock_Cleanup ()
d286 1
a286 9
    /* FIXME: error handling here is kind of bogus; we sometimes will call
       error, which in turn can call us again.  For the moment work around
       this by refusing to reenter this function (this is a kludge).  */
    /* FIXME-reentrancy: the workaround isn't reentrant.  */
    static int in_lock_cleanup = 0;

    if (in_lock_cleanup)
	return;
    in_lock_cleanup = 1;
d288 23
a310 1
    remove_locks ();
d312 10
a321 1
    dellist (&lock_tree_list);
d323 8
a330 1
    if (locked_dir != NULL)
d332 8
a339 4
	dellist (&locked_list);
	free (locked_dir);
	locked_dir = NULL;
	locked_list = NULL;
a340 1
    in_lock_cleanup = 0;
d343 2
d346 1
a346 1
 * Remove locks without discarding the lock information
d348 2
a349 2
static void
remove_locks ()
d351 8
a358 1
    /* clean up simple locks (if any) */
d360 39
a398 4
    {
	lock_simple_remove (&global_readlock);
	global_readlock.repository = NULL;
    }
d400 15
a414 6
    /* clean up multiple locks (if any) */
    if (locklist != (List *) NULL)
    {
	(void) walklist (locklist, unlock_proc, NULL);
	locklist = (List *) NULL;
    }
d417 2
d423 1
a423 3
unlock_proc (p, closure)
    Node *p;
    void *closure;
d425 2
a426 2
    lock_simple_remove ((struct lock *)p->data);
    return (0);
d429 5
a433 1
/* Remove the lock files.  */
d435 1
a435 2
lock_simple_remove (lock)
    struct lock *lock;
d437 1
a437 1
    char *tmp;
d439 5
a443 5
    /* If readlock is set, the lock directory *might* have been created, but
       since Reader_Lock doesn't use SIG_beginCrSect the way that set_lock
       does, we don't know that.  That is why we need to check for
       existence_error here.  */
    if (readlock != NULL)
d445 6
a450 4
	tmp = lock_name (lock->repository, readlock);
	if ( CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
	    error (0, errno, "failed to remove lock %s", tmp);
	free (tmp);
d452 3
a455 11
    /* If writelock is set, the lock directory *might* have been created, but
       since write_lock doesn't use SIG_beginCrSect the way that set_lock
       does, we don't know that.  That is why we need to check for
       existence_error here.  */
    if (writelock != NULL)
    {
	tmp = lock_name (lock->repository, writelock);
	if ( CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
	    error (0, errno, "failed to remove lock %s", tmp);
	free (tmp);
    }
d457 7
a463 1
    if (lock->have_lckdir)
d465 8
a472 7
	tmp = lock_name (lock->repository, CVSLCK);
	SIG_beginCrSect ();
	if (CVS_RMDIR (tmp) < 0)
	    error (0, errno, "failed to remove lock dir %s", tmp);
	lock->have_lckdir = 0;
	SIG_endCrSect ();
	free (tmp);
d476 2
d482 1
a482 2
Reader_Lock (xrepository)
    char *xrepository;
d486 2
a487 1
    char *tmp;
d490 1
a490 1
	return (0);
d492 1
a492 1
    /* we only do one directory at a time for read locks! */
d496 1
a496 1
	return (1);
d499 1
a499 11
    if (readlock == NULL)
    {
	readlock = xmalloc (strlen (hostname) + sizeof (CVSRFL) + 40);
	(void) sprintf (readlock, 
#ifdef HAVE_LONG_FILE_NAMES
			"%s.%s.%ld", CVSRFL, hostname,
#else
			"%s.%ld", CVSRFL,
#endif
			(long) getpid ());
    }
d502 2
a503 1
    global_readlock.repository = xrepository;
d516 1
a516 1
	return (1);
d520 3
a522 2
    tmp = lock_name (xrepository, readlock);
    if ((fp = CVS_FOPEN (tmp, "w+")) == NULL || fclose (fp) == EOF)
a525 3
	if (readlock != NULL)
	    free (readlock);
	readlock = NULL;
a527 1
    free (tmp);
d532 1
a532 1
    return (err);
d535 2
d538 19
a556 1
 * Lock a list of directories for writing
a557 5
static char *lock_error_repos;
static int lock_error;

static int Writer_Lock PROTO ((List * list));

d559 1
a559 2
Writer_Lock (list)
    List *list;
d561 10
a570 4
    char *wait_repos;

    if (noexec)
	return (0);
d572 2
a573 6
    /* We only know how to do one list at a time */
    if (locklist != (List *) NULL)
    {
	error (0, 0, "Writer_Lock called while write locks set - Help!");
	return (1);
    }
d575 2
a576 10
    wait_repos = NULL;
    for (;;)
    {
	/* try to lock everything on the list */
	lock_error = L_OK;		/* init for set_writelock_proc */
	lock_error_repos = (char *) NULL; /* init for set_writelock_proc */
	locklist = list;		/* init for Lock_Cleanup */
	if (lockers_name != NULL)
	    free (lockers_name);
	lockers_name = xstrdup ("unknown");
d578 3
a580 1
	(void) walklist (list, set_writelock_proc, NULL);
d582 3
a584 1
	switch (lock_error)
d586 30
a615 15
	    case L_ERROR:		/* Real Error */
		if (wait_repos != NULL)
		    free (wait_repos);
		Lock_Cleanup ();	/* clean up any locks we set */
		error (0, 0, "lock failed - giving up");
		return (1);

	    case L_LOCKED:		/* Someone already had a lock */
		remove_locks ();	/* clean up any locks we set */
		lock_wait (lock_error_repos); /* sleep a while and try again */
		wait_repos = xstrdup (lock_error_repos);
		continue;

	    case L_OK:			/* we got the locks set */
	        if (wait_repos != NULL)
d617 6
a622 2
		    lock_obtained (wait_repos);
		    free (wait_repos);
d624 12
a635 1
		return (0);
d637 3
a639 8
	    default:
		if (wait_repos != NULL)
		    free (wait_repos);
		error (0, 0, "unknown lock status %d in Writer_Lock",
		       lock_error);
		return (1);
	}
    }
d642 2
d645 5
a649 1
 * walklist proc for setting write locks
d652 1
a652 3
set_writelock_proc (p, closure)
    Node *p;
    void *closure;
d654 16
a669 3
    /* if some lock was not OK, just skip this one */
    if (lock_error != L_OK)
	return (0);
d671 12
a682 4
    /* apply the write lock */
    lock_error_repos = p->key;
    lock_error = write_lock ((struct lock *)p->data);
    return (0);
d685 2
d688 10
a697 2
 * Create a lock file for writers returns L_OK if lock set ok, L_LOCKED if
 * lock held by someone else or L_ERROR if an error occurred
d700 1
a700 2
write_lock (lock)
    struct lock *lock;
a703 1
    char *tmp;
d705 4
a708 1
    if (writelock == NULL)
d710 2
a711 2
	writelock = xmalloc (strlen (hostname) + sizeof (CVSWFL) + 40);
	(void) sprintf (writelock,
d713 1
a713 1
			"%s.%s.%ld", CVSWFL, hostname,
d715 1
a715 1
			"%s.%ld", CVSWFL,
d724 2
a725 2
	/* we now own a writer - make sure there are no readers */
	if (readers_exist (lock->repository))
d727 2
a728 5
	    /* clean up the lock dir if we created it */
	    if (status == L_OK)
	    {
		clear_lock (lock);
	    }
d731 20
a750 1
	    return (L_LOCKED);
d753 9
a761 3
	/* write the write-lock file */
	tmp = lock_name (lock->repository, writelock);
	if ((fp = CVS_FOPEN (tmp, "w+")) == NULL || fclose (fp) == EOF)
d765 5
a769 2
	    if ( CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
		error (0, errno, "failed to remove lock %s", tmp);
d771 3
a773 5
	    /* free the lock dir if we created it */
	    if (status == L_OK)
	    {
		clear_lock (lock);
	    }
d776 2
a777 1
	    error (0, xerrno, "cannot create write lock in repository `%s'",
d779 1
a779 2
	    free (tmp);
	    return (L_ERROR);
d781 5
a785 2
	free (tmp);
	return (L_OK);
d788 39
a826 1
	return (status);
d829 28
d858 1
a858 3
 * readers_exist() returns 0 if there are no reader lock files remaining in
 * the repository; else 1 is returned, to indicate that the caller should
 * sleep a while and try again.
d860 21
d882 1
a882 2
readers_exist (repository)
    char *repository;
d884 6
a889 5
    char *line;
    DIR *dirp;
    struct dirent *dp;
    struct stat sb;
    int ret = 0;
d891 7
a897 3
#ifdef CVS_FUDGELOCKS
again:
#endif
d899 7
a905 2
    if ((dirp = CVS_OPENDIR (repository)) == NULL)
	error (1, 0, "cannot open directory %s", repository);
d907 2
a908 2
    errno = 0;
    while ((dp = CVS_READDIR (dirp)) != NULL)
d910 11
a920 1
	if (CVS_FNMATCH (CVSRFLPAT, dp->d_name, 0) == 0)
d922 12
a933 4
#ifdef CVS_FUDGELOCKS
	    time_t now;
	    (void) time (&now);
#endif
d935 2
a936 11
	    line = xmalloc (strlen (repository) + strlen (dp->d_name) + 5);
	    (void) sprintf (line, "%s/%s", repository, dp->d_name);
	    if ( CVS_STAT (line, &sb) != -1)
	    {
#ifdef CVS_FUDGELOCKS
		/*
		 * If the create time of the file is more than CVSLCKAGE 
		 * seconds ago, try to clean-up the lock file, and if
		 * successful, re-open the directory and try again.
		 */
		if (now >= (sb.st_ctime + CVSLCKAGE) && CVS_UNLINK (line) != -1)
d938 2
a939 3
		    (void) CVS_CLOSEDIR (dirp);
		    free (line);
		    goto again;
d941 1
a941 13
#endif
		set_lockers_name (&sb);
	    }
	    else
	    {
		/* If the file doesn't exist, it just means that it disappeared
		   between the time we did the readdir and the time we did
		   the stat.  */
		if (!existence_error (errno))
		    error (0, errno, "cannot stat %s", line);
	    }
	    errno = 0;
	    free (line);
d943 6
a948 2
	    ret = 1;
	    break;
a949 1
	errno = 0;
d951 2
a952 2
    if (errno != 0)
	error (0, errno, "error reading directory %s", repository);
a953 3
    CVS_CLOSEDIR (dirp);
    return (ret);
}
d960 1
a960 2
set_lockers_name (statp)
    struct stat *statp;
d966 2
a967 2
    if ((pw = (struct passwd *) getpwuid (statp->st_uid)) !=
	(struct passwd *) NULL)
d974 1
a974 1
	(void) sprintf (lockers_name, "uid%lu", (unsigned long) statp->st_uid);
d978 2
d981 5
a985 2
 * Persistently tries to make the directory "lckdir",, which serves as a
 * lock. If the create time on the directory is greater than CVSLCKAGE
d987 2
d991 1
a991 3
set_lock (lock, will_wait)
    struct lock *lock;
    int will_wait;
d994 1
d1001 3
d1014 1
d1076 14
d1095 2
d1102 1
a1102 2
clear_lock (lock)
    struct lock *lock;
a1110 31
/*
 * Print out a message that the lock is still held, then sleep a while.
 */
static void
lock_wait (repos)
    char *repos;
{
    time_t now;
    char *msg;

    (void) time (&now);
    msg = xmalloc (100 + strlen (lockers_name) + strlen (repos));
    sprintf (msg, "[%8.8s] waiting for %s's lock in %s", ctime (&now) + 11,
	     lockers_name, repos);
    error (0, 0, "%s", msg);
    /* Call cvs_flusherr to ensure that the user sees this message as
       soon as possible.  */
    cvs_flusherr ();
    free (msg);
    (void) sleep (CVSLCKSLEEP);
}

/*
 * Print out a message when we obtain a lock.
 */
static void
lock_obtained (repos)
     char *repos;
{
    time_t now;
    char *msg;
a1111 13
    (void) time (&now);
    msg = xmalloc (100 + strlen (repos));
    sprintf (msg, "[%8.8s] obtained lock in %s", ctime (&now) + 11, repos);
    error (0, 0, "%s", msg);
    /* Call cvs_flusherr to ensure that the user sees this message as
       soon as possible.  */
    cvs_flusherr ();
    free (msg);
}

static int lock_filesdoneproc PROTO ((void *callerdat, int err,
				      char *repository, char *update_dir,
				      List *entries));
d1118 2
a1119 6
lock_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
    int err;
    char *repository;
    char *update_dir;
    List *entries;
d1128 4
d1133 1
d1138 1
a1138 1
    return (err);
d1141 2
d1144 1
a1144 6
lock_tree_for_write (argc, argv, local, which, aflag)
    int argc;
    char **argv;
    int local;
    int which;
    int aflag;
d1146 3
a1148 1
    int err;
d1154 5
a1158 3
    err = start_recursion ((FILEPROC) NULL, lock_filesdoneproc,
			   (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL, argc,
			   argv, local, which, aflag, 0, (char *) NULL, 0);
d1160 1
a1160 1
    if (Writer_Lock (lock_tree_list) != 0)
d1163 3
a1165 1

d1167 6
a1172 2
   a lock has been set with lock_dir_for_write; the new lock will replace
   the old one.  If REPOSITORY is NULL, don't do anything.  */
d1174 1
a1174 2
lock_dir_for_write (repository)
     char *repository;
d1176 4
d1181 2
a1182 2
	&& (locked_dir == NULL
	    || strcmp (locked_dir, repository) != 0))
d1184 17
a1200 1
	Node *node;
d1202 3
a1204 2
	if (locked_dir != NULL)
	    Lock_Cleanup ();
d1206 24
a1229 8
	locked_dir = xstrdup (repository);
	locked_list = getlist ();
	node = getnode ();
	node->type = LOCK;
	node->key = xstrdup (repository);
	node->data = xmalloc (sizeof (struct lock));
	((struct lock *)node->data)->repository = node->key;
	((struct lock *)node->data)->have_lckdir = 0;
d1231 29
a1259 2
	(void) addnode (locked_list, node);
	Writer_Lock (locked_list);
@


1.2
log
@first step of merging new cvs
XXX might not compile
XXX might not work
XXX might contain bugs
XXX definitively needs autoconf 2.58 first
@
text
@d58 4
a61 1
   2.  Provide an option to disable locks for operations which only
d64 1
a64 1
   3.  Have a server internally do the locking.  Probably a good
d68 6
a73 1
   much, much work still to be done before this is feasible.  */
a77 10
#ifdef HAVE_NANOSLEEP
# include "xtime.h"
#else /* HAVE_NANOSLEEP */
# if !defined HAVE_USLEEP && defined HAVE_SELECT
    /* use select as a workaround */
#   include "xselect.h"
# endif /* !defined HAVE_USLEEP && defined HAVE_SELECT */
#endif /* !HAVE_NANOSLEEP */


a293 3
    if (trace)
	(void) fprintf (stderr, "%s-> Lock_Cleanup()\n", CLIENT_SERVER_STR);

a398 4
    if (trace)
	(void) fprintf (stderr, "%s-> Reader_Lock(%s)\n", CLIENT_SERVER_STR,
                        xrepository);

a556 4
    if (trace)
	(void) fprintf (stderr, "%s-> write_lock(%s)\n",
                        CLIENT_SERVER_STR, lock->repository);

a622 1
    char *lockdir;
d627 2
a628 1
    int ret;
d630 1
a630 2
    time_t now;
    (void) time (&now);
d633 2
a634 2
    lockdir = lock_name (repository, "");
    lockdir[strlen (lockdir) - 1] = '\0';   /* remove trailing slash */
d636 9
a644 3
    do {
	if ((dirp = CVS_OPENDIR (lockdir)) == NULL)
	    error (1, 0, "cannot open directory %s", lockdir);
d646 3
a648 5
	ret = 0;
	errno = 0;
	while ((dp = CVS_READDIR (dirp)) != NULL)
	{
	    if (CVS_FNMATCH (CVSRFLPAT, dp->d_name, 0) == 0)
a649 4
		line = xmalloc (strlen (lockdir) + 1 + strlen (dp->d_name) + 1);
		(void) sprintf (line, "%s/%s", lockdir, dp->d_name);
		if ( CVS_STAT (line, &sb) != -1)
		{
d651 6
a656 16
		    /*
		     * If the create time of the file is more than CVSLCKAGE 
		     * seconds ago, try to clean-up the lock file, and if
		     * successful, re-open the directory and try again.
		     */
		    if (now >= (sb.st_ctime + CVSLCKAGE) &&
                        CVS_UNLINK (line) != -1)
		    {
			free (line);
			ret = -1;
			break;
		    }
#endif
		    set_lockers_name (&sb);
		}
		else
d658 3
a660 5
		    /* If the file doesn't exist, it just means that it disappeared
		       between the time we did the readdir and the time we did
		       the stat.  */
		    if (!existence_error (errno))
			error (0, errno, "cannot stat %s", line);
d662 10
a671 4
		errno = 0;
		free (line);
		ret = 1;
		break;
d674 4
d679 4
a682 2
	if (errno != 0)
	    error (0, errno, "error reading directory %s", repository);
d684 1
a684 2
	CVS_CLOSEDIR (dirp);
    } while (ret < 0);
d713 2
a714 5
 * Persistently tries to make the directory "lckdir", which serves as a
 * lock.
 *
 * #ifdef CVS_FUDGELOCKS
 * If the create time on the directory is greater than CVSLCKAGE
a715 2
 * #endif
 *
a722 1
    long us;
a738 1
    us = 1;
a799 27

	/* if possible, try a very short sleep without a message */
	if (!waited && us < 1000)
	{
	    us += us;
#if defined HAVE_NANOSLEEP
	    {
		struct timespec ts;
		ts.tv_sec = 0;
		ts.tv_nsec = us * 1000;
		(void)nanosleep (&ts, NULL);
		continue;
	    }
#elif defined HAVE_USLEEP
	    (void)usleep (us);
	    continue;
#elif defined HAVE_SELECT
	    {
		struct timeval tv;
		tv.tv_sec = 0;
		tv.tv_usec = us;
		(void)select (0, (fd_set *)NULL, (fd_set *)NULL, (fd_set *)NULL, &tv);
		continue;
	    }
#endif
	}

a828 1
    struct tm *tm_p;
a830 1
    tm_p = gmtime (&now);
d832 1
a832 2
    sprintf (msg, "[%8.8s] waiting for %s's lock in %s",
	     (tm_p ? asctime (tm_p) : ctime (&now)) + 11,
a850 1
    struct tm *tm_p;
a852 1
    tm_p = gmtime (&now);
d854 1
a854 2
    sprintf (msg, "[%8.8s] obtained lock in %s",
	     (tm_p ? asctime (tm_p) : ctime (&now)) + 11, repos);
d901 1
d907 3
a909 4
    start_recursion ((FILEPROC) NULL, lock_filesdoneproc,
		     (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL, argc,
		     argv, local, which, aflag, CVS_LOCK_NONE,
		     (char *) NULL, 0, (char *) NULL);
@


1.1
log
@Initial revision
@
text
@d58 1
a58 4
   2.  Provide a means to put the cvs locks in some directory apart from
   the repository (CVSROOT/locks; a -l option in modules; etc.).

   3.  Provide an option to disable locks for operations which only
d61 1
a61 1
   4.  Have a server internally do the locking.  Probably a good
d65 1
a65 6
   much, much work still to be done before this is feasible.

   5.  Like #4 but use shared memory or something so that the servers
   merely need to all be on the same machine.  This is a much smaller
   change to CVS (it functions much like #2; shared memory might be an
   unneeded complication although it presumably would be faster).  */
d70 10
d296 3
d404 4
d566 4
d636 1
d641 1
a641 2
    int ret = 0;

d643 2
a644 1
again:
d647 2
a648 2
    if ((dirp = CVS_OPENDIR (repository)) == NULL)
	error (1, 0, "cannot open directory %s", repository);
d650 7
a656 4
    errno = 0;
    while ((dp = CVS_READDIR (dirp)) != NULL)
    {
	if (CVS_FNMATCH (CVSRFLPAT, dp->d_name, 0) == 0)
d658 6
d665 12
a676 2
	    time_t now;
	    (void) time (&now);
d678 3
a680 12

	    line = xmalloc (strlen (repository) + strlen (dp->d_name) + 5);
	    (void) sprintf (line, "%s/%s", repository, dp->d_name);
	    if ( CVS_STAT (line, &sb) != -1)
	    {
#ifdef CVS_FUDGELOCKS
		/*
		 * If the create time of the file is more than CVSLCKAGE 
		 * seconds ago, try to clean-up the lock file, and if
		 * successful, re-open the directory and try again.
		 */
		if (now >= (sb.st_ctime + CVSLCKAGE) && CVS_UNLINK (line) != -1)
d682 5
a686 3
		    (void) CVS_CLOSEDIR (dirp);
		    free (line);
		    goto again;
d688 4
a691 10
#endif
		set_lockers_name (&sb);
	    }
	    else
	    {
		/* If the file doesn't exist, it just means that it disappeared
		   between the time we did the readdir and the time we did
		   the stat.  */
		if (!existence_error (errno))
		    error (0, errno, "cannot stat %s", line);
a693 4
	    free (line);

	    ret = 1;
	    break;
d695 2
a696 4
	errno = 0;
    }
    if (errno != 0)
	error (0, errno, "error reading directory %s", repository);
d698 2
a699 1
    CVS_CLOSEDIR (dirp);
d728 5
a732 2
 * Persistently tries to make the directory "lckdir",, which serves as a
 * lock. If the create time on the directory is greater than CVSLCKAGE
d734 2
d743 1
d760 1
d822 27
d878 1
d881 1
d883 2
a884 1
    sprintf (msg, "[%8.8s] waiting for %s's lock in %s", ctime (&now) + 11,
d903 1
d906 1
d908 2
a909 1
    sprintf (msg, "[%8.8s] obtained lock in %s", ctime (&now) + 11, repos);
a955 1
    int err;
d961 4
a964 3
    err = start_recursion ((FILEPROC) NULL, lock_filesdoneproc,
			   (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL, argc,
			   argv, local, which, aflag, 0, (char *) NULL, 0);
@


1.1.2.1
log
@vendor-branch-ify new cvs 1.12
@
text
@d58 4
a61 1
   2.  Provide an option to disable locks for operations which only
d64 1
a64 1
   3.  Have a server internally do the locking.  Probably a good
d68 6
a73 1
   much, much work still to be done before this is feasible.  */
d76 1
a76 2


d83 1
a83 1
       case of promotablelocks, it is just a pointer to the storage allocated
d85 1
a85 8
    const char *repository;

    /* The name of the lock files. */
    char *file1;
#ifdef LOCK_COMPATIBILITY
    char *file2;
#endif /* LOCK_COMPATIBILITY */

a90 1
    int free_repository;
d93 11
a103 4
static void remove_locks (void);
static int set_lock (struct lock *lock, int will_wait);
static void clear_lock (struct lock *lock);
static void set_lockers_name (struct stat *statp);
a113 3
/* Malloc'd array specifying name of a promotablelock within a directory.
   Or NULL if none.  */
static char *promotablelock;
a125 1
static struct lock global_writelock;
d131 6
d138 4
d150 3
a152 1
lock_name (const char *repository, const char *name)
d155 1
a155 1
    const char *p;
d157 2
a158 2
    const char *short_repos;
    mode_t save_umask = 0000;
d161 1
a161 4
    TRACE (TRACE_FLOW, "lock_name (%s, %s)",
	   repository  ? repository : "(null)", name ? name : "(null)");

    if (!config->lock_dir)
a164 2
	assert (name != NULL);
	assert (repository != NULL);
d186 1
a186 1
	retval = xmalloc (strlen (config->lock_dir)
d190 1
a190 1
	strcpy (retval, config->lock_dir);
d229 2
a230 2
	if (CVS_STAT (config->lock_dir, &sb) < 0)
	    error (1, errno, "cannot stat %s", config->lock_dir);
d238 1
a238 1
	    while (!ISSLASH (*p) && *p != '\0')
d240 1
a240 1
	    if (ISSLASH (*p))
d244 1
a244 1
		if (!ISSLASH (q[p - short_repos - 1])
d282 2
a283 9


/* Remove the lock files.  For interrupt purposes, it can be assumed that the
 * first thing this function does is set lock->repository to NULL.
 *
 * INPUTS
 *   lock	The lock to remove.
 *   free	True if this lock directory will not5 be reused (free
 *		lock->repository if necessary).
d285 2
a286 2
static void
remove_lock_files (struct lock *lock, int free_repository)
d288 9
a296 1
    TRACE (TRACE_FLOW, "remove_lock_files (%s)", lock->repository);
d298 1
a298 23
    /* If lock->file is set, the lock *might* have been created, but since
     * Reader_Lock & lock_dir_for_write don't use SIG_beginCrSect the way that
     * set_lock does, we don't know that.  That is why we need to check for
     * existence_error here.
     */
    if (lock->file1)
    {
	char *tmp = lock->file1;
	lock->file1 = NULL;
	if (CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
	    error (0, errno, "failed to remove lock %s", tmp);
	free (tmp);
    }
#ifdef LOCK_COMPATIBILITY
    if (lock->file2)
    {
	char *tmp = lock->file2;
	lock->file2 = NULL;
	if (CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
	    error (0, errno, "failed to remove lock %s", tmp);
	free (tmp);
    }
#endif /* LOCK_COMPATIBILITY */
d300 1
a300 10
    if (lock->have_lckdir)
    {
	char *tmp = lock_name (lock->repository, CVSLCK);
	SIG_beginCrSect ();
	if (CVS_RMDIR (tmp) < 0)
	    error (0, errno, "failed to remove lock dir %s", tmp);
	lock->have_lckdir = 0;
	SIG_endCrSect ();
	free (tmp);
    }
d302 1
a302 8
    /* And free the repository string.  We don't really have to set the
     * repository string to NULL first since there is no harm in running any of
     * the above code twice.
     *
     * Use SIG_beginCrSect since otherwise we might be interrupted between
     * checking whether free_repository is set and freeing stuff.
     */
    if (free_repository)
d304 4
a307 8
	SIG_beginCrSect ();
	if (lock->free_repository)
	{
	    free ((char *)lock->repository);
	    lock->free_repository = 0;
	}
	lock->repository = NULL;
	SIG_endCrSect ();
d309 1
a311 2


d313 1
a313 1
 * Clean up outstanding read and write locks and free their storage.
d315 2
a316 2
void
Simple_Lock_Cleanup (void)
d318 1
a318 8
    TRACE (TRACE_FUNCTION, "Simple_Lock_Cleanup()");

    /* Avoid interrupts while accessing globals the interrupt handlers might
     * make use of.
     */
    SIG_beginCrSect();

    /* clean up simple read locks (if any) */
d320 4
a323 12
	remove_lock_files (&global_readlock, 1);
    /* See note in Lock_Cleanup() below.  */
    SIG_endCrSect();

    SIG_beginCrSect();

    /* clean up simple write locks (if any) */
    if (global_writelock.repository != NULL)
	remove_lock_files (&global_writelock, 1);
    /* See note in Lock_Cleanup() below.  */
    SIG_endCrSect();
}
d325 6
a330 42


/*
 * Clean up all outstanding locks and free their storage.
 *
 * NOTES
 *   This function needs to be reentrant since a call to exit() can cause a
 *   call to this function, which can then be interrupted by a signal, which
 *   can cause a second call to this function.
 *
 * RETURNS
 *   Nothing.
 */
void
Lock_Cleanup (void)
{
    TRACE (TRACE_FUNCTION, "Lock_Cleanup()");

    /* FIXME: Do not perform buffered I/O from an interrupt handler like
     * this (via error).  However, I'm leaving the error-calling code there
     * in the hope that on the rare occasion the error call is actually made
     * (e.g., a fluky I/O error or permissions problem prevents the deletion
     * of a just-created file) reentrancy won't be an issue.
     */

    remove_locks ();

    /* Avoid being interrupted during calls which set globals to NULL.  This
     * avoids having interrupt handlers attempt to use these global variables
     * in inconsistent states.
     *
     * This isn't always necessary, because sometimes we are called via exit()
     * or the interrupt handler, in which case signals will already be blocked,
     * but sometimes we might be called from elsewhere.
     */
    SIG_beginCrSect();
    dellist (&lock_tree_list);
    /*  Unblocking allows any signal to be processed as soon as possible.  This
     *  isn't really necessary, but since we know signals can cause us to be
     *  called, why not avoid having blocks of code run twice.
     */
    SIG_endCrSect();
a332 2


d337 3
a339 1
unlock_proc (Node *p, void *closure)
d341 2
a342 2
    remove_lock_files (p->data, 0);
    return 0;
d345 1
a345 5


/*
 * Remove locks without discarding the lock information.
 */
d347 2
a348 1
remove_locks (void)
d350 1
a350 1
    TRACE (TRACE_FLOW, "remove_locks()");
d352 11
a362 1
    Simple_Lock_Cleanup ();
d364 5
a368 3
    /* clean up promotable locks (if any) */
    SIG_beginCrSect();
    if (locklist != NULL)
d370 4
a373 6
	/* Use a tmp var since any of these functions could call exit, causing
	 * us to be called a second time.
	 */
	List *tmp = locklist;
	locklist = NULL;
	walklist (tmp, unlock_proc, NULL);
a374 2
    SIG_endCrSect();
}
d376 1
a376 9


/*
 * Set the global readlock variable if it isn't already.
 */
static void
set_readlock_name (void)
{
    if (readlock == NULL)
d378 7
a384 8
	readlock = xmalloc (strlen (hostname) + sizeof (CVSRFL) + 40);
	(void) sprintf (readlock, 
#ifdef HAVE_LONG_FILE_NAMES
			"%s.%s.%ld", CVSRFL, hostname,
#else
			"%s.%ld", CVSRFL,
#endif
			(long) getpid ());
a387 2


d392 2
a393 1
Reader_Lock (char *xrepository)
d397 1
a397 2

    TRACE (TRACE_FUNCTION, "Reader_Lock(%s)", xrepository);
d400 1
a400 1
	return 0;
d402 1
a402 1
    /* we only do one directory at a time for read locks!  */
d406 1
a406 1
	return 1;
d409 11
a419 1
    set_readlock_name ();
d422 1
a422 2
    global_readlock.repository = xstrdup (xrepository);
    global_readlock.free_repository = 1;
d435 1
a435 1
	return 1;
d439 2
a440 3
    global_readlock.file1 = lock_name (xrepository, readlock);
    if ((fp = CVS_FOPEN (global_readlock.file1, "w+")) == NULL
	|| fclose (fp) == EOF)
d444 3
d449 1
d454 1
a454 1
    return err;
d457 5
d463 1
a464 21
/*
 * lock_exists() returns 0 if there is no lock file matching FILEPAT in
 * the repository but not IGNORE; else 1 is returned, to indicate that the
 * caller should sleep a while and try again.
 *
 * INPUTS
 *   repository		The repository directory to search for locks.
 *   filepat		The file name pattern to search for.
 *   ignore		The name of a single file which can be ignored.
 *
 * GLOBALS
 *   lockdir		The lock dir external to the repository, if any.
 *
 * RETURNS
 *   0		No lock matching FILEPAT and not IGNORE exists.
 *   1		Otherwise and on error.
 *
 * ERRORS
 *  In the case where errors are encountered reading the directory, a warning
 *  message is printed, 1 is is returned and ERRNO is left set.
 */
d466 2
a467 1
lock_exists (const char *repository, const char *filepat, const char *ignore)
d469 4
a472 10
    char *lockdir;
    char *line;
    DIR *dirp;
    struct dirent *dp;
    struct stat sb;
    int ret;
#ifdef CVS_FUDGELOCKS
    time_t now;
    (void)time (&now);
#endif
d474 6
a479 2
    TRACE (TRACE_FLOW, "lock_exists (%s, %s, %s)",
	   repository, filepat, ignore ? ignore : "(null)");
d481 10
a490 2
    lockdir = lock_name (repository, "");
    lockdir[strlen (lockdir) - 1] = '\0';   /* remove trailing slash */
d492 1
a492 3
    do {
	if ((dirp = CVS_OPENDIR (lockdir)) == NULL)
	    error (1, 0, "cannot open directory %s", lockdir);
d494 1
a494 3
	ret = 0;
	errno = 0;
	while ((dp = CVS_READDIR (dirp)) != NULL)
d496 15
a510 12
	    if (CVS_FNMATCH (filepat, dp->d_name, 0) == 0)
	    {
		/* FIXME: the basename conversion below should be replaced with
		 * a call to the GNULIB basename function once it is imported.
		 */
		/* ignore our plock, if any */
		if (ignore && !fncmp (ignore, dp->d_name))
		    continue;

		line = xmalloc (strlen (lockdir) + 1 + strlen (dp->d_name) + 1);
		(void)sprintf (line, "%s/%s", lockdir, dp->d_name);
		if (CVS_STAT (line, &sb) != -1)
d512 2
a513 15
#ifdef CVS_FUDGELOCKS
		    /*
		     * If the create time of the file is more than CVSLCKAGE 
		     * seconds ago, try to clean-up the lock file, and if
		     * successful, re-open the directory and try again.
		     */
		    if (now >= (sb.st_ctime + CVSLCKAGE) &&
                        CVS_UNLINK (line) != -1)
		    {
			free (line);
			ret = -1;
			break;
		    }
#endif
		    set_lockers_name (&sb);
d515 8
a522 15
		else
		{
		    /* If the file doesn't exist, it just means that it
		     * disappeared between the time we did the readdir and the
		     * time we did the stat.
		     */
		    if (!existence_error (errno))
			error (0, errno, "cannot stat %s", line);
		}
		errno = 0;
		free (line);
		ret = 1;
		break;
	    }
	    errno = 0;
d524 1
a524 9
	if (errno != 0)
	    error (0, errno, "error reading directory %s", repository);

	CVS_CLOSEDIR (dirp);
    } while (ret < 0);

    if (lockdir != NULL)
	free (lockdir);
    return ret;
a526 2


d528 1
a528 5
 * readers_exist() returns 0 if there are no reader lock files remaining in
 * the repository; else 1 is returned, to indicate that the caller should
 * sleep a while and try again.
 *
 * See lock_exists() for argument detail.
d531 3
a533 1
readers_exist (const char *repository)
d535 3
a537 1
    TRACE (TRACE_FLOW, "readers_exist (%s)", repository);
d539 4
a542 11
    /* It is only safe to ignore a readlock set by our process if it was set as
     * a safety measure to prevent older CVS processes from ignoring our
     * promotable locks.  The code to ignore these readlocks can be removed
     * once it is deemed unlikely that anyone will be using CVS servers earlier
     * than version 1.12.4.
     */
    return lock_exists (repository, CVSRFLPAT,
#ifdef LOCK_COMPATIBILITY
                         findnode (locklist, repository) ? readlock : 
#endif /* LOCK_COMPATIBILITY */
			 NULL);
a544 2


d546 2
a547 5
 * promotable_exists() returns 0 if there is no promotable lock file in
 * the repository; else 1 is returned, to indicate that the caller should
 * sleep a while and try again.
 *
 * See lock_exists() for argument detail.
d550 2
a551 22
promotable_exists (const char *repository)
{
    TRACE (TRACE_FLOW, "promotable_exists (%s)", repository);
    return lock_exists (repository, CVSPFLPAT, promotablelock);
}



/*
 * Lock a list of directories for writing
 */
static char *lock_error_repos;
static int lock_error;



/*
 * Create a lock file for potential writers returns L_OK if lock set ok,
 * L_LOCKED if lock held by someone else or L_ERROR if an error occurred.
 */
static int
set_promotable_lock (struct lock *lock)
d555 1
d557 1
a557 4
    TRACE (TRACE_FUNCTION, "set_promotable_lock(%s)",
	   lock->repository ? lock->repository : "(null)");

    if (promotablelock == NULL)
d559 2
a560 2
	promotablelock = xmalloc (strlen (hostname) + sizeof (CVSPFL) + 40);
	(void) sprintf (promotablelock,
d562 1
a562 1
			"%s.%s.%ld", CVSPFL, hostname,
d564 1
a564 1
			"%s.%ld", CVSPFL,
d573 2
a574 2
	/* we now own a promotable lock - make sure there are no others */
	if (promotable_exists (lock->repository))
d576 5
a580 2
	    /* clean up the lock dir */
	    clear_lock (lock);
d583 1
a583 1
	    return L_LOCKED;
d586 3
a588 3
	/* write the promotable-lock file */
	lock->file1 = lock_name (lock->repository, promotablelock);
	if ((fp = CVS_FOPEN (lock->file1, "w+")) == NULL || fclose (fp) == EOF)
d592 2
a593 2
	    if (CVS_UNLINK (lock->file1) < 0 && ! existence_error (errno))
		error (0, errno, "failed to remove lock %s", lock->file1);
d595 5
a599 2
	    /* free the lock dir */
	    clear_lock (lock);
d602 1
a602 2
	    error (0, xerrno,
		   "cannot create promotable lock in repository `%s'",
d604 2
a605 1
	    return L_ERROR;
d607 2
a608 34

#ifdef LOCK_COMPATIBILITY
	/* write the read-lock file.  We only do this so that older versions of
	 * CVS will not think it is okay to create a write lock.  When it is
	 * decided that versions of CVS earlier than 1.12.4 are not likely to
	 * be used, this code can be removed.
	 */
	set_readlock_name ();
	lock->file2 = lock_name (lock->repository, readlock);
	if ((fp = CVS_FOPEN (lock->file2, "w+")) == NULL || fclose (fp) == EOF)
	{
	    int xerrno = errno;

	    if ( CVS_UNLINK (lock->file2) < 0 && ! existence_error (errno))
		error (0, errno, "failed to remove lock %s", lock->file2);

	    /* free the lock dir */
	    clear_lock (lock);

	    /* Remove the promotable lock.  */
	    lock->file2 = NULL;
	    remove_lock_files (lock, 0);

	    /* return the error */
	    error (0, xerrno,
		   "cannot create read lock in repository `%s'",
		   lock->repository);
	    return L_ERROR;
	}
#endif /* LOCK_COMPATIBILITY */

	clear_lock (lock);

	return L_OK;
d611 1
a611 1
	return status;
a613 2


d615 3
a617 21
 * walklist proc for setting write locks.  Mostly just a wrapper for the
 * set_promotable_lock function, which has a prettier API, but no other good
 * reason for existing separately.
 *
 * INPUTS
 *   p		The current node, as determined by walklist().
 *   closure	Not used.
 *
 * GLOBAL INPUTS
 *   lock_error		Any previous error encountered while attempting to get
 *                      a lock.
 *
 * GLOBAL OUTPUTS
 *   lock_error		Set if we encounter an error attempting to get axi
 *			promotable lock.
 *   lock_error_repos	Set so that if we set lock_error later functions will
 *			be able to report where the other process's lock was
 *			encountered.
 *
 * RETURNS
 *   0 for no error.
d620 2
a621 1
set_promotablelock_proc (Node *p, void *closure)
d623 5
a627 3
    /* if some lock was not OK, just skip this one */
    if (lock_error != L_OK)
	return 0;
d629 3
a631 62
    /* apply the write lock */
    lock_error_repos = p->key;
    lock_error = set_promotable_lock ((struct lock *)p->data);
    return 0;
}



/*
 * Print out a message that the lock is still held, then sleep a while.
 */
static void
lock_wait (const char *repos)
{
    time_t now;
    char *msg;
    struct tm *tm_p;

    (void) time (&now);
    tm_p = gmtime (&now);
    msg = xmalloc (100 + strlen (lockers_name) + strlen (repos));
    sprintf (msg, "[%8.8s] waiting for %s's lock in %s",
	     (tm_p ? asctime (tm_p) : ctime (&now)) + 11,
	     lockers_name, repos);
    error (0, 0, "%s", msg);
    /* Call cvs_flusherr to ensure that the user sees this message as
       soon as possible.  */
    cvs_flusherr ();
    free (msg);
    (void)sleep (CVSLCKSLEEP);
}



/*
 * Print out a message when we obtain a lock.
 */
static void
lock_obtained (const char *repos)
{
    time_t now;
    char *msg;
    struct tm *tm_p;

    (void) time (&now);
    tm_p = gmtime (&now);
    msg = xmalloc (100 + strlen (repos));
    sprintf (msg, "[%8.8s] obtained lock in %s",
	     (tm_p ? asctime (tm_p) : ctime (&now)) + 11, repos);
    error (0, 0, "%s", msg);
    /* Call cvs_flusherr to ensure that the user sees this message as
       soon as possible.  */
    cvs_flusherr ();
    free (msg);
}



static int
lock_list_promotably (List *list)
{
    char *wait_repos;
d633 2
a634 1
    TRACE (TRACE_FLOW, "lock_list_promotably ()");
d636 2
a637 21
    if (noexec)
	return 0;

    if (readonlyfs) {
	error (0, 0,
	       "promotable lock failed.\n\
WARNING: Read-only repository access mode selected via `cvs -R'.\n\
Attempting to write to a read-only filesystem is not allowed.");
	return 1;
    }

    /* We only know how to do one list at a time */
    if (locklist != (List *) NULL)
    {
	error (0, 0,
	       "lock_list_promotably called while promotable locks set - Help!");
	return 1;
    }

    wait_repos = NULL;
    for (;;)
d639 1
a639 11
	/* try to lock everything on the list */
	lock_error = L_OK;		/* init for set_promotablelock_proc */
	lock_error_repos = (char *) NULL; /* init for set_promotablelock_proc */
	locklist = list;		/* init for Lock_Cleanup */
	if (lockers_name != NULL)
	    free (lockers_name);
	lockers_name = xstrdup ("unknown");

	(void) walklist (list, set_promotablelock_proc, NULL);

	switch (lock_error)
d641 4
a644 6
	    case L_ERROR:		/* Real Error */
		if (wait_repos != NULL)
		    free (wait_repos);
		Lock_Cleanup ();	/* clean up any locks we set */
		error (0, 0, "lock failed - giving up");
		return 1;
d646 11
a656 8
	    case L_LOCKED:		/* Someone already had a lock */
		remove_locks ();	/* clean up any locks we set */
		lock_wait (lock_error_repos); /* sleep a while and try again */
		wait_repos = xstrdup (lock_error_repos);
		continue;

	    case L_OK:			/* we got the locks set */
	        if (wait_repos != NULL)
d658 3
a660 2
		    lock_obtained (wait_repos);
		    free (wait_repos);
d662 13
a674 1
		return 0;
d676 2
a677 6
	    default:
		if (wait_repos != NULL)
		    free (wait_repos);
		error (0, 0, "unknown lock status %d in lock_list_promotably",
		       lock_error);
		return 1;
d679 1
d681 5
a687 2


d693 2
a694 1
set_lockers_name (struct stat *statp)
d700 2
a701 2
    if ((pw = (struct passwd *)getpwuid (statp->st_uid)) !=
	(struct passwd *)NULL)
d708 1
a708 1
	(void)sprintf (lockers_name, "uid%lu", (unsigned long) statp->st_uid);
a711 2


d713 2
a714 5
 * Persistently tries to make the directory "lckdir", which serves as a
 * lock.
 *
 * #ifdef CVS_FUDGELOCKS
 * If the create time on the directory is greater than CVSLCKAGE
a715 2
 * #endif
 *
d718 3
a720 1
set_lock (struct lock *lock, int will_wait)
a722 1
    long us;
a728 3
    TRACE (TRACE_FLOW, "set_lock (%s, %d)",
	   lock->repository ? lock->repository : "(null)", will_wait);

a738 1
    us = 1;
a799 14

	/* if possible, try a very short sleep without a message */
	if (!waited && us < 1000)
	{
	    us += us;
	    {
		struct timespec ts;
		ts.tv_sec = 0;
		ts.tv_nsec = us * 1000;
		(void)nanosleep (&ts, NULL);
		continue;
	    }
	}

a804 2


d810 2
a811 1
clear_lock (struct lock *lock)
d820 31
d852 13
d871 6
a876 2
lock_filesdoneproc (void *callerdat, int err, const char *repository,
                    const char *update_dir, List *entries)
a884 4
    ((struct lock *)p->data)->file1 = NULL;
#ifdef LOCK_COMPATIBILITY
    ((struct lock *)p->data)->file2 = NULL;
#endif /* LOCK_COMPATIBILITY */
a885 1
    ((struct lock *)p->data)->free_repository = 0;
d890 1
a890 1
    return err;
a892 2


d894 6
a899 1
lock_tree_promotably (int argc, char **argv, int local, int which, int aflag)
d901 1
a901 3
    TRACE (TRACE_FUNCTION, "lock_tree_promotably (%d, argv, %d, %d, %d)",
	   argc, local, which, aflag);

d907 3
a909 5
    start_recursion
	(NULL, lock_filesdoneproc,
	 NULL, NULL, NULL, argc,
	 argv, local, which, aflag, CVS_LOCK_NONE,
	 NULL, 0, NULL );
d911 1
a911 1
    if (lock_list_promotably (lock_tree_list) != 0)
d914 1
a914 3



d916 2
a917 6
 * a lock has been set with lock_dir_for_write; the new lock will replace
 * the old one.  If REPOSITORY is NULL, don't do anything.
 *
 * We do not clear the dir lock after writing the lock file name since write
 * locks are exclusive to all other locks.
 */
d919 2
a920 1
lock_dir_for_write (const char *repository)
a921 4
    int waiting = 0;

    TRACE (TRACE_FLOW, "lock_dir_for_write (%s)", repository);

d923 2
a924 2
	&& (global_writelock.repository == NULL
	    || !strcmp (global_writelock.repository, repository)))
d926 1
a926 17
	if (writelock == NULL)
	{
	    writelock = xmalloc (strlen (hostname) + sizeof (CVSWFL) + 40);
	    (void) sprintf (writelock,
#ifdef HAVE_LONG_FILE_NAMES
			    "%s.%s.%ld", CVSWFL, hostname,
#else
			    "%s.%ld", CVSWFL,
#endif
			    (long) getpid());
	}

	if (global_writelock.repository != NULL)
	    remove_lock_files (&global_writelock, 1);

	global_writelock.repository = xstrdup (repository);
	global_writelock.free_repository = 1;
d928 2
a929 3
	for (;;)
	{
	    FILE *fp;
d931 8
a938 24
	    if (set_lock (&global_writelock, 1) != L_OK)
		error (1, 0, "failed to obtain write lock in repository `%s'",
		       repository);

	    /* check if readers exist */
	    if (readers_exist (repository)
		|| promotable_exists (repository))
	    {
		clear_lock (&global_writelock);
		lock_wait (repository); /* sleep a while and try again */
		waiting = 1;
		continue;
	    }

	    if (waiting)
		lock_obtained (repository);

	    /* write the write-lock file */
	    global_writelock.file1 = lock_name (global_writelock.repository,
	                                        writelock);
	    if ((fp = CVS_FOPEN (global_writelock.file1, "w+")) == NULL
		|| fclose (fp) == EOF)
	    {
		int xerrno = errno;
d940 2
a941 29
		if (CVS_UNLINK (global_writelock.file1) < 0
		    && !existence_error (errno))
		{
		    error (0, errno, "failed to remove write lock %s",
			   global_writelock.file1);
		}

		/* free the lock dir */
		clear_lock (&global_writelock);

		/* return the error */
		error (1, xerrno,
		       "cannot create write lock in repository `%s'",
		       global_writelock.repository);
	    }

	    /* If we upgraded from a promotable lock, remove it. */
	    if (locklist)
	    {
		Node *p = findnode (locklist, repository);
		if (p)
		{
		    remove_lock_files (p->data, 1);
		    delnode (p);
		}
	    }

	    break;
	}
@


1.1.3.1
log
@our CVS is currently at 1.11.1p1, thus import that version into vendor branch
@
text
@d399 1
a399 1
    if (noexec)
@


1.1.3.2
log
@CVS 1.11.12 is the latest stable version of CVS,
released 06.02.2004, with a huge lot of bug fixes.

/me hopes this will pay off...
@
text
@d58 4
a61 1
   2.  Provide an option to disable locks for operations which only
d64 1
a64 1
   3.  Have a server internally do the locking.  Probably a good
d68 6
a73 1
   much, much work still to be done before this is feasible.  */
a77 10
#ifdef HAVE_NANOSLEEP
# include "xtime.h"
#else /* HAVE_NANOSLEEP */
# if !defined HAVE_USLEEP && defined HAVE_SELECT
    /* use select as a workaround */
#   include "xselect.h"
# endif /* !defined HAVE_USLEEP && defined HAVE_SELECT */
#endif /* !HAVE_NANOSLEEP */


a293 3
    if (trace)
	(void) fprintf (stderr, "%s-> Lock_Cleanup()\n", CLIENT_SERVER_STR);

a398 4
    if (trace)
	(void) fprintf (stderr, "%s-> Reader_Lock(%s)\n", CLIENT_SERVER_STR,
                        xrepository);

a556 4
    if (trace)
	(void) fprintf (stderr, "%s-> write_lock(%s)\n",
                        CLIENT_SERVER_STR, lock->repository);

a622 1
    char *lockdir;
d627 2
a628 1
    int ret;
d630 1
a630 2
    time_t now;
    (void) time (&now);
d633 2
a634 2
    lockdir = lock_name (repository, "");
    lockdir[strlen (lockdir) - 1] = '\0';   /* remove trailing slash */
d636 9
a644 3
    do {
	if ((dirp = CVS_OPENDIR (lockdir)) == NULL)
	    error (1, 0, "cannot open directory %s", lockdir);
d646 3
a648 5
	ret = 0;
	errno = 0;
	while ((dp = CVS_READDIR (dirp)) != NULL)
	{
	    if (CVS_FNMATCH (CVSRFLPAT, dp->d_name, 0) == 0)
a649 4
		line = xmalloc (strlen (lockdir) + 1 + strlen (dp->d_name) + 1);
		(void) sprintf (line, "%s/%s", lockdir, dp->d_name);
		if ( CVS_STAT (line, &sb) != -1)
		{
d651 6
a656 16
		    /*
		     * If the create time of the file is more than CVSLCKAGE 
		     * seconds ago, try to clean-up the lock file, and if
		     * successful, re-open the directory and try again.
		     */
		    if (now >= (sb.st_ctime + CVSLCKAGE) &&
                        CVS_UNLINK (line) != -1)
		    {
			free (line);
			ret = -1;
			break;
		    }
#endif
		    set_lockers_name (&sb);
		}
		else
d658 3
a660 5
		    /* If the file doesn't exist, it just means that it disappeared
		       between the time we did the readdir and the time we did
		       the stat.  */
		    if (!existence_error (errno))
			error (0, errno, "cannot stat %s", line);
d662 10
a671 4
		errno = 0;
		free (line);
		ret = 1;
		break;
d674 4
d679 4
a682 2
	if (errno != 0)
	    error (0, errno, "error reading directory %s", repository);
d684 1
a684 2
	CVS_CLOSEDIR (dirp);
    } while (ret < 0);
d713 2
a714 5
 * Persistently tries to make the directory "lckdir", which serves as a
 * lock.
 *
 * #ifdef CVS_FUDGELOCKS
 * If the create time on the directory is greater than CVSLCKAGE
a715 2
 * #endif
 *
a722 1
    long us;
a738 1
    us = 1;
a799 27

	/* if possible, try a very short sleep without a message */
	if (!waited && us < 1000)
	{
	    us += us;
#if defined HAVE_NANOSLEEP
	    {
		struct timespec ts;
		ts.tv_sec = 0;
		ts.tv_nsec = us * 1000;
		(void)nanosleep (&ts, NULL);
		continue;
	    }
#elif defined HAVE_USLEEP
	    (void)usleep (us);
	    continue;
#elif defined HAVE_SELECT
	    {
		struct timeval tv;
		tv.tv_sec = 0;
		tv.tv_usec = us;
		(void)select (0, (fd_set *)NULL, (fd_set *)NULL, (fd_set *)NULL, &tv);
		continue;
	    }
#endif
	}

a828 1
    struct tm *tm_p;
a830 1
    tm_p = gmtime (&now);
d832 1
a832 2
    sprintf (msg, "[%8.8s] waiting for %s's lock in %s",
	     (tm_p ? asctime (tm_p) : ctime (&now)) + 11,
a850 1
    struct tm *tm_p;
a852 1
    tm_p = gmtime (&now);
d854 1
a854 2
    sprintf (msg, "[%8.8s] obtained lock in %s",
	     (tm_p ? asctime (tm_p) : ctime (&now)) + 11, repos);
d901 1
d907 3
a909 4
    start_recursion ((FILEPROC) NULL, lock_filesdoneproc,
		     (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL, argc,
		     argv, local, which, aflag, CVS_LOCK_NONE,
		     (char *) NULL, 0, (char *) NULL);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
