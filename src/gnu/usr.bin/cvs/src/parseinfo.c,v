head	1.11;
access;
symbols
	cvs-1_12_11:1.1.2.2
	tg-mergetmp-mirosx-1:1.10
	tg-mergefixes-1-branch:1.10.0.4
	tg-mergefixes-1-base:1.10
	MIROS_X:1.10.0.2
	MIROS_X_BASE:1.10
	cvs-1_12_10:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_MIRPPC:1.7.0.4
	MIRBSD_XP_SPARC_BASE:1.7
	MIRBSD_XP_SPARC:1.7.0.2
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.5
	cvs-200405160640:1.1.1.1
	cvs-200404170130:1.1.1.1
	cvs-1_11_12:1.1.3.2
	cvs-1_11_1p1:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.5.0.6
	MIRBSD_7:1.5.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.5
	MIRBSD_7_DEV:1.5.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.5
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.5
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2005.01.08.21.31.31;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.07.18.38.14;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.03.20.23.09;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.02.12.40.19;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.22.13.49.15;	author tg;	state Stab;
branches;
next	1.6;

1.6
date	2004.02.12.21.16.17;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.30.12.31.39;	author tg;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2003.03.30.12.22.02;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.30.12.20.48;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.30.12.15.17;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.32;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.41.32;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2004.12.02.11.58.58;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.01.08.21.14.04;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.02.12.19.19.15;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.12.19.39.45;	author tg;	state Exp;
branches;
next	;

1.5.4.1
date	2004.12.03.22.04.10;	author tg;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2004.12.07.18.38.11;	author tg;	state Exp;
branches;
next	;


desc
@@


1.11
log
@fastmerge
@
text
@/* $MirBSD: src/gnu/usr.bin/cvs/src/parseinfo.c,v 1.10 2004/12/07 18:38:14 tg Exp $ */

/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 *
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 */

#include "cvs.h"
#include "getline.h"
#include "history.h"

__RCSID("$MirBSD: src/gnu/usr.bin/cvs/src/parseinfo.c,v 1.10 2004/12/07 18:38:14 tg Exp $");


/*
 * Parse the INFOFILE file for the specified REPOSITORY.  Invoke CALLPROC for
 * the first line in the file that matches the REPOSITORY, or if ALL != 0, any
 * lines matching "ALL", or if no lines match, the last line matching
 * "DEFAULT".
 *
 * Return 0 for success, -1 if there was not an INFOFILE, and >0 for failure.
 */
int
Parse_Info (const char *infofile, const char *repository, CALLPROC callproc,
            int opt, void *closure)
{
    int err = 0;
    FILE *fp_info;
    char *infopath;
    char *line = NULL;
    size_t line_allocated = 0;
    char *default_value = NULL;
    int default_line = 0;
    char *expanded_value;
    int callback_done, line_number;
    char *cp, *exp, *value;
    const char *srepos;
    const char *regex_err;

    if (current_parsed_root == NULL)
    {
	/* XXX - should be error maybe? */
	error (0, 0, "CVSROOT variable not set");
	return 1;
    }

    /* find the info file and open it */
    infopath = xmalloc (strlen (current_parsed_root->directory)
			+ strlen (infofile)
			+ sizeof (CVSROOTADM)
			+ 3);
    (void) sprintf (infopath, "%s/%s/%s", current_parsed_root->directory,
		    CVSROOTADM, infofile);
    fp_info = CVS_FOPEN (infopath, "r");
    if (fp_info == NULL)
    {
	/* If no file, don't do anything special.  */
	if (!existence_error (errno))
	    error (0, errno, "cannot open %s", infopath);
	free (infopath);
	return 0;
    }

    /* strip off the CVSROOT if repository was absolute */
    srepos = Short_Repository (repository);

    TRACE (1, "Parse_Info (%s, %s, %s)",
	   infopath, srepos,  (opt & PIOPT_ALL) ? "ALL" : "not ALL");

    /* search the info file for lines that match */
    callback_done = line_number = 0;
    while (getline (&line, &line_allocated, fp_info) >= 0)
    {
	line_number++;

	/* skip lines starting with # */
	if (line[0] == '#')
	    continue;

	/* skip whitespace at beginning of line */
	for (cp = line; *cp && isspace ((unsigned char) *cp); cp++)
	    ;

	/* if *cp is null, the whole line was blank */
	if (*cp == '\0')
	    continue;

	/* the regular expression is everything up to the first space */
	for (exp = cp; *cp && !isspace ((unsigned char) *cp); cp++)
	    ;
	if (*cp != '\0')
	    *cp++ = '\0';

	/* skip whitespace up to the start of the matching value */
	while (*cp && isspace ((unsigned char) *cp))
	    cp++;

	/* no value to match with the regular expression is an error */
	if (*cp == '\0')
	{
	    error (0, 0, "syntax error at line %d file %s; ignored",
		   line_number, infopath);
	    continue;
	}
	value = cp;

	/* strip the newline off the end of the value */
	if ((cp = strrchr (value, '\n')) != NULL)
	    *cp = '\0';

	/*
	 * At this point, exp points to the regular expression, and value
	 * points to the value to call the callback routine with.  Evaluate
	 * the regular expression against srepos and callback with the value
	 * if it matches.
	 */

	/* save the default value so we have it later if we need it */
	if (strcmp (exp, "DEFAULT") == 0)
	{
	    if (default_value != NULL)
	    {
		error (0, 0, "Multiple `DEFAULT' lines (%d and %d) in %s file",
		       default_line, line_number, infofile);
		free (default_value);
	    }
	    default_value = xstrdup (value);
	    default_line = line_number;
	    continue;
	}

	/*
	 * For a regular expression of "ALL", do the callback always We may
	 * execute lots of ALL callbacks in addition to *one* regular matching
	 * callback or default
	 */
	if (strcmp (exp, "ALL") == 0)
	{
	    if (!(opt & PIOPT_ALL))
		error (0, 0, "Keyword `ALL' is ignored at line %d in %s file",
		       line_number, infofile);
	    else if ((expanded_value = expand_path (value, infofile,
	                                            line_number, 1))
	             != NULL )
	    {
		err += callproc (repository, expanded_value, closure);
		free (expanded_value);
	    }
	    else
		err++;
	    continue;
	}

	if (callback_done)
	    /* only first matching, plus "ALL"'s */
	    continue;

	/* see if the repository matched this regular expression */
	if ((regex_err = re_comp (exp)) != NULL)
	{
	    error (0, 0, "bad regular expression at line %d file %s: %s",
		   line_number, infofile, regex_err);
	    continue;
	}
	if (re_exec (srepos) == 0)
	    continue;				/* no match */

	/* it did, so do the callback and note that we did one */
	if ((expanded_value = expand_path( value, infofile, line_number, 1)
	    ) != NULL)
	{
	    err += callproc (repository, expanded_value, closure);
	    free (expanded_value);
	}
	else
	    err++;
	callback_done = 1;
    }
    if (ferror (fp_info))
	error (0, errno, "cannot read %s", infopath);
    if (fclose (fp_info) < 0)
	error (0, errno, "cannot close %s", infopath);

    /* if we fell through and didn't callback at all, do the default */
    if (callback_done == 0 && default_value != NULL)
    {
	if ((expanded_value = expand_path (default_value, infofile,
	                                   line_number, 1)
	    ) != NULL)
	{
	    err += callproc (repository, expanded_value, closure);
	    free (expanded_value);
	}
	else
	    err++;
    }

    /* free up space if necessary */
    if (default_value != NULL)
	free (default_value);
    free (infopath);
    if (line != NULL)
	free (line);

    return err;
}



/* Print a warning and return false if P doesn't look like a string specifying
 * something that can be converted into a size_t.
 *
 * Sets *VAL to the parsed value when it is found to be valid.  *VAL will not
 * be altered when false is returned.
 */
static bool
readSizeT (const char *infopath, const char *option, const char *p,
	   size_t *val)
{
    const char *q;
    size_t num, factor = 1;

    if (!strcasecmp ("unlimited", p))
    {
	*val = SIZE_MAX;
	return true;
    }

    /* Record the factor character (kilo, mega, giga, tera).  */
    if (!isdigit (p[strlen(p) - 1]))
    {
	switch (p[strlen(p) - 1])
	{
	    case 'T':
		factor = xtimes (factor, 1024);
	    case 'G':
		factor = xtimes (factor, 1024);
	    case 'M':
		factor = xtimes (factor, 1024);
	    case 'k':
		factor = xtimes (factor, 1024);
		break;
	    default:
		error (0, 0,
    "%s: Unknown %s factor: `%c'",
		       infopath, option, p[strlen(p)]);
		return false;
	}
	TRACE (TRACE_DATA, "readSizeT(): Found factor %u for %s",
	       factor, option);
    }

    /* Verify that *q is a number.  */
    q = p;
    while (q < p + strlen(p) - 1 /* Checked last character above.  */)
    {
	if (!isdigit(*q))
	{
	    error (0, 0,
"%s: %s must be a postitive integer, not '%s'",
		   infopath, option, p);
	    return false;
	}
	q++;
    }

    /* Compute final value.  */
    num = strtoul (p, NULL, 10);
    if (num == ULONG_MAX || num > SIZE_MAX)
	/* Don't return an error, just max out.  */
	num = SIZE_MAX;

    TRACE (TRACE_DATA, "readSizeT(): read number %u for %s", num, option);
    *val = xtimes (strtoul (p, NULL, 10), factor);
    TRACE (TRACE_DATA, "readSizeT(): returnning %u for %s", *val, option);
    return true;
}



/* Allocate and initialize a new config struct.  */
static inline struct config *
new_config (void)
{
    struct config *new = xcalloc (1, sizeof (struct config));

    TRACE (TRACE_FLOW, "new_config ()");

    new->logHistory = ALL_HISTORY_REC_TYPES;
    new->RereadLogAfterVerify = LOGMSG_REREAD_ALWAYS;
    new->UserAdminOptions = xstrdup ("k");
    new->MaxCommentLeaderLength = 20;
#ifdef PROXY_SUPPORT
    new->MaxProxyBufferSize = (size_t)(8 * 1024 * 1024); /* 8 megabytes,
                                                          * by default.
                                                          */
#endif /* PROXY_SUPPORT */
#ifdef AUTH_SERVER_SUPPORT
    new->system_auth = true;
#endif /* AUTH_SERVER_SUPPORT */

    return new;
}



void
free_config (struct config *data)
{
    if (data->keywords) free_keywords (data->keywords);
    free (data);
}



/* Parse the CVS config file.  The syntax right now is a bit ad hoc
 * but tries to draw on the best or more common features of the other
 * *info files and various unix (or non-unix) config file syntaxes.
 * Lines starting with # are comments.  Settings are lines of the form
 * KEYWORD=VALUE.  There is currently no way to have a multi-line
 * VALUE (would be nice if there was, probably).
 *
 * CVSROOT is the $CVSROOT directory
 * (current_parsed_root->directory might not be set yet, so this
 * function takes the cvsroot as a function argument).
 *
 * RETURNS
 *   Always returns a fully initialized config struct, which on error may
 *   contain only the defaults.
 *
 * ERRORS
 *   Calls error(0, ...) on errors in addition to the return value.
 *
 *   xmalloc() failures are fatal, per usual.
 */
struct config *
parse_config (const char *cvsroot)
{
    char *infopath;
    FILE *fp_info;
    char *line = NULL;
    size_t line_allocated = 0;
    size_t len;
    char *p;
    struct config *retval;

    TRACE (TRACE_FUNCTION, "parse_config (%s)", cvsroot);

    retval = new_config ();

    infopath = Xasprintf ("%s/%s/%s", cvsroot, CVSROOTADM, CVSROOTADM_CONFIG);

    fp_info = CVS_FOPEN (infopath, "r");
    if (fp_info == NULL)
    {
	/* If no file, don't do anything special.  */
	if (!existence_error (errno))
	{
	    /* Just a warning message; doesn't affect return
	       value, currently at least.  */
	    error (0, errno, "cannot open %s", infopath);
	}
	free (infopath);
	return retval;
    }

    while (getline (&line, &line_allocated, fp_info) >= 0)
    {
	/* Skip comments.  */
	if (line[0] == '#')
	    continue;

	/* At least for the moment we don't skip whitespace at the start
	   of the line.  Too picky?  Maybe.  But being insufficiently
	   picky leads to all sorts of confusion, and it is a lot easier
	   to start out picky and relax it than the other way around.

	   Is there any kind of written standard for the syntax of this
	   sort of config file?  Anywhere in POSIX for example (I guess
	   makefiles are sort of close)?  Red Hat Linux has a bunch of
	   these too (with some GUI tools which edit them)...

	   Along the same lines, we might want a table of keywords,
	   with various types (boolean, string, &c), as a mechanism
	   for making sure the syntax is consistent.  Any good examples
	   to follow there (Apache?)?  */

	/* Strip the trailing newline.  There will be one unless we
	   read a partial line without a newline, and then got end of
	   file (or error?).  */

	len = strlen (line) - 1;
	if (line[len] == '\n')
	    line[len] = '\0';

	/* Skip blank lines.  */
	if (line[0] == '\0')
	    continue;

	TRACE (TRACE_DATA, "parse_info() examining line: `%s'", line);

	/* The first '=' separates keyword from value.  */
	p = strchr (line, '=');
	if (p == NULL)
	{
	    /* Probably should be printing line number.  */
	    error (0, 0, "syntax error in %s: line '%s' is missing '='",
		   infopath, line);
	    continue;
	}

	*p++ = '\0';

	if (strcmp (line, "RCSBIN") == 0)
	{
	    /* This option used to specify the directory for RCS
	       executables.  But since we don't run them any more,
	       this is a noop.  Silently ignore it so that a
	       repository can work with either new or old CVS.  */
	    ;
	}
	else if (strcmp (line, "SystemAuth") == 0)
#ifdef AUTH_SERVER_SUPPORT
	    readBool (infopath, "SystemAuth", p, &retval->system_auth);
#else
	{
	    /* Still parse the syntax but ignore the option.  That way the same
	     * config file can be used for local and server.
	     */
	    bool dummy;
	    readBool (infopath, "SystemAuth", p, &dummy);
	}
#endif
	else if (strcmp (line, "LocalKeyword") == 0)
	    RCS_setlocalid (&retval->keywords, p);
	else if (strcmp (line, "KeywordExpand") == 0)
	    RCS_setincexc (&retval->keywords, p);
	else if (strcmp (line, "PreservePermissions") == 0)
#ifdef PRESERVE_PERMISSIONS_SUPPORT
	    readBool (infopath, "PreservePermissions", p,
		      &retval->preserve_perms);
#else
	    error (0, 0, "\
warning: this CVS does not support PreservePermissions");
#endif
	else if (strcmp (line, "TopLevelAdmin") == 0)
	    readBool (infopath, "TopLevelAdmin", p, &retval->top_level_admin);
	else if (strcmp (line, "LockDir") == 0)
	{
	    if (retval->lock_dir != NULL)
		free (retval->lock_dir);
	    retval->lock_dir = xstrdup (p);
	    /* Could try some validity checking, like whether we can
	       opendir it or something, but I don't see any particular
	       reason to do that now rather than waiting until lock.c.  */
	}
	else if (strcmp (line, "LogHistory") == 0)
	{
	    if (strcmp (p, "all") != 0)
		retval->logHistory = xstrdup (p);
	}
	else if (strcmp (line, "RereadLogAfterVerify") == 0)
	{
	    if (!strcasecmp (p, "never"))
	      retval->RereadLogAfterVerify = LOGMSG_REREAD_NEVER;
	    else if (!strcasecmp (p, "always"))
	      retval->RereadLogAfterVerify = LOGMSG_REREAD_ALWAYS;
	    else if (!strcasecmp (p, "stat"))
	      retval->RereadLogAfterVerify = LOGMSG_REREAD_STAT;
	    else
	    {
		bool tmp;
		if (readBool (infopath, "RereadLogAfterVerify", p, &tmp))
		{
		    if (tmp)
			retval->RereadLogAfterVerify = LOGMSG_REREAD_ALWAYS;
		    else
			retval->RereadLogAfterVerify = LOGMSG_REREAD_NEVER;
		}
	    }
	}
	else if (strcmp (line, "UserAdminOptions") == 0)
	    retval->UserAdminOptions = xstrdup (p);
	else if (strcmp (line, "UseNewInfoFmtStrings") == 0)
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	    readBool (infopath, "UseNewInfoFmtStrings", p,
		      &retval->UseNewInfoFmtStrings);
#else /* !SUPPORT_OLD_INFO_FMT_STRINGS */
	{
	    bool dummy;
	    if (readBool (infopath, "UseNewInfoFmtStrings", p, &dummy)
		&& !dummy)
		error (1, 0,
"%s: Old style info format strings not supported by this executable.",
		       infopath);
	}
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	else if (strcmp (line, "ImportNewFilesToVendorBranchOnly") == 0)
	    readBool (infopath, "ImportNewFilesToVendorBranchOnly", p,
		      &retval->ImportNewFilesToVendorBranchOnly);
#ifdef PROXY_SUPPORT
	else if (strcmp (line, "PrimaryServer") == 0)
	{
	    retval->PrimaryServer = parse_cvsroot (p);
	    if (retval->PrimaryServer->method != fork_method
		&& retval->PrimaryServer->method != ext_method)
	    {
		/* I intentionally neglect to mention :fork: here.  It is
	         * really only useful for testing.
		 */
	        error (1, 0,
"%s: Only PrimaryServers with :ext: methods are valid, not `%s'.",
		       infopath, p);
	    }
	}
	else if (!strcmp (line, "MaxProxyBufferSize"))
	    readSizeT (infopath, "MaxProxyBufferSize", p,
		       &retval->MaxProxyBufferSize);
#endif /* PROXY_SUPPORT */
	else if (!strcmp (line, "MaxCommentLeaderLength"))
	    readSizeT (infopath, "MaxCommentLeaderLength", p,
		       &retval->MaxCommentLeaderLength);
	else if (!strcmp (line, "UseArchiveCommentLeader"))
	    readBool (infopath, "UseArchiveCommentLeader", p,
		      &retval->UseArchiveCommentLeader);
#if !defined(LOCK_COMPATIBILITY) || !defined(SUPPORT_OLD_INFO_FMT_STRINGS)
	else if ((!strcmp (line, "tag")) || (!strcmp (line, "umask"))
	  || (!strcmp (line, "DisableXProg")) || (!strcmp (line, "dlimit"))
	  || (!strcmp (line, "forceReadOnlyFS"))) {
	    /* We are dealing with keywords removed between cvs 1.11.1p1
	       and cvs 1.12.10; odds are we are not being able to handle
	       access or concurrent access with 1.11 cvs correctly */
	    error (0, 0, "%s: found keyword '%s' in repository",
		   infopath, line);
	    error (readonlyfs ? 0 : 1, 0, readonlyfs
		? "Danger: Granting read access to incompatible repository!"
		: "Do not try to access a cvs 1.11 repository!");
	}
#endif
	else
	    /* We may be dealing with a keyword which was added in a
	       subsequent version of CVS.  In that case it is a good idea
	       to complain, as (1) the keyword might enable a behavior like
	       alternate locking behavior, in which it is dangerous and hard
	       to detect if some CVS's have it one way and others have it
	       the other way, (2) in general, having us not do what the user
	       had in mind when they put in the keyword violates the
	       principle of least surprise.  Note that one corollary is
	       adding new keywords to your CVSROOT/config file is not
	       particularly recommended unless you are planning on using
	       the new features.  */
	    error (0, 0, "%s: unrecognized keyword '%s'",
		   infopath, line);
    }
    if (ferror (fp_info))
	error (0, errno, "cannot read %s", infopath);
    if (fclose (fp_info) < 0)
	error (0, errno, "cannot close %s", infopath);
    free (infopath);
    if (line != NULL)
	free (line);
    return retval;
}
@


1.10
log
@let cvs 1.1X access cvs 1.1Y repos read-onlily
(*this is dangerous*)
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/cvs/src/parseinfo.c,v 1.9 2004/12/03 20:23:09 tg Exp $ */
d15 1
a15 1
__RCSID("$MirBSD: src/gnu/usr.bin/cvs/src/parseinfo.c,v 1.9 2004/12/03 20:23:09 tg Exp $");
a208 32
}



/* Print a warning and return false if P doesn't look like a string specifying
 * a boolean value.
 *
 * Sets *VAL to the parsed value when it is found to be valid.  *VAL will not
 * be altered when false is returned.
 */
static bool
readBool (const char *infopath, const char *option, const char *p, bool *val)
{
    TRACE (TRACE_FLOW, "readBool (%s, %s, %s)", infopath, option, p);
    if (!strcasecmp (p, "no") || !strcasecmp (p, "false")
        || !strcasecmp (p, "off") || !strcmp (p, "0"))
    {
	TRACE (TRACE_DATA, "Read %d for %s", *val, option);
	*val = false;
	return true;
    }
    else if (!strcasecmp (p, "yes") || !strcasecmp (p, "true")
	     || !strcasecmp (p, "on") || !strcmp (p, "1"))
    {
	TRACE (TRACE_DATA, "Read %d for %s", *val, option);
	*val = true;
	return true;
    }

    error (0, 0, "%s: unrecognized value '%s' for `%s'",
	   infopath, option, p);
    return false;
@


1.9
log
@abort if trying to locally access an 1.11.1p1 repo
@
text
@d1 1
a1 1
/* $MirBSD$ */
d15 1
a15 1
__RCSID("$MirBSD$");
d570 3
a572 1
	    error (1, 0, "Do not try to access a cvs 1.11 repository!");
@


1.8
log
@update to cvs 1.12.10-MirOS except automatically
generated files
XXX this installs as /usr/bin/ncvs yet, so no
XXX conflicts during the test phase.
XXX I suggest to _not_ update.

XXX *** IMPORTANT *** DO NOT ACCESS CVS 1.11 REPOSITORIES
XXX *** IMPORTANT *** WITH CVS 1.12 OR VICE VERSA!
@
text
@d1 2
d6 1
a6 1
 * 
d15 1
d561 12
@


1.7
log
@cvs-1.11.12 doesn't do the joints correctly (what were the
FSF people smoking?), it memory faults.
thusly revert to 1.11.1p1

tested.
agreed bsiegert@@
@
text
@a0 1
/*	$MirBSD: parseinfo.c,v 1.5 2003/03/30 12:31:39 tg Exp $	*/
d11 1
a11 1
#include <assert.h>
a12 1
static const char RCSId[]="$MirBSD: parseinfo.c,v 1.5 2003/03/30 12:31:39 tg Exp $";
a13 1
extern char *logHistory;
d17 3
a19 2
 * the first line in the file that matches the REPOSITORY, or if ALL != 0, any lines
 * matching "ALL", or if no lines match, the last line matching "DEFAULT".
d24 2
a25 5
Parse_Info (infofile, repository, callproc, all)
    char *infofile;
    char *repository;
    CALLPROC callproc;
    int all;
d33 2
a34 1
    char *expanded_value= NULL;
d36 2
a37 1
    char *cp, *exp, *value, *srepos, bad;
d44 1
a44 1
	return (1);
d67 2
a68 3
    if (trace)
	(void) fprintf (stderr, " -> ParseInfo(%s, %s, %s)\n",
			infopath, srepos, all ? "ALL" : "not ALL");
d102 1
a102 1
		   line_number, infofile);
a110 4
	if (expanded_value != NULL)
	    free (expanded_value);
	expanded_value = expand_path (value, infofile, line_number);

d121 4
a124 3
	    /* Is it OK to silently ignore all but the last DEFAULT
               expression?  */
	    if (default_value != NULL && default_value != &bad)
d126 3
a128 2
	    default_value = (expanded_value != NULL ?
			     xstrdup (expanded_value) : &bad);
d139 10
a148 5
	    if (!all)
		error(0, 0, "Keyword `ALL' is ignored at line %d in %s file",
		      line_number, infofile);
	    else if (expanded_value != NULL)
		err += callproc (repository, expanded_value);
d169 6
a174 2
	if (expanded_value != NULL)
	    err += callproc (repository, expanded_value);
d187 7
a193 2
	if (default_value != &bad)
	    err += callproc (repository, default_value);
d199 1
a199 1
    if (default_value != NULL && default_value != &bad)
a200 2
    if (expanded_value != NULL)
	free (expanded_value);
d205 130
a334 1
    return (err);
a337 6
/* Parse the CVS config file.  The syntax right now is a bit ad hoc
   but tries to draw on the best or more common features of the other
   *info files and various unix (or non-unix) config file syntaxes.
   Lines starting with # are comments.  Settings are lines of the form
   KEYWORD=VALUE.  There is currently no way to have a multi-line
   VALUE (would be nice if there was, probably).
d339 8
a346 2
   CVSROOT is the $CVSROOT directory (current_parsed_root->directory might not be
   set yet).
d348 22
a369 5
   Returns 0 for success, negative value for failure.  Call
   error(0, ...) on errors in addition to the return value.  */
int
parse_config (cvsroot)
    char *cvsroot;
d377 3
a379 9
    /* FIXME-reentrancy: If we do a multi-threaded server, this would need
       to go to the per-connection data structures.  */
    static int parsed = 0;

    /* Authentication code and serve_root might both want to call us.
       Let this happen smoothly.  */
    if (parsed)
	return 0;
    parsed = 1;
d381 1
a381 9
    infopath = malloc (strlen (cvsroot)
			+ sizeof (CVSROOTADM_CONFIG)
			+ sizeof (CVSROOTADM)
			+ 10);
    if (infopath == NULL)
    {
	error (0, 0, "out of memory; cannot allocate infopath");
	goto error_return;
    }
d383 1
a383 5
    strcpy (infopath, cvsroot);
    strcat (infopath, "/");
    strcat (infopath, CVSROOTADM);
    strcat (infopath, "/");
    strcat (infopath, CVSROOTADM_CONFIG);
d396 1
a396 1
	return 0;
d420 1
a420 1
	/* Strip the training newline.  There will be one unless we
d432 2
d441 1
a441 1
	    goto error_return;
a454 2
	{
	    if (strcmp (p, "no") == 0)
d456 1
a456 1
		system_auth = 0;
d458 6
a463 31
		/* Still parse the syntax but ignore the
		   option.  That way the same config file can
		   be used for local and server.  */
		;
#endif
	    else if (strcmp (p, "yes") == 0)
#ifdef AUTH_SERVER_SUPPORT
		system_auth = 1;
#else
		;
#endif
	    else
	    {
		error (0, 0, "unrecognized value '%s' for SystemAuth", p);
		goto error_return;
	    }
	}
	else if (strcmp (line, "forceReadOnlyFS") == 0) {
		/* CTM helper */
	    if (strcmp (p, "no") == 0)
		;
	    else if (strcmp (p, "yes") == 0)
	    {
		readonlyfs = 1;
		logoff = 1;
	    }
	    else
	    {
		error (0, 0, "unrecognized value '%s' for forceReadOnlyFS", p);
		goto error_return;
	    }
a464 40
	else if (strcmp (line, "tag") == 0) {
	    RCS_citag = strdup(p);
	    if (RCS_citag == NULL) {
		error (0, 0, "%s: no memory for local tag '%s'",
		       infopath, p);
		goto error_return;
	    }
	}
	else if (strcmp (line, "umask") == 0) {
	    cvsumask = (mode_t)(strtol(p, NULL, 8) & 0777);
	}
	else if (strcmp (line, "dlimit") == 0) {
#ifdef BSD
#include <sys/resource.h>
	    struct rlimit rl;

	    if (getrlimit(RLIMIT_DATA, &rl) != -1) {
		rl.rlim_cur = atoi(p);
		rl.rlim_cur *= 1024;

		(void) setrlimit(RLIMIT_DATA, &rl);
	    }
#endif /* BSD */
	}
	else if (strcmp (line, "DisableXProg") == 0)
	{
	    if (strcmp (p, "no") == 0)
#ifdef AUTH_SERVER_SUPPORT
		disable_x_prog = 0;
#else
		/* Still parse the syntax but ignore the
		   option.  That way the same config file can
		   be used for local and server.  */
		;
#endif
	    else if (strcmp (p, "yes") == 0)
#ifdef AUTH_SERVER_SUPPORT
		disable_x_prog = 1;
#else
		;
d466 4
a469 6
	    else
	    {
		error (0, 0, "unrecognized value '%s' for DisableXProg", p);
		goto error_return;
	    }
	}
a470 5
	{
	    if (strcmp (p, "no") == 0)
		preserve_perms = 0;
	    else if (strcmp (p, "yes") == 0)
	    {
d472 2
a473 1
		preserve_perms = 1;
d475 1
a475 1
		error (0, 0, "\
a477 8
	    }
	    else
	    {
		error (0, 0, "unrecognized value '%s' for PreservePermissions",
		       p);
		goto error_return;
	    }
	}
d479 1
a479 11
	{
	    if (strcmp (p, "no") == 0)
		top_level_admin = 0;
	    else if (strcmp (p, "yes") == 0)
		top_level_admin = 1;
	    else
	    {
		error (0, 0, "unrecognized value '%s' for TopLevelAdmin", p);
		goto error_return;
	    }
	}
d482 3
a484 3
	    if (lock_dir != NULL)
		free (lock_dir);
	    lock_dir = xstrdup (p);
d492 47
d540 6
a545 2
		logHistory=malloc(strlen (p) + 1);
		strcpy (logHistory, p);
d548 10
a558 1
	{
a571 3
	    /* If readonly, do not bother bailing out -- MirBSD */
	    if (!readonlyfs) goto error_return;
	}
a573 1
    {
a574 2
	goto error_return;
    }
a575 1
    {
a576 2
	goto error_return;
    }
d580 1
a580 8
    return 0;

 error_return:
    if (infopath != NULL)
	free (infopath);
    if (line != NULL)
	free (line);
    return -1;
@


1.6
log
@first step of merging new cvs
XXX might not compile
XXX might not work
XXX might contain bugs
XXX definitively needs autoconf 2.58 first
@
text
@d38 1
a38 2
    int default_line = 0;
    char *expanded_value;
d40 1
a40 1
    char *cp, *exp, *value, *srepos;
d71 1
a71 6
	(void) fprintf (stderr, "%s-> Parse_Info (%s, %s, %s)\n",
#ifdef SERVER_SUPPORT
			server_active ? "S" : " ",
#else
			"",
#endif
d115 4
d129 3
a131 4
	    if (default_value != NULL)
	    {
		error (0, 0, "Multiple `DEFAULT' lines (%d and %d) in %s file",
		       default_line, line_number, infofile);
d133 2
a134 3
	    }
	    default_value = xstrdup(value);
	    default_line = line_number;
d148 1
a148 2
	    else if ((expanded_value = expand_path (value, infofile, line_number)) != NULL)
	    {
a149 2
		free (expanded_value);
	    }
d170 1
a170 2
	if ((expanded_value = expand_path (value, infofile, line_number)) != NULL)
	{
a171 2
	    free (expanded_value);
	}
d184 2
a185 5
	if ((expanded_value = expand_path (default_value, infofile, default_line)) != NULL)
	{
	    err += callproc (repository, expanded_value);
	    free (expanded_value);
	}
d191 1
a191 1
    if (default_value != NULL)
d193 2
d235 1
a235 1
    infopath = xmalloc (strlen (cvsroot)
d448 1
a448 1
		logHistory=xmalloc(strlen (p) + 1);
a450 9
	}
	else if (strcmp (line, "RereadLogAfterVerify") == 0)
	{
	    if (strcmp (p, "no") == 0 || strcmp (p, "never") == 0)
	      RereadLogAfterVerify = LOGMSG_REREAD_NEVER;
	    else if (strcmp (p, "yes") == 0 || strcmp (p, "always") == 0)
	      RereadLogAfterVerify = LOGMSG_REREAD_ALWAYS;
	    else if (strcmp (p, "stat") == 0)
	      RereadLogAfterVerify = LOGMSG_REREAD_STAT;
@


1.5
log
@Another good idea: if readonly, don't bother
breaking when seeing unknown keywords.
@
text
@d1 1
a1 1
/*	$MirBSD: parseinfo.c,v 1.4 2003/03/30 12:22:02 tg Exp $	*/
d14 1
a14 1
static const char RCSId[]="$MirBSD$";
d38 2
a39 1
    char *expanded_value= NULL;
d41 1
a41 1
    char *cp, *exp, *value, *srepos, bad;
d72 6
a77 1
	(void) fprintf (stderr, " -> ParseInfo(%s, %s, %s)\n",
a120 4
	if (expanded_value != NULL)
	    free (expanded_value);
	expanded_value = expand_path (value, infofile, line_number);

d131 4
a134 3
	    /* Is it OK to silently ignore all but the last DEFAULT
               expression?  */
	    if (default_value != NULL && default_value != &bad)
d136 3
a138 2
	    default_value = (expanded_value != NULL ?
			     xstrdup (expanded_value) : &bad);
d152 2
a153 1
	    else if (expanded_value != NULL)
d155 2
d177 2
a178 1
	if (expanded_value != NULL)
d180 2
d194 5
a198 2
	if (default_value != &bad)
	    err += callproc (repository, default_value);
d204 1
a204 1
    if (default_value != NULL && default_value != &bad)
a205 2
    if (expanded_value != NULL)
	free (expanded_value);
d246 1
a246 1
    infopath = malloc (strlen (cvsroot)
d459 1
a459 1
		logHistory=malloc(strlen (p) + 1);
d462 9
@


1.5.4.1
log
@#7-stable: always error out on unknown keywords.
@
text
@d1 1
a1 1
/*	$MirBSD: src/gnu/usr.bin/cvs/src/parseinfo.c,v 1.5 2003/03/30 12:31:39 tg Exp $	*/
d14 1
a14 1
static const char RCSId[]="$MirBSD: src/gnu/usr.bin/cvs/src/parseinfo.c,v 1.5 2003/03/30 12:31:39 tg Exp $";
d465 1
a465 1
	    error (1, 0, "%s: unrecognized keyword '%s'",
d467 2
@


1.5.4.2
log
@let cvs 1.1X access cvs 1.1Y repos read-onlily
(*this is dangerous*)
@
text
@d1 1
a1 1
/*	$MirBSD: src/gnu/usr.bin/cvs/src/parseinfo.c,v 1.5.4.1 2004/12/03 22:04:10 tg Exp $	*/
d14 1
a14 1
static const char RCSId[]="$MirBSD: src/gnu/usr.bin/cvs/src/parseinfo.c,v 1.5.4.1 2004/12/03 22:04:10 tg Exp $";
d465 1
a465 1
	    error (0, 0, "%s: unrecognized keyword '%s'",
a466 3
	    error (readonlyfs ? 0 : 1, 0, readonlyfs
		? "Danger: Granting read access to incompatible repository!"
		: "Do not try to access an incompatible cvs repository!");
@


1.4
log
@GNU coding styles suck. I overlooked the { }
@
text
@d1 1
a1 1
/*	$MirBSD: parseinfo.c,v 1.3 2003/03/30 12:20:48 tg Exp $	*/
d14 2
d467 2
a468 1
	    goto error_return;
@


1.3
log
@fix it right this time
add RCS Id
@
text
@d1 1
a1 1
/*	$MirBSD$	*/
d344 1
d347 1
@


1.2
log
@Add another option to CVSROOT/config (forceReadOnlyFS),
which equivalents "env CVSREADONLYFS=1", and document
some additions to that file.
@
text
@d1 1
d341 3
d346 5
@


1.1
log
@Initial revision
@
text
@d338 5
@


1.1.2.1
log
@vendor-branch-ify new cvs 1.12
@
text
@d11 1
a11 2
#include "history.h"

d13 1
d17 2
a18 3
 * the first line in the file that matches the REPOSITORY, or if ALL != 0, any
 * lines matching "ALL", or if no lines match, the last line matching
 * "DEFAULT".
d23 5
a27 2
Parse_Info (const char *infofile, const char *repository, CALLPROC callproc,
            int opt, void *closure)
d35 1
a35 2
    int default_line = 0;
    char *expanded_value;
d37 1
a37 2
    char *cp, *exp, *value;
    const char *srepos;
d44 1
a44 1
	return 1;
d67 3
a69 2
    TRACE (1, "Parse_Info (%s, %s, %s)",
	   infopath, srepos,  (opt & PIOPT_ALL) ? "ALL" : "not ALL");
d103 1
a103 1
		   line_number, infopath);
d112 4
d126 3
a128 4
	    if (default_value != NULL)
	    {
		error (0, 0, "Multiple `DEFAULT' lines (%d and %d) in %s file",
		       default_line, line_number, infofile);
d130 2
a131 3
	    }
	    default_value = xstrdup (value);
	    default_line = line_number;
d142 5
a146 10
	    if (!(opt & PIOPT_ALL))
		error (0, 0, "Keyword `ALL' is ignored at line %d in %s file",
		       line_number, infofile);
	    else if ((expanded_value = expand_path (value, infofile,
	                                            line_number, 1))
	             != NULL )
	    {
		err += callproc (repository, expanded_value, closure);
		free (expanded_value);
	    }
d167 2
a168 6
	if ((expanded_value = expand_path( value, infofile, line_number, 1)
	    ) != NULL)
	{
	    err += callproc (repository, expanded_value, closure);
	    free (expanded_value);
	}
d181 2
a182 7
	if ((expanded_value = expand_path (default_value, infofile,
	                                   line_number, 1)
	    ) != NULL)
	{
	    err += callproc (repository, expanded_value, closure);
	    free (expanded_value);
	}
d188 1
a188 1
    if (default_value != NULL)
d190 2
d196 1
a196 1
    return err;
d200 6
d207 2
a208 24
/* Print a warning and return false if P doesn't look like a string specifying
 * a boolean value.
 *
 * Sets *VAL to the parsed value when it is found to be valid.  *VAL will not
 * be altered when false is returned.
 */
static bool
readBool (const char *infopath, const char *option, const char *p, bool *val)
{
    TRACE (TRACE_FLOW, "readBool (%s, %s, %s)", infopath, option, p);
    if (!strcasecmp (p, "no") || !strcasecmp (p, "false")
        || !strcasecmp (p, "off") || !strcmp (p, "0"))
    {
	TRACE (TRACE_DATA, "Read %d for %s", *val, option);
	*val = false;
	return true;
    }
    else if (!strcasecmp (p, "yes") || !strcasecmp (p, "true")
	     || !strcasecmp (p, "on") || !strcmp (p, "1"))
    {
	TRACE (TRACE_DATA, "Read %d for %s", *val, option);
	*val = true;
	return true;
    }
d210 5
a214 135
    error (0, 0, "%s: unrecognized value '%s' for `%s'",
	   infopath, option, p);
    return false;
}



/* Print a warning and return false if P doesn't look like a string specifying
 * something that can be converted into a size_t.
 *
 * Sets *VAL to the parsed value when it is found to be valid.  *VAL will not
 * be altered when false is returned.
 */
static bool
readSizeT (const char *infopath, const char *option, const char *p,
	   size_t *val)
{
    const char *q;
    size_t num, factor = 1;

    if (!strcasecmp ("unlimited", p))
    {
	*val = SIZE_MAX;
	return true;
    }

    /* Record the factor character (kilo, mega, giga, tera).  */
    if (!isdigit (p[strlen(p) - 1]))
    {
	switch (p[strlen(p) - 1])
	{
	    case 'T':
		factor = xtimes (factor, 1024);
	    case 'G':
		factor = xtimes (factor, 1024);
	    case 'M':
		factor = xtimes (factor, 1024);
	    case 'k':
		factor = xtimes (factor, 1024);
		break;
	    default:
		error (0, 0,
    "%s: Unknown %s factor: `%c'",
		       infopath, option, p[strlen(p)]);
		return false;
	}
	TRACE (TRACE_DATA, "readSizeT(): Found factor %u for %s",
	       factor, option);
    }

    /* Verify that *q is a number.  */
    q = p;
    while (q < p + strlen(p) - 1 /* Checked last character above.  */)
    {
	if (!isdigit(*q))
	{
	    error (0, 0,
"%s: %s must be a postitive integer, not '%s'",
		   infopath, option, p);
	    return false;
	}
	q++;
    }

    /* Compute final value.  */
    num = strtoul (p, NULL, 10);
    if (num == ULONG_MAX || num > SIZE_MAX)
	/* Don't return an error, just max out.  */
	num = SIZE_MAX;

    TRACE (TRACE_DATA, "readSizeT(): read number %u for %s", num, option);
    *val = xtimes (strtoul (p, NULL, 10), factor);
    TRACE (TRACE_DATA, "readSizeT(): returnning %u for %s", *val, option);
    return true;
}



/* Allocate and initialize a new config struct.  */
static inline struct config *
new_config (void)
{
    struct config *new = xcalloc (1, sizeof (struct config));

    TRACE (TRACE_FLOW, "new_config ()");

    new->logHistory = ALL_HISTORY_REC_TYPES;
    new->RereadLogAfterVerify = LOGMSG_REREAD_ALWAYS;
    new->UserAdminOptions = xstrdup ("k");
    new->MaxCommentLeaderLength = 20;
#ifdef PROXY_SUPPORT
    new->MaxProxyBufferSize = (size_t)(8 * 1024 * 1024); /* 8 megabytes,
                                                          * by default.
                                                          */
#endif /* PROXY_SUPPORT */
#ifdef AUTH_SERVER_SUPPORT
    new->system_auth = true;
#endif /* AUTH_SERVER_SUPPORT */

    return new;
}



void
free_config (struct config *data)
{
    if (data->keywords) free_keywords (data->keywords);
    free (data);
}



/* Parse the CVS config file.  The syntax right now is a bit ad hoc
 * but tries to draw on the best or more common features of the other
 * *info files and various unix (or non-unix) config file syntaxes.
 * Lines starting with # are comments.  Settings are lines of the form
 * KEYWORD=VALUE.  There is currently no way to have a multi-line
 * VALUE (would be nice if there was, probably).
 *
 * CVSROOT is the $CVSROOT directory
 * (current_parsed_root->directory might not be set yet, so this
 * function takes the cvsroot as a function argument).
 *
 * RETURNS
 *   Always returns a fully initialized config struct, which on error may
 *   contain only the defaults.
 *
 * ERRORS
 *   Calls error(0, ...) on errors in addition to the return value.
 *
 *   xmalloc() failures are fatal, per usual.
 */
struct config *
parse_config (const char *cvsroot)
d222 9
a230 1
    struct config *retval;
d232 9
a240 3
    TRACE (TRACE_FUNCTION, "parse_config (%s)", cvsroot);

    retval = new_config ();
d242 5
a246 1
    infopath = Xasprintf ("%s/%s/%s", cvsroot, CVSROOTADM, CVSROOTADM_CONFIG);
d259 1
a259 1
	return retval;
d283 1
a283 1
	/* Strip the trailing newline.  There will be one unless we
a294 2
	TRACE (TRACE_DATA, "parse_info() examining line: `%s'", line);

d302 1
a302 1
	    continue;
d316 11
d328 1
a328 1
	    readBool (infopath, "SystemAuth", p, &retval->system_auth);
d330 33
d364 20
a383 5
	    /* Still parse the syntax but ignore the option.  That way the same
	     * config file can be used for local and server.
	     */
	    bool dummy;
	    readBool (infopath, "SystemAuth", p, &dummy);
a384 5
#endif
	else if (strcmp (line, "LocalKeyword") == 0)
	    RCS_setlocalid (&retval->keywords, p);
	else if (strcmp (line, "KeywordExpand") == 0)
	    RCS_setincexc (&retval->keywords, p);
d386 5
d392 1
a392 2
	    readBool (infopath, "PreservePermissions", p,
		      &retval->preserve_perms);
d394 1
a394 1
	    error (0, 0, "\
d397 8
d406 11
a416 1
	    readBool (infopath, "TopLevelAdmin", p, &retval->top_level_admin);
d419 3
a421 3
	    if (retval->lock_dir != NULL)
		free (retval->lock_dir);
	    retval->lock_dir = xstrdup (p);
a428 47
		retval->logHistory = xstrdup (p);
	}
	else if (strcmp (line, "RereadLogAfterVerify") == 0)
	{
	    if (!strcasecmp (p, "never"))
	      retval->RereadLogAfterVerify = LOGMSG_REREAD_NEVER;
	    else if (!strcasecmp (p, "always"))
	      retval->RereadLogAfterVerify = LOGMSG_REREAD_ALWAYS;
	    else if (!strcasecmp (p, "stat"))
	      retval->RereadLogAfterVerify = LOGMSG_REREAD_STAT;
	    else
	    {
		bool tmp;
		if (readBool (infopath, "RereadLogAfterVerify", p, &tmp))
		{
		    if (tmp)
			retval->RereadLogAfterVerify = LOGMSG_REREAD_ALWAYS;
		    else
			retval->RereadLogAfterVerify = LOGMSG_REREAD_NEVER;
		}
	    }
	}
	else if (strcmp (line, "UserAdminOptions") == 0)
	    retval->UserAdminOptions = xstrdup (p);
	else if (strcmp (line, "UseNewInfoFmtStrings") == 0)
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	    readBool (infopath, "UseNewInfoFmtStrings", p,
		      &retval->UseNewInfoFmtStrings);
#else /* !SUPPORT_OLD_INFO_FMT_STRINGS */
	{
	    bool dummy;
	    if (readBool (infopath, "UseNewInfoFmtStrings", p, &dummy)
		&& !dummy)
		error (1, 0,
"%s: Old style info format strings not supported by this executable.",
		       infopath);
	}
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	else if (strcmp (line, "ImportNewFilesToVendorBranchOnly") == 0)
	    readBool (infopath, "ImportNewFilesToVendorBranchOnly", p,
		      &retval->ImportNewFilesToVendorBranchOnly);
#ifdef PROXY_SUPPORT
	else if (strcmp (line, "PrimaryServer") == 0)
	{
	    retval->PrimaryServer = parse_cvsroot (p);
	    if (retval->PrimaryServer->method != fork_method
		&& retval->PrimaryServer->method != ext_method)
d430 2
a431 6
		/* I intentionally neglect to mention :fork: here.  It is
	         * really only useful for testing.
		 */
	        error (1, 0,
"%s: Only PrimaryServers with :ext: methods are valid, not `%s'.",
		       infopath, p);
a433 10
	else if (!strcmp (line, "MaxProxyBufferSize"))
	    readSizeT (infopath, "MaxProxyBufferSize", p,
		       &retval->MaxProxyBufferSize);
#endif /* PROXY_SUPPORT */
	else if (!strcmp (line, "MaxCommentLeaderLength"))
	    readSizeT (infopath, "MaxCommentLeaderLength", p,
		       &retval->MaxCommentLeaderLength);
	else if (!strcmp (line, "UseArchiveCommentLeader"))
	    readBool (infopath, "UseArchiveCommentLeader", p,
		      &retval->UseArchiveCommentLeader);
d435 1
d449 2
d453 1
d455 2
d458 1
d460 2
d465 8
a472 1
    return retval;
@


1.1.2.2
log
@GNU CVS 1.12.11
@
text
@d211 32
@


1.1.3.1
log
@our CVS is currently at 1.11.1p1, thus import that version into vendor branch
@
text
@d338 47
@


1.1.3.2
log
@CVS 1.11.12 is the latest stable version of CVS,
released 06.02.2004, with a huge lot of bug fixes.

/me hopes this will pay off...
@
text
@d35 1
a35 2
    int default_line = 0;
    char *expanded_value;
d37 1
a37 1
    char *cp, *exp, *value, *srepos;
d68 1
a68 6
	(void) fprintf (stderr, "%s-> Parse_Info (%s, %s, %s)\n",
#ifdef SERVER_SUPPORT
			server_active ? "S" : " ",
#else
			"",
#endif
d112 4
d126 3
a128 4
	    if (default_value != NULL)
	    {
		error (0, 0, "Multiple `DEFAULT' lines (%d and %d) in %s file",
		       default_line, line_number, infofile);
d130 2
a131 3
	    }
	    default_value = xstrdup(value);
	    default_line = line_number;
d145 1
a145 2
	    else if ((expanded_value = expand_path (value, infofile, line_number)) != NULL)
	    {
a146 2
		free (expanded_value);
	    }
d167 1
a167 2
	if ((expanded_value = expand_path (value, infofile, line_number)) != NULL)
	{
a168 2
	    free (expanded_value);
	}
d181 2
a182 5
	if ((expanded_value = expand_path (default_value, infofile, default_line)) != NULL)
	{
	    err += callproc (repository, expanded_value);
	    free (expanded_value);
	}
d188 1
a188 1
    if (default_value != NULL)
d190 2
d232 1
a232 1
    infopath = xmalloc (strlen (cvsroot)
d383 1
a383 1
		logHistory=xmalloc(strlen (p) + 1);
a385 9
	}
	else if (strcmp (line, "RereadLogAfterVerify") == 0)
	{
	    if (strcmp (p, "no") == 0 || strcmp (p, "never") == 0)
	      RereadLogAfterVerify = LOGMSG_REREAD_NEVER;
	    else if (strcmp (p, "yes") == 0 || strcmp (p, "always") == 0)
	      RereadLogAfterVerify = LOGMSG_REREAD_ALWAYS;
	    else if (strcmp (p, "stat") == 0)
	      RereadLogAfterVerify = LOGMSG_REREAD_STAT;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
