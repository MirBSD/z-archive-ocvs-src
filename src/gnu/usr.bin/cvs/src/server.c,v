head	1.6;
access;
symbols
	cvs-1_12_11:1.1.2.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.4
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.2
	MIROS_X_BASE:1.5
	cvs-1_12_10:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_MIRPPC:1.1.1.3.0.4
	MIRBSD_XP_SPARC_BASE:1.1.1.3
	MIRBSD_XP_SPARC:1.1.1.3.0.2
	cvs-200406091940:1.1.1.3
	MIRBSD_7quater:1.4
	cvs-200405160640:1.1.1.2
	cvs-200404170130:1.1.1.2
	cvs-1_11_12:1.1.3.2
	cvs-1_11_1p1:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.4.0.2
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.08.21.31.32;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.02.12.40.29;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.19.16.36.48;	author tg;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2004.02.22.13.49.19;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.12.21.16.24;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.32;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.41.32;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.01.02.17.17.58;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.06.09.20.33.07;	author tg;	state Stab;
branches;
next	;

1.1.2.1
date	2004.12.02.11.59.14;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.01.08.21.14.05;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.02.12.19.20.15;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.12.19.40.24;	author tg;	state Exp;
branches;
next	;

1.4.2.1
date	2004.06.20.17.39.31;	author bsiegert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@fastmerge
@
text
@/* This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

#include "cvs.h"
#include "watch.h"
#include "edit.h"
#include "fileattr.h"
#include "getline.h"
#include "getnline.h"
#include "buffer.h"

#if defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT)

#include "log-buffer.h"
#include "ms-buffer.h"

#if defined(PROXY_SUPPORT) || defined(HAVE_GSSAPI)
#  include <netdb.h>
#endif /* defined(PROXY_SUPPORT) || defined(HAVE_GSSAPI) */

# ifdef HAVE_GSSAPI
#   include "gssapi-client.h"

/* This stuff isn't included solely with SERVER_SUPPORT since some of these
 * functions (encryption & the like) get compiled with or without server
 * support.
 *
 * FIXME - They should be in a different file.
 */
/* We use Kerberos 5 routines to map the GSSAPI credential to a user
   name.  */
#   include <krb5.h>

static void gserver_authenticate_connection (void);

/* Whether we are already wrapping GSSAPI communication.  */
static int cvs_gssapi_wrapping;

# endif	/* HAVE_GSSAPI */
#endif	/* defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT) */

#ifdef SERVER_SUPPORT

extern char *server_hostname;

# ifdef HAVE_WINSOCK_H
#   include <winsock.h>
# endif

# if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_KERBEROS) || defined (HAVE_GSSAPI)
#   include <sys/socket.h>
# endif

# ifdef HAVE_SYSLOG_H
#   include <syslog.h>
#   ifndef LOG_DAEMON   /* for ancient syslogs */
#     define LOG_DAEMON 0
#   endif
# endif

# ifdef HAVE_KERBEROS
#   include <netinet/in.h>
#   include <krb.h>
#   ifndef HAVE_KRB_GET_ERR_TEXT
#     define krb_get_err_text(status) krb_err_txt[status]
#   endif

/* Information we need if we are going to use Kerberos encryption.  */
static C_Block kblock;
static Key_schedule sched;

# endif

/* for select */
# include "xselect.h"

# ifndef O_NONBLOCK
#   define O_NONBLOCK O_NDELAY
# endif

/* For initgroups().  */
# if HAVE_INITGROUPS
#   include <grp.h>
# endif /* HAVE_INITGROUPS */

# ifdef AUTH_SERVER_SUPPORT

#   ifdef HAVE_GETSPNAM
#     include <shadow.h>
#   endif

/* The cvs username sent by the client, which might or might not be
   the same as the system username the server eventually switches to
   run as.  CVS_Username gets set iff password authentication is
   successful. */
char *CVS_Username = NULL;

/* Used to check that same repos is transmitted in pserver auth and in
   later CVS protocol.  Exported because root.c also uses. */
static char *Pserver_Repos = NULL;

# endif /* AUTH_SERVER_SUPPORT */

# ifdef HAVE_PAM
#   include <security/pam_appl.h>

static pam_handle_t *pamh = NULL;
# endif /* HAVE_PAM */



/* While processing requests, this buffer accumulates data to be sent to
   the client, and then once we are in do_cvs_command, we use it
   for all the data to be sent.  */
static struct buffer *buf_to_net;

/* This buffer is used to read input from the client.  */
static struct buffer *buf_from_net;



# ifdef PROXY_SUPPORT
/* These are the secondary log buffers so that we can disable them after
 * creation, when it is determined that they are unneeded, regardless of what
 * other filters have been prepended to the buffer chain.
 */
static struct buffer *proxy_log;
static struct buffer *proxy_log_out;

/* Set while we are reprocessing a log so that we can avoid sending responses
 * to some requests twice.
 */
static bool reprocessing;
# endif /* PROXY_SUPPORT */



/* Arguments storage for `Argument' & `Argumentx' requests.  */
static int argument_count;
static char **argument_vector;
static int argument_vector_size;

/*
 * This is where we stash stuff we are going to use.  Format string
 * which expects a single directory within it, starting with a slash.
 */
static char *server_temp_dir;

/* This is the original value of server_temp_dir, before any possible
   changes inserted by serve_max_dotdot.  */
static char *orig_server_temp_dir;

/* Nonzero if we should keep the temp directory around after we exit.  */
static int dont_delete_temp;

static void server_write_entries (void);

cvsroot_t *referrer;



/* Populate all of the directories between BASE_DIR and its relative
   subdirectory DIR with CVSADM directories.  Return 0 for success or
   errno value.  */
static int
create_adm_p (char *base_dir, char *dir)
{
    char *dir_where_cvsadm_lives, *dir_to_register, *p, *tmp;
    int retval, done;
    FILE *f;

    if (strcmp (dir, ".") == 0)
	return 0;			/* nothing to do */

    /* Allocate some space for our directory-munging string. */
    p = xmalloc (strlen (dir) + 1);
    if (p == NULL)
	return ENOMEM;

    dir_where_cvsadm_lives = xmalloc (strlen (base_dir) + strlen (dir) + 100);
    if (dir_where_cvsadm_lives == NULL)
	return ENOMEM;

    /* Allocate some space for the temporary string in which we will
       construct filenames. */
    tmp = xmalloc (strlen (base_dir) + strlen (dir) + 100);
    if (tmp == NULL)
	return ENOMEM;


    /* We make several passes through this loop.  On the first pass,
       we simply create the CVSADM directory in the deepest directory.
       For each subsequent pass, we try to remove the last path
       element from DIR, create the CVSADM directory in the remaining
       pathname, and register the subdirectory in the newly created
       CVSADM directory. */

    retval = done = 0;

    strcpy (p, dir);
    strcpy (dir_where_cvsadm_lives, base_dir);
    strcat (dir_where_cvsadm_lives, "/");
    strcat (dir_where_cvsadm_lives, p);
    dir_to_register = NULL;

    while (1)
    {
	/* Create CVSADM. */
	(void) sprintf (tmp, "%s/%s", dir_where_cvsadm_lives, CVSADM);
	if ((CVS_MKDIR (tmp, 0777) < 0) && (errno != EEXIST))
	{
	    retval = errno;
	    goto finish;
	}

	/* Create CVSADM_REP. */
	(void) sprintf (tmp, "%s/%s", dir_where_cvsadm_lives, CVSADM_REP);
	if (! isfile (tmp))
	{
	    /* Use Emptydir as the placeholder until the client sends
	       us the real value.  This code is similar to checkout.c
	       (emptydir_name), but the code below returns errors
	       differently.  */

	    char *empty;
	    empty = xmalloc (strlen (current_parsed_root->directory)
			    + sizeof (CVSROOTADM)
			    + sizeof (CVSNULLREPOS)
			    + 3);
	    if (! empty)
	    {
		retval = ENOMEM;
		goto finish;
	    }

	    /* Create the directory name. */
	    (void) sprintf (empty, "%s/%s/%s", current_parsed_root->directory,
			    CVSROOTADM, CVSNULLREPOS);

	    /* Create the directory if it doesn't exist. */
	    if (! isfile (empty))
	    {
		mode_t omask;
		omask = umask (cvsumask);
		if (CVS_MKDIR (empty, 0777) < 0)
		{
		    retval = errno;
		    free (empty);
		    goto finish;
		}
		(void) umask (omask);
	    }

	    f = CVS_FOPEN (tmp, "w");
	    if (f == NULL)
	    {
		retval = errno;
		free (empty);
		goto finish;
	    }
	    /* Write the directory name to CVSADM_REP. */
	    if (fprintf (f, "%s\n", empty) < 0)
	    {
		retval = errno;
		fclose (f);
		free (empty);
		goto finish;
	    }
	    if (fclose (f) == EOF)
	    {
		retval = errno;
		free (empty);
		goto finish;
	    }

	    /* Clean up after ourselves. */
	    free (empty);
	}

	/* Create CVSADM_ENT.  We open in append mode because we
	   don't want to clobber an existing Entries file.  */
	(void) sprintf (tmp, "%s/%s", dir_where_cvsadm_lives, CVSADM_ENT);
	f = CVS_FOPEN (tmp, "a");
	if (f == NULL)
	{
	    retval = errno;
	    goto finish;
	}
	if (fclose (f) == EOF)
	{
	    retval = errno;
	    goto finish;
	}

	if (dir_to_register != NULL)
	{
	    /* FIXME: Yes, this results in duplicate entries in the
	       Entries.Log file, but it doesn't currently matter.  We
	       might need to change this later on to make sure that we
	       only write one entry.  */

	    Subdir_Register ((List *) NULL, dir_where_cvsadm_lives,
			     dir_to_register);
	}

	if (done)
	    break;

	dir_to_register = strrchr (p, '/');
	if (dir_to_register == NULL)
	{
	    dir_to_register = p;
	    strcpy (dir_where_cvsadm_lives, base_dir);
	    done = 1;
	}
	else
	{
	    *dir_to_register = '\0';
	    dir_to_register++;
	    strcpy (dir_where_cvsadm_lives, base_dir);
	    strcat (dir_where_cvsadm_lives, "/");
	    strcat (dir_where_cvsadm_lives, p);
	}
    }

  finish:
    free (tmp);
    free (dir_where_cvsadm_lives);
    free (p);
    return retval;
}

/*
 * Make directory DIR, including all intermediate directories if necessary.
 * Returns 0 for success or errno code.
 */
static int mkdir_p (char *);

static int
mkdir_p (char *dir)
{
    char *p;
    char *q = xmalloc (strlen (dir) + 1);
    int retval;

    if (q == NULL)
	return ENOMEM;

    retval = 0;

    /*
     * Skip over leading slash if present.  We won't bother to try to
     * make '/'.
     */
    p = dir + 1;
    while (1)
    {
	while (*p != '/' && *p != '\0')
	    ++p;
	if (*p == '/')
	{
	    strncpy (q, dir, p - dir);
	    q[p - dir] = '\0';
	    if (q[p - dir - 1] != '/'  &&  CVS_MKDIR (q, 0777) < 0)
	    {
		int saved_errno = errno;

		if (saved_errno != EEXIST
		    && ((saved_errno != EACCES && saved_errno != EROFS)
			|| !isdir (q)))
		{
		    retval = saved_errno;
		    goto done;
		}
	    }
	    ++p;
	}
	else
	{
	    if (CVS_MKDIR (dir, 0777) < 0)
		retval = errno;
	    goto done;
	}
    }
  done:
    free (q);
    return retval;
}

/*
 * Print the error response for error code STATUS.  The caller is
 * reponsible for making sure we get back to the command loop without
 * any further output occuring.
 * Must be called only in contexts where it is OK to send output.
 */
static void
print_error (int status)
{
    char *msg;
    char tmpstr[80];

    buf_output0 (buf_to_net, "error  ");
    msg = strerror (status);
    if (msg == NULL)
    {
       sprintf (tmpstr, "unknown error %d", status);
       msg = tmpstr;
    }
    buf_output0 (buf_to_net, msg);
    buf_append_char (buf_to_net, '\n');

    buf_flush (buf_to_net, 0);
}

static int pending_error;
/*
 * Malloc'd text for pending error.  Each line must start with "E ".  The
 * last line should not end with a newline.
 */
static char *pending_error_text;

/* If an error is pending, print it and return 1.  If not, return 0.
   Must be called only in contexts where it is OK to send output.  */
static int
print_pending_error (void)
{
    if (pending_error_text)
    {
	buf_output0 (buf_to_net, pending_error_text);
	buf_append_char (buf_to_net, '\n');
	if (pending_error)
	    print_error (pending_error);
	else
	    buf_output0 (buf_to_net, "error  \n");

	buf_flush (buf_to_net, 0);

	pending_error = 0;
	free (pending_error_text);
	pending_error_text = NULL;
	return 1;
    }
    else if (pending_error)
    {
	print_error (pending_error);
	pending_error = 0;
	return 1;
    }
    else
	return 0;
}

/* Is an error pending?  */
#define error_pending() (pending_error || pending_error_text)

static int alloc_pending (size_t size);

/* Allocate SIZE bytes for pending_error_text and return nonzero
   if we could do it.  */
static int
alloc_pending (size_t size)
{
    if (error_pending ())
	/* Probably alloc_pending callers will have already checked for
	   this case.  But we might as well handle it if they don't, I
	   guess.  */
	return 0;
    pending_error_text = xmalloc (size);
    if (pending_error_text == NULL)
    {
	pending_error = ENOMEM;
	return 0;
    }
    return 1;
}



static int
supported_response (char *name)
{
    struct response *rs;

    for (rs = responses; rs->name != NULL; ++rs)
	if (strcmp (rs->name, name) == 0)
	    return rs->status == rs_supported;
    error (1, 0, "internal error: testing support for unknown response?");
    /* NOTREACHED */
    return 0;
}



/* Return true if two paths match, resolving symlinks.
 */
static inline bool
isSamePath (const char *path1_in, const char *path2_in)
{
    char *p1, *p2;
    bool same;

    if (!strcmp (config->PrimaryServer->directory,
		 current_parsed_root->directory))
	return true;

    /* Path didn't match, but try to resolve any links that may be
     * present.
     */
    if (!isdir (path1_in) || !isdir (path2_in))
	/* To be resolvable, paths must exist on this server.  */
	return false;

    p1 = xresolvepath (path1_in);
    p2 = xresolvepath (path2_in);
    if (strcmp (p1, p2))
	same = false;
    else
	same = true;

    free (p1);
    free (p2);
    return same;
}



/* Return true if OTHERHOST resolves to this host in the DNS.
 *
 * GLOBALS
 *   server_hostname	The name of this host, as determined by the call to
 *			xgethostname() in main().
 *
 * RETURNS
 *   true	If OTHERHOST equals or resolves to HOSTNAME.
 *   false	Otherwise.
 */
static inline bool
isThisHost (const char *otherhost)
{
    struct hostent *hinfo;

    /* As an optimization, check the literal strings before looking up
     * OTHERHOST in the DNS.
     */
    if (!strcasecmp (server_hostname, otherhost))
	return true;

    if (!(hinfo = gethostbyname (otherhost)))
#ifdef HAVE_HSTRERROR
	error (1, 0, "Name lookup failed for `%s': %s",
	       otherhost, hstrerror (h_errno));
#else
	error (1, 0, "Name lookup failed for `%s': h_error=%d",
	       otherhost, h_errno);
#endif

    return !strcasecmp (server_hostname, hinfo->h_name);
}



/*
 * Return true if we need to relay write requests to a primary server
 * and false otherwise.
 *
 * NOTES
 *
 *   - primarily handles :ext: method as this seems most likely to be used in
 *     practice.
 *
 *   - :fork: method is handled for testing.
 *
 *   - Could handle pserver too, but would have to store the password
 *     the client sent us.
 *
 *
 * GLOBALS
 *   config->PrimaryServer
 *                        The parsed setting from CVSROOT/config, if any, or
 *                        NULL, otherwise.
 *   current_parsed_root  The current repository.
 *
 * RETURNS
 *   true                 If this server is configured as a secondary server.
 *   false                Otherwise.
 */
static inline bool
isProxyServer (void)
{
    assert (current_parsed_root);

    /***
     *** The following is done as a series of if/return combinations an an
     *** optimization.
     ***/

    /* If there is no primary server defined in CVSROOT/config, then we can't
     * be a secondary.
     */
    if (!config || !config->PrimaryServer) return false;

    /* The directory must not match for all methods.  */
    if (!isSamePath (config->PrimaryServer->directory,
		     current_parsed_root->directory))
	return true;

    /* Only the directory is important for fork.  */
    if (config->PrimaryServer->method == fork_method)
	return false;

    /* Must be :ext: method, then.  This is enforced when CVSROOT/config is
     * parsed.
     */
    assert (config->PrimaryServer->method == ext_method);

    if (isThisHost (config->PrimaryServer->hostname))
	return false;

    return true;
}



static void
serve_valid_responses (char *arg)
{
    char *p = arg;
    char *q;
    struct response *rs;

#ifdef PROXY_SUPPORT
    /* Process this in the first pass since the data it gathers can be used
     * prior to a `Root' request.
     */
    if (reprocessing) return;
#endif /* PROXY_SUPPORT */

    do
    {
	q = strchr (p, ' ');
	if (q != NULL)
	    *q++ = '\0';
	for (rs = responses; rs->name != NULL; ++rs)
	{
	    if (strcmp (rs->name, p) == 0)
		break;
	}
	if (rs->name == NULL)
	    /*
	     * It is a response we have never heard of (and thus never
	     * will want to use).  So don't worry about it.
	     */
	    ;
	else
	    rs->status = rs_supported;
	p = q;
    } while (q != NULL);
    for (rs = responses; rs->name != NULL; ++rs)
    {
	if (rs->status == rs_essential)
	{
	    buf_output0 (buf_to_net, "E response `");
	    buf_output0 (buf_to_net, rs->name);
	    buf_output0 (buf_to_net, "' not supported by client\nerror  \n");

	    /* FIXME: This call to buf_flush could conceivably
	       cause deadlock, as noted in server_cleanup.  */
	    buf_flush (buf_to_net, 1);

	    exit (EXIT_FAILURE);
	}
	else if (rs->status == rs_optional)
	    rs->status = rs_not_supported;
    }
}



/*
 * Process IDs of the subprocess, or negative if that subprocess
 * does not exist.
 */
static pid_t command_pid;

static void
outbuf_memory_error (struct buffer *buf)
{
    static const char msg[] = "E Fatal server error\n\
error ENOMEM Virtual memory exhausted.\n";
    if (command_pid > 0)
	kill (command_pid, SIGTERM);

    /*
     * We have arranged things so that printing this now either will
     * be valid, or the "E fatal error" line will get glommed onto the
     * end of an existing "E" or "M" response.
     */

    /* If this gives an error, not much we could do.  syslog() it?  */
    write (STDOUT_FILENO, msg, sizeof (msg) - 1);
#ifdef HAVE_SYSLOG_H
    syslog (LOG_DAEMON | LOG_ERR, "virtual memory exhausted");
#endif
    exit (EXIT_FAILURE);
}



static void
input_memory_error (struct buffer *buf)
{
    outbuf_memory_error (buf);
}



#ifdef PROXY_SUPPORT
/* This function rewinds the net connection using the write proxy log file.
 *
 * GLOBALS
 *   proxy_log	The buffer object containing the write proxy log.
 *
 * RETURNS
 *   Nothing.
 */
static void
rewind_buf_from_net (void)
{
    struct buffer *log;

    assert (proxy_log);

    /* Free the arguments since we processed some of them in the first pass.
     */
    {
	/* argument_vector[0] is a dummy argument, we don't mess with
	 * it.
	 */
	char **cp;
	for (cp = argument_vector + 1;
	     cp < argument_vector + argument_count;
	     ++cp)
	    free (*cp);

	argument_count = 1;
    }

    log = log_buffer_rewind (proxy_log);
    proxy_log = NULL;
    /* Dispose of any read but unused data in the net buffer since it will
     * already be in the log.
     */
    buf_free_data (buf_from_net);
    buf_from_net = ms_buffer_initialize (outbuf_memory_error, log,
					 buf_from_net);
    reprocessing = true;
}
#endif /* PROXY_SUPPORT */



/*
 * This request cannot be ignored by a potential secondary since it is used to
 * determine if we _are_ a secondary.
 */
static void
serve_root (char *arg)
{
    char *env;
    char *path;

    TRACE (TRACE_FUNCTION, "serve_root (%s)", arg ? arg : "(null)");

    /* Don't process this twice or when errors are pending.  */
    if (error_pending()
#ifdef PROXY_SUPPORT
	|| reprocessing
#endif /* PROXY_SUPPORT */
       ) return;

    if (!isabsolute (arg))
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E Root %s must be an absolute pathname", arg);
	return;
    }

    /* Sending "Root" twice is invalid.

       The other way to handle a duplicate Root requests would be as a
       request to clear out all state and start over as if it was a
       new connection.  Doing this would cause interoperability
       headaches, so it should be a different request, if there is
       any reason why such a feature is needed.  */
    if (current_parsed_root != NULL)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E Protocol error: Duplicate Root request, for %s", arg);
	return;
    }

    /* Set original_parsed_root here, not because it can be changed in the
     * client Redirect sense, but so we don't have to switch in code that
     * runs in both modes to decide which to print.
     */
    original_parsed_root = current_parsed_root = local_cvsroot (arg);

#ifdef AUTH_SERVER_SUPPORT
    if (Pserver_Repos != NULL)
    {
	if (strcmp (Pserver_Repos, current_parsed_root->directory) != 0)
	{
	    if (alloc_pending (80 + strlen (Pserver_Repos)
			       + strlen (current_parsed_root->directory)))
		/* The explicitness is to aid people who are writing clients.
		   I don't see how this information could help an
		   attacker.  */
		sprintf (pending_error_text, "\
E Protocol error: Root says \"%s\" but pserver says \"%s\"",
			 current_parsed_root->directory, Pserver_Repos);
	    return;
	}
    }
#endif

    /* For pserver, this will already have happened, and the call will do
       nothing.  But for rsh, we need to do it now.  */
    config = get_root_allow_config (current_parsed_root->directory);

#ifdef PROXY_SUPPORT
    /* At this point we have enough information to determine if we are a
     * secondary server or not.
     */
    if (proxy_log && !isProxyServer ())
    {
	/* Else we are not a secondary server.  There is no point in
	 * reprocessing since we handle all the requests we can receive
	 * before `Root' as we receive them.  But close the logs.
	 */
	log_buffer_closelog (proxy_log);
	log_buffer_closelog (proxy_log_out);
	proxy_log = NULL;
	/*
	 * Don't need this.  We assume it when proxy_log == NULL.
	 *
	 *   proxy_log_out = NULL;
	 */
    }
#endif /* PROXY_SUPPORT */


    path = xmalloc (strlen (current_parsed_root->directory)
		   + sizeof (CVSROOTADM)
		   + 2);
    if (path == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    (void) sprintf (path, "%s/%s", current_parsed_root->directory, CVSROOTADM);
    if (!isaccessible (path, R_OK | X_OK))
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (path)))
	    sprintf (pending_error_text, "E Cannot access %s", path);
	pending_error = save_errno;
    }
    free (path);

#ifdef HAVE_PUTENV
    env = xmalloc (strlen (CVSROOT_ENV) + strlen (current_parsed_root->directory) + 2);
    if (env == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    (void) sprintf (env, "%s=%s", CVSROOT_ENV, current_parsed_root->directory);
    (void) putenv (env);
    /* do not free env, as putenv has control of it */
#endif
}



static int max_dotdot_limit = 0;

/* Is this pathname OK to recurse into when we are running as the server?
   If not, call error() with a fatal error.  */
void
server_pathname_check (char *path)
{
    TRACE (TRACE_FUNCTION, "server_pathname_check (%s)",
	   path ? path : "(null)");

    /* An absolute pathname is almost surely a path on the *client* machine,
       and is unlikely to do us any good here.  It also is probably capable
       of being a security hole in the anonymous readonly case.  */
    if (isabsolute (path))
	/* Giving an error is actually kind of a cop-out, in the sense
	   that it would be nice for "cvs co -d /foo/bar/baz" to work.
	   A quick fix in the server would be requiring Max-dotdot of
	   at least one if pathnames are absolute, and then putting
	   /abs/foo/bar/baz in the temp dir beside the /d/d/d stuff.
	   A cleaner fix in the server might be to decouple the
	   pathnames we pass back to the client from pathnames in our
	   temp directory (this would also probably remove the need
	   for Max-dotdot).  A fix in the client would have the client
	   turn it into "cd /foo/bar; cvs co -d baz" (more or less).
	   This probably has some problems with pathnames which appear
	   in messages.  */
	error ( 1, 0,
		"absolute pathnames invalid for server (specified `%s')",
		path );
    if (pathname_levels (path) > max_dotdot_limit)
    {
	/* Similar to the isabsolute case in security implications.  */
	error (0, 0, "protocol error: `%s' contains more leading ..", path);
	error (1, 0, "than the %d which Max-dotdot specified",
	       max_dotdot_limit);
    }
}

static int outside_root (char *);

/* Is file or directory REPOS an absolute pathname within the
   current_parsed_root->directory?  If yes, return 0.  If no, set pending_error
   and return 1.  */
static int
outside_root (char *repos)
{
    size_t repos_len = strlen (repos);
    size_t root_len = strlen (current_parsed_root->directory);

    /* isabsolute (repos) should always be true, but
       this is a good security precaution regardless. -DRP
     */
    if (!isabsolute (repos))
    {
	if (alloc_pending (repos_len + 80))
	    sprintf (pending_error_text, "\
E protocol error: %s is not absolute", repos);
	return 1;
    }

    if (repos_len < root_len
	|| strncmp (current_parsed_root->directory, repos, root_len) != 0)
    {
    not_within:
	if (alloc_pending (strlen (current_parsed_root->directory)
			   + strlen (repos)
			   + 80))
	    sprintf (pending_error_text, "\
E protocol error: directory '%s' not within root '%s'",
		     repos, current_parsed_root->directory);
	return 1;
    }
    if (repos_len > root_len)
    {
	if (repos[root_len] != '/')
	    goto not_within;
	if (pathname_levels (repos + root_len + 1) > 0)
	    goto not_within;
    }
    return 0;
}

static int outside_dir (char *);

/* Is file or directory FILE outside the current directory (that is, does
   it contain '/')?  If no, return 0.  If yes, set pending_error
   and return 1.  */
static int
outside_dir (char *file)
{
    if (strchr (file, '/') != NULL)
    {
	if (alloc_pending (strlen (file)
			   + 80))
	    sprintf (pending_error_text, "\
E protocol error: directory '%s' not within current directory",
		     file);
	return 1;
    }
    return 0;
}



/*
 * Add as many directories to the temp directory as the client tells us it
 * will use "..", so we never try to access something outside the temp
 * directory via "..".
 */
static void
serve_max_dotdot (char *arg)
{
    int lim = atoi (arg);
    int i;
    char *p;

#ifdef PROXY_SUPPORT
    if (proxy_log) return;
#endif /* PROXY_SUPPORT */

    if (lim < 0 || lim > 10000)
	return;
    p = xmalloc (strlen (server_temp_dir) + 2 * lim + 10);
    if (p == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (p, server_temp_dir);
    for (i = 0; i < lim; ++i)
	strcat (p, "/d");
    if (server_temp_dir != orig_server_temp_dir)
	free (server_temp_dir);
    server_temp_dir = p;
    max_dotdot_limit = lim;
}



static char *gDirname;
static char *gupdate_dir;

static void
dirswitch (char *dir, char *repos)
{
    int status;
    FILE *f;
    size_t dir_len;

    TRACE (TRACE_FUNCTION, "dirswitch (%s, %s)", dir ? dir : "(null)",
	   repos ? repos : "(null)");

    server_write_entries ();

    if (error_pending()) return;

    /* Check for bad directory name.

       FIXME: could/should unify these checks with server_pathname_check
       except they need to report errors differently.  */
    if (isabsolute (dir))
    {
	if (alloc_pending (80 + strlen (dir)))
	    sprintf ( pending_error_text,
		      "E absolute pathnames invalid for server (specified `%s')",
		      dir);
	return;
    }
    if (pathname_levels (dir) > max_dotdot_limit)
    {
	if (alloc_pending (80 + strlen (dir)))
	    sprintf (pending_error_text,
		     "E protocol error: `%s' has too many ..", dir);
	return;
    }

    dir_len = strlen (dir);

    /* Check for a trailing '/'.  This is not ISSLASH because \ in the
       protocol is an ordinary character, not a directory separator (of
       course, it is perhaps unwise to use it in directory names, but that
       is another issue).  */
    if (dir_len > 0
	&& dir[dir_len - 1] == '/')
    {
	if (alloc_pending (80 + dir_len))
	    sprintf (pending_error_text,
		     "E protocol error: invalid directory syntax in %s", dir);
	return;
    }

    if (gDirname != NULL)
	free (gDirname);
    if (gupdate_dir != NULL)
	free (gupdate_dir);

    if (!strcmp (dir, "."))
	gupdate_dir = xstrdup ("");
    else
	gupdate_dir = xstrdup (dir);

    gDirname = xmalloc (strlen (server_temp_dir) + dir_len + 40);
    if (gDirname == NULL)
    {
	pending_error = ENOMEM;
	return;
    }

    strcpy (gDirname, server_temp_dir);
    strcat (gDirname, "/");
    strcat (gDirname, dir);

    status = mkdir_p (gDirname);
    if (status != 0
	&& status != EEXIST)
    {
	if (alloc_pending (80 + strlen (gDirname)))
	    sprintf (pending_error_text, "E cannot mkdir %s", gDirname);
	pending_error = status;
	return;
    }

    /* We need to create adm directories in all path elements because
       we want the server to descend them, even if the client hasn't
       sent the appropriate "Argument xxx" command to match the
       already-sent "Directory xxx" command.  See recurse.c
       (start_recursion) for a big discussion of this.  */

    status = create_adm_p (server_temp_dir, dir);
    if (status != 0)
    {
	if (alloc_pending (80 + strlen (gDirname)))
	    sprintf (pending_error_text, "E cannot create_adm_p %s", gDirname);
	pending_error = status;
	return;
    }

    if ( CVS_CHDIR (gDirname) < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (gDirname)))
	    sprintf (pending_error_text, "E cannot change to %s", gDirname);
	pending_error = save_errno;
	return;
    }
    /*
     * This is pretty much like calling Create_Admin, but Create_Admin doesn't
     * report errors in the right way for us.
     */
    if ((CVS_MKDIR (CVSADM, 0777) < 0) && (errno != EEXIST))
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM)))
	    sprintf (pending_error_text,
		     "E cannot mkdir %s/%s", gDirname, CVSADM);
	pending_error = save_errno;
	return;
    }

    /* The following will overwrite the contents of CVSADM_REP.  This
       is the correct behavior -- mkdir_p may have written a
       placeholder value to this file and we need to insert the
       correct value. */

    f = CVS_FOPEN (CVSADM_REP, "w");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E cannot open %s/%s", gDirname, CVSADM_REP);
	pending_error = save_errno;
	return;
    }
    if (fprintf (f, "%s", repos) < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E error writing %s/%s", gDirname, CVSADM_REP);
	pending_error = save_errno;
	fclose (f);
	return;
    }
    /* Non-remote CVS handles a module representing the entire tree
       (e.g., an entry like ``world -a .'') by putting /. at the end
       of the Repository file, so we do the same.  */
    if (strcmp (dir, ".") == 0
	&& current_parsed_root != NULL
	&& current_parsed_root->directory != NULL
	&& strcmp (current_parsed_root->directory, repos) == 0)
    {
	if (fprintf (f, "/.") < 0)
	{
	    int save_errno = errno;
	    if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM_REP)))
		sprintf (pending_error_text,
			 "E error writing %s/%s", gDirname, CVSADM_REP);
	    pending_error = save_errno;
	    fclose (f);
	    return;
	}
    }
    if (fprintf (f, "\n") < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E error writing %s/%s", gDirname, CVSADM_REP);
	pending_error = save_errno;
	fclose (f);
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E error closing %s/%s", gDirname, CVSADM_REP);
	pending_error = save_errno;
	return;
    }
    /* We open in append mode because we don't want to clobber an
       existing Entries file.  */
    f = CVS_FOPEN (CVSADM_ENT, "a");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_ENT)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_ENT);
	pending_error = save_errno;
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_ENT)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_ENT);
	pending_error = save_errno;
	return;
    }
}



static void
serve_repository (char *arg)
{
#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */

    if (alloc_pending (80))
	strcpy (pending_error_text,
		"E Repository request is obsolete; aborted");
    return;
}



static void
serve_directory (char *arg)
{
    int status;
    char *repos;

    TRACE (TRACE_FUNCTION, "serve_directory (%s)", arg ? arg : "(null)");


    /* The data needs to be read into the secondary log regardless, but
     * processing of anything other than errors is skipped until later.
     */
    status = buf_read_line (buf_from_net, &repos, NULL);
    if (status == 0)
    {
	if (!isabsolute (repos))
	{
	    /* Make absolute.
	     *
	     * FIXME: This is kinda hacky - we should probably only ever store
	     * and pass SHORT_REPOS (perhaps with the occassional exception
	     * for optimizations, but many, many functions end up
	     * deconstructing REPOS to gain SHORT_REPOS anyhow) - the
	     * CVSROOT portion of REPOS is redundant with
	     * current_parsed_root->directory - but since this is the way
	     * things have always been done, changing this will likely involve
	     * a major overhaul.
	     */
	    char *short_repos;

	    short_repos = repos;
	    repos = Xasprintf ("%s/%s",
	                      current_parsed_root->directory, short_repos);
	    free (short_repos);
	}
	else
	    repos = xstrdup (primary_root_translate (repos));

	if (
#ifdef PROXY_SUPPORT
	    !proxy_log &&
#endif /* PROXY_SUPPORT */
	    !outside_root (repos))
	    dirswitch (arg, repos);
	free (repos);
    }
    else if (status == -2)
    {
	pending_error = ENOMEM;
    }
    else if (status != 0)
    {
	pending_error_text = xmalloc (80 + strlen (arg));
	if (pending_error_text == NULL)
	{
	    pending_error = ENOMEM;
	}
	else if (status == -1)
	{
	    sprintf (pending_error_text,
		     "E end of file reading mode for %s", arg);
	}
	else
	{
	    sprintf (pending_error_text,
		     "E error reading mode for %s", arg);
	    pending_error = status;
	}
    }
}



static void
serve_static_directory (char *arg)
{
    FILE *f;

    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       ) return;

    f = CVS_FOPEN (CVSADM_ENTSTAT, "w+");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_ENTSTAT)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_ENTSTAT);
	pending_error = save_errno;
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_ENTSTAT)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_ENTSTAT);
	pending_error = save_errno;
	return;
    }
}



static void
serve_sticky (char *arg)
{
    FILE *f;

    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       ) return;

    f = CVS_FOPEN (CVSADM_TAG, "w+");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_TAG)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_TAG);
	pending_error = save_errno;
	return;
    }
    if (fprintf (f, "%s\n", arg) < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_TAG)))
	    sprintf (pending_error_text, "E cannot write to %s", CVSADM_TAG);
	pending_error = save_errno;
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_TAG)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_TAG);
	pending_error = save_errno;
	return;
    }
}



/*
 * Read SIZE bytes from buf_from_net, write them to FILE.
 *
 * Currently this isn't really used for receiving parts of a file --
 * the file is still sent over in one chunk.  But if/when we get
 * spiffy in-process gzip support working, perhaps the compressed
 * pieces could be sent over as they're ready, if the network is fast
 * enough.  Or something.
 */
static void
receive_partial_file (size_t size, int file)
{
    while (size > 0)
    {
	int status;
	size_t nread;
	char *data;

	status = buf_read_data (buf_from_net, size, &data, &nread);
	if (status != 0)
	{
	    if (status == -2)
		pending_error = ENOMEM;
	    else
	    {
		pending_error_text = xmalloc (80);
		if (pending_error_text == NULL)
		    pending_error = ENOMEM;
		else if (status == -1)
		{
		    sprintf (pending_error_text,
			     "E premature end of file from client");
		    pending_error = 0;
		}
		else
		{
		    sprintf (pending_error_text,
			     "E error reading from client");
		    pending_error = status;
		}
	    }
	    return;
	}

	size -= nread;

	while (nread > 0)
	{
	    size_t nwrote;

	    nwrote = write (file, data, nread);
	    if (nwrote < 0)
	    {
		int save_errno = errno;
		if (alloc_pending (40))
		    strcpy (pending_error_text, "E unable to write");
		pending_error = save_errno;

		/* Read and discard the file data.  */
		while (size > 0)
		{
		    int status;
		    size_t nread;
		    char *data;

		    status = buf_read_data (buf_from_net, size, &data, &nread);
		    if (status != 0)
			return;
		    size -= nread;
		}

		return;
	    }
	    nread -= nwrote;
	    data += nwrote;
	}
    }
}

/* Receive SIZE bytes, write to filename FILE.  */
static void
receive_file (size_t size, char *file, int gzipped)
{
    int fd;
    char *arg = file;

    /* Write the file.  */
    fd = CVS_OPEN (arg, O_WRONLY | O_CREAT | O_TRUNC, 0600);
    if (fd < 0)
    {
	int save_errno = errno;
	if (alloc_pending (40 + strlen (arg)))
	    sprintf (pending_error_text, "E cannot open %s", arg);
	pending_error = save_errno;
	return;
    }

    if (gzipped)
    {
	/* Using gunzip_and_write isn't really a high-performance
	   approach, because it keeps the whole thing in memory
	   (contiguous memory, worse yet).  But it seems easier to
	   code than the alternative (and less vulnerable to subtle
	   bugs).  Given that this feature is mainly for
	   compatibility, that is the better tradeoff.  */

	size_t toread = size;
	char *filebuf;
	char *p;

	filebuf = xmalloc (size);
	p = filebuf;
	/* If NULL, we still want to read the data and discard it.  */

	while (toread > 0)
	{
	    int status;
	    size_t nread;
	    char *data;

	    status = buf_read_data (buf_from_net, toread, &data, &nread);
	    if (status != 0)
	    {
		if (status == -2)
		    pending_error = ENOMEM;
		else
		{
		    pending_error_text = xmalloc (80);
		    if (pending_error_text == NULL)
			pending_error = ENOMEM;
		    else if (status == -1)
		    {
			sprintf (pending_error_text,
				 "E premature end of file from client");
			pending_error = 0;
		    }
		    else
		    {
			sprintf (pending_error_text,
				 "E error reading from client");
			pending_error = status;
		    }
		}
		return;
	    }

	    toread -= nread;

	    if (filebuf != NULL)
	    {
		memcpy (p, data, nread);
		p += nread;
	    }
	}
	if (filebuf == NULL)
	{
	    pending_error = ENOMEM;
	    goto out;
	}

	if (gunzip_and_write (fd, file, (unsigned char *) filebuf, size))
	{
	    if (alloc_pending (80))
		sprintf (pending_error_text,
			 "E aborting due to compression error");
	}
	free (filebuf);
    }
    else
	receive_partial_file (size, fd);

    if (pending_error_text)
    {
	char *p = xrealloc (pending_error_text,
			   strlen (pending_error_text) + strlen (arg) + 30);
	if (p)
	{
	    pending_error_text = p;
	    sprintf (p + strlen (p), ", file %s", arg);
	}
	/* else original string is supposed to be unchanged */
    }

 out:
    if (close (fd) < 0 && !error_pending ())
    {
	int save_errno = errno;
	if (alloc_pending (40 + strlen (arg)))
	    sprintf (pending_error_text, "E cannot close %s", arg);
	pending_error = save_errno;
	return;
    }
}



/* Kopt for the next file sent in Modified or Is-modified.  */
static char *kopt;

/* Timestamp (Checkin-time) for next file sent in Modified or
   Is-modified.  */
static int checkin_time_valid;
static time_t checkin_time;



/*
 * Used to keep track of Entry requests.
 */
struct an_entry {
    struct an_entry *next;
    char *entry;
};

static struct an_entry *entries;

static void
serve_is_modified (char *arg)
{
    struct an_entry *p;
    char *name;
    char *cp;
    char *timefield;
    /* Have we found this file in "entries" yet.  */
    int found;

    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       ) return;

    if (outside_dir (arg))
	return;

    /* Rewrite entries file to have `M' in timestamp field.  */
    found = 0;
    for (p = entries; p != NULL; p = p->next)
    {
	name = p->entry + 1;
	cp = strchr (name, '/');
	if (cp != NULL
	    && strlen (arg) == cp - name
	    && strncmp (arg, name, cp - name) == 0)
	{
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
	    {
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
		cp = timefield + strlen (timefield);
		cp[1] = '\0';
		while (cp > timefield)
		{
		    *cp = cp[-1];
		    --cp;
		}
	    }
	    /* If *TIMEFIELD wasn't '/', we assume that it was because of
	     * multiple calls to Is-modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of CVSNT (at least 2.0.34 -
	     * 2.0.41, reported fixed in 2.0.41a) and the WinCVS & TortoiseCVS
	     * clients which depend on those broken versions of CVSNT (WinCVS
	     * 1.3 & at least one TortoiseCVS release) rely on this behavior.
	     */
	    *timefield++ = 'M';
	    if (kopt != NULL)
	    {
		if (alloc_pending (strlen (name) + 80))
		    sprintf (pending_error_text,
			     "E protocol error: both Kopt and Entry for %s",
			     arg);
		free (kopt);
		kopt = NULL;
		return;
	    }
	    found = 1;
	    break;
	}
    }
    if (!found)
    {
	/* We got Is-modified but no Entry.  Add a dummy entry.
	   The "D" timestamp is what makes it a dummy.  */
	p = xmalloc (sizeof (struct an_entry));
	if (p == NULL)
	{
	    pending_error = ENOMEM;
	    return;
	}
	p->entry = xmalloc (strlen (arg) + 80);
	if (p->entry == NULL)
	{
	    pending_error = ENOMEM;
	    free (p);
	    return;
	}
	strcpy (p->entry, "/");
	strcat (p->entry, arg);
	strcat (p->entry, "//D/");
	if (kopt != NULL)
	{
	    strcat (p->entry, kopt);
	    free (kopt);
	    kopt = NULL;
	}
	strcat (p->entry, "/");
	p->next = entries;
	entries = p;
    }
}



static void
serve_modified (char *arg)
{
    size_t size;
    int read_size;
    int status;
    char *size_text;
    char *mode_text;

    int gzipped = 0;

    /*
     * This used to return immediately if error_pending () was true.
     * However, that fails, because it causes each line of the file to
     * be echoed back to the client as an unrecognized command.  The
     * client isn't reading from the socket, so eventually both
     * processes block trying to write to the other.  Now, we try to
     * read the file if we can.
     */

    status = buf_read_line (buf_from_net, &mode_text, NULL);
    if (status != 0)
    {
	if (status == -2)
	    pending_error = ENOMEM;
	else
	{
	    pending_error_text = xmalloc (80 + strlen (arg));
	    if (pending_error_text == NULL)
		pending_error = ENOMEM;
	    else
	    {
		if (status == -1)
		    sprintf (pending_error_text,
			     "E end of file reading mode for %s", arg);
		else
		{
		    sprintf (pending_error_text,
			     "E error reading mode for %s", arg);
		    pending_error = status;
		}
	    }
	}
	return;
    }

    status = buf_read_line (buf_from_net, &size_text, NULL);
    if (status != 0)
    {
	if (status == -2)
	    pending_error = ENOMEM;
	else
	{
	    pending_error_text = xmalloc (80 + strlen (arg));
	    if (pending_error_text == NULL)
		pending_error = ENOMEM;
	    else
	    {
		if (status == -1)
		    sprintf (pending_error_text,
			     "E end of file reading size for %s", arg);
		else
		{
		    sprintf (pending_error_text,
			     "E error reading size for %s", arg);
		    pending_error = status;
		}
	    }
	}
	free (mode_text);
	return;
    }
    if (size_text[0] == 'z')
    {
	gzipped = 1;
	read_size = atoi (size_text + 1);
    }
    else
	read_size = atoi (size_text);
    free (size_text);

    if (read_size < 0 && alloc_pending (80))
    {
	sprintf (pending_error_text,
		 "E client sent invalid (negative) file size");
	return;
    }
    else
	size = read_size;

    if (error_pending ())
    {
	/* Now that we know the size, read and discard the file data.  */
	while (size > 0)
	{
	    int status;
	    size_t nread;
	    char *data;

	    status = buf_read_data (buf_from_net, size, &data, &nread);
	    if (status != 0)
		return;
	    size -= nread;
	}
	free (mode_text);
	return;
    }

    if (
#ifdef PROXY_SUPPORT
	!proxy_log &&
#endif /* PROXY_SUPPORT */
	outside_dir (arg))
    {
	free (mode_text);
	return;
    }

    receive_file (size,
#ifdef PROXY_SUPPORT
	          proxy_log ? DEVNULL :
#endif /* PROXY_SUPPORT */
			      arg,
		  gzipped);
    if (error_pending ())
    {
	free (mode_text);
	return;
    }

#ifdef PROXY_SUPPORT
    /* We've read all the data that needed to be read if we're still logging
     * for a secondary.  Return.
     */
    if (proxy_log) return;
#endif /* PROXY_SUPPORT */

    if (checkin_time_valid)
    {
	struct utimbuf t;

	memset (&t, 0, sizeof (t));
	t.modtime = t.actime = checkin_time;
	if (utime (arg, &t) < 0)
	{
	    int save_errno = errno;
	    if (alloc_pending (80 + strlen (arg)))
		sprintf (pending_error_text, "E cannot utime %s", arg);
	    pending_error = save_errno;
	    free (mode_text);
	    return;
	}
	checkin_time_valid = 0;
    }

    {
	int status = change_mode (arg, mode_text, 0);
	free (mode_text);
	if (status)
	{
	    if (alloc_pending (40 + strlen (arg)))
		sprintf (pending_error_text,
			 "E cannot change mode for %s", arg);
	    pending_error = status;
	    return;
	}
    }

    /* Make sure that the Entries indicate the right kopt.  We probably
       could do this even in the non-kopt case and, I think, save a stat()
       call in time_stamp_server.  But for conservatism I'm leaving the
       non-kopt case alone.  */
    if (kopt != NULL)
	serve_is_modified (arg);
}



static void
serve_enable_unchanged (char *arg)
{
#ifdef PROXY_SUPPORT
    /* Might as well skip this since this function does nothing anyhow.  If
     * it did do anything and could generate errors, then the line below would
     * be necessary since this can be processed before a `Root' request.
     *
     *     if (reprocessing) return;
     */
#endif /* PROXY_SUPPORT */
}



static void
serve_unchanged (char *arg)
{
    struct an_entry *p;
    char *name;
    char *cp;
    char *timefield;

    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       ) return;

    if (outside_dir (arg))
	return;

    /* Rewrite entries file to have `=' in timestamp field.  */
    for (p = entries; p != NULL; p = p->next)
    {
	name = p->entry + 1;
	cp = strchr (name, '/');
	if (cp != NULL
	    && strlen (arg) == cp - name
	    && strncmp (arg, name, cp - name) == 0)
	{
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
	    {
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
		cp = timefield + strlen (timefield);
		cp[1] = '\0';
		while (cp > timefield)
		{
		    *cp = cp[-1];
		    --cp;
		}
	    }
	    else if (timefield[1] != '/')
	    {
		/* Obliterate anything else in TIMEFIELD.  This is again to
		 * support the broken CVSNT clients mentioned below, in
		 * conjunction with strict timestamp string boundry checking in
		 * time_stamp_server() from vers_ts.c & file_has_conflict()
		 * from subr.c, since the broken clients used to send malformed
		 * timestamp fields in the Entry request that they then
		 * depended on the subsequent Unchanged request to overwrite.
		 */
		char *d = timefield + 1;
		if ((cp = strchr (d, '/')))
		{
		    while (*cp)
		    {
			*d++ = *cp++;
		    }
		    *d = '\0';
		}
	    }
	    /* If *TIMEFIELD wasn't '/', we assume that it was because of
	     * multiple calls to Is-modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of CVSNT (at least 2.0.34 -
	     * 2.0.41, reported fixed in 2.0.41a) and the WinCVS & TortoiseCVS
	     * clients which depend on those broken versions of CVSNT (WinCVS
	     * 1.3 & at least one TortoiseCVS release) rely on this behavior.
	     */
	    *timefield = '=';
	    break;
	}
    }
}



static void
serve_entry (char *arg)
{
    struct an_entry *p;
    char *cp;
    int i = 0;

    if (error_pending()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       ) return;

    /* Verify that the entry is well-formed.  This can avoid problems later.
     * At the moment we only check that the Entry contains five slashes in
     * approximately the correct locations since some of the code makes
     * assumptions about this.
     */
    cp = arg;
    if (*cp == 'D') cp++;
    while (i++ < 5)
    {
	if (!cp || *cp != '/')
	{
	    if (alloc_pending (80))
		sprintf (pending_error_text,
			 "E protocol error: Malformed Entry");
	    return;
	}
	cp = strchr (cp + 1, '/');
    }

    p = xmalloc (sizeof (struct an_entry));
    if (p == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    /* Leave space for serve_unchanged to write '=' if it wants.  */
    cp = xmalloc (strlen (arg) + 2);
    if (cp == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (cp, arg);
    p->next = entries;
    p->entry = cp;
    entries = p;
}



static void
serve_kopt (char *arg)
{
    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       )
	return;

    if (kopt != NULL)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E protocol error: duplicate Kopt request: %s", arg);
	return;
    }

    /* Do some sanity checks.  In particular, that it is not too long.
       This lets the rest of the code not worry so much about buffer
       overrun attacks.  Probably should call RCS_check_kflag here,
       but that would mean changing RCS_check_kflag to handle errors
       other than via exit(), fprintf(), and such.  */
    if (strlen (arg) > 10)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E protocol error: invalid Kopt request: %s", arg);
	return;
    }

    kopt = xmalloc (strlen (arg) + 1);
    if (kopt == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (kopt, arg);
}



static void
serve_checkin_time (char *arg)
{
    struct timespec t;

    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       )
	return;

    if (checkin_time_valid)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E protocol error: duplicate Checkin-time request: %s",
		     arg);
	return;
    }

    if (!get_date (&t, arg, NULL))
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text, "E cannot parse date %s", arg);
	return;
    }

    /* Truncate any nanoseconds returned by get_date().  */
    checkin_time = t.tv_sec;
    checkin_time_valid = 1;
}



static void
server_write_entries (void)
{
    FILE *f;
    struct an_entry *p;
    struct an_entry *q;

    if (entries == NULL)
	return;

    f = NULL;
    /* Note that we free all the entries regardless of errors.  */
    if (!error_pending ())
    {
	/* We open in append mode because we don't want to clobber an
	   existing Entries file.  If we are checking out a module
	   which explicitly lists more than one file in a particular
	   directory, then we will wind up calling
	   server_write_entries for each such file.  */
	f = CVS_FOPEN (CVSADM_ENT, "a");
	if (f == NULL)
	{
	    int save_errno = errno;
	    if (alloc_pending (80 + strlen (CVSADM_ENT)))
		sprintf (pending_error_text, "E cannot open %s", CVSADM_ENT);
	    pending_error = save_errno;
	}
    }
    for (p = entries; p != NULL;)
    {
	if (!error_pending ())
	{
	    if (fprintf (f, "%s\n", p->entry) < 0)
	    {
		int save_errno = errno;
		if (alloc_pending (80 + strlen(CVSADM_ENT)))
		    sprintf (pending_error_text,
			     "E cannot write to %s", CVSADM_ENT);
		pending_error = save_errno;
	    }
	}
	free (p->entry);
	q = p->next;
	free (p);
	p = q;
    }
    entries = NULL;
    if (f != NULL && fclose (f) == EOF && !error_pending ())
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_ENT)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_ENT);
	pending_error = save_errno;
    }
}



#ifdef PROXY_SUPPORT
/*
 * callback proc to run a script when admin finishes.
 */
static int
prepost_proxy_proc (const char *repository, const char *filter, void *closure)
{
    char *cmdline;
    bool *pre = closure;

    /* %c = cvs_cmd_name
     * %p = shortrepos
     * %r = repository
     */
    TRACE (TRACE_FUNCTION, "prepost_proxy_proc (%s, %s, %s)", repository,
	   filter, *pre ? "pre" : "post");

    cmdline = format_cmdline (
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	                      0, ".",
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	                      filter,
	                      "c", "s", cvs_cmd_name,
#ifdef SERVER_SUPPORT
	                      "R", "s", referrer ? referrer->original : "NONE",
#endif /* SERVER_SUPPORT */
	                      "p", "s", ".",
	                      "r", "s", current_parsed_root->directory,
	                      "P", "s", config->PrimaryServer->original,
	                      (char *)NULL
	                     );

    if (!cmdline || !strlen (cmdline))
    {
	if (cmdline) free (cmdline);
	if (*pre)
	    error (0, 0, "preadmin proc resolved to the empty string!");
	else
	    error (0, 0, "postadmin proc resolved to the empty string!");
	return 1;
    }

    run_setup (cmdline);

    free (cmdline);

    /* FIXME - read the comment in verifymsg_proc() about why we use abs()
     * below() and shouldn't.
     */
    return abs (run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
			  RUN_NORMAL | RUN_SIGIGNORE));
}



/* Become a secondary write proxy to a master server.
 *
 * This function opens the connection to the primary, dumps the secondary log
 * to the primary, then reads data from any available connection and writes it
 * to its partner:
 *
 *   buf_from_net -> buf_to_primary
 *   buf_from_primary -> buf_to_net
 *
 * When all "from" connections have sent EOF and all data has been sent to
 * "to" connections, this function closes the "to" pipes and returns.
 */
static void
become_proxy (void)
{
    struct buffer *buf_to_primary;
    struct buffer *buf_from_primary;

    /* Close the client log and open it for read.  */
    struct buffer *buf_clientlog = log_buffer_rewind (proxy_log_out);
    int status, to_primary_fd, from_primary_fd, to_net_fd, from_net_fd;

    /* Call presecondary script.  */
    bool pre = true;

	    char *data;
	    size_t thispass, got;
	    int s;
	    char *newdata;

    Parse_Info (CVSROOTADM_PREPROXY, current_parsed_root->directory,
		prepost_proxy_proc, PIOPT_ALL, &pre);

    /* Open connection to primary server.  */
    open_connection_to_server (config->PrimaryServer, &buf_to_primary,
                               &buf_from_primary);
    setup_logfiles ("CVS_SECONDARY_LOG", &buf_to_primary, &buf_from_primary);
    if ((status = set_nonblock (buf_from_primary)))
	error (1, status, "failed to set nonblocking io from primary");
    if ((status = set_nonblock (buf_from_net)))
	error (1, status, "failed to set nonblocking io from client");
    if ((status = set_nonblock (buf_to_primary)))
	error (1, status, "failed to set nonblocking io to primary");
    if ((status = set_nonblock (buf_to_net)))
	error (1, status, "failed to set nonblocking io to client");

    to_primary_fd = buf_get_fd (buf_to_primary);
    from_primary_fd = buf_get_fd (buf_from_primary);
    to_net_fd = buf_get_fd (buf_to_net);
    assert (to_primary_fd >= 0 && from_primary_fd >= 0 && to_net_fd >= 0);

    /* Close the client log and open it for read.  */
    rewind_buf_from_net ();

    while (from_primary_fd >= 0 || to_primary_fd >= 0)
    {
	fd_set readfds, writefds;
	int status, numfds = -1;
	struct timeval *timeout_ptr;
	struct timeval timeout;
	size_t toread;

	FD_ZERO (&readfds);
	FD_ZERO (&writefds);

	/* The fd for a multi-source buffer can change with any read.  */
	from_net_fd = buf_from_net ? buf_get_fd (buf_from_net) : -1;

	if ((buf_from_net && !buf_empty_p (buf_from_net))
	    || (buf_from_primary && !buf_empty_p (buf_from_primary)))
	{
	    /* There is data pending so don't block if we don't find any new
	     * data on the fds.
	     */
	    timeout.tv_sec = 0;
	    timeout.tv_usec = 0;
	    timeout_ptr = &timeout;
	}
	else
	    /* block indefinately */
	    timeout_ptr = NULL;

	/* Set writefds if data is pending.  */
	if (to_net_fd >= 0 && !buf_empty_p (buf_to_net))
	{
	    FD_SET (to_net_fd, &writefds);
	    numfds = MAX (numfds, to_net_fd);
	}
	if (to_primary_fd >= 0 && !buf_empty_p (buf_to_primary))
	{
	    FD_SET (to_primary_fd, &writefds);
	    numfds = MAX (numfds, to_primary_fd);
	}

	/* Set readfds if descriptors are still open.  */
	if (from_net_fd >= 0)
	{
	    FD_SET (from_net_fd, &readfds);
	    numfds = MAX (numfds, from_net_fd);
	}
	if (from_primary_fd >= 0)
	{
	    FD_SET (from_primary_fd, &readfds);
	    numfds = MAX (numfds, from_primary_fd);
	}

	/* NUMFDS needs to be the highest descriptor + 1 according to the
	 * select spec.
	 */
	numfds++;

	do {
	    /* This used to select on exceptions too, but as far
	       as I know there was never any reason to do that and
	       SCO doesn't let you select on exceptions on pipes.  */
	    numfds = select (numfds, &readfds, &writefds,
			     NULL, timeout_ptr);
	    if (numfds < 0 && errno != EINTR)
	    {
		/* Sending an error to the client, possibly in the middle of a
		 * separate protocol message, will likely not mean much to the
		 * client, but it's better than nothing, I guess.
		 */
		buf_output0 (buf_to_net, "E select failed\n");
		print_error (errno);
		exit (EXIT_FAILURE);
	    }
	} while (numfds < 0);

	if (numfds == 0)
	{
	    FD_ZERO (&readfds);
	    FD_ZERO (&writefds);
	}

	if (to_net_fd >= 0 && FD_ISSET (to_net_fd, &writefds))
	{
	    /* What should we do with errors?  syslog() them?  */
	    buf_send_output (buf_to_net);
	    buf_flush (buf_to_net, false);
	}

	status = 0;
	if (from_net_fd >= 0 && (FD_ISSET (from_net_fd, &readfds)))
	    status = buf_input_data (buf_from_net, NULL);

	if (buf_from_net && !buf_empty_p (buf_from_net))
	{
	    if (buf_to_primary)
		buf_append_buffer (buf_to_primary, buf_from_net);
	    else
		/* (Sys?)log this?  */;
		
	}

	if (status == -1 /* EOF */)
	{
	    SIG_beginCrSect();
	    /* Need only to shut this down and set to NULL, really, in
	     * crit sec, to ensure no double-dispose and to make sure
	     * network pipes are closed as properly as possible, but I
	     * don't see much optimization potential in saving values and
	     * postponing the free.
	     */
	    buf_shutdown (buf_from_net);
	    buf_free (buf_from_net);
	    buf_from_net = NULL;
	    /* So buf_to_primary will be closed at the end of this loop.  */
	    from_net_fd = -1;
	    SIG_endCrSect();
	}
	else if (status > 0 /* ERRNO */)
	{
	    buf_output0 (buf_to_net,
			 "E buf_input_data failed reading from client\n");
	    print_error (status);
	    exit (EXIT_FAILURE);
	}

	if (to_primary_fd >= 0 && FD_ISSET (to_primary_fd, &writefds))
	{
	    /* What should we do with errors?  syslog() them?  */
	    buf_send_output (buf_to_primary);
	    buf_flush (buf_to_primary, false);
	}

	status = 0;
	if (from_primary_fd >= 0 && FD_ISSET (from_primary_fd, &readfds))
	    status = buf_input_data (buf_from_primary, &toread);

	/* Avoid resending data from the server which we already sent to the
	 * client.  Otherwise clients get really confused.
	 */
	if (buf_clientlog
	    && buf_from_primary && !buf_empty_p (buf_from_primary))
	{
	    /* Dispose of data we already sent to the client.  */
	    while (buf_clientlog && toread > 0)
	    {
		s = buf_read_data (buf_clientlog, toread, &data, &got);
		if (s == -2)
		    error (1, ENOMEM, "Failed to read data.");
		if (s == -1)
		{
		    buf_shutdown (buf_clientlog);
		    buf_clientlog = NULL;
		}
		else if (s)
		    error (1, s, "Error reading writeproxy log.");
		else
		{
		    thispass = got;
		    while (thispass > 0)
		    {
			/* No need to check for errors here since we know we
			 * won't read more than buf_input read into
			 * BUF_FROM_PRIMARY (see how TOREAD is set above).
			 */
			buf_read_data (buf_from_primary, thispass, &newdata,
				       &got);
			/* Verify that we are throwing away what we think we
			 * are.
			 *
			 * It is valid to assume that the secondary and primary
			 * are closely enough in sync that this portion of the
			 * communication will be in sync beacuse if they were
			 * not, then the secondary might provide a
			 * valid-request string to the client which contained a
			 * request that the primary didn't support.  If the
			 * client later used the request, the primary server
			 * would exit anyhow.
			 *
			 * FIXME?
			 * An alternative approach might be to make sure that
			 * the secondary provides the same string as the
			 * primary regardless, for purposes like pointing a
			 * secondary at an unwitting primary, in which case it
			 * might be useful to have some way to override the
			 * valid-requests string on a secondary, but it seems
			 * much easier to simply sync the versions, at the
			 * moment.
			 */
			if (memcmp (data, newdata, got))
			    error (1, 0, "Secondary out of sync with primary!");
			data += got;
			thispass -= got;
		    }
		    toread -= got;
		}
	    }
	}

	if (buf_from_primary && !buf_empty_p (buf_from_primary))
	{
	    if (buf_to_net)
		buf_append_buffer (buf_to_net, buf_from_primary);
	    else
		/* (Sys?)log this?  */;
		
	}

	if (status == -1 /* EOF */)
	{
	    buf_shutdown (buf_from_primary);
	    buf_from_primary = NULL;
	    from_primary_fd = -1;
	}
	else if (status > 0 /* ERRNO */)
	{
	    buf_output0 (buf_to_net,
			 "E buf_input_data failed reading from primary\n");
	    print_error (status);
	    exit (EXIT_FAILURE);
	}

	/* If our "source pipe" is closed and all data has been sent, close
	 * the corresponding "dest pipe".
	 */
	if (from_primary_fd < 0
	    && buf_to_net && buf_empty_p (buf_to_net))
	{
	    to_net_fd = -1;
	    /* Don't actually shut down or free BUF_TO_NET unless BUF_FROM_NET
	     * is already closed.  Let the shutdown handlers do it otherwise
	     * since we might need it later.
	     */
	    if (!buf_from_net)
	    {
		SIG_beginCrSect();
		/* Need only to shut this down and set to NULL, really, in
		 * crit sec, to ensure no double-dispose and to make sure
		 * network pipes are closed as properly as possible, but I
		 * don't see much optimization potential in saving values and
		 * postponing the free.
		 */
		buf_shutdown (buf_to_net);
		buf_free (buf_to_net);
		buf_to_net = NULL;
		SIG_endCrSect();
	    }
	}
	if (from_net_fd < 0
	    && buf_to_primary && buf_empty_p (buf_to_primary))
	{
	    buf_shutdown (buf_to_primary);
	    buf_free (buf_to_primary);
	    buf_to_primary = NULL;
	    to_primary_fd = -1;
	}
    }

    /* Call postsecondary script.  */
    pre = false;
    Parse_Info (CVSROOTADM_POSTPROXY, current_parsed_root->directory,
		prepost_proxy_proc, PIOPT_ALL, &pre);
}
#endif /* PROXY_SUPPORT */



struct notify_note {
    /* Directory in which this notification happens.  xmalloc'd*/
    char *dir;

    /* xmalloc'd.  */
    char *update_dir;

    /* xmalloc'd.  */
    char *filename;

    /* The following three all in one xmalloc'd block, pointed to by TYPE.
       Each '\0' terminated.  */
    /* "E" or "U".  */
    char *type;
    /* time+host+dir */
    char *val;
    char *watches;

    struct notify_note *next;
};

static struct notify_note *notify_list;
/* Used while building list, to point to the last node that already exists.  */
static struct notify_note *last_node;

static void
serve_notify (char *arg)
{
    struct notify_note *new = NULL;
    char *data = NULL;
    int status;

    if (error_pending ()) return;

    if (isProxyServer())
    {
#ifdef PROXY_SUPPORT
	if (!proxy_log)
	{
#endif /* PROXY_SUPPORT */
	    if (alloc_pending (160) + strlen (program_name))
		sprintf (pending_error_text, 
"E This CVS server does not support disconnected `%s edit'.  For now, remove all `%s' files in your workspace and try your command again.",
			 program_name, CVSADM_NOTIFY);
	return;
#ifdef PROXY_SUPPORT
	}
	else
	{
	    /* This is effectively a write command, so run it on the primary.  */
	    become_proxy ();
	    exit (EXIT_SUCCESS);
	}
#endif /* PROXY_SUPPORT */
    }

    if (outside_dir (arg))
	return;

    if (gDirname == NULL)
	goto error;

    new = xmalloc (sizeof (struct notify_note));
    if (new == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    new->dir = xmalloc (strlen (gDirname) + 1);
    new->update_dir = xmalloc (strlen (gupdate_dir) + 1);
    new->filename = xmalloc (strlen (arg) + 1);
    if (new->dir == NULL || new->update_dir == NULL || new->filename == NULL)
    {
	pending_error = ENOMEM;
	if (new->dir != NULL)
	    free (new->dir);
	free (new);
	return;
    }
    strcpy (new->dir, gDirname);
    strcpy (new->update_dir, gupdate_dir);
    strcpy (new->filename, arg);

    status = buf_read_line (buf_from_net, &data, NULL);
    if (status != 0)
    {
	if (status == -2)
	    pending_error = ENOMEM;
	else
	{
	    pending_error_text = xmalloc (80 + strlen (arg));
	    if (pending_error_text == NULL)
		pending_error = ENOMEM;
	    else
	    {
		if (status == -1)
		    sprintf (pending_error_text,
			     "E end of file reading notification for %s", arg);
		else
		{
		    sprintf (pending_error_text,
			     "E error reading notification for %s", arg);
		    pending_error = status;
		}
	    }
	}
	free (new->filename);
	free (new->dir);
	free (new);
    }
    else
    {
	char *cp;

	if (!data[0])
	    goto error;

	if (strchr (data, '+'))
	    goto error;

	new->type = data;
	if (data[1] != '\t')
	    goto error;
	data[1] = '\0';
	cp = data + 2;
	new->val = cp;
	cp = strchr (cp, '\t');
	if (cp == NULL)
	    goto error;
	*cp++ = '+';
	cp = strchr (cp, '\t');
	if (cp == NULL)
	    goto error;
	*cp++ = '+';
	cp = strchr (cp, '\t');
	if (cp == NULL)
	    goto error;
	*cp++ = '\0';
	new->watches = cp;
	/* If there is another tab, ignore everything after it,
	   for future expansion.  */
	cp = strchr (cp, '\t');
	if (cp != NULL)
	    *cp = '\0';

	new->next = NULL;

	if (last_node == NULL)
	    notify_list = new;
	else
	    last_node->next = new;
	last_node = new;
    }
    return;
  error:
    pending_error = 0;
    if (alloc_pending (80))
	strcpy (pending_error_text,
		"E Protocol error; misformed Notify request");
    if (data != NULL)
	free (data);
    if (new != NULL)
    {
	free (new->filename);
	free (new->update_dir);
	free (new->dir);
	free (new);
    }
    return;
}



static void
serve_hostname (char *arg)
{
    free (hostname);
    hostname = xstrdup (arg);
    return;
}



static void
serve_localdir (char *arg)
{
    if (CurDir) free (CurDir);
    CurDir = xstrdup (arg);
}



/* Process all the Notify requests that we have stored up.  Returns 0
   if successful, if not prints error message (via error()) and
   returns negative value.  */
static int
server_notify (void)
{
    struct notify_note *p;
    char *repos;

    TRACE (TRACE_FUNCTION, "server_notify()");

    while (notify_list != NULL)
    {
	if (CVS_CHDIR (notify_list->dir) < 0)
	{
	    error (0, errno, "cannot change to %s", notify_list->dir);
	    return -1;
	}
	repos = Name_Repository (NULL, NULL);

	lock_dir_for_write (repos);

	fileattr_startdir (repos);

	notify_do (*notify_list->type, notify_list->filename,
		   notify_list->update_dir, getcaller(), notify_list->val,
		   notify_list->watches, repos);

	buf_output0 (buf_to_net, "Notified ");
	{
	    char *dir = notify_list->dir + strlen (server_temp_dir) + 1;
	    if (dir[0] == '\0')
		buf_append_char (buf_to_net, '.');
	    else
		buf_output0 (buf_to_net, dir);
	    buf_append_char (buf_to_net, '/');
	    buf_append_char (buf_to_net, '\n');
	}
	buf_output0 (buf_to_net, repos);
	buf_append_char (buf_to_net, '/');
	buf_output0 (buf_to_net, notify_list->filename);
	buf_append_char (buf_to_net, '\n');
	free (repos);

	p = notify_list->next;
	free (notify_list->filename);
	free (notify_list->dir);
	free (notify_list->type);
	free (notify_list);
	notify_list = p;

	fileattr_write ();
	fileattr_free ();

	Lock_Cleanup ();
    }

    last_node = NULL;

    /* The code used to call fflush (stdout) here, but that is no
       longer necessary.  The data is now buffered in buf_to_net,
       which will be flushed by the caller, do_cvs_command.  */

    return 0;
}



/* This request is processed in all passes since requests which must
 * sometimes be processed before it is known whether we are running as a
 * secondary or not, for instance the `expand-modules' request, sometimes use
 * the `Arguments'.
 */
static void
serve_argument (char *arg)
{
    char *p;

    if (error_pending()) return;

    if (argument_count >= 10000)
    {
	if (alloc_pending (80))
	    sprintf (pending_error_text, 
		     "E Protocol error: too many arguments");
	return;
    }

    if (argument_vector_size <= argument_count)
    {
	argument_vector_size *= 2;
	argument_vector = xrealloc (argument_vector,
			            argument_vector_size * sizeof (char *));
	if (argument_vector == NULL)
	{
	    pending_error = ENOMEM;
	    return;
	}
    }
    p = xmalloc (strlen (arg) + 1);
    if (p == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (p, arg);
    argument_vector[argument_count++] = p;
}



/* For secondary servers, this is handled in all passes, as is the `Argument'
 * request, and for the same reasons.
 */
static void
serve_argumentx (char *arg)
{
    char *p;

    if (error_pending()) return;
    
    if (argument_count <= 1) 
    {
	if (alloc_pending (80))
	    sprintf (pending_error_text,
"E Protocol error: called argumentx without prior call to argument");
	return;
    }

    p = argument_vector[argument_count - 1];
    p = xrealloc (p, strlen (p) + 1 + strlen (arg) + 1);
    if (p == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcat (p, "\n");
    strcat (p, arg);
    argument_vector[argument_count - 1] = p;
}



static void
serve_global_option (char *arg)
{
#ifdef PROXY_SUPPORT
    /* This can generate error messages and termination before `Root' requests,
     * so it must be dealt with in the first pass.
     */ 
    if (reprocessing) return;
#endif /* PROXY_SUPPORT */

    if (arg[0] != '-' || arg[1] == '\0' || arg[2] != '\0')
    {
    error_return:
	if (alloc_pending (strlen (arg) + 80))
	    sprintf (pending_error_text,
		     "E Protocol error: bad global option %s",
		     arg);
	return;
    }
    switch (arg[1])
    {
	case 'l':
	    error(0, 0, "WARNING: global `-l' option ignored.");
	    break;
	case 'n':
	    noexec = 1;
	    logoff = 1;
	    break;
	case 'q':
	    quiet = 1;
	    break;
	case 'r':
	    cvswrite = 0;
	    break;
	case 'Q':
	    really_quiet = 1;
	    break;
	case 't':
	    trace++;
	    break;
	default:
	    goto error_return;
    }
}



/* This needs to be processed before Root requests, so we allow it to be
 * be processed before knowing whether we are running as a secondary server
 * to allow `noop' and `Root' requests to generate errors as before.
 */
static void
serve_set (char *arg)
{
#ifdef PROXY_SUPPORT
    if (reprocessing) return;
#endif /* PROXY_SUPPORT */

    /* FIXME: This sends errors immediately (I think); they should be
       put into pending_error.  */
    variable_set (arg);
}

#ifdef ENCRYPTION

#ifdef HAVE_KERBEROS

static void
serve_kerberos_encrypt( char *arg )
{
#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */

    /* All future communication with the client will be encrypted.  */

    buf_to_net = krb_encrypt_buffer_initialize (buf_to_net, 0, sched,
						kblock,
						buf_to_net->memory_error);
    buf_from_net = krb_encrypt_buffer_initialize (buf_from_net, 1, sched,
						  kblock,
						  buf_from_net->memory_error);
}

#endif /* HAVE_KERBEROS */

#ifdef HAVE_GSSAPI

static void
serve_gssapi_encrypt( char *arg )
{
#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */

    if (cvs_gssapi_wrapping)
    {
	/* We're already using a gssapi_wrap buffer for stream
	   authentication.  Flush everything we've output so far, and
	   turn on encryption for future data.  On the input side, we
	   should only have unwrapped as far as the Gssapi-encrypt
	   command, so future unwrapping will become encrypted.  */
	buf_flush (buf_to_net, 1);
	cvs_gssapi_encrypt = 1;
	return;
    }

    /* All future communication with the client will be encrypted.  */

    cvs_gssapi_encrypt = 1;

    buf_to_net = cvs_gssapi_wrap_buffer_initialize (buf_to_net, 0,
						    gcontext,
						    buf_to_net->memory_error);
    buf_from_net = cvs_gssapi_wrap_buffer_initialize (buf_from_net, 1,
						      gcontext,
						      buf_from_net->memory_error);

    cvs_gssapi_wrapping = 1;
}

#endif /* HAVE_GSSAPI */

#endif /* ENCRYPTION */

#ifdef HAVE_GSSAPI

static void
serve_gssapi_authenticate (char *arg)
{
#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */

    if (cvs_gssapi_wrapping)
    {
	/* We're already using a gssapi_wrap buffer for encryption.
	   That includes authentication, so we don't have to do
	   anything further.  */
	return;
    }

    buf_to_net = cvs_gssapi_wrap_buffer_initialize (buf_to_net, 0,
						    gcontext,
						    buf_to_net->memory_error);
    buf_from_net = cvs_gssapi_wrap_buffer_initialize (buf_from_net, 1,
						      gcontext,
						      buf_from_net->memory_error);

    cvs_gssapi_wrapping = 1;
}

#endif /* HAVE_GSSAPI */



#ifdef SERVER_FLOWCONTROL
/* The maximum we'll queue to the remote client before blocking.  */
# ifndef SERVER_HI_WATER
#  define SERVER_HI_WATER (2 * 1024 * 1024)
# endif /* SERVER_HI_WATER */
/* When the buffer drops to this, we restart the child */
# ifndef SERVER_LO_WATER
#  define SERVER_LO_WATER (1 * 1024 * 1024)
# endif /* SERVER_LO_WATER */
#endif /* SERVER_FLOWCONTROL */



static void
serve_questionable (char *arg)
{
    static int initted;

#ifdef PROXY_SUPPORT
    if (proxy_log) return;
#endif /* PROXY_SUPPORT */

    if (error_pending ()) return;

    if (!initted)
    {
	/* Pick up ignores from CVSROOTADM_IGNORE, $HOME/.cvsignore on server,
	   and CVSIGNORE on server.  */
	ign_setup ();
	initted = 1;
    }

    if (gDirname == NULL)
    {
	if (alloc_pending (80))
	    sprintf (pending_error_text,
"E Protocol error: `Directory' missing");
	return;
    }

    if (outside_dir (arg))
	return;

    if (!ign_name (arg))
    {
	char *update_dir;

	buf_output (buf_to_net, "M ? ", 4);
	update_dir = gDirname + strlen (server_temp_dir) + 1;
	if (!(update_dir[0] == '.' && update_dir[1] == '\0'))
	{
	    buf_output0 (buf_to_net, update_dir);
	    buf_output (buf_to_net, "/", 1);
	}
	buf_output0 (buf_to_net, arg);
	buf_output (buf_to_net, "\n", 1);
    }
}



static struct buffer *protocol = NULL;

/* This is the output which we are saving up to send to the server, in the
   child process.  We will push it through, via the `protocol' buffer, when
   we have a complete line.  */
static struct buffer *saved_output;

/* Likewise, but stuff which will go to stderr.  */
static struct buffer *saved_outerr;



static void
protocol_memory_error (struct buffer *buf)
{
    error (1, ENOMEM, "Virtual memory exhausted");
}



/* If command is valid, return 1.
 * Else if command is invalid and croak_on_invalid is set, then die.
 * Else just return 0 to indicate that command is invalid.
 */
static bool
check_command_valid_p (char *cmd_name)
{
    /* Right now, only pserver notices invalid commands -- namely,
     * write attempts by a read-only user.  Therefore, if CVS_Username
     * is not set, this just returns 1, because CVS_Username unset
     * means pserver is not active.
     */
#ifdef AUTH_SERVER_SUPPORT
    if (CVS_Username == NULL)
	return true;

    if (lookup_command_attribute (cmd_name) & CVS_CMD_MODIFIES_REPOSITORY)
    {
	/* This command has the potential to modify the repository, so
	 * we check if the user have permission to do that.
	 *
	 * (Only relevant for remote users -- local users can do
	 * whatever normal Unix file permissions allow them to do.)
	 *
	 * The decision method:
	 *
	 *    If $CVSROOT/CVSADMROOT_READERS exists and user is listed
	 *    in it, then read-only access for user.
	 *
	 *    Or if $CVSROOT/CVSADMROOT_WRITERS exists and user NOT
	 *    listed in it, then also read-only access for user.
	 *
	 *    Else read-write access for user.
	 */

	 char *linebuf = NULL;
	 int num_red = 0;
	 size_t linebuf_len = 0;
	 char *fname;
	 size_t flen;
	 FILE *fp;
	 int found_it = 0;

	 /* else */
	 flen = strlen (current_parsed_root->directory)
		+ strlen (CVSROOTADM)
		+ strlen (CVSROOTADM_READERS)
		+ 3;

	 fname = xmalloc (flen);
	 (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
			CVSROOTADM, CVSROOTADM_READERS);

	 fp = fopen (fname, "r");

	 if (fp == NULL)
	 {
	     if (!existence_error (errno))
	     {
		 /* Need to deny access, so that attackers can't fool
		    us with some sort of denial of service attack.  */
		 error (0, errno, "cannot open %s", fname);
		 free (fname);
		 return false;
	     }
	 }
         else  /* successfully opened readers file */
         {
             while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
             {
                 /* Hmmm, is it worth importing my own readline
                    library into CVS?  It takes care of chopping
                    leading and trailing whitespace, "#" comments, and
                    newlines automatically when so requested.  Would
                    save some code here...  -kff */

                 /* Chop newline by hand, for strcmp()'s sake. */
                 if (num_red > 0 && linebuf[num_red - 1] == '\n')
                     linebuf[num_red - 1] = '\0';

                 if (strcmp (linebuf, CVS_Username) == 0)
                     goto handle_invalid;
             }
	     if (num_red < 0 && !feof (fp))
		 error (0, errno, "cannot read %s", fname);

	     /* If not listed specifically as a reader, then this user
		has write access by default unless writers are also
		specified in a file . */
	     if (fclose (fp) < 0)
		 error (0, errno, "cannot close %s", fname);
	 }
	 free (fname);

	 /* Now check the writers file.  */

	 flen = strlen (current_parsed_root->directory)
		+ strlen (CVSROOTADM)
		+ strlen (CVSROOTADM_WRITERS)
		+ 3;

	 fname = xmalloc (flen);
	 (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
			CVSROOTADM, CVSROOTADM_WRITERS);

	 fp = fopen (fname, "r");

	 if (fp == NULL)
	 {
	     if (linebuf)
		 free (linebuf);
	     if (existence_error (errno))
	     {
		 /* Writers file does not exist, so everyone is a writer,
		    by default.  */
		 free (fname);
		 return true;
	     }
	     else
	     {
		 /* Need to deny access, so that attackers can't fool
		    us with some sort of denial of service attack.  */
		 error (0, errno, "cannot read %s", fname);
		 free (fname);
		 return false;
	     }
	 }

	 found_it = 0;
	 while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
	 {
	     /* Chop newline by hand, for strcmp()'s sake. */
	     if (num_red > 0 && linebuf[num_red - 1] == '\n')
		 linebuf[num_red - 1] = '\0';

	     if (strcmp (linebuf, CVS_Username) == 0)
	     {
		 found_it = 1;
		 break;
	     }
	 }
	 if (num_red < 0 && !feof (fp))
	     error (0, errno, "cannot read %s", fname);

	 if (found_it)
	 {
	     if (fclose (fp) < 0)
		 error (0, errno, "cannot close %s", fname);
	     if (linebuf)
		 free (linebuf);
	     free (fname);
             return true;
         }
         else   /* writers file exists, but this user not listed in it */
         {
         handle_invalid:
             if (fclose (fp) < 0)
		 error (0, errno, "cannot close %s", fname);
	     if (linebuf)
		 free (linebuf);
	     free (fname);
	     return false;
	 }
    }
#endif /* AUTH_SERVER_SUPPORT */

    /* If ever reach end of this function, command must be valid. */
    return true;
}



/* Execute COMMAND in a subprocess with the approriate funky things done.  */

static struct fd_set_wrapper { fd_set fds; } command_fds_to_drain;
#ifdef SUNOS_KLUDGE
static int max_command_fd;
#endif

#ifdef SERVER_FLOWCONTROL
static int flowcontrol_pipe[2];
#endif /* SERVER_FLOWCONTROL */



/*
 * Set buffer FD to non-blocking I/O.  Returns 0 for success or errno
 * code.
 */
int
set_nonblock_fd (int fd)
{
#if defined (F_GETFL) && defined (O_NONBLOCK) && defined (F_SETFL)
    int flags;

    flags = fcntl (fd, F_GETFL, 0);
    if (flags < 0)
	return errno;
    if (fcntl (fd, F_SETFL, flags | O_NONBLOCK) < 0)
	return errno;
#endif /* F_GETFL && O_NONBLOCK && F_SETFL */
    return 0;
}



static void
do_cvs_command (char *cmd_name, int (*command) (int, char **))
{
    /*
     * The following file descriptors are set to -1 if that file is not
     * currently open.
     */

    /* Data on these pipes is a series of '\n'-terminated lines.  */
    int stdout_pipe[2];
    int stderr_pipe[2];

    /*
     * Data on this pipe is a series of counted (see buf_send_counted)
     * packets.  Each packet must be processed atomically (i.e. not
     * interleaved with data from stdout_pipe or stderr_pipe).
     */
    int protocol_pipe[2];

    int dev_null_fd = -1;

    int errs;

    TRACE (TRACE_FUNCTION, "do_cvs_command (%s)", cmd_name);

    /* Write proxy logging is always terminated when a command is received.
     * Therefore, we wish to avoid reprocessing the command since that would
     * cause endless recursion.
     */
    if (isProxyServer())
    {
#ifdef PROXY_SUPPORT
	if (reprocessing)
	    /* This must be the second time we've reached this point.
	     * Done reprocessing.
	     */
	    reprocessing = false;
	else
	{
	    if (lookup_command_attribute (cmd_name)
		    & CVS_CMD_MODIFIES_REPOSITORY)
	    {
		become_proxy ();
		exit (EXIT_SUCCESS);
	    }
	    else if (/* serve_co may have called this already and missing logs
		      * should have generated an error in serve_root().
		      */
		     proxy_log)
	    {
		/* Set up the log for reprocessing.  */
		rewind_buf_from_net ();
		/* And return to the main loop in server(), where we will now
		 * find the logged secondary data and reread it.
		 */
		return;
	    }
	}
#else /* !PROXY_SUPPORT */
	if (lookup_command_attribute (cmd_name)
		    & CVS_CMD_MODIFIES_REPOSITORY
	    && alloc_pending (120))
	    sprintf (pending_error_text, 
"E You need a CVS client that supports the `Redirect' response for write requests to this server.");
	return;
#endif /* PROXY_SUPPORT */
    }

    command_pid = -1;
    stdout_pipe[0] = -1;
    stdout_pipe[1] = -1;
    stderr_pipe[0] = -1;
    stderr_pipe[1] = -1;
    protocol_pipe[0] = -1;
    protocol_pipe[1] = -1;

    server_write_entries ();

    if (print_pending_error ())
	goto free_args_and_return;

    /* Global `cvs_cmd_name' is probably "server" right now -- only
       serve_export() sets it to anything else.  So we will use local
       parameter `cmd_name' to determine if this command is valid for
       this user.  */
    if (!check_command_valid_p (cmd_name))
    {
	buf_output0 (buf_to_net, "E ");
	buf_output0 (buf_to_net, program_name);
	buf_output0 (buf_to_net, " [server aborted]: \"");
	buf_output0 (buf_to_net, cmd_name);
	buf_output0 (buf_to_net,
"\" requires write access to the repository\n\
error  \n");
	goto free_args_and_return;
    }
    cvs_cmd_name = cmd_name;

    (void) server_notify ();

    /*
     * We use a child process which actually does the operation.  This
     * is so we can intercept its standard output.  Even if all of CVS
     * were written to go to some special routine instead of writing
     * to stdout or stderr, we would still need to do the same thing
     * for the RCS commands.
     */

    if (pipe (stdout_pipe) < 0)
    {
	buf_output0 (buf_to_net, "E pipe failed\n");
	print_error (errno);
	goto error_exit;
    }
    if (pipe (stderr_pipe) < 0)
    {
	buf_output0 (buf_to_net, "E pipe failed\n");
	print_error (errno);
	goto error_exit;
    }
    if (pipe (protocol_pipe) < 0)
    {
	buf_output0 (buf_to_net, "E pipe failed\n");
	print_error (errno);
	goto error_exit;
    }
#ifdef SERVER_FLOWCONTROL
    if (pipe (flowcontrol_pipe) < 0)
    {
	buf_output0 (buf_to_net, "E pipe failed\n");
	print_error (errno);
	goto error_exit;
    }
    set_nonblock_fd (flowcontrol_pipe[0]);
    set_nonblock_fd (flowcontrol_pipe[1]);
#endif /* SERVER_FLOWCONTROL */

    dev_null_fd = CVS_OPEN (DEVNULL, O_RDONLY);
    if (dev_null_fd < 0)
    {
	buf_output0 (buf_to_net, "E open /dev/null failed\n");
	print_error (errno);
	goto error_exit;
    }

    /* We shouldn't have any partial lines from cvs_output and
       cvs_outerr, but we handle them here in case there is a bug.  */
    /* FIXME: appending a newline, rather than using "MT" as we
       do in the child process, is probably not really a very good
       way to "handle" them.  */
    if (! buf_empty_p (saved_output))
    {
	buf_append_char (saved_output, '\n');
	buf_copy_lines (buf_to_net, saved_output, 'M');
    }
    if (! buf_empty_p (saved_outerr))
    {
	buf_append_char (saved_outerr, '\n');
	buf_copy_lines (buf_to_net, saved_outerr, 'E');
    }

    /* Flush out any pending data.  */
    buf_flush (buf_to_net, 1);

    /* Don't use vfork; we're not going to exec().  */
    command_pid = fork ();
    if (command_pid < 0)
    {
	buf_output0 (buf_to_net, "E fork failed\n");
	print_error (errno);
	goto error_exit;
    }
    if (command_pid == 0)
    {
	int exitstatus;

	/* Since we're in the child, and the parent is going to take
	   care of packaging up our error messages, we can clear this
	   flag.  */
	error_use_protocol = 0;

	protocol = fd_buffer_initialize (protocol_pipe[1], 0, NULL, false,
					 protocol_memory_error);

	/* At this point we should no longer be using buf_to_net and
	   buf_from_net.  Instead, everything should go through
	   protocol.  */
	if (buf_to_net != NULL)
	{
	    buf_free (buf_to_net);
	    buf_to_net = NULL;
	}
	if (buf_from_net != NULL)
	{
	    buf_free (buf_from_net);
	    buf_from_net = NULL;
	}

	/* These were originally set up to use outbuf_memory_error.
	   Since we're now in the child, we should use the simpler
	   protocol_memory_error function.  */
	saved_output->memory_error = protocol_memory_error;
	saved_outerr->memory_error = protocol_memory_error;

	if (dup2 (dev_null_fd, STDIN_FILENO) < 0)
	    error (1, errno, "can't set up pipes");
	if (dup2 (stdout_pipe[1], STDOUT_FILENO) < 0)
	    error (1, errno, "can't set up pipes");
	if (dup2 (stderr_pipe[1], STDERR_FILENO) < 0)
	    error (1, errno, "can't set up pipes");
	close (dev_null_fd);
	close (stdout_pipe[0]);
	close (stdout_pipe[1]);
	close (stderr_pipe[0]);
	close (stderr_pipe[1]);
	close (protocol_pipe[0]);
	close_on_exec (protocol_pipe[1]);
#ifdef SERVER_FLOWCONTROL
	close_on_exec (flowcontrol_pipe[0]);
	close (flowcontrol_pipe[1]);
#endif /* SERVER_FLOWCONTROL */

	/*
	 * Set this in .bashrc if you want to give yourself time to attach
	 * to the subprocess with a debugger.
	 */
	if (getenv ("CVS_SERVER_SLEEP"))
	{
	    int secs = atoi (getenv ("CVS_SERVER_SLEEP"));
	    TRACE (TRACE_DATA, "Sleeping CVS_SERVER_SLEEP (%d) seconds", secs);
	    sleep (secs);
	}
	else
	    TRACE (TRACE_DATA, "CVS_SERVER_SLEEP not set.");

	exitstatus = (*command) (argument_count, argument_vector);

	/* Output any partial lines.  If the client doesn't support
	   "MT", we go ahead and just tack on a newline since the
	   protocol doesn't support anything better.  */
	if (! buf_empty_p (saved_output))
	{
	    buf_output0 (protocol, supported_response ("MT") ? "MT text " : "M ");
	    buf_append_buffer (protocol, saved_output);
	    buf_output (protocol, "\n", 1);
	    buf_send_counted (protocol);
	}
	/* For now we just discard partial lines on stderr.  I suspect
	   that CVS can't write such lines unless there is a bug.  */

	buf_free (protocol);

	/* Close the pipes explicitly in order to send an EOF to the parent,
	 * then wait for the parent to close the flow control pipe.  This
	 * avoids a race condition where a child which dumped more than the
	 * high water mark into the pipes could complete its job and exit,
	 * leaving the parent process to attempt to write a stop byte to the
	 * closed flow control pipe, which earned the parent a SIGPIPE, which
	 * it normally only expects on the network pipe and that causes it to
	 * exit with an error message, rather than the SIGCHILD that it knows
	 * how to handle correctly.
	 */
	/* Let exit() close STDIN - it's from /dev/null anyhow.  */
	fclose (stderr);
	fclose (stdout);
	close (protocol_pipe[1]);
#ifdef SERVER_FLOWCONTROL
	{
	    char junk;
	    ssize_t status;
	    while ((status = read (flowcontrol_pipe[0], &junk, 1)) > 0
	           || (status == -1 && errno == EAGAIN));
	}
	/* FIXME: No point in printing an error message with error(),
	 * as STDERR is already closed, but perhaps this could be syslogged?
	 */
#endif

	exit (exitstatus);
    }

    /* OK, sit around getting all the input from the child.  */
    {
	struct buffer *stdoutbuf;
	struct buffer *stderrbuf;
	struct buffer *protocol_inbuf;
	/* Number of file descriptors to check in select ().  */
	int num_to_check;
	int count_needed = 1;
#ifdef SERVER_FLOWCONTROL
	int have_flowcontrolled = 0;
#endif /* SERVER_FLOWCONTROL */

	FD_ZERO (&command_fds_to_drain.fds);
	num_to_check = stdout_pipe[0];
	FD_SET (stdout_pipe[0], &command_fds_to_drain.fds);
	num_to_check = MAX (num_to_check, stderr_pipe[0]);
	FD_SET (stderr_pipe[0], &command_fds_to_drain.fds);
	num_to_check = MAX (num_to_check, protocol_pipe[0]);
	FD_SET (protocol_pipe[0], &command_fds_to_drain.fds);
	num_to_check = MAX (num_to_check, STDOUT_FILENO);
#ifdef SUNOS_KLUDGE
	max_command_fd = num_to_check;
#endif
	/*
	 * File descriptors are numbered from 0, so num_to_check needs to
	 * be one larger than the largest descriptor.
	 */
	++num_to_check;
	if (num_to_check > FD_SETSIZE)
	{
	    buf_output0 (buf_to_net,
			 "E internal error: FD_SETSIZE not big enough.\n\
error  \n");
	    goto error_exit;
	}

	stdoutbuf = fd_buffer_initialize (stdout_pipe[0], 0, NULL, true,
					  input_memory_error);

	stderrbuf = fd_buffer_initialize (stderr_pipe[0], 0, NULL, true,
					  input_memory_error);

	protocol_inbuf = fd_buffer_initialize (protocol_pipe[0], 0, NULL, true,
					       input_memory_error);

	set_nonblock (buf_to_net);
	set_nonblock (stdoutbuf);
	set_nonblock (stderrbuf);
	set_nonblock (protocol_inbuf);

	if (close (stdout_pipe[1]) < 0)
	{
	    buf_output0 (buf_to_net, "E close failed\n");
	    print_error (errno);
	    goto error_exit;
	}
	stdout_pipe[1] = -1;

	if (close (stderr_pipe[1]) < 0)
	{
	    buf_output0 (buf_to_net, "E close failed\n");
	    print_error (errno);
	    goto error_exit;
	}
	stderr_pipe[1] = -1;

	if (close (protocol_pipe[1]) < 0)
	{
	    buf_output0 (buf_to_net, "E close failed\n");
	    print_error (errno);
	    goto error_exit;
	}
	protocol_pipe[1] = -1;

#ifdef SERVER_FLOWCONTROL
	if (close (flowcontrol_pipe[0]) < 0)
	{
	    buf_output0 (buf_to_net, "E close failed\n");
	    print_error (errno);
	    goto error_exit;
	}
	flowcontrol_pipe[0] = -1;
#endif /* SERVER_FLOWCONTROL */

	if (close (dev_null_fd) < 0)
	{
	    buf_output0 (buf_to_net, "E close failed\n");
	    print_error (errno);
	    goto error_exit;
	}
	dev_null_fd = -1;

	while (stdout_pipe[0] >= 0
	       || stderr_pipe[0] >= 0
	       || protocol_pipe[0] >= 0
	       || count_needed <= 0)
	{
	    fd_set readfds;
	    fd_set writefds;
	    int numfds;
	    struct timeval *timeout_ptr;
	    struct timeval timeout;
#ifdef SERVER_FLOWCONTROL
	    int bufmemsize;

	    /*
	     * See if we are swamping the remote client and filling our VM.
	     * Tell child to hold off if we do.
	     */
	    bufmemsize = buf_count_mem (buf_to_net);
	    if (!have_flowcontrolled && (bufmemsize > SERVER_HI_WATER))
	    {
		if (write(flowcontrol_pipe[1], "S", 1) == 1)
		    have_flowcontrolled = 1;
	    }
	    else if (have_flowcontrolled && (bufmemsize < SERVER_LO_WATER))
	    {
		if (write(flowcontrol_pipe[1], "G", 1) == 1)
		    have_flowcontrolled = 0;
	    }
#endif /* SERVER_FLOWCONTROL */

	    FD_ZERO (&readfds);
	    FD_ZERO (&writefds);

	    if (count_needed <= 0)
	    {
		/* there is data pending which was read from the protocol pipe
		 * so don't block if we don't find any data
		 */
		timeout.tv_sec = 0;
		timeout.tv_usec = 0;
		timeout_ptr = &timeout;
	    }
	    else
	    {
		/* block indefinately */
		timeout_ptr = NULL;
	    }

	    if (! buf_empty_p (buf_to_net))
		FD_SET (STDOUT_FILENO, &writefds);

	    if (stdout_pipe[0] >= 0)
	    {
		FD_SET (stdout_pipe[0], &readfds);
	    }
	    if (stderr_pipe[0] >= 0)
	    {
		FD_SET (stderr_pipe[0], &readfds);
	    }
	    if (protocol_pipe[0] >= 0)
	    {
		FD_SET (protocol_pipe[0], &readfds);
	    }

	    /* This process of selecting on the three pipes means that
	     we might not get output in the same order in which it
	     was written, thus producing the well-known
	     "out-of-order" bug.  If the child process uses
	     cvs_output and cvs_outerr, it will send everything on
	     the protocol_pipe and avoid this problem, so the
	     solution is to use cvs_output and cvs_outerr in the
	     child process.  */
	    do {
		/* This used to select on exceptions too, but as far
		   as I know there was never any reason to do that and
		   SCO doesn't let you select on exceptions on pipes.  */
		numfds = select (num_to_check, &readfds, &writefds,
				 NULL, timeout_ptr);
		if (numfds < 0
			&& errno != EINTR)
		{
		    buf_output0 (buf_to_net, "E select failed\n");
		    print_error (errno);
		    goto error_exit;
		}
	    } while (numfds < 0);

	    if (numfds == 0)
	    {
		FD_ZERO (&readfds);
		FD_ZERO (&writefds);
	    }

	    if (FD_ISSET (STDOUT_FILENO, &writefds))
	    {
		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);
	    }

	    if (protocol_pipe[0] >= 0
		&& (FD_ISSET (protocol_pipe[0], &readfds)))
	    {
		int status;
		size_t count_read;

		status = buf_input_data (protocol_inbuf, &count_read);

		if (status == -1)
		{
		    close (protocol_pipe[0]);
		    protocol_pipe[0] = -1;
		}
		else if (status > 0)
		{
		    buf_output0 (buf_to_net, "E buf_input_data failed\n");
		    print_error (status);
		    goto error_exit;
		}

		/*
		 * We only call buf_copy_counted if we have read
		 * enough bytes to make it worthwhile.  This saves us
		 * from continually recounting the amount of data we
		 * have.
		 */
		count_needed -= count_read;
	    }
	    /* this is still part of the protocol pipe procedure, but it is
	     * outside the above conditional so that unprocessed data can be
	     * left in the buffer and stderr/stdout can be read when a flush
	     * signal is received and control can return here without passing
	     * through the select code and maybe blocking
	     */
	    while (count_needed <= 0)
	    {
		int special = 0;

		count_needed = buf_copy_counted (buf_to_net,
						     protocol_inbuf,
						     &special);

		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);

		/* If SPECIAL got set to <0, it means that the child
		 * wants us to flush the pipe & maybe stderr or stdout.
		 *
		 * After that we break to read stderr & stdout again before
		 * going back to the protocol pipe
		 *
		 * Upon breaking, count_needed = 0, so the next pass will only
		 * perform a non-blocking select before returning here to finish
		 * processing data we already read from the protocol buffer
		 */
		 if (special == -1)
		 {
		     cvs_flushout();
		     break;
		 }
		if (special == -2)
		{
		    /* If the client supports the 'F' command, we send it. */
		    if (supported_response ("F"))
		    {
			buf_append_char (buf_to_net, 'F');
			buf_append_char (buf_to_net, '\n');
		    }
		    cvs_flusherr ();
		    break;
		}
	    }

	    if (stdout_pipe[0] >= 0
		&& (FD_ISSET (stdout_pipe[0], &readfds)))
	    {
		int status;

		status = buf_input_data (stdoutbuf, NULL);

		buf_copy_lines (buf_to_net, stdoutbuf, 'M');

		if (status == -1)
		{
		    close (stdout_pipe[0]);
		    stdout_pipe[0] = -1;
		}
		else if (status > 0)
		{
		    buf_output0 (buf_to_net, "E buf_input_data failed\n");
		    print_error (status);
		    goto error_exit;
		}

		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);
	    }

	    if (stderr_pipe[0] >= 0
		&& (FD_ISSET (stderr_pipe[0], &readfds)))
	    {
		int status;

		status = buf_input_data (stderrbuf, NULL);

		buf_copy_lines (buf_to_net, stderrbuf, 'E');

		if (status == -1)
		{
		    close (stderr_pipe[0]);
		    stderr_pipe[0] = -1;
		}
		else if (status > 0)
		{
		    buf_output0 (buf_to_net, "E buf_input_data failed\n");
		    print_error (status);
		    goto error_exit;
		}

		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);
	    }
	}

	/*
	 * OK, we've gotten EOF on all the pipes.  If there is
	 * anything left on stdoutbuf or stderrbuf (this could only
	 * happen if there was no trailing newline), send it over.
	 */
	if (! buf_empty_p (stdoutbuf))
	{
	    buf_append_char (stdoutbuf, '\n');
	    buf_copy_lines (buf_to_net, stdoutbuf, 'M');
	}
	if (! buf_empty_p (stderrbuf))
	{
	    buf_append_char (stderrbuf, '\n');
	    buf_copy_lines (buf_to_net, stderrbuf, 'E');
	}
	if (! buf_empty_p (protocol_inbuf))
	    buf_output0 (buf_to_net,
			 "E Protocol error: uncounted data discarded\n");

#ifdef SERVER_FLOWCONTROL
	close (flowcontrol_pipe[1]);
	flowcontrol_pipe[1] = -1;
#endif /* SERVER_FLOWCONTROL */

	errs = 0;

	while (command_pid > 0)
	{
	    int status;
	    pid_t waited_pid;
	    waited_pid = waitpid (command_pid, &status, 0);
	    if (waited_pid < 0)
	    {
		/*
		 * Intentionally ignoring EINTR.  Other errors
		 * "can't happen".
		 */
		continue;
	    }

	    if (WIFEXITED (status))
		errs += WEXITSTATUS (status);
	    else
	    {
		int sig = WTERMSIG (status);
		char buf[50];
		/*
		 * This is really evil, because signals might be numbered
		 * differently on the two systems.  We should be using
		 * signal names (either of the "Terminated" or the "SIGTERM"
		 * variety).  But cvs doesn't currently use libiberty...we
		 * could roll our own....  FIXME.
		 */
		buf_output0 (buf_to_net, "E Terminated with fatal signal ");
		sprintf (buf, "%d\n", sig);
		buf_output0 (buf_to_net, buf);

		/* Test for a core dump.  */
		if (WCOREDUMP (status))
		{
		    buf_output0 (buf_to_net, "E Core dumped; preserving ");
		    buf_output0 (buf_to_net, orig_server_temp_dir);
		    buf_output0 (buf_to_net, " on server.\n\
E CVS locks may need cleaning up.\n");
		    dont_delete_temp = 1;
		}
		++errs;
	    }
	    if (waited_pid == command_pid)
		command_pid = -1;
	}

	/*
	 * OK, we've waited for the child.  By now all CVS locks are free
	 * and it's OK to block on the network.
	 */
	set_block (buf_to_net);
	buf_flush (buf_to_net, 1);
	buf_shutdown (protocol_inbuf);
	buf_free (protocol_inbuf);
	protocol_inbuf = NULL;
	buf_shutdown (stderrbuf);
	buf_free (stderrbuf);
	stderrbuf = NULL;
	buf_shutdown (stdoutbuf);
	buf_free (stdoutbuf);
	stdoutbuf = NULL;
    }

    if (errs)
	/* We will have printed an error message already.  */
	buf_output0 (buf_to_net, "error  \n");
    else
	buf_output0 (buf_to_net, "ok\n");
    goto free_args_and_return;

 error_exit:
    if (command_pid > 0)
	kill (command_pid, SIGTERM);

    while (command_pid > 0)
    {
	pid_t waited_pid;
	waited_pid = waitpid (command_pid, (int *) 0, 0);
	if (waited_pid < 0 && errno == EINTR)
	    continue;
	if (waited_pid == command_pid)
	    command_pid = -1;
    }

    close (dev_null_fd);
    close (protocol_pipe[0]);
    close (protocol_pipe[1]);
    close (stderr_pipe[0]);
    close (stderr_pipe[1]);
    close (stdout_pipe[0]);
    close (stdout_pipe[1]);
#ifdef SERVER_FLOWCONTROL
    close (flowcontrol_pipe[0]);
    close (flowcontrol_pipe[1]);
#endif /* SERVER_FLOWCONTROL */

 free_args_and_return:
    /* Now free the arguments.  */
    {
	/* argument_vector[0] is a dummy argument, we don't mess with it.  */
	char **cp;
	for (cp = argument_vector + 1;
	     cp < argument_vector + argument_count;
	     ++cp)
	    free (*cp);

	argument_count = 1;
    }

    /* Flush out any data not yet sent.  */
    set_block (buf_to_net);
    buf_flush (buf_to_net, 1);

    return;
}



#ifdef SERVER_FLOWCONTROL
/*
 * Called by the child at convenient points in the server's execution for
 * the server child to block.. ie: when it has no locks active.
 */
void
server_pause_check(void)
{
    int paused = 0;
    char buf[1];

    while (read (flowcontrol_pipe[0], buf, 1) == 1)
    {
	if (*buf == 'S')	/* Stop */
	    paused = 1;
	else if (*buf == 'G')	/* Go */
	    paused = 0;
	else
	    return;		/* ??? */
    }
    while (paused) {
	int numfds, numtocheck;
	fd_set fds;

	FD_ZERO (&fds);
	FD_SET (flowcontrol_pipe[0], &fds);
	numtocheck = flowcontrol_pipe[0] + 1;

	do {
	    numfds = select (numtocheck, &fds, NULL, NULL, NULL);
	    if (numfds < 0
		&& errno != EINTR)
	    {
		buf_output0 (buf_to_net, "E select failed\n");
		print_error (errno);
		return;
	    }
	} while (numfds < 0);

	if (FD_ISSET (flowcontrol_pipe[0], &fds))
	{
	    int got;

	    while ((got = read (flowcontrol_pipe[0], buf, 1)) == 1)
	    {
		if (*buf == 'S')	/* Stop */
		    paused = 1;
		else if (*buf == 'G')	/* Go */
		    paused = 0;
		else
		    return;		/* ??? */
	    }

	    /* This assumes that we are using BSD or POSIX nonblocking
	       I/O.  System V nonblocking I/O returns zero if there is
	       nothing to read.  */
	    if (got == 0)
		error (1, 0, "flow control EOF");
	    if (got < 0 && ! blocking_error (errno))
	    {
		error (1, errno, "flow control read failed");
	    }
	}
    }
}
#endif /* SERVER_FLOWCONTROL */



/* This variable commented in server.h.  */
char *server_dir = NULL;



static void
output_dir (const char *update_dir, const char *repository)
{
    /* Set up SHORT_REPOS.  */
    const char *short_repos = Short_Repository (repository);

    /* Send the update_dir/repos.  */
    if (server_dir != NULL)
    {
	buf_output0 (protocol, server_dir);
	buf_output0 (protocol, "/");
    }
    if (update_dir[0] == '\0')
	buf_output0 (protocol, ".");
    else
	buf_output0 (protocol, update_dir);
    buf_output0 (protocol, "/\n");
    if (short_repos[0] == '\0')
	buf_output0 (protocol, ".");
    else
	buf_output0 (protocol, short_repos);
    buf_output0 (protocol, "/");
}



/*
 * Entries line that we are squirreling away to send to the client when
 * we are ready.
 */
static char *entries_line;

/*
 * File which has been Scratch_File'd, we are squirreling away that fact
 * to inform the client when we are ready.
 */
static char *scratched_file;

/*
 * The scratched_file will need to be removed as well as having its entry
 * removed.
 */
static int kill_scratched_file;



void
server_register (const char *name, const char *version, const char *timestamp,
                 const char *options, const char *tag, const char *date,
                 const char *conflict)
{
    int len;

    if (options == NULL)
	options = "";

    TRACE ( 1, "server_register(%s, %s, %s, %s, %s, %s, %s)",
	    name, version, timestamp ? timestamp : "", options,
	    tag ? tag : "", date ? date : "",
	    conflict ? conflict : "" );

    if (entries_line != NULL)
    {
	/*
	 * If CVS decides to Register it more than once (which happens
	 * on "cvs update foo/foo.c" where foo and foo.c are already
	 * checked out), use the last of the entries lines Register'd.
	 */
	free (entries_line);
    }

    /*
     * I have reports of Scratch_Entry and Register both happening, in
     * two different cases.  Using the last one which happens is almost
     * surely correct; I haven't tracked down why they both happen (or
     * even verified that they are for the same file).
     */
    if (scratched_file != NULL)
    {
	free (scratched_file);
	scratched_file = NULL;
    }

    len = (strlen (name) + strlen (version) + strlen (options) + 80);
    if (tag)
	len += strlen (tag);
    if (date)
	len += strlen (date);

    entries_line = xmalloc (len);
    sprintf (entries_line, "/%s/%s/", name, version);
    if (conflict != NULL)
    {
	strcat (entries_line, "+=");
    }
    strcat (entries_line, "/");
    strcat (entries_line, options);
    strcat (entries_line, "/");
    if (tag != NULL)
    {
	strcat (entries_line, "T");
	strcat (entries_line, tag);
    }
    else if (date != NULL)
    {
	strcat (entries_line, "D");
	strcat (entries_line, date);
    }
}



void
server_scratch (const char *fname)
{
    /*
     * I have reports of Scratch_Entry and Register both happening, in
     * two different cases.  Using the last one which happens is almost
     * surely correct; I haven't tracked down why they both happen (or
     * even verified that they are for the same file).
     *
     * Don't know if this is what whoever wrote the above comment was
     * talking about, but this can happen in the case where a join
     * removes a file - the call to Register puts the '-vers' into the
     * Entries file after the file is removed
     */
    if (entries_line != NULL)
    {
	free (entries_line);
	entries_line = NULL;
    }

    if (scratched_file != NULL)
    {
	buf_output0 (protocol,
		     "E CVS server internal error: duplicate Scratch_Entry\n");
	buf_send_counted (protocol);
	return;
    }
    scratched_file = xstrdup (fname);
    kill_scratched_file = 1;
}

void
server_scratch_entry_only (void)
{
    kill_scratched_file = 0;
}

/* Print a new entries line, from a previous server_register.  */
static void
new_entries_line (void)
{
    if (entries_line)
    {
	buf_output0 (protocol, entries_line);
	buf_output (protocol, "\n", 1);
    }
    else
	/* Return the error message as the Entries line.  */
	buf_output0 (protocol,
		     "CVS server internal error: Register missing\n");
    free (entries_line);
    entries_line = NULL;
}



static void
serve_ci (char *arg)
{
    do_cvs_command ("commit", commit);
}



static void
checked_in_response (const char *file, const char *update_dir,
                     const char *repository)
{
    if (supported_response ("Mode"))
    {
	struct stat sb;
	char *mode_string;

	if ( CVS_STAT (file, &sb) < 0)
	{
	    /* Not clear to me why the file would fail to exist, but it
	       was happening somewhere in the testsuite.  */
	    if (!existence_error (errno))
		error (0, errno, "cannot stat %s", file);
	}
	else
	{
	    buf_output0 (protocol, "Mode ");
	    mode_string = mode_to_string (sb.st_mode);
	    buf_output0 (protocol, mode_string);
	    buf_output0 (protocol, "\n");
	    free (mode_string);
	}
    }

    buf_output0 (protocol, "Checked-in ");
    output_dir (update_dir, repository);
    buf_output0 (protocol, file);
    buf_output (protocol, "\n", 1);
    new_entries_line ();
}

void
server_checked_in (const char *file, const char *update_dir,
                   const char *repository)
{
    if (noexec)
	return;
    if (scratched_file != NULL && entries_line == NULL)
    {
	/*
	 * This happens if we are now doing a "cvs remove" after a previous
	 * "cvs add" (without a "cvs ci" in between).
	 */
	buf_output0 (protocol, "Remove-entry ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, file);
	buf_output (protocol, "\n", 1);
	free (scratched_file);
	scratched_file = NULL;
    }
    else
    {
	checked_in_response (file, update_dir, repository);
    }
    buf_send_counted (protocol);
}

void
server_update_entries (const char *file, const char *update_dir,
                       const char *repository,
                       enum server_updated_arg4 updated)
{
    if (noexec)
	return;
    if (updated == SERVER_UPDATED)
	checked_in_response (file, update_dir, repository);
    else
    {
	if (!supported_response ("New-entry"))
	    return;
	buf_output0 (protocol, "New-entry ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, file);
	buf_output (protocol, "\n", 1);
	new_entries_line ();
    }

    buf_send_counted (protocol);
}

static void
serve_update (char *arg)
{
    do_cvs_command ("update", update);
}

static void
serve_diff (char *arg)
{
    do_cvs_command ("diff", diff);
}

static void
serve_log (char *arg)
{
    do_cvs_command ("log", cvslog);
}

static void
serve_rlog (char *arg)
{
    do_cvs_command ("rlog", cvslog);
}

static void
serve_ls (char *arg)
{
  do_cvs_command ("ls", ls);
}

static void
serve_rls (char *arg)
{
  do_cvs_command ("rls", ls);
}

static void
serve_add (char *arg)
{
    do_cvs_command ("add", add);
}

static void
serve_remove (char *arg)
{
    do_cvs_command ("remove", cvsremove);
}

static void
serve_status (char *arg)
{
    do_cvs_command ("status", cvsstatus);
}

static void
serve_rdiff (char *arg)
{
    do_cvs_command ("rdiff", patch);
}

static void
serve_tag (char *arg)
{
    do_cvs_command ("tag", cvstag);
}

static void
serve_rtag (char *arg)
{
    do_cvs_command ("rtag", cvstag);
}

static void
serve_import (char *arg)
{
    do_cvs_command ("import", import);
}

static void
serve_admin (char *arg)
{
    do_cvs_command ("admin", admin);
}

static void
serve_history (char *arg)
{
    do_cvs_command ("history", history);
}

static void
serve_release (char *arg)
{
    do_cvs_command ("release", release);
}



static void
serve_watch_on (char *arg)
{
    do_cvs_command ("watch", watch_on);
}

static void
serve_watch_off (char *arg)
{
    do_cvs_command ("watch", watch_off);
}

static void
serve_watch_add (char *arg)
{
    do_cvs_command ("watch", watch_add);
}

static void
serve_watch_remove (char *arg)
{
    do_cvs_command ("watch", watch_remove);
}

static void
serve_watchers (char *arg)
{
    do_cvs_command ("watchers", watchers);
}

static void
serve_editors (char *arg)
{
    do_cvs_command ("editors", editors);
}

static void
serve_edit (char *arg)
{
    do_cvs_command ("edit", edit);
}



#ifdef PROXY_SUPPORT
/* We need to handle some of this before reprocessing since it is defined to
 * send a response and print errors before a Root request is received.
 */
#endif /* PROXY_SUPPORT */
static void
serve_noop (char *arg)
{
    /* Errors could be encountered in the first or second passes, so always
     * send them to the client.
     */
    bool pe = print_pending_error();

#ifdef PROXY_SUPPORT
    /* The portions below need not be handled until reprocessing anyhow since
     * there should be no entries or notifications prior to that.  */
    if (!proxy_log)
#endif /* PROXY_SUPPORT */
    {
	server_write_entries ();
	if (!pe)
	    (void) server_notify ();
    }

    if (!pe
#ifdef PROXY_SUPPORT
        /* "ok" only goes across in the first pass.  */
        && !reprocessing
#endif /* PROXY_SUPPORT */
       )
	buf_output0 (buf_to_net, "ok\n");
    buf_flush (buf_to_net, 1);
}



static void
serve_version (char *arg)
{
    do_cvs_command ("version", version);
}

static void
serve_init (char *arg)
{
    cvsroot_t *saved_parsed_root;

    if (!isabsolute (arg))
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E init %s must be an absolute pathname", arg);
    }
#ifdef AUTH_SERVER_SUPPORT
    else if (Pserver_Repos != NULL)
    {
	if (strcmp (Pserver_Repos, arg) != 0)
	{
	    if (alloc_pending (80 + strlen (Pserver_Repos) + strlen (arg)))
		/* The explicitness is to aid people who are writing clients.
		   I don't see how this information could help an
		   attacker.  */
		sprintf (pending_error_text, "\
E Protocol error: init says \"%s\" but pserver says \"%s\"",
			 arg, Pserver_Repos);
	}
    }
#endif

    if (print_pending_error ())
	return;

    saved_parsed_root = current_parsed_root;
    current_parsed_root = local_cvsroot (arg);

    do_cvs_command ("init", init);
    free_cvsroot_t (current_parsed_root);
    current_parsed_root = saved_parsed_root;
}

static void
serve_annotate (char *arg)
{
    do_cvs_command ("annotate", annotate);
}

static void
serve_rannotate (char *arg)
{
    do_cvs_command ("rannotate", annotate);
}

static void
serve_co (char *arg)
{
    char *tempdir;
    int status;

    if (print_pending_error ())
	return;

#ifdef PROXY_SUPPORT
    /* If we are not a secondary server, the write proxy log will already have
     * been processed.
     */
    if (isProxyServer ())
    {
	if (reprocessing)
	    reprocessing = false;
	else if (/* The proxy log may be closed if the client sent a
		  * `Command-prep' request.
		  */
		 proxy_log)
	{
	    /* Set up the log for reprocessing.  */
	    rewind_buf_from_net ();
	    /* And return to the main loop in server(), where we will now find
	     * the logged secondary data and reread it.
	     */
	    return;
	}
    }
#endif /* PROXY_SUPPORT */

    if (!isdir (CVSADM))
    {
	/*
	 * The client has not sent a "Repository" line.  Check out
	 * into a pristine directory.
	 */
	tempdir = xmalloc (strlen (server_temp_dir) + 80);
	if (tempdir == NULL)
	{
	    buf_output0 (buf_to_net, "E Out of memory\n");
	    return;
	}
	strcpy (tempdir, server_temp_dir);
	strcat (tempdir, "/checkout-dir");
	status = mkdir_p (tempdir);
	if (status != 0 && status != EEXIST)
	{
	    buf_output0 (buf_to_net, "E Cannot create ");
	    buf_output0 (buf_to_net, tempdir);
	    buf_append_char (buf_to_net, '\n');
	    print_error (errno);
	    free (tempdir);
	    return;
	}

	if (CVS_CHDIR (tempdir) < 0)
	{
	    buf_output0 (buf_to_net, "E Cannot change to directory ");
	    buf_output0 (buf_to_net, tempdir);
	    buf_append_char (buf_to_net, '\n');
	    print_error (errno);
	    free (tempdir);
	    return;
	}
	free (tempdir);
    }

    /* Compensate for server_export()'s setting of cvs_cmd_name.
     *
     * [It probably doesn't matter if do_cvs_command() gets "export"
     *  or "checkout", but we ought to be accurate where possible.]
     */
    do_cvs_command ((strcmp (cvs_cmd_name, "export") == 0) ?
		    "export" : "checkout",
		    checkout);
}

static void
serve_export (char *arg)
{
    /* Tell checkout() to behave like export not checkout.  */
    cvs_cmd_name = "export";
    serve_co (arg);
}



void
server_copy_file (const char *file, const char *update_dir,
                  const char *repository, const char *newfile)
{
    /* At least for now, our practice is to have the server enforce
       noexec for the repository and the client enforce it for the
       working directory.  This might want more thought, and/or
       documentation in cvsclient.texi (other responses do it
       differently).  */

    if (!supported_response ("Copy-file"))
	return;
    buf_output0 (protocol, "Copy-file ");
    output_dir (update_dir, repository);
    buf_output0 (protocol, file);
    buf_output0 (protocol, "\n");
    buf_output0 (protocol, newfile);
    buf_output0 (protocol, "\n");
}

/* See server.h for description.  */

void
server_modtime (struct file_info *finfo, Vers_TS *vers_ts)
{
    char date[MAXDATELEN];
    char outdate[MAXDATELEN];

    assert (vers_ts->vn_rcs != NULL);

    if (!supported_response ("Mod-time"))
	return;

    if (RCS_getrevtime (finfo->rcs, vers_ts->vn_rcs, date, 0) == (time_t) -1)
	/* FIXME? should we be printing some kind of warning?  For one
	   thing I'm not 100% sure whether this happens in non-error
	   circumstances.  */
	return;
    date_to_internet (outdate, date);
    buf_output0 (protocol, "Mod-time ");
    buf_output0 (protocol, outdate);
    buf_output0 (protocol, "\n");
}



/* See server.h for description.  */
void
server_updated (
    struct file_info *finfo,
    Vers_TS *vers,
    enum server_updated_arg4 updated,
    mode_t mode,
    unsigned char *checksum,
    struct buffer *filebuf)
{
    if (noexec)
    {
	/* Hmm, maybe if we did the same thing for entries_file, we
	   could get rid of the kludges in server_register and
	   server_scratch which refrain from warning if both
	   Scratch_Entry and Register get called.  Maybe.  */
	if (scratched_file)
	{
	    free (scratched_file);
	    scratched_file = NULL;
	}
	buf_send_counted (protocol);
	return;
    }

    if (entries_line != NULL && scratched_file == NULL)
    {
	FILE *f;
	struct buffer_data *list, *last;
	unsigned long size;
	char size_text[80];

	/* The contents of the file will be in one of filebuf,
	   list/last, or here.  */
	unsigned char *file;
	size_t file_allocated;
	size_t file_used;

	if (filebuf != NULL)
	{
	    size = buf_length (filebuf);
	    if (mode == (mode_t) -1)
		error (1, 0, "\
CVS server internal error: no mode in server_updated");
	}
	else
	{
	    struct stat sb;

	    if ( CVS_STAT (finfo->file, &sb) < 0)
	    {
		if (existence_error (errno))
		{
		    /* If we have a sticky tag for a branch on which
		       the file is dead, and cvs update the directory,
		       it gets a T_CHECKOUT but no file.  So in this
		       case just forget the whole thing.  */
		    free (entries_line);
		    entries_line = NULL;
		    goto done;
		}
		error (1, errno, "reading %s", finfo->fullname);
	    }
	    size = sb.st_size;
	    if (mode == (mode_t) -1)
	    {
		/* FIXME: When we check out files the umask of the
		   server (set in .bashrc if rsh is in use) affects
		   what mode we send, and it shouldn't.  */
		mode = sb.st_mode;
	    }
	}

	if (checksum != NULL)
	{
	    static int checksum_supported = -1;

	    if (checksum_supported == -1)
	    {
		checksum_supported = supported_response ("Checksum");
	    }

	    if (checksum_supported)
	    {
		int i;
		char buf[3];

		buf_output0 (protocol, "Checksum ");
		for (i = 0; i < 16; i++)
		{
		    sprintf (buf, "%02x", (unsigned int) checksum[i]);
		    buf_output0 (protocol, buf);
		}
		buf_append_char (protocol, '\n');
	    }
	}

	if (updated == SERVER_UPDATED)
	{
	    Node *node;
	    Entnode *entnode;

	    if (!(supported_response ("Created")
		  && supported_response ("Update-existing")))
		buf_output0 (protocol, "Updated ");
	    else
	    {
		assert (vers != NULL);
		if (vers->ts_user == NULL)
		    buf_output0 (protocol, "Created ");
		else
		    buf_output0 (protocol, "Update-existing ");
	    }

	    /* Now munge the entries to say that the file is unmodified,
	       in case we end up processing it again (e.g. modules3-6
	       in the testsuite).  */
	    node = findnode_fn (finfo->entries, finfo->file);
	    entnode = node->data;
	    free (entnode->timestamp);
	    entnode->timestamp = xstrdup ("=");
	}
	else if (updated == SERVER_MERGED)
	    buf_output0 (protocol, "Merged ");
	else if (updated == SERVER_PATCHED)
	    buf_output0 (protocol, "Patched ");
	else if (updated == SERVER_RCS_DIFF)
	    buf_output0 (protocol, "Rcs-diff ");
	else
	    abort ();
	output_dir (finfo->update_dir, finfo->repository);
	buf_output0 (protocol, finfo->file);
	buf_output (protocol, "\n", 1);

	new_entries_line ();

	{
	    char *mode_string;

	    mode_string = mode_to_string (mode);
	    buf_output0 (protocol, mode_string);
	    buf_output0 (protocol, "\n");
	    free (mode_string);
	}

	list = last = NULL;

	file = NULL;
	file_allocated = 0;
	file_used = 0;

	if (size > 0)
	{
	    /* Throughout this section we use binary mode to read the
	       file we are sending.  The client handles any line ending
	       translation if necessary.  */

	    if (file_gzip_level
		/*
		 * For really tiny files, the gzip process startup
		 * time will outweigh the compression savings.  This
		 * might be computable somehow; using 100 here is just
		 * a first approximation.
		 */
		&& size > 100)
	    {
		/* Basing this routine on read_and_gzip is not a
		   high-performance approach.  But it seems easier
		   to code than the alternative (and less
		   vulnerable to subtle bugs).  Given that this feature
		   is mainly for compatibility, that is the better
		   tradeoff.  */

		int fd;

		/* Callers must avoid passing us a buffer if
		   file_gzip_level is set.  We could handle this case,
		   but it's not worth it since this case never arises
		   with a current client and server.  */
		if (filebuf != NULL)
		    error (1, 0, "\
CVS server internal error: unhandled case in server_updated");

		fd = CVS_OPEN (finfo->file, O_RDONLY | OPEN_BINARY, 0);
		if (fd < 0)
		    error (1, errno, "reading %s", finfo->fullname);
		if (read_and_gzip (fd, finfo->fullname, &file,
				   &file_allocated, &file_used,
				   file_gzip_level))
		    error (1, 0, "aborting due to compression error");
		size = file_used;
		if (close (fd) < 0)
		    error (1, errno, "reading %s", finfo->fullname);
		/* Prepending length with "z" is flag for using gzip here.  */
		buf_output0 (protocol, "z");
	    }
	    else if (filebuf == NULL)
	    {
		long status;

		f = CVS_FOPEN (finfo->file, "rb");
		if (f == NULL)
		    error (1, errno, "reading %s", finfo->fullname);
		status = buf_read_file (f, size, &list, &last);
		if (status == -2)
		    (*protocol->memory_error) (protocol);
		else if (status != 0)
		    error (1, ferror (f) ? errno : 0, "reading %s",
			   finfo->fullname);
		if (fclose (f) == EOF)
		    error (1, errno, "reading %s", finfo->fullname);
	    }
	}

	sprintf (size_text, "%lu\n", size);
	buf_output0 (protocol, size_text);

	if (file != NULL)
	{
	    buf_output (protocol, (char *) file, file_used);
	    free (file);
	    file = NULL;
	}
	else if (filebuf == NULL)
	    buf_append_data (protocol, list, last);
	else
	    buf_append_buffer (protocol, filebuf);
	/* Note we only send a newline here if the file ended with one.  */

	/*
	 * Avoid using up too much disk space for temporary files.
	 * A file which does not exist indicates that the file is up-to-date,
	 * which is now the case.  If this is SERVER_MERGED, the file is
	 * not up-to-date, and we indicate that by leaving the file there.
	 * I'm thinking of cases like "cvs update foo/foo.c foo".
	 */
	if ((updated == SERVER_UPDATED
	     || updated == SERVER_PATCHED
	     || updated == SERVER_RCS_DIFF)
	    && filebuf == NULL
	    /* But if we are joining, we'll need the file when we call
	       join_file.  */
	    && !joining ())
	{
	    if (CVS_UNLINK (finfo->file) < 0)
		error (0, errno, "cannot remove temp file for %s",
		       finfo->fullname);
	}
    }
    else if (scratched_file != NULL && entries_line == NULL)
    {
	if (strcmp (scratched_file, finfo->file) != 0)
	    error (1, 0,
		   "CVS server internal error: `%s' vs. `%s' scratched",
		   scratched_file,
		   finfo->file);
	free (scratched_file);
	scratched_file = NULL;

	if (kill_scratched_file)
	    buf_output0 (protocol, "Removed ");
	else
	    buf_output0 (protocol, "Remove-entry ");
	output_dir (finfo->update_dir, finfo->repository);
	buf_output0 (protocol, finfo->file);
	buf_output (protocol, "\n", 1);
	/* keep the vers structure up to date in case we do a join
	 * - if there isn't a file, it can't very well have a version number, can it?
	 *
	 * we do it here on the assumption that since we just told the client
	 * to remove the file/entry, it will, and we want to remember that.
	 * If it fails, that's the client's problem, not ours
	 */
	if (vers && vers->vn_user != NULL)
	{
	    free (vers->vn_user);
	    vers->vn_user = NULL;
	}
	if (vers && vers->ts_user != NULL)
	{
	    free (vers->ts_user);
	    vers->ts_user = NULL;
	}
    }
    else if (scratched_file == NULL && entries_line == NULL)
    {
	/*
	 * This can happen with death support if we were processing
	 * a dead file in a checkout.
	 */
    }
    else
	error (1, 0,
	       "CVS server internal error: Register *and* Scratch_Entry.\n");
    buf_send_counted (protocol);
  done:;
}

/* Return whether we should send patches in RCS format.  */

int
server_use_rcs_diff (void)
{
    return supported_response ("Rcs-diff");
}



void
server_set_entstat (const char *update_dir, const char *repository)
{
    static int set_static_supported = -1;
    if (set_static_supported == -1)
	set_static_supported = supported_response ("Set-static-directory");
    if (!set_static_supported) return;

    buf_output0 (protocol, "Set-static-directory ");
    output_dir (update_dir, repository);
    buf_output0 (protocol, "\n");
    buf_send_counted (protocol);
}



void
server_clear_entstat (const char *update_dir, const char *repository)
{
    static int clear_static_supported = -1;
    if (clear_static_supported == -1)
	clear_static_supported = supported_response ("Clear-static-directory");
    if (!clear_static_supported) return;

    if (noexec)
	return;

    buf_output0 (protocol, "Clear-static-directory ");
    output_dir (update_dir, repository);
    buf_output0 (protocol, "\n");
    buf_send_counted (protocol);
}



void
server_set_sticky (const char *update_dir, const char *repository,
                   const char *tag, const char *date, int nonbranch)
{
    static int set_sticky_supported = -1;

    assert (update_dir != NULL);

    if (set_sticky_supported == -1)
	set_sticky_supported = supported_response ("Set-sticky");
    if (!set_sticky_supported) return;

    if (noexec)
	return;

    if (tag == NULL && date == NULL)
    {
	buf_output0 (protocol, "Clear-sticky ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, "\n");
    }
    else
    {
	buf_output0 (protocol, "Set-sticky ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, "\n");
	if (tag != NULL)
	{
	    if (nonbranch)
		buf_output0 (protocol, "N");
	    else
		buf_output0 (protocol, "T");
	    buf_output0 (protocol, tag);
	}
	else
	{
	    buf_output0 (protocol, "D");
	    buf_output0 (protocol, date);
	}
	buf_output0 (protocol, "\n");
    }
    buf_send_counted (protocol);
}



void
server_edit_file (struct file_info *finfo)
{
    buf_output (protocol, "Edit-file ", 10);
    output_dir (finfo->update_dir, finfo->repository);
    buf_output0 (protocol, finfo->file);
    buf_output (protocol, "\n", 1);
    buf_send_counted (protocol);
}



struct template_proc_data
{
    const char *update_dir;
    const char *repository;
};

static int
template_proc (const char *repository, const char *template, void *closure)
{
    FILE *fp;
    char buf[1024];
    size_t n;
    struct stat sb;
    struct template_proc_data *data = (struct template_proc_data *)closure;

    if (!supported_response ("Template"))
	/* Might want to warn the user that the rcsinfo feature won't work.  */
	return 0;
    buf_output0 (protocol, "Template ");
    output_dir (data->update_dir, data->repository);
    buf_output0 (protocol, "\n");

    fp = CVS_FOPEN (template, "rb");
    if (fp == NULL)
    {
	error (0, errno, "Couldn't open rcsinfo template file %s", template);
	return 1;
    }
    if (fstat (fileno (fp), &sb) < 0)
    {
	error (0, errno, "cannot stat rcsinfo template file %s", template);
	return 1;
    }
    sprintf (buf, "%ld\n", (long) sb.st_size);
    buf_output0 (protocol, buf);
    while (!feof (fp))
    {
	n = fread (buf, 1, sizeof buf, fp);
	buf_output (protocol, buf, n);
	if (ferror (fp))
	{
	    error (0, errno, "cannot read rcsinfo template file %s", template);
	    (void) fclose (fp);
	    return 1;
	}
    }
    buf_send_counted (protocol);
    if (fclose (fp) < 0)
	error (0, errno, "cannot close rcsinfo template file %s", template);
    return 0;
}



void
server_clear_template (const char *update_dir, const char *repository)
{
    assert (update_dir != NULL);

    if (noexec)
	return;

    if (!supported_response ("Clear-template") &&
	!supported_response ("Template"))
	/* Might want to warn the user that the rcsinfo feature won't work.  */
	return;

    if (supported_response ("Clear-template"))
    {
	buf_output0 (protocol, "Clear-template ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, "\n");
	buf_send_counted (protocol);
    }
    else
    {
	buf_output0 (protocol, "Template ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, "\n");
	buf_output0 (protocol, "0\n");
	buf_send_counted (protocol);
    }
}



void
server_template (const char *update_dir, const char *repository)
{
    struct template_proc_data data;
    data.update_dir = update_dir;
    data.repository = repository;
    (void) Parse_Info (CVSROOTADM_RCSINFO, repository, template_proc,
		       PIOPT_ALL, &data);
}



static void
serve_gzip_contents (char *arg)
{
    int level;

#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */

    level = atoi (arg);
    if (level == 0)
	level = 6;
    file_gzip_level = level;
}



static void
serve_gzip_stream (char *arg)
{
    int level;

    /* If we received this request before the `Root' request, the buffer index
     * maintained to allow the write proxy to replace the `Root' request would
     * be relative to the decompressed stream rather than the secondary log.
     */
    assert (current_parsed_root);

    level = atoi (arg);
    if (level == 0)
	level = 6;

    /* All further communication with the client will be compressed.  */

    /* This needs to be processed in both passes so that we may continue to
     * understand client requests on both the socket and from the log.
     */
    buf_from_net = compress_buffer_initialize (buf_from_net, 1, level,
					       buf_from_net->memory_error);

    /* This needs to be skipped in subsequent passes to avoid compressing data
     * to the client twice.
     */
#ifdef PROXY_SUPPORT
    if (reprocessing) return;
#endif /* PROXY_SUPPORT */
    buf_to_net = compress_buffer_initialize (buf_to_net, 0, level,
					     buf_to_net->memory_error);
}



/* Tell the client about RCS options set in CVSROOT/cvswrappers. */
static void
serve_wrapper_sendme_rcs_options (char *arg)
{
    /* Actually, this is kind of sdrawkcab-ssa: the client wants
     * verbatim lines from a cvswrappers file, but the server has
     * already parsed the cvswrappers file into the wrap_list struct.
     * Therefore, the server loops over wrap_list, unparsing each
     * entry before sending it.
     */
    char *wrapper_line = NULL;

#ifdef PROXY_SUPPORT
    if (reprocessing) return;
#endif /* PROXY_SUPPORT */

    wrap_setup ();

    for (wrap_unparse_rcs_options (&wrapper_line, 1);
	 wrapper_line;
	 wrap_unparse_rcs_options (&wrapper_line, 0))
    {
	buf_output0 (buf_to_net, "Wrapper-rcsOption ");
	buf_output0 (buf_to_net, wrapper_line);
	buf_output0 (buf_to_net, "\012");;
	free (wrapper_line);
    }

    buf_output0 (buf_to_net, "ok\012");

    /* The client is waiting for us, so we better send the data now.  */
    buf_flush (buf_to_net, 1);
}



static void
serve_ignore (char *arg)
{
    /*
     * Just ignore this command.  This is used to support the
     * update-patches command, which is not a real command, but a signal
     * to the client that update will accept the -u argument.
     */
#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */
}



static int
expand_proc (int argc, char **argv, char *where, char *mwhere, char *mfile, int shorten, int local_specified, char *omodule, char *msg)
{
    int i;
    char *dir = argv[0];

    /* If mwhere has been specified, the thing we're expanding is a
       module -- just return its name so the client will ask for the
       right thing later.  If it is an alias or a real directory,
       mwhere will not be set, so send out the appropriate
       expansion. */

    if (mwhere != NULL)
    {
	buf_output0 (buf_to_net, "Module-expansion ");
	if (server_dir != NULL)
	{
	    buf_output0 (buf_to_net, server_dir);
	    buf_output0 (buf_to_net, "/");
	}
	buf_output0 (buf_to_net, mwhere);
	if (mfile != NULL)
	{
	    buf_append_char (buf_to_net, '/');
	    buf_output0 (buf_to_net, mfile);
	}
	buf_append_char (buf_to_net, '\n');
    }
    else
    {
	/* We may not need to do this anymore -- check the definition
	   of aliases before removing */
	if (argc == 1)
	{
	    buf_output0 (buf_to_net, "Module-expansion ");
	    if (server_dir != NULL)
	    {
		buf_output0 (buf_to_net, server_dir);
		buf_output0 (buf_to_net, "/");
	    }
	    buf_output0 (buf_to_net, dir);
	    buf_append_char (buf_to_net, '\n');
	}
	else
	{
	    for (i = 1; i < argc; ++i)
	    {
		buf_output0 (buf_to_net, "Module-expansion ");
		if (server_dir != NULL)
		{
		    buf_output0 (buf_to_net, server_dir);
		    buf_output0 (buf_to_net, "/");
		}
		buf_output0 (buf_to_net, dir);
		buf_append_char (buf_to_net, '/');
		buf_output0 (buf_to_net, argv[i]);
		buf_append_char (buf_to_net, '\n');
	    }
	}
    }
    return 0;
}

static void
serve_expand_modules (char *arg)
{
    int i;
    int err = 0;
    DBM *db;

#ifdef PROXY_SUPPORT
    /* This needs to be processed in the first pass since the client expects a
     * response but we may not yet know if we are a secondary.
     *
     * On the second pass, we still must make sure to ignore the arguments.
     */
    if (!reprocessing)
#endif /* PROXY_SUPPORT */
    {
	err = 0;

	db = open_module ();
	for (i = 1; i < argument_count; i++)
	    err += do_module (db, argument_vector[i],
			      CHECKOUT, "Updating", expand_proc,
			      NULL, 0, 0, 0, 0,
			      (char *) NULL);
	close_module (db);
    }

    {
	/* argument_vector[0] is a dummy argument, we don't mess with it.  */
	char **cp;
	for (cp = argument_vector + 1;
	     cp < argument_vector + argument_count;
	     ++cp)
	    free (*cp);

	argument_count = 1;
    }

#ifdef PROXY_SUPPORT
    if (!reprocessing)
#endif /* PROXY_SUPPORT */
    {
	if (err)
	    /* We will have printed an error message already.  */
	    buf_output0 (buf_to_net, "error  \n");
	else
	    buf_output0 (buf_to_net, "ok\n");

	/* The client is waiting for the module expansions, so we must
	   send the output now.  */
	buf_flush (buf_to_net, 1);
    }
}



/* Decide if we should redirect the client to another server.
 *
 * GLOBALS
 *   config->PrimaryServer	The server to redirect write requests to, if
 *				any.
 *
 * ASSUMPTIONS
 *   The `Root' request has already been processed.
 *
 * RETURNS
 *   Nothing.
 */
static void
serve_command_prep (char *arg)
{
    bool redirect_supported;
#ifdef PROXY_SUPPORT
    bool ditch_log;
#endif /* PROXY_SUPPORT */

    if (error_pending ()) return;

    redirect_supported = supported_response ("Redirect");
    if (redirect_supported
	&& lookup_command_attribute (arg) & CVS_CMD_MODIFIES_REPOSITORY
	/* I call isProxyServer() last because it can probably be the slowest
	 * call due to the call to gethostbyname().
	 */
	&& isProxyServer ())
    {
	/* Before sending a redirect, send a "Referrer" line to the client,
	 * if possible, to give admins more control over canonicalizing roots
	 * sent from the client.
	 */
	if (supported_response ("Referrer"))
	{
	    /* assume :ext:, since that is all we currently support for
	     * proxies and redirection.
	     */
	    char *referrer = Xasprintf (":ext:%s@@%s%s", getcaller(),
					server_hostname,
					current_parsed_root->directory);

	    buf_output0 (buf_to_net, "Referrer ");
	    buf_output0 (buf_to_net, referrer);
	    buf_output0 (buf_to_net, "\n");

	    free (referrer);
	}

	/* Send `Redirect' to redirect client requests to the primary.  */
	buf_output0 (buf_to_net, "Redirect ");
	buf_output0 (buf_to_net, config->PrimaryServer->original);
	buf_output0 (buf_to_net, "\n");
	buf_flush (buf_to_net, 1);
#ifdef PROXY_SUPPORT
	ditch_log = true;
#endif /* PROXY_SUPPORT */
    }
    else
    {
	/* Send `ok' so the client can proceed.  */
	buf_output0 (buf_to_net, "ok\n");
	buf_flush (buf_to_net, 1);
#ifdef PROXY_SUPPORT
	if (lookup_command_attribute (arg) & CVS_CMD_MODIFIES_REPOSITORY
            && isProxyServer ())
	    /* Don't ditch the log for write commands on a proxy server.  We
	     * we got here because the `Redirect' response was not supported.
	     */
	    ditch_log = false;
	else
	    ditch_log = true;
#endif /* PROXY_SUPPORT */
    }
#ifdef PROXY_SUPPORT
    if (proxy_log && ditch_log)
    {
	/* If the client supported the redirect response, then they will always
	 * be redirected if they are preparing for a write request.  It is
	 * therefore safe to close the proxy logs.
	 *
	 * If the client is broken and ignores the redirect, this will be
	 * detected later, in rewind_buf_from_net().
	 *
	 * Since a `Command-prep' response is only acceptable immediately
	 * following the `Root' request according to the specification, there
	 * is no need to rewind the log and reprocess.
	 */
	log_buffer_closelog (proxy_log);
	log_buffer_closelog (proxy_log_out);
	proxy_log = NULL;
    }
#endif /* PROXY_SUPPORT */
}



/* Save a referrer, potentially for passing to hook scripts later.
 *
 * GLOBALS
 *   referrer	Where we save the parsed referrer.
 *
 * ASSUMPTIONS
 *   The `Root' request has already been processed.
 *   There is no need to dispose of REFERRER if it is set.  It's memory is
 *   tracked by parse_root().
 *
 * RETURNS
 *   Nothing.
 */
static void
serve_referrer (char *arg)
{
    if (error_pending ()) return;

    referrer = parse_cvsroot (arg);

    if (!referrer
	&& alloc_pending (80 + strlen (arg)))
	sprintf (pending_error_text,
		 "E Protocol error: Invalid Referrer: `%s'",
		 arg);
}



static void serve_valid_requests (char *arg);

#endif /* SERVER_SUPPORT */
/*
 * Comment to move position of the following #if line which works
 * around an apparent bug in Microsoft Visual C++ 6.0 compiler.
 */
#if defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT)
/*
 * Parts of this table are shared with the client code,
 * but the client doesn't need to know about the handler
 * functions.
 */

struct request requests[] =
{
#ifdef SERVER_SUPPORT
#define REQ_LINE(n, f, s) {n, f, s}
#else
#define REQ_LINE(n, f, s) {n, s}
#endif

  REQ_LINE("Root", serve_root, RQ_ESSENTIAL | RQ_ROOTLESS),
  REQ_LINE("Valid-responses", serve_valid_responses,
	   RQ_ESSENTIAL | RQ_ROOTLESS),
  REQ_LINE("valid-requests", serve_valid_requests,
	   RQ_ESSENTIAL | RQ_ROOTLESS),
  REQ_LINE("Command-prep", serve_command_prep, 0),
  REQ_LINE("Referrer", serve_referrer, 0),
  REQ_LINE("Repository", serve_repository, 0),
  REQ_LINE("Directory", serve_directory, RQ_ESSENTIAL),
  REQ_LINE("Relative-directory", serve_directory, 0),
  REQ_LINE("Max-dotdot", serve_max_dotdot, 0),
  REQ_LINE("Static-directory", serve_static_directory, 0),
  REQ_LINE("Sticky", serve_sticky, 0),
  REQ_LINE("Entry", serve_entry, RQ_ESSENTIAL),
  REQ_LINE("Kopt", serve_kopt, 0),
  REQ_LINE("Checkin-time", serve_checkin_time, 0),
  REQ_LINE("Modified", serve_modified, RQ_ESSENTIAL),
  REQ_LINE("Is-modified", serve_is_modified, 0),

  /* The client must send this request to interoperate with CVS 1.5
     through 1.9 servers.  The server must support it (although it can
     be and is a noop) to interoperate with CVS 1.5 to 1.9 clients.  */
  REQ_LINE("UseUnchanged", serve_enable_unchanged, RQ_ENABLEME | RQ_ROOTLESS),

  REQ_LINE("Unchanged", serve_unchanged, RQ_ESSENTIAL),
  REQ_LINE("Notify", serve_notify, 0),
  REQ_LINE("Hostname", serve_hostname, 0),
  REQ_LINE("LocalDir", serve_localdir, 0),
  REQ_LINE("Questionable", serve_questionable, 0),
  REQ_LINE("Argument", serve_argument, RQ_ESSENTIAL),
  REQ_LINE("Argumentx", serve_argumentx, RQ_ESSENTIAL),
  REQ_LINE("Global_option", serve_global_option, RQ_ROOTLESS),
  REQ_LINE("Gzip-stream", serve_gzip_stream, 0),
  REQ_LINE("wrapper-sendme-rcsOptions",
	   serve_wrapper_sendme_rcs_options,
	   0),
  REQ_LINE("Set", serve_set, RQ_ROOTLESS),
#ifdef ENCRYPTION
#  ifdef HAVE_KERBEROS
  REQ_LINE("Kerberos-encrypt", serve_kerberos_encrypt, 0),
#  endif
#  ifdef HAVE_GSSAPI
  REQ_LINE("Gssapi-encrypt", serve_gssapi_encrypt, 0),
#  endif
#endif
#ifdef HAVE_GSSAPI
  REQ_LINE("Gssapi-authenticate", serve_gssapi_authenticate, 0),
#endif
  REQ_LINE("expand-modules", serve_expand_modules, 0),
  REQ_LINE("ci", serve_ci, RQ_ESSENTIAL),
  REQ_LINE("co", serve_co, RQ_ESSENTIAL),
  REQ_LINE("update", serve_update, RQ_ESSENTIAL),
  REQ_LINE("diff", serve_diff, 0),
  REQ_LINE("log", serve_log, 0),
  REQ_LINE("rlog", serve_rlog, 0),
  REQ_LINE("list", serve_ls, 0),
  REQ_LINE("rlist", serve_rls, 0),
  /* This allows us to avoid sending `-q' as a command argument to `cvs ls',
   * or more accurately, allows us to send `-q' to backwards CVSNT servers.
   */
  REQ_LINE("global-list-quiet", serve_noop, RQ_ROOTLESS),
  /* Deprecated synonym for rlist, for compatibility with CVSNT. */
  REQ_LINE("ls", serve_rls, 0),
  REQ_LINE("add", serve_add, 0),
  REQ_LINE("remove", serve_remove, 0),
  REQ_LINE("update-patches", serve_ignore, 0),
  REQ_LINE("gzip-file-contents", serve_gzip_contents, 0),
  REQ_LINE("status", serve_status, 0),
  REQ_LINE("rdiff", serve_rdiff, 0),
  REQ_LINE("tag", serve_tag, 0),
  REQ_LINE("rtag", serve_rtag, 0),
  REQ_LINE("import", serve_import, 0),
  REQ_LINE("admin", serve_admin, 0),
  REQ_LINE("export", serve_export, 0),
  REQ_LINE("history", serve_history, 0),
  REQ_LINE("release", serve_release, 0),
  REQ_LINE("watch-on", serve_watch_on, 0),
  REQ_LINE("watch-off", serve_watch_off, 0),
  REQ_LINE("watch-add", serve_watch_add, 0),
  REQ_LINE("watch-remove", serve_watch_remove, 0),
  REQ_LINE("watchers", serve_watchers, 0),
  REQ_LINE("editors", serve_editors, 0),
  REQ_LINE("edit", serve_edit, 0),
  REQ_LINE("init", serve_init, RQ_ROOTLESS),
  REQ_LINE("annotate", serve_annotate, 0),
  REQ_LINE("rannotate", serve_rannotate, 0),
  REQ_LINE("noop", serve_noop, RQ_ROOTLESS),
  REQ_LINE("version", serve_version, RQ_ROOTLESS),
  REQ_LINE(NULL, NULL, 0)

#undef REQ_LINE
};
#endif /* SERVER_SUPPORT or CLIENT_SUPPORT */



#ifdef SERVER_SUPPORT
/*
 * This server request is not ignored by the secondary.
 */
static void
serve_valid_requests (char *arg)
{
    struct request *rq;

    /* Since this is processed in the first pass, don't reprocess it in the
     * second.
     *
     * We still print errors since new errors could have been generated in the
     * second pass.
     */
    if (print_pending_error ()
#ifdef PROXY_SUPPORT
	|| reprocessing
#endif /* PROXY_SUPPORT */
       )
	return;

    buf_output0 (buf_to_net, "Valid-requests");
    for (rq = requests; rq->name != NULL; rq++)
    {
	if (rq->func != NULL)
	{
	    buf_append_char (buf_to_net, ' ');
	    buf_output0 (buf_to_net, rq->name);
	}
    }
    buf_output0 (buf_to_net, "\nok\n");

    /* The client is waiting for the list of valid requests, so we
       must send the output now.  */
    buf_flush (buf_to_net, 1);
}



#ifdef SUNOS_KLUDGE
/*
 * Delete temporary files.  SIG is the signal making this happen, or
 * 0 if not called as a result of a signal.
 */
static int command_pid_is_dead;
static void wait_sig (int sig)
{
    int status;
    pid_t r = wait (&status);
    if (r == command_pid)
	command_pid_is_dead++;
}
#endif /* SUNOS_KLUDGE */



/*
 * This function cleans up after the server.  Specifically, it:
 *
 * <ol>
 * <li>Sets BUF_TO_NET to blocking and fluxhes it.</li>
 * <li>With SUNOS_KLUDGE enabled:
 *   <ol>
 *   <li>Terminates the command process.</li>
 *   <li>Waits on the command process, draining output as necessary.</li>
 *   </ol>
 * </li>
 * <li>Removes the temporary directory.</li>
 * <li>Flush and shutdown the buffers.</li>
 * <li>Set ERROR_USE_PROTOCOL and SERVER_ACTIVE to false.</li>
 * </ol>
 *
 * NOTES
 *   This function needs to be reentrant since a call to exit() can cause a
 *   call to this function, which can then be interrupted by a signal, which
 *   can cause a second call to this function.
 *
 * GLOBALS
 *   buf_from_net		The input buffer which brings data from the
 *   				CVS client.
 *   buf_to_net			The output buffer which moves data to the CVS
 *   				client.
 *   error_use_protocol		Set when the server parent process is active.
 *   				Cleared for the server child processes.
 *   dont_delete_temp		Set when a core dump of a child process is
 *   				detected so that the core and related data may
 *   				be preserved.
 *   Tmpdir			The system TMP directory for all temp files.
 *   noexec			Whether we are supposed to change the disk.
 *   orig_server_temp_dir	The temporary directory we created within
 *   				Tmpdir for our duplicate of the client
 *   				workspace.
 *
 * INPUTS
 *   None.
 *
 * ERRORS
 *   Problems encountered during the cleanup, for instance low memory or
 *   problems deleting the temp files and directories, can cause the error
 *   function to be called, which might call exit.  If exit gets called in this
 *   manner. this routine will not complete, but the other exit handlers
 *   registered via atexit() will still run.
 *
 * RETURNS
 *   Nothing.
 */
void
server_cleanup (void)
{
    TRACE (TRACE_FUNCTION, "server_cleanup()");

    assert (server_active);

    /* FIXME: Do not perform buffered I/O from an interrupt handler like
     * this (via error).  However, I'm leaving the error-calling code there
     * in the hope that on the rare occasion the error call is actually made
     * (e.g., a fluky I/O error or permissions problem prevents the deletion
     * of a just-created file) reentrancy won't be an issue.
     */

    /* We don't want to be interrupted during calls which set globals to NULL,
     * but we know that by the time we reach this function, interrupts have
     * already been blocked.
     */

    /* Since we install this function in an atexit() handler before forking,
     * reuse the ERROR_USE_PROTOCOL flag, which we know is only set in the
     * parent server process, to avoid cleaning up the temp space multiple
     * times.  Skip the buf_to_net checks too as an optimization since we know
     * they will be set to NULL in the child process anyhow.
     */
    if (error_use_protocol)
    {
	if (buf_to_net != NULL)
	{
	    int status;

	    /* Since we're done, go ahead and put BUF_TO_NET back into blocking
	     * mode and send any pending output.  In the usual case there won't
	     * won't be any, but there might be if an error occured.
	     */

	    set_block (buf_to_net);
	    buf_flush (buf_to_net, 1);

	    /* Next we shut down BUF_FROM_NET.  That will pick up the checksum
	     * generated when the client shuts down its buffer.  Then, after we
	     * have generated any final output, we shut down BUF_TO_NET.
	     */

	    /* SIG_beginCrSect(); */
	    if (buf_from_net)
	    {
		status = buf_shutdown (buf_from_net);
		if (status != 0)
		    error (0, status, "shutting down buffer from client");
		buf_free (buf_from_net);
		buf_from_net = NULL;
	    }
	    /* SIG_endCrSect(); */
	}

	if (!dont_delete_temp)
	{
	    int save_noexec;

	    /* What a bogus kludge.  This disgusting code makes all kinds of
	       assumptions about SunOS, and is only for a bug in that system.
	       So only enable it on Suns.  */
#ifdef SUNOS_KLUDGE
	    if (command_pid > 0)
	    {
		/* To avoid crashes on SunOS due to bugs in SunOS tmpfs
		 * triggered by the use of rename() in RCS, wait for the
		 * subprocess to die.  Unfortunately, this means draining
		 * output while waiting for it to unblock the signal we sent
		 * it.  Yuck!
		 */
		int status;
		pid_t r;

		signal (SIGCHLD, wait_sig);
		/* Perhaps SIGTERM would be more correct.  But the child
		   process will delay the SIGINT delivery until its own
		   children have exited.  */
		kill (command_pid, SIGINT);
		/* The caller may also have sent a signal to command_pid, so
		 * always try waiting.  First, though, check and see if it's
		 * still there....
		 */
	    do_waitpid:
		r = waitpid (command_pid, &status, WNOHANG);
		if (r == 0)
		    ;
		else if (r == command_pid)
		    command_pid_is_dead++;
		else if (r == -1)
		    switch (errno)
		    {
			case ECHILD:
			    command_pid_is_dead++;
			    break;
			case EINTR:
			    goto do_waitpid;
		    }
		else
		    /* waitpid should always return one of the above values */
		    abort ();
		while (!command_pid_is_dead)
		{
		    struct timeval timeout;
		    struct fd_set_wrapper readfds;
		    char buf[100];
		    int i;

		    /* Use a non-zero timeout to avoid eating up CPU cycles.  */
		    timeout.tv_sec = 2;
		    timeout.tv_usec = 0;
		    readfds = command_fds_to_drain;
		    switch (select (max_command_fd + 1, &readfds.fds,
				    NULL, NULL &timeout))
		    {
			case -1:
			    if (errno != EINTR)
				abort ();
			case 0:
			    /* timeout */
			    break;
			case 1:
			    for (i = 0; i <= max_command_fd; i++)
			    {
				if (!FD_ISSET (i, &readfds.fds))
				    continue;
				/* this fd is non-blocking */
				while (read (i, buf, sizeof (buf)) >= 1)
				    ;
			    }
			    break;
			default:
			    abort ();
		    }
		}
	    }
#endif /* SUNOS_KLUDGE */

	    /* Make sure our working directory isn't inside the tree we're
	       going to delete.  */
	    CVS_CHDIR (Tmpdir);

	    /* Temporarily clear noexec, so that we clean up our temp directory
	       regardless of it (this could more cleanly be handled by moving
	       the noexec check to all the unlink_file_dir callers from
	       unlink_file_dir itself).  */
	    save_noexec = noexec;

	    /* SIG_beginCrSect(); */
	    noexec = 0;
	    unlink_file_dir (orig_server_temp_dir);
	    noexec = save_noexec;
	    /* SIG_endCrSect(); */
	} /* !dont_delete_temp */

	/* SIG_beginCrSect(); */
	if (buf_to_net != NULL)
	{
	    /* Save BUF_TO_NET and set the global pointer to NULL so that any
	     * error messages generated during shutdown go to the syslog rather
	     * than getting lost.
	     */
	    struct buffer *buf_to_net_save = buf_to_net;
	    buf_to_net = NULL;

	    (void) buf_flush (buf_to_net_save, 1);
	    (void) buf_shutdown (buf_to_net_save);
	    buf_free (buf_to_net_save);
	    error_use_protocol = 0;
	}
	/* SIG_endCrSect(); */
    }

    server_active = 0;
}



#ifdef PROXY_SUPPORT
size_t MaxProxyBufferSize = (size_t)(8 * 1024 * 1024); /* 8 megabytes,
                                                        * by default.
                                                        */
#endif /* PROXY_SUPPORT */

int server_active = 0;

int
server (int argc, char **argv)
{
    char *error_prog_name;		/* Used in error messages */

    if (argc == -1)
    {
	static const char *const msg[] =
	{
	    "Usage: %s %s\n",
	    "  Normally invoked by a cvs client on a remote machine.\n",
	    NULL
	};
	usage (msg);
    }
    /* Ignore argc and argv.  They might be from .cvsrc.  */

    /*
     * Set this in .bashrc if you want to give yourself time to attach
     * to the subprocess with a debugger.
     */
    if (getenv ("CVS_PARENT_SERVER_SLEEP"))
    {
	int secs = atoi (getenv ("CVS_PARENT_SERVER_SLEEP"));
	TRACE (TRACE_DATA, "Sleeping CVS_PARENT_SERVER_SLEEP (%d) seconds",
	       secs);
	sleep (secs);
    }
    else
	TRACE (TRACE_DATA, "CVS_PARENT_SERVER_SLEEP not set.");

    /* pserver_authenticate_connection () (called from main ()) can initialize
     * these.
     */
    if (!buf_to_net)
    {
	buf_to_net = fd_buffer_initialize (STDOUT_FILENO, 0, NULL, false,
					   outbuf_memory_error);
	buf_from_net = fd_buffer_initialize (STDIN_FILENO, 0, NULL, true,
					     outbuf_memory_error);
    }

    setup_logfiles ("CVS_SERVER_LOG", &buf_to_net, &buf_from_net);

#ifdef PROXY_SUPPORT
    /* We have to set up the recording for all servers.  Until we receive the
     * `Root' request and load CVSROOT/config, we can't tell if we are a
     * secondary or primary.
     */
    {
	/* Open the secondary log.  */
	buf_from_net = log_buffer_initialize (buf_from_net, NULL,
# ifdef PROXY_SUPPORT
					      true,
					      config
						? config->MaxProxyBufferSize
						: MaxProxyBufferSize,
# endif /* PROXY_SUPPORT */
					      true, outbuf_memory_error);
	proxy_log = buf_from_net;

	/* And again for the out log.  */
	buf_to_net = log_buffer_initialize (buf_to_net, NULL,
# ifdef PROXY_SUPPORT
					    true,
					    config
					      ? config->MaxProxyBufferSize
					      : MaxProxyBufferSize,
# endif /* PROXY_SUPPORT */
					    false, outbuf_memory_error);
	proxy_log_out = buf_to_net;
    }
#endif /* PROXY_SUPPORT */

    saved_output = buf_nonio_initialize (outbuf_memory_error);
    saved_outerr = buf_nonio_initialize (outbuf_memory_error);

    /* Since we're in the server parent process, error should use the
       protocol to report error messages.  */
    error_use_protocol = 1;

    /* OK, now figure out where we stash our temporary files.  */
    {
	char *p;

	/* The code which wants to chdir into server_temp_dir is not set
	   up to deal with it being a relative path.  So give an error
	   for that case.  */
	if (!isabsolute (Tmpdir))
	{
	    if (alloc_pending (80 + strlen (Tmpdir)))
		sprintf (pending_error_text,
			 "E Value of %s for TMPDIR is not absolute", Tmpdir);

	    /* FIXME: we would like this error to be persistent, that
	       is, not cleared by print_pending_error.  The current client
	       will exit as soon as it gets an error, but the protocol spec
	       does not require a client to do so.  */
	}
	else
	{
	    int status;
	    int i = 0;

	    server_temp_dir = xmalloc (strlen (Tmpdir) + 80);
	    if (server_temp_dir == NULL)
	    {
		/*
		 * Strictly speaking, we're not supposed to output anything
		 * now.  But we're about to exit(), give it a try.
		 */
		printf ("E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");

		exit (EXIT_FAILURE);
	    }
	    strcpy (server_temp_dir, Tmpdir);

	    /* Remove a trailing slash from TMPDIR if present.  */
	    p = server_temp_dir + strlen (server_temp_dir) - 1;
	    if (*p == '/')
		*p = '\0';

	    /*
	     * I wanted to use cvs-serv/PID, but then you have to worry about
	     * the permissions on the cvs-serv directory being right.  So
	     * use cvs-servPID.
	     */
	    strcat (server_temp_dir, "/cvs-serv");

	    p = server_temp_dir + strlen (server_temp_dir);
	    sprintf (p, "%ld", (long) getpid ());

	    orig_server_temp_dir = server_temp_dir;

	    /* Create the temporary directory, and set the mode to
	       700, to discourage random people from tampering with
	       it.  */
	    while ((status = mkdir_p (server_temp_dir)) == EEXIST)
	    {
		static const char suffix[] = "abcdefghijklmnopqrstuvwxyz";

		if (i >= sizeof suffix - 1) break;
		if (i == 0) p = server_temp_dir + strlen (server_temp_dir);
		p[0] = suffix[i++];
		p[1] = '\0';
	    }
	    if (status != 0)
	    {
		if (alloc_pending (80 + strlen (server_temp_dir)))
		    sprintf (pending_error_text,
			    "E can't create temporary directory %s",
			    server_temp_dir);
		pending_error = status;
	    }
#ifndef CHMOD_BROKEN
	    else if (chmod (server_temp_dir, S_IRWXU) < 0)
	    {
		int save_errno = errno;
		if (alloc_pending (80 + strlen (server_temp_dir)))
		    sprintf (pending_error_text,
"E cannot change permissions on temporary directory %s",
			     server_temp_dir);
		pending_error = save_errno;
	    }
#endif
	    else if (CVS_CHDIR (server_temp_dir) < 0)
	    {
		int save_errno = errno;
		if (alloc_pending (80 + strlen (server_temp_dir)))
		    sprintf (pending_error_text,
"E cannot change to temporary directory %s",
			     server_temp_dir);
		pending_error = save_errno;
	    }
	}
    }

    /* Now initialize our argument vector (for arguments from the client).  */

    /* Small for testing.  */
    argument_vector_size = 1;
    argument_vector = xmalloc (argument_vector_size * sizeof (char *));
    argument_count = 1;
    /* This gets printed if the client supports an option which the
       server doesn't, causing the server to print a usage message.
       FIXME: just a nit, I suppose, but the usage message the server
       prints isn't literally true--it suggests "cvs server" followed
       by options which are for a particular command.  Might be nice to
       say something like "client apparently supports an option not supported
       by this server" or something like that instead of usage message.  */
    error_prog_name = xmalloc (strlen (program_name) + 8);
    sprintf(error_prog_name, "%s server", program_name);
    argument_vector[0] = error_prog_name;

    while (1)
    {
	char *cmd, *orig_cmd;
	struct request *rq;
	int status;

	status = buf_read_line (buf_from_net, &cmd, NULL);
	if (status == -2)
	{
	    buf_output0 (buf_to_net, "E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");
	    break;
	}
	if (status != 0)
	    break;

	orig_cmd = cmd;
	for (rq = requests; rq->name != NULL; ++rq)
	    if (strncmp (cmd, rq->name, strlen (rq->name)) == 0)
	    {
		int len = strlen (rq->name);
		if (cmd[len] == '\0')
		    cmd += len;
		else if (cmd[len] == ' ')
		    cmd += len + 1;
		else
		    /*
		     * The first len characters match, but it's a different
		     * command.  e.g. the command is "cooperate" but we matched
		     * "co".
		     */
		    continue;

		if (!(rq->flags & RQ_ROOTLESS)
		    && current_parsed_root == NULL)
		{
		    /* For commands which change the way in which data
		       is sent and received, for example Gzip-stream,
		       this does the wrong thing.  Since the client
		       assumes that everything is being compressed,
		       unconditionally, there is no way to give this
		       error to the client without turning on
		       compression.  The obvious fix would be to make
		       Gzip-stream RQ_ROOTLESS (with the corresponding
		       change to the spec), and that might be a good
		       idea but then again I can see some settings in
		       CVSROOT about what compression level to allow.
		       I suppose a more baroque answer would be to
		       turn on compression (say, at level 1), just
		       enough to give the "Root request missing"
		       error.  For now we just lose.  */
		    if (alloc_pending (80))
			sprintf (pending_error_text,
				 "E Protocol error: Root request missing");
		}
		else
		    (*rq->func) (cmd);
		break;
	    }
	if (rq->name == NULL)
	{
	    if (!print_pending_error ())
	    {
		buf_output0 (buf_to_net, "error  unrecognized request `");
		buf_output0 (buf_to_net, cmd);
		buf_append_char (buf_to_net, '\'');
		buf_append_char (buf_to_net, '\n');
	    }
	}
	free (orig_cmd);
    }

    free (error_prog_name);

    /* We expect the client is done talking to us at this point.  If there is
     * any data in the buffer or on the network pipe, then something we didn't
     * prepare for is happening.
     */
    if (!buf_empty (buf_from_net))
    {
	/* Try to send the error message to the client, but also syslog it, in
	 * case the client isn't listening anymore.
	 */
#ifdef HAVE_SYSLOG_H
	/* FIXME: Can the IP address of the connecting client be retrieved
	 * and printed here?
	 */
	syslog (LOG_DAEMON | LOG_ERR, "Dying gasps received from client.");
#endif
	error (0, 0, "Dying gasps received from client.");
    }

#ifdef HAVE_PAM
    {
        int retval;

        retval = pam_close_session(pamh, 0);
#ifdef HAVE_SYSLOG_H
        if (retval != PAM_SUCCESS)
            syslog (LOG_DAEMON | LOG_ERR, 
                    "PAM close session error: %s",
                    pam_strerror(pamh, retval));
#endif

        retval = pam_end (pamh, retval);
#ifdef HAVE_SYSLOG_H
        if (retval != PAM_SUCCESS)
            syslog (LOG_DAEMON | LOG_ERR, 
                    "PAM failed to release authenticator, error: %s",
                    pam_strerror(pamh, retval));
#endif
    }
#endif

    /* server_cleanup() will be called on a normal exit and close the buffers
     * explicitly.
     */
    return 0;
}



#if defined (HAVE_KERBEROS) || defined (AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)
static void
switch_to_user (const char *cvs_username, const char *username)
{
    struct passwd *pw;
#ifdef HAVE_PAM
    int retval;
    char *pam_stage = "open session";

    retval = pam_open_session(pamh, 0);
    if (retval == PAM_SUCCESS) {
        pam_stage = "get pam user";
        retval = pam_get_item(pamh, PAM_USER, (const void **)&username);
    }

    if (retval != PAM_SUCCESS) {
        printf("E PAM %s error: %s\n", pam_stage,
                pam_strerror(pamh, retval));
        exit (EXIT_FAILURE);
    }
#endif

    pw = getpwnam (username);
    if (pw == NULL)
    {
	/* check_password contains a similar check, so this usually won't be
	   reached unless the CVS user is mapped to an invalid system user.  */

	printf ("E Fatal error, aborting.\n\
error 0 %s: no such system user\n", username);
	exit (EXIT_FAILURE);
    }

    if (pw->pw_uid == 0)
    {
#ifdef HAVE_SYSLOG_H
	    /* FIXME: Can the IP address of the connecting client be retrieved
	     * and printed here?
	     */
	    syslog (LOG_DAEMON | LOG_ALERT,
		    "attempt to root from account: %s", cvs_username
		   );
#endif
        printf("error 0: root not allowed\n");
	exit (EXIT_FAILURE);
    }

#if HAVE_INITGROUPS
    if (initgroups (pw->pw_name, pw->pw_gid) < 0
#  ifdef EPERM
	/* At least on the system I tried, initgroups() only works as root.
	   But we do still want to report ENOMEM and whatever other
	   errors initgroups() might dish up.  */
	&& errno != EPERM
#  endif
	)
    {
	/* This could be a warning, but I'm not sure I see the point
	   in doing that instead of an error given that it would happen
	   on every connection.  We could log it somewhere and not tell
	   the user.  But at least for now make it an error.  */
	printf ("error 0 initgroups failed: %s\n", strerror (errno));
	exit (EXIT_FAILURE);
    }
#endif /* HAVE_INITGROUPS */

#ifdef HAVE_PAM
    retval = pam_setcred(pamh, PAM_ESTABLISH_CRED);
    if (retval != PAM_SUCCESS) {
        printf("E PAM reestablish credentials error: %s\n", 
                pam_strerror(pamh, retval));
        exit (EXIT_FAILURE);
    }
#endif

#ifdef SETXID_SUPPORT
    /* honor the setgid bit iff set*/
    if (getgid() != getegid())
    {
	if (setgid (getegid ()) < 0)
	{
	    /* See comments at setuid call below for more discussion.  */
	    printf ("error 0 setgid failed: %s\n", strerror (errno));
	    exit (EXIT_FAILURE);
	}
    }
    else
#endif
    {
	if (setgid (pw->pw_gid) < 0)
	{
	    /* See comments at setuid call below for more discussion.  */
	    printf ("error 0 setgid failed: %s\n", strerror (errno));
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR,
		    "setgid to %d failed (%m): real %d/%d, effective %d/%d ",
		    pw->pw_gid, getuid(), getgid(), geteuid(), getegid());
#endif
	    exit (EXIT_FAILURE);
	}
    }

    if (setuid (pw->pw_uid) < 0)
    {
	/* Note that this means that if run as a non-root user,
	   CVSROOT/passwd must contain the user we are running as
	   (e.g. "joe:FsEfVcu:cvs" if run as "cvs" user).  This seems
	   cleaner than ignoring the error like CVS 1.10 and older but
	   it does mean that some people might need to update their
	   CVSROOT/passwd file.  */
	printf ("error 0 setuid failed: %s\n", strerror (errno));
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR,
		    "setuid to %d failed (%m): real %d/%d, effective %d/%d ",
		    pw->pw_uid, getuid(), getgid(), geteuid(), getegid());
#endif
	exit (EXIT_FAILURE);
    }

    /* We don't want our umask to change file modes.  The modes should
       be set by the modes used in the repository, and by the umask of
       the client.  */
    umask (0);

#ifdef AUTH_SERVER_SUPPORT
    /* Make sure our CVS_Username has been set. */
    if (CVS_Username == NULL)
	CVS_Username = xstrdup (username);
#endif

#if HAVE_PUTENV
    /* Set LOGNAME, USER and CVS_USER in the environment, in case they
       are already set to something else.  */
    {
	char *env;

	env = xmalloc (sizeof "LOGNAME=" + strlen (username));
	(void) sprintf (env, "LOGNAME=%s", username);
	(void) putenv (env);

	env = xmalloc (sizeof "USER=" + strlen (username));
	(void) sprintf (env, "USER=%s", username);
	(void) putenv (env);

#ifdef AUTH_SERVER_SUPPORT
	env = xmalloc (sizeof "CVS_USER=" + strlen (CVS_Username));
	(void) sprintf (env, "CVS_USER=%s", CVS_Username);
	(void) putenv (env);
#endif
    }
#endif /* HAVE_PUTENV */
}
#endif

#ifdef AUTH_SERVER_SUPPORT

extern char *crypt (const char *, const char *);


/*
 * 0 means no entry found for this user.
 * 1 means entry found and password matches (or found password is empty)
 * 2 means entry found, but password does not match.
 *
 * If 1, host_user_ptr will be set to point at the system
 * username (i.e., the "real" identity, which may or may not be the
 * CVS username) of this user; caller may free this.  Global
 * CVS_Username will point at an allocated copy of cvs username (i.e.,
 * the username argument below).
 * kff todo: FIXME: last sentence is not true, it applies to caller.
 */
static int
check_repository_password (char *username, char *password, char *repository, char **host_user_ptr)
{
    int retval = 0;
    FILE *fp;
    char *filename;
    char *linebuf = NULL;
    size_t linebuf_len;
    int found_it = 0;
    int namelen;

    /* We don't use current_parsed_root->directory because it hasn't been
     * set yet -- our `repository' argument came from the authentication
     * protocol, not the regular CVS protocol.
     */

    filename = xmalloc (strlen (repository)
			+ 1
			+ strlen (CVSROOTADM)
			+ 1
			+ strlen (CVSROOTADM_PASSWD)
			+ 1);

    (void) sprintf (filename, "%s/%s/%s", repository,
		    CVSROOTADM, CVSROOTADM_PASSWD);

    fp = CVS_FOPEN (filename, "r");
    if (fp == NULL)
    {
	if (!existence_error (errno))
	    error (0, errno, "cannot open %s", filename);
	return 0;
    }

    /* Look for a relevant line -- one with this user's name. */
    namelen = strlen (username);
    while (getline (&linebuf, &linebuf_len, fp) >= 0)
    {
	if ((strncmp (linebuf, username, namelen) == 0)
	    && (linebuf[namelen] == ':'))
	{
	    found_it = 1;
	    break;
	}
    }
    if (ferror (fp))
	error (0, errno, "cannot read %s", filename);
    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", filename);

    /* If found_it, then linebuf contains the information we need. */
    if (found_it)
    {
	char *found_password, *host_user_tmp;
	char *non_cvsuser_portion;

	/* We need to make sure lines such as
	 *
	 *    "username::sysuser\n"
	 *    "username:\n"
	 *    "username:  \n"
	 *
	 * all result in a found_password of NULL, but we also need to
	 * make sure that
	 *
	 *    "username:   :sysuser\n"
	 *    "username: <whatever>:sysuser\n"
	 *
	 * continues to result in an impossible password.  That way,
	 * an admin would be on safe ground by going in and tacking a
	 * space onto the front of a password to disable the account
	 * (a technique some people use to close accounts
	 * temporarily).
	 */

	/* Make `non_cvsuser_portion' contain everything after the CVS
	   username, but null out any final newline. */
	non_cvsuser_portion = linebuf + namelen;
	strtok (non_cvsuser_portion, "\n");

	/* If there's a colon now, we just want to inch past it. */
	if (strchr (non_cvsuser_portion, ':') == non_cvsuser_portion)
	    non_cvsuser_portion++;

	/* Okay, after this conditional chain, found_password and
	   host_user_tmp will have useful values: */

	if ((non_cvsuser_portion == NULL)
	    || (strlen (non_cvsuser_portion) == 0)
	    || ((strspn (non_cvsuser_portion, " \t"))
		== strlen (non_cvsuser_portion)))
	{
	    found_password = NULL;
	    host_user_tmp = NULL;
	}
	else if (strncmp (non_cvsuser_portion, ":", 1) == 0)
	{
	    found_password = NULL;
	    host_user_tmp = non_cvsuser_portion + 1;
	    if (strlen (host_user_tmp) == 0)
		host_user_tmp = NULL;
	}
	else
	{
	    found_password = strtok (non_cvsuser_portion, ":");
	    host_user_tmp = strtok (NULL, ":");
	}

	/* Of course, maybe there was no system user portion... */
	if (host_user_tmp == NULL)
	    host_user_tmp = username;

	/* Verify blank passwords directly, otherwise use crypt(). */
	if ((found_password == NULL)
	    || ((strcmp (found_password, crypt (password, found_password))
		 == 0)))
	{
	    /* Give host_user_ptr permanent storage. */
	    *host_user_ptr = xstrdup (host_user_tmp);
	    retval = 1;
	}
	else
	{
#ifdef LOG_AUTHPRIV
	syslog (LOG_AUTHPRIV | LOG_NOTICE,
		"password mismatch for %s in %s: %s vs. %s", username,
		repository, crypt(password, found_password), found_password);
#endif
	    *host_user_ptr = NULL;
	    retval	 = 2;
	}
    }
    else     /* Didn't find this user, so deny access. */
    {
	*host_user_ptr = NULL;
	retval = 0;
    }

    free (filename);
    if (linebuf)
	free (linebuf);

    return retval;
}

#ifdef HAVE_PAM

struct cvs_pam_userinfo {
    char *username;
    char *password;
};

static int
cvs_pam_conv (int num_msg, const struct pam_message **msg,
              struct pam_response **resp, void *appdata_ptr)
{
    int i;
    struct pam_response *response;
    struct cvs_pam_userinfo *ui = (struct cvs_pam_userinfo *)appdata_ptr;

    assert (msg && resp);

    response = xmalloc(num_msg * sizeof (struct pam_response));
    memset(response, 0, num_msg * sizeof (struct pam_response));

    for (i = 0; i < num_msg; i++)
    {
	switch (msg[i]->msg_style) 
	{
	    /* PAM wants a username */
	    case PAM_PROMPT_ECHO_ON:
                assert (ui && ui->username);
		response[i].resp = xstrdup (ui->username);
		break;
	    /* PAM wants a password */
	    case PAM_PROMPT_ECHO_OFF:
                assert (ui && ui->password);
		response[i].resp = xstrdup (ui->password);
		break;
	    case PAM_ERROR_MSG:
	    case PAM_TEXT_INFO:
		printf ("E %s\n", msg[i]->msg);
		break;
	    /* PAM wants something we don't understand - bail out */
	    default:
		goto cleanup;
	}
    }

    *resp = response;
    return PAM_SUCCESS;

cleanup:
    for (i = 0; i < num_msg; i++)
    {
	if (response[i].resp)
	{
	    free (response[i].resp);
	    response[i].resp = 0;
	}
    }
    free (response);
    return PAM_CONV_ERR;
}

static int
check_pam_password (char **username, char *password)
{
    int retval, err;
    struct cvs_pam_userinfo ui = { *username, password };
    struct pam_conv conv = { cvs_pam_conv, (void *)&ui };
    char *pam_stage = "start";

    retval = pam_start (PAM_SERVICE_NAME, *username, &conv, &pamh);

    /* sets a dummy tty name which pam modules can check for */
    if (retval == PAM_SUCCESS) {
        pam_stage = "set dummy tty";
        retval = pam_set_item(pamh, PAM_TTY, PAM_SERVICE_NAME);
    }

    if (retval == PAM_SUCCESS) {
	pam_stage = "authenticate";
	retval = pam_authenticate(pamh, 0);
    }

    if (retval == PAM_SUCCESS) {
	pam_stage = "account";
	retval = pam_acct_mgmt (pamh, 0);
    }

    if (retval == PAM_SUCCESS) {
        pam_stage = "get pam user";
        retval = pam_get_item(pamh, PAM_USER, (const void **)username);
    }

    if (retval != PAM_SUCCESS)
	printf ("E PAM %s error: %s\n", pam_stage, pam_strerror(pamh, retval));

    return retval == PAM_SUCCESS;       /* indicate success */
}
#endif

static int
check_system_password (char *username, char *password)
{
    char *found_passwd = NULL;
    struct passwd *pw;
#ifdef HAVE_GETSPNAM
    {
	struct spwd *spw;

	spw = getspnam (username);
	if (spw != NULL)
	    found_passwd = spw->sp_pwdp;
    }
#endif

    if (found_passwd == NULL && (pw = getpwnam (username)) != NULL)
	found_passwd = pw->pw_passwd;

    if (found_passwd == NULL)
    {
	printf ("E Fatal error, aborting.\n\
error 0 %s: no such user\n", username);

	exit (EXIT_FAILURE);
    }

    /* Allow for dain bramaged HPUX passwd aging
     *  - Basically, HPUX adds a comma and some data
     *    about whether the passwd has expired or not
     *    on the end of the passwd field.
     *  - This code replaces the ',' with '\0'.
     *
     * FIXME - our workaround is brain damaged too.  I'm
     * guessing that HPUX WANTED other systems to think the
     * password was wrong so logins would fail if the
     * system didn't handle expired passwds and the passwd
     * might be expired.  I think the way to go here
     * is with PAM.
     */
    strtok (found_passwd, ",");

    if (*found_passwd)
    {
	/* user exists and has a password */
	if (strcmp (found_passwd, crypt (password, found_passwd)) == 0)
	    return 1;
	else
	{
#ifdef LOG_AUTHPRIV
	    syslog (LOG_AUTHPRIV | LOG_NOTICE,
		    "password mismatch for %s: %s vs. %s", username,
		    crypt(password, found_passwd), found_passwd);
#endif
	    return 0;
	}
    }

#ifdef LOG_AUTHPRIV
    syslog (LOG_AUTHPRIV | LOG_NOTICE,
	    "user %s authenticated because of blank system password",
	    username);
#endif
    return 1;
}



/* Return a hosting username if password matches, else NULL. */
static char *
check_password (char *username, char *password, char *repository)
{
    int rc;
    char *host_user = NULL;

    /* First we see if this user has a password in the CVS-specific
       password file.  If so, that's enough to authenticate with.  If
       not, we'll check /etc/passwd or maybe whatever is configured via PAM. */

    rc = check_repository_password (username, password, repository,
				    &host_user);

    if (rc == 2)
	return NULL;

    if (rc == 1)
	/* host_user already set by reference, so just return. */
	goto handle_return;

    assert (rc == 0);

    if (!config->system_auth)
    {
	/* Note that the message _does_ distinguish between the case in
	   which we check for a system password and the case in which
	   we do not.  It is a real pain to track down why it isn't
	   letting you in if it won't say why, and I am not convinced
	   that the potential information disclosure to an attacker
	   outweighs this.  */
	printf ("error 0 no such user %s in CVSROOT/passwd\n", username);

	exit (EXIT_FAILURE);
    }

    /* No cvs password found, so try /etc/passwd. */
#ifdef HAVE_PAM
    if (check_pam_password (&username, password))
#else /* !HAVE_PAM */
    if (check_system_password (username, password))
#endif /* HAVE_PAM */
	host_user = xstrdup (username);
    else
	host_user = NULL;

#ifdef LOG_AUTHPRIV
    if (!host_user)
	syslog (LOG_AUTHPRIV | LOG_NOTICE,
		"login refused for %s: user has no password", username);
#endif

handle_return:
    if (host_user)
    {
	/* Set CVS_Username here, in allocated space.
	   It might or might not be the same as host_user. */
	CVS_Username = xmalloc (strlen (username) + 1);
	strcpy (CVS_Username, username);
    }

    return host_user;
}

#endif /* AUTH_SERVER_SUPPORT */

#if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)

static void
pserver_read_line (char **tmp, size_t *tmp_len)
{
    int status;

    /* Make sure the protocol starts off on the right foot... */
    status = buf_read_short_line (buf_from_net, tmp, tmp_len, PATH_MAX);
    if (status == -1)
    {
#ifdef HAVE_SYSLOG_H
	syslog (LOG_DAEMON | LOG_NOTICE,
	        "unexpected EOF encountered during authentication");
#endif
	error (1, 0, "unexpected EOF encountered during authentication");
    }
    if (status == -2)
	status = ENOMEM;
    if (status != 0)
    {
#ifdef HAVE_SYSLOG_H
	syslog (LOG_DAEMON | LOG_NOTICE,
                "error reading from net while validating pserver");
#endif
	error (1, status, "error reading from net while validating pserver");
    }
}

/* Read username and password from client (i.e., stdin).
   If correct, then switch to run as that user and send an ACK to the
   client via stdout, else send NACK and die. */
void
pserver_authenticate_connection (void)
{
    char *tmp;
#ifdef AUTH_SERVER_SUPPORT
    char *repository = NULL;
    char *username = NULL;
    char *password = NULL;

    char *host_user;
    char *descrambled_password;
#endif /* AUTH_SERVER_SUPPORT */
    int verify_and_exit = 0;

    /* The Authentication Protocol.  Client sends:
     *
     *   BEGIN AUTH REQUEST\n
     *   <REPOSITORY>\n
     *   <USERNAME>\n
     *   <PASSWORD>\n
     *   END AUTH REQUEST\n
     *
     * Server uses above information to authenticate, then sends
     *
     *   I LOVE YOU\n
     *
     * if it grants access, else
     *
     *   I HATE YOU\n
     *
     * if it denies access (and it exits if denying).
     *
     * When the client is "cvs login", the user does not desire actual
     * repository access, but would like to confirm the password with
     * the server.  In this case, the start and stop strings are
     *
     *   BEGIN VERIFICATION REQUEST\n
     *
     *	    and
     *
     *   END VERIFICATION REQUEST\n
     *
     * On a verification request, the server's responses are the same
     * (with the obvious semantics), but it exits immediately after
     * sending the response in both cases.
     *
     * Why is the repository sent?  Well, note that the actual
     * client/server protocol can't start up until authentication is
     * successful.  But in order to perform authentication, the server
     * needs to look up the password in the special CVS passwd file,
     * before trying /etc/passwd.  So the client transmits the
     * repository as part of the "authentication protocol".  The
     * repository will be redundantly retransmitted later, but that's no
     * big deal.
     */

    /* Initialize buffers.  */
    buf_to_net = fd_buffer_initialize (STDOUT_FILENO, 0, NULL, false,
				       outbuf_memory_error);
    buf_from_net = fd_buffer_initialize (STDIN_FILENO, 0, NULL, true,
					 outbuf_memory_error);

#ifdef SO_KEEPALIVE
    /* Set SO_KEEPALIVE on the socket, so that we don't hang forever
       if the client dies while we are waiting for input.  */
    {
	int on = 1;

	if (setsockopt (STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,
			&on, sizeof on) < 0)
	{
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR, "error setting KEEPALIVE: %m");
#endif
	}
    }
#endif

    /* Make sure the protocol starts off on the right foot... */
    pserver_read_line (&tmp, NULL);

    if (strcmp (tmp, "BEGIN VERIFICATION REQUEST") == 0)
	verify_and_exit = 1;
    else if (strcmp (tmp, "BEGIN AUTH REQUEST") == 0)
	;
    else if (strcmp (tmp, "BEGIN GSSAPI REQUEST") == 0)
    {
#ifdef HAVE_GSSAPI
	free (tmp);
	gserver_authenticate_connection ();
	return;
#else
	error (1, 0, "GSSAPI authentication not supported by this server");
#endif
    }
    else
	error (1, 0, "bad auth protocol start: %s", tmp);

#ifndef AUTH_SERVER_SUPPORT

    error (1, 0, "Password authentication not supported by this server");

#else /* AUTH_SERVER_SUPPORT */

    free (tmp);

    /* Get the three important pieces of information in order. */
    /* See above comment about error handling.  */
    pserver_read_line (&repository, NULL);
    pserver_read_line (&username, NULL);
    pserver_read_line (&password, NULL);

    /* ... and make sure the protocol ends on the right foot. */
    /* See above comment about error handling.  */
    pserver_read_line (&tmp, NULL);
    if (strcmp (tmp,
		verify_and_exit ?
		"END VERIFICATION REQUEST" : "END AUTH REQUEST")
	!= 0)
    {
	error (1, 0, "bad auth protocol end: %s", tmp);
    }
    free (tmp);

    if (!root_allow_ok (repository))
    {
	error (1, 0, "%s: no such repository", repository);
#ifdef HAVE_SYSLOG_H
	syslog (LOG_DAEMON | LOG_NOTICE, "login refused for %s", repository);
#endif
	goto i_hate_you;
    }

    /* OK, now parse the config file, so we can use it to control how
       to check passwords.  If there was an error parsing the config
       file, parse_config already printed an error.  We keep going.
       Why?  Because if we didn't, then there would be no way to check
       in a new CVSROOT/config file to fix the broken one!  */
    config = get_root_allow_config (repository);

    /* We need the real cleartext before we hash it. */
    descrambled_password = descramble (password);
    host_user = check_password (username, descrambled_password, repository);
    if (host_user == NULL)
    {
#ifdef HAVE_SYSLOG_H
	syslog (LOG_DAEMON | LOG_NOTICE, "login failure (for %s)", repository);
#endif
	memset (descrambled_password, 0, strlen (descrambled_password));
	free (descrambled_password);
    i_hate_you:
	buf_output0 (buf_to_net, "I HATE YOU\n");
	buf_flush (buf_to_net, true);

	/* Don't worry about server_cleanup, server_active isn't set
	   yet.  */
	exit (EXIT_FAILURE);
    }
    memset (descrambled_password, 0, strlen (descrambled_password));
    free (descrambled_password);

    /* Don't go any farther if we're just responding to "cvs login". */
    if (verify_and_exit)
    {
	buf_output0 (buf_to_net, "I LOVE YOU\n");
	buf_flush (buf_to_net, true);
	exit (EXIT_SUCCESS);
    }

    /* Set Pserver_Repos so that we can check later that the same
       repository is sent in later client/server protocol. */
    Pserver_Repos = xmalloc (strlen (repository) + 1);
    strcpy (Pserver_Repos, repository);

    /* Switch to run as this user. */
    switch_to_user (username, host_user);
    free (host_user);
    free (repository);
    free (username);
    free (password);

    buf_output0 (buf_to_net, "I LOVE YOU\n");
    buf_flush (buf_to_net, true);
#endif /* AUTH_SERVER_SUPPORT */
}

#endif /* AUTH_SERVER_SUPPORT || HAVE_GSSAPI */


#ifdef HAVE_KERBEROS
void
kserver_authenticate_connection( void )
{
    int status;
    char instance[INST_SZ];
    struct sockaddr_in peer;
    struct sockaddr_in laddr;
    int len;
    KTEXT_ST ticket;
    AUTH_DAT auth;
    char version[KRB_SENDAUTH_VLEN];
    char user[ANAME_SZ];

    strcpy (instance, "*");
    len = sizeof peer;
    if (getpeername (STDIN_FILENO, (struct sockaddr *) &peer, &len) < 0
	|| getsockname (STDIN_FILENO, (struct sockaddr *) &laddr,
			&len) < 0)
    {
	printf ("E Fatal error, aborting.\n\
error %s getpeername or getsockname failed\n", strerror (errno));

	exit (EXIT_FAILURE);
    }

#ifdef SO_KEEPALIVE
    /* Set SO_KEEPALIVE on the socket, so that we don't hang forever
       if the client dies while we are waiting for input.  */
    {
	int on = 1;

	if (setsockopt (STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,
			   (char *) &on, sizeof on) < 0)
	{
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR, "error setting KEEPALIVE: %m");
#endif
	}
    }
#endif

    status = krb_recvauth (KOPT_DO_MUTUAL, STDIN_FILENO, &ticket, "rcmd",
			   instance, &peer, &laddr, &auth, "", sched,
			   version);
    if (status != KSUCCESS)
    {
	printf ("E Fatal error, aborting.\n\
error 0 kerberos: %s\n", krb_get_err_text(status));

	exit (EXIT_FAILURE);
    }

    memcpy (kblock, auth.session, sizeof (C_Block));

    /* Get the local name.  */
    status = krb_kntoln (&auth, user);
    if (status != KSUCCESS)
    {
	printf ("E Fatal error, aborting.\n"
		"error 0 kerberos: can't get local name: %s\n",
		krb_get_err_text(status));

	exit (EXIT_FAILURE);
    }

    /* Switch to run as this user. */
    switch_to_user ("Kerberos 4", user);
}
#endif /* HAVE_KERBEROS */



#ifdef HAVE_GSSAPI
/* Authenticate a GSSAPI connection.  This is called from
 * pserver_authenticate_connection, and it handles success and failure
 * the same way.
 *
 * GLOBALS
 *   server_hostname	The name of this host, as set via a call to
 *			xgethostname() in main().
 */
static void
gserver_authenticate_connection (void)
{
    struct hostent *hp;
    gss_buffer_desc tok_in, tok_out;
    char buf[1024];
    char *credbuf;
    size_t credbuflen;
    OM_uint32 stat_min, ret;
    gss_name_t server_name, client_name;
    gss_cred_id_t server_creds;
    int nbytes;
    gss_OID mechid;

    hp = gethostbyname (server_hostname);
    if (hp == NULL)
	error (1, 0, "can't get canonical hostname");

    sprintf (buf, "cvs@@%s", hp->h_name);
    tok_in.value = buf;
    tok_in.length = strlen (buf);

    if (gss_import_name (&stat_min, &tok_in, GSS_C_NT_HOSTBASED_SERVICE,
			 &server_name) != GSS_S_COMPLETE)
	error (1, 0, "could not import GSSAPI service name %s", buf);

    /* Acquire the server credential to verify the client's
       authentication.  */
    if (gss_acquire_cred (&stat_min, server_name, 0, GSS_C_NULL_OID_SET,
			  GSS_C_ACCEPT, &server_creds,
			  NULL, NULL) != GSS_S_COMPLETE)
	error (1, 0, "could not acquire GSSAPI server credentials");

    gss_release_name (&stat_min, &server_name);

    /* The client will send us a two byte length followed by that many
       bytes.  */
    if (fread (buf, 1, 2, stdin) != 2)
	error (1, errno, "read of length failed");

    nbytes = ((buf[0] & 0xff) << 8) | (buf[1] & 0xff);
    if (nbytes <= sizeof buf)
    {
        credbuf = buf;
        credbuflen = sizeof buf;
    }
    else
    {
        credbuflen = nbytes;
        credbuf = xmalloc (credbuflen);
    }
    
    if (fread (credbuf, 1, nbytes, stdin) != nbytes)
	error (1, errno, "read of data failed");

    gcontext = GSS_C_NO_CONTEXT;
    tok_in.length = nbytes;
    tok_in.value = credbuf;

    if (gss_accept_sec_context (&stat_min,
				&gcontext,	/* context_handle */
				server_creds,	/* verifier_cred_handle */
				&tok_in,	/* input_token */
				NULL,		/* channel bindings */
				&client_name,	/* src_name */
				&mechid,	/* mech_type */
				&tok_out,	/* output_token */
				&ret,
				NULL,		/* ignore time_rec */
				NULL)		/* ignore del_cred_handle */
	!= GSS_S_COMPLETE)
    {
	error (1, 0, "could not verify credentials");
    }

    /* FIXME: Use Kerberos v5 specific code to authenticate to a user.
       We could instead use an authentication to access mapping.  */
    {
	krb5_context kc;
	krb5_principal p;
	gss_buffer_desc desc;

	krb5_init_context (&kc);
	if (gss_display_name (&stat_min, client_name, &desc,
			      &mechid) != GSS_S_COMPLETE
	    || krb5_parse_name (kc, ((gss_buffer_t) &desc)->value, &p) != 0
	    || krb5_aname_to_localname (kc, p, sizeof buf, buf) != 0
	    || krb5_kuserok (kc, p, buf) != TRUE)
	{
	    error (1, 0, "access denied");
	}
	krb5_free_principal (kc, p);
	krb5_free_context (kc);
    }

    if (tok_out.length != 0)
    {
	char cbuf[2];

	cbuf[0] = (tok_out.length >> 8) & 0xff;
	cbuf[1] = tok_out.length & 0xff;
	if (fwrite (cbuf, 1, 2, stdout) != 2
	    || (fwrite (tok_out.value, 1, tok_out.length, stdout)
		!= tok_out.length))
	    error (1, errno, "fwrite failed");
    }

    switch_to_user ("GSSAPI", buf);

    if (credbuf != buf)
        free (credbuf);

    printf ("I LOVE YOU\n");
    fflush (stdout);
}

#endif /* HAVE_GSSAPI */

#endif /* SERVER_SUPPORT */

#if defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT)

/* This global variable is non-zero if the user requests encryption on
   the command line.  */
int cvsencrypt;

/* This global variable is non-zero if the users requests stream
   authentication on the command line.  */
int cvsauthenticate;

#ifdef ENCRYPTION

#ifdef HAVE_KERBEROS

/* An encryption interface using Kerberos.  This is built on top of a
   packetizing buffer.  */

/* This structure is the closure field of the Kerberos translation
   routines.  */
struct krb_encrypt_data
{
    /* The Kerberos key schedule.  */
    Key_schedule sched;
    /* The Kerberos DES block.  */
    C_Block block;
};



/* Decrypt Kerberos data.  */
static int
krb_encrypt_input( void *fnclosure, const char *input, char *output, int size )
{
    struct krb_encrypt_data *kd = (struct krb_encrypt_data *) fnclosure;
    int tcount;

    des_cbc_encrypt ((C_Block *) input, (C_Block *) output,
		     size, kd->sched, &kd->block, 0);

    /* SIZE is the size of the buffer, which is set by the encryption
       routine.  The packetizing buffer will arrange for the first two
       bytes in the decrypted buffer to be the real (unaligned)
       length.  As a safety check, make sure that the length in the
       buffer corresponds to SIZE.  Note that the length in the buffer
       is just the length of the data.  We must add 2 to account for
       the buffer count itself.  */
    tcount = ((output[0] & 0xff) << 8) + (output[1] & 0xff);
    if (((tcount + 2 + 7) & ~7) != size)
      error (1, 0, "Decryption failure");

    return 0;
}



/* Encrypt Kerberos data.  */
static int
krb_encrypt_output( void *fnclosure, const char *input, char *output,
                    int size, int *translated )
{
    struct krb_encrypt_data *kd = (struct krb_encrypt_data *) fnclosure;
    int aligned;

    /* For security against a known plaintext attack, we should
       initialize any padding bytes to random values.  Instead, we
       just pick up whatever is on the stack, which is at least better
       than using zero.  */

    /* Align SIZE to an 8 byte boundary.  Note that SIZE includes the
       two byte buffer count at the start of INPUT which was added by
       the packetizing buffer.  */
    aligned = (size + 7) & ~7;

    /* We use des_cbc_encrypt rather than krb_mk_priv because the
       latter sticks a timestamp in the block, and krb_rd_priv expects
       that timestamp to be within five minutes of the current time.
       Given the way the CVS server buffers up data, that can easily
       fail over a long network connection.  We trust krb_recvauth to
       guard against a replay attack.  */

    des_cbc_encrypt ((C_Block *) input, (C_Block *) output, aligned,
		     kd->sched, &kd->block, 1);

    *translated = aligned;

    return 0;
}



/* Create a Kerberos encryption buffer.  We use a packetizing buffer
   with Kerberos encryption translation routines.  */
struct buffer *
krb_encrypt_buffer_initialize( struct buffer *buf, int input,
                               Key_schedule sched, C_Block block,
                               void *memory( struct buffer * ) )
{
    struct krb_encrypt_data *kd;

    kd = (struct krb_encrypt_data *) xmalloc (sizeof *kd);
    memcpy (kd->sched, sched, sizeof (Key_schedule));
    memcpy (kd->block, block, sizeof (C_Block));

    return packetizing_buffer_initialize (buf,
					  input ? krb_encrypt_input : NULL,
					  input ? NULL : krb_encrypt_output,
					  kd,
					  memory);
}

#endif /* HAVE_KERBEROS */
#endif /* ENCRYPTION */
#endif /* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */



/* Output LEN bytes at STR.  If LEN is zero, then output up to (not including)
   the first '\0' byte.  */
void
cvs_output (const char *str, size_t len)
{
    if (len == 0)
	len = strlen (str);
#ifdef SERVER_SUPPORT
    if (error_use_protocol)
    {
	if (buf_to_net)
	{
	    buf_output (saved_output, str, len);
	    buf_copy_lines (buf_to_net, saved_output, 'M');
	}
# if HAVE_SYSLOG_H
	else
	    syslog (LOG_DAEMON | LOG_ERR,
		    "Attempt to write message after close of network buffer.  "
		    "Message was: %s",
		    str);
# endif /* HAVE_SYSLOG */
    }
    else if (server_active)
    {
	if (protocol)
	{
	    buf_output (saved_output, str, len);
	    buf_copy_lines (protocol, saved_output, 'M');
	    buf_send_counted (protocol);
	}
# if HAVE_SYSLOG_H
	else
	    syslog (LOG_DAEMON | LOG_ERR,
		    "Attempt to write message before initialization of "
		    "protocol buffer.  Message was: %s",
		    str);
# endif /* HAVE_SYSLOG */
    }
    else
#endif
    {
	size_t written;
	size_t to_write = len;
	const char *p = str;

	/* Local users that do 'cvs status 2>&1' on a local repository
	   may see the informational messages out-of-order with the
	   status messages unless we use the fflush (stderr) here. */
	fflush (stderr);

	while (to_write > 0)
	{
	    written = fwrite (p, 1, to_write, stdout);
	    if (written == 0)
		break;
	    p += written;
	    to_write -= written;
	}
    }
}

/* Output LEN bytes at STR in binary mode.  If LEN is zero, then
   output zero bytes.  */

void
cvs_output_binary (char *str, size_t len)
{
#ifdef SERVER_SUPPORT
    if (error_use_protocol || server_active)
    {
	struct buffer *buf;
	char size_text[40];

	if (error_use_protocol)
	    buf = buf_to_net;
	else
	    buf = protocol;

	assert (buf);

	if (!supported_response ("Mbinary"))
	{
	    error (0, 0, "\
this client does not support writing binary files to stdout");
	    return;
	}

	buf_output0 (buf, "Mbinary\012");
	sprintf (size_text, "%lu\012", (unsigned long) len);
	buf_output0 (buf, size_text);

	/* Not sure what would be involved in using buf_append_data here
	   without stepping on the toes of our caller (which is responsible
	   for the memory allocation of STR).  */
	buf_output (buf, str, len);

	if (!error_use_protocol)
	    buf_send_counted (protocol);
    }
    else
#endif
    {
	size_t written;
	size_t to_write = len;
	const char *p = str;
#ifdef USE_SETMODE_STDOUT
	int oldmode;
#endif

	/* Local users that do 'cvs status 2>&1' on a local repository
	   may see the informational messages out-of-order with the
	   status messages unless we use the fflush (stderr) here. */
	fflush (stderr);

#ifdef USE_SETMODE_STDOUT
	/* It is possible that this should be the same ifdef as
	   USE_SETMODE_BINARY but at least for the moment we keep them
	   separate.  Mostly this is just laziness and/or a question
	   of what has been tested where.  Also there might be an
	   issue of setmode vs. _setmode.  */
	/* The Windows doc says to call setmode only right after startup.
	   I assume that what they are talking about can also be helped
	   by flushing the stream before changing the mode.  */
	fflush (stdout);
	oldmode = _setmode (_fileno (stdout), OPEN_BINARY);
	if (oldmode < 0)
	    error (0, errno, "failed to setmode on stdout");
#endif

	while (to_write > 0)
	{
	    written = fwrite (p, 1, to_write, stdout);
	    if (written == 0)
		break;
	    p += written;
	    to_write -= written;
	}
#ifdef USE_SETMODE_STDOUT
	fflush (stdout);
	if (_setmode (_fileno (stdout), oldmode) != OPEN_BINARY)
	    error (0, errno, "failed to setmode on stdout");
#endif
    }
}



/* Like CVS_OUTPUT but output is for stderr not stdout.  */
void
cvs_outerr (const char *str, size_t len)
{
    if (len == 0)
	len = strlen (str);
#ifdef SERVER_SUPPORT
    if (error_use_protocol)
    {
	if (buf_to_net)
	{
	    buf_output (saved_outerr, str, len);
	    buf_copy_lines (buf_to_net, saved_outerr, 'E');
	}
# if HAVE_SYSLOG_H
	else
	    syslog (LOG_DAEMON | LOG_ERR,
		    "Attempt to write error message after close of network "
		    "buffer.  Message was: %s",
		    str);
# endif /* HAVE_SYSLOG */
    }
    else if (server_active)
    {
	if (protocol)
	{
	    buf_output (saved_outerr, str, len);
	    buf_copy_lines (protocol, saved_outerr, 'E');
	    buf_send_counted (protocol);
	}
# if HAVE_SYSLOG_H
	else
	    syslog (LOG_DAEMON | LOG_ERR,
		    "Attempt to write error message before initialization of "
		    "protocol buffer.  Message was: %s",
		    str);
# endif /* HAVE_SYSLOG */
    }
    else
#endif
    {
	size_t written;
	size_t to_write = len;
	const char *p = str;

	/* Make sure that output appears in order if stdout and stderr
	   point to the same place.  For the server case this is taken
	   care of by the fact that saved_outerr always holds less
	   than a line.  */
	fflush (stdout);

	while (to_write > 0)
	{
	    written = fwrite (p, 1, to_write, stderr);
	    if (written == 0)
		break;
	    p += written;
	    to_write -= written;
	}
    }
}



/* Flush stderr.  stderr is normally flushed automatically, of course,
   but this function is used to flush information from the server back
   to the client.  */
void
cvs_flusherr (void)
{
#ifdef SERVER_SUPPORT
    if (error_use_protocol)
    {
	/* skip the actual stderr flush in this case since the parent process
	 * on the server should only be writing to stdout anyhow
	 */
	/* Flush what we can to the network, but don't block.  */
	buf_flush (buf_to_net, 0);
    }
    else if (server_active)
    {
	/* make sure stderr is flushed before we send the flush count on the
	 * protocol pipe
	 */
	fflush (stderr);
	/* Send a special count to tell the parent to flush.  */
	buf_send_special_count (protocol, -2);
    }
    else
#endif
	fflush (stderr);
}



/* Make it possible for the user to see what has been written to
   stdout (it is up to the implementation to decide exactly how far it
   should go to ensure this).  */
void
cvs_flushout (void)
{
#ifdef SERVER_SUPPORT
    if (error_use_protocol)
    {
	/* Flush what we can to the network, but don't block.  */
	buf_flush (buf_to_net, 0);
    }
    else if (server_active)
    {
	/* Just do nothing.  This is because the code which
	   cvs_flushout replaces, setting stdout to line buffering in
	   main.c, didn't get called in the server child process.  But
	   in the future it is quite plausible that we'll want to make
	   this case work analogously to cvs_flusherr.

	   FIXME - DRP - I tried to implement this and triggered the following
	   error: "Protocol error: uncounted data discarded".  I don't need
	   this feature right now, so I'm not going to bother with it yet.
	 */
	buf_send_special_count (protocol, -1);
    }
    else
#endif
	fflush (stdout);
}



/* Output TEXT, tagging it according to TAG.  There are lots more
   details about what TAG means in cvsclient.texi but for the simple
   case (e.g. non-client/server), TAG is just "newline" to output a
   newline (in which case TEXT must be NULL), and any other tag to
   output normal text.

   Note that there is no way to output either \0 or \n as part of TEXT.  */

void
cvs_output_tagged (const char *tag, const char *text)
{
    if (text != NULL && strchr (text, '\n') != NULL)
	/* Uh oh.  The protocol has no way to cope with this.  For now
	   we dump core, although that really isn't such a nice
	   response given that this probably can be caused by newlines
	   in filenames and other causes other than bugs in CVS.  Note
	   that we don't want to turn this into "MT newline" because
	   this case is a newline within a tagged item, not a newline
	   as extraneous sugar for the user.  */
	assert (0);

    /* Start and end tags don't take any text, per cvsclient.texi.  */
    if (tag[0] == '+' || tag[0] == '-')
	assert (text == NULL);

#ifdef SERVER_SUPPORT
    if (server_active && supported_response ("MT"))
    {
	struct buffer *buf;

	if (error_use_protocol)
	    buf = buf_to_net;
	else
	    buf = protocol;

	buf_output0 (buf, "MT ");
	buf_output0 (buf, tag);
	if (text != NULL)
	{
	    buf_output (buf, " ", 1);
	    buf_output0 (buf, text);
	}
	buf_output (buf, "\n", 1);

	if (!error_use_protocol)
	    buf_send_counted (protocol);
    }
    else
#endif /* SERVER_SUPPORT */
    {
	/* No MT support or we are using a local repository. */
	if (strcmp (tag, "newline") == 0)
	    cvs_output ("\n", 1);
	else if (strcmp (tag, "date") == 0)
	{
#ifdef SERVER_SUPPORT
	    if (server_active)
		/* Output UTC when running as a server without MT support in
		 * the client since it is likely to be more meaningful than
	         * localtime.
		 */
		cvs_output (text, 0);
	    else
#endif /* SERVER_SUPPORT */
	    {
		char *date_in = xstrdup (text);
		char *date = format_date_alloc (date_in);
		cvs_output (date, 0);
		free (date);
		free (date_in);
	    }
	}
	else if (text != NULL)
	    cvs_output (text, 0);
    }
}
@


1.5
log
@update to cvs 1.12.10-MirOS except automatically
generated files
XXX this installs as /usr/bin/ncvs yet, so no
XXX conflicts during the test phase.
XXX I suggest to _not_ update.

XXX *** IMPORTANT *** DO NOT ACCESS CVS 1.11 REPOSITORIES
XXX *** IMPORTANT *** WITH CVS 1.12 OR VICE VERSA!
@
text
@d51 1
a51 11
/* This isn't defined anywhere else that I know of.  We made it up.  Referenced
 * both times this file can call gethostname.
 *
 * FIXME: This should probably correspond to any hostname length limits defined
 * by POSIX or some appropriate internet standard, but I'm not sure where to
 * look and I haven't heard any complaints.  If you happen to know the correct
 * standard, it should probably at least be referenced in this comment.
 */
# ifndef MAXHOSTNAMELEN
#   define MAXHOSTNAMELEN (256)
# endif
d111 2
a112 2
#ifdef HAVE_PAM
# include <security/pam_appl.h>
d115 1
a115 1
#endif
d129 1
a129 1
#ifdef PROXY_SUPPORT
d141 1
a141 1
#endif /* PROXY_SUPPORT */
d535 8
a546 4
    /* THISHOST is static so that it may be cached.  Our hostname will not
     * change from one call to the next.
     */
    static char *thishost = NULL;
d549 5
a553 8
    /* Our hostname must also match for this to be the primary.  */
    if (!thishost)
    {
	thishost = xmalloc (MAXHOSTNAMELEN);
	if (gethostname (thishost, MAXHOSTNAMELEN))
	    error (1, errno, "Failed to retrieve hostname.");
	thishost[MAXHOSTNAMELEN - 1] = '\0';
    }
d564 1
a564 1
    return !strcasecmp (thishost, hinfo->h_name);
d2487 19
d2761 2
a2762 10
    if (strlen (hostname) >= MAXHOSTNAMELEN)
    {
	pending_error = 0;
	if (alloc_pending (80))
	    strcpy (pending_error_text,
		    "E Protocol error; hostname too long.");
	return;
    }

    strcpy (hostname, arg);
d5540 4
a5543 1
    bool supported;
d5547 2
a5548 2
    supported = supported_response ("Redirect");
    if (config->PrimaryServer && supported
d5550 2
a5551 2
	/* I call isProxyServer() last because it is probably the slowest
	 * call due to the call to gethostname().
d5555 20
d5580 3
d5589 10
d5601 1
a5601 1
    if (proxy_log && supported)
d5630 2
a5631 1
 *   If referrer is set it may be disposed.
a5640 2
    if (referrer)
	free_cvsroot_t (referrer);
d5645 2
a5646 5
	/* The explicitness is to aid people who are writing clients.
	   I don't see how this information could help an
	   attacker.  */
	sprintf (pending_error_text, "\
E Protocol error: Invalid Referrer: `%s'",
d6900 4
a6903 4
    if ( check_pam_password(&username, password) )
#else
    if ( check_system_password(username, password) )
#endif
d7224 7
a7230 3
   pserver_authenticate_connection, and it handles success and failure
   the same way.  */

a7233 1
    char hostname[MAXHOSTNAMELEN];
d7245 1
a7245 2
    gethostname (hostname, sizeof hostname);
    hp = gethostbyname (hostname);
@


1.4
log
@heise says security fix
damn @@cvs for not providing a real fix, but just a new version
with a plethora of other changes like
-#include <foo>
-return (x);
+# include <foo>
+return x;

damn. they should take obsd as an example how to do it correctly.
@
text
@a10 1
#include <assert.h>
d16 1
d20 8
d29 2
a36 2
#   include <netdb.h>
#   include "xgssapi.h"
d41 1
a41 4
/* We need this to wrap data.  */
static gss_ctx_id_t gcontext;

static void gserver_authenticate_connection PROTO((void));
a45 7
#   ifdef ENCRYPTION
/* Whether to encrypt GSSAPI communication.  We use a global variable
   like this because we use the same buffer type (gssapi_wrap) to
   handle both authentication and encryption, and we don't want
   multiple instances of that buffer in the communication stream.  */
int cvs_gssapi_encrypt;
#   endif
d51 11
a61 3
#ifdef HAVE_WINSOCK_H
#include <winsock.h>
#endif
d63 3
a65 3
#if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_KERBEROS) || defined (HAVE_GSSAPI)
#include <sys/socket.h>
#endif
d67 3
a69 3
#ifdef HAVE_SYSLOG_H
#include <syslog.h>
#endif
d71 5
a75 5
#ifdef HAVE_KERBEROS
# include <netinet/in.h>
# include <krb.h>
# ifndef HAVE_KRB_GET_ERR_TEXT
#   define krb_get_err_text(status) krb_err_txt[status]
d78 7
d89 1
a89 1
#endif
d92 1
a92 1
#include "xselect.h"
d94 3
a96 11
#ifndef O_NONBLOCK
#define O_NONBLOCK O_NDELAY
#endif

/* EWOULDBLOCK is not defined by POSIX, but some BSD systems will
   return it, rather than EAGAIN, for nonblocking writes.  */
#ifdef EWOULDBLOCK
#define blocking_error(err) ((err) == EWOULDBLOCK || (err) == EAGAIN)
#else
#define blocking_error(err) ((err) == EAGAIN)
#endif
d99 3
a101 3
#if HAVE_INITGROUPS
#include <grp.h>
#endif /* HAVE_INITGROUPS */
d119 8
a126 7
/* Should we check for system usernames/passwords?  Can be changed by
   CVSROOT/config.  */
int system_auth = 1;

/* Should we disable Update-prog/Checkin-prog? Can be changed by
   CVSROOT/config.  */
int disable_x_prog = 0;
a127 1
# endif /* AUTH_SERVER_SUPPORT */
a128 1

d137 23
d173 1
a173 137
static void server_write_entries PROTO((void));

/* All server communication goes through buffer structures.  Most of
   the buffers are built on top of a file descriptor.  This structure
   is used as the closure field in a buffer.  */

struct fd_buffer
{
    /* The file descriptor.  */
    int fd;
    /* Nonzero if the file descriptor is in blocking mode.  */
    int blocking;
};

static struct buffer *fd_buffer_initialize
  PROTO ((int, int, void (*) (struct buffer *)));
static int fd_buffer_input PROTO((void *, char *, int, int, int *));
static int fd_buffer_output PROTO((void *, const char *, int, int *));
static int fd_buffer_flush PROTO((void *));
static int fd_buffer_block PROTO((void *, int));
static int fd_buffer_shutdown PROTO((void *));

/* Initialize a buffer built on a file descriptor.  FD is the file
   descriptor.  INPUT is nonzero if this is for input, zero if this is
   for output.  MEMORY is the function to call when a memory error
   occurs.  */

static struct buffer *
fd_buffer_initialize (fd, input, memory)
     int fd;
     int input;
     void (*memory) PROTO((struct buffer *));
{
    struct fd_buffer *n;

    n = (struct fd_buffer *) xmalloc (sizeof *n);
    n->fd = fd;
    n->blocking = 1;
    return buf_initialize (input ? fd_buffer_input : NULL,
			   input ? NULL : fd_buffer_output,
			   input ? NULL : fd_buffer_flush,
			   fd_buffer_block,
			   fd_buffer_shutdown,
			   memory,
			   n);
}

/* The buffer input function for a buffer built on a file descriptor.  */

static int
fd_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
     int size;
     int *got;
{
    struct fd_buffer *fd = (struct fd_buffer *) closure;
    int nbytes;

    if (! fd->blocking)
	nbytes = read (fd->fd, data, size);
    else
    {
	/* This case is not efficient.  Fortunately, I don't think it
           ever actually happens.  */
	nbytes = read (fd->fd, data, need == 0 ? 1 : need);
    }

    if (nbytes > 0)
    {
	*got = nbytes;
	return 0;
    }

    *got = 0;

    if (nbytes == 0)
    {
	/* End of file.  This assumes that we are using POSIX or BSD
           style nonblocking I/O.  On System V we will get a zero
           return if there is no data, even when not at EOF.  */
	return -1;
    }

    /* Some error occurred.  */

    if (blocking_error (errno))
    {
	/* Everything's fine, we just didn't get any data.  */
	return 0;
    }

    return errno;
}

/* The buffer output function for a buffer built on a file descriptor.  */

static int
fd_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
{
    struct fd_buffer *fd = (struct fd_buffer *) closure;

    *wrote = 0;

    while (have > 0)
    {
	int nbytes;

	nbytes = write (fd->fd, data, have);

	if (nbytes <= 0)
	{
	    if (! fd->blocking
		&& (nbytes == 0 || blocking_error (errno)))
	    {
		/* A nonblocking write failed to write any data.  Just
                   return.  */
		return 0;
	    }

	    /* Some sort of error occurred.  */

	    if (nbytes == 0)
	        return EIO;

	    return errno;
	}

	*wrote += nbytes;
	data += nbytes;
	have -= nbytes;
    }
d175 1
a175 27
    return 0;
}

/* The buffer flush function for a buffer built on a file descriptor.  */

/*ARGSUSED*/
static int
fd_buffer_flush (closure)
     void *closure;
{
    /* Nothing to do.  File descriptors are always flushed.  */
    return 0;
}

/* The buffer block function for a buffer built on a file descriptor.  */

static int
fd_buffer_block (closure, block)
     void *closure;
     int block;
{
    struct fd_buffer *fd = (struct fd_buffer *) closure;
    int flags;

    flags = fcntl (fd->fd, F_GETFL, 0);
    if (flags < 0)
	return errno;
a176 12
    if (block)
	flags &= ~O_NONBLOCK;
    else
	flags |= O_NONBLOCK;

    if (fcntl (fd->fd, F_SETFL, flags) < 0)
        return errno;

    fd->blocking = block;

    return 0;
}
a177 9
/* The buffer shutdown function for a buffer built on a file descriptor.  */

static int
fd_buffer_shutdown (closure)
     void *closure;
{
    free (closure);
    return 0;
}
a181 2
static int create_adm_p PROTO((char *, char *));

d183 1
a183 3
create_adm_p (base_dir, dir)
    char *base_dir;
    char *dir;
d193 1
a193 1
    p = malloc (strlen (dir) + 1);
d197 1
a197 1
    dir_where_cvsadm_lives = malloc (strlen (base_dir) + strlen (dir) + 100);
d203 1
a203 1
    tmp = malloc (strlen (base_dir) + strlen (dir) + 100);
d207 1
a207 1
    
d243 1
a243 1
	    empty = malloc (strlen (current_parsed_root->directory)
d270 1
a270 2
	    
	    
d354 1
a354 1
static int mkdir_p PROTO((char *));
d357 1
a357 2
mkdir_p (dir)
     char *dir;
d360 1
a360 1
    char *q = malloc (strlen (dir) + 1);
d414 1
a414 2
print_error (status)
    int status;
d442 1
a442 1
print_pending_error ()
d473 1
a473 1
static int alloc_pending PROTO ((size_t size));
d478 1
a478 2
alloc_pending (size)
    size_t size;
d485 1
a485 1
    pending_error_text = malloc (size);
a492 2

static void serve_is_modified PROTO ((char *));
d494 1
a494 1
static int supported_response PROTO ((char *));
d497 1
a497 2
supported_response (name)
     char *name;
d509 131
d641 1
a641 2
serve_valid_responses (arg)
     char *arg;
d646 8
a685 10
	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket subsystems on
	       NT and OS2 or dealing with windows and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

d693 89
d783 1
a783 2
serve_root (arg)
    char *arg;
d787 9
a795 2
    
    if (error_pending()) return;
d805 1
a805 1
    /* Sending "Root" twice is illegal.
d820 6
d829 1
a829 1
	if (strcmp (Pserver_Repos, arg) != 0)
d831 2
a832 1
	    if (alloc_pending (80 + strlen (Pserver_Repos) + strlen (arg)))
d838 2
a839 1
			 arg, Pserver_Repos);
a843 4
    if (current_parsed_root != NULL)
	free_cvsroot_t (current_parsed_root);
    current_parsed_root = local_cvsroot (arg);

d846 23
a868 1
    parse_config (current_parsed_root->directory);
d870 1
a870 1
    path = malloc (strlen (current_parsed_root->directory)
d879 1
a879 1
    if (readonlyfs == 0 && !isaccessible (path, R_OK | X_OK))
d889 1
a889 1
    env = malloc (strlen (CVSROOT_ENV) + strlen (current_parsed_root->directory) + 2);
d900 3
a902 1

d908 1
a908 2
server_pathname_check (path)
    char *path;
d910 3
d929 3
a931 1
	error (1, 0, "absolute pathname `%s' illegal for server", path);
d941 1
a941 1
static int outside_root PROTO ((char *));
d947 1
a947 2
outside_root (repos)
    char *repos;
d952 3
a954 4
    /* I think isabsolute (repos) should always be true, and that
       any RELATIVE_REPOS stuff should only be in CVS/Repository
       files, not the protocol (for compatibility), but I'm putting
       in the isabsolute check just in case.  */
d985 1
a985 1
static int outside_dir PROTO ((char *));
d991 1
a991 2
outside_dir (file)
    char *file;
d1004 3
a1006 1
	
d1013 1
a1013 2
serve_max_dotdot (arg)
    char *arg;
d1019 5
a1023 1
    if (lim < 0)
d1025 1
a1025 1
    p = malloc (strlen (server_temp_dir) + 2 * lim + 10);
d1039 5
a1043 2

static char *dir_name;
d1046 1
a1046 3
dirswitch (dir, repos)
    char *dir;
    char *repos;
d1052 3
d1066 3
a1068 2
	    sprintf (pending_error_text,
		     "E absolute pathname `%s' illegal for server", dir);
d1081 1
a1081 1
    /* Check for a trailing '/'.  This is not ISDIRSEP because \ in the
d1094 4
a1097 2
    if (dir_name != NULL)
	free (dir_name);
d1099 7
a1105 2
    dir_name = malloc (strlen (server_temp_dir) + dir_len + 40);
    if (dir_name == NULL)
a1109 4
    
    strcpy (dir_name, server_temp_dir);
    strcat (dir_name, "/");
    strcat (dir_name, dir);
d1111 5
a1115 1
    status = mkdir_p (dir_name);
d1119 2
a1120 2
	if (alloc_pending (80 + strlen (dir_name)))
	    sprintf (pending_error_text, "E cannot mkdir %s", dir_name);
d1134 2
a1135 2
	if (alloc_pending (80 + strlen (dir_name)))
	    sprintf (pending_error_text, "E cannot create_adm_p %s", dir_name);
d1140 1
a1140 1
    if ( CVS_CHDIR (dir_name) < 0)
d1143 2
a1144 2
	if (alloc_pending (80 + strlen (dir_name)))
	    sprintf (pending_error_text, "E cannot change to %s", dir_name);
d1155 1
a1155 1
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM)))
d1157 1
a1157 1
		     "E cannot mkdir %s/%s", dir_name, CVSADM);
d1171 1
a1171 1
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
d1173 1
a1173 1
		     "E cannot open %s/%s", dir_name, CVSADM_REP);
d1180 1
a1180 1
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
d1182 1
a1182 1
		     "E error writing %s/%s", dir_name, CVSADM_REP);
d1195 1
a1195 1
        if (fprintf (f, "/.") < 0)
d1198 1
a1198 1
	    if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
d1200 1
a1200 1
			 "E error writing %s/%s", dir_name, CVSADM_REP);
d1209 1
a1209 1
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
d1211 1
a1211 1
		     "E error writing %s/%s", dir_name, CVSADM_REP);
d1219 1
a1219 1
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
d1221 1
a1221 1
		     "E error closing %s/%s", dir_name, CVSADM_REP);
d1246 2
d1249 1
a1249 2
serve_repository (arg)
    char *arg;
d1251 4
d1261 2
d1264 1
a1264 2
serve_directory (arg)
    char *arg;
d1269 7
a1275 1
    status = buf_read_line (buf_from_net, &repos, (int *) NULL);
d1278 28
a1305 1
	if (!outside_root (repos))
d1311 1
a1311 1
        pending_error = ENOMEM;
d1313 1
a1313 1
    else
d1315 1
a1315 1
	pending_error_text = malloc (80 + strlen (arg));
d1333 3
a1335 1

d1337 1
a1337 2
serve_static_directory (arg)
    char *arg;
d1341 5
a1345 1
    if (error_pending ()) return;
d1366 2
d1369 1
a1369 2
serve_sticky (arg)
    char *arg;
d1373 5
a1377 1
    if (error_pending ()) return;
d1405 3
a1407 1

d1418 1
a1418 3
receive_partial_file (size, file)
     int size;
     int file;
d1422 2
a1423 1
	int status, nread;
d1433 1
a1433 1
		pending_error_text = malloc (80);
d1456 1
a1456 1
	    int nwrote;
d1461 1
a1461 1
	        int save_errno = errno;
d1469 2
a1470 1
		    int status, nread;
d1489 1
a1489 4
receive_file (size, file, gzipped)
     int size;
     char *file;
     int gzipped;
d1514 1
a1514 1
	int toread = size;
d1518 1
a1518 1
	filebuf = malloc (size);
d1524 2
a1525 1
	    int status, nread;
d1535 1
a1535 1
		    pending_error_text = malloc (80);
d1581 1
a1581 1
	char *p = realloc (pending_error_text,
d1602 2
d1612 130
a1741 1
static void serve_modified PROTO ((char *));
d1744 1
a1744 2
serve_modified (arg)
     char *arg;
d1746 3
a1748 1
    int size, status;
d1763 1
a1763 1
    status = buf_read_line (buf_from_net, &mode_text, (int *) NULL);
d1766 1
a1766 1
        if (status == -2)
d1770 1
a1770 1
	    pending_error_text = malloc (80 + strlen (arg));
d1789 1
a1789 1
    status = buf_read_line (buf_from_net, &size_text, (int *) NULL);
d1796 1
a1796 1
	    pending_error_text = malloc (80 + strlen (arg));
d1818 1
a1818 1
	size = atoi (size_text + 1);
d1821 1
a1821 1
	size = atoi (size_text);
d1824 9
d1835 1
a1835 1
        /* Now that we know the size, read and discard the file data.  */
d1838 2
a1839 1
	    int status, nread;
d1851 5
a1855 1
    if (outside_dir (arg))
d1861 7
a1867 1
    if (size >= 0)
d1869 2
a1870 6
	receive_file (size, arg, gzipped);
	if (error_pending ())
	{
	    free (mode_text);
	    return;
	}
d1873 7
d1919 2
a1920 1

d1922 1
a1922 2
serve_enable_unchanged (arg)
     char *arg;
d1924 8
a1933 6
struct an_entry {
    struct an_entry *next;
    char *entry;
};

static struct an_entry *entries;
a1934 1
static void serve_unchanged PROTO ((char *));
d1937 1
a1937 2
serve_unchanged (arg)
    char *arg;
d1944 5
a1948 2
    if (error_pending ())
	return;
d1962 10
a1971 1
	    timefield = strchr (cp + 1, '/') + 1;
d1992 22
a2013 2
	    /* If *TIMEFIELD wasn't "/", we assume that it was because of
	     * multiple calls to Is-Modified & Unchanged by the client and
d2018 4
a2021 2
	     * is allowed, but broken versions of WinCVS & TortoiseCVS rely on
	     * this behavior.
d2029 2
d2032 1
a2032 2
serve_is_modified (arg)
    char *arg;
a2034 1
    char *name;
d2036 26
a2061 3
    char *timefield;
    /* Have we found this file in "entries" yet.  */
    int found;
d2063 11
a2073 1
    if (error_pending ())
d2075 7
a2082 91
    if (outside_dir (arg))
	return;

    /* Rewrite entries file to have `M' in timestamp field.  */
    found = 0;
    for (p = entries; p != NULL; p = p->next)
    {
	name = p->entry + 1;
	cp = strchr (name, '/');
	if (cp != NULL
	    && strlen (arg) == cp - name
	    && strncmp (arg, name, cp - name) == 0)
	{
	    timefield = strchr (cp + 1, '/') + 1;
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
	    {
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
		cp = timefield + strlen (timefield);
		cp[1] = '\0';
		while (cp > timefield)
		{
		    *cp = cp[-1];
		    --cp;
		}
	    }
	    /* If *TIMEFIELD wasn't "/", we assume that it was because of
	     * multiple calls to Is-Modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of WinCVS & TortoiseCVS rely on
	     * this behavior.
	     */
	    *timefield = 'M';
	    if (kopt != NULL)
	    {
		if (alloc_pending (strlen (name) + 80))
		    sprintf (pending_error_text,
			     "E protocol error: both Kopt and Entry for %s",
			     arg);
		free (kopt);
		kopt = NULL;
		return;
	    }
	    found = 1;
	    break;
	}
    }
    if (!found)
    {
	/* We got Is-modified but no Entry.  Add a dummy entry.
	   The "D" timestamp is what makes it a dummy.  */
	p = (struct an_entry *) malloc (sizeof (struct an_entry));
	if (p == NULL)
	{
	    pending_error = ENOMEM;
	    return;
	}
	p->entry = malloc (strlen (arg) + 80);
	if (p->entry == NULL)
	{
	    pending_error = ENOMEM;
	    free (p);
	    return;
	}
	strcpy (p->entry, "/");
	strcat (p->entry, arg);
	strcat (p->entry, "//D/");
	if (kopt != NULL)
	{
	    strcat (p->entry, kopt);
	    free (kopt);
	    kopt = NULL;
	}
	strcat (p->entry, "/");
	p->next = entries;
	entries = p;
    }
}

static void serve_entry PROTO ((char *));
d2085 1
a2085 2
serve_entry (arg)
     char *arg;
d2087 5
a2091 29
    struct an_entry *p;
    char *cp;
    if (error_pending()) return;
    p = (struct an_entry *) malloc (sizeof (struct an_entry));
    if (p == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    /* Leave space for serve_unchanged to write '=' if it wants.  */
    cp = malloc (strlen (arg) + 2);
    if (cp == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (cp, arg);
    p->next = entries;
    p->entry = cp;
    entries = p;
}

static void serve_kopt PROTO ((char *));

static void
serve_kopt (arg)
     char *arg;
{
    if (error_pending ())
d2115 1
a2115 1
    kopt = malloc (strlen (arg) + 1);
d2124 1
a2124 1
static void serve_checkin_time PROTO ((char *));
d2127 1
a2127 2
serve_checkin_time (arg)
     char *arg;
d2129 7
a2135 1
    if (error_pending ())
d2147 1
a2147 2
    checkin_time = get_date (arg, NULL);
    if (checkin_time == (time_t)-1)
d2153 3
d2159 2
d2162 1
a2162 1
server_write_entries ()
d2176 4
a2179 4
           existing Entries file.  If we are checking out a module
           which explicitly lists more than one file in a particular
           directory, then we will wind up calling
           server_write_entries for each such file.  */
d2216 359
a2574 1

d2576 1
a2576 1
    /* Directory in which this notification happens.  malloc'd*/
d2579 4
a2582 1
    /* malloc'd.  */
d2585 1
a2585 1
    /* The following three all in one malloc'd block, pointed to by TYPE.
a2599 2
static void serve_notify PROTO ((char *));

d2601 1
a2601 2
serve_notify (arg)
    char *arg;
d2609 22
d2634 1
a2634 1
    if (dir_name == NULL)
d2637 1
a2637 1
    new = (struct notify_note *) malloc (sizeof (struct notify_note));
d2643 4
a2646 3
    new->dir = malloc (strlen (dir_name) + 1);
    new->filename = malloc (strlen (arg) + 1);
    if (new->dir == NULL || new->filename == NULL)
d2654 2
a2655 1
    strcpy (new->dir, dir_name);
d2658 1
a2658 1
    status = buf_read_line (buf_from_net, &data, (int *) NULL);
d2665 1
a2665 1
	    pending_error_text = malloc (80 + strlen (arg));
d2689 3
a2717 1
	{
a2718 1
	}
a2722 1
	{
a2723 1
	}
d2739 1
d2746 29
d2779 1
a2779 1
server_notify ()
d2784 2
d2788 1
a2788 1
	if ( CVS_CHDIR (notify_list->dir) < 0)
d2799 3
a2801 2
	notify_do (*notify_list->type, notify_list->filename, getcaller(),
		   notify_list->val, notify_list->watches, repos);
d2807 1
a2807 1
	        buf_append_char (buf_to_net, '.');
d2809 1
a2809 1
	        buf_output0 (buf_to_net, dir);
a2839 4

static int argument_count;
static char **argument_vector;
static int argument_vector_size;
d2841 7
d2849 1
a2849 2
serve_argument (arg)
     char *arg;
d2852 1
a2852 1
    
d2854 9
a2862 1
    
d2866 2
a2867 3
	argument_vector =
	    (char **) realloc ((char *)argument_vector,
			       argument_vector_size * sizeof (char *));
d2874 1
a2874 1
    p = malloc (strlen (arg) + 1);
d2884 5
d2890 1
a2890 2
serve_argumentx (arg)
     char *arg;
d2893 1
a2893 1
    
d2896 8
d2905 1
a2905 1
    p = realloc (p, strlen (p) + 1 + strlen (arg) + 1);
d2916 2
d2919 1
a2919 2
serve_global_option (arg)
    char *arg;
d2921 7
d2938 4
a2941 1
    {
d2944 1
a2954 3
	case 'l':
	    logoff = 1;
	    break;
d2956 1
a2956 1
	    trace = 1;
d2963 6
d2970 1
a2970 2
serve_set (arg)
    char *arg;
d2972 4
d2986 1
a2986 2
serve_kerberos_encrypt (arg)
     char *arg;
d2988 4
d3007 1
a3007 2
serve_gssapi_encrypt (arg)
     char *arg;
d3009 4
d3016 4
a3019 4
           authentication.  Flush everything we've output so far, and
           turn on encryption for future data.  On the input side, we
           should only have unwrapped as far as the Gssapi-encrypt
           command, so future unwrapping will become encrypted.  */
d3046 1
a3046 2
serve_gssapi_authenticate (arg)
     char *arg;
d3048 4
d3055 2
a3056 2
           That includes authentication, so we don't have to do
           anything further.  */
d3071 3
a3073 1

d3083 1
a3084 1
static int set_nonblock_fd PROTO((int));
a3085 4
/*
 * Set buffer BUF to non-blocking I/O.  Returns 0 for success or errno
 * code.
 */
d3087 2
a3088 3
static int
set_nonblock_fd (fd)
     int fd;
d3090 1
a3090 1
    int flags;
d3092 3
a3094 7
    flags = fcntl (fd, F_GETFL, 0);
    if (flags < 0)
	return errno;
    if (fcntl (fd, F_SETFL, flags | O_NONBLOCK) < 0)
	return errno;
    return 0;
}
d3096 1
a3096 9
#endif /* SERVER_FLOWCONTROL */

static void serve_questionable PROTO((char *));

static void
serve_questionable (arg)
    char *arg;
{
    static int initted;
d3106 1
a3106 1
    if (dir_name == NULL)
d3108 3
a3110 1
	buf_output0 (buf_to_net, "E Protocol error: 'Directory' missing");
d3122 1
a3122 1
	update_dir = dir_name + strlen (server_temp_dir) + 1;
a3132 1
static void serve_case PROTO ((char *));
d3134 2
a3135 8
static void
serve_case (arg)
    char *arg;
{
    ign_case = 1;
}

static struct buffer *protocol;
d3141 1
a3143 7

static void
protocol_memory_error (buf)
    struct buffer *buf;
{
    error (1, ENOMEM, "Virtual memory exhausted");
}
d3145 1
a3145 5
/*
 * Process IDs of the subprocess, or negative if that subprocess
 * does not exist.
 */
static pid_t command_pid;
d3148 1
a3148 2
outbuf_memory_error (buf)
    struct buffer *buf;
d3150 1
a3150 17
    static const char msg[] = "E Fatal server error\n\
error ENOMEM Virtual memory exhausted.\n";
    if (command_pid > 0)
	kill (command_pid, SIGTERM);

    /*
     * We have arranged things so that printing this now either will
     * be legal, or the "E fatal error" line will get glommed onto the
     * end of an existing "E" or "M" response.
     */

    /* If this gives an error, not much we could do.  syslog() it?  */
    write (STDOUT_FILENO, msg, sizeof (msg) - 1);
#ifdef HAVE_SYSLOG_H
    syslog (LOG_DAEMON | LOG_ERR, "virtual memory exhausted");
#endif
    error_exit ();
a3152 7
static void
input_memory_error (buf)
     struct buffer *buf;
{
    outbuf_memory_error (buf);
}

d3155 3
a3157 3
/* If command is legal, return 1.
 * Else if command is illegal and croak_on_illegal is set, then die.
 * Else just return 0 to indicate that command is illegal.
d3159 2
a3160 3
static int
check_command_legal_p (cmd_name)
    char *cmd_name;
d3162 1
a3162 1
    /* Right now, only pserver notices illegal commands -- namely,
d3169 1
a3169 1
        return 1;
d3173 30
a3202 30
        /* This command has the potential to modify the repository, so
         * we check if the user have permission to do that.
         *
         * (Only relevant for remote users -- local users can do
         * whatever normal Unix file permissions allow them to do.)
         *
         * The decision method:
         *
         *    If $CVSROOT/CVSADMROOT_READERS exists and user is listed
         *    in it, then read-only access for user.
         *
         *    Or if $CVSROOT/CVSADMROOT_WRITERS exists and user NOT
         *    listed in it, then also read-only access for user.
         *
         *    Else read-write access for user.
         */

         char *linebuf = NULL;
         int num_red = 0;
         size_t linebuf_len = 0;
         char *fname;
         size_t flen;
         FILE *fp;
         int found_it = 0;
         
         /* else */
         flen = strlen (current_parsed_root->directory)
                + strlen (CVSROOTADM)
                + strlen (CVSROOTADM_READERS)
                + 3;
d3204 2
a3205 2
         fname = xmalloc (flen);
         (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
d3208 1
a3208 1
         fp = fopen (fname, "r");
d3210 1
a3210 1
         if (fp == NULL)
d3218 1
a3218 1
		 return 0;
d3232 1
a3232 1
                 if (linebuf[num_red - 1] == '\n')
d3236 1
a3236 1
                     goto handle_illegal;
d3241 3
a3243 3
             /* If not listed specifically as a reader, then this user
                has write access by default unless writers are also
                specified in a file . */
d3246 1
a3246 1
         }
d3251 4
a3254 4
         flen = strlen (current_parsed_root->directory)
                + strlen (CVSROOTADM)
                + strlen (CVSROOTADM_WRITERS)
                + 3;
d3256 2
a3257 2
         fname = xmalloc (flen);
         (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
d3260 1
a3260 1
         fp = fopen (fname, "r");
d3262 2
a3263 2
         if (fp == NULL)
         {
d3265 1
a3265 1
	         free (linebuf);
d3271 1
a3271 1
		 return 1;
d3279 1
a3279 1
		 return 0;
d3281 8
a3288 1
         }
d3290 6
a3295 13
         found_it = 0;
         while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
         {
             /* Chop newline by hand, for strcmp()'s sake. */
             if (linebuf[num_red - 1] == '\n')
                 linebuf[num_red - 1] = '\0';
           
             if (strcmp (linebuf, CVS_Username) == 0)
             {
                 found_it = 1;
                 break;
             }
         }
d3299 3
a3301 3
         if (found_it)
         {
             if (fclose (fp) < 0)
d3303 2
a3304 2
             if (linebuf)
                 free (linebuf);
d3306 1
a3306 1
             return 1;
d3310 1
a3310 1
         handle_illegal:
d3313 2
a3314 2
             if (linebuf)
                 free (linebuf);
d3316 2
a3317 2
	     return 0;
         }
d3321 2
a3322 2
    /* If ever reach end of this function, command must be legal. */
    return 1;
d3326 1
a3326 1

d3330 1
d3332 1
d3338 23
d3362 1
a3362 3
do_cvs_command (cmd_name, command)
    char *cmd_name;
    int (*command) PROTO((int argc, char **argv));
d3379 1
a3379 1
    
d3384 45
d3442 1
a3442 1
    /* Global `command_name' is probably "server" right now -- only
d3444 1
a3444 1
       parameter `cmd_name' to determine if this command is legal for
d3446 1
a3446 1
    if (!check_command_legal_p (cmd_name))
d3452 2
a3453 1
	buf_output0 (buf_to_net, "\" requires write access to the repository\n\
d3457 1
d3542 1
a3542 1
	protocol = fd_buffer_initialize (protocol_pipe[1], 0,
d3546 12
a3557 4
           buf_from_net.  Instead, everything should go through
           protocol.  */
	buf_to_net = NULL;
	buf_from_net = NULL;
d3560 2
a3561 2
           Since we're now in the child, we should use the simpler
           protocol_memory_error function.  */
d3590 1
d3593 2
d3611 25
a3635 3
	/*
	 * When we exit, that will close the pipes, giving an EOF to
	 * the parent.
d3637 2
a3638 1
	buf_free (protocol);
d3657 1
a3657 2
	if (stderr_pipe[0] > num_to_check)
	  num_to_check = stderr_pipe[0];
d3659 1
a3659 2
	if (protocol_pipe[0] > num_to_check)
	  num_to_check = protocol_pipe[0];
d3661 2
a3662 2
	if (STDOUT_FILENO > num_to_check)
	  num_to_check = STDOUT_FILENO;
d3664 1
d3678 1
a3678 1
	stdoutbuf = fd_buffer_initialize (stdout_pipe[0], 1,
d3681 1
a3681 1
	stderrbuf = fd_buffer_initialize (stderr_pipe[0], 1,
d3684 1
a3684 1
	protocol_inbuf = fd_buffer_initialize (protocol_pipe[0], 1,
d3742 2
a3745 2
	    struct timeval *timeout_ptr;
	    struct timeval timeout;
d3808 2
a3809 2
                   as I know there was never any reason to do that and
                   SCO doesn't let you select on exceptions on pipes.  */
d3811 1
a3811 1
				 (fd_set *)0, timeout_ptr);
d3837 2
a3838 2
		int count_read;
		
d3909 1
a3909 1
	        int status;
d3911 1
a3911 1
	        status = buf_input_data (stdoutbuf, (int *) NULL);
d3934 1
a3934 1
	        int status;
d3936 1
a3936 1
	        status = buf_input_data (stderrbuf, (int *) NULL);
d3996 1
a3996 1
	    
d4001 2
a4002 2
	        int sig = WTERMSIG (status);
	        char buf[50];
d4014 2
a4015 2
		/* Test for a core dump.  Is this portable?  */
		if (status & 0x80)
d4037 1
d4040 1
d4043 1
d4098 3
a4100 1

d4107 1
a4107 1
server_pause_check()
d4128 1
a4128 1
	
d4130 1
a4130 2
	    numfds = select (numtocheck, &fds, (fd_set *)0,
			     (fd_set *)0, (struct timeval *)NULL);
d4139 1
a4139 1
	    
d4155 2
a4156 2
               I/O.  System V nonblocking I/O returns zero if there is
               nothing to read.  */
d4158 1
a4158 1
	        error (1, 0, "flow control EOF");
d4161 1
a4161 1
	        error (1, errno, "flow control read failed");
d4167 3
a4169 1

d4173 1
a4173 1
static void output_dir PROTO((char *, char *));
d4176 1
a4176 3
output_dir (update_dir, repository)
    char *update_dir;
    char *repository;
d4178 4
d4192 4
a4195 1
    buf_output0 (protocol, repository);
d4198 3
a4200 1

d4219 2
d4222 3
a4224 8
server_register (name, version, timestamp, options, tag, date, conflict)
    char *name;
    char *version;
    char *timestamp;
    char *options;
    char *tag;
    char *date;
    char *conflict;
d4231 4
a4234 9
    if (trace)
    {
	(void) fprintf (stderr,
			"%s-> server_register(%s, %s, %s, %s, %s, %s, %s)\n",
			CLIENT_SERVER_STR,
			name, version, timestamp ? timestamp : "", options,
			tag ? tag : "", date ? date : "",
			conflict ? conflict : "");
    }
d4263 1
a4263 1
    
d4285 2
d4288 1
a4288 2
server_scratch (fname)
    char *fname;
d4319 1
a4319 1
server_scratch_entry_only ()
d4326 1
a4326 1
new_entries_line ()
d4340 2
a4341 1

d4344 1
a4344 2
serve_ci (arg)
    char *arg;
d4349 2
d4352 2
a4353 4
checked_in_response (file, update_dir, repository)
    char *file;
    char *update_dir;
    char *repository;
d4385 2
a4386 4
server_checked_in (file, update_dir, repository)
    char *file;
    char *update_dir;
    char *repository;
d4411 3
a4413 5
server_update_entries (file, update_dir, repository, updated)
    char *file;
    char *update_dir;
    char *repository;
    enum server_updated_arg4 updated;
d4432 1
a4432 1

d4434 1
a4434 2
serve_update (arg)
    char *arg;
d4440 1
a4440 2
serve_diff (arg)
    char *arg;
d4446 1
a4446 2
serve_log (arg)
    char *arg;
d4452 1
a4452 2
serve_rlog (arg)
    char *arg;
a4453 2
    /* Tell cvslog() to behave like rlog not log.  */
    command_name = "rlog";
d4458 13
a4470 2
serve_add (arg)
    char *arg;
d4476 1
a4476 2
serve_remove (arg)
    char *arg;
d4482 1
a4482 2
serve_status (arg)
    char *arg;
d4488 1
a4488 2
serve_rdiff (arg)
    char *arg;
d4494 1
a4494 2
serve_tag (arg)
    char *arg;
d4496 1
a4496 1
    do_cvs_command ("cvstag", cvstag);
d4500 1
a4500 2
serve_rtag (arg)
    char *arg;
a4501 2
    /* Tell cvstag() to behave like rtag not tag.  */
    command_name = "rtag";
d4506 1
a4506 2
serve_import (arg)
    char *arg;
d4512 1
a4512 2
serve_admin (arg)
    char *arg;
d4518 1
a4518 2
serve_history (arg)
    char *arg;
d4524 1
a4524 2
serve_release (arg)
    char *arg;
d4529 1
a4529 1
static void serve_watch_on PROTO ((char *));
d4532 1
a4532 2
serve_watch_on (arg)
    char *arg;
d4534 1
a4534 1
    do_cvs_command ("watch_on", watch_on);
a4536 2
static void serve_watch_off PROTO ((char *));

d4538 1
a4538 2
serve_watch_off (arg)
    char *arg;
d4540 1
a4540 1
    do_cvs_command ("watch_off", watch_off);
a4542 2
static void serve_watch_add PROTO ((char *));

d4544 1
a4544 2
serve_watch_add (arg)
    char *arg;
d4546 1
a4546 1
    do_cvs_command ("watch_add", watch_add);
a4548 2
static void serve_watch_remove PROTO ((char *));

d4550 1
a4550 2
serve_watch_remove (arg)
    char *arg;
d4552 1
a4552 1
    do_cvs_command ("watch_remove", watch_remove);
a4554 2
static void serve_watchers PROTO ((char *));

d4556 1
a4556 2
serve_watchers (arg)
    char *arg;
d4561 5
a4565 1
static void serve_editors PROTO ((char *));
d4568 1
a4568 2
serve_editors (arg)
    char *arg;
d4570 1
a4570 1
    do_cvs_command ("editors", editors);
a4572 1
static void serve_noop PROTO ((char *));
d4574 6
d4581 1
a4581 2
serve_noop (arg)
    char *arg;
d4583 4
d4588 17
a4604 4
    server_write_entries ();
    if (!print_pending_error ())
    {
	(void) server_notify ();
a4605 1
    }
d4609 1
a4609 1
static void serve_version PROTO ((char *));
d4612 1
a4612 2
serve_version (arg)
    char *arg;
a4616 2
static void serve_init PROTO ((char *));

d4618 1
a4618 2
serve_init (arg)
    char *arg;
d4620 2
d4624 17
a4640 5
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E Root %s must be an absolute pathname", arg);
	/* Fall through to do_cvs_command which will return the
	   actual error.  */
d4642 1
d4644 4
a4647 2
    if (current_parsed_root != NULL)
	free_cvsroot_t (current_parsed_root);
d4651 2
a4654 2
static void serve_annotate PROTO ((char *));

d4656 1
a4656 2
serve_annotate (arg)
    char *arg;
a4660 2
static void serve_rannotate PROTO ((char *));

d4662 1
a4662 2
serve_rannotate (arg)
    char *arg;
a4663 2
    /* Tell annotate() to behave like rannotate not annotate.  */
    command_name = "rannotate";
d4666 1
a4666 1

d4668 1
a4668 2
serve_co (arg)
    char *arg;
d4676 23
d4705 1
a4705 1
	tempdir = malloc (strlen (server_temp_dir) + 80);
d4724 1
a4724 1
	if ( CVS_CHDIR (tempdir) < 0)
d4736 1
a4736 1
    /* Compensate for server_export()'s setting of command_name.
d4741 3
a4743 3
    do_cvs_command ((strcmp (command_name, "export") == 0) ?
                    "export" : "checkout",
                    checkout);
d4747 1
a4747 2
serve_export (arg)
    char *arg;
d4750 1
a4750 1
    command_name = "export";
d4753 3
a4755 1

d4757 2
a4758 5
server_copy_file (file, update_dir, repository, newfile)
    char *file;
    char *update_dir;
    char *repository;
    char *newfile;
d4779 1
a4779 3
server_modtime (finfo, vers_ts)
    struct file_info *finfo;
    Vers_TS *vers_ts;
d4800 2
a4802 3

#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
/* Need to prototype because mode_t might be smaller than int.  */
a4810 10
#else
void
server_updated (finfo, vers, updated, mode, checksum, filebuf)
    struct file_info *finfo;
    Vers_TS *vers;
    enum server_updated_arg4 updated;
    mode_t mode;
    unsigned char *checksum;
    struct buffer *filebuf;
#endif
d4823 1
d4886 1
a4886 1
	        int i;
d4889 1
a4889 1
	        buf_output0 (protocol, "Checksum ");
d4920 1
a4920 1
	    entnode = (Entnode *)node->data;
d4938 1
a4938 1
        {
d4978 3
a4980 3
                   file_gzip_level is set.  We could handle this case,
                   but it's not worth it since this case never arises
                   with a current client and server.  */
a5027 1
	{
a5028 2
	    buf_free (filebuf);
	}
d5103 1
a5103 1
server_use_rcs_diff ()
d5108 2
d5111 1
a5111 3
server_set_entstat (update_dir, repository)
    char *update_dir;
    char *repository;
d5124 2
d5127 1
a5127 3
server_clear_entstat (update_dir, repository)
     char *update_dir;
     char *repository;
d5142 3
a5144 1

d5146 2
a5147 6
server_set_sticky (update_dir, repository, tag, date, nonbranch)
    char *update_dir;
    char *repository;
    char *tag;
    char *date;
    int nonbranch;
d5188 15
a5202 1

d5205 2
a5206 2
    char *update_dir;
    char *repository;
a5208 4
/* Here as a static until we get around to fixing Parse_Info to pass along
   a void * for it.  */
static struct template_proc_data *tpd;

d5210 1
a5210 3
template_proc (repository, template)
    char *repository;
    char *template;
d5216 1
a5216 1
    struct template_proc_data *data = tpd;
d5249 1
d5255 34
d5290 1
a5290 3
server_template (update_dir, repository)
    char *update_dir;
    char *repository;
d5295 2
a5296 2
    tpd = &data;
    (void) Parse_Info (CVSROOTADM_RCSINFO, repository, template_proc, 1);
d5298 3
a5300 1

d5302 1
a5302 2
serve_gzip_contents (arg)
     char *arg;
d5305 5
d5316 2
d5319 1
a5319 2
serve_gzip_stream (arg)
     char *arg;
d5322 7
d5335 12
a5348 2
    buf_from_net = compress_buffer_initialize (buf_from_net, 1, level,
					       buf_from_net->memory_error);
d5350 3
a5352 1

d5355 1
a5355 2
serve_wrapper_sendme_rcs_options (arg)
     char *arg;
d5365 4
d5372 2
a5373 2
         wrapper_line;
         wrap_unparse_rcs_options (&wrapper_line, 0))
d5387 2
a5388 1

d5390 1
a5390 2
serve_ignore (arg)
    char *arg;
d5397 3
d5401 3
a5403 1

d5405 1
a5405 11
expand_proc (argc, argv, where, mwhere, mfile, shorten,
	     local_specified, omodule, msg)
    int argc;
    char **argv;
    char *where;
    char *mwhere;
    char *mfile;
    int shorten;
    int local_specified;
    char *omodule;
    char *msg;
d5435 1
a5435 1
           of aliases before removing */
d5451 1
a5451 1
	        buf_output0 (buf_to_net, "Module-expansion ");
d5468 1
a5468 2
serve_expand_modules (arg)
    char *arg;
d5471 1
a5471 1
    int err;
a5472 1
    err = 0;
d5474 20
a5493 9
    server_expanding = 1;
    db = open_module ();
    for (i = 1; i < argument_count; i++)
	err += do_module (db, argument_vector[i],
			  CHECKOUT, "Updating", expand_proc,
			  NULL, 0, 0, 0, 0,
			  (char *) NULL);
    close_module (db);
    server_expanding = 0;
a5503 5
    if (err)
	/* We will have printed an error message already.  */
	buf_output0 (buf_to_net, "error  \n");
    else
	buf_output0 (buf_to_net, "ok\n");
d5505 9
a5513 4
    /* The client is waiting for the module expansions, so we must
       send the output now.  */
    buf_flush (buf_to_net, 1);
}
d5515 3
a5517 20
void
server_prog (dir, name, which)
    char *dir;
    char *name;
    enum progs which;
{
    if (!supported_response ("Set-checkin-prog"))
    {
	buf_output0 (buf_to_net, "E \
warning: this client does not support -i or -u flags in the modules file.\n");
	return;
    }
    switch (which)
    {
	case PROG_CHECKIN:
	    buf_output0 (buf_to_net, "Set-checkin-prog ");
	    break;
	case PROG_UPDATE:
	    buf_output0 (buf_to_net, "Set-update-prog ");
	    break;
a5518 4
    buf_output0 (buf_to_net, dir);
    buf_append_char (buf_to_net, '\n');
    buf_output0 (buf_to_net, name);
    buf_append_char (buf_to_net, '\n');
d5521 14
d5536 1
a5536 2
serve_checkin_prog (arg)
    char *arg;
d5538 1
a5538 1
    FILE *f;
d5540 1
a5540 9
    /* Before we do anything we first check if this command is not 
       disabled. */
    if (disable_x_prog)
    {
	if (alloc_pending (80))
	    sprintf (pending_error_text, "\
E Checkin-prog disabled by configuration");
	return;
    }
d5542 7
a5548 2
    f = CVS_FOPEN (CVSADM_CIPROG, "w+");
    if (f == NULL)
d5550 5
a5554 5
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_CIPROG);
	pending_error = save_errno;
	return;
d5556 1
a5556 1
    if (fprintf (f, "%s\n", arg) < 0)
d5558 3
a5560 6
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text,
		     "E cannot write to %s", CVSADM_CIPROG);
	pending_error = save_errno;
	return;
d5562 2
a5563 1
    if (fclose (f) == EOF)
d5565 14
a5578 5
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_CIPROG);
	pending_error = save_errno;
	return;
d5580 1
d5583 14
d5598 1
a5598 2
serve_update_prog (arg)
    char *arg;
d5600 1
a5600 1
    FILE *f;
d5602 3
a5604 21
    /* Before we do anything we first check if this command is not 
       disabled. */
    if (disable_x_prog)
    {
	if (alloc_pending (80))
	    sprintf (pending_error_text, "\
E Update-prog disabled by configuration");
	return;
    }
    
    /* Before we do anything we need to make sure we are not in readonly
       mode.  */
    if (!check_command_legal_p ("commit"))
    {
	/* I might be willing to make this a warning, except we lack the
	   machinery to do so.  */
	if (alloc_pending (80))
	    sprintf (pending_error_text, "\
E Flag -u in modules not allowed in readonly mode");
	return;
    }
d5606 8
a5613 25
    f = CVS_FOPEN (CVSADM_UPROG, "w+");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_UPROG);
	pending_error = save_errno;
	return;
    }
    if (fprintf (f, "%s\n", arg) < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot write to %s", CVSADM_UPROG);
	pending_error = save_errno;
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_UPROG);
	pending_error = save_errno;
	return;
    }
d5615 4
a5618 2

static void serve_valid_requests PROTO((char *arg));
d5621 4
a5625 1

d5645 2
d5649 1
a5652 2
  REQ_LINE("Checkin-prog", serve_checkin_prog, 0),
  REQ_LINE("Update-prog", serve_update_prog, 0),
d5666 2
a5668 1
  REQ_LINE("Case", serve_case, 0),
d5674 2
a5675 2
           serve_wrapper_sendme_rcs_options,
           0),
d5695 8
d5722 1
d5732 3
a5735 1
#endif /* SERVER_SUPPORT or CLIENT_SUPPORT */
d5737 3
a5739 1

d5741 1
a5741 2
serve_valid_requests (arg)
     char *arg;
d5744 12
a5755 1
    if (print_pending_error ())
d5757 1
d5774 2
d5782 1
a5782 2
static void wait_sig (sig)
     int sig;
a5784 2
    int save_errno = errno;

a5787 1
    errno = save_errno;
d5791 52
d5844 1
a5844 2
server_cleanup (sig)
    int sig;
d5846 1
a5846 27
    /* Do "rm -rf" on the temp directory.  */
    static int called = 0;
    int status;
    int save_noexec;

    if (called++)
	return;

    /* already processing cleanup, do not want recursion */
#ifdef SIGABRT
    (void) SIG_deregister (SIGABRT, server_cleanup);
#endif
#ifdef SIGHUP
    (void) SIG_deregister (SIGHUP, server_cleanup);
#endif
#ifdef SIGINT
    (void) SIG_deregister (SIGINT, server_cleanup);
#endif
#ifdef SIGQUIT
    (void) SIG_deregister (SIGQUIT, server_cleanup);
#endif
#ifdef SIGPIPE
    (void) SIG_deregister (SIGPIPE, server_cleanup);
#endif
#ifdef SIGTERM
    (void) SIG_deregister (SIGTERM, server_cleanup);
#endif
d5848 1
a5848 9
    if (buf_to_net != NULL)
    {
	/* FIXME: If this is not the final call from server, this
	   could deadlock, because the client might be blocked writing
	   to us.  This should not be a problem in practice, because
	   we do not generate much output when the client is not
	   waiting for it.  */
	set_block (buf_to_net);
	buf_flush (buf_to_net, 1);
d5850 6
a5855 5
	/* The calls to buf_shutdown are currently only meaningful
	   when we are using compression.  First we shut down
	   BUF_FROM_NET.  That will pick up the checksum generated
	   when the client shuts down its buffer.  Then, after we have
	   generated any final output, we shut down BUF_TO_NET.  */
d5857 4
a5860 7
	status = buf_shutdown (buf_from_net);
	if (status != 0)
	{
	    error (0, status, "shutting down buffer from client");
	    buf_flush (buf_to_net, 1);
	}
    }
d5862 7
a5868 1
    if (dont_delete_temp)
d5871 10
a5880 3
	    (void) buf_shutdown (buf_to_net);
	return;
    }
d5882 4
a5885 12
    /* What a bogus kludge.  This disgusting code makes all kinds of
       assumptions about SunOS, and is only for a bug in that system.
       So only enable it on Suns.  */
#ifdef SUNOS_KLUDGE
    if (command_pid > 0)
    {
	/* To avoid crashes on SunOS due to bugs in SunOS tmpfs
	   triggered by the use of rename() in RCS, wait for the
	   subprocess to die.  Unfortunately, this means draining output
	   while waiting for it to unblock the signal we sent it.  Yuck!  */
	int status;
	pid_t r;
d5887 2
a5888 17
	signal (SIGCHLD, wait_sig);
	if (sig)
	    /* Perhaps SIGTERM would be more correct.  But the child
	       process will delay the SIGINT delivery until its own
	       children have exited.  */
	    kill (command_pid, SIGINT);
	/* The caller may also have sent a signal to command_pid, so
	   always try waiting.  First, though, check and see if it's still
	   there....  */
    do_waitpid:
	r = waitpid (command_pid, &status, WNOHANG);
	if (r == 0)
	    ;
	else if (r == command_pid)
	    command_pid_is_dead++;
	else if (r == -1)
	    switch (errno)
d5890 5
a5894 5
		case ECHILD:
		    command_pid_is_dead++;
		    break;
		case EINTR:
		    goto do_waitpid;
d5896 4
a5899 4
	else
	    /* waitpid should always return one of the above values */
	    abort ();
	while (!command_pid_is_dead)
d5901 16
a5916 4
	    struct timeval timeout;
	    struct fd_set_wrapper readfds;
	    char buf[100];
	    int i;
d5918 17
a5934 16
	    /* Use a non-zero timeout to avoid eating up CPU cycles.  */
	    timeout.tv_sec = 2;
	    timeout.tv_usec = 0;
	    readfds = command_fds_to_drain;
	    switch (select (max_command_fd + 1, &readfds.fds,
			    (fd_set *)0, (fd_set *)0,
			    &timeout))
	    {
		case -1:
		    if (errno != EINTR)
			abort ();
		case 0:
		    /* timeout */
		    break;
		case 1:
		    for (i = 0; i <= max_command_fd; i++)
d5936 5
a5940 5
			if (!FD_ISSET (i, &readfds.fds))
			    continue;
			/* this fd is non-blocking */
			while (read (i, buf, sizeof (buf)) >= 1)
			    ;
d5942 2
a5943 2
		    break;
		default:
d5945 34
d5980 33
d6014 1
a6015 1
#endif /* SUNOS_KLUDGE */
d6017 4
a6020 14
    CVS_CHDIR (Tmpdir);
    /* Temporarily clear noexec, so that we clean up our temp directory
       regardless of it (this could more cleanly be handled by moving
       the noexec check to all the unlink_file_dir callers from
       unlink_file_dir itself).  */
    save_noexec = noexec;
    noexec = 0;
    /* FIXME?  Would be nice to not ignore errors.  But what should we do?
       We could try to do this before we shut down the network connection,
       and try to notify the client (but the client might not be waiting
       for responses).  We could try something like syslog() or our own
       log file.  */
    unlink_file_dir (orig_server_temp_dir);
    noexec = save_noexec;
d6022 5
a6026 3
    if (buf_to_net != NULL)
	(void) buf_shutdown (buf_to_net);
}
a6028 1
int server_expanding = 0;
d6031 1
a6031 3
server (argc, argv)
     int argc;
     char **argv;
d6033 2
d6047 56
a6102 3
    buf_to_net = fd_buffer_initialize (STDOUT_FILENO, 0,
				       outbuf_memory_error);
    buf_from_net = stdio_buffer_initialize (stdin, 1, outbuf_memory_error);
d6134 1
a6134 1
	    server_temp_dir = malloc (strlen (Tmpdir) + 80);
a6143 11
		/* I'm doing this manually rather than via error_exit ()
		   because I'm not sure whether we want to call server_cleanup.
		   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
		/* Hook for OS-specific behavior, for example socket
		   subsystems on NT and OS2 or dealing with windows
		   and arguments on Mac.  */
		SYSTEM_CLEANUP ();
#endif

d6166 2
a6167 2
               700, to discourage random people from tampering with
               it.  */
d6170 1
a6170 1
	        static const char suffix[] = "abcdefghijklmnopqrstuvwxyz";
d6172 1
a6172 1
	        if (i >= sizeof suffix - 1) break;
a6207 19
#ifdef SIGABRT
    (void) SIG_register (SIGABRT, server_cleanup);
#endif
#ifdef SIGHUP
    (void) SIG_register (SIGHUP, server_cleanup);
#endif
#ifdef SIGINT
    (void) SIG_register (SIGINT, server_cleanup);
#endif
#ifdef SIGQUIT
    (void) SIG_register (SIGQUIT, server_cleanup);
#endif
#ifdef SIGPIPE
    (void) SIG_register (SIGPIPE, server_cleanup);
#endif
#ifdef SIGTERM
    (void) SIG_register (SIGTERM, server_cleanup);
#endif

d6212 1
a6212 24
    argument_vector =
	(char **) malloc (argument_vector_size * sizeof (char *));
    if (argument_vector == NULL)
    {
	/*
	 * Strictly speaking, we're not supposed to output anything
	 * now.  But we're about to exit(), give it a try.
	 */
	printf ("E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");

	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif

	exit (EXIT_FAILURE);
    }

a6215 1
       FIXME: probably should be using program_name here.
d6221 3
a6223 1
    argument_vector[0] = "cvs server";
d6230 2
a6231 2
	
	status = buf_read_line (buf_from_net, &cmd, (int *) NULL);
d6288 1
a6288 1
	        buf_output0 (buf_to_net, "error  unrecognized request `");
d6296 46
a6341 1
    server_cleanup (0);
d6345 2
a6346 1

a6347 2
static void switch_to_user PROTO((const char *));

d6349 1
a6349 2
switch_to_user (username)
    const char *username;
d6352 16
d6372 2
a6373 2
	/* Normally this won't be reached; check_password contains
	   a similar check.  */
d6376 16
a6391 3
error 0 %s: no such user\n", username);
	/* Don't worry about server_cleanup; server_active isn't set yet.  */
	error_exit ();
d6409 1
a6409 2
	/* Don't worry about server_cleanup; server_active isn't set yet.  */
	error_exit ();
d6413 9
d6430 1
a6430 3
	    /* Don't worry about server_cleanup;
	       server_active isn't set yet.  */
	    error_exit ();
d6440 6
a6445 3
	    /* Don't worry about server_cleanup;
	       server_active isn't set yet.  */
	    error_exit ();
d6448 1
a6448 1
    
d6458 6
a6463 2
	/* Don't worry about server_cleanup; server_active isn't set yet.  */
	error_exit ();
d6476 1
a6476 1
      
a6481 3
#ifdef AUTH_SERVER_SUPPORT
	char *cvs_user;
#endif
d6492 3
a6494 4
        cvs_user = NULL != CVS_Username ? CVS_Username : "";
        env = xmalloc (sizeof "CVS_USER=" + strlen (cvs_user));
        (void) sprintf (env, "CVS_USER=%s", cvs_user);
        (void) putenv (env);
d6503 1
a6503 1
extern char *crypt PROTO((const char *, const char *));
d6506 1
a6506 1
/* 
d6519 1
a6519 2
check_repository_password (username, password, repository, host_user_ptr)
     char *username, *password, *repository, **host_user_ptr;
d6529 2
a6530 2
    /* We don't use current_parsed_root->directory because it hasn't been set yet
     * -- our `repository' argument came from the authentication
d6542 1
a6542 1
                    CVSROOTADM, CVSROOTADM_PASSWD);
d6558 1
a6558 1
        {
d6561 1
a6561 1
        }
d6572 150
a6721 1
        char *non_cvsuser_portion;
d6723 52
a6774 18
        /* We need to make sure lines such as 
         *
         *    "username::sysuser\n"
         *    "username:\n"
         *    "username:  \n"
         *
         * all result in a found_password of NULL, but we also need to
         * make sure that
         *
         *    "username:   :sysuser\n"
         *    "username: <whatever>:sysuser\n"
         *
         * continues to result in an impossible password.  That way,
         * an admin would be on safe ground by going in and tacking a
         * space onto the front of a password to disable the account
         * (a technique some people use to close accounts
         * temporarily).
         */
d6776 7
a6782 4
        /* Make `non_cvsuser_portion' contain everything after the CVS
           username, but null out any final newline. */
	non_cvsuser_portion = linebuf + namelen;
        strtok (non_cvsuser_portion, "\n");
d6784 2
a6785 27
        /* If there's a colon now, we just want to inch past it. */
        if (strchr (non_cvsuser_portion, ':') == non_cvsuser_portion)
            non_cvsuser_portion++;

        /* Okay, after this conditional chain, found_password and
           host_user_tmp will have useful values: */

        if ((non_cvsuser_portion == NULL)
            || (strlen (non_cvsuser_portion) == 0)
            || ((strspn (non_cvsuser_portion, " \t"))
                == strlen (non_cvsuser_portion)))
        {
            found_password = NULL;
            host_user_tmp = NULL;
        }
        else if (strncmp (non_cvsuser_portion, ":", 1) == 0)
        {
            found_password = NULL;
            host_user_tmp = non_cvsuser_portion + 1;
            if (strlen (host_user_tmp) == 0)
                host_user_tmp = NULL;
        }
        else
        {
            found_password = strtok (non_cvsuser_portion, ":");
            host_user_tmp = strtok (NULL, ":");
        }
d6787 14
a6800 3
        /* Of course, maybe there was no system user portion... */
	if (host_user_tmp == NULL)
            host_user_tmp = username;
d6802 5
a6806 9
        /* Verify blank passwords directly, otherwise use crypt(). */
        if ((found_password == NULL)
            || ((strcmp (found_password, crypt (password, found_password))
                 == 0)))
        {
            /* Give host_user_ptr permanent storage. */
            *host_user_ptr = xstrdup (host_user_tmp);
	    retval = 1;
        }
d6808 8
a6815 9
        {
            *host_user_ptr = NULL;
	    retval         = 2;
        }
    }
    else     /* Didn't find this user, so deny access. */
    {
	*host_user_ptr = NULL;
	retval = 0;
d6818 7
a6824 3
    free (filename);
    if (linebuf)
        free (linebuf);
a6825 2
    return retval;
}
d6830 1
a6830 2
check_password (username, password, repository)
    char *username, *password, *repository;
d6837 1
a6837 1
       not, we'll check /etc/passwd. */
a6844 2
    /* else */

d6846 2
a6847 19
    {
        /* host_user already set by reference, so just return. */
        goto handle_return;
    }
    else if (rc == 0 && system_auth)
    {
	/* No cvs password found, so try /etc/passwd. */

	const char *found_passwd = NULL;
	struct passwd *pw;
#ifdef HAVE_GETSPNAM
	struct spwd *spw;

	spw = getspnam (username);
	if (spw != NULL)
	{
	    found_passwd = spw->sp_pwdp;
	}
#endif
d6849 1
a6849 9
	if (found_passwd == NULL && (pw = getpwnam (username)) != NULL)
	{
	    found_passwd = pw->pw_passwd;
	}
	
	if (found_passwd == NULL)
	{
	    printf ("E Fatal error, aborting.\n\
error 0 %s: no such user\n", username);
d6851 1
a6851 36
	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket subsystems on
	       NT and OS2 or dealing with windows and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

	    exit (EXIT_FAILURE);
	}
	
	if (*found_passwd)
        {
	    /* user exists and has a password */
	    host_user = ((! strcmp (found_passwd,
                                    crypt (password, found_passwd)))
                         ? xstrdup (username) : NULL);
            goto handle_return;
        }
	else if (password && *password)
        {
	    /* user exists and has no system password, but we got
	       one as parameter */
	    host_user = xstrdup (username);
            goto handle_return;
        }
	else
        {
	    /* user exists but has no password at all */
	    host_user = NULL;
            goto handle_return;
        }
    }
    else if (rc == 0)
a6860 9
	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
d6863 8
a6871 3
    {
	/* Something strange happened.  We don't know what it was, but
	   we certainly won't grant authorization. */
d6873 6
a6878 2
        goto handle_return;
    }
d6883 4
a6886 4
        /* Set CVS_Username here, in allocated space. 
           It might or might not be the same as host_user. */
        CVS_Username = xmalloc (strlen (username) + 1);
        strcpy (CVS_Username, username);
d6896 27
d6927 1
a6927 1
pserver_authenticate_connection ()
d6929 1
a6929 2
    char *tmp = NULL;
    size_t tmp_allocated = 0;
a6931 1
    size_t repository_allocated = 0;
a6932 1
    size_t username_allocated = 0;
a6933 1
    size_t password_allocated = 0;
d6964 1
a6964 1
     *            and
d6982 6
d6995 1
a6995 1
			   (char *) &on, sizeof on) < 0)
d7005 1
a7005 5
    if (getline_safe (&tmp, &tmp_allocated, stdin, PATH_MAX) < 0)
	/* FIXME: what?  We could try writing error/eof, but chances
	   are the network connection is dead bidirectionally.  log it
	   somewhere?  */
	;
d7007 1
a7007 1
    if (strcmp (tmp, "BEGIN VERIFICATION REQUEST\n") == 0)
d7009 1
a7009 1
    else if (strcmp (tmp, "BEGIN AUTH REQUEST\n") == 0)
d7011 1
a7011 1
    else if (strcmp (tmp, "BEGIN GSSAPI REQUEST\n") == 0)
d7030 2
d7034 3
a7036 8
    getline_safe (&repository, &repository_allocated, stdin, PATH_MAX);
    getline_safe (&username, &username_allocated, stdin, PATH_MAX);
    getline_safe (&password, &password_allocated, stdin, PATH_MAX);

    /* Make them pure. */ 
    strip_trailing_newlines (repository);
    strip_trailing_newlines (username);
    strip_trailing_newlines (password);
d7040 1
a7040 1
    getline_safe (&tmp, &tmp_allocated, stdin, PATH_MAX);
d7043 1
a7043 1
		"END VERIFICATION REQUEST\n" : "END AUTH REQUEST\n")
d7048 2
d7052 1
a7052 1
	printf ("error 0 %s: no such repository\n", repository);
d7064 1
a7064 1
    parse_config (repository);
a7068 2
    memset (descrambled_password, 0, strlen (descrambled_password));
    free (descrambled_password);
a7072 4
#ifdef LOG_AUTHPRIV
        syslog (LOG_AUTHPRIV | LOG_NOTICE, "login failure by %s / %s (for %s)",
        	username, descrambled_password, repository);
#endif
d7074 2
d7077 2
a7078 2
	printf ("I HATE YOU\n");
	fflush (stdout);
d7082 1
a7082 1
	error_exit ();
d7084 2
d7090 3
a7092 10
	printf ("I LOVE YOU\n");
	fflush (stdout);

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif

	exit (0);
d7101 1
a7101 1
    switch_to_user (host_user);
a7102 1
    free (tmp);
d7107 2
a7108 2
    printf ("I LOVE YOU\n");
    fflush (stdout);
d7117 1
a7117 1
kserver_authenticate_connection ()
d7137 1
a7137 5
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
d7164 1
a7164 5
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
d7174 4
a7177 7
	printf ("E Fatal error, aborting.\n\
error 0 kerberos: can't get local name: %s\n", krb_get_err_text(status));
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
d7182 1
a7182 1
    switch_to_user (user);
a7185 1
#ifdef HAVE_GSSAPI
a7186 3
#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN (256)
#endif
d7188 1
d7194 1
a7194 1
gserver_authenticate_connection ()
d7200 2
d7236 12
a7247 3
    assert (nbytes <= sizeof buf);

    if (fread (buf, 1, nbytes, stdin) != nbytes)
d7252 1
a7252 1
    tok_in.value = buf;
d7255 10
a7264 10
                                &gcontext,	/* context_handle */
                                server_creds,	/* verifier_cred_handle */
                                &tok_in,	/* input_token */
                                NULL,		/* channel bindings */
                                &client_name,	/* src_name */
                                &mechid,	/* mech_type */
                                &tok_out,	/* output_token */
                                &ret,
                                NULL,	 	/* ignore time_rec */
                                NULL)		/* ignore del_cred_handle */
d7302 4
a7305 1
    switch_to_user (buf);
a7324 125
#ifdef HAVE_GSSAPI

/* An buffer interface using GSSAPI.  This is built on top of a
   packetizing buffer.  */

/* This structure is the closure field of the GSSAPI translation
   routines.  */

struct cvs_gssapi_wrap_data
{
    /* The GSSAPI context.  */
    gss_ctx_id_t gcontext;
};

static int cvs_gssapi_wrap_input PROTO((void *, const char *, char *, int));
static int cvs_gssapi_wrap_output PROTO((void *, const char *, char *, int,
					 int *));

/* Create a GSSAPI wrapping buffer.  We use a packetizing buffer with
   GSSAPI wrapping routines.  */

struct buffer *
cvs_gssapi_wrap_buffer_initialize (buf, input, gcontext, memory)
     struct buffer *buf;
     int input;
     gss_ctx_id_t gcontext;
     void (*memory) PROTO((struct buffer *));
{
    struct cvs_gssapi_wrap_data *gd;

    gd = (struct cvs_gssapi_wrap_data *) xmalloc (sizeof *gd);
    gd->gcontext = gcontext;

    return (packetizing_buffer_initialize
	    (buf,
	     input ? cvs_gssapi_wrap_input : NULL,
	     input ? NULL : cvs_gssapi_wrap_output,
	     gd,
	     memory));
}

/* Unwrap data using GSSAPI.  */

static int
cvs_gssapi_wrap_input (fnclosure, input, output, size)
     void *fnclosure;
     const char *input;
     char *output;
     int size;
{
    struct cvs_gssapi_wrap_data *gd =
	(struct cvs_gssapi_wrap_data *) fnclosure;
    gss_buffer_desc inbuf, outbuf;
    OM_uint32 stat_min;
    int conf;

    inbuf.value = (void *) input;
    inbuf.length = size;

    if (gss_unwrap (&stat_min, gd->gcontext, &inbuf, &outbuf, &conf, NULL)
	!= GSS_S_COMPLETE)
    {
	error (1, 0, "gss_unwrap failed");
    }

    if (outbuf.length > size)
	abort ();

    memcpy (output, outbuf.value, outbuf.length);

    /* The real packet size is stored in the data, so we don't need to
       remember outbuf.length.  */

    gss_release_buffer (&stat_min, &outbuf);

    return 0;
}

/* Wrap data using GSSAPI.  */

static int
cvs_gssapi_wrap_output (fnclosure, input, output, size, translated)
     void *fnclosure;
     const char *input;
     char *output;
     int size;
     int *translated;
{
    struct cvs_gssapi_wrap_data *gd =
	(struct cvs_gssapi_wrap_data *) fnclosure;
    gss_buffer_desc inbuf, outbuf;
    OM_uint32 stat_min;
    int conf_req, conf;

    inbuf.value = (void *) input;
    inbuf.length = size;

#ifdef ENCRYPTION
    conf_req = cvs_gssapi_encrypt;
#else
    conf_req = 0;
#endif

    if (gss_wrap (&stat_min, gd->gcontext, conf_req, GSS_C_QOP_DEFAULT,
		  &inbuf, &conf, &outbuf) != GSS_S_COMPLETE)
	error (1, 0, "gss_wrap failed");

    /* The packetizing buffer only permits us to add 100 bytes.
       FIXME: I don't know what, if anything, is guaranteed by GSSAPI.
       This may need to be increased for a different GSSAPI
       implementation, or we may need a different algorithm.  */
    if (outbuf.length > size + 100)
	abort ();

    memcpy (output, outbuf.value, outbuf.length);

    *translated = outbuf.length;

    gss_release_buffer (&stat_min, &outbuf);

    return 0;
}

#endif /* HAVE_GSSAPI */

a7333 1

a7341 20
static int krb_encrypt_input PROTO((void *, const char *, char *, int));
static int krb_encrypt_output PROTO((void *, const char *, char *, int,
				     int *));

/* Create a Kerberos encryption buffer.  We use a packetizing buffer
   with Kerberos encryption translation routines.  */

struct buffer *
krb_encrypt_buffer_initialize (buf, input, sched, block, memory)
     struct buffer *buf;
     int input;
     Key_schedule sched;
     C_Block block;
     void (*memory) PROTO((struct buffer *));
{
    struct krb_encrypt_data *kd;

    kd = (struct krb_encrypt_data *) xmalloc (sizeof *kd);
    memcpy (kd->sched, sched, sizeof (Key_schedule));
    memcpy (kd->block, block, sizeof (C_Block));
a7342 6
    return packetizing_buffer_initialize (buf,
					  input ? krb_encrypt_input : NULL,
					  input ? NULL : krb_encrypt_output,
					  kd,
					  memory);
}
a7344 1

d7346 1
a7346 5
krb_encrypt_input (fnclosure, input, output, size)
     void *fnclosure;
     const char *input;
     char *output;
     int size;
d7368 2
a7370 1

d7372 2
a7373 6
krb_encrypt_output (fnclosure, input, output, size, translated)
     void *fnclosure;
     const char *input;
     char *output;
     int size;
     int *translated;
d7403 22
d7429 2
a7432 1

d7434 1
a7434 3
cvs_output (str, len)
    const char *str;
    size_t len;
d7441 12
a7452 2
	buf_output (saved_output, str, len);
	buf_copy_lines (buf_to_net, saved_output, 'M');
d7456 13
a7468 3
	buf_output (saved_output, str, len);
	buf_copy_lines (protocol, saved_output, 'M');
	buf_send_counted (protocol);
d7477 4
a7480 6
	/* For symmetry with cvs_outerr we would call fflush (stderr)
	   here.  I guess the assumption is that stderr will be
	   unbuffered, so we don't need to.  That sounds like a sound
	   assumption from the manpage I looked at, but if there was
	   something fishy about it, my guess is that calling fflush
	   would not produce a significant performance problem.  */
d7497 1
a7497 3
cvs_output_binary (str, len)
    char *str;
    size_t len;
d7510 2
a7536 7

	/* For symmetry with cvs_outerr we would call fflush (stderr)
	   here.  I guess the assumption is that stderr will be
	   unbuffered, so we don't need to.  That sounds like a sound
	   assumption from the manpage I looked at, but if there was
	   something fishy about it, my guess is that calling fflush
	   would not produce a significant performance problem.  */
d7539 6
d7546 1
d7577 2
a7579 1

d7581 1
a7581 3
cvs_outerr (str, len)
    const char *str;
    size_t len;
d7588 12
a7599 2
	buf_output (saved_outerr, str, len);
	buf_copy_lines (buf_to_net, saved_outerr, 'E');
d7603 13
a7615 3
	buf_output (saved_outerr, str, len);
	buf_copy_lines (protocol, saved_outerr, 'E');
	buf_send_counted (protocol);
d7641 2
a7645 1

d7647 1
a7647 1
cvs_flusherr ()
d7662 1
a7662 1
	 */ 
d7672 2
a7676 1

d7678 1
a7678 1
cvs_flushout ()
d7693 1
a7693 1
	 
d7705 2
d7716 1
a7716 3
cvs_output_tagged (tag, text)
    char *tag;
    char *text;
d7755 1
a7755 1
#endif
d7757 1
d7760 19
@


1.4.2.1
log
@SECURITY: Fix from OpenBSD 3.4-stable:

Fix all those cvs holes in one go, too lazy to list them all here
@
text
@d933 1
a933 1
    if (lim < 0 || lim > 10000)
d1638 2
a1639 1
    if (error_pending ()) return;
d1653 1
a1653 10
 	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
 	    {
 		/* We didn't find the record separator or it is followed by
 		 * the end of the string, so just exit.
 		 */
 		if (alloc_pending (80))
 		    sprintf (pending_error_text,
 		             "E Malformed Entry encountered.");
 		return;
 	    }
d1700 2
a1701 1
    if (error_pending ()) return;
d1716 1
a1716 10
 	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
 	    {
 		/* We didn't find the record separator or it is followed by
 		 * the end of the string, so just exit.
 		 */
 		if (alloc_pending (80))
 		    sprintf (pending_error_text,
 		             "E Malformed Entry encountered.");
 		return;
 	    }
a1800 1
    int i = 0;
d1802 1
a1802 21

    /* Verify that the entry is well-formed.  This can avoid problems later.
     * At the moment we only check that the Entry contains five slashes in
     * approximately the correct locations since some of the code makes
     * assumptions about this.
     */
    cp = arg;
    if (*cp == 'D') cp++;
    while (i++ < 5)
    {
      if (!cp || *cp != '/')
      {
          if (alloc_pending (80))
              sprintf (pending_error_text,
                       "E protocol error: Malformed Entry");
           return;
      }
    cp = strchr (cp + 1, '/');
    }

    p = xmalloc (sizeof (struct an_entry));
a2033 3
	if (!data[0])
	    goto error;

a2164 9

    if (argument_count >= 10000)
    {
       if (alloc_pending (80))
           sprintf (pending_error_text,
                    "E Protocol error: too many arguments");
       return;
    }

a2194 9

    if (argument_count <= 1)
    {
        if (alloc_pending (80))
            sprintf (pending_error_text,
                     "E Protocol error: called argumentx without prior call to argument");
        return;
    }

d2552 1
a2552 1
                 if (num_red > 0 && linebuf[num_red - 1] == '\n')
d2607 1
a2607 1
             if (num_red > 0 && linebuf[num_red - 1] == '\n')
@


1.3
log
@cvs-1.11.12 doesn't do the joints correctly (what were the
FSF people smoking?), it memory faults.
thusly revert to 1.11.1p1

tested.
agreed bsiegert@@
@
text
@d1654 9
a1662 1
	    if (*timefield != '=')
d1664 2
a1672 1
		*timefield = '=';
d1674 10
d1717 9
a1725 1
	    if (!(timefield[0] == 'M' && timefield[1] == '/'))
d1727 2
a1735 1
		*timefield = 'M';
d1737 10
@


1.2
log
@first step of merging new cvs
XXX might not compile
XXX might not work
XXX might contain bugs
XXX definitively needs autoconf 2.58 first
@
text
@d62 1
a62 4
# include <syslog.h>
# ifndef LOG_DAEMON   /* for ancient syslogs */
#  define LOG_DAEMON 0
# endif
d166 1
a166 1
static int fd_buffer_shutdown PROTO((struct buffer *));
d211 1
a211 1
	   ever actually happens.  */
d226 2
a227 2
	   style nonblocking I/O.  On System V we will get a zero
	   return if there is no data, even when not at EOF.  */
d267 1
a267 1
		   return.  */
d274 1
a274 1
		return EIO;
d318 1
a318 1
	return errno;
d328 2
a329 2
fd_buffer_shutdown (buf)
     struct buffer *buf;
d331 1
a331 1
    free (buf->closure);
d353 1
a353 1
    p = xmalloc (strlen (dir) + 1);
d357 1
a357 1
    dir_where_cvsadm_lives = xmalloc (strlen (base_dir) + strlen (dir) + 100);
d363 1
a363 1
    tmp = xmalloc (strlen (base_dir) + strlen (dir) + 100);
d367 1
a367 1

d403 1
a403 1
	    empty = xmalloc (strlen (current_parsed_root->directory)
d430 2
a431 1

d522 1
a522 1
    char *q = xmalloc (strlen (dir) + 1);
d649 1
a649 1
    pending_error_text = xmalloc (size);
d715 11
a725 1
	    error_exit ();
d738 1
a738 1

a775 1
	    return;
d780 2
d788 1
a788 1
    path = xmalloc (strlen (current_parsed_root->directory)
d807 1
a807 1
    env = xmalloc (strlen (CVSROOT_ENV) + strlen (current_parsed_root->directory) + 2);
d865 4
a868 3
    /* isabsolute (repos) should always be true, but
       this is a good security precaution regardless. -DRP
     */
d919 1
a919 1

d935 1
a935 1
    p = xmalloc (strlen (server_temp_dir) + 2 * lim + 10);
d1002 1
a1002 1
    dir_name = xmalloc (strlen (server_temp_dir) + dir_len + 40);
d1008 1
a1008 1

d1093 1
a1093 1
	if (fprintf (f, "/.") < 0)
d1170 1
a1170 1
	pending_error = ENOMEM;
d1174 1
a1174 1
	pending_error_text = xmalloc (80 + strlen (arg));
d1281 1
a1281 1
		pending_error_text = xmalloc (80);
d1309 1
a1309 1
		int save_errno = errno;
d1368 1
a1368 1
	filebuf = xmalloc (size);
d1384 1
a1384 1
		    pending_error_text = xmalloc (80);
d1430 1
a1430 1
	char *p = xrealloc (pending_error_text,
d1483 1
a1483 1
	if (status == -2)
d1487 1
a1487 1
	    pending_error_text = xmalloc (80 + strlen (arg));
d1513 1
a1513 1
	    pending_error_text = xmalloc (80 + strlen (arg));
d1543 1
a1543 1
	/* Now that we know the size, read and discard the file data.  */
d1727 1
a1727 1
	p = (struct an_entry *) xmalloc (sizeof (struct an_entry));
d1733 1
a1733 1
	p->entry = xmalloc (strlen (arg) + 80);
d1764 1
a1764 1
    p = (struct an_entry *) xmalloc (sizeof (struct an_entry));
d1771 1
a1771 1
    cp = xmalloc (strlen (arg) + 2);
d1813 1
a1813 1
    kopt = xmalloc (strlen (arg) + 1);
d1865 4
a1868 4
	   existing Entries file.  If we are checking out a module
	   which explicitly lists more than one file in a particular
	   directory, then we will wind up calling
	   server_write_entries for each such file.  */
d1907 1
a1907 1
    /* Directory in which this notification happens.  xmalloc'd*/
d1910 1
a1910 1
    /* xmalloc'd.  */
d1913 1
a1913 1
    /* The following three all in one xmalloc'd block, pointed to by TYPE.
d1946 1
a1946 1
    new = (struct notify_note *) xmalloc (sizeof (struct notify_note));
d1952 2
a1953 2
    new->dir = xmalloc (strlen (dir_name) + 1);
    new->filename = xmalloc (strlen (arg) + 1);
d1972 1
a1972 1
	    pending_error_text = xmalloc (80 + strlen (arg));
d2082 1
a2082 1
		buf_append_char (buf_to_net, '.');
d2084 1
a2084 1
		buf_output0 (buf_to_net, dir);
d2125 1
a2125 1

d2127 1
a2127 1

d2132 1
a2132 1
	    (char **) xrealloc ((char *)argument_vector,
d2140 1
a2140 1
    p = xmalloc (strlen (arg) + 1);
d2155 1
a2155 1

d2157 1
a2157 1

d2159 1
a2159 1
    p = xrealloc (p, strlen (p) + 1 + strlen (arg) + 1);
a2184 3
	case 'l':
	    error(0, 0, "WARNING: global `-l' option ignored.");
	    break;
a2186 1
	    logoff = 1;
d2197 3
d2246 4
a2249 4
	   authentication.  Flush everything we've output so far, and
	   turn on encryption for future data.  On the input side, we
	   should only have unwrapped as far as the Gssapi-encrypt
	   command, so future unwrapping will become encrypted.  */
d2282 2
a2283 2
	   That includes authentication, so we don't have to do
	   anything further.  */
d2373 1
d2375 7
a2381 1

d2451 1
a2451 1
	return 1;
d2455 30
a2484 16
	/* This command has the potential to modify the repository, so
	 * we check if the user have permission to do that.
	 *
	 * (Only relevant for remote users -- local users can do
	 * whatever normal Unix file permissions allow them to do.)
	 *
	 * The decision method:
	 *
	 *    If $CVSROOT/CVSADMROOT_READERS exists and user is listed
	 *    in it, then read-only access for user.
	 *
	 *    Or if $CVSROOT/CVSADMROOT_WRITERS exists and user NOT
	 *    listed in it, then also read-only access for user.
	 *
	 *    Else read-write access for user.
	 */
d2486 2
a2487 16
	 char *linebuf = NULL;
	 int num_red = 0;
	 size_t linebuf_len = 0;
	 char *fname;
	 size_t flen;
	 FILE *fp;
	 int found_it = 0;

	 /* else */
	 flen = strlen (current_parsed_root->directory)
		+ strlen (CVSROOTADM)
		+ strlen (CVSROOTADM_READERS)
		+ 3;

	 fname = xmalloc (flen);
	 (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
d2490 1
a2490 1
	 fp = fopen (fname, "r");
d2492 1
a2492 1
	 if (fp == NULL)
d2503 17
a2519 17
	 else  /* successfully opened readers file */
	 {
	     while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
	     {
		 /* Hmmm, is it worth importing my own readline
		    library into CVS?  It takes care of chopping
		    leading and trailing whitespace, "#" comments, and
		    newlines automatically when so requested.  Would
		    save some code here...  -kff */

		 /* Chop newline by hand, for strcmp()'s sake. */
		 if (linebuf[num_red - 1] == '\n')
		     linebuf[num_red - 1] = '\0';

		 if (strcmp (linebuf, CVS_Username) == 0)
		     goto handle_illegal;
	     }
d2523 3
a2525 3
	     /* If not listed specifically as a reader, then this user
		has write access by default unless writers are also
		specified in a file . */
d2528 1
a2528 1
	 }
d2533 4
a2536 4
	 flen = strlen (current_parsed_root->directory)
		+ strlen (CVSROOTADM)
		+ strlen (CVSROOTADM_WRITERS)
		+ 3;
d2538 2
a2539 2
	 fname = xmalloc (flen);
	 (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
d2542 1
a2542 1
	 fp = fopen (fname, "r");
d2544 2
a2545 2
	 if (fp == NULL)
	 {
d2547 1
a2547 1
		 free (linebuf);
d2563 1
a2563 1
	 }
d2565 13
a2577 13
	 found_it = 0;
	 while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
	 {
	     /* Chop newline by hand, for strcmp()'s sake. */
	     if (linebuf[num_red - 1] == '\n')
		 linebuf[num_red - 1] = '\0';

	     if (strcmp (linebuf, CVS_Username) == 0)
	     {
		 found_it = 1;
		 break;
	     }
	 }
d2581 3
a2583 3
	 if (found_it)
	 {
	     if (fclose (fp) < 0)
d2585 2
a2586 2
	     if (linebuf)
		 free (linebuf);
d2588 6
a2593 6
	     return 1;
	 }
	 else   /* writers file exists, but this user not listed in it */
	 {
	 handle_illegal:
	     if (fclose (fp) < 0)
d2595 2
a2596 2
	     if (linebuf)
		 free (linebuf);
d2599 1
a2599 1
	 }
a2611 1
#ifdef SUNOS_KLUDGE
a2612 1
#endif
d2638 1
a2638 1

a2669 1
    command_name = cmd_name;
d2758 2
a2759 2
	   buf_from_net.  Instead, everything should go through
	   protocol.  */
d2764 2
a2765 2
	   Since we're now in the child, we should use the simpler
	   protocol_memory_error function.  */
a2842 1
#ifdef SUNOS_KLUDGE
a2843 1
#endif
d2921 2
a2924 2
#ifdef SERVER_FLOWCONTROL
	    int bufmemsize;
d2987 2
a2988 2
		   as I know there was never any reason to do that and
		   SCO doesn't let you select on exceptions on pipes.  */
d3017 1
a3017 1

d3088 1
a3088 1
		int status;
d3090 1
a3090 1
		status = buf_input_data (stdoutbuf, (int *) NULL);
d3113 1
a3113 1
		int status;
d3115 1
a3115 1
		status = buf_input_data (stderrbuf, (int *) NULL);
d3175 1
a3175 1

d3180 2
a3181 2
		int sig = WTERMSIG (status);
		char buf[50];
d3193 2
a3194 2
		/* Test for a core dump.  */
		if (WCOREDUMP (status))
a3215 1
	protocol_inbuf = NULL;
a3217 1
	stderrbuf = NULL;
a3219 1
	stdoutbuf = NULL;
d3302 1
a3302 1

d3314 1
a3314 1

d3330 2
a3331 2
	       I/O.  System V nonblocking I/O returns zero if there is
	       nothing to read.  */
d3333 1
a3333 1
		error (1, 0, "flow control EOF");
d3336 1
a3336 1
		error (1, errno, "flow control read failed");
d3437 1
a3437 1

d3635 2
d3672 1
a3672 1
    do_cvs_command ("tag", cvstag);
d3679 2
d3718 1
a3718 1
    do_cvs_command ("watch", watch_on);
d3727 1
a3727 1
    do_cvs_command ("watch", watch_off);
d3736 1
a3736 1
    do_cvs_command ("watch", watch_add);
d3745 1
a3745 1
    do_cvs_command ("watch", watch_remove);
a3796 2
    cvsroot_t *saved_parsed_root;

d3801 3
a3803 1
		     "E init %s must be an absolute pathname", arg);
a3804 15
#ifdef AUTH_SERVER_SUPPORT
    else if (Pserver_Repos != NULL)
    {
	if (strcmp (Pserver_Repos, arg) != 0)
	{
	    if (alloc_pending (80 + strlen (Pserver_Repos) + strlen (arg)))
		/* The explicitness is to aid people who are writing clients.
		   I don't see how this information could help an
		   attacker.  */
		sprintf (pending_error_text, "\
E Protocol error: init says \"%s\" but pserver says \"%s\"",
			 arg, Pserver_Repos);
	}
    }
#endif
d3806 3
a3808 2
    if (print_pending_error ())
	return;
a3809 2
    saved_parsed_root = current_parsed_root;
    current_parsed_root = local_cvsroot (arg);
a3810 2
    free_cvsroot_t (current_parsed_root);
    current_parsed_root = saved_parsed_root;
d3828 2
d3849 1
a3849 1
	tempdir = xmalloc (strlen (server_temp_dir) + 80);
d3886 2
a3887 2
		    "export" : "checkout",
		    checkout);
d4044 1
a4044 1
		int i;
d4047 1
a4047 1
		buf_output0 (protocol, "Checksum ");
d4096 1
a4096 1
	{
d4136 3
a4138 3
		   file_gzip_level is set.  We could handle this case,
		   but it's not worth it since this case never arises
		   with a current client and server.  */
a4403 1
    buf_send_counted (protocol);
d4465 2
a4466 2
	 wrapper_line;
	 wrap_unparse_rcs_options (&wrapper_line, 0))
d4533 1
a4533 1
	   of aliases before removing */
d4549 1
a4549 1
		buf_output0 (buf_to_net, "Module-expansion ");
d4574 1
d4582 1
d4604 42
d4647 83
d4759 2
d4775 1
d4781 2
a4782 2
	   serve_wrapper_sendme_rcs_options,
	   0),
d4910 5
a4914 5
	/* Since we're done, go ahead and put BUF_TO_NET back into blocking
	 * mode and send any pending output.  In the usual case there won't
	 * won't be any, but there might be if an error occured.
	 */

d4918 5
a4922 4
	/* Next we shut down BUF_FROM_NET.  That will pick up the checksum
	 * generated when the client shuts down its buffer.  Then, after we
	 * have generated any final output, we shut down BUF_TO_NET.
	 */
d4924 2
a4925 1
	if (buf_from_net != NULL)
d4927 2
a4928 5
	    status = buf_shutdown (buf_from_net);
	    if (status != 0)
		error (0, status, "shutting down buffer from client");
	    buf_free (buf_from_net);
	    buf_from_net = NULL;
d4930 1
d4932 3
a4934 3
	if (dont_delete_temp)
	{
	    (void) buf_flush (buf_to_net, 1);
d4936 1
a4936 5
	    buf_free (buf_to_net);
	    buf_to_net = NULL;
	    error_use_protocol = 0;
	    return;
	}
a4937 2
    else if (dont_delete_temp)
	return;
a5032 2
    {
	(void) buf_flush (buf_to_net, 1);
a5033 4
	buf_free (buf_to_net);
	buf_to_net = NULL;
	error_use_protocol = 0;
    }
d5037 1
a5043 2
    char *error_prog_name;		/* Used in error messages */

d5058 1
a5058 1
    buf_from_net = stdio_buffer_initialize (stdin, 0, 1, outbuf_memory_error);
d5090 1
a5090 1
	    server_temp_dir = xmalloc (strlen (Tmpdir) + 80);
d5100 12
a5111 1
		error_exit ();
d5133 2
a5134 2
	       700, to discourage random people from tampering with
	       it.  */
d5137 1
a5137 1
		static const char suffix[] = "abcdefghijklmnopqrstuvwxyz";
d5139 1
a5139 1
		if (i >= sizeof suffix - 1) break;
d5175 19
d5199 23
a5221 1
	(char **) xmalloc (argument_vector_size * sizeof (char *));
d5225 1
d5231 1
a5231 3
    error_prog_name = xmalloc( strlen(program_name) + 8 );
    sprintf(error_prog_name, "%s server", program_name);
    argument_vector[0] = error_prog_name;
d5238 1
a5238 1

d5296 1
a5296 1
		buf_output0 (buf_to_net, "error  unrecognized request `");
a5303 1
    free(error_prog_name);
d5310 1
a5310 1
static void switch_to_user PROTO((const char *, const char *));
d5313 1
a5313 2
switch_to_user (cvs_username, username)
    const char *cvs_username; /* Only used for error messages. */
d5321 2
a5322 2
	/* check_password contains a similar check, so this usually won't be
	   reached unless the CVS user is mapped to an invalid system user.  */
d5325 1
a5325 1
error 0 %s: no such system user\n", username);
a5329 14
    if (pw->pw_uid == 0)
    {
#ifdef HAVE_SYSLOG_H
	    /* FIXME: Can the IP address of the connecting client be retrieved
	     * and printed here?
	     */
	    syslog (LOG_DAEMON | LOG_ALERT,
		    "attempt to root from account: %s", cvs_username
		   );
#endif
        printf("error 0: root not allowed\n");
        error_exit ();
    }

a5369 5
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR,
		    "setgid to %d failed (%m): real %d/%d, effective %d/%d ",
		    pw->pw_gid, getuid(), getgid(), geteuid(), getegid());
#endif
d5375 1
a5375 1

a5384 5
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR,
		    "setuid to %d failed (%m): real %d/%d, effective %d/%d ",
		    pw->pw_uid, getuid(), getgid(), geteuid(), getegid());
#endif
d5399 1
a5399 1

d5405 3
d5418 4
a5421 3
	env = xmalloc (sizeof "CVS_USER=" + strlen (CVS_Username));
	(void) sprintf (env, "CVS_USER=%s", CVS_Username);
	(void) putenv (env);
d5433 1
a5433 1
/*
d5457 2
a5458 2
    /* We don't use current_parsed_root->directory because it hasn't been
     * set yet -- our `repository' argument came from the authentication
d5470 1
a5470 1
		    CVSROOTADM, CVSROOTADM_PASSWD);
d5486 1
a5486 1
	{
d5489 1
a5489 1
	}
d5500 1
a5500 1
	char *non_cvsuser_portion;
d5502 18
a5519 18
	/* We need to make sure lines such as
	 *
	 *    "username::sysuser\n"
	 *    "username:\n"
	 *    "username:  \n"
	 *
	 * all result in a found_password of NULL, but we also need to
	 * make sure that
	 *
	 *    "username:   :sysuser\n"
	 *    "username: <whatever>:sysuser\n"
	 *
	 * continues to result in an impossible password.  That way,
	 * an admin would be on safe ground by going in and tacking a
	 * space onto the front of a password to disable the account
	 * (a technique some people use to close accounts
	 * temporarily).
	 */
d5521 2
a5522 2
	/* Make `non_cvsuser_portion' contain everything after the CVS
	   username, but null out any final newline. */
d5524 1
a5524 5
	strtok (non_cvsuser_portion, "\n");

	/* If there's a colon now, we just want to inch past it. */
	if (strchr (non_cvsuser_portion, ':') == non_cvsuser_portion)
	    non_cvsuser_portion++;
d5526 27
a5552 2
	/* Okay, after this conditional chain, found_password and
	   host_user_tmp will have useful values: */
d5554 1
a5554 22
	if ((non_cvsuser_portion == NULL)
	    || (strlen (non_cvsuser_portion) == 0)
	    || ((strspn (non_cvsuser_portion, " \t"))
		== strlen (non_cvsuser_portion)))
	{
	    found_password = NULL;
	    host_user_tmp = NULL;
	}
	else if (strncmp (non_cvsuser_portion, ":", 1) == 0)
	{
	    found_password = NULL;
	    host_user_tmp = non_cvsuser_portion + 1;
	    if (strlen (host_user_tmp) == 0)
		host_user_tmp = NULL;
	}
	else
	{
	    found_password = strtok (non_cvsuser_portion, ":");
	    host_user_tmp = strtok (NULL, ":");
	}

	/* Of course, maybe there was no system user portion... */
d5556 1
a5556 1
	    host_user_tmp = username;
d5558 7
a5564 7
	/* Verify blank passwords directly, otherwise use crypt(). */
	if ((found_password == NULL)
	    || ((strcmp (found_password, crypt (password, found_password))
		 == 0)))
	{
	    /* Give host_user_ptr permanent storage. */
	    *host_user_ptr = xstrdup (host_user_tmp);
d5566 1
a5566 1
	}
d5568 4
a5571 9
	{
#ifdef LOG_AUTHPRIV
	syslog (LOG_AUTHPRIV | LOG_NOTICE,
		"password mismatch for %s in %s: %s vs. %s", username,
		repository, crypt(password, found_password), found_password);
#endif
	    *host_user_ptr = NULL;
	    retval	 = 2;
	}
d5581 1
a5581 1
	free (linebuf);
a5593 2
    char *found_passwd = NULL;
    struct passwd *pw;
d5605 2
d5609 2
a5610 2
	/* host_user already set by reference, so just return. */
	goto handle_return;
d5612 1
a5612 4

    assert (rc == 0);

    if (!system_auth)
d5614 1
a5614 12
	/* Note that the message _does_ distinguish between the case in
	   which we check for a system password and the case in which
	   we do not.  It is a real pain to track down why it isn't
	   letting you in if it won't say why, and I am not convinced
	   that the potential information disclosure to an attacker
	   outweighs this.  */
	printf ("error 0 no such user %s in CVSROOT/passwd\n", username);

	error_exit ();
    }

    /* No cvs password found, so try /etc/passwd. */
d5616 2
a5618 1
    {
a5625 1
    }
d5628 8
a5635 8
    if (found_passwd == NULL && (pw = getpwnam (username)) != NULL)
    {
	found_passwd = pw->pw_passwd;
    }

    if (found_passwd == NULL)
    {
	printf ("E Fatal error, aborting.\n\
d5638 3
a5640 17
	error_exit ();
    }

    /* Allow for dain bramaged HPUX passwd aging
     *  - Basically, HPUX adds a comma and some data
     *    about whether the passwd has expired or not
     *    on the end of the passwd field.
     *  - This code replaces the ',' with '\0'.
     *
     * FIXME - our workaround is brain damaged too.  I'm
     * guessing that HPUX WANTED other systems to think the
     * password was wrong so logins would fail if the
     * system didn't handle expired passwds and the passwd
     * might be expired.  I think the way to go here
     * is with PAM.
     */
    strtok (found_passwd, ",");
d5642 21
a5662 5
    if (*found_passwd)
    {
	/* user exists and has a password */
	if (strcmp (found_passwd, crypt (password, found_passwd)) == 0)
	{
d5664 2
a5665 1
	}
d5667 2
a5668 1
	{
d5670 21
a5690 4
#ifdef LOG_AUTHPRIV
	    syslog (LOG_AUTHPRIV | LOG_NOTICE,
		    "password mismatch for %s: %s vs. %s", username,
		    crypt(password, found_passwd), found_passwd);
d5692 1
a5692 2
	}
	goto handle_return;
d5694 1
a5694 2

    if (password && *password)
d5696 4
a5699 4
	/* user exists and has no system password, but we got
	   one as parameter */
	host_user = xstrdup (username);
	goto handle_return;
a5701 7
    /* user exists but has no password at all */
    host_user = NULL;
#ifdef LOG_AUTHPRIV
    syslog (LOG_AUTHPRIV | LOG_NOTICE,
	    "login refused for %s: user has no password", username);
#endif

d5705 4
a5708 4
	/* Set CVS_Username here, in allocated space.
	   It might or might not be the same as host_user. */
	CVS_Username = xmalloc (strlen (username) + 1);
	strcpy (CVS_Username, username);
d5763 1
a5763 1
     *	    and
d5799 4
a5802 6
	{
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_NOTICE, "bad auth protocol start: EOF");
#endif
	    error (1, 0, "bad auth protocol start: EOF");
	}
d5833 4
a5836 10
    /* Make them pure.
     *
     * We check that none of the lines were truncated by getnline in order
     * to be sure that we don't accidentally allow a blind DOS attack to
     * authenticate, however slim the odds of that might be.
     */
    if (!strip_trailing_newlines (repository)
	|| !strip_trailing_newlines (username)
	|| !strip_trailing_newlines (password))
	error (1, 0, "Maximum line length exceeded during authentication.");
d5867 2
d5873 4
a5877 2
	memset (descrambled_password, 0, strlen (descrambled_password));
	free (descrambled_password);
a5885 2
    memset (descrambled_password, 0, strlen (descrambled_password));
    free (descrambled_password);
d5908 1
a5908 1
    switch_to_user (username, host_user);
d5945 6
a5950 2

	error_exit ();
d5976 6
a5981 2

	error_exit ();
d5992 6
a5997 2

	error_exit ();
d6001 1
a6001 1
    switch_to_user ("Kerberos 4", user);
d6066 10
a6075 10
				&gcontext,	/* context_handle */
				server_creds,	/* verifier_cred_handle */
				&tok_in,	/* input_token */
				NULL,		/* channel bindings */
				&client_name,	/* src_name */
				&mechid,	/* mech_type */
				&tok_out,	/* output_token */
				&ret,
				NULL,		/* ignore time_rec */
				NULL)		/* ignore del_cred_handle */
d6113 1
a6113 1
    switch_to_user ("GSSAPI", buf);
d6386 1
a6386 1
    if (error_use_protocol && buf_to_net != NULL)
d6391 1
a6391 1
    else if (server_active && protocol != NULL)
d6571 1
a6571 1
	 */
d6601 1
a6601 1

@


1.1
log
@Initial revision
@
text
@d62 4
a65 1
#include <syslog.h>
d169 1
a169 1
static int fd_buffer_shutdown PROTO((void *));
d214 1
a214 1
           ever actually happens.  */
d229 2
a230 2
           style nonblocking I/O.  On System V we will get a zero
           return if there is no data, even when not at EOF.  */
d270 1
a270 1
                   return.  */
d277 1
a277 1
	        return EIO;
d321 1
a321 1
        return errno;
d331 2
a332 2
fd_buffer_shutdown (closure)
     void *closure;
d334 1
a334 1
    free (closure);
d356 1
a356 1
    p = malloc (strlen (dir) + 1);
d360 1
a360 1
    dir_where_cvsadm_lives = malloc (strlen (base_dir) + strlen (dir) + 100);
d366 1
a366 1
    tmp = malloc (strlen (base_dir) + strlen (dir) + 100);
d370 1
a370 1
    
d406 1
a406 1
	    empty = malloc (strlen (current_parsed_root->directory)
d433 1
a433 2
	    
	    
d524 1
a524 1
    char *q = malloc (strlen (dir) + 1);
d651 1
a651 1
    pending_error_text = malloc (size);
d717 1
a717 11
	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket subsystems on
	       NT and OS2 or dealing with windows and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

	    exit (EXIT_FAILURE);
d730 1
a730 1
    
d768 1
a772 2
    if (current_parsed_root != NULL)
	free_cvsroot_t (current_parsed_root);
d779 1
a779 1
    path = malloc (strlen (current_parsed_root->directory)
d798 1
a798 1
    env = malloc (strlen (CVSROOT_ENV) + strlen (current_parsed_root->directory) + 2);
d856 3
a858 4
    /* I think isabsolute (repos) should always be true, and that
       any RELATIVE_REPOS stuff should only be in CVS/Repository
       files, not the protocol (for compatibility), but I'm putting
       in the isabsolute check just in case.  */
d909 1
a909 1
	
d925 1
a925 1
    p = malloc (strlen (server_temp_dir) + 2 * lim + 10);
d992 1
a992 1
    dir_name = malloc (strlen (server_temp_dir) + dir_len + 40);
d998 1
a998 1
    
d1083 1
a1083 1
        if (fprintf (f, "/.") < 0)
d1160 1
a1160 1
        pending_error = ENOMEM;
d1164 1
a1164 1
	pending_error_text = malloc (80 + strlen (arg));
d1271 1
a1271 1
		pending_error_text = malloc (80);
d1299 1
a1299 1
	        int save_errno = errno;
d1358 1
a1358 1
	filebuf = malloc (size);
d1374 1
a1374 1
		    pending_error_text = malloc (80);
d1420 1
a1420 1
	char *p = realloc (pending_error_text,
d1473 1
a1473 1
        if (status == -2)
d1477 1
a1477 1
	    pending_error_text = malloc (80 + strlen (arg));
d1503 1
a1503 1
	    pending_error_text = malloc (80 + strlen (arg));
d1533 1
a1533 1
        /* Now that we know the size, read and discard the file data.  */
d1717 1
a1717 1
	p = (struct an_entry *) malloc (sizeof (struct an_entry));
d1723 1
a1723 1
	p->entry = malloc (strlen (arg) + 80);
d1754 1
a1754 1
    p = (struct an_entry *) malloc (sizeof (struct an_entry));
d1761 1
a1761 1
    cp = malloc (strlen (arg) + 2);
d1803 1
a1803 1
    kopt = malloc (strlen (arg) + 1);
d1855 4
a1858 4
           existing Entries file.  If we are checking out a module
           which explicitly lists more than one file in a particular
           directory, then we will wind up calling
           server_write_entries for each such file.  */
d1897 1
a1897 1
    /* Directory in which this notification happens.  malloc'd*/
d1900 1
a1900 1
    /* malloc'd.  */
d1903 1
a1903 1
    /* The following three all in one malloc'd block, pointed to by TYPE.
d1936 1
a1936 1
    new = (struct notify_note *) malloc (sizeof (struct notify_note));
d1942 2
a1943 2
    new->dir = malloc (strlen (dir_name) + 1);
    new->filename = malloc (strlen (arg) + 1);
d1962 1
a1962 1
	    pending_error_text = malloc (80 + strlen (arg));
d2072 1
a2072 1
	        buf_append_char (buf_to_net, '.');
d2074 1
a2074 1
	        buf_output0 (buf_to_net, dir);
d2115 1
a2115 1
    
d2117 1
a2117 1
    
d2122 1
a2122 1
	    (char **) realloc ((char *)argument_vector,
d2130 1
a2130 1
    p = malloc (strlen (arg) + 1);
d2145 1
a2145 1
    
d2147 1
a2147 1
    
d2149 1
a2149 1
    p = realloc (p, strlen (p) + 1 + strlen (arg) + 1);
d2175 3
d2180 1
a2190 3
	case 'l':
	    logoff = 1;
	    break;
d2237 4
a2240 4
           authentication.  Flush everything we've output so far, and
           turn on encryption for future data.  On the input side, we
           should only have unwrapped as far as the Gssapi-encrypt
           command, so future unwrapping will become encrypted.  */
d2273 2
a2274 2
           That includes authentication, so we don't have to do
           anything further.  */
a2363 1
static void serve_case PROTO ((char *));
d2365 1
a2365 7
static void
serve_case (arg)
    char *arg;
{
    ign_case = 1;
}

d2435 1
a2435 1
        return 1;
d2439 30
a2468 30
        /* This command has the potential to modify the repository, so
         * we check if the user have permission to do that.
         *
         * (Only relevant for remote users -- local users can do
         * whatever normal Unix file permissions allow them to do.)
         *
         * The decision method:
         *
         *    If $CVSROOT/CVSADMROOT_READERS exists and user is listed
         *    in it, then read-only access for user.
         *
         *    Or if $CVSROOT/CVSADMROOT_WRITERS exists and user NOT
         *    listed in it, then also read-only access for user.
         *
         *    Else read-write access for user.
         */

         char *linebuf = NULL;
         int num_red = 0;
         size_t linebuf_len = 0;
         char *fname;
         size_t flen;
         FILE *fp;
         int found_it = 0;
         
         /* else */
         flen = strlen (current_parsed_root->directory)
                + strlen (CVSROOTADM)
                + strlen (CVSROOTADM_READERS)
                + 3;
d2470 2
a2471 2
         fname = xmalloc (flen);
         (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
d2474 1
a2474 1
         fp = fopen (fname, "r");
d2476 1
a2476 1
         if (fp == NULL)
d2487 17
a2503 17
         else  /* successfully opened readers file */
         {
             while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
             {
                 /* Hmmm, is it worth importing my own readline
                    library into CVS?  It takes care of chopping
                    leading and trailing whitespace, "#" comments, and
                    newlines automatically when so requested.  Would
                    save some code here...  -kff */

                 /* Chop newline by hand, for strcmp()'s sake. */
                 if (linebuf[num_red - 1] == '\n')
                     linebuf[num_red - 1] = '\0';

                 if (strcmp (linebuf, CVS_Username) == 0)
                     goto handle_illegal;
             }
d2507 3
a2509 3
             /* If not listed specifically as a reader, then this user
                has write access by default unless writers are also
                specified in a file . */
d2512 1
a2512 1
         }
d2517 4
a2520 4
         flen = strlen (current_parsed_root->directory)
                + strlen (CVSROOTADM)
                + strlen (CVSROOTADM_WRITERS)
                + 3;
d2522 2
a2523 2
         fname = xmalloc (flen);
         (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
d2526 1
a2526 1
         fp = fopen (fname, "r");
d2528 2
a2529 2
         if (fp == NULL)
         {
d2531 1
a2531 1
	         free (linebuf);
d2547 8
a2554 1
         }
d2556 6
a2561 13
         found_it = 0;
         while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
         {
             /* Chop newline by hand, for strcmp()'s sake. */
             if (linebuf[num_red - 1] == '\n')
                 linebuf[num_red - 1] = '\0';
           
             if (strcmp (linebuf, CVS_Username) == 0)
             {
                 found_it = 1;
                 break;
             }
         }
d2565 3
a2567 3
         if (found_it)
         {
             if (fclose (fp) < 0)
d2569 2
a2570 2
             if (linebuf)
                 free (linebuf);
d2572 6
a2577 6
             return 1;
         }
         else   /* writers file exists, but this user not listed in it */
         {
         handle_illegal:
             if (fclose (fp) < 0)
d2579 2
a2580 2
             if (linebuf)
                 free (linebuf);
d2583 1
a2583 1
         }
d2596 1
d2598 1
d2624 1
a2624 1
    
d2656 1
d2745 2
a2746 2
           buf_from_net.  Instead, everything should go through
           protocol.  */
d2751 2
a2752 2
           Since we're now in the child, we should use the simpler
           protocol_memory_error function.  */
d2830 1
d2832 1
d2910 2
a2913 2
	    struct timeval *timeout_ptr;
	    struct timeval timeout;
d2976 2
a2977 2
                   as I know there was never any reason to do that and
                   SCO doesn't let you select on exceptions on pipes.  */
d3006 1
a3006 1
		
d3077 1
a3077 1
	        int status;
d3079 1
a3079 1
	        status = buf_input_data (stdoutbuf, (int *) NULL);
d3102 1
a3102 1
	        int status;
d3104 1
a3104 1
	        status = buf_input_data (stderrbuf, (int *) NULL);
d3164 1
a3164 1
	    
d3169 2
a3170 2
	        int sig = WTERMSIG (status);
	        char buf[50];
d3182 2
a3183 2
		/* Test for a core dump.  Is this portable?  */
		if (status & 0x80)
d3205 1
d3208 1
d3211 1
d3294 1
a3294 1
	
d3306 1
a3306 1
	    
d3322 2
a3323 2
               I/O.  System V nonblocking I/O returns zero if there is
               nothing to read.  */
d3325 1
a3325 1
	        error (1, 0, "flow control EOF");
d3328 1
a3328 1
	        error (1, errno, "flow control read failed");
d3429 1
a3429 1
    
a3626 2
    /* Tell cvslog() to behave like rlog not log.  */
    command_name = "rlog";
d3662 1
a3662 1
    do_cvs_command ("cvstag", cvstag);
a3668 2
    /* Tell cvstag() to behave like rtag not tag.  */
    command_name = "rtag";
d3706 1
a3706 1
    do_cvs_command ("watch_on", watch_on);
d3715 1
a3715 1
    do_cvs_command ("watch_off", watch_off);
d3724 1
a3724 1
    do_cvs_command ("watch_add", watch_add);
d3733 1
a3733 1
    do_cvs_command ("watch_remove", watch_remove);
d3785 2
d3791 15
a3805 3
		     "E Root %s must be an absolute pathname", arg);
	/* Fall through to do_cvs_command which will return the
	   actual error.  */
d3807 1
d3809 4
a3812 2
    if (current_parsed_root != NULL)
	free_cvsroot_t (current_parsed_root);
a3813 1

d3815 2
a3833 2
    /* Tell annotate() to behave like rannotate not annotate.  */
    command_name = "rannotate";
d3853 1
a3853 1
	tempdir = malloc (strlen (server_temp_dir) + 80);
d3890 2
a3891 2
                    "export" : "checkout",
                    checkout);
d4048 1
a4048 1
	        int i;
d4051 1
a4051 1
	        buf_output0 (protocol, "Checksum ");
d4100 1
a4100 1
        {
d4140 3
a4142 3
                   file_gzip_level is set.  We could handle this case,
                   but it's not worth it since this case never arises
                   with a current client and server.  */
d4408 1
d4470 2
a4471 2
         wrapper_line;
         wrap_unparse_rcs_options (&wrapper_line, 0))
d4538 1
a4538 1
           of aliases before removing */
d4554 1
a4554 1
	        buf_output0 (buf_to_net, "Module-expansion ");
a4578 1
    server_expanding = 1;
a4585 1
    server_expanding = 0;
a4606 42
void
server_prog (dir, name, which)
    char *dir;
    char *name;
    enum progs which;
{
    if (!supported_response ("Set-checkin-prog"))
    {
	buf_output0 (buf_to_net, "E \
warning: this client does not support -i or -u flags in the modules file.\n");
	return;
    }
    switch (which)
    {
	case PROG_CHECKIN:
	    buf_output0 (buf_to_net, "Set-checkin-prog ");
	    break;
	case PROG_UPDATE:
	    buf_output0 (buf_to_net, "Set-update-prog ");
	    break;
    }
    buf_output0 (buf_to_net, dir);
    buf_append_char (buf_to_net, '\n');
    buf_output0 (buf_to_net, name);
    buf_append_char (buf_to_net, '\n');
}

static void
serve_checkin_prog (arg)
    char *arg;
{
    FILE *f;

    /* Before we do anything we first check if this command is not 
       disabled. */
    if (disable_x_prog)
    {
	if (alloc_pending (80))
	    sprintf (pending_error_text, "\
E Checkin-prog disabled by configuration");
	return;
    }
a4607 83
    f = CVS_FOPEN (CVSADM_CIPROG, "w+");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_CIPROG);
	pending_error = save_errno;
	return;
    }
    if (fprintf (f, "%s\n", arg) < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text,
		     "E cannot write to %s", CVSADM_CIPROG);
	pending_error = save_errno;
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_CIPROG);
	pending_error = save_errno;
	return;
    }
}

static void
serve_update_prog (arg)
    char *arg;
{
    FILE *f;

    /* Before we do anything we first check if this command is not 
       disabled. */
    if (disable_x_prog)
    {
	if (alloc_pending (80))
	    sprintf (pending_error_text, "\
E Update-prog disabled by configuration");
	return;
    }
    
    /* Before we do anything we need to make sure we are not in readonly
       mode.  */
    if (!check_command_legal_p ("commit"))
    {
	/* I might be willing to make this a warning, except we lack the
	   machinery to do so.  */
	if (alloc_pending (80))
	    sprintf (pending_error_text, "\
E Flag -u in modules not allowed in readonly mode");
	return;
    }

    f = CVS_FOPEN (CVSADM_UPROG, "w+");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_UPROG);
	pending_error = save_errno;
	return;
    }
    if (fprintf (f, "%s\n", arg) < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot write to %s", CVSADM_UPROG);
	pending_error = save_errno;
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_UPROG);
	pending_error = save_errno;
	return;
    }
}

a4636 2
  REQ_LINE("Checkin-prog", serve_checkin_prog, 0),
  REQ_LINE("Update-prog", serve_update_prog, 0),
a4650 1
  REQ_LINE("Case", serve_case, 0),
d4656 2
a4657 2
           serve_wrapper_sendme_rcs_options,
           0),
d4756 1
d4760 23
d4785 5
a4789 5
	/* FIXME: If this is not the final call from server, this
	   could deadlock, because the client might be blocked writing
	   to us.  This should not be a problem in practice, because
	   we do not generate much output when the client is not
	   waiting for it.  */
d4793 4
a4796 5
	/* The calls to buf_shutdown are currently only meaningful
	   when we are using compression.  First we shut down
	   BUF_FROM_NET.  That will pick up the checksum generated
	   when the client shuts down its buffer.  Then, after we have
	   generated any final output, we shut down BUF_TO_NET.  */
d4798 1
a4798 2
	status = buf_shutdown (buf_from_net);
	if (status != 0)
d4800 5
a4804 2
	    error (0, status, "shutting down buffer from client");
	    buf_flush (buf_to_net, 1);
a4805 1
    }
d4807 3
a4809 3
    if (dont_delete_temp)
    {
	if (buf_to_net != NULL)
d4811 7
a4818 1
    }
d4914 2
d4917 4
a4923 1
int server_expanding = 0;
d4930 2
d4946 1
a4946 1
    buf_from_net = stdio_buffer_initialize (stdin, 1, outbuf_memory_error);
d4978 1
a4978 1
	    server_temp_dir = malloc (strlen (Tmpdir) + 80);
d4988 1
a4988 12
		/* I'm doing this manually rather than via error_exit ()
		   because I'm not sure whether we want to call server_cleanup.
		   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
		/* Hook for OS-specific behavior, for example socket
		   subsystems on NT and OS2 or dealing with windows
		   and arguments on Mac.  */
		SYSTEM_CLEANUP ();
#endif

		exit (EXIT_FAILURE);
d5010 2
a5011 2
               700, to discourage random people from tampering with
               it.  */
d5014 1
a5014 1
	        static const char suffix[] = "abcdefghijklmnopqrstuvwxyz";
d5016 1
a5016 1
	        if (i >= sizeof suffix - 1) break;
a5051 19
#ifdef SIGABRT
    (void) SIG_register (SIGABRT, server_cleanup);
#endif
#ifdef SIGHUP
    (void) SIG_register (SIGHUP, server_cleanup);
#endif
#ifdef SIGINT
    (void) SIG_register (SIGINT, server_cleanup);
#endif
#ifdef SIGQUIT
    (void) SIG_register (SIGQUIT, server_cleanup);
#endif
#ifdef SIGPIPE
    (void) SIG_register (SIGPIPE, server_cleanup);
#endif
#ifdef SIGTERM
    (void) SIG_register (SIGTERM, server_cleanup);
#endif

d5057 1
a5057 23
	(char **) malloc (argument_vector_size * sizeof (char *));
    if (argument_vector == NULL)
    {
	/*
	 * Strictly speaking, we're not supposed to output anything
	 * now.  But we're about to exit(), give it a try.
	 */
	printf ("E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");

	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif

	exit (EXIT_FAILURE);
    }

a5060 1
       FIXME: probably should be using program_name here.
d5066 3
a5068 1
    argument_vector[0] = "cvs server";
d5075 1
a5075 1
	
d5133 1
a5133 1
	        buf_output0 (buf_to_net, "error  unrecognized request `");
d5141 1
d5148 1
a5148 1
static void switch_to_user PROTO((const char *));
d5151 2
a5152 1
switch_to_user (username)
d5160 2
a5161 2
	/* Normally this won't be reached; check_password contains
	   a similar check.  */
d5164 1
a5164 1
error 0 %s: no such user\n", username);
d5169 14
d5223 5
d5233 1
a5233 1
    
d5243 5
d5262 1
a5262 1
      
a5267 3
#ifdef AUTH_SERVER_SUPPORT
	char *cvs_user;
#endif
d5278 3
a5280 4
        cvs_user = NULL != CVS_Username ? CVS_Username : "";
        env = xmalloc (sizeof "CVS_USER=" + strlen (cvs_user));
        (void) sprintf (env, "CVS_USER=%s", cvs_user);
        (void) putenv (env);
d5292 1
a5292 1
/* 
d5316 2
a5317 2
    /* We don't use current_parsed_root->directory because it hasn't been set yet
     * -- our `repository' argument came from the authentication
d5329 1
a5329 1
                    CVSROOTADM, CVSROOTADM_PASSWD);
d5345 1
a5345 1
        {
d5348 1
a5348 1
        }
d5359 1
a5359 1
        char *non_cvsuser_portion;
d5361 18
a5378 18
        /* We need to make sure lines such as 
         *
         *    "username::sysuser\n"
         *    "username:\n"
         *    "username:  \n"
         *
         * all result in a found_password of NULL, but we also need to
         * make sure that
         *
         *    "username:   :sysuser\n"
         *    "username: <whatever>:sysuser\n"
         *
         * continues to result in an impossible password.  That way,
         * an admin would be on safe ground by going in and tacking a
         * space onto the front of a password to disable the account
         * (a technique some people use to close accounts
         * temporarily).
         */
d5380 2
a5381 2
        /* Make `non_cvsuser_portion' contain everything after the CVS
           username, but null out any final newline. */
d5383 5
a5387 1
        strtok (non_cvsuser_portion, "\n");
d5389 2
a5390 27
        /* If there's a colon now, we just want to inch past it. */
        if (strchr (non_cvsuser_portion, ':') == non_cvsuser_portion)
            non_cvsuser_portion++;

        /* Okay, after this conditional chain, found_password and
           host_user_tmp will have useful values: */

        if ((non_cvsuser_portion == NULL)
            || (strlen (non_cvsuser_portion) == 0)
            || ((strspn (non_cvsuser_portion, " \t"))
                == strlen (non_cvsuser_portion)))
        {
            found_password = NULL;
            host_user_tmp = NULL;
        }
        else if (strncmp (non_cvsuser_portion, ":", 1) == 0)
        {
            found_password = NULL;
            host_user_tmp = non_cvsuser_portion + 1;
            if (strlen (host_user_tmp) == 0)
                host_user_tmp = NULL;
        }
        else
        {
            found_password = strtok (non_cvsuser_portion, ":");
            host_user_tmp = strtok (NULL, ":");
        }
d5392 22
a5413 1
        /* Of course, maybe there was no system user portion... */
d5415 1
a5415 1
            host_user_tmp = username;
d5417 7
a5423 7
        /* Verify blank passwords directly, otherwise use crypt(). */
        if ((found_password == NULL)
            || ((strcmp (found_password, crypt (password, found_password))
                 == 0)))
        {
            /* Give host_user_ptr permanent storage. */
            *host_user_ptr = xstrdup (host_user_tmp);
d5425 1
a5425 1
        }
d5427 9
a5435 4
        {
            *host_user_ptr = NULL;
	    retval         = 2;
        }
d5445 1
a5445 1
        free (linebuf);
d5458 2
a5470 2
    /* else */

d5473 2
a5474 2
        /* host_user already set by reference, so just return. */
        goto handle_return;
d5476 4
a5479 1
    else if (rc == 0 && system_auth)
d5481 12
a5492 1
	/* No cvs password found, so try /etc/passwd. */
a5493 2
	const char *found_passwd = NULL;
	struct passwd *pw;
d5495 1
d5503 1
d5506 8
a5513 8
	if (found_passwd == NULL && (pw = getpwnam (username)) != NULL)
	{
	    found_passwd = pw->pw_passwd;
	}
	
	if (found_passwd == NULL)
	{
	    printf ("E Fatal error, aborting.\n\
d5516 17
a5532 3
	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */
d5534 5
a5538 21
#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket subsystems on
	       NT and OS2 or dealing with windows and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

	    exit (EXIT_FAILURE);
	}
	
	if (*found_passwd)
        {
	    /* user exists and has a password */
	    host_user = ((! strcmp (found_passwd,
                                    crypt (password, found_passwd)))
                         ? xstrdup (username) : NULL);
            goto handle_return;
        }
	else if (password && *password)
        {
	    /* user exists and has no system password, but we got
	       one as parameter */
d5540 1
a5540 2
            goto handle_return;
        }
d5542 1
a5542 2
        {
	    /* user exists but has no password at all */
d5544 7
a5550 2
            goto handle_return;
        }
d5552 2
a5553 1
    else if (rc == 0)
d5555 5
a5559 7
	/* Note that the message _does_ distinguish between the case in
	   which we check for a system password and the case in which
	   we do not.  It is a real pain to track down why it isn't
	   letting you in if it won't say why, and I am not convinced
	   that the potential information disclosure to an attacker
	   outweighs this.  */
	printf ("error 0 no such user %s in CVSROOT/passwd\n", username);
d5561 5
a5565 8
	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
a5566 9
	exit (EXIT_FAILURE);
    }
    else
    {
	/* Something strange happened.  We don't know what it was, but
	   we certainly won't grant authorization. */
	host_user = NULL;
        goto handle_return;
    }
d5571 4
a5574 4
        /* Set CVS_Username here, in allocated space. 
           It might or might not be the same as host_user. */
        CVS_Username = xmalloc (strlen (username) + 1);
        strcpy (CVS_Username, username);
d5629 1
a5629 1
     *            and
d5665 6
a5670 4
	/* FIXME: what?  We could try writing error/eof, but chances
	   are the network connection is dead bidirectionally.  log it
	   somewhere?  */
	;
d5701 10
a5710 4
    /* Make them pure. */ 
    strip_trailing_newlines (repository);
    strip_trailing_newlines (username);
    strip_trailing_newlines (password);
a5740 2
    memset (descrambled_password, 0, strlen (descrambled_password));
    free (descrambled_password);
a5744 4
#ifdef LOG_AUTHPRIV
        syslog (LOG_AUTHPRIV | LOG_NOTICE, "login failure by %s / %s (for %s)",
        	username, descrambled_password, repository);
#endif
d5746 2
d5756 2
d5780 1
a5780 1
    switch_to_user (host_user);
d5817 2
a5818 6
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
	exit (EXIT_FAILURE);
d5844 2
a5845 6
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
	exit (EXIT_FAILURE);
d5856 2
a5857 6
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
	exit (EXIT_FAILURE);
d5861 1
a5861 1
    switch_to_user (user);
d5926 10
a5935 10
                                &gcontext,	/* context_handle */
                                server_creds,	/* verifier_cred_handle */
                                &tok_in,	/* input_token */
                                NULL,		/* channel bindings */
                                &client_name,	/* src_name */
                                &mechid,	/* mech_type */
                                &tok_out,	/* output_token */
                                &ret,
                                NULL,	 	/* ignore time_rec */
                                NULL)		/* ignore del_cred_handle */
d5973 1
a5973 1
    switch_to_user (buf);
d6246 1
a6246 1
    if (error_use_protocol)
d6251 1
a6251 1
    else if (server_active)
d6431 1
a6431 1
	 */ 
d6461 1
a6461 1
	 
@


1.1.2.1
log
@vendor-branch-ify new cvs 1.12
@
text
@d11 1
a16 1
#include "getnline.h"
a19 8

#include "log-buffer.h"
#include "ms-buffer.h"

#if defined(PROXY_SUPPORT) || defined(HAVE_GSSAPI)
#  include <netdb.h>
#endif /* defined(PROXY_SUPPORT) || defined(HAVE_GSSAPI) */

a20 2
#   include "gssapi-client.h"

d27 2
d33 4
a36 1
static void gserver_authenticate_connection (void);
d41 7
d53 3
a55 11
/* This isn't defined anywhere else that I know of.  We made it up.  Referenced
 * both times this file can call gethostname.
 *
 * FIXME: This should probably correspond to any hostname length limits defined
 * by POSIX or some appropriate internet standard, but I'm not sure where to
 * look and I haven't heard any complaints.  If you happen to know the correct
 * standard, it should probably at least be referenced in this comment.
 */
# ifndef MAXHOSTNAMELEN
#   define MAXHOSTNAMELEN (256)
# endif
d57 3
a59 3
# ifdef HAVE_WINSOCK_H
#   include <winsock.h>
# endif
d61 3
a63 3
# if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_KERBEROS) || defined (HAVE_GSSAPI)
#   include <sys/socket.h>
# endif
d65 5
a69 5
# ifdef HAVE_SYSLOG_H
#   include <syslog.h>
#   ifndef LOG_DAEMON   /* for ancient syslogs */
#     define LOG_DAEMON 0
#   endif
a71 7
# ifdef HAVE_KERBEROS
#   include <netinet/in.h>
#   include <krb.h>
#   ifndef HAVE_KRB_GET_ERR_TEXT
#     define krb_get_err_text(status) krb_err_txt[status]
#   endif

d76 1
a76 1
# endif
d79 5
a83 1
# include "xselect.h"
d85 7
a91 3
# ifndef O_NONBLOCK
#   define O_NONBLOCK O_NDELAY
# endif
d94 3
a96 3
# if HAVE_INITGROUPS
#   include <grp.h>
# endif /* HAVE_INITGROUPS */
d114 8
d124 1
a124 8
#ifdef HAVE_PAM
# include <security/pam_appl.h>

static pam_handle_t *pamh = NULL;
#endif



a132 23


#ifdef PROXY_SUPPORT
/* These are the secondary log buffers so that we can disable them after
 * creation, when it is determined that they are unneeded, regardless of what
 * other filters have been prepended to the buffer chain.
 */
static struct buffer *proxy_log;
static struct buffer *proxy_log_out;

/* Set while we are reprocessing a log so that we can avoid sending responses
 * to some requests twice.
 */
static bool reprocessing;
#endif /* PROXY_SUPPORT */



/* Arguments storage for `Argument' & `Argumentx' requests.  */
static int argument_count;
static char **argument_vector;
static int argument_vector_size;

d146 137
a282 1
static void server_write_entries (void);
d284 27
a310 1
cvsroot_t *referrer;
d312 12
d325 9
d338 2
d341 3
a343 1
create_adm_p (char *base_dir, char *dir)
d353 1
a353 1
    p = xmalloc (strlen (dir) + 1);
d357 1
a357 1
    dir_where_cvsadm_lives = xmalloc (strlen (base_dir) + strlen (dir) + 100);
d363 1
a363 1
    tmp = xmalloc (strlen (base_dir) + strlen (dir) + 100);
d367 1
a367 1

d403 1
a403 1
	    empty = xmalloc (strlen (current_parsed_root->directory)
d430 2
a431 1

d515 1
a515 1
static int mkdir_p (char *);
d518 2
a519 1
mkdir_p (char *dir)
d522 1
a522 1
    char *q = xmalloc (strlen (dir) + 1);
d576 2
a577 1
print_error (int status)
d605 1
a605 1
print_pending_error (void)
d636 1
a636 1
static int alloc_pending (size_t size);
d641 2
a642 1
alloc_pending (size_t size)
d649 1
a649 1
    pending_error_text = xmalloc (size);
d657 2
d660 1
a660 1

d663 2
a664 1
supported_response (char *name)
a675 131


/* Return true if two paths match, resolving symlinks.
 */
static inline bool
isSamePath (const char *path1_in, const char *path2_in)
{
    char *p1, *p2;
    bool same;

    if (!strcmp (config->PrimaryServer->directory,
		 current_parsed_root->directory))
	return true;

    /* Path didn't match, but try to resolve any links that may be
     * present.
     */
    if (!isdir (path1_in) || !isdir (path2_in))
	/* To be resolvable, paths must exist on this server.  */
	return false;

    p1 = xresolvepath (path1_in);
    p2 = xresolvepath (path2_in);
    if (strcmp (p1, p2))
	same = false;
    else
	same = true;

    free (p1);
    free (p2);
    return same;
}



/* Return true if OTHERHOST resolves to this host in the DNS.
 */
static inline bool
isThisHost (const char *otherhost)
{
    /* THISHOST is static so that it may be cached.  Our hostname will not
     * change from one call to the next.
     */
    static char *thishost = NULL;
    struct hostent *hinfo;

    /* Our hostname must also match for this to be the primary.  */
    if (!thishost)
    {
	thishost = xmalloc (MAXHOSTNAMELEN);
	if (gethostname (thishost, MAXHOSTNAMELEN))
	    error (1, errno, "Failed to retrieve hostname.");
	thishost[MAXHOSTNAMELEN - 1] = '\0';
    }

    if (!(hinfo = gethostbyname (otherhost)))
#ifdef HAVE_HSTRERROR
	error (1, 0, "Name lookup failed for `%s': %s",
	       otherhost, hstrerror (h_errno));
#else
	error (1, 0, "Name lookup failed for `%s': h_error=%d",
	       otherhost, h_errno);
#endif

    return !strcasecmp (thishost, hinfo->h_name);
}



/*
 * Return true if we need to relay write requests to a primary server
 * and false otherwise.
 *
 * NOTES
 *
 *   - primarily handles :ext: method as this seems most likely to be used in
 *     practice.
 *
 *   - :fork: method is handled for testing.
 *
 *   - Could handle pserver too, but would have to store the password
 *     the client sent us.
 *
 *
 * GLOBALS
 *   config->PrimaryServer
 *                        The parsed setting from CVSROOT/config, if any, or
 *                        NULL, otherwise.
 *   current_parsed_root  The current repository.
 *
 * RETURNS
 *   true                 If this server is configured as a secondary server.
 *   false                Otherwise.
 */
static inline bool
isProxyServer (void)
{
    assert (current_parsed_root);

    /***
     *** The following is done as a series of if/return combinations an an
     *** optimization.
     ***/

    /* If there is no primary server defined in CVSROOT/config, then we can't
     * be a secondary.
     */
    if (!config || !config->PrimaryServer) return false;

    /* The directory must not match for all methods.  */
    if (!isSamePath (config->PrimaryServer->directory,
		     current_parsed_root->directory))
	return true;

    /* Only the directory is important for fork.  */
    if (config->PrimaryServer->method == fork_method)
	return false;

    /* Must be :ext: method, then.  This is enforced when CVSROOT/config is
     * parsed.
     */
    assert (config->PrimaryServer->method == ext_method);

    if (isThisHost (config->PrimaryServer->hostname))
	return false;

    return true;
}



d677 2
a678 1
serve_valid_responses (char *arg)
a682 8

#ifdef PROXY_SUPPORT
    /* Process this in the first pass since the data it gathers can be used
     * prior to a `Root' request.
     */
    if (reprocessing) return;
#endif /* PROXY_SUPPORT */

d715 10
a731 89


/*
 * Process IDs of the subprocess, or negative if that subprocess
 * does not exist.
 */
static pid_t command_pid;

static void
outbuf_memory_error (struct buffer *buf)
{
    static const char msg[] = "E Fatal server error\n\
error ENOMEM Virtual memory exhausted.\n";
    if (command_pid > 0)
	kill (command_pid, SIGTERM);

    /*
     * We have arranged things so that printing this now either will
     * be valid, or the "E fatal error" line will get glommed onto the
     * end of an existing "E" or "M" response.
     */

    /* If this gives an error, not much we could do.  syslog() it?  */
    write (STDOUT_FILENO, msg, sizeof (msg) - 1);
#ifdef HAVE_SYSLOG_H
    syslog (LOG_DAEMON | LOG_ERR, "virtual memory exhausted");
#endif
    exit (EXIT_FAILURE);
}



static void
input_memory_error (struct buffer *buf)
{
    outbuf_memory_error (buf);
}



#ifdef PROXY_SUPPORT
/* This function rewinds the net connection using the write proxy log file.
 *
 * GLOBALS
 *   proxy_log	The buffer object containing the write proxy log.
 *
 * RETURNS
 *   Nothing.
 */
static void
rewind_buf_from_net (void)
{
    struct buffer *log;

    assert (proxy_log);

    /* Free the arguments since we processed some of them in the first pass.
     */
    {
	/* argument_vector[0] is a dummy argument, we don't mess with
	 * it.
	 */
	char **cp;
	for (cp = argument_vector + 1;
	     cp < argument_vector + argument_count;
	     ++cp)
	    free (*cp);

	argument_count = 1;
    }

    log = log_buffer_rewind (proxy_log);
    proxy_log = NULL;
    /* Dispose of any read but unused data in the net buffer since it will
     * already be in the log.
     */
    buf_free_data (buf_from_net);
    buf_from_net = ms_buffer_initialize (outbuf_memory_error, log,
					 buf_from_net);
    reprocessing = true;
}
#endif /* PROXY_SUPPORT */



/*
 * This request cannot be ignored by a potential secondary since it is used to
 * determine if we _are_ a secondary.
 */
d733 2
a734 1
serve_root (char *arg)
d738 2
a739 9

    TRACE (TRACE_FUNCTION, "serve_root (%s)", arg ? arg : "(null)");

    /* Don't process this twice or when errors are pending.  */
    if (error_pending()
#ifdef PROXY_SUPPORT
	|| reprocessing
#endif /* PROXY_SUPPORT */
       ) return;
d749 1
a749 1
    /* Sending "Root" twice is invalid.
a763 6
    /* Set original_parsed_root here, not because it can be changed in the
     * client Redirect sense, but so we don't have to switch in code that
     * runs in both modes to decide which to print.
     */
    original_parsed_root = current_parsed_root = local_cvsroot (arg);

d767 1
a767 1
	if (strcmp (Pserver_Repos, current_parsed_root->directory) != 0)
d769 1
a769 2
	    if (alloc_pending (80 + strlen (Pserver_Repos)
			       + strlen (current_parsed_root->directory)))
d775 1
a775 2
			 current_parsed_root->directory, Pserver_Repos);
	    return;
d780 4
d786 1
a786 23
    config = get_root_allow_config (current_parsed_root->directory);

#ifdef PROXY_SUPPORT
    /* At this point we have enough information to determine if we are a
     * secondary server or not.
     */
    if (proxy_log && !isProxyServer ())
    {
	/* Else we are not a secondary server.  There is no point in
	 * reprocessing since we handle all the requests we can receive
	 * before `Root' as we receive them.  But close the logs.
	 */
	log_buffer_closelog (proxy_log);
	log_buffer_closelog (proxy_log_out);
	proxy_log = NULL;
	/*
	 * Don't need this.  We assume it when proxy_log == NULL.
	 *
	 *   proxy_log_out = NULL;
	 */
    }
#endif /* PROXY_SUPPORT */

d788 1
a788 1
    path = xmalloc (strlen (current_parsed_root->directory)
d797 1
a797 1
    if (!isaccessible (path, R_OK | X_OK))
d807 1
a807 1
    env = xmalloc (strlen (CVSROOT_ENV) + strlen (current_parsed_root->directory) + 2);
d818 1
a818 3



d824 2
a825 1
server_pathname_check (char *path)
a826 3
    TRACE (TRACE_FUNCTION, "server_pathname_check (%s)",
	   path ? path : "(null)");

d843 1
a843 3
	error ( 1, 0,
		"absolute pathnames invalid for server (specified `%s')",
		path );
d853 1
a853 1
static int outside_root (char *);
d859 2
a860 1
outside_root (char *repos)
d865 4
a868 3
    /* isabsolute (repos) should always be true, but
       this is a good security precaution regardless. -DRP
     */
d899 1
a899 1
static int outside_dir (char *);
d905 2
a906 1
outside_dir (char *file)
d919 1
a919 3



d926 2
a927 1
serve_max_dotdot (char *arg)
d933 1
a933 5
#ifdef PROXY_SUPPORT
    if (proxy_log) return;
#endif /* PROXY_SUPPORT */

    if (lim < 0 || lim > 10000)
d935 1
a935 1
    p = xmalloc (strlen (server_temp_dir) + 2 * lim + 10);
d949 2
a950 5



static char *gDirname;
static char *gupdate_dir;
d953 3
a955 1
dirswitch (char *dir, char *repos)
a960 3
    TRACE (TRACE_FUNCTION, "dirswitch (%s, %s)", dir ? dir : "(null)",
	   repos ? repos : "(null)");

d972 2
a973 3
	    sprintf ( pending_error_text,
		      "E absolute pathnames invalid for server (specified `%s')",
		      dir);
d986 1
a986 1
    /* Check for a trailing '/'.  This is not ISSLASH because \ in the
d999 2
a1000 4
    if (gDirname != NULL)
	free (gDirname);
    if (gupdate_dir != NULL)
	free (gupdate_dir);
d1002 2
a1003 7
    if (!strcmp (dir, "."))
	gupdate_dir = xstrdup ("");
    else
	gupdate_dir = xstrdup (dir);

    gDirname = xmalloc (strlen (server_temp_dir) + dir_len + 40);
    if (gDirname == NULL)
d1008 4
d1013 1
a1013 5
    strcpy (gDirname, server_temp_dir);
    strcat (gDirname, "/");
    strcat (gDirname, dir);

    status = mkdir_p (gDirname);
d1017 2
a1018 2
	if (alloc_pending (80 + strlen (gDirname)))
	    sprintf (pending_error_text, "E cannot mkdir %s", gDirname);
d1032 2
a1033 2
	if (alloc_pending (80 + strlen (gDirname)))
	    sprintf (pending_error_text, "E cannot create_adm_p %s", gDirname);
d1038 1
a1038 1
    if ( CVS_CHDIR (gDirname) < 0)
d1041 2
a1042 2
	if (alloc_pending (80 + strlen (gDirname)))
	    sprintf (pending_error_text, "E cannot change to %s", gDirname);
d1053 1
a1053 1
	if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM)))
d1055 1
a1055 1
		     "E cannot mkdir %s/%s", gDirname, CVSADM);
d1069 1
a1069 1
	if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM_REP)))
d1071 1
a1071 1
		     "E cannot open %s/%s", gDirname, CVSADM_REP);
d1078 1
a1078 1
	if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM_REP)))
d1080 1
a1080 1
		     "E error writing %s/%s", gDirname, CVSADM_REP);
d1093 1
a1093 1
	if (fprintf (f, "/.") < 0)
d1096 1
a1096 1
	    if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM_REP)))
d1098 1
a1098 1
			 "E error writing %s/%s", gDirname, CVSADM_REP);
d1107 1
a1107 1
	if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM_REP)))
d1109 1
a1109 1
		     "E error writing %s/%s", gDirname, CVSADM_REP);
d1117 1
a1117 1
	if (alloc_pending (80 + strlen (gDirname) + strlen (CVSADM_REP)))
d1119 1
a1119 1
		     "E error closing %s/%s", gDirname, CVSADM_REP);
a1143 2


d1145 2
a1146 1
serve_repository (char *arg)
a1147 4
#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */

a1153 2


d1155 2
a1156 1
serve_directory (char *arg)
d1161 1
a1161 7
    TRACE (TRACE_FUNCTION, "serve_directory (%s)", arg ? arg : "(null)");


    /* The data needs to be read into the secondary log regardless, but
     * processing of anything other than errors is skipped until later.
     */
    status = buf_read_line (buf_from_net, &repos, NULL);
d1164 1
a1164 28
	if (!isabsolute (repos))
	{
	    /* Make absolute.
	     *
	     * FIXME: This is kinda hacky - we should probably only ever store
	     * and pass SHORT_REPOS (perhaps with the occassional exception
	     * for optimizations, but many, many functions end up
	     * deconstructing REPOS to gain SHORT_REPOS anyhow) - the
	     * CVSROOT portion of REPOS is redundant with
	     * current_parsed_root->directory - but since this is the way
	     * things have always been done, changing this will likely involve
	     * a major overhaul.
	     */
	    char *short_repos;

	    short_repos = repos;
	    repos = Xasprintf ("%s/%s",
	                      current_parsed_root->directory, short_repos);
	    free (short_repos);
	}
	else
	    repos = xstrdup (primary_root_translate (repos));

	if (
#ifdef PROXY_SUPPORT
	    !proxy_log &&
#endif /* PROXY_SUPPORT */
	    !outside_root (repos))
d1170 1
a1170 1
	pending_error = ENOMEM;
d1172 1
a1172 1
    else if (status != 0)
d1174 1
a1174 1
	pending_error_text = xmalloc (80 + strlen (arg));
d1192 1
a1192 3



d1194 2
a1195 1
serve_static_directory (char *arg)
d1199 1
a1199 5
    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       ) return;
a1219 2


d1221 2
a1222 1
serve_sticky (char *arg)
d1226 1
a1226 5
    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       ) return;
d1254 1
a1254 3



d1265 3
a1267 1
receive_partial_file (size_t size, int file)
d1271 1
a1271 2
	int status;
	size_t nread;
d1281 1
a1281 1
		pending_error_text = xmalloc (80);
d1304 1
a1304 1
	    size_t nwrote;
d1309 1
a1309 1
		int save_errno = errno;
d1317 1
a1317 2
		    int status;
		    size_t nread;
d1336 4
a1339 1
receive_file (size_t size, char *file, int gzipped)
d1364 1
a1364 1
	size_t toread = size;
d1368 1
a1368 1
	filebuf = xmalloc (size);
d1374 1
a1374 2
	    int status;
	    size_t nread;
d1384 1
a1384 1
		    pending_error_text = xmalloc (80);
d1430 1
a1430 1
	char *p = xrealloc (pending_error_text,
a1450 2


d1459 1
a1459 130


/*
 * Used to keep track of Entry requests.
 */
struct an_entry {
    struct an_entry *next;
    char *entry;
};

static struct an_entry *entries;

static void
serve_is_modified (char *arg)
{
    struct an_entry *p;
    char *name;
    char *cp;
    char *timefield;
    /* Have we found this file in "entries" yet.  */
    int found;

    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       ) return;

    if (outside_dir (arg))
	return;

    /* Rewrite entries file to have `M' in timestamp field.  */
    found = 0;
    for (p = entries; p != NULL; p = p->next)
    {
	name = p->entry + 1;
	cp = strchr (name, '/');
	if (cp != NULL
	    && strlen (arg) == cp - name
	    && strncmp (arg, name, cp - name) == 0)
	{
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
	    {
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
		cp = timefield + strlen (timefield);
		cp[1] = '\0';
		while (cp > timefield)
		{
		    *cp = cp[-1];
		    --cp;
		}
	    }
	    /* If *TIMEFIELD wasn't '/', we assume that it was because of
	     * multiple calls to Is-modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of CVSNT (at least 2.0.34 -
	     * 2.0.41, reported fixed in 2.0.41a) and the WinCVS & TortoiseCVS
	     * clients which depend on those broken versions of CVSNT (WinCVS
	     * 1.3 & at least one TortoiseCVS release) rely on this behavior.
	     */
	    *timefield++ = 'M';
	    if (kopt != NULL)
	    {
		if (alloc_pending (strlen (name) + 80))
		    sprintf (pending_error_text,
			     "E protocol error: both Kopt and Entry for %s",
			     arg);
		free (kopt);
		kopt = NULL;
		return;
	    }
	    found = 1;
	    break;
	}
    }
    if (!found)
    {
	/* We got Is-modified but no Entry.  Add a dummy entry.
	   The "D" timestamp is what makes it a dummy.  */
	p = xmalloc (sizeof (struct an_entry));
	if (p == NULL)
	{
	    pending_error = ENOMEM;
	    return;
	}
	p->entry = xmalloc (strlen (arg) + 80);
	if (p->entry == NULL)
	{
	    pending_error = ENOMEM;
	    free (p);
	    return;
	}
	strcpy (p->entry, "/");
	strcat (p->entry, arg);
	strcat (p->entry, "//D/");
	if (kopt != NULL)
	{
	    strcat (p->entry, kopt);
	    free (kopt);
	    kopt = NULL;
	}
	strcat (p->entry, "/");
	p->next = entries;
	entries = p;
    }
}


d1462 2
a1463 1
serve_modified (char *arg)
d1465 1
a1465 3
    size_t size;
    int read_size;
    int status;
d1480 1
a1480 1
    status = buf_read_line (buf_from_net, &mode_text, NULL);
d1483 1
a1483 1
	if (status == -2)
d1487 1
a1487 1
	    pending_error_text = xmalloc (80 + strlen (arg));
d1506 1
a1506 1
    status = buf_read_line (buf_from_net, &size_text, NULL);
d1513 1
a1513 1
	    pending_error_text = xmalloc (80 + strlen (arg));
d1535 1
a1535 1
	read_size = atoi (size_text + 1);
d1538 1
a1538 1
	read_size = atoi (size_text);
a1540 9
    if (read_size < 0 && alloc_pending (80))
    {
	sprintf (pending_error_text,
		 "E client sent invalid (negative) file size");
	return;
    }
    else
	size = read_size;

d1543 1
a1543 1
	/* Now that we know the size, read and discard the file data.  */
d1546 1
a1546 2
	    int status;
	    size_t nread;
d1558 1
a1558 5
    if (
#ifdef PROXY_SUPPORT
	!proxy_log &&
#endif /* PROXY_SUPPORT */
	outside_dir (arg))
d1564 1
a1564 7
    receive_file (size,
#ifdef PROXY_SUPPORT
	          proxy_log ? DEVNULL :
#endif /* PROXY_SUPPORT */
			      arg,
		  gzipped);
    if (error_pending ())
d1566 6
a1571 2
	free (mode_text);
	return;
a1573 7
#ifdef PROXY_SUPPORT
    /* We've read all the data that needed to be read if we're still logging
     * for a secondary.  Return.
     */
    if (proxy_log) return;
#endif /* PROXY_SUPPORT */

d1613 1
a1613 2


d1615 2
a1616 1
serve_enable_unchanged (char *arg)
a1617 8
#ifdef PROXY_SUPPORT
    /* Might as well skip this since this function does nothing anyhow.  If
     * it did do anything and could generate errors, then the line below would
     * be necessary since this can be processed before a `Root' request.
     *
     *     if (reprocessing) return;
     */
#endif /* PROXY_SUPPORT */
d1620 6
d1627 1
d1630 2
a1631 1
serve_unchanged (char *arg)
d1638 2
a1639 5
    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       ) return;
d1653 2
a1654 19
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
a1655 2
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
d1663 1
a1664 32
	    else if (timefield[1] != '/')
	    {
		/* Obliterate anything else in TIMEFIELD.  This is again to
		 * support the broken CVSNT clients mentioned below, in
		 * conjunction with strict timestamp string boundry checking in
		 * time_stamp_server() from vers_ts.c & file_has_conflict()
		 * from subr.c, since the broken clients used to send malformed
		 * timestamp fields in the Entry request that they then
		 * depended on the subsequent Unchanged request to overwrite.
		 */
		char *d = timefield + 1;
		if ((cp = strchr (d, '/')))
		{
		    while (*cp)
		    {
			*d++ = *cp++;
		    }
		    *d = '\0';
		}
	    }
	    /* If *TIMEFIELD wasn't '/', we assume that it was because of
	     * multiple calls to Is-modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of CVSNT (at least 2.0.34 -
	     * 2.0.41, reported fixed in 2.0.41a) and the WinCVS & TortoiseCVS
	     * clients which depend on those broken versions of CVSNT (WinCVS
	     * 1.3 & at least one TortoiseCVS release) rely on this behavior.
	     */
	    *timefield = '=';
a1669 2


d1671 2
a1672 1
serve_entry (char *arg)
d1675 1
d1677 3
a1679 1
    int i = 0;
d1681 1
a1681 36
    if (error_pending()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       ) return;

    /* Verify that the entry is well-formed.  This can avoid problems later.
     * At the moment we only check that the Entry contains five slashes in
     * approximately the correct locations since some of the code makes
     * assumptions about this.
     */
    cp = arg;
    if (*cp == 'D') cp++;
    while (i++ < 5)
    {
	if (!cp || *cp != '/')
	{
	    if (alloc_pending (80))
		sprintf (pending_error_text,
			 "E protocol error: Malformed Entry");
	    return;
	}
	cp = strchr (cp + 1, '/');
    }

    p = xmalloc (sizeof (struct an_entry));
    if (p == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    /* Leave space for serve_unchanged to write '=' if it wants.  */
    cp = xmalloc (strlen (arg) + 2);
    if (cp == NULL)
    {
	pending_error = ENOMEM;
a1682 6
    }
    strcpy (cp, arg);
    p->next = entries;
    p->entry = cp;
    entries = p;
}
d1684 1
a1684 10


static void
serve_kopt (char *arg)
{
    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       )
d1687 106
a1792 1
    if (kopt != NULL)
d1813 1
a1813 1
    kopt = xmalloc (strlen (arg) + 1);
d1822 1
a1822 1

d1825 2
a1826 1
serve_checkin_time (char *arg)
d1828 1
a1828 7
    struct timespec t;

    if (error_pending ()
#ifdef PROXY_SUPPORT
	|| proxy_log
#endif /* PROXY_SUPPORT */
       )
d1840 2
a1841 1
    if (!get_date (&t, arg, NULL))
a1846 3

    /* Truncate any nanoseconds returned by get_date().  */
    checkin_time = t.tv_sec;
a1849 2


d1851 1
a1851 1
server_write_entries (void)
d1865 4
a1868 4
	   existing Entries file.  If we are checking out a module
	   which explicitly lists more than one file in a particular
	   directory, then we will wind up calling
	   server_write_entries for each such file.  */
d1905 1
a1905 359



#ifdef PROXY_SUPPORT
/*
 * callback proc to run a script when admin finishes.
 */
static int
prepost_proxy_proc (const char *repository, const char *filter, void *closure)
{
    char *cmdline;
    bool *pre = closure;

    /* %c = cvs_cmd_name
     * %p = shortrepos
     * %r = repository
     */
    TRACE (TRACE_FUNCTION, "prepost_proxy_proc (%s, %s, %s)", repository,
	   filter, *pre ? "pre" : "post");

    cmdline = format_cmdline (
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	                      0, ".",
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	                      filter,
	                      "c", "s", cvs_cmd_name,
#ifdef SERVER_SUPPORT
	                      "R", "s", referrer ? referrer->original : "NONE",
#endif /* SERVER_SUPPORT */
	                      "p", "s", ".",
	                      "r", "s", current_parsed_root->directory,
	                      "P", "s", config->PrimaryServer->original,
	                      (char *)NULL
	                     );

    if (!cmdline || !strlen (cmdline))
    {
	if (cmdline) free (cmdline);
	if (*pre)
	    error (0, 0, "preadmin proc resolved to the empty string!");
	else
	    error (0, 0, "postadmin proc resolved to the empty string!");
	return 1;
    }

    run_setup (cmdline);

    free (cmdline);

    /* FIXME - read the comment in verifymsg_proc() about why we use abs()
     * below() and shouldn't.
     */
    return abs (run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
			  RUN_NORMAL | RUN_SIGIGNORE));
}



/* Become a secondary write proxy to a master server.
 *
 * This function opens the connection to the primary, dumps the secondary log
 * to the primary, then reads data from any available connection and writes it
 * to its partner:
 *
 *   buf_from_net -> buf_to_primary
 *   buf_from_primary -> buf_to_net
 *
 * When all "from" connections have sent EOF and all data has been sent to
 * "to" connections, this function closes the "to" pipes and returns.
 */
static void
become_proxy (void)
{
    struct buffer *buf_to_primary;
    struct buffer *buf_from_primary;

    /* Close the client log and open it for read.  */
    struct buffer *buf_clientlog = log_buffer_rewind (proxy_log_out);
    int status, to_primary_fd, from_primary_fd, to_net_fd, from_net_fd;

    /* Call presecondary script.  */
    bool pre = true;

	    char *data;
	    size_t thispass, got;
	    int s;
	    char *newdata;

    Parse_Info (CVSROOTADM_PREPROXY, current_parsed_root->directory,
		prepost_proxy_proc, PIOPT_ALL, &pre);

    /* Open connection to primary server.  */
    open_connection_to_server (config->PrimaryServer, &buf_to_primary,
                               &buf_from_primary);
    setup_logfiles ("CVS_SECONDARY_LOG", &buf_to_primary, &buf_from_primary);
    if ((status = set_nonblock (buf_from_primary)))
	error (1, status, "failed to set nonblocking io from primary");
    if ((status = set_nonblock (buf_from_net)))
	error (1, status, "failed to set nonblocking io from client");
    if ((status = set_nonblock (buf_to_primary)))
	error (1, status, "failed to set nonblocking io to primary");
    if ((status = set_nonblock (buf_to_net)))
	error (1, status, "failed to set nonblocking io to client");

    to_primary_fd = buf_get_fd (buf_to_primary);
    from_primary_fd = buf_get_fd (buf_from_primary);
    to_net_fd = buf_get_fd (buf_to_net);
    assert (to_primary_fd >= 0 && from_primary_fd >= 0 && to_net_fd >= 0);

    /* Close the client log and open it for read.  */
    rewind_buf_from_net ();

    while (from_primary_fd >= 0 || to_primary_fd >= 0)
    {
	fd_set readfds, writefds;
	int status, numfds = -1;
	struct timeval *timeout_ptr;
	struct timeval timeout;
	size_t toread;

	FD_ZERO (&readfds);
	FD_ZERO (&writefds);

	/* The fd for a multi-source buffer can change with any read.  */
	from_net_fd = buf_from_net ? buf_get_fd (buf_from_net) : -1;

	if ((buf_from_net && !buf_empty_p (buf_from_net))
	    || (buf_from_primary && !buf_empty_p (buf_from_primary)))
	{
	    /* There is data pending so don't block if we don't find any new
	     * data on the fds.
	     */
	    timeout.tv_sec = 0;
	    timeout.tv_usec = 0;
	    timeout_ptr = &timeout;
	}
	else
	    /* block indefinately */
	    timeout_ptr = NULL;

	/* Set writefds if data is pending.  */
	if (to_net_fd >= 0 && !buf_empty_p (buf_to_net))
	{
	    FD_SET (to_net_fd, &writefds);
	    numfds = MAX (numfds, to_net_fd);
	}
	if (to_primary_fd >= 0 && !buf_empty_p (buf_to_primary))
	{
	    FD_SET (to_primary_fd, &writefds);
	    numfds = MAX (numfds, to_primary_fd);
	}

	/* Set readfds if descriptors are still open.  */
	if (from_net_fd >= 0)
	{
	    FD_SET (from_net_fd, &readfds);
	    numfds = MAX (numfds, from_net_fd);
	}
	if (from_primary_fd >= 0)
	{
	    FD_SET (from_primary_fd, &readfds);
	    numfds = MAX (numfds, from_primary_fd);
	}

	/* NUMFDS needs to be the highest descriptor + 1 according to the
	 * select spec.
	 */
	numfds++;

	do {
	    /* This used to select on exceptions too, but as far
	       as I know there was never any reason to do that and
	       SCO doesn't let you select on exceptions on pipes.  */
	    numfds = select (numfds, &readfds, &writefds,
			     NULL, timeout_ptr);
	    if (numfds < 0 && errno != EINTR)
	    {
		/* Sending an error to the client, possibly in the middle of a
		 * separate protocol message, will likely not mean much to the
		 * client, but it's better than nothing, I guess.
		 */
		buf_output0 (buf_to_net, "E select failed\n");
		print_error (errno);
		exit (EXIT_FAILURE);
	    }
	} while (numfds < 0);

	if (numfds == 0)
	{
	    FD_ZERO (&readfds);
	    FD_ZERO (&writefds);
	}

	if (to_net_fd >= 0 && FD_ISSET (to_net_fd, &writefds))
	{
	    /* What should we do with errors?  syslog() them?  */
	    buf_send_output (buf_to_net);
	    buf_flush (buf_to_net, false);
	}

	status = 0;
	if (from_net_fd >= 0 && (FD_ISSET (from_net_fd, &readfds)))
	    status = buf_input_data (buf_from_net, NULL);

	if (buf_from_net && !buf_empty_p (buf_from_net))
	{
	    if (buf_to_primary)
		buf_append_buffer (buf_to_primary, buf_from_net);
	    else
		/* (Sys?)log this?  */;
		
	}

	if (status == -1 /* EOF */)
	{
	    SIG_beginCrSect();
	    /* Need only to shut this down and set to NULL, really, in
	     * crit sec, to ensure no double-dispose and to make sure
	     * network pipes are closed as properly as possible, but I
	     * don't see much optimization potential in saving values and
	     * postponing the free.
	     */
	    buf_shutdown (buf_from_net);
	    buf_free (buf_from_net);
	    buf_from_net = NULL;
	    /* So buf_to_primary will be closed at the end of this loop.  */
	    from_net_fd = -1;
	    SIG_endCrSect();
	}
	else if (status > 0 /* ERRNO */)
	{
	    buf_output0 (buf_to_net,
			 "E buf_input_data failed reading from client\n");
	    print_error (status);
	    exit (EXIT_FAILURE);
	}

	if (to_primary_fd >= 0 && FD_ISSET (to_primary_fd, &writefds))
	{
	    /* What should we do with errors?  syslog() them?  */
	    buf_send_output (buf_to_primary);
	    buf_flush (buf_to_primary, false);
	}

	status = 0;
	if (from_primary_fd >= 0 && FD_ISSET (from_primary_fd, &readfds))
	    status = buf_input_data (buf_from_primary, &toread);

	/* Avoid resending data from the server which we already sent to the
	 * client.  Otherwise clients get really confused.
	 */
	if (buf_clientlog
	    && buf_from_primary && !buf_empty_p (buf_from_primary))
	{
	    /* Dispose of data we already sent to the client.  */
	    while (buf_clientlog && toread > 0)
	    {
		s = buf_read_data (buf_clientlog, toread, &data, &got);
		if (s == -2)
		    error (1, ENOMEM, "Failed to read data.");
		if (s == -1)
		{
		    buf_shutdown (buf_clientlog);
		    buf_clientlog = NULL;
		}
		else if (s)
		    error (1, s, "Error reading writeproxy log.");
		else
		{
		    thispass = got;
		    while (thispass > 0)
		    {
			/* No need to check for errors here since we know we
			 * won't read more than buf_input read into
			 * BUF_FROM_PRIMARY (see how TOREAD is set above).
			 */
			buf_read_data (buf_from_primary, thispass, &newdata,
				       &got);
			/* Verify that we are throwing away what we think we
			 * are.
			 */
			if (memcmp (data, newdata, got))
			    error (1, 0, "Secondary out of sync with primary!");
			data += got;
			thispass -= got;
		    }
		    toread -= got;
		}
	    }
	}

	if (buf_from_primary && !buf_empty_p (buf_from_primary))
	{
	    if (buf_to_net)
		buf_append_buffer (buf_to_net, buf_from_primary);
	    else
		/* (Sys?)log this?  */;
		
	}

	if (status == -1 /* EOF */)
	{
	    buf_shutdown (buf_from_primary);
	    buf_from_primary = NULL;
	    from_primary_fd = -1;
	}
	else if (status > 0 /* ERRNO */)
	{
	    buf_output0 (buf_to_net,
			 "E buf_input_data failed reading from primary\n");
	    print_error (status);
	    exit (EXIT_FAILURE);
	}

	/* If our "source pipe" is closed and all data has been sent, close
	 * the corresponding "dest pipe".
	 */
	if (from_primary_fd < 0
	    && buf_to_net && buf_empty_p (buf_to_net))
	{
	    to_net_fd = -1;
	    /* Don't actually shut down or free BUF_TO_NET unless BUF_FROM_NET
	     * is already closed.  Let the shutdown handlers do it otherwise
	     * since we might need it later.
	     */
	    if (!buf_from_net)
	    {
		SIG_beginCrSect();
		/* Need only to shut this down and set to NULL, really, in
		 * crit sec, to ensure no double-dispose and to make sure
		 * network pipes are closed as properly as possible, but I
		 * don't see much optimization potential in saving values and
		 * postponing the free.
		 */
		buf_shutdown (buf_to_net);
		buf_free (buf_to_net);
		buf_to_net = NULL;
		SIG_endCrSect();
	    }
	}
	if (from_net_fd < 0
	    && buf_to_primary && buf_empty_p (buf_to_primary))
	{
	    buf_shutdown (buf_to_primary);
	    buf_free (buf_to_primary);
	    buf_to_primary = NULL;
	    to_primary_fd = -1;
	}
    }

    /* Call postsecondary script.  */
    pre = false;
    Parse_Info (CVSROOTADM_POSTPROXY, current_parsed_root->directory,
		prepost_proxy_proc, PIOPT_ALL, &pre);
}
#endif /* PROXY_SUPPORT */



d1907 1
a1907 1
    /* Directory in which this notification happens.  xmalloc'd*/
d1910 1
a1910 4
    /* xmalloc'd.  */
    char *update_dir;

    /* xmalloc'd.  */
d1913 1
a1913 1
    /* The following three all in one xmalloc'd block, pointed to by TYPE.
d1928 2
d1931 2
a1932 1
serve_notify (char *arg)
a1939 22
    if (isProxyServer())
    {
#ifdef PROXY_SUPPORT
	if (!proxy_log)
	{
#endif /* PROXY_SUPPORT */
	    if (alloc_pending (160) + strlen (program_name))
		sprintf (pending_error_text, 
"E This CVS server does not support disconnected `%s edit'.  For now, remove all `%s' files in your workspace and try your command again.",
			 program_name, CVSADM_NOTIFY);
	return;
#ifdef PROXY_SUPPORT
	}
	else
	{
	    /* This is effectively a write command, so run it on the primary.  */
	    become_proxy ();
	    exit (EXIT_SUCCESS);
	}
#endif /* PROXY_SUPPORT */
    }

d1943 1
a1943 1
    if (gDirname == NULL)
d1946 1
a1946 1
    new = xmalloc (sizeof (struct notify_note));
d1952 3
a1954 4
    new->dir = xmalloc (strlen (gDirname) + 1);
    new->update_dir = xmalloc (strlen (gupdate_dir) + 1);
    new->filename = xmalloc (strlen (arg) + 1);
    if (new->dir == NULL || new->update_dir == NULL || new->filename == NULL)
d1962 1
a1962 2
    strcpy (new->dir, gDirname);
    strcpy (new->update_dir, gupdate_dir);
d1965 1
a1965 1
    status = buf_read_line (buf_from_net, &data, NULL);
d1972 1
a1972 1
	    pending_error_text = xmalloc (80 + strlen (arg));
a1995 3
	if (!data[0])
	    goto error;

d2022 1
d2024 1
d2029 1
d2031 1
a2046 1
	free (new->update_dir);
a2052 29


static void
serve_hostname (char *arg)
{
    if (strlen (hostname) >= MAXHOSTNAMELEN)
    {
	pending_error = 0;
	if (alloc_pending (80))
	    strcpy (pending_error_text,
		    "E Protocol error; hostname too long.");
	return;
    }

    strcpy (hostname, arg);
    return;
}



static void
serve_localdir (char *arg)
{
    if (CurDir) free (CurDir);
    CurDir = xstrdup (arg);
}



d2057 1
a2057 1
server_notify (void)
a2061 2
    TRACE (TRACE_FUNCTION, "server_notify()");

d2064 1
a2064 1
	if (CVS_CHDIR (notify_list->dir) < 0)
d2075 2
a2076 3
	notify_do (*notify_list->type, notify_list->filename,
		   notify_list->update_dir, getcaller(), notify_list->val,
		   notify_list->watches, repos);
d2082 1
a2082 1
		buf_append_char (buf_to_net, '.');
d2084 1
a2084 1
		buf_output0 (buf_to_net, dir);
d2115 4
a2119 7


/* This request is processed in all passes since requests which must
 * sometimes be processed before it is known whether we are running as a
 * secondary or not, for instance the `expand-modules' request, sometimes use
 * the `Arguments'.
 */
d2121 2
a2122 1
serve_argument (char *arg)
d2125 1
a2125 1

d2127 1
a2127 9

    if (argument_count >= 10000)
    {
	if (alloc_pending (80))
	    sprintf (pending_error_text, 
		     "E Protocol error: too many arguments");
	return;
    }

d2131 3
a2133 2
	argument_vector = xrealloc (argument_vector,
			            argument_vector_size * sizeof (char *));
d2140 1
a2140 1
    p = xmalloc (strlen (arg) + 1);
a2149 5


/* For secondary servers, this is handled in all passes, as is the `Argument'
 * request, and for the same reasons.
 */
d2151 2
a2152 1
serve_argumentx (char *arg)
d2155 1
a2155 1

a2157 8
    if (argument_count <= 1) 
    {
	if (alloc_pending (80))
	    sprintf (pending_error_text,
"E Protocol error: called argumentx without prior call to argument");
	return;
    }

d2159 1
a2159 1
    p = xrealloc (p, strlen (p) + 1 + strlen (arg) + 1);
a2169 2


d2171 2
a2172 1
serve_global_option (char *arg)
a2173 7
#ifdef PROXY_SUPPORT
    /* This can generate error messages and termination before `Root' requests,
     * so it must be dealt with in the first pass.
     */ 
    if (reprocessing) return;
#endif /* PROXY_SUPPORT */

a2184 3
	case 'l':
	    error(0, 0, "WARNING: global `-l' option ignored.");
	    break;
a2186 1
	    logoff = 1;
d2197 3
d2201 1
a2201 1
	    trace++;
a2207 6


/* This needs to be processed before Root requests, so we allow it to be
 * be processed before knowing whether we are running as a secondary server
 * to allow `noop' and `Root' requests to generate errors as before.
 */
d2209 2
a2210 1
serve_set (char *arg)
a2211 4
#ifdef PROXY_SUPPORT
    if (reprocessing) return;
#endif /* PROXY_SUPPORT */

d2222 2
a2223 1
serve_kerberos_encrypt( char *arg )
a2224 4
#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */

d2240 2
a2241 1
serve_gssapi_encrypt( char *arg )
a2242 4
#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */

d2246 4
a2249 4
	   authentication.  Flush everything we've output so far, and
	   turn on encryption for future data.  On the input side, we
	   should only have unwrapped as far as the Gssapi-encrypt
	   command, so future unwrapping will become encrypted.  */
d2276 2
a2277 1
serve_gssapi_authenticate (char *arg)
a2278 4
#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */

d2282 2
a2283 2
	   That includes authentication, so we don't have to do
	   anything further.  */
d2298 1
a2298 3



a2307 1
#endif /* SERVER_FLOWCONTROL */
d2309 20
d2330 3
d2335 2
a2336 1
serve_questionable (char *arg)
a2339 6
#ifdef PROXY_SUPPORT
    if (proxy_log) return;
#endif /* PROXY_SUPPORT */

    if (error_pending ()) return;

d2348 1
a2348 1
    if (gDirname == NULL)
d2350 1
a2350 3
	if (alloc_pending (80))
	    sprintf (pending_error_text,
"E Protocol error: `Directory' missing");
d2362 1
a2362 1
	update_dir = gDirname + strlen (server_temp_dir) + 1;
d2373 1
d2375 8
a2382 2

static struct buffer *protocol = NULL;
a2387 1

d2390 13
d2404 14
d2419 7
d2428 2
a2429 1
protocol_memory_error (struct buffer *buf)
d2431 1
a2431 1
    error (1, ENOMEM, "Virtual memory exhausted");
d2433 1
d2436 3
a2438 4

/* If command is valid, return 1.
 * Else if command is invalid and croak_on_invalid is set, then die.
 * Else just return 0 to indicate that command is invalid.
d2440 3
a2442 2
static bool
check_command_valid_p (char *cmd_name)
d2444 1
a2444 1
    /* Right now, only pserver notices invalid commands -- namely,
d2451 1
a2451 1
	return true;
d2455 30
a2484 16
	/* This command has the potential to modify the repository, so
	 * we check if the user have permission to do that.
	 *
	 * (Only relevant for remote users -- local users can do
	 * whatever normal Unix file permissions allow them to do.)
	 *
	 * The decision method:
	 *
	 *    If $CVSROOT/CVSADMROOT_READERS exists and user is listed
	 *    in it, then read-only access for user.
	 *
	 *    Or if $CVSROOT/CVSADMROOT_WRITERS exists and user NOT
	 *    listed in it, then also read-only access for user.
	 *
	 *    Else read-write access for user.
	 */
d2486 2
a2487 16
	 char *linebuf = NULL;
	 int num_red = 0;
	 size_t linebuf_len = 0;
	 char *fname;
	 size_t flen;
	 FILE *fp;
	 int found_it = 0;

	 /* else */
	 flen = strlen (current_parsed_root->directory)
		+ strlen (CVSROOTADM)
		+ strlen (CVSROOTADM_READERS)
		+ 3;

	 fname = xmalloc (flen);
	 (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
d2490 1
a2490 1
	 fp = fopen (fname, "r");
d2492 1
a2492 1
	 if (fp == NULL)
d2500 1
a2500 1
		 return false;
d2514 1
a2514 1
                 if (num_red > 0 && linebuf[num_red - 1] == '\n')
d2518 1
a2518 1
                     goto handle_invalid;
d2523 3
a2525 3
	     /* If not listed specifically as a reader, then this user
		has write access by default unless writers are also
		specified in a file . */
d2528 1
a2528 1
	 }
d2533 4
a2536 4
	 flen = strlen (current_parsed_root->directory)
		+ strlen (CVSROOTADM)
		+ strlen (CVSROOTADM_WRITERS)
		+ 3;
d2538 2
a2539 2
	 fname = xmalloc (flen);
	 (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
d2542 1
a2542 1
	 fp = fopen (fname, "r");
d2544 2
a2545 2
	 if (fp == NULL)
	 {
d2547 1
a2547 1
		 free (linebuf);
d2553 1
a2553 1
		 return true;
d2561 1
a2561 1
		 return false;
d2563 1
a2563 1
	 }
d2565 13
a2577 13
	 found_it = 0;
	 while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
	 {
	     /* Chop newline by hand, for strcmp()'s sake. */
	     if (num_red > 0 && linebuf[num_red - 1] == '\n')
		 linebuf[num_red - 1] = '\0';

	     if (strcmp (linebuf, CVS_Username) == 0)
	     {
		 found_it = 1;
		 break;
	     }
	 }
d2581 3
a2583 3
	 if (found_it)
	 {
	     if (fclose (fp) < 0)
d2585 2
a2586 2
	     if (linebuf)
		 free (linebuf);
d2588 1
a2588 1
             return true;
d2592 1
a2592 1
         handle_invalid:
d2595 2
a2596 2
	     if (linebuf)
		 free (linebuf);
d2598 2
a2599 2
	     return false;
	 }
d2603 2
a2604 2
    /* If ever reach end of this function, command must be valid. */
    return true;
d2608 1
a2608 1

a2611 1
#ifdef SUNOS_KLUDGE
a2612 1
#endif
a2617 23


/*
 * Set buffer FD to non-blocking I/O.  Returns 0 for success or errno
 * code.
 */
int
set_nonblock_fd (int fd)
{
#if defined (F_GETFL) && defined (O_NONBLOCK) && defined (F_SETFL)
    int flags;

    flags = fcntl (fd, F_GETFL, 0);
    if (flags < 0)
	return errno;
    if (fcntl (fd, F_SETFL, flags | O_NONBLOCK) < 0)
	return errno;
#endif /* F_GETFL && O_NONBLOCK && F_SETFL */
    return 0;
}



d2619 3
a2621 1
do_cvs_command (char *cmd_name, int (*command) (int, char **))
d2638 1
a2638 1

a2642 45
    TRACE (TRACE_FUNCTION, "do_cvs_command (%s)", cmd_name);

    /* Write proxy logging is always terminated when a command is received.
     * Therefore, we wish to avoid reprocessing the command since that would
     * cause endless recursion.
     */
    if (isProxyServer())
    {
#ifdef PROXY_SUPPORT
	if (reprocessing)
	    /* This must be the second time we've reached this point.
	     * Done reprocessing.
	     */
	    reprocessing = false;
	else
	{
	    if (lookup_command_attribute (cmd_name)
		    & CVS_CMD_MODIFIES_REPOSITORY)
	    {
		become_proxy ();
		exit (EXIT_SUCCESS);
	    }
	    else if (/* serve_co may have called this already and missing logs
		      * should have generated an error in serve_root().
		      */
		     proxy_log)
	    {
		/* Set up the log for reprocessing.  */
		rewind_buf_from_net ();
		/* And return to the main loop in server(), where we will now
		 * find the logged secondary data and reread it.
		 */
		return;
	    }
	}
#else /* !PROXY_SUPPORT */
	if (lookup_command_attribute (cmd_name)
		    & CVS_CMD_MODIFIES_REPOSITORY
	    && alloc_pending (120))
	    sprintf (pending_error_text, 
"E You need a CVS client that supports the `Redirect' response for write requests to this server.");
	return;
#endif /* PROXY_SUPPORT */
    }

d2656 1
a2656 1
    /* Global `cvs_cmd_name' is probably "server" right now -- only
d2658 1
a2658 1
       parameter `cmd_name' to determine if this command is valid for
d2660 1
a2660 1
    if (!check_command_valid_p (cmd_name))
d2666 1
a2666 2
	buf_output0 (buf_to_net,
"\" requires write access to the repository\n\
a2669 1
    cvs_cmd_name = cmd_name;
d2754 1
a2754 1
	protocol = fd_buffer_initialize (protocol_pipe[1], 0, NULL, false,
d2758 4
a2761 12
	   buf_from_net.  Instead, everything should go through
	   protocol.  */
	if (buf_to_net != NULL)
	{
	    buf_free (buf_to_net);
	    buf_to_net = NULL;
	}
	if (buf_from_net != NULL)
	{
	    buf_free (buf_from_net);
	    buf_from_net = NULL;
	}
d2764 2
a2765 2
	   Since we're now in the child, we should use the simpler
	   protocol_memory_error function.  */
a2793 1
	    TRACE (TRACE_DATA, "Sleeping CVS_SERVER_SLEEP (%d) seconds", secs);
a2795 2
	else
	    TRACE (TRACE_DATA, "CVS_SERVER_SLEEP not set.");
d2812 4
a2816 27

	/* Close the pipes explicitly in order to send an EOF to the parent,
	 * then wait for the parent to close the flow control pipe.  This
	 * avoids a race condition where a child which dumped more than the
	 * high water mark into the pipes could complete its job and exit,
	 * leaving the parent process to attempt to write a stop byte to the
	 * closed flow control pipe, which earned the parent a SIGPIPE, which
	 * it normally only expects on the network pipe and that causes it to
	 * exit with an error message, rather than the SIGCHILD that it knows
	 * how to handle correctly.
	 */
	/* Let exit() close STDIN - it's from /dev/null anyhow.  */
	fclose (stderr);
	fclose (stdout);
	close (protocol_pipe[1]);
#ifdef SERVER_FLOWCONTROL
	{
	    char junk;
	    ssize_t status;
	    while ((status = read (flowcontrol_pipe[0], &junk, 1)) > 0
	           || (status == -1 && errno == EAGAIN));
	}
	/* FIXME: No point in printing an error message with error(),
	 * as STDERR is already closed, but perhaps this could be syslogged?
	 */
#endif

d2835 2
a2836 1
	num_to_check = MAX (num_to_check, stderr_pipe[0]);
d2838 2
a2839 1
	num_to_check = MAX (num_to_check, protocol_pipe[0]);
d2841 2
a2842 2
	num_to_check = MAX (num_to_check, STDOUT_FILENO);
#ifdef SUNOS_KLUDGE
a2843 1
#endif
d2857 1
a2857 1
	stdoutbuf = fd_buffer_initialize (stdout_pipe[0], 0, NULL, true,
d2860 1
a2860 1
	stderrbuf = fd_buffer_initialize (stderr_pipe[0], 0, NULL, true,
d2863 1
a2863 1
	protocol_inbuf = fd_buffer_initialize (protocol_pipe[0], 0, NULL, true,
d2921 2
a2924 2
#ifdef SERVER_FLOWCONTROL
	    int bufmemsize;
d2987 2
a2988 2
		   as I know there was never any reason to do that and
		   SCO doesn't let you select on exceptions on pipes.  */
d2990 1
a2990 1
				 NULL, timeout_ptr);
d3016 2
a3017 2
		size_t count_read;

d3088 1
a3088 1
		int status;
d3090 1
a3090 1
		status = buf_input_data (stdoutbuf, NULL);
d3113 1
a3113 1
		int status;
d3115 1
a3115 1
		status = buf_input_data (stderrbuf, NULL);
d3175 1
a3175 1

d3180 2
a3181 2
		int sig = WTERMSIG (status);
		char buf[50];
d3193 2
a3194 2
		/* Test for a core dump.  */
		if (WCOREDUMP (status))
a3215 1
	protocol_inbuf = NULL;
a3217 1
	stderrbuf = NULL;
a3219 1
	stdoutbuf = NULL;
d3274 1
a3274 3



d3281 1
a3281 1
server_pause_check(void)
d3302 1
a3302 1

d3304 2
a3305 1
	    numfds = select (numtocheck, &fds, NULL, NULL, NULL);
d3314 1
a3314 1

d3330 2
a3331 2
	       I/O.  System V nonblocking I/O returns zero if there is
	       nothing to read.  */
d3333 1
a3333 1
		error (1, 0, "flow control EOF");
d3336 1
a3336 1
		error (1, errno, "flow control read failed");
d3342 1
a3342 3



d3346 1
a3346 1

d3349 3
a3351 1
output_dir (const char *update_dir, const char *repository)
a3352 4
    /* Set up SHORT_REPOS.  */
    const char *short_repos = Short_Repository (repository);

    /* Send the update_dir/repos.  */
d3363 1
a3363 4
    if (short_repos[0] == '\0')
	buf_output0 (protocol, ".");
    else
	buf_output0 (protocol, short_repos);
d3366 1
a3366 3



a3384 2


d3386 8
a3393 3
server_register (const char *name, const char *version, const char *timestamp,
                 const char *options, const char *tag, const char *date,
                 const char *conflict)
d3400 9
a3408 4
    TRACE ( 1, "server_register(%s, %s, %s, %s, %s, %s, %s)",
	    name, version, timestamp ? timestamp : "", options,
	    tag ? tag : "", date ? date : "",
	    conflict ? conflict : "" );
d3437 1
a3437 1

a3458 2


d3460 2
a3461 1
server_scratch (const char *fname)
d3492 1
a3492 1
server_scratch_entry_only (void)
d3499 1
a3499 1
new_entries_line (void)
d3513 1
a3513 2


d3516 2
a3517 1
serve_ci (char *arg)
a3521 2


d3523 4
a3526 2
checked_in_response (const char *file, const char *update_dir,
                     const char *repository)
d3558 4
a3561 2
server_checked_in (const char *file, const char *update_dir,
                   const char *repository)
d3586 5
a3590 3
server_update_entries (const char *file, const char *update_dir,
                       const char *repository,
                       enum server_updated_arg4 updated)
d3609 1
a3609 1

d3611 2
a3612 1
serve_update (char *arg)
d3618 2
a3619 1
serve_diff (char *arg)
d3625 2
a3626 1
serve_log (char *arg)
d3632 2
a3633 1
serve_rlog (char *arg)
d3635 2
d3641 2
a3642 13
serve_ls (char *arg)
{
  do_cvs_command ("ls", ls);
}

static void
serve_rls (char *arg)
{
  do_cvs_command ("rls", ls);
}

static void
serve_add (char *arg)
d3648 2
a3649 1
serve_remove (char *arg)
d3655 2
a3656 1
serve_status (char *arg)
d3662 2
a3663 1
serve_rdiff (char *arg)
d3669 2
a3670 1
serve_tag (char *arg)
d3672 1
a3672 1
    do_cvs_command ("tag", cvstag);
d3676 2
a3677 1
serve_rtag (char *arg)
d3679 2
d3685 2
a3686 1
serve_import (char *arg)
d3692 2
a3693 1
serve_admin (char *arg)
d3699 2
a3700 1
serve_history (char *arg)
d3706 2
a3707 1
serve_release (char *arg)
d3712 1
a3712 1

d3715 2
a3716 1
serve_watch_on (char *arg)
d3718 1
a3718 1
    do_cvs_command ("watch", watch_on);
d3721 2
d3724 2
a3725 1
serve_watch_off (char *arg)
d3727 1
a3727 1
    do_cvs_command ("watch", watch_off);
d3730 2
d3733 2
a3734 1
serve_watch_add (char *arg)
d3736 1
a3736 1
    do_cvs_command ("watch", watch_add);
d3739 2
d3742 2
a3743 1
serve_watch_remove (char *arg)
d3745 1
a3745 1
    do_cvs_command ("watch", watch_remove);
d3748 2
d3751 2
a3752 1
serve_watchers (char *arg)
d3757 2
d3760 2
a3761 1
serve_editors (char *arg)
d3766 1
a3766 6
static void
serve_edit (char *arg)
{
    do_cvs_command ("edit", edit);
}

a3767 6

#ifdef PROXY_SUPPORT
/* We need to handle some of this before reprocessing since it is defined to
 * send a response and print errors before a Root request is received.
 */
#endif /* PROXY_SUPPORT */
d3769 2
a3770 1
serve_noop (char *arg)
a3771 4
    /* Errors could be encountered in the first or second passes, so always
     * send them to the client.
     */
    bool pe = print_pending_error();
d3773 4
a3776 17
#ifdef PROXY_SUPPORT
    /* The portions below need not be handled until reprocessing anyhow since
     * there should be no entries or notifications prior to that.  */
    if (!proxy_log)
#endif /* PROXY_SUPPORT */
    {
	server_write_entries ();
	if (!pe)
	    (void) server_notify ();
    }

    if (!pe
#ifdef PROXY_SUPPORT
        /* "ok" only goes across in the first pass.  */
        && !reprocessing
#endif /* PROXY_SUPPORT */
       )
d3778 1
d3782 1
a3782 1

d3785 2
a3786 1
serve_version (char *arg)
d3791 2
d3794 2
a3795 1
serve_init (char *arg)
a3796 2
    cvsroot_t *saved_parsed_root;

d3801 3
a3803 15
		     "E init %s must be an absolute pathname", arg);
    }
#ifdef AUTH_SERVER_SUPPORT
    else if (Pserver_Repos != NULL)
    {
	if (strcmp (Pserver_Repos, arg) != 0)
	{
	    if (alloc_pending (80 + strlen (Pserver_Repos) + strlen (arg)))
		/* The explicitness is to aid people who are writing clients.
		   I don't see how this information could help an
		   attacker.  */
		sprintf (pending_error_text, "\
E Protocol error: init says \"%s\" but pserver says \"%s\"",
			 arg, Pserver_Repos);
	}
a3804 1
#endif
d3806 2
a3807 4
    if (print_pending_error ())
	return;

    saved_parsed_root = current_parsed_root;
a3810 2
    free_cvsroot_t (current_parsed_root);
    current_parsed_root = saved_parsed_root;
d3813 2
d3816 2
a3817 1
serve_annotate (char *arg)
d3822 2
d3825 2
a3826 1
serve_rannotate (char *arg)
d3828 2
d3832 1
a3832 1

d3834 2
a3835 1
serve_co (char *arg)
a3842 23
#ifdef PROXY_SUPPORT
    /* If we are not a secondary server, the write proxy log will already have
     * been processed.
     */
    if (isProxyServer ())
    {
	if (reprocessing)
	    reprocessing = false;
	else if (/* The proxy log may be closed if the client sent a
		  * `Command-prep' request.
		  */
		 proxy_log)
	{
	    /* Set up the log for reprocessing.  */
	    rewind_buf_from_net ();
	    /* And return to the main loop in server(), where we will now find
	     * the logged secondary data and reread it.
	     */
	    return;
	}
    }
#endif /* PROXY_SUPPORT */

d3849 1
a3849 1
	tempdir = xmalloc (strlen (server_temp_dir) + 80);
d3868 1
a3868 1
	if (CVS_CHDIR (tempdir) < 0)
d3880 1
a3880 1
    /* Compensate for server_export()'s setting of cvs_cmd_name.
d3885 3
a3887 3
    do_cvs_command ((strcmp (cvs_cmd_name, "export") == 0) ?
		    "export" : "checkout",
		    checkout);
d3891 2
a3892 1
serve_export (char *arg)
d3895 1
a3895 1
    cvs_cmd_name = "export";
d3898 1
a3898 3



d3900 5
a3904 2
server_copy_file (const char *file, const char *update_dir,
                  const char *repository, const char *newfile)
d3925 3
a3927 1
server_modtime (struct file_info *finfo, Vers_TS *vers_ts)
d3948 1
d3950 2
a3951 2

/* See server.h for description.  */
d3960 10
a3981 1
	buf_send_counted (protocol);
d4044 1
a4044 1
		int i;
d4047 1
a4047 1
		buf_output0 (protocol, "Checksum ");
d4078 1
a4078 1
	    entnode = node->data;
d4096 1
a4096 1
	{
d4136 3
a4138 3
		   file_gzip_level is set.  We could handle this case,
		   but it's not worth it since this case never arises
		   with a current client and server.  */
d4186 1
d4188 2
d4264 1
a4264 1
server_use_rcs_diff (void)
a4268 2


d4270 3
a4272 1
server_set_entstat (const char *update_dir, const char *repository)
a4284 2


d4286 3
a4288 1
server_clear_entstat (const char *update_dir, const char *repository)
d4303 1
a4303 3



d4305 6
a4310 2
server_set_sticky (const char *update_dir, const char *repository,
                   const char *tag, const char *date, int nonbranch)
d4351 1
a4351 15



void
server_edit_file (struct file_info *finfo)
{
    buf_output (protocol, "Edit-file ", 10);
    output_dir (finfo->update_dir, finfo->repository);
    buf_output0 (protocol, finfo->file);
    buf_output (protocol, "\n", 1);
    buf_send_counted (protocol);
}



d4354 2
a4355 2
    const char *update_dir;
    const char *repository;
d4358 4
d4363 3
a4365 1
template_proc (const char *repository, const char *template, void *closure)
d4371 1
a4371 1
    struct template_proc_data *data = (struct template_proc_data *)closure;
a4403 1
    buf_send_counted (protocol);
a4408 2


d4410 3
a4412 33
server_clear_template (const char *update_dir, const char *repository)
{
    assert (update_dir != NULL);

    if (noexec)
	return;

    if (!supported_response ("Clear-template") &&
	!supported_response ("Template"))
	/* Might want to warn the user that the rcsinfo feature won't work.  */
	return;

    if (supported_response ("Clear-template"))
    {
	buf_output0 (protocol, "Clear-template ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, "\n");
	buf_send_counted (protocol);
    }
    else
    {
	buf_output0 (protocol, "Template ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, "\n");
	buf_output0 (protocol, "0\n");
	buf_send_counted (protocol);
    }
}



void
server_template (const char *update_dir, const char *repository)
d4417 2
a4418 2
    (void) Parse_Info (CVSROOTADM_RCSINFO, repository, template_proc,
		       PIOPT_ALL, &data);
d4420 1
a4420 3



d4422 2
a4423 1
serve_gzip_contents (char *arg)
a4425 5

#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */

a4431 2


d4433 2
a4434 1
serve_gzip_stream (char *arg)
a4436 7

    /* If we received this request before the `Root' request, the buffer index
     * maintained to allow the write proxy to replace the `Root' request would
     * be relative to the decompressed stream rather than the secondary log.
     */
    assert (current_parsed_root);

d4443 2
a4444 3
    /* This needs to be processed in both passes so that we may continue to
     * understand client requests on both the socket and from the log.
     */
a4446 9

    /* This needs to be skipped in subsequent passes to avoid compressing data
     * to the client twice.
     */
#ifdef PROXY_SUPPORT
    if (reprocessing) return;
#endif /* PROXY_SUPPORT */
    buf_to_net = compress_buffer_initialize (buf_to_net, 0, level,
					     buf_to_net->memory_error);
d4448 1
a4448 3



d4451 2
a4452 1
serve_wrapper_sendme_rcs_options (char *arg)
a4461 4
#ifdef PROXY_SUPPORT
    if (reprocessing) return;
#endif /* PROXY_SUPPORT */

d4465 2
a4466 2
	 wrapper_line;
	 wrap_unparse_rcs_options (&wrapper_line, 0))
d4480 1
a4480 2


d4482 2
a4483 1
serve_ignore (char *arg)
a4489 3
#ifdef PROXY_SUPPORT
    assert (!proxy_log);
#endif /* PROXY_SUPPORT */
d4491 1
a4491 3



d4493 11
a4503 1
expand_proc (int argc, char **argv, char *where, char *mwhere, char *mfile, int shorten, int local_specified, char *omodule, char *msg)
d4533 1
a4533 1
	   of aliases before removing */
d4549 1
a4549 1
		buf_output0 (buf_to_net, "Module-expansion ");
d4566 2
a4567 1
serve_expand_modules (char *arg)
d4570 1
a4570 1
    int err = 0;
d4572 1
d4574 9
a4582 20
#ifdef PROXY_SUPPORT
    /* This needs to be processed in the first pass since the client expects a
     * response but we may not yet know if we are a secondary.
     *
     * On the second pass, we still must make sure to ignore the arguments.
     */
    if (!reprocessing)
#endif /* PROXY_SUPPORT */
    {
	err = 0;

	db = open_module ();
	for (i = 1; i < argument_count; i++)
	    err += do_module (db, argument_vector[i],
			      CHECKOUT, "Updating", expand_proc,
			      NULL, 0, 0, 0, 0,
			      (char *) NULL);
	close_module (db);
    }

d4593 10
d4604 13
a4616 3
#ifdef PROXY_SUPPORT
    if (!reprocessing)
#endif /* PROXY_SUPPORT */
d4618 6
a4623 9
	if (err)
	    /* We will have printed an error message already.  */
	    buf_output0 (buf_to_net, "error  \n");
	else
	    buf_output0 (buf_to_net, "ok\n");

	/* The client is waiting for the module expansions, so we must
	   send the output now.  */
	buf_flush (buf_to_net, 1);
d4625 4
a4630 14


/* Decide if we should redirect the client to another server.
 *
 * GLOBALS
 *   config->PrimaryServer	The server to redirect write requests to, if
 *				any.
 *
 * ASSUMPTIONS
 *   The `Root' request has already been processed.
 *
 * RETURNS
 *   Nothing.
 */
d4632 2
a4633 1
serve_command_prep (char *arg)
d4635 1
a4635 1
    bool supported;
d4637 9
a4645 1
    if (error_pending ()) return;
d4647 2
a4648 7
    supported = supported_response ("Redirect");
    if (config->PrimaryServer && supported
	&& lookup_command_attribute (arg) & CVS_CMD_MODIFIES_REPOSITORY
	/* I call isProxyServer() last because it is probably the slowest
	 * call due to the call to gethostname().
	 */
	&& isProxyServer ())
d4650 5
a4654 5
	/* Send `Redirect' to redirect client requests to the primary.  */
	buf_output0 (buf_to_net, "Redirect ");
	buf_output0 (buf_to_net, config->PrimaryServer->original);
	buf_output0 (buf_to_net, "\n");
	buf_flush (buf_to_net, 1);
d4656 1
a4656 1
    else
d4658 6
a4663 3
	/* Send `ok' so the client can proceed.  */
	buf_output0 (buf_to_net, "ok\n");
	buf_flush (buf_to_net, 1);
d4665 1
a4665 2
#ifdef PROXY_SUPPORT
    if (proxy_log && supported)
d4667 5
a4671 14
	/* If the client supported the redirect response, then they will always
	 * be redirected if they are preparing for a write request.  It is
	 * therefore safe to close the proxy logs.
	 *
	 * If the client is broken and ignores the redirect, this will be
	 * detected later, in rewind_buf_from_net().
	 *
	 * Since a `Command-prep' response is only acceptable immediately
	 * following the `Root' request according to the specification, there
	 * is no need to rewind the log and reprocess.
	 */
	log_buffer_closelog (proxy_log);
	log_buffer_closelog (proxy_log_out);
	proxy_log = NULL;
a4672 1
#endif /* PROXY_SUPPORT */
a4674 14


/* Save a referrer, potentially for passing to hook scripts later.
 *
 * GLOBALS
 *   referrer	Where we save the parsed referrer.
 *
 * ASSUMPTIONS
 *   The `Root' request has already been processed.
 *   If referrer is set it may be disposed.
 *
 * RETURNS
 *   Nothing.
 */
d4676 2
a4677 1
serve_referrer (char *arg)
d4679 1
a4679 1
    if (error_pending ()) return;
d4681 21
a4701 3
    if (referrer)
	free_cvsroot_t (referrer);
    referrer = parse_cvsroot (arg);
d4703 25
a4727 8
    if (!referrer
	&& alloc_pending (80 + strlen (arg)))
	/* The explicitness is to aid people who are writing clients.
	   I don't see how this information could help an
	   attacker.  */
	sprintf (pending_error_text, "\
E Protocol error: Invalid Referrer: `%s'",
		 arg);
d4729 2
a4730 4



static void serve_valid_requests (char *arg);
a4732 4
/*
 * Comment to move position of the following #if line which works
 * around an apparent bug in Microsoft Visual C++ 6.0 compiler.
 */
d4734 1
a4753 2
  REQ_LINE("Command-prep", serve_command_prep, 0),
  REQ_LINE("Referrer", serve_referrer, 0),
a4755 1
  REQ_LINE("Relative-directory", serve_directory, 0),
d4759 2
a4773 2
  REQ_LINE("Hostname", serve_hostname, 0),
  REQ_LINE("LocalDir", serve_localdir, 0),
d4775 1
d4781 2
a4782 2
	   serve_wrapper_sendme_rcs_options,
	   0),
a4801 8
  REQ_LINE("list", serve_ls, 0),
  REQ_LINE("rlist", serve_rls, 0),
  /* This allows us to avoid sending `-q' as a command argument to `cvs ls',
   * or more accurately, allows us to send `-q' to backwards CVSNT servers.
   */
  REQ_LINE("global-list-quiet", serve_noop, RQ_ROOTLESS),
  /* Deprecated synonym for rlist, for compatibility with CVSNT. */
  REQ_LINE("ls", serve_rls, 0),
a4820 1
  REQ_LINE("edit", serve_edit, 0),
d4830 1
d4832 1
a4833 6


#ifdef SERVER_SUPPORT
/*
 * This server request is not ignored by the secondary.
 */
d4835 2
a4836 1
serve_valid_requests (char *arg)
d4839 1
a4839 12

    /* Since this is processed in the first pass, don't reprocess it in the
     * second.
     *
     * We still print errors since new errors could have been generated in the
     * second pass.
     */
    if (print_pending_error ()
#ifdef PROXY_SUPPORT
	|| reprocessing
#endif /* PROXY_SUPPORT */
       )
a4840 1

a4856 2


d4863 2
a4864 1
static void wait_sig (int sig)
d4867 2
d4872 1
a4875 52


/*
 * This function cleans up after the server.  Specifically, it:
 *
 * <ol>
 * <li>Sets BUF_TO_NET to blocking and fluxhes it.</li>
 * <li>With SUNOS_KLUDGE enabled:
 *   <ol>
 *   <li>Terminates the command process.</li>
 *   <li>Waits on the command process, draining output as necessary.</li>
 *   </ol>
 * </li>
 * <li>Removes the temporary directory.</li>
 * <li>Flush and shutdown the buffers.</li>
 * <li>Set ERROR_USE_PROTOCOL and SERVER_ACTIVE to false.</li>
 * </ol>
 *
 * NOTES
 *   This function needs to be reentrant since a call to exit() can cause a
 *   call to this function, which can then be interrupted by a signal, which
 *   can cause a second call to this function.
 *
 * GLOBALS
 *   buf_from_net		The input buffer which brings data from the
 *   				CVS client.
 *   buf_to_net			The output buffer which moves data to the CVS
 *   				client.
 *   error_use_protocol		Set when the server parent process is active.
 *   				Cleared for the server child processes.
 *   dont_delete_temp		Set when a core dump of a child process is
 *   				detected so that the core and related data may
 *   				be preserved.
 *   Tmpdir			The system TMP directory for all temp files.
 *   noexec			Whether we are supposed to change the disk.
 *   orig_server_temp_dir	The temporary directory we created within
 *   				Tmpdir for our duplicate of the client
 *   				workspace.
 *
 * INPUTS
 *   None.
 *
 * ERRORS
 *   Problems encountered during the cleanup, for instance low memory or
 *   problems deleting the temp files and directories, can cause the error
 *   function to be called, which might call exit.  If exit gets called in this
 *   manner. this routine will not complete, but the other exit handlers
 *   registered via atexit() will still run.
 *
 * RETURNS
 *   Nothing.
 */
d4877 2
a4878 1
server_cleanup (void)
d4880 3
a4882 1
    TRACE (TRACE_FUNCTION, "server_cleanup()");
d4884 9
a4892 1
    assert (server_active);
d4894 5
a4898 6
    /* FIXME: Do not perform buffered I/O from an interrupt handler like
     * this (via error).  However, I'm leaving the error-calling code there
     * in the hope that on the rare occasion the error call is actually made
     * (e.g., a fluky I/O error or permissions problem prevents the deletion
     * of a just-created file) reentrancy won't be an issue.
     */
d4900 7
a4906 4
    /* We don't want to be interrupted during calls which set globals to NULL,
     * but we know that by the time we reach this function, interrupts have
     * already been blocked.
     */
d4908 1
a4908 7
    /* Since we install this function in an atexit() handler before forking,
     * reuse the ERROR_USE_PROTOCOL flag, which we know is only set in the
     * parent server process, to avoid cleaning up the temp space multiple
     * times.  Skip the buf_to_net checks too as an optimization since we know
     * they will be set to NULL in the child process anyhow.
     */
    if (error_use_protocol)
d4911 3
a4913 2
	{
	    int status;
d4915 12
a4926 4
	    /* Since we're done, go ahead and put BUF_TO_NET back into blocking
	     * mode and send any pending output.  In the usual case there won't
	     * won't be any, but there might be if an error occured.
	     */
d4928 17
a4944 10
	    set_block (buf_to_net);
	    buf_flush (buf_to_net, 1);

	    /* Next we shut down BUF_FROM_NET.  That will pick up the checksum
	     * generated when the client shuts down its buffer.  Then, after we
	     * have generated any final output, we shut down BUF_TO_NET.
	     */

	    /* SIG_beginCrSect(); */
	    if (buf_from_net)
d4946 5
a4950 5
		status = buf_shutdown (buf_from_net);
		if (status != 0)
		    error (0, status, "shutting down buffer from client");
		buf_free (buf_from_net);
		buf_from_net = NULL;
d4952 4
a4955 4
	    /* SIG_endCrSect(); */
	}

	if (!dont_delete_temp)
d4957 4
a4960 1
	    int save_noexec;
d4962 16
a4977 32
	    /* What a bogus kludge.  This disgusting code makes all kinds of
	       assumptions about SunOS, and is only for a bug in that system.
	       So only enable it on Suns.  */
#ifdef SUNOS_KLUDGE
	    if (command_pid > 0)
	    {
		/* To avoid crashes on SunOS due to bugs in SunOS tmpfs
		 * triggered by the use of rename() in RCS, wait for the
		 * subprocess to die.  Unfortunately, this means draining
		 * output while waiting for it to unblock the signal we sent
		 * it.  Yuck!
		 */
		int status;
		pid_t r;

		signal (SIGCHLD, wait_sig);
		/* Perhaps SIGTERM would be more correct.  But the child
		   process will delay the SIGINT delivery until its own
		   children have exited.  */
		kill (command_pid, SIGINT);
		/* The caller may also have sent a signal to command_pid, so
		 * always try waiting.  First, though, check and see if it's
		 * still there....
		 */
	    do_waitpid:
		r = waitpid (command_pid, &status, WNOHANG);
		if (r == 0)
		    ;
		else if (r == command_pid)
		    command_pid_is_dead++;
		else if (r == -1)
		    switch (errno)
d4979 5
a4983 5
			case ECHILD:
			    command_pid_is_dead++;
			    break;
			case EINTR:
			    goto do_waitpid;
d4985 2
a4986 2
		else
		    /* waitpid should always return one of the above values */
a4987 34
		while (!command_pid_is_dead)
		{
		    struct timeval timeout;
		    struct fd_set_wrapper readfds;
		    char buf[100];
		    int i;

		    /* Use a non-zero timeout to avoid eating up CPU cycles.  */
		    timeout.tv_sec = 2;
		    timeout.tv_usec = 0;
		    readfds = command_fds_to_drain;
		    switch (select (max_command_fd + 1, &readfds.fds,
				    NULL, NULL &timeout))
		    {
			case -1:
			    if (errno != EINTR)
				abort ();
			case 0:
			    /* timeout */
			    break;
			case 1:
			    for (i = 0; i <= max_command_fd; i++)
			    {
				if (!FD_ISSET (i, &readfds.fds))
				    continue;
				/* this fd is non-blocking */
				while (read (i, buf, sizeof (buf)) >= 1)
				    ;
			    }
			    break;
			default:
			    abort ();
		    }
		}
d4989 2
d4993 14
a5006 34
	    /* Make sure our working directory isn't inside the tree we're
	       going to delete.  */
	    CVS_CHDIR (Tmpdir);

	    /* Temporarily clear noexec, so that we clean up our temp directory
	       regardless of it (this could more cleanly be handled by moving
	       the noexec check to all the unlink_file_dir callers from
	       unlink_file_dir itself).  */
	    save_noexec = noexec;

	    /* SIG_beginCrSect(); */
	    noexec = 0;
	    unlink_file_dir (orig_server_temp_dir);
	    noexec = save_noexec;
	    /* SIG_endCrSect(); */
	} /* !dont_delete_temp */

	/* SIG_beginCrSect(); */
	if (buf_to_net != NULL)
	{
	    /* Save BUF_TO_NET and set the global pointer to NULL so that any
	     * error messages generated during shutdown go to the syslog rather
	     * than getting lost.
	     */
	    struct buffer *buf_to_net_save = buf_to_net;
	    buf_to_net = NULL;

	    (void) buf_flush (buf_to_net_save, 1);
	    (void) buf_shutdown (buf_to_net_save);
	    buf_free (buf_to_net_save);
	    error_use_protocol = 0;
	}
	/* SIG_endCrSect(); */
    }
d5008 2
a5009 1
    server_active = 0;
a5011 8


#ifdef PROXY_SUPPORT
size_t MaxProxyBufferSize = (size_t)(8 * 1024 * 1024); /* 8 megabytes,
                                                        * by default.
                                                        */
#endif /* PROXY_SUPPORT */

d5013 1
d5016 3
a5018 1
server (int argc, char **argv)
a5019 2
    char *error_prog_name;		/* Used in error messages */

d5032 3
a5034 56
    /*
     * Set this in .bashrc if you want to give yourself time to attach
     * to the subprocess with a debugger.
     */
    if (getenv ("CVS_PARENT_SERVER_SLEEP"))
    {
	int secs = atoi (getenv ("CVS_PARENT_SERVER_SLEEP"));
	TRACE (TRACE_DATA, "Sleeping CVS_PARENT_SERVER_SLEEP (%d) seconds",
	       secs);
	sleep (secs);
    }
    else
	TRACE (TRACE_DATA, "CVS_PARENT_SERVER_SLEEP not set.");

    /* pserver_authenticate_connection () (called from main ()) can initialize
     * these.
     */
    if (!buf_to_net)
    {
	buf_to_net = fd_buffer_initialize (STDOUT_FILENO, 0, NULL, false,
					   outbuf_memory_error);
	buf_from_net = fd_buffer_initialize (STDIN_FILENO, 0, NULL, true,
					     outbuf_memory_error);
    }

    setup_logfiles ("CVS_SERVER_LOG", &buf_to_net, &buf_from_net);

#ifdef PROXY_SUPPORT
    /* We have to set up the recording for all servers.  Until we receive the
     * `Root' request and load CVSROOT/config, we can't tell if we are a
     * secondary or primary.
     */
    {
	/* Open the secondary log.  */
	buf_from_net = log_buffer_initialize (buf_from_net, NULL,
# ifdef PROXY_SUPPORT
					      true,
					      config
						? config->MaxProxyBufferSize
						: MaxProxyBufferSize,
# endif /* PROXY_SUPPORT */
					      true, outbuf_memory_error);
	proxy_log = buf_from_net;

	/* And again for the out log.  */
	buf_to_net = log_buffer_initialize (buf_to_net, NULL,
# ifdef PROXY_SUPPORT
					    true,
					    config
					      ? config->MaxProxyBufferSize
					      : MaxProxyBufferSize,
# endif /* PROXY_SUPPORT */
					    false, outbuf_memory_error);
	proxy_log_out = buf_to_net;
    }
#endif /* PROXY_SUPPORT */
d5066 1
a5066 1
	    server_temp_dir = xmalloc (strlen (Tmpdir) + 80);
d5076 11
d5109 2
a5110 2
	       700, to discourage random people from tampering with
	       it.  */
d5113 1
a5113 1
		static const char suffix[] = "abcdefghijklmnopqrstuvwxyz";
d5115 1
a5115 1
		if (i >= sizeof suffix - 1) break;
d5151 19
d5174 24
a5197 1
    argument_vector = xmalloc (argument_vector_size * sizeof (char *));
d5201 1
d5207 1
a5207 3
    error_prog_name = xmalloc (strlen (program_name) + 8);
    sprintf(error_prog_name, "%s server", program_name);
    argument_vector[0] = error_prog_name;
d5214 2
a5215 2

	status = buf_read_line (buf_from_net, &cmd, NULL);
d5272 1
a5272 1
		buf_output0 (buf_to_net, "error  unrecognized request `");
d5280 1
a5280 46

    free (error_prog_name);

    /* We expect the client is done talking to us at this point.  If there is
     * any data in the buffer or on the network pipe, then something we didn't
     * prepare for is happening.
     */
    if (!buf_empty (buf_from_net))
    {
	/* Try to send the error message to the client, but also syslog it, in
	 * case the client isn't listening anymore.
	 */
#ifdef HAVE_SYSLOG_H
	/* FIXME: Can the IP address of the connecting client be retrieved
	 * and printed here?
	 */
	syslog (LOG_DAEMON | LOG_ERR, "Dying gasps received from client.");
#endif
	error (0, 0, "Dying gasps received from client.");
    }

#ifdef HAVE_PAM
    {
        int retval;

        retval = pam_close_session(pamh, 0);
#ifdef HAVE_SYSLOG_H
        if (retval != PAM_SUCCESS)
            syslog (LOG_DAEMON | LOG_ERR, 
                    "PAM close session error: %s",
                    pam_strerror(pamh, retval));
#endif

        retval = pam_end (pamh, retval);
#ifdef HAVE_SYSLOG_H
        if (retval != PAM_SUCCESS)
            syslog (LOG_DAEMON | LOG_ERR, 
                    "PAM failed to release authenticator, error: %s",
                    pam_strerror(pamh, retval));
#endif
    }
#endif

    /* server_cleanup() will be called on a normal exit and close the buffers
     * explicitly.
     */
d5284 3
a5287 2

#if defined (HAVE_KERBEROS) || defined (AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)
d5289 2
a5290 1
switch_to_user (const char *cvs_username, const char *username)
a5292 16
#ifdef HAVE_PAM
    int retval;
    char *pam_stage = "open session";

    retval = pam_open_session(pamh, 0);
    if (retval == PAM_SUCCESS) {
        pam_stage = "get pam user";
        retval = pam_get_item(pamh, PAM_USER, (const void **)&username);
    }

    if (retval != PAM_SUCCESS) {
        printf("E PAM %s error: %s\n", pam_stage,
                pam_strerror(pamh, retval));
        exit (EXIT_FAILURE);
    }
#endif
d5297 2
a5298 2
	/* check_password contains a similar check, so this usually won't be
	   reached unless the CVS user is mapped to an invalid system user.  */
d5301 3
a5303 16
error 0 %s: no such system user\n", username);
	exit (EXIT_FAILURE);
    }

    if (pw->pw_uid == 0)
    {
#ifdef HAVE_SYSLOG_H
	    /* FIXME: Can the IP address of the connecting client be retrieved
	     * and printed here?
	     */
	    syslog (LOG_DAEMON | LOG_ALERT,
		    "attempt to root from account: %s", cvs_username
		   );
#endif
        printf("error 0: root not allowed\n");
	exit (EXIT_FAILURE);
d5321 2
a5322 1
	exit (EXIT_FAILURE);
a5325 9
#ifdef HAVE_PAM
    retval = pam_setcred(pamh, PAM_ESTABLISH_CRED);
    if (retval != PAM_SUCCESS) {
        printf("E PAM reestablish credentials error: %s\n", 
                pam_strerror(pamh, retval));
        exit (EXIT_FAILURE);
    }
#endif

d5334 3
a5336 1
	    exit (EXIT_FAILURE);
d5346 3
a5348 6
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR,
		    "setgid to %d failed (%m): real %d/%d, effective %d/%d ",
		    pw->pw_gid, getuid(), getgid(), geteuid(), getegid());
#endif
	    exit (EXIT_FAILURE);
d5351 1
a5351 1

d5361 2
a5362 6
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR,
		    "setuid to %d failed (%m): real %d/%d, effective %d/%d ",
		    pw->pw_uid, getuid(), getgid(), geteuid(), getegid());
#endif
	exit (EXIT_FAILURE);
d5375 1
a5375 1

d5381 3
d5394 4
a5397 3
	env = xmalloc (sizeof "CVS_USER=" + strlen (CVS_Username));
	(void) sprintf (env, "CVS_USER=%s", CVS_Username);
	(void) putenv (env);
d5406 1
a5406 1
extern char *crypt (const char *, const char *);
d5409 1
a5409 1
/*
d5422 2
a5423 1
check_repository_password (char *username, char *password, char *repository, char **host_user_ptr)
d5433 2
a5434 2
    /* We don't use current_parsed_root->directory because it hasn't been
     * set yet -- our `repository' argument came from the authentication
d5446 1
a5446 1
		    CVSROOTADM, CVSROOTADM_PASSWD);
d5462 1
a5462 1
	{
d5465 1
a5465 1
	}
d5476 1
a5476 1
	char *non_cvsuser_portion;
d5478 18
a5495 18
	/* We need to make sure lines such as
	 *
	 *    "username::sysuser\n"
	 *    "username:\n"
	 *    "username:  \n"
	 *
	 * all result in a found_password of NULL, but we also need to
	 * make sure that
	 *
	 *    "username:   :sysuser\n"
	 *    "username: <whatever>:sysuser\n"
	 *
	 * continues to result in an impossible password.  That way,
	 * an admin would be on safe ground by going in and tacking a
	 * space onto the front of a password to disable the account
	 * (a technique some people use to close accounts
	 * temporarily).
	 */
d5497 2
a5498 2
	/* Make `non_cvsuser_portion' contain everything after the CVS
	   username, but null out any final newline. */
d5500 1
a5500 187
	strtok (non_cvsuser_portion, "\n");

	/* If there's a colon now, we just want to inch past it. */
	if (strchr (non_cvsuser_portion, ':') == non_cvsuser_portion)
	    non_cvsuser_portion++;

	/* Okay, after this conditional chain, found_password and
	   host_user_tmp will have useful values: */

	if ((non_cvsuser_portion == NULL)
	    || (strlen (non_cvsuser_portion) == 0)
	    || ((strspn (non_cvsuser_portion, " \t"))
		== strlen (non_cvsuser_portion)))
	{
	    found_password = NULL;
	    host_user_tmp = NULL;
	}
	else if (strncmp (non_cvsuser_portion, ":", 1) == 0)
	{
	    found_password = NULL;
	    host_user_tmp = non_cvsuser_portion + 1;
	    if (strlen (host_user_tmp) == 0)
		host_user_tmp = NULL;
	}
	else
	{
	    found_password = strtok (non_cvsuser_portion, ":");
	    host_user_tmp = strtok (NULL, ":");
	}

	/* Of course, maybe there was no system user portion... */
	if (host_user_tmp == NULL)
	    host_user_tmp = username;

	/* Verify blank passwords directly, otherwise use crypt(). */
	if ((found_password == NULL)
	    || ((strcmp (found_password, crypt (password, found_password))
		 == 0)))
	{
	    /* Give host_user_ptr permanent storage. */
	    *host_user_ptr = xstrdup (host_user_tmp);
	    retval = 1;
	}
	else
	{
#ifdef LOG_AUTHPRIV
	syslog (LOG_AUTHPRIV | LOG_NOTICE,
		"password mismatch for %s in %s: %s vs. %s", username,
		repository, crypt(password, found_password), found_password);
#endif
	    *host_user_ptr = NULL;
	    retval	 = 2;
	}
    }
    else     /* Didn't find this user, so deny access. */
    {
	*host_user_ptr = NULL;
	retval = 0;
    }

    free (filename);
    if (linebuf)
	free (linebuf);

    return retval;
}

#ifdef HAVE_PAM

struct cvs_pam_userinfo {
    char *username;
    char *password;
};

static int
cvs_pam_conv (int num_msg, const struct pam_message **msg,
              struct pam_response **resp, void *appdata_ptr)
{
    int i;
    struct pam_response *response;
    struct cvs_pam_userinfo *ui = (struct cvs_pam_userinfo *)appdata_ptr;

    assert (msg && resp);

    response = xmalloc(num_msg * sizeof (struct pam_response));
    memset(response, 0, num_msg * sizeof (struct pam_response));

    for (i = 0; i < num_msg; i++)
    {
	switch (msg[i]->msg_style) 
	{
	    /* PAM wants a username */
	    case PAM_PROMPT_ECHO_ON:
                assert (ui && ui->username);
		response[i].resp = xstrdup (ui->username);
		break;
	    /* PAM wants a password */
	    case PAM_PROMPT_ECHO_OFF:
                assert (ui && ui->password);
		response[i].resp = xstrdup (ui->password);
		break;
	    case PAM_ERROR_MSG:
	    case PAM_TEXT_INFO:
		printf ("E %s\n", msg[i]->msg);
		break;
	    /* PAM wants something we don't understand - bail out */
	    default:
		goto cleanup;
	}
    }

    *resp = response;
    return PAM_SUCCESS;

cleanup:
    for (i = 0; i < num_msg; i++)
    {
	if (response[i].resp)
	{
	    free (response[i].resp);
	    response[i].resp = 0;
	}
    }
    free (response);
    return PAM_CONV_ERR;
}

static int
check_pam_password (char **username, char *password)
{
    int retval, err;
    struct cvs_pam_userinfo ui = { *username, password };
    struct pam_conv conv = { cvs_pam_conv, (void *)&ui };
    char *pam_stage = "start";

    retval = pam_start (PAM_SERVICE_NAME, *username, &conv, &pamh);

    /* sets a dummy tty name which pam modules can check for */
    if (retval == PAM_SUCCESS) {
        pam_stage = "set dummy tty";
        retval = pam_set_item(pamh, PAM_TTY, PAM_SERVICE_NAME);
    }

    if (retval == PAM_SUCCESS) {
	pam_stage = "authenticate";
	retval = pam_authenticate(pamh, 0);
    }

    if (retval == PAM_SUCCESS) {
	pam_stage = "account";
	retval = pam_acct_mgmt (pamh, 0);
    }

    if (retval == PAM_SUCCESS) {
        pam_stage = "get pam user";
        retval = pam_get_item(pamh, PAM_USER, (const void **)username);
    }

    if (retval != PAM_SUCCESS)
	printf ("E PAM %s error: %s\n", pam_stage, pam_strerror(pamh, retval));

    return retval == PAM_SUCCESS;       /* indicate success */
}
#endif

static int
check_system_password (char *username, char *password)
{
    char *found_passwd = NULL;
    struct passwd *pw;
#ifdef HAVE_GETSPNAM
    {
	struct spwd *spw;

	spw = getspnam (username);
	if (spw != NULL)
	    found_passwd = spw->sp_pwdp;
    }
#endif

    if (found_passwd == NULL && (pw = getpwnam (username)) != NULL)
	found_passwd = pw->pw_passwd;

    if (found_passwd == NULL)
    {
	printf ("E Fatal error, aborting.\n\
error 0 %s: no such user\n", username);
d5502 27
a5528 2
	exit (EXIT_FAILURE);
    }
d5530 3
a5532 14
    /* Allow for dain bramaged HPUX passwd aging
     *  - Basically, HPUX adds a comma and some data
     *    about whether the passwd has expired or not
     *    on the end of the passwd field.
     *  - This code replaces the ',' with '\0'.
     *
     * FIXME - our workaround is brain damaged too.  I'm
     * guessing that HPUX WANTED other systems to think the
     * password was wrong so logins would fail if the
     * system didn't handle expired passwds and the passwd
     * might be expired.  I think the way to go here
     * is with PAM.
     */
    strtok (found_passwd, ",");
d5534 16
a5549 1
    if (*found_passwd)
d5551 2
a5552 12
	/* user exists and has a password */
	if (strcmp (found_passwd, crypt (password, found_passwd)) == 0)
	    return 1;
	else
	{
#ifdef LOG_AUTHPRIV
	    syslog (LOG_AUTHPRIV | LOG_NOTICE,
		    "password mismatch for %s: %s vs. %s", username,
		    crypt(password, found_passwd), found_passwd);
#endif
	    return 0;
	}
d5555 5
a5559 6
#ifdef LOG_AUTHPRIV
    syslog (LOG_AUTHPRIV | LOG_NOTICE,
	    "user %s authenticated because of blank system password",
	    username);
#endif
    return 1;
a5562 1

d5565 2
a5566 1
check_password (char *username, char *password, char *repository)
d5573 1
a5573 1
       not, we'll check /etc/passwd or maybe whatever is configured via PAM. */
d5581 2
d5584 19
a5602 2
	/* host_user already set by reference, so just return. */
	goto handle_return;
d5604 9
a5612 1
    assert (rc == 0);
d5614 36
a5649 1
    if (!config->system_auth)
d5659 9
a5669 8

    /* No cvs password found, so try /etc/passwd. */
#ifdef HAVE_PAM
    if ( check_pam_password(&username, password) )
#else
    if ( check_system_password(username, password) )
#endif
	host_user = xstrdup (username);
d5671 3
d5675 2
a5676 6

#ifdef LOG_AUTHPRIV
    if (!host_user)
	syslog (LOG_AUTHPRIV | LOG_NOTICE,
		"login refused for %s: user has no password", username);
#endif
d5681 4
a5684 4
	/* Set CVS_Username here, in allocated space.
	   It might or might not be the same as host_user. */
	CVS_Username = xmalloc (strlen (username) + 1);
	strcpy (CVS_Username, username);
a5693 27
static void
pserver_read_line (char **tmp, size_t *tmp_len)
{
    int status;

    /* Make sure the protocol starts off on the right foot... */
    status = buf_read_short_line (buf_from_net, tmp, tmp_len, PATH_MAX);
    if (status == -1)
    {
#ifdef HAVE_SYSLOG_H
	syslog (LOG_DAEMON | LOG_NOTICE,
	        "unexpected EOF encountered during authentication");
#endif
	error (1, 0, "unexpected EOF encountered during authentication");
    }
    if (status == -2)
	status = ENOMEM;
    if (status != 0)
    {
#ifdef HAVE_SYSLOG_H
	syslog (LOG_DAEMON | LOG_NOTICE,
                "error reading from net while validating pserver");
#endif
	error (1, status, "error reading from net while validating pserver");
    }
}

d5698 1
a5698 1
pserver_authenticate_connection (void)
d5700 2
a5701 1
    char *tmp;
d5704 1
d5706 1
d5708 1
d5739 1
a5739 1
     *	    and
a5756 6
    /* Initialize buffers.  */
    buf_to_net = fd_buffer_initialize (STDOUT_FILENO, 0, NULL, false,
				       outbuf_memory_error);
    buf_from_net = fd_buffer_initialize (STDIN_FILENO, 0, NULL, true,
					 outbuf_memory_error);

d5764 1
a5764 1
			&on, sizeof on) < 0)
d5774 5
a5778 1
    pserver_read_line (&tmp, NULL);
d5780 1
a5780 1
    if (strcmp (tmp, "BEGIN VERIFICATION REQUEST") == 0)
d5782 1
a5782 1
    else if (strcmp (tmp, "BEGIN AUTH REQUEST") == 0)
d5784 1
a5784 1
    else if (strcmp (tmp, "BEGIN GSSAPI REQUEST") == 0)
a5802 2
    free (tmp);

d5805 8
a5812 3
    pserver_read_line (&repository, NULL);
    pserver_read_line (&username, NULL);
    pserver_read_line (&password, NULL);
d5816 1
a5816 1
    pserver_read_line (&tmp, NULL);
d5819 1
a5819 1
		"END VERIFICATION REQUEST" : "END AUTH REQUEST")
a5823 2
    free (tmp);

d5826 1
a5826 1
	error (1, 0, "%s: no such repository", repository);
d5838 1
a5838 1
    config = get_root_allow_config (repository);
d5843 2
d5849 4
a5853 2
	memset (descrambled_password, 0, strlen (descrambled_password));
	free (descrambled_password);
d5855 2
a5856 2
	buf_output0 (buf_to_net, "I HATE YOU\n");
	buf_flush (buf_to_net, true);
d5860 1
a5860 1
	exit (EXIT_FAILURE);
a5861 2
    memset (descrambled_password, 0, strlen (descrambled_password));
    free (descrambled_password);
d5866 10
a5875 3
	buf_output0 (buf_to_net, "I LOVE YOU\n");
	buf_flush (buf_to_net, true);
	exit (EXIT_SUCCESS);
d5884 1
a5884 1
    switch_to_user (username, host_user);
d5886 1
d5891 2
a5892 2
    buf_output0 (buf_to_net, "I LOVE YOU\n");
    buf_flush (buf_to_net, true);
d5901 1
a5901 1
kserver_authenticate_connection( void )
d5921 5
a5925 1

d5952 5
a5956 1

d5966 7
a5972 4
	printf ("E Fatal error, aborting.\n"
		"error 0 kerberos: can't get local name: %s\n",
		krb_get_err_text(status));

d5977 1
a5977 1
    switch_to_user ("Kerberos 4", user);
d5981 1
d5983 3
a5986 1
#ifdef HAVE_GSSAPI
d5992 1
a5992 1
gserver_authenticate_connection (void)
a5997 2
    char *credbuf;
    size_t credbuflen;
d6032 3
a6034 12
    if (nbytes <= sizeof buf)
    {
        credbuf = buf;
        credbuflen = sizeof buf;
    }
    else
    {
        credbuflen = nbytes;
        credbuf = xmalloc (credbuflen);
    }
    
    if (fread (credbuf, 1, nbytes, stdin) != nbytes)
d6039 1
a6039 1
    tok_in.value = credbuf;
d6042 10
a6051 10
				&gcontext,	/* context_handle */
				server_creds,	/* verifier_cred_handle */
				&tok_in,	/* input_token */
				NULL,		/* channel bindings */
				&client_name,	/* src_name */
				&mechid,	/* mech_type */
				&tok_out,	/* output_token */
				&ret,
				NULL,		/* ignore time_rec */
				NULL)		/* ignore del_cred_handle */
d6089 1
a6089 4
    switch_to_user ("GSSAPI", buf);

    if (credbuf != buf)
        free (credbuf);
d6109 125
d6243 1
d6252 20
d6273 6
d6281 1
d6283 5
a6287 1
krb_encrypt_input( void *fnclosure, const char *input, char *output, int size )
d6309 1
a6310 2

/* Encrypt Kerberos data.  */
d6312 6
a6317 2
krb_encrypt_output( void *fnclosure, const char *input, char *output,
                    int size, int *translated )
a6346 22


/* Create a Kerberos encryption buffer.  We use a packetizing buffer
   with Kerberos encryption translation routines.  */
struct buffer *
krb_encrypt_buffer_initialize( struct buffer *buf, int input,
                               Key_schedule sched, C_Block block,
                               void *memory( struct buffer * ) )
{
    struct krb_encrypt_data *kd;

    kd = (struct krb_encrypt_data *) xmalloc (sizeof *kd);
    memcpy (kd->sched, sched, sizeof (Key_schedule));
    memcpy (kd->block, block, sizeof (C_Block));

    return packetizing_buffer_initialize (buf,
					  input ? krb_encrypt_input : NULL,
					  input ? NULL : krb_encrypt_output,
					  kd,
					  memory);
}

a6350 2


d6353 1
d6355 3
a6357 1
cvs_output (const char *str, size_t len)
d6364 2
a6365 12
	if (buf_to_net)
	{
	    buf_output (saved_output, str, len);
	    buf_copy_lines (buf_to_net, saved_output, 'M');
	}
# if HAVE_SYSLOG_H
	else
	    syslog (LOG_DAEMON | LOG_ERR,
		    "Attempt to write message after close of network buffer.  "
		    "Message was: %s",
		    str);
# endif /* HAVE_SYSLOG */
d6369 3
a6371 13
	if (protocol)
	{
	    buf_output (saved_output, str, len);
	    buf_copy_lines (protocol, saved_output, 'M');
	    buf_send_counted (protocol);
	}
# if HAVE_SYSLOG_H
	else
	    syslog (LOG_DAEMON | LOG_ERR,
		    "Attempt to write message before initialization of "
		    "protocol buffer.  Message was: %s",
		    str);
# endif /* HAVE_SYSLOG */
d6380 6
a6385 4
	/* Local users that do 'cvs status 2>&1' on a local repository
	   may see the informational messages out-of-order with the
	   status messages unless we use the fflush (stderr) here. */
	fflush (stderr);
d6402 3
a6404 1
cvs_output_binary (char *str, size_t len)
a6416 2
	assert (buf);

d6442 7
a6450 6
#endif

	/* Local users that do 'cvs status 2>&1' on a local repository
	   may see the informational messages out-of-order with the
	   status messages unless we use the fflush (stderr) here. */
	fflush (stderr);
a6451 1
#ifdef USE_SETMODE_STDOUT
d6482 1
a6483 2

/* Like CVS_OUTPUT but output is for stderr not stdout.  */
d6485 3
a6487 1
cvs_outerr (const char *str, size_t len)
d6494 2
a6495 12
	if (buf_to_net)
	{
	    buf_output (saved_outerr, str, len);
	    buf_copy_lines (buf_to_net, saved_outerr, 'E');
	}
# if HAVE_SYSLOG_H
	else
	    syslog (LOG_DAEMON | LOG_ERR,
		    "Attempt to write error message after close of network "
		    "buffer.  Message was: %s",
		    str);
# endif /* HAVE_SYSLOG */
d6499 3
a6501 13
	if (protocol)
	{
	    buf_output (saved_outerr, str, len);
	    buf_copy_lines (protocol, saved_outerr, 'E');
	    buf_send_counted (protocol);
	}
# if HAVE_SYSLOG_H
	else
	    syslog (LOG_DAEMON | LOG_ERR,
		    "Attempt to write error message before initialization of "
		    "protocol buffer.  Message was: %s",
		    str);
# endif /* HAVE_SYSLOG */
a6526 2


d6530 1
d6532 1
a6532 1
cvs_flusherr (void)
d6547 1
a6547 1
	 */
a6556 2


d6560 1
d6562 1
a6562 1
cvs_flushout (void)
d6577 1
a6577 1

a6588 2


d6598 3
a6600 1
cvs_output_tagged (const char *tag, const char *text)
d6639 1
a6639 1
#endif /* SERVER_SUPPORT */
a6640 1
	/* No MT support or we are using a local repository. */
a6642 19
	else if (strcmp (tag, "date") == 0)
	{
#ifdef SERVER_SUPPORT
	    if (server_active)
		/* Output UTC when running as a server without MT support in
		 * the client since it is likely to be more meaningful than
	         * localtime.
		 */
		cvs_output (text, 0);
	    else
#endif /* SERVER_SUPPORT */
	    {
		char *date_in = xstrdup (text);
		char *date = format_date_alloc (date_in);
		cvs_output (date, 0);
		free (date);
		free (date_in);
	    }
	}
@


1.1.2.2
log
@GNU CVS 1.12.11
@
text
@d51 11
a61 1
extern char *server_hostname;
d121 2
a122 2
# ifdef HAVE_PAM
#   include <security/pam_appl.h>
d125 1
a125 1
# endif /* HAVE_PAM */
d139 1
a139 1
# ifdef PROXY_SUPPORT
d151 1
a151 1
# endif /* PROXY_SUPPORT */
a544 8
 *
 * GLOBALS
 *   server_hostname	The name of this host, as determined by the call to
 *			xgethostname() in main().
 *
 * RETURNS
 *   true	If OTHERHOST equals or resolves to HOSTNAME.
 *   false	Otherwise.
d549 4
d555 8
a562 5
    /* As an optimization, check the literal strings before looking up
     * OTHERHOST in the DNS.
     */
    if (!strcasecmp (server_hostname, otherhost))
	return true;
d573 1
a573 1
    return !strcasecmp (server_hostname, hinfo->h_name);
a2495 19
			 *
			 * It is valid to assume that the secondary and primary
			 * are closely enough in sync that this portion of the
			 * communication will be in sync beacuse if they were
			 * not, then the secondary might provide a
			 * valid-request string to the client which contained a
			 * request that the primary didn't support.  If the
			 * client later used the request, the primary server
			 * would exit anyhow.
			 *
			 * FIXME?
			 * An alternative approach might be to make sure that
			 * the secondary provides the same string as the
			 * primary regardless, for purposes like pointing a
			 * secondary at an unwitting primary, in which case it
			 * might be useful to have some way to override the
			 * valid-requests string on a secondary, but it seems
			 * much easier to simply sync the versions, at the
			 * moment.
d2751 10
a2760 2
    free (hostname);
    hostname = xstrdup (arg);
d5538 1
a5538 4
    bool redirect_supported;
#ifdef PROXY_SUPPORT
    bool ditch_log;
#endif /* PROXY_SUPPORT */
d5542 2
a5543 2
    redirect_supported = supported_response ("Redirect");
    if (redirect_supported
d5545 2
a5546 2
	/* I call isProxyServer() last because it can probably be the slowest
	 * call due to the call to gethostbyname().
a5549 20
	/* Before sending a redirect, send a "Referrer" line to the client,
	 * if possible, to give admins more control over canonicalizing roots
	 * sent from the client.
	 */
	if (supported_response ("Referrer"))
	{
	    /* assume :ext:, since that is all we currently support for
	     * proxies and redirection.
	     */
	    char *referrer = Xasprintf (":ext:%s@@%s%s", getcaller(),
					server_hostname,
					current_parsed_root->directory);

	    buf_output0 (buf_to_net, "Referrer ");
	    buf_output0 (buf_to_net, referrer);
	    buf_output0 (buf_to_net, "\n");

	    free (referrer);
	}

a5554 3
#ifdef PROXY_SUPPORT
	ditch_log = true;
#endif /* PROXY_SUPPORT */
a5560 10
#ifdef PROXY_SUPPORT
	if (lookup_command_attribute (arg) & CVS_CMD_MODIFIES_REPOSITORY
            && isProxyServer ())
	    /* Don't ditch the log for write commands on a proxy server.  We
	     * we got here because the `Redirect' response was not supported.
	     */
	    ditch_log = false;
	else
	    ditch_log = true;
#endif /* PROXY_SUPPORT */
d5563 1
a5563 1
    if (proxy_log && ditch_log)
d5592 1
a5592 2
 *   There is no need to dispose of REFERRER if it is set.  It's memory is
 *   tracked by parse_root().
d5602 2
d5608 5
a5612 2
	sprintf (pending_error_text,
		 "E Protocol error: Invalid Referrer: `%s'",
d6866 4
a6869 4
    if (check_pam_password (&username, password))
#else /* !HAVE_PAM */
    if (check_system_password (username, password))
#endif /* HAVE_PAM */
d7190 3
a7192 7
 * pserver_authenticate_connection, and it handles success and failure
 * the same way.
 *
 * GLOBALS
 *   server_hostname	The name of this host, as set via a call to
 *			xgethostname() in main().
 */
d7196 1
d7208 2
a7209 1
    hp = gethostbyname (server_hostname);
@


1.1.3.1
log
@our CVS is currently at 1.11.1p1, thus import that version into vendor branch
@
text
@d118 4
d797 1
a797 1
    if (!isaccessible (path, R_OK | X_OK))
a983 3
    if (dir_name != NULL)
	free (dir_name);

d999 3
d4636 11
d4681 10
d4867 2
d4872 1
d5380 4
a5383 1
	char *env, *cvs_user;
d5393 1
d5398 1
@


1.1.3.2
log
@CVS 1.11.12 is the latest stable version of CVS,
released 06.02.2004, with a huge lot of bug fixes.

/me hopes this will pay off...
@
text
@d62 1
a62 4
# include <syslog.h>
# ifndef LOG_DAEMON   /* for ancient syslogs */
#  define LOG_DAEMON 0
# endif
d162 1
a162 1
static int fd_buffer_shutdown PROTO((struct buffer *));
d207 1
a207 1
	   ever actually happens.  */
d222 2
a223 2
	   style nonblocking I/O.  On System V we will get a zero
	   return if there is no data, even when not at EOF.  */
d263 1
a263 1
		   return.  */
d270 1
a270 1
		return EIO;
d314 1
a314 1
	return errno;
d324 2
a325 2
fd_buffer_shutdown (buf)
     struct buffer *buf;
d327 1
a327 1
    free (buf->closure);
d349 1
a349 1
    p = xmalloc (strlen (dir) + 1);
d353 1
a353 1
    dir_where_cvsadm_lives = xmalloc (strlen (base_dir) + strlen (dir) + 100);
d359 1
a359 1
    tmp = xmalloc (strlen (base_dir) + strlen (dir) + 100);
d363 1
a363 1

d399 1
a399 1
	    empty = xmalloc (strlen (current_parsed_root->directory)
d426 2
a427 1

d518 1
a518 1
    char *q = xmalloc (strlen (dir) + 1);
d645 1
a645 1
    pending_error_text = xmalloc (size);
d711 11
a721 1
	    error_exit ();
d734 1
a734 1

a771 1
	    return;
d776 2
d784 1
a784 1
    path = xmalloc (strlen (current_parsed_root->directory)
d803 1
a803 1
    env = xmalloc (strlen (CVSROOT_ENV) + strlen (current_parsed_root->directory) + 2);
d861 4
a864 3
    /* isabsolute (repos) should always be true, but
       this is a good security precaution regardless. -DRP
     */
d915 1
a915 1

d931 1
a931 1
    p = xmalloc (strlen (server_temp_dir) + 2 * lim + 10);
d980 3
d998 1
a998 4
    if (dir_name != NULL)
	free (dir_name);

    dir_name = xmalloc (strlen (server_temp_dir) + dir_len + 40);
d1004 1
a1004 1

d1089 1
a1089 1
	if (fprintf (f, "/.") < 0)
d1166 1
a1166 1
	pending_error = ENOMEM;
d1170 1
a1170 1
	pending_error_text = xmalloc (80 + strlen (arg));
d1277 1
a1277 1
		pending_error_text = xmalloc (80);
d1305 1
a1305 1
		int save_errno = errno;
d1364 1
a1364 1
	filebuf = xmalloc (size);
d1380 1
a1380 1
		    pending_error_text = xmalloc (80);
d1426 1
a1426 1
	char *p = xrealloc (pending_error_text,
d1479 1
a1479 1
	if (status == -2)
d1483 1
a1483 1
	    pending_error_text = xmalloc (80 + strlen (arg));
d1509 1
a1509 1
	    pending_error_text = xmalloc (80 + strlen (arg));
d1539 1
a1539 1
	/* Now that we know the size, read and discard the file data.  */
d1723 1
a1723 1
	p = (struct an_entry *) xmalloc (sizeof (struct an_entry));
d1729 1
a1729 1
	p->entry = xmalloc (strlen (arg) + 80);
d1760 1
a1760 1
    p = (struct an_entry *) xmalloc (sizeof (struct an_entry));
d1767 1
a1767 1
    cp = xmalloc (strlen (arg) + 2);
d1809 1
a1809 1
    kopt = xmalloc (strlen (arg) + 1);
d1861 4
a1864 4
	   existing Entries file.  If we are checking out a module
	   which explicitly lists more than one file in a particular
	   directory, then we will wind up calling
	   server_write_entries for each such file.  */
d1903 1
a1903 1
    /* Directory in which this notification happens.  xmalloc'd*/
d1906 1
a1906 1
    /* xmalloc'd.  */
d1909 1
a1909 1
    /* The following three all in one xmalloc'd block, pointed to by TYPE.
d1942 1
a1942 1
    new = (struct notify_note *) xmalloc (sizeof (struct notify_note));
d1948 2
a1949 2
    new->dir = xmalloc (strlen (dir_name) + 1);
    new->filename = xmalloc (strlen (arg) + 1);
d1968 1
a1968 1
	    pending_error_text = xmalloc (80 + strlen (arg));
d2078 1
a2078 1
		buf_append_char (buf_to_net, '.');
d2080 1
a2080 1
		buf_output0 (buf_to_net, dir);
d2121 1
a2121 1

d2123 1
a2123 1

d2128 1
a2128 1
	    (char **) xrealloc ((char *)argument_vector,
d2136 1
a2136 1
    p = xmalloc (strlen (arg) + 1);
d2151 1
a2151 1

d2153 1
a2153 1

d2155 1
a2155 1
    p = xrealloc (p, strlen (p) + 1 + strlen (arg) + 1);
a2180 3
	case 'l':
	    error(0, 0, "WARNING: global `-l' option ignored.");
	    break;
a2182 1
	    logoff = 1;
d2193 3
d2242 4
a2245 4
	   authentication.  Flush everything we've output so far, and
	   turn on encryption for future data.  On the input side, we
	   should only have unwrapped as far as the Gssapi-encrypt
	   command, so future unwrapping will become encrypted.  */
d2278 2
a2279 2
	   That includes authentication, so we don't have to do
	   anything further.  */
d2369 1
d2371 7
a2377 1

d2447 1
a2447 1
	return 1;
d2451 30
a2480 30
	/* This command has the potential to modify the repository, so
	 * we check if the user have permission to do that.
	 *
	 * (Only relevant for remote users -- local users can do
	 * whatever normal Unix file permissions allow them to do.)
	 *
	 * The decision method:
	 *
	 *    If $CVSROOT/CVSADMROOT_READERS exists and user is listed
	 *    in it, then read-only access for user.
	 *
	 *    Or if $CVSROOT/CVSADMROOT_WRITERS exists and user NOT
	 *    listed in it, then also read-only access for user.
	 *
	 *    Else read-write access for user.
	 */

	 char *linebuf = NULL;
	 int num_red = 0;
	 size_t linebuf_len = 0;
	 char *fname;
	 size_t flen;
	 FILE *fp;
	 int found_it = 0;

	 /* else */
	 flen = strlen (current_parsed_root->directory)
		+ strlen (CVSROOTADM)
		+ strlen (CVSROOTADM_READERS)
		+ 3;
d2482 2
a2483 2
	 fname = xmalloc (flen);
	 (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
d2486 1
a2486 1
	 fp = fopen (fname, "r");
d2488 1
a2488 1
	 if (fp == NULL)
d2499 17
a2515 17
	 else  /* successfully opened readers file */
	 {
	     while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
	     {
		 /* Hmmm, is it worth importing my own readline
		    library into CVS?  It takes care of chopping
		    leading and trailing whitespace, "#" comments, and
		    newlines automatically when so requested.  Would
		    save some code here...  -kff */

		 /* Chop newline by hand, for strcmp()'s sake. */
		 if (linebuf[num_red - 1] == '\n')
		     linebuf[num_red - 1] = '\0';

		 if (strcmp (linebuf, CVS_Username) == 0)
		     goto handle_illegal;
	     }
d2519 3
a2521 3
	     /* If not listed specifically as a reader, then this user
		has write access by default unless writers are also
		specified in a file . */
d2524 1
a2524 1
	 }
d2529 4
a2532 4
	 flen = strlen (current_parsed_root->directory)
		+ strlen (CVSROOTADM)
		+ strlen (CVSROOTADM_WRITERS)
		+ 3;
d2534 2
a2535 2
	 fname = xmalloc (flen);
	 (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
d2538 1
a2538 1
	 fp = fopen (fname, "r");
d2540 2
a2541 2
	 if (fp == NULL)
	 {
d2543 1
a2543 1
		 free (linebuf);
d2559 1
a2559 8
	 }

	 found_it = 0;
	 while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
	 {
	     /* Chop newline by hand, for strcmp()'s sake. */
	     if (linebuf[num_red - 1] == '\n')
		 linebuf[num_red - 1] = '\0';
d2561 13
a2573 6
	     if (strcmp (linebuf, CVS_Username) == 0)
	     {
		 found_it = 1;
		 break;
	     }
	 }
d2577 3
a2579 3
	 if (found_it)
	 {
	     if (fclose (fp) < 0)
d2581 2
a2582 2
	     if (linebuf)
		 free (linebuf);
d2584 6
a2589 6
	     return 1;
	 }
	 else   /* writers file exists, but this user not listed in it */
	 {
	 handle_illegal:
	     if (fclose (fp) < 0)
d2591 2
a2592 2
	     if (linebuf)
		 free (linebuf);
d2595 1
a2595 1
	 }
a2607 1
#ifdef SUNOS_KLUDGE
a2608 1
#endif
d2634 1
a2634 1

a2665 1
    command_name = cmd_name;
d2754 2
a2755 2
	   buf_from_net.  Instead, everything should go through
	   protocol.  */
d2760 2
a2761 2
	   Since we're now in the child, we should use the simpler
	   protocol_memory_error function.  */
a2838 1
#ifdef SUNOS_KLUDGE
a2839 1
#endif
d2917 2
a2920 2
#ifdef SERVER_FLOWCONTROL
	    int bufmemsize;
d2983 2
a2984 2
		   as I know there was never any reason to do that and
		   SCO doesn't let you select on exceptions on pipes.  */
d3013 1
a3013 1

d3084 1
a3084 1
		int status;
d3086 1
a3086 1
		status = buf_input_data (stdoutbuf, (int *) NULL);
d3109 1
a3109 1
		int status;
d3111 1
a3111 1
		status = buf_input_data (stderrbuf, (int *) NULL);
d3171 1
a3171 1

d3176 2
a3177 2
		int sig = WTERMSIG (status);
		char buf[50];
d3189 2
a3190 2
		/* Test for a core dump.  */
		if (WCOREDUMP (status))
a3211 1
	protocol_inbuf = NULL;
a3213 1
	stderrbuf = NULL;
a3215 1
	stdoutbuf = NULL;
d3298 1
a3298 1

d3310 1
a3310 1

d3326 2
a3327 2
	       I/O.  System V nonblocking I/O returns zero if there is
	       nothing to read.  */
d3329 1
a3329 1
		error (1, 0, "flow control EOF");
d3332 1
a3332 1
		error (1, errno, "flow control read failed");
d3433 1
a3433 1

d3631 2
d3668 1
a3668 1
    do_cvs_command ("tag", cvstag);
d3675 2
d3714 1
a3714 1
    do_cvs_command ("watch", watch_on);
d3723 1
a3723 1
    do_cvs_command ("watch", watch_off);
d3732 1
a3732 1
    do_cvs_command ("watch", watch_add);
d3741 1
a3741 1
    do_cvs_command ("watch", watch_remove);
a3792 2
    cvsroot_t *saved_parsed_root;

d3797 3
a3799 1
		     "E init %s must be an absolute pathname", arg);
a3800 15
#ifdef AUTH_SERVER_SUPPORT
    else if (Pserver_Repos != NULL)
    {
	if (strcmp (Pserver_Repos, arg) != 0)
	{
	    if (alloc_pending (80 + strlen (Pserver_Repos) + strlen (arg)))
		/* The explicitness is to aid people who are writing clients.
		   I don't see how this information could help an
		   attacker.  */
		sprintf (pending_error_text, "\
E Protocol error: init says \"%s\" but pserver says \"%s\"",
			 arg, Pserver_Repos);
	}
    }
#endif
d3802 3
a3804 2
    if (print_pending_error ())
	return;
a3805 2
    saved_parsed_root = current_parsed_root;
    current_parsed_root = local_cvsroot (arg);
a3806 2
    free_cvsroot_t (current_parsed_root);
    current_parsed_root = saved_parsed_root;
d3824 2
d3845 1
a3845 1
	tempdir = xmalloc (strlen (server_temp_dir) + 80);
d3882 2
a3883 2
		    "export" : "checkout",
		    checkout);
d4040 1
a4040 1
		int i;
d4043 1
a4043 1
		buf_output0 (protocol, "Checksum ");
d4092 1
a4092 1
	{
d4132 3
a4134 3
		   file_gzip_level is set.  We could handle this case,
		   but it's not worth it since this case never arises
		   with a current client and server.  */
a4399 1
    buf_send_counted (protocol);
d4461 2
a4462 2
	 wrapper_line;
	 wrap_unparse_rcs_options (&wrapper_line, 0))
d4529 1
a4529 1
	   of aliases before removing */
d4545 1
a4545 1
		buf_output0 (buf_to_net, "Module-expansion ");
d4570 1
d4578 1
d4600 65
d4666 11
d4678 27
d4734 2
d4750 1
d4756 2
a4757 2
	   serve_wrapper_sendme_rcs_options,
	   0),
d4858 5
a4862 5
	/* Since we're done, go ahead and put BUF_TO_NET back into blocking
	 * mode and send any pending output.  In the usual case there won't
	 * won't be any, but there might be if an error occured.
	 */

d4866 5
a4870 4
	/* Next we shut down BUF_FROM_NET.  That will pick up the checksum
	 * generated when the client shuts down its buffer.  Then, after we
	 * have generated any final output, we shut down BUF_TO_NET.
	 */
d4872 2
a4873 1
	if (buf_from_net != NULL)
d4875 2
a4876 5
	    status = buf_shutdown (buf_from_net);
	    if (status != 0)
		error (0, status, "shutting down buffer from client");
	    buf_free (buf_from_net);
	    buf_from_net = NULL;
d4878 1
d4880 3
a4882 3
	if (dont_delete_temp)
	{
	    (void) buf_flush (buf_to_net, 1);
d4884 1
a4884 5
	    buf_free (buf_to_net);
	    buf_to_net = NULL;
	    error_use_protocol = 0;
	    return;
	}
a4885 2
    else if (dont_delete_temp)
	return;
a4980 2
    {
	(void) buf_flush (buf_to_net, 1);
a4981 4
	buf_free (buf_to_net);
	buf_to_net = NULL;
	error_use_protocol = 0;
    }
d4985 1
a4991 2
    char *error_prog_name;		/* Used in error messages */

d5006 1
a5006 1
    buf_from_net = stdio_buffer_initialize (stdin, 0, 1, outbuf_memory_error);
d5038 1
a5038 1
	    server_temp_dir = xmalloc (strlen (Tmpdir) + 80);
d5048 12
a5059 1
		error_exit ();
d5081 2
a5082 2
	       700, to discourage random people from tampering with
	       it.  */
d5085 1
a5085 1
		static const char suffix[] = "abcdefghijklmnopqrstuvwxyz";
d5087 1
a5087 1
		if (i >= sizeof suffix - 1) break;
d5123 19
d5147 23
a5169 1
	(char **) xmalloc (argument_vector_size * sizeof (char *));
d5173 1
d5179 1
a5179 3
    error_prog_name = xmalloc( strlen(program_name) + 8 );
    sprintf(error_prog_name, "%s server", program_name);
    argument_vector[0] = error_prog_name;
d5186 1
a5186 1

d5244 1
a5244 1
		buf_output0 (buf_to_net, "error  unrecognized request `");
a5251 1
    free(error_prog_name);
d5258 1
a5258 1
static void switch_to_user PROTO((const char *, const char *));
d5261 1
a5261 2
switch_to_user (cvs_username, username)
    const char *cvs_username; /* Only used for error messages. */
d5269 2
a5270 2
	/* check_password contains a similar check, so this usually won't be
	   reached unless the CVS user is mapped to an invalid system user.  */
d5273 1
a5273 1
error 0 %s: no such system user\n", username);
a5277 14
    if (pw->pw_uid == 0)
    {
#ifdef HAVE_SYSLOG_H
	    /* FIXME: Can the IP address of the connecting client be retrieved
	     * and printed here?
	     */
	    syslog (LOG_DAEMON | LOG_ALERT,
		    "attempt to root from account: %s", cvs_username
		   );
#endif
        printf("error 0: root not allowed\n");
        error_exit ();
    }

a5317 5
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR,
		    "setgid to %d failed (%m): real %d/%d, effective %d/%d ",
		    pw->pw_gid, getuid(), getgid(), geteuid(), getegid());
#endif
d5323 1
a5323 1

a5332 5
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR,
		    "setuid to %d failed (%m): real %d/%d, effective %d/%d ",
		    pw->pw_uid, getuid(), getgid(), geteuid(), getegid());
#endif
d5347 1
a5347 1

d5352 1
a5352 1
	char *env;
d5362 4
a5365 5
#ifdef AUTH_SERVER_SUPPORT
	env = xmalloc (sizeof "CVS_USER=" + strlen (CVS_Username));
	(void) sprintf (env, "CVS_USER=%s", CVS_Username);
	(void) putenv (env);
#endif
d5376 1
a5376 1
/*
d5400 2
a5401 2
    /* We don't use current_parsed_root->directory because it hasn't been
     * set yet -- our `repository' argument came from the authentication
d5413 1
a5413 1
		    CVSROOTADM, CVSROOTADM_PASSWD);
d5429 1
a5429 1
	{
d5432 1
a5432 1
	}
d5443 1
a5443 1
	char *non_cvsuser_portion;
d5445 18
a5462 18
	/* We need to make sure lines such as
	 *
	 *    "username::sysuser\n"
	 *    "username:\n"
	 *    "username:  \n"
	 *
	 * all result in a found_password of NULL, but we also need to
	 * make sure that
	 *
	 *    "username:   :sysuser\n"
	 *    "username: <whatever>:sysuser\n"
	 *
	 * continues to result in an impossible password.  That way,
	 * an admin would be on safe ground by going in and tacking a
	 * space onto the front of a password to disable the account
	 * (a technique some people use to close accounts
	 * temporarily).
	 */
d5464 2
a5465 2
	/* Make `non_cvsuser_portion' contain everything after the CVS
	   username, but null out any final newline. */
d5467 1
a5467 1
	strtok (non_cvsuser_portion, "\n");
d5469 27
a5495 3
	/* If there's a colon now, we just want to inch past it. */
	if (strchr (non_cvsuser_portion, ':') == non_cvsuser_portion)
	    non_cvsuser_portion++;
d5497 1
a5497 25
	/* Okay, after this conditional chain, found_password and
	   host_user_tmp will have useful values: */

	if ((non_cvsuser_portion == NULL)
	    || (strlen (non_cvsuser_portion) == 0)
	    || ((strspn (non_cvsuser_portion, " \t"))
		== strlen (non_cvsuser_portion)))
	{
	    found_password = NULL;
	    host_user_tmp = NULL;
	}
	else if (strncmp (non_cvsuser_portion, ":", 1) == 0)
	{
	    found_password = NULL;
	    host_user_tmp = non_cvsuser_portion + 1;
	    if (strlen (host_user_tmp) == 0)
		host_user_tmp = NULL;
	}
	else
	{
	    found_password = strtok (non_cvsuser_portion, ":");
	    host_user_tmp = strtok (NULL, ":");
	}

	/* Of course, maybe there was no system user portion... */
d5499 1
a5499 1
	    host_user_tmp = username;
d5501 7
a5507 7
	/* Verify blank passwords directly, otherwise use crypt(). */
	if ((found_password == NULL)
	    || ((strcmp (found_password, crypt (password, found_password))
		 == 0)))
	{
	    /* Give host_user_ptr permanent storage. */
	    *host_user_ptr = xstrdup (host_user_tmp);
d5509 1
a5509 1
	}
d5511 4
a5514 9
	{
#ifdef LOG_AUTHPRIV
	syslog (LOG_AUTHPRIV | LOG_NOTICE,
		"password mismatch for %s in %s: %s vs. %s", username,
		repository, crypt(password, found_password), found_password);
#endif
	    *host_user_ptr = NULL;
	    retval	 = 2;
	}
d5524 1
a5524 1
	free (linebuf);
a5536 2
    char *found_passwd = NULL;
    struct passwd *pw;
d5548 2
d5552 2
a5553 2
	/* host_user already set by reference, so just return. */
	goto handle_return;
d5555 1
a5555 4

    assert (rc == 0);

    if (!system_auth)
d5557 1
a5557 12
	/* Note that the message _does_ distinguish between the case in
	   which we check for a system password and the case in which
	   we do not.  It is a real pain to track down why it isn't
	   letting you in if it won't say why, and I am not convinced
	   that the potential information disclosure to an attacker
	   outweighs this.  */
	printf ("error 0 no such user %s in CVSROOT/passwd\n", username);

	error_exit ();
    }

    /* No cvs password found, so try /etc/passwd. */
d5559 2
a5561 1
    {
a5568 1
    }
d5571 8
a5578 8
    if (found_passwd == NULL && (pw = getpwnam (username)) != NULL)
    {
	found_passwd = pw->pw_passwd;
    }

    if (found_passwd == NULL)
    {
	printf ("E Fatal error, aborting.\n\
d5581 3
a5583 2
	error_exit ();
    }
d5585 21
a5605 20
    /* Allow for dain bramaged HPUX passwd aging
     *  - Basically, HPUX adds a comma and some data
     *    about whether the passwd has expired or not
     *    on the end of the passwd field.
     *  - This code replaces the ',' with '\0'.
     *
     * FIXME - our workaround is brain damaged too.  I'm
     * guessing that HPUX WANTED other systems to think the
     * password was wrong so logins would fail if the
     * system didn't handle expired passwds and the passwd
     * might be expired.  I think the way to go here
     * is with PAM.
     */
    strtok (found_passwd, ",");

    if (*found_passwd)
    {
	/* user exists and has a password */
	if (strcmp (found_passwd, crypt (password, found_passwd)) == 0)
	{
d5607 2
a5608 1
	}
d5610 2
a5611 1
	{
d5613 21
a5633 4
#ifdef LOG_AUTHPRIV
	    syslog (LOG_AUTHPRIV | LOG_NOTICE,
		    "password mismatch for %s: %s vs. %s", username,
		    crypt(password, found_passwd), found_passwd);
d5635 1
a5635 2
	}
	goto handle_return;
d5637 1
a5637 2

    if (password && *password)
d5639 4
a5642 4
	/* user exists and has no system password, but we got
	   one as parameter */
	host_user = xstrdup (username);
	goto handle_return;
a5644 7
    /* user exists but has no password at all */
    host_user = NULL;
#ifdef LOG_AUTHPRIV
    syslog (LOG_AUTHPRIV | LOG_NOTICE,
	    "login refused for %s: user has no password", username);
#endif

d5648 4
a5651 4
	/* Set CVS_Username here, in allocated space.
	   It might or might not be the same as host_user. */
	CVS_Username = xmalloc (strlen (username) + 1);
	strcpy (CVS_Username, username);
d5706 1
a5706 1
     *	    and
d5742 4
a5745 6
	{
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_NOTICE, "bad auth protocol start: EOF");
#endif
	    error (1, 0, "bad auth protocol start: EOF");
	}
d5776 4
a5779 10
    /* Make them pure.
     *
     * We check that none of the lines were truncated by getnline in order
     * to be sure that we don't accidentally allow a blind DOS attack to
     * authenticate, however slim the odds of that might be.
     */
    if (!strip_trailing_newlines (repository)
	|| !strip_trailing_newlines (username)
	|| !strip_trailing_newlines (password))
	error (1, 0, "Maximum line length exceeded during authentication.");
d5810 2
d5816 4
a5820 2
	memset (descrambled_password, 0, strlen (descrambled_password));
	free (descrambled_password);
a5828 2
    memset (descrambled_password, 0, strlen (descrambled_password));
    free (descrambled_password);
d5851 1
a5851 1
    switch_to_user (username, host_user);
d5888 6
a5893 2

	error_exit ();
d5919 6
a5924 2

	error_exit ();
d5935 6
a5940 2

	error_exit ();
d5944 1
a5944 1
    switch_to_user ("Kerberos 4", user);
d6009 10
a6018 10
				&gcontext,	/* context_handle */
				server_creds,	/* verifier_cred_handle */
				&tok_in,	/* input_token */
				NULL,		/* channel bindings */
				&client_name,	/* src_name */
				&mechid,	/* mech_type */
				&tok_out,	/* output_token */
				&ret,
				NULL,		/* ignore time_rec */
				NULL)		/* ignore del_cred_handle */
d6056 1
a6056 1
    switch_to_user ("GSSAPI", buf);
d6329 1
a6329 1
    if (error_use_protocol && buf_to_net != NULL)
d6334 1
a6334 1
    else if (server_active && protocol != NULL)
d6514 1
a6514 1
	 */
d6544 1
a6544 1

@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD again, for various reasons.
@
text
@a4880 1
    static int called = 0;
a4882 23

    if (called++)
	return;

    /* already processing cleanup, do not want recursion */
#ifdef SIGABRT
    (void) SIG_deregister (SIGABRT, server_cleanup);
#endif
#ifdef SIGHUP
    (void) SIG_deregister (SIGHUP, server_cleanup);
#endif
#ifdef SIGINT
    (void) SIG_deregister (SIGINT, server_cleanup);
#endif
#ifdef SIGQUIT
    (void) SIG_deregister (SIGQUIT, server_cleanup);
#endif
#ifdef SIGPIPE
    (void) SIG_deregister (SIGPIPE, server_cleanup);
#endif
#ifdef SIGTERM
    (void) SIG_deregister (SIGTERM, server_cleanup);
#endif
@


1.1.1.3
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d933 1
a933 1
    if (lim < 0 || lim > 10000)
d1638 2
a1639 1
    if (error_pending ()) return;
d1653 2
a1654 19
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
a1655 2
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
d1663 1
a1664 10
	    /* If *TIMEFIELD wasn't "/", we assume that it was because of
	     * multiple calls to Is-Modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of WinCVS & TortoiseCVS rely on
	     * this behavior.
	     */
	    *timefield = '=';
d1681 2
a1682 1
    if (error_pending ()) return;
d1697 2
a1698 19
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
a1699 2
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
d1707 1
a1708 10
	    /* If *TIMEFIELD wasn't "/", we assume that it was because of
	     * multiple calls to Is-Modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of WinCVS & TortoiseCVS rely on
	     * this behavior.
	     */
	    *timefield = 'M';
a1762 1
    int i = 0;
d1764 1
a1764 21

    /* Verify that the entry is well-formed.  This can avoid problems later.
     * At the moment we only check that the Entry contains five slashes in
     * approximately the correct locations since some of the code makes
     * assumptions about this.
     */
    cp = arg;
    if (*cp == 'D') cp++;
    while (i++ < 5)
    {
      if (!cp || *cp != '/')
      {
          if (alloc_pending (80))
              sprintf (pending_error_text,
                       "E protocol error: Malformed Entry");
           return;
      }
    cp = strchr (cp + 1, '/');
    }

    p = xmalloc (sizeof (struct an_entry));
a1995 3
	if (!data[0])
	    goto error;

a2126 9

    if (argument_count >= 10000)
    {
       if (alloc_pending (80))
           sprintf (pending_error_text,
                    "E Protocol error: too many arguments");
       return;
    }

a2156 9

    if (argument_count <= 1)
    {
        if (alloc_pending (80))
            sprintf (pending_error_text,
                     "E Protocol error: called argumentx without prior call to argument");
        return;
    }

d2514 1
a2514 1
                 if (num_red > 0 && linebuf[num_red - 1] == '\n')
d2569 1
a2569 1
             if (num_red > 0 && linebuf[num_red - 1] == '\n')
@


