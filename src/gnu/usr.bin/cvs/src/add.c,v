head	1.4;
access;
symbols
	cvs-1_12_11:1.1.2.1
	tg-mergetmp-mirosx-1:1.4
	tg-mergefixes-1-branch:1.4.0.4
	tg-mergefixes-1-base:1.4
	MIROS_X:1.4.0.2
	MIROS_X_BASE:1.4
	cvs-1_12_10:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_MIRPPC:1.3.0.4
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200404170130:1.1.1.1
	cvs-1_11_12:1.1.3.2
	cvs-1_11_1p1:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.12.02.12.40.10;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.22.13.49.13;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.02.12.21.16.08;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.28;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.41.28;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2004.12.02.11.58.47;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.02.12.19.18.06;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.12.19.38.30;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@update to cvs 1.12.10-MirOS except automatically
generated files
XXX this installs as /usr/bin/ncvs yet, so no
XXX conflicts during the test phase.
XXX I suggest to _not_ update.

XXX *** IMPORTANT *** DO NOT ACCESS CVS 1.11 REPOSITORIES
XXX *** IMPORTANT *** WITH CVS 1.12 OR VICE VERSA!
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * Add
 * 
 * Adds a file or directory to the RCS source repository.  For a file,
 * the entry is marked as "needing to be added" in the user's own CVS
 * directory, and really added to the repository when it is committed.
 * For a directory, it is added at the appropriate place in the source
 * repository and a CVS directory is generated within the directory.
 * 
 * The -m option is currently the only supported option.  Some may wish to
 * supply standard "rcs" options here, but I've found that this causes more
 * trouble than anything else.
 * 
 * The user files or directories must already exist.  For a directory, it must
 * not already have a CVS file in it.
 * 
 * An "add" on a file that has been "remove"d but not committed will cause the
 * file to be resurrected.
 */

#include <assert.h>
#include "cvs.h"
#include "save-cwd.h"
#include "fileattr.h"

static int add_directory (struct file_info *finfo);
static int build_entry (const char *repository, const char *user,
                        const char *options, const char *message,
                        List * entries, const char *tag);

static const char *const add_usage[] =
{
    "Usage: %s %s [-k rcs-kflag] [-m message] files...\n",
    "\t-k\tUse \"rcs-kflag\" to add the file with the specified kflag.\n",
    "\t-m\tUse \"message\" for the creation log.\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

int
add (int argc, char **argv)
{
    char *message = NULL;
    int i;
    char *repository;
    int c;
    int err = 0;
    int added_files = 0;
    char *options = NULL;
    List *entries;
    Vers_TS *vers;
    struct saved_cwd cwd;
    /* Nonzero if we found a slash, and are thus adding files in a
       subdirectory.  */
    int found_slash = 0;
    size_t cvsroot_len;

    if (argc == 1 || argc == -1)
	usage (add_usage);

    wrap_setup ();

    /* parse args */
    optind = 0;
    while ((c = getopt (argc, argv, "+k:m:")) != -1)
    {
	switch (c)
	{
	    case 'k':
		if (options)
		    free (options);
		options = RCS_check_kflag (optarg);
		break;

	    case 'm':
		message = xstrdup (optarg);
		break;
	    case '?':
	    default:
		usage (add_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

    if (argc <= 0)
	usage (add_usage);

    cvsroot_len = strlen (current_parsed_root->directory);

    /* First some sanity checks.  I know that the CVS case is (sort of)
       also handled by add_directory, but we need to check here so the
       client won't get all confused in send_file_names.  */
    for (i = 0; i < argc; i++)
    {
	int skip_file = 0;

	/* If it were up to me I'd probably make this a fatal error.
	   But some people are really fond of their "cvs add *", and
	   don't seem to object to the warnings.
	   Whatever.  */
	strip_trailing_slashes (argv[i]);
	if (strcmp (argv[i], ".") == 0
	    || strcmp (argv[i], "..") == 0
	    || fncmp (argv[i], CVSADM) == 0)
	{
	    if (!quiet)
		error (0, 0, "cannot add special file `%s'; skipping", argv[i]);
	    skip_file = 1;
	}
	else
	{
	    char *p;
	    p = argv[i];
	    while (*p != '\0')
	    {
		if (ISSLASH (*p))
		{
		    found_slash = 1;
		    break;
		}
		++p;
	    }
	}

	if (skip_file)
	{
	    int j;

	    /* FIXME: We don't do anything about free'ing argv[i].  But
	       the problem is that it is only sometimes allocated (see
	       cvsrc.c).  */

	    for (j = i; j < argc - 1; ++j)
		argv[j] = argv[j + 1];
	    --argc;
	    /* Check the new argv[i] again.  */
	    --i;
	    ++err;
	}
    }

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
    {
	int j;

	if (argc == 0)
	    /* We snipped out all the arguments in the above sanity
	       check.  We can just forget the whole thing (and we
	       better, because if we fired up the server and passed it
	       nothing, it would spit back a usage message).  */
	    return err;

	start_server ();
	ign_setup ();
	if (options)
	{
	    send_arg (options);
	    free (options);
	}
	option_with_arg ("-m", message);
	send_arg ("--");

	/* If !found_slash, refrain from sending "Directory", for
	   CVS 1.9 compatibility.  If we only tried to deal with servers
	   which are at least CVS 1.9.26 or so, we wouldn't have to
	   special-case this.  */
	if (found_slash)
	{
	    repository = Name_Repository (NULL, NULL);
	    send_a_repository ("", repository, "");
	    free (repository);
	}

	for (j = 0; j < argc; ++j)
	{
	    /* FIXME: Does this erroneously call Create_Admin in error
	       conditions which are only detected once the server gets its
	       hands on things?  */
	    if (isdir (argv[j]))
	    {
		char *tag;
		char *date;
		int nonbranch;
		char *rcsdir;
		char *p;
		char *update_dir;
		/* This is some mungeable storage into which we can point
		   with p and/or update_dir.  */
		char *filedir;

		if (save_cwd (&cwd))
		    error (1, errno, "Failed to save current directory.");

		filedir = xstrdup (argv[j]);
                /* Deliberately discard the const below since we know we just
                 * allocated filedir and can do what we like with it.
                 */
		p = (char *)last_component (filedir);
		if (p == filedir)
		{
		    update_dir = "";
		}
		else
		{
		    p[-1] = '\0';
		    update_dir = filedir;
		    if (CVS_CHDIR (update_dir) < 0)
			error (1, errno,
			       "could not chdir to `%s'", update_dir);
		}

		/* find the repository associated with our current dir */
		repository = Name_Repository (NULL, update_dir);

		/* don't add stuff to Emptydir */
		if (strncmp (repository, current_parsed_root->directory, cvsroot_len) == 0
		    && ISSLASH (repository[cvsroot_len])
		    && strncmp (repository + cvsroot_len + 1,
				CVSROOTADM,
				sizeof CVSROOTADM - 1) == 0
		    && ISSLASH (repository[cvsroot_len + sizeof CVSROOTADM])
		    && strcmp (repository + cvsroot_len + sizeof CVSROOTADM + 1,
			       CVSNULLREPOS) == 0)
		    error (1, 0, "cannot add to `%s'", repository);

		/* before we do anything else, see if we have any
		   per-directory tags */
		ParseTag (&tag, &date, &nonbranch);

		rcsdir = xmalloc (strlen (repository) + strlen (p) + 5);
		sprintf (rcsdir, "%s/%s", repository, p);

		Create_Admin (p, argv[j], rcsdir, tag, date,
			      nonbranch, 0, 1);

		if (found_slash)
		    send_a_repository ("", repository, update_dir);

		if (restore_cwd (&cwd))
		    error (1, errno,
		           "Failed to restore current directory, `%s'.",
		           cwd.name);
		free_cwd (&cwd);

		if (tag)
		    free (tag);
		if (date)
		    free (date);
		free (rcsdir);

		if (p == filedir)
		    Subdir_Register ((List *) NULL, (char *) NULL, argv[j]);
		else
		{
		    Subdir_Register ((List *) NULL, update_dir, p);
		}
		free (repository);
		free (filedir);
	    }
	}
	send_files (argc, argv, 0, 0, SEND_BUILD_DIRS | SEND_NO_CONTENTS);
	send_file_names (argc, argv, SEND_EXPAND_WILD);
	send_to_server ("add\012", 0);
	if (message)
	    free (message);
	return err + get_responses_and_close ();
    }
#endif

    /* walk the arg list adding files/dirs */
    for (i = 0; i < argc; i++)
    {
	int begin_err = err;
#ifdef SERVER_SUPPORT
	int begin_added_files = added_files;
#endif
	struct file_info finfo;
	char *filename, *p;

	memset (&finfo, 0, sizeof finfo);

	if (save_cwd (&cwd))
	    error (1, errno, "Failed to save current directory.");

	finfo.fullname = xstrdup (argv[i]);
	filename = xstrdup (argv[i]);
	/* We know we can discard the const below since we just allocated
	 * filename and can do as we like with it.
         */
	p = (char *)last_component (filename);
	if (p == filename)
	{
	    finfo.update_dir = "";
	    finfo.file = p;
	}
	else
	{
	    p[-1] = '\0';
	    finfo.update_dir = filename;
	    finfo.file = p;
	    if (CVS_CHDIR (finfo.update_dir) < 0)
		error (1, errno, "could not chdir to `%s'", finfo.update_dir);
	}

	/* Add wrappers for this directory.  They exist only until
	   the next call to wrap_add_file.  */
	wrap_add_file (CVSDOTWRAPPER, 1);

	finfo.rcs = NULL;

	/* Find the repository associated with our current dir.  */
	repository = Name_Repository (NULL, finfo.update_dir);

	/* don't add stuff to Emptydir */
	if (strncmp (repository, current_parsed_root->directory,
		     cvsroot_len) == 0
	    && ISSLASH (repository[cvsroot_len])
	    && strncmp (repository + cvsroot_len + 1,
			CVSROOTADM,
			sizeof CVSROOTADM - 1) == 0
	    && ISSLASH (repository[cvsroot_len + sizeof CVSROOTADM])
	    && strcmp (repository + cvsroot_len + sizeof CVSROOTADM + 1,
		       CVSNULLREPOS) == 0)
	    error (1, 0, "cannot add to `%s'", repository);

	entries = Entries_Open (0, NULL);

	finfo.repository = repository;
	finfo.entries = entries;

	/* We pass force_tag_match as 1.  If the directory has a
           sticky branch tag, and there is already an RCS file which
           does not have that tag, then the head revision is
           meaningless to us.  */
	vers = Version_TS (&finfo, options, NULL, NULL, 1, 0);
	if (vers->vn_user == NULL)
	{
	    /* No entry available, ts_rcs is invalid */
	    if (vers->vn_rcs == NULL)
	    {
		/* There is no RCS file either */
		if (vers->ts_user == NULL)
		{
		    /* There is no user file either */
		    error (0, 0, "nothing known about `%s'", finfo.fullname);
		    err++;
		}
		else if (!isdir (finfo.file)
			 || wrap_name_has (finfo.file, WRAP_TOCVS))
		{
		    /*
		     * See if a directory exists in the repository with
		     * the same name.  If so, blow this request off.
		     */
		    char *dname = xmalloc (strlen (repository)
					   + strlen (finfo.file)
					   + 10);
		    (void) sprintf (dname, "%s/%s", repository, finfo.file);
		    if (isdir (dname))
		    {
			error (0, 0,
			       "cannot add file `%s' since the directory",
			       finfo.fullname);
			error (0, 0, "`%s' already exists in the repository",
			       dname);
			error (1, 0, "invalid filename overlap");
		    }
		    free (dname);

		    if (vers->options == NULL || *vers->options == '\0')
		    {
			/* No options specified on command line (or in
			   rcs file if it existed, e.g. the file exists
			   on another branch).  Check for a value from
			   the wrapper stuff.  */
			if (wrap_name_has (finfo.file, WRAP_RCSOPTION))
			{
			    if (vers->options)
				free (vers->options);
			    vers->options = wrap_rcsoption (finfo.file, 1);
			}
		    }

		    if (vers->nonbranch)
		    {
			error (0, 0,
				"cannot add file on non-branch tag `%s'",
				vers->tag);
			++err;
		    }
		    else
		    {
			/* There is a user file, so build the entry for it */
			if (build_entry (repository, finfo.file, vers->options,
					 message, entries, vers->tag) != 0)
			    err++;
			else
			{
			    added_files++;
			    if (!quiet)
			    {
				if (vers->tag)
				    error (0, 0, "scheduling %s `%s' for"
					   " addition on branch `%s'",
					   (wrap_name_has (finfo.file,
							   WRAP_TOCVS)
					    ? "wrapper"
					    : "file"),
					   finfo.fullname, vers->tag);
				else
				    error (0, 0,
					   "scheduling %s `%s' for addition",
					   (wrap_name_has (finfo.file,
							   WRAP_TOCVS)
					    ? "wrapper"
					    : "file"),
					   finfo.fullname);
			    }
			}
		    }
		}
	    }
	    else if (RCS_isdead (vers->srcfile, vers->vn_rcs))
	    {
		if (isdir (finfo.file)
		    && !wrap_name_has (finfo.file, WRAP_TOCVS))
		{
		    error (0, 0,
			   "the directory `%s' cannot be added because a file"
			   " of the", finfo.fullname);
		    error (1, 0, "same name already exists in the repository.");
		}
		else
		{
		    if (vers->nonbranch)
		    {
			error (0, 0,
			       "cannot add file on non-branch tag `%s'",
			       vers->tag);
			++err;
		    }
		    else
		    {
			char *timestamp = NULL;
			if (vers->ts_user == NULL)
			{
			    /* If this file does not exist locally, assume that
			     * the last version on the branch is being
			     * resurrected.
			     *
			     * Compute previous revision.  We assume that it
			     * exists and that it is not a revision on the
			     * trunk of the form X.1 (1.1, 2.1, 3.1, ...).  We
			     * also assume that it is not dead, which seems
			     * fair since we know vers->vn_rcs is dead
			     * and we shouldn't see two dead revisions in a
			     * row.
			     */
			    char *prev = previous_rev (vers->srcfile,
			                               vers->vn_rcs);
			    int status;
			    if (prev == NULL)
			    {
				/* There is no previous revision.  Either:
				 *
				 *  * Revision 1.1 was dead, as when a file was
				 *    inititially added on a branch, 
				 *
				 * or
				 *
				 *  * All previous revisions have been deleted.
				 *    For instance, via `admin -o'.
				 */
				if (!really_quiet)
				    error (0, 0,
"File `%s' has no previous revision to resurrect.",
			                   finfo.fullname);
				free (prev);
				goto skip_this_file;
			    }
			    if (!quiet)
				error (0, 0,
"Resurrecting file `%s' from revision %s.",
			               finfo.fullname, prev);
			    status = RCS_checkout (vers->srcfile, finfo.file,
						   prev, vers->tag,
						   vers->options, RUN_TTY,
			                           NULL, NULL);
			    xchmod (finfo.file, 1);
			    if (status != 0)
			    {
				error (0, 0, "Failed to resurrect revision %s",
				       prev);
				err++;
			    }
			    else
			    {
				/* I don't actually set vers->ts_user here
				 * because it would confuse server_update().
				 */
				timestamp = time_stamp (finfo.file);
				if (!really_quiet)
				    write_letter (&finfo, 'U');
			    }
			    free (prev);
			}
			if (!quiet)
			{
			    char *bbuf;
			    if (vers->tag)
			    {
				bbuf = xmalloc (strlen (vers->tag) + 14);
				sprintf (bbuf, " on branch `%s'", vers->tag);
			    }
			    else
				bbuf = "";
			    error (0, 0,
"Re-adding file `%s'%s after dead revision %s.",
				   finfo.fullname, bbuf, vers->vn_rcs);
			    if (vers->tag)
				free (bbuf);
			}
			Register (entries, finfo.file, "0",
				  timestamp ? timestamp : vers->ts_user,
				  vers->options, vers->tag, vers->date, NULL);
			if (timestamp) free (timestamp);
#ifdef SERVER_SUPPORT
			if (server_active && vers->ts_user == NULL)
			{
			    /* If we resurrected the file from the archive, we
			     * need to tell the client about it.
			     */
			    server_updated (&finfo, vers,
					    SERVER_UPDATED,
					    (mode_t) -1, NULL, NULL);
			    /* This is kinda hacky or, at least, it renders the
			     * name "begin_added_files" obsolete, but we want
			     * the added_files to be counted without triggering
			     * the check that causes server_checked_in() to be
			     * called below since we have already called
			     * server_updated() to complete the resurrection.
			     */
			    ++begin_added_files;
			}
#endif
			++added_files;
		    }
		}
	    }
	    else
	    {
		/*
		 * There is an RCS file already, so somebody else must've
		 * added it
		 */
		error (0, 0, "`%s' added independently by second party",
		       finfo.fullname);
		err++;
	    }
	}
	else if (vers->vn_user[0] == '0' && vers->vn_user[1] == '\0')
	{

	    /*
	     * An entry for a new-born file, ts_rcs is dummy, but that is
	     * inappropriate here
	     */
	    if (!quiet)
		error (0, 0, "`%s' has already been entered", finfo.fullname);
	    err++;
	}
	else if (vers->vn_user[0] == '-')
	{
	    /* An entry for a removed file, ts_rcs is invalid */
	    if (vers->ts_user == NULL)
	    {
		/* There is no user file (as it should be) */
		if (vers->vn_rcs == NULL)
		{

		    /*
		     * There is no RCS file, so somebody else must've removed
		     * it from under us
		     */
		    error (0, 0,
			   "cannot resurrect `%s'; RCS file removed by"
			   " second party", finfo.fullname);
		    err++;
		}
		else
		{
		    int status;
		    /*
		     * There is an RCS file, so remove the "-" from the
		     * version number and restore the file
		     */
		    char *tmp = xmalloc (strlen (vers->vn_user));
		    (void) strcpy (tmp, vers->vn_user + 1);
		    (void) strcpy (vers->vn_user, tmp);
		    free( tmp );
		    status = RCS_checkout (vers->srcfile, finfo.file,
					   vers->vn_user, vers->tag,
					   vers->options, RUN_TTY,
					   NULL, NULL);
		    xchmod (finfo.file, cvswrite);
		    if (status != 0)
		    {
			error (0, 0, "Failed to resurrect revision %s.",
			       vers->vn_user);
			err++;
			tmp = NULL;
		    }
		    else
		    {
			/* I don't actually set vers->ts_user here because it
			 * would confuse server_update().
			 */
			tmp = time_stamp (finfo.file);
			write_letter (&finfo, 'U');
			if (!quiet)
			     error (0, 0, "`%s', version %s, resurrected",
			            finfo.fullname, vers->vn_user);
		    }
		    Register (entries, finfo.file, vers->vn_user,
                              tmp, vers->options,
			      vers->tag, vers->date, NULL);
		    if (tmp) free (tmp);
#ifdef SERVER_SUPPORT
		    if (server_active)
		    {
			/* If we resurrected the file from the archive, we
			 * need to tell the client about it.
			 */
			server_updated (&finfo, vers,
					SERVER_UPDATED,
					(mode_t) -1, NULL, NULL);
		    }
		   /* We don't increment added_files here because this isn't
		    * a change that needs to be committed.
		    */
#endif
		}
	    }
	    else
	    {
		/* The user file shouldn't be there */
		error (0, 0, "\
`%s' should be removed and is still there (or is back again)", finfo.fullname);
		err++;
	    }
	}
	else
	{
	    /* A normal entry, ts_rcs is valid, so it must already be there */
	    if (!quiet)
		error (0, 0, "`%s' already exists, with version number %s",
			finfo.fullname,
			vers->vn_user);
	    err++;
	}
	freevers_ts (&vers);

	/* passed all the checks.  Go ahead and add it if its a directory */
	if (begin_err == err
	    && isdir (finfo.file)
	    && !wrap_name_has (finfo.file, WRAP_TOCVS))
	{
	    err += add_directory (&finfo);
	}
	else
	{
#ifdef SERVER_SUPPORT
	    if (server_active && begin_added_files != added_files)
		server_checked_in (finfo.file, finfo.update_dir, repository);
#endif
	}

skip_this_file:
	free (repository);
	Entries_Close (entries);

	if (restore_cwd (&cwd))
	    error (1, errno, "Failed to restore current directory, `%s'.",
	           cwd.name);
	free_cwd (&cwd);

	/* It's okay to discard the const to free this - we allocated this
	 * above.  The const is for everybody else.
	 */
	free ((char *) finfo.fullname);
	free (filename);
    }
    if (added_files && !really_quiet)
	error (0, 0, "use `%s commit' to add %s permanently",
	       program_name,
	       (added_files == 1) ? "this file" : "these files");

    if (message)
	free (message);
    if (options)
	free (options);

    return err;
}



/*
 * The specified user file is really a directory.  So, let's make sure that
 * it is created in the RCS source repository, and that the user's directory
 * is updated to include a CVS directory.
 * 
 * Returns 1 on failure, 0 on success.
 */
static int
add_directory (struct file_info *finfo)
{
    const char *repository = finfo->repository;
    List *entries = finfo->entries;
    const char *dir = finfo->file;

    char *rcsdir = NULL;
    struct saved_cwd cwd;
    char *message = NULL;
    char *tag, *date;
    int nonbranch;
    char *attrs;

    if (strchr (dir, '/') != NULL)
    {
	/* "Can't happen".  */
	error (0, 0,
	       "directory %s not added; must be a direct sub-directory", dir);
	return 1;
    }
    if (fncmp (dir, CVSADM) == 0)
    {
	error (0, 0, "cannot add a `%s' directory", CVSADM);
	return 1;
    }

    /* before we do anything else, see if we have any per-directory tags */
    ParseTag (&tag, &date, &nonbranch);

    /* Remember the default attributes from this directory, so we can apply
       them to the new directory.  */
    fileattr_startdir (repository);
    attrs = fileattr_getall (NULL);
    fileattr_free ();

    /* now, remember where we were, so we can get back */
    if (save_cwd (&cwd))
    {
	error (0, errno, "Failed to save current directory.");
	return 1;
    }
    if (CVS_CHDIR (dir) < 0)
    {
	error (0, errno, "cannot chdir to %s", finfo->fullname);
	return 1;
    }
#ifdef SERVER_SUPPORT
    if (!server_active && isfile (CVSADM))
#else
    if (isfile (CVSADM))
#endif
    {
	error (0, 0, "%s/%s already exists", finfo->fullname, CVSADM);
	goto out;
    }

    rcsdir = xmalloc (strlen (repository) + strlen (dir) + 5);
    sprintf (rcsdir, "%s/%s", repository, dir);
    if (isfile (rcsdir) && !isdir (rcsdir))
    {
	error (0, 0, "%s is not a directory; %s not added", rcsdir,
	       finfo->fullname);
	goto out;
    }

    /* setup the log message */
    message = xmalloc (strlen (rcsdir)
		       + 36
		       + (tag == NULL ? 0 : strlen (tag) + 38)
		       + (date == NULL ? 0 : strlen (date) + 39));
    (void) sprintf (message, "Directory %s added to the repository\n",
		    rcsdir);
    if (tag)
    {
	(void) strcat (message, "--> Using per-directory sticky tag `");
	(void) strcat (message, tag);
	(void) strcat (message, "'\n");
    }
    if (date)
    {
	(void) strcat (message, "--> Using per-directory sticky date `");
	(void) strcat (message, date);
	(void) strcat (message, "'\n");
    }

    if (!isdir (rcsdir))
    {
	mode_t omask;
	Node *p;
	List *ulist;
	struct logfile_info *li;

	/* There used to be some code here which would prompt for
	   whether to add the directory.  The details of that code had
	   bitrotted, but more to the point it can't work
	   client/server, doesn't ask in the right way for GUIs, etc.
	   A better way of making it harder to accidentally add
	   directories would be to have to add and commit directories
	   like for files.  The code was #if 0'd at least since CVS 1.5.  */

	if (!noexec)
	{
	    omask = umask (cvsumask);
	    if (CVS_MKDIR (rcsdir, 0777) < 0)
	    {
		error (0, errno, "cannot mkdir %s", rcsdir);
		(void) umask (omask);
		goto out;
	    }
	    (void) umask (omask);
	}

	/* Now set the default file attributes to the ones we inherited
	   from the parent directory.  */
	fileattr_startdir (rcsdir);
	fileattr_setall (NULL, attrs);
	fileattr_write ();
	fileattr_free ();
	if (attrs != NULL)
	    free (attrs);

	/*
	 * Set up an update list with a single title node for Update_Logfile
	 */
	ulist = getlist ();
	p = getnode ();
	p->type = UPDATE;
	p->delproc = update_delproc;
	p->key = xstrdup ("- New directory");
	li = (struct logfile_info *) xmalloc (sizeof (struct logfile_info));
	li->type = T_TITLE;
	li->tag = xstrdup (tag);
	li->rev_old = li->rev_new = NULL;
	p->data = li;
	(void) addnode (ulist, p);
	Update_Logfile (rcsdir, message, (FILE *) NULL, ulist);
	dellist (&ulist);
    }

#ifdef SERVER_SUPPORT
    if (server_active)
	WriteTemplate (finfo->fullname, 1, rcsdir);
    else
#endif
	Create_Admin (".", finfo->fullname, rcsdir, tag, date, nonbranch, 0, 1);

    if (tag)
	free (tag);
    if (date)
	free (date);

    if (restore_cwd (&cwd))
	error (1, errno, "Failed to restore current directory, `%s'.",
	       cwd.name);
    free_cwd (&cwd);

    Subdir_Register (entries, (char *) NULL, dir);

    if (!really_quiet)
	cvs_output (message, 0);

    free (rcsdir);
    free (message);

    return 0;

out:
    if (restore_cwd (&cwd))
	error (1, errno, "Failed to restore current directory, `%s'.",
	       cwd.name);
    free_cwd (&cwd);
    if (rcsdir != NULL)
	free (rcsdir);
    return 0;
}



/*
 * Builds an entry for a new file and sets up "CVS/file",[pt] by
 * interrogating the user.  Returns non-zero on error.
 */
static int
build_entry (const char *repository, const char *user, const char *options,
             const char *message, List *entries, const char *tag)
{
    char *fname;
    char *line;
    FILE *fp;

    if (noexec)
	return 0;

    /*
     * The requested log is read directly from the user and stored in the
     * file user,t.  If the "message" argument is set, use it as the
     * initial creation log (which typically describes the file).
     */
    fname = xmalloc (strlen (user) + 80);
    (void) sprintf (fname, "%s/%s%s", CVSADM, user, CVSEXT_LOG);
    fp = open_file (fname, "w+");
    if (message && fputs (message, fp) == EOF)
	    error (1, errno, "cannot write to %s", fname);
    if (fclose(fp) == EOF)
        error(1, errno, "cannot close %s", fname);
    free (fname);

    /*
     * Create the entry now, since this allows the user to interrupt us above
     * without needing to clean anything up (well, we could clean up the
     * ,t file, but who cares).
     */
    line = xmalloc (strlen (user) + 20);
    (void) sprintf (line, "Initial %s", user);
    Register (entries, user, "0", line, options, tag, (char *) 0, (char *) 0);
    free (line);
    return 0;
}



/* vim:tabstop=8:shiftwidth=4
 */
@


1.3
log
@cvs-1.11.12 doesn't do the joints correctly (what were the
FSF people smoking?), it memory faults.
thusly revert to 1.11.1p1

tested.
agreed bsiegert@@
@
text
@d27 1
d29 1
a29 1
#include "savecwd.h"
d32 4
a35 3
static int add_directory PROTO ((struct file_info *finfo));
static int build_entry PROTO((char *repository, char *user, char *options,
		        char *message, List * entries, char *tag));
d47 1
a47 3
add (argc, argv)
    int argc;
    char **argv;
d124 1
a124 1
		if (ISDIRSEP (*p))
d153 1
a153 1
	int i;
d170 1
d183 1
a183 1
	for (i = 0; i < argc; ++i)
d188 1
a188 11
	    /* FIXME-also: if filenames are case-insensitive on the
	       client, and the directory in the repository already
	       exists and is named "foo", and the command is "cvs add
	       FOO", this call to Create_Admin puts the wrong thing in
	       CVS/Repository and so a subsequent "cvs update" will
	       give an error.  The fix will be to have the server report
	       back what it actually did (e.g. use tagged text for the
	       "Directory %s added" message), and then Create_Admin,
	       which should also fix the error handling concerns.  */

	    if (isdir (argv[i]))
d201 1
a201 1
		    error_exit ();
d203 5
a207 2
		filedir = xstrdup (argv[i]);
		p = last_component (filedir);
d218 1
a218 1
			       "could not chdir to %s", update_dir);
d226 1
a226 1
		    && ISDIRSEP (repository[cvsroot_len])
d230 1
a230 1
		    && ISDIRSEP (repository[cvsroot_len + sizeof CVSROOTADM])
d233 1
a233 1
		    error (1, 0, "cannot add to %s", repository);
d242 1
a242 1
		Create_Admin (p, argv[i], rcsdir, tag, date,
d248 4
a251 2
		if (restore_cwd (&cwd, NULL))
		    error_exit ();
d261 1
a261 1
		    Subdir_Register ((List *) NULL, (char *) NULL, argv[i]);
d287 1
a287 4
	char *p;
#if defined (SERVER_SUPPORT) && !defined (FILENAMES_CASE_INSENSITIVE)
	char *found_name;
#endif
d292 1
a292 1
	    error_exit ();
d295 6
a300 2
	p = last_component (argv[i]);
	if (p == argv[i])
d308 1
a308 1
	    finfo.update_dir = argv[i];
d311 1
a311 1
		error (1, errno, "could not chdir to %s", finfo.update_dir);
d324 3
a326 2
	if (strncmp (repository, current_parsed_root->directory, cvsroot_len) == 0
	    && ISDIRSEP (repository[cvsroot_len])
d330 1
a330 1
	    && ISDIRSEP (repository[cvsroot_len + sizeof CVSROOTADM])
d333 1
a333 1
	    error (1, 0, "cannot add to %s", repository);
a339 54
#if defined (SERVER_SUPPORT) && !defined (FILENAMES_CASE_INSENSITIVE)
	if (ign_case)
	{
	    /* Need to check whether there is a directory with the
	       same name but different case.  We'll check for files
	       with the same name later (when Version_TS calls
	       RCS_parse which calls fopen_case).  If CVS some day
	       records directories in the RCS files, then we should be
	       able to skip the separate check here, which would be
	       cleaner.  */
	    DIR *dirp;
	    struct dirent *dp;

	    dirp = CVS_OPENDIR (finfo.repository);
	    if (dirp == NULL)
		error (1, errno, "cannot read directory %s", finfo.repository);
	    found_name = NULL;
	    errno = 0;
	    while ((dp = CVS_READDIR (dirp)) != NULL)
	    {
		if (cvs_casecmp (dp->d_name, finfo.file) == 0)
		{
		    if (found_name != NULL)
			error (1, 0, "%s is ambiguous; could mean %s or %s",
			       finfo.file, dp->d_name, found_name);
		    found_name = xstrdup (dp->d_name);
		}
	    }
	    if (errno != 0)
		error (1, errno, "cannot read directory %s", finfo.repository);
	    CVS_CLOSEDIR (dirp);

	    if (found_name != NULL)
	    {
		/* OK, we are about to patch up the name, so patch up
		   the temporary directory too to match.  The isdir
		   should "always" be true (since files have ,v), but
		   I guess we might as well make some attempt to not
		   get confused by stray files in the repository.  */
		if (isdir (finfo.file))
		{
		    if (CVS_MKDIR (found_name, 0777) < 0
			&& errno != EEXIST)
			error (0, errno, "cannot create %s", finfo.file);
		}

		/* OK, we found a directory with the same name, maybe in
		   a different case.  Treat it as if the name were the
		   same.  */
		finfo.file = found_name;
	    }
	}
#endif

d354 1
a354 1
		    error (0, 0, "nothing known about %s", finfo.fullname);
d375 1
a375 1
			error (1, 0, "illegal filename overlap");
d396 1
a396 1
				"cannot add file on non-branch tag %s",
d412 2
a413 2
				    error (0, 0, "\
scheduling %s `%s' for addition on branch `%s'",
d437 4
a440 4
		    error (0, 0, "\
the directory `%s' cannot be added because a file of the", finfo.fullname);
		    error (1, 0, "\
same name already exists in the repository.");
d447 1
a447 1
			       "cannot add file on non-branch tag %s",
d453 63
d518 1
d520 4
a523 3
				error (0, 0, "\
file `%s' will be added on branch `%s' from version %s",
					finfo.fullname, vers->tag, vers->vn_rcs);
d525 6
a530 7
				/* I'm not sure that mentioning
				   vers->vn_rcs makes any sense here; I
				   can't think of a way to word the
				   message which is not confusing.  */
				error (0, 0, "\
re-adding file %s (in place of dead revision %s)",
					finfo.fullname, vers->vn_rcs);
d532 23
a554 3
			Register (entries, finfo.file, "0", vers->ts_user,
				  vers->options,
				  vers->tag, NULL, NULL);
d565 1
a565 1
		error (0, 0, "%s added independently by second party",
d578 1
a578 1
		error (0, 0, "%s has already been entered", finfo.fullname);
d594 3
a596 2
		    error (0, 0, "\
cannot resurrect %s; RCS file removed by second party", finfo.fullname);
d601 1
a601 1

d606 1
a606 2
		    char *tmp = xmalloc (strlen (finfo.file) + 50);

d609 7
a615 11
		    (void) sprintf (tmp, "Resurrected %s", finfo.file);
		    Register (entries, finfo.file, vers->vn_user, tmp,
			      vers->options,
			      vers->tag, vers->date, vers->ts_conflict);
		    free (tmp);

		    /* XXX - bugs here; this really resurrect the head */
		    /* Note that this depends on the Register above actually
		       having written Entries, or else it won't really
		       check the file out.  */
		    if (update (2, argv + i - 1) == 0)
d617 1
a617 2
			error (0, 0, "%s, version %s, resurrected",
			       finfo.fullname,
d619 2
d624 22
a645 2
			error (0, 0, "could not resurrect %s", finfo.fullname);
			err++;
d647 4
d657 1
a657 1
%s should be removed and is still there (or is back again)", finfo.fullname);
d665 1
a665 1
		error (0, 0, "%s already exists, with version number %s",
d686 2
d691 3
a693 2
	if (restore_cwd (&cwd, NULL))
	    error_exit ();
d696 5
a700 5
	free (finfo.fullname);
#if defined (SERVER_SUPPORT) && !defined (FILENAMES_CASE_INSENSITIVE)
	if (ign_case && found_name != NULL)
	    free (found_name);
#endif
d703 1
a703 1
	error (0, 0, "use '%s commit' to add %s permanently",
d712 1
a712 1
    return (err);
d715 2
d725 1
a725 2
add_directory (finfo)
    struct file_info *finfo;
d727 1
a727 1
    char *repository = finfo->repository;
d729 1
a729 1
    char *dir = finfo->file;
d743 1
a743 1
	return (1);
d748 1
a748 1
	return (1);
d762 5
a766 2
	return (1);
    if ( CVS_CHDIR (dir) < 0)
d769 1
a769 1
	return (1);
d792 5
a796 4
		       + 80
		       + (tag == NULL ? 0 : strlen (tag) + 80)
		       + (date == NULL ? 0 : strlen (date) + 80));
    (void) sprintf (message, "Directory %s added to the repository\n", rcsdir);
d858 1
a858 1
	p->data = (char *) li;
d865 3
a867 1
    if (!server_active)
d869 2
a870 1
        Create_Admin (".", finfo->fullname, rcsdir, tag, date, nonbranch, 0, 1);
d876 3
a878 2
    if (restore_cwd (&cwd, NULL))
	error_exit ();
d883 2
a884 1
    cvs_output (message, 0);
d889 1
a889 1
    return (0);
d892 3
a894 2
    if (restore_cwd (&cwd, NULL))
	error_exit ();
d898 1
a898 1
    return (0);
d901 2
d908 2
a909 7
build_entry (repository, user, options, message, entries, tag)
    char *repository;
    char *user;
    char *options;
    char *message;
    List *entries;
    char *tag;
d916 1
a916 1
	return (0);
d941 1
a941 1
    return (0);
d943 5
@


1.2
log
@first step of merging new cvs
XXX might not compile
XXX might not work
XXX might contain bugs
XXX definitively needs autoconf 2.58 first
@
text
@d153 1
a153 1
	int j;
a169 1
	send_arg ("--");
d182 1
a182 1
	for (j = 0; j < argc; ++j)
d197 1
a197 1
	    if (isdir (argv[j]))
d212 1
a212 1
		filedir = xstrdup (argv[j]);
d248 1
a248 1
		Create_Admin (p, argv[j], rcsdir, tag, date,
d265 1
a265 1
		    Subdir_Register ((List *) NULL, (char *) NULL, argv[j]);
d292 3
d342 54
a400 1

d521 1
a521 1
re-adding file `%s' (in place of dead revision %s)",
d577 2
a578 1
		    char *tmp = xmalloc( strlen( vers->vn_user ) );
a580 2
		    free( tmp );
		    tmp = xmalloc( strlen( finfo.file ) + 13 );
d645 4
d739 1
a739 2
    (void) sprintf (message, "Directory %s added to the repository\n",
		    rcsdir);
d822 1
a822 2
    if (!really_quiet)
	cvs_output (message, 0);
d827 1
a827 1
    return 0;
@


1.1
log
@Initial revision
@
text
@d153 1
a153 1
	int i;
d170 1
d183 1
a183 1
	for (i = 0; i < argc; ++i)
d198 1
a198 1
	    if (isdir (argv[i]))
d213 1
a213 1
		filedir = xstrdup (argv[i]);
d249 1
a249 1
		Create_Admin (p, argv[i], rcsdir, tag, date,
d266 1
a266 1
		    Subdir_Register ((List *) NULL, (char *) NULL, argv[i]);
a292 3
#if defined (SERVER_SUPPORT) && !defined (FILENAMES_CASE_INSENSITIVE)
	char *found_name;
#endif
a339 54
#if defined (SERVER_SUPPORT) && !defined (FILENAMES_CASE_INSENSITIVE)
	if (ign_case)
	{
	    /* Need to check whether there is a directory with the
	       same name but different case.  We'll check for files
	       with the same name later (when Version_TS calls
	       RCS_parse which calls fopen_case).  If CVS some day
	       records directories in the RCS files, then we should be
	       able to skip the separate check here, which would be
	       cleaner.  */
	    DIR *dirp;
	    struct dirent *dp;

	    dirp = CVS_OPENDIR (finfo.repository);
	    if (dirp == NULL)
		error (1, errno, "cannot read directory %s", finfo.repository);
	    found_name = NULL;
	    errno = 0;
	    while ((dp = CVS_READDIR (dirp)) != NULL)
	    {
		if (cvs_casecmp (dp->d_name, finfo.file) == 0)
		{
		    if (found_name != NULL)
			error (1, 0, "%s is ambiguous; could mean %s or %s",
			       finfo.file, dp->d_name, found_name);
		    found_name = xstrdup (dp->d_name);
		}
	    }
	    if (errno != 0)
		error (1, errno, "cannot read directory %s", finfo.repository);
	    CVS_CLOSEDIR (dirp);

	    if (found_name != NULL)
	    {
		/* OK, we are about to patch up the name, so patch up
		   the temporary directory too to match.  The isdir
		   should "always" be true (since files have ,v), but
		   I guess we might as well make some attempt to not
		   get confused by stray files in the repository.  */
		if (isdir (finfo.file))
		{
		    if (CVS_MKDIR (found_name, 0777) < 0
			&& errno != EEXIST)
			error (0, errno, "cannot create %s", finfo.file);
		}

		/* OK, we found a directory with the same name, maybe in
		   a different case.  Treat it as if the name were the
		   same.  */
		finfo.file = found_name;
	    }
	}
#endif

d345 1
d466 1
a466 1
re-adding file %s (in place of dead revision %s)",
d522 1
a522 2
		    char *tmp = xmalloc (strlen (finfo.file) + 50);

d525 2
a590 4
#if defined (SERVER_SUPPORT) && !defined (FILENAMES_CASE_INSENSITIVE)
	if (ign_case && found_name != NULL)
	    free (found_name);
#endif
d681 2
a682 1
    (void) sprintf (message, "Directory %s added to the repository\n", rcsdir);
d765 2
a766 1
    cvs_output (message, 0);
d771 1
a771 1
    return (0);
@


1.1.2.1
log
@vendor-branch-ify new cvs 1.12
@
text
@a26 1
#include <assert.h>
d28 1
a28 1
#include "save-cwd.h"
d31 3
a33 4
static int add_directory (struct file_info *finfo);
static int build_entry (const char *repository, const char *user,
                        const char *options, const char *message,
                        List * entries, const char *tag);
d45 3
a47 1
add (int argc, char **argv)
d124 1
a124 1
		if (ISSLASH (*p))
d153 1
a153 1
	int j;
a169 1
	send_arg ("--");
d182 1
a182 1
	for (j = 0; j < argc; ++j)
d187 11
a197 1
	    if (isdir (argv[j]))
d210 1
a210 1
		    error (1, errno, "Failed to save current directory.");
d212 2
a213 5
		filedir = xstrdup (argv[j]);
                /* Deliberately discard the const below since we know we just
                 * allocated filedir and can do what we like with it.
                 */
		p = (char *)last_component (filedir);
d224 1
a224 1
			       "could not chdir to `%s'", update_dir);
d232 1
a232 1
		    && ISSLASH (repository[cvsroot_len])
d236 1
a236 1
		    && ISSLASH (repository[cvsroot_len + sizeof CVSROOTADM])
d239 1
a239 1
		    error (1, 0, "cannot add to `%s'", repository);
d248 1
a248 1
		Create_Admin (p, argv[j], rcsdir, tag, date,
d254 2
a255 4
		if (restore_cwd (&cwd))
		    error (1, errno,
		           "Failed to restore current directory, `%s'.",
		           cwd.name);
d265 1
a265 1
		    Subdir_Register ((List *) NULL, (char *) NULL, argv[j]);
d291 4
a294 1
	char *filename, *p;
d299 1
a299 1
	    error (1, errno, "Failed to save current directory.");
d302 2
a303 6
	filename = xstrdup (argv[i]);
	/* We know we can discard the const below since we just allocated
	 * filename and can do as we like with it.
         */
	p = (char *)last_component (filename);
	if (p == filename)
d311 1
a311 1
	    finfo.update_dir = filename;
d314 1
a314 1
		error (1, errno, "could not chdir to `%s'", finfo.update_dir);
d327 2
a328 3
	if (strncmp (repository, current_parsed_root->directory,
		     cvsroot_len) == 0
	    && ISSLASH (repository[cvsroot_len])
d332 1
a332 1
	    && ISSLASH (repository[cvsroot_len + sizeof CVSROOTADM])
d335 1
a335 1
	    error (1, 0, "cannot add to `%s'", repository);
d342 54
d410 1
a410 1
		    error (0, 0, "nothing known about `%s'", finfo.fullname);
d431 1
a431 1
			error (1, 0, "invalid filename overlap");
d452 1
a452 1
				"cannot add file on non-branch tag `%s'",
d468 2
a469 2
				    error (0, 0, "scheduling %s `%s' for"
					   " addition on branch `%s'",
d493 4
a496 4
		    error (0, 0,
			   "the directory `%s' cannot be added because a file"
			   " of the", finfo.fullname);
		    error (1, 0, "same name already exists in the repository.");
d503 1
a503 1
			       "cannot add file on non-branch tag `%s'",
a508 63
			char *timestamp = NULL;
			if (vers->ts_user == NULL)
			{
			    /* If this file does not exist locally, assume that
			     * the last version on the branch is being
			     * resurrected.
			     *
			     * Compute previous revision.  We assume that it
			     * exists and that it is not a revision on the
			     * trunk of the form X.1 (1.1, 2.1, 3.1, ...).  We
			     * also assume that it is not dead, which seems
			     * fair since we know vers->vn_rcs is dead
			     * and we shouldn't see two dead revisions in a
			     * row.
			     */
			    char *prev = previous_rev (vers->srcfile,
			                               vers->vn_rcs);
			    int status;
			    if (prev == NULL)
			    {
				/* There is no previous revision.  Either:
				 *
				 *  * Revision 1.1 was dead, as when a file was
				 *    inititially added on a branch, 
				 *
				 * or
				 *
				 *  * All previous revisions have been deleted.
				 *    For instance, via `admin -o'.
				 */
				if (!really_quiet)
				    error (0, 0,
"File `%s' has no previous revision to resurrect.",
			                   finfo.fullname);
				free (prev);
				goto skip_this_file;
			    }
			    if (!quiet)
				error (0, 0,
"Resurrecting file `%s' from revision %s.",
			               finfo.fullname, prev);
			    status = RCS_checkout (vers->srcfile, finfo.file,
						   prev, vers->tag,
						   vers->options, RUN_TTY,
			                           NULL, NULL);
			    xchmod (finfo.file, 1);
			    if (status != 0)
			    {
				error (0, 0, "Failed to resurrect revision %s",
				       prev);
				err++;
			    }
			    else
			    {
				/* I don't actually set vers->ts_user here
				 * because it would confuse server_update().
				 */
				timestamp = time_stamp (finfo.file);
				if (!really_quiet)
				    write_letter (&finfo, 'U');
			    }
			    free (prev);
			}
a510 1
			    char *bbuf;
d512 3
a514 4
			    {
				bbuf = xmalloc (strlen (vers->tag) + 14);
				sprintf (bbuf, " on branch `%s'", vers->tag);
			    }
d516 7
a522 6
				bbuf = "";
			    error (0, 0,
"Re-adding file `%s'%s after dead revision %s.",
				   finfo.fullname, bbuf, vers->vn_rcs);
			    if (vers->tag)
				free (bbuf);
d524 3
a526 23
			Register (entries, finfo.file, "0",
				  timestamp ? timestamp : vers->ts_user,
				  vers->options, vers->tag, vers->date, NULL);
			if (timestamp) free (timestamp);
#ifdef SERVER_SUPPORT
			if (server_active && vers->ts_user == NULL)
			{
			    /* If we resurrected the file from the archive, we
			     * need to tell the client about it.
			     */
			    server_updated (&finfo, vers,
					    SERVER_UPDATED,
					    (mode_t) -1, NULL, NULL);
			    /* This is kinda hacky or, at least, it renders the
			     * name "begin_added_files" obsolete, but we want
			     * the added_files to be counted without triggering
			     * the check that causes server_checked_in() to be
			     * called below since we have already called
			     * server_updated() to complete the resurrection.
			     */
			    ++begin_added_files;
			}
#endif
d537 1
a537 1
		error (0, 0, "`%s' added independently by second party",
d550 1
a550 1
		error (0, 0, "`%s' has already been entered", finfo.fullname);
d566 2
a567 3
		    error (0, 0,
			   "cannot resurrect `%s'; RCS file removed by"
			   " second party", finfo.fullname);
d572 1
a572 1
		    int status;
d577 2
a578 1
		    char *tmp = xmalloc (strlen (vers->vn_user));
d581 11
a591 7
		    free( tmp );
		    status = RCS_checkout (vers->srcfile, finfo.file,
					   vers->vn_user, vers->tag,
					   vers->options, RUN_TTY,
					   NULL, NULL);
		    xchmod (finfo.file, cvswrite);
		    if (status != 0)
d593 2
a594 1
			error (0, 0, "Failed to resurrect revision %s.",
a595 2
			err++;
			tmp = NULL;
d599 2
a600 22
			/* I don't actually set vers->ts_user here because it
			 * would confuse server_update().
			 */
			tmp = time_stamp (finfo.file);
			write_letter (&finfo, 'U');
			if (!quiet)
			     error (0, 0, "`%s', version %s, resurrected",
			            finfo.fullname, vers->vn_user);
		    }
		    Register (entries, finfo.file, vers->vn_user,
                              tmp, vers->options,
			      vers->tag, vers->date, NULL);
		    if (tmp) free (tmp);
#ifdef SERVER_SUPPORT
		    if (server_active)
		    {
			/* If we resurrected the file from the archive, we
			 * need to tell the client about it.
			 */
			server_updated (&finfo, vers,
					SERVER_UPDATED,
					(mode_t) -1, NULL, NULL);
a601 4
		   /* We don't increment added_files here because this isn't
		    * a change that needs to be committed.
		    */
#endif
d608 1
a608 1
`%s' should be removed and is still there (or is back again)", finfo.fullname);
d616 1
a616 1
		error (0, 0, "`%s' already exists, with version number %s",
a636 2

skip_this_file:
d640 2
a641 3
	if (restore_cwd (&cwd))
	    error (1, errno, "Failed to restore current directory, `%s'.",
	           cwd.name);
d644 5
a648 5
	/* It's okay to discard the const to free this - we allocated this
	 * above.  The const is for everybody else.
	 */
	free ((char *) finfo.fullname);
	free (filename);
d651 1
a651 1
	error (0, 0, "use `%s commit' to add %s permanently",
d660 1
a660 1
    return err;
a662 2


d671 2
a672 1
add_directory (struct file_info *finfo)
d674 1
a674 1
    const char *repository = finfo->repository;
d676 1
a676 1
    const char *dir = finfo->file;
d690 1
a690 1
	return 1;
d695 1
a695 1
	return 1;
d709 2
a710 5
    {
	error (0, errno, "Failed to save current directory.");
	return 1;
    }
    if (CVS_CHDIR (dir) < 0)
d713 1
a713 1
	return 1;
d736 4
a739 5
		       + 36
		       + (tag == NULL ? 0 : strlen (tag) + 38)
		       + (date == NULL ? 0 : strlen (date) + 39));
    (void) sprintf (message, "Directory %s added to the repository\n",
		    rcsdir);
d801 1
a801 1
	p->data = li;
d808 1
a808 3
    if (server_active)
	WriteTemplate (finfo->fullname, 1, rcsdir);
    else
d810 1
a810 2
	Create_Admin (".", finfo->fullname, rcsdir, tag, date, nonbranch, 0, 1);

d816 2
a817 3
    if (restore_cwd (&cwd))
	error (1, errno, "Failed to restore current directory, `%s'.",
	       cwd.name);
d822 1
a822 2
    if (!really_quiet)
	cvs_output (message, 0);
d827 1
a827 1
    return 0;
d830 2
a831 3
    if (restore_cwd (&cwd))
	error (1, errno, "Failed to restore current directory, `%s'.",
	       cwd.name);
d835 1
a835 1
    return 0;
a837 2


d843 7
a849 2
build_entry (const char *repository, const char *user, const char *options,
             const char *message, List *entries, const char *tag)
d856 1
a856 1
	return 0;
d881 1
a881 1
    return 0;
a882 5



/* vim:tabstop=8:shiftwidth=4
 */
@


1.1.3.1
log
@our CVS is currently at 1.11.1p1, thus import that version into vendor branch
@
text
@@


1.1.3.2
log
@CVS 1.11.12 is the latest stable version of CVS,
released 06.02.2004, with a huge lot of bug fixes.

/me hopes this will pay off...
@
text
@d153 1
a153 1
	int j;
a169 1
	send_arg ("--");
d182 1
a182 1
	for (j = 0; j < argc; ++j)
d197 1
a197 1
	    if (isdir (argv[j]))
d212 1
a212 1
		filedir = xstrdup (argv[j]);
d248 1
a248 1
		Create_Admin (p, argv[j], rcsdir, tag, date,
d265 1
a265 1
		    Subdir_Register ((List *) NULL, (char *) NULL, argv[j]);
d292 3
d342 54
a400 1

d521 1
a521 1
re-adding file `%s' (in place of dead revision %s)",
d577 2
a578 1
		    char *tmp = xmalloc( strlen( vers->vn_user ) );
a580 2
		    free( tmp );
		    tmp = xmalloc( strlen( finfo.file ) + 13 );
d645 4
d739 1
a739 2
    (void) sprintf (message, "Directory %s added to the repository\n",
		    rcsdir);
d822 1
a822 2
    if (!really_quiet)
	cvs_output (message, 0);
d827 1
a827 1
    return 0;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
