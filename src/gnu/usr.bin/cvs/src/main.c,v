head	1.8;
access;
symbols
	cvs-1_12_11:1.1.2.2
	tg-mergetmp-mirosx-1:1.7
	tg-mergefixes-1-branch:1.7.0.4
	tg-mergefixes-1-base:1.7
	MIROS_X:1.7.0.2
	MIROS_X_BASE:1.7
	cvs-1_12_10:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_MIRPPC:1.4.0.4
	MIRBSD_XP_SPARC_BASE:1.4
	MIRBSD_XP_SPARC:1.4.0.2
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200404170130:1.1.1.1
	cvs-1_11_12:1.1.3.2
	cvs-1_11_1p1:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2005.01.08.21.31.31;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.03.20.10.45;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.02.12.40.18;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.28.02.02.02;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.19.18.01.33;	author tg;	state Stab;
branches;
next	1.3;

1.3
date	2004.02.22.13.49.15;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.12.21.16.16;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.31;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.41.31;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2004.12.02.11.58.57;	author tg;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.01.08.21.14.03;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.02.12.19.19.09;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.12.19.39.37;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@fastmerge
@
text
@/* $MirBSD: src/gnu/usr.bin/cvs/src/main.c,v 1.7 2004/12/03 20:10:45 tg Exp $ */

/*
 *    Copyright (c) 1992, Brian Berliner and Jeff Polk
 *    Copyright (c) 1989-1992, Brian Berliner
 *
 *    You may distribute under the terms of the GNU General Public License
 *    as specified in the README file that comes with the CVS source
 *    distribution.
 *
 * This is the main C driver for the CVS system.
 *
 * Credit to Dick Grune, Vrije Universiteit, Amsterdam, for writing
 * the shell-script CVS system that this is based on.
 *
 */

#include "cvs.h"
#include "xgethostname.h"
#include "strftime.h"

__RCSID("$MirBSD: src/gnu/usr.bin/cvs/src/main.c,v 1.7 2004/12/03 20:10:45 tg Exp $");

const char *program_name;
const char *program_path;
const char *cvs_cmd_name;

char *hostname;
#ifdef SERVER_SUPPORT
char *server_hostname;
#endif /* SERVER_SUPPORT */

int use_editor = 1;
int use_cvsrc = 1;
int cvswrite = !CVSREAD_DFLT;
int really_quiet = 0;
int quiet = 0;
int trace = 0;
int noexec = 0;
int readonlyfs = 0;
int logoff = 0;



/***
 ***
 ***   CVSROOT/config options
 ***
 ***/
struct config *config;



mode_t cvsumask = UMASK_DFLT;

char *CurDir;

/*
 * Defaults, for the environment variables that are not set
 */
char *Tmpdir = TMPDIR_DFLT;
char *Editor = EDITOR_DFLT;


/* When our working directory contains subdirectories with different
   values in CVS/Root files, we maintain a list of them.  */
List *root_directories = NULL;

static const struct cmd
{
    const char *fullname;	/* Full name of the function (e.g. "commit") */

    /* Synonyms for the command, nick1 and nick2.  We supply them
       mostly for two reasons: (1) CVS has always supported them, and
       we need to maintain compatibility, (2) if there is a need for a
       version which is shorter than the fullname, for ease in typing.
       Synonyms have the disadvantage that people will see "new" and
       then have to think about it, or look it up, to realize that is
       the operation they know as "add".  Also, this means that one
       cannot create a command "cvs new" with a different meaning.  So
       new synonyms are probably best used sparingly, and where used
       should be abbreviations of the fullname (preferably consisting
       of the first 2 or 3 or so letters).

       One thing that some systems do is to recognize any unique
       abbreviation, for example "annotat" "annota", etc., for
       "annotate".  The problem with this is that scripts and user
       habits will expect a certain abbreviation to be unique, and in
       a future release of CVS it may not be.  So it is better to
       accept only an explicit list of abbreviations and plan on
       supporting them in the future as well as now.  */

    const char *nick1;
    const char *nick2;

    int (*func) (int, char **);	/* Function takes (argc, argv) arguments. */
    unsigned long attr;		/* Attributes. */
} cmds[] =

{
    { "add",      "ad",       "new",       add,       CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "admin",    "adm",      "rcs",       admin,     CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "annotate", "ann",      NULL,        annotate,  CVS_CMD_USES_WORK_DIR },
    { "checkout", "co",       "get",       checkout,  0 },
    { "commit",   "ci",       "com",       commit,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "diff",     "di",       "dif",       diff,      CVS_CMD_USES_WORK_DIR },
    { "edit",     NULL,       NULL,        edit,      CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "editors",  NULL,       NULL,        editors,   CVS_CMD_USES_WORK_DIR },
    { "export",   "exp",      "ex",        checkout,  CVS_CMD_USES_WORK_DIR },
    { "history",  "hi",       "his",       history,   CVS_CMD_USES_WORK_DIR },
    { "import",   "im",       "imp",       import,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR | CVS_CMD_IGNORE_ADMROOT},
    { "init",     NULL,       NULL,        init,      CVS_CMD_MODIFIES_REPOSITORY },
#if defined (HAVE_KERBEROS) && defined (SERVER_SUPPORT)
    { "kserver",  NULL,       NULL,        server,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR }, /* placeholder */
#endif
    { "log",      "lo",       NULL,        cvslog,    CVS_CMD_USES_WORK_DIR },
#ifdef AUTH_CLIENT_SUPPORT
    { "login",    "logon",    "lgn",       login,     0 },
    { "logout",   NULL,       NULL,        logout,    0 },
#endif /* AUTH_CLIENT_SUPPORT */
    { "ls",       "dir",      "list",      ls,        0 },
#if (defined(AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)) && defined(SERVER_SUPPORT)
    { "pserver",  NULL,       NULL,        server,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR }, /* placeholder */
#endif
    { "rannotate","rann",     "ra",        annotate,  0 },
    { "rdiff",    "patch",    "pa",        patch,     0 },
    { "release",  "re",       "rel",       release,   CVS_CMD_MODIFIES_REPOSITORY },
    { "remove",   "rm",       "delete",    cvsremove, CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "rlog",     "rl",       NULL,        cvslog,    0 },
    { "rls",      "rdir",     "rlist",     ls,        0 },
    { "rtag",     "rt",       "rfreeze",   cvstag,    CVS_CMD_MODIFIES_REPOSITORY },
#ifdef SERVER_SUPPORT
    { "server",   NULL,       NULL,        server,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
#endif
    { "status",   "st",       "stat",      cvsstatus, CVS_CMD_USES_WORK_DIR },
    { "tag",      "ta",       "freeze",    cvstag,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "unedit",   NULL,       NULL,        unedit,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "update",   "up",       "upd",       update,    CVS_CMD_USES_WORK_DIR },
    { "version",  "ve",       "ver",       version,   0 },
    { "watch",    NULL,       NULL,        watch,     CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "watchers", NULL,       NULL,        watchers,  CVS_CMD_USES_WORK_DIR },
    { NULL, NULL, NULL, NULL, 0 },
};

static const char *const usg[] =
{
    /* CVS usage messages never have followed the GNU convention of
       putting metavariables in uppercase.  I don't know whether that
       is a good convention or not, but if it changes it would have to
       change in all the usage messages.  For now, they consistently
       use lowercase, as far as I know.  Punctuation is pretty funky,
       though.  Sometimes they use none, as here.  Sometimes they use
       single quotes (not the TeX-ish `' stuff), as in --help-options.
       Sometimes they use double quotes, as in cvs -H add.

       Most (not all) of the usage messages seem to have periods at
       the end of each line.  I haven't tried to duplicate this style
       in --help as it is a rather different format from the rest.  */

    "Usage: %s [cvs-options] command [command-options-and-arguments]\n",
    "  where cvs-options are -q, -n, etc.\n",
    "    (specify --help-options for a list of options)\n",
    "  where command is add, admin, etc.\n",
    "    (specify --help-commands for a list of commands\n",
    "     or --help-synonyms for a list of command synonyms)\n",
    "  where command-options-and-arguments depend on the specific command\n",
    "    (specify -H followed by a command name for command-specific help)\n",
    "  Specify --help to receive this message\n",
    "\n",

    /* Some people think that a bug-reporting address should go here.  IMHO,
       the web sites are better because anything else is very likely to go
       obsolete in the years between a release and when someone might be
       reading this help.  Besides, we could never adequately discuss
       bug reporting in a concise enough way to put in a help message.  */

    /* I was going to put this at the top, but usage() wants the %s to
       be in the first line.  */
    "The Concurrent Versions System (CVS) is a tool for version control.\n",
    /* I really don't think I want to try to define "version control"
       in one line.  I'm not sure one can get more concise than the
       paragraph in ../cvs.spec without assuming the reader knows what
       version control means.  */

    "For CVS updates and additional information, see\n",
    "    the CVS home page at http://www.cvshome.org/ or\n",
    "    the CVSNT home page at http://www.cvsnt.org/\n",
    NULL,
};

static const char *const cmd_usage[] =
{
    "CVS commands are:\n",
    "        add          Add a new file/directory to the repository\n",
    "        admin        Administration front end for rcs\n",
    "        annotate     Show last revision where each line was modified\n",
    "        checkout     Checkout sources for editing\n",
    "        commit       Check files into the repository\n",
    "        diff         Show differences between revisions\n",
    "        edit         Get ready to edit a watched file\n",
    "        editors      See who is editing a watched file\n",
    "        export       Export sources from CVS, similar to checkout\n",
    "        history      Show repository access history\n",
    "        import       Import sources into CVS, using vendor branches\n",
    "        init         Create a CVS repository if it doesn't exist\n",
#if defined (HAVE_KERBEROS) && defined (SERVER_SUPPORT)
    "        kserver      Kerberos server mode\n",
#endif
    "        log          Print out history information for files\n",
#ifdef AUTH_CLIENT_SUPPORT
    "        login        Prompt for password for authenticating server\n",
    "        logout       Removes entry in .cvspass for remote repository\n",
#endif /* AUTH_CLIENT_SUPPORT */
    "        ls           List files available from CVS\n",
#if (defined(AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)) && defined(SERVER_SUPPORT)
    "        pserver      Password server mode\n",
#endif
    "        rannotate    Show last revision where each line of module was modified\n",
    "        rdiff        Create 'patch' format diffs between releases\n",
    "        release      Indicate that a Module is no longer in use\n",
    "        remove       Remove an entry from the repository\n",
    "        rlog         Print out history information for a module\n",
    "        rls          List files in a module\n",
    "        rtag         Add a symbolic tag to a module\n",
#ifdef SERVER_SUPPORT
    "        server       Server mode\n",
#endif
    "        status       Display status information on checked out files\n",
    "        tag          Add a symbolic tag to checked out version of files\n",
    "        unedit       Undo an edit command\n",
    "        update       Bring work tree in sync with repository\n",
    "        version      Show current CVS version(s)\n",
    "        watch        Set watches\n",
    "        watchers     See who is watching a file\n",
    "(Specify the --help option for a list of other help options)\n",
    NULL,
};

static const char *const opt_usage[] =
{
    /* Omit -b because it is just for compatibility.  */
    "CVS global options (specified before the command name) are:\n",
    "    -H           Displays usage information for command.\n",
    "    -Q           Cause CVS to be really quiet.\n",
    "    -q           Cause CVS to be somewhat quiet.\n",
    "    -r           Make checked-out files read-only.\n",
    "    -w           Make checked-out files read-write (default).\n",
    "    -n           Do not execute anything that will change the disk.\n",
    "    -t           Show trace of program execution (repeat for more\n",
    "                 verbosity) -- try with -n.\n",
    "    -R           Assume repository is read-only, such as CDROM\n",
    "    -v           CVS version and copyright.\n",
    "    -T tmpdir    Use 'tmpdir' for temporary files.\n",
    "    -e editor    Use 'editor' for editing log information.\n",
    "    -d CVS_root  Overrides $CVSROOT as the root of the CVS tree.\n",
    "    -f           Do not use the ~/.cvsrc file.\n",
#ifdef CLIENT_SUPPORT
    "    -z #         Use compression level '#' for net traffic.\n",
#ifdef ENCRYPTION
    "    -x           Encrypt all net traffic.\n",
#endif
    "    -a           Authenticate all net traffic.\n",
#endif
    "    -s VAR=VAL   Set CVS user variable.\n",
    "(Specify the --help option for a list of other help options)\n",
    NULL
};


static int
set_root_directory (Node *p, void *ignored)
{
    if (current_parsed_root == NULL && p->data != NULL)
    {
	current_parsed_root = p->data;
	original_parsed_root = current_parsed_root;
	return 1;
    }
    return 0;
}


static const char * const*
cmd_synonyms (void)
{
    char ** synonyms;
    char ** line;
    const struct cmd *c = &cmds[0];
    /* Three more for title, "specify --help" line, and NULL.  */
    int numcmds = 3;

    while (c->fullname != NULL)
    {
	numcmds++;
	c++;
    }

    synonyms = (char **) xmalloc(numcmds * sizeof(char *));
    line = synonyms;
    *line++ = "CVS command synonyms are:\n";
    for (c = &cmds[0]; c->fullname != NULL; c++)
    {
	if (c->nick1 || c->nick2)
	{
	    *line = xmalloc (strlen (c->fullname)
			     + (c->nick1 != NULL ? strlen (c->nick1) : 0)
			     + (c->nick2 != NULL ? strlen (c->nick2) : 0)
			     + 40);
	    sprintf(*line, "        %-12s %s %s\n", c->fullname,
		    c->nick1 ? c->nick1 : "",
		    c->nick2 ? c->nick2 : "");
	    line++;
	}
    }
    *line++ = "(Specify the --help option for a list of other help options)\n";
    *line = NULL;

    return (const char * const*) synonyms; /* will never be freed */
}



unsigned long int
lookup_command_attribute (const char *cmd_name)
{
    const struct cmd *cm;

    for (cm = cmds; cm->fullname; cm++)
    {
	if (strcmp (cmd_name, cm->fullname) == 0)
	    break;
    }
    if (!cm->fullname)
	error (1, 0, "unknown command: %s", cmd_name);
    return cm->attr;
}



/*
 * Exit with an error code and an informative message about the signal
 * received.  This function, by virtue of causing an actual call to exit(),
 * causes all the atexit() handlers to be called.
 *
 * INPUTS
 *   sig	The signal recieved.
 *
 * ERRORS
 *   The cleanup routines registered via atexit() and the error function
 *   itself can potentially change the exit status.  They shouldn't do this
 *   unless they encounter problems doing their own jobs.
 *
 * RETURNS
 *   Nothing.  This function will always exit.  It should exit with an exit
 *   status of 1, but might not, as noted in the ERRORS section above.
 */
#ifndef DONT_USE_SIGNALS
static RETSIGTYPE main_cleanup (int) __attribute__ ((__noreturn__));
#endif /* DONT_USE_SIGNALS */
static RETSIGTYPE
main_cleanup (int sig)
{
#ifndef DONT_USE_SIGNALS
    const char *name;
    char temp[10];

    switch (sig)
    {
#ifdef SIGABRT
    case SIGABRT:
	name = "abort";
	break;
#endif
#ifdef SIGHUP
    case SIGHUP:
	name = "hangup";
	break;
#endif
#ifdef SIGINT
    case SIGINT:
	name = "interrupt";
	break;
#endif
#ifdef SIGQUIT
    case SIGQUIT:
	name = "quit";
	break;
#endif
#ifdef SIGPIPE
    case SIGPIPE:
	name = "broken pipe";
	break;
#endif
#ifdef SIGTERM
    case SIGTERM:
	name = "termination";
	break;
#endif
    default:
	/* This case should never be reached, because we list above all
	   the signals for which we actually establish a signal handler.  */
	sprintf (temp, "%d", sig);
	name = temp;
	break;
    }

    /* This always exits, which will cause our exit handlers to be called.  */
    error (1, 0, "received %s signal", name);
    /* but make the exit explicit to silence warnings when gcc processes the
     * noreturn attribute.
     */
    exit (EXIT_FAILURE);
#endif /* !DONT_USE_SIGNALS */
}



int
main (int argc, char **argv)
{
    cvsroot_t *CVSroot_parsed = NULL;
    bool cvsroot_update_env = true;
    char *cp, *end;
    const struct cmd *cm;
    int c, err = 0;
    int tmpdir_update_env;
    int free_Editor = 0;
    int free_Tmpdir = 0;

    int help = 0;		/* Has the user asked for help?  This
				   lets us support the `cvs -H cmd'
				   convention to give help for cmd. */
    static const char short_options[] = "+QqrwtnRvb:T:e:d:Hfz:s:xa";
    static struct option long_options[] =
    {
        {"help", 0, NULL, 'H'},
        {"version", 0, NULL, 'v'},
	{"help-commands", 0, NULL, 1},
	{"help-synonyms", 0, NULL, 2},
	{"help-options", 0, NULL, 4},
#ifdef SERVER_SUPPORT
	{"allow-root", required_argument, NULL, 3},
#endif /* SERVER_SUPPORT */
        {0, 0, 0, 0}
    };
    /* `getopt_long' stores the option index here, but right now we
        don't use it. */
    int option_index = 0;

#ifdef SYSTEM_INITIALIZE
    /* Hook for OS-specific behavior, for example socket subsystems on
       NT and OS2 or dealing with windows and arguments on Mac.  */
    SYSTEM_INITIALIZE (&argc, &argv);
#endif

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	cleanup_register (SYSTEM_CLEANUP);
#endif

#ifdef HAVE_TZSET
    /* On systems that have tzset (which is almost all the ones I know
       of), it's a good idea to call it.  */
    tzset ();
#endif

    /*
     * Just save the last component of the path for error messages
     */
    program_path = xstrdup (argv[0]);
#ifdef ARGV0_NOT_PROGRAM_NAME
    /* On some systems, e.g. VMS, argv[0] is not the name of the command
       which the user types to invoke the program.  */
    program_name = "cvs";
#else
    program_name = last_component (argv[0]);
#endif

    /*
     * Query the environment variables up-front, so that
     * they can be overridden by command line arguments
     */
    tmpdir_update_env = *Tmpdir;	/* TMPDIR_DFLT must be set */
    if ((cp = getenv (TMPDIR_ENV)) != NULL)
    {
	Tmpdir = cp;
	tmpdir_update_env = 0;		/* it's already there */
    }
    if ((cp = getenv (EDITOR1_ENV)) != NULL)
 	Editor = cp;
    else if ((cp = getenv (EDITOR2_ENV)) != NULL)
	Editor = cp;
    else if ((cp = getenv (EDITOR3_ENV)) != NULL)
	Editor = cp;
    if (getenv (CVSREAD_ENV) != NULL)
	cvswrite = 0;
    if (getenv (CVSREADONLYFS_ENV) != NULL) {
	readonlyfs = 1;
	logoff = 1;
    }

    /* Set this to 0 to force getopt initialization.  getopt() sets
       this to 1 internally.  */
    optind = 0;

    /* We have to parse the options twice because else there is no
       chance to avoid reading the global options from ".cvsrc".  Set
       opterr to 0 for avoiding error messages about invalid options.
       */
    opterr = 0;

    while ((c = getopt_long
            (argc, argv, short_options, long_options, &option_index))
           != EOF)
    {
	if (c == 'f')
	    use_cvsrc = 0;
    }

    /*
     * Scan cvsrc file for global options.
     */
    if (use_cvsrc)
	read_cvsrc (&argc, &argv, "cvs");

    optind = 0;
    opterr = 1;

    while ((c = getopt_long
            (argc, argv, short_options, long_options, &option_index))
           != EOF)
    {
	switch (c)
	{
            case 1:
	        /* --help-commands */
                usage (cmd_usage);
                break;
            case 2:
	        /* --help-synonyms */
                usage (cmd_synonyms());
                break;
	    case 4:
		/* --help-options */
		usage (opt_usage);
		break;
#ifdef SERVER_SUPPORT
	    case 3:
		/* --allow-root */
		root_allow_add (optarg);
		break;
#endif /* SERVER_SUPPORT */
	    case 'Q':
		really_quiet = 1;
		/* FALL THROUGH */
	    case 'q':
		quiet = 1;
		break;
	    case 'r':
		cvswrite = 0;
		break;
	    case 'w':
		cvswrite = 1;
		break;
	    case 't':
		trace++;
		break;
	    case 'R':
		readonlyfs = -1;
		logoff = 1;
		break;
	    case 'n':
		noexec = 1;
		logoff = 1;
		break;
	    case 'v':
		fputs ("\n", stdout);
		version (0, NULL);
		fputs (
"\n"
"Copyright (c) 1989-2004 Brian Berliner, david d `zoo' zuhn,\n"
"                        Jeff Polk, and other authors\n"
"\n"
"CVS may be copied only under the terms of the GNU General Public License,\n"
"a copy of which can be found with the CVS distribution kit.\n"
"\n"
"Specify the --help option for further information about CVS\n", stdout);

		exit (0);
		break;
	    case 'b':
		/* This option used to specify the directory for RCS
		   executables.  But since we don't run them any more,
		   this is a noop.  Silently ignore it so that .cvsrc
		   and scripts and inetd.conf and such can work with
		   either new or old CVS.  */
		break;
	    case 'T':
		if (free_Tmpdir) free (Tmpdir);
		Tmpdir = xstrdup (optarg);
		free_Tmpdir = 1;
		tmpdir_update_env = 1;	/* need to update environment */
		break;
	    case 'e':
		if (free_Editor) free (Editor);
		Editor = xstrdup (optarg);
		free_Editor = 1;
		break;
	    case 'd':
		if (CVSroot_cmdline != NULL)
		    free (CVSroot_cmdline);
		CVSroot_cmdline = xstrdup (optarg);
		break;
	    case 'H':
	        help = 1;
		break;
            case 'f':
		use_cvsrc = 0; /* unnecessary, since we've done it above */
		break;
	    case 'z':
#ifdef CLIENT_SUPPORT
		gzip_level = strtol (optarg, &end, 10);
		if (*end != '\0' || gzip_level < 0 || gzip_level > 9)
		  error (1, 0,
			 "gzip compression level must be between 0 and 9");
#endif /* CLIENT_SUPPORT */
		/* If no CLIENT_SUPPORT, we just silently ignore the gzip
		 * level, so that users can have it in their .cvsrc and not
		 * cause any trouble.
		 *
		 * We still parse the argument to -z for correctness since
		 * one user complained of being bitten by a run of
		 * `cvs -z -n up' which read -n as the argument to -z without
		 * complaining.  */
		break;
	    case 's':
		variable_set (optarg);
		break;
	    case 'x':
#ifdef CLIENT_SUPPORT
	        cvsencrypt = 1;
#endif /* CLIENT_SUPPORT */
		/* If no CLIENT_SUPPORT, ignore -x, so that users can
                   have it in their .cvsrc and not cause any trouble.
                   If no ENCRYPTION, we still accept -x, but issue an
                   error if we are being run as a client.  */
		break;
	    case 'a':
#ifdef CLIENT_SUPPORT
		cvsauthenticate = 1;
#endif
		/* If no CLIENT_SUPPORT, ignore -a, so that users can
                   have it in their .cvsrc and not cause any trouble.
                   We will issue an error later if stream
                   authentication is not supported.  */
		break;
	    case '?':
	    default:
                usage (usg);
	}
    }

    argc -= optind;
    argv += optind;
    if (argc < 1)
	usage (usg);

    /* Look up the command name. */

    cvs_cmd_name = argv[0];
    for (cm = cmds; cm->fullname; cm++)
    {
	if (cm->nick1 && !strcmp (cvs_cmd_name, cm->nick1))
	    break;
	if (cm->nick2 && !strcmp (cvs_cmd_name, cm->nick2))
	    break;
	if (!strcmp (cvs_cmd_name, cm->fullname))
	    break;
    }

    if (!cm->fullname)
    {
	fprintf (stderr, "Unknown command: `%s'\n\n", cvs_cmd_name);
	usage (cmd_usage);
    }
    else
	cvs_cmd_name = cm->fullname;	/* Global pointer for later use */

    if (help)
    {
	argc = -1;		/* some functions only check for this */
	err = (*(cm->func)) (argc, argv);
    }
    else
    {
	/* The user didn't ask for help, so go ahead and authenticate,
           set up CVSROOT, and the rest of it. */

	short int lock_cleanup_setup = 0;

	/* The UMASK environment variable isn't handled with the
	   others above, since we don't want to signal errors if the
	   user has asked for help.  This won't work if somebody adds
	   a command-line flag to set the umask, since we'll have to
	   parse it before we get here. */

	if ((cp = getenv (CVSUMASK_ENV)) != NULL)
	{
	    /* FIXME: Should be accepting symbolic as well as numeric mask.  */
	    cvsumask = strtol (cp, &end, 8) & 0777;
	    if (*end != '\0')
		error (1, errno, "invalid umask value in %s (%s)",
		       CVSUMASK_ENV, cp);
	}

#ifdef SERVER_SUPPORT

# ifdef HAVE_KERBEROS
	/* If we are invoked with a single argument "kserver", then we are
	   running as Kerberos server as root.  Do the authentication as
	   the very first thing, to minimize the amount of time we are
	   running as root.  */
	if (strcmp (cvs_cmd_name, "kserver") == 0)
	{
	    kserver_authenticate_connection ();

	    /* Pretend we were invoked as a plain server.  */
	    cvs_cmd_name = "server";
	}
# endif /* HAVE_KERBEROS */


# if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)
	if (strcmp (cvs_cmd_name, "pserver") == 0)
	{
	    /* The reason that --allow-root is not a command option
	       is mainly the comment in server() about how argc,argv
	       might be from .cvsrc.  I'm not sure about that, and
	       I'm not sure it is only true of command options, but
	       it seems easier to make it a global option.  */

	    /* Gets username and password from client, authenticates, then
	       switches to run as that user and sends an ACK back to the
	       client. */
	    pserver_authenticate_connection ();

	    /* Pretend we were invoked as a plain server.  */
	    cvs_cmd_name = "server";
	}
# endif /* AUTH_SERVER_SUPPORT || HAVE_GSSAPI */

	server_active = strcmp (cvs_cmd_name, "server") == 0;

#endif /* SERVER_SUPPORT */


#ifdef SERVER_SUPPORT
	if (server_active)
	{
	    /* This is only used for writing into the history file.  For
	       remote connections, it might be nice to have hostname
	       and/or remote path, on the other hand I'm not sure whether
	       it is worth the trouble.  */
	    CurDir = xstrdup ("<remote>");
	    cleanup_register (server_cleanup);
	}
	else
#endif
	{
	    CurDir = xgetcwd ();
            if (CurDir == NULL)
		error (1, errno, "cannot get working directory");
	}

	if (Tmpdir == NULL || Tmpdir[0] == '\0')
	    Tmpdir = "/tmp";

#ifdef HAVE_PUTENV
	if (tmpdir_update_env)
	{
	    char *env;
	    env = xmalloc (strlen (TMPDIR_ENV) + strlen (Tmpdir) + 1 + 1);
	    (void) sprintf (env, "%s=%s", TMPDIR_ENV, Tmpdir);
	    (void) putenv (env);
	    /* do not free env, as putenv has control of it */
	}
	{
	    char *env;
	    /* XXX pid < 10^32 */
	    env = xmalloc (strlen (CVS_PID_ENV) + 1 + 32 + 1);
	    (void) sprintf (env, "%s=%ld", CVS_PID_ENV, (long) getpid ());
	    (void) putenv (env);
	    /* do not free env, as putenv has control of it */
	}
#endif

	/* make sure we clean up on error */
	signals_register (main_cleanup);

	hostname = xgethostname();
#ifdef SERVER_SUPPORT
	/* Keep track of this separately since the client can change the
	 * hostname.
	 */
	if (server_active)
	    server_hostname = xstrdup (hostname);
#endif /* SERVER_SUPPORT */

#ifdef KLUDGE_FOR_WNT_TESTSUITE
	/* Probably the need for this will go away at some point once
	   we call fflush enough places (e.g. fflush (stdout) in
	   cvs_outerr).  */
	(void) setvbuf (stdout, (char *) NULL, _IONBF, 0);
	(void) setvbuf (stderr, (char *) NULL, _IONBF, 0);
#endif /* KLUDGE_FOR_WNT_TESTSUITE */

	if (use_cvsrc)
	    read_cvsrc (&argc, &argv, cvs_cmd_name);

#ifdef SERVER_SUPPORT
	/* Fiddling with CVSROOT doesn't make sense if we're running
	 * in server mode, since the client will send the repository
	 * directory after the connection is made.
	 */
	if (!server_active)
#endif
	{
	    /* First check if a root was set via the command line.  */
	    if (CVSroot_cmdline)
	    {
		 if (!(CVSroot_parsed = parse_cvsroot (CVSroot_cmdline)))
		     error (1, 0, "Bad CVSROOT: `%s'.", CVSroot_cmdline);
	    }

	    /* See if we are able to find a 'better' value for CVSroot
	     * in the CVSADM_ROOT directory.
	     *
	     * "cvs import" shouldn't check CVS/Root; in general it
	     * ignores CVS directories and CVS/Root is likely to
	     * specify a different repository than the one we are
	     * importing to, but if this is not import and no root was
	     * specified on the command line, set the root from the
	     * CVS/Root file.
	     */
	    if (!CVSroot_parsed
		&& !(cm->attr & CVS_CMD_IGNORE_ADMROOT)
	       )
		CVSroot_parsed = Name_Root (NULL, NULL);

	    /* Now, if there is no root on the command line and we didn't find
	     * one in a file, set it via the $CVSROOT env var.
	     */
	    if (!CVSroot_parsed)
	    {
		char *tmp = getenv (CVSROOT_ENV);
		if (tmp)
		{
		    if (!(CVSroot_parsed = parse_cvsroot (tmp)))
			error (1, 0, "Bad CVSROOT: `%s'.", tmp);
		    cvsroot_update_env = false;
		}
	    }

#ifdef CVSROOT_DFLT
	    if (!CVSroot_parsed)
	    {
		if (!(CVSroot_parsed = parse_cvsroot (CVSROOT_DFLT)))
		    error (1, 0, "Bad CVSROOT: `%s'.", CVSROOT_DFLT);
	    }
#endif /* CVSROOT_DFLT */

	    /* Now we've reconciled CVSROOT from the command line, the
	       CVS/Root file, and the environment variable.  Do the
	       last sanity checks on the variable. */
	    if (!CVSroot_parsed)
	    {
		error (0, 0,
		       "No CVSROOT specified!  Please use the `-d' option");
		error (1, 0,
		       "or set the %s environment variable.", CVSROOT_ENV);
	    }
	}

	/* Here begins the big loop over unique cvsroot values.  We
           need to call do_recursion once for each unique value found
           in CVS/Root.  Prime the list with the current value. */

	/* Create the list. */
	assert (root_directories == NULL);
	root_directories = getlist ();

	/* Prime it. */
	if (CVSroot_parsed)
	{
	    Node *n;
	    n = getnode ();
	    n->type = NT_UNKNOWN;
	    n->key = xstrdup (CVSroot_parsed->original);
	    n->data = CVSroot_parsed;

	    if (addnode (root_directories, n))
		error (1, 0, "cannot add initial CVSROOT %s", n->key);
	}

	assert (current_parsed_root == NULL);

	/* If we're running the server, we want to execute this main
	   loop once and only once (we won't be serving multiple roots
	   from this connection, so there's no need to do it more than
	   once).  To get out of the loop, we perform a "break" at the
	   end of things.  */

	while (
#ifdef SERVER_SUPPORT
	       server_active ||
#endif
	       walklist (root_directories, set_root_directory, NULL)
	       )
	{
#ifdef SERVER_SUPPORT
	    /* Fiddling with CVSROOT doesn't make sense if we're running
	       in server mode, since the client will send the repository
	       directory after the connection is made. */

	    if (!server_active)
#endif
	    {
		/* Now we're 100% sure that we have a valid CVSROOT
		   variable.  Parse it to see if we're supposed to do
		   remote accesses or use a special access method. */

		TRACE (TRACE_FUNCTION,
		       "main loop with CVSROOT=%s",
		       current_parsed_root ? current_parsed_root->directory
					   : "(null)");

		/*
		 * Check to see if the repository exists.
		 */
#ifdef CLIENT_SUPPORT
		if (!current_parsed_root->isremote)
#endif	/* CLIENT_SUPPORT */
		{
		    char *path;
		    int save_errno;

		    path = Xasprintf ("%s/%s", current_parsed_root->directory,
				      CVSROOTADM);
		    if (!isaccessible (path, R_OK | X_OK))
		    {
			save_errno = errno;
			/* If this is "cvs init", the root need not exist yet.
			 */
			if (strcmp (cvs_cmd_name, "init"))
			    error (1, save_errno, "%s", path);
		    }
		    free (path);
		}

#ifdef HAVE_PUTENV
		/* Update the CVSROOT environment variable.  */
		if (cvsroot_update_env)
		{
		    static char *prev;
		    char *env;

		    env = Xasprintf ("%s=%s", CVSROOT_ENV,
				     current_parsed_root->original);
		    (void) putenv (env);
		    /* do not free env yet, as putenv has control of it */
		    /* but do free the previous value, if any */
		    if (prev != NULL)
			free (prev);
		    prev = env;
		}
#endif
	    }

	    /* Parse the CVSROOT/config file, but only for local.  For the
	       server, we parse it after we know $CVSROOT.  For the
	       client, it doesn't get parsed at all, obviously.  The
	       presence of the parse_config call here is not meant to
	       predetermine whether CVSROOT/config overrides things from
	       read_cvsrc and other such places or vice versa.  That sort
	       of thing probably needs more thought.  */
	    if (1
#ifdef SERVER_SUPPORT
		&& !server_active
#endif
#ifdef CLIENT_SUPPORT
		&& !current_parsed_root->isremote
#endif
		)
	    {
		/* If there was an error parsing the config file, parse_config
		   already printed an error.  We keep going.  Why?  Because
		   if we didn't, then there would be no way to check in a new
		   CVSROOT/config file to fix the broken one!  */
		if (config) free_config (config);
		config = parse_config (current_parsed_root->directory);
	    }

#ifdef CLIENT_SUPPORT
	    /* Need to check for current_parsed_root != NULL here since
	     * we could still be in server mode before the server function
	     * gets called below and sets the root
	     */
	    if (current_parsed_root != NULL && current_parsed_root->isremote)
	    {
		/* Create a new list for directory names that we've
		   sent to the server. */
		if (dirs_sent_to_server != NULL)
		    dellist (&dirs_sent_to_server);
		dirs_sent_to_server = getlist ();
	    }
#endif

	    if (
#ifdef SERVER_SUPPORT
		/* Don't worry about lock_cleanup_setup when the server is
		 * active since we can only go through this loop once in that
		 * case anyhow.
		 */
		server_active ||
#endif
	        (
#ifdef CLIENT_SUPPORT
		 !current_parsed_root->isremote &&
#endif
		 !lock_cleanup_setup))
	    {
		/* Set up to clean up any locks we might create on exit.  */
		cleanup_register (Lock_Cleanup);
		lock_cleanup_setup = 1;
	    }

	    /* Call our worker function.  */
	    err = (*(cm->func)) (argc, argv);

	    /* Mark this root directory as done.  When the server is
               active, our list will be empty -- don't try and
               remove it from the list. */

#ifdef SERVER_SUPPORT
	    if (!server_active)
#endif /* SERVER_SUPPORT */
	    {
		Node *n = findnode (root_directories,
				    original_parsed_root->original);
		assert (n != NULL);
		assert (n->data != NULL);
		n->data = NULL;
		current_parsed_root = NULL;
	    }

#ifdef SERVER_SUPPORT
	    if (server_active)
		break;
#endif
	} /* end of loop for cvsroot values */

	dellist (&root_directories);
    } /* end of stuff that gets done if the user DOESN'T ask for help */

    root_allow_free ();

    /* This is exit rather than return because apparently that keeps
       some tools which check for memory leaks happier.  */
    exit (err ? EXIT_FAILURE : 0);
	/* Keep picky/stupid compilers (e.g. Visual C++ 5.0) happy.  */
	return 0;
}



char *
Make_Date (char *rawdate)
{
    struct timespec t;

    if (!get_date (&t, rawdate, NULL))
	error (1, 0, "Can't parse date/time: `%s'", rawdate);

    /* Truncate nanoseconds.  */
    return date_from_time_t (t.tv_sec);
}



/* Convert a time_t to an RCS format date.  This is mainly for the
   use of "cvs history", because the CVSROOT/history file contains
   time_t format dates; most parts of CVS will want to avoid using
   time_t's directly, and instead use RCS_datecmp, Make_Date, &c.
   Assuming that the time_t is in GMT (as it generally should be),
   then the result will be in GMT too.

   Returns a newly malloc'd string.  */

char *
date_from_time_t (time_t unixtime)
{
    struct tm *ftm;
    char date[MAXDATELEN];
    char *ret;

    ftm = gmtime (&unixtime);
    if (ftm == NULL)
	/* This is a system, like VMS, where the system clock is in local
	   time.  Hopefully using localtime here matches the "zero timezone"
	   hack I added to get_date (get_date of course being the relevant
	   issue for Make_Date, and for history.c too I think).  */
	ftm = localtime (&unixtime);

    (void) sprintf (date, DATEFORM,
		    (int)(ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900)),
		    ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
		    ftm->tm_min, ftm->tm_sec);
    ret = xstrdup (date);
    return ret;
}



/* Convert a date to RFC822/1123 format.  This is used in contexts like
   dates to send in the protocol; it should not vary based on locale or
   other such conventions for users.  We should have another routine which
   does that kind of thing.

   The SOURCE date is in our internal RCS format.  DEST should point to
   storage managed by the caller, at least MAXDATELEN characters.  */
void
date_to_internet (char *dest, const char *source)
{
    struct tm date;

    date_to_tm (&date, source);
    tm_to_internet (dest, &date);
}



void
date_to_tm (struct tm *dest, const char *source)
{
    int y;
    if (sscanf (source, SDATEFORM,
		&y, &dest->tm_mon, &dest->tm_mday,
		&dest->tm_hour, &dest->tm_min, &dest->tm_sec)
	    != 6)
	/* Is there a better way to handle errors here?  I made this
	   non-fatal in case we are called from the code which can't
	   deal with fatal errors.  */
	error (0, 0, "internal error: bad date %s", source);

    dest->tm_year = y - ((y > 100) ? 1900 : 0);
    dest->tm_mon -= 1;
}



/* Convert a date to RFC822/1123 format.  This is used in contexts like
   dates to send in the protocol; it should not vary based on locale or
   other such conventions for users.  We should have another routine which
   does that kind of thing.

   The SOURCE date is a pointer to a struct tm.  DEST should point to
   storage managed by the caller, at least MAXDATELEN characters.  */
void
tm_to_internet (char *dest, const struct tm *source)
{
    /* Just to reiterate, these strings are from RFC822 and do not vary
       according to locale.  */
    static const char *const month_names[] =
      {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    sprintf (dest, "%d %s %lld %02d:%02d:%02d -0000", source->tm_mday,
	     source->tm_mon < 0 || source->tm_mon > 11
               ? "???" : month_names[source->tm_mon],
	     (int64_t)source->tm_year + 1900, source->tm_hour, source->tm_min,
             source->tm_sec);
}



/*
 * Format a date for the current locale.
 *
 * INPUT
 *   UNIXTIME	The UNIX seconds since the epoch.
 *
 * RETURNS
 *   If my_strftime() encounters an error, this function can return NULL.
 *
 *   Otherwise, returns a date string in ISO8601 format, e.g.:
 *
 *	2004-04-29 13:24:22 -0700
 *
 *   It is the responsibility of the caller to return of this string.
 */
static char *
format_time_t (time_t unixtime)
{
    static char buf[sizeof ("yyyy-mm-dd HH:MM:SS -HHMM")];
    /* Convert to a time in the local time zone.  */
    struct tm ltm = *(localtime (&unixtime));

    if (!my_strftime (buf, sizeof (buf), "%Y-%m-%d %H:%M:%S %z", &ltm, 0, 0))
	return NULL;

    return xstrdup (buf);
}



/* Like format_time_t(), but return time in UTC.
 */
char *
gmformat_time_t (time_t unixtime)
{
    static char buf[sizeof ("yyyy-mm-dd HH:MM:SS -HHMM")];
    /* Convert to a time in the local time zone.  */
    struct tm ltm = *(gmtime (&unixtime));

    if (!my_strftime (buf, sizeof (buf), "%Y-%m-%d %H:%M:%S %z", &ltm, 0, 0))
	return NULL;

    return xstrdup (buf);
}



/* Format a date in the local timezone using format_time_t() given a date from
 * an arbitrary timezone in a string.
 *
 * INPUT
 *   DATESTR	A string that looks like anything get_date() can parse, e.g.:
 *
 *                      2004-04-29 20:24:22
 *
 * ERRORS
 *   As get_date() & format_time_t().  Prints a warning if either provide
 *   error return values.  See RETURNS.
 *
 * RETURNS
 *   A freshly allocated string that is a copy of the input string if either
 *   get_date() or format_time_t() encounter an error and as format_time_t()
 *   otherwise.
 */
char *
format_date_alloc (char *datestr)
{
    struct timespec t;
    char *buf;

    TRACE (TRACE_FUNCTION, "format_date (%s)", datestr);

    /* Convert the date string to seconds since the epoch. */
    if (!get_date (&t, datestr, NULL))
    {
	error (0, 0, "Can't parse date/time: `%s'.", datestr);
	goto as_is;
    }

    /* Get the time into a string, truncating any nanoseconds returned by
     * getdate.
     */
    if ((buf = format_time_t (t.tv_sec)) == NULL)
    {
	error (0, 0, "Unable to reformat date `%s'.", datestr);
	goto as_is;
    }

    return buf;

 as_is:
    return xstrdup (datestr);
}



void
usage (register const char *const *cpp)
{
    (void) fprintf (stderr, *cpp++, program_name, cvs_cmd_name);
    for (; *cpp; cpp++)
	(void) fprintf (stderr, *cpp);
    exit (EXIT_FAILURE);
}

/* vim:tabstop=8:shiftwidth=4
 */
@


1.7
log
@shut the fuck up
we use -R on a regular basis
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/cvs/src/main.c,v 1.6 2004/12/02 12:40:18 tg Exp $ */
d19 1
d22 1
a22 7
__RCSID("$MirBSD: src/gnu/usr.bin/cvs/src/main.c,v 1.6 2004/12/02 12:40:18 tg Exp $");

#ifdef HAVE_WINSOCK_H
# include <winsock.h>
#elif !HAVE_GETHOSTNAME
extern int gethostname (char *, int);
#endif
d28 4
a31 8
/* I'd dynamically allocate this, but it seems like gethostname
   requires a fixed size array.  If I'm remembering the RFCs right,
   256 should be enough.  */
#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN  256
#endif

char hostname[MAXHOSTNAMELEN];
d187 1
a187 1
    "    Pascal Molli's CVS site at http://www.loria.fr/~molli/cvs-index.html\n",
d801 8
a808 1
	gethostname(hostname, sizeof (hostname));
a1052 1
		free_cvsroot_t (n->data);
@


1.6
log
@update to cvs 1.12.10-MirOS except automatically
generated files
XXX this installs as /usr/bin/ncvs yet, so no
XXX conflicts during the test phase.
XXX I suggest to _not_ update.

XXX *** IMPORTANT *** DO NOT ACCESS CVS 1.11 REPOSITORIES
XXX *** IMPORTANT *** WITH CVS 1.12 OR VICE VERSA!
@
text
@d1 1
a1 1
/* $MirBSD: testing/cvs/src/main.c,v 1.2 2004/12/02 09:33:08 tg Exp $ */
d21 1
a21 1
__RCSID("$MirBSD: testing/cvs/src/main.c,v 1.2 2004/12/02 09:33:08 tg Exp $");
a676 7

    if (readonlyfs && !really_quiet) {
	error (0, 0,
	       "WARNING: Read-only repository access mode selected via `cvs -R'.\n\
Using this option to access a repository which some users write to may\n\
cause intermittent sandbox corruption.");
    }
@


1.5
log
@* fix a few cases where DESTDIR wasn't honoured
* fix a few cases where CFLAGS (specifically the
  new global -Werror) wasn't honoured
* fix a bunch of warnings and errors
  (for takers: there are quite a few left, I fixed
  the most important ones. Don't care about gcc3.2
  though, it'll die RSN. Perl or Lynx are probably
  good targets.)
* fix parameter passing to HTML manpage generation
  (noticed outside the chroot and with a known bad
  config only... jarejare... we should build stuff
  with a ports-like systrace (I have worn the idea
  for weeks).
* sync lists

I'm not too sure about this code being release-quality
yet, but OTOH it works without too much failures.
@
text
@d1 2
a2 1
/* $MirBSD: src/gnu/usr.bin/cvs/src/main.c,v 1.4 2004/04/19 18:01:33 tg Stab $ */
d8 2
a9 1
 *    as specified in the README file that comes with the CVS source distribution.
a17 1
#include <assert.h>
d19 3
d24 3
a26 3
#include <winsock.h>
#else
extern int gethostname ();
d29 3
a31 5
__RCSID("$MirBSD$");

char *program_name;
char *program_path;
char *command_name;
d52 10
a61 4
/* Set if we should be writing CVSADM directories at top level.  At
   least for now we'll make the default be off (the CVS 1.9, not CVS
   1.9.2, behavior). */
int top_level_admin = 0;
a63 1
char *RCS_citag = NULL;
a77 9
/* We step through the above values.  This variable is set to reflect
 * the currently active value.
 *
 * Now static.  FIXME - this variable should be removable (well, localizable)
 * with a little more work.
 */
static char *current_root = NULL;


d80 1
a80 1
    char *fullname;		/* Full name of the function (e.g. "commit") */
d102 2
a103 2
    char *nick1;
    char *nick2;
d105 1
a105 1
    int (*func) ();		/* Function takes (argc, argv) arguments. */
d130 1
d136 1
a136 1
    { "release",  "re",       "rel",       release,   0 },
d139 1
d160 1
a160 1
       use lowercase, as far as I know.  Puncutation is pretty funky,
d177 1
a177 1
    "  Specify --help to receive this message; -v for version and (c) info\n",
d223 1
d232 1
a256 1
    "    -l           Turn history logging off.\n",
d258 3
a260 1
    "    -t           Show trace of program execution -- try with -n.\n",
a261 1
    "    -R           Read-only repository.\n",
d280 1
a280 3
set_root_directory (p, ignored)
    Node *p;
    void *ignored;
d282 1
a282 1
    if (current_root == NULL && p->data == NULL)
d284 2
a285 1
	current_root = p->key;
d293 1
a293 1
cmd_synonyms ()
d331 1
d333 1
a333 2
lookup_command_attribute (cmd_name)
     char *cmd_name;
d342 2
d348 21
d370 1
a370 2
main_cleanup (sig)
    int sig;
d416 1
d418 4
d425 2
d428 1
a428 3
main (argc, argv)
    int argc;
    char **argv;
d430 2
a431 1
    char *CVSroot = CVSROOT_DFLT;
d435 1
a435 2
    int tmpdir_update_env, cvs_update_env;
    int free_CVSroot = 0;
d442 1
a442 1
    static const char short_options[] = "+Qqrwtnlvb:T:e:d:Hfz:s:xaR";
d450 1
d452 1
d465 6
a492 1
    cvs_update_env = 0;
a504 5
    if ((cp = getenv (CVSROOT_ENV)) != NULL)
    {
	CVSroot = cp;
	cvs_update_env = 0;		/* it's already there */
    }
d507 1
a507 1
    if (getenv (CVSREADONLYFS_ENV)) {
d557 1
d562 1
d576 5
a580 1
		trace = 1;
a583 1
	    case 'l':			/* Fall through */
a585 4
	    case 'R':
		logoff = 1;
		readonlyfs = 1;
		break;
d587 11
a597 9
		(void) fputs ("\n", stdout);
		version (0, (char **) NULL);
		(void) fputs ("\n"
		    "Copyright (c) 1989-2001 Brian Berliner, david d `zoo' zuhn, \n"
		    "                        Jeff Polk, and other authors\n\n"
		    "CVS may be copied only under the terms of the GNU General Public License,\n"
		    "Version 2, as seen in /usr/share/doc/legal on MirOS.\n\n", stdout);

		(void) fputs ("Specify the --help option for further information about CVS\n", stdout);
d609 1
d615 1
a622 5
		if (free_CVSroot)
		    free (CVSroot);
		CVSroot = xstrdup (optarg);
		free_CVSroot = 1;
		cvs_update_env = 1;	/* need to update environment */
d632 2
a633 2
		gzip_level = atoi (optarg);
		if (gzip_level < 0 || gzip_level > 9)
d636 1
a636 1
#endif
d638 7
a644 2
		   level, so that users can have it in their .cvsrc and not
		   cause any trouble.  */
d678 6
d687 1
a687 1
    command_name = argv[0];
d690 1
a690 1
	if (cm->nick1 && !strcmp (command_name, cm->nick1))
d692 1
a692 1
	if (cm->nick2 && !strcmp (command_name, cm->nick2))
d694 1
a694 1
	if (!strcmp (command_name, cm->fullname))
d700 1
a700 1
	fprintf (stderr, "Unknown command: `%s'\n\n", command_name);
d704 1
a704 1
	command_name = cm->fullname;	/* Global pointer for later use */
d716 2
d733 3
a735 1
#if defined (HAVE_KERBEROS) && defined (SERVER_SUPPORT)
d740 1
a740 1
	if (strcmp (command_name, "kserver") == 0)
d745 1
a745 1
	    command_name = "server";
d747 1
a747 1
#endif /* HAVE_KERBEROS */
d750 2
a751 2
#if (defined(AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)) && defined(SERVER_SUPPORT)
	if (strcmp (command_name, "pserver") == 0)
d765 1
a765 1
	    command_name = "server";
d767 1
a767 1
#endif /* (AUTH_SERVER_SUPPORT || HAVE_GSSAPI) && SERVER_SUPPORT */
d769 3
a771 3
#ifdef SERVER_SUPPORT
	server_active = strcmp (command_name, "server") == 0;
#endif
a772 4
	/* This is only used for writing into the history file.  For
	   remote connections, it might be nice to have hostname
	   and/or remote path, on the other hand I'm not sure whether
	   it is worth the trouble.  */
d776 5
d782 2
d787 1
a787 1
	    CurDir = xgetwd ();
d804 8
a813 1
#ifndef DONT_USE_SIGNALS
d815 1
a815 19
#ifdef SIGABRT
	(void) SIG_register (SIGABRT, main_cleanup);
#endif
#ifdef SIGHUP
	(void) SIG_register (SIGHUP, main_cleanup);
#endif
#ifdef SIGINT
	(void) SIG_register (SIGINT, main_cleanup);
#endif
#ifdef SIGQUIT
	(void) SIG_register (SIGQUIT, main_cleanup);
#endif
#ifdef SIGPIPE
	(void) SIG_register (SIGPIPE, main_cleanup);
#endif
#ifdef SIGTERM
	(void) SIG_register (SIGTERM, main_cleanup);
#endif
#endif /* !DONT_USE_SIGNALS */
d828 1
a828 1
	    read_cvsrc (&argc, &argv, command_name);
d832 3
a834 3
	       in server mode, since the client will send the repository
	       directory after the connection is made. */

d838 6
a843 1
	    char *CVSADM_Root;
d846 13
a858 1
	       in the CVSADM_ROOT directory. */
d860 4
a863 12
	    CVSADM_Root = NULL;

	    /* "cvs import" shouldn't check CVS/Root; in general it
	       ignores CVS directories and CVS/Root is likely to
	       specify a different repository than the one we are
	       importing to.  */

	    if (!(cm->attr & CVS_CMD_IGNORE_ADMROOT)

		/* -d overrides CVS/Root, so don't give an error if the
		   latter points to a nonexistent repository.  */
		&& CVSroot_cmdline == NULL)
d865 7
a871 1
		CVSADM_Root = Name_Root((char *) NULL, (char *) NULL);
d874 2
a875 1
	    if (CVSADM_Root != NULL)
d877 2
a878 5
		if (CVSroot == NULL || !cvs_update_env)
		{
		    CVSroot = CVSADM_Root;
		    cvs_update_env = 1;	/* need to update environment */
		}
d880 1
d885 1
a885 2

	    if (! CVSroot)
a891 13

	    if (! *CVSroot)
	    {
		error (0, 0,
		       "CVSROOT is set but empty!  Make sure that the");
		error (0, 0,
		       "specification of CVSROOT is legal, either via the");
		error (0, 0,
		       "`-d' option, the %s environment variable, or the",
		       CVSROOT_ENV);
		error (1, 0,
		       "CVS/Root file (if any).");
	    }
d903 1
a903 1
	if (CVSroot != NULL)
d908 2
a909 2
	    n->key = xstrdup (CVSroot);
	    n->data = NULL;
d915 1
a915 1
	assert (current_root == NULL);
d942 4
a945 8
		if (current_parsed_root != NULL)
		    free_cvsroot_t (current_parsed_root);
		if ((current_parsed_root = parse_cvsroot (current_root)) == NULL)
		    error (1, 0, "Bad CVSROOT.");

		if (trace)
		    fprintf (stderr, "%s-> main loop with CVSROOT=%s\n",
			   CLIENT_SERVER_STR, current_root);
d957 3
a959 5
		    path = xmalloc (strlen (current_parsed_root->directory)
				    + sizeof (CVSROOTADM)
				    + 20);
		    (void) sprintf (path, "%s/%s", current_parsed_root->directory, CVSROOTADM);
		    if (readonlyfs == 0 && !isaccessible (path, R_OK | X_OK))
d962 3
a964 3
			/* If this is "cvs init", the root need not exist yet.  */
			if (strcmp (command_name, "init") != 0)
			{
a965 1
			}
d971 2
a972 3
		/* Update the CVSROOT environment variable if necessary. */
		/* FIXME (njc): should we always set this with the CVSROOT from the command line? */
		if (cvs_update_env)
d976 3
a978 3
		    env = xmalloc (strlen (CVSROOT_ENV) + strlen (CVSroot)
				   + 1 + 1);
		    (void) sprintf (env, "%s=%s", CVSROOT_ENV, CVSroot);
d992 1
a992 1
	       presence of the parse_config call here is not mean to
d1009 2
a1010 1
		parse_config (current_parsed_root->directory);
d1028 20
d1051 1
a1051 1
               active, current_root will be NULL -- don't try and
d1054 3
a1056 1
	    if (current_root != NULL)
d1058 2
a1059 1
		Node *n = findnode (root_directories, current_root);
d1061 4
a1064 2
		n->data = (void *) 1;
		current_root = NULL;
a1066 5
#if 0
	    /* This will not work yet, since it tries to free (void *) 1. */
	    dellist (&root_directories);
#endif

d1069 1
a1069 1
	      break;
d1073 1
a1075 11
    Lock_Cleanup ();

    free (program_path);
    if (CVSroot_cmdline != NULL)
	free (CVSroot_cmdline);
    if (free_CVSroot)
	free (CVSroot);
    if (free_Editor)
	free (Editor);
    if (free_Tmpdir)
	free (Tmpdir);
a1077 6
#ifdef SYSTEM_CLEANUP
    /* Hook for OS-specific behavior, for example socket subsystems on
       NT and OS2 or dealing with windows and arguments on Mac.  */
    SYSTEM_CLEANUP ();
#endif

d1085 2
d1088 1
a1088 2
Make_Date (rawdate)
    char *rawdate;
d1090 4
a1093 1
    time_t unixtime;
d1095 2
a1096 4
    unixtime = get_date (rawdate, (struct timeb *) NULL);
    if (unixtime == (time_t) - 1)
	error (1, 0, "Can't parse date/time: %s", rawdate);
    return date_from_time_t (unixtime);
d1099 2
d1111 1
a1111 2
date_from_time_t (unixtime)
    time_t unixtime;
d1126 1
a1126 1
		    (int)ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
d1130 1
a1130 1
    return (ret);
d1133 2
d1143 1
a1143 3
date_to_internet (dest, source)
    char *dest;
    const char *source;
d1151 2
d1154 1
a1154 3
date_to_tm (dest, source)
    struct tm *dest;
    const char *source;
d1170 2
d1180 1
a1180 3
tm_to_internet (dest, source)
    char *dest;
    const struct tm *source;
d1189 51
a1239 2
	     source->tm_mon < 0 || source->tm_mon > 11 ? "???" : month_names[source->tm_mon],
	     (int64_t)source->tm_year + 1900, source->tm_hour, source->tm_min, source->tm_sec);
d1242 51
d1294 1
a1294 2
usage (cpp)
    register const char *const *cpp;
d1296 1
a1296 1
    (void) fprintf (stderr, *cpp++, program_name, command_name);
d1299 1
a1299 1
    error_exit();
d1301 3
@


1.4
log
@prettify -v and --help output; nuke wrapped string
@
text
@d1 1
a1 1
/* $MirBSD$ */
d25 2
d1089 1
a1089 1
		    ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
d1119 1
d1121 1
a1121 1
		&dest->tm_year, &dest->tm_mon, &dest->tm_mday,
d1129 1
a1129 3
    if (dest->tm_year > 100)
	dest->tm_year -= 1900;

d1151 1
a1151 1
    sprintf (dest, "%d %s %d %02d:%02d:%02d -0000", source->tm_mday,
d1153 1
a1153 1
	     source->tm_year + 1900, source->tm_hour, source->tm_min, source->tm_sec);
@


1.3
log
@cvs-1.11.12 doesn't do the joints correctly (what were the
FSF people smoking?), it memory faults.
thusly revert to 1.11.1p1

tested.
agreed bsiegert@@
@
text
@d1 1
d104 1
a104 1
    
d175 1
a175 1
    "  Specify --help to receive this message\n",
d303 1
a303 1
    
d323 1
a323 1
    
d555 6
a560 9
		version (0, (char **) NULL);    
		(void) fputs ("\n", stdout);
		(void) fputs ("\
Copyright (c) 1989-2001 Brian Berliner, david d `zoo' zuhn, \n\
                        Jeff Polk, and other authors\n", stdout);
		(void) fputs ("\n", stdout);
		(void) fputs ("CVS may be copied only under the terms of the GNU General Public License,\n", stdout);
		(void) fputs ("a copy of which can be found with the CVS distribution kit.\n", stdout);
		(void) fputs ("\n", stdout);
d716 1
a716 1
      
d800 1
a800 1
	    
d840 1
a840 1
	    
d957 1
a957 1
	
d997 1
a997 1
	
d1009 1
a1009 1
	
d1149 1
a1149 1
    
@


1.2
log
@first step of merging new cvs
XXX might not compile
XXX might not work
XXX might contain bugs
XXX definitively needs autoconf 2.58 first
@
text
@d157 1
a157 1
       use lowercase, as far as I know.  Punctuation is pretty funky,
d252 1
a337 2
    if (!cm->fullname)
	error (1, 0, "unknown command: %s", cmd_name);
d411 1
a411 1
    static const char short_options[] = "+Qqrwtnvb:T:e:d:Hfz:s:xaR";
d545 1
d557 1
a557 1
Copyright (c) 1989-2003 Brian Berliner, david d `zoo' zuhn, \n\
d602 2
a603 2
		gzip_level = strtol (optarg, &end, 10);
		if (*end != '\0' || gzip_level < 0 || gzip_level > 9)
d606 1
a606 1
#endif /* CLIENT_SUPPORT */
d608 2
a609 7
		 * level, so that users can have it in their .cvsrc and not
		 * cause any trouble.
		 *
		 * We still parse the argument to -z for correctness since
		 * one user complained of being bitten by a run of
		 * `cvs -z -n up' which read -n as the argument to -z without
		 * complaining.  */
d690 1
a690 3
#ifdef SERVER_SUPPORT

# ifdef HAVE_KERBEROS
d702 1
a702 1
# endif /* HAVE_KERBEROS */
d705 1
a705 1
# if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)
d722 1
a722 1
# endif /* AUTH_SERVER_SUPPORT || HAVE_GSSAPI */
d724 1
d726 1
a726 2

#endif /* SERVER_SUPPORT */
d848 1
a848 1
		       "specification of CVSROOT is valid, either via the");
d908 1
a908 1
		    error (1, 0, "Bad CVSROOT: `%s'.", current_root);
d1019 1
a1019 4
	    {
		server_active = 0;
		break;
	    }
@


1.1
log
@Initial revision
@
text
@d157 1
a157 1
       use lowercase, as far as I know.  Puncutation is pretty funky,
a251 1
    "    -l           Turn history logging off.\n",
d337 2
d412 1
a412 1
    static const char short_options[] = "+Qqrwtnlvb:T:e:d:Hfz:s:xaR";
a545 1
	    case 'l':			/* Fall through */
d557 1
a557 1
Copyright (c) 1989-2001 Brian Berliner, david d `zoo' zuhn, \n\
d602 2
a603 2
		gzip_level = atoi (optarg);
		if (gzip_level < 0 || gzip_level > 9)
d606 1
a606 1
#endif
d608 7
a614 2
		   level, so that users can have it in their .cvsrc and not
		   cause any trouble.  */
d695 3
a697 1
#if defined (HAVE_KERBEROS) && defined (SERVER_SUPPORT)
d709 1
a709 1
#endif /* HAVE_KERBEROS */
d712 1
a712 1
#if (defined(AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)) && defined(SERVER_SUPPORT)
d729 1
a729 1
#endif /* (AUTH_SERVER_SUPPORT || HAVE_GSSAPI) && SERVER_SUPPORT */
a730 1
#ifdef SERVER_SUPPORT
d732 2
a733 1
#endif
d855 1
a855 1
		       "specification of CVSROOT is legal, either via the");
d915 1
a915 1
		    error (1, 0, "Bad CVSROOT.");
d1026 4
a1029 1
	      break;
@


1.1.2.1
log
@vendor-branch-ify new cvs 1.12
@
text
@d6 1
a6 2
 *    as specified in the README file that comes with the CVS source
 *    distribution.
d15 1
a16 1
#include "strftime.h"
d19 3
a21 3
# include <winsock.h>
#elif !HAVE_GETHOSTNAME
extern int gethostname (char *, int);
d24 3
a26 3
const char *program_name;
const char *program_path;
const char *cvs_cmd_name;
d47 4
a50 10


/***
 ***
 ***   CVSROOT/config options
 ***
 ***/
struct config *config;


d53 1
d68 9
d79 1
a79 1
    const char *fullname;	/* Full name of the function (e.g. "commit") */
d101 2
a102 2
    const char *nick1;
    const char *nick2;
d104 1
a104 1
    int (*func) (int, char **);	/* Function takes (argc, argv) arguments. */
a128 1
    { "ls",       "dir",      "list",      ls,        0 },
d134 1
a134 1
    { "release",  "re",       "rel",       release,   CVS_CMD_MODIFIES_REPOSITORY },
a136 1
    { "rls",      "rdir",     "rlist",     ls,        0 },
d157 1
a157 1
       use lowercase, as far as I know.  Punctuation is pretty funky,
a219 1
    "        ls           List files available from CVS\n",
a227 1
    "        rls          List files in a module\n",
d252 1
d254 1
a254 3
    "    -t           Show trace of program execution (repeat for more\n",
    "                 verbosity) -- try with -n.\n",
    "    -R           Assume repository is read-only, such as CDROM\n",
d256 1
d275 3
a277 1
set_root_directory (Node *p, void *ignored)
d279 1
a279 1
    if (current_parsed_root == NULL && p->data != NULL)
d281 1
a281 2
	current_parsed_root = p->data;
	original_parsed_root = current_parsed_root;
d289 1
a289 1
cmd_synonyms (void)
a326 1

d328 2
a329 1
lookup_command_attribute (const char *cmd_name)
a337 2
    if (!cm->fullname)
	error (1, 0, "unknown command: %s", cmd_name);
a341 21

/*
 * Exit with an error code and an informative message about the signal
 * received.  This function, by virtue of causing an actual call to exit(),
 * causes all the atexit() handlers to be called.
 *
 * INPUTS
 *   sig	The signal recieved.
 *
 * ERRORS
 *   The cleanup routines registered via atexit() and the error function
 *   itself can potentially change the exit status.  They shouldn't do this
 *   unless they encounter problems doing their own jobs.
 *
 * RETURNS
 *   Nothing.  This function will always exit.  It should exit with an exit
 *   status of 1, but might not, as noted in the ERRORS section above.
 */
#ifndef DONT_USE_SIGNALS
static RETSIGTYPE main_cleanup (int) __attribute__ ((__noreturn__));
#endif /* DONT_USE_SIGNALS */
d343 2
a344 1
main_cleanup (int sig)
a389 1
    /* This always exits, which will cause our exit handlers to be called.  */
a390 4
    /* but make the exit explicit to silence warnings when gcc processes the
     * noreturn attribute.
     */
    exit (EXIT_FAILURE);
a393 2


d395 3
a397 1
main (int argc, char **argv)
d399 1
a399 2
    cvsroot_t *CVSroot_parsed = NULL;
    bool cvsroot_update_env = true;
d403 2
a404 1
    int tmpdir_update_env;
d411 1
a411 1
    static const char short_options[] = "+QqrwtnRvb:T:e:d:Hfz:s:xa";
a418 1
#ifdef SERVER_SUPPORT
a419 1
#endif /* SERVER_SUPPORT */
a431 6
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	cleanup_register (SYSTEM_CLEANUP);
#endif

d454 1
d467 5
d474 1
a474 1
    if (getenv (CVSREADONLYFS_ENV) != NULL) {
a523 1
#ifdef SERVER_SUPPORT
a527 1
#endif /* SERVER_SUPPORT */
d541 1
a541 1
		trace++;
d543 3
a545 2
	    case 'R':
		readonlyfs = -1;
d548 1
a548 2
	    case 'n':
		noexec = 1;
d550 1
d553 12
a564 11
		fputs ("\n", stdout);
		version (0, NULL);    
		fputs (
"\n"
"Copyright (c) 1989-2004 Brian Berliner, david d `zoo' zuhn,\n"
"                        Jeff Polk, and other authors\n"
"\n"
"CVS may be copied only under the terms of the GNU General Public License,\n"
"a copy of which can be found with the CVS distribution kit.\n"
"\n"
"Specify the --help option for further information about CVS\n", stdout);
a575 1
		if (free_Tmpdir) free (Tmpdir);
a580 1
		if (free_Editor) free (Editor);
d588 5
d602 2
a603 2
		gzip_level = strtol (optarg, &end, 10);
		if (*end != '\0' || gzip_level < 0 || gzip_level > 9)
d606 1
a606 1
#endif /* CLIENT_SUPPORT */
d608 2
a609 7
		 * level, so that users can have it in their .cvsrc and not
		 * cause any trouble.
		 *
		 * We still parse the argument to -z for correctness since
		 * one user complained of being bitten by a run of
		 * `cvs -z -n up' which read -n as the argument to -z without
		 * complaining.  */
a642 6
    if (readonlyfs && !really_quiet) {
	error (0, 0,
	       "WARNING: Read-only repository access mode selected via `cvs -R'.\n\
Using this option to access a repository which some users write to may\n\
cause intermittent sandbox corruption.");
    }
d646 1
a646 1
    cvs_cmd_name = argv[0];
d649 1
a649 1
	if (cm->nick1 && !strcmp (cvs_cmd_name, cm->nick1))
d651 1
a651 1
	if (cm->nick2 && !strcmp (cvs_cmd_name, cm->nick2))
d653 1
a653 1
	if (!strcmp (cvs_cmd_name, cm->fullname))
d659 1
a659 1
	fprintf (stderr, "Unknown command: `%s'\n\n", cvs_cmd_name);
d663 1
a663 1
	cvs_cmd_name = cm->fullname;	/* Global pointer for later use */
a674 2
	short int lock_cleanup_setup = 0;

d690 1
a690 3
#ifdef SERVER_SUPPORT

# ifdef HAVE_KERBEROS
d695 1
a695 1
	if (strcmp (cvs_cmd_name, "kserver") == 0)
d700 1
a700 1
	    cvs_cmd_name = "server";
d702 1
a702 1
# endif /* HAVE_KERBEROS */
d705 2
a706 2
# if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)
	if (strcmp (cvs_cmd_name, "pserver") == 0)
d720 1
a720 1
	    cvs_cmd_name = "server";
d722 1
a722 1
# endif /* AUTH_SERVER_SUPPORT || HAVE_GSSAPI */
d724 3
a726 3
	server_active = strcmp (cvs_cmd_name, "server") == 0;

#endif /* SERVER_SUPPORT */
d728 4
a734 5
	{
	    /* This is only used for writing into the history file.  For
	       remote connections, it might be nice to have hostname
	       and/or remote path, on the other hand I'm not sure whether
	       it is worth the trouble.  */
a735 2
	    cleanup_register (server_cleanup);
	}
d739 1
a739 1
	    CurDir = xgetcwd ();
a755 8
	{
	    char *env;
	    /* XXX pid < 10^32 */
	    env = xmalloc (strlen (CVS_PID_ENV) + 1 + 32 + 1);
	    (void) sprintf (env, "%s=%ld", CVS_PID_ENV, (long) getpid ());
	    (void) putenv (env);
	    /* do not free env, as putenv has control of it */
	}
d758 1
d760 19
a778 1
	signals_register (main_cleanup);
d791 1
a791 1
	    read_cvsrc (&argc, &argv, cvs_cmd_name);
d795 3
a797 3
	 * in server mode, since the client will send the repository
	 * directory after the connection is made.
	 */
d801 17
a817 2
	    /* First check if a root was set via the command line.  */
	    if (CVSroot_cmdline)
d819 1
a819 2
		 if (!(CVSroot_parsed = parse_cvsroot (CVSroot_cmdline)))
		     error (1, 0, "Bad CVSROOT: `%s'.", CVSroot_cmdline);
d822 1
a822 19
	    /* See if we are able to find a 'better' value for CVSroot
	     * in the CVSADM_ROOT directory.
	     *
	     * "cvs import" shouldn't check CVS/Root; in general it
	     * ignores CVS directories and CVS/Root is likely to
	     * specify a different repository than the one we are
	     * importing to, but if this is not import and no root was
	     * specified on the command line, set the root from the
	     * CVS/Root file.
	     */
	    if (!CVSroot_parsed
		&& !(cm->attr & CVS_CMD_IGNORE_ADMROOT)
	       )
		CVSroot_parsed = Name_Root (NULL, NULL);

	    /* Now, if there is no root on the command line and we didn't find
	     * one in a file, set it via the $CVSROOT env var.
	     */
	    if (!CVSroot_parsed)
d824 1
a824 2
		char *tmp = getenv (CVSROOT_ENV);
		if (tmp)
d826 2
a827 3
		    if (!(CVSroot_parsed = parse_cvsroot (tmp)))
			error (1, 0, "Bad CVSROOT: `%s'.", tmp);
		    cvsroot_update_env = false;
a830 8
#ifdef CVSROOT_DFLT
	    if (!CVSroot_parsed)
	    {
		if (!(CVSroot_parsed = parse_cvsroot (CVSROOT_DFLT)))
		    error (1, 0, "Bad CVSROOT: `%s'.", CVSROOT_DFLT);
	    }
#endif /* CVSROOT_DFLT */

d834 2
a835 1
	    if (!CVSroot_parsed)
d842 13
d866 1
a866 1
	if (CVSroot_parsed)
d871 2
a872 2
	    n->key = xstrdup (CVSroot_parsed->original);
	    n->data = CVSroot_parsed;
d878 1
a878 1
	assert (current_parsed_root == NULL);
d905 8
a912 4
		TRACE (TRACE_FUNCTION,
		       "main loop with CVSROOT=%s",
		       current_parsed_root ? current_parsed_root->directory
					   : "(null)");
d924 5
a928 3
		    path = Xasprintf ("%s/%s", current_parsed_root->directory,
				      CVSROOTADM);
		    if (!isaccessible (path, R_OK | X_OK))
d931 3
a933 3
			/* If this is "cvs init", the root need not exist yet.
			 */
			if (strcmp (cvs_cmd_name, "init"))
d935 1
d941 3
a943 2
		/* Update the CVSROOT environment variable.  */
		if (cvsroot_update_env)
d947 3
a949 3

		    env = Xasprintf ("%s=%s", CVSROOT_ENV,
				     current_parsed_root->original);
d963 1
a963 1
	       presence of the parse_config call here is not meant to
d980 1
a980 2
		if (config) free_config (config);
		config = parse_config (current_parsed_root->directory);
a997 20
	    if (
#ifdef SERVER_SUPPORT
		/* Don't worry about lock_cleanup_setup when the server is
		 * active since we can only go through this loop once in that
		 * case anyhow.
		 */
		server_active ||
#endif
	        (
#ifdef CLIENT_SUPPORT
		 !current_parsed_root->isremote &&
#endif
		 !lock_cleanup_setup))
	    {
		/* Set up to clean up any locks we might create on exit.  */
		cleanup_register (Lock_Cleanup);
		lock_cleanup_setup = 1;
	    }

	    /* Call our worker function.  */
d1001 1
a1001 1
               active, our list will be empty -- don't try and
d1004 1
a1004 3
#ifdef SERVER_SUPPORT
	    if (!server_active)
#endif /* SERVER_SUPPORT */
d1006 1
a1006 2
		Node *n = findnode (root_directories,
				    original_parsed_root->original);
d1008 2
a1009 4
		assert (n->data != NULL);
		free_cvsroot_t (n->data);
		n->data = NULL;
		current_parsed_root = NULL;
d1011 5
d1019 1
a1019 1
		break;
a1022 1
	dellist (&root_directories);
d1025 11
d1038 6
a1050 2


d1052 2
a1053 1
Make_Date (char *rawdate)
d1055 1
a1055 1
    struct timespec t;
d1057 4
a1060 5
    if (!get_date (&t, rawdate, NULL))
	error (1, 0, "Can't parse date/time: `%s'", rawdate);

    /* Truncate nanoseconds.  */
    return date_from_time_t (t.tv_sec);
a1062 2


d1073 2
a1074 1
date_from_time_t (time_t unixtime)
d1093 1
a1093 1
    return ret;
a1095 2


d1104 3
a1106 1
date_to_internet (char *dest, const char *source)
a1113 2


d1115 3
a1117 1
date_to_tm (struct tm *dest, const char *source)
a1133 2


d1142 3
a1144 1
tm_to_internet (char *dest, const struct tm *source)
d1153 2
a1154 100
	     source->tm_mon < 0 || source->tm_mon > 11
               ? "???" : month_names[source->tm_mon],
	     source->tm_year + 1900, source->tm_hour, source->tm_min,
             source->tm_sec);
}



/*
 * Format a date for the current locale.
 *
 * INPUT
 *   UNIXTIME	The UNIX seconds since the epoch.
 *
 * RETURNS
 *   If my_strftime() encounters an error, this function can return NULL.
 *
 *   Otherwise, returns a date string in ISO8601 format, e.g.:
 *
 *	2004-04-29 13:24:22 -0700
 *
 *   It is the responsibility of the caller to return of this string.
 */
static char *
format_time_t (time_t unixtime)
{
    static char buf[sizeof ("yyyy-mm-dd HH:MM:SS -HHMM")];
    /* Convert to a time in the local time zone.  */
    struct tm ltm = *(localtime (&unixtime));

    if (!my_strftime (buf, sizeof (buf), "%Y-%m-%d %H:%M:%S %z", &ltm, 0, 0))
	return NULL;

    return xstrdup (buf);
}



/* Like format_time_t(), but return time in UTC.
 */
char *
gmformat_time_t (time_t unixtime)
{
    static char buf[sizeof ("yyyy-mm-dd HH:MM:SS -HHMM")];
    /* Convert to a time in the local time zone.  */
    struct tm ltm = *(gmtime (&unixtime));

    if (!my_strftime (buf, sizeof (buf), "%Y-%m-%d %H:%M:%S %z", &ltm, 0, 0))
	return NULL;

    return xstrdup (buf);
}



/* Format a date in the local timezone using format_time_t() given a date from
 * an arbitrary timezone in a string.
 *
 * INPUT
 *   DATESTR	A string that looks like anything get_date() can parse, e.g.:
 *
 *                      2004-04-29 20:24:22
 *
 * ERRORS
 *   As get_date() & format_time_t().  Prints a warning if either provide
 *   error return values.  See RETURNS.
 *
 * RETURNS
 *   A freshly allocated string that is a copy of the input string if either
 *   get_date() or format_time_t() encounter an error and as format_time_t()
 *   otherwise.
 */
char *
format_date_alloc (char *datestr)
{
    struct timespec t;
    char *buf;

    TRACE (TRACE_FUNCTION, "format_date (%s)", datestr);

    /* Convert the date string to seconds since the epoch. */
    if (!get_date (&t, datestr, NULL))
    {
	error (0, 0, "Can't parse date/time: `%s'.", datestr);
	goto as_is;
    }

    /* Get the time into a string, truncating any nanoseconds returned by
     * getdate.
     */
    if ((buf = format_time_t (t.tv_sec)) == NULL)
    {
	error (0, 0, "Unable to reformat date `%s'.", datestr);
	goto as_is;
    }

    return buf;

 as_is:
    return xstrdup (datestr);
a1156 2


d1158 2
a1159 1
usage (register const char *const *cpp)
d1161 1
a1161 1
    (void) fprintf (stderr, *cpp++, program_name, cvs_cmd_name);
d1164 1
a1164 1
    exit (EXIT_FAILURE);
a1165 3

/* vim:tabstop=8:shiftwidth=4
 */
@


1.1.2.2
log
@GNU CVS 1.12.11
@
text
@a16 1
#include "xgethostname.h"
d19 6
d29 8
a36 4
char *hostname;
#ifdef SERVER_SUPPORT
char *server_hostname;
#endif /* SERVER_SUPPORT */
d192 1
a192 1
    "    the CVSNT home page at http://www.cvsnt.org/\n",
d813 1
a813 8
	hostname = xgethostname();
#ifdef SERVER_SUPPORT
	/* Keep track of this separately since the client can change the
	 * hostname.
	 */
	if (server_active)
	    server_hostname = xstrdup (hostname);
#endif /* SERVER_SUPPORT */
d1058 1
@


1.1.3.1
log
@our CVS is currently at 1.11.1p1, thus import that version into vendor branch
@
text
@d44 1
d53 1
d256 1
d411 1
a411 1
    static const char short_options[] = "+Qqrwtnlvb:T:e:d:Hfz:s:xa";
d474 4
d548 4
d926 1
a926 1
				    + 2);
d928 1
a928 1
		    if (!isaccessible (path, R_OK | X_OK))
d1164 1
a1164 1
    error_exit ();
@


1.1.3.2
log
@CVS 1.11.12 is the latest stable version of CVS,
released 06.02.2004, with a huge lot of bug fixes.

/me hopes this will pay off...
@
text
@d155 1
a155 1
       use lowercase, as far as I know.  Punctuation is pretty funky,
d250 1
a334 2
    if (!cm->fullname)
	error (1, 0, "unknown command: %s", cmd_name);
d408 1
a408 1
    static const char short_options[] = "+Qqrwtnvb:T:e:d:Hfz:s:xa";
d538 1
d546 1
a546 1
Copyright (c) 1989-2003 Brian Berliner, david d `zoo' zuhn, \n\
d591 2
a592 2
		gzip_level = strtol (optarg, &end, 10);
		if (*end != '\0' || gzip_level < 0 || gzip_level > 9)
d595 1
a595 1
#endif /* CLIENT_SUPPORT */
d597 2
a598 7
		 * level, so that users can have it in their .cvsrc and not
		 * cause any trouble.
		 *
		 * We still parse the argument to -z for correctness since
		 * one user complained of being bitten by a run of
		 * `cvs -z -n up' which read -n as the argument to -z without
		 * complaining.  */
d679 1
a679 3
#ifdef SERVER_SUPPORT

# ifdef HAVE_KERBEROS
d691 1
a691 1
# endif /* HAVE_KERBEROS */
d694 1
a694 1
# if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)
d711 1
a711 1
# endif /* AUTH_SERVER_SUPPORT || HAVE_GSSAPI */
d713 1
d715 1
a715 2

#endif /* SERVER_SUPPORT */
d837 1
a837 1
		       "specification of CVSROOT is valid, either via the");
d897 1
a897 1
		    error (1, 0, "Bad CVSROOT: `%s'.", current_root);
d1008 1
a1008 4
	    {
		server_active = 0;
		break;
	    }
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
