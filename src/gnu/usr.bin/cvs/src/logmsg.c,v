head	1.5;
access;
symbols
	cvs-1_12_11:1.1.2.1
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.4
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.2
	MIROS_X_BASE:1.5
	cvs-1_12_10:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_MIRPPC:1.3.0.4
	MIRBSD_XP_SPARC_BASE:1.3
	MIRBSD_XP_SPARC:1.3.0.2
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200404170130:1.1.1.1
	cvs-1_11_12:1.1.3.2
	cvs-1_11_1p1:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.12.02.14.54.24;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.02.12.40.18;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.22.13.49.15;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.02.12.21.16.16;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.31;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.41.31;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2004.12.02.11.58.57;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.02.12.19.19.07;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.12.19.39.33;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@I like it better when I already have got a blank line
to type my cimsg on
@
text
@/* $MirBSD$ */

/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 *
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 */


#include "cvs.h"
#include "getline.h"

__RCSID("$MirBSD$");

static int find_type (Node * p, void *closure);
static int fmt_proc (Node * p, void *closure);
static int logfile_write (const char *repository, const char *filter,
			  const char *message, FILE * logfp, List * changes);
static int logmsg_list_to_args_proc (Node *p, void *closure);
static int rcsinfo_proc (const char *repository, const char *template,
                         void *closure );
static int update_logfile_proc (const char *repository, const char *filter,
                                void *closure);
static void setup_tmpfile (FILE * xfp, char *xprefix, List * changes);
static int verifymsg_proc (const char *repository, const char *script,
                           void *closure );

static FILE *fp;
static Ctype type;

struct verifymsg_proc_data
{
    /* The name of the temp file storing the log message to be verified.  This
     * is initially NULL and verifymsg_proc() writes message into it so that it
     * can be shared when multiple verifymsg scripts exist.  do_verify() is
     * responsible for rereading the message from the file when
     * RereadLogAfterVerify is in effect and the file has changed.
     */
    char *fname;
    /* The initial message text to be verified.
     */
    char *message;
    /* The initial stats of the temp file so we can tell that the temp file has
     * been changed when RereadLogAfterVerify is STAT.
     */
    struct stat pre_stbuf;
};

/*
 * Puts a standard header on the output which is either being prepared for an
 * editor session, or being sent to a logfile program.  The modified, added,
 * and removed files are included (if any) and formatted to look pretty. */
static char *prefix;
static int col;
static char *tag;
static void
setup_tmpfile (FILE *xfp, char *xprefix, List *changes)
{
    /* set up statics */
    fp = xfp;
    prefix = xprefix;

    type = T_MODIFIED;
    if (walklist (changes, find_type, NULL) != 0)
    {
	(void) fprintf (fp, "%sModified Files:\n", prefix);
	col = 0;
	(void) walklist (changes, fmt_proc, NULL);
	(void) fprintf (fp, "\n");
	if (tag != NULL)
	{
	    free (tag);
	    tag = NULL;
	}
    }
    type = T_ADDED;
    if (walklist (changes, find_type, NULL) != 0)
    {
	(void) fprintf (fp, "%sAdded Files:\n", prefix);
	col = 0;
	(void) walklist (changes, fmt_proc, NULL);
	(void) fprintf (fp, "\n");
	if (tag != NULL)
	{
	    free (tag);
	    tag = NULL;
	}
    }
    type = T_REMOVED;
    if (walklist (changes, find_type, NULL) != 0)
    {
	(void) fprintf (fp, "%sRemoved Files:\n", prefix);
	col = 0;
	(void) walklist (changes, fmt_proc, NULL);
	(void) fprintf (fp, "\n");
	if (tag != NULL)
	{
	    free (tag);
	    tag = NULL;
	}
    }
}

/*
 * Looks for nodes of a specified type and returns 1 if found
 */
static int
find_type (Node *p, void *closure)
{
    struct logfile_info *li = p->data;

    if (li->type == type)
	return (1);
    else
	return (0);
}

/*
 * Breaks the files list into reasonable sized lines to avoid line wrap...
 * all in the name of pretty output.  It only works on nodes whose types
 * match the one we're looking for
 */
static int
fmt_proc (Node *p, void *closure)
{
    struct logfile_info *li;

    li = p->data;
    if (li->type == type)
    {
        if (li->tag == NULL
	    ? tag != NULL
	    : tag == NULL || strcmp (tag, li->tag) != 0)
	{
	    if (col > 0)
	        (void) fprintf (fp, "\n");
	    (void) fputs (prefix, fp);
	    col = strlen (prefix);
	    while (col < 6)
	    {
	        (void) fprintf (fp, " ");
		++col;
	    }

	    if (li->tag == NULL)
	        (void) fprintf (fp, "No tag");
	    else
	        (void) fprintf (fp, "Tag: %s", li->tag);

	    if (tag != NULL)
	        free (tag);
	    tag = xstrdup (li->tag);

	    /* Force a new line.  */
	    col = 70;
	}

	if (col == 0)
	{
	    (void) fprintf (fp, "%s\t", prefix);
	    col = 8;
	}
	else if (col > 8 && (col + (int) strlen (p->key)) > 70)
	{
	    (void) fprintf (fp, "\n%s\t", prefix);
	    col = 8;
	}
	(void) fprintf (fp, "%s ", p->key);
	col += strlen (p->key) + 1;
    }
    return (0);
}

/*
 * Builds a temporary file using setup_tmpfile() and invokes the user's
 * editor on the file.  The header garbage in the resultant file is then
 * stripped and the log message is stored in the "message" argument.
 *
 * If REPOSITORY is non-NULL, process rcsinfo for that repository; if it
 * is NULL, use the CVSADM_TEMPLATE file instead.  REPOSITORY should be
 * NULL when running in client mode.
 *
 * GLOBALS
 *   Editor     Set to a default value by configure and overridable using the
 *              -e option to the CVS executable.
 */
void
do_editor (const char *dir, char **messagep, const char *repository,
           List *changes)
{
    static int reuse_log_message = 0;
    char *line;
    int line_length;
    size_t line_chars_allocated;
    char *fname;
    struct stat pre_stbuf, post_stbuf;
    int retcode = 0;

#ifdef CLIENT_SUPPORT
    assert (!current_parsed_root->isremote != !repository);
#else
    assert (repository);
#endif

    if (noexec || reuse_log_message)
	return;

    /* Abort before creation of the temp file if no editor is defined. */
    if (strcmp (Editor, "") == 0)
        error(1, 0, "no editor defined, must use -e or -m");

  again:
    /* Create a temporary file.  */
    if( ( fp = cvs_temp_file( &fname ) ) == NULL )
	error( 1, errno, "cannot create temporary file" );

    if (*messagep)
    {
	(void) fputs (*messagep, fp);

	if ((*messagep)[0] == '\0' ||
	    (*messagep)[strlen (*messagep) - 1] != '\n')
	    (void) fprintf (fp, "\n");
    }
    else
	(void) fputc ('\n', fp);

    if (repository != NULL)
	/* tack templates on if necessary */
	(void) Parse_Info (CVSROOTADM_RCSINFO, repository, rcsinfo_proc,
		PIOPT_ALL, NULL);
    else
    {
	FILE *tfp;
	char buf[1024];
	size_t n;
	size_t nwrite;

	/* Why "b"?  */
	tfp = CVS_FOPEN (CVSADM_TEMPLATE, "rb");
	if (tfp == NULL)
	{
	    if (!existence_error (errno))
		error (1, errno, "cannot read %s", CVSADM_TEMPLATE);
	}
	else
	{
	    while (!feof (tfp))
	    {
		char *p = buf;
		n = fread (buf, 1, sizeof buf, tfp);
		nwrite = n;
		while (nwrite > 0)
		{
		    n = fwrite (p, 1, nwrite, fp);
		    nwrite -= n;
		    p += n;
		}
		if (ferror (tfp))
		    error (1, errno, "cannot read %s", CVSADM_TEMPLATE);
	    }
	    if (fclose (tfp) < 0)
		error (0, errno, "cannot close %s", CVSADM_TEMPLATE);
	}
    }

    (void) fprintf (fp,
  "%s----------------------------------------------------------------------\n",
		    CVSEDITPREFIX);
    (void) fprintf (fp,
  "%sEnter Log.  Lines beginning with `%.*s' are removed automatically\n%s\n",
		    CVSEDITPREFIX, CVSEDITPREFIXLEN, CVSEDITPREFIX,
		    CVSEDITPREFIX);
    if (dir != NULL && *dir)
	(void) fprintf (fp, "%sCommitting in %s\n%s\n", CVSEDITPREFIX,
			dir, CVSEDITPREFIX);
    if (changes != NULL)
	setup_tmpfile (fp, CVSEDITPREFIX, changes);
    (void) fprintf (fp,
  "%s----------------------------------------------------------------------\n",
		    CVSEDITPREFIX);

    /* finish off the temp file */
    if (fclose (fp) == EOF)
        error (1, errno, "%s", fname);
    if ( CVS_STAT (fname, &pre_stbuf) == -1)
	pre_stbuf.st_mtime = 0;

    /* run the editor */
    run_setup (Editor);
    run_arg (fname);
    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
			     RUN_NORMAL | RUN_SIGIGNORE)) != 0)
	error (0, retcode == -1 ? errno : 0, "warning: editor session failed");

    /* put the entire message back into the *messagep variable */

    fp = open_file (fname, "r");

    if (*messagep)
	free (*messagep);

    if ( CVS_STAT (fname, &post_stbuf) != 0)
	    error (1, errno, "cannot find size of temp file %s", fname);

    if (post_stbuf.st_size == 0)
	*messagep = NULL;
    else
    {
	/* On NT, we might read less than st_size bytes, but we won't
	   read more.  So this works.  */
	*messagep = (char *) xmalloc (post_stbuf.st_size + 1);
 	(*messagep)[0] = '\0';
    }

    line = NULL;
    line_chars_allocated = 0;

    if (*messagep)
    {
	size_t message_len = post_stbuf.st_size + 1;
	size_t offset = 0;
	while (1)
	{
	    line_length = getline (&line, &line_chars_allocated, fp);
	    if (line_length == -1)
	    {
		if (ferror (fp))
		    error (0, errno, "warning: cannot read %s", fname);
		break;
	    }
	    if (strncmp (line, CVSEDITPREFIX, CVSEDITPREFIXLEN) == 0)
		continue;
	    if (offset + line_length >= message_len)
		expand_string (messagep, &message_len,
				offset + line_length + 1);
	    (void) strcpy (*messagep + offset, line);
	    offset += line_length;
	}
    }
    if (fclose (fp) < 0)
	error (0, errno, "warning: cannot close %s", fname);

    /* canonicalize emply messages */
    if (*messagep != NULL &&
        (**messagep == '\0' || strcmp (*messagep, "\n") == 0))
    {
	free (*messagep);
	*messagep = NULL;
    }

    if (pre_stbuf.st_mtime == post_stbuf.st_mtime || *messagep == NULL)
    {
	for (;;)
	{
	    (void) printf ("\nLog message unchanged or not specified\n");
	    (void) printf ("a)bort, c)ontinue, e)dit, !)reuse this message unchanged for remaining dirs\n");
	    (void) printf ("Action: (continue) ");
	    (void) fflush (stdout);
	    line_length = getline (&line, &line_chars_allocated, stdin);
	    if (line_length < 0)
	    {
		error (0, errno, "cannot read from stdin");
		if (unlink_file (fname) < 0)
		    error (0, errno,
			   "warning: cannot remove temp file %s", fname);
		error (1, 0, "aborting");
	    }
	    else if (line_length == 0
		     || *line == '\n' || *line == 'c' || *line == 'C')
		break;
	    if (*line == 'a' || *line == 'A')
		{
		    if (unlink_file (fname) < 0)
			error (0, errno, "warning: cannot remove temp file %s", fname);
		    error (1, 0, "aborted by user");
		}
	    if (*line == 'e' || *line == 'E')
		goto again;
	    if (*line == '!')
	    {
		reuse_log_message = 1;
		break;
	    }
	    (void) printf ("Unknown input\n");
	}
    }
    if (line)
	free (line);
    if (unlink_file (fname) < 0)
	error (0, errno, "warning: cannot remove temp file %s", fname);
    free (fname);
}

/* Runs the user-defined verification script as part of the commit or import
   process.  This verification is meant to be run whether or not the user
   included the -m attribute.  unlike the do_editor function, this is
   independant of the running of an editor for getting a message.
 */
void
do_verify (char **messagep, const char *repository)
{
    int err;
    struct verifymsg_proc_data data;
    struct stat post_stbuf;

#ifdef CLIENT_SUPPORT
    if( current_parsed_root->isremote )
	/* The verification will happen on the server.  */
	return;
#endif

    /* FIXME? Do we really want to skip this on noexec?  What do we do
       for the other administrative files?  */
    /* EXPLAIN: Why do we check for repository == NULL here? */
    if (noexec || repository == NULL)
	return;

    /* Get the name of the verification script to run  */

    data.message = *messagep;
    data.fname = NULL;
    if ((err = Parse_Info (CVSROOTADM_VERIFYMSG, repository,
	                  verifymsg_proc, 0, &data)) != 0)
    {
	int saved_errno = errno;
	/* Since following error() exits, delete the temp file now.  */
	if (data.fname != NULL && unlink_file( data.fname ) < 0)
	    error (0, errno, "cannot remove %s", data.fname);
	free (data.fname);

	errno = saved_errno;
	error (1, err == -1 ? errno : 0, "Message verification failed");
    }

    /* Return if no temp file was created.  That means that we didn't call any
     * verifymsg scripts.
     */
    if (data.fname == NULL)
	return;

    /* Get the mod time and size of the possibly new log message
     * in always and stat modes.
     */
    if (config->RereadLogAfterVerify == LOGMSG_REREAD_ALWAYS ||
	config->RereadLogAfterVerify == LOGMSG_REREAD_STAT)
    {
	if(CVS_STAT (data.fname, &post_stbuf) != 0)
	    error (1, errno, "cannot find size of temp file %s", data.fname);
    }

    /* And reread the log message in `always' mode or in `stat' mode when it's
     * changed.
     */
    if (config->RereadLogAfterVerify == LOGMSG_REREAD_ALWAYS ||
	(config->RereadLogAfterVerify == LOGMSG_REREAD_STAT &&
	  (data.pre_stbuf.st_mtime != post_stbuf.st_mtime ||
	    data.pre_stbuf.st_size != post_stbuf.st_size)))
    {
	/* put the entire message back into the *messagep variable */

	if (*messagep) free (*messagep);

	if (post_stbuf.st_size == 0)
	    *messagep = NULL;
	else
	{
	    char *line = NULL;
	    int line_length;
	    size_t line_chars_allocated = 0;
	    char *p;
	    FILE *fp;

	    if ((fp = open_file (data.fname, "r")) == NULL)
		error (1, errno, "cannot open temporary file %s", data.fname);

	    /* On NT, we might read less than st_size bytes,
	       but we won't read more.  So this works.  */
	    p = *messagep = (char *) xmalloc (post_stbuf.st_size + 1);
	    *messagep[0] = '\0';

	    for (;;)
	    {
		line_length = getline( &line,
				       &line_chars_allocated,
				       fp);
		if (line_length == -1)
		{
		    if (ferror (fp))
			/* Fail in this case because otherwise we will have no
			 * log message
			 */
			error (1, errno, "cannot read %s", data.fname);
		    break;
		}
		if (strncmp (line, CVSEDITPREFIX, CVSEDITPREFIXLEN) == 0)
		    continue;
		(void) strcpy (p, line);
		p += line_length;
	    }
	    if (line) free (line);
	    if (fclose (fp) < 0)
	        error (0, errno, "warning: cannot close %s", data.fname);
	}
    }
    /* Delete the temp file  */
    if (unlink_file (data.fname) < 0)
	error (0, errno, "cannot remove `%s'", data.fname);
    free (data.fname);
}



/*
 * callback proc for Parse_Info for rcsinfo templates this routine basically
 * copies the matching template onto the end of the tempfile we are setting
 * up
 */
/* ARGSUSED */
static int
rcsinfo_proc (const char *repository, const char *template, void *closure)
{
    static char *last_template;
    FILE *tfp;

    /* nothing to do if the last one included is the same as this one */
    if (last_template && strcmp (last_template, template) == 0)
	return (0);
    if (last_template)
	free (last_template);
    last_template = xstrdup (template);

    if ((tfp = CVS_FOPEN (template, "r")) != NULL)
    {
	char *line = NULL;
	size_t line_chars_allocated = 0;

	while (getline (&line, &line_chars_allocated, tfp) >= 0)
	    (void) fputs (line, fp);
	if (ferror (tfp))
	    error (0, errno, "warning: cannot read %s", template);
	if (fclose (tfp) < 0)
	    error (0, errno, "warning: cannot close %s", template);
	if (line)
	    free (line);
	return (0);
    }
    else
    {
	error (0, errno, "Couldn't open rcsinfo template file %s", template);
	return (1);
    }
}

/*
 * Uses setup_tmpfile() to pass the updated message on directly to any
 * logfile programs that have a regular expression match for the checked in
 * directory in the source repository.  The log information is fed into the
 * specified program as standard input.
 */
struct ulp_data {
    FILE *logfp;
    const char *message;
    List *changes;
};



void
Update_Logfile (const char *repository, const char *xmessage, FILE *xlogfp,
                List *xchanges)
{
    struct ulp_data ud;

    /* nothing to do if the list is empty */
    if (xchanges == NULL || xchanges->list->next == xchanges->list)
	return;

    /* set up vars for update_logfile_proc */
    ud.message = xmessage;
    ud.logfp = xlogfp;
    ud.changes = xchanges;

    /* call Parse_Info to do the actual logfile updates */
    (void) Parse_Info (CVSROOTADM_LOGINFO, repository, update_logfile_proc,
		       PIOPT_ALL, &ud);
}



/*
 * callback proc to actually do the logfile write from Update_Logfile
 */
static int
update_logfile_proc (const char *repository, const char *filter, void *closure)
{
    struct ulp_data *udp = closure;
    TRACE (TRACE_FUNCTION, "update_logfile_proc(%s,%s)", repository, filter);
    return logfile_write (repository, filter, udp->message, udp->logfp,
                          udp->changes);
}



/* static int
 * logmsg_list_to_args_proc( Node *p, void *closure )
 * This function is intended to be passed into walklist() with a list of tags
 * (nodes in the same format as pretag_list_proc() accepts - p->key = tagname
 * and p->data = a revision.
 *
 * closure will be a struct format_cmdline_walklist_closure
 * where closure is undefined.
 */
static int
logmsg_list_to_args_proc (Node *p, void *closure)
{
    struct format_cmdline_walklist_closure *c = closure;
    struct logfile_info *li;
    char *arg = NULL;
    const char *f;
    char *d;
    size_t doff;

    if (p->data == NULL) return 1;

    f = c->format;
    d = *c->d;
    /* foreach requested attribute */
    while (*f)
    {
	switch (*f++)
	{
	    case 's':
		arg = p->key;
		break;
	    case 'V':
		li = p->data;
		arg = li->rev_old ? li->rev_old : "NONE";
		break;
	    case 'v':
		li = p->data;
		arg = li->rev_new ? li->rev_new : "NONE";
		break;
	    default:
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
		if (c->onearg)
		{
		    /* The old deafult was to print the empty string for
		     * unknown args.
		     */
		    arg = "\0";
		}
		else
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
		    error (1, 0,
		           "Unknown format character or not a list attribute: %c", f[-1]);
		/* NOTREACHED */
		break;
	}
	/* copy the attribute into an argument */
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	if (c->onearg)
	{
	    if (c->firstpass)
	    {
		c->firstpass = 0;
		doff = d - *c->buf;
		expand_string (c->buf, c->length,
		               doff + strlen (c->srepos) + 1);
		d = *c->buf + doff;
		strncpy (d, c->srepos, strlen (c->srepos));
		d += strlen (c->srepos);
	    	*d++ = ' ';
	    }
	}
	else /* c->onearg */
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	{
	    if (c->quotes)
	    {
		arg = cmdlineescape (c->quotes, arg);
	    }
	    else
	    {
		arg = cmdlinequote ('"', arg);
	    }
	} /* !c->onearg */
	doff = d - *c->buf;
	expand_string (c->buf, c->length, doff + strlen (arg));
	d = *c->buf + doff;
	strncpy (d, arg, strlen (arg));
	d += strlen (arg);
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	if (!c->onearg)
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	    free (arg);

	/* Always put the extra space on.  we'll have to back up a char
	 * when we're done, but that seems most efficient.
	 */
	doff = d - *c->buf;
	expand_string (c->buf, c->length, doff + 1);
	d = *c->buf + doff;
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	if (c->onearg && *f) *d++ = ',';
	else
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	    *d++ = ' ';
    }
    /* correct our original pointer into the buff */
    *c->d = d;
    return 0;
}



/*
 * Writes some stuff to the logfile "filter" and returns the status of the
 * filter program.
 */
static int
logfile_write (const char *repository, const char *filter, const char *message,
               FILE *logfp, List *changes)
{
    char *cmdline;
    FILE *pipefp;
    char *cp;
    int c;
    int pipestatus;
    const char *srepos = Short_Repository (repository);

    /* The user may specify a format string as part of the filter.
       Originally, `%s' was the only valid string.  The string that
       was substituted for it was:

         <repository-name> <file1> <file2> <file3> ...

       Each file was either a new directory/import (T_TITLE), or a
       added (T_ADDED), modified (T_MODIFIED), or removed (T_REMOVED)
       file.

       It is desirable to preserve that behavior so lots of commitlog
       scripts won't die when they get this new code.  At the same
       time, we'd like to pass other information about the files (like
       version numbers, statuses, or checkin times).

       The solution is to allow a format string that allows us to
       specify those other pieces of information.  The format string
       will be composed of `%' followed by a single format character,
       or followed by a set of format characters surrounded by `{' and
       `}' as separators.  The format characters are:

         s = file name
	 V = old version number (pre-checkin)
	 v = new version number (post-checkin)

       For example, valid format strings are:

         %{}
	 %s
	 %{s}
	 %{sVv}

       There's no reason that more items couldn't be added (like
       modification date or file status [added, modified, updated,
       etc.]) -- the code modifications would be minimal (logmsg.c
       (title_proc) and commit.c (check_fileproc)).

       The output will be a string of tokens separated by spaces.  For
       backwards compatibility, the the first token will be the
       repository name.  The rest of the tokens will be
       comma-delimited lists of the information requested in the
       format string.  For example, if `/u/src/master' is the
       repository, `%{sVv}' is the format string, and three files
       (ChangeLog, Makefile, foo.c) were modified, the output might
       be:

         /u/src/master ChangeLog,1.1,1.2 Makefile,1.3,1.4 foo.c,1.12,1.13

       Why this duplicates the old behavior when the format string is
       `%s' is left as an exercise for the reader. */

    /* %c = cvs_cmd_name
     * %p = shortrepos
     * %r = repository
     * %{sVv} = file name, old revision (precommit), new revision (postcommit)
     */
    cmdline = format_cmdline (
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	                      !config->UseNewInfoFmtStrings, srepos,
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	                      filter,
	                      "c", "s", cvs_cmd_name,
#ifdef SERVER_SUPPORT
	                      "R", "s", referrer ? referrer->original : "NONE",
#endif /* SERVER_SUPPORT */
	                      "p", "s", srepos,
	                      "r", "s", current_parsed_root->directory,
	                      "sVv", ",", changes,
			             logmsg_list_to_args_proc, (void *) NULL,
	                      (char *)NULL
	                     );
    if( !cmdline || !strlen( cmdline ) )
    {
	if( cmdline ) free( cmdline );
	error( 0, 0, "logmsg proc resolved to the empty string!" );
	return 1;
    }

    if( ( pipefp = run_popen( cmdline, "w" ) ) == NULL )
    {
	if (!noexec)
	    error( 0, 0, "cannot write entry to log filter: %s", cmdline );
	free( cmdline );
	return 1;
    }
    (void) fprintf (pipefp, "Update of %s\n", repository);
    (void) fprintf (pipefp, "In directory %s:", hostname);
    cp = xgetcwd ();
    if (cp == NULL)
	fprintf (pipefp, "<cannot get working directory: %s>\n\n",
		 strerror (errno));
    else
    {
	fprintf (pipefp, "%s\n\n", cp);
	free (cp);
    }

    setup_tmpfile (pipefp, "", changes);
    (void) fprintf (pipefp, "Log Message:\n%s\n", (message) ? message : "");
    if (logfp != (FILE *) 0)
    {
	(void) fprintf (pipefp, "Status:\n");
	rewind (logfp);
	while ((c = getc (logfp)) != EOF)
	    (void) putc ((char) c, pipefp);
    }
    free (cmdline);
    pipestatus = pclose (pipefp);
    return ((pipestatus == -1) || (pipestatus == 127)) ? 1 : 0;
}



/*  This routine is called by Parse_Info.  It runs the
 *  message verification script.
 */
static int
verifymsg_proc (const char *repository, const char *script, void *closure)
{
    char *verifymsg_script;
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
    char *newscript = NULL;
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
    struct verifymsg_proc_data *vpd = closure;
    const char *srepos = Short_Repository (repository);

#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
    if (!strchr (script, '%'))
    {
	error (0, 0,
	       "warning: verifymsg line doesn't contain any format strings:\n"
               "    \"%s\"\n"
               "Appending default format string (\" %%l\"), but be aware that this usage is\n"
               "deprecated.", script);
	newscript = xmalloc (strlen (script) + 4);
	strcpy (newscript, script);
	strcat (newscript, " %l");
	script = newscript;
    }
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */

    /* If we don't already have one, open a temporary file, write the message
     * to the temp file, and close the file.
     *
     * We do this here so that we only create the file when there is a
     * verifymsg script specified and we only create it once when there is
     * more than one verifymsg script specified.
     */
    if (vpd->fname == NULL)
    {
	FILE *fp;
	if ((fp = cvs_temp_file (&(vpd->fname))) == NULL)
	    error (1, errno, "cannot create temporary file %s", vpd->fname);

	if (vpd->message != NULL)
	    fputs (vpd->message, fp);
	if (vpd->message == NULL ||
	    (vpd->message)[0] == '\0' ||
	    (vpd->message)[strlen (vpd->message) - 1] != '\n')
	    putc ('\n', fp);
	if (fclose (fp) == EOF)
	    error (1, errno, "%s", vpd->fname);

	if (config->RereadLogAfterVerify == LOGMSG_REREAD_STAT)
	{
	    /* Remember the status of the temp file for later */
	    if (CVS_STAT (vpd->fname, &(vpd->pre_stbuf)) != 0)
		error (1, errno, "cannot stat temp file %s", vpd->fname);

	    /*
	     * See if we need to sleep before running the verification
	     * script to avoid time-stamp races.
	     */
	    sleep_past (vpd->pre_stbuf.st_mtime);
	}
    } /* if (vpd->fname == NULL) */

    verifymsg_script = format_cmdline (
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
                                       false, srepos,
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
                                       script,
				       "c", "s", cvs_cmd_name,
#ifdef SERVER_SUPPORT
				       "R", "s", referrer ? referrer->original
							  : "NONE",
#endif /* SERVER_SUPPORT */
                                       "p", "s", srepos,
                                       "r", "s",
                                       current_parsed_root->directory,
                                       "l", "s", vpd->fname,
                                       (char *)NULL
                                      );

#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
    if (newscript) free (newscript);
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */

    if (!verifymsg_script || !strlen (verifymsg_script))
    {
	if (verifymsg_script) free (verifymsg_script);
	verifymsg_script = NULL;
	error (0, 0, "verifymsg proc resolved to the empty string!");
	return 1;
    }

    run_setup (verifymsg_script);

    free (verifymsg_script);

    /* FIXME - because run_exec can return negative values and Parse_Info adds
     * the values of each call to this function to get a total error, we are
     * calling abs on the value of run_exec to ensure two errors do not sum to
     * zero.
     *
     * The only REALLY obnoxious thing about this, I guess, is that a -1 return
     * code from run_exec can mean we failed to call the process for some
     * reason and should care about errno or that the process we called
     * returned -1 and the value of errno is undefined.  In other words,
     * run_exec should probably be rewritten to have two return codes.  one
     * which is its own exit status and one which is the child process's.  So
     * there.  :P
     *
     * Once run_exec is returning two error codes, we should probably be
     * failing here with an error message including errno when we get the
     * return code which means we care about errno, in case you missed that
     * little tidbit.
     *
     * I do happen to know we just fail for a non-zero value anyway and I
     * believe the docs actually state that if the verifymsg_proc returns a
     * "non-zero" value we will fail.
     */
    return abs (run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
			  RUN_NORMAL | RUN_SIGIGNORE));
}
@


1.4
log
@update to cvs 1.12.10-MirOS except automatically
generated files
XXX this installs as /usr/bin/ncvs yet, so no
XXX conflicts during the test phase.
XXX I suggest to _not_ update.

XXX *** IMPORTANT *** DO NOT ACCESS CVS 1.11 REPOSITORIES
XXX *** IMPORTANT *** WITH CVS 1.12 OR VICE VERSA!
@
text
@d1 2
d6 1
a6 1
 * 
d15 2
d180 1
a180 1
 * 
d227 2
d397 3
a399 3
/* Runs the user-defined verification script as part of the commit or import 
   process.  This verification is meant to be run whether or not the user 
   included the -m attribute.  unlike the do_editor function, this is 
@


1.3
log
@cvs-1.11.12 doesn't do the joints correctly (what were the
FSF people smoking?), it memory faults.
thusly revert to 1.11.1p1

tested.
agreed bsiegert@@
@
text
@d9 1
d13 12
a24 10
static int find_type PROTO((Node * p, void *closure));
static int fmt_proc PROTO((Node * p, void *closure));
static int logfile_write PROTO((char *repository, char *filter,
			  char *message, FILE * logfp, List * changes));
static int rcsinfo_proc PROTO((char *repository, char *template));
static int title_proc PROTO((Node * p, void *closure));
static int update_logfile_proc PROTO((char *repository, char *filter));
static void setup_tmpfile PROTO((FILE * xfp, char *xprefix, List * changes));
static int editinfo_proc PROTO((char *repository, char *template));
static int verifymsg_proc PROTO((char *repository, char *script));
a26 4
static char *str_list;
static char *str_list_format;	/* The format for str_list's contents. */
static char *editinfo_editor;
static char *verifymsg_script;
d29 18
d55 1
a55 4
setup_tmpfile (xfp, xprefix, changes)
    FILE *xfp;
    char *xprefix;
    List *changes;
d106 1
a106 3
find_type (p, closure)
    Node *p;
    void *closure;
d108 1
a108 1
    struct logfile_info *li;
a109 1
    li = (struct logfile_info *) p->data;
d122 1
a122 3
fmt_proc (p, closure)
    Node *p;
    void *closure;
d126 1
a126 1
    li = (struct logfile_info *) p->data;
d135 1
a135 1
	    (void) fprintf (fp, "%s", prefix);
d178 6
a183 1
 * is NULL, use the CVSADM_TEMPLATE file instead.
d186 2
a187 5
do_editor (dir, messagep, repository, changes)
    char *dir;
    char **messagep;
    char *repository;
    List *changes;
d197 6
d206 4
a209 9
    /* Abort creation of temp file if no editor is defined */
    if (strcmp (Editor, "") == 0 && !editinfo_editor)
	error(1, 0, "no editor defined, must use -e or -m");

    /* Create a temporary file */
    /* FIXME - It's possible we should be relying on cvs_temp_file to open
     * the file here - we get race conditions otherwise.
     */
    fname = cvs_temp_name ();
d211 3
a213 2
    if ((fp = CVS_FOPEN (fname, "w+")) == NULL)
	error (1, 0, "cannot create temporary file %s", fname);
d217 1
a217 1
	(void) fprintf (fp, "%s", *messagep);
a222 2
    else
	(void) fprintf (fp, "\n");
d226 2
a227 1
	(void) Parse_Info (CVSROOTADM_RCSINFO, repository, rcsinfo_proc, 1);
a284 11
    if (editinfo_editor)
	free (editinfo_editor);
    editinfo_editor = (char *) NULL;
#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
	; /* nothing, leave editinfo_editor NULL */
    else
#endif
    if (repository != NULL)
	(void) Parse_Info (CVSROOTADM_EDITINFO, repository, editinfo_proc, 0);

d286 1
a286 1
    run_setup (editinfo_editor ? editinfo_editor : Editor);
d290 1
a290 3
	error (editinfo_editor ? 1 : 0, retcode == -1 ? errno : 0,
	       editinfo_editor ? "Logfile verification failed" :
	       "warning: editor session failed");
d309 1
a309 1
 	*messagep[0] = '\0';
d340 9
a348 3
    if (pre_stbuf.st_mtime == post_stbuf.st_mtime ||
	*messagep == NULL ||
	strcmp (*messagep, "\n") == 0)
d393 1
a393 1
   included the -m atribute.  unlike the do_editor function, this is 
d397 1
a397 3
do_verify (message, repository)
    char *message;
    char *repository;
d399 3
a401 3
    FILE *fp;
    char *fname;
    int retcode = 0;
d404 1
a404 1
    if (current_parsed_root->isremote)
d411 2
a412 1
    if (noexec)
d415 6
a420 3
    /* If there's no message, then we have nothing to verify.  Can this
       case happen?  And if so why would we print a message?  */
    if (message == NULL)
d422 8
a429 2
	cvs_output ("No message to verify\n", 0);
	return;
d432 5
a436 2
    /* open a temporary file, write the message to the 
       temp file, and close the file.  */
d438 5
a442 3
    if ((fp = cvs_temp_file (&fname)) == NULL)
	error (1, errno, "cannot create temporary file %s", fname);
    else
d444 3
a446 6
	fprintf (fp, "%s", message);
	if ((message)[0] == '\0' ||
	    (message)[strlen (message) - 1] != '\n')
	    (void) fprintf (fp, "%s", "\n");
	if (fclose (fp) == EOF)
	    error (1, errno, "%s", fname);
d448 9
a456 1
	/* Get the name of the verification script to run  */
d458 1
a458 3
	if (repository != NULL)
	    (void) Parse_Info (CVSROOTADM_VERIFYMSG, repository, 
			       verifymsg_proc, 0);
d460 17
a476 1
	/* Run the verification script  */
d478 1
a478 6
	if (verifymsg_script)
	{
	    run_setup (verifymsg_script);
	    run_arg (fname);
	    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
				     RUN_NORMAL | RUN_SIGIGNORE)) != 0)
d480 16
a495 7
		/* Since following error() exits, delete the temp file
		   now.  */
		if (unlink_file (fname) < 0)
		    error (0, errno, "cannot remove %s", fname);

		error (1, retcode == -1 ? errno : 0, 
		       "Message verification failed");
d497 3
d501 6
a507 1
	/* Delete the temp file  */
a508 5
	if (unlink_file (fname) < 0)
	    error (0, errno, "cannot remove %s", fname);
	free (fname);
    }
}
d517 1
a517 3
rcsinfo_proc (repository, template)
    char *repository;
    char *template;
d557 7
a563 3
static FILE *logfp;
static char *message;
static List *changes;
d566 2
a567 5
Update_Logfile (repository, xmessage, xlogfp, xchanges)
    char *repository;
    char *xmessage;
    FILE *xlogfp;
    List *xchanges;
d569 2
d575 4
a578 4
    /* set up static vars for update_logfile_proc */
    message = xmessage;
    logfp = xlogfp;
    changes = xchanges;
d581 2
a582 1
    (void) Parse_Info (CVSROOTADM_LOGINFO, repository, update_logfile_proc, 1);
d585 2
d591 1
a591 3
update_logfile_proc (repository, filter)
    char *repository;
    char *filter;
d593 4
a596 1
    return (logfile_write (repository, filter, message, logfp, changes));
d599 10
a608 2
/*
 * concatenate each filename/version onto str_list
d611 1
a611 3
title_proc (p, closure)
    Node *p;
    void *closure;
d613 1
d615 11
a625 4
    char *c;

    li = (struct logfile_info *) p->data;
    if (li->type == type)
d627 28
a654 14
	/* Until we decide on the correct logging solution when we add
	   directories or perform imports, T_TITLE nodes will only
	   tack on the name provided, regardless of the format string.
	   You can verify that this assumption is safe by checking the
	   code in add.c (add_directory) and import.c (import). */

	str_list = xrealloc (str_list, strlen (str_list) + 5);
	(void) strcat (str_list, " ");

	if (li->type == T_TITLE)
	{
	    str_list = xrealloc (str_list,
				 strlen (str_list) + strlen (p->key) + 5);
	    (void) strcat (str_list, p->key);
d656 3
a658 1
	else
d660 1
a660 3
	    /* All other nodes use the format string. */

	    for (c = str_list_format; *c != '\0'; c++)
d662 8
a669 39
		switch (*c)
		{
		case 's':
		    str_list =
			xrealloc (str_list,
				  strlen (str_list) + strlen (p->key) + 5);
		    (void) strcat (str_list, p->key);
		    break;
		case 'V':
		    str_list =
			xrealloc (str_list,
				  (strlen (str_list)
				   + (li->rev_old ? strlen (li->rev_old) : 0)
				   + 10)
				  );
		    (void) strcat (str_list, (li->rev_old
					      ? li->rev_old : "NONE"));
		    break;
		case 'v':
		    str_list =
			xrealloc (str_list,
				  (strlen (str_list)
				   + (li->rev_new ? strlen (li->rev_new) : 0)
				   + 10)
				  );
		    (void) strcat (str_list, (li->rev_new
					      ? li->rev_new : "NONE"));
		    break;
		/* All other characters, we insert an empty field (but
		   we do put in the comma separating it from other
		   fields).  This way if future CVS versions add formatting
		   characters, one can write a loginfo file which at least
		   won't blow up on an old CVS.  */
		}
		if (*(c + 1) != '\0')
		{
		    str_list = xrealloc (str_list, strlen (str_list) + 5);
		    (void) strcat (str_list, ",");
		}
d672 33
d706 3
a708 1
    return (0);
d711 2
d718 2
a719 6
logfile_write (repository, filter, message, logfp, changes)
    char *repository;
    char *filter;
    char *message;
    FILE *logfp;
    List *changes;
d721 1
a722 1
    char *prog;
d726 1
a726 2
    char *fmt_percent;		/* the location of the percent sign
				   that starts the format string. */
d779 25
a803 113
    fmt_percent = strchr (filter, '%');
    if (fmt_percent)
    {
	int len;
	char *srepos;
	char *fmt_begin, *fmt_end;	/* beginning and end of the
					   format string specified in
					   filter. */
	char *fmt_continue;		/* where the string continues
					   after the format string (we
					   might skip a '}') somewhere
					   in there... */

	/* Grab the format string. */

	if ((*(fmt_percent + 1) == ' ') || (*(fmt_percent + 1) == '\0'))
	{
	    /* The percent stands alone.  This is an error.  We could
	       be treating ' ' like any other formatting character, but
	       using it as a formatting character seems like it would be
	       a mistake.  */

	    /* Would be nice to also be giving the line number.  */
	    error (0, 0, "loginfo: '%%' not followed by formatting character");
	    fmt_begin = fmt_percent + 1;
	    fmt_end = fmt_begin;
	    fmt_continue = fmt_begin;
	}
	else if (*(fmt_percent + 1) == '{')
	{
	    /* The percent has a set of characters following it. */

	    fmt_begin = fmt_percent + 2;
	    fmt_end = strchr (fmt_begin, '}');
	    if (fmt_end)
	    {
		/* Skip over the '}' character. */

		fmt_continue = fmt_end + 1;
	    }
	    else
	    {
		/* There was no close brace -- assume that format
                   string continues to the end of the line. */

		/* Would be nice to also be giving the line number.  */
		error (0, 0, "loginfo: '}' missing");
		fmt_end = fmt_begin + strlen (fmt_begin);
		fmt_continue = fmt_end;
	    }
	}
	else
	{
	    /* The percent has a single character following it.  FIXME:
	       %% should expand to a regular percent sign.  */

	    fmt_begin = fmt_percent + 1;
	    fmt_end = fmt_begin + 1;
	    fmt_continue = fmt_end;
	}

	len = fmt_end - fmt_begin;
	str_list_format = xmalloc (len + 1);
	strncpy (str_list_format, fmt_begin, len);
	str_list_format[len] = '\0';

	/* Allocate an initial chunk of memory.  As we build up the string
	   we will realloc it.  */
	if (!str_list)
	    str_list = xmalloc (1);
	str_list[0] = '\0';

	/* Add entries to the string.  Don't bother looking for
           entries if the format string is empty. */

	if (str_list_format[0] != '\0')
	{
	    type = T_TITLE;
	    (void) walklist (changes, title_proc, NULL);
	    type = T_ADDED;
	    (void) walklist (changes, title_proc, NULL);
	    type = T_MODIFIED;
	    (void) walklist (changes, title_proc, NULL);
	    type = T_REMOVED;
	    (void) walklist (changes, title_proc, NULL);
	}

	free (str_list_format);
	
	/* Construct the final string. */

	srepos = Short_Repository (repository);

	prog = cp = xmalloc ((fmt_percent - filter) + 2 * strlen (srepos)
			+ 2 * strlen (str_list) + strlen (fmt_continue)
			+ 10);
	(void) memcpy (cp, filter, fmt_percent - filter);
	cp += fmt_percent - filter;
	*cp++ = '"';
	cp = shell_escape (cp, srepos);
	cp = shell_escape (cp, str_list);
	*cp++ = '"';
	(void) strcpy (cp, fmt_continue);
	    
	/* To be nice, free up some memory. */

	free (str_list);
	str_list = (char *) NULL;
    }
    else
    {
	/* There's no format string. */
	prog = xstrdup (filter);
d806 1
a806 1
    if ((pipefp = run_popen (prog, "w")) == NULL)
d809 3
a811 3
	    error (0, 0, "cannot write entry to log filter: %s", prog);
	free (prog);
	return (1);
d815 1
a815 1
    cp = xgetwd ();
d826 1
a826 1
    (void) fprintf (pipefp, "Log Message:\n%s\n", message);
d834 1
a834 1
    free (prog);
a838 19
/*
 * We choose to use the *last* match within the editinfo file for this
 * repository.  This allows us to have a global editinfo program for the
 * root of some hierarchy, for example, and different ones within different
 * sub-directories of the root (like a special checker for changes made to
 * the "src" directory versus changes made to the "doc" or "test"
 * directories.
 */
/* ARGSUSED */
static int
editinfo_proc(repository, editor)
    char *repository;
    char *editor;
{
    /* nothing to do if the last match is the same as this one */
    if (editinfo_editor && strcmp (editinfo_editor, editor) == 0)
	return (0);
    if (editinfo_editor)
	free (editinfo_editor);
a839 3
    editinfo_editor = xstrdup (editor);
    return (0);
}
d841 2
a842 2
/*  This routine is calld by Parse_Info.  it asigns the name of the
 *  message verification script to the global variable verify_script
d845 1
a845 3
verifymsg_proc (repository, script)
    char *repository;
    char *script;
d847 115
a961 6
    if (verifymsg_script && strcmp (verifymsg_script, script) == 0)
	return (0);
    if (verifymsg_script)
	free (verifymsg_script);
    verifymsg_script = xstrdup (script);
    return (0);
@


1.2
log
@first step of merging new cvs
XXX might not compile
XXX might not work
XXX might contain bugs
XXX definitively needs autoconf 2.58 first
@
text
@a8 2
#include <assert.h>

a29 9
/* 
 * Should the logmsg be re-read during the do_verify phase?
 * RereadLogAfterVerify=no|stat|yes
 * LOGMSG_REREAD_NEVER  - never re-read the logmsg
 * LOGMSG_REREAD_STAT   - re-read the logmsg only if it has changed
 * LOGMSG_REREAD_ALWAYS - always re-read the logmsg
 */
int RereadLogAfterVerify = LOGMSG_REREAD_ALWAYS;

d126 1
a126 1
	    (void) fputs (prefix, fp);
d169 1
a169 2
 * is NULL, use the CVSADM_TEMPLATE file instead.  REPOSITORY should be
 * NULL when running in client mode.
a185 6
#ifdef CLIENT_SUPPORT
    assert (!current_parsed_root->isremote != !repository);
#else
    assert (repository);
#endif

d204 1
a204 1
	(void) fputs (*messagep, fp);
d310 1
a310 1
 	(*messagep)[0] = '\0';
d341 3
a343 9
    /* canonicalize emply messages */
    if (*messagep != NULL &&
        (**messagep == '\0' || strcmp (*messagep, "\n") == 0))
    {
	free (*messagep);
	*messagep = NULL;
    }

    if (pre_stbuf.st_mtime == post_stbuf.st_mtime || *messagep == NULL)
d392 2
a393 2
do_verify (messagep, repository)
    char **messagep;
a399 2
    struct stat pre_stbuf, post_stbuf;

d408 1
a408 1
    if (noexec || repository == NULL)
d411 5
a415 6
    /* Get the name of the verification script to run  */

    if (Parse_Info (CVSROOTADM_VERIFYMSG, repository, verifymsg_proc, 0) > 0)
	error (1, 0, "Message verification failed");

    if (!verifymsg_script)
d417 1
d424 28
d453 4
a456 8
    if (*messagep != NULL)
	fputs (*messagep, fp);
    if (*messagep == NULL ||
	(*messagep)[0] == '\0' ||
	(*messagep)[strlen (*messagep) - 1] != '\n')
	putc ('\n', fp);
    if (fclose (fp) == EOF)
	error (1, errno, "%s", fname);
d458 1
a458 12
    if (RereadLogAfterVerify == LOGMSG_REREAD_STAT)
    {
	/* Remember the status of the temp file for later */
	if ( CVS_STAT (fname, &pre_stbuf) != 0 )
	    error (1, errno, "cannot stat temp file %s", fname);

	/*
	 * See if we need to sleep before running the verification
	 * script to avoid time-stamp races.
	 */
	sleep_past (pre_stbuf.st_mtime);
    }
a459 6
    run_setup (verifymsg_script);
    run_arg (fname);
    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
			     RUN_NORMAL | RUN_SIGIGNORE)) != 0)
    {
	/* Since following error() exits, delete the temp file now.  */
d462 1
a462 3

	error (1, retcode == -1 ? errno : 0, 
	       "Message verification failed");
a463 72

    /* Get the mod time and size of the possibly new log message
     * in always and stat modes.
     */
    if (RereadLogAfterVerify == LOGMSG_REREAD_ALWAYS ||
	RereadLogAfterVerify == LOGMSG_REREAD_STAT)
    {
	if ( CVS_STAT (fname, &post_stbuf) != 0 )
	    error (1, errno, "cannot find size of temp file %s", fname);
    }

    /* And reread the log message in `always' mode or in `stat' mode when it's
     * changed
     */
    if (RereadLogAfterVerify == LOGMSG_REREAD_ALWAYS ||
	(RereadLogAfterVerify == LOGMSG_REREAD_STAT &&
	    (pre_stbuf.st_mtime != post_stbuf.st_mtime ||
	     pre_stbuf.st_size != post_stbuf.st_size)))
    {
	/* put the entire message back into the *messagep variable */

	if (*messagep) free (*messagep);

	if (post_stbuf.st_size == 0)
	    *messagep = NULL;
	else
	{
	    char *line = NULL;
	    int line_length;
	    size_t line_chars_allocated = 0;
	    char *p;

	    if ( (fp = open_file (fname, "r")) == NULL )
		error (1, errno, "cannot open temporary file %s", fname);

	    /* On NT, we might read less than st_size bytes,
	       but we won't read more.  So this works.  */
	    p = *messagep = (char *) xmalloc (post_stbuf.st_size + 1);
	    *messagep[0] = '\0';

	    while (1)
	    {
		line_length = getline (&line,
				       &line_chars_allocated,
				       fp);
		if (line_length == -1)
		{
		    if (ferror (fp))
			/* Fail in this case because otherwise we will have no
			 * log message
			 */
			error (1, errno, "cannot read %s", fname);
		    break;
		}
		if (strncmp (line, CVSEDITPREFIX, CVSEDITPREFIXLEN) == 0)
		    continue;
		(void) strcpy (p, line);
		p += line_length;
	    }
	    if (line) free (line);
	    if (fclose (fp) < 0)
	        error (0, errno, "warning: cannot close %s", fname);
	}
    }

    /* Delete the temp file  */

    if (unlink_file (fname) < 0)
	error (0, errno, "cannot remove %s", fname);
    free (fname);
    free( verifymsg_script );
    verifymsg_script = NULL;
a617 5
		/* Note that people who have to deal with spaces in file
		   and directory names are using space to get a known
		   delimiter for the directory name, so it's probably
		   not a good idea to ever define that as a formatting
		   character.  */
d836 1
a836 1
    (void) fprintf (pipefp, "Log Message:\n%s\n", (message) ? message : "");
@


1.1
log
@Initial revision
@
text
@d9 2
d32 9
d137 1
a137 1
	    (void) fprintf (fp, "%s", prefix);
d180 2
a181 1
 * is NULL, use the CVSADM_TEMPLATE file instead.
d198 6
d222 1
a222 1
	(void) fprintf (fp, "%s", *messagep);
d328 1
a328 1
 	*messagep[0] = '\0';
d359 9
a367 3
    if (pre_stbuf.st_mtime == post_stbuf.st_mtime ||
	*messagep == NULL ||
	strcmp (*messagep, "\n") == 0)
d416 2
a417 2
do_verify (message, repository)
    char *message;
d424 2
d434 1
a434 1
    if (noexec)
d437 6
a442 5
    /* If there's no message, then we have nothing to verify.  Can this
       case happen?  And if so why would we print a message?  */
    if (message == NULL)
    {
	cvs_output ("No message to verify\n", 0);
a443 1
    }
d450 53
a502 1
    else
d504 22
a525 21
	fprintf (fp, "%s", message);
	if ((message)[0] == '\0' ||
	    (message)[strlen (message) - 1] != '\n')
	    (void) fprintf (fp, "%s", "\n");
	if (fclose (fp) == EOF)
	    error (1, errno, "%s", fname);

	/* Get the name of the verification script to run  */

	if (repository != NULL)
	    (void) Parse_Info (CVSROOTADM_VERIFYMSG, repository, 
			       verifymsg_proc, 0);

	/* Run the verification script  */

	if (verifymsg_script)
	{
	    run_setup (verifymsg_script);
	    run_arg (fname);
	    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
				     RUN_NORMAL | RUN_SIGIGNORE)) != 0)
d527 16
a542 7
		/* Since following error() exits, delete the temp file
		   now.  */
		if (unlink_file (fname) < 0)
		    error (0, errno, "cannot remove %s", fname);

		error (1, retcode == -1 ? errno : 0, 
		       "Message verification failed");
d544 3
d548 1
d550 1
a550 1
	/* Delete the temp file  */
d552 5
a556 4
	if (unlink_file (fname) < 0)
	    error (0, errno, "cannot remove %s", fname);
	free (fname);
    }
d711 5
d934 1
a934 1
    (void) fprintf (pipefp, "Log Message:\n%s\n", message);
@


1.1.2.1
log
@vendor-branch-ify new cvs 1.12
@
text
@a8 1

d12 10
a21 12
static int find_type (Node * p, void *closure);
static int fmt_proc (Node * p, void *closure);
static int logfile_write (const char *repository, const char *filter,
			  const char *message, FILE * logfp, List * changes);
static int logmsg_list_to_args_proc (Node *p, void *closure);
static int rcsinfo_proc (const char *repository, const char *template,
                         void *closure );
static int update_logfile_proc (const char *repository, const char *filter,
                                void *closure);
static void setup_tmpfile (FILE * xfp, char *xprefix, List * changes);
static int verifymsg_proc (const char *repository, const char *script,
                           void *closure );
d24 4
a29 18
struct verifymsg_proc_data
{
    /* The name of the temp file storing the log message to be verified.  This
     * is initially NULL and verifymsg_proc() writes message into it so that it
     * can be shared when multiple verifymsg scripts exist.  do_verify() is
     * responsible for rereading the message from the file when
     * RereadLogAfterVerify is in effect and the file has changed.
     */
    char *fname;
    /* The initial message text to be verified.
     */
    char *message;
    /* The initial stats of the temp file so we can tell that the temp file has
     * been changed when RereadLogAfterVerify is STAT.
     */
    struct stat pre_stbuf;
};

d38 4
a41 1
setup_tmpfile (FILE *xfp, char *xprefix, List *changes)
d92 3
a94 1
find_type (Node *p, void *closure)
d96 1
a96 1
    struct logfile_info *li = p->data;
d98 1
d111 3
a113 1
fmt_proc (Node *p, void *closure)
d117 1
a117 1
    li = p->data;
d126 1
a126 1
	    (void) fputs (prefix, fp);
d169 1
a169 6
 * is NULL, use the CVSADM_TEMPLATE file instead.  REPOSITORY should be
 * NULL when running in client mode.
 *
 * GLOBALS
 *   Editor     Set to a default value by configure and overridable using the
 *              -e option to the CVS executable.
d172 5
a176 2
do_editor (const char *dir, char **messagep, const char *repository,
           List *changes)
a185 6
#ifdef CLIENT_SUPPORT
    assert (!current_parsed_root->isremote != !repository);
#else
    assert (repository);
#endif

d189 9
a197 4
    /* Abort before creation of the temp file if no editor is defined. */
    if (strcmp (Editor, "") == 0)
        error(1, 0, "no editor defined, must use -e or -m");

d199 2
a200 3
    /* Create a temporary file.  */
    if( ( fp = cvs_temp_file( &fname ) ) == NULL )
	error( 1, errno, "cannot create temporary file" );
d204 1
a204 1
	(void) fputs (*messagep, fp);
d210 2
d215 1
a215 2
	(void) Parse_Info (CVSROOTADM_RCSINFO, repository, rcsinfo_proc,
		PIOPT_ALL, NULL);
d273 11
d285 1
a285 1
    run_setup (Editor);
d289 3
a291 1
	error (0, retcode == -1 ? errno : 0, "warning: editor session failed");
d310 1
a310 1
 	(*messagep)[0] = '\0';
d341 3
a343 9
    /* canonicalize emply messages */
    if (*messagep != NULL &&
        (**messagep == '\0' || strcmp (*messagep, "\n") == 0))
    {
	free (*messagep);
	*messagep = NULL;
    }

    if (pre_stbuf.st_mtime == post_stbuf.st_mtime || *messagep == NULL)
d388 1
a388 1
   included the -m attribute.  unlike the do_editor function, this is 
d392 3
a394 1
do_verify (char **messagep, const char *repository)
d396 3
a398 3
    int err;
    struct verifymsg_proc_data data;
    struct stat post_stbuf;
d401 1
a401 1
    if( current_parsed_root->isremote )
d408 1
a408 2
    /* EXPLAIN: Why do we check for repository == NULL here? */
    if (noexec || repository == NULL)
d411 3
a413 6
    /* Get the name of the verification script to run  */

    data.message = *messagep;
    data.fname = NULL;
    if ((err = Parse_Info (CVSROOTADM_VERIFYMSG, repository,
	                  verifymsg_proc, 0, &data)) != 0)
d415 2
a416 8
	int saved_errno = errno;
	/* Since following error() exits, delete the temp file now.  */
	if (data.fname != NULL && unlink_file( data.fname ) < 0)
	    error (0, errno, "cannot remove %s", data.fname);
	free (data.fname);

	errno = saved_errno;
	error (1, err == -1 ? errno : 0, "Message verification failed");
d419 2
a420 5
    /* Return if no temp file was created.  That means that we didn't call any
     * verifymsg scripts.
     */
    if (data.fname == NULL)
	return;
d422 3
a424 5
    /* Get the mod time and size of the possibly new log message
     * in always and stat modes.
     */
    if (config->RereadLogAfterVerify == LOGMSG_REREAD_ALWAYS ||
	config->RereadLogAfterVerify == LOGMSG_REREAD_STAT)
d426 8
a433 3
	if(CVS_STAT (data.fname, &post_stbuf) != 0)
	    error (1, errno, "cannot find size of temp file %s", data.fname);
    }
d435 3
a437 9
    /* And reread the log message in `always' mode or in `stat' mode when it's
     * changed.
     */
    if (config->RereadLogAfterVerify == LOGMSG_REREAD_ALWAYS ||
	(config->RereadLogAfterVerify == LOGMSG_REREAD_STAT &&
	  (data.pre_stbuf.st_mtime != post_stbuf.st_mtime ||
	    data.pre_stbuf.st_size != post_stbuf.st_size)))
    {
	/* put the entire message back into the *messagep variable */
d439 1
a439 1
	if (*messagep) free (*messagep);
d441 1
a441 3
	if (post_stbuf.st_size == 0)
	    *messagep = NULL;
	else
d443 9
a451 13
	    char *line = NULL;
	    int line_length;
	    size_t line_chars_allocated = 0;
	    char *p;
	    FILE *fp;

	    if ((fp = open_file (data.fname, "r")) == NULL)
		error (1, errno, "cannot open temporary file %s", data.fname);

	    /* On NT, we might read less than st_size bytes,
	       but we won't read more.  So this works.  */
	    p = *messagep = (char *) xmalloc (post_stbuf.st_size + 1);
	    *messagep[0] = '\0';
d453 2
a454 18
	    for (;;)
	    {
		line_length = getline( &line,
				       &line_chars_allocated,
				       fp);
		if (line_length == -1)
		{
		    if (ferror (fp))
			/* Fail in this case because otherwise we will have no
			 * log message
			 */
			error (1, errno, "cannot read %s", data.fname);
		    break;
		}
		if (strncmp (line, CVSEDITPREFIX, CVSEDITPREFIXLEN) == 0)
		    continue;
		(void) strcpy (p, line);
		p += line_length;
a455 3
	    if (line) free (line);
	    if (fclose (fp) < 0)
	        error (0, errno, "warning: cannot close %s", data.fname);
d457 6
a463 4
    /* Delete the temp file  */
    if (unlink_file (data.fname) < 0)
	error (0, errno, "cannot remove `%s'", data.fname);
    free (data.fname);
a465 2


d473 3
a475 1
rcsinfo_proc (const char *repository, const char *template, void *closure)
d515 3
a517 7
struct ulp_data {
    FILE *logfp;
    const char *message;
    List *changes;
};


d520 5
a524 2
Update_Logfile (const char *repository, const char *xmessage, FILE *xlogfp,
                List *xchanges)
a525 2
    struct ulp_data ud;

d530 4
a533 4
    /* set up vars for update_logfile_proc */
    ud.message = xmessage;
    ud.logfp = xlogfp;
    ud.changes = xchanges;
d536 1
a536 2
    (void) Parse_Info (CVSROOTADM_LOGINFO, repository, update_logfile_proc,
		       PIOPT_ALL, &ud);
a538 2


d543 3
a545 1
update_logfile_proc (const char *repository, const char *filter, void *closure)
d547 1
a547 4
    struct ulp_data *udp = closure;
    TRACE (TRACE_FUNCTION, "update_logfile_proc(%s,%s)", repository, filter);
    return logfile_write (repository, filter, udp->message, udp->logfp,
                          udp->changes);
d550 2
a551 10


/* static int
 * logmsg_list_to_args_proc( Node *p, void *closure )
 * This function is intended to be passed into walklist() with a list of tags
 * (nodes in the same format as pretag_list_proc() accepts - p->key = tagname
 * and p->data = a revision.
 *
 * closure will be a struct format_cmdline_walklist_closure
 * where closure is undefined.
d554 3
a556 1
logmsg_list_to_args_proc (Node *p, void *closure)
a557 1
    struct format_cmdline_walklist_closure *c = closure;
d559 4
a562 11
    char *arg = NULL;
    const char *f;
    char *d;
    size_t doff;

    if (p->data == NULL) return 1;

    f = c->format;
    d = *c->d;
    /* foreach requested attribute */
    while (*f)
d564 16
a579 1
	switch (*f++)
d581 39
a619 14
	    case 's':
		arg = p->key;
		break;
	    case 'V':
		li = p->data;
		arg = li->rev_old ? li->rev_old : "NONE";
		break;
	    case 'v':
		li = p->data;
		arg = li->rev_new ? li->rev_new : "NONE";
		break;
	    default:
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
		if (c->onearg)
d621 2
a622 4
		    /* The old deafult was to print the empty string for
		     * unknown args.
		     */
		    arg = "\0";
a623 21
		else
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
		    error (1, 0,
		           "Unknown format character or not a list attribute: %c", f[-1]);
		/* NOTREACHED */
		break;
	}
	/* copy the attribute into an argument */
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	if (c->onearg)
	{
	    if (c->firstpass)
	    {
		c->firstpass = 0;
		doff = d - *c->buf;
		expand_string (c->buf, c->length,
		               doff + strlen (c->srepos) + 1);
		d = *c->buf + doff;
		strncpy (d, c->srepos, strlen (c->srepos));
		d += strlen (c->srepos);
	    	*d++ = ' ';
a625 33
	else /* c->onearg */
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	{
	    if (c->quotes)
	    {
		arg = cmdlineescape (c->quotes, arg);
	    }
	    else
	    {
		arg = cmdlinequote ('"', arg);
	    }
	} /* !c->onearg */
	doff = d - *c->buf;
	expand_string (c->buf, c->length, doff + strlen (arg));
	d = *c->buf + doff;
	strncpy (d, arg, strlen (arg));
	d += strlen (arg);
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	if (!c->onearg)
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	    free (arg);

	/* Always put the extra space on.  we'll have to back up a char
	 * when we're done, but that seems most efficient.
	 */
	doff = d - *c->buf;
	expand_string (c->buf, c->length, doff + 1);
	d = *c->buf + doff;
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	if (c->onearg && *f) *d++ = ',';
	else
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	    *d++ = ' ';
d627 1
a627 3
    /* correct our original pointer into the buff */
    *c->d = d;
    return 0;
a629 2


d635 6
a640 2
logfile_write (const char *repository, const char *filter, const char *message,
               FILE *logfp, List *changes)
a641 1
    char *cmdline;
d643 1
d647 2
a648 1
    const char *srepos = Short_Repository (repository);
d701 113
a813 25
    /* %c = cvs_cmd_name
     * %p = shortrepos
     * %r = repository
     * %{sVv} = file name, old revision (precommit), new revision (postcommit)
     */
    cmdline = format_cmdline (
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
	                      !config->UseNewInfoFmtStrings, srepos,
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
	                      filter,
	                      "c", "s", cvs_cmd_name,
#ifdef SERVER_SUPPORT
	                      "R", "s", referrer ? referrer->original : "NONE",
#endif /* SERVER_SUPPORT */
	                      "p", "s", srepos,
	                      "r", "s", current_parsed_root->directory,
	                      "sVv", ",", changes,
			             logmsg_list_to_args_proc, (void *) NULL,
	                      (char *)NULL
	                     );
    if( !cmdline || !strlen( cmdline ) )
    {
	if( cmdline ) free( cmdline );
	error( 0, 0, "logmsg proc resolved to the empty string!" );
	return 1;
d816 1
a816 1
    if( ( pipefp = run_popen( cmdline, "w" ) ) == NULL )
d819 3
a821 3
	    error( 0, 0, "cannot write entry to log filter: %s", cmdline );
	free( cmdline );
	return 1;
d825 1
a825 1
    cp = xgetcwd ();
d836 1
a836 1
    (void) fprintf (pipefp, "Log Message:\n%s\n", (message) ? message : "");
d844 1
a844 1
    free (cmdline);
d849 19
d869 3
d873 2
a874 2
/*  This routine is called by Parse_Info.  It runs the
 *  message verification script.
d877 3
a879 1
verifymsg_proc (const char *repository, const char *script, void *closure)
d881 6
a886 115
    char *verifymsg_script;
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
    char *newscript = NULL;
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
    struct verifymsg_proc_data *vpd = closure;
    const char *srepos = Short_Repository (repository);

#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
    if (!strchr (script, '%'))
    {
	error (0, 0,
	       "warning: verifymsg line doesn't contain any format strings:\n"
               "    \"%s\"\n"
               "Appending default format string (\" %%l\"), but be aware that this usage is\n"
               "deprecated.", script);
	newscript = xmalloc (strlen (script) + 4);
	strcpy (newscript, script);
	strcat (newscript, " %l");
	script = newscript;
    }
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */

    /* If we don't already have one, open a temporary file, write the message
     * to the temp file, and close the file.
     *
     * We do this here so that we only create the file when there is a
     * verifymsg script specified and we only create it once when there is
     * more than one verifymsg script specified.
     */
    if (vpd->fname == NULL)
    {
	FILE *fp;
	if ((fp = cvs_temp_file (&(vpd->fname))) == NULL)
	    error (1, errno, "cannot create temporary file %s", vpd->fname);

	if (vpd->message != NULL)
	    fputs (vpd->message, fp);
	if (vpd->message == NULL ||
	    (vpd->message)[0] == '\0' ||
	    (vpd->message)[strlen (vpd->message) - 1] != '\n')
	    putc ('\n', fp);
	if (fclose (fp) == EOF)
	    error (1, errno, "%s", vpd->fname);

	if (config->RereadLogAfterVerify == LOGMSG_REREAD_STAT)
	{
	    /* Remember the status of the temp file for later */
	    if (CVS_STAT (vpd->fname, &(vpd->pre_stbuf)) != 0)
		error (1, errno, "cannot stat temp file %s", vpd->fname);

	    /*
	     * See if we need to sleep before running the verification
	     * script to avoid time-stamp races.
	     */
	    sleep_past (vpd->pre_stbuf.st_mtime);
	}
    } /* if (vpd->fname == NULL) */

    verifymsg_script = format_cmdline (
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
                                       false, srepos,
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
                                       script,
				       "c", "s", cvs_cmd_name,
#ifdef SERVER_SUPPORT
				       "R", "s", referrer ? referrer->original
							  : "NONE",
#endif /* SERVER_SUPPORT */
                                       "p", "s", srepos,
                                       "r", "s",
                                       current_parsed_root->directory,
                                       "l", "s", vpd->fname,
                                       (char *)NULL
                                      );

#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
    if (newscript) free (newscript);
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */

    if (!verifymsg_script || !strlen (verifymsg_script))
    {
	if (verifymsg_script) free (verifymsg_script);
	verifymsg_script = NULL;
	error (0, 0, "verifymsg proc resolved to the empty string!");
	return 1;
    }

    run_setup (verifymsg_script);

    free (verifymsg_script);

    /* FIXME - because run_exec can return negative values and Parse_Info adds
     * the values of each call to this function to get a total error, we are
     * calling abs on the value of run_exec to ensure two errors do not sum to
     * zero.
     *
     * The only REALLY obnoxious thing about this, I guess, is that a -1 return
     * code from run_exec can mean we failed to call the process for some
     * reason and should care about errno or that the process we called
     * returned -1 and the value of errno is undefined.  In other words,
     * run_exec should probably be rewritten to have two return codes.  one
     * which is its own exit status and one which is the child process's.  So
     * there.  :P
     *
     * Once run_exec is returning two error codes, we should probably be
     * failing here with an error message including errno when we get the
     * return code which means we care about errno, in case you missed that
     * little tidbit.
     *
     * I do happen to know we just fail for a non-zero value anyway and I
     * believe the docs actually state that if the verifymsg_proc returns a
     * "non-zero" value we will fail.
     */
    return abs (run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
			  RUN_NORMAL | RUN_SIGIGNORE));
@


1.1.3.1
log
@our CVS is currently at 1.11.1p1, thus import that version into vendor branch
@
text
@d210 2
@


1.1.3.2
log
@CVS 1.11.12 is the latest stable version of CVS,
released 06.02.2004, with a huge lot of bug fixes.

/me hopes this will pay off...
@
text
@a8 2
#include <assert.h>

a29 9
/* 
 * Should the logmsg be re-read during the do_verify phase?
 * RereadLogAfterVerify=no|stat|yes
 * LOGMSG_REREAD_NEVER  - never re-read the logmsg
 * LOGMSG_REREAD_STAT   - re-read the logmsg only if it has changed
 * LOGMSG_REREAD_ALWAYS - always re-read the logmsg
 */
int RereadLogAfterVerify = LOGMSG_REREAD_ALWAYS;

d126 1
a126 1
	    (void) fputs (prefix, fp);
d169 1
a169 2
 * is NULL, use the CVSADM_TEMPLATE file instead.  REPOSITORY should be
 * NULL when running in client mode.
a185 6
#ifdef CLIENT_SUPPORT
    assert (!current_parsed_root->isremote != !repository);
#else
    assert (repository);
#endif

d204 1
a204 1
	(void) fputs (*messagep, fp);
d308 1
a308 1
 	(*messagep)[0] = '\0';
d339 3
a341 9
    /* canonicalize emply messages */
    if (*messagep != NULL &&
        (**messagep == '\0' || strcmp (*messagep, "\n") == 0))
    {
	free (*messagep);
	*messagep = NULL;
    }

    if (pre_stbuf.st_mtime == post_stbuf.st_mtime || *messagep == NULL)
d390 2
a391 2
do_verify (messagep, repository)
    char **messagep;
a397 2
    struct stat pre_stbuf, post_stbuf;

d406 1
a406 1
    if (noexec || repository == NULL)
d409 5
a413 6
    /* Get the name of the verification script to run  */

    if (Parse_Info (CVSROOTADM_VERIFYMSG, repository, verifymsg_proc, 0) > 0)
	error (1, 0, "Message verification failed");

    if (!verifymsg_script)
d415 1
d422 28
d451 4
a454 8
    if (*messagep != NULL)
	fputs (*messagep, fp);
    if (*messagep == NULL ||
	(*messagep)[0] == '\0' ||
	(*messagep)[strlen (*messagep) - 1] != '\n')
	putc ('\n', fp);
    if (fclose (fp) == EOF)
	error (1, errno, "%s", fname);
d456 1
a456 12
    if (RereadLogAfterVerify == LOGMSG_REREAD_STAT)
    {
	/* Remember the status of the temp file for later */
	if ( CVS_STAT (fname, &pre_stbuf) != 0 )
	    error (1, errno, "cannot stat temp file %s", fname);

	/*
	 * See if we need to sleep before running the verification
	 * script to avoid time-stamp races.
	 */
	sleep_past (pre_stbuf.st_mtime);
    }
a457 6
    run_setup (verifymsg_script);
    run_arg (fname);
    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
			     RUN_NORMAL | RUN_SIGIGNORE)) != 0)
    {
	/* Since following error() exits, delete the temp file now.  */
d460 1
a460 3

	error (1, retcode == -1 ? errno : 0, 
	       "Message verification failed");
a461 72

    /* Get the mod time and size of the possibly new log message
     * in always and stat modes.
     */
    if (RereadLogAfterVerify == LOGMSG_REREAD_ALWAYS ||
	RereadLogAfterVerify == LOGMSG_REREAD_STAT)
    {
	if ( CVS_STAT (fname, &post_stbuf) != 0 )
	    error (1, errno, "cannot find size of temp file %s", fname);
    }

    /* And reread the log message in `always' mode or in `stat' mode when it's
     * changed
     */
    if (RereadLogAfterVerify == LOGMSG_REREAD_ALWAYS ||
	(RereadLogAfterVerify == LOGMSG_REREAD_STAT &&
	    (pre_stbuf.st_mtime != post_stbuf.st_mtime ||
	     pre_stbuf.st_size != post_stbuf.st_size)))
    {
	/* put the entire message back into the *messagep variable */

	if (*messagep) free (*messagep);

	if (post_stbuf.st_size == 0)
	    *messagep = NULL;
	else
	{
	    char *line = NULL;
	    int line_length;
	    size_t line_chars_allocated = 0;
	    char *p;

	    if ( (fp = open_file (fname, "r")) == NULL )
		error (1, errno, "cannot open temporary file %s", fname);

	    /* On NT, we might read less than st_size bytes,
	       but we won't read more.  So this works.  */
	    p = *messagep = (char *) xmalloc (post_stbuf.st_size + 1);
	    *messagep[0] = '\0';

	    while (1)
	    {
		line_length = getline (&line,
				       &line_chars_allocated,
				       fp);
		if (line_length == -1)
		{
		    if (ferror (fp))
			/* Fail in this case because otherwise we will have no
			 * log message
			 */
			error (1, errno, "cannot read %s", fname);
		    break;
		}
		if (strncmp (line, CVSEDITPREFIX, CVSEDITPREFIXLEN) == 0)
		    continue;
		(void) strcpy (p, line);
		p += line_length;
	    }
	    if (line) free (line);
	    if (fclose (fp) < 0)
	        error (0, errno, "warning: cannot close %s", fname);
	}
    }

    /* Delete the temp file  */

    if (unlink_file (fname) < 0)
	error (0, errno, "cannot remove %s", fname);
    free (fname);
    free( verifymsg_script );
    verifymsg_script = NULL;
a615 5
		/* Note that people who have to deal with spaces in file
		   and directory names are using space to get a known
		   delimiter for the directory name, so it's probably
		   not a good idea to ever define that as a formatting
		   character.  */
d834 1
a834 1
    (void) fprintf (pipefp, "Log Message:\n%s\n", (message) ? message : "");
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
