head	1.5;
access;
symbols
	cvs-1_12_11:1.1.2.1
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.4
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.2
	MIROS_X_BASE:1.5
	cvs-1_12_10:1.1.2.1
	FSF:1.1.2
	MIRBSD_XP_MIRPPC:1.4.0.4
	MIRBSD_XP_SPARC_BASE:1.4
	MIRBSD_XP_SPARC:1.4.0.2
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.1.1.1
	cvs-200405160640:1.1.1.1
	cvs-200404170130:1.1.1.1
	cvs-1_11_12:1.1.3.2
	cvs-1_11_1p1:1.1.3.1
	tg:1.1.3
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.6
	MIRBSD_7:1.1.1.1.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.1.1.1
	MIRBSD_7_DEV:1.1.1.1.0.2
	cvs-200310020700:1.1.1.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.12.02.12.40.12;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.09.21.38.37;	author tg;	state Stab;
branches;
next	1.3;

1.3
date	2004.02.22.13.49.14;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.12.21.16.11;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.17.41.28;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.41.28;	author tg;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2004.06.09.20.32.52;	author tg;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2004.06.20.17.39.30;	author bsiegert;	state Exp;
branches;
next	;

1.1.2.1
date	2004.12.02.11.58.51;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2004.02.12.19.18.32;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.12.19.38.59;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@update to cvs 1.12.10-MirOS except automatically
generated files
XXX this installs as /usr/bin/ncvs yet, so no
XXX conflicts during the test phase.
XXX I suggest to _not_ update.

XXX *** IMPORTANT *** DO NOT ACCESS CVS 1.11 REPOSITORIES
XXX *** IMPORTANT *** WITH CVS 1.12 OR VICE VERSA!
@
text
@/* $MirBSD: testing/cvs/src/commit.c,v 1.2 2004/12/02 09:10:13 tg Exp $ */

/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 *
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 *
 * Commit Files
 *
 * "commit" commits the present version to the RCS repository, AFTER
 * having done a test on conflicts.
 *
 * The call is: cvs commit [options] files...
 *
 */

#include "cvs.h"
#include "getline.h"
#include "edit.h"
#include "fileattr.h"
#include "hardlink.h"

__RCSID("$MirBSD: testing/cvs/src/commit.c,v 1.2 2004/12/02 09:10:13 tg Exp $");

static Dtype check_direntproc (void *callerdat, const char *dir,
                               const char *repos, const char *update_dir,
                               List *entries);
static int check_fileproc (void *callerdat, struct file_info *finfo);
static int check_filesdoneproc (void *callerdat, int err, const char *repos,
				const char *update_dir, List *entries);
static int checkaddfile (const char *file, const char *repository,
                         const char *tag, const char *options,
                         RCSNode **rcsnode);
static Dtype commit_direntproc (void *callerdat, const char *dir,
                                const char *repos, const char *update_dir,
                                List *entries);
static int commit_dirleaveproc (void *callerdat, const char *dir, int err,
				const char *update_dir, List *entries);
static int commit_fileproc (void *callerdat, struct file_info *finfo);
static int commit_filesdoneproc (void *callerdat, int err,
                                 const char *repository,
				 const char *update_dir, List *entries);
static int finaladd (struct file_info *finfo, char *revision, char *tag,
		     char *options);
static int findmaxrev (Node * p, void *closure);
static int lock_RCS (const char *user, RCSNode *rcs, const char *rev,
                     const char *repository);
static int precommit_list_to_args_proc (Node * p, void *closure);
static int precommit_proc (const char *repository, const char *filter,
                           void *closure);
static int remove_file (struct file_info *finfo, char *tag,
			char *message);
static void fixaddfile (const char *rcs);
static void fixbranch (RCSNode *, char *branch);
static void unlockrcs (RCSNode *rcs);
static void ci_delproc (Node *p);
static void masterlist_delproc (Node *p);

struct commit_info
{
    Ctype status;			/* as returned from Classify_File() */
    char *rev;				/* a numeric rev, if we know it */
    char *tag;				/* any sticky tag, or -r option */
    char *options;			/* Any sticky -k option */
};
struct master_lists
{
    List *ulist;			/* list for Update_Logfile */
    List *cilist;			/* list with commit_info structs */
};

static int check_valid_edit = 0;
static int force_ci = 0;
static int got_message;
static int aflag;
static char *saved_tag;
static char *write_dirtag;
static int write_dirnonbranch;
static char *logfile;
static List *mulist;
static char *saved_message;
static time_t last_register_time;

static const char *const commit_usage[] =
{
    "Usage: %s %s [-cRlf] [-m msg | -F logfile] [-r rev] files...\n",
    "    -c          Check for valid edits before committing.\n",
    "    -R          Process directories recursively.\n",
    "    -l          Local directory only (not recursive).\n",
    "    -f          Force the file to be committed; disables recursion.\n",
    "    -F logfile  Read the log message from file.\n",
    "    -m msg      Log message.\n",
    "    -r rev      Commit to this branch or trunk revision.\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

#ifdef CLIENT_SUPPORT
/* Identify a file which needs "? foo" or a Questionable request.  */
struct question {
    /* The two fields for the Directory request.  */
    char *dir;
    char *repos;

    /* The file name.  */
    char *file;

    struct question *next;
};

struct find_data {
    List *ulist;
    int argc;
    char **argv;

    /* This is used from dirent to filesdone time, for each directory,
       to make a list of files we have already seen.  */
    List *ignlist;

    /* Linked list of files which need "? foo" or a Questionable request.  */
    struct question *questionables;

    /* Only good within functions called from the filesdoneproc.  Stores
       the repository (pointer into storage managed by the recursion
       processor.  */
    const char *repository;

    /* Non-zero if we should force the commit.  This is enabled by
       either -f or -r options, unlike force_ci which is just -f.  */
    int force;
};



static Dtype
find_dirent_proc (void *callerdat, const char *dir, const char *repository,
                  const char *update_dir, List *entries)
{
    struct find_data *find_data = callerdat;

    /* This check seems to slowly be creeping throughout CVS (update
       and send_dirent_proc by CVS 1.5, diff in 31 Oct 1995.  My guess
       is that it (or some variant thereof) should go in all the
       dirent procs.  Unless someone has some better idea...  */
    if (!isdir (dir))
	return R_SKIP_ALL;

    /* initialize the ignore list for this directory */
    find_data->ignlist = getlist ();

    /* Print the same warm fuzzy as in check_direntproc, since that
       code will never be run during client/server operation and we
       want the messages to match. */
    if (!quiet)
	error (0, 0, "Examining %s", update_dir);

    return R_PROCESS;
}



/* Here as a static until we get around to fixing ignore_files to pass
   it along as an argument.  */
static struct find_data *find_data_static;



static void
find_ignproc (const char *file, const char *dir)
{
    struct question *p;

    p = xmalloc (sizeof (struct question));
    p->dir = xstrdup (dir);
    p->repos = xstrdup (find_data_static->repository);
    p->file = xstrdup (file);
    p->next = find_data_static->questionables;
    find_data_static->questionables = p;
}



static int
find_filesdoneproc (void *callerdat, int err, const char *repository,
                    const char *update_dir, List *entries)
{
    struct find_data *find_data = callerdat;
    find_data->repository = repository;

    /* if this directory has an ignore list, process it then free it */
    if (find_data->ignlist)
    {
	find_data_static = find_data;
	ignore_files (find_data->ignlist, entries, update_dir, find_ignproc);
	dellist (&find_data->ignlist);
    }

    find_data->repository = NULL;

    return err;
}



/* Machinery to find out what is modified, added, and removed.  It is
   possible this should be broken out into a new client_classify function;
   merging it with classify_file is almost sure to be a mess, though,
   because classify_file has all kinds of repository processing.  */
static int
find_fileproc (void *callerdat, struct file_info *finfo)
{
    Vers_TS *vers;
    enum classify_type status;
    Node *node;
    struct find_data *args = callerdat;
    struct logfile_info *data;
    struct file_info xfinfo;

    /* if this directory has an ignore list, add this file to it */
    if (args->ignlist)
    {
	Node *p;

	p = getnode ();
	p->type = FILES;
	p->key = xstrdup (finfo->file);
	if (addnode (args->ignlist, p) != 0)
	    freenode (p);
    }

    xfinfo = *finfo;
    xfinfo.repository = NULL;
    xfinfo.rcs = NULL;

    vers = Version_TS (&xfinfo, NULL, saved_tag, NULL, 0, 0);
    if (vers->vn_user == NULL)
    {
	if (vers->ts_user == NULL)
	    error (0, 0, "nothing known about `%s'", finfo->fullname);
	else
	    error (0, 0, "use `%s add' to create an entry for `%s'",
		   program_name, finfo->fullname);
	freevers_ts (&vers);
	return 1;
    }
    if (vers->vn_user[0] == '-')
    {
	if (vers->ts_user != NULL)
	{
	    error (0, 0,
		   "`%s' should be removed and is still there (or is back"
		   " again)", finfo->fullname);
	    freevers_ts (&vers);
	    return 1;
	}
	/* else */
	status = T_REMOVED;
    }
    else if (strcmp (vers->vn_user, "0") == 0)
    {
	if (vers->ts_user == NULL)
	{
	    /* This happens when one has `cvs add'ed a file, but it no
	       longer exists in the working directory at commit time.
	       FIXME: What classify_file does in this case is print
	       "new-born %s has disappeared" and removes the entry.
	       We probably should do the same.  */
	    if (!really_quiet)
		error (0, 0, "warning: new-born %s has disappeared",
		       finfo->fullname);
	    status = T_REMOVE_ENTRY;
	}
	else
	    status = T_ADDED;
    }
    else if (vers->ts_user == NULL)
    {
	/* FIXME: What classify_file does in this case is print
	   "%s was lost".  We probably should do the same.  */
	freevers_ts (&vers);
	return 0;
    }
    else if (vers->ts_rcs != NULL
	     && (args->force || strcmp (vers->ts_user, vers->ts_rcs) != 0))
	/* If we are forcing commits, pretend that the file is
           modified.  */
	status = T_MODIFIED;
    else
    {
	/* This covers unmodified files, as well as a variety of other
	   cases.  FIXME: we probably should be printing a message and
	   returning 1 for many of those cases (but I'm not sure
	   exactly which ones).  */
	freevers_ts (&vers);
	return 0;
    }

    node = getnode ();
    node->key = xstrdup (finfo->fullname);

    data = xmalloc (sizeof (struct logfile_info));
    data->type = status;
    data->tag = xstrdup (vers->tag);
    data->rev_old = data->rev_new = NULL;

    node->type = UPDATE;
    node->delproc = update_delproc;
    node->data = data;
    (void)addnode (args->ulist, node);

    ++args->argc;

    freevers_ts (&vers);
    return 0;
}



static int
copy_ulist (Node *node, void *data)
{
    struct find_data *args = data;
    args->argv[args->argc++] = node->key;
    return 0;
}
#endif /* CLIENT_SUPPORT */



#ifdef SERVER_SUPPORT
# define COMMIT_OPTIONS "+cnlRm:fF:r:"
#else /* !SERVER_SUPPORT */
# define COMMIT_OPTIONS "+clRm:fF:r:"
#endif /* SERVER_SUPPORT */
int
commit (int argc, char **argv)
{
    int c;
    int err = 0;
    int local = 0;

    if (argc == -1)
	usage (commit_usage);

#ifdef CVS_BADROOT
    /*
     * For log purposes, do not allow "root" to commit files.  If you look
     * like root, but are really logged in as a non-root user, it's OK.
     */
    /* FIXME: Shouldn't this check be much more closely related to the
       readonly user stuff (CVSROOT/readers, &c).  That is, why should
       root be able to "cvs init", "cvs import", &c, but not "cvs ci"?  */
    if (geteuid () == (uid_t) 0
#  ifdef CLIENT_SUPPORT
	/* Who we are on the client side doesn't affect logging.  */
	&& !current_parsed_root->isremote
#  endif
	)
    {
	struct passwd *pw;

	if ((pw = getpwnam (getcaller ())) == NULL)
	    error (1, 0,
                   "your apparent username (%s) is unknown to this system",
                   getcaller ());
	if (pw->pw_uid == (uid_t) 0)
	    error (1, 0, "'root' is not allowed to commit files");
    }
#endif /* CVS_BADROOT */

    optind = 0;
    while ((c = getopt (argc, argv, COMMIT_OPTIONS)) != -1)
    {
	switch (c)
	{
            case 'c':
                check_valid_edit = 1;
                break;
#ifdef SERVER_SUPPORT
	    case 'n':
		/* Silently ignore -n for compatibility with old
		 * clients.
		 */
		break;
#endif /* SERVER_SUPPORT */
	    case 'm':
#ifdef FORCE_USE_EDITOR
		use_editor = 1;
#else
		use_editor = 0;
#endif
		if (saved_message)
		{
		    free (saved_message);
		    saved_message = NULL;
		}

		saved_message = xstrdup(optarg);
		break;
	    case 'r':
		if (saved_tag)
		    free (saved_tag);
		saved_tag = xstrdup (optarg);
		break;
	    case 'l':
		local = 1;
		break;
	    case 'R':
		local = 0;
		break;
	    case 'f':
		force_ci = 1;
                check_valid_edit = 0;
		local = 1;		/* also disable recursion */
		break;
	    case 'F':
#ifdef FORCE_USE_EDITOR
		use_editor = 1;
#else
		use_editor = 0;
#endif
		logfile = optarg;
		break;
	    case '?':
	    default:
		usage (commit_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

    /* numeric specified revision means we ignore sticky tags... */
    if (saved_tag && isdigit ((unsigned char) *saved_tag))
    {
	char *p = saved_tag + strlen (saved_tag);
	aflag = 1;
	/* strip trailing dots and leading zeros */
	while (*--p == '.') ;
	p[1] = '\0';
	while (saved_tag[0] == '0' && isdigit ((unsigned char) saved_tag[1]))
	    ++saved_tag;
    }

    /* some checks related to the "-F logfile" option */
    if (logfile)
    {
	size_t size = 0, len;

	if (saved_message)
	    error (1, 0, "cannot specify both a message and a log file");

	get_file (logfile, logfile, "r", &saved_message, &size, &len);
    }

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
    {
	struct find_data find_args;

	ign_setup ();

	find_args.ulist = getlist ();
	find_args.argc = 0;
	find_args.questionables = NULL;
	find_args.ignlist = NULL;
	find_args.repository = NULL;

	/* It is possible that only a numeric tag should set this.
	   I haven't really thought about it much.
	   Anyway, I suspect that setting it unnecessarily only causes
	   a little unneeded network traffic.  */
	find_args.force = force_ci || saved_tag != NULL;

	err = start_recursion
	    (find_fileproc, find_filesdoneproc, find_dirent_proc, NULL,
	     &find_args, argc, argv, local, W_LOCAL, 0, CVS_LOCK_NONE,
	     NULL, 0, NULL );
	if (err)
	    error (1, 0, "correct above errors first!");

	if (find_args.argc == 0)
	{
	    /* Nothing to commit.  Exit now without contacting the
	       server (note that this means that we won't print "?
	       foo" for files which merit it, because we don't know
	       what is in the CVSROOT/cvsignore file).  */
	    dellist (&find_args.ulist);
	    return 0;
	}

	/* Now we keep track of which files we actually are going to
	   operate on, and only work with those files in the future.
	   This saves time--we don't want to search the file system
	   of the working directory twice.  */
	if (size_overflow_p (xtimes (find_args.argc, sizeof (char **))))
	{
	    find_args.argc = 0;
	    return 0;
	}
	find_args.argv = xmalloc (xtimes (find_args.argc, sizeof (char **)));
	find_args.argc = 0;
	walklist (find_args.ulist, copy_ulist, &find_args);

	/* Do this before calling do_editor; don't ask for a log
	   message if we can't talk to the server.  But do it after we
	   have made the checks that we can locally (to more quickly
	   catch syntax errors, the case where no files are modified,
	   added or removed, etc.).

	   On the other hand, calling start_server before do_editor
	   means that we chew up server resources the whole time that
	   the user has the editor open (hours or days if the user
	   forgets about it), which seems dubious.  */
	start_server ();

	/*
	 * We do this once, not once for each directory as in normal CVS.
	 * The protocol is designed this way.  This is a feature.
	 */
	if (use_editor)
	    do_editor (".", &saved_message, NULL, find_args.ulist);

	/* We always send some sort of message, even if empty.  */
	option_with_arg ("-m", saved_message ? saved_message : "");

	/* OK, now process all the questionable files we have been saving
	   up.  */
	{
	    struct question *p;
	    struct question *q;

	    p = find_args.questionables;
	    while (p != NULL)
	    {
		if (ign_inhibit_server || !supported_request ("Questionable"))
		{
		    cvs_output ("? ", 2);
		    if (p->dir[0] != '\0')
		    {
			cvs_output (p->dir, 0);
			cvs_output ("/", 1);
		    }
		    cvs_output (p->file, 0);
		    cvs_output ("\n", 1);
		}
		else
		{
		    /* This used to send the Directory line of its own accord,
		     * but skipped some of the other processing like checking
		     * for whether the server would accept "Relative-directory"
		     * requests.  Relying on send_a_repository() to do this
		     * picks up these checks but also:
		     *
		     *   1. Causes the "Directory" request to be sent only once
		     *      per directory.
		     *   2. Causes the global TOPLEVEL_REPOS to be set.
		     *   3. Causes "Static-directory" and "Sticky" requests
		     *      to sometimes be sent.
		     *
		     * (1) is almost certainly a plus.  (2) & (3) may or may
		     * not be useful sometimes, and will ocassionally cause a
		     * little extra network traffic.  The additional network
		     * traffic is probably already saved several times over and
		     * certainly cancelled out via the multiple "Directory"
		     * request suppression of (1).
		     */
		    send_a_repository (p->dir, p->repos, p->dir);

		    send_to_server ("Questionable ", 0);
		    send_to_server (p->file, 0);
		    send_to_server ("\012", 1);
		}
		free (p->dir);
		free (p->repos);
		free (p->file);
		q = p->next;
		free (p);
		p = q;
	    }
	}

	if (local)
	    send_arg("-l");
        if (check_valid_edit)
            send_arg("-c");
	if (force_ci)
	    send_arg("-f");
	option_with_arg ("-r", saved_tag);
	send_arg ("--");

	/* FIXME: This whole find_args.force/SEND_FORCE business is a
	   kludge.  It would seem to be a server bug that we have to
	   say that files are modified when they are not.  This makes
	   "cvs commit -r 2" across a whole bunch of files a very slow
	   operation (and it isn't documented in cvsclient.texi).  I
	   haven't looked at the server code carefully enough to be
	   _sure_ why this is needed, but if it is because the "ci"
	   program, which we used to call, wanted the file to exist,
	   then it would be relatively simple to fix in the server.  */
	send_files (find_args.argc, find_args.argv, local, 0,
		    find_args.force ? SEND_FORCE : 0);

	/* Sending only the names of the files which were modified, added,
	   or removed means that the server will only do an up-to-date
	   check on those files.  This is different from local CVS and
	   previous versions of client/server CVS, but it probably is a Good
	   Thing, or at least Not Such A Bad Thing.  */
	send_file_names (find_args.argc, find_args.argv, 0);
	free (find_args.argv);
	dellist (&find_args.ulist);

	send_to_server ("ci\012", 0);
	err = get_responses_and_close ();
	if (err != 0 && use_editor && saved_message != NULL)
	{
	    /* If there was an error, don't nuke the user's carefully
	       constructed prose.  This is something of a kludge; a better
	       solution is probably more along the lines of #150 in TODO
	       (doing a second up-to-date check before accepting the
	       log message has also been suggested, but that seems kind of
	       iffy because the real up-to-date check could still fail,
	       another error could occur, &c.  Also, a second check would
	       slow things down).  */

	    char *fname;
	    FILE *fp;

	    fp = cvs_temp_file (&fname);
	    if (fp == NULL)
		error (1, 0, "cannot create temporary file %s", fname);
	    if (fwrite (saved_message, 1, strlen (saved_message), fp)
		!= strlen (saved_message))
		error (1, errno, "cannot write temporary file %s", fname);
	    if (fclose (fp) < 0)
		error (0, errno, "cannot close temporary file %s", fname);
	    error (0, 0, "saving log message in %s", fname);
	    free (fname);
	}
	return err;
    }
#endif

    if (saved_tag != NULL)
	tag_check_valid (saved_tag, argc, argv, local, aflag, "", false);

    /* XXX - this is not the perfect check for this */
    if (argc <= 0)
	write_dirtag = saved_tag;

    wrap_setup ();

    lock_tree_promotably (argc, argv, local, W_LOCAL, aflag);

    /*
     * Set up the master update list and hard link list
     */
    mulist = getlist ();

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    if (preserve_perms)
    {
	hardlist = getlist ();

	/*
	 * We need to save the working directory so that
	 * check_fileproc can construct a full pathname for each file.
	 */
	working_dir = xgetcwd ();
    }
#endif

    /*
     * Run the recursion processor to verify the files are all up-to-date
     */
    err = start_recursion (check_fileproc, check_filesdoneproc,
                           check_direntproc, NULL, NULL, argc, argv, local,
                           W_LOCAL, aflag, CVS_LOCK_NONE, NULL, 1, NULL);
    if (err)
	error (1, 0, "correct above errors first!");

    /*
     * Run the recursion processor to commit the files
     */
    write_dirnonbranch = 0;
    if (noexec == 0)
	err = start_recursion (commit_fileproc, commit_filesdoneproc,
                               commit_direntproc, commit_dirleaveproc, NULL,
                               argc, argv, local, W_LOCAL, aflag,
                               CVS_LOCK_WRITE, NULL, 1, NULL);

    /*
     * Unlock all the dirs and clean up
     */
    Lock_Cleanup ();
    dellist (&mulist);

    /* see if we need to sleep before returning to avoid time-stamp races */
    if (
#ifdef SERVER_SUPPORT
	/* But only sleep on the client.  */
        !server_active &&
#endif
	last_register_time
       )
	    sleep_past (last_register_time);

    return err;
}



/* This routine determines the status of a given file and retrieves
   the version information that is associated with that file. */

static
Ctype
classify_file_internal (struct file_info *finfo, Vers_TS **vers)
{
    int save_noexec, save_quiet, save_really_quiet;
    Ctype status;

    /* FIXME: Do we need to save quiet as well as really_quiet?  Last
       time I glanced at Classify_File I only saw it looking at really_quiet
       not quiet.  */
    save_noexec = noexec;
    save_quiet = quiet;
    save_really_quiet = really_quiet;
    noexec = quiet = really_quiet = 1;

    /* handle specified numeric revision specially */
    if (saved_tag && isdigit ((unsigned char) *saved_tag))
    {
	/* If the tag is for the trunk, make sure we're at the head */
	if (numdots (saved_tag) < 2)
	{
	    status = Classify_File (finfo, NULL, NULL,
				    NULL, 1, aflag, vers, 0);
	    if (status == T_UPTODATE || status == T_MODIFIED ||
		status == T_ADDED)
	    {
		Ctype xstatus;

		freevers_ts (vers);
		xstatus = Classify_File (finfo, saved_tag, NULL,
					 NULL, 1, aflag, vers, 0);
		if (xstatus == T_REMOVE_ENTRY)
		    status = T_MODIFIED;
		else if (status == T_MODIFIED && xstatus == T_CONFLICT)
		    status = T_MODIFIED;
		else
		    status = xstatus;
	    }
	}
	else
	{
	    char *xtag, *cp;

	    /*
	     * The revision is off the main trunk; make sure we're
	     * up-to-date with the head of the specified branch.
	     */
	    xtag = xstrdup (saved_tag);
	    if ((numdots (xtag) & 1) != 0)
	    {
		cp = strrchr (xtag, '.');
		*cp = '\0';
	    }
	    status = Classify_File (finfo, xtag, NULL,
				    NULL, 1, aflag, vers, 0);
	    if ((status == T_REMOVE_ENTRY || status == T_CONFLICT)
		&& (cp = strrchr (xtag, '.')) != NULL)
	    {
		/* pluck one more dot off the revision */
		*cp = '\0';
		freevers_ts (vers);
		status = Classify_File (finfo, xtag, NULL,
					NULL, 1, aflag, vers, 0);
		if (status == T_UPTODATE || status == T_REMOVE_ENTRY)
		    status = T_MODIFIED;
	    }
	    /* now, muck with vers to make the tag correct */
	    free ((*vers)->tag);
	    (*vers)->tag = xstrdup (saved_tag);
	    free (xtag);
	}
    }
    else
	status = Classify_File (finfo, saved_tag, NULL, NULL, 1, 0, vers, 0);
    noexec = save_noexec;
    quiet = save_quiet;
    really_quiet = save_really_quiet;

    return status;
}



/*
 * Check to see if a file is ok to commit and make sure all files are
 * up-to-date
 */
/* ARGSUSED */
static int
check_fileproc (void *callerdat, struct file_info *finfo)
{
    Ctype status;
    const char *xdir;
    Node *p;
    List *ulist, *cilist;
    Vers_TS *vers;
    struct commit_info *ci;
    struct logfile_info *li;
    int retval = 1;

    size_t cvsroot_len = strlen (current_parsed_root->directory);

    if (!finfo->repository)
    {
	error (0, 0, "nothing known about `%s'", finfo->fullname);
	return 1;
    }

    if (strncmp (finfo->repository, current_parsed_root->directory,
                 cvsroot_len) == 0
	&& ISSLASH (finfo->repository[cvsroot_len])
	&& strncmp (finfo->repository + cvsroot_len + 1,
		    CVSROOTADM,
		    sizeof (CVSROOTADM) - 1) == 0
	&& ISSLASH (finfo->repository[cvsroot_len + sizeof (CVSROOTADM)])
	&& strcmp (finfo->repository + cvsroot_len + sizeof (CVSROOTADM) + 1,
		   CVSNULLREPOS) == 0
	)
	error (1, 0, "cannot check in to %s", finfo->repository);

    status = classify_file_internal (finfo, &vers);

    /*
     * If the force-commit option is enabled, and the file in question
     * appears to be up-to-date, just make it look modified so that
     * it will be committed.
     */
    if (force_ci && status == T_UPTODATE)
	status = T_MODIFIED;

    switch (status)
    {
	case T_CHECKOUT:
	case T_PATCH:
	case T_NEEDS_MERGE:
	case T_CONFLICT:
	case T_REMOVE_ENTRY:
	    error (0, 0, "Up-to-date check failed for `%s'", finfo->fullname);
	    goto out;
	case T_MODIFIED:
	case T_ADDED:
	case T_REMOVED:
        {
            char *editor;

	    /*
	     * some quick sanity checks; if no numeric -r option specified:
	     *	- can't have a sticky date
	     *	- can't have a sticky tag that is not a branch
	     * Also,
	     *	- if status is T_REMOVED, file must not exist and its entry
	     *	  can't have a numeric sticky tag.
	     *	- if status is T_ADDED, rcs file must not exist unless on
	     *    a branch or head is dead
	     *	- if status is T_ADDED, can't have a non-trunk numeric rev
	     *	- if status is T_MODIFIED and a Conflict marker exists, don't
	     *    allow the commit if timestamp is identical or if we find
	     *    an RCS_MERGE_PAT in the file.
	     */
	    if (!saved_tag || !isdigit ((unsigned char) *saved_tag))
	    {
		if (vers->date)
		{
		    error (0, 0,
			   "cannot commit with sticky date for file `%s'",
			   finfo->fullname);
		    goto out;
		}
		if (status == T_MODIFIED && vers->tag &&
		    !RCS_isbranch (finfo->rcs, vers->tag))
		{
		    error (0, 0,
			   "sticky tag `%s' for file `%s' is not a branch",
			   vers->tag, finfo->fullname);
		    goto out;
		}
	    }
	    if (status == T_MODIFIED && !force_ci && vers->ts_conflict)
	    {
		/*
		 * We found a "conflict" marker.
		 *
		 * If the timestamp on the file is the same as the
		 * timestamp stored in the Entries file, we block the commit.
		 */
		if ( file_has_conflict ( finfo, vers->ts_conflict ) )
		{
		    error (0, 0,
			  "file `%s' had a conflict and has not been modified",
			   finfo->fullname);
		    goto out;
		}

		if (file_has_markers (finfo))
		{
		    /* Make this a warning, not an error, because we have
		       no way of knowing whether the "conflict indicators"
		       are really from a conflict or whether they are part
		       of the document itself (cvs.texinfo and sanity.sh in
		       CVS itself, for example, tend to want to have strings
		       like ">>>>>>>" at the start of a line).  Making people
		       kludge this the way they need to kludge keyword
		       expansion seems undesirable.  And it is worse than
		       keyword expansion, because there is no -ko
		       analogue.  */
		    error (0, 0,
			   "\
warning: file `%s' seems to still contain conflict indicators",
			   finfo->fullname);
		}
	    }

	    if (status == T_REMOVED)
	    {
		if (vers->ts_user != NULL)
		{
		    error (0, 0,
			   "`%s' should be removed and is still there (or is"
			   " back again)", finfo->fullname);
		    goto out;
		}

		if (vers->tag && isdigit ((unsigned char) *vers->tag))
		{
		    /* Remove also tries to forbid this, but we should check
		       here.  I'm only _sure_ about somewhat obscure cases
		       (hacking the Entries file, using an old version of
		       CVS for the remove and a new one for the commit), but
		       there might be other cases.  */
		    error (0, 0,
			   "cannot remove file `%s' which has a numeric sticky"
			   " tag of `%s'", finfo->fullname, vers->tag);
		    freevers_ts (&vers);
		    goto out;
		}
	    }
	    if (status == T_ADDED)
	    {
	        if (vers->tag == NULL)
		{
		    if (finfo->rcs != NULL &&
			!RCS_isdead (finfo->rcs, finfo->rcs->head))
		    {
			error (0, 0,
		    "cannot add file `%s' when RCS file `%s' already exists",
			       finfo->fullname, finfo->rcs->path);
			goto out;
		    }
		}
		else if (isdigit ((unsigned char) *vers->tag) &&
		    numdots (vers->tag) > 1)
		{
		    error (0, 0,
		"cannot add file `%s' with revision `%s'; must be on trunk",
			       finfo->fullname, vers->tag);
		    goto out;
		}
	    }

	    /* done with consistency checks; now, to get on with the commit */
	    if (finfo->update_dir[0] == '\0')
		xdir = ".";
	    else
		xdir = finfo->update_dir;
	    if ((p = findnode (mulist, xdir)) != NULL)
	    {
		ulist = ((struct master_lists *) p->data)->ulist;
		cilist = ((struct master_lists *) p->data)->cilist;
	    }
	    else
	    {
		struct master_lists *ml;

		ml = xmalloc (sizeof (struct master_lists ));
		ulist = ml->ulist = getlist();
		cilist = ml->cilist = getlist();

		p = getnode ();
		p->key = xstrdup (xdir);
		p->type = UPDATE;
		p->data = ml;
		p->delproc = masterlist_delproc;
		(void) addnode (mulist, p);
	    }

	    /* first do ulist, then cilist */
	    p = getnode ();
	    p->key = xstrdup (finfo->file);
	    p->type = UPDATE;
	    p->delproc = update_delproc;
	    li = xmalloc (sizeof (struct logfile_info));
	    li->type = status;

	    if (check_valid_edit)
            {
                char *editors = NULL;

		editor = NULL;
                editors = fileattr_get0 (finfo->file, "_editors");
                if (editors != NULL)
                {
                    char *caller = getcaller ();
                    char *p = NULL;
                    char *p0 = NULL;

                    p = editors;
                    p0 = p;
                    while (*p != '\0')
                    {
                        p = strchr (p, '>');
                        if (p == NULL)
                        {
                            break;
                        }
                        *p = '\0';
                        if (strcmp (caller, p0) == 0)
                        {
                            break;
                        }
                        p = strchr (p + 1, ',');
                        if (p == NULL)
                        {
                            break;
                        }
                        ++p;
                        p0 = p;
                    }

                    if (strcmp (caller, p0) == 0)
                    {
                        editor = caller;
                    }

                    free (editors);
                }
            }

            if (check_valid_edit && editor == NULL)
            {
                error (0, 0, "Valid edit does not exist for %s",
                       finfo->fullname);
                freevers_ts (&vers);
                return 1;
            }

	    li->tag = xstrdup (vers->tag);
	    li->rev_old = xstrdup (vers->vn_rcs);
	    li->rev_new = NULL;
	    p->data = li;
	    (void) addnode (ulist, p);

	    p = getnode ();
	    p->key = xstrdup (finfo->file);
	    p->type = UPDATE;
	    p->delproc = ci_delproc;
	    ci = xmalloc (sizeof (struct commit_info));
	    ci->status = status;
	    if (vers->tag)
		if (isdigit ((unsigned char) *vers->tag))
		    ci->rev = xstrdup (vers->tag);
		else
		    ci->rev = RCS_whatbranch (finfo->rcs, vers->tag);
	    else
		ci->rev = NULL;
	    ci->tag = xstrdup (vers->tag);
	    ci->options = xstrdup(vers->options);
	    p->data = ci;
	    (void) addnode (cilist, p);

#ifdef PRESERVE_PERMISSIONS_SUPPORT
	    if (preserve_perms)
	    {
		/* Add this file to hardlist, indexed on its inode.  When
		   we are done, we can find out what files are hardlinked
		   to a given file by looking up its inode in hardlist. */
		char *fullpath;
		Node *linkp;
		struct hardlink_info *hlinfo;

		/* Get the full pathname of the current file. */
		fullpath = xmalloc (strlen(working_dir) +
				    strlen(finfo->fullname) + 2);
		sprintf (fullpath, "%s/%s", working_dir, finfo->fullname);

		/* To permit following links in subdirectories, files
                   are keyed on finfo->fullname, not on finfo->name. */
		linkp = lookup_file_by_inode (fullpath);

		/* If linkp is NULL, the file doesn't exist... maybe
		   we're doing a remove operation? */
		if (linkp != NULL)
		{
		    /* Create a new hardlink_info node, which will record
		       the current file's status and the links listed in its
		       `hardlinks' delta field.  We will append this
		       hardlink_info node to the appropriate hardlist entry. */
		    hlinfo = xmalloc (sizeof (struct hardlink_info));
		    hlinfo->status = status;
		    linkp->data = hlinfo;
		}
	    }
#endif

	    break;
        }

	case T_UNKNOWN:
	    error (0, 0, "nothing known about `%s'", finfo->fullname);
	    goto out;
	case T_UPTODATE:
	    break;
	default:
	    error (0, 0, "CVS internal error: unknown status %d", status);
	    break;
    }

    retval = 0;

 out:

    freevers_ts (&vers);
    return retval;
}



/*
 * By default, return the code that tells do_recursion to examine all
 * directories
 */
/* ARGSUSED */
static Dtype
check_direntproc (void *callerdat, const char *dir, const char *repos,
                  const char *update_dir, List *entries)
{
    if (!isdir (dir))
	return R_SKIP_ALL;

    if (!quiet)
	error (0, 0, "Examining %s", update_dir);

    return R_PROCESS;
}



/*
 * Walklist proc to generate an arg list from the line in commitinfo
 */
static int
precommit_list_to_args_proc (p, closure)
    Node *p;
    void *closure;
{
    struct format_cmdline_walklist_closure *c = closure;
    struct logfile_info *li;
    char *arg = NULL;
    const char *f;
    char *d;
    size_t doff;

    if (p->data == NULL) return 1;

    f = c->format;
    d = *c->d;
    /* foreach requested attribute */
    while (*f)
    {
   	switch (*f++)
	{
	    case 's':
		li = p->data;
		if (li->type == T_ADDED
			|| li->type == T_MODIFIED
			|| li->type == T_REMOVED)
		{
		    arg = p->key;
		}
		break;
	    default:
		error (1, 0,
		       "Unknown format character or not a list attribute: %c",
		       f[-1]);
		/* NOTREACHED */
		break;
	}
	/* copy the attribute into an argument */
	if (c->quotes)
	{
	    arg = cmdlineescape (c->quotes, arg);
	}
	else
	{
	    arg = cmdlinequote ('"', arg);
	}
	doff = d - *c->buf;
	expand_string (c->buf, c->length, doff + strlen (arg));
	d = *c->buf + doff;
	strncpy (d, arg, strlen (arg));
	d += strlen (arg);
	free (arg);

	/* and always put the extra space on.  we'll have to back up a char
	 * when we're done, but that seems most efficient
	 */
	doff = d - *c->buf;
	expand_string (c->buf, c->length, doff + 1);
	d = *c->buf + doff;
	*d++ = ' ';
    }
    /* correct our original pointer into the buff */
    *c->d = d;
    return 0;
}



/*
 * Callback proc for pre-commit checking
 */
static int
precommit_proc (const char *repository, const char *filter, void *closure)
{
    char *newfilter = NULL;
    char *cmdline;
    const char *srepos = Short_Repository (repository);
    List *ulist = closure;

#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
    if (!strchr (filter, '%'))
    {
	error (0, 0,
               "warning: commitinfo line contains no format strings:\n"
               "    \"%s\"\n"
               "Appending defaults (\" %%r/%%p %%s\"), but please be aware that this usage is\n"
               "deprecated.", filter);
	newfilter = xmalloc (strlen (filter) + 10);
	strcpy (newfilter, filter);
	strcat (newfilter, " %r/%p %s");
	filter = newfilter;
    }
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */

    cmdline = format_cmdline (
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
        false, srepos,
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
        filter,
	"c", "s", cvs_cmd_name,
#ifdef SERVER_SUPPORT
        "R", "s", referrer ? referrer->original : "NONE",
#endif /* SERVER_SUPPORT */
        "p", "s", srepos,
        "r", "s", current_parsed_root->directory,
        "s", ",", ulist, precommit_list_to_args_proc, (void *)NULL,
        (char *)NULL
	);

    if (newfilter) free (newfilter);

    if (!cmdline || !strlen (cmdline))
    {
	if (cmdline) free (cmdline);
	error (0, 0, "precommit proc resolved to the empty string!");
	return 1;
    }

    run_setup (cmdline);
    free (cmdline);

    return run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL|RUN_REALLY);
}



/*
 * Run the pre-commit checks for the dir
 */
/* ARGSUSED */
static int
check_filesdoneproc (void *callerdat, int err, const char *repos,
                     const char *update_dir, List *entries)
{
    int n;
    Node *p;
    List *saved_ulist;

    /* find the update list for this dir */
    p = findnode (mulist, update_dir);
    if (p != NULL)
	saved_ulist = ((struct master_lists *) p->data)->ulist;
    else
	saved_ulist = NULL;

    /* skip the checks if there's nothing to do */
    if (saved_ulist == NULL || saved_ulist->list->next == saved_ulist->list)
	return err;

    /* run any pre-commit checks */
    n = Parse_Info (CVSROOTADM_COMMITINFO, repos, precommit_proc, PIOPT_ALL,
                    saved_ulist);
    if (n > 0)
    {
	error (0, 0, "Pre-commit check failed");
	err += n;
    }

    return err;
}



/*
 * Do the work of committing a file
 */
static int maxrev;
static char *sbranch;

/* ARGSUSED */
static int
commit_fileproc (void *callerdat, struct file_info *finfo)
{
    Node *p;
    int err = 0;
    List *ulist, *cilist;
    struct commit_info *ci;

    /* Keep track of whether write_dirtag is a branch tag.
       Note that if it is a branch tag in some files and a nonbranch tag
       in others, treat it as a nonbranch tag.  It is possible that case
       should elicit a warning or an error.  */
    if (write_dirtag != NULL
	&& finfo->rcs != NULL)
    {
	char *rev = RCS_getversion (finfo->rcs, write_dirtag, NULL, 1, NULL);
	if (rev != NULL
	    && !RCS_nodeisbranch (finfo->rcs, write_dirtag))
	    write_dirnonbranch = 1;
	if (rev != NULL)
	    free (rev);
    }

    if (finfo->update_dir[0] == '\0')
	p = findnode (mulist, ".");
    else
	p = findnode (mulist, finfo->update_dir);

    /*
     * if p is null, there were file type command line args which were
     * all up-to-date so nothing really needs to be done
     */
    if (p == NULL)
	return 0;
    ulist = ((struct master_lists *) p->data)->ulist;
    cilist = ((struct master_lists *) p->data)->cilist;

    /*
     * At this point, we should have the commit message unless we were called
     * with files as args from the command line.  In that latter case, we
     * need to get the commit message ourselves
     */
    if (!got_message)
    {
	got_message = 1;
	if (
#ifdef SERVER_SUPPORT
	    !server_active &&
#endif
	    use_editor)
	    do_editor (finfo->update_dir, &saved_message,
		       finfo->repository, ulist);
	do_verify (&saved_message, finfo->repository);
    }

    p = findnode (cilist, finfo->file);
    if (p == NULL)
	return 0;

    ci = p->data;
    if (ci->status == T_MODIFIED)
    {
	if (finfo->rcs == NULL)
	    error (1, 0, "internal error: no parsed RCS file");
	if (lock_RCS (finfo->file, finfo->rcs, ci->rev,
		      finfo->repository) != 0)
	{
	    unlockrcs (finfo->rcs);
	    err = 1;
	    goto out;
	}
    }
    else if (ci->status == T_ADDED)
    {
	if (checkaddfile (finfo->file, finfo->repository, ci->tag, ci->options,
			  &finfo->rcs) != 0)
	{
	    if (finfo->rcs != NULL)
		fixaddfile (finfo->rcs->path);
	    err = 1;
	    goto out;
	}

	/* adding files with a tag, now means adding them on a branch.
	   Since the branch test was done in check_fileproc for
	   modified files, we need to stub it in again here. */

	if (ci->tag

	    /* If numeric, it is on the trunk; check_fileproc enforced
	       this.  */
	    && !isdigit ((unsigned char) ci->tag[0]))
	{
	    if (finfo->rcs == NULL)
		error (1, 0, "internal error: no parsed RCS file");
	    if (ci->rev)
		free (ci->rev);
	    ci->rev = RCS_whatbranch (finfo->rcs, ci->tag);
	    err = Checkin ('A', finfo, ci->rev,
			   ci->tag, ci->options, saved_message);
	    if (err != 0)
	    {
		unlockrcs (finfo->rcs);
		fixbranch (finfo->rcs, sbranch);
	    }

	    (void) time (&last_register_time);

	    ci->status = T_UPTODATE;
	}
    }

    /*
     * Add the file for real
     */
    if (ci->status == T_ADDED)
    {
	char *xrev = NULL;

	if (ci->rev == NULL)
	{
	    /* find the max major rev number in this directory */
	    maxrev = 0;
	    (void) walklist (finfo->entries, findmaxrev, NULL);
	    if (finfo->rcs->head) {
		/* resurrecting: include dead revision */
		int thisrev = atoi (finfo->rcs->head);
		if (thisrev > maxrev)
		    maxrev = thisrev;
	    }
	    if (maxrev == 0)
		maxrev = 1;
	    xrev = xmalloc (20);
	    (void) sprintf (xrev, "%d", maxrev);
	}

	/* XXX - an added file with symbolic -r should add tag as well */
	err = finaladd (finfo, ci->rev ? ci->rev : xrev, ci->tag, ci->options);
	if (xrev)
	    free (xrev);
    }
    else if (ci->status == T_MODIFIED)
    {
	err = Checkin ('M', finfo, ci->rev, ci->tag,
		       ci->options, saved_message);

	(void) time (&last_register_time);

	if (err != 0)
	{
	    unlockrcs (finfo->rcs);
	    fixbranch (finfo->rcs, sbranch);
	}
    }
    else if (ci->status == T_REMOVED)
    {
	err = remove_file (finfo, ci->tag, saved_message);
#ifdef SERVER_SUPPORT
	if (server_active) {
	    server_scratch_entry_only ();
	    server_updated (finfo,
			    NULL,

			    /* Doesn't matter, it won't get checked.  */
			    SERVER_UPDATED,

			    (mode_t) -1,
			    NULL,
			    NULL);
	}
#endif
    }

    /* Clearly this is right for T_MODIFIED.  I haven't thought so much
       about T_ADDED or T_REMOVED.  */
    notify_do ('C', finfo->file, finfo->update_dir, getcaller (), NULL, NULL,
	       finfo->repository);

out:
    if (err != 0)
    {
	/* on failure, remove the file from ulist */
	p = findnode (ulist, finfo->file);
	if (p)
	    delnode (p);
    }
    else
    {
	/* On success, retrieve the new version number of the file and
           copy it into the log information (see logmsg.c
           (logfile_write) for more details).  We should only update
           the version number for files that have been added or
           modified but not removed since classify_file_internal
           will return the version number of a file even after it has
           been removed from the archive, which is not the behavior we
           want for our commitlog messages; we want the old version
           number and then "NONE." */

	if (ci->status != T_REMOVED)
	{
	    p = findnode (ulist, finfo->file);
	    if (p)
	    {
		Vers_TS *vers;
		struct logfile_info *li;

		(void) classify_file_internal (finfo, &vers);
		li = p->data;
		li->rev_new = xstrdup (vers->vn_rcs);
		freevers_ts (&vers);
	    }
	}
    }
    if (SIG_inCrSect ())
	SIG_endCrSect ();

    return err;
}



/*
 * Log the commit and clean up the update list
 */
/* ARGSUSED */
static int
commit_filesdoneproc (void *callerdat, int err, const char *repository,
                      const char *update_dir, List *entries)
{
    Node *p;
    List *ulist;

    p = findnode (mulist, update_dir);
    if (p == NULL)
	return err;

    ulist = ((struct master_lists *) p->data)->ulist;

    got_message = 0;

    /* Build the administrative files if necessary.  */
    {
	const char *p;

	if (strncmp (current_parsed_root->directory, repository,
		     strlen (current_parsed_root->directory)) != 0)
	    error (0, 0,
		 "internal error: repository (%s) doesn't begin with root (%s)",
		   repository, current_parsed_root->directory);
	p = repository + strlen (current_parsed_root->directory);
	if (*p == '/')
	    ++p;
	if (strcmp ("CVSROOT", p) == 0
	    /* Check for subdirectories because people may want to create
	       subdirectories and list files therein in checkoutlist.  */
	    || strncmp ("CVSROOT/", p, strlen ("CVSROOT/")) == 0
	    )
	{
	    /* "Database" might a little bit grandiose and/or vague,
	       but "checked-out copies of administrative files, unless
	       in the case of modules and you are using ndbm in which
	       case modules.{pag,dir,db}" is verbose and excessively
	       focused on how the database is implemented.  */

	    /* mkmodules requires the absolute name of the CVSROOT directory.
	       Remove anything after the `CVSROOT' component -- this is
	       necessary when committing in a subdirectory of CVSROOT.  */
	    char *admin_dir = xstrdup (repository);
	    int cvsrootlen = strlen ("CVSROOT");
	    assert (admin_dir[p - repository + cvsrootlen] == '\0'
		    || admin_dir[p - repository + cvsrootlen] == '/');
	    admin_dir[p - repository + cvsrootlen] = '\0';

	    if (!really_quiet)
	    {
		cvs_output (program_name, 0);
		cvs_output (" ", 1);
		cvs_output (cvs_cmd_name, 0);
		cvs_output (": Rebuilding administrative file database\n", 0);
	    }
	    mkmodules (admin_dir);
	    free (admin_dir);
	    WriteTemplate (".", 1, repository);
	}
    }

    /* FIXME: This used to be above the block above.  The advantage of being
     * here is that it is not called until after all possible writes from this
     * process are complete.  The disadvantage is that a fatal error during
     * update of CVSROOT can prevent the loginfo script from being called.
     *
     * A more general solution I have been considering is calling a generic
     * "postwrite" hook from the remove write lock routine.
     */
    Update_Logfile (repository, saved_message, NULL, ulist);

    return err;
}



/*
 * Get the log message for a dir
 */
/* ARGSUSED */
static Dtype
commit_direntproc (void *callerdat, const char *dir, const char *repos,
                   const char *update_dir, List *entries)
{
    Node *p;
    List *ulist;
    char *real_repos;

    if (!isdir (dir))
	return R_SKIP_ALL;

    /* find the update list for this dir */
    p = findnode (mulist, update_dir);
    if (p != NULL)
	ulist = ((struct master_lists *) p->data)->ulist;
    else
	ulist = NULL;

    /* skip the files as an optimization */
    if (ulist == NULL || ulist->list->next == ulist->list)
	return R_SKIP_FILES;

    /* get commit message */
    got_message = 1;
    real_repos = Name_Repository (dir, update_dir);
    if (
#ifdef SERVER_SUPPORT
        !server_active &&
#endif
        use_editor)
	do_editor (update_dir, &saved_message, real_repos, ulist);
    do_verify (&saved_message, real_repos);
    free (real_repos);
    return R_PROCESS;
}



/*
 * Process the post-commit proc if necessary
 */
/* ARGSUSED */
static int
commit_dirleaveproc (void *callerdat, const char *dir, int err,
                     const char *update_dir, List *entries)
{
    /* update the per-directory tag info */
    /* FIXME?  Why?  The "commit examples" node of cvs.texinfo briefly
       mentions commit -r being sticky, but apparently in the context of
       this being a confusing feature!  */
    if (err == 0 && write_dirtag != NULL)
    {
	char *repos = Name_Repository (NULL, update_dir);
	WriteTag (NULL, write_dirtag, NULL, write_dirnonbranch,
		  update_dir, repos);
	free (repos);
    }

    return err;
}



/*
 * find the maximum major rev number in an entries file
 */
static int
findmaxrev (Node *p, void *closure)
{
    int thisrev;
    Entnode *entdata = p->data;

    if (entdata->type != ENT_FILE)
	return 0;
    thisrev = atoi (entdata->version);
    if (thisrev > maxrev)
	maxrev = thisrev;
    return 0;
}

/*
 * Actually remove a file by moving it to the attic
 * XXX - if removing a ,v file that is a relative symbolic link to
 * another ,v file, we probably should add a ".." component to the
 * link to keep it relative after we move it into the attic.

   Return value is 0 on success, or >0 on error (in which case we have
   printed an error message).  */
static int
remove_file (struct file_info *finfo, char *tag, char *message)
{
    int retcode;

    int branch;
    int lockflag;
    char *corev;
    char *rev;
    char *prev_rev;
    char *old_path;

    corev = NULL;
    rev = NULL;
    prev_rev = NULL;

    retcode = 0;

    if (finfo->rcs == NULL)
	error (1, 0, "internal error: no parsed RCS file");

    branch = 0;
    if (tag && !(branch = RCS_nodeisbranch (finfo->rcs, tag)))
    {
	/* a symbolic tag is specified; just remove the tag from the file */
	if ((retcode = RCS_deltag (finfo->rcs, tag)) != 0)
	{
	    if (!quiet)
		error (0, retcode == -1 ? errno : 0,
		       "failed to remove tag `%s' from `%s'", tag,
		       finfo->fullname);
	    return 1;
	}
	RCS_rewrite (finfo->rcs, NULL, NULL);
	Scratch_Entry (finfo->entries, finfo->file);
	return 0;
    }

    /* we are removing the file from either the head or a branch */
    /* commit a new, dead revision. */

    rev = NULL;
    lockflag = 1;
    if (branch)
    {
	char *branchname;

	rev = RCS_whatbranch (finfo->rcs, tag);
	if (rev == NULL)
	{
	    error (0, 0, "cannot find branch \"%s\".", tag);
	    return 1;
	}

	branchname = RCS_getbranch (finfo->rcs, rev, 1);
	if (branchname == NULL)
	{
	    /* no revision exists on this branch.  use the previous
	       revision but do not lock. */
	    corev = RCS_gettag (finfo->rcs, tag, 1, NULL);
	    prev_rev = xstrdup (corev);
	    lockflag = 0;
	} else
	{
	    corev = xstrdup (rev);
	    prev_rev = xstrdup (branchname);
	    free (branchname);
	}

    } else  /* Not a branch */
    {
        /* Get current head revision of file. */
	prev_rev = RCS_head (finfo->rcs);
    }

    /* if removing without a tag or a branch, then make sure the default
       branch is the trunk. */
    if (!tag && !branch)
    {
        if (RCS_setbranch (finfo->rcs, NULL) != 0)
	{
	    error (0, 0, "cannot change branch to default for %s",
		   finfo->fullname);
	    return 1;
	}
	RCS_rewrite (finfo->rcs, NULL, NULL);
    }

    /* check something out.  Generally this is the head.  If we have a
       particular rev, then name it.  */
    retcode = RCS_checkout (finfo->rcs, finfo->file, rev ? corev : NULL,
			    NULL, NULL, RUN_TTY, NULL, NULL);
    if (retcode != 0)
    {
	error (0, 0,
	       "failed to check out `%s'", finfo->fullname);
	return 1;
    }

    /* Except when we are creating a branch, lock the revision so that
       we can check in the new revision.  */
    if (lockflag)
    {
	if (RCS_lock (finfo->rcs, rev ? corev : NULL, 1) == 0)
	    RCS_rewrite (finfo->rcs, NULL, NULL);
    }

    if (corev != NULL)
	free (corev);

    retcode = RCS_checkin (finfo->rcs, NULL, finfo->file, message,
			   rev, 0, RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);
    if (retcode	!= 0)
    {
	if (!quiet)
	    error (0, retcode == -1 ? errno : 0,
		   "failed to commit dead revision for `%s'", finfo->fullname);
	return 1;
    }
    /* At this point, the file has been committed as removed.  We should
       probably tell the history file about it  */
    history_write ('R', NULL, finfo->rcs->head, finfo->file, finfo->repository);

    if (rev != NULL)
	free (rev);

    old_path = xstrdup (finfo->rcs->path);
    if (!branch)
	RCS_setattic (finfo->rcs, 1);

    /* Print message that file was removed. */
    if (!really_quiet)
    {
	cvs_output (old_path, 0);
	cvs_output ("  <--  ", 0);
	if (finfo->update_dir && strlen (finfo->update_dir))
	{
	    cvs_output (finfo->update_dir, 0);
	    cvs_output ("/", 1);
	}
	cvs_output (finfo->file, 0);
	cvs_output ("\nnew revision: delete; previous revision: ", 0);
	cvs_output (prev_rev, 0);
	cvs_output ("\n", 0);
    }

    free (prev_rev);

    free (old_path);

    Scratch_Entry (finfo->entries, finfo->file);
    return 0;
}



/*
 * Do the actual checkin for added files
 */
static int
finaladd (struct file_info *finfo, char *rev, char *tag, char *options)
{
    int ret;

    ret = Checkin ('A', finfo, rev, tag, options, saved_message);
    if (ret == 0)
    {
	char *tmp = xmalloc (strlen (finfo->file) + sizeof (CVSADM)
			     + sizeof (CVSEXT_LOG) + 10);
	(void) sprintf (tmp, "%s/%s%s", CVSADM, finfo->file, CVSEXT_LOG);
	if (unlink_file (tmp) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", tmp);
	free (tmp);
    }
    else if (finfo->rcs != NULL)
	fixaddfile (finfo->rcs->path);

    (void) time (&last_register_time);

    return ret;
}



/*
 * Unlock an rcs file
 */
static void
unlockrcs (RCSNode *rcs)
{
    int retcode;

    if ((retcode = RCS_unlock (rcs, NULL, 1)) != 0)
	error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
	       "could not unlock %s", rcs->path);
    else
	RCS_rewrite (rcs, NULL, NULL);
}



/*
 * remove a partially added file.  if we can parse it, leave it alone.
 *
 * FIXME: Every caller that calls this function can access finfo->rcs (the
 * parsed RCSNode data), so we should be able to detect that the file needs
 * to be removed without reparsing the file as we do below.
 */
static void
fixaddfile (const char *rcs)
{
    RCSNode *rcsfile;
    int save_really_quiet;

    save_really_quiet = really_quiet;
    really_quiet = 1;
    if ((rcsfile = RCS_parsercsfile (rcs)) == NULL)
    {
	if (unlink_file (rcs) < 0)
	    error (0, errno, "cannot remove %s", rcs);
    }
    else
	freercsnode (&rcsfile);
    really_quiet = save_really_quiet;
}



/*
 * put the branch back on an rcs file
 */
static void
fixbranch (RCSNode *rcs, char *branch)
{
    int retcode;

    if (branch != NULL)
    {
	if ((retcode = RCS_setbranch (rcs, branch)) != 0)
	    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		   "cannot restore branch to %s for %s", branch, rcs->path);
	RCS_rewrite (rcs, NULL, NULL);
    }
}



/*
 * do the initial part of a file add for the named file.  if adding
 * with a tag, put the file in the Attic and point the symbolic tag
 * at the committed revision.
 *
 * INPUTS
 *   file	The name of the file in the workspace.
 *   repository	The repository directory to expect to find FILE,v in.
 *   tag	The name or rev num of the branch being added to, if any.
 *   options	Any RCS keyword expansion options specified by the user.
 *   rcsnode	A pointer to the pre-parsed RCSNode for this file, if the file
 *		exists in the repository.  If this is NULL, assume the file
 *		does not yet exist.
 *
 * RETURNS
 *   0 on success.
 *   1 on errors, after printing any appropriate error messages.
 *
 * ERRORS
 *   This function will return an error when any of the following functions do:
 *     add_rcs_file
 *     RCS_setattic
 *     lock_RCS
 *     RCS_checkin
 *     RCS_parse (called to verify the newly created archive file)
 *     RCS_settag
 */

static int
checkaddfile (const char *file, const char *repository, const char *tag,
              const char *options, RCSNode **rcsnode)
{
    RCSNode *rcs;
    char *fname;
    int newfile = 0;		/* Set to 1 if we created a new RCS archive. */
    int retval = 1;
    int adding_on_branch;

    assert (rcsnode != NULL);

    /* Callers expect to be able to use either "" or NULL to mean the
       default keyword expansion.  */
    if (options != NULL && options[0] == '\0')
	options = NULL;
    if (options != NULL)
	assert (options[0] == '-' && options[1] == 'k');

    /* If numeric, it is on the trunk; check_fileproc enforced
       this.  */
    adding_on_branch = tag != NULL && !isdigit ((unsigned char) tag[0]);

    if (*rcsnode == NULL)
    {
	char *rcsname;
	char *desc = NULL;
	size_t descalloc = 0;
	size_t desclen = 0;
	const char *opt;

	if ( adding_on_branch )
	{
	    mode_t omask;
	    rcsname = xmalloc (strlen (repository)
			       + sizeof (CVSATTIC)
			       + strlen (file)
			       + sizeof (RCSEXT)
			       + 3);
	    (void) sprintf (rcsname, "%s/%s", repository, CVSATTIC);
	    omask = umask ( cvsumask );
	    if (CVS_MKDIR (rcsname, 0777 ) != 0 && errno != EEXIST)
		error (1, errno, "cannot make directory `%s'", rcsname);
	    (void) umask ( omask );
	    (void) sprintf (rcsname,
			    "%s/%s/%s%s",
			    repository,
			    CVSATTIC,
			    file,
			    RCSEXT);
	}
	else
	{
	    rcsname = xmalloc (strlen (repository)
			       + strlen (file)
			       + sizeof (RCSEXT)
			       + 2);
	    (void) sprintf (rcsname,
			    "%s/%s%s",
			    repository,
			    file,
			    RCSEXT);
	}

	/* this is the first time we have ever seen this file; create
	   an RCS file.  */
	fname = xmalloc (strlen (file) + sizeof (CVSADM)
			 + sizeof (CVSEXT_LOG) + 10);
	(void) sprintf (fname, "%s/%s%s", CVSADM, file, CVSEXT_LOG);
	/* If the file does not exist, no big deal.  In particular, the
	   server does not (yet at least) create CVSEXT_LOG files.  */
	if (isfile (fname))
	    /* FIXME: Should be including update_dir in the appropriate
	       place here.  */
	    get_file (fname, fname, "r", &desc, &descalloc, &desclen);
	free (fname);

	/* From reading the RCS 5.7 source, "rcs -i" adds a newline to the
	   end of the log message if the message is nonempty.
	   Do it.  RCS also deletes certain whitespace, in cleanlogmsg,
	   which we don't try to do here.  */
	if (desclen > 0)
	{
	    expand_string (&desc, &descalloc, desclen + 1);
	    desc[desclen++] = '\012';
	}

	/* Set RCS keyword expansion options.  */
	if (options != NULL)
	    opt = options + 2;
	else
	    opt = NULL;

	if (add_rcs_file (NULL, rcsname, file, NULL, opt,
			  NULL, NULL, 0, NULL,
			  desc, desclen, NULL, 0) != 0)
	{
	    if (rcsname != NULL)
	        free (rcsname);
	    goto out;
	}
	rcs = RCS_parsercsfile (rcsname);
	newfile = 1;
	if (rcsname != NULL)
	    free (rcsname);
	if (desc != NULL)
	    free (desc);
	*rcsnode = rcs;
    }
    else
    {
	/* file has existed in the past.  Prepare to resurrect. */
	char *rev;
	char *oldexpand;

	rcs = *rcsnode;

	oldexpand = RCS_getexpand (rcs);
	if ((oldexpand != NULL
	     && options != NULL
	     && strcmp (options + 2, oldexpand) != 0)
	    || (oldexpand == NULL && options != NULL))
	{
	    /* We tell the user about this, because it means that the
	       old revisions will no longer retrieve the way that they
	       used to.  */
	    error (0, 0, "changing keyword expansion mode to %s", options);
	    RCS_setexpand (rcs, options + 2);
	}

	if (!adding_on_branch)
	{
	    /* We are adding on the trunk, so move the file out of the
	       Attic.  */
	    if (!(rcs->flags & INATTIC))
	    {
		error (0, 0, "warning: expected %s to be in Attic",
		       rcs->path);
	    }

	    /* Begin a critical section around the code that spans the
	       first commit on the trunk of a file that's already been
	       committed on a branch.  */
	    SIG_beginCrSect ();

	    if (RCS_setattic (rcs, 0))
	    {
		goto out;
	    }
	}

	rev = RCS_getversion (rcs, tag, NULL, 1, NULL);
	/* and lock it */
	if (lock_RCS (file, rcs, rev, repository))
	{
	    error (0, 0, "cannot lock `%s'.", rcs->path);
	    if (rev != NULL)
		free (rev);
	    goto out;
	}

	if (rev != NULL)
	    free (rev);
    }

    /* when adding a file for the first time, and using a tag, we need
       to create a dead revision on the trunk.  */
    if (adding_on_branch)
    {
	if (newfile)
	{
	    char *tmp;
	    FILE *fp;
	    int retcode;

	    /* move the new file out of the way. */
	    fname = xmalloc (strlen (file) + sizeof (CVSADM)
			     + sizeof (CVSPREFIX) + 10);
	    (void) sprintf (fname, "%s/%s%s", CVSADM, CVSPREFIX, file);
	    rename_file (file, fname);

	    /* Create empty FILE.  Can't use copy_file with a DEVNULL
	       argument -- copy_file now ignores device files. */
	    fp = fopen (file, "w");
	    if (fp == NULL)
		error (1, errno, "cannot open %s for writing", file);
	    if (fclose (fp) < 0)
		error (0, errno, "cannot close %s", file);

	    tmp = xmalloc (strlen (file) + strlen (tag) + 80);
	    /* commit a dead revision. */
	    (void) sprintf (tmp, "file %s was initially added on branch %s.",
			    file, tag);
	    retcode = RCS_checkin (rcs, NULL, NULL, tmp, NULL, 0,
				   RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);
	    free (tmp);
	    if (retcode != 0)
	    {
		error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		       "could not create initial dead revision %s", rcs->path);
		goto out;
	    }

	    /* put the new file back where it was */
	    rename_file (fname, file);
	    free (fname);

	    /* double-check that the file was written correctly */
	    freercsnode (&rcs);
	    rcs = RCS_parse (file, repository);
	    if (rcs == NULL)
	    {
		error (0, 0, "could not read %s", rcs->path);
		goto out;
	    }
	    *rcsnode = rcs;

	    /* and lock it once again. */
	    if (lock_RCS (file, rcs, NULL, repository))
	    {
		error (0, 0, "cannot lock `%s'.", rcs->path);
		goto out;
	    }
	}

	/* when adding with a tag, we need to stub a branch, if it
	   doesn't already exist.  */
	if (!RCS_nodeisbranch (rcs, tag))
	{
	    /* branch does not exist.  Stub it.  */
	    char *head;
	    char *magicrev;
	    int retcode;
	    time_t headtime = -1;
	    char *revnum, *tmp;
	    FILE *fp;
	    time_t t = -1;
	    struct tm *ct;

	    fixbranch (rcs, sbranch);

	    head = RCS_getversion (rcs, NULL, NULL, 0, NULL);
	    magicrev = RCS_magicrev (rcs, head);

	    /* If this is not a new branch, then we will want a dead
	       version created before this one. */
	    if (!newfile)
		headtime = RCS_getrevtime (rcs, head, 0, 0);

	    retcode = RCS_settag (rcs, tag, magicrev);
	    RCS_rewrite (rcs, NULL, NULL);

	    free (head);
	    free (magicrev);

	    if (retcode != 0)
	    {
		error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		       "could not stub branch %s for %s", tag, rcs->path);
		goto out;
	    }
	    /* We need to add a dead version here to avoid -rtag -Dtime
	       checkout problems between when the head version was
	       created and now. */
	    if (!newfile && headtime != -1)
	    {
		/* move the new file out of the way. */
		fname = Xasprintf ("%s/%s%s", CVSADM, CVSPREFIX, file);
		rename_file (file, fname);

		/* Create empty FILE.  Can't use copy_file with a DEVNULL
		   argument -- copy_file now ignores device files. */
		fp = fopen (file, "w");
		if (fp == NULL)
		    error (1, errno, "cannot open %s for writing", file);
		if (fclose (fp) < 0)
		    error (0, errno, "cannot close %s", file);

		/* As we will be hacking the delta date, put the time
		   this was added into the log message. */
		t = time(NULL);
		ct = gmtime(&t);
		tmp = Xasprintf ("file %s was added on branch %s on %lld-%02d-%02d %02d:%02d:%02d +0000",
				 file, tag,
				 (int64_t)ct->tm_year
				  + (ct->tm_year < 100 ? 0 : 1900),
				 ct->tm_mon + 1, ct->tm_mday,
				 ct->tm_hour, ct->tm_min, ct->tm_sec);

		/* commit a dead revision. */
		revnum = RCS_whatbranch (rcs, tag);
		retcode = RCS_checkin (rcs, NULL, NULL, tmp, revnum, headtime,
				       RCS_FLAGS_DEAD |
				       RCS_FLAGS_QUIET |
				       RCS_FLAGS_USETIME);
		free (revnum);
		free (tmp);

		if (retcode != 0)
		{
		    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
			   "could not created dead stub %s for %s", tag,
			   rcs->path);
		    goto out;
		}

		/* put the new file back where it was */
		rename_file (fname, file);
		free (fname);

		/* double-check that the file was written correctly */
		freercsnode (&rcs);
		rcs = RCS_parse (file, repository);
		if (rcs == NULL)
		{
		    error (0, 0, "could not read %s", rcs->path);
		    goto out;
		}
		*rcsnode = rcs;
	    }
	}
	else
	{
	    /* lock the branch. (stubbed branches need not be locked.)  */
	    if (lock_RCS (file, rcs, NULL, repository))
	    {
		error (0, 0, "cannot lock `%s'.", rcs->path);
		goto out;
	    }
	}

	if (*rcsnode != rcs)
	{
	    freercsnode(rcsnode);
	    *rcsnode = rcs;
	}
    }

    fileattr_newfile (file);

    /* At this point, we used to set the file mode of the RCS file
       based on the mode of the file in the working directory.  If we
       are creating the RCS file for the first time, add_rcs_file does
       this already.  If we are re-adding the file, then perhaps it is
       consistent to preserve the old file mode, just as we preserve
       the old keyword expansion mode.

       If we decide that we should change the modes, then we can't do
       it here anyhow.  At this point, the RCS file may be owned by
       somebody else, so a chmod will fail.  We need to instead do the
       chmod after rewriting it.

       FIXME: In general, I think the file mode (and the keyword
       expansion mode) should be associated with a particular revision
       of the file, so that it is possible to have different revisions
       of a file have different modes.  */

    retval = 0;

 out:
    if (retval != 0 && SIG_inCrSect ())
	SIG_endCrSect ();
    return retval;
}



/*
 * Attempt to place a lock on the RCS file; returns 0 if it could and 1 if it
 * couldn't.  If the RCS file currently has a branch as the head, we must
 * move the head back to the trunk before locking the file, and be sure to
 * put the branch back as the head if there are any errors.
 */
static int
lock_RCS (const char *user, RCSNode *rcs, const char *rev,
          const char *repository)
{
    char *branch = NULL;
    int err = 0;

    /*
     * For a specified, numeric revision of the form "1" or "1.1", (or when
     * no revision is specified ""), definitely move the branch to the trunk
     * before locking the RCS file.
     *
     * The assumption is that if there is more than one revision on the trunk,
     * the head points to the trunk, not a branch... and as such, it's not
     * necessary to move the head in this case.
     */
    if (rev == NULL
	|| (rev && isdigit ((unsigned char) *rev) && numdots (rev) < 2))
    {
	branch = xstrdup (rcs->branch);
	if (branch != NULL)
	{
	    if (RCS_setbranch (rcs, NULL) != 0)
	    {
		error (0, 0, "cannot change branch to default for %s",
		       rcs->path);
		if (branch)
		    free (branch);
		return 1;
	    }
	}
	err = RCS_lock (rcs, NULL, 1);
    }
    else
    {
	RCS_lock (rcs, rev, 1);
    }

    /* We used to call RCS_rewrite here, and that might seem
       appropriate in order to write out the locked revision
       information.  However, such a call would actually serve no
       purpose.  CVS locks will prevent any interference from other
       CVS processes.  The comment above rcs_internal_lockfile
       explains that it is already unsafe to use RCS and CVS
       simultaneously.  It follows that writing out the locked
       revision information here would add no additional security.

       If we ever do care about it, the proper fix is to create the
       RCS lock file before calling this function, and maintain it
       until the checkin is complete.

       The call to RCS_lock is still required at present, since in
       some cases RCS_checkin will determine which revision to check
       in by looking for a lock.  FIXME: This is rather roundabout,
       and a more straightforward approach would probably be easier to
       understand.  */

    if (err == 0)
    {
	if (sbranch != NULL)
	    free (sbranch);
	sbranch = branch;
	return 0;
    }

    /* try to restore the branch if we can on error */
    if (branch != NULL)
	fixbranch (rcs, branch);

    if (branch)
	free (branch);
    return 1;
}



/*
 * free an UPDATE node's data
 */
void
update_delproc (Node *p)
{
    struct logfile_info *li = p->data;

    if (li->tag)
	free (li->tag);
    if (li->rev_old)
	free (li->rev_old);
    if (li->rev_new)
	free (li->rev_new);
    free (li);
}

/*
 * Free the commit_info structure in p.
 */
static void
ci_delproc (Node *p)
{
    struct commit_info *ci = p->data;

    if (ci->rev)
	free (ci->rev);
    if (ci->tag)
	free (ci->tag);
    if (ci->options)
	free (ci->options);
    free (ci);
}

/*
 * Free the commit_info structure in p.
 */
static void
masterlist_delproc (Node *p)
{
    struct master_lists *ml = p->data;

    dellist (&ml->ulist);
    dellist (&ml->cilist);
    free (ml);
}
@


1.4
log
@merge CVS - SECURITY FIX!
@
text
@d1 2
a18 1
#include <assert.h>
d25 35
a59 34
static Dtype check_direntproc PROTO ((void *callerdat, char *dir,
				      char *repos, char *update_dir,
				      List *entries));
static int check_fileproc PROTO ((void *callerdat, struct file_info *finfo));
static int check_filesdoneproc PROTO ((void *callerdat, int err,
				       char *repos, char *update_dir,
				       List *entries));
static int checkaddfile PROTO((char *file, char *repository, char *tag,
			       char *options, RCSNode **rcsnode));
static Dtype commit_direntproc PROTO ((void *callerdat, char *dir,
				       char *repos, char *update_dir,
				       List *entries));
static int commit_dirleaveproc PROTO ((void *callerdat, char *dir,
				       int err, char *update_dir,
				       List *entries));
static int commit_fileproc PROTO ((void *callerdat, struct file_info *finfo));
static int commit_filesdoneproc PROTO ((void *callerdat, int err,
					char *repository, char *update_dir,
					List *entries));
static int finaladd PROTO((struct file_info *finfo, char *revision, char *tag,
			   char *options));
static int findmaxrev PROTO((Node * p, void *closure));
static int lock_RCS PROTO((char *user, RCSNode *rcs, char *rev,
			   char *repository));
static int precommit_list_proc PROTO((Node * p, void *closure));
static int precommit_proc PROTO((char *repository, char *filter));
static int remove_file PROTO ((struct file_info *finfo, char *tag,
			       char *message));
static void fixaddfile PROTO((char *file, char *repository));
static void fixbranch PROTO((RCSNode *, char *branch));
static void unlockrcs PROTO((RCSNode *rcs));
static void ci_delproc PROTO((Node *p));
static void masterlist_delproc PROTO((Node *p));
static char *locate_rcs PROTO((char *file, char *repository));
d74 1
a76 1
static int run_module_prog = 1;
a82 1
static List *saved_ulist;
d88 2
a89 2
    "Usage: %s %s [-nRlf] [-m msg | -F logfile] [-r rev] files...\n",
    "    -n          Do not run the module program (if any).\n",
d128 1
a128 1
    char *repository;
d135 1
a135 3
static Dtype find_dirent_proc PROTO ((void *callerdat, char *dir,
				      char *repository, char *update_dir,
				      List *entries));
d138 2
a139 6
find_dirent_proc (callerdat, dir, repository, update_dir, entries)
    void *callerdat;
    char *dir;
    char *repository;
    char *update_dir;
    List *entries;
d141 1
a141 1
    struct find_data *find_data = (struct find_data *)callerdat;
d148 1
a148 1
	return (R_SKIP_ALL);
d162 2
d168 1
a168 1
static void find_ignproc PROTO ((char *, char *));
d171 1
a171 3
find_ignproc (file, dir)
    char *file;
    char *dir;
d175 1
a175 1
    p = (struct question *) xmalloc (sizeof (struct question));
d183 1
a183 3
static int find_filesdoneproc PROTO ((void *callerdat, int err,
				      char *repository, char *update_dir,
				      List *entries));
d186 2
a187 6
find_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
    int err;
    char *repository;
    char *update_dir;
    List *entries;
d189 1
a189 1
    struct find_data *find_data = (struct find_data *)callerdat;
d205 1
a205 1
static int find_fileproc PROTO ((void *callerdat, struct file_info *finfo));
d212 1
a212 3
find_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
d217 1
a217 1
    struct find_data *args = (struct find_data *)callerdat;
d238 1
a238 9
    if (vers->ts_user == NULL
	&& vers->vn_user != NULL
	&& vers->vn_user[0] == '-')
	/* FIXME: If vn_user is starts with "-" but ts_user is
	   non-NULL, what classify_file does is print "%s should be
	   removed and is still there".  I'm not sure what it does
	   then.  We probably should do the same.  */
	status = T_REMOVED;
    else if (vers->vn_user == NULL)
d243 1
a243 1
	    error (0, 0, "use `%s add' to create an entry for %s",
d248 38
a285 9
    else if (vers->ts_user != NULL
	     && vers->vn_user != NULL
	     && vers->vn_user[0] == '0')
	/* FIXME: If vn_user is "0" but ts_user is NULL, what classify_file
	   does is print "new-born %s has disappeared" and removes the entry.
	   We probably should do the same.  */
	status = T_ADDED;
    else if (vers->ts_user != NULL
	     && vers->ts_rcs != NULL
d303 1
a303 1
    data = (struct logfile_info *) xmalloc (sizeof (struct logfile_info));
d310 1
a310 1
    node->data = (char *) data;
d319 1
a319 1
static int copy_ulist PROTO ((Node *, void *));
d322 1
a322 3
copy_ulist (node, data)
    Node *node;
    void *data;
d324 1
a324 1
    struct find_data *args = (struct find_data *)data;
d330 7
d338 1
a338 3
commit (argc, argv)
    int argc;
    char **argv;
d364 4
a367 2
	if ((pw = (struct passwd *) getpwnam (getcaller ())) == NULL)
	    error (1, 0, "you are unknown to this system");
d369 1
a369 1
	    error (1, 0, "cannot commit files as 'root'");
d374 1
a374 1
    while ((c = getopt (argc, argv, "+nlRm:fF:r:")) != -1)
d378 4
d383 3
a385 1
		run_module_prog = 0;
d387 1
d415 1
d438 1
d440 5
a444 3
	/* strip trailing dots */
	while (saved_tag[strlen (saved_tag) - 1] == '.')
	    saved_tag[strlen (saved_tag) - 1] = '\0';
d477 4
a480 5
	err = start_recursion (find_fileproc, find_filesdoneproc,
			       find_dirent_proc, (DIRLEAVEPROC) NULL,
			       (void *)&find_args,
			       argc, argv, local, W_LOCAL, 0, 0,
			       (char *)NULL, 0);
d524 1
a524 6
	    do_editor (".", &saved_message, (char *)NULL, find_args.ulist);

	/* Run the user-defined script to verify/check information in
	 *the log message
	 */
	do_verify (saved_message, (char *)NULL);
d527 1
a527 3
	/* FIXME: is that true?  There seems to be some code in do_editor
	   which can leave the message NULL.  */
	option_with_arg ("-m", saved_message);
d551 20
a570 5
		    send_to_server ("Directory ", 0);
		    send_to_server (p->dir[0] == '\0' ? "." : p->dir, 0);
		    send_to_server ("\012", 1);
		    send_to_server (p->repos, 0);
		    send_to_server ("\012", 1);
d587 2
a590 2
	if (!run_module_prog)
	    send_arg("-n");
d592 1
d647 1
a647 1
	tag_check_valid (saved_tag, argc, argv, local, aflag, "");
d655 1
a655 1
    lock_tree_for_write (argc, argv, local, W_LOCAL, aflag);
d671 1
a671 1
	working_dir = xgetwd();
d679 2
a680 2
			   check_direntproc, (DIRLEAVEPROC) NULL, NULL, argc,
			   argv, local, W_LOCAL, aflag, 0, (char *) NULL, 1);
a681 2
    {
	Lock_Cleanup ();
a682 1
    }
d690 3
a692 3
			       commit_direntproc, commit_dirleaveproc, NULL,
			       argc, argv, local, W_LOCAL, aflag, 0,
			       (char *) NULL, 1);
d700 2
d703 2
a704 2
    if (server_active)
	return err;
d706 6
a712 5
    /* see if we need to sleep before returning to avoid time-stamp races */
    if (last_register_time)
    {
	sleep_past (last_register_time);
    }
a713 2
    return (err);
}
d720 1
a720 3
classify_file_internal (finfo, vers)
    struct file_info *finfo;
    Vers_TS **vers;
d739 2
a740 2
	    status = Classify_File (finfo, (char *) NULL, (char *) NULL,
				    (char *) NULL, 1, aflag, vers, 0);
d747 2
a748 2
		xstatus = Classify_File (finfo, saved_tag, (char *) NULL,
					 (char *) NULL, 1, aflag, vers, 0);
d771 2
a772 2
	    status = Classify_File (finfo, xtag, (char *) NULL,
				    (char *) NULL, 1, aflag, vers, 0);
d779 2
a780 2
		status = Classify_File (finfo, xtag, (char *) NULL,
					(char *) NULL, 1, aflag, vers, 0);
d791 1
a791 2
	status = Classify_File (finfo, saved_tag, (char *) NULL, (char *) NULL,
				1, 0, vers, 0);
d799 2
d807 1
a807 3
check_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
d810 1
a810 1
    char *xdir;
d816 1
d823 1
a823 1
	return (1);
d826 3
a828 2
    if (strncmp (finfo->repository, current_parsed_root->directory, cvsroot_len) == 0
	&& ISDIRSEP (finfo->repository[cvsroot_len])
d832 1
a832 1
	&& ISDIRSEP (finfo->repository[cvsroot_len + sizeof (CVSROOTADM)])
d856 1
a856 2
	    freevers_ts (&vers);
	    return (1);
d860 3
d868 2
a869 1
	     *	- if status is T_REMOVED, can't have a numeric tag
d884 1
a884 2
		    freevers_ts (&vers);
		    return (1);
d892 1
a892 2
		    freevers_ts (&vers);
		    return (1);
a896 3
		char *filestamp;
		int retcode;

d903 1
a903 14
#ifdef SERVER_SUPPORT
		if (server_active)
		    retcode = vers->ts_conflict[0] != '=';
		else {
		    filestamp = time_stamp (finfo->file);
		    retcode = strcmp (vers->ts_conflict, filestamp);
		    free (filestamp);
		}
#else
		filestamp = time_stamp (finfo->file);
		retcode = strcmp (vers->ts_conflict, filestamp);
		free (filestamp);
#endif
		if (retcode == 0)
d908 1
a908 2
		    freevers_ts (&vers);
		    return (1);
d930 23
a952 14
	    if (status == T_REMOVED
		&& vers->tag
		&& isdigit ((unsigned char) *vers->tag))
	    {
		/* Remove also tries to forbid this, but we should check
		   here.  I'm only _sure_ about somewhat obscure cases
		   (hacking the Entries file, using an old version of
		   CVS for the remove and a new one for the commit), but
		   there might be other cases.  */
		error (0, 0,
	"cannot remove file `%s' which has a numeric sticky tag of `%s'",
			   finfo->fullname, vers->tag);
		freevers_ts (&vers);
		return (1);
d964 1
a964 2
			freevers_ts (&vers);
			return (1);
d973 1
a973 2
		    freevers_ts (&vers);
		    return (1);
d991 4
a994 2
		ulist = getlist ();
		cilist = getlist ();
d998 1
a998 5
		ml = (struct master_lists *)
		    xmalloc (sizeof (struct master_lists));
		ml->ulist = ulist;
		ml->cilist = cilist;
		p->data = (char *) ml;
d1008 1
a1008 2
	    li = ((struct logfile_info *)
		  xmalloc (sizeof (struct logfile_info)));
d1010 53
d1066 1
a1066 1
	    p->data = (char *) li;
d1073 1
a1073 1
	    ci = (struct commit_info *) xmalloc (sizeof (struct commit_info));
d1081 1
a1081 1
		ci->rev = (char *) NULL;
d1084 1
a1084 1
	    p->data = (char *) ci;
d1114 1
a1114 2
		    hlinfo = (struct hardlink_info *)
			xmalloc (sizeof (struct hardlink_info));
d1116 1
a1116 1
		    linkp->data = (char *) hlinfo;
d1122 2
d1126 1
a1126 2
	    freevers_ts (&vers);
	    return (1);
d1134 4
d1139 1
a1139 1
    return (0);
d1142 2
d1150 2
a1151 6
check_direntproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
    char *dir;
    char *repos;
    char *update_dir;
    List *entries;
d1154 1
a1154 1
	return (R_SKIP_ALL);
d1159 1
a1159 1
    return (R_PROCESS);
d1162 2
d1165 1
a1165 1
 * Walklist proc to run pre-commit checks
d1168 1
a1168 1
precommit_list_proc (p, closure)
d1172 1
d1174 45
d1220 7
a1226 6
    li = (struct logfile_info *) p->data;
    if (li->type == T_ADDED
	|| li->type == T_MODIFIED
	|| li->type == T_REMOVED)
    {
	run_arg (p->key);
d1228 3
a1230 1
    return (0);
d1233 2
d1239 44
a1282 23
precommit_proc (repository, filter)
    char *repository;
    char *filter;
{
    /* see if the filter is there, only if it's a full path */
    if (isabsolute (filter))
    {
    	char *s, *cp;

	s = xstrdup (filter);
	for (cp = s; *cp; cp++)
	    if (isspace ((unsigned char) *cp))
	    {
		*cp = '\0';
		break;
	    }
	if (!isfile (s))
	{
	    error (0, errno, "cannot find pre-commit filter `%s'", s);
	    free (s);
	    return (1);			/* so it fails! */
	}
	free (s);
d1285 4
a1288 4
    run_setup (filter);
    run_arg (repository);
    (void) walklist (saved_ulist, precommit_list_proc, NULL);
    return (run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL|RUN_REALLY));
d1291 2
d1298 2
a1299 6
check_filesdoneproc (callerdat, err, repos, update_dir, entries)
    void *callerdat;
    int err;
    char *repos;
    char *update_dir;
    List *entries;
d1303 1
d1310 1
a1310 1
	saved_ulist = (List *) NULL;
d1314 1
a1314 1
	return (err);
d1317 3
a1319 1
    if ((n = Parse_Info (CVSROOTADM_COMMITINFO, repos, precommit_proc, 1)) > 0)
d1325 1
a1325 1
    return (err);
d1328 2
d1338 1
a1338 3
commit_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
d1370 1
a1370 1
	return (0);
d1379 1
a1379 1
    if (!(got_message))
d1382 5
a1386 1
	if (use_editor)
d1389 1
a1389 1
	do_verify (saved_message, finfo->repository);
d1394 1
a1394 1
	return (0);
d1396 1
a1396 1
    ci = (struct commit_info *) p->data;
d1414 2
a1415 1
	    fixaddfile (finfo->file, finfo->repository);
d1435 1
a1435 1
	    err = Checkin ('A', finfo, finfo->rcs->path, ci->rev,
d1454 1
a1454 1
	char *xrev = (char *) NULL;
d1480 1
a1480 2
	err = Checkin ('M', finfo,
		       finfo->rcs->path, ci->rev, ci->tag,
d1504 2
a1505 2
			    (unsigned char *) NULL,
			    (struct buffer *) NULL);
d1512 2
a1513 1
    notify_do ('C', finfo->file, getcaller (), NULL, NULL, finfo->repository);
d1529 1
a1529 1
           modified but not removed.  Why?  classify_file_internal
d1544 1
a1544 1
		li = (struct logfile_info *) p->data;
d1553 1
a1553 1
    return (err);
d1556 2
d1563 2
a1564 6
commit_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
    int err;
    char *repository;
    char *update_dir;
    List *entries;
d1571 1
a1571 1
	return (err);
a1576 3

    Update_Logfile (repository, saved_message, (FILE *) 0, ulist);

d1579 1
a1579 1
	char *p;
d1610 7
a1616 4
	    cvs_output (program_name, 0);
	    cvs_output (" ", 1);
	    cvs_output (command_name, 0);
	    cvs_output (": Rebuilding administrative file database\n", 0);
d1619 1
d1623 12
a1634 3
    if (err == 0 && run_module_prog)
    {
	FILE *fp;
a1635 45
	if ((fp = CVS_FOPEN (CVSADM_CIPROG, "r")) != NULL)
	{
	    char *line;
	    int line_length;
	    size_t line_chars_allocated;
	    char *repos;

	    line = NULL;
	    line_chars_allocated = 0;
	    line_length = getline (&line, &line_chars_allocated, fp);
	    if (line_length > 0)
	    {
		/* Remove any trailing newline.  */
		if (line[line_length - 1] == '\n')
		    line[--line_length] = '\0';
		repos = Name_Repository ((char *) NULL, update_dir);
		run_setup (line);
		run_arg (repos);
		cvs_output (program_name, 0);
		cvs_output (" ", 1);
		cvs_output (command_name, 0);
		cvs_output (": Executing '", 0);
		run_print (stdout);
		cvs_output ("'\n", 0);
		cvs_flushout ();
		(void) run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
		free (repos);
	    }
	    else
	    {
		if (ferror (fp))
		    error (0, errno, "warning: error reading %s",
			   CVSADM_CIPROG);
	    }
	    if (line != NULL)
		free (line);
	    if (fclose (fp) < 0)
		error (0, errno, "warning: cannot close %s", CVSADM_CIPROG);
	}
	else
	{
	    if (! existence_error (errno))
		error (0, errno, "warning: cannot open %s", CVSADM_CIPROG);
	}
    }
a1636 2
    return (err);
}
d1643 2
a1644 6
commit_direntproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
    char *dir;
    char *repos;
    char *update_dir;
    List *entries;
d1651 1
a1651 1
	return (R_SKIP_ALL);
d1658 1
a1658 1
	ulist = (List *) NULL;
d1662 1
a1662 1
	return (R_SKIP_FILES);
d1665 1
d1667 5
a1671 2
    got_message = 1;
    if (use_editor)
d1673 1
a1673 1
    do_verify (saved_message, real_repos);
d1675 1
a1675 1
    return (R_PROCESS);
d1678 2
d1685 2
a1686 6
commit_dirleaveproc (callerdat, dir, err, update_dir, entries)
    void *callerdat;
    char *dir;
    int err;
    char *update_dir;
    List *entries;
d1694 1
a1694 1
	char *repos = Name_Repository (dir, update_dir);
d1700 1
a1700 1
    return (err);
d1703 2
d1709 1
a1709 3
findmaxrev (p, closure)
    Node *p;
    void *closure;
d1712 1
a1712 1
    Entnode *entdata;
a1713 1
    entdata = (Entnode *) p->data;
d1715 1
a1715 1
	return (0);
d1719 1
a1719 1
    return (0);
d1731 1
a1731 4
remove_file (finfo, tag, message)
    struct file_info *finfo;
    char *tag;
    char *message;
d1761 1
a1761 1
	    return (1);
d1765 1
a1765 1
	return (0);
a1770 5
    /* Print message indicating that file is going to be removed. */
    cvs_output ("Removing ", 0);
    cvs_output (finfo->fullname, 0);
    cvs_output (";\n", 0);

d1781 1
a1781 1
	    return (1);
d1789 2
a1790 2
	    corev = RCS_gettag (finfo->rcs, tag, 1, (int *) NULL);
	    prev_rev = xstrdup(rev);
d1795 1
a1795 1
	    prev_rev = xstrdup(branchname);
d1813 1
a1813 1
	    return (1);
d1821 1
a1821 2
			    (char *) NULL, (char *) NULL, RUN_TTY,
			    (RCSCHECKOUTPROC) NULL, (void *) NULL);
d1826 1
a1826 1
	return (1);
d1840 2
a1841 2
    retcode = RCS_checkin (finfo->rcs, finfo->file, message, rev,
			   RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);
d1847 1
a1847 1
	return (1);
d1861 16
a1876 7
    cvs_output (old_path, 0);
    cvs_output ("  <--  ", 0);
    cvs_output (finfo->file, 0);
    cvs_output ("\nnew revision: delete; previous revision: ", 0);
    cvs_output (prev_rev, 0);
    cvs_output ("\ndone\n", 0);
    free(prev_rev);
d1881 1
a1881 1
    return (0);
d1884 2
d1890 1
a1890 5
finaladd (finfo, rev, tag, options)
    struct file_info *finfo;
    char *rev;
    char *tag;
    char *options;
a1892 1
    char *rcs;
d1894 1
a1894 2
    rcs = locate_rcs (finfo->file, finfo->repository);
    ret = Checkin ('A', finfo, rcs, rev, tag, options, saved_message);
d1905 2
a1906 2
    else
	fixaddfile (finfo->file, finfo->repository);
a1908 1
    free (rcs);
d1910 1
a1910 1
    return (ret);
d1913 2
d1919 1
a1919 2
unlockrcs (rcs)
    RCSNode *rcs;
d1923 1
a1923 1
    if ((retcode = RCS_unlock (rcs, NULL, 0)) != 0)
d1930 2
d1934 4
d1940 1
a1940 3
fixaddfile (file, repository)
    char *file;
    char *repository;
a1942 1
    char *rcs;
a1944 1
    rcs = locate_rcs (file, repository);
a1954 1
    free (rcs);
d1957 2
d1963 1
a1963 3
fixbranch (rcs, branch)
    RCSNode *rcs;
    char *branch;
d1976 2
d1982 22
d2007 2
a2008 6
checkaddfile (file, repository, tag, options, rcsnode)
    char *file;
    char *repository;
    char *tag;
    char *options;
    RCSNode **rcsnode;
d2010 1
a2010 1
    char *rcs;
d2012 2
a2013 5
    mode_t omask;
    int retcode = 0;
    int newfile = 0;
    RCSNode *rcsfile = NULL;
    int retval;
d2016 2
d2029 1
a2029 1
    if (adding_on_branch)
d2031 36
a2066 11
	rcs = xmalloc (strlen (repository) + strlen (file)
		       + sizeof (RCSEXT) + sizeof (CVSATTIC) + 10);
        (void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
	if (! isreadable (rcs))
	{
	    (void) sprintf(rcs, "%s/%s", repository, CVSATTIC);
	    omask = umask (cvsumask);
	    if (CVS_MKDIR (rcs, 0777) != 0 && errno != EEXIST)
		error (1, errno, "cannot make directory `%s'", rcs);;
	    (void) umask (omask);
	    (void) sprintf (rcs, "%s/%s/%s%s", repository, CVSATTIC, file,
d2069 45
a2115 3
	rcs = locate_rcs (file, repository);

    if (isreadable (rcs))
d2121 1
a2121 6
	if ((rcsfile = *rcsnode) == NULL)
	{
	    error (0, 0, "could not find parsed rcsfile %s", file);
	    retval = 1;
	    goto out;
	}
d2123 1
a2123 1
	oldexpand = RCS_getexpand (rcsfile);
d2133 1
a2133 1
	    RCS_setexpand (rcsfile, options + 2);
d2140 1
a2140 1
	    if (!(rcsfile->flags & INATTIC))
d2143 1
a2143 1
		       rcsfile->path);
a2145 2
	    sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);

d2151 1
a2151 1
	    if (RCS_setattic (rcsfile, 0))
a2152 1
		retval = 1;
d2157 1
a2157 1
	rev = RCS_getversion (rcsfile, tag, NULL, 1, (int *) NULL);
d2159 1
a2159 1
	if (lock_RCS (file, rcsfile, rev, repository))
d2161 1
a2161 1
	    error (0, 0, "cannot lock `%s'.", rcs);
a2163 1
	    retval = 1;
a2169 67
    else
    {
	/* this is the first time we have ever seen this file; create
	   an rcs file.  */

	char *desc;
	size_t descalloc;
	size_t desclen;

	char *opt;

	desc = NULL;
	descalloc = 0;
	desclen = 0;
	fname = xmalloc (strlen (file) + sizeof (CVSADM)
			 + sizeof (CVSEXT_LOG) + 10);
	(void) sprintf (fname, "%s/%s%s", CVSADM, file, CVSEXT_LOG);
	/* If the file does not exist, no big deal.  In particular, the
	   server does not (yet at least) create CVSEXT_LOG files.  */
	if (isfile (fname))
	    /* FIXME: Should be including update_dir in the appropriate
	       place here.  */
	    get_file (fname, fname, "r", &desc, &descalloc, &desclen);
	free (fname);

	/* From reading the RCS 5.7 source, "rcs -i" adds a newline to the
	   end of the log message if the message is nonempty.
	   Do it.  RCS also deletes certain whitespace, in cleanlogmsg,
	   which we don't try to do here.  */
	if (desclen > 0)
	{
	    expand_string (&desc, &descalloc, desclen + 1);
	    desc[desclen++] = '\012';
	}

	/* Set RCS keyword expansion options.  */
	if (options != NULL)
	    opt = options + 2;
	else
	    opt = NULL;

	/* This message is an artifact of the time when this
	   was implemented via "rcs -i".  It should be revised at
	   some point (does the "initial revision" in the message from
	   RCS_checkin indicate that this is a new file?  Or does the
	   "RCS file" message serve some function?).  */
	cvs_output ("RCS file: ", 0);
	cvs_output (rcs, 0);
	cvs_output ("\ndone\n", 0);

	if (add_rcs_file (NULL, rcs, file, NULL, opt,
			  NULL, NULL, 0, NULL,
			  desc, desclen, NULL) != 0)
	{
	    retval = 1;
	    goto out;
	}
	rcsfile = RCS_parsercsfile (rcs);
	newfile = 1;
	if (desc != NULL)
	    free (desc);
	if (rcsnode != NULL)
	{
	    assert (*rcsnode == NULL);
	    *rcsnode = rcsfile;
	}
    }
d2179 1
d2199 1
a2199 1
	    retcode = RCS_checkin (rcsfile, NULL, tmp, NULL,
d2205 1
a2205 2
		       "could not create initial dead revision %s", rcs);
		retval = 1;
d2214 3
a2216 3
	    freercsnode (&rcsfile);
	    rcsfile = RCS_parse (file, repository);
	    if (rcsfile == NULL)
d2218 1
a2218 2
		error (0, 0, "could not read %s", rcs);
		retval = 1;
d2221 1
a2221 2
	    if (rcsnode != NULL)
		*rcsnode = rcsfile;
d2224 1
a2224 1
	    if (lock_RCS (file, rcsfile, NULL, repository))
d2226 1
a2226 2
		error (0, 0, "cannot lock `%s'.", rcs);
		retval = 1;
d2233 1
a2233 18

	if (rcsfile == NULL)
	{
	    if (rcsnode != NULL && *rcsnode != NULL)
		rcsfile = *rcsnode;
	    else
	    {
		rcsfile = RCS_parse (file, repository);
		if (rcsfile == NULL)
		{
		    error (0, 0, "could not read %s", rcs);
		    retval = 1;
		    goto out;
		}
	    }
	}

	if (!RCS_nodeisbranch (rcsfile, tag))
d2238 6
d2245 1
a2245 2
	    head = RCS_getversion (rcsfile, NULL, NULL, 0, (int *) NULL);
	    magicrev = RCS_magicrev (rcsfile, head);
d2247 10
a2256 2
	    retcode = RCS_settag (rcsfile, tag, magicrev);
	    RCS_rewrite (rcsfile, NULL, NULL);
d2264 1
a2264 2
		       "could not stub branch %s for %s", tag, rcs);
		retval = 1;
d2267 59
d2330 1
a2330 1
	    if (lock_RCS (file, rcsfile, NULL, repository))
d2332 1
a2332 2
		error (0, 0, "cannot lock `%s'.", rcs);
		retval = 1;
d2337 1
a2337 1
	if (rcsnode && *rcsnode != rcsfile)
d2340 1
a2340 1
	    *rcsnode = rcsfile;
a2367 1
    free (rcs);
d2371 2
d2380 2
a2381 5
lock_RCS (user, rcs, rev, repository)
    char *user;
    RCSNode *rcs;
    char *rev;
    char *repository;
d2407 1
a2407 1
		return (1);
d2410 1
a2410 1
	err = RCS_lock(rcs, NULL, 1);
d2414 1
a2414 1
	(void) RCS_lock(rcs, rev, 1);
d2441 1
a2441 1
	return (0);
d2450 1
a2450 1
    return (1);
d2453 2
d2459 1
a2459 2
update_delproc (p)
    Node *p;
d2461 1
a2461 1
    struct logfile_info *li;
a2462 1
    li = (struct logfile_info *) p->data;
d2476 1
a2476 2
ci_delproc (p)
    Node *p;
d2478 1
a2478 1
    struct commit_info *ci;
a2479 1
    ci = (struct commit_info *) p->data;
d2493 1
a2493 2
masterlist_delproc (p)
    Node *p;
d2495 1
a2495 1
    struct master_lists *ml;
a2496 1
    ml = (struct master_lists *) p->data;
a2499 27
}

/* Find an RCS file in the repository.  Most parts of CVS will want to
   rely instead on RCS_parse which performs a similar operation and is
   called by recurse.c which then puts the result in useful places
   like the rcs field of struct file_info.

   REPOSITORY is the repository (including the directory) and FILE is
   the filename within that directory (without RCSEXT).  Returns a
   newly-malloc'd array containing the absolute pathname of the RCS
   file that was found.  */
static char *
locate_rcs (file, repository)
    char *file;
    char *repository;
{
    char *rcs;

    rcs = xmalloc (strlen (repository) + strlen (file) + sizeof (RCSEXT) + 10);
    (void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
    if (!isreadable (rcs))
    {
	(void) sprintf (rcs, "%s/%s/%s%s", repository, CVSATTIC, file, RCSEXT);
	if (!isreadable (rcs))
	    (void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
    }
    return rcs;
@


1.3
log
@cvs-1.11.12 doesn't do the joints correctly (what were the
FSF people smoking?), it memory faults.
thusly revert to 1.11.1p1

tested.
agreed bsiegert@@
@
text
@d475 6
a480 1
	find_args.argv = (char **) xmalloc (find_args.argc * sizeof (char **));
@


1.2
log
@first step of merging new cvs
XXX might not compile
XXX might not work
XXX might contain bugs
XXX definitively needs autoconf 2.58 first
@
text
@d52 1
a52 1
static void fixaddfile PROTO((const char *rcs));
d57 1
d74 1
d87 2
a88 1
    "Usage: %s %s [-Rlf] [-m msg | -F logfile] [-r rev] files...\n",
d251 9
a259 1
    if (vers->vn_user == NULL)
d269 9
a277 38
    if (vers->vn_user[0] == '-')
    {
	if (vers->ts_user != NULL)
	{
	    error (0, 0,
		   "`%s' should be removed and is still there (or is back"
		   " again)", finfo->fullname);
	    freevers_ts (&vers);
	    return 1;
	}
	/* else */
	status = T_REMOVED;
    }
    else if (strcmp (vers->vn_user, "0") == 0)
    {
	if (vers->ts_user == NULL)
	{
	    /* This happens when one has `cvs add'ed a file, but it no
	       longer exists in the working directory at commit time.
	       FIXME: What classify_file does in this case is print
	       "new-born %s has disappeared" and removes the entry.
	       We probably should do the same.  */
	    if (!really_quiet)
		error (0, 0, "warning: new-born %s has disappeared",
		       finfo->fullname);
	    status = T_REMOVE_ENTRY;
	}
	else
	    status = T_ADDED;
    }
    else if (vers->ts_user == NULL)
    {
	/* FIXME: What classify_file does in this case is print
	   "%s was lost".  We probably should do the same.  */
	freevers_ts (&vers);
	return 0;
    }
    else if (vers->ts_rcs != NULL
a323 5
#ifdef SERVER_SUPPORT
# define COMMIT_OPTIONS "+nlRm:fF:r:"
#else /* !SERVER_SUPPORT */
# define COMMIT_OPTIONS "+lRm:fF:r:"
#endif /* SERVER_SUPPORT */
d354 1
a354 2
	    error (1, 0, "your apparent username (%s) is unknown to this system",
			 getcaller ());
d356 1
a356 1
	    error (1, 0, "'root' is not allowed to commit files");
d361 1
a361 1
    while( ( c = getopt( argc, argv, COMMIT_OPTIONS ) ) != -1 )
a364 1
#ifdef SERVER_SUPPORT
d366 1
a366 3
		/* Silently ignore -n for compatibility with old
		 * clients.
		 */
a367 1
#endif /* SERVER_SUPPORT */
a416 1
	char *p = saved_tag + strlen (saved_tag);
d418 3
a420 5
	/* strip trailing dots and leading zeros */
	while (*--p == '.') ;
	p[1] = '\0';
	while (saved_tag[0] == '0' && isdigit ((unsigned char) saved_tag[1]))
	    ++saved_tag;
d456 2
a457 2
			       argc, argv, local, W_LOCAL, 0, CVS_LOCK_NONE,
			       (char *) NULL, 0, (char *) NULL);
d498 5
d504 3
a506 1
	option_with_arg ("-m", saved_message ? saved_message : "");
d553 2
a555 1
	send_arg ("--");
d643 1
a643 2
			   argv, local, W_LOCAL, aflag, CVS_LOCK_NONE,
			   (char *) NULL, 1, (char *) NULL);
d657 2
a658 2
			       argc, argv, local, W_LOCAL, aflag, CVS_LOCK_NONE,
			       (char *) NULL, 1, (char *) NULL);
d832 1
a832 2
	     *	- if status is T_REMOVED, file must not exist and its entry
	     *	  can't have a numeric sticky tag.
d862 3
d871 14
a884 1
		if ( file_has_conflict ( finfo, vers->ts_conflict ) )
d912 14
a925 24
	    if (status == T_REMOVED)
	    {
		if (vers->ts_user != NULL)
		{
		    error (0, 0,
			   "`%s' should be removed and is still there (or is"
			   " back again)", finfo->fullname);
		    freevers_ts (&vers);
		    return 1;
		}

		if (vers->tag && isdigit ((unsigned char) *vers->tag))
		{
		    /* Remove also tries to forbid this, but we should check
		       here.  I'm only _sure_ about somewhat obscure cases
		       (hacking the Entries file, using an old version of
		       CVS for the remove and a new one for the commit), but
		       there might be other cases.  */
		    error (0, 0,
			   "cannot remove file `%s' which has a numeric sticky"
			   " tag of `%s'", finfo->fullname, vers->tag);
		    freevers_ts (&vers);
		    return (1);
		}
d1227 1
a1227 1
    if (!got_message)
d1230 1
a1230 5
	if (
#ifdef SERVER_SUPPORT
	    !server_active &&
#endif
	    use_editor)
d1233 1
a1233 1
	do_verify (&saved_message, finfo->repository);
d1258 1
a1258 2
	    if (finfo->rcs != NULL)
		fixaddfile (finfo->rcs->path);
d1278 1
a1278 1
	    err = Checkin ('A', finfo, ci->rev,
d1323 2
a1324 1
	err = Checkin ('M', finfo, ci->rev, ci->tag,
d1372 1
a1372 1
           modified but not removed since classify_file_internal
d1467 50
d1553 1
a1553 5
    if (
#ifdef SERVER_SUPPORT
        !server_active &&
#endif
        use_editor)
d1555 1
a1555 1
    do_verify (&saved_message, real_repos);
d1578 1
a1578 1
	char *repos = Name_Repository (NULL, update_dir);
d1780 1
d1782 2
a1783 1
    ret = Checkin ('A', finfo, rev, tag, options, saved_message);
d1794 2
a1795 2
    else if (finfo->rcs != NULL)
	fixaddfile (finfo->rcs->path);
d1798 1
d1812 1
a1812 1
    if ((retcode = RCS_unlock (rcs, NULL, 1)) != 0)
a1818 2


a1820 4
 *
 * FIXME: Every caller that calls this function can access finfo->rcs (the
 * parsed RCSNode data), so we should be able to detect that the file needs
 * to be removed without reparsing the file as we do below.
d1823 3
a1825 2
fixaddfile (rcs)
    const char *rcs;
d1828 1
d1831 1
d1842 1
a1844 2


a1867 22
 *
 * INPUTS
 *   file	The name of the file in the workspace.
 *   repository	The repository directory to expect to find FILE,v in.
 *   tag	The name or rev num of the branch being added to, if any.
 *   options	Any RCS keyword expansion options specified by the user.
 *   rcsnode	A pointer to the pre-parsed RCSNode for this file, if the file
 *		exists in the repository.  If this is NULL, assume the file
 *		does not yet exist.
 *
 * RETURNS
 *   0 on success.
 *   1 on errors, after printing any appropriate error messages.
 *
 * ERRORS
 *   This function will return an error when any of the following functions do:
 *     add_rcs_file
 *     RCS_setattic
 *     lock_RCS
 *     RCS_checkin
 *     RCS_parse (called to verify the newly created archive file)
 *     RCS_settag
d1878 1
a1878 1
    RCSNode *rcs;
d1880 5
a1884 2
    int newfile = 0;		/* Set to 1 if we created a new RCS archive. */
    int retval = 1;
a1886 2
    assert (rcsnode != NULL);

d1898 20
a1917 1
    if (*rcsnode == NULL)
d1919 23
a1941 5
	char *rcsname;
	char *desc = NULL;
	size_t descalloc = 0;
	size_t desclen = 0;
	char *opt;
d1943 1
a1943 1
	if ( adding_on_branch )
d1945 20
a1964 17
	    mode_t omask;
	    rcsname = xmalloc (strlen (repository)
			       + sizeof (CVSATTIC)
			       + strlen (file)
			       + sizeof (RCSEXT)
			       + 3);
	    (void) sprintf (rcsname, "%s/%s", repository, CVSATTIC);
	    omask = umask ( cvsumask );
	    if (CVS_MKDIR (rcsname, 0777 ) != 0 && errno != EEXIST)
		error (1, errno, "cannot make directory `%s'", rcsname);
	    (void) umask ( omask );
	    (void) sprintf (rcsname,
			    "%s/%s/%s%s",
			    repository,
			    CVSATTIC,
			    file,
			    RCSEXT);
d1966 4
a1969 1
	else
d1971 5
a1975 9
	    rcsname = xmalloc (strlen (repository)
			       + strlen (file)
			       + sizeof (RCSEXT)
			       + 2);
	    (void) sprintf (rcsname,
			    "%s/%s%s",
			    repository,
			    file,
			    RCSEXT);
d1978 5
d1984 11
a1994 1
	   an RCS file.  */
d2028 1
a2028 1
	cvs_output (rcsname, 0);
d2031 1
a2031 1
	if (add_rcs_file (NULL, rcsname, file, NULL, opt,
d2035 1
d2038 1
a2038 1
	rcs = RCS_parsercsfile (rcsname);
d2042 1
a2042 47
	*rcsnode = rcs;
    }
    else
    {
	/* file has existed in the past.  Prepare to resurrect. */
	char *rev;
	char *oldexpand;

	rcs = *rcsnode;

	oldexpand = RCS_getexpand (rcs);
	if ((oldexpand != NULL
	     && options != NULL
	     && strcmp (options + 2, oldexpand) != 0)
	    || (oldexpand == NULL && options != NULL))
	{
	    /* We tell the user about this, because it means that the
	       old revisions will no longer retrieve the way that they
	       used to.  */
	    error (0, 0, "changing keyword expansion mode to %s", options);
	    RCS_setexpand (rcs, options + 2);
	}

	if (!adding_on_branch)
	{
	    /* We are adding on the trunk, so move the file out of the
	       Attic.  */
	    if (!(rcs->flags & INATTIC))
	    {
		error (0, 0, "warning: expected %s to be in Attic",
		       rcs->path);
	    }

	    /* Begin a critical section around the code that spans the
	       first commit on the trunk of a file that's already been
	       committed on a branch.  */
	    SIG_beginCrSect ();

	    if (RCS_setattic (rcs, 0))
	    {
		goto out;
	    }
	}

	rev = RCS_getversion (rcs, tag, NULL, 1, (int *) NULL);
	/* and lock it */
	if (lock_RCS (file, rcs, rev, repository))
d2044 2
a2045 4
	    error (0, 0, "cannot lock `%s'.", rcs->path);
	    if (rev != NULL)
		free (rev);
	    goto out;
a2046 3

	if (rev != NULL)
	    free (rev);
a2056 1
	    int retcode;
d2076 1
a2076 1
	    retcode = RCS_checkin (rcs, NULL, tmp, NULL,
d2082 2
a2083 1
		       "could not create initial dead revision %s", rcs->path);
d2092 3
a2094 3
	    freercsnode (&rcs);
	    rcs = RCS_parse (file, repository);
	    if (rcs == NULL)
d2096 2
a2097 1
		error (0, 0, "could not read %s", rcs->path);
d2100 2
a2101 1
	    *rcsnode = rcs;
d2104 1
a2104 1
	    if (lock_RCS (file, rcs, NULL, repository))
d2106 2
a2107 1
		error (0, 0, "cannot lock `%s'.", rcs->path);
d2114 18
a2131 1
	if (!RCS_nodeisbranch (rcs, tag))
a2135 1
	    int retcode;
d2137 2
a2138 1
	    fixbranch (rcs, sbranch);
d2140 2
a2141 5
	    head = RCS_getversion (rcs, NULL, NULL, 0, (int *) NULL);
	    magicrev = RCS_magicrev (rcs, head);

	    retcode = RCS_settag (rcs, tag, magicrev);
	    RCS_rewrite (rcs, NULL, NULL);
d2149 2
a2150 1
		       "could not stub branch %s for %s", tag, rcs->path);
d2157 1
a2157 1
	    if (lock_RCS (file, rcs, NULL, repository))
d2159 2
a2160 1
		error (0, 0, "cannot lock `%s'.", rcs->path);
d2165 1
a2165 1
	if (*rcsnode != rcs)
d2168 1
a2168 1
	    *rcsnode = rcs;
d2196 1
d2336 15
d2352 10
a2361 3

/* vim:tabstop=8:shiftwidth=4
 */
@


1.1
log
@Initial revision
@
text
@d52 1
a52 1
static void fixaddfile PROTO((char *file, char *repository));
a56 1
static char *locate_rcs PROTO((char *file, char *repository));
a72 1
static int run_module_prog = 1;
d85 1
a85 2
    "Usage: %s %s [-nRlf] [-m msg | -F logfile] [-r rev] files...\n",
    "    -n          Do not run the module program (if any).\n",
d248 1
a248 9
    if (vers->ts_user == NULL
	&& vers->vn_user != NULL
	&& vers->vn_user[0] == '-')
	/* FIXME: If vn_user is starts with "-" but ts_user is
	   non-NULL, what classify_file does is print "%s should be
	   removed and is still there".  I'm not sure what it does
	   then.  We probably should do the same.  */
	status = T_REMOVED;
    else if (vers->vn_user == NULL)
d258 38
a295 9
    else if (vers->ts_user != NULL
	     && vers->vn_user != NULL
	     && vers->vn_user[0] == '0')
	/* FIXME: If vn_user is "0" but ts_user is NULL, what classify_file
	   does is print "new-born %s has disappeared" and removes the entry.
	   We probably should do the same.  */
	status = T_ADDED;
    else if (vers->ts_user != NULL
	     && vers->ts_rcs != NULL
d342 5
d377 2
a378 1
	    error (1, 0, "you are unknown to this system");
d380 1
a380 1
	    error (1, 0, "cannot commit files as 'root'");
d385 1
a385 1
    while ((c = getopt (argc, argv, "+nlRm:fF:r:")) != -1)
d389 1
d391 3
a393 1
		run_module_prog = 0;
d395 1
d445 1
d447 5
a451 3
	/* strip trailing dots */
	while (saved_tag[strlen (saved_tag) - 1] == '.')
	    saved_tag[strlen (saved_tag) - 1] = '\0';
d487 2
a488 2
			       argc, argv, local, W_LOCAL, 0, 0,
			       (char *)NULL, 0);
a528 5
	/* Run the user-defined script to verify/check information in
	 *the log message
	 */
	do_verify (saved_message, (char *)NULL);

d530 1
a530 3
	/* FIXME: is that true?  There seems to be some code in do_editor
	   which can leave the message NULL.  */
	option_with_arg ("-m", saved_message);
a576 2
	if (!run_module_prog)
	    send_arg("-n");
d578 1
d666 2
a667 1
			   argv, local, W_LOCAL, aflag, 0, (char *) NULL, 1);
d681 2
a682 2
			       argc, argv, local, W_LOCAL, aflag, 0,
			       (char *) NULL, 1);
d856 2
a857 1
	     *	- if status is T_REMOVED, can't have a numeric tag
a886 3
		char *filestamp;
		int retcode;

d893 1
a893 14
#ifdef SERVER_SUPPORT
		if (server_active)
		    retcode = vers->ts_conflict[0] != '=';
		else {
		    filestamp = time_stamp (finfo->file);
		    retcode = strcmp (vers->ts_conflict, filestamp);
		    free (filestamp);
		}
#else
		filestamp = time_stamp (finfo->file);
		retcode = strcmp (vers->ts_conflict, filestamp);
		free (filestamp);
#endif
		if (retcode == 0)
d921 24
a944 14
	    if (status == T_REMOVED
		&& vers->tag
		&& isdigit ((unsigned char) *vers->tag))
	    {
		/* Remove also tries to forbid this, but we should check
		   here.  I'm only _sure_ about somewhat obscure cases
		   (hacking the Entries file, using an old version of
		   CVS for the remove and a new one for the commit), but
		   there might be other cases.  */
		error (0, 0,
	"cannot remove file `%s' which has a numeric sticky tag of `%s'",
			   finfo->fullname, vers->tag);
		freevers_ts (&vers);
		return (1);
d1246 1
a1246 1
    if (!(got_message))
d1249 5
a1253 1
	if (use_editor)
d1256 1
a1256 1
	do_verify (saved_message, finfo->repository);
d1281 2
a1282 1
	    fixaddfile (finfo->file, finfo->repository);
d1302 1
a1302 1
	    err = Checkin ('A', finfo, finfo->rcs->path, ci->rev,
d1347 1
a1347 2
	err = Checkin ('M', finfo,
		       finfo->rcs->path, ci->rev, ci->tag,
d1395 1
a1395 1
           modified but not removed.  Why?  classify_file_internal
a1489 50
    if (err == 0 && run_module_prog)
    {
	FILE *fp;

	if ((fp = CVS_FOPEN (CVSADM_CIPROG, "r")) != NULL)
	{
	    char *line;
	    int line_length;
	    size_t line_chars_allocated;
	    char *repos;

	    line = NULL;
	    line_chars_allocated = 0;
	    line_length = getline (&line, &line_chars_allocated, fp);
	    if (line_length > 0)
	    {
		/* Remove any trailing newline.  */
		if (line[line_length - 1] == '\n')
		    line[--line_length] = '\0';
		repos = Name_Repository ((char *) NULL, update_dir);
		run_setup (line);
		run_arg (repos);
		cvs_output (program_name, 0);
		cvs_output (" ", 1);
		cvs_output (command_name, 0);
		cvs_output (": Executing '", 0);
		run_print (stdout);
		cvs_output ("'\n", 0);
		cvs_flushout ();
		(void) run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
		free (repos);
	    }
	    else
	    {
		if (ferror (fp))
		    error (0, errno, "warning: error reading %s",
			   CVSADM_CIPROG);
	    }
	    if (line != NULL)
		free (line);
	    if (fclose (fp) < 0)
		error (0, errno, "warning: cannot close %s", CVSADM_CIPROG);
	}
	else
	{
	    if (! existence_error (errno))
		error (0, errno, "warning: cannot open %s", CVSADM_CIPROG);
	}
    }

d1526 5
a1530 1
    if (use_editor)
d1532 1
a1532 1
    do_verify (saved_message, real_repos);
d1555 1
a1555 1
	char *repos = Name_Repository (dir, update_dir);
a1756 1
    char *rcs;
d1758 1
a1758 2
    rcs = locate_rcs (finfo->file, finfo->repository);
    ret = Checkin ('A', finfo, rcs, rev, tag, options, saved_message);
d1769 2
a1770 2
    else
	fixaddfile (finfo->file, finfo->repository);
a1772 1
    free (rcs);
d1786 1
a1786 1
    if ((retcode = RCS_unlock (rcs, NULL, 0)) != 0)
d1793 2
d1797 4
d1803 2
a1804 3
fixaddfile (file, repository)
    char *file;
    char *repository;
a1806 1
    char *rcs;
a1808 1
    rcs = locate_rcs (file, repository);
a1818 1
    free (rcs);
d1821 2
d1846 22
d1878 1
a1878 1
    char *rcs;
d1880 2
a1881 5
    mode_t omask;
    int retcode = 0;
    int newfile = 0;
    RCSNode *rcsfile = NULL;
    int retval;
d1884 2
d1897 1
a1897 1
    if (adding_on_branch)
d1899 5
a1903 22
	rcs = xmalloc (strlen (repository) + strlen (file)
		       + sizeof (RCSEXT) + sizeof (CVSATTIC) + 10);
        (void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
	if (! isreadable (rcs))
	{
	    (void) sprintf(rcs, "%s/%s", repository, CVSATTIC);
	    omask = umask (cvsumask);
	    if (CVS_MKDIR (rcs, 0777) != 0 && errno != EEXIST)
		error (1, errno, "cannot make directory `%s'", rcs);;
	    (void) umask (omask);
	    (void) sprintf (rcs, "%s/%s/%s%s", repository, CVSATTIC, file,
			    RCSEXT);
	}
    }
    else
	rcs = locate_rcs (file, repository);

    if (isreadable (rcs))
    {
	/* file has existed in the past.  Prepare to resurrect. */
	char *rev;
	char *oldexpand;
d1905 1
a1905 1
	if ((rcsfile = *rcsnode) == NULL)
d1907 17
a1923 3
	    error (0, 0, "could not find parsed rcsfile %s", file);
	    retval = 1;
	    goto out;
d1925 1
a1925 6

	oldexpand = RCS_getexpand (rcsfile);
	if ((oldexpand != NULL
	     && options != NULL
	     && strcmp (options + 2, oldexpand) != 0)
	    || (oldexpand == NULL && options != NULL))
d1927 9
a1935 40
	    /* We tell the user about this, because it means that the
	       old revisions will no longer retrieve the way that they
	       used to.  */
	    error (0, 0, "changing keyword expansion mode to %s", options);
	    RCS_setexpand (rcsfile, options + 2);
	}

	if (!adding_on_branch)
	{
	    /* We are adding on the trunk, so move the file out of the
	       Attic.  */
	    if (!(rcsfile->flags & INATTIC))
	    {
		error (0, 0, "warning: expected %s to be in Attic",
		       rcsfile->path);
	    }

	    sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);

	    /* Begin a critical section around the code that spans the
	       first commit on the trunk of a file that's already been
	       committed on a branch.  */
	    SIG_beginCrSect ();

	    if (RCS_setattic (rcsfile, 0))
	    {
		retval = 1;
		goto out;
	    }
	}

	rev = RCS_getversion (rcsfile, tag, NULL, 1, (int *) NULL);
	/* and lock it */
	if (lock_RCS (file, rcsfile, rev, repository))
	{
	    error (0, 0, "cannot lock `%s'.", rcs);
	    if (rev != NULL)
		free (rev);
	    retval = 1;
	    goto out;
a1937 5
	if (rev != NULL)
	    free (rev);
    }
    else
    {
d1939 1
a1939 11
	   an rcs file.  */

	char *desc;
	size_t descalloc;
	size_t desclen;

	char *opt;

	desc = NULL;
	descalloc = 0;
	desclen = 0;
d1973 1
a1973 1
	cvs_output (rcs, 0);
d1976 1
a1976 1
	if (add_rcs_file (NULL, rcs, file, NULL, opt,
a1979 1
	    retval = 1;
d1982 1
a1982 1
	rcsfile = RCS_parsercsfile (rcs);
d1986 47
a2032 1
	if (rcsnode != NULL)
d2034 4
a2037 2
	    assert (*rcsnode == NULL);
	    *rcsnode = rcsfile;
d2039 3
d2052 1
d2072 1
a2072 1
	    retcode = RCS_checkin (rcsfile, NULL, tmp, NULL,
d2078 1
a2078 2
		       "could not create initial dead revision %s", rcs);
		retval = 1;
d2087 3
a2089 3
	    freercsnode (&rcsfile);
	    rcsfile = RCS_parse (file, repository);
	    if (rcsfile == NULL)
d2091 1
a2091 2
		error (0, 0, "could not read %s", rcs);
		retval = 1;
d2094 1
a2094 2
	    if (rcsnode != NULL)
		*rcsnode = rcsfile;
d2097 1
a2097 1
	    if (lock_RCS (file, rcsfile, NULL, repository))
d2099 1
a2099 2
		error (0, 0, "cannot lock `%s'.", rcs);
		retval = 1;
d2106 1
a2106 18

	if (rcsfile == NULL)
	{
	    if (rcsnode != NULL && *rcsnode != NULL)
		rcsfile = *rcsnode;
	    else
	    {
		rcsfile = RCS_parse (file, repository);
		if (rcsfile == NULL)
		{
		    error (0, 0, "could not read %s", rcs);
		    retval = 1;
		    goto out;
		}
	    }
	}

	if (!RCS_nodeisbranch (rcsfile, tag))
d2111 1
d2113 1
a2113 2
	    head = RCS_getversion (rcsfile, NULL, NULL, 0, (int *) NULL);
	    magicrev = RCS_magicrev (rcsfile, head);
d2115 5
a2119 2
	    retcode = RCS_settag (rcsfile, tag, magicrev);
	    RCS_rewrite (rcsfile, NULL, NULL);
d2127 1
a2127 2
		       "could not stub branch %s for %s", tag, rcs);
		retval = 1;
d2134 1
a2134 1
	    if (lock_RCS (file, rcsfile, NULL, repository))
d2136 1
a2136 2
		error (0, 0, "cannot lock `%s'.", rcs);
		retval = 1;
d2141 1
a2141 1
	if (rcsnode && *rcsnode != rcsfile)
d2144 1
a2144 1
	    *rcsnode = rcsfile;
a2171 1
    free (rcs);
a2310 15
/* Find an RCS file in the repository.  Most parts of CVS will want to
   rely instead on RCS_parse which performs a similar operation and is
   called by recurse.c which then puts the result in useful places
   like the rcs field of struct file_info.

   REPOSITORY is the repository (including the directory) and FILE is
   the filename within that directory (without RCSEXT).  Returns a
   newly-malloc'd array containing the absolute pathname of the RCS
   file that was found.  */
static char *
locate_rcs (file, repository)
    char *file;
    char *repository;
{
    char *rcs;
d2312 3
a2314 10
    rcs = xmalloc (strlen (repository) + strlen (file) + sizeof (RCSEXT) + 10);
    (void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
    if (!isreadable (rcs))
    {
	(void) sprintf (rcs, "%s/%s/%s%s", repository, CVSATTIC, file, RCSEXT);
	if (!isreadable (rcs))
	    (void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
    }
    return rcs;
}
@


1.1.2.1
log
@vendor-branch-ify new cvs 1.12
@
text
@d17 1
d24 34
a57 33
static Dtype check_direntproc (void *callerdat, const char *dir,
                               const char *repos, const char *update_dir,
                               List *entries);
static int check_fileproc (void *callerdat, struct file_info *finfo);
static int check_filesdoneproc (void *callerdat, int err, const char *repos,
				const char *update_dir, List *entries);
static int checkaddfile (const char *file, const char *repository,
                         const char *tag, const char *options,
                         RCSNode **rcsnode);
static Dtype commit_direntproc (void *callerdat, const char *dir,
                                const char *repos, const char *update_dir,
                                List *entries);
static int commit_dirleaveproc (void *callerdat, const char *dir, int err,
				const char *update_dir, List *entries);
static int commit_fileproc (void *callerdat, struct file_info *finfo);
static int commit_filesdoneproc (void *callerdat, int err,
                                 const char *repository,
				 const char *update_dir, List *entries);
static int finaladd (struct file_info *finfo, char *revision, char *tag,
		     char *options);
static int findmaxrev (Node * p, void *closure);
static int lock_RCS (const char *user, RCSNode *rcs, const char *rev,
                     const char *repository);
static int precommit_list_to_args_proc (Node * p, void *closure);
static int precommit_proc (const char *repository, const char *filter,
                           void *closure);
static int remove_file (struct file_info *finfo, char *tag,
			char *message);
static void fixaddfile (const char *rcs);
static void fixbranch (RCSNode *, char *branch);
static void unlockrcs (RCSNode *rcs);
static void ci_delproc (Node *p);
static void masterlist_delproc (Node *p);
a71 1
static int check_valid_edit = 0;
d74 1
d81 1
d87 2
a88 2
    "Usage: %s %s [-cRlf] [-m msg | -F logfile] [-r rev] files...\n",
    "    -c          Check for valid edits before committing.\n",
d127 1
a127 1
    const char *repository;
d134 3
a136 1

d139 6
a144 2
find_dirent_proc (void *callerdat, const char *dir, const char *repository,
                  const char *update_dir, List *entries)
d146 1
a146 1
    struct find_data *find_data = callerdat;
d153 1
a153 1
	return R_SKIP_ALL;
a166 2


d171 1
a171 1

d174 3
a176 1
find_ignproc (const char *file, const char *dir)
d180 1
a180 1
    p = xmalloc (sizeof (struct question));
d188 3
a190 1

d193 6
a198 2
find_filesdoneproc (void *callerdat, int err, const char *repository,
                    const char *update_dir, List *entries)
d200 1
a200 1
    struct find_data *find_data = callerdat;
d216 1
a216 1

d223 3
a225 1
find_fileproc (void *callerdat, struct file_info *finfo)
d230 1
a230 1
    struct find_data *args = callerdat;
d251 9
a259 1
    if (vers->vn_user == NULL)
d264 1
a264 1
	    error (0, 0, "use `%s add' to create an entry for `%s'",
d269 9
a277 38
    if (vers->vn_user[0] == '-')
    {
	if (vers->ts_user != NULL)
	{
	    error (0, 0,
		   "`%s' should be removed and is still there (or is back"
		   " again)", finfo->fullname);
	    freevers_ts (&vers);
	    return 1;
	}
	/* else */
	status = T_REMOVED;
    }
    else if (strcmp (vers->vn_user, "0") == 0)
    {
	if (vers->ts_user == NULL)
	{
	    /* This happens when one has `cvs add'ed a file, but it no
	       longer exists in the working directory at commit time.
	       FIXME: What classify_file does in this case is print
	       "new-born %s has disappeared" and removes the entry.
	       We probably should do the same.  */
	    if (!really_quiet)
		error (0, 0, "warning: new-born %s has disappeared",
		       finfo->fullname);
	    status = T_REMOVE_ENTRY;
	}
	else
	    status = T_ADDED;
    }
    else if (vers->ts_user == NULL)
    {
	/* FIXME: What classify_file does in this case is print
	   "%s was lost".  We probably should do the same.  */
	freevers_ts (&vers);
	return 0;
    }
    else if (vers->ts_rcs != NULL
d295 1
a295 1
    data = xmalloc (sizeof (struct logfile_info));
d302 1
a302 1
    node->data = data;
d311 1
a311 1

d314 3
a316 1
copy_ulist (Node *node, void *data)
d318 1
a318 1
    struct find_data *args = data;
a323 7


#ifdef SERVER_SUPPORT
# define COMMIT_OPTIONS "+cnlRm:fF:r:"
#else /* !SERVER_SUPPORT */
# define COMMIT_OPTIONS "+clRm:fF:r:"
#endif /* SERVER_SUPPORT */
d325 3
a327 1
commit (int argc, char **argv)
d353 2
a354 4
	if ((pw = getpwnam (getcaller ())) == NULL)
	    error (1, 0,
                   "your apparent username (%s) is unknown to this system",
                   getcaller ());
d356 1
a356 1
	    error (1, 0, "'root' is not allowed to commit files");
d361 1
a361 1
    while ((c = getopt (argc, argv, COMMIT_OPTIONS)) != -1)
a364 4
            case 'c':
                check_valid_edit = 1;
                break;
#ifdef SERVER_SUPPORT
d366 1
a366 3
		/* Silently ignore -n for compatibility with old
		 * clients.
		 */
a367 1
#endif /* SERVER_SUPPORT */
a394 1
                check_valid_edit = 0;
a416 1
	char *p = saved_tag + strlen (saved_tag);
d418 3
a420 5
	/* strip trailing dots and leading zeros */
	while (*--p == '.') ;
	p[1] = '\0';
	while (saved_tag[0] == '0' && isdigit ((unsigned char) saved_tag[1]))
	    ++saved_tag;
d453 5
a457 4
	err = start_recursion
	    (find_fileproc, find_filesdoneproc, find_dirent_proc, NULL,
	     &find_args, argc, argv, local, W_LOCAL, 0, CVS_LOCK_NONE,
	     NULL, 0, NULL );
d475 1
a475 6
	if (size_overflow_p (xtimes (find_args.argc, sizeof (char **))))
	{
	    find_args.argc = 0;
	    return 0;
	}
	find_args.argv = xmalloc (xtimes (find_args.argc, sizeof (char **)));
d496 6
a501 1
	    do_editor (".", &saved_message, NULL, find_args.ulist);
d504 3
a506 1
	option_with_arg ("-m", saved_message ? saved_message : "");
d530 5
a534 20
		    /* This used to send the Directory line of its own accord,
		     * but skipped some of the other processing like checking
		     * for whether the server would accept "Relative-directory"
		     * requests.  Relying on send_a_repository() to do this
		     * picks up these checks but also:
		     *
		     *   1. Causes the "Directory" request to be sent only once
		     *      per directory.
		     *   2. Causes the global TOPLEVEL_REPOS to be set.
		     *   3. Causes "Static-directory" and "Sticky" requests
		     *      to sometimes be sent.
		     *
		     * (1) is almost certainly a plus.  (2) & (3) may or may
		     * not be useful sometimes, and will ocassionally cause a
		     * little extra network traffic.  The additional network
		     * traffic is probably already saved several times over and
		     * certainly cancelled out via the multiple "Directory"
		     * request suppression of (1).
		     */
		    send_a_repository (p->dir, p->repos, p->dir);
a550 2
        if (check_valid_edit)
            send_arg("-c");
d553 2
a555 1
	send_arg ("--");
d610 1
a610 1
	tag_check_valid (saved_tag, argc, argv, local, aflag, "", false);
d618 1
a618 1
    lock_tree_promotably (argc, argv, local, W_LOCAL, aflag);
d634 1
a634 1
	working_dir = xgetcwd ();
d642 2
a643 2
                           check_direntproc, NULL, NULL, argc, argv, local,
                           W_LOCAL, aflag, CVS_LOCK_NONE, NULL, 1, NULL);
d645 2
d648 1
d656 3
a658 3
                               commit_direntproc, commit_dirleaveproc, NULL,
                               argc, argv, local, W_LOCAL, aflag,
                               CVS_LOCK_WRITE, NULL, 1, NULL);
a665 2
    /* see if we need to sleep before returning to avoid time-stamp races */
    if (
d667 2
a668 2
	/* But only sleep on the client.  */
        !server_active &&
a669 3
	last_register_time
       )
	    sleep_past (last_register_time);
d671 7
a677 1
    return err;
a679 2


d685 3
a687 1
classify_file_internal (struct file_info *finfo, Vers_TS **vers)
d706 2
a707 2
	    status = Classify_File (finfo, NULL, NULL,
				    NULL, 1, aflag, vers, 0);
d714 2
a715 2
		xstatus = Classify_File (finfo, saved_tag, NULL,
					 NULL, 1, aflag, vers, 0);
d738 2
a739 2
	    status = Classify_File (finfo, xtag, NULL,
				    NULL, 1, aflag, vers, 0);
d746 2
a747 2
		status = Classify_File (finfo, xtag, NULL,
					NULL, 1, aflag, vers, 0);
d758 2
a759 1
	status = Classify_File (finfo, saved_tag, NULL, NULL, 1, 0, vers, 0);
a766 2


d773 3
a775 1
check_fileproc (void *callerdat, struct file_info *finfo)
d778 1
a778 1
    const char *xdir;
a783 1
    int retval = 1;
d790 1
a790 1
	return 1;
d793 2
a794 3
    if (strncmp (finfo->repository, current_parsed_root->directory,
                 cvsroot_len) == 0
	&& ISSLASH (finfo->repository[cvsroot_len])
d798 1
a798 1
	&& ISSLASH (finfo->repository[cvsroot_len + sizeof (CVSROOTADM)])
d822 2
a823 1
	    goto out;
a826 3
        {
            char *editor;

d832 1
a832 2
	     *	- if status is T_REMOVED, file must not exist and its entry
	     *	  can't have a numeric sticky tag.
d847 2
a848 1
		    goto out;
d856 2
a857 1
		    goto out;
d862 3
d871 14
a884 1
		if ( file_has_conflict ( finfo, vers->ts_conflict ) )
d889 2
a890 1
		    goto out;
d912 14
a925 23
	    if (status == T_REMOVED)
	    {
		if (vers->ts_user != NULL)
		{
		    error (0, 0,
			   "`%s' should be removed and is still there (or is"
			   " back again)", finfo->fullname);
		    goto out;
		}

		if (vers->tag && isdigit ((unsigned char) *vers->tag))
		{
		    /* Remove also tries to forbid this, but we should check
		       here.  I'm only _sure_ about somewhat obscure cases
		       (hacking the Entries file, using an old version of
		       CVS for the remove and a new one for the commit), but
		       there might be other cases.  */
		    error (0, 0,
			   "cannot remove file `%s' which has a numeric sticky"
			   " tag of `%s'", finfo->fullname, vers->tag);
		    freevers_ts (&vers);
		    goto out;
		}
d937 2
a938 1
			goto out;
d947 2
a948 1
		    goto out;
d966 2
a967 4
		ml = xmalloc (sizeof (struct master_lists ));
		ulist = ml->ulist = getlist();
		cilist = ml->cilist = getlist();

d971 5
a975 1
		p->data = ml;
d985 2
a986 1
	    li = xmalloc (sizeof (struct logfile_info));
a987 53

	    if (check_valid_edit)
            {
                char *editors = NULL;

		editor = NULL;
                editors = fileattr_get0 (finfo->file, "_editors");
                if (editors != NULL)
                {
                    char *caller = getcaller ();
                    char *p = NULL;
                    char *p0 = NULL;

                    p = editors;
                    p0 = p;
                    while (*p != '\0')
                    {
                        p = strchr (p, '>');
                        if (p == NULL)
                        {
                            break;
                        }
                        *p = '\0';
                        if (strcmp (caller, p0) == 0)
                        {
                            break;
                        }
                        p = strchr (p + 1, ',');
                        if (p == NULL)
                        {
                            break;
                        }
                        ++p;
                        p0 = p;
                    }

                    if (strcmp (caller, p0) == 0)
                    {
                        editor = caller;
                    }

                    free (editors);
                }
            }

            if (check_valid_edit && editor == NULL)
            {
                error (0, 0, "Valid edit does not exist for %s",
                       finfo->fullname);
                freevers_ts (&vers);
                return 1;
            }

d991 1
a991 1
	    p->data = li;
d998 1
a998 1
	    ci = xmalloc (sizeof (struct commit_info));
d1006 1
a1006 1
		ci->rev = NULL;
d1009 1
a1009 1
	    p->data = ci;
d1039 2
a1040 1
		    hlinfo = xmalloc (sizeof (struct hardlink_info));
d1042 1
a1042 1
		    linkp->data = hlinfo;
a1047 2
        }

d1050 2
a1051 1
	    goto out;
a1058 4
    retval = 0;

 out:

d1060 1
a1060 1
    return retval;
a1062 2


d1069 6
a1074 2
check_direntproc (void *callerdat, const char *dir, const char *repos,
                  const char *update_dir, List *entries)
d1077 1
a1077 1
	return R_SKIP_ALL;
d1082 1
a1082 1
    return R_PROCESS;
a1084 2


d1086 1
a1086 1
 * Walklist proc to generate an arg list from the line in commitinfo
d1089 1
a1089 1
precommit_list_to_args_proc (p, closure)
a1092 1
    struct format_cmdline_walklist_closure *c = closure;
a1093 45
    char *arg = NULL;
    const char *f;
    char *d;
    size_t doff;

    if (p->data == NULL) return 1;

    f = c->format;
    d = *c->d;
    /* foreach requested attribute */
    while (*f)
    {
   	switch (*f++)
	{
	    case 's':
		li = p->data;
		if (li->type == T_ADDED
			|| li->type == T_MODIFIED
			|| li->type == T_REMOVED)
		{
		    arg = p->key;
		}
		break;
	    default:
		error (1, 0,
		       "Unknown format character or not a list attribute: %c",
		       f[-1]);
		/* NOTREACHED */
		break;
	}
	/* copy the attribute into an argument */
	if (c->quotes)
	{
	    arg = cmdlineescape (c->quotes, arg);
	}
	else
	{
	    arg = cmdlinequote ('"', arg);
	}
	doff = d - *c->buf;
	expand_string (c->buf, c->length, doff + strlen (arg));
	d = *c->buf + doff;
	strncpy (d, arg, strlen (arg));
	d += strlen (arg);
	free (arg);
d1095 6
a1100 7
	/* and always put the extra space on.  we'll have to back up a char
	 * when we're done, but that seems most efficient
	 */
	doff = d - *c->buf;
	expand_string (c->buf, c->length, doff + 1);
	d = *c->buf + doff;
	*d++ = ' ';
d1102 1
a1102 3
    /* correct our original pointer into the buff */
    *c->d = d;
    return 0;
a1104 2


d1109 23
a1131 44
precommit_proc (const char *repository, const char *filter, void *closure)
{
    char *newfilter = NULL;
    char *cmdline;
    const char *srepos = Short_Repository (repository);
    List *ulist = closure;

#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
    if (!strchr (filter, '%'))
    {
	error (0, 0,
               "warning: commitinfo line contains no format strings:\n"
               "    \"%s\"\n"
               "Appending defaults (\" %%r/%%p %%s\"), but please be aware that this usage is\n"
               "deprecated.", filter);
	newfilter = xmalloc (strlen (filter) + 10);
	strcpy (newfilter, filter);
	strcat (newfilter, " %r/%p %s");
	filter = newfilter;
    }
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */

    cmdline = format_cmdline (
#ifdef SUPPORT_OLD_INFO_FMT_STRINGS
        false, srepos,
#endif /* SUPPORT_OLD_INFO_FMT_STRINGS */
        filter,
	"c", "s", cvs_cmd_name,
#ifdef SERVER_SUPPORT
        "R", "s", referrer ? referrer->original : "NONE",
#endif /* SERVER_SUPPORT */
        "p", "s", srepos,
        "r", "s", current_parsed_root->directory,
        "s", ",", ulist, precommit_list_to_args_proc, (void *)NULL,
        (char *)NULL
	);

    if (newfilter) free (newfilter);

    if (!cmdline || !strlen (cmdline))
    {
	if (cmdline) free (cmdline);
	error (0, 0, "precommit proc resolved to the empty string!");
	return 1;
d1134 4
a1137 4
    run_setup (cmdline);
    free (cmdline);

    return run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL|RUN_REALLY);
a1139 2


d1145 6
a1150 2
check_filesdoneproc (void *callerdat, int err, const char *repos,
                     const char *update_dir, List *entries)
a1153 1
    List *saved_ulist;
d1160 1
a1160 1
	saved_ulist = NULL;
d1164 1
a1164 1
	return err;
d1167 1
a1167 3
    n = Parse_Info (CVSROOTADM_COMMITINFO, repos, precommit_proc, PIOPT_ALL,
                    saved_ulist);
    if (n > 0)
d1173 1
a1173 1
    return err;
a1175 2


d1184 3
a1186 1
commit_fileproc (void *callerdat, struct file_info *finfo)
d1218 1
a1218 1
	return 0;
d1227 1
a1227 1
    if (!got_message)
d1230 1
a1230 5
	if (
#ifdef SERVER_SUPPORT
	    !server_active &&
#endif
	    use_editor)
d1233 1
a1233 1
	do_verify (&saved_message, finfo->repository);
d1238 1
a1238 1
	return 0;
d1240 1
a1240 1
    ci = p->data;
d1258 1
a1258 2
	    if (finfo->rcs != NULL)
		fixaddfile (finfo->rcs->path);
d1278 1
a1278 1
	    err = Checkin ('A', finfo, ci->rev,
d1297 1
a1297 1
	char *xrev = NULL;
d1323 2
a1324 1
	err = Checkin ('M', finfo, ci->rev, ci->tag,
d1348 2
a1349 2
			    NULL,
			    NULL);
d1356 1
a1356 2
    notify_do ('C', finfo->file, finfo->update_dir, getcaller (), NULL, NULL,
	       finfo->repository);
d1372 1
a1372 1
           modified but not removed since classify_file_internal
d1387 1
a1387 1
		li = p->data;
d1396 1
a1396 1
    return err;
a1398 2


d1404 6
a1409 2
commit_filesdoneproc (void *callerdat, int err, const char *repository,
                      const char *update_dir, List *entries)
d1416 1
a1416 1
	return err;
d1422 3
d1427 1
a1427 1
	const char *p;
d1458 31
a1488 2
	    if (!really_quiet)
	    {
d1491 13
a1503 2
		cvs_output (cvs_cmd_name, 0);
		cvs_output (": Rebuilding administrative file database\n", 0);
d1505 9
a1513 3
	    mkmodules (admin_dir);
	    free (admin_dir);
	    WriteTemplate (".", 1, repository);
d1517 1
a1517 11
    /* FIXME: This used to be above the block above.  The advantage of being
     * here is that it is not called until after all possible writes from this
     * process are complete.  The disadvantage is that a fatal error during
     * update of CVSROOT can prevent the loginfo script from being called.
     *
     * A more general solution I have been considering is calling a generic
     * "postwrite" hook from the remove write lock routine.
     */
    Update_Logfile (repository, saved_message, NULL, ulist);

    return err;
a1519 2


d1525 6
a1530 2
commit_direntproc (void *callerdat, const char *dir, const char *repos,
                   const char *update_dir, List *entries)
d1537 1
a1537 1
	return R_SKIP_ALL;
d1544 1
a1544 1
	ulist = NULL;
d1548 1
a1548 1
	return R_SKIP_FILES;
d1551 1
d1553 1
a1553 6
    real_repos = Name_Repository (dir, update_dir);
    if (
#ifdef SERVER_SUPPORT
        !server_active &&
#endif
        use_editor)
d1555 1
a1555 1
    do_verify (&saved_message, real_repos);
d1557 1
a1557 1
    return R_PROCESS;
a1559 2


d1565 6
a1570 2
commit_dirleaveproc (void *callerdat, const char *dir, int err,
                     const char *update_dir, List *entries)
d1578 1
a1578 1
	char *repos = Name_Repository (NULL, update_dir);
d1584 1
a1584 1
    return err;
a1586 2


d1591 3
a1593 1
findmaxrev (Node *p, void *closure)
d1596 1
a1596 1
    Entnode *entdata = p->data;
d1598 1
d1600 1
a1600 1
	return 0;
d1604 1
a1604 1
    return 0;
d1616 4
a1619 1
remove_file (struct file_info *finfo, char *tag, char *message)
d1649 1
a1649 1
	    return 1;
d1653 1
a1653 1
	return 0;
d1659 5
d1674 1
a1674 1
	    return 1;
d1682 2
a1683 2
	    corev = RCS_gettag (finfo->rcs, tag, 1, NULL);
	    prev_rev = xstrdup (corev);
d1688 1
a1688 1
	    prev_rev = xstrdup (branchname);
d1706 1
a1706 1
	    return 1;
d1714 2
a1715 1
			    NULL, NULL, RUN_TTY, NULL, NULL);
d1720 1
a1720 1
	return 1;
d1734 2
a1735 2
    retcode = RCS_checkin (finfo->rcs, NULL, finfo->file, message,
			   rev, 0, RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);
d1741 1
a1741 1
	return 1;
d1755 7
a1761 16
    if (!really_quiet)
    {
	cvs_output (old_path, 0);
	cvs_output ("  <--  ", 0);
	if (finfo->update_dir && strlen (finfo->update_dir))
	{
	    cvs_output (finfo->update_dir, 0);
	    cvs_output ("/", 1);
	}
	cvs_output (finfo->file, 0);
	cvs_output ("\nnew revision: delete; previous revision: ", 0);
	cvs_output (prev_rev, 0);
	cvs_output ("\n", 0);
    }

    free (prev_rev);
d1766 1
a1766 1
    return 0;
a1768 2


d1773 5
a1777 1
finaladd (struct file_info *finfo, char *rev, char *tag, char *options)
d1780 1
d1782 2
a1783 1
    ret = Checkin ('A', finfo, rev, tag, options, saved_message);
d1794 2
a1795 2
    else if (finfo->rcs != NULL)
	fixaddfile (finfo->rcs->path);
d1798 1
d1800 1
a1800 1
    return ret;
a1802 2


d1807 2
a1808 1
unlockrcs (RCSNode *rcs)
d1812 1
a1812 1
    if ((retcode = RCS_unlock (rcs, NULL, 1)) != 0)
a1818 2


a1820 4
 *
 * FIXME: Every caller that calls this function can access finfo->rcs (the
 * parsed RCSNode data), so we should be able to detect that the file needs
 * to be removed without reparsing the file as we do below.
d1823 3
a1825 1
fixaddfile (const char *rcs)
d1828 1
d1831 1
d1842 1
a1844 2


d1849 3
a1851 1
fixbranch (RCSNode *rcs, char *branch)
a1863 2


a1867 22
 *
 * INPUTS
 *   file	The name of the file in the workspace.
 *   repository	The repository directory to expect to find FILE,v in.
 *   tag	The name or rev num of the branch being added to, if any.
 *   options	Any RCS keyword expansion options specified by the user.
 *   rcsnode	A pointer to the pre-parsed RCSNode for this file, if the file
 *		exists in the repository.  If this is NULL, assume the file
 *		does not yet exist.
 *
 * RETURNS
 *   0 on success.
 *   1 on errors, after printing any appropriate error messages.
 *
 * ERRORS
 *   This function will return an error when any of the following functions do:
 *     add_rcs_file
 *     RCS_setattic
 *     lock_RCS
 *     RCS_checkin
 *     RCS_parse (called to verify the newly created archive file)
 *     RCS_settag
d1871 6
a1876 2
checkaddfile (const char *file, const char *repository, const char *tag,
              const char *options, RCSNode **rcsnode)
d1878 1
a1878 1
    RCSNode *rcs;
d1880 5
a1884 2
    int newfile = 0;		/* Set to 1 if we created a new RCS archive. */
    int retval = 1;
a1886 2
    assert (rcsnode != NULL);

d1898 1
a1898 1
    if (*rcsnode == NULL)
d1900 11
a1910 36
	char *rcsname;
	char *desc = NULL;
	size_t descalloc = 0;
	size_t desclen = 0;
	const char *opt;

	if ( adding_on_branch )
	{
	    mode_t omask;
	    rcsname = xmalloc (strlen (repository)
			       + sizeof (CVSATTIC)
			       + strlen (file)
			       + sizeof (RCSEXT)
			       + 3);
	    (void) sprintf (rcsname, "%s/%s", repository, CVSATTIC);
	    omask = umask ( cvsumask );
	    if (CVS_MKDIR (rcsname, 0777 ) != 0 && errno != EEXIST)
		error (1, errno, "cannot make directory `%s'", rcsname);
	    (void) umask ( omask );
	    (void) sprintf (rcsname,
			    "%s/%s/%s%s",
			    repository,
			    CVSATTIC,
			    file,
			    RCSEXT);
	}
	else
	{
	    rcsname = xmalloc (strlen (repository)
			       + strlen (file)
			       + sizeof (RCSEXT)
			       + 2);
	    (void) sprintf (rcsname,
			    "%s/%s%s",
			    repository,
			    file,
a1912 45

	/* this is the first time we have ever seen this file; create
	   an RCS file.  */
	fname = xmalloc (strlen (file) + sizeof (CVSADM)
			 + sizeof (CVSEXT_LOG) + 10);
	(void) sprintf (fname, "%s/%s%s", CVSADM, file, CVSEXT_LOG);
	/* If the file does not exist, no big deal.  In particular, the
	   server does not (yet at least) create CVSEXT_LOG files.  */
	if (isfile (fname))
	    /* FIXME: Should be including update_dir in the appropriate
	       place here.  */
	    get_file (fname, fname, "r", &desc, &descalloc, &desclen);
	free (fname);

	/* From reading the RCS 5.7 source, "rcs -i" adds a newline to the
	   end of the log message if the message is nonempty.
	   Do it.  RCS also deletes certain whitespace, in cleanlogmsg,
	   which we don't try to do here.  */
	if (desclen > 0)
	{
	    expand_string (&desc, &descalloc, desclen + 1);
	    desc[desclen++] = '\012';
	}

	/* Set RCS keyword expansion options.  */
	if (options != NULL)
	    opt = options + 2;
	else
	    opt = NULL;

	if (add_rcs_file (NULL, rcsname, file, NULL, opt,
			  NULL, NULL, 0, NULL,
			  desc, desclen, NULL, 0) != 0)
	{
	    if (rcsname != NULL)
	        free (rcsname);
	    goto out;
	}
	rcs = RCS_parsercsfile (rcsname);
	newfile = 1;
	if (rcsname != NULL)
	    free (rcsname);
	if (desc != NULL)
	    free (desc);
	*rcsnode = rcs;
d1915 3
d1923 6
a1928 1
	rcs = *rcsnode;
d1930 1
a1930 1
	oldexpand = RCS_getexpand (rcs);
d1940 1
a1940 1
	    RCS_setexpand (rcs, options + 2);
d1947 1
a1947 1
	    if (!(rcs->flags & INATTIC))
d1950 1
a1950 1
		       rcs->path);
d1953 2
d1960 1
a1960 1
	    if (RCS_setattic (rcs, 0))
d1962 1
d1967 1
a1967 1
	rev = RCS_getversion (rcs, tag, NULL, 1, NULL);
d1969 1
a1969 1
	if (lock_RCS (file, rcs, rev, repository))
d1971 1
a1971 1
	    error (0, 0, "cannot lock `%s'.", rcs->path);
d1974 1
d1981 67
a2056 1
	    int retcode;
d2076 1
a2076 1
	    retcode = RCS_checkin (rcs, NULL, NULL, tmp, NULL, 0,
d2082 2
a2083 1
		       "could not create initial dead revision %s", rcs->path);
d2092 3
a2094 3
	    freercsnode (&rcs);
	    rcs = RCS_parse (file, repository);
	    if (rcs == NULL)
d2096 2
a2097 1
		error (0, 0, "could not read %s", rcs->path);
d2100 2
a2101 1
	    *rcsnode = rcs;
d2104 1
a2104 1
	    if (lock_RCS (file, rcs, NULL, repository))
d2106 2
a2107 1
		error (0, 0, "cannot lock `%s'.", rcs->path);
d2114 18
a2131 1
	if (!RCS_nodeisbranch (rcs, tag))
a2135 6
	    int retcode;
	    time_t headtime = -1;
	    char *revnum, *tmp;
	    FILE *fp;
	    time_t t = -1;
	    struct tm *ct;
d2137 2
a2138 1
	    fixbranch (rcs, sbranch);
d2140 2
a2141 10
	    head = RCS_getversion (rcs, NULL, NULL, 0, NULL);
	    magicrev = RCS_magicrev (rcs, head);

	    /* If this is not a new branch, then we will want a dead
	       version created before this one. */
	    if (!newfile)
		headtime = RCS_getrevtime (rcs, head, 0, 0);

	    retcode = RCS_settag (rcs, tag, magicrev);
	    RCS_rewrite (rcs, NULL, NULL);
d2149 2
a2150 1
		       "could not stub branch %s for %s", tag, rcs->path);
a2152 58
	    /* We need to add a dead version here to avoid -rtag -Dtime
	       checkout problems between when the head version was
	       created and now. */
	    if (!newfile && headtime != -1)
	    {
		/* move the new file out of the way. */
		fname = Xasprintf ("%s/%s%s", CVSADM, CVSPREFIX, file);
		rename_file (file, fname);

		/* Create empty FILE.  Can't use copy_file with a DEVNULL
		   argument -- copy_file now ignores device files. */
		fp = fopen (file, "w");
		if (fp == NULL)
		    error (1, errno, "cannot open %s for writing", file);
		if (fclose (fp) < 0)
		    error (0, errno, "cannot close %s", file);

		/* As we will be hacking the delta date, put the time
		   this was added into the log message. */
		t = time(NULL);
		ct = gmtime(&t);
		tmp = Xasprintf ("file %s was added on branch %s on %d-%02d-%02d %02d:%02d:%02d +0000",
				 file, tag,
				 ct->tm_year + (ct->tm_year < 100 ? 0 : 1900),
				 ct->tm_mon + 1, ct->tm_mday,
				 ct->tm_hour, ct->tm_min, ct->tm_sec);
			 
		/* commit a dead revision. */
		revnum = RCS_whatbranch (rcs, tag);
		retcode = RCS_checkin (rcs, NULL, NULL, tmp, revnum, headtime,
				       RCS_FLAGS_DEAD |
				       RCS_FLAGS_QUIET |
				       RCS_FLAGS_USETIME);
		free (revnum);
		free (tmp);

		if (retcode != 0)
		{
		    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
			   "could not created dead stub %s for %s", tag,
			   rcs->path);
		    goto out;
		}

		/* put the new file back where it was */
		rename_file (fname, file);
		free (fname);

		/* double-check that the file was written correctly */
		freercsnode (&rcs);
		rcs = RCS_parse (file, repository);
		if (rcs == NULL)
		{
		    error (0, 0, "could not read %s", rcs->path);
		    goto out;
		}
		*rcsnode = rcs;
	    }
d2157 1
a2157 1
	    if (lock_RCS (file, rcs, NULL, repository))
d2159 2
a2160 1
		error (0, 0, "cannot lock `%s'.", rcs->path);
d2165 1
a2165 1
	if (*rcsnode != rcs)
d2168 1
a2168 1
	    *rcsnode = rcs;
d2196 1
a2199 2


d2207 5
a2211 2
lock_RCS (const char *user, RCSNode *rcs, const char *rev,
          const char *repository)
d2237 1
a2237 1
		return 1;
d2240 1
a2240 1
	err = RCS_lock (rcs, NULL, 1);
d2244 1
a2244 1
	RCS_lock (rcs, rev, 1);
d2271 1
a2271 1
	return 0;
d2280 1
a2280 1
    return 1;
a2282 2


d2287 2
a2288 1
update_delproc (Node *p)
d2290 1
a2290 1
    struct logfile_info *li = p->data;
d2292 1
d2306 2
a2307 1
ci_delproc (Node *p)
d2309 1
a2309 1
    struct commit_info *ci = p->data;
d2311 1
d2325 2
a2326 1
masterlist_delproc (Node *p)
d2328 1
a2328 1
    struct master_lists *ml = p->data;
d2330 1
d2334 27
@


1.1.3.1
log
@our CVS is currently at 1.11.1p1, thus import that version into vendor branch
@
text
@@


1.1.3.2
log
@CVS 1.11.12 is the latest stable version of CVS,
released 06.02.2004, with a huge lot of bug fixes.

/me hopes this will pay off...
@
text
@d52 1
a52 1
static void fixaddfile PROTO((const char *rcs));
d57 1
d74 1
d87 2
a88 1
    "Usage: %s %s [-Rlf] [-m msg | -F logfile] [-r rev] files...\n",
d251 9
a259 1
    if (vers->vn_user == NULL)
d269 9
a277 38
    if (vers->vn_user[0] == '-')
    {
	if (vers->ts_user != NULL)
	{
	    error (0, 0,
		   "`%s' should be removed and is still there (or is back"
		   " again)", finfo->fullname);
	    freevers_ts (&vers);
	    return 1;
	}
	/* else */
	status = T_REMOVED;
    }
    else if (strcmp (vers->vn_user, "0") == 0)
    {
	if (vers->ts_user == NULL)
	{
	    /* This happens when one has `cvs add'ed a file, but it no
	       longer exists in the working directory at commit time.
	       FIXME: What classify_file does in this case is print
	       "new-born %s has disappeared" and removes the entry.
	       We probably should do the same.  */
	    if (!really_quiet)
		error (0, 0, "warning: new-born %s has disappeared",
		       finfo->fullname);
	    status = T_REMOVE_ENTRY;
	}
	else
	    status = T_ADDED;
    }
    else if (vers->ts_user == NULL)
    {
	/* FIXME: What classify_file does in this case is print
	   "%s was lost".  We probably should do the same.  */
	freevers_ts (&vers);
	return 0;
    }
    else if (vers->ts_rcs != NULL
a323 5
#ifdef SERVER_SUPPORT
# define COMMIT_OPTIONS "+nlRm:fF:r:"
#else /* !SERVER_SUPPORT */
# define COMMIT_OPTIONS "+lRm:fF:r:"
#endif /* SERVER_SUPPORT */
d354 1
a354 2
	    error (1, 0, "your apparent username (%s) is unknown to this system",
			 getcaller ());
d356 1
a356 1
	    error (1, 0, "'root' is not allowed to commit files");
d361 1
a361 1
    while( ( c = getopt( argc, argv, COMMIT_OPTIONS ) ) != -1 )
a364 1
#ifdef SERVER_SUPPORT
d366 1
a366 3
		/* Silently ignore -n for compatibility with old
		 * clients.
		 */
a367 1
#endif /* SERVER_SUPPORT */
a416 1
	char *p = saved_tag + strlen (saved_tag);
d418 3
a420 5
	/* strip trailing dots and leading zeros */
	while (*--p == '.') ;
	p[1] = '\0';
	while (saved_tag[0] == '0' && isdigit ((unsigned char) saved_tag[1]))
	    ++saved_tag;
d456 2
a457 2
			       argc, argv, local, W_LOCAL, 0, CVS_LOCK_NONE,
			       (char *) NULL, 0, (char *) NULL);
d498 5
d504 3
a506 1
	option_with_arg ("-m", saved_message ? saved_message : "");
d553 2
a555 1
	send_arg ("--");
d643 1
a643 2
			   argv, local, W_LOCAL, aflag, CVS_LOCK_NONE,
			   (char *) NULL, 1, (char *) NULL);
d657 2
a658 2
			       argc, argv, local, W_LOCAL, aflag, CVS_LOCK_NONE,
			       (char *) NULL, 1, (char *) NULL);
d832 1
a832 2
	     *	- if status is T_REMOVED, file must not exist and its entry
	     *	  can't have a numeric sticky tag.
d862 3
d871 14
a884 1
		if ( file_has_conflict ( finfo, vers->ts_conflict ) )
d912 14
a925 24
	    if (status == T_REMOVED)
	    {
		if (vers->ts_user != NULL)
		{
		    error (0, 0,
			   "`%s' should be removed and is still there (or is"
			   " back again)", finfo->fullname);
		    freevers_ts (&vers);
		    return 1;
		}

		if (vers->tag && isdigit ((unsigned char) *vers->tag))
		{
		    /* Remove also tries to forbid this, but we should check
		       here.  I'm only _sure_ about somewhat obscure cases
		       (hacking the Entries file, using an old version of
		       CVS for the remove and a new one for the commit), but
		       there might be other cases.  */
		    error (0, 0,
			   "cannot remove file `%s' which has a numeric sticky"
			   " tag of `%s'", finfo->fullname, vers->tag);
		    freevers_ts (&vers);
		    return (1);
		}
d1227 1
a1227 1
    if (!got_message)
d1230 1
a1230 5
	if (
#ifdef SERVER_SUPPORT
	    !server_active &&
#endif
	    use_editor)
d1233 1
a1233 1
	do_verify (&saved_message, finfo->repository);
d1258 1
a1258 2
	    if (finfo->rcs != NULL)
		fixaddfile (finfo->rcs->path);
d1278 1
a1278 1
	    err = Checkin ('A', finfo, ci->rev,
d1323 2
a1324 1
	err = Checkin ('M', finfo, ci->rev, ci->tag,
d1372 1
a1372 1
           modified but not removed since classify_file_internal
d1467 50
d1553 1
a1553 5
    if (
#ifdef SERVER_SUPPORT
        !server_active &&
#endif
        use_editor)
d1555 1
a1555 1
    do_verify (&saved_message, real_repos);
d1578 1
a1578 1
	char *repos = Name_Repository (NULL, update_dir);
d1780 1
d1782 2
a1783 1
    ret = Checkin ('A', finfo, rev, tag, options, saved_message);
d1794 2
a1795 2
    else if (finfo->rcs != NULL)
	fixaddfile (finfo->rcs->path);
d1798 1
d1812 1
a1812 1
    if ((retcode = RCS_unlock (rcs, NULL, 1)) != 0)
a1818 2


a1820 4
 *
 * FIXME: Every caller that calls this function can access finfo->rcs (the
 * parsed RCSNode data), so we should be able to detect that the file needs
 * to be removed without reparsing the file as we do below.
d1823 3
a1825 2
fixaddfile (rcs)
    const char *rcs;
d1828 1
d1831 1
d1842 1
a1844 2


a1867 22
 *
 * INPUTS
 *   file	The name of the file in the workspace.
 *   repository	The repository directory to expect to find FILE,v in.
 *   tag	The name or rev num of the branch being added to, if any.
 *   options	Any RCS keyword expansion options specified by the user.
 *   rcsnode	A pointer to the pre-parsed RCSNode for this file, if the file
 *		exists in the repository.  If this is NULL, assume the file
 *		does not yet exist.
 *
 * RETURNS
 *   0 on success.
 *   1 on errors, after printing any appropriate error messages.
 *
 * ERRORS
 *   This function will return an error when any of the following functions do:
 *     add_rcs_file
 *     RCS_setattic
 *     lock_RCS
 *     RCS_checkin
 *     RCS_parse (called to verify the newly created archive file)
 *     RCS_settag
d1878 1
a1878 1
    RCSNode *rcs;
d1880 5
a1884 2
    int newfile = 0;		/* Set to 1 if we created a new RCS archive. */
    int retval = 1;
a1886 2
    assert (rcsnode != NULL);

d1898 20
a1917 1
    if (*rcsnode == NULL)
d1919 23
a1941 5
	char *rcsname;
	char *desc = NULL;
	size_t descalloc = 0;
	size_t desclen = 0;
	char *opt;
d1943 1
a1943 1
	if ( adding_on_branch )
d1945 20
a1964 17
	    mode_t omask;
	    rcsname = xmalloc (strlen (repository)
			       + sizeof (CVSATTIC)
			       + strlen (file)
			       + sizeof (RCSEXT)
			       + 3);
	    (void) sprintf (rcsname, "%s/%s", repository, CVSATTIC);
	    omask = umask ( cvsumask );
	    if (CVS_MKDIR (rcsname, 0777 ) != 0 && errno != EEXIST)
		error (1, errno, "cannot make directory `%s'", rcsname);
	    (void) umask ( omask );
	    (void) sprintf (rcsname,
			    "%s/%s/%s%s",
			    repository,
			    CVSATTIC,
			    file,
			    RCSEXT);
d1966 4
a1969 1
	else
d1971 5
a1975 9
	    rcsname = xmalloc (strlen (repository)
			       + strlen (file)
			       + sizeof (RCSEXT)
			       + 2);
	    (void) sprintf (rcsname,
			    "%s/%s%s",
			    repository,
			    file,
			    RCSEXT);
d1978 5
d1984 11
a1994 1
	   an RCS file.  */
d2028 1
a2028 1
	cvs_output (rcsname, 0);
d2031 1
a2031 1
	if (add_rcs_file (NULL, rcsname, file, NULL, opt,
d2035 1
d2038 1
a2038 1
	rcs = RCS_parsercsfile (rcsname);
d2042 1
a2042 47
	*rcsnode = rcs;
    }
    else
    {
	/* file has existed in the past.  Prepare to resurrect. */
	char *rev;
	char *oldexpand;

	rcs = *rcsnode;

	oldexpand = RCS_getexpand (rcs);
	if ((oldexpand != NULL
	     && options != NULL
	     && strcmp (options + 2, oldexpand) != 0)
	    || (oldexpand == NULL && options != NULL))
	{
	    /* We tell the user about this, because it means that the
	       old revisions will no longer retrieve the way that they
	       used to.  */
	    error (0, 0, "changing keyword expansion mode to %s", options);
	    RCS_setexpand (rcs, options + 2);
	}

	if (!adding_on_branch)
	{
	    /* We are adding on the trunk, so move the file out of the
	       Attic.  */
	    if (!(rcs->flags & INATTIC))
	    {
		error (0, 0, "warning: expected %s to be in Attic",
		       rcs->path);
	    }

	    /* Begin a critical section around the code that spans the
	       first commit on the trunk of a file that's already been
	       committed on a branch.  */
	    SIG_beginCrSect ();

	    if (RCS_setattic (rcs, 0))
	    {
		goto out;
	    }
	}

	rev = RCS_getversion (rcs, tag, NULL, 1, (int *) NULL);
	/* and lock it */
	if (lock_RCS (file, rcs, rev, repository))
d2044 2
a2045 4
	    error (0, 0, "cannot lock `%s'.", rcs->path);
	    if (rev != NULL)
		free (rev);
	    goto out;
a2046 3

	if (rev != NULL)
	    free (rev);
a2056 1
	    int retcode;
d2076 1
a2076 1
	    retcode = RCS_checkin (rcs, NULL, tmp, NULL,
d2082 2
a2083 1
		       "could not create initial dead revision %s", rcs->path);
d2092 3
a2094 3
	    freercsnode (&rcs);
	    rcs = RCS_parse (file, repository);
	    if (rcs == NULL)
d2096 2
a2097 1
		error (0, 0, "could not read %s", rcs->path);
d2100 2
a2101 1
	    *rcsnode = rcs;
d2104 1
a2104 1
	    if (lock_RCS (file, rcs, NULL, repository))
d2106 2
a2107 1
		error (0, 0, "cannot lock `%s'.", rcs->path);
d2114 18
a2131 1
	if (!RCS_nodeisbranch (rcs, tag))
a2135 1
	    int retcode;
d2137 2
a2138 1
	    fixbranch (rcs, sbranch);
d2140 2
a2141 5
	    head = RCS_getversion (rcs, NULL, NULL, 0, (int *) NULL);
	    magicrev = RCS_magicrev (rcs, head);

	    retcode = RCS_settag (rcs, tag, magicrev);
	    RCS_rewrite (rcs, NULL, NULL);
d2149 2
a2150 1
		       "could not stub branch %s for %s", tag, rcs->path);
d2157 1
a2157 1
	    if (lock_RCS (file, rcs, NULL, repository))
d2159 2
a2160 1
		error (0, 0, "cannot lock `%s'.", rcs->path);
d2165 1
a2165 1
	if (*rcsnode != rcs)
d2168 1
a2168 1
	    *rcsnode = rcs;
d2196 1
d2336 15
d2352 10
a2361 3

/* vim:tabstop=8:shiftwidth=4
 */
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.1.4.1
log
@SECURITY: Fix from OpenBSD 3.4-stable:

Fix all those cvs holes in one go, too lazy to list them all here
@
text
@d475 1
a475 6
	if (size_overflow_p (xtimes (find_args.argc, sizeof (char **))))
	{
	    find_args.argc = 0;
	    return 0;
	}
	find_args.argv = xmalloc (xtimes (find_args.argc, sizeof (char **)));
@


1.1.1.2
log
@Sync of src/gnu with OpenBSD (promised a long time ago)
@
text
@d475 1
a475 6
	if (size_overflow_p (xtimes (find_args.argc, sizeof (char **))))
	{
	    find_args.argc = 0;
	    return 0;
	}
	find_args.argv = xmalloc (xtimes (find_args.argc, sizeof (char **)));
@

