head	1.7;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.8
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.6
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2005.01.03.00.45.46;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.31;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.24;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.55.39;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.57.59;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.05;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.53;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.09;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.49;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.24;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.11;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.46.36;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@soft merge
@
text
@/*		   /Net/dxcern/userd/timbl/hypertext/WWW/Library/Implementation/HTAnchor.html
 */

/*	Hypertext "Anchor" Object				     HTAnchor.h
 *	==========================
 *
 *	An anchor represents a region of a hypertext document which is linked
 *	to another anchor in the same or a different document.
 */

#ifndef HTANCHOR_H
#define HTANCHOR_H

/* Version 0 (TBL) written in Objective-C for the NeXT browser */
/* Version 1 of 24-Oct-1991 (JFG), written in C, browser-independent */

#include <HTList.h>
#include <HTBTree.h>
#include <HTChunk.h>
#include <HTAtom.h>
#include <UCDefs.h>

typedef struct _HyperDoc HyperDoc;	/* Ready for forward references */
typedef struct _HTAnchor HTAnchor;
typedef struct _HTParentAnchor HTParentAnchor;
typedef struct _HTParentAnchor0 HTParentAnchor0;

#include <HTFormat.h>

#ifdef __cplusplus
extern "C" {
#endif
/*			Main definition of anchor
 *			=========================
				 */ struct _HTAnchor {
	/* Generic anchor */
	HTParentAnchor0 *parent;	/* Parent of this anchor (self for adults) */
    };

    struct _HTParentAnchor0 {	/* One for adult_table,
				 * generally not used outside HTAnchor.c */
	/* Common part from the generic anchor structure */
	HTParentAnchor0 *parent;	/* (self) */

	/* ParentAnchor0-specific information */
	char *address;		/* Absolute address of this node */
	HTParentAnchor *info;	/* additional info, allocated on demand */

	HTBTree *children;	/* Subanchors <a name="tag">, sorted by tag */
	HTList sources;		/* List of anchors pointing to this, if any */

	HTList _add_adult;	/* - just a memory for list entry:) */
	short adult_hash;	/* adult list number */
	BOOL underway;		/* Document about to be attached to it */
    };

/*
 *  Separated from the above to save memory:  allocated on demand,
 *  it is nearly 1:1 to HText (well, sometimes without HText...),
 *  available for SGML, HTML, and HText stages.
 *  [being precise, we currently allocate it before HTLoadDocument(),
 *  in HTAnchor_findAddress() and HTAnchor_parent()].
 */
    struct _HTParentAnchor {
	/* Common part from the generic anchor structure */
	HTParentAnchor0 *parent;	/* Parent of this anchor */

	/* ParentAnchor-specific information */
	HTList children_notag;	/* Subanchors <a href=...>, tag is NULL */
	HyperDoc *document;	/* The document within which this is an anchor */

	char *address;		/* parent->address, a pointer */
	bstring *post_data;	/* Posting data */
	char *post_content_type;	/* Type of post data */
	char *bookmark;		/* Bookmark filename */
	HTFormat format;	/* Pointer to node format descriptor */
	char *charset;		/* Pointer to character set (kludge, for now */
	BOOL isIndex;		/* Acceptance of a keyword search */
	char *isIndexAction;	/* URL of isIndex server */
	char *isIndexPrompt;	/* Prompt for isIndex query */
	char *title;		/* Title of document */
	char *owner;		/* Owner of document */
	char *RevTitle;		/* TITLE in REV="made" or REV="owner" LINK */
	char *citehost;		/* Citehost from REL="citehost" LINK */
#ifdef USE_COLOR_STYLE
	char *style;
#endif

	HTList *methods;	/* Methods available as HTAtoms */
	void *protocol;		/* Protocol object */
	char *physical;		/* Physical address */
	BOOL isISMAPScript;	/* Script for clickable image map */
	BOOL isHEAD;		/* Document is headers from a HEAD request */
	BOOL safe;		/* Safe */
#ifdef USE_SOURCE_CACHE
	char *source_cache_file;
	HTChunk *source_cache_chunk;
#endif
	char *FileCache;	/* Path to a disk-cached copy (see src/HTFWriter.c) */
	char *SugFname;		/* Suggested filename */
	char *cache_control;	/* Cache-Control */
	BOOL no_cache;		/* Cache-Control, Pragma or META "no-cache"? */
	BOOL inBASE;		/* duplicated from HTStructured (HTML.c/h) */
#ifdef EXP_HTTP_HEADERS
	HTChunk http_headers;
#endif
	char *content_type_params;	/* Content-Type (with parameters if any) */
	char *content_type;	/* Content-Type */
	char *content_language;	/* Content-Language */
	char *content_encoding;	/* Compression algorithm */
	char *content_base;	/* Content-Base */
	char *content_disposition;	/* Content-Disposition */
	char *content_location;	/* Content-Location */
	char *content_md5;	/* Content-MD5 */
	char *message_id;	/* Message-ID */
	char *subject;		/* Subject */
	int content_length;	/* Content-Length */
	char *date;		/* Date */
	char *expires;		/* Expires */
	char *last_modified;	/* Last-Modified */
	char *ETag;		/* ETag (HTTP1.1 cache validator) */
	char *server;		/* Server */
	UCAnchorInfo *UCStages;	/* chartrans stages */
	HTList *imaps;		/* client side image maps */
    };

    typedef HTAtom HTLinkType;

    typedef struct {
	/* Common part from the generic anchor structure */
	HTParentAnchor0 *parent;	/* Parent of this anchor */

	/* ChildAnchor-specific information */
	char *tag;		/* #fragment,  relative to the parent */

	HTAnchor *dest;		/* The anchor to which this leads */
	HTLinkType *type;	/* Semantics of this link */

	HTList _add_children_notag;	/* - just a memory for list entry:) */
	HTList _add_sources;	/* - just a memory for list entry:) */
    } HTChildAnchor;

/*
 *  DocAddress structure is used for loading an absolute anchor with all
 *  needed information including posting data and post content type.
 */
    typedef struct _DocAddress {
	char *address;
	bstring *post_data;
	char *post_content_type;
	char *bookmark;
	BOOL isHEAD;
	BOOL safe;
    } DocAddress;

/* "internal" means "within the same document, with certainty". */
    extern HTLinkType *HTInternalLink;

/*	Create or find a child anchor with a possible link
 *	--------------------------------------------------
 *
 *	Create new anchor with a given parent and possibly
 *	a name, and possibly a link to a _relatively_ named anchor.
 *	(Code originally in ParseHTML.h)
 */
    extern HTChildAnchor *HTAnchor_findChildAndLink(HTParentAnchor *parent,	/* May not be 0 */
						    const char *tag,	/* May be "" or 0 */
						    const char *href,	/* May be "" or 0 */
						    HTLinkType *ltype);		/* May be 0 */

/*	Create new or find old parent anchor
 *	------------------------------------
 *
 *	This one is for a reference which is found in a document, and might
 *	not be already loaded.
 *	Note: You are not guaranteed a new anchor -- you might get an old one,
 *	like with fonts.
 */
    extern HTParentAnchor *HTAnchor_findAddress(const DocAddress *address);

/*	Create new or find old named anchor - simple form
 *	-------------------------------------------------
 *
 *	Like the previous one, but simpler to use for simple cases.
 *	No post data etc. can be supplied. - kw
 */
    extern HTParentAnchor *HTAnchor_findSimpleAddress(const char *url);

/*	Delete an anchor and possibly related things (auto garbage collection)
 *	--------------------------------------------
 *
 *	The anchor is only deleted if the corresponding document is not loaded.
 *	All outgoing links from children are deleted, and children are
 *	removed from the sources lists of their targets.
 *	We also try to delete the targets whose documents are not loaded.
 *	If this anchor's sources list is empty, we delete it and its children.
 */
    extern BOOL HTAnchor_delete(HTParentAnchor0 *me);

/*
 *  Unnamed children (children_notag) have no sense without HText -
 *  delete them and their links if we are about to free HText.
 *  Document currently exists.  Called within HText_free().
 */
    extern void HTAnchor_delete_links(HTParentAnchor *me);

#ifdef USE_SOURCE_CACHE
    extern void HTAnchor_clearSourceCache(HTParentAnchor *me);
#endif

/*	Data access functions
 *	---------------------
 */
    extern HTParentAnchor *HTAnchor_parent(HTAnchor * me);

    extern void HTAnchor_setDocument(HTParentAnchor *me,
				     HyperDoc *doc);

    extern HyperDoc *HTAnchor_document(HTParentAnchor *me);

/*	Returns the full URI of the anchor, child or parent
 *	as a malloc'd string to be freed by the caller.
 */
    extern char *HTAnchor_address(HTAnchor * me);

    extern void HTAnchor_setFormat(HTParentAnchor *me,
				   HTFormat form);

    extern HTFormat HTAnchor_format(HTParentAnchor *me);

    extern void HTAnchor_setIndex(HTParentAnchor *me,
				  const char *address);

    extern void HTAnchor_setPrompt(HTParentAnchor *me,
				   const char *prompt);

    extern BOOL HTAnchor_isIndex(HTParentAnchor *me);

    extern BOOL HTAnchor_isISMAPScript(HTAnchor * me);

#if defined(USE_COLOR_STYLE)
    extern const char *HTAnchor_style(HTParentAnchor *me);

    extern void HTAnchor_setStyle(HTParentAnchor *me,
				  const char *style);
#endif

/*	Title handling.
*/
    extern const char *HTAnchor_title(HTParentAnchor *me);

    extern void HTAnchor_setTitle(HTParentAnchor *me,
				  const char *title);

    extern void HTAnchor_appendTitle(HTParentAnchor *me,
				     const char *title);

/*	Bookmark handling.
*/
    extern const char *HTAnchor_bookmark(HTParentAnchor *me);

    extern void HTAnchor_setBookmark(HTParentAnchor *me,
				     const char *bookmark);

/*	Owner handling.
*/
    extern const char *HTAnchor_owner(HTParentAnchor *me);

    extern void HTAnchor_setOwner(HTParentAnchor *me,
				  const char *owner);

/*	TITLE handling in LINKs with REV="made" or REV="owner". - FM
*/
    extern const char *HTAnchor_RevTitle(HTParentAnchor *me);

    extern void HTAnchor_setRevTitle(HTParentAnchor *me,
				     const char *title);

/*	Citehost for bibp links from LINKs with REL="citehost". - RDC
*/
    extern const char *HTAnchor_citehost(HTParentAnchor *me);

    extern void HTAnchor_setCitehost(HTParentAnchor *me,
				     const char *citehost);

/*	Suggested filename handling. - FM
 *	(will be loaded if we had a Content-Disposition
 *	 header or META element with filename=name.suffix)
 */
    extern const char *HTAnchor_SugFname(HTParentAnchor *me);

/*	HTTP Headers.
*/
    extern const char *HTAnchor_http_headers(HTParentAnchor *me);

/*	Content-Type handling (parameter list).
*/
    extern const char *HTAnchor_content_type_params(HTParentAnchor *me);

/*	Content-Type handling. - FM
*/
    extern const char *HTAnchor_content_type(HTParentAnchor *me);

/*	Content-Encoding handling. - FM
 *	(will be loaded if we had a Content-Encoding
 *	 header.)
 */
    extern const char *HTAnchor_content_encoding(HTParentAnchor *me);

/*	Last-Modified header handling. - FM
*/
    extern const char *HTAnchor_last_modified(HTParentAnchor *me);

/*	Date header handling. - FM
*/
    extern const char *HTAnchor_date(HTParentAnchor *me);

/*	Server header handling. - FM
*/
    extern const char *HTAnchor_server(HTParentAnchor *me);

/*	Safe header handling. - FM
*/
    extern BOOL HTAnchor_safe(HTParentAnchor *me);

/*	Content-Base header handling. - FM
*/
    extern const char *HTAnchor_content_base(HTParentAnchor *me);

/*	Content-Location header handling. - FM
*/
    extern const char *HTAnchor_content_location(HTParentAnchor *me);

/*	Message-ID, used for mail replies - kw
*/
    extern const char *HTAnchor_messageID(HTParentAnchor *me);

    extern BOOL HTAnchor_setMessageID(HTParentAnchor *me,
				      const char *messageid);

/*	Subject, used for mail replies - kw
*/
    extern const char *HTAnchor_subject(HTParentAnchor *me);

    extern BOOL HTAnchor_setSubject(HTParentAnchor *me,
				    const char *subject);

/*	Manipulation of links
 *	---------------------
 */
    extern HTAnchor *HTAnchor_followLink(HTChildAnchor *me);

    extern HTAnchor *HTAnchor_followTypedLink(HTChildAnchor *me,
					      HTLinkType *type);

/*	Read and write methods
 *	----------------------
 */
    extern HTList *HTAnchor_methods(HTParentAnchor *me);

/*	Protocol
 *	--------
 */
    extern void *HTAnchor_protocol(HTParentAnchor *me);

    extern void HTAnchor_setProtocol(HTParentAnchor *me,
				     void *protocol);

/*	Physical address
 *	----------------
 */
    extern char *HTAnchor_physical(HTParentAnchor *me);

    extern void HTAnchor_setPhysical(HTParentAnchor *me,
				     char *protocol);

    extern LYUCcharset *HTAnchor_getUCInfoStage(HTParentAnchor *me,
						int which_stage);

    extern int HTAnchor_getUCLYhndl(HTParentAnchor *me,
				    int which_stage);

    extern LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
						int LYhndl,
						int which_stage,
						int set_by);

    extern LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
						int LYhndl,
						int which_stage,
						int set_by);

    extern LYUCcharset *HTAnchor_resetUCInfoStage(HTParentAnchor *me,
						  int LYhndl,
						  int which_stage,
						  int set_by);

    extern LYUCcharset *HTAnchor_copyUCInfoStage(HTParentAnchor *me,
						 int to_stage,
						 int from_stage,
						 int set_by);

    extern void ImageMapList_free(HTList *list);

#ifdef __cplusplus
}
#endif
#endif				/* HTANCHOR_H */
@


1.6
log
@automatic merge of lynx-current
@
text
@a22 4
/*			Main definition of anchor
 *			=========================
 */

a27 1
/*	After definition of HTFormat: */
d30 9
a38 3
struct _HTAnchor {		/* Generic anchor */
    HTParentAnchor0 *parent;	/* Parent of this anchor (self for adults) */
};
d40 1
a40 1
struct _HTParentAnchor0 {	/* One for adult_table,
d42 2
a43 2
    /* Common part from the generic anchor structure */
    HTParentAnchor0 *parent;	/* (self) */
d45 11
a55 11
    /* ParentAnchor0-specific information */
    char *address;		/* Absolute address of this node */
    HTParentAnchor *info;	/* additional info, allocated on demand */

    HTBTree *children;		/* Subanchors <a name="tag">, sorted by tag */
    HTList sources;		/* List of anchors pointing to this, if any */

    HTList _add_adult;		/* - just a memory for list entry:) */
    short adult_hash;		/* adult list number */
    BOOL underway;		/* Document about to be attached to it */
};
d64 21
a84 21
struct _HTParentAnchor {
    /* Common part from the generic anchor structure */
    HTParentAnchor0 *parent;	/* Parent of this anchor */

    /* ParentAnchor-specific information */
    HTList children_notag;	/* Subanchors <a href=...>, tag is NULL */
    HyperDoc *document;		/* The document within which this is an anchor */

    char *address;		/* parent->address, a pointer */
    bstring *post_data;		/* Posting data */
    char *post_content_type;	/* Type of post data */
    char *bookmark;		/* Bookmark filename */
    HTFormat format;		/* Pointer to node format descriptor */
    char *charset;		/* Pointer to character set (kludge, for now */
    BOOL isIndex;		/* Acceptance of a keyword search */
    char *isIndexAction;	/* URL of isIndex server */
    char *isIndexPrompt;	/* Prompt for isIndex query */
    char *title;		/* Title of document */
    char *owner;		/* Owner of document */
    char *RevTitle;		/* TITLE in REV="made" or REV="owner" LINK */
    char *citehost;		/* Citehost from REL="citehost" LINK */
d86 1
a86 1
    char *style;
d89 6
a94 6
    HTList *methods;		/* Methods available as HTAtoms */
    void *protocol;		/* Protocol object */
    char *physical;		/* Physical address */
    BOOL isISMAPScript;		/* Script for clickable image map */
    BOOL isHEAD;		/* Document is headers from a HEAD request */
    BOOL safe;			/* Safe */
d96 2
a97 2
    char *source_cache_file;
    HTChunk *source_cache_chunk;
d99 5
a103 5
    char *FileCache;		/* Path to a disk-cached copy (see src/HTFWriter.c) */
    char *SugFname;		/* Suggested filename */
    char *cache_control;	/* Cache-Control */
    BOOL no_cache;		/* Cache-Control, Pragma or META "no-cache"? */
    BOOL inBASE;		/* duplicated from HTStructured (HTML.c/h) */
d105 1
a105 1
    HTChunk http_headers;
d107 35
a141 35
    char *content_type_params;	/* Content-Type (with parameters if any) */
    char *content_type;		/* Content-Type */
    char *content_language;	/* Content-Language */
    char *content_encoding;	/* Compression algorithm */
    char *content_base;		/* Content-Base */
    char *content_disposition;	/* Content-Disposition */
    char *content_location;	/* Content-Location */
    char *content_md5;		/* Content-MD5 */
    char *message_id;		/* Message-ID */
    char *subject;		/* Subject */
    int content_length;		/* Content-Length */
    char *date;			/* Date */
    char *expires;		/* Expires */
    char *last_modified;	/* Last-Modified */
    char *ETag;			/* ETag (HTTP1.1 cache validator) */
    char *server;		/* Server */
    UCAnchorInfo *UCStages;	/* chartrans stages */
    HTList *imaps;		/* client side image maps */
};

typedef HTAtom HTLinkType;

typedef struct {
    /* Common part from the generic anchor structure */
    HTParentAnchor0 *parent;	/* Parent of this anchor */

    /* ChildAnchor-specific information */
    char *tag;			/* #fragment,  relative to the parent */

    HTAnchor *dest;		/* The anchor to which this leads */
    HTLinkType *type;		/* Semantics of this link */

    HTList _add_children_notag;	/* - just a memory for list entry:) */
    HTList _add_sources;	/* - just a memory for list entry:) */
} HTChildAnchor;
d147 8
a154 8
typedef struct _DocAddress {
    char *address;
    bstring *post_data;
    char *post_content_type;
    char *bookmark;
    BOOL isHEAD;
    BOOL safe;
} DocAddress;
d157 1
a157 1
extern HTLinkType *HTInternalLink;
d166 4
a169 4
extern HTChildAnchor *HTAnchor_findChildAndLink(HTParentAnchor *parent,		/* May not be 0 */
						const char *tag,	/* May be "" or 0 */
						const char *href,	/* May be "" or 0 */
						HTLinkType *ltype);	/* May be 0 */
d179 1
a179 1
extern HTParentAnchor *HTAnchor_findAddress(const DocAddress *address);
d187 1
a187 1
extern HTParentAnchor *HTAnchor_findSimpleAddress(const char *url);
d198 1
a198 1
extern BOOL HTAnchor_delete(HTParentAnchor0 *me);
d205 1
a205 1
extern void HTAnchor_delete_links(HTParentAnchor *me);
d208 1
a208 1
extern void HTAnchor_clearSourceCache(HTParentAnchor *me);
d214 1
a214 1
extern HTParentAnchor *HTAnchor_parent(HTAnchor * me);
d216 2
a217 2
extern void HTAnchor_setDocument(HTParentAnchor *me,
				 HyperDoc *doc);
d219 1
a219 1
extern HyperDoc *HTAnchor_document(HTParentAnchor *me);
d224 1
a224 1
extern char *HTAnchor_address(HTAnchor * me);
d226 2
a227 2
extern void HTAnchor_setFormat(HTParentAnchor *me,
			       HTFormat form);
d229 1
a229 1
extern HTFormat HTAnchor_format(HTParentAnchor *me);
d231 2
a232 2
extern void HTAnchor_setIndex(HTParentAnchor *me,
			      const char *address);
d234 2
a235 2
extern void HTAnchor_setPrompt(HTParentAnchor *me,
			       const char *prompt);
d237 1
a237 1
extern BOOL HTAnchor_isIndex(HTParentAnchor *me);
d239 1
a239 1
extern BOOL HTAnchor_isISMAPScript(HTAnchor * me);
d242 1
a242 1
extern const char *HTAnchor_style(HTParentAnchor *me);
d244 2
a245 2
extern void HTAnchor_setStyle(HTParentAnchor *me,
			      const char *style);
d250 1
a250 1
extern const char *HTAnchor_title(HTParentAnchor *me);
d252 2
a253 2
extern void HTAnchor_setTitle(HTParentAnchor *me,
			      const char *title);
d255 2
a256 2
extern void HTAnchor_appendTitle(HTParentAnchor *me,
				 const char *title);
d260 1
a260 1
extern const char *HTAnchor_bookmark(HTParentAnchor *me);
d262 2
a263 2
extern void HTAnchor_setBookmark(HTParentAnchor *me,
				 const char *bookmark);
d267 1
a267 1
extern const char *HTAnchor_owner(HTParentAnchor *me);
d269 2
a270 2
extern void HTAnchor_setOwner(HTParentAnchor *me,
			      const char *owner);
d274 1
a274 1
extern const char *HTAnchor_RevTitle(HTParentAnchor *me);
d276 2
a277 2
extern void HTAnchor_setRevTitle(HTParentAnchor *me,
				 const char *title);
d281 1
a281 1
extern const char *HTAnchor_citehost(HTParentAnchor *me);
d283 2
a284 2
extern void HTAnchor_setCitehost(HTParentAnchor *me,
				 const char *citehost);
d290 1
a290 1
extern const char *HTAnchor_SugFname(HTParentAnchor *me);
d294 1
a294 1
extern const char *HTAnchor_http_headers(HTParentAnchor *me);
d298 1
a298 1
extern const char *HTAnchor_content_type_params(HTParentAnchor *me);
d302 1
a302 1
extern const char *HTAnchor_content_type(HTParentAnchor *me);
d308 1
a308 1
extern const char *HTAnchor_content_encoding(HTParentAnchor *me);
d312 1
a312 1
extern const char *HTAnchor_last_modified(HTParentAnchor *me);
d316 1
a316 1
extern const char *HTAnchor_date(HTParentAnchor *me);
d320 1
a320 1
extern const char *HTAnchor_server(HTParentAnchor *me);
d324 1
a324 1
extern BOOL HTAnchor_safe(HTParentAnchor *me);
d328 1
a328 1
extern const char *HTAnchor_content_base(HTParentAnchor *me);
d332 1
a332 1
extern const char *HTAnchor_content_location(HTParentAnchor *me);
d336 1
a336 1
extern const char *HTAnchor_messageID(HTParentAnchor *me);
d338 2
a339 2
extern BOOL HTAnchor_setMessageID(HTParentAnchor *me,
				  const char *messageid);
d343 1
a343 1
extern const char *HTAnchor_subject(HTParentAnchor *me);
d345 2
a346 2
extern BOOL HTAnchor_setSubject(HTParentAnchor *me,
				const char *subject);
d351 1
a351 1
extern HTAnchor *HTAnchor_followLink(HTChildAnchor *me);
d353 2
a354 2
extern HTAnchor *HTAnchor_followTypedLink(HTChildAnchor *me,
					  HTLinkType *type);
d359 1
a359 1
extern HTList *HTAnchor_methods(HTParentAnchor *me);
d364 1
a364 1
extern void *HTAnchor_protocol(HTParentAnchor *me);
d366 2
a367 2
extern void HTAnchor_setProtocol(HTParentAnchor *me,
				 void *protocol);
d372 1
a372 1
extern char *HTAnchor_physical(HTParentAnchor *me);
d374 2
a375 2
extern void HTAnchor_setPhysical(HTParentAnchor *me,
				 char *protocol);
d377 2
a378 2
extern LYUCcharset *HTAnchor_getUCInfoStage(HTParentAnchor *me,
					    int which_stage);
d380 2
a381 2
extern int HTAnchor_getUCLYhndl(HTParentAnchor *me,
				int which_stage);
d383 4
a386 4
extern LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
					    int LYhndl,
					    int which_stage,
					    int set_by);
d388 4
a391 4
extern LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
					    int LYhndl,
					    int which_stage,
					    int set_by);
d393 4
a396 4
extern LYUCcharset *HTAnchor_resetUCInfoStage(HTParentAnchor *me,
					      int LYhndl,
					      int which_stage,
					      int set_by);
d398 4
a401 4
extern LYUCcharset *HTAnchor_copyUCInfoStage(HTParentAnchor *me,
					     int to_stage,
					     int from_stage,
					     int set_by);
d403 1
a403 1
extern void ImageMapList_free(HTList *list);
d405 4
a408 1
#endif /* HTANCHOR_H */
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d5 5
a9 5
**	==========================
**
**	An anchor represents a region of a hypertext document which is linked
**	to another anchor in the same or a different document.
*/
d24 2
a25 2
**			=========================
*/
d27 1
a27 1
typedef struct _HyperDoc HyperDoc;  /* Ready for forward references */
a34 1

d36 1
a36 1
  HTParentAnchor0 * parent;	/* Parent of this anchor (self for adults) */
d41 2
a42 2
  /* Common part from the generic anchor structure */
  HTParentAnchor0 * parent;	/* (self) */
d44 10
a53 10
  /* ParentAnchor0-specific information */
  char		  * address;	/* Absolute address of this node */
  HTParentAnchor  * info;	/* additional info, allocated on demand */

  HTBTree *	children;	/* Subanchors <a name="tag">, sorted by tag */
  HTList	sources;	/* List of anchors pointing to this, if any */

  HTList	_add_adult;	/* - just a memory for list entry:) */
  short		adult_hash;	/* adult list number */
  BOOL		underway;	/* Document about to be attached to it */
d64 2
a65 2
  /* Common part from the generic anchor structure */
  HTParentAnchor0 * parent;	/* Parent of this anchor */
d67 17
a83 17
  /* ParentAnchor-specific information */
  HTList	children_notag;	/* Subanchors <a href=...>, tag is NULL */
  HyperDoc *	document;	/* The document within which this is an anchor*/

  char *	address;	/* parent->address, a pointer */
  bstring *	post_data;	/* Posting data */
  char *	post_content_type;  /* Type of post data */
  char *	bookmark;	/* Bookmark filename */
  HTFormat	format;		/* Pointer to node format descriptor */
  char *	charset;	/* Pointer to character set (kludge, for now */
  BOOL		isIndex;	/* Acceptance of a keyword search */
  char *	isIndexAction;	/* URL of isIndex server */
  char *	isIndexPrompt;	/* Prompt for isIndex query */
  char *	title;		/* Title of document */
  char *	owner;		/* Owner of document */
  char *	RevTitle;	/* TITLE in REV="made" or REV="owner" LINK */
  char *	citehost;	/* Citehost from REL="citehost" LINK */
d85 1
a85 1
  char *	style;
d88 6
a93 6
  HTList*	methods;	/* Methods available as HTAtoms */
  void *	protocol;	/* Protocol object */
  char *	physical;	/* Physical address */
  BOOL		isISMAPScript;	/* Script for clickable image map */
  BOOL		isHEAD;		/* Document is headers from a HEAD request */
  BOOL		safe;			/* Safe */
d95 2
a96 2
  char *	source_cache_file;
  HTChunk *	source_cache_chunk;
d98 26
a123 22
  char *	FileCache;	/* Path to a disk-cached copy (see src/HTFWriter.c) */
  char *	SugFname;	/* Suggested filename */
  char *	cache_control;	/* Cache-Control */
  BOOL		no_cache;	/* Cache-Control, Pragma or META "no-cache"? */
  BOOL		inBASE;		/* duplicated from HTStructured (HTML.c/h) */
  char *	content_type;		/* Content-Type */
  char *	content_language;	/* Content-Language */
  char *	content_encoding;	/* Compression algorithm */
  char *	content_base;		/* Content-Base */
  char *	content_disposition;	/* Content-Disposition */
  char *	content_location;	/* Content-Location */
  char *	content_md5;		/* Content-MD5 */
  char *	message_id;		/* Message-ID */
  char *	subject;		/* Subject */
  int		content_length;		/* Content-Length */
  char *	date;			/* Date */
  char *	expires;		/* Expires */
  char *	last_modified;		/* Last-Modified */
  char *	ETag;			/* ETag (HTTP1.1 cache validator) */
  char *	server;			/* Server */
  UCAnchorInfo *UCStages;		/* chartrans stages */
  HTList *	imaps;			/* client side image maps */
d129 2
a130 2
  /* Common part from the generic anchor structure */
  HTParentAnchor0 * parent;	/* Parent of this anchor */
d132 2
a133 2
  /* ChildAnchor-specific information */
  char *	tag;		/* #fragment,  relative to the parent */
d135 2
a136 2
  HTAnchor *	dest;		/* The anchor to which this leads */
  HTLinkType *	type;		/* Semantics of this link */
d138 2
a139 2
  HTList	_add_children_notag;	/* - just a memory for list entry:) */
  HTList	_add_sources;		/* - just a memory for list entry:) */
d143 3
a145 3
**  DocAddress structure is used for loading an absolute anchor with all
**  needed information including posting data and post content type.
*/
d147 6
a152 6
    char *	address;
    bstring *	post_data;
    char *	post_content_type;
    char *	bookmark;
    BOOL	isHEAD;
    BOOL	safe;
d156 1
a156 1
extern HTLinkType * HTInternalLink;
d159 10
a168 11
**	--------------------------------------------------
**
**	Create new anchor with a given parent and possibly
**	a name, and possibly a link to a _relatively_ named anchor.
**	(Code originally in ParseHTML.h)
*/
extern HTChildAnchor * HTAnchor_findChildAndLink (
	HTParentAnchor * parent,	/* May not be 0 */
	const char * tag,		/* May be "" or 0 */
	const char * href,		/* May be "" or 0 */
	HTLinkType * ltype);		/* May be 0 */
d171 8
a178 9
**	------------------------------------
**
**	This one is for a reference which is found in a document, and might
**	not be already loaded.
**	Note: You are not guaranteed a new anchor -- you might get an old one,
**	like with fonts.
*/
extern HTParentAnchor * HTAnchor_findAddress (
	const DocAddress *	address);
d181 6
a186 7
**	-------------------------------------------------
**
**	Like the previous one, but simpler to use for simple cases.
**	No post data etc. can be supplied. - kw
*/
extern HTParentAnchor * HTAnchor_findSimpleAddress (
	const char *	url);
d189 9
a197 10
**	--------------------------------------------
**
**	The anchor is only deleted if the corresponding document is not loaded.
**	All outgoing links from children are deleted, and children are
**	removed from the sources lists of their targets.
**	We also try to delete the targets whose documents are not loaded.
**	If this anchor's sources list is empty, we delete it and its children.
*/
extern BOOL HTAnchor_delete (
	HTParentAnchor0 *	me);
d204 1
a204 2
extern void HTAnchor_delete_links (
	HTParentAnchor *	me);
d207 1
a207 2
extern void HTAnchor_clearSourceCache (
	HTParentAnchor *	me);
d211 3
a213 4
**	---------------------
*/
extern HTParentAnchor * HTAnchor_parent (
	HTAnchor *		me);
d215 2
a216 3
extern void HTAnchor_setDocument (
	HTParentAnchor *	me,
	HyperDoc *		doc);
d218 1
a218 2
extern HyperDoc * HTAnchor_document (
	HTParentAnchor *	me);
d221 3
a223 4
**	as a malloc'd string to be freed by the caller.
*/
extern char * HTAnchor_address (
	HTAnchor *		me);
d225 2
a226 3
extern void HTAnchor_setFormat (
	HTParentAnchor *	me,
	HTFormat		form);
d228 1
a228 2
extern HTFormat HTAnchor_format (
	HTParentAnchor *	me);
d230 2
a231 3
extern void HTAnchor_setIndex (
	HTParentAnchor *	me,
	const char *		address);
d233 2
a234 3
extern void HTAnchor_setPrompt (
	HTParentAnchor *	me,
	const char *		prompt);
d236 1
a236 2
extern BOOL HTAnchor_isIndex (
	HTParentAnchor *	me);
d238 1
a238 2
extern BOOL HTAnchor_isISMAPScript (
	HTAnchor *		me);
d241 1
a241 2
extern const char * HTAnchor_style (
	HTParentAnchor *	me);
d243 2
a244 3
extern void HTAnchor_setStyle (
	HTParentAnchor *	me,
	const char *		style);
d249 4
a252 2
extern const char * HTAnchor_title (
	HTParentAnchor *	me);
d254 2
a255 7
extern void HTAnchor_setTitle (
	HTParentAnchor *	me,
	const char *		title);

extern void HTAnchor_appendTitle (
	HTParentAnchor *	me,
	const char *		title);
d259 1
a259 2
extern const char * HTAnchor_bookmark (
	HTParentAnchor *	me);
d261 2
a262 3
extern void HTAnchor_setBookmark (
	HTParentAnchor *	me,
	const char *		bookmark);
d266 1
a266 2
extern const char * HTAnchor_owner (
	HTParentAnchor *	me);
d268 2
a269 3
extern void HTAnchor_setOwner (
	HTParentAnchor *	me,
	const char *		owner);
d273 1
a273 2
extern const char * HTAnchor_RevTitle (
	HTParentAnchor *	me);
d275 2
a276 3
extern void HTAnchor_setRevTitle (
	HTParentAnchor *	me,
	const char *		title);
d280 1
a280 2
extern const char * HTAnchor_citehost (
	HTParentAnchor *	me);
d282 2
a283 3
extern void HTAnchor_setCitehost (
	HTParentAnchor *	me,
	const char *		citehost);
d286 6
a291 2
**	(will be loaded if we had a Content-Disposition
**	 header or META element with filename=name.suffix)
d293 5
a297 2
extern const char * HTAnchor_SugFname (
	HTParentAnchor *	me);
d301 1
a301 2
extern const char * HTAnchor_content_type (
	HTParentAnchor *	me);
d304 4
a307 5
**	(will be loaded if we had a Content-Encoding
**	 header.)
*/
extern const char * HTAnchor_content_encoding (
	HTParentAnchor *	me);
d311 1
a311 2
extern const char * HTAnchor_last_modified (
	HTParentAnchor *	me);
d315 1
a315 2
extern const char * HTAnchor_date (
	HTParentAnchor *	me);
d319 1
a319 2
extern const char * HTAnchor_server (
	HTParentAnchor *	me);
d323 1
a323 2
extern BOOL HTAnchor_safe (
	HTParentAnchor *	me);
d327 1
a327 2
extern const char * HTAnchor_content_base (
	HTParentAnchor *	me);
d331 1
a331 2
extern const char * HTAnchor_content_location (
	HTParentAnchor *	me);
d335 1
a335 2
extern const char * HTAnchor_messageID (
	HTParentAnchor *	me);
d337 2
a338 3
extern BOOL HTAnchor_setMessageID (
	HTParentAnchor *	me,
	const char *		messageid);
d342 1
a342 2
extern const char * HTAnchor_subject (
	HTParentAnchor *	me);
d344 2
a345 3
extern BOOL HTAnchor_setSubject (
	HTParentAnchor *	me,
	const char *		subject);
d348 3
a350 4
**	---------------------
*/
extern HTAnchor * HTAnchor_followLink (
	HTChildAnchor *		me);
d352 2
a353 3
extern HTAnchor * HTAnchor_followTypedLink (
	HTChildAnchor *		me,
	HTLinkType *		type);
d356 3
a358 4
**	----------------------
*/
extern HTList * HTAnchor_methods (
	HTParentAnchor *	me);
d361 3
a363 4
**	--------
*/
extern void * HTAnchor_protocol (
	HTParentAnchor *	me);
d365 2
a366 3
extern void HTAnchor_setProtocol (
	HTParentAnchor *	me,
	void *			protocol);
d369 9
a377 4
**	----------------
*/
extern char * HTAnchor_physical (
	HTParentAnchor *	me);
d379 22
a400 35
extern void HTAnchor_setPhysical (
	HTParentAnchor *	me,
	char *			protocol);

extern LYUCcharset * HTAnchor_getUCInfoStage (
	HTParentAnchor *	me,
	int			which_stage);

extern int HTAnchor_getUCLYhndl (
	HTParentAnchor *	me,
	int			which_stage);

extern LYUCcharset * HTAnchor_setUCInfoStage (
	HTParentAnchor *	me,
	int			LYhndl,
	int			which_stage,
	int			set_by);

extern LYUCcharset * HTAnchor_setUCInfoStage (
	HTParentAnchor *	me,
	int			LYhndl,
	int			which_stage,
	int			set_by);

extern LYUCcharset * HTAnchor_resetUCInfoStage (
	HTParentAnchor *	me,
	int			LYhndl,
	int			which_stage,
	int			set_by);

extern LYUCcharset * HTAnchor_copyUCInfoStage (
	HTParentAnchor *	me,
	int			to_stage,
	int			from_stage,
	int			set_by);
d402 1
a402 1
extern void ImageMapList_free (HTList * list);
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d162 1
a162 1
extern HTChildAnchor * HTAnchor_findChildAndLink PARAMS((
d164 3
a166 3
	CONST char * tag,		/* May be "" or 0 */
	CONST char * href,		/* May be "" or 0 */
	HTLinkType * ltype));		/* May be 0 */
d176 2
a177 2
extern HTParentAnchor * HTAnchor_findAddress PARAMS((
	CONST DocAddress *	address));
d185 2
a186 2
extern HTParentAnchor * HTAnchor_findSimpleAddress PARAMS((
	CONST char *	url));
d197 2
a198 2
extern BOOL HTAnchor_delete PARAMS((
	HTParentAnchor0 *	me));
d205 2
a206 2
extern void HTAnchor_delete_links PARAMS((
	HTParentAnchor *	me));
d209 2
a210 2
extern void HTAnchor_clearSourceCache PARAMS((
	HTParentAnchor *	me));
d216 2
a217 2
extern HTParentAnchor * HTAnchor_parent PARAMS((
	HTAnchor *		me));
d219 1
a219 1
extern void HTAnchor_setDocument PARAMS((
d221 1
a221 1
	HyperDoc *		doc));
d223 2
a224 2
extern HyperDoc * HTAnchor_document PARAMS((
	HTParentAnchor *	me));
d229 2
a230 2
extern char * HTAnchor_address PARAMS((
	HTAnchor *		me));
d232 1
a232 1
extern void HTAnchor_setFormat PARAMS((
d234 1
a234 1
	HTFormat		form));
d236 2
a237 2
extern HTFormat HTAnchor_format PARAMS((
	HTParentAnchor *	me));
d239 1
a239 1
extern void HTAnchor_setIndex PARAMS((
d241 1
a241 1
	CONST char *		address));
d243 1
a243 1
extern void HTAnchor_setPrompt PARAMS((
d245 1
a245 1
	CONST char *		prompt));
d247 2
a248 2
extern BOOL HTAnchor_isIndex PARAMS((
	HTParentAnchor *	me));
d250 2
a251 2
extern BOOL HTAnchor_isISMAPScript PARAMS((
	HTAnchor *		me));
d254 2
a255 2
extern CONST char * HTAnchor_style PARAMS((
	HTParentAnchor *	me));
d257 1
a257 1
extern void HTAnchor_setStyle PARAMS((
d259 1
a259 1
	CONST char *		style));
d264 2
a265 2
extern CONST char * HTAnchor_title PARAMS((
	HTParentAnchor *	me));
d267 1
a267 1
extern void HTAnchor_setTitle PARAMS((
d269 1
a269 1
	CONST char *		title));
d271 1
a271 1
extern void HTAnchor_appendTitle PARAMS((
d273 1
a273 1
	CONST char *		title));
d277 2
a278 2
extern CONST char * HTAnchor_bookmark PARAMS((
	HTParentAnchor *	me));
d280 1
a280 1
extern void HTAnchor_setBookmark PARAMS((
d282 1
a282 1
	CONST char *		bookmark));
d286 2
a287 2
extern CONST char * HTAnchor_owner PARAMS((
	HTParentAnchor *	me));
d289 1
a289 1
extern void HTAnchor_setOwner PARAMS((
d291 1
a291 1
	CONST char *		owner));
d295 2
a296 2
extern CONST char * HTAnchor_RevTitle PARAMS((
	HTParentAnchor *	me));
d298 1
a298 1
extern void HTAnchor_setRevTitle PARAMS((
d300 1
a300 1
	CONST char *		title));
d304 2
a305 2
extern CONST char * HTAnchor_citehost PARAMS((
	HTParentAnchor *	me));
d307 1
a307 1
extern void HTAnchor_setCitehost PARAMS((
d309 1
a309 1
	CONST char *		citehost));
d315 2
a316 2
extern CONST char * HTAnchor_SugFname PARAMS((
	HTParentAnchor *	me));
d320 2
a321 2
extern CONST char * HTAnchor_content_type PARAMS((
	HTParentAnchor *	me));
d327 2
a328 2
extern CONST char * HTAnchor_content_encoding PARAMS((
	HTParentAnchor *	me));
d332 2
a333 2
extern CONST char * HTAnchor_last_modified PARAMS((
	HTParentAnchor *	me));
d337 2
a338 2
extern CONST char * HTAnchor_date PARAMS((
	HTParentAnchor *	me));
d342 2
a343 2
extern CONST char * HTAnchor_server PARAMS((
	HTParentAnchor *	me));
d347 2
a348 2
extern BOOL HTAnchor_safe PARAMS((
	HTParentAnchor *	me));
d352 2
a353 2
extern CONST char * HTAnchor_content_base PARAMS((
	HTParentAnchor *	me));
d357 2
a358 2
extern CONST char * HTAnchor_content_location PARAMS((
	HTParentAnchor *	me));
d362 2
a363 2
extern CONST char * HTAnchor_messageID PARAMS((
	HTParentAnchor *	me));
d365 1
a365 1
extern BOOL HTAnchor_setMessageID PARAMS((
d367 1
a367 1
	CONST char *		messageid));
d371 2
a372 2
extern CONST char * HTAnchor_subject PARAMS((
	HTParentAnchor *	me));
d374 1
a374 1
extern BOOL HTAnchor_setSubject PARAMS((
d376 1
a376 1
	CONST char *		subject));
d381 2
a382 2
extern HTAnchor * HTAnchor_followLink PARAMS((
	HTChildAnchor *		me));
d384 1
a384 1
extern HTAnchor * HTAnchor_followTypedLink PARAMS((
d386 1
a386 1
	HTLinkType *		type));
d391 2
a392 2
extern HTList * HTAnchor_methods PARAMS((
	HTParentAnchor *	me));
d397 2
a398 2
extern void * HTAnchor_protocol PARAMS((
	HTParentAnchor *	me));
d400 1
a400 1
extern void HTAnchor_setProtocol PARAMS((
d402 1
a402 1
	void *			protocol));
d407 2
a408 2
extern char * HTAnchor_physical PARAMS((
	HTParentAnchor *	me));
d410 1
a410 1
extern void HTAnchor_setPhysical PARAMS((
d412 1
a412 1
	char *			protocol));
d414 1
a414 1
extern LYUCcharset * HTAnchor_getUCInfoStage PARAMS((
d416 1
a416 1
	int			which_stage));
d418 1
a418 1
extern int HTAnchor_getUCLYhndl PARAMS((
d420 1
a420 1
	int			which_stage));
d422 1
a422 1
extern LYUCcharset * HTAnchor_setUCInfoStage PARAMS((
d426 1
a426 1
	int			set_by));
d428 1
a428 1
extern LYUCcharset * HTAnchor_setUCInfoStage PARAMS((
d432 1
a432 1
	int			set_by));
d434 1
a434 1
extern LYUCcharset * HTAnchor_resetUCInfoStage PARAMS((
d438 1
a438 1
	int			set_by));
d440 1
a440 1
extern LYUCcharset * HTAnchor_copyUCInfoStage PARAMS((
d444 1
a444 1
	int			set_by));
d446 1
a446 1
extern void ImageMapList_free PARAMS((HTList * list));
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d95 1
a95 1
#ifdef SOURCE_CACHE
d208 1
a208 1
#ifdef SOURCE_CACHE
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d18 2
d30 1
a34 1
typedef HTAtom HTLinkType;
d36 15
a50 4
typedef struct {
  HTAnchor *	dest;		/* The anchor to which this leads */
  HTLinkType *	type;		/* Semantics of this link */
} HTLink;
d52 3
a54 6
struct _HTAnchor {		/* Generic anchor : just links */
  HTLink	mainLink;	/* Main (or default) destination of this */
  HTList *	links;		/* List of extra links from this, if any */
  /* We separate the first link from the others to avoid too many small mallocs
     involved by a list creation.  Most anchors only point to one place. */
  HTParentAnchor * parent;	/* Parent of this anchor (self for adults) */
d57 7
d66 1
a66 3
  HTLink	mainLink;	/* Main (or default) destination of this */
  HTList *	links;		/* List of extra links from this, if any */
  HTParentAnchor * parent;	/* Parent of this anchor (self) */
d69 5
a73 5
  HTList *	children;	/* Subanchors of this, if any */
  HTList *	sources;	/* List of anchors pointing to this, if any */
  HyperDoc *	document;	/* The document within which this is an anchor */
  char *	address;	/* Absolute address of this node */
  char *	post_data;	/* Posting data */
d84 2
a85 1
#ifdef USE_HASH
a91 1
  BOOL		underway;	/* Document about to be attached to it */
d95 5
a99 1
  char *	FileCache;	/* Path to a disk-cached copy */
d103 1
d123 2
d127 1
a127 3
  HTLink	mainLink;	/* Main (or default) destination of this */
  HTList *	links;		/* List of extra links from this, if any */
  HTParentAnchor * parent;	/* Parent of this anchor */
d130 7
a136 1
  char *	tag;		/* Address of this anchor relative to parent */
d144 6
a149 6
    char * address;
    char * post_data;
    char * post_content_type;
    char * bookmark;
    BOOL   isHEAD;
    BOOL   safe;
d152 2
a153 15
/* "internal" means "within the same document, with certainty".
   It includes a space so it cannot conflict with any (valid) "TYPE"
   attributes on A elements. [According to which DTD, anyway??] - kw */

#define LINK_INTERNAL HTAtom_for("internal link")

/*	Create new or find old sub-anchor
**	---------------------------------
**
**	This one is for a new anchor being edited into an existing
**	document.  The parent anchor must already exist.
*/
extern HTChildAnchor * HTAnchor_findChild PARAMS((
	HTParentAnchor *	parent,
	CONST char *		tag));
d168 2
a169 2
/*	Create new or find old named anchor
**	-----------------------------------
d176 1
a176 1
extern HTAnchor * HTAnchor_findAddress PARAMS((
d179 9
d192 2
a193 2
**	All outgoing links from parent and children are deleted, and this anchor
**	is removed from the sources list of all its targets.
d195 1
a195 1
**	If this anchor's source list is empty, we delete it and its children.
d198 8
d208 4
a211 8
/*		Move an anchor to the head of the list of its siblings
**		------------------------------------------------------
**
**	This is to ensure that an anchor which might have already existed
**	is put in the correct order as we load the document.
*/
extern void HTAnchor_makeLastChild PARAMS((
	HTChildAnchor *		me));
d241 1
a241 1
	char *		address));
d245 1
a245 1
	char *			prompt));
d253 1
a253 4
extern BOOL HTAnchor_hasChildren PARAMS((
	HTParentAnchor *	me));

#if defined(USE_HASH)
d302 9
a377 8
/*	Link this Anchor to another given one
**	-------------------------------------
*/
extern BOOL HTAnchor_link PARAMS((
	HTAnchor *		source,
	HTAnchor *		destination,
	HTLinkType *		type));

d381 2
a382 2
extern HTAnchor * HTAnchor_followMainLink PARAMS((
	HTAnchor *		me));
d385 1
a385 1
	HTAnchor *		me,
a387 4
extern BOOL HTAnchor_makeMainLink PARAMS((
	HTAnchor *		me,
	HTLink *		movingLink));

a448 4

/*

    */
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d5 5
a9 5
 *	==========================
 *
 *	An anchor represents a region of a hypertext document which is linked
 *	to another anchor in the same or a different document.
 */
a17 2
#include <HTBTree.h>
#include <HTChunk.h>
d21 5
a25 1
typedef struct _HyperDoc HyperDoc;	/* Ready for forward references */
a27 1
typedef struct _HTParentAnchor0 HTParentAnchor0;
d29 1
d32 1
a32 26
#ifdef __cplusplus
extern "C" {
#endif
/*			Main definition of anchor
 *			=========================
				 */ struct _HTAnchor {
	/* Generic anchor */
	HTParentAnchor0 *parent;	/* Parent of this anchor (self for adults) */
    };

    struct _HTParentAnchor0 {	/* One for adult_table,
				 * generally not used outside HTAnchor.c */
	/* Common part from the generic anchor structure */
	HTParentAnchor0 *parent;	/* (self) */

	/* ParentAnchor0-specific information */
	char *address;		/* Absolute address of this node */
	HTParentAnchor *info;	/* additional info, allocated on demand */

	HTBTree *children;	/* Subanchors <a name="tag">, sorted by tag */
	HTList sources;		/* List of anchors pointing to this, if any */

	HTList _add_adult;	/* - just a memory for list entry:) */
	short adult_hash;	/* adult list number */
	BOOL underway;		/* Document about to be attached to it */
    };
d34 37
a70 30
/*
 *  Separated from the above to save memory:  allocated on demand,
 *  it is nearly 1:1 to HText (well, sometimes without HText...),
 *  available for SGML, HTML, and HText stages.
 *  [being precise, we currently allocate it before HTLoadDocument(),
 *  in HTAnchor_findAddress() and HTAnchor_parent()].
 */
    struct _HTParentAnchor {
	/* Common part from the generic anchor structure */
	HTParentAnchor0 *parent;	/* Parent of this anchor */

	/* ParentAnchor-specific information */
	HTList children_notag;	/* Subanchors <a href=...>, tag is NULL */
	HyperDoc *document;	/* The document within which this is an anchor */

	char *address;		/* parent->address, a pointer */
	bstring *post_data;	/* Posting data */
	char *post_content_type;	/* Type of post data */
	char *bookmark;		/* Bookmark filename */
	HTFormat format;	/* Pointer to node format descriptor */
	char *charset;		/* Pointer to character set (kludge, for now */
	BOOL isIndex;		/* Acceptance of a keyword search */
	char *isIndexAction;	/* URL of isIndex server */
	char *isIndexPrompt;	/* Prompt for isIndex query */
	char *title;		/* Title of document */
	char *owner;		/* Owner of document */
	char *RevTitle;		/* TITLE in REV="made" or REV="owner" LINK */
	char *citehost;		/* Citehost from REL="citehost" LINK */
#ifdef USE_COLOR_STYLE
	char *style;
d73 39
a111 53
	HTList *methods;	/* Methods available as HTAtoms */
	void *protocol;		/* Protocol object */
	char *physical;		/* Physical address */
	BOOL isISMAPScript;	/* Script for clickable image map */
	BOOL isHEAD;		/* Document is headers from a HEAD request */
	BOOL safe;		/* Safe */
#ifdef USE_SOURCE_CACHE
	char *source_cache_file;
	HTChunk *source_cache_chunk;
#endif
	char *FileCache;	/* Path to a disk-cached copy (see src/HTFWriter.c) */
	char *SugFname;		/* Suggested filename */
	char *cache_control;	/* Cache-Control */
	BOOL no_cache;		/* Cache-Control, Pragma or META "no-cache"? */
	BOOL inBASE;		/* duplicated from HTStructured (HTML.c/h) */
#ifdef EXP_HTTP_HEADERS
	HTChunk http_headers;
#endif
	char *content_type_params;	/* Content-Type (with parameters if any) */
	char *content_type;	/* Content-Type */
	char *content_language;	/* Content-Language */
	char *content_encoding;	/* Compression algorithm */
	char *content_base;	/* Content-Base */
	char *content_disposition;	/* Content-Disposition */
	char *content_location;	/* Content-Location */
	char *content_md5;	/* Content-MD5 */
	char *message_id;	/* Message-ID */
	char *subject;		/* Subject */
	int content_length;	/* Content-Length */
	char *date;		/* Date */
	char *expires;		/* Expires */
	char *last_modified;	/* Last-Modified */
	char *ETag;		/* ETag (HTTP1.1 cache validator) */
	char *server;		/* Server */
	UCAnchorInfo *UCStages;	/* chartrans stages */
	HTList *imaps;		/* client side image maps */
    };

    typedef HTAtom HTLinkType;

    typedef struct {
	/* Common part from the generic anchor structure */
	HTParentAnchor0 *parent;	/* Parent of this anchor */

	/* ChildAnchor-specific information */
	char *tag;		/* #fragment,  relative to the parent */

	HTAnchor *dest;		/* The anchor to which this leads */
	HTLinkType *type;	/* Semantics of this link */

	HTList _add_children_notag;	/* - just a memory for list entry:) */
	HTList _add_sources;	/* - just a memory for list entry:) */
    } HTChildAnchor;
d114 27
a140 14
 *  DocAddress structure is used for loading an absolute anchor with all
 *  needed information including posting data and post content type.
 */
    typedef struct _DocAddress {
	char *address;
	bstring *post_data;
	char *post_content_type;
	char *bookmark;
	BOOL isHEAD;
	BOOL safe;
    } DocAddress;

/* "internal" means "within the same document, with certainty". */
    extern HTLinkType *HTInternalLink;
d143 22
a164 28
 *	--------------------------------------------------
 *
 *	Create new anchor with a given parent and possibly
 *	a name, and possibly a link to a _relatively_ named anchor.
 *	(Code originally in ParseHTML.h)
 */
    extern HTChildAnchor *HTAnchor_findChildAndLink(HTParentAnchor *parent,	/* May not be 0 */
						    const char *tag,	/* May be "" or 0 */
						    const char *href,	/* May be "" or 0 */
						    HTLinkType *ltype);		/* May be 0 */

/*	Create new or find old parent anchor
 *	------------------------------------
 *
 *	This one is for a reference which is found in a document, and might
 *	not be already loaded.
 *	Note: You are not guaranteed a new anchor -- you might get an old one,
 *	like with fonts.
 */
    extern HTParentAnchor *HTAnchor_findAddress(const DocAddress *address);

/*	Create new or find old named anchor - simple form
 *	-------------------------------------------------
 *
 *	Like the previous one, but simpler to use for simple cases.
 *	No post data etc. can be supplied. - kw
 */
    extern HTParentAnchor *HTAnchor_findSimpleAddress(const char *url);
d167 19
a185 20
 *	--------------------------------------------
 *
 *	The anchor is only deleted if the corresponding document is not loaded.
 *	All outgoing links from children are deleted, and children are
 *	removed from the sources lists of their targets.
 *	We also try to delete the targets whose documents are not loaded.
 *	If this anchor's sources list is empty, we delete it and its children.
 */
    extern BOOL HTAnchor_delete(HTParentAnchor0 *me);

/*
 *  Unnamed children (children_notag) have no sense without HText -
 *  delete them and their links if we are about to free HText.
 *  Document currently exists.  Called within HText_free().
 */
    extern void HTAnchor_delete_links(HTParentAnchor *me);

#ifdef USE_SOURCE_CACHE
    extern void HTAnchor_clearSourceCache(HTParentAnchor *me);
#endif
d188 4
a191 3
 *	---------------------
 */
    extern HTParentAnchor *HTAnchor_parent(HTAnchor * me);
d193 3
a195 2
    extern void HTAnchor_setDocument(HTParentAnchor *me,
				     HyperDoc *doc);
d197 2
a198 1
    extern HyperDoc *HTAnchor_document(HTParentAnchor *me);
d201 4
a204 3
 *	as a malloc'd string to be freed by the caller.
 */
    extern char *HTAnchor_address(HTAnchor * me);
d206 3
a208 2
    extern void HTAnchor_setFormat(HTParentAnchor *me,
				   HTFormat form);
d210 2
a211 1
    extern HTFormat HTAnchor_format(HTParentAnchor *me);
d213 3
a215 2
    extern void HTAnchor_setIndex(HTParentAnchor *me,
				  const char *address);
d217 3
a219 2
    extern void HTAnchor_setPrompt(HTParentAnchor *me,
				   const char *prompt);
d221 2
a222 1
    extern BOOL HTAnchor_isIndex(HTParentAnchor *me);
d224 2
a225 1
    extern BOOL HTAnchor_isISMAPScript(HTAnchor * me);
d227 2
a228 2
#if defined(USE_COLOR_STYLE)
    extern const char *HTAnchor_style(HTParentAnchor *me);
d230 7
a236 2
    extern void HTAnchor_setStyle(HTParentAnchor *me,
				  const char *style);
d241 2
a242 4
    extern const char *HTAnchor_title(HTParentAnchor *me);

    extern void HTAnchor_setTitle(HTParentAnchor *me,
				  const char *title);
d244 7
a250 2
    extern void HTAnchor_appendTitle(HTParentAnchor *me,
				     const char *title);
d254 2
a255 1
    extern const char *HTAnchor_bookmark(HTParentAnchor *me);
d257 3
a259 2
    extern void HTAnchor_setBookmark(HTParentAnchor *me,
				     const char *bookmark);
d263 2
a264 1
    extern const char *HTAnchor_owner(HTParentAnchor *me);
d266 3
a268 2
    extern void HTAnchor_setOwner(HTParentAnchor *me,
				  const char *owner);
d272 2
a273 8
    extern const char *HTAnchor_RevTitle(HTParentAnchor *me);

    extern void HTAnchor_setRevTitle(HTParentAnchor *me,
				     const char *title);

/*	Citehost for bibp links from LINKs with REL="citehost". - RDC
*/
    extern const char *HTAnchor_citehost(HTParentAnchor *me);
d275 3
a277 2
    extern void HTAnchor_setCitehost(HTParentAnchor *me,
				     const char *citehost);
d280 2
a281 10
 *	(will be loaded if we had a Content-Disposition
 *	 header or META element with filename=name.suffix)
 */
    extern const char *HTAnchor_SugFname(HTParentAnchor *me);

/*	HTTP Headers.
*/
    extern const char *HTAnchor_http_headers(HTParentAnchor *me);

/*	Content-Type handling (parameter list).
d283 2
a284 1
    extern const char *HTAnchor_content_type_params(HTParentAnchor *me);
d288 2
a289 1
    extern const char *HTAnchor_content_type(HTParentAnchor *me);
d292 5
a296 4
 *	(will be loaded if we had a Content-Encoding
 *	 header.)
 */
    extern const char *HTAnchor_content_encoding(HTParentAnchor *me);
d300 2
a301 1
    extern const char *HTAnchor_last_modified(HTParentAnchor *me);
d305 2
a306 1
    extern const char *HTAnchor_date(HTParentAnchor *me);
d310 2
a311 1
    extern const char *HTAnchor_server(HTParentAnchor *me);
d315 2
a316 1
    extern BOOL HTAnchor_safe(HTParentAnchor *me);
d320 2
a321 1
    extern const char *HTAnchor_content_base(HTParentAnchor *me);
d325 2
a326 1
    extern const char *HTAnchor_content_location(HTParentAnchor *me);
d330 2
a331 1
    extern const char *HTAnchor_messageID(HTParentAnchor *me);
d333 3
a335 2
    extern BOOL HTAnchor_setMessageID(HTParentAnchor *me,
				      const char *messageid);
d339 2
a340 1
    extern const char *HTAnchor_subject(HTParentAnchor *me);
d342 11
a352 2
    extern BOOL HTAnchor_setSubject(HTParentAnchor *me,
				    const char *subject);
d355 4
a358 3
 *	---------------------
 */
    extern HTAnchor *HTAnchor_followLink(HTChildAnchor *me);
d360 7
a366 2
    extern HTAnchor *HTAnchor_followTypedLink(HTChildAnchor *me,
					      HTLinkType *type);
d369 4
a372 3
 *	----------------------
 */
    extern HTList *HTAnchor_methods(HTParentAnchor *me);
d375 4
a378 3
 *	--------
 */
    extern void *HTAnchor_protocol(HTParentAnchor *me);
d380 3
a382 2
    extern void HTAnchor_setProtocol(HTParentAnchor *me,
				     void *protocol);
d385 40
a424 32
 *	----------------
 */
    extern char *HTAnchor_physical(HTParentAnchor *me);

    extern void HTAnchor_setPhysical(HTParentAnchor *me,
				     char *protocol);

    extern LYUCcharset *HTAnchor_getUCInfoStage(HTParentAnchor *me,
						int which_stage);

    extern int HTAnchor_getUCLYhndl(HTParentAnchor *me,
				    int which_stage);

    extern LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
						int LYhndl,
						int which_stage,
						int set_by);

    extern LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
						int LYhndl,
						int which_stage,
						int set_by);

    extern LYUCcharset *HTAnchor_resetUCInfoStage(HTParentAnchor *me,
						  int LYhndl,
						  int which_stage,
						  int set_by);

    extern LYUCcharset *HTAnchor_copyUCInfoStage(HTParentAnchor *me,
						 int to_stage,
						 int from_stage,
						 int set_by);
d426 1
a426 1
    extern void ImageMapList_free(HTList *list);
d428 5
a432 4
#ifdef __cplusplus
}
#endif
#endif				/* HTANCHOR_H */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a17 2
#include <HTBTree.h>
#include <HTChunk.h>
a27 1
typedef struct _HTParentAnchor0 HTParentAnchor0;
d32 1
d34 4
a37 8
struct _HTAnchor {		/* Generic anchor */
  HTParentAnchor0 * parent;	/* Parent of this anchor (self for adults) */
};

struct _HTParentAnchor0 {	/* One for adult_table,
				 * generally not used outside HTAnchor.c */
  /* Common part from the generic anchor structure */
  HTParentAnchor0 * parent;	/* (self) */
d39 6
a44 10
  /* ParentAnchor0-specific information */
  char		  * address;	/* Absolute address of this node */
  HTParentAnchor  * info;	/* additional info, allocated on demand */

  HTBTree *	children;	/* Subanchors <a name="tag">, sorted by tag */
  HTList	sources;	/* List of anchors pointing to this, if any */

  HTList	_add_adult;	/* - just a memory for list entry:) */
  short		adult_hash;	/* adult list number */
  BOOL		underway;	/* Document about to be attached to it */
a46 7
/*
 *  Separated from the above to save memory:  allocated on demand,
 *  it is nearly 1:1 to HText (well, sometimes without HText...),
 *  available for SGML, HTML, and HText stages.
 *  [being precise, we currently allocate it before HTLoadDocument(),
 *  in HTAnchor_findAddress() and HTAnchor_parent()].
 */
d49 3
a51 1
  HTParentAnchor0 * parent;	/* Parent of this anchor */
d54 5
a58 5
  HTList	children_notag;	/* Subanchors <a href=...>, tag is NULL */
  HyperDoc *	document;	/* The document within which this is an anchor*/

  char *	address;	/* parent->address, a pointer */
  bstring *	post_data;	/* Posting data */
d69 1
a69 2
  char *	citehost;	/* Citehost from REL="citehost" LINK */
#ifdef USE_COLOR_STYLE
d76 1
d80 1
a80 5
#ifdef SOURCE_CACHE
  char *	source_cache_file;
  HTChunk *	source_cache_chunk;
#endif
  char *	FileCache;	/* Path to a disk-cached copy (see src/HTFWriter.c) */
a83 1
  BOOL		inBASE;		/* duplicated from HTStructured (HTML.c/h) */
a102 2
typedef HTAtom HTLinkType;

d105 3
a107 1
  HTParentAnchor0 * parent;	/* Parent of this anchor */
d110 1
a110 7
  char *	tag;		/* #fragment,  relative to the parent */

  HTAnchor *	dest;		/* The anchor to which this leads */
  HTLinkType *	type;		/* Semantics of this link */

  HTList	_add_children_notag;	/* - just a memory for list entry:) */
  HTList	_add_sources;		/* - just a memory for list entry:) */
d118 6
a123 6
    char *	address;
    bstring *	post_data;
    char *	post_content_type;
    char *	bookmark;
    BOOL	isHEAD;
    BOOL	safe;
d126 15
a140 2
/* "internal" means "within the same document, with certainty". */
extern HTLinkType * HTInternalLink;
d155 2
a156 2
/*	Create new or find old parent anchor
**	------------------------------------
d163 1
a163 1
extern HTParentAnchor * HTAnchor_findAddress PARAMS((
a165 9
/*	Create new or find old named anchor - simple form
**	-------------------------------------------------
**
**	Like the previous one, but simpler to use for simple cases.
**	No post data etc. can be supplied. - kw
*/
extern HTParentAnchor * HTAnchor_findSimpleAddress PARAMS((
	CONST char *	url));

d170 2
a171 2
**	All outgoing links from children are deleted, and children are
**	removed from the sources lists of their targets.
d173 1
a173 1
**	If this anchor's sources list is empty, we delete it and its children.
a175 8
	HTParentAnchor0 *	me));

/*
 *  Unnamed children (children_notag) have no sense without HText -
 *  delete them and their links if we are about to free HText.
 *  Document currently exists.  Called within HText_free().
 */
extern void HTAnchor_delete_links PARAMS((
d178 8
a185 4
#ifdef SOURCE_CACHE
extern void HTAnchor_clearSourceCache PARAMS((
	HTParentAnchor *	me));
#endif
d215 1
a215 1
	CONST char *		address));
d219 1
a219 1
	CONST char *		prompt));
d227 4
a230 1
#if defined(USE_COLOR_STYLE)
a278 9
/*	Citehost for bibp links from LINKs with REL="citehost". - RDC
*/
extern CONST char * HTAnchor_citehost PARAMS((
	HTParentAnchor *	me));

extern void HTAnchor_setCitehost PARAMS((
	HTParentAnchor *	me,
	CONST char *		citehost));

d346 8
d357 2
a358 2
extern HTAnchor * HTAnchor_followLink PARAMS((
	HTChildAnchor *		me));
d361 1
a361 1
	HTChildAnchor *		me,
d364 4
d429 4
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d95 1
a95 1
#ifdef USE_SOURCE_CACHE
d208 1
a208 1
#ifdef USE_SOURCE_CACHE
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d162 1
a162 1
extern HTChildAnchor * HTAnchor_findChildAndLink (
d164 3
a166 3
	const char * tag,		/* May be "" or 0 */
	const char * href,		/* May be "" or 0 */
	HTLinkType * ltype);		/* May be 0 */
d176 2
a177 2
extern HTParentAnchor * HTAnchor_findAddress (
	const DocAddress *	address);
d185 2
a186 2
extern HTParentAnchor * HTAnchor_findSimpleAddress (
	const char *	url);
d197 2
a198 2
extern BOOL HTAnchor_delete (
	HTParentAnchor0 *	me);
d205 2
a206 2
extern void HTAnchor_delete_links (
	HTParentAnchor *	me);
d209 2
a210 2
extern void HTAnchor_clearSourceCache (
	HTParentAnchor *	me);
d216 2
a217 2
extern HTParentAnchor * HTAnchor_parent (
	HTAnchor *		me);
d219 1
a219 1
extern void HTAnchor_setDocument (
d221 1
a221 1
	HyperDoc *		doc);
d223 2
a224 2
extern HyperDoc * HTAnchor_document (
	HTParentAnchor *	me);
d229 2
a230 2
extern char * HTAnchor_address (
	HTAnchor *		me);
d232 1
a232 1
extern void HTAnchor_setFormat (
d234 1
a234 1
	HTFormat		form);
d236 2
a237 2
extern HTFormat HTAnchor_format (
	HTParentAnchor *	me);
d239 1
a239 1
extern void HTAnchor_setIndex (
d241 1
a241 1
	const char *		address);
d243 1
a243 1
extern void HTAnchor_setPrompt (
d245 1
a245 1
	const char *		prompt);
d247 2
a248 2
extern BOOL HTAnchor_isIndex (
	HTParentAnchor *	me);
d250 2
a251 2
extern BOOL HTAnchor_isISMAPScript (
	HTAnchor *		me);
d254 2
a255 2
extern const char * HTAnchor_style (
	HTParentAnchor *	me);
d257 1
a257 1
extern void HTAnchor_setStyle (
d259 1
a259 1
	const char *		style);
d264 2
a265 2
extern const char * HTAnchor_title (
	HTParentAnchor *	me);
d267 1
a267 1
extern void HTAnchor_setTitle (
d269 1
a269 1
	const char *		title);
d271 1
a271 1
extern void HTAnchor_appendTitle (
d273 1
a273 1
	const char *		title);
d277 2
a278 2
extern const char * HTAnchor_bookmark (
	HTParentAnchor *	me);
d280 1
a280 1
extern void HTAnchor_setBookmark (
d282 1
a282 1
	const char *		bookmark);
d286 2
a287 2
extern const char * HTAnchor_owner (
	HTParentAnchor *	me);
d289 1
a289 1
extern void HTAnchor_setOwner (
d291 1
a291 1
	const char *		owner);
d295 2
a296 2
extern const char * HTAnchor_RevTitle (
	HTParentAnchor *	me);
d298 1
a298 1
extern void HTAnchor_setRevTitle (
d300 1
a300 1
	const char *		title);
d304 2
a305 2
extern const char * HTAnchor_citehost (
	HTParentAnchor *	me);
d307 1
a307 1
extern void HTAnchor_setCitehost (
d309 1
a309 1
	const char *		citehost);
d315 2
a316 2
extern const char * HTAnchor_SugFname (
	HTParentAnchor *	me);
d320 2
a321 2
extern const char * HTAnchor_content_type (
	HTParentAnchor *	me);
d327 2
a328 2
extern const char * HTAnchor_content_encoding (
	HTParentAnchor *	me);
d332 2
a333 2
extern const char * HTAnchor_last_modified (
	HTParentAnchor *	me);
d337 2
a338 2
extern const char * HTAnchor_date (
	HTParentAnchor *	me);
d342 2
a343 2
extern const char * HTAnchor_server (
	HTParentAnchor *	me);
d347 2
a348 2
extern BOOL HTAnchor_safe (
	HTParentAnchor *	me);
d352 2
a353 2
extern const char * HTAnchor_content_base (
	HTParentAnchor *	me);
d357 2
a358 2
extern const char * HTAnchor_content_location (
	HTParentAnchor *	me);
d362 2
a363 2
extern const char * HTAnchor_messageID (
	HTParentAnchor *	me);
d365 1
a365 1
extern BOOL HTAnchor_setMessageID (
d367 1
a367 1
	const char *		messageid);
d371 2
a372 2
extern const char * HTAnchor_subject (
	HTParentAnchor *	me);
d374 1
a374 1
extern BOOL HTAnchor_setSubject (
d376 1
a376 1
	const char *		subject);
d381 2
a382 2
extern HTAnchor * HTAnchor_followLink (
	HTChildAnchor *		me);
d384 1
a384 1
extern HTAnchor * HTAnchor_followTypedLink (
d386 1
a386 1
	HTLinkType *		type);
d391 2
a392 2
extern HTList * HTAnchor_methods (
	HTParentAnchor *	me);
d397 2
a398 2
extern void * HTAnchor_protocol (
	HTParentAnchor *	me);
d400 1
a400 1
extern void HTAnchor_setProtocol (
d402 1
a402 1
	void *			protocol);
d407 2
a408 2
extern char * HTAnchor_physical (
	HTParentAnchor *	me);
d410 1
a410 1
extern void HTAnchor_setPhysical (
d412 1
a412 1
	char *			protocol);
d414 1
a414 1
extern LYUCcharset * HTAnchor_getUCInfoStage (
d416 1
a416 1
	int			which_stage);
d418 1
a418 1
extern int HTAnchor_getUCLYhndl (
d420 1
a420 1
	int			which_stage);
d422 1
a422 1
extern LYUCcharset * HTAnchor_setUCInfoStage (
d426 1
a426 1
	int			set_by);
d428 1
a428 1
extern LYUCcharset * HTAnchor_setUCInfoStage (
d432 1
a432 1
	int			set_by);
d434 1
a434 1
extern LYUCcharset * HTAnchor_resetUCInfoStage (
d438 1
a438 1
	int			set_by);
d440 1
a440 1
extern LYUCcharset * HTAnchor_copyUCInfoStage (
d444 1
a444 1
	int			set_by);
d446 1
a446 1
extern void ImageMapList_free (HTList * list);
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d5 5
a9 5
 *	==========================
 *
 *	An anchor represents a region of a hypertext document which is linked
 *	to another anchor in the same or a different document.
 */
d24 2
a25 2
 *			=========================
 */
d27 1
a27 1
typedef struct _HyperDoc HyperDoc;	/* Ready for forward references */
d35 1
d37 1
a37 1
    HTParentAnchor0 *parent;	/* Parent of this anchor (self for adults) */
d42 2
a43 2
    /* Common part from the generic anchor structure */
    HTParentAnchor0 *parent;	/* (self) */
d45 10
a54 10
    /* ParentAnchor0-specific information */
    char *address;		/* Absolute address of this node */
    HTParentAnchor *info;	/* additional info, allocated on demand */

    HTBTree *children;		/* Subanchors <a name="tag">, sorted by tag */
    HTList sources;		/* List of anchors pointing to this, if any */

    HTList _add_adult;		/* - just a memory for list entry:) */
    short adult_hash;		/* adult list number */
    BOOL underway;		/* Document about to be attached to it */
d65 2
a66 2
    /* Common part from the generic anchor structure */
    HTParentAnchor0 *parent;	/* Parent of this anchor */
d68 17
a84 17
    /* ParentAnchor-specific information */
    HTList children_notag;	/* Subanchors <a href=...>, tag is NULL */
    HyperDoc *document;		/* The document within which this is an anchor */

    char *address;		/* parent->address, a pointer */
    bstring *post_data;		/* Posting data */
    char *post_content_type;	/* Type of post data */
    char *bookmark;		/* Bookmark filename */
    HTFormat format;		/* Pointer to node format descriptor */
    char *charset;		/* Pointer to character set (kludge, for now */
    BOOL isIndex;		/* Acceptance of a keyword search */
    char *isIndexAction;	/* URL of isIndex server */
    char *isIndexPrompt;	/* Prompt for isIndex query */
    char *title;		/* Title of document */
    char *owner;		/* Owner of document */
    char *RevTitle;		/* TITLE in REV="made" or REV="owner" LINK */
    char *citehost;		/* Citehost from REL="citehost" LINK */
d86 1
a86 1
    char *style;
d89 6
a94 6
    HTList *methods;		/* Methods available as HTAtoms */
    void *protocol;		/* Protocol object */
    char *physical;		/* Physical address */
    BOOL isISMAPScript;		/* Script for clickable image map */
    BOOL isHEAD;		/* Document is headers from a HEAD request */
    BOOL safe;			/* Safe */
d96 2
a97 2
    char *source_cache_file;
    HTChunk *source_cache_chunk;
d99 22
a120 26
    char *FileCache;		/* Path to a disk-cached copy (see src/HTFWriter.c) */
    char *SugFname;		/* Suggested filename */
    char *cache_control;	/* Cache-Control */
    BOOL no_cache;		/* Cache-Control, Pragma or META "no-cache"? */
    BOOL inBASE;		/* duplicated from HTStructured (HTML.c/h) */
#ifdef EXP_HTTP_HEADERS
    HTChunk http_headers;
#endif
    char *content_type_params;	/* Content-Type (with parameters if any) */
    char *content_type;		/* Content-Type */
    char *content_language;	/* Content-Language */
    char *content_encoding;	/* Compression algorithm */
    char *content_base;		/* Content-Base */
    char *content_disposition;	/* Content-Disposition */
    char *content_location;	/* Content-Location */
    char *content_md5;		/* Content-MD5 */
    char *message_id;		/* Message-ID */
    char *subject;		/* Subject */
    int content_length;		/* Content-Length */
    char *date;			/* Date */
    char *expires;		/* Expires */
    char *last_modified;	/* Last-Modified */
    char *ETag;			/* ETag (HTTP1.1 cache validator) */
    char *server;		/* Server */
    UCAnchorInfo *UCStages;	/* chartrans stages */
    HTList *imaps;		/* client side image maps */
d126 2
a127 2
    /* Common part from the generic anchor structure */
    HTParentAnchor0 *parent;	/* Parent of this anchor */
d129 2
a130 2
    /* ChildAnchor-specific information */
    char *tag;			/* #fragment,  relative to the parent */
d132 2
a133 2
    HTAnchor *dest;		/* The anchor to which this leads */
    HTLinkType *type;		/* Semantics of this link */
d135 2
a136 2
    HTList _add_children_notag;	/* - just a memory for list entry:) */
    HTList _add_sources;	/* - just a memory for list entry:) */
d140 3
a142 3
 *  DocAddress structure is used for loading an absolute anchor with all
 *  needed information including posting data and post content type.
 */
d144 6
a149 6
    char *address;
    bstring *post_data;
    char *post_content_type;
    char *bookmark;
    BOOL isHEAD;
    BOOL safe;
d153 1
a153 1
extern HTLinkType *HTInternalLink;
d156 11
a166 10
 *	--------------------------------------------------
 *
 *	Create new anchor with a given parent and possibly
 *	a name, and possibly a link to a _relatively_ named anchor.
 *	(Code originally in ParseHTML.h)
 */
extern HTChildAnchor *HTAnchor_findChildAndLink(HTParentAnchor *parent,		/* May not be 0 */
						const char *tag,	/* May be "" or 0 */
						const char *href,	/* May be "" or 0 */
						HTLinkType *ltype);	/* May be 0 */
d169 9
a177 8
 *	------------------------------------
 *
 *	This one is for a reference which is found in a document, and might
 *	not be already loaded.
 *	Note: You are not guaranteed a new anchor -- you might get an old one,
 *	like with fonts.
 */
extern HTParentAnchor *HTAnchor_findAddress(const DocAddress *address);
d180 7
a186 6
 *	-------------------------------------------------
 *
 *	Like the previous one, but simpler to use for simple cases.
 *	No post data etc. can be supplied. - kw
 */
extern HTParentAnchor *HTAnchor_findSimpleAddress(const char *url);
d189 10
a198 9
 *	--------------------------------------------
 *
 *	The anchor is only deleted if the corresponding document is not loaded.
 *	All outgoing links from children are deleted, and children are
 *	removed from the sources lists of their targets.
 *	We also try to delete the targets whose documents are not loaded.
 *	If this anchor's sources list is empty, we delete it and its children.
 */
extern BOOL HTAnchor_delete(HTParentAnchor0 *me);
d205 2
a206 1
extern void HTAnchor_delete_links(HTParentAnchor *me);
d209 2
a210 1
extern void HTAnchor_clearSourceCache(HTParentAnchor *me);
d214 4
a217 3
 *	---------------------
 */
extern HTParentAnchor *HTAnchor_parent(HTAnchor * me);
d219 3
a221 2
extern void HTAnchor_setDocument(HTParentAnchor *me,
				 HyperDoc *doc);
d223 2
a224 1
extern HyperDoc *HTAnchor_document(HTParentAnchor *me);
d227 4
a230 3
 *	as a malloc'd string to be freed by the caller.
 */
extern char *HTAnchor_address(HTAnchor * me);
d232 3
a234 2
extern void HTAnchor_setFormat(HTParentAnchor *me,
			       HTFormat form);
d236 2
a237 1
extern HTFormat HTAnchor_format(HTParentAnchor *me);
d239 3
a241 2
extern void HTAnchor_setIndex(HTParentAnchor *me,
			      const char *address);
d243 3
a245 2
extern void HTAnchor_setPrompt(HTParentAnchor *me,
			       const char *prompt);
d247 2
a248 1
extern BOOL HTAnchor_isIndex(HTParentAnchor *me);
d250 2
a251 1
extern BOOL HTAnchor_isISMAPScript(HTAnchor * me);
d254 2
a255 1
extern const char *HTAnchor_style(HTParentAnchor *me);
d257 3
a259 2
extern void HTAnchor_setStyle(HTParentAnchor *me,
			      const char *style);
d264 2
a265 4
extern const char *HTAnchor_title(HTParentAnchor *me);

extern void HTAnchor_setTitle(HTParentAnchor *me,
			      const char *title);
d267 7
a273 2
extern void HTAnchor_appendTitle(HTParentAnchor *me,
				 const char *title);
d277 2
a278 1
extern const char *HTAnchor_bookmark(HTParentAnchor *me);
d280 3
a282 2
extern void HTAnchor_setBookmark(HTParentAnchor *me,
				 const char *bookmark);
d286 2
a287 1
extern const char *HTAnchor_owner(HTParentAnchor *me);
d289 3
a291 2
extern void HTAnchor_setOwner(HTParentAnchor *me,
			      const char *owner);
d295 2
a296 1
extern const char *HTAnchor_RevTitle(HTParentAnchor *me);
d298 3
a300 2
extern void HTAnchor_setRevTitle(HTParentAnchor *me,
				 const char *title);
d304 2
a305 1
extern const char *HTAnchor_citehost(HTParentAnchor *me);
d307 3
a309 2
extern void HTAnchor_setCitehost(HTParentAnchor *me,
				 const char *citehost);
d312 2
a313 6
 *	(will be loaded if we had a Content-Disposition
 *	 header or META element with filename=name.suffix)
 */
extern const char *HTAnchor_SugFname(HTParentAnchor *me);

/*	HTTP Headers.
d315 2
a316 5
extern const char *HTAnchor_http_headers(HTParentAnchor *me);

/*	Content-Type handling (parameter list).
*/
extern const char *HTAnchor_content_type_params(HTParentAnchor *me);
d320 2
a321 1
extern const char *HTAnchor_content_type(HTParentAnchor *me);
d324 5
a328 4
 *	(will be loaded if we had a Content-Encoding
 *	 header.)
 */
extern const char *HTAnchor_content_encoding(HTParentAnchor *me);
d332 2
a333 1
extern const char *HTAnchor_last_modified(HTParentAnchor *me);
d337 2
a338 1
extern const char *HTAnchor_date(HTParentAnchor *me);
d342 2
a343 1
extern const char *HTAnchor_server(HTParentAnchor *me);
d347 2
a348 1
extern BOOL HTAnchor_safe(HTParentAnchor *me);
d352 2
a353 1
extern const char *HTAnchor_content_base(HTParentAnchor *me);
d357 2
a358 1
extern const char *HTAnchor_content_location(HTParentAnchor *me);
d362 2
a363 1
extern const char *HTAnchor_messageID(HTParentAnchor *me);
d365 3
a367 2
extern BOOL HTAnchor_setMessageID(HTParentAnchor *me,
				  const char *messageid);
d371 2
a372 1
extern const char *HTAnchor_subject(HTParentAnchor *me);
d374 3
a376 2
extern BOOL HTAnchor_setSubject(HTParentAnchor *me,
				const char *subject);
d379 4
a382 3
 *	---------------------
 */
extern HTAnchor *HTAnchor_followLink(HTChildAnchor *me);
d384 3
a386 2
extern HTAnchor *HTAnchor_followTypedLink(HTChildAnchor *me,
					  HTLinkType *type);
d389 4
a392 3
 *	----------------------
 */
extern HTList *HTAnchor_methods(HTParentAnchor *me);
d395 4
a398 3
 *	--------
 */
extern void *HTAnchor_protocol(HTParentAnchor *me);
d400 3
a402 2
extern void HTAnchor_setProtocol(HTParentAnchor *me,
				 void *protocol);
d405 4
a408 9
 *	----------------
 */
extern char *HTAnchor_physical(HTParentAnchor *me);

extern void HTAnchor_setPhysical(HTParentAnchor *me,
				 char *protocol);

extern LYUCcharset *HTAnchor_getUCInfoStage(HTParentAnchor *me,
					    int which_stage);
d410 35
a444 22
extern int HTAnchor_getUCLYhndl(HTParentAnchor *me,
				int which_stage);

extern LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
					    int LYhndl,
					    int which_stage,
					    int set_by);

extern LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
					    int LYhndl,
					    int which_stage,
					    int set_by);

extern LYUCcharset *HTAnchor_resetUCInfoStage(HTParentAnchor *me,
					      int LYhndl,
					      int which_stage,
					      int set_by);

extern LYUCcharset *HTAnchor_copyUCInfoStage(HTParentAnchor *me,
					     int to_stage,
					     int from_stage,
					     int set_by);
d446 1
a446 1
extern void ImageMapList_free(HTList *list);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a17 1
#include <HTChunk.h>
d69 1
a69 2
  char *	citehost;	/* Citehost from REL="citehost" LINK */
#ifdef USE_COLOR_STYLE
d80 1
a80 5
#ifdef SOURCE_CACHE
  char *	source_cache_file;
  HTChunk *	source_cache_chunk;
#endif
  char *	FileCache;	/* Path to a disk-cached copy (see src/HTFWriter.c) */
a165 9
/*	Create new or find old named anchor - simple form
**	-------------------------------------------------
**
**	Like the previous one, but simpler to use for simple cases.
**	No post data etc. can be supplied. - kw
*/
extern HTAnchor * HTAnchor_findSimpleAddress PARAMS((
	CONST char *	url));

a177 5
#ifdef SOURCE_CACHE
extern void HTAnchor_clearSourceCache PARAMS((
	HTParentAnchor *	me));
#endif

d230 1
a230 1
#if defined(USE_COLOR_STYLE)
a277 9

/*	Citehost for bibp links from LINKs with REL="citehost". - RDC
*/
extern CONST char * HTAnchor_citehost PARAMS((
	HTParentAnchor *	me));

extern void HTAnchor_setCitehost PARAMS((
	HTParentAnchor *	me,
	CONST char *		citehost));
@

