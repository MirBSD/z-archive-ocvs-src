head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.6
	tg-mergefixes-1-branch:1.1.3.6.0.4
	tg-mergefixes-1-base:1.1.3.6
	MIROS_X:1.1.3.6.0.2
	MIROS_X_BASE:1.1.3.6
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.3
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.3
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.3
	cvs-200401261630:1.1.1.3
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.3
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.3
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.3
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.3
	cvs-200309251530:1.1.1.3
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.45.49;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.55.48;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.03;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.07;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.00;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.17.13.42.02;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.45;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.52;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.25;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.05.54;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.15;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.47.22;	author tg;	state Stab;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.20.10.10.33;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@/*			Generic Communication Code		HTTCP.c
 *			==========================
 *
 *	This code is in common between client and server sides.
 *
 *	16 Jan 92  TBL	Fix strtol() undefined on CMU Mach.
 *	25 Jun 92  JFG	Added DECNET option through TCP socket emulation.
 *	13 Sep 93  MD	Added correct return of vmserrorno for HTInetStatus.
 *			Added decoding of vms error message for MULTINET.
 *	7-DEC-1993 Bjorn S. Nilsson, ALEPH, CERN, VMS UCX ioctl() changes
 *			(done of Mosaic)
 *	19 Feb 94  Danny Mayer	Added Bjorn Fixes to Lynx version
 *	 7 Mar 94  Danny Mayer	Added Fix UCX version for full domain name
 *	20 May 94  Andy Harper	Added support for CMU TCP/IP transport
 *	17 Nov 94  Andy Harper	Added support for SOCKETSHR transport
 *	16 Jul 95  S. Bjorndahl added kluge to deal with LIBCMU bug
 */

#include <HTUtils.h>
#include <HTParse.h>
#include <HTAlert.h>
#include <HTTCP.h>
#include <LYGlobalDefs.h>	/* added for no_suspend */
#include <LYUtils.h>

#ifdef NSL_FORK
#include <signal.h>
#include <www_wait.h>
#endif /* NSL_FORK */

#ifdef HAVE_RESOLV_H
#include <resolv.h>
#endif

#ifdef __DJGPP__
#include <netdb.h>
#endif /* __DJGPP__ */

#define LYNX_ADDRINFO	struct addrinfo
#define LYNX_HOSTENT	struct hostent

#define OK_HOST(p) ((p) != 0 && ((p)->h_length) != 0)

#ifdef SVR4_BSDSELECT
int BSDselect(int nfds,
	      fd_set * readfds,
	      fd_set * writefds,
	      fd_set * exceptfds,
	      struct timeval *select_timeout);

#ifdef select
#undef select
#endif /* select */
#define select BSDselect
#ifdef SOCKS
#ifdef Rselect
#undef Rselect
#endif /* Rselect */
#define Rselect BSDselect
#endif /* SOCKS */
#endif /* SVR4_BSDSELECT */

#include <LYLeaks.h>

/*
 *  Module-Wide variables
 */
static char *hostname = NULL;	/* The name of this host */

/*
 *  PUBLIC VARIABLES
 */
#ifdef SOCKS
unsigned long socks_bind_remoteAddr;	/* for long Rbind */
#endif /* SOCKS */

/* PUBLIC SockA HTHostAddress; *//* The internet address of the host */
					/* Valid after call to HTHostName() */

/*	Encode INET status (as in sys/errno.h)			  inet_status()
 *	------------------
 *
 *  On entry,
 *	where		gives a description of what caused the error
 *	global errno	gives the error number in the Unix way.
 *
 *  On return,
 *	returns		a negative status in the Unix way.
 */

#ifdef DECL_SYS_ERRLIST
extern char *sys_errlist[];	/* see man perror on cernvax */
extern int sys_nerr;
#endif /* DECL_SYS_ERRLIST */

#ifdef __DJGPP__
static int ResolveYield(void)
{
    return HTCheckForInterrupt()? 0 : 1;
}
#endif

/*
 * This chunk of code is used in both win32 and cygwin.
 */
#if defined(_WINDOWS_NSL)
static LYNX_HOSTENT *phost;	/* Pointer to host - See netdb.h */
static int donelookup;

static unsigned long __stdcall _fork_func(void *arg)
{
    const char *host = (const char *) arg;

#ifdef SH_EX
    unsigned long addr;

    addr = (unsigned long) inet_addr(host);
    if (addr != INADDR_NONE)
	phost = gethostbyaddr((char *) &addr, sizeof(addr), AF_INET);
    else
	phost = gethostbyname(host);
#else
    phost = gethostbyname(host);
#endif
    donelookup = TRUE;
    return (unsigned long) (phost);
}
#endif /* _WINDOWS_NSL */

#if defined(VMS) && defined(UCX)
/*
 *  A routine to mimic the ioctl function for UCX.
 *  Bjorn S. Nilsson, 25-Nov-1993. Based on an example in the UCX manual.
 */
#include <HTioctl.h>

int HTioctl(int d,
	    int request,
	    int *argp)
{
    int sdc, status;
    unsigned short fun, iosb[4];
    char *p5, *p6;
    struct comm {
	int command;
	char *addr;
    } ioctl_comm;
    struct it2 {
	unsigned short len;
	unsigned short opt;
	struct comm *addr;
    } ioctl_desc;

    if ((sdc = vaxc$get_sdc(d)) == 0) {
	set_errno(EBADF);
	return -1;
    }
    ioctl_desc.opt = UCX$C_IOCTL;
    ioctl_desc.len = sizeof(struct comm);

    ioctl_desc.addr = &ioctl_comm;
    if (request & IOC_OUT) {
	fun = IO$_SENSEMODE;
	p5 = 0;
	p6 = (char *) &ioctl_desc;
    } else {
	fun = IO$_SETMODE;
	p5 = (char *) &ioctl_desc;
	p6 = 0;
    }
    ioctl_comm.command = request;
    ioctl_comm.addr = (char *) argp;
    status = sys$qiow(0, sdc, fun, iosb, 0, 0, 0, 0, 0, 0, p5, p6);
    if (!(status & 01)) {
	set_errno(status);
	return -1;
    }
    if (!(iosb[0] & 01)) {
	set_errno(iosb[0]);
	return -1;
    }
    return 0;
}
#endif /* VMS && UCX */

#define MY_FORMAT "TCP: Error %d in `SOCKET_ERRNO' after call to %s() failed.\n\t%s\n"
	   /* third arg is transport/platform specific */

/*	Report Internet Error
 *	---------------------
 */
int HTInetStatus(const char *where)
{
    int status;
    int saved_errno = errno;

#ifdef VMS
#ifdef MULTINET
    SOCKET_ERRNO = vmserrno;
#endif /* MULTINET */
#endif /* VMS */

#ifdef VM
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    "(Error number not translated)"));	/* What Is the VM equiv? */
#define ER_NO_TRANS_DONE
#endif /* VM */

#ifdef VMS
#ifdef MULTINET
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    vms_errno_string()));
#else
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    ((SOCKET_ERRNO > 0 && SOCKET_ERRNO <= 65) ?
	     strerror(SOCKET_ERRNO) : "(Error number not translated)")));
#endif /* MULTINET */
#define ER_NO_TRANS_DONE
#endif /* VMS */

#ifdef HAVE_STRERROR
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    strerror(SOCKET_ERRNO)));
#define ER_NO_TRANS_DONE
#endif /* HAVE_STRERROR */

#ifndef ER_NO_TRANS_DONE
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    (SOCKET_ERRNO < sys_nerr ?
	     sys_errlist[SOCKET_ERRNO] : "Unknown error")));
#endif /* !ER_NO_TRANS_DONE */

#ifdef VMS
#ifndef MULTINET
    CTRACE((tfp,
	    "         Unix error number (SOCKET_ERRNO) = %ld dec\n",
	    SOCKET_ERRNO));
    CTRACE((tfp,
	    "         VMS error (vaxc$errno)    = %lx hex\n",
	    vaxc$errno));
#endif /* MULTINET */
#endif /* VMS */

    set_errno(saved_errno);

#ifdef VMS
    /*
     * uerrno and errno happen to be zero if vmserrno <> 0
     */
#ifdef MULTINET
    status = -vmserrno;
#else
    status = -vaxc$errno;
#endif /* MULTINET */
#else
    status = -SOCKET_ERRNO;
#endif /* VMS */
    return status;
}

/*	Parse a cardinal value				       parse_cardinal()
 *	----------------------
 *
 * On entry,
 *	*pp	    points to first character to be interpreted, terminated by
 *		    non 0:9 character.
 *	*pstatus    points to status already valid
 *	maxvalue    gives the largest allowable value.
 *
 * On exit,
 *	*pp	    points to first unread character
 *	*pstatus    points to status updated iff bad
 */
unsigned int HTCardinal(int *pstatus,
			char **pp,
			unsigned int max_value)
{
    unsigned int n;

    if ((**pp < '0') || (**pp > '9')) {		/* Null string is error */
	*pstatus = -3;		/* No number where one expected */
	return 0;
    }

    n = 0;
    while ((**pp >= '0') && (**pp <= '9'))
	n = n * 10 + *((*pp)++) - '0';

    if (n > max_value) {
	*pstatus = -4;		/* Cardinal outside range */
	return 0;
    }

    return n;
}

#ifndef DECNET			/* Function only used below for a trace message */
/*	Produce a string for an Internet address
 *	----------------------------------------
 *
 *  On exit,
 *	returns a pointer to a static string which must be copied if
 *		it is to be kept.
 */
const char *HTInetString(SockA * soc_in)
{
#ifdef INET6
    static char hostbuf[MAXHOSTNAMELEN];

    getnameinfo((struct sockaddr *) soc_in,
		SOCKADDR_LEN(soc_in),
		hostbuf, sizeof(hostbuf), NULL, 0, NI_NUMERICHOST);
    return hostbuf;
#else
    static char string[20];

    sprintf(string, "%d.%d.%d.%d",
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 0),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 1),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 2),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 3));
    return string;
#endif /* INET6 */
}
#endif /* !DECNET */

/*	Check whether string is a valid Internet hostname - kw
 *	-------------------------------------------------
 *
 *  Checks whether
 *  - contains only valid chars for domain names (actually, the
 *    restrictions are somewhat relaxed),
 *  - no leading dots or empty segments,
 *  - no segment starts with '-' or '+' [this protects telnet command],
 *  - max. length of dot-separated segment <= 63 (RFC 1034,1035),
 *  - total length <= 254 (if it ends with dot) or 253 (otherwise)
 *     [an interpretation of RFC 1034,1035, although RFC 1123
 *      suggests 255 as limit - kw].
 *
 *  Note: user (before '@@') and port (after ':') components from
 *      host part of URL should be already stripped (if appropriate)
 *      from the input string.
 *
 *  On exit,
 *	returns 1 if valid, otherwise 0.
 */
BOOL valid_hostname(char *name)
{
    int i = 1, iseg = 0;
    char *cp = name;

    if (!(name && *name))
	return NO;
    for (; (*cp && i <= 253); cp++, i++) {
	if (*cp == '.') {
	    if (iseg == 0) {
		return NO;
	    } else {
		iseg = 0;
		continue;
	    }
	} else if (iseg == 0 && (*cp == '-' || *cp == '+')) {
	    return NO;
	} else if (++iseg > 63) {
	    return NO;
	}
	if (!isalnum(UCH(*cp)) &&
	    *cp != '-' && *cp != '_' &&
	    *cp != '$' && *cp != '+') {
	    return NO;
	}
    }
    return (BOOL) (*cp == '\0' || (*cp == '.' && iseg != 0 && cp[1] == '\0'));
}

#ifdef NSL_FORK
/*
 *  Function to allow us to be killed with a normal signal (not
 *  SIGKILL), but don't go through normal libc exit() processing, which
 *  would screw up parent's stdio.  -BL
 */
static void quench(int sig GCC_UNUSED)
{
    _exit(2);
}
#endif /* NSL_FORK */

int lynx_nsl_status = HT_OK;

#define DEBUG_HOSTENT		/* disable in case of problems */
#define DEBUG_HOSTENT_CHILD	/* for NSL_FORK, may screw up trace file */

/*
 *  Two auxiliary functions for name lookup and LYNX_HOSTENT.
 *
 *  dump_hostent - dumps the contents of a LYNX_HOSTENT to the
 *  trace log or stderr, including all pointer values, strings, and
 *  addresses, in a format inspired by gdb's print format. - kw
 */
static void dump_hostent(const char *msgprefix,
			 const LYNX_HOSTENT *phost)
{
    if (TRACE) {
	int i;
	char **pcnt;

	CTRACE((tfp, "%s: %p ", msgprefix, phost));
	if (phost) {
	    CTRACE((tfp, "{ h_name = %p", phost->h_name));
	    if (phost->h_name) {
		CTRACE((tfp, " \"%s\",", phost->h_name));
	    } else {
		CTRACE((tfp, ","));
	    }
	    CTRACE((tfp, "\n\t h_aliases = %p", phost->h_aliases));
	    if (phost->h_aliases) {
		CTRACE((tfp, " {"));
		for (pcnt = phost->h_aliases; *pcnt; pcnt++) {
		    CTRACE((tfp, "%s %p \"%s\"",
			    (pcnt == phost->h_aliases ? " " : ", "),
			    *pcnt, *pcnt));
		}
		CTRACE((tfp, "%s0x0 },\n\t",
			(*phost->h_aliases ? ", " : " ")));
	    } else {
		CTRACE((tfp, ",\n\t"));
	    }
	    CTRACE((tfp, " h_addrtype = %d,", phost->h_addrtype));
	    CTRACE((tfp, " h_length = %d,\n\t", phost->h_length));
	    CTRACE((tfp, " h_addr_list = %p", phost->h_addr_list));
	    if (phost->h_addr_list) {
		CTRACE((tfp, " {"));
		for (pcnt = phost->h_addr_list; *pcnt; pcnt++) {
		    CTRACE((tfp, "%s %p",
			    (pcnt == phost->h_addr_list ? "" : ","),
			    *pcnt));
		    for (i = 0; i < phost->h_length; i++) {
			CTRACE((tfp, "%s%d%s", (i == 0 ? " \"" : "."),
				(int) *((unsigned char *) (*pcnt) + i),
				(i + 1 == phost->h_length ? "\"" : "")));
		    }
		}
		if (*phost->h_addr_list) {
		    CTRACE((tfp, ", 0x0 } }"));
		} else {
		    CTRACE((tfp, " 0x0 } }"));
		}
	    } else {
		CTRACE((tfp, "}"));
	    }
	}
	CTRACE((tfp, "\n"));
	fflush(tfp);
    }
}

/*
 *  fill_rehostent - copies as much as possible relevant content from
 *  the LYNX_HOSTENT pointed to by phost to the char buffer given
 *  by rehostent, subject to maximum output length rehostentsize,
 *  following pointers and building self-contained output which can be
 *  cast to a LYNX_HOSTENT. - kw
 *  See also description of LYGetHostByName.
 */
#ifdef NSL_FORK

#define REHOSTENT_SIZE 128	/* not bigger than pipe buffer! */

typedef struct {
    LYNX_HOSTENT h;
    char rest[REHOSTENT_SIZE];
} AlignedHOSTENT;

static size_t fill_rehostent(char *rehostent,
			     size_t rehostentsize,
			     const LYNX_HOSTENT *phost)
{
    AlignedHOSTENT *data = (AlignedHOSTENT *) rehostent;
    int num_addrs = 0;
    int num_aliases = 0;
    char **pcnt;
    char *p_next_char;
    char **p_next_charptr;
    size_t name_len = 0;
    size_t required_per_addr;
    size_t curlen = sizeof(LYNX_HOSTENT);
    size_t available = rehostentsize - curlen;
    size_t chk_available, mem_this_alias, required_this_alias;
    int i_addr, i_alias;

    if (!phost)
	return 0;
    required_per_addr = phost->h_length + sizeof(char *);

    if (phost->h_addr_list)
	available -= sizeof(phost->h_addr_list[0]);
    if (phost->h_aliases)
	available -= sizeof(phost->h_aliases[0]);
    if (phost->h_name)
	available--;
    if (phost->h_addr_list) {
	if (phost->h_addr_list[0]) {
	    if (available >= required_per_addr) {
		num_addrs++;
		available -= required_per_addr;
	    }
	}
    }
    if (phost->h_name) {
	name_len = strlen(phost->h_name);
	if (available >= name_len) {
	    available -= name_len;
	} else {
	    name_len = 0;
	}
    }
    if (num_addrs) {
	for (pcnt = phost->h_addr_list + 1; *pcnt; pcnt++) {
	    if (available >= required_per_addr) {
		num_addrs++;
		available -= required_per_addr;
	    } else {
		break;
	    }
	}
    }
    chk_available = available;
    if (phost->h_aliases) {
	for (pcnt = phost->h_aliases; *pcnt; pcnt++) {
	    required_this_alias = sizeof(phost->h_aliases[0]) +
		strlen(*pcnt) + 1;
	    if (chk_available >= required_this_alias) {
		num_aliases++;
		chk_available -= required_this_alias;
	    }
	}
    }

    data->h.h_addrtype = phost->h_addrtype;
    data->h.h_length = phost->h_length;
    p_next_charptr = (char **) (rehostent + curlen);
    p_next_char = rehostent + curlen;
    if (phost->h_addr_list)
	p_next_char += (num_addrs + 1) * sizeof(phost->h_addr_list[0]);
    if (phost->h_aliases)
	p_next_char += (num_aliases + 1) * sizeof(phost->h_aliases[0]);

    if (phost->h_addr_list) {
	data->h.h_addr_list = p_next_charptr;
	for (pcnt = phost->h_addr_list, i_addr = 0;
	     i_addr < num_addrs;
	     pcnt++, i_addr++) {
	    memcpy(p_next_char, *pcnt, sizeof(phost->h_addr_list[0]));
	    *p_next_charptr++ = p_next_char;
	    p_next_char += sizeof(phost->h_addr_list[0]);
	}
	*p_next_charptr++ = NULL;
    } else {
	data->h.h_addr_list = NULL;
    }

    if (phost->h_name) {
	data->h.h_name = p_next_char;
	if (name_len) {
	    strcpy(p_next_char, phost->h_name);
	    p_next_char += name_len + 1;
	} else {
	    *p_next_char++ = '\0';
	}
    } else {
	data->h.h_name = NULL;
    }

    if (phost->h_aliases) {
	data->h.h_aliases = p_next_charptr;
	for (pcnt = phost->h_aliases, i_alias = 0;
	     (*pcnt && i_alias < num_addrs);
	     pcnt++, i_alias++) {
	    mem_this_alias = strlen(*pcnt) + 1;
	    required_this_alias = sizeof(phost->h_aliases[0]) +
		mem_this_alias;
	    if (available >= required_this_alias) {
		i_alias++;
		available -= required_this_alias;
		strcpy(p_next_char, *pcnt);
		*p_next_charptr++ = p_next_char;
		p_next_char += mem_this_alias;
	    }
	    p_next_char += sizeof(phost->h_aliases[0]);
	}
	*p_next_charptr++ = NULL;
    } else {
	data->h.h_aliases = NULL;
    }
    curlen = p_next_char - (char *) rehostent;
    return curlen;
}
#endif /* NSL_FORK */

#ifndef HAVE_H_ERRNO
#undef  h_errno
#define h_errno my_errno
static int my_errno;

#else /* we do HAVE_H_ERRNO: */
#ifndef h_errno			/* there may be a macro as well as the extern data */
extern int h_errno;
#endif
#endif

/*	Resolve an internet hostname, like gethostbyname
 *	------------------------------------------------
 *
 *  On entry,
 *	str	points to the given host name, not numeric address,
 *		without colon or port number.
 *
 *  On exit,
 *	returns a pointer to a LYNX_HOSTENT in static storage,
 *	or NULL in case of error or user interruption.
 *
 *  The interface is intended to be exactly the same as for (Unix)
 *  gethostbyname(), except for the following:
 *
 *  If NSL_FORK is not used, the result of gethostbyname is returned
 *  directly.  Otherwise:
 *  All lists, addresses, and strings referred to by pointers in the
 *  returned struct are located, together with the returned struct
 *  itself, in a buffer of size REHOSTENT_SIZE.  If not everything fits,
 *  some info is omitted, but the function is careful to still return
 *  a valid structure, without truncating strings; it tries to return,
 *  in order of decreasing priority, the first address (h_addr), the
 *  official name (h_name), the additional addresses, then alias names.
 *
 *  If NULL is returned, the reason is made available in the global
 *  variable lynx_nsl_status, with one of the following values:
 *	HT_INTERRUPTED		Interrupted by user
 *	HT_NOT_ACCEPTABLE	Hostname detected as invalid
 *				(also sets h_errno)
 *	HT_H_ERRNO_VALID	An error occurred, and h_errno holds
 *				an appropriate value
 *	HT_ERROR		Resolver error, reason not known
 *	HT_INTERNAL		Internal error
 */
LYNX_HOSTENT *LYGetHostByName(char *str)
{
    char *host = str;

#ifdef NSL_FORK
    /* for transfer of result between from child to parent: */
    static AlignedHOSTENT aligned_full_rehostent;

    /*
     * We could define rehosten directly as a static char
     * rehostent[REHOSTENT_SIZE], but the indirect approach via the above
     * struct should automatically take care of alignment requirements.
     * Note that, in addition,
     * - this must be static, as we shall return a pointer to it which must
     *   remain valid, and
     * - we have to use the same rehostent in the child process as in the
     *   parent (its address in the parent's address space must be the same as
     *   in the child's, otherwise the internal pointers built by the child's
     *   call to fill_rehostent would be invalid when seen by the parent).  -kw
     */
    char *rehostent = (char *) &aligned_full_rehostent;

    /* for transfer of status from child to parent: */
    struct _statuses {
	size_t rehostentlen;
	int h_length;
	int child_errno;	/* sometimes useful to pass this on */
	int child_h_errno;
	BOOL h_errno_valid;
    } statuses;

    size_t rehostentlen = 0;
#endif /* NSL_FORK */

    LYNX_HOSTENT *result_phost = NULL;

#ifdef __DJGPP__
    _resolve_hook = ResolveYield;
#endif

    if (!str) {
	CTRACE((tfp, "LYGetHostByName: Can't parse `NULL'.\n"));
	lynx_nsl_status = HT_INTERNAL;
	return NULL;
    }
    CTRACE((tfp, "LYGetHostByName: parsing `%s'.\n", str));

    /*  Could disable this if all our callers already check - kw */
    if (HTCheckForInterrupt()) {
	CTRACE((tfp, "LYGetHostByName: INTERRUPTED for '%s'.\n", str));
	lynx_nsl_status = HT_INTERRUPTED;
	return NULL;
    }

    if (!valid_hostname(host)) {
	lynx_nsl_status = HT_NOT_ACCEPTABLE;
#ifdef NO_RECOVERY
#ifdef _WINDOWS
	WSASetLastError(NO_RECOVERY);
#else
	h_errno = NO_RECOVERY;
#endif
#endif
	return NULL;
    }
#ifdef MVS			/* Outstanding problem with crash in MVS gethostbyname */
    CTRACE((tfp, "LYGetHostByName: Calling gethostbyname(%s)\n", host));
#endif /* MVS */

    CTRACE_FLUSH(tfp);		/* so child messages will not mess up parent log */

    lynx_nsl_status = HT_INTERNAL;	/* should be set to something else below */

#ifdef NSL_FORK
    statuses.h_errno_valid = NO;
    /*
     * Start block for fork-based gethostbyname() with checks for interrupts. 
     * - Tom Zerucha (tz@@execpc.com) & FM
     */
    {
	int got_rehostent = 0;

#if HAVE_SIGACTION
	sigset_t old_sigset;
	sigset_t new_sigset;
#endif
	/*
	 * Pipe, child pid, status buffers, start time, select() control
	 * variables.
	 */
	int fpid, waitret;
	int pfd[2], selret, readret;

#ifdef HAVE_TYPE_UNIONWAIT
	union wait waitstat;

#else
	int waitstat = 0;
#endif
	time_t start_time = time((time_t *) 0);
	fd_set readfds;
	struct timeval one_second;
	long dns_patience = 30;	/* how many seconds will we wait for DNS? */
	int child_exited = 0;

	/*
	 * Reap any children that have terminated since last time through. 
	 * This might include children that we killed, then waited with WNOHANG
	 * before they were actually ready to be reaped.  (Should be max of 1
	 * in this state, but the loop is safe if waitpid() is implemented
	 * correctly:  returns 0 when children exist but none have exited; -1
	 * with errno == ECHILD when no children.) -BL
	 */
	do {
	    waitret = waitpid(-1, 0, WNOHANG);
	} while (waitret > 0 || (waitret == -1 && errno == EINTR));
	waitret = 0;

	pipe(pfd);

#if HAVE_SIGACTION
	/*
	 * Attempt to prevent a rare situation where the child could execute
	 * the Lynx signal handlers because it gets killed before it even has a
	 * chance to reset its handlers, resulting in bogus 'Exiting via
	 * interrupt' message and screen corruption or worse.
	 * Should that continue to be reported, for systems without
	 * sigprocmask(), we need to find a different solutions for those.  -
	 * kw 19990430
	 */
	sigemptyset(&new_sigset);
	sigaddset(&new_sigset, SIGTERM);
	sigaddset(&new_sigset, SIGINT);
#ifndef NOSIGHUP
	sigaddset(&new_sigset, SIGHUP);
#endif /* NOSIGHUP */
#ifdef SIGTSTP
	sigaddset(&new_sigset, SIGTSTP);
#endif /* SIGTSTP */
#ifdef SIGWINCH
	sigaddset(&new_sigset, SIGWINCH);
#endif /* SIGWINCH */
	sigprocmask(SIG_BLOCK, &new_sigset, &old_sigset);
#endif /* HAVE_SIGACTION */

	if ((fpid = fork()) == 0) {
	    LYNX_HOSTENT *phost;	/* Pointer to host - See netdb.h */

	    /*
	     * Child - for the long call.
	     *
	     * Make sure parent can kill us at will.  -BL
	     */
	    (void) signal(SIGTERM, quench);

	    /*
	     * Also make sure the child does not run one of the signal handlers
	     * that may have been installed by Lynx if one of those signals
	     * occurs.  For example we don't want the child to remove temp
	     * files on ^C, let the parent deal with that.  - kw
	     */
	    (void) signal(SIGINT, quench);
#ifndef NOSIGHUP
	    (void) signal(SIGHUP, quench);
#endif /* NOSIGHUP */
#ifdef SIGTSTP
	    if (no_suspend)
		(void) signal(SIGTSTP, SIG_IGN);
	    else
		(void) signal(SIGTSTP, SIG_DFL);
#endif /* SIGTSTP */
#ifdef SIGWINCH
	    (void) signal(SIGWINCH, SIG_IGN);
#endif /* SIGWINCH */
#ifndef __linux__
#ifndef DOSPATH
	    signal(SIGBUS, SIG_DFL);
#endif /* DOSPATH */
#endif /* !__linux__ */
	    signal(SIGSEGV, SIG_DFL);
	    signal(SIGILL, SIG_DFL);

#if HAVE_SIGACTION
	    /* Restore signal mask to whatever it was before the fork. -kw */
	    sigprocmask(SIG_SETMASK, &old_sigset, NULL);
#endif /* HAVE_SIGACTION */

	    /*
	     * Child won't use read side.  -BL
	     */
	    close(pfd[0]);
#ifdef HAVE_H_ERRNO
	    /* to detect cases when it doesn't get set although it should */
	    h_errno = -2;
#endif
	    set_errno(0);
	    phost = gethostbyname(host);
	    statuses.child_errno = errno;
	    statuses.child_h_errno = h_errno;
#ifdef HAVE_H_ERRNO
	    statuses.h_errno_valid = YES;
#endif
#ifdef MVS
	    CTRACE((tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost));
#endif /* MVS */

#ifdef DEBUG_HOSTENT_CHILD
	    dump_hostent("CHILD gethostbyname", phost);
#endif
	    if (OK_HOST(phost)) {
		rehostentlen = fill_rehostent(rehostent, REHOSTENT_SIZE, phost);
#ifdef DEBUG_HOSTENT_CHILD
		dump_hostent("CHILD fill_rehostent", (LYNX_HOSTENT *) rehostent);
#endif
	    }
	    if (rehostentlen <= sizeof(LYNX_HOSTENT) ||
		!OK_HOST((LYNX_HOSTENT *) rehostent)) {
		rehostentlen = 0;
		statuses.h_length = 0;
	    } else {
		statuses.h_length = ((LYNX_HOSTENT *) rehostent)->h_length;
#ifdef HAVE_H_ERRNO
		if (h_errno == -2)	/* success, but h_errno unchanged? */
		    statuses.h_errno_valid = NO;
#endif
	    }
	    /*
	     * Send variables indicating status of lookup to parent.  That
	     * includes rehostentlen, which the parent will use as the size for
	     * the second read (if > 0).
	     */
	    if (!statuses.child_errno)
		statuses.child_errno = errno;
	    statuses.rehostentlen = rehostentlen;
	    write(pfd[1], &statuses, sizeof(statuses));

	    if (rehostentlen) {
		/*
		 * Return our resulting rehostent through pipe...
		 */
		write(pfd[1], rehostent, rehostentlen);
		_exit(0);
	    } else {
		/*
		 * ...  or return error as exit code.
		 */
		_exit(1);
	    }
	}
#if HAVE_SIGACTION
	/*
	 * (parent) Restore signal mask to whatever it was before the fork.  -
	 * kw
	 */
	sigprocmask(SIG_SETMASK, &old_sigset, NULL);
#endif /* HAVE_SIGACTION */

	/*
	 * (parent) Wait until lookup finishes, or interrupt, or cycled too
	 * many times (just in case) -BL
	 */

	close(pfd[1]);		/* parent won't use write side -BL */

	if (fpid < 0) {		/* fork failed */
	    close(pfd[0]);
	    goto failed;
	}

	while (child_exited || (long) (time((time_t *) 0) - start_time) < dns_patience) {

	    FD_ZERO(&readfds);
	    /*
	     * This allows us to abort immediately, not after 1-second timeout,
	     * when user hits abort key.  Can't do this when using SLANG (or at
	     * least I don't know how), so SLANG users must live with up-to-1s
	     * timeout.  -BL
	     *
	     * Whoops -- we need to make sure stdin is actually selectable! 
	     * /dev/null isn't, on some systems, which makes some useful Lynx
	     * invocations fail.  -BL
	     */
	    {
		int kbd_fd = LYConsoleInputFD(TRUE);

		if (kbd_fd != INVSOC) {
		    FD_SET(kbd_fd, &readfds);
		}
	    }

	    one_second.tv_sec = 1;
	    one_second.tv_usec = 0;
	    FD_SET(pfd[0], &readfds);

	    /*
	     * Return when data received, interrupted, or failed.  If nothing
	     * is waiting, we sleep for 1 second in select(), to be nice to the
	     * system.  -BL
	     */
#ifdef SOCKS
	    if (socks_flag)
		selret = Rselect(pfd[0] + 1, &readfds, NULL, NULL, &one_second);
	    else
#endif /* SOCKS */
		selret = select(pfd[0] + 1, &readfds, NULL, NULL, &one_second);

	    if ((selret > 0) && FD_ISSET(pfd[0], &readfds)) {
		/*
		 * First get status, including length of address.  -BL, kw
		 */
		readret = read(pfd[0], &statuses, sizeof(statuses));
		if (readret == sizeof(statuses)) {
		    h_errno = statuses.child_h_errno;
		    set_errno(statuses.child_errno);
#ifdef HAVE_H_ERRNO
		    if (statuses.h_errno_valid) {
			lynx_nsl_status = HT_H_ERRNO_VALID;
			/*
			 * If something went wrong in the child process other
			 * than normal lookup errors, and it appears that we
			 * have enough info to know what went wrong, generate
			 * diagnostic output.  ENOMEM observed on linux in
			 * processes constrained with ulimit.  It would be too
			 * unkind to abort the session, access to local files
			 * or through a proxy may still work.  - kw
			 */
			if (
#ifdef NETDB_INTERNAL		/* linux glibc: defined in netdb.h */
			       (errno && h_errno == NETDB_INTERNAL) ||
#endif
			       (errno == ENOMEM &&
				statuses.rehostentlen == 0 &&
			/* should probably be NETDB_INTERNAL if child
			   memory exhausted, but we may find that
			   h_errno remains unchanged. - kw */
				h_errno == -2)) {
#ifndef MULTINET
			    HTInetStatus("CHILD gethostbyname");
#endif
			    HTAlert(LYStrerror(statuses.child_errno));
			    if (errno == ENOMEM) {
				/*
				 * Not much point in continuing, right?  Fake a
				 * 'z', should shorten pointless guessing
				 * cycle.  - kw
				 */
				LYFakeZap(YES);
			    }
			}
		    }
#endif /* HAVE_H_ERRNO */
		    if (statuses.rehostentlen > sizeof(LYNX_HOSTENT)) {
			/*
			 * Then get the full reorganized hostent.  -BL, kw
			 */
			readret = read(pfd[0], rehostent, statuses.rehostentlen);
#ifdef DEBUG_HOSTENT
			dump_hostent("Read from pipe", (LYNX_HOSTENT *) rehostent);
#endif
			if (readret == (int) statuses.rehostentlen) {
			    got_rehostent = 1;
			    result_phost = (LYNX_HOSTENT *) rehostent;
			    lynx_nsl_status = HT_OK;
			} else if (!statuses.h_errno_valid) {
			    lynx_nsl_status = HT_INTERNAL;
			}
		    }
		} else {
		    lynx_nsl_status = HT_ERROR;
		}
		/*
		 * Make sure child is cleaned up.  -BL
		 */
		if (!child_exited)
		    waitret = waitpid(fpid, &waitstat, WNOHANG);
		if (!WIFEXITED(waitstat) && !WIFSIGNALED(waitstat)) {
		    kill(fpid, SIGTERM);
		    waitret = waitpid(fpid, &waitstat, WNOHANG);
		}
		break;
	    }

	    /*
	     * Clean up if child exited before & no data received.  -BL
	     */
	    if (child_exited) {
		waitret = waitpid(fpid, &waitstat, WNOHANG);
		break;
	    }
	    /*
	     * If child exited, loop once more looking for data.  -BL
	     */
	    if ((waitret = waitpid(fpid, &waitstat, WNOHANG)) > 0) {
		/*
		 * Data will be arriving right now, so make sure we don't
		 * short-circuit out for too many loops, and skip the interrupt
		 * check.  -BL
		 */
		child_exited = 1;
		continue;
	    }

	    /*
	     * Abort if interrupt key pressed.
	     */
	    if (HTCheckForInterrupt()) {
		CTRACE((tfp, "LYGetHostByName: INTERRUPTED gethostbyname.\n"));
		kill(fpid, SIGTERM);
		waitpid(fpid, NULL, WNOHANG);
		close(pfd[0]);
		lynx_nsl_status = HT_INTERRUPTED;
		return NULL;
	    }
	}
	close(pfd[0]);
	if (waitret <= 0) {
	    kill(fpid, SIGTERM);
	    waitret = waitpid(fpid, &waitstat, WNOHANG);
	}
	if (waitret > 0) {
	    if (WIFEXITED(waitstat)) {
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",
			(int) waitret, WEXITSTATUS(waitstat)));
	    } else if (WIFSIGNALED(waitstat)) {
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
			(int) waitret, WTERMSIG(waitstat)));
#ifdef WCOREDUMP
		if (WCOREDUMP(waitstat)) {
		    CTRACE((tfp,
			    "LYGetHostByName: NSL_FORK child %d dumped core!\n",
			    (int) waitret));
		}
#endif /* WCOREDUMP */
	    } else if (WIFSTOPPED(waitstat)) {
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
			(int) waitret, WSTOPSIG(waitstat)));
	    }
	}
	if (!got_rehostent) {
	    goto failed;
	}
    }
#else /* Not NSL_FORK: */

#ifdef _WINDOWS_NSL
    {
	HANDLE hThread, dwThreadID;

#ifndef __CYGWIN__
	if (!system_is_NT) {	/* for Windows9x */
	    unsigned long t;

	    t = (unsigned long) inet_addr(host);
	    if (t != INADDR_NONE)
		phost = gethostbyaddr((char *) &t, sizeof(t), AF_INET);
	    else
		phost = gethostbyname(host);
	} else {		/* for Windows NT */
#endif /* !__CYGWIN__ */
	    phost = (LYNX_HOSTENT *) NULL;
	    donelookup = FALSE;
	    WSASetLastError(WSAHOST_NOT_FOUND);

	    hThread = CreateThread(NULL, 4096UL, _fork_func, host, 0UL,
				   (unsigned long *) &dwThreadID);
	    if (!hThread)
		MessageBox(NULL, "CreateThread",
			   "CreateThread Failed", 0L);

	    while (!donelookup) {
		if (HTCheckForInterrupt()) {
		    /* Note that host is a character array and is not freed */
		    /* to avoid possible subthread problems: */
		    if (!CloseHandle(hThread)) {
			MessageBox((void *) NULL,
				   "CloseHandle", "CloseHandle Failed", 0L);
		    }
		    lynx_nsl_status = HT_INTERRUPTED;
		    return NULL;
		}
	    }
#ifndef __CYGWIN__
	}
#endif /* !__CYGWIN__ */
	if (phost) {
	    lynx_nsl_status = HT_OK;
	    result_phost = phost;
	} else {
	    lynx_nsl_status = HT_ERROR;
	    goto failed;
	}
    }

#else /* !NSL_FORK, !_WINDOWS_NSL: */
    {
	LYNX_HOSTENT *phost;

	phost = gethostbyname(host);	/* See netdb.h */
#ifdef MVS
	CTRACE((tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost));
#endif /* MVS */
	if (phost) {
	    lynx_nsl_status = HT_OK;
	    result_phost = phost;
	} else {
	    lynx_nsl_status = HT_H_ERRNO_VALID;
	    goto failed;
	}
    }
#endif /* !NSL_FORK, !_WINDOWS_NSL */
#endif /* !NSL_FORK */

#ifdef DEBUG_HOSTENT
    dump_hostent("End of LYGetHostByName", result_phost);
    CTRACE((tfp, "LYGetHostByName: Resolved name to a hostent.\n"));
#endif

    return result_phost;	/* OK */

  failed:
    CTRACE((tfp, "LYGetHostByName: Can't find internet node name `%s'.\n",
	    host));
    return NULL;
}

/*	Parse a network node address and port
 *	-------------------------------------
 *
 *  On entry,
 *	str	points to a string with a node name or number,
 *		with optional trailing colon and port number.
 *	soc_in	points to the binary internet or decnet address field.
 *
 *  On exit,
 *	*soc_in is filled in.  If no port is specified in str, that
 *		field is left unchanged in *soc_in.
 */
#ifndef INET6
static int HTParseInet(SockA * soc_in, const char *str)
{
    char *port;
    int dotcount_ip = 0;	/* for dotted decimal IP addr */
    char *strptr;
    char *host = NULL;

    if (!str) {
	CTRACE((tfp, "HTParseInet: Can't parse `NULL'.\n"));
	return -1;
    }
    CTRACE((tfp, "HTParseInet: parsing `%s'.\n", str));
    if (HTCheckForInterrupt()) {
	CTRACE((tfp, "HTParseInet: INTERRUPTED for '%s'.\n", str));
	return -1;
    }
    StrAllocCopy(host, str);	/* Make a copy we can mutilate */
    /*
     * Parse port number if present.
     */
    if ((port = strchr(host, ':')) != NULL) {
	*port++ = 0;		/* Chop off port */
	strptr = port;
	if (port[0] >= '0' && port[0] <= '9') {
#ifdef UNIX
	    soc_in->sin_port = (PortNumber) htons(strtol(port, &strptr, 10));
#else /* VMS: */
#ifdef DECNET
	    soc_in->sdn_objnum = (unsigned char) (strtol(port, &strptr, 10));
#else
	    soc_in->sin_port = htons((PortNumber) strtol(port, &strptr, 10));
#endif /* Decnet */
#endif /* Unix vs. VMS */
#ifdef SUPPRESS			/* 1. crashes!?!.  2. URL syntax has number not name */
	} else {
	    struct servent *serv = getservbyname(port, (char *) 0);

	    if (serv) {
		soc_in->sin_port = serv->s_port;
	    } else {
		CTRACE((tfp, "TCP: Unknown service %s\n", port));
	    }
#endif /* SUPPRESS */
	}
	if (strptr && *strptr != '\0') {
	    FREE(host);
	    HTAlwaysAlert(NULL, gettext("Address has invalid port"));
	    return -1;
	}
    }
#ifdef DECNET
    /*
     * Read Decnet node name.  @@@@ Should know about DECnet addresses, but it's
     * probably worth waiting until the Phase transition from IV to V.
     */
    soc_in->sdn_nam.n_len = min(DN_MAXNAML, strlen(host));	/* <=6 in phase 4 */
    strncpy(soc_in->sdn_nam.n_name, host, soc_in->sdn_nam.n_len + 1);
    CTRACE((tfp,
	    "DECnet: Parsed address as object number %d on host %.6s...\n",
	    soc_in->sdn_objnum, host));
#else /* parse Internet host: */

    if (*host >= '0' && *host <= '9') {		/* Test for numeric node address: */
	strptr = host;
	while (*strptr) {
	    if (*strptr == '.') {
		dotcount_ip++;
	    } else if (!isdigit(UCH(*strptr))) {
		break;
	    }
	    strptr++;
	}
	if (*strptr) {		/* found non-numeric, assume domain name */
	    dotcount_ip = 0;
	}
    }

    /*
     * Parse host number if present.
     */
    if (dotcount_ip == 3)	/* Numeric node address: */
    {
#ifdef DGUX_OLD
	soc_in->sin_addr.s_addr = inet_addr(host).s_addr;	/* See arpa/inet.h */
#else
#ifdef GUSI
	soc_in->sin_addr = inet_addr(host);	/* See netinet/in.h */
#else
#ifdef HAVE_INET_ATON
	if (!inet_aton(host, &(soc_in->sin_addr))) {
	    CTRACE((tfp, "inet_aton(%s) returns error\n", host));
	    FREE(host);
	    return -1;
	}
#else
	soc_in->sin_addr.s_addr = inet_addr(host);	/* See arpa/inet.h */
#endif /* HAVE_INET_ATON */
#endif /* GUSI */
#endif /* DGUX_OLD */
	FREE(host);
    } else {			/* Alphanumeric node name: */

#ifdef MVS			/* Outstanding problem with crash in MVS gethostbyname */
	CTRACE((tfp, "HTParseInet: Calling LYGetHostByName(%s)\n", host));
#endif /* MVS */

#ifdef _WINDOWS_NSL
	phost = LYGetHostByName(host);	/* See above */
	if (!phost)
	    goto failed;
	memcpy((void *) &soc_in->sin_addr, phost->h_addr, phost->h_length);
#else /* !_WINDOWS_NSL */
	{
	    LYNX_HOSTENT *phost;

	    phost = LYGetHostByName(host);	/* See above */

	    if (!phost)
		goto failed;
#if defined(VMS) && defined(CMU_TCP)
	    /*
	     * In LIBCMU, phost->h_length contains not the length of one
	     * address (four bytes) but the number of bytes in *h_addr, i.e.,
	     * some multiple of four.  Thus we need to hard code the value
	     * here, and remember to change it if/when IP addresses change in
	     * size.  :-( LIBCMU is no longer supported, and CMU users are
	     * encouraged to obtain and use SOCKETSHR/NETLIB instead.  - S. 
	     * Bjorndahl
	     */
	    memcpy((void *) &soc_in->sin_addr, phost->h_addr, 4);
#else
	    if (!phost)
		goto failed;
	    if (phost->h_length != sizeof soc_in->sin_addr) {
		HTAlwaysAlert(host, gettext("Address length looks invalid"));
	    }
	    memcpy((void *) &soc_in->sin_addr, phost->h_addr, phost->h_length);
#endif /* VMS && CMU_TCP */
	}
#endif /* _WINDOWS_NSL */

	FREE(host);
    }				/* Alphanumeric node name */

    CTRACE((tfp,
	    "HTParseInet: Parsed address as port %d, IP address %d.%d.%d.%d\n",
	    (int) ntohs(soc_in->sin_port),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 0),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 1),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 2),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 3)));
#endif /* Internet vs. Decnet */

    return 0;			/* OK */

  failed:
    CTRACE((tfp, "HTParseInet: Can't find internet node name `%s'.\n",
	    host));
    FREE(host);
    switch (lynx_nsl_status) {
    case HT_NOT_ACCEPTABLE:
    case HT_INTERRUPTED:
	return lynx_nsl_status;
    default:
	return -1;
    }
}
#endif /* !INET6 */

#ifdef INET6
static LYNX_ADDRINFO *HTGetAddrInfo(const char *str,
				    const int defport)
{
    LYNX_ADDRINFO hints, *res;
    int error;
    char *p;
    char *s = NULL;
    char *host, *port;
    char pbuf[80];

    StrAllocCopy(s, str);

    if (s[0] == '[' && (p = strchr(s, ']')) != NULL) {
	*p++ = '\0';
	host = s + 1;
    } else {
	p = s;
	host = &s[0];
    }
    port = strrchr(p, ':');
    if (port) {
	*port++ = '\0';
    } else {
	sprintf(pbuf, "%d", defport);
	port = pbuf;
    }

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, port, &hints, &res);
    if (error || !res) {
	CTRACE((tfp, "HTGetAddrInfo: getaddrinfo(%s, %s): %s\n", host, port,
		gai_strerror(error)));
	res = NULL;
    }

    free(s);
    return res;
}
#endif /* INET6 */

#ifdef LY_FIND_LEAKS
/*	Free our name for the host on which we are - FM
 *	-------------------------------------------
 *
 */
static void free_HTTCP_hostname(void)
{
    FREE(hostname);
}
#endif /* LY_FIND_LEAKS */

/*	Derive the name of the host on which we are
 *	-------------------------------------------
 *
 */
static void get_host_details(void)
{
    char name[MAXHOSTNAMELEN + 1];	/* The name of this host */

#ifdef UCX
    char *domain_name;		/* The name of this host domain */
#endif /* UCX */
#ifdef NEED_HOST_ADDRESS	/* no -- needs name server! */
#ifdef INET6
    LYNX_ADDRINFO hints, *res;
    int error;

#else
    LYNX_HOSTENT *phost;	/* Pointer to host -- See netdb.h */
#endif /* INET6 */
#endif /* NEED_HOST_ADDRESS */
    int namelength = sizeof(name);

    if (hostname)
	return;			/* Already done */
    gethostname(name, namelength);	/* Without domain */
    StrAllocCopy(hostname, name);
#ifdef LY_FIND_LEAKS
    atexit(free_HTTCP_hostname);
#endif
#ifdef UCX
    /*
     * UCX doesn't give the complete domain name.  Get rest from UCX$BIND_DOM
     * logical.
     */
    if (strchr(hostname, '.') == NULL) {	/* Not full address */
	domain_name = LYGetEnv("UCX$BIND_DOMAIN");
	if (domain_name == NULL)
	    domain_name = LYGetEnv("TCPIP$BIND_DOMAIN");
	if (domain_name != NULL) {
	    StrAllocCat(hostname, ".");
	    StrAllocCat(hostname, domain_name);
	}
    }
#endif /* UCX */
    CTRACE((tfp, "TCP: Local host name is %s\n", hostname));

#ifndef DECNET			/* Decnet ain't got no damn name server 8#OO */
#ifdef NEED_HOST_ADDRESS	/* no -- needs name server! */
#ifdef INET6
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_CANONNAME;
    error = getaddrinfo(name, NULL, &hints, &res);
    if (error || !res || !res->ai_canonname) {
	CTRACE((tfp, "TCP: %s: `%s'\n", gai_strerror(error), name));
	if (res)
	    freeaddrinfo(res);
	return;			/* Fail! */
    }
    StrAllocCopy(hostname, res->ai_canonname);
    memcpy(&HTHostAddress, res->ai_addr, res->ai_addrlen);
    freeaddrinfo(res);
#else
    phost = gethostbyname(name);	/* See netdb.h */
    if (!OK_HOST(phost)) {
	CTRACE((tfp,
		"TCP: Can't find my own internet node address for `%s'!!\n",
		name));
	return;			/* Fail! */
    }
    StrAllocCopy(hostname, phost->h_name);
    memcpy(&HTHostAddress, &phost->h_addr, phost->h_length);
#endif /* INET6 */
    CTRACE((tfp, "     Name server says that I am `%s' = %s\n",
	    hostname, HTInetString(&HTHostAddress)));
#endif /* NEED_HOST_ADDRESS */

#endif /* !DECNET */
}

const char *HTHostName(void)
{
    get_host_details();
    return hostname;
}

#ifndef MULTINET		/* SOCKET_ERRNO != errno ? */
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
#define SOCKET_DEBUG_TRACE	/* show errno status after some system calls */
#endif /* UCX && VAXC */
#endif /* MULTINET */
/*
 *  Interruptible connect as implemented for Mosaic by Marc Andreesen
 *  and hacked in for Lynx years ago by Lou Montulli, and further
 *  modified over the years by numerous Lynx lovers. - FM
 */
int HTDoConnect(const char *url,
		const char *protocol,
		int default_port,
		int *s)
{
    int status = 0;
    char *line = NULL;
    char *p1 = NULL;
    char *at_sign = NULL;
    char *host = NULL;

#ifdef INET6
    LYNX_ADDRINFO *res = 0, *res0 = 0;

#else
    struct sockaddr_in soc_address;
    struct sockaddr_in *soc_in = &soc_address;

    /*
     * Set up defaults.
     */
    memset(soc_in, 0, sizeof(*soc_in));
    soc_in->sin_family = AF_INET;
    soc_in->sin_port = htons((PortNumber) default_port);
#endif /* INET6 */

    /*
     * Get node name and optional port number.
     */
    p1 = HTParse(url, "", PARSE_HOST);
    if ((at_sign = strchr(p1, '@@')) != NULL) {
	/*
	 * If there's an @@ then use the stuff after it as a hostname.
	 */
	StrAllocCopy(host, (at_sign + 1));
    } else {
	StrAllocCopy(host, p1);
    }
    FREE(p1);

    HTSprintf0(&line, "%s%s", WWW_FIND_MESSAGE, host);
    _HTProgress(line);
#ifdef INET6
    /* HTParseInet() is useless! */
    res0 = HTGetAddrInfo(host, default_port);
    if (res0 == NULL) {
	HTSprintf0(&line, gettext("Unable to locate remote host %s."), host);
	_HTProgress(line);
	FREE(host);
	FREE(line);
	return HT_NO_DATA;
    }
#else
    status = HTParseInet(soc_in, host);
    if (status) {
	if (status != HT_INTERRUPTED) {
	    if (status == HT_NOT_ACCEPTABLE) {
		/* Not HTProgress, so warning won't be overwritten immediately;
		 * but not HTAlert, because typically there will be other
		 * alerts from the callers.  - kw
		 */
		HTUserMsg2(gettext("Invalid hostname %s"), host);
	    } else {
		HTSprintf0(&line,
			   gettext("Unable to locate remote host %s."), host);
		_HTProgress(line);
	    }
	    status = HT_NO_DATA;
	}
	FREE(host);
	FREE(line);
	return status;
    }
#endif /* INET6 */

    HTSprintf0(&line, gettext("Making %s connection to %s"), protocol, host);
    _HTProgress(line);
    FREE(host);
    FREE(line);

    /*
     * Now, let's get a socket set up from the server for the data.
     */
#ifndef INET6
    *s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (*s == -1) {
	HTAlert(gettext("socket failed."));
	return HT_NO_DATA;
    }
#else
    for (res = res0; res; res = res->ai_next) {
	*s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	if (*s == -1) {
	    char hostbuf[1024], portbuf[1024];

	    getnameinfo(res->ai_addr, res->ai_addrlen,
			hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
			NI_NUMERICHOST | NI_NUMERICSERV);
	    HTSprintf0(&line,
		       gettext("socket failed: family %d addr %s port %s."),
		       res->ai_family, hostbuf, portbuf);
	    _HTProgress(line);
	    FREE(line);
	    continue;
	}
#endif /* INET6 */

#if !defined(DOSPATH) || defined(__DJGPP__)
#if !defined(NO_IOCTL) || defined(USE_FCNTL)
	/*
	 * Make the socket non-blocking, so the connect can be canceled.  This
	 * means that when we issue the connect we should NOT have to wait for
	 * the accept on the other end.
	 */
	{
#ifdef USE_FCNTL
	    int ret = fcntl(*s, F_SETFL, O_NONBLOCK);

#else
	    int val = 1;
	    int ret = IOCTL(*s, FIONBIO, &val);
#endif /* USE_FCNTL */
	    if (ret == -1)
		_HTProgress(gettext("Could not make connection non-blocking."));
	}
#endif /* !NO_IOCTL || USE_FCNTL */
#endif /* !DOSPATH || __DJGPP__ */

	/*
	 * Issue the connect.  Since the server can't do an instantaneous
	 * accept and we are non-blocking, this will almost certainly return a
	 * negative status.
	 */
#ifdef SOCKS
	if (socks_flag) {
#ifdef INET6
	    status = Rconnect(*s, res->ai_addr, res->ai_addrlen);
#else
	    status = Rconnect(*s, (struct sockaddr *) &soc_address,
			      sizeof(soc_address));
#endif /* INET6 */
	    /*
	     * For long Rbind.
	     */
	    socks_bind_remoteAddr = soc_address.sin_addr.s_addr;
	} else
#endif /* SOCKS */
#ifdef INET6
	    status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
	    status = connect(*s, (struct sockaddr *) &soc_address, sizeof(soc_address));
#endif /* INET6 */

	/*
	 * According to the Sun man page for connect:
	 *  EINPROGRESS         The socket is non-blocking and the  con-
	 *                      nection cannot be completed immediately.
	 *                      It is possible to select(2) for  comple-
	 *                      tion  by  selecting the socket for writ-
	 *                      ing.
	 * According to the Motorola SVR4 man page for connect:
	 *  EAGAIN              The socket is non-blocking and the  con-
	 *                      nection cannot be completed immediately.
	 *                      It is possible to select for  completion
	 *                      by  selecting  the  socket  for writing.
	 *                      However, this is only  possible  if  the
	 *                      socket  STREAMS  module  is  the topmost
	 *                      module on  the  protocol  stack  with  a
	 *                      write  service  procedure.  This will be
	 *                      the normal case.
	 */
	if ((status < 0) &&
	    (SOCKET_ERRNO == EINPROGRESS
#ifdef EAGAIN
	     || SOCKET_ERRNO == EAGAIN
#endif
	    )) {
	    struct timeval select_timeout;
	    int ret;
	    int tries = 0;

#ifdef SOCKET_DEBUG_TRACE
	    HTInetStatus("this socket's first connect");
#endif /* SOCKET_DEBUG_TRACE */
	    ret = 0;
	    while (ret <= 0) {
		fd_set writefds;

		/*
		 * Protect against an infinite loop.
		 */
		if ((tries++ / 10) >= connect_timeout) {
		    HTAlert(gettext("Connection failed (too many retries)."));
#ifdef INET6
		    FREE(line);
		    if (res0)
			freeaddrinfo(res0);
#endif /* INET6 */
		    return HT_NO_DATA;
		}
#ifdef _WINDOWS_NSL
		select_timeout.tv_sec = connect_timeout;
		select_timeout.tv_usec = 0;
#else
		select_timeout.tv_sec = 0;
		select_timeout.tv_usec = 100000;
#endif /* _WINDOWS_NSL */
		FD_ZERO(&writefds);
		FD_SET((unsigned) *s, &writefds);
#ifdef SOCKS
		if (socks_flag)
		    ret = Rselect((unsigned) *s + 1, NULL,
				  &writefds, NULL, &select_timeout);
		else
#endif /* SOCKS */
		    ret = select((unsigned) *s + 1,
				 NULL,
				 &writefds,
				 NULL,
				 &select_timeout);

#ifdef SOCKET_DEBUG_TRACE
		if (tries == 1) {
		    HTInetStatus("this socket's first select");
		}
#endif /* SOCKET_DEBUG_TRACE */
		/*
		 * If we suspend, then it is possible that select will be
		 * interrupted.  Allow for this possibility.  - JED
		 */
		if ((ret == -1) && (errno == EINTR))
		    continue;

#ifdef SOCKET_DEBUG_TRACE
		if (ret < 0) {
		    HTInetStatus("failed select");
		}
#endif /* SOCKET_DEBUG_TRACE */
		/*
		 * Again according to the Sun and Motorola man pages for
		 * connect:
		 *  EALREADY    The socket is non-blocking and a  previ-
		 *              ous  connection attempt has not yet been
		 *              completed.
		 * Thus if the SOCKET_ERRNO is NOT EALREADY we have a real
		 * error, and should break out here and return that error. 
		 * Otherwise if it is EALREADY keep on trying to complete the
		 * connection.
		 */
		if ((ret < 0) && (SOCKET_ERRNO != EALREADY)) {
		    status = ret;
		    break;
		} else if (ret > 0) {
		    /*
		     * Extra check here for connection success, if we try to
		     * connect again, and get EISCONN, it means we have a
		     * successful connection.  But don't check with SOCKS.
		     */
#ifdef SOCKS
		    if (socks_flag) {
			status = 0;
		    } else {
#endif /* SOCKS */
#ifdef INET6
			status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
			status = connect(*s, (struct sockaddr *) &soc_address,
					 sizeof(soc_address));
#endif /* INET6 */
#ifdef UCX
			/*
			 * A UCX feature:  Instead of returning EISCONN UCX
			 * returns EADDRINUSE.  Test for this status also.
			 */
			if ((status < 0) && ((SOCKET_ERRNO == EISCONN) ||
					     (SOCKET_ERRNO == EADDRINUSE)))
#else
			if ((status < 0) && (SOCKET_ERRNO == EISCONN))
#endif /* UCX */
			{
			    status = 0;
			}

			if (status && (SOCKET_ERRNO == EALREADY))	/* new stuff LJM */
			    ret = 0;	/* keep going */
			else {
#ifdef SOCKET_DEBUG_TRACE
			    if (status < 0) {
				HTInetStatus("confirm-ready connect");
			    }
#endif /* SOCKET_DEBUG_TRACE */
			    break;
			}
#ifdef SOCKS
		    }
#endif /* SOCKS */
		}
#ifdef SOCKS
		else if (!socks_flag)
#else
		else
#endif /* SOCKS */
		{
		    /*
		     * The select says we aren't ready yet.  Try to connect
		     * again to make sure.  If we don't get EALREADY or
		     * EISCONN, something has gone wrong.  Break out and report
		     * it.
		     *
		     * For some reason, SVR4 returns EAGAIN here instead of
		     * EALREADY, even though the man page says it should be
		     * EALREADY.
		     *
		     * For some reason, UCX pre 3 apparently returns errno =
		     * 18242 instead of EALREADY or EISCONN.
		     */
#ifdef INET6
		    status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
		    status = connect(*s, (struct sockaddr *) &soc_address,
				     sizeof(soc_address));
#endif /* INET6 */
		    if ((status < 0) &&
			(SOCKET_ERRNO != EALREADY
#ifdef EAGAIN
			 && SOCKET_ERRNO != EAGAIN
#endif
			) &&
#ifdef UCX
			(SOCKET_ERRNO != 18242) &&
#endif /* UCX */
			(SOCKET_ERRNO != EISCONN)) {
#ifdef SOCKET_DEBUG_TRACE
			HTInetStatus("confirm-not-ready connect");
#endif /* SOCKET_DEBUG_TRACE */
			break;
		    }
		}
		if (HTCheckForInterrupt()) {
		    CTRACE((tfp, "*** INTERRUPTED in middle of connect.\n"));
		    status = HT_INTERRUPTED;
#ifdef _WINDOWS
		    WSASetLastError(EINTR);
#else
		    SOCKET_ERRNO = EINTR;
#endif
		    break;
		}
	    }
	}
#ifdef SOCKET_DEBUG_TRACE
	else if (status < 0) {
	    HTInetStatus("this socket's first and only connect");
	}
#endif /* SOCKET_DEBUG_TRACE */
#ifdef INET6
	if (status < 0) {
	    NETCLOSE(*s);
	    *s = -1;
	    continue;
	}
	break;
    }
#endif /* INET6 */

#ifdef INET6
    if (*s < 0)
#else
    if (status < 0)
#endif /* INET6 */
    {
	/*
	 * The connect attempt failed or was interrupted, so close up the
	 * socket.
	 */
	NETCLOSE(*s);
    }
#if !defined(DOSPATH) || defined(__DJGPP__)
#if !defined(NO_IOCTL) || defined(USE_FCNTL)
    else {
	/*
	 * Make the socket blocking again on good connect.
	 */
#ifdef USE_FCNTL
	int ret = fcntl(*s, F_SETFL, 0);

#else
	int val = 0;
	int ret = IOCTL(*s, FIONBIO, &val);
#endif /* USE_FCNTL */
	if (ret == -1)
	    _HTProgress(gettext("Could not restore socket to blocking."));
    }
#endif /* !NO_IOCTL || USE_FCNTL */
#endif /* !DOSPATH || __DJGPP__ */

#ifdef INET6
    FREE(line);
    if (res0)
	freeaddrinfo(res0);
#endif /* INET6 */
    return status;
}

/*
 *  This is so interruptible reads can be implemented cleanly.
 */
int HTDoRead(int fildes,
	     void *buf,
	     unsigned nbyte)
{
    int ready, ret;
    fd_set readfds;
    struct timeval select_timeout;
    int tries = 0;

#ifdef USE_READPROGRESS
    int otries = 0;
    time_t otime = time((time_t *) 0);
#endif
#if defined(UNIX) || defined(UCX)
    int nb;
#endif /* UCX, BSN */

#ifdef UNIX
    if (fildes == 0) {
	/*
	 * 0 can be a valid socket fd, but if it's a tty something must have
	 * gone wrong.  - kw
	 */
	if (isatty(fildes)) {
	    CTRACE((tfp, "HTDoRead - refusing to read fd 0 which is a tty!\n"));
	    return -1;
	}
    } else
#endif
    if (fildes <= 0)
	return -1;

    if (HTCheckForInterrupt()) {
#ifdef _WINDOWS
	WSASetLastError(EINTR);
#else
	SOCKET_ERRNO = EINTR;
#endif
	return (HT_INTERRUPTED);
    }
#if !defined(NO_IOCTL)
    ready = 0;
#else
    ready = 1;
#endif /* bypass for NO_IOCTL */
    while (!ready) {
	/*
	 * Protect against an infinite loop.
	 */
	if (tries++ >= 180000) {
	    HTAlert(gettext("Socket read failed for 180,000 tries."));
#ifdef _WINDOWS
	    WSASetLastError(EINTR);
#else
	    SOCKET_ERRNO = EINTR;
#endif
	    return HT_INTERRUPTED;
	}
#ifdef USE_READPROGRESS
	if (tries - otries > 10) {
	    time_t t = time((time_t *) 0);

	    otries = tries;
	    if (t - otime >= 5) {
		otime = t;
		HTReadProgress(-1, 0);	/* Put "stalled" message */
	    }
	}
#endif

	/*
	 * If we suspend, then it is possible that select will be interrupted. 
	 * Allow for this possibility.  - JED
	 */
	do {
	    select_timeout.tv_sec = 0;
	    select_timeout.tv_usec = 100000;
	    FD_ZERO(&readfds);
	    FD_SET((unsigned) fildes, &readfds);
#ifdef SOCKS
	    if (socks_flag)
		ret = Rselect((unsigned) fildes + 1,
			      &readfds, NULL, NULL, &select_timeout);
	    else
#endif /* SOCKS */
		ret = select((unsigned) fildes + 1,
			     &readfds, NULL, NULL, &select_timeout);
	} while ((ret == -1) && (errno == EINTR));

	if (ret < 0) {
	    return -1;
	} else if (ret > 0) {
	    ready = 1;
	} else if (HTCheckForInterrupt()) {
#ifdef _WINDOWS
	    WSASetLastError(EINTR);
#else
	    SOCKET_ERRNO = EINTR;
#endif
	    return HT_INTERRUPTED;
	}
    }

#if !defined(UCX) || !defined(VAXC)
#ifdef UNIX
    while ((nb = SOCKET_READ(fildes, buf, nbyte)) == -1) {
	if (errno == EINTR)
	    continue;
#ifdef ERESTARTSYS
	if (errno == ERESTARTSYS)
	    continue;
#endif /* ERESTARTSYS */
	HTInetStatus("read");
	break;
    }
    return nb;
#else /* UNIX */
    return SOCKET_READ(fildes, buf, nbyte);
#endif /* !UNIX */

#else /* UCX && VAXC */
    /*
     * VAXC and UCX problem only.
     */
    errno = vaxc$errno = 0;
    nb = SOCKET_READ(fildes, buf, nbyte);
    CTRACE((tfp,
	    "Read - nb,errno,vaxc$errno: %d %d %d\n", nb, errno, vaxc$errno));
    if ((nb <= 0) && TRACE)
	perror("HTTCP.C:HTDoRead:read");	/* RJF */
    /*
     * An errno value of EPIPE and nb < 0 indicates end-of-file on VAXC.
     */
    if ((nb <= 0) && (errno == EPIPE)) {
	nb = 0;
	set_errno(0);
    }
    return nb;
#endif /* UCX, BSN */
}

#ifdef SVR4_BSDSELECT
/*
 *  This is a fix for the difference between BSD's select() and
 *  SVR4's select().  SVR4's select() can never return a value larger
 *  than the total number of file descriptors being checked.  So, if
 *  you select for read and write on one file descriptor, and both
 *  are true, SVR4 select() will only return 1.  BSD select in the
 *  same situation will return 2.
 *
 *	Additionally, BSD select() on timing out, will zero the masks,
 *	while SVR4 does not.  This is fixed here as well.
 *
 *	Set your tabstops to 4 characters to have this code nicely formatted.
 *
 *	Jerry Whelan, guru@@bradley.edu, June 12th, 1993
 */
#ifdef select
#undef select
#endif /* select */

#ifdef SOCKS
#ifdef Rselect
#undef Rselect
#endif /* Rselect */
#endif /* SOCKS */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/select.h>

int BSDselect(int nfds,
	      fd_set * readfds,
	      fd_set * writefds,
	      fd_set * exceptfds,
	      struct timeval *select_timeout)
{
    int rval, i;

#ifdef SOCKS
    if (socks_flag)
	rval = Rselect(nfds, readfds, writefds, exceptfds, select_timeout);
    else
#endif /* SOCKS */
	rval = select(nfds, readfds, writefds, exceptfds, select_timeout);

    switch (rval) {
    case -1:
	return (rval);

    case 0:
	if (readfds != NULL)
	    FD_ZERO(readfds);
	if (writefds != NULL)
	    FD_ZERO(writefds);
	if (exceptfds != NULL)
	    FD_ZERO(exceptfds);
	return (rval);

    default:
	for (i = 0, rval = 0; i < nfds; i++) {
	    if ((readfds != NULL) && FD_ISSET(i, readfds))
		rval++;
	    if ((writefds != NULL) && FD_ISSET(i, writefds))
		rval++;
	    if ((exceptfds != NULL) && FD_ISSET(i, exceptfds))
		rval++;

	}
	return (rval);
    }
/* Should never get here */
}
#endif /* SVR4_BSDSELECT */
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d2 16
a17 16
**			==========================
**
**	This code is in common between client and server sides.
**
**	16 Jan 92  TBL	Fix strtol() undefined on CMU Mach.
**	25 Jun 92  JFG	Added DECNET option through TCP socket emulation.
**	13 Sep 93  MD	Added correct return of vmserrorno for HTInetStatus.
**			Added decoding of vms error message for MULTINET.
**	7-DEC-1993 Bjorn S. Nilsson, ALEPH, CERN, VMS UCX ioctl() changes
**			(done of Mosaic)
**	19 Feb 94  Danny Mayer	Added Bjorn Fixes to Lynx version
**	 7 Mar 94  Danny Mayer	Added Fix UCX version for full domain name
**	20 May 94  Andy Harper	Added support for CMU TCP/IP transport
**	17 Nov 94  Andy Harper	Added support for SOCKETSHR transport
**	16 Jul 95  S. Bjorndahl added kluge to deal with LIBCMU bug
*/
d39 3
d45 6
a50 6
PUBLIC int BSDselect PARAMS((
	int		 nfds,
	fd_set *	 readfds,
	fd_set *	 writefds,
	fd_set *	 exceptfds,
	struct timeval * select_timeout));
d66 3
a68 3
**  Module-Wide variables
*/
PRIVATE char *hostname = NULL;		/* The name of this host */
d71 2
a72 2
**  PUBLIC VARIABLES
*/
d74 1
a74 1
PUBLIC unsigned long socks_bind_remoteAddr; /* for long Rbind */
d77 1
a77 1
/* PUBLIC SockA HTHostAddress; */	/* The internet address of the host */
d81 9
a89 9
**	------------------
**
**  On entry,
**	where		gives a description of what caused the error
**	global errno	gives the error number in the Unix way.
**
**  On return,
**	returns		a negative status in the Unix way.
*/
d92 1
a92 1
extern char *sys_errlist[];		/* see man perror on cernvax */
d97 1
a97 1
static int ResolveYield (void)
d99 1
a99 1
    return HTCheckForInterrupt() ? 0 : 1;
d107 1
a107 2
static char host[512];
static struct hostent *phost; /* Pointer to host - See netdb.h */
d110 1
a110 1
static unsigned long _fork_func (void *arglist GCC_UNUSED)
d112 2
d116 4
a119 3
    addr = (unsigned long)inet_addr(host);
    if ((int)addr != -1)
	phost = gethostbyaddr((char *)&addr, sizeof (addr), AF_INET);
d126 1
a126 1
    return (unsigned long)(phost);
d132 3
a134 3
**  A routine to mimic the ioctl function for UCX.
**  Bjorn S. Nilsson, 25-Nov-1993. Based on an example in the UCX manual.
*/
d137 3
a139 4
PUBLIC int HTioctl ARGS3(
	int,		d,
	int,		request,
	int *,		argp)
d154 1
a154 1
    if ((sdc = vaxc$get_sdc (d)) == 0) {
d158 3
a160 2
    ioctl_desc.opt  = UCX$C_IOCTL;
    ioctl_desc.len  = sizeof(struct comm);
d165 1
a165 1
	p6 = (char *)&ioctl_desc;
d168 1
a168 1
	p5 = (char *)&ioctl_desc;
d172 2
a173 2
    ioctl_comm.addr = (char *)argp;
    status = sys$qiow (0, sdc, fun, iosb, 0, 0, 0, 0, 0, 0, p5, p6);
d190 3
a192 4
**	---------------------
*/
PUBLIC int HTInetStatus ARGS1(
	char *,		where)
d196 1
d204 2
a205 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   "(Error number not translated)"));	/* What Is the VM equiv? */
d211 2
a212 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   vms_errno_string()));
d214 3
a216 3
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   ((SOCKET_ERRNO > 0 && SOCKET_ERRNO <= 65) ?
	    strerror(SOCKET_ERRNO) : "(Error number not translated)")));
d222 2
a223 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   strerror(SOCKET_ERRNO)));
d228 3
a230 3
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   (SOCKET_ERRNO < sys_nerr ?
	    sys_errlist[SOCKET_ERRNO] : "Unknown error" )));
d236 2
a237 2
	   "         Unix error number (SOCKET_ERRNO) = %ld dec\n",
	   SOCKET_ERRNO));
d239 2
a240 2
	   "         VMS error (vaxc$errno)    = %lx hex\n",
	   vaxc$errno));
d248 2
a249 2
    **	uerrno and errno happen to be zero if vmserrno <> 0
    */
d262 15
a276 16
**	----------------------
**
** On entry,
**	*pp	    points to first character to be interpreted, terminated by
**		    non 0:9 character.
**	*pstatus    points to status already valid
**	maxvalue    gives the largest allowable value.
**
** On exit,
**	*pp	    points to first unread character
**	*pstatus    points to status updated iff bad
*/
PUBLIC unsigned int HTCardinal ARGS3(
	int *,		pstatus,
	char **,	pp,
	unsigned int,	max_value)
d279 3
a281 2
    if ((**pp<'0') || (**pp>'9')) {	    /* Null string is error */
	*pstatus = -3;	/* No number where one expected */
d287 1
a287 1
	n = n*10 + *((*pp)++) - '0';
d290 1
a290 1
	*pstatus = -4;	/* Cardinal outside range */
d297 1
a297 1
#ifndef DECNET	/* Function only used below for a trace message */
d299 7
a305 8
**	----------------------------------------
**
**  On exit,
**	returns a pointer to a static string which must be copied if
**		it is to be kept.
*/
PUBLIC CONST char * HTInetString ARGS1(
	SockA*,		soc_in)
d309 4
a312 3
    getnameinfo((struct sockaddr *)soc_in,
	    SOCKADDR_LEN(soc_in),
	    hostbuf, sizeof(hostbuf), NULL, 0, NI_NUMERICHOST);
d316 1
d318 4
a321 4
	    (int)*((unsigned char *)(&soc_in->sin_addr)+0),
	    (int)*((unsigned char *)(&soc_in->sin_addr)+1),
	    (int)*((unsigned char *)(&soc_in->sin_addr)+2),
	    (int)*((unsigned char *)(&soc_in->sin_addr)+3));
d328 20
a347 21
**	-------------------------------------------------
**
**  Checks whether
**  - contains only valid chars for domain names (actually, the
**    restrictions are somewhat relaxed),
**  - no leading dots or empty segments,
**  - no segment starts with '-' or '+' [this protects telnet command],
**  - max. length of dot-separated segment <= 63 (RFC 1034,1035),
**  - total length <= 254 (if it ends with dot) or 253 (otherwise)
**     [an interpretation of RFC 1034,1035, although RFC 1123
**      suggests 255 as limit - kw].
**
**  Note: user (before '@@') and port (after ':') components from
**      host part of URL should be already stripped (if appropriate)
**      from the input string.
**
**  On exit,
**	returns 1 if valid, otherwise 0.
*/
PUBLIC BOOL valid_hostname ARGS1(
	char *,	name)
d349 1
a349 1
    int i=1, iseg = 0;
d351 1
d378 5
a382 6
**  Function to allow us to be killed with a normal signal (not
**  SIGKILL), but don't go through normal libc exit() processing, which
**  would screw up parent's stdio.  -BL
*/
PRIVATE void quench ARGS1(
	int,	sig GCC_UNUSED)
d388 1
a388 1
PUBLIC int lynx_nsl_status = HT_OK;
d391 1
a391 1
#define DEBUG_HOSTENT_CHILD  /* for NSL_FORK, may screw up trace file */
d394 8
a401 9
**  Two auxiliary functions for name lookup and struct hostent.
**
**  dump_hostent - dumps the contents of a struct hostent to the
**  trace log or stderr, including all pointer values, strings, and
**  addresses, in a format inspired by gdb's print format. - kw
*/
PRIVATE void dump_hostent ARGS2(
    CONST char *,		msgprefix,
    CONST struct hostent *,	phost)
d406 2
a407 1
	CTRACE((tfp,"%s: %p ", msgprefix, phost));
d409 1
a409 1
	    CTRACE((tfp,"{ h_name = %p", phost->h_name));
d415 1
a415 1
	    CTRACE((tfp,"\n\t h_aliases = %p", phost->h_aliases));
d419 3
a421 3
		    CTRACE((tfp,"%s %p \"%s\"",
			   (pcnt == phost->h_aliases ? " " : ", "),
			   *pcnt, *pcnt));
d424 1
a424 1
		       (*phost->h_aliases ? ", " : " ")));
d428 3
a430 3
	    CTRACE((tfp," h_addrtype = %d,", phost->h_addrtype));
	    CTRACE((tfp," h_length = %d,\n\t", phost->h_length));
	    CTRACE((tfp," h_addr_list = %p", phost->h_addr_list));
d434 3
a436 3
		    CTRACE((tfp,"%s %p",
			   (pcnt == phost->h_addr_list ? "" : ","),
			   *pcnt));
d438 3
a440 3
			CTRACE((tfp, "%s%d%s", (i==0 ? " \"" : "."),
			       (int)*((unsigned char *)(*pcnt)+i),
			       (i+1 == phost->h_length ? "\"" : "")));
d452 1
a452 1
	CTRACE((tfp,"\n"));
d458 7
a464 7
**  fill_rehostent - copies as much as possible relevant content from
**  the struct hostent pointed to by phost to the char buffer given
**  by rehostent, subject to maximum output length rehostentsize,
**  following pointers and building self-contained output which can be
**  cast to a struct hostent. - kw
**  See also description of LYGetHostByName.
*/
d467 1
a467 1
#define REHOSTENT_SIZE 128		/* not bigger than pipe buffer! */
d470 7
a476 8
	struct hostent	h;
	char		rest[REHOSTENT_SIZE];
    } AlignedHOSTENT;

PRIVATE size_t fill_rehostent ARGS3(
    char *,			rehostent,
    size_t,			rehostentsize,
    CONST struct hostent *,	phost)
d478 1
a478 1
    AlignedHOSTENT *data = (AlignedHOSTENT *)rehostent;
d486 1
a486 1
    size_t curlen = sizeof(struct hostent);
d494 1
d518 1
a518 1
	for (pcnt=phost->h_addr_list+1; *pcnt; pcnt++) {
d529 1
a529 1
	for (pcnt=phost->h_aliases; *pcnt; pcnt++) {
d541 1
a541 1
    p_next_charptr = (char **)(rehostent + curlen);
d544 1
a544 1
	p_next_char += (num_addrs+1) * sizeof(phost->h_addr_list[0]);
d546 1
a546 1
	p_next_char += (num_aliases+1) * sizeof(phost->h_aliases[0]);
d550 1
a550 1
	for (pcnt=phost->h_addr_list, i_addr = 0;
d576 1
a576 1
	for (pcnt=phost->h_aliases, i_alias = 0;
d595 1
a595 1
    curlen = p_next_char - (char *)rehostent;
d604 1
d606 1
a606 1
#ifndef h_errno		/* there may be a macro as well as the extern data */
d612 34
a645 35
**	------------------------------------------------
**
**  On entry,
**	str	points to the given host name, not numeric address,
**		without colon or port number.
**
**  On exit,
**	returns a pointer to a struct hostent in static storage,
**	or NULL in case of error or user interruption.
**
**  The interface is intended to be exactly the same as for (Unix)
**  gethostbyname(), except for the following:
**
**  If NSL_FORK is not used, the result of gethostbyname is returned
**  directly.  Otherwise:
**  All lists, addresses, and strings referred to by pointers in the
**  returned struct are located, together with the returned struct
**  itself, in a buffer of size REHOSTENT_SIZE.  If not everything fits,
**  some info is omitted, but the function is careful to still return
**  a valid structure, without truncating strings; it tries to return,
**  in order of decreasing priority, the first address (h_addr), the
**  official name (h_name), the additional addresses, then alias names.
**
**  If NULL is returned, the reason is made available in the global
**  variable lynx_nsl_status, with one of the following values:
**	HT_INTERRUPTED		Interrupted by user
**	HT_NOT_ACCEPTABLE	Hostname detected as invalid
**				(also sets h_errno)
**	HT_H_ERRNO_VALID	An error occurred, and h_errno holds
**				an appropriate value
**	HT_ERROR		Resolver error, reason not known
**	HT_INTERNAL		Internal error
*/
PUBLIC struct hostent * LYGetHostByName ARGS1(
	char *,	str)
a646 1
#ifndef _WINDOWS_NSL
a647 1
#endif
d652 1
d654 3
a656 4
     * We could define rehosten directly as a
     * static char rehostent[REHOSTENT_SIZE],
     * but the indirect approach via the above struct
     * should automatically take care of alignment requirements.
d658 6
a663 7
     *  - this must be static, as we shall return a pointer to it
     *    which must remain valid, and
     *  - we have to use the same rehostent in the child process as
     *    in the parent (its address in the parent's address space
     *    must be the same as in the child's, otherwise the internal
     *    pointers built by the child's call to fill_rehostent would
     *    be invalid when seen by the parent). - kw
d665 1
a665 1
    char *rehostent = (char *)&aligned_full_rehostent;
d671 1
a671 1
	int child_errno;  /* sometimes useful to pass this on */
d679 1
a679 1
    struct hostent *result_phost = NULL;
d692 1
a692 1
	/*  Could disable this if all our callers already check - kw */
a698 4
#ifdef _WINDOWS_NSL
    strncpy(host, str, sizeof(host));
#endif /*  _WINDOWS_NSL */

d710 1
a710 2

#ifdef MVS	/* Outstanding problem with crash in MVS gethostbyname */
d714 1
a714 1
    CTRACE_FLUSH(tfp);  /* so child messages will not mess up parent log */
d720 4
a723 4
	/*
	**  Start block for fork-based gethostbyname() with
	**  checks for interrupts. - Tom Zerucha (tz@@execpc.com) & FM
	*/
d726 1
d732 3
a734 3
	**	Pipe, child pid, status buffers, start time, select()
	**	control variables.
	*/
d737 1
d740 1
d744 1
a744 1
	time_t start_time = time((time_t *)0);
d747 1
a747 1
	long dns_patience = 30; /* how many seconds will we wait for DNS? */
d750 8
a757 9
	    /*
	    **  Reap any children that have terminated since last time
	    **  through.  This might include children that we killed,
	    **  then waited with WNOHANG before they were actually ready
	    **  to be reaped.  (Should be max of 1 in this state, but
	    **  the loop is safe if waitpid() is implemented correctly:
	    **  returns 0 when children exist but none have exited; -1
	    **  with errno == ECHILD when no children.)  -BL
	    */
d767 7
a773 8
	 *  Attempt to prevent a rare situation where the child
	 *  could execute the Lynx signal handlers because it gets
	 *  killed before it even has a chance to reset its handlers,
	 *  resulting in bogus 'Exiting via interrupt' message and
	 *  screen corruption or worse.
	 *  Should that continue to be reported, for systems without
	 *  sigprocmask(), we need to find a different solutions for
	 *  those. - kw 19990430
d790 3
a792 2
	if ((fpid = fork()) == 0 ) {
	    struct hostent  *phost;	/* Pointer to host - See netdb.h */
d794 4
a797 4
	    **  Child - for the long call.
	    **
	    **  Make sure parent can kill us at will.  -BL
	    */
d801 5
a805 6
	    **  Also make sure the child does not run one of the
	    **  signal handlers that may have been installed by
	    **  Lynx if one of those signals occurs.  For example
	    **  we don't want the child to remove temp files on
	    **  ^C, let the parent deal with that. - kw
	    */
d833 2
a834 2
	    **  Child won't use read side.  -BL
	    */
d857 1
a857 1
		dump_hostent("CHILD fill_rehostent", (struct hostent *)rehostent);
d860 2
a861 2
	    if (rehostentlen <= sizeof(struct hostent) ||
		!OK_HOST((struct hostent *)rehostent)) {
d865 1
a865 1
		statuses.h_length = ((struct hostent *)rehostent)->h_length;
d867 1
a867 1
		if (h_errno == -2) /* success, but h_errno unchanged? */
d872 4
a875 4
	    **  Send variables indicating status of lookup to parent.
	    **  That includes rehostentlen, which the parent will use
	    **  as the size for the second read (if > 0).
	    */
d877 1
a877 1
	    statuses.child_errno = errno;
a880 1

d883 2
a884 2
		**  Return our resulting rehostent through pipe...
		*/
d889 2
a890 2
		**  ... or return error as exit code.
		*/
a893 1

d896 3
a898 3
	**  (parent) Restore signal mask to whatever it was
	**  before the fork. - kw
	*/
d903 3
a905 3
	**	(parent) Wait until lookup finishes, or interrupt,
	**	or cycled too many times (just in case) -BL
	*/
d907 1
a907 1
	close(pfd[1]);      /* parent won't use write side -BL */
d909 3
a911 3
	if (fpid < 0) {     /* fork failed */
		close(pfd[0]);
		goto failed;
d914 1
a914 1
	while (child_exited || (long)(time((time_t *)0) - start_time) < dns_patience) {
d918 9
a926 9
	    **  This allows us to abort immediately, not after 1-second
	    **  timeout, when user hits abort key.  Can't do this when
	    **  using SLANG (or at least I don't know how), so SLANG
	    **  users must live with up-to-1s timeout.  -BL
	    **
	    **  Whoops -- we need to make sure stdin is actually
	    **  selectable!  /dev/null isn't, on some systems, which
	    **  makes some useful Lynx invocations fail.  -BL
	    */
d929 1
d939 5
a943 5
		/*
		**  Return when data received, interrupted, or failed.
		**  If nothing is waiting, we sleep for 1 second in
		**  select(), to be nice to the system.  -BL
		*/
d946 1
a946 1
		selret = Rselect(pfd[0] + 1, (void *)&readfds, NULL, NULL, &one_second);
d949 1
a949 1
		selret = select(pfd[0] + 1, (void *)&readfds, NULL, NULL, &one_second);
d953 2
a954 2
		**	First get status, including length of address.  -BL, kw
		*/
d963 7
a969 8
			 *  If something went wrong in the child process
			 *  other than normal lookup errors, and it appears
			 *  that we have enough info to know what went wrong,
			 *  generate diagnostic output.
			 *  ENOMEM observed on linux in processes constrained
			 *  with ulimit.  It would be too unkind to abort
			 *  the session, access to local files or through a
			 *  proxy may still work. - kw
d973 1
a973 1
			    (errno && h_errno == NETDB_INTERNAL) ||
d975 6
a980 6
			    (errno == ENOMEM &&
			     statuses.rehostentlen == 0 &&
			     /* should probably be NETDB_INTERNAL if child
				memory exhausted, but we may find that
				h_errno remains unchanged. - kw */
			     h_errno == -2)) {
d987 3
a989 3
				 *  Not much point in continuing, right?
				 *  Fake a 'z', should shorten pointless
				 *  guessing cycle. - kw
d996 1
a996 1
		    if (statuses.rehostentlen > sizeof(struct hostent)) {
d998 2
a999 2
			**  Then get the full reorganized hostent.  -BL, kw
			*/
d1002 1
a1002 1
			dump_hostent("Read from pipe", (struct hostent *)rehostent);
d1006 1
a1006 1
			    result_phost = (struct hostent *)rehostent;
d1016 2
a1017 2
		**  Make sure child is cleaned up.  -BL
		*/
d1028 2
a1029 2
	    **  Clean up if child exited before & no data received.  -BL
	    */
d1035 2
a1036 2
	    **  If child exited, loop once more looking for data.  -BL
	    */
d1039 4
a1042 4
		**	Data will be arriving right now, so make sure we
		**	don't short-circuit out for too many loops, and
		**	skip the interrupt check.  -BL
		*/
d1048 2
a1049 2
	    **  Abort if interrupt key pressed.
	    */
d1066 3
a1068 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",
			(int)waitret, WEXITSTATUS(waitstat)));
d1070 3
a1072 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
		       (int)waitret, WTERMSIG(waitstat)));
d1075 3
a1077 2
		    CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d dumped core!\n",
			   (int)waitret));
d1081 3
a1083 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
			(int)waitret, WSTOPSIG(waitstat)));
d1099 4
a1102 3
	    t = (unsigned long)inet_addr(host);
	    if ((int)t != -1)
		phost = gethostbyaddr((char *)&t, sizeof (t), AF_INET);
d1107 1
a1107 1
	    phost = (struct hostent *) NULL;
d1109 4
a1112 3
	    hThread = CreateThread((void *)NULL, 4096UL,
		(LPTHREAD_START_ROUTINE)_fork_func,
		(void *)NULL, 0UL, (unsigned long *)&dwThreadID);
d1114 1
a1114 1
		MessageBox((void *)NULL, "CreateThread",
d1122 2
a1123 2
			MessageBox((void *)NULL,
				   "CloseHandle","CloseHandle Failed", 0L);
d1143 2
a1144 1
	struct hostent  *phost;
d1167 1
a1167 1
failed:
d1169 1
a1169 1
		host));
a1172 1

d1174 11
a1184 11
**	-------------------------------------
**
**  On entry,
**	str	points to a string with a node name or number,
**		with optional trailing colon and port number.
**	soc_in	points to the binary internet or decnet address field.
**
**  On exit,
**	*soc_in is filled in.  If no port is specified in str, that
**		field is left unchanged in *soc_in.
*/
d1186 1
a1186 3
PRIVATE int HTParseInet ARGS2(
	SockA *,	soc_in,
	CONST char *,	str)
a1190 1
#ifndef _WINDOWS_NSL
a1191 1
#endif /* _WINDOWS_NSL */
a1201 3
#ifdef _WINDOWS_NSL
    strncpy(host, str, sizeof(host));
#else
a1202 1
#endif /*  _WINDOWS_NSL */
d1204 2
a1205 2
    **	Parse port number if present.
    */
d1211 1
a1211 1
	    soc_in->sin_port = (PortNumber)htons(strtol(port, &strptr, 10));
d1214 1
a1214 1
	    soc_in->sdn_objnum = (unsigned char)(strtol(port, &strptr, 10));
d1216 1
a1216 1
	    soc_in->sin_port = htons((PortNumber)strtol(port, &strptr, 10));
d1219 1
a1219 1
#ifdef SUPPRESS		/* 1. crashes!?!.  2. URL syntax has number not name */
d1221 2
a1222 1
	    struct servent * serv = getservbyname(port, (char*)0);
a1230 1
#ifndef _WINDOWS_NSL
a1231 1
#endif /* _WINDOWS_NSL */
a1235 1

d1238 4
a1241 4
    **	Read Decnet node name. @@@@ Should know about DECnet addresses, but
    **	it's probably worth waiting until the Phase transition from IV to V.
    */
    soc_in->sdn_nam.n_len = min(DN_MAXNAML, strlen(host));  /* <=6 in phase 4 */
d1243 4
a1246 3
    CTRACE((tfp, "DECnet: Parsed address as object number %d on host %.6s...\n",
		soc_in->sdn_objnum, host));
#else  /* parse Internet host: */
d1248 1
a1248 1
    if (*host >= '0' && *host <= '9') {   /* Test for numeric node address: */
d1264 3
a1266 3
    **	Parse host number if present.
    */
    if (dotcount_ip == 3)   /* Numeric node address: */
d1269 1
a1269 1
	soc_in->sin_addr.s_addr = inet_addr(host).s_addr; /* See arpa/inet.h */
d1272 1
a1272 1
	soc_in->sin_addr = inet_addr(host);		/* See netinet/in.h */
a1276 1
#ifndef _WINDOWS_NSL
a1277 1
#endif /* _WINDOWS_NSL */
a1284 1
#ifndef _WINDOWS_NSL
d1286 1
a1286 3
#endif /* _WINDOWS_NSL */
    } else
    {			    /* Alphanumeric node name: */
d1288 1
a1288 1
#ifdef MVS	/* Outstanding problem with crash in MVS gethostbyname */
d1294 3
a1296 2
	if (!phost) goto failed;
	memcpy((void *)&soc_in->sin_addr, phost->h_addr, phost->h_length);
d1299 2
a1300 1
	    struct hostent  *phost;
d1303 2
a1304 1
	    if (!phost) goto failed;
d1307 9
a1315 8
	    **  In LIBCMU, phost->h_length contains not the length of one address
	    **  (four bytes) but the number of bytes in *h_addr, i.e., some multiple
	    **  of four.  Thus we need to hard code the value here, and remember to
	    **  change it if/when IP addresses change in size. :-(	LIBCMU is no
	    **  longer supported, and CMU users are encouraged to obtain and use
	    **  SOCKETSHR/NETLIB instead. - S. Bjorndahl
	    */
	    memcpy((void *)&soc_in->sin_addr, phost->h_addr, 4);
d1317 2
a1318 1
	    if (!phost) goto failed;
d1322 1
a1322 1
	    memcpy((void *)&soc_in->sin_addr, phost->h_addr, phost->h_length);
a1326 1
#ifndef _WINDOWS_NSL
d1328 1
a1328 1
#endif /* _WINDOWS_NSL */
d1330 8
a1337 9
    }	/* Alphanumeric node name */

    CTRACE((tfp, "HTParseInet: Parsed address as port %d, IP address %d.%d.%d.%d\n",
		(int)ntohs(soc_in->sin_port),
		(int)*((unsigned char *)(&soc_in->sin_addr)+0),
		(int)*((unsigned char *)(&soc_in->sin_addr)+1),
		(int)*((unsigned char *)(&soc_in->sin_addr)+2),
		(int)*((unsigned char *)(&soc_in->sin_addr)+3)));
#endif	/* Internet vs. Decnet */
d1339 1
a1339 1
    return 0;	/* OK */
d1341 1
a1341 1
failed:
d1343 1
a1343 2
		host));
#ifndef _WINDOWS_NSL
a1344 1
#endif /* _WINDOWS_NSL */
d1346 4
a1349 4
	case HT_NOT_ACCEPTABLE:
	case HT_INTERRUPTED:
	    return lynx_nsl_status;
	default:
d1356 2
a1357 4
PRIVATE struct addrinfo *
HTGetAddrInfo ARGS2(
    CONST char *, str,
    CONST int, defport)
d1359 1
a1359 1
    struct addrinfo hints, *res;
d1362 1
a1362 1
    char *s;
d1366 1
a1366 1
    s = strdup(str);
d1393 1
d1400 4
a1403 4
**	-------------------------------------------
**
*/
PRIVATE void free_HTTCP_hostname NOARGS
d1410 4
a1413 4
**	-------------------------------------------
**
*/
PRIVATE void get_host_details NOARGS
d1415 2
a1416 1
    char name[MAXHOSTNAMELEN+1];	/* The name of this host */
d1418 1
a1418 1
    char *domain_name;			/* The name of this host domain */
d1420 1
a1420 1
#ifdef NEED_HOST_ADDRESS		/* no -- needs name server! */
d1422 1
a1422 1
    struct addrinfo hints, *res;
d1424 1
d1426 1
a1426 1
    struct hostent * phost;		/* Pointer to host -- See netdb.h */
d1432 1
a1432 1
	return;				/* Already done */
d1440 4
a1443 4
    **	UCX doesn't give the complete domain name.
    **	Get rest from UCX$BIND_DOM logical.
    */
    if (strchr(hostname,'.') == NULL) {		  /* Not full address */
d1451 1
a1451 1
     }
d1455 2
a1456 2
#ifndef DECNET	/* Decnet ain't got no damn name server 8#OO */
#ifdef NEED_HOST_ADDRESS		/* no -- needs name server! */
d1467 1
a1467 1
	return;  /* Fail! */
d1475 4
a1478 3
	CTRACE((tfp, "TCP: Can't find my own internet node address for `%s'!!\n",
		    name));
	return;  /* Fail! */
d1484 1
a1484 1
		hostname, HTInetString(&HTHostAddress)));
d1490 1
a1490 1
PUBLIC CONST char * HTHostName NOARGS
d1497 3
a1499 3
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
#define SOCKET_DEBUG_TRACE    /* show errno status after some system calls */
#endif  /* UCX && VAXC */
d1502 8
a1509 9
**  Interruptible connect as implemented for Mosaic by Marc Andreesen
**  and hacked in for Lynx years ago by Lou Montulli, and further
**  modified over the years by numerous Lynx lovers. - FM
*/
PUBLIC int HTDoConnect ARGS4(
	CONST char *,	url,
	char *,		protocol,
	int,		default_port,
	int *,		s)
d1516 1
d1518 2
a1519 1
    struct addrinfo *res, *res0;
d1525 2
a1526 2
    **	Set up defaults.
    */
d1533 2
a1534 2
    **	Get node name and optional port number.
    */
d1538 2
a1539 2
	**  If there's an @@ then use the stuff after it as a hostname.
	*/
d1546 2
a1547 2
    HTSprintf0 (&line, "%s%s", WWW_FIND_MESSAGE, host);
    _HTProgress (line);
d1552 1
a1552 1
	HTSprintf0 (&line, gettext("Unable to locate remote host %s."), host);
d1563 3
a1565 3
		/*  Not HTProgress, so warning won't be overwritten
		 *  immediately; but not HTAlert, because typically
		 *  there will be other alerts from the callers. - kw
d1569 2
a1570 2
		HTSprintf0 (&line,
			 gettext("Unable to locate remote host %s."), host);
d1581 2
a1582 2
    HTSprintf0 (&line, gettext("Making %s connection to %s"), protocol, host);
    _HTProgress (line);
d1587 9
a1595 3
    **	Now, let's get a socket set up from the server for the data.
    */
#ifdef INET6
d1600 1
d1602 6
a1607 5
		    hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
		    NI_NUMERICHOST|NI_NUMERICSERV);
	    HTSprintf0 (&line, gettext("socket failed: family %d addr %s port %s."),
		    res->ai_family, hostbuf, portbuf);
	    _HTProgress (line);
a1610 6
#else
    *s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (*s == -1) {
	HTAlert(gettext("socket failed."));
	return HT_NO_DATA;
    }
d1615 6
a1620 6
    /*
    **	Make the socket non-blocking, so the connect can be canceled.
    **	This means that when we issue the connect we should NOT
    **	have to wait for the accept on the other end.
    */
    {
d1622 2
a1623 1
	int ret = fcntl(*s, F_SETFL, O_NONBLOCK);
d1625 2
a1626 2
	int val = 1;
	int ret = IOCTL(*s, FIONBIO, &val);
d1628 3
a1630 3
	if (ret == -1)
	    _HTProgress(gettext("Could not make connection non-blocking."));
    }
d1634 5
a1638 5
    /*
    **	Issue the connect.  Since the server can't do an instantaneous
    **	accept and we are non-blocking, this will almost certainly return
    **	a negative status.
    */
d1640 1
a1640 1
    if (socks_flag) {
d1642 1
a1642 1
	status = Rconnect(*s, res->ai_addr, res->ai_addrlen);
d1644 2
a1645 2
	status = Rconnect(*s, (struct sockaddr*)&soc_address,
			  sizeof(soc_address));
d1647 5
a1651 5
	/*
	**  For long Rbind.
	*/
	socks_bind_remoteAddr = soc_address.sin_addr.s_addr;
    } else
d1654 1
a1654 1
    status = connect(*s, res->ai_addr, res->ai_addrlen);
d1656 1
a1656 1
    status = connect(*s, (struct sockaddr*)&soc_address, sizeof(soc_address));
d1659 20
a1678 20
    /*
    **	According to the Sun man page for connect:
    **	   EINPROGRESS	       The socket is non-blocking and the  con-
    **			       nection cannot be completed immediately.
    **			       It is possible to select(2) for	comple-
    **			       tion  by  selecting the socket for writ-
    **			       ing.
    **	According to the Motorola SVR4 man page for connect:
    **	   EAGAIN	       The socket is non-blocking and the  con-
    **			       nection cannot be completed immediately.
    **			       It is possible to select for  completion
    **			       by  selecting  the  socket  for writing.
    **			       However, this is only  possible	if  the
    **			       socket  STREAMS	module	is  the topmost
    **			       module on  the  protocol  stack	with  a
    **			       write  service  procedure.  This will be
    **			       the normal case.
    */
    if ((status < 0) &&
	(SOCKET_ERRNO == EINPROGRESS
d1680 1
a1680 1
	 || SOCKET_ERRNO == EAGAIN
d1682 4
a1685 4
	 )) {
	struct timeval select_timeout;
	int ret;
	int tries=0;
d1688 1
a1688 1
	HTInetStatus("this socket's first connect");
d1690 3
a1692 3
	ret = 0;
	while (ret <= 0) {
	    fd_set writefds;
d1694 5
a1698 5
	    /*
	    **	Protect against an infinite loop.
	    */
	    if ((tries++/10) >= connect_timeout) {
		HTAlert(gettext("Connection failed (too many retries)."));
d1700 3
a1702 2
		FREE(line);
		freeaddrinfo(res0);
d1704 2
a1705 3
		return HT_NO_DATA;
	    }

d1707 2
a1708 2
	    select_timeout.tv_sec = connect_timeout;
	    select_timeout.tv_usec = 0;
d1710 2
a1711 2
	    select_timeout.tv_sec = 0;
	    select_timeout.tv_usec = 100000;
d1713 2
a1714 2
	    FD_ZERO(&writefds);
	    FD_SET((unsigned) *s, &writefds);
d1716 4
a1719 4
	    if (socks_flag)
		ret = Rselect((unsigned)*s + 1, NULL,
			      (void *)&writefds, NULL, &select_timeout);
	    else
d1721 5
a1725 1
	    ret = select((unsigned)*s + 1, NULL, (void *)&writefds, NULL, &select_timeout);
d1728 3
a1730 3
	    if (tries == 1) {
		HTInetStatus("this socket's first select");
	    }
d1732 6
a1737 6
	    /*
	    **  If we suspend, then it is possible that select will be
	    **  interrupted.  Allow for this possibility. - JED
	    */
	    if ((ret == -1) && (errno == EINTR))
		continue;
d1740 3
a1742 3
	    if (ret < 0) {
		HTInetStatus("failed select");
	    }
a1743 14
	    /*
	    **	Again according to the Sun and Motorola man pages for connect:
	    **	   EALREADY	       The socket is non-blocking and a  previ-
	    **			       ous  connection attempt has not yet been
	    **			       completed.
	    **	Thus if the SOCKET_ERRNO is NOT EALREADY we have a real error,
	    **	and should break out here and return that error.
	    **	Otherwise if it is EALREADY keep on trying to complete the
	    **	connection.
	    */
	    if ((ret < 0) && (SOCKET_ERRNO != EALREADY)) {
		status = ret;
		break;
	    } else if (ret > 0) {
d1745 19
a1763 4
		**  Extra check here for connection success, if we try to
		**  connect again, and get EISCONN, it means we have a
		**  successful connection.  But don't check with SOCKS.
		*/
d1765 3
a1767 3
		if (socks_flag) {
		    status = 0;
		} else {
d1770 1
a1770 1
		status = connect(*s, res->ai_addr, res->ai_addrlen);
d1772 2
a1773 2
		status = connect(*s, (struct sockaddr*)&soc_address,
				 sizeof(soc_address));
d1776 6
a1781 7
		/*
		**  A UCX feature: Instead of returning EISCONN
		**		 UCX returns EADDRINUSE.
		**  Test for this status also.
		*/
		if ((status < 0) && ((SOCKET_ERRNO == EISCONN) ||
				     (SOCKET_ERRNO == EADDRINUSE)))
d1783 1
a1783 1
		if ((status < 0) && (SOCKET_ERRNO == EISCONN))
d1785 3
a1787 3
		{
		    status = 0;
		}
d1789 3
a1791 3
		if (status && (SOCKET_ERRNO == EALREADY)) /* new stuff LJM */
		    ret = 0; /* keep going */
		else {
d1793 3
a1795 3
		    if (status < 0) {
			HTInetStatus("confirm-ready connect");
		    }
d1797 2
a1798 2
		    break;
		}
d1800 2
a1802 2
#endif /* SOCKS */
	    }
d1804 1
a1804 1
	    else if (!socks_flag)
d1806 1
a1806 1
	    else
d1808 14
a1821 13
	    {
		/*
		**  The select says we aren't ready yet.  Try to connect
		**  again to make sure.  If we don't get EALREADY or EISCONN,
		**  something has gone wrong.  Break out and report it.
		**
		**  For some reason, SVR4 returns EAGAIN here instead of
		**  EALREADY, even though the man page says it should be
		**  EALREADY.
		**
		**  For some reason, UCX pre 3 apparently returns
		**  errno = 18242 instead the EALREADY or EISCONN.
		*/
d1823 1
a1823 1
		status = connect(*s, res->ai_addr, res->ai_addrlen);
d1825 2
a1826 2
		status = connect(*s, (struct sockaddr*)&soc_address,
				 sizeof(soc_address));
d1828 2
a1829 2
		if ((status < 0) &&
		    (SOCKET_ERRNO != EALREADY
d1831 1
a1831 1
		    && SOCKET_ERRNO != EAGAIN
d1833 1
a1833 1
		    ) &&
d1835 1
a1835 1
		    (SOCKET_ERRNO != 18242) &&
d1837 1
a1837 1
		    (SOCKET_ERRNO != EISCONN)) {
d1839 1
a1839 1
		    HTInetStatus("confirm-not-ready connect");
d1841 2
a1842 1
		    break;
d1844 3
a1846 4
	    }
	    if (HTCheckForInterrupt()) {
		CTRACE((tfp, "*** INTERRUPTED in middle of connect.\n"));
		status = HT_INTERRUPTED;
d1848 1
a1848 1
		WSASetLastError(EINTR);
d1850 1
a1850 1
		SOCKET_ERRNO = EINTR;
d1852 2
a1853 1
		break;
a1855 1
    }
d1857 3
a1859 3
    else if (status < 0) {
	HTInetStatus("this socket's first and only connect");
    }
d1863 3
a1865 3
		NETCLOSE(*s);
		*s = -1;
		continue;
d1878 3
a1880 3
	**  The connect attempt failed or was interrupted,
	**  so close up the socket.
	*/
d1887 2
a1888 2
	**  Make the socket blocking again on good connect.
	*/
d1891 1
d1904 2
a1905 1
    freeaddrinfo(res0);
d1911 5
a1915 6
**  This is so interruptible reads can be implemented cleanly.
*/
PUBLIC int HTDoRead ARGS3(
	int,		fildes,
	void *,		buf,
	unsigned,	nbyte)
d1920 2
a1921 1
    int tries=0;
d1924 1
a1924 1
    time_t otime = time((time_t *)0);
d1933 2
a1934 2
	 *  0 can be a valid socket fd, but if it's a tty something must
	 *  have gone wrong. - kw
a1952 1

d1960 2
a1961 2
	**  Protect against an infinite loop.
	*/
a1970 1

d1973 1
a1973 1
	    time_t t = time((time_t *)0);
d1984 3
a1986 3
	**  If we suspend, then it is possible that select will be
	**  interrupted.  Allow for this possibility. - JED
	*/
d1991 1
a1991 1
	    FD_SET((unsigned)fildes, &readfds);
d1994 2
a1995 2
		ret = Rselect((unsigned)fildes + 1,
			      (void *)&readfds, NULL, NULL, &select_timeout);
d1998 2
a1999 2
		ret = select((unsigned)fildes + 1,
			     (void *)&readfds, NULL, NULL, &select_timeout);
d2018 1
a2018 1
    while ((nb = SOCKET_READ (fildes, buf, nbyte)) == -1) {
d2029 2
a2030 2
#else  /* UNIX */
    return SOCKET_READ (fildes, buf, nbyte);
d2033 1
a2033 1
#else  /* UCX && VAXC */
d2035 2
a2036 2
    **	VAXC and UCX problem only.
    */
d2038 1
a2038 1
    nb = SOCKET_READ (fildes, buf, nbyte);
d2040 1
a2040 1
	   "Read - nb,errno,vaxc$errno: %d %d %d\n", nb,errno,vaxc$errno));
d2042 1
a2042 1
	perror ("HTTCP.C:HTDoRead:read");	   /* RJF */
d2044 2
a2045 2
    **	An errno value of EPIPE and nb < 0 indicates end-of-file on VAXC.
    */
d2056 14
a2069 14
**  This is a fix for the difference between BSD's select() and
**  SVR4's select().  SVR4's select() can never return a value larger
**  than the total number of file descriptors being checked.  So, if
**  you select for read and write on one file descriptor, and both
**  are true, SVR4 select() will only return 1.  BSD select in the
**  same situation will return 2.
**
**	Additionally, BSD select() on timing out, will zero the masks,
**	while SVR4 does not.  This is fixed here as well.
**
**	Set your tabstops to 4 characters to have this code nicely formatted.
**
**	Jerry Whelan, guru@@bradley.edu, June 12th, 1993
*/
d2084 5
a2088 6
PUBLIC int BSDselect ARGS5(
	int,			nfds,
	fd_set *,		readfds,
	fd_set *,		writefds,
	fd_set *,		exceptfds,
	struct timeval *,	select_timeout)
d2090 1
a2090 2
    int rval,
    i;
d2097 1
a2097 1
    rval = select(nfds, readfds, writefds, exceptfds, select_timeout);
d2100 2
a2101 2
	case -1:
	    return(rval);
d2103 17
a2119 17
	case 0:
	    if (readfds != NULL)
		FD_ZERO(readfds);
	    if (writefds != NULL)
		FD_ZERO(writefds);
	    if (exceptfds != NULL)
		FD_ZERO(exceptfds);
	    return(rval);

	default:
	    for (i = 0, rval = 0; i < nfds; i++) {
		if ((readfds != NULL) && FD_ISSET(i, readfds))
		    rval++;
		if ((writefds != NULL) && FD_ISSET(i, writefds))
		    rval++;
		if ((exceptfds != NULL) && FD_ISSET(i, exceptfds))
		    rval++;
d2121 2
a2122 2
	    }
	    return(rval);
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d1920 1
a1920 1
#ifdef EXP_READPROGRESS
d1971 1
a1971 1
#ifdef EXP_READPROGRESS
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d28 1
a28 1
#include <sys/wait.h>
d35 4
d47 1
a47 1
	struct timeval * timeout));
a61 8
#ifndef FD_SETSIZE
#if defined(UCX) || defined(SOCKETSHR_TCP) || defined(CMU_TCP)
#define FD_SETSIZE 32
#else
#define FD_SETSIZE 256
#endif /* Limit # sockets to 32 for UCX, BSN - also SOCKETSHR and CMU, AH */
#endif /* FD_SETSIZE */

a70 1
extern BOOLEAN socks_flag;
d85 1
a85 1
**	returns 	a negative status in the Unix way.
a86 12
#ifndef PCNFS

#ifdef VMS
#include <perror.h>
#ifndef errno
extern int errno;
#endif /* !errno */
#endif /* VMS */

#ifndef VM
#ifndef VMS
#ifndef THINK_C
d93 6
a98 3
#endif /* !THINK_C */
#endif /* !VMS */
#endif /* !VM */
d100 7
a106 6
#endif	/* !PCNFS */

#ifdef _WINDOWS_NSL
	 char host[512];
	 struct hostent  *phost;	/* Pointer to host - See netdb.h */
	 int donelookup;
d108 1
a108 1
unsigned long _fork_func (void *arglist)
d110 12
a121 3
	 phost = gethostbyname(host);
	 donelookup = TRUE;
	 return (unsigned long)(phost);
d130 1
a130 3
#include <iodef.h>
#define IOC_OUT (int)0x40000000
extern int vaxc$get_sdc(), sys$qiow();
d151 1
a151 1
	errno = EBADF;
d170 1
a170 1
	errno = status;
d174 1
a174 1
	errno = iosb[0];
d181 3
d188 1
a188 1
	char *, 	where)
d190 2
a197 4
    CTRACE(tfp,
	"TCP: Error %d in `SOCKET_ERRNO' after call to %s() failed.\n\t%s\n",
	   SOCKET_ERRNO,  where,
	   /* third arg is transport/platform specific */
d199 2
a200 1
	   "(Error number not translated)");	/* What Is the VM equiv? */
d206 2
a207 1
	   vms_errno_string());
d209 1
d211 1
a211 1
	    strerror(SOCKET_ERRNO) : "(Error number not translated)"));
d217 2
a218 1
	   strerror(SOCKET_ERRNO));
d223 1
d225 1
a225 1
	    sys_errlist[SOCKET_ERRNO] : "Unknown error" ));
d230 1
a230 1
    CTRACE(tfp,
d232 2
a233 2
	   SOCKET_ERRNO);
    CTRACE(tfp,
d235 1
a235 1
	   vaxc$errno);
d239 2
d246 1
a246 1
    return -vmserrno;
d248 1
a248 1
    return -vaxc$errno;
d251 1
a251 1
    return -SOCKET_ERRNO;
d253 1
d301 1
a301 1
	SockA*, 	soc_in)
d303 8
a310 1
    static char string[16];
d317 1
d328 1
d342 1
a342 1
	CONST char *,	name)
d345 1
a345 1
    CONST char *cp = name;
d356 2
d359 1
a359 1
		return NO;
d361 1
a361 1
	if (!isalnum((unsigned char)*cp) &&
d367 1
a367 1
    return (*cp == '\0' || (*cp == '.' && iseg != 0 && cp[1] == '\0'));
a384 2
#ifndef DJGPP			/* much excluded! */

d402 1
a402 1
	CTRACE(tfp,"%s: %p ", msgprefix, phost);
d404 1
a404 1
	    CTRACE(tfp,"{ h_name = %p", phost->h_name);
d406 1
a406 1
		CTRACE(tfp, " \"%s\",", phost->h_name);
d408 1
a408 1
		CTRACE(tfp, ",");
d410 1
a410 1
	    CTRACE(tfp,"\n\t h_aliases = %p", phost->h_aliases);
d412 1
a412 1
		CTRACE(tfp, " {");
d414 1
a414 1
		    CTRACE(tfp,"%s %p \"%s\"",
d416 1
a416 1
			   *pcnt, *pcnt);
d418 2
a419 2
		CTRACE(tfp, "%s0x0 },\n\t",
		       (*phost->h_aliases ? ", " : " "));
d421 1
a421 1
		CTRACE(tfp, ",\n\t");
d423 3
a425 3
	    CTRACE(tfp," h_addrtype = %d,", phost->h_addrtype);
	    CTRACE(tfp," h_length = %d,\n\t", phost->h_length);
	    CTRACE(tfp," h_addr_list = %p", phost->h_addr_list);
d427 1
a427 1
		CTRACE(tfp, " {");
d429 1
a429 1
		    CTRACE(tfp,"%s %p",
d431 1
a431 1
			   *pcnt);
d433 1
a433 1
			CTRACE(tfp, "%s%d%s", (i==0 ? " \"" : "."),
d435 1
a435 1
			       (i+1 == phost->h_length ? "\"" : ""));
d439 1
a439 1
		    CTRACE(tfp, ", 0x0 } }");
d441 1
a441 1
		    CTRACE(tfp, " 0x0 } }");
d444 1
a444 1
		CTRACE(tfp, "}");
d447 1
a447 1
	CTRACE(tfp,"\n");
d460 9
d474 1
d534 2
a535 2
    ((struct hostent *)rehostent)->h_addrtype = phost->h_addrtype;
    ((struct hostent *)rehostent)->h_length = phost->h_length;
d544 1
a544 1
	((struct hostent *)rehostent)->h_addr_list = p_next_charptr;
d554 1
a554 1
	((struct hostent *)rehostent)->h_addr_list = NULL;
d558 1
a558 1
	((struct hostent *)rehostent)->h_name = p_next_char;
d566 1
a566 1
	((struct hostent *)rehostent)->h_name = NULL;
d570 1
a570 1
	((struct hostent *)rehostent)->h_aliases = p_next_charptr;
d588 1
a588 1
	((struct hostent *)rehostent)->h_aliases = NULL;
d593 1
a593 2

#define REHOSTENT_SIZE 128		/* not bigger than pipe buffer! */
d600 1
d603 1
d640 1
a640 1
	CONST char *,	str)
d643 3
a645 2
    CONST char *host = str;
#endif /* _WINDOWS_NSL */
d648 1
a648 4
    static struct {
	struct hostent	h;
	char		rest[REHOSTENT_SIZE];
    } aligned_full_rehostent;
d669 1
a669 1
	int child_errno;  /* maybe not very useful */
d679 4
d684 1
a684 1
	CTRACE(tfp, "LYGetHostByName: Can't parse `NULL'.\n");
d688 1
a688 1
    CTRACE(tfp, "LYGetHostByName: parsing `%s'.\n", str);
d692 1
a692 1
	CTRACE (tfp, "LYGetHostByName: INTERRUPTED for '%s'.\n", str);
d697 4
d704 3
d709 1
a712 6
#ifdef _WINDOWS_NSL
    strncpy(host, str, (size_t)512);
#else
    host = str;
#endif /*  _WINDOWS_NSL */

d714 1
a714 1
    CTRACE(tfp, "LYGetHostByName: Calling gethostbyname(%s)\n", host);
d717 1
a717 1
    CTRACE_FLUSH(tfp);  /* so child messages will not mess parent log */
d729 4
d737 8
a744 3
	pid_t fpid, waitret;
	int pfd[2], selret, readret, waitstat = 0;
	time_t start_time = time(NULL);
d746 2
a747 2
	struct timeval timeout;
	int dns_patience = 30; /* how many seconds will we wait for DNS? */
d766 26
d829 5
d838 5
d844 1
d846 1
d848 1
d850 1
a850 1
	    CTRACE(tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost);
d868 4
d878 1
d898 8
d918 1
a918 1
	while (child_exited || time(NULL) - start_time < dns_patience) {
d938 2
a939 2
	    timeout.tv_sec = 1;
	    timeout.tv_usec = 0;
d949 1
a949 1
		selret = Rselect(pfd[0] + 1, (void *)&readfds, NULL, NULL, &timeout);
d952 1
a952 1
		selret = select(pfd[0] + 1, (void *)&readfds, NULL, NULL, &timeout);
d961 3
a963 2
		    errno = statuses.child_errno;
		    if (statuses.h_errno_valid)
d965 35
d1015 1
a1015 1
	    	    }
d1055 1
a1055 1
		CTRACE(tfp, "LYGetHostByName: INTERRUPTED gethostbyname.\n");
d1070 2
a1071 2
		CTRACE(tfp, "LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",
		       (int)waitret, waitstat);
d1073 2
a1074 2
		CTRACE(tfp, "LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
		       (int)waitret, waitstat);
d1077 2
a1078 2
		    CTRACE(tfp, "LYGetHostByName: NSL_FORK child %d dumped core!\n",
			   (int)waitret);
d1082 2
a1083 2
		CTRACE(tfp, "LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
		       (int)waitret, waitstat);
d1094 31
a1124 35
#ifdef __BORLANDC__
		HANDLE hThread, dwThreadID;
#else
		unsigned long hThread, dwThreadID;
#endif /* __BORLANDC__ */
		phost = (struct hostent *) NULL;
		hThread = CreateThread((void *)NULL, 4096UL,
#ifdef __BORLANDC__
			 (LPTHREAD_START_ROUTINE)_fork_func,
#else
			 (unsigned long (*)())_fork_func,
#endif /* __BORLANDC__ */
			 (void *)NULL, 0UL, (unsigned long *)&dwThreadID);
		if (!hThread)
			 MessageBox((void *)NULL, "CreateThread",
				"CreateThread Failed", 0L);

		donelookup = FALSE;
		while (!donelookup)
			if (HTCheckForInterrupt())
			 {
			  /* Note that host is a character array and is not freed */
			  /* to avoid possible subthread problems: */
			  if (!CloseHandle(hThread))
				 MessageBox((void *)NULL, "CloseHandle","CloseHandle Failed",
						0L);
			  lynx_nsl_status = HT_INTERRUPTED;
			  return NULL;
			};
		if (phost) {
		    lynx_nsl_status = HT_OK;
		    result_phost = phost;
		} else {
		    lynx_nsl_status = HT_ERROR;
		    goto failed;
d1126 12
a1137 1
    };
d1142 1
a1142 1
	phost = gethostbyname((char *)host);	/* See netdb.h */
d1144 1
a1144 1
	CTRACE(tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost);
d1159 1
a1159 1
    CTRACE(tfp, "LYGetHostByName: Resolved name to a hostent.\n");
d1165 2
a1166 2
    CTRACE(tfp, "LYGetHostByName: Can't find internet node name `%s'.\n",
		host);
a1169 2
#endif /* from here on DJGPP joins us again. */

d1183 2
a1184 1
PUBLIC int HTParseInet ARGS2(
d1190 1
d1196 1
a1196 1
	CTRACE(tfp, "HTParseInet: Can't parse `NULL'.\n");
d1199 1
a1199 1
    CTRACE(tfp, "HTParseInet: parsing `%s'.\n", str);
d1201 1
a1201 1
	CTRACE (tfp, "HTParseInet: INTERRUPTED for '%s'.\n", str);
d1205 1
a1205 1
    strncpy(host, str, (size_t)512);
d1214 1
d1216 2
a1217 2
#ifdef unix
	    soc_in->sin_port = htons(atol(port));
d1220 1
a1220 1
	    soc_in->sdn_objnum = (unsigned char)(strtol(port, (char**)0, 10));
d1222 1
a1222 1
	    soc_in->sin_port = htons((unsigned short)strtol(port,(char**)0,10));
d1225 1
a1225 1
#ifdef SUPPRESS 	/* 1. crashes!?!.  2. Not recommended */
d1231 1
a1231 1
		CTRACE(tfp, "TCP: Unknown service %s\n", port);
d1235 7
d1251 2
a1252 2
    CTRACE(tfp, "DECnet: Parsed address as object number %d on host %.6s...\n",
		soc_in->sdn_objnum, host);
d1256 1
a1256 1
	char *strptr = host;
d1260 1
a1260 1
	    } else if (!isdigit(*strptr)) {
d1273 2
a1274 5
    if (dotcount_ip == 3) {   /* Numeric node address: */

#ifdef DJGPP
	soc_in->sin_addr.s_addr = htonl(aton(host));
#else
d1283 1
a1283 1
	    CTRACE(tfp, "inet_aton(%s) returns error\n", host);
a1293 1
#endif /* DJGPP */
d1297 2
a1298 1
    } else {		    /* Alphanumeric node name: */
d1301 1
a1301 1
	CTRACE(tfp, "HTParseInet: Calling LYGetHostByName(%s)\n", host);
a1303 10
#ifdef DJGPP
	if (!valid_hostname(host)) {
	    FREE(host);
	    return HT_NOT_ACCEPTABLE; /* only HTDoConnect checks this. */
	}
	soc_in->sin_addr.s_addr = htonl(resolve(host));
	if (soc_in->sin_addr.s_addr == 0) {
	    goto failed;
	}
#else /* !DJGPP: */
d1308 1
a1308 1
#else /* !DJGPP, !_WINDOWS_NSL: */
d1332 2
a1333 2
#endif /* !DJGPP, !_WINDOWS_NSL */
#endif /* !DJGPP */
d1340 1
a1340 1
    CTRACE(tfp, "HTParseInet: Parsed address as port %d, IP address %d.%d.%d.%d\n",
d1345 1
a1345 1
		(int)*((unsigned char *)(&soc_in->sin_addr)+3));
d1351 2
a1352 2
    CTRACE(tfp, "HTParseInet: Can't find internet node name `%s'.\n",
		host);
d1357 6
a1362 5
    case HT_NOT_ACCEPTABLE:
    case HT_INTERRUPTED:
	return lynx_nsl_status;
    default:
    return -1;
d1364 43
d1408 1
a1424 4
#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN 64		/* Arbitrary limit */
#endif /* MAXHOSTNAMELEN */

d1432 4
d1437 1
d1442 1
a1442 1
	return; 			/* Already done */
d1453 4
a1456 2
    if (strchr(hostname,'.') == NULL) { 	  /* Not full address */
	domain_name = getenv("UCX$BIND_DOMAIN");
d1463 1
a1463 1
    CTRACE(tfp, "TCP: Local host name is %s\n", hostname);
d1467 16
d1485 2
a1486 2
	CTRACE(tfp, "TCP: Can't find my own internet node address for `%s'!!\n",
		    name);
d1491 3
a1493 2
    CTRACE(tfp, "     Name server says that I am `%s' = %s\n",
		hostname, HTInetString(&HTHostAddress));
d1505 5
d1511 1
a1511 1
**  Interruptable connect as implemented for Mosaic by Marc Andreesen
d1517 1
a1517 1
	char *, 	protocol,
d1521 1
a1521 3
    struct sockaddr_in soc_address;
    struct sockaddr_in *soc_in = &soc_address;
    int status;
d1526 5
d1537 2
a1538 1
    soc_in->sin_port = htons(default_port);
d1554 1
a1554 1
    HTSprintf0 (&line, gettext("Looking up %s."), host);
d1556 11
d1587 1
d1589 1
a1589 1
    HTSprintf0 (&line, gettext("Making %s connection to %s."), protocol, host);
d1597 15
d1617 1
d1619 1
a1619 1
#ifndef DOSPATH
d1637 1
a1637 1
#endif /* !DOSPATH */
d1646 3
d1651 1
d1658 3
d1662 2
a1663 1
#ifndef DJGPP
d1683 6
a1688 2
	(SOCKET_ERRNO == EINPROGRESS || SOCKET_ERRNO == EAGAIN)) {
	struct timeval timeout;
d1692 3
d1702 6
a1707 2
	    if (tries++ >= 180000) {
		HTAlert(gettext("Connection failed for 180,000 tries."));
d1712 2
a1713 1
	    timeout.tv_sec = 100;
d1715 2
a1716 1
	    timeout.tv_sec = 0;
a1717 1
	    timeout.tv_usec = 100000;
d1719 1
a1719 1
	    FD_SET(*s, &writefds);
d1722 2
a1723 2
		ret = Rselect(FD_SETSIZE, NULL,
			      (void *)&writefds, NULL, &timeout);
d1726 1
a1726 1
	    ret = select(FD_SETSIZE, NULL, (void *)&writefds, NULL, &timeout);
d1728 11
a1738 6
	   /*
	   **  If we suspend, then it is possible that select will be
	   **  interrupted.  Allow for this possibility. - JED
	   */
	   if ((ret == -1) && (errno == EINTR))
	     continue;
d1740 5
d1769 3
d1774 1
d1792 6
a1797 1
		else
d1799 1
d1822 3
d1827 1
d1829 5
a1833 1
		    (SOCKET_ERRNO != EALREADY && SOCKET_ERRNO != EAGAIN) &&
d1838 3
d1845 1
a1845 1
		CTRACE(tfp, "*** INTERRUPTED in middle of connect.\n");
d1847 3
d1851 1
d1856 21
a1876 2
#endif /* !DJGPP */
    if (status < 0) {
d1883 1
a1883 1
#ifndef DOSPATH
d1899 1
a1899 1
#endif /* !DOSPATH */
d1901 4
d1913 1
a1913 1
	void *, 	buf,
d1918 1
a1918 1
    struct timeval timeout;
d1920 4
d1935 1
a1935 1
	    CTRACE(tfp, "HTDoRead - refusing to read fd 0 which is a tty!\n");
d1944 3
d1948 1
d1963 3
d1967 1
d1971 12
d1988 2
a1989 2
	    timeout.tv_sec = 0;
	    timeout.tv_usec = 100000;
d1991 1
a1991 1
	    FD_SET(fildes, &readfds);
d1994 2
a1995 2
		ret = Rselect(FD_SETSIZE,
			      (void *)&readfds, NULL, NULL, &timeout);
d1998 2
a1999 2
		ret = select(FD_SETSIZE,
			     (void *)&readfds, NULL, NULL, &timeout);
d2007 3
d2011 1
a2018 1
	int saved_errno = errno;
a2025 1
	errno = saved_errno;	/* our caller may check it */
d2039 2
a2040 2
    CTRACE(tfp,
	   "Read - nb,errno,vaxc$errno: %d %d %d\n", nb,errno,vaxc$errno);
d2048 1
a2048 1
	errno = 0;
d2089 1
a2089 1
	struct timeval *,	timeout)
d2096 1
a2096 1
	rval = Rselect(nfds, readfds, writefds, exceptfds, timeout);
d2099 1
a2099 1
    rval = select(nfds, readfds, writefds, exceptfds, timeout);
a2103 1
	    break;
a2112 1
	    break;
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 16
a17 16
 *			==========================
 *
 *	This code is in common between client and server sides.
 *
 *	16 Jan 92  TBL	Fix strtol() undefined on CMU Mach.
 *	25 Jun 92  JFG	Added DECNET option through TCP socket emulation.
 *	13 Sep 93  MD	Added correct return of vmserrorno for HTInetStatus.
 *			Added decoding of vms error message for MULTINET.
 *	7-DEC-1993 Bjorn S. Nilsson, ALEPH, CERN, VMS UCX ioctl() changes
 *			(done of Mosaic)
 *	19 Feb 94  Danny Mayer	Added Bjorn Fixes to Lynx version
 *	 7 Mar 94  Danny Mayer	Added Fix UCX version for full domain name
 *	20 May 94  Andy Harper	Added support for CMU TCP/IP transport
 *	17 Nov 94  Andy Harper	Added support for SOCKETSHR transport
 *	16 Jul 95  S. Bjorndahl added kluge to deal with LIBCMU bug
 */
d28 1
a28 1
#include <www_wait.h>
a34 7
#ifdef __DJGPP__
#include <netdb.h>
#endif /* __DJGPP__ */

#define LYNX_ADDRINFO	struct addrinfo
#define LYNX_HOSTENT	struct hostent

d38 6
a43 6
int BSDselect(int nfds,
	      fd_set * readfds,
	      fd_set * writefds,
	      fd_set * exceptfds,
	      struct timeval *select_timeout);

d58 8
d67 3
a69 3
 *  Module-Wide variables
 */
static char *hostname = NULL;	/* The name of this host */
d72 2
a73 2
 *  PUBLIC VARIABLES
 */
d75 2
a76 1
unsigned long socks_bind_remoteAddr;	/* for long Rbind */
d79 1
a79 1
/* PUBLIC SockA HTHostAddress; *//* The internet address of the host */
d83 21
a103 9
 *	------------------
 *
 *  On entry,
 *	where		gives a description of what caused the error
 *	global errno	gives the error number in the Unix way.
 *
 *  On return,
 *	returns		a negative status in the Unix way.
 */
d106 1
a106 1
extern char *sys_errlist[];	/* see man perror on cernvax */
d110 5
a114 6
#ifdef __DJGPP__
static int ResolveYield(void)
{
    return HTCheckForInterrupt()? 0 : 1;
}
#endif
d116 4
a119 6
/*
 * This chunk of code is used in both win32 and cygwin.
 */
#if defined(_WINDOWS_NSL)
static LYNX_HOSTENT *phost;	/* Pointer to host - See netdb.h */
static int donelookup;
d121 1
a121 1
static unsigned long __stdcall _fork_func(void *arg)
d123 3
a125 15
    const char *host = (const char *) arg;

#ifdef SH_EX
    unsigned long addr;

    addr = (unsigned long) inet_addr(host);
    if (addr != INADDR_NONE)
	phost = gethostbyaddr((char *) &addr, sizeof(addr), AF_INET);
    else
	phost = gethostbyname(host);
#else
    phost = gethostbyname(host);
#endif
    donelookup = TRUE;
    return (unsigned long) (phost);
d131 11
a141 8
 *  A routine to mimic the ioctl function for UCX.
 *  Bjorn S. Nilsson, 25-Nov-1993. Based on an example in the UCX manual.
 */
#include <HTioctl.h>

int HTioctl(int d,
	    int request,
	    int *argp)
d156 2
a157 2
    if ((sdc = vaxc$get_sdc(d)) == 0) {
	set_errno(EBADF);
d160 2
a161 3
    ioctl_desc.opt = UCX$C_IOCTL;
    ioctl_desc.len = sizeof(struct comm);

d166 1
a166 1
	p6 = (char *) &ioctl_desc;
d169 1
a169 1
	p5 = (char *) &ioctl_desc;
d173 2
a174 2
    ioctl_comm.addr = (char *) argp;
    status = sys$qiow(0, sdc, fun, iosb, 0, 0, 0, 0, 0, 0, p5, p6);
d176 1
a176 1
	set_errno(status);
d180 1
a180 1
	set_errno(iosb[0]);
a186 3
#define MY_FORMAT "TCP: Error %d in `SOCKET_ERRNO' after call to %s() failed.\n\t%s\n"
	   /* third arg is transport/platform specific */

d188 4
a191 3
 *	---------------------
 */
int HTInetStatus(const char *where)
a192 3
    int status;
    int saved_errno = errno;

d199 4
d204 1
a204 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    "(Error number not translated)"));	/* What Is the VM equiv? */
d210 1
a210 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    vms_errno_string()));
d212 2
a213 3
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    ((SOCKET_ERRNO > 0 && SOCKET_ERRNO <= 65) ?
	     strerror(SOCKET_ERRNO) : "(Error number not translated)")));
d219 1
a219 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    strerror(SOCKET_ERRNO)));
d224 2
a225 3
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    (SOCKET_ERRNO < sys_nerr ?
	     sys_errlist[SOCKET_ERRNO] : "Unknown error")));
d230 6
a235 6
    CTRACE((tfp,
	    "         Unix error number (SOCKET_ERRNO) = %ld dec\n",
	    SOCKET_ERRNO));
    CTRACE((tfp,
	    "         VMS error (vaxc$errno)    = %lx hex\n",
	    vaxc$errno));
a238 2
    set_errno(saved_errno);

d241 2
a242 2
     * uerrno and errno happen to be zero if vmserrno <> 0
     */
d244 1
a244 1
    status = -vmserrno;
d246 1
a246 1
    status = -vaxc$errno;
d249 1
a249 1
    status = -SOCKET_ERRNO;
a250 1
    return status;
d254 16
a269 15
 *	----------------------
 *
 * On entry,
 *	*pp	    points to first character to be interpreted, terminated by
 *		    non 0:9 character.
 *	*pstatus    points to status already valid
 *	maxvalue    gives the largest allowable value.
 *
 * On exit,
 *	*pp	    points to first unread character
 *	*pstatus    points to status updated iff bad
 */
unsigned int HTCardinal(int *pstatus,
			char **pp,
			unsigned int max_value)
d272 2
a273 3

    if ((**pp < '0') || (**pp > '9')) {		/* Null string is error */
	*pstatus = -3;		/* No number where one expected */
d279 1
a279 1
	n = n * 10 + *((*pp)++) - '0';
d282 1
a282 1
	*pstatus = -4;		/* Cardinal outside range */
d289 1
a289 1
#ifndef DECNET			/* Function only used below for a trace message */
d291 8
a298 7
 *	----------------------------------------
 *
 *  On exit,
 *	returns a pointer to a static string which must be copied if
 *		it is to be kept.
 */
const char *HTInetString(SockA * soc_in)
d300 1
a300 10
#ifdef INET6
    static char hostbuf[MAXHOSTNAMELEN];

    getnameinfo((struct sockaddr *) soc_in,
		SOCKADDR_LEN(soc_in),
		hostbuf, sizeof(hostbuf), NULL, 0, NI_NUMERICHOST);
    return hostbuf;
#else
    static char string[20];

d302 4
a305 4
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 0),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 1),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 2),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 3));
a306 1
#endif /* INET6 */
d311 20
a330 20
 *	-------------------------------------------------
 *
 *  Checks whether
 *  - contains only valid chars for domain names (actually, the
 *    restrictions are somewhat relaxed),
 *  - no leading dots or empty segments,
 *  - no segment starts with '-' or '+' [this protects telnet command],
 *  - max. length of dot-separated segment <= 63 (RFC 1034,1035),
 *  - total length <= 254 (if it ends with dot) or 253 (otherwise)
 *     [an interpretation of RFC 1034,1035, although RFC 1123
 *      suggests 255 as limit - kw].
 *
 *  Note: user (before '@@') and port (after ':') components from
 *      host part of URL should be already stripped (if appropriate)
 *      from the input string.
 *
 *  On exit,
 *	returns 1 if valid, otherwise 0.
 */
BOOL valid_hostname(char *name)
d332 2
a333 3
    int i = 1, iseg = 0;
    char *cp = name;

a343 2
	} else if (iseg == 0 && (*cp == '-' || *cp == '+')) {
	    return NO;
d345 1
a345 1
	    return NO;
d347 1
a347 1
	if (!isalnum(UCH(*cp)) &&
d353 1
a353 1
    return (BOOL) (*cp == '\0' || (*cp == '.' && iseg != 0 && cp[1] == '\0'));
d358 6
a363 5
 *  Function to allow us to be killed with a normal signal (not
 *  SIGKILL), but don't go through normal libc exit() processing, which
 *  would screw up parent's stdio.  -BL
 */
static void quench(int sig GCC_UNUSED)
d369 3
a371 1
int lynx_nsl_status = HT_OK;
d374 1
a374 1
#define DEBUG_HOSTENT_CHILD	/* for NSL_FORK, may screw up trace file */
d377 9
a385 8
 *  Two auxiliary functions for name lookup and LYNX_HOSTENT.
 *
 *  dump_hostent - dumps the contents of a LYNX_HOSTENT to the
 *  trace log or stderr, including all pointer values, strings, and
 *  addresses, in a format inspired by gdb's print format. - kw
 */
static void dump_hostent(const char *msgprefix,
			 const LYNX_HOSTENT *phost)
d390 1
a390 2

	CTRACE((tfp, "%s: %p ", msgprefix, phost));
d392 1
a392 1
	    CTRACE((tfp, "{ h_name = %p", phost->h_name));
d394 1
a394 1
		CTRACE((tfp, " \"%s\",", phost->h_name));
d396 1
a396 1
		CTRACE((tfp, ","));
d398 1
a398 1
	    CTRACE((tfp, "\n\t h_aliases = %p", phost->h_aliases));
d400 1
a400 1
		CTRACE((tfp, " {"));
d402 3
a404 3
		    CTRACE((tfp, "%s %p \"%s\"",
			    (pcnt == phost->h_aliases ? " " : ", "),
			    *pcnt, *pcnt));
d406 2
a407 2
		CTRACE((tfp, "%s0x0 },\n\t",
			(*phost->h_aliases ? ", " : " ")));
d409 1
a409 1
		CTRACE((tfp, ",\n\t"));
d411 3
a413 3
	    CTRACE((tfp, " h_addrtype = %d,", phost->h_addrtype));
	    CTRACE((tfp, " h_length = %d,\n\t", phost->h_length));
	    CTRACE((tfp, " h_addr_list = %p", phost->h_addr_list));
d415 1
a415 1
		CTRACE((tfp, " {"));
d417 3
a419 3
		    CTRACE((tfp, "%s %p",
			    (pcnt == phost->h_addr_list ? "" : ","),
			    *pcnt));
d421 3
a423 3
			CTRACE((tfp, "%s%d%s", (i == 0 ? " \"" : "."),
				(int) *((unsigned char *) (*pcnt) + i),
				(i + 1 == phost->h_length ? "\"" : "")));
d427 1
a427 1
		    CTRACE((tfp, ", 0x0 } }"));
d429 1
a429 1
		    CTRACE((tfp, " 0x0 } }"));
d432 1
a432 1
		CTRACE((tfp, "}"));
d435 1
a435 1
	CTRACE((tfp, "\n"));
d441 11
a451 19
 *  fill_rehostent - copies as much as possible relevant content from
 *  the LYNX_HOSTENT pointed to by phost to the char buffer given
 *  by rehostent, subject to maximum output length rehostentsize,
 *  following pointers and building self-contained output which can be
 *  cast to a LYNX_HOSTENT. - kw
 *  See also description of LYGetHostByName.
 */
#ifdef NSL_FORK

#define REHOSTENT_SIZE 128	/* not bigger than pipe buffer! */

typedef struct {
    LYNX_HOSTENT h;
    char rest[REHOSTENT_SIZE];
} AlignedHOSTENT;

static size_t fill_rehostent(char *rehostent,
			     size_t rehostentsize,
			     const LYNX_HOSTENT *phost)
a452 1
    AlignedHOSTENT *data = (AlignedHOSTENT *) rehostent;
d460 1
a460 1
    size_t curlen = sizeof(LYNX_HOSTENT);
a467 1

d491 1
a491 1
	for (pcnt = phost->h_addr_list + 1; *pcnt; pcnt++) {
d502 1
a502 1
	for (pcnt = phost->h_aliases; *pcnt; pcnt++) {
d512 3
a514 3
    data->h.h_addrtype = phost->h_addrtype;
    data->h.h_length = phost->h_length;
    p_next_charptr = (char **) (rehostent + curlen);
d517 1
a517 1
	p_next_char += (num_addrs + 1) * sizeof(phost->h_addr_list[0]);
d519 1
a519 1
	p_next_char += (num_aliases + 1) * sizeof(phost->h_aliases[0]);
d522 2
a523 2
	data->h.h_addr_list = p_next_charptr;
	for (pcnt = phost->h_addr_list, i_addr = 0;
d532 1
a532 1
	data->h.h_addr_list = NULL;
d536 1
a536 1
	data->h.h_name = p_next_char;
d544 1
a544 1
	data->h.h_name = NULL;
d548 2
a549 2
	data->h.h_aliases = p_next_charptr;
	for (pcnt = phost->h_aliases, i_alias = 0;
d566 1
a566 1
	data->h.h_aliases = NULL;
d568 1
a568 1
    curlen = p_next_char - (char *) rehostent;
d571 2
a572 1
#endif /* NSL_FORK */
a577 1

a578 1
#ifndef h_errno			/* there may be a macro as well as the extern data */
a580 1
#endif
d583 35
a617 34
 *	------------------------------------------------
 *
 *  On entry,
 *	str	points to the given host name, not numeric address,
 *		without colon or port number.
 *
 *  On exit,
 *	returns a pointer to a LYNX_HOSTENT in static storage,
 *	or NULL in case of error or user interruption.
 *
 *  The interface is intended to be exactly the same as for (Unix)
 *  gethostbyname(), except for the following:
 *
 *  If NSL_FORK is not used, the result of gethostbyname is returned
 *  directly.  Otherwise:
 *  All lists, addresses, and strings referred to by pointers in the
 *  returned struct are located, together with the returned struct
 *  itself, in a buffer of size REHOSTENT_SIZE.  If not everything fits,
 *  some info is omitted, but the function is careful to still return
 *  a valid structure, without truncating strings; it tries to return,
 *  in order of decreasing priority, the first address (h_addr), the
 *  official name (h_name), the additional addresses, then alias names.
 *
 *  If NULL is returned, the reason is made available in the global
 *  variable lynx_nsl_status, with one of the following values:
 *	HT_INTERRUPTED		Interrupted by user
 *	HT_NOT_ACCEPTABLE	Hostname detected as invalid
 *				(also sets h_errno)
 *	HT_H_ERRNO_VALID	An error occurred, and h_errno holds
 *				an appropriate value
 *	HT_ERROR		Resolver error, reason not known
 *	HT_INTERNAL		Internal error
 */
LYNX_HOSTENT *LYGetHostByName(char *str)
d619 3
a621 2
    char *host = str;

d624 4
a627 2
    static AlignedHOSTENT aligned_full_rehostent;

d629 4
a632 3
     * We could define rehosten directly as a static char
     * rehostent[REHOSTENT_SIZE], but the indirect approach via the above
     * struct should automatically take care of alignment requirements.
d634 7
a640 6
     * - this must be static, as we shall return a pointer to it which must
     *   remain valid, and
     * - we have to use the same rehostent in the child process as in the
     *   parent (its address in the parent's address space must be the same as
     *   in the child's, otherwise the internal pointers built by the child's
     *   call to fill_rehostent would be invalid when seen by the parent).  -kw
d642 1
a642 1
    char *rehostent = (char *) &aligned_full_rehostent;
d648 1
a648 1
	int child_errno;	/* sometimes useful to pass this on */
d656 1
a656 5
    LYNX_HOSTENT *result_phost = NULL;

#ifdef __DJGPP__
    _resolve_hook = ResolveYield;
#endif
d659 1
a659 1
	CTRACE((tfp, "LYGetHostByName: Can't parse `NULL'.\n"));
d663 1
a663 1
    CTRACE((tfp, "LYGetHostByName: parsing `%s'.\n", str));
d665 1
a665 1
    /*  Could disable this if all our callers already check - kw */
d667 1
a667 1
	CTRACE((tfp, "LYGetHostByName: INTERRUPTED for '%s'.\n", str));
a674 3
#ifdef _WINDOWS
	WSASetLastError(NO_RECOVERY);
#else
a676 1
#endif
d679 9
a687 2
#ifdef MVS			/* Outstanding problem with crash in MVS gethostbyname */
    CTRACE((tfp, "LYGetHostByName: Calling gethostbyname(%s)\n", host));
d690 1
a690 1
    CTRACE_FLUSH(tfp);		/* so child messages will not mess up parent log */
d696 4
a699 4
    /*
     * Start block for fork-based gethostbyname() with checks for interrupts. 
     * - Tom Zerucha (tz@@execpc.com) & FM
     */
a701 5

#if HAVE_SIGACTION
	sigset_t old_sigset;
	sigset_t new_sigset;
#endif
d703 6
a708 13
	 * Pipe, child pid, status buffers, start time, select() control
	 * variables.
	 */
	int fpid, waitret;
	int pfd[2], selret, readret;

#ifdef HAVE_TYPE_UNIONWAIT
	union wait waitstat;

#else
	int waitstat = 0;
#endif
	time_t start_time = time((time_t *) 0);
d710 2
a711 2
	struct timeval one_second;
	long dns_patience = 30;	/* how many seconds will we wait for DNS? */
d714 9
a722 8
	/*
	 * Reap any children that have terminated since last time through. 
	 * This might include children that we killed, then waited with WNOHANG
	 * before they were actually ready to be reaped.  (Should be max of 1
	 * in this state, but the loop is safe if waitpid() is implemented
	 * correctly:  returns 0 when children exist but none have exited; -1
	 * with errno == ECHILD when no children.) -BL
	 */
d730 2
a731 28
#if HAVE_SIGACTION
	/*
	 * Attempt to prevent a rare situation where the child could execute
	 * the Lynx signal handlers because it gets killed before it even has a
	 * chance to reset its handlers, resulting in bogus 'Exiting via
	 * interrupt' message and screen corruption or worse.
	 * Should that continue to be reported, for systems without
	 * sigprocmask(), we need to find a different solutions for those.  -
	 * kw 19990430
	 */
	sigemptyset(&new_sigset);
	sigaddset(&new_sigset, SIGTERM);
	sigaddset(&new_sigset, SIGINT);
#ifndef NOSIGHUP
	sigaddset(&new_sigset, SIGHUP);
#endif /* NOSIGHUP */
#ifdef SIGTSTP
	sigaddset(&new_sigset, SIGTSTP);
#endif /* SIGTSTP */
#ifdef SIGWINCH
	sigaddset(&new_sigset, SIGWINCH);
#endif /* SIGWINCH */
	sigprocmask(SIG_BLOCK, &new_sigset, &old_sigset);
#endif /* HAVE_SIGACTION */

	if ((fpid = fork()) == 0) {
	    LYNX_HOSTENT *phost;	/* Pointer to host - See netdb.h */

d733 4
a736 4
	     * Child - for the long call.
	     *
	     * Make sure parent can kill us at will.  -BL
	     */
d740 6
a745 5
	     * Also make sure the child does not run one of the signal handlers
	     * that may have been installed by Lynx if one of those signals
	     * occurs.  For example we don't want the child to remove temp
	     * files on ^C, let the parent deal with that.  - kw
	     */
a766 5
#if HAVE_SIGACTION
	    /* Restore signal mask to whatever it was before the fork. -kw */
	    sigprocmask(SIG_SETMASK, &old_sigset, NULL);
#endif /* HAVE_SIGACTION */

d768 2
a769 2
	     * Child won't use read side.  -BL
	     */
a770 5
#ifdef HAVE_H_ERRNO
	    /* to detect cases when it doesn't get set although it should */
	    h_errno = -2;
#endif
	    set_errno(0);
a771 1
	    statuses.child_errno = errno;
a772 1
#ifdef HAVE_H_ERRNO
a773 1
#endif
d775 1
a775 1
	    CTRACE((tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost));
d784 1
a784 1
		dump_hostent("CHILD fill_rehostent", (LYNX_HOSTENT *) rehostent);
d787 2
a788 2
	    if (rehostentlen <= sizeof(LYNX_HOSTENT) ||
		!OK_HOST((LYNX_HOSTENT *) rehostent)) {
d792 1
a792 5
		statuses.h_length = ((LYNX_HOSTENT *) rehostent)->h_length;
#ifdef HAVE_H_ERRNO
		if (h_errno == -2)	/* success, but h_errno unchanged? */
		    statuses.h_errno_valid = NO;
#endif
d795 5
a799 6
	     * Send variables indicating status of lookup to parent.  That
	     * includes rehostentlen, which the parent will use as the size for
	     * the second read (if > 0).
	     */
	    if (!statuses.child_errno)
		statuses.child_errno = errno;
d803 1
d806 2
a807 2
		 * Return our resulting rehostent through pipe...
		 */
d812 2
a813 2
		 * ...  or return error as exit code.
		 */
a816 7
#if HAVE_SIGACTION
	/*
	 * (parent) Restore signal mask to whatever it was before the fork.  -
	 * kw
	 */
	sigprocmask(SIG_SETMASK, &old_sigset, NULL);
#endif /* HAVE_SIGACTION */
d819 3
a821 3
	 * (parent) Wait until lookup finishes, or interrupt, or cycled too
	 * many times (just in case) -BL
	 */
d823 1
a823 1
	close(pfd[1]);		/* parent won't use write side -BL */
d825 3
a827 3
	if (fpid < 0) {		/* fork failed */
	    close(pfd[0]);
	    goto failed;
d830 1
a830 1
	while (child_exited || (long) (time((time_t *) 0) - start_time) < dns_patience) {
d834 9
a842 9
	     * This allows us to abort immediately, not after 1-second timeout,
	     * when user hits abort key.  Can't do this when using SLANG (or at
	     * least I don't know how), so SLANG users must live with up-to-1s
	     * timeout.  -BL
	     *
	     * Whoops -- we need to make sure stdin is actually selectable! 
	     * /dev/null isn't, on some systems, which makes some useful Lynx
	     * invocations fail.  -BL
	     */
a844 1

d850 2
a851 2
	    one_second.tv_sec = 1;
	    one_second.tv_usec = 0;
d854 5
a858 5
	    /*
	     * Return when data received, interrupted, or failed.  If nothing
	     * is waiting, we sleep for 1 second in select(), to be nice to the
	     * system.  -BL
	     */
d861 1
a861 1
		selret = Rselect(pfd[0] + 1, &readfds, NULL, NULL, &one_second);
d864 1
a864 1
		selret = select(pfd[0] + 1, &readfds, NULL, NULL, &one_second);
d868 2
a869 2
		 * First get status, including length of address.  -BL, kw
		 */
d873 2
a874 3
		    set_errno(statuses.child_errno);
#ifdef HAVE_H_ERRNO
		    if (statuses.h_errno_valid) {
d876 1
d878 2
a879 37
			 * If something went wrong in the child process other
			 * than normal lookup errors, and it appears that we
			 * have enough info to know what went wrong, generate
			 * diagnostic output.  ENOMEM observed on linux in
			 * processes constrained with ulimit.  It would be too
			 * unkind to abort the session, access to local files
			 * or through a proxy may still work.  - kw
			 */
			if (
#ifdef NETDB_INTERNAL		/* linux glibc: defined in netdb.h */
			       (errno && h_errno == NETDB_INTERNAL) ||
#endif
			       (errno == ENOMEM &&
				statuses.rehostentlen == 0 &&
			/* should probably be NETDB_INTERNAL if child
			   memory exhausted, but we may find that
			   h_errno remains unchanged. - kw */
				h_errno == -2)) {
#ifndef MULTINET
			    HTInetStatus("CHILD gethostbyname");
#endif
			    HTAlert(LYStrerror(statuses.child_errno));
			    if (errno == ENOMEM) {
				/*
				 * Not much point in continuing, right?  Fake a
				 * 'z', should shorten pointless guessing
				 * cycle.  - kw
				 */
				LYFakeZap(YES);
			    }
			}
		    }
#endif /* HAVE_H_ERRNO */
		    if (statuses.rehostentlen > sizeof(LYNX_HOSTENT)) {
			/*
			 * Then get the full reorganized hostent.  -BL, kw
			 */
d882 1
a882 1
			dump_hostent("Read from pipe", (LYNX_HOSTENT *) rehostent);
d886 1
a886 1
			    result_phost = (LYNX_HOSTENT *) rehostent;
d891 1
a891 1
		    }
d896 2
a897 2
		 * Make sure child is cleaned up.  -BL
		 */
d908 2
a909 2
	     * Clean up if child exited before & no data received.  -BL
	     */
d915 2
a916 2
	     * If child exited, loop once more looking for data.  -BL
	     */
d919 4
a922 4
		 * Data will be arriving right now, so make sure we don't
		 * short-circuit out for too many loops, and skip the interrupt
		 * check.  -BL
		 */
d928 2
a929 2
	     * Abort if interrupt key pressed.
	     */
d931 1
a931 1
		CTRACE((tfp, "LYGetHostByName: INTERRUPTED gethostbyname.\n"));
d946 2
a947 3
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",
			(int) waitret, WEXITSTATUS(waitstat)));
d949 2
a950 3
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
			(int) waitret, WTERMSIG(waitstat)));
d953 2
a954 3
		    CTRACE((tfp,
			    "LYGetHostByName: NSL_FORK child %d dumped core!\n",
			    (int) waitret));
d958 2
a959 3
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
			(int) waitret, WSTOPSIG(waitstat)));
d970 35
a1004 33
	HANDLE hThread, dwThreadID;

#ifndef __CYGWIN__
	if (!system_is_NT) {	/* for Windows9x */
	    unsigned long t;

	    t = (unsigned long) inet_addr(host);
	    if (t != INADDR_NONE)
		phost = gethostbyaddr((char *) &t, sizeof(t), AF_INET);
	    else
		phost = gethostbyname(host);
	} else {		/* for Windows NT */
#endif /* !__CYGWIN__ */
	    phost = (LYNX_HOSTENT *) NULL;
	    donelookup = FALSE;
	    WSASetLastError(WSAHOST_NOT_FOUND);

	    hThread = CreateThread(NULL, 4096UL, _fork_func, host, 0UL,
				   (unsigned long *) &dwThreadID);
	    if (!hThread)
		MessageBox(NULL, "CreateThread",
			   "CreateThread Failed", 0L);

	    while (!donelookup) {
		if (HTCheckForInterrupt()) {
		    /* Note that host is a character array and is not freed */
		    /* to avoid possible subthread problems: */
		    if (!CloseHandle(hThread)) {
			MessageBox((void *) NULL,
				   "CloseHandle", "CloseHandle Failed", 0L);
		    }
		    lynx_nsl_status = HT_INTERRUPTED;
		    return NULL;
d1006 1
a1006 12
	    }
#ifndef __CYGWIN__
	}
#endif /* !__CYGWIN__ */
	if (phost) {
	    lynx_nsl_status = HT_OK;
	    result_phost = phost;
	} else {
	    lynx_nsl_status = HT_ERROR;
	    goto failed;
	}
    }
d1010 2
a1011 3
	LYNX_HOSTENT *phost;

	phost = gethostbyname(host);	/* See netdb.h */
d1013 1
a1013 1
	CTRACE((tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost));
d1028 1
a1028 1
    CTRACE((tfp, "LYGetHostByName: Resolved name to a hostent.\n"));
d1033 3
a1035 3
  failed:
    CTRACE((tfp, "LYGetHostByName: Can't find internet node name `%s'.\n",
	    host));
d1039 3
d1043 14
a1056 13
 *	-------------------------------------
 *
 *  On entry,
 *	str	points to a string with a node name or number,
 *		with optional trailing colon and port number.
 *	soc_in	points to the binary internet or decnet address field.
 *
 *  On exit,
 *	*soc_in is filled in.  If no port is specified in str, that
 *		field is left unchanged in *soc_in.
 */
#ifndef INET6
static int HTParseInet(SockA * soc_in, const char *str)
d1060 1
a1060 1
    char *strptr;
d1062 1
d1065 1
a1065 1
	CTRACE((tfp, "HTParseInet: Can't parse `NULL'.\n"));
d1068 1
a1068 1
    CTRACE((tfp, "HTParseInet: parsing `%s'.\n", str));
d1070 1
a1070 1
	CTRACE((tfp, "HTParseInet: INTERRUPTED for '%s'.\n", str));
d1073 3
d1077 1
d1079 2
a1080 2
     * Parse port number if present.
     */
a1082 1
	strptr = port;
d1084 2
a1085 2
#ifdef UNIX
	    soc_in->sin_port = (PortNumber) htons(strtol(port, &strptr, 10));
d1088 1
a1088 1
	    soc_in->sdn_objnum = (unsigned char) (strtol(port, &strptr, 10));
d1090 1
a1090 1
	    soc_in->sin_port = htons((PortNumber) strtol(port, &strptr, 10));
d1093 1
a1093 1
#ifdef SUPPRESS			/* 1. crashes!?!.  2. URL syntax has number not name */
d1095 1
a1095 2
	    struct servent *serv = getservbyname(port, (char *) 0);

d1099 1
a1099 1
		CTRACE((tfp, "TCP: Unknown service %s\n", port));
a1102 5
	if (strptr && *strptr != '\0') {
	    FREE(host);
	    HTAlwaysAlert(NULL, gettext("Address has invalid port"));
	    return -1;
	}
d1104 1
d1107 4
a1110 4
     * Read Decnet node name.  @@@@ Should know about DECnet addresses, but it's
     * probably worth waiting until the Phase transition from IV to V.
     */
    soc_in->sdn_nam.n_len = min(DN_MAXNAML, strlen(host));	/* <=6 in phase 4 */
d1112 3
a1114 4
    CTRACE((tfp,
	    "DECnet: Parsed address as object number %d on host %.6s...\n",
	    soc_in->sdn_objnum, host));
#else /* parse Internet host: */
d1116 2
a1117 2
    if (*host >= '0' && *host <= '9') {		/* Test for numeric node address: */
	strptr = host;
d1121 1
a1121 1
	    } else if (!isdigit(UCH(*strptr))) {
d1132 7
a1138 4
     * Parse host number if present.
     */
    if (dotcount_ip == 3)	/* Numeric node address: */
    {
d1140 1
a1140 1
	soc_in->sin_addr.s_addr = inet_addr(host).s_addr;	/* See arpa/inet.h */
d1143 1
a1143 1
	soc_in->sin_addr = inet_addr(host);	/* See netinet/in.h */
d1147 2
a1148 1
	    CTRACE((tfp, "inet_aton(%s) returns error\n", host));
d1150 1
d1158 2
d1161 2
a1162 1
    } else {			/* Alphanumeric node name: */
d1164 2
a1165 2
#ifdef MVS			/* Outstanding problem with crash in MVS gethostbyname */
	CTRACE((tfp, "HTParseInet: Calling LYGetHostByName(%s)\n", host));
d1168 10
d1180 3
a1182 4
	if (!phost)
	    goto failed;
	memcpy((void *) &soc_in->sin_addr, phost->h_addr, phost->h_length);
#else /* !_WINDOWS_NSL */
d1184 1
a1184 2
	    LYNX_HOSTENT *phost;

d1187 1
a1187 2
	    if (!phost)
		goto failed;
d1190 8
a1197 9
	     * In LIBCMU, phost->h_length contains not the length of one
	     * address (four bytes) but the number of bytes in *h_addr, i.e.,
	     * some multiple of four.  Thus we need to hard code the value
	     * here, and remember to change it if/when IP addresses change in
	     * size.  :-( LIBCMU is no longer supported, and CMU users are
	     * encouraged to obtain and use SOCKETSHR/NETLIB instead.  - S. 
	     * Bjorndahl
	     */
	    memcpy((void *) &soc_in->sin_addr, phost->h_addr, 4);
d1199 1
a1199 2
	    if (!phost)
		goto failed;
d1203 1
a1203 1
	    memcpy((void *) &soc_in->sin_addr, phost->h_addr, phost->h_length);
d1206 4
d1212 1
a1212 2
	FREE(host);
    }				/* Alphanumeric node name */
d1214 14
a1227 14
    CTRACE((tfp,
	    "HTParseInet: Parsed address as port %d, IP address %d.%d.%d.%d\n",
	    (int) ntohs(soc_in->sin_port),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 0),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 1),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 2),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 3)));
#endif /* Internet vs. Decnet */

    return 0;			/* OK */

  failed:
    CTRACE((tfp, "HTParseInet: Can't find internet node name `%s'.\n",
	    host));
d1229 1
d1235 1
a1235 2
	return -1;
    }
a1236 42
#endif /* !INET6 */

#ifdef INET6
static LYNX_ADDRINFO *HTGetAddrInfo(const char *str,
				    const int defport)
{
    LYNX_ADDRINFO hints, *res;
    int error;
    char *p;
    char *s = NULL;
    char *host, *port;
    char pbuf[80];

    StrAllocCopy(s, str);

    if (s[0] == '[' && (p = strchr(s, ']')) != NULL) {
	*p++ = '\0';
	host = s + 1;
    } else {
	p = s;
	host = &s[0];
    }
    port = strrchr(p, ':');
    if (port) {
	*port++ = '\0';
    } else {
	sprintf(pbuf, "%d", defport);
	port = pbuf;
    }

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, port, &hints, &res);
    if (error || !res) {
	CTRACE((tfp, "HTGetAddrInfo: getaddrinfo(%s, %s): %s\n", host, port,
		gai_strerror(error)));
	res = NULL;
    }

    free(s);
    return res;
a1237 1
#endif /* INET6 */
d1241 4
a1244 4
 *	-------------------------------------------
 *
 */
static void free_HTTCP_hostname(void)
d1251 8
a1258 4
 *	-------------------------------------------
 *
 */
static void get_host_details(void)
d1260 1
a1260 2
    char name[MAXHOSTNAMELEN + 1];	/* The name of this host */

d1262 1
a1262 1
    char *domain_name;		/* The name of this host domain */
d1264 2
a1265 8
#ifdef NEED_HOST_ADDRESS	/* no -- needs name server! */
#ifdef INET6
    LYNX_ADDRINFO hints, *res;
    int error;

#else
    LYNX_HOSTENT *phost;	/* Pointer to host -- See netdb.h */
#endif /* INET6 */
d1270 1
a1270 1
	return;			/* Already done */
d1278 5
a1282 7
     * UCX doesn't give the complete domain name.  Get rest from UCX$BIND_DOM
     * logical.
     */
    if (strchr(hostname, '.') == NULL) {	/* Not full address */
	domain_name = LYGetEnv("UCX$BIND_DOMAIN");
	if (domain_name == NULL)
	    domain_name = LYGetEnv("TCPIP$BIND_DOMAIN");
d1287 1
a1287 1
    }
d1289 1
a1289 1
    CTRACE((tfp, "TCP: Local host name is %s\n", hostname));
d1291 2
a1292 18
#ifndef DECNET			/* Decnet ain't got no damn name server 8#OO */
#ifdef NEED_HOST_ADDRESS	/* no -- needs name server! */
#ifdef INET6
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_CANONNAME;
    error = getaddrinfo(name, NULL, &hints, &res);
    if (error || !res || !res->ai_canonname) {
	CTRACE((tfp, "TCP: %s: `%s'\n", gai_strerror(error), name));
	if (res)
	    freeaddrinfo(res);
	return;			/* Fail! */
    }
    StrAllocCopy(hostname, res->ai_canonname);
    memcpy(&HTHostAddress, res->ai_addr, res->ai_addrlen);
    freeaddrinfo(res);
#else
d1295 3
a1297 4
	CTRACE((tfp,
		"TCP: Can't find my own internet node address for `%s'!!\n",
		name));
	return;			/* Fail! */
d1301 2
a1302 3
#endif /* INET6 */
    CTRACE((tfp, "     Name server says that I am `%s' = %s\n",
	    hostname, HTInetString(&HTHostAddress)));
d1308 1
a1308 1
const char *HTHostName(void)
a1313 5
#ifndef MULTINET		/* SOCKET_ERRNO != errno ? */
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
#define SOCKET_DEBUG_TRACE	/* show errno status after some system calls */
#endif /* UCX && VAXC */
#endif /* MULTINET */
d1315 9
a1323 8
 *  Interruptible connect as implemented for Mosaic by Marc Andreesen
 *  and hacked in for Lynx years ago by Lou Montulli, and further
 *  modified over the years by numerous Lynx lovers. - FM
 */
int HTDoConnect(const char *url,
		const char *protocol,
		int default_port,
		int *s)
d1325 3
a1327 1
    int status = 0;
a1332 7
#ifdef INET6
    LYNX_ADDRINFO *res = 0, *res0 = 0;

#else
    struct sockaddr_in soc_address;
    struct sockaddr_in *soc_in = &soc_address;

d1334 2
a1335 2
     * Set up defaults.
     */
d1338 1
a1338 2
    soc_in->sin_port = htons((PortNumber) default_port);
#endif /* INET6 */
d1341 2
a1342 2
     * Get node name and optional port number.
     */
d1346 2
a1347 2
	 * If there's an @@ then use the stuff after it as a hostname.
	 */
d1354 2
a1355 13
    HTSprintf0(&line, "%s%s", WWW_FIND_MESSAGE, host);
    _HTProgress(line);
#ifdef INET6
    /* HTParseInet() is useless! */
    res0 = HTGetAddrInfo(host, default_port);
    if (res0 == NULL) {
	HTSprintf0(&line, gettext("Unable to locate remote host %s."), host);
	_HTProgress(line);
	FREE(host);
	FREE(line);
	return HT_NO_DATA;
    }
#else
d1360 3
a1362 3
		/* Not HTProgress, so warning won't be overwritten immediately;
		 * but not HTAlert, because typically there will be other
		 * alerts from the callers.  - kw
d1366 2
a1367 2
		HTSprintf0(&line,
			   gettext("Unable to locate remote host %s."), host);
a1375 1
#endif /* INET6 */
d1377 2
a1378 2
    HTSprintf0(&line, gettext("Making %s connection to %s"), protocol, host);
    _HTProgress(line);
d1383 2
a1384 3
     * Now, let's get a socket set up from the server for the data.
     */
#ifndef INET6
a1389 17
#else
    for (res = res0; res; res = res->ai_next) {
	*s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	if (*s == -1) {
	    char hostbuf[1024], portbuf[1024];

	    getnameinfo(res->ai_addr, res->ai_addrlen,
			hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
			NI_NUMERICHOST | NI_NUMERICSERV);
	    HTSprintf0(&line,
		       gettext("socket failed: family %d addr %s port %s."),
		       res->ai_family, hostbuf, portbuf);
	    _HTProgress(line);
	    FREE(line);
	    continue;
	}
#endif /* INET6 */
d1391 1
a1391 1
#if !defined(DOSPATH) || defined(__DJGPP__)
d1393 6
a1398 6
	/*
	 * Make the socket non-blocking, so the connect can be canceled.  This
	 * means that when we issue the connect we should NOT have to wait for
	 * the accept on the other end.
	 */
	{
d1400 1
a1400 2
	    int ret = fcntl(*s, F_SETFL, O_NONBLOCK);

d1402 2
a1403 2
	    int val = 1;
	    int ret = IOCTL(*s, FIONBIO, &val);
d1405 3
a1407 3
	    if (ret == -1)
		_HTProgress(gettext("Could not make connection non-blocking."));
	}
d1409 1
a1409 1
#endif /* !DOSPATH || __DJGPP__ */
d1411 9
d1421 4
a1424 17
	 * Issue the connect.  Since the server can't do an instantaneous
	 * accept and we are non-blocking, this will almost certainly return a
	 * negative status.
	 */
#ifdef SOCKS
	if (socks_flag) {
#ifdef INET6
	    status = Rconnect(*s, res->ai_addr, res->ai_addrlen);
#else
	    status = Rconnect(*s, (struct sockaddr *) &soc_address,
			      sizeof(soc_address));
#endif /* INET6 */
	    /*
	     * For long Rbind.
	     */
	    socks_bind_remoteAddr = soc_address.sin_addr.s_addr;
	} else
d1426 29
a1454 5
#ifdef INET6
	    status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
	    status = connect(*s, (struct sockaddr *) &soc_address, sizeof(soc_address));
#endif /* INET6 */
d1456 7
a1462 34
	/*
	 * According to the Sun man page for connect:
	 *  EINPROGRESS         The socket is non-blocking and the  con-
	 *                      nection cannot be completed immediately.
	 *                      It is possible to select(2) for  comple-
	 *                      tion  by  selecting the socket for writ-
	 *                      ing.
	 * According to the Motorola SVR4 man page for connect:
	 *  EAGAIN              The socket is non-blocking and the  con-
	 *                      nection cannot be completed immediately.
	 *                      It is possible to select for  completion
	 *                      by  selecting  the  socket  for writing.
	 *                      However, this is only  possible  if  the
	 *                      socket  STREAMS  module  is  the topmost
	 *                      module on  the  protocol  stack  with  a
	 *                      write  service  procedure.  This will be
	 *                      the normal case.
	 */
	if ((status < 0) &&
	    (SOCKET_ERRNO == EINPROGRESS
#ifdef EAGAIN
	     || SOCKET_ERRNO == EAGAIN
#endif
	    )) {
	    struct timeval select_timeout;
	    int ret;
	    int tries = 0;

#ifdef SOCKET_DEBUG_TRACE
	    HTInetStatus("this socket's first connect");
#endif /* SOCKET_DEBUG_TRACE */
	    ret = 0;
	    while (ret <= 0) {
		fd_set writefds;
a1463 12
		/*
		 * Protect against an infinite loop.
		 */
		if ((tries++ / 10) >= connect_timeout) {
		    HTAlert(gettext("Connection failed (too many retries)."));
#ifdef INET6
		    FREE(line);
		    if (res0)
			freeaddrinfo(res0);
#endif /* INET6 */
		    return HT_NO_DATA;
		}
d1465 1
a1465 2
		select_timeout.tv_sec = connect_timeout;
		select_timeout.tv_usec = 0;
d1467 1
a1467 2
		select_timeout.tv_sec = 0;
		select_timeout.tv_usec = 100000;
d1469 3
a1471 2
		FD_ZERO(&writefds);
		FD_SET((unsigned) *s, &writefds);
d1473 4
a1476 4
		if (socks_flag)
		    ret = Rselect((unsigned) *s + 1, NULL,
				  &writefds, NULL, &select_timeout);
		else
d1478 8
a1485 17
		    ret = select((unsigned) *s + 1,
				 NULL,
				 &writefds,
				 NULL,
				 &select_timeout);

#ifdef SOCKET_DEBUG_TRACE
		if (tries == 1) {
		    HTInetStatus("this socket's first select");
		}
#endif /* SOCKET_DEBUG_TRACE */
		/*
		 * If we suspend, then it is possible that select will be
		 * interrupted.  Allow for this possibility.  - JED
		 */
		if ((ret == -1) && (errno == EINTR))
		    continue;
d1487 14
a1500 5
#ifdef SOCKET_DEBUG_TRACE
		if (ret < 0) {
		    HTInetStatus("failed select");
		}
#endif /* SOCKET_DEBUG_TRACE */
d1502 4
a1505 19
		 * Again according to the Sun and Motorola man pages for
		 * connect:
		 *  EALREADY    The socket is non-blocking and a  previ-
		 *              ous  connection attempt has not yet been
		 *              completed.
		 * Thus if the SOCKET_ERRNO is NOT EALREADY we have a real
		 * error, and should break out here and return that error. 
		 * Otherwise if it is EALREADY keep on trying to complete the
		 * connection.
		 */
		if ((ret < 0) && (SOCKET_ERRNO != EALREADY)) {
		    status = ret;
		    break;
		} else if (ret > 0) {
		    /*
		     * Extra check here for connection success, if we try to
		     * connect again, and get EISCONN, it means we have a
		     * successful connection.  But don't check with SOCKS.
		     */
d1507 3
a1509 3
		    if (socks_flag) {
			status = 0;
		    } else {
d1511 2
a1512 6
#ifdef INET6
			status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
			status = connect(*s, (struct sockaddr *) &soc_address,
					 sizeof(soc_address));
#endif /* INET6 */
d1514 7
a1520 6
			/*
			 * A UCX feature:  Instead of returning EISCONN UCX
			 * returns EADDRINUSE.  Test for this status also.
			 */
			if ((status < 0) && ((SOCKET_ERRNO == EISCONN) ||
					     (SOCKET_ERRNO == EADDRINUSE)))
d1522 1
a1522 1
			if ((status < 0) && (SOCKET_ERRNO == EISCONN))
d1524 3
a1526 3
			{
			    status = 0;
			}
d1528 4
a1531 10
			if (status && (SOCKET_ERRNO == EALREADY))	/* new stuff LJM */
			    ret = 0;	/* keep going */
			else {
#ifdef SOCKET_DEBUG_TRACE
			    if (status < 0) {
				HTInetStatus("confirm-ready connect");
			    }
#endif /* SOCKET_DEBUG_TRACE */
			    break;
			}
d1533 1
a1533 1
		    }
d1535 1
a1535 1
		}
d1537 1
a1537 1
		else if (!socks_flag)
d1539 1
a1539 1
		else
d1541 17
a1557 26
		{
		    /*
		     * The select says we aren't ready yet.  Try to connect
		     * again to make sure.  If we don't get EALREADY or
		     * EISCONN, something has gone wrong.  Break out and report
		     * it.
		     *
		     * For some reason, SVR4 returns EAGAIN here instead of
		     * EALREADY, even though the man page says it should be
		     * EALREADY.
		     *
		     * For some reason, UCX pre 3 apparently returns errno =
		     * 18242 instead of EALREADY or EISCONN.
		     */
#ifdef INET6
		    status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
		    status = connect(*s, (struct sockaddr *) &soc_address,
				     sizeof(soc_address));
#endif /* INET6 */
		    if ((status < 0) &&
			(SOCKET_ERRNO != EALREADY
#ifdef EAGAIN
			 && SOCKET_ERRNO != EAGAIN
#endif
			) &&
d1559 1
a1559 1
			(SOCKET_ERRNO != 18242) &&
d1561 1
a1561 15
			(SOCKET_ERRNO != EISCONN)) {
#ifdef SOCKET_DEBUG_TRACE
			HTInetStatus("confirm-not-ready connect");
#endif /* SOCKET_DEBUG_TRACE */
			break;
		    }
		}
		if (HTCheckForInterrupt()) {
		    CTRACE((tfp, "*** INTERRUPTED in middle of connect.\n"));
		    status = HT_INTERRUPTED;
#ifdef _WINDOWS
		    WSASetLastError(EINTR);
#else
		    SOCKET_ERRNO = EINTR;
#endif
d1565 6
a1571 12
#ifdef SOCKET_DEBUG_TRACE
	else if (status < 0) {
	    HTInetStatus("this socket's first and only connect");
	}
#endif /* SOCKET_DEBUG_TRACE */
#ifdef INET6
	if (status < 0) {
	    NETCLOSE(*s);
	    *s = -1;
	    continue;
	}
	break;
d1573 2
a1574 8
#endif /* INET6 */

#ifdef INET6
    if (*s < 0)
#else
    if (status < 0)
#endif /* INET6 */
    {
d1576 3
a1578 3
	 * The connect attempt failed or was interrupted, so close up the
	 * socket.
	 */
d1581 1
a1581 1
#if !defined(DOSPATH) || defined(__DJGPP__)
d1585 2
a1586 2
	 * Make the socket blocking again on good connect.
	 */
a1588 1

d1597 1
a1597 1
#endif /* !DOSPATH || __DJGPP__ */
a1598 5
#ifdef INET6
    FREE(line);
    if (res0)
	freeaddrinfo(res0);
#endif /* INET6 */
d1603 6
a1608 5
 *  This is so interruptible reads can be implemented cleanly.
 */
int HTDoRead(int fildes,
	     void *buf,
	     unsigned nbyte)
d1612 2
a1613 7
    struct timeval select_timeout;
    int tries = 0;

#ifdef USE_READPROGRESS
    int otries = 0;
    time_t otime = time((time_t *) 0);
#endif
d1621 2
a1622 2
	 * 0 can be a valid socket fd, but if it's a tty something must have
	 * gone wrong.  - kw
d1625 1
a1625 1
	    CTRACE((tfp, "HTDoRead - refusing to read fd 0 which is a tty!\n"));
a1633 3
#ifdef _WINDOWS
	WSASetLastError(EINTR);
#else
a1634 1
#endif
d1637 1
d1645 2
a1646 2
	 * Protect against an infinite loop.
	 */
a1648 3
#ifdef _WINDOWS
	    WSASetLastError(EINTR);
#else
a1649 1
#endif
a1651 11
#ifdef USE_READPROGRESS
	if (tries - otries > 10) {
	    time_t t = time((time_t *) 0);

	    otries = tries;
	    if (t - otime >= 5) {
		otime = t;
		HTReadProgress(-1, 0);	/* Put "stalled" message */
	    }
	}
#endif
d1654 3
a1656 3
	 * If we suspend, then it is possible that select will be interrupted. 
	 * Allow for this possibility.  - JED
	 */
d1658 2
a1659 2
	    select_timeout.tv_sec = 0;
	    select_timeout.tv_usec = 100000;
d1661 1
a1661 1
	    FD_SET((unsigned) fildes, &readfds);
d1664 2
a1665 2
		ret = Rselect((unsigned) fildes + 1,
			      &readfds, NULL, NULL, &select_timeout);
d1668 2
a1669 2
		ret = select((unsigned) fildes + 1,
			     &readfds, NULL, NULL, &select_timeout);
a1676 3
#ifdef _WINDOWS
	    WSASetLastError(EINTR);
#else
a1677 1
#endif
d1684 2
a1685 1
    while ((nb = SOCKET_READ(fildes, buf, nbyte)) == -1) {
d1693 1
d1697 2
a1698 2
#else /* UNIX */
    return SOCKET_READ(fildes, buf, nbyte);
d1701 1
a1701 1
#else /* UCX && VAXC */
d1703 2
a1704 2
     * VAXC and UCX problem only.
     */
d1706 3
a1708 3
    nb = SOCKET_READ(fildes, buf, nbyte);
    CTRACE((tfp,
	    "Read - nb,errno,vaxc$errno: %d %d %d\n", nb, errno, vaxc$errno));
d1710 1
a1710 1
	perror("HTTCP.C:HTDoRead:read");	/* RJF */
d1712 2
a1713 2
     * An errno value of EPIPE and nb < 0 indicates end-of-file on VAXC.
     */
d1716 1
a1716 1
	set_errno(0);
d1724 14
a1737 14
 *  This is a fix for the difference between BSD's select() and
 *  SVR4's select().  SVR4's select() can never return a value larger
 *  than the total number of file descriptors being checked.  So, if
 *  you select for read and write on one file descriptor, and both
 *  are true, SVR4 select() will only return 1.  BSD select in the
 *  same situation will return 2.
 *
 *	Additionally, BSD select() on timing out, will zero the masks,
 *	while SVR4 does not.  This is fixed here as well.
 *
 *	Set your tabstops to 4 characters to have this code nicely formatted.
 *
 *	Jerry Whelan, guru@@bradley.edu, June 12th, 1993
 */
d1752 6
a1757 5
int BSDselect(int nfds,
	      fd_set * readfds,
	      fd_set * writefds,
	      fd_set * exceptfds,
	      struct timeval *select_timeout)
d1759 2
a1760 1
    int rval, i;
d1764 1
a1764 1
	rval = Rselect(nfds, readfds, writefds, exceptfds, select_timeout);
d1767 1
a1767 1
	rval = select(nfds, readfds, writefds, exceptfds, select_timeout);
d1770 22
a1791 2
    case -1:
	return (rval);
d1793 2
a1794 20
    case 0:
	if (readfds != NULL)
	    FD_ZERO(readfds);
	if (writefds != NULL)
	    FD_ZERO(writefds);
	if (exceptfds != NULL)
	    FD_ZERO(exceptfds);
	return (rval);

    default:
	for (i = 0, rval = 0; i < nfds; i++) {
	    if ((readfds != NULL) && FD_ISSET(i, readfds))
		rval++;
	    if ((writefds != NULL) && FD_ISSET(i, writefds))
		rval++;
	    if ((exceptfds != NULL) && FD_ISSET(i, exceptfds))
		rval++;

	}
	return (rval);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d28 1
a28 1
#include <www_wait.h>
a34 4
#ifdef __DJGPP__
#include <netdb.h>
#endif /* __DJGPP__ */

d43 1
a43 1
	struct timeval * select_timeout));
d58 8
d75 1
d90 1
a90 1
**	returns		a negative status in the Unix way.
d92 12
d110 5
a114 6
#ifdef __DJGPP__
static int ResolveYield (void)
{
    return HTCheckForInterrupt() ? 0 : 1;
}
#endif
d116 4
a119 7
/*
 * This chunk of code is used in both win32 and cygwin.
 */
#if defined(_WINDOWS_NSL)
static char host[512];
static struct hostent *phost; /* Pointer to host - See netdb.h */
static int donelookup;
d121 1
a121 1
static unsigned long _fork_func (void *arglist GCC_UNUSED)
d123 3
a125 12
#ifdef SH_EX
    unsigned long addr;
    addr = (unsigned long)inet_addr(host);
    if ((int)addr != -1)
	phost = gethostbyaddr((char *)&addr, sizeof (addr), AF_INET);
    else
	phost = gethostbyname(host);
#else
    phost = gethostbyname(host);
#endif
    donelookup = TRUE;
    return (unsigned long)(phost);
d134 3
a136 1
#include <HTioctl.h>
d157 1
a157 1
	set_errno(EBADF);
d176 1
a176 1
	set_errno(status);
d180 1
a180 1
	set_errno(iosb[0]);
a186 3
#define MY_FORMAT "TCP: Error %d in `SOCKET_ERRNO' after call to %s() failed.\n\t%s\n"
	   /* third arg is transport/platform specific */

d191 1
a191 1
	char *,		where)
a192 2
    int status;
    int saved_errno = errno;
d199 4
d204 1
a204 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   "(Error number not translated)"));	/* What Is the VM equiv? */
d210 1
a210 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   vms_errno_string()));
a211 1
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
d213 1
a213 1
	    strerror(SOCKET_ERRNO) : "(Error number not translated)")));
d219 1
a219 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   strerror(SOCKET_ERRNO)));
a223 1
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
d225 1
a225 1
	    sys_errlist[SOCKET_ERRNO] : "Unknown error" )));
d230 1
a230 1
    CTRACE((tfp,
d232 2
a233 2
	   SOCKET_ERRNO));
    CTRACE((tfp,
d235 1
a235 1
	   vaxc$errno));
a238 2
    set_errno(saved_errno);

d244 1
a244 1
    status = -vmserrno;
d246 1
a246 1
    status = -vaxc$errno;
d249 1
a249 1
    status = -SOCKET_ERRNO;
a250 1
    return status;
d298 1
a298 1
	SockA*,		soc_in)
d300 1
a300 8
#ifdef INET6
    static char hostbuf[MAXHOSTNAMELEN];
    getnameinfo((struct sockaddr *)soc_in,
	    SOCKADDR_LEN(soc_in),
	    hostbuf, sizeof(hostbuf), NULL, 0, NI_NUMERICHOST);
    return hostbuf;
#else
    static char string[20];
a306 1
#endif /* INET6 */
a316 1
**  - no segment starts with '-' or '+' [this protects telnet command],
d330 1
a330 1
	char *,	name)
d333 1
a333 1
    char *cp = name;
a343 2
	} else if (iseg == 0 && (*cp == '-' || *cp == '+')) {
	    return NO;
d345 1
a345 1
	    return NO;
d347 1
a347 1
	if (!isalnum(UCH(*cp)) &&
d353 1
a353 1
    return (BOOL) (*cp == '\0' || (*cp == '.' && iseg != 0 && cp[1] == '\0'));
d371 2
d390 1
a390 1
	CTRACE((tfp,"%s: %p ", msgprefix, phost));
d392 1
a392 1
	    CTRACE((tfp,"{ h_name = %p", phost->h_name));
d394 1
a394 1
		CTRACE((tfp, " \"%s\",", phost->h_name));
d396 1
a396 1
		CTRACE((tfp, ","));
d398 1
a398 1
	    CTRACE((tfp,"\n\t h_aliases = %p", phost->h_aliases));
d400 1
a400 1
		CTRACE((tfp, " {"));
d402 1
a402 1
		    CTRACE((tfp,"%s %p \"%s\"",
d404 1
a404 1
			   *pcnt, *pcnt));
d406 2
a407 2
		CTRACE((tfp, "%s0x0 },\n\t",
		       (*phost->h_aliases ? ", " : " ")));
d409 1
a409 1
		CTRACE((tfp, ",\n\t"));
d411 3
a413 3
	    CTRACE((tfp," h_addrtype = %d,", phost->h_addrtype));
	    CTRACE((tfp," h_length = %d,\n\t", phost->h_length));
	    CTRACE((tfp," h_addr_list = %p", phost->h_addr_list));
d415 1
a415 1
		CTRACE((tfp, " {"));
d417 1
a417 1
		    CTRACE((tfp,"%s %p",
d419 1
a419 1
			   *pcnt));
d421 1
a421 1
			CTRACE((tfp, "%s%d%s", (i==0 ? " \"" : "."),
d423 1
a423 1
			       (i+1 == phost->h_length ? "\"" : "")));
d427 1
a427 1
		    CTRACE((tfp, ", 0x0 } }"));
d429 1
a429 1
		    CTRACE((tfp, " 0x0 } }"));
d432 1
a432 1
		CTRACE((tfp, "}"));
d435 1
a435 1
	CTRACE((tfp,"\n"));
a447 9
#ifdef NSL_FORK

#define REHOSTENT_SIZE 128		/* not bigger than pipe buffer! */

typedef struct {
	struct hostent	h;
	char		rest[REHOSTENT_SIZE];
    } AlignedHOSTENT;

a452 1
    AlignedHOSTENT *data = (AlignedHOSTENT *)rehostent;
d512 2
a513 2
    data->h.h_addrtype = phost->h_addrtype;
    data->h.h_length = phost->h_length;
d522 1
a522 1
	data->h.h_addr_list = p_next_charptr;
d532 1
a532 1
	data->h.h_addr_list = NULL;
d536 1
a536 1
	data->h.h_name = p_next_char;
d544 1
a544 1
	data->h.h_name = NULL;
d548 1
a548 1
	data->h.h_aliases = p_next_charptr;
d566 1
a566 1
	data->h.h_aliases = NULL;
d571 2
a572 1
#endif /* NSL_FORK */
a578 1
#ifndef h_errno		/* there may be a macro as well as the extern data */
a580 1
#endif
d617 1
a617 1
	char *,	str)
d620 2
a621 3
    char *host = str;
#endif

d624 4
a627 1
    static AlignedHOSTENT aligned_full_rehostent;
d648 1
a648 1
	int child_errno;  /* sometimes useful to pass this on */
a657 4
#ifdef __DJGPP__
    _resolve_hook = ResolveYield;
#endif

d659 1
a659 1
	CTRACE((tfp, "LYGetHostByName: Can't parse `NULL'.\n"));
d663 1
a663 1
    CTRACE((tfp, "LYGetHostByName: parsing `%s'.\n", str));
d667 1
a667 1
	CTRACE((tfp, "LYGetHostByName: INTERRUPTED for '%s'.\n", str));
a671 4
#ifdef _WINDOWS_NSL
    strncpy(host, str, sizeof(host));
#endif /*  _WINDOWS_NSL */

a674 3
#ifdef _WINDOWS
	WSASetLastError(NO_RECOVERY);
#else
a676 1
#endif
d680 6
d687 1
a687 1
    CTRACE((tfp, "LYGetHostByName: Calling gethostbyname(%s)\n", host));
d690 1
a690 1
    CTRACE_FLUSH(tfp);  /* so child messages will not mess up parent log */
a701 4
#if HAVE_SIGACTION
	sigset_t old_sigset;
	sigset_t new_sigset;
#endif
d706 3
a708 8
	int fpid, waitret;
	int pfd[2], selret, readret;
#ifdef HAVE_TYPE_UNIONWAIT
	union wait waitstat;
#else
	int waitstat = 0;
#endif
	time_t start_time = time((time_t *)0);
d710 2
a711 2
	struct timeval one_second;
	long dns_patience = 30; /* how many seconds will we wait for DNS? */
a729 26
#if HAVE_SIGACTION
	/*
	 *  Attempt to prevent a rare situation where the child
	 *  could execute the Lynx signal handlers because it gets
	 *  killed before it even has a chance to reset its handlers,
	 *  resulting in bogus 'Exiting via interrupt' message and
	 *  screen corruption or worse.
	 *  Should that continue to be reported, for systems without
	 *  sigprocmask(), we need to find a different solutions for
	 *  those. - kw 19990430
	 */
	sigemptyset(&new_sigset);
	sigaddset(&new_sigset, SIGTERM);
	sigaddset(&new_sigset, SIGINT);
#ifndef NOSIGHUP
	sigaddset(&new_sigset, SIGHUP);
#endif /* NOSIGHUP */
#ifdef SIGTSTP
	sigaddset(&new_sigset, SIGTSTP);
#endif /* SIGTSTP */
#ifdef SIGWINCH
	sigaddset(&new_sigset, SIGWINCH);
#endif /* SIGWINCH */
	sigprocmask(SIG_BLOCK, &new_sigset, &old_sigset);
#endif /* HAVE_SIGACTION */

a766 5
#if HAVE_SIGACTION
	    /* Restore signal mask to whatever it was before the fork. -kw */
	    sigprocmask(SIG_SETMASK, &old_sigset, NULL);
#endif /* HAVE_SIGACTION */

a770 5
#ifdef HAVE_H_ERRNO
	    /* to detect cases when it doesn't get set although it should */
	    h_errno = -2;
#endif
	    set_errno(0);
a771 1
	    statuses.child_errno = errno;
a772 1
#ifdef HAVE_H_ERRNO
a773 1
#endif
d775 1
a775 1
	    CTRACE((tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost));
a792 4
#ifdef HAVE_H_ERRNO
		if (h_errno == -2) /* success, but h_errno unchanged? */
		    statuses.h_errno_valid = NO;
#endif
a798 1
	    if (!statuses.child_errno)
a817 8
#if HAVE_SIGACTION
	/*
	**  (parent) Restore signal mask to whatever it was
	**  before the fork. - kw
	*/
	sigprocmask(SIG_SETMASK, &old_sigset, NULL);
#endif /* HAVE_SIGACTION */

d830 1
a830 1
	while (child_exited || (long)(time((time_t *)0) - start_time) < dns_patience) {
d850 2
a851 2
	    one_second.tv_sec = 1;
	    one_second.tv_usec = 0;
d861 1
a861 1
		selret = Rselect(pfd[0] + 1, (void *)&readfds, NULL, NULL, &one_second);
d864 1
a864 1
		selret = select(pfd[0] + 1, (void *)&readfds, NULL, NULL, &one_second);
d873 2
a874 3
		    set_errno(statuses.child_errno);
#ifdef HAVE_H_ERRNO
		    if (statuses.h_errno_valid) {
a875 35
			/*
			 *  If something went wrong in the child process
			 *  other than normal lookup errors, and it appears
			 *  that we have enough info to know what went wrong,
			 *  generate diagnostic output.
			 *  ENOMEM observed on linux in processes constrained
			 *  with ulimit.  It would be too unkind to abort
			 *  the session, access to local files or through a
			 *  proxy may still work. - kw
			 */
			if (
#ifdef NETDB_INTERNAL		/* linux glibc: defined in netdb.h */
			    (errno && h_errno == NETDB_INTERNAL) ||
#endif
			    (errno == ENOMEM &&
			     statuses.rehostentlen == 0 &&
			     /* should probably be NETDB_INTERNAL if child
				memory exhausted, but we may find that
				h_errno remains unchanged. - kw */
			     h_errno == -2)) {
#ifndef MULTINET
			    HTInetStatus("CHILD gethostbyname");
#endif
			    HTAlert(LYStrerror(statuses.child_errno));
			    if (errno == ENOMEM) {
				/*
				 *  Not much point in continuing, right?
				 *  Fake a 'z', should shorten pointless
				 *  guessing cycle. - kw
				 */
				LYFakeZap(YES);
			    }
			}
		    }
#endif /* HAVE_H_ERRNO */
d891 1
a891 1
		    }
d931 1
a931 1
		CTRACE((tfp, "LYGetHostByName: INTERRUPTED gethostbyname.\n"));
d946 2
a947 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",
			(int)waitret, WEXITSTATUS(waitstat)));
d949 2
a950 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
		       (int)waitret, WTERMSIG(waitstat)));
d953 2
a954 2
		    CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d dumped core!\n",
			   (int)waitret));
d958 2
a959 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
			(int)waitret, WSTOPSIG(waitstat)));
d970 35
a1004 31
	HANDLE hThread, dwThreadID;

#ifndef __CYGWIN__
	if (!system_is_NT) {	/* for Windows9x */
	    unsigned long t;
	    t = (unsigned long)inet_addr(host);
	    if ((int)t != -1)
		phost = gethostbyaddr((char *)&t, sizeof (t), AF_INET);
	    else
		phost = gethostbyname(host);
	} else {		/* for Windows NT */
#endif /* !__CYGWIN__ */
	    phost = (struct hostent *) NULL;
	    donelookup = FALSE;
	    hThread = CreateThread((void *)NULL, 4096UL,
		(LPTHREAD_START_ROUTINE)_fork_func,
		(void *)NULL, 0UL, (unsigned long *)&dwThreadID);
	    if (!hThread)
		MessageBox((void *)NULL, "CreateThread",
			   "CreateThread Failed", 0L);

	    while (!donelookup) {
		if (HTCheckForInterrupt()) {
		    /* Note that host is a character array and is not freed */
		    /* to avoid possible subthread problems: */
		    if (!CloseHandle(hThread)) {
			MessageBox((void *)NULL,
				   "CloseHandle","CloseHandle Failed", 0L);
		    }
		    lynx_nsl_status = HT_INTERRUPTED;
		    return NULL;
d1006 1
a1006 12
	    }
#ifndef __CYGWIN__
	}
#endif /* !__CYGWIN__ */
	if (phost) {
	    lynx_nsl_status = HT_OK;
	    result_phost = phost;
	} else {
	    lynx_nsl_status = HT_ERROR;
	    goto failed;
	}
    }
d1011 1
a1011 1
	phost = gethostbyname(host);	/* See netdb.h */
d1013 1
a1013 1
	CTRACE((tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost));
d1028 1
a1028 1
    CTRACE((tfp, "LYGetHostByName: Resolved name to a hostent.\n"));
d1034 2
a1035 2
    CTRACE((tfp, "LYGetHostByName: Can't find internet node name `%s'.\n",
		host));
d1039 2
d1054 1
a1054 2
#ifndef INET6
PRIVATE int HTParseInet ARGS2(
a1059 1
    char *strptr;
d1065 1
a1065 1
	CTRACE((tfp, "HTParseInet: Can't parse `NULL'.\n"));
d1068 1
a1068 1
    CTRACE((tfp, "HTParseInet: parsing `%s'.\n", str));
d1070 1
a1070 1
	CTRACE((tfp, "HTParseInet: INTERRUPTED for '%s'.\n", str));
d1074 1
a1074 1
    strncpy(host, str, sizeof(host));
a1082 1
	strptr = port;
d1084 2
a1085 2
#ifdef UNIX
	    soc_in->sin_port = (PortNumber)htons(strtol(port, &strptr, 10));
d1088 1
a1088 1
	    soc_in->sdn_objnum = (unsigned char)(strtol(port, &strptr, 10));
d1090 1
a1090 1
	    soc_in->sin_port = htons((PortNumber)strtol(port, &strptr, 10));
d1093 1
a1093 1
#ifdef SUPPRESS		/* 1. crashes!?!.  2. URL syntax has number not name */
d1099 1
a1099 1
		CTRACE((tfp, "TCP: Unknown service %s\n", port));
a1102 7
	if (strptr && *strptr != '\0') {
#ifndef _WINDOWS_NSL
	    FREE(host);
#endif /* _WINDOWS_NSL */
	    HTAlwaysAlert(NULL, gettext("Address has invalid port"));
	    return -1;
	}
d1112 2
a1113 2
    CTRACE((tfp, "DECnet: Parsed address as object number %d on host %.6s...\n",
		soc_in->sdn_objnum, host));
d1117 1
a1117 1
	strptr = host;
d1121 1
a1121 1
	    } else if (!isdigit(UCH(*strptr))) {
d1134 5
a1138 2
    if (dotcount_ip == 3)   /* Numeric node address: */
    {
d1147 1
a1147 1
	    CTRACE((tfp, "inet_aton(%s) returns error\n", host));
d1158 1
d1162 1
a1162 2
    } else
    {			    /* Alphanumeric node name: */
d1165 1
a1165 1
	CTRACE((tfp, "HTParseInet: Calling LYGetHostByName(%s)\n", host));
d1168 10
d1182 1
a1182 1
#else /* !_WINDOWS_NSL */
d1206 2
a1207 2
#endif /* _WINDOWS_NSL */

d1214 1
a1214 1
    CTRACE((tfp, "HTParseInet: Parsed address as port %d, IP address %d.%d.%d.%d\n",
d1219 1
a1219 1
		(int)*((unsigned char *)(&soc_in->sin_addr)+3)));
d1225 2
a1226 2
    CTRACE((tfp, "HTParseInet: Can't find internet node name `%s'.\n",
		host));
d1231 5
a1235 6
	case HT_NOT_ACCEPTABLE:
	case HT_INTERRUPTED:
	    return lynx_nsl_status;
	default:
	return -1;
    }
a1236 43
#endif /* !INET6 */

#ifdef INET6
PRIVATE struct addrinfo *
HTGetAddrInfo ARGS2(
    CONST char *, str,
    CONST int, defport)
{
    struct addrinfo hints, *res;
    int error;
    char *p;
    char *s;
    char *host, *port;
    char pbuf[80];

    s = strdup(str);

    if (s[0] == '[' && (p = strchr(s, ']')) != NULL) {
	*p++ = '\0';
	host = s + 1;
    } else {
	p = s;
	host = &s[0];
    }
    port = strrchr(p, ':');
    if (port) {
	*port++ = '\0';
    } else {
	sprintf(pbuf, "%d", defport);
	port = pbuf;
    }

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, port, &hints, &res);
    if (error || !res) {
	CTRACE((tfp, "HTGetAddrInfo: getaddrinfo(%s, %s): %s\n", host, port,
		gai_strerror(error)));
	res = NULL;
    }

    return res;
a1237 1
#endif /* INET6 */
d1254 4
a1264 4
#ifdef INET6
    struct addrinfo hints, *res;
    int error;
#else
a1265 1
#endif /* INET6 */
d1270 1
a1270 1
	return;				/* Already done */
d1281 2
a1282 4
    if (strchr(hostname,'.') == NULL) {		  /* Not full address */
	domain_name = LYGetEnv("UCX$BIND_DOMAIN");
	if (domain_name == NULL)
	    domain_name = LYGetEnv("TCPIP$BIND_DOMAIN");
d1289 1
a1289 1
    CTRACE((tfp, "TCP: Local host name is %s\n", hostname));
a1292 16
#ifdef INET6
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_CANONNAME;
    error = getaddrinfo(name, NULL, &hints, &res);
    if (error || !res || !res->ai_canonname) {
	CTRACE((tfp, "TCP: %s: `%s'\n", gai_strerror(error), name));
	if (res)
	    freeaddrinfo(res);
	return;  /* Fail! */
    }
    StrAllocCopy(hostname, res->ai_canonname);
    memcpy(&HTHostAddress, res->ai_addr, res->ai_addrlen);
    freeaddrinfo(res);
#else
d1295 2
a1296 2
	CTRACE((tfp, "TCP: Can't find my own internet node address for `%s'!!\n",
		    name));
d1301 2
a1302 3
#endif /* INET6 */
    CTRACE((tfp, "     Name server says that I am `%s' = %s\n",
		hostname, HTInetString(&HTHostAddress)));
a1313 5
#ifndef MULTINET		/* SOCKET_ERRNO != errno ? */
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
#define SOCKET_DEBUG_TRACE    /* show errno status after some system calls */
#endif  /* UCX && VAXC */
#endif /* MULTINET */
d1315 1
a1315 1
**  Interruptible connect as implemented for Mosaic by Marc Andreesen
d1321 1
a1321 1
	char *,		protocol,
d1325 3
a1327 1
    int status = 0;
a1331 5
#ifdef INET6
    struct addrinfo *res, *res0;
#else
    struct sockaddr_in soc_address;
    struct sockaddr_in *soc_in = &soc_address;
d1338 1
a1338 2
    soc_in->sin_port = htons((PortNumber) default_port);
#endif /* INET6 */
d1354 1
a1354 1
    HTSprintf0 (&line, "%s%s", WWW_FIND_MESSAGE, host);
a1355 11
#ifdef INET6
    /* HTParseInet() is useless! */
    res0 = HTGetAddrInfo(host, default_port);
    if (res0 == NULL) {
	HTSprintf0 (&line, gettext("Unable to locate remote host %s."), host);
	_HTProgress(line);
	FREE(host);
	FREE(line);
	return HT_NO_DATA;
    }
#else
a1375 1
#endif /* INET6 */
d1377 1
a1377 1
    HTSprintf0 (&line, gettext("Making %s connection to %s"), protocol, host);
a1384 15
#ifdef INET6
    for (res = res0; res; res = res->ai_next) {
	*s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	if (*s == -1) {
	    char hostbuf[1024], portbuf[1024];
	    getnameinfo(res->ai_addr, res->ai_addrlen,
		    hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
		    NI_NUMERICHOST|NI_NUMERICSERV);
	    HTSprintf0 (&line, gettext("socket failed: family %d addr %s port %s."),
		    res->ai_family, hostbuf, portbuf);
	    _HTProgress (line);
	    FREE(line);
	    continue;
	}
#else
a1389 1
#endif /* INET6 */
d1391 1
a1391 1
#if !defined(DOSPATH) || defined(__DJGPP__)
d1409 1
a1409 1
#endif /* !DOSPATH || __DJGPP__ */
a1417 3
#ifdef INET6
	status = Rconnect(*s, res->ai_addr, res->ai_addrlen);
#else
a1419 1
#endif /* INET6 */
a1425 3
#ifdef INET6
    status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
d1427 1
a1427 2
#endif /* INET6 */

d1447 2
a1448 6
	(SOCKET_ERRNO == EINPROGRESS
#ifdef EAGAIN
	 || SOCKET_ERRNO == EAGAIN
#endif
	 )) {
	struct timeval select_timeout;
a1451 3
#ifdef SOCKET_DEBUG_TRACE
	HTInetStatus("this socket's first connect");
#endif /* SOCKET_DEBUG_TRACE */
d1459 2
a1460 6
	    if ((tries++/10) >= connect_timeout) {
		HTAlert(gettext("Connection failed (too many retries)."));
#ifdef INET6
		FREE(line);
		freeaddrinfo(res0);
#endif /* INET6 */
d1465 1
a1465 2
	    select_timeout.tv_sec = connect_timeout;
	    select_timeout.tv_usec = 0;
d1467 1
a1467 2
	    select_timeout.tv_sec = 0;
	    select_timeout.tv_usec = 100000;
d1469 1
d1471 1
a1471 1
	    FD_SET((unsigned) *s, &writefds);
d1474 2
a1475 2
		ret = Rselect((unsigned)*s + 1, NULL,
			      (void *)&writefds, NULL, &select_timeout);
d1478 1
a1478 1
	    ret = select((unsigned)*s + 1, NULL, (void *)&writefds, NULL, &select_timeout);
d1480 6
a1485 11
#ifdef SOCKET_DEBUG_TRACE
	    if (tries == 1) {
		HTInetStatus("this socket's first select");
	    }
#endif /* SOCKET_DEBUG_TRACE */
	    /*
	    **  If we suspend, then it is possible that select will be
	    **  interrupted.  Allow for this possibility. - JED
	    */
	    if ((ret == -1) && (errno == EINTR))
		continue;
a1486 5
#ifdef SOCKET_DEBUG_TRACE
	    if (ret < 0) {
		HTInetStatus("failed select");
	    }
#endif /* SOCKET_DEBUG_TRACE */
a1510 3
#ifdef INET6
		status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
a1512 1
#endif /* INET6 */
d1530 1
a1530 6
		else {
#ifdef SOCKET_DEBUG_TRACE
		    if (status < 0) {
			HTInetStatus("confirm-ready connect");
		    }
#endif /* SOCKET_DEBUG_TRACE */
a1531 1
		}
a1553 3
#ifdef INET6
		status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
a1555 1
#endif /* INET6 */
d1557 1
a1557 5
		    (SOCKET_ERRNO != EALREADY
#ifdef EAGAIN
		    && SOCKET_ERRNO != EAGAIN
#endif
		    ) &&
a1561 3
#ifdef SOCKET_DEBUG_TRACE
		    HTInetStatus("confirm-not-ready connect");
#endif /* SOCKET_DEBUG_TRACE */
d1566 1
a1566 1
		CTRACE((tfp, "*** INTERRUPTED in middle of connect.\n"));
a1567 3
#ifdef _WINDOWS
		WSASetLastError(EINTR);
#else
a1568 1
#endif
d1573 2
a1574 21
#ifdef SOCKET_DEBUG_TRACE
    else if (status < 0) {
	HTInetStatus("this socket's first and only connect");
    }
#endif /* SOCKET_DEBUG_TRACE */
#ifdef INET6
	if (status < 0) {
		NETCLOSE(*s);
		*s = -1;
		continue;
	}
	break;
    }
#endif /* INET6 */

#ifdef INET6
    if (*s < 0)
#else
    if (status < 0)
#endif /* INET6 */
    {
d1581 1
a1581 1
#if !defined(DOSPATH) || defined(__DJGPP__)
d1597 1
a1597 1
#endif /* !DOSPATH || __DJGPP__ */
a1598 4
#ifdef INET6
    FREE(line);
    freeaddrinfo(res0);
#endif /* INET6 */
d1607 1
a1607 1
	void *,		buf,
d1612 1
a1612 1
    struct timeval select_timeout;
a1613 4
#ifdef EXP_READPROGRESS
    int otries = 0;
    time_t otime = time((time_t *)0);
#endif
d1625 1
a1625 1
	    CTRACE((tfp, "HTDoRead - refusing to read fd 0 which is a tty!\n"));
a1633 3
#ifdef _WINDOWS
	WSASetLastError(EINTR);
#else
a1634 1
#endif
a1648 3
#ifdef _WINDOWS
	    WSASetLastError(EINTR);
#else
a1649 1
#endif
a1652 12
#ifdef EXP_READPROGRESS
	if (tries - otries > 10) {
	    time_t t = time((time_t *)0);

	    otries = tries;
	    if (t - otime >= 5) {
		otime = t;
		HTReadProgress(-1, 0);	/* Put "stalled" message */
	    }
	}
#endif

d1658 2
a1659 2
	    select_timeout.tv_sec = 0;
	    select_timeout.tv_usec = 100000;
d1661 1
a1661 1
	    FD_SET((unsigned)fildes, &readfds);
d1664 2
a1665 2
		ret = Rselect((unsigned)fildes + 1,
			      (void *)&readfds, NULL, NULL, &select_timeout);
d1668 2
a1669 2
		ret = select((unsigned)fildes + 1,
			     (void *)&readfds, NULL, NULL, &select_timeout);
a1676 3
#ifdef _WINDOWS
	    WSASetLastError(EINTR);
#else
a1677 1
#endif
d1685 1
d1693 1
d1707 2
a1708 2
    CTRACE((tfp,
	   "Read - nb,errno,vaxc$errno: %d %d %d\n", nb,errno,vaxc$errno));
d1716 1
a1716 1
	set_errno(0);
d1757 1
a1757 1
	struct timeval *,	select_timeout)
d1764 1
a1764 1
	rval = Rselect(nfds, readfds, writefds, exceptfds, select_timeout);
d1767 1
a1767 1
    rval = select(nfds, readfds, writefds, exceptfds, select_timeout);
d1772 1
d1782 1
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d1920 1
a1920 1
#ifdef USE_READPROGRESS
d1971 1
a1971 1
#ifdef USE_READPROGRESS
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d1527 1
a1527 1
    struct addrinfo *res = 0, *res0 = 0;
d1706 1
a1706 2
		if (res0)
		    freeaddrinfo(res0);
d1903 1
a1903 2
    if (res0)
	freeaddrinfo(res0);
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d42 1
a42 1
int BSDselect (
d47 1
a47 1
	struct timeval * select_timeout);
d65 1
a65 1
static char *hostname = NULL;		/* The name of this host */
d71 1
a71 1
unsigned long socks_bind_remoteAddr; /* for long Rbind */
d132 4
a135 4
int HTioctl (
	int		d,
	int		request,
	int *		argp)
d187 2
a188 2
int HTInetStatus (
	char *		where)
d269 4
a272 4
unsigned int HTCardinal (
	int *		pstatus,
	char **	pp,
	unsigned int	max_value)
d300 2
a301 2
const char * HTInetString (
	SockA*		soc_in)
d341 2
a342 2
BOOL valid_hostname (
	char *	name)
d376 2
a377 2
static void quench (
	int	sig GCC_UNUSED)
d383 1
a383 1
int lynx_nsl_status = HT_OK;
d395 3
a397 3
static void dump_hostent (
    const char *		msgprefix,
    const struct hostent *	phost)
d469 4
a472 4
static size_t fill_rehostent (
    char *			rehostent,
    size_t			rehostentsize,
    const struct hostent *	phost)
d639 2
a640 2
struct hostent * LYGetHostByName (
	char *	str)
d1184 3
a1186 3
static int HTParseInet (
	SockA *	soc_in,
	const char *	str)
d1367 4
a1370 4
static struct addrinfo *
HTGetAddrInfo (
    const char * str,
    const int defport)
d1415 1
a1415 1
static void free_HTTCP_hostname (void)
d1425 1
a1425 1
static void get_host_details (void)
d1499 1
a1499 1
const char * HTHostName (void)
d1515 5
a1519 5
int HTDoConnect (
	const char *	url,
	char *		protocol,
	int		default_port,
	int *		s)
d1913 4
a1916 4
int HTDoRead (
	int		fildes,
	void *		buf,
	unsigned	nbyte)
d2086 6
a2091 6
int BSDselect (
	int			nfds,
	fd_set *		readfds,
	fd_set *		writefds,
	fd_set *		exceptfds,
	struct timeval *	select_timeout)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 16
a17 16
 *			==========================
 *
 *	This code is in common between client and server sides.
 *
 *	16 Jan 92  TBL	Fix strtol() undefined on CMU Mach.
 *	25 Jun 92  JFG	Added DECNET option through TCP socket emulation.
 *	13 Sep 93  MD	Added correct return of vmserrorno for HTInetStatus.
 *			Added decoding of vms error message for MULTINET.
 *	7-DEC-1993 Bjorn S. Nilsson, ALEPH, CERN, VMS UCX ioctl() changes
 *			(done of Mosaic)
 *	19 Feb 94  Danny Mayer	Added Bjorn Fixes to Lynx version
 *	 7 Mar 94  Danny Mayer	Added Fix UCX version for full domain name
 *	20 May 94  Andy Harper	Added support for CMU TCP/IP transport
 *	17 Nov 94  Andy Harper	Added support for SOCKETSHR transport
 *	16 Jul 95  S. Bjorndahl added kluge to deal with LIBCMU bug
 */
a38 3
#define LYNX_ADDRINFO	struct addrinfo
#define LYNX_HOSTENT	struct hostent

d42 6
a47 6
int BSDselect(int nfds,
	      fd_set * readfds,
	      fd_set * writefds,
	      fd_set * exceptfds,
	      struct timeval *select_timeout);

d63 3
a65 3
 *  Module-Wide variables
 */
static char *hostname = NULL;	/* The name of this host */
d68 2
a69 2
 *  PUBLIC VARIABLES
 */
d71 1
a71 1
unsigned long socks_bind_remoteAddr;	/* for long Rbind */
d74 1
a74 1
/* PUBLIC SockA HTHostAddress; *//* The internet address of the host */
d78 9
a86 9
 *	------------------
 *
 *  On entry,
 *	where		gives a description of what caused the error
 *	global errno	gives the error number in the Unix way.
 *
 *  On return,
 *	returns		a negative status in the Unix way.
 */
d89 1
a89 1
extern char *sys_errlist[];	/* see man perror on cernvax */
d94 1
a94 1
static int ResolveYield(void)
d96 1
a96 1
    return HTCheckForInterrupt()? 0 : 1;
d104 2
a105 1
static LYNX_HOSTENT *phost;	/* Pointer to host - See netdb.h */
d108 1
a108 1
static unsigned long __stdcall _fork_func(void *arg)
a109 2
    const char *host = (const char *) arg;

d112 3
a114 4

    addr = (unsigned long) inet_addr(host);
    if (addr != INADDR_NONE)
	phost = gethostbyaddr((char *) &addr, sizeof(addr), AF_INET);
d121 1
a121 1
    return (unsigned long) (phost);
d127 3
a129 3
 *  A routine to mimic the ioctl function for UCX.
 *  Bjorn S. Nilsson, 25-Nov-1993. Based on an example in the UCX manual.
 */
d132 4
a135 3
int HTioctl(int d,
	    int request,
	    int *argp)
d150 1
a150 1
    if ((sdc = vaxc$get_sdc(d)) == 0) {
d154 2
a155 3
    ioctl_desc.opt = UCX$C_IOCTL;
    ioctl_desc.len = sizeof(struct comm);

d160 1
a160 1
	p6 = (char *) &ioctl_desc;
d163 1
a163 1
	p5 = (char *) &ioctl_desc;
d167 2
a168 2
    ioctl_comm.addr = (char *) argp;
    status = sys$qiow(0, sdc, fun, iosb, 0, 0, 0, 0, 0, 0, p5, p6);
d185 4
a188 3
 *	---------------------
 */
int HTInetStatus(char *where)
a191 1

d199 2
a200 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    "(Error number not translated)"));	/* What Is the VM equiv? */
d206 2
a207 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    vms_errno_string()));
d209 3
a211 3
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    ((SOCKET_ERRNO > 0 && SOCKET_ERRNO <= 65) ?
	     strerror(SOCKET_ERRNO) : "(Error number not translated)")));
d217 2
a218 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    strerror(SOCKET_ERRNO)));
d223 3
a225 3
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    (SOCKET_ERRNO < sys_nerr ?
	     sys_errlist[SOCKET_ERRNO] : "Unknown error")));
d231 2
a232 2
	    "         Unix error number (SOCKET_ERRNO) = %ld dec\n",
	    SOCKET_ERRNO));
d234 2
a235 2
	    "         VMS error (vaxc$errno)    = %lx hex\n",
	    vaxc$errno));
d243 2
a244 2
     * uerrno and errno happen to be zero if vmserrno <> 0
     */
d257 16
a272 15
 *	----------------------
 *
 * On entry,
 *	*pp	    points to first character to be interpreted, terminated by
 *		    non 0:9 character.
 *	*pstatus    points to status already valid
 *	maxvalue    gives the largest allowable value.
 *
 * On exit,
 *	*pp	    points to first unread character
 *	*pstatus    points to status updated iff bad
 */
unsigned int HTCardinal(int *pstatus,
			char **pp,
			unsigned int max_value)
d275 2
a276 3

    if ((**pp < '0') || (**pp > '9')) {		/* Null string is error */
	*pstatus = -3;		/* No number where one expected */
d282 1
a282 1
	n = n * 10 + *((*pp)++) - '0';
d285 1
a285 1
	*pstatus = -4;		/* Cardinal outside range */
d292 1
a292 1
#ifndef DECNET			/* Function only used below for a trace message */
d294 8
a301 7
 *	----------------------------------------
 *
 *  On exit,
 *	returns a pointer to a static string which must be copied if
 *		it is to be kept.
 */
const char *HTInetString(SockA * soc_in)
d305 3
a307 4

    getnameinfo((struct sockaddr *) soc_in,
		SOCKADDR_LEN(soc_in),
		hostbuf, sizeof(hostbuf), NULL, 0, NI_NUMERICHOST);
a310 1

d312 4
a315 4
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 0),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 1),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 2),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 3));
d322 21
a342 20
 *	-------------------------------------------------
 *
 *  Checks whether
 *  - contains only valid chars for domain names (actually, the
 *    restrictions are somewhat relaxed),
 *  - no leading dots or empty segments,
 *  - no segment starts with '-' or '+' [this protects telnet command],
 *  - max. length of dot-separated segment <= 63 (RFC 1034,1035),
 *  - total length <= 254 (if it ends with dot) or 253 (otherwise)
 *     [an interpretation of RFC 1034,1035, although RFC 1123
 *      suggests 255 as limit - kw].
 *
 *  Note: user (before '@@') and port (after ':') components from
 *      host part of URL should be already stripped (if appropriate)
 *      from the input string.
 *
 *  On exit,
 *	returns 1 if valid, otherwise 0.
 */
BOOL valid_hostname(char *name)
d344 1
a344 1
    int i = 1, iseg = 0;
a345 1

d372 6
a377 5
 *  Function to allow us to be killed with a normal signal (not
 *  SIGKILL), but don't go through normal libc exit() processing, which
 *  would screw up parent's stdio.  -BL
 */
static void quench(int sig GCC_UNUSED)
d386 1
a386 1
#define DEBUG_HOSTENT_CHILD	/* for NSL_FORK, may screw up trace file */
d389 9
a397 8
 *  Two auxiliary functions for name lookup and LYNX_HOSTENT.
 *
 *  dump_hostent - dumps the contents of a LYNX_HOSTENT to the
 *  trace log or stderr, including all pointer values, strings, and
 *  addresses, in a format inspired by gdb's print format. - kw
 */
static void dump_hostent(const char *msgprefix,
			 const LYNX_HOSTENT *phost)
d402 1
a402 2

	CTRACE((tfp, "%s: %p ", msgprefix, phost));
d404 1
a404 1
	    CTRACE((tfp, "{ h_name = %p", phost->h_name));
d410 1
a410 1
	    CTRACE((tfp, "\n\t h_aliases = %p", phost->h_aliases));
d414 3
a416 3
		    CTRACE((tfp, "%s %p \"%s\"",
			    (pcnt == phost->h_aliases ? " " : ", "),
			    *pcnt, *pcnt));
d419 1
a419 1
			(*phost->h_aliases ? ", " : " ")));
d423 3
a425 3
	    CTRACE((tfp, " h_addrtype = %d,", phost->h_addrtype));
	    CTRACE((tfp, " h_length = %d,\n\t", phost->h_length));
	    CTRACE((tfp, " h_addr_list = %p", phost->h_addr_list));
d429 3
a431 3
		    CTRACE((tfp, "%s %p",
			    (pcnt == phost->h_addr_list ? "" : ","),
			    *pcnt));
d433 3
a435 3
			CTRACE((tfp, "%s%d%s", (i == 0 ? " \"" : "."),
				(int) *((unsigned char *) (*pcnt) + i),
				(i + 1 == phost->h_length ? "\"" : "")));
d447 1
a447 1
	CTRACE((tfp, "\n"));
d453 7
a459 7
 *  fill_rehostent - copies as much as possible relevant content from
 *  the LYNX_HOSTENT pointed to by phost to the char buffer given
 *  by rehostent, subject to maximum output length rehostentsize,
 *  following pointers and building self-contained output which can be
 *  cast to a LYNX_HOSTENT. - kw
 *  See also description of LYGetHostByName.
 */
d462 1
a462 1
#define REHOSTENT_SIZE 128	/* not bigger than pipe buffer! */
d465 8
a472 7
    LYNX_HOSTENT h;
    char rest[REHOSTENT_SIZE];
} AlignedHOSTENT;

static size_t fill_rehostent(char *rehostent,
			     size_t rehostentsize,
			     const LYNX_HOSTENT *phost)
d474 1
a474 1
    AlignedHOSTENT *data = (AlignedHOSTENT *) rehostent;
d482 1
a482 1
    size_t curlen = sizeof(LYNX_HOSTENT);
a489 1

d513 1
a513 1
	for (pcnt = phost->h_addr_list + 1; *pcnt; pcnt++) {
d524 1
a524 1
	for (pcnt = phost->h_aliases; *pcnt; pcnt++) {
d536 1
a536 1
    p_next_charptr = (char **) (rehostent + curlen);
d539 1
a539 1
	p_next_char += (num_addrs + 1) * sizeof(phost->h_addr_list[0]);
d541 1
a541 1
	p_next_char += (num_aliases + 1) * sizeof(phost->h_aliases[0]);
d545 1
a545 1
	for (pcnt = phost->h_addr_list, i_addr = 0;
d571 1
a571 1
	for (pcnt = phost->h_aliases, i_alias = 0;
d590 1
a590 1
    curlen = p_next_char - (char *) rehostent;
a598 1

d600 1
a600 1
#ifndef h_errno			/* there may be a macro as well as the extern data */
d606 35
a640 34
 *	------------------------------------------------
 *
 *  On entry,
 *	str	points to the given host name, not numeric address,
 *		without colon or port number.
 *
 *  On exit,
 *	returns a pointer to a LYNX_HOSTENT in static storage,
 *	or NULL in case of error or user interruption.
 *
 *  The interface is intended to be exactly the same as for (Unix)
 *  gethostbyname(), except for the following:
 *
 *  If NSL_FORK is not used, the result of gethostbyname is returned
 *  directly.  Otherwise:
 *  All lists, addresses, and strings referred to by pointers in the
 *  returned struct are located, together with the returned struct
 *  itself, in a buffer of size REHOSTENT_SIZE.  If not everything fits,
 *  some info is omitted, but the function is careful to still return
 *  a valid structure, without truncating strings; it tries to return,
 *  in order of decreasing priority, the first address (h_addr), the
 *  official name (h_name), the additional addresses, then alias names.
 *
 *  If NULL is returned, the reason is made available in the global
 *  variable lynx_nsl_status, with one of the following values:
 *	HT_INTERRUPTED		Interrupted by user
 *	HT_NOT_ACCEPTABLE	Hostname detected as invalid
 *				(also sets h_errno)
 *	HT_H_ERRNO_VALID	An error occurred, and h_errno holds
 *				an appropriate value
 *	HT_ERROR		Resolver error, reason not known
 *	HT_INTERNAL		Internal error
 */
LYNX_HOSTENT *LYGetHostByName(char *str)
d642 1
d644 1
a648 1

d650 4
a653 3
     * We could define rehosten directly as a static char
     * rehostent[REHOSTENT_SIZE], but the indirect approach via the above
     * struct should automatically take care of alignment requirements.
d655 7
a661 6
     * - this must be static, as we shall return a pointer to it which must
     *   remain valid, and
     * - we have to use the same rehostent in the child process as in the
     *   parent (its address in the parent's address space must be the same as
     *   in the child's, otherwise the internal pointers built by the child's
     *   call to fill_rehostent would be invalid when seen by the parent).  -kw
d663 1
a663 1
    char *rehostent = (char *) &aligned_full_rehostent;
d669 1
a669 1
	int child_errno;	/* sometimes useful to pass this on */
d677 1
a677 1
    LYNX_HOSTENT *result_phost = NULL;
d690 1
a690 1
    /*  Could disable this if all our callers already check - kw */
d697 4
d712 2
a713 1
#ifdef MVS			/* Outstanding problem with crash in MVS gethostbyname */
d717 1
a717 1
    CTRACE_FLUSH(tfp);		/* so child messages will not mess up parent log */
d723 4
a726 4
    /*
     * Start block for fork-based gethostbyname() with checks for interrupts. 
     * - Tom Zerucha (tz@@execpc.com) & FM
     */
a728 1

d734 3
a736 3
	 * Pipe, child pid, status buffers, start time, select() control
	 * variables.
	 */
a738 1

a740 1

d744 1
a744 1
	time_t start_time = time((time_t *) 0);
d747 1
a747 1
	long dns_patience = 30;	/* how many seconds will we wait for DNS? */
d750 9
a758 8
	/*
	 * Reap any children that have terminated since last time through. 
	 * This might include children that we killed, then waited with WNOHANG
	 * before they were actually ready to be reaped.  (Should be max of 1
	 * in this state, but the loop is safe if waitpid() is implemented
	 * correctly:  returns 0 when children exist but none have exited; -1
	 * with errno == ECHILD when no children.) -BL
	 */
d768 8
a775 7
	 * Attempt to prevent a rare situation where the child could execute
	 * the Lynx signal handlers because it gets killed before it even has a
	 * chance to reset its handlers, resulting in bogus 'Exiting via
	 * interrupt' message and screen corruption or worse.
	 * Should that continue to be reported, for systems without
	 * sigprocmask(), we need to find a different solutions for those.  -
	 * kw 19990430
d792 2
a793 3
	if ((fpid = fork()) == 0) {
	    LYNX_HOSTENT *phost;	/* Pointer to host - See netdb.h */

d795 4
a798 4
	     * Child - for the long call.
	     *
	     * Make sure parent can kill us at will.  -BL
	     */
d802 6
a807 5
	     * Also make sure the child does not run one of the signal handlers
	     * that may have been installed by Lynx if one of those signals
	     * occurs.  For example we don't want the child to remove temp
	     * files on ^C, let the parent deal with that.  - kw
	     */
d835 2
a836 2
	     * Child won't use read side.  -BL
	     */
d859 1
a859 1
		dump_hostent("CHILD fill_rehostent", (LYNX_HOSTENT *) rehostent);
d862 2
a863 2
	    if (rehostentlen <= sizeof(LYNX_HOSTENT) ||
		!OK_HOST((LYNX_HOSTENT *) rehostent)) {
d867 1
a867 1
		statuses.h_length = ((LYNX_HOSTENT *) rehostent)->h_length;
d869 1
a869 1
		if (h_errno == -2)	/* success, but h_errno unchanged? */
d874 4
a877 4
	     * Send variables indicating status of lookup to parent.  That
	     * includes rehostentlen, which the parent will use as the size for
	     * the second read (if > 0).
	     */
d879 1
a879 1
		statuses.child_errno = errno;
d883 1
d886 2
a887 2
		 * Return our resulting rehostent through pipe...
		 */
d892 2
a893 2
		 * ...  or return error as exit code.
		 */
d897 1
d900 3
a902 3
	 * (parent) Restore signal mask to whatever it was before the fork.  -
	 * kw
	 */
d907 3
a909 3
	 * (parent) Wait until lookup finishes, or interrupt, or cycled too
	 * many times (just in case) -BL
	 */
d911 1
a911 1
	close(pfd[1]);		/* parent won't use write side -BL */
d913 3
a915 3
	if (fpid < 0) {		/* fork failed */
	    close(pfd[0]);
	    goto failed;
d918 1
a918 1
	while (child_exited || (long) (time((time_t *) 0) - start_time) < dns_patience) {
d922 9
a930 9
	     * This allows us to abort immediately, not after 1-second timeout,
	     * when user hits abort key.  Can't do this when using SLANG (or at
	     * least I don't know how), so SLANG users must live with up-to-1s
	     * timeout.  -BL
	     *
	     * Whoops -- we need to make sure stdin is actually selectable! 
	     * /dev/null isn't, on some systems, which makes some useful Lynx
	     * invocations fail.  -BL
	     */
a932 1

d942 5
a946 5
	    /*
	     * Return when data received, interrupted, or failed.  If nothing
	     * is waiting, we sleep for 1 second in select(), to be nice to the
	     * system.  -BL
	     */
d949 1
a949 1
		selret = Rselect(pfd[0] + 1, (void *) &readfds, NULL, NULL, &one_second);
d952 1
a952 1
		selret = select(pfd[0] + 1, (void *) &readfds, NULL, NULL, &one_second);
d956 2
a957 2
		 * First get status, including length of address.  -BL, kw
		 */
d966 8
a973 7
			 * If something went wrong in the child process other
			 * than normal lookup errors, and it appears that we
			 * have enough info to know what went wrong, generate
			 * diagnostic output.  ENOMEM observed on linux in
			 * processes constrained with ulimit.  It would be too
			 * unkind to abort the session, access to local files
			 * or through a proxy may still work.  - kw
d977 1
a977 1
			       (errno && h_errno == NETDB_INTERNAL) ||
d979 6
a984 6
			       (errno == ENOMEM &&
				statuses.rehostentlen == 0 &&
			/* should probably be NETDB_INTERNAL if child
			   memory exhausted, but we may find that
			   h_errno remains unchanged. - kw */
				h_errno == -2)) {
d991 3
a993 3
				 * Not much point in continuing, right?  Fake a
				 * 'z', should shorten pointless guessing
				 * cycle.  - kw
d1000 1
a1000 1
		    if (statuses.rehostentlen > sizeof(LYNX_HOSTENT)) {
d1002 2
a1003 2
			 * Then get the full reorganized hostent.  -BL, kw
			 */
d1006 1
a1006 1
			dump_hostent("Read from pipe", (LYNX_HOSTENT *) rehostent);
d1010 1
a1010 1
			    result_phost = (LYNX_HOSTENT *) rehostent;
d1020 2
a1021 2
		 * Make sure child is cleaned up.  -BL
		 */
d1032 2
a1033 2
	     * Clean up if child exited before & no data received.  -BL
	     */
d1039 2
a1040 2
	     * If child exited, loop once more looking for data.  -BL
	     */
d1043 4
a1046 4
		 * Data will be arriving right now, so make sure we don't
		 * short-circuit out for too many loops, and skip the interrupt
		 * check.  -BL
		 */
d1052 2
a1053 2
	     * Abort if interrupt key pressed.
	     */
d1070 2
a1071 3
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",
			(int) waitret, WEXITSTATUS(waitstat)));
d1073 2
a1074 3
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
			(int) waitret, WTERMSIG(waitstat)));
d1077 2
a1078 3
		    CTRACE((tfp,
			    "LYGetHostByName: NSL_FORK child %d dumped core!\n",
			    (int) waitret));
d1082 2
a1083 3
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
			(int) waitret, WSTOPSIG(waitstat)));
d1099 3
a1101 4

	    t = (unsigned long) inet_addr(host);
	    if (t != INADDR_NONE)
		phost = gethostbyaddr((char *) &t, sizeof(t), AF_INET);
d1106 1
a1106 1
	    phost = (LYNX_HOSTENT *) NULL;
d1108 3
a1110 4
	    WSASetLastError(WSAHOST_NOT_FOUND);

	    hThread = CreateThread(NULL, 4096UL, _fork_func, host, 0UL,
				   (unsigned long *) &dwThreadID);
d1112 1
a1112 1
		MessageBox(NULL, "CreateThread",
d1120 2
a1121 2
			MessageBox((void *) NULL,
				   "CloseHandle", "CloseHandle Failed", 0L);
d1141 1
a1141 2
	LYNX_HOSTENT *phost;

d1164 1
a1164 1
  failed:
d1166 1
a1166 1
	    host));
d1170 1
d1172 11
a1182 11
 *	-------------------------------------
 *
 *  On entry,
 *	str	points to a string with a node name or number,
 *		with optional trailing colon and port number.
 *	soc_in	points to the binary internet or decnet address field.
 *
 *  On exit,
 *	*soc_in is filled in.  If no port is specified in str, that
 *		field is left unchanged in *soc_in.
 */
d1184 3
a1186 1
static int HTParseInet(SockA * soc_in, const char *str)
d1191 1
d1193 1
d1204 3
d1208 1
d1210 2
a1211 2
     * Parse port number if present.
     */
d1217 1
a1217 1
	    soc_in->sin_port = (PortNumber) htons(strtol(port, &strptr, 10));
d1220 1
a1220 1
	    soc_in->sdn_objnum = (unsigned char) (strtol(port, &strptr, 10));
d1222 1
a1222 1
	    soc_in->sin_port = htons((PortNumber) strtol(port, &strptr, 10));
d1225 1
a1225 1
#ifdef SUPPRESS			/* 1. crashes!?!.  2. URL syntax has number not name */
d1227 1
a1227 2
	    struct servent *serv = getservbyname(port, (char *) 0);

d1236 1
d1238 1
d1243 1
d1246 4
a1249 4
     * Read Decnet node name.  @@@@ Should know about DECnet addresses, but it's
     * probably worth waiting until the Phase transition from IV to V.
     */
    soc_in->sdn_nam.n_len = min(DN_MAXNAML, strlen(host));	/* <=6 in phase 4 */
d1251 3
a1253 4
    CTRACE((tfp,
	    "DECnet: Parsed address as object number %d on host %.6s...\n",
	    soc_in->sdn_objnum, host));
#else /* parse Internet host: */
d1255 1
a1255 1
    if (*host >= '0' && *host <= '9') {		/* Test for numeric node address: */
d1271 3
a1273 3
     * Parse host number if present.
     */
    if (dotcount_ip == 3)	/* Numeric node address: */
d1276 1
a1276 1
	soc_in->sin_addr.s_addr = inet_addr(host).s_addr;	/* See arpa/inet.h */
d1279 1
a1279 1
	soc_in->sin_addr = inet_addr(host);	/* See netinet/in.h */
d1284 1
d1286 1
d1294 1
d1296 3
a1298 1
    } else {			/* Alphanumeric node name: */
d1300 1
a1300 1
#ifdef MVS			/* Outstanding problem with crash in MVS gethostbyname */
d1306 2
a1307 3
	if (!phost)
	    goto failed;
	memcpy((void *) &soc_in->sin_addr, phost->h_addr, phost->h_length);
d1310 1
a1310 2
	    LYNX_HOSTENT *phost;

d1313 1
a1313 2
	    if (!phost)
		goto failed;
d1316 8
a1323 9
	     * In LIBCMU, phost->h_length contains not the length of one
	     * address (four bytes) but the number of bytes in *h_addr, i.e.,
	     * some multiple of four.  Thus we need to hard code the value
	     * here, and remember to change it if/when IP addresses change in
	     * size.  :-( LIBCMU is no longer supported, and CMU users are
	     * encouraged to obtain and use SOCKETSHR/NETLIB instead.  - S. 
	     * Bjorndahl
	     */
	    memcpy((void *) &soc_in->sin_addr, phost->h_addr, 4);
d1325 1
a1325 2
	    if (!phost)
		goto failed;
d1329 1
a1329 1
	    memcpy((void *) &soc_in->sin_addr, phost->h_addr, phost->h_length);
d1334 1
d1336 1
a1336 1
    }				/* Alphanumeric node name */
d1338 9
a1346 8
    CTRACE((tfp,
	    "HTParseInet: Parsed address as port %d, IP address %d.%d.%d.%d\n",
	    (int) ntohs(soc_in->sin_port),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 0),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 1),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 2),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 3)));
#endif /* Internet vs. Decnet */
d1348 1
a1348 1
    return 0;			/* OK */
d1350 1
a1350 1
  failed:
d1352 2
a1353 1
	    host));
d1355 1
d1357 4
a1360 4
    case HT_NOT_ACCEPTABLE:
    case HT_INTERRUPTED:
	return lynx_nsl_status;
    default:
d1367 4
a1370 2
static LYNX_ADDRINFO *HTGetAddrInfo(const char *str,
				    const int defport)
d1372 1
a1372 1
    LYNX_ADDRINFO hints, *res;
d1412 4
a1415 4
 *	-------------------------------------------
 *
 */
static void free_HTTCP_hostname(void)
d1422 4
a1425 4
 *	-------------------------------------------
 *
 */
static void get_host_details(void)
d1427 1
a1427 2
    char name[MAXHOSTNAMELEN + 1];	/* The name of this host */

d1429 1
a1429 1
    char *domain_name;		/* The name of this host domain */
d1431 1
a1431 1
#ifdef NEED_HOST_ADDRESS	/* no -- needs name server! */
d1433 1
a1433 1
    LYNX_ADDRINFO hints, *res;
a1434 1

d1436 1
a1436 1
    LYNX_HOSTENT *phost;	/* Pointer to host -- See netdb.h */
d1442 1
a1442 1
	return;			/* Already done */
d1450 4
a1453 4
     * UCX doesn't give the complete domain name.  Get rest from UCX$BIND_DOM
     * logical.
     */
    if (strchr(hostname, '.') == NULL) {	/* Not full address */
d1461 1
a1461 1
    }
d1465 2
a1466 2
#ifndef DECNET			/* Decnet ain't got no damn name server 8#OO */
#ifdef NEED_HOST_ADDRESS	/* no -- needs name server! */
d1477 1
a1477 1
	return;			/* Fail! */
d1485 3
a1487 4
	CTRACE((tfp,
		"TCP: Can't find my own internet node address for `%s'!!\n",
		name));
	return;			/* Fail! */
d1493 1
a1493 1
	    hostname, HTInetString(&HTHostAddress)));
d1499 1
a1499 1
const char *HTHostName(void)
d1506 3
a1508 3
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
#define SOCKET_DEBUG_TRACE	/* show errno status after some system calls */
#endif /* UCX && VAXC */
d1511 9
a1519 8
 *  Interruptible connect as implemented for Mosaic by Marc Andreesen
 *  and hacked in for Lynx years ago by Lou Montulli, and further
 *  modified over the years by numerous Lynx lovers. - FM
 */
int HTDoConnect(const char *url,
		char *protocol,
		int default_port,
		int *s)
a1525 1

d1527 1
a1527 2
    LYNX_ADDRINFO *res = 0, *res0 = 0;

d1533 2
a1534 2
     * Set up defaults.
     */
d1541 2
a1542 2
     * Get node name and optional port number.
     */
d1546 2
a1547 2
	 * If there's an @@ then use the stuff after it as a hostname.
	 */
d1554 2
a1555 2
    HTSprintf0(&line, "%s%s", WWW_FIND_MESSAGE, host);
    _HTProgress(line);
d1560 1
a1560 1
	HTSprintf0(&line, gettext("Unable to locate remote host %s."), host);
d1571 3
a1573 3
		/* Not HTProgress, so warning won't be overwritten immediately;
		 * but not HTAlert, because typically there will be other
		 * alerts from the callers.  - kw
d1577 2
a1578 2
		HTSprintf0(&line,
			   gettext("Unable to locate remote host %s."), host);
d1589 2
a1590 2
    HTSprintf0(&line, gettext("Making %s connection to %s"), protocol, host);
    _HTProgress(line);
d1595 3
a1597 9
     * Now, let's get a socket set up from the server for the data.
     */
#ifndef INET6
    *s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (*s == -1) {
	HTAlert(gettext("socket failed."));
	return HT_NO_DATA;
    }
#else
a1601 1

d1603 5
a1607 6
			hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
			NI_NUMERICHOST | NI_NUMERICSERV);
	    HTSprintf0(&line,
		       gettext("socket failed: family %d addr %s port %s."),
		       res->ai_family, hostbuf, portbuf);
	    _HTProgress(line);
d1611 6
d1621 6
a1626 6
	/*
	 * Make the socket non-blocking, so the connect can be canceled.  This
	 * means that when we issue the connect we should NOT have to wait for
	 * the accept on the other end.
	 */
	{
d1628 1
a1628 2
	    int ret = fcntl(*s, F_SETFL, O_NONBLOCK);

d1630 2
a1631 2
	    int val = 1;
	    int ret = IOCTL(*s, FIONBIO, &val);
d1633 3
a1635 3
	    if (ret == -1)
		_HTProgress(gettext("Could not make connection non-blocking."));
	}
d1639 5
a1643 5
	/*
	 * Issue the connect.  Since the server can't do an instantaneous
	 * accept and we are non-blocking, this will almost certainly return a
	 * negative status.
	 */
d1645 1
a1645 1
	if (socks_flag) {
d1647 1
a1647 1
	    status = Rconnect(*s, res->ai_addr, res->ai_addrlen);
d1649 2
a1650 2
	    status = Rconnect(*s, (struct sockaddr *) &soc_address,
			      sizeof(soc_address));
d1652 5
a1656 5
	    /*
	     * For long Rbind.
	     */
	    socks_bind_remoteAddr = soc_address.sin_addr.s_addr;
	} else
d1659 1
a1659 1
	    status = connect(*s, res->ai_addr, res->ai_addrlen);
d1661 1
a1661 1
	    status = connect(*s, (struct sockaddr *) &soc_address, sizeof(soc_address));
d1664 20
a1683 20
	/*
	 * According to the Sun man page for connect:
	 *  EINPROGRESS         The socket is non-blocking and the  con-
	 *                      nection cannot be completed immediately.
	 *                      It is possible to select(2) for  comple-
	 *                      tion  by  selecting the socket for writ-
	 *                      ing.
	 * According to the Motorola SVR4 man page for connect:
	 *  EAGAIN              The socket is non-blocking and the  con-
	 *                      nection cannot be completed immediately.
	 *                      It is possible to select for  completion
	 *                      by  selecting  the  socket  for writing.
	 *                      However, this is only  possible  if  the
	 *                      socket  STREAMS  module  is  the topmost
	 *                      module on  the  protocol  stack  with  a
	 *                      write  service  procedure.  This will be
	 *                      the normal case.
	 */
	if ((status < 0) &&
	    (SOCKET_ERRNO == EINPROGRESS
d1685 1
a1685 1
	     || SOCKET_ERRNO == EAGAIN
d1687 4
a1690 4
	    )) {
	    struct timeval select_timeout;
	    int ret;
	    int tries = 0;
d1693 1
a1693 1
	    HTInetStatus("this socket's first connect");
d1695 3
a1697 3
	    ret = 0;
	    while (ret <= 0) {
		fd_set writefds;
d1699 5
a1703 5
		/*
		 * Protect against an infinite loop.
		 */
		if ((tries++ / 10) >= connect_timeout) {
		    HTAlert(gettext("Connection failed (too many retries)."));
d1705 3
a1707 3
		    FREE(line);
		    if (res0)
			freeaddrinfo(res0);
d1709 3
a1711 2
		    return HT_NO_DATA;
		}
d1713 2
a1714 2
		select_timeout.tv_sec = connect_timeout;
		select_timeout.tv_usec = 0;
d1716 2
a1717 2
		select_timeout.tv_sec = 0;
		select_timeout.tv_usec = 100000;
d1719 2
a1720 2
		FD_ZERO(&writefds);
		FD_SET((unsigned) *s, &writefds);
d1722 4
a1725 4
		if (socks_flag)
		    ret = Rselect((unsigned) *s + 1, NULL,
				  (void *) &writefds, NULL, &select_timeout);
		else
d1727 1
a1727 5
		    ret = select((unsigned) *s + 1,
				 NULL,
				 (void *) &writefds,
				 NULL,
				 &select_timeout);
d1730 3
a1732 3
		if (tries == 1) {
		    HTInetStatus("this socket's first select");
		}
d1734 6
a1739 6
		/*
		 * If we suspend, then it is possible that select will be
		 * interrupted.  Allow for this possibility.  - JED
		 */
		if ((ret == -1) && (errno == EINTR))
		    continue;
d1742 3
a1744 3
		if (ret < 0) {
		    HTInetStatus("failed select");
		}
d1746 14
d1761 4
a1764 19
		 * Again according to the Sun and Motorola man pages for
		 * connect:
		 *  EALREADY    The socket is non-blocking and a  previ-
		 *              ous  connection attempt has not yet been
		 *              completed.
		 * Thus if the SOCKET_ERRNO is NOT EALREADY we have a real
		 * error, and should break out here and return that error. 
		 * Otherwise if it is EALREADY keep on trying to complete the
		 * connection.
		 */
		if ((ret < 0) && (SOCKET_ERRNO != EALREADY)) {
		    status = ret;
		    break;
		} else if (ret > 0) {
		    /*
		     * Extra check here for connection success, if we try to
		     * connect again, and get EISCONN, it means we have a
		     * successful connection.  But don't check with SOCKS.
		     */
d1766 3
a1768 3
		    if (socks_flag) {
			status = 0;
		    } else {
d1771 1
a1771 1
			status = connect(*s, res->ai_addr, res->ai_addrlen);
d1773 2
a1774 2
			status = connect(*s, (struct sockaddr *) &soc_address,
					 sizeof(soc_address));
d1777 7
a1783 6
			/*
			 * A UCX feature:  Instead of returning EISCONN UCX
			 * returns EADDRINUSE.  Test for this status also.
			 */
			if ((status < 0) && ((SOCKET_ERRNO == EISCONN) ||
					     (SOCKET_ERRNO == EADDRINUSE)))
d1785 1
a1785 1
			if ((status < 0) && (SOCKET_ERRNO == EISCONN))
d1787 3
a1789 3
			{
			    status = 0;
			}
d1791 3
a1793 3
			if (status && (SOCKET_ERRNO == EALREADY))	/* new stuff LJM */
			    ret = 0;	/* keep going */
			else {
d1795 3
a1797 3
			    if (status < 0) {
				HTInetStatus("confirm-ready connect");
			    }
d1799 2
a1800 2
			    break;
			}
d1802 1
a1802 1
		    }
d1804 1
a1804 1
		}
d1806 1
a1806 1
		else if (!socks_flag)
d1808 1
a1808 1
		else
d1810 13
a1822 14
		{
		    /*
		     * The select says we aren't ready yet.  Try to connect
		     * again to make sure.  If we don't get EALREADY or
		     * EISCONN, something has gone wrong.  Break out and report
		     * it.
		     *
		     * For some reason, SVR4 returns EAGAIN here instead of
		     * EALREADY, even though the man page says it should be
		     * EALREADY.
		     *
		     * For some reason, UCX pre 3 apparently returns errno =
		     * 18242 instead the EALREADY or EISCONN.
		     */
d1824 1
a1824 1
		    status = connect(*s, res->ai_addr, res->ai_addrlen);
d1826 2
a1827 2
		    status = connect(*s, (struct sockaddr *) &soc_address,
				     sizeof(soc_address));
d1829 2
a1830 2
		    if ((status < 0) &&
			(SOCKET_ERRNO != EALREADY
d1832 1
a1832 1
			 && SOCKET_ERRNO != EAGAIN
d1834 1
a1834 1
			) &&
d1836 1
a1836 1
			(SOCKET_ERRNO != 18242) &&
d1838 1
a1838 1
			(SOCKET_ERRNO != EISCONN)) {
d1840 1
a1840 1
			HTInetStatus("confirm-not-ready connect");
d1842 1
a1842 2
			break;
		    }
d1844 4
a1847 3
		if (HTCheckForInterrupt()) {
		    CTRACE((tfp, "*** INTERRUPTED in middle of connect.\n"));
		    status = HT_INTERRUPTED;
d1849 1
a1849 1
		    WSASetLastError(EINTR);
d1851 1
a1851 1
		    SOCKET_ERRNO = EINTR;
d1853 1
a1853 2
		    break;
		}
d1856 1
d1858 3
a1860 3
	else if (status < 0) {
	    HTInetStatus("this socket's first and only connect");
	}
d1864 3
a1866 3
	    NETCLOSE(*s);
	    *s = -1;
	    continue;
d1879 3
a1881 3
	 * The connect attempt failed or was interrupted, so close up the
	 * socket.
	 */
d1888 2
a1889 2
	 * Make the socket blocking again on good connect.
	 */
a1891 1

d1911 6
a1916 5
 *  This is so interruptible reads can be implemented cleanly.
 */
int HTDoRead(int fildes,
	     void *buf,
	     unsigned nbyte)
d1921 1
a1921 2
    int tries = 0;

d1924 1
a1924 1
    time_t otime = time((time_t *) 0);
d1933 2
a1934 2
	 * 0 can be a valid socket fd, but if it's a tty something must have
	 * gone wrong.  - kw
d1953 1
d1961 2
a1962 2
	 * Protect against an infinite loop.
	 */
d1972 1
d1975 1
a1975 1
	    time_t t = time((time_t *) 0);
d1986 3
a1988 3
	 * If we suspend, then it is possible that select will be interrupted. 
	 * Allow for this possibility.  - JED
	 */
d1993 1
a1993 1
	    FD_SET((unsigned) fildes, &readfds);
d1996 2
a1997 2
		ret = Rselect((unsigned) fildes + 1,
			      (void *) &readfds, NULL, NULL, &select_timeout);
d2000 2
a2001 2
		ret = select((unsigned) fildes + 1,
			     (void *) &readfds, NULL, NULL, &select_timeout);
d2020 1
a2020 1
    while ((nb = SOCKET_READ(fildes, buf, nbyte)) == -1) {
d2031 2
a2032 2
#else /* UNIX */
    return SOCKET_READ(fildes, buf, nbyte);
d2035 1
a2035 1
#else /* UCX && VAXC */
d2037 2
a2038 2
     * VAXC and UCX problem only.
     */
d2040 1
a2040 1
    nb = SOCKET_READ(fildes, buf, nbyte);
d2042 1
a2042 1
	    "Read - nb,errno,vaxc$errno: %d %d %d\n", nb, errno, vaxc$errno));
d2044 1
a2044 1
	perror("HTTCP.C:HTDoRead:read");	/* RJF */
d2046 2
a2047 2
     * An errno value of EPIPE and nb < 0 indicates end-of-file on VAXC.
     */
d2058 14
a2071 14
 *  This is a fix for the difference between BSD's select() and
 *  SVR4's select().  SVR4's select() can never return a value larger
 *  than the total number of file descriptors being checked.  So, if
 *  you select for read and write on one file descriptor, and both
 *  are true, SVR4 select() will only return 1.  BSD select in the
 *  same situation will return 2.
 *
 *	Additionally, BSD select() on timing out, will zero the masks,
 *	while SVR4 does not.  This is fixed here as well.
 *
 *	Set your tabstops to 4 characters to have this code nicely formatted.
 *
 *	Jerry Whelan, guru@@bradley.edu, June 12th, 1993
 */
d2086 6
a2091 5
int BSDselect(int nfds,
	      fd_set * readfds,
	      fd_set * writefds,
	      fd_set * exceptfds,
	      struct timeval *select_timeout)
d2093 2
a2094 1
    int rval, i;
d2101 1
a2101 1
	rval = select(nfds, readfds, writefds, exceptfds, select_timeout);
d2104 2
a2105 2
    case -1:
	return (rval);
d2107 17
a2123 17
    case 0:
	if (readfds != NULL)
	    FD_ZERO(readfds);
	if (writefds != NULL)
	    FD_ZERO(writefds);
	if (exceptfds != NULL)
	    FD_ZERO(exceptfds);
	return (rval);

    default:
	for (i = 0, rval = 0; i < nfds; i++) {
	    if ((readfds != NULL) && FD_ISSET(i, readfds))
		rval++;
	    if ((writefds != NULL) && FD_ISSET(i, writefds))
		rval++;
	    if ((exceptfds != NULL) && FD_ISSET(i, exceptfds))
		rval++;
d2125 2
a2126 2
	}
	return (rval);
@


1.1.3.6
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@a1392 1
    free(s);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d28 1
a28 1
#include <www_wait.h>
a34 4
#if defined(__DJGPP__) && defined (WATT32)
#include <netdb.h>
#endif /* __DJGPP__ */

d43 1
a43 1
	struct timeval * select_timeout));
d90 1
a90 1
**	returns		a negative status in the Unix way.
d92 12
d110 6
d117 3
a119 3
char host[512];
struct hostent  *phost;	/* Pointer to host - See netdb.h */
int donelookup;
d121 1
a121 1
static unsigned long _fork_func (void *arglist)
d123 3
a125 12
#ifdef SH_EX
    unsigned long addr;
    addr = (unsigned long)inet_addr(host);
    if ((int)addr != -1)
	phost = gethostbyaddr((char *)&addr, sizeof (addr), AF_INET);
    else
	phost = gethostbyname(host);
#else
    phost = gethostbyname(host);
#endif
    donelookup = TRUE;
    return (unsigned long)(phost);
d134 3
a136 1
#include <HTioctl.h>
d157 1
a157 1
	set_errno(EBADF);
d176 1
a176 1
	set_errno(status);
d180 1
a180 1
	set_errno(iosb[0]);
a186 3
#define MY_FORMAT "TCP: Error %d in `SOCKET_ERRNO' after call to %s() failed.\n\t%s\n"
	   /* third arg is transport/platform specific */

d191 1
a191 1
	char *,		where)
a192 2
    int status;
    int saved_errno = errno;
d199 4
d204 1
a204 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   "(Error number not translated)"));	/* What Is the VM equiv? */
d210 1
a210 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   vms_errno_string()));
a211 1
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
d213 1
a213 1
	    strerror(SOCKET_ERRNO) : "(Error number not translated)")));
d219 1
a219 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   strerror(SOCKET_ERRNO)));
a223 1
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
d225 1
a225 1
	    sys_errlist[SOCKET_ERRNO] : "Unknown error" )));
d230 1
a230 1
    CTRACE((tfp,
d232 2
a233 2
	   SOCKET_ERRNO));
    CTRACE((tfp,
d235 1
a235 1
	   vaxc$errno));
a238 2
    set_errno(saved_errno);

d244 1
a244 1
    status = -vmserrno;
d246 1
a246 1
    status = -vaxc$errno;
d249 1
a249 1
    status = -SOCKET_ERRNO;
a250 1
    return status;
d298 1
a298 1
	SockA*,		soc_in)
d300 1
a300 8
#ifdef INET6
    static char hostbuf[MAXHOSTNAMELEN];
    getnameinfo((struct sockaddr *)soc_in,
	    SOCKADDR_LEN(soc_in),
	    hostbuf, sizeof(hostbuf), NULL, 0, NI_NUMERICHOST);
    return hostbuf;
#else
    static char string[20];
a306 1
#endif /* INET6 */
a316 1
**  - no segment starts with '-' or '+' [this protects telnet command],
d330 1
a330 1
	char *,	name)
d333 1
a333 1
    char *cp = name;
a343 2
	} else if (iseg == 0 && (*cp == '-' || *cp == '+')) {
	    return NO;
d345 1
a345 1
	    return NO;
d347 1
a347 1
	if (!isalnum(UCH(*cp)) &&
d353 1
a353 1
    return (BOOL) (*cp == '\0' || (*cp == '.' && iseg != 0 && cp[1] == '\0'));
d371 1
a371 1
#if !( defined(__DJGPP__) && !defined(WATT32) )    /* much excluded! */
d390 1
a390 1
	CTRACE((tfp,"%s: %p ", msgprefix, phost));
d392 1
a392 1
	    CTRACE((tfp,"{ h_name = %p", phost->h_name));
d394 1
a394 1
		CTRACE((tfp, " \"%s\",", phost->h_name));
d396 1
a396 1
		CTRACE((tfp, ","));
d398 1
a398 1
	    CTRACE((tfp,"\n\t h_aliases = %p", phost->h_aliases));
d400 1
a400 1
		CTRACE((tfp, " {"));
d402 1
a402 1
		    CTRACE((tfp,"%s %p \"%s\"",
d404 1
a404 1
			   *pcnt, *pcnt));
d406 2
a407 2
		CTRACE((tfp, "%s0x0 },\n\t",
		       (*phost->h_aliases ? ", " : " ")));
d409 1
a409 1
		CTRACE((tfp, ",\n\t"));
d411 3
a413 3
	    CTRACE((tfp," h_addrtype = %d,", phost->h_addrtype));
	    CTRACE((tfp," h_length = %d,\n\t", phost->h_length));
	    CTRACE((tfp," h_addr_list = %p", phost->h_addr_list));
d415 1
a415 1
		CTRACE((tfp, " {"));
d417 1
a417 1
		    CTRACE((tfp,"%s %p",
d419 1
a419 1
			   *pcnt));
d421 1
a421 1
			CTRACE((tfp, "%s%d%s", (i==0 ? " \"" : "."),
d423 1
a423 1
			       (i+1 == phost->h_length ? "\"" : "")));
d427 1
a427 1
		    CTRACE((tfp, ", 0x0 } }"));
d429 1
a429 1
		    CTRACE((tfp, " 0x0 } }"));
d432 1
a432 1
		CTRACE((tfp, "}"));
d435 1
a435 1
	CTRACE((tfp,"\n"));
a447 9
#ifdef NSL_FORK

#define REHOSTENT_SIZE 128		/* not bigger than pipe buffer! */

typedef struct {
	struct hostent	h;
	char		rest[REHOSTENT_SIZE];
    } AlignedHOSTENT;

a452 1
    AlignedHOSTENT *data = (AlignedHOSTENT *)rehostent;
d512 2
a513 2
    data->h.h_addrtype = phost->h_addrtype;
    data->h.h_length = phost->h_length;
d522 1
a522 1
	data->h.h_addr_list = p_next_charptr;
d532 1
a532 1
	data->h.h_addr_list = NULL;
d536 1
a536 1
	data->h.h_name = p_next_char;
d544 1
a544 1
	data->h.h_name = NULL;
d548 1
a548 1
	data->h.h_aliases = p_next_charptr;
d566 1
a566 1
	data->h.h_aliases = NULL;
d571 2
a572 1
#endif /* NSL_FORK */
a578 1
#ifndef h_errno		/* there may be a macro as well as the extern data */
a580 1
#endif
d617 1
a617 1
	char *,	str)
d620 2
a621 2
    char *host = str;
#endif
d624 4
a627 1
    static AlignedHOSTENT aligned_full_rehostent;
d648 1
a648 1
	int child_errno;  /* sometimes useful to pass this on */
d659 1
a659 1
	CTRACE((tfp, "LYGetHostByName: Can't parse `NULL'.\n"));
d663 1
a663 1
    CTRACE((tfp, "LYGetHostByName: parsing `%s'.\n", str));
d667 1
a667 1
	CTRACE((tfp, "LYGetHostByName: INTERRUPTED for '%s'.\n", str));
a671 4
#ifdef _WINDOWS_NSL
    strncpy(host, str, sizeof(host));
#endif /*  _WINDOWS_NSL */

a674 3
#ifdef _WINDOWS
	WSASetLastError(NO_RECOVERY);
#else
a676 1
#endif
d680 6
d687 1
a687 1
    CTRACE((tfp, "LYGetHostByName: Calling gethostbyname(%s)\n", host));
d690 1
a690 1
    CTRACE_FLUSH(tfp);  /* so child messages will not mess up parent log */
a701 4
#if HAVE_SIGACTION
	sigset_t old_sigset;
	sigset_t new_sigset;
#endif
d707 2
a708 7
	int pfd[2], selret, readret;
#ifdef HAVE_TYPE_UNIONWAIT
	union wait waitstat;
#else
	int waitstat = 0;
#endif
	time_t start_time = time((time_t *)0);
d710 2
a711 2
	struct timeval one_second;
	long dns_patience = 30; /* how many seconds will we wait for DNS? */
a729 26
#if HAVE_SIGACTION
	/*
	 *  Attempt to prevent a rare situation where the child
	 *  could execute the Lynx signal handlers because it gets
	 *  killed before it even has a chance to reset its handlers,
	 *  resulting in bogus 'Exiting via interrupt' message and
	 *  screen corruption or worse.
	 *  Should that continue to be reported, for systems without
	 *  sigprocmask(), we need to find a different solutions for
	 *  those. - kw 19990430
	 */
	sigemptyset(&new_sigset);
	sigaddset(&new_sigset, SIGTERM);
	sigaddset(&new_sigset, SIGINT);
#ifndef NOSIGHUP
	sigaddset(&new_sigset, SIGHUP);
#endif /* NOSIGHUP */
#ifdef SIGTSTP
	sigaddset(&new_sigset, SIGTSTP);
#endif /* SIGTSTP */
#ifdef SIGWINCH
	sigaddset(&new_sigset, SIGWINCH);
#endif /* SIGWINCH */
	sigprocmask(SIG_BLOCK, &new_sigset, &old_sigset);
#endif /* HAVE_SIGACTION */

a766 5
#if HAVE_SIGACTION
	    /* Restore signal mask to whatever it was before the fork. -kw */
	    sigprocmask(SIG_SETMASK, &old_sigset, NULL);
#endif /* HAVE_SIGACTION */

a770 5
#ifdef HAVE_H_ERRNO
	    /* to detect cases when it doesn't get set although it should */
	    h_errno = -2;
#endif
	    set_errno(0);
a771 1
	    statuses.child_errno = errno;
a772 1
#ifdef HAVE_H_ERRNO
a773 1
#endif
d775 1
a775 1
	    CTRACE((tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost));
a792 4
#ifdef HAVE_H_ERRNO
		if (h_errno == -2) /* success, but h_errno unchanged? */
		    statuses.h_errno_valid = NO;
#endif
a798 1
	    if (!statuses.child_errno)
a817 8
#if HAVE_SIGACTION
	/*
	**  (parent) Restore signal mask to whatever it was
	**  before the fork. - kw
	*/
	sigprocmask(SIG_SETMASK, &old_sigset, NULL);
#endif /* HAVE_SIGACTION */

d830 1
a830 1
	while (child_exited || (long)(time((time_t *)0) - start_time) < dns_patience) {
d850 2
a851 2
	    one_second.tv_sec = 1;
	    one_second.tv_usec = 0;
d861 1
a861 1
		selret = Rselect(pfd[0] + 1, (void *)&readfds, NULL, NULL, &one_second);
d864 1
a864 1
		selret = select(pfd[0] + 1, (void *)&readfds, NULL, NULL, &one_second);
d873 2
a874 3
		    set_errno(statuses.child_errno);
#ifdef HAVE_H_ERRNO
		    if (statuses.h_errno_valid) {
a875 35
			/*
			 *  If something went wrong in the child process
			 *  other than normal lookup errors, and it appears
			 *  that we have enough info to know what went wrong,
			 *  generate diagnostic output.
			 *  ENOMEM observed on linux in processes constrained
			 *  with ulimit.  It would be too unkind to abort
			 *  the session, access to local files or through a
			 *  proxy may still work. - kw
			 */
			if (
#ifdef NETDB_INTERNAL		/* linux glibc: defined in netdb.h */
			    (errno && h_errno == NETDB_INTERNAL) ||
#endif
			    (errno == ENOMEM &&
			     statuses.rehostentlen == 0 &&
			     /* should probably be NETDB_INTERNAL if child
				memory exhausted, but we may find that
				h_errno remains unchanged. - kw */
			     h_errno == -2)) {
#ifndef MULTINET
			    HTInetStatus("CHILD gethostbyname");
#endif
			    HTAlert(LYStrerror(statuses.child_errno));
			    if (errno == ENOMEM) {
				/*
				 *  Not much point in continuing, right?
				 *  Fake a 'z', should shorten pointless
				 *  guessing cycle. - kw
				 */
				LYFakeZap(YES);
			    }
			}
		    }
#endif /* HAVE_H_ERRNO */
d891 1
a891 1
		    }
d931 1
a931 1
		CTRACE((tfp, "LYGetHostByName: INTERRUPTED gethostbyname.\n"));
d946 2
a947 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",
			(int)waitret, WEXITSTATUS(waitstat)));
d949 2
a950 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
		       (int)waitret, WTERMSIG(waitstat)));
d953 2
a954 2
		    CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d dumped core!\n",
			   (int)waitret));
d958 2
a959 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
			(int)waitret, WEXITSTATUS(waitstat)));
d970 35
a1004 29
	HANDLE hThread, dwThreadID;

	if (!system_is_NT) {	/* for Windows9x */
	    unsigned long t;
	    t = (unsigned long)inet_addr(host);
	    if ((int)t != -1)
		phost = gethostbyaddr((char *)&t, sizeof (t), AF_INET);
	    else
		phost = gethostbyname(host);
	} else {		/* for Windows NT */
	    phost = (struct hostent *) NULL;
	    donelookup = FALSE;
	    hThread = CreateThread((void *)NULL, 4096UL,
		(LPTHREAD_START_ROUTINE)_fork_func,
		(void *)NULL, 0UL, (unsigned long *)&dwThreadID);
	    if (!hThread)
		MessageBox((void *)NULL, "CreateThread",
			   "CreateThread Failed", 0L);

	    while (!donelookup) {
		if (HTCheckForInterrupt()) {
		    /* Note that host is a character array and is not freed */
		    /* to avoid possible subthread problems: */
		    if (!CloseHandle(hThread)) {
			MessageBox((void *)NULL,
				   "CloseHandle","CloseHandle Failed", 0L);
		    }
		    lynx_nsl_status = HT_INTERRUPTED;
		    return NULL;
d1006 1
a1006 10
	    }
	}
	if (phost) {
	    lynx_nsl_status = HT_OK;
	    result_phost = phost;
	} else {
	    lynx_nsl_status = HT_ERROR;
	    goto failed;
	}
    }
d1011 1
a1011 1
	phost = gethostbyname(host);	/* See netdb.h */
d1013 1
a1013 1
	CTRACE((tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost));
d1028 1
a1028 1
    CTRACE((tfp, "LYGetHostByName: Resolved name to a hostent.\n"));
d1034 2
a1035 2
    CTRACE((tfp, "LYGetHostByName: Can't find internet node name `%s'.\n",
		host));
d1039 1
a1039 1
#endif /* from here on DJGPP without WATT32 joins us again. */
d1054 1
a1054 2
#ifndef INET6
PRIVATE int HTParseInet ARGS2(
a1059 1
    char *strptr;
d1065 1
a1065 1
	CTRACE((tfp, "HTParseInet: Can't parse `NULL'.\n"));
d1068 1
a1068 1
    CTRACE((tfp, "HTParseInet: parsing `%s'.\n", str));
d1070 1
a1070 1
	CTRACE((tfp, "HTParseInet: INTERRUPTED for '%s'.\n", str));
d1074 1
a1074 1
    strncpy(host, str, sizeof(host));
a1082 1
	strptr = port;
d1084 2
a1085 2
#ifdef UNIX
	    soc_in->sin_port = (PortNumber)htons(strtol(port, &strptr, 10));
d1088 1
a1088 1
	    soc_in->sdn_objnum = (unsigned char)(strtol(port, &strptr, 10));
d1090 1
a1090 1
	    soc_in->sin_port = htons((PortNumber)strtol(port, &strptr, 10));
d1093 1
a1093 1
#ifdef SUPPRESS		/* 1. crashes!?!.  2. URL syntax has number not name */
d1099 1
a1099 1
		CTRACE((tfp, "TCP: Unknown service %s\n", port));
a1102 7
	if (strptr && *strptr != '\0') {
#ifndef _WINDOWS_NSL
	    FREE(host);
#endif /* _WINDOWS_NSL */
	    HTAlwaysAlert(NULL, gettext("Address has invalid port"));
	    return -1;
	}
d1112 2
a1113 2
    CTRACE((tfp, "DECnet: Parsed address as object number %d on host %.6s...\n",
		soc_in->sdn_objnum, host));
d1117 1
a1117 1
	strptr = host;
d1121 1
a1121 1
	    } else if (!isdigit(UCH(*strptr))) {
d1134 1
a1134 2
    if (dotcount_ip == 3)   /* Numeric node address: */
    {
d1136 1
a1136 1
#if defined(__DJGPP__) && !defined(WATT32)
d1147 1
a1147 1
	    CTRACE((tfp, "inet_aton(%s) returns error\n", host));
d1158 1
a1158 1
#endif /* __DJGPP__ && !WATT32 */
d1162 1
a1162 2
    } else
    {			    /* Alphanumeric node name: */
d1165 1
a1165 1
	CTRACE((tfp, "HTParseInet: Calling LYGetHostByName(%s)\n", host));
d1168 1
a1168 1
#if defined(__DJGPP__) && !defined(WATT32)
d1177 1
a1177 1
#else /* !(__DJGPP__ && !WATT32) */
d1182 1
a1182 1
#else /* !(__DJGPP__ && !WATT32) && !_WINDOWS_NSL */
d1206 2
a1207 2
#endif /* _WINDOWS_NSL */
#endif /* __DJGPP__ && !WATT32 */
d1214 1
a1214 1
    CTRACE((tfp, "HTParseInet: Parsed address as port %d, IP address %d.%d.%d.%d\n",
d1219 1
a1219 1
		(int)*((unsigned char *)(&soc_in->sin_addr)+3)));
d1225 2
a1226 2
    CTRACE((tfp, "HTParseInet: Can't find internet node name `%s'.\n",
		host));
d1231 5
a1235 6
	case HT_NOT_ACCEPTABLE:
	case HT_INTERRUPTED:
	    return lynx_nsl_status;
	default:
	return -1;
    }
a1236 43
#endif /* !INET6 */

#ifdef INET6
PRIVATE struct addrinfo *
HTGetAddrInfo ARGS2(
    CONST char *, str,
    CONST int, defport)
{
    struct addrinfo hints, *res;
    int error;
    char *p;
    char *s;
    char *host, *port;
    char pbuf[10];

    s = strdup(str);

    if (s[0] == '[' && (p = strchr(s, ']')) != NULL) {
	*p++ = '\0';
	host = s + 1;
    } else {
	p = s;
	host = &s[0];
    }
    port = strrchr(p, ':');
    if (port) {
	*port++ = '\0';
    } else {
	snprintf(pbuf, sizeof(pbuf), "%d", defport);
	port = pbuf;
    }

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, port, &hints, &res);
    if (error || !res) {
	CTRACE((tfp, "HTGetAddrInfo: getaddrinfo(%s, %s): %s\n", host, port,
		gai_strerror(error)));
	res = NULL;
    }

    return res;
a1237 1
#endif /* INET6 */
a1264 4
#ifdef INET6
    struct addrinfo hints, *res;
    int error;
#else
a1265 1
#endif /* INET6 */
d1270 1
a1270 1
	return;				/* Already done */
d1281 1
a1281 1
    if (strchr(hostname,'.') == NULL) {		  /* Not full address */
a1282 2
	if (domain_name == NULL)
	    domain_name = getenv("TCPIP$BIND_DOMAIN");
d1289 1
a1289 1
    CTRACE((tfp, "TCP: Local host name is %s\n", hostname));
a1292 16
#ifdef INET6
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_CANONNAME;
    error = getaddrinfo(name, NULL, &hints, &res);
    if (error || !res || !res->ai_canonname) {
	CTRACE((tfp, "TCP: %s: `%s'\n", gai_strerror(error), name));
	if (res)
	    freeaddrinfo(res);
	return;  /* Fail! */
    }
    StrAllocCopy(hostname, res->ai_canonname);
    memcpy(&HTHostAddress, res->ai_addr, res->ai_addrlen);
    freeaddrinfo(res);
#else
d1295 2
a1296 2
	CTRACE((tfp, "TCP: Can't find my own internet node address for `%s'!!\n",
		    name));
d1301 2
a1302 3
#endif /* INET6 */
    CTRACE((tfp, "     Name server says that I am `%s' = %s\n",
		hostname, HTInetString(&HTHostAddress)));
a1313 5
#ifndef MULTINET		/* SOCKET_ERRNO != errno ? */
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
#define SOCKET_DEBUG_TRACE    /* show errno status after some system calls */
#endif  /* UCX && VAXC */
#endif /* MULTINET */
d1315 1
a1315 1
**  Interruptible connect as implemented for Mosaic by Marc Andreesen
d1321 1
a1321 1
	char *,		protocol,
d1325 3
a1327 1
    int status = 0;
a1331 5
#ifdef INET6
    struct addrinfo *res, *res0;
#else
    struct sockaddr_in soc_address;
    struct sockaddr_in *soc_in = &soc_address;
d1338 1
a1338 2
    soc_in->sin_port = htons((PortNumber) default_port);
#endif /* INET6 */
d1354 1
a1354 1
    HTSprintf0 (&line, "%s%s", WWW_FIND_MESSAGE, host);
a1355 12
#ifdef INET6
    /* HTParseInet() is useless! */
    _HTProgress(host);
    res0 = HTGetAddrInfo(host, default_port);
    if (res0 == NULL) {
	HTSprintf0 (&line, gettext("Unable to locate remote host %s."), host);
	_HTProgress(line);
	FREE(host);
	FREE(line);
	return HT_NO_DATA;
    }
#else
a1375 1
#endif /* INET6 */
d1377 1
a1377 1
    HTSprintf0 (&line, gettext("Making %s connection to %s"), protocol, host);
a1384 15
#ifdef INET6
    for (res = res0; res; res = res->ai_next) {
	*s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	if (*s == -1) {
	    char hostbuf[1024], portbuf[1024];
	    getnameinfo(res->ai_addr, res->ai_addrlen,
		    hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
		    NI_NUMERICHOST|NI_NUMERICSERV);
	    HTSprintf0 (&line, gettext("socket failed: family %d addr %s port %s."),
		    res->ai_family, hostbuf, portbuf);
	    _HTProgress (line);
	    FREE(line);
	    continue;
	}
#else
a1389 1
#endif /* INET6 */
a1417 3
#ifdef INET6
	status = Rconnect(*s, res->ai_addr, res->ai_addrlen);
#else
a1419 1
#endif /* INET6 */
a1425 3
#ifdef INET6
    status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
d1427 1
a1427 2
#endif /* INET6 */
#ifndef __DJGPP__
d1447 2
a1448 6
	(SOCKET_ERRNO == EINPROGRESS
#ifdef EAGAIN
	 || SOCKET_ERRNO == EAGAIN
#endif
	 )) {
	struct timeval select_timeout;
a1451 3
#ifdef SOCKET_DEBUG_TRACE
	HTInetStatus("this socket's first connect");
#endif /* SOCKET_DEBUG_TRACE */
d1459 2
a1460 6
	    if ((tries++/10) >= connect_timeout) {
		HTAlert(gettext("Connection failed (too many retries)."));
#ifdef INET6
		FREE(line);
		freeaddrinfo(res0);
#endif /* INET6 */
d1465 1
a1465 2
	    select_timeout.tv_sec = connect_timeout;
	    select_timeout.tv_usec = 0;
d1467 1
a1467 2
	    select_timeout.tv_sec = 0;
	    select_timeout.tv_usec = 100000;
d1469 1
d1471 1
a1471 1
	    FD_SET((unsigned) *s, &writefds);
d1475 1
a1475 1
			      (void *)&writefds, NULL, &select_timeout);
d1478 1
a1478 1
	    ret = select(FD_SETSIZE, NULL, (void *)&writefds, NULL, &select_timeout);
d1480 6
a1485 11
#ifdef SOCKET_DEBUG_TRACE
	    if (tries == 1) {
		HTInetStatus("this socket's first select");
	    }
#endif /* SOCKET_DEBUG_TRACE */
	    /*
	    **  If we suspend, then it is possible that select will be
	    **  interrupted.  Allow for this possibility. - JED
	    */
	    if ((ret == -1) && (errno == EINTR))
		continue;
a1486 5
#ifdef SOCKET_DEBUG_TRACE
	    if (ret < 0) {
		HTInetStatus("failed select");
	    }
#endif /* SOCKET_DEBUG_TRACE */
a1510 3
#ifdef INET6
		status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
a1512 1
#endif /* INET6 */
d1530 1
a1530 6
		else {
#ifdef SOCKET_DEBUG_TRACE
		    if (status < 0) {
			HTInetStatus("confirm-ready connect");
		    }
#endif /* SOCKET_DEBUG_TRACE */
a1531 1
		}
a1553 3
#ifdef INET6
		status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
a1555 1
#endif /* INET6 */
d1557 1
a1557 5
		    (SOCKET_ERRNO != EALREADY
#ifdef EAGAIN
		    && SOCKET_ERRNO != EAGAIN
#endif
		    ) &&
a1561 3
#ifdef SOCKET_DEBUG_TRACE
		    HTInetStatus("confirm-not-ready connect");
#endif /* SOCKET_DEBUG_TRACE */
d1566 1
a1566 1
		CTRACE((tfp, "*** INTERRUPTED in middle of connect.\n"));
a1567 3
#ifdef _WINDOWS
		WSASetLastError(EINTR);
#else
a1568 1
#endif
d1573 2
a1574 21
#ifdef SOCKET_DEBUG_TRACE
    else if (status < 0) {
	HTInetStatus("this socket's first and only connect");
    }
#endif /* SOCKET_DEBUG_TRACE */
#ifdef INET6
	if (status < 0) {
		NETCLOSE(*s);
		*s = -1;
		continue;
	}
	break;
    }
#endif /* INET6 */
#endif /* !__DJGPP__ */
#ifdef INET6
    if (*s < 0)
#else
    if (status < 0)
#endif /* INET6 */
    {
a1598 4
#ifdef INET6
    FREE(line);
    freeaddrinfo(res0);
#endif /* INET6 */
d1607 1
a1607 1
	void *,		buf,
d1612 1
a1612 1
    struct timeval select_timeout;
a1613 4
#ifdef EXP_READPROGRESS
    int otries = 0;
    time_t otime = time((time_t *)0);
#endif
d1625 1
a1625 1
	    CTRACE((tfp, "HTDoRead - refusing to read fd 0 which is a tty!\n"));
a1633 3
#ifdef _WINDOWS
	WSASetLastError(EINTR);
#else
a1634 1
#endif
a1648 3
#ifdef _WINDOWS
	    WSASetLastError(EINTR);
#else
a1649 1
#endif
a1652 12
#ifdef EXP_READPROGRESS
	if (tries - otries > 10) {
	    time_t t = time((time_t *)0);

	    otries = tries;
	    if (t - otime >= 5) {
		otime = t;
		HTReadProgress(-1, 0);	/* Put "stalled" message */
	    }
	}
#endif

d1658 2
a1659 2
	    select_timeout.tv_sec = 0;
	    select_timeout.tv_usec = 100000;
d1661 1
a1661 1
	    FD_SET((unsigned)fildes, &readfds);
d1665 1
a1665 1
			      (void *)&readfds, NULL, NULL, &select_timeout);
d1669 1
a1669 1
			     (void *)&readfds, NULL, NULL, &select_timeout);
a1676 3
#ifdef _WINDOWS
	    WSASetLastError(EINTR);
#else
a1677 1
#endif
d1685 1
d1693 1
d1707 2
a1708 2
    CTRACE((tfp,
	   "Read - nb,errno,vaxc$errno: %d %d %d\n", nb,errno,vaxc$errno));
d1716 1
a1716 1
	set_errno(0);
d1757 1
a1757 1
	struct timeval *,	select_timeout)
d1764 1
a1764 1
	rval = Rselect(nfds, readfds, writefds, exceptfds, select_timeout);
d1767 1
a1767 1
    rval = select(nfds, readfds, writefds, exceptfds, select_timeout);
d1772 1
d1782 1
@


1.1.1.3
log
@Import OpenBSD source tree from CVS (anoncvs canada)
of roughly 12:00 UTC today. Bumps us to OpenBSD 3.4
and makes source/ports in sync. Hopefully.
@
text
@d1736 1
a1736 1
		ret = Rselect(*s + 1, NULL,
d1740 1
a1740 1
	    ret = select(*s + 1, NULL, (void *)&writefds, NULL, &select_timeout);
d2008 1
a2008 1
		ret = Rselect(fildes + 1,
d2012 1
a2012 1
		ret = select(fildes + 1,
@


