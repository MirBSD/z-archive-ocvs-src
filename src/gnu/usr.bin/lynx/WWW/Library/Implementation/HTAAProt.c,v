head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.46;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.29;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.24;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.57.58;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.04;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.53;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.03;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.49;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.13;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.46.52;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@
/* MODULE							HTAAProt.c
 *		PROTECTION FILE PARSING MODULE
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	20 Oct 93  AL	Now finds uid/gid for nobody/nogroup by name
 *			(doesn't use default 65534 right away).
 *			Also understands negative uids/gids.
 *	14 Nov 93  MD	Added VMS compatibility
 *
 * BUGS:
 *
 *
 */

#include <HTUtils.h>

#ifndef VMS
#ifndef NOUSERS
#include <pwd.h>		/* Unix password file routine: getpwnam()       */
#include <grp.h>		/* Unix group file routine: getgrnam()          */
#endif /* NOUSERS */
#endif /* not VMS */

#include <HTAAUtil.h>
#include <HTLex.h>		/* Lexical analysor     */
#include <HTAAProt.h>		/* Implemented here     */

#include <LYUtils.h>
#include <LYLeaks.h>

#define NOBODY    65534		/* -2 in 16-bit environment */
#define NONESUCH  65533		/* -3 in 16-bit environment */

/*
 * Protection setup caching
 */
typedef struct {
    char *prot_filename;
    HTAAProt *prot;
} HTAAProtCache;

static HTList *prot_cache = NULL;	/* Protection setup cache.      */
static HTAAProt *default_prot = NULL;	/* Default protection.          */
static HTAAProt *current_prot = NULL;	/* Current protection mode      */

					/* which is set up by callbacks */
					/* from the rule system when    */
					/* a "protect" rule is matched. */

#ifndef NOUSERS
/* static							isNumber()
 *		DOES A CHARACTER STRING REPRESENT A NUMBER
 */
static BOOL isNumber(const char *s)
{
    const char *cur = s;

    if (isEmpty(s))
	return NO;

    if (*cur == '-')
	cur++;			/* Allow initial minus sign in a number */

    while (*cur) {
	if (*cur < '0' || *cur > '9')
	    return NO;
	cur++;
    }
    return YES;
}
#endif /* !NOUSERS */

#if defined (NOUSERS)
/* PUBLIC							HTAA_getUidName()
 *		GET THE USER ID NAME (VMS ONLY)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the user name
 *		Default is "" (nobody).
 */
const char *HTAA_getUidName(void)
{
    if (current_prot && current_prot->uid_name
	&& (0 != strcmp(current_prot->uid_name, "nobody")))
	return (current_prot->uid_name);
    else
	return ("");
}

/* PUBLIC							HTAA_getFileName
 *		GET THE FILENAME (VMS ONLY)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the filename
 */
const char *HTAA_getFileName(void)
{
    if (current_prot && current_prot->filename)
	return (current_prot->filename);
    else
	return ("");
}

#else /* not VMS */

/* PUBLIC							HTAA_getUid()
 *		GET THE USER ID TO CHANGE THE PROCESS UID TO
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the uid number to give to setuid() system call.
 *		Default is 65534 (nobody).
 */
int HTAA_getUid(void)
{
    int uid;

    if (current_prot && current_prot->uid_name) {
	if (isNumber(current_prot->uid_name)) {
	    uid = atoi(current_prot->uid_name);
	    if ((*HTAA_UidToName(uid)) != '\0') {
		return uid;
	    }
	} else {		/* User name (not a number) */
	    if ((uid = HTAA_NameToUid(current_prot->uid_name)) != NONESUCH) {
		return uid;
	    }
	}
    }
    /*
     * Ok, then let's get uid for nobody.
     */
    if ((uid = HTAA_NameToUid("nobody")) != NONESUCH) {
	return uid;
    }
    /*
     * Ok, then use default.
     */
    return NOBODY;		/* nobody */
}

/* PUBLIC							HTAA_getGid()
 *		GET THE GROUP ID TO CHANGE THE PROCESS GID TO
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the uid number to give to setgid() system call.
 *		Default is 65534 (nogroup).
 */
int HTAA_getGid(void)
{
    int gid;

    if (current_prot && current_prot->gid_name) {
	if (isNumber(current_prot->gid_name)) {
	    gid = atoi(current_prot->gid_name);
	    if (*HTAA_GidToName(gid) != '\0') {
		return gid;
	    }
	} else {		/* Group name (not number) */
	    if ((gid = HTAA_NameToGid(current_prot->gid_name)) != NONESUCH) {
		return gid;
	    }
	}
    }
    /*
     * Ok, then let's get gid for nogroup.
     */
    if ((gid = HTAA_NameToGid("nogroup")) != NONESUCH) {
	return gid;
    }
    /*
     * Ok, then use default.
     */
    return NOBODY;		/* nogroup */
}
#endif /* not VMS */

/* static							HTAA_setIds()
 *		SET UID AND GID (AS NAMES OR NUMBERS)
 *		TO HTAAProt STRUCTURE
 * ON ENTRY:
 *	prot		destination.
 *	ids		is a string like "james.www" or "1422.69" etc.
 *			giving uid and gid.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAA_setIds(HTAAProt *prot, const char *ids)
{
    if (ids) {
	char *local_copy = NULL;
	char *point;

	StrAllocCopy(local_copy, ids);
	point = strchr(local_copy, '.');
	if (point) {
	    *(point++) = (char) 0;
	    StrAllocCopy(prot->gid_name, point);
	} else {
	    StrAllocCopy(prot->gid_name, "nogroup");
	}
	StrAllocCopy(prot->uid_name, local_copy);
	FREE(local_copy);
    } else {
	StrAllocCopy(prot->uid_name, "nobody");
	StrAllocCopy(prot->gid_name, "nogroup");
    }
}

/* static						HTAA_parseProtFile()
 *		PARSE A PROTECTION SETUP FILE AND
 *		PUT THE RESULT IN A HTAAProt STRUCTURE
 * ON ENTRY:
 *	prot		destination structure.
 *	fp		open protection file.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAA_parseProtFile(HTAAProt *prot, FILE *fp)
{
    if (prot && fp) {
	LexItem lex_item;
	char *fieldname = NULL;

	while (LEX_EOF != (lex_item = lex(fp))) {

	    while (lex_item == LEX_REC_SEP)	/* Ignore empty lines */
		lex_item = lex(fp);

	    if (lex_item == LEX_EOF)	/* End of file */
		break;

	    if (lex_item == LEX_ALPH_STR) {	/* Valid setup record */

		StrAllocCopy(fieldname, HTlex_buffer);

		if (LEX_FIELD_SEP != (lex_item = lex(fp)))
		    unlex(lex_item);	/* If someone wants to use colon */
		/* after field name it's ok, but */
		/* not required. Here we read it. */

		if (0 == strncasecomp(fieldname, "Auth", 4)) {
		    lex_item = lex(fp);
		    while (lex_item == LEX_ALPH_STR) {
			HTAAScheme scheme = HTAAScheme_enum(HTlex_buffer);

			if (scheme != HTAA_UNKNOWN) {
			    if (!prot->valid_schemes)
				prot->valid_schemes = HTList_new();
			    HTList_addObject(prot->valid_schemes, (void *) scheme);
			    CTRACE((tfp, "%s %s `%s'\n",
				    "HTAA_parseProtFile: valid",
				    "authentication scheme:",
				    HTAAScheme_name(scheme)));
			} else {
			    CTRACE((tfp, "%s %s `%s'\n",
				    "HTAA_parseProtFile: unknown",
				    "authentication scheme:",
				    HTlex_buffer));
			}

			if (LEX_ITEM_SEP != (lex_item = lex(fp)))
			    break;
			/*
			 * Here lex_item == LEX_ITEM_SEP; after item separator
			 * it is ok to have one or more newlines (LEX_REC_SEP)
			 * and they are ignored (continuation line).
			 */
			do {
			    lex_item = lex(fp);
			} while (lex_item == LEX_REC_SEP);
		    }		/* while items in list */
		}
		/* if "Authenticate" */
		else if (0 == strncasecomp(fieldname, "mask", 4)) {
		    prot->mask_group = HTAA_parseGroupDef(fp);
		    lex_item = LEX_REC_SEP;	/*groupdef parser read this already */
		    if (TRACE) {
			if (prot->mask_group) {
			    fprintf(tfp,
				    "HTAA_parseProtFile: Mask group:\n");
			    HTAA_printGroupDef(prot->mask_group);
			} else
			    fprintf(tfp,
				    "HTAA_parseProtFile: Mask group syntax error\n");
		    }
		}
		/* if "Mask" */
		else {		/* Just a name-value pair, put it to assoclist */

		    if (LEX_ALPH_STR == (lex_item = lex(fp))) {
			if (!prot->values)
			    prot->values = HTAssocList_new();
			HTAssocList_add(prot->values, fieldname, HTlex_buffer);
			lex_item = lex(fp);	/* Read record separator */
			CTRACE((tfp, "%s `%s' bound to value `%s'\n",
				"HTAA_parseProtFile: Name",
				fieldname, HTlex_buffer));
		    }
		}		/* else name-value pair */

	    }
	    /* if valid field */
	    if (lex_item != LEX_EOF && lex_item != LEX_REC_SEP) {
		CTRACE((tfp, "%s %s %d (that line ignored)\n",
			"HTAA_parseProtFile: Syntax error",
			"in protection setup file at line",
			HTlex_line));
		do {
		    lex_item = lex(fp);
		} while (lex_item != LEX_EOF && lex_item != LEX_REC_SEP);
	    }			/* if syntax error */
	}			/* while not end-of-file */
	FREE(fieldname);
    }				/* if valid parameters */
}

/* static						HTAAProt_new()
 *		ALLOCATE A NEW HTAAProt STRUCTURE AND
 *		INITIALIZE IT FROM PROTECTION SETUP FILE
 * ON ENTRY:
 *	cur_docname	current filename after rule translations.
 *	prot_filename	protection setup file name.
 *			If NULL, not an error.
 *	ids		Uid and gid names or numbers,
 *			examples:
 *				james	( <=> james.nogroup)
 *				.www	( <=> nobody.www)
 *				james.www
 *				james.69
 *				1422.69
 *				1422.www
 *
 *			May be NULL, defaults to nobody.nogroup.
 *			Should be NULL, if prot_file is NULL.
 *
 * ON EXIT:
 *	returns		returns a new and initialized protection
 *			setup structure.
 *			If setup file is already read in (found
 *			in cache), only sets uid_name and gid
 *			fields, and returns that.
 */
static HTAAProt *HTAAProt_new(const char *cur_docname,
			      const char *prot_filename,
			      const char *ids)
{
    HTList *cur = prot_cache;
    HTAAProtCache *cache_item = NULL;
    HTAAProt *prot;
    FILE *fp;

    if (!prot_cache)
	prot_cache = HTList_new();

    while (NULL != (cache_item = (HTAAProtCache *) HTList_nextObject(cur))) {
	if (!strcmp(cache_item->prot_filename, prot_filename))
	    break;
    }
    if (cache_item) {
	prot = cache_item->prot;
	CTRACE((tfp, "%s `%s' already in cache\n",
		"HTAAProt_new: Protection file", prot_filename));
    } else {
	CTRACE((tfp, "HTAAProt_new: Loading protection file `%s'\n",
		prot_filename));

	if ((prot = typecalloc(HTAAProt)) == 0)
	      outofmem(__FILE__, "HTAAProt_new");

	prot->ctemplate = NULL;
	prot->filename = NULL;
	prot->uid_name = NULL;
	prot->gid_name = NULL;
	prot->valid_schemes = HTList_new();
	prot->mask_group = NULL;	/* Masking disabled by defaults */
	prot->values = HTAssocList_new();

	if (prot_filename && NULL != (fp = fopen(prot_filename, TXT_R))) {
	    HTAA_parseProtFile(prot, fp);
	    fclose(fp);
	    if ((cache_item = typecalloc(HTAAProtCache)) == 0)
		outofmem(__FILE__, "HTAAProt_new");
	    cache_item->prot = prot;
	    cache_item->prot_filename = NULL;
	    StrAllocCopy(cache_item->prot_filename, prot_filename);
	    HTList_addObject(prot_cache, (void *) cache_item);
	} else {
	    CTRACE((tfp, "HTAAProt_new: %s `%s'\n",
		    "Unable to open protection setup file",
		    NONNULL(prot_filename)));
	}
    }

    if (cur_docname)
	StrAllocCopy(prot->filename, cur_docname);
    HTAA_setIds(prot, ids);

    return prot;
}

/* PUBLIC					HTAA_setDefaultProtection()
 *		SET THE DEFAULT PROTECTION MODE
 *		(called by rule system when a
 *		"defprot" rule is matched)
 * ON ENTRY:
 *	cur_docname	is the current result of rule translations.
 *	prot_filename	is the protection setup file (second argument
 *			for "defprot" rule, optional)
 *	ids		contains user and group names separated by
 *			a dot, corresponding to the uid
 *			gid under which the server should run,
 *			default is "nobody.nogroup" (third argument
 *			for "defprot" rule, optional; can be given
 *			only if protection setup file is also given).
 *
 * ON EXIT:
 *	returns		nothing.
 *			Sets the module-wide variable default_prot.
 */
void HTAA_setDefaultProtection(const char *cur_docname,
			       const char *prot_filename,
			       const char *ids)
{
    default_prot = NULL;	/* Not free()'d because this is in cache */

    if (prot_filename) {
	default_prot = HTAAProt_new(cur_docname, prot_filename, ids);
    } else {
	CTRACE((tfp, "%s %s\n",
		"HTAA_setDefaultProtection: ERROR: Protection file",
		"not specified (obligatory for DefProt rule)!!\n"));
    }
}

/* PUBLIC					HTAA_setCurrentProtection()
 *		SET THE CURRENT PROTECTION MODE
 *		(called by rule system when a
 *		"protect" rule is matched)
 * ON ENTRY:
 *	cur_docname	is the current result of rule translations.
 *	prot_filename	is the protection setup file (second argument
 *			for "protect" rule, optional)
 *	ids		contains user and group names separated by
 *			a dot, corresponding to the uid
 *			gid under which the server should run,
 *			default is "nobody.nogroup" (third argument
 *			for "protect" rule, optional; can be given
 *			only if protection setup file is also given).
 *
 * ON EXIT:
 *	returns		nothing.
 *			Sets the module-wide variable current_prot.
 */
void HTAA_setCurrentProtection(const char *cur_docname,
			       const char *prot_filename,
			       const char *ids)
{
    current_prot = NULL;	/* Not free()'d because this is in cache */

    if (prot_filename) {
	current_prot = HTAAProt_new(cur_docname, prot_filename, ids);
    } else {
	if (default_prot) {
	    current_prot = default_prot;
	    HTAA_setIds(current_prot, ids);
	    CTRACE((tfp, "%s %s %s\n",
		    "HTAA_setCurrentProtection: Protection file",
		    "not specified for Protect rule",
		    "-- using default protection"));
	} else {
	    CTRACE((tfp, "%s %s %s\n",
		    "HTAA_setCurrentProtection: ERROR: Protection",
		    "file not specified for Protect rule, and",
		    "default protection is not set!!"));
	}
    }
}

/* PUBLIC					HTAA_getCurrentProtection()
 *		GET CURRENT PROTECTION SETUP STRUCTURE
 *		(this is set up by callbacks made from
 *		 the rule system when matching "protect"
 *		 (and "defprot") rules)
 * ON ENTRY:
 *	HTTranslate() must have been called before calling
 *	this function.
 *
 * ON EXIT:
 *	returns	a HTAAProt structure representing the
 *		protection setup of the HTTranslate()'d file.
 *		This must not be free()'d.
 */
HTAAProt *HTAA_getCurrentProtection(void)
{
    return current_prot;
}

/* PUBLIC					HTAA_getDefaultProtection()
 *		GET DEFAULT PROTECTION SETUP STRUCTURE
 *		AND SET IT TO CURRENT PROTECTION
 *		(this is set up by callbacks made from
 *		 the rule system when matching "defprot"
 *		 rules)
 * ON ENTRY:
 *	HTTranslate() must have been called before calling
 *	this function.
 *
 * ON EXIT:
 *	returns	a HTAAProt structure representing the
 *		default protection setup of the HTTranslate()'d
 *		file (if HTAA_getCurrentProtection() returned
 *		NULL, i.e., if there is no "protect" rule
 *		but ACL exists, and we need to know default
 *		protection settings).
 *		This must not be free()'d.
 * IMPORTANT:
 *	As a side-effect this tells the protection system that
 *	the file is in fact protected and sets the current
 *	protection mode to default.
 */
HTAAProt *HTAA_getDefaultProtection(void)
{
    if (!current_prot) {
	current_prot = default_prot;
	default_prot = NULL;
    }
    return current_prot;
}

/* SERVER INTERNAL					HTAA_clearProtections()
 *		CLEAR DOCUMENT PROTECTION MODE
 *		(ALSO DEFAULT PROTECTION)
 *		(called by the rule system)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	nothing.
 *		Frees the memory used by protection information.
 */
void HTAA_clearProtections(void)
{
    current_prot = NULL;	/* These are not freed because  */
    default_prot = NULL;	/* they are actually in cache.  */
}

typedef struct {
    char *name;
    int user;
} USER_DATA;

#ifndef NOUSERS
static HTList *known_grp = NULL;
static HTList *known_pwd = NULL;
static BOOL uidgid_cache_inited = NO;
#endif

#ifdef LY_FIND_LEAKS
static void clear_uidgid_cache(void)
{
#ifndef NOUSERS
    USER_DATA *data;

    if (known_grp) {
	while ((data = HTList_removeLastObject(known_grp)) != NULL) {
	    FREE(data->name);
	    FREE(data);
	}
	FREE(known_grp);
    }
    if (known_pwd) {
	while ((data = HTList_removeLastObject(known_pwd)) != NULL) {
	    FREE(data->name);
	    FREE(data);
	}
	FREE(known_pwd);
    }
#endif
}
#endif /* LY_FIND_LEAKS */

#ifndef NOUSERS
static void save_gid_info(const char *name, int user)
{
    USER_DATA *data = typecalloc(USER_DATA);

    if (!data)
	return;
    if (!known_grp) {
	known_grp = HTList_new();
	if (!uidgid_cache_inited) {
#ifdef LY_FIND_LEAKS
	    atexit(clear_uidgid_cache);
#endif
	    uidgid_cache_inited = YES;
	}
    }
    StrAllocCopy(data->name, name);
    data->user = user;
    HTList_addObject(known_grp, data);
}
#endif /* NOUSERS */

#ifndef NOUSERS
static void save_uid_info(const char *name, int user)
{
    USER_DATA *data = typecalloc(USER_DATA);

    if (!data)
	return;
    if (!known_pwd) {
	known_pwd = HTList_new();
	if (!uidgid_cache_inited) {
#ifdef LY_FIND_LEAKS
	    atexit(clear_uidgid_cache);
#endif
	    uidgid_cache_inited = YES;
	}
    }
    StrAllocCopy(data->name, name);
    data->user = user;
    HTList_addObject(known_pwd, data);
}
#endif /* !NOUSERS */

/* PUBLIC							HTAA_UidToName
 *		GET THE USER NAME
 * ON ENTRY:
 *      The user-id
 *
 * ON EXIT:
 *      returns the user name, or an empty string if not found.
 */
const char *HTAA_UidToName(int uid)
{
#ifndef NOUSERS
    struct passwd *pw;
    HTList *me = known_pwd;

    while (HTList_nextObject(me)) {
	USER_DATA *data = (USER_DATA *) (me->object);

	if (uid == data->user)
	    return data->name;
    }

    if ((pw = getpwuid(uid)) != 0
	&& pw->pw_name != 0) {
	CTRACE((tfp, "%s(%d) returned (%s:%d:...)\n",
		"HTAA_UidToName: getpwuid",
		uid,
		pw->pw_name, (int) pw->pw_uid));
	save_uid_info(pw->pw_name, (int) pw->pw_uid);
	return pw->pw_name;
    }
#endif
    return "";
}

/* PUBLIC							HTAA_NameToUid
 *		GET THE USER ID
 * ON ENTRY:
 *      The user-name
 *
 * ON EXIT:
 *      returns the user id, or NONESUCH if not found.
 */
int HTAA_NameToUid(const char *name)
{
#ifndef NOUSERS
    struct passwd *pw;
    HTList *me = known_pwd;

    while (HTList_nextObject(me)) {
	USER_DATA *data = (USER_DATA *) (me->object);

	if (!strcmp(name, data->name))
	    return data->user;
    }

    if ((pw = getpwnam(name)) != 0) {
	CTRACE((tfp, "%s(%s) returned (%s:%d:...)\n",
		"HTAA_NameToUid: getpwnam",
		name,
		pw->pw_name, (int) pw->pw_uid));
	save_uid_info(pw->pw_name, (int) pw->pw_uid);
	return (int) pw->pw_uid;
    }
#endif
    return NONESUCH;
}

/* PUBLIC							HTAA_GidToName
 *		GET THE GROUP NAME
 * ON ENTRY:
 *      The group-id
 *
 * ON EXIT:
 *      returns the group name, or an empty string if not found.
 */
const char *HTAA_GidToName(int gid)
{
#ifndef NOUSERS
    struct group *gr;
    HTList *me = known_grp;

    while (HTList_nextObject(me)) {
	USER_DATA *data = (USER_DATA *) (me->object);

	if (gid == data->user)
	    return data->name;
    }

    if ((gr = getgrgid(gid)) != 0
	&& gr->gr_name != 0) {
	CTRACE((tfp, "%s(%d) returned (%s:%d:...)\n",
		"HTAA_GidToName: getgrgid",
		gid,
		gr->gr_name, (int) gr->gr_gid));
	save_gid_info(gr->gr_name, (int) gr->gr_gid);
	return gr->gr_name;
    }
#endif
    return "";
}

/* PUBLIC							HTAA_NameToGid
 *		GET THE GROUP ID
 * ON ENTRY:
 *      The group-name
 *
 * ON EXIT:
 *      returns the group id, or NONESUCH if not found.
 */
int HTAA_NameToGid(const char *name)
{
#ifndef NOUSERS
    struct group *gr;
    HTList *me = known_grp;

    while (HTList_nextObject(me)) {
	USER_DATA *data = (USER_DATA *) (me->object);

	if (!strcmp(name, data->name))
	    return data->user;
    }

    if ((gr = getgrnam(name)) != 0) {
	CTRACE((tfp, "%s(%s) returned (%s:%d:...)\n",
		"HTAA_NameToGid: getgrnam",
		name,
		gr->gr_name, (int) gr->gr_gid));
	save_gid_info(gr->gr_name, (int) gr->gr_gid);
	return (int) gr->gr_gid;
    }
#endif
    return NONESUCH;
}
@


1.5
log
@automatic merge of lynx-current
@
text
@d88 1
a88 1
char *HTAA_getUidName(void)
d105 1
a105 1
char *HTAA_getFileName(void)
d385 1
a385 1
	prot->template = NULL;
d598 1
a598 1
static void save_gid_info(char *name, int user)
d620 1
a620 1
static void save_uid_info(char *name, int user)
d649 1
a649 1
char *HTAA_UidToName(int uid)
d683 1
a683 1
int HTAA_NameToUid(char *name)
d716 1
a716 1
char *HTAA_GidToName(int gid)
d750 1
a750 1
int HTAA_NameToGid(char *name)
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d3 16
a18 16
**		PROTECTION FILE PARSING MODULE
**
** AUTHORS:
**	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
**	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
**
** HISTORY:
**	20 Oct 93  AL	Now finds uid/gid for nobody/nogroup by name
**			(doesn't use default 65534 right away).
**			Also understands negative uids/gids.
**	14 Nov 93  MD	Added VMS compatibility
**
** BUGS:
**
**
*/
d24 2
a25 2
#include <pwd.h>	/* Unix password file routine: getpwnam()	*/
#include <grp.h>	/* Unix group file routine: getgrnam()		*/
d30 2
a31 2
#include <HTLex.h>	/* Lexical analysor	*/
#include <HTAAProt.h>	/* Implemented here	*/
d36 2
a37 2
#define NOBODY    65534	/* -2 in 16-bit environment */
#define NONESUCH  65533	/* -3 in 16-bit environment */
d40 2
a41 2
** Protection setup caching
*/
d43 2
a44 2
    char *	prot_filename;
    HTAAProt *	prot;
d47 4
a50 3
static HTList *  prot_cache	= NULL;	/* Protection setup cache.	*/
static HTAAProt *default_prot	= NULL;	/* Default protection.		*/
static HTAAProt *current_prot	= NULL;	/* Current protection mode	*/
d52 1
a52 1
					/* from the rule system when	*/
d57 3
a59 3
**		DOES A CHARACTER STRING REPRESENT A NUMBER
*/
static BOOL isNumber (const char * s)
d63 2
a64 1
    if (isEmpty(s)) return NO;
d67 1
a67 1
	cur++;		/* Allow initial minus sign in a number */
a77 1

d80 9
a88 9
**		GET THE USER ID NAME (VMS ONLY)
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	the user name
**		Default is "" (nobody).
*/
char * HTAA_getUidName (void)
d91 2
a92 2
		  && (0 != strcmp(current_prot->uid_name,"nobody")) )
       return(current_prot->uid_name);
d94 1
a94 1
       return("");
d98 8
a105 8
**		GET THE FILENAME (VMS ONLY)
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	the filename
*/
char * HTAA_getFileName (void)
d108 1
a108 1
       return(current_prot->filename);
d110 1
a110 1
       return("");
d116 9
a124 9
**		GET THE USER ID TO CHANGE THE PROCESS UID TO
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	the uid number to give to setuid() system call.
**		Default is 65534 (nobody).
*/
int HTAA_getUid (void)
d128 1
a128 1
    if (current_prot  &&  current_prot->uid_name) {
d131 1
a131 1
	    if ((*HTAA_UidToName (uid)) != '\0') {
d134 2
a135 3
	}
	else {	/* User name (not a number) */
	    if ((uid = HTAA_NameToUid (current_prot->uid_name)) != NONESUCH) {
d141 3
a143 3
    ** Ok, then let's get uid for nobody.
    */
    if ((uid = HTAA_NameToUid ("nobody")) != NONESUCH) {
d147 3
a149 3
    ** Ok, then use default.
    */
    return NOBODY;	/* nobody */
a151 1

d153 9
a161 9
**		GET THE GROUP ID TO CHANGE THE PROCESS GID TO
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	the uid number to give to setgid() system call.
**		Default is 65534 (nogroup).
*/
int HTAA_getGid (void)
d165 1
a165 1
    if (current_prot  &&  current_prot->gid_name) {
d171 2
a172 3
	}
	else {	/* Group name (not number) */
	    if ((gid = HTAA_NameToGid (current_prot->gid_name)) != NONESUCH) {
d178 3
a180 3
    ** Ok, then let's get gid for nogroup.
    */
    if ((gid = HTAA_NameToGid ("nogroup")) != NONESUCH) {
d184 3
a186 3
    ** Ok, then use default.
    */
    return NOBODY;	/* nogroup */
a189 1

d191 11
a201 12
**		SET UID AND GID (AS NAMES OR NUMBERS)
**		TO HTAAProt STRUCTURE
** ON ENTRY:
**	prot		destination.
**	ids		is a string like "james.www" or "1422.69" etc.
**			giving uid and gid.
**
** ON EXIT:
**	returns		nothing.
*/
static void HTAA_setIds (HTAAProt *	prot,
			       const char *	ids)
d210 1
a210 1
	    *(point++) = (char)0;
d212 1
a212 2
	}
	else {
d217 1
a217 2
    }
    else {
a222 1

d224 10
a233 11
**		PARSE A PROTECTION SETUP FILE AND
**		PUT THE RESULT IN A HTAAProt STRUCTURE
** ON ENTRY:
**	prot		destination structure.
**	fp		open protection file.
**
** ON EXIT:
**	returns		nothing.
*/
static void HTAA_parseProtFile (HTAAProt * prot,
				      FILE *	  fp)
d244 1
a244 1
	    if (lex_item == LEX_EOF)		/* End of file */
d253 2
a254 2
					/* after field name it's ok, but */
					/* not required. Here we read it.*/
d256 1
a256 1
		if (0==strncasecomp(fieldname, "Auth", 4)) {
d260 1
d264 1
a264 1
			    HTList_addObject(prot->valid_schemes,(void*)scheme);
d266 3
a268 3
					"HTAA_parseProtFile: valid",
					"authentication scheme:",
					HTAAScheme_name(scheme)));
d271 3
a273 3
					"HTAA_parseProtFile: unknown",
					"authentication scheme:",
					HTlex_buffer));
d279 4
a282 4
			** Here lex_item == LEX_ITEM_SEP; after item separator
			** it is ok to have one or more newlines (LEX_REC_SEP)
			** and they are ignored (continuation line).
			*/
d286 4
a289 4
		    } /* while items in list */
		} /* if "Authenticate" */

		else if (0==strncasecomp(fieldname, "mask", 4)) {
d291 1
a291 1
		    lex_item=LEX_REC_SEP; /*groupdef parser read this already*/
d297 3
a299 1
			} else fprintf(tfp, "HTAA_parseProtFile: Mask group syntax error\n");
d301 3
a303 3
		} /* if "Mask" */

		else {	/* Just a name-value pair, put it to assoclist */
d309 1
a309 1
			lex_item = lex(fp);  /* Read record separator */
d311 2
a312 2
				    "HTAA_parseProtFile: Name",
				    fieldname, HTlex_buffer));
d314 1
a314 1
		} /* else name-value pair */
d316 3
a318 3
	    } /* if valid field */

	    if (lex_item != LEX_EOF  &&  lex_item != LEX_REC_SEP) {
d320 3
a322 3
			    "HTAA_parseProtFile: Syntax error",
			    "in protection setup file at line",
			    HTlex_line));
d326 2
a327 2
	    } /* if syntax error */
	} /* while not end-of-file */
d329 1
a329 1
    } /* if valid parameters */
a331 1

d333 28
a360 28
**		ALLOCATE A NEW HTAAProt STRUCTURE AND
**		INITIALIZE IT FROM PROTECTION SETUP FILE
** ON ENTRY:
**	cur_docname	current filename after rule translations.
**	prot_filename	protection setup file name.
**			If NULL, not an error.
**	ids		Uid and gid names or numbers,
**			examples:
**				james	( <=> james.nogroup)
**				.www	( <=> nobody.www)
**				james.www
**				james.69
**				1422.69
**				1422.www
**
**			May be NULL, defaults to nobody.nogroup.
**			Should be NULL, if prot_file is NULL.
**
** ON EXIT:
**	returns		returns a new and initialized protection
**			setup structure.
**			If setup file is already read in (found
**			in cache), only sets uid_name and gid
**			fields, and returns that.
*/
static HTAAProt *HTAAProt_new (const char *	cur_docname,
				     const char *	prot_filename,
				     const char *	ids)
d370 1
a370 1
    while (NULL != (cache_item = (HTAAProtCache*)HTList_nextObject(cur))) {
d377 1
a377 1
		    "HTAAProt_new: Protection file", prot_filename));
d380 1
a380 1
		    prot_filename));
d383 1
a383 1
	    outofmem(__FILE__, "HTAAProt_new");
d385 4
a388 4
	prot->template	= NULL;
	prot->filename	= NULL;
	prot->uid_name	= NULL;
	prot->gid_name	= NULL;
d390 2
a391 2
	prot->mask_group= NULL;		/* Masking disabled by defaults */
	prot->values	= HTAssocList_new();
d401 1
a401 1
	    HTList_addObject(prot_cache, (void*)cache_item);
d404 2
a405 2
			"Unable to open protection setup file",
			NONNULL(prot_filename)));
a415 1

d417 21
a437 21
**		SET THE DEFAULT PROTECTION MODE
**		(called by rule system when a
**		"defprot" rule is matched)
** ON ENTRY:
**	cur_docname	is the current result of rule translations.
**	prot_filename	is the protection setup file (second argument
**			for "defprot" rule, optional)
**	ids		contains user and group names separated by
**			a dot, corresponding to the uid
**			gid under which the server should run,
**			default is "nobody.nogroup" (third argument
**			for "defprot" rule, optional; can be given
**			only if protection setup file is also given).
**
** ON EXIT:
**	returns		nothing.
**			Sets the module-wide variable default_prot.
*/
void HTAA_setDefaultProtection (const char *	cur_docname,
					    const char *	prot_filename,
					    const char *	ids)
d445 2
a446 2
		    "HTAA_setDefaultProtection: ERROR: Protection file",
		    "not specified (obligatory for DefProt rule)!!\n"));
a449 1

d451 21
a471 21
**		SET THE CURRENT PROTECTION MODE
**		(called by rule system when a
**		"protect" rule is matched)
** ON ENTRY:
**	cur_docname	is the current result of rule translations.
**	prot_filename	is the protection setup file (second argument
**			for "protect" rule, optional)
**	ids		contains user and group names separated by
**			a dot, corresponding to the uid
**			gid under which the server should run,
**			default is "nobody.nogroup" (third argument
**			for "protect" rule, optional; can be given
**			only if protection setup file is also given).
**
** ON EXIT:
**	returns		nothing.
**			Sets the module-wide variable current_prot.
*/
void HTAA_setCurrentProtection (const char *	cur_docname,
					    const char *	prot_filename,
					    const char *	ids)
d482 3
a484 3
			"HTAA_setCurrentProtection: Protection file",
			"not specified for Protect rule",
			"-- using default protection"));
d487 3
a489 3
			"HTAA_setCurrentProtection: ERROR: Protection",
			"file not specified for Protect rule, and",
			"default protection is not set!!"));
a493 1

d495 14
a508 14
**		GET CURRENT PROTECTION SETUP STRUCTURE
**		(this is set up by callbacks made from
**		 the rule system when matching "protect"
**		 (and "defprot") rules)
** ON ENTRY:
**	HTTranslate() must have been called before calling
**	this function.
**
** ON EXIT:
**	returns	a HTAAProt structure representing the
**		protection setup of the HTTranslate()'d file.
**		This must not be free()'d.
*/
HTAAProt *HTAA_getCurrentProtection (void)
a512 1

d514 23
a536 23
**		GET DEFAULT PROTECTION SETUP STRUCTURE
**		AND SET IT TO CURRENT PROTECTION
**		(this is set up by callbacks made from
**		 the rule system when matching "defprot"
**		 rules)
** ON ENTRY:
**	HTTranslate() must have been called before calling
**	this function.
**
** ON EXIT:
**	returns	a HTAAProt structure representing the
**		default protection setup of the HTTranslate()'d
**		file (if HTAA_getCurrentProtection() returned
**		NULL, i.e., if there is no "protect" rule
**		but ACL exists, and we need to know default
**		protection settings).
**		This must not be free()'d.
** IMPORTANT:
**	As a side-effect this tells the protection system that
**	the file is in fact protected and sets the current
**	protection mode to default.
*/
HTAAProt *HTAA_getDefaultProtection (void)
a544 1

d546 11
a556 11
**		CLEAR DOCUMENT PROTECTION MODE
**		(ALSO DEFAULT PROTECTION)
**		(called by the rule system)
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	nothing.
**		Frees the memory used by protection information.
*/
void HTAA_clearProtections (void)
d558 2
a559 2
    current_prot = NULL;	/* These are not freed because	*/
    default_prot = NULL;	/* they are actually in cache.	*/
d563 3
a565 3
	char *name;
	int user;
	} USER_DATA;
d574 1
a574 1
static void clear_uidgid_cache (void)
d578 1
d598 1
a598 1
static void save_gid_info (char * name, int user)
d601 1
d615 1
a615 1
    HTList_addObject (known_grp, data);
d620 1
a620 1
static void save_uid_info (char * name, int user)
d623 1
d637 1
a637 1
    HTList_addObject (known_pwd, data);
d642 8
a649 8
**		GET THE USER NAME
** ON ENTRY:
**      The user-id
**
** ON EXIT:
**      returns the user name, or an empty string if not found.
*/
char * HTAA_UidToName (int uid)
d656 2
a657 1
	USER_DATA *data = (USER_DATA *)(me->object);
d663 1
a663 1
     && pw->pw_name != 0) {
d665 3
a667 3
		    "HTAA_UidToName: getpwuid",
		    uid,
		    pw->pw_name, (int) pw->pw_uid));
d676 8
a683 8
**		GET THE USER ID
** ON ENTRY:
**      The user-name
**
** ON EXIT:
**      returns the user id, or NONESUCH if not found.
*/
int HTAA_NameToUid (char * name)
d690 2
a691 1
	USER_DATA *data = (USER_DATA *)(me->object);
d698 3
a700 3
		    "HTAA_NameToUid: getpwnam",
		    name,
		    pw->pw_name, (int) pw->pw_uid));
d709 8
a716 8
**		GET THE GROUP NAME
** ON ENTRY:
**      The group-id
**
** ON EXIT:
**      returns the group name, or an empty string if not found.
*/
char * HTAA_GidToName (int gid)
d723 2
a724 1
	USER_DATA *data = (USER_DATA *)(me->object);
d730 1
a730 1
     && gr->gr_name != 0) {
d732 3
a734 3
		    "HTAA_GidToName: getgrgid",
		    gid,
		    gr->gr_name, (int) gr->gr_gid));
d743 8
a750 8
**		GET THE GROUP ID
** ON ENTRY:
**      The group-name
**
** ON EXIT:
**      returns the group id, or NONESUCH if not found.
*/
int HTAA_NameToGid (char * name)
d757 2
a758 1
	USER_DATA *data = (USER_DATA *)(me->object);
d765 3
a767 3
		    "HTAA_NameToGid: getgrnam",
		    name,
		    gr->gr_name, (int) gr->gr_gid));
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d47 3
a49 3
PRIVATE HTList *  prot_cache	= NULL;	/* Protection setup cache.	*/
PRIVATE HTAAProt *default_prot	= NULL;	/* Default protection.		*/
PRIVATE HTAAProt *current_prot	= NULL;	/* Current protection mode	*/
d55 1
a55 1
/* PRIVATE							isNumber()
d58 1
a58 1
PRIVATE BOOL isNumber ARGS1(CONST char *, s)
d60 1
a60 1
    CONST char *cur = s;
d87 1
a87 1
PUBLIC char * HTAA_getUidName NOARGS
d104 1
a104 1
PUBLIC char * HTAA_getFileName NOARGS
d123 1
a123 1
PUBLIC int HTAA_getUid NOARGS
d162 1
a162 1
PUBLIC int HTAA_getGid NOARGS
d193 1
a193 1
/* PRIVATE							HTAA_setIds()
d204 2
a205 2
PRIVATE void HTAA_setIds ARGS2(HTAAProt *,	prot,
			       CONST char *,	ids)
d230 1
a230 1
/* PRIVATE						HTAA_parseProtFile()
d240 2
a241 2
PRIVATE void HTAA_parseProtFile ARGS2(HTAAProt *, prot,
				      FILE *,	  fp)
d338 1
a338 1
/* PRIVATE						HTAAProt_new()
d364 3
a366 3
PRIVATE HTAAProt *HTAAProt_new ARGS3(CONST char *,	cur_docname,
				     CONST char *,	prot_filename,
				     CONST char *,	ids)
d442 3
a444 3
PUBLIC void HTAA_setDefaultProtection ARGS3(CONST char *,	cur_docname,
					    CONST char *,	prot_filename,
					    CONST char *,	ids)
d477 3
a479 3
PUBLIC void HTAA_setCurrentProtection ARGS3(CONST char *,	cur_docname,
					    CONST char *,	prot_filename,
					    CONST char *,	ids)
d517 1
a517 1
PUBLIC HTAAProt *HTAA_getCurrentProtection NOARGS
d546 1
a546 1
PUBLIC HTAAProt *HTAA_getDefaultProtection NOARGS
d567 1
a567 1
PUBLIC void HTAA_clearProtections NOARGS
d579 3
a581 3
PRIVATE HTList *known_grp = NULL;
PRIVATE HTList *known_pwd = NULL;
PRIVATE BOOL uidgid_cache_inited = NO;
d585 1
a585 1
PRIVATE void clear_uidgid_cache NOARGS
d608 1
a608 1
PRIVATE void save_gid_info ARGS2(char *, name, int, user)
d629 1
a629 1
PRIVATE void save_uid_info ARGS2(char *, name, int, user)
d657 1
a657 1
PUBLIC char * HTAA_UidToName ARGS1(int, uid)
d690 1
a690 1
PUBLIC int HTAA_NameToUid ARGS1(char *, name)
d722 1
a722 1
PUBLIC char * HTAA_GidToName ARGS1(int, gid)
d755 1
a755 1
PUBLIC int HTAA_NameToGid ARGS1(char *, name)
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d33 1
d50 3
a52 4
                                        /* which is set up by callbacks	*/
                                        /* from the rule system when	*/
                                        /* a "protect" rule is matched.	*/

d54 1
d62 1
a62 1
    if (!s || !*s) return NO;
d74 1
d90 1
a90 1
                  && (0 != strcmp(current_prot->uid_name,"nobody")) )
d261 2
a262 2
		                        /* after field name it's ok, but */
		                        /* not required. Here we read it.*/
d272 4
a275 4
			    CTRACE(tfp, "%s %s `%s'\n",
				        "HTAA_parseProtFile: valid",
				        "authentication scheme:",
				        HTAAScheme_name(scheme));
d277 1
a277 1
			    CTRACE(tfp, "%s %s `%s'\n",
d280 1
a280 1
					HTlex_buffer);
d315 1
a315 1
			CTRACE(tfp, "%s `%s' bound to value `%s'\n",
d317 1
a317 1
				    fieldname, HTlex_buffer);
d324 1
a324 1
		CTRACE(tfp, "%s %s %d (that line ignored)\n",
d327 1
a327 1
			    HTlex_line);
d382 2
a383 2
	CTRACE(tfp, "%s `%s' already in cache\n",
		    "HTAAProt_new: Protection file", prot_filename);
d385 2
a386 2
	CTRACE(tfp, "HTAAProt_new: Loading protection file `%s'\n",
		    prot_filename);
d388 1
a388 1
	if (!(prot = (HTAAProt*)calloc(1, sizeof(HTAAProt))))
d399 1
a399 1
	if (prot_filename && NULL != (fp = fopen(prot_filename, "r"))) {
d402 1
a402 2
	    if (!(cache_item =
	    		(HTAAProtCache*)calloc(1, sizeof(HTAAProtCache))))
d409 1
a409 1
	    CTRACE(tfp, "HTAAProt_new: %s `%s'\n",
d411 1
a411 1
			(prot_filename ? prot_filename : "(null)"));
d451 1
a451 1
	CTRACE(tfp, "%s %s\n",
d453 1
a453 1
		    "not specified (obligatory for DefProt rule)!!\n");
d489 4
a492 4
	    CTRACE(tfp, "%s %s %s\n",
		        "HTAA_setCurrentProtection: Protection file",
		        "not specified for Protect rule",
		        "-- using default protection");
d494 4
a497 4
	    CTRACE(tfp, "%s %s %s\n",
		        "HTAA_setCurrentProtection: ERROR: Protection",
		        "file not specified for Protect rule, and",
		        "default protection is not set!!");
d574 1
a574 1
    	char *name;
d576 1
a576 1
    	} USER_DATA;
d578 1
d582 1
d587 1
d603 1
d607 1
d610 1
a610 1
    USER_DATA *data = (USER_DATA *)calloc(1, sizeof(USER_DATA));
d626 1
d628 1
d631 1
a631 1
    USER_DATA *data = (USER_DATA *)calloc(1, sizeof(USER_DATA));
d647 1
d649 2
a650 2
/* PUBLIC                                                       HTAA_UidToName
**              GET THE USER NAME
d671 1
a671 1
	CTRACE(tfp, "%s(%d) returned (%s:%d:...)\n",
d674 1
a674 1
		    pw->pw_name, (int) pw->pw_uid);
d682 2
a683 2
/* PUBLIC                                                       HTAA_NameToUid
**              GET THE USER ID
d703 1
a703 1
	CTRACE(tfp, "%s(%s) returned (%s:%d:...)\n",
d706 1
a706 1
		    pw->pw_name, (int) pw->pw_uid);
d714 2
a715 2
/* PUBLIC                                                       HTAA_GidToName
**              GET THE GROUP NAME
d736 1
a736 1
	CTRACE(tfp, "%s(%d) returned (%s:%d:...)\n",
d739 1
a739 1
		    gr->gr_name, (int) gr->gr_gid);
d747 2
a748 2
/* PUBLIC                                                       HTAA_NameToGid
**              GET THE GROUP ID
d768 1
a768 1
	CTRACE(tfp, "%s(%s) returned (%s:%d:...)\n",
d771 1
a771 1
		    gr->gr_name, (int) gr->gr_gid);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d3 16
a18 16
 *		PROTECTION FILE PARSING MODULE
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	20 Oct 93  AL	Now finds uid/gid for nobody/nogroup by name
 *			(doesn't use default 65534 right away).
 *			Also understands negative uids/gids.
 *	14 Nov 93  MD	Added VMS compatibility
 *
 * BUGS:
 *
 *
 */
d24 2
a25 2
#include <pwd.h>		/* Unix password file routine: getpwnam()       */
#include <grp.h>		/* Unix group file routine: getgrnam()          */
d30 2
a31 2
#include <HTLex.h>		/* Lexical analysor     */
#include <HTAAProt.h>		/* Implemented here     */
a32 1
#include <LYUtils.h>
d35 2
a36 2
#define NOBODY    65534		/* -2 in 16-bit environment */
#define NONESUCH  65533		/* -3 in 16-bit environment */
d39 2
a40 2
 * Protection setup caching
 */
d42 2
a43 2
    char *prot_filename;
    HTAAProt *prot;
d46 12
a57 13
static HTList *prot_cache = NULL;	/* Protection setup cache.      */
static HTAAProt *default_prot = NULL;	/* Default protection.          */
static HTAAProt *current_prot = NULL;	/* Current protection mode      */

					/* which is set up by callbacks */
					/* from the rule system when    */
					/* a "protect" rule is matched. */

#ifndef NOUSERS
/* static							isNumber()
 *		DOES A CHARACTER STRING REPRESENT A NUMBER
 */
static BOOL isNumber(const char *s)
d59 1
a59 1
    const char *cur = s;
d61 1
a61 2
    if (isEmpty(s))
	return NO;
d64 1
a64 1
	cur++;			/* Allow initial minus sign in a number */
d73 1
a73 1
#endif /* !NOUSERS */
d77 9
a85 9
 *		GET THE USER ID NAME (VMS ONLY)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the user name
 *		Default is "" (nobody).
 */
const char *HTAA_getUidName(void)
d88 2
a89 2
	&& (0 != strcmp(current_prot->uid_name, "nobody")))
	return (current_prot->uid_name);
d91 1
a91 1
	return ("");
d95 8
a102 8
 *		GET THE FILENAME (VMS ONLY)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the filename
 */
const char *HTAA_getFileName(void)
d105 1
a105 1
	return (current_prot->filename);
d107 1
a107 1
	return ("");
d113 9
a121 9
 *		GET THE USER ID TO CHANGE THE PROCESS UID TO
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the uid number to give to setuid() system call.
 *		Default is 65534 (nobody).
 */
int HTAA_getUid(void)
d125 1
a125 1
    if (current_prot && current_prot->uid_name) {
d128 1
a128 1
	    if ((*HTAA_UidToName(uid)) != '\0') {
d131 3
a133 2
	} else {		/* User name (not a number) */
	    if ((uid = HTAA_NameToUid(current_prot->uid_name)) != NONESUCH) {
d139 3
a141 3
     * Ok, then let's get uid for nobody.
     */
    if ((uid = HTAA_NameToUid("nobody")) != NONESUCH) {
d145 3
a147 3
     * Ok, then use default.
     */
    return NOBODY;		/* nobody */
d150 1
d152 9
a160 9
 *		GET THE GROUP ID TO CHANGE THE PROCESS GID TO
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the uid number to give to setgid() system call.
 *		Default is 65534 (nogroup).
 */
int HTAA_getGid(void)
d164 1
a164 1
    if (current_prot && current_prot->gid_name) {
d170 3
a172 2
	} else {		/* Group name (not number) */
	    if ((gid = HTAA_NameToGid(current_prot->gid_name)) != NONESUCH) {
d178 3
a180 3
     * Ok, then let's get gid for nogroup.
     */
    if ((gid = HTAA_NameToGid("nogroup")) != NONESUCH) {
d184 3
a186 3
     * Ok, then use default.
     */
    return NOBODY;		/* nogroup */
d190 14
a203 12
/* static							HTAA_setIds()
 *		SET UID AND GID (AS NAMES OR NUMBERS)
 *		TO HTAAProt STRUCTURE
 * ON ENTRY:
 *	prot		destination.
 *	ids		is a string like "james.www" or "1422.69" etc.
 *			giving uid and gid.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAA_setIds(HTAAProt *prot, const char *ids)
d212 1
a212 1
	    *(point++) = (char) 0;
d214 2
a215 1
	} else {
d220 2
a221 1
    } else {
d227 13
a239 11
/* static						HTAA_parseProtFile()
 *		PARSE A PROTECTION SETUP FILE AND
 *		PUT THE RESULT IN A HTAAProt STRUCTURE
 * ON ENTRY:
 *	prot		destination structure.
 *	fp		open protection file.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAA_parseProtFile(HTAAProt *prot, FILE *fp)
d250 1
a250 1
	    if (lex_item == LEX_EOF)	/* End of file */
d259 2
a260 2
		/* after field name it's ok, but */
		/* not required. Here we read it. */
d262 1
a262 1
		if (0 == strncasecomp(fieldname, "Auth", 4)) {
a265 1

d269 5
a273 5
			    HTList_addObject(prot->valid_schemes, (void *) scheme);
			    CTRACE((tfp, "%s %s `%s'\n",
				    "HTAA_parseProtFile: valid",
				    "authentication scheme:",
				    HTAAScheme_name(scheme)));
d275 4
a278 4
			    CTRACE((tfp, "%s %s `%s'\n",
				    "HTAA_parseProtFile: unknown",
				    "authentication scheme:",
				    HTlex_buffer));
d284 4
a287 4
			 * Here lex_item == LEX_ITEM_SEP; after item separator
			 * it is ok to have one or more newlines (LEX_REC_SEP)
			 * and they are ignored (continuation line).
			 */
d291 4
a294 4
		    }		/* while items in list */
		}
		/* if "Authenticate" */
		else if (0 == strncasecomp(fieldname, "mask", 4)) {
d296 1
a296 1
		    lex_item = LEX_REC_SEP;	/*groupdef parser read this already */
d302 1
a302 3
			} else
			    fprintf(tfp,
				    "HTAA_parseProtFile: Mask group syntax error\n");
d304 3
a306 3
		}
		/* if "Mask" */
		else {		/* Just a name-value pair, put it to assoclist */
d312 4
a315 4
			lex_item = lex(fp);	/* Read record separator */
			CTRACE((tfp, "%s `%s' bound to value `%s'\n",
				"HTAA_parseProtFile: Name",
				fieldname, HTlex_buffer));
d317 3
a319 1
		}		/* else name-value pair */
d321 5
a325 7
	    }
	    /* if valid field */
	    if (lex_item != LEX_EOF && lex_item != LEX_REC_SEP) {
		CTRACE((tfp, "%s %s %d (that line ignored)\n",
			"HTAA_parseProtFile: Syntax error",
			"in protection setup file at line",
			HTlex_line));
d329 2
a330 2
	    }			/* if syntax error */
	}			/* while not end-of-file */
d332 1
a332 1
    }				/* if valid parameters */
d335 30
a364 29
/* static						HTAAProt_new()
 *		ALLOCATE A NEW HTAAProt STRUCTURE AND
 *		INITIALIZE IT FROM PROTECTION SETUP FILE
 * ON ENTRY:
 *	cur_docname	current filename after rule translations.
 *	prot_filename	protection setup file name.
 *			If NULL, not an error.
 *	ids		Uid and gid names or numbers,
 *			examples:
 *				james	( <=> james.nogroup)
 *				.www	( <=> nobody.www)
 *				james.www
 *				james.69
 *				1422.69
 *				1422.www
 *
 *			May be NULL, defaults to nobody.nogroup.
 *			Should be NULL, if prot_file is NULL.
 *
 * ON EXIT:
 *	returns		returns a new and initialized protection
 *			setup structure.
 *			If setup file is already read in (found
 *			in cache), only sets uid_name and gid
 *			fields, and returns that.
 */
static HTAAProt *HTAAProt_new(const char *cur_docname,
			      const char *prot_filename,
			      const char *ids)
d374 1
a374 1
    while (NULL != (cache_item = (HTAAProtCache *) HTList_nextObject(cur))) {
d380 2
a381 2
	CTRACE((tfp, "%s `%s' already in cache\n",
		"HTAAProt_new: Protection file", prot_filename));
d383 2
a384 2
	CTRACE((tfp, "HTAAProt_new: Loading protection file `%s'\n",
		prot_filename));
d386 2
a387 2
	if ((prot = typecalloc(HTAAProt)) == 0)
	      outofmem(__FILE__, "HTAAProt_new");
d389 4
a392 4
	prot->ctemplate = NULL;
	prot->filename = NULL;
	prot->uid_name = NULL;
	prot->gid_name = NULL;
d394 2
a395 2
	prot->mask_group = NULL;	/* Masking disabled by defaults */
	prot->values = HTAssocList_new();
d397 1
a397 1
	if (prot_filename && NULL != (fp = fopen(prot_filename, TXT_R))) {
d400 2
a401 1
	    if ((cache_item = typecalloc(HTAAProtCache)) == 0)
d406 1
a406 1
	    HTList_addObject(prot_cache, (void *) cache_item);
d408 3
a410 3
	    CTRACE((tfp, "HTAAProt_new: %s `%s'\n",
		    "Unable to open protection setup file",
		    NONNULL(prot_filename)));
d421 1
d423 21
a443 21
 *		SET THE DEFAULT PROTECTION MODE
 *		(called by rule system when a
 *		"defprot" rule is matched)
 * ON ENTRY:
 *	cur_docname	is the current result of rule translations.
 *	prot_filename	is the protection setup file (second argument
 *			for "defprot" rule, optional)
 *	ids		contains user and group names separated by
 *			a dot, corresponding to the uid
 *			gid under which the server should run,
 *			default is "nobody.nogroup" (third argument
 *			for "defprot" rule, optional; can be given
 *			only if protection setup file is also given).
 *
 * ON EXIT:
 *	returns		nothing.
 *			Sets the module-wide variable default_prot.
 */
void HTAA_setDefaultProtection(const char *cur_docname,
			       const char *prot_filename,
			       const char *ids)
d450 3
a452 3
	CTRACE((tfp, "%s %s\n",
		"HTAA_setDefaultProtection: ERROR: Protection file",
		"not specified (obligatory for DefProt rule)!!\n"));
d456 1
d458 21
a478 21
 *		SET THE CURRENT PROTECTION MODE
 *		(called by rule system when a
 *		"protect" rule is matched)
 * ON ENTRY:
 *	cur_docname	is the current result of rule translations.
 *	prot_filename	is the protection setup file (second argument
 *			for "protect" rule, optional)
 *	ids		contains user and group names separated by
 *			a dot, corresponding to the uid
 *			gid under which the server should run,
 *			default is "nobody.nogroup" (third argument
 *			for "protect" rule, optional; can be given
 *			only if protection setup file is also given).
 *
 * ON EXIT:
 *	returns		nothing.
 *			Sets the module-wide variable current_prot.
 */
void HTAA_setCurrentProtection(const char *cur_docname,
			       const char *prot_filename,
			       const char *ids)
d488 4
a491 4
	    CTRACE((tfp, "%s %s %s\n",
		    "HTAA_setCurrentProtection: Protection file",
		    "not specified for Protect rule",
		    "-- using default protection"));
d493 4
a496 4
	    CTRACE((tfp, "%s %s %s\n",
		    "HTAA_setCurrentProtection: ERROR: Protection",
		    "file not specified for Protect rule, and",
		    "default protection is not set!!"));
d501 1
d503 14
a516 14
 *		GET CURRENT PROTECTION SETUP STRUCTURE
 *		(this is set up by callbacks made from
 *		 the rule system when matching "protect"
 *		 (and "defprot") rules)
 * ON ENTRY:
 *	HTTranslate() must have been called before calling
 *	this function.
 *
 * ON EXIT:
 *	returns	a HTAAProt structure representing the
 *		protection setup of the HTTranslate()'d file.
 *		This must not be free()'d.
 */
HTAAProt *HTAA_getCurrentProtection(void)
d521 1
d523 23
a545 23
 *		GET DEFAULT PROTECTION SETUP STRUCTURE
 *		AND SET IT TO CURRENT PROTECTION
 *		(this is set up by callbacks made from
 *		 the rule system when matching "defprot"
 *		 rules)
 * ON ENTRY:
 *	HTTranslate() must have been called before calling
 *	this function.
 *
 * ON EXIT:
 *	returns	a HTAAProt structure representing the
 *		default protection setup of the HTTranslate()'d
 *		file (if HTAA_getCurrentProtection() returned
 *		NULL, i.e., if there is no "protect" rule
 *		but ACL exists, and we need to know default
 *		protection settings).
 *		This must not be free()'d.
 * IMPORTANT:
 *	As a side-effect this tells the protection system that
 *	the file is in fact protected and sets the current
 *	protection mode to default.
 */
HTAAProt *HTAA_getDefaultProtection(void)
d554 1
d556 11
a566 11
 *		CLEAR DOCUMENT PROTECTION MODE
 *		(ALSO DEFAULT PROTECTION)
 *		(called by the rule system)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	nothing.
 *		Frees the memory used by protection information.
 */
void HTAA_clearProtections(void)
d568 2
a569 2
    current_prot = NULL;	/* These are not freed because  */
    default_prot = NULL;	/* they are actually in cache.  */
d573 7
a579 9
    char *name;
    int user;
} USER_DATA;

#ifndef NOUSERS
static HTList *known_grp = NULL;
static HTList *known_pwd = NULL;
static BOOL uidgid_cache_inited = NO;
#endif
d582 1
a582 1
static void clear_uidgid_cache(void)
a583 1
#ifndef NOUSERS
a584 1

a598 1
#endif
d602 1
a602 2
#ifndef NOUSERS
static void save_gid_info(const char *name, int user)
d604 1
a604 2
    USER_DATA *data = typecalloc(USER_DATA);

d618 1
a618 1
    HTList_addObject(known_grp, data);
a619 1
#endif /* NOUSERS */
d621 1
a621 2
#ifndef NOUSERS
static void save_uid_info(const char *name, int user)
d623 1
a623 2
    USER_DATA *data = typecalloc(USER_DATA);

d637 1
a637 1
    HTList_addObject(known_pwd, data);
a638 1
#endif /* !NOUSERS */
d640 9
a648 9
/* PUBLIC							HTAA_UidToName
 *		GET THE USER NAME
 * ON ENTRY:
 *      The user-id
 *
 * ON EXIT:
 *      returns the user name, or an empty string if not found.
 */
const char *HTAA_UidToName(int uid)
d655 1
a655 2
	USER_DATA *data = (USER_DATA *) (me->object);

d661 5
a665 5
	&& pw->pw_name != 0) {
	CTRACE((tfp, "%s(%d) returned (%s:%d:...)\n",
		"HTAA_UidToName: getpwuid",
		uid,
		pw->pw_name, (int) pw->pw_uid));
d673 9
a681 9
/* PUBLIC							HTAA_NameToUid
 *		GET THE USER ID
 * ON ENTRY:
 *      The user-name
 *
 * ON EXIT:
 *      returns the user id, or NONESUCH if not found.
 */
int HTAA_NameToUid(const char *name)
d688 1
a688 2
	USER_DATA *data = (USER_DATA *) (me->object);

d694 4
a697 4
	CTRACE((tfp, "%s(%s) returned (%s:%d:...)\n",
		"HTAA_NameToUid: getpwnam",
		name,
		pw->pw_name, (int) pw->pw_uid));
d705 9
a713 9
/* PUBLIC							HTAA_GidToName
 *		GET THE GROUP NAME
 * ON ENTRY:
 *      The group-id
 *
 * ON EXIT:
 *      returns the group name, or an empty string if not found.
 */
const char *HTAA_GidToName(int gid)
d720 1
a720 2
	USER_DATA *data = (USER_DATA *) (me->object);

d726 5
a730 5
	&& gr->gr_name != 0) {
	CTRACE((tfp, "%s(%d) returned (%s:%d:...)\n",
		"HTAA_GidToName: getgrgid",
		gid,
		gr->gr_name, (int) gr->gr_gid));
d738 9
a746 9
/* PUBLIC							HTAA_NameToGid
 *		GET THE GROUP ID
 * ON ENTRY:
 *      The group-name
 *
 * ON EXIT:
 *      returns the group id, or NONESUCH if not found.
 */
int HTAA_NameToGid(const char *name)
d753 1
a753 2
	USER_DATA *data = (USER_DATA *) (me->object);

d759 4
a762 4
	CTRACE((tfp, "%s(%s) returned (%s:%d:...)\n",
		"HTAA_NameToGid: getgrnam",
		name,
		gr->gr_name, (int) gr->gr_gid));
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a32 1
#include <LYUtils.h>
d49 4
a52 3
					/* which is set up by callbacks */
					/* from the rule system when	*/
					/* a "protect" rule is matched. */
a53 1
#ifndef NOUSERS
d61 1
a61 1
    if (isEmpty(s)) return NO;
a72 1
#endif /* !NOUSERS */
d88 1
a88 1
		  && (0 != strcmp(current_prot->uid_name,"nobody")) )
d259 2
a260 2
					/* after field name it's ok, but */
					/* not required. Here we read it.*/
d270 4
a273 4
			    CTRACE((tfp, "%s %s `%s'\n",
					"HTAA_parseProtFile: valid",
					"authentication scheme:",
					HTAAScheme_name(scheme)));
d275 1
a275 1
			    CTRACE((tfp, "%s %s `%s'\n",
d278 1
a278 1
					HTlex_buffer));
d313 1
a313 1
			CTRACE((tfp, "%s `%s' bound to value `%s'\n",
d315 1
a315 1
				    fieldname, HTlex_buffer));
d322 1
a322 1
		CTRACE((tfp, "%s %s %d (that line ignored)\n",
d325 1
a325 1
			    HTlex_line));
d380 2
a381 2
	CTRACE((tfp, "%s `%s' already in cache\n",
		    "HTAAProt_new: Protection file", prot_filename));
d383 2
a384 2
	CTRACE((tfp, "HTAAProt_new: Loading protection file `%s'\n",
		    prot_filename));
d386 1
a386 1
	if ((prot = typecalloc(HTAAProt)) == 0)
d397 1
a397 1
	if (prot_filename && NULL != (fp = fopen(prot_filename, TXT_R))) {
d400 2
a401 1
	    if ((cache_item = typecalloc(HTAAProtCache)) == 0)
d408 1
a408 1
	    CTRACE((tfp, "HTAAProt_new: %s `%s'\n",
d410 1
a410 1
			NONNULL(prot_filename)));
d450 1
a450 1
	CTRACE((tfp, "%s %s\n",
d452 1
a452 1
		    "not specified (obligatory for DefProt rule)!!\n"));
d488 4
a491 4
	    CTRACE((tfp, "%s %s %s\n",
			"HTAA_setCurrentProtection: Protection file",
			"not specified for Protect rule",
			"-- using default protection"));
d493 4
a496 4
	    CTRACE((tfp, "%s %s %s\n",
			"HTAA_setCurrentProtection: ERROR: Protection",
			"file not specified for Protect rule, and",
			"default protection is not set!!"));
d573 1
a573 1
	char *name;
d575 1
a575 1
	} USER_DATA;
a576 1
#ifndef NOUSERS
a579 1
#endif
a583 1
#ifndef NOUSERS
a598 1
#endif
a601 1
#ifndef NOUSERS
d604 1
a604 1
    USER_DATA *data = typecalloc(USER_DATA);
a619 1
#endif /* NOUSERS */
a620 1
#ifndef NOUSERS
d623 1
a623 1
    USER_DATA *data = typecalloc(USER_DATA);
a638 1
#endif /* !NOUSERS */
d640 2
a641 2
/* PUBLIC							HTAA_UidToName
**		GET THE USER NAME
d662 1
a662 1
	CTRACE((tfp, "%s(%d) returned (%s:%d:...)\n",
d665 1
a665 1
		    pw->pw_name, (int) pw->pw_uid));
d673 2
a674 2
/* PUBLIC							HTAA_NameToUid
**		GET THE USER ID
d694 1
a694 1
	CTRACE((tfp, "%s(%s) returned (%s:%d:...)\n",
d697 1
a697 1
		    pw->pw_name, (int) pw->pw_uid));
d705 2
a706 2
/* PUBLIC							HTAA_GidToName
**		GET THE GROUP NAME
d727 1
a727 1
	CTRACE((tfp, "%s(%d) returned (%s:%d:...)\n",
d730 1
a730 1
		    gr->gr_name, (int) gr->gr_gid));
d738 2
a739 2
/* PUBLIC							HTAA_NameToGid
**		GET THE GROUP ID
d759 1
a759 1
	CTRACE((tfp, "%s(%s) returned (%s:%d:...)\n",
d762 1
a762 1
		    gr->gr_name, (int) gr->gr_gid));
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d47 3
a49 3
static HTList *  prot_cache	= NULL;	/* Protection setup cache.	*/
static HTAAProt *default_prot	= NULL;	/* Default protection.		*/
static HTAAProt *current_prot	= NULL;	/* Current protection mode	*/
d55 1
a55 1
/* static							isNumber()
d58 1
a58 1
static BOOL isNumber (const char * s)
d60 1
a60 1
    const char *cur = s;
d87 1
a87 1
char * HTAA_getUidName (void)
d104 1
a104 1
char * HTAA_getFileName (void)
d123 1
a123 1
int HTAA_getUid (void)
d162 1
a162 1
int HTAA_getGid (void)
d193 1
a193 1
/* static							HTAA_setIds()
d204 2
a205 2
static void HTAA_setIds (HTAAProt *	prot,
			       const char *	ids)
d230 1
a230 1
/* static						HTAA_parseProtFile()
d240 2
a241 2
static void HTAA_parseProtFile (HTAAProt * prot,
				      FILE *	  fp)
d338 1
a338 1
/* static						HTAAProt_new()
d364 3
a366 3
static HTAAProt *HTAAProt_new (const char *	cur_docname,
				     const char *	prot_filename,
				     const char *	ids)
d442 3
a444 3
void HTAA_setDefaultProtection (const char *	cur_docname,
					    const char *	prot_filename,
					    const char *	ids)
d477 3
a479 3
void HTAA_setCurrentProtection (const char *	cur_docname,
					    const char *	prot_filename,
					    const char *	ids)
d517 1
a517 1
HTAAProt *HTAA_getCurrentProtection (void)
d546 1
a546 1
HTAAProt *HTAA_getDefaultProtection (void)
d567 1
a567 1
void HTAA_clearProtections (void)
d579 3
a581 3
static HTList *known_grp = NULL;
static HTList *known_pwd = NULL;
static BOOL uidgid_cache_inited = NO;
d585 1
a585 1
static void clear_uidgid_cache (void)
d608 1
a608 1
static void save_gid_info (char * name, int user)
d629 1
a629 1
static void save_uid_info (char * name, int user)
d657 1
a657 1
char * HTAA_UidToName (int uid)
d690 1
a690 1
int HTAA_NameToUid (char * name)
d722 1
a722 1
char * HTAA_GidToName (int gid)
d755 1
a755 1
int HTAA_NameToGid (char * name)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d3 16
a18 16
 *		PROTECTION FILE PARSING MODULE
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	20 Oct 93  AL	Now finds uid/gid for nobody/nogroup by name
 *			(doesn't use default 65534 right away).
 *			Also understands negative uids/gids.
 *	14 Nov 93  MD	Added VMS compatibility
 *
 * BUGS:
 *
 *
 */
d24 2
a25 2
#include <pwd.h>		/* Unix password file routine: getpwnam()       */
#include <grp.h>		/* Unix group file routine: getgrnam()          */
d30 2
a31 2
#include <HTLex.h>		/* Lexical analysor     */
#include <HTAAProt.h>		/* Implemented here     */
d36 2
a37 2
#define NOBODY    65534		/* -2 in 16-bit environment */
#define NONESUCH  65533		/* -3 in 16-bit environment */
d40 2
a41 2
 * Protection setup caching
 */
d43 2
a44 2
    char *prot_filename;
    HTAAProt *prot;
d47 3
a49 4
static HTList *prot_cache = NULL;	/* Protection setup cache.      */
static HTAAProt *default_prot = NULL;	/* Default protection.          */
static HTAAProt *current_prot = NULL;	/* Current protection mode      */

d51 1
a51 1
					/* from the rule system when    */
d56 3
a58 3
 *		DOES A CHARACTER STRING REPRESENT A NUMBER
 */
static BOOL isNumber(const char *s)
d62 1
a62 2
    if (isEmpty(s))
	return NO;
d65 1
a65 1
	cur++;			/* Allow initial minus sign in a number */
d76 1
d79 9
a87 9
 *		GET THE USER ID NAME (VMS ONLY)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the user name
 *		Default is "" (nobody).
 */
char *HTAA_getUidName(void)
d90 2
a91 2
	&& (0 != strcmp(current_prot->uid_name, "nobody")))
	return (current_prot->uid_name);
d93 1
a93 1
	return ("");
d97 8
a104 8
 *		GET THE FILENAME (VMS ONLY)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the filename
 */
char *HTAA_getFileName(void)
d107 1
a107 1
	return (current_prot->filename);
d109 1
a109 1
	return ("");
d115 9
a123 9
 *		GET THE USER ID TO CHANGE THE PROCESS UID TO
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the uid number to give to setuid() system call.
 *		Default is 65534 (nobody).
 */
int HTAA_getUid(void)
d127 1
a127 1
    if (current_prot && current_prot->uid_name) {
d130 1
a130 1
	    if ((*HTAA_UidToName(uid)) != '\0') {
d133 3
a135 2
	} else {		/* User name (not a number) */
	    if ((uid = HTAA_NameToUid(current_prot->uid_name)) != NONESUCH) {
d141 3
a143 3
     * Ok, then let's get uid for nobody.
     */
    if ((uid = HTAA_NameToUid("nobody")) != NONESUCH) {
d147 3
a149 3
     * Ok, then use default.
     */
    return NOBODY;		/* nobody */
d152 1
d154 9
a162 9
 *		GET THE GROUP ID TO CHANGE THE PROCESS GID TO
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the uid number to give to setgid() system call.
 *		Default is 65534 (nogroup).
 */
int HTAA_getGid(void)
d166 1
a166 1
    if (current_prot && current_prot->gid_name) {
d172 3
a174 2
	} else {		/* Group name (not number) */
	    if ((gid = HTAA_NameToGid(current_prot->gid_name)) != NONESUCH) {
d180 3
a182 3
     * Ok, then let's get gid for nogroup.
     */
    if ((gid = HTAA_NameToGid("nogroup")) != NONESUCH) {
d186 3
a188 3
     * Ok, then use default.
     */
    return NOBODY;		/* nogroup */
d192 1
d194 12
a205 11
 *		SET UID AND GID (AS NAMES OR NUMBERS)
 *		TO HTAAProt STRUCTURE
 * ON ENTRY:
 *	prot		destination.
 *	ids		is a string like "james.www" or "1422.69" etc.
 *			giving uid and gid.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAA_setIds(HTAAProt *prot, const char *ids)
d214 1
a214 1
	    *(point++) = (char) 0;
d216 2
a217 1
	} else {
d222 2
a223 1
    } else {
d229 1
d231 11
a241 10
 *		PARSE A PROTECTION SETUP FILE AND
 *		PUT THE RESULT IN A HTAAProt STRUCTURE
 * ON ENTRY:
 *	prot		destination structure.
 *	fp		open protection file.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAA_parseProtFile(HTAAProt *prot, FILE *fp)
d252 1
a252 1
	    if (lex_item == LEX_EOF)	/* End of file */
d261 2
a262 2
		/* after field name it's ok, but */
		/* not required. Here we read it. */
d264 1
a264 1
		if (0 == strncasecomp(fieldname, "Auth", 4)) {
a267 1

d271 1
a271 1
			    HTList_addObject(prot->valid_schemes, (void *) scheme);
d273 3
a275 3
				    "HTAA_parseProtFile: valid",
				    "authentication scheme:",
				    HTAAScheme_name(scheme)));
d278 3
a280 3
				    "HTAA_parseProtFile: unknown",
				    "authentication scheme:",
				    HTlex_buffer));
d286 4
a289 4
			 * Here lex_item == LEX_ITEM_SEP; after item separator
			 * it is ok to have one or more newlines (LEX_REC_SEP)
			 * and they are ignored (continuation line).
			 */
d293 4
a296 4
		    }		/* while items in list */
		}
		/* if "Authenticate" */
		else if (0 == strncasecomp(fieldname, "mask", 4)) {
d298 1
a298 1
		    lex_item = LEX_REC_SEP;	/*groupdef parser read this already */
d304 1
a304 3
			} else
			    fprintf(tfp,
				    "HTAA_parseProtFile: Mask group syntax error\n");
d306 3
a308 3
		}
		/* if "Mask" */
		else {		/* Just a name-value pair, put it to assoclist */
d314 1
a314 1
			lex_item = lex(fp);	/* Read record separator */
d316 2
a317 2
				"HTAA_parseProtFile: Name",
				fieldname, HTlex_buffer));
d319 1
a319 1
		}		/* else name-value pair */
d321 3
a323 3
	    }
	    /* if valid field */
	    if (lex_item != LEX_EOF && lex_item != LEX_REC_SEP) {
d325 3
a327 3
			"HTAA_parseProtFile: Syntax error",
			"in protection setup file at line",
			HTlex_line));
d331 2
a332 2
	    }			/* if syntax error */
	}			/* while not end-of-file */
d334 1
a334 1
    }				/* if valid parameters */
d337 1
d339 28
a366 28
 *		ALLOCATE A NEW HTAAProt STRUCTURE AND
 *		INITIALIZE IT FROM PROTECTION SETUP FILE
 * ON ENTRY:
 *	cur_docname	current filename after rule translations.
 *	prot_filename	protection setup file name.
 *			If NULL, not an error.
 *	ids		Uid and gid names or numbers,
 *			examples:
 *				james	( <=> james.nogroup)
 *				.www	( <=> nobody.www)
 *				james.www
 *				james.69
 *				1422.69
 *				1422.www
 *
 *			May be NULL, defaults to nobody.nogroup.
 *			Should be NULL, if prot_file is NULL.
 *
 * ON EXIT:
 *	returns		returns a new and initialized protection
 *			setup structure.
 *			If setup file is already read in (found
 *			in cache), only sets uid_name and gid
 *			fields, and returns that.
 */
static HTAAProt *HTAAProt_new(const char *cur_docname,
			      const char *prot_filename,
			      const char *ids)
d376 1
a376 1
    while (NULL != (cache_item = (HTAAProtCache *) HTList_nextObject(cur))) {
d383 1
a383 1
		"HTAAProt_new: Protection file", prot_filename));
d386 1
a386 1
		prot_filename));
d389 1
a389 1
	      outofmem(__FILE__, "HTAAProt_new");
d391 4
a394 4
	prot->template = NULL;
	prot->filename = NULL;
	prot->uid_name = NULL;
	prot->gid_name = NULL;
d396 2
a397 2
	prot->mask_group = NULL;	/* Masking disabled by defaults */
	prot->values = HTAssocList_new();
d407 1
a407 1
	    HTList_addObject(prot_cache, (void *) cache_item);
d410 2
a411 2
		    "Unable to open protection setup file",
		    NONNULL(prot_filename)));
d422 1
d424 21
a444 21
 *		SET THE DEFAULT PROTECTION MODE
 *		(called by rule system when a
 *		"defprot" rule is matched)
 * ON ENTRY:
 *	cur_docname	is the current result of rule translations.
 *	prot_filename	is the protection setup file (second argument
 *			for "defprot" rule, optional)
 *	ids		contains user and group names separated by
 *			a dot, corresponding to the uid
 *			gid under which the server should run,
 *			default is "nobody.nogroup" (third argument
 *			for "defprot" rule, optional; can be given
 *			only if protection setup file is also given).
 *
 * ON EXIT:
 *	returns		nothing.
 *			Sets the module-wide variable default_prot.
 */
void HTAA_setDefaultProtection(const char *cur_docname,
			       const char *prot_filename,
			       const char *ids)
d452 2
a453 2
		"HTAA_setDefaultProtection: ERROR: Protection file",
		"not specified (obligatory for DefProt rule)!!\n"));
d457 1
d459 21
a479 21
 *		SET THE CURRENT PROTECTION MODE
 *		(called by rule system when a
 *		"protect" rule is matched)
 * ON ENTRY:
 *	cur_docname	is the current result of rule translations.
 *	prot_filename	is the protection setup file (second argument
 *			for "protect" rule, optional)
 *	ids		contains user and group names separated by
 *			a dot, corresponding to the uid
 *			gid under which the server should run,
 *			default is "nobody.nogroup" (third argument
 *			for "protect" rule, optional; can be given
 *			only if protection setup file is also given).
 *
 * ON EXIT:
 *	returns		nothing.
 *			Sets the module-wide variable current_prot.
 */
void HTAA_setCurrentProtection(const char *cur_docname,
			       const char *prot_filename,
			       const char *ids)
d490 3
a492 3
		    "HTAA_setCurrentProtection: Protection file",
		    "not specified for Protect rule",
		    "-- using default protection"));
d495 3
a497 3
		    "HTAA_setCurrentProtection: ERROR: Protection",
		    "file not specified for Protect rule, and",
		    "default protection is not set!!"));
d502 1
d504 14
a517 14
 *		GET CURRENT PROTECTION SETUP STRUCTURE
 *		(this is set up by callbacks made from
 *		 the rule system when matching "protect"
 *		 (and "defprot") rules)
 * ON ENTRY:
 *	HTTranslate() must have been called before calling
 *	this function.
 *
 * ON EXIT:
 *	returns	a HTAAProt structure representing the
 *		protection setup of the HTTranslate()'d file.
 *		This must not be free()'d.
 */
HTAAProt *HTAA_getCurrentProtection(void)
d522 1
d524 23
a546 23
 *		GET DEFAULT PROTECTION SETUP STRUCTURE
 *		AND SET IT TO CURRENT PROTECTION
 *		(this is set up by callbacks made from
 *		 the rule system when matching "defprot"
 *		 rules)
 * ON ENTRY:
 *	HTTranslate() must have been called before calling
 *	this function.
 *
 * ON EXIT:
 *	returns	a HTAAProt structure representing the
 *		default protection setup of the HTTranslate()'d
 *		file (if HTAA_getCurrentProtection() returned
 *		NULL, i.e., if there is no "protect" rule
 *		but ACL exists, and we need to know default
 *		protection settings).
 *		This must not be free()'d.
 * IMPORTANT:
 *	As a side-effect this tells the protection system that
 *	the file is in fact protected and sets the current
 *	protection mode to default.
 */
HTAAProt *HTAA_getDefaultProtection(void)
d555 1
d557 11
a567 11
 *		CLEAR DOCUMENT PROTECTION MODE
 *		(ALSO DEFAULT PROTECTION)
 *		(called by the rule system)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	nothing.
 *		Frees the memory used by protection information.
 */
void HTAA_clearProtections(void)
d569 2
a570 2
    current_prot = NULL;	/* These are not freed because  */
    default_prot = NULL;	/* they are actually in cache.  */
d574 3
a576 3
    char *name;
    int user;
} USER_DATA;
d585 1
a585 1
static void clear_uidgid_cache(void)
a588 1

d608 1
a608 1
static void save_gid_info(char *name, int user)
a610 1

d624 1
a624 1
    HTList_addObject(known_grp, data);
d629 1
a629 1
static void save_uid_info(char *name, int user)
a631 1

d645 1
a645 1
    HTList_addObject(known_pwd, data);
d650 8
a657 8
 *		GET THE USER NAME
 * ON ENTRY:
 *      The user-id
 *
 * ON EXIT:
 *      returns the user name, or an empty string if not found.
 */
char *HTAA_UidToName(int uid)
d664 1
a664 2
	USER_DATA *data = (USER_DATA *) (me->object);

d670 1
a670 1
	&& pw->pw_name != 0) {
d672 3
a674 3
		"HTAA_UidToName: getpwuid",
		uid,
		pw->pw_name, (int) pw->pw_uid));
d683 8
a690 8
 *		GET THE USER ID
 * ON ENTRY:
 *      The user-name
 *
 * ON EXIT:
 *      returns the user id, or NONESUCH if not found.
 */
int HTAA_NameToUid(char *name)
d697 1
a697 2
	USER_DATA *data = (USER_DATA *) (me->object);

d704 3
a706 3
		"HTAA_NameToUid: getpwnam",
		name,
		pw->pw_name, (int) pw->pw_uid));
d715 8
a722 8
 *		GET THE GROUP NAME
 * ON ENTRY:
 *      The group-id
 *
 * ON EXIT:
 *      returns the group name, or an empty string if not found.
 */
char *HTAA_GidToName(int gid)
d729 1
a729 2
	USER_DATA *data = (USER_DATA *) (me->object);

d735 1
a735 1
	&& gr->gr_name != 0) {
d737 3
a739 3
		"HTAA_GidToName: getgrgid",
		gid,
		gr->gr_name, (int) gr->gr_gid));
d748 8
a755 8
 *		GET THE GROUP ID
 * ON ENTRY:
 *      The group-name
 *
 * ON EXIT:
 *      returns the group id, or NONESUCH if not found.
 */
int HTAA_NameToGid(char *name)
d762 1
a762 2
	USER_DATA *data = (USER_DATA *) (me->object);

d769 3
a771 3
		"HTAA_NameToGid: getgrnam",
		name,
		gr->gr_name, (int) gr->gr_gid));
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a32 1
#include <LYUtils.h>
d49 4
a52 3
					/* which is set up by callbacks */
					/* from the rule system when	*/
					/* a "protect" rule is matched. */
a53 1
#ifndef NOUSERS
a72 1
#endif /* !NOUSERS */
d88 1
a88 1
		  && (0 != strcmp(current_prot->uid_name,"nobody")) )
d259 2
a260 2
					/* after field name it's ok, but */
					/* not required. Here we read it.*/
d270 4
a273 4
			    CTRACE((tfp, "%s %s `%s'\n",
					"HTAA_parseProtFile: valid",
					"authentication scheme:",
					HTAAScheme_name(scheme)));
d275 1
a275 1
			    CTRACE((tfp, "%s %s `%s'\n",
d278 1
a278 1
					HTlex_buffer));
d313 1
a313 1
			CTRACE((tfp, "%s `%s' bound to value `%s'\n",
d315 1
a315 1
				    fieldname, HTlex_buffer));
d322 1
a322 1
		CTRACE((tfp, "%s %s %d (that line ignored)\n",
d325 1
a325 1
			    HTlex_line));
d380 2
a381 2
	CTRACE((tfp, "%s `%s' already in cache\n",
		    "HTAAProt_new: Protection file", prot_filename));
d383 2
a384 2
	CTRACE((tfp, "HTAAProt_new: Loading protection file `%s'\n",
		    prot_filename));
d386 1
a386 1
	if ((prot = typecalloc(HTAAProt)) == 0)
d397 1
a397 1
	if (prot_filename && NULL != (fp = fopen(prot_filename, TXT_R))) {
d400 2
a401 1
	    if ((cache_item = typecalloc(HTAAProtCache)) == 0)
d408 1
a408 1
	    CTRACE((tfp, "HTAAProt_new: %s `%s'\n",
d410 1
a410 1
			NONNULL(prot_filename)));
d450 1
a450 1
	CTRACE((tfp, "%s %s\n",
d452 1
a452 1
		    "not specified (obligatory for DefProt rule)!!\n"));
d488 4
a491 4
	    CTRACE((tfp, "%s %s %s\n",
			"HTAA_setCurrentProtection: Protection file",
			"not specified for Protect rule",
			"-- using default protection"));
d493 4
a496 4
	    CTRACE((tfp, "%s %s %s\n",
			"HTAA_setCurrentProtection: ERROR: Protection",
			"file not specified for Protect rule, and",
			"default protection is not set!!"));
d573 1
a573 1
	char *name;
d575 1
a575 1
	} USER_DATA;
a576 1
#ifndef NOUSERS
a579 1
#endif
a583 1
#ifndef NOUSERS
a598 1
#endif
a601 1
#ifndef NOUSERS
d604 1
a604 1
    USER_DATA *data = typecalloc(USER_DATA);
a619 1
#endif /* NOUSERS */
a620 1
#ifndef NOUSERS
d623 1
a623 1
    USER_DATA *data = typecalloc(USER_DATA);
a638 1
#endif /* !NOUSERS */
d640 2
a641 2
/* PUBLIC							HTAA_UidToName
**		GET THE USER NAME
d662 1
a662 1
	CTRACE((tfp, "%s(%d) returned (%s:%d:...)\n",
d665 1
a665 1
		    pw->pw_name, (int) pw->pw_uid));
d673 2
a674 2
/* PUBLIC							HTAA_NameToUid
**		GET THE USER ID
d694 1
a694 1
	CTRACE((tfp, "%s(%s) returned (%s:%d:...)\n",
d697 1
a697 1
		    pw->pw_name, (int) pw->pw_uid));
d705 2
a706 2
/* PUBLIC							HTAA_GidToName
**		GET THE GROUP NAME
d727 1
a727 1
	CTRACE((tfp, "%s(%d) returned (%s:%d:...)\n",
d730 1
a730 1
		    gr->gr_name, (int) gr->gr_gid));
d738 2
a739 2
/* PUBLIC							HTAA_NameToGid
**		GET THE GROUP ID
d759 1
a759 1
	CTRACE((tfp, "%s(%s) returned (%s:%d:...)\n",
d762 1
a762 1
		    gr->gr_name, (int) gr->gr_gid));
@

