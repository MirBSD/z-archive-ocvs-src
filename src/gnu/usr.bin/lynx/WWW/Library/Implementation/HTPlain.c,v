head	1.7;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.8
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.6
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2005.01.03.00.45.47;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.37;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.27;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.55.47;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.02;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.07;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.00;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.40;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.51;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.25;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.15;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.47.15;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@soft merge
@
text
@/*		Plain text object		HTWrite.c
 *		=================
 *
 *	This version of the stream object just writes to a socket.
 *	The socket is assumed open and left open.
 *
 *	Bugs:
 *		strings written must be less than buffer size.
 */

#include <HTUtils.h>
#include <LYCharVals.h>		/* S/390 -- gil -- 0288 */

#include <HTPlain.h>

#include <HTChunk.h>
#include <HText.h>
#include <HTStyle.h>
#define Lynx_HTML_Handler
#include <HTML.h>		/* styles[] */

#define BUFFER_SIZE 4096;	/* Tradeoff */

#include <HTMLDTD.h>
#include <HTCJK.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <UCAux.h>

#include <LYCharSets.h>
#include <LYLeaks.h>

static int HTPlain_lastraw = -1;
static int HTPlain_bs_pending = 0;	/* 1:bs 2:underline 3:underline+bs - kw */

/*		HTML Object
 *		-----------
 */
struct _HTStream {
    const HTStreamClass *isa;
    HText *text;
    /*
     * The node_anchor UCInfo and handle for the input (PARSER) stage.  - FM
     */
    LYUCcharset *inUCI;
    int inUCLYhndl;
    /*
     * The node_anchor UCInfo and handle for the output (HTEXT) stage.  - FM
     */
    LYUCcharset *outUCI;
    int outUCLYhndl;
    /*
     * Counter, value, buffer and pointer for UTF-8 handling.  - FM
     */
    char utf_count;
    UCode_t utf_char;
    char utf_buf[8];
    char *utf_buf_p;
    /*
     * The charset transformation structure.  - FM
     */
    UCTransParams T;
};

static char replace_buf[64];	/* buffer for replacement strings */

static void HTPlain_getChartransInfo(HTStream *me, HTParentAnchor *anchor)
{
    if (me->inUCLYhndl < 0) {
	HTAnchor_copyUCInfoStage(anchor, UCT_STAGE_PARSER, UCT_STAGE_MIME,
				 UCT_SETBY_PARSER);
	me->inUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
    }
    if (me->outUCLYhndl < 0) {
	int chndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);

	if (chndl < 0) {
	    chndl = current_char_set;
	    HTAnchor_setUCInfoStage(anchor, chndl,
				    UCT_STAGE_HTEXT, UCT_SETBY_DEFAULT);
	}
	HTAnchor_setUCInfoStage(anchor, chndl,
				UCT_STAGE_HTEXT, UCT_SETBY_DEFAULT);
	me->outUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
    }
    me->inUCI = HTAnchor_getUCInfoStage(anchor, UCT_STAGE_PARSER);
    me->outUCI = HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT);
}

/*	Write the buffer out to the socket
 *	----------------------------------
 */

/*_________________________________________________________________________
 *
 *			A C T I O N	R O U T I N E S
 */

static void HTPlain_write(HTStream *me, const char *s,
			  int l);

/*	Character handling
 *	------------------
 */
static void HTPlain_put_character(HTStream *me, char c)
{
#ifdef REMOVE_CR_ONLY
    /*
     * Throw away \r's.
     */
    if (c != '\r') {
	HText_appendCharacter(me->text, c);
    }
#else
    /*
     * See HTPlain_write() for explanations of the following code (we've been
     * called via HTPlain_put_string() to do for each character of a terminated
     * string what HTPlain_write() does via a while loop for each character in
     * a stream of given length).  - FM
     */
    if ((HTPlain_lastraw == '\r') && c == '\n') {
	HTPlain_lastraw = -1;
	return;
    }
    if (c == '\b' || c == '_' || HTPlain_bs_pending) {
	HTPlain_write(me, &c, 1);
	return;
    }
    HTPlain_lastraw = UCH(c);
    if (c == '\r') {
	HText_appendCharacter(me->text, '\n');
    } else if (TOASCII(UCH(c)) >= 127) {	/* S/390 -- gil -- 0305 */
	/*
	 * For now, don't repeat everything here that has been done below - KW
	 */
	HTPlain_write(me, &c, 1);
    } else if (HTCJK != NOCJK) {
	HText_appendCharacter(me->text, c);
    } else if (TOASCII(UCH(c)) >= 127 && TOASCII(UCH(c)) < 161 &&
	       HTPassHighCtrlRaw) {
	HText_appendCharacter(me->text, c);
    } else if (UCH(c) == CH_NBSP) {	/* S/390 -- gil -- 0341 */
	HText_appendCharacter(me->text, ' ');
    } else if (UCH(c) == CH_SHY) {
	return;
    } else if ((UCH(c) >= ' ' && TOASCII(UCH(c)) < 127) ||
	       c == '\n' || c == '\t') {
	HText_appendCharacter(me->text, c);
    } else if (TOASCII(UCH(c)) > 160) {
	if (!HTPassEightBitRaw &&
	    !((me->outUCLYhndl == LATIN1) ||
	      (me->outUCI->enc & (UCT_CP_SUPERSETOF_LAT1)))) {
	    int len, high, low, i, diff = 1;
	    const char *name;
	    UCode_t value = (UCode_t) FROMASCII((TOASCII(UCH(c)) - 160));

	    name = HTMLGetEntityName(value);
	    len = strlen(name);
	    for (low = 0, high = HTML_dtd.number_of_entities;
		 high > low;
		 diff < 0 ? (low = i + 1) : (high = i)) {
		/* Binary search */
		i = (low + (high - low) / 2);
		diff = AS_ncmp(HTML_dtd.entity_names[i], name, len);
		if (diff == 0) {
		    HText_appendText(me->text,
				     LYCharSets[me->outUCLYhndl][i]);
		    break;
		}
	    }
	    if (diff) {
		HText_appendCharacter(me->text, c);
	    }
	} else {
	    HText_appendCharacter(me->text, c);
	}
    }
#endif /* REMOVE_CR_ONLY */
}

/*	String handling
 *	---------------
 *
 */
static void HTPlain_put_string(HTStream *me, const char *s)
{
#ifdef REMOVE_CR_ONLY
    HText_appendText(me->text, s);
#else
    const char *p;

    if (s == NULL)
	return;
    for (p = s; *p; p++) {
	HTPlain_put_character(me, *p);
    }
#endif /* REMOVE_CR_ONLY */
}

/*
 *	Entry function for displayed text/plain and WWW_SOURCE strings. - FM
 *	---------------------------------------------------------------
 */
static void HTPlain_write(HTStream *me, const char *s, int l)
{
    const char *p;
    const char *e = s + l;
    char c;
    unsigned c_unsign;
    BOOL chk;
    UCode_t code, uck = -1;
    char saved_char_in = '\0';

    for (p = s; p < e; p++) {
#ifdef REMOVE_CR_ONLY
	/*
	 * Append the whole string, but remove any \r's.  - FM
	 */
	if (*p != '\r') {
	    HText_appendCharacter(me->text, *p);
	}
#else
	if (*p == '\b') {
	    if (HTPlain_lastraw >= UCH(' ') &&
		HTPlain_lastraw != '\r' && HTPlain_lastraw != '\n') {
		if (!HTPlain_bs_pending) {
		    HTPlain_bs_pending = 1;
		    continue;
		} else if (HTPlain_bs_pending == 2) {
		    HTPlain_bs_pending = 3;
		    continue;
		}
	    }
	    if (HTPlain_bs_pending >= 2)
		HText_appendCharacter(me->text, '_');
	    HTPlain_bs_pending = 0;
	} else if (*p == '_') {
	    if (!HTPlain_bs_pending) {
		HTPlain_bs_pending = 2;
		HTPlain_lastraw = UCH(*p);
		continue;
#if 0
	    } else if (HTPlain_bs_pending != 2) {
		HTPlain_bs_pending--;	/* 1 -> 0, 3 -> 2 */
		HTPlain_lastraw = UCH(*p);
		continue;
#endif
	    }
	}

	/*
	 * Try to handle lone LFs, CRLFs and lone CRs as newline, and to deal
	 * with control, ASCII, and 8-bit characters based on best guesses of
	 * what's appropriate.  - FM
	 */
	if ((HTPlain_lastraw == '\r') && *p == '\n') {
	    HTPlain_lastraw = -1;
	    continue;
	}

	if (HTPlain_bs_pending &&
	    !(UCH(*p) >= ' ' && *p != '\r' && *p != '\n' &&
	      (HTPlain_lastraw == UCH(*p) ||
	       HTPlain_lastraw == UCH('_') ||
	       *p == '_'))) {
	    if (HTPlain_bs_pending >= 2)
		HText_appendCharacter(me->text, '_');
	    HTPlain_bs_pending = 0;
	} else if (HTPlain_bs_pending == 1) {
	    HTPlain_bs_pending = 0;
	    continue;		/* ignore last two of "X\bX" or "X\b_" - kw */
	} else if (HTPlain_bs_pending == 3) {
	    if (*p == '_') {
		HTPlain_bs_pending = 2;
		continue;	/* ignore last two of "_\b_" - kw */
	    } else {
		HTPlain_bs_pending = 0;
		/* ignore first two of "_\bX" - kw */
	    }
	} else if (HTPlain_bs_pending == 2) {
	    HText_appendCharacter(me->text, '_');
	    if (*p == '_')
		continue;	/* keep second of "__" pending - kw */
	    HTPlain_bs_pending = 0;
	} else {
	    HTPlain_bs_pending = 0;
	}
	HTPlain_lastraw = UCH(*p);
	if (*p == '\r') {
	    HText_appendCharacter(me->text, '\n');
	    continue;
	}
	/*
	 * Make sure the character is handled as Unicode whenever that's
	 * appropriate.  - FM
	 */
	c = *p;
	c_unsign = UCH(c);
	code = (UCode_t) c_unsign;
	saved_char_in = '\0';
	/*
	 * Combine any UTF-8 multibytes into Unicode to check for special
	 * characters.  - FM
	 */
	if (me->T.decode_utf8) {
	    /*
	     * Combine UTF-8 into Unicode.  Incomplete characters silently
	     * ignored.  from Linux kernel's console.c - KW
	     */
	    if (TOASCII(c_unsign) > 127) {	/* S/390 -- gil -- 0371 */
		/*
		 * We have an octet from a multibyte character.  - FM
		 */
		if (me->utf_count > 0 && (c & 0xc0) == 0x80) {
		    /*
		     * Adjust the UCode_t value, add the octet to the buffer,
		     * and decrement the byte count.  - FM
		     */
		    me->utf_char = (me->utf_char << 6) | (c & 0x3f);
		    me->utf_count--;
		    *(me->utf_buf_p) = c;
		    (me->utf_buf_p)++;
		    if (me->utf_count == 0) {
			/*
			 * Got a complete multibyte character.
			 */
			*(me->utf_buf_p) = '\0';
			code = me->utf_char;
			if (code > 0 && code < 256) {
			    c = FROMASCII((char) code);
			    c_unsign = UCH(c);
			}
		    } else {
			/*
			 * Get the next byte.  - FM
			 */
			continue;
		    }
		} else {
		    /*
		     * Start handling a new multibyte character.  - FM
		     */
		    me->utf_buf_p[0] = c;
		    me->utf_buf_p = &me->utf_buf[1];
		    if ((*p & 0xe0) == 0xc0) {
			me->utf_count = 1;
			me->utf_char = (c & 0x1f);
		    } else if ((*p & 0xf0) == 0xe0) {
			me->utf_count = 2;
			me->utf_char = (c & 0x0f);
		    } else if ((*p & 0xf8) == 0xf0) {
			me->utf_count = 3;
			me->utf_char = (c & 0x07);
		    } else if ((*p & 0xfc) == 0xf8) {
			me->utf_count = 4;
			me->utf_char = (c & 0x03);
		    } else if ((*p & 0xfe) == 0xfc) {
			me->utf_count = 5;
			me->utf_char = (c & 0x01);
		    } else {
			/*
			 * We got garbage, so ignore it.  - FM
			 */
			me->utf_count = 0;
			me->utf_buf_p[0] = '\0';
			me->utf_buf_p = me->utf_buf;
		    }
		    /*
		     * Get the next byte.  - FM
		     */
		    continue;
		}
	    } else if (me->utf_count > 0) {
		/*
		 * Got an ASCII character when expecting UTF-8 multibytes, so
		 * ignore the buffered multibye characters and fall through
		 * with the current ASCII character.  - FM
		 */
		me->utf_count = 0;
		me->utf_buf[0] = '\0';
		me->utf_buf_p = me->utf_buf;
		code = (UCode_t) c_unsign;
	    } else {
		/*
		 * Got a valid ASCII character, so fall through with it.  - FM
		 */
		code = (UCode_t) c_unsign;
	    }
	}
	/*
	 * Convert characters from non-UTF-8 charsets to Unicode (if
	 * appropriate).  - FM
	 */
	if (!(me->T.decode_utf8 &&
	      UCH(*p) > 127)) {
#ifdef NOTDEFINED
	    if (me->T.strip_raw_char_in)
		saved_char_in = c;
#endif /* NOTDEFINED */
	    if (me->T.trans_to_uni &&
		(TOASCII(code) >= LYlowest_eightbit[me->inUCLYhndl] ||	/* S/390 -- gil -- 0389 */
		 (code < ' ' && code != 0 &&
		  me->T.trans_C0_to_uni))) {
		/*
		 * Convert the octet to Unicode.  - FM
		 */
		code = (UCode_t) UCTransToUni(c, me->inUCLYhndl);
		if (code > 0) {
		    saved_char_in = c;
		    if (code < 256) {
			c = FROMASCII((char) code);
			c_unsign = UCH(c);
		    }
		}
	    } else if (code < 32 && code != 0 &&
		       me->T.trans_C0_to_uni) {
		/*
		 * Quote from SGML.c:
		 * "This else if may be too ugly to keep.  - KW"
		 */
		if (me->T.trans_from_uni &&
		    (((code = UCTransToUni(c, me->inUCLYhndl)) >= 32) ||
		     (me->T.transp &&
		      (code = UCTransToUni(c, me->inUCLYhndl)) > 0))) {
		    saved_char_in = c;
		    if (code < 256) {
			c = FROMASCII((char) code);
			c_unsign = UCH(c);
		    }
		} else {
		    uck = -1;
		    if (me->T.transp) {
			uck = UCTransCharStr(replace_buf, 60, c,
					     me->inUCLYhndl,
					     me->inUCLYhndl, NO);
		    }
		    if (!me->T.transp || uck < 0) {
			uck = UCTransCharStr(replace_buf, 60, c,
					     me->inUCLYhndl,
					     me->outUCLYhndl, YES);
		    }
		    if (uck == 0) {
			continue;
		    } else if (uck < 0) {
			me->utf_buf[0] = '\0';
			code = UCH(c);
		    } else {
			c = replace_buf[0];
			if (c && replace_buf[1]) {
			    HText_appendText(me->text, replace_buf);
			    continue;
			}
		    }
		    me->utf_buf[0] = '\0';
		    code = UCH(c);
		}		/*  Next line end of ugly stuff for C0. - KW */
	    } else {
		me->utf_buf[0] = '\0';
		code = UCH(c);
	    }
	}
	/*
	 * At this point we have either code in Unicode (and c in latin1 if
	 * code is in the latin1 range), or code and c will have to be passed
	 * raw.
	 */

	/*
	 * If CJK mode is on, we'll assume the document matches the user's
	 * display character set, and if not, the user should toggle off
	 * raw/CJK mode to reload.  - FM
	 */
	if (HTCJK != NOCJK) {
	    HText_appendCharacter(me->text, c);

#define PASSHICTRL (me->T.transp || \
		    code >= LYlowest_eightbit[me->inUCLYhndl])
#define PASS8859SPECL me->T.pass_160_173_raw
#define PASSHI8BIT (HTPassEightBitRaw || \
		    (me->T.do_8bitraw && !me->T.trans_from_uni))
	    /*
	     * If HTPassHighCtrlRaw is set (e.g., for KOI8-R) assume the
	     * document matches and pass 127-160 8-bit characters.  If it
	     * doesn't match, the user should toggle raw/CJK mode off.  - FM
	     */
	} else if (TOASCII(code) >= 127 && TOASCII(code) < 161 &&	/* S/390 -- gil -- 0427 */
		   PASSHICTRL && PASS8859SPECL) {
	    HText_appendCharacter(me->text, c);
	} else if (code == CH_SHY && PASS8859SPECL) {
	    HText_appendCharacter(me->text, c);
	    /*
	     * If neither HTPassHighCtrlRaw nor CJK is set, play it safe and
	     * treat 160 (nbsp) as an ASCII space (32).  - FM
	     */
	} else if (code == CH_NBSP) {
	    HText_appendCharacter(me->text, ' ');
	    /*
	     * If neither HTPassHighCtrlRaw nor CJK is set, play it safe and
	     * ignore 173 (shy).  - FM
	     * Now only ignore it for color style, which doesn't handle it
	     * anyway.  Otherwise pass it on as LY_SOFT_HYPHEN and let HText
	     * deal with it.  It should be either ignored, or displayed as a
	     * hyphen if it was indeed at the end of a line.  Well it should. 
	     * - kw
	     */
	} else if (code == CH_SHY) {
#ifndef USE_COLOR_STYLE
	    HText_appendCharacter(me->text, LY_SOFT_HYPHEN);
#endif
	    continue;
	    /*
	     * If we get to here, pass the displayable ASCII characters.  - FM
	     */
	} else if ((code >= ' ' && TOASCII(code) < 127) ||
		   (PASSHI8BIT &&
		    c >= LYlowest_eightbit[me->outUCLYhndl]) ||
		   *p == '\n' || *p == '\t') {
	    HText_appendCharacter(me->text, c);
	    /*
	     * Use an ASCII space (32) for ensp, emsp or thinsp.  - FM
	     */
	} else if (code == 8194 || code == 8195 || code == 8201) {
	    HText_appendCharacter(me->text, ' ');
	    /*
	     * If we want the raw character, pass it now.  - FM
	     */
	} else if (me->T.use_raw_char_in && saved_char_in) {
	    HText_appendCharacter(me->text, saved_char_in);
/******************************************************************
 * I.  LATIN-1 OR UCS2 TO DISPLAY CHARSET
 ******************************************************************/
	} else if ((chk = (BOOL) (me->T.trans_from_uni && code >= 160)) &&
		   (uck = UCTransUniChar(code,
					 me->outUCLYhndl)) >= ' ' &&	/* S/390 -- gil -- 0464 */
		   uck < 256) {
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
		    uck, FROMASCII((char) uck)));
	    HText_appendCharacter(me->text, ((char) (uck & 0xff)));
	} else if (chk &&
		   (uck == -4 ||
		    (me->T.repl_translated_C0 && uck > 0 && uck < ' ')) &&	/* S/390 -- gil -- 0481 */
	    /*
	     * Not found; look for replacement string.
	     */
		   (uck = UCTransUniCharStr(replace_buf, 60, code,
					    me->outUCLYhndl, 0) >= 0)) {
	    /*
	     * No further tests for valididy - assume that whoever defined
	     * replacement strings knew what she was doing.
	     */
	    HText_appendText(me->text, replace_buf);
	    /*
	     * If we get to here, and should have translated, translation has
	     * failed so far.
	     */
	} else if (chk && TOASCII(code) > 127 && me->T.output_utf8) {	/* S/390 -- gil -- 0498 */
	    /*
	     * We want UTF-8 output, so do it now.  - FM
	     */
	    if (*me->utf_buf) {
		HText_appendText(me->text, me->utf_buf);
		me->utf_buf[0] = '\0';
		me->utf_buf_p = me->utf_buf;
	    } else if (UCConvertUniToUtf8(code, replace_buf)) {
		HText_appendText(me->text, replace_buf);
	    } else {
		/*
		 * Out of luck, so use the UHHH notation (ugh).  - gil
		 */
		/* S/390 -- gil -- 0517 */
		sprintf(replace_buf, "U%.2lX", TOASCII(code));
		HText_appendText(me->text, replace_buf);
	    }
#ifdef NOTDEFINED
	} else if (me->T.strip_raw_char_in &&
		   UCH(*p) >= 192 &&
		   UCH(*p) < 255) {
	    /*
	     * KOI special:  strip high bit, gives (somewhat) readable ASCII.
	     */
	    HText_appendCharacter(me->text, (char) (*p & 0x7f));
#endif /* NOTDEFINED */
	    /*
	     * If we don't actually want the character, make it safe and output
	     * that now.  - FM
	     */
	} else if ((c_unsign > 0 &&
		    (int) c_unsign < LYlowest_eightbit[me->outUCLYhndl]) ||
		   (me->T.trans_from_uni && !HTPassEightBitRaw)) {
	    /*
	     * If we do not have the "7-bit approximations" as our output
	     * character set (in which case we did it already) seek a
	     * translation for that.  Otherwise, or if the translation fails,
	     * use UHHH notation.  - FM
	     */
	    if ((chk = (BOOL) (me->outUCLYhndl !=
			       UCGetLYhndl_byMIME("us-ascii"))) &&
		(uck = UCTransUniChar(code,
				      UCGetLYhndl_byMIME("us-ascii")))
		>= ' ' && TOASCII(uck) < 127) {		/* S/390 -- gil -- 0535 */
		/*
		 * Got an ASCII character (yippey).  - FM
		 */
		c = FROMASCII((char) uck);
		HText_appendCharacter(me->text, c);
	    } else if ((chk && uck == -4) &&
		       (uck = UCTransUniCharStr(replace_buf,
						60, code,
						UCGetLYhndl_byMIME("us-ascii"),
						0) >= 0)) {
		/*
		 * Got a repacement string (yippey).  - FM
		 */
		HText_appendText(me->text, replace_buf);
	    } else if (code == 8204 || code == 8205) {
		/*
		 * Ignore 8204 (zwnj) or 8205 (zwj), if we get to here.  - FM
		 */
		CTRACE((tfp, "HTPlain_write: Ignoring '%ld'.\n", code));
	    } else if (code == 8206 || code == 8207) {
		/*
		 * Ignore 8206 (lrm) or 8207 (rlm), if we get to here.  - FM
		 */
		CTRACE((tfp, "HTPlain_write: Ignoring '%ld'.\n", code));
	    } else {
		/*
		 * Out of luck, so use the UHHH notation (ugh).  - FM
		 */
		/* do not print UHHH for now
		   sprintf(replace_buf, "U%.2lX", code);
		   HText_appendText(me->text, replace_buf);
		 */
	    }
	    /*
	     * If we get to here and have a monobyte character, pass it.  - FM
	     */
	} else if (c_unsign != 0 && c_unsign < 256) {
	    HText_appendCharacter(me->text, c);
	}
#endif /* REMOVE_CR_ONLY */
    }
}

/*	Free an HTML object
 *	-------------------
 *
 *	Note that the SGML parsing context is freed, but the created object is
 *	not, as it takes on an existence of its own unless explicitly freed.
 */
static void HTPlain_free(HTStream *me)
{
    if (HTPlain_bs_pending >= 2)
	HText_appendCharacter(me->text, '_');
    FREE(me);
}

/*	End writing
*/
static void HTPlain_abort(HTStream *me, HTError e GCC_UNUSED)
{
    HTPlain_free(me);
}

/*		Structured Object Class
 *		-----------------------
 */
static const HTStreamClass HTPlain =
{
    "PlainPresenter",
    HTPlain_free,
    HTPlain_abort,
    HTPlain_put_character, HTPlain_put_string, HTPlain_write,
};

/*		New object
 *		----------
 */
HTStream *HTPlainPresent(HTPresentation *pres GCC_UNUSED, HTParentAnchor *anchor,
			 HTStream *sink GCC_UNUSED)
{

    HTStream *me = (HTStream *) malloc(sizeof(*me));

    if (me == NULL)
	outofmem(__FILE__, "HTPlain_new");
    me->isa = &HTPlain;

    HTPlain_lastraw = -1;

    me->utf_count = 0;
    me->utf_char = 0;
    me->utf_buf[0] = me->utf_buf[6] = me->utf_buf[7] = '\0';
    me->utf_buf_p = me->utf_buf;
    me->outUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
    me->inUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
    HTPlain_getChartransInfo(me, anchor);
    UCSetTransParams(&me->T,
		     me->inUCLYhndl, me->inUCI,
		     me->outUCLYhndl,
		     HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT));

    me->text = HText_new(anchor);
    HText_setStyle(me->text, LYstyles(HTML_XMP));
    HText_beginAppend(me->text);

    return (HTStream *) me;
}
@


1.6
log
@automatic merge of lynx-current
@
text
@d33 1
a33 1
int HTPlain_lastraw = -1;
d667 1
a667 1
const HTStreamClass HTPlain =
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 8
a9 8
**		=================
**
**	This version of the stream object just writes to a socket.
**	The socket is assumed open and left open.
**
**	Bugs:
**		strings written must be less than buffer size.
*/
d12 1
a12 1
#include <LYCharVals.h>  /* S/390 -- gil -- 0288 */
d34 1
a34 1
static int HTPlain_bs_pending = 0; /* 1:bs 2:underline 3:underline+bs - kw */
d37 2
a38 2
**		-----------
*/
d40 2
a41 2
    const HTStreamClass *	isa;
    HText *			text;
d43 4
a46 4
    **	The node_anchor UCInfo and handle for the input (PARSER) stage. - FM
    */
    LYUCcharset		*	inUCI;
    int				inUCLYhndl;
d48 3
a50 3
    **	The node_anchor UCInfo and handle for the output (HTEXT) stage. - FM
    */
    LYUCcharset	*		outUCI;
d53 6
a58 6
    **	Counter, value, buffer and pointer for UTF-8 handling. - FM
    */
    char			utf_count;
    UCode_t			utf_char;
    char			utf_buf[8];
    char *			utf_buf_p;
d60 3
a62 3
    **	The charset transformation structure. - FM
    */
    UCTransParams		T;
d65 1
a65 1
static char replace_buf [64];	      /* buffer for replacement strings */
d67 1
a67 3
static void HTPlain_getChartransInfo (
	HTStream *		me,
	HTParentAnchor *	anchor)
d71 1
a71 1
					 UCT_SETBY_PARSER);
d76 1
d91 2
a92 2
**	----------------------------------
*/
d95 3
a97 3
**
**			A C T I O N	R O U T I N E S
*/
d99 2
a100 4
static void HTPlain_write (
	HTStream *		me,
	const char *		s,
	int			l);
d103 3
a105 5
**	------------------
*/
static void HTPlain_put_character (
	HTStream *		me,
	char			c)
d109 2
a110 2
    **	Throw away \r's.
    */
d112 1
a112 1
       HText_appendCharacter(me->text, c);
d116 5
a120 6
    **	See HTPlain_write() for explanations of the following code
    **	(we've been called via HTPlain_put_string() to do for each
    **	character of a terminated string what HTPlain_write() does
    **	via a while loop for each character in a stream of given
    **	length). - FM
    */
d132 1
a132 1
    } else if (TOASCII(UCH(c)) >= 127) {  /* S/390 -- gil -- 0305 */
d134 2
a135 3
	**  For now, don't repeat everything here
	**  that has been done below - KW
	*/
d142 1
a142 1
    } else if (UCH(c) == CH_NBSP) { /* S/390 -- gil -- 0341 */
d154 2
a155 2
	    const char * name;
	    UCode_t value = (UCode_t)FROMASCII((TOASCII(UCH(c)) - 160));
d158 1
a158 1
	    len =  strlen(name);
d160 2
a161 2
		high > low;
		diff < 0 ? (low = i+1) : (high = i)) {
d163 1
a163 1
		i = (low + (high-low)/2);
a180 1

d182 4
a185 4
**	---------------
**
*/
static void HTPlain_put_string (HTStream *  me, const char*  s)
d190 1
a190 1
    const char * p;
a199 1

d201 4
a204 4
**	Entry function for displayed text/plain and WWW_SOURCE strings. - FM
**	---------------------------------------------------------------
*/
static void HTPlain_write (HTStream * me, const char* s, int l)
d206 2
a207 2
    const char * p;
    const char * e = s+l;
d217 2
a218 2
	**  Append the whole string, but remove any \r's. - FM
	*/
d238 4
a241 4
		if (!HTPlain_bs_pending) {
		    HTPlain_bs_pending = 2;
		    HTPlain_lastraw = UCH(*p);
		    continue;
d243 4
a246 4
		} else if (HTPlain_bs_pending != 2) {
		    HTPlain_bs_pending--; /* 1 -> 0, 3 -> 2 */
		    HTPlain_lastraw = UCH(*p);
		    continue;
d248 1
a248 1
		}
d252 4
a255 5
	**  Try to handle lone LFs, CRLFs and lone CRs
	**  as newline, and to deal with control, ASCII,
	**  and 8-bit characters based on best guesses
	**  of what's appropriate. - FM
	*/
d271 1
a271 1
	    continue;	/* ignore last two of "X\bX" or "X\b_" - kw */
d278 1
a278 1
				/* ignore first two of "_\bX" - kw */
d294 3
a296 3
	**  Make sure the character is handled as Unicode
	**  whenever that's appropriate.  - FM
	*/
d299 1
a299 1
	code = (UCode_t)c_unsign;
d302 3
a304 3
	**  Combine any UTF-8 multibytes into Unicode
	**  to check for special characters. - FM
	*/
d307 4
a310 5
	    **	Combine UTF-8 into Unicode.
	    **	Incomplete characters silently ignored.
	    **	from Linux kernel's console.c - KW
	    */
	    if (TOASCII(c_unsign) > 127) {  /* S/390 -- gil -- 0371 */
d312 2
a313 2
		**  We have an octet from a multibyte character. - FM
		*/
d316 3
a318 4
		    **	Adjust the UCode_t value, add the octet
		    **	to the buffer, and decrement the byte
		    **	count. - FM
		    */
d325 2
a326 2
			**  Got a complete multibyte character.
			*/
d330 1
a330 1
			    c = FROMASCII((char)code);
d335 2
a336 2
			**  Get the next byte. - FM
			*/
d341 2
a342 2
		    **	Start handling a new multibyte character. - FM
		    */
d362 1
a362 1
			 *  We got garbage, so ignore it. - FM
d369 2
a370 2
		    **	Get the next byte. - FM
		    */
d375 4
a378 5
		**  Got an ASCII character when expecting
		**  UTF-8 multibytes, so ignore the buffered
		**  multibye characters and fall through with
		**  the current ASCII character. - FM
		*/
d382 1
a382 1
		code = (UCode_t)c_unsign;
d385 3
a387 4
		**  Got a valid ASCII character, so fall
		**  through with it. - FM
		*/
		code = (UCode_t)c_unsign;
d391 3
a393 3
	**  Convert characters from non-UTF-8 charsets
	**  to Unicode (if appropriate). - FM
	*/
d400 9
a408 9
	if (me->T.trans_to_uni &&
	    (TOASCII(code) >= LYlowest_eightbit[me->inUCLYhndl] ||  /* S/390 -- gil -- 0389 */
	     (code < ' ' && code != 0 &&
	     me->T.trans_C0_to_uni))) {
		/*
		**  Convert the octet to Unicode. - FM
		*/
	    code = (UCode_t)UCTransToUni(c, me->inUCLYhndl);
	    if (code > 0) {
d410 2
a411 2
		if (code < 256) {
			c = FROMASCII((char)code);
d413 1
a414 1
	    }
d418 3
a420 3
		**  Quote from SGML.c:
		**	"This else if may be too ugly to keep. - KW"
		*/
d427 1
a427 1
			c = FROMASCII((char)code);
d456 1
a456 1
		} /*  Next line end of ugly stuff for C0. - KW */
d463 4
a466 4
	**  At this point we have either code in Unicode
	**  (and c in latin1 if code is in the latin1 range),
	**  or code and c will have to be passed raw.
	*/
d469 4
a472 4
	**  If CJK mode is on, we'll assume the document matches
	**  the user's display character set, and if not, the
	**  user should toggle off raw/CJK mode to reload. - FM
	*/
d481 6
a486 6
	/*
	**  If HTPassHighCtrlRaw is set (e.g., for KOI8-R) assume the
	**  document matches and pass 127-160 8-bit characters.  If it
	**  doesn't match, the user should toggle raw/CJK mode off. - FM
	*/
	} else if (TOASCII(code) >= 127 && TOASCII(code) < 161 &&  /* S/390 -- gil -- 0427 */
d491 4
a494 4
	/*
	**  If neither HTPassHighCtrlRaw nor CJK is set, play it safe
	**  and treat 160 (nbsp) as an ASCII space (32). - FM
	*/
d497 9
a505 8
	/*
	**  If neither HTPassHighCtrlRaw nor CJK is set, play it safe
	**  and ignore 173 (shy). - FM
	**  Now only ignore it for color style, which doesn't handle it anyway.
	**  Otherwise pass it on as LY_SOFT_HYPHEN and let HText deal with it.
	**  It should be either ignored, or displayed as a hyphen if it was
	**  indeed at the end of a line.  Well it should. - kw
	*/
d511 3
a513 3
	/*
	**  If we get to here, pass the displayable ASCII characters. - FM
	*/
d519 3
a521 3
	/*
	**  Use an ASCII space (32) for ensp, emsp or thinsp. - FM
	*/
d524 3
a526 3
	/*
	**  If we want the raw character, pass it now. - FM
	*/
d530 1
a530 1
 *   I. LATIN-1 OR UCS2  TO  DISPLAY CHARSET
d534 1
a534 1
					 me->outUCLYhndl)) >= ' ' &&  /* S/390 -- gil -- 0464 */
d537 2
a538 2
			uck, FROMASCII((char)uck)));
	    HText_appendCharacter(me->text, ((char)(uck & 0xff)));
d541 4
a544 4
		    (me->T.repl_translated_C0 && uck > 0 && uck < ' ')) &&  /* S/390 -- gil -- 0481 */
		   /*
		   **  Not found; look for replacement string.
		   */
d548 3
a550 3
	    **	No further tests for valididy - assume that whoever
	    **	defined replacement strings knew what she was doing.
	    */
a551 5
	/*
	**  If we get to here, and should have translated,
	**  translation has failed so far.
	*/
	} else if (chk && TOASCII(code) > 127 && me->T.output_utf8) {  /* S/390 -- gil -- 0498 */
d553 7
a559 2
	    **	We want UTF-8 output, so do it now. - FM
	    */
d568 3
a570 2
		**  Out of luck, so use the UHHH notation (ugh). - gil
		*/  /* S/390 -- gil -- 0517 */
d579 3
a581 4
	    **	KOI special: strip high bit, gives
	    **	(somewhat) readable ASCII.
	    */
	    HText_appendCharacter(me->text, (char)(*p & 0x7f));
d584 3
a586 3
	    **  If we don't actually want the character,
	    **  make it safe and output that now. - FM
	    */
d588 2
a589 2
		      (int) c_unsign < LYlowest_eightbit[me->outUCLYhndl]) ||
		      (me->T.trans_from_uni && !HTPassEightBitRaw)) {
d591 5
a595 5
	    **	If we do not have the "7-bit approximations" as our
	    **	output character set (in which case we did it already)
	    **	seek a translation for that.  Otherwise, or if the
	    **	translation fails, use UHHH notation. - FM
	    */
d597 8
a604 8
			UCGetLYhndl_byMIME("us-ascii"))) &&
		   (uck = UCTransUniChar(code,
					 UCGetLYhndl_byMIME("us-ascii")))
				      >= ' ' && TOASCII(uck) < 127) {  /* S/390 -- gil -- 0535 */
		/*
		**  Got an ASCII character (yippey). - FM
		*/
		c = FROMASCII((char)uck);
d612 2
a613 2
		**  Got a repacement string (yippey). - FM
		*/
d617 2
a618 2
		**	Ignore 8204 (zwnj) or 8205 (zwj), if we get to here. - FM
		*/
d622 2
a623 2
		**	Ignore 8206 (lrm) or 8207 (rlm), if we get to here. - FM
		*/
d627 10
a636 11
		**  Out of luck, so use the UHHH notation (ugh). - FM
		*/
			/* do not print UHHH for now
			sprintf(replace_buf, "U%.2lX", code);
			HText_appendText(me->text, replace_buf);
			*/
		}
		/*
		**  If we get to here and have a monobyte character,
		**  pass it. - FM
		*/
d645 6
a650 7
**	-------------------
**
**	Note that the SGML parsing context is freed, but the created object is
**	not, as it takes on an existence of its own unless explicitly freed.
*/
static void HTPlain_free (
	HTStream *	me)
d659 1
a659 3
static void HTPlain_abort (
	HTStream *	me,
	HTError	e GCC_UNUSED)
d665 2
a666 2
**		-----------------------
*/
d669 4
a672 4
	"PlainPresenter",
	HTPlain_free,
	HTPlain_abort,
	HTPlain_put_character,	HTPlain_put_string, HTPlain_write,
d676 4
a679 6
**		----------
*/
HTStream* HTPlainPresent (
	HTPresentation *	pres GCC_UNUSED,
	HTParentAnchor *	anchor,
	HTStream *		sink GCC_UNUSED)
d682 2
a683 1
    HTStream* me = (HTStream*)malloc(sizeof(*me));
d692 1
a692 1
    me->utf_buf[0] = me->utf_buf[6] =me->utf_buf[7] = '\0';
d694 2
a695 2
    me->outUCLYhndl = HTAnchor_getUCLYhndl(anchor,UCT_STAGE_HTEXT);
    me->inUCLYhndl = HTAnchor_getUCLYhndl(anchor,UCT_STAGE_PARSER);
d700 1
a700 1
		     HTAnchor_getUCInfoStage(anchor,UCT_STAGE_HTEXT));
d703 1
a703 1
    HText_setStyle(me->text, LYstyles(HTML_XMP) );
d706 1
a706 1
    return (HTStream*) me;
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d33 2
a34 2
PUBLIC int HTPlain_lastraw = -1;
PRIVATE int HTPlain_bs_pending = 0; /* 1:bs 2:underline 3:underline+bs - kw */
d40 1
a40 1
    CONST HTStreamClass *	isa;
d65 1
a65 1
PRIVATE char replace_buf [64];	      /* buffer for replacement strings */
d67 3
a69 3
PRIVATE void HTPlain_getChartransInfo ARGS2(
	HTStream *,		me,
	HTParentAnchor *,	anchor)
d100 1
a100 1
PRIVATE void HTPlain_write PARAMS((
d102 2
a103 2
	CONST char *		s,
	int			l));
d108 3
a110 3
PRIVATE void HTPlain_put_character ARGS2(
	HTStream *,		me,
	char,			c)
d161 1
a161 1
	    CONST char * name;
d193 1
a193 1
PRIVATE void HTPlain_put_string ARGS2(HTStream *, me, CONST char*, s)
d198 1
a198 1
    CONST char * p;
d213 1
a213 1
PRIVATE void HTPlain_write ARGS3(HTStream *, me, CONST char*, s, int, l)
d215 2
a216 2
    CONST char * p;
    CONST char * e = s+l;
d664 2
a665 2
PRIVATE void HTPlain_free ARGS1(
	HTStream *,	me)
d674 3
a676 3
PRIVATE void HTPlain_abort ARGS2(
	HTStream *,	me,
	HTError,	e GCC_UNUSED)
d684 1
a684 1
PUBLIC CONST HTStreamClass HTPlain =
d695 4
a698 4
PUBLIC HTStream* HTPlainPresent ARGS3(
	HTPresentation *,	pres GCC_UNUSED,
	HTParentAnchor *,	anchor,
	HTStream *,		sink GCC_UNUSED)
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d433 1
a433 1
		**  	"This else if may be too ugly to keep. - KW"
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a32 4
extern BOOL HTPassEightBitRaw;
extern BOOL HTPassHighCtrlRaw;
extern HTCJKlang HTCJK;

d34 1
d45 2
a46 2
    LYUCcharset 	*	inUCI;
    int 			inUCLYhndl;
d131 5
a135 1
    HTPlain_lastraw = c;
d138 1
a138 1
    } else if (TOASCII((unsigned char)c) >= 127) {  /* S/390 -- gil -- 0305 */
d146 1
a146 1
    } else if (TOASCII((unsigned char)c) >= 127 && TOASCII((unsigned char)c) < 161 &&
d149 1
a149 1
    } else if ((unsigned char)c == CH_NBSP) { /* S/390 -- gil -- 0341 */
d151 1
a151 1
    } else if ((unsigned char)c == CH_SHY) {
d153 1
a153 1
    } else if (((unsigned char)c >= ' ' && TOASCII((unsigned char)c) < 127) ||
d156 1
a156 1
    } else if (TOASCII((unsigned char)c) > 160) {
d162 1
a162 1
	    UCode_t value = (UCode_t)FROMASCII((TOASCII((unsigned char)c) - 160));
d232 28
d270 29
a298 1
	HTPlain_lastraw = *p;
d308 1
a308 1
	c_unsign = (unsigned char)c;
d343 1
a343 1
			    c_unsign = (unsigned char)c;
d409 1
a409 1
	      (unsigned char)(*p) > 127)) {
d426 1
a426 1
			c_unsign = (unsigned char)c;
d442 1
a442 1
			c_unsign = (unsigned char)c;
d460 1
a460 1
			code = (unsigned char)c;
d469 1
a469 1
		    code = (unsigned char)c;
d473 1
a473 1
		code = (unsigned char)c;
d514 4
d520 3
d545 1
a545 1
	} else if ((chk = (me->T.trans_from_uni && code >= 160)) &&
d549 2
a550 2
	    CTRACE(tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
			uck, FROMASCII((char)uck));
d588 2
a589 2
		   (unsigned char)*p >= 192 &&
		   (unsigned char)*p < 255) {
d596 5
a600 5
	   /*
	   **  If we don't actually want the character,
	   **  make it safe and output that now. - FM
	   */
	   } else if ((c_unsign > 0 &&
d609 1
a609 1
	    if ((chk = (me->outUCLYhndl !=
d617 3
a619 3
	    c = FROMASCII((char)uck);
	    HText_appendCharacter(me->text, c);
	} else if ((chk && uck == -4) &&
d632 1
a632 1
		CTRACE(tfp, "HTPlain_write: Ignoring '%ld'.\n", code);
d637 1
a637 1
		CTRACE(tfp, "HTPlain_write: Ignoring '%ld'.\n", code);
d652 2
a653 2
		HText_appendCharacter(me->text, c);
	    }
d667 2
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 8
a9 8
 *		=================
 *
 *	This version of the stream object just writes to a socket.
 *	The socket is assumed open and left open.
 *
 *	Bugs:
 *		strings written must be less than buffer size.
 */
d12 1
a12 1
#include <LYCharVals.h>		/* S/390 -- gil -- 0288 */
d33 5
a37 2
static int HTPlain_lastraw = -1;
static int HTPlain_bs_pending = 0;	/* 1:bs 2:underline 3:underline+bs - kw */
d40 2
a41 2
 *		-----------
 */
d43 2
a44 2
    const HTStreamClass *isa;
    HText *text;
d46 4
a49 4
     * The node_anchor UCInfo and handle for the input (PARSER) stage.  - FM
     */
    LYUCcharset *inUCI;
    int inUCLYhndl;
d51 3
a53 3
     * The node_anchor UCInfo and handle for the output (HTEXT) stage.  - FM
     */
    LYUCcharset *outUCI;
d56 6
a61 6
     * Counter, value, buffer and pointer for UTF-8 handling.  - FM
     */
    char utf_count;
    UCode_t utf_char;
    char utf_buf[8];
    char *utf_buf_p;
d63 3
a65 3
     * The charset transformation structure.  - FM
     */
    UCTransParams T;
d68 1
a68 1
static char replace_buf[64];	/* buffer for replacement strings */
d70 3
a72 1
static void HTPlain_getChartransInfo(HTStream *me, HTParentAnchor *anchor)
d76 1
a76 1
				 UCT_SETBY_PARSER);
a80 1

d95 2
a96 2
 *	----------------------------------
 */
d99 3
a101 3
 *
 *			A C T I O N	R O U T I N E S
 */
d103 4
a106 2
static void HTPlain_write(HTStream *me, const char *s,
			  int l);
d109 5
a113 3
 *	------------------
 */
static void HTPlain_put_character(HTStream *me, char c)
d117 2
a118 2
     * Throw away \r's.
     */
d120 1
a120 1
	HText_appendCharacter(me->text, c);
d124 6
a129 5
     * See HTPlain_write() for explanations of the following code (we've been
     * called via HTPlain_put_string() to do for each character of a terminated
     * string what HTPlain_write() does via a while loop for each character in
     * a stream of given length).  - FM
     */
d134 1
a134 5
    if (c == '\b' || c == '_' || HTPlain_bs_pending) {
	HTPlain_write(me, &c, 1);
	return;
    }
    HTPlain_lastraw = UCH(c);
d137 1
a137 1
    } else if (TOASCII(UCH(c)) >= 127) {	/* S/390 -- gil -- 0305 */
d139 3
a141 2
	 * For now, don't repeat everything here that has been done below - KW
	 */
d145 1
a145 1
    } else if (TOASCII(UCH(c)) >= 127 && TOASCII(UCH(c)) < 161 &&
d148 1
a148 1
    } else if (UCH(c) == CH_NBSP) {	/* S/390 -- gil -- 0341 */
d150 1
a150 1
    } else if (UCH(c) == CH_SHY) {
d152 1
a152 1
    } else if ((UCH(c) >= ' ' && TOASCII(UCH(c)) < 127) ||
d155 1
a155 1
    } else if (TOASCII(UCH(c)) > 160) {
d160 2
a161 2
	    const char *name;
	    UCode_t value = (UCode_t) FROMASCII((TOASCII(UCH(c)) - 160));
d164 1
a164 1
	    len = strlen(name);
d166 2
a167 2
		 high > low;
		 diff < 0 ? (low = i + 1) : (high = i)) {
d169 1
a169 1
		i = (low + (high - low) / 2);
d187 1
d189 4
a192 4
 *	---------------
 *
 */
static void HTPlain_put_string(HTStream *me, const char *s)
d197 1
a197 1
    const char *p;
d207 1
d209 4
a212 4
 *	Entry function for displayed text/plain and WWW_SOURCE strings. - FM
 *	---------------------------------------------------------------
 */
static void HTPlain_write(HTStream *me, const char *s, int l)
d214 2
a215 2
    const char *p;
    const char *e = s + l;
d225 2
a226 2
	 * Append the whole string, but remove any \r's.  - FM
	 */
a230 28
	if (*p == '\b') {
	    if (HTPlain_lastraw >= UCH(' ') &&
		HTPlain_lastraw != '\r' && HTPlain_lastraw != '\n') {
		if (!HTPlain_bs_pending) {
		    HTPlain_bs_pending = 1;
		    continue;
		} else if (HTPlain_bs_pending == 2) {
		    HTPlain_bs_pending = 3;
		    continue;
		}
	    }
	    if (HTPlain_bs_pending >= 2)
		HText_appendCharacter(me->text, '_');
	    HTPlain_bs_pending = 0;
	} else if (*p == '_') {
	    if (!HTPlain_bs_pending) {
		HTPlain_bs_pending = 2;
		HTPlain_lastraw = UCH(*p);
		continue;
#if 0
	    } else if (HTPlain_bs_pending != 2) {
		HTPlain_bs_pending--;	/* 1 -> 0, 3 -> 2 */
		HTPlain_lastraw = UCH(*p);
		continue;
#endif
	    }
	}

d232 5
a236 4
	 * Try to handle lone LFs, CRLFs and lone CRs as newline, and to deal
	 * with control, ASCII, and 8-bit characters based on best guesses of
	 * what's appropriate.  - FM
	 */
d241 1
a241 29

	if (HTPlain_bs_pending &&
	    !(UCH(*p) >= ' ' && *p != '\r' && *p != '\n' &&
	      (HTPlain_lastraw == UCH(*p) ||
	       HTPlain_lastraw == UCH('_') ||
	       *p == '_'))) {
	    if (HTPlain_bs_pending >= 2)
		HText_appendCharacter(me->text, '_');
	    HTPlain_bs_pending = 0;
	} else if (HTPlain_bs_pending == 1) {
	    HTPlain_bs_pending = 0;
	    continue;		/* ignore last two of "X\bX" or "X\b_" - kw */
	} else if (HTPlain_bs_pending == 3) {
	    if (*p == '_') {
		HTPlain_bs_pending = 2;
		continue;	/* ignore last two of "_\b_" - kw */
	    } else {
		HTPlain_bs_pending = 0;
		/* ignore first two of "_\bX" - kw */
	    }
	} else if (HTPlain_bs_pending == 2) {
	    HText_appendCharacter(me->text, '_');
	    if (*p == '_')
		continue;	/* keep second of "__" pending - kw */
	    HTPlain_bs_pending = 0;
	} else {
	    HTPlain_bs_pending = 0;
	}
	HTPlain_lastraw = UCH(*p);
d247 3
a249 3
	 * Make sure the character is handled as Unicode whenever that's
	 * appropriate.  - FM
	 */
d251 2
a252 2
	c_unsign = UCH(c);
	code = (UCode_t) c_unsign;
d255 3
a257 3
	 * Combine any UTF-8 multibytes into Unicode to check for special
	 * characters.  - FM
	 */
d260 5
a264 4
	     * Combine UTF-8 into Unicode.  Incomplete characters silently
	     * ignored.  from Linux kernel's console.c - KW
	     */
	    if (TOASCII(c_unsign) > 127) {	/* S/390 -- gil -- 0371 */
d266 2
a267 2
		 * We have an octet from a multibyte character.  - FM
		 */
d270 4
a273 3
		     * Adjust the UCode_t value, add the octet to the buffer,
		     * and decrement the byte count.  - FM
		     */
d280 2
a281 2
			 * Got a complete multibyte character.
			 */
d285 2
a286 2
			    c = FROMASCII((char) code);
			    c_unsign = UCH(c);
d290 2
a291 2
			 * Get the next byte.  - FM
			 */
d296 2
a297 2
		     * Start handling a new multibyte character.  - FM
		     */
d317 1
a317 1
			 * We got garbage, so ignore it.  - FM
d324 2
a325 2
		     * Get the next byte.  - FM
		     */
d330 5
a334 4
		 * Got an ASCII character when expecting UTF-8 multibytes, so
		 * ignore the buffered multibye characters and fall through
		 * with the current ASCII character.  - FM
		 */
d338 1
a338 1
		code = (UCode_t) c_unsign;
d341 4
a344 3
		 * Got a valid ASCII character, so fall through with it.  - FM
		 */
		code = (UCode_t) c_unsign;
d348 3
a350 3
	 * Convert characters from non-UTF-8 charsets to Unicode (if
	 * appropriate).  - FM
	 */
d352 1
a352 1
	      UCH(*p) > 127)) {
d357 9
a365 9
	    if (me->T.trans_to_uni &&
		(TOASCII(code) >= LYlowest_eightbit[me->inUCLYhndl] ||	/* S/390 -- gil -- 0389 */
		 (code < ' ' && code != 0 &&
		  me->T.trans_C0_to_uni))) {
		/*
		 * Convert the octet to Unicode.  - FM
		 */
		code = (UCode_t) UCTransToUni(c, me->inUCLYhndl);
		if (code > 0) {
d367 3
a369 4
		    if (code < 256) {
			c = FROMASCII((char) code);
			c_unsign = UCH(c);
		    }
d371 1
d375 3
a377 3
		 * Quote from SGML.c:
		 * "This else if may be too ugly to keep.  - KW"
		 */
d384 2
a385 2
			c = FROMASCII((char) code);
			c_unsign = UCH(c);
d403 1
a403 1
			code = UCH(c);
d412 2
a413 2
		    code = UCH(c);
		}		/*  Next line end of ugly stuff for C0. - KW */
d416 1
a416 1
		code = UCH(c);
d420 4
a423 4
	 * At this point we have either code in Unicode (and c in latin1 if
	 * code is in the latin1 range), or code and c will have to be passed
	 * raw.
	 */
d426 4
a429 4
	 * If CJK mode is on, we'll assume the document matches the user's
	 * display character set, and if not, the user should toggle off
	 * raw/CJK mode to reload.  - FM
	 */
d438 6
a443 6
	    /*
	     * If HTPassHighCtrlRaw is set (e.g., for KOI8-R) assume the
	     * document matches and pass 127-160 8-bit characters.  If it
	     * doesn't match, the user should toggle raw/CJK mode off.  - FM
	     */
	} else if (TOASCII(code) >= 127 && TOASCII(code) < 161 &&	/* S/390 -- gil -- 0427 */
d448 4
a451 4
	    /*
	     * If neither HTPassHighCtrlRaw nor CJK is set, play it safe and
	     * treat 160 (nbsp) as an ASCII space (32).  - FM
	     */
d454 4
a457 9
	    /*
	     * If neither HTPassHighCtrlRaw nor CJK is set, play it safe and
	     * ignore 173 (shy).  - FM
	     * Now only ignore it for color style, which doesn't handle it
	     * anyway.  Otherwise pass it on as LY_SOFT_HYPHEN and let HText
	     * deal with it.  It should be either ignored, or displayed as a
	     * hyphen if it was indeed at the end of a line.  Well it should. 
	     * - kw
	     */
a458 3
#ifndef USE_COLOR_STYLE
	    HText_appendCharacter(me->text, LY_SOFT_HYPHEN);
#endif
d460 3
a462 3
	    /*
	     * If we get to here, pass the displayable ASCII characters.  - FM
	     */
d468 3
a470 3
	    /*
	     * Use an ASCII space (32) for ensp, emsp or thinsp.  - FM
	     */
d473 3
a475 3
	    /*
	     * If we want the raw character, pass it now.  - FM
	     */
d479 1
a479 1
 * I.  LATIN-1 OR UCS2 TO DISPLAY CHARSET
d481 1
a481 1
	} else if ((chk = (BOOL) (me->T.trans_from_uni && code >= 160)) &&
d483 1
a483 1
					 me->outUCLYhndl)) >= ' ' &&	/* S/390 -- gil -- 0464 */
d485 3
a487 3
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
		    uck, FROMASCII((char) uck)));
	    HText_appendCharacter(me->text, ((char) (uck & 0xff)));
d490 4
a493 4
		    (me->T.repl_translated_C0 && uck > 0 && uck < ' ')) &&	/* S/390 -- gil -- 0481 */
	    /*
	     * Not found; look for replacement string.
	     */
d497 3
a499 3
	     * No further tests for valididy - assume that whoever defined
	     * replacement strings knew what she was doing.
	     */
d501 5
d507 2
a508 7
	     * If we get to here, and should have translated, translation has
	     * failed so far.
	     */
	} else if (chk && TOASCII(code) > 127 && me->T.output_utf8) {	/* S/390 -- gil -- 0498 */
	    /*
	     * We want UTF-8 output, so do it now.  - FM
	     */
d517 2
a518 3
		 * Out of luck, so use the UHHH notation (ugh).  - gil
		 */
		/* S/390 -- gil -- 0517 */
d524 2
a525 2
		   UCH(*p) >= 192 &&
		   UCH(*p) < 255) {
d527 4
a530 3
	     * KOI special:  strip high bit, gives (somewhat) readable ASCII.
	     */
	    HText_appendCharacter(me->text, (char) (*p & 0x7f));
d532 24
a555 24
	    /*
	     * If we don't actually want the character, make it safe and output
	     * that now.  - FM
	     */
	} else if ((c_unsign > 0 &&
		    (int) c_unsign < LYlowest_eightbit[me->outUCLYhndl]) ||
		   (me->T.trans_from_uni && !HTPassEightBitRaw)) {
	    /*
	     * If we do not have the "7-bit approximations" as our output
	     * character set (in which case we did it already) seek a
	     * translation for that.  Otherwise, or if the translation fails,
	     * use UHHH notation.  - FM
	     */
	    if ((chk = (BOOL) (me->outUCLYhndl !=
			       UCGetLYhndl_byMIME("us-ascii"))) &&
		(uck = UCTransUniChar(code,
				      UCGetLYhndl_byMIME("us-ascii")))
		>= ' ' && TOASCII(uck) < 127) {		/* S/390 -- gil -- 0535 */
		/*
		 * Got an ASCII character (yippey).  - FM
		 */
		c = FROMASCII((char) uck);
		HText_appendCharacter(me->text, c);
	    } else if ((chk && uck == -4) &&
d561 2
a562 2
		 * Got a repacement string (yippey).  - FM
		 */
d566 3
a568 3
		 * Ignore 8204 (zwnj) or 8205 (zwj), if we get to here.  - FM
		 */
		CTRACE((tfp, "HTPlain_write: Ignoring '%ld'.\n", code));
d571 3
a573 3
		 * Ignore 8206 (lrm) or 8207 (rlm), if we get to here.  - FM
		 */
		CTRACE((tfp, "HTPlain_write: Ignoring '%ld'.\n", code));
d576 13
a588 6
		 * Out of luck, so use the UHHH notation (ugh).  - FM
		 */
		/* do not print UHHH for now
		   sprintf(replace_buf, "U%.2lX", code);
		   HText_appendText(me->text, replace_buf);
		 */
a589 6
	    /*
	     * If we get to here and have a monobyte character, pass it.  - FM
	     */
	} else if (c_unsign != 0 && c_unsign < 256) {
	    HText_appendCharacter(me->text, c);
	}
d595 7
a601 6
 *	-------------------
 *
 *	Note that the SGML parsing context is freed, but the created object is
 *	not, as it takes on an existence of its own unless explicitly freed.
 */
static void HTPlain_free(HTStream *me)
a602 2
    if (HTPlain_bs_pending >= 2)
	HText_appendCharacter(me->text, '_');
d608 3
a610 1
static void HTPlain_abort(HTStream *me, HTError e GCC_UNUSED)
d616 3
a618 3
 *		-----------------------
 */
static const HTStreamClass HTPlain =
d620 4
a623 4
    "PlainPresenter",
    HTPlain_free,
    HTPlain_abort,
    HTPlain_put_character, HTPlain_put_string, HTPlain_write,
d627 6
a632 4
 *		----------
 */
HTStream *HTPlainPresent(HTPresentation *pres GCC_UNUSED, HTParentAnchor *anchor,
			 HTStream *sink GCC_UNUSED)
d635 1
a635 2
    HTStream *me = (HTStream *) malloc(sizeof(*me));

d644 1
a644 1
    me->utf_buf[0] = me->utf_buf[6] = me->utf_buf[7] = '\0';
d646 2
a647 2
    me->outUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
    me->inUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
d652 1
a652 1
		     HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT));
d655 1
a655 1
    HText_setStyle(me->text, LYstyles(HTML_XMP));
d658 1
a658 1
    return (HTStream *) me;
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d33 4
a37 1
PRIVATE int HTPlain_bs_pending = 0; /* 1:bs 2:underline 3:underline+bs - kw */
d48 2
a49 2
    LYUCcharset		*	inUCI;
    int				inUCLYhndl;
d134 1
a134 5
    if (c == '\b' || c == '_' || HTPlain_bs_pending) {
	HTPlain_write(me, &c, 1);
	return;
    }
    HTPlain_lastraw = UCH(c);
d137 1
a137 1
    } else if (TOASCII(UCH(c)) >= 127) {  /* S/390 -- gil -- 0305 */
d145 1
a145 1
    } else if (TOASCII(UCH(c)) >= 127 && TOASCII(UCH(c)) < 161 &&
d148 1
a148 1
    } else if (UCH(c) == CH_NBSP) { /* S/390 -- gil -- 0341 */
d150 1
a150 1
    } else if (UCH(c) == CH_SHY) {
d152 1
a152 1
    } else if ((UCH(c) >= ' ' && TOASCII(UCH(c)) < 127) ||
d155 1
a155 1
    } else if (TOASCII(UCH(c)) > 160) {
d161 1
a161 1
	    UCode_t value = (UCode_t)FROMASCII((TOASCII(UCH(c)) - 160));
a230 28
	if (*p == '\b') {
	    if (HTPlain_lastraw >= UCH(' ') &&
		HTPlain_lastraw != '\r' && HTPlain_lastraw != '\n') {
		if (!HTPlain_bs_pending) {
		    HTPlain_bs_pending = 1;
		    continue;
		} else if (HTPlain_bs_pending == 2) {
		    HTPlain_bs_pending = 3;
		    continue;
		}
	    }
	    if (HTPlain_bs_pending >= 2)
		HText_appendCharacter(me->text, '_');
	    HTPlain_bs_pending = 0;
	} else if (*p == '_') {
		if (!HTPlain_bs_pending) {
		    HTPlain_bs_pending = 2;
		    HTPlain_lastraw = UCH(*p);
		    continue;
#if 0
		} else if (HTPlain_bs_pending != 2) {
		    HTPlain_bs_pending--; /* 1 -> 0, 3 -> 2 */
		    HTPlain_lastraw = UCH(*p);
		    continue;
#endif
		}
	}

d241 1
a241 29

	if (HTPlain_bs_pending &&
	    !(UCH(*p) >= ' ' && *p != '\r' && *p != '\n' &&
	      (HTPlain_lastraw == UCH(*p) ||
	       HTPlain_lastraw == UCH('_') ||
	       *p == '_'))) {
	    if (HTPlain_bs_pending >= 2)
		HText_appendCharacter(me->text, '_');
	    HTPlain_bs_pending = 0;
	} else if (HTPlain_bs_pending == 1) {
	    HTPlain_bs_pending = 0;
	    continue;	/* ignore last two of "X\bX" or "X\b_" - kw */
	} else if (HTPlain_bs_pending == 3) {
	    if (*p == '_') {
		HTPlain_bs_pending = 2;
		continue;	/* ignore last two of "_\b_" - kw */
	    } else {
		HTPlain_bs_pending = 0;
				/* ignore first two of "_\bX" - kw */
	    }
	} else if (HTPlain_bs_pending == 2) {
	    HText_appendCharacter(me->text, '_');
	    if (*p == '_')
		continue;	/* keep second of "__" pending - kw */
	    HTPlain_bs_pending = 0;
	} else {
	    HTPlain_bs_pending = 0;
	}
	HTPlain_lastraw = UCH(*p);
d251 1
a251 1
	c_unsign = UCH(c);
d286 1
a286 1
			    c_unsign = UCH(c);
d352 1
a352 1
	      UCH(*p) > 127)) {
d369 1
a369 1
			c_unsign = UCH(c);
d385 1
a385 1
			c_unsign = UCH(c);
d403 1
a403 1
			code = UCH(c);
d412 1
a412 1
		    code = UCH(c);
d416 1
a416 1
		code = UCH(c);
a456 4
	**  Now only ignore it for color style, which doesn't handle it anyway.
	**  Otherwise pass it on as LY_SOFT_HYPHEN and let HText deal with it.
	**  It should be either ignored, or displayed as a hyphen if it was
	**  indeed at the end of a line.  Well it should. - kw
a458 3
#ifndef USE_COLOR_STYLE
	    HText_appendCharacter(me->text, LY_SOFT_HYPHEN);
#endif
d481 1
a481 1
	} else if ((chk = (BOOL) (me->T.trans_from_uni && code >= 160)) &&
d485 2
a486 2
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
			uck, FROMASCII((char)uck)));
d524 2
a525 2
		   UCH(*p) >= 192 &&
		   UCH(*p) < 255) {
d532 5
a536 5
	    /*
	    **  If we don't actually want the character,
	    **  make it safe and output that now. - FM
	    */
	} else if ((c_unsign > 0 &&
d545 1
a545 1
	    if ((chk = (BOOL) (me->outUCLYhndl !=
d553 3
a555 3
		c = FROMASCII((char)uck);
		HText_appendCharacter(me->text, c);
	    } else if ((chk && uck == -4) &&
d568 1
a568 1
		CTRACE((tfp, "HTPlain_write: Ignoring '%ld'.\n", code));
d573 1
a573 1
		CTRACE((tfp, "HTPlain_write: Ignoring '%ld'.\n", code));
d588 2
a589 2
	    HText_appendCharacter(me->text, c);
	}
a602 2
    if (HTPlain_bs_pending >= 2)
	HText_appendCharacter(me->text, '_');
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d433 1
a433 1
		**	"This else if may be too ugly to keep. - KW"
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d33 2
a34 2
int HTPlain_lastraw = -1;
static int HTPlain_bs_pending = 0; /* 1:bs 2:underline 3:underline+bs - kw */
d40 1
a40 1
    const HTStreamClass *	isa;
d65 1
a65 1
static char replace_buf [64];	      /* buffer for replacement strings */
d67 3
a69 3
static void HTPlain_getChartransInfo (
	HTStream *		me,
	HTParentAnchor *	anchor)
d100 1
a100 1
static void HTPlain_write (
d102 2
a103 2
	const char *		s,
	int			l);
d108 3
a110 3
static void HTPlain_put_character (
	HTStream *		me,
	char			c)
d161 1
a161 1
	    const char * name;
d193 1
a193 1
static void HTPlain_put_string (HTStream *  me, const char*  s)
d198 1
a198 1
    const char * p;
d213 1
a213 1
static void HTPlain_write (HTStream * me, const char* s, int l)
d215 2
a216 2
    const char * p;
    const char * e = s+l;
d664 2
a665 2
static void HTPlain_free (
	HTStream *	me)
d674 3
a676 3
static void HTPlain_abort (
	HTStream *	me,
	HTError	e GCC_UNUSED)
d684 1
a684 1
const HTStreamClass HTPlain =
d695 4
a698 4
HTStream* HTPlainPresent (
	HTPresentation *	pres GCC_UNUSED,
	HTParentAnchor *	anchor,
	HTStream *		sink GCC_UNUSED)
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 8
a9 8
 *		=================
 *
 *	This version of the stream object just writes to a socket.
 *	The socket is assumed open and left open.
 *
 *	Bugs:
 *		strings written must be less than buffer size.
 */
d12 1
a12 1
#include <LYCharVals.h>		/* S/390 -- gil -- 0288 */
d34 1
a34 1
static int HTPlain_bs_pending = 0;	/* 1:bs 2:underline 3:underline+bs - kw */
d37 2
a38 2
 *		-----------
 */
d40 2
a41 2
    const HTStreamClass *isa;
    HText *text;
d43 4
a46 4
     * The node_anchor UCInfo and handle for the input (PARSER) stage.  - FM
     */
    LYUCcharset *inUCI;
    int inUCLYhndl;
d48 3
a50 3
     * The node_anchor UCInfo and handle for the output (HTEXT) stage.  - FM
     */
    LYUCcharset *outUCI;
d53 6
a58 6
     * Counter, value, buffer and pointer for UTF-8 handling.  - FM
     */
    char utf_count;
    UCode_t utf_char;
    char utf_buf[8];
    char *utf_buf_p;
d60 3
a62 3
     * The charset transformation structure.  - FM
     */
    UCTransParams T;
d65 1
a65 1
static char replace_buf[64];	/* buffer for replacement strings */
d67 3
a69 1
static void HTPlain_getChartransInfo(HTStream *me, HTParentAnchor *anchor)
d73 1
a73 1
				 UCT_SETBY_PARSER);
a77 1

d92 2
a93 2
 *	----------------------------------
 */
d96 3
a98 3
 *
 *			A C T I O N	R O U T I N E S
 */
d100 4
a103 2
static void HTPlain_write(HTStream *me, const char *s,
			  int l);
d106 5
a110 3
 *	------------------
 */
static void HTPlain_put_character(HTStream *me, char c)
d114 2
a115 2
     * Throw away \r's.
     */
d117 1
a117 1
	HText_appendCharacter(me->text, c);
d121 6
a126 5
     * See HTPlain_write() for explanations of the following code (we've been
     * called via HTPlain_put_string() to do for each character of a terminated
     * string what HTPlain_write() does via a while loop for each character in
     * a stream of given length).  - FM
     */
d138 1
a138 1
    } else if (TOASCII(UCH(c)) >= 127) {	/* S/390 -- gil -- 0305 */
d140 3
a142 2
	 * For now, don't repeat everything here that has been done below - KW
	 */
d149 1
a149 1
    } else if (UCH(c) == CH_NBSP) {	/* S/390 -- gil -- 0341 */
d161 2
a162 2
	    const char *name;
	    UCode_t value = (UCode_t) FROMASCII((TOASCII(UCH(c)) - 160));
d165 1
a165 1
	    len = strlen(name);
d167 2
a168 2
		 high > low;
		 diff < 0 ? (low = i + 1) : (high = i)) {
d170 1
a170 1
		i = (low + (high - low) / 2);
d188 1
d190 4
a193 4
 *	---------------
 *
 */
static void HTPlain_put_string(HTStream *me, const char *s)
d198 1
a198 1
    const char *p;
d208 1
d210 4
a213 4
 *	Entry function for displayed text/plain and WWW_SOURCE strings. - FM
 *	---------------------------------------------------------------
 */
static void HTPlain_write(HTStream *me, const char *s, int l)
d215 2
a216 2
    const char *p;
    const char *e = s + l;
d226 2
a227 2
	 * Append the whole string, but remove any \r's.  - FM
	 */
d247 4
a250 4
	    if (!HTPlain_bs_pending) {
		HTPlain_bs_pending = 2;
		HTPlain_lastraw = UCH(*p);
		continue;
d252 4
a255 4
	    } else if (HTPlain_bs_pending != 2) {
		HTPlain_bs_pending--;	/* 1 -> 0, 3 -> 2 */
		HTPlain_lastraw = UCH(*p);
		continue;
d257 1
a257 1
	    }
d261 5
a265 4
	 * Try to handle lone LFs, CRLFs and lone CRs as newline, and to deal
	 * with control, ASCII, and 8-bit characters based on best guesses of
	 * what's appropriate.  - FM
	 */
d281 1
a281 1
	    continue;		/* ignore last two of "X\bX" or "X\b_" - kw */
d288 1
a288 1
		/* ignore first two of "_\bX" - kw */
d304 3
a306 3
	 * Make sure the character is handled as Unicode whenever that's
	 * appropriate.  - FM
	 */
d309 1
a309 1
	code = (UCode_t) c_unsign;
d312 3
a314 3
	 * Combine any UTF-8 multibytes into Unicode to check for special
	 * characters.  - FM
	 */
d317 5
a321 4
	     * Combine UTF-8 into Unicode.  Incomplete characters silently
	     * ignored.  from Linux kernel's console.c - KW
	     */
	    if (TOASCII(c_unsign) > 127) {	/* S/390 -- gil -- 0371 */
d323 2
a324 2
		 * We have an octet from a multibyte character.  - FM
		 */
d327 4
a330 3
		     * Adjust the UCode_t value, add the octet to the buffer,
		     * and decrement the byte count.  - FM
		     */
d337 2
a338 2
			 * Got a complete multibyte character.
			 */
d342 1
a342 1
			    c = FROMASCII((char) code);
d347 2
a348 2
			 * Get the next byte.  - FM
			 */
d353 2
a354 2
		     * Start handling a new multibyte character.  - FM
		     */
d374 1
a374 1
			 * We got garbage, so ignore it.  - FM
d381 2
a382 2
		     * Get the next byte.  - FM
		     */
d387 5
a391 4
		 * Got an ASCII character when expecting UTF-8 multibytes, so
		 * ignore the buffered multibye characters and fall through
		 * with the current ASCII character.  - FM
		 */
d395 1
a395 1
		code = (UCode_t) c_unsign;
d398 4
a401 3
		 * Got a valid ASCII character, so fall through with it.  - FM
		 */
		code = (UCode_t) c_unsign;
d405 3
a407 3
	 * Convert characters from non-UTF-8 charsets to Unicode (if
	 * appropriate).  - FM
	 */
d414 9
a422 9
	    if (me->T.trans_to_uni &&
		(TOASCII(code) >= LYlowest_eightbit[me->inUCLYhndl] ||	/* S/390 -- gil -- 0389 */
		 (code < ' ' && code != 0 &&
		  me->T.trans_C0_to_uni))) {
		/*
		 * Convert the octet to Unicode.  - FM
		 */
		code = (UCode_t) UCTransToUni(c, me->inUCLYhndl);
		if (code > 0) {
d424 2
a425 2
		    if (code < 256) {
			c = FROMASCII((char) code);
a426 1
		    }
d428 1
d432 3
a434 3
		 * Quote from SGML.c:
		 * "This else if may be too ugly to keep.  - KW"
		 */
d441 1
a441 1
			c = FROMASCII((char) code);
d470 1
a470 1
		}		/*  Next line end of ugly stuff for C0. - KW */
d477 4
a480 4
	 * At this point we have either code in Unicode (and c in latin1 if
	 * code is in the latin1 range), or code and c will have to be passed
	 * raw.
	 */
d483 4
a486 4
	 * If CJK mode is on, we'll assume the document matches the user's
	 * display character set, and if not, the user should toggle off
	 * raw/CJK mode to reload.  - FM
	 */
d495 6
a500 6
	    /*
	     * If HTPassHighCtrlRaw is set (e.g., for KOI8-R) assume the
	     * document matches and pass 127-160 8-bit characters.  If it
	     * doesn't match, the user should toggle raw/CJK mode off.  - FM
	     */
	} else if (TOASCII(code) >= 127 && TOASCII(code) < 161 &&	/* S/390 -- gil -- 0427 */
d505 4
a508 4
	    /*
	     * If neither HTPassHighCtrlRaw nor CJK is set, play it safe and
	     * treat 160 (nbsp) as an ASCII space (32).  - FM
	     */
d511 8
a518 9
	    /*
	     * If neither HTPassHighCtrlRaw nor CJK is set, play it safe and
	     * ignore 173 (shy).  - FM
	     * Now only ignore it for color style, which doesn't handle it
	     * anyway.  Otherwise pass it on as LY_SOFT_HYPHEN and let HText
	     * deal with it.  It should be either ignored, or displayed as a
	     * hyphen if it was indeed at the end of a line.  Well it should. 
	     * - kw
	     */
d524 3
a526 3
	    /*
	     * If we get to here, pass the displayable ASCII characters.  - FM
	     */
d532 3
a534 3
	    /*
	     * Use an ASCII space (32) for ensp, emsp or thinsp.  - FM
	     */
d537 3
a539 3
	    /*
	     * If we want the raw character, pass it now.  - FM
	     */
d543 1
a543 1
 * I.  LATIN-1 OR UCS2 TO DISPLAY CHARSET
d547 1
a547 1
					 me->outUCLYhndl)) >= ' ' &&	/* S/390 -- gil -- 0464 */
d550 2
a551 2
		    uck, FROMASCII((char) uck)));
	    HText_appendCharacter(me->text, ((char) (uck & 0xff)));
d554 4
a557 4
		    (me->T.repl_translated_C0 && uck > 0 && uck < ' ')) &&	/* S/390 -- gil -- 0481 */
	    /*
	     * Not found; look for replacement string.
	     */
d561 3
a563 3
	     * No further tests for valididy - assume that whoever defined
	     * replacement strings knew what she was doing.
	     */
d565 5
d571 2
a572 7
	     * If we get to here, and should have translated, translation has
	     * failed so far.
	     */
	} else if (chk && TOASCII(code) > 127 && me->T.output_utf8) {	/* S/390 -- gil -- 0498 */
	    /*
	     * We want UTF-8 output, so do it now.  - FM
	     */
d581 2
a582 3
		 * Out of luck, so use the UHHH notation (ugh).  - gil
		 */
		/* S/390 -- gil -- 0517 */
d591 4
a594 3
	     * KOI special:  strip high bit, gives (somewhat) readable ASCII.
	     */
	    HText_appendCharacter(me->text, (char) (*p & 0x7f));
d597 3
a599 3
	     * If we don't actually want the character, make it safe and output
	     * that now.  - FM
	     */
d601 2
a602 2
		    (int) c_unsign < LYlowest_eightbit[me->outUCLYhndl]) ||
		   (me->T.trans_from_uni && !HTPassEightBitRaw)) {
d604 5
a608 5
	     * If we do not have the "7-bit approximations" as our output
	     * character set (in which case we did it already) seek a
	     * translation for that.  Otherwise, or if the translation fails,
	     * use UHHH notation.  - FM
	     */
d610 8
a617 8
			       UCGetLYhndl_byMIME("us-ascii"))) &&
		(uck = UCTransUniChar(code,
				      UCGetLYhndl_byMIME("us-ascii")))
		>= ' ' && TOASCII(uck) < 127) {		/* S/390 -- gil -- 0535 */
		/*
		 * Got an ASCII character (yippey).  - FM
		 */
		c = FROMASCII((char) uck);
d625 2
a626 2
		 * Got a repacement string (yippey).  - FM
		 */
d630 2
a631 2
		 * Ignore 8204 (zwnj) or 8205 (zwj), if we get to here.  - FM
		 */
d635 2
a636 2
		 * Ignore 8206 (lrm) or 8207 (rlm), if we get to here.  - FM
		 */
d640 11
a650 10
		 * Out of luck, so use the UHHH notation (ugh).  - FM
		 */
		/* do not print UHHH for now
		   sprintf(replace_buf, "U%.2lX", code);
		   HText_appendText(me->text, replace_buf);
		 */
	    }
	    /*
	     * If we get to here and have a monobyte character, pass it.  - FM
	     */
d659 7
a665 6
 *	-------------------
 *
 *	Note that the SGML parsing context is freed, but the created object is
 *	not, as it takes on an existence of its own unless explicitly freed.
 */
static void HTPlain_free(HTStream *me)
d674 3
a676 1
static void HTPlain_abort(HTStream *me, HTError e GCC_UNUSED)
d682 2
a683 2
 *		-----------------------
 */
d686 4
a689 4
    "PlainPresenter",
    HTPlain_free,
    HTPlain_abort,
    HTPlain_put_character, HTPlain_put_string, HTPlain_write,
d693 6
a698 4
 *		----------
 */
HTStream *HTPlainPresent(HTPresentation *pres GCC_UNUSED, HTParentAnchor *anchor,
			 HTStream *sink GCC_UNUSED)
d701 1
a701 2
    HTStream *me = (HTStream *) malloc(sizeof(*me));

d710 1
a710 1
    me->utf_buf[0] = me->utf_buf[6] = me->utf_buf[7] = '\0';
d712 2
a713 2
    me->outUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
    me->inUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
d718 1
a718 1
		     HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT));
d721 1
a721 1
    HText_setStyle(me->text, LYstyles(HTML_XMP));
d724 1
a724 1
    return (HTStream *) me;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d35 1
a37 1
PRIVATE int HTPlain_bs_pending = 0; /* 1:bs 2:underline 3:underline+bs - kw */
d48 2
a49 2
    LYUCcharset		*	inUCI;
    int				inUCLYhndl;
d134 1
a134 5
    if (c == '\b' || c == '_' || HTPlain_bs_pending) {
	HTPlain_write(me, &c, 1);
	return;
    }
    HTPlain_lastraw = UCH(c);
d137 1
a137 1
    } else if (TOASCII(UCH(c)) >= 127) {  /* S/390 -- gil -- 0305 */
d145 1
a145 1
    } else if (TOASCII(UCH(c)) >= 127 && TOASCII(UCH(c)) < 161 &&
d148 1
a148 1
    } else if (UCH(c) == CH_NBSP) { /* S/390 -- gil -- 0341 */
d150 1
a150 1
    } else if (UCH(c) == CH_SHY) {
d152 1
a152 1
    } else if ((UCH(c) >= ' ' && TOASCII(UCH(c)) < 127) ||
d155 1
a155 1
    } else if (TOASCII(UCH(c)) > 160) {
d161 1
a161 1
	    UCode_t value = (UCode_t)FROMASCII((TOASCII(UCH(c)) - 160));
a230 28
	if (*p == '\b') {
	    if (HTPlain_lastraw >= UCH(' ') &&
		HTPlain_lastraw != '\r' && HTPlain_lastraw != '\n') {
		if (!HTPlain_bs_pending) {
		    HTPlain_bs_pending = 1;
		    continue;
		} else if (HTPlain_bs_pending == 2) {
		    HTPlain_bs_pending = 3;
		    continue;
		}
	    }
	    if (HTPlain_bs_pending >= 2)
		HText_appendCharacter(me->text, '_');
	    HTPlain_bs_pending = 0;
	} else if (*p == '_') {
		if (!HTPlain_bs_pending) {
		    HTPlain_bs_pending = 2;
		    HTPlain_lastraw = UCH(*p);
		    continue;
#if 0
		} else if (HTPlain_bs_pending != 2) {
		    HTPlain_bs_pending--; /* 1 -> 0, 3 -> 2 */
		    HTPlain_lastraw = UCH(*p);
		    continue;
#endif
		}
	}

d241 1
a241 29

	if (HTPlain_bs_pending &&
	    !(UCH(*p) >= ' ' && *p != '\r' && *p != '\n' &&
	      (HTPlain_lastraw == UCH(*p) ||
	       HTPlain_lastraw == UCH('_') ||
	       *p == '_'))) {
	    if (HTPlain_bs_pending >= 2)
		HText_appendCharacter(me->text, '_');
	    HTPlain_bs_pending = 0;
	} else if (HTPlain_bs_pending == 1) {
	    HTPlain_bs_pending = 0;
	    continue;	/* ignore last two of "X\bX" or "X\b_" - kw */
	} else if (HTPlain_bs_pending == 3) {
	    if (*p == '_') {
		HTPlain_bs_pending = 2;
		continue;	/* ignore last two of "_\b_" - kw */
	    } else {
		HTPlain_bs_pending = 0;
				/* ignore first two of "_\bX" - kw */
	    }
	} else if (HTPlain_bs_pending == 2) {
	    HText_appendCharacter(me->text, '_');
	    if (*p == '_')
		continue;	/* keep second of "__" pending - kw */
	    HTPlain_bs_pending = 0;
	} else {
	    HTPlain_bs_pending = 0;
	}
	HTPlain_lastraw = UCH(*p);
d251 1
a251 1
	c_unsign = UCH(c);
d286 1
a286 1
			    c_unsign = UCH(c);
d352 1
a352 1
	      UCH(*p) > 127)) {
d369 1
a369 1
			c_unsign = UCH(c);
d385 1
a385 1
			c_unsign = UCH(c);
d403 1
a403 1
			code = UCH(c);
d412 1
a412 1
		    code = UCH(c);
d416 1
a416 1
		code = UCH(c);
a456 4
	**  Now only ignore it for color style, which doesn't handle it anyway.
	**  Otherwise pass it on as LY_SOFT_HYPHEN and let HText deal with it.
	**  It should be either ignored, or displayed as a hyphen if it was
	**  indeed at the end of a line.  Well it should. - kw
a458 3
#ifndef USE_COLOR_STYLE
	    HText_appendCharacter(me->text, LY_SOFT_HYPHEN);
#endif
d481 1
a481 1
	} else if ((chk = (BOOL) (me->T.trans_from_uni && code >= 160)) &&
d485 2
a486 2
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
			uck, FROMASCII((char)uck)));
d524 2
a525 2
		   UCH(*p) >= 192 &&
		   UCH(*p) < 255) {
d532 5
a536 5
	    /*
	    **  If we don't actually want the character,
	    **  make it safe and output that now. - FM
	    */
	} else if ((c_unsign > 0 &&
d545 1
a545 1
	    if ((chk = (BOOL) (me->outUCLYhndl !=
d553 3
a555 3
		c = FROMASCII((char)uck);
		HText_appendCharacter(me->text, c);
	    } else if ((chk && uck == -4) &&
d568 1
a568 1
		CTRACE((tfp, "HTPlain_write: Ignoring '%ld'.\n", code));
d573 1
a573 1
		CTRACE((tfp, "HTPlain_write: Ignoring '%ld'.\n", code));
d588 2
a589 2
	    HText_appendCharacter(me->text, c);
	}
a602 2
    if (HTPlain_bs_pending >= 2)
	HText_appendCharacter(me->text, '_');
@

