head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.07.15.18.16.42;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.28;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.04;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.11;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.02;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.57;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.53;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.17;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.47.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@automatic merge of lynx-current
@
text
@/*	WorldWideWeb - Wide Area Informaion Server Access	HTWAIS.c
 *	==================================================
 *
 *	This module allows a WWW server or client to read data from a
 *	remote	WAIS
 *  server, and provide that data to a WWW client in hypertext form.
 *  Source files, once retrieved, are stored and used to provide
 *  information about the index when that is acessed.
 *
 *  Authors
 *	BK	Brewster Kahle, Thinking Machines, <Brewster@@think.com>
 *	TBL	Tim Berners-Lee, CERN <timbl@@info.cern.ch>
 *	FM	Foteos Macrides, WFEB <macrides@@sci.wfeb.edu>
 *
 *  History
 *	   Sep 91	TBL adapted shell-ui.c (BK) with HTRetrieve.c from WWW.
 *	   Feb 91	TBL Generated HTML cleaned up a bit (quotes, escaping)
 *			    Refers to lists of sources.
 *	   Mar 93	TBL Lib 2.0 compatible module made.
 *	   May 94	FM  Added DIRECT_WAIS support for VMS.
 *
 *  Bugs
 *	Uses C stream i/o to read and write sockets, which won't work
 *	on VMS TCP systems.
 *
 *	Should cache connections.
 *
 *	ANSI C only as written
 *
 *  Bugs fixed
 *	NT Nathan Torkington (Nathan.Torkington@@vuw.ac.nz)
 *
 *  WAIS comments:
 *
 *	1.	Separate directories for different system's .o would help
 *	2.	Document ids are rather long!
 *
 * W WW Address mapping convention:
 *
 *	/servername/database/type/length/document-id
 *
 *	/servername/database?word+word+word
 */
/* WIDE AREA INFORMATION SERVER SOFTWARE:
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   Brewster@@think.com
*/

#include <HTUtils.h>
#include <HTParse.h>
#include <HTAccess.h>		/* We implement a protocol */
#include <HTML.h>		/* The object we will generate */
#include <HTWSRC.h>
#include <HTTCP.h>
#include <HTCJK.h>
#include <HTAlert.h>

/*			From WAIS
 *			---------
 */
#ifdef VMS
#include <HTVMS_WaisUI.h>
#include <HTVMS_WaisProt.h>
#else
#include <ui.h>
#endif /* VMS */

#define MAX_MESSAGE_LEN 100000
#define CHARS_PER_PAGE 10000	/* number of chars retrieved in each request */

#define WAISSEARCH_DATE "Fri Jul 19 1991"

/*			FROM WWW
 *			--------
 */
#include <LYUtils.h>
#include <LYLeaks.h>

#define DIRECTORY "/cnidr.org:210/directory-of-servers"
/* #define DIRECTORY "/quake.think.com:210/directory-of-servers" */

#define BIG 1024		/* identifier size limit  @@@@@@@@@@ */

#define BUFFER_SIZE 4096	/* Arbitrary size for efficiency */

#define HEX_ESCAPE '%'

static BOOL as_gate;		/* Client is using us as gateway */

static char line[2048];		/* For building strings to display */

				/* Must be able to take id */

#define PUTC(c) (*target->isa->put_character)(target, c)
#define PUTS(s) (*target->isa->put_string)(target, s)
#define START(e) (*target->isa->start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*target->isa->end_element)(target, e, 0)
#define MAYBE_END(e) if (HTML_dtd.tags[e].contents != SGML_EMPTY) \
			(*target->isa->end_element)(target, e, 0)
#define FREE_TARGET (*target->isa->_free)(target)

struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

struct _HTStream {
    const HTStreamClass *isa;
    /* ... */
};

/* ------------------------------------------------------------------------ */
/* ---------------- Local copy of connect_to_server calls ----------------- */
/* ------------------------------------------------------------------------ */
/* Returns 1 on success, 0 on fail, -1 on interrupt. */
static int fd_mosaic_connect_to_server(char *host_name,
				       long port,
				       long *fd)
{
    char *dummy = NULL;
    int status;
    int result;

    HTSprintf0(&dummy, "%s//%s:%d/", STR_WAIS_URL, host_name, port);

    status = HTDoConnect(dummy, "WAIS", 210, (int *) fd);
    if (status == HT_INTERRUPTED) {
	result = -1;
    } else if (status < 0) {
	result = 0;
    } else {
	result = 1;
    }
    FREE(dummy);
    return result;
}

/* Returns 1 on success, 0 on fail, -1 on interrupt. */
#ifdef VMS
static int mosaic_connect_to_server(char *host_name,
				    long port,
				    long *fdp)
#else
static int mosaic_connect_to_server(char *host_name,
				    long port,
				    FILE **fp)
#endif				/* VMS */
{
#ifndef VMS
    FILE *file;
#endif /* VMS */
    long fd;
    int rv;

    rv = fd_mosaic_connect_to_server(host_name, port, &fd);
    if (rv == 0) {
	HTAlert(gettext("Could not connect to WAIS server."));
	return 0;
    } else if (rv == -1) {
	HTAlert(CONNECTION_INTERRUPTED);
	return -1;
    }
#ifndef VMS
    if ((file = fdopen(fd, "r+")) == NULL) {
	HTAlert(gettext("Could not open WAIS connection for reading."));
	return 0;
    }

    *fp = file;
#else
    *fdp = fd;
#endif /* VMS */
    return 1;
}
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */

/*								showDiags
*/
/* modified from Jonny G's version in ui/question.c */
static void showDiags(HTStream *target, diagnosticRecord ** d)
{
    long i;

    for (i = 0; d[i] != NULL; i++) {
	if (d[i]->ADDINFO != NULL) {
	    PUTS(gettext("Diagnostic code is "));
	    PUTS(d[i]->DIAG);
	    PUTC(' ');
	    PUTS(d[i]->ADDINFO);
	    PUTC('\n');
	}
    }
}

/*	Matrix of allowed characters in filenames
 *	-----------------------------------------
 */

static BOOL acceptable[256];
static BOOL acceptable_inited = NO;

static void init_acceptable(void)
{
    unsigned int i;
    char *good =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";

    for (i = 0; i < 256; i++)
	acceptable[i] = NO;
    for (; *good; good++)
	acceptable[(unsigned int) *good] = YES;
    acceptable_inited = YES;
}

/*	Transform file identifier into WWW address
 *	------------------------------------------
 *
 *
 * On exit,
 *	returns		nil if error
 *			pointer to malloced string (must be freed) if ok
 */
static char *WWW_from_archie(char *file)
{
    char *end;
    char *result;
    char *colon;

    for (end = file; *end > ' '; end++) ;	/* assumes ASCII encoding */
    result = (char *) malloc(10 + (end - file));
    if (!result)
	return result;		/* Malloc error */
    strcpy(result, "file://");
    strncat(result, file, end - file);
    colon = strchr(result + 7, ':');	/* Expect colon after host */
    if (colon) {
	for (; colon[0]; colon[0] = colon[1], colon++) ;	/* move down */
    }
    return result;
}				/* WWW_from_archie */

/*	Transform document identifier into URL
 *	--------------------------------------
 *
 *  Bugs: A static buffer of finite size is used!
 *	The format of the docid MUST be good!
 *
 *  On exit,
 *	returns		nil if error
 *			pointer to malloced string (must be freed) if ok
 */
static char hex[17] = "0123456789ABCDEF";

static char *WWW_from_WAIS(any *docid)
{
    static char buf[BIG];
    char *q = buf;
    char *p = (docid->bytes);
    char *result = NULL;
    int i, l;

    if (TRACE) {
	char *p;

	fprintf(tfp, "WAIS id (%d bytes) is ", (int) docid->size);
	for (p = docid->bytes; p < docid->bytes + docid->size; p++) {
	    if ((*p >= ' ') && (*p <= '~'))	/* Assume ASCII! */
		fprintf(tfp, "%c", *p);
	    else
		fprintf(tfp, "<%x>", (unsigned) *p);
	}
	fprintf(tfp, "\n");
    }
    for (p = docid->bytes;
	 (p < docid->bytes + docid->size) && (q < &buf[BIG]);) {
	CTRACE((tfp, "    Record type %d, length %d\n", p[0], p[1]));
	if (*p > 10) {
	    CTRACE((tfp, "Eh?  DOCID record type of %d!\n", *p));
	    return 0;
	} {			/* Bug fix -- allow any byte value 15 Apr 93 */
	    unsigned int i = (unsigned) *p++;

	    if (i > 99) {
		*q++ = (i / 100) + '0';
		i = i % 100;
	    }
	    if (i > 9) {
		*q++ = (i / 10) + '0';
		i = i % 10;
	    }
	    *q++ = i + '0';	/* Record type */
	}
	*q++ = '=';		/* Separate */
	l = *p++;		/* Length */
	for (i = 0; i < l; i++, p++) {
	    if (!acceptable[*p]) {
		*q++ = HEX_ESCAPE;	/* Means hex coming */
		*q++ = hex[(*p) >> 4];
		*q++ = hex[(*p) & 15];
	    } else
		*q++ = *p;
	}
	*q++ = ';';		/* Terminate field */
    }
    *q++ = 0;			/* Terminate string */
    CTRACE((tfp, "WWW form of id: %s\n", buf));
    StrAllocCopy(result, buf);
    return result;
}				/* WWW_from_WAIS */

/*	Transform URL into WAIS document identifier
 *	-------------------------------------------
 *
 *  On entry,
 *	docname		points to valid name produced originally by
 *			WWW_from_WAIS
 *  On exit,
 *	docid->size	is valid
 *	docid->bytes	is malloced and must later be freed.
 */
static any *WAIS_from_WWW(any *docid, char *docname)
{
    char *z;			/* Output pointer */
    char *sor;			/* Start of record - points to size field. */
    char *p;			/* Input pointer */
    char *q;			/* Poisition of "=" */
    char *s;			/* Position of semicolon */
    int n;			/* size */

    CTRACE((tfp, "WWW id (to become WAIS id): %s\n", docname));
    for (n = 0, p = docname; *p; p++) {		/* Count sizes of strings */
	n++;
	if (*p == ';')
	    n--;		/* Not converted */
	else if (*p == HEX_ESCAPE)
	    n = n - 2;		/* Save two bytes */
	docid->size = n;
    }

    if (!(docid->bytes = (char *) malloc(docid->size)))		/* result record */
	outofmem(__FILE__, "WAIS_from_WWW");
    z = docid->bytes;

    for (p = docname; *p;) {	/* Convert of strings */
	/* Record type */

	*z = 0;			/* Initialize record type */
	while (*p >= '0' && *p <= '9') {
	    *z = *z * 10 + (*p++ - '0');	/* Decode decimal record type */
	}
	z++;
	if (*p != '=')
	    return 0;
	q = p;

/*	  *z++ = *p++ - '0';
	q = strchr(p , '=');
	if (!q) return 0;
*/
	s = strchr(q, ';');	/* (Check only) */
	if (!s)
	    return 0;		/* Bad! No ';'; */
	sor = z;		/* Remember where the size field was */
	z++;			/* Skip record size for now     */
	for (p = q + 1; *p != ';';) {
	    if (*p == HEX_ESCAPE) {
		char c;
		unsigned int b;

		p++;
		c = *p++;
		b = from_hex(c);
		c = *p++;
		if (!c)
		    break;	/* Odd number of chars! */
		*z++ = (b << 4) + from_hex(c);
	    } else {
		*z++ = *p++;	/* Record */
	    }
	}
	*sor = (z - sor - 1);	/* Fill in size -- not counting size itself */
	p++;			/* After semicolon: start of next record */
    }

    if (TRACE) {
	char *p;

	fprintf(tfp, "WAIS id (%d bytes) is ", (int) docid->size);
	for (p = docid->bytes; p < docid->bytes + docid->size; p++) {
	    if ((*p >= ' ') && (*p <= '~'))	/* Assume ASCII! */
		fprintf(tfp, "%c", *p);
	    else
		fprintf(tfp, "<%x>", (unsigned) *p);
	}
	fprintf(tfp, "\n");
    }
    return docid;		/* Ok */

}				/* WAIS_from_WWW */

/*	Send a plain text record to the client		output_text_record()
 *	--------------------------------------
 */
static void output_text_record(HTStream *target,
			       WAISDocumentText *record,
			       boolean quote_string_quotes,
			       boolean binary)
{
    long count;

    /* printf(" Text\n");
       print_any("     DocumentID:  ", record->DocumentID);
       printf("     VersionNumber:  %d\n", record->VersionNumber);
     */

    if (binary) {
	(*target->isa->put_block) (target,
				   record->DocumentText->bytes,
				   record->DocumentText->size);
	return;
    }

    for (count = 0; count < record->DocumentText->size; count++) {
	long ch = (unsigned char) record->DocumentText->bytes[count];

	if (ch == 27) {		/* What is this in for?  Tim */
	    /* then we have an escape code */
	    /* if the next letter is '(' or ')', then ignore two letters */
	    if ('(' == record->DocumentText->bytes[count + 1] ||
		')' == record->DocumentText->bytes[count + 1])
		count += 1;	/* it is a term marker */
	    else
		count += 4;	/* it is a paragraph marker */
	} else if (ch == '\n' || ch == '\r') {
	    PUTC('\n');
	} else if (HTCJK != NOCJK || ch == '\t' || isprint(ch)) {
	    PUTC(ch);
	}
    }
}				/* output text record */

/*	Format A Search response for the client		display_search_response
 *	---------------------------------------
 */
/* modified from tracy shen's version in wutil.c
 * displays either a text record or a set of headlines.
 */
static void display_search_response(HTStructured * target, SearchResponseAPDU *response,
				    char *database,
				    char *keywords)
{
    WAISSearchResponse *info;
    long i, k;

    BOOL archie = strstr(database, "archie") != 0;	/* Special handling */

    CTRACE((tfp, "HTWAIS: Displaying search response\n"));
    PUTS(gettext("Index "));
    START(HTML_EM);
    PUTS(database);
    END(HTML_EM);
    sprintf(line, gettext(" contains the following %d item%s relevant to \""),
	    (int) (response->NumberOfRecordsReturned),
	    response->NumberOfRecordsReturned == 1 ? "" : "s");
    PUTS(line);
    START(HTML_EM);
    PUTS(keywords);
    END(HTML_EM);
    PUTS("\".\n");
    PUTS(gettext("The first figure after each entry is its relative score, "));
    PUTS(gettext("the second is the number of lines in the item."));
    START(HTML_BR);
    START(HTML_BR);
    PUTC('\n');
    START(HTML_OL);

    if (response->DatabaseDiagnosticRecords != 0) {
	info = (WAISSearchResponse *) response->DatabaseDiagnosticRecords;
	i = 0;

	if (info->Diagnostics != NULL)
	    showDiags((HTStream *) target, info->Diagnostics);

	if (info->DocHeaders != 0) {
	    for (k = 0; info->DocHeaders[k] != 0; k++) {
		WAISDocumentHeader *head = info->DocHeaders[k];
		char *headline = trim_junk(head->Headline);
		any *docid = head->DocumentID;
		char *docname;	/* printable version of docid */

		i++;
		/*
		 * Make a printable string out of the document id.
		 */
		CTRACE((tfp, "HTWAIS:  %2ld: Score: %4ld, lines:%4ld '%s'\n",
			i,
			(long int) (info->DocHeaders[k]->Score),
			(long int) (info->DocHeaders[k]->Lines),
			headline));

		START(HTML_LI);

		if (archie) {
		    char *www_name = WWW_from_archie(headline);

		    if (www_name) {
			HTStartAnchor(target, NULL, www_name);
			PUTS(headline);
			END(HTML_A);
			FREE(www_name);
		    } else {
			PUTS(headline);
			PUTS(gettext(" (bad file name)"));
		    }
		} else {	/* Not archie */
		    docname = WWW_from_WAIS(docid);
		    if (docname) {
			if ((head->Types) &&
			    (!strcmp(head->Types[0], "URL"))) {
			    HTStartAnchor(target, NULL, headline);
			} else {
			    char *dbname = HTEscape(database, URL_XPALPHAS);
			    char *w3_address = NULL;

			    HTSprintf0(&w3_address,
				       "/%s/%s/%d/%s",
				       dbname,
				       head->Types ? head->Types[0] : "TEXT",
				       (int) (head->DocumentLength),
				       docname);
			    HTStartAnchor(target, NULL, w3_address);
			    FREE(w3_address);
			    FREE(dbname);
			}
			PUTS(headline);
			END(HTML_A);
			FREE(docname);
		    } else {
			PUTS(gettext("(bad doc id)"));
		    }
		}

		sprintf(line, "%5ld  %5ld  ",
			head->Score,
			head->Lines);
		PUTS(line);
		MAYBE_END(HTML_LI);
	    }			/* next document header */
	}
	/* if there were any document headers */
	if (info->ShortHeaders != 0) {
	    k = 0;
	    while (info->ShortHeaders[k] != 0) {
		i++;
		PUTS(gettext("(Short Header record, can't display)"));
	    }
	}
	if (info->LongHeaders != 0) {
	    k = 0;
	    while (info->LongHeaders[k] != 0) {
		i++;
		PUTS(gettext("\nLong Header record, can't display\n"));
	    }
	}
	if (info->Text != 0) {
	    k = 0;
	    while (info->Text[k] != 0) {
		i++;
		PUTS(gettext("\nText record\n"));
		output_text_record((HTStream *) target,
				   info->Text[k++], false, false);
	    }
	}
	if (info->Headlines != 0) {
	    k = 0;
	    while (info->Headlines[k] != 0) {
		i++;
		PUTS(gettext("\nHeadline record, can't display\n"));
		/* dsply_headline_record( info->Headlines[k++]); */
	    }
	}
	if (info->Codes != 0) {
	    k = 0;
	    while (info->Codes[k] != 0) {
		i++;
		PUTS(gettext("\nCode record, can't display\n"));
		/* dsply_code_record( info->Codes[k++]); */
	    }
	}
    }				/* Loop: display user info */
    END(HTML_OL);
    PUTC('\n');
}

/*		Load by name					HTLoadWAIS
 *		============
 *
 *  This renders any object or search as required.
 */
int HTLoadWAIS(const char *arg,
	       HTParentAnchor *anAnchor,
	       HTFormat format_out,
	       HTStream *sink)
#define MAX_KEYWORDS_LENGTH 1000
#define MAX_SERVER_LENGTH 1000
#define MAX_DATABASE_LENGTH 1000
#define MAX_SERVICE_LENGTH 1000
#define MAXDOCS 200

{
    char *key;			/* pointer to keywords in URL */
    char *request_message = NULL;	/* arbitrary message limit */
    char *response_message = NULL;	/* arbitrary message limit */
    long request_buffer_length;	/* how of the request is left */
    SearchResponseAPDU *retrieval_response = 0;
    char keywords[MAX_KEYWORDS_LENGTH + 1];
    char *server_name;
    char *wais_database = NULL;	/* name of current database */
    char *www_database;		/* Same name escaped */
    char *service;
    char *doctype;
    char *doclength;
    long document_length;
    char *docname;

#ifdef VMS
    long connection = 0;

#else
    FILE *connection = NULL;
#endif /* VMS */
    char *names;		/* Copy of arg to be hacked up */
    BOOL ok = NO;
    int return_status = HT_LOADED;
    int rv;

    if (!acceptable_inited)
	init_acceptable();

    /* Decipher and check syntax of WWW address:
     * ----------------------------------------
     *
     * First we remove the "wais:" if it was specified.  920110
     */
    names = HTParse(arg, "", PARSE_HOST | PARSE_PATH | PARSE_PUNCTUATION);
    key = strchr(names, '?');

    if (key) {
	char *p;

	*key++ = 0;		/* Split off keywords */
	for (p = key; *p; p++)
	    if (*p == '+')
		*p = ' ';
	HTUnEscape(key);
    }
    if (names[0] == '/') {
	server_name = names + 1;
	if ((as_gate = (*server_name == '/')) != 0)
	    server_name++;	/* Accept one or two */
	www_database = strchr(server_name, '/');
	if (www_database) {
	    *www_database++ = 0;	/* Separate database name */
	    doctype = strchr(www_database, '/');
	    if (key)
		ok = YES;	/* Don't need doc details */
	    else if (doctype) {	/* If not search parse doc details */
		*doctype++ = 0;	/* Separate rest of doc address */
		doclength = strchr(doctype, '/');
		if (doclength) {
		    *doclength++ = 0;
		    document_length = atol(doclength);
		    if (document_length) {
			docname = strchr(doclength, '/');
			if (docname) {
			    *docname++ = 0;
			    ok = YES;	/* To avoid a goto! */
			}	/* if docname */
		    }		/* if document_length valid */
		}		/* if doclength */
	    } else {		/* no doctype?  Assume index required */
		if (!key)
		    key = "";
		ok = YES;
	    }			/* if doctype */
	}			/* if database */
    }

    if (!ok)
	return HTLoadError(sink, 500, gettext("Syntax error in WAIS URL"));

    CTRACE((tfp, "HTWAIS: Parsed OK\n"));

    service = strchr(names, ':');
    if (service)
	*service++ = 0;
    else
	service = "210";

    if (server_name[0] == 0) {
#ifdef VMS
	connection = 0;
#else
	connection = NULL;
#endif /* VMS */

    } else if (!(key && !*key)) {
	int status;

	CTRACE((tfp, "===WAIS=== calling mosaic_connect_to_server\n"));
	status = mosaic_connect_to_server(server_name,
					  atoi(service),
					  &connection);
	if (status == 0) {
	    CTRACE((tfp, "===WAIS=== connection failed\n"));
	    FREE(names);
	    return HT_NOT_LOADED;
	} else if (status == -1) {
	    CTRACE((tfp, "===WAIS=== connection interrupted\n"));
	    FREE(names);
	    return HT_NOT_LOADED;
	}
    }

    StrAllocCopy(wais_database, www_database);
    HTUnEscape(wais_database);

    /*
     * This below fixed size stuff is terrible.
     */
#ifdef VMS
    if ((request_message = typecallocn(char, MAX_MESSAGE_LEN)) == 0)
	  outofmem(__FILE__, "HTLoadWAIS");
    if ((response_message = typecallocn(char, MAX_MESSAGE_LEN)) == 0)
	  outofmem(__FILE__, "HTLoadWAIS");

#else
    request_message = (char *) s_malloc((size_t) MAX_MESSAGE_LEN * sizeof(char));
    response_message = (char *) s_malloc((size_t) MAX_MESSAGE_LEN * sizeof(char));
#endif /* VMS */

    /*
     * If keyword search is performed but there are no keywords, the user has
     * followed a link to the index itself.  It would be appropriate at this
     * point to send him the .SRC file - how?
     */
    if (key && !*key) {		/* I N D E X */
#ifdef CACHE_FILE_PREFIX
	char *filename = NULL;
	FILE *fp;
#endif
	HTStructured *target = HTML_new(anAnchor, format_out, sink);

	START(HTML_HEAD);
	PUTC('\n');
	HTStartIsIndex(target, HTWAIS_SOLICIT_QUERY, NULL);
	PUTC('\n');

	{
	    START(HTML_TITLE);
	    PUTS(wais_database);
	    PUTS(gettext(" (WAIS Index)"));
	    END(HTML_TITLE);
	    PUTC('\n');
	    END(HTML_HEAD);
	    PUTC('\n');

	    START(HTML_H1);
	    PUTS(gettext("WAIS Index: "));
	    START(HTML_EM);
	    PUTS(wais_database);
	    END(HTML_EM);
	    END(HTML_H1);
	    PUTC('\n');
	    PUTS(gettext("This is a link for searching the "));
	    START(HTML_EM);
	    PUTS(wais_database);
	    END(HTML_EM);
	    PUTS(gettext(" WAIS Index.\n"));

	}
	/*
	 * If we have seen a source file for this database, use that.
	 */
#ifdef CACHE_FILE_PREFIX
	HTSprintf0(&filename, "%sWSRC-%s:%s:%.100s.txt",
		   CACHE_FILE_PREFIX,
		   server_name, service, www_database);

	fp = fopen(filename, "r");	/* Have we found this already? */
	CTRACE((tfp, "HTWAIS: Description of server %s %s.\n",
		filename,
		fp ? "exists already" : "does NOT exist!"));

	if (fp) {
	    char c;

	    START(HTML_PRE);	/* Preformatted description */
	    PUTC('\n');
	    while ((c = getc(fp)) != EOF)
		PUTC(c);	/* Transfer file */
	    END(HTML_PRE);
	    fclose(fp);
	}
	FREE(filename);
#endif
	START(HTML_P);
	PUTS(gettext("\nEnter the 's'earch command and then specify search words.\n"));

	FREE_TARGET;
    } else if (key) {		/* S E A R C H */
	char *p;
	HTStructured *target;

	strncpy(keywords, key, MAX_KEYWORDS_LENGTH);
	while ((p = strchr(keywords, '+')) != 0)
	    *p = ' ';

	/*
	 * Send advance title to get something fast to the other end.
	 */
	target = HTML_new(anAnchor, format_out, sink);

	START(HTML_HEAD);
	PUTC('\n');
	HTStartIsIndex(target, HTWAIS_SOLICIT_QUERY, NULL);
	PUTC('\n');
	START(HTML_TITLE);
	PUTS(keywords);
	PUTS(gettext(" (in "));
	PUTS(wais_database);
	PUTC(')');
	END(HTML_TITLE);
	PUTC('\n');
	END(HTML_HEAD);
	PUTC('\n');

	START(HTML_H1);
	PUTS(gettext("WAIS Search of \""));
	START(HTML_EM);
	PUTS(keywords);
	END(HTML_EM);
	PUTS(gettext("\" in: "));
	START(HTML_EM);
	PUTS(wais_database);
	END(HTML_EM);
	END(HTML_H1);
	PUTC('\n');

	request_buffer_length = MAX_MESSAGE_LEN;	/* Amount left */
	CTRACE((tfp, "HTWAIS: Search for `%s' in `%s'\n",
		keywords, wais_database));
	if (NULL ==
	    generate_search_apdu(request_message + HEADER_LENGTH,
				 &request_buffer_length,
				 keywords, wais_database, NULL, MAXDOCS)) {
#ifdef VMS
	    HTAlert(gettext("HTWAIS: Request too large."));
	    return_status = HT_NOT_LOADED;
	    FREE_TARGET;
	    goto CleanUp;
#else
	    panic("request too large");
#endif /* VMS */
	}

	HTProgress(gettext("Searching WAIS database..."));
	rv = interpret_message(request_message,
			       MAX_MESSAGE_LEN - request_buffer_length,
			       response_message,
			       MAX_MESSAGE_LEN,
			       connection,
			       false	/* true verbose */
	    );

	if (rv == HT_INTERRUPTED) {
	    HTAlert(gettext("Search interrupted."));
	    return_status = HT_INTERRUPTED;
	    FREE_TARGET;
	    goto CleanUp;
	} else if (!rv) {
#ifdef VMS
	    HTAlert(HTWAIS_MESSAGE_TOO_BIG);
	    return_status = HT_NOT_LOADED;
	    FREE_TARGET;
	    goto CleanUp;
#else
	    panic("returned message too large");
#endif /* VMS */
	} else {		/* returned message ok */
	    SearchResponseAPDU *query_response = 0;

	    readSearchResponseAPDU(&query_response,
				   response_message + HEADER_LENGTH);
	    display_search_response(target,
				    query_response, wais_database, keywords);
	    if (query_response->DatabaseDiagnosticRecords)
		freeWAISSearchResponse(query_response->DatabaseDiagnosticRecords);
	    freeSearchResponseAPDU(query_response);
	}			/* returned message not too large */
	FREE_TARGET;
    } else {			/* D O C U M E N T    F E T C H */
	HTFormat format_in;
	boolean binary;		/* how to transfer stuff coming over */
	HTStream *target;
	long count;
	any doc_chunk;
	any *docid = &doc_chunk;

	CTRACE((tfp,
		"HTWAIS: Retrieve document id `%s' type `%s' length %ld\n",
		docname, doctype, document_length));

	format_in =
	    !strcmp(doctype, "WSRC") ? HTAtom_for("application/x-wais-source") :
	    !strcmp(doctype, "TEXT") ? HTAtom_for("text/plain") :
	    !strcmp(doctype, "HTML") ? HTAtom_for("text/html") :
	    !strcmp(doctype, "GIF") ? HTAtom_for("image/gif") :
	    HTAtom_for("application/octet-stream");
	binary =
	    0 != strcmp(doctype, "WSRC") &&
	    0 != strcmp(doctype, "TEXT") &&
	    0 != strcmp(doctype, "HTML");

	target = HTStreamStack(format_in, format_out, sink, anAnchor);
	if (!target)
	    return HTLoadError(sink, 500,
			       gettext("Can't convert format of WAIS document"));
	/*
	 * Decode hex or litteral format for document ID.
	 */
	WAIS_from_WWW(docid, docname);

	/*
	 * Loop over slices of the document.
	 */
	for (count = 0;
	     count * CHARS_PER_PAGE < document_length;
	     count++) {
#ifdef VMS
	    char *type = NULL;

	    StrAllocCopy(type, doctype);
#else
	    char *type = s_strdup(doctype);	/* Gets freed I guess */
#endif /* VMS */
	    request_buffer_length = MAX_MESSAGE_LEN;	/* Amount left */
	    CTRACE((tfp, "HTWAIS: Slice number %ld\n", count));

	    if (HTCheckForInterrupt()) {
		HTAlert(TRANSFER_INTERRUPTED);
		(*target->isa->_abort) (target, NULL);
#ifdef VMS
		FREE(type);
#endif /* VMS */
		return_status = HT_NOT_LOADED;
		goto CleanUp;
	    }

	    if (0 ==
		generate_retrieval_apdu(request_message + HEADER_LENGTH,
					&request_buffer_length,
					docid,
					CT_byte,
					count * CHARS_PER_PAGE,
					(((count + 1) * CHARS_PER_PAGE <= document_length)
					 ? (count + 1) * CHARS_PER_PAGE
					 : document_length),
					type,
					wais_database)) {
#ifdef VMS
		HTAlert(gettext("HTWAIS: Request too long."));
		return_status = HT_NOT_LOADED;
		FREE_TARGET;
		FREE(type);
		FREE(docid->bytes);
		goto CleanUp;
#else
		panic("request too long");
#endif /* VMS */
	    }

	    /*
	     * Actually do the transaction given by request_message.
	     */
	    HTProgress(gettext("Fetching WAIS document..."));
	    rv = interpret_message(request_message,
				   MAX_MESSAGE_LEN - request_buffer_length,
				   response_message,
				   MAX_MESSAGE_LEN,
				   connection,
				   false	/* true verbose */
		);
	    if (rv == HT_INTERRUPTED) {
		HTAlert(TRANSFER_INTERRUPTED);
		return_status = HT_INTERRUPTED;
		FREE_TARGET;
		FREE(type);
		FREE(docid->bytes);
		goto CleanUp;
	    } else if (!rv) {
#ifdef VMS
		HTAlert(HTWAIS_MESSAGE_TOO_BIG);
		return_status = HT_NOT_LOADED;
		FREE_TARGET;
		FREE(type);
		FREE(docid->bytes);
		goto CleanUp;
#else
		panic("Returned message too large");
#endif /* VMS */
	    }

	    /*
	     * Parse the result which came back into memory.
	     */
	    readSearchResponseAPDU(&retrieval_response,
				   response_message + HEADER_LENGTH);

	    if (NULL ==
		((WAISSearchResponse *)
		 retrieval_response->DatabaseDiagnosticRecords)->Text) {
		/* display_search_response(target, retrieval_response,
		   wais_database, keywords); */
		PUTS(gettext("No text was returned!\n"));
		/* panic("No text was returned"); */
	    } else {
		output_text_record(target,
				   ((WAISSearchResponse *)
				    retrieval_response->DatabaseDiagnosticRecords)->Text[0],
				   false, binary);
	    }			/* If text existed */

#ifdef VMS
	    FREE(type);
#endif /* VMS */
	}			/* Loop over slices */

	FREE_TARGET;
	FREE(docid->bytes);

	freeWAISSearchResponse(retrieval_response->DatabaseDiagnosticRecords);
	freeSearchResponseAPDU(retrieval_response);

    }				/* If document rather than search */

  CleanUp:
    /*
     * (This postponed until later, after a timeout:)
     */
#ifdef VMS
    if (connection)
	NETCLOSE((int) connection);
#else
    if (connection)
	fclose(connection);
#endif /* VMS */
    FREE(wais_database);
#ifdef VMS
    FREE(request_message);
    FREE(response_message);
#else
    s_free(request_message);
    s_free(response_message);
#endif /* VMS */
    FREE(names);
    return (return_status);
}

#ifdef GLOBALDEF_IS_MACRO
#define _HTWAIS_C_1_INIT { "wais", HTLoadWAIS, NULL }
GLOBALDEF(HTProtocol, HTWAIS, _HTWAIS_C_1_INIT);
#else
GLOBALDEF HTProtocol HTWAIS =
{"wais", HTLoadWAIS, NULL};
#endif /* GLOBALDEF_IS_MACRO */
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 42
a43 42
**	==================================================
**
**	This module allows a WWW server or client to read data from a
**	remote	WAIS
**  server, and provide that data to a WWW client in hypertext form.
**  Source files, once retrieved, are stored and used to provide
**  information about the index when that is acessed.
**
**  Authors
**	BK	Brewster Kahle, Thinking Machines, <Brewster@@think.com>
**	TBL	Tim Berners-Lee, CERN <timbl@@info.cern.ch>
**	FM	Foteos Macrides, WFEB <macrides@@sci.wfeb.edu>
**
**  History
**	   Sep 91	TBL adapted shell-ui.c (BK) with HTRetrieve.c from WWW.
**	   Feb 91	TBL Generated HTML cleaned up a bit (quotes, escaping)
**			    Refers to lists of sources.
**	   Mar 93	TBL Lib 2.0 compatible module made.
**	   May 94	FM  Added DIRECT_WAIS support for VMS.
**
**  Bugs
**	Uses C stream i/o to read and write sockets, which won't work
**	on VMS TCP systems.
**
**	Should cache connections.
**
**	ANSI C only as written
**
**  Bugs fixed
**	NT Nathan Torkington (Nathan.Torkington@@vuw.ac.nz)
**
**  WAIS comments:
**
**	1.	Separate directories for different system's .o would help
**	2.	Document ids are rather long!
**
** W WW Address mapping convention:
**
**	/servername/database/type/length/document-id
**
**	/servername/database?word+word+word
*/
d61 2
a62 2
**			---------
*/
d71 1
a71 1
#define CHARS_PER_PAGE 10000 /* number of chars retrieved in each request */
d76 2
a77 2
**			--------
*/
d84 1
a84 1
#define BIG 1024	/* identifier size limit  @@@@@@@@@@ */
d90 3
a92 1
static BOOL	as_gate;	/* Client is using us as gateway */
a93 1
static char	line[2048];	/* For building strings to display */
d105 2
a106 2
	const HTStructuredClass *	isa;
	/* ... */
d110 2
a111 2
	const HTStreamClass *	isa;
	/* ... */
d118 3
a120 4
static int fd_mosaic_connect_to_server (
	char *		host_name,
	long		port,
	long *		fd)
d128 1
a128 1
    status = HTDoConnect (dummy, "WAIS", 210, (int *)fd);
d142 3
a144 4
static int mosaic_connect_to_server (
	char *		host_name,
	long		port,
	long *		fdp)
d146 4
a149 5
static int mosaic_connect_to_server (
	char *		host_name,
	long		port,
	FILE **	fp)
#endif /* VMS */
d152 1
a152 1
    FILE* file;
d157 1
a157 1
    rv = fd_mosaic_connect_to_server (host_name, port, &fd);
d159 1
a159 1
	HTAlert (gettext("Could not connect to WAIS server."));
d162 1
a162 1
	HTAlert (CONNECTION_INTERRUPTED);
a164 1

d166 2
a167 2
    if ((file = fdopen(fd,"r+")) == NULL) {
	HTAlert (gettext("Could not open WAIS connection for reading."));
d183 1
a183 3
static void showDiags (
	HTStream *		target,
	diagnosticRecord **	d)
d199 2
a200 2
**	-----------------------------------------
*/
d205 1
a205 1
static void init_acceptable (void)
d208 7
a214 4
    char * good =
      "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
    for(i=0; i<256; i++) acceptable[i] = NO;
    for(;*good; good++) acceptable[(unsigned int)*good] = YES;
d219 8
a226 9
**	------------------------------------------
**
**
** On exit,
**	returns		nil if error
**			pointer to malloced string (must be freed) if ok
*/
static char * WWW_from_archie (
	char *		file)
d228 8
a235 6
    char * end;
    char * result;
    char * colon;
    for(end=file; *end > ' '; end++);	/* assumes ASCII encoding*/
    result = (char *)malloc(10 + (end-file));
    if (!result) return result;		/* Malloc error */
d237 2
a238 2
    strncat(result, file, end-file);
    colon = strchr(result+7, ':');	/* Expect colon after host */
d240 1
a240 1
	for(; colon[0]; colon[0]=colon[1], colon++);	/* move down */
d243 1
a243 1
} /* WWW_from_archie */
d246 10
a255 10
**	--------------------------------------
**
**  Bugs: A static buffer of finite size is used!
**	The format of the docid MUST be good!
**
**  On exit,
**	returns		nil if error
**			pointer to malloced string (must be freed) if ok
*/
static char hex [17] = "0123456789ABCDEF";
d257 1
a257 2
static char * WWW_from_WAIS (
	any *		docid)
d260 3
a262 3
    char * q = buf;
    char * p = (docid->bytes);
    char * result = NULL;
d267 4
a270 3
	fprintf(tfp, "WAIS id (%d bytes) is ", (int)docid->size);
	for (p = docid->bytes; p < docid->bytes+docid->size; p++) {
	    if ((*p >= ' ') && (*p<= '~')) /* Assume ASCII! */
d273 1
a273 1
		fprintf(tfp, "<%x>", (unsigned)*p);
d278 1
a278 1
	 (p < docid->bytes+docid->size) && (q < &buf[BIG]);) {
d283 1
a283 2
	}
	{	/* Bug fix -- allow any byte value 15 Apr 93 */
d287 1
a287 1
		*q++ = (i/100) + '0';
d291 1
a291 1
		*q++ = (i/10) + '0';
d298 1
a298 1
	for (i = 0; i < l; i++, p++){
d303 2
a304 2
	    }
	    else *q++ = *p;
d306 1
a306 1
	*q++= ';';		/* Terminate field */
d312 1
a312 1
} /* WWW_from_WAIS */
d315 10
a324 12
**	-------------------------------------------
**
**  On entry,
**	docname		points to valid name produced originally by
**			WWW_from_WAIS
**  On exit,
**	docid->size	is valid
**	docid->bytes	is malloced and must later be freed.
*/
static any * WAIS_from_WWW (
	any *		docid,
	char *		docname)
d326 6
a331 6
    char *z;	/* Output pointer */
    char *sor;	/* Start of record - points to size field. */
    char *p;	/* Input pointer */
    char *q;	/* Poisition of "=" */
    char *s;	/* Position of semicolon */
    int n;	/* size */
d334 1
a334 1
    for (n = 0, p = docname; *p; p++) { /* Count sizes of strings */
d339 1
a339 1
	    n = n-2;		/* Save two bytes */
d343 2
a344 2
    if (!(docid->bytes = (char *) malloc(docid->size))) /* result record */
	    outofmem(__FILE__, "WAIS_from_WWW");
d347 2
a348 2
    for (p = docname; *p; ) {	/* Convert of strings */
				/* Record type */
d352 1
a352 1
	    *z = *z*10 + (*p++ - '0');	/* Decode decimal record type */
d367 3
a369 3
	z++;			/* Skip record size for now	*/
	for (p = q+1; *p != ';';) {
	   if (*p == HEX_ESCAPE) {
d372 1
d375 1
a375 1
		b =   from_hex(c);
d379 1
a379 1
		*z++ = (b<<4) + from_hex(c);
d384 1
a384 1
	*sor = (z-sor-1);	/* Fill in size -- not counting size itself */
d390 4
a393 3
	fprintf(tfp, "WAIS id (%d bytes) is ", (int)docid->size);
	for (p = docid->bytes; p < docid->bytes+docid->size; p++) {
	    if ((*p >= ' ') && (*p<= '~')) /* Assume ASCII! */
d396 1
a396 1
		fprintf(tfp, "<%x>", (unsigned)*p);
d402 1
a402 1
} /* WAIS_from_WWW */
d405 6
a410 7
**	--------------------------------------
*/
static void output_text_record (
    HTStream *			target,
    WAISDocumentText *		record,
    boolean			quote_string_quotes,
    boolean			binary)
d412 5
a416 4
  long count;
  /* printf(" Text\n");
     print_any("     DocumentID:  ", record->DocumentID);
     printf("	  VersionNumber:  %d\n", record->VersionNumber);
d419 11
a429 10
  if (binary) {
    (*target->isa->put_block)(target,
			      record->DocumentText->bytes,
			      record->DocumentText->size);
    return;
  }

  for (count = 0; count < record->DocumentText->size; count++){
    long ch = (unsigned char)record->DocumentText->bytes[count];
    if (ch == 27) {	/* What is this in for?  Tim */
d434 4
a437 3
	    count += 1;		    /* it is a term marker */
	    else count += 4;		/* it is a paragraph marker */
    } else if (ch == '\n' || ch == '\r') {
d439 1
a439 1
    } else if (HTCJK != NOCJK || ch == '\t' || isprint(ch)){
d441 1
d443 1
a443 2
  }
} /* output text record */
d446 2
a447 2
**	---------------------------------------
*/
d451 3
a453 5
static void display_search_response (
    HTStructured *		target,
    SearchResponseAPDU *	response,
    char *			database,
    char *			keywords)
d455 1
a455 1
    WAISSearchResponse	*info;
d458 1
a458 1
    BOOL archie =  strstr(database, "archie")!=0;	/* Special handling */
d466 2
a467 2
	    (int)(response->NumberOfRecordsReturned),
	    response->NumberOfRecordsReturned ==1 ? "" : "s");
d481 2
a482 2
	info = (WAISSearchResponse *)response->DatabaseDiagnosticRecords;
	i =0;
d485 1
a485 1
	    showDiags((HTStream*)target, info->Diagnostics);
d488 5
a492 5
	    for (k = 0; info->DocHeaders[k] != 0; k++ ) {
		WAISDocumentHeader* head = info->DocHeaders[k];
		char * headline = trim_junk(head->Headline);
		any * docid = head->DocumentID;
		char * docname;		/* printable version of docid */
d496 2
a497 2
		**  Make a printable string out of the document id.
		*/
d499 4
a502 4
			    i,
			    (long int)(info->DocHeaders[k]->Score),
			    (long int)(info->DocHeaders[k]->Lines),
			    headline));
d507 2
a508 1
		    char * www_name = WWW_from_archie(headline);
d518 2
a519 2
		} else { /* Not archie */
		    docname =  WWW_from_WAIS(docid);
d522 1
a522 1
			   (!strcmp(head->Types[0], "URL"))) {
d524 4
a527 3
			} else{
			    char * dbname = HTEscape(database, URL_XPALPHAS);
			    char * w3_address = NULL;
d529 5
a533 5
					"/%s/%s/%d/%s",
					dbname,
					head->Types ? head->Types[0] : "TEXT",
					(int)(head->DocumentLength),
					docname);
d549 1
a549 1
		PUTS( line);
d551 3
a553 3
	    } /* next document header */
	} /* if there were any document headers */

d558 1
a558 1
		PUTS( gettext("(Short Header record, can't display)"));
d565 1
a565 1
		PUTS( gettext("\nLong Header record, can't display\n"));
d572 2
a573 2
		PUTS( gettext("\nText record\n"));
		output_text_record((HTStream*)target,
d581 1
a581 1
		PUTS( gettext("\nHeadline record, can't display\n"));
d589 1
a589 1
		PUTS( gettext("\nCode record, can't display\n"));
d593 1
a593 1
    }	/* Loop: display user info */
d599 8
a606 10
**		============
**
**  This renders any object or search as required.
*/
int HTLoadWAIS (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)

d614 5
a618 5
    char * key;			  /* pointer to keywords in URL */
    char* request_message = NULL; /* arbitrary message limit */
    char* response_message = NULL; /* arbitrary message limit */
    long request_buffer_length; /* how of the request is left */
    SearchResponseAPDU	*retrieval_response = 0;
d621 2
a622 2
    char *wais_database = NULL;		/* name of current database */
    char *www_database;			/* Same name escaped */
d628 1
d631 1
d635 1
a635 1
    char * names;		/* Copy of arg to be hacked up */
d643 5
a647 5
    /*	Decipher and check syntax of WWW address:
    **	----------------------------------------
    **
    **	First we remove the "wais:" if it was specified.  920110
    */
d652 6
a657 3
	char * p;
	*key++ = 0;	/* Split off keywords */
	for (p=key; *p; p++) if (*p == '+') *p = ' ';
d661 2
a662 2
	server_name = names+1;
	if ((as_gate =(*server_name == '/')) != 0)
d664 1
a664 1
	www_database = strchr(server_name,'/');
d666 1
a666 1
	    *www_database++ = 0;		/* Separate database name */
d668 4
a671 3
	    if (key) ok = YES;	/* Don't need doc details */
	    else if (doctype) { /* If not search parse doc details */
		*doctype++ = 0; /* Separate rest of doc address */
d681 4
a684 4
			} /* if docname */
		    } /* if document_length valid */
		} /* if doclength */
	    } else { /* no doctype?  Assume index required */
d688 2
a689 2
	    } /* if doctype */
	} /* if database */
d712 1
d728 1
a728 1
    StrAllocCopy(wais_database,www_database);
d732 2
a733 2
    **	This below fixed size stuff is terrible.
    */
d736 1
a736 1
	outofmem(__FILE__, "HTLoadWAIS");
d738 2
a739 1
	outofmem(__FILE__, "HTLoadWAIS");
d741 2
a742 2
    request_message = (char*)s_malloc((size_t)MAX_MESSAGE_LEN * sizeof(char));
    response_message = (char*)s_malloc((size_t)MAX_MESSAGE_LEN * sizeof(char));
d746 5
a750 5
    **	If keyword search is performed but there are no keywords,
    **	the user has followed a link to the index itself.  It would be
    **	appropriate at this point to send him the .SRC file - how?
    */
    if (key && !*key) {				/* I N D E X */
d752 2
a753 2
	char * filename = NULL;
	FILE * fp;
d755 1
a755 1
	HTStructured * target = HTML_new(anAnchor, format_out, sink);
d759 1
a759 1
	HTStartIsIndex(target, HTWAIS_SOLICIT_QUERY , NULL);
d786 2
a787 2
	**  If we have seen a source file for this database, use that.
	*/
d790 2
a791 2
		CACHE_FILE_PREFIX,
		server_name, service, www_database);
d795 2
a796 2
		    filename,
		    fp ? "exists already" : "does NOT exist!"));
d800 2
a801 1
	    START(HTML_PRE);		/* Preformatted description */
d803 2
a804 1
	    while((c=getc(fp))!=EOF) PUTC(c);	/* Transfer file */
d814 1
a814 1
    } else if (key) {					/* S E A R C H */
d816 1
a816 1
	HTStructured * target;
d823 2
a824 2
	**  Send advance title to get something fast to the other end.
	*/
d853 1
a853 1
	request_buffer_length = MAX_MESSAGE_LEN; /* Amount left */
d855 5
a859 5
		    keywords, wais_database));
	if(NULL ==
	generate_search_apdu(request_message + HEADER_LENGTH,
				&request_buffer_length,
				keywords, wais_database, NULL, MAXDOCS)) {
d861 1
a861 1
	    HTAlert (gettext("HTWAIS: Request too large."));
d871 7
a877 7
	rv = interpret_message (request_message,
				MAX_MESSAGE_LEN - request_buffer_length,
				response_message,
				MAX_MESSAGE_LEN,
				connection,
				false	/* true verbose */
			       );
d880 1
a880 1
	    HTAlert (gettext("Search interrupted."));
d886 1
a886 1
	    HTAlert (HTWAIS_MESSAGE_TOO_BIG);
d893 3
a895 2
	} else {	/* returned message ok */
	    SearchResponseAPDU	*query_response = 0;
d897 1
a897 1
		response_message + HEADER_LENGTH);
d899 1
a899 1
		query_response, wais_database, keywords);
d901 3
a903 4
		freeWAISSearchResponse(
			query_response->DatabaseDiagnosticRecords);
	    freeSearchResponseAPDU( query_response);
	}	/* returned message not too large */
d907 2
a908 2
	boolean binary;     /* how to transfer stuff coming over */
	HTStream * target;
d910 2
a911 2
	any   doc_chunk;
	any * docid = &doc_chunk;
d913 3
a915 2
	CTRACE((tfp, "HTWAIS: Retrieve document id `%s' type `%s' length %ld\n",
		    docname, doctype, document_length));
d918 5
a922 5
	  !strcmp(doctype, "WSRC") ? HTAtom_for("application/x-wais-source") :
	  !strcmp(doctype, "TEXT") ? HTAtom_for("text/plain") :
	  !strcmp(doctype, "HTML") ? HTAtom_for("text/html") :
	  !strcmp(doctype, "GIF")  ? HTAtom_for("image/gif") :
				     HTAtom_for("application/octet-stream");
d924 3
a926 3
	  0 != strcmp(doctype, "WSRC") &&
	  0 != strcmp(doctype, "TEXT") &&
	  0 != strcmp(doctype, "HTML") ;
d933 2
a934 2
	**  Decode hex or litteral format for document ID.
	*/
d938 2
a939 2
	**  Loop over slices of the document.
	*/
d950 1
a950 1
	    request_buffer_length = MAX_MESSAGE_LEN; /* Amount left */
d954 2
a955 2
		HTAlert (TRANSFER_INTERRUPTED);
		(*target->isa->_abort)(target, NULL);
d969 3
a971 3
		    ((count + 1) * CHARS_PER_PAGE <= document_length ?
					(count + 1) * CHARS_PER_PAGE :
					document_length),
d975 1
a975 1
		HTAlert (gettext("HTWAIS: Request too long."));
d987 2
a988 2
	    **	Actually do the transaction given by request_message.
	    */
d995 2
a996 2
				   false /* true verbose */
				  );
d998 1
a998 1
		HTAlert (TRANSFER_INTERRUPTED);
d1006 1
a1006 1
		HTAlert (HTWAIS_MESSAGE_TOO_BIG);
d1018 2
a1019 2
	    **	Parse the result which came back into memory.
	    */
d1027 1
a1027 1
					wais_database, keywords); */
d1033 1
a1033 1
		    retrieval_response->DatabaseDiagnosticRecords)->Text[0],
d1035 1
a1035 1
	    } /* If text existed */
d1040 1
a1040 1
	}	/* Loop over slices */
d1045 2
a1046 2
	freeWAISSearchResponse( retrieval_response->DatabaseDiagnosticRecords);
	freeSearchResponseAPDU( retrieval_response);
d1048 1
a1048 1
    } /* If document rather than search */
d1050 1
a1050 1
CleanUp:
d1052 2
a1053 2
    **	(This postponed until later,  after a timeout:)
    */
d1056 1
a1056 1
	NETCLOSE((int)connection);
d1077 2
a1078 1
GLOBALDEF HTProtocol HTWAIS = { "wais", HTLoadWAIS, NULL };
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d90 1
a90 1
PRIVATE BOOL	as_gate;	/* Client is using us as gateway */
d92 1
a92 1
PRIVATE char	line[2048];	/* For building strings to display */
d104 1
a104 1
	CONST HTStructuredClass *	isa;
d109 1
a109 1
	CONST HTStreamClass *	isa;
d117 4
a120 4
PRIVATE int fd_mosaic_connect_to_server ARGS3(
	char *,		host_name,
	long,		port,
	long *,		fd)
d142 9
a150 9
PRIVATE int mosaic_connect_to_server ARGS3(
	char *,		host_name,
	long,		port,
	long *,		fdp)
#else
PRIVATE int mosaic_connect_to_server ARGS3(
	char *,		host_name,
	long,		port,
	FILE **,	fp)
d186 3
a188 3
PRIVATE void showDiags ARGS2(
	HTStream *,		target,
	diagnosticRecord **,	d)
d207 2
a208 2
PRIVATE BOOL acceptable[256];
PRIVATE BOOL acceptable_inited = NO;
d210 1
a210 1
PRIVATE void init_acceptable NOARGS
d228 2
a229 2
PRIVATE char * WWW_from_archie ARGS1(
	char *,		file)
d256 1
a256 1
PRIVATE char hex [17] = "0123456789ABCDEF";
d258 2
a259 2
PRIVATE char * WWW_from_WAIS ARGS1(
	any *,		docid)
d326 3
a328 3
PRIVATE any * WAIS_from_WWW ARGS2(
	any *,		docid,
	char *,		docname)
d409 5
a413 5
PRIVATE void output_text_record ARGS4(
    HTStream *,			target,
    WAISDocumentText *,		record,
    boolean,			quote_string_quotes,
    boolean,			binary)
d451 5
a455 5
PRIVATE void display_search_response ARGS4(
    HTStructured *,		target,
    SearchResponseAPDU *,	response,
    char *,			database,
    char *,			keywords)
d603 5
a607 5
PUBLIC int HTLoadWAIS ARGS4(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d1068 1
a1068 1
GLOBALDEF PUBLIC HTProtocol HTWAIS = { "wais", HTLoadWAIS, NULL };
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d78 1
a89 5
extern HTCJKlang HTCJK;

extern int WWW_TraceFlag;	/* Control diagnostic output */
extern FILE * logfile;		/* Log file output */

d118 1
a118 1
	char *, 	host_name,
d120 1
a120 1
	long *, 	fd)
d122 1
a122 4
    /*
    **	New version.
    */
    char dummy[256];
d124 1
d126 1
a126 1
    sprintf (dummy, "wais://%s:%d/", host_name, port);
d130 5
a134 1
	return -1;
d136 2
a137 3
    if (status < 0)
	return 0;
    return 1;
d143 1
a143 1
	char *, 	host_name,
d145 1
a145 1
	long *, 	fdp)
d148 1
a148 1
	char *, 	host_name,
d225 1
a225 1
**	returns 	nil if error
d229 1
a229 1
	char *, 	file)
d236 1
a236 1
    if (!result) return result; 	/* Malloc error */
d253 1
a253 1
**	returns 	nil if error
d264 1
d266 1
d280 1
a280 1
	CTRACE(tfp, "    Record type %d, length %d\n", p[0], p[1]);
d282 1
a282 1
	    CTRACE(tfp, "Eh?  DOCID record type of %d!\n", *p);
d302 1
a302 1
		*q++ = HEX_ESCAPE;	/* Means hex commming */
d311 3
a313 8
    CTRACE(tfp, "WWW form of id: %s\n", buf);
    {
	char * result = (char *)malloc(strlen(buf)+1);
	if (!result)
	    outofmem(__FILE__, "WWW_from_WAIS");
	strcpy(result, buf);
	return result;
    }
d320 1
a320 1
**	docname 	points to valid name produced originally by
d328 1
a328 1
	char *, 	docname)
d337 1
a337 1
    CTRACE(tfp, "WWW id (to become WAIS id): %s\n", docname);
d354 1
a354 1
	*z = 0; 		/* Initialize record type */
d410 2
a411 2
    HTStream *, 		target,
    WAISDocumentText *, 	record,
d435 1
a435 1
	    count += 1; 	    /* it is a term marker */
d445 1
a445 1
/*	Format A Search response for the client 	display_search_response
d460 1
a460 1
    BOOL archie =  strstr(database, "archie")!=0;	/* Specical handling */
d462 1
a462 1
    CTRACE(tfp, "HTWAIS: Displaying search response\n");
d494 1
a494 1
		char * docname; 	/* printable version of docid */
d500 1
a500 1
		CTRACE(tfp, "HTWAIS:  %2ld: Score: %4ld, lines:%4ld '%s'\n",
d504 1
a504 1
			    headline);
d522 16
a537 12
			char * dbname = HTEscape(database, URL_XPALPHAS);
			sprintf(line,
				"/%s/%s/%d/%s", 	/* W3 address */
				dbname,
				head->Types ? head->Types[0] : "TEXT",
				(int)(head->DocumentLength),
				docname);
			HTStartAnchor(target, NULL,
				      ((head->Types) &&
				       (!strcmp(head->Types[0], "URL")))
						?
				       headline : line); /* NT, Sep 93 */
a539 1
			FREE(dbname);
d616 1
a616 3
    static CONST char * error_header =
"<h1>Access error</h1>\nThe following error occured in accesing a WAIS server:<P>\n";
    char * key; 		  /* pointer to keywords in URL */
d623 2
a624 2
    char *wais_database = NULL; 	/* name of current database */
    char *www_database; 		/* Same name escaped */
a639 2
    extern FILE * connect_to_server();

d646 1
a646 1
    **	First we remove the "wais:" if it was spcified.  920110
d659 1
a659 1
	if (as_gate =(*server_name == '/'))
d691 1
a691 1
    CTRACE(tfp, "HTWAIS: Parsed OK\n");
d708 1
a708 1
	CTRACE (tfp, "===WAIS=== calling mosaic_connect_to_server\n");
d713 1
a713 1
	    CTRACE (tfp, "===WAIS=== connection failed\n");
d717 1
a717 1
	    CTRACE (tfp, "===WAIS=== connection interrupted\n");
d730 1
a730 2
    if (!(request_message =
	  (char*)calloc((size_t)MAX_MESSAGE_LEN*sizeof(char),1)))
d732 1
a732 2
    if (!(response_message =
	  (char*)calloc((size_t)MAX_MESSAGE_LEN*sizeof(char),1)))
d744 1
a744 1
    if (key && !*key) { 			/* I N D E X */
d746 1
a746 1
	char filename[256];
d783 1
a783 1
	sprintf(filename, "%sWSRC-%s:%s:%.100s.txt",
d788 1
a788 1
	CTRACE(tfp, "HTWAIS: Description of server %s %s.\n",
d790 1
a790 1
		    fp ? "exists already" : "does NOT exist!");
d800 1
d811 2
a812 1
	while(p=strchr(keywords, '+')) *p = ' ';
d846 2
a847 2
	CTRACE(tfp, "HTWAIS: Search for `%s' in `%s'\n",
		    keywords, wais_database);
d905 2
a906 2
	CTRACE(tfp, "HTWAIS: Retrieve document id `%s' type `%s' length %ld\n",
		    docname, doctype, document_length);
d942 1
a942 1
	    CTRACE(tfp, "HTWAIS: Slice number %ld\n", count);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 42
a43 42
 *	==================================================
 *
 *	This module allows a WWW server or client to read data from a
 *	remote	WAIS
 *  server, and provide that data to a WWW client in hypertext form.
 *  Source files, once retrieved, are stored and used to provide
 *  information about the index when that is acessed.
 *
 *  Authors
 *	BK	Brewster Kahle, Thinking Machines, <Brewster@@think.com>
 *	TBL	Tim Berners-Lee, CERN <timbl@@info.cern.ch>
 *	FM	Foteos Macrides, WFEB <macrides@@sci.wfeb.edu>
 *
 *  History
 *	   Sep 91	TBL adapted shell-ui.c (BK) with HTRetrieve.c from WWW.
 *	   Feb 91	TBL Generated HTML cleaned up a bit (quotes, escaping)
 *			    Refers to lists of sources.
 *	   Mar 93	TBL Lib 2.0 compatible module made.
 *	   May 94	FM  Added DIRECT_WAIS support for VMS.
 *
 *  Bugs
 *	Uses C stream i/o to read and write sockets, which won't work
 *	on VMS TCP systems.
 *
 *	Should cache connections.
 *
 *	ANSI C only as written
 *
 *  Bugs fixed
 *	NT Nathan Torkington (Nathan.Torkington@@vuw.ac.nz)
 *
 *  WAIS comments:
 *
 *	1.	Separate directories for different system's .o would help
 *	2.	Document ids are rather long!
 *
 * W WW Address mapping convention:
 *
 *	/servername/database/type/length/document-id
 *
 *	/servername/database?word+word+word
 */
d61 2
a62 2
 *			---------
 */
d71 1
a71 1
#define CHARS_PER_PAGE 10000	/* number of chars retrieved in each request */
d76 2
a77 3
 *			--------
 */
#include <LYUtils.h>
d83 1
a83 1
#define BIG 1024		/* identifier size limit  @@@@@@@@@@ */
d89 1
a89 1
static BOOL as_gate;		/* Client is using us as gateway */
d91 2
a92 1
static char line[2048];		/* For building strings to display */
d94 3
d108 2
a109 2
    const HTStructuredClass *isa;
    /* ... */
d113 2
a114 2
    const HTStreamClass *isa;
    /* ... */
d121 4
a124 3
static int fd_mosaic_connect_to_server(char *host_name,
				       long port,
				       long *fd)
d126 4
a129 1
    char *dummy = NULL;
a130 1
    int result;
d132 1
a132 1
    HTSprintf0(&dummy, "%s//%s:%d/", STR_WAIS_URL, host_name, port);
d134 1
a134 1
    status = HTDoConnect(dummy, "WAIS", 210, (int *) fd);
d136 1
a136 5
	result = -1;
    } else if (status < 0) {
	result = 0;
    } else {
	result = 1;
d138 3
a140 2
    FREE(dummy);
    return result;
d145 4
a148 3
static int mosaic_connect_to_server(char *host_name,
				    long port,
				    long *fdp)
d150 5
a154 4
static int mosaic_connect_to_server(char *host_name,
				    long port,
				    FILE **fp)
#endif				/* VMS */
d157 1
a157 1
    FILE *file;
d162 1
a162 1
    rv = fd_mosaic_connect_to_server(host_name, port, &fd);
d164 1
a164 1
	HTAlert(gettext("Could not connect to WAIS server."));
d167 1
a167 1
	HTAlert(CONNECTION_INTERRUPTED);
d170 1
d172 2
a173 2
    if ((file = fdopen(fd, "r+")) == NULL) {
	HTAlert(gettext("Could not open WAIS connection for reading."));
d189 3
a191 1
static void showDiags(HTStream *target, diagnosticRecord ** d)
d207 2
a208 2
 *	-----------------------------------------
 */
d210 2
a211 2
static BOOL acceptable[256];
static BOOL acceptable_inited = NO;
d213 1
a213 1
static void init_acceptable(void)
d216 4
a219 7
    char *good =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";

    for (i = 0; i < 256; i++)
	acceptable[i] = NO;
    for (; *good; good++)
	acceptable[(unsigned int) *good] = YES;
d224 9
a232 8
 *	------------------------------------------
 *
 *
 * On exit,
 *	returns		nil if error
 *			pointer to malloced string (must be freed) if ok
 */
static char *WWW_from_archie(char *file)
d234 6
a239 8
    char *end;
    char *result;
    char *colon;

    for (end = file; *end > ' '; end++) ;	/* assumes ASCII encoding */
    result = (char *) malloc(10 + (end - file));
    if (!result)
	return result;		/* Malloc error */
d241 2
a242 2
    strncat(result, file, end - file);
    colon = strchr(result + 7, ':');	/* Expect colon after host */
d244 1
a244 1
	for (; colon[0]; colon[0] = colon[1], colon++) ;	/* move down */
d247 1
a247 1
}				/* WWW_from_archie */
d250 10
a259 10
 *	--------------------------------------
 *
 *  Bugs: A static buffer of finite size is used!
 *	The format of the docid MUST be good!
 *
 *  On exit,
 *	returns		nil if error
 *			pointer to malloced string (must be freed) if ok
 */
static char hex[17] = "0123456789ABCDEF";
d261 2
a262 1
static char *WWW_from_WAIS(any *docid)
d265 2
a266 3
    char *q = buf;
    char *p = (docid->bytes);
    char *result = NULL;
a267 1

d270 3
a272 4

	fprintf(tfp, "WAIS id (%d bytes) is ", (int) docid->size);
	for (p = docid->bytes; p < docid->bytes + docid->size; p++) {
	    if ((*p >= ' ') && (*p <= '~'))	/* Assume ASCII! */
d275 1
a275 1
		fprintf(tfp, "<%x>", (unsigned) *p);
d280 2
a281 2
	 (p < docid->bytes + docid->size) && (q < &buf[BIG]);) {
	CTRACE((tfp, "    Record type %d, length %d\n", p[0], p[1]));
d283 1
a283 1
	    CTRACE((tfp, "Eh?  DOCID record type of %d!\n", *p));
d285 2
a286 1
	} {			/* Bug fix -- allow any byte value 15 Apr 93 */
d290 1
a290 1
		*q++ = (i / 100) + '0';
d294 1
a294 1
		*q++ = (i / 10) + '0';
d301 1
a301 1
	for (i = 0; i < l; i++, p++) {
d303 1
a303 1
		*q++ = HEX_ESCAPE;	/* Means hex coming */
d306 2
a307 2
	    } else
		*q++ = *p;
d309 1
a309 1
	*q++ = ';';		/* Terminate field */
d312 9
a320 4
    CTRACE((tfp, "WWW form of id: %s\n", buf));
    StrAllocCopy(result, buf);
    return result;
}				/* WWW_from_WAIS */
d323 12
a334 10
 *	-------------------------------------------
 *
 *  On entry,
 *	docname		points to valid name produced originally by
 *			WWW_from_WAIS
 *  On exit,
 *	docid->size	is valid
 *	docid->bytes	is malloced and must later be freed.
 */
static any *WAIS_from_WWW(any *docid, char *docname)
d336 6
a341 6
    char *z;			/* Output pointer */
    char *sor;			/* Start of record - points to size field. */
    char *p;			/* Input pointer */
    char *q;			/* Poisition of "=" */
    char *s;			/* Position of semicolon */
    int n;			/* size */
d343 2
a344 2
    CTRACE((tfp, "WWW id (to become WAIS id): %s\n", docname));
    for (n = 0, p = docname; *p; p++) {		/* Count sizes of strings */
d349 1
a349 1
	    n = n - 2;		/* Save two bytes */
d353 2
a354 2
    if (!(docid->bytes = (char *) malloc(docid->size)))		/* result record */
	outofmem(__FILE__, "WAIS_from_WWW");
d357 2
a358 2
    for (p = docname; *p;) {	/* Convert of strings */
	/* Record type */
d360 1
a360 1
	*z = 0;			/* Initialize record type */
d362 1
a362 1
	    *z = *z * 10 + (*p++ - '0');	/* Decode decimal record type */
d377 3
a379 3
	z++;			/* Skip record size for now     */
	for (p = q + 1; *p != ';';) {
	    if (*p == HEX_ESCAPE) {
a381 1

d384 1
a384 1
		b = from_hex(c);
d388 1
a388 1
		*z++ = (b << 4) + from_hex(c);
d393 1
a393 1
	*sor = (z - sor - 1);	/* Fill in size -- not counting size itself */
d399 3
a401 4

	fprintf(tfp, "WAIS id (%d bytes) is ", (int) docid->size);
	for (p = docid->bytes; p < docid->bytes + docid->size; p++) {
	    if ((*p >= ' ') && (*p <= '~'))	/* Assume ASCII! */
d404 1
a404 1
		fprintf(tfp, "<%x>", (unsigned) *p);
d410 1
a410 1
}				/* WAIS_from_WWW */
d413 7
a419 6
 *	--------------------------------------
 */
static void output_text_record(HTStream *target,
			       WAISDocumentText *record,
			       boolean quote_string_quotes,
			       boolean binary)
d421 4
a424 5
    long count;

    /* printf(" Text\n");
       print_any("     DocumentID:  ", record->DocumentID);
       printf("     VersionNumber:  %d\n", record->VersionNumber);
d427 10
a436 11
    if (binary) {
	(*target->isa->put_block) (target,
				   record->DocumentText->bytes,
				   record->DocumentText->size);
	return;
    }

    for (count = 0; count < record->DocumentText->size; count++) {
	long ch = (unsigned char) record->DocumentText->bytes[count];

	if (ch == 27) {		/* What is this in for?  Tim */
d441 3
a443 4
		count += 1;	/* it is a term marker */
	    else
		count += 4;	/* it is a paragraph marker */
	} else if (ch == '\n' || ch == '\r') {
d445 1
a445 1
	} else if (HTCJK != NOCJK || ch == '\t' || isprint(ch)) {
a446 1
	}
d448 2
a449 1
}				/* output text record */
d451 3
a453 3
/*	Format A Search response for the client		display_search_response
 *	---------------------------------------
 */
d457 5
a461 3
static void display_search_response(HTStructured * target, SearchResponseAPDU *response,
				    char *database,
				    char *keywords)
d463 1
a463 1
    WAISSearchResponse *info;
d466 1
a466 1
    BOOL archie = strstr(database, "archie") != 0;	/* Special handling */
d468 1
a468 1
    CTRACE((tfp, "HTWAIS: Displaying search response\n"));
d474 2
a475 2
	    (int) (response->NumberOfRecordsReturned),
	    response->NumberOfRecordsReturned == 1 ? "" : "s");
d489 2
a490 2
	info = (WAISSearchResponse *) response->DatabaseDiagnosticRecords;
	i = 0;
d493 1
a493 1
	    showDiags((HTStream *) target, info->Diagnostics);
d496 5
a500 5
	    for (k = 0; info->DocHeaders[k] != 0; k++) {
		WAISDocumentHeader *head = info->DocHeaders[k];
		char *headline = trim_junk(head->Headline);
		any *docid = head->DocumentID;
		char *docname;	/* printable version of docid */
d504 7
a510 7
		 * Make a printable string out of the document id.
		 */
		CTRACE((tfp, "HTWAIS:  %2ld: Score: %4ld, lines:%4ld '%s'\n",
			i,
			(long int) (info->DocHeaders[k]->Score),
			(long int) (info->DocHeaders[k]->Lines),
			headline));
d515 1
a515 2
		    char *www_name = WWW_from_archie(headline);

d525 2
a526 2
		} else {	/* Not archie */
		    docname = WWW_from_WAIS(docid);
d528 12
a539 17
			if ((head->Types) &&
			    (!strcmp(head->Types[0], "URL"))) {
			    HTStartAnchor(target, NULL, headline);
			} else {
			    char *dbname = HTEscape(database, URL_XPALPHAS);
			    char *w3_address = NULL;

			    HTSprintf0(&w3_address,
				       "/%s/%s/%d/%s",
				       dbname,
				       head->Types ? head->Types[0] : "TEXT",
				       (int) (head->DocumentLength),
				       docname);
			    HTStartAnchor(target, NULL, w3_address);
			    FREE(w3_address);
			    FREE(dbname);
			}
d542 1
d552 1
a552 1
		PUTS(line);
d554 3
a556 3
	    }			/* next document header */
	}
	/* if there were any document headers */
d561 1
a561 1
		PUTS(gettext("(Short Header record, can't display)"));
d568 1
a568 1
		PUTS(gettext("\nLong Header record, can't display\n"));
d575 2
a576 2
		PUTS(gettext("\nText record\n"));
		output_text_record((HTStream *) target,
d584 1
a584 1
		PUTS(gettext("\nHeadline record, can't display\n"));
d592 1
a592 1
		PUTS(gettext("\nCode record, can't display\n"));
d596 1
a596 1
    }				/* Loop: display user info */
d602 10
a611 8
 *		============
 *
 *  This renders any object or search as required.
 */
int HTLoadWAIS(const char *arg,
	       HTParentAnchor *anAnchor,
	       HTFormat format_out,
	       HTStream *sink)
d619 7
a625 5
    char *key;			/* pointer to keywords in URL */
    char *request_message = NULL;	/* arbitrary message limit */
    char *response_message = NULL;	/* arbitrary message limit */
    long request_buffer_length;	/* how of the request is left */
    SearchResponseAPDU *retrieval_response = 0;
d628 2
a629 2
    char *wais_database = NULL;	/* name of current database */
    char *www_database;		/* Same name escaped */
a634 1

a636 1

d640 1
a640 1
    char *names;		/* Copy of arg to be hacked up */
d645 2
d650 5
a654 5
    /* Decipher and check syntax of WWW address:
     * ----------------------------------------
     *
     * First we remove the "wais:" if it was specified.  920110
     */
d659 3
a661 6
	char *p;

	*key++ = 0;		/* Split off keywords */
	for (p = key; *p; p++)
	    if (*p == '+')
		*p = ' ';
d665 2
a666 2
	server_name = names + 1;
	if ((as_gate = (*server_name == '/')) != 0)
d668 1
a668 1
	www_database = strchr(server_name, '/');
d670 1
a670 1
	    *www_database++ = 0;	/* Separate database name */
d672 3
a674 4
	    if (key)
		ok = YES;	/* Don't need doc details */
	    else if (doctype) {	/* If not search parse doc details */
		*doctype++ = 0;	/* Separate rest of doc address */
d684 4
a687 4
			}	/* if docname */
		    }		/* if document_length valid */
		}		/* if doclength */
	    } else {		/* no doctype?  Assume index required */
d691 2
a692 2
	    }			/* if doctype */
	}			/* if database */
d698 1
a698 1
    CTRACE((tfp, "HTWAIS: Parsed OK\n"));
d715 1
a715 2

	CTRACE((tfp, "===WAIS=== calling mosaic_connect_to_server\n"));
d720 1
a720 1
	    CTRACE((tfp, "===WAIS=== connection failed\n"));
d724 1
a724 1
	    CTRACE((tfp, "===WAIS=== connection interrupted\n"));
d730 1
a730 1
    StrAllocCopy(wais_database, www_database);
d734 2
a735 2
     * This below fixed size stuff is terrible.
     */
d737 6
a742 5
    if ((request_message = typecallocn(char, MAX_MESSAGE_LEN)) == 0)
	  outofmem(__FILE__, "HTLoadWAIS");
    if ((response_message = typecallocn(char, MAX_MESSAGE_LEN)) == 0)
	  outofmem(__FILE__, "HTLoadWAIS");

d744 2
a745 2
    request_message = (char *) s_malloc((size_t) MAX_MESSAGE_LEN * sizeof(char));
    response_message = (char *) s_malloc((size_t) MAX_MESSAGE_LEN * sizeof(char));
d749 5
a753 5
     * If keyword search is performed but there are no keywords, the user has
     * followed a link to the index itself.  It would be appropriate at this
     * point to send him the .SRC file - how?
     */
    if (key && !*key) {		/* I N D E X */
d755 2
a756 2
	char *filename = NULL;
	FILE *fp;
d758 1
a758 1
	HTStructured *target = HTML_new(anAnchor, format_out, sink);
d762 1
a762 1
	HTStartIsIndex(target, HTWAIS_SOLICIT_QUERY, NULL);
d789 2
a790 2
	 * If we have seen a source file for this database, use that.
	 */
d792 3
a794 3
	HTSprintf0(&filename, "%sWSRC-%s:%s:%.100s.txt",
		   CACHE_FILE_PREFIX,
		   server_name, service, www_database);
d797 3
a799 3
	CTRACE((tfp, "HTWAIS: Description of server %s %s.\n",
		filename,
		fp ? "exists already" : "does NOT exist!"));
d803 1
a803 2

	    START(HTML_PRE);	/* Preformatted description */
d805 1
a805 2
	    while ((c = getc(fp)) != EOF)
		PUTC(c);	/* Transfer file */
a808 1
	FREE(filename);
d814 1
a814 1
    } else if (key) {		/* S E A R C H */
d816 1
a816 1
	HTStructured *target;
d819 1
a819 2
	while ((p = strchr(keywords, '+')) != 0)
	    *p = ' ';
d822 2
a823 2
	 * Send advance title to get something fast to the other end.
	 */
d852 7
a858 7
	request_buffer_length = MAX_MESSAGE_LEN;	/* Amount left */
	CTRACE((tfp, "HTWAIS: Search for `%s' in `%s'\n",
		keywords, wais_database));
	if (NULL ==
	    generate_search_apdu(request_message + HEADER_LENGTH,
				 &request_buffer_length,
				 keywords, wais_database, NULL, MAXDOCS)) {
d860 1
a860 1
	    HTAlert(gettext("HTWAIS: Request too large."));
d870 7
a876 7
	rv = interpret_message(request_message,
			       MAX_MESSAGE_LEN - request_buffer_length,
			       response_message,
			       MAX_MESSAGE_LEN,
			       connection,
			       false	/* true verbose */
	    );
d879 1
a879 1
	    HTAlert(gettext("Search interrupted."));
d885 1
a885 1
	    HTAlert(HTWAIS_MESSAGE_TOO_BIG);
d892 2
a893 3
	} else {		/* returned message ok */
	    SearchResponseAPDU *query_response = 0;

d895 1
a895 1
				   response_message + HEADER_LENGTH);
d897 1
a897 1
				    query_response, wais_database, keywords);
d899 4
a902 3
		freeWAISSearchResponse(query_response->DatabaseDiagnosticRecords);
	    freeSearchResponseAPDU(query_response);
	}			/* returned message not too large */
d906 2
a907 2
	boolean binary;		/* how to transfer stuff coming over */
	HTStream *target;
d909 2
a910 2
	any doc_chunk;
	any *docid = &doc_chunk;
d912 2
a913 3
	CTRACE((tfp,
		"HTWAIS: Retrieve document id `%s' type `%s' length %ld\n",
		docname, doctype, document_length));
d916 5
a920 5
	    !strcmp(doctype, "WSRC") ? HTAtom_for("application/x-wais-source") :
	    !strcmp(doctype, "TEXT") ? HTAtom_for("text/plain") :
	    !strcmp(doctype, "HTML") ? HTAtom_for("text/html") :
	    !strcmp(doctype, "GIF") ? HTAtom_for("image/gif") :
	    HTAtom_for("application/octet-stream");
d922 3
a924 3
	    0 != strcmp(doctype, "WSRC") &&
	    0 != strcmp(doctype, "TEXT") &&
	    0 != strcmp(doctype, "HTML");
d931 2
a932 2
	 * Decode hex or litteral format for document ID.
	 */
d936 2
a937 2
	 * Loop over slices of the document.
	 */
d948 2
a949 2
	    request_buffer_length = MAX_MESSAGE_LEN;	/* Amount left */
	    CTRACE((tfp, "HTWAIS: Slice number %ld\n", count));
d952 2
a953 2
		HTAlert(TRANSFER_INTERRUPTED);
		(*target->isa->_abort) (target, NULL);
d967 3
a969 3
					(((count + 1) * CHARS_PER_PAGE <= document_length)
					 ? (count + 1) * CHARS_PER_PAGE
					 : document_length),
d973 1
a973 1
		HTAlert(gettext("HTWAIS: Request too long."));
d985 2
a986 2
	     * Actually do the transaction given by request_message.
	     */
d993 2
a994 2
				   false	/* true verbose */
		);
d996 1
a996 1
		HTAlert(TRANSFER_INTERRUPTED);
d1004 1
a1004 1
		HTAlert(HTWAIS_MESSAGE_TOO_BIG);
d1016 2
a1017 2
	     * Parse the result which came back into memory.
	     */
d1025 1
a1025 1
		   wais_database, keywords); */
d1031 1
a1031 1
				    retrieval_response->DatabaseDiagnosticRecords)->Text[0],
d1033 1
a1033 1
	    }			/* If text existed */
d1038 1
a1038 1
	}			/* Loop over slices */
d1043 2
a1044 2
	freeWAISSearchResponse(retrieval_response->DatabaseDiagnosticRecords);
	freeSearchResponseAPDU(retrieval_response);
d1046 1
a1046 1
    }				/* If document rather than search */
d1048 1
a1048 1
  CleanUp:
d1050 2
a1051 2
     * (This postponed until later, after a timeout:)
     */
d1054 1
a1054 1
	NETCLOSE((int) connection);
d1075 1
a1075 2
GLOBALDEF HTProtocol HTWAIS =
{"wais", HTLoadWAIS, NULL};
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a77 1
#include <LYUtils.h>
d89 5
d122 1
a122 1
	char *,		host_name,
d124 1
a124 1
	long *,		fd)
d126 4
a129 1
    char *dummy = NULL;
a130 1
    int result;
d132 1
a132 1
    HTSprintf0(&dummy, "%s//%s:%d/", STR_WAIS_URL, host_name, port);
d136 1
a136 5
	result = -1;
    } else if (status < 0) {
	result = 0;
    } else {
	result = 1;
d138 3
a140 2
    FREE(dummy);
    return result;
d146 1
a146 1
	char *,		host_name,
d148 1
a148 1
	long *,		fdp)
d151 1
a151 1
	char *,		host_name,
d228 1
a228 1
**	returns		nil if error
d232 1
a232 1
	char *,		file)
d239 1
a239 1
    if (!result) return result;		/* Malloc error */
d256 1
a256 1
**	returns		nil if error
a266 1
    char * result = NULL;
a267 1

d281 1
a281 1
	CTRACE((tfp, "    Record type %d, length %d\n", p[0], p[1]));
d283 1
a283 1
	    CTRACE((tfp, "Eh?  DOCID record type of %d!\n", *p));
d303 1
a303 1
		*q++ = HEX_ESCAPE;	/* Means hex coming */
d312 8
a319 3
    CTRACE((tfp, "WWW form of id: %s\n", buf));
    StrAllocCopy(result, buf);
    return result;
d326 1
a326 1
**	docname		points to valid name produced originally by
d334 1
a334 1
	char *,		docname)
d343 1
a343 1
    CTRACE((tfp, "WWW id (to become WAIS id): %s\n", docname));
d360 1
a360 1
	*z = 0;			/* Initialize record type */
d416 2
a417 2
    HTStream *,			target,
    WAISDocumentText *,		record,
d441 1
a441 1
	    count += 1;		    /* it is a term marker */
d451 1
a451 1
/*	Format A Search response for the client		display_search_response
d466 1
a466 1
    BOOL archie =  strstr(database, "archie")!=0;	/* Special handling */
d468 1
a468 1
    CTRACE((tfp, "HTWAIS: Displaying search response\n"));
d500 1
a500 1
		char * docname;		/* printable version of docid */
d506 1
a506 1
		CTRACE((tfp, "HTWAIS:  %2ld: Score: %4ld, lines:%4ld '%s'\n",
d510 1
a510 1
			    headline));
d528 12
a539 16
			if ((head->Types) &&
			   (!strcmp(head->Types[0], "URL"))) {
			    HTStartAnchor(target, NULL, headline);
			} else{
			    char * dbname = HTEscape(database, URL_XPALPHAS);
			    char * w3_address = NULL;
			    HTSprintf0(&w3_address,
					"/%s/%s/%d/%s",
					dbname,
					head->Types ? head->Types[0] : "TEXT",
					(int)(head->DocumentLength),
					docname);
			    HTStartAnchor(target, NULL, w3_address);
			    FREE(w3_address);
			    FREE(dbname);
			}
d542 1
d619 3
a621 1
    char * key;			  /* pointer to keywords in URL */
d628 2
a629 2
    char *wais_database = NULL;		/* name of current database */
    char *www_database;			/* Same name escaped */
d645 2
d653 1
a653 1
    **	First we remove the "wais:" if it was specified.  920110
d666 1
a666 1
	if ((as_gate =(*server_name == '/')) != 0)
d698 1
a698 1
    CTRACE((tfp, "HTWAIS: Parsed OK\n"));
d715 1
a715 1
	CTRACE((tfp, "===WAIS=== calling mosaic_connect_to_server\n"));
d720 1
a720 1
	    CTRACE((tfp, "===WAIS=== connection failed\n"));
d724 1
a724 1
	    CTRACE((tfp, "===WAIS=== connection interrupted\n"));
d737 2
a738 1
    if ((request_message = typecallocn(char, MAX_MESSAGE_LEN)) == 0)
d740 2
a741 1
    if ((response_message = typecallocn(char, MAX_MESSAGE_LEN)) == 0)
d753 1
a753 1
    if (key && !*key) {				/* I N D E X */
d755 1
a755 1
	char * filename = NULL;
d792 1
a792 1
	HTSprintf0(&filename, "%sWSRC-%s:%s:%.100s.txt",
d797 1
a797 1
	CTRACE((tfp, "HTWAIS: Description of server %s %s.\n",
d799 1
a799 1
		    fp ? "exists already" : "does NOT exist!"));
a808 1
	FREE(filename);
d819 1
a819 2
	while ((p = strchr(keywords, '+')) != 0)
	    *p = ' ';
d853 2
a854 2
	CTRACE((tfp, "HTWAIS: Search for `%s' in `%s'\n",
		    keywords, wais_database));
d912 2
a913 2
	CTRACE((tfp, "HTWAIS: Retrieve document id `%s' type `%s' length %ld\n",
		    docname, doctype, document_length));
d949 1
a949 1
	    CTRACE((tfp, "HTWAIS: Slice number %ld\n", count));
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d90 1
a90 1
static BOOL	as_gate;	/* Client is using us as gateway */
d92 1
a92 1
static char	line[2048];	/* For building strings to display */
d104 1
a104 1
	const HTStructuredClass *	isa;
d109 1
a109 1
	const HTStreamClass *	isa;
d117 4
a120 4
static int fd_mosaic_connect_to_server (
	char *		host_name,
	long		port,
	long *		fd)
d142 9
a150 9
static int mosaic_connect_to_server (
	char *		host_name,
	long		port,
	long *		fdp)
#else
static int mosaic_connect_to_server (
	char *		host_name,
	long		port,
	FILE **	fp)
d186 3
a188 3
static void showDiags (
	HTStream *		target,
	diagnosticRecord **	d)
d207 2
a208 2
static BOOL acceptable[256];
static BOOL acceptable_inited = NO;
d210 1
a210 1
static void init_acceptable (void)
d228 2
a229 2
static char * WWW_from_archie (
	char *		file)
d256 1
a256 1
static char hex [17] = "0123456789ABCDEF";
d258 2
a259 2
static char * WWW_from_WAIS (
	any *		docid)
d326 3
a328 3
static any * WAIS_from_WWW (
	any *		docid,
	char *		docname)
d409 5
a413 5
static void output_text_record (
    HTStream *			target,
    WAISDocumentText *		record,
    boolean			quote_string_quotes,
    boolean			binary)
d451 5
a455 5
static void display_search_response (
    HTStructured *		target,
    SearchResponseAPDU *	response,
    char *			database,
    char *			keywords)
d603 5
a607 5
int HTLoadWAIS (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d1068 1
a1068 1
GLOBALDEF HTProtocol HTWAIS = { "wais", HTLoadWAIS, NULL };
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 42
a43 42
 *	==================================================
 *
 *	This module allows a WWW server or client to read data from a
 *	remote	WAIS
 *  server, and provide that data to a WWW client in hypertext form.
 *  Source files, once retrieved, are stored and used to provide
 *  information about the index when that is acessed.
 *
 *  Authors
 *	BK	Brewster Kahle, Thinking Machines, <Brewster@@think.com>
 *	TBL	Tim Berners-Lee, CERN <timbl@@info.cern.ch>
 *	FM	Foteos Macrides, WFEB <macrides@@sci.wfeb.edu>
 *
 *  History
 *	   Sep 91	TBL adapted shell-ui.c (BK) with HTRetrieve.c from WWW.
 *	   Feb 91	TBL Generated HTML cleaned up a bit (quotes, escaping)
 *			    Refers to lists of sources.
 *	   Mar 93	TBL Lib 2.0 compatible module made.
 *	   May 94	FM  Added DIRECT_WAIS support for VMS.
 *
 *  Bugs
 *	Uses C stream i/o to read and write sockets, which won't work
 *	on VMS TCP systems.
 *
 *	Should cache connections.
 *
 *	ANSI C only as written
 *
 *  Bugs fixed
 *	NT Nathan Torkington (Nathan.Torkington@@vuw.ac.nz)
 *
 *  WAIS comments:
 *
 *	1.	Separate directories for different system's .o would help
 *	2.	Document ids are rather long!
 *
 * W WW Address mapping convention:
 *
 *	/servername/database/type/length/document-id
 *
 *	/servername/database?word+word+word
 */
d61 2
a62 2
 *			---------
 */
d71 1
a71 1
#define CHARS_PER_PAGE 10000	/* number of chars retrieved in each request */
d76 2
a77 2
 *			--------
 */
d84 1
a84 1
#define BIG 1024		/* identifier size limit  @@@@@@@@@@ */
d90 1
a90 3
static BOOL as_gate;		/* Client is using us as gateway */

static char line[2048];		/* For building strings to display */
d92 1
d104 2
a105 2
    const HTStructuredClass *isa;
    /* ... */
d109 2
a110 2
    const HTStreamClass *isa;
    /* ... */
d117 4
a120 3
static int fd_mosaic_connect_to_server(char *host_name,
				       long port,
				       long *fd)
d128 1
a128 1
    status = HTDoConnect(dummy, "WAIS", 210, (int *) fd);
d142 4
a145 3
static int mosaic_connect_to_server(char *host_name,
				    long port,
				    long *fdp)
d147 5
a151 4
static int mosaic_connect_to_server(char *host_name,
				    long port,
				    FILE **fp)
#endif				/* VMS */
d154 1
a154 1
    FILE *file;
d159 1
a159 1
    rv = fd_mosaic_connect_to_server(host_name, port, &fd);
d161 1
a161 1
	HTAlert(gettext("Could not connect to WAIS server."));
d164 1
a164 1
	HTAlert(CONNECTION_INTERRUPTED);
d167 1
d169 2
a170 2
    if ((file = fdopen(fd, "r+")) == NULL) {
	HTAlert(gettext("Could not open WAIS connection for reading."));
d186 3
a188 1
static void showDiags(HTStream *target, diagnosticRecord ** d)
d204 2
a205 2
 *	-----------------------------------------
 */
d210 1
a210 1
static void init_acceptable(void)
d213 4
a216 7
    char *good =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";

    for (i = 0; i < 256; i++)
	acceptable[i] = NO;
    for (; *good; good++)
	acceptable[(unsigned int) *good] = YES;
d221 9
a229 8
 *	------------------------------------------
 *
 *
 * On exit,
 *	returns		nil if error
 *			pointer to malloced string (must be freed) if ok
 */
static char *WWW_from_archie(char *file)
d231 6
a236 8
    char *end;
    char *result;
    char *colon;

    for (end = file; *end > ' '; end++) ;	/* assumes ASCII encoding */
    result = (char *) malloc(10 + (end - file));
    if (!result)
	return result;		/* Malloc error */
d238 2
a239 2
    strncat(result, file, end - file);
    colon = strchr(result + 7, ':');	/* Expect colon after host */
d241 1
a241 1
	for (; colon[0]; colon[0] = colon[1], colon++) ;	/* move down */
d244 1
a244 1
}				/* WWW_from_archie */
d247 10
a256 10
 *	--------------------------------------
 *
 *  Bugs: A static buffer of finite size is used!
 *	The format of the docid MUST be good!
 *
 *  On exit,
 *	returns		nil if error
 *			pointer to malloced string (must be freed) if ok
 */
static char hex[17] = "0123456789ABCDEF";
d258 2
a259 1
static char *WWW_from_WAIS(any *docid)
d262 3
a264 3
    char *q = buf;
    char *p = (docid->bytes);
    char *result = NULL;
d269 3
a271 4

	fprintf(tfp, "WAIS id (%d bytes) is ", (int) docid->size);
	for (p = docid->bytes; p < docid->bytes + docid->size; p++) {
	    if ((*p >= ' ') && (*p <= '~'))	/* Assume ASCII! */
d274 1
a274 1
		fprintf(tfp, "<%x>", (unsigned) *p);
d279 1
a279 1
	 (p < docid->bytes + docid->size) && (q < &buf[BIG]);) {
d284 2
a285 1
	} {			/* Bug fix -- allow any byte value 15 Apr 93 */
d289 1
a289 1
		*q++ = (i / 100) + '0';
d293 1
a293 1
		*q++ = (i / 10) + '0';
d300 1
a300 1
	for (i = 0; i < l; i++, p++) {
d305 2
a306 2
	    } else
		*q++ = *p;
d308 1
a308 1
	*q++ = ';';		/* Terminate field */
d314 1
a314 1
}				/* WWW_from_WAIS */
d317 12
a328 10
 *	-------------------------------------------
 *
 *  On entry,
 *	docname		points to valid name produced originally by
 *			WWW_from_WAIS
 *  On exit,
 *	docid->size	is valid
 *	docid->bytes	is malloced and must later be freed.
 */
static any *WAIS_from_WWW(any *docid, char *docname)
d330 6
a335 6
    char *z;			/* Output pointer */
    char *sor;			/* Start of record - points to size field. */
    char *p;			/* Input pointer */
    char *q;			/* Poisition of "=" */
    char *s;			/* Position of semicolon */
    int n;			/* size */
d338 1
a338 1
    for (n = 0, p = docname; *p; p++) {		/* Count sizes of strings */
d343 1
a343 1
	    n = n - 2;		/* Save two bytes */
d347 2
a348 2
    if (!(docid->bytes = (char *) malloc(docid->size)))		/* result record */
	outofmem(__FILE__, "WAIS_from_WWW");
d351 2
a352 2
    for (p = docname; *p;) {	/* Convert of strings */
	/* Record type */
d356 1
a356 1
	    *z = *z * 10 + (*p++ - '0');	/* Decode decimal record type */
d371 3
a373 3
	z++;			/* Skip record size for now     */
	for (p = q + 1; *p != ';';) {
	    if (*p == HEX_ESCAPE) {
a375 1

d378 1
a378 1
		b = from_hex(c);
d382 1
a382 1
		*z++ = (b << 4) + from_hex(c);
d387 1
a387 1
	*sor = (z - sor - 1);	/* Fill in size -- not counting size itself */
d393 3
a395 4

	fprintf(tfp, "WAIS id (%d bytes) is ", (int) docid->size);
	for (p = docid->bytes; p < docid->bytes + docid->size; p++) {
	    if ((*p >= ' ') && (*p <= '~'))	/* Assume ASCII! */
d398 1
a398 1
		fprintf(tfp, "<%x>", (unsigned) *p);
d404 1
a404 1
}				/* WAIS_from_WWW */
d407 7
a413 6
 *	--------------------------------------
 */
static void output_text_record(HTStream *target,
			       WAISDocumentText *record,
			       boolean quote_string_quotes,
			       boolean binary)
d415 4
a418 5
    long count;

    /* printf(" Text\n");
       print_any("     DocumentID:  ", record->DocumentID);
       printf("     VersionNumber:  %d\n", record->VersionNumber);
d421 10
a430 11
    if (binary) {
	(*target->isa->put_block) (target,
				   record->DocumentText->bytes,
				   record->DocumentText->size);
	return;
    }

    for (count = 0; count < record->DocumentText->size; count++) {
	long ch = (unsigned char) record->DocumentText->bytes[count];

	if (ch == 27) {		/* What is this in for?  Tim */
d435 3
a437 4
		count += 1;	/* it is a term marker */
	    else
		count += 4;	/* it is a paragraph marker */
	} else if (ch == '\n' || ch == '\r') {
d439 1
a439 1
	} else if (HTCJK != NOCJK || ch == '\t' || isprint(ch)) {
a440 1
	}
d442 2
a443 1
}				/* output text record */
d446 2
a447 2
 *	---------------------------------------
 */
d451 5
a455 3
static void display_search_response(HTStructured * target, SearchResponseAPDU *response,
				    char *database,
				    char *keywords)
d457 1
a457 1
    WAISSearchResponse *info;
d460 1
a460 1
    BOOL archie = strstr(database, "archie") != 0;	/* Special handling */
d468 2
a469 2
	    (int) (response->NumberOfRecordsReturned),
	    response->NumberOfRecordsReturned == 1 ? "" : "s");
d483 2
a484 2
	info = (WAISSearchResponse *) response->DatabaseDiagnosticRecords;
	i = 0;
d487 1
a487 1
	    showDiags((HTStream *) target, info->Diagnostics);
d490 5
a494 5
	    for (k = 0; info->DocHeaders[k] != 0; k++) {
		WAISDocumentHeader *head = info->DocHeaders[k];
		char *headline = trim_junk(head->Headline);
		any *docid = head->DocumentID;
		char *docname;	/* printable version of docid */
d498 2
a499 2
		 * Make a printable string out of the document id.
		 */
d501 4
a504 4
			i,
			(long int) (info->DocHeaders[k]->Score),
			(long int) (info->DocHeaders[k]->Lines),
			headline));
d509 1
a509 2
		    char *www_name = WWW_from_archie(headline);

d519 2
a520 2
		} else {	/* Not archie */
		    docname = WWW_from_WAIS(docid);
d523 1
a523 1
			    (!strcmp(head->Types[0], "URL"))) {
d525 3
a527 4
			} else {
			    char *dbname = HTEscape(database, URL_XPALPHAS);
			    char *w3_address = NULL;

d529 5
a533 5
				       "/%s/%s/%d/%s",
				       dbname,
				       head->Types ? head->Types[0] : "TEXT",
				       (int) (head->DocumentLength),
				       docname);
d549 1
a549 1
		PUTS(line);
d551 3
a553 3
	    }			/* next document header */
	}
	/* if there were any document headers */
d558 1
a558 1
		PUTS(gettext("(Short Header record, can't display)"));
d565 1
a565 1
		PUTS(gettext("\nLong Header record, can't display\n"));
d572 2
a573 2
		PUTS(gettext("\nText record\n"));
		output_text_record((HTStream *) target,
d581 1
a581 1
		PUTS(gettext("\nHeadline record, can't display\n"));
d589 1
a589 1
		PUTS(gettext("\nCode record, can't display\n"));
d593 1
a593 1
    }				/* Loop: display user info */
d599 10
a608 8
 *		============
 *
 *  This renders any object or search as required.
 */
int HTLoadWAIS(const char *arg,
	       HTParentAnchor *anAnchor,
	       HTFormat format_out,
	       HTStream *sink)
d616 5
a620 5
    char *key;			/* pointer to keywords in URL */
    char *request_message = NULL;	/* arbitrary message limit */
    char *response_message = NULL;	/* arbitrary message limit */
    long request_buffer_length;	/* how of the request is left */
    SearchResponseAPDU *retrieval_response = 0;
d623 2
a624 2
    char *wais_database = NULL;	/* name of current database */
    char *www_database;		/* Same name escaped */
a629 1

a631 1

d635 1
a635 1
    char *names;		/* Copy of arg to be hacked up */
d643 5
a647 5
    /* Decipher and check syntax of WWW address:
     * ----------------------------------------
     *
     * First we remove the "wais:" if it was specified.  920110
     */
d652 3
a654 6
	char *p;

	*key++ = 0;		/* Split off keywords */
	for (p = key; *p; p++)
	    if (*p == '+')
		*p = ' ';
d658 2
a659 2
	server_name = names + 1;
	if ((as_gate = (*server_name == '/')) != 0)
d661 1
a661 1
	www_database = strchr(server_name, '/');
d663 1
a663 1
	    *www_database++ = 0;	/* Separate database name */
d665 3
a667 4
	    if (key)
		ok = YES;	/* Don't need doc details */
	    else if (doctype) {	/* If not search parse doc details */
		*doctype++ = 0;	/* Separate rest of doc address */
d677 4
a680 4
			}	/* if docname */
		    }		/* if document_length valid */
		}		/* if doclength */
	    } else {		/* no doctype?  Assume index required */
d684 2
a685 2
	    }			/* if doctype */
	}			/* if database */
a707 1

d723 1
a723 1
    StrAllocCopy(wais_database, www_database);
d727 2
a728 2
     * This below fixed size stuff is terrible.
     */
d731 1
a731 1
	  outofmem(__FILE__, "HTLoadWAIS");
d733 1
a733 2
	  outofmem(__FILE__, "HTLoadWAIS");

d735 2
a736 2
    request_message = (char *) s_malloc((size_t) MAX_MESSAGE_LEN * sizeof(char));
    response_message = (char *) s_malloc((size_t) MAX_MESSAGE_LEN * sizeof(char));
d740 5
a744 5
     * If keyword search is performed but there are no keywords, the user has
     * followed a link to the index itself.  It would be appropriate at this
     * point to send him the .SRC file - how?
     */
    if (key && !*key) {		/* I N D E X */
d746 2
a747 2
	char *filename = NULL;
	FILE *fp;
d749 1
a749 1
	HTStructured *target = HTML_new(anAnchor, format_out, sink);
d753 1
a753 1
	HTStartIsIndex(target, HTWAIS_SOLICIT_QUERY, NULL);
d780 2
a781 2
	 * If we have seen a source file for this database, use that.
	 */
d784 2
a785 2
		   CACHE_FILE_PREFIX,
		   server_name, service, www_database);
d789 2
a790 2
		filename,
		fp ? "exists already" : "does NOT exist!"));
d794 1
a794 2

	    START(HTML_PRE);	/* Preformatted description */
d796 1
a796 2
	    while ((c = getc(fp)) != EOF)
		PUTC(c);	/* Transfer file */
d806 1
a806 1
    } else if (key) {		/* S E A R C H */
d808 1
a808 1
	HTStructured *target;
d815 2
a816 2
	 * Send advance title to get something fast to the other end.
	 */
d845 1
a845 1
	request_buffer_length = MAX_MESSAGE_LEN;	/* Amount left */
d847 5
a851 5
		keywords, wais_database));
	if (NULL ==
	    generate_search_apdu(request_message + HEADER_LENGTH,
				 &request_buffer_length,
				 keywords, wais_database, NULL, MAXDOCS)) {
d853 1
a853 1
	    HTAlert(gettext("HTWAIS: Request too large."));
d863 7
a869 7
	rv = interpret_message(request_message,
			       MAX_MESSAGE_LEN - request_buffer_length,
			       response_message,
			       MAX_MESSAGE_LEN,
			       connection,
			       false	/* true verbose */
	    );
d872 1
a872 1
	    HTAlert(gettext("Search interrupted."));
d878 1
a878 1
	    HTAlert(HTWAIS_MESSAGE_TOO_BIG);
d885 2
a886 3
	} else {		/* returned message ok */
	    SearchResponseAPDU *query_response = 0;

d888 1
a888 1
				   response_message + HEADER_LENGTH);
d890 1
a890 1
				    query_response, wais_database, keywords);
d892 4
a895 3
		freeWAISSearchResponse(query_response->DatabaseDiagnosticRecords);
	    freeSearchResponseAPDU(query_response);
	}			/* returned message not too large */
d899 2
a900 2
	boolean binary;		/* how to transfer stuff coming over */
	HTStream *target;
d902 2
a903 2
	any doc_chunk;
	any *docid = &doc_chunk;
d905 2
a906 3
	CTRACE((tfp,
		"HTWAIS: Retrieve document id `%s' type `%s' length %ld\n",
		docname, doctype, document_length));
d909 5
a913 5
	    !strcmp(doctype, "WSRC") ? HTAtom_for("application/x-wais-source") :
	    !strcmp(doctype, "TEXT") ? HTAtom_for("text/plain") :
	    !strcmp(doctype, "HTML") ? HTAtom_for("text/html") :
	    !strcmp(doctype, "GIF") ? HTAtom_for("image/gif") :
	    HTAtom_for("application/octet-stream");
d915 3
a917 3
	    0 != strcmp(doctype, "WSRC") &&
	    0 != strcmp(doctype, "TEXT") &&
	    0 != strcmp(doctype, "HTML");
d924 2
a925 2
	 * Decode hex or litteral format for document ID.
	 */
d929 2
a930 2
	 * Loop over slices of the document.
	 */
d941 1
a941 1
	    request_buffer_length = MAX_MESSAGE_LEN;	/* Amount left */
d945 2
a946 2
		HTAlert(TRANSFER_INTERRUPTED);
		(*target->isa->_abort) (target, NULL);
d960 3
a962 3
					(((count + 1) * CHARS_PER_PAGE <= document_length)
					 ? (count + 1) * CHARS_PER_PAGE
					 : document_length),
d966 1
a966 1
		HTAlert(gettext("HTWAIS: Request too long."));
d978 2
a979 2
	     * Actually do the transaction given by request_message.
	     */
d986 2
a987 2
				   false	/* true verbose */
		);
d989 1
a989 1
		HTAlert(TRANSFER_INTERRUPTED);
d997 1
a997 1
		HTAlert(HTWAIS_MESSAGE_TOO_BIG);
d1009 2
a1010 2
	     * Parse the result which came back into memory.
	     */
d1018 1
a1018 1
		   wais_database, keywords); */
d1024 1
a1024 1
				    retrieval_response->DatabaseDiagnosticRecords)->Text[0],
d1026 1
a1026 1
	    }			/* If text existed */
d1031 1
a1031 1
	}			/* Loop over slices */
d1036 2
a1037 2
	freeWAISSearchResponse(retrieval_response->DatabaseDiagnosticRecords);
	freeSearchResponseAPDU(retrieval_response);
d1039 1
a1039 1
    }				/* If document rather than search */
d1041 1
a1041 1
  CleanUp:
d1043 2
a1044 2
     * (This postponed until later, after a timeout:)
     */
d1047 1
a1047 1
	NETCLOSE((int) connection);
d1068 1
a1068 2
GLOBALDEF HTProtocol HTWAIS =
{"wais", HTLoadWAIS, NULL};
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a77 1
#include <LYUtils.h>
d89 5
d122 1
a122 1
	char *,		host_name,
d124 1
a124 1
	long *,		fd)
d126 4
a129 1
    char *dummy = NULL;
a130 1
    int result;
d132 1
a132 1
    HTSprintf0(&dummy, "wais://%s:%d/", host_name, port);
d136 1
a136 5
	result = -1;
    } else if (status < 0) {
	result = 0;
    } else {
	result = 1;
d138 3
a140 2
    FREE(dummy);
    return result;
d146 1
a146 1
	char *,		host_name,
d148 1
a148 1
	long *,		fdp)
d151 1
a151 1
	char *,		host_name,
d228 1
a228 1
**	returns		nil if error
d232 1
a232 1
	char *,		file)
d239 1
a239 1
    if (!result) return result;		/* Malloc error */
d256 1
a256 1
**	returns		nil if error
a266 1
    char * result = NULL;
a267 1

d281 1
a281 1
	CTRACE((tfp, "    Record type %d, length %d\n", p[0], p[1]));
d283 1
a283 1
	    CTRACE((tfp, "Eh?  DOCID record type of %d!\n", *p));
d303 1
a303 1
		*q++ = HEX_ESCAPE;	/* Means hex coming */
d312 8
a319 3
    CTRACE((tfp, "WWW form of id: %s\n", buf));
    StrAllocCopy(result, buf);
    return result;
d326 1
a326 1
**	docname		points to valid name produced originally by
d334 1
a334 1
	char *,		docname)
d343 1
a343 1
    CTRACE((tfp, "WWW id (to become WAIS id): %s\n", docname));
d360 1
a360 1
	*z = 0;			/* Initialize record type */
d416 2
a417 2
    HTStream *,			target,
    WAISDocumentText *,		record,
d441 1
a441 1
	    count += 1;		    /* it is a term marker */
d451 1
a451 1
/*	Format A Search response for the client		display_search_response
d466 1
a466 1
    BOOL archie =  strstr(database, "archie")!=0;	/* Special handling */
d468 1
a468 1
    CTRACE((tfp, "HTWAIS: Displaying search response\n"));
d500 1
a500 1
		char * docname;		/* printable version of docid */
d506 1
a506 1
		CTRACE((tfp, "HTWAIS:  %2ld: Score: %4ld, lines:%4ld '%s'\n",
d510 1
a510 1
			    headline));
d528 12
a539 16
			if ((head->Types) &&
			   (!strcmp(head->Types[0], "URL"))) {
			    HTStartAnchor(target, NULL, headline);
			} else{
			    char * dbname = HTEscape(database, URL_XPALPHAS);
			    char * w3_address = NULL;
			    HTSprintf0(&w3_address,
					"/%s/%s/%d/%s",
					dbname,
					head->Types ? head->Types[0] : "TEXT",
					(int)(head->DocumentLength),
					docname);
			    HTStartAnchor(target, NULL, w3_address);
			    FREE(w3_address);
			    FREE(dbname);
			}
d542 1
d619 3
a621 1
    char * key;			  /* pointer to keywords in URL */
d628 2
a629 2
    char *wais_database = NULL;		/* name of current database */
    char *www_database;			/* Same name escaped */
d653 1
a653 1
    **	First we remove the "wais:" if it was specified.  920110
d666 1
a666 1
	if ((as_gate =(*server_name == '/')) != 0)
d698 1
a698 1
    CTRACE((tfp, "HTWAIS: Parsed OK\n"));
d715 1
a715 1
	CTRACE((tfp, "===WAIS=== calling mosaic_connect_to_server\n"));
d720 1
a720 1
	    CTRACE((tfp, "===WAIS=== connection failed\n"));
d724 1
a724 1
	    CTRACE((tfp, "===WAIS=== connection interrupted\n"));
d737 2
a738 1
    if ((request_message = typecallocn(char, MAX_MESSAGE_LEN)) == 0)
d740 2
a741 1
    if ((response_message = typecallocn(char, MAX_MESSAGE_LEN)) == 0)
d753 1
a753 1
    if (key && !*key) {				/* I N D E X */
d755 1
a755 1
	char * filename = NULL;
d792 1
a792 1
	HTSprintf0(&filename, "%sWSRC-%s:%s:%.100s.txt",
d797 1
a797 1
	CTRACE((tfp, "HTWAIS: Description of server %s %s.\n",
d799 1
a799 1
		    fp ? "exists already" : "does NOT exist!"));
a808 1
	FREE(filename);
d819 1
a819 2
	while ((p = strchr(keywords, '+')) != 0)
	    *p = ' ';
d853 2
a854 2
	CTRACE((tfp, "HTWAIS: Search for `%s' in `%s'\n",
		    keywords, wais_database));
d912 2
a913 2
	CTRACE((tfp, "HTWAIS: Retrieve document id `%s' type `%s' length %ld\n",
		    docname, doctype, document_length));
d949 1
a949 1
	    CTRACE((tfp, "HTWAIS: Slice number %ld\n", count));
@

