head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.07.15.18.16.31;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.25;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.57.59;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.05;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.53;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.10;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.52;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.16;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.47.29;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@automatic merge of lynx-current
@
text
@/*                  Binary Tree for sorting things
 *                  ==============================
 *                      Author: Arthur Secret
 *
 *       4 March 94: Bug fixed in the balancing procedure
 *
 */

#include <HTUtils.h>
#include <HTBTree.h>

#define MAXIMUM(a,b) ((a)>(b)?(a):(b))

#include <LYLeaks.h>

/*********************************************************
 * This function returns an HTBTree with memory allocated
 * for it when given a mean to compare things
 */
HTBTree *HTBTree_new(HTComparer comp)
{
    HTBTree *tree = typeMalloc(HTBTree);

    if (tree == NULL)
	outofmem(__FILE__, "HTBTree_new");

    tree->compare = comp;
    tree->top = NULL;

    return tree;
}

/*********************************************************
 * This void will free the memory allocated for one element
 */
static void HTBTElement_free(HTBTElement *element)
{
    if (element) {
	if (element->left != NULL)
	    HTBTElement_free(element->left);
	if (element->right != NULL)
	    HTBTElement_free(element->right);
	FREE(element);
    }
}

/*************************************************************
 * This void will free the memory allocated for the whole tree
 */
void HTBTree_free(HTBTree *tree)
{
    HTBTElement_free(tree->top);
    FREE(tree);
}

/*********************************************************
 * This void will free the memory allocated for one element
 */
static void HTBTElementAndObject_free(HTBTElement *element)
{
    if (element) {		/* Just in case nothing was in the tree anyway */
	if (element->left != NULL)
	    HTBTElementAndObject_free(element->left);
	if (element->right != NULL)
	    HTBTElementAndObject_free(element->right);
	FREE(element->object);
	FREE(element);
    }
}

/*************************************************************
 * This void will free the memory allocated for the whole tree
 */
void HTBTreeAndObject_free(HTBTree *tree)
{
    HTBTElementAndObject_free(tree->top);
    FREE(tree);
}

/*********************************************************************
 * Returns a pointer to equivalent object in a tree or NULL if none.
 */
void *HTBTree_search(HTBTree *tree,
		     void *object)
{
    HTBTElement *cur = tree->top;
    int res;

    while (cur != NULL) {
	res = tree->compare(object, cur->object);

	if (res == 0)
	    return cur->object;
	else if (res < 0)
	    cur = cur->left;
	else if (res > 0)
	    cur = cur->right;
    }
    return NULL;
}

/*********************************************************************
 * This void is the core of HTBTree.c . It will
 *       1/ add a new element to the tree at the right place
 *		so that the tree remains sorted
 *       2/ balance the tree to be as fast as possible when reading it
 */
void HTBTree_add(HTBTree *tree,
		 void *object)
{
    HTBTElement *father_of_element;
    HTBTElement *added_element;
    HTBTElement *forefather_of_element;
    HTBTElement *father_of_forefather;
    BOOL father_found, top_found;
    int depth, depth2, corrections;

    /* father_of_element is a pointer to the structure that is the father of
     * the new object "object".  added_element is a pointer to the structure
     * that contains or will contain the new object "object". 
     * father_of_forefather and forefather_of_element are pointers that are
     * used to modify the depths of upper elements, when needed.
     *
     * father_found indicates by a value NO when the future father of "object"
     * is found.  top_found indicates by a value NO when, in case of a
     * difference of depths < 2, the top of the tree is encountered and forbids
     * any further try to balance the tree.  corrections is an integer used to
     * avoid infinite loops in cases such as:
     *
     *             3                        3
     *          4                              4
     *           5                            5
     *
     * 3 is used here to show that it need not be the top of the tree.
     */

    /*
     * 1/ Adding of the element to the binary tree
     */

    if (tree->top == NULL) {
	tree->top = typeMalloc(HTBTElement);

	if (tree->top == NULL)
	    outofmem(__FILE__, "HTBTree_add");
	tree->top->up = NULL;
	tree->top->object = object;
	tree->top->left = NULL;
	tree->top->left_depth = 0;
	tree->top->right = NULL;
	tree->top->right_depth = 0;
    } else {
	father_found = YES;
	father_of_element = tree->top;
	added_element = NULL;
	father_of_forefather = NULL;
	forefather_of_element = NULL;
	while (father_found) {
	    int res = tree->compare(object, father_of_element->object);

	    if (res < 0) {
		if (father_of_element->left != NULL)
		    father_of_element = father_of_element->left;
		else {
		    father_found = NO;
		    father_of_element->left = typeMalloc(HTBTElement);

		    if (father_of_element->left == NULL)
			outofmem(__FILE__, "HTBTree_add");
		    added_element = father_of_element->left;
		    added_element->up = father_of_element;
		    added_element->object = object;
		    added_element->left = NULL;
		    added_element->left_depth = 0;
		    added_element->right = NULL;
		    added_element->right_depth = 0;
		}
	    } else {		/* res >= 0 */
		if (father_of_element->right != NULL)
		    father_of_element = father_of_element->right;
		else {
		    father_found = NO;
		    father_of_element->right = typeMalloc(HTBTElement);

		    if (father_of_element->right == NULL)
			outofmem(__FILE__, "HTBTree_add");
		    added_element = father_of_element->right;
		    added_element->up = father_of_element;
		    added_element->object = object;
		    added_element->left = NULL;
		    added_element->left_depth = 0;
		    added_element->right = NULL;
		    added_element->right_depth = 0;
		}
	    }
	}

	/*
	 * Changing of all depths that need to be changed
	 */
	father_of_forefather = father_of_element;
	forefather_of_element = added_element;
	do {
	    if (father_of_forefather->left == forefather_of_element) {
		depth = father_of_forefather->left_depth;
		father_of_forefather->left_depth = 1
		    + MAXIMUM(forefather_of_element->right_depth,
			      forefather_of_element->left_depth);
		depth2 = father_of_forefather->left_depth;
	    } else {
		depth = father_of_forefather->right_depth;
		father_of_forefather->right_depth = 1
		    + MAXIMUM(forefather_of_element->right_depth,
			      forefather_of_element->left_depth);
		depth2 = father_of_forefather->right_depth;
	    }
	    forefather_of_element = father_of_forefather;
	    father_of_forefather = father_of_forefather->up;
	} while ((depth != depth2) && (father_of_forefather != NULL));

	/*
	 * 2/ Balancing the binary tree, if necessary
	 */
	top_found = YES;
	corrections = 0;
	while ((top_found) && (corrections < 7)) {
	    if ((abs(father_of_element->left_depth
		     - father_of_element->right_depth)) < 2) {
		if (father_of_element->up != NULL)
		    father_of_element = father_of_element->up;
		else
		    top_found = NO;
	    } else {		/* We start the process of balancing */

		corrections = corrections + 1;
		/*
		 * corrections is an integer used to avoid infinite
		 * loops in cases such as:
		 *
		 *             3                        3
		 *          4                              4
		 *           5                            5
		 *
		 * 3 is used to show that it need not be the top of the tree
		 * But let's avoid these two exceptions anyhow
		 * with the two following conditions (4 March 94 - AS)
		 */

		if ((father_of_element->left == NULL)
		    && (father_of_element->right->right == NULL)
		    && (father_of_element->right->left->left == NULL)
		    && (father_of_element->right->left->right == NULL))
		    corrections = 7;

		if ((father_of_element->right == NULL)
		    && (father_of_element->left->left == NULL)
		    && (father_of_element->left->right->right == NULL)
		    && (father_of_element->left->right->left == NULL))
		    corrections = 7;

		if (father_of_element->left_depth > father_of_element->right_depth) {
		    added_element = father_of_element->left;
		    father_of_element->left_depth = added_element->right_depth;
		    added_element->right_depth = 1
			+ MAXIMUM(father_of_element->right_depth,
				  father_of_element->left_depth);
		    if (father_of_element->up != NULL) {
			/* Bug fixed in March 94  -  AS */
			BOOL first_time;

			father_of_forefather = father_of_element->up;
			forefather_of_element = added_element;
			first_time = YES;
			do {
			    if (father_of_forefather->left
				== forefather_of_element->up) {
				depth = father_of_forefather->left_depth;
				if (first_time) {
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
				    first_time = NO;
				} else
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);

				depth2 = father_of_forefather->left_depth;
			    } else {
				depth = father_of_forefather->right_depth;
				if (first_time) {
				    father_of_forefather->right_depth = 1
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
				    first_time = NO;
				} else
				    father_of_forefather->right_depth = 1
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
				depth2 = father_of_forefather->right_depth;
			    }
			    forefather_of_element = forefather_of_element->up;
			    father_of_forefather = father_of_forefather->up;
			} while ((depth != depth2) &&
				 (father_of_forefather != NULL));
			father_of_forefather = father_of_element->up;
			if (father_of_forefather->left == father_of_element) {
			    /*
			     *                   3                       3
			     *               4                       5
			     * When tree   5   6        becomes    7    4
			     *            7 8                          8 6
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree.
			     */
			    father_of_forefather->left = added_element;
			    father_of_element->left = added_element->right;
			    added_element->right = father_of_element;
			}
			if (father_of_forefather->right == father_of_element) {
			    /*
			     *          3                       3
			     *               4                       5
			     * When tree   5   6        becomes    7    4
			     *            7 8                          8 6
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree
			     */
			    father_of_forefather->right = added_element;
			    father_of_element->left = added_element->right;
			    added_element->right = father_of_element;
			}
			added_element->up = father_of_forefather;
		    } else {
			/*

			 *               1                       2
			 * When tree   2   3        becomes    4    1
			 *            4 5                          5 3
			 *
			 * 1 is used to show that it is the top of the tree
			 */
			added_element->up = NULL;
			father_of_element->left = added_element->right;
			added_element->right = father_of_element;
		    }
		    father_of_element->up = added_element;
		    if (father_of_element->left != NULL)
			father_of_element->left->up = father_of_element;
		} else {
		    added_element = father_of_element->right;
		    father_of_element->right_depth = added_element->left_depth;
		    added_element->left_depth = 1 +
			MAXIMUM(father_of_element->right_depth,
				father_of_element->left_depth);
		    if (father_of_element->up != NULL)
			/* Bug fixed in March 94  -  AS */
		    {
			BOOL first_time;

			father_of_forefather = father_of_element->up;
			forefather_of_element = added_element;
			first_time = YES;
			do {
			    if (father_of_forefather->left
				== forefather_of_element->up) {
				depth = father_of_forefather->left_depth;
				if (first_time) {
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
				    first_time = NO;
				} else
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
				depth2 = father_of_forefather->left_depth;
			    } else {
				depth = father_of_forefather->right_depth;
				if (first_time) {
				    father_of_forefather->right_depth = 1
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
				    first_time = NO;
				} else
				    father_of_forefather->right_depth = 1
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
				depth2 = father_of_forefather->right_depth;
			    }
			    father_of_forefather = father_of_forefather->up;
			    forefather_of_element = forefather_of_element->up;
			} while ((depth != depth2) &&
				 (father_of_forefather != NULL));
			father_of_forefather = father_of_element->up;
			if (father_of_forefather->left == father_of_element) {
			    /*
			     *                    3                       3
			     *               4                       6
			     * When tree   5   6        becomes    4    8
			     *                7 8                 5 7
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree.
			     */
			    father_of_forefather->left = added_element;
			    father_of_element->right = added_element->left;
			    added_element->left = father_of_element;
			}
			if (father_of_forefather->right == father_of_element) {
			    /*
			     *           3                      3
			     *               4                       6
			     * When tree   5   6        becomes    4    8
			     *                7 8                 5 7
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree
			     */
			    father_of_forefather->right = added_element;
			    father_of_element->right = added_element->left;
			    added_element->left = father_of_element;
			}
			added_element->up = father_of_forefather;
		    } else {
			/*

			 *               1                       3
			 * When tree   2   3        becomes    1    5
			 *                4 5                 2 4
			 *
			 * 1 is used to show that it is the top of the tree.
			 */
			added_element->up = NULL;
			father_of_element->right = added_element->left;
			added_element->left = father_of_element;
		    }
		    father_of_element->up = added_element;
		    if (father_of_element->right != NULL)
			father_of_element->right->up = father_of_element;
		}
	    }
	}
	while (father_of_element->up != NULL) {
	    father_of_element = father_of_element->up;
	}
	tree->top = father_of_element;
    }
}

/*************************************************************************
 * this function returns a pointer to the leftmost element if ele is NULL,
 * and to the next object to the right otherwise.
 * If no elements left, returns a pointer to NULL.
 */
HTBTElement *HTBTree_next(HTBTree *tree,
			  HTBTElement *ele)
{
    HTBTElement *father_of_element;
    HTBTElement *father_of_forefather;

    if (ele == NULL) {
	father_of_element = tree->top;
	if (father_of_element != NULL)
	    while (father_of_element->left != NULL)
		father_of_element = father_of_element->left;
    } else {
	father_of_element = ele;
	if (father_of_element->right != NULL) {
	    father_of_element = father_of_element->right;
	    while (father_of_element->left != NULL)
		father_of_element = father_of_element->left;
	} else {
	    father_of_forefather = father_of_element->up;
	    while (father_of_forefather &&
		   (father_of_forefather->right == father_of_element)) {
		father_of_element = father_of_forefather;
		father_of_forefather = father_of_element->up;
	    }
	    father_of_element = father_of_forefather;
	}
    }
#ifdef BTREE_TRACE
    /* The option -DBTREE_TRACE will give much more information
     * about the way the process is running, for debugging matters
     */
    if (father_of_element != NULL) {
	printf("\nObject = %s\t", (char *) father_of_element->object);
	if (father_of_element->up != NULL)
	    printf("Objet du pere = %s\n",
		   (char *) father_of_element->up->object);
	else
	    printf("Pas de Pere\n");
	if (father_of_element->left != NULL)
	    printf("Objet du fils gauche = %s\t",
		   (char *) father_of_element->left->object);
	else
	    printf("Pas de fils gauche\t");
	if (father_of_element->right != NULL)
	    printf("Objet du fils droit = %s\n",
		   (char *) father_of_element->right->object);
	else
	    printf("Pas de fils droit\n");
	printf("Profondeur gauche = %d\t", father_of_element->left_depth);
	printf("Profondeur droite = %d\n", father_of_element->right_depth);
	printf("      **************\n");
    }
#endif
    return father_of_element;
}

#ifdef TEST
/*****************************************************
 * This is just a test to show how to handle HTBTree.c
 */
main()
{
    HTBTree *tree;
    HTBTElement *next_element;

    tree = HTBTree_new((HTComparer) strcasecomp);
    HTBTree_add(tree, "hypertext");
    HTBTree_add(tree, "Addressing");
    HTBTree_add(tree, "X11");
    HTBTree_add(tree, "Tools");
    HTBTree_add(tree, "Proposal.wn");
    HTBTree_add(tree, "Protocols");
    HTBTree_add(tree, "NeXT");
    HTBTree_add(tree, "Daemon");
    HTBTree_add(tree, "Test");
    HTBTree_add(tree, "Administration");
    HTBTree_add(tree, "LineMode");
    HTBTree_add(tree, "DesignIssues");
    HTBTree_add(tree, "MarkUp");
    HTBTree_add(tree, "Macintosh");
    HTBTree_add(tree, "Proposal.rtf.wn");
    HTBTree_add(tree, "FIND");
    HTBTree_add(tree, "Paper");
    HTBTree_add(tree, "Tcl");
    HTBTree_add(tree, "Talks");
    HTBTree_add(tree, "Architecture");
    HTBTree_add(tree, "VMSHelp");
    HTBTree_add(tree, "Provider");
    HTBTree_add(tree, "Archive");
    HTBTree_add(tree, "SLAC");
    HTBTree_add(tree, "Project");
    HTBTree_add(tree, "News");
    HTBTree_add(tree, "Viola");
    HTBTree_add(tree, "Users");
    HTBTree_add(tree, "FAQ");
    HTBTree_add(tree, "WorkingNotes");
    HTBTree_add(tree, "Windows");
    HTBTree_add(tree, "FineWWW");
    HTBTree_add(tree, "Frame");
    HTBTree_add(tree, "XMosaic");
    HTBTree_add(tree, "People");
    HTBTree_add(tree, "All");
    HTBTree_add(tree, "Curses");
    HTBTree_add(tree, "Erwise");
    HTBTree_add(tree, "Carl");
    HTBTree_add(tree, "MidasWWW");
    HTBTree_add(tree, "XPM");
    HTBTree_add(tree, "MailRobot");
    HTBTree_add(tree, "Illustrations");
    HTBTree_add(tree, "VMClient");
    HTBTree_add(tree, "XPA");
    HTBTree_add(tree, "Clients.html");
    HTBTree_add(tree, "Library");
    HTBTree_add(tree, "CERNLIB_Distribution");
    HTBTree_add(tree, "libHTML");
    HTBTree_add(tree, "WindowsPC");
    HTBTree_add(tree, "tkWWW");
    HTBTree_add(tree, "tk2.3");
    HTBTree_add(tree, "CVS-RCS");
    HTBTree_add(tree, "DecnetSockets");
    HTBTree_add(tree, "SGMLStream");
    HTBTree_add(tree, "NextStep");
    HTBTree_add(tree, "CVSRepository_old");
    HTBTree_add(tree, "ArthurSecret");
    HTBTree_add(tree, "CVSROOT");
    HTBTree_add(tree, "HytelnetGate");
    HTBTree_add(tree, "cern.www.new.src");
    HTBTree_add(tree, "Conditions");
    HTBTree_add(tree, "HTMLGate");
    HTBTree_add(tree, "Makefile");
    HTBTree_add(tree, "Newsgroups.html");
    HTBTree_add(tree, "People.html");
    HTBTree_add(tree, "Bugs.html");
    HTBTree_add(tree, "Summary.html");
    HTBTree_add(tree, "zDesignIssues.wn");
    HTBTree_add(tree, "HT.draw");
    HTBTree_add(tree, "HTandCERN.wn");
    HTBTree_add(tree, "Ideas.wn");
    HTBTree_add(tree, "MarkUp.wn");
    HTBTree_add(tree, "Proposal.html");
    HTBTree_add(tree, "SearchPanel.draw");
    HTBTree_add(tree, "Comments.wn");
    HTBTree_add(tree, "Xanadu.html");
    HTBTree_add(tree, "Storinglinks.html");
    HTBTree_add(tree, "TheW3Book.html");
    HTBTree_add(tree, "Talk_Feb-91.html");
    HTBTree_add(tree, "JFosterEntry.txt");
    HTBTree_add(tree, "Summary.txt");
    HTBTree_add(tree, "Bibliography.html");
    HTBTree_add(tree, "HTandCern.txt");
    HTBTree_add(tree, "Talk.draw");
    HTBTree_add(tree, "zDesignNotes.html");
    HTBTree_add(tree, "Link.html");
    HTBTree_add(tree, "Status.html");
    HTBTree_add(tree, "http.txt");
    HTBTree_add(tree, "People.html~");
    HTBTree_add(tree, "TAGS");
    HTBTree_add(tree, "summary.txt");
    HTBTree_add(tree, "Technical.html");
    HTBTree_add(tree, "Terms.html");
    HTBTree_add(tree, "JANETAccess.html");
    HTBTree_add(tree, "People.txt");
    HTBTree_add(tree, "README.txt");
    HTBTree_add(tree, "CodingStandards.html");
    HTBTree_add(tree, "Copyright.txt");
    HTBTree_add(tree, "Status_old.html");
    HTBTree_add(tree, "patches~");
    HTBTree_add(tree, "RelatedProducts.html");
    HTBTree_add(tree, "Implementation");
    HTBTree_add(tree, "History.html");
    HTBTree_add(tree, "Makefile.bak");
    HTBTree_add(tree, "Makefile.old");
    HTBTree_add(tree, "Policy.html");
    HTBTree_add(tree, "WhatIs.html");
    HTBTree_add(tree, "TheProject.html");
    HTBTree_add(tree, "Notation.html");
    HTBTree_add(tree, "Helping.html");
    HTBTree_add(tree, "Cyber-WWW.sit.Hqx");
    HTBTree_add(tree, "Glossary.html");
    HTBTree_add(tree, "maketags.html");
    HTBTree_add(tree, "IntroCS.html");
    HTBTree_add(tree, "Contrib");
    HTBTree_add(tree, "Help.html");
    HTBTree_add(tree, "CodeManagExec");
    HTBTree_add(tree, "HT-0.1draz");
    HTBTree_add(tree, "Cello");
    HTBTree_add(tree, "TOPUB");
    HTBTree_add(tree, "BUILD");
    HTBTree_add(tree, "BUILDALL");
    HTBTree_add(tree, "Lynx");
    HTBTree_add(tree, "ArthurLibrary");
    HTBTree_add(tree, "RashtyClient");
    HTBTree_add(tree, "#History.html#");
    HTBTree_add(tree, "PerlServers");
    HTBTree_add(tree, "modules");
    HTBTree_add(tree, "NCSA_httpd");
    HTBTree_add(tree, "MAIL2HTML");
    HTBTree_add(tree, "core");
    HTBTree_add(tree, "EmacsWWW");
#ifdef BTREE_TRACE
    printf("\nTreeTopObject=%s\n\n", tree->top->object);
#endif
    next_element = HTBTree_next(tree, NULL);
    while (next_element != NULL) {
#ifndef BTREE_TRACE
	printf("The next element is %s\n", next_element->object);
#endif
	next_element = HTBTree_next(tree, next_element);
    }
    HTBTree_free(tree);
}

#endif
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 6
a7 7
**                  ==============================
**                      Author: Arthur Secret
**
**       4 March 94: Bug fixed in the balancing procedure
**
*/

d16 5
a20 5
HTBTree * HTBTree_new (HTComparer comp)
    /*********************************************************
    ** This function returns an HTBTree with memory allocated
    ** for it when given a mean to compare things
    */
d22 4
a25 2
    HTBTree * tree = typeMalloc(HTBTree);
    if (tree==NULL) outofmem(__FILE__, "HTBTree_new");
d33 4
a36 7



static void HTBTElement_free (HTBTElement* element)
    /**********************************************************
    ** This void will free the memory allocated for one element
    */
d47 4
a50 4
void HTBTree_free (HTBTree* tree)
    /**************************************************************
    ** This void will free the memory allocated for the whole tree
    */
d56 4
a59 7



static void HTBTElementAndObject_free (HTBTElement* element)
    /**********************************************************
    ** This void will free the memory allocated for one element
    */
d61 1
a61 1
    if (element) {     /* Just in case nothing was in the tree anyway */
d71 4
a74 4
void HTBTreeAndObject_free (HTBTree* tree)
    /**************************************************************
    ** This void will free the memory allocated for the whole tree
    */
d80 5
a84 7

void * HTBTree_search (
		   HTBTree*  tree,
		   void*     object)
    /**********************************************************************
    ** Returns a pointer to equivalent object in a tree or NULL if none.
    */
d86 1
a86 1
    HTBTElement * cur = tree->top;
d89 1
a89 2
    while (cur != NULL)
    {
d102 8
a109 11


void HTBTree_add (
		    HTBTree*  tree,
		    void*     object)
    /**********************************************************************
    ** This void is the core of HTBTree.c . It will
    **       1/ add a new element to the tree at the right place
    **		so that the tree remains sorted
    **       2/ balance the tree to be as fast as possible when reading it
    */
d111 25
a135 27
    HTBTElement * father_of_element;
    HTBTElement * added_element;
    HTBTElement * forefather_of_element;
    HTBTElement * father_of_forefather;
    BOOL father_found,top_found;
    int depth,depth2,corrections;
	/* father_of_element is a pointer to the structure that is the father of the
	** new object "object".
	** added_element is a pointer to the structure that contains or will contain
	** the new object "object".
	** father_of_forefather and forefather_of_element are pointers that are used
	** to modify the depths of upper elements, when needed.
	**
	** father_found indicates by a value NO when the future father of "object"
	** is found.
	** top_found indicates by a value NO when, in case of a difference of depths
	**  < 2, the top of the tree is encountered and forbids any further try to
	** balance the tree.
	** corrections is an integer used to avoid infinite loops in cases
	** such as:
	**
	**             3                        3
	**          4                              4
	**           5                            5
	**
	** 3 is used here to show that it need not be the top of the tree.
	*/
d138 2
a139 2
    ** 1/ Adding of the element to the binary tree
    */
d141 1
a141 2
    if (tree->top == NULL)
    {
d143 3
a145 1
	if (tree->top == NULL) outofmem(__FILE__, "HTBTree_add");
d152 1
a152 3
    }
    else
    {
d158 4
a161 5
	while (father_found)
	{
	    int res = tree->compare(object,father_of_element->object);
	    if (res < 0)
	    {
d164 1
a164 2
		else
		{
d167 2
a168 1
		    if (father_of_element->left==NULL)
d178 1
a178 3
	    }
	    else /* res >= 0 */
	   {
d181 1
a181 2
		else
		{
d184 2
a185 1
		    if (father_of_element->right==NULL)
d199 2
a200 2
	** Changing of all depths that need to be changed
	*/
d203 2
a204 4
	do
	{
	    if (father_of_forefather->left == forefather_of_element)
	    {
d207 2
a208 2
			    + MAXIMUM(forefather_of_element->right_depth,
				  forefather_of_element->left_depth);
d210 1
a210 3
	    }
	    else
	    {
d213 2
a214 2
			    + MAXIMUM(forefather_of_element->right_depth,
				  forefather_of_element->left_depth);
d221 3
a223 5


	    /*
	    ** 2/ Balancing the binary tree, if necessary
	    */
d226 1
a226 2
	while ((top_found) && (corrections < 7))
	{
d228 1
a228 2
		      - father_of_element->right_depth)) < 2)
	    {
d231 3
a233 4
		else top_found = NO;
	    }
	    else
	    {		     /* We start the process of balancing */
d236 12
a247 12
		   /*
		   ** corrections is an integer used to avoid infinite
		   ** loops in cases such as:
		   **
		   **             3                        3
		   **          4                              4
		   **           5                            5
		   **
		   ** 3 is used to show that it need not be the top of the tree
		   ** But let's avoid these two exceptions anyhow
		   ** with the two following conditions (4 March 94 - AS)
		   */
d261 1
a261 3

		if (father_of_element->left_depth > father_of_element->right_depth)
		{
d265 3
a267 4
				    + MAXIMUM(father_of_element->right_depth,
					  father_of_element->left_depth);
		    if (father_of_element->up != NULL)
		    {
d274 1
a274 2
			do
			{
d276 5
a280 7
				 == forefather_of_element->up)
			      {
				  depth = father_of_forefather->left_depth;
				  if (first_time)
				  {
				      father_of_forefather->left_depth = 1
					  + MAXIMUM(forefather_of_element->left_depth,
d282 5
a286 6
					first_time = NO;
				   }
				   else
				       father_of_forefather->left_depth = 1
					   + MAXIMUM(forefather_of_element->up->left_depth,
					      forefather_of_element->up->right_depth);
d289 1
a289 3
			    }
			    else
			    {
d291 1
a291 2
				if (first_time)
				{
d293 2
a294 2
				      + MAXIMUM(forefather_of_element->left_depth,
					       forefather_of_element->right_depth);
d296 1
a296 2
				}
				else
d298 2
a299 2
				      + MAXIMUM(forefather_of_element->up->left_depth,
					   forefather_of_element->up->right_depth);
d307 1
a307 2
			if (father_of_forefather->left == father_of_element)
			{
d309 8
a316 8
			    **                   3                       3
			    **               4                       5
			    ** When tree   5   6        becomes    7    4
			    **            7 8                          8 6
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree.
			    */
d321 1
a321 2
			if (father_of_forefather->right == father_of_element)
			{
d323 8
a330 8
			    **          3                       3
			    **               4                       5
			    ** When tree   5   6        becomes    7    4
			    **            7 8                          8 6
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree
			    */
d336 1
a336 3
		    }
		    else
		    {
d338 7
a344 7
			**
			**               1                       2
			** When tree   2   3        becomes    4    1
			**            4 5                          5 3
			**
			** 1 is used to show that it is the top of the tree
			*/
d352 1
a352 3
		}
		else
		{
d356 1
a356 1
			    MAXIMUM(father_of_element->right_depth,
d366 1
a366 2
			do
			{
d368 1
a368 2
				== forefather_of_element->up)
			    {
d370 1
a370 2
				if (first_time)
				{
d372 2
a373 2
				       + MAXIMUM(forefather_of_element->left_depth,
					       forefather_of_element->right_depth);
d375 1
a375 2
				}
				else
d377 2
a378 2
				      + MAXIMUM(forefather_of_element->up->left_depth,
					  forefather_of_element->up->right_depth);
d380 1
a380 3
			    }
			    else
			    {
d382 1
a382 2
				if (first_time)
				{
d384 2
a385 2
				       + MAXIMUM(forefather_of_element->left_depth,
					       forefather_of_element->right_depth);
d387 1
a387 2
				}
				else
d389 2
a390 2
				      + MAXIMUM(forefather_of_element->up->left_depth,
					   forefather_of_element->up->right_depth);
d398 1
a398 2
			if (father_of_forefather->left == father_of_element)
			{
d400 8
a407 8
			    **                    3                       3
			    **               4                       6
			    ** When tree   5   6        becomes    4    8
			    **                7 8                 5 7
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree.
			    */
d412 1
a412 2
			if (father_of_forefather->right == father_of_element)
			{
d414 8
a421 8
			    **           3                      3
			    **               4                       6
			    ** When tree   5   6        becomes    4    8
			    **                7 8                 5 7
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree
			    */
d427 1
a427 3
		    }
		    else
		    {
d429 7
a435 7
			**
			**               1                       3
			** When tree   2   3        becomes    1    5
			**                4 5                 2 4
			**
			** 1 is used to show that it is the top of the tree.
			*/
d446 1
a446 2
	while (father_of_element->up != NULL)
	{
d453 7
a459 10


HTBTElement * HTBTree_next (
			       HTBTree*       tree,
			       HTBTElement*   ele)
    /**************************************************************************
    ** this function returns a pointer to the leftmost element if ele is NULL,
    ** and to the next object to the right otherwise.
    ** If no elements left, returns a pointer to NULL.
    */
d461 2
a462 2
    HTBTElement * father_of_element;
    HTBTElement * father_of_forefather;
d464 1
a464 2
    if (ele == NULL)
    {
d469 1
a469 3
    }
    else
    {
d471 1
a471 2
	if (father_of_element->right != NULL)
	{
d475 1
a475 3
	}
	else
	{
d477 5
a481 6
		while (father_of_forefather &&
		       (father_of_forefather->right == father_of_element))
		{
		    father_of_element = father_of_forefather;
		    father_of_forefather = father_of_element->up;
		}
d487 4
a490 5
    ** about the way the process is running, for debugging matters
    */
    if (father_of_element != NULL)
    {
	printf("\nObject = %s\t",(char *)father_of_element->object);
d493 3
a495 2
		   (char *)father_of_element->up->object);
	else printf("Pas de Pere\n");
d498 3
a500 2
		   (char *)father_of_element->left->object);
	else printf("Pas de fils gauche\t");
d503 5
a507 4
		   (char *)father_of_element->right->object);
	else printf("Pas de fils droit\n");
	printf("Profondeur gauche = %d\t",father_of_element->left_depth);
	printf("Profondeur droite = %d\n",father_of_element->right_depth);
a513 1

d515 4
a518 4
main ()
    /******************************************************
    ** This is just a test to show how to handle HTBTree.c
    */
d520 2
a521 2
    HTBTree * tree;
    HTBTElement * next_element;
d523 134
a656 134
    tree = HTBTree_new((HTComparer)strcasecomp);
    HTBTree_add(tree,"hypertext");
    HTBTree_add(tree,"Addressing");
    HTBTree_add(tree,"X11");
    HTBTree_add(tree,"Tools");
    HTBTree_add(tree,"Proposal.wn");
    HTBTree_add(tree,"Protocols");
    HTBTree_add(tree,"NeXT");
    HTBTree_add(tree,"Daemon");
    HTBTree_add(tree,"Test");
    HTBTree_add(tree,"Administration");
    HTBTree_add(tree,"LineMode");
    HTBTree_add(tree,"DesignIssues");
    HTBTree_add(tree,"MarkUp");
    HTBTree_add(tree,"Macintosh");
    HTBTree_add(tree,"Proposal.rtf.wn");
    HTBTree_add(tree,"FIND");
    HTBTree_add(tree,"Paper");
    HTBTree_add(tree,"Tcl");
    HTBTree_add(tree,"Talks");
    HTBTree_add(tree,"Architecture");
    HTBTree_add(tree,"VMSHelp");
    HTBTree_add(tree,"Provider");
    HTBTree_add(tree,"Archive");
    HTBTree_add(tree,"SLAC");
    HTBTree_add(tree,"Project");
    HTBTree_add(tree,"News");
    HTBTree_add(tree,"Viola");
    HTBTree_add(tree,"Users");
    HTBTree_add(tree,"FAQ");
    HTBTree_add(tree,"WorkingNotes");
    HTBTree_add(tree,"Windows");
    HTBTree_add(tree,"FineWWW");
    HTBTree_add(tree,"Frame");
    HTBTree_add(tree,"XMosaic");
    HTBTree_add(tree,"People");
    HTBTree_add(tree,"All");
    HTBTree_add(tree,"Curses");
    HTBTree_add(tree,"Erwise");
    HTBTree_add(tree,"Carl");
    HTBTree_add(tree,"MidasWWW");
    HTBTree_add(tree,"XPM");
    HTBTree_add(tree,"MailRobot");
    HTBTree_add(tree,"Illustrations");
    HTBTree_add(tree,"VMClient");
    HTBTree_add(tree,"XPA");
    HTBTree_add(tree,"Clients.html");
    HTBTree_add(tree,"Library");
    HTBTree_add(tree,"CERNLIB_Distribution");
    HTBTree_add(tree,"libHTML");
    HTBTree_add(tree,"WindowsPC");
    HTBTree_add(tree,"tkWWW");
    HTBTree_add(tree,"tk2.3");
    HTBTree_add(tree,"CVS-RCS");
    HTBTree_add(tree,"DecnetSockets");
    HTBTree_add(tree,"SGMLStream");
    HTBTree_add(tree,"NextStep");
    HTBTree_add(tree,"CVSRepository_old");
    HTBTree_add(tree,"ArthurSecret");
    HTBTree_add(tree,"CVSROOT");
    HTBTree_add(tree,"HytelnetGate");
    HTBTree_add(tree,"cern.www.new.src");
    HTBTree_add(tree,"Conditions");
    HTBTree_add(tree,"HTMLGate");
    HTBTree_add(tree,"Makefile");
    HTBTree_add(tree,"Newsgroups.html");
    HTBTree_add(tree,"People.html");
    HTBTree_add(tree,"Bugs.html");
    HTBTree_add(tree,"Summary.html");
    HTBTree_add(tree,"zDesignIssues.wn");
    HTBTree_add(tree,"HT.draw");
    HTBTree_add(tree,"HTandCERN.wn");
    HTBTree_add(tree,"Ideas.wn");
    HTBTree_add(tree,"MarkUp.wn");
    HTBTree_add(tree,"Proposal.html");
    HTBTree_add(tree,"SearchPanel.draw");
    HTBTree_add(tree,"Comments.wn");
    HTBTree_add(tree,"Xanadu.html");
    HTBTree_add(tree,"Storinglinks.html");
    HTBTree_add(tree,"TheW3Book.html");
    HTBTree_add(tree,"Talk_Feb-91.html");
    HTBTree_add(tree,"JFosterEntry.txt");
    HTBTree_add(tree,"Summary.txt");
    HTBTree_add(tree,"Bibliography.html");
    HTBTree_add(tree,"HTandCern.txt");
    HTBTree_add(tree,"Talk.draw");
    HTBTree_add(tree,"zDesignNotes.html");
    HTBTree_add(tree,"Link.html");
    HTBTree_add(tree,"Status.html");
    HTBTree_add(tree,"http.txt");
    HTBTree_add(tree,"People.html~");
    HTBTree_add(tree,"TAGS");
    HTBTree_add(tree,"summary.txt");
    HTBTree_add(tree,"Technical.html");
    HTBTree_add(tree,"Terms.html");
    HTBTree_add(tree,"JANETAccess.html");
    HTBTree_add(tree,"People.txt");
    HTBTree_add(tree,"README.txt");
    HTBTree_add(tree,"CodingStandards.html");
    HTBTree_add(tree,"Copyright.txt");
    HTBTree_add(tree,"Status_old.html");
    HTBTree_add(tree,"patches~");
    HTBTree_add(tree,"RelatedProducts.html");
    HTBTree_add(tree,"Implementation");
    HTBTree_add(tree,"History.html");
    HTBTree_add(tree,"Makefile.bak");
    HTBTree_add(tree,"Makefile.old");
    HTBTree_add(tree,"Policy.html");
    HTBTree_add(tree,"WhatIs.html");
    HTBTree_add(tree,"TheProject.html");
    HTBTree_add(tree,"Notation.html");
    HTBTree_add(tree,"Helping.html");
    HTBTree_add(tree,"Cyber-WWW.sit.Hqx");
    HTBTree_add(tree,"Glossary.html");
    HTBTree_add(tree,"maketags.html");
    HTBTree_add(tree,"IntroCS.html");
    HTBTree_add(tree,"Contrib");
    HTBTree_add(tree,"Help.html");
    HTBTree_add(tree,"CodeManagExec");
    HTBTree_add(tree,"HT-0.1draz");
    HTBTree_add(tree,"Cello");
    HTBTree_add(tree,"TOPUB");
    HTBTree_add(tree,"BUILD");
    HTBTree_add(tree,"BUILDALL");
    HTBTree_add(tree,"Lynx");
    HTBTree_add(tree,"ArthurLibrary");
    HTBTree_add(tree,"RashtyClient");
    HTBTree_add(tree,"#History.html#");
    HTBTree_add(tree,"PerlServers");
    HTBTree_add(tree,"modules");
    HTBTree_add(tree,"NCSA_httpd");
    HTBTree_add(tree,"MAIL2HTML");
    HTBTree_add(tree,"core");
    HTBTree_add(tree,"EmacsWWW");
d658 1
a658 1
    printf("\nTreeTopObject=%s\n\n",tree->top->object);
d660 2
a661 3
    next_element = HTBTree_next(tree,NULL);
    while (next_element != NULL)
    {
d663 1
a663 1
	printf("The next element is %s\n",next_element->object);
d665 1
a665 1
	next_element = HTBTree_next(tree,next_element);
a668 1

@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d17 1
a17 1
PUBLIC HTBTree * HTBTree_new ARGS1(HTComparer, comp)
d35 1
a35 1
PRIVATE void HTBTElement_free ARGS1(HTBTElement*, element)
d49 1
a49 1
PUBLIC void HTBTree_free ARGS1(HTBTree*, tree)
d61 1
a61 1
PRIVATE void HTBTElementAndObject_free ARGS1(HTBTElement*, element)
d76 1
a76 1
PUBLIC void HTBTreeAndObject_free ARGS1(HTBTree*, tree)
d86 3
a88 3
PUBLIC void * HTBTree_search ARGS2(
		   HTBTree*,  tree,
		   void*,     object)
d112 3
a114 3
PUBLIC void HTBTree_add ARGS2(
		    HTBTree*,  tree,
		    void*,     object)
d511 3
a513 3
PUBLIC HTBTElement * HTBTree_next ARGS2(
			       HTBTree*,       tree,
			       HTBTElement*,   ele)
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a11 3
#ifndef __STRICT_BSD__
#include <stdlib.h>
#endif
d23 1
a23 1
    HTBTree * tree = (HTBTree *)malloc(sizeof(HTBTree));
d41 1
a41 1
        if (element->left != NULL)
d67 1
a67 1
        if (element->left != NULL)
d86 24
d118 1
a118 1
    **          so that the tree remains sorted
d128 21
a148 21
        /* father_of_element is a pointer to the structure that is the father of the
        ** new object "object".
        ** added_element is a pointer to the structure that contains or will contain
        ** the new object "object".
        ** father_of_forefather and forefather_of_element are pointers that are used
        ** to modify the depths of upper elements, when needed.
        **
        ** father_found indicates by a value NO when the future father of "object"
        ** is found.
        ** top_found indicates by a value NO when, in case of a difference of depths
        **  < 2, the top of the tree is encountered and forbids any further try to
        ** balance the tree.
        ** corrections is an integer used to avoid infinite loops in cases
        ** such as:
        **
        **             3                        3
        **          4                              4
        **           5                            5
        **
        ** 3 is used here to show that it need not be the top of the tree.
        */
d156 8
a163 8
        tree->top = (HTBTElement *)malloc(sizeof(HTBTElement));
        if (tree->top == NULL) outofmem(__FILE__, "HTBTree_add");
        tree->top->up = NULL;
        tree->top->object = object;
        tree->top->left = NULL;
        tree->top->left_depth = 0;
        tree->top->right = NULL;
        tree->top->right_depth = 0;
d167 9
a175 8
        father_found = YES;
        father_of_element = tree->top;
        added_element = NULL;
        father_of_forefather = NULL;
        forefather_of_element = NULL;
        while (father_found)
        {
            if (tree->compare(object,father_of_element->object)<0)
d177 36
a212 38
                if (father_of_element->left != NULL)
                    father_of_element = father_of_element->left;
                else
	        {
                    father_found = NO;
                    father_of_element->left =
                        (HTBTElement *)malloc(sizeof(HTBTElement));
                    if (father_of_element->left==NULL)
                        outofmem(__FILE__, "HTBTree_add");
                    added_element = father_of_element->left;
                    added_element->up = father_of_element;
                    added_element->object = object;
                    added_element->left = NULL;
                    added_element->left_depth = 0;
                    added_element->right = NULL;
                    added_element->right_depth = 0;
                }
   	    }
            if (tree->compare(object,father_of_element->object)>=0)
            {
                if (father_of_element->right != NULL)
                    father_of_element = father_of_element->right;
                else
                {
                    father_found = NO;
                    father_of_element->right =
                        (HTBTElement *)malloc(sizeof(HTBTElement));
                    if (father_of_element->right==NULL)
                        outofmem(__FILE__, "HTBTree_add");
                    added_element = father_of_element->right;
                    added_element->up = father_of_element;
                    added_element->object = object;
                    added_element->left = NULL;
                    added_element->left_depth = 0;
                    added_element->right = NULL;
                    added_element->right_depth = 0;
    	        }
            }
d214 17
a230 16
            /*
            ** Changing of all depths that need to be changed
            */
        father_of_forefather = father_of_element;
        forefather_of_element = added_element;
        do
        {
            if (father_of_forefather->left == forefather_of_element)
            {
                depth = father_of_forefather->left_depth;
                father_of_forefather->left_depth = 1
                            + MAXIMUM(forefather_of_element->right_depth,
                                  forefather_of_element->left_depth);
                depth2 = father_of_forefather->left_depth;
            }
            else
d232 9
a240 9
                depth = father_of_forefather->right_depth;
                father_of_forefather->right_depth = 1
                            + MAXIMUM(forefather_of_element->right_depth,
                                  forefather_of_element->left_depth);
                depth2 = father_of_forefather->right_depth;
            }
            forefather_of_element = father_of_forefather;
            father_of_forefather = father_of_forefather->up;
        } while ((depth != depth2) && (father_of_forefather != NULL));
d244 9
a252 9
            /*
            ** 2/ Balancing the binary tree, if necessary
            */
        top_found = YES;
        corrections = 0;
        while ((top_found) && (corrections < 7))
        {
            if ((abs(father_of_element->left_depth
                      - father_of_element->right_depth)) < 2)
d254 3
a256 3
                if (father_of_element->up != NULL)
                    father_of_element = father_of_element->up;
                else top_found = NO;
d258 2
a259 2
            else
 	    {                /* We start the process of balancing */
d261 13
a273 13
                corrections = corrections + 1;
                    /*
                    ** corrections is an integer used to avoid infinite
                    ** loops in cases such as:
                    **
                    **             3                        3
                    **          4                              4
                    **           5                            5
                    **
                    ** 3 is used to show that it need not be the top of the tree
		    ** But let's avoid these two exceptions anyhow
		    ** with the two following conditions (4 March 94 - AS)
                    */
d288 8
a295 8
                if (father_of_element->left_depth > father_of_element->right_depth)
	        {
                    added_element = father_of_element->left;
                    father_of_element->left_depth = added_element->right_depth;
                    added_element->right_depth = 1
                                    + MAXIMUM(father_of_element->right_depth,
                                          father_of_element->left_depth);
                    if (father_of_element->up != NULL)
d300 2
a301 2
                        father_of_forefather = father_of_element->up;
                        forefather_of_element = added_element;
d303 5
a307 5
                        do
                        {
                            if (father_of_forefather->left
                                 == forefather_of_element->up)
                              {
d321 1
a321 1
                                depth2 = father_of_forefather->left_depth;
d323 1
a323 1
                            else
d325 1
a325 1
                                depth = father_of_forefather->right_depth;
d337 1
a337 1
                                depth2 = father_of_forefather->right_depth;
d339 2
a340 2
                            forefather_of_element = forefather_of_element->up;
                            father_of_forefather = father_of_forefather->up;
d343 32
a374 32
                        father_of_forefather = father_of_element->up;
                        if (father_of_forefather->left == father_of_element)
	                {
                            /*
                            **                   3                       3
                            **               4                       5
                            ** When tree   5   6        becomes    7    4
                            **            7 8                          8 6
                            **
                            ** 3 is used to show that it may not be the top of the
                            ** tree.
                            */
                            father_of_forefather->left = added_element;
                            father_of_element->left = added_element->right;
                            added_element->right = father_of_element;
                        }
                        if (father_of_forefather->right == father_of_element)
		        {
                            /*
                            **          3                       3
                            **               4                       5
                            ** When tree   5   6        becomes    7    4
                            **            7 8                          8 6
                            **
                            ** 3 is used to show that it may not be the top of the
                            ** tree
                            */
                            father_of_forefather->right = added_element;
                            father_of_element->left = added_element->right;
                            added_element->right = father_of_element;
                        }
                        added_element->up = father_of_forefather;
d376 1
a376 1
                    else
d378 11
a388 11
                        /*
                        **
                        **               1                       2
                        ** When tree   2   3        becomes    4    1
                        **            4 5                          5 3
                        **
                        ** 1 is used to show that it is the top of the tree
                        */
                        added_element->up = NULL;
                        father_of_element->left = added_element->right;
                        added_element->right = father_of_element;
d390 12
a401 12
                    father_of_element->up = added_element;
                    if (father_of_element->left != NULL)
                        father_of_element->left->up = father_of_element;
	        }
                else
	        {
                    added_element = father_of_element->right;
                    father_of_element->right_depth = added_element->left_depth;
                    added_element->left_depth = 1 +
                            MAXIMUM(father_of_element->right_depth,
                                father_of_element->left_depth);
                    if (father_of_element->up != NULL)
d406 2
a407 2
                        father_of_forefather = father_of_element->up;
                        forefather_of_element = added_element;
d409 3
a411 3
                        do
                        {
                            if (father_of_forefather->left
d413 3
a415 3
                            {
                                depth = father_of_forefather->left_depth;
                                if (first_time)
d422 1
a422 1
                                else
d425 1
a425 1
				       	  forefather_of_element->up->right_depth);
d428 1
a428 1
                            else
d430 1
a430 1
                                depth = father_of_forefather->right_depth;
d442 1
a442 1
                                depth2 = father_of_forefather->right_depth;
d444 2
a445 2
                            father_of_forefather = father_of_forefather->up;
                            forefather_of_element = forefather_of_element->up;
d448 32
a479 32
                        father_of_forefather = father_of_element->up;
                        if (father_of_forefather->left == father_of_element)
		        {
                            /*
                            **                    3                       3
                            **               4                       6
                            ** When tree   5   6        becomes    4    8
                            **                7 8                 5 7
                            **
                            ** 3 is used to show that it may not be the top of the
                            ** tree.
                            */
                            father_of_forefather->left = added_element;
                            father_of_element->right = added_element->left;
                            added_element->left = father_of_element;
                        }
                        if (father_of_forefather->right == father_of_element)
		        {
                            /*
                            **           3                      3
                            **               4                       6
                            ** When tree   5   6        becomes    4    8
                            **                7 8                 5 7
                            **
                            ** 3 is used to show that it may not be the top of the
                            ** tree
                            */
                            father_of_forefather->right = added_element;
                            father_of_element->right = added_element->left;
                            added_element->left = father_of_element;
                        }
                        added_element->up = father_of_forefather;
d481 13
a493 13
                    else
                    {
                        /*
                        **
                        **               1                       3
                        ** When tree   2   3        becomes    1    5
                        **                4 5                 2 4
                        **
                        ** 1 is used to show that it is the top of the tree.
                        */
                        added_element->up = NULL;
                        father_of_element->right = added_element->left;
                        added_element->left = father_of_element;
d495 3
a497 3
                    father_of_element->up = added_element;
                    if (father_of_element->right != NULL)
		        father_of_element->right->up = father_of_element;
d500 2
a501 2
        }
        while (father_of_element->up != NULL)
d503 3
a505 3
            father_of_element = father_of_element->up;
        }
        tree->top = father_of_element;
d512 2
a513 2
                               HTBTree*,       tree,
                               HTBTElement*,   ele)
d525 4
a528 4
        father_of_element = tree->top;
        if (father_of_element != NULL)
            while (father_of_element->left != NULL)
                father_of_element = father_of_element->left;
d532 2
a533 2
        father_of_element = ele;
        if (father_of_element->right != NULL)
d535 3
a537 3
            father_of_element = father_of_element->right;
            while (father_of_element->left != NULL)
                father_of_element = father_of_element->left;
d539 1
a539 1
        else
d541 2
a542 2
            father_of_forefather = father_of_element->up;
	        while (father_of_forefather &&
d544 2
a545 2
      	        {
                    father_of_element = father_of_forefather;
d548 1
a548 1
            father_of_element = father_of_forefather;
d557 3
a559 3
        printf("\nObject = %s\t",(char *)father_of_element->object);
        if (father_of_element->up != NULL)
            printf("Objet du pere = %s\n",
d561 3
a563 3
        else printf("Pas de Pere\n");
        if (father_of_element->left != NULL)
            printf("Objet du fils gauche = %s\t",
d565 3
a567 3
        else printf("Pas de fils gauche\t");
        if (father_of_element->right != NULL)
            printf("Objet du fils droit = %s\n",
d569 4
a572 4
        else printf("Pas de fils droit\n");
        printf("Profondeur gauche = %d\t",father_of_element->left_depth);
        printf("Profondeur droite = %d\n",father_of_element->right_depth);
        printf("      **************\n");
d729 1
a729 1
        printf("The next element is %s\n",next_element->object);
d731 1
a731 1
        next_element = HTBTree_next(tree,next_element);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 7
a8 6
 *                  ==============================
 *                      Author: Arthur Secret
 *
 *       4 March 94: Bug fixed in the balancing procedure
 *
 */
d12 3
d20 5
a24 5
/*********************************************************
 * This function returns an HTBTree with memory allocated
 * for it when given a mean to compare things
 */
HTBTree *HTBTree_new(HTComparer comp)
d26 2
a27 4
    HTBTree *tree = typeMalloc(HTBTree);

    if (tree == NULL)
	outofmem(__FILE__, "HTBTree_new");
d35 7
a41 4
/*********************************************************
 * This void will free the memory allocated for one element
 */
static void HTBTElement_free(HTBTElement *element)
d44 1
a44 1
	if (element->left != NULL)
d52 4
a55 4
/*************************************************************
 * This void will free the memory allocated for the whole tree
 */
void HTBTree_free(HTBTree *tree)
d61 7
a67 4
/*********************************************************
 * This void will free the memory allocated for one element
 */
static void HTBTElementAndObject_free(HTBTElement *element)
d69 2
a70 2
    if (element) {		/* Just in case nothing was in the tree anyway */
	if (element->left != NULL)
d79 4
a82 4
/*************************************************************
 * This void will free the memory allocated for the whole tree
 */
void HTBTreeAndObject_free(HTBTree *tree)
a87 8
/*********************************************************************
 * Returns a pointer to equivalent object in a tree or NULL if none.
 */
void *HTBTree_search(HTBTree *tree,
		     void *object)
{
    HTBTElement *cur = tree->top;
    int res;
a88 2
    while (cur != NULL) {
	res = tree->compare(object, cur->object);
a89 9
	if (res == 0)
	    return cur->object;
	else if (res < 0)
	    cur = cur->left;
	else if (res > 0)
	    cur = cur->right;
    }
    return NULL;
}
d91 9
a99 8
/*********************************************************************
 * This void is the core of HTBTree.c . It will
 *       1/ add a new element to the tree at the right place
 *		so that the tree remains sorted
 *       2/ balance the tree to be as fast as possible when reading it
 */
void HTBTree_add(HTBTree *tree,
		 void *object)
d101 27
a127 25
    HTBTElement *father_of_element;
    HTBTElement *added_element;
    HTBTElement *forefather_of_element;
    HTBTElement *father_of_forefather;
    BOOL father_found, top_found;
    int depth, depth2, corrections;

    /* father_of_element is a pointer to the structure that is the father of
     * the new object "object".  added_element is a pointer to the structure
     * that contains or will contain the new object "object". 
     * father_of_forefather and forefather_of_element are pointers that are
     * used to modify the depths of upper elements, when needed.
     *
     * father_found indicates by a value NO when the future father of "object"
     * is found.  top_found indicates by a value NO when, in case of a
     * difference of depths < 2, the top of the tree is encountered and forbids
     * any further try to balance the tree.  corrections is an integer used to
     * avoid infinite loops in cases such as:
     *
     *             3                        3
     *          4                              4
     *           5                            5
     *
     * 3 is used here to show that it need not be the top of the tree.
     */
d130 91
a220 2
     * 1/ Adding of the element to the binary tree
     */
a221 2
    if (tree->top == NULL) {
	tree->top = typeMalloc(HTBTElement);
d223 13
a235 51
	if (tree->top == NULL)
	    outofmem(__FILE__, "HTBTree_add");
	tree->top->up = NULL;
	tree->top->object = object;
	tree->top->left = NULL;
	tree->top->left_depth = 0;
	tree->top->right = NULL;
	tree->top->right_depth = 0;
    } else {
	father_found = YES;
	father_of_element = tree->top;
	added_element = NULL;
	father_of_forefather = NULL;
	forefather_of_element = NULL;
	while (father_found) {
	    int res = tree->compare(object, father_of_element->object);

	    if (res < 0) {
		if (father_of_element->left != NULL)
		    father_of_element = father_of_element->left;
		else {
		    father_found = NO;
		    father_of_element->left = typeMalloc(HTBTElement);

		    if (father_of_element->left == NULL)
			outofmem(__FILE__, "HTBTree_add");
		    added_element = father_of_element->left;
		    added_element->up = father_of_element;
		    added_element->object = object;
		    added_element->left = NULL;
		    added_element->left_depth = 0;
		    added_element->right = NULL;
		    added_element->right_depth = 0;
		}
	    } else {		/* res >= 0 */
		if (father_of_element->right != NULL)
		    father_of_element = father_of_element->right;
		else {
		    father_found = NO;
		    father_of_element->right = typeMalloc(HTBTElement);

		    if (father_of_element->right == NULL)
			outofmem(__FILE__, "HTBTree_add");
		    added_element = father_of_element->right;
		    added_element->up = father_of_element;
		    added_element->object = object;
		    added_element->left = NULL;
		    added_element->left_depth = 0;
		    added_element->right = NULL;
		    added_element->right_depth = 0;
		}
d237 2
a238 1
	}
d240 13
a252 50
	/*
	 * Changing of all depths that need to be changed
	 */
	father_of_forefather = father_of_element;
	forefather_of_element = added_element;
	do {
	    if (father_of_forefather->left == forefather_of_element) {
		depth = father_of_forefather->left_depth;
		father_of_forefather->left_depth = 1
		    + MAXIMUM(forefather_of_element->right_depth,
			      forefather_of_element->left_depth);
		depth2 = father_of_forefather->left_depth;
	    } else {
		depth = father_of_forefather->right_depth;
		father_of_forefather->right_depth = 1
		    + MAXIMUM(forefather_of_element->right_depth,
			      forefather_of_element->left_depth);
		depth2 = father_of_forefather->right_depth;
	    }
	    forefather_of_element = father_of_forefather;
	    father_of_forefather = father_of_forefather->up;
	} while ((depth != depth2) && (father_of_forefather != NULL));

	/*
	 * 2/ Balancing the binary tree, if necessary
	 */
	top_found = YES;
	corrections = 0;
	while ((top_found) && (corrections < 7)) {
	    if ((abs(father_of_element->left_depth
		     - father_of_element->right_depth)) < 2) {
		if (father_of_element->up != NULL)
		    father_of_element = father_of_element->up;
		else
		    top_found = NO;
	    } else {		/* We start the process of balancing */

		corrections = corrections + 1;
		/*
		 * corrections is an integer used to avoid infinite
		 * loops in cases such as:
		 *
		 *             3                        3
		 *          4                              4
		 *           5                            5
		 *
		 * 3 is used to show that it need not be the top of the tree
		 * But let's avoid these two exceptions anyhow
		 * with the two following conditions (4 March 94 - AS)
		 */
d266 10
a275 7
		if (father_of_element->left_depth > father_of_element->right_depth) {
		    added_element = father_of_element->left;
		    father_of_element->left_depth = added_element->right_depth;
		    added_element->right_depth = 1
			+ MAXIMUM(father_of_element->right_depth,
				  father_of_element->left_depth);
		    if (father_of_element->up != NULL) {
d279 2
a280 2
			father_of_forefather = father_of_element->up;
			forefather_of_element = added_element;
d282 10
a291 7
			do {
			    if (father_of_forefather->left
				== forefather_of_element->up) {
				depth = father_of_forefather->left_depth;
				if (first_time) {
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->left_depth,
d293 6
a298 5
				    first_time = NO;
				} else
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
d300 7
a306 4
				depth2 = father_of_forefather->left_depth;
			    } else {
				depth = father_of_forefather->right_depth;
				if (first_time) {
d308 2
a309 2
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
d311 2
a312 1
				} else
d314 3
a316 3
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
				depth2 = father_of_forefather->right_depth;
d318 2
a319 2
			    forefather_of_element = forefather_of_element->up;
			    father_of_forefather = father_of_forefather->up;
d322 32
a353 42
			father_of_forefather = father_of_element->up;
			if (father_of_forefather->left == father_of_element) {
			    /*
			     *                   3                       3
			     *               4                       5
			     * When tree   5   6        becomes    7    4
			     *            7 8                          8 6
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree.
			     */
			    father_of_forefather->left = added_element;
			    father_of_element->left = added_element->right;
			    added_element->right = father_of_element;
			}
			if (father_of_forefather->right == father_of_element) {
			    /*
			     *          3                       3
			     *               4                       5
			     * When tree   5   6        becomes    7    4
			     *            7 8                          8 6
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree
			     */
			    father_of_forefather->right = added_element;
			    father_of_element->left = added_element->right;
			    added_element->right = father_of_element;
			}
			added_element->up = father_of_forefather;
		    } else {
			/*

			 *               1                       2
			 * When tree   2   3        becomes    4    1
			 *            4 5                          5 3
			 *
			 * 1 is used to show that it is the top of the tree
			 */
			added_element->up = NULL;
			father_of_element->left = added_element->right;
			added_element->right = father_of_element;
d355 26
a380 10
		    father_of_element->up = added_element;
		    if (father_of_element->left != NULL)
			father_of_element->left->up = father_of_element;
		} else {
		    added_element = father_of_element->right;
		    father_of_element->right_depth = added_element->left_depth;
		    added_element->left_depth = 1 +
			MAXIMUM(father_of_element->right_depth,
				father_of_element->left_depth);
		    if (father_of_element->up != NULL)
d385 2
a386 2
			father_of_forefather = father_of_element->up;
			forefather_of_element = added_element;
d388 8
a395 5
			do {
			    if (father_of_forefather->left
				== forefather_of_element->up) {
				depth = father_of_forefather->left_depth;
				if (first_time) {
d397 2
a398 2
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
d400 2
a401 1
				} else
d403 2
a404 2
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
d406 6
a411 3
			    } else {
				depth = father_of_forefather->right_depth;
				if (first_time) {
d413 2
a414 2
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
d416 2
a417 1
				} else
d419 3
a421 3
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
				depth2 = father_of_forefather->right_depth;
d423 2
a424 2
			    father_of_forefather = father_of_forefather->up;
			    forefather_of_element = forefather_of_element->up;
d427 32
a458 42
			father_of_forefather = father_of_element->up;
			if (father_of_forefather->left == father_of_element) {
			    /*
			     *                    3                       3
			     *               4                       6
			     * When tree   5   6        becomes    4    8
			     *                7 8                 5 7
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree.
			     */
			    father_of_forefather->left = added_element;
			    father_of_element->right = added_element->left;
			    added_element->left = father_of_element;
			}
			if (father_of_forefather->right == father_of_element) {
			    /*
			     *           3                      3
			     *               4                       6
			     * When tree   5   6        becomes    4    8
			     *                7 8                 5 7
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree
			     */
			    father_of_forefather->right = added_element;
			    father_of_element->right = added_element->left;
			    added_element->left = father_of_element;
			}
			added_element->up = father_of_forefather;
		    } else {
			/*

			 *               1                       3
			 * When tree   2   3        becomes    1    5
			 *                4 5                 2 4
			 *
			 * 1 is used to show that it is the top of the tree.
			 */
			added_element->up = NULL;
			father_of_element->right = added_element->left;
			added_element->left = father_of_element;
d460 17
a476 3
		    father_of_element->up = added_element;
		    if (father_of_element->right != NULL)
			father_of_element->right->up = father_of_element;
d479 6
a484 5
	}
	while (father_of_element->up != NULL) {
	    father_of_element = father_of_element->up;
	}
	tree->top = father_of_element;
d488 10
a497 7
/*************************************************************************
 * this function returns a pointer to the leftmost element if ele is NULL,
 * and to the next object to the right otherwise.
 * If no elements left, returns a pointer to NULL.
 */
HTBTElement *HTBTree_next(HTBTree *tree,
			  HTBTElement *ele)
d499 2
a500 2
    HTBTElement *father_of_element;
    HTBTElement *father_of_forefather;
d502 26
a527 19
    if (ele == NULL) {
	father_of_element = tree->top;
	if (father_of_element != NULL)
	    while (father_of_element->left != NULL)
		father_of_element = father_of_element->left;
    } else {
	father_of_element = ele;
	if (father_of_element->right != NULL) {
	    father_of_element = father_of_element->right;
	    while (father_of_element->left != NULL)
		father_of_element = father_of_element->left;
	} else {
	    father_of_forefather = father_of_element->up;
	    while (father_of_forefather &&
		   (father_of_forefather->right == father_of_element)) {
		father_of_element = father_of_forefather;
		father_of_forefather = father_of_element->up;
	    }
	    father_of_element = father_of_forefather;
d532 20
a551 22
     * about the way the process is running, for debugging matters
     */
    if (father_of_element != NULL) {
	printf("\nObject = %s\t", (char *) father_of_element->object);
	if (father_of_element->up != NULL)
	    printf("Objet du pere = %s\n",
		   (char *) father_of_element->up->object);
	else
	    printf("Pas de Pere\n");
	if (father_of_element->left != NULL)
	    printf("Objet du fils gauche = %s\t",
		   (char *) father_of_element->left->object);
	else
	    printf("Pas de fils gauche\t");
	if (father_of_element->right != NULL)
	    printf("Objet du fils droit = %s\n",
		   (char *) father_of_element->right->object);
	else
	    printf("Pas de fils droit\n");
	printf("Profondeur gauche = %d\t", father_of_element->left_depth);
	printf("Profondeur droite = %d\n", father_of_element->right_depth);
	printf("      **************\n");
d557 1
d559 4
a562 4
/*****************************************************
 * This is just a test to show how to handle HTBTree.c
 */
main()
d564 2
a565 2
    HTBTree *tree;
    HTBTElement *next_element;
d567 134
a700 134
    tree = HTBTree_new((HTComparer) strcasecomp);
    HTBTree_add(tree, "hypertext");
    HTBTree_add(tree, "Addressing");
    HTBTree_add(tree, "X11");
    HTBTree_add(tree, "Tools");
    HTBTree_add(tree, "Proposal.wn");
    HTBTree_add(tree, "Protocols");
    HTBTree_add(tree, "NeXT");
    HTBTree_add(tree, "Daemon");
    HTBTree_add(tree, "Test");
    HTBTree_add(tree, "Administration");
    HTBTree_add(tree, "LineMode");
    HTBTree_add(tree, "DesignIssues");
    HTBTree_add(tree, "MarkUp");
    HTBTree_add(tree, "Macintosh");
    HTBTree_add(tree, "Proposal.rtf.wn");
    HTBTree_add(tree, "FIND");
    HTBTree_add(tree, "Paper");
    HTBTree_add(tree, "Tcl");
    HTBTree_add(tree, "Talks");
    HTBTree_add(tree, "Architecture");
    HTBTree_add(tree, "VMSHelp");
    HTBTree_add(tree, "Provider");
    HTBTree_add(tree, "Archive");
    HTBTree_add(tree, "SLAC");
    HTBTree_add(tree, "Project");
    HTBTree_add(tree, "News");
    HTBTree_add(tree, "Viola");
    HTBTree_add(tree, "Users");
    HTBTree_add(tree, "FAQ");
    HTBTree_add(tree, "WorkingNotes");
    HTBTree_add(tree, "Windows");
    HTBTree_add(tree, "FineWWW");
    HTBTree_add(tree, "Frame");
    HTBTree_add(tree, "XMosaic");
    HTBTree_add(tree, "People");
    HTBTree_add(tree, "All");
    HTBTree_add(tree, "Curses");
    HTBTree_add(tree, "Erwise");
    HTBTree_add(tree, "Carl");
    HTBTree_add(tree, "MidasWWW");
    HTBTree_add(tree, "XPM");
    HTBTree_add(tree, "MailRobot");
    HTBTree_add(tree, "Illustrations");
    HTBTree_add(tree, "VMClient");
    HTBTree_add(tree, "XPA");
    HTBTree_add(tree, "Clients.html");
    HTBTree_add(tree, "Library");
    HTBTree_add(tree, "CERNLIB_Distribution");
    HTBTree_add(tree, "libHTML");
    HTBTree_add(tree, "WindowsPC");
    HTBTree_add(tree, "tkWWW");
    HTBTree_add(tree, "tk2.3");
    HTBTree_add(tree, "CVS-RCS");
    HTBTree_add(tree, "DecnetSockets");
    HTBTree_add(tree, "SGMLStream");
    HTBTree_add(tree, "NextStep");
    HTBTree_add(tree, "CVSRepository_old");
    HTBTree_add(tree, "ArthurSecret");
    HTBTree_add(tree, "CVSROOT");
    HTBTree_add(tree, "HytelnetGate");
    HTBTree_add(tree, "cern.www.new.src");
    HTBTree_add(tree, "Conditions");
    HTBTree_add(tree, "HTMLGate");
    HTBTree_add(tree, "Makefile");
    HTBTree_add(tree, "Newsgroups.html");
    HTBTree_add(tree, "People.html");
    HTBTree_add(tree, "Bugs.html");
    HTBTree_add(tree, "Summary.html");
    HTBTree_add(tree, "zDesignIssues.wn");
    HTBTree_add(tree, "HT.draw");
    HTBTree_add(tree, "HTandCERN.wn");
    HTBTree_add(tree, "Ideas.wn");
    HTBTree_add(tree, "MarkUp.wn");
    HTBTree_add(tree, "Proposal.html");
    HTBTree_add(tree, "SearchPanel.draw");
    HTBTree_add(tree, "Comments.wn");
    HTBTree_add(tree, "Xanadu.html");
    HTBTree_add(tree, "Storinglinks.html");
    HTBTree_add(tree, "TheW3Book.html");
    HTBTree_add(tree, "Talk_Feb-91.html");
    HTBTree_add(tree, "JFosterEntry.txt");
    HTBTree_add(tree, "Summary.txt");
    HTBTree_add(tree, "Bibliography.html");
    HTBTree_add(tree, "HTandCern.txt");
    HTBTree_add(tree, "Talk.draw");
    HTBTree_add(tree, "zDesignNotes.html");
    HTBTree_add(tree, "Link.html");
    HTBTree_add(tree, "Status.html");
    HTBTree_add(tree, "http.txt");
    HTBTree_add(tree, "People.html~");
    HTBTree_add(tree, "TAGS");
    HTBTree_add(tree, "summary.txt");
    HTBTree_add(tree, "Technical.html");
    HTBTree_add(tree, "Terms.html");
    HTBTree_add(tree, "JANETAccess.html");
    HTBTree_add(tree, "People.txt");
    HTBTree_add(tree, "README.txt");
    HTBTree_add(tree, "CodingStandards.html");
    HTBTree_add(tree, "Copyright.txt");
    HTBTree_add(tree, "Status_old.html");
    HTBTree_add(tree, "patches~");
    HTBTree_add(tree, "RelatedProducts.html");
    HTBTree_add(tree, "Implementation");
    HTBTree_add(tree, "History.html");
    HTBTree_add(tree, "Makefile.bak");
    HTBTree_add(tree, "Makefile.old");
    HTBTree_add(tree, "Policy.html");
    HTBTree_add(tree, "WhatIs.html");
    HTBTree_add(tree, "TheProject.html");
    HTBTree_add(tree, "Notation.html");
    HTBTree_add(tree, "Helping.html");
    HTBTree_add(tree, "Cyber-WWW.sit.Hqx");
    HTBTree_add(tree, "Glossary.html");
    HTBTree_add(tree, "maketags.html");
    HTBTree_add(tree, "IntroCS.html");
    HTBTree_add(tree, "Contrib");
    HTBTree_add(tree, "Help.html");
    HTBTree_add(tree, "CodeManagExec");
    HTBTree_add(tree, "HT-0.1draz");
    HTBTree_add(tree, "Cello");
    HTBTree_add(tree, "TOPUB");
    HTBTree_add(tree, "BUILD");
    HTBTree_add(tree, "BUILDALL");
    HTBTree_add(tree, "Lynx");
    HTBTree_add(tree, "ArthurLibrary");
    HTBTree_add(tree, "RashtyClient");
    HTBTree_add(tree, "#History.html#");
    HTBTree_add(tree, "PerlServers");
    HTBTree_add(tree, "modules");
    HTBTree_add(tree, "NCSA_httpd");
    HTBTree_add(tree, "MAIL2HTML");
    HTBTree_add(tree, "core");
    HTBTree_add(tree, "EmacsWWW");
d702 1
a702 1
    printf("\nTreeTopObject=%s\n\n", tree->top->object);
d704 3
a706 2
    next_element = HTBTree_next(tree, NULL);
    while (next_element != NULL) {
d708 1
a708 1
	printf("The next element is %s\n", next_element->object);
d710 1
a710 1
	next_element = HTBTree_next(tree, next_element);
d714 1
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d12 3
d26 1
a26 1
    HTBTree * tree = typeMalloc(HTBTree);
d44 1
a44 1
	if (element->left != NULL)
d70 1
a70 1
	if (element->left != NULL)
a88 24
PUBLIC void * HTBTree_search ARGS2(
		   HTBTree*,  tree,
		   void*,     object)
    /**********************************************************************
    ** Returns a pointer to equivalent object in a tree or NULL if none.
    */
{
    HTBTElement * cur = tree->top;
    int res;

    while (cur != NULL)
    {
	res = tree->compare(object, cur->object);

	if (res == 0)
	    return cur->object;
	else if (res < 0)
	    cur = cur->left;
	else if (res > 0)
	    cur = cur->right;
    }
    return NULL;
}

d97 1
a97 1
    **		so that the tree remains sorted
d107 21
a127 21
	/* father_of_element is a pointer to the structure that is the father of the
	** new object "object".
	** added_element is a pointer to the structure that contains or will contain
	** the new object "object".
	** father_of_forefather and forefather_of_element are pointers that are used
	** to modify the depths of upper elements, when needed.
	**
	** father_found indicates by a value NO when the future father of "object"
	** is found.
	** top_found indicates by a value NO when, in case of a difference of depths
	**  < 2, the top of the tree is encountered and forbids any further try to
	** balance the tree.
	** corrections is an integer used to avoid infinite loops in cases
	** such as:
	**
	**             3                        3
	**          4                              4
	**           5                            5
	**
	** 3 is used here to show that it need not be the top of the tree.
	*/
d135 8
a142 8
	tree->top = typeMalloc(HTBTElement);
	if (tree->top == NULL) outofmem(__FILE__, "HTBTree_add");
	tree->top->up = NULL;
	tree->top->object = object;
	tree->top->left = NULL;
	tree->top->left_depth = 0;
	tree->top->right = NULL;
	tree->top->right_depth = 0;
d146 8
a153 9
	father_found = YES;
	father_of_element = tree->top;
	added_element = NULL;
	father_of_forefather = NULL;
	forefather_of_element = NULL;
	while (father_found)
	{
	    int res = tree->compare(object,father_of_element->object);
	    if (res < 0)
d155 38
a192 36
		if (father_of_element->left != NULL)
		    father_of_element = father_of_element->left;
		else
		{
		    father_found = NO;
		    father_of_element->left = typeMalloc(HTBTElement);
		    if (father_of_element->left==NULL)
			outofmem(__FILE__, "HTBTree_add");
		    added_element = father_of_element->left;
		    added_element->up = father_of_element;
		    added_element->object = object;
		    added_element->left = NULL;
		    added_element->left_depth = 0;
		    added_element->right = NULL;
		    added_element->right_depth = 0;
		}
	    }
	    else /* res >= 0 */
	   {
		if (father_of_element->right != NULL)
		    father_of_element = father_of_element->right;
		else
		{
		    father_found = NO;
		    father_of_element->right = typeMalloc(HTBTElement);
		    if (father_of_element->right==NULL)
			outofmem(__FILE__, "HTBTree_add");
		    added_element = father_of_element->right;
		    added_element->up = father_of_element;
		    added_element->object = object;
		    added_element->left = NULL;
		    added_element->left_depth = 0;
		    added_element->right = NULL;
		    added_element->right_depth = 0;
		}
	    }
d194 16
a209 17

	/*
	** Changing of all depths that need to be changed
	*/
	father_of_forefather = father_of_element;
	forefather_of_element = added_element;
	do
	{
	    if (father_of_forefather->left == forefather_of_element)
	    {
		depth = father_of_forefather->left_depth;
		father_of_forefather->left_depth = 1
			    + MAXIMUM(forefather_of_element->right_depth,
				  forefather_of_element->left_depth);
		depth2 = father_of_forefather->left_depth;
	    }
	    else
d211 9
a219 9
		depth = father_of_forefather->right_depth;
		father_of_forefather->right_depth = 1
			    + MAXIMUM(forefather_of_element->right_depth,
				  forefather_of_element->left_depth);
		depth2 = father_of_forefather->right_depth;
	    }
	    forefather_of_element = father_of_forefather;
	    father_of_forefather = father_of_forefather->up;
	} while ((depth != depth2) && (father_of_forefather != NULL));
d223 9
a231 9
	    /*
	    ** 2/ Balancing the binary tree, if necessary
	    */
	top_found = YES;
	corrections = 0;
	while ((top_found) && (corrections < 7))
	{
	    if ((abs(father_of_element->left_depth
		      - father_of_element->right_depth)) < 2)
d233 3
a235 3
		if (father_of_element->up != NULL)
		    father_of_element = father_of_element->up;
		else top_found = NO;
d237 2
a238 2
	    else
	    {		     /* We start the process of balancing */
d240 13
a252 13
		corrections = corrections + 1;
		   /*
		   ** corrections is an integer used to avoid infinite
		   ** loops in cases such as:
		   **
		   **             3                        3
		   **          4                              4
		   **           5                            5
		   **
		   ** 3 is used to show that it need not be the top of the tree
		   ** But let's avoid these two exceptions anyhow
		   ** with the two following conditions (4 March 94 - AS)
		   */
d267 8
a274 8
		if (father_of_element->left_depth > father_of_element->right_depth)
		{
		    added_element = father_of_element->left;
		    father_of_element->left_depth = added_element->right_depth;
		    added_element->right_depth = 1
				    + MAXIMUM(father_of_element->right_depth,
					  father_of_element->left_depth);
		    if (father_of_element->up != NULL)
d279 2
a280 2
			father_of_forefather = father_of_element->up;
			forefather_of_element = added_element;
d282 5
a286 5
			do
			{
			    if (father_of_forefather->left
				 == forefather_of_element->up)
			      {
d300 1
a300 1
				depth2 = father_of_forefather->left_depth;
d302 1
a302 1
			    else
d304 1
a304 1
				depth = father_of_forefather->right_depth;
d316 1
a316 1
				depth2 = father_of_forefather->right_depth;
d318 2
a319 2
			    forefather_of_element = forefather_of_element->up;
			    father_of_forefather = father_of_forefather->up;
d322 32
a353 32
			father_of_forefather = father_of_element->up;
			if (father_of_forefather->left == father_of_element)
			{
			    /*
			    **                   3                       3
			    **               4                       5
			    ** When tree   5   6        becomes    7    4
			    **            7 8                          8 6
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree.
			    */
			    father_of_forefather->left = added_element;
			    father_of_element->left = added_element->right;
			    added_element->right = father_of_element;
			}
			if (father_of_forefather->right == father_of_element)
			{
			    /*
			    **          3                       3
			    **               4                       5
			    ** When tree   5   6        becomes    7    4
			    **            7 8                          8 6
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree
			    */
			    father_of_forefather->right = added_element;
			    father_of_element->left = added_element->right;
			    added_element->right = father_of_element;
			}
			added_element->up = father_of_forefather;
d355 1
a355 1
		    else
d357 11
a367 11
			/*
			**
			**               1                       2
			** When tree   2   3        becomes    4    1
			**            4 5                          5 3
			**
			** 1 is used to show that it is the top of the tree
			*/
			added_element->up = NULL;
			father_of_element->left = added_element->right;
			added_element->right = father_of_element;
d369 12
a380 12
		    father_of_element->up = added_element;
		    if (father_of_element->left != NULL)
			father_of_element->left->up = father_of_element;
		}
		else
		{
		    added_element = father_of_element->right;
		    father_of_element->right_depth = added_element->left_depth;
		    added_element->left_depth = 1 +
			    MAXIMUM(father_of_element->right_depth,
				father_of_element->left_depth);
		    if (father_of_element->up != NULL)
d385 2
a386 2
			father_of_forefather = father_of_element->up;
			forefather_of_element = added_element;
d388 3
a390 3
			do
			{
			    if (father_of_forefather->left
d392 3
a394 3
			    {
				depth = father_of_forefather->left_depth;
				if (first_time)
d401 1
a401 1
				else
d404 1
a404 1
					  forefather_of_element->up->right_depth);
d407 1
a407 1
			    else
d409 1
a409 1
				depth = father_of_forefather->right_depth;
d421 1
a421 1
				depth2 = father_of_forefather->right_depth;
d423 2
a424 2
			    father_of_forefather = father_of_forefather->up;
			    forefather_of_element = forefather_of_element->up;
d427 32
a458 32
			father_of_forefather = father_of_element->up;
			if (father_of_forefather->left == father_of_element)
			{
			    /*
			    **                    3                       3
			    **               4                       6
			    ** When tree   5   6        becomes    4    8
			    **                7 8                 5 7
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree.
			    */
			    father_of_forefather->left = added_element;
			    father_of_element->right = added_element->left;
			    added_element->left = father_of_element;
			}
			if (father_of_forefather->right == father_of_element)
			{
			    /*
			    **           3                      3
			    **               4                       6
			    ** When tree   5   6        becomes    4    8
			    **                7 8                 5 7
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree
			    */
			    father_of_forefather->right = added_element;
			    father_of_element->right = added_element->left;
			    added_element->left = father_of_element;
			}
			added_element->up = father_of_forefather;
d460 13
a472 13
		    else
		    {
			/*
			**
			**               1                       3
			** When tree   2   3        becomes    1    5
			**                4 5                 2 4
			**
			** 1 is used to show that it is the top of the tree.
			*/
			added_element->up = NULL;
			father_of_element->right = added_element->left;
			added_element->left = father_of_element;
d474 3
a476 3
		    father_of_element->up = added_element;
		    if (father_of_element->right != NULL)
			father_of_element->right->up = father_of_element;
d479 2
a480 2
	}
	while (father_of_element->up != NULL)
d482 3
a484 3
	    father_of_element = father_of_element->up;
	}
	tree->top = father_of_element;
d491 2
a492 2
			       HTBTree*,       tree,
			       HTBTElement*,   ele)
d504 4
a507 4
	father_of_element = tree->top;
	if (father_of_element != NULL)
	    while (father_of_element->left != NULL)
		father_of_element = father_of_element->left;
d511 2
a512 2
	father_of_element = ele;
	if (father_of_element->right != NULL)
d514 3
a516 3
	    father_of_element = father_of_element->right;
	    while (father_of_element->left != NULL)
		father_of_element = father_of_element->left;
d518 1
a518 1
	else
d520 2
a521 2
	    father_of_forefather = father_of_element->up;
		while (father_of_forefather &&
d523 2
a524 2
		{
		    father_of_element = father_of_forefather;
d527 1
a527 1
	    father_of_element = father_of_forefather;
d536 3
a538 3
	printf("\nObject = %s\t",(char *)father_of_element->object);
	if (father_of_element->up != NULL)
	    printf("Objet du pere = %s\n",
d540 3
a542 3
	else printf("Pas de Pere\n");
	if (father_of_element->left != NULL)
	    printf("Objet du fils gauche = %s\t",
d544 3
a546 3
	else printf("Pas de fils gauche\t");
	if (father_of_element->right != NULL)
	    printf("Objet du fils droit = %s\n",
d548 4
a551 4
	else printf("Pas de fils droit\n");
	printf("Profondeur gauche = %d\t",father_of_element->left_depth);
	printf("Profondeur droite = %d\n",father_of_element->right_depth);
	printf("      **************\n");
d708 1
a708 1
	printf("The next element is %s\n",next_element->object);
d710 1
a710 1
	next_element = HTBTree_next(tree,next_element);
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d17 1
a17 1
HTBTree * HTBTree_new (HTComparer comp)
d35 1
a35 1
static void HTBTElement_free (HTBTElement* element)
d49 1
a49 1
void HTBTree_free (HTBTree* tree)
d61 1
a61 1
static void HTBTElementAndObject_free (HTBTElement* element)
d76 1
a76 1
void HTBTreeAndObject_free (HTBTree* tree)
d86 3
a88 3
void * HTBTree_search (
		   HTBTree*  tree,
		   void*     object)
d112 3
a114 3
void HTBTree_add (
		    HTBTree*  tree,
		    void*     object)
d511 3
a513 3
HTBTElement * HTBTree_next (
			       HTBTree*       tree,
			       HTBTElement*   ele)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 7
a8 6
 *                  ==============================
 *                      Author: Arthur Secret
 *
 *       4 March 94: Bug fixed in the balancing procedure
 *
 */
d17 5
a21 5
/*********************************************************
 * This function returns an HTBTree with memory allocated
 * for it when given a mean to compare things
 */
HTBTree *HTBTree_new(HTComparer comp)
d23 2
a24 4
    HTBTree *tree = typeMalloc(HTBTree);

    if (tree == NULL)
	outofmem(__FILE__, "HTBTree_new");
d32 7
a38 4
/*********************************************************
 * This void will free the memory allocated for one element
 */
static void HTBTElement_free(HTBTElement *element)
d49 4
a52 4
/*************************************************************
 * This void will free the memory allocated for the whole tree
 */
void HTBTree_free(HTBTree *tree)
d58 7
a64 4
/*********************************************************
 * This void will free the memory allocated for one element
 */
static void HTBTElementAndObject_free(HTBTElement *element)
d66 1
a66 1
    if (element) {		/* Just in case nothing was in the tree anyway */
d76 4
a79 4
/*************************************************************
 * This void will free the memory allocated for the whole tree
 */
void HTBTreeAndObject_free(HTBTree *tree)
d85 7
a91 5
/*********************************************************************
 * Returns a pointer to equivalent object in a tree or NULL if none.
 */
void *HTBTree_search(HTBTree *tree,
		     void *object)
d93 1
a93 1
    HTBTElement *cur = tree->top;
d96 2
a97 1
    while (cur != NULL) {
d110 11
a120 8
/*********************************************************************
 * This void is the core of HTBTree.c . It will
 *       1/ add a new element to the tree at the right place
 *		so that the tree remains sorted
 *       2/ balance the tree to be as fast as possible when reading it
 */
void HTBTree_add(HTBTree *tree,
		 void *object)
d122 27
a148 25
    HTBTElement *father_of_element;
    HTBTElement *added_element;
    HTBTElement *forefather_of_element;
    HTBTElement *father_of_forefather;
    BOOL father_found, top_found;
    int depth, depth2, corrections;

    /* father_of_element is a pointer to the structure that is the father of
     * the new object "object".  added_element is a pointer to the structure
     * that contains or will contain the new object "object". 
     * father_of_forefather and forefather_of_element are pointers that are
     * used to modify the depths of upper elements, when needed.
     *
     * father_found indicates by a value NO when the future father of "object"
     * is found.  top_found indicates by a value NO when, in case of a
     * difference of depths < 2, the top of the tree is encountered and forbids
     * any further try to balance the tree.  corrections is an integer used to
     * avoid infinite loops in cases such as:
     *
     *             3                        3
     *          4                              4
     *           5                            5
     *
     * 3 is used here to show that it need not be the top of the tree.
     */
d151 2
a152 2
     * 1/ Adding of the element to the binary tree
     */
d154 2
a155 1
    if (tree->top == NULL) {
d157 1
a157 3

	if (tree->top == NULL)
	    outofmem(__FILE__, "HTBTree_add");
d164 3
a166 1
    } else {
d172 5
a176 4
	while (father_found) {
	    int res = tree->compare(object, father_of_element->object);

	    if (res < 0) {
d179 2
a180 1
		else {
d183 1
a183 2

		    if (father_of_element->left == NULL)
d193 3
a195 1
	    } else {		/* res >= 0 */
d198 2
a199 1
		else {
d202 1
a202 2

		    if (father_of_element->right == NULL)
d216 2
a217 2
	 * Changing of all depths that need to be changed
	 */
d220 4
a223 2
	do {
	    if (father_of_forefather->left == forefather_of_element) {
d226 2
a227 2
		    + MAXIMUM(forefather_of_element->right_depth,
			      forefather_of_element->left_depth);
d229 3
a231 1
	    } else {
d234 2
a235 2
		    + MAXIMUM(forefather_of_element->right_depth,
			      forefather_of_element->left_depth);
d242 5
a246 3
	/*
	 * 2/ Balancing the binary tree, if necessary
	 */
d249 2
a250 1
	while ((top_found) && (corrections < 7)) {
d252 2
a253 1
		     - father_of_element->right_depth)) < 2) {
d256 4
a259 3
		else
		    top_found = NO;
	    } else {		/* We start the process of balancing */
d262 12
a273 12
		/*
		 * corrections is an integer used to avoid infinite
		 * loops in cases such as:
		 *
		 *             3                        3
		 *          4                              4
		 *           5                            5
		 *
		 * 3 is used to show that it need not be the top of the tree
		 * But let's avoid these two exceptions anyhow
		 * with the two following conditions (4 March 94 - AS)
		 */
d287 3
a289 1
		if (father_of_element->left_depth > father_of_element->right_depth) {
d293 4
a296 3
			+ MAXIMUM(father_of_element->right_depth,
				  father_of_element->left_depth);
		    if (father_of_element->up != NULL) {
d303 2
a304 1
			do {
d306 7
a312 5
				== forefather_of_element->up) {
				depth = father_of_forefather->left_depth;
				if (first_time) {
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->left_depth,
d314 6
a319 5
				    first_time = NO;
				} else
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
d322 3
a324 1
			    } else {
d326 2
a327 1
				if (first_time) {
d329 2
a330 2
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
d332 2
a333 1
				} else
d335 2
a336 2
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
d344 2
a345 1
			if (father_of_forefather->left == father_of_element) {
d347 8
a354 8
			     *                   3                       3
			     *               4                       5
			     * When tree   5   6        becomes    7    4
			     *            7 8                          8 6
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree.
			     */
d359 2
a360 1
			if (father_of_forefather->right == father_of_element) {
d362 8
a369 8
			     *          3                       3
			     *               4                       5
			     * When tree   5   6        becomes    7    4
			     *            7 8                          8 6
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree
			     */
d375 3
a377 1
		    } else {
d379 7
a385 7

			 *               1                       2
			 * When tree   2   3        becomes    4    1
			 *            4 5                          5 3
			 *
			 * 1 is used to show that it is the top of the tree
			 */
d393 3
a395 1
		} else {
d399 1
a399 1
			MAXIMUM(father_of_element->right_depth,
d409 2
a410 1
			do {
d412 2
a413 1
				== forefather_of_element->up) {
d415 2
a416 1
				if (first_time) {
d418 2
a419 2
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
d421 2
a422 1
				} else
d424 2
a425 2
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
d427 3
a429 1
			    } else {
d431 2
a432 1
				if (first_time) {
d434 2
a435 2
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
d437 2
a438 1
				} else
d440 2
a441 2
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
d449 2
a450 1
			if (father_of_forefather->left == father_of_element) {
d452 8
a459 8
			     *                    3                       3
			     *               4                       6
			     * When tree   5   6        becomes    4    8
			     *                7 8                 5 7
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree.
			     */
d464 2
a465 1
			if (father_of_forefather->right == father_of_element) {
d467 8
a474 8
			     *           3                      3
			     *               4                       6
			     * When tree   5   6        becomes    4    8
			     *                7 8                 5 7
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree
			     */
d480 3
a482 1
		    } else {
d484 7
a490 7

			 *               1                       3
			 * When tree   2   3        becomes    1    5
			 *                4 5                 2 4
			 *
			 * 1 is used to show that it is the top of the tree.
			 */
d501 2
a502 1
	while (father_of_element->up != NULL) {
d509 10
a518 7
/*************************************************************************
 * this function returns a pointer to the leftmost element if ele is NULL,
 * and to the next object to the right otherwise.
 * If no elements left, returns a pointer to NULL.
 */
HTBTElement *HTBTree_next(HTBTree *tree,
			  HTBTElement *ele)
d520 2
a521 2
    HTBTElement *father_of_element;
    HTBTElement *father_of_forefather;
d523 2
a524 1
    if (ele == NULL) {
d529 3
a531 1
    } else {
d533 2
a534 1
	if (father_of_element->right != NULL) {
d538 3
a540 1
	} else {
d542 6
a547 5
	    while (father_of_forefather &&
		   (father_of_forefather->right == father_of_element)) {
		father_of_element = father_of_forefather;
		father_of_forefather = father_of_element->up;
	    }
d553 5
a557 4
     * about the way the process is running, for debugging matters
     */
    if (father_of_element != NULL) {
	printf("\nObject = %s\t", (char *) father_of_element->object);
d560 2
a561 3
		   (char *) father_of_element->up->object);
	else
	    printf("Pas de Pere\n");
d564 2
a565 3
		   (char *) father_of_element->left->object);
	else
	    printf("Pas de fils gauche\t");
d568 4
a571 5
		   (char *) father_of_element->right->object);
	else
	    printf("Pas de fils droit\n");
	printf("Profondeur gauche = %d\t", father_of_element->left_depth);
	printf("Profondeur droite = %d\n", father_of_element->right_depth);
d578 1
d580 4
a583 4
/*****************************************************
 * This is just a test to show how to handle HTBTree.c
 */
main()
d585 2
a586 2
    HTBTree *tree;
    HTBTElement *next_element;
d588 134
a721 134
    tree = HTBTree_new((HTComparer) strcasecomp);
    HTBTree_add(tree, "hypertext");
    HTBTree_add(tree, "Addressing");
    HTBTree_add(tree, "X11");
    HTBTree_add(tree, "Tools");
    HTBTree_add(tree, "Proposal.wn");
    HTBTree_add(tree, "Protocols");
    HTBTree_add(tree, "NeXT");
    HTBTree_add(tree, "Daemon");
    HTBTree_add(tree, "Test");
    HTBTree_add(tree, "Administration");
    HTBTree_add(tree, "LineMode");
    HTBTree_add(tree, "DesignIssues");
    HTBTree_add(tree, "MarkUp");
    HTBTree_add(tree, "Macintosh");
    HTBTree_add(tree, "Proposal.rtf.wn");
    HTBTree_add(tree, "FIND");
    HTBTree_add(tree, "Paper");
    HTBTree_add(tree, "Tcl");
    HTBTree_add(tree, "Talks");
    HTBTree_add(tree, "Architecture");
    HTBTree_add(tree, "VMSHelp");
    HTBTree_add(tree, "Provider");
    HTBTree_add(tree, "Archive");
    HTBTree_add(tree, "SLAC");
    HTBTree_add(tree, "Project");
    HTBTree_add(tree, "News");
    HTBTree_add(tree, "Viola");
    HTBTree_add(tree, "Users");
    HTBTree_add(tree, "FAQ");
    HTBTree_add(tree, "WorkingNotes");
    HTBTree_add(tree, "Windows");
    HTBTree_add(tree, "FineWWW");
    HTBTree_add(tree, "Frame");
    HTBTree_add(tree, "XMosaic");
    HTBTree_add(tree, "People");
    HTBTree_add(tree, "All");
    HTBTree_add(tree, "Curses");
    HTBTree_add(tree, "Erwise");
    HTBTree_add(tree, "Carl");
    HTBTree_add(tree, "MidasWWW");
    HTBTree_add(tree, "XPM");
    HTBTree_add(tree, "MailRobot");
    HTBTree_add(tree, "Illustrations");
    HTBTree_add(tree, "VMClient");
    HTBTree_add(tree, "XPA");
    HTBTree_add(tree, "Clients.html");
    HTBTree_add(tree, "Library");
    HTBTree_add(tree, "CERNLIB_Distribution");
    HTBTree_add(tree, "libHTML");
    HTBTree_add(tree, "WindowsPC");
    HTBTree_add(tree, "tkWWW");
    HTBTree_add(tree, "tk2.3");
    HTBTree_add(tree, "CVS-RCS");
    HTBTree_add(tree, "DecnetSockets");
    HTBTree_add(tree, "SGMLStream");
    HTBTree_add(tree, "NextStep");
    HTBTree_add(tree, "CVSRepository_old");
    HTBTree_add(tree, "ArthurSecret");
    HTBTree_add(tree, "CVSROOT");
    HTBTree_add(tree, "HytelnetGate");
    HTBTree_add(tree, "cern.www.new.src");
    HTBTree_add(tree, "Conditions");
    HTBTree_add(tree, "HTMLGate");
    HTBTree_add(tree, "Makefile");
    HTBTree_add(tree, "Newsgroups.html");
    HTBTree_add(tree, "People.html");
    HTBTree_add(tree, "Bugs.html");
    HTBTree_add(tree, "Summary.html");
    HTBTree_add(tree, "zDesignIssues.wn");
    HTBTree_add(tree, "HT.draw");
    HTBTree_add(tree, "HTandCERN.wn");
    HTBTree_add(tree, "Ideas.wn");
    HTBTree_add(tree, "MarkUp.wn");
    HTBTree_add(tree, "Proposal.html");
    HTBTree_add(tree, "SearchPanel.draw");
    HTBTree_add(tree, "Comments.wn");
    HTBTree_add(tree, "Xanadu.html");
    HTBTree_add(tree, "Storinglinks.html");
    HTBTree_add(tree, "TheW3Book.html");
    HTBTree_add(tree, "Talk_Feb-91.html");
    HTBTree_add(tree, "JFosterEntry.txt");
    HTBTree_add(tree, "Summary.txt");
    HTBTree_add(tree, "Bibliography.html");
    HTBTree_add(tree, "HTandCern.txt");
    HTBTree_add(tree, "Talk.draw");
    HTBTree_add(tree, "zDesignNotes.html");
    HTBTree_add(tree, "Link.html");
    HTBTree_add(tree, "Status.html");
    HTBTree_add(tree, "http.txt");
    HTBTree_add(tree, "People.html~");
    HTBTree_add(tree, "TAGS");
    HTBTree_add(tree, "summary.txt");
    HTBTree_add(tree, "Technical.html");
    HTBTree_add(tree, "Terms.html");
    HTBTree_add(tree, "JANETAccess.html");
    HTBTree_add(tree, "People.txt");
    HTBTree_add(tree, "README.txt");
    HTBTree_add(tree, "CodingStandards.html");
    HTBTree_add(tree, "Copyright.txt");
    HTBTree_add(tree, "Status_old.html");
    HTBTree_add(tree, "patches~");
    HTBTree_add(tree, "RelatedProducts.html");
    HTBTree_add(tree, "Implementation");
    HTBTree_add(tree, "History.html");
    HTBTree_add(tree, "Makefile.bak");
    HTBTree_add(tree, "Makefile.old");
    HTBTree_add(tree, "Policy.html");
    HTBTree_add(tree, "WhatIs.html");
    HTBTree_add(tree, "TheProject.html");
    HTBTree_add(tree, "Notation.html");
    HTBTree_add(tree, "Helping.html");
    HTBTree_add(tree, "Cyber-WWW.sit.Hqx");
    HTBTree_add(tree, "Glossary.html");
    HTBTree_add(tree, "maketags.html");
    HTBTree_add(tree, "IntroCS.html");
    HTBTree_add(tree, "Contrib");
    HTBTree_add(tree, "Help.html");
    HTBTree_add(tree, "CodeManagExec");
    HTBTree_add(tree, "HT-0.1draz");
    HTBTree_add(tree, "Cello");
    HTBTree_add(tree, "TOPUB");
    HTBTree_add(tree, "BUILD");
    HTBTree_add(tree, "BUILDALL");
    HTBTree_add(tree, "Lynx");
    HTBTree_add(tree, "ArthurLibrary");
    HTBTree_add(tree, "RashtyClient");
    HTBTree_add(tree, "#History.html#");
    HTBTree_add(tree, "PerlServers");
    HTBTree_add(tree, "modules");
    HTBTree_add(tree, "NCSA_httpd");
    HTBTree_add(tree, "MAIL2HTML");
    HTBTree_add(tree, "core");
    HTBTree_add(tree, "EmacsWWW");
d723 1
a723 1
    printf("\nTreeTopObject=%s\n\n", tree->top->object);
d725 3
a727 2
    next_element = HTBTree_next(tree, NULL);
    while (next_element != NULL) {
d729 1
a729 1
	printf("The next element is %s\n", next_element->object);
d731 1
a731 1
	next_element = HTBTree_next(tree, next_element);
d735 1
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d12 3
@

