head	1.7;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.8
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.6
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2005.01.03.00.45.50;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.42;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.28;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.55.52;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.04;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.11;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.02;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.56;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.47;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.23;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.09;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.46.12;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@soft merge
@
text
@/*							HTVMS_WAISUI.h
 *
 *	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
 *
 *	31-May-1994 FM	Initial version.
 */

#ifndef HTVMSWAIS_H
#define HTVMSWAIS_H

#ifndef HTUTILS_H
#include <HTUtils.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif
    void log_write(char *);

/*
 *	Routines originally from Panic.h -- FM
 *
 *----------------------------------------------------------------------*/

    void panic(char *format,...);

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from CUtil.h -- FM
 *
 *----------------------------------------------------------------------*/

/* types and constants */

#ifndef boolean
#define boolean unsigned long
#endif				/* boolean */

#ifndef true
#define true	(boolean)1L
#endif				/* true */

#ifndef false
#define false	(boolean)0L	/* used to be (!true), but broke
				   some compilers */
#endif				/* false */

#ifndef TRUE
#define TRUE	true
#endif				/* TRUE */

#ifndef FALSE
#define FALSE	false
#endif				/* FALSE */

/*----------------------------------------------------------------------*/
/* functions */

/* enhanced memory handling functions - don't call them directly, use the
   macros below */
    void fs_checkPtr(void *ptr);
    void *fs_malloc(size_t size);
    void *fs_realloc(void *ptr, size_t size);
    void fs_free(void *ptr);
    char *fs_strncat(char *dst, char *src, size_t maxToAdd, size_t maxTotal);

/* macros for memory functions.  call these in your program.  */
#define s_checkPtr(ptr)		fs_checkPtr(ptr)
#define s_malloc(size)		fs_malloc(size)
#define s_realloc(ptr,size)	fs_realloc((ptr),(size))
#define s_free(ptr)		{ fs_free((char*)ptr); ptr = NULL; }
#define s_strncat(dst,src,maxToAdd,maxTotal)	fs_strncat((dst),(src),(maxToAdd),(maxTotal))

    char *s_strdup(char *s);

#define IS_DELIMITER	1
#define	NOT_DELIMITER	!IS_DELIMITER

    char char_downcase(unsigned long ch);
    char *string_downcase(char *word);

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from ZUtil.c -- FM
 *
 *----------------------------------------------------------------------*/

/* Data types / constants */

/* bytes to leave for the header size info */
#define HEADER_LEN	(size_t)2

    typedef long pdu_type;

#define	initAPDU			(pdu_type)20
#define	initResponseAPDU		(pdu_type)21
#define	searchAPDU			(pdu_type)22
#define	searchResponseAPDU		(pdu_type)23
#define	presentAPDU			(pdu_type)24
#define	presentResponseAPDU		(pdu_type)25
#define	deteteAPDU			(pdu_type)26
#define	deleteResponseAPDU		(pdu_type)27
#define	accessControlAPDU		(pdu_type)28
#define	accessControlResponseAPDU	(pdu_type)29
#define	resourceControlAPDU		(pdu_type)30
#define	resourceControlResponseAPDU	(pdu_type)31

    typedef struct any {	/* an any is a non-ascii string of characters */
	unsigned long size;
	char *bytes;
    } any;

    typedef any bit_map;	/* a bit_map is a group of packed bits */

    typedef unsigned long data_tag;

#define DT_PDUType			(data_tag)1
#define	DT_ReferenceID			(data_tag)2
#define	DT_ProtocolVersion		(data_tag)3
#define	DT_Options			(data_tag)4
#define	DT_PreferredMessageSize		(data_tag)5
#define	DT_MaximumRecordSize		(data_tag)6
#define	DT_IDAuthentication		(data_tag)7
#define	DT_ImplementationID		(data_tag)8
#define	DT_ImplementationName		(data_tag)9
#define	DT_ImplementationVersion	(data_tag)10
#define	DT_UserInformationField		(data_tag)11
#define	DT_Result			(data_tag)12
#define	DT_SmallSetUpperBound		(data_tag)13
#define	DT_LargeSetLowerBound		(data_tag)14
#define	DT_MediumSetPresentNumber	(data_tag)15
#define	DT_ReplaceIndicator		(data_tag)16
#define	DT_ResultSetName		(data_tag)17
#define	DT_DatabaseNames		(data_tag)18
#define DT_ElementSetNames		(data_tag)19
#define	DT_QueryType			(data_tag)20
#define	DT_Query			(data_tag)21
#define	DT_SearchStatus			(data_tag)22
#define	DT_ResultCount			(data_tag)23
#define	DT_NumberOfRecordsReturned	(data_tag)24
#define	DT_NextResultSetPosition	(data_tag)25
#define	DT_ResultSetStatus		(data_tag)26
#define	DT_PresentStatus		(data_tag)27
#define	DT_DatabaseDiagnosticRecords	(data_tag)28
#define	DT_NumberOfRecordsRequested	(data_tag)29
#define	DT_ResultSetStartPosition	(data_tag)30
#define	DT_ResultSetID			(data_tag)31
#define	DT_DeleteOperation		(data_tag)32
#define	DT_DeleteStatus			(data_tag)33
#define	DT_NumberNotDeleted		(data_tag)34
#define	DT_BulkStatuses			(data_tag)35
#define	DT_DeleteMSG			(data_tag)36
#define	DT_SecurityChallenge		(data_tag)37
#define	DT_SecurityChallengeResponse	(data_tag)38
#define	DT_SuspendedFlag		(data_tag)39
#define	DT_ResourceReport		(data_tag)40
#define	DT_PartialResultsAvailable	(data_tag)41
#define	DT_ContinueFlag			(data_tag)42
#define	DT_ResultSetWanted		(data_tag)43

#define UNUSED	-1

/* number of bytes required to represent the following sizes in compressed
   integer format
 */
#define CompressedInt1Byte	128	/* 2 ^ 7 */
#define CompressedInt2Byte	16384	/* 2 ^ 14 */
#define CompressedInt3Byte	2097152		/* 2 ^ 21 */
/* others may follow ... */

/* types of query */
#define QT_0	"0"		/* query whose non-standard format has been agreed upon
				   client and server */
/* values for InitAPDU option element */
#define	WILL_USE		TRUE
#define WILL_NOT_USE		FALSE
#define WILL_SUPPORT		TRUE
#define WILL_NOT_SUPPORT	FALSE

/* values for InitResponseAPDU result element */
#define ACCEPT	TRUE
#define REJECT	FALSE

/* values for SearchResponseAPDU search status element */
#define	SUCCESS	0		/* intuitive huh? */
#define FAILURE	1

/* values for SearchResponseAPDU result set status element */
#define	SUBSET	1
#define INTERIM	2
#define NONE	3

/* values for SearchResponseAPDU present status element */
/* SUCCESS already defined */
#define PARTIAL_1	1
#define PARTIAL_2	2
#define PARTIAL_3	3
#define PARTIAL_4	4
#define PS_NONE		5	/* can't use NONE since it was used by result
				   set status */

#define DIAGNOSTIC_CODE_SIZE	(size_t)3

    typedef struct diagnosticRecord {
	boolean SURROGATE;
	char DIAG[DIAGNOSTIC_CODE_SIZE];
	char *ADDINFO;
    } diagnosticRecord;

#define D_PermanentSystemError	       "S1"
#define D_TemporarySystemError         "S2"
#define D_UnsupportedSearch            "S3"
#define D_TermsOnlyStopWords           "S5"
#define D_TooManyArgumentWords         "S6"
#define D_TooManyBooleanOperators      "S7"
#define D_TooManyTruncatedWords        "S8"
#define D_TooMany IncompleteSubfields  "S9"
#define D_TruncatedWordsTooShort       "SA"
#define D_InvalidFormatForRecordNumber "SB"
#define D_TooManyCharactersInSearch    "SC"
#define D_TooManyRecordsRetrieved      "SD"
#define D_PresentRequestOutOfRange     "SF"
#define D_SystemErrorInPresentRecords  "SG"
#define D_RecordNotAuthorizedToBeSent  "SH"
#define D_RecordExceedsPrefMessageSize "SI"
#define D_RecordExceedsMaxRecordSize   "SJ"
#define D_ResultSetNotSuppAsSearchTerm "SK"
#define D_OnlyOneRsltSetAsSrchTermSupp "SL"
#define D_OnlyANDingOfASnglRsltSetSupp "SM"
#define D_RsltSetExistsNoReplace       "SN"
#define D_ResultSetNamingNotSupported  "SO"
#define D_CombinationDatabasesNotSupp  "SP"
#define D_ElementSetNamesNotSupported  "SQ"
#define D_ElementSetNameNotValid       "SR"
#define D_OnlyASingleElmntSetNameSupp  "SS"
#define D_ResultSetDeletedByTarget     "ST"
#define D_ResultSetIsInUse             "SU"
#define D_DatabasesIsLocked            "SV"
#define D_TerminatedByNoContinueResp   "SW"
#define D_ResultSetDoesNotExist        "SX"
#define D_ResExNoResultsAvailable      "SY"
#define D_ResExUnpredictableResults    "SZ"
#define D_ResExValidSubsetOfResults    "T1"
#define D_AccessControlFailure         "T2"
#define D_SecurityNotIssuedReqTerm     "T3"
#define D_SecurityNotBeIssuedRecNotInc "T4"

/*----------------------------------------------------------------------*/

/* for internal error handling */

    extern char *readErrorPosition;	/* pos where buf stoped making sense */

/* the following are macros so that they can return OUT of the function
   which calls them
 */

#define RETURN_ON_NULL(var)					\
	if (var == NULL)					\
	  return(NULL);		/* jump out of caller */

#define REPORT_READ_ERROR(pos)					\
	{ readErrorPosition = (pos);				\
	  return(NULL); /* jump out of caller */		\
    }

#define CHECK_FOR_SPACE_LEFT(spaceNeeded,spaceLeft)		\
	{ if (*spaceLeft >= spaceNeeded)			\
	    (*spaceLeft) -= spaceNeeded;			\
	  else							\
	   { *spaceLeft = 0;					\
	     return(NULL); /* jump out of the caller */		\
	   }							\
	}

/*----------------------------------------------------------------------*/

    diagnosticRecord *makeDiag(boolean surrogate, char *code, char *addInfo);
    void freeDiag(diagnosticRecord * diag);
    char *writeDiag(diagnosticRecord * diag, char *buffer, long *len);
    char *readDiag(diagnosticRecord ** diag, char *buffer);

    char *writeCompressedInteger(unsigned long num, char *buf, long *len);
    char *readCompressedInteger(unsigned long *num, char *buf);
    char *writeCompressedIntWithPadding(unsigned long num, unsigned long size,
					char *buffer, long *len);
    unsigned long writtenCompressedIntSize(unsigned long num);

    char *writeTag(data_tag tag, char *buf, long *len);
    char *readTag(data_tag *tag, char *buf);
    data_tag peekTag(char *buf);
    unsigned long writtenTagSize(data_tag tag);

    any *makeAny(unsigned long size, char *data);
    void freeAny(any *a);
    any *duplicateAny(any *a);
    char *writeAny(any *a, data_tag tag, char *buffer, long *len);
    char *readAny(any **anAny, char *buffer);
    unsigned long writtenAnySize(data_tag tag, any *a);

    any *stringToAny(char *s);
    char *anyToString(any *a);
    unsigned long writtenStringSize(data_tag tag, char *s);

    any *longToAny(long Num);
    long anyToLong(any *a);

    char *writeString(char *s, data_tag tag, char *buffer, long *len);
    char *readString(char **s, char *buffer);

    bit_map *makeBitMap(unsigned long numBits,...);

    void freeBitMap(bit_map *bm);
    boolean bitAtPos(unsigned long pos, bit_map *bm);
    char *writeBitMap(bit_map *bm, data_tag tag, char *buffer, long *len);
    char *readBitMap(bit_map **bm, char *buffer);

    char *writeByte(unsigned long byte, char *buf, long *len);
    char *readByte(unsigned char *byte, char *buf);

    char *writeBoolean(boolean flag, char *buf, long *len);
    char *readBoolean(boolean *flag, char *buf);

    char *writePDUType(pdu_type pduType, char *buf, long *len);
    char *readPDUType(pdu_type *pduType, char *buf);
    pdu_type peekPDUType(char *buf);

    char *writeBinaryInteger(long num, unsigned long size,
			     char *buf, long *len);
    char *readBinaryInteger(long *num, unsigned long size, char *buf);
    unsigned long writtenCompressedBinIntSize(long num);

    char *writeNum(long num, data_tag tag, char *buffer, long *len);
    char *readNum(long *num, char *buffer);
    unsigned long writtenNumSize(data_tag tag, long num);

    void doList(void **list, void (*func) (void *));

    char *writeProtocolVersion(char *buf, long *len);
    char *defaultImplementationID(void);
    char *defaultImplementationName(void);
    char *defaultImplementationVersion(void);

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from ZType1.c -- FM
 *
 *----------------------------------------------------------------------*/

/* This file implements the type 1 query defined in appendices B & C
   of the SR 1 spec.
 */

/*----------------------------------------------------------------------*/
/* types and constants */

/* new data tags */
#define	DT_AttributeList	(data_tag)44
#define DT_Term			(data_tag)45
#define DT_Operator		(data_tag)46

#define QT_BooleanQuery	"1"	/* standard boolean query */

/* general attribute code - use in place of any attribute */
#define IGNORE			"ig"

/* use value codes */
#define	UV_ISBN			"ub"
#define	CORPORATE_NAME		"uc"
#define	ISSN			"us"
#define	PERSONAL_NAME		"up"
#define	SUBJECT			"uj"
#define	TITLE			"ut"
#define	GEOGRAPHIC_NAME		"ug"
#define	CODEN			"ud"
#define	SUBJECT_SUBDIVISION	"ue"
#define	SERIES_TITLE		"uf"
#define	MICROFORM_GENERATION	"uh"
#define	PLACE_OF_PUBLICATION	"ui"
#define	NUC_CODE		"uk"
#define	LANGUAGE		"ul"
#define	COMBINATION_OF_USE_VALUES	"um"
#define	SYSTEM_CONTROL_NUMBER	"un"
#define	DATE			"uo"
#define	LC_CONTROL_NUMBER	"ur"
#define	MUSIC_PUBLISHERS_NUMBER	"uu"
#define	GOVERNMENT_DOCUMENTS_NUMBER	"uv"
#define	SUBJECT_CLASSIFICATION	"uw"
#define	RECORD_TYPE		"uy"

/* relation value codes */
#define	EQUAL			"re"
#define	GREATER_THAN		"rg"
#define	GREATER_THAN_OR_EQUAL	"ro"
#define	LESS_THAN		"rl"
#define	LESS_THAN_OR_EQUAL	"rp"
#define	NOT_EQUAL		"rn"

/* position value codes */
#define	FIRST_IN_FIELD		"pf"
#define	FIRST_IN_SUBFIELD	"ps"
#define	FIRST_IN_A_SUBFIELD	"pa"
#define	FIRST_IN_NOT_A_SUBFIELD	"pt"
#define	ANY_POSITION_IN_FIELD	"py"

/* structure value codes */
#define	PHRASE			"sp"
#define	WORD			"sw"
#define	KEY			"sk"
#define	WORD_LIST		"sl"

/* truncation value codes */
#define	NO_TRUNCATION		"tn"
#define	RIGHT_TRUNCATION	"tr"
#define	PROC_NUM_INCLUDED_IN_SEARCH_ARG	"ti"

/* completeness value codes */
#define	INCOMPLETE_SUBFIELD	"ci"
#define	COMPLETE_SUBFIELD	"cs"
#define	COMPLETEFIELD		"cf"

/* operator codes */
#define AND	"a"
#define OR	"o"
#define AND_NOT	"n"

/* term types */
#define TT_Attribute		1
#define	TT_ResultSetID		2
#define	TT_Operator		3

#define ATTRIBUTE_SIZE		3
#define OPERATOR_SIZE		2

    typedef struct query_term {
	/* type */
	long TermType;
	/* for term */
	char Use[ATTRIBUTE_SIZE];
	char Relation[ATTRIBUTE_SIZE];
	char Position[ATTRIBUTE_SIZE];
	char Structure[ATTRIBUTE_SIZE];
	char Truncation[ATTRIBUTE_SIZE];
	char Completeness[ATTRIBUTE_SIZE];
	any *Term;
	/* for result set */
	any *ResultSetID;
	/* for operator */
	char Operator[OPERATOR_SIZE];
    } query_term;

/*----------------------------------------------------------------------*/
/* functions */

    query_term *makeAttributeTerm(char *use, char *relation, char *position, char *structure,
				  char *truncation, char *completeness, any *term);
    query_term *makeResultSetTerm(any *resultSet);
    query_term *makeOperatorTerm(char *operatorCode);
    void freeTerm(void *qt);
    char *writeQueryTerm(query_term *qt, char *buffer, long *len);
    char *readQueryTerm(query_term **qt, char *buffer);
    any *writeQuery(query_term **terms);
    query_term **readQuery(any *info);

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from UI.c -- FM
 *
 *----------------------------------------------------------------------*/

    char *generate_retrieval_apdu(char *buff,
				  long *buff_len,
				  any *docID,
				  long chunk_type,
				  long start_line, long end_line,
				  char *type,
				  char *database_name);

    long interpret_message(char *request_message,
			   long request_length,
			   char *response_message,
			   long response_buffer_length,		/* length of the buffer (modified) */
			   long connection,
			   boolean verbose);

    char *trim_junk(char *headline);

/*
 *	Routines originally from ZProt.c -- FM
 *
 *----------------------------------------------------------------------*/

/* APDU types */

    typedef struct InitAPDU {
	pdu_type PDUType;
	boolean willSearch, willPresent, willDelete;
	boolean supportAccessControl, supportResourceControl;
	long PreferredMessageSize;
	long MaximumRecordSize;
	char *IDAuthentication;
	char *ImplementationID;
	char *ImplementationName;
	char *ImplementationVersion;
	any *ReferenceID;
	void *UserInformationField;
    } InitAPDU;

    typedef struct InitResponseAPDU {
	pdu_type PDUType;
	boolean Result;
	boolean willSearch, willPresent, willDelete;
	boolean supportAccessControl, supportResourceControl;
	long PreferredMessageSize;
	long MaximumRecordSize;
	char *IDAuthentication;
	char *ImplementationID;
	char *ImplementationName;
	char *ImplementationVersion;
	any *ReferenceID;
	void *UserInformationField;
    } InitResponseAPDU;

    typedef struct SearchAPDU {
	pdu_type PDUType;
	long SmallSetUpperBound;
	long LargeSetLowerBound;
	long MediumSetPresentNumber;
	boolean ReplaceIndicator;
	char *ResultSetName;
	char **DatabaseNames;
	char *QueryType;
	char **ElementSetNames;
	any *ReferenceID;
	void *Query;
    } SearchAPDU;

    typedef struct SearchResponseAPDU {
	pdu_type PDUType;
	long SearchStatus;
	long ResultCount;
	long NumberOfRecordsReturned;
	long NextResultSetPosition;
	long ResultSetStatus;
	long PresentStatus;
	any *ReferenceID;
	void *DatabaseDiagnosticRecords;
    } SearchResponseAPDU;

    typedef struct PresentAPDU {
	pdu_type PDUType;
	long NumberOfRecordsRequested;
	long ResultSetStartPosition;
	char *ResultSetID;
	char *ElementSetNames;
	any *ReferenceID;
	void *PresentInfo;
    } PresentAPDU;

    typedef struct PresentResponseAPDU {
	pdu_type PDUType;
	boolean PresentStatus;
	long NumberOfRecordsReturned;
	long NextResultSetPosition;
	any *ReferenceID;
	void *DatabaseDiagnosticRecords;
    } PresentResponseAPDU;

/*----------------------------------------------------------------------*/
/* Functions */

    InitAPDU *makeInitAPDU(boolean search, boolean present, boolean deleteIt,
			   boolean accessControl, boolean resourceControl, long prefMsgSize,
			   long maxMsgSize,
			   char *auth,
			   char *id,
			   char *name,
			   char *version,
			   any *refID,
			   void *userInfo);
    void freeInitAPDU(InitAPDU * init);
    char *writeInitAPDU(InitAPDU * init, char *buffer, long *len);
    char *readInitAPDU(InitAPDU ** init, char *buffer);

    InitResponseAPDU *makeInitResponseAPDU(boolean result,
					   boolean search,
					   boolean present,
					   boolean deleteIt,
					   boolean accessControl,
					   boolean resourceControl,
					   long prefMsgSize,
					   long maxMsgSize,
					   char *auth,
					   char *id,
					   char *name,
					   char *version,
					   any *refID,
					   void *userInfo);
    void freeInitResponseAPDU(InitResponseAPDU *init);
    char *writeInitResponseAPDU(InitResponseAPDU *init, char *buffer, long *len);
    char *readInitResponseAPDU(InitResponseAPDU **init, char *buffer);
    InitResponseAPDU *replyToInitAPDU(InitAPDU * init, boolean result, void *userInfo);

    SearchAPDU *makeSearchAPDU(long small, long large, long medium,
			       boolean replace, char *name, char **databases,
			       char *type, char **elements, any *refID, void *queryInfo);
    void freeSearchAPDU(SearchAPDU *query);
    char *writeSearchAPDU(SearchAPDU *query, char *buffer, long *len);
    char *readSearchAPDU(SearchAPDU **query, char *buffer);

    SearchResponseAPDU *makeSearchResponseAPDU(long result, long count,
					       long recordsReturned, long nextPos,
					       long resultStatus, long presentStatus,
					       any *refID, void *records);
    void freeSearchResponseAPDU(SearchResponseAPDU *queryResponse);
    char *writeSearchResponseAPDU(SearchResponseAPDU *queryResponse, char
				  *buffer, long *len);
    char *readSearchResponseAPDU(SearchResponseAPDU **queryResponse, char *buffer);

    PresentAPDU *makePresentAPDU(long recsReq, long startPos,
				 char *resultID, any *refID, void *info);
    void freePresentAPDU(PresentAPDU * present);
    char *writePresentAPDU(PresentAPDU * present, char *buffer, long *len);
    char *readPresentAPDU(PresentAPDU ** present, char *buffer);

    PresentResponseAPDU *makePresentResponseAPDU(boolean status, long recsRet,
						 long nextPos, any *refID,
						 void *records);
    void freePresentResponseAPDU(PresentResponseAPDU * present);
    char *writePresentResponseAPDU(PresentResponseAPDU * present, char
				   *buffer, long *len);
    char *readPresentResponseAPDU(PresentResponseAPDU ** present, char *buffer);

/*----------------------------------------------------------------------*/
/* user extension hooks: */

    extern char *writeInitInfo(InitAPDU * init, char *buffer, long *len);
    extern char *readInitInfo(void **info, char *buffer);

    extern char *writeInitResponseInfo(InitResponseAPDU *init, char *buffer, long *len);
    extern char *readInitResponseInfo(void **info, char *buffer);

    extern char *writeSearchInfo(SearchAPDU *query, char *buffer, long *len);
    extern char *readSearchInfo(void **info, char *buffer);

    extern char *writeSearchResponseInfo(SearchResponseAPDU *query, char
					 *buffer, long *len);
    extern char *readSearchResponseInfo(void **info, char *buffer);

    extern char *writePresentInfo(PresentAPDU * present, char *buffer, long *len);
    extern char *readPresentInfo(void **info, char *buffer);

    extern char *writePresentResponseInfo(PresentResponseAPDU * present, char
					  *buffer, long *len);
    extern char *readPresentResponseInfo(void **info, char *buffer);

#ifdef __cplusplus
}
#endif
#endif				/* HTVMSWAIS_H */
@


1.6
log
@automatic merge of lynx-current
@
text
@d15 4
a18 1
void log_write(char *);
d25 1
a25 1
void panic(char *format,...);
d38 1
a38 1
#endif /* boolean */
d42 1
a42 1
#endif /* true */
d47 1
a47 1
#endif /* false */
d51 1
a51 1
#endif /* TRUE */
d55 1
a55 1
#endif /* FALSE */
d62 5
a66 5
void fs_checkPtr(void *ptr);
void *fs_malloc(size_t size);
void *fs_realloc(void *ptr, size_t size);
void fs_free(void *ptr);
char *fs_strncat(char *dst, char *src, size_t maxToAdd, size_t maxTotal);
d75 1
a75 1
char *s_strdup(char *s);
d80 2
a81 2
char char_downcase(unsigned long ch);
char *string_downcase(char *word);
d95 1
a95 1
typedef long pdu_type;
d110 4
a113 4
typedef struct any {		/* an any is a non-ascii string of characters */
    unsigned long size;
    char *bytes;
} any;
d115 1
a115 1
typedef any bit_map;		/* a bit_map is a group of packed bits */
d117 1
a117 1
typedef unsigned long data_tag;
d206 5
a210 5
typedef struct diagnosticRecord {
    boolean SURROGATE;
    char DIAG[DIAGNOSTIC_CODE_SIZE];
    char *ADDINFO;
} diagnosticRecord;
d254 1
a254 1
extern char *readErrorPosition;	/* pos where buf stoped making sense */
d280 65
a344 65
diagnosticRecord *makeDiag(boolean surrogate, char *code, char *addInfo);
void freeDiag(diagnosticRecord * diag);
char *writeDiag(diagnosticRecord * diag, char *buffer, long *len);
char *readDiag(diagnosticRecord ** diag, char *buffer);

char *writeCompressedInteger(unsigned long num, char *buf, long *len);
char *readCompressedInteger(unsigned long *num, char *buf);
char *writeCompressedIntWithPadding(unsigned long num, unsigned long size,
				    char *buffer, long *len);
unsigned long writtenCompressedIntSize(unsigned long num);

char *writeTag(data_tag tag, char *buf, long *len);
char *readTag(data_tag *tag, char *buf);
data_tag peekTag(char *buf);
unsigned long writtenTagSize(data_tag tag);

any *makeAny(unsigned long size, char *data);
void freeAny(any *a);
any *duplicateAny(any *a);
char *writeAny(any *a, data_tag tag, char *buffer, long *len);
char *readAny(any **anAny, char *buffer);
unsigned long writtenAnySize(data_tag tag, any *a);

any *stringToAny(char *s);
char *anyToString(any *a);
unsigned long writtenStringSize(data_tag tag, char *s);

any *longToAny(long Num);
long anyToLong(any *a);

char *writeString(char *s, data_tag tag, char *buffer, long *len);
char *readString(char **s, char *buffer);

bit_map *makeBitMap(unsigned long numBits,...);

void freeBitMap(bit_map *bm);
boolean bitAtPos(unsigned long pos, bit_map *bm);
char *writeBitMap(bit_map *bm, data_tag tag, char *buffer, long *len);
char *readBitMap(bit_map **bm, char *buffer);

char *writeByte(unsigned long byte, char *buf, long *len);
char *readByte(unsigned char *byte, char *buf);

char *writeBoolean(boolean flag, char *buf, long *len);
char *readBoolean(boolean *flag, char *buf);

char *writePDUType(pdu_type pduType, char *buf, long *len);
char *readPDUType(pdu_type *pduType, char *buf);
pdu_type peekPDUType(char *buf);

char *writeBinaryInteger(long num, unsigned long size,
			 char *buf, long *len);
char *readBinaryInteger(long *num, unsigned long size, char *buf);
unsigned long writtenCompressedBinIntSize(long num);

char *writeNum(long num, data_tag tag, char *buffer, long *len);
char *readNum(long *num, char *buffer);
unsigned long writtenNumSize(data_tag tag, long num);

void doList(void **list, void (*func) (void *));

char *writeProtocolVersion(char *buf, long *len);
char *defaultImplementationID(void);
char *defaultImplementationName(void);
char *defaultImplementationVersion(void);
d368 1
a368 1
#define IGNORE	"ig"
d371 8
a378 8
#define	UV_ISBN	"ub"
#define	CORPORATE_NAME	"uc"
#define	ISSN	"us"
#define	PERSONAL_NAME	"up"
#define	SUBJECT	"uj"
#define	TITLE	"ut"
#define	GEOGRAPHIC_NAME	"ug"
#define	CODEN	"ud"
d380 1
a380 1
#define	SERIES_TITLE	"uf"
d383 2
a384 2
#define	NUC_CODE	"uk"
#define	LANGUAGE	"ul"
d387 1
a387 1
#define	DATE	"uo"
d392 1
a392 1
#define	RECORD_TYPE	"uy"
d395 2
a396 2
#define	EQUAL	"re"
#define	GREATER_THAN	"rg"
d398 1
a398 1
#define	LESS_THAN	"rl"
d400 1
a400 1
#define	NOT_EQUAL	"rn"
d403 1
a403 1
#define	FIRST_IN_FIELD	"pf"
d410 4
a413 4
#define	PHRASE	"sp"
#define	WORD	"sw"
#define	KEY	"sk"
#define	WORD_LIST	"sl"
d416 1
a416 1
#define	NO_TRUNCATION	"tn"
d423 1
a423 1
#define	COMPLETEFIELD	"cf"
d433 1
a433 1
#define	TT_Operator			3
d438 16
a453 16
typedef struct query_term {
    /* type */
    long TermType;
    /* for term */
    char Use[ATTRIBUTE_SIZE];
    char Relation[ATTRIBUTE_SIZE];
    char Position[ATTRIBUTE_SIZE];
    char Structure[ATTRIBUTE_SIZE];
    char Truncation[ATTRIBUTE_SIZE];
    char Completeness[ATTRIBUTE_SIZE];
    any *Term;
    /* for result set */
    any *ResultSetID;
    /* for operator */
    char Operator[OPERATOR_SIZE];
} query_term;
d458 9
a466 9
query_term *makeAttributeTerm(char *use, char *relation, char *position, char *structure,
			      char *truncation, char *completeness, any *term);
query_term *makeResultSetTerm(any *resultSet);
query_term *makeOperatorTerm(char *operatorCode);
void freeTerm(void *qt);
char *writeQueryTerm(query_term *qt, char *buffer, long *len);
char *readQueryTerm(query_term **qt, char *buffer);
any *writeQuery(query_term **terms);
query_term **readQuery(any *info);
d475 14
a488 14
char *generate_retrieval_apdu(char *buff,
			      long *buff_len,
			      any *docID,
			      long chunk_type,
			      long start_line, long end_line,
			      char *type,
			      char *database_name);

long interpret_message(char *request_message,
		       long request_length,
		       char *response_message,
		       long response_buffer_length,	/* length of the buffer (modified) */
		       long connection,
		       boolean verbose);
d490 1
a490 1
char *trim_junk(char *headline);
d499 73
a571 73
typedef struct InitAPDU {
    pdu_type PDUType;
    boolean willSearch, willPresent, willDelete;
    boolean supportAccessControl, supportResourceControl;
    long PreferredMessageSize;
    long MaximumRecordSize;
    char *IDAuthentication;
    char *ImplementationID;
    char *ImplementationName;
    char *ImplementationVersion;
    any *ReferenceID;
    void *UserInformationField;
} InitAPDU;

typedef struct InitResponseAPDU {
    pdu_type PDUType;
    boolean Result;
    boolean willSearch, willPresent, willDelete;
    boolean supportAccessControl, supportResourceControl;
    long PreferredMessageSize;
    long MaximumRecordSize;
    char *IDAuthentication;
    char *ImplementationID;
    char *ImplementationName;
    char *ImplementationVersion;
    any *ReferenceID;
    void *UserInformationField;
} InitResponseAPDU;

typedef struct SearchAPDU {
    pdu_type PDUType;
    long SmallSetUpperBound;
    long LargeSetLowerBound;
    long MediumSetPresentNumber;
    boolean ReplaceIndicator;
    char *ResultSetName;
    char **DatabaseNames;
    char *QueryType;
    char **ElementSetNames;
    any *ReferenceID;
    void *Query;
} SearchAPDU;

typedef struct SearchResponseAPDU {
    pdu_type PDUType;
    long SearchStatus;
    long ResultCount;
    long NumberOfRecordsReturned;
    long NextResultSetPosition;
    long ResultSetStatus;
    long PresentStatus;
    any *ReferenceID;
    void *DatabaseDiagnosticRecords;
} SearchResponseAPDU;

typedef struct PresentAPDU {
    pdu_type PDUType;
    long NumberOfRecordsRequested;
    long ResultSetStartPosition;
    char *ResultSetID;
    char *ElementSetNames;
    any *ReferenceID;
    void *PresentInfo;
} PresentAPDU;

typedef struct PresentResponseAPDU {
    pdu_type PDUType;
    boolean PresentStatus;
    long NumberOfRecordsReturned;
    long NextResultSetPosition;
    any *ReferenceID;
    void *DatabaseDiagnosticRecords;
} PresentResponseAPDU;
d576 61
a636 59
InitAPDU *makeInitAPDU(boolean search, boolean present, boolean deleteIt,
		       boolean accessControl, boolean resourceControl, long prefMsgSize,
		       long maxMsgSize,
		       char *auth,
		       char *id,
		       char *name,
		       char *version,
		       any *refID,
		       void *userInfo);
void freeInitAPDU(InitAPDU * init);
char *writeInitAPDU(InitAPDU * init, char *buffer, long *len);
char *readInitAPDU(InitAPDU ** init, char *buffer);

InitResponseAPDU *makeInitResponseAPDU(boolean result,
				       boolean search,
				       boolean present,
				       boolean deleteIt,
				       boolean accessControl,
				       boolean resourceControl,
				       long prefMsgSize,
				       long maxMsgSize,
				       char *auth,
				       char *id,
				       char *name,
				       char *version,
				       any *refID,
				       void *userInfo);
void freeInitResponseAPDU(InitResponseAPDU *init);
char *writeInitResponseAPDU(InitResponseAPDU *init, char *buffer, long *len);
char *readInitResponseAPDU(InitResponseAPDU **init, char *buffer);
InitResponseAPDU *replyToInitAPDU(InitAPDU * init, boolean result, void *userInfo);

SearchAPDU *makeSearchAPDU(long small, long large, long medium,
			   boolean replace, char *name, char **databases,
			   char *type, char **elements, any *refID, void *queryInfo);
void freeSearchAPDU(SearchAPDU *query);
char *writeSearchAPDU(SearchAPDU *query, char *buffer, long *len);
char *readSearchAPDU(SearchAPDU **query, char *buffer);

SearchResponseAPDU *makeSearchResponseAPDU(long result, long count,
					   long recordsReturned, long nextPos,
					   long resultStatus, long presentStatus,
					   any *refID, void *records);
void freeSearchResponseAPDU(SearchResponseAPDU *queryResponse);
char *writeSearchResponseAPDU(SearchResponseAPDU *queryResponse, char *buffer, long *len);
char *readSearchResponseAPDU(SearchResponseAPDU **queryResponse, char *buffer);

PresentAPDU *makePresentAPDU(long recsReq, long startPos,
			     char *resultID, any *refID, void *info);
void freePresentAPDU(PresentAPDU * present);
char *writePresentAPDU(PresentAPDU * present, char *buffer, long *len);
char *readPresentAPDU(PresentAPDU ** present, char *buffer);

PresentResponseAPDU *makePresentResponseAPDU(boolean status, long recsRet,
					     long nextPos, any *refID,
					     void *records);
void freePresentResponseAPDU(PresentResponseAPDU * present);
char *writePresentResponseAPDU(PresentResponseAPDU * present, char *buffer, long *len);
char *readPresentResponseAPDU(PresentResponseAPDU ** present, char *buffer);
d641 2
a642 2
extern char *writeInitInfo(InitAPDU * init, char *buffer, long *len);
extern char *readInitInfo(void **info, char *buffer);
d644 2
a645 2
extern char *writeInitResponseInfo(InitResponseAPDU *init, char *buffer, long *len);
extern char *readInitResponseInfo(void **info, char *buffer);
d647 2
a648 2
extern char *writeSearchInfo(SearchAPDU *query, char *buffer, long *len);
extern char *readSearchInfo(void **info, char *buffer);
d650 15
a664 11
extern char *writeSearchResponseInfo(SearchResponseAPDU *query, char *buffer, long *len);
extern char *readSearchResponseInfo(void **info, char *buffer);

extern char *writePresentInfo(PresentAPDU * present, char *buffer, long *len);
extern char *readPresentInfo(void **info, char *buffer);

extern char *writePresentResponseInfo(PresentResponseAPDU * present, char
				      *buffer, long *len);
extern char *readPresentResponseInfo(void **info, char *buffer);

#endif /* HTVMSWAIS_H */
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 5
a6 5
**
**	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
**
**	31-May-1994 FM	Initial version.
*/
d15 1
a15 1
void	log_write (char *);
d18 3
a20 3
**	Routines originally from Panic.h -- FM
**
**----------------------------------------------------------------------*/
d22 1
a22 1
void	panic (char* format,...);
a25 1

d27 3
a29 3
**	Routines originally from CUtil.h -- FM
**
**----------------------------------------------------------------------*/
d42 2
a43 2
#define false	(boolean)0L   /* used to be (!true), but broke
				 some compilers */
d59 5
a63 5
void	fs_checkPtr (void* ptr);
void*	fs_malloc (size_t size);
void*	fs_realloc (void* ptr,size_t size);
void	fs_free (void* ptr);
char*	fs_strncat (char* dst,char* src,size_t maxToAdd,size_t maxTotal);
d72 1
a72 1
char*	s_strdup (char* s);
d77 2
a78 2
char char_downcase (unsigned long ch);
char *string_downcase (char* word);
a81 2


d83 3
a85 3
**	Routines originally from ZUtil.c -- FM
**
**----------------------------------------------------------------------*/
d107 4
a110 4
typedef struct any {	/* an any is a non-ascii string of characters */
	unsigned long	size;
	char*			bytes;
	} any;
d112 1
a112 1
typedef any	bit_map;	/* a bit_map is a group of packed bits */
d165 2
a166 2
#define CompressedInt1Byte	128		/* 2 ^ 7 */
#define CompressedInt2Byte	16384		/* 2 ^ 14 */
d171 2
a172 2
#define QT_0	"0"	/* query whose non-standard format has been agreed upon
			   client and server */
d184 1
a184 1
#define	SUCCESS	0 /* intuitive huh? */
d198 2
a199 2
#define PS_NONE		5 /* can't use NONE since it was used by result
			     set status */
d203 5
a207 5
typedef struct diagnosticRecord
 { boolean	SURROGATE;
   char		DIAG[DIAGNOSTIC_CODE_SIZE];
   char*	ADDINFO;
 } diagnosticRecord;
d251 1
a251 1
extern char* readErrorPosition;		/* pos where buf stoped making sense */
d259 1
a259 1
	  return(NULL); /* jump out of caller */
d277 65
a341 65
diagnosticRecord* makeDiag (boolean surrogate,char* code,char* addInfo);
void freeDiag (diagnosticRecord* diag);
char* writeDiag (diagnosticRecord* diag,char* buffer,long* len);
char* readDiag (diagnosticRecord** diag,char* buffer);

char* writeCompressedInteger (unsigned long num,char* buf,long* len);
char* readCompressedInteger (unsigned long *num,char* buf);
char* writeCompressedIntWithPadding (unsigned long num,unsigned long size,
					 char* buffer,long* len);
unsigned long writtenCompressedIntSize (unsigned long num);

char* writeTag (data_tag tag,char* buf,long* len);
char* readTag (data_tag* tag,char* buf);
data_tag peekTag (char* buf);
unsigned long writtenTagSize (data_tag tag);

any* makeAny (unsigned long size,char* data);
void freeAny (any* a);
any* duplicateAny (any* a);
char* writeAny (any* a,data_tag tag,char* buffer,long* len);
char* readAny (any** anAny,char* buffer);
unsigned long writtenAnySize (data_tag tag,any* a);

any* stringToAny (char* s);
char* anyToString (any* a);
unsigned long writtenStringSize (data_tag tag,char* s);

any* longToAny (long Num);
long anyToLong (any* a);

char* writeString (char* s,data_tag tag,char* buffer,long* len);
char* readString (char** s,char* buffer);

bit_map* makeBitMap (unsigned long numBits,...);

void freeBitMap (bit_map* bm);
boolean bitAtPos (unsigned long pos,bit_map* bm);
char* writeBitMap (bit_map* bm,data_tag tag,char* buffer,long* len);
char* readBitMap (bit_map** bm,char* buffer);

char* writeByte (unsigned long byte,char* buf,long* len);
char* readByte (unsigned char* byte,char* buf);

char* writeBoolean (boolean flag,char* buf,long* len);
char* readBoolean (boolean* flag,char* buf);

char* writePDUType (pdu_type pduType,char* buf,long* len);
char* readPDUType (pdu_type* pduType,char* buf);
pdu_type peekPDUType (char* buf);

char* writeBinaryInteger (long num,unsigned long size,
			      char* buf,long* len);
char* readBinaryInteger (long* num,unsigned long size,char* buf);
unsigned long writtenCompressedBinIntSize (long num);

char* writeNum (long num,data_tag tag,char* buffer,long* len);
char* readNum (long* num,char* buffer);
unsigned long  writtenNumSize (data_tag tag,long num);

void doList (void** list,void (*func)(void *));

char* writeProtocolVersion (char* buf,long* len);
char* defaultImplementationID (void);
char* defaultImplementationName (void);
char* defaultImplementationVersion (void);
a344 1

d346 3
a348 3
**	Routines originally from ZType1.c -- FM
**
**----------------------------------------------------------------------*/
d362 1
a362 1
#define QT_BooleanQuery	"1"		/* standard boolean query */
d436 14
a449 14
  /* type */
  long	TermType;
  /* for term */
  char	Use[ATTRIBUTE_SIZE];
  char	Relation[ATTRIBUTE_SIZE];
  char	Position[ATTRIBUTE_SIZE];
  char	Structure[ATTRIBUTE_SIZE];
  char	Truncation[ATTRIBUTE_SIZE];
  char	Completeness[ATTRIBUTE_SIZE];
  any*	Term;
  /* for result set */
  any*	ResultSetID;
  /* for operator */
  char	Operator[OPERATOR_SIZE];
d455 9
a463 10
query_term* makeAttributeTerm (
        char* use,char* relation,char* position,char* structure,
	char* truncation,char* completeness,any* term);
query_term* makeResultSetTerm (any* resultSet);
query_term* makeOperatorTerm (char* operatorCode);
void freeTerm (void* qt);
char* writeQueryTerm (query_term* qt,char* buffer,long* len);
char* readQueryTerm (query_term** qt,char* buffer);
any* writeQuery (query_term** terms);
query_term** readQuery (any* info);
a466 1

d468 11
a478 13
**	Routines originally from UI.c -- FM
**
**----------------------------------------------------------------------*/

char *
generate_retrieval_apdu (char *buff,
			     long *buff_len,
			     any *docID,
			     long chunk_type,
			     long start_line, long end_line,
			     char *type,
			     char *database_name);

d480 1
a480 2
long
interpret_message (char *request_message,
d483 1
a483 1
		       long response_buffer_length, /* length of the buffer (modified)*/
d487 1
a487 3
char *trim_junk (char *headline);


d490 3
a492 3
**	Routines originally from ZProt.c -- FM
**
**----------------------------------------------------------------------*/
d497 12
a508 12
	pdu_type		PDUType;
	boolean			willSearch,willPresent,willDelete;
	boolean			supportAccessControl,supportResourceControl;
	long			PreferredMessageSize;
	long			MaximumRecordSize;
	char*			IDAuthentication;
	char*			ImplementationID;
	char*			ImplementationName;
	char*			ImplementationVersion;
	any*			ReferenceID;
	void*			UserInformationField;
	} InitAPDU;
d511 13
a523 13
	pdu_type		PDUType;
	boolean			Result;
	boolean			willSearch,willPresent,willDelete;
	boolean			supportAccessControl,supportResourceControl;
	long			PreferredMessageSize;
	long			MaximumRecordSize;
	char*			IDAuthentication;
	char*			ImplementationID;
	char*			ImplementationName;
	char*			ImplementationVersion;
	any*			ReferenceID;
	void*			UserInformationField;
	} InitResponseAPDU;
d526 12
a537 12
	pdu_type		PDUType;
	long			SmallSetUpperBound;
	long			LargeSetLowerBound;
	long			MediumSetPresentNumber;
	boolean			ReplaceIndicator;
	char*			ResultSetName;
	char**			DatabaseNames;
	char*			QueryType;
	char**			ElementSetNames;
	any*			ReferenceID;
	void*			Query;
	} SearchAPDU;
d540 10
a549 10
	pdu_type		PDUType;
	long			SearchStatus;
	long			ResultCount;
	long			NumberOfRecordsReturned;
	long			NextResultSetPosition;
	long			ResultSetStatus;
	long			PresentStatus;
	any*			ReferenceID;
	void*			DatabaseDiagnosticRecords;
	} SearchResponseAPDU;
d552 8
a559 8
	pdu_type		PDUType;
	long			NumberOfRecordsRequested;
	long			ResultSetStartPosition;
	char*			ResultSetID;
	char*			ElementSetNames;
	any*			ReferenceID;
	void*			PresentInfo;
	} PresentAPDU;
d562 7
a568 7
	pdu_type		PDUType;
	boolean			PresentStatus;
	long			NumberOfRecordsReturned;
	long			NextResultSetPosition;
	any*			ReferenceID;
	void*			DatabaseDiagnosticRecords;
	} PresentResponseAPDU;
d573 59
a631 47
InitAPDU* makeInitAPDU (boolean search,boolean present,boolean deleteIt,
			    boolean accessControl,boolean resourceControl,
			    long prefMsgSize,long maxMsgSize,
			    char* auth,char* id,char* name, char* version,
			    any* refID,void* userInfo);
void freeInitAPDU (InitAPDU* init);
char* writeInitAPDU (InitAPDU* init,char* buffer,long* len);
char* readInitAPDU (InitAPDU** init,char* buffer);

InitResponseAPDU* makeInitResponseAPDU (boolean result,
					    boolean search,boolean present,boolean deleteIt,
					    boolean accessControl,boolean resourceControl,
					    long prefMsgSize,long maxMsgSize,
					    char* auth,char* id,char* name, char* version,
					    any* refID,void* userInfo);
void freeInitResponseAPDU (InitResponseAPDU* init);
char* writeInitResponseAPDU (InitResponseAPDU* init,char* buffer,long* len);
char* readInitResponseAPDU (InitResponseAPDU** init,char* buffer);
InitResponseAPDU* replyToInitAPDU (InitAPDU* init,boolean result,void* userInfo);

SearchAPDU* makeSearchAPDU (long small,long large, long medium,
				boolean replace,char* name,char** databases,
				char* type,char** elements,any* refID,void* queryInfo);
void freeSearchAPDU (SearchAPDU* query);
char* writeSearchAPDU (SearchAPDU* query,char* buffer,long* len);
char* readSearchAPDU (SearchAPDU** query,char* buffer);

SearchResponseAPDU* makeSearchResponseAPDU (long result,long count,
						long recordsReturned,long nextPos,
						long resultStatus,long presentStatus,
						any* refID,void* records);
void freeSearchResponseAPDU (SearchResponseAPDU* queryResponse);
char* writeSearchResponseAPDU (SearchResponseAPDU* queryResponse,char* buffer,long* len);
char* readSearchResponseAPDU (SearchResponseAPDU** queryResponse,char* buffer);

PresentAPDU* makePresentAPDU (long recsReq, long startPos,
				  char* resultID,any* refID,void* info);
void freePresentAPDU (PresentAPDU* present);
char* writePresentAPDU (PresentAPDU* present,char* buffer,long* len);
char* readPresentAPDU (PresentAPDU** present,char* buffer);

PresentResponseAPDU* makePresentResponseAPDU (boolean status,long recsRet,
						  long nextPos,any* refID,
						  void* records);
void freePresentResponseAPDU (PresentResponseAPDU* present);
char* writePresentResponseAPDU (PresentResponseAPDU* present,char* buffer,long* len);
char* readPresentResponseAPDU (PresentResponseAPDU** present,char* buffer);
d636 2
a637 5
extern char* writeInitInfo (InitAPDU* init,char* buffer,long* len);
extern char* readInitInfo (void** info,char* buffer);

extern char* writeInitResponseInfo (InitResponseAPDU* init,char* buffer,long* len);
extern char* readInitResponseInfo (void** info,char* buffer);
d639 2
a640 2
extern char* writeSearchInfo (SearchAPDU* query,char* buffer,long* len);
extern char* readSearchInfo (void** info,char* buffer);
d642 2
a643 2
extern char* writeSearchResponseInfo (SearchResponseAPDU* query,char* buffer,long* len);
extern char* readSearchResponseInfo (void** info,char* buffer);
d645 2
a646 2
extern char* writePresentInfo (PresentAPDU* present,char* buffer,long* len);
extern char* readPresentInfo (void** info,char* buffer);
d648 2
a649 2
extern char* writePresentResponseInfo (PresentResponseAPDU* present,char* buffer,long* len);
extern char* readPresentResponseInfo (void** info,char* buffer);
d651 3
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d15 1
a15 1
void	log_write PARAMS((char *));
d60 5
a64 5
void	fs_checkPtr PARAMS((void* ptr));
void*	fs_malloc PARAMS((size_t size));
void*	fs_realloc PARAMS((void* ptr,size_t size));
void	fs_free PARAMS((void* ptr));
char*	fs_strncat PARAMS((char* dst,char* src,size_t maxToAdd,size_t maxTotal));
d73 1
a73 1
char*	s_strdup PARAMS((char* s));
d78 2
a79 2
char char_downcase PARAMS((unsigned long ch));
char *string_downcase PARAMS((char* word));
d280 26
a305 26
diagnosticRecord* makeDiag PARAMS((boolean surrogate,char* code,char* addInfo));
void freeDiag PARAMS((diagnosticRecord* diag));
char* writeDiag PARAMS((diagnosticRecord* diag,char* buffer,long* len));
char* readDiag PARAMS((diagnosticRecord** diag,char* buffer));

char* writeCompressedInteger PARAMS((unsigned long num,char* buf,long* len));
char* readCompressedInteger PARAMS((unsigned long *num,char* buf));
char* writeCompressedIntWithPadding PARAMS((unsigned long num,unsigned long size,
					 char* buffer,long* len));
unsigned long writtenCompressedIntSize PARAMS((unsigned long num));

char* writeTag PARAMS((data_tag tag,char* buf,long* len));
char* readTag PARAMS((data_tag* tag,char* buf));
data_tag peekTag PARAMS((char* buf));
unsigned long writtenTagSize PARAMS((data_tag tag));

any* makeAny PARAMS((unsigned long size,char* data));
void freeAny PARAMS((any* a));
any* duplicateAny PARAMS((any* a));
char* writeAny PARAMS((any* a,data_tag tag,char* buffer,long* len));
char* readAny PARAMS((any** anAny,char* buffer));
unsigned long writtenAnySize PARAMS((data_tag tag,any* a));

any* stringToAny PARAMS((char* s));
char* anyToString PARAMS((any* a));
unsigned long writtenStringSize PARAMS((data_tag tag,char* s));
d307 2
a308 2
any* longToAny PARAMS((long Num));
long anyToLong PARAMS((any* a));
d310 2
a311 2
char* writeString PARAMS((char* s,data_tag tag,char* buffer,long* len));
char* readString PARAMS((char** s,char* buffer));
d315 30
a344 30
void freeBitMap PARAMS((bit_map* bm));
boolean bitAtPos PARAMS((unsigned long pos,bit_map* bm));
char* writeBitMap PARAMS((bit_map* bm,data_tag tag,char* buffer,long* len));
char* readBitMap PARAMS((bit_map** bm,char* buffer));

char* writeByte PARAMS((unsigned long byte,char* buf,long* len));
char* readByte PARAMS((unsigned char* byte,char* buf));

char* writeBoolean PARAMS((boolean flag,char* buf,long* len));
char* readBoolean PARAMS((boolean* flag,char* buf));

char* writePDUType PARAMS((pdu_type pduType,char* buf,long* len));
char* readPDUType PARAMS((pdu_type* pduType,char* buf));
pdu_type peekPDUType PARAMS((char* buf));

char* writeBinaryInteger PARAMS((long num,unsigned long size,
			      char* buf,long* len));
char* readBinaryInteger PARAMS((long* num,unsigned long size,char* buf));
unsigned long writtenCompressedBinIntSize PARAMS((long num));

char* writeNum PARAMS((long num,data_tag tag,char* buffer,long* len));
char* readNum PARAMS((long* num,char* buffer));
unsigned long  writtenNumSize PARAMS((data_tag tag,long num));

void doList PARAMS((void** list,void (*func)(void *)));

char* writeProtocolVersion PARAMS((char* buf,long* len));
char* defaultImplementationID PARAMS((void));
char* defaultImplementationName PARAMS((void));
char* defaultImplementationVersion PARAMS((void));
d459 1
a459 1
query_term* makeAttributeTerm PARAMS((
d461 8
a468 8
	char* truncation,char* completeness,any* term));
query_term* makeResultSetTerm PARAMS((any* resultSet));
query_term* makeOperatorTerm PARAMS((char* operatorCode));
void freeTerm PARAMS((void* qt));
char* writeQueryTerm PARAMS((query_term* qt,char* buffer,long* len));
char* readQueryTerm PARAMS((query_term** qt,char* buffer));
any* writeQuery PARAMS((query_term** terms));
query_term** readQuery PARAMS((any* info));
d479 1
a479 1
generate_retrieval_apdu PARAMS((char *buff,
d485 1
a485 1
			     char *database_name));
d489 1
a489 1
interpret_message PARAMS((char *request_message,
d494 1
a494 1
		       boolean verbose));
d496 1
a496 1
char *trim_junk PARAMS((char *headline));
d584 1
a584 1
InitAPDU* makeInitAPDU PARAMS((boolean search,boolean present,boolean deleteIt,
d588 4
a591 4
			    any* refID,void* userInfo));
void freeInitAPDU PARAMS((InitAPDU* init));
char* writeInitAPDU PARAMS((InitAPDU* init,char* buffer,long* len));
char* readInitAPDU PARAMS((InitAPDU** init,char* buffer));
d593 1
a593 1
InitResponseAPDU* makeInitResponseAPDU PARAMS((boolean result,
d598 5
a602 5
					    any* refID,void* userInfo));
void freeInitResponseAPDU PARAMS((InitResponseAPDU* init));
char* writeInitResponseAPDU PARAMS((InitResponseAPDU* init,char* buffer,long* len));
char* readInitResponseAPDU PARAMS((InitResponseAPDU** init,char* buffer));
InitResponseAPDU* replyToInitAPDU PARAMS((InitAPDU* init,boolean result,void* userInfo));
d604 1
a604 1
SearchAPDU* makeSearchAPDU PARAMS((long small,long large, long medium,
d606 4
a609 4
				char* type,char** elements,any* refID,void* queryInfo));
void freeSearchAPDU PARAMS((SearchAPDU* query));
char* writeSearchAPDU PARAMS((SearchAPDU* query,char* buffer,long* len));
char* readSearchAPDU PARAMS((SearchAPDU** query,char* buffer));
d611 1
a611 1
SearchResponseAPDU* makeSearchResponseAPDU PARAMS((long result,long count,
d614 10
a623 10
						any* refID,void* records));
void freeSearchResponseAPDU PARAMS((SearchResponseAPDU* queryResponse));
char* writeSearchResponseAPDU PARAMS((SearchResponseAPDU* queryResponse,char* buffer,long* len));
char* readSearchResponseAPDU PARAMS((SearchResponseAPDU** queryResponse,char* buffer));

PresentAPDU* makePresentAPDU PARAMS((long recsReq, long startPos,
				  char* resultID,any* refID,void* info));
void freePresentAPDU PARAMS((PresentAPDU* present));
char* writePresentAPDU PARAMS((PresentAPDU* present,char* buffer,long* len));
char* readPresentAPDU PARAMS((PresentAPDU** present,char* buffer));
d625 1
a625 1
PresentResponseAPDU* makePresentResponseAPDU PARAMS((boolean status,long recsRet,
d627 4
a630 4
						  void* records));
void freePresentResponseAPDU PARAMS((PresentResponseAPDU* present));
char* writePresentResponseAPDU PARAMS((PresentResponseAPDU* present,char* buffer,long* len));
char* readPresentResponseAPDU PARAMS((PresentResponseAPDU** present,char* buffer));
d635 2
a636 2
extern char* writeInitInfo PARAMS((InitAPDU* init,char* buffer,long* len));
extern char* readInitInfo PARAMS((void** info,char* buffer));
d638 2
a639 2
extern char* writeInitResponseInfo PARAMS((InitResponseAPDU* init,char* buffer,long* len));
extern char* readInitResponseInfo PARAMS((void** info,char* buffer));
d641 2
a642 2
extern char* writeSearchInfo PARAMS((SearchAPDU* query,char* buffer,long* len));
extern char* readSearchInfo PARAMS((void** info,char* buffer));
d644 2
a645 2
extern char* writeSearchResponseInfo PARAMS((SearchResponseAPDU* query,char* buffer,long* len));
extern char* readSearchResponseInfo PARAMS((void** info,char* buffer));
d647 2
a648 2
extern char* writePresentInfo PARAMS((PresentAPDU* present,char* buffer,long* len));
extern char* readPresentInfo PARAMS((void** info,char* buffer));
d650 2
a651 2
extern char* writePresentResponseInfo PARAMS((PresentResponseAPDU* present,char* buffer,long* len));
extern char* readPresentResponseInfo PARAMS((void** info,char* buffer));
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d22 1
a22 1
void	panic (char* format,...); 
d39 1
a39 1
#define true 	(boolean)1L
d43 1
a43 1
#define false 	(boolean)0L   /* used to be (!true), but broke 
d64 1
a64 1
char* 	fs_strncat PARAMS((char* dst,char* src,size_t maxToAdd,size_t maxTotal));
d67 2
a68 2
#define s_checkPtr(ptr) 	fs_checkPtr(ptr)
#define s_malloc(size)	      	fs_malloc(size)
d73 1
a73 1
char* 	s_strdup PARAMS((char* s));
d93 1
a93 1
#define HEADER_LEN	(size_t)2 
d111 1
a111 1
	unsigned long	size; 
d114 2
a115 2
	
typedef any	bit_map; 	/* a bit_map is a group of packed bits */
d119 1
a119 1
#define DT_PDUType			(data_tag)1 	
d137 1
a137 1
#define	DT_ElementSetNames 		(data_tag)19
d165 1
a165 1
/* number of bytes required to represent the following sizes in compressed 
d168 3
a170 3
#define CompressedInt1Byte	128 		/* 2 ^ 7 */
#define CompressedInt2Byte	16384 		/* 2 ^ 14 */
#define CompressedInt3Byte	2097152 	/* 2 ^ 21 */
d201 1
a201 1
#define PS_NONE		5 /* can't use NONE since it was used by result 
d206 1
a206 1
typedef struct diagnosticRecord 
d209 1
a209 1
   char* 	ADDINFO;
d213 4
a216 4
#define D_TemporarySystemError	       "S2"
#define D_UnsupportedSearch	       "S3"
#define D_TermsOnlyStopWords	       "S5"
#define D_TooManyArgumentWords	       "S6"
d218 1
a218 1
#define D_TooManyTruncatedWords	       "S8"
d254 1
a254 1
extern char* readErrorPosition; 	/* pos where buf stoped making sense */
d259 3
a261 3
 
#define RETURN_ON_NULL(var) 					\
	if (var == NULL) 				     	\
d264 1
a264 1
#define REPORT_READ_ERROR(pos) 					\
d273 2
a274 2
	   { *spaceLeft = 0; 					\
	     return(NULL); /* jump out of the caller */ 	\
d479 2
a480 2
generate_retrieval_apdu PARAMS((char *buff, 
			     long *buff_len, 
d515 1
a515 1
	char* 			ImplementationName;
d527 1
a527 1
	long 			MaximumRecordSize;
d530 1
a530 1
	char* 			ImplementationName;
d538 1
a538 1
	long	 		SmallSetUpperBound;
d540 2
a541 2
	long	 		MediumSetPresentNumber;
	boolean 		ReplaceIndicator;
d543 1
a543 1
	char**			DatabaseNames;   
d545 1
a545 1
	char**			ElementSetNames;  
d555 1
a555 1
	long		 	NextResultSetPosition;
d557 1
a557 1
	long 			PresentStatus;
d566 1
a566 1
	char*		 	ResultSetID;
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a185 4
/* values for SearchAPDU replace indicator element */
#define ON	TRUE
#define OFF	FALSE

@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 5
a6 5
 *
 *	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
 *
 *	31-May-1994 FM	Initial version.
 */
d15 1
a15 4
#ifdef __cplusplus
extern "C" {
#endif
    void log_write(char *);
d18 3
a20 3
 *	Routines originally from Panic.h -- FM
 *
 *----------------------------------------------------------------------*/
d22 1
a22 1
    void panic(char *format,...);
d26 1
d28 3
a30 3
 *	Routines originally from CUtil.h -- FM
 *
 *----------------------------------------------------------------------*/
d36 1
a36 1
#endif				/* boolean */
d39 2
a40 2
#define true	(boolean)1L
#endif				/* true */
d43 3
a45 3
#define false	(boolean)0L	/* used to be (!true), but broke
				   some compilers */
#endif				/* false */
d49 1
a49 1
#endif				/* TRUE */
d53 1
a53 1
#endif				/* FALSE */
d60 5
a64 5
    void fs_checkPtr(void *ptr);
    void *fs_malloc(size_t size);
    void *fs_realloc(void *ptr, size_t size);
    void fs_free(void *ptr);
    char *fs_strncat(char *dst, char *src, size_t maxToAdd, size_t maxTotal);
d67 2
a68 2
#define s_checkPtr(ptr)		fs_checkPtr(ptr)
#define s_malloc(size)		fs_malloc(size)
d73 1
a73 1
    char *s_strdup(char *s);
d78 2
a79 2
    char char_downcase(unsigned long ch);
    char *string_downcase(char *word);
d83 2
d86 3
a88 3
 *	Routines originally from ZUtil.c -- FM
 *
 *----------------------------------------------------------------------*/
d93 1
a93 1
#define HEADER_LEN	(size_t)2
d95 1
a95 1
    typedef long pdu_type;
d110 6
a115 6
    typedef struct any {	/* an any is a non-ascii string of characters */
	unsigned long size;
	char *bytes;
    } any;

    typedef any bit_map;	/* a bit_map is a group of packed bits */
d117 1
a117 1
    typedef unsigned long data_tag;
d119 1
a119 1
#define DT_PDUType			(data_tag)1
d137 1
a137 1
#define DT_ElementSetNames		(data_tag)19
d165 1
a165 1
/* number of bytes required to represent the following sizes in compressed
d168 3
a170 3
#define CompressedInt1Byte	128	/* 2 ^ 7 */
#define CompressedInt2Byte	16384	/* 2 ^ 14 */
#define CompressedInt3Byte	2097152		/* 2 ^ 21 */
d174 2
a175 2
#define QT_0	"0"		/* query whose non-standard format has been agreed upon
				   client and server */
d186 4
d191 1
a191 1
#define	SUCCESS	0		/* intuitive huh? */
d205 2
a206 2
#define PS_NONE		5	/* can't use NONE since it was used by result
				   set status */
d210 5
a214 5
    typedef struct diagnosticRecord {
	boolean SURROGATE;
	char DIAG[DIAGNOSTIC_CODE_SIZE];
	char *ADDINFO;
    } diagnosticRecord;
d217 4
a220 4
#define D_TemporarySystemError         "S2"
#define D_UnsupportedSearch            "S3"
#define D_TermsOnlyStopWords           "S5"
#define D_TooManyArgumentWords         "S6"
d222 1
a222 1
#define D_TooManyTruncatedWords        "S8"
d258 1
a258 1
    extern char *readErrorPosition;	/* pos where buf stoped making sense */
d263 4
d268 1
a268 5
#define RETURN_ON_NULL(var)					\
	if (var == NULL)					\
	  return(NULL);		/* jump out of caller */

#define REPORT_READ_ERROR(pos)					\
d277 2
a278 2
	   { *spaceLeft = 0;					\
	     return(NULL); /* jump out of the caller */		\
d284 65
a348 65
    diagnosticRecord *makeDiag(boolean surrogate, char *code, char *addInfo);
    void freeDiag(diagnosticRecord * diag);
    char *writeDiag(diagnosticRecord * diag, char *buffer, long *len);
    char *readDiag(diagnosticRecord ** diag, char *buffer);

    char *writeCompressedInteger(unsigned long num, char *buf, long *len);
    char *readCompressedInteger(unsigned long *num, char *buf);
    char *writeCompressedIntWithPadding(unsigned long num, unsigned long size,
					char *buffer, long *len);
    unsigned long writtenCompressedIntSize(unsigned long num);

    char *writeTag(data_tag tag, char *buf, long *len);
    char *readTag(data_tag *tag, char *buf);
    data_tag peekTag(char *buf);
    unsigned long writtenTagSize(data_tag tag);

    any *makeAny(unsigned long size, char *data);
    void freeAny(any *a);
    any *duplicateAny(any *a);
    char *writeAny(any *a, data_tag tag, char *buffer, long *len);
    char *readAny(any **anAny, char *buffer);
    unsigned long writtenAnySize(data_tag tag, any *a);

    any *stringToAny(char *s);
    char *anyToString(any *a);
    unsigned long writtenStringSize(data_tag tag, char *s);

    any *longToAny(long Num);
    long anyToLong(any *a);

    char *writeString(char *s, data_tag tag, char *buffer, long *len);
    char *readString(char **s, char *buffer);

    bit_map *makeBitMap(unsigned long numBits,...);

    void freeBitMap(bit_map *bm);
    boolean bitAtPos(unsigned long pos, bit_map *bm);
    char *writeBitMap(bit_map *bm, data_tag tag, char *buffer, long *len);
    char *readBitMap(bit_map **bm, char *buffer);

    char *writeByte(unsigned long byte, char *buf, long *len);
    char *readByte(unsigned char *byte, char *buf);

    char *writeBoolean(boolean flag, char *buf, long *len);
    char *readBoolean(boolean *flag, char *buf);

    char *writePDUType(pdu_type pduType, char *buf, long *len);
    char *readPDUType(pdu_type *pduType, char *buf);
    pdu_type peekPDUType(char *buf);

    char *writeBinaryInteger(long num, unsigned long size,
			     char *buf, long *len);
    char *readBinaryInteger(long *num, unsigned long size, char *buf);
    unsigned long writtenCompressedBinIntSize(long num);

    char *writeNum(long num, data_tag tag, char *buffer, long *len);
    char *readNum(long *num, char *buffer);
    unsigned long writtenNumSize(data_tag tag, long num);

    void doList(void **list, void (*func) (void *));

    char *writeProtocolVersion(char *buf, long *len);
    char *defaultImplementationID(void);
    char *defaultImplementationName(void);
    char *defaultImplementationVersion(void);
d352 1
d354 3
a356 3
 *	Routines originally from ZType1.c -- FM
 *
 *----------------------------------------------------------------------*/
d370 1
a370 1
#define QT_BooleanQuery	"1"	/* standard boolean query */
d373 1
a373 1
#define IGNORE			"ig"
d376 8
a383 8
#define	UV_ISBN			"ub"
#define	CORPORATE_NAME		"uc"
#define	ISSN			"us"
#define	PERSONAL_NAME		"up"
#define	SUBJECT			"uj"
#define	TITLE			"ut"
#define	GEOGRAPHIC_NAME		"ug"
#define	CODEN			"ud"
d385 1
a385 1
#define	SERIES_TITLE		"uf"
d388 2
a389 2
#define	NUC_CODE		"uk"
#define	LANGUAGE		"ul"
d392 1
a392 1
#define	DATE			"uo"
d397 1
a397 1
#define	RECORD_TYPE		"uy"
d400 2
a401 2
#define	EQUAL			"re"
#define	GREATER_THAN		"rg"
d403 1
a403 1
#define	LESS_THAN		"rl"
d405 1
a405 1
#define	NOT_EQUAL		"rn"
d408 1
a408 1
#define	FIRST_IN_FIELD		"pf"
d415 4
a418 4
#define	PHRASE			"sp"
#define	WORD			"sw"
#define	KEY			"sk"
#define	WORD_LIST		"sl"
d421 1
a421 1
#define	NO_TRUNCATION		"tn"
d428 1
a428 1
#define	COMPLETEFIELD		"cf"
d438 1
a438 1
#define	TT_Operator		3
d443 16
a458 16
    typedef struct query_term {
	/* type */
	long TermType;
	/* for term */
	char Use[ATTRIBUTE_SIZE];
	char Relation[ATTRIBUTE_SIZE];
	char Position[ATTRIBUTE_SIZE];
	char Structure[ATTRIBUTE_SIZE];
	char Truncation[ATTRIBUTE_SIZE];
	char Completeness[ATTRIBUTE_SIZE];
	any *Term;
	/* for result set */
	any *ResultSetID;
	/* for operator */
	char Operator[OPERATOR_SIZE];
    } query_term;
d463 10
a472 9
    query_term *makeAttributeTerm(char *use, char *relation, char *position, char *structure,
				  char *truncation, char *completeness, any *term);
    query_term *makeResultSetTerm(any *resultSet);
    query_term *makeOperatorTerm(char *operatorCode);
    void freeTerm(void *qt);
    char *writeQueryTerm(query_term *qt, char *buffer, long *len);
    char *readQueryTerm(query_term **qt, char *buffer);
    any *writeQuery(query_term **terms);
    query_term **readQuery(any *info);
d476 1
d478 24
a501 18
 *	Routines originally from UI.c -- FM
 *
 *----------------------------------------------------------------------*/

    char *generate_retrieval_apdu(char *buff,
				  long *buff_len,
				  any *docID,
				  long chunk_type,
				  long start_line, long end_line,
				  char *type,
				  char *database_name);

    long interpret_message(char *request_message,
			   long request_length,
			   char *response_message,
			   long response_buffer_length,		/* length of the buffer (modified) */
			   long connection,
			   boolean verbose);
a502 1
    char *trim_junk(char *headline);
d505 3
a507 3
 *	Routines originally from ZProt.c -- FM
 *
 *----------------------------------------------------------------------*/
d511 73
a583 73
    typedef struct InitAPDU {
	pdu_type PDUType;
	boolean willSearch, willPresent, willDelete;
	boolean supportAccessControl, supportResourceControl;
	long PreferredMessageSize;
	long MaximumRecordSize;
	char *IDAuthentication;
	char *ImplementationID;
	char *ImplementationName;
	char *ImplementationVersion;
	any *ReferenceID;
	void *UserInformationField;
    } InitAPDU;

    typedef struct InitResponseAPDU {
	pdu_type PDUType;
	boolean Result;
	boolean willSearch, willPresent, willDelete;
	boolean supportAccessControl, supportResourceControl;
	long PreferredMessageSize;
	long MaximumRecordSize;
	char *IDAuthentication;
	char *ImplementationID;
	char *ImplementationName;
	char *ImplementationVersion;
	any *ReferenceID;
	void *UserInformationField;
    } InitResponseAPDU;

    typedef struct SearchAPDU {
	pdu_type PDUType;
	long SmallSetUpperBound;
	long LargeSetLowerBound;
	long MediumSetPresentNumber;
	boolean ReplaceIndicator;
	char *ResultSetName;
	char **DatabaseNames;
	char *QueryType;
	char **ElementSetNames;
	any *ReferenceID;
	void *Query;
    } SearchAPDU;

    typedef struct SearchResponseAPDU {
	pdu_type PDUType;
	long SearchStatus;
	long ResultCount;
	long NumberOfRecordsReturned;
	long NextResultSetPosition;
	long ResultSetStatus;
	long PresentStatus;
	any *ReferenceID;
	void *DatabaseDiagnosticRecords;
    } SearchResponseAPDU;

    typedef struct PresentAPDU {
	pdu_type PDUType;
	long NumberOfRecordsRequested;
	long ResultSetStartPosition;
	char *ResultSetID;
	char *ElementSetNames;
	any *ReferenceID;
	void *PresentInfo;
    } PresentAPDU;

    typedef struct PresentResponseAPDU {
	pdu_type PDUType;
	boolean PresentStatus;
	long NumberOfRecordsReturned;
	long NextResultSetPosition;
	any *ReferenceID;
	void *DatabaseDiagnosticRecords;
    } PresentResponseAPDU;
d588 47
a634 61
    InitAPDU *makeInitAPDU(boolean search, boolean present, boolean deleteIt,
			   boolean accessControl, boolean resourceControl, long prefMsgSize,
			   long maxMsgSize,
			   char *auth,
			   char *id,
			   char *name,
			   char *version,
			   any *refID,
			   void *userInfo);
    void freeInitAPDU(InitAPDU * init);
    char *writeInitAPDU(InitAPDU * init, char *buffer, long *len);
    char *readInitAPDU(InitAPDU ** init, char *buffer);

    InitResponseAPDU *makeInitResponseAPDU(boolean result,
					   boolean search,
					   boolean present,
					   boolean deleteIt,
					   boolean accessControl,
					   boolean resourceControl,
					   long prefMsgSize,
					   long maxMsgSize,
					   char *auth,
					   char *id,
					   char *name,
					   char *version,
					   any *refID,
					   void *userInfo);
    void freeInitResponseAPDU(InitResponseAPDU *init);
    char *writeInitResponseAPDU(InitResponseAPDU *init, char *buffer, long *len);
    char *readInitResponseAPDU(InitResponseAPDU **init, char *buffer);
    InitResponseAPDU *replyToInitAPDU(InitAPDU * init, boolean result, void *userInfo);

    SearchAPDU *makeSearchAPDU(long small, long large, long medium,
			       boolean replace, char *name, char **databases,
			       char *type, char **elements, any *refID, void *queryInfo);
    void freeSearchAPDU(SearchAPDU *query);
    char *writeSearchAPDU(SearchAPDU *query, char *buffer, long *len);
    char *readSearchAPDU(SearchAPDU **query, char *buffer);

    SearchResponseAPDU *makeSearchResponseAPDU(long result, long count,
					       long recordsReturned, long nextPos,
					       long resultStatus, long presentStatus,
					       any *refID, void *records);
    void freeSearchResponseAPDU(SearchResponseAPDU *queryResponse);
    char *writeSearchResponseAPDU(SearchResponseAPDU *queryResponse, char
				  *buffer, long *len);
    char *readSearchResponseAPDU(SearchResponseAPDU **queryResponse, char *buffer);

    PresentAPDU *makePresentAPDU(long recsReq, long startPos,
				 char *resultID, any *refID, void *info);
    void freePresentAPDU(PresentAPDU * present);
    char *writePresentAPDU(PresentAPDU * present, char *buffer, long *len);
    char *readPresentAPDU(PresentAPDU ** present, char *buffer);

    PresentResponseAPDU *makePresentResponseAPDU(boolean status, long recsRet,
						 long nextPos, any *refID,
						 void *records);
    void freePresentResponseAPDU(PresentResponseAPDU * present);
    char *writePresentResponseAPDU(PresentResponseAPDU * present, char
				   *buffer, long *len);
    char *readPresentResponseAPDU(PresentResponseAPDU ** present, char *buffer);
d639 5
a643 2
    extern char *writeInitInfo(InitAPDU * init, char *buffer, long *len);
    extern char *readInitInfo(void **info, char *buffer);
d645 2
a646 2
    extern char *writeInitResponseInfo(InitResponseAPDU *init, char *buffer, long *len);
    extern char *readInitResponseInfo(void **info, char *buffer);
d648 2
a649 2
    extern char *writeSearchInfo(SearchAPDU *query, char *buffer, long *len);
    extern char *readSearchInfo(void **info, char *buffer);
d651 2
a652 3
    extern char *writeSearchResponseInfo(SearchResponseAPDU *query, char
					 *buffer, long *len);
    extern char *readSearchResponseInfo(void **info, char *buffer);
d654 2
a655 2
    extern char *writePresentInfo(PresentAPDU * present, char *buffer, long *len);
    extern char *readPresentInfo(void **info, char *buffer);
a656 3
    extern char *writePresentResponseInfo(PresentResponseAPDU * present, char
					  *buffer, long *len);
    extern char *readPresentResponseInfo(void **info, char *buffer);
d658 1
a658 4
#ifdef __cplusplus
}
#endif
#endif				/* HTVMSWAIS_H */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d186 4
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d22 1
a22 1
void	panic (char* format,...);
d39 1
a39 1
#define true	(boolean)1L
d43 1
a43 1
#define false	(boolean)0L   /* used to be (!true), but broke
d64 1
a64 1
char*	fs_strncat PARAMS((char* dst,char* src,size_t maxToAdd,size_t maxTotal));
d67 2
a68 2
#define s_checkPtr(ptr)		fs_checkPtr(ptr)
#define s_malloc(size)		fs_malloc(size)
d73 1
a73 1
char*	s_strdup PARAMS((char* s));
d93 1
a93 1
#define HEADER_LEN	(size_t)2
d111 1
a111 1
	unsigned long	size;
d114 2
a115 2

typedef any	bit_map;	/* a bit_map is a group of packed bits */
d119 1
a119 1
#define DT_PDUType			(data_tag)1
d137 1
a137 1
#define DT_ElementSetNames		(data_tag)19
d165 1
a165 1
/* number of bytes required to represent the following sizes in compressed
d168 3
a170 3
#define CompressedInt1Byte	128		/* 2 ^ 7 */
#define CompressedInt2Byte	16384		/* 2 ^ 14 */
#define CompressedInt3Byte	2097152		/* 2 ^ 21 */
d201 1
a201 1
#define PS_NONE		5 /* can't use NONE since it was used by result
d206 1
a206 1
typedef struct diagnosticRecord
d209 1
a209 1
   char*	ADDINFO;
d213 4
a216 4
#define D_TemporarySystemError         "S2"
#define D_UnsupportedSearch            "S3"
#define D_TermsOnlyStopWords           "S5"
#define D_TooManyArgumentWords         "S6"
d218 1
a218 1
#define D_TooManyTruncatedWords        "S8"
d254 1
a254 1
extern char* readErrorPosition;		/* pos where buf stoped making sense */
d259 3
a261 3

#define RETURN_ON_NULL(var)					\
	if (var == NULL)					\
d264 1
a264 1
#define REPORT_READ_ERROR(pos)					\
d273 2
a274 2
	   { *spaceLeft = 0;					\
	     return(NULL); /* jump out of the caller */		\
d479 2
a480 2
generate_retrieval_apdu PARAMS((char *buff,
			     long *buff_len,
d515 1
a515 1
	char*			ImplementationName;
d527 1
a527 1
	long			MaximumRecordSize;
d530 1
a530 1
	char*			ImplementationName;
d538 1
a538 1
	long			SmallSetUpperBound;
d540 2
a541 2
	long			MediumSetPresentNumber;
	boolean			ReplaceIndicator;
d543 1
a543 1
	char**			DatabaseNames;
d545 1
a545 1
	char**			ElementSetNames;
d555 1
a555 1
	long			NextResultSetPosition;
d557 1
a557 1
	long			PresentStatus;
d566 1
a566 1
	char*			ResultSetID;
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d15 1
a15 1
void	log_write (char *);
d60 5
a64 5
void	fs_checkPtr (void* ptr);
void*	fs_malloc (size_t size);
void*	fs_realloc (void* ptr,size_t size);
void	fs_free (void* ptr);
char*	fs_strncat (char* dst,char* src,size_t maxToAdd,size_t maxTotal);
d73 1
a73 1
char*	s_strdup (char* s);
d78 2
a79 2
char char_downcase (unsigned long ch);
char *string_downcase (char* word);
d280 26
a305 26
diagnosticRecord* makeDiag (boolean surrogate,char* code,char* addInfo);
void freeDiag (diagnosticRecord* diag);
char* writeDiag (diagnosticRecord* diag,char* buffer,long* len);
char* readDiag (diagnosticRecord** diag,char* buffer);

char* writeCompressedInteger (unsigned long num,char* buf,long* len);
char* readCompressedInteger (unsigned long *num,char* buf);
char* writeCompressedIntWithPadding (unsigned long num,unsigned long size,
					 char* buffer,long* len);
unsigned long writtenCompressedIntSize (unsigned long num);

char* writeTag (data_tag tag,char* buf,long* len);
char* readTag (data_tag* tag,char* buf);
data_tag peekTag (char* buf);
unsigned long writtenTagSize (data_tag tag);

any* makeAny (unsigned long size,char* data);
void freeAny (any* a);
any* duplicateAny (any* a);
char* writeAny (any* a,data_tag tag,char* buffer,long* len);
char* readAny (any** anAny,char* buffer);
unsigned long writtenAnySize (data_tag tag,any* a);

any* stringToAny (char* s);
char* anyToString (any* a);
unsigned long writtenStringSize (data_tag tag,char* s);
d307 2
a308 2
any* longToAny (long Num);
long anyToLong (any* a);
d310 2
a311 2
char* writeString (char* s,data_tag tag,char* buffer,long* len);
char* readString (char** s,char* buffer);
d315 30
a344 30
void freeBitMap (bit_map* bm);
boolean bitAtPos (unsigned long pos,bit_map* bm);
char* writeBitMap (bit_map* bm,data_tag tag,char* buffer,long* len);
char* readBitMap (bit_map** bm,char* buffer);

char* writeByte (unsigned long byte,char* buf,long* len);
char* readByte (unsigned char* byte,char* buf);

char* writeBoolean (boolean flag,char* buf,long* len);
char* readBoolean (boolean* flag,char* buf);

char* writePDUType (pdu_type pduType,char* buf,long* len);
char* readPDUType (pdu_type* pduType,char* buf);
pdu_type peekPDUType (char* buf);

char* writeBinaryInteger (long num,unsigned long size,
			      char* buf,long* len);
char* readBinaryInteger (long* num,unsigned long size,char* buf);
unsigned long writtenCompressedBinIntSize (long num);

char* writeNum (long num,data_tag tag,char* buffer,long* len);
char* readNum (long* num,char* buffer);
unsigned long  writtenNumSize (data_tag tag,long num);

void doList (void** list,void (*func)(void *));

char* writeProtocolVersion (char* buf,long* len);
char* defaultImplementationID (void);
char* defaultImplementationName (void);
char* defaultImplementationVersion (void);
d459 1
a459 1
query_term* makeAttributeTerm (
d461 8
a468 8
	char* truncation,char* completeness,any* term);
query_term* makeResultSetTerm (any* resultSet);
query_term* makeOperatorTerm (char* operatorCode);
void freeTerm (void* qt);
char* writeQueryTerm (query_term* qt,char* buffer,long* len);
char* readQueryTerm (query_term** qt,char* buffer);
any* writeQuery (query_term** terms);
query_term** readQuery (any* info);
d479 1
a479 1
generate_retrieval_apdu (char *buff,
d485 1
a485 1
			     char *database_name);
d489 1
a489 1
interpret_message (char *request_message,
d494 1
a494 1
		       boolean verbose);
d496 1
a496 1
char *trim_junk (char *headline);
d584 1
a584 1
InitAPDU* makeInitAPDU (boolean search,boolean present,boolean deleteIt,
d588 4
a591 4
			    any* refID,void* userInfo);
void freeInitAPDU (InitAPDU* init);
char* writeInitAPDU (InitAPDU* init,char* buffer,long* len);
char* readInitAPDU (InitAPDU** init,char* buffer);
d593 1
a593 1
InitResponseAPDU* makeInitResponseAPDU (boolean result,
d598 5
a602 5
					    any* refID,void* userInfo);
void freeInitResponseAPDU (InitResponseAPDU* init);
char* writeInitResponseAPDU (InitResponseAPDU* init,char* buffer,long* len);
char* readInitResponseAPDU (InitResponseAPDU** init,char* buffer);
InitResponseAPDU* replyToInitAPDU (InitAPDU* init,boolean result,void* userInfo);
d604 1
a604 1
SearchAPDU* makeSearchAPDU (long small,long large, long medium,
d606 4
a609 4
				char* type,char** elements,any* refID,void* queryInfo);
void freeSearchAPDU (SearchAPDU* query);
char* writeSearchAPDU (SearchAPDU* query,char* buffer,long* len);
char* readSearchAPDU (SearchAPDU** query,char* buffer);
d611 1
a611 1
SearchResponseAPDU* makeSearchResponseAPDU (long result,long count,
d614 10
a623 10
						any* refID,void* records);
void freeSearchResponseAPDU (SearchResponseAPDU* queryResponse);
char* writeSearchResponseAPDU (SearchResponseAPDU* queryResponse,char* buffer,long* len);
char* readSearchResponseAPDU (SearchResponseAPDU** queryResponse,char* buffer);

PresentAPDU* makePresentAPDU (long recsReq, long startPos,
				  char* resultID,any* refID,void* info);
void freePresentAPDU (PresentAPDU* present);
char* writePresentAPDU (PresentAPDU* present,char* buffer,long* len);
char* readPresentAPDU (PresentAPDU** present,char* buffer);
d625 1
a625 1
PresentResponseAPDU* makePresentResponseAPDU (boolean status,long recsRet,
d627 4
a630 4
						  void* records);
void freePresentResponseAPDU (PresentResponseAPDU* present);
char* writePresentResponseAPDU (PresentResponseAPDU* present,char* buffer,long* len);
char* readPresentResponseAPDU (PresentResponseAPDU** present,char* buffer);
d635 2
a636 2
extern char* writeInitInfo (InitAPDU* init,char* buffer,long* len);
extern char* readInitInfo (void** info,char* buffer);
d638 2
a639 2
extern char* writeInitResponseInfo (InitResponseAPDU* init,char* buffer,long* len);
extern char* readInitResponseInfo (void** info,char* buffer);
d641 2
a642 2
extern char* writeSearchInfo (SearchAPDU* query,char* buffer,long* len);
extern char* readSearchInfo (void** info,char* buffer);
d644 2
a645 2
extern char* writeSearchResponseInfo (SearchResponseAPDU* query,char* buffer,long* len);
extern char* readSearchResponseInfo (void** info,char* buffer);
d647 2
a648 2
extern char* writePresentInfo (PresentAPDU* present,char* buffer,long* len);
extern char* readPresentInfo (void** info,char* buffer);
d650 2
a651 2
extern char* writePresentResponseInfo (PresentResponseAPDU* present,char* buffer,long* len);
extern char* readPresentResponseInfo (void** info,char* buffer);
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 5
a6 5
 *
 *	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
 *
 *	31-May-1994 FM	Initial version.
 */
d15 1
a15 1
void log_write(char *);
d18 3
a20 3
 *	Routines originally from Panic.h -- FM
 *
 *----------------------------------------------------------------------*/
d22 1
a22 1
void panic(char *format,...);
d26 1
d28 3
a30 3
 *	Routines originally from CUtil.h -- FM
 *
 *----------------------------------------------------------------------*/
d43 2
a44 2
#define false	(boolean)0L	/* used to be (!true), but broke
				   some compilers */
d60 5
a64 5
void fs_checkPtr(void *ptr);
void *fs_malloc(size_t size);
void *fs_realloc(void *ptr, size_t size);
void fs_free(void *ptr);
char *fs_strncat(char *dst, char *src, size_t maxToAdd, size_t maxTotal);
d73 1
a73 1
char *s_strdup(char *s);
d78 2
a79 2
char char_downcase(unsigned long ch);
char *string_downcase(char *word);
d83 2
d86 3
a88 3
 *	Routines originally from ZUtil.c -- FM
 *
 *----------------------------------------------------------------------*/
d110 4
a113 4
typedef struct any {		/* an any is a non-ascii string of characters */
    unsigned long size;
    char *bytes;
} any;
d115 1
a115 1
typedef any bit_map;		/* a bit_map is a group of packed bits */
d168 2
a169 2
#define CompressedInt1Byte	128	/* 2 ^ 7 */
#define CompressedInt2Byte	16384	/* 2 ^ 14 */
d174 2
a175 2
#define QT_0	"0"		/* query whose non-standard format has been agreed upon
				   client and server */
d187 1
a187 1
#define	SUCCESS	0		/* intuitive huh? */
d201 2
a202 2
#define PS_NONE		5	/* can't use NONE since it was used by result
				   set status */
d206 5
a210 5
typedef struct diagnosticRecord {
    boolean SURROGATE;
    char DIAG[DIAGNOSTIC_CODE_SIZE];
    char *ADDINFO;
} diagnosticRecord;
d254 1
a254 1
extern char *readErrorPosition;	/* pos where buf stoped making sense */
d262 1
a262 1
	  return(NULL);		/* jump out of caller */
d280 65
a344 65
diagnosticRecord *makeDiag(boolean surrogate, char *code, char *addInfo);
void freeDiag(diagnosticRecord * diag);
char *writeDiag(diagnosticRecord * diag, char *buffer, long *len);
char *readDiag(diagnosticRecord ** diag, char *buffer);

char *writeCompressedInteger(unsigned long num, char *buf, long *len);
char *readCompressedInteger(unsigned long *num, char *buf);
char *writeCompressedIntWithPadding(unsigned long num, unsigned long size,
				    char *buffer, long *len);
unsigned long writtenCompressedIntSize(unsigned long num);

char *writeTag(data_tag tag, char *buf, long *len);
char *readTag(data_tag *tag, char *buf);
data_tag peekTag(char *buf);
unsigned long writtenTagSize(data_tag tag);

any *makeAny(unsigned long size, char *data);
void freeAny(any *a);
any *duplicateAny(any *a);
char *writeAny(any *a, data_tag tag, char *buffer, long *len);
char *readAny(any **anAny, char *buffer);
unsigned long writtenAnySize(data_tag tag, any *a);

any *stringToAny(char *s);
char *anyToString(any *a);
unsigned long writtenStringSize(data_tag tag, char *s);

any *longToAny(long Num);
long anyToLong(any *a);

char *writeString(char *s, data_tag tag, char *buffer, long *len);
char *readString(char **s, char *buffer);

bit_map *makeBitMap(unsigned long numBits,...);

void freeBitMap(bit_map *bm);
boolean bitAtPos(unsigned long pos, bit_map *bm);
char *writeBitMap(bit_map *bm, data_tag tag, char *buffer, long *len);
char *readBitMap(bit_map **bm, char *buffer);

char *writeByte(unsigned long byte, char *buf, long *len);
char *readByte(unsigned char *byte, char *buf);

char *writeBoolean(boolean flag, char *buf, long *len);
char *readBoolean(boolean *flag, char *buf);

char *writePDUType(pdu_type pduType, char *buf, long *len);
char *readPDUType(pdu_type *pduType, char *buf);
pdu_type peekPDUType(char *buf);

char *writeBinaryInteger(long num, unsigned long size,
			 char *buf, long *len);
char *readBinaryInteger(long *num, unsigned long size, char *buf);
unsigned long writtenCompressedBinIntSize(long num);

char *writeNum(long num, data_tag tag, char *buffer, long *len);
char *readNum(long *num, char *buffer);
unsigned long writtenNumSize(data_tag tag, long num);

void doList(void **list, void (*func) (void *));

char *writeProtocolVersion(char *buf, long *len);
char *defaultImplementationID(void);
char *defaultImplementationName(void);
char *defaultImplementationVersion(void);
d348 1
d350 3
a352 3
 *	Routines originally from ZType1.c -- FM
 *
 *----------------------------------------------------------------------*/
d366 1
a366 1
#define QT_BooleanQuery	"1"	/* standard boolean query */
d440 14
a453 14
    /* type */
    long TermType;
    /* for term */
    char Use[ATTRIBUTE_SIZE];
    char Relation[ATTRIBUTE_SIZE];
    char Position[ATTRIBUTE_SIZE];
    char Structure[ATTRIBUTE_SIZE];
    char Truncation[ATTRIBUTE_SIZE];
    char Completeness[ATTRIBUTE_SIZE];
    any *Term;
    /* for result set */
    any *ResultSetID;
    /* for operator */
    char Operator[OPERATOR_SIZE];
d459 10
a468 9
query_term *makeAttributeTerm(char *use, char *relation, char *position, char *structure,
			      char *truncation, char *completeness, any *term);
query_term *makeResultSetTerm(any *resultSet);
query_term *makeOperatorTerm(char *operatorCode);
void freeTerm(void *qt);
char *writeQueryTerm(query_term *qt, char *buffer, long *len);
char *readQueryTerm(query_term **qt, char *buffer);
any *writeQuery(query_term **terms);
query_term **readQuery(any *info);
d472 1
d474 13
a486 11
 *	Routines originally from UI.c -- FM
 *
 *----------------------------------------------------------------------*/

char *generate_retrieval_apdu(char *buff,
			      long *buff_len,
			      any *docID,
			      long chunk_type,
			      long start_line, long end_line,
			      char *type,
			      char *database_name);
d488 2
a489 1
long interpret_message(char *request_message,
d492 1
a492 1
		       long response_buffer_length,	/* length of the buffer (modified) */
d496 3
a498 1
char *trim_junk(char *headline);
d501 3
a503 3
 *	Routines originally from ZProt.c -- FM
 *
 *----------------------------------------------------------------------*/
d508 12
a519 12
    pdu_type PDUType;
    boolean willSearch, willPresent, willDelete;
    boolean supportAccessControl, supportResourceControl;
    long PreferredMessageSize;
    long MaximumRecordSize;
    char *IDAuthentication;
    char *ImplementationID;
    char *ImplementationName;
    char *ImplementationVersion;
    any *ReferenceID;
    void *UserInformationField;
} InitAPDU;
d522 13
a534 13
    pdu_type PDUType;
    boolean Result;
    boolean willSearch, willPresent, willDelete;
    boolean supportAccessControl, supportResourceControl;
    long PreferredMessageSize;
    long MaximumRecordSize;
    char *IDAuthentication;
    char *ImplementationID;
    char *ImplementationName;
    char *ImplementationVersion;
    any *ReferenceID;
    void *UserInformationField;
} InitResponseAPDU;
d537 12
a548 12
    pdu_type PDUType;
    long SmallSetUpperBound;
    long LargeSetLowerBound;
    long MediumSetPresentNumber;
    boolean ReplaceIndicator;
    char *ResultSetName;
    char **DatabaseNames;
    char *QueryType;
    char **ElementSetNames;
    any *ReferenceID;
    void *Query;
} SearchAPDU;
d551 10
a560 10
    pdu_type PDUType;
    long SearchStatus;
    long ResultCount;
    long NumberOfRecordsReturned;
    long NextResultSetPosition;
    long ResultSetStatus;
    long PresentStatus;
    any *ReferenceID;
    void *DatabaseDiagnosticRecords;
} SearchResponseAPDU;
d563 8
a570 8
    pdu_type PDUType;
    long NumberOfRecordsRequested;
    long ResultSetStartPosition;
    char *ResultSetID;
    char *ElementSetNames;
    any *ReferenceID;
    void *PresentInfo;
} PresentAPDU;
d573 7
a579 7
    pdu_type PDUType;
    boolean PresentStatus;
    long NumberOfRecordsReturned;
    long NextResultSetPosition;
    any *ReferenceID;
    void *DatabaseDiagnosticRecords;
} PresentResponseAPDU;
d584 47
a630 59
InitAPDU *makeInitAPDU(boolean search, boolean present, boolean deleteIt,
		       boolean accessControl, boolean resourceControl, long prefMsgSize,
		       long maxMsgSize,
		       char *auth,
		       char *id,
		       char *name,
		       char *version,
		       any *refID,
		       void *userInfo);
void freeInitAPDU(InitAPDU * init);
char *writeInitAPDU(InitAPDU * init, char *buffer, long *len);
char *readInitAPDU(InitAPDU ** init, char *buffer);

InitResponseAPDU *makeInitResponseAPDU(boolean result,
				       boolean search,
				       boolean present,
				       boolean deleteIt,
				       boolean accessControl,
				       boolean resourceControl,
				       long prefMsgSize,
				       long maxMsgSize,
				       char *auth,
				       char *id,
				       char *name,
				       char *version,
				       any *refID,
				       void *userInfo);
void freeInitResponseAPDU(InitResponseAPDU *init);
char *writeInitResponseAPDU(InitResponseAPDU *init, char *buffer, long *len);
char *readInitResponseAPDU(InitResponseAPDU **init, char *buffer);
InitResponseAPDU *replyToInitAPDU(InitAPDU * init, boolean result, void *userInfo);

SearchAPDU *makeSearchAPDU(long small, long large, long medium,
			   boolean replace, char *name, char **databases,
			   char *type, char **elements, any *refID, void *queryInfo);
void freeSearchAPDU(SearchAPDU *query);
char *writeSearchAPDU(SearchAPDU *query, char *buffer, long *len);
char *readSearchAPDU(SearchAPDU **query, char *buffer);

SearchResponseAPDU *makeSearchResponseAPDU(long result, long count,
					   long recordsReturned, long nextPos,
					   long resultStatus, long presentStatus,
					   any *refID, void *records);
void freeSearchResponseAPDU(SearchResponseAPDU *queryResponse);
char *writeSearchResponseAPDU(SearchResponseAPDU *queryResponse, char *buffer, long *len);
char *readSearchResponseAPDU(SearchResponseAPDU **queryResponse, char *buffer);

PresentAPDU *makePresentAPDU(long recsReq, long startPos,
			     char *resultID, any *refID, void *info);
void freePresentAPDU(PresentAPDU * present);
char *writePresentAPDU(PresentAPDU * present, char *buffer, long *len);
char *readPresentAPDU(PresentAPDU ** present, char *buffer);

PresentResponseAPDU *makePresentResponseAPDU(boolean status, long recsRet,
					     long nextPos, any *refID,
					     void *records);
void freePresentResponseAPDU(PresentResponseAPDU * present);
char *writePresentResponseAPDU(PresentResponseAPDU * present, char *buffer, long *len);
char *readPresentResponseAPDU(PresentResponseAPDU ** present, char *buffer);
d635 5
a639 2
extern char *writeInitInfo(InitAPDU * init, char *buffer, long *len);
extern char *readInitInfo(void **info, char *buffer);
d641 2
a642 2
extern char *writeInitResponseInfo(InitResponseAPDU *init, char *buffer, long *len);
extern char *readInitResponseInfo(void **info, char *buffer);
d644 2
a645 2
extern char *writeSearchInfo(SearchAPDU *query, char *buffer, long *len);
extern char *readSearchInfo(void **info, char *buffer);
d647 2
a648 2
extern char *writeSearchResponseInfo(SearchResponseAPDU *query, char *buffer, long *len);
extern char *readSearchResponseInfo(void **info, char *buffer);
d650 2
a651 2
extern char *writePresentInfo(PresentAPDU * present, char *buffer, long *len);
extern char *readPresentInfo(void **info, char *buffer);
a652 3
extern char *writePresentResponseInfo(PresentResponseAPDU * present, char
				      *buffer, long *len);
extern char *readPresentResponseInfo(void **info, char *buffer);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d186 4
@

