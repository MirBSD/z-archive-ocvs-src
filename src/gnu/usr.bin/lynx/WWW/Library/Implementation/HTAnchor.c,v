head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.8
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.6
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.07.15.18.16.31;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.24;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.55.39;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.57.59;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.05;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.53;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.08;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.50;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.25;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.14;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.47.08;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@automatic merge of lynx-current
@
text
@/*	Hypertext "Anchor" Object				HTAnchor.c
 *	==========================
 *
 * An anchor represents a region of a hypertext document which is linked to
 * another anchor in the same or a different document.
 *
 * History
 *
 *	   Nov 1990  Written in Objective-C for the NeXT browser (TBL)
 *	24-Oct-1991 (JFG), written in C, browser-independent
 *	21-Nov-1991 (JFG), first complete version
 *
 *	(c) Copyright CERN 1991 - See Copyright.html
 */

#define HASH_SIZE 101		/* Arbitrary prime.  Memory/speed tradeoff */

#include <HTUtils.h>
#include <HTAnchor.h>
#include <HTParse.h>
#include <HTString.h>
#include <UCAux.h>
#include <UCMap.h>

#include <GridText.h>
#include <LYUtils.h>
#include <LYCharSets.h>
#include <LYLeaks.h>

#ifdef NOT_DEFINED
/*
 *	This is the hashing function used to determine which list in the
 *		adult_table a parent anchor should be put in.  This is a
 *		much simpler function than the original used.
 */
#define HASH_FUNCTION(cp_address) ((unsigned short int)strlen(cp_address) *\
	(unsigned short int)TOUPPER(*cp_address) % HASH_SIZE)
#endif /* NOT_DEFINED */
/*
 *	This is the original function.	We'll use it again. - FM
 */
static int HASH_FUNCTION(const char *cp_address)
{
    int hash;
    const unsigned char *p;

    for (p = (const unsigned char *) cp_address, hash = 0; *p; p++)
	hash = (int) (hash * 3 + (*(const unsigned char *) p)) % HASH_SIZE;

    return (hash);
}

typedef struct _HyperDoc Hyperdoc;

#ifdef VMS
struct _HyperDoc {
    int junk;			/* VMS cannot handle pointers to undefined structs */
};
#endif /* VMS */

/* Table of lists of all parents */
static HTList adult_table[HASH_SIZE] =
{
    {NULL, NULL}};

/*				Creation Methods
 *				================
 *
 *	Do not use "new" by itself outside this module.  In order to enforce
 *	consistency, we insist that you furnish more information about the
 *	anchor you are creating : use newWithParent or newWithAddress.
 */
static HTParentAnchor0 *HTParentAnchor0_new(const char *address,
					    short hash)
{
    HTParentAnchor0 *newAnchor = typecalloc(HTParentAnchor0);

    if (newAnchor == NULL)
	outofmem(__FILE__, "HTParentAnchor0_new");

    newAnchor->parent = newAnchor;	/* self */
    StrAllocCopy(newAnchor->address, address);
    newAnchor->adult_hash = hash;

    return (newAnchor);
}

static HTParentAnchor *HTParentAnchor_new(HTParentAnchor0 *parent)
{
    HTParentAnchor *newAnchor = typecalloc(HTParentAnchor);

    if (newAnchor == NULL)
	outofmem(__FILE__, "HTParentAnchor_new");

    newAnchor->parent = parent;	/* cross reference */
    parent->info = newAnchor;	/* cross reference */
    newAnchor->address = parent->address;	/* copy pointer */

    newAnchor->isISMAPScript = FALSE;	/* Lynx appends ?0,0 if TRUE. - FM */
    newAnchor->isHEAD = FALSE;	/* HEAD request if TRUE. - FM */
    newAnchor->safe = FALSE;	/* Safe. - FM */
    newAnchor->no_cache = FALSE;	/* no-cache? - FM */
    newAnchor->inBASE = FALSE;	/* duplicated from HTML.c/h */
    newAnchor->content_length = 0;	/* Content-Length. - FM */
    return (newAnchor);
}

static HTChildAnchor *HTChildAnchor_new(HTParentAnchor0 *parent)
{
    HTChildAnchor *p = typecalloc(HTChildAnchor);

    if (p == NULL)
	outofmem(__FILE__, "HTChildAnchor_new");

    p->parent = parent;		/* parent reference */
    return p;
}

static HTChildAnchor *HText_pool_ChildAnchor_new(HTParentAnchor *parent)
{
    HTChildAnchor *p = (HTChildAnchor *) HText_pool_calloc((HText *) (parent->document),
							   sizeof(HTChildAnchor));

    if (p == NULL)
	outofmem(__FILE__, "HText_pool_ChildAnchor_new");

    p->parent = parent->parent;	/* parent reference */
    return p;
}

#ifdef CASE_INSENSITIVE_ANCHORS
/* Case insensitive string comparison */
#define HT_EQUIV(a,b) (TOUPPER(a) == TOUPPER(b))
#else
/* Case sensitive string comparison */
#define HT_EQUIV(a,b) ((a) == (b))
#endif

/*	Null-terminated string comparison
 *	---------------------------------
 * On entry,
 *	s	Points to one string, null terminated
 *	t	points to the other.
 * On exit,
 *	returns YES if the strings are equivalent
 *		NO if they differ.
 */
static BOOL HTSEquivalent(const char *s,
			  const char *t)
{
    if (s && t) {		/* Make sure they point to something */
	for (; *s && *t; s++, t++) {
	    if (!HT_EQUIV(*s, *t)) {
		return (NO);
	    }
	}
	return (HT_EQUIV(*s, *t));
    } else {
	return (s == t);	/* Two NULLs are equivalent, aren't they ? */
    }
}

/*	Binary string comparison
 *	------------------------
 * On entry,
 *	s	Points to one bstring
 *	t	points to the other.
 * On exit,
 *	returns YES if the strings are equivalent
 *		NO if they differ.
 */
static BOOL HTBEquivalent(const bstring *s,
			  const bstring *t)
{
    if (s && t && BStrLen(s) == BStrLen(t)) {
	int j;
	int len = BStrLen(s);

	for (j = 0; j < len; ++j) {
	    if (!HT_EQUIV(BStrData(s)[j], BStrData(t)[j])) {
		return (NO);
	    }
	}
	return (YES);
    } else {
	return (s == t);	/* Two NULLs are equivalent, aren't they ? */
    }
}

/*
 * Three-way compare function
 */
static int compare_anchors(void *l,
			   void *r)
{
    const char *a = ((HTChildAnchor *) l)->tag;
    const char *b = ((HTChildAnchor *) r)->tag;

    /* both tags are not NULL */

#ifdef CASE_INSENSITIVE_ANCHORS
    return strcasecomp(a, b);	/* Case insensitive */
#else
    return strcmp(a, b);	/* Case sensitive - FM */
#endif /* CASE_INSENSITIVE_ANCHORS */
}

/*	Create new or find old sub-anchor
 *	---------------------------------
 *
 *	This one is for a named child.
 *	The parent anchor must already exist.
 */
static HTChildAnchor *HTAnchor_findNamedChild(HTParentAnchor0 *parent,
					      const char *tag)
{
    HTChildAnchor *child;

    if (parent && tag && *tag) {	/* TBL */
	if (parent->children) {
	    /*
	     * Parent has children.  Search them.
	     */
	    HTChildAnchor sample;

	    sample.tag = (char *) tag;	/* for compare_anchors() only */

	    child = (HTChildAnchor *) HTBTree_search(parent->children, &sample);
	    if (child != NULL) {
		CTRACE((tfp,
			"Child anchor %p of parent %p with name `%s' already exists.\n",
			(void *) child, (void *) parent, tag));
		return (child);
	    }
	} else {		/* parent doesn't have any children yet : create family */
	    parent->children = HTBTree_new(compare_anchors);
	}

	child = HTChildAnchor_new(parent);
	CTRACE((tfp, "HTAnchor: New Anchor %p named `%s' is child of %p\n",
		(void *) child,
		NonNull(tag),
		(void *) child->parent));

	StrAllocCopy(child->tag, tag);	/* should be set before HTBTree_add */
	HTBTree_add(parent->children, child);
	return (child);

    } else {
	CTRACE((tfp, "HTAnchor_findNamedChild called with NULL parent.\n"));
	return (NULL);
    }

}

/*
 *	This one is for a new unnamed child being edited into an existing
 *	document.  The parent anchor and the document must already exist.
 *	(Just add new unnamed child).
 */
static HTChildAnchor *HTAnchor_addChild(HTParentAnchor *parent)
{
    HTChildAnchor *child;

    if (!parent) {
	CTRACE((tfp, "HTAnchor_addChild called with NULL parent.\n"));
	return (NULL);
    }

    child = HText_pool_ChildAnchor_new(parent);
    CTRACE((tfp, "HTAnchor: New unnamed Anchor %p is child of %p\n",
	    (void *) child,
	    (void *) child->parent));

    child->tag = 0;
    HTList_linkObject(&parent->children_notag, child, &child->_add_children_notag);

    return (child);
}

static HTParentAnchor0 *HTAnchor_findAddress_in_adult_table(const DocAddress *newdoc);

static BOOL HTAnchor_link(HTChildAnchor *child,
			  HTAnchor * destination,
			  HTLinkType *type);

/*	Create or find a child anchor with a possible link
 *	--------------------------------------------------
 *
 *	Create new anchor with a given parent and possibly
 *	a name, and possibly a link to a _relatively_ named anchor.
 *	(Code originally in ParseHTML.h)
 */
HTChildAnchor *HTAnchor_findChildAndLink(HTParentAnchor *parent,	/* May not be 0   */
					 const char *tag,	/* May be "" or 0 */
					 const char *href,	/* May be "" or 0 */
					 HTLinkType *ltype)	/* May be 0       */
{
    HTChildAnchor *child;

    CTRACE((tfp, "Entered HTAnchor_findChildAndLink:  tag=`%s',%s href=`%s'\n",
	    NonNull(tag),
	    (ltype == HTInternalLink) ? " (internal link)" : "",
	    NonNull(href)));

    if (tag && *tag) {
	child = HTAnchor_findNamedChild(parent->parent, tag);
    } else {
	child = HTAnchor_addChild(parent);
    }

    if (href && *href) {
	const char *fragment = NULL;
	HTParentAnchor0 *dest;

	if (ltype == HTInternalLink && *href == '#') {
	    dest = parent->parent;
	} else {
	    const char *relative_to = (parent->inBASE && *href != '#') ?
	    parent->content_base : parent->address;
	    DocAddress parsed_doc;

	    parsed_doc.address = HTParse(href, relative_to,
					 PARSE_ALL_WITHOUT_ANCHOR);

	    parsed_doc.post_data = NULL;
	    parsed_doc.post_content_type = NULL;
	    if (ltype && parent->post_data && ltype == HTInternalLink) {
		/* for internal links, find a destination with the same
		   post data if the source of the link has post data. - kw
		   Example: LYNXIMGMAP: */
		parsed_doc.post_data = parent->post_data;
		parsed_doc.post_content_type = parent->post_content_type;
	    }
	    parsed_doc.bookmark = NULL;
	    parsed_doc.isHEAD = FALSE;
	    parsed_doc.safe = FALSE;

	    dest = HTAnchor_findAddress_in_adult_table(&parsed_doc);
	    FREE(parsed_doc.address);
	}

	/*
	 * [from HTAnchor_findAddress()]
	 * If the address represents a sub-anchor, we load its parent (above),
	 * then we create a named child anchor within that parent.
	 */
	fragment = (*href == '#') ? href + 1 : HTParseAnchor(href);

	if (*fragment)
	    dest = (HTParentAnchor0 *) HTAnchor_findNamedChild(dest, fragment);

	if (tag && *tag) {
	    if (child->dest) {	/* DUPLICATE_ANCHOR_NAME_WORKAROUND  - kw */
		CTRACE((tfp,
			"*** Duplicate ChildAnchor %p named `%s'",
			child, tag));
		if ((HTAnchor *) dest != child->dest || ltype != child->type) {
		    CTRACE((tfp,
			    ", different dest %p or type, creating unnamed child\n",
			    child->dest));
		    child = HTAnchor_addChild(parent);
		}
	    }
	}
	HTAnchor_link(child, (HTAnchor *) dest, ltype);
    }
    return child;
}

/*	Create new or find old parent anchor
 *	------------------------------------
 *
 *	Me one is for a reference which is found in a document, and might
 *	not be already loaded.
 *	Note: You are not guaranteed a new anchor -- you might get an old one,
 *	like with fonts.
 */
HTParentAnchor *HTAnchor_findAddress(const DocAddress *newdoc)
{
    /* Anchor tag specified ? */
    const char *tag = HTParseAnchor(newdoc->address);

    CTRACE((tfp, "Entered HTAnchor_findAddress\n"));

    /*
     * If the address represents a sub-anchor, we load its parent, then we
     * create a named child anchor within that parent.
     */
    if (*tag) {
	DocAddress parsed_doc;
	HTParentAnchor0 *foundParent;
	HTChildAnchor *foundAnchor;

	parsed_doc.address = HTParse(newdoc->address, "",
				     PARSE_ALL_WITHOUT_ANCHOR);
	parsed_doc.post_data = newdoc->post_data;
	parsed_doc.post_content_type = newdoc->post_content_type;
	parsed_doc.bookmark = newdoc->bookmark;
	parsed_doc.isHEAD = newdoc->isHEAD;
	parsed_doc.safe = newdoc->safe;

	foundParent = HTAnchor_findAddress_in_adult_table(&parsed_doc);
	foundAnchor = HTAnchor_findNamedChild(foundParent, tag);
	FREE(parsed_doc.address);
	return HTAnchor_parent((HTAnchor *) foundParent);
    }
    return HTAnchor_parent((HTAnchor *) HTAnchor_findAddress_in_adult_table(newdoc));
}

/*  The address has no anchor tag, for sure.
 */
static HTParentAnchor0 *HTAnchor_findAddress_in_adult_table(const DocAddress *newdoc)
{
    /*
     * Check whether we have this node.
     */
    int hash;
    HTList *adults;
    HTList *grownups;
    HTParentAnchor0 *foundAnchor;
    BOOL need_extra_info = (newdoc->post_data || newdoc->post_content_type ||
			    newdoc->bookmark || newdoc->isHEAD || newdoc->safe);

    /*
     * We need not free adult_table[] atexit - it should be perfectly empty
     * after free'ing all HText's.  (There is an error if it is not empty at
     * exit).  -LP
     */

    /*
     * Select list from hash table,
     */
    hash = HASH_FUNCTION(newdoc->address);
    adults = &(adult_table[hash]);

    /*
     * Search list for anchor.
     */
    grownups = adults;
    while (NULL != (foundAnchor =
		    (HTParentAnchor0 *) HTList_nextObject(grownups))) {
	if (HTSEquivalent(foundAnchor->address, newdoc->address) &&

	    ((!foundAnchor->info && !need_extra_info) ||
	     (foundAnchor->info &&
	      HTBEquivalent(foundAnchor->info->post_data, newdoc->post_data) &&
	      foundAnchor->info->isHEAD == newdoc->isHEAD))) {
	    CTRACE((tfp, "Anchor %p with address `%s' already exists.\n",
		    (void *) foundAnchor, newdoc->address));
	    return foundAnchor;
	}
    }

    /*
     * Node not found:  create new anchor.
     */
    foundAnchor = HTParentAnchor0_new(newdoc->address, hash);
    CTRACE((tfp, "New anchor %p has hash %d and address `%s'\n",
	    (void *) foundAnchor, hash, newdoc->address));

    if (need_extra_info) {
	/* rare case, create a big structure */
	HTParentAnchor *p = HTParentAnchor_new(foundAnchor);

	if (newdoc->post_data)
	    BStrCopy(p->post_data, newdoc->post_data);
	if (newdoc->post_content_type)
	    StrAllocCopy(p->post_content_type,
			 newdoc->post_content_type);
	if (newdoc->bookmark)
	    StrAllocCopy(p->bookmark, newdoc->bookmark);
	p->isHEAD = newdoc->isHEAD;
	p->safe = newdoc->safe;
    }
    HTList_linkObject(adults, foundAnchor, &foundAnchor->_add_adult);

    return foundAnchor;
}

/*	Create new or find old named anchor - simple form
 *	-------------------------------------------------
 *
 *     Like HTAnchor_findAddress, but simpler to use for simple cases.
 *	No post data etc. can be supplied. - kw
 */
HTParentAnchor *HTAnchor_findSimpleAddress(const char *url)
{
    DocAddress urldoc;

    urldoc.address = (char *) url;	/* ignore warning, it IS treated like const - kw */
    urldoc.post_data = NULL;
    urldoc.post_content_type = NULL;
    urldoc.bookmark = NULL;
    urldoc.isHEAD = FALSE;
    urldoc.safe = FALSE;
    return HTAnchor_findAddress(&urldoc);
}

/*	Link me Anchor to another given one
 *	-------------------------------------
 */
static BOOL HTAnchor_link(HTChildAnchor *child,
			  HTAnchor * destination,
			  HTLinkType *type)
{
    if (!(child && destination))
	return (NO);		/* Can't link to/from non-existing anchor */

    CTRACE((tfp, "Linking child %p to anchor %p\n", child, destination));
    if (child->dest) {
	CTRACE((tfp, "*** child anchor already has destination, exiting!\n"));
	return (NO);
    }

    child->dest = destination;
    child->type = type;

    if (child->parent != destination->parent)
	/* link only foreign children */
	HTList_linkObject(&destination->parent->sources, child, &child->_add_sources);

    return (YES);		/* Success */
}

/*	Delete an anchor and possibly related things (auto garbage collection)
 *	--------------------------------------------
 *
 *	The anchor is only deleted if the corresponding document is not loaded.
 *	All outgoing links from children are deleted, and children are
 *	removed from the sources lists of theirs targets.
 *	We also try to delete the targets whose documents are not loaded.
 *	If this anchor's sources list is empty, we delete it and its children.
 */

/*
 *	Recursively try to delete destination anchor of this child.
 *	In any event, this will tell destination anchor that we
 *	no longer consider it a destination.
 */
static void deleteLinks(HTChildAnchor *me)
{
    /*
     * Unregister me with our destination anchor's parent.
     */
    if (me->dest) {
	HTParentAnchor0 *parent = me->dest->parent;

	/*
	 * Start.  Set the dest pointer to zero.
	 */
	me->dest = NULL;

	/*
	 * Remove me from the parent's sources so that the parent knows one
	 * less anchor is its dest.
	 */
	if ((me->parent != parent) && !HTList_isEmpty(&parent->sources)) {
	    /*
	     * Really should only need to deregister once.
	     */
	    HTList_unlinkObject(&parent->sources, (void *) me);
	}

	/*
	 * Recursive call.  Test here to avoid calling overhead.  Don't delete
	 * if document is loaded or being loaded.
	 */
	if ((me->parent != parent) && !parent->underway &&
	    (!parent->info || !parent->info->document)) {
	    HTAnchor_delete(parent);
	}

	/*
	 * At this point, we haven't a destination.  Set it to be so.  Leave
	 * the HTAtom pointed to by type up to other code to handle (reusable,
	 * near static).
	 */
	me->type = NULL;
    }
}

static void HTParentAnchor_free(HTParentAnchor *me);

BOOL HTAnchor_delete(HTParentAnchor0 *me)
{
    /*
     * Memory leaks fixed.
     * 05-27-94 Lynx 2-3-1 Garrett Arch Blythe
     */
    HTBTElement *ele;
    HTChildAnchor *child;

    /*
     * Do nothing if nothing to do.
     */
    if (!me) {
	return (NO);
    }

    /*
     * Don't delete if document is loaded or being loaded.
     */
    if (me->underway || (me->info && me->info->document)) {
	return (NO);
    }

    /*
     * Mark ourselves busy, so that recursive calls of this function on this
     * HTParentAnchor0 will not free it from under our feet.  - kw
     */
    me->underway = TRUE;

    {
	/*
	 * Delete all outgoing links from named children.  Do not delete named
	 * children itself (may have incoming links).
	 */
	if (me->children) {
	    ele = HTBTree_next(me->children, NULL);
	    while (ele != NULL) {
		child = (HTChildAnchor *) HTBTree_object(ele);
		if (child->dest)
		    deleteLinks(child);
		ele = HTBTree_next(me->children, ele);
	    }
	}
    }
    me->underway = FALSE;

    /*
     * There are still incoming links to this one (we are the
     * destination of another anchor).
     */
    if (!HTList_isEmpty(&me->sources)) {
	/*
	 * Can't delete parent, still have sources.
	 */
	return (NO);
    }

    /*
     * No more incoming and outgoing links :  kill everything First, delete
     * named children.
     */
    if (me->children) {
	ele = HTBTree_next(me->children, NULL);
	while (ele != NULL) {
	    child = (HTChildAnchor *) HTBTree_object(ele);
	    FREE(child->tag);
	    FREE(child);
	    ele = HTBTree_next(me->children, ele);
	}
	HTBTree_free(me->children);
    }

    /*
     * Delete the ParentAnchor, if any.  (Document was already deleted).
     */
    if (me->info) {
	HTParentAnchor_free(me->info);
	FREE(me->info);
    }

    /*
     * Remove ourselves from the hash table's list.
     */
    HTList_unlinkObject(&(adult_table[me->adult_hash]), (void *) me);

    /*
     * Free the address.
     */
    FREE(me->address);

    /*
     * Finally, kill the parent anchor passed in.
     */
    FREE(me);

    return (YES);
}

/*
 * Unnamed children (children_notag) have no sence without HText - delete them
 * and their links if we are about to free HText.  Document currently exists. 
 * Called within HText_free().
 */
void HTAnchor_delete_links(HTParentAnchor *me)
{
    HTList *cur;
    HTChildAnchor *child;

    /*
     * Do nothing if nothing to do.
     */
    if (!me || !me->document) {
	return;
    }

    /*
     * Mark ourselves busy, so that recursive calls on this HTParentAnchor0
     * will not free it from under our feet.  - kw
     */
    me->parent->underway = TRUE;

    /*
     * Delete all outgoing links from unnamed children.
     */
    if (!HTList_isEmpty(&me->children_notag)) {
	cur = &me->children_notag;
	while ((child =
		(HTChildAnchor *) HTList_unlinkLastObject(cur)) != 0) {
	    deleteLinks(child);
	    /* child allocated in HText pool, HText_free() will free it later */
	}
    }
    me->parent->underway = FALSE;
}

static void HTParentAnchor_free(HTParentAnchor *me)
{
    /*
     * Delete the methods list.
     */
    if (me->methods) {
	/*
	 * Leave what the methods point to up in memory for other code (near
	 * static stuff).
	 */
	HTList_delete(me->methods);
	me->methods = NULL;
    }

    /*
     * Free up all allocated members.
     */
    FREE(me->charset);
    FREE(me->isIndexAction);
    FREE(me->isIndexPrompt);
    FREE(me->title);
    FREE(me->physical);
    BStrFree(me->post_data);
    FREE(me->post_content_type);
    FREE(me->bookmark);
    FREE(me->owner);
    FREE(me->RevTitle);
    FREE(me->citehost);
#ifdef USE_SOURCE_CACHE
    HTAnchor_clearSourceCache(me);
#endif
    if (me->FileCache) {
	FILE *fd;

	if ((fd = fopen(me->FileCache, "r")) != NULL) {
	    fclose(fd);
	    remove(me->FileCache);
	}
	FREE(me->FileCache);
    }
    FREE(me->SugFname);
    FREE(me->cache_control);
#ifdef EXP_HTTP_HEADERS
    HTChunkClear(&(me->http_headers));
#endif
    FREE(me->content_type_params);
    FREE(me->content_type);
    FREE(me->content_language);
    FREE(me->content_encoding);
    FREE(me->content_base);
    FREE(me->content_disposition);
    FREE(me->content_location);
    FREE(me->content_md5);
    FREE(me->message_id);
    FREE(me->subject);
    FREE(me->date);
    FREE(me->expires);

    FREE(me->last_modified);
    FREE(me->ETag);
    FREE(me->server);
#ifdef USE_COLOR_STYLE
    FREE(me->style);
#endif

    /*
     * Original code wanted a way to clean out the HTFormat if no longer needed
     * (ref count?).  I'll leave it alone since those HTAtom objects are a
     * little harder to know where they are being referenced all at one time. 
     * (near static)
     */

    FREE(me->UCStages);
    ImageMapList_free(me->imaps);
}

#ifdef USE_SOURCE_CACHE
void HTAnchor_clearSourceCache(HTParentAnchor *me)
{
    /*
     * Clean up the source cache, if any.
     */
    if (me->source_cache_file) {
	CTRACE((tfp, "SourceCache: Removing file %s\n",
		me->source_cache_file));
	LYRemoveTemp(me->source_cache_file);
	FREE(me->source_cache_file);
    }
    if (me->source_cache_chunk) {
	CTRACE((tfp, "SourceCache: Removing memory chunk %p\n",
		(void *) me->source_cache_chunk));
	HTChunkFree(me->source_cache_chunk);
	me->source_cache_chunk = NULL;
    }
}
#endif /* USE_SOURCE_CACHE */

/*	Data access functions
 *	---------------------
 */
HTParentAnchor *HTAnchor_parent(HTAnchor * me)
{
    if (!me)
	return NULL;

    if (me->parent->info)
	return me->parent->info;

    /* else: create a new structure */
    return HTParentAnchor_new(me->parent);
}

void HTAnchor_setDocument(HTParentAnchor *me,
			  HyperDoc *doc)
{
    if (me)
	me->document = doc;
}

HyperDoc *HTAnchor_document(HTParentAnchor *me)
{
    return (me ? me->document : NULL);
}

char *HTAnchor_address(HTAnchor * me)
{
    char *addr = NULL;

    if (me) {
	if (((HTParentAnchor0 *) me == me->parent) ||
	    ((HTParentAnchor *) me == me->parent->info) ||
	    !((HTChildAnchor *) me)->tag) {	/* it's an adult or no tag */
	    StrAllocCopy(addr, me->parent->address);
	} else {		/* it's a named child */
	    HTSprintf0(&addr, "%s#%s",
		       me->parent->address, ((HTChildAnchor *) me)->tag);
	}
    }
    return (addr);
}

void HTAnchor_setFormat(HTParentAnchor *me,
			HTFormat form)
{
    if (me)
	me->format = form;
}

HTFormat HTAnchor_format(HTParentAnchor *me)
{
    return (me ? me->format : NULL);
}

void HTAnchor_setIndex(HTParentAnchor *me,
		       const char *address)
{
    if (me) {
	me->isIndex = YES;
	StrAllocCopy(me->isIndexAction, address);
    }
}

void HTAnchor_setPrompt(HTParentAnchor *me,
			const char *prompt)
{
    if (me) {
	StrAllocCopy(me->isIndexPrompt, prompt);
    }
}

BOOL HTAnchor_isIndex(HTParentAnchor *me)
{
    return (me ? me->isIndex : NO);
}

/*	Whether Anchor has been designated as an ISMAP link
 *	(normally by presence of an ISMAP attribute on A or IMG) - KW
 */
BOOL HTAnchor_isISMAPScript(HTAnchor * me)
{
    return ((me && me->parent->info) ? me->parent->info->isISMAPScript : NO);
}

#if defined(USE_COLOR_STYLE)
/*	Style handling.
*/
const char *HTAnchor_style(HTParentAnchor *me)
{
    return (me ? me->style : NULL);
}

void HTAnchor_setStyle(HTParentAnchor *me,
		       const char *style)
{
    if (me) {
	StrAllocCopy(me->style, style);
    }
}
#endif

/*	Title handling.
*/
const char *HTAnchor_title(HTParentAnchor *me)
{
    return (me ? me->title : NULL);
}

void HTAnchor_setTitle(HTParentAnchor *me,
		       const char *title)
{
    int i;

    if (me) {
	if (title) {
	    StrAllocCopy(me->title, title);
	    for (i = 0; me->title[i]; i++) {
		if (UCH(me->title[i]) == 1 ||
		    UCH(me->title[i]) == 2) {
		    me->title[i] = ' ';
		}
	    }
	} else {
	    CTRACE((tfp, "HTAnchor_setTitle: New title is NULL! "));
	    if (me->title) {
		CTRACE((tfp, "Old title was \"%s\".\n", me->title));
		FREE(me->title);
	    } else {
		CTRACE((tfp, "Old title was NULL.\n"));
	    }
	}
    }
}

void HTAnchor_appendTitle(HTParentAnchor *me,
			  const char *title)
{
    int i;

    if (me) {
	StrAllocCat(me->title, title);
	for (i = 0; me->title[i]; i++) {
	    if (UCH(me->title[i]) == 1 ||
		UCH(me->title[i]) == 2) {
		me->title[i] = ' ';
	    }
	}
    }
}

/*	Bookmark handling.
*/
const char *HTAnchor_bookmark(HTParentAnchor *me)
{
    return (me ? me->bookmark : NULL);
}

void HTAnchor_setBookmark(HTParentAnchor *me,
			  const char *bookmark)
{
    if (me)
	StrAllocCopy(me->bookmark, bookmark);
}

/*	Owner handling.
*/
const char *HTAnchor_owner(HTParentAnchor *me)
{
    return (me ? me->owner : NULL);
}

void HTAnchor_setOwner(HTParentAnchor *me,
		       const char *owner)
{
    if (me) {
	StrAllocCopy(me->owner, owner);
    }
}

/*	TITLE handling in LINKs with REV="made" or REV="owner". - FM
*/
const char *HTAnchor_RevTitle(HTParentAnchor *me)
{
    return (me ? me->RevTitle : NULL);
}

void HTAnchor_setRevTitle(HTParentAnchor *me,
			  const char *title)
{
    int i;

    if (me) {
	StrAllocCopy(me->RevTitle, title);
	for (i = 0; me->RevTitle[i]; i++) {
	    if (UCH(me->RevTitle[i]) == 1 ||
		UCH(me->RevTitle[i]) == 2) {
		me->RevTitle[i] = ' ';
	    }
	}
    }
}

#ifndef DISABLE_BIBP
/*	Citehost for bibp links from LINKs with REL="citehost". - RDC
*/
const char *HTAnchor_citehost(HTParentAnchor *me)
{
    return (me ? me->citehost : NULL);
}

void HTAnchor_setCitehost(HTParentAnchor *me,
			  const char *citehost)
{
    if (me) {
	StrAllocCopy(me->citehost, citehost);
    }
}
#endif /* !DISABLE_BIBP */

/*	Suggested filename handling. - FM
 *	(will be loaded if we had a Content-Disposition
 *	 header or META element with filename=name.suffix)
 */
const char *HTAnchor_SugFname(HTParentAnchor *me)
{
    return (me ? me->SugFname : NULL);
}

#ifdef EXP_HTTP_HEADERS
/*	HTTP Headers.
*/
const char *HTAnchor_http_headers(HTParentAnchor *me)
{
    return (me ? me->http_headers.data : NULL);
}
#endif

/*	Content-Type handling (parameter list).
*/
const char *HTAnchor_content_type_params(HTParentAnchor *me)
{
    return (me ? me->content_type_params : NULL);
}

/*	Content-Encoding handling. - FM
 *	(will be loaded if we had a Content-Encoding
 *	 header.)
 */
const char *HTAnchor_content_encoding(HTParentAnchor *me)
{
    return (me ? me->content_encoding : NULL);
}

/*	Content-Type handling. - FM
*/
const char *HTAnchor_content_type(HTParentAnchor *me)
{
    return (me ? me->content_type : NULL);
}

/*	Last-Modified header handling. - FM
*/
const char *HTAnchor_last_modified(HTParentAnchor *me)
{
    return (me ? me->last_modified : NULL);
}

/*	Date header handling. - FM
*/
const char *HTAnchor_date(HTParentAnchor *me)
{
    return (me ? me->date : NULL);
}

/*	Server header handling. - FM
*/
const char *HTAnchor_server(HTParentAnchor *me)
{
    return (me ? me->server : NULL);
}

/*	Safe header handling. - FM
*/
BOOL HTAnchor_safe(HTParentAnchor *me)
{
    return (BOOL) (me ? me->safe : FALSE);
}

/*	Content-Base header handling. - FM
*/
const char *HTAnchor_content_base(HTParentAnchor *me)
{
    return (me ? me->content_base : NULL);
}

/*	Content-Location header handling. - FM
*/
const char *HTAnchor_content_location(HTParentAnchor *me)
{
    return (me ? me->content_location : NULL);
}

/*	Message-ID, used for mail replies - kw
*/
const char *HTAnchor_messageID(HTParentAnchor *me)
{
    return (me ? me->message_id : NULL);
}

BOOL HTAnchor_setMessageID(HTParentAnchor *me,
			   const char *messageid)
{
    if (!(me && messageid && *messageid)) {
	return FALSE;
    }
    StrAllocCopy(me->message_id, messageid);
    return TRUE;
}

/*	Subject, used for mail replies - kw
*/
const char *HTAnchor_subject(HTParentAnchor *me)
{
    return (me ? me->subject : NULL);
}

BOOL HTAnchor_setSubject(HTParentAnchor *me,
			 const char *subject)
{
    if (!(me && subject && *subject)) {
	return FALSE;
    }
    StrAllocCopy(me->subject, subject);
    return TRUE;
}

/*	Manipulation of links
 *	---------------------
 */
HTAnchor *HTAnchor_followLink(HTChildAnchor *me)
{
    return (me->dest);
}

HTAnchor *HTAnchor_followTypedLink(HTChildAnchor *me,
				   HTLinkType *type)
{
    if (me->type == type)
	return (me->dest);
    return (NULL);		/* No link of me type */
}

/*	Methods List
 *	------------
 */
HTList *HTAnchor_methods(HTParentAnchor *me)
{
    if (!me->methods) {
	me->methods = HTList_new();
    }
    return (me->methods);
}

/*	Protocol
 *	--------
 */
void *HTAnchor_protocol(HTParentAnchor *me)
{
    return (me->protocol);
}

void HTAnchor_setProtocol(HTParentAnchor *me,
			  void *protocol)
{
    me->protocol = protocol;
}

/*	Physical Address
 *	----------------
 */
char *HTAnchor_physical(HTParentAnchor *me)
{
    return (me->physical);
}

void HTAnchor_setPhysical(HTParentAnchor *me,
			  char *physical)
{
    if (me) {
	StrAllocCopy(me->physical, physical);
    }
}

/*
 *  We store charset info in the HTParentAnchor object, for several
 *  "stages".  (See UCDefs.h)
 *  A stream method is supposed to know what stage in the model it is.
 *
 *  General model	MIME	 ->  parser  ->  structured  ->  HText
 *  e.g., text/html
 *	from HTTP:	HTMIME.c ->  SGML.c  ->  HTML.c      ->  GridText.c
 *     text/plain
 *	from file:	HTFile.c ->  HTPlain.c		     ->  GridText.c
 *
 *  The lock/set_by is used to lock e.g. a charset set by an explicit
 *  HTTP MIME header against overriding by a HTML META tag - the MIME
 *  header has higher priority.  Defaults (from -assume_.. options etc.)
 *  will not override charset explicitly given by server.
 *
 *  Some advantages of keeping this in the HTAnchor:
 *  - Global variables are bad.
 *  - Can remember a charset given by META tag when toggling to SOURCE view.
 *  - Can remember a charset given by <A CHARSET=...> href in another doc.
 *
 *  We don't modify the HTParentAnchor's charset element
 *  here, that one will only be set when explicitly given.
 */
LYUCcharset *HTAnchor_getUCInfoStage(HTParentAnchor *me,
				     int which_stage)
{
    if (me && !me->UCStages) {
	int i;
	int chndl = UCLYhndl_for_unspec;	/* always >= 0 */
	UCAnchorInfo *stages = typecalloc(UCAnchorInfo);

	if (stages == NULL)
	    outofmem(__FILE__, "HTAnchor_getUCInfoStage");
	for (i = 0; i < UCT_STAGEMAX; i++) {
	    stages->s[i].C.MIMEname = "";
	    stages->s[i].LYhndl = -1;
	}
	if (me->charset) {
	    chndl = UCGetLYhndl_byMIME(me->charset);
	    if (chndl < 0)
		chndl = UCLYhndl_for_unrec;
	    if (chndl < 0)
		/*
		 * UCLYhndl_for_unrec not defined :-(
		 * fallback to UCLYhndl_for_unspec which always valid.
		 */
		chndl = UCLYhndl_for_unspec;	/* always >= 0 */
	}
	memcpy(&stages->s[UCT_STAGE_MIME].C, &LYCharSet_UC[chndl],
	       sizeof(LYUCcharset));

	stages->s[UCT_STAGE_MIME].lock = UCT_SETBY_DEFAULT;
	stages->s[UCT_STAGE_MIME].LYhndl = chndl;
	me->UCStages = stages;
    }
    if (me) {
	return (&me->UCStages->s[which_stage].C);
    }
    return (NULL);
}

int HTAnchor_getUCLYhndl(HTParentAnchor *me,
			 int which_stage)
{
    if (me) {
	if (!me->UCStages) {
	    /*
	     * This will allocate and initialize, if not yet done.
	     */
	    (void) HTAnchor_getUCInfoStage(me, which_stage);
	}
	if (me->UCStages->s[which_stage].lock > UCT_SETBY_NONE) {
	    return (me->UCStages->s[which_stage].LYhndl);
	}
    }
    return (-1);
}

#ifdef CAN_SWITCH_DISPLAY_CHARSET
static void setup_switch_display_charset(HTParentAnchor *me, int h)
{
    if (!Switch_Display_Charset(h, SWITCH_DISPLAY_CHARSET_MAYBE))
	return;
    HTAnchor_setUCInfoStage(me, current_char_set,
			    UCT_STAGE_HTEXT, UCT_SETBY_MIME);	/* highest priorty! */
    HTAnchor_setUCInfoStage(me, current_char_set,
			    UCT_STAGE_STRUCTURED, UCT_SETBY_MIME);	/* highest priorty! */
    CTRACE((tfp,
	    "changing UCInfoStage: HTEXT/STRUCTURED stages charset='%s'.\n",
	    LYCharSet_UC[current_char_set].MIMEname));
}
#endif

LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
				     int LYhndl,
				     int which_stage,
				     int set_by)
{
    if (me) {
	/*
	 * This will allocate and initialize, if not yet done.
	 */
	LYUCcharset *p = HTAnchor_getUCInfoStage(me, which_stage);

	/*
	 * Can we override?
	 */
	if (set_by >= me->UCStages->s[which_stage].lock) {
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    int ohandle = me->UCStages->s[which_stage].LYhndl;
#endif
	    me->UCStages->s[which_stage].lock = set_by;
	    me->UCStages->s[which_stage].LYhndl = LYhndl;
	    if (LYhndl >= 0) {
		memcpy(p, &LYCharSet_UC[LYhndl], sizeof(LYUCcharset));

#ifdef CAN_SWITCH_DISPLAY_CHARSET
		/* Allow a switch to a more suitable display charset */
		if (LYhndl != ohandle && which_stage == UCT_STAGE_PARSER)
		    setup_switch_display_charset(me, LYhndl);
#endif
	    } else {
		p->UChndl = -1;
	    }
	    return (p);
	}
    }
    return (NULL);
}

LYUCcharset *HTAnchor_resetUCInfoStage(HTParentAnchor *me,
				       int LYhndl,
				       int which_stage,
				       int set_by)
{
    int ohandle;

    if (!me || !me->UCStages)
	return (NULL);
    me->UCStages->s[which_stage].lock = set_by;
    ohandle = me->UCStages->s[which_stage].LYhndl;
    me->UCStages->s[which_stage].LYhndl = LYhndl;
#ifdef CAN_SWITCH_DISPLAY_CHARSET
    /* Allow a switch to a more suitable display charset */
    if (LYhndl >= 0 && LYhndl != ohandle && which_stage == UCT_STAGE_PARSER)
	setup_switch_display_charset(me, LYhndl);
#endif
    return (&me->UCStages->s[which_stage].C);
}

/*
 *  A set_by of (-1) means use the lock value from the from_stage.
 */
LYUCcharset *HTAnchor_copyUCInfoStage(HTParentAnchor *me,
				      int to_stage,
				      int from_stage,
				      int set_by)
{
    if (me) {
	/*
	 * This will allocate and initialize, if not yet done.
	 */
	LYUCcharset *p_from = HTAnchor_getUCInfoStage(me, from_stage);
	LYUCcharset *p_to = HTAnchor_getUCInfoStage(me, to_stage);

	/*
	 * Can we override?
	 */
	if (set_by == -1)
	    set_by = me->UCStages->s[from_stage].lock;
	if (set_by == UCT_SETBY_NONE)
	    set_by = UCT_SETBY_DEFAULT;
	if (set_by >= me->UCStages->s[to_stage].lock) {
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    int ohandle = me->UCStages->s[to_stage].LYhndl;
#endif
	    me->UCStages->s[to_stage].lock = set_by;
	    me->UCStages->s[to_stage].LYhndl =
		me->UCStages->s[from_stage].LYhndl;
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Allow a switch to a more suitable display charset */
	    if (me->UCStages->s[to_stage].LYhndl >= 0
		&& me->UCStages->s[to_stage].LYhndl != ohandle
		&& to_stage == UCT_STAGE_PARSER)
		setup_switch_display_charset(me,
					     me->UCStages->s[to_stage].LYhndl);
#endif
	    if (p_to != p_from)
		memcpy(p_to, p_from, sizeof(LYUCcharset));

	    return (p_to);
	}
    }
    return (NULL);
}
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 13
a14 13
**	==========================
**
** An anchor represents a region of a hypertext document which is linked to
** another anchor in the same or a different document.
**
** History
**
**	   Nov 1990  Written in Objective-C for the NeXT browser (TBL)
**	24-Oct-1991 (JFG), written in C, browser-independent
**	21-Nov-1991 (JFG), first complete version
**
**	(c) Copyright CERN 1991 - See Copyright.html
*/
d42 1
a42 2
static int HASH_FUNCTION (
	const char *	cp_address)
d47 2
a48 2
    for (p = (const unsigned char *)cp_address, hash = 0; *p; p++)
	hash = (int) (hash * 3 + (*(const unsigned char *)p)) % HASH_SIZE;
d50 1
a50 1
    return(hash);
d54 1
d57 1
a57 1
	int junk;	/* VMS cannot handle pointers to undefined structs */
d62 3
a64 2
static HTList adult_table[HASH_SIZE] = { {NULL, NULL} };

d67 8
a74 9
**				================
**
**	Do not use "new" by itself outside this module.  In order to enforce
**	consistency, we insist that you furnish more information about the
**	anchor you are creating : use newWithParent or newWithAddress.
*/
static HTParentAnchor0 * HTParentAnchor0_new (
	const char *	address,
	short		hash)
d77 1
d85 1
a85 1
    return(newAnchor);
d88 1
a88 2
static HTParentAnchor * HTParentAnchor_new (
	HTParentAnchor0 *	parent)
d91 1
d95 3
a97 3
    newAnchor->parent = parent;		/* cross reference */
    parent->info = newAnchor;		/* cross reference */
    newAnchor->address = parent->address;  /* copy pointer */
d100 2
a101 2
    newAnchor->isHEAD = FALSE;		/* HEAD request if TRUE. - FM */
    newAnchor->safe = FALSE;		/* Safe. - FM */
d103 1
a103 1
    newAnchor->inBASE = FALSE;		/* duplicated from HTML.c/h */
d105 1
a105 1
    return(newAnchor);
d108 1
a108 2
static HTChildAnchor * HTChildAnchor_new (
	HTParentAnchor0 *	parent)
d111 1
d119 1
a119 2
static HTChildAnchor * HText_pool_ChildAnchor_new (
	HTParentAnchor *	parent)
d121 3
a123 2
    HTChildAnchor *p = (HTChildAnchor *)HText_pool_calloc((HText*)(parent->document),
						sizeof(HTChildAnchor));
d140 10
a149 11
**	---------------------------------
** On entry,
**	s	Points to one string, null terminated
**	t	points to the other.
** On exit,
**	returns YES if the strings are equivalent
**		NO if they differ.
*/
static BOOL HTSEquivalent (
	const char *	s,
	const char *	t)
d151 1
a151 1
    if (s && t) {  /* Make sure they point to something */
d154 1
a154 1
		return(NO);
d157 1
a157 1
	return(HT_EQUIV(*s, *t));
d159 1
a159 1
	return(s == t);		/* Two NULLs are equivalent, aren't they ? */
d164 10
a173 11
**	------------------------
** On entry,
**	s	Points to one bstring
**	t	points to the other.
** On exit,
**	returns YES if the strings are equivalent
**		NO if they differ.
*/
static BOOL HTBEquivalent (
	const bstring *	s,
	const bstring *	t)
d178 1
d181 1
a181 1
		return(NO);
d184 1
a184 1
	return(YES);
d186 1
a186 1
	return(s == t);		/* Two NULLs are equivalent, aren't they ? */
d191 1
a191 1
 *  Three-way compare function
d193 2
a194 3
static int compare_anchors (
	void * l,
	void * r)
d196 3
a198 2
    const char* a = ((HTChildAnchor *)l)->tag;
    const char* b = ((HTChildAnchor *)r)->tag;
d202 1
a202 1
	return strcasecomp(a, b); /* Case insensitive */
d204 1
a204 1
	return strcmp(a, b);      /* Case sensitive - FM */
a207 1

d209 7
a215 8
**	---------------------------------
**
**	This one is for a named child.
**	The parent anchor must already exist.
*/
static HTChildAnchor * HTAnchor_findNamedChild (
	HTParentAnchor0 *	parent,
	const char *		tag)
d219 1
a219 1
    if (parent && tag && *tag) {  /* TBL */
d222 2
a223 2
	    **  Parent has children.  Search them.
	    */
a224 1
	    sample.tag = (char*)tag;    /* for compare_anchors() only */
d226 3
a228 1
	    child = (HTChildAnchor *)HTBTree_search(parent->children, &sample);
d230 4
a233 3
		CTRACE((tfp, "Child anchor %p of parent %p with name `%s' already exists.\n",
				(void *)child, (void *)parent, tag));
		return(child);
d235 1
a235 1
	} else {  /* parent doesn't have any children yet : create family */
d241 1
a241 1
		(void *)child,
d243 1
a243 1
		(void *)child->parent));
d245 1
a245 1
	StrAllocCopy(child->tag, tag);   /* should be set before HTBTree_add */
d247 1
a247 1
	return(child);
d251 1
a251 1
	return(NULL);
d257 5
a261 6
**	This one is for a new unnamed child being edited into an existing
**	document.  The parent anchor and the document must already exist.
**	(Just add new unnamed child).
*/
static HTChildAnchor * HTAnchor_addChild (
	HTParentAnchor *	parent)
d267 1
a267 1
	return(NULL);
d272 2
a273 2
		(void *)child,
		(void *)child->parent));
d278 1
a278 1
    return(child);
d281 1
d283 3
a285 7
static HTParentAnchor0 * HTAnchor_findAddress_in_adult_table (
	const DocAddress *	newdoc);

static BOOL HTAnchor_link (
	HTChildAnchor *		child,
	HTAnchor *		destination,
	HTLinkType *		type);
d287 13
d301 4
a304 18
/*	Create or find a child anchor with a possible link
**	--------------------------------------------------
**
**	Create new anchor with a given parent and possibly
**	a name, and possibly a link to a _relatively_ named anchor.
**	(Code originally in ParseHTML.h)
*/
HTChildAnchor * HTAnchor_findChildAndLink (
	HTParentAnchor *	parent, /* May not be 0   */
	const char *		tag,	/* May be "" or 0 */
	const char *		href,	/* May be "" or 0 */
	HTLinkType *		ltype)	/* May be 0	  */
{
    HTChildAnchor * child;
    CTRACE((tfp,"Entered HTAnchor_findChildAndLink:  tag=`%s',%s href=`%s'\n",
	       NonNull(tag),
	       (ltype == HTInternalLink) ? " (internal link)" : "",
	       NonNull(href) ));
d314 1
a314 1
	HTParentAnchor0 * dest;
d320 1
a320 1
				parent->content_base : parent->address;
d322 1
d344 5
a348 5
	** [from HTAnchor_findAddress()]
	** If the address represents a sub-anchor, we load its parent (above),
	** then we create a named child anchor within that parent.
	*/
	fragment = (*href == '#') ?  href+1 : HTParseAnchor(href);
d351 1
a351 2
	    dest = (HTParentAnchor0 *)HTAnchor_findNamedChild(dest, fragment);

d354 1
a354 1
	    if (child->dest) { /* DUPLICATE_ANCHOR_NAME_WORKAROUND  - kw */
d356 3
a358 3
			   "*** Duplicate ChildAnchor %p named `%s'",
			   child, tag));
		if ((HTAnchor *)dest != child->dest || ltype != child->type) {
d360 2
a361 2
			   ", different dest %p or type, creating unnamed child\n",
			   child->dest));
d366 1
a366 1
	HTAnchor_link(child, (HTAnchor *)dest, ltype);
a370 1

d372 8
a379 9
**	------------------------------------
**
**	Me one is for a reference which is found in a document, and might
**	not be already loaded.
**	Note: You are not guaranteed a new anchor -- you might get an old one,
**	like with fonts.
*/
HTParentAnchor * HTAnchor_findAddress (
	const DocAddress *	newdoc)
d384 1
a384 1
    CTRACE((tfp,"Entered HTAnchor_findAddress\n"));
d387 3
a389 3
    **	If the address represents a sub-anchor, we load its parent,
    **	then we create a named child anchor within that parent.
    */
d392 2
a393 2
	HTParentAnchor0 * foundParent;
	HTChildAnchor * foundAnchor;
d404 1
a404 1
	foundAnchor = HTAnchor_findNamedChild (foundParent, tag);
d406 1
a406 1
	return HTAnchor_parent((HTAnchor *)foundParent);
d408 1
a408 1
    return HTAnchor_parent((HTAnchor *)HTAnchor_findAddress_in_adult_table(newdoc));
a410 1

d413 1
a413 2
static HTParentAnchor0 * HTAnchor_findAddress_in_adult_table (
	const DocAddress *	newdoc)
d416 2
a417 2
    **  Check whether we have this node.
    */
d419 1
a419 1
    HTList * adults;
d421 1
a421 1
    HTParentAnchor0 * foundAnchor;
d423 1
a423 1
		newdoc->bookmark || newdoc->isHEAD || newdoc->safe);
d426 3
a428 3
     *  We need not free adult_table[] atexit -
     *  it should be perfectly empty after free'ing all HText's.
     *  (There is an error if it is not empty at exit). -LP
d432 2
a433 2
    **  Select list from hash table,
    */
d438 2
a439 2
    **  Search list for anchor.
    */
d442 1
a442 1
		    (HTParentAnchor0 *)HTList_nextObject(grownups))) {
d448 1
a448 2
	      foundAnchor->info->isHEAD == newdoc->isHEAD)))
	{
d450 1
a450 1
			(void *)foundAnchor, newdoc->address));
d456 2
a457 2
    **  Node not found: create new anchor.
    */
d460 1
a460 1
		(void *)foundAnchor, hash, newdoc->address));
d470 1
a470 1
		     newdoc->post_content_type);
d482 6
a487 7
**	-------------------------------------------------
**
**     Like HTAnchor_findAddress, but simpler to use for simple cases.
**	No post data etc. can be supplied. - kw
*/
HTParentAnchor * HTAnchor_findSimpleAddress (
	const char *	url)
d491 1
a491 1
    urldoc.address = (char *)url; /* ignore warning, it IS treated like const - kw */
a499 1

d501 5
a505 6
**	-------------------------------------
*/
static BOOL HTAnchor_link (
	HTChildAnchor *	child,
	HTAnchor *		destination,
	HTLinkType *		type)
d508 1
a508 1
	return(NO);  /* Can't link to/from non-existing anchor */
d513 1
a513 1
	return(NO);
d523 1
a523 1
    return(YES);  /* Success */
a525 1

d527 8
a534 8
**	--------------------------------------------
**
**	The anchor is only deleted if the corresponding document is not loaded.
**	All outgoing links from children are deleted, and children are
**	removed from the sources lists of theirs targets.
**	We also try to delete the targets whose documents are not loaded.
**	If this anchor's sources list is empty, we delete it and its children.
*/
d541 1
a541 2
static void deleteLinks (
	HTChildAnchor *	me)
d544 1
a544 1
     *	Unregister me with our destination anchor's parent.
d550 1
a550 1
	 *  Start.  Set the dest pointer to zero.
d552 1
a552 1
	 me->dest = NULL;
d555 2
a556 2
	 *  Remove me from the parent's sources so that the
	 *  parent knows one less anchor is its dest.
d560 1
a560 1
	     *	Really should only need to deregister once.
d562 1
a562 1
	    HTList_unlinkObject(&parent->sources, (void *)me);
d566 2
a567 3
	 *  Recursive call.
	 *  Test here to avoid calling overhead.
	 *  Don't delete if document is loaded or being loaded.
d575 3
a577 4
	 *  At this point, we haven't a destination.  Set it to be
	 *  so.
	 *  Leave the HTAtom pointed to by type up to other code to
	 *  handle (reusable, near static).
d583 1
d585 1
a585 5
static void HTParentAnchor_free (
	HTParentAnchor *	me);

BOOL HTAnchor_delete (
	HTParentAnchor0 *	me)
d588 1
a588 1
     *	Memory leaks fixed.
d595 1
a595 1
     *	Do nothing if nothing to do.
d598 1
a598 1
	return(NO);
d602 1
a602 1
     *	Don't delete if document is loaded or being loaded.
d605 1
a605 1
	return(NO);
d609 2
a610 2
     *  Mark ourselves busy, so that recursive calls of this function
     *  on this HTParentAnchor0 will not free it from under our feet. - kw
d616 2
a617 2
	 *  Delete all outgoing links from named children.
	 *  Do not delete named children itself (may have incoming links).
d622 1
a622 1
		child = (HTChildAnchor *)HTBTree_object(ele);
a630 1

d637 1
a637 1
	 *  Can't delete parent, still have sources.
d639 1
a639 1
	return(NO);
d643 2
a644 2
     *	No more incoming and outgoing links : kill everything
     *	First, delete named children.
d649 1
a649 1
	    child = (HTChildAnchor *)HTBTree_object(ele);
d658 1
a658 1
     *  Delete the ParentAnchor, if any. (Document was already deleted).
d666 1
a666 1
     *	Remove ourselves from the hash table's list.
d668 1
a668 1
    HTList_unlinkObject(&(adult_table[me->adult_hash]), (void *)me);
d671 1
a671 1
     *	Free the address.
d676 1
a676 1
     *	Finally, kill the parent anchor passed in.
d680 1
a680 1
    return(YES);
d684 3
a686 3
 *  Unnamed children (children_notag) have no sence without HText -
 *  delete them and their links if we are about to free HText.
 *  Document currently exists. Called within HText_free().
d688 1
a688 2
void HTAnchor_delete_links (
	HTParentAnchor *	me)
d694 1
a694 1
     *	Do nothing if nothing to do.
d701 2
a702 2
     *  Mark ourselves busy, so that recursive calls
     *  on this HTParentAnchor0 will not free it from under our feet. - kw
d707 1
a707 1
     *  Delete all outgoing links from unnamed children.
d712 1
a712 1
		(HTChildAnchor *)HTList_unlinkLastObject(cur)) != 0) {
d714 1
a714 1
	    /* child allocated in HText pool, HText_free() will free it later*/
d720 1
a720 3

static void HTParentAnchor_free (
	HTParentAnchor *	me)
d723 1
a723 1
     *	Delete the methods list.
d727 2
a728 2
	 *  Leave what the methods point to up in memory for
	 *  other code (near static stuff).
d735 1
a735 1
     *	Free up all allocated members.
d753 1
d762 4
d786 4
a789 4
     *	Original code wanted a way to clean out the HTFormat if no
     *	longer needed (ref count?).  I'll leave it alone since
     *	those HTAtom objects are a little harder to know where
     *	they are being referenced all at one time. (near static)
d797 1
a797 2
void HTAnchor_clearSourceCache (
	HTParentAnchor *	me)
d804 1
a804 1
	       me->source_cache_file));
d810 1
a810 1
	       (void *)me->source_cache_chunk));
d818 3
a820 4
**	---------------------
*/
HTParentAnchor * HTAnchor_parent (
	HTAnchor *	me)
d832 2
a833 3
void HTAnchor_setDocument (
	HTParentAnchor *	me,
	HyperDoc *		doc)
d839 1
a839 2
HyperDoc * HTAnchor_document (
	HTParentAnchor *	me)
d841 1
a841 1
    return( me ? me->document : NULL);
d844 1
a844 3

char * HTAnchor_address (
	HTAnchor *	me)
d849 3
a851 3
	if (((HTParentAnchor0 *)me == me->parent) ||
	    ((HTParentAnchor *)me == me->parent->info) ||
	    !((HTChildAnchor *)me)->tag) {  /* it's an adult or no tag */
d853 1
a853 1
	} else {  /* it's a named child */
d855 1
a855 1
		       me->parent->address, ((HTChildAnchor *)me)->tag);
d858 1
a858 1
    return(addr);
d861 2
a862 3
void HTAnchor_setFormat (
	HTParentAnchor *	me,
	HTFormat		form)
d868 1
a868 2
HTFormat HTAnchor_format (
	HTParentAnchor *	me)
d870 1
a870 1
    return( me ? me->format : NULL);
d873 2
a874 3
void HTAnchor_setIndex (
	HTParentAnchor *	me,
	const char *		address)
d882 2
a883 3
void HTAnchor_setPrompt (
	HTParentAnchor *	me,
	const char *		prompt)
d890 1
a890 2
BOOL HTAnchor_isIndex (
	HTParentAnchor *	me)
d892 1
a892 1
    return( me ? me->isIndex : NO);
d896 3
a898 4
**	(normally by presence of an ISMAP attribute on A or IMG) - KW
*/
BOOL HTAnchor_isISMAPScript (
	HTAnchor *	me)
d900 1
a900 1
    return( (me && me->parent->info) ? me->parent->info->isISMAPScript : NO);
d906 1
a906 2
const char * HTAnchor_style (
	HTParentAnchor *	me)
d908 1
a908 1
	return( me ? me->style : NULL);
d911 2
a912 3
void HTAnchor_setStyle (
	HTParentAnchor *	me,
	const char *		style)
a919 1

d922 1
a922 2
const char * HTAnchor_title (
	HTParentAnchor *	me)
d924 1
a924 1
    return( me ? me->title : NULL);
d927 2
a928 3
void HTAnchor_setTitle (
	HTParentAnchor *	me,
	const char *		title)
d942 1
a942 1
	    CTRACE((tfp,"HTAnchor_setTitle: New title is NULL! "));
d944 1
a944 1
		CTRACE((tfp,"Old title was \"%s\".\n", me->title));
d947 1
a947 1
		CTRACE((tfp,"Old title was NULL.\n"));
d953 2
a954 3
void HTAnchor_appendTitle (
	HTParentAnchor *	me,
	const char *		title)
d971 1
a971 2
const char * HTAnchor_bookmark (
	HTParentAnchor *	me)
d973 1
a973 1
    return( me ? me->bookmark : NULL);
d976 2
a977 3
void HTAnchor_setBookmark (
	HTParentAnchor *	me,
	const char *		bookmark)
d985 1
a985 2
const char * HTAnchor_owner (
	HTParentAnchor *	me)
d987 1
a987 1
    return( me ? me->owner : NULL);
d990 2
a991 3
void HTAnchor_setOwner (
	HTParentAnchor *	me,
	const char *		owner)
d1000 1
a1000 2
const char * HTAnchor_RevTitle (
	HTParentAnchor *	me)
d1002 1
a1002 1
    return( me ? me->RevTitle : NULL);
d1005 2
a1006 3
void HTAnchor_setRevTitle (
	HTParentAnchor *	me,
	const char *		title)
d1024 1
a1024 2
const char * HTAnchor_citehost (
	HTParentAnchor *	me)
d1026 1
a1026 1
    return( me ? me->citehost : NULL);
d1029 2
a1030 3
void HTAnchor_setCitehost (
	HTParentAnchor *	me,
	const char *		citehost)
d1039 18
a1056 2
**	(will be loaded if we had a Content-Disposition
**	 header or META element with filename=name.suffix)
d1058 1
a1058 2
const char * HTAnchor_SugFname (
	HTParentAnchor *	me)
d1060 1
a1060 1
    return( me ? me->SugFname : NULL);
d1064 4
a1067 5
**	(will be loaded if we had a Content-Encoding
**	 header.)
*/
const char * HTAnchor_content_encoding (
	HTParentAnchor *	me)
d1069 1
a1069 1
    return( me ? me->content_encoding : NULL);
d1074 1
a1074 2
const char * HTAnchor_content_type (
	HTParentAnchor *	me)
d1076 1
a1076 1
    return( me ? me->content_type : NULL);
d1081 1
a1081 2
const char * HTAnchor_last_modified (
	HTParentAnchor *	me)
d1083 1
a1083 1
    return( me ? me->last_modified : NULL);
d1088 1
a1088 2
const char * HTAnchor_date (
	HTParentAnchor *	me)
d1090 1
a1090 1
    return( me ? me->date : NULL);
d1095 1
a1095 2
const char * HTAnchor_server (
	HTParentAnchor *	me)
d1097 1
a1097 1
    return( me ? me->server : NULL);
d1102 1
a1102 2
BOOL HTAnchor_safe (
	HTParentAnchor *	me)
d1104 1
a1104 1
    return (BOOL) ( me ? me->safe : FALSE);
d1109 1
a1109 2
const char * HTAnchor_content_base (
	HTParentAnchor *	me)
d1111 1
a1111 1
    return( me ? me->content_base : NULL);
d1116 1
a1116 2
const char * HTAnchor_content_location (
	HTParentAnchor *	me)
d1118 1
a1118 1
    return( me ? me->content_location : NULL);
d1123 1
a1123 2
const char * HTAnchor_messageID (
	HTParentAnchor *	me)
d1125 1
a1125 1
    return( me ? me->message_id : NULL);
d1128 2
a1129 3
BOOL HTAnchor_setMessageID (
	HTParentAnchor *	me,
	const char *		messageid)
d1140 1
a1140 2
const char * HTAnchor_subject (
	HTParentAnchor *	me)
d1142 1
a1142 1
    return( me ? me->subject : NULL);
d1145 2
a1146 3
BOOL HTAnchor_setSubject (
	HTParentAnchor *	me,
	const char *		subject)
d1156 3
a1158 4
**	---------------------
*/
HTAnchor * HTAnchor_followLink (
	HTChildAnchor *	me)
d1160 1
a1160 1
    return( me->dest);
d1163 2
a1164 3
HTAnchor * HTAnchor_followTypedLink (
	HTChildAnchor *	me,
	HTLinkType *		type)
d1167 2
a1168 2
	return( me->dest);
    return(NULL);  /* No link of me type */
a1170 1

d1172 3
a1174 4
**	------------
*/
HTList * HTAnchor_methods (
	HTParentAnchor *	me)
d1179 1
a1179 1
    return( me->methods);
d1183 3
a1185 4
**	--------
*/
void * HTAnchor_protocol (
	HTParentAnchor *	me)
d1187 1
a1187 1
    return( me->protocol);
d1190 2
a1191 3
void HTAnchor_setProtocol (
	HTParentAnchor *	me,
	void*			protocol)
d1197 3
a1199 4
**	----------------
*/
char * HTAnchor_physical (
	HTParentAnchor *	me)
d1201 1
a1201 1
    return( me->physical);
d1204 2
a1205 3
void HTAnchor_setPhysical (
	HTParentAnchor *	me,
	char *			physical)
d1213 25
a1237 26
**  We store charset info in the HTParentAnchor object, for several
**  "stages".  (See UCDefs.h)
**  A stream method is supposed to know what stage in the model it is.
**
**  General model	MIME	 ->  parser  ->  structured  ->  HText
**  e.g., text/html
**	from HTTP:	HTMIME.c ->  SGML.c  ->  HTML.c      ->  GridText.c
**     text/plain
**	from file:	HTFile.c ->  HTPlain.c		     ->  GridText.c
**
**  The lock/set_by is used to lock e.g. a charset set by an explicit
**  HTTP MIME header against overriding by a HTML META tag - the MIME
**  header has higher priority.  Defaults (from -assume_.. options etc.)
**  will not override charset explicitly given by server.
**
**  Some advantages of keeping this in the HTAnchor:
**  - Global variables are bad.
**  - Can remember a charset given by META tag when toggling to SOURCE view.
**  - Can remember a charset given by <A CHARSET=...> href in another doc.
**
**  We don't modify the HTParentAnchor's charset element
**  here, that one will only be set when explicitly given.
*/
LYUCcharset * HTAnchor_getUCInfoStage (
	HTParentAnchor *	me,
	int			which_stage)
d1241 3
a1243 2
	int chndl = UCLYhndl_for_unspec;  /* always >= 0 */
	UCAnchorInfo * stages = typecalloc(UCAnchorInfo);
d1256 4
a1259 4
		**  UCLYhndl_for_unrec not defined :-(
		**  fallback to UCLYhndl_for_unspec which always valid.
		*/
		chndl = UCLYhndl_for_unspec;  /* always >= 0 */
d1263 1
d1269 1
a1269 1
	return( &me->UCStages->s[which_stage].C);
d1271 1
a1271 1
    return(NULL);
d1274 2
a1275 3
int HTAnchor_getUCLYhndl (
	HTParentAnchor *	me,
	int			which_stage)
d1280 1
a1280 1
	     *	This will allocate and initialize, if not yet done.
d1285 1
a1285 1
	    return( me->UCStages->s[which_stage].LYhndl);
d1288 1
a1288 1
    return( -1);
d1292 1
a1292 1
static void setup_switch_display_charset (HTParentAnchor * me, int h)
d1294 1
a1294 1
    if (!Switch_Display_Charset(h,SWITCH_DISPLAY_CHARSET_MAYBE))
d1297 1
a1297 1
			    UCT_STAGE_HTEXT, UCT_SETBY_MIME); /* highest priorty! */
d1299 3
a1301 2
			    UCT_STAGE_STRUCTURED, UCT_SETBY_MIME); /* highest priorty! */
    CTRACE((tfp, "changing UCInfoStage: HTEXT/STRUCTURED stages charset='%s'.\n",
d1306 4
a1309 5
LYUCcharset * HTAnchor_setUCInfoStage (
	HTParentAnchor *	me,
	int			LYhndl,
	int			which_stage,
	int			set_by)
d1313 1
a1313 1
	 *  This will allocate and initialize, if not yet done.
d1315 2
a1316 1
	LYUCcharset * p = HTAnchor_getUCInfoStage(me, which_stage);
d1318 1
a1318 1
	 *  Can we override?
d1328 1
d1331 1
a1331 1
		if ( LYhndl != ohandle && which_stage == UCT_STAGE_PARSER )
d1334 1
a1334 2
	    }
	    else {
d1337 1
a1337 1
	    return(p);
d1340 1
a1340 1
    return(NULL);
d1343 4
a1346 5
LYUCcharset * HTAnchor_resetUCInfoStage (
	HTParentAnchor *	me,
	int			LYhndl,
	int			which_stage,
	int			set_by)
d1351 1
a1351 1
	return(NULL);
d1360 1
a1360 1
    return( &me->UCStages->s[which_stage].C);
d1364 6
a1369 7
**  A set_by of (-1) means use the lock value from the from_stage.
*/
LYUCcharset * HTAnchor_copyUCInfoStage (
	HTParentAnchor *	me,
	int			to_stage,
	int			from_stage,
	int			set_by)
d1373 1
a1373 1
	 *  This will allocate and initialize, if not yet done.
d1375 3
a1377 2
	LYUCcharset * p_from = HTAnchor_getUCInfoStage(me, from_stage);
	LYUCcharset * p_to = HTAnchor_getUCInfoStage(me, to_stage);
d1379 1
a1379 1
	 *  Can we override?
d1394 3
a1396 3
	    if ( me->UCStages->s[to_stage].LYhndl >= 0
		 && me->UCStages->s[to_stage].LYhndl != ohandle
		 && to_stage == UCT_STAGE_PARSER )
d1402 2
a1403 1
	    return(p_to);
d1406 1
a1406 1
    return(NULL);
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d42 2
a43 2
PRIVATE int HASH_FUNCTION ARGS1(
	CONST char *,	cp_address)
d46 1
a46 1
    CONST unsigned char *p;
d48 2
a49 2
    for (p = (CONST unsigned char *)cp_address, hash = 0; *p; p++)
	hash = (int) (hash * 3 + (*(CONST unsigned char *)p)) % HASH_SIZE;
d62 1
a62 1
PRIVATE HTList adult_table[HASH_SIZE] = { {NULL, NULL} };
d72 3
a74 3
PRIVATE HTParentAnchor0 * HTParentAnchor0_new ARGS2(
	CONST char *,	address,
	short,		hash)
d87 2
a88 2
PRIVATE HTParentAnchor * HTParentAnchor_new ARGS1(
	HTParentAnchor0 *,	parent)
d107 2
a108 2
PRIVATE HTChildAnchor * HTChildAnchor_new ARGS1(
	HTParentAnchor0 *,	parent)
d118 2
a119 2
PRIVATE HTChildAnchor * HText_pool_ChildAnchor_new ARGS1(
	HTParentAnchor *,	parent)
d147 3
a149 3
PRIVATE BOOL HTSEquivalent ARGS2(
	CONST char *,	s,
	CONST char *,	t)
d172 3
a174 3
PRIVATE BOOL HTBEquivalent ARGS2(
	CONST bstring *,	s,
	CONST bstring *,	t)
d193 3
a195 3
PRIVATE int compare_anchors ARGS2(
	void *, l,
	void *, r)
d197 2
a198 2
    CONST char* a = ((HTChildAnchor *)l)->tag;
    CONST char* b = ((HTChildAnchor *)r)->tag;
d215 3
a217 3
PRIVATE HTChildAnchor * HTAnchor_findNamedChild ARGS2(
	HTParentAnchor0 *,	parent,
	CONST char *,		tag)
d261 2
a262 2
PRIVATE HTChildAnchor * HTAnchor_addChild ARGS1(
	HTParentAnchor *,	parent)
d283 2
a284 2
PRIVATE HTParentAnchor0 * HTAnchor_findAddress_in_adult_table PARAMS((
	CONST DocAddress *	newdoc));
d286 1
a286 1
PRIVATE BOOL HTAnchor_link PARAMS((
d289 1
a289 1
	HTLinkType *		type));
d299 5
a303 5
PUBLIC HTChildAnchor * HTAnchor_findChildAndLink ARGS4(
	HTParentAnchor *,	parent, /* May not be 0   */
	CONST char *,		tag,	/* May be "" or 0 */
	CONST char *,		href,	/* May be "" or 0 */
	HTLinkType *,		ltype)	/* May be 0	  */
d318 1
a318 1
	CONST char *fragment = NULL;
d324 1
a324 1
	    CONST char *relative_to = (parent->inBASE && *href != '#') ?
d385 2
a386 2
PUBLIC HTParentAnchor * HTAnchor_findAddress ARGS1(
	CONST DocAddress *,	newdoc)
d389 1
a389 1
    CONST char *tag = HTParseAnchor(newdoc->address);
d421 2
a422 2
PRIVATE HTParentAnchor0 * HTAnchor_findAddress_in_adult_table ARGS1(
	CONST DocAddress *,	newdoc)
d497 2
a498 2
PUBLIC HTParentAnchor * HTAnchor_findSimpleAddress ARGS1(
	CONST char *,	url)
d515 4
a518 4
PRIVATE BOOL HTAnchor_link ARGS3(
	HTChildAnchor *,	child,
	HTAnchor *,		destination,
	HTLinkType *,		type)
d555 2
a556 2
PRIVATE void deleteLinks ARGS1(
	HTChildAnchor *,	me)
d601 2
a602 2
PRIVATE void HTParentAnchor_free PARAMS((
	HTParentAnchor *	me));
d604 2
a605 2
PUBLIC BOOL HTAnchor_delete ARGS1(
	HTParentAnchor0 *,	me)
d709 2
a710 2
PUBLIC void HTAnchor_delete_links ARGS1(
	HTParentAnchor *,	me)
d743 2
a744 2
PRIVATE void HTParentAnchor_free ARGS1(
	HTParentAnchor *,	me)
d816 2
a817 2
PUBLIC void HTAnchor_clearSourceCache ARGS1(
	HTParentAnchor *,	me)
d840 2
a841 2
PUBLIC HTParentAnchor * HTAnchor_parent ARGS1(
	HTAnchor *,	me)
d853 3
a855 3
PUBLIC void HTAnchor_setDocument ARGS2(
	HTParentAnchor *,	me,
	HyperDoc *,		doc)
d861 2
a862 2
PUBLIC HyperDoc * HTAnchor_document ARGS1(
	HTParentAnchor *,	me)
d868 2
a869 2
PUBLIC char * HTAnchor_address ARGS1(
	HTAnchor *,	me)
d886 3
a888 3
PUBLIC void HTAnchor_setFormat ARGS2(
	HTParentAnchor *,	me,
	HTFormat,		form)
d894 2
a895 2
PUBLIC HTFormat HTAnchor_format ARGS1(
	HTParentAnchor *,	me)
d900 3
a902 3
PUBLIC void HTAnchor_setIndex ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		address)
d910 3
a912 3
PUBLIC void HTAnchor_setPrompt ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		prompt)
d919 2
a920 2
PUBLIC BOOL HTAnchor_isIndex ARGS1(
	HTParentAnchor *,	me)
d928 2
a929 2
PUBLIC BOOL HTAnchor_isISMAPScript ARGS1(
	HTAnchor *,	me)
d937 2
a938 2
PUBLIC CONST char * HTAnchor_style ARGS1(
	HTParentAnchor *,	me)
d943 3
a945 3
PUBLIC void HTAnchor_setStyle ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		style)
d956 2
a957 2
PUBLIC CONST char * HTAnchor_title ARGS1(
	HTParentAnchor *,	me)
d962 3
a964 3
PUBLIC void HTAnchor_setTitle ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		title)
d989 3
a991 3
PUBLIC void HTAnchor_appendTitle ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		title)
d1008 2
a1009 2
PUBLIC CONST char * HTAnchor_bookmark ARGS1(
	HTParentAnchor *,	me)
d1014 3
a1016 3
PUBLIC void HTAnchor_setBookmark ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		bookmark)
d1024 2
a1025 2
PUBLIC CONST char * HTAnchor_owner ARGS1(
	HTParentAnchor *,	me)
d1030 3
a1032 3
PUBLIC void HTAnchor_setOwner ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		owner)
d1041 2
a1042 2
PUBLIC CONST char * HTAnchor_RevTitle ARGS1(
	HTParentAnchor *,	me)
d1047 3
a1049 3
PUBLIC void HTAnchor_setRevTitle ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		title)
d1067 2
a1068 2
PUBLIC CONST char * HTAnchor_citehost ARGS1(
	HTParentAnchor *,	me)
d1073 3
a1075 3
PUBLIC void HTAnchor_setCitehost ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		citehost)
d1087 2
a1088 2
PUBLIC CONST char * HTAnchor_SugFname ARGS1(
	HTParentAnchor *,	me)
d1097 2
a1098 2
PUBLIC CONST char * HTAnchor_content_encoding ARGS1(
	HTParentAnchor *,	me)
d1105 2
a1106 2
PUBLIC CONST char * HTAnchor_content_type ARGS1(
	HTParentAnchor *,	me)
d1113 2
a1114 2
PUBLIC CONST char * HTAnchor_last_modified ARGS1(
	HTParentAnchor *,	me)
d1121 2
a1122 2
PUBLIC CONST char * HTAnchor_date ARGS1(
	HTParentAnchor *,	me)
d1129 2
a1130 2
PUBLIC CONST char * HTAnchor_server ARGS1(
	HTParentAnchor *,	me)
d1137 2
a1138 2
PUBLIC BOOL HTAnchor_safe ARGS1(
	HTParentAnchor *,	me)
d1145 2
a1146 2
PUBLIC CONST char * HTAnchor_content_base ARGS1(
	HTParentAnchor *,	me)
d1153 2
a1154 2
PUBLIC CONST char * HTAnchor_content_location ARGS1(
	HTParentAnchor *,	me)
d1161 2
a1162 2
PUBLIC CONST char * HTAnchor_messageID ARGS1(
	HTParentAnchor *,	me)
d1167 3
a1169 3
PUBLIC BOOL HTAnchor_setMessageID ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		messageid)
d1180 2
a1181 2
PUBLIC CONST char * HTAnchor_subject ARGS1(
	HTParentAnchor *,	me)
d1186 3
a1188 3
PUBLIC BOOL HTAnchor_setSubject ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		subject)
d1200 2
a1201 2
PUBLIC HTAnchor * HTAnchor_followLink ARGS1(
	HTChildAnchor *,	me)
d1206 3
a1208 3
PUBLIC HTAnchor * HTAnchor_followTypedLink ARGS2(
	HTChildAnchor *,	me,
	HTLinkType *,		type)
d1219 2
a1220 2
PUBLIC HTList * HTAnchor_methods ARGS1(
	HTParentAnchor *,	me)
d1231 2
a1232 2
PUBLIC void * HTAnchor_protocol ARGS1(
	HTParentAnchor *,	me)
d1237 3
a1239 3
PUBLIC void HTAnchor_setProtocol ARGS2(
	HTParentAnchor *,	me,
	void*,			protocol)
d1247 2
a1248 2
PUBLIC char * HTAnchor_physical ARGS1(
	HTParentAnchor *,	me)
d1253 3
a1255 3
PUBLIC void HTAnchor_setPhysical ARGS2(
	HTParentAnchor *,	me,
	char *,			physical)
d1286 3
a1288 3
PUBLIC LYUCcharset * HTAnchor_getUCInfoStage ARGS2(
	HTParentAnchor *,	me,
	int,			which_stage)
d1323 3
a1325 3
PUBLIC int HTAnchor_getUCLYhndl ARGS2(
	HTParentAnchor *,	me,
	int,			which_stage)
d1342 1
a1342 1
PRIVATE void setup_switch_display_charset ARGS2(HTParentAnchor *, me, int, h)
d1355 5
a1359 5
PUBLIC LYUCcharset * HTAnchor_setUCInfoStage ARGS4(
	HTParentAnchor *,	me,
	int,			LYhndl,
	int,			which_stage,
	int,			set_by)
d1392 5
a1396 5
PUBLIC LYUCcharset * HTAnchor_resetUCInfoStage ARGS4(
	HTParentAnchor *,	me,
	int,			LYhndl,
	int,			which_stage,
	int,			set_by)
d1416 5
a1420 5
PUBLIC LYUCcharset * HTAnchor_copyUCInfoStage ARGS4(
	HTParentAnchor *,	me,
	int,			to_stage,
	int,			from_stage,
	int,			set_by)
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d772 1
a772 1
#ifdef SOURCE_CACHE
d815 1
a815 1
#ifdef SOURCE_CACHE
d835 1
a835 1
#endif /* SOURCE_CACHE */
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d21 1
d25 2
d61 3
a63 1
PRIVATE HTList **adult_table = 0;  /* Point to table of lists of all parents */
d72 3
a74 1
PRIVATE HTParentAnchor * HTParentAnchor_new NOARGS
d76 15
a90 2
    HTParentAnchor *newAnchor =
       (HTParentAnchor *)calloc(1, sizeof(HTParentAnchor));  /* zero-filled */
d93 5
a97 2
    newAnchor->parent = newAnchor;
    newAnchor->bookmark = NULL; 	/* Bookmark filename. - FM */
a100 4
    newAnchor->FileCache = NULL;	/* Path to a disk-cached copy. - FM */
    newAnchor->SugFname = NULL; 	/* Suggested filename. - FM */
    newAnchor->RevTitle = NULL; 	/* TITLE for a LINK with REV. - FM */
    newAnchor->cache_control = NULL;	/* Cache-Control. - FM */
d102 1
a102 7
    newAnchor->content_type = NULL;	/* Content-Type. - FM */
    newAnchor->content_language = NULL; /* Content-Language. - FM */
    newAnchor->content_encoding = NULL; /* Compression algorithm. - FM */
    newAnchor->content_base = NULL;	/* Content-Base. - FM */
    newAnchor->content_disposition = NULL; /* Content-Disposition. - FM */
    newAnchor->content_location = NULL; /* Content-Location. - FM */
    newAnchor->content_md5 = NULL;	/* Content-MD5. - FM */
a103 5
    newAnchor->date = NULL;		/* Date. - FM */
    newAnchor->expires = NULL;		/* Expires. - FM */
    newAnchor->last_modified = NULL;	/* Last-Modified. - FM */
    newAnchor->ETag = NULL;		/* ETag (HTTP/1.1 cache validator) */
    newAnchor->server = NULL;		/* Server. - FM */
d107 2
a108 1
PRIVATE HTChildAnchor * HTChildAnchor_new NOARGS
d110 6
a115 1
    return (HTChildAnchor *)calloc(1, sizeof(HTChildAnchor)); /* zero-filled */
d118 11
d131 9
a139 2
/*	Case insensitive string comparison
**	----------------------------------
d144 2
a145 2
**	returns YES if the strings are equivalent ignoring case
**		NO if they differ in more than	their case.
d147 1
a147 1
PRIVATE BOOL HTEquivalent ARGS2(
d153 1
a153 1
	    if (TOUPPER(*s) != TOUPPER(*t)) {
d157 1
a157 1
	return( TOUPPER(*s) == TOUPPER(*t));
d159 1
a159 1
	return(s == t); 	/* Two NULLs are equivalent, aren't they ? */
d163 2
a164 4
#else

/*	Case sensitive string comparison
**	----------------------------------
d166 1
a166 1
**	s	Points to one string, null terminated
d169 1
a169 1
**	returns YES if the strings are identical or both NULL
d172 9
a180 7
PRIVATE BOOL HTIdentical ARGS2(
	CONST char *,	s,
	CONST char *,	t)
{
    if (s && t) {  /* Make sure they point to something */
	for (; *s && *t; s++, t++) {
	    if (*s != *t) {
d184 1
a184 1
	return(*s == *t);
d186 1
a186 1
	return(s == t); 	/* Two NULLs are identical, aren't they ? */
d189 16
d206 1
d212 2
a213 2
**	Me one is for a new anchor being edited into an existing
**	document.  The parent anchor must already exist.
d215 2
a216 2
PUBLIC HTChildAnchor * HTAnchor_findChild ARGS2(
	HTParentAnchor *,	parent,
d220 45
a264 1
    HTList *kids;
d267 1
a267 1
	CTRACE(tfp, "HTAnchor_findChild called with NULL parent.\n");
a269 21
    if ((kids = parent->children) != 0) {
	/*
	**  Parent has children.  Search them.
	*/
	if (tag && *tag) {		/* TBL */
	    while (NULL != (child=(HTChildAnchor *)HTList_nextObject(kids))) {
#ifdef CASE_INSENSITIVE_ANCHORS
		if (HTEquivalent(child->tag, tag)) /* Case insensitive */
#else
		if (HTIdentical(child->tag, tag)) /* Case sensitive - FM */
#endif /* CASE_INSENSITIVE_ANCHORS */
		{
		    CTRACE(tfp, "Child anchor %p of parent %p with name `%s' already exists.\n",
				(void *)child, (void *)parent, tag);
		    return(child);
		}
	    }
	}  /*  end if tag is void */
    } else {  /* parent doesn't have any children yet : create family */
	parent->children = HTList_new();
    }
d271 2
a272 4
    child = HTChildAnchor_new();
    if (child == NULL)
	outofmem(__FILE__, "HTChildAnchor_new");
    CTRACE(tfp, "new Anchor %p named `%s' is child of %p\n",
d274 5
a278 5
		tag ? tag : (CONST char *)"",
		(void *)parent); /* int for apollo */
    HTList_addObject (parent->children, child);
    child->parent = parent;
    StrAllocCopy(child->tag, tag);
d283 9
d305 5
a309 1
    HTChildAnchor * child = HTAnchor_findChild(parent, tag);
d311 5
a315 1
    CTRACE(tfp,"Entered HTAnchor_findChildAndLink\n");
d318 11
a328 3
	char *relative_to = HTAnchor_address((HTAnchor *)parent);
	DocAddress parsed_doc;
	HTAnchor * dest;
a329 10
	parsed_doc.address = HTParse(href, relative_to, PARSE_ALL);
#ifndef DONT_TRACK_INTERNAL_LINKS
	if (ltype && parent->post_data && ltype == LINK_INTERNAL) {
	    /* for internal links, find a destination with the same
	       post data if the source of the link has post data. - kw */
	    parsed_doc.post_data = parent->post_data;
	    parsed_doc.post_content_type = parent->post_content_type;
	} else
#endif
	{
d332 13
a345 4
	parsed_doc.bookmark = NULL;
	parsed_doc.isHEAD = FALSE;
	parsed_doc.safe = FALSE;
	dest = HTAnchor_findAddress(&parsed_doc);
d347 10
a356 1
#define DUPLICATE_ANCHOR_NAME_WORKAROUND
a357 1
#ifdef DUPLICATE_ANCHOR_NAME_WORKAROUND
d359 9
a367 15
	    HTAnchor *testdest1;
	    int nlinks;
	    testdest1 = child->mainLink.dest;
	    if (testdest1) {
		nlinks = 1 + HTList_count(child->links);
		CTRACE(tfp,
		       "*** Duplicate ChildAnchor %p named `%s' with %d links",
		       child, tag, nlinks);
		if (dest == testdest1 && ltype == child->mainLink.type) {
		    CTRACE(tfp,", same dest %p and type, keeping it\n",
			   testdest1);
		} else {
		    CTRACE(tfp,", different dest %p, creating unnamed child\n",
			   testdest1);
		    child = HTAnchor_findChild(parent, 0);
d371 1
a371 4
#endif
	HTAnchor_link((HTAnchor *)child, dest, ltype);
	FREE(parsed_doc.address);
	FREE(relative_to);
d373 1
a373 1
    return(child);
a375 38
#ifdef LY_FIND_LEAKS
/*
**  Function for freeing the adult hash table. - FM
*/
PRIVATE void free_adult_table NOARGS
{
    int i_counter;
    HTList * HTAp_freeme;
    HTParentAnchor * parent;
    /*
     *	Loop through all lists.
     */
    for (i_counter = 0; i_counter < HASH_SIZE; i_counter++) {
	/*
	**  Loop through the list.
	*/
	while (adult_table[i_counter] != NULL) {
	    /*
	    **	Free off items - FM
	    */
	    HTAp_freeme = adult_table[i_counter];
	    adult_table[i_counter] = HTAp_freeme->next;
	    if (HTAp_freeme->object) {
		parent = (HTParentAnchor *)HTAp_freeme->object;
		CTRACE(tfp, "delete anchor:%d/%d,%d,%d %s\n",
		       i_counter, HTList_count(HTAp_freeme) + 1,
		       (parent->physical ? 1 : 0),
		       (int)parent->underway,
		       (parent->address ? parent->address : "(no address)"));
		parent->underway = FALSE;
		HTAnchor_delete(parent);
	    }
	    FREE(HTAp_freeme);
	}
    }
    FREE(adult_table);
}
#endif /* LY_FIND_LEAKS */
d377 2
a378 2
/*	Create new or find old named anchor
**	-----------------------------------
d385 1
a385 1
PUBLIC HTAnchor * HTAnchor_findAddress ARGS1(
d389 1
a389 1
    char *tag = HTParse(newdoc->address, "", PARSE_ANCHOR);
d391 1
a391 1
    CTRACE(tfp,"Entered HTAnchor_findAddress\n");
d394 2
a395 2
    **	If the address represents a sub-anchor, we recursively load its
    **	parent, then we create a child anchor within that document.
d399 1
a399 1
	HTParentAnchor * foundParent;
d403 1
a403 1
		PARSE_ACCESS | PARSE_HOST | PARSE_PATH | PARSE_PUNCTUATION);
d410 2
a411 2
	foundParent = (HTParentAnchor *)HTAnchor_findAddress(&parsed_doc);
	foundAnchor = HTAnchor_findChild (foundParent, tag);
d413 20
a432 11
	FREE(tag);
	return (HTAnchor *)foundAnchor;
    } else {
	/*
	**  If the address has no anchor tag,
	**  check whether we have this node.
	*/
	int hash;
	HTList * adults;
	HTList *grownups;
	HTParentAnchor * foundAnchor;
d434 5
a438 1
	FREE(tag);
d440 22
a461 11
	/*
	**  Select list from hash table,
	*/
	hash = HASH_FUNCTION(newdoc->address);
	if (!adult_table) {
	    adult_table = (HTList **)calloc(HASH_SIZE, sizeof(HTList *));
	    if (!adult_table)
		outofmem(__FILE__, "HTAnchor_findAddress");
#ifdef LY_FIND_LEAKS
	    atexit(free_adult_table);
#endif
d463 1
a463 3
	if (!adult_table[hash])
	    adult_table[hash] = HTList_new();
	adults = adult_table[hash];
d465 10
a474 21
	/*
	**  Search list for anchor.
	*/
	grownups = adults;
	while (NULL != (foundAnchor =
			(HTParentAnchor *)HTList_nextObject(grownups))) {
#ifdef CASE_INSENSITIVE_ANCHORS
	    if (HTEquivalent(foundAnchor->address, newdoc->address) &&
		HTEquivalent(foundAnchor->post_data, newdoc->post_data) &&
		foundAnchor->isHEAD == newdoc->isHEAD)
#else
	    if (HTIdentical(foundAnchor->address, newdoc->address) &&
		HTIdentical(foundAnchor->post_data, newdoc->post_data) &&
		foundAnchor->isHEAD == newdoc->isHEAD)
#endif /* CASE_INSENSITIVE_ANCHORS */
	    {
		CTRACE(tfp, "Anchor %p with address `%s' already exists.\n",
			    (void *)foundAnchor, newdoc->address);
		 return (HTAnchor *)foundAnchor;
	     }
	}
a475 7
	/*
	**  Node not found: create new anchor.
	*/
	foundAnchor = HTParentAnchor_new();
	CTRACE(tfp, "New anchor %p has hash %d and address `%s'\n",
		    (void *)foundAnchor, hash, newdoc->address);
	StrAllocCopy(foundAnchor->address, newdoc->address);
d477 1
a477 1
	    StrAllocCopy(foundAnchor->post_data, newdoc->post_data);
d479 2
a480 2
	    StrAllocCopy(foundAnchor->post_content_type,
			 newdoc->post_content_type);
d482 3
a484 5
	    StrAllocCopy(foundAnchor->bookmark, newdoc->bookmark);
	foundAnchor->isHEAD = newdoc->isHEAD;
	foundAnchor->safe = newdoc->safe;
	HTList_addObject (adults, foundAnchor);
	return (HTAnchor *)foundAnchor;
d486 51
d544 2
a545 2
**	All outgoing links from parent and children are deleted, and this anchor
**	is removed from the sources list of all its targets.
d547 1
a547 1
**	If this anchor's source list is empty, we delete it and its children.
d549 6
d556 1
a556 1
	HTAnchor *,	me)
d559 1
a559 2
     *	Memory leaks fixed.
     *	05-27-94 Lynx 2-3-1 Garrett Arch Blythe
d561 2
a562 13

    /*
     *	Anchor is NULL, do nothing.
     */
    if (!me) {
	return;
    }

    /*
     *	Unregister me with our mainLink destination anchor's parent.
     */
    if (me->mainLink.dest) {
	HTParentAnchor *parent = me->mainLink.dest->parent;
d565 1
a565 4
	 *  Set the mainLink pointer to zero NOW.  If we don't,
	 *  and we get somehow called recursively again for this
	 *  same old me during the HTAnchor_delete below, weird
	 *  things can occasionally happen. - kw
d567 1
a567 1
	 me->mainLink.dest = NULL;
d571 1
a571 1
	 *  parent knows one less anchor is it's dest.
d573 1
a573 1
	if (!HTList_isEmpty(parent->sources)) {
d577 1
a577 1
	    HTList_removeObject(parent->sources, (void *)me);
d581 1
d583 1
a583 6
	 *  If the parent has no loaded document, then we should
	 *  tell it to attempt to delete itself.
	 *  Don't do this jazz if the anchor passed in is the same
	 *  as the anchor to delete.
	 *  Also, don't do this if the destination parent is our
	 *  parent.
d585 2
a586 3
	if (!parent->document &&
	    parent != (HTParentAnchor *)me &&
	    me->parent != parent) {
d591 1
a591 1
	 *  At this point, we haven't a mainLink.  Set it to be
d596 1
a596 1
	me->mainLink.type = NULL;
d598 1
a599 54
    /*
     *	Check for extra destinations in our links list.
     */
    if (!HTList_isEmpty(me->links)) {
	HTLink *target;
	HTParentAnchor *parent;

	/*
	 *  Take out our extra non mainLinks one by one, calling
	 *  their parents to know that they are no longer
	 *  the destination of me's anchor.
	 */
	while ((target = (HTLink *)HTList_removeLastObject(me->links)) != 0) {
	    parent = target->dest->parent;
	    if (!HTList_isEmpty(parent->sources)) {
		/*
		 *  Only need to tell destination parent
		 *  anchor once.
		 */
		HTList_removeObject(parent->sources, (void *)me);
	    }

	    /*
	     *	Avoid calling overhead.
	     *	If the parent hasn't a loaded document, then
	     *	   we will attempt to have the parent
	     *	   delete itself.
	     *	Don't call twice if this is the same anchor
	     *	   that we are trying to delete.
	     *	Also, don't do this if we are trying to delete
	     *	   our parent.
	     */
	    if (!parent->document &&
		(HTParentAnchor *)me != parent &&
		me->parent != parent) {
		HTAnchor_delete(parent);
	    }
	    /*
	     *	The link structure has to be deleted, too!
	     *	That was missing, but this code probably never
	     *	got exercised by Lynx.	- KW
	     */
	    FREE(target);
	}

	/*
	 *  At this point, me no longer has any destination in
	 *  the links list.  Get rid of it.
	 */
	if (me->links) {
	    HTList_delete(me->links);
	    me->links = NULL;
	}
    }
d601 2
a602 8
    /*
     *	Catch in case links list exists but nothing in it.
     */
    if (me->links) {
	HTList_delete(me->links);
	me->links = NULL;
    }
}
d605 1
a605 1
	HTParentAnchor *,	me)
d611 1
a611 1
    HTList *cur;
d624 1
a624 1
    if (me->document || me->underway) {
d630 1
a630 1
     *  on this HTParentAnchor will not free it from under our feet. - kw
d634 1
a634 14
    /*
     *	Recursively try to delete destination anchors of this parent.
     *	In any event, this will tell all destination anchors that we
     *	no longer consider them a destination.
     */
    deleteLinks((HTAnchor *)me);

    /*
     *	There are still incoming links to this one (we are the
     *	destination of another anchor).
     *	Don't actually delete this anchor, but children are OK to
     *	delete their links.
     */
    if (!HTList_isEmpty(me->sources)) {
d636 2
a637 2
	 *  Delete all outgoing links from children, do not
	 *  delete the children, though.
d639 7
a645 6
	if (!HTList_isEmpty(me->children)) {
	    cur = me->children;
	    while ((child = (HTChildAnchor *)HTList_nextObject(cur)) != 0) {
		if (child != NULL) {
		    deleteLinks((HTAnchor *)child);
		}
d648 3
a650 1
	me->underway = FALSE;
d652 5
d664 2
a665 2
     *	No more incoming links : kill everything
     *	First, recursively delete children and their links.
d667 7
a673 10
    if (!HTList_isEmpty(me->children)) {
	while ((child = (HTChildAnchor *)HTList_removeLastObject(
							me->children)) != 0) {
	    if (child) {
		deleteLinks((HTAnchor *)child);
		if (child->tag) {
		    FREE(child->tag);
		}
		FREE(child);
	    }
d675 1
a676 1
    me->underway = FALSE;
d679 1
a679 1
     *	Delete our empty list of children.
d681 3
a683 3
    if (me->children) {
	HTList_delete(me->children);
	me->children = NULL;
d687 1
a687 1
     * Delete our empty list of sources.
d689 31
a719 3
    if (me->sources) {
	HTList_delete(me->sources);
	me->sources = NULL;
d723 24
d766 1
a766 1
    FREE(me->post_data);
d771 4
d796 1
d800 1
a800 1
#ifdef USE_HASH
a804 11
     *	Remove ourselves from the hash table's list.
     */
    if (adult_table) {
	unsigned short int usi_hash = HASH_FUNCTION(me->address);

	if (adult_table[usi_hash])  {
	    HTList_removeObject(adult_table[usi_hash], (void *)me);
	}
    }

    /*
d811 1
a811 6
    /*
     *	Free the address.
     */
    FREE(me->address);

    FREE (me->UCStages);
d813 1
d815 4
a818 1

d820 1
a820 1
     *	Finally, kill the parent anchor passed in.
d822 11
a832 19
    FREE(me);

    return(YES);
}


/*		Move an anchor to the head of the list of its siblings
**		------------------------------------------------------
**
**	This is to ensure that an anchor which might have already existed
**	is put in the correct order as we load the document.
*/
PUBLIC void HTAnchor_makeLastChild ARGS1(
	HTChildAnchor *,	me)
{
    if (me->parent != (HTParentAnchor *)me) {  /* Make sure it's a child */
	HTList * siblings = me->parent->children;
	HTList_removeObject (siblings, me);
	HTList_addObject (siblings, me);
d835 1
d843 8
a850 1
    return( me ? me->parent : NULL);
d874 2
a875 1
	if (((HTParentAnchor *)me == me->parent) ||
d879 2
a880 7
	    addr = malloc(2 +
			  strlen(me->parent->address) +
			  strlen(((HTChildAnchor *)me)->tag));
	    if (addr == NULL)
		outofmem(__FILE__, "HTAnchor_address");
	    sprintf(addr, "%s#%s",
			   me->parent->address, ((HTChildAnchor *)me)->tag);
d902 1
a902 1
	char *, 		address)
d912 1
a912 1
	char *, 		prompt)
d931 1
a931 7
    return( me ? me->parent->isISMAPScript : NO);
}

PUBLIC BOOL HTAnchor_hasChildren ARGS1(
	HTParentAnchor *,	me)
{
    return( me ? ! HTList_isEmpty(me->children) : NO);
d934 1
a934 1
#if defined(USE_HASH)
d972 2
a973 2
		if ((unsigned char)me->title[i] == 1 ||
		    (unsigned char)me->title[i] == 2) {
d978 1
a978 1
	    CTRACE(tfp,"HTAnchor_setTitle: New title is NULL! ");
d980 1
a980 1
		CTRACE(tfp,"Old title was \"%s\".\n", me->title);
d983 1
a983 1
		CTRACE(tfp,"Old title was NULL.\n");
d998 2
a999 2
	    if ((unsigned char)me->title[i] == 1 ||
		(unsigned char)me->title[i] == 2) {
d1056 2
a1057 2
	    if ((unsigned char)me->RevTitle[i] == 1 ||
		(unsigned char)me->RevTitle[i] == 2) {
d1064 19
d1140 1
a1140 1
    return( me ? me->safe : FALSE);
a1196 31
/*	Link me Anchor to another given one
**	-------------------------------------
*/
PUBLIC BOOL HTAnchor_link ARGS3(
	HTAnchor *,	source,
	HTAnchor *,	destination,
	HTLinkType *,	type)
{
    if (!(source && destination))
	return(NO);  /* Can't link to/from non-existing anchor */
    CTRACE(tfp, "Linking anchor %p to anchor %p\n", source, destination);
    if (!source->mainLink.dest) {
	source->mainLink.dest = destination;
	source->mainLink.type = type;
    } else {
	HTLink * newLink = (HTLink *)calloc (1, sizeof (HTLink));
	if (newLink == NULL)
	    outofmem(__FILE__, "HTAnchor_link");
	newLink->dest = destination;
	newLink->type = type;
	if (!source->links)
	    source->links = HTList_new();
	HTList_addObject (source->links, newLink);
    }
    if (!destination->parent->sources)
	destination->parent->sources = HTList_new();
    HTList_addObject (destination->parent->sources, source);
    return(YES);  /* Success */
}


d1200 2
a1201 2
PUBLIC HTAnchor * HTAnchor_followMainLink ARGS1(
	HTAnchor *,	me)
d1203 1
a1203 1
    return( me->mainLink.dest);
d1207 2
a1208 2
	HTAnchor *,	me,
	HTLinkType *,	type)
d1210 2
a1211 11
    if (me->mainLink.type == type)
	return( me->mainLink.dest);
    if (me->links) {
	HTList *links = me->links;
	HTLink *the_link;
	while (NULL != (the_link=(HTLink *)HTList_nextObject(links))) {
	    if (the_link->type == type) {
		return( the_link->dest);
	    }
	}
    }
a1215 27
/*	Make main link
*/
PUBLIC BOOL HTAnchor_makeMainLink ARGS2(
	HTAnchor *,	me,
	HTLink *,	movingLink)
{
    /* Check that everything's OK */
    if (!(me && HTList_removeObject (me->links, movingLink))) {
	return(NO);  /* link not found or NULL anchor */
    } else {
	/* First push current main link onto top of links list */
	HTLink *newLink = (HTLink *)calloc (1, sizeof (HTLink));
	if (newLink == NULL)
	    outofmem(__FILE__, "HTAnchor_makeMainLink");
	memcpy((void *)newLink,
	       (CONST char *)&me->mainLink, sizeof (HTLink));
	HTList_addObject (me->links, newLink);

	/* Now make movingLink the new main link, and free it */
	memcpy((void *)&me->mainLink,
	       (CONST void *)movingLink, sizeof (HTLink));
	FREE(movingLink);
	return(YES);
    }
}


d1255 1
a1255 1
	char *, 		physical)
d1293 1
a1293 2
	UCAnchorInfo * stages = (UCAnchorInfo*)calloc(1,
						      sizeof(UCAnchorInfo));
d1341 14
d1370 3
d1377 5
d1398 2
d1403 1
d1405 5
d1436 3
d1442 8
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 13
a14 13
 *	==========================
 *
 * An anchor represents a region of a hypertext document which is linked to
 * another anchor in the same or a different document.
 *
 * History
 *
 *	   Nov 1990  Written in Objective-C for the NeXT browser (TBL)
 *	24-Oct-1991 (JFG), written in C, browser-independent
 *	21-Nov-1991 (JFG), first complete version
 *
 *	(c) Copyright CERN 1991 - See Copyright.html
 */
a20 1
#include <HTString.h>
a23 2
#include <GridText.h>
#include <LYUtils.h>
d39 2
a40 1
static int HASH_FUNCTION(const char *cp_address)
d43 1
a43 1
    const unsigned char *p;
d45 2
a46 2
    for (p = (const unsigned char *) cp_address, hash = 0; *p; p++)
	hash = (int) (hash * 3 + (*(const unsigned char *) p)) % HASH_SIZE;
d48 1
a48 1
    return (hash);
a51 1

d54 1
a54 1
    int junk;			/* VMS cannot handle pointers to undefined structs */
d58 1
a58 4
/* Table of lists of all parents */
static HTList adult_table[HASH_SIZE] =
{
    {NULL, NULL}};
d61 7
a67 22
 *				================
 *
 *	Do not use "new" by itself outside this module.  In order to enforce
 *	consistency, we insist that you furnish more information about the
 *	anchor you are creating : use newWithParent or newWithAddress.
 */
static HTParentAnchor0 *HTParentAnchor0_new(const char *address,
					    short hash)
{
    HTParentAnchor0 *newAnchor = typecalloc(HTParentAnchor0);

    if (newAnchor == NULL)
	outofmem(__FILE__, "HTParentAnchor0_new");

    newAnchor->parent = newAnchor;	/* self */
    StrAllocCopy(newAnchor->address, address);
    newAnchor->adult_hash = hash;

    return (newAnchor);
}

static HTParentAnchor *HTParentAnchor_new(HTParentAnchor0 *parent)
d69 2
a70 2
    HTParentAnchor *newAnchor = typecalloc(HTParentAnchor);

d73 2
a74 5

    newAnchor->parent = parent;	/* cross reference */
    parent->info = newAnchor;	/* cross reference */
    newAnchor->address = parent->address;	/* copy pointer */

d76 6
a81 2
    newAnchor->isHEAD = FALSE;	/* HEAD request if TRUE. - FM */
    newAnchor->safe = FALSE;	/* Safe. - FM */
d83 7
a89 1
    newAnchor->inBASE = FALSE;	/* duplicated from HTML.c/h */
d91 6
a96 1
    return (newAnchor);
d99 1
a99 1
static HTChildAnchor *HTChildAnchor_new(HTParentAnchor0 *parent)
d101 1
a101 7
    HTChildAnchor *p = typecalloc(HTChildAnchor);

    if (p == NULL)
	outofmem(__FILE__, "HTChildAnchor_new");

    p->parent = parent;		/* parent reference */
    return p;
a103 11
static HTChildAnchor *HText_pool_ChildAnchor_new(HTParentAnchor *parent)
{
    HTChildAnchor *p = (HTChildAnchor *) HText_pool_calloc((HText *) (parent->document),
							   sizeof(HTChildAnchor));

    if (p == NULL)
	outofmem(__FILE__, "HText_pool_ChildAnchor_new");

    p->parent = parent->parent;	/* parent reference */
    return p;
}
d106 12
a117 18
/* Case insensitive string comparison */
#define HT_EQUIV(a,b) (TOUPPER(a) == TOUPPER(b))
#else
/* Case sensitive string comparison */
#define HT_EQUIV(a,b) ((a) == (b))
#endif

/*	Null-terminated string comparison
 *	---------------------------------
 * On entry,
 *	s	Points to one string, null terminated
 *	t	points to the other.
 * On exit,
 *	returns YES if the strings are equivalent
 *		NO if they differ.
 */
static BOOL HTSEquivalent(const char *s,
			  const char *t)
d119 1
a119 1
    if (s && t) {		/* Make sure they point to something */
d121 2
a122 2
	    if (!HT_EQUIV(*s, *t)) {
		return (NO);
d125 1
a125 1
	return (HT_EQUIV(*s, *t));
d127 1
a127 1
	return (s == t);	/* Two NULLs are equivalent, aren't they ? */
d131 14
a144 11
/*	Binary string comparison
 *	------------------------
 * On entry,
 *	s	Points to one bstring
 *	t	points to the other.
 * On exit,
 *	returns YES if the strings are equivalent
 *		NO if they differ.
 */
static BOOL HTBEquivalent(const bstring *s,
			  const bstring *t)
d146 4
a149 7
    if (s && t && BStrLen(s) == BStrLen(t)) {
	int j;
	int len = BStrLen(s);

	for (j = 0; j < len; ++j) {
	    if (!HT_EQUIV(BStrData(s)[j], BStrData(t)[j])) {
		return (NO);
d152 1
a152 1
	return (YES);
d154 1
a154 1
	return (s == t);	/* Two NULLs are equivalent, aren't they ? */
d157 2
d160 9
a168 5
/*
 * Three-way compare function
 */
static int compare_anchors(void *l,
			   void *r)
d170 2
a171 4
    const char *a = ((HTChildAnchor *) l)->tag;
    const char *b = ((HTChildAnchor *) r)->tag;

    /* both tags are not NULL */
d173 10
d184 1
a184 1
    return strcasecomp(a, b);	/* Case insensitive */
d186 1
a186 1
    return strcmp(a, b);	/* Case sensitive - FM */
d188 5
a192 28
}

/*	Create new or find old sub-anchor
 *	---------------------------------
 *
 *	This one is for a named child.
 *	The parent anchor must already exist.
 */
static HTChildAnchor *HTAnchor_findNamedChild(HTParentAnchor0 *parent,
					      const char *tag)
{
    HTChildAnchor *child;

    if (parent && tag && *tag) {	/* TBL */
	if (parent->children) {
	    /*
	     * Parent has children.  Search them.
	     */
	    HTChildAnchor sample;

	    sample.tag = (char *) tag;	/* for compare_anchors() only */

	    child = (HTChildAnchor *) HTBTree_search(parent->children, &sample);
	    if (child != NULL) {
		CTRACE((tfp,
			"Child anchor %p of parent %p with name `%s' already exists.\n",
			(void *) child, (void *) parent, tag));
		return (child);
d194 3
a196 17
	} else {		/* parent doesn't have any children yet : create family */
	    parent->children = HTBTree_new(compare_anchors);
	}

	child = HTChildAnchor_new(parent);
	CTRACE((tfp, "HTAnchor: New Anchor %p named `%s' is child of %p\n",
		(void *) child,
		NonNull(tag),
		(void *) child->parent));

	StrAllocCopy(child->tag, tag);	/* should be set before HTBTree_add */
	HTBTree_add(parent->children, child);
	return (child);

    } else {
	CTRACE((tfp, "HTAnchor_findNamedChild called with NULL parent.\n"));
	return (NULL);
d199 11
a211 30
/*
 *	This one is for a new unnamed child being edited into an existing
 *	document.  The parent anchor and the document must already exist.
 *	(Just add new unnamed child).
 */
static HTChildAnchor *HTAnchor_addChild(HTParentAnchor *parent)
{
    HTChildAnchor *child;

    if (!parent) {
	CTRACE((tfp, "HTAnchor_addChild called with NULL parent.\n"));
	return (NULL);
    }

    child = HText_pool_ChildAnchor_new(parent);
    CTRACE((tfp, "HTAnchor: New unnamed Anchor %p is child of %p\n",
	    (void *) child,
	    (void *) child->parent));

    child->tag = 0;
    HTList_linkObject(&parent->children_notag, child, &child->_add_children_notag);

    return (child);
}

static HTParentAnchor0 *HTAnchor_findAddress_in_adult_table(const DocAddress *newdoc);

static BOOL HTAnchor_link(HTChildAnchor *child,
			  HTAnchor * destination,
			  HTLinkType *type);
d214 11
a224 10
 *	--------------------------------------------------
 *
 *	Create new anchor with a given parent and possibly
 *	a name, and possibly a link to a _relatively_ named anchor.
 *	(Code originally in ParseHTML.h)
 */
HTChildAnchor *HTAnchor_findChildAndLink(HTParentAnchor *parent,	/* May not be 0   */
					 const char *tag,	/* May be "" or 0 */
					 const char *href,	/* May be "" or 0 */
					 HTLinkType *ltype)	/* May be 0       */
d226 1
a226 1
    HTChildAnchor *child;
d228 1
a228 10
    CTRACE((tfp, "Entered HTAnchor_findChildAndLink:  tag=`%s',%s href=`%s'\n",
	    NonNull(tag),
	    (ltype == HTInternalLink) ? " (internal link)" : "",
	    NonNull(href)));

    if (tag && *tag) {
	child = HTAnchor_findNamedChild(parent->parent, tag);
    } else {
	child = HTAnchor_addChild(parent);
    }
d231 3
a233 12
	const char *fragment = NULL;
	HTParentAnchor0 *dest;

	if (ltype == HTInternalLink && *href == '#') {
	    dest = parent->parent;
	} else {
	    const char *relative_to = (parent->inBASE && *href != '#') ?
	    parent->content_base : parent->address;
	    DocAddress parsed_doc;

	    parsed_doc.address = HTParse(href, relative_to,
					 PARSE_ALL_WITHOUT_ANCHOR);
d235 10
a246 13
	    if (ltype && parent->post_data && ltype == HTInternalLink) {
		/* for internal links, find a destination with the same
		   post data if the source of the link has post data. - kw
		   Example: LYNXIMGMAP: */
		parsed_doc.post_data = parent->post_data;
		parsed_doc.post_content_type = parent->post_content_type;
	    }
	    parsed_doc.bookmark = NULL;
	    parsed_doc.isHEAD = FALSE;
	    parsed_doc.safe = FALSE;

	    dest = HTAnchor_findAddress_in_adult_table(&parsed_doc);
	    FREE(parsed_doc.address);
d248 4
d253 1
a253 9
	/*
	 * [from HTAnchor_findAddress()]
	 * If the address represents a sub-anchor, we load its parent (above),
	 * then we create a named child anchor within that parent.
	 */
	fragment = (*href == '#') ? href + 1 : HTParseAnchor(href);

	if (*fragment)
	    dest = (HTParentAnchor0 *) HTAnchor_findNamedChild(dest, fragment);
d255 1
d257 15
a271 9
	    if (child->dest) {	/* DUPLICATE_ANCHOR_NAME_WORKAROUND  - kw */
		CTRACE((tfp,
			"*** Duplicate ChildAnchor %p named `%s'",
			child, tag));
		if ((HTAnchor *) dest != child->dest || ltype != child->type) {
		    CTRACE((tfp,
			    ", different dest %p or type, creating unnamed child\n",
			    child->dest));
		    child = HTAnchor_addChild(parent);
d275 42
a316 1
	HTAnchor_link(child, (HTAnchor *) dest, ltype);
d318 1
a318 1
    return child;
d320 1
d322 10
a331 9
/*	Create new or find old parent anchor
 *	------------------------------------
 *
 *	Me one is for a reference which is found in a document, and might
 *	not be already loaded.
 *	Note: You are not guaranteed a new anchor -- you might get an old one,
 *	like with fonts.
 */
HTParentAnchor *HTAnchor_findAddress(const DocAddress *newdoc)
d334 1
a334 1
    const char *tag = HTParseAnchor(newdoc->address);
d336 1
a336 1
    CTRACE((tfp, "Entered HTAnchor_findAddress\n"));
d339 3
a341 3
     * If the address represents a sub-anchor, we load its parent, then we
     * create a named child anchor within that parent.
     */
d344 2
a345 2
	HTParentAnchor0 *foundParent;
	HTChildAnchor *foundAnchor;
d348 1
a348 1
				     PARSE_ALL_WITHOUT_ANCHOR);
d355 2
a356 2
	foundParent = HTAnchor_findAddress_in_adult_table(&parsed_doc);
	foundAnchor = HTAnchor_findNamedChild(foundParent, tag);
d358 11
a368 4
	return HTAnchor_parent((HTAnchor *) foundParent);
    }
    return HTAnchor_parent((HTAnchor *) HTAnchor_findAddress_in_adult_table(newdoc));
}
d370 1
a370 13
/*  The address has no anchor tag, for sure.
 */
static HTParentAnchor0 *HTAnchor_findAddress_in_adult_table(const DocAddress *newdoc)
{
    /*
     * Check whether we have this node.
     */
    int hash;
    HTList *adults;
    HTList *grownups;
    HTParentAnchor0 *foundAnchor;
    BOOL need_extra_info = (newdoc->post_data || newdoc->post_content_type ||
			    newdoc->bookmark || newdoc->isHEAD || newdoc->safe);
d372 15
a386 5
    /*
     * We need not free adult_table[] atexit - it should be perfectly empty
     * after free'ing all HText's.  (There is an error if it is not empty at
     * exit).  -LP
     */
d388 20
a407 21
    /*
     * Select list from hash table,
     */
    hash = HASH_FUNCTION(newdoc->address);
    adults = &(adult_table[hash]);

    /*
     * Search list for anchor.
     */
    grownups = adults;
    while (NULL != (foundAnchor =
		    (HTParentAnchor0 *) HTList_nextObject(grownups))) {
	if (HTSEquivalent(foundAnchor->address, newdoc->address) &&

	    ((!foundAnchor->info && !need_extra_info) ||
	     (foundAnchor->info &&
	      HTBEquivalent(foundAnchor->info->post_data, newdoc->post_data) &&
	      foundAnchor->info->isHEAD == newdoc->isHEAD))) {
	    CTRACE((tfp, "Anchor %p with address `%s' already exists.\n",
		    (void *) foundAnchor, newdoc->address));
	    return foundAnchor;
a408 12
    }

    /*
     * Node not found:  create new anchor.
     */
    foundAnchor = HTParentAnchor0_new(newdoc->address, hash);
    CTRACE((tfp, "New anchor %p has hash %d and address `%s'\n",
	    (void *) foundAnchor, hash, newdoc->address));

    if (need_extra_info) {
	/* rare case, create a big structure */
	HTParentAnchor *p = HTParentAnchor_new(foundAnchor);
d410 7
d418 1
a418 1
	    BStrCopy(p->post_data, newdoc->post_data);
d420 1
a420 1
	    StrAllocCopy(p->post_content_type,
d423 5
a427 3
	    StrAllocCopy(p->bookmark, newdoc->bookmark);
	p->isHEAD = newdoc->isHEAD;
	p->safe = newdoc->safe;
a428 3
    HTList_linkObject(adults, foundAnchor, &foundAnchor->_add_adult);

    return foundAnchor;
a430 9
/*	Create new or find old named anchor - simple form
 *	-------------------------------------------------
 *
 *     Like HTAnchor_findAddress, but simpler to use for simple cases.
 *	No post data etc. can be supplied. - kw
 */
HTParentAnchor *HTAnchor_findSimpleAddress(const char *url)
{
    DocAddress urldoc;
d432 11
a442 15
    urldoc.address = (char *) url;	/* ignore warning, it IS treated like const - kw */
    urldoc.post_data = NULL;
    urldoc.post_content_type = NULL;
    urldoc.bookmark = NULL;
    urldoc.isHEAD = FALSE;
    urldoc.safe = FALSE;
    return HTAnchor_findAddress(&urldoc);
}

/*	Link me Anchor to another given one
 *	-------------------------------------
 */
static BOOL HTAnchor_link(HTChildAnchor *child,
			  HTAnchor * destination,
			  HTLinkType *type)
d444 4
a447 2
    if (!(child && destination))
	return (NO);		/* Can't link to/from non-existing anchor */
d449 5
a453 4
    CTRACE((tfp, "Linking child %p to anchor %p\n", child, destination));
    if (child->dest) {
	CTRACE((tfp, "*** child anchor already has destination, exiting!\n"));
	return (NO);
a455 27
    child->dest = destination;
    child->type = type;

    if (child->parent != destination->parent)
	/* link only foreign children */
	HTList_linkObject(&destination->parent->sources, child, &child->_add_sources);

    return (YES);		/* Success */
}

/*	Delete an anchor and possibly related things (auto garbage collection)
 *	--------------------------------------------
 *
 *	The anchor is only deleted if the corresponding document is not loaded.
 *	All outgoing links from children are deleted, and children are
 *	removed from the sources lists of theirs targets.
 *	We also try to delete the targets whose documents are not loaded.
 *	If this anchor's sources list is empty, we delete it and its children.
 */

/*
 *	Recursively try to delete destination anchor of this child.
 *	In any event, this will tell destination anchor that we
 *	no longer consider it a destination.
 */
static void deleteLinks(HTChildAnchor *me)
{
d457 1
a457 1
     * Unregister me with our destination anchor's parent.
d459 2
a460 2
    if (me->dest) {
	HTParentAnchor0 *parent = me->dest->parent;
d463 4
a466 1
	 * Start.  Set the dest pointer to zero.
d468 1
a468 1
	me->dest = NULL;
d471 2
a472 2
	 * Remove me from the parent's sources so that the parent knows one
	 * less anchor is its dest.
d474 1
a474 1
	if ((me->parent != parent) && !HTList_isEmpty(&parent->sources)) {
d476 1
a476 1
	     * Really should only need to deregister once.
d478 1
a478 1
	    HTList_unlinkObject(&parent->sources, (void *) me);
d482 7
a488 2
	 * Recursive call.  Test here to avoid calling overhead.  Don't delete
	 * if document is loaded or being loaded.
d490 3
a492 2
	if ((me->parent != parent) && !parent->underway &&
	    (!parent->info || !parent->info->document)) {
d497 4
a500 3
	 * At this point, we haven't a destination.  Set it to be so.  Leave
	 * the HTAtom pointed to by type up to other code to handle (reusable,
	 * near static).
d502 1
a502 1
	me->type = NULL;
a503 3
}

static void HTParentAnchor_free(HTParentAnchor *me);
a504 2
BOOL HTAnchor_delete(HTParentAnchor0 *me)
{
d506 1
a506 2
     * Memory leaks fixed.
     * 05-27-94 Lynx 2-3-1 Garrett Arch Blythe
d508 3
a510 2
    HTBTElement *ele;
    HTChildAnchor *child;
d512 14
a525 6
    /*
     * Do nothing if nothing to do.
     */
    if (!me) {
	return (NO);
    }
d527 22
a548 6
    /*
     * Don't delete if document is loaded or being loaded.
     */
    if (me->underway || (me->info && me->info->document)) {
	return (NO);
    }
a549 7
    /*
     * Mark ourselves busy, so that recursive calls of this function on this
     * HTParentAnchor0 will not free it from under our feet.  - kw
     */
    me->underway = TRUE;

    {
d551 2
a552 2
	 * Delete all outgoing links from named children.  Do not delete named
	 * children itself (may have incoming links).
d554 3
a556 8
	if (me->children) {
	    ele = HTBTree_next(me->children, NULL);
	    while (ele != NULL) {
		child = (HTChildAnchor *) HTBTree_object(ele);
		if (child->dest)
		    deleteLinks(child);
		ele = HTBTree_next(me->children, ele);
	    }
a558 1
    me->underway = FALSE;
d561 1
a561 2
     * There are still incoming links to this one (we are the
     * destination of another anchor).
d563 3
a565 5
    if (!HTList_isEmpty(&me->sources)) {
	/*
	 * Can't delete parent, still have sources.
	 */
	return (NO);
d567 1
d569 3
d573 2
a574 2
     * No more incoming and outgoing links :  kill everything First, delete
     * named children.
d576 8
a583 9
    if (me->children) {
	ele = HTBTree_next(me->children, NULL);
	while (ele != NULL) {
	    child = (HTChildAnchor *) HTBTree_object(ele);
	    FREE(child->tag);
	    FREE(child);
	    ele = HTBTree_next(me->children, ele);
	}
	HTBTree_free(me->children);
d587 1
a587 1
     * Delete the ParentAnchor, if any.  (Document was already deleted).
d589 2
a590 3
    if (me->info) {
	HTParentAnchor_free(me->info);
	FREE(me->info);
d594 2
a595 1
     * Remove ourselves from the hash table's list.
d597 1
a597 1
    HTList_unlinkObject(&(adult_table[me->adult_hash]), (void *) me);
d600 3
a602 1
     * Free the address.
d604 1
a604 1
    FREE(me->address);
d607 4
a610 1
     * Finally, kill the parent anchor passed in.
d612 14
a625 1
    FREE(me);
d627 5
a631 12
    return (YES);
}

/*
 * Unnamed children (children_notag) have no sence without HText - delete them
 * and their links if we are about to free HText.  Document currently exists. 
 * Called within HText_free().
 */
void HTAnchor_delete_links(HTParentAnchor *me)
{
    HTList *cur;
    HTChildAnchor *child;
d634 2
a635 1
     * Do nothing if nothing to do.
d637 11
a647 2
    if (!me || !me->document) {
	return;
d649 1
d652 1
a652 2
     * Mark ourselves busy, so that recursive calls on this HTParentAnchor0
     * will not free it from under our feet.  - kw
d654 4
a657 1
    me->parent->underway = TRUE;
d660 1
a660 1
     * Delete all outgoing links from unnamed children.
d662 3
a664 7
    if (!HTList_isEmpty(&me->children_notag)) {
	cur = &me->children_notag;
	while ((child =
		(HTChildAnchor *) HTList_unlinkLastObject(cur)) != 0) {
	    deleteLinks(child);
	    /* child allocated in HText pool, HText_free() will free it later */
	}
a665 2
    me->parent->underway = FALSE;
}
a666 2
static void HTParentAnchor_free(HTParentAnchor *me)
{
d668 1
a668 1
     * Delete the methods list.
d672 2
a673 2
	 * Leave what the methods point to up in memory for other code (near
	 * static stuff).
d680 1
a680 1
     * Free up all allocated members.
d687 1
a687 1
    BStrFree(me->post_data);
a691 4
    FREE(me->citehost);
#ifdef USE_SOURCE_CACHE
    HTAnchor_clearSourceCache(me);
#endif
a693 1

a701 4
#ifdef EXP_HTTP_HEADERS
    HTChunkClear(&(me->http_headers));
#endif
    FREE(me->content_type_params);
a712 1

d716 1
a716 1
#ifdef USE_COLOR_STYLE
d721 1
a721 4
     * Original code wanted a way to clean out the HTFormat if no longer needed
     * (ref count?).  I'll leave it alone since those HTAtom objects are a
     * little harder to know where they are being referenced all at one time. 
     * (near static)
d723 19
d743 1
a743 1
    FREE(me->UCStages);
d745 8
d755 9
a763 2
#ifdef USE_SOURCE_CACHE
void HTAnchor_clearSourceCache(HTParentAnchor *me)
d765 4
a768 14
    /*
     * Clean up the source cache, if any.
     */
    if (me->source_cache_file) {
	CTRACE((tfp, "SourceCache: Removing file %s\n",
		me->source_cache_file));
	LYRemoveTemp(me->source_cache_file);
	FREE(me->source_cache_file);
    }
    if (me->source_cache_chunk) {
	CTRACE((tfp, "SourceCache: Removing memory chunk %p\n",
		(void *) me->source_cache_chunk));
	HTChunkFree(me->source_cache_chunk);
	me->source_cache_chunk = NULL;
a770 1
#endif /* USE_SOURCE_CACHE */
d773 4
a776 3
 *	---------------------
 */
HTParentAnchor *HTAnchor_parent(HTAnchor * me)
d778 1
a778 8
    if (!me)
	return NULL;

    if (me->parent->info)
	return me->parent->info;

    /* else: create a new structure */
    return HTParentAnchor_new(me->parent);
d781 3
a783 2
void HTAnchor_setDocument(HTParentAnchor *me,
			  HyperDoc *doc)
d789 2
a790 1
HyperDoc *HTAnchor_document(HTParentAnchor *me)
d792 1
a792 1
    return (me ? me->document : NULL);
d795 3
a797 1
char *HTAnchor_address(HTAnchor * me)
d802 2
a803 3
	if (((HTParentAnchor0 *) me == me->parent) ||
	    ((HTParentAnchor *) me == me->parent->info) ||
	    !((HTChildAnchor *) me)->tag) {	/* it's an adult or no tag */
d805 16
a820 10
	} else {		/* it's a named child */
	    HTSprintf0(&addr, "%s#%s",
		       me->parent->address, ((HTChildAnchor *) me)->tag);
	}
    }
    return (addr);
}

void HTAnchor_setFormat(HTParentAnchor *me,
			HTFormat form)
d826 2
a827 1
HTFormat HTAnchor_format(HTParentAnchor *me)
d829 1
a829 1
    return (me ? me->format : NULL);
d832 3
a834 2
void HTAnchor_setIndex(HTParentAnchor *me,
		       const char *address)
d842 3
a844 2
void HTAnchor_setPrompt(HTParentAnchor *me,
			const char *prompt)
d851 2
a852 1
BOOL HTAnchor_isIndex(HTParentAnchor *me)
d854 1
a854 1
    return (me ? me->isIndex : NO);
d858 10
a867 3
 *	(normally by presence of an ISMAP attribute on A or IMG) - KW
 */
BOOL HTAnchor_isISMAPScript(HTAnchor * me)
d869 1
a869 1
    return ((me && me->parent->info) ? me->parent->info->isISMAPScript : NO);
d872 1
a872 1
#if defined(USE_COLOR_STYLE)
d875 2
a876 1
const char *HTAnchor_style(HTParentAnchor *me)
d878 1
a878 1
    return (me ? me->style : NULL);
d881 3
a883 2
void HTAnchor_setStyle(HTParentAnchor *me,
		       const char *style)
d891 1
d894 2
a895 1
const char *HTAnchor_title(HTParentAnchor *me)
d897 1
a897 1
    return (me ? me->title : NULL);
d900 3
a902 2
void HTAnchor_setTitle(HTParentAnchor *me,
		       const char *title)
d910 2
a911 2
		if (UCH(me->title[i]) == 1 ||
		    UCH(me->title[i]) == 2) {
d916 1
a916 1
	    CTRACE((tfp, "HTAnchor_setTitle: New title is NULL! "));
d918 1
a918 1
		CTRACE((tfp, "Old title was \"%s\".\n", me->title));
d921 1
a921 1
		CTRACE((tfp, "Old title was NULL.\n"));
d927 3
a929 2
void HTAnchor_appendTitle(HTParentAnchor *me,
			  const char *title)
d936 2
a937 2
	    if (UCH(me->title[i]) == 1 ||
		UCH(me->title[i]) == 2) {
d946 2
a947 1
const char *HTAnchor_bookmark(HTParentAnchor *me)
d949 1
a949 1
    return (me ? me->bookmark : NULL);
d952 3
a954 2
void HTAnchor_setBookmark(HTParentAnchor *me,
			  const char *bookmark)
d962 2
a963 1
const char *HTAnchor_owner(HTParentAnchor *me)
d965 1
a965 1
    return (me ? me->owner : NULL);
d968 3
a970 2
void HTAnchor_setOwner(HTParentAnchor *me,
		       const char *owner)
d979 2
a980 1
const char *HTAnchor_RevTitle(HTParentAnchor *me)
d982 1
a982 1
    return (me ? me->RevTitle : NULL);
d985 3
a987 2
void HTAnchor_setRevTitle(HTParentAnchor *me,
			  const char *title)
d994 2
a995 2
	    if (UCH(me->RevTitle[i]) == 1 ||
		UCH(me->RevTitle[i]) == 2) {
a1001 17
#ifndef DISABLE_BIBP
/*	Citehost for bibp links from LINKs with REL="citehost". - RDC
*/
const char *HTAnchor_citehost(HTParentAnchor *me)
{
    return (me ? me->citehost : NULL);
}

void HTAnchor_setCitehost(HTParentAnchor *me,
			  const char *citehost)
{
    if (me) {
	StrAllocCopy(me->citehost, citehost);
    }
}
#endif /* !DISABLE_BIBP */

d1003 2
a1004 10
 *	(will be loaded if we had a Content-Disposition
 *	 header or META element with filename=name.suffix)
 */
const char *HTAnchor_SugFname(HTParentAnchor *me)
{
    return (me ? me->SugFname : NULL);
}

#ifdef EXP_HTTP_HEADERS
/*	HTTP Headers.
d1006 2
a1007 1
const char *HTAnchor_http_headers(HTParentAnchor *me)
d1009 1
a1009 1
    return (me ? me->http_headers.data : NULL);
a1010 1
#endif
d1012 3
a1014 1
/*	Content-Type handling (parameter list).
d1016 2
a1017 1
const char *HTAnchor_content_type_params(HTParentAnchor *me)
d1019 1
a1019 10
    return (me ? me->content_type_params : NULL);
}

/*	Content-Encoding handling. - FM
 *	(will be loaded if we had a Content-Encoding
 *	 header.)
 */
const char *HTAnchor_content_encoding(HTParentAnchor *me)
{
    return (me ? me->content_encoding : NULL);
d1024 2
a1025 1
const char *HTAnchor_content_type(HTParentAnchor *me)
d1027 1
a1027 1
    return (me ? me->content_type : NULL);
d1032 2
a1033 1
const char *HTAnchor_last_modified(HTParentAnchor *me)
d1035 1
a1035 1
    return (me ? me->last_modified : NULL);
d1040 2
a1041 1
const char *HTAnchor_date(HTParentAnchor *me)
d1043 1
a1043 1
    return (me ? me->date : NULL);
d1048 2
a1049 1
const char *HTAnchor_server(HTParentAnchor *me)
d1051 1
a1051 1
    return (me ? me->server : NULL);
d1056 2
a1057 1
BOOL HTAnchor_safe(HTParentAnchor *me)
d1059 1
a1059 1
    return (BOOL) (me ? me->safe : FALSE);
d1064 2
a1065 1
const char *HTAnchor_content_base(HTParentAnchor *me)
d1067 1
a1067 1
    return (me ? me->content_base : NULL);
d1072 2
a1073 1
const char *HTAnchor_content_location(HTParentAnchor *me)
d1075 1
a1075 1
    return (me ? me->content_location : NULL);
d1080 2
a1081 1
const char *HTAnchor_messageID(HTParentAnchor *me)
d1083 1
a1083 1
    return (me ? me->message_id : NULL);
d1086 3
a1088 2
BOOL HTAnchor_setMessageID(HTParentAnchor *me,
			   const char *messageid)
d1099 2
a1100 1
const char *HTAnchor_subject(HTParentAnchor *me)
d1102 1
a1102 1
    return (me ? me->subject : NULL);
d1105 3
a1107 2
BOOL HTAnchor_setSubject(HTParentAnchor *me,
			 const char *subject)
d1116 31
d1148 4
a1151 3
 *	---------------------
 */
HTAnchor *HTAnchor_followLink(HTChildAnchor *me)
d1153 19
a1171 1
    return (me->dest);
d1174 25
a1198 6
HTAnchor *HTAnchor_followTypedLink(HTChildAnchor *me,
				   HTLinkType *type)
{
    if (me->type == type)
	return (me->dest);
    return (NULL);		/* No link of me type */
d1201 1
d1203 4
a1206 3
 *	------------
 */
HTList *HTAnchor_methods(HTParentAnchor *me)
d1211 1
a1211 1
    return (me->methods);
d1215 4
a1218 3
 *	--------
 */
void *HTAnchor_protocol(HTParentAnchor *me)
d1220 1
a1220 1
    return (me->protocol);
d1223 3
a1225 2
void HTAnchor_setProtocol(HTParentAnchor *me,
			  void *protocol)
d1231 4
a1234 3
 *	----------------
 */
char *HTAnchor_physical(HTParentAnchor *me)
d1236 1
a1236 1
    return (me->physical);
d1239 3
a1241 2
void HTAnchor_setPhysical(HTParentAnchor *me,
			  char *physical)
d1249 26
a1274 25
 *  We store charset info in the HTParentAnchor object, for several
 *  "stages".  (See UCDefs.h)
 *  A stream method is supposed to know what stage in the model it is.
 *
 *  General model	MIME	 ->  parser  ->  structured  ->  HText
 *  e.g., text/html
 *	from HTTP:	HTMIME.c ->  SGML.c  ->  HTML.c      ->  GridText.c
 *     text/plain
 *	from file:	HTFile.c ->  HTPlain.c		     ->  GridText.c
 *
 *  The lock/set_by is used to lock e.g. a charset set by an explicit
 *  HTTP MIME header against overriding by a HTML META tag - the MIME
 *  header has higher priority.  Defaults (from -assume_.. options etc.)
 *  will not override charset explicitly given by server.
 *
 *  Some advantages of keeping this in the HTAnchor:
 *  - Global variables are bad.
 *  - Can remember a charset given by META tag when toggling to SOURCE view.
 *  - Can remember a charset given by <A CHARSET=...> href in another doc.
 *
 *  We don't modify the HTParentAnchor's charset element
 *  here, that one will only be set when explicitly given.
 */
LYUCcharset *HTAnchor_getUCInfoStage(HTParentAnchor *me,
				     int which_stage)
d1278 3
a1280 3
	int chndl = UCLYhndl_for_unspec;	/* always >= 0 */
	UCAnchorInfo *stages = typecalloc(UCAnchorInfo);

d1293 4
a1296 4
		 * UCLYhndl_for_unrec not defined :-(
		 * fallback to UCLYhndl_for_unspec which always valid.
		 */
		chndl = UCLYhndl_for_unspec;	/* always >= 0 */
a1299 1

d1305 1
a1305 1
	return (&me->UCStages->s[which_stage].C);
d1307 1
a1307 1
    return (NULL);
d1310 3
a1312 2
int HTAnchor_getUCLYhndl(HTParentAnchor *me,
			 int which_stage)
d1317 1
a1317 1
	     * This will allocate and initialize, if not yet done.
d1322 1
a1322 1
	    return (me->UCStages->s[which_stage].LYhndl);
d1325 1
a1325 1
    return (-1);
d1328 5
a1332 19
#ifdef CAN_SWITCH_DISPLAY_CHARSET
static void setup_switch_display_charset(HTParentAnchor *me, int h)
{
    if (!Switch_Display_Charset(h, SWITCH_DISPLAY_CHARSET_MAYBE))
	return;
    HTAnchor_setUCInfoStage(me, current_char_set,
			    UCT_STAGE_HTEXT, UCT_SETBY_MIME);	/* highest priorty! */
    HTAnchor_setUCInfoStage(me, current_char_set,
			    UCT_STAGE_STRUCTURED, UCT_SETBY_MIME);	/* highest priorty! */
    CTRACE((tfp,
	    "changing UCInfoStage: HTEXT/STRUCTURED stages charset='%s'.\n",
	    LYCharSet_UC[current_char_set].MIMEname));
}
#endif

LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
				     int LYhndl,
				     int which_stage,
				     int set_by)
d1336 1
a1336 1
	 * This will allocate and initialize, if not yet done.
d1338 1
a1338 2
	LYUCcharset *p = HTAnchor_getUCInfoStage(me, which_stage);

d1340 1
a1340 1
	 * Can we override?
a1342 3
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    int ohandle = me->UCStages->s[which_stage].LYhndl;
#endif
d1347 2
a1348 7

#ifdef CAN_SWITCH_DISPLAY_CHARSET
		/* Allow a switch to a more suitable display charset */
		if (LYhndl != ohandle && which_stage == UCT_STAGE_PARSER)
		    setup_switch_display_charset(me, LYhndl);
#endif
	    } else {
d1351 1
a1351 1
	    return (p);
d1354 1
a1354 1
    return (NULL);
d1357 5
a1361 4
LYUCcharset *HTAnchor_resetUCInfoStage(HTParentAnchor *me,
				       int LYhndl,
				       int which_stage,
				       int set_by)
a1362 2
    int ohandle;

d1364 1
a1364 1
	return (NULL);
a1365 1
    ohandle = me->UCStages->s[which_stage].LYhndl;
d1367 1
a1367 6
#ifdef CAN_SWITCH_DISPLAY_CHARSET
    /* Allow a switch to a more suitable display charset */
    if (LYhndl >= 0 && LYhndl != ohandle && which_stage == UCT_STAGE_PARSER)
	setup_switch_display_charset(me, LYhndl);
#endif
    return (&me->UCStages->s[which_stage].C);
d1371 7
a1377 6
 *  A set_by of (-1) means use the lock value from the from_stage.
 */
LYUCcharset *HTAnchor_copyUCInfoStage(HTParentAnchor *me,
				      int to_stage,
				      int from_stage,
				      int set_by)
d1381 1
a1381 1
	 * This will allocate and initialize, if not yet done.
d1383 2
a1384 3
	LYUCcharset *p_from = HTAnchor_getUCInfoStage(me, from_stage);
	LYUCcharset *p_to = HTAnchor_getUCInfoStage(me, to_stage);

d1386 1
a1386 1
	 * Can we override?
a1392 3
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    int ohandle = me->UCStages->s[to_stage].LYhndl;
#endif
a1395 8
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Allow a switch to a more suitable display charset */
	    if (me->UCStages->s[to_stage].LYhndl >= 0
		&& me->UCStages->s[to_stage].LYhndl != ohandle
		&& to_stage == UCT_STAGE_PARSER)
		setup_switch_display_charset(me,
					     me->UCStages->s[to_stage].LYhndl);
#endif
d1398 1
a1398 2

	    return (p_to);
d1401 1
a1401 1
    return (NULL);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a20 1
#include <HTString.h>
a23 2
#include <GridText.h>
#include <LYUtils.h>
d58 1
a58 3
/* Table of lists of all parents */
PRIVATE HTList adult_table[HASH_SIZE] = { {NULL, NULL} };

d67 1
a67 3
PRIVATE HTParentAnchor0 * HTParentAnchor0_new ARGS2(
	CONST char *,	address,
	short,		hash)
d69 2
a70 15
    HTParentAnchor0 *newAnchor = typecalloc(HTParentAnchor0);
    if (newAnchor == NULL)
	outofmem(__FILE__, "HTParentAnchor0_new");

    newAnchor->parent = newAnchor;	/* self */
    StrAllocCopy(newAnchor->address, address);
    newAnchor->adult_hash = hash;

    return(newAnchor);
}

PRIVATE HTParentAnchor * HTParentAnchor_new ARGS1(
	HTParentAnchor0 *,	parent)
{
    HTParentAnchor *newAnchor = typecalloc(HTParentAnchor);
d73 2
a74 5

    newAnchor->parent = parent;		/* cross reference */
    parent->info = newAnchor;		/* cross reference */
    newAnchor->address = parent->address;  /* copy pointer */

d78 4
d83 7
a89 1
    newAnchor->inBASE = FALSE;		/* duplicated from HTML.c/h */
d91 5
d99 1
a99 2
PRIVATE HTChildAnchor * HTChildAnchor_new ARGS1(
	HTParentAnchor0 *,	parent)
d101 1
a101 6
    HTChildAnchor *p = typecalloc(HTChildAnchor);
    if (p == NULL)
	outofmem(__FILE__, "HTChildAnchor_new");

    p->parent = parent;		/* parent reference */
    return p;
a103 11
PRIVATE HTChildAnchor * HText_pool_ChildAnchor_new ARGS1(
	HTParentAnchor *,	parent)
{
    HTChildAnchor *p = (HTChildAnchor *)HText_pool_calloc((HText*)(parent->document),
						sizeof(HTChildAnchor));
    if (p == NULL)
	outofmem(__FILE__, "HText_pool_ChildAnchor_new");

    p->parent = parent->parent;	/* parent reference */
    return p;
}
d106 2
a107 9
/* Case insensitive string comparison */
#define HT_EQUIV(a,b) (TOUPPER(a) == TOUPPER(b))
#else
/* Case sensitive string comparison */
#define HT_EQUIV(a,b) ((a) == (b))
#endif

/*	Null-terminated string comparison
**	---------------------------------
d112 2
a113 2
**	returns YES if the strings are equivalent
**		NO if they differ.
d115 1
a115 1
PRIVATE BOOL HTSEquivalent ARGS2(
d121 1
a121 1
	    if (!HT_EQUIV(*s, *t)) {
d125 1
a125 1
	return(HT_EQUIV(*s, *t));
d127 1
a127 1
	return(s == t);		/* Two NULLs are equivalent, aren't they ? */
d131 4
a134 2
/*	Binary string comparison
**	------------------------
d136 1
a136 1
**	s	Points to one bstring
d139 1
a139 1
**	returns YES if the strings are equivalent
d142 7
a148 9
PRIVATE BOOL HTBEquivalent ARGS2(
	CONST bstring *,	s,
	CONST bstring *,	t)
{
    if (s && t && BStrLen(s) == BStrLen(t)) {
	int j;
	int len = BStrLen(s);
	for (j = 0; j < len; ++j) {
	    if (!HT_EQUIV(BStrData(s)[j], BStrData(t)[j])) {
d152 1
a152 1
	return(YES);
d154 1
a154 1
	return(s == t);		/* Two NULLs are equivalent, aren't they ? */
a156 16

/*
 *  Three-way compare function
 */
PRIVATE int compare_anchors ARGS2(
	void *, l,
	void *, r)
{
    CONST char* a = ((HTChildAnchor *)l)->tag;
    CONST char* b = ((HTChildAnchor *)r)->tag;
    /* both tags are not NULL */

#ifdef CASE_INSENSITIVE_ANCHORS
	return strcasecomp(a, b); /* Case insensitive */
#else
	return strcmp(a, b);      /* Case sensitive - FM */
a157 1
}
d163 2
a164 2
**	This one is for a named child.
**	The parent anchor must already exist.
d166 2
a167 2
PRIVATE HTChildAnchor * HTAnchor_findNamedChild ARGS2(
	HTParentAnchor0 *,	parent,
d171 1
d173 2
a174 30
    if (parent && tag && *tag) {  /* TBL */
	if (parent->children) {
	    /*
	    **  Parent has children.  Search them.
	    */
	    HTChildAnchor sample;
	    sample.tag = (char*)tag;    /* for compare_anchors() only */

	    child = (HTChildAnchor *)HTBTree_search(parent->children, &sample);
	    if (child != NULL) {
		CTRACE((tfp, "Child anchor %p of parent %p with name `%s' already exists.\n",
				(void *)child, (void *)parent, tag));
		return(child);
	    }
	} else {  /* parent doesn't have any children yet : create family */
	    parent->children = HTBTree_new(compare_anchors);
	}

	child = HTChildAnchor_new(parent);
	CTRACE((tfp, "HTAnchor: New Anchor %p named `%s' is child of %p\n",
		(void *)child,
		NonNull(tag),
		(void *)child->parent));

	StrAllocCopy(child->tag, tag);   /* should be set before HTBTree_add */
	HTBTree_add(parent->children, child);
	return(child);

    } else {
	CTRACE((tfp, "HTAnchor_findNamedChild called with NULL parent.\n"));
d177 20
a196 16

}

/*
**	This one is for a new unnamed child being edited into an existing
**	document.  The parent anchor and the document must already exist.
**	(Just add new unnamed child).
*/
PRIVATE HTChildAnchor * HTAnchor_addChild ARGS1(
	HTParentAnchor *,	parent)
{
    HTChildAnchor *child;

    if (!parent) {
	CTRACE((tfp, "HTAnchor_addChild called with NULL parent.\n"));
	return(NULL);
d199 4
a202 2
    child = HText_pool_ChildAnchor_new(parent);
    CTRACE((tfp, "HTAnchor: New unnamed Anchor %p is child of %p\n",
d204 5
a208 5
		(void *)child->parent));

    child->tag = 0;
    HTList_linkObject(&parent->children_notag, child, &child->_add_children_notag);

a212 9
PRIVATE HTParentAnchor0 * HTAnchor_findAddress_in_adult_table PARAMS((
	CONST DocAddress *	newdoc));

PRIVATE BOOL HTAnchor_link PARAMS((
	HTChildAnchor *		child,
	HTAnchor *		destination,
	HTLinkType *		type));


d226 1
a226 5
    HTChildAnchor * child;
    CTRACE((tfp,"Entered HTAnchor_findChildAndLink:  tag=`%s',%s href=`%s'\n",
	       NonNull(tag),
	       (ltype == HTInternalLink) ? " (internal link)" : "",
	       NonNull(href) ));
d228 1
a228 5
    if (tag && *tag) {
	child = HTAnchor_findNamedChild(parent->parent, tag);
    } else {
	child = HTAnchor_addChild(parent);
    }
d231 3
a233 11
	CONST char *fragment = NULL;
	HTParentAnchor0 * dest;

	if (ltype == HTInternalLink && *href == '#') {
	    dest = parent->parent;
	} else {
	    CONST char *relative_to = (parent->inBASE && *href != '#') ?
				parent->content_base : parent->address;
	    DocAddress parsed_doc;
	    parsed_doc.address = HTParse(href, relative_to,
					 PARSE_ALL_WITHOUT_ANCHOR);
d235 10
a246 13
	    if (ltype && parent->post_data && ltype == HTInternalLink) {
		/* for internal links, find a destination with the same
		   post data if the source of the link has post data. - kw
		   Example: LYNXIMGMAP: */
		parsed_doc.post_data = parent->post_data;
		parsed_doc.post_content_type = parent->post_content_type;
	    }
	    parsed_doc.bookmark = NULL;
	    parsed_doc.isHEAD = FALSE;
	    parsed_doc.safe = FALSE;

	    dest = HTAnchor_findAddress_in_adult_table(&parsed_doc);
	    FREE(parsed_doc.address);
d248 4
d253 1
a253 10
	/*
	** [from HTAnchor_findAddress()]
	** If the address represents a sub-anchor, we load its parent (above),
	** then we create a named child anchor within that parent.
	*/
	fragment = (*href == '#') ?  href+1 : HTParseAnchor(href);

	if (*fragment)
	    dest = (HTParentAnchor0 *)HTAnchor_findNamedChild(dest, fragment);

d255 1
d257 15
a271 9
	    if (child->dest) { /* DUPLICATE_ANCHOR_NAME_WORKAROUND  - kw */
		CTRACE((tfp,
			   "*** Duplicate ChildAnchor %p named `%s'",
			   child, tag));
		if ((HTAnchor *)dest != child->dest || ltype != child->type) {
		    CTRACE((tfp,
			   ", different dest %p or type, creating unnamed child\n",
			   child->dest));
		    child = HTAnchor_addChild(parent);
d275 4
a278 1
	HTAnchor_link(child, (HTAnchor *)dest, ltype);
d280 1
a280 1
    return child;
d283 38
d322 2
a323 2
/*	Create new or find old parent anchor
**	------------------------------------
d330 1
a330 1
PUBLIC HTParentAnchor * HTAnchor_findAddress ARGS1(
d334 1
a334 1
    CONST char *tag = HTParseAnchor(newdoc->address);
d336 1
a336 1
    CTRACE((tfp,"Entered HTAnchor_findAddress\n"));
d339 2
a340 2
    **	If the address represents a sub-anchor, we load its parent,
    **	then we create a named child anchor within that parent.
d344 1
a344 1
	HTParentAnchor0 * foundParent;
d348 1
a348 1
				     PARSE_ALL_WITHOUT_ANCHOR);
d355 2
a356 2
	foundParent = HTAnchor_findAddress_in_adult_table(&parsed_doc);
	foundAnchor = HTAnchor_findNamedChild (foundParent, tag);
d358 11
a368 4
	return HTAnchor_parent((HTAnchor *)foundParent);
    }
    return HTAnchor_parent((HTAnchor *)HTAnchor_findAddress_in_adult_table(newdoc));
}
d370 1
d372 15
a386 14
/*  The address has no anchor tag, for sure.
 */
PRIVATE HTParentAnchor0 * HTAnchor_findAddress_in_adult_table ARGS1(
	CONST DocAddress *,	newdoc)
{
    /*
    **  Check whether we have this node.
    */
    int hash;
    HTList * adults;
    HTList *grownups;
    HTParentAnchor0 * foundAnchor;
    BOOL need_extra_info = (newdoc->post_data || newdoc->post_content_type ||
		newdoc->bookmark || newdoc->isHEAD || newdoc->safe);
d388 20
a407 28
    /*
     *  We need not free adult_table[] atexit -
     *  it should be perfectly empty after free'ing all HText's.
     *  (There is an error if it is not empty at exit). -LP
     */

    /*
    **  Select list from hash table,
    */
    hash = HASH_FUNCTION(newdoc->address);
    adults = &(adult_table[hash]);

    /*
    **  Search list for anchor.
    */
    grownups = adults;
    while (NULL != (foundAnchor =
		    (HTParentAnchor0 *)HTList_nextObject(grownups))) {
	if (HTSEquivalent(foundAnchor->address, newdoc->address) &&

	    ((!foundAnchor->info && !need_extra_info) ||
	     (foundAnchor->info &&
	      HTBEquivalent(foundAnchor->info->post_data, newdoc->post_data) &&
	      foundAnchor->info->isHEAD == newdoc->isHEAD)))
	{
	    CTRACE((tfp, "Anchor %p with address `%s' already exists.\n",
			(void *)foundAnchor, newdoc->address));
	    return foundAnchor;
a408 12
    }

    /*
    **  Node not found: create new anchor.
    */
    foundAnchor = HTParentAnchor0_new(newdoc->address, hash);
    CTRACE((tfp, "New anchor %p has hash %d and address `%s'\n",
		(void *)foundAnchor, hash, newdoc->address));

    if (need_extra_info) {
	/* rare case, create a big structure */
	HTParentAnchor *p = HTParentAnchor_new(foundAnchor);
d410 7
d418 1
a418 1
	    BStrCopy(p->post_data, newdoc->post_data);
d420 2
a421 2
	    StrAllocCopy(p->post_content_type,
		     newdoc->post_content_type);
d423 5
a427 3
	    StrAllocCopy(p->bookmark, newdoc->bookmark);
	p->isHEAD = newdoc->isHEAD;
	p->safe = newdoc->safe;
a428 51
    HTList_linkObject(adults, foundAnchor, &foundAnchor->_add_adult);

    return foundAnchor;
}

/*	Create new or find old named anchor - simple form
**	-------------------------------------------------
**
**     Like HTAnchor_findAddress, but simpler to use for simple cases.
**	No post data etc. can be supplied. - kw
*/
PUBLIC HTParentAnchor * HTAnchor_findSimpleAddress ARGS1(
	CONST char *,	url)
{
    DocAddress urldoc;

    urldoc.address = (char *)url; /* ignore warning, it IS treated like const - kw */
    urldoc.post_data = NULL;
    urldoc.post_content_type = NULL;
    urldoc.bookmark = NULL;
    urldoc.isHEAD = FALSE;
    urldoc.safe = FALSE;
    return HTAnchor_findAddress(&urldoc);
}


/*	Link me Anchor to another given one
**	-------------------------------------
*/
PRIVATE BOOL HTAnchor_link ARGS3(
	HTChildAnchor *,	child,
	HTAnchor *,		destination,
	HTLinkType *,		type)
{
    if (!(child && destination))
	return(NO);  /* Can't link to/from non-existing anchor */

    CTRACE((tfp, "Linking child %p to anchor %p\n", child, destination));
    if (child->dest) {
	CTRACE((tfp, "*** child anchor already has destination, exiting!\n"));
	return(NO);
    }

    child->dest = destination;
    child->type = type;

    if (child->parent != destination->parent)
	/* link only foreign children */
	HTList_linkObject(&destination->parent->sources, child, &child->_add_sources);

    return(YES);  /* Success */
d436 2
a437 2
**	All outgoing links from children are deleted, and children are
**	removed from the sources lists of theirs targets.
d439 1
a439 1
**	If this anchor's sources list is empty, we delete it and its children.
a440 6

/*
 *	Recursively try to delete destination anchor of this child.
 *	In any event, this will tell destination anchor that we
 *	no longer consider it a destination.
 */
d442 1
a442 1
	HTChildAnchor *,	me)
d445 2
a446 1
     *	Unregister me with our destination anchor's parent.
d448 13
a460 2
    if (me->dest) {
	HTParentAnchor0 *parent = me->dest->parent;
d463 4
a466 1
	 *  Start.  Set the dest pointer to zero.
d468 1
a468 1
	 me->dest = NULL;
d472 1
a472 1
	 *  parent knows one less anchor is its dest.
d474 1
a474 1
	if ((me->parent != parent) && !HTList_isEmpty(&parent->sources)) {
d478 1
a478 1
	    HTList_unlinkObject(&parent->sources, (void *)me);
a481 1
	 *  Recursive call.
d483 6
a488 1
	 *  Don't delete if document is loaded or being loaded.
d490 3
a492 2
	if ((me->parent != parent) && !parent->underway &&
	    (!parent->info || !parent->info->document)) {
d497 1
a497 1
	 *  At this point, we haven't a destination.  Set it to be
d502 1
a502 1
	me->type = NULL;
a503 1
}
d505 54
d560 8
a567 2
PRIVATE void HTParentAnchor_free PARAMS((
	HTParentAnchor *	me));
d570 1
a570 1
	HTParentAnchor0 *,	me)
d576 1
a576 1
    HTBTElement *ele;
d589 1
a589 1
    if (me->underway || (me->info && me->info->document)) {
d595 1
a595 1
     *  on this HTParentAnchor0 will not free it from under our feet. - kw
d599 14
a612 1
    {
d614 2
a615 2
	 *  Delete all outgoing links from named children.
	 *  Do not delete named children itself (may have incoming links).
d617 6
a622 7
	if (me->children) {
	    ele = HTBTree_next(me->children, NULL);
	    while (ele != NULL) {
		child = (HTChildAnchor *)HTBTree_object(ele);
		if (child->dest)
		    deleteLinks(child);
		ele = HTBTree_next(me->children, ele);
d625 1
a625 3
    }
    me->underway = FALSE;

a626 5
    /*
     * There are still incoming links to this one (we are the
     * destination of another anchor).
     */
    if (!HTList_isEmpty(&me->sources)) {
d634 2
a635 2
     *	No more incoming and outgoing links : kill everything
     *	First, delete named children.
d637 10
a646 7
    if (me->children) {
	ele = HTBTree_next(me->children, NULL);
	while (ele != NULL) {
	    child = (HTChildAnchor *)HTBTree_object(ele);
	    FREE(child->tag);
	    FREE(child);
	    ele = HTBTree_next(me->children, ele);
a647 1
	HTBTree_free(me->children);
d649 1
d652 1
a652 1
     *  Delete the ParentAnchor, if any. (Document was already deleted).
d654 3
a656 3
    if (me->info) {
	HTParentAnchor_free(me->info);
	FREE(me->info);
d660 1
a660 1
     *	Remove ourselves from the hash table's list.
d662 3
a664 31
    HTList_unlinkObject(&(adult_table[me->adult_hash]), (void *)me);

    /*
     *	Free the address.
     */
    FREE(me->address);

    /*
     *	Finally, kill the parent anchor passed in.
     */
    FREE(me);

    return(YES);
}

/*
 *  Unnamed children (children_notag) have no sence without HText -
 *  delete them and their links if we are about to free HText.
 *  Document currently exists. Called within HText_free().
 */
PUBLIC void HTAnchor_delete_links ARGS1(
	HTParentAnchor *,	me)
{
    HTList *cur;
    HTChildAnchor *child;

    /*
     *	Do nothing if nothing to do.
     */
    if (!me || !me->document) {
	return;
a667 24
     *  Mark ourselves busy, so that recursive calls
     *  on this HTParentAnchor0 will not free it from under our feet. - kw
     */
    me->parent->underway = TRUE;

    /*
     *  Delete all outgoing links from unnamed children.
     */
    if (!HTList_isEmpty(&me->children_notag)) {
	cur = &me->children_notag;
	while ((child =
		(HTChildAnchor *)HTList_unlinkLastObject(cur)) != 0) {
	    deleteLinks(child);
	    /* child allocated in HText pool, HText_free() will free it later*/
	}
    }
    me->parent->underway = FALSE;
}


PRIVATE void HTParentAnchor_free ARGS1(
	HTParentAnchor *,	me)
{
    /*
d687 1
a687 1
    BStrFree(me->post_data);
a691 4
    FREE(me->citehost);
#ifdef SOURCE_CACHE
    HTAnchor_clearSourceCache(me);
#endif
a712 1

d716 1
a716 1
#ifdef USE_COLOR_STYLE
d721 11
d738 6
a743 1
    FREE(me->UCStages);
d745 8
d755 9
a763 3
#ifdef SOURCE_CACHE
PUBLIC void HTAnchor_clearSourceCache ARGS1(
	HTParentAnchor *,	me)
d765 4
a768 14
    /*
     * Clean up the source cache, if any.
     */
    if (me->source_cache_file) {
	CTRACE((tfp, "SourceCache: Removing file %s\n",
	       me->source_cache_file));
	LYRemoveTemp(me->source_cache_file);
	FREE(me->source_cache_file);
    }
    if (me->source_cache_chunk) {
	CTRACE((tfp, "SourceCache: Removing memory chunk %p\n",
	       (void *)me->source_cache_chunk));
	HTChunkFree(me->source_cache_chunk);
	me->source_cache_chunk = NULL;
a770 1
#endif /* SOURCE_CACHE */
d778 1
a778 8
    if (!me)
	return NULL;

    if (me->parent->info)
	return me->parent->info;

    /* else: create a new structure */
    return HTParentAnchor_new(me->parent);
d802 1
a802 2
	if (((HTParentAnchor0 *)me == me->parent) ||
	    ((HTParentAnchor *)me == me->parent->info) ||
d806 7
a812 2
	    HTSprintf0(&addr, "%s#%s",
		       me->parent->address, ((HTChildAnchor *)me)->tag);
d834 1
a834 1
	CONST char *,		address)
d844 1
a844 1
	CONST char *,		prompt)
d863 7
a869 1
    return( (me && me->parent->info) ? me->parent->info->isISMAPScript : NO);
d872 1
a872 1
#if defined(USE_COLOR_STYLE)
d910 2
a911 2
		if (UCH(me->title[i]) == 1 ||
		    UCH(me->title[i]) == 2) {
d916 1
a916 1
	    CTRACE((tfp,"HTAnchor_setTitle: New title is NULL! "));
d918 1
a918 1
		CTRACE((tfp,"Old title was \"%s\".\n", me->title));
d921 1
a921 1
		CTRACE((tfp,"Old title was NULL.\n"));
d936 2
a937 2
	    if (UCH(me->title[i]) == 1 ||
		UCH(me->title[i]) == 2) {
d994 2
a995 2
	    if (UCH(me->RevTitle[i]) == 1 ||
		UCH(me->RevTitle[i]) == 2) {
a1001 19
#ifndef DISABLE_BIBP
/*	Citehost for bibp links from LINKs with REL="citehost". - RDC
*/
PUBLIC CONST char * HTAnchor_citehost ARGS1(
	HTParentAnchor *,	me)
{
    return( me ? me->citehost : NULL);
}

PUBLIC void HTAnchor_setCitehost ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		citehost)
{
    if (me) {
	StrAllocCopy(me->citehost, citehost);
    }
}
#endif /* !DISABLE_BIBP */

d1059 1
a1059 1
    return (BOOL) ( me ? me->safe : FALSE);
d1116 31
d1150 2
a1151 2
PUBLIC HTAnchor * HTAnchor_followLink ARGS1(
	HTChildAnchor *,	me)
d1153 1
a1153 1
    return( me->dest);
d1157 2
a1158 2
	HTChildAnchor *,	me,
	HTLinkType *,		type)
d1160 11
a1170 2
    if (me->type == type)
	return( me->dest);
d1175 27
d1241 1
a1241 1
	char *,			physical)
d1279 2
a1280 1
	UCAnchorInfo * stages = typecalloc(UCAnchorInfo);
a1327 14
#ifdef CAN_SWITCH_DISPLAY_CHARSET
PRIVATE void setup_switch_display_charset ARGS2(HTParentAnchor *, me, int, h)
{
    if (!Switch_Display_Charset(h,SWITCH_DISPLAY_CHARSET_MAYBE))
	return;
    HTAnchor_setUCInfoStage(me, current_char_set,
			    UCT_STAGE_HTEXT, UCT_SETBY_MIME); /* highest priorty! */
    HTAnchor_setUCInfoStage(me, current_char_set,
			    UCT_STAGE_STRUCTURED, UCT_SETBY_MIME); /* highest priorty! */
    CTRACE((tfp, "changing UCInfoStage: HTEXT/STRUCTURED stages charset='%s'.\n",
	    LYCharSet_UC[current_char_set].MIMEname));
}
#endif

a1342 3
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    int ohandle = me->UCStages->s[which_stage].LYhndl;
#endif
a1346 5
#ifdef CAN_SWITCH_DISPLAY_CHARSET
		/* Allow a switch to a more suitable display charset */
		if ( LYhndl != ohandle && which_stage == UCT_STAGE_PARSER )
		    setup_switch_display_charset(me, LYhndl);
#endif
a1362 2
    int ohandle;

a1365 1
    ohandle = me->UCStages->s[which_stage].LYhndl;
a1366 5
#ifdef CAN_SWITCH_DISPLAY_CHARSET
    /* Allow a switch to a more suitable display charset */
    if (LYhndl >= 0 && LYhndl != ohandle && which_stage == UCT_STAGE_PARSER)
	setup_switch_display_charset(me, LYhndl);
#endif
a1392 3
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    int ohandle = me->UCStages->s[to_stage].LYhndl;
#endif
a1395 8
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Allow a switch to a more suitable display charset */
	    if ( me->UCStages->s[to_stage].LYhndl >= 0
		 && me->UCStages->s[to_stage].LYhndl != ohandle
		 && to_stage == UCT_STAGE_PARSER )
		setup_switch_display_charset(me,
					     me->UCStages->s[to_stage].LYhndl);
#endif
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d772 1
a772 1
#ifdef USE_SOURCE_CACHE
d815 1
a815 1
#ifdef USE_SOURCE_CACHE
d835 1
a835 1
#endif /* USE_SOURCE_CACHE */
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d42 2
a43 2
static int HASH_FUNCTION (
	const char *	cp_address)
d46 1
a46 1
    const unsigned char *p;
d48 2
a49 2
    for (p = (const unsigned char *)cp_address, hash = 0; *p; p++)
	hash = (int) (hash * 3 + (*(const unsigned char *)p)) % HASH_SIZE;
d62 1
a62 1
static HTList adult_table[HASH_SIZE] = { {NULL, NULL} };
d72 3
a74 3
static HTParentAnchor0 * HTParentAnchor0_new (
	const char *	address,
	short		hash)
d87 2
a88 2
static HTParentAnchor * HTParentAnchor_new (
	HTParentAnchor0 *	parent)
d107 2
a108 2
static HTChildAnchor * HTChildAnchor_new (
	HTParentAnchor0 *	parent)
d118 2
a119 2
static HTChildAnchor * HText_pool_ChildAnchor_new (
	HTParentAnchor *	parent)
d147 3
a149 3
static BOOL HTSEquivalent (
	const char *	s,
	const char *	t)
d172 3
a174 3
static BOOL HTBEquivalent (
	const bstring *	s,
	const bstring *	t)
d193 3
a195 3
static int compare_anchors (
	void * l,
	void * r)
d197 2
a198 2
    const char* a = ((HTChildAnchor *)l)->tag;
    const char* b = ((HTChildAnchor *)r)->tag;
d215 3
a217 3
static HTChildAnchor * HTAnchor_findNamedChild (
	HTParentAnchor0 *	parent,
	const char *		tag)
d261 2
a262 2
static HTChildAnchor * HTAnchor_addChild (
	HTParentAnchor *	parent)
d283 2
a284 2
static HTParentAnchor0 * HTAnchor_findAddress_in_adult_table (
	const DocAddress *	newdoc);
d286 1
a286 1
static BOOL HTAnchor_link (
d289 1
a289 1
	HTLinkType *		type);
d299 5
a303 5
HTChildAnchor * HTAnchor_findChildAndLink (
	HTParentAnchor *	parent, /* May not be 0   */
	const char *		tag,	/* May be "" or 0 */
	const char *		href,	/* May be "" or 0 */
	HTLinkType *		ltype)	/* May be 0	  */
d318 1
a318 1
	const char *fragment = NULL;
d324 1
a324 1
	    const char *relative_to = (parent->inBASE && *href != '#') ?
d385 2
a386 2
HTParentAnchor * HTAnchor_findAddress (
	const DocAddress *	newdoc)
d389 1
a389 1
    const char *tag = HTParseAnchor(newdoc->address);
d421 2
a422 2
static HTParentAnchor0 * HTAnchor_findAddress_in_adult_table (
	const DocAddress *	newdoc)
d497 2
a498 2
HTParentAnchor * HTAnchor_findSimpleAddress (
	const char *	url)
d515 4
a518 4
static BOOL HTAnchor_link (
	HTChildAnchor *	child,
	HTAnchor *		destination,
	HTLinkType *		type)
d555 2
a556 2
static void deleteLinks (
	HTChildAnchor *	me)
d601 2
a602 2
static void HTParentAnchor_free (
	HTParentAnchor *	me);
d604 2
a605 2
BOOL HTAnchor_delete (
	HTParentAnchor0 *	me)
d709 2
a710 2
void HTAnchor_delete_links (
	HTParentAnchor *	me)
d743 2
a744 2
static void HTParentAnchor_free (
	HTParentAnchor *	me)
d816 2
a817 2
void HTAnchor_clearSourceCache (
	HTParentAnchor *	me)
d840 2
a841 2
HTParentAnchor * HTAnchor_parent (
	HTAnchor *	me)
d853 3
a855 3
void HTAnchor_setDocument (
	HTParentAnchor *	me,
	HyperDoc *		doc)
d861 2
a862 2
HyperDoc * HTAnchor_document (
	HTParentAnchor *	me)
d868 2
a869 2
char * HTAnchor_address (
	HTAnchor *	me)
d886 3
a888 3
void HTAnchor_setFormat (
	HTParentAnchor *	me,
	HTFormat		form)
d894 2
a895 2
HTFormat HTAnchor_format (
	HTParentAnchor *	me)
d900 3
a902 3
void HTAnchor_setIndex (
	HTParentAnchor *	me,
	const char *		address)
d910 3
a912 3
void HTAnchor_setPrompt (
	HTParentAnchor *	me,
	const char *		prompt)
d919 2
a920 2
BOOL HTAnchor_isIndex (
	HTParentAnchor *	me)
d928 2
a929 2
BOOL HTAnchor_isISMAPScript (
	HTAnchor *	me)
d937 2
a938 2
const char * HTAnchor_style (
	HTParentAnchor *	me)
d943 3
a945 3
void HTAnchor_setStyle (
	HTParentAnchor *	me,
	const char *		style)
d956 2
a957 2
const char * HTAnchor_title (
	HTParentAnchor *	me)
d962 3
a964 3
void HTAnchor_setTitle (
	HTParentAnchor *	me,
	const char *		title)
d989 3
a991 3
void HTAnchor_appendTitle (
	HTParentAnchor *	me,
	const char *		title)
d1008 2
a1009 2
const char * HTAnchor_bookmark (
	HTParentAnchor *	me)
d1014 3
a1016 3
void HTAnchor_setBookmark (
	HTParentAnchor *	me,
	const char *		bookmark)
d1024 2
a1025 2
const char * HTAnchor_owner (
	HTParentAnchor *	me)
d1030 3
a1032 3
void HTAnchor_setOwner (
	HTParentAnchor *	me,
	const char *		owner)
d1041 2
a1042 2
const char * HTAnchor_RevTitle (
	HTParentAnchor *	me)
d1047 3
a1049 3
void HTAnchor_setRevTitle (
	HTParentAnchor *	me,
	const char *		title)
d1067 2
a1068 2
const char * HTAnchor_citehost (
	HTParentAnchor *	me)
d1073 3
a1075 3
void HTAnchor_setCitehost (
	HTParentAnchor *	me,
	const char *		citehost)
d1087 2
a1088 2
const char * HTAnchor_SugFname (
	HTParentAnchor *	me)
d1097 2
a1098 2
const char * HTAnchor_content_encoding (
	HTParentAnchor *	me)
d1105 2
a1106 2
const char * HTAnchor_content_type (
	HTParentAnchor *	me)
d1113 2
a1114 2
const char * HTAnchor_last_modified (
	HTParentAnchor *	me)
d1121 2
a1122 2
const char * HTAnchor_date (
	HTParentAnchor *	me)
d1129 2
a1130 2
const char * HTAnchor_server (
	HTParentAnchor *	me)
d1137 2
a1138 2
BOOL HTAnchor_safe (
	HTParentAnchor *	me)
d1145 2
a1146 2
const char * HTAnchor_content_base (
	HTParentAnchor *	me)
d1153 2
a1154 2
const char * HTAnchor_content_location (
	HTParentAnchor *	me)
d1161 2
a1162 2
const char * HTAnchor_messageID (
	HTParentAnchor *	me)
d1167 3
a1169 3
BOOL HTAnchor_setMessageID (
	HTParentAnchor *	me,
	const char *		messageid)
d1180 2
a1181 2
const char * HTAnchor_subject (
	HTParentAnchor *	me)
d1186 3
a1188 3
BOOL HTAnchor_setSubject (
	HTParentAnchor *	me,
	const char *		subject)
d1200 2
a1201 2
HTAnchor * HTAnchor_followLink (
	HTChildAnchor *	me)
d1206 3
a1208 3
HTAnchor * HTAnchor_followTypedLink (
	HTChildAnchor *	me,
	HTLinkType *		type)
d1219 2
a1220 2
HTList * HTAnchor_methods (
	HTParentAnchor *	me)
d1231 2
a1232 2
void * HTAnchor_protocol (
	HTParentAnchor *	me)
d1237 3
a1239 3
void HTAnchor_setProtocol (
	HTParentAnchor *	me,
	void*			protocol)
d1247 2
a1248 2
char * HTAnchor_physical (
	HTParentAnchor *	me)
d1253 3
a1255 3
void HTAnchor_setPhysical (
	HTParentAnchor *	me,
	char *			physical)
d1286 3
a1288 3
LYUCcharset * HTAnchor_getUCInfoStage (
	HTParentAnchor *	me,
	int			which_stage)
d1323 3
a1325 3
int HTAnchor_getUCLYhndl (
	HTParentAnchor *	me,
	int			which_stage)
d1342 1
a1342 1
static void setup_switch_display_charset (HTParentAnchor * me, int h)
d1355 5
a1359 5
LYUCcharset * HTAnchor_setUCInfoStage (
	HTParentAnchor *	me,
	int			LYhndl,
	int			which_stage,
	int			set_by)
d1392 5
a1396 5
LYUCcharset * HTAnchor_resetUCInfoStage (
	HTParentAnchor *	me,
	int			LYhndl,
	int			which_stage,
	int			set_by)
d1416 5
a1420 5
LYUCcharset * HTAnchor_copyUCInfoStage (
	HTParentAnchor *	me,
	int			to_stage,
	int			from_stage,
	int			set_by)
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 13
a14 13
 *	==========================
 *
 * An anchor represents a region of a hypertext document which is linked to
 * another anchor in the same or a different document.
 *
 * History
 *
 *	   Nov 1990  Written in Objective-C for the NeXT browser (TBL)
 *	24-Oct-1991 (JFG), written in C, browser-independent
 *	21-Nov-1991 (JFG), first complete version
 *
 *	(c) Copyright CERN 1991 - See Copyright.html
 */
d42 2
a43 1
static int HASH_FUNCTION(const char *cp_address)
d48 2
a49 2
    for (p = (const unsigned char *) cp_address, hash = 0; *p; p++)
	hash = (int) (hash * 3 + (*(const unsigned char *) p)) % HASH_SIZE;
d51 1
a51 1
    return (hash);
a54 1

d57 1
a57 1
    int junk;			/* VMS cannot handle pointers to undefined structs */
d62 2
a63 3
static HTList adult_table[HASH_SIZE] =
{
    {NULL, NULL}};
d66 9
a74 8
 *				================
 *
 *	Do not use "new" by itself outside this module.  In order to enforce
 *	consistency, we insist that you furnish more information about the
 *	anchor you are creating : use newWithParent or newWithAddress.
 */
static HTParentAnchor0 *HTParentAnchor0_new(const char *address,
					    short hash)
a76 1

d84 1
a84 1
    return (newAnchor);
d87 2
a88 1
static HTParentAnchor *HTParentAnchor_new(HTParentAnchor0 *parent)
a90 1

d94 3
a96 3
    newAnchor->parent = parent;	/* cross reference */
    parent->info = newAnchor;	/* cross reference */
    newAnchor->address = parent->address;	/* copy pointer */
d99 2
a100 2
    newAnchor->isHEAD = FALSE;	/* HEAD request if TRUE. - FM */
    newAnchor->safe = FALSE;	/* Safe. - FM */
d102 1
a102 1
    newAnchor->inBASE = FALSE;	/* duplicated from HTML.c/h */
d104 1
a104 1
    return (newAnchor);
d107 2
a108 1
static HTChildAnchor *HTChildAnchor_new(HTParentAnchor0 *parent)
a110 1

d118 2
a119 1
static HTChildAnchor *HText_pool_ChildAnchor_new(HTParentAnchor *parent)
d121 2
a122 3
    HTChildAnchor *p = (HTChildAnchor *) HText_pool_calloc((HText *) (parent->document),
							   sizeof(HTChildAnchor));

d139 11
a149 10
 *	---------------------------------
 * On entry,
 *	s	Points to one string, null terminated
 *	t	points to the other.
 * On exit,
 *	returns YES if the strings are equivalent
 *		NO if they differ.
 */
static BOOL HTSEquivalent(const char *s,
			  const char *t)
d151 1
a151 1
    if (s && t) {		/* Make sure they point to something */
d154 1
a154 1
		return (NO);
d157 1
a157 1
	return (HT_EQUIV(*s, *t));
d159 1
a159 1
	return (s == t);	/* Two NULLs are equivalent, aren't they ? */
d164 11
a174 10
 *	------------------------
 * On entry,
 *	s	Points to one bstring
 *	t	points to the other.
 * On exit,
 *	returns YES if the strings are equivalent
 *		NO if they differ.
 */
static BOOL HTBEquivalent(const bstring *s,
			  const bstring *t)
a178 1

d181 1
a181 1
		return (NO);
d184 1
a184 1
	return (YES);
d186 1
a186 1
	return (s == t);	/* Two NULLs are equivalent, aren't they ? */
d191 1
a191 1
 * Three-way compare function
d193 3
a195 2
static int compare_anchors(void *l,
			   void *r)
d197 2
a198 3
    const char *a = ((HTChildAnchor *) l)->tag;
    const char *b = ((HTChildAnchor *) r)->tag;

d202 1
a202 1
    return strcasecomp(a, b);	/* Case insensitive */
d204 1
a204 1
    return strcmp(a, b);	/* Case sensitive - FM */
d208 1
d210 8
a217 7
 *	---------------------------------
 *
 *	This one is for a named child.
 *	The parent anchor must already exist.
 */
static HTChildAnchor *HTAnchor_findNamedChild(HTParentAnchor0 *parent,
					      const char *tag)
d221 1
a221 1
    if (parent && tag && *tag) {	/* TBL */
d224 2
a225 2
	     * Parent has children.  Search them.
	     */
d227 1
d229 1
a229 3
	    sample.tag = (char *) tag;	/* for compare_anchors() only */

	    child = (HTChildAnchor *) HTBTree_search(parent->children, &sample);
d231 3
a233 4
		CTRACE((tfp,
			"Child anchor %p of parent %p with name `%s' already exists.\n",
			(void *) child, (void *) parent, tag));
		return (child);
d235 1
a235 1
	} else {		/* parent doesn't have any children yet : create family */
d241 1
a241 1
		(void *) child,
d243 1
a243 1
		(void *) child->parent));
d245 1
a245 1
	StrAllocCopy(child->tag, tag);	/* should be set before HTBTree_add */
d247 1
a247 1
	return (child);
d251 1
a251 1
	return (NULL);
d257 6
a262 5
 *	This one is for a new unnamed child being edited into an existing
 *	document.  The parent anchor and the document must already exist.
 *	(Just add new unnamed child).
 */
static HTChildAnchor *HTAnchor_addChild(HTParentAnchor *parent)
d268 1
a268 1
	return (NULL);
d273 2
a274 2
	    (void *) child,
	    (void *) child->parent));
d279 1
a279 1
    return (child);
a281 1
static HTParentAnchor0 *HTAnchor_findAddress_in_adult_table(const DocAddress *newdoc);
d283 8
a290 3
static BOOL HTAnchor_link(HTChildAnchor *child,
			  HTAnchor * destination,
			  HTLinkType *type);
d293 17
a309 17
 *	--------------------------------------------------
 *
 *	Create new anchor with a given parent and possibly
 *	a name, and possibly a link to a _relatively_ named anchor.
 *	(Code originally in ParseHTML.h)
 */
HTChildAnchor *HTAnchor_findChildAndLink(HTParentAnchor *parent,	/* May not be 0   */
					 const char *tag,	/* May be "" or 0 */
					 const char *href,	/* May be "" or 0 */
					 HTLinkType *ltype)	/* May be 0       */
{
    HTChildAnchor *child;

    CTRACE((tfp, "Entered HTAnchor_findChildAndLink:  tag=`%s',%s href=`%s'\n",
	    NonNull(tag),
	    (ltype == HTInternalLink) ? " (internal link)" : "",
	    NonNull(href)));
d319 1
a319 1
	HTParentAnchor0 *dest;
d325 1
a325 1
	    parent->content_base : parent->address;
a326 1

d348 5
a352 5
	 * [from HTAnchor_findAddress()]
	 * If the address represents a sub-anchor, we load its parent (above),
	 * then we create a named child anchor within that parent.
	 */
	fragment = (*href == '#') ? href + 1 : HTParseAnchor(href);
d355 2
a356 1
	    dest = (HTParentAnchor0 *) HTAnchor_findNamedChild(dest, fragment);
d359 1
a359 1
	    if (child->dest) {	/* DUPLICATE_ANCHOR_NAME_WORKAROUND  - kw */
d361 3
a363 3
			"*** Duplicate ChildAnchor %p named `%s'",
			child, tag));
		if ((HTAnchor *) dest != child->dest || ltype != child->type) {
d365 2
a366 2
			    ", different dest %p or type, creating unnamed child\n",
			    child->dest));
d371 1
a371 1
	HTAnchor_link(child, (HTAnchor *) dest, ltype);
d376 1
d378 9
a386 8
 *	------------------------------------
 *
 *	Me one is for a reference which is found in a document, and might
 *	not be already loaded.
 *	Note: You are not guaranteed a new anchor -- you might get an old one,
 *	like with fonts.
 */
HTParentAnchor *HTAnchor_findAddress(const DocAddress *newdoc)
d391 1
a391 1
    CTRACE((tfp, "Entered HTAnchor_findAddress\n"));
d394 3
a396 3
     * If the address represents a sub-anchor, we load its parent, then we
     * create a named child anchor within that parent.
     */
d399 2
a400 2
	HTParentAnchor0 *foundParent;
	HTChildAnchor *foundAnchor;
d411 1
a411 1
	foundAnchor = HTAnchor_findNamedChild(foundParent, tag);
d413 1
a413 1
	return HTAnchor_parent((HTAnchor *) foundParent);
d415 1
a415 1
    return HTAnchor_parent((HTAnchor *) HTAnchor_findAddress_in_adult_table(newdoc));
d418 1
d421 2
a422 1
static HTParentAnchor0 *HTAnchor_findAddress_in_adult_table(const DocAddress *newdoc)
d425 2
a426 2
     * Check whether we have this node.
     */
d428 1
a428 1
    HTList *adults;
d430 1
a430 1
    HTParentAnchor0 *foundAnchor;
d432 1
a432 1
			    newdoc->bookmark || newdoc->isHEAD || newdoc->safe);
d435 3
a437 3
     * We need not free adult_table[] atexit - it should be perfectly empty
     * after free'ing all HText's.  (There is an error if it is not empty at
     * exit).  -LP
d441 2
a442 2
     * Select list from hash table,
     */
d447 2
a448 2
     * Search list for anchor.
     */
d451 1
a451 1
		    (HTParentAnchor0 *) HTList_nextObject(grownups))) {
d457 2
a458 1
	      foundAnchor->info->isHEAD == newdoc->isHEAD))) {
d460 1
a460 1
		    (void *) foundAnchor, newdoc->address));
d466 2
a467 2
     * Node not found:  create new anchor.
     */
d470 1
a470 1
	    (void *) foundAnchor, hash, newdoc->address));
d480 1
a480 1
			 newdoc->post_content_type);
d492 7
a498 6
 *	-------------------------------------------------
 *
 *     Like HTAnchor_findAddress, but simpler to use for simple cases.
 *	No post data etc. can be supplied. - kw
 */
HTParentAnchor *HTAnchor_findSimpleAddress(const char *url)
d502 1
a502 1
    urldoc.address = (char *) url;	/* ignore warning, it IS treated like const - kw */
d511 1
d513 6
a518 5
 *	-------------------------------------
 */
static BOOL HTAnchor_link(HTChildAnchor *child,
			  HTAnchor * destination,
			  HTLinkType *type)
d521 1
a521 1
	return (NO);		/* Can't link to/from non-existing anchor */
d526 1
a526 1
	return (NO);
d536 1
a536 1
    return (YES);		/* Success */
d539 1
d541 8
a548 8
 *	--------------------------------------------
 *
 *	The anchor is only deleted if the corresponding document is not loaded.
 *	All outgoing links from children are deleted, and children are
 *	removed from the sources lists of theirs targets.
 *	We also try to delete the targets whose documents are not loaded.
 *	If this anchor's sources list is empty, we delete it and its children.
 */
d555 2
a556 1
static void deleteLinks(HTChildAnchor *me)
d559 1
a559 1
     * Unregister me with our destination anchor's parent.
d565 1
a565 1
	 * Start.  Set the dest pointer to zero.
d567 1
a567 1
	me->dest = NULL;
d570 2
a571 2
	 * Remove me from the parent's sources so that the parent knows one
	 * less anchor is its dest.
d575 1
a575 1
	     * Really should only need to deregister once.
d577 1
a577 1
	    HTList_unlinkObject(&parent->sources, (void *) me);
d581 3
a583 2
	 * Recursive call.  Test here to avoid calling overhead.  Don't delete
	 * if document is loaded or being loaded.
d591 4
a594 3
	 * At this point, we haven't a destination.  Set it to be so.  Leave
	 * the HTAtom pointed to by type up to other code to handle (reusable,
	 * near static).
a599 1
static void HTParentAnchor_free(HTParentAnchor *me);
d601 5
a605 1
BOOL HTAnchor_delete(HTParentAnchor0 *me)
d608 1
a608 1
     * Memory leaks fixed.
d615 1
a615 1
     * Do nothing if nothing to do.
d618 1
a618 1
	return (NO);
d622 1
a622 1
     * Don't delete if document is loaded or being loaded.
d625 1
a625 1
	return (NO);
d629 2
a630 2
     * Mark ourselves busy, so that recursive calls of this function on this
     * HTParentAnchor0 will not free it from under our feet.  - kw
d636 2
a637 2
	 * Delete all outgoing links from named children.  Do not delete named
	 * children itself (may have incoming links).
d642 1
a642 1
		child = (HTChildAnchor *) HTBTree_object(ele);
d651 1
d658 1
a658 1
	 * Can't delete parent, still have sources.
d660 1
a660 1
	return (NO);
d664 2
a665 2
     * No more incoming and outgoing links :  kill everything First, delete
     * named children.
d670 1
a670 1
	    child = (HTChildAnchor *) HTBTree_object(ele);
d679 1
a679 1
     * Delete the ParentAnchor, if any.  (Document was already deleted).
d687 1
a687 1
     * Remove ourselves from the hash table's list.
d689 1
a689 1
    HTList_unlinkObject(&(adult_table[me->adult_hash]), (void *) me);
d692 1
a692 1
     * Free the address.
d697 1
a697 1
     * Finally, kill the parent anchor passed in.
d701 1
a701 1
    return (YES);
d705 3
a707 3
 * Unnamed children (children_notag) have no sence without HText - delete them
 * and their links if we are about to free HText.  Document currently exists. 
 * Called within HText_free().
d709 2
a710 1
void HTAnchor_delete_links(HTParentAnchor *me)
d716 1
a716 1
     * Do nothing if nothing to do.
d723 2
a724 2
     * Mark ourselves busy, so that recursive calls on this HTParentAnchor0
     * will not free it from under our feet.  - kw
d729 1
a729 1
     * Delete all outgoing links from unnamed children.
d734 1
a734 1
		(HTChildAnchor *) HTList_unlinkLastObject(cur)) != 0) {
d736 1
a736 1
	    /* child allocated in HText pool, HText_free() will free it later */
d742 3
a744 1
static void HTParentAnchor_free(HTParentAnchor *me)
d747 1
a747 1
     * Delete the methods list.
d751 2
a752 2
	 * Leave what the methods point to up in memory for other code (near
	 * static stuff).
d759 1
a759 1
     * Free up all allocated members.
a776 1

a784 4
#ifdef EXP_HTTP_HEADERS
    HTChunkClear(&(me->http_headers));
#endif
    FREE(me->content_type_params);
d805 4
a808 4
     * Original code wanted a way to clean out the HTFormat if no longer needed
     * (ref count?).  I'll leave it alone since those HTAtom objects are a
     * little harder to know where they are being referenced all at one time. 
     * (near static)
d816 2
a817 1
void HTAnchor_clearSourceCache(HTParentAnchor *me)
d824 1
a824 1
		me->source_cache_file));
d830 1
a830 1
		(void *) me->source_cache_chunk));
d838 4
a841 3
 *	---------------------
 */
HTParentAnchor *HTAnchor_parent(HTAnchor * me)
d853 3
a855 2
void HTAnchor_setDocument(HTParentAnchor *me,
			  HyperDoc *doc)
d861 2
a862 1
HyperDoc *HTAnchor_document(HTParentAnchor *me)
d864 1
a864 1
    return (me ? me->document : NULL);
d867 3
a869 1
char *HTAnchor_address(HTAnchor * me)
d874 3
a876 3
	if (((HTParentAnchor0 *) me == me->parent) ||
	    ((HTParentAnchor *) me == me->parent->info) ||
	    !((HTChildAnchor *) me)->tag) {	/* it's an adult or no tag */
d878 1
a878 1
	} else {		/* it's a named child */
d880 1
a880 1
		       me->parent->address, ((HTChildAnchor *) me)->tag);
d883 1
a883 1
    return (addr);
d886 3
a888 2
void HTAnchor_setFormat(HTParentAnchor *me,
			HTFormat form)
d894 2
a895 1
HTFormat HTAnchor_format(HTParentAnchor *me)
d897 1
a897 1
    return (me ? me->format : NULL);
d900 3
a902 2
void HTAnchor_setIndex(HTParentAnchor *me,
		       const char *address)
d910 3
a912 2
void HTAnchor_setPrompt(HTParentAnchor *me,
			const char *prompt)
d919 2
a920 1
BOOL HTAnchor_isIndex(HTParentAnchor *me)
d922 1
a922 1
    return (me ? me->isIndex : NO);
d926 4
a929 3
 *	(normally by presence of an ISMAP attribute on A or IMG) - KW
 */
BOOL HTAnchor_isISMAPScript(HTAnchor * me)
d931 1
a931 1
    return ((me && me->parent->info) ? me->parent->info->isISMAPScript : NO);
d937 2
a938 1
const char *HTAnchor_style(HTParentAnchor *me)
d940 1
a940 1
    return (me ? me->style : NULL);
d943 3
a945 2
void HTAnchor_setStyle(HTParentAnchor *me,
		       const char *style)
d953 1
d956 2
a957 1
const char *HTAnchor_title(HTParentAnchor *me)
d959 1
a959 1
    return (me ? me->title : NULL);
d962 3
a964 2
void HTAnchor_setTitle(HTParentAnchor *me,
		       const char *title)
d978 1
a978 1
	    CTRACE((tfp, "HTAnchor_setTitle: New title is NULL! "));
d980 1
a980 1
		CTRACE((tfp, "Old title was \"%s\".\n", me->title));
d983 1
a983 1
		CTRACE((tfp, "Old title was NULL.\n"));
d989 3
a991 2
void HTAnchor_appendTitle(HTParentAnchor *me,
			  const char *title)
d1008 2
a1009 1
const char *HTAnchor_bookmark(HTParentAnchor *me)
d1011 1
a1011 1
    return (me ? me->bookmark : NULL);
d1014 3
a1016 2
void HTAnchor_setBookmark(HTParentAnchor *me,
			  const char *bookmark)
d1024 2
a1025 1
const char *HTAnchor_owner(HTParentAnchor *me)
d1027 1
a1027 1
    return (me ? me->owner : NULL);
d1030 3
a1032 2
void HTAnchor_setOwner(HTParentAnchor *me,
		       const char *owner)
d1041 2
a1042 1
const char *HTAnchor_RevTitle(HTParentAnchor *me)
d1044 1
a1044 1
    return (me ? me->RevTitle : NULL);
d1047 3
a1049 2
void HTAnchor_setRevTitle(HTParentAnchor *me,
			  const char *title)
d1067 2
a1068 1
const char *HTAnchor_citehost(HTParentAnchor *me)
d1070 1
a1070 1
    return (me ? me->citehost : NULL);
d1073 3
a1075 2
void HTAnchor_setCitehost(HTParentAnchor *me,
			  const char *citehost)
d1084 2
a1085 10
 *	(will be loaded if we had a Content-Disposition
 *	 header or META element with filename=name.suffix)
 */
const char *HTAnchor_SugFname(HTParentAnchor *me)
{
    return (me ? me->SugFname : NULL);
}

#ifdef EXP_HTTP_HEADERS
/*	HTTP Headers.
d1087 2
a1088 1
const char *HTAnchor_http_headers(HTParentAnchor *me)
d1090 1
a1090 1
    return (me ? me->http_headers.data : NULL);
a1091 1
#endif
d1093 3
a1095 1
/*	Content-Type handling (parameter list).
d1097 2
a1098 1
const char *HTAnchor_content_type_params(HTParentAnchor *me)
d1100 1
a1100 10
    return (me ? me->content_type_params : NULL);
}

/*	Content-Encoding handling. - FM
 *	(will be loaded if we had a Content-Encoding
 *	 header.)
 */
const char *HTAnchor_content_encoding(HTParentAnchor *me)
{
    return (me ? me->content_encoding : NULL);
d1105 2
a1106 1
const char *HTAnchor_content_type(HTParentAnchor *me)
d1108 1
a1108 1
    return (me ? me->content_type : NULL);
d1113 2
a1114 1
const char *HTAnchor_last_modified(HTParentAnchor *me)
d1116 1
a1116 1
    return (me ? me->last_modified : NULL);
d1121 2
a1122 1
const char *HTAnchor_date(HTParentAnchor *me)
d1124 1
a1124 1
    return (me ? me->date : NULL);
d1129 2
a1130 1
const char *HTAnchor_server(HTParentAnchor *me)
d1132 1
a1132 1
    return (me ? me->server : NULL);
d1137 2
a1138 1
BOOL HTAnchor_safe(HTParentAnchor *me)
d1140 1
a1140 1
    return (BOOL) (me ? me->safe : FALSE);
d1145 2
a1146 1
const char *HTAnchor_content_base(HTParentAnchor *me)
d1148 1
a1148 1
    return (me ? me->content_base : NULL);
d1153 2
a1154 1
const char *HTAnchor_content_location(HTParentAnchor *me)
d1156 1
a1156 1
    return (me ? me->content_location : NULL);
d1161 2
a1162 1
const char *HTAnchor_messageID(HTParentAnchor *me)
d1164 1
a1164 1
    return (me ? me->message_id : NULL);
d1167 3
a1169 2
BOOL HTAnchor_setMessageID(HTParentAnchor *me,
			   const char *messageid)
d1180 2
a1181 1
const char *HTAnchor_subject(HTParentAnchor *me)
d1183 1
a1183 1
    return (me ? me->subject : NULL);
d1186 3
a1188 2
BOOL HTAnchor_setSubject(HTParentAnchor *me,
			 const char *subject)
d1198 4
a1201 3
 *	---------------------
 */
HTAnchor *HTAnchor_followLink(HTChildAnchor *me)
d1203 1
a1203 1
    return (me->dest);
d1206 3
a1208 2
HTAnchor *HTAnchor_followTypedLink(HTChildAnchor *me,
				   HTLinkType *type)
d1211 2
a1212 2
	return (me->dest);
    return (NULL);		/* No link of me type */
d1215 1
d1217 4
a1220 3
 *	------------
 */
HTList *HTAnchor_methods(HTParentAnchor *me)
d1225 1
a1225 1
    return (me->methods);
d1229 4
a1232 3
 *	--------
 */
void *HTAnchor_protocol(HTParentAnchor *me)
d1234 1
a1234 1
    return (me->protocol);
d1237 3
a1239 2
void HTAnchor_setProtocol(HTParentAnchor *me,
			  void *protocol)
d1245 4
a1248 3
 *	----------------
 */
char *HTAnchor_physical(HTParentAnchor *me)
d1250 1
a1250 1
    return (me->physical);
d1253 3
a1255 2
void HTAnchor_setPhysical(HTParentAnchor *me,
			  char *physical)
d1263 26
a1288 25
 *  We store charset info in the HTParentAnchor object, for several
 *  "stages".  (See UCDefs.h)
 *  A stream method is supposed to know what stage in the model it is.
 *
 *  General model	MIME	 ->  parser  ->  structured  ->  HText
 *  e.g., text/html
 *	from HTTP:	HTMIME.c ->  SGML.c  ->  HTML.c      ->  GridText.c
 *     text/plain
 *	from file:	HTFile.c ->  HTPlain.c		     ->  GridText.c
 *
 *  The lock/set_by is used to lock e.g. a charset set by an explicit
 *  HTTP MIME header against overriding by a HTML META tag - the MIME
 *  header has higher priority.  Defaults (from -assume_.. options etc.)
 *  will not override charset explicitly given by server.
 *
 *  Some advantages of keeping this in the HTAnchor:
 *  - Global variables are bad.
 *  - Can remember a charset given by META tag when toggling to SOURCE view.
 *  - Can remember a charset given by <A CHARSET=...> href in another doc.
 *
 *  We don't modify the HTParentAnchor's charset element
 *  here, that one will only be set when explicitly given.
 */
LYUCcharset *HTAnchor_getUCInfoStage(HTParentAnchor *me,
				     int which_stage)
d1292 2
a1293 3
	int chndl = UCLYhndl_for_unspec;	/* always >= 0 */
	UCAnchorInfo *stages = typecalloc(UCAnchorInfo);

d1306 4
a1309 4
		 * UCLYhndl_for_unrec not defined :-(
		 * fallback to UCLYhndl_for_unspec which always valid.
		 */
		chndl = UCLYhndl_for_unspec;	/* always >= 0 */
a1312 1

d1318 1
a1318 1
	return (&me->UCStages->s[which_stage].C);
d1320 1
a1320 1
    return (NULL);
d1323 3
a1325 2
int HTAnchor_getUCLYhndl(HTParentAnchor *me,
			 int which_stage)
d1330 1
a1330 1
	     * This will allocate and initialize, if not yet done.
d1335 1
a1335 1
	    return (me->UCStages->s[which_stage].LYhndl);
d1338 1
a1338 1
    return (-1);
d1342 1
a1342 1
static void setup_switch_display_charset(HTParentAnchor *me, int h)
d1344 1
a1344 1
    if (!Switch_Display_Charset(h, SWITCH_DISPLAY_CHARSET_MAYBE))
d1347 1
a1347 1
			    UCT_STAGE_HTEXT, UCT_SETBY_MIME);	/* highest priorty! */
d1349 2
a1350 3
			    UCT_STAGE_STRUCTURED, UCT_SETBY_MIME);	/* highest priorty! */
    CTRACE((tfp,
	    "changing UCInfoStage: HTEXT/STRUCTURED stages charset='%s'.\n",
d1355 5
a1359 4
LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
				     int LYhndl,
				     int which_stage,
				     int set_by)
d1363 1
a1363 1
	 * This will allocate and initialize, if not yet done.
d1365 1
a1365 2
	LYUCcharset *p = HTAnchor_getUCInfoStage(me, which_stage);

d1367 1
a1367 1
	 * Can we override?
a1376 1

d1379 1
a1379 1
		if (LYhndl != ohandle && which_stage == UCT_STAGE_PARSER)
d1382 2
a1383 1
	    } else {
d1386 1
a1386 1
	    return (p);
d1389 1
a1389 1
    return (NULL);
d1392 5
a1396 4
LYUCcharset *HTAnchor_resetUCInfoStage(HTParentAnchor *me,
				       int LYhndl,
				       int which_stage,
				       int set_by)
d1401 1
a1401 1
	return (NULL);
d1410 1
a1410 1
    return (&me->UCStages->s[which_stage].C);
d1414 7
a1420 6
 *  A set_by of (-1) means use the lock value from the from_stage.
 */
LYUCcharset *HTAnchor_copyUCInfoStage(HTParentAnchor *me,
				      int to_stage,
				      int from_stage,
				      int set_by)
d1424 1
a1424 1
	 * This will allocate and initialize, if not yet done.
d1426 2
a1427 3
	LYUCcharset *p_from = HTAnchor_getUCInfoStage(me, from_stage);
	LYUCcharset *p_to = HTAnchor_getUCInfoStage(me, to_stage);

d1429 1
a1429 1
	 * Can we override?
d1444 3
a1446 3
	    if (me->UCStages->s[to_stage].LYhndl >= 0
		&& me->UCStages->s[to_stage].LYhndl != ohandle
		&& to_stage == UCT_STAGE_PARSER)
d1452 1
a1452 2

	    return (p_to);
d1455 1
a1455 1
    return (NULL);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a23 1
#include <LYUtils.h>
d69 2
a70 1
    HTParentAnchor *newAnchor = typecalloc(HTParentAnchor);
d74 1
a74 1
    newAnchor->bookmark = NULL;		/* Bookmark filename. - FM */
a77 4
#ifdef SOURCE_CACHE
    newAnchor->source_cache_file = NULL;
    newAnchor->source_cache_chunk = NULL;
#endif
d79 2
a80 3
    newAnchor->SugFname = NULL;		/* Suggested filename. - FM */
    newAnchor->RevTitle = NULL;		/* TITLE for a LINK with REV. - FM */
    newAnchor->citehost = NULL;		/* LINK REL=citehost - RDC */
d101 1
a101 6
    HTChildAnchor *p;

    p = typecalloc(HTChildAnchor);
    if (p == NULL)
	outofmem(__FILE__, "HTChildAnchor_new");
    return p;
d127 1
a127 1
	return(s == t);		/* Two NULLs are equivalent, aren't they ? */
a146 6
#ifdef SH_EX	/* 1998/04/28 (Tue) 22:02:58 */
	if (*s == 'P' || *t == 'P') {
	    if (strcmp(s + 1, "Name") == 0 || strcmp(t + 1, "Name") == 0)
		return NO;
	}
#endif
d152 1
a152 1
	return (BOOL) (*s == *t);
d154 1
a154 1
	return (BOOL) (s == t);  /* Two NULLs are identical, aren't they ? */
d174 1
a174 1
	CTRACE((tfp, "HTAnchor_findChild called with NULL parent.\n"));
d189 2
a190 2
		    CTRACE((tfp, "Child anchor %p of parent %p with name `%s' already exists.\n",
				(void *)child, (void *)parent, tag));
d200 3
a202 1
    CTRACE((tfp, "HTAnchor: New Anchor %p named `%s' is child of %p\n",
d205 1
a205 1
		(void *)parent)); /* int for apollo */
d228 1
a228 1
    CTRACE((tfp,"Entered HTAnchor_findChildAndLink\n"));
d262 1
a262 1
		CTRACE((tfp,
d264 1
a264 1
		       child, tag, nlinks));
d266 2
a267 2
		    CTRACE((tfp,", same dest %p and type, keeping it\n",
			   testdest1));
d269 2
a270 2
		    CTRACE((tfp,", different dest %p, creating unnamed child\n",
			   testdest1));
d307 1
a307 1
		CTRACE((tfp, "delete anchor:%d/%d,%d,%d %s\n",
d311 1
a311 1
		       (parent->address ? parent->address : "(no address)")));
d336 1
a336 1
    CTRACE((tfp,"Entered HTAnchor_findAddress\n"));
d377 1
a377 1
	    adult_table = typecallocn(HTList *, HASH_SIZE);
d404 2
a405 2
		CTRACE((tfp, "Anchor %p with address `%s' already exists.\n",
			    (void *)foundAnchor, newdoc->address));
d414 2
a415 2
	CTRACE((tfp, "New anchor %p has hash %d and address `%s'\n",
		    (void *)foundAnchor, hash, newdoc->address));
a429 10
/*	Create new or find old named anchor - simple form
**	-------------------------------------------------
**
**	Like the previous one, but simpler to use for simple cases.
**	No post data etc. can be supplied. - kw
*/
PUBLIC HTAnchor * HTAnchor_findSimpleAddress ARGS1(
	CONST char *,	url)
{
    DocAddress urldoc;
a430 8
    urldoc.address = (char *)url; /* ignore warning, it IS treated like const - kw */
    urldoc.post_data = NULL;
    urldoc.post_content_type = NULL;
    urldoc.bookmark = NULL;
    urldoc.isHEAD = FALSE;
    urldoc.safe = FALSE;
    return HTAnchor_findAddress(&urldoc);
}
a568 22
#ifdef SOURCE_CACHE
PUBLIC void HTAnchor_clearSourceCache ARGS1(
	HTParentAnchor *,	me)
{
    /*
     * Clean up the source cache, if any.
     */
    if (me->source_cache_file) {
	CTRACE((tfp, "SourceCache: Removing file %s\n",
	       me->source_cache_file));
	LYRemoveTemp(me->source_cache_file);
	FREE(me->source_cache_file);
    }
    if (me->source_cache_chunk) {
	CTRACE((tfp, "SourceCache: Removing memory chunk %p\n",
	       (void *)me->source_cache_chunk));
	HTChunkFree(me->source_cache_chunk);
	me->source_cache_chunk = NULL;
    }
}
#endif /* SOURCE_CACHE */

a691 4
    FREE(me->citehost);
#ifdef SOURCE_CACHE
    HTAnchor_clearSourceCache(me);
#endif
d716 1
a716 1
#ifdef USE_COLOR_STYLE
d724 1
a724 1
	unsigned short usi_hash = (unsigned short) HASH_FUNCTION(me->address);
d806 7
a812 2
	    HTSprintf0(&addr, "%s#%s",
		       me->parent->address, ((HTChildAnchor *)me)->tag);
d834 1
a834 1
	char *,			address)
d844 1
a844 1
	char *,			prompt)
d869 1
a869 1
    return (BOOL) ( me ? ! HTList_isEmpty(me->children) : NO);
d872 1
a872 1
#if defined(USE_COLOR_STYLE)
d910 2
a911 2
		if (UCH(me->title[i]) == 1 ||
		    UCH(me->title[i]) == 2) {
d916 1
a916 1
	    CTRACE((tfp,"HTAnchor_setTitle: New title is NULL! "));
d918 1
a918 1
		CTRACE((tfp,"Old title was \"%s\".\n", me->title));
d921 1
a921 1
		CTRACE((tfp,"Old title was NULL.\n"));
d936 2
a937 2
	    if (UCH(me->title[i]) == 1 ||
		UCH(me->title[i]) == 2) {
d994 2
a995 2
	    if (UCH(me->RevTitle[i]) == 1 ||
		UCH(me->RevTitle[i]) == 2) {
a1001 19
#ifndef DISABLE_BIBP
/*	Citehost for bibp links from LINKs with REL="citehost". - RDC
*/
PUBLIC CONST char * HTAnchor_citehost ARGS1(
	HTParentAnchor *,	me)
{
    return( me ? me->citehost : NULL);
}

PUBLIC void HTAnchor_setCitehost ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		citehost)
{
    if (me) {
	StrAllocCopy(me->citehost, citehost);
    }
}
#endif /* !DISABLE_BIBP */

d1059 1
a1059 1
    return (BOOL) ( me ? me->safe : FALSE);
d1126 1
a1126 1
    CTRACE((tfp, "Linking anchor %p to anchor %p\n", source, destination));
d1131 1
a1131 1
	HTLink * newLink = typecalloc(HTLink);
d1186 1
a1186 1
	HTLink *newLink = typecalloc(HTLink);
d1241 1
a1241 1
	char *,			physical)
d1279 2
a1280 1
	UCAnchorInfo * stages = typecalloc(UCAnchorInfo);
a1327 14
#ifdef CAN_SWITCH_DISPLAY_CHARSET
PRIVATE void setup_switch_display_charset ARGS2(HTParentAnchor *, me, int, h)
{
    if (!Switch_Display_Charset(h,SWITCH_DISPLAY_CHARSET_MAYBE))
	return;
    HTAnchor_setUCInfoStage(me, current_char_set,
			    UCT_STAGE_HTEXT, UCT_SETBY_MIME); /* highest priorty! */
    HTAnchor_setUCInfoStage(me, current_char_set,
			    UCT_STAGE_STRUCTURED, UCT_SETBY_MIME); /* highest priorty! */
    CTRACE((tfp, "changing UCInfoStage: HTEXT/STRUCTURED stages charset='%s'.\n",
	    LYCharSet_UC[current_char_set].MIMEname));
}
#endif

a1342 3
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    int ohandle = me->UCStages->s[which_stage].LYhndl;
#endif
a1346 5
#ifdef CAN_SWITCH_DISPLAY_CHARSET
		/* Allow a switch to a more suitable display charset */
		if ( LYhndl != ohandle && which_stage == UCT_STAGE_PARSER )
		    setup_switch_display_charset(me, LYhndl);
#endif
a1362 2
    int ohandle;

a1365 1
    ohandle = me->UCStages->s[which_stage].LYhndl;
a1366 5
#ifdef CAN_SWITCH_DISPLAY_CHARSET
    /* Allow a switch to a more suitable display charset */
    if (LYhndl >= 0 && LYhndl != ohandle && which_stage == UCT_STAGE_PARSER)
	setup_switch_display_charset(me, LYhndl);
#endif
a1392 3
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    int ohandle = me->UCStages->s[to_stage].LYhndl;
#endif
a1395 8
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Allow a switch to a more suitable display charset */
	    if ( me->UCStages->s[to_stage].LYhndl >= 0
		 && me->UCStages->s[to_stage].LYhndl != ohandle
		 && to_stage == UCT_STAGE_PARSER )
		setup_switch_display_charset(me,
					     me->UCStages->s[to_stage].LYhndl);
#endif
@

