head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.51;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.43;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.29;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.05;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.11;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.02;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.27.04;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.49;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.11;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.46.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@/*						  SGML parse and stream definition for libwww
			       SGML AND STRUCTURED STREAMS

   The SGML parser is a state machine.	It is called for every character
   of the input stream.	 The DTD data structure contains pointers
   to functions which are called to implement the actual effect of the
   text read. When these functions are called, the attribute structures pointed to by the
   DTD are valid, and the function is passed a pointer to the current tag structure, and an
   "element stack" which represents the state of nesting within SGML elements.

   The following aspects are from Dan Connolly's suggestions:  Binary search,
   Structured object scheme basically, SGML content enum type.

   (c) Copyright CERN 1991 - See Copyright.html

 */
#ifndef SGML_H
#define SGML_H

#include <HTStream.h>
#include <HTAnchor.h>
#include <LYJustify.h>

#ifdef __cplusplus
extern "C" {
#endif
/*

SGML content types

 */ typedef enum {
	SGML_EMPTY,		/* No content. */
	SGML_LITTERAL,		/* Literal character data.  Recognize exact close tag only.
				   Old www server compatibility only!  Not SGML */
	SGML_CDATA,		/* Character data.  Recognize </ only.
				   (But we treat it just as SGML_LITTERAL.) */
	SGML_SCRIPT,		/* Like CDATA, but allow it to be a comment */
	SGML_RCDATA,		/* Replaceable character data. Should recognize </ and &ref;
				   (but we treat it like SGML_MIXED for old times' sake). */
	SGML_MIXED,		/* Elements and parsed character data.
				   Recognize all markup. */
	SGML_ELEMENT,		/* Any data found should be regarded as an error.
				   (But we treat it just like SGML_MIXED.) */
	SGML_PCDATA		/* Should contain no elements but &ref; is parsed.
				   (We treat it like SGML_CDATA wrt. contained tags
				   i.e. pass them on literally, i.e. like we should
				   treat SGML_RCDATA) (added by KW). */
    } SGMLContent;

    typedef struct {
	const char *name;	/* The name of the attribute */
#ifdef USE_PRETTYSRC
	char type;		/* code of the type of the attribute. Code
				   values are in HTMLDTD.h */
#endif
    } attr;

    typedef int TagClass;

    /* textflow */
#define Tgc_FONTlike	0x00001	/* S,STRIKE,I,B,TT,U,BIG,SMALL,STYLE,BLINK;BR,TAB */
#define Tgc_EMlike	0x00002	/* EM,STRONG,DFN,CODE,SAMP,KBD,VAR,CITE,Q,INS,DEL,SPAN,.. */
#define Tgc_MATHlike	0x00004	/* SUB,SUP,MATH,COMMENT */
#define Tgc_Alike	0x00008	/* A */
#define Tgc_formula	0x00010	/* not used until math is supported better... */
    /* used for special structures: forms, tables,... */
#define Tgc_TRlike	0x00020	/* TR and similar */
#define Tgc_SELECTlike	0x00040	/* SELECT,INPUT,TEXTAREA(,...) */
    /* structure */
#define Tgc_FORMlike	0x00080	/* FORM itself */
#define Tgc_Plike	0x00100	/* P,H1..H6,... structures containing text or
				   insertion but not other structures */
#define Tgc_DIVlike	0x00200	/* ADDRESS,FIG,BDO,NOTE,FN,DIV,CENTER;FIG
				   structures which can contain other structures */
#define Tgc_LIlike	0x00400	/* LH,LI,DT,DD;TH,TD structure-like, only valid
				   within certain other structures */
#define Tgc_ULlike	0x00800	/* UL,OL,DL,DIR,MENU;TABLE;XMP,LISTING
				   special in some way, cannot contain (parsed)
				   text directly */
    /* insertions */
#define Tgc_BRlike	0x01000	/* BR,IMG,TAB allowed in any text */
#define Tgc_APPLETlike	0x02000	/* APPLET,OBJECT,EMBED,SCRIPT;BUTTON */
#define Tgc_HRlike	0x04000	/* HR,MARQUEE can contain all kinds of things
				   and/or are not allowed (?) in running text */
#define Tgc_MAPlike	0x08000	/* MAP,AREA some specials that never contain
				   (directly or indirectly) other things than
				   special insertions */
#define Tgc_outer	0x10000	/* HTML,FRAMESET,FRAME,PLAINTEXT; */
#define Tgc_BODYlike	0x20000	/* BODY,BODYTEXT,NOFRAMES,TEXTFLOW; */
#define Tgc_HEADstuff	0x40000	/* HEAD,BASE,STYLE,TITLE; */
    /* special relations */
#define Tgc_same	0x80000

/* Some more properties of tags (or rather, elements) and rules how
   to deal with them. - kw */
    typedef int TagFlags;

#define Tgf_endO	0x00001	/* end tag can be Omitted */
#define Tgf_startO	0x00002	/* start tag can be Omitted */
#define Tgf_mafse	0x00004	/* Make Attribute-Free Start-tag End instead
				   (if found invalid) */
#define Tgf_strict	0x00008	/* Ignore contained invalid elements,
				   don't pass them on; or other variant
				   handling for some content types */
#define Tgf_nreie	0x00010	/* Not Really Empty If Empty,
				   used by color style code */
#define Tgf_frecyc	0x00020	/* Pass element content on in a form that
				   allows recycling, i.e. don't translate to
				   output (display) character set yet (treat
				   content similar to attribute values) */
#define Tgf_nolyspcl	0x00040	/* Don't generate lynx special characters
				   for soft hyphen and various spaces (nbsp,
				   ensp,..) */

/*		A tag structure describes an SGML element.
 *		-----------------------------------------
 *
 *
 *	name		is the string which comes after the tag opener "<".
 *
 *	attributes	points to a zero-terminated array
 *			of attribute names.
 *
 *	litteral	determines how the SGML engine parses the characters
 *			within the element.  If set, tag openers are ignored
 *			except for that which opens a matching closing tag.
 *
 */
    typedef struct _tag HTTag;
    struct _tag {
	const char *name;	/* The name of the tag */
#ifdef USE_COLOR_STYLE
	int name_len;		/* The length of the name */
#endif
#ifdef EXP_JUSTIFY_ELTS
	BOOL can_justify;	/* justification allowed? */
#endif
	attr *attributes;	/* The list of acceptable attributes */
	int number_of_attributes;	/* Number of possible attributes */
	SGMLContent contents;	/* End only on end tag @@@@ */
	TagClass tagclass;
	TagClass contains;	/* which classes of elements this one can contain directly */
	TagClass icontains;	/* which classes of elements this one can contain indirectly */
	TagClass contained;	/* in which classes can this tag be contained ? */
	TagClass icontained;	/* in which classes can this tag be indirectly contained ? */
	TagClass canclose;	/* which classes of elements can this one close
				   if something looks wrong ? */
	TagFlags flags;
    };

/*		DTD Information
 *		---------------
 *
 *  Not the whole DTD, but all this parser uses of it.
 */
    typedef struct {
	HTTag *tags;		/* Must be in strcmp order by name */
	int number_of_tags;
	const char **entity_names;	/* Must be in strcmp order by name */
	size_t number_of_entities;
	/*  "entity_names" table probably unused,
	 *  see comments in HTMLDTD.c near the top
	 */
    } SGML_dtd;

/*	SGML context passed to parsers
*/
    typedef struct _HTSGMLContext *HTSGMLContext;	/* Hidden */

/*__________________________________________________________________________
*/

/*

Structured Object definition

   A structured object is something which can reasonably be represented
   in SGML.  I'll rephrase that.  A structured object is an ordered
   tree-structured arrangement of data which is representable as text.
   The SGML parser outputs to a Structured object.  A Structured object
   can output its contents to another Structured Object.  It's a kind of
   typed stream.  The architecture is largely Dan Conolly's.  Elements and
   entities are passed to the sob by number, implying a knowledge of the
   DTD.	 Knowledge of the SGML syntax is not here, though.

   Superclass: HTStream

   The creation methods will vary on the type of Structured Object.
   Maybe the callerData is enough info to pass along.

 */
    typedef struct _HTStructured HTStructured;

    typedef struct _HTStructuredClass {

	const char *name;	/* Just for diagnostics */

	void (*_free) (HTStructured * me);

	void (*_abort) (HTStructured * me, HTError e);

	void (*put_character) (HTStructured * me, char ch);

	void (*put_string) (HTStructured * me, const char *str);

	void (*_write) (HTStructured * me, const char *str,
			int len);

	int (*start_element) (HTStructured * me, int element_number,
			      const BOOL *attribute_present,
			      const char **attribute_value,
			      int charset,
			      char **include);

	int (*end_element) (HTStructured * me, int element_number,
			    char **include);

	int (*put_entity) (HTStructured * me, int entity_number);

    } HTStructuredClass;

/*
  Equivalents to the following functions possibly could be generalised
  into additional HTStructuredClass members.  For now they don't do
  anything target-specific. - kw
  */
    extern BOOLEAN LYCheckForCSI(HTParentAnchor *anchor, char **url);
    extern void LYDoCSI(char *url, const char *comment, char **csi);
    extern BOOLEAN LYCommentHacks(HTParentAnchor *anchor, const char *comment);

/*

Find a Tag by Name

   Returns a pointer to the tag within the DTD.

 */
    extern HTTag *SGMLFindTag(const SGML_dtd * dtd,
			      const char *string);

/*

Create an SGML parser

 */
/*
 * On entry,
 *	dtd		must point to a DTD structure as defined above
 *	callbacks	must point to user routines.
 *	callData	is returned in callbacks transparently.
 * On exit,
 *		The default tag starter has been processed.
 */
    extern HTStream *SGML_new(const SGML_dtd * dtd,
			      HTParentAnchor *anchor,
			      HTStructured * target);

    extern const HTStreamClass SGMLParser;

#ifdef __cplusplus
}
#endif
#endif				/* SGML_H */
@


1.5
log
@automatic merge of lynx-current
@
text
@d24 3
d31 3
a33 4
 */
typedef enum {
    SGML_EMPTY,			/* No content. */
    SGML_LITTERAL,		/* Literal character data.  Recognize exact close tag only.
d35 1
a35 1
    SGML_CDATA,			/* Character data.  Recognize </ only.
d37 2
a38 2
    SGML_SCRIPT,		/* Like CDATA, but allow it to be a comment */
    SGML_RCDATA,		/* Replaceable character data. Should recognize </ and &ref;
d40 1
a40 1
    SGML_MIXED,			/* Elements and parsed character data.
d42 1
a42 1
    SGML_ELEMENT,		/* Any data found should be regarded as an error.
d44 1
a44 1
    SGML_PCDATA			/* Should contain no elements but &ref; is parsed.
d48 1
a48 1
} SGMLContent;
d50 2
a51 2
typedef struct {
    char *name;			/* The (constant) name of the attribute */
d53 1
a53 1
    char type;			/* code of the type of the attribute. Code
d56 1
a56 1
} attr;
d58 1
a58 1
typedef int TagClass;
d96 1
a96 1
typedef int TagFlags;
d129 3
a131 3
typedef struct _tag HTTag;
struct _tag {
    char *name;			/* The name of the tag */
d133 1
a133 1
    int name_len;		/* The length of the name */
d136 1
a136 1
    BOOL can_justify;		/* justification allowed? */
d138 9
a146 9
    attr *attributes;		/* The list of acceptable attributes */
    int number_of_attributes;	/* Number of possible attributes */
    SGMLContent contents;	/* End only on end tag @@@@ */
    TagClass tagclass;
    TagClass contains;		/* which classes of elements this one can contain directly */
    TagClass icontains;		/* which classes of elements this one can contain indirectly */
    TagClass contained;		/* in which classes can this tag be contained ? */
    TagClass icontained;	/* in which classes can this tag be indirectly contained ? */
    TagClass canclose;		/* which classes of elements can this one close
d148 2
a149 2
    TagFlags flags;
};
d156 9
a164 9
typedef struct {
    HTTag *tags;		/* Must be in strcmp order by name */
    int number_of_tags;
    const char **entity_names;	/* Must be in strcmp order by name */
    size_t number_of_entities;
    /*  "entity_names" table probably unused,
     *  see comments in HTMLDTD.c near the top
     */
} SGML_dtd;
d168 1
a168 1
typedef struct _HTSGMLContext *HTSGMLContext;	/* Hidden */
d192 1
a192 1
typedef struct _HTStructured HTStructured;
d194 1
a194 1
typedef struct _HTStructuredClass {
d196 1
a196 1
    char *name;			/* Just for diagnostics */
d198 1
a198 1
    void (*_free) (HTStructured * me);
d200 1
a200 1
    void (*_abort) (HTStructured * me, HTError e);
d202 1
a202 1
    void (*put_character) (HTStructured * me, char ch);
d204 1
a204 1
    void (*put_string) (HTStructured * me, const char *str);
d206 2
a207 2
    void (*_write) (HTStructured * me, const char *str,
		    int len);
d209 5
a213 5
    int (*start_element) (HTStructured * me, int element_number,
			  const BOOL *attribute_present,
			  const char **attribute_value,
			  int charset,
			  char **include);
d215 2
a216 2
    int (*end_element) (HTStructured * me, int element_number,
			char **include);
d218 1
a218 1
    int (*put_entity) (HTStructured * me, int entity_number);
d220 1
a220 1
} HTStructuredClass;
d227 3
a229 3
extern BOOLEAN LYCheckForCSI(HTParentAnchor *anchor, char **url);
extern void LYDoCSI(char *url, const char *comment, char **csi);
extern BOOLEAN LYCommentHacks(HTParentAnchor *anchor, const char *comment);
d238 2
a239 2
extern HTTag *SGMLFindTag(const SGML_dtd * dtd,
			  const char *string);
d254 3
a256 3
extern HTStream *SGML_new(const SGML_dtd * dtd,
			  HTParentAnchor *anchor,
			  HTStructured * target);
d258 1
a258 1
extern const HTStreamClass SGMLParser;
d260 4
a263 1
#endif /* SGML_H */
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d30 16
a45 16
    SGML_EMPTY,	   /* No content. */
    SGML_LITTERAL, /* Literal character data.  Recognize exact close tag only.
		      Old www server compatibility only!  Not SGML */
    SGML_CDATA,	   /* Character data.  Recognize </ only.
		      (But we treat it just as SGML_LITTERAL.) */
    SGML_SCRIPT,   /* Like CDATA, but allow it to be a comment */
    SGML_RCDATA,   /* Replaceable character data. Should recognize </ and &ref;
		      (but we treat it like SGML_MIXED for old times' sake). */
    SGML_MIXED,	   /* Elements and parsed character data.
		      Recognize all markup. */
    SGML_ELEMENT,  /* Any data found should be regarded as an error.
		      (But we treat it just like SGML_MIXED.) */
    SGML_PCDATA	   /* Should contain no elements but &ref; is parsed.
		      (We treat it like SGML_CDATA wrt. contained tags
		      i.e. pass them on literally, i.e. like we should
		      treat SGML_RCDATA) (added by KW). */
a47 1

d49 1
a49 1
    char *	name;		/* The (constant) name of the attribute */
d51 1
a51 1
    char	type;		/* code of the type of the attribute. Code
d57 1
d59 5
a63 5
#define Tgc_FONTlike	0x00001 /* S,STRIKE,I,B,TT,U,BIG,SMALL,STYLE,BLINK;BR,TAB */
#define Tgc_EMlike	0x00002 /* EM,STRONG,DFN,CODE,SAMP,KBD,VAR,CITE,Q,INS,DEL,SPAN,.. */
#define Tgc_MATHlike	0x00004 /* SUB,SUP,MATH,COMMENT */
#define Tgc_Alike	0x00008 /* A */
#define Tgc_formula	0x00010 /* not used until math is supported better... */
d65 2
a66 2
#define Tgc_TRlike	0x00020 /* TR and similar */
#define Tgc_SELECTlike	0x00040 /* SELECT,INPUT,TEXTAREA(,...) */
d68 10
a77 10
#define Tgc_FORMlike	0x00080 /* FORM itself */
#define Tgc_Plike	0x00100 /* P,H1..H6,... structures containing text or
				    insertion but not other structures */
#define Tgc_DIVlike	0x00200 /* ADDRESS,FIG,BDO,NOTE,FN,DIV,CENTER;FIG
				    structures which can contain other structures */
#define Tgc_LIlike	0x00400 /* LH,LI,DT,DD;TH,TD structure-like, only valid
				    within certain other structures */
#define Tgc_ULlike	0x00800 /* UL,OL,DL,DIR,MENU;TABLE;XMP,LISTING
				    special in some way, cannot contain (parsed)
				    text directly */
d79 10
a88 10
#define Tgc_BRlike	0x01000 /* BR,IMG,TAB allowed in any text */
#define Tgc_APPLETlike	0x02000 /* APPLET,OBJECT,EMBED,SCRIPT;BUTTON */
#define Tgc_HRlike	0x04000 /* HR,MARQUEE can contain all kinds of things
				    and/or are not allowed (?) in running text */
#define Tgc_MAPlike	0x08000 /* MAP,AREA some specials that never contain
				    (directly or indirectly) other things than
				    special insertions */
#define Tgc_outer	0x10000 /* HTML,FRAMESET,FRAME,PLAINTEXT; */
#define Tgc_BODYlike	0x20000 /* BODY,BODYTEXT,NOFRAMES,TEXTFLOW; */
#define Tgc_HEADstuff	0x40000 /* HEAD,BASE,STYLE,TITLE; */
d95 6
a100 5
#define Tgf_endO	0x00001 /* end tag can be Omitted */
#define Tgf_startO	0x00002 /* start tag can be Omitted */
#define Tgf_mafse	0x00004 /* Make Attribute-Free Start-tag End instead
				      (if found invalid) */
#define Tgf_strict	0x00008 /* Ignore contained invalid elements,
d103 3
a105 3
#define Tgf_nreie	0x00010 /* Not Really Empty If Empty,
				      used by color style code */
#define Tgf_frecyc	0x00020 /* Pass element content on in a form that
d109 1
a109 1
#define Tgf_nolyspcl	0x00040 /* Don't generate lynx special characters
d114 13
a126 13
**		-----------------------------------------
**
**
**	name		is the string which comes after the tag opener "<".
**
**	attributes	points to a zero-terminated array
**			of attribute names.
**
**	litteral	determines how the SGML engine parses the characters
**			within the element.  If set, tag openers are ignored
**			except for that which opens a matching closing tag.
**
*/
d128 2
a129 2
struct _tag{
    char *	name;			/* The name of the tag */
d131 1
a131 1
    int		name_len;		/* The length of the name */
d134 1
a134 1
    BOOL	can_justify;		/* justification allowed?*/
d136 11
a146 11
    attr *	attributes;		/* The list of acceptable attributes */
    int		number_of_attributes;	/* Number of possible attributes */
    SGMLContent contents;		/* End only on end tag @@@@ */
    TagClass	tagclass,
	contains,	/* which classes of elements this one can contain directly */
	icontains,	/* which classes of elements this one can contain indirectly */
	contained,	/* in which classes can this tag be contained ? */
	icontained,	/* in which classes can this tag be indirectly contained ? */
	canclose;	/* which classes of elements can this one close
			   if something looks wrong ? */
    TagFlags	flags;
a148 1

d150 4
a153 4
**		---------------
**
**  Not the whole DTD, but all this parser uses of it.
*/
d155 7
a161 7
    HTTag *		tags;		/* Must be in strcmp order by name */
    int			number_of_tags;
    const char **	entity_names;	/* Must be in strcmp order by name */
    size_t		number_of_entities;
				/*  "entity_names" table probably unused,
				**  see comments in HTMLDTD.c near the top
				*/
a163 1

a167 1

d192 1
a192 1
typedef struct _HTStructuredClass{
d194 1
a194 1
	char*  name;				/* Just for diagnostics */
d196 1
a196 2
	void (*_free) (
		HTStructured*	me);
d198 19
a216 33
	void (*_abort) (
		HTStructured*	me,
		HTError		e);

	void (*put_character) (
		HTStructured*	me,
		char		ch);

	void (*put_string) (
		HTStructured*	me,
		const char *	str);

	void (*_write) (
		HTStructured*	me,
		const char *	str,
		int		len);

	int (*start_element) (
		HTStructured*	me,
		int		element_number,
		const BOOL*	attribute_present,
		const char**	attribute_value,
		int		charset,
		char **		include);

	int (*end_element) (
		HTStructured*	me,
		int		element_number,
		char **		include);

	int (*put_entity) (
		HTStructured*	me,
		int		entity_number);
d225 3
a227 3
extern BOOLEAN LYCheckForCSI (HTParentAnchor *anchor, char **url);
extern void LYDoCSI (char *url, const char *comment, char **csi);
extern BOOLEAN LYCommentHacks (HTParentAnchor *anchor, const char *comment);
d236 2
a237 4
extern HTTag * SGMLFindTag (
	const SGML_dtd *	dtd,
	const char *		string);

d245 10
a254 11
** On entry,
**	dtd		must point to a DTD structure as defined above
**	callbacks	must point to user routines.
**	callData	is returned in callbacks transparently.
** On exit,
**		The default tag starter has been processed.
*/
extern HTStream * SGML_new (
	const SGML_dtd *	dtd,
	HTParentAnchor *	anchor,
	HTStructured *		target);
d258 1
a258 1
#endif	/* SGML_H */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d157 1
a157 1
    CONST char **	entity_names;	/* Must be in strcmp order by name */
d198 2
a199 2
	void (*_free) PARAMS((
		HTStructured*	me));
d201 1
a201 1
	void (*_abort) PARAMS((
d203 1
a203 1
		HTError		e));
d205 1
a205 1
	void (*put_character) PARAMS((
d207 1
a207 1
		char		ch));
d209 1
a209 1
	void (*put_string) PARAMS((
d211 1
a211 1
		CONST char *	str));
d213 1
a213 1
	void (*_write) PARAMS((
d215 2
a216 2
		CONST char *	str,
		int		len));
d218 1
a218 1
	int (*start_element) PARAMS((
d221 2
a222 2
		CONST BOOL*	attribute_present,
		CONST char**	attribute_value,
d224 1
a224 1
		char **		include));
d226 1
a226 1
	int (*end_element) PARAMS((
d229 1
a229 1
		char **		include));
d231 1
a231 1
	int (*put_entity) PARAMS((
d233 1
a233 1
		int		entity_number));
d242 3
a244 3
extern BOOLEAN LYCheckForCSI PARAMS((HTParentAnchor *anchor, char **url));
extern void LYDoCSI PARAMS((char *url, CONST char *comment, char **csi));
extern BOOLEAN LYCommentHacks PARAMS((HTParentAnchor *anchor, CONST char *comment));
d253 3
a255 3
extern HTTag * SGMLFindTag PARAMS((
	CONST SGML_dtd *	dtd,
	CONST char *		string));
d271 2
a272 2
extern HTStream * SGML_new PARAMS((
	CONST SGML_dtd *	dtd,
d274 1
a274 1
	HTStructured *		target));
d276 1
a276 1
extern CONST HTStreamClass SGMLParser;
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d22 1
d29 1
a29 1
typedef enum _SGMLContent {
d33 5
a37 2
    SGML_CDATA,	   /* Character data.  Recognize </ only. */
    SGML_RCDATA,   /* Replaceable character data.  Recognize </ and &ref; */
d40 6
a45 2
    SGML_ELEMENT,  /* Any data found will be returned as an error. */
    SGML_PCDATA	   /* Added by KW. */
d51 1
a51 1
#ifdef USE_PSRC
d80 1
a80 1
#define Tgc_APPLETlike	0x02000 /* APPLET,OBJECT,EMBED,SCRIPT */
d100 2
a101 1
				      don't pass them on */
d104 7
d132 3
d218 1
a218 1
	void (*start_element) PARAMS((
d226 1
a226 1
	void (*end_element) PARAMS((
d235 1
a235 1
}HTStructuredClass;
a278 4

/*

    */
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a21 1
#include <LYJustify.h>
a22 3
#ifdef __cplusplus
extern "C" {
#endif
d27 18
a44 23
 */ typedef enum {
	SGML_EMPTY,		/* No content. */
	SGML_LITTERAL,		/* Literal character data.  Recognize exact close tag only.
				   Old www server compatibility only!  Not SGML */
	SGML_CDATA,		/* Character data.  Recognize </ only.
				   (But we treat it just as SGML_LITTERAL.) */
	SGML_SCRIPT,		/* Like CDATA, but allow it to be a comment */
	SGML_RCDATA,		/* Replaceable character data. Should recognize </ and &ref;
				   (but we treat it like SGML_MIXED for old times' sake). */
	SGML_MIXED,		/* Elements and parsed character data.
				   Recognize all markup. */
	SGML_ELEMENT,		/* Any data found should be regarded as an error.
				   (But we treat it just like SGML_MIXED.) */
	SGML_PCDATA		/* Should contain no elements but &ref; is parsed.
				   (We treat it like SGML_CDATA wrt. contained tags
				   i.e. pass them on literally, i.e. like we should
				   treat SGML_RCDATA) (added by KW). */
    } SGMLContent;

    typedef struct {
	const char *name;	/* The name of the attribute */
#ifdef USE_PRETTYSRC
	char type;		/* code of the type of the attribute. Code
d47 1
a47 3
    } attr;

    typedef int TagClass;
d49 1
d51 5
a55 5
#define Tgc_FONTlike	0x00001	/* S,STRIKE,I,B,TT,U,BIG,SMALL,STYLE,BLINK;BR,TAB */
#define Tgc_EMlike	0x00002	/* EM,STRONG,DFN,CODE,SAMP,KBD,VAR,CITE,Q,INS,DEL,SPAN,.. */
#define Tgc_MATHlike	0x00004	/* SUB,SUP,MATH,COMMENT */
#define Tgc_Alike	0x00008	/* A */
#define Tgc_formula	0x00010	/* not used until math is supported better... */
d57 2
a58 2
#define Tgc_TRlike	0x00020	/* TR and similar */
#define Tgc_SELECTlike	0x00040	/* SELECT,INPUT,TEXTAREA(,...) */
d60 10
a69 10
#define Tgc_FORMlike	0x00080	/* FORM itself */
#define Tgc_Plike	0x00100	/* P,H1..H6,... structures containing text or
				   insertion but not other structures */
#define Tgc_DIVlike	0x00200	/* ADDRESS,FIG,BDO,NOTE,FN,DIV,CENTER;FIG
				   structures which can contain other structures */
#define Tgc_LIlike	0x00400	/* LH,LI,DT,DD;TH,TD structure-like, only valid
				   within certain other structures */
#define Tgc_ULlike	0x00800	/* UL,OL,DL,DIR,MENU;TABLE;XMP,LISTING
				   special in some way, cannot contain (parsed)
				   text directly */
d71 10
a80 10
#define Tgc_BRlike	0x01000	/* BR,IMG,TAB allowed in any text */
#define Tgc_APPLETlike	0x02000	/* APPLET,OBJECT,EMBED,SCRIPT;BUTTON */
#define Tgc_HRlike	0x04000	/* HR,MARQUEE can contain all kinds of things
				   and/or are not allowed (?) in running text */
#define Tgc_MAPlike	0x08000	/* MAP,AREA some specials that never contain
				   (directly or indirectly) other things than
				   special insertions */
#define Tgc_outer	0x10000	/* HTML,FRAMESET,FRAME,PLAINTEXT; */
#define Tgc_BODYlike	0x20000	/* BODY,BODYTEXT,NOFRAMES,TEXTFLOW; */
#define Tgc_HEADstuff	0x40000	/* HEAD,BASE,STYLE,TITLE; */
d86 9
a94 18
    typedef int TagFlags;

#define Tgf_endO	0x00001	/* end tag can be Omitted */
#define Tgf_startO	0x00002	/* start tag can be Omitted */
#define Tgf_mafse	0x00004	/* Make Attribute-Free Start-tag End instead
				   (if found invalid) */
#define Tgf_strict	0x00008	/* Ignore contained invalid elements,
				   don't pass them on; or other variant
				   handling for some content types */
#define Tgf_nreie	0x00010	/* Not Really Empty If Empty,
				   used by color style code */
#define Tgf_frecyc	0x00020	/* Pass element content on in a form that
				   allows recycling, i.e. don't translate to
				   output (display) character set yet (treat
				   content similar to attribute values) */
#define Tgf_nolyspcl	0x00040	/* Don't generate lynx special characters
				   for soft hyphen and various spaces (nbsp,
				   ensp,..) */
d97 16
a112 16
 *		-----------------------------------------
 *
 *
 *	name		is the string which comes after the tag opener "<".
 *
 *	attributes	points to a zero-terminated array
 *			of attribute names.
 *
 *	litteral	determines how the SGML engine parses the characters
 *			within the element.  If set, tag openers are ignored
 *			except for that which opens a matching closing tag.
 *
 */
    typedef struct _tag HTTag;
    struct _tag {
	const char *name;	/* The name of the tag */
d114 1
a114 1
	int name_len;		/* The length of the name */
d116 13
a128 15
#ifdef EXP_JUSTIFY_ELTS
	BOOL can_justify;	/* justification allowed? */
#endif
	attr *attributes;	/* The list of acceptable attributes */
	int number_of_attributes;	/* Number of possible attributes */
	SGMLContent contents;	/* End only on end tag @@@@ */
	TagClass tagclass;
	TagClass contains;	/* which classes of elements this one can contain directly */
	TagClass icontains;	/* which classes of elements this one can contain indirectly */
	TagClass contained;	/* in which classes can this tag be contained ? */
	TagClass icontained;	/* in which classes can this tag be indirectly contained ? */
	TagClass canclose;	/* which classes of elements can this one close
				   if something looks wrong ? */
	TagFlags flags;
    };
d131 14
a144 13
 *		---------------
 *
 *  Not the whole DTD, but all this parser uses of it.
 */
    typedef struct {
	HTTag *tags;		/* Must be in strcmp order by name */
	int number_of_tags;
	const char **entity_names;	/* Must be in strcmp order by name */
	size_t number_of_entities;
	/*  "entity_names" table probably unused,
	 *  see comments in HTMLDTD.c near the top
	 */
    } SGML_dtd;
d148 2
a149 1
    typedef struct _HTSGMLContext *HTSGMLContext;	/* Hidden */
d173 1
a173 3
    typedef struct _HTStructured HTStructured;

    typedef struct _HTStructuredClass {
d175 1
a175 1
	const char *name;	/* Just for diagnostics */
d177 1
a177 1
	void (*_free) (HTStructured * me);
d179 2
a180 1
	void (*_abort) (HTStructured * me, HTError e);
d182 33
a214 1
	void (*put_character) (HTStructured * me, char ch);
d216 1
a216 17
	void (*put_string) (HTStructured * me, const char *str);

	void (*_write) (HTStructured * me, const char *str,
			int len);

	int (*start_element) (HTStructured * me, int element_number,
			      const BOOL *attribute_present,
			      const char **attribute_value,
			      int charset,
			      char **include);

	int (*end_element) (HTStructured * me, int element_number,
			    char **include);

	int (*put_entity) (HTStructured * me, int entity_number);

    } HTStructuredClass;
d223 3
a225 3
    extern BOOLEAN LYCheckForCSI(HTParentAnchor *anchor, char **url);
    extern void LYDoCSI(char *url, const char *comment, char **csi);
    extern BOOLEAN LYCommentHacks(HTParentAnchor *anchor, const char *comment);
d234 4
a237 2
    extern HTTag *SGMLFindTag(const SGML_dtd * dtd,
			      const char *string);
d245 15
a259 10
 * On entry,
 *	dtd		must point to a DTD structure as defined above
 *	callbacks	must point to user routines.
 *	callData	is returned in callbacks transparently.
 * On exit,
 *		The default tag starter has been processed.
 */
    extern HTStream *SGML_new(const SGML_dtd * dtd,
			      HTParentAnchor *anchor,
			      HTStructured * target);
d261 1
a261 1
    extern const HTStreamClass SGMLParser;
d263 1
a263 4
#ifdef __cplusplus
}
#endif
#endif				/* SGML_H */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a21 1
#include <LYJustify.h>
d28 1
a28 1
typedef enum {
d32 2
a33 5
    SGML_CDATA,	   /* Character data.  Recognize </ only.
		      (But we treat it just as SGML_LITTERAL.) */
    SGML_SCRIPT,   /* Like CDATA, but allow it to be a comment */
    SGML_RCDATA,   /* Replaceable character data. Should recognize </ and &ref;
		      (but we treat it like SGML_MIXED for old times' sake). */
d36 2
a37 6
    SGML_ELEMENT,  /* Any data found should be regarded as an error.
		      (But we treat it just like SGML_MIXED.) */
    SGML_PCDATA	   /* Should contain no elements but &ref; is parsed.
		      (We treat it like SGML_CDATA wrt. contained tags
		      i.e. pass them on literally, i.e. like we should
		      treat SGML_RCDATA) (added by KW). */
d43 1
a43 1
#ifdef USE_PRETTYSRC
d72 1
a72 1
#define Tgc_APPLETlike	0x02000 /* APPLET,OBJECT,EMBED,SCRIPT;BUTTON */
d92 1
a92 2
				   don't pass them on; or other variant
				   handling for some content types */
a94 7
#define Tgf_frecyc	0x00020 /* Pass element content on in a form that
				   allows recycling, i.e. don't translate to
				   output (display) character set yet (treat
				   content similar to attribute values) */
#define Tgf_nolyspcl	0x00040 /* Don't generate lynx special characters
				   for soft hyphen and various spaces (nbsp,
				   ensp,..) */
a115 3
#ifdef EXP_JUSTIFY_ELTS
    BOOL	can_justify;		/* justification allowed?*/
#endif
d199 1
a199 1
	int (*start_element) PARAMS((
d207 1
a207 1
	int (*end_element) PARAMS((
d216 1
a216 1
} HTStructuredClass;
d260 4
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d157 1
a157 1
    const char **	entity_names;	/* Must be in strcmp order by name */
d198 2
a199 2
	void (*_free) (
		HTStructured*	me);
d201 1
a201 1
	void (*_abort) (
d203 1
a203 1
		HTError		e);
d205 1
a205 1
	void (*put_character) (
d207 1
a207 1
		char		ch);
d209 1
a209 1
	void (*put_string) (
d211 1
a211 1
		const char *	str);
d213 1
a213 1
	void (*_write) (
d215 2
a216 2
		const char *	str,
		int		len);
d218 1
a218 1
	int (*start_element) (
d221 2
a222 2
		const BOOL*	attribute_present,
		const char**	attribute_value,
d224 1
a224 1
		char **		include);
d226 1
a226 1
	int (*end_element) (
d229 1
a229 1
		char **		include);
d231 1
a231 1
	int (*put_entity) (
d233 1
a233 1
		int		entity_number);
d242 3
a244 3
extern BOOLEAN LYCheckForCSI (HTParentAnchor *anchor, char **url);
extern void LYDoCSI (char *url, const char *comment, char **csi);
extern BOOLEAN LYCommentHacks (HTParentAnchor *anchor, const char *comment);
d253 3
a255 3
extern HTTag * SGMLFindTag (
	const SGML_dtd *	dtd,
	const char *		string);
d271 2
a272 2
extern HTStream * SGML_new (
	const SGML_dtd *	dtd,
d274 1
a274 1
	HTStructured *		target);
d276 1
a276 1
extern const HTStreamClass SGMLParser;
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d30 16
a45 16
    SGML_EMPTY,			/* No content. */
    SGML_LITTERAL,		/* Literal character data.  Recognize exact close tag only.
				   Old www server compatibility only!  Not SGML */
    SGML_CDATA,			/* Character data.  Recognize </ only.
				   (But we treat it just as SGML_LITTERAL.) */
    SGML_SCRIPT,		/* Like CDATA, but allow it to be a comment */
    SGML_RCDATA,		/* Replaceable character data. Should recognize </ and &ref;
				   (but we treat it like SGML_MIXED for old times' sake). */
    SGML_MIXED,			/* Elements and parsed character data.
				   Recognize all markup. */
    SGML_ELEMENT,		/* Any data found should be regarded as an error.
				   (But we treat it just like SGML_MIXED.) */
    SGML_PCDATA			/* Should contain no elements but &ref; is parsed.
				   (We treat it like SGML_CDATA wrt. contained tags
				   i.e. pass them on literally, i.e. like we should
				   treat SGML_RCDATA) (added by KW). */
d48 1
d50 1
a50 1
    char *name;			/* The (constant) name of the attribute */
d52 1
a52 1
    char type;			/* code of the type of the attribute. Code
a57 1

d59 5
a63 5
#define Tgc_FONTlike	0x00001	/* S,STRIKE,I,B,TT,U,BIG,SMALL,STYLE,BLINK;BR,TAB */
#define Tgc_EMlike	0x00002	/* EM,STRONG,DFN,CODE,SAMP,KBD,VAR,CITE,Q,INS,DEL,SPAN,.. */
#define Tgc_MATHlike	0x00004	/* SUB,SUP,MATH,COMMENT */
#define Tgc_Alike	0x00008	/* A */
#define Tgc_formula	0x00010	/* not used until math is supported better... */
d65 2
a66 2
#define Tgc_TRlike	0x00020	/* TR and similar */
#define Tgc_SELECTlike	0x00040	/* SELECT,INPUT,TEXTAREA(,...) */
d68 10
a77 10
#define Tgc_FORMlike	0x00080	/* FORM itself */
#define Tgc_Plike	0x00100	/* P,H1..H6,... structures containing text or
				   insertion but not other structures */
#define Tgc_DIVlike	0x00200	/* ADDRESS,FIG,BDO,NOTE,FN,DIV,CENTER;FIG
				   structures which can contain other structures */
#define Tgc_LIlike	0x00400	/* LH,LI,DT,DD;TH,TD structure-like, only valid
				   within certain other structures */
#define Tgc_ULlike	0x00800	/* UL,OL,DL,DIR,MENU;TABLE;XMP,LISTING
				   special in some way, cannot contain (parsed)
				   text directly */
d79 10
a88 10
#define Tgc_BRlike	0x01000	/* BR,IMG,TAB allowed in any text */
#define Tgc_APPLETlike	0x02000	/* APPLET,OBJECT,EMBED,SCRIPT;BUTTON */
#define Tgc_HRlike	0x04000	/* HR,MARQUEE can contain all kinds of things
				   and/or are not allowed (?) in running text */
#define Tgc_MAPlike	0x08000	/* MAP,AREA some specials that never contain
				   (directly or indirectly) other things than
				   special insertions */
#define Tgc_outer	0x10000	/* HTML,FRAMESET,FRAME,PLAINTEXT; */
#define Tgc_BODYlike	0x20000	/* BODY,BODYTEXT,NOFRAMES,TEXTFLOW; */
#define Tgc_HEADstuff	0x40000	/* HEAD,BASE,STYLE,TITLE; */
d95 5
a99 6

#define Tgf_endO	0x00001	/* end tag can be Omitted */
#define Tgf_startO	0x00002	/* start tag can be Omitted */
#define Tgf_mafse	0x00004	/* Make Attribute-Free Start-tag End instead
				   (if found invalid) */
#define Tgf_strict	0x00008	/* Ignore contained invalid elements,
d102 3
a104 3
#define Tgf_nreie	0x00010	/* Not Really Empty If Empty,
				   used by color style code */
#define Tgf_frecyc	0x00020	/* Pass element content on in a form that
d108 1
a108 1
#define Tgf_nolyspcl	0x00040	/* Don't generate lynx special characters
d113 13
a125 13
 *		-----------------------------------------
 *
 *
 *	name		is the string which comes after the tag opener "<".
 *
 *	attributes	points to a zero-terminated array
 *			of attribute names.
 *
 *	litteral	determines how the SGML engine parses the characters
 *			within the element.  If set, tag openers are ignored
 *			except for that which opens a matching closing tag.
 *
 */
d127 2
a128 2
struct _tag {
    char *name;			/* The name of the tag */
d130 1
a130 1
    int name_len;		/* The length of the name */
d133 1
a133 1
    BOOL can_justify;		/* justification allowed? */
d135 11
a145 11
    attr *attributes;		/* The list of acceptable attributes */
    int number_of_attributes;	/* Number of possible attributes */
    SGMLContent contents;	/* End only on end tag @@@@ */
    TagClass tagclass;
    TagClass contains;		/* which classes of elements this one can contain directly */
    TagClass icontains;		/* which classes of elements this one can contain indirectly */
    TagClass contained;		/* in which classes can this tag be contained ? */
    TagClass icontained;	/* in which classes can this tag be indirectly contained ? */
    TagClass canclose;		/* which classes of elements can this one close
				   if something looks wrong ? */
    TagFlags flags;
d148 1
d150 4
a153 4
 *		---------------
 *
 *  Not the whole DTD, but all this parser uses of it.
 */
d155 7
a161 7
    HTTag *tags;		/* Must be in strcmp order by name */
    int number_of_tags;
    const char **entity_names;	/* Must be in strcmp order by name */
    size_t number_of_entities;
    /*  "entity_names" table probably unused,
     *  see comments in HTMLDTD.c near the top
     */
d164 1
d169 1
d194 1
a194 1
typedef struct _HTStructuredClass {
d196 1
a196 1
    char *name;			/* Just for diagnostics */
d198 2
a199 1
    void (*_free) (HTStructured * me);
d201 33
a233 19
    void (*_abort) (HTStructured * me, HTError e);

    void (*put_character) (HTStructured * me, char ch);

    void (*put_string) (HTStructured * me, const char *str);

    void (*_write) (HTStructured * me, const char *str,
		    int len);

    int (*start_element) (HTStructured * me, int element_number,
			  const BOOL *attribute_present,
			  const char **attribute_value,
			  int charset,
			  char **include);

    int (*end_element) (HTStructured * me, int element_number,
			char **include);

    int (*put_entity) (HTStructured * me, int entity_number);
d242 3
a244 3
extern BOOLEAN LYCheckForCSI(HTParentAnchor *anchor, char **url);
extern void LYDoCSI(char *url, const char *comment, char **csi);
extern BOOLEAN LYCommentHacks(HTParentAnchor *anchor, const char *comment);
d253 4
a256 2
extern HTTag *SGMLFindTag(const SGML_dtd * dtd,
			  const char *string);
d264 11
a274 10
 * On entry,
 *	dtd		must point to a DTD structure as defined above
 *	callbacks	must point to user routines.
 *	callData	is returned in callbacks transparently.
 * On exit,
 *		The default tag starter has been processed.
 */
extern HTStream *SGML_new(const SGML_dtd * dtd,
			  HTParentAnchor *anchor,
			  HTStructured * target);
d278 1
a278 1
#endif /* SGML_H */
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a21 1
#include <LYJustify.h>
d28 1
a28 1
typedef enum {
d32 2
a33 5
    SGML_CDATA,	   /* Character data.  Recognize </ only.
		      (But we treat it just as SGML_LITTERAL.) */
    SGML_SCRIPT,   /* Like CDATA, but allow it to be a comment */
    SGML_RCDATA,   /* Replaceable character data. Should recognize </ and &ref;
		      (but we treat it like SGML_MIXED for old times' sake). */
d36 2
a37 6
    SGML_ELEMENT,  /* Any data found should be regarded as an error.
		      (But we treat it just like SGML_MIXED.) */
    SGML_PCDATA	   /* Should contain no elements but &ref; is parsed.
		      (We treat it like SGML_CDATA wrt. contained tags
		      i.e. pass them on literally, i.e. like we should
		      treat SGML_RCDATA) (added by KW). */
d43 1
a43 1
#ifdef USE_PRETTYSRC
d72 1
a72 1
#define Tgc_APPLETlike	0x02000 /* APPLET,OBJECT,EMBED,SCRIPT;BUTTON */
d92 1
a92 2
				   don't pass them on; or other variant
				   handling for some content types */
a94 7
#define Tgf_frecyc	0x00020 /* Pass element content on in a form that
				   allows recycling, i.e. don't translate to
				   output (display) character set yet (treat
				   content similar to attribute values) */
#define Tgf_nolyspcl	0x00040 /* Don't generate lynx special characters
				   for soft hyphen and various spaces (nbsp,
				   ensp,..) */
a115 3
#ifdef EXP_JUSTIFY_ELTS
    BOOL	can_justify;		/* justification allowed?*/
#endif
d199 1
a199 1
	int (*start_element) PARAMS((
d207 1
a207 1
	int (*end_element) PARAMS((
d216 1
a216 1
} HTStructuredClass;
@

